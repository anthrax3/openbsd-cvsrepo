head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.4
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.21.0.12
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.8
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.4
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.22
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.20
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.18
	OPENBSD_5_0:1.10.0.16
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.14
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.12
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.8
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.10
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.6
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.16
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.14
	OPENBSD_2_8:1.5.0.12
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.10
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2017.08.22.15.04.18;	author bluhm;	state Exp;
branches;
next	1.21;
commitid	cibi0WiADELXiHyq;

1.21
date	2014.09.09.03.41.08;	author guenther;	state Exp;
branches;
next	1.20;
commitid	VR4fCtOZMbshOip1;

1.20
date	2014.07.22.07.30.24;	author jsg;	state Exp;
branches;
next	1.19;
commitid	5F2TXUtxGWuYgYJc;

1.19
date	2014.07.20.12.08.55;	author guenther;	state Exp;
branches;
next	1.18;
commitid	S3moNyJOYK9CLzJu;

1.18
date	2014.07.20.09.20.48;	author guenther;	state Exp;
branches;
next	1.17;
commitid	BlPcwczsfw7yNVQ4;

1.17
date	2014.07.20.08.56.47;	author guenther;	state Exp;
branches;
next	1.16;
commitid	uvklKjlkNqUA10lW;

1.16
date	2014.07.20.08.12.46;	author guenther;	state Exp;
branches;
next	1.15;
commitid	qbZdS8s4KEeVt81G;

1.15
date	2014.07.20.07.34.43;	author guenther;	state Exp;
branches;
next	1.14;
commitid	bJI5k8jINaMf9lH1;

1.14
date	2014.07.20.06.39.41;	author guenther;	state Exp;
branches;
next	1.13;
commitid	2c9hYJDg2dE2R3T8;

1.13
date	2014.07.20.05.22.02;	author guenther;	state Exp;
branches;
next	1.12;
commitid	mkPeU1MBN7ewMEUq;

1.12
date	2014.07.19.23.50.38;	author guenther;	state Exp;
branches;
next	1.11;
commitid	J1fNmylmVMpKGeua;

1.11
date	2013.04.21.09.51.24;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.17.20.10.44;	author chl;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.02.56.18;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.03.12.05.58;	author hin;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.01.06.59.17;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	98.03.12.04.57.47;	author art;	state Exp;
branches;
next	1.4;

1.4
date	98.02.16.04.59.04;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	96.12.12.11.24.08;	author robin;	state Exp;
branches;
next	1.2;

1.2
date	96.03.27.19.33.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.15;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.15;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Use a boolean variable to remember the quotation level instead of
doing string pointer arithmetic.  Fixes a clang warning.
OK otto@@ tom@@
@
text
@/*	$OpenBSD: utilities.c,v 1.21 2014/09/09 03:41:08 guenther Exp $	*/
/*	$NetBSD: utilities.c,v 1.5 1996/02/28 21:04:21 thorpej Exp $	*/

/*
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* these three defines affect the behavior of <arpa/telnet.h> */
#define	TELOPTS
#define	TELCMDS
#define	SLC_NAMES

#include "telnet_locl.h"

#include <arpa/telnet.h>
#include <ctype.h>
#include <limits.h>
#include <poll.h>
#include <stdlib.h>
#include <string.h>

static FILE	*NetTrace = NULL;
int	prettydump;

/*
 * upcase()
 *
 *	Upcase (in place) the argument.
 */

void
upcase(char *argument)
{
	int c;

	while ((c = *argument) != '\0')
		*argument++ = toupper((unsigned char)c);
}

/*
 * The following are routines used to print out debugging information.
 */

char NetTraceFile[PATH_MAX] = "(standard output)";

void
SetNetTrace(const char *file)
{
    if (NetTrace && NetTrace != stdout)
	fclose(NetTrace);
    if (file && (strcmp(file, "-") != 0)) {
	NetTrace = fopen(file, "we");
	if (NetTrace) {
	    strlcpy(NetTraceFile, file, sizeof(NetTraceFile));
	    return;
	}
	fprintf(stderr, "Cannot open %s.\n", file);
    }
    NetTrace = stdout;
    strlcpy(NetTraceFile, "(standard output)", sizeof(NetTraceFile));
}

void
Dump(char direction, unsigned char *buffer, int length)
{
#   define BYTES_PER_LINE	32
#   define min(x,y)	((x<y)? x:y)
    unsigned char *pThis;
    int offset;

    offset = 0;

    while (length) {
	/* print one line */
	fprintf(NetTrace, "%c 0x%x\t", direction, offset);
	pThis = buffer;
	if (prettydump) {
	    buffer = buffer + min(length, BYTES_PER_LINE/2);
	    while (pThis < buffer) {
		fprintf(NetTrace, "%c%.2x",
		    (((*pThis)&0xff) == 0xff) ? '*' : ' ',
		    (*pThis)&0xff);
		pThis++;
	    }
	    length -= BYTES_PER_LINE/2;
	    offset += BYTES_PER_LINE/2;
	} else {
	    buffer = buffer + min(length, BYTES_PER_LINE);
	    while (pThis < buffer) {
		fprintf(NetTrace, "%.2x", (*pThis)&0xff);
		pThis++;
	    }
	    length -= BYTES_PER_LINE;
	    offset += BYTES_PER_LINE;
	}
	if (NetTrace == stdout) {
	    fprintf(NetTrace, "\r\n");
	} else {
	    fprintf(NetTrace, "\n");
	}
	if (length < 0) {
	    fflush(NetTrace);
	    return;
	}
	/* find next unique line */
    }
    fflush(NetTrace);
}

void
printoption(char *direction, int cmd, int option)
{
	if (!showoptions)
		return;
	if (cmd == IAC) {
		if (TELCMD_OK(option))
		    fprintf(NetTrace, "%s IAC %s", direction, TELCMD(option));
		else
		    fprintf(NetTrace, "%s IAC %d", direction, option);
	} else {
		char *fmt;
		fmt = (cmd == WILL) ? "WILL" : (cmd == WONT) ? "WONT" :
			(cmd == DO) ? "DO" : (cmd == DONT) ? "DONT" : 0;
		if (fmt) {
		    fprintf(NetTrace, "%s %s ", direction, fmt);
		    if (TELOPT_OK(option))
			fprintf(NetTrace, "%s", TELOPT(option));
		    else if (option == TELOPT_EXOPL)
			fprintf(NetTrace, "EXOPL");
		    else
			fprintf(NetTrace, "%d", option);
		} else
		    fprintf(NetTrace, "%s %d %d", direction, cmd, option);
	}
	if (NetTrace == stdout) {
	    fprintf(NetTrace, "\r\n");
	    fflush(NetTrace);
	} else {
	    fprintf(NetTrace, "\n");
	}
	return;
}

void
optionstatus(void)
{
    int i;

    for (i = 0; i < 256; i++) {
	if (do_dont_resp[i]) {
	    if (TELOPT_OK(i))
		printf("resp DO_DONT %s: %d\n", TELOPT(i), do_dont_resp[i]);
	    else if (TELCMD_OK(i))
		printf("resp DO_DONT %s: %d\n", TELCMD(i), do_dont_resp[i]);
	    else
		printf("resp DO_DONT %d: %d\n", i,
				do_dont_resp[i]);
	    if (my_want_state_is_do(i)) {
		if (TELOPT_OK(i))
		    printf("want DO   %s\n", TELOPT(i));
		else if (TELCMD_OK(i))
		    printf("want DO   %s\n", TELCMD(i));
		else
		    printf("want DO   %d\n", i);
	    } else {
		if (TELOPT_OK(i))
		    printf("want DONT %s\n", TELOPT(i));
		else if (TELCMD_OK(i))
		    printf("want DONT %s\n", TELCMD(i));
		else
		    printf("want DONT %d\n", i);
	    }
	} else {
	    if (my_state_is_do(i)) {
		if (TELOPT_OK(i))
		    printf("     DO   %s\n", TELOPT(i));
		else if (TELCMD_OK(i))
		    printf("     DO   %s\n", TELCMD(i));
		else
		    printf("     DO   %d\n", i);
	    }
	}
	if (will_wont_resp[i]) {
	    if (TELOPT_OK(i))
		printf("resp WILL_WONT %s: %d\n", TELOPT(i), will_wont_resp[i]);
	    else if (TELCMD_OK(i))
		printf("resp WILL_WONT %s: %d\n", TELCMD(i), will_wont_resp[i]);
	    else
		printf("resp WILL_WONT %d: %d\n",
				i, will_wont_resp[i]);
	    if (my_want_state_is_will(i)) {
		if (TELOPT_OK(i))
		    printf("want WILL %s\n", TELOPT(i));
		else if (TELCMD_OK(i))
		    printf("want WILL %s\n", TELCMD(i));
		else
		    printf("want WILL %d\n", i);
	    } else {
		if (TELOPT_OK(i))
		    printf("want WONT %s\n", TELOPT(i));
		else if (TELCMD_OK(i))
		    printf("want WONT %s\n", TELCMD(i));
		else
		    printf("want WONT %d\n", i);
	    }
	} else {
	    if (my_state_is_will(i)) {
		if (TELOPT_OK(i))
		    printf("     WILL %s\n", TELOPT(i));
		else if (TELCMD_OK(i))
		    printf("     WILL %s\n", TELCMD(i));
		else
		    printf("     WILL %d\n", i);
	    }
	}
    }

}

void
printsub(char direction,	/* '<' or '>' */
    unsigned char *pointer,	/* where suboption data sits */
    int length)			/* length of suboption data */
{
    int i;

    if (showoptions || direction == 0 ||
	(want_status_response && (pointer[0] == TELOPT_STATUS))) {
	if (direction) {
	    fprintf(NetTrace, "%s IAC SB ",
				(direction == '<')? "RCVD":"SENT");
	    if (length >= 3) {
		int j;

		i = pointer[length-2];
		j = pointer[length-1];

		if (i != IAC || j != SE) {
		    fprintf(NetTrace, "(terminated by ");
		    if (TELOPT_OK(i))
			fprintf(NetTrace, "%s ", TELOPT(i));
		    else if (TELCMD_OK(i))
			fprintf(NetTrace, "%s ", TELCMD(i));
		    else
			fprintf(NetTrace, "%d ", i);
		    if (TELOPT_OK(j))
			fprintf(NetTrace, "%s", TELOPT(j));
		    else if (TELCMD_OK(j))
			fprintf(NetTrace, "%s", TELCMD(j));
		    else
			fprintf(NetTrace, "%d", j);
		    fprintf(NetTrace, ", not IAC SE!) ");
		}
	    }
	    length -= 2;
	}
	if (length < 1) {
	    fprintf(NetTrace, "(Empty suboption??\?)");
	    if (NetTrace == stdout)
		fflush(NetTrace);
	    return;
	}
	switch (pointer[0]) {
	case TELOPT_TTYPE:
	    fprintf(NetTrace, "TERMINAL-TYPE ");
	    switch (pointer[1]) {
	    case TELQUAL_IS:
		fprintf(NetTrace, "IS \"%.*s\"", length-2, (char *)pointer+2);
		break;
	    case TELQUAL_SEND:
		fprintf(NetTrace, "SEND");
		break;
	    default:
		fprintf(NetTrace,
				"- unknown qualifier %d (0x%x).",
				pointer[1], pointer[1]);
	    }
	    break;
	case TELOPT_TSPEED:
	    fprintf(NetTrace, "TERMINAL-SPEED");
	    if (length < 2) {
		fprintf(NetTrace, " (empty suboption??\?)");
		break;
	    }
	    switch (pointer[1]) {
	    case TELQUAL_IS:
		fprintf(NetTrace, " IS ");
		fprintf(NetTrace, "%.*s", length-2, (char *)pointer+2);
		break;
	    default:
		if (pointer[1] == 1)
		    fprintf(NetTrace, " SEND");
		else
		    fprintf(NetTrace, " %d (unknown)", pointer[1]);
		for (i = 2; i < length; i++)
		    fprintf(NetTrace, " ?%d?", pointer[i]);
		break;
	    }
	    break;

	case TELOPT_LFLOW:
	    fprintf(NetTrace, "TOGGLE-FLOW-CONTROL");
	    if (length < 2) {
		fprintf(NetTrace, " (empty suboption??\?)");
		break;
	    }
	    switch (pointer[1]) {
	    case LFLOW_OFF:
		fprintf(NetTrace, " OFF"); break;
	    case LFLOW_ON:
		fprintf(NetTrace, " ON"); break;
	    case LFLOW_RESTART_ANY:
		fprintf(NetTrace, " RESTART-ANY"); break;
	    case LFLOW_RESTART_XON:
		fprintf(NetTrace, " RESTART-XON"); break;
	    default:
		fprintf(NetTrace, " %d (unknown)", pointer[1]);
	    }
	    for (i = 2; i < length; i++)
		fprintf(NetTrace, " ?%d?", pointer[i]);
	    break;

	case TELOPT_NAWS:
	    fprintf(NetTrace, "NAWS");
	    if (length < 2) {
		fprintf(NetTrace, " (empty suboption??\?)");
		break;
	    }
	    if (length == 2) {
		fprintf(NetTrace, " ?%d?", pointer[1]);
		break;
	    }
	    fprintf(NetTrace, " %d %d (%d)",
		pointer[1], pointer[2], (pointer[1]<<8) | pointer[2]);
	    if (length == 4) {
		fprintf(NetTrace, " ?%d?", pointer[3]);
		break;
	    }
	    fprintf(NetTrace, " %d %d (%d)",
		pointer[3], pointer[4], (pointer[3]<<8) | pointer[4]);
	    for (i = 5; i < length; i++)
		fprintf(NetTrace, " ?%d?", pointer[i]);
	    break;

	case TELOPT_LINEMODE:
	    fprintf(NetTrace, "LINEMODE ");
	    if (length < 2) {
		fprintf(NetTrace, " (empty suboption??\?)");
		break;
	    }
	    switch (pointer[1]) {
	    case WILL:
		fprintf(NetTrace, "WILL ");
		goto common;
	    case WONT:
		fprintf(NetTrace, "WONT ");
		goto common;
	    case DO:
		fprintf(NetTrace, "DO ");
		goto common;
	    case DONT:
		fprintf(NetTrace, "DONT ");
	    common:
		if (length < 3) {
		    fprintf(NetTrace, "(no option??\?)");
		    break;
		}
		switch (pointer[2]) {
		case LM_FORWARDMASK:
		    fprintf(NetTrace, "Forward Mask");
		    for (i = 3; i < length; i++)
			fprintf(NetTrace, " %x", pointer[i]);
		    break;
		default:
		    fprintf(NetTrace, "%d (unknown)", pointer[2]);
		    for (i = 3; i < length; i++)
			fprintf(NetTrace, " %d", pointer[i]);
		    break;
		}
		break;

	    case LM_SLC:
		fprintf(NetTrace, "SLC");
		for (i = 2; i < length - 2; i += 3) {
		    if (SLC_NAME_OK(pointer[i+SLC_FUNC]))
			fprintf(NetTrace, " %s", SLC_NAME(pointer[i+SLC_FUNC]));
		    else
			fprintf(NetTrace, " %d", pointer[i+SLC_FUNC]);
		    switch (pointer[i+SLC_FLAGS]&SLC_LEVELBITS) {
		    case SLC_NOSUPPORT:
			fprintf(NetTrace, " NOSUPPORT"); break;
		    case SLC_CANTCHANGE:
			fprintf(NetTrace, " CANTCHANGE"); break;
		    case SLC_VARIABLE:
			fprintf(NetTrace, " VARIABLE"); break;
		    case SLC_DEFAULT:
			fprintf(NetTrace, " DEFAULT"); break;
		    }
		    fprintf(NetTrace, "%s%s%s",
			pointer[i+SLC_FLAGS]&SLC_ACK ? "|ACK" : "",
			pointer[i+SLC_FLAGS]&SLC_FLUSHIN ? "|FLUSHIN" : "",
			pointer[i+SLC_FLAGS]&SLC_FLUSHOUT ? "|FLUSHOUT" : "");
		    if (pointer[i+SLC_FLAGS]& ~(SLC_ACK|SLC_FLUSHIN|
						SLC_FLUSHOUT| SLC_LEVELBITS))
			fprintf(NetTrace, "(0x%x)", pointer[i+SLC_FLAGS]);
		    fprintf(NetTrace, " %d;", pointer[i+SLC_VALUE]);
		    if ((pointer[i+SLC_VALUE] == IAC) &&
			(pointer[i+SLC_VALUE+1] == IAC))
				i++;
		}
		for (; i < length; i++)
		    fprintf(NetTrace, " ?%d?", pointer[i]);
		break;

	    case LM_MODE:
		fprintf(NetTrace, "MODE ");
		if (length < 3) {
		    fprintf(NetTrace, "(no mode??\?)");
		    break;
		}
		{
		    char tbuf[64];
		    snprintf(tbuf, sizeof(tbuf),
			     "%s%s%s%s%s",
			     pointer[2]&MODE_EDIT ? "|EDIT" : "",
			     pointer[2]&MODE_TRAPSIG ? "|TRAPSIG" : "",
			     pointer[2]&MODE_SOFT_TAB ? "|SOFT_TAB" : "",
			     pointer[2]&MODE_LIT_ECHO ? "|LIT_ECHO" : "",
			     pointer[2]&MODE_ACK ? "|ACK" : "");
		    fprintf(NetTrace, "%s", tbuf[1] ? &tbuf[1] : "0");
		}
		if (pointer[2]&~(MODE_MASK))
		    fprintf(NetTrace, " (0x%x)", pointer[2]);
		for (i = 3; i < length; i++)
		    fprintf(NetTrace, " ?0x%x?", pointer[i]);
		break;
	    default:
		fprintf(NetTrace, "%d (unknown)", pointer[1]);
		for (i = 2; i < length; i++)
		    fprintf(NetTrace, " %d", pointer[i]);
	    }
	    break;

	case TELOPT_STATUS: {
	    char *cp;
	    int j, k;

	    fprintf(NetTrace, "STATUS");

	    switch (pointer[1]) {
	    default:
		if (pointer[1] == TELQUAL_SEND)
		    fprintf(NetTrace, " SEND");
		else
		    fprintf(NetTrace, " %d (unknown)", pointer[1]);
		for (i = 2; i < length; i++)
		    fprintf(NetTrace, " ?%d?", pointer[i]);
		break;
	    case TELQUAL_IS:
		if (--want_status_response < 0)
		    want_status_response = 0;
		if (NetTrace == stdout)
		    fprintf(NetTrace, " IS\r\n");
		else
		    fprintf(NetTrace, " IS\n");

		for (i = 2; i < length; i++) {
		    switch(pointer[i]) {
		    case DO:	cp = "DO"; goto common2;
		    case DONT:	cp = "DONT"; goto common2;
		    case WILL:	cp = "WILL"; goto common2;
		    case WONT:	cp = "WONT"; goto common2;
		    common2:
			i++;
			if (TELOPT_OK(pointer[i]))
			    fprintf(NetTrace, " %s %s", cp, TELOPT(pointer[i]));
			else
			    fprintf(NetTrace, " %s %d", cp, pointer[i]);

			if (NetTrace == stdout)
			    fprintf(NetTrace, "\r\n");
			else
			    fprintf(NetTrace, "\n");
			break;

		    case SB:
			fprintf(NetTrace, " SB ");
			i++;
			j = k = i;
			while (j < length) {
			    if (pointer[j] == SE) {
				if (j+1 == length)
				    break;
				if (pointer[j+1] == SE)
				    j++;
				else
				    break;
			    }
			    pointer[k++] = pointer[j++];
			}
			printsub(0, &pointer[i], k - i);
			if (i < length) {
			    fprintf(NetTrace, " SE");
			    i = j;
			} else
			    i = j - 1;

			if (NetTrace == stdout)
			    fprintf(NetTrace, "\r\n");
			else
			    fprintf(NetTrace, "\n");

			break;

		    default:
			fprintf(NetTrace, " %d", pointer[i]);
			break;
		    }
		}
		break;
	    }
	    break;
	  }

	case TELOPT_XDISPLOC:
	    fprintf(NetTrace, "X-DISPLAY-LOCATION ");
	    switch (pointer[1]) {
	    case TELQUAL_IS:
		fprintf(NetTrace, "IS \"%.*s\"", length-2, (char *)pointer+2);
		break;
	    case TELQUAL_SEND:
		fprintf(NetTrace, "SEND");
		break;
	    default:
		fprintf(NetTrace, "- unknown qualifier %d (0x%x).",
				pointer[1], pointer[1]);
	    }
	    break;

	case TELOPT_NEW_ENVIRON:
	    fprintf(NetTrace, "NEW-ENVIRON ");
	    switch (pointer[1]) {
	    case TELQUAL_IS:
		fprintf(NetTrace, "IS ");
		goto env_common;
	    case TELQUAL_SEND:
		fprintf(NetTrace, "SEND ");
		goto env_common;
	    case TELQUAL_INFO:
		fprintf(NetTrace, "INFO ");
	    env_common:
		{
		    int quote = 0;
		    for (i = 2; i < length; i++ ) {
			switch (pointer[i]) {
			case NEW_ENV_VALUE:
			    fprintf(NetTrace, "%sVALUE ", quote ? "\" " : "");
			    quote = 0;
			    break;

			case NEW_ENV_VAR:
			    fprintf(NetTrace, "%sVAR ", quote ? "\" " : "");
			    quote = 0;
			    break;

			case ENV_ESC:
			    fprintf(NetTrace, "%sESC ", quote ? "\" " : "");
			    quote = 0;
			    break;

			case ENV_USERVAR:
			    fprintf(NetTrace, "%sUSERVAR ", quote ? "\" " : "");
			    quote = 0;
			    break;

			default:
			    if (isprint((unsigned char)pointer[i]) &&
				pointer[i] != '"') {
				    fprintf(NetTrace, "%s%c",
					quote ? "" : "\"", pointer[i]);
				    quote = 1;
			    } else {
				    fprintf(NetTrace, "%s%03o ",
					quote ? "\" " : "", pointer[i]);
				    quote = 0;
			    }
			    break;
			}
		    }
		    if (quote)
			putc('"', NetTrace);
		    break;
		}
	    }
	    break;

	default:
	    if (TELOPT_OK(pointer[0]))
		fprintf(NetTrace, "%s (unknown)", TELOPT(pointer[0]));
	    else
		fprintf(NetTrace, "%d (unknown)", pointer[0]);
	    for (i = 1; i < length; i++)
		fprintf(NetTrace, " %d", pointer[i]);
	    break;
	}
	if (direction) {
	    if (NetTrace == stdout)
		fprintf(NetTrace, "\r\n");
	    else
		fprintf(NetTrace, "\n");
	}
	if (NetTrace == stdout)
	    fflush(NetTrace);
    }
}

/* EmptyTerminal - called to make sure that the terminal buffer is empty.
 *			Note that we consider the buffer to run all the
 *			way to the kernel (thus the poll).
 */

void
EmptyTerminal(void)
{
    struct pollfd pfd[1];

    pfd[0].fd = tout;
    pfd[0].events = POLLOUT;

    if (TTYBYTES() == 0) {
	(void) poll(pfd, 1, INFTIM); /* wait for TTLOWAT */
    } else {
	while (TTYBYTES()) {
	    (void) ttyflush(0);
	    (void) poll(pfd, 1, INFTIM); /* wait for TTLOWAT */
	}
    }
}

void
SetForExit(void)
{
    setconnmode(0);
    do {
	(void)telrcv();			/* Process any incoming data */
	EmptyTerminal();
    } while (ring_full_count(&netiring));	/* While there is any */
    setcommandmode();
    fflush(stdout);
    fflush(stderr);
    setconnmode(0);
    EmptyTerminal();			/* Flush the path to the tty */
    setcommandmode();
}

void
Exit(int returnCode)
{
    SetForExit();
    exit(returnCode);
}

void
ExitString(char *string, int returnCode)
{
    SetForExit();
    fwrite(string, 1, strlen(string), stderr);
    exit(returnCode);
}
@


1.21
log
@Eliminate a pile of casts that were superfluous or wrong, or that were
the result of bad type choices, particularly (unsigned char *) vs
(const char *).  Also, use reallocarray().
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.20 2014/07/22 07:30:24 jsg Exp $	*/
d578 1
a578 1
		    int noquote = 2;
d582 2
a583 2
				fprintf(NetTrace, "\" VALUE " + noquote);
			    noquote = 2;
d587 2
a588 2
				fprintf(NetTrace, "\" VAR " + noquote);
			    noquote = 2;
d592 2
a593 2
			    fprintf(NetTrace, "\" ESC " + noquote);
			    noquote = 2;
d597 2
a598 2
			    fprintf(NetTrace, "\" USERVAR " + noquote);
			    noquote = 2;
d604 3
a606 5
				if (noquote) {
				    putc('"', NetTrace);
				    noquote = 0;
				}
				putc(pointer[i], NetTrace);
d608 3
a610 3
				fprintf(NetTrace, "\" %03o " + noquote,
							pointer[i]);
				noquote = 2;
d615 1
a615 1
		    if (!noquote)
@


1.20
log
@use ansi style function declarations
with suggestions from and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.19 2014/07/20 12:08:55 guenther Exp $	*/
d69 1
a69 1
unsigned char NetTraceFile[PATH_MAX] = "(standard output)";
d72 1
a72 1
SetNetTrace(char *file)
d76 2
a77 2
    if (file  && (strcmp(file, "-") != 0)) {
	NetTrace = fopen(file, "w");
d79 1
a79 1
	    strlcpy((char *)NetTraceFile, file, sizeof(NetTraceFile));
d85 1
a85 1
    strlcpy((char *)NetTraceFile, "(standard output)", sizeof(NetTraceFile));
d359 1
a359 2
		pointer[1], pointer[2],
		(int)((((unsigned int)pointer[1])<<8)|((unsigned int)pointer[2])));
d365 1
a365 2
		pointer[3], pointer[4],
		(int)((((unsigned int)pointer[3])<<8)|((unsigned int)pointer[4])));
d500 1
a500 1
			if (TELOPT_OK((int)pointer[i]))
@


1.19
log
@Eliminate silly call() routine that fakes up internal calls as if
the user typed in undocumented arguments by splitting two functions
and doing normal (shock!) C calls.

Move extern declarations to externs.h
Eliminate another function cast
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.18 2014/07/20 09:20:48 guenther Exp $	*/
d71 2
a72 3
    void
SetNetTrace(file)
    char *file;
d88 2
a89 5
    void
Dump(direction, buffer, length)
    char direction;
    unsigned char *buffer;
    int length;
d135 2
a136 5

	void
printoption(direction, cmd, option)
	char *direction;
	int cmd, option;
d169 2
a170 2
    void
optionstatus()
d245 4
a248 5
    void
printsub(direction, pointer, length)
    char direction;	/* '<' or '>' */
    unsigned char *pointer;	/* where suboption data sits */
    int		  length;	/* length of suboption data */
d651 2
a652 2
    void
EmptyTerminal()
d669 2
a670 2
    void
SetForExit()
d685 2
a686 3
    void
Exit(returnCode)
    int returnCode;
d692 2
a693 4
    void
ExitString(string, returnCode)
    char *string;
    int returnCode;
@


1.18
log
@Delete an insane chunk of code for handling broken poll() emulation.
Pass poll() INFTIM instead of -1
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.17 2014/07/20 08:56:47 guenther Exp $	*/
a179 1
    extern char will_wont_resp[], do_dont_resp[];
a258 1
    extern int want_status_response;
@


1.17
log
@Add prototypes to some function callbacks and fix the type errors that
this reveals.
Make NetTrace static to utilities.c
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.16 2014/07/20 08:12:46 guenther Exp $	*/
d670 1
a670 1
	(void) poll(pfd, 1, -1); /* wait for TTLOWAT */
d674 1
a674 1
	    (void) poll(pfd, 1, -1); /* wait for TTLOWAT */
@


1.16
log
@More encryption tentacles: intr_happened and intr_waiting vanish
Push more includes into .c files
Make ring.c only need ring.h
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.15 2014/07/20 07:34:43 guenther Exp $	*/
d47 1
a47 1
FILE	*NetTrace = 0;		/* Not in bss, since needs to stay */
@


1.15
log
@Don't depend on <sys/param.h> for MAXPATHLEN
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.14 2014/07/20 06:39:41 guenther Exp $	*/
d40 1
d44 2
@


1.14
log
@Correctly cast to unsigned char for ctype functions/macros
Push <ctype.h> and <unistd.h> into the .c files
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.13 2014/07/20 05:22:02 guenther Exp $	*/
d41 1
d66 1
a66 1
unsigned char NetTraceFile[MAXPATHLEN] = "(standard output)";
@


1.13
log
@Simplify #includes, start pushing them into the .c files, eliminate
extern declarations from .c files that duplicate those in .h files,
start marking functions with __dead
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.12 2014/07/19 23:50:38 guenther Exp $	*/
d39 2
d52 2
a53 3
    void
upcase(argument)
    char *argument;
d55 1
a55 1
    int c;
d57 2
a58 6
    while ((c = *argument) != 0) {
	if (islower(c)) {
	    *argument = toupper(c);
	}
	argument++;
    }
d610 2
a611 1
			    if (isprint(pointer[i]) && pointer[i] != '"') {
@


1.12
log
@Flense the telnet code base of unwanted ifdefs: authentication/encryption
tn3270, sgtty, pre-POSIX and other ancient system support, etc.  Brings up
to date the manpage with what we support.

ok matthieu@@ beck@@ jmc@@ millert@@ deraadt@@ okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.11 2013/04/21 09:51:24 millert Exp $	*/
d33 1
d39 1
@


1.11
log
@Convert select() to poll().  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.10 2007/10/17 20:10:44 chl Exp $	*/
a62 23
 * SetSockOpt()
 *
 * Compensate for differences in 4.2 and 4.3 systems.
 */

    int
SetSockOpt(fd, level, option, yesno)
    int fd, level, option, yesno;
{
#ifndef	NOT43
    return setsockopt(fd, level, option,
				(void *)&yesno, sizeof yesno);
#else	/* NOT43 */
    if (yesno == 0) {		/* Can't do that in 4.2! */
	fprintf(stderr, "Error: attempt to turn off an option 0x%x.\n",
				option);
	return -1;
    }
    return setsockopt(fd, level, option, 0, 0);
#endif	/* NOT43 */
}

/*
a256 3
#if defined(AUTHENTICATION) || defined(ENCRYPTION)
    char buf[512];
#endif
a378 139
#if	defined(AUTHENTICATION)
	case TELOPT_AUTHENTICATION:
	    fprintf(NetTrace, "AUTHENTICATION");
	    if (length < 2) {
		fprintf(NetTrace, " (empty suboption??\?)");
		break;
	    }
	    switch (pointer[1]) {
	    case TELQUAL_REPLY:
	    case TELQUAL_IS:
		fprintf(NetTrace, " %s ", (pointer[1] == TELQUAL_IS) ?
							"IS" : "REPLY");
		if (AUTHTYPE_NAME_OK(pointer[2]))
		    fprintf(NetTrace, "%s ", AUTHTYPE_NAME(pointer[2]));
		else
		    fprintf(NetTrace, "%d ", pointer[2]);
		if (length < 3) {
		    fprintf(NetTrace, "(partial suboption??\?)");
		    break;
		}
		fprintf(NetTrace, "%s|%s",
			((pointer[3] & AUTH_WHO_MASK) == AUTH_WHO_CLIENT) ?
			"CLIENT" : "SERVER",
			((pointer[3] & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL) ?
			"MUTUAL" : "ONE-WAY");

		auth_printsub(&pointer[1], length - 1, buf, sizeof(buf));
		fprintf(NetTrace, "%s", buf);
		break;

	    case TELQUAL_SEND:
		i = 2;
		fprintf(NetTrace, " SEND ");
		while (i < length) {
		    if (AUTHTYPE_NAME_OK(pointer[i]))
			fprintf(NetTrace, "%s ", AUTHTYPE_NAME(pointer[i]));
		    else
			fprintf(NetTrace, "%d ", pointer[i]);
		    if (++i >= length) {
			fprintf(NetTrace, "(partial suboption??\?)");
			break;
		    }
		    fprintf(NetTrace, "%s|%s ",
			((pointer[i] & AUTH_WHO_MASK) == AUTH_WHO_CLIENT) ?
							"CLIENT" : "SERVER",
			((pointer[i] & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL) ?
							"MUTUAL" : "ONE-WAY");
		    ++i;
		}
		break;

	    case TELQUAL_NAME:
		i = 2;
		fprintf(NetTrace, " NAME \"");
		while (i < length)
		    putc(pointer[i++], NetTrace);
		putc('"', NetTrace);
		break;

	    default:
		    for (i = 2; i < length; i++)
			fprintf(NetTrace, " ?%d?", pointer[i]);
		    break;
	    }
	    break;
#endif

#if    defined(ENCRYPTION)
	case TELOPT_ENCRYPT:
	    fprintf(NetTrace, "ENCRYPT");
	    if (length < 2) {
		fprintf(NetTrace, " (empty suboption?)");
		break;
	    }
	    switch (pointer[1]) {
	    case ENCRYPT_START:
		fprintf(NetTrace, " START");
		break;
		
	    case ENCRYPT_END:
		fprintf(NetTrace, " END");
		break;
		
	    case ENCRYPT_REQSTART:
		fprintf(NetTrace, " REQUEST-START");
		break;

	    case ENCRYPT_REQEND:
		fprintf(NetTrace, " REQUEST-END");
		break;
		
	    case ENCRYPT_IS:
	    case ENCRYPT_REPLY:
		fprintf(NetTrace, " %s ", (pointer[1] == ENCRYPT_IS) ?
			"IS" : "REPLY");
		if (length < 3) {
		    fprintf(NetTrace, " (partial suboption?)");
		    break;
		}
		if (ENCTYPE_NAME_OK(pointer[2]))
		    fprintf(NetTrace, "%s ", ENCTYPE_NAME(pointer[2]));
		else
		    fprintf(NetTrace, " %d (unknown)", pointer[2]);
		
		encrypt_printsub(&pointer[1], length - 1, buf, sizeof(buf));
		fprintf(NetTrace, "%s", buf);
		break;
		
	    case ENCRYPT_SUPPORT:
		i = 2;
		fprintf(NetTrace, " SUPPORT ");
		while (i < length) {
		    if (ENCTYPE_NAME_OK(pointer[i]))
			fprintf(NetTrace, "%s ", ENCTYPE_NAME(pointer[i]));
		    else
			fprintf(NetTrace, "%d ", pointer[i]);
		    i++;
		}
		break;
		
	    case ENCRYPT_ENC_KEYID:
		fprintf(NetTrace, " ENC_KEYID ");
		goto encommon;
		
	    case ENCRYPT_DEC_KEYID:
		fprintf(NetTrace, " DEC_KEYID ");
		goto encommon;
		
	    default:
		fprintf(NetTrace, " %d (unknown)", pointer[1]);
	    encommon:
		for (i = 2; i < length; i++)
		    fprintf(NetTrace, " %d", pointer[i]);
		break;
	    }
	    break;
#endif


a575 6
#ifdef	OLD_ENVIRON
	    goto env_common1;
	case TELOPT_OLD_ENVIRON:
	    fprintf(NetTrace, "OLD-ENVIRON");
	env_common1:
#endif
a587 3
#if defined(ENV_HACK) && defined(OLD_ENVIRON)
		    extern int old_env_var, old_env_value;
#endif
a590 11
#ifdef OLD_ENVIRON
		     /*	case NEW_ENV_OVAR: */
			    if (pointer[0] == TELOPT_OLD_ENVIRON) {
# ifdef	ENV_HACK
				if (old_env_var == OLD_ENV_VALUE)
				    fprintf(NetTrace, "\" (VALUE) " + noquote);
				else
# endif
				    fprintf(NetTrace, "\" VAR " + noquote);
			    } else
#endif /* OLD_ENVIRON */
a595 11
#ifdef OLD_ENVIRON
		     /* case OLD_ENV_VALUE: */
			    if (pointer[0] == TELOPT_OLD_ENVIRON) {
# ifdef	ENV_HACK
				if (old_env_value == OLD_ENV_VAR)
				    fprintf(NetTrace, "\" (VAR) " + noquote);
				else
# endif
				    fprintf(NetTrace, "\" VALUE " + noquote);
			    } else
#endif /* OLD_ENVIRON */
a678 5
#if	defined(TN3270)
    if (In3270) {
	Finish3270();
    }
#else	/* defined(TN3270) */
a682 1
#endif	/* defined(TN3270) */
a685 5
#if	defined(TN3270)
    if (In3270) {
	StopScreen(1);
    }
#endif	/* defined(TN3270) */
@


1.10
log
@remove "unused variable" warnings

tested by deraadt@@ on a gcc2 arch

looks ok ray@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.9 2003/06/03 02:56:18 millert Exp $	*/
d850 1
a850 1
 *			way to the kernel (thus the select).
d856 1
a856 2
#if	defined(unix)
    fd_set	outs;
d858 2
a859 2
    FD_ZERO(&outs);
#endif	/* defined(unix) */
d862 1
a862 5
#if	defined(unix)
	FD_SET(tout, &outs);
	(void) select(tout+1, (fd_set *) 0, &outs, (fd_set *) 0,
			(struct timeval *) 0);	/* wait for TTLOWAT */
#endif	/* defined(unix) */
d866 1
a866 6
#if	defined(unix)
	    ttyflush(0);
	    FD_SET(tout, &outs);
	    (void) select(tout+1, (fd_set *) 0, &outs, (fd_set *) 0,
				(struct timeval *) 0);	/* wait for TTLOWAT */
#endif	/* defined(unix) */
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.8 2003/04/03 12:05:58 hin Exp $	*/
d280 1
d282 1
@


1.8
log
@strcpy -> strlcpy
strcat -> strlcat

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.7 2002/02/01 06:59:17 itojun Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.6 2001/11/19 19:02:16 mpech Exp $	*/
d110 1
a110 1
    strcpy((char *)NetTraceFile, "(standard output)");
@


1.6
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.5 1998/03/12 04:57:47 art Exp $	*/
d93 1
a93 1
unsigned char NetTraceFile[256] = "(standard output)";
d104 1
a104 1
	    strcpy((char *)NetTraceFile, file);
@


1.5
log
@encryption support from kth-krb 0.9.8 (kerberos only)
plus some tweaks for better binary/8-bit support.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.4 1998/02/16 04:59:04 jason Exp $	*/
d54 1
a54 1
    register char *argument;
d56 1
a56 1
    register int c;
d97 1
a97 1
    register char *file;
d177 1
a177 1
		register char *fmt;
d203 1
a203 1
    register int i;
d283 1
a283 1
    register int i;
d293 1
a293 1
		register int j;
d646 2
a647 2
	    register char *cp;
	    register int j, k;
d760 1
a760 1
		    register int noquote = 2;
@


1.4
log
@fixes to compile against netbsd domestic libtelnet
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.3 1996/12/12 11:24:08 robin Exp $	*/
a36 9
#ifndef lint
#if 0
static char sccsid[] = "@@(#)utilities.c	8.3 (Berkeley) 5/30/95";
static char rcsid[] = "$NetBSD: utilities.c,v 1.5 1996/02/28 21:04:21 thorpej Exp $";
#else
static char rcsid[] = "$OpenBSD: utilities.c,v 1.3 1996/12/12 11:24:08 robin Exp $";
#endif
#endif /* not lint */

a39 10
#include <arpa/telnet.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <unistd.h>
#include <ctype.h>

#include "general.h"

#include "fdset.h"
d41 1
a41 5
#include "ring.h"

#include "defines.h"

#include "externs.h"
d78 1
a78 1
				(char *)&yesno, sizeof yesno);
d474 71
d624 7
a630 6
		    sprintf(tbuf, "%s%s%s%s%s",
			pointer[2]&MODE_EDIT ? "|EDIT" : "",
			pointer[2]&MODE_TRAPSIG ? "|TRAPSIG" : "",
			pointer[2]&MODE_SOFT_TAB ? "|SOFT_TAB" : "",
			pointer[2]&MODE_LIT_ECHO ? "|LIT_ECHO" : "",
			pointer[2]&MODE_ACK ? "|ACK" : "");
d859 1
a859 1
    fd_set	o;
d861 1
a861 1
    FD_ZERO(&o);
d866 2
a867 2
	FD_SET(tout, &o);
	(void) select(tout+1, (fd_set *) 0, &o, (fd_set *) 0,
d874 3
a876 2
	    FD_SET(tout, &o);
	    (void) select(tout+1, (fd_set *) 0, &o, (fd_set *) 0,
@


1.3
log
@Add <sys/socket.h> for setsockopt(2), <unistd.h> for select(2).
Remove two unused variables: `pettydump' and `buf'.
Remove redundant case label: `def_case'.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.2 1996/03/27 19:33:15 niklas Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.2 1996/03/27 19:33:15 niklas Exp $";
d307 1
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD$";
d52 2
a53 1

a145 1
    extern pettydump;
a306 1
    char buf[512];
a758 1
			def_case:
@


1.1
log
@Initial revision
@
text
@d1 3
d38 6
a43 2
/* from: static char sccsid[] = "@@(#)utilities.c	8.1 (Berkeley) 6/6/93"; */
static char *rcsid = "$Id: utilities.c,v 1.3 1994/02/25 03:00:51 cgd Exp $";
d534 1
a534 1
		
d666 1
a666 1
				
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

