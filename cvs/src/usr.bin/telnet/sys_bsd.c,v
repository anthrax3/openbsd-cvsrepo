head	1.33;
access;
symbols
	OPENBSD_6_1:1.32.0.6
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.32.0.2
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.40
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.38
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.36
	OPENBSD_5_0:1.14.0.34
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.32
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.30
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.26
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.28
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.24
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.22
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.20
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.18
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.16
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.14
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.12
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2017.07.07.09.14.26;	author fcambus;	state Exp;
branches;
next	1.32;
commitid	Z3Nr3Tgp5JM9CAGX;

1.32
date	2016.03.16.15.41.11;	author krw;	state Exp;
branches;
next	1.31;
commitid	JEVxsRygqcjPtWTf;

1.31
date	2015.11.29.14.18.40;	author semarie;	state Exp;
branches;
next	1.30;
commitid	p6M1syk1LgfWIXtP;

1.30
date	2015.03.29.13.42.53;	author sthen;	state Exp;
branches;
next	1.29;
commitid	qjXi04qbenggeg8M;

1.29
date	2015.02.12.09.50.50;	author guenther;	state Exp;
branches;
next	1.28;
commitid	c8HJWWfbSrq35iI0;

1.28
date	2014.09.09.03.41.08;	author guenther;	state Exp;
branches;
next	1.27;
commitid	VR4fCtOZMbshOip1;

1.27
date	2014.07.22.07.30.24;	author jsg;	state Exp;
branches;
next	1.26;
commitid	5F2TXUtxGWuYgYJc;

1.26
date	2014.07.20.12.08.55;	author guenther;	state Exp;
branches;
next	1.25;
commitid	S3moNyJOYK9CLzJu;

1.25
date	2014.07.20.10.55.26;	author guenther;	state Exp;
branches;
next	1.24;
commitid	KvN9Bh2AXHiOi5nI;

1.24
date	2014.07.20.10.18.10;	author guenther;	state Exp;
branches;
next	1.23;
commitid	g3VtcxajtWcT7VuD;

1.23
date	2014.07.20.09.59.42;	author guenther;	state Exp;
branches;
next	1.22;
commitid	11DQHPdHfrXBxigB;

1.22
date	2014.07.20.09.31.25;	author guenther;	state Exp;
branches;
next	1.21;
commitid	sgiDhU5W6KOMYLqU;

1.21
date	2014.07.20.09.20.48;	author guenther;	state Exp;
branches;
next	1.20;
commitid	BlPcwczsfw7yNVQ4;

1.20
date	2014.07.20.08.12.46;	author guenther;	state Exp;
branches;
next	1.19;
commitid	qbZdS8s4KEeVt81G;

1.19
date	2014.07.20.07.35.04;	author guenther;	state Exp;
branches;
next	1.18;
commitid	2cOmMOs302nEGrCZ;

1.18
date	2014.07.20.06.39.41;	author guenther;	state Exp;
branches;
next	1.17;
commitid	2c9hYJDg2dE2R3T8;

1.17
date	2014.07.20.05.22.02;	author guenther;	state Exp;
branches;
next	1.16;
commitid	mkPeU1MBN7ewMEUq;

1.16
date	2014.07.19.23.50.38;	author guenther;	state Exp;
branches;
next	1.15;
commitid	J1fNmylmVMpKGeua;

1.15
date	2013.04.21.09.51.24;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.03.02.56.18;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.25.10.52.32;	author hin;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.22.13.49.28;	author hin;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.04.23.35.59;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.10.15.41.10;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.05.07.18.29.07;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.12.28.11.13.51;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.03.12.04.57.40;	author art;	state Exp;
branches;
next	1.4;

1.4
date	96.12.11.17.14.22;	author robin;	state Exp;
branches;
next	1.3;

1.3
date	96.03.27.19.33.07;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.23.15.13.01;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.14;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.14;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Remove unnecessary #ifdefs in telnet. No binary change.

OK deraadt@@, tedu@@
@
text
@/*	$OpenBSD: sys_bsd.c,v 1.32 2016/03/16 15:41:11 krw Exp $	*/
/*	$NetBSD: sys_bsd.c,v 1.11 1996/02/28 21:04:10 thorpej Exp $	*/

/*
 * Copyright (c) 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "telnet_locl.h"

#include <sys/ioctl.h>
#include <sys/socket.h>
#include <arpa/telnet.h>
#include <errno.h>
#include <poll.h>
#include <string.h>
#include <unistd.h>

/*
 * The following routines try to encapsulate what is system dependent
 * (at least between 4.x and dos) which is used in telnet.c.
 */

int
	tout,			/* Output file descriptor */
	tin,			/* Input file descriptor */
	net;

#define TELNET_FD_TOUT	0
#define TELNET_FD_TIN	1
#define TELNET_FD_NET	2
#define TELNET_FD_NUM	3

struct	termios old_tc = { 0 };

void
init_sys(void)
{
    tout = fileno(stdout);
    tin = fileno(stdin);

    errno = 0;
}


/*
 * TerminalSpecialChars()
 *
 * Look at an input character to see if it is a special character
 * and decide what to do.
 *
 * Output:
 *
 *	0	Don't add this character.
 *	1	Do add this character
 */

int
TerminalSpecialChars(int c)
{
    if (c == termIntChar) {
	intp();
	return 0;
    } else if (c == termQuitChar) {
#ifdef	KLUDGELINEMODE
	if (kludgelinemode)
	    sendbrk();
	else
#endif
	    sendabort();
	return 0;
    } else if (c == termEofChar) {
	if (my_want_state_is_will(TELOPT_LINEMODE)) {
	    sendeof();
	    return 0;
	}
	return 1;
    } else if (c == termSuspChar) {
	sendsusp();
	return(0);
    } else if (c == termFlushChar) {
	xmitAO();		/* Transmit Abort Output */
	return 0;
    } else if (!MODE_LOCAL_CHARS(globalmode)) {
	if (c == termKillChar) {
	    xmitEL();
	    return 0;
	} else if (c == termEraseChar) {
	    xmitEC();		/* Transmit Erase Character */
	    return 0;
	}
    }
    return 1;
}

void
TerminalSaveState(void)
{
    tcgetattr(0, &old_tc);

    new_tc = old_tc;
}

cc_t *
tcval(int func)
{
    switch(func) {
    case SLC_IP:	return(&termIntChar);
    case SLC_ABORT:	return(&termQuitChar);
    case SLC_EOF:	return(&termEofChar);
    case SLC_EC:	return(&termEraseChar);
    case SLC_EL:	return(&termKillChar);
    case SLC_XON:	return(&termStartChar);
    case SLC_XOFF:	return(&termStopChar);
    case SLC_FORW1:	return(&termForw1Char);
    case SLC_FORW2:	return(&termForw2Char);
    case SLC_SUSP:	return(&termSuspChar);
    case SLC_AO:	return(&termFlushChar);
    case SLC_EW:	return(&termWerasChar);
    case SLC_RP:	return(&termRprntChar);
    case SLC_LNEXT:	return(&termLiteralNextChar);
    case SLC_AYT:	return(&termAytChar);
    case SLC_SYNCH:
    case SLC_BRK:
    case SLC_EOR:
    default:
	return(NULL);
    }
}

void
TerminalDefaultChars(void)
{
    memcpy(new_tc.c_cc, old_tc.c_cc, sizeof(old_tc.c_cc));
}

/*
 * TerminalNewMode - set up terminal to a specific mode.
 *	MODE_ECHO: do local terminal echo
 *	MODE_FLOW: do local flow control
 *	MODE_TRAPSIG: do local mapping to TELNET IAC sequences
 *	MODE_EDIT: do local line editing
 *
 *	Command mode:
 *		MODE_ECHO|MODE_EDIT|MODE_FLOW|MODE_TRAPSIG
 *		local echo
 *		local editing
 *		local xon/xoff
 *		local signal mapping
 *
 *	Linemode:
 *		local/no editing
 *	Both Linemode and Single Character mode:
 *		local/remote echo
 *		local/no xon/xoff
 *		local/no signal mapping
 */

static void susp();
#ifdef SIGINFO
static void ayt();
#endif

void
TerminalNewMode(int f)
{
    static int prevmode = 0;
    struct termios tmp_tc;
    int onoff;
    int old;
    cc_t esc;

    globalmode = f&~MODE_FORCE;
    if (prevmode == f)
	return;

    /*
     * Write any outstanding data before switching modes
     * ttyflush() returns 0 only when there is no more data
     * left to write out, it returns -1 if it couldn't do
     * anything at all, otherwise it returns 1 + the number
     * of characters left to write.
     */
    old = ttyflush(SYNCHing|flushout);
    if (old < 0 || old > 1) {
	tcgetattr(tin, &tmp_tc);
	do {
	    /*
	     * Wait for data to drain, then flush again.
	     */
	    if (isatty(tin))
	        tcsetattr(tin, TCSADRAIN, &tmp_tc);
	    old = ttyflush(SYNCHing|flushout);
	} while (old < 0 || old > 1);
    }

    old = prevmode;
    prevmode = f&~MODE_FORCE;
    tmp_tc = new_tc;

    if (f&MODE_ECHO) {
	tmp_tc.c_lflag |= ECHO;
	tmp_tc.c_oflag |= ONLCR;
	if (crlf)
		tmp_tc.c_iflag |= ICRNL;
    } else {
	tmp_tc.c_lflag &= ~ECHO;
	tmp_tc.c_oflag &= ~ONLCR;
    }

    if ((f&MODE_FLOW) == 0) {
	tmp_tc.c_iflag &= ~(IXOFF|IXON);	/* Leave the IXANY bit alone */
    } else {
	if (restartany < 0) {
		tmp_tc.c_iflag |= IXOFF|IXON;	/* Leave the IXANY bit alone */
	} else if (restartany > 0) {
		tmp_tc.c_iflag |= IXOFF|IXON|IXANY;
	} else {
		tmp_tc.c_iflag |= IXOFF|IXON;
		tmp_tc.c_iflag &= ~IXANY;
	}
    }

    if ((f&MODE_TRAPSIG) == 0) {
	tmp_tc.c_lflag &= ~ISIG;
	localchars = 0;
    } else {
	tmp_tc.c_lflag |= ISIG;
	localchars = 1;
    }

    if (f&MODE_EDIT) {
	tmp_tc.c_lflag |= ICANON;
    } else {
	tmp_tc.c_lflag &= ~ICANON;
	tmp_tc.c_iflag &= ~ICRNL;
	tmp_tc.c_cc[VMIN] = 1;
	tmp_tc.c_cc[VTIME] = 0;
    }

    if ((f&(MODE_EDIT|MODE_TRAPSIG)) == 0) {
	tmp_tc.c_lflag &= ~IEXTEN;
    }

    if (f&MODE_SOFT_TAB) {
# ifdef	OXTABS
	tmp_tc.c_oflag |= OXTABS;
# endif
# ifdef	TABDLY
	tmp_tc.c_oflag &= ~TABDLY;
	tmp_tc.c_oflag |= TAB3;
# endif
    } else {
# ifdef	OXTABS
	tmp_tc.c_oflag &= ~OXTABS;
# endif
# ifdef	TABDLY
	tmp_tc.c_oflag &= ~TABDLY;
# endif
    }

    if (f&MODE_LIT_ECHO) {
# ifdef	ECHOCTL
	tmp_tc.c_lflag &= ~ECHOCTL;
# endif
    } else {
# ifdef	ECHOCTL
	tmp_tc.c_lflag |= ECHOCTL;
# endif
    }

    if (f == -1) {
	onoff = 0;
    } else {
	if (f & MODE_INBIN)
		tmp_tc.c_iflag &= ~ISTRIP;
	else
		tmp_tc.c_iflag |= ISTRIP;
	if ((f & MODE_OUTBIN) || (f & MODE_OUT8)) {
		tmp_tc.c_cflag &= ~(CSIZE|PARENB);
		tmp_tc.c_cflag |= CS8;
		if(f & MODE_OUTBIN)
			tmp_tc.c_oflag &= ~OPOST;
		else
			tmp_tc.c_oflag |= OPOST;

	} else {
		tmp_tc.c_cflag &= ~(CSIZE|PARENB);
		tmp_tc.c_cflag |= old_tc.c_cflag & (CSIZE|PARENB);
		tmp_tc.c_oflag |= OPOST;
	}
	onoff = 1;
    }

    if (f != -1) {
	(void) signal(SIGTSTP, susp);
#ifdef	SIGINFO
	(void) signal(SIGINFO, ayt);
#endif
#if	defined(NOKERNINFO)
	tmp_tc.c_lflag |= NOKERNINFO;
#endif
	/*
	 * We don't want to process ^Y here.  It's just another
	 * character that we'll pass on to the back end.  It has
	 * to process it because it will be processed when the
	 * user attempts to read it, not when we send it.
	 */
# ifdef	VDSUSP
	tmp_tc.c_cc[VDSUSP] = (cc_t)(_POSIX_VDISABLE);
# endif
	/*
	 * If the VEOL character is already set, then use VEOL2,
	 * otherwise use VEOL.
	 */
	esc = (rlogin != _POSIX_VDISABLE) ? rlogin : escape;
	if ((tmp_tc.c_cc[VEOL] != esc)
# ifdef	VEOL2
	    && (tmp_tc.c_cc[VEOL2] != esc)
# endif
	    ) {
		if (tmp_tc.c_cc[VEOL] == (cc_t)(_POSIX_VDISABLE))
		    tmp_tc.c_cc[VEOL] = esc;
# ifdef	VEOL2
		else if (tmp_tc.c_cc[VEOL2] == (cc_t)(_POSIX_VDISABLE))
		    tmp_tc.c_cc[VEOL2] = esc;
# endif
	}
    } else {
	sigset_t mask;
#ifdef	SIGINFO
	(void) signal(SIGINFO, ayt_status);
#endif
	(void) signal(SIGTSTP, SIG_DFL);
	sigemptyset(&mask);
	sigaddset(&mask, SIGTSTP);
	sigprocmask(SIG_UNBLOCK, &mask, NULL);
	tmp_tc = old_tc;
    }
    if (isatty(tin) && tcsetattr(tin, TCSADRAIN, &tmp_tc) < 0)
	tcsetattr(tin, TCSANOW, &tmp_tc);

    ioctl(tin, FIONBIO, &onoff);
    ioctl(tout, FIONBIO, &onoff);
}

/*
 * Try to guess whether speeds are "encoded" (4.2BSD) or just numeric (4.4BSD).
 */
#if B4800 != 4800
#define	DECODE_BAUD
#endif

#ifdef	DECODE_BAUD
#ifndef	B7200
#define B7200   B4800
#endif

#ifndef	B14400
#define B14400  B9600
#endif

#ifndef	B19200
# define B19200 B14400
#endif

#ifndef	B28800
#define B28800  B19200
#endif

#ifndef	B38400
# define B38400 B28800
#endif

#ifndef B57600
#define B57600  B38400
#endif

#ifndef B76800
#define B76800  B57600
#endif

#ifndef B115200
#define B115200 B76800
#endif

#ifndef B230400
#define B230400 B115200
#endif


/*
 * This code assumes that the values B0, B50, B75...
 * are in ascending order.  They do not have to be
 * contiguous.
 */
struct termspeeds {
	long speed;
	long value;
} termspeeds[] = {
	{ 0,      B0 },      { 50,    B50 },    { 75,     B75 },
	{ 110,    B110 },    { 134,   B134 },   { 150,    B150 },
	{ 200,    B200 },    { 300,   B300 },   { 600,    B600 },
	{ 1200,   B1200 },   { 1800,  B1800 },  { 2400,   B2400 },
	{ 4800,   B4800 },   { 7200,  B7200 },  { 9600,   B9600 },
	{ 14400,  B14400 },  { 19200, B19200 }, { 28800,  B28800 },
	{ 38400,  B38400 },  { 57600, B57600 }, { 115200, B115200 },
	{ 230400, B230400 }, { -1,    B230400 }
};
#endif	/* DECODE_BAUD */

void
TerminalSpeeds(long *ispeed, long *ospeed)
{
#ifdef	DECODE_BAUD
    struct termspeeds *tp;
#endif	/* DECODE_BAUD */
    long in, out;

    out = cfgetospeed(&old_tc);
    in = cfgetispeed(&old_tc);
    if (in == 0)
	in = out;

#ifdef	DECODE_BAUD
    tp = termspeeds;
    while ((tp->speed != -1) && (tp->value < in))
	tp++;
    *ispeed = tp->speed;

    tp = termspeeds;
    while ((tp->speed != -1) && (tp->value < out))
	tp++;
    *ospeed = tp->speed;
#else	/* DECODE_BAUD */
	*ispeed = in;
	*ospeed = out;
#endif	/* DECODE_BAUD */
}

int
TerminalWindowSize(long *rows, long *cols)
{
#ifdef	TIOCGWINSZ
    struct winsize ws;

    if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) >= 0) {
	*rows = ws.ws_row;
	*cols = ws.ws_col;
	return 1;
    }
#endif	/* TIOCGWINSZ */
    return 0;
}

/*
 * Various signal handling routines.
 */

void
deadpeer(int sig)
{
	setcommandmode();
	longjmp(peerdied, -1);
}

void
intr(int sig)
{
    if (localchars) {
	intp();
	return;
    }
    setcommandmode();
    longjmp(toplevel, -1);
}

void
intr2(int sig)
{
    if (localchars) {
#ifdef	KLUDGELINEMODE
	if (kludgelinemode)
	    sendbrk();
	else
#endif
	    sendabort();
	return;
    }
}

void
susp(int sig)
{
    if ((rlogin != _POSIX_VDISABLE) && rlogin_susp())
	return;
    if (localchars)
	sendsusp();
}

#ifdef	SIGWINCH
void
sendwin(int sig)
{
    if (connected) {
	sendnaws();
    }
}
#endif

#ifdef	SIGINFO
void
ayt(int sig)
{
    if (connected)
	sendayt();
    else
	ayt_status(sig);
}
#endif


void
sys_telnet_init(void)
{
    int one = 1;

    (void) signal(SIGINT, intr);
    (void) signal(SIGQUIT, intr2);
    (void) signal(SIGPIPE, deadpeer);
#ifdef	SIGWINCH
    (void) signal(SIGWINCH, sendwin);
#endif
    (void) signal(SIGTSTP, susp);
#ifdef	SIGINFO
    (void) signal(SIGINFO, ayt);
#endif

    setconnmode(0);

    /*
     * Mark the socket as non-blocking and receive urgent data inline.
     * (The latter is required for correct telnet operation when a
     * second urgent is sent before telnet can process the first.)
     */
    ioctl(net, FIONBIO, &one);
    if (setsockopt(net, SOL_SOCKET, SO_OOBINLINE, &one, sizeof(one)) == -1) {
	perror("setsockopt");
    }
}

/*
 * Process rings -
 *
 *	This routine tries to fill up/empty our various rings.
 *
 *	The parameter specifies whether this is a poll operation,
 *	or a block-until-something-happens operation.
 *
 *	The return value is 1 if something happened, 0 if not.
 */

int
process_rings(int netin, int netout, int netex, int ttyin, int ttyout,
    int dopoll)		/* If 0, then block until something to do */
{
    int c;
		/* One wants to be a bit careful about setting returnValue
		 * to one, since a one implies we did some useful work,
		 * and therefore probably won't be called to block next
		 * time (TN3270 mode only).
		 */
    int returnValue = 0;
    struct pollfd pfd[TELNET_FD_NUM];

    if (ttyout) {
	pfd[TELNET_FD_TOUT].fd = tout;
	pfd[TELNET_FD_TOUT].events = POLLOUT;
    } else {
	pfd[TELNET_FD_TOUT].fd = -1;
    }
    if (ttyin) {
	pfd[TELNET_FD_TIN].fd = tin;
	pfd[TELNET_FD_TIN].events = POLLIN;
    } else {
	pfd[TELNET_FD_TIN].fd = -1;
    }
    if (netout || netin || netex) {
	pfd[TELNET_FD_NET].fd = net;
	pfd[TELNET_FD_NET].events = 0;
	if (netout)
	    pfd[TELNET_FD_NET].events |= POLLOUT;
	if (netin)
	    pfd[TELNET_FD_NET].events |= POLLIN;
	if (netex)
	    pfd[TELNET_FD_NET].events |= POLLRDBAND;
    } else {
	pfd[TELNET_FD_NET].fd = -1;
    }

    if ((c = poll(pfd, TELNET_FD_NUM, dopoll ? 0 : INFTIM)) < 0) {
	return 0;
    }

    /*
     * Any urgent data?
     */
    if (pfd[TELNET_FD_NET].revents & POLLRDBAND) {
	SYNCHing = 1;
	(void) ttyflush(1);	/* flush already enqueued data */
    }

    /*
     * Something to read from the network...
     */
    if (pfd[TELNET_FD_NET].revents & (POLLIN|POLLHUP)) {
	int canread;

	canread = ring_empty_consecutive(&netiring);
	c = recv(net, netiring.supply, canread, 0);
	if (c < 0 && errno == EWOULDBLOCK) {
	    c = 0;
	} else if (c <= 0) {
	    return -1;
	}
	if (netdata) {
	    Dump('<', netiring.supply, c);
	}
	if (c)
	    ring_supplied(&netiring, c);
	returnValue = 1;
    }

    /*
     * Something to read from the tty...
     */
    if (pfd[TELNET_FD_TIN].revents & (POLLIN|POLLHUP)) {
	c = read(tin, ttyiring.supply, ring_empty_consecutive(&ttyiring));
	if (c < 0 && errno == EIO)
	    c = 0;
	if (c < 0 && errno == EWOULDBLOCK) {
	    c = 0;
	} else {
	    /* EOF detection for line mode!!!! */
	    if ((c == 0) && MODE_LOCAL_CHARS(globalmode) && isatty(tin)) {
		/* must be an EOF... */
		*ttyiring.supply = termEofChar;
		c = 1;
	    }
	    if (c <= 0) {
		return -1;
	    }
	    if (termdata) {
		Dump('<', ttyiring.supply, c);
	    }
	    ring_supplied(&ttyiring, c);
	}
	returnValue = 1;		/* did something useful */
    }

    if (pfd[TELNET_FD_NET].revents & POLLOUT) {
	returnValue |= netflush();
    }
    if (pfd[TELNET_FD_TOUT].revents & POLLOUT) {
	returnValue |= (ttyflush(SYNCHing|flushout) > 0);
    }

    return returnValue;
}
@


1.32
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.31 2015/11/29 14:18:40 semarie Exp $	*/
a125 22

#ifndef	VDISCARD
    termFlushChar = CONTROL('O');
#endif
#ifndef	VWERASE
    termWerasChar = CONTROL('W');
#endif
#ifndef	VREPRINT
    termRprntChar = CONTROL('R');
#endif
#ifndef	VLNEXT
    termLiteralNextChar = CONTROL('V');
#endif
#ifndef	VSTART
    termStartChar = CONTROL('Q');
#endif
#ifndef	VSTOP
    termStopChar = CONTROL('S');
#endif
#ifndef	VSTATUS
    termAytChar = CONTROL('T');
#endif
a141 1
# ifdef	VDISCARD
a142 2
# endif
# ifdef	VWERASE
a143 2
# endif
# ifdef	VREPRINT
a144 2
# endif
# ifdef	VLNEXT
a145 2
# endif
# ifdef	VSTATUS
a146 2
# endif

a158 21
# ifndef	VDISCARD
    termFlushChar = CONTROL('O');
# endif
# ifndef	VWERASE
    termWerasChar = CONTROL('W');
# endif
# ifndef	VREPRINT
    termRprntChar = CONTROL('R');
# endif
# ifndef	VLNEXT
    termLiteralNextChar = CONTROL('V');
# endif
# ifndef	VSTART
    termStartChar = CONTROL('Q');
# endif
# ifndef	VSTOP
    termStopChar = CONTROL('S');
# endif
# ifndef	VSTATUS
    termAytChar = CONTROL('T');
# endif
@


1.31
log
@telnet: check if fd is a tty before calling tcsetattr(fd, TCSADRAIN)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.30 2015/03/29 13:42:53 sthen Exp $	*/
d184 1
a184 1
	return((cc_t *)0);
@


1.30
log
@Revert r1.29 "Don't clear ICRNL when editing mode is off, so that character
local echo mode don't echo ^M locally" as this causes problems sending CR to
some Cisco equipment reported by Ryan Freeman and Fred Crowson.

kettenis@@ agrees with reverting to fix the regression; we can consider a
better diff afterwards but clearly this is a sensitive area.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.29 2015/02/12 09:50:50 guenther Exp $	*/
d269 2
a270 1
	    tcsetattr(tin, TCSADRAIN, &tmp_tc);
d418 1
a418 1
    if (tcsetattr(tin, TCSADRAIN, &tmp_tc) < 0)
@


1.29
log
@Don't clear ICRNL when editing mode is off, so that character local echo
mode don't echo ^M locally

analysis and patch from Stanislav Brabec (sbrabec (at) suse.cz)
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.28 2014/09/09 03:41:08 guenther Exp $	*/
d313 1
@


1.28
log
@Eliminate a pile of casts that were superfluous or wrong, or that were
the result of bad type choices, particularly (unsigned char *) vs
(const char *).  Also, use reallocarray().
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.27 2014/07/22 07:30:24 jsg Exp $	*/
a312 1
	tmp_tc.c_iflag &= ~ICRNL;
@


1.27
log
@use ansi style function declarations
with suggestions from and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.26 2014/07/20 12:08:55 guenther Exp $	*/
d420 2
a421 2
    ioctl(tin, FIONBIO, (char *)&onoff);
    ioctl(tout, FIONBIO, (char *)&onoff);
d524 1
a524 1
    if (ioctl(fileno(stdin), TIOCGWINSZ, (char *)&ws) >= 0) {
d697 1
a697 1
	c = recv(net, (char *)netiring.supply, canread, 0);
@


1.26
log
@Eliminate silly call() routine that fakes up internal calls as if
the user typed in undocumented arguments by splitting two functions
and doing normal (shock!) C calls.

Move extern declarations to externs.h
Eliminate another function cast
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.25 2014/07/20 10:55:26 guenther Exp $	*/
d60 2
a61 2
    void
init_sys()
d82 2
a83 3
    int
TerminalSpecialChars(c)
    int	c;
d120 2
a121 2
    void
TerminalSaveState()
d150 2
a151 3
    cc_t *
tcval(func)
    int func;
d188 2
a189 2
    void
TerminalDefaultChars()
d242 2
a243 3
    void
TerminalNewMode(f)
    int f;
d489 2
a490 4
    void
TerminalSpeeds(ispeed, ospeed)
    long *ispeed;
    long *ospeed;
d518 2
a519 3
    int
TerminalWindowSize(rows, cols)
    long *rows, *cols;
d537 2
a538 3
    void
deadpeer(sig)
    int sig;
d544 2
a545 3
    void
intr(sig)
    int sig;
d555 2
a556 3
    void
intr2(sig)
    int sig;
d569 2
a570 3
    void
susp(sig)
    int sig;
d579 2
a580 3
    void
sendwin(sig)
    int sig;
d589 2
a590 3
    void
ayt(sig)
    int sig;
d600 2
a601 2
    void
sys_telnet_init()
d640 3
a642 3
    int
process_rings(netin, netout, netex, ttyin, ttyout, dopoll)
    int dopoll;		/* If 0, then block until something to do */
@


1.25
log
@Mark a slurry of functions as static
Eliminate two more trivial wrappers
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.24 2014/07/20 10:18:10 guenther Exp $	*/
a58 1
extern struct termios new_tc;
a69 3
#ifdef	KLUDGELINEMODE
extern int kludgelinemode;
#endif
d412 1
a412 3
	void ayt_status();

	(void) signal(SIGINFO, (void (*)(int))ayt_status);
d607 1
a607 1
	ayt_status();
@


1.24
log
@Kill lint comments; mark ExitString() as __dead
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.23 2014/07/20 09:59:42 guenther Exp $	*/
a544 17
    int
NetClose(fd)
    int	fd;
{
    return close(fd);
}


    void
NetNonblockingIO(fd, onoff)
    int fd;
    int onoff;
{
    ioctl(fd, FIONBIO, (char *)&onoff);
}


d636 6
a641 2
    NetNonblockingIO(net, 1);

@


1.23
log
@Switch from memmove() to memcpy() where appropriate; simplify address
parsing logic; eliminate an inefficient use of MIN() macro
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.22 2014/07/20 09:31:25 guenther Exp $	*/
a565 1
    /* ARGSUSED */
a573 1
    /* ARGSUSED */
a585 1
    /* ARGSUSED */
a600 1
    /* ARGSUSED */
a611 1
    /* ARGSUSED */
a622 1
    /* ARGSUSED */
@


1.22
log
@VSUSP and SIGTSTP are required by POSIX
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.21 2014/07/20 09:20:48 guenther Exp $	*/
d197 1
a197 1
    memmove(new_tc.c_cc, old_tc.c_cc, sizeof(old_tc.c_cc));
@


1.21
log
@Delete an insane chunk of code for handling broken poll() emulation.
Pass poll() INFTIM instead of -1
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.20 2014/07/20 08:12:46 guenther Exp $	*/
d169 1
a172 3
# ifdef	VSUSP
    case SLC_SUSP:	return(&termSuspChar);
# endif
a242 1
#ifdef SIGTSTP
a243 1
#endif /* SIGTSTP */
a379 1
#ifdef	SIGTSTP
a380 1
#endif	/* SIGTSTP */
a413 1
#ifdef	SIGTSTP
a414 1
#endif	/* SIGTSTP */
a419 1
#ifdef	SIGTSTP
a423 1
#endif	/* SIGTSTP */
a603 1
#ifdef	SIGTSTP
a613 1
#endif
a651 1
#ifdef	SIGTSTP
a652 1
#endif
@


1.20
log
@More encryption tentacles: intr_happened and intr_waiting vanish
Push more includes into .c files
Make ring.c only need ring.h
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.19 2014/07/20 07:35:04 guenther Exp $	*/
d729 1
a729 14
    if ((c = poll(pfd, TELNET_FD_NUM, dopoll ? 0 : -1)) < 0) {
	if (c == -1) {
		    /*
		     * we can get EINTR if we are in line mode,
		     * and the user does an escape (TSTP), or
		     * some other signal generator.
		     */
	    if (errno == EINTR) {
		return 0;
	    }
		    /* I don't like this, does it ever happen? */
	    printf("sleep(5) from telnet, after poll\r\n");
	    sleep(5);
	}
@


1.19
log
@Eliminate trivial wrappers TerminalWrite() and TerminalRead()
Replace TerminalFlushOutput() with tcflush().
Replace TerminalAutoFlush() with check of tty's NOFLSH flag as
	documented in the manpage.
Push <netdb.h> into .c files
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.18 2014/07/20 06:39:41 guenther Exp $	*/
d36 3
d40 1
a584 3
volatile sig_atomic_t intr_happened = 0;
volatile sig_atomic_t intr_waiting = 0;

a589 4
    if (intr_waiting) {
	intr_happened = 1;
	return;
    }
@


1.18
log
@Correctly cast to unsigned char for ctype functions/macros
Push <ctype.h> and <unistd.h> into the .c files
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.17 2014/07/20 05:22:02 guenther Exp $	*/
a66 33
    int
TerminalWrite(buf, n)
    char *buf;
    int  n;
{
    return write(tout, buf, n);
}

    int
TerminalRead(buf, n)
    unsigned char *buf;
    int  n;
{
    return read(tin, buf, n);
}

/*
 *
 */

    int
TerminalAutoFlush()
{
#if	defined(LNOFLSH)
    int flush;

    ioctl(0, TIOCLGET, (char *)&flush);
    return !(flush&LNOFLSH);	/* if LNOFLSH, no autoflush */
#else	/* LNOFLSH */
    return 1;
#endif	/* LNOFLSH */
}

a120 16

/*
 * Flush output to the terminal
 */

    void
TerminalFlushOutput()
{
#ifdef	TIOCFLUSH
    int com = FWRITE;
    (void) ioctl(fileno(stdout), TIOCFLUSH, (int *) &com);
#else
    (void) ioctl(fileno(stdout), TCFLSH, (int *) 0);
#endif
}

d782 1
a782 1
	c = TerminalRead(ttyiring.supply, ring_empty_consecutive(&ttyiring));
@


1.17
log
@Simplify #includes, start pushing them into the .c files, eliminate
extern declarations from .c files that duplicate those in .h files,
start marking functions with __dead
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.16 2014/07/19 23:50:38 guenther Exp $	*/
d34 1
d37 1
@


1.16
log
@Flense the telnet code base of unwanted ifdefs: authentication/encryption
tn3270, sgtty, pre-POSIX and other ancient system support, etc.  Brings up
to date the manpage with what we support.

ok matthieu@@ beck@@ jmc@@ millert@@ deraadt@@ okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.15 2013/04/21 09:51:24 millert Exp $	*/
d34 2
a35 1
#include <err.h>
a111 2

extern void xmitAO(), xmitEL(), xmitEC(), intp(), sendbrk();
@


1.15
log
@Convert select() to poll().  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.14 2003/06/03 02:56:18 millert Exp $	*/
a50 10
#ifndef	USE_TERMIO
struct	tchars otc = { 0 }, ntc = { 0 };
struct	ltchars oltc = { 0 }, nltc = { 0 };
struct	sgttyb ottyb = { 0 }, nttyb = { 0 };
int	olmode = 0;
# define cfgetispeed(ptr)	(ptr)->sg_ispeed
# define cfgetospeed(ptr)	(ptr)->sg_ospeed
# define old_tc ottyb

#else	/* USE_TERMIO */
a53 29
# ifndef	TCSANOW
#  ifdef TCSETS
#   define	TCSANOW		TCSETS
#   define	TCSADRAIN	TCSETSW
#   define	tcgetattr(f, t) ioctl(f, TCGETS, (char *)t)
#  else
#   ifdef TCSETA
#    define	TCSANOW		TCSETA
#    define	TCSADRAIN	TCSETAW
#    define	tcgetattr(f, t) ioctl(f, TCGETA, (char *)t)
#   else
#    define	TCSANOW		TIOCSETA
#    define	TCSADRAIN	TIOCSETAW
#    define	tcgetattr(f, t) ioctl(f, TIOCGETA, (char *)t)
#   endif
#  endif
#  define	tcsetattr(f, a, t) ioctl(f, a, (char *)t)
#  define	cfgetospeed(ptr)	((ptr)->c_cflag&CBAUD)
#  ifdef CIBAUD
#   define	cfgetispeed(ptr)	(((ptr)->c_cflag&CIBAUD) >> IBSHIFT)
#  else
#   define	cfgetispeed(ptr)	cfgetospeed(ptr)
#  endif
# endif /* TCSANOW */
# ifdef	sysV88
# define TIOCFLUSH TC_PX_DRAIN
# endif
#endif	/* USE_TERMIO */

a171 11
#ifndef	USE_TERMIO
    ioctl(0, TIOCGETP, (char *)&ottyb);
    ioctl(0, TIOCGETC, (char *)&otc);
    ioctl(0, TIOCGLTC, (char *)&oltc);
    ioctl(0, TIOCLGET, (char *)&olmode);

    ntc = otc;
    nltc = oltc;
    nttyb = ottyb;

#else	/* USE_TERMIO */
a196 1
#endif	/* USE_TERMIO */
a211 1
#ifdef	USE_TERMIO
a230 1
#endif
a242 6
#ifndef	USE_TERMIO
    ntc = otc;
    nltc = oltc;
    nttyb.sg_kill = ottyb.sg_kill;
    nttyb.sg_erase = ottyb.sg_erase;
#else	/* USE_TERMIO */
a264 1
#endif	/* USE_TERMIO */
a266 7
#ifdef notdef
void
TerminalRestoreState()
{
}
#endif

a300 6
#ifndef	USE_TERMIO
    struct tchars tc;
    struct ltchars ltc;
    struct sgttyb sb;
    int lmode;
#else	/* USE_TERMIO */
a301 1
#endif	/* USE_TERMIO */
a315 7
#ifndef	USE_TERMIO
     * We would really like ask the kernel to wait for the output
     * to drain, like we can do with the TCSADRAIN, but we don't have
     * that option.  The only ioctl that waits for the output to
     * drain, TIOCSETP, also flushes the input queue, which is NOT
     * what we want (TIOCSETP is like TCSADFLUSH).
#endif
a318 1
#ifdef	USE_TERMIO
a319 1
#endif	/* USE_TERMIO */
a323 1
#ifdef	USE_TERMIO
a324 1
#endif	/* USE_TERMIO */
a330 6
#ifndef	USE_TERMIO
    sb = nttyb;
    tc = ntc;
    ltc = nltc;
    lmode = olmode;
#else
a331 1
#endif
a333 3
#ifndef	USE_TERMIO
	sb.sg_flags |= ECHO;
#else
a337 1
#endif
a338 3
#ifndef	USE_TERMIO
	sb.sg_flags &= ~ECHO;
#else
a340 5
# ifdef notdef
	if (crlf)
		tmp_tc.c_iflag &= ~ICRNL;
# endif
#endif
a343 4
#ifndef	USE_TERMIO
	tc.t_startc = _POSIX_VDISABLE;
	tc.t_stopc = _POSIX_VDISABLE;
#else
a353 1
#endif
a356 7
#ifndef	USE_TERMIO
	tc.t_intrc = _POSIX_VDISABLE;
	tc.t_quitc = _POSIX_VDISABLE;
	tc.t_eofc = _POSIX_VDISABLE;
	ltc.t_suspc = _POSIX_VDISABLE;
	ltc.t_dsuspc = _POSIX_VDISABLE;
#else
a357 1
#endif
a359 1
#ifdef	USE_TERMIO
a360 1
#endif
a364 4
#ifndef	USE_TERMIO
	sb.sg_flags &= ~CBREAK;
	sb.sg_flags |= CRMOD;
#else
a365 1
#endif
a366 7
#ifndef	USE_TERMIO
	sb.sg_flags |= CBREAK;
	if (f&MODE_ECHO)
	    sb.sg_flags |= CRMOD;
	else
	    sb.sg_flags &= ~CRMOD;
#else
a370 1
#endif
a373 3
#ifndef	USE_TERMIO
	ltc.t_lnextc = _POSIX_VDISABLE;
#else
a374 1
#endif
a377 3
#ifndef USE_TERMIO
	sb.sg_flags |= XTABS;
#else
a384 1
#endif
a385 3
#ifndef USE_TERMIO
	sb.sg_flags &= ~XTABS;
#else
a391 1
#endif
a394 3
#ifndef USE_TERMIO
	lmode &= ~LCTLECH;
#else
a397 1
#endif
a398 3
#ifndef USE_TERMIO
	lmode |= LCTLECH;
#else
a401 1
#endif
a406 11
#ifndef	USE_TERMIO
	if (f & MODE_OUTBIN)
		lmode |= LLITOUT;
	else
		lmode &= ~LLITOUT;

	if (f & MODE_INBIN)
		lmode |= LPASS8;
	else
		lmode &= ~LPASS8;
#else
a423 1
#endif
d434 1
a434 1
#if	defined(USE_TERMIO) && defined(NOKERNINFO)
a442 3
#ifndef	USE_TERMIO
	ltc.t_dsuspc = _POSIX_VDISABLE;
#else
a445 2
#endif
#ifdef	USE_TERMIO
a462 4
#else
	if (tc.t_brkc == (cc_t)(_POSIX_VDISABLE))
		tc.t_brkc = esc;
#endif
a477 6
#ifndef USE_TERMIO
	ltc = oltc;
	tc = otc;
	sb = ottyb;
	lmode = olmode;
#else
a478 1
#endif
a479 6
#ifndef USE_TERMIO
    ioctl(tin, TIOCLSET, (char *)&lmode);
    ioctl(tin, TIOCSLTC, (char *)&ltc);
    ioctl(tin, TIOCSETC, (char *)&tc);
    ioctl(tin, TIOCSETN, (char *)&sb);
#else
a481 1
#endif
a482 2
#if	(!defined(TN3270)) || ((!defined(NOT43)) || defined(PUTCHAR))
# if	!defined(sysV88)
a484 8
# endif
#endif	/* (!defined(TN3270)) || ((!defined(NOT43)) || defined(PUTCHAR)) */
#if	defined(TN3270)
    if (noasynchtty == 0) {
	ioctl(tin, FIOASYNC, (char *)&onoff);
    }
#endif	/* defined(TN3270) */

a614 19
#if	defined(TN3270)
    void
NetSigIO(fd, onoff)
    int fd;
    int onoff;
{
    ioctl(fd, FIOASYNC, (char *)&onoff);	/* hear about input */
}

    void
NetSetPgrp(fd)
    int fd;
{
    pid_t myPid;

    myPid = getpid();
    fcntl(fd, F_SETOWN, myPid);
}
#endif	/*defined(TN3270)*/
d707 2
d726 2
a727 10
#if	defined(TN3270)
    if (noasynchnet == 0) {			/* DBX can't handle! */
	NetSigIO(net, 1);
	NetSetPgrp(net);
    }
#endif	/* defined(TN3270) */

#if	defined(SO_OOBINLINE)
    if (SetSockOpt(net, SOL_SOCKET, SO_OOBINLINE, 1) == -1) {
	perror("SetSockOpt");
a728 1
#endif	/* defined(SO_OOBINLINE) */
a789 9
#	    if defined(TN3270)
		    /*
		     * we can get EBADF if we were in transparent
		     * mode, and the transcom process died.
		    */
	    if (errno == EBADF) {
		return 0;
	    }
#	    endif /* defined(TN3270) */
a811 90
#if	!defined(SO_OOBINLINE)
	    /*
	     * In 4.2 (and some early 4.3) systems, the
	     * OOB indication and data handling in the kernel
	     * is such that if two separate TCP Urgent requests
	     * come in, one byte of TCP data will be overlaid.
	     * This is fatal for Telnet, but we try to live
	     * with it.
	     *
	     * In addition, in 4.2 (and...), a special protocol
	     * is needed to pick up the TCP Urgent data in
	     * the correct sequence.
	     *
	     * What we do is:  if we think we are in urgent
	     * mode, we look to see if we are "at the mark".
	     * If we are, we do an OOB receive.  If we run
	     * this twice, we will do the OOB receive twice,
	     * but the second will fail, since the second
	     * time we were "at the mark", but there wasn't
	     * any data there (the kernel doesn't reset
	     * "at the mark" until we do a normal read).
	     * Once we've read the OOB data, we go ahead
	     * and do normal reads.
	     *
	     * There is also another problem, which is that
	     * since the OOB byte we read doesn't put us
	     * out of OOB state, and since that byte is most
	     * likely the TELNET DM (data mark), we would
	     * stay in the TELNET SYNCH (SYNCHing) state.
	     * So, clocks to the rescue.  If we've "just"
	     * received a DM, then we test for the
	     * presence of OOB data when the receive OOB
	     * fails (and AFTER we did the normal mode read
	     * to clear "at the mark").
	     */
	if (SYNCHing) {
	    int atmark;
	    static int bogus_oob = 0, first = 1;

	    ioctl(net, SIOCATMARK, (char *)&atmark);
	    if (atmark) {
		c = recv(net, netiring.supply, canread, MSG_OOB);
		if ((c == -1) && (errno == EINVAL)) {
		    c = recv(net, netiring.supply, canread, 0);
		    if (clocks.didnetreceive < clocks.gotDM) {
			SYNCHing = stilloob(net);
		    }
		} else if (first && c > 0) {
		    /*
		     * Bogosity check.  Systems based on 4.2BSD
		     * do not return an error if you do a second
		     * recv(MSG_OOB).  So, we do one.  If it
		     * succeeds and returns exactly the same
		     * data, then assume that we are running
		     * on a broken system and set the bogus_oob
		     * flag.  (If the data was different, then
		     * we probably got some valid new data, so
		     * increment the count...)
		     */
		    int i;
		    i = recv(net, netiring.supply + c, canread - c, MSG_OOB);
		    if (i == c &&
			 memcmp(netiring.supply, netiring.supply + c, i) == 0) {
			bogus_oob = 1;
			first = 0;
		    } else if (i < 0) {
			bogus_oob = 0;
			first = 0;
		    } else
			c += i;
		}
		if (bogus_oob && c > 0) {
		    int i;
		    /*
		     * Bogosity.  We have to do the read
		     * to clear the atmark to get out of
		     * an infinate loop.
		     */
		    i = read(net, netiring.supply + c, canread - c);
		    if (i > 0)
			c += i;
		}
	    } else {
		c = recv(net, netiring.supply, canread, 0);
	    }
	} else {
	    c = recv(net, netiring.supply, canread, 0);
	}
	settimer(didnetreceive);
#else	/* !defined(SO_OOBINLINE) */
a812 1
#endif	/* !defined(SO_OOBINLINE) */
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.13 2002/06/12 06:07:16 mpech Exp $	*/
d46 5
a92 3
fd_set *ibitsp, *obitsp, *xbitsp;
int fdsn;

d966 2
a967 2
process_rings(netin, netout, netex, ttyin, ttyout, poll)
    int poll;		/* If 0, then block until something to do */
d976 26
a1001 40
    static struct timeval TimeValue = { 0 };
    int maxfd = -1;
    int tmp;

    if ((netout || netin || netex) && net > maxfd)
	maxfd = net;
    if (ttyout && tout > maxfd)
	maxfd = tout;
    if (ttyin && tin > maxfd)
	maxfd = tin;
    tmp = howmany(maxfd+1, NFDBITS) * sizeof(fd_mask);
    if (tmp > fdsn) {
	if (ibitsp)
	    free(ibitsp);
	if (obitsp)
	    free(obitsp);
	if (xbitsp)
	    free(xbitsp);
	fdsn = tmp;
	if ((ibitsp = (fd_set *)malloc(fdsn)) == NULL)
	    err(1, "malloc");
	if ((obitsp = (fd_set *)malloc(fdsn)) == NULL)
	    err(1, "malloc");
	if ((xbitsp = (fd_set *)malloc(fdsn)) == NULL)
	    err(1, "malloc");
	memset(ibitsp, 0, fdsn);
	memset(obitsp, 0, fdsn);
	memset(xbitsp, 0, fdsn);
    }

    if (netout)
	FD_SET(net, obitsp);
    if (ttyout)
	FD_SET(tout, obitsp);
    if (ttyin)
	FD_SET(tin, ibitsp);
    if (netin)
	FD_SET(net, ibitsp);
    if (netex)
	FD_SET(net, xbitsp);
d1003 1
a1003 2
    if ((c = select(maxfd+1, ibitsp, obitsp, xbitsp,
      (poll == 0)? (struct timeval *)0 : &TimeValue)) < 0) {
a1018 8
			/*
			 * zero the bits (even though kernel does it)
			 * to make sure we are selecting on the right
			 * ones.
			*/
		memset(ibitsp, 0, fdsn);
		memset(obitsp, 0, fdsn);
		memset(xbitsp, 0, fdsn);
d1023 1
a1023 1
	    printf("sleep(5) from telnet, after select\r\n");
d1032 1
a1032 2
    if (FD_ISSET(net, xbitsp)) {
	FD_CLR(net, xbitsp);
d1040 1
a1040 1
    if (FD_ISSET(net, ibitsp)) {
a1042 1
	FD_CLR(net, ibitsp);
d1152 1
a1152 2
    if (FD_ISSET(tin, ibitsp)) {
	FD_CLR(tin, ibitsp);
d1176 1
a1176 2
    if (FD_ISSET(net, obitsp)) {
	FD_CLR(net, obitsp);
d1179 1
a1179 2
    if (FD_ISSET(tout, obitsp)) {
	FD_CLR(tout, obitsp);
@


1.13
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.12 2002/03/25 10:52:32 hin Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.12
log
@Todd Miller pointed this out to me:

    You really want to use 'volatile sig_atomic_t' not just sig_atomic_t
    for flags set in signal handlers.  Without the volatile gcc may
    stick the value in a register but update the on-stack copy in the
    signal handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.11 2002/03/22 13:49:28 hin Exp $	*/
d827 1
a827 1
    int myPid;
@


1.11
log
@Telnet encryption warning messages, taken from kth-krb4-1.1.1.

(krb4-1.1.1 will be imported after release)

Noone bothered to look at this, but I've used this for a couple of weeks,
and i really want this to go in before release.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.10 2001/11/19 19:02:16 mpech Exp $	*/
d847 2
a848 2
sig_atomic_t intr_happened = 0;
sig_atomic_t intr_waiting = 0;
@


1.10
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.9 2001/09/04 23:35:59 millert Exp $	*/
d847 3
d855 4
@


1.9
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.8 2000/10/10 15:41:10 millert Exp $	*/
d254 1
a254 1
    register int func;
d367 1
a367 1
    register int f;
d757 1
a757 1
    register struct termspeeds *tp;
d759 1
a759 1
    register long in, out;
d964 1
a964 1
    register int c;
@


1.8
log
@Use curses, not ocurses and thus setupterm() not tgetent().  This means
we no longer need to have a faked up telnet_setupterm().

Remove some unused variables and add missing err.h include in sys_bsd.c
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.7 1999/05/07 18:29:07 deraadt Exp $	*/
d639 3
d649 3
a651 5
# ifndef SOLARIS
	(void) sigsetmask(sigblock(0) & ~(1<<(SIGTSTP-1)));
# else	SOLARIS
	(void) sigrelse(SIGTSTP);
# endif	SOLARIS
@


1.7
log
@repair TIOCFLUSH use; alaric@@MIT.EDU
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.6 1998/12/28 11:13:51 deraadt Exp $	*/
d38 1
@


1.6
log
@handle oversize fd_set
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.5 1998/03/12 04:57:40 art Exp $	*/
d202 2
a203 1
    (void) ioctl(fileno(stdout), TIOCFLUSH, (char *) 0);
d205 1
a205 1
    (void) ioctl(fileno(stdout), TCFLSH, (char *) 0);
@


1.5
log
@encryption support from kth-krb 0.9.8 (kerberos only)
plus some tweaks for better binary/8-bit support.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.4 1996/12/11 17:14:22 robin Exp $	*/
d91 2
a92 2
static fd_set ibits, obits, xbits;

a98 3
    FD_ZERO(&ibits);
    FD_ZERO(&obits);
    FD_ZERO(&xbits);
d969 39
d1009 2
a1010 29
    if (netout) {
	FD_SET(net, &obits);
    }
    if (ttyout) {
	FD_SET(tout, &obits);
    }
#if	defined(TN3270)
    if (ttyin) {
	FD_SET(tin, &ibits);
    }
#else	/* defined(TN3270) */
    if (ttyin) {
	FD_SET(tin, &ibits);
    }
#endif	/* defined(TN3270) */
#if	defined(TN3270)
    if (netin) {
	FD_SET(net, &ibits);
    }
#   else /* !defined(TN3270) */
    if (netin) {
	FD_SET(net, &ibits);
    }
#   endif /* !defined(TN3270) */
    if (netex) {
	FD_SET(net, &xbits);
    }
    if ((c = select(16, &ibits, &obits, &xbits,
			(poll == 0)? (struct timeval *)0 : &TimeValue)) < 0) {
d1031 3
a1033 3
		FD_ZERO(&ibits);
		FD_ZERO(&obits);
		FD_ZERO(&xbits);
d1047 2
a1048 2
    if (FD_ISSET(net, &xbits)) {
	FD_CLR(net, &xbits);
d1056 1
a1056 1
    if (FD_ISSET(net, &ibits)) {
d1059 1
a1059 1
	FD_CLR(net, &ibits);
d1169 2
a1170 2
    if (FD_ISSET(tin, &ibits)) {
	FD_CLR(tin, &ibits);
d1194 2
a1195 2
    if (FD_ISSET(net, &obits)) {
	FD_CLR(net, &obits);
d1198 2
a1199 2
    if (FD_ISSET(tout, &obits)) {
	FD_CLR(tout, &obits);
@


1.4
log
@Add ``#include <unistd.h>'' for prototypes of:
close(2), write(2), read(2), select(2), sleep(3) and isatty(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_bsd.c,v 1.3 1996/03/27 19:33:07 niklas Exp $	*/
d37 1
a37 8
#ifndef lint
#if 0
from: static char sccsid[] = "@@(#)sys_bsd.c	8.4 (Berkeley) 5/30/95";
static char rcsid[] = "$NetBSD: sys_bsd.c,v 1.11 1996/02/28 21:04:10 thorpej Exp $";
#else
static char rcsid[] = "$OpenBSD: sys_bsd.c,v 1.3 1996/03/27 19:33:07 niklas Exp $";
#endif
#endif /* not lint */
a43 28

#include <fcntl.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <signal.h>
#include <errno.h>
#include <arpa/telnet.h>
#include <unistd.h>

#include "ring.h"

#include "fdset.h"

#include "defines.h"
#include "externs.h"
#include "types.h"

#if	defined(CRAY) || (defined(USE_TERMIO) && !defined(SYSV_TERMIO))
#define	SIG_FUNC_RET	void
#else
#define	SIG_FUNC_RET	int
#endif

#ifdef	SIGINFO
extern SIG_FUNC_RET ayt_status();
#endif

d59 2
a60 2
struct	termio old_tc = { 0 };
extern struct termio new_tc;
d359 6
d377 1
a377 1
    struct termio tmp_tc;
d577 1
a577 1
	if (f & MODE_OUTBIN) {
d580 5
a584 1
		tmp_tc.c_oflag &= ~OPOST;
a595 7
	SIG_FUNC_RET susp();
#endif	/* SIGTSTP */
#ifdef	SIGINFO
	SIG_FUNC_RET ayt();
#endif

#ifdef	SIGTSTP
d641 1
a641 1
	SIG_FUNC_RET ayt_status();
d643 1
a643 1
	(void) signal(SIGINFO, ayt_status);
d839 1
a839 1
    SIG_FUNC_RET
d848 1
a848 1
    SIG_FUNC_RET
d861 1
a861 1
    SIG_FUNC_RET
d878 1
a878 1
    SIG_FUNC_RET
d891 1
a891 1
    SIG_FUNC_RET
d903 1
a903 1
    SIG_FUNC_RET
d1168 7
a1174 1
	    if (c < 0) {
a1175 11
	    }
	    if (c == 0) {
		/* must be an EOF... */
		if (MODE_LOCAL_CHARS(globalmode) && isatty(tin)) {
		    *ttyiring.supply = termEofChar;
		    c = 1;
		} else {
		    clienteof = 1;
		    shutdown(net, 1);
		    return 0;
		}
@


1.3
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD$";
d59 1
@


1.2
log
@From NetBSD:
I (tls) seem to have forgotten to commit the patch in PR1608 when I closed it.
Fix VLNEXT handling.
@
text
@d1 3
d38 6
a43 2
/* from: static char sccsid[] = "@@(#)sys_bsd.c	8.1 (Berkeley) 6/6/93"; */
static char *rcsid = "$Id: sys_bsd.c,v 1.1.1.1 1995/10/18 08:46:14 deraadt Exp $";
d151 1
a151 1
    char *buf;
d234 1
a234 1
 
d339 1
a339 1
    memcpy(new_tc.c_cc, old_tc.c_cc, sizeof(old_tc.c_cc));
d678 1
d680 3
d717 16
d734 5
a738 1
# define B19200 B9600
d742 5
a746 1
# define B38400 B19200
d749 13
d771 8
a778 6
	{ 0,     B0 },     { 50,    B50 },   { 75,    B75 },
	{ 110,   B110 },   { 134,   B134 },  { 150,   B150 },
	{ 200,   B200 },   { 300,   B300 },  { 600,   B600 },
	{ 1200,  B1200 },  { 1800,  B1800 }, { 2400,  B2400 },
	{ 4800,  B4800 },  { 9600,  B9600 }, { 19200, B19200 },
	{ 38400, B38400 }, { -1,    B38400 }
d780 1
d787 1
d789 1
d797 1
d807 4
d1006 1
a1006 1
    } 
d1145 1
a1145 1
			  bcmp(netiring.supply, netiring.supply + c, i) == 0) {
d1194 2
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
static char *rcsid = "$Id: sys_bsd.c,v 1.6 1995/03/17 18:03:08 mycroft Exp $";
d533 1
a533 3
# ifdef VLNEXT
	tmp_tc.c_cc[VLNEXT] = (cc_t)(_POSIX_VDISABLE);
# endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

