head	1.85;
access;
symbols
	OPENBSD_6_1:1.84.0.6
	OPENBSD_6_1_BASE:1.84
	OPENBSD_6_0:1.84.0.2
	OPENBSD_6_0_BASE:1.84
	OPENBSD_5_9:1.82.0.2
	OPENBSD_5_9_BASE:1.82
	OPENBSD_5_8:1.71.0.6
	OPENBSD_5_8_BASE:1.71
	OPENBSD_5_7:1.71.0.2
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.69.0.4
	OPENBSD_5_6_BASE:1.69
	OPENBSD_5_5:1.55.0.4
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.53.0.10
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.53.0.8
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.53.0.6
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.4
	OPENBSD_5_0:1.53.0.2
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.52.0.4
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.52.0.2
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.51.0.2
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.51.0.4
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.49.0.14
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.49.0.12
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.49.0.10
	OPENBSD_4_3_BASE:1.49
	OPENBSD_4_2:1.49.0.8
	OPENBSD_4_2_BASE:1.49
	OPENBSD_4_1:1.49.0.6
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.49.0.4
	OPENBSD_4_0_BASE:1.49
	OPENBSD_3_9:1.49.0.2
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.48.0.4
	OPENBSD_3_8_BASE:1.48
	OPENBSD_3_7:1.48.0.2
	OPENBSD_3_7_BASE:1.48
	OPENBSD_3_6:1.46.0.4
	OPENBSD_3_6_BASE:1.46
	OPENBSD_3_5:1.46.0.2
	OPENBSD_3_5_BASE:1.46
	OPENBSD_3_4:1.45.0.2
	OPENBSD_3_4_BASE:1.45
	OPENBSD_3_3:1.42.0.4
	OPENBSD_3_3_BASE:1.42
	OPENBSD_3_2:1.42.0.2
	OPENBSD_3_2_BASE:1.42
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	OPENBSD_3_0:1.38.0.2
	OPENBSD_3_0_BASE:1.38
	OPENBSD_2_9_BASE:1.34
	OPENBSD_2_9:1.34.0.2
	OPENBSD_2_8:1.33.0.2
	OPENBSD_2_8_BASE:1.33
	OPENBSD_2_7:1.28.0.2
	OPENBSD_2_7_BASE:1.28
	OPENBSD_2_6:1.21.0.2
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.20.0.2
	OPENBSD_2_5_BASE:1.20
	OPENBSD_2_4:1.19.0.2
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.85
date	2017.07.19.12.25.52;	author deraadt;	state Exp;
branches;
next	1.84;
commitid	t9dchEDjYuILVEVu;

1.84
date	2016.05.03.02.06.54;	author awolk;	state Exp;
branches;
next	1.83;
commitid	KxL6O43ERmJM4EBg;

1.83
date	2016.03.16.15.41.11;	author krw;	state Exp;
branches;
next	1.82;
commitid	JEVxsRygqcjPtWTf;

1.82
date	2015.12.09.19.39.10;	author mmcc;	state Exp;
branches;
next	1.81;
commitid	vYfMHQk0uPOMI7wA;

1.81
date	2015.11.24.05.06.24;	author beck;	state Exp;
branches;
next	1.80;
commitid	UPNmjZ9lwrIxCZws;

1.80
date	2015.11.20.12.43.37;	author jca;	state Exp;
branches;
next	1.79;
commitid	xA1XvlkYmOIiueH9;

1.79
date	2015.11.13.17.04.48;	author deraadt;	state Exp;
branches;
next	1.78;
commitid	djH4uFvsg7Vd7Wbw;

1.78
date	2015.11.13.17.01.12;	author deraadt;	state Exp;
branches;
next	1.77;
commitid	d9ke1jbuBYVSlCUU;

1.77
date	2015.11.13.16.53.46;	author deraadt;	state Exp;
branches;
next	1.76;
commitid	ED3U8LjhbD1s750O;

1.76
date	2015.11.13.16.50.03;	author deraadt;	state Exp;
branches;
next	1.75;
commitid	edZZvywqRwRUcW6M;

1.75
date	2015.11.13.16.46.30;	author deraadt;	state Exp;
branches;
next	1.74;
commitid	Ao2vzMAwpISx6TZp;

1.74
date	2015.10.26.00.33.03;	author jca;	state Exp;
branches;
next	1.73;
commitid	hSvFOL6NvmHxJNXG;

1.73
date	2015.10.25.14.42.02;	author jca;	state Exp;
branches;
next	1.72;
commitid	0FpmPYxvzOpdXhCm;

1.72
date	2015.10.25.14.11.37;	author jca;	state Exp;
branches;
next	1.71;
commitid	AVduLoFXmybiJqII;

1.71
date	2015.01.16.06.40.13;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	Uu5nFG3wCl0LACBb;

1.70
date	2014.09.09.03.41.08;	author guenther;	state Exp;
branches;
next	1.69;
commitid	VR4fCtOZMbshOip1;

1.69
date	2014.07.22.07.30.24;	author jsg;	state Exp;
branches;
next	1.68;
commitid	5F2TXUtxGWuYgYJc;

1.68
date	2014.07.20.12.08.55;	author guenther;	state Exp;
branches;
next	1.67;
commitid	S3moNyJOYK9CLzJu;

1.67
date	2014.07.20.10.55.26;	author guenther;	state Exp;
branches;
next	1.66;
commitid	KvN9Bh2AXHiOi5nI;

1.66
date	2014.07.20.10.18.10;	author guenther;	state Exp;
branches;
next	1.65;
commitid	g3VtcxajtWcT7VuD;

1.65
date	2014.07.20.09.59.42;	author guenther;	state Exp;
branches;
next	1.64;
commitid	11DQHPdHfrXBxigB;

1.64
date	2014.07.20.09.31.25;	author guenther;	state Exp;
branches;
next	1.63;
commitid	sgiDhU5W6KOMYLqU;

1.63
date	2014.07.20.08.56.47;	author guenther;	state Exp;
branches;
next	1.62;
commitid	uvklKjlkNqUA10lW;

1.62
date	2014.07.20.08.12.45;	author guenther;	state Exp;
branches;
next	1.61;
commitid	qbZdS8s4KEeVt81G;

1.61
date	2014.07.20.07.35.04;	author guenther;	state Exp;
branches;
next	1.60;
commitid	2cOmMOs302nEGrCZ;

1.60
date	2014.07.20.06.39.41;	author guenther;	state Exp;
branches;
next	1.59;
commitid	2c9hYJDg2dE2R3T8;

1.59
date	2014.07.20.05.22.02;	author guenther;	state Exp;
branches;
next	1.58;
commitid	mkPeU1MBN7ewMEUq;

1.58
date	2014.07.20.04.07.16;	author guenther;	state Exp;
branches;
next	1.57;
commitid	to6mXl3eODyXY0fy;

1.57
date	2014.07.20.04.00.47;	author guenther;	state Exp;
branches;
next	1.56;
commitid	UBvFZ3iNmtaucCj9;

1.56
date	2014.07.19.23.50.38;	author guenther;	state Exp;
branches;
next	1.55;
commitid	J1fNmylmVMpKGeua;

1.55
date	2013.10.26.21.33.29;	author sthen;	state Exp;
branches;
next	1.54;

1.54
date	2013.10.21.09.02.37;	author phessler;	state Exp;
branches;
next	1.53;

1.53
date	2011.06.21.17.31.07;	author mikeb;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2009.06.05.00.20.46;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2009.04.27.06.08.10;	author matthieu;	state Exp;
branches;
next	1.49;

1.49
date	2006.01.14.21.21.46;	author otto;	state Exp;
branches;
next	1.48;

1.48
date	2005.02.27.15.46.42;	author otto;	state Exp;
branches;
next	1.47;

1.47
date	2004.11.17.01.47.20;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2003.12.28.21.53.01;	author otto;	state Exp;
branches
	1.46.2.1
	1.46.4.1;
next	1.45;

1.45
date	2003.06.03.02.56.18;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2003.04.25.20.07.09;	author pvalchev;	state Exp;
branches;
next	1.43;

1.43
date	2003.04.03.12.05.58;	author hin;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.17.17.20.49;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.38;

1.38
date	2001.09.03.05.28.51;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.12.05.17.22;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.09.07.04.54;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2001.04.30.10.00.04;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2000.11.08.21.49.44;	author aaron;	state Exp;
branches;
next	1.33;

1.33
date	2000.10.10.15.41.10;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.13.19.41.13;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.13.19.39.01;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.13.08.37.07;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.02.04.10.49;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.30.23.57.08;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2000.02.05.18.17.56;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2000.01.29.16.07.08;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	99.12.20.09.43.01;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	99.12.11.22.12.00;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	99.12.11.09.08.08;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	99.12.07.01.10.29;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	99.07.20.12.50.33;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	99.01.04.07.55.05;	author art;	state Exp;
branches;
next	1.19;

1.19
date	98.07.16.18.55.59;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	98.07.09.06.32.10;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.07.01.19.31.12;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	98.05.23.12.15.20;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.05.15.03.16.35;	author art;	state Exp;
branches;
next	1.14;

1.14
date	98.05.15.01.26.09;	author art;	state Exp;
branches;
next	1.13;

1.13
date	98.04.07.20.01.06;	author art;	state Exp;
branches;
next	1.12;

1.12
date	98.03.18.21.21.40;	author art;	state Exp;
branches;
next	1.11;

1.11
date	98.03.12.17.31.30;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.03.12.04.57.29;	author art;	state Exp;
branches;
next	1.9;

1.9
date	96.12.22.03.26.08;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.12.06.15.21.53;	author robin;	state Exp;
branches;
next	1.7;

1.7
date	96.10.28.00.54.10;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.09.05.09.10.02;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.03.14.01.55;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.23.44.11;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.27.19.32.58;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.01.05.16.41.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.14;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.14;	author deraadt;	state Exp;
branches;
next	;

1.46.2.1
date	2005.03.29.20.20.10;	author brad;	state Exp;
branches;
next	;

1.46.4.1
date	2005.03.29.19.49.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.85
log
@A few cleanups.  This only needs to operate on systems with SIGWINCH,
SIGINFO, and Bxxxx values that equal xxxx.
ok tom millert
@
text
@/*	$OpenBSD: commands.c,v 1.84 2016/05/03 02:06:54 awolk Exp $	*/
/*	$NetBSD: commands.c,v 1.14 1996/03/24 22:03:48 jtk Exp $	*/

/*
 * Copyright (c) 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "telnet_locl.h"

#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <arpa/telnet.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <netdb.h>
#include <pwd.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

char	*hostname;

typedef struct {
	char	*name;		/* command name */
	char	*help;		/* help string (NULL for no help) */
	int	(*handler)(int, char **);/* routine which executes command */
	int	needconnect;	/* Do we need to be connected to execute? */
} Command;

static char line[256];
static int margc;
static char *margv[20];

static void
makeargv(void)
{
    char *cp, *cp2, c;
    char **argp = margv;

    margc = 0;
    cp = line;
    while ((c = *cp)) {
	int inquote = 0;
	while (isspace((unsigned char)c))
	    c = *++cp;
	if (c == '\0')
	    break;
	*argp++ = cp;
	margc += 1;
	for (cp2 = cp; c != '\0'; c = *++cp) {
	    if (inquote) {
		if (c == inquote) {
		    inquote = 0;
		    continue;
		}
	    } else {
		if (c == '\\') {
		    if ((c = *++cp) == '\0')
			break;
		} else if (c == '"') {
		    inquote = '"';
		    continue;
		} else if (c == '\'') {
		    inquote = '\'';
		    continue;
		} else if (isspace((unsigned char)c))
		    break;
	    }
	    *cp2++ = c;
	}
	*cp2 = '\0';
	if (c == '\0')
	    break;
	cp++;
    }
    *argp++ = 0;
}

/*
 * Make a character string into a number.
 *
 * Todo:  1.  Could take random integers (12, 0x12, 012, 0b1).
 */

static char
special(char *s)
{
	char c;
	char b;

	switch (*s) {
	case '^':
		b = *++s;
		if (b == '?') {
		    c = b | 0x40;		/* DEL */
		} else {
		    c = b & 0x1f;
		}
		break;
	default:
		c = *s;
		break;
	}
	return c;
}

/*
 * Construct a control character sequence
 * for a special character.
 */
static char *
control(cc_t c)
{
	static char buf[5];
	/*
	 * The only way I could get the Sun 3.5 compiler
	 * to shut up about
	 *	if ((unsigned int)c >= 0x80)
	 * was to assign "c" to an unsigned int variable...
	 * Arggg....
	 */
	unsigned int uic = (unsigned int)c;

	if (uic == 0x7f)
		return ("^?");
	if (c == (cc_t)_POSIX_VDISABLE) {
		return "off";
	}
	if (uic >= 0x80) {
		buf[0] = '\\';
		buf[1] = ((c>>6)&07) + '0';
		buf[2] = ((c>>3)&07) + '0';
		buf[3] = (c&07) + '0';
		buf[4] = 0;
	} else if (uic >= 0x20) {
		buf[0] = c;
		buf[1] = 0;
	} else {
		buf[0] = '^';
		buf[1] = '@@'+c;
		buf[2] = 0;
	}
	return (buf);
}

/*
 *	The following are data structures and routines for
 *	the "send" command.
 *
 */

struct sendlist {
    char	*name;		/* How user refers to it (case independent) */
    char	*help;		/* Help information (0 ==> no help) */
    int		needconnect;	/* Need to be connected */
    int		narg;		/* Number of arguments */
    int		(*handler)();	/* Routine to perform (for special ops) */
    int		nbyte;		/* Number of bytes to send this command */
    int		what;		/* Character to be sent (<0 ==> special) */
};


static int
	send_esc(void),
	send_help(void),
	send_docmd(char *),
	send_dontcmd(char *),
	send_willcmd(char *),
	send_wontcmd(char *);

static struct sendlist Sendlist[] = {
    { "ao",	"Send Telnet Abort output",		1, 0, 0, 2, AO },
    { "ayt",	"Send Telnet 'Are You There'",		1, 0, 0, 2, AYT },
    { "brk",	"Send Telnet Break",			1, 0, 0, 2, BREAK },
    { "break",	0,					1, 0, 0, 2, BREAK },
    { "ec",	"Send Telnet Erase Character",		1, 0, 0, 2, EC },
    { "el",	"Send Telnet Erase Line",		1, 0, 0, 2, EL },
    { "escape",	"Send current escape character",	1, 0, send_esc, 1, 0 },
    { "ga",	"Send Telnet 'Go Ahead' sequence",	1, 0, 0, 2, GA },
    { "ip",	"Send Telnet Interrupt Process",	1, 0, 0, 2, IP },
    { "intp",	0,					1, 0, 0, 2, IP },
    { "interrupt", 0,					1, 0, 0, 2, IP },
    { "intr",	0,					1, 0, 0, 2, IP },
    { "nop",	"Send Telnet 'No operation'",		1, 0, 0, 2, NOP },
    { "eor",	"Send Telnet 'End of Record'",		1, 0, 0, 2, EOR },
    { "abort",	"Send Telnet 'Abort Process'",		1, 0, 0, 2, ABORT },
    { "susp",	"Send Telnet 'Suspend Process'",	1, 0, 0, 2, SUSP },
    { "eof",	"Send Telnet End of File Character",	1, 0, 0, 2, xEOF },
    { "synch",	"Perform Telnet 'Synch operation'",	1, 0, dosynch, 2, 0 },
    { "getstatus", "Send request for STATUS",		1, 0, get_status, 6, 0 },
    { "?",	"Display send options",			0, 0, send_help, 0, 0 },
    { "help",	0,					0, 0, send_help, 0, 0 },
    { "do",	0,					0, 1, send_docmd, 3, 0 },
    { "dont",	0,					0, 1, send_dontcmd, 3, 0 },
    { "will",	0,					0, 1, send_willcmd, 3, 0 },
    { "wont",	0,					0, 1, send_wontcmd, 3, 0 },
    { 0 }
};

#define	GETSEND(name) ((struct sendlist *) genget(name, (char **) Sendlist, \
				sizeof(struct sendlist)))

static int
sendcmd(int argc, char **argv)
{
    int count;		/* how many bytes we are going to need to send */
    int i;
    struct sendlist *s;	/* pointer to current command */
    int success = 0;
    int needconnect = 0;

    if (argc < 2) {
	printf("need at least one argument for 'send' command\r\n");
	printf("'send ?' for help\r\n");
	return 0;
    }
    /*
     * First, validate all the send arguments.
     * In addition, we see how much space we are going to need, and
     * whether or not we will be doing a "SYNCH" operation (which
     * flushes the network queue).
     */
    count = 0;
    for (i = 1; i < argc; i++) {
	s = GETSEND(argv[i]);
	if (s == 0) {
	    printf("Unknown send argument '%s'\r\n'send ?' for help.\r\n",
			argv[i]);
	    return 0;
	} else if (Ambiguous(s)) {
	    printf("Ambiguous send argument '%s'\r\n'send ?' for help.\r\n",
			argv[i]);
	    return 0;
	}
	if (i + s->narg >= argc) {
	    fprintf(stderr,
	    "Need %d argument%s to 'send %s' command.  'send %s ?' for help.\r\n",
		s->narg, s->narg == 1 ? "" : "s", s->name, s->name);
	    return 0;
	}
	count += s->nbyte;
	if (s->handler == send_help) {
	    send_help();
	    return 0;
	}

	i += s->narg;
	needconnect += s->needconnect;
    }
    if (!connected && needconnect) {
	printf("?Need to be connected first.\r\n");
	printf("'send ?' for help\r\n");
	return 0;
    }
    /* Now, do we have enough room? */
    if (NETROOM() < count) {
	printf("There is not enough room in the buffer TO the network\r\n");
	printf("to process your request.  Nothing will be done.\r\n");
	printf("('send synch' will throw away most data in the network\r\n");
	printf("buffer, if this might help.)\r\n");
	return 0;
    }
    /* OK, they are all OK, now go through again and actually send */
    count = 0;
    for (i = 1; i < argc; i++) {
	if ((s = GETSEND(argv[i])) == 0) {
	    fprintf(stderr, "Telnet 'send' error - argument disappeared!\r\n");
	    quit();
	}
	if (s->handler) {
	    count++;
	    success += (*s->handler)((s->narg > 0) ? argv[i+1] : 0,
				  (s->narg > 1) ? argv[i+2] : 0);
	    i += s->narg;
	} else {
	    NET2ADD(IAC, s->what);
	    printoption("SENT", IAC, s->what);
	}
    }
    return (count == success);
}

static int send_tncmd(void (*func)(int, int), char *cmd, char *name);

static int
send_esc(void)
{
    NETADD(escape);
    return 1;
}

static int
send_docmd(char *name)
{
    return(send_tncmd(send_do, "do", name));
}

static int
send_dontcmd(char *name)
{
    return(send_tncmd(send_dont, "dont", name));
}

static int
send_willcmd(char *name)
{
    return(send_tncmd(send_will, "will", name));
}

static int
send_wontcmd(char *name)
{
    return(send_tncmd(send_wont, "wont", name));
}

int
send_tncmd(void (*func)(int, int), char *cmd, char *name)
{
    char **cpp;
    extern char *telopts[];
    int val = 0;

    if (isprefix(name, "help") || isprefix(name, "?")) {
	int col, len;

	printf("Usage: send %s <value|option>\r\n", cmd);
	printf("\"value\" must be from 0 to 255\r\n");
	printf("Valid options are:\r\n\t");

	col = 8;
	for (cpp = telopts; *cpp; cpp++) {
	    len = strlen(*cpp) + 3;
	    if (col + len > 65) {
		printf("\r\n\t");
		col = 8;
	    }
	    printf(" \"%s\"", *cpp);
	    col += len;
	}
	printf("\r\n");
	return 0;
    }
    cpp = (char **)genget(name, telopts, sizeof(char *));
    if (Ambiguous(cpp)) {
	fprintf(stderr,"'%s': ambiguous argument ('send %s ?' for help).\r\n",
					name, cmd);
	return 0;
    }
    if (cpp) {
	val = cpp - telopts;
    } else {
	char *cp = name;

	while (*cp >= '0' && *cp <= '9') {
	    val *= 10;
	    val += *cp - '0';
	    cp++;
	}
	if (*cp != 0) {
	    fprintf(stderr, "'%s': unknown argument ('send %s ?' for help).\r\n",
					name, cmd);
	    return 0;
	} else if (val < 0 || val > 255) {
	    fprintf(stderr, "'%s': bad value ('send %s ?' for help).\r\n",
					name, cmd);
	    return 0;
	}
    }
    if (!connected) {
	printf("?Need to be connected first.\r\n");
	return 0;
    }
    (*func)(val, 1);
    return 1;
}

static int
send_help(void)
{
    struct sendlist *s;	/* pointer to current command */
    for (s = Sendlist; s->name; s++) {
	if (s->help)
	    printf("%-15s %s\r\n", s->name, s->help);
    }
    return(0);
}

/*
 * The following are the routines and data structures referred
 * to by the arguments to the "toggle" command.
 */

static int
lclchars(int unused)
{
    donelclchars = 1;
    return 1;
}

static int
togcrlf(int unused)
{
    if (crlf) {
	printf("Will send carriage returns as telnet <CR><LF>.\r\n");
    } else {
	printf("Will send carriage returns as telnet <CR><NUL>.\r\n");
    }
    return 1;
}

int binmode;

static int
togbinary(int val)
{
    donebinarytoggle = 1;

    if (val >= 0) {
	binmode = val;
    } else {
	if (my_want_state_is_will(TELOPT_BINARY) &&
				my_want_state_is_do(TELOPT_BINARY)) {
	    binmode = 1;
	} else if (my_want_state_is_wont(TELOPT_BINARY) &&
				my_want_state_is_dont(TELOPT_BINARY)) {
	    binmode = 0;
	}
	val = binmode ? 0 : 1;
    }

    if (val == 1) {
	if (my_want_state_is_will(TELOPT_BINARY) &&
					my_want_state_is_do(TELOPT_BINARY)) {
	    printf("Already operating in binary mode with remote host.\r\n");
	} else {
	    printf("Negotiating binary mode with remote host.\r\n");
	    tel_enter_binary(3);
	}
    } else {
	if (my_want_state_is_wont(TELOPT_BINARY) &&
					my_want_state_is_dont(TELOPT_BINARY)) {
	    printf("Already in network ascii mode with remote host.\r\n");
	} else {
	    printf("Negotiating network ascii mode with remote host.\r\n");
	    tel_leave_binary(3);
	}
    }
    return 1;
}

static int
togrbinary(int val)
{
    donebinarytoggle = 1;

    if (val == -1)
	val = my_want_state_is_do(TELOPT_BINARY) ? 0 : 1;

    if (val == 1) {
	if (my_want_state_is_do(TELOPT_BINARY)) {
	    printf("Already receiving in binary mode.\r\n");
	} else {
	    printf("Negotiating binary mode on input.\r\n");
	    tel_enter_binary(1);
	}
    } else {
	if (my_want_state_is_dont(TELOPT_BINARY)) {
	    printf("Already receiving in network ascii mode.\r\n");
	} else {
	    printf("Negotiating network ascii mode on input.\r\n");
	    tel_leave_binary(1);
	}
    }
    return 1;
}

static int
togxbinary(int val)
{
    donebinarytoggle = 1;

    if (val == -1)
	val = my_want_state_is_will(TELOPT_BINARY) ? 0 : 1;

    if (val == 1) {
	if (my_want_state_is_will(TELOPT_BINARY)) {
	    printf("Already transmitting in binary mode.\r\n");
	} else {
	    printf("Negotiating binary mode on output.\r\n");
	    tel_enter_binary(2);
	}
    } else {
	if (my_want_state_is_wont(TELOPT_BINARY)) {
	    printf("Already transmitting in network ascii mode.\r\n");
	} else {
	    printf("Negotiating network ascii mode on output.\r\n");
	    tel_leave_binary(2);
	}
    }
    return 1;
}


static int togglehelp(int);

struct togglelist {
    char	*name;			/* name of toggle */
    char	*help;			/* help message */
    int		(*handler)(int);	/* routine to do actual setting */
    int		*variable;
    char	*actionexplanation;
    int		needconnect;	/* Need to be connected */
};

static struct togglelist Togglelist[] = {
    { "autoflush",
	"flushing of output when sending interrupt characters",
	    0,
		&autoflush,
		    "flush output when sending interrupt characters" },
    { "autosynch",
	"automatic sending of interrupt characters in urgent mode",
	    0,
		&autosynch,
		    "send interrupt characters in urgent mode" },
    { "autologin",
	"automatic sending of login name",
	    0,
		&autologin,
		    "send login name" },
    { "skiprc",
	"don't read ~/.telnetrc file",
	    0,
		&skiprc,
		    "skip reading of ~/.telnetrc file" },
    { "binary",
	"sending and receiving of binary data",
	    togbinary,
		0,
		    0 },
    { "inbinary",
	"receiving of binary data",
	    togrbinary,
		0,
		    0 },
    { "outbinary",
	"sending of binary data",
	    togxbinary,
		0,
		    0 },
    { "crlf",
	"sending carriage returns as telnet <CR><LF>",
	    togcrlf,
		&crlf,
		    0 },
    { "crmod",
	"mapping of received carriage returns",
	    0,
		&crmod,
		    "map carriage return on output" },
    { "localchars",
	"local recognition of certain control characters",
	    lclchars,
		&localchars,
		    "recognize certain control characters" },
    { " ", "", 0, 0 },		/* empty line */
    { "netdata",
	"printing of hexadecimal network data (debugging)",
	    0,
		&netdata,
		    "print hexadecimal representation of network traffic" },
    { "prettydump",
	"output of \"netdata\" to user readable format (debugging)",
	    0,
		&prettydump,
		    "print user readable output for \"netdata\"" },
    { "options",
	"viewing of options processing (debugging)",
	    0,
		&showoptions,
		    "show option processing" },
    { "termdata",
	"(debugging) toggle printing of hexadecimal terminal data",
	    0,
		&termdata,
		    "print hexadecimal representation of terminal traffic" },
    { "?",
	0,
	    togglehelp },
    { "help",
	0,
	    togglehelp },
    { 0 }
};

static int
togglehelp(int unused)
{
    struct togglelist *c;

    for (c = Togglelist; c->name; c++) {
	if (c->help) {
	    if (*c->help)
		printf("%-15s toggle %s\r\n", c->name, c->help);
	    else
		printf("\r\n");
	}
    }
    printf("\r\n");
    printf("%-15s %s\r\n", "?", "display help information");
    return 0;
}

static void
settogglehelp(int set)
{
    struct togglelist *c;

    for (c = Togglelist; c->name; c++) {
	if (c->help) {
	    if (*c->help)
		printf("%-15s %s %s\r\n", c->name, set ? "enable" : "disable",
						c->help);
	    else
		printf("\r\n");
	}
    }
}

#define	GETTOGGLE(name) (struct togglelist *) \
		genget(name, (char **) Togglelist, sizeof(struct togglelist))

static int
toggle(int argc, char *argv[])
{
    int retval = 1;
    char *name;
    struct togglelist *c;

    if (argc < 2) {
	fprintf(stderr,
	    "Need an argument to 'toggle' command.  'toggle ?' for help.\r\n");
	return 0;
    }
    argc--;
    argv++;
    while (argc--) {
	name = *argv++;
	c = GETTOGGLE(name);
	if (Ambiguous(c)) {
	    fprintf(stderr, "'%s': ambiguous argument ('toggle ?' for help).\r\n",
					name);
	    return 0;
	} else if (c == 0) {
	    fprintf(stderr, "'%s': unknown argument ('toggle ?' for help).\r\n",
					name);
	    return 0;
	} else if (!connected && c->needconnect) {
	    printf("?Need to be connected first.\r\n");
	    printf("'send ?' for help\r\n");
	    return 0;
	} else {
	    if (c->variable) {
		*c->variable = !*c->variable;		/* invert it */
		if (c->actionexplanation) {
		    printf("%s %s.\r\n", *c->variable? "Will" : "Won't",
							c->actionexplanation);
		}
	    }
	    if (c->handler) {
		retval &= (*c->handler)(-1);
	    }
	}
    }
    return retval;
}

/*
 * The following perform the "set" command.
 */

struct termios new_tc = { 0 };

struct setlist {
    char *name;				/* name */
    char *help;				/* help information */
    void (*handler)(const char *);
    cc_t *charp;			/* where it is located at */
};

static struct setlist Setlist[] = {
#ifdef	KLUDGELINEMODE
    { "echo", 	"character to toggle local echoing on/off", 0, &echoc },
#endif
    { "escape",	"character to escape back to telnet command mode", 0, &escape },
    { "rlogin", "rlogin escape character", 0, &rlogin },
    { " ", "" },
    { " ", "The following need 'localchars' to be toggled true", 0, 0 },
    { "flushoutput", "character to cause an Abort Output", 0, &termFlushChar },
    { "interrupt", "character to cause an Interrupt Process", 0, &termIntChar },
    { "quit",	"character to cause an Abort process", 0, &termQuitChar },
    { "eof",	"character to cause an EOF ", 0, &termEofChar },
    { " ", "" },
    { " ", "The following are for local editing in linemode", 0, 0 },
    { "erase",	"character to use to erase a character", 0, &termEraseChar },
    { "kill",	"character to use to erase a line", 0, &termKillChar },
    { "lnext",	"character to use for literal next", 0, &termLiteralNextChar },
    { "susp",	"character to cause a Suspend Process", 0, &termSuspChar },
    { "reprint", "character to use for line reprint", 0, &termRprntChar },
    { "worderase", "character to use to erase a word", 0, &termWerasChar },
    { "start",	"character to use for XON", 0, &termStartChar },
    { "stop",	"character to use for XOFF", 0, &termStopChar },
    { "forw1",	"alternate end of line character", 0, &termForw1Char },
    { "forw2",	"alternate end of line character", 0, &termForw2Char },
    { "ayt",	"alternate AYT character", 0, &termAytChar },
    { 0 }
};

static struct setlist *
getset(char *name)
{
    return (struct setlist *)
		genget(name, (char **) Setlist, sizeof(struct setlist));
}

void
set_escape_char(char *s)
{
	if (rlogin != _POSIX_VDISABLE) {
		rlogin = (s && *s) ? special(s) : _POSIX_VDISABLE;
		printf("Telnet rlogin escape character is '%s'.\r\n",
					control(rlogin));
	} else {
		escape = (s && *s) ? special(s) : _POSIX_VDISABLE;
		printf("Telnet escape character is '%s'.\r\n", control(escape));
	}
}

static int
setcmd(int argc, char *argv[])
{
    int value;
    struct setlist *ct;
    struct togglelist *c;

    if (argc < 2 || argc > 3) {
	printf("Format is 'set Name Value'\r\n'set ?' for help.\r\n");
	return 0;
    }
    if ((argc == 2) && (isprefix(argv[1], "?") || isprefix(argv[1], "help"))) {
	for (ct = Setlist; ct->name; ct++)
	    printf("%-15s %s\r\n", ct->name, ct->help);
	printf("\r\n");
	settogglehelp(1);
	printf("%-15s %s\r\n", "?", "display help information");
	return 0;
    }

    ct = getset(argv[1]);
    if (ct == 0) {
	c = GETTOGGLE(argv[1]);
	if (c == 0) {
	    fprintf(stderr, "'%s': unknown argument ('set ?' for help).\r\n",
			argv[1]);
	    return 0;
	} else if (Ambiguous(c)) {
	    fprintf(stderr, "'%s': ambiguous argument ('set ?' for help).\r\n",
			argv[1]);
	    return 0;
	} else if (!connected && c->needconnect) {
	    printf("?Need to be connected first.\r\n");
	    printf("'send ?' for help\r\n");
	    return 0;
	}

	if (c->variable) {
	    if ((argc == 2) || (strcmp("on", argv[2]) == 0))
		*c->variable = 1;
	    else if (strcmp("off", argv[2]) == 0)
		*c->variable = 0;
	    else {
		printf("Format is 'set togglename [on|off]'\r\n'set ?' for help.\r\n");
		return 0;
	    }
	    if (c->actionexplanation) {
		printf("%s %s.\r\n", *c->variable? "Will" : "Won't",
							c->actionexplanation);
	    }
	}
	if (c->handler)
	    (*c->handler)(1);
    } else if (argc != 3) {
	printf("Format is 'set Name Value'\r\n'set ?' for help.\r\n");
	return 0;
    } else if (Ambiguous(ct)) {
	fprintf(stderr, "'%s': ambiguous argument ('set ?' for help).\r\n",
			argv[1]);
	return 0;
    } else if (ct->handler) {
	(*ct->handler)(argv[2]);
	printf("%s set to \"%s\".\r\n", ct->name, (char *)ct->charp);
    } else {
	if (strcmp("off", argv[2])) {
	    value = special(argv[2]);
	} else {
	    value = _POSIX_VDISABLE;
	}
	*(ct->charp) = (cc_t)value;
	printf("%s character is '%s'.\r\n", ct->name, control(*(ct->charp)));
    }
    slc_check();
    return 1;
}

static int
unsetcmd(int argc, char *argv[])
{
    struct setlist *ct;
    struct togglelist *c;
    char *name;

    if (argc < 2) {
	fprintf(stderr,
	    "Need an argument to 'unset' command.  'unset ?' for help.\r\n");
	return 0;
    }
    if (isprefix(argv[1], "?") || isprefix(argv[1], "help")) {
	for (ct = Setlist; ct->name; ct++)
	    printf("%-15s %s\r\n", ct->name, ct->help);
	printf("\r\n");
	settogglehelp(0);
	printf("%-15s %s\r\n", "?", "display help information");
	return 0;
    }

    argc--;
    argv++;
    while (argc--) {
	name = *argv++;
	ct = getset(name);
	if (ct == 0) {
	    c = GETTOGGLE(name);
	    if (c == 0) {
		fprintf(stderr, "'%s': unknown argument ('unset ?' for help).\r\n",
			name);
		return 0;
	    } else if (Ambiguous(c)) {
		fprintf(stderr, "'%s': ambiguous argument ('unset ?' for help).\r\n",
			name);
		return 0;
	    }
	    if (c->variable) {
		*c->variable = 0;
		if (c->actionexplanation) {
		    printf("%s %s.\r\n", *c->variable? "Will" : "Won't",
							c->actionexplanation);
		}
	    }
	    if (c->handler)
		(*c->handler)(0);
	} else if (Ambiguous(ct)) {
	    fprintf(stderr, "'%s': ambiguous argument ('unset ?' for help).\r\n",
			name);
	    return 0;
	} else if (ct->handler) {
	    (*ct->handler)(NULL);
	    printf("%s reset to \"%s\".\r\n", ct->name, (char *)ct->charp);
	} else {
	    *(ct->charp) = _POSIX_VDISABLE;
	    printf("%s character is '%s'.\r\n", ct->name, control(*(ct->charp)));
	}
    }
    return 1;
}

/*
 * The following are the data structures and routines for the
 * 'mode' command.
 */
#ifdef	KLUDGELINEMODE
static int
dokludgemode(int unused)
{
    kludgelinemode = 1;
    send_wont(TELOPT_LINEMODE, 1);
    send_dont(TELOPT_SGA, 1);
    send_dont(TELOPT_ECHO, 1);
    return 1;
}
#endif

static int
dolinemode(int unused)
{
#ifdef	KLUDGELINEMODE
    if (kludgelinemode)
	send_dont(TELOPT_SGA, 1);
#endif
    send_will(TELOPT_LINEMODE, 1);
    send_dont(TELOPT_ECHO, 1);
    return 1;
}

static int
docharmode(int unused)
{
#ifdef	KLUDGELINEMODE
    if (kludgelinemode)
	send_do(TELOPT_SGA, 1);
    else
#endif
    send_wont(TELOPT_LINEMODE, 1);
    send_do(TELOPT_ECHO, 1);
    return 1;
}

static int
dolmmode(int bit, int on)
{
    unsigned char c;

    if (my_want_state_is_wont(TELOPT_LINEMODE)) {
	printf("?Need to have LINEMODE option enabled first.\r\n");
	printf("'mode ?' for help.\r\n");
	return 0;
    }

    if (on)
	c = (linemode | bit);
    else
	c = (linemode & ~bit);
    lm_mode(&c, 1, 1);
    return 1;
}

int
tn_setmode(int bit)
{
    return dolmmode(bit, 1);
}

int
tn_clearmode(int bit)
{
    return dolmmode(bit, 0);
}

struct modelist {
	char	*name;		/* command name */
	char	*help;		/* help string */
	int	(*handler)(int);/* routine which executes command */
	int	needconnect;	/* Do we need to be connected to execute? */
	int	arg1;
};

static int modehelp(int);

static struct modelist ModeList[] = {
    { "character", "Disable LINEMODE option",	docharmode, 1 },
#ifdef	KLUDGELINEMODE
    { "",	"(or disable obsolete line-by-line mode)", 0 },
#endif
    { "line",	"Enable LINEMODE option",	dolinemode, 1 },
#ifdef	KLUDGELINEMODE
    { "",	"(or enable obsolete line-by-line mode)", 0 },
#endif
    { "", "", 0 },
    { "",	"These require the LINEMODE option to be enabled", 0 },
    { "isig",	"Enable signal trapping",	tn_setmode, 1, MODE_TRAPSIG },
    { "+isig",	0,				tn_setmode, 1, MODE_TRAPSIG },
    { "-isig",	"Disable signal trapping",	tn_clearmode, 1, MODE_TRAPSIG },
    { "edit",	"Enable character editing",	tn_setmode, 1, MODE_EDIT },
    { "+edit",	0,				tn_setmode, 1, MODE_EDIT },
    { "-edit",	"Disable character editing",	tn_clearmode, 1, MODE_EDIT },
    { "softtabs", "Enable tab expansion",	tn_setmode, 1, MODE_SOFT_TAB },
    { "+softtabs", 0,				tn_setmode, 1, MODE_SOFT_TAB },
    { "-softtabs", "Disable character editing",	tn_clearmode, 1, MODE_SOFT_TAB },
    { "litecho", "Enable literal character echo", tn_setmode, 1, MODE_LIT_ECHO },
    { "+litecho", 0,				tn_setmode, 1, MODE_LIT_ECHO },
    { "-litecho", "Disable literal character echo", tn_clearmode, 1, MODE_LIT_ECHO },
    { "help",	0,				modehelp, 0 },
#ifdef	KLUDGELINEMODE
    { "kludgeline", 0,				dokludgemode, 1 },
#endif
    { "", "", 0 },
    { "?",	"Print help information",	modehelp, 0 },
    { 0 },
};

static int
modehelp(int unused)
{
    struct modelist *mt;

    printf("format is:  'mode Mode', where 'Mode' is one of:\r\n\r\n");
    for (mt = ModeList; mt->name; mt++) {
	if (mt->help) {
	    if (*mt->help)
		printf("%-15s %s\r\n", mt->name, mt->help);
	    else
		printf("\r\n");
	}
    }
    return 0;
}

#define	GETMODECMD(name) (struct modelist *) \
		genget(name, (char **) ModeList, sizeof(struct modelist))

static int
modecmd(int argc, char *argv[])
{
    struct modelist *mt;

    if (argc != 2) {
	printf("'mode' command requires an argument\r\n");
	printf("'mode ?' for help.\r\n");
    } else if ((mt = GETMODECMD(argv[1])) == 0) {
	fprintf(stderr, "Unknown mode '%s' ('mode ?' for help).\r\n", argv[1]);
    } else if (Ambiguous(mt)) {
	fprintf(stderr, "Ambiguous mode '%s' ('mode ?' for help).\r\n", argv[1]);
    } else if (mt->needconnect && !connected) {
	printf("?Need to be connected first.\r\n");
	printf("'mode ?' for help.\r\n");
    } else if (mt->handler) {
	return (*mt->handler)(mt->arg1);
    }
    return 0;
}

/*
 * The following data structures and routines implement the
 * "display" command.
 */

static int
display(int argc, char *argv[])
{
    struct togglelist *tl;
    struct setlist *sl;

#define	dotog(tl)	if (tl->variable && tl->actionexplanation) { \
			    if (*tl->variable) { \
				printf("will"); \
			    } else { \
				printf("won't"); \
			    } \
			    printf(" %s.\r\n", tl->actionexplanation); \
			}

#define	doset(sl)   if (sl->name && *sl->name != ' ') { \
			if (sl->handler == 0) \
			    printf("%-15s [%s]\r\n", sl->name, control(*sl->charp)); \
			else \
			    printf("%-15s \"%s\"\r\n", sl->name, (char *)sl->charp); \
		    }

    if (argc == 1) {
	for (tl = Togglelist; tl->name; tl++) {
	    dotog(tl);
	}
	printf("\r\n");
	for (sl = Setlist; sl->name; sl++) {
	    doset(sl);
	}
    } else {
	int i;

	for (i = 1; i < argc; i++) {
	    sl = getset(argv[i]);
	    tl = GETTOGGLE(argv[i]);
	    if (Ambiguous(sl) || Ambiguous(tl)) {
		printf("?Ambiguous argument '%s'.\r\n", argv[i]);
		return 0;
	    } else if (!sl && !tl) {
		printf("?Unknown argument '%s'.\r\n", argv[i]);
		return 0;
	    } else {
		if (tl) {
		    dotog(tl);
		}
		if (sl) {
		    doset(sl);
		}
	    }
	}
    }
/*@@*/optionstatus();
    return 1;
#undef	doset
#undef	dotog
}

/*
 * The following are the data structures, and many of the routines,
 * relating to command processing.
 */

/*
 * Set the escape character.
 */
static int
setescape(int argc, char *argv[])
{
	char *arg;
	char buf[50];

	printf(
	    "Deprecated usage - please use 'set escape%s%s' in the future.\r\n",
				(argc > 2)? " ":"", (argc > 2)? argv[1]: "");
	if (argc > 2)
		arg = argv[1];
	else {
		printf("new escape character: ");
		(void) fgets(buf, sizeof(buf), stdin);
		arg = buf;
	}
	if (arg[0] != '\0')
		escape = arg[0];
	printf("Escape character is '%s'.\r\n", control(escape));
	(void) fflush(stdout);
	return 1;
}

static int
togcrmod(int unused1, char *unused2[])
{
    crmod = !crmod;
    printf("Deprecated usage - please use 'toggle crmod' in the future.\r\n");
    printf("%s map carriage return on output.\r\n", crmod ? "Will" : "Won't");
    (void) fflush(stdout);
    return 1;
}

int
telnetsuspend(int unused1, char *unused2[])
{
    setcommandmode();
    {
	long oldrows, oldcols, newrows, newcols, err;

	err = (TerminalWindowSize(&oldrows, &oldcols) == 0) ? 1 : 0;
	(void) kill(0, SIGTSTP);
	/*
	 * If we didn't get the window size before the SUSPEND, but we
	 * can get them now (?), then send the NAWS to make sure that
	 * we are set up for the right window size.
	 */
	if (TerminalWindowSize(&newrows, &newcols) && connected &&
	    (err || ((oldrows != newrows) || (oldcols != newcols)))) {
		sendnaws();
	}
    }
    /* reget parameters in case they were changed */
    TerminalSaveState();
    setconnmode(0);
    return 1;
}

static void
close_connection(void)
{
	if (connected) {
		(void) shutdown(net, SHUT_RDWR);
		printf("Connection closed.\r\n");
		(void)close(net);
		connected = 0;
		resettermname = 1;
		/* reset options */
		tninit();
	}
}

static int
bye(int argc, char *argv[])
{
	close_connection();
	longjmp(toplevel, 1);
}

void
quit(void)
{
	close_connection();
	Exit(0);
}

static int
quitcmd(int unused1, char *unused2[])
{
	quit();
}

static int
logout(int unused1, char *unused2[])
{
	send_do(TELOPT_LOGOUT, 1);
	(void) netflush();
	return 1;
}


/*
 * The SLC command.
 */

struct slclist {
	char	*name;
	char	*help;
	void	(*handler)(int);
	int	arg;
};

static void slc_help(int);

struct slclist SlcList[] = {
    { "export",	"Use local special character definitions",
						slc_mode_export,	0 },
    { "import",	"Use remote special character definitions",
						slc_mode_import,	1 },
    { "check",	"Verify remote special character definitions",
						slc_mode_import,	0 },
    { "help",	0,				slc_help,		0 },
    { "?",	"Print help information",	slc_help,		0 },
    { 0 },
};

static void
slc_help(int unused)
{
    struct slclist *c;

    for (c = SlcList; c->name; c++) {
	if (c->help) {
	    if (*c->help)
		printf("%-15s %s\r\n", c->name, c->help);
	    else
		printf("\r\n");
	}
    }
}

static struct slclist *
getslc(char *name)
{
    return (struct slclist *)
		genget(name, (char **) SlcList, sizeof(struct slclist));
}

static int
slccmd(int argc, char *argv[])
{
    struct slclist *c;

    if (argc != 2) {
	fprintf(stderr,
	    "Need an argument to 'slc' command.  'slc ?' for help.\r\n");
	return 0;
    }
    c = getslc(argv[1]);
    if (c == 0) {
	fprintf(stderr, "'%s': unknown argument ('slc ?' for help).\r\n",
    				argv[1]);
	return 0;
    }
    if (Ambiguous(c)) {
	fprintf(stderr, "'%s': ambiguous argument ('slc ?' for help).\r\n",
    				argv[1]);
	return 0;
    }
    (*c->handler)(c->arg);
    slcstate();
    return 1;
}

/*
 * The ENVIRON command.
 */

struct envlist {
	char	*name;
	char	*help;
	void	(*handler)();
	int	narg;
};

static void	env_help(void);
static void	env_undefine(const char *);
static void	env_export(const char *);
static void	env_unexport(const char *);
static void	env_send(const char *);
static void	env_list(void);
static struct env_lst *env_find(const char *var);

struct envlist EnvList[] = {
    { "define",	"Define an environment variable",
						(void (*)())env_define,	2 },
    { "undefine", "Undefine an environment variable",
						env_undefine,	1 },
    { "export",	"Mark an environment variable for automatic export",
						env_export,	1 },
    { "unexport", "Don't mark an environment variable for automatic export",
						env_unexport,	1 },
    { "send",	"Send an environment variable", env_send,	1 },
    { "list",	"List the current environment variables",
						env_list,	0 },
    { "help",	0,				env_help,		0 },
    { "?",	"Print help information",	env_help,		0 },
    { 0 },
};

static void
env_help(void)
{
    struct envlist *c;

    for (c = EnvList; c->name; c++) {
	if (c->help) {
	    if (*c->help)
		printf("%-15s %s\r\n", c->name, c->help);
	    else
		printf("\r\n");
	}
    }
}

static struct envlist *
getenvcmd(char *name)
{
    return (struct envlist *)
		genget(name, (char **) EnvList, sizeof(struct envlist));
}

static int
env_cmd(int argc, char *argv[])
{
    struct envlist *c;

    if (argc < 2) {
	fprintf(stderr,
	    "Need an argument to 'environ' command.  'environ ?' for help.\r\n");
	return 0;
    }
    c = getenvcmd(argv[1]);
    if (c == 0) {
	fprintf(stderr, "'%s': unknown argument ('environ ?' for help).\r\n",
    				argv[1]);
	return 0;
    }
    if (Ambiguous(c)) {
	fprintf(stderr, "'%s': ambiguous argument ('environ ?' for help).\r\n",
    				argv[1]);
	return 0;
    }
    if (c->narg + 2 != argc) {
	fprintf(stderr,
	    "Need %s%d argument%s to 'environ %s' command.  'environ ?' for help.\r\n",
		c->narg < argc + 2 ? "only " : "",
		c->narg, c->narg == 1 ? "" : "s", c->name);
	return 0;
    }
    (*c->handler)(argv[2], argv[3]);
    return 1;
}

struct env_lst {
	struct env_lst *next;	/* pointer to next structure */
	struct env_lst *prev;	/* pointer to previous structure */
	char *var;		/* pointer to variable name */
	char *value;		/* pointer to variable value */
	int export;		/* 1 -> export with default list of variables */
	int welldefined;	/* A well defined variable */
};

struct env_lst envlisthead;

static struct env_lst *
env_find(const char *var)
{
	struct env_lst *ep;

	for (ep = envlisthead.next; ep; ep = ep->next) {
		if (strcmp(ep->var, var) == 0)
			return(ep);
	}
	return(NULL);
}

void
env_init(void)
{
	extern char **environ;
	char **epp, *cp;
	struct env_lst *ep;

	for (epp = environ; *epp; epp++) {
		if ((cp = strchr(*epp, '='))) {
			*cp = '\0';
			ep = env_define(*epp, cp+1);
			ep->export = 0;
			*cp = '=';
		}
	}
	/*
	 * Special case for DISPLAY variable.  If it is ":0.0" or
	 * "unix:0.0", we have to get rid of "unix" and insert our
	 * hostname.
	 */
	if ((ep = env_find("DISPLAY"))
	    && ((*ep->value == ':')
		|| (strncmp(ep->value, "unix:", 5) == 0))) {
		char hbuf[HOST_NAME_MAX+1];
		char *cp2 = strchr(ep->value, ':');

		gethostname(hbuf, sizeof hbuf);

		if (asprintf (&cp, "%s%s", hbuf, cp2) == -1)
			err(1, "asprintf");

		free(ep->value);
		ep->value = cp;
	}
	/*
	 * If USER is not defined, but LOGNAME is, then add
	 * USER with the value from LOGNAME.  By default, we
	 * don't export the USER variable.
	 */
	if ((env_find("USER") == NULL) && (ep = env_find("LOGNAME"))) {
		env_define("USER", ep->value);
		env_unexport("USER");
	}
	env_export("DISPLAY");
	env_export("PRINTER");
	env_export("XAUTHORITY");
}

struct env_lst *
env_define(const char *var, const char *value)
{
	struct env_lst *ep;

	if ((ep = env_find(var))) {
		free(ep->var);
		free(ep->value);
	} else {
		if ((ep = malloc(sizeof(struct env_lst))) == NULL)
			err(1, "malloc");
		ep->next = envlisthead.next;
		envlisthead.next = ep;
		ep->prev = &envlisthead;
		if (ep->next)
			ep->next->prev = ep;
	}
	ep->welldefined = opt_welldefined(var);
	ep->export = 1;
	if ((ep->var = strdup(var)) == NULL)
		err(1, "strdup");
	if ((ep->value = strdup(value)) == NULL)
		err(1, "strdup");
	return(ep);
}

static void
env_undefine(const char *var)
{
	struct env_lst *ep;

	if ((ep = env_find(var))) {
		ep->prev->next = ep->next;
		if (ep->next)
			ep->next->prev = ep->prev;
		free(ep->var);
		free(ep->value);
		free(ep);
	}
}

static void
env_export(const char *var)
{
	struct env_lst *ep;

	if ((ep = env_find(var)))
		ep->export = 1;
}

static void
env_unexport(const char *var)
{
	struct env_lst *ep;

	if ((ep = env_find(var)) != NULL)
		ep->export = 0;
}

static void
env_send(const char *var)
{
	struct env_lst *ep;

	if (my_state_is_wont(TELOPT_NEW_ENVIRON)
		) {
		fprintf(stderr,
		    "Cannot send '%s': Telnet ENVIRON option not enabled\r\n",
									var);
		return;
	}
	ep = env_find(var);
	if (ep == 0) {
		fprintf(stderr, "Cannot send '%s': variable not defined\r\n",
									var);
		return;
	}
	env_opt_start_info();
	env_opt_add(ep->var);
	env_opt_end(0);
}

static void
env_list(void)
{
	struct env_lst *ep;

	for (ep = envlisthead.next; ep; ep = ep->next) {
		printf("%c %-20s %s\r\n", ep->export ? '*' : ' ',
					ep->var, ep->value);
	}
}

char *
env_default(int init, int welldefined)
{
	static struct env_lst *nep = NULL;

	if (init) {
		nep = &envlisthead;
		return NULL;
	}
	if (nep) {
		while ((nep = nep->next)) {
			if (nep->export && (nep->welldefined == welldefined))
				return(nep->var);
		}
	}
	return(NULL);
}

char *
env_getvalue(const char *var, int exported_only)
{
	struct env_lst *ep;

	if ((ep = env_find(var)) && (!exported_only || ep->export))
		return(ep->value);
	return(NULL);
}

static void
connection_status(int local_only)
{
	if (!connected)
		printf("No connection.\r\n");
	else {
		printf("Connected to %s.\r\n", hostname);
		if (!local_only) {
			int mode = getconnmode();

			printf("Operating ");
			if (my_want_state_is_will(TELOPT_LINEMODE)) {
				printf("with LINEMODE option\r\n"
				    "%s line editing\r\n"
				    "%s catching of signals\r\n",
				    (mode & MODE_EDIT) ? "Local" : "No",
				    (mode & MODE_TRAPSIG) ? "Local" : "No");
				slcstate();
#ifdef	KLUDGELINEMODE
			} else if (kludgelinemode &&
			    my_want_state_is_dont(TELOPT_SGA)) {
				printf("in obsolete linemode\r\n");
#endif
			} else {
				printf("in single character mode\r\n");
				if (localchars)
					printf("Catching signals locally\r\n");
			}

			printf("%s character echo\r\n",
			    (mode & MODE_ECHO) ? "Local" : "Remote");
			if (my_want_state_is_will(TELOPT_LFLOW))
				printf("%s flow control\r\n",
				    (mode & MODE_FLOW) ? "Local" : "No");
		}
	}
	printf("Escape character is '%s'.\r\n", control(escape));
	(void) fflush(stdout);
}

/*
 * Print status about the connection.
 */
static int
status(int argc, char *argv[])
{
	connection_status(0);
	return 1;
}

/*
 * Function that gets called when SIGINFO is received.
 */
void
ayt_status(int sig)
{
	connection_status(1);
}

static Command *getcmd(char *name);

static void
cmdrc(char *m1, char *m2)
{
    static char rcname[128];
    Command *c;
    FILE *rcfile;
    int gotmachine = 0;
    int l1 = strlen(m1);
    int l2 = strlen(m2);
    char m1save[HOST_NAME_MAX+1];

    if (skiprc)
	return;

    strlcpy(m1save, m1, sizeof(m1save));
    m1 = m1save;

    if (rcname[0] == 0) {
	char *home = getenv("HOME");

	if (home == NULL || *home == '\0')
	    return;
	snprintf (rcname, sizeof(rcname), "%s/.telnetrc",
		  home ? home : "");
    }

    if ((rcfile = fopen(rcname, "r")) == 0) {
	return;
    }

    for (;;) {
	if (fgets(line, sizeof(line), rcfile) == NULL)
	    break;
	if (line[0] == 0)
	    break;
	if (line[0] == '#')
	    continue;
	if (gotmachine) {
	    if (!isspace((unsigned char)line[0]))
		gotmachine = 0;
	}
	if (gotmachine == 0) {
	    if (isspace((unsigned char)line[0]))
		continue;
	    if (strncasecmp(line, m1, l1) == 0)
		strncpy(line, &line[l1], sizeof(line) - l1);
	    else if (strncasecmp(line, m2, l2) == 0)
		strncpy(line, &line[l2], sizeof(line) - l2);
	    else if (strncasecmp(line, "DEFAULT", 7) == 0)
		strncpy(line, &line[7], sizeof(line) - 7);
	    else
		continue;
	    if (line[0] != ' ' && line[0] != '\t' && line[0] != '\n')
		continue;
	    gotmachine = 1;
	}
	makeargv();
	if (margv[0] == 0)
	    continue;
	c = getcmd(margv[0]);
	if (Ambiguous(c)) {
	    printf("?Ambiguous command: %s\r\n", margv[0]);
	    continue;
	}
	if (c == 0) {
	    printf("?Invalid command: %s\r\n", margv[0]);
	    continue;
	}
	/*
	 * This should never happen...
	 */
	if (c->needconnect && !connected) {
	    printf("?Need to be connected first for %s.\r\n", margv[0]);
	    continue;
	}
	(*c->handler)(margc, margv);
    }
    fclose(rcfile);
}

int
tn(int argc, char *argv[])
{
    struct addrinfo hints, *res, *res0;
    char *cmd, *hostp = 0, *portp = 0, *user = 0, *aliasp = 0;
    int error, retry;
    const int niflags = NI_NUMERICHOST, tos = IPTOS_LOWDELAY;

    if (connected) {
	printf("?Already connected to %s\r\n", hostname);
	return 0;
    }
    if (connections) {
	printf("Repeated connections not supported\r\n");
	return 0;
    }
    if (argc < 2) {
	strlcpy(line, "open ", sizeof(line));
	printf("(to) ");
	(void) fgets(&line[strlen(line)], sizeof(line) - strlen(line), stdin);
	makeargv();
	argc = margc;
	argv = margv;
    }
    cmd = *argv;
    --argc; ++argv;
    while (argc) {
	if (strcmp(*argv, "help") == 0 || isprefix(*argv, "?"))
	    goto usage;
	if (strcmp(*argv, "-l") == 0) {
	    --argc; ++argv;
	    if (argc == 0)
		goto usage;
	    if ((user = strdup(*argv++)) == NULL)
		err(1, "strdup");
	    --argc;
	    continue;
	}
	if (strcmp(*argv, "-b") == 0) {
	    --argc; ++argv;
	    if (argc == 0)
		goto usage;
	    aliasp = *argv++;
	    --argc;
	    continue;
	}
	if (strcmp(*argv, "-a") == 0) {
	    --argc; ++argv;
	    autologin = 1;
	    continue;
	}
	if (hostp == 0) {
	    hostp = *argv++;
	    --argc;
	    continue;
	}
	if (portp == 0) {
	    portp = *argv++;
	    --argc;
	    continue;
	}
    usage:
	printf("usage: %s [-a] [-b hostalias] [-l user] host-name [port]\r\n", cmd);
	return 0;
    }
    if (hostp == 0)
	goto usage;

    hostname = hostp;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = family;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_CANONNAME;
    if (portp == NULL) {
        portp = "telnet";
        telnetport = 1;
    } else if (*portp == '-') {
        portp++;
        telnetport = 1;
    } else
        telnetport = 0;
    error = getaddrinfo(hostp, portp, &hints, &res0);
    if (error) {
        if (error == EAI_SERVICE)
            warnx("%s: bad port", portp);
        else
            warnx("%s: %s", hostp, gai_strerror(error));
        return 0;
    }

    net = -1;
    retry = 0;
    for (res = res0; res; res = res->ai_next) {
	if (1 /* retry */) {
	    char hbuf[NI_MAXHOST];

	    if (getnameinfo(res->ai_addr, res->ai_addrlen, hbuf, sizeof(hbuf),
		    NULL, 0, niflags) != 0) {
		strlcpy(hbuf, "(invalid)", sizeof(hbuf));
	    }
	    printf("Trying %s...\r\n", hbuf);
	}
	net = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
	if (net < 0)
	    continue;

	if (aliasp) {
	    struct addrinfo ahints, *ares;

	    memset(&ahints, 0, sizeof(ahints));
	    ahints.ai_family = family;
	    ahints.ai_socktype = SOCK_STREAM;
	    ahints.ai_flags = AI_PASSIVE;
	    error = getaddrinfo(aliasp, "0", &ahints, &ares);
	    if (error) {
		warn("%s: %s", aliasp, gai_strerror(error));
		close(net);
		net = -1;
		continue;
	    }
	    if (bind(net, ares->ai_addr, ares->ai_addrlen) < 0) {
		perror(aliasp);
		(void) close(net);   /* dump descriptor */
		net = -1;
		freeaddrinfo(ares);
		continue;
            }
	    freeaddrinfo(ares);
	}

	switch (res->ai_family) {
	case AF_INET:
		if (setsockopt(net, IPPROTO_IP, IP_TOS, &tos, sizeof(tos)) < 0
		    && errno != ENOPROTOOPT)
			perror("telnet: setsockopt (IP_TOS) (ignored)");
		break;
	case AF_INET6:
		if (setsockopt(net, IPPROTO_IPV6, IPV6_TCLASS, &tos,
		    sizeof(tos)) < 0 && errno != ENOPROTOOPT)
			perror("telnet: setsockopt (IPV6_TCLASS) (ignored)");
		break;
	}

	if (connect(net, res->ai_addr, res->ai_addrlen) < 0) {
	    char hbuf[NI_MAXHOST];

	    if (getnameinfo(res->ai_addr, res->ai_addrlen, hbuf, sizeof(hbuf),
		    NULL, 0, niflags) != 0) {
		strlcpy(hbuf, "(invalid)", sizeof(hbuf));
	    }
	    fprintf(stderr, "telnet: connect to address %s: %s\n", hbuf,
		strerror(errno));

	    close(net);
	    net = -1;
	    retry++;
	    continue;
	}

	connected++;
	break;
    }
    freeaddrinfo(res0);
    if (net < 0) {
	return 0;
    }
    cmdrc(hostp, hostname);
    if (autologin && user == NULL) {
	struct passwd *pw;

	user = getlogin();
	if (user == NULL ||
	    (pw = getpwnam(user)) == NULL || pw->pw_uid != getuid()) {
		if ((pw = getpwuid(getuid())) != NULL)
			user = pw->pw_name;
		else
			user = NULL;
	}
    }
    if (user) {
	env_define("USER", user);
	env_export("USER");
    }
    connection_status(1);
    if (setjmp(peerdied) == 0)
	telnet(user);
    (void)close(net);
    ExitString("Connection closed by foreign host.\r\n",1);
}

#define HELPINDENT (sizeof ("connect"))

static char
	openhelp[] =	"connect to a site",
	closehelp[] =	"close current connection",
	logouthelp[] =	"forcibly logout remote user and close the connection",
	quithelp[] =	"exit telnet",
	statushelp[] =	"print status information",
	helphelp[] =	"print help information",
	sendhelp[] =	"transmit special characters ('send ?' for more)",
	sethelp[] = 	"set operating parameters ('set ?' for more)",
	unsethelp[] = 	"unset operating parameters ('unset ?' for more)",
	togglestring[] ="toggle operating parameters ('toggle ?' for more)",
	slchelp[] =	"change state of special charaters ('slc ?' for more)",
	displayhelp[] =	"display operating parameters",
	zhelp[] =	"suspend telnet",
	envhelp[] =	"change environment variables ('environ ?' for more)",
	modestring[] = "try to enter line or character mode ('mode ?' for more)";

static int	help(int, char**);

static Command cmdtab[] = {
	{ "close",	closehelp,	bye,		1 },
	{ "logout",	logouthelp,	logout,		1 },
	{ "display",	displayhelp,	display,	0 },
	{ "mode",	modestring,	modecmd,	0 },
	{ "open",	openhelp,	tn,		0 },
	{ "quit",	quithelp,	quitcmd,	0 },
	{ "send",	sendhelp,	sendcmd,	0 },
	{ "set",	sethelp,	setcmd,		0 },
	{ "unset",	unsethelp,	unsetcmd,	0 },
	{ "status",	statushelp,	status,		0 },
	{ "toggle",	togglestring,	toggle,		0 },
	{ "slc",	slchelp,	slccmd,		0 },

	{ "z",		zhelp,		telnetsuspend,	0 },
	{ "environ",	envhelp,	env_cmd,	0 },
	{ "?",		helphelp,	help,		0 },
	{ 0,		0,		0,		0 }
};

static char	crmodhelp[] =	"deprecated command -- use 'toggle crmod' instead";
static char	escapehelp[] =	"deprecated command -- use 'set escape' instead";

static Command cmdtab2[] = {
	{ "help",	0,		help,		0 },
	{ "escape",	escapehelp,	setescape,	0 },
	{ "crmod",	crmodhelp,	togcrmod,	0 },
	{ 0,		0,		0,		0 }
};


static Command *
getcmd(char *name)
{
    Command *cm;

    if ((cm = (Command *) genget(name, (char **) cmdtab, sizeof(Command))))
	return cm;
    return (Command *) genget(name, (char **) cmdtab2, sizeof(Command));
}

void
command(int top, char *tbuf, int cnt)
{
    Command *c;

    setcommandmode();
    if (!top) {
	putchar('\n');
    } else {
	(void) signal(SIGINT, SIG_DFL);
	(void) signal(SIGQUIT, SIG_DFL);
    }
    for (;;) {
	if (rlogin == _POSIX_VDISABLE)
		printf("%s> ", prompt);
	if (tbuf) {
	    char *cp;
	    cp = line;
	    while (cnt > 0 && (*cp++ = *tbuf++) != '\n')
		cnt--;
	    tbuf = 0;
	    if (cp == line || *--cp != '\n' || cp == line)
		goto getline;
	    *cp = '\0';
	    if (rlogin == _POSIX_VDISABLE)
		printf("%s\r\n", line);
	} else {
	getline:
	    if (rlogin != _POSIX_VDISABLE)
		printf("%s> ", prompt);
	    if (fgets(line, sizeof(line), stdin) == NULL) {
		if (feof(stdin) || ferror(stdin))
		    quit();
		break;
	    }
	}
	if (line[0] == 0)
	    break;
	makeargv();
	if (margv[0] == 0) {
	    break;
	}
	c = getcmd(margv[0]);
	if (Ambiguous(c)) {
	    printf("?Ambiguous command\r\n");
	    continue;
	}
	if (c == 0) {
	    printf("?Invalid command\r\n");
	    continue;
	}
	if (c->needconnect && !connected) {
	    printf("?Need to be connected first.\r\n");
	    continue;
	}
	if ((*c->handler)(margc, margv)) {
	    break;
	}
    }
    if (!top) {
	if (!connected)
	    longjmp(toplevel, 1);
	setconnmode(0);
    }
}

/*
 * Help command.
 */
static int
help(int argc, char *argv[])
{
	Command *c;

	if (argc == 1) {
		printf("Commands may be abbreviated.  Commands are:\r\n\r\n");
		for (c = cmdtab; c->name; c++)
			if (c->help) {
				printf("%-*s\t%s\r\n", (int)HELPINDENT, c->name,
								    c->help);
			}
		return 0;
	}
	while (--argc > 0) {
		char *arg;
		arg = *++argv;
		c = getcmd(arg);
		if (Ambiguous(c))
			printf("?Ambiguous help command %s\r\n", arg);
		else if (c == NULL)
			printf("?Invalid help command %s\r\n", arg);
		else
			printf("%s\r\n", c->help);
	}
	return 0;
}
@


1.84
log
@telnet should not verify if hostname is a fully qualified domain

telnet would perform a gethostbyname on close/quit commands
when the machine hostname is not a fully qualified domain.
This behavior added on 12-March-98 breaks the current pledge
that "dns" operations are not needed after establishing
a connection leading to a coredump from telnet when
quiting or closing an existing connection.

OK chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.83 2016/03/16 15:41:11 krw Exp $	*/
a1638 1
#ifdef	SIGINFO
a1646 1
#endif
@


1.83
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.82 2015/12/09 19:39:10 mmcc Exp $	*/
a1446 8

		/* If this is not the full name, try to get it via DNS */
		if (strchr(hbuf, '.') == 0) {
			struct hostent *he = gethostbyname(hbuf);
			if (he != 0)
				strncpy(hbuf, he->h_name, sizeof hbuf-1);
			hbuf[sizeof hbuf-1] = '\0';
		}
@


1.82
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.81 2015/11/24 05:06:24 beck Exp $	*/
d2081 1
a2081 1
		else if (c == (Command *)0)
@


1.81
log
@Don't support repeated connections - avoids pledge problems
ok deraadt@@, "god please commit before I see any more" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.80 2015/11/20 12:43:37 jca Exp $	*/
d1482 2
a1483 4
		if (ep->var)
			free(ep->var);
		if (ep->value)
			free(ep->value);
d1511 2
a1512 4
		if (ep->var)
			free(ep->var);
		if (ep->value)
			free(ep->value);
@


1.80
log
@Replace hardcoded "2" with SHUT_RDWR; from Ricardo Mestre
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.79 2015/11/13 17:04:48 deraadt Exp $	*/
d1754 4
@


1.79
log
@Use setrtable() for the entire process, rather than doing it for the
socket later.  Same idea as in nc(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.78 2015/11/13 17:01:12 deraadt Exp $	*/
d1195 1
a1195 1
		(void) shutdown(net, 2);
@


1.78
log
@Remove support for the debug command; noone needs setsockopt SO_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.77 2015/11/13 16:53:46 deraadt Exp $	*/
a1844 4

	if (rtableid >= 0 && (setsockopt(net, SOL_SOCKET, SO_RTABLE, &rtableid,
	    sizeof(rtableid)) == -1))
		perror("setsockopt (SO_RTABLE)");
@


1.77
log
@Delete tracefile command.  Tracefiles can now only be specified at
program startup.  Who uses that?  Noone...
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.76 2015/11/13 16:50:03 deraadt Exp $	*/
a431 10
togdebug(int unused)
{
    if (net > 0 &&
	(setsockopt(net, SOL_SOCKET, SO_DEBUG, &debug, sizeof(debug))) == -1) {
	    perror("setsockopt (SO_DEBUG)");
    }
    return 1;
}

static int
a597 5
    { "debug",
	"debugging",
	    togdebug,
		&debug,
		    "turn on socket level debugging" },
a1884 8
	}

	if (debug) {
		int one = 1;

		if (setsockopt(net, SOL_SOCKET, SO_DEBUG, &one,
		    sizeof(one)) < 0)
			perror("setsockopt (SO_DEBUG)");
@


1.76
log
@remove support for !shell
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.75 2015/11/13 16:46:30 deraadt Exp $	*/
a742 1
    { "tracefile", "file to write trace information to", SetNetTrace, (cc_t *)NetTraceFile},
@


1.75
log
@remove skey support
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.74 2015/10/26 00:33:03 jca Exp $	*/
a35 1
#include <sys/wait.h>
a61 1
static char saveline[256];
a72 6
    if (*cp == '!') {		/* Special case shell escape */
	strlcpy(saveline, line, sizeof(saveline)); /* save for shell command */
	*argp++ = "!";		/* No room in string to get this */
	margc++;
	cp++;
    }
a1206 46
int
shell(int argc, char *argv[])
{
    long oldrows, oldcols, newrows, newcols, err;

    setcommandmode();

    err = (TerminalWindowSize(&oldrows, &oldcols) == 0) ? 1 : 0;
    switch(vfork()) {
    case -1:
	perror("Fork failed\r\n");
	break;

    case 0:
	{
	    /*
	     * Fire up the shell in the child.
	     */
	    char *shellp, *shellname;

	    shellp = getenv("SHELL");
	    if (shellp == NULL)
		shellp = "/bin/sh";
	    if ((shellname = strrchr(shellp, '/')) == 0)
		shellname = shellp;
	    else
		shellname++;
	    if (argc > 1)
		execl(shellp, shellname, "-c", &saveline[1], (char *)NULL);
	    else
		execl(shellp, shellname, (char *)NULL);
	    perror("Execl");
	    _exit(1);
	}
    default:
	    (void)wait((int *)0);	/* Wait for the shell to complete */

	    if (TerminalWindowSize(&newrows, &newcols) && connected &&
		(err || ((oldrows != newrows) || (oldcols != newcols)))) {
		    sendnaws();
	    }
	    break;
    }
    return 1;
}

a1973 1
	shellhelp[] =	"invoke a subshell",
a1993 1
	{ "!",		shellhelp,	shell,		0 },
@


1.74
log
@Set low-delay traffic class for IPv6 connections as well

While here, there is no option to pass a different tos, and no other
use of the "tos" variable out of tn(), so move the "tos" variable in tn()
and assign it the right value from the start.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.73 2015/10/25 14:42:02 jca Exp $	*/
d36 1
a52 5
#ifdef SKEY
#include <sys/wait.h>
#define PATH_SKEY	"/usr/bin/skey"
#endif

a66 27
#ifdef SKEY
int
skey_calc(int argc, char **argv)
{
	int status;

	if(argc != 3) {
		printf("usage: %s sequence challenge\n", argv[0]);
		return 0;
	}

	switch(fork()) {
	case 0:
		execv(PATH_SKEY, argv);
		exit (1);
	case -1:
		err(1, "fork");
		break;
	default:
		(void) wait(&status);
		if (WIFEXITED(status))
			return (WEXITSTATUS(status));
		return (0);
	}
}
#endif

a2027 3
#ifdef SKEY
	skeyhelp[] =	"compute response to s/key challenge",
#endif
a2051 3
#ifdef SKEY
	{ "skey",	skeyhelp,	skey_calc,	0 },
#endif		
@


1.73
log
@Kill unused local var, and reorder while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.72 2015/10/25 14:11:37 jca Exp $	*/
a56 2
int tos = -1;

d1851 1
a1851 1
    const int niflags = NI_NUMERICHOST;
d1974 12
a1985 7
	if (res->ai_family == AF_INET) {
	    if (tos < 0)
		tos = IPTOS_LOWDELAY;	/* Low Delay bit */
	    if (tos
		&& (setsockopt(net, IPPROTO_IP, IP_TOS, &tos, sizeof(int)) < 0)
		&& (errno != ENOPROTOOPT))
		    perror("telnet: setsockopt (IP_TOS) (ignored)");
@


1.72
log
@Kill IP Source Route support, unusable since 1998.

ok sthen@@ guenther@@ mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.71 2015/01/16 06:40:13 deraadt Exp $	*/
a1850 2
    int error;
    struct sockaddr_in sin;
d1852 1
a1852 1
    int retry;
a1853 3

    /* clear the socket address prior to use */
    memset(&sin, 0, sizeof(sin));
@


1.71
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.70 2014/09/09 03:41:08 guenther Exp $	*/
a56 2
static unsigned long sourceroute(char *arg, char **cpp, int *lenp);

a1852 3
    unsigned long temp;
    char *srp = 0;
    int srlen;
d1916 11
a1926 15
    if (hostp[0] == '@@' || hostp[0] == '!') {
	if ((hostname = strrchr(hostp, ':')) == NULL)
	    hostname = strrchr(hostp, '@@');
	hostname++;
	srp = 0;
	temp = sourceroute(hostp, &srp, &srlen);
	if (temp == 0) {
	    herror(srp);
	    return 0;
	} else if (temp == -1) {
	    printf("Bad source route option: %s\r\n", hostp);
	    return 0;
	} else {
	    abort();
	}
d1928 8
a1935 25
    {
	hostname = hostp;
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = family;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_CANONNAME;
	if (portp == NULL) {
	    portp = "telnet";
	    telnetport = 1;
	} else if (*portp == '-') {
	    portp++;
	    telnetport = 1;
	} else
	    telnetport = 0;
	h_errno = 0;
	error = getaddrinfo(hostp, portp, &hints, &res0);
	if (error) {
	    if (error == EAI_SERVICE)
		warnx("%s: bad port", portp);
	    else
		warnx("%s: %s", hostp, gai_strerror(error));
	    if (h_errno)
		herror(hostp);
	    return 0;
	}
a1980 3
	if (srp && res->ai_family == AF_INET
	 && setsockopt(net, IPPROTO_IP, IP_OPTIONS, srp, srlen) < 0)
		perror("setsockopt (IP_OPTIONS)");
a2209 140
}

/*
 * Source route is handed in as
 *	[!]@@hop1@@hop2...[@@|:]dst
 * If the leading ! is present, it is a
 * strict source route, otherwise it is
 * assmed to be a loose source route.
 *
 * We fill in the source route option as
 *	hop1,hop2,hop3...dest
 * and return a pointer to hop1, which will
 * be the address to connect() to.
 *
 * Arguments:
 *	arg:	pointer to route list to decipher
 *
 *	cpp: 	If *cpp is not equal to NULL, this is a
 *		pointer to a pointer to a character array
 *		that should be filled in with the option.
 *
 *	lenp:	pointer to an integer that contains the
 *		length of *cpp if *cpp != NULL.
 *
 * Return values:
 *
 *	Returns the address of the host to connect to.  If the
 *	return value is -1, there was a syntax error in the
 *	option, either unknown characters, or too many hosts.
 *	If the return value is 0, one of the hostnames in the
 *	path is unknown, and *cpp is set to point to the bad
 *	hostname.
 *
 *	*cpp:	If *cpp was equal to NULL, it will be filled
 *		in with a pointer to our static area that has
 *		the option filled in.  This will be 32bit aligned.
 *
 *	*lenp:	This will be filled in with how long the option
 *		pointed to by *cpp is.
 *
 */

static unsigned long
sourceroute(char *arg, char **cpp, int *lenp)
{
	static char lsr[44];
	char *cp, *cp2, *lsrp, *lsrep;
	struct in_addr addr;
	struct hostent *host = 0;
	char c;

	/*
	 * Verify the arguments, and make sure we have
	 * at least 7 bytes for the option.
	 */
	if (cpp == NULL || lenp == NULL)
		return((unsigned long)-1);
	if (*cpp != NULL && *lenp < 7)
		return((unsigned long)-1);
	/*
	 * Decide whether we have a buffer passed to us,
	 * or if we need to use our own static buffer.
	 */
	if (*cpp) {
		lsrp = *cpp;
		lsrep = lsrp + *lenp;
	} else {
		*cpp = lsrp = lsr;
		lsrep = lsrp + 44;
	}

	cp = arg;

	/*
	 * Next, decide whether we have a loose source
	 * route or a strict source route, and fill in
	 * the begining of the option.
	 */
	if (*cp == '!') {
		cp++;
		*lsrp++ = IPOPT_SSRR;
	} else
		*lsrp++ = IPOPT_LSRR;

	if (*cp != '@@')
		return((unsigned long)-1);

	lsrp++;		/* skip over length, we'll fill it in later */
	*lsrp++ = 4;

	cp++;

	addr.s_addr = 0;

	for (c = 0;;) {
		if (c == ':')
			cp2 = 0;
		else for (cp2 = cp; (c = *cp2); cp2++) {
			if (c == ',') {
				*cp2++ = '\0';
				if (*cp2 == '@@')
					cp2++;
			} else if (c == '@@') {
				*cp2++ = '\0';
			} else if (c == ':') {
				*cp2++ = '\0';
			} else
				continue;
			break;
		}
		if (!c)
			cp2 = 0;

		if ((addr.s_addr = inet_addr(cp)) == INADDR_NONE) {
			if ((host = gethostbyname(cp)) == NULL) {
				*cpp = cp;
				return(0);
			}
			memcpy(&addr, host->h_addr_list[0], sizeof addr);
		}
		memcpy(lsrp, &addr, 4);
		lsrp += 4;
		if (cp2)
			cp = cp2;
		else
			break;
		/*
		 * Check to make sure there is space for next address
		 */
		if (lsrp + 4 > lsrep)
			return((unsigned long)-1);
	}
	if ((*(*cpp+IPOPT_OLEN) = lsrp - *cpp) <= 7) {
		*cpp = 0;
		*lenp = 0;
		return((unsigned long)-1);
	}
	*lsrp++ = IPOPT_NOP; /* 32 bit word align it */
	*lenp = lsrp - *cpp;
	return(addr.s_addr);
@


1.70
log
@Eliminate a pile of casts that were superfluous or wrong, or that were
the result of bad type choices, particularly (unsigned char *) vs
(const char *).  Also, use reallocarray().
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.69 2014/07/22 07:30:24 jsg Exp $	*/
d50 1
d1548 1
a1548 1
		char hbuf[MAXHOSTNAMELEN];
d1778 1
a1778 1
    char m1save[MAXHOSTNAMELEN];
@


1.69
log
@use ansi style function declarations
with suggestions from and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.68 2014/07/20 12:08:55 guenther Exp $	*/
d775 1
a775 1
    void (*handler)(char *);
d1423 4
a1426 4
static void	env_undefine(unsigned char *);
static void	env_export(unsigned char *);
static void	env_unexport(unsigned char *);
static void	env_send(unsigned char *);
d1428 1
a1428 1
static struct env_lst *env_find(unsigned char *var);
d1504 2
a1505 2
	unsigned char *var;	/* pointer to variable name */
	unsigned char *value;	/* pointer to variable value */
d1513 1
a1513 1
env_find(unsigned char *var)
d1518 1
a1518 1
		if (strcmp((char *)ep->var, (char *)var) == 0)
d1534 1
a1534 2
			ep = env_define((unsigned char *)*epp,
					(unsigned char *)cp+1);
d1546 1
a1546 1
		|| (strncmp((char *)ep->value, "unix:", 5) == 0))) {
d1548 1
a1548 1
		char *cp2 = strchr((char *)ep->value, ':');
d1564 1
a1564 1
		ep->value = (unsigned char *)cp;
d1572 2
a1573 2
		env_define((unsigned char *)"USER", ep->value);
		env_unexport((unsigned char *)"USER");
d1575 3
a1577 3
	env_export((unsigned char *)"DISPLAY");
	env_export((unsigned char *)"PRINTER");
	env_export((unsigned char *)"XAUTHORITY");
d1581 1
a1581 1
env_define(unsigned char *var, unsigned char *value)
d1599 1
a1599 1
	ep->welldefined = opt_welldefined((char *)var);
d1601 1
a1601 1
	if ((ep->var = strdup((char *)var)) == NULL)
d1603 1
a1603 1
	if ((ep->value = strdup((char *)value)) == NULL)
d1609 1
a1609 1
env_undefine(unsigned char *var)
d1626 1
a1626 1
env_export(unsigned char *var)
d1635 1
a1635 1
env_unexport(unsigned char *var)
d1644 1
a1644 1
env_send(unsigned char *var)
d1677 1
a1677 1
unsigned char *
d1695 2
a1696 2
unsigned char *
env_getvalue(unsigned char *var, int exported_only)
d1862 1
a1862 1
    memset((char *)&sin, 0, sizeof(sin));
d2063 2
a2064 2
	env_define((unsigned char *)"USER", (unsigned char *)user);
	env_export((unsigned char *)"USER");
@


1.68
log
@Eliminate silly call() routine that fakes up internal calls as if
the user typed in undocumented arguments by splitting two functions
and doing normal (shock!) C calls.

Move extern declarations to externs.h
Eliminate another function cast
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.67 2014/07/20 10:55:26 guenther Exp $	*/
d75 2
a76 4
    int
skey_calc(argc, argv)
	int argc;
	char **argv;
a99 1
   	
d101 2
a102 3

    static void
makeargv()
d158 2
a159 3
	static char
special(s)
	char *s;
d184 2
a185 3
	static char *
control(c)
	cc_t c;
a218 2


d276 2
a277 4
    static int
sendcmd(argc, argv)
    int  argc;
    char **argv;
d356 1
a356 2
	static int
send_tncmd(void (*func)(), char *cmd, char *name);
d358 2
a359 2
    static int
send_esc()
d365 2
a366 3
    static int
send_docmd(name)
    char *name;
d371 2
a372 3
    static int
send_dontcmd(name)
    char *name;
d376 3
a378 3
    static int
send_willcmd(name)
    char *name;
d382 3
a384 3
    static int
send_wontcmd(name)
    char *name;
d389 2
a390 4
    int
send_tncmd(func, cmd, name)
    void	(*func)();
    char	*cmd, *name;
d450 2
a451 2
    static int
send_help()
d466 2
a467 2
    static int
lclchars()
d473 2
a474 2
    static int
togdebug()
d483 2
a484 3

    static int
togcrlf()
d496 2
a497 3
    static int
togbinary(val)
    int val;
d534 2
a535 3
    static int
togrbinary(val)
    int val;
d560 2
a561 3
    static int
togxbinary(val)
    int val;
d684 1
a684 1
    static int
d702 2
a703 3
    static void
settogglehelp(set)
    int set;
d721 2
a722 4
    static int
toggle(argc, argv)
    int  argc;
    char *argv[];
d808 2
a809 3
    static struct setlist *
getset(name)
    char *name;
d815 2
a816 3
    void
set_escape_char(s)
    char *s;
d828 2
a829 4
    static int
setcmd(argc, argv)
    int  argc;
    char *argv[];
d904 2
a905 4
    static int
unsetcmd(argc, argv)
    int  argc;
    char *argv[];
d970 2
a971 2
    static int
dokludgemode()
d981 2
a982 2
    static int
dolinemode()
d993 2
a994 2
    static int
docharmode()
d1006 2
a1007 3
    static int
dolmmode(bit, on)
    int bit, on;
d1025 2
a1026 2
    int
tn_setmode(bit)
d1031 2
a1032 2
    int
tn_clearmode(bit)
d1079 1
a1079 2

    static int
d1099 2
a1100 4
    static int
modecmd(argc, argv)
    int  argc;
    char *argv[];
d1125 2
a1126 4
    static int
display(argc, argv)
    int  argc;
    char *argv[];
d1191 2
a1192 4
	static int
setescape(argc, argv)
	int argc;
	char *argv[];
d1214 2
a1215 2
    static int
togcrmod()
d1224 2
a1225 2
    int
telnetsuspend()
d1249 2
a1250 4
    int
shell(argc, argv)
    int argc;
    char *argv[];
d1310 1
a1310 3
bye(argc, argv)
    int  argc;		/* Number of arguments */
    char *argv[];	/* arguments */
d1329 2
a1330 2
	static int
logout()
d1363 1
a1363 1
    static void
d1378 2
a1379 3
    static struct slclist *
getslc(name)
    char *name;
d1385 2
a1386 4
    static int
slccmd(argc, argv)
    int  argc;
    char *argv[];
d1448 1
a1448 1
env_help()
d1463 1
a1463 2
getenvcmd(name)
    char *name;
d1470 1
a1470 3
env_cmd(argc, argv)
    int  argc;
    char *argv[];
d1513 1
a1513 2
env_find(var)
	unsigned char *var;
d1524 2
a1525 2
	void
env_init()
d1581 2
a1582 3
	struct env_lst *
env_define(var, value)
	unsigned char *var, *value;
d1610 1
a1610 2
env_undefine(var)
	unsigned char *var;
d1627 1
a1627 2
env_export(var)
	unsigned char *var;
d1636 1
a1636 2
env_unexport(var)
	unsigned char *var;
d1645 1
a1645 2
env_send(var)
	unsigned char *var;
d1668 1
a1668 1
env_list()
d1678 2
a1679 3
	unsigned char *
env_default(init, welldefined)
	int init;
d1696 2
a1697 4
	unsigned char *
env_getvalue(var, exported_only)
	unsigned char *var;
	int exported_only;
d1849 2
a1850 5

    int
tn(argc, argv)
    int argc;
    char *argv[];
d2134 2
a2135 3
    static Command *
getcmd(name)
    char *name;
d2144 2
a2145 5
    void
command(top, tbuf, cnt)
    int top;
    char *tbuf;
    int cnt;
d2213 2
a2214 4
	static int
help(argc, argv)
	int argc;
	char *argv[];
d2282 1
a2282 4
sourceroute(arg, cpp, lenp)
	char	*arg;
	char	**cpp;
	int	*lenp;
@


1.67
log
@Mark a slurry of functions as static
Eliminate two more trivial wrappers
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.66 2014/07/20 10:18:10 guenther Exp $	*/
d51 7
a61 4
typedef int (*intrtn_t)(int, char**);
static int call(intrtn_t, ...);
static unsigned long sourceroute(char *arg, char **cpp, int *lenp);

d74 1
a74 3
#if	defined(SKEY)
#include <sys/wait.h>
#define PATH_SKEY	"/usr/bin/skey"
a997 2
extern int kludgelinemode;

a1038 1
    extern int linemode;
d1333 15
a1347 1
    static int
d1352 1
a1352 12
    extern int resettermname;

    if (connected) {
	(void) shutdown(net, 2);
	printf("Connection closed.\r\n");
	(void)close(net);
	connected = 0;
	resettermname = 1;
	/* reset options */
	tninit();
    }
    if ((argc != 2) || (strcmp(argv[1], "fromquit") != 0))
a1353 1
    return 0;
d1359 1
a1359 1
	(void) call(bye, "bye", "fromquit", 0);
d1761 40
d1804 2
a1805 4
    static int
status(argc, argv)
    int	 argc;
    char *argv[];
d1807 2
a1808 31
    if (connected) {
	printf("Connected to %s.\r\n", hostname);
	if ((argc < 2) || strcmp(argv[1], "notmuch")) {
	    int mode = getconnmode();

	    if (my_want_state_is_will(TELOPT_LINEMODE)) {
		printf("Operating with LINEMODE option\r\n");
		printf("%s line editing\r\n", (mode&MODE_EDIT) ? "Local" : "No");
		printf("%s catching of signals\r\n",
					(mode&MODE_TRAPSIG) ? "Local" : "No");
		slcstate();
#ifdef	KLUDGELINEMODE
	    } else if (kludgelinemode && my_want_state_is_dont(TELOPT_SGA)) {
		printf("Operating in obsolete linemode\r\n");
#endif
	    } else {
		printf("Operating in single character mode\r\n");
		if (localchars)
		    printf("Catching signals locally\r\n");
	    }
	    printf("%s character echo\r\n", (mode&MODE_ECHO) ? "Local" : "Remote");
	    if (my_want_state_is_will(TELOPT_LFLOW))
		printf("%s flow control\r\n", (mode&MODE_FLOW) ? "Local" : "No");
	}
    } else {
	printf("No connection.\r\n");
    }
    printf("Escape character is '%s'.\r\n", control(escape));
    (void) fflush(stdout);
    fflush(stdout);
    return 1;
d1816 1
a1816 1
ayt_status()
d1818 1
a1818 1
    (void) call(status, "status", "notmuch", 0);
d2125 1
a2125 1
    (void) call(status, "status", "notmuch", 0);
d2175 1
a2175 1
#if	defined(SKEY)
a2189 19


/*
 * Call routine with argc, argv set from args (terminated by 0).
 */

    /*VARARGS1*/
    static int
call(intrtn_t routine, ...)
{
    va_list ap;
    char *args[100];
    int argno = 0;

    va_start(ap, routine);
    while ((args[argno++] = va_arg(ap, char *)) != 0);
    va_end(ap);
    return (*routine)(argno-1, args);
}
@


1.66
log
@Kill lint comments; mark ExitString() as __dead
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.65 2014/07/20 09:59:42 guenther Exp $	*/
d57 1
d1345 1
a1345 1
	(void) NetClose(net);
d1466 6
d1490 1
a1490 1
    static void
d1505 1
a1505 1
    static struct envlist *
d1513 1
a1513 1
    int
d1558 1
a1558 1
	struct env_lst *
d1657 1
a1657 1
	void
d1675 1
a1675 1
	void
d1685 1
a1685 1
	void
d1695 1
a1695 1
	void
d1719 1
a1719 1
	void
d2119 1
a2119 1
    (void) NetClose(net);
d2354 2
a2355 1
	unsigned long
@


1.65
log
@Switch from memmove() to memcpy() where appropriate; simplify address
parsing logic; eliminate an inefficient use of MIN() macro
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.64 2014/07/20 09:31:25 guenther Exp $	*/
a349 1
	    /*NOTREACHED*/
a1250 1
    /*VARARGS*/
a1260 1
    /*VARARGS*/
a1285 1
    /*ARGSUSED*/
a1333 1
    /*VARARGS*/
d1350 1
a1350 1
    if ((argc != 2) || (strcmp(argv[1], "fromquit") != 0)) {
d1352 1
a1352 3
	/* NOTREACHED */
    }
    return 0; /* NOTREACHED */
a1367 1
/*VARARGS*/
a1756 1
    /*ARGSUSED*/
a2113 2
    /*NOTREACHED*/
    return 0;
d2240 1
a2240 1
		if (feof(stdin) || ferror(stdin)) {
a2241 2
		    /*NOTREACHED*/
		}
d2269 1
a2269 1
	if (!connected) {
a2270 2
	    /*NOTREACHED*/
	}
@


1.64
log
@VSUSP and SIGTSTP are required by POSIX
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.63 2014/07/20 08:56:47 guenther Exp $	*/
d2370 1
a2370 1
	struct in_addr sin_addr;
d2415 1
a2415 1
	sin_addr.s_addr = 0;
d2436 6
a2441 8
		if ((sin_addr.s_addr = inet_addr(cp)) != INADDR_NONE) {
		} else if ((host = gethostbyname(cp))) {
			memmove((caddr_t)&sin_addr,
				host->h_addr_list[0], 
				sizeof(sin_addr));
		} else {
			*cpp = cp;
			return(0);
d2443 1
a2443 1
		memmove(lsrp, (char *)&sin_addr, 4);
d2462 1
a2462 1
	return(sin_addr.s_addr);
@


1.63
log
@Add prototypes to some function callbacks and fix the type errors that
this reveals.
Make NetTrace static to utilities.c
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.62 2014/07/20 08:12:45 guenther Exp $	*/
a1266 1
#ifdef	SIGTSTP
a1285 3
#else
    printf("Suspend is not supported.  Try the '!' command instead\r\n");
#endif
@


1.62
log
@More encryption tentacles: intr_happened and intr_waiting vanish
Push more includes into .c files
Make ring.c only need ring.h
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.61 2014/07/20 07:35:04 guenther Exp $	*/
d61 1
a61 1
	int	(*handler)();	/* routine which executes command */
d349 1
a349 1
	    (void) quit();
d605 1
a605 1
static int togglehelp(void);
d608 3
a610 3
    char	*name;		/* name of toggle */
    char	*help;		/* help message */
    int		(*handler)();	/* routine to do actual setting */
d703 1
a703 1
togglehelp()
d796 1
a796 1
    void (*handler)();
d982 1
a982 1
	    (*ct->handler)(0);
d1071 1
a1071 1
	int	(*handler)();	/* routine which executes command */
d1076 1
a1076 1
static int modehelp(void);
d1112 1
a1112 1
modehelp()
d1366 1
a1366 1
int
d1373 6
d1396 1
a1396 1
	void	(*handler)();
d1400 1
a1400 1
static void slc_help();
d1415 1
a1415 1
slc_help()
d2162 1
a2162 1
	{ "quit",	quithelp,	quit,		0 },
d2256 1
a2256 1
		    (void) quit();
@


1.61
log
@Eliminate trivial wrappers TerminalWrite() and TerminalRead()
Replace TerminalFlushOutput() with tcflush().
Replace TerminalAutoFlush() with check of tty's NOFLSH flag as
	documented in the manpage.
Push <netdb.h> into .c files
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.60 2014/07/20 06:39:41 guenther Exp $	*/
d35 1
d39 1
d43 1
d47 2
@


1.60
log
@Correctly cast to unsigned char for ctype functions/macros
Push <ctype.h> and <unistd.h> into the .c files
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.59 2014/07/20 05:22:02 guenther Exp $	*/
d41 1
@


1.59
log
@Simplify #includes, start pushing them into the .c files, eliminate
extern declarations from .c files that duplicate those in .h files,
start marking functions with __dead
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.58 2014/07/20 04:07:16 guenther Exp $	*/
d39 1
d43 1
d113 1
a113 1
	while (isspace(c))
d135 1
a135 1
		} else if (isspace(c))
d1847 1
a1847 1
	    if (!isspace(line[0]))
d1851 1
a1851 1
	    if (isspace(line[0]))
@


1.58
log
@The manpage claims the -a option uses getlogin(2), so do so.  Also,
ignore its value if it returns a user that doesn't exit
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.57 2014/07/20 04:00:47 guenther Exp $	*/
d34 5
d40 2
d1358 2
a1359 3
/*VARARGS*/
	int
quit()
a1362 1
	return 0; /*NOTREACHED*/
a1896 1
    extern char *inet_ntoa();
a2359 1
	int tmp;
d2426 1
a2426 2
		if ((tmp = inet_addr(cp)) != -1) {
			sin_addr.s_addr = tmp;
@


1.57
log
@The only authentication info now is the login name
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.56 2014/07/19 23:50:38 guenther Exp $	*/
d2091 1
a2091 1
	user = getenv("USER");
d2093 1
a2093 1
	    ((pw = getpwnam(user)) && pw->pw_uid != getuid())) {
@


1.56
log
@Flense the telnet code base of unwanted ifdefs: authentication/encryption
tn3270, sgtty, pre-POSIX and other ancient system support, etc.  Brings up
to date the manpage with what we support.

ok matthieu@@ beck@@ jmc@@ millert@@ deraadt@@ okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.55 2013/10/26 21:33:29 sthen Exp $	*/
d613 1
a613 1
	"automatic sending of login and/or authentication info",
d616 1
a616 1
		    "send login name and/or authentication information" },
@


1.55
log
@Only use setsockopt(..SO_RTABLE..) if the -V flag is given to nc/telnet,
same style as traceroute6 (change to int and use -1 as a flag, so rtable 0
can still be used as an explicit parameter).
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.54 2013/10/21 09:02:37 phessler Exp $	*/
a35 1
#if	defined(IPPROTO_IP) && defined(IP_TOS)
a36 1
#endif	/* defined(IPPROTO_IP) && defined(IP_TOS) */
a474 1
#ifndef	NOT43
d476 1
a476 1
	(SetSockOpt(net, SOL_SOCKET, SO_DEBUG, debug)) < 0) {
a478 7
#else	/* NOT43 */
    if (debug) {
	if (net > 0 && SetSockOpt(net, SOL_SOCKET, SO_DEBUG, 0, 0) < 0)
	    perror("setsockopt (SO_DEBUG)");
    } else
	printf("Cannot turn off socket debugging\r\n");
#endif	/* NOT43 */
a590 10
#if	defined(AUTHENTICATION)
extern int auth_togdebug(int);
#endif
#if    defined(ENCRYPTION)
extern int EncryptAutoEnc(int);
extern int EncryptAutoDec(int);
extern int EncryptDebug(int);
extern int EncryptVerbose(int);
#endif

a611 1
#if	defined(AUTHENTICATION)
a616 28
    { "authdebug",
	"Toggle authentication debugging",
	    auth_togdebug,
		0,
		     "print authentication debugging information" },
#endif
#if    defined(ENCRYPTION)
    { "autoencrypt",
       "automatic encryption of data stream",
           EncryptAutoEnc,
               0,
                   "automatically encrypt output" },
    { "autodecrypt",
       "automatic decryption of data stream",
           EncryptAutoDec,
               0,
                   "automatically decrypt input" },
    { "verbose_encrypt",
       "Toggle verbose encryption output",
           EncryptVerbose,
               0,
                   "print verbose encryption output" },
    { "encdebug",
       "Toggle encryption debugging",
           EncryptDebug,
               0,
                   "print encryption debugging information" },
#endif
a652 12
#if	defined(unix) && defined(TN3270)
    { "apitrace",
	"(debugging) toggle tracing of API transactions",
	    0,
		&apitrace,
		    "trace API transactions", 0 },
    { "cursesdata",
	"(debugging) toggle printing of hexadecimal curses data",
	    0,
		&cursesdata,
		    "print hexadecimal representation of curses data", 0 },
#endif	/* defined(unix) && defined(TN3270) */
a672 1
#if	defined(unix)
a677 1
#endif	/* defined(unix) */
a775 1
#ifdef	USE_TERMIO
a776 1
#endif
a1198 3
#if    defined(ENCRYPTION)
    EncryptStatus();
#endif
d1232 1
a1232 3
	if (!In3270) {
		printf("Escape character is '%s'.\r\n", control(escape));
	}
a1277 1
#if	!defined(TN3270)
a1325 3
#else	/* !defined(TN3270) */
extern int shell();
#endif	/* !defined(TN3270) */
a1340 3
#if	defined(AUTHENTICATION) || defined(ENCRYPTION)
	auth_encrypt_connect(connected);
#endif	/* defined(AUTHENTICATION) */
a1342 3
#if	defined(TN3270)
	SetIn3270();		/* Get out of 3270 mode */
#endif	/* defined(TN3270) */
a1470 4
#if defined(OLD_ENVIRON) && defined(ENV_HACK)
    { "varval", "Reverse VAR and VALUE (auto, right, wrong, status)",
						env_varval,    1 },
#endif
a1687 3
#ifdef	OLD_ENVIRON
	    && my_state_is_wont(TELOPT_OLD_ENVIRON)
#endif
a1746 259
#if defined(OLD_ENVIRON) && defined(ENV_HACK)
	void
env_varval(what)
	unsigned char *what;
{
	extern int old_env_var, old_env_value, env_auto;
	int len = strlen((char *)what);

	if (len == 0)
		goto unknown;

	if (strncasecmp((char *)what, "status", len) == 0) {
		if (env_auto)
			printf("%s%s", "VAR and VALUE are/will be ",
					"determined automatically\r\n");
		if (old_env_var == OLD_ENV_VAR)
			printf("VAR and VALUE set to correct definitions\r\n");
		else
			printf("VAR and VALUE definitions are reversed\r\n");
	} else if (strncasecmp((char *)what, "auto", len) == 0) {
		env_auto = 1;
		old_env_var = OLD_ENV_VALUE;
		old_env_value = OLD_ENV_VAR;
	} else if (strncasecmp((char *)what, "right", len) == 0) {
		env_auto = 0;
		old_env_var = OLD_ENV_VAR;
		old_env_value = OLD_ENV_VALUE;
	} else if (strncasecmp((char *)what, "wrong", len) == 0) {
		env_auto = 0;
		old_env_var = OLD_ENV_VALUE;
		old_env_value = OLD_ENV_VAR;
	} else {
unknown:
		printf("Unknown \"varval\" command. (\"auto\", \"right\", \"wrong\", \"status\")\r\n");
	}
}
#endif

#if	defined(AUTHENTICATION)
/*
 * The AUTHENTICATE command.
 */

struct authlist {
	char	*name;
	char	*help;
	int	(*handler)();
	int	narg;
};

static int
	auth_help(void);

struct authlist AuthList[] = {
    { "status",	"Display current status of authentication information",
						auth_status,	0 },
    { "disable", "Disable an authentication type ('auth disable ?' for more)",
						auth_disable,	1 },
    { "enable", "Enable an authentication type ('auth enable ?' for more)",
						auth_enable,	1 },
    { "help",	0,				auth_help,		0 },
    { "?",	"Print help information",	auth_help,		0 },
    { 0 },
};

    static int
auth_help()
{
    struct authlist *c;

    for (c = AuthList; c->name; c++) {
	if (c->help) {
	    if (*c->help)
		printf("%-15s %s\r\n", c->name, c->help);
	    else
		printf("\r\n");
	}
    }
    return 0;
}

    int
auth_cmd(argc, argv)
    int  argc;
    char *argv[];
{
    struct authlist *c;

    if (argc < 2) {
	fprintf(stderr,
	    "Need an argument to 'auth' command.  'auth ?' for help.\r\n");
	return 0;
    }

    c = (struct authlist *)
		genget(argv[1], (char **) AuthList, sizeof(struct authlist));
    if (c == 0) {
	fprintf(stderr, "'%s': unknown argument ('auth ?' for help).\r\n",
    				argv[1]);
	return 0;
    }
    if (Ambiguous(c)) {
	fprintf(stderr, "'%s': ambiguous argument ('auth ?' for help).\r\n",
    				argv[1]);
	return 0;
    }
    if (c->narg + 2 != argc) {
	fprintf(stderr,
	    "Need %s%d argument%s to 'auth %s' command.  'auth ?' for help.\r\n",
		c->narg < argc + 2 ? "only " : "",
		c->narg, c->narg == 1 ? "" : "s", c->name);
	return 0;
    }
    return((*c->handler)(argv[2], argv[3]));
}
#endif

#if    defined(ENCRYPTION)
/*
 * The ENCRYPT command.
 */

struct encryptlist {
       char    *name;
       char    *help;
       int     (*handler)();
       int     needconnect;
       int     minarg;
       int     maxarg;
};
 
static int
       EncryptHelp (void);

struct encryptlist EncryptList[] = {
    { "enable", "Enable encryption. ('encrypt enable ?' for more)",
                                               EncryptEnable, 1, 1, 2 },
    { "disable", "Disable encryption. ('encrypt enable ?' for more)",
                                               EncryptDisable, 0, 1, 2 },
    { "type", "Set encryption type. ('encrypt type ?' for more)",
                                               EncryptType, 0, 1, 1 },
    { "start", "Start encryption. ('encrypt start ?' for more)",
                                               EncryptStart, 1, 0, 1 },
    { "stop", "Stop encryption. ('encrypt stop ?' for more)",
                                               EncryptStop, 1, 0, 1 },
    { "input", "Start encrypting the input stream",
                                               EncryptStartInput, 1, 0, 0 },
    { "-input", "Stop encrypting the input stream",
                                               EncryptStopInput, 1, 0, 0 },
    { "output", "Start encrypting the output stream",
                                               EncryptStartOutput, 1, 0, 0 },
    { "-output", "Stop encrypting the output stream",
                                               EncryptStopOutput, 1, 0, 0 },

    { "status",        "Display current status of authentication information",
                                               EncryptStatus,  0, 0, 0 },
    { "help",  0,                              EncryptHelp,    0, 0, 0 },
    { "?",     "Print help information",       EncryptHelp,    0, 0, 0 },
    { 0 },
};

static int
EncryptHelp()
{
    struct encryptlist *c;

    for (c = EncryptList; c->name; c++) {
       if (c->help) {
           if (*c->help)
               printf("%-15s %s\r\n", c->name, c->help);
           else
               printf("\r\n");
       }
    }
    return 0;
}

static int
encrypt_cmd(int argc, char **argv)
{
    struct encryptlist *c;

    if (argc < 2) {
	fprintf(stderr, "Need at least one argument for 'encrypt' command.\n");
	fprintf(stderr, "('encrypt ?' for help)\n");
	return 0;
    }

    c = (struct encryptlist *)
               genget(argv[1], (char **) EncryptList, sizeof(struct encryptlist));
    if (c == 0) {
        fprintf(stderr, "'%s': unknown argument ('encrypt ?' for help).\r\n",
                               argv[1]);
        return 0;
    }
    if (Ambiguous(c)) {
        fprintf(stderr, "'%s': ambiguous argument ('encrypt ?' for help).\r\n",
                               argv[1]);
        return 0;
    }
    argc -= 2;
    if (argc < c->minarg || argc > c->maxarg) {
       if (c->minarg == c->maxarg) {
           fprintf(stderr, "Need %s%d argument%s ",
               c->minarg < argc ? "only " : "", c->minarg,
               c->minarg == 1 ? "" : "s");
       } else {
           fprintf(stderr, "Need %s%d-%d arguments ",
               c->maxarg < argc ? "only " : "", c->minarg, c->maxarg);
       }
       fprintf(stderr, "to 'encrypt %s' command.  'encrypt ?' for help.\r\n",
               c->name);
       return 0;
    }
    if (c->needconnect && !connected) {
       if (!(argc && (isprefix(argv[2], "help") || isprefix(argv[2], "?")))) {
           printf("?Need to be connected first.\r\n");
           return 0;
       }
    }
    return ((*c->handler)(argc > 0 ? argv[2] : 0,
                       argc > 1 ? argv[3] : 0,
                       argc > 2 ? argv[4] : 0));
}
#endif

#if	defined(unix) && defined(TN3270)
    static void
filestuff(fd)
    int fd;
{
    int res;

#ifdef	F_GETOWN
    setconnmode(0);
    res = fcntl(fd, F_GETOWN, 0);
    setcommandmode();

    if (res == -1) {
	perror("fcntl");
	return;
    }
    printf("\tOwner is %d.\r\n", res);
#endif

    setconnmode(0);
    res = fcntl(fd, F_GETFL, 0);
    setcommandmode();

    if (res == -1) {
	perror("fcntl");
	return;
    }
#ifdef notdef
    printf("\tFlags are 0x%x: %s\r\n", res, decodeflags(res));
#endif
}
#endif /* defined(unix) && defined(TN3270) */

a1778 3
#if    defined(ENCRYPTION)
           encrypt_display();
#endif
a1782 1
#   if !defined(TN3270)
a1784 28
#   else /* !defined(TN3270) */
    if ((!In3270) && ((argc < 2) || strcmp(argv[1], "notmuch"))) {
	printf("Escape character is '%s'.\r\n", control(escape));
    }
#   if defined(unix)
    if ((argc >= 2) && !strcmp(argv[1], "everything")) {
	printf("SIGIO received %d time%s.\r\n",
				sigiocount, (sigiocount == 1)? "":"s");
	if (In3270) {
	    printf("Process ID %ld, process group %ld.\r\n",
					    (long)getpid(), (long)getpgrp());
	    printf("Terminal input:\r\n");
	    filestuff(tin);
	    printf("Terminal output:\r\n");
	    filestuff(tout);
	    printf("Network socket:\r\n");
	    filestuff(net);
	}
    }
    if (In3270 && transcom) {
       printf("Transparent mode command is '%s'.\r\n", transcom);
    }
#   endif /* defined(unix) */
    (void) fflush(stdout);
    if (In3270) {
	return 0;
    }
#   endif /* defined(TN3270) */
a1892 1
#if	defined(IP_OPTIONS) && defined(IPPROTO_IP)
a1894 1
#endif
d1952 1
a1952 1
	printf("usage: %s [-l user] [-a] host-name [port]\r\n", cmd);
a1957 1
#if	defined(IP_OPTIONS) && defined(IPPROTO_IP)
a1973 1
#endif
a2043 1
#if	defined(IP_OPTIONS) && defined(IPPROTO_IP)
d2045 1
a2045 1
	 && setsockopt(net, IPPROTO_IP, IP_OPTIONS, (char *)srp, srlen) < 0)
a2046 2
#endif
#if	defined(IPPROTO_IP) && defined(IP_TOS)
a2047 5
# if	defined(HAS_GETTOS)
	    struct tosent *tp;
	    if (tos < 0 && (tp = gettosbyname("telnet", "tcp")))
		tos = tp->t_tos;
# endif
d2051 1
a2051 2
		&& (setsockopt(net, IPPROTO_IP, IP_TOS,
		    (void *)&tos, sizeof(int)) < 0)
a2054 1
#endif	/* defined(IPPROTO_IP) && defined(IP_TOS) */
d2056 6
a2061 2
	if (debug && SetSockOpt(net, SOL_SOCKET, SO_DEBUG, 1) < 0) {
		perror("setsockopt (SO_DEBUG)");
a2080 3
#if	defined(AUTHENTICATION) || defined(ENCRYPTION)
	auth_encrypt_connect(connected);
#endif	/* defined(AUTHENTICATION) */
a2127 9
#if	defined(TN3270) && defined(unix)
	transcomhelp[] = "specify Unix command for transparent mode pipe",
#endif	/* defined(TN3270) && defined(unix) */
#if	defined(AUTHENTICATION)
	authhelp[] =	"turn on (off) authentication ('auth ?' for more)",
#endif
#if     defined(ENCRYPTION)
        encrypthelp[] = "turn on (off) encryption ('encrypt ?' for more)",
#endif
a2150 9
#if	defined(TN3270) && defined(unix)
	{ "transcom",	transcomhelp,	settranscom,	0 },
#endif	/* defined(TN3270) && defined(unix) */
#if	defined(AUTHENTICATION)
	{ "auth",	authhelp,	auth_cmd,	0 },
#endif
#if    defined(ENCRYPTION)
	{ "encrypt",    encrypthelp,    encrypt_cmd,    0 },
#endif
a2152 3
#if	defined(TN3270)
	{ "!",		shellhelp,	shell,		1 },
#else
a2153 1
#endif
a2213 1
#if	defined(unix)
a2216 1
#endif	/* defined(unix) */
a2271 5
#if	defined(TN3270)
	if (shell_active == 0) {
	    setconnmode(0);
	}
#else	/* defined(TN3270) */
a2272 1
#endif	/* defined(TN3270) */
a2308 2
#if	defined(IP_OPTIONS) && defined(IPPROTO_IP)

a2354 3
#ifdef	sysV88
	static IOPTN ipopt;
#endif
a2387 1
#ifndef	sysV88
a2392 7
#else
	if (*cp == '!') {
		cp++;
		ipopt.io_type = IPOPT_SSRR;
	} else
		ipopt.io_type = IPOPT_LSRR;
#endif
a2396 1
#ifndef	sysV88
a2398 1
#endif
a2425 1
#if	defined(h_addr)
a2428 4
#else
			memmove((caddr_t)&sin_addr, host->h_addr, 
				sizeof(sin_addr));
#endif
a2444 1
#ifndef	sysV88
a2451 10
#else
	ipopt.io_len = lsrp - *cpp;
	if (ipopt.io_len <= 5) {		/* Is 3 better ? */
		*cpp = 0;
		*lenp = 0;
		return((unsigned long)-1);
	}
	*lenp = sizeof(ipopt);
	*cpp = (char *) &ipopt;
#endif
a2453 1
#endif
@


1.54
log
@Allow a user to switch to rdomain zero
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.53 2011/06/21 17:31:07 mikeb Exp $	*/
d2399 2
a2400 2
	if (setsockopt(net, SOL_SOCKET, SO_RTABLE, &rtableid,
	    sizeof(rtableid)) == -1)
@


1.53
log
@Convert SO_RTABLE's protocol level to the SOL_SOCKET;  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.52 2010/07/03 04:44:51 guenther Exp $	*/
d2399 3
a2401 5
	if (rtableid) {
		if (setsockopt(net, SOL_SOCKET, SO_RTABLE, &rtableid,
		    sizeof(rtableid)) == -1)
			perror("setsockopt (SO_RTABLE)");
	}
@


1.52
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.51 2009/06/05 00:20:46 claudio Exp $	*/
d2400 1
a2400 1
		if (setsockopt(net, IPPROTO_IP, SO_RTABLE, &rtableid,
@


1.51
log
@Last but not least. Telnet -V rdomain to connect to systems in other routing
domains.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.50 2009/04/27 06:08:10 matthieu Exp $	*/
d2399 4
a2402 4
	if (rdomain) {
		if (setsockopt(net, IPPROTO_IP, SO_RDOMAIN, &rdomain,
		    sizeof(rdomain)) == -1)
			perror("setsockopt (SO_RDOMAIN)");
@


1.50
log
@Remove unused _hostname[] variable. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.49 2006/01/14 21:21:46 otto Exp $	*/
d2398 6
@


1.49
log
@Properly handle failure binding to a local interface (using the -b
option).  Problem found by David Hill <dhill at mindcry dot org>;
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.48 2005/02/27 15:46:42 otto Exp $	*/
a40 1
static char _hostname[MAXHOSTNAMELEN];
@


1.48
log
@- only send exported vars (based on a diff from Solar Designer)
- fix some buffer overflows (also some Solar Designer input)

ok deraadt@@ cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.47 2004/11/17 01:47:20 itojun Exp $	*/
d2411 1
d2417 1
@


1.47
log
@remove NI_WITHSCOPEID (which is not standard)
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.46 2003/12/28 21:53:01 otto Exp $	*/
d1824 1
a1824 1
env_getvalue(var)
d1826 1
d1830 1
a1830 1
	if ((ep = env_find(var)))
@


1.46
log
@Introduce -4 and -6: options to force usage of IPv4 or IPv6 only.
From PR 1974.

ok henning@@ jose@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.45 2003/06/03 02:56:18 millert Exp $	*/
a2276 3
#ifdef NI_WITHSCOPEID
    const int niflags = NI_NUMERICHOST | NI_WITHSCOPEID;
#else
a2277 1
#endif
@


1.46.2.1
log
@MFC:
Fix by otto@@

- only send exported vars (based on a diff from Solar Designer)
- fix some buffer overflows (also some Solar Designer input)
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.46 2003/12/28 21:53:01 otto Exp $	*/
d1824 1
a1824 1
env_getvalue(var, exported_only)
a1825 1
	int exported_only;
d1829 1
a1829 1
	if ((ep = env_find(var)) && (!exported_only || ep->export))
@


1.46.4.1
log
@MFC:
Fix by otto@@

- only send exported vars (based on a diff from Solar Designer)
- fix some buffer overflows (also some Solar Designer input)
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.46 2003/12/28 21:53:01 otto Exp $	*/
d1824 1
a1824 1
env_getvalue(var, exported_only)
a1825 1
	int exported_only;
d1829 1
a1829 1
	if ((ep = env_find(var)) && (!exported_only || ep->export))
@


1.45
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.44 2003/04/25 20:07:09 pvalchev Exp $	*/
d2363 1
a2363 1
	hints.ai_family = PF_UNSPEC;
d2407 1
a2407 1
	    ahints.ai_family = PF_UNSPEC;
@


1.44
log
@check asprintf return value for error, as the pointer is not guaranteed
to be NULL in such case; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.43 2003/04/03 12:05:58 hin Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.43
log
@strcpy -> strlcpy
strcat -> strlcat

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.42 2002/06/12 06:07:16 mpech Exp $	*/
d1683 1
a1683 2
		asprintf (&cp, "%s%s", hbuf, cp2);
		if (cp == NULL)
@


1.42
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.41 2002/02/17 17:20:49 millert Exp $	*/
d104 1
a104 1
	strcpy(saveline, line);	/* save for shell command */
d2296 1
a2296 1
	(void) strcpy(line, "open ");
d2400 1
a2400 1
		strcpy(hbuf, "(invalid)");
d2460 1
a2460 1
		strcpy(hbuf, "(invalid)");
@


1.41
log
@telnet used a P macro instead of __P -- g/c that too.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.40 2002/02/16 21:27:54 millert Exp $	*/
d2149 2
a2150 2
	    printf("Process ID %d, process group %d.\r\n",
					    getpid(), getpgrp());
@


1.40
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.39 2001/11/19 19:02:16 mpech Exp $	*/
d235 6
a240 6
	send_esc P((void)),
	send_help P((void)),
	send_docmd P((char *)),
	send_dontcmd P((char *)),
	send_willcmd P((char *)),
	send_wontcmd P((char *));
d605 1
a605 1
static int togglehelp P((void));
d607 1
a607 1
extern int auth_togdebug P((int));
d610 4
a613 4
extern int EncryptAutoEnc P((int));
extern int EncryptAutoDec P((int));
extern int EncryptDebug P((int));
extern int EncryptVerbose P((int));
d1542 1
a1542 1
static void	env_help P((void));
d1890 1
a1890 1
	auth_help P((void));
@


1.39
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.38 2001/09/03 05:28:51 itojun Exp $	*/
d48 1
a48 1
static int call __P((intrtn_t, ...));
d1131 1
a1131 1
static int modehelp __P((void));
d2539 1
a2539 1
static int	help __P((int, char**));
@


1.38
log
@repair a bug in 1.23, where "telnetport" was incorrectly set.
From: Pekka Savola <pekkas@@netcore.fi>
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.37 2001/07/12 05:17:22 deraadt Exp $	*/
d98 2
a99 2
    register char *cp, *cp2, c;
    register char **argp = margv;
d110 1
a110 1
	register int inquote = 0;
d154 1
a154 1
	register char *s;
d156 1
a156 1
	register char c;
d181 1
a181 1
	register cc_t c;
d191 1
a191 1
	register unsigned int uic = (unsigned int)c;
d400 1
a400 1
    register int val = 0;
d403 1
a403 1
	register int col, len;
d431 1
a431 1
	register char *cp = name;
d991 1
a991 1
    register char *name;
d1290 1
a1290 1
	register char *arg;
d1375 1
a1375 1
	    register char *shellp, *shellname;
d1637 1
a1637 1
	register struct env_lst *ep;
d1708 1
a1708 1
	register struct env_lst *ep;
d1737 1
a1737 1
	register struct env_lst *ep;
d1755 1
a1755 1
	register struct env_lst *ep;
d1765 1
a1765 1
	register struct env_lst *ep;
d1775 1
a1775 1
	register struct env_lst *ep;
d1801 1
a1801 1
	register struct env_lst *ep;
d1832 1
a1832 1
	register struct env_lst *ep;
d2625 1
a2625 1
    register Command *c;
d2640 1
a2640 1
	    register char *cp;
d2708 1
a2708 1
	register Command *c;
d2720 1
a2720 1
		register char *arg;
d2785 1
a2785 1
	register int tmp;
d2787 2
a2788 2
	register struct hostent *host = 0;
	register char c;
@


1.37
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.36 2001/07/09 07:04:54 deraadt Exp $	*/
d2373 1
d2377 2
a2378 1
	}
@


1.36
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.35 2001/04/30 10:00:04 markus Exp $	*/
d2712 1
a2712 1
				printf("%-*s\t%s\r\n", HELPINDENT, c->name,
@


1.35
log
@don't freeaddrinfo if getaddrinfo fails; ok deraadt@@,itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.34 2000/11/08 21:49:44 aaron Exp $	*/
d1385 1
a1385 1
		execl(shellp, shellname, "-c", &saveline[1], 0);
d1387 1
a1387 1
		execl(shellp, shellname, 0);
@


1.34
log
@Fix a buf oflow, only exposed because a user happened to have a host with a
resolvable name > 63 characters and specified a port number on the command
line; spotted by steve@@tightrope.demon.co.uk, who provided a useful traceback.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.33 2000/10/10 15:41:10 millert Exp $	*/
a2416 1
		freeaddrinfo(ares);
@


1.33
log
@Use curses, not ocurses and thus setupterm() not tgetent().  This means
we no longer need to have a faked up telnet_setupterm().

Remove some unused variables and add missing err.h include in sys_bsd.c
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.32 2000/08/13 19:41:13 itojun Exp $	*/
d2194 1
a2194 1
    char m1save[64];
d2199 1
a2199 1
    strcpy(m1save, m1);
@


1.32
log
@recover 1.29 -> 1.30
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.31 2000/08/13 19:39:01 itojun Exp $	*/
a2272 3
#if defined(AF_INET6)
    struct sockaddr_in6 sin6;
#endif
a2273 4
    struct sockaddr_in ladr;
    struct sockaddr *sa;
    int sa_size;
    struct servent *sp = 0;
a2280 1
    int family, port;
@


1.31
log
@properly look at error code from getnameinfo(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.30 2000/08/13 08:37:07 niklas Exp $	*/
d2428 1
a2428 1
	    if (bind(net, res->ai_addr, res->ai_addrlen) < 0) {
@


1.30
log
@telnet -b broke when getaddrinfo conversion was done,
bind(2) was done on the dst addr instead of the src.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.29 2000/08/02 04:10:49 millert Exp $	*/
a2286 1
    int retry;
d2289 6
d2402 1
a2402 6
	    char hbuf[MAXHOSTNAMELEN];
#ifdef NI_WITHSCOPEID
	    const int niflags = NI_NUMERICHOST | NI_WITHSCOPEID;
#else
	    const int niflags = NI_NUMERICHOST;
#endif
d2404 4
a2407 2
	    getnameinfo(res->ai_addr, res->ai_addrlen, hbuf, sizeof(hbuf),
		NULL, 0, niflags);
d2428 3
a2430 3
	    if (bind(net, ares->ai_addr, ares->ai_addrlen) < 0) {
                perror(aliasp);
                (void) close(net);   /* dump descriptor */
d2463 1
a2463 1
	    char hbuf[MAXHOSTNAMELEN];
d2465 4
a2468 2
	    getnameinfo(res->ai_addr, res->ai_addrlen, hbuf, sizeof(hbuf),
		NULL, 0, NI_NUMERICHOST);
@


1.29
log
@$HOME paranoia: never use getenv("HOME") w/o checking for NULL and non-zero
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.28 2000/04/30 23:57:08 millert Exp $	*/
d2426 1
a2426 1
	    if (bind(net, res->ai_addr, res->ai_addrlen) < 0) {
@


1.28
log
@If getaddrinfo() fails:
o Only call herror() if h_errno != 0
o if error == EAI_SERVICE say "bad port" since the generic error,
"service not supported for ai_socktype" is incomprehensible to most
users.
o Use warnx(), not warn() since this is not a case where errno is likely
to be relevant.
Ok'd by Theo
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.27 2000/02/05 18:17:56 itojun Exp $	*/
d2205 2
@


1.27
log
@show scopeid on "Trying foo...".
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.26 2000/01/29 16:07:08 itojun Exp $	*/
d2378 1
d2381 6
a2386 2
	    warn("%s: %s", hostp, gai_strerror(error));
	    herror(hostp);
@


1.26
log
@remove #if 0'ed portion (not necessary due to use of getaddrinfo)
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.25 1999/12/20 09:43:01 itojun Exp $	*/
d2391 5
d2398 1
a2398 1
		NULL, 0, NI_NUMERICHOST);
@


1.25
log
@it looks perror("") has no effect in most cases.
use strerror(errno) and format it on our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.24 1999/12/11 22:12:00 angelos Exp $	*/
a2384 31
#if 0
    if (portp) {
	if (*portp == '-') {
	    portp++;
	    telnetport = 1;
	} else
	    telnetport = 0;
	port = atoi(portp);
	if (port == 0) {
	    sp = getservbyname(portp, "tcp");
	    if (sp)
		port = sp->s_port;
	    else {
		printf("%s: bad port number\r\n", portp);
		return 0;
	    }
	} else {
	    port = htons(port);
	}
    } else {
	if (sp == 0) {
	    sp = getservbyname("telnet", "tcp");
	    if (sp == 0) {
		fprintf(stderr, "telnet: tcp/telnet: unknown service\r\n");
		return 0;
	    }
	    port = sp->s_port;
	}
	telnetport = 1;
    }
#endif
@


1.24
log
@Add a perror() in reporting failure to connect.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.23 1999/12/11 09:08:08 itojun Exp $	*/
d2484 2
a2485 2
	    fprintf(stderr, "telnet: connect to address %s: ", hbuf);
	    perror("");
@


1.23
log
@IPv6/IPv4 dual stack support.  uses getaddrinfo() and getnameinfo()
throughout the code so please look at it with care (for auditing).

XXX source routing is not available for IPv6
(even before I modify, it was not available for IPv4 anyways)
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.22 1999/12/07 01:10:29 deraadt Exp $	*/
d2485 1
@


1.22
log
@extra setuid calls go away
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.21 1999/07/20 12:50:33 deraadt Exp $	*/
d2269 2
a2270 1
    register struct hostent *host = 0, *alias = 0;
d2285 1
d2364 1
a2364 1
    } else {
d2366 18
a2383 60
	memset (&sin, 0, sizeof(sin));
#if defined(HAVE_INET_PTON) && defined(AF_INET6)
	memset (&sin6, 0, sizeof(sin6));

	if(inet_pton(AF_INET6, hostp, &sin6.sin6_addr)) {
	    sin6.sin6_family = family = AF_INET6;
	    sa = (struct sockaddr *)&sin6;
	    sa_size = sizeof(sin6);
	    strcpy(_hostname, hostp);
	    hostname =_hostname;
	} else
#endif
	    if(inet_aton(hostp, &sin.sin_addr)){
		sin.sin_family = family = AF_INET;
		sa = (struct sockaddr *)&sin;
		sa_size = sizeof(sin);
		strcpy(_hostname, hostp);
		hostname = _hostname;
	    } else {
#ifdef HAVE_GETHOSTBYNAME2
		host = gethostbyname2(hostp, AF_INET6);
		if(host == NULL)
		    host = gethostbyname2(hostp, AF_INET);
#else
		host = gethostbyname(hostp);
#endif
		if (host) {
		    strncpy(_hostname, host->h_name, sizeof(_hostname));
		    family = host->h_addrtype;

		    switch(family) {
		    case AF_INET:
			memset(&sin, 0, sizeof(sin));
			sa_size = sizeof(sin);
			sa = (struct sockaddr *)&sin;
			sin.sin_family = family;
			sin.sin_addr   = *((struct in_addr *)(*host->h_addr_list));
			break;
#if defined(AF_INET6) && defined(HAVE_STRUCT_SOCKADDR_IN6)
		    case AF_INET6:
			memset(&sin6, 0, sizeof(sin6));
			sa_size = sizeof(sin6);
			sa = (struct sockaddr *)&sin6;
			sin6.sin6_family = family;
			sin6.sin6_addr   = *((struct in6_addr *)(*host->h_addr_list));
			break;
#endif
		    default:
			fprintf(stderr, "Bad address family: %d\n", family);
			return 0;
		    }
		    
		    _hostname[sizeof(_hostname)-1] = '\0';
		    hostname = _hostname;
		} else {
		    herror(hostp);
		    return 0;
		}
	    }
#if	defined(IP_OPTIONS) && defined(IPPROTO_IP)
d2385 1
a2385 1
#endif
a2414 9
    switch(family) {
    case AF_INET:
	sin.sin_port = port;
	printf("Trying %s...\r\n", inet_ntoa(sin.sin_addr));
	break;
#if defined(AF_INET6) && defined(HAVE_STRUCT_SOCKADDR_IN6)
    case AF_INET6: {
#ifndef INET6_ADDRSTRLEN
#define INET6_ADDRSTRLEN 46 
d2417 13
a2429 15
	char buf[INET6_ADDRSTRLEN];

	sin6.sin6_port = port;
#ifdef HAVE_INET_NTOP
	printf("Trying %s...\r\n", inet_ntop(AF_INET6,
					     &sin6.sin6_addr,
					     buf,
					     sizeof(buf)));
#endif
	break;
    }
#endif
    default:
	abort();
    }
a2430 6
    do {
	net = socket(family, SOCK_STREAM, 0);
	if (net < 0) {
	    perror("telnet: socket");
	    return 0;
	}
d2432 12
a2443 21
	    memset ((caddr_t)&ladr, 0, sizeof (ladr));
	    temp = inet_addr(aliasp);
	    if (temp != INADDR_NONE) {
	        ladr.sin_addr.s_addr = temp;
	        ladr.sin_family = AF_INET;
	        alias = gethostbyaddr((char *)&temp, sizeof(temp), AF_INET);
	    } else {
	        alias = gethostbyname(aliasp);
	        if (alias) {
		    ladr.sin_family = alias->h_addrtype;
#if	defined(h_addr)		/* In 4.3, this is a #define */
		    memmove((caddr_t)&ladr.sin_addr,
			alias->h_addr_list[0], alias->h_length);
#else	/* defined(h_addr) */
		    memmove((caddr_t)&ladr.sin_addr, alias->h_addr,
			alias->h_length);
#endif	/* defined(h_addr) */
	        } else {
		    herror(aliasp);
		    return 0;
	        }
d2445 2
a2446 4
            ladr.sin_port = htons(0);
  
            if (bind (net, (struct sockaddr *)&ladr, sizeof(ladr)) < 0) {
                perror(aliasp);; 
d2448 2
a2449 1
		return 0;
d2451 5
a2455 3
        }
 #if	defined(IP_OPTIONS) && defined(IPPROTO_IP)
	if (srp && setsockopt(net, IPPROTO_IP, IP_OPTIONS, (char *)srp, srlen) < 0)
d2459 1
a2459 1
	{
d2479 2
a2480 2
	if (connect(net, sa, sa_size) < 0) {
	    int retry = 0;
d2482 8
a2489 48
	    if (host && host->h_addr_list[1]) {
		int oerrno = errno;
	        retry = 1;

		switch(family) {
		case AF_INET :
		    fprintf(stderr, "telnet: connect to address %s: ",
			    inet_ntoa(sin.sin_addr));
		    sin.sin_addr = *((struct in_addr *)(*++host->h_addr_list));
		    break;
#if defined(AF_INET6) && defined(HAVE_STRUCT_SOCKADDR_IN6)
		case AF_INET6: {
		    char buf[INET6_ADDRSTRLEN];

		    fprintf(stderr, "telnet: connect to address %s: ",
			    inet_ntop(AF_INET6, &sin6.sin6_addr, buf,
				      sizeof(buf)));
		    sin6.sin6_addr = *((struct in6_addr *)(*++host->h_addr_list));
		    break;
		}
#endif
		default:
		    abort();
		}
                   
		errno = oerrno;
		perror(NULL);

		switch(family) {
		case AF_INET :
			printf("Trying %s...\r\n", inet_ntoa(sin.sin_addr));
			break;
#if defined(AF_INET6) && defined(HAVE_STRUCT_SOCKADDR_IN6)
		case AF_INET6: {
		    printf("Trying %s...\r\n", inet_ntop(AF_INET6,
					     &sin6.sin6_addr,
					     buf,
					     sizeof(buf)));
		    break;
		}
#endif
		}
		
		(void) NetClose(net);
		continue;
	    }
	    perror("telnet: Unable to connect to remote host");
	    return 0;
d2491 1
d2496 6
a2501 1
    } while (connected == 0);
@


1.21
log
@skey help; freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.20 1999/01/04 07:55:05 art Exp $	*/
a2291 2
	seteuid(getuid());
	setuid(getuid());
a2340 2
	seteuid(getuid());
	setuid(getuid());
a2354 2
	    seteuid(getuid());
	    setuid(getuid());
a2357 2
	    seteuid(getuid());
	    setuid(getuid());
a2419 2
		    seteuid(getuid());
		    setuid(getuid());
a2438 2
		seteuid(getuid());
		setuid(getuid());
a2448 2
		seteuid(getuid());
		setuid(getuid());
a2483 2
	seteuid(getuid());
	setuid(getuid());
@


1.20
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.19 1998/07/16 18:55:59 deraadt Exp $	*/
d73 1
a73 1
		printf("%s sequence challenge\n", argv[0]);
d2668 3
d2709 1
a2709 1
	{ "skey",	NULL,		skey_calc,	0 },
@


1.19
log
@terminate nicer
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.18 1998/07/09 06:32:10 deraadt Exp $	*/
d1978 1
a1978 1
    { "type", "Set encryptiong type. ('encrypt type ?' for more)",
@


1.18
log
@use MAXHOSTNAMELEN
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.17 1998/07/01 19:31:12 deraadt Exp $	*/
d1679 2
a1680 2
				strncpy(hbuf, he->h_name, sizeof hbuf);
			hbuf[256] = '\0';
@


1.17
log
@delete unknown error
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.16 1998/05/23 12:15:20 deraadt Exp $	*/
d1670 1
a1670 1
		char hbuf[256+1];
d1673 1
a1673 2
		gethostname(hbuf, 256);
		hbuf[256] = '\0';
d1679 1
a1679 1
				strncpy(hbuf, he->h_name, 256);
@


1.16
log
@fix multi-address host connects; cstone@@pobox.com
print new address as it is tried; deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.15 1998/05/15 03:16:35 art Exp $	*/
a2430 2
		    fprintf (stderr, "%s: %s\r\n", hostp ? hostp : "",
			     "unknown error");
@


1.15
log
@cleanup warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.14 1998/05/15 01:26:09 art Exp $	*/
d2564 2
d2568 1
d2579 1
a2579 1
		    
d2593 16
a2608 3
		host->h_addr_list++;
		memmove((caddr_t)&sin.sin_addr,
			host->h_addr_list[0], host->h_length);
@


1.14
log
@check mallocs
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.13 1998/04/07 20:01:06 art Exp $	*/
d38 1
d74 1
a74 1
		return;
d82 1
a82 1
		perror("fork");
d152 1
a152 1
	static
d1407 1
a1407 1
    static
d1503 1
a1503 1
    static
d1588 1
d1768 1
a1768 1
	if (ep = env_find(var))
d1921 1
d2103 1
a2103 1
    static
d2610 2
a2611 2
	    (pw = getpwnam(user)) && pw->pw_uid != getuid()) {
		if (pw = getpwuid(getuid()))
d2823 1
a2823 1
	static
a2851 3

static char *rcname = 0;
static char rcbuf[128];
@


1.13
log
@ - show usage for the encrypt command when there are no arguments.
 - don't default to autologin and autoencrypt when kerberos is disabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.12 1998/03/18 21:21:40 art Exp $	*/
d1683 2
d1715 2
a1716 1
		ep = (struct env_lst *)malloc(sizeof(struct env_lst));
d1725 4
a1728 2
	ep->var = (unsigned char *)strdup((char *)var);
	ep->value = (unsigned char *)strdup((char *)value);
d2311 2
a2312 1
	    user = strdup(*argv++);
@


1.12
log
@fix connecting to ip-numbers
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.11 1998/03/12 17:31:30 deraadt Exp $	*/
d2013 7
@


1.11
log
@repair tn3270
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.10 1998/03/12 04:57:29 art Exp $	*/
d2363 2
d2371 2
@


1.10
log
@encryption support from kth-krb 0.9.8 (kerberos only)
plus some tweaks for better binary/8-bit support.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.9 1996/12/22 03:26:08 tholo Exp $	*/
d1323 1
a1323 1
    static int
d2136 1
a2136 1
					    getpid(), getpgrp(getpid()));
@


1.9
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.8 1996/12/06 15:21:53 robin Exp $	*/
d37 1
a37 55
#ifndef lint
#if 0
static char sccsid[] = "@@(#)commands.c	8.4 (Berkeley) 5/30/95";
static char rcsid[] = "$NetBSD: commands.c,v 1.14 1996/03/24 22:03:48 jtk Exp $";
#else
static char rcsid[] = "$OpenBSD: commands.c,v 1.8 1996/12/06 15:21:53 robin Exp $";
#endif
#endif /* not lint */

#if	defined(unix)
#include <sys/param.h>
#if	defined(CRAY) || defined(sysV88)
#include <sys/types.h>
#endif
#include <sys/file.h>
#else
#include <sys/types.h>
#endif	/* defined(unix) */
#include <sys/socket.h>
#include <netinet/in.h>
#ifdef	CRAY
#include <fcntl.h>
#endif	/* CRAY */

#include <signal.h>
#include <netdb.h>
#include <ctype.h>
#include <pwd.h>
#include <varargs.h>
#include <errno.h>

#include <arpa/telnet.h>
#include <sys/cdefs.h>
#define P __P

#include "general.h"

#include "ring.h"

#include "externs.h"
#include "defines.h"
#include "types.h"

#if !defined(CRAY) && !defined(sysV88)
#include <netinet/in_systm.h>
# if (defined(vax) || defined(tahoe) || defined(hp300)) && !defined(ultrix)
# include <machine/endian.h>
# endif /* vax */
#endif /* !defined(CRAY) && !defined(sysV88) */
#include <netinet/ip.h>


#ifndef	MAXHOSTNAMELEN
#define	MAXHOSTNAMELEN 64
#endif	MAXHOSTNAMELEN
d46 2
a47 7
extern char *getenv();

extern int isprefix();
extern char **genget();
extern int Ambiguous();

static call();
d108 1
a108 1
    while (c = *cp) {
a279 1
    int question = 0;	/* was at least one argument a question */
d285 2
a286 2
	printf("need at least one argument for 'send' command\n");
	printf("'send ?' for help\n");
d299 1
a299 1
	    printf("Unknown send argument '%s'\n'send ?' for help.\n",
d303 1
a303 1
	    printf("Ambiguous send argument '%s'\n'send ?' for help.\n",
d309 1
a309 1
	    "Need %d argument%s to 'send %s' command.  'send %s ?' for help.\n",
d323 2
a324 2
	printf("?Need to be connected first.\n");
	printf("'send ?' for help\n");
d329 4
a332 4
	printf("There is not enough room in the buffer TO the network\n");
	printf("to process your request.  Nothing will be done.\n");
	printf("('send synch' will throw away most data in the network\n");
	printf("buffer, if this might help.)\n");
d339 1
a339 1
	    fprintf(stderr, "Telnet 'send' error - argument disappeared!\n");
d356 3
d401 1
a401 1
    if (isprefix(name, "?")) {
d404 3
a406 3
	printf("Usage: send %s <value|option>\n", cmd);
	printf("\"value\" must be from 0 to 255\n");
	printf("Valid options are:\n\t");
d412 1
a412 1
		printf("\n\t");
d418 1
a418 1
	printf("\n");
d423 1
a423 1
	fprintf(stderr,"'%s': ambiguous argument ('send %s ?' for help).\n",
d438 1
a438 1
	    fprintf(stderr, "'%s': unknown argument ('send %s ?' for help).\n",
d442 1
a442 1
	    fprintf(stderr, "'%s': bad value ('send %s ?' for help).\n",
d448 1
a448 1
	printf("?Need to be connected first.\n");
d461 1
a461 1
	    printf("%-15s %s\n", s->name, s->help);
d488 1
a488 1
	if (net > 0 && SetSockOpt(net, SOL_SOCKET, SO_DEBUG, 1) < 0)
d491 1
a491 1
	printf("Cannot turn off socket debugging\n");
d501 1
a501 1
	printf("Will send carriage returns as telnet <CR><LF>.\n");
d503 1
a503 1
	printf("Will send carriage returns as telnet <CR><NUL>.\n");
d532 1
a532 1
	    printf("Already operating in binary mode with remote host.\n");
d534 1
a534 1
	    printf("Negotiating binary mode with remote host.\n");
d540 1
a540 1
	    printf("Already in network ascii mode with remote host.\n");
d542 1
a542 1
	    printf("Negotiating network ascii mode with remote host.\n");
d560 1
a560 1
	    printf("Already receiving in binary mode.\n");
d562 1
a562 1
	    printf("Negotiating binary mode on input.\n");
d567 1
a567 1
	    printf("Already receiving in network ascii mode.\n");
d569 1
a569 1
	    printf("Negotiating network ascii mode on input.\n");
d587 1
a587 1
	    printf("Already transmitting in binary mode.\n");
d589 1
a589 1
	    printf("Negotiating binary mode on output.\n");
d594 1
a594 1
	    printf("Already transmitting in network ascii mode.\n");
d596 1
a596 1
	    printf("Negotiating network ascii mode on output.\n");
d608 7
d630 1
a630 1
		    "flush output when sending interrupt characters", 0 },
d635 1
a635 1
		    "send interrupt characters in urgent mode", 0 },
d641 1
a641 1
		    "send login name and/or authentication information", 0 },
d646 23
a668 1
		     "print authentication debugging information", 0 },
d674 1
a674 1
		    "skip reading of ~/.telnetrc file", 0 },
d679 1
a679 1
		    0, 1 },
d684 1
a684 1
		    0, 1 },
d689 1
a689 1
		    0, 1 },
d694 1
a694 1
		    0, 0 },
d699 1
a699 1
		    "map carriage return on output", 0 },
d704 1
a704 1
		    "recognize certain control characters", 0 },
d722 1
a722 1
		    "turn on socket level debugging", 0 },
d727 1
a727 1
		    "print hexadecimal representation of network traffic", 0 },
d732 1
a732 1
		    "print user readable output for \"netdata\"", 0 },
d737 1
a737 1
		    "show option processing", 0 },
d743 1
a743 1
		    "print hexadecimal representation of terminal traffic", 0 },
d747 1
a747 1
	    togglehelp, 0 },
d750 1
a750 1
	    togglehelp, 0 },
d762 1
a762 1
		printf("%-15s toggle %s\n", c->name, c->help);
d764 1
a764 1
		printf("\n");
d767 2
a768 2
    printf("\n");
    printf("%-15s %s\n", "?", "display help information");
d781 1
a781 1
		printf("%-15s %s %s\n", c->name, set ? "enable" : "disable",
d784 1
a784 1
		printf("\n");
d803 1
a803 1
	    "Need an argument to 'toggle' command.  'toggle ?' for help.\n");
d812 1
a812 1
	    fprintf(stderr, "'%s': ambiguous argument ('toggle ?' for help).\n",
d816 1
a816 1
	    fprintf(stderr, "'%s': unknown argument ('toggle ?' for help).\n",
d820 2
a821 2
	    printf("?Need to be connected first.\n");
	    printf("'send ?' for help\n");
d827 1
a827 1
		    printf("%s %s.\n", *c->variable? "Will" : "Won't",
d844 1
a844 1
struct termio new_tc = { 0 };
d863 4
a866 4
    { "flushoutput", "character to cause an Abort Output", 0, termFlushCharp },
    { "interrupt", "character to cause an Interrupt Process", 0, termIntCharp },
    { "quit",	"character to cause an Abort process", 0, termQuitCharp },
    { "eof",	"character to cause an EOF ", 0, termEofCharp },
d869 11
a879 11
    { "erase",	"character to use to erase a character", 0, termEraseCharp },
    { "kill",	"character to use to erase a line", 0, termKillCharp },
    { "lnext",	"character to use for literal next", 0, termLiteralNextCharp },
    { "susp",	"character to cause a Suspend Process", 0, termSuspCharp },
    { "reprint", "character to use for line reprint", 0, termRprntCharp },
    { "worderase", "character to use to erase a word", 0, termWerasCharp },
    { "start",	"character to use for XON", 0, termStartCharp },
    { "stop",	"character to use for XOFF", 0, termStopCharp },
    { "forw1",	"alternate end of line character", 0, termForw1Charp },
    { "forw2",	"alternate end of line character", 0, termForw2Charp },
    { "ayt",	"alternate AYT character", 0, termAytCharp },
a882 29
#if	defined(CRAY) && !defined(__STDC__)
/* Work around compiler bug in pcc 4.1.5 */
    void
_setlist_init()
{
#ifndef	KLUDGELINEMODE
#define	N 5
#else
#define	N 6
#endif
	Setlist[N+0].charp = &termFlushChar;
	Setlist[N+1].charp = &termIntChar;
	Setlist[N+2].charp = &termQuitChar;
	Setlist[N+3].charp = &termEofChar;
	Setlist[N+6].charp = &termEraseChar;
	Setlist[N+7].charp = &termKillChar;
	Setlist[N+8].charp = &termLiteralNextChar;
	Setlist[N+9].charp = &termSuspChar;
	Setlist[N+10].charp = &termRprntChar;
	Setlist[N+11].charp = &termWerasChar;
	Setlist[N+12].charp = &termStartChar;
	Setlist[N+13].charp = &termStopChar;
	Setlist[N+14].charp = &termForw1Char;
	Setlist[N+15].charp = &termForw2Char;
	Setlist[N+16].charp = &termAytChar;
#undef	N
}
#endif	/* defined(CRAY) && !defined(__STDC__) */

d897 1
a897 1
		printf("Telnet rlogin escape character is '%s'.\n",
d901 1
a901 1
		printf("Telnet escape character is '%s'.\n", control(escape));
d915 1
a915 1
	printf("Format is 'set Name Value'\n'set ?' for help.\n");
d920 2
a921 2
	    printf("%-15s %s\n", ct->name, ct->help);
	printf("\n");
d923 1
a923 1
	printf("%-15s %s\n", "?", "display help information");
d931 1
a931 1
	    fprintf(stderr, "'%s': unknown argument ('set ?' for help).\n",
d935 1
a935 1
	    fprintf(stderr, "'%s': ambiguous argument ('set ?' for help).\n",
d939 2
a940 2
	    printf("?Need to be connected first.\n");
	    printf("'send ?' for help\n");
d950 1
a950 1
		printf("Format is 'set togglename [on|off]'\n'set ?' for help.\n");
d954 1
a954 1
		printf("%s %s.\n", *c->variable? "Will" : "Won't",
d961 1
a961 1
	printf("Format is 'set Name Value'\n'set ?' for help.\n");
d964 1
a964 1
	fprintf(stderr, "'%s': ambiguous argument ('set ?' for help).\n",
d969 1
a969 1
	printf("%s set to \"%s\".\n", ct->name, (char *)ct->charp);
d977 1
a977 1
	printf("%s character is '%s'.\n", ct->name, control(*(ct->charp)));
d994 1
a994 1
	    "Need an argument to 'unset' command.  'unset ?' for help.\n");
d999 2
a1000 2
	    printf("%-15s %s\n", ct->name, ct->help);
	printf("\n");
d1002 1
a1002 1
	printf("%-15s %s\n", "?", "display help information");
d1014 1
a1014 1
		fprintf(stderr, "'%s': unknown argument ('unset ?' for help).\n",
d1018 1
a1018 1
		fprintf(stderr, "'%s': ambiguous argument ('unset ?' for help).\n",
d1025 1
a1025 1
		    printf("%s %s.\n", *c->variable? "Will" : "Won't",
d1032 1
a1032 1
	    fprintf(stderr, "'%s': ambiguous argument ('unset ?' for help).\n",
d1037 1
a1037 1
	    printf("%s reset to \"%s\".\n", ct->name, (char *)ct->charp);
d1040 1
a1040 1
	    printf("%s character is '%s'.\n", ct->name, control(*(ct->charp)));
d1060 1
d1097 2
a1098 2
	printf("?Need to have LINEMODE option enabled first.\n");
	printf("'mode ?' for help.\n");
d1111 1
a1111 1
setmode(bit)
d1117 1
a1117 1
clearmode(bit)
d1130 1
a1130 1
extern int modehelp();
d1143 12
a1154 12
    { "isig",	"Enable signal trapping",	setmode, 1, MODE_TRAPSIG },
    { "+isig",	0,				setmode, 1, MODE_TRAPSIG },
    { "-isig",	"Disable signal trapping",	clearmode, 1, MODE_TRAPSIG },
    { "edit",	"Enable character editing",	setmode, 1, MODE_EDIT },
    { "+edit",	0,				setmode, 1, MODE_EDIT },
    { "-edit",	"Disable character editing",	clearmode, 1, MODE_EDIT },
    { "softtabs", "Enable tab expansion",	setmode, 1, MODE_SOFT_TAB },
    { "+softtabs", 0,				setmode, 1, MODE_SOFT_TAB },
    { "-softtabs", "Disable character editing",	clearmode, 1, MODE_SOFT_TAB },
    { "litecho", "Enable literal character echo", setmode, 1, MODE_LIT_ECHO },
    { "+litecho", 0,				setmode, 1, MODE_LIT_ECHO },
    { "-litecho", "Disable literal character echo", clearmode, 1, MODE_LIT_ECHO },
d1165 1
a1165 1
    int
d1170 1
a1170 1
    printf("format is:  'mode Mode', where 'Mode' is one of:\n\n");
d1174 1
a1174 1
		printf("%-15s %s\n", mt->name, mt->help);
d1176 1
a1176 1
		printf("\n");
d1193 2
a1194 2
	printf("'mode' command requires an argument\n");
	printf("'mode ?' for help.\n");
d1196 1
a1196 1
	fprintf(stderr, "Unknown mode '%s' ('mode ?' for help).\n", argv[1]);
d1198 1
a1198 1
	fprintf(stderr, "Ambiguous mode '%s' ('mode ?' for help).\n", argv[1]);
d1200 2
a1201 2
	printf("?Need to be connected first.\n");
	printf("'mode ?' for help.\n");
d1227 1
a1227 1
			    printf(" %s.\n", tl->actionexplanation); \
d1232 1
a1232 1
			    printf("%-15s [%s]\n", sl->name, control(*sl->charp)); \
d1234 1
a1234 1
			    printf("%-15s \"%s\"\n", sl->name, (char *)sl->charp); \
d1241 1
a1241 1
	printf("\n");
d1252 1
a1252 1
		printf("?Ambiguous argument '%s'.\n", argv[i]);
d1255 1
a1255 1
		printf("?Unknown argument '%s'.\n", argv[i]);
d1268 3
d1275 1
a1275 1

d1293 1
a1293 1
	    "Deprecated usage - please use 'set escape%s%s' in the future.\n",
d1305 1
a1305 1
		printf("Escape character is '%s'.\n", control(escape));
d1316 2
a1317 2
    printf("Deprecated usage - please use 'toggle crmod' in the future.\n");
    printf("%s map carriage return on output.\n", crmod ? "Will" : "Won't");
d1323 2
a1324 2
    int
suspend()
d1347 1
a1347 1
    printf("Suspend is not supported.  Try the '!' command instead\n");
d1366 1
a1366 1
	perror("Fork failed\n");
a1374 1
	    extern char *strrchr();
d1415 1
a1415 1
	printf("Connection closed.\n");
d1419 1
a1419 1
#if	defined(AUTHENTICATION)
d1432 1
a1432 1
    return 1;			/* Keep lint, etc., happy */
d1436 1
d1441 1
a1441 1
	/*NOTREACHED*/
d1445 1
a1445 1
	int
d1487 1
a1487 1
		printf("%-15s %s\n", c->name, c->help);
d1489 1
a1489 1
		printf("\n");
d1511 1
a1511 1
	    "Need an argument to 'slc' command.  'slc ?' for help.\n");
d1516 1
a1516 1
	fprintf(stderr, "'%s': unknown argument ('slc ?' for help).\n",
d1521 1
a1521 1
	fprintf(stderr, "'%s': ambiguous argument ('slc ?' for help).\n",
d1541 1
a1541 13
extern struct env_lst *
	env_define P((unsigned char *, unsigned char *));
extern void
	env_undefine P((unsigned char *)),
	env_export P((unsigned char *)),
	env_unexport P((unsigned char *)),
	env_send P((unsigned char *)),
#if defined(OLD_ENVIRON) && defined(ENV_HACK)
	env_varval P((unsigned char *)),
#endif
	env_list P((void));
static void
	env_help P((void));
d1572 1
a1572 1
		printf("%-15s %s\n", c->name, c->help);
d1574 1
a1574 1
		printf("\n");
d1595 1
a1595 1
	    "Need an argument to 'environ' command.  'environ ?' for help.\n");
d1600 1
a1600 1
	fprintf(stderr, "'%s': unknown argument ('environ ?' for help).\n",
d1605 1
a1605 1
	fprintf(stderr, "'%s': ambiguous argument ('environ ?' for help).\n",
d1611 1
a1611 1
	    "Need %s%d argument%s to 'environ %s' command.  'environ ?' for help.\n",
d1648 2
a1649 3
	register char **epp, *cp;
	register struct env_lst *ep;
	extern char *strchr();
d1652 1
a1652 1
		if (cp = strchr(*epp, '=')) {
d1673 11
a1683 2
		cp = (char *)malloc(strlen(hbuf) + strlen(cp2) + 1);
		sprintf((char *)cp, "%s%s", hbuf, cp2);
d1698 1
d1707 1
a1707 1
	if (ep = env_find(var)) {
d1720 1
a1720 1
	ep->welldefined = opt_welldefined(var);
d1733 1
a1733 1
	if (ep = env_find(var)) {
d1751 1
a1751 1
	if (ep = env_find(var))
d1777 1
a1777 1
		    "Cannot send '%s': Telnet ENVIRON option not enabled\n",
d1783 1
a1783 1
		fprintf(stderr, "Cannot send '%s': variable not defined\n",
d1798 1
a1798 1
		printf("%c %-20s %s\n", ep->export ? '*' : ' ',
d1811 1
a1811 1
		return;
d1814 1
a1814 1
		while (nep = nep->next) {
d1828 1
a1828 1
	if (ep = env_find(var))
d1847 1
a1847 1
					"determined automatically\n");
d1849 1
a1849 1
			printf("VAR and VALUE set to correct definitions\n");
d1851 1
a1851 1
			printf("VAR and VALUE definitions are reversed\n");
d1866 1
a1866 1
		printf("Unknown \"varval\" command. (\"auto\", \"right\", \"wrong\", \"status\")\n");
a1882 4
extern int
	auth_enable P((char *)),
	auth_disable P((char *)),
	auth_status P((void));
d1906 1
a1906 1
		printf("%-15s %s\n", c->name, c->help);
d1908 1
a1908 1
		printf("\n");
d1922 1
a1922 1
	    "Need an argument to 'auth' command.  'auth ?' for help.\n");
d1929 1
a1929 1
	fprintf(stderr, "'%s': unknown argument ('auth ?' for help).\n",
d1934 1
a1934 1
	fprintf(stderr, "'%s': ambiguous argument ('auth ?' for help).\n",
d1940 1
a1940 1
	    "Need %s%d argument%s to 'auth %s' command.  'auth ?' for help.\n",
d1949 101
d2067 1
a2067 1
    printf("\tOwner is %d.\n", res);
d2079 1
a2079 1
    printf("\tFlags are 0x%x: %s\n", res, decodeflags(res));
d2094 1
a2094 1
	printf("Connected to %s.\n", hostname);
d2099 3
a2101 3
		printf("Operating with LINEMODE option\n");
		printf("%s line editing\n", (mode&MODE_EDIT) ? "Local" : "No");
		printf("%s catching of signals\n",
d2106 1
a2106 1
		printf("Operating in obsolete linemode\n");
d2109 1
a2109 1
		printf("Operating in single character mode\n");
d2111 1
a2111 1
		    printf("Catching signals locally\n");
d2113 1
a2113 1
	    printf("%s character echo\n", (mode&MODE_ECHO) ? "Local" : "Remote");
d2115 4
a2118 1
		printf("%s flow control\n", (mode&MODE_FLOW) ? "Local" : "No");
d2121 1
a2121 1
	printf("No connection.\n");
d2124 1
a2124 1
    printf("Escape character is '%s'.\n", control(escape));
d2128 1
a2128 1
	printf("Escape character is '%s'.\n", control(escape));
d2132 1
a2132 1
	printf("SIGIO received %d time%s.\n",
d2135 1
a2135 1
	    printf("Process ID %d, process group %d.\n",
d2137 1
a2137 1
	    printf("Terminal input:\n");
d2139 1
a2139 1
	    printf("Terminal output:\n");
d2141 1
a2141 1
	    printf("Network socket:\n");
d2146 1
a2146 1
       printf("Transparent mode command is '%s'.\n", transcom);
d2154 1
d2162 1
d2169 80
a2248 1
unsigned long inet_addr();
d2256 3
d2261 2
d2267 2
a2268 2
    char *srp = 0, *strrchr();
    unsigned long sourceroute(), srlen;
d2271 1
d2277 1
a2277 1
	printf("?Already connected to %s\n", hostname);
d2299 1
a2299 1
	    user = *argv++;
d2327 1
a2327 1
	printf("usage: %s [-l user] [-a] host-name [port]\n", cmd);
d2348 1
a2348 1
	    printf("Bad source route option: %s\n", hostp);
d2353 1
a2353 2
	    sin.sin_addr.s_addr = temp;
	    sin.sin_family = AF_INET;
d2357 13
a2369 22
	temp = inet_addr(hostp);
	if (temp != INADDR_NONE) {
	    sin.sin_addr.s_addr = temp;
	    sin.sin_family = AF_INET;
	    host = gethostbyaddr((char *)&temp, sizeof(temp), AF_INET);
	    if (host)
	        (void) strcpy(_hostname, host->h_name);
	    else
		(void) strcpy(_hostname, hostp);
	    hostname = _hostname;
	} else {
	    host = gethostbyname(hostp);
	    if (host) {
		sin.sin_family = host->h_addrtype;
#if	defined(h_addr)		/* In 4.3, this is a #define */
		memmove((caddr_t)&sin.sin_addr,
				host->h_addr_list[0], host->h_length);
#else	/* defined(h_addr) */
		memmove((caddr_t)&sin.sin_addr, host->h_addr, host->h_length);
#endif	/* defined(h_addr) */
		strncpy(_hostname, host->h_name, sizeof(_hostname));
		_hostname[sizeof(_hostname)-1] = '\0';
d2372 43
a2414 4
		herror(hostp);
		seteuid(getuid());
		setuid(getuid());
		return 0;
a2415 1
	}
d2425 2
a2426 2
	sin.sin_port = atoi(portp);
	if (sin.sin_port == 0) {
d2429 1
a2429 1
		sin.sin_port = sp->s_port;
d2431 1
a2431 1
		printf("%s: bad port number\n", portp);
d2437 1
a2437 4
#if	!defined(htons)
	    u_short htons P((unsigned short));
#endif	/* !defined(htons) */
	    sin.sin_port = htons(sin.sin_port);
d2443 1
a2443 1
		fprintf(stderr, "telnet: tcp/telnet: unknown service\n");
d2448 1
a2448 1
	    sin.sin_port = sp->s_port;
d2452 27
a2478 1
    printf("Trying %s...\n", inet_ntoa(sin.sin_addr));
d2480 1
a2480 1
	net = socket(AF_INET, SOCK_STREAM, 0);
d2533 1
a2533 1
		    (char *)&tos, sizeof(int)) < 0)
d2543 1
a2543 2
	if (connect(net, (struct sockaddr *)&sin, sizeof (sin)) < 0) {
#if	defined(h_addr)		/* In 4.3, this is a #define */
d2547 21
a2567 2
		fprintf(stderr, "telnet: connect to address %s: ",
						inet_ntoa(sin.sin_addr));
d2569 1
a2569 1
		perror((char *)0);
a2575 1
#endif	/* defined(h_addr) */
d2580 1
a2580 1
#if	defined(AUTHENTICATION)
d2605 1
a2605 1
    ExitString("Connection closed by foreign host.\n",1);
d2607 1
d2631 3
a2633 1
#if	defined(unix)
a2634 1
#endif	/* defined(unix) */
d2639 1
a2639 1
static int	help();
d2660 5
a2664 3
#if	defined(unix)
	{ "z",		zhelp,		suspend,	0 },
#endif	/* defined(unix) */
d2675 1
a2675 1
	0
d2685 1
a2685 1
	0
d2694 2
a2695 3
    static
call(va_alist)
    va_dcl
a2697 2
    typedef int (*intrtn_t)();
    intrtn_t routine;
d2701 2
a2702 5
    va_start(ap);
    routine = (va_arg(ap, intrtn_t));
    while ((args[argno++] = va_arg(ap, char *)) != 0) {
	;
    }
d2714 1
a2714 1
    if (cm = (Command *) genget(name, (char **) cmdtab, sizeof(Command)))
d2749 1
a2749 1
		printf("%s\n", line);
d2770 1
a2770 1
	    printf("?Ambiguous command\n");
d2774 1
a2774 1
	    printf("?Invalid command\n");
d2778 1
a2778 1
	    printf("?Need to be connected first.\n");
d2811 1
a2811 1
		printf("Commands may be abbreviated.  Commands are:\n\n");
d2814 1
a2814 1
				printf("%-*s\t%s\n", HELPINDENT, c->name,
d2824 1
a2824 1
			printf("?Ambiguous help command %s\n", arg);
d2826 1
a2826 1
			printf("?Invalid help command %s\n", arg);
d2828 1
a2828 1
			printf("%s\n", c->help);
a2835 80
cmdrc(m1, m2)
	char *m1, *m2;
{
    register Command *c;
    FILE *rcfile;
    int gotmachine = 0;
    int l1 = strlen(m1);
    int l2 = strlen(m2);
    char m1save[64];

    if (skiprc)
	return;

    strcpy(m1save, m1);
    m1 = m1save;

    if (rcname == 0) {
	rcname = getenv("HOME");
	if (rcname && (strlen(rcname) + 10) < sizeof(rcbuf))
	    strcpy(rcbuf, rcname);
	else
	    rcbuf[0] = '\0';
	strcat(rcbuf, "/.telnetrc");
	rcname = rcbuf;
    }

    if ((rcfile = fopen(rcname, "r")) == 0) {
	return;
    }

    for (;;) {
	if (fgets(line, sizeof(line), rcfile) == NULL)
	    break;
	if (line[0] == 0)
	    break;
	if (line[0] == '#')
	    continue;
	if (gotmachine) {
	    if (!isspace(line[0]))
		gotmachine = 0;
	}
	if (gotmachine == 0) {
	    if (isspace(line[0]))
		continue;
	    if (strncasecmp(line, m1, l1) == 0)
		strncpy(line, &line[l1], sizeof(line) - l1);
	    else if (strncasecmp(line, m2, l2) == 0)
		strncpy(line, &line[l2], sizeof(line) - l2);
	    else if (strncasecmp(line, "DEFAULT", 7) == 0)
		strncpy(line, &line[7], sizeof(line) - 7);
	    else
		continue;
	    if (line[0] != ' ' && line[0] != '\t' && line[0] != '\n')
		continue;
	    gotmachine = 1;
	}
	makeargv();
	if (margv[0] == 0)
	    continue;
	c = getcmd(margv[0]);
	if (Ambiguous(c)) {
	    printf("?Ambiguous command: %s\n", margv[0]);
	    continue;
	}
	if (c == 0) {
	    printf("?Invalid command: %s\n", margv[0]);
	    continue;
	}
	/*
	 * This should never happen...
	 */
	if (c->needconnect && !connected) {
	    printf("?Need to be connected first for %s.\n", margv[0]);
	    continue;
	}
	(*c->handler)(margc, margv);
    }
    fclose(rcfile);
}

d2949 1
a2949 1
		else for (cp2 = cp; c = *cp2; cp2++) {
d2965 1
a2965 1
		if ((tmp = inet_addr(cp)) != INADDR_NONE) {
d2967 1
a2967 1
		} else if (host = gethostbyname(cp)) {
d2970 2
a2971 1
				host->h_addr_list[0], host->h_length);
d2973 2
a2974 1
			memmove((caddr_t)&sin_addr, host->h_addr, host->h_length);
@


1.8
log
@Fix bug where one could ``send'' various TELNET commands from the telnet
command prompt, prior to being connected to a remote host.

The affected commands were:

  set       binary | inbinary | outbinary
  toggle    binary | inbinary | outbinary
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.7 1996/10/28 00:54:10 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: commands.c,v 1.7 1996/10/28 00:54:10 millert Exp $";
d2147 1
d2197 1
d2213 1
d2218 1
d2252 1
d2273 1
d2288 1
d2299 1
@


1.7
log
@Safe $HOME handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.6 1996/09/05 09:10:02 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: commands.c,v 1.6 1996/09/05 09:10:02 deraadt Exp $";
d672 1
d680 1
a680 1
		    "flush output when sending interrupt characters" },
d685 1
a685 1
		    "send interrupt characters in urgent mode" },
d691 1
a691 1
		    "send login name and/or authentication information" },
d696 1
a696 1
		     "print authentication debugging information" },
d702 1
a702 1
		    "skip reading of ~/.telnetrc file" },
d707 1
a707 1
		    0 },
d712 1
a712 1
		    0 },
d717 1
a717 1
		    0 },
d722 1
a722 1
		    0 },
d727 1
a727 1
		    "map carriage return on output" },
d732 2
a733 2
		    "recognize certain control characters" },
    { " ", "", 0 },		/* empty line */
d739 1
a739 1
		    "trace API transactions" },
d744 1
a744 1
		    "print hexadecimal representation of curses data" },
d750 1
a750 1
		    "turn on socket level debugging" },
d755 1
a755 1
		    "print hexadecimal representation of network traffic" },
d760 1
a760 1
		    "print user readable output for \"netdata\"" },
d765 1
a765 1
		    "show option processing" },
d771 1
a771 1
		    "print hexadecimal representation of terminal traffic" },
d775 1
a775 1
	    togglehelp },
d778 1
a778 1
	    togglehelp },
d847 4
d995 4
d1000 1
@


1.6
log
@skey command for inline use; by brian@@saturn.net (but i had to fix his sleep deprived code)
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.5 1996/07/03 14:01:55 niklas Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: commands.c,v 1.5 1996/07/03 14:01:55 niklas Exp $";
d2639 1
a2639 1
	if (rcname)
@


1.5
log
@Add a -b option that takes a hostname or IP-address as an argument.
This address is bound to the local socket of the TCP connection and is
useful for talking to services which does authentication based on IP-
addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.4 1996/04/21 23:44:11 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: commands.c,v 1.4 1996/04/21 23:44:11 deraadt Exp $";
d120 33
d2451 3
@


1.4
log
@sync to netbsd 960418
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.3 1996/03/27 19:32:58 niklas Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: commands.c,v 1.3 1996/03/27 19:32:58 niklas Exp $";
d2087 1
a2087 1
    register struct hostent *host = 0;
d2089 1
d2097 1
a2097 1
    char *cmd, *hostp = 0, *portp = 0, *user = 0;
d2128 8
d2254 32
a2285 1
#if	defined(IP_OPTIONS) && defined(IPPROTO_IP)
@


1.3
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: commands.c,v 1.13 1996/02/28 21:03:53 thorpej Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: commands.c,v 1.13 1996/02/28 21:03:53 thorpej Exp $";
d42 1
a42 1
static char rcsid[] = "$OpenBSD$";
d2175 5
a2179 1
	    (void) strcpy(_hostname, hostp);
@


1.2
log
@from tls; contrary to unpopular opinion, "help" is a perfectly valid hostname
@
text
@d1 3
d38 6
a43 2
/* from: static char sccsid[] = "@@(#)commands.c	8.1 (Berkeley) 6/6/93"; */
static char *rcsid = "$Id: commands.c,v 1.9 1996/01/05 04:19:30 tls Exp $";
d69 2
d89 3
a91 3
#ifndef       MAXHOSTNAMELEN
#define       MAXHOSTNAMELEN 64
#endif        MAXHOSTNAMELEN
d247 1
a247 1
 
d425 1
a425 1
    if (isprefix(name, "help") || isprefix(name, "?")) {
d1345 1
a1345 1
	 * can get them now (???), then send the NAWS to make sure that
d1385 1
a1385 1
	    extern char *rindex();
d1390 1
a1390 1
	    if ((shellname = rindex(shellp, '/')) == 0)
d1526 1
a1526 1
        fprintf(stderr, "'%s': unknown argument ('slc ?' for help).\n",
d1528 1
a1528 1
        return 0;
d1531 1
a1531 1
        fprintf(stderr, "'%s': ambiguous argument ('slc ?' for help).\n",
d1533 1
a1533 1
        return 0;
d1622 1
a1622 1
        fprintf(stderr, "'%s': unknown argument ('environ ?' for help).\n",
d1624 1
a1624 1
        return 0;
d1627 1
a1627 1
        fprintf(stderr, "'%s': ambiguous argument ('environ ?' for help).\n",
d1629 1
a1629 1
        return 0;
d1672 1
a1672 1
	extern char *index();
d1675 1
a1675 1
		if (cp = index(*epp, '=')) {
d1690 1
a1690 1
	        || (strncmp((char *)ep->value, "unix:", 5) == 0))) {
d1692 1
a1692 1
		char *cp2 = index((char *)ep->value, ':');
d1784 1
a1784 1
        if (my_state_is_wont(TELOPT_NEW_ENVIRON)
d1897 2
a1898 2
	auth_enable P((int)),
	auth_disable P((int)),
d1937 6
d1946 1
a1946 1
        fprintf(stderr, "'%s': unknown argument ('auth ?' for help).\n",
d1948 1
a1948 1
        return 0;
d1951 1
a1951 1
        fprintf(stderr, "'%s': ambiguous argument ('auth ?' for help).\n",
d1953 1
a1953 1
        return 0;
d2099 1
a2099 1
    bzero((char *)&sin, sizeof(sin));
d2117 1
a2117 1
	if (isprefix(*argv, "?"))
d2182 1
a2182 1
		memcpy((caddr_t)&sin.sin_addr,
d2185 1
a2185 1
		memcpy((caddr_t)&sin.sin_addr, host->h_addr, host->h_length);
d2192 1
a2192 1
	        setuid(getuid());
d2212 1
a2212 1
	        setuid(getuid());
d2226 1
a2226 1
	        setuid(getuid());
d2253 1
a2253 1
		tos = IPTOS_LOWDELAY;
d2276 1
a2276 1
		memcpy((caddr_t)&sin.sin_addr, 
d2454 1
a2454 1
	        printf("%s\n", line);
d2657 1
a2657 1
 * 
d2660 1
a2660 1
 *	
d2754 1
a2754 1
			memcpy((caddr_t)&sin_addr,
d2757 1
a2757 1
			memcpy((caddr_t)&sin_addr, host->h_addr, host->h_length);
d2763 1
a2763 1
		memcpy(lsrp, (char *)&sin_addr, 4);
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
static char *rcsid = "$Id: commands.c,v 1.8 1995/01/03 06:24:48 hpeyerl Exp $";
d2102 1
a2102 1
	if (isprefix(*argv, "help") || isprefix(*argv, "?"))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

