head	1.30;
access;
symbols
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.14
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.12
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.10
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.8
	OPENBSD_5_0:1.16.0.6
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.18
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.16
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.14
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.12
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.10
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.8
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.12
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.10
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.8
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2015.11.24.05.06.24;	author beck;	state Exp;
branches;
next	1.29;
commitid	UPNmjZ9lwrIxCZws;

1.29
date	2014.09.09.03.41.08;	author guenther;	state Exp;
branches;
next	1.28;
commitid	VR4fCtOZMbshOip1;

1.28
date	2014.07.22.07.30.24;	author jsg;	state Exp;
branches;
next	1.27;
commitid	5F2TXUtxGWuYgYJc;

1.27
date	2014.07.20.12.08.55;	author guenther;	state Exp;
branches;
next	1.26;
commitid	S3moNyJOYK9CLzJu;

1.26
date	2014.07.20.10.55.26;	author guenther;	state Exp;
branches;
next	1.25;
commitid	KvN9Bh2AXHiOi5nI;

1.25
date	2014.07.20.10.18.10;	author guenther;	state Exp;
branches;
next	1.24;
commitid	g3VtcxajtWcT7VuD;

1.24
date	2014.07.20.09.31.25;	author guenther;	state Exp;
branches;
next	1.23;
commitid	sgiDhU5W6KOMYLqU;

1.23
date	2014.07.20.08.56.47;	author guenther;	state Exp;
branches;
next	1.22;
commitid	uvklKjlkNqUA10lW;

1.22
date	2014.07.20.08.12.45;	author guenther;	state Exp;
branches;
next	1.21;
commitid	qbZdS8s4KEeVt81G;

1.21
date	2014.07.20.07.35.04;	author guenther;	state Exp;
branches;
next	1.20;
commitid	2cOmMOs302nEGrCZ;

1.20
date	2014.07.20.05.22.02;	author guenther;	state Exp;
branches;
next	1.19;
commitid	mkPeU1MBN7ewMEUq;

1.19
date	2014.07.20.03.00.31;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	HAasfAU6uciboOsY;

1.18
date	2014.07.19.23.50.38;	author guenther;	state Exp;
branches;
next	1.17;
commitid	J1fNmylmVMpKGeua;

1.17
date	2013.10.26.21.33.29;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.05.00.20.46;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.27.15.46.42;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.03.23.36.14;	author pvalchev;	state Exp;
branches
	1.13.2.1
	1.13.4.1;
next	1.12;

1.12
date	2003.12.28.21.53.01;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.03.02.56.18;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.25.10.52.32;	author hin;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.22.13.49.28;	author hin;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.17.17.20.49;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.04.15.21.02;	author pvalchev;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.25.10.24.25;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.22.11.03.38;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	98.03.12.17.31.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.03.12.04.57.31;	author art;	state Exp;
branches;
next	1.2;

1.2
date	96.03.27.19.33.01;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.14;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.14;	author deraadt;	state Exp;
branches;
next	;

1.13.2.1
date	2005.03.29.20.20.10;	author brad;	state Exp;
branches;
next	;

1.13.4.1
date	2005.03.29.19.49.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Don't support repeated connections - avoids pledge problems
ok deraadt@@, "god please commit before I see any more" tedu@@
@
text
@/*	$OpenBSD: externs.h,v 1.29 2014/09/09 03:41:08 guenther Exp $	*/
/* $KTH: externs.h,v 1.16 1997/11/29 02:28:35 joda Exp $ */

/*
 * Copyright (c) 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)externs.h	8.3 (Berkeley) 5/30/95
 */

#define	SUBBUFSIZE	256

extern int
    autologin,		/* Autologin enabled */
    skiprc,		/* Don't process the ~/.telnetrc file */
    eight,		/* use eight bit mode (binary in and/or out */
    binary,
    family,		/* address family of peer */
    flushout,		/* flush output */
    connections,
    connected,		/* Are we connected to the other side? */
    globalmode,		/* Mode tty should be in */
    telnetport,		/* Are we connected to the telnet port? */
    localflow,		/* Flow control handled locally */
    restartany,		/* If flow control, restart output on any character */
    localchars,		/* we recognize interrupt/quit */
    donelclchars,	/* the user has set "localchars" */
    showoptions,
    net,		/* Network file descriptor */
    tin,		/* Terminal input file descriptor */
    tout,		/* Terminal output file descriptor */
    crlf,		/* Should '\r' be mapped to <CR><LF> (or <CR><NUL>)? */
    autoflush,		/* flush output when interrupting? */
    autosynch,		/* send interrupt characters with SYNCH? */
    SYNCHing,		/* Is the stream in telnet SYNCH mode? */
    donebinarytoggle,	/* the user has put us in binary */
    dontlecho,		/* do we suppress local echoing right now? */
    crmod,
    netdata,		/* Print out network data flow */
    prettydump,		/* Print "netdata" output in user readable format */
    termdata,		/* Print out terminal data flow */
    resettermname,
    linemode,
    kludgelinemode,
    want_status_response,
    debug;		/* Debug level */

extern cc_t escape;	/* Escape to command mode */
extern cc_t rlogin;	/* Rlogin mode escape character */
#ifdef	KLUDGELINEMODE
extern cc_t echoc;	/* Toggle local echoing */
#endif

extern char
    *prompt;		/* Prompt for command. */

extern char
    doopt[],
    dont[],
    will[],
    wont[],
    will_wont_resp[],
    do_dont_resp[],
    options[],		/* All the little options */
    *hostname;		/* Who are we connected to? */

extern int	rtableid;	/* routing table to use */

/*
 * We keep track of each side of the option negotiation.
 */

#define	MY_STATE_WILL		0x01
#define	MY_WANT_STATE_WILL	0x02
#define	MY_STATE_DO		0x04
#define	MY_WANT_STATE_DO	0x08

/*
 * Macros to check the current state of things
 */

#define	my_state_is_do(opt)		(options[opt]&MY_STATE_DO)
#define	my_state_is_will(opt)		(options[opt]&MY_STATE_WILL)
#define my_want_state_is_do(opt)	(options[opt]&MY_WANT_STATE_DO)
#define my_want_state_is_will(opt)	(options[opt]&MY_WANT_STATE_WILL)

#define	my_state_is_dont(opt)		(!my_state_is_do(opt))
#define	my_state_is_wont(opt)		(!my_state_is_will(opt))
#define my_want_state_is_dont(opt)	(!my_want_state_is_do(opt))
#define my_want_state_is_wont(opt)	(!my_want_state_is_will(opt))

#define	set_my_state_do(opt)		{options[opt] |= MY_STATE_DO;}
#define	set_my_state_will(opt)		{options[opt] |= MY_STATE_WILL;}
#define	set_my_want_state_do(opt)	{options[opt] |= MY_WANT_STATE_DO;}
#define	set_my_want_state_will(opt)	{options[opt] |= MY_WANT_STATE_WILL;}

#define	set_my_state_dont(opt)		{options[opt] &= ~MY_STATE_DO;}
#define	set_my_state_wont(opt)		{options[opt] &= ~MY_STATE_WILL;}
#define	set_my_want_state_dont(opt)	{options[opt] &= ~MY_WANT_STATE_DO;}
#define	set_my_want_state_wont(opt)	{options[opt] &= ~MY_WANT_STATE_WILL;}

/*
 * Make everything symmetrical
 */

#define	HIS_STATE_WILL			MY_STATE_DO
#define	HIS_WANT_STATE_WILL		MY_WANT_STATE_DO
#define HIS_STATE_DO			MY_STATE_WILL
#define HIS_WANT_STATE_DO		MY_WANT_STATE_WILL

#define	his_state_is_do			my_state_is_will
#define	his_state_is_will		my_state_is_do
#define his_want_state_is_do		my_want_state_is_will
#define his_want_state_is_will		my_want_state_is_do

#define	his_state_is_dont		my_state_is_wont
#define	his_state_is_wont		my_state_is_dont
#define his_want_state_is_dont		my_want_state_is_wont
#define his_want_state_is_wont		my_want_state_is_dont

#define	set_his_state_do		set_my_state_will
#define	set_his_state_will		set_my_state_do
#define	set_his_want_state_do		set_my_want_state_will
#define	set_his_want_state_will		set_my_want_state_do

#define	set_his_state_dont		set_my_state_wont
#define	set_his_state_wont		set_my_state_dont
#define	set_his_want_state_dont		set_my_want_state_wont
#define	set_his_want_state_wont		set_my_want_state_dont


extern jmp_buf
    peerdied,
    toplevel;		/* For error conditions. */

/* commands.c */

struct	env_lst *env_define (const char *, const char *);
void	env_init (void);
char	*env_default(int init, int welldefined);
char	*env_getvalue(const char *var, int exported_only);

void set_escape_char(char *s);

#ifdef SIGINFO
void ayt_status(int sig);
#endif
int tn(int argc, char **argv);
void command(int top, char *tbuf, int cnt);

/* main.c */

void tninit(void);

/* network.c */

void init_network(void);
int stilloob(void);
void setneturg(void);
int netflush(void);

/* sys_bsd.c */

void init_sys(void);
int TerminalSpecialChars(int c);
void TerminalDefaultChars(void);
cc_t *tcval(int func);
void TerminalSpeeds(long *input_speed, long *output_speed);
int TerminalWindowSize(long *rows, long *cols);
void TerminalNewMode(int);
void TerminalSaveState(void);
void sys_telnet_init(void);
int process_rings(int netin, int netout, int netex, int ttyin, int ttyout,
		  int poll);

/* telnet.c */

void init_telnet(void);

void tel_leave_binary(int rw);
void tel_enter_binary(int rw);
int opt_welldefined(const char *ep);
void telnet(char *);
int telrcv(void);
int rlogin_susp(void);
void intp(void);
void sendbrk(void);
void sendabort(void);
void sendsusp(void);
void sendeof(void);
void sendayt(void);
void sendnaws(void);

void xmitAO(void);
void xmitEL(void);
void xmitEC(void);

void     send_do (int, int);
void     send_dont (int, int);
void     send_will (int, int);
void     send_wont (int, int);

void     lm_mode (unsigned char *, int, int);

void     slcstate (void);
void     slc_mode_export (int);
void     slc_mode_import (int);
void     slc_check (void);

void     env_opt_start_info (void);
void     env_opt_add (char *);
void     env_opt_end (int);

int get_status (void);
int dosynch (void);

cc_t *tcval (int);

__dead void quit(void);

/* genget.c */

char	**genget(char *name, char **table, int stlen);
int	isprefix(char *s1, char *s2);
int	Ambiguous(void *s);

/* terminal.c */

void init_terminal(void);
int ttyflush(int drop);
int getconnmode(void);
void setconnmode(int);
void setcommandmode(void);

/* utilities.c */

extern char NetTraceFile[];
void SetNetTrace(const char *file);
void Dump(char direction, unsigned char *buffer, int length);
void printoption(char *direction, int cmd, int option);
void optionstatus(void);
void printsub(char direction, unsigned char *pointer, int length);
void EmptyTerminal(void);
void SetForExit(void);
__dead void Exit(int returnCode);
__dead void ExitString(char *string, int returnCode);

extern struct	termios new_tc;

# define termEofChar		new_tc.c_cc[VEOF]
# define termEraseChar		new_tc.c_cc[VERASE]
# define termIntChar		new_tc.c_cc[VINTR]
# define termKillChar		new_tc.c_cc[VKILL]
# define termQuitChar		new_tc.c_cc[VQUIT]
# define termSuspChar		new_tc.c_cc[VSUSP]

# if	defined(VFLUSHO) && !defined(VDISCARD)
#  define VDISCARD VFLUSHO
# endif
# ifndef	VDISCARD
extern cc_t termFlushChar;
# else
#  define termFlushChar		new_tc.c_cc[VDISCARD]
# endif
# ifndef VWERASE
extern cc_t termWerasChar;
# else
#  define termWerasChar		new_tc.c_cc[VWERASE]
# endif
# ifndef	VREPRINT
extern cc_t termRprntChar;
# else
#  define termRprntChar		new_tc.c_cc[VREPRINT]
# endif
# ifndef	VLNEXT
extern cc_t termLiteralNextChar;
# else
#  define termLiteralNextChar	new_tc.c_cc[VLNEXT]
# endif
# ifndef	VSTART
extern cc_t termStartChar;
# else
#  define termStartChar		new_tc.c_cc[VSTART]
# endif
# ifndef	VSTOP
extern cc_t termStopChar;
# else
#  define termStopChar		new_tc.c_cc[VSTOP]
# endif
# ifndef	VEOL
extern cc_t termForw1Char;
# else
#  define termForw1Char		new_tc.c_cc[VEOL]
# endif
# ifndef	VEOL2
extern cc_t termForw2Char;
# else
#  define termForw2Char		new_tc.c_cc[VEOL]
# endif
# ifndef	VSTATUS
extern cc_t termAytChar;
#else
#  define termAytChar		new_tc.c_cc[VSTATUS]
#endif

/* Ring buffer structures which are shared */

extern Ring
    netoring,
    netiring,
    ttyoring,
    ttyiring;
@


1.29
log
@Eliminate a pile of casts that were superfluous or wrong, or that were
the result of bad type choices, particularly (unsigned char *) vs
(const char *).  Also, use reallocarray().
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.28 2014/07/22 07:30:24 jsg Exp $	*/
d44 1
@


1.28
log
@use ansi style function declarations
with suggestions from and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.27 2014/07/20 12:08:55 guenther Exp $	*/
a154 5
extern unsigned char
    NetTraceFile[];	/* Name of file where debugging output goes */
extern void
    SetNetTrace (char *);	/* Function to change where debugging goes */

d161 4
a164 4
struct env_lst *env_define (unsigned char *, unsigned char *);
void env_init (void);
unsigned char * env_default(int init, int welldefined);
unsigned char * env_getvalue(unsigned char *var, int exported_only);
d205 1
a205 1
int opt_welldefined(char *ep);
d234 1
a234 1
void     env_opt_add (unsigned char *);
a236 3
unsigned char     *env_default (int, int);
unsigned char     *env_getvalue (unsigned char *, int);

d260 2
a261 1
void SetNetTrace(char *file);
@


1.27
log
@Eliminate silly call() routine that fakes up internal calls as if
the user typed in undocumented arguments by splitting two functions
and doing normal (shock!) C calls.

Move extern declarations to externs.h
Eliminate another function cast
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.26 2014/07/20 10:55:26 guenther Exp $	*/
d272 1
a272 1
void printsub(int direction, unsigned char *pointer, int length);
@


1.26
log
@Mark a slurry of functions as static
Eliminate two more trivial wrappers
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.25 2014/07/20 10:18:10 guenther Exp $	*/
d65 4
d85 2
d174 1
a174 1
void ayt_status(void);
@


1.25
log
@Kill lint comments; mark ExitString() as __dead
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.24 2014/07/20 09:31:25 guenther Exp $	*/
a160 1
struct env_lst *env_find(unsigned char *var);
a161 5
void env_undefine (unsigned char *);
void env_export (unsigned char *);
void env_unexport (unsigned char *);
void env_send (unsigned char *);
void env_list (void);
a165 1
unsigned long sourceroute(char *arg, char **cpp, int *lenp);
d192 3
a194 2
int NetClose(int fd);
void NetNonblockingIO(int fd, int onoff);
d205 1
d214 1
a219 18

void     Dump (char, unsigned char *, int);
void     printoption (char *, int, int);
void     sendnaws (void);
void     setconnmode (int);
void     setcommandmode (void);
void     setneturg (void);
void     sys_telnet_init (void);
void     telnet (char *);
void     tel_enter_binary (int);
void     TerminalNewMode (int);
void     TerminalRestoreState (void);
void     TerminalSaveState (void);
void     tninit (void);
void     willoption (int);
void     wontoption (int);


a224 4
void     lm_will (unsigned char *, int);
void     lm_wont (unsigned char *, int);
void     lm_do (unsigned char *, int);
void     lm_dont (unsigned char *, int);
a226 1
void     slc_init (void);
a229 3
void     slc_import (int);
void     slc_export (void);
void     slc (unsigned char *, int);
a230 4
void     slc_start_reply (void);
void     slc_add_reply (unsigned char, unsigned char, cc_t);
void     slc_end_reply (void);
int	 slc_update (void);
a231 2
void     env_opt (unsigned char *, int);
void     env_opt_start (void);
d257 2
@


1.24
log
@VSUSP and SIGTSTP are required by POSIX
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.23 2014/07/20 08:56:47 guenther Exp $	*/
a182 1
void usage(void);
d304 1
a304 1
void ExitString(char *string, int returnCode);
@


1.23
log
@Add prototypes to some function callbacks and fix the type errors that
this reveals.
Make NetTrace static to utilities.c
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.22 2014/07/20 08:12:45 guenther Exp $	*/
d314 1
a315 5
# ifndef	VSUSP
extern cc_t termSuspChar;
# else
#  define termSuspChar		new_tc.c_cc[VSUSP]
# endif
@


1.22
log
@More encryption tentacles: intr_happened and intr_waiting vanish
Push more includes into .c files
Make ring.c only need ring.h
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.21 2014/07/20 07:35:04 guenther Exp $	*/
a148 2
extern FILE
    *NetTrace;		/* Where debugging output goes */
d256 1
a256 1
void     slc_mode_export (void);
d281 1
a281 1
__dead int quit(void);
@


1.21
log
@Eliminate trivial wrappers TerminalWrite() and TerminalRead()
Replace TerminalFlushOutput() with tcflush().
Replace TerminalAutoFlush() with check of tty's NOFLSH flag as
	documented in the manpage.
Push <netdb.h> into .c files
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.20 2014/07/20 05:22:02 guenther Exp $	*/
a65 2

extern volatile sig_atomic_t intr_happened, intr_waiting;	/* for interrupt handling */
@


1.20
log
@Simplify #includes, start pushing them into the .c files, eliminate
extern declarations from .c files that duplicate those in .h files,
start marking functions with __dead
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.19 2014/07/20 03:00:31 deraadt Exp $	*/
a198 3
int TerminalWrite(char *buf, int n);
int TerminalRead(unsigned char *buf, int n);
int TerminalAutoFlush(void);
a199 2
void TerminalFlushOutput(void);
void TerminalSaveState(void);
a200 1
void TerminalNewMode(int f);
a238 1
void     TerminalFlushOutput (void);
@


1.19
log
@remove a variable called wantencryption.
hahahahahahahahahha.  OK, I'm done.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.18 2014/07/19 23:50:38 guenther Exp $	*/
d292 1
a292 1
int quit (void);
d315 1
a315 1
void Exit(int returnCode);
@


1.18
log
@Flense the telnet code base of unwanted ifdefs: authentication/encryption
tn3270, sgtty, pre-POSIX and other ancient system support, etc.  Brings up
to date the manpage with what we support.

ok matthieu@@ beck@@ jmc@@ millert@@ deraadt@@ okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.17 2013/10/26 21:33:29 sthen Exp $	*/
a51 1
    wantencryption,	/* User has requested encryption */
@


1.17
log
@Only use setsockopt(..SO_RTABLE..) if the -V flag is given to nc/telnet,
same style as traceroute6 (change to int and use -1 as a flag, so rtable 0
can still be used as an explicit parameter).
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.16 2010/07/03 04:44:51 guenther Exp $	*/
a34 15
#ifndef	BSD
# define BSD 43
#endif

#ifndef	_POSIX_VDISABLE
# ifdef sun
#  include <sys/param.h>	/* pick up VDISABLE definition, mayby */
# endif
# ifdef VDISABLE
#  define _POSIX_VDISABLE VDISABLE
# else
#  define _POSIX_VDISABLE ((cc_t)'\377')
# endif
#endif

a46 1
    In3270,            /* Are we in 3270 mode? */
a64 4
#if    defined(TN3270)
    cursesdata,		/* Print out curses data flow */
    apitrace,		/* Trace API transactions */
#endif /* defined(TN3270) */
a85 4
#if	defined(ENCRYPTION)
extern void (*encrypt_output) (unsigned char *, int);
extern int (*decrypt_input) (int);
#endif
a162 11
/* authenc.c */

#if	defined(AUTHENTICATION) || defined(ENCRYPTION)
int net_write(unsigned char *str, int len);
void net_encrypt(void);
int telnet_spin(void);
char *telnet_getenv(const char *val);
char *telnet_gets(char *prompt, char *result, int length, int echo);
int Scheduler(int block);
#endif

a178 19
#if	defined(AUTHENTICATION)
int auth_enable (char *);
int auth_disable (char *);
int auth_status (void);
#endif

#if defined(ENCRYPTION)
int 	EncryptEnable (char *, char *);
int 	EncryptDisable (char *, char *);
int 	EncryptType (char *, char *);
int 	EncryptStart (char *);
int 	EncryptStartInput (void);
int 	EncryptStartOutput (void);
int 	EncryptStop (char *);
int 	EncryptStopInput (void);
int 	EncryptStopOutput (void);
int 	EncryptStatus (void);
#endif

a238 1
void     printsub (int, unsigned char *, int);
d295 6
a308 1
int SetSockOpt(int fd, int level, int option, int yesno);
a387 24

/* Tn3270 section */
#if    defined(TN3270)

extern int
    HaveInput,         /* Whether an asynchronous I/O indication came in */
    noasynchtty,       /* Don't do signals on I/O (SIGURG, SIGIO) */
    noasynchnet,       /* Don't do signals on I/O (SIGURG, SIGIO) */
    sigiocount,                /* Count of SIGIO receptions */
    shell_active;      /* Subshell is active */

extern char
    *Ibackp,           /* Oldest byte of 3270 data */
    Ibuf[],            /* 3270 buffer */
    *Ifrontp,          /* Where next 3270 byte goes */
    tline[200],
    *transcom;         /* Transparent command */

extern int
    settranscom(int, char**);

extern void
    inputAvailable(int);
#endif /* defined(TN3270) */
@


1.16
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.15 2009/06/05 00:20:46 claudio Exp $	*/
d111 1
a111 1
extern u_int	rtableid;	/* routing table to use */
@


1.15
log
@Last but not least. Telnet -V rdomain to connect to systems in other routing
domains.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.14 2005/02/27 15:46:42 otto Exp $	*/
d111 1
a111 1
extern u_int	rdomain;	/* routing domain to use */
@


1.14
log
@- only send exported vars (based on a diff from Solar Designer)
- fix some buffer overflows (also some Solar Designer input)

ok deraadt@@ cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.13 2004/01/03 23:36:14 pvalchev Exp $	*/
d110 2
@


1.13
log
@missing proto; ok hin
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.12 2003/12/28 21:53:01 otto Exp $	*/
d207 1
a207 1
unsigned char * env_getvalue(unsigned char *var);
d339 1
a339 1
unsigned char     *env_getvalue (unsigned char *);
@


1.13.2.1
log
@MFC:
Fix by otto@@

- only send exported vars (based on a diff from Solar Designer)
- fix some buffer overflows (also some Solar Designer input)
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.13 2004/01/03 23:36:14 pvalchev Exp $	*/
d207 1
a207 1
unsigned char * env_getvalue(unsigned char *var, int exported_only);
d339 1
a339 1
unsigned char     *env_getvalue (unsigned char *, int);
@


1.13.4.1
log
@MFC:
Fix by otto@@

- only send exported vars (based on a diff from Solar Designer)
- fix some buffer overflows (also some Solar Designer input)
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.13 2004/01/03 23:36:14 pvalchev Exp $	*/
d207 1
a207 1
unsigned char * env_getvalue(unsigned char *var, int exported_only);
d339 1
a339 1
unsigned char     *env_getvalue (unsigned char *, int);
@


1.12
log
@Introduce -4 and -6: options to force usage of IPv4 or IPv6 only.
From PR 1974.

ok henning@@ jose@@
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.11 2003/06/03 02:56:18 millert Exp $	*/
d193 1
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.10 2002/03/25 10:52:32 hin Exp $	*/
d57 1
@


1.10
log
@Todd Miller pointed this out to me:

    You really want to use 'volatile sig_atomic_t' not just sig_atomic_t
    for flags set in signal handlers.  Without the volatile gcc may
    stick the value in a register but update the on-stack copy in the
    signal handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.9 2002/03/22 13:49:28 hin Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@Telnet encryption warning messages, taken from kth-krb4-1.1.1.

(krb4-1.1.1 will be imported after release)

Noone bothered to look at this, but I've used this for a couple of weeks,
and i really want this to go in before release.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.8 2002/02/17 17:20:49 millert Exp $	*/
d91 1
a91 1
extern sig_atomic_t intr_happened, intr_waiting;	/* for interrupt handling */
@


1.8
log
@telnet used a P macro instead of __P -- g/c that too.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.7 2001/07/04 15:21:02 pvalchev Exp $	*/
d71 1
d90 2
@


1.7
log
@symmetrical, not symetrical
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.6 2001/05/25 10:24:25 hin Exp $	*/
d454 1
a454 1
    settranscom P((int, char**));
d457 1
a457 1
    inputAvailable P((int));
@


1.6
log
@KerberosV support from Heimdal.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.5 2001/01/22 11:03:38 fgsch Exp $	*/
d145 1
a145 1
 * Make everything symetrical
@


1.5
log
@make sizeof tline doable; bad aaron.
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.4 1998/03/12 17:31:32 deraadt Exp $	*/
d191 1
a191 1
char *telnet_getenv(char *val);
d290 1
a290 1
void     printsub (char, unsigned char *, int);
d360 1
a360 1
void printsub(char direction, unsigned char *pointer, int length);
@


1.4
log
@repair tn3270
@
text
@d1 1
a1 1
/*	$OpenBSD: externs.h,v 1.3 1998/03/12 04:57:31 art Exp $	*/
d450 1
a450 1
    tline[],
@


1.3
log
@encryption support from kth-krb 0.9.8 (kerberos only)
plus some tweaks for better binary/8-bit support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d83 4
d436 23
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d2 1
a2 1
/*	$NetBSD: externs.h,v 1.8 1996/02/28 21:03:58 thorpej Exp $	*/
d36 1
a36 1
 *	from: @@(#)externs.h	8.3 (Berkeley) 5/30/95
a42 51
/*
 * ucb stdio.h defines BSD as something wierd
 */
#if defined(sun) && defined(__svr4__)
#define BSD 43
#endif

#ifndef	USE_TERMIO
# if BSD > 43 || defined(SYSV_TERMIO)
#  define USE_TERMIO
# endif
#endif

#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>
#if defined(CRAY) && !defined(NO_BSD_SETJMP)
#include <bsdsetjmp.h>
#endif
#ifndef	FILIO_H
#include <sys/ioctl.h>
#else
#include <sys/filio.h>
#endif
#ifdef CRAY
# include <errno.h>
#endif /* CRAY */
#ifdef	USE_TERMIO
# ifndef	VINTR
#  ifdef SYSV_TERMIO
#   include <sys/termio.h>
#  else
#   include <sys/termios.h>
#   define termio termios
#  endif
# endif
#endif
#if defined(NO_CC_T) || !defined(USE_TERMIO)
# if !defined(USE_TERMIO)
typedef char cc_t;
# else
typedef unsigned char cc_t;
# endif
#endif

#ifndef	NO_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

a55 7
#ifndef CRAY
extern int errno;		/* outside this world */
#endif /* !CRAY */

#include <sys/cdefs.h>
#define P __P

d60 1
a63 1
    In3270,		/* Are we in 3270 mode? */
d65 1
a82 5
#if	defined(unix)
#if	defined(TN3270)
    cursesdata,		/* Print out curses data flow */
    apitrace,		/* Trace API transactions */
#endif	/* defined(TN3270) */
d84 1
a84 3
#endif	/* defined(unix) */
    debug,		/* Debug level */
    clienteof;		/* Client received EOF */
d102 4
d175 1
a175 1
    SetNetTrace P((char *));	/* Function to change where debugging goes */
d181 1
a181 105
extern void
    command P((int, char *, int)),
    Dump P((int, unsigned char *, int)),
    init_3270 P((void)),
    printoption P((char *, int, int)),
    printsub P((int, unsigned char *, int)),
    sendnaws P((void)),
    setconnmode P((int)),
    setcommandmode P((void)),
    setneturg P((void)),
    sys_telnet_init P((void)),
    telnet P((char *)),
    tel_enter_binary P((int)),
    TerminalFlushOutput P((void)),
    TerminalNewMode P((int)),
    TerminalRestoreState P((void)),
    TerminalSaveState P((void)),
    tninit P((void)),
    upcase P((char *)),
    willoption P((int)),
    wontoption P((int));

extern void
    send_do P((int, int)),
    send_dont P((int, int)),
    send_will P((int, int)),
    send_wont P((int, int));

extern void
    lm_will P((unsigned char *, int)),
    lm_wont P((unsigned char *, int)),
    lm_do P((unsigned char *, int)),
    lm_dont P((unsigned char *, int)),
    lm_mode P((unsigned char *, int, int));

extern void
    slc_init P((void)),
    slcstate P((void)),
    slc_mode_export P((void)),
    slc_mode_import P((int)),
    slc_import P((int)),
    slc_export P((void)),
    slc P((unsigned char *, int)),
    slc_check P((void)),
    slc_start_reply P((void)),
    slc_add_reply P((int, int, int)),
    slc_end_reply P((void));
extern int
    slc_update P((void));

extern void
    env_opt P((unsigned char *, int)),
    env_opt_start P((void)),
    env_opt_start_info P((void)),
    env_opt_add P((unsigned char *)),
    env_opt_end P((int));

extern unsigned char
    *env_default P((int, int)),
    *env_getvalue P((unsigned char *));

extern int
    get_status P((void)),
    dosynch P((void));

extern cc_t
    *tcval P((int));

#ifndef	USE_TERMIO

extern struct	tchars ntc;
extern struct	ltchars nltc;
extern struct	sgttyb nttyb;

# define termEofChar		ntc.t_eofc
# define termEraseChar		nttyb.sg_erase
# define termFlushChar		nltc.t_flushc
# define termIntChar		ntc.t_intrc
# define termKillChar		nttyb.sg_kill
# define termLiteralNextChar	nltc.t_lnextc
# define termQuitChar		ntc.t_quitc
# define termSuspChar		nltc.t_suspc
# define termRprntChar		nltc.t_rprntc
# define termWerasChar		nltc.t_werasc
# define termStartChar		ntc.t_startc
# define termStopChar		ntc.t_stopc
# define termForw1Char		ntc.t_brkc
extern cc_t termForw2Char;
extern cc_t termAytChar;

# define termEofCharp		(cc_t *)&ntc.t_eofc
# define termEraseCharp		(cc_t *)&nttyb.sg_erase
# define termFlushCharp		(cc_t *)&nltc.t_flushc
# define termIntCharp		(cc_t *)&ntc.t_intrc
# define termKillCharp		(cc_t *)&nttyb.sg_kill
# define termLiteralNextCharp	(cc_t *)&nltc.t_lnextc
# define termQuitCharp		(cc_t *)&ntc.t_quitc
# define termSuspCharp		(cc_t *)&nltc.t_suspc
# define termRprntCharp		(cc_t *)&nltc.t_rprntc
# define termWerasCharp		(cc_t *)&nltc.t_werasc
# define termStartCharp		(cc_t *)&ntc.t_startc
# define termStopCharp		(cc_t *)&ntc.t_stopc
# define termForw1Charp		(cc_t *)&ntc.t_brkc
# define termForw2Charp		(cc_t *)&termForw2Char
# define termAytCharp		(cc_t *)&termAytChar
d183 178
a360 1
# else
d362 1
a362 1
extern struct	termio new_tc;
a423 37
# if !defined(CRAY) || defined(__STDC__)
#  define termEofCharp		&termEofChar
#  define termEraseCharp	&termEraseChar
#  define termIntCharp		&termIntChar
#  define termKillCharp		&termKillChar
#  define termQuitCharp		&termQuitChar
#  define termSuspCharp		&termSuspChar
#  define termFlushCharp	&termFlushChar
#  define termWerasCharp	&termWerasChar
#  define termRprntCharp	&termRprntChar
#  define termLiteralNextCharp	&termLiteralNextChar
#  define termStartCharp	&termStartChar
#  define termStopCharp		&termStopChar
#  define termForw1Charp	&termForw1Char
#  define termForw2Charp	&termForw2Char
#  define termAytCharp		&termAytChar
# else
	/* Work around a compiler bug */
#  define termEofCharp		0
#  define termEraseCharp	0
#  define termIntCharp		0
#  define termKillCharp		0
#  define termQuitCharp		0
#  define termSuspCharp		0
#  define termFlushCharp	0
#  define termWerasCharp	0
#  define termRprntCharp	0
#  define termLiteralNextCharp	0
#  define termStartCharp	0
#  define termStopCharp		0
#  define termForw1Charp	0
#  define termForw2Charp	0
#  define termAytCharp		0
# endif
#endif


a431 23
/* Tn3270 section */
#if	defined(TN3270)

extern int
    HaveInput,		/* Whether an asynchronous I/O indication came in */
    noasynchtty,	/* Don't do signals on I/O (SIGURG, SIGIO) */
    noasynchnet,	/* Don't do signals on I/O (SIGURG, SIGIO) */
    sigiocount,		/* Count of SIGIO receptions */
    shell_active;	/* Subshell is active */

extern char
    *Ibackp,		/* Oldest byte of 3270 data */
    Ibuf[],		/* 3270 buffer */
    *Ifrontp,		/* Where next 3270 byte goes */
    tline[],
    *transcom;		/* Transparent command */

extern int
    settranscom P((int, char**));

extern void
    inputAvailable P((int));
#endif	/* defined(TN3270) */
@


1.1
log
@Initial revision
@
text
@d1 3
d36 1
a36 2
 *	from: @@(#)externs.h	8.1 (Berkeley) 6/6/93
 *	$Id: externs.h,v 1.5 1995/03/17 18:03:06 mycroft Exp $
d90 2
a92 1
#include <strings.h>
d111 2
a112 7
#if	!defined(P)
# ifdef	__STDC__
#  define	P(x)	x
# else
#  define	P(x)	()
# endif
#endif
d121 1
a121 1
    In3270,			/* Are we in 3270 mode? */
d126 1
a126 1
    donelclchars,		/* the user has set "localchars" */
d147 1
a147 1
    debug,			/* Debug level */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

