head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.6
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.8
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.16
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.12
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.10
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.8
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.6
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.16
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.12
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.14
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.10
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.8
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.22
date	2015.10.10.14.23.12;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	cR8N7mATazVezoHi;

1.21
date	2015.01.16.06.40.09;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Uu5nFG3wCl0LACBb;

1.20
date	2014.05.20.01.25.23;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2010.08.22.21.25.37;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.15.22.23.11;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.04.19.30.00;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.04.18.39.57;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.29.17.02.18;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.13.16.55.22;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.14.03.14.06;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.10.23.21.57;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.23.04.10.14;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.17.07.06.39;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.29.18.33.39;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.28.02.36.03;	author form;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.47;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.04.04.56.15;	author jasoni;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.20.17.47.17;	author ericj;	state Exp;
branches;
next	1.4;

1.4
date	96.08.19.14.20.18;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.06.50.16;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.06.34.03;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.05.47.26;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.22
log
@fairly simple pledge to "stdio rpath wpath cpath"
@
text
@/*	$OpenBSD: lndir.c,v 1.21 2015/01/16 06:40:09 deraadt Exp $	*/
/* $XConsortium: lndir.c /main/15 1995/08/30 10:56:18 gildea $ */

/*
 * Create shadow link tree (after X11R4 script of the same name)
 * Mark Reinhold (mbr@@lcs.mit.edu)/3 January 1990
 */

/*
Copyright (c) 1990,  X Consortium

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of the X Consortium shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from the X Consortium.

*/

/* From the original /bin/sh script:

  Used to create a copy of the a directory tree that has links for all
  non-directories (except those named RCS, SCCS or CVS.adm).  If you are
  building the distribution on more than one machine, you should use
  this technique.

  If your master sources are located in /usr/local/src/X and you would like
  your link tree to be in /usr/local/src/new-X, do the following:

	%  mkdir /usr/local/src/new-X
	%  cd /usr/local/src/new-X
	%  lndir ../X
*/

#include <sys/stat.h>

#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

extern char *__progname;

int silent;			/* -silent */
int ignore_links;		/* -ignorelinks */

char *rcurdir;
char *curdir;

int equivalent(char *, char *);
void addexcept(char *);
int dodir(char *, struct stat *, struct stat *, int);
void usage(void);

struct except {
	char *name;
	struct except *next;
};

struct except *exceptions;

int
main(int argc, char *argv[])
{
	struct stat fs, ts;
	char *fn, *tn;

	if (pledge("stdio rpath wpath cpath", NULL) == -1)
		err(1, "pledge");

	while (++argv, --argc) {
		if ((strcmp(*argv, "-silent") == 0) ||
		    (strcmp(*argv, "-s") == 0))
			silent = 1;
		else if ((strcmp(*argv, "-ignorelinks") == 0) ||
		    (strcmp(*argv, "-i") == 0))
			ignore_links = 1;
		else if (strcmp(*argv, "-e") == 0) {
			++argv, --argc;

			if (argc < 2)
				usage();
			addexcept(*argv);
		} else if (strcmp(*argv, "--") == 0) {
			++argv, --argc;
			break;
		} else
			break;
	}

	if (argc < 1 || argc > 2)
		usage();

	fn = argv[0];
	if (argc == 2)
		tn = argv[1];
	else
		tn = ".";

	/* to directory */
	if (stat(tn, &ts) < 0)
		err(1, "%s", tn);
	if (!(S_ISDIR(ts.st_mode)))
		errc(2, ENOTDIR, "%s", tn);
	if (chdir(tn) < 0)
		err(1, "%s", tn);

	/* from directory */
	if (stat(fn, &fs) < 0)
		err(1, "%s", fn);
	if (!(S_ISDIR(fs.st_mode)))
		errc(2, ENOTDIR, "%s", fn);

	exit(dodir(fn, &fs, &ts, 0));
}

int
equivalent(char *lname, char *rname)
{
	char *s, *ns;

	if (strcmp(lname, rname) == 0)
		return(1);
	for (s = lname; *s && (s = strchr(s, '/')); s++) {
		if (s[1] == '/') {
			/* collapse multiple slashes in lname */
			for (ns = s + 1; *ns == '/'; ns++)
				;
			memmove(s + 1, ns, strlen(ns) + 1);
		}
	}
	return (strcmp(lname, rname) == 0);
}

void
addexcept(char *name)
{
	struct except *new;

	new = malloc(sizeof(struct except));
	if (new == NULL)
		err(1, NULL);
	new->name = strdup(name);
	if (new->name == NULL)
		err(1, NULL);

	new->next = exceptions;
	exceptions = new;
}


/*
 * Recursively create symbolic links from the current directory to the "from"
 * directory.  Assumes that files described by fs and ts are directories.
 */
#if 0
	char *fn;		/* name of "from" directory, either absolute or
				   relative to cwd */
	struct stat *fs, *ts;	/* stats for the "from" directory and cwd */
	int rel;		/* if true, prepend "../" to fn before using */
#endif
int
dodir(char *fn, struct stat *fs, struct stat *ts, int rel)
{
	char buf[PATH_MAX + 1], symbuf[PATH_MAX + 1];
	char basesym[PATH_MAX + 1];
	int n_dirs, symlen, basesymlen = -1;
	struct stat sb, sc;
	struct except *cur;
	struct dirent *dp;
	char *ocurdir, *p;
	DIR *df;

	if (fs->st_dev == ts->st_dev && fs->st_ino == ts->st_ino) {
		warnx("%s: From and to directories are identical!", fn);
		return(1);
	}

	if (rel)
		strlcpy(buf, "../", sizeof(buf));
	else
		buf[0] = '\0';
	strlcat(buf, fn, sizeof(buf));

	if (!(df = opendir(buf))) {
		warn("%s: Cannot opendir", buf);
		return(1);
	}

	p = buf + strlen(buf);
	*p++ = '/';
	n_dirs = fs->st_nlink;
	while ((dp = readdir(df))) {
		if (dp->d_namlen == 0 || dp->d_name[dp->d_namlen - 1] == '~' ||
		    strncmp(dp->d_name, ".#", 2) == 0)
			continue;
		for (cur = exceptions; cur != NULL; cur = cur->next) {
			if (!strcmp(dp->d_name, cur->name))
				goto next;	/* can't continue */
		}
		strlcpy(p, dp->d_name, buf + sizeof(buf) - p);

		if (n_dirs > 0) {
			if (stat(buf, &sb) < 0) {
				warn("%s", buf);
				continue;
			}

			if (S_ISDIR(sb.st_mode)) {
				/* directory */
				n_dirs--;
				if (dp->d_name[0] == '.' &&
				    (dp->d_name[1] == '\0' ||
				    (dp->d_name[1] == '.' &&
				    dp->d_name[2] == '\0')))
					continue;
				if (!strcmp(dp->d_name, "RCS"))
					continue;
				if (!strcmp(dp->d_name, "SCCS"))
					continue;
				if (!strcmp(dp->d_name, "CVS"))
					continue;
				if (!strcmp(dp->d_name, "CVS.adm"))
					continue;
				ocurdir = rcurdir;
				rcurdir = buf;
				curdir = silent ? buf : NULL;
				if (!silent)
					printf("%s:\n", buf);
				if (stat(dp->d_name, &sc) < 0 &&
				    errno == ENOENT) {
					if (mkdir(dp->d_name, 0777) < 0 ||
					    stat(dp->d_name, &sc) < 0) {
						warn("%s", dp->d_name);
						curdir = rcurdir = ocurdir;
						continue;
					}
				}
				if (readlink(dp->d_name, symbuf,
				    sizeof(symbuf) - 1) >= 0) {
					fprintf(stderr,
					    "%s: is a link instead of a "
					    "directory\n",
					    dp->d_name);
					curdir = rcurdir = ocurdir;
					continue;
				}
				if (chdir(dp->d_name) < 0) {
					warn("%s", dp->d_name);
					curdir = rcurdir = ocurdir;
					continue;
				}
				dodir(buf, &sb, &sc, (buf[0] != '/'));
				if (chdir("..") < 0)
					err(1, "..");
				curdir = rcurdir = ocurdir;
				continue;
			}
		}

		/* non-directory */
		symlen = readlink(dp->d_name, symbuf, sizeof(symbuf) - 1);
		if (symlen >= 0)
			symbuf[symlen] = '\0';

		/*
		 * The option to ignore links exists mostly because
		 * checking for them slows us down by 10-20%.
		 * But it is off by default because this is a useful check.
		 */
		if (!ignore_links) {
			/* see if the file in the base tree was a symlink */
			basesymlen = readlink(buf, basesym,
			    sizeof(basesym) - 1);
			if (basesymlen >= 0)
				basesym[basesymlen] = '\0';
		}

		if (symlen >= 0) {
			/*
			 * Link exists in new tree.  Print message if
			 * it doesn't match.
			 */
			if (!equivalent(basesymlen >= 0 ? basesym : buf,
			    symbuf))
				fprintf(stderr,"%s: %s\n", dp->d_name, symbuf);
		} else {
			if (symlink(basesymlen >= 0 ? basesym : buf,
			    dp->d_name) < 0)
				warn("%s", dp->d_name);
		}
next:
	;
	}

	closedir(df);
	return (0);
}

void
usage(void)
{
	fprintf(stderr, "usage: %s [-is] [-e exceptfile] fromdir [todir]\n",
	    __progname);
	exit(1);
}
@


1.21
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.20 2014/05/20 01:25:23 guenther Exp $	*/
d87 3
@


1.20
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.19 2010/08/22 21:25:37 tedu Exp $	*/
a49 1
#include <sys/param.h>
d60 1
d182 2
a183 2
	char buf[MAXPATHLEN + 1], symbuf[MAXPATHLEN + 1];
	char basesym[MAXPATHLEN + 1];
@


1.19
log
@small style fixes of no consequnce
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.18 2006/11/15 22:23:11 miod Exp $	*/
d121 1
a121 1
		errx(2, "%s: %s", tn, strerror(ENOTDIR));
d129 1
a129 1
		errx(2, "%s: %s", fn, strerror(ENOTDIR));
@


1.18
log
@err(..., strerror(errno)) is redundant.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.17 2005/10/04 19:30:00 jmc Exp $	*/
d64 2
a65 2
int silent = 0;			/* -silent */
int ignore_links = 0;		/* -ignorelinks */
d80 1
a80 1
struct except *exceptions = (struct except *)NULL;
d149 1
a149 1
	return(strcmp(lname, rname) == 0);
d157 2
a158 2
	new = (struct except *)malloc(sizeof(struct except));
	if (new == (struct except *)NULL)
d161 1
a161 1
	if (new->name == (char *)NULL)
d182 2
a183 1
	char buf[MAXPATHLEN + 1], symbuf[MAXPATHLEN + 1], basesym[MAXPATHLEN + 1];
d230 2
a231 1
				    (dp->d_name[1] == '\0' || (dp->d_name[1] == '.' &&
d247 2
a248 1
				if (stat(dp->d_name, &sc) < 0 && errno == ENOENT) {
d259 2
a260 1
					    "%s: is a link instead of a directory\n",
d286 1
a286 1
		 * But it is off by default because this really is a useful check.
d290 2
a291 1
			basesymlen = readlink(buf, basesym, sizeof(basesym) - 1);
d301 2
a302 1
			if (!equivalent(basesymlen>=0 ? basesym : buf, symbuf))
d305 2
a306 1
			if (symlink(basesymlen>=0 ? basesym : buf, dp->d_name) < 0)
d314 1
a314 1
	return(0);
d320 1
a320 1
	(void)fprintf(stderr, "usage: %s [-is] [-e exceptfile] fromdir [todir]\n",
@


1.17
log
@standard synopsis/usage() and sort options list;
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.16 2005/10/04 18:39:57 matthieu Exp $	*/
d129 1
a129 1
		err(2, "%s: %s", fn, strerror(ENOTDIR));
@


1.16
log
@ignore the .#* files left over by cvs (and emacs). ok deraadt@@, jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.15 2004/06/29 17:02:18 mickey Exp $	*/
d313 1
a313 1
	(void)fprintf(stderr, "usage: %s [-e except] [-si] fromdir [todir]\n",
@


1.15
log
@kill spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.14 2003/05/13 16:55:22 millert Exp $	*/
d210 2
a211 1
		if (dp->d_namlen == 0 || dp->d_name[dp->d_namlen - 1] == '~')
@


1.14
log
@Use dp->d_namlen instead of strlen(dp->d_name) and check for
dp->d_namlen == 0.  Shouldn't be possible but the check prevents
any possibilty of using an array index of -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.13 2003/04/14 03:14:06 millert Exp $	*/
d4 1
a4 1
/* 
d6 1
a6 1
 * Mark Reinhold (mbr@@lcs.mit.edu)/3 January 1990 
d9 1
a9 1
/* 
d62 1
a62 1
extern	char *__progname;
d169 1
a169 1
/* 
d200 1
a200 1
    
d255 1
a255 1
					    "%s: is a link instead of a directory\n", 
d278 1
a278 1
		/* 
@


1.13
log
@More strlcpy/strlcat and use memmove for equivalent() so it is more
readable.  deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.12 2003/04/10 23:21:57 millert Exp $	*/
d210 1
a210 1
		if (dp->d_name[strlen(dp->d_name) - 1] == '~')
d212 2
a213 3
		for (cur = exceptions; cur != (struct except *)NULL;
		    cur = cur->next) {
			if (!strcmp (dp->d_name, cur->name))
@


1.12
log
@Some style from Andrey Matveev
 o avoid including sys/types.h and sys/param.h together
 o sort includes
 o in one place warn(3) -> warnx(3)
 o proper usage() (argument `todir' is optional)

Also, fromdir was marked as optional in the manual--it is not.
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.11 2002/09/23 04:10:14 millert Exp $	*/
d137 1
a137 1
	char *s;
d142 6
a147 2
		while (s[1] == '/')
			strcpy(s+1, s+2);
d149 1
a149 1
	return(!strcmp(lname, rname));
d196 1
a196 1
		strlcpy(buf, "../", sizeof buf);
d199 1
a199 1
	strlcat(buf, fn, sizeof buf);
d217 1
a217 1
		strcpy(p, dp->d_name);
@


1.11
log
@Add missing includes, breaks and semicolons to appease gcc3; David Krause
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.10 2002/06/17 07:06:39 deraadt Exp $	*/
d50 1
a50 3
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
d52 2
a53 1
#include <sys/param.h>
a55 1
#include <dirent.h>
d57 2
d139 1
a139 1
	if (!strcmp(lname, rname))
d155 1
a155 1
		err(1, "addexcept");
d158 1
a158 1
		err(1, "addexcept");
d187 1
a187 1
		warn("%s: From and to directories are identical!", fn);
d309 1
a309 1
	(void)fprintf(stderr, "usage: %s [-e except] [-si] fromdir todir\n",
@


1.10
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.9 2002/05/29 18:33:39 deraadt Exp $	*/
d299 1
@


1.9
log
@strlcat
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.8 2002/03/28 02:36:03 form Exp $	*/
d45 1
a45 1
   	%  mkdir /usr/local/src/new-X
d47 1
a47 1
   	%  lndir ../X
d83 1
a83 3
main (argc, argv)
	int	argc;
	char 	**argv;
d85 1
a86 1
	struct stat fs, ts;
d88 42
a129 43
        while (++argv, --argc) {
                if ((strcmp(*argv, "-silent") == 0)
                    || (strcmp(*argv, "-s") == 0))
                        silent = 1;
                else if ((strcmp(*argv, "-ignorelinks") == 0)
                        || (strcmp(*argv, "-i") == 0))
                        ignore_links = 1;
                else if (strcmp(*argv, "-e") == 0) {
                        ++argv, --argc;

                        if (argc < 2)
                                usage();
                        addexcept(*argv);
                } else if (strcmp(*argv, "--") == 0) {
                        ++argv, --argc;
                        break;
                } else
                        break;
        }

		
    if (argc < 1 || argc > 2)
	usage();

    fn = argv[0];
    if (argc == 2)
	tn = argv[1];
    else
	tn = ".";

    /* to directory */
    if (stat(tn, &ts) < 0)
	err(1, "%s", tn);
    if (!(S_ISDIR(ts.st_mode)))
	errx(2, "%s: %s", tn, strerror(ENOTDIR));
    if (chdir(tn) < 0)
	err(1, "%s", tn);

    /* from directory */
    if (stat(fn, &fs) < 0)
	err(1, "%s", fn);
    if (!(S_ISDIR(fs.st_mode)))
	err(2, "%s: %s", fn, strerror(ENOTDIR));
d131 1
a131 1
    exit(dodir (fn, &fs, &ts, 0));
d135 1
a135 3
equivalent(lname, rname)
    char *lname;
    char *rname;
d137 1
a137 1
    char *s;
d139 7
a145 7
    if (!strcmp(lname, rname))
	return(1);
    for (s = lname; *s && (s = strchr(s, '/')); s++) {
	while (s[1] == '/')
	    strcpy(s+1, s+2);
    }
    return(!strcmp(lname, rname));
d149 1
a149 2
addexcept(name)
    char *name;
d151 8
a158 1
    struct except *new;
d160 2
a161 9
    new = (struct except *)malloc(sizeof(struct except));
    if (new == (struct except *)NULL)
        err(1, "addexcept");
    new->name = strdup(name);
    if (new->name == (char *)NULL)
        err(1, "addexcept");
    
    new->next = exceptions;
    exceptions = new;
d169 1
a169 2
int
dodir(fn, fs, ts, rel)
d174 3
d178 18
a195 22
    DIR *df;
    struct dirent *dp;
    char buf[MAXPATHLEN + 1], *p;
    char symbuf[MAXPATHLEN + 1];
    char basesym[MAXPATHLEN + 1];
    struct stat sb, sc;
    int n_dirs;
    int symlen;
    int basesymlen = -1;
    char *ocurdir;
    struct except *cur;

    if ((fs->st_dev == ts->st_dev) && (fs->st_ino == ts->st_ino)) {
	warn("%s: From and to directories are identical!", fn);
	return(1);
    }

    if (rel)
	strcpy(buf, "../");
    else
	buf[0] = '\0';
    strlcat(buf, fn, sizeof buf);
d197 3
a199 15
    if (!(df = opendir(buf))) {
	warn("%s: Cannot opendir", buf);
	return(1);
    }

    p = buf + strlen(buf);
    *p++ = '/';
    n_dirs = fs->st_nlink;
    while ((dp = readdir(df))) {
	if (dp->d_name[strlen(dp->d_name) - 1] == '~')
	    continue;
	for (cur = exceptions; cur != (struct except *)NULL;
	     cur = cur->next) {
	    if (!strcmp (dp->d_name, cur->name))
	    	goto next;	/* can't continue */
a200 1
	strcpy(p, dp->d_name);
d202 5
a206 31
	if (n_dirs > 0) {
	    if (stat(buf, &sb) < 0) {
		warn("%s", buf);
		continue;
	    }

	    if (S_ISDIR(sb.st_mode)) {
		/* directory */
		n_dirs--;
		if (dp->d_name[0] == '.' &&
		    (dp->d_name[1] == '\0' || (dp->d_name[1] == '.' &&
					       dp->d_name[2] == '\0')))
		    continue;
		if (!strcmp(dp->d_name, "RCS"))
		    continue;
		if (!strcmp(dp->d_name, "SCCS"))
		    continue;
		if (!strcmp(dp->d_name, "CVS"))
		    continue;
		if (!strcmp(dp->d_name, "CVS.adm"))
		    continue;
		ocurdir = rcurdir;
		rcurdir = buf;
		curdir = silent ? buf : NULL;
		if (!silent)
		    printf("%s:\n", buf);
		if ((stat(dp->d_name, &sc) < 0) && (errno == ENOENT)) {
		    if (mkdir(dp->d_name, 0777) < 0 ||
			stat(dp->d_name, &sc) < 0) {
			warn("%s", dp->d_name);
			curdir = rcurdir = ocurdir;
d208 4
a211 1
		    }
d213 55
a267 5
		if (readlink(dp->d_name, symbuf, sizeof(symbuf) - 1) >= 0) {
		    (void)fprintf(stderr, "%s: is a link instead of a directory\n", 
				dp->d_name);
		    curdir = rcurdir = ocurdir;
		    continue;
d269 16
a284 4
		if (chdir(dp->d_name) < 0) {
		    warn("%s", dp->d_name);
		    curdir = rcurdir = ocurdir;
		    continue;
a285 7
		dodir(buf, &sb, &sc, (buf[0] != '/'));
		if (chdir ("..") < 0)
		    err (1, "..");
		curdir = rcurdir = ocurdir;
		continue;
	    }
	}
d287 12
a298 15
	/* non-directory */
	symlen = readlink(dp->d_name, symbuf, sizeof(symbuf) - 1);
	if (symlen >= 0)
	    symbuf[symlen] = '\0';

	/* 
	 * The option to ignore links exists mostly because
	 * checking for them slows us down by 10-20%.
	 * But it is off by default because this really is a useful check.
	 */
	if (!ignore_links) {
	    /* see if the file in the base tree was a symlink */
	    basesymlen = readlink(buf, basesym, sizeof(basesym) - 1);
	    if (basesymlen >= 0)
		basesym[basesymlen] = '\0';
d301 2
a302 13
	if (symlen >= 0) {
	    /* Link exists in new tree.  Print message if it doesn't match. */
	    if (!equivalent(basesymlen>=0 ? basesym : buf, symbuf))
		(void)fprintf(stderr,"%s: %s\n", dp->d_name, symbuf);
	} else {
	    if (symlink(basesymlen>=0 ? basesym : buf, dp->d_name) < 0)
		warn("%s", dp->d_name);
	}
next:
    }

    closedir(df);
    return(0);
d306 1
a306 1
usage()
d309 1
a309 1
		__progname);
@


1.8
log
@Fix err*() usage.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.7 2002/02/16 21:27:47 millert Exp $	*/
d203 1
a203 1
    strcat(buf, fn);
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.6 2001/07/04 04:56:15 jasoni Exp $	*/
d122 1
a122 1
	errx(1, "%s", tn);
d124 1
a124 1
	errx(2, "%s: Not a directory", tn);
d126 1
a126 1
	errx(1, "%s", tn);
d130 1
a130 1
	errx(1, "%s", fn);
d132 1
a132 1
	errx(2, "%s: Not a directory", fn);
d161 1
a161 1
        errx(1, "addexcept");
d164 1
a164 1
        errx(1, "addexcept");
d270 1
a270 1
		    errx (1, "..");
@


1.6
log
@removed unused variable (-Wall cleanup)
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.5 2000/07/20 17:47:17 ericj Exp $	*/
d70 4
a73 4
int equivalent __P((char *, char *));
void addexcept __P((char *));
int dodir __P((char *, struct stat *, struct stat *, int));
void usage __P((void));
@


1.5
log
@
Code cleanup, user errx and warn instead of the hacks already there.
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.4 1996/08/19 14:20:18 niklas Exp $	*/
d87 1
a87 2
	int ch;
    	char *fn, *tn;
@


1.4
log
@We need a malloc prototype for alphas
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.3 1996/08/19 06:50:16 downsj Exp $	*/
d3 5
a7 2
/* Create shadow link tree (after X11R4 script of the same name)
   Mark Reinhold (mbr@@lcs.mit.edu)/3 January 1990 */
d55 1
d60 3
d70 5
a76 1

d79 1
d82 4
a85 2
void
quit (int code, char * fmt, ...)
d87 33
a119 7
    va_list args;
    va_start(args, fmt);
    vfprintf (stderr, fmt, args);
    va_end(args);
    putc ('\n', stderr);
    exit (code);
}
d121 7
a127 7
void
quiterr (code, s)
    char *s;
{
    perror (s);
    exit (code);
}
d129 5
a133 13
void
msg (char * fmt, ...)
{
    va_list args;
    if (curdir) {
	fprintf (stderr, "%s:\n", curdir);
	curdir = 0;
    }
    va_start(args, fmt);
    vfprintf (stderr, fmt, args);
    va_end(args);
    putc ('\n', stderr);
}
d135 1
a135 9
void
mperror (s)
    char *s;
{
    if (curdir) {
	fprintf (stderr, "%s:\n", curdir);
	curdir = 0;
    }
    perror (s);
d138 2
a139 2

int equivalent(lname, rname)
d146 1
a146 1
	return 1;
d151 1
a151 1
    return !strcmp(lname, rname);
d154 1
a154 1

d162 1
a162 1
        quiterr(1, "addexcept");
d165 1
a165 1
        quiterr(1, "addexcept");
d172 7
a178 5
/* Recursively create symbolic links from the current directory to the "from"
   directory.  Assumes that files described by fs and ts are directories. */

dodir (fn, fs, ts, rel)
char *fn;			/* name of "from" directory, either absolute or
d180 2
a181 2
struct stat *fs, *ts;		/* stats for the "from" directory and cwd */
int rel;			/* if true, prepend "../" to fn before using */
d196 2
a197 2
	msg ("%s: From and to directories are identical!", fn);
	return 1;
d201 1
a201 1
	strcpy (buf, "../");
d204 1
a204 1
    strcat (buf, fn);
d206 3
a208 3
    if (!(df = opendir (buf))) {
	msg ("%s: Cannot opendir", buf);
	return 1;
d211 1
a211 1
    p = buf + strlen (buf);
d214 1
a214 1
    while (dp = readdir (df)) {
d222 1
a222 1
	strcpy (p, dp->d_name);
d225 2
a226 2
	    if (stat (buf, &sb) < 0) {
		mperror (buf);
d230 1
a230 1
	    if(S_ISDIR(sb.st_mode)) {
d237 1
a237 1
		if (!strcmp (dp->d_name, "RCS"))
d239 1
a239 1
		if (!strcmp (dp->d_name, "SCCS"))
d241 1
a241 1
		if (!strcmp (dp->d_name, "CVS"))
d243 1
a243 1
		if (!strcmp (dp->d_name, "CVS.adm"))
d247 1
a247 1
		curdir = silent ? buf : (char *)0;
d249 5
a253 5
		    printf ("%s:\n", buf);
		if ((stat (dp->d_name, &sc) < 0) && (errno == ENOENT)) {
		    if (mkdir (dp->d_name, 0777) < 0 ||
			stat (dp->d_name, &sc) < 0) {
			mperror (dp->d_name);
d258 3
a260 2
		if (readlink (dp->d_name, symbuf, sizeof(symbuf) - 1) >= 0) {
		    msg ("%s: is a link instead of a directory", dp->d_name);
d264 2
a265 2
		if (chdir (dp->d_name) < 0) {
		    mperror (dp->d_name);
d269 1
a269 1
		dodir (buf, &sb, &sc, (buf[0] != '/'));
d271 1
a271 1
		    quiterr (1, "..");
d278 1
a278 1
	symlen = readlink (dp->d_name, symbuf, sizeof(symbuf) - 1);
d282 5
a286 3
	/* The option to ignore links exists mostly because
	   checking for them slows us down by 10-20%.
	   But it is off by default because this really is a useful check. */
d296 2
a297 2
	    if (!equivalent (basesymlen>=0 ? basesym : buf, symbuf))
		msg ("%s: %s", dp->d_name, symbuf);
d299 2
a300 2
	    if (symlink (basesymlen>=0 ? basesym : buf, dp->d_name) < 0)
		mperror (dp->d_name);
d305 2
a306 2
    closedir (df);
    return 0;
d309 2
a310 4

main (ac, av)
int ac;
char **av;
d312 3
a314 50
    char *prog_name = av[0];
    char *fn, *tn;
    struct stat fs, ts;

    while (++av, --ac) {
	if ((strcmp(*av, "-silent") == 0) || (strcmp(*av, "-s") == 0))
	    silent = 1;
	else if ((strcmp(*av, "-ignorelinks") == 0) || (strcmp(*av, "-i") == 0))
	    ignore_links = 1;
	else if (strcmp(*av, "-e") == 0) {
	    ++av, --ac;

	    if (ac < 2)
	        quit (1, "usage: %s [-e except] [-s] [-i] fromdir [todir]",
		      prog_name);
	    addexcept(*av);
	}
	else if (strcmp(*av, "--") == 0) {
	    ++av, --ac;
	    break;
	}
	else
	    break;
    }

    if (ac < 1 || ac > 2)
	quit (1, "usage: %s [-e except] [-s] [-i] fromdir [todir]",
	      prog_name);

    fn = av[0];
    if (ac == 2)
	tn = av[1];
    else
	tn = ".";

    /* to directory */
    if (stat (tn, &ts) < 0)
	quiterr (1, tn);
    if (!(S_ISDIR(ts.st_mode)))
	quit (2, "%s: Not a directory", tn);
    if (chdir (tn) < 0)
	quiterr (1, tn);

    /* from directory */
    if (stat (fn, &fs) < 0)
	quiterr (1, fn);
    if (!(S_ISDIR(fs.st_mode)))
	quit (2, "%s: Not a directory", fn);

    exit (dodir (fn, &fs, &ts, 0));
@


1.3
log
@Move the except check.
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.2 1996/08/19 06:34:03 downsj Exp $	*/
d48 1
@


1.2
log
@kill a little more cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: lndir.c,v 1.1 1996/08/19 05:47:26 downsj Exp $	*/
d190 5
a209 5
		for (cur = exceptions; cur != (struct except *)NULL;
		     cur = cur->next) {
		    if (!strcmp (dp->d_name, cur->name))
		    	goto next;	/* can't continue */
		}
@


1.1
log
@lndir from X11, hacked up.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a321 1
#ifdef S_ISDIR
a322 3
#else
    if (!(ts.st_mode & S_IFDIR))
#endif
a329 1
#ifdef S_ISDIR
a330 3
#else
    if (!(fs.st_mode & S_IFDIR))
#endif
@
