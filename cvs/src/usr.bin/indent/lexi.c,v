head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.6
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.10
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.6
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.12.0.12
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.10
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.8
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.6
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.10
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.6
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2016.06.06.06.43.03;	author tobiasu;	state Exp;
branches;
next	1.19;
commitid	sQwbmU2fvsqEzyiw;

1.19
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	0Dp7Dy9FuNZesYo2;

1.18
date	2015.01.22.05.35.27;	author jsg;	state Exp;
branches;
next	1.17;
commitid	e6kig31QCq8dntgP;

1.17
date	2014.10.11.03.05.48;	author doug;	state Exp;
branches;
next	1.16;
commitid	bvwBIjzHyB3srYBI;

1.16
date	2013.11.26.13.21.17;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.27.23.59.39;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.27.16.22.14;	author martynas;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.02.15.19.32;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.06.14.34.25;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.20.03.50.26;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.26.22.23.28;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.12.01.07.27;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.25.04.58.31;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.08.07.14.42;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	98.05.22.05.15.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.09.10.07.06.37;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.09.10.07.01.10;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.07.25.22.00.46;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.34.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@it's typedef, not typdef.

typo found by Piotr Stefaniak
@
text
@/*	$OpenBSD: lexi.c,v 1.19 2015/08/20 22:32:41 deraadt Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.
 * Copyright (c) 1976 Board of Trustees of the University of Illinois.
 * Copyright (c) 1985 Sun Microsystems, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Here we have the token scanner for indent.  It scans off one token and puts
 * it in the global variable "token".  It returns a code, indicating the type
 * of token scanned.
 */

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <err.h>
#include "indent_globs.h"
#include "indent_codes.h"

#define alphanum 1
#define opchar 3

struct templ {
    char       *rwd;
    int         rwcode;
};

struct templ specialsinit[] = {
	{ "switch", 1 },
	{ "case", 2 },
	{ "break", 0 },
	{ "struct", 3 },
	{ "union", 3 },
	{ "enum", 3 },
	{ "default", 2 },
	{ "int", 4 },
	{ "char", 4 },
	{ "float", 4 },
	{ "double", 4 },
	{ "long", 4 },
	{ "short", 4 },
	{ "typedef", 4 },
	{ "unsigned", 4 },
	{ "register", 4 },
	{ "static", 4 },
	{ "global", 4 },
	{ "extern", 4 },
	{ "void", 4 },
	{ "goto", 0 },
	{ "return", 0 },
	{ "if", 5 },
	{ "while", 5 },
	{ "for", 5 },
	{ "else", 6 },
	{ "do", 6 },
	{ "sizeof", 7 },
};

struct templ *specials = specialsinit;
int	nspecials = sizeof(specialsinit) / sizeof(specialsinit[0]);
int	maxspecials;

char        chartype[128] =
{				/* this is used to facilitate the decision of
				 * what type (alphanumeric, operator) each
				 * character is */
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 3, 0, 0, 1, 3, 3, 0,
    0, 0, 3, 3, 0, 3, 0, 3,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 0, 0, 3, 3, 3, 3,
    0, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 0, 0, 0, 3, 1,
    0, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 0, 3, 0, 3, 0
};




int
lexi(void)
{
    int         unary_delim;	/* this is set to 1 if the current token
				 * forces a following operator to be unary */
    static int  last_code;	/* the last token type returned */
    static int  l_struct;	/* set to 1 if the last token was 'struct' */
    int         code;		/* internal code to be returned */
    char        qchar;		/* the delimiter character for a string */
    int		i;

    e_token = s_token;		/* point to start of place to save token */
    unary_delim = false;
    ps.col_1 = ps.last_nl;	/* tell world that this token started in
				 * column 1 iff the last thing scanned was nl */
    ps.last_nl = false;

    while (*buf_ptr == ' ' || *buf_ptr == '\t') {	/* get rid of blanks */
	ps.col_1 = false;	/* leading blanks imply token is not in column
				 * 1 */
	if (++buf_ptr >= buf_end)
	    fill_buffer();
    }

    /* Scan an alphanumeric token */
    if (chartype[(int)*buf_ptr] == alphanum ||
	(buf_ptr[0] == '.' && isdigit((unsigned char)buf_ptr[1]))) {
	/*
	 * we have a character or number
	 */
	char *j;	/* used for searching thru list of
			 * reserved words */
	if (isdigit((unsigned char)*buf_ptr) ||
	    (buf_ptr[0] == '.' && isdigit((unsigned char)buf_ptr[1]))) {
	    int         seendot = 0,
	                seenexp = 0,
			seensfx = 0;
	    if (*buf_ptr == '0' &&
		    (buf_ptr[1] == 'x' || buf_ptr[1] == 'X')) {
		*e_token++ = *buf_ptr++;
		*e_token++ = *buf_ptr++;
		while (isxdigit(*buf_ptr)) {
		    CHECK_SIZE_TOKEN;
		    *e_token++ = *buf_ptr++;
		}
	    }
	    else
		while (1) {
		    if (*buf_ptr == '.') {
			if (seendot)
			    break;
			else
			    seendot++;
		    }
		    CHECK_SIZE_TOKEN;
		    *e_token++ = *buf_ptr++;
		    if (!isdigit((unsigned char)*buf_ptr) && *buf_ptr != '.') {
			if ((*buf_ptr != 'E' && *buf_ptr != 'e') || seenexp)
			    break;
			else {
			    seenexp++;
			    seendot++;
			    CHECK_SIZE_TOKEN;
			    *e_token++ = *buf_ptr++;
			    if (*buf_ptr == '+' || *buf_ptr == '-')
				*e_token++ = *buf_ptr++;
			}
		    }
		}
	    while (1) {
		if (!(seensfx & 1) &&
			(*buf_ptr == 'U' || *buf_ptr == 'u')) {
		    CHECK_SIZE_TOKEN;
		    *e_token++ = *buf_ptr++;
		    seensfx |= 1;
		    continue;
		}
        	if (!(seensfx & 2) &&
			(*buf_ptr == 'L' || *buf_ptr == 'l')) {
		    CHECK_SIZE_TOKEN;
		    if (buf_ptr[1] == buf_ptr[0])
		        *e_token++ = *buf_ptr++;
		    *e_token++ = *buf_ptr++;
		    seensfx |= 2;
		    continue;
		}
		break;
	    }
	    if (!(seensfx & 1) &&    
	        (*buf_ptr == 'F' || *buf_ptr == 'f')) {
		CHECK_SIZE_TOKEN;
		*e_token++ = *buf_ptr++;
		seensfx |= 1;
	    }
	}
	else
	    while (chartype[(int)*buf_ptr] == alphanum) {	/* copy it over */
		CHECK_SIZE_TOKEN;
		*e_token++ = *buf_ptr++;
		if (buf_ptr >= buf_end)
		    fill_buffer();
	    }
	*e_token++ = '\0';
	while (*buf_ptr == ' ' || *buf_ptr == '\t') {	/* get rid of blanks */
	    if (++buf_ptr >= buf_end)
		fill_buffer();
	}
	ps.its_a_keyword = false;
	ps.sizeof_keyword = false;
	if (l_struct) {		/* if last token was 'struct', then this token
				 * should be treated as a declaration */
	    l_struct = false;
	    last_code = ident;
	    ps.last_u_d = true;
	    return (decl);
	}
	ps.last_u_d = false;	/* Operator after identifier is binary */
	last_code = ident;	/* Remember that this is the code we will
				 * return */

	/*
	 * This loop will check if the token is a keyword.
	 */
	for (i = 0; i < nspecials; i++) {
	    char *p = s_token;	/* point at scanned token */
	    j = specials[i].rwd;
	    if (*j++ != *p++ || *j++ != *p++)
		continue;	/* This test depends on the fact that
				 * identifiers are always at least 1 character
				 * long (ie. the first two bytes of the
				 * identifier are always meaningful) */
	    if (p[-1] == 0)
		break;		/* If its a one-character identifier */
	    while (*p++ == *j)
		if (*j++ == 0)
		    goto found_keyword;	/* I wish that C had a multi-level
					 * break... */
	}
	if (i < nspecials) {		/* we have a keyword */
    found_keyword:
	    ps.its_a_keyword = true;
	    ps.last_u_d = true;
	    switch (specials[i].rwcode) {
	    case 1:		/* it is a switch */
		return (swstmt);
	    case 2:		/* a case or default */
		return (casestmt);

	    case 3:		/* a "struct" */
		if (ps.p_l_follow)
		    break;	/* inside parens: cast */
		l_struct = true;

		/*
		 * Next time around, we will want to know that we have had a
		 * 'struct'
		 */
	    case 4:		/* one of the declaration keywords */
		if (ps.p_l_follow) {
		    ps.cast_mask |= 1 << ps.p_l_follow;
		    break;	/* inside parens: cast */
		}
		last_code = decl;
		return (decl);

	    case 5:		/* if, while, for */
		return (sp_paren);

	    case 6:		/* do, else */
		return (sp_nparen);

	    case 7:
		ps.sizeof_keyword = true;
	    default:		/* all others are treated like any other
				 * identifier */
		return (ident);
	    }			/* end of switch */
	}			/* end of if (found_it) */
	if (*buf_ptr == '(' && ps.tos <= 1 && ps.ind_level == 0) {
	    char *tp = buf_ptr;
	    while (tp < buf_end)
		if (*tp++ == ')' && (*tp == ';' || *tp == ','))
		    goto not_proc;
	    strlcpy(ps.procname, token, sizeof ps.procname);
	    ps.in_parameter_declaration = 1;
	    rparen_count = 1;
    not_proc:;
	}
	/*
	 * The following hack attempts to guess whether or not the current
	 * token is in fact a declaration keyword -- one that has been
	 * typedefd
	 */
	if (((*buf_ptr == '*' && buf_ptr[1] != '=') ||
	    isalpha((unsigned char)*buf_ptr) || *buf_ptr == '_')
		&& !ps.p_l_follow
	        && !ps.block_init
		&& (ps.last_token == rparen || ps.last_token == semicolon ||
		    ps.last_token == decl ||
		    ps.last_token == lbrace || ps.last_token == rbrace)) {
	    ps.its_a_keyword = true;
	    ps.last_u_d = true;
	    last_code = decl;
	    return decl;
	}
	if (last_code == decl)	/* if this is a declared variable, then
				 * following sign is unary */
	    ps.last_u_d = true;	/* will make "int a -1" work */
	last_code = ident;
	return (ident);		/* the ident is not in the list */
    }				/* end of procesing for alpanum character */

    /* Scan a non-alphanumeric token */

    *e_token++ = *buf_ptr;		/* if it is only a one-character token, it is
				 * moved here */
    *e_token = '\0';
    if (++buf_ptr >= buf_end)
	fill_buffer();

    switch (*token) {
    case '\n':
	unary_delim = ps.last_u_d;
	ps.last_nl = true;	/* remember that we just had a newline */
	code = (had_eof ? 0 : newline);

	/*
	 * if data has been exausted, the newline is a dummy, and we should
	 * return code to stop
	 */
	break;

    case '\'':			/* start of quoted character */
    case '"':			/* start of string */
	qchar = *token;
	if (troff) {
	    e_token[-1] = '`';
	    if (qchar == '"')
		*e_token++ = '`';
	    e_token = chfont(&bodyf, &stringf, e_token);
	}
	do {			/* copy the string */
	    while (1) {		/* move one character or [/<char>]<char> */
		if (*buf_ptr == '\n') {
		    printf("%d: Unterminated literal\n", line_no);
		    goto stop_lit;
		}
		CHECK_SIZE_TOKEN;	/* Only have to do this once in this loop,
					 * since CHECK_SIZE guarantees that there
					 * are at least 5 entries left */
		*e_token = *buf_ptr++;
		if (buf_ptr >= buf_end)
		    fill_buffer();
		if (*e_token == BACKSLASH) {	/* if escape, copy extra char */
		    if (*buf_ptr == '\n')	/* check for escaped newline */
			++line_no;
		    if (troff) {
			*++e_token = BACKSLASH;
			if (*buf_ptr == BACKSLASH)
			    *++e_token = BACKSLASH;
		    }
		    *++e_token = *buf_ptr++;
		    ++e_token;	/* we must increment this again because we
				 * copied two chars */
		    if (buf_ptr >= buf_end)
			fill_buffer();
		}
		else
		    break;	/* we copied one character */
	    }			/* end of while (1) */
	} while (*e_token++ != qchar);
	if (troff) {
	    e_token = chfont(&stringf, &bodyf, e_token - 1);
	    if (qchar == '"')
		*e_token++ = '\'';
	}
stop_lit:
	code = ident;
	break;

    case ('('):
    case ('['):
	unary_delim = true;
	code = lparen;
	break;

    case (')'):
    case (']'):
	code = rparen;
	break;

    case '#':
	unary_delim = ps.last_u_d;
	code = preesc;
	break;

    case '?':
	unary_delim = true;
	code = question;
	break;

    case (':'):
	code = colon;
	unary_delim = true;
	break;

    case (';'):
	unary_delim = true;
	code = semicolon;
	break;

    case ('{'):
	unary_delim = true;

	/*
	 * if (ps.in_or_st) ps.block_init = 1;
	 */
	/* ?	code = ps.block_init ? lparen : lbrace; */
	code = lbrace;
	break;

    case ('}'):
	unary_delim = true;
	/* ?	code = ps.block_init ? rparen : rbrace; */
	code = rbrace;
	break;

    case 014:			/* a form feed */
	unary_delim = ps.last_u_d;
	ps.last_nl = true;	/* remember this so we can set 'ps.col_1'
				 * right */
	code = form_feed;
	break;

    case (','):
	unary_delim = true;
	code = comma;
	break;

    case '.':
	unary_delim = false;
	code = period;
	break;

    case '-':
    case '+':			/* check for -, +, --, ++ */
	code = (ps.last_u_d ? unary_op : binary_op);
	unary_delim = true;

	if (*buf_ptr == token[0]) {
	    /* check for doubled character */
	    *e_token++ = *buf_ptr++;
	    /* buffer overflow will be checked at end of loop */
	    if (last_code == ident || last_code == rparen) {
		code = (ps.last_u_d ? unary_op : postop);
		/* check for following ++ or -- */
		unary_delim = false;
	    }
	}
	else if (*buf_ptr == '=')
	    /* check for operator += */
	    *e_token++ = *buf_ptr++;
	else if (*buf_ptr == '>') {
	    /* check for operator -> */
	    *e_token++ = *buf_ptr++;
	    if (!pointer_as_binop) {
		unary_delim = false;
		code = unary_op;
		ps.want_blank = false;
	    }
	}
	break;			/* buffer overflow will be checked at end of
				 * switch */

    case '=':
	if (ps.in_or_st)
	    ps.block_init = 1;
#ifdef undef
	if (chartype[*buf_ptr] == opchar) {	/* we have two char assignment */
	    e_token[-1] = *buf_ptr++;
	    if ((e_token[-1] == '<' || e_token[-1] == '>') && e_token[-1] == *buf_ptr)
		*e_token++ = *buf_ptr++;
	    *e_token++ = '=';	/* Flip =+ to += */
	    *e_token = 0;
	}
#else
	if (*buf_ptr == '=') {/* == */
	    *e_token++ = '=';	/* Flip =+ to += */
	    buf_ptr++;
	    *e_token = 0;
	}
#endif
	code = binary_op;
	unary_delim = true;
	break;
	/* can drop thru!!! */

    case '>':
    case '<':
    case '!':			/* ops like <, <<, <=, !=, etc */
	if (*buf_ptr == '>' || *buf_ptr == '<' || *buf_ptr == '=') {
	    *e_token++ = *buf_ptr;
	    if (++buf_ptr >= buf_end)
		fill_buffer();
	}
	if (*buf_ptr == '=')
	    *e_token++ = *buf_ptr++;
	code = (ps.last_u_d ? unary_op : binary_op);
	unary_delim = true;
	break;

    default:
	if (token[0] == '/' && *buf_ptr == '*') {
	    /* it is start of comment */
	    *e_token++ = '*';

	    if (++buf_ptr >= buf_end)
		fill_buffer();

	    code = comment;
	    unary_delim = ps.last_u_d;
	    break;
	}
	while (*(e_token - 1) == *buf_ptr || *buf_ptr == '=') {
	    /*
	     * handle ||, &&, etc, and also things as in int *****i
	     */
	    *e_token++ = *buf_ptr;
	    if (++buf_ptr >= buf_end)
		fill_buffer();
	}
	code = (ps.last_u_d ? unary_op : binary_op);
	unary_delim = true;


    }				/* end of switch */
    if (code != newline) {
	l_struct = false;
	last_code = code;
    }
    if (buf_ptr >= buf_end)	/* check for input buffer empty */
	fill_buffer();
    ps.last_u_d = unary_delim;
    *e_token = '\0';		/* null terminate the token */
    return (code);
}

/*
 * Add the given keyword to the keyword table, using val as the keyword type
 */
void
addkey(char *key, int val)
{
    struct templ *p;
    int i;

    for (i = 0; i < nspecials; i++) {
	p = &specials[i];
	if (p->rwd[0] == key[0] && strcmp(p->rwd, key) == 0)
	    return;
    }

    if (specials == specialsinit) {
	/*
	 * Whoa. Must reallocate special table.
	 */
	nspecials = sizeof (specialsinit) / sizeof (specialsinit[0]);
	maxspecials = nspecials + (nspecials >> 2);
	specials = calloc(maxspecials, sizeof specials[0]);
	if (specials == NULL)
	    err(1, NULL);
	memcpy(specials, specialsinit, sizeof specialsinit);
    } else if (nspecials >= maxspecials) {
	int newspecials = maxspecials + (maxspecials >> 2);
	struct templ *specials2;

	specials2 = reallocarray(specials, newspecials, sizeof(specials[0]));
	if (specials2 == NULL)
	    err(1, NULL);
	specials = specials2;
	maxspecials = newspecials;
    }

    p = &specials[nspecials];
    p->rwd = key;
    p->rwcode = val;
    nspecials++;
    return;
}
@


1.19
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.18 2015/01/22 05:35:27 jsg Exp $	*/
d71 1
a71 1
	{ "typdef", 4 },
@


1.18
log
@Recognise 'F'/'f' constant suffix for single precision floating point.
Prevents indent from inserting a space which broke the build of the
development version of Mesa.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.17 2014/10/11 03:05:48 doug Exp $	*/
d585 1
a585 1
	specials = (struct templ *)calloc(maxspecials, sizeof specials[0]);
@


1.17
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.16 2013/11/26 13:21:17 deraadt Exp $	*/
d204 6
@


1.16
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.15 2009/10/27 23:59:39 deraadt Exp $	*/
d587 1
a587 1
	specials2 = realloc(specials, newspecials * sizeof specials[0]);
@


1.15
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.14 2007/11/27 16:22:14 martynas Exp $	*/
d143 1
a143 1
	(buf_ptr[0] == '.' && isdigit(buf_ptr[1]))) {
d149 2
a150 1
	if (isdigit(*buf_ptr) || (buf_ptr[0] == '.' && isdigit(buf_ptr[1]))) {
d173 1
a173 1
		    if (!isdigit(*buf_ptr) && *buf_ptr != '.') {
d304 2
a305 1
	if (((*buf_ptr == '*' && buf_ptr[1] != '=') || isalpha(*buf_ptr) || *buf_ptr == '_')
@


1.14
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.13 2007/09/02 15:19:32 deraadt Exp $	*/
a33 5

#ifndef lint
/*static char sccsid[] = "@@(#)lexi.c	8.1 (Berkeley) 6/6/93";*/
static char rcsid[] = "$OpenBSD: lexi.c,v 1.13 2007/09/02 15:19:32 deraadt Exp $";
#endif /* not lint */
@


1.13
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.12 2005/03/06 14:34:25 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: lexi.c,v 1.12 2005/03/06 14:34:25 millert Exp $";
d231 1
a231 1
	ps.last_u_d = false;	/* Operator after indentifier is binary */
@


1.12
log
@Fix realloc bug introduce in rev 1.10 and do some minor cleanup.
OK henning@@ and tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.11 2004/07/20 03:50:26 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: lexi.c,v 1.11 2004/07/20 03:50:26 deraadt Exp $";
d582 1
a582 1
	specials = (struct templ *)malloc(maxspecials * sizeof specials[0]);
@


1.11
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.10 2003/09/26 22:23:28 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: lexi.c,v 1.10 2003/09/26 22:23:28 tedu Exp $";
d568 1
a568 1
    int i = 0;
d570 1
a570 1
    while (i < nspecials) {
a573 2
	else
	    i++;
d581 1
a581 2
	maxspecials = nspecials;
	maxspecials += maxspecials >> 2;
d585 1
a585 1
	memmove(specials, specialsinit, sizeof specialsinit);
d587 1
a587 1
	int newspecials = maxspecials + maxspecials >> 2;
d597 1
a597 1
    p = &specials[i];
@


1.10
log
@better realloc.  ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.9 2003/06/12 01:07:27 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: lexi.c,v 1.9 2003/06/12 01:07:27 deraadt Exp $";
d123 1
a123 1
lexi()
d565 1
a565 3
addkey(key, val)
    char       *key;
    int		val;
@


1.9
log
@final bits of obvious UCB term 3 removal
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.8 2001/06/25 04:58:31 pjanzen Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: lexi.c,v 1.8 2001/06/25 04:58:31 pjanzen Exp $";
d592 5
a596 3
	maxspecials += maxspecials >> 2;
	specials = realloc(specials, maxspecials * sizeof specials[0]);
	if (specials == NULL)
d598 2
@


1.8
log
@errx -> err if ENOMEM
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.7 2001/01/08 07:14:42 pjanzen Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: lexi.c,v 1.7 2001/01/08 07:14:42 pjanzen Exp $";
@


1.7
log
@Fix various warnings, merge lite-2, and tidy a bit; also, cast some
pointer arithmetic to int where needed.  Mostly from NetBSD.
Fix some buffer overflows pointed out in PR 1446 by gluk@@ptci.ru,
and check some {m,re}allocs.
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.6 1998/05/22 05:15:12 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: lexi.c,v 1.6 1998/05/22 05:15:12 deraadt Exp $";
d593 1
a593 1
	    errx(1, "out of memory");
d599 1
a599 1
	    errx(1, "out of memory");
@


1.6
log
@support U, and LL suffixes; rnordier
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.5 1997/09/10 07:06:37 deraadt Exp $	*/
d4 3
a7 2
 * Copyright (c) 1980 The Regents of the University of California.
 * Copyright (c) 1976 Board of Trustees of the University of Illinois.
d40 2
a41 2
/*static char sccsid[] = "from: @@(#)lexi.c	5.16 (Berkeley) 2/26/91";*/
static char rcsid[] = "$OpenBSD: lexi.c,v 1.5 1997/09/10 07:06:37 deraadt Exp $";
d54 1
a129 1
				 * 
d151 1
a151 1
    if (chartype[*buf_ptr] == alphanum ||
d156 2
a157 3
	register char *j;	/* used for searching thru list of
				 * 
				 * reserved words */
d173 1
a173 1
		    if (*buf_ptr == '.')
d178 1
d181 1
a181 1
		    if (!isdigit(*buf_ptr) && *buf_ptr != '.')
d192 1
d215 1
a215 1
	    while (chartype[*buf_ptr] == alphanum) {	/* copy it over */
d243 1
a243 1
	    register char *p = s_token;	/* point at scanned token */
d298 1
a298 1
	    register char *tp = buf_ptr;
d302 1
a302 1
	    strncpy(ps.procname, token, sizeof ps.procname - 1);
d573 1
a573 1
    register struct templ *p;
d593 1
a593 1
	    errx(1, "indent: out of memory");
d599 1
a599 1
	    errx(1, "indent: out of memory");
d601 1
a601 1
    
@


1.5
log
@remove my debug code, grrrrr
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.4 1997/09/10 07:01:10 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: lexi.c,v 1.4 1997/09/10 07:01:10 deraadt Exp $";
d160 2
a161 1
	                seenexp = 0;
d192 19
a210 2
	    if (*buf_ptr == 'L' || *buf_ptr == 'l')
		*e_token++ = *buf_ptr++;
@


1.4
log
@make 'special' array completely dynamic. hence you can now use as many -T
flags as you want; problem found in netbsd by agc but it isn't really a fix
to crank 100 to 1000, you know. I make it dynamic instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.3 1997/07/25 22:00:46 mickey Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: lexi.c,v 1.3 1997/07/25 22:00:46 mickey Exp $";
a567 1
	printf("alloc\n");
a575 1
	printf("realloc\n");
@


1.3
log
@use err(3), some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: lexi.c,v 1.2 1996/06/26 05:34:31 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: lexi.c,v 1.2 1996/06/26 05:34:31 deraadt Exp $";
d64 1
a64 2
struct templ specials[100] =
{
a92 1
	{ 0, 0 }
d95 4
d134 1
a157 2
	register struct templ *p;

d222 1
a222 1
	for (p = specials; (j = p->rwd) != 0; p++) {
d224 1
d237 1
a237 1
	if (p->rwd) {		/* we have a keyword */
d241 1
a241 1
	    switch (p->rwcode) {
d551 1
d553 5
a557 2
    register struct templ *p = specials;
    while (p->rwd)
d561 24
a584 4
	    p++;
    if (p >= specials + sizeof specials / sizeof specials[0])
	return;			/* For now, table overflows are silently
				 * ignored */
d587 1
a587 2
    p[1].rwd = 0;
    p[1].rwcode = 0;
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: lexi.c,v 1.1.1.1 1995/10/18 08:45:25 deraadt Exp $";
d66 29
a94 29
    "switch", 1,
    "case", 2,
    "break", 0,
    "struct", 3,
    "union", 3,
    "enum", 3,
    "default", 2,
    "int", 4,
    "char", 4,
    "float", 4,
    "double", 4,
    "long", 4,
    "short", 4,
    "typdef", 4,
    "unsigned", 4,
    "register", 4,
    "static", 4,
    "global", 4,
    "extern", 4,
    "void", 4,
    "goto", 0,
    "return", 0,
    "if", 5,
    "while", 5,
    "for", 5,
    "else", 6,
    "do", 6,
    "sizeof", 7,
    0, 0
d147 2
a148 1
    if (chartype[*buf_ptr] == alphanum || buf_ptr[0] == '.' && isdigit(buf_ptr[1])) {
d157 1
a157 1
	if (isdigit(*buf_ptr) || buf_ptr[0] == '.' && isdigit(buf_ptr[1])) {
d546 1
@


1.1
log
@Initial revision
@
text
@d1 2
d40 1
a40 1
static char rcsid[] = "$Id: lexi.c,v 1.2 1993/08/01 18:14:31 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
