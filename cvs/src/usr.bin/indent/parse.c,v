head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.30
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.28
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.24
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.26
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.18
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.22
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.20
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.16
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.14
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.24
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.20
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.18
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.16
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.14
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.12
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.10
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.14
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.12
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2009.10.27.23.59.39;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.20.03.50.26;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.26.21.43.07;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.12.01.07.27;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.08.07.14.42;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	97.07.25.22.00.47;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.34.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.9
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@/*	$OpenBSD: parse.c,v 1.8 2004/07/20 03:50:26 deraadt Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.
 * Copyright (c) 1976 Board of Trustees of the University of Illinois.
 * Copyright (c) 1985 Sun Microsystems, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdio.h>
#include "indent_globs.h"
#include "indent_codes.h"

void reduce(void);

void
parse(int tk)			/* the code for the construct scanned */
{
    int         i;

#ifdef debug
    printf("%2d - %s\n", tk, token);
#endif

    while (ps.p_stack[ps.tos] == ifhead && tk != elselit) {
	/* true if we have an if without an else */
	ps.p_stack[ps.tos] = stmt;	/* apply the if(..) stmt ::= stmt
					 * reduction */
	reduce();		/* see if this allows any reduction */
    }


    switch (tk) {		/* go on and figure out what to do with the
				 * input */

    case decl:			/* scanned a declaration word */
	ps.search_brace = btype_2;
	/* indicate that following brace should be on same line */
	if (ps.p_stack[ps.tos] != decl) {	/* only put one declaration
						 * onto stack */
	    break_comma = true;	/* while in declaration, newline should be
				 * forced after comma */
	    ps.p_stack[++ps.tos] = decl;
	    ps.il[ps.tos] = ps.i_l_follow;

	    if (ps.ljust_decl) {/* only do if we want left justified
				 * declarations */
		ps.ind_level = 0;
		for (i = ps.tos - 1; i > 0; --i)
		    if (ps.p_stack[i] == decl)
			++ps.ind_level;	/* indentation is number of
					 * declaration levels deep we are */
		ps.i_l_follow = ps.ind_level;
	    }
	}
	break;

    case ifstmt:		/* scanned if (...) */
	if (ps.p_stack[ps.tos] == elsehead && ps.else_if)	/* "else if ..." */
	    ps.i_l_follow = ps.il[ps.tos];
    case dolit:		/* 'do' */
    case forstmt:		/* for (...) */
	ps.p_stack[++ps.tos] = tk;
	ps.il[ps.tos] = ps.ind_level = ps.i_l_follow;
	++ps.i_l_follow;	/* subsequent statements should be indented 1 */
	ps.search_brace = btype_2;
	break;

    case lbrace:		/* scanned { */
	break_comma = false;	/* don't break comma in an initial list */
	if (ps.p_stack[ps.tos] == stmt || ps.p_stack[ps.tos] == decl
		|| ps.p_stack[ps.tos] == stmtl)
	    ++ps.i_l_follow;	/* it is a random, isolated stmt group or a
				 * declaration */
	else {
	    if (s_code == e_code) {
		/*
		 * only do this if there is nothing on the line
		 */
		--ps.ind_level;
		/*
		 * it is a group as part of a while, for, etc.
		 */
		if (ps.p_stack[ps.tos] == swstmt && ps.case_indent >= 1)
		    --ps.ind_level;
		/*
		 * for a switch, brace should be two levels out from the code
		 */
	    }
	}

	ps.p_stack[++ps.tos] = lbrace;
	ps.il[ps.tos] = ps.ind_level;
	ps.p_stack[++ps.tos] = stmt;
	/* allow null stmt between braces */
	ps.il[ps.tos] = ps.i_l_follow;
	break;

    case whilestmt:		/* scanned while (...) */
	if (ps.p_stack[ps.tos] == dohead) {
	    /* it is matched with do stmt */
	    ps.ind_level = ps.i_l_follow = ps.il[ps.tos];
	    ps.p_stack[++ps.tos] = whilestmt;
	    ps.il[ps.tos] = ps.ind_level = ps.i_l_follow;
	}
	else {			/* it is a while loop */
	    ps.p_stack[++ps.tos] = whilestmt;
	    ps.il[ps.tos] = ps.i_l_follow;
	    ++ps.i_l_follow;
	    ps.search_brace = btype_2;
	}

	break;

    case elselit:		/* scanned an else */

	if (ps.p_stack[ps.tos] != ifhead)
	    diag(1, "Unmatched 'else'");
	else {
	    ps.ind_level = ps.il[ps.tos];	/* indentation for else should
						 * be same as for if */
	    ps.i_l_follow = ps.ind_level + 1;	/* everything following should
						 * be in 1 level */
	    ps.p_stack[ps.tos] = elsehead;
	    /* remember if with else */
	    ps.search_brace = btype_2 | ps.else_if;
	}
	break;

    case rbrace:		/* scanned a } */
	/* stack should have <lbrace> <stmt> or <lbrace> <stmtl> */
	if (ps.p_stack[ps.tos - 1] == lbrace) {
	    ps.ind_level = ps.i_l_follow = ps.il[--ps.tos];
	    ps.p_stack[ps.tos] = stmt;
	}
	else
	    diag(1, "Stmt nesting error.");
	break;

    case swstmt:		/* had switch (...) */
	ps.p_stack[++ps.tos] = swstmt;
	ps.cstk[ps.tos] = case_ind;
	/* save current case indent level */
	ps.il[ps.tos] = ps.i_l_follow;
	case_ind = ps.i_l_follow + ps.case_indent;	/* cases should be one
							 * level down from
							 * switch */
	ps.i_l_follow += ps.case_indent + 1;	/* statements should be two
						 * levels in */
	ps.search_brace = btype_2;
	break;

    case semicolon:		/* this indicates a simple stmt */
	break_comma = false;	/* turn off flag to break after commas in a
				 * declaration */
	ps.p_stack[++ps.tos] = stmt;
	ps.il[ps.tos] = ps.ind_level;
	break;

    default:			/* this is an error */
	diag(1, "Unknown code to parser");
	return;


    }				/* end of switch */

    reduce();			/* see if any reduction can be done */

#ifdef debug
    for (i = 1; i <= ps.tos; ++i)
	printf("(%d %d)", ps.p_stack[i], ps.il[i]);
    printf("\n");
#endif

    return;
}

/*
 * NAME: reduce
 *
 * FUNCTION: Implements the reduce part of the parsing algorithm
 *
 * ALGORITHM: The following reductions are done.  Reductions are repeated
 *	until no more are possible.
 *
 * Old TOS		New TOS
 * <stmt> <stmt>	<stmtl>
 * <stmtl> <stmt>	<stmtl>
 * do <stmt>		"dostmt"
 * if <stmt>		"ifstmt"
 * switch <stmt>	<stmt>
 * decl <stmt>		<stmt>
 * "ifelse" <stmt>	<stmt>
 * for <stmt>		<stmt>
 * while <stmt>		<stmt>
 * "dostmt" while	<stmt>
 *
 * On each reduction, ps.i_l_follow (the indentation for the following line)
 * is set to the indentation level associated with the old TOS.
 *
 * PARAMETERS: None
 *
 * RETURNS: Nothing
 *
 * GLOBALS: ps.cstk ps.i_l_follow = ps.il ps.p_stack = ps.tos =
 *
 * CALLS: None
 *
 * CALLED BY: parse
 *
 * HISTORY: initial coding 	November 1976	D A Willcox of CAC
 *
 */
/*----------------------------------------------*\
|   REDUCTION PHASE				    |
\*----------------------------------------------*/
void
reduce(void)
{

    int i;

    for (;;) {			/* keep looping until there is nothing left to
				 * reduce */

	switch (ps.p_stack[ps.tos]) {

	case stmt:
	    switch (ps.p_stack[ps.tos - 1]) {

	    case stmt:
	    case stmtl:
		/* stmtl stmt or stmt stmt */
		ps.p_stack[--ps.tos] = stmtl;
		break;

	    case dolit:	/* <do> <stmt> */
		ps.p_stack[--ps.tos] = dohead;
		ps.i_l_follow = ps.il[ps.tos];
		break;

	    case ifstmt:
		/* <if> <stmt> */
		ps.p_stack[--ps.tos] = ifhead;
		for (i = ps.tos - 1;
			(
			 ps.p_stack[i] != stmt
			 &&
			 ps.p_stack[i] != stmtl
			 &&
			 ps.p_stack[i] != lbrace
			 );
			--i);
		ps.i_l_follow = ps.il[i];
		/*
		 * for the time being, we will assume that there is no else on
		 * this if, and set the indentation level accordingly. If an
		 * else is scanned, it will be fixed up later
		 */
		break;

	    case swstmt:
		/* <switch> <stmt> */
		case_ind = ps.cstk[ps.tos - 1];

	    case decl:		/* finish of a declaration */
	    case elsehead:
		/* <<if> <stmt> else> <stmt> */
	    case forstmt:
		/* <for> <stmt> */
	    case whilestmt:
		/* <while> <stmt> */
		ps.p_stack[--ps.tos] = stmt;
		ps.i_l_follow = ps.il[ps.tos];
		break;

	    default:		/* <anything else> <stmt> */
		return;

	    }			/* end of section for <stmt> on top of stack */
	    break;

	case whilestmt:	/* while (...) on top */
	    if (ps.p_stack[ps.tos - 1] == dohead) {
		/* it is termination of a do while */
		ps.p_stack[--ps.tos] = stmt;
		break;
	    }
	    else
		return;

	default:		/* anything else on top */
	    return;

	}
    }
}
@


1.8
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.7 2003/06/26 21:43:07 deraadt Exp $	*/
a33 5

#ifndef lint
/*static char sccsid[] = "@@(#)parse.c	8.1 (Berkeley) 6/6/93";*/
static char rcsid[] = "$OpenBSD: parse.c,v 1.7 2003/06/26 21:43:07 deraadt Exp $";
#endif /* not lint */
@


1.7
log
@minimal protos
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.6 2003/06/12 01:07:27 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.6 2003/06/12 01:07:27 deraadt Exp $";
d47 1
a47 2
parse(tk)
    int         tk;		/* the code for the construct scanned */
@


1.6
log
@final bits of obvious UCB term 3 removal
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.5 2001/11/19 19:02:14 mpech Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.5 2001/11/19 19:02:14 mpech Exp $";
d44 1
a44 1
void reduce();
d249 1
a249 1
reduce()
@


1.5
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.4 2001/01/08 07:14:42 pjanzen Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.4 2001/01/08 07:14:42 pjanzen Exp $";
@


1.4
log
@Fix various warnings, merge lite-2, and tidy a bit; also, cast some
pointer arithmetic to int where needed.  Mostly from NetBSD.
Fix some buffer overflows pointed out in PR 1446 by gluk@@ptci.ru,
and check some {m,re}allocs.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.3 1997/07/25 22:00:47 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.3 1997/07/25 22:00:47 mickey Exp $";
d256 1
a256 1
    register int i;
@


1.3
log
@use err(3), some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.2 1996/06/26 05:34:32 deraadt Exp $	*/
d4 3
a7 2
 * Copyright (c) 1980 The Regents of the University of California.
 * Copyright (c) 1976 Board of Trustees of the University of Illinois.
d40 2
a41 2
/*static char sccsid[] = "from: @@(#)parse.c	5.12 (Berkeley) 2/26/91";*/
static char rcsid[] = "$OpenBSD: parse.c,v 1.2 1996/06/26 05:34:32 deraadt Exp $";
d215 1
a215 1
 * 
d217 1
a217 1
 * 
d220 1
a220 1
 * 
d232 1
a232 1
 * 
d235 1
a235 1
 * 
d237 1
a237 1
 * 
d239 1
a239 1
 * 
d241 1
a241 1
 * 
d243 1
a243 1
 * 
d245 1
a245 1
 * 
d247 1
a247 1
 * 
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.1.1.1 1995/10/18 08:45:25 deraadt Exp $";
d47 3
d251 1
@


1.1
log
@Initial revision
@
text
@d1 2
d40 1
a40 1
static char rcsid[] = "$Id: parse.c,v 1.2 1993/08/01 18:14:30 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
