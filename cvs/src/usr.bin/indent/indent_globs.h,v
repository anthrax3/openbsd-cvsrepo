head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.8
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.40
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.38
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.36
	OPENBSD_5_0:1.10.0.34
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.32
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.30
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.26
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.28
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.24
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.22
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.20
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.18
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.16
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.14
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2015.09.27.17.00.46;	author guenther;	state Exp;
branches;
next	1.13;
commitid	W4y3MLIpS5fPpHTW;

1.13
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	0Dp7Dy9FuNZesYo2;

1.12
date	2015.01.19.15.30.52;	author krw;	state Exp;
branches;
next	1.11;
commitid	NY1hHZats0xLzgJV;

1.11
date	2013.06.20.06.28.15;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.25.21.24.53;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.12.01.07.27;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.11.23.31.50;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.47;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.25.04.58.31;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.08.07.14.42;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	99.09.14.18.38.28;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.07.25.22.00.45;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.34.30;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Mark diag() as printf-like

ok millert@@
@
text
@/*	$OpenBSD: indent_globs.h,v 1.13 2015/08/20 22:32:41 deraadt Exp $ */
/*
 * Copyright (c) 1985 Sun Microsystems, Inc.
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.
 * Copyright (c) 1976 Board of Trustees of the University of Illinois.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)indent_globs.h	8.1 (Berkeley) 6/6/93
 */

#define BACKSLASH '\\'
#define bufsize 200		/* size of internal buffers */
#define sc_size 5000		/* size of save_com buffer */
#define label_offset 2		/* number of levels a label is placed to left
				 * of code */

#define tabsize 8		/* the size of a tab */
#define tabmask 0177770		/* mask used when figuring length of lines
				 * with tabs */


#define false 0
#define true  1


FILE       *input;		/* the fid for the input file */
FILE       *output;		/* the output file */

#define CHECK_SIZE_CODE \
	if (e_code >= l_code) { \
	    int nsize = l_code-s_code+400; \
	\
	    codebuf = realloc(codebuf, nsize); \
	    if (codebuf == NULL) \
		    err(1, NULL); \
	    e_code = codebuf + (e_code-s_code) + 1; \
	    l_code = codebuf + nsize - 5; \
	    s_code = codebuf + 1; \
	}
#define CHECK_SIZE_COM \
	if (e_com >= l_com) { \
	    int nsize = l_com-s_com+400; \
	\
	    combuf = realloc(combuf, nsize); \
	    if (combuf == NULL) \
		    err(1, NULL); \
	    e_com = combuf + (e_com-s_com) + 1; \
	    l_com = combuf + nsize - 5; \
	    s_com = combuf + 1; \
	}
#define CHECK_SIZE_LAB \
	if (e_lab >= l_lab) { \
	    int nsize = l_lab-s_lab+400; \
	\
	    labbuf = realloc(labbuf, nsize); \
	    if (labbuf == NULL) \
		    err(1, NULL); \
	    e_lab = labbuf + (e_lab-s_lab) + 1; \
	    l_lab = labbuf + nsize - 5; \
	    s_lab = labbuf + 1; \
	}
#define CHECK_SIZE_TOKEN \
	if (e_token >= l_token) { \
	    int nsize = l_token-s_token+400; \
	\
	    tokenbuf = realloc(tokenbuf, nsize); \
	    if (tokenbuf == NULL) \
		    err(1, NULL); \
	    e_token = tokenbuf + (e_token-s_token) + 1; \
	    l_token = tokenbuf + nsize - 5; \
	    s_token = tokenbuf + 1; \
	}

char       *labbuf;		/* buffer for label */
char       *s_lab;		/* start ... */
char       *e_lab;		/* .. and end of stored label */
char       *l_lab;		/* limit of label buffer */

char       *codebuf;		/* buffer for code section */
char       *s_code;		/* start ... */
char       *e_code;		/* .. and end of stored code */
char       *l_code;		/* limit of code section */

char       *combuf;		/* buffer for comments */
char       *s_com;		/* start ... */
char       *e_com;		/* ... and end of stored comments */
char       *l_com;		/* limit of comment buffer */

#define token s_token
char       *tokenbuf;		/* the last token scanned */
char	   *s_token;
char       *e_token;
char	   *l_token;

char       *in_buffer;		/* input buffer */
char	   *in_buffer_limit;	/* the end of the input buffer */
char       *buf_ptr;		/* ptr to next character to be taken from
				 * in_buffer */
char       *buf_end;		/* ptr to first after last char in in_buffer */

char        save_com[sc_size];	/* input text is saved here when looking for
				 * the brace after an if, while, etc */
char       *sc_end;		/* pointer into save_com buffer */

char       *bp_save;		/* saved value of buf_ptr when taking input
				 * from save_com */
char       *be_save;		/* similarly saved value of buf_end */


int         pointer_as_binop;
int         blanklines_after_declarations;
int         blanklines_before_blockcomments;
int         blanklines_after_procs;
int         blanklines_around_conditional_compilation;
int         swallow_optional_blanklines;
int         n_real_blanklines;
int         prefix_blankline_requested;
int         postfix_blankline_requested;
int         break_comma;	/* when true and not in parens, break after a
				 * comma */
int         btype_2;		/* when true, brace should be on same line as
				 * if, while, etc */
float       case_ind;		/* indentation level to be used for a "case
				 * n:" */
int         code_lines;		/* count of lines with code */
int         had_eof;		/* set to true when input is exhausted */
int         line_no;		/* the current line number. */
int         max_col;		/* the maximum allowable line length */
int         verbose;		/* when true, non-essential error messages are
				 * printed */
int         cuddle_else;	/* true if else should cuddle up to '}' */
int         star_comment_cont;	/* true iff comment continuation lines should
				 * have stars at the beginning of each line. */
int         comment_delimiter_on_blankline;
int         troff;		/* true iff were generating troff input */
int         procnames_start_line;	/* if true, the names of procedures
					 * being defined get placed in column
					 * 1 (ie. a newline is placed between
					 * the type of the procedure and its
					 * name) */
int         proc_calls_space;	/* If true, procedure calls look like:
				 * foo(bar) rather than foo (bar) */
int         format_col1_comments;	/* If comments which start in column 1
					 * are to be magically reformatted
					 * (just like comments that begin in
					 * later columns) */
int         inhibit_formatting;	/* true if INDENT OFF is in effect */
int         suppress_blanklines;/* set iff following blanklines should be
				 * suppressed */
int         continuation_indent;/* set to the indentation between the edge of
				 * code and continuation lines */
int         lineup_to_parens;	/* if true, continued code within parens will
				 * be lined up to the open paren */
int         Bill_Shannon;	/* true iff a blank should always be inserted
				 * after sizeof */
int         blanklines_after_declarations_at_proctop;	/* This is vaguely
							 * similar to
							 * blanklines_after_decla
							 * rations except that
							 * it only applies to
							 * the first set of
							 * declarations in a
							 * procedure (just after
							 * the first '{') and it
							 * causes a blank line
							 * to be generated even
							 * if there are no
							 * declarations */
int         block_comment_max_col;
int         extra_expression_indent;	/* True if continuation lines from the
					 * expression part of "if(e)",
					 * "while(e)", "for(e;e;e)" should be
					 * indented an extra tab stop so that
					 * they don't conflict with the code
					 * that follows */
int	    use_tabs;			/* set true to use tabs for spacing,
					 * false uses all spaces */

/* -troff font state information */

struct fstate {
    char        font[4];
    char        size;
    int         allcaps:1;
};

struct fstate
            keywordf,		/* keyword font */
            stringf,		/* string font */
            boxcomf,		/* Box comment font */
            blkcomf,		/* Block comment font */
            scomf,		/* Same line comment font */
            bodyf;		/* major body font */


#define STACKSIZE 150

struct parser_state {
    int         last_token;
    struct fstate cfont;	/* Current font */
    int         p_stack[STACKSIZE];	/* this is the parsers stack */
    int         il[STACKSIZE];	/* this stack stores indentation levels */
    float       cstk[STACKSIZE];/* used to store case stmt indentation levels */
    int         box_com;	/* set to true when we are in a "boxed"
				 * comment. In that case, the first non-blank
				 * char should be lined up with the / in rem */
    int         comment_delta,
                n_comment_delta;
    int         cast_mask;	/* indicates which close parens close off
				 * casts */
    int         sizeof_mask;	/* indicates which close parens close off
				 * sizeof''s */
    int         block_init;	/* true iff inside a block initialization */
    int         block_init_level;	/* The level of brace nesting in an
					 * initialization */
    int         last_nl;	/* this is true if the last thing scanned was
				 * a newline */
    int         in_or_st;	/* Will be true iff there has been a
				 * declarator (e.g. int or char) and no left
				 * paren since the last semicolon. When true,
				 * a '{' is starting a structure definition or
				 * an initialization list */
    int         bl_line;	/* set to 1 by dump_line if the line is blank */
    int         col_1;		/* set to true if the last token started in
				 * column 1 */
    int         com_col;	/* this is the column in which the current
				 * coment should start */
    int         com_ind;	/* the column in which comments to the right
				 * of code should start */
    int         com_lines;	/* the number of lines with comments, set by
				 * dump_line */
    int         dec_nest;	/* current nesting level for structure or init */
    int         decl_com_ind;	/* the column in which comments after
				 * declarations should be put */
    int         decl_on_line;	/* set to true if this line of code has part
				 * of a declaration on it */
    int         i_l_follow;	/* the level to which ind_level should be set
				 * after the current line is printed */
    int         in_decl;	/* set to true when we are in a declaration
				 * stmt.  The processing of braces is then
				 * slightly different */
    int         in_stmt;	/* set to 1 while in a stmt */
    int         ind_level;	/* the current indentation level */
    int         ind_size;	/* the size of one indentation level */
    int         ind_stmt;	/* set to 1 if next line should have an extra
				 * indentation level because we are in the
				 * middle of a stmt */
    int         last_u_d;	/* set to true after scanning a token which
				 * forces a following operator to be unary */
    int         leave_comma;	/* if true, never break declarations after
				 * commas */
    int         ljust_decl;	/* true if declarations should be left
				 * justified */
    int         out_coms;	/* the number of comments processed, set by
				 * pr_comment */
    int         out_lines;	/* the number of lines written, set by
				 * dump_line */
    int         p_l_follow;	/* used to remember how to indent following
				 * statement */
    int         paren_level;	/* parenthesization level. used to indent
				 * within stmts */
    short       paren_indents[20];	/* column positions of each paren */
    int         pcase;		/* set to 1 if the current line label is a
				 * case.  It is printed differently from a
				 * regular label */
    int         search_brace;	/* set to true by parse when it is necessary
				 * to buffer up all info up to the start of a
				 * stmt after an if, while, etc */
    int         unindent_displace;	/* comments not to the right of code
					 * will be placed this many
					 * indentation levels to the left of
					 * code */
    int         use_ff;		/* set to one if the current line should be
				 * terminated with a form feed */
    int         want_blank;	/* set to true when the following token should
				 * be prefixed by a blank. (Said prefixing is
				 * ignored in some cases.) */
    int         else_if;	/* True iff else if pairs should be handled
				 * specially */
    int         decl_indent;	/* column to indent declared identifiers to */
    int         its_a_keyword;
    int         sizeof_keyword;
    int         dumped_decl_indent;
    float       case_indent;	/* The distance to indent case labels from the
				 * switch statement */
    int         in_parameter_declaration;
    int         indent_parameters;
    int         tos;		/* pointer to top of stack */
    char        procname[100];	/* The name of the current procedure */
    int         just_saw_decl;
}           ps;

int         ifdef_level;
int	    rparen_count;
struct parser_state state_stack[5];
struct parser_state match_state[5];

int compute_code_target(void);
int compute_label_target(void);
int count_spaces(int, char *);
void diag(int, const char *, ...) __attribute__((__format__ (printf, 2, 3)));
void dump_line(void);
int eqin(char *, char *);
void fill_buffer(void);
int pad_output(int, int);
void scan_profile(FILE *);
void set_defaults(void);
void set_option(char *);
void addkey(char *, int);
void set_profile(void);
char   *chfont(struct fstate *, struct fstate *, char *);
void parsefont(struct fstate *, char *);
void writefdef(struct fstate *, int);
int lexi(void);
void reduce(void);
void parse(int);
void pr_comment(void);
void bakcopy(void);
@


1.13
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: indent_globs.h,v 1.12 2015/01/19 15:30:52 krw Exp $ */
d326 1
a326 1
void diag(int, char *, ...);
@


1.12
log
@Make some $OpenBSD$ lines prettier/standardier by eliminating
superflous '*' after '/*' and adding blank after terminating '$'.
Also eases parsing of the lines by simple awk scripts.

Aesthetic approval from tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: indent_globs.h,v 1.11 2013/06/20 06:28:15 jsg Exp $ */
d58 1
a58 1
	    codebuf = (char *) realloc(codebuf, nsize); \
d69 1
a69 1
	    combuf = (char *) realloc(combuf, nsize); \
d80 1
a80 1
	    labbuf = (char *) realloc(labbuf, nsize); \
d91 1
a91 1
	    tokenbuf = (char *) realloc(tokenbuf, nsize); \
@


1.11
log
@add ut/nut flags to indent to enable/disable tabs.

based on FreeBSD svn rev 131184.
ok deraadt@@
@
text
@d1 1
a1 1
/* *	$OpenBSD: indent_globs.h,v 1.10 2003/06/25 21:24:53 deraadt Exp $*/
@


1.10
log
@delete junk proto
@
text
@d1 1
a1 1
/* *	$OpenBSD: indent_globs.h,v 1.9 2003/06/12 01:07:27 deraadt Exp $*/
d201 2
@


1.9
log
@final bits of obvious UCB term 3 removal
@
text
@d1 1
a1 1
/* *	$OpenBSD: indent_globs.h,v 1.8 2003/06/11 23:31:50 deraadt Exp $*/
a208 1
char       *chfont();
@


1.8
log
@de-register
@
text
@d1 1
a1 1
/* *	$OpenBSD: indent_globs.h,v 1.7 2002/02/16 21:27:47 millert Exp $*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/* *	$OpenBSD: indent_globs.h,v 1.6 2001/06/25 04:58:31 pjanzen Exp $*/
d60 2
a61 1
	    register int nsize = l_code-s_code+400; \
d71 2
a72 1
	    register int nsize = l_com-s_com+400; \
d82 2
a83 1
	    register int nsize = l_lab-s_lab+400; \
d93 2
a94 1
	    register int nsize = l_token-s_token+400; \
@


1.6
log
@errx -> err if ENOMEM
@
text
@d1 1
a1 1
/* *	$OpenBSD: indent_globs.h,v 1.5 2001/01/08 07:14:42 pjanzen Exp $*/
d322 21
a342 21
int compute_code_target __P((void));
int compute_label_target __P((void));
int count_spaces __P((int, char *));
void diag __P((int, char *, ...));
void dump_line __P((void));
int eqin __P((char *, char *));
void fill_buffer __P((void));
int pad_output __P((int, int));
void scan_profile __P((FILE *));
void set_defaults __P((void));
void set_option __P((char *));
void addkey __P((char *, int));
void set_profile __P((void));
char   *chfont __P((struct fstate *, struct fstate *, char *));
void parsefont __P((struct fstate *, char *));
void writefdef __P((struct fstate *, int));
int lexi __P((void));
void reduce __P((void));
void parse __P((int));
void pr_comment __P((void));
void bakcopy __P((void));
@


1.5
log
@Fix various warnings, merge lite-2, and tidy a bit; also, cast some
pointer arithmetic to int where needed.  Mostly from NetBSD.
Fix some buffer overflows pointed out in PR 1446 by gluk@@ptci.ru,
and check some {m,re}allocs.
@
text
@d1 1
a1 1
/* *	$OpenBSD: indent_globs.h,v 1.4 1999/09/14 18:38:28 deraadt Exp $*/
d63 1
a63 1
		    errx(1, "out of memory"); \
d73 1
a73 1
		    errx(1, "out of memory"); \
d83 1
a83 1
		    errx(1, "out of memory"); \
d93 1
a93 1
		    errx(1, "out of memory"); \
@


1.4
log
@types
@
text
@d1 1
a1 1
/* *	$OpenBSD: indent_globs.h,v 1.3 1997/07/25 22:00:45 mickey Exp $*/
d4 2
a5 1
 * Copyright (c) 1980 The Regents of the University of California.
d37 1
a37 1
 *	from: @@(#)indent_globs.h	5.11 (Berkeley) 2/26/91
d62 2
d72 2
d82 2
d92 2
d321 22
@


1.3
log
@use err(3), some -Wall
@
text
@d1 1
a1 1
/* *	$OpenBSD: indent_globs.h,v 1.2 1996/06/26 05:34:30 deraadt Exp $*/
d59 1
a59 1
	    register nsize = l_code-s_code+400; \
d67 1
a67 1
	    register nsize = l_com-s_com+400; \
d75 1
a75 1
	    register nsize = l_lab-s_lab+400; \
d83 1
a83 1
	    register nsize = l_token-s_token+400; \
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/* *	$OpenBSD: indent_globs.h,v 1.1.1.1 1995/10/18 08:45:25 deraadt Exp $*/
d221 1
a221 1
				 * char should be lined up with the / in /* */
@


1.1
log
@Initial revision
@
text
@d1 1
a36 1
 *	$Id: indent_globs.h,v 1.2 1993/08/01 18:14:34 mycroft Exp $
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
