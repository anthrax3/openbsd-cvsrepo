head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.10
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.20
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.16
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.14
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.12
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.10
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.8
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.6
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.14
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.12
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2015.09.27.17.00.46;	author guenther;	state Exp;
branches;
next	1.13;
commitid	W4y3MLIpS5fPpHTW;

1.13
date	2013.11.26.13.21.17;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.20.06.28.15;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.39;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.15.03.27.04;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.20.03.50.26;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.26.22.23.28;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.03.02.56.09;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.04.15.27.21;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.08.07.14.42;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	97.07.25.22.00.46;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.34.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Mark diag() as printf-like

ok millert@@
@
text
@/*	$OpenBSD: io.c,v 1.13 2013/11/26 13:21:17 deraadt Exp $	*/

/*
 * Copyright (c) 1985 Sun Microsystems, Inc.
 * Copyright (c) 1980, 1993 The Regents of the University of California.
 * Copyright (c) 1976 Board of Trustees of the University of Illinois.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <err.h>
#include "indent_globs.h"


int         comment_open;
static int  paren_target;

void
dump_line(void)
{				/* dump_line is the routine that actually
				 * effects the printing of the new source. It
				 * prints the label section, followed by the
				 * code section with the appropriate nesting
				 * level, followed by any comments */
    int         cur_col, target_col;
    static int  not_first_line;

    if (ps.procname[0]) {
	if (troff) {
	    if (comment_open) {
		comment_open = 0;
		fprintf(output, ".*/\n");
	    }
	    fprintf(output, ".Pr \"%s\"\n", ps.procname);
	}
	ps.ind_level = 0;
	ps.procname[0] = 0;
    }
    if (s_code == e_code && s_lab == e_lab && s_com == e_com) {
	if (suppress_blanklines > 0)
	    suppress_blanklines--;
	else {
	    ps.bl_line = true;
	    n_real_blanklines++;
	}
    }
    else if (!inhibit_formatting) {
	suppress_blanklines = 0;
	ps.bl_line = false;
	if (prefix_blankline_requested && not_first_line) {
	    if (swallow_optional_blanklines) {
		if (n_real_blanklines == 1)
		    n_real_blanklines = 0;
	    } else {
		if (n_real_blanklines == 0)
		    n_real_blanklines = 1;
	    }
	}
	while (--n_real_blanklines >= 0)
	    putc('\n', output);
	n_real_blanklines = 0;
	if (ps.ind_level == 0)
	    ps.ind_stmt = 0;	/* this is a class A kludge. dont do
				 * additional statement indentation if we are
				 * at bracket level 0 */

	if (e_lab != s_lab || e_code != s_code)
	    ++code_lines;	/* keep count of lines with code */


	if (e_lab != s_lab) {	/* print lab, if any */
	    if (comment_open) {
		comment_open = 0;
		fprintf(output, ".*/\n");
	    }
	    while (e_lab > s_lab && (e_lab[-1] == ' ' || e_lab[-1] == '\t'))
		e_lab--;
	    cur_col = pad_output(1, compute_label_target());
	    if (s_lab[0] == '#' && (strncmp(s_lab, "#else", 5) == 0
				    || strncmp(s_lab, "#endif", 6) == 0)) {
		char *s = s_lab;
		if (e_lab[-1] == '\n')
			e_lab--;
		do
			putc(*s++, output);
		while (s < e_lab && 'a' <= *s && *s<='z');
		while ((*s == ' ' || *s == '\t') && s < e_lab)
		    s++;
		if (s < e_lab)
		    fprintf(output, s[0]=='/' && s[1]=='*' ? "\t%.*s" : "\t/* %.*s */",
			    (int)(e_lab - s), s);
	    }
	    else fprintf(output, "%.*s", (int)(e_lab - s_lab), s_lab);
	    cur_col = count_spaces(cur_col, s_lab);
	}
	else
	    cur_col = 1;	/* there is no label section */

	ps.pcase = false;

	if (s_code != e_code) {	/* print code section, if any */
	    char *p;

	    if (comment_open) {
		comment_open = 0;
		fprintf(output, ".*/\n");
	    }
	    target_col = compute_code_target();
	    {
		int  i;

		for (i = 0; i < ps.p_l_follow; i++)
		    if (ps.paren_indents[i] >= 0)
			ps.paren_indents[i] = -(ps.paren_indents[i] + target_col);
	    }
	    cur_col = pad_output(cur_col, target_col);
	    for (p = s_code; p < e_code; p++)
		if (*p == (char) 0200)
		    fprintf(output, "%d", target_col * 7);
		else
		    putc(*p, output);
	    cur_col = count_spaces(cur_col, s_code);
	}
	if (s_com != e_com) {
	    if (troff) {
		int   all_here = 0;
		char *p;

		if (e_com[-1] == '/' && e_com[-2] == '*')
		    e_com -= 2, all_here++;
		while (e_com > s_com && e_com[-1] == ' ')
		    e_com--;
		*e_com = 0;
		p = s_com;
		while (*p == ' ')
		    p++;
		if (p[0] == '/' && p[1] == '*')
		    p += 2, all_here++;
		else if (p[0] == '*')
		    p += p[1] == '/' ? 2 : 1;
		while (*p == ' ')
		    p++;
		if (*p == 0)
		    goto inhibit_newline;
		if (comment_open < 2 && ps.box_com) {
		    comment_open = 0;
		    fprintf(output, ".*/\n");
		}
		if (comment_open == 0) {
		    if ('a' <= *p && *p <= 'z')
			*p = *p + 'A' - 'a';
		    if (e_com - p < 50 && all_here == 2) {
			char *follow = p;
			fprintf(output, "\n.nr C! \\w\1");
			while (follow < e_com) {
			    switch (*follow) {
			    case '\n':
				putc(' ', output);
			    case 1:
				break;
			    case '\\':
				putc('\\', output);
			    default:
				putc(*follow, output);
			    }
			    follow++;
			}
			putc(1, output);
		    }
		    fprintf(output, "\n./* %dp %d %dp\n",
			    ps.com_col * 7,
			    (s_code != e_code || s_lab != e_lab) - ps.box_com,
			    target_col * 7);
		}
		comment_open = 1 + ps.box_com;
		while (*p) {
		    if (*p == BACKSLASH)
			putc(BACKSLASH, output);
		    putc(*p++, output);
		}
	    } else {		/* print comment, if any */
		int   target = ps.com_col;
		char *com_st = s_com;

		target += ps.comment_delta;
		while (*com_st == '\t')
		    com_st++, target += 8;	/* ? */
		while (target <= 0)
		    if (*com_st == ' ')
			target++, com_st++;
		    else if (*com_st == '\t')
			target = ((target - 1) & ~7) + 9, com_st++;
		    else
			target = 1;
		if (cur_col > target) {	/* if comment cant fit on this line,
					 * put it on next line */
		    putc('\n', output);
		    cur_col = 1;
		    ++ps.out_lines;
		}
		while (e_com > com_st && isspace((unsigned char)e_com[-1]))
		    e_com--;
		cur_col = pad_output(cur_col, target);
		if (!ps.box_com) {
		    if (star_comment_cont && (com_st[1] != '*' || e_com <= com_st + 1)) {
			if (com_st[1] == ' ' && com_st[0] == ' ' && e_com > com_st + 1)
			    com_st[1] = '*';
			else
			    fwrite(" * ", com_st[0] == '\t' ? 2 : com_st[0] == '*' ? 1 : 3, 1, output);
		    }
		}
		fwrite(com_st, e_com - com_st, 1, output);
		ps.comment_delta = ps.n_comment_delta;
		cur_col = count_spaces(cur_col, com_st);
		++ps.com_lines;	/* count lines with comments */
	    }
	}
	if (ps.use_ff)
	    putc('\014', output);
	else
	    putc('\n', output);
inhibit_newline:
	++ps.out_lines;
	if (ps.just_saw_decl == 1 && blanklines_after_declarations) {
	    prefix_blankline_requested = 1;
	    ps.just_saw_decl = 0;
	}
	else
	    prefix_blankline_requested = postfix_blankline_requested;
	postfix_blankline_requested = 0;
    }
    ps.decl_on_line = ps.in_decl;	/* if we are in the middle of a
					 * declaration, remember that fact for
					 * proper comment indentation */
    ps.ind_stmt = ps.in_stmt & ~ps.in_decl;	/* next line should be
						 * indented if we have not
						 * completed this stmt and if
						 * we are not in the middle of
						 * a declaration */
    ps.use_ff = false;
    ps.dumped_decl_indent = 0;
    *(e_lab = s_lab) = '\0';	/* reset buffers */
    *(e_code = s_code) = '\0';
    *(e_com = s_com) = '\0';
    ps.ind_level = ps.i_l_follow;
    ps.paren_level = ps.p_l_follow;
    paren_target = -ps.paren_indents[ps.paren_level - 1];
    not_first_line = 1;
    return;
}

int
compute_code_target(void)
{
    int target_col;

    target_col = ps.ind_size * ps.ind_level + 1;
    if (ps.paren_level)
	if (!lineup_to_parens)
	    target_col += continuation_indent * ps.paren_level;
	else {
	    int    w;
	    int    t = paren_target;

	    if ((w = count_spaces(t, s_code) - max_col) > 0
		    && count_spaces(target_col, s_code) <= max_col) {
		t -= w + 1;
		if (t > target_col)
		    target_col = t;
	    }
	    else
		target_col = t;
	}
    else if (ps.ind_stmt)
	target_col += continuation_indent;
    return target_col;
}

int
compute_label_target(void)
{
    return
	ps.pcase ? (int) (case_ind * ps.ind_size) + 1
	: *s_lab == '#' ? 1
	: ps.ind_size * (ps.ind_level - label_offset) + 1;
}


/*
 * Copyright (C) 1976 by the Board of Trustees of the University of Illinois
 * 
 * All rights reserved
 * 
 * 
 * NAME: fill_buffer
 * 
 * FUNCTION: Reads one block of input into input_buffer
 * 
 * HISTORY: initial coding 	November 1976	D A Willcox of CAC 1/7/77 A
 * Willcox of CAC	Added check for switch back to partly full input
 * buffer from temporary buffer
 * 
 */
void
fill_buffer(void)
{				/* this routine reads stuff from the input */
    char *p, *buf2;
    int i;
    FILE *f = input;

    if (bp_save != 0) {		/* there is a partly filled input buffer left */
	buf_ptr = bp_save;	/* dont read anything, just switch buffers */
	buf_end = be_save;
	bp_save = be_save = 0;
	if (buf_ptr < buf_end)
	    return;		/* only return if there is really something in
				 * this buffer */
    }
    for (p = in_buffer;;) {
	if (p >= in_buffer_limit) {
	    int size = (in_buffer_limit - in_buffer) * 2 + 10;
	    int offset = p - in_buffer;
	    buf2 = realloc(in_buffer, size);
	    if (buf2 == NULL)
		errx(1, "input line too long");
	    in_buffer = buf2;
	    p = in_buffer + offset;
	    in_buffer_limit = in_buffer + size - 2;
	}
	if ((i = getc(f)) == EOF) {
		*p++ = ' ';
		*p++ = '\n';
		had_eof = true;
		break;
	}
	*p++ = i;
	if (i == '\n')
		break;
    }
    buf_ptr = in_buffer;
    buf_end = p;
    if (p - 3 >= in_buffer && p[-2] == '/' && p[-3] == '*') {
	if (in_buffer[3] == 'I' && strncmp(in_buffer, "/**INDENT**", 11) == 0)
	    fill_buffer();	/* flush indent error message */
	else {
	    int         com = 0;

	    p = in_buffer;
	    while (*p == ' ' || *p == '\t')
		p++;
	    if (*p == '/' && p[1] == '*') {
		p += 2;
		while (*p == ' ' || *p == '\t')
		    p++;
		if (p[0] == 'I' && p[1] == 'N' && p[2] == 'D' && p[3] == 'E'
			&& p[4] == 'N' && p[5] == 'T') {
		    p += 6;
		    while (*p == ' ' || *p == '\t')
			p++;
		    if (*p == '*')
			com = 1;
		    else if (*p == 'O') {
			if (*++p == 'N')
			    p++, com = 1;
			else if (*p == 'F' && *++p == 'F')
			    p++, com = 2;
		    }
		    while (*p == ' ' || *p == '\t')
			p++;
		    if (p[0] == '*' && p[1] == '/' && p[2] == '\n' && com) {
			if (s_com != e_com || s_lab != e_lab || s_code != e_code)
			    dump_line();
			if (!(inhibit_formatting = com - 1)) {
			    n_real_blanklines = 0;
			    postfix_blankline_requested = 0;
			    prefix_blankline_requested = 0;
			    suppress_blanklines = 1;
			}
		    }
		}
	    }
	}
    }
    if (inhibit_formatting) {
	p = in_buffer;
	do
	    putc(*p, output);
	while (*p++ != '\n');
    }
    return;
}

/*
 * Copyright (C) 1976 by the Board of Trustees of the University of Illinois
 * 
 * All rights reserved
 * 
 * 
 * NAME: pad_output
 * 
 * FUNCTION: Writes tabs and spaces to move the current column up to the desired
 * position.
 * 
 * ALGORITHM: Put tabs and/or blanks into pobuf, then write pobuf.
 * 
 * PARAMETERS: current		integer		The current column target
 *             target 		integer		The desired column
 * 
 * RETURNS: Integer value of the new column.  (If current >= target, no action is
 * taken, and current is returned.
 * 
 * GLOBALS: None
 * 
 * CALLS: write (sys)
 * 
 * CALLED BY: dump_line
 * 
 * HISTORY: initial coding 	November 1976	D A Willcox of CAC
 * 
 */
int
pad_output(int current, int target)
{
    int curr;		/* internal column pointer */
    int tcur;

    if (troff)
	fprintf(output, "\\h'|%dp'", (target - 1) * 7);
    else {
	if (current >= target)
	    return (current);	/* line is already long enough */
	curr = current;
	if (use_tabs) {
		while ((tcur = ((curr - 1) & tabmask) + tabsize + 1) <= target) {
			putc('\t', output);
			curr = tcur;
		}
	}
	while (curr++ < target)
	    putc(' ', output);	/* pad with final blanks */
    }
    return (target);
}

/*
 * Copyright (C) 1976 by the Board of Trustees of the University of Illinois
 * 
 * All rights reserved
 * 
 * 
 * NAME: count_spaces
 * 
 * FUNCTION: Find out where printing of a given string will leave the current
 * character position on output.
 * 
 * ALGORITHM: Run thru input string and add appropriate values to current
 * position.
 * 
 * RETURNS: Integer value of position after printing "buffer" starting in column
 * "current".
 * 
 * HISTORY: initial coding 	November 1976	D A Willcox of CAC
 * 
 */
int
count_spaces(int current, char *buffer)
{
    char *buf;		/* used to look thru buffer */
    int cur;		/* current character counter */

    cur = current;

    for (buf = buffer; *buf != '\0'; ++buf) {
	switch (*buf) {

	case '\n':
	case 014:		/* form feed */
	    cur = 1;
	    break;

	case '\t':
	    cur = ((cur - 1) & tabmask) + tabsize + 1;
	    break;

	case 010:		/* backspace */
	    --cur;
	    break;

	default:
	    ++cur;
	    break;
	}			/* end of switch */
    }				/* end of for loop */
    return (cur);
}

int	found_err;

void
diag(int level, const char *msg, ...)
{
    va_list ap;

    va_start(ap, msg);
    if (level)
	found_err = 1;
    if (output == stdout) {
	fprintf(stdout, "/**INDENT** %s@@%d: ", level == 0 ? "Warning" : "Error", line_no);
	vfprintf(stdout, msg, ap);
	fprintf(stdout, " */\n");
    }
    else {
	fprintf(stderr, "%s@@%d: ", level == 0 ? "Warning" : "Error", line_no);
	vfprintf(stderr, msg, ap);
	fprintf(stderr, "\n");
    }
    va_end(ap);
}

void
writefdef(struct fstate *f, int nm)
{
    fprintf(output, ".ds f%c %s\n.nr s%c %d\n",
	    nm, f->font, nm, f->size);
}

char       *
chfont(struct fstate *of, struct fstate *nf, char *s)
{
    if (of->font[0] != nf->font[0]
	    || of->font[1] != nf->font[1]) {
	*s++ = '\\';
	*s++ = 'f';
	if (nf->font[1]) {
	    *s++ = '(';
	    *s++ = nf->font[0];
	    *s++ = nf->font[1];
	}
	else
	    *s++ = nf->font[0];
    }
    if (nf->size != of->size) {
	*s++ = '\\';
	*s++ = 's';
	if (nf->size < of->size) {
	    *s++ = '-';
	    *s++ = '0' + of->size - nf->size;
	}
	else {
	    *s++ = '+';
	    *s++ = '0' + nf->size - of->size;
	}
    }
    return s;
}

void
parsefont(struct fstate *f, char *s0)
{
    char *s = s0;
    int         sizedelta = 0;
    bzero(f, sizeof *f);
    while (*s) {
	if (isdigit((unsigned char)*s))
	    f->size = f->size * 10 + *s - '0';
	else if (isupper((unsigned char)*s))
	    if (f->font[0])
		f->font[1] = *s;
	    else
		f->font[0] = *s;
	else if (*s == 'c')
	    f->allcaps = 1;
	else if (*s == '+')
	    sizedelta++;
	else if (*s == '-')
	    sizedelta--;
	else
	    errx(1, "bad font specification: %s", s0);
	s++;
    }
    if (f->font[0] == 0)
	f->font[0] = 'R';
    if (bodyf.size == 0)
	bodyf.size = 11;
    if (f->size == 0)
	f->size = bodyf.size + sizedelta;
    else if (sizedelta > 0)
	f->size += bodyf.size;
    else
	f->size = bodyf.size - f->size;
}
@


1.13
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.12 2013/06/20 06:28:15 jsg Exp $	*/
a526 1
/* VARARGS2 */
d528 1
a528 1
diag(int level, char *msg, ...)
@


1.12
log
@add ut/nut flags to indent to enable/disable tabs.

based on FreeBSD svn rev 131184.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.11 2009/10/27 23:59:39 deraadt Exp $	*/
d229 1
a229 1
		while (e_com > com_st && isspace(e_com[-1]))
d593 1
a593 1
	if (isdigit(*s))
d595 1
a595 1
	else if (isupper(*s))
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.10 2005/05/15 03:27:04 millert Exp $	*/
d461 5
a465 3
	while ((tcur = ((curr - 1) & tabmask) + tabsize + 1) <= target) {
	    putc('\t', output);
	    curr = tcur;
@


1.10
log
@When checking for comment characters using negative pointer arithmetic
make sure that we don't peek at memory outside the string boundaries.
Fixes a core dump with mmap malloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.9 2004/07/20 03:50:26 deraadt Exp $	*/
a32 5

#ifndef lint
/*static char sccsid[] = "@@(#)io.c	8.1 (Berkeley) 6/6/93";*/
static char rcsid[] = "$OpenBSD: io.c,v 1.9 2004/07/20 03:50:26 deraadt Exp $";
#endif /* not lint */
@


1.9
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.8 2003/09/26 22:23:28 tedu Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: io.c,v 1.8 2003/09/26 22:23:28 tedu Exp $";
d375 1
a375 1
    if (p[-2] == '/' && p[-3] == '*') {
@


1.8
log
@better realloc.  ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.7 2003/06/03 02:56:09 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: io.c,v 1.7 2003/06/03 02:56:09 millert Exp $";
d52 1
a52 1
dump_line()
d286 1
a286 1
compute_code_target()
d313 1
a313 1
compute_label_target()
d338 1
a338 1
fill_buffer()
d440 1
a440 1
 * nteger		The desired column
d455 1
a455 5
pad_output(current, target)	/* writes tabs and blanks (if necessary) to
				 * get the current output position up to the
				 * target column */
    int         current;	/* the current column value */
    int         target;		/* position we want it at */
d497 1
a497 7
count_spaces(current, buffer)
/*
 * this routine figures out where the character position will be after
 * printing the text in buffer starting at column "current"
 */
    int         current;
    char       *buffer;
d553 1
a553 3
writefdef(f, nm)
    struct fstate *f;
    int           nm;
d560 1
a560 3
chfont(of, nf, s)
    struct fstate *of, *nf;
    char       *s;
d590 1
a590 3
parsefont(f, s0)
    struct fstate *f;
    char       *s0;
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.6 2002/10/04 15:27:21 mickey Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: io.c,v 1.6 2002/10/04 15:27:21 mickey Exp $";
d340 1
a340 1
    char *p;
d356 2
a357 2
	    in_buffer = (char *) realloc(in_buffer, size);
	    if (in_buffer == NULL)
d359 1
@


1.6
log
@fprintf+exit vs errx
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.5 2002/02/19 19:39:38 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d36 1
a36 1
static char rcsid[] = "$OpenBSD: io.c,v 1.5 2002/02/19 19:39:38 millert Exp $";
@


1.5
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.4 2001/01/08 07:14:42 pjanzen Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: io.c,v 1.4 2001/01/08 07:14:42 pjanzen Exp $";
d628 2
a629 4
	else {
	    fprintf(stderr, "indent: bad font specification: %s\n", s0);
	    exit(1);
	}
@


1.4
log
@Fix various warnings, merge lite-2, and tidy a bit; also, cast some
pointer arithmetic to int where needed.  Mostly from NetBSD.
Fix some buffer overflows pointed out in PR 1446 by gluk@@ptci.ru,
and check some {m,re}allocs.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.3 1997/07/25 22:00:46 mickey Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: io.c,v 1.3 1997/07/25 22:00:46 mickey Exp $";
d47 1
a540 6
#if __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a544 1
#if __STDC__
a545 6
#else
diag(level, msg, va_alist)
	int   level;
	char *msg;
	va_dcl
#endif
d547 1
a547 6
	va_list ap;
#if __STDC__
	va_start(ap, msg);
#else
	va_start(ap);
#endif
d549 1
@


1.3
log
@use err(3), some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.2 1996/06/26 05:34:31 deraadt Exp $	*/
d5 1
a5 1
 * Copyright (c) 1980 The Regents of the University of California.
d39 2
a40 2
/*static char sccsid[] = "from: @@(#)io.c	5.15 (Berkeley) 2/26/91";*/
static char rcsid[] = "$OpenBSD: io.c,v 1.2 1996/06/26 05:34:31 deraadt Exp $";
d52 1
a52 1
static      paren_target;
d61 2
a62 3
    register int cur_col,
                target_col;
    static      not_first_line;
d86 1
a86 1
	if (prefix_blankline_requested && not_first_line)
d90 1
a90 2
	    }
	    else {
d94 1
d117 5
a121 3
		register char *s = s_lab;
		if (e_lab[-1] == '\n') e_lab--;
		do putc(*s++, output);
d127 1
a127 1
			    e_lab - s, s);
d129 1
a129 1
	    else fprintf(output, "%.*s", e_lab - s_lab, s_lab);
d138 1
a138 1
	    register char *p;
d146 1
a146 1
		register    i;
d160 1
a160 1
	if (s_com != e_com)
d162 2
a163 2
		int         all_here = 0;
		register char *p;
d189 1
a189 1
			register char *follow = p;
d217 3
a219 4
	    }
	    else {		/* print comment, if any */
		register    target = ps.com_col;
		register char *com_st = s_com;
d241 1
a241 1
		    if (star_comment_cont && (com_st[1] != '*' || e_com <= com_st + 1))
d246 1
d253 1
d291 1
a291 1
    register    target_col = ps.ind_size * ps.ind_level + 1;
d293 1
d298 2
a299 2
	    register    w;
	    register    t = paren_target;
d343 3
a345 3
    register char *p;
    register int i;
    register FILE *f = input;
d357 2
a358 2
	    register size = (in_buffer_limit - in_buffer) * 2 + 10;
	    register offset = p - in_buffer;
d360 1
a360 1
	    if (in_buffer == 0)
d397 1
a397 1
		    else if (*p == 'O')
d402 1
d463 2
a464 2
    register int curr;		/* internal column pointer */
    register int tcur;
d511 2
a512 2
    register char *buf;		/* used to look thru buffer */
    register int cur;		/* current character counter */
d540 6
d547 1
d550 5
a554 1
diag(level, msg, a, b)
d556 2
d559 7
d570 1
a570 1
	fprintf(stdout, msg, a, b);
d575 1
a575 1
	fprintf(stderr, msg, a, b);
d578 1
d583 2
a584 1
    register struct fstate *f;
d592 1
a592 2
    register struct fstate *of,
               *nf;
d624 1
a624 1
    register struct fstate *f;
d627 1
a627 1
    register char *s = s0;
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: io.c,v 1.1.1.1 1995/10/18 08:45:25 deraadt Exp $";
d47 1
d54 1
d286 1
d312 1
d337 1
a337 1
int
d358 1
a358 1
		err("input line too long");
d452 1
d538 1
d556 1
d597 1
a597 1

@


1.1
log
@Initial revision
@
text
@d1 2
d40 1
a40 1
static char rcsid[] = "$Id: io.c,v 1.2 1993/08/01 18:14:32 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
