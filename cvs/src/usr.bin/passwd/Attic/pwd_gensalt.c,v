head	1.30;
access;
symbols
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.27.0.20
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.18
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.14
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.12
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.10
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.8
	OPENBSD_5_0:1.27.0.6
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.26.0.10
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.12
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.8
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.6
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.4
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.22.0.6
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.4
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.12
	OPENBSD_2_8:1.9.0.10
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.6
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7;
locks; strict;
comment	@ * @;


1.30
date	2015.10.24.15.59.51;	author tedu;	state dead;
branches;
next	1.29;
commitid	29TBSYFBMUKQijt0;

1.29
date	2014.11.01.17.48.00;	author tedu;	state Exp;
branches;
next	1.28;
commitid	qfJzoYj2Pbty7S96;

1.28
date	2014.09.17.17.58.41;	author kspillner;	state Exp;
branches;
next	1.27;
commitid	JuEPe4PEA50JUrwf;

1.27
date	2010.07.11.15.53.12;	author dhill;	state Exp;
branches;
next	1.26;

1.26
date	2007.07.06.13.09.36;	author thib;	state Exp;
branches;
next	1.25;

1.25
date	2006.04.02.04.13.08;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.02.01.00.18;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.30.21.06.29;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.20.15.05.59;	author moritz;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.02.08.03.55;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.15.17.23.44;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.13.21.29.12;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.13.21.09.48;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.02.21.04.10;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.05.15.56.27;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.21.15.02.03;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.28.22.28.17;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.27.21.12.54;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.50;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.18.21.09.24;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.07.05.21.08.32;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	98.07.04.18.27.04;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.04.10.20.04.54;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.03.27.23.02.58;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.03.27.00.36.32;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.03.27.00.30.54;	author weingart;	state Exp;
branches;
next	1.3;

1.3
date	97.03.27.00.05.41;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	97.02.16.20.08.59;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	97.02.14.23.27.29;	author provos;	state Exp;
branches;
next	;


desc
@@


1.30
log
@the last user of gensalt has been removed. remove the file.
@
text
@/*	$OpenBSD: pwd_gensalt.c,v 1.29 2014/11/01 17:48:00 tedu Exp $ */

/*
 * Copyright 1997 Niels Provos <provos@@physnet.uni-hamburg.de>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <err.h>
#include <grp.h>
#include <pwd.h>
#include <time.h>
#include <login_cap.h>

void	to64(char *, u_int32_t, int n);
int	pwd_gensalt(char *, int, login_cap_t *, char);

#define	CIPHER_DEF		"blowfish,8"

int
pwd_gensalt(char *salt, int saltlen, login_cap_t *lc, char type)
{
	char *next, *now, *oldnext;

	*salt = '\0';

	next = login_getcapstr(lc, "localcipher", NULL, NULL);
	if (next == NULL && (next = strdup(CIPHER_DEF)) == NULL) {
		warn(NULL);
		return 0;
	}

	oldnext = next;
	now = strsep(&next, ",");
	if (!strcmp(now, "blowfish")) {
		int rounds = 8;

		if (next)
			rounds = atoi(next);
		if (rounds < 4)
			rounds = 4;
		if (rounds > 31)
			rounds = 31;
		strlcpy(salt, bcrypt_gensalt(rounds), saltlen);
	} else {
		warnx("Unknown option %s.", now);
		free(oldnext);
		return 0;
	}
	free(oldnext);
	return 1;
}

static unsigned char itoa64[] =	 /* 0 ... 63 => ascii - 64 */
	"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

void
to64(char *s, u_int32_t v, int n)
{
	while (--n >= 0) {
		*s++ = itoa64[v&0x3f];
		v >>= 6;
	}
}
@


1.29
log
@remove support for creating any password style that's not blowfish.
this also effectively retires the ypcipher cap. it's time for DES crypt
to die (especially over network traffic!) and a multi stage rollout of
upgrading login.conf first would take too long. one cipher standard is
good enough. this doesn't prevent auth yet, just new passwords.
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_gensalt.c,v 1.28 2014/09/17 17:58:41 kspillner Exp $ */
@


1.28
log
@Increase number of blowfish rounds to 8 by default when not specified in
login.conf.

ok deraadt@@ doug@@ millert@@
"please commit" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_gensalt.c,v 1.27 2010/07/11 15:53:12 dhill Exp $ */
d46 1
a46 2
#define	YPCIPHER_DEF		"old"
#define	LOCALCIPHER_DEF		"blowfish,8"
d55 4
a58 16
	switch (type) {
	case 'y':
		next = login_getcapstr(lc, "ypcipher", NULL, NULL);
		if (next == NULL && (next = strdup(YPCIPHER_DEF)) == NULL) {
			warn(NULL);
			return 0;
		}
		break;
	case 'l':
	default:
		next = login_getcapstr(lc, "localcipher", NULL, NULL);
		if (next == NULL && (next = strdup(LOCALCIPHER_DEF)) == NULL) {
			warn(NULL);
			return 0;
		}
		break;
d63 1
a63 36
	if (!strcmp(now, "old")) {
		if (saltlen < 3) {
			free(oldnext);
			return 0;
		}
		to64(&salt[0], arc4random(), 2);
		salt[2] = '\0';
	} else if (!strcmp(now, "newsalt")) {
		u_int32_t rounds = 7250;

		if (next)
			rounds = atol(next);
		if (saltlen < 10) {
			free(oldnext);
			return 0;
		}
		/* Check rounds, 24 bit is max */
		if (rounds < 7250)
			rounds = 7250;
		else if (rounds > 0xffffff)
			rounds = 0xffffff;
		salt[0] = _PASSWORD_EFMT1;
		to64(&salt[1], (u_int32_t)rounds, 4);
		to64(&salt[5], arc4random(), 4);
		salt[9] = '\0';
	} else if (!strcmp(now, "md5")) {
		if (saltlen < 13) {	/* $1$8salt$\0 */
			free(oldnext);
			return 0;
		}

		strlcpy(salt, "$1$", saltlen);
		to64(&salt[3], arc4random(), 4);
		to64(&salt[7], arc4random(), 4);
		strlcpy(&salt[11], "$", saltlen - 11);
	} else if (!strcmp(now, "blowfish")) {
@


1.27
log
@bcrypt_gensalt is already declared in pwd.h

"sure" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_gensalt.c,v 1.26 2007/07/06 13:09:36 thib Exp $ */
d47 1
a47 1
#define	LOCALCIPHER_DEF		"blowfish,6"
d112 1
a112 1
		int rounds = 6;
@


1.26
log
@dont inlucde <sys/syslimits.h> directly.
no binary change
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_gensalt.c,v 1.25 2006/04/02 04:13:08 deraadt Exp $ */
a43 1
char	*bcrypt_gensalt(u_int8_t);
@


1.25
log
@oops, to64() is shared.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_gensalt.c,v 1.24 2006/04/02 01:00:18 deraadt Exp $ */
a32 1
#include <sys/syslimits.h>
@


1.24
log
@avoid lvalue cast by making local function be unsigned to begin with
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_gensalt.c,v 1.23 2006/03/30 21:06:29 deraadt Exp $ */
d44 3
a46 3
static void	to64(char *, u_int32_t, int n);
char		*bcrypt_gensalt(u_int8_t);
int		pwd_gensalt(char *, int, login_cap_t *, char);
d135 1
a135 1
static void
@


1.23
log
@minimal lint happiness, round 1
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_gensalt.c,v 1.22 2004/12/20 15:05:59 moritz Exp $ */
d44 3
a46 3
void	to64(char *, int32_t, int n);
char	*bcrypt_gensalt(u_int8_t);
int	pwd_gensalt(char *, int, login_cap_t *, char);
d135 2
a136 2
void
to64(char *s, int32_t v, int n)
d140 1
a140 1
		(unsigned)v >>= 6;
@


1.22
log
@o some missing free()'s in error paths
o use FD_CLOEXEC instead of 1
o fix a crash when the round number of
  localcipher in the default section
  in login.conf was ommitted. noted by
  mpech@@

ok mpech@@, otto@@, millert@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_gensalt.c,v 1.21 2004/11/02 08:03:55 otto Exp $ */
d100 1
a100 1
		to64(&salt[1], (u_int32_t) rounds, 4);
d140 1
a140 1
		v >>= 6;
@


1.21
log
@Do not modify ro mem and plug a mem leak. Happens when no cipher
spec is found in login.conf.  Found by Jerome Loyet. ok henning@@
hshoexer@@ and millert@@ on an earlier version.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_gensalt.c,v 1.20 2004/07/15 17:23:44 millert Exp $ */
d86 1
a86 1
		u_int32_t rounds = atol(next);
d88 2
d114 1
a114 1
		int rounds = atoi(next);
d116 2
d120 2
a123 1
		strlcpy(salt, ":", saltlen);
d125 2
@


1.20
log
@Minor simplification.  Pass values in to login_getcapstr for "default" and
"error".  No longer need check for NULL and set a default value manually.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_gensalt.c,v 1.19 2004/07/13 21:29:12 millert Exp $ */
d54 1
a54 1
	char *next, *now;
d60 5
a64 2
		next = login_getcapstr(lc, "ypcipher", YPCIPHER_DEF,
		    YPCIPHER_DEF);
d68 5
a72 2
		next = login_getcapstr(lc, "localcipher", LOCALCIPHER_DEF,
		    LOCALCIPHER_DEF);
d76 1
d79 2
a80 1
		if (saltlen < 3)
d82 1
d88 2
a89 1
		if (saltlen < 10)
d91 1
d102 2
a103 1
		if (saltlen < 13)	/* $1$8salt$\0 */
d105 1
d121 1
@


1.19
log
@Simplify some things now that we only have login.conf to worry about
and fix two bugs introduced in the last commit (a duplicate free
and reversed logic for the default cipher types).
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_gensalt.c,v 1.18 2004/07/13 21:09:48 millert Exp $ */
d48 3
d54 1
a54 1
	char *next, *now, *cipher;
d60 2
a61 1
		cipher = "ypcipher";
d65 2
a66 1
		cipher = "localcipher";
a67 7
	}

	if ((next = login_getcapstr(lc, cipher, NULL, NULL)) == NULL) {
		if (type == 'y')
			next = "old";
		else		
			next = "blowfish,6";
@


1.18
log
@passwd.conf has been deprecated since login.conf was imported.
Today it finally dies.  Based on a diff from Gabriel Kihlman.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_gensalt.c,v 1.17 2003/07/02 21:04:10 deraadt Exp $ */
d51 1
a51 1
	char	option[LINE_MAX], *next, *now, *cipher;
a52 1
	option[0] = '\0';
d65 3
a67 11
	/*
	 * Check login.conf
	 */
	if ((next = login_getcapstr(lc, cipher, NULL, NULL)) != NULL) {
		strlcpy(option, next, sizeof(option));
		free(next);
	} 

	if (*option == 0) {
		if (type == 'l')
			strlcpy(option, "old", sizeof(option));
d69 1
a69 1
			strlcpy(option, "blowfish,6", sizeof(option));
a71 1
	next = option;
@


1.17
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_gensalt.c,v 1.16 2003/04/05 15:56:27 deraadt Exp $ */
a40 1
#include <util.h>
d46 1
a46 1
int	pwd_gensalt(char *, int, struct passwd *, login_cap_t *, char);
d49 1
a49 1
pwd_gensalt(char *salt, int saltlen, struct passwd *pwd, login_cap_t *lc, char type)
d53 1
d67 1
a67 1
	 * Check login.conf, falling back onto the deprecated passwd.conf
a68 1
	/* XXX - when passwd.conf goes away completely, add a default value */
d72 1
a72 2
	} else {
		pw_getconf(option, LINE_MAX, pwd->pw_name, cipher);
d74 5
a78 20
		/* Try to find an entry for the group */
		if (*option == 0) {
			struct group *grp;
			char grpkey[LINE_MAX];

			grp = getgrgid(pwd->pw_gid);
			if (grp != NULL) {
				snprintf(grpkey, LINE_MAX, ":%s",
				    grp->gr_name);
				pw_getconf(option, LINE_MAX, grpkey, cipher);
			}
			if (grp != NULL && *option == 0 &&
			    strchr(pwd->pw_name, '.') == NULL) {
				snprintf(grpkey, LINE_MAX, ".%s",
				    grp->gr_name);
				pw_getconf(option, LINE_MAX, grpkey, cipher);
			}
			if (*option == 0)
				pw_getconf(option, LINE_MAX, "default", cipher);
		}
@


1.16
log
@strlcpy; ok matthieu henning miod
@
text
@d1 2
a2 1
/* $OpenBSD: pwd_gensalt.c,v 1.15 2002/11/21 15:02:03 henning Exp $ */
d47 1
@


1.15
log
@typo in error message; Tor Houghton
@
text
@d1 1
a1 1
/* $OpenBSD: pwd_gensalt.c,v 1.14 2002/06/28 22:28:17 deraadt Exp $ */
d124 1
a124 1
		strcpy(&salt[11], "$");
@


1.14
log
@various cleanups; ok millert
@
text
@d1 1
a1 1
/* $OpenBSD: pwd_gensalt.c,v 1.13 2002/05/27 21:12:54 itojun Exp $ */
d133 1
a133 1
		warnx("Unkown option %s.", now);
@


1.13
log
@support ":" prefix as group name, as username can contain ".".
(still support "." as welll).  passwd.conf support will go away in a
couple of months anyways... ok by millert
@
text
@d1 1
a1 1
/* $OpenBSD: pwd_gensalt.c,v 1.12 2002/02/16 21:27:50 millert Exp $ */
d44 2
a45 1
void to64(char *, int32_t, int n);
d48 1
a48 6
pwd_gensalt(salt, max, pwd, lc, type)
	char   *salt;
	int     max;
	struct passwd *pwd;
	login_cap_t *lc;
	char    type;
d50 2
a51 4
	char   *bcrypt_gensalt(u_int8_t);
	char    option[LINE_MAX];
	char   *next, *now;
	char   *cipher;
d56 1
a56 1
	        cipher = "ypcipher";
d60 1
a60 1
	        cipher = "localcipher";
d81 1
a81 1
				snprintf(grpkey, LINE_MAX-1, ":%s",
a82 1
				grpkey[LINE_MAX-1] = 0;
d87 1
a87 1
				snprintf(grpkey, LINE_MAX-1, ".%s",
a88 1
				grpkey[LINE_MAX-1] = 0;
d99 1
a99 1
		if (max < 3)
d105 2
a106 1
		if (max < 10)
d112 1
a112 1
		        rounds = 0xffffff;
d118 1
a118 1
		if (max < 13)  /* $1$8salt$\0 */
d120 2
a121 1
		strcpy(salt, "$1$");
d126 2
a127 1
		int     rounds = atoi(next);
d130 1
a130 2
		strncpy(salt, bcrypt_gensalt(rounds), max - 1);
		salt[max - 1] = 0;
d132 1
a132 1
		strcpy(salt, ":");
d142 1
a142 4
to64(s, v, n)
	char *s;
	int32_t v;
	int n;
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/* $OpenBSD: pwd_gensalt.c,v 1.11 2001/11/19 19:02:15 mpech Exp $ */
d87 7
@


1.11
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: pwd_gensalt.c,v 1.10 2001/06/18 21:09:24 millert Exp $ */
d44 1
a44 1
void to64 __P((char *, int32_t, int n));
d54 1
a54 1
	char   *bcrypt_gensalt __P((u_int8_t));
@


1.10
log
@o move passwd.conf variables into login.conf
o no longer install passwd.conf (but it is used if it exists and the
  needed info is not in login.conf)
o added passwordtime and minpasswordlen login.conf variables
@
text
@d1 1
a1 1
/* $OpenBSD: pwd_gensalt.c,v 1.9 1998/07/05 21:08:32 provos Exp $ */
d142 3
a144 3
	register char *s;
	register int32_t v;
	register int n;
@


1.9
log
@newsalt uses 24-bit count, and not 32-bit
@
text
@d1 1
a1 1
/* $OpenBSD: pwd_gensalt.c,v 1.8 1998/07/04 18:27:04 provos Exp $ */
d42 1
d47 1
a47 1
pwd_gensalt(salt, max, pwd, type)
d51 1
d70 24
a93 12
	pw_getconf(option, LINE_MAX, pwd->pw_name, cipher);

	/* Try to find an entry for the group */
	if (*option == 0) {
	        struct group *grp;
	        char grpkey[LINE_MAX];

	        grp = getgrgid(pwd->pw_gid);
	        if (grp != NULL) {
                        snprintf(grpkey, LINE_MAX-1, ".%s", grp->gr_name);
			grpkey[LINE_MAX-1] = 0;
			pw_getconf(option, LINE_MAX, grpkey, cipher);
a94 2
		if (*option == 0)
		        pw_getconf(option, LINE_MAX, "default", cipher);
@


1.8
log
@enable variable number of rounds for extended crypt, this is the crypt
variant used by BSDI, reminded of this fact by Solar Designer.
@
text
@d1 1
a1 1
/* $OpenBSD: pwd_gensalt.c,v 1.7 1997/04/10 20:04:54 provos Exp $ */
a93 2
		if (rounds < 725)
			rounds = 725;
d96 5
@


1.7
log
@enable .group entries in /etc/passwd.conf
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d93 3
d99 1
a99 1
		to64(&salt[1], (int32_t) (29 * 25), 4);
@


1.6
log
@pretty and one 64bit thingy
@
text
@d1 1
d33 1
d38 1
d55 1
d60 1
a60 1
		pw_getconf(option, LINE_MAX, pwd->pw_name, "ypcipher");
d64 1
a64 1
		pw_getconf(option, LINE_MAX, pwd->pw_name, "localcipher");
d66 17
@


1.5
log
@use arc4random instead of random
@
text
@d40 1
a40 1
void to64( char *, long, int n);
d67 1
a67 1
		if( max < 3 )
d72 1
a72 1
		if( max < 10 )
d75 1
a75 1
		to64(&salt[1], (long) (29 * 25), 4);
d79 1
a79 1
		if( max < 13 )  /* $1$8salt$\0 */
d98 2
a99 2
static unsigned char itoa64[] =         /* 0 ... 63 => ascii - 64 */
        "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
d101 5
a105 4
void to64(s, v, n)
        register char *s;
        register long v;
        register int n;
d107 4
a110 4
        while (--n >= 0) {
                *s++ = itoa64[v&0x3f];
                v >>= 6;
        }
@


1.4
log
@Slight cleanup, more needed
@
text
@d69 1
a69 2
		(void) srandom((int) time((time_t *) NULL));
		to64(&salt[0], random(), 2);
a73 1
		(void) srandom((int) time((time_t *) NULL));
d76 1
a76 1
		to64(&salt[5], random(), 4);
d82 2
a83 3
		(void) srandom((int) time((time_t *) NULL));
		to64(&salt[3], random(), 4);
		to64(&salt[7], random(), 4);
@


1.3
log
@support for md5 passwords
@
text
@d33 1
d38 1
@


1.2
log
@cleaned up, moved pw_getconf to libutil, removed _'s in option names
@
text
@d70 26
a95 20
	} else
		if (!strcmp(now, "newsalt")) {
			if( max < 10 )
				return 0;
			(void) srandom((int) time((time_t *) NULL));
			salt[0] = _PASSWORD_EFMT1;
			to64(&salt[1], (long) (29 * 25), 4);
			to64(&salt[5], random(), 4);
			salt[9] = '\0';
		} else
			if (!strcmp(now, "blowfish")) {
				int     rounds = atoi(next);
				if (rounds < 4)
					rounds = 4;
				strncpy(salt, bcrypt_gensalt(rounds), max - 1);
				salt[max - 1] = 0;
			} else {
				strcpy(salt, ":");
				warnx("Unkown option %s.", now);
			}
@


1.1
log
@include blowfish cipher - free config of which cipher to use
@
text
@d15 1
a15 1
 *      This product includes software developed by Theo de Raadt.
d31 1
d36 1
d38 1
d40 1
a40 119
#define NUM_OPTIONS	2	/* Number of hardcoded defaults */
#define LINE_MAX	100	/* Max. length of one config file */

static const char options[NUM_OPTIONS][2][80] =
{
	{"local_cipher", "blowfish,4"},
	{"yp_cipher", "old"}
};
/* Read lines and removes trailers. */

static int
read_line(fp, line, max)
	FILE   *fp;
	char   *line;
	int     max;
{
	char   *p, *c;
	/* Read one line of config */
	if (fgets(line, max, fp) == 0)
		return 0;
	if (!(p = strchr(line, '\n'))) {
		warnx("line too long");
		return 0;
	}
	*p = '\0';

	/* Remove comments */
	if ((p = strchr(line, '#')))
		*p = '\0';

	/* Remove trailing spaces */
	p = line;
	while (isspace(*p))
		p++;
	memcpy(line, p, strlen(p) + 1);

	p = line + strlen(line) - 1;
	while (isspace(*p))
		p--;
	*(p + 1) = '\0';
	return 1;
}


static const char *
pwd_default(option)
	char   *option;
{
	int     i;
	for (i = 0; i < NUM_OPTIONS; i++)
		if (!strcasecmp(options[i][0], option))
			return options[i][1];
	return NULL;
}

void
pwd_gettype(data, max, key, option)
	char   *data;
	int     max;
	char   *key;
	char   *option;
{
	FILE   *fp;
	char    line[LINE_MAX];
	static char result[LINE_MAX];
	int     defaultw;
	int     keyw;
	int     got;
	result[0] = '\0';
	if ((fp = fopen(_PATH_PASSWDCONF, "r")) == NULL) {
		strncpy(data, pwd_default(option), max - 1);
		data[max - 1] = '\0';
		return;
	}
	defaultw = 0;
	keyw = 0;
	got = 0;
	while (!keyw && (got || read_line(fp, line, LINE_MAX))) {
		got = 0;
		if (!strcmp("default:", line))
			defaultw = 1;
		if (!strncmp(key, line, strlen(key)) &&
		    line[strlen(key)] == ':')
			keyw = 1;

		/* Now we found default or specified key */
		if (defaultw || keyw) {
			while (read_line(fp, line, LINE_MAX)) {
				/* Leaving key field */
				if (strchr(line, ':')) {
					got = 1;
					break;
				}
				if (!strncmp(line, option, strlen(option)) &&
				    line[strlen(option)] == '=') {
					char   *p;
					p = line + strlen(option) + 1;
					while (isspace(*p))
						p++;
					strcpy(result, p);
					break;
				}
			}
			if (keyw)
				break;
			defaultw = 0;
		}
	}
	fclose(fp);
	if (!strlen(result)) {
		strncpy(data, pwd_default(option), max - 1);
		data[max - 1] = '\0';
		return;
	}
	strncpy(data, result, max - 1);
	data[max - 1] = '\0';
}

void
a50 2
	if (max < 10)
		return;
d54 1
a54 1
		pwd_gettype(option, LINE_MAX, pwd->pw_name, "yp_cipher");
d58 1
a58 1
		pwd_gettype(option, LINE_MAX, pwd->pw_name, "local_cipher");
d65 2
d69 1
d72 2
d78 1
d90 15
@
