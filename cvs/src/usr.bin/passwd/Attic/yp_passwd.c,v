head	1.38;
access;
symbols
	OPENBSD_5_8:1.35.0.6
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.32.0.22
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.20
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.16
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.14
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.12
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.10
	OPENBSD_5_0:1.32.0.8
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.6
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.4
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.31.0.6
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.30.0.6
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.4
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.29.0.4
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.28.0.8
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.6
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.4
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.12.0.8
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2015.11.26.19.01.47;	author deraadt;	state dead;
branches;
next	1.37;
commitid	0NbTNVgy2y455HVw;

1.37
date	2015.10.25.08.39.26;	author ajacoutot;	state Exp;
branches;
next	1.36;
commitid	cLlYHAKgT7hh5C62;

1.36
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	0Dp7Dy9FuNZesYo2;

1.35
date	2015.01.16.06.40.10;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	Uu5nFG3wCl0LACBb;

1.34
date	2014.11.21.05.13.44;	author tedu;	state Exp;
branches;
next	1.33;
commitid	H7AJhZvkXj2g8HJk;

1.33
date	2014.11.20.14.53.15;	author tedu;	state Exp;
branches;
next	1.32;
commitid	QCpCF0xG1gASOuQP;

1.32
date	2009.10.27.23.59.41;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2008.11.06.05.35.56;	author djm;	state Exp;
branches;
next	1.30;

1.30
date	2007.08.14.13.30.45;	author aanriot;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.30.21.06.29;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2004.07.13.21.09.48;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.12.22.59.28;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.10.21.23.17;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.20.21.24.57;	author maja;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.03.02.56.14;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.28.22.28.17;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.04.00.09.08;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.16.11.54.25;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.16.21.27.50;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.07.04.15.08;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.07.00.10.49;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.18.21.09.24;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.10.20.11.30;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.12.02.19.59;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.01.22.27.51;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.30.16.00.20;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.07.13.02.15.01;	author deraadt;	state Exp;
branches
	1.12.8.1;
next	1.11;

1.11
date	98.07.12.18.05.15;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.02.24.20.46.17;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.09.12.04.12.53;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.03.27.00.30.55;	author weingart;	state Exp;
branches;
next	1.7;

1.7
date	97.02.17.10.34.41;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.02.16.20.09.00;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.02.14.23.27.31;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	96.08.30.13.37.53;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.22.03.53.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.37.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.54;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.54;	author deraadt;	state Exp;
branches;
next	;

1.12.8.1
date	2000.10.06.20.20.59;	author jason;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Delete YP password related code.  As a result, these can also be
pledged.  Keep an eye out for regressions, because they could be
uncomfortable.
ok beck semarie
@
text
@/*	$OpenBSD: yp_passwd.c,v 1.37 2015/10/25 08:39:26 ajacoutot Exp $	*/

/*
 * Copyright (c) 1988 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifdef	YP

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <time.h>
#include <pwd.h>
#include <err.h>
#include <signal.h>
#include <errno.h>
#include <ctype.h>
#include <login_cap.h>
#include <rpc/rpc.h>
#include <rpcsvc/yp_prot.h>
#include <rpcsvc/ypclnt.h>
#define passwd yp_passwd_rec
#include <rpcsvc/yppasswd.h>
#undef passwd

#ifndef _PASSWORD_LEN
#define _PASSWORD_LEN PASS_MAX
#endif

extern int	pwd_check(login_cap_t *, char *);
extern int	pwd_gettries(login_cap_t *);
extern void	kbintr(int);
int		yp_passwd(char *);

char		*ypgetnewpasswd(struct passwd *, login_cap_t *, char **);
struct passwd	*ypgetpwnam(char *, int);
struct passwd	*interpret(struct passwd *, char *, int);

char *domain;

static int
pw_error(char *name, int error, int eval)
{
	if (error) {
		if (name)
			warn("%s", name);
		else
			warn(NULL);
	}

	warnx("YP passwd database: unchanged.");
	exit(eval);
}

int
yp_passwd(char *username)
{
	struct yppasswd yppwd;
	int r, rpcport, status, secure=0;
	struct passwd *pw;
	struct timeval tv;
	login_cap_t *lc;
	CLIENT *client;
	char *master;
	uid_t uid;

	/*
	 * Get local domain
	 */
	if ((r = yp_get_default_domain(&domain)) != 0) {
		warnx("can't get local YP domain. Reason: %s",
		    yperr_string(r));
		return (1);
	}

	/*
	 * Find the host for the passwd map; it should be running
	 * the daemon.
	 */
	if ((r = yp_master(domain, "master.passwd.byname", &master)) == 0) {
		secure=1;
	} else if ((r = yp_master(domain, "passwd.byname", &master)) != 0) {
		warnx("can't find the master YP server. Reason: %s",
		    yperr_string(r));
		return (1);
	}

	/*
	 * Ask the portmapper for the port of the daemon.
	 */
	if ((rpcport = getrpcport(master, YPPASSWDPROG,
	    YPPASSWDPROC_UPDATE, IPPROTO_UDP)) == 0) {
		warnx("master YP server not running yppasswd daemon.");
		warnx("Can't change password.");
		return (1);
	}

	/*
	 * Be sure the port is privileged
	 */
	if (rpcport >= IPPORT_RESERVED) {
		warnx("yppasswd daemon is on an invalid port.");
		return (1);
	}

	/* Get user's login identity */
	if (!(pw = ypgetpwnam(username, secure))) {
		warnx("unknown user %s.", username);
		return (1);
	}
	if ((lc = login_getclass(pw->pw_class)) == NULL) {
		warnx("unable to get login class for user %s.", username);
		return (1);
	}

	uid = getuid();
	if (uid && uid != pw->pw_uid) {
		warnx("you may only change your own password: %s",
		    strerror(EACCES));
		return (1);
	}

	/* prompt for new password */
	yppwd.newpw.pw_passwd = ypgetnewpasswd(pw, lc, &yppwd.oldpass);

	/* tell rpc.yppasswdd */
	yppwd.newpw.pw_name	= pw->pw_name;
	yppwd.newpw.pw_uid	= pw->pw_uid;
	yppwd.newpw.pw_gid	= pw->pw_gid;
	yppwd.newpw.pw_gecos = pw->pw_gecos;
	yppwd.newpw.pw_dir	= pw->pw_dir;
	yppwd.newpw.pw_shell	= pw->pw_shell;

	client = clnt_create(master, YPPASSWDPROG, YPPASSWDVERS, "udp");
	if (client==NULL) {
		warnx("cannot contact yppasswdd on %s: Reason: %s",
		    master, yperr_string(YPERR_YPBIND));
		free(yppwd.newpw.pw_passwd);
		return (YPERR_YPBIND);
	}
	client->cl_auth = authunix_create_default();
	tv.tv_sec = 2;
	tv.tv_usec = 0;
	r = clnt_call(client, YPPASSWDPROC_UPDATE,
	    xdr_yppasswd, &yppwd, xdr_int, &status, tv);
	if (r) {
		printf("rpc to yppasswdd failed.\n");
		free(yppwd.newpw.pw_passwd);
		return (1);
	} else if (status) {
		printf("Couldn't change YP password.\n");
		free(yppwd.newpw.pw_passwd);
		return (1);
	} else {
		printf("The YP password has been changed on %s, "
	 	    "the master YP passwd server.\n", master);
		free(yppwd.newpw.pw_passwd);
		return (0);
	}
}

char *
ypgetnewpasswd(struct passwd *pw, login_cap_t *lc, char **old_pass)
{
	char buf[1024], hash[_PASSWORD_LEN];
	sig_t saveint, savequit;
	int tries, pwd_tries;
	char *p, *pref;

	saveint = signal(SIGINT, kbintr);
	savequit = signal(SIGQUIT, kbintr);

	printf("Changing YP password for %s.\n", pw->pw_name);
	if (old_pass) {
		*old_pass = NULL;

		if (pw->pw_passwd[0]) {
			p = getpass("Old password:");
			if (p == NULL ||
			    strcmp(crypt(p, pw->pw_passwd), pw->pw_passwd)) {
				errno = EACCES;
				pw_error(NULL, 1, 1);
			}
		} else
			p = "";
		*old_pass = strdup(p);
		if (*old_pass == NULL)
			pw_error(NULL, 1, 1);
	}

	pwd_tries = pwd_gettries(lc);

	for (buf[0] = '\0', tries = 0;;) {
		p = getpass("New password:");
		if (p == NULL || *p == '\0')
			pw_error(NULL, 0, p == NULL ? 1 : 0);
		if (strcmp(p, "s/key") == 0) {
			printf("That password collides with a system feature. "
			    "Choose another.\n");
			continue;
		}
		if ((tries++ < pwd_tries || pwd_tries == 0)
		    && pwd_check(lc, p) == 0)
			continue;
		strlcpy(buf, p, sizeof buf);
		p = getpass("Retype new password:");
		if (p != NULL && strcmp(buf, p) == 0)
			break;
		(void)printf("Mismatch; try again, EOF to quit.\n");
	}

	(void)signal(SIGINT, saveint);
	(void)signal(SIGQUIT, savequit);

	pref = login_getcapstr(lc, "localcipher", NULL, NULL);
	if (crypt_newhash(buf, pref, hash, sizeof(hash)) == -1) {
		(void)printf("Couldn't generate hash.\n");
		pw_error(NULL, 0, 0);
	}
	free(pref);
	p = strdup(hash);
	if (p == NULL)
		pw_error(NULL, 1, 1);

	return (p);
}

static char *
pwskip(char *p)
{
	while (*p && *p != ':' && *p != '\n')
		++p;
	if (*p)
		*p++ = 0;
	return (p);
}

struct passwd *
interpret(struct passwd *pwent, char *line, int secure)
{
	char	*p = line;

	pwent->pw_passwd = "*";
	pwent->pw_uid = 0;
	pwent->pw_gid = 0;
	pwent->pw_gecos = "";
	pwent->pw_dir = "";
	pwent->pw_shell = "";
	pwent->pw_change = 0;
	pwent->pw_expire = 0;
	pwent->pw_class = "";

	/* line without colon separators is no good, so ignore it */
	if (!strchr(p, ':'))
		return (NULL);

	pwent->pw_name = p;
	p = pwskip(p);
	pwent->pw_passwd = p;
	p = pwskip(p);
	pwent->pw_uid = (uid_t)strtoul(p, NULL, 10);
	p = pwskip(p);
	pwent->pw_gid = (gid_t)strtoul(p, NULL, 10);
	p = pwskip(p);
	if ( secure == 1 ) {
		pwent->pw_class = p;
		p = pwskip(p);
		pwent->pw_change = (time_t)strtoul(p, NULL, 10);
		p = pwskip(p);
		pwent->pw_expire = (time_t)strtoul(p, NULL, 10);
		p = pwskip(p);
	}
	pwent->pw_gecos = p;
	p = pwskip(p);
	pwent->pw_dir = p;
	p = pwskip(p);
	pwent->pw_shell = p;
	while (*p && *p != '\n')
		p++;
	*p = '\0';
	return (pwent);
}

static char *__yplin;

struct passwd *
ypgetpwnam(char *nam, int secure)
{
	static struct passwd pwent;
	int reason, vallen;
	char *val;

	reason = yp_match(domain,
	    secure ? "master.passwd.byname" : "passwd.byname",
	    nam, strlen(nam), &val, &vallen);
	switch (reason) {
	case 0:
		break;
	default:
		return (NULL);
	}
	val[vallen] = '\0';
	if (__yplin)
		free(__yplin);
	__yplin = malloc(vallen + 1);
	if (__yplin == NULL)
		pw_error(NULL, 1, 1);
	strlcpy(__yplin, val, vallen + 1);
	free(val);

	return (interpret(&pwent, __yplin, secure));
}

#endif	/* YP */
@


1.37
log
@No need to declare pwd_gensalt; it's unused and gone.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.36 2015/08/20 22:32:41 deraadt Exp $	*/
@


1.36
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.35 2015/01/16 06:40:10 deraadt Exp $	*/
a56 1
extern int	pwd_gensalt(char *, int, login_cap_t *, char);
@


1.35
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.34 2014/11/21 05:13:44 tedu Exp $	*/
d333 1
a333 1
	__yplin = (char *)malloc(vallen + 1);
@


1.34
log
@change prototype for crypt_newhash. the login_cap_t is a holdover from its
pwd_gensalt origins, but a string argument works equally work and is more
friendly to consumers beyond local user accounts.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.33 2014/11/20 14:53:15 tedu Exp $	*/
d42 1
@


1.33
log
@switch to using crypt_newhash interface. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.32 2009/10/27 23:59:41 deraadt Exp $	*/
d195 1
a195 1
	char *p;
d242 2
a243 1
	if (crypt_newhash(buf, lc, hash, sizeof(hash)) == -1) {
d247 1
@


1.32
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.31 2008/11/06 05:35:56 djm Exp $	*/
d192 1
a192 2
	static char buf[_PASSWORD_LEN+1];
	char salt[_PASSWORD_LEN];
d238 6
a243 2
	if (!pwd_gensalt(salt, _PASSWORD_LEN, lc, 'y')) {
		(void)printf("Couldn't generate salt.\n");
d246 1
a246 1
	p = strdup(crypt(buf, salt));
a248 2
	(void)signal(SIGINT, saveint);
	(void)signal(SIGQUIT, savequit);
@


1.31
log
@-Wall -Wshadow clean, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.30 2007/08/14 13:30:45 aanriot Exp $	*/
a30 4
#ifndef lint
/*static const char sccsid[] = "from: @@(#)yp_passwd.c	1.0 2/2/93";*/
static const char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.30 2007/08/14 13:30:45 aanriot Exp $";
#endif /* not lint */
@


1.30
log
@error out, instead of producing a warning and displaying that the YP
password has changed, when the rpc.yppasswdd daemon is unreachable.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.29 2006/03/30 21:06:29 deraadt Exp $	*/
d33 1
a33 1
static const char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.29 2006/03/30 21:06:29 deraadt Exp $";
d64 1
d68 1
d73 1
a73 1
pw_error(char *name, int err, int eval)
d75 1
a75 1
	if (err) {
d89 1
a89 1
	struct yppasswd yppasswd;
d155 1
a155 1
	yppasswd.newpw.pw_passwd = ypgetnewpasswd(pw, lc, &yppasswd.oldpass);
d158 6
a163 6
	yppasswd.newpw.pw_name	= pw->pw_name;
	yppasswd.newpw.pw_uid	= pw->pw_uid;
	yppasswd.newpw.pw_gid	= pw->pw_gid;
	yppasswd.newpw.pw_gecos = pw->pw_gecos;
	yppasswd.newpw.pw_dir	= pw->pw_dir;
	yppasswd.newpw.pw_shell	= pw->pw_shell;
d169 1
a169 1
		free(yppasswd.newpw.pw_passwd);
d176 1
a176 1
	    xdr_yppasswd, &yppasswd, xdr_int, &status, tv);
d179 1
a179 1
		free(yppasswd.newpw.pw_passwd);
d183 1
a183 1
		free(yppasswd.newpw.pw_passwd);
d188 1
a188 1
		free(yppasswd.newpw.pw_passwd);
@


1.29
log
@minimal lint happiness, round 1
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.28 2004/07/13 21:09:48 millert Exp $	*/
d33 1
a33 1
static const char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.28 2004/07/13 21:09:48 millert Exp $";
d175 5
a179 3
	if (r)
		warnx("rpc to yppasswdd failed.");
	else if (status) {
d183 5
a188 4
	printf("The YP password has been changed on %s, "
	    "the master YP passwd server.\n", master);
	free(yppasswd.newpw.pw_passwd);
	return (0);
@


1.28
log
@passwd.conf has been deprecated since login.conf was imported.
Today it finally dies.  Based on a diff from Gabriel Kihlman.
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.27 2004/03/12 22:59:28 millert Exp $	*/
d33 1
a33 1
static const char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.27 2004/03/12 22:59:28 millert Exp $";
d317 2
a318 2
			  secure ? "master.passwd.byname" : "passwd.byname",
			  nam, strlen(nam), &val, &vallen);
a323 1
		break;
@


1.27
log
@Remove pw_abort() added in last commit and use the local verson of
pw_error() instead.  OK deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.26 2004/03/10 21:23:17 millert Exp $	*/
d33 1
a33 1
static const char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.26 2004/03/10 21:23:17 millert Exp $";
d60 3
a62 3
extern int	pwd_gensalt(char *, int, struct passwd *, login_cap_t *, char);
extern int	pwd_check(struct passwd *, login_cap_t *, char *);
extern int	pwd_gettries(struct passwd *, login_cap_t *);
d218 1
a218 1
	pwd_tries = pwd_gettries(pw, lc);
d230 1
a230 1
		    && pwd_check(pw, lc, p) == 0)
d238 1
a238 1
	if (!pwd_gensalt(salt, _PASSWORD_LEN, pw, lc, 'y')) {
@


1.26
log
@Check getpass() return value for NULL.  Closes Pr 3706.
With help and OK from otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.25 2004/02/20 21:24:57 maja Exp $	*/
d33 1
a33 1
static const char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.25 2004/02/20 21:24:57 maja Exp $";
d222 2
a223 5
		if (p == NULL || *p == '\0') {
			printf("Password unchanged.\n");
			pw_abort();
			exit(p == NULL ? 1 : 0);
		}
@


1.25
log
@Make passwd understand master.passwd.byname so it can work in a secure
environment.

Patch from llx at hitech dot ch, modified by me. -moj ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.24 2003/06/03 02:56:14 millert Exp $	*/
d33 1
a33 1
static const char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.24 2003/06/03 02:56:14 millert Exp $";
d206 2
a207 1
			if (strcmp(crypt(p, pw->pw_passwd), pw->pw_passwd)) {
d222 1
a222 1
		if (!*p) {
d224 2
a225 1
			pw_error(NULL, 0, 0);
d236 2
a237 1
		if (!strcmp(buf, getpass("Retype new password:")))
@


1.24
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.23 2002/06/28 22:28:17 deraadt Exp $	*/
d33 1
a33 1
static const char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.23 2002/06/28 22:28:17 deraadt Exp $";
d66 1
a66 1
struct passwd	*ypgetpwnam(char *);
d88 1
a88 1
	int r, rpcport, status;
d109 3
a111 1
	if ((r = yp_master(domain, "passwd.byname", &master)) != 0) {
d136 1
a136 1
	if (!(pw = ypgetpwnam(username))) {
d262 1
a262 1
interpret(struct passwd *pwent, char *line)
d288 8
d310 1
a310 1
ypgetpwnam(char *nam)
d316 3
a318 2
	reason = yp_match(domain, "passwd.byname", nam, strlen(nam),
	    &val, &vallen);
d335 1
a335 1
	return (interpret(&pwent, __yplin));
@


1.23
log
@various cleanups; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.22 2002/06/04 00:09:08 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d33 1
a33 1
static const char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.22 2002/06/04 00:09:08 deraadt Exp $";
@


1.22
log
@spelling; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.21 2002/05/16 11:54:25 fgsch Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.21 2002/05/16 11:54:25 fgsch Exp $";
d69 2
a70 2
char	       *ypgetnewpasswd(struct passwd *, login_cap_t *, char **);
struct passwd  *ypgetpwnam(char *);
d75 1
a75 3
pw_error(name, err, eval)
	char *name;
	int err, eval;
d89 1
a89 2
yp_passwd(username)
	char *username;
d91 1
a91 1
	char *master;
a92 2
	uid_t uid;
	struct yppasswd yppasswd;
d95 1
d97 2
a98 1
	login_cap_t *lc;
d159 1
a159 1
	yppasswd.newpw.pw_uid 	= pw->pw_uid;
d191 1
a191 4
ypgetnewpasswd(pw, lc, old_pass)
	struct passwd *pw;
	login_cap_t *lc;
	char **old_pass;
a193 2
	char *p;
	int tries, pwd_tries;
d196 2
d235 1
a235 2
		strncpy(buf, p, sizeof buf-1);
		buf[sizeof buf-1] = '\0';
d240 1
a240 1
	if(!pwd_gensalt(salt, _PASSWORD_LEN, pw, lc, 'y')) {
d279 1
a279 1
	if(!strchr(p, ':'))
d304 1
a304 2
ypgetpwnam(nam)
	char *nam;
d307 1
a308 1
	int reason, vallen;
d312 1
a312 1
	switch(reason) {
d325 1
a325 2
	strncpy(__yplin, val, vallen);
	__yplin[vallen] = '\0';
@


1.21
log
@- mimic pw_error() behavior from libutil when name is NULL.
- while i'm here some style, as well as spaces/tabs removal.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.20 2002/02/16 21:27:50 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.20 2002/02/16 21:27:50 millert Exp $";
d133 1
a133 1
	 * Be sure the port is priviledged
@


1.20
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.19 2001/12/07 04:15:08 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.19 2001/12/07 04:15:08 millert Exp $";
d64 4
a67 4
extern int pwd_gensalt(char *, int, struct passwd *, login_cap_t *, char);
extern int pwd_check(struct passwd *, login_cap_t *, char *);
extern int pwd_gettries(struct passwd *, login_cap_t *);
extern void kbintr(int);
d69 2
a70 2
char *ypgetnewpasswd(struct passwd *, login_cap_t *, char **);
struct passwd *ypgetpwnam(char *);
d79 6
a84 2
	if (err) 
		warn("%s", name);
d86 1
a86 1
	warnx("YP passwd database unchanged.");
d107 3
a109 2
		warnx("can't get local YP domain. Reason: %s", yperr_string(r));
		return(1);
d119 1
a119 1
		return(1);
d129 1
a129 1
		return(1);
d137 1
a137 1
		return(1);
d143 1
a143 1
		return(1);
d147 1
a147 1
		return(1);
d149 1
a149 1
		
d152 3
a154 2
		warnx("you may only change your own password: %s", strerror(EACCES));
		return(1);
d167 1
a167 1
	
d173 1
a173 1
		return(YPERR_YPBIND);
d185 1
a185 1
		return(1);
d187 2
a188 2
	printf("The YP password has been changed on %s, the master YP passwd server.\n",
	    master);
d190 1
a190 1
	return(0);
d207 1
a207 1
	
d211 1
a211 1
	
d234 2
a235 1
			printf("That password collides with a system feature. Choose another.\n");
d238 1
a238 1
		if ((tries++ < pwd_tries || pwd_tries == 0) 
d247 4
a250 4
        if( !pwd_gensalt( salt, _PASSWORD_LEN, pw, lc, 'y' )) {
                (void)printf("Couldn't generate salt.\n");
                pw_error(NULL, 0, 0);
        }
d284 1
a284 1
	
d287 1
a287 1
		return(NULL);
d317 1
a317 1
	
d337 1
a337 1
	return(interpret(&pwent, __yplin));
@


1.19
log
@Catch SIGINT and SIGQUIT via the kbintr() signal handler in ypgetnewpasswd()
too.  Restore old signal handler at the end of ypgetnewpasswd() and
getnewpasswd().
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.18 2001/07/07 00:10:49 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.18 2001/07/07 00:10:49 millert Exp $";
d64 4
a67 4
extern int pwd_gensalt __P((char *, int, struct passwd *, login_cap_t *, char));
extern int pwd_check __P((struct passwd *, login_cap_t *, char *));
extern int pwd_gettries __P((struct passwd *, login_cap_t *));
extern void kbintr __P((int));
d69 2
a70 2
char *ypgetnewpasswd __P((struct passwd *, login_cap_t *, char **));
struct passwd *ypgetpwnam __P((char *));
@


1.18
log
@quiet some -Wall warnings for login_{l,}chpass
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.17 2001/06/18 21:09:24 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.17 2001/06/18 21:09:24 millert Exp $";
d67 1
d197 4
d247 3
@


1.17
log
@o move passwd.conf variables into login.conf
o no longer install passwd.conf (but it is used if it exists and the
  needed info is not in login.conf)
o added passwordtime and minpasswordlen login.conf variables
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.16 2001/01/10 20:11:30 deraadt Exp $	*/
d36 2
a37 2
/*static char sccsid[] = "from: @@(#)yp_passwd.c	1.0 2/2/93";*/
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.16 2001/01/10 20:11:30 deraadt Exp $";
@


1.16
log
@handle malloc() failures
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.15 2000/12/12 02:19:59 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.15 2000/12/12 02:19:59 millert Exp $";
d52 1
d64 3
a66 3
extern	int pwd_gensalt __P(( char *, int, struct passwd *, char));
extern	int pwd_check __P((struct passwd *, char *));
extern	int pwd_gettries __P((struct passwd *));
d68 1
a68 1
char *ypgetnewpasswd __P((struct passwd *, char **));
d96 1
d139 4
d151 1
a151 1
	yppasswd.newpw.pw_passwd = ypgetnewpasswd(pw, &yppasswd.oldpass);
d187 1
a187 1
ypgetnewpasswd(pw, old_pass)
d189 1
d214 1
a214 1
	pwd_tries = pwd_gettries(pw);
d227 1
a227 1
		    && pwd_check(pw, p) == 0)
d235 1
a235 1
        if( !pwd_gensalt( salt, _PASSWORD_LEN, pw, 'y' )) {
@


1.15
log
@Minor interface changes to allow code reuse in login_chpass(8) and
login_lchpass(8)
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.14 2000/08/01 22:27:51 provos Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.14 2000/08/01 22:27:51 provos Exp $";
d203 2
d232 4
a235 1
	return(strdup(crypt(buf, salt)));
d309 2
@


1.14
log
@integrate password quality checking, disallow all digit passwords motivated
by Solar Designer.  External password checking program can be spawned now,
number of password trials configurable.  work by me and Bob Beck.
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.13 2000/06/30 16:00:20 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.13 2000/06/30 16:00:20 millert Exp $";
d67 2
a68 2
static char *getnewpasswd();
static struct passwd *ypgetpwnam();
a69 1
static uid_t uid;
d77 1
a77 1
	if(err) 
d90 1
a94 2
	
	uid = getuid();
d101 1
a101 1
		exit(1);
d111 1
a111 1
		exit(1);
d121 1
a121 1
		exit(1);
d129 1
a129 1
		exit(1);
d135 1
a135 1
		exit(1);
d138 1
d141 1
a141 1
		exit(1);
d145 1
a145 1
	yppasswd.newpw.pw_passwd = getnewpasswd(pw, &yppasswd.oldpass);
d172 1
a172 1
		exit(1);
d177 1
a177 1
	exit(0);
d180 3
a182 3
static char *
getnewpasswd(pw, old_pass)
	register struct passwd *pw;
d186 1
a186 1
	register char *p, *t;
d188 1
a188 1
	char salt[_PASSWORD_LEN], *crypt(), *getpass();
a190 1

d234 1
a234 1
pwskip(register char *p)
d246 1
a246 1
	register char	*p = line;
d283 1
a283 1
static struct passwd *
@


1.13
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.12 1998/07/13 02:15:01 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.12 1998/07/13 02:15:01 deraadt Exp $";
d63 4
d188 1
a188 1
	int tries;
a189 1
	int pwd_gensalt __P(( char *, int, struct passwd *, char));
d207 2
d219 2
a220 2
		if (strlen(p) <= 5 && ++tries < 2) {
			printf("Please enter a longer password.\n");
a221 7
		}
		for (t = p; *t && islower(*t); ++t)
			;
		if (!*t && ++tries < 2) {
			printf("Please don't use an all-lower case password.\nUnusual capitalization, control characters or digits are suggested.\n");
			continue;
		}
@


1.12
log
@excessive paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.11 1998/07/12 18:05:15 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.11 1998/07/12 18:05:15 deraadt Exp $";
d75 1
a75 1
		warn(name);
@


1.12.8.1
log
@Pull in patch from current:
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.12 1998/07/13 02:15:01 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.12 1998/07/13 02:15:01 deraadt Exp $";
d75 1
a75 1
		warn("%s", name);
@


1.11
log
@fix printing glitch
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.10 1998/02/24 20:46:17 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.10 1998/02/24 20:46:17 deraadt Exp $";
d224 2
a225 1
		strcpy(buf, p);
d308 2
a309 1
	strcpy(__yplin, val);
@


1.10
log
@catch special password "s/key" and refuse it
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.9 1997/09/12 04:12:53 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.9 1997/09/12 04:12:53 millert Exp $";
d75 1
a75 1
		warn(name != NULL ? name : "");
@


1.9
log
@Kill extra newline in err()/warn().
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.8 1997/03/27 00:30:55 weingart Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.8 1997/03/27 00:30:55 weingart Exp $";
d209 4
@


1.8
log
@Slight cleanup, more needed
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.7 1997/02/17 10:34:41 provos Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.7 1997/02/17 10:34:41 provos Exp $";
d107 2
a108 1
		warnx("can't find the master YP server. Reason: %s\n", yperr_string(r));
d154 1
a154 1
		warnx("cannot contact yppasswdd on %s: Reason: %s\n",
@


1.7
log
@free what was allocated by strdup
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.6 1997/02/16 20:09:00 provos Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.6 1997/02/16 20:09:00 provos Exp $";
d43 1
d45 1
d49 1
d51 1
a62 1
extern char *progname;
d69 1
a69 1
static
d74 2
a75 1
	int sverrno;
d77 1
a77 9
	if (err) {
		sverrno = errno;
		(void)fprintf(stderr, "%s: ", progname);
		if (name)
			(void)fprintf(stderr, "%s: ", name);
		(void)fprintf(stderr, "%s\n", strerror(sverrno));
	}
	(void)fprintf(stderr,
	    "%s: YP passwd database unchanged\n", progname);
d81 1
a85 1
	char *pp;
d97 2
a98 3
	if (r = yp_get_default_domain(&domain)) {
		fprintf(stderr, "%s: can't get local YP domain. Reason: %s\n",
		    progname, yperr_string(r));
d107 1
a107 3
		fprintf(stderr,
		    "%s: can't find the master YP server. Reason: %s\n",
		    progname, yperr_string(r));
d116 2
a117 4
		fprintf(stderr,
		    "%s: master YP server not running yppasswd daemon.\n",
		    progname);
		fprintf(stderr, "\tCan't change password.\n");
d125 1
a125 2
		fprintf(stderr, "%s: yppasswd daemon is on an invalid port.\n",
		    progname);
d131 1
a131 2
		(void)fprintf(stderr, "%s: unknown user %s.\n",
		    progname, username);
d136 1
a136 3
		fprintf(stderr,
		    "%s: you may only change your own password: %s\n",
		    progname, strerror(EACCES));
d153 1
a153 1
		fprintf(stderr, "cannot contact yppasswdd on %s: Reason: %s\n",
d164 1
a164 1
		fprintf(stderr, "%s: rpc to yppasswdd failed.\n", progname);
a244 1
	register int	c;
@


1.6
log
@cleaned up, moved pw_getconf to libutil, removed _'s in option names
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.5 1997/02/14 23:27:31 provos Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.5 1997/02/14 23:27:31 provos Exp $";
d168 1
d180 1
d185 1
@


1.5
log
@include blowfish cipher - free config of which cipher to use
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.4 1996/08/30 13:37:53 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.4 1996/08/30 13:37:53 deraadt Exp $";
d195 1
a195 1
	void pwd_gensalt __P(( char *, int, struct passwd *, char));
d234 4
a237 1
	pwd_gensalt( salt, _PASSWORD_LEN, pw, 'y' );
@


1.4
log
@of course, the same bug as in chpass shows up here too...
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.3 1996/07/22 03:53:21 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.3 1996/07/22 03:53:21 deraadt Exp $";
d194 2
a195 1
	char salt[9], *crypt(), *getpass();
d234 1
a234 9
	/* grab a random printable character that isn't a colon */
	(void)srandom((int)time((time_t *)NULL));
#ifdef NEWSALT
	salt[0] = _PASSWORD_EFMT1;
	to64(&salt[1], (long)(29 * 25), 4);
	to64(&salt[5], random(), 4);
#else
	to64(&salt[0], random(), 2);
#endif
@


1.3
log
@finally half-readable
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_passwd.c,v 1.2 1996/06/26 05:37:48 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.2 1996/06/26 05:37:48 deraadt Exp $";
d294 2
a300 1
	static char line[1024];
d314 4
a317 1
	strcpy(line, val);
d320 1
a320 1
	return(interpret(&pwent, line));
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: yp_passwd.c,v 1.1.1.1 1995/10/18 08:45:54 deraadt Exp $";
d174 1
a174 1
		      xdr_yppasswd, &yppasswd, xdr_int, &status, tv);
d177 1
a177 1
	else if (status)
d179 4
a182 2
	else
		printf("The YP password has been changed on %s, the master YP passwd server.\n", master);
d196 1
a196 1
	(void)printf("Changing YP password for %s.\n", pw->pw_name);
d202 4
a205 4
			if (strcmp(crypt(p = getpass("Old password:"),
					 pw->pw_passwd),  pw->pw_passwd)) {
				   errno = EACCES;
				   pw_error(NULL, 1, 1);
d207 1
a207 1
		} else {
a208 2
		}

d211 1
d215 1
a215 1
			(void)printf("Password unchanged.\n");
d219 1
a219 1
			(void)printf("Please enter a longer password.\n");
d222 2
a223 1
		for (t = p; *t && islower(*t); ++t);
d225 1
a225 1
			(void)printf("Please don't use an all-lower case password.\nUnusual capitalization, control characters or digits are suggested.\n");
d228 1
a228 1
		(void)strcpy(buf, p);
d272 1
a272 1
	if(!strchr(p,':'))
d304 1
a304 1
			  &val, &vallen);
@


1.1
log
@Initial revision
@
text
@d1 2
d37 1
a37 1
static char rcsid[] = "$Id: yp_passwd.c,v 1.8 1995/02/08 19:54:12 phil Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

