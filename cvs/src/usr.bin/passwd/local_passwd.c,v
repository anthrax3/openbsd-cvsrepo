head	1.53;
access;
symbols
	OPENBSD_6_2:1.53.0.6
	OPENBSD_6_2_BASE:1.53
	OPENBSD_6_1:1.53.0.4
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.47.0.2
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.44.0.6
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.41.0.10
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.8
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.4
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.2
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.40.0.12
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.10
	OPENBSD_5_0:1.40.0.8
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.40.0.6
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.40.0.4
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.39.0.6
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.2
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.38.0.2
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.37.0.12
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.37.0.10
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.37.0.8
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.37.0.6
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.37.0.4
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.36.0.2
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.34.0.2
	OPENBSD_3_6_BASE:1.34
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	OPENBSD_3_3:1.26.0.4
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.8
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.6
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.53
date	2016.12.30.23.32.14;	author millert;	state Exp;
branches;
next	1.52;
commitid	LqrrLjghRLUgzKDf;

1.52
date	2016.09.02.18.06.43;	author tedu;	state Exp;
branches;
next	1.51;
commitid	r8vIJFz95usZVwYa;

1.51
date	2016.09.02.10.32.38;	author gsoares;	state Exp;
branches;
next	1.50;
commitid	MtvvXgtNDkxNIbv6;

1.50
date	2016.08.31.12.41.19;	author tedu;	state Exp;
branches;
next	1.49;
commitid	dimAMGTpUXw9R5Md;

1.49
date	2016.08.31.10.06.41;	author tedu;	state Exp;
branches;
next	1.48;
commitid	XcQsizSsGaUmitz5;

1.48
date	2016.08.15.04.28.31;	author guenther;	state Exp;
branches;
next	1.47;
commitid	G1Tr6KDwvMLNnqtw;

1.47
date	2016.05.08.20.27.43;	author tim;	state Exp;
branches;
next	1.46;
commitid	5rMnlcR8KHtiOX1n;

1.46
date	2015.11.26.19.01.47;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	0NbTNVgy2y455HVw;

1.45
date	2015.10.25.08.39.26;	author ajacoutot;	state Exp;
branches;
next	1.44;
commitid	cLlYHAKgT7hh5C62;

1.44
date	2014.11.21.05.13.44;	author tedu;	state Exp;
branches;
next	1.43;
commitid	H7AJhZvkXj2g8HJk;

1.43
date	2014.11.20.14.53.15;	author tedu;	state Exp;
branches;
next	1.42;
commitid	QCpCF0xG1gASOuQP;

1.42
date	2014.11.11.21.06.24;	author tedu;	state Exp;
branches;
next	1.41;
commitid	lK9HvjA0rRyGiCb3;

1.41
date	2013.01.18.11.13.38;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2009.10.27.23.59.41;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2008.11.06.05.35.56;	author djm;	state Exp;
branches;
next	1.38;

1.38
date	2008.04.27.10.01.53;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.01.18.47.06;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2004.12.20.15.05.59;	author moritz;	state Exp;
branches;
next	1.35;

1.35
date	2004.09.18.19.34.29;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.24.16.57.43;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.13.21.09.48;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2004.04.20.23.21.23;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.10.21.23.17;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.20.16.53.27;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.03.02.56.14;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.28.01.40.06;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.30.20.50.05;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.28.22.28.17;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.16.21.27.50;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.07.04.15.08;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.07.03.48.39;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.27.02.57.07;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.26.03.28.30;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.18.19.58.46;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.16.18.29.27;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.16.16.14.35;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.07.00.10.49;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.04.17.20.24;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.18.21.09.23;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.12.02.19.58;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.26.01.29.43;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.01.22.27.51;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	98.07.13.02.15.00;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.02.24.20.46.14;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.04.07.06.43.09;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.03.27.00.30.53;	author weingart;	state Exp;
branches;
next	1.6;

1.6
date	97.02.16.20.08.56;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.02.14.23.27.28;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	96.09.30.01.54.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.37.46;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.35.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.54;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.54;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.53
log
@Use explicit_bzero() to clear the buffer used when the user retypes
the new password.  From isk AT ingve DOT org
@
text
@/*	$OpenBSD: local_passwd.c,v 1.52 2016/09/02 18:06:43 tedu Exp $	*/

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/uio.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
#include <util.h>
#include <login_cap.h>
#include <readpassphrase.h>

#define UNCHANGED_MSG	"Password unchanged."

static uid_t uid;
extern int pwd_check(login_cap_t *, char *);
extern int pwd_gettries(login_cap_t *);

int local_passwd(char *, int);
char *getnewpasswd(struct passwd *, login_cap_t *, int);
void kbintr(int);

int
local_passwd(char *uname, int authenticated)
{
	struct passwd *pw, *opw;
	login_cap_t *lc;
	sigset_t fullset;
	time_t period;
	int i, pfd, tfd = -1;
	int pwflags = _PASSWORD_OMITV7;

	if (!(pw = getpwnam_shadow(uname))) {
		warnx("unknown user %s.", uname);
		return(1);
	}

	if (pledge("stdio rpath wpath cpath getpw tty id proc exec", NULL) == -1)
		err(1, "pledge");

	if ((opw = pw_dup(pw)) == NULL) {
		warn(NULL);
		return(1);
	}
	if ((lc = login_getclass(pw->pw_class)) == NULL) {
		warnx("unable to get login class for user %s.", uname);
		free(opw);
		return(1);
	}

	uid = authenticated ? pw->pw_uid : getuid();
	if (uid && uid != pw->pw_uid) {
		warnx("login/uid mismatch, username argument required.");
		free(opw);
		return(1);
	}

	/* Get the new password. */
	pw->pw_passwd = getnewpasswd(pw, lc, authenticated);

	if (pledge("stdio rpath wpath cpath getpw id proc exec", NULL) == -1)
		err(1, "pledge");

	/* Reset password change time based on login.conf. */
	period = (time_t)login_getcaptime(lc, "passwordtime", 0, 0);
	if (period > 0) {
		pw->pw_change = time(NULL) + period;
	} else {
		/*
		 * If the pw change time is the same we only need
		 * to update the spwd.db file.
		 */
		if (pw->pw_change != 0)
			pw->pw_change = 0;
		else
			pwflags = _PASSWORD_SECUREONLY;
	}

	/* Drop user's real uid and block all signals to avoid a DoS. */
	setuid(0);
	sigfillset(&fullset);
	sigdelset(&fullset, SIGINT);
	sigprocmask(SIG_BLOCK, &fullset, NULL);

	if (pledge("stdio rpath wpath cpath proc exec", NULL) == -1)
		err(1, "pledge");

	/* Get a lock on the passwd file and open it. */
	pw_init();
	for (i = 1; (tfd = pw_lock(0)) == -1; i++) {
		if (i == 4)
			(void)fputs("Attempting to lock password file, "
			    "please wait or press ^C to abort", stderr);
		(void)signal(SIGINT, kbintr);
		if (i % 16 == 0)
			fputc('.', stderr);
		usleep(250000);
		(void)signal(SIGINT, SIG_IGN);
	}
	if (i >= 4)
		fputc('\n', stderr);
	pfd = open(_PATH_MASTERPASSWD, O_RDONLY | O_CLOEXEC, 0);
	if (pfd < 0)
		pw_error(_PATH_MASTERPASSWD, 1, 1);

	/* Update master.passwd file and rebuild spwd.db. */
	pw_copy(pfd, tfd, pw, opw);
	free(opw);
	if (pw_mkdb(uname, pwflags) < 0)
		pw_error(NULL, 0, 1);

	return(0);
}

char *
getnewpasswd(struct passwd *pw, login_cap_t *lc, int authenticated)
{
	static char hash[_PASSWORD_LEN];
	char newpass[1024];
	char *p, *pref;
	int tries, pwd_tries;
	sig_t saveint, savequit;

	saveint = signal(SIGINT, kbintr);
	savequit = signal(SIGQUIT, kbintr);

	if (!authenticated) {
		(void)printf("Changing password for %s.\n", pw->pw_name);
		if (uid != 0 && pw->pw_passwd[0] != '\0') {
			char oldpass[1024];

			p = readpassphrase("Old password:", oldpass,
			    sizeof(oldpass), RPP_ECHO_OFF);
			if (p == NULL || *p == '\0') {
				(void)printf("%s\n", UNCHANGED_MSG);
				pw_abort();
				exit(p == NULL ? 1 : 0);
			}
			if (crypt_checkpass(p, pw->pw_passwd) != 0) {
				errno = EACCES;
				explicit_bzero(oldpass, sizeof(oldpass));
				pw_error(NULL, 1, 1);
			}
			explicit_bzero(oldpass, sizeof(oldpass));
		}
	}

	pwd_tries = pwd_gettries(lc);

	for (newpass[0] = '\0', tries = 0;;) {
		char repeat[1024];

		p = readpassphrase("New password:", newpass, sizeof(newpass),
		    RPP_ECHO_OFF);
		if (p == NULL || *p == '\0') {
			(void)printf("%s\n", UNCHANGED_MSG);
			pw_abort();
			exit(p == NULL ? 1 : 0);
		}
		if (strcmp(p, "s/key") == 0) {
			printf("That password collides with a system feature. Choose another.\n");
			continue;
		}

		if ((tries++ < pwd_tries || pwd_tries == 0) &&
		    pwd_check(lc, p) == 0)
			continue;
		p = readpassphrase("Retype new password:", repeat, sizeof(repeat),
		    RPP_ECHO_OFF);
		if (p != NULL && strcmp(newpass, p) == 0) {
			explicit_bzero(repeat, sizeof(repeat));
			break;
		}
		(void)printf("Mismatch; try again, EOF to quit.\n");
		explicit_bzero(repeat, sizeof(repeat));
		explicit_bzero(newpass, sizeof(newpass));
	}

	(void)signal(SIGINT, saveint);
	(void)signal(SIGQUIT, savequit);

	pref = login_getcapstr(lc, "localcipher", NULL, NULL);
	if (crypt_newhash(newpass, pref, hash, sizeof(hash)) != 0) {
		(void)printf("Couldn't generate hash.\n");
		explicit_bzero(newpass, sizeof(newpass));
		pw_error(NULL, 0, 0);
	}
	explicit_bzero(newpass, sizeof(newpass));
	free(pref);
	return hash;
}

void
kbintr(int signo)
{
	dprintf(STDOUT_FILENO, "\n%s\n", UNCHANGED_MSG);
	_exit(0);
}
@


1.52
log
@_PASSWORD_LEN is length that comes out of crypt(), not a meaningful
length for user entered passwords. And the +1 is just superstitious
nonsense inherited from getpass() guts.
Switch to a pleasing fixed size of 1024.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.51 2016/09/02 10:32:38 gsoares Exp $	*/
d206 2
a207 1
		if (p != NULL && strcmp(newpass, p) == 0)
d209 1
d211 1
@


1.51
log
@make sure to explicitly clear memory that is used for password input.
OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.50 2016/08/31 12:41:19 tedu Exp $	*/
d155 1
a155 1
	char newpass[_PASSWORD_LEN + 1];
d166 1
a166 1
			char oldpass[_PASSWORD_LEN + 1];
d187 1
a187 1
		char repeat[_PASSWORD_LEN + 1];
@


1.50
log
@replace obsolete getpass with readpassphrase.
ok gsoares
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.49 2016/08/31 10:06:41 tedu Exp $	*/
d177 1
d180 1
d209 1
d218 1
d221 1
@


1.49
log
@nicer format strings and use dprintf instead of write
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.48 2016/08/15 04:28:31 guenther Exp $	*/
d47 1
d155 1
a157 1
	char buf[1024];
d166 4
a169 1
			p = getpass("Old password:");
d184 5
a188 2
	for (buf[0] = '\0', tries = 0;;) {
		p = getpass("New password:");
d202 3
a204 3
		strlcpy(buf, p, sizeof(buf));
		p = getpass("Retype new password:");
		if (p != NULL && strcmp(buf, p) == 0)
d213 1
a213 1
	if (crypt_newhash(buf, pref, hash, sizeof(hash)) != 0) {
@


1.48
log
@Trust the login_getcaptime() declaration and don't cast the arguments to
their own expected type
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.47 2016/05/08 20:27:43 tim Exp $	*/
d48 1
a48 1
#define UNCHANGED_MSG	"Password unchanged.\n"
d167 1
a167 1
				(void)printf(UNCHANGED_MSG);
d183 1
a183 1
			(void)printf(UNCHANGED_MSG);
a213 1
/* ARGSUSED */
d217 1
a217 2
	write(STDOUT_FILENO, "\n", 1);
	write(STDOUT_FILENO, UNCHANGED_MSG, sizeof(UNCHANGED_MSG) - 1);
@


1.47
log
@Switch to getpwnam_shadow() now that getpwnam() no longer opens the shadow
database; OK deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.46 2015/11/26 19:01:47 deraadt Exp $	*/
d100 1
a100 2
	period = (time_t)login_getcaptime(lc, "passwordtime",
	    (quad_t)0, (quad_t)0);
@


1.46
log
@Delete YP password related code.  As a result, these can also be
pledged.  Keep an eye out for regressions, because they could be
uncomfortable.
ok beck semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.45 2015/10/25 08:39:26 ajacoutot Exp $	*/
d68 1
a68 1
	if (!(pw = getpwnam(uname))) {
@


1.45
log
@No need to declare pwd_gensalt; it's unused and gone.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.44 2014/11/21 05:13:44 tedu Exp $	*/
a68 4
#ifdef YP
		extern int use_yp;
		if (!use_yp)
#endif
d72 4
d96 3
d121 3
d164 1
a164 1
		(void)printf("Changing local password for %s.\n", pw->pw_name);
@


1.44
log
@change prototype for crypt_newhash. the login_cap_t is a holdover from its
pwd_gensalt origins, but a string argument works equally work and is more
friendly to consumers beyond local user accounts.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.43 2014/11/20 14:53:15 tedu Exp $	*/
a50 1
extern int pwd_gensalt(char *, int, login_cap_t *, char);
@


1.43
log
@switch to using crypt_newhash interface. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.42 2014/11/11 21:06:24 tedu Exp $	*/
d150 1
a150 1
	char *p;
d201 2
a202 1
	if (crypt_newhash(buf, lc, hash, sizeof(hash)) != 0) {
d206 1
@


1.42
log
@use crypt_checkpass instead of crypt/strcmp
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.41 2013/01/18 11:13:38 guenther Exp $	*/
d149 1
d152 1
a152 1
	char buf[_PASSWORD_LEN+1], salt[_PASSWORD_LEN];
d197 1
a197 4
	if (!pwd_gensalt(salt, _PASSWORD_LEN, lc, 'l')) {
		(void)printf("Couldn't generate salt.\n");
		pw_error(NULL, 0, 0);
	}
d201 5
a205 1
	return(crypt(buf, salt));
@


1.41
log
@Use open(O_CLOEXEC) instead of a separate fcntl(FD_CLOEXEC) call.

Nudged by David Hill
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.40 2009/10/27 23:59:41 deraadt Exp $	*/
d166 1
a166 1
			if (strcmp(crypt(p, pw->pw_passwd), pw->pw_passwd)) {
@


1.40
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.39 2008/11/06 05:35:56 djm Exp $	*/
d133 2
a134 2
	pfd = open(_PATH_MASTERPASSWD, O_RDONLY, 0);
	if (pfd < 0 || fcntl(pfd, F_SETFD, FD_CLOEXEC) == -1)
@


1.39
log
@-Wall -Wshadow clean, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.38 2008/04/27 10:01:53 jsing Exp $	*/
a30 5

#ifndef lint
/*static const char sccsid[] = "from: @@(#)local_passwd.c	5.5 (Berkeley) 5/6/91";*/
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.38 2008/04/27 10:01:53 jsing Exp $";
#endif /* not lint */
@


1.38
log
@Correct English.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.37 2005/05/01 18:47:06 deraadt Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.37 2005/05/01 18:47:06 deraadt Exp $";
d60 1
@


1.37
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.36 2004/12/20 15:05:59 moritz Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.36 2004/12/20 15:05:59 moritz Exp $";
d127 1
a127 1
			(void)fputs("Attempting lock password file, "
@


1.36
log
@o some missing free()'s in error paths
o use FD_CLOEXEC instead of 1
o fix a crash when the round number of
  localcipher in the default section
  in login.conf was ommitted. noted by
  mpech@@

ok mpech@@, otto@@, millert@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.35 2004/09/18 19:34:29 deraadt Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.35 2004/09/18 19:34:29 deraadt Exp $";
d191 2
a192 2
		if ((tries++ < pwd_tries || pwd_tries == 0) 
		    && pwd_check(lc, p) == 0)
@


1.35
log
@ARGSUSED signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.34 2004/07/24 16:57:43 millert Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.34 2004/07/24 16:57:43 millert Exp $";
d87 1
d94 1
d138 1
a138 1
	if (pfd < 0 || fcntl(pfd, F_SETFD, 1) == -1)
@


1.34
log
@Print a newline before the message in kbintr.  Otherwise the message
ends up on the same line as the prompt.
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.33 2004/07/13 21:09:48 millert Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.33 2004/07/13 21:09:48 millert Exp $";
d208 1
@


1.33
log
@passwd.conf has been deprecated since login.conf was imported.
Today it finally dies.  Based on a diff from Gabriel Kihlman.
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.32 2004/04/20 23:21:23 millert Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.32 2004/04/20 23:21:23 millert Exp $";
d211 1
@


1.32
log
@Adapt to new pw_copy() API, closes PR 3698.
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.31 2004/03/10 21:23:17 millert Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.31 2004/03/10 21:23:17 millert Exp $";
d56 3
a58 3
extern int pwd_gensalt(char *, int, struct passwd *, login_cap_t *, char);
extern int pwd_check(struct passwd *, login_cap_t *, char *);
extern int pwd_gettries(struct passwd *, login_cap_t *);
d175 1
a175 1
	pwd_tries = pwd_gettries(pw, lc);
d190 1
a190 1
		    && pwd_check(pw, lc, p) == 0)
d198 1
a198 1
	if (!pwd_gensalt(salt, _PASSWORD_LEN, pw, lc, 'l')) {
@


1.31
log
@Check getpass() return value for NULL.  Closes Pr 3706.
With help and OK from otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.30 2003/06/20 16:53:27 deraadt Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.30 2003/06/20 16:53:27 deraadt Exp $";
d66 1
a66 1
	struct passwd *pw;
d81 4
d140 2
a141 1
	pw_copy(pfd, tfd, pw);
@


1.30
log
@a cleaning recommended by lint
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.29 2003/06/03 02:56:14 millert Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.29 2003/06/03 02:56:14 millert Exp $";
d158 1
a158 1
			if (*p == '\0') {
d161 1
a161 1
				exit(0);
d174 1
a174 1
		if (*p == '\0') {
d177 1
a177 1
			exit(0);
d188 2
a189 1
		if (!strcmp(buf, getpass("Retype new password:")))
@


1.29
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.28 2003/04/28 01:40:06 deraadt Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.28 2003/04/28 01:40:06 deraadt Exp $";
d96 2
a97 1
	period = login_getcaptime(lc, "passwordtime", 0, 0);
@


1.28
log
@stdlib.h
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.27 2003/03/30 20:50:05 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.27 2003/03/30 20:50:05 millert Exp $";
@


1.27
log
@Simpler and consistent error messages when the user enters an empty
password or hits ^C.  OK deraadt@@ and mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.26 2002/06/28 22:28:17 deraadt Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.26 2002/06/28 22:28:17 deraadt Exp $";
d50 1
@


1.26
log
@various cleanups; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.25 2002/02/16 21:27:50 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.25 2002/02/16 21:27:50 millert Exp $";
d56 2
d158 11
a168 5
		if (uid && pw->pw_passwd[0] &&
		    strcmp(crypt(getpass("Old password:"), pw->pw_passwd),
		    pw->pw_passwd)) {
			errno = EACCES;
			pw_error(NULL, 1, 1);
d176 4
a179 3
		if (!*p) {
			(void)printf("Password unchanged.\n");
			pw_error(NULL, 0, 0);
d207 2
a208 17
	char msg[] = "\nPassword unchanged.\n";
	struct iovec iv[5];
	extern char *__progname;

	iv[0].iov_base = msg;
	iv[0].iov_len = sizeof(msg) - 1;
	iv[1].iov_base = __progname;
	iv[1].iov_len = strlen(__progname);
	iv[2].iov_base = ": ";
	iv[2].iov_len = 2;
	iv[3].iov_base = _PATH_MASTERPASSWD;
	iv[3].iov_len = sizeof(_PATH_MASTERPASSWD) - 1;
	iv[4].iov_base = " unchanged\n";
	iv[4].iov_len = 11;
	writev(STDERR_FILENO, iv, 5);

	_exit(1);
@


1.25
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.24 2001/12/07 04:15:08 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.24 2001/12/07 04:15:08 millert Exp $";
d65 1
a65 3
local_passwd(uname, authenticated)
	char *uname;
	int authenticated;
d144 1
a144 4
getnewpasswd(pw, lc, authenticated)
	struct passwd *pw;
	login_cap_t *lc;
	int authenticated;
d163 1
a163 1
	
d176 1
a176 1
		
d196 1
a196 2
kbintr(signo)
	int signo;
@


1.24
log
@Catch SIGINT and SIGQUIT via the kbintr() signal handler in ypgetnewpasswd()
too.  Restore old signal handler at the end of ypgetnewpasswd() and
getnewpasswd().
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.23 2001/12/07 03:48:39 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.23 2001/12/07 03:48:39 millert Exp $";
d57 3
a59 3
extern int pwd_gensalt __P((char *, int, struct passwd *, login_cap_t *, char));
extern int pwd_check __P((struct passwd *, login_cap_t *, char *));
extern int pwd_gettries __P((struct passwd *, login_cap_t *));
d61 2
a62 2
char *getnewpasswd __P((struct passwd *, login_cap_t *, int));
void kbintr __P((int));
@


1.23
log
@Catch SIGINT and SIGQUIT via the kbintr() signal handler.
Now that getpass() is interuptible we need to catch these so that the
"Password unchanged." message is printed.
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.22 2001/11/19 19:02:15 mpech Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.22 2001/11/19 19:02:15 mpech Exp $";
d154 1
d156 2
a157 2
	(void)signal(SIGINT, kbintr);
	(void)signal(SIGQUIT, kbintr);
d194 2
a195 2
	(void)signal(SIGINT, SIG_DFL);
	(void)signal(SIGQUIT, SIG_DFL);
d208 1
a208 1
	iv[0].iov_base = "\nPassword unchanged.\n";
@


1.22
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.21 2001/08/27 02:57:07 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.21 2001/08/27 02:57:07 millert Exp $";
d155 3
d193 3
@


1.21
log
@Instead of prompting the user whether or not they wish to continue to
wait for the lock on password file just tell the user to interrupt with
^C.  This simplifies the locking loop a bit.

Update man page to this effect.
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.20 2001/08/26 03:28:30 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.20 2001/08/26 03:28:30 millert Exp $";
d151 1
a151 1
	register char *p;
@


1.20
log
@Change the second arg to pw_mkdb() from a boolean flag to a set of
bit flags ORed together.  Currently the only flags defined are
_PASSWORD_SECUREONLY and _PASSWORD_OMITV7 but this is enough to
cause pw_mkdb() to run pwd_mkdb with the options we want.

With this change we no longer generate the old V7 passwd file when
only the extra fields in master.passwd (or the encrypted password)
have changed.  There are other programs that could probably use
the _PASSWORD_OMITV7 flag; they will be converted at a future date.
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.19 2001/08/18 19:58:46 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.19 2001/08/18 19:58:46 millert Exp $";
d43 2
a44 1
#include <pwd.h>
d47 2
d50 1
a52 3
#include <ctype.h>
#include <fcntl.h>
#include <signal.h>
d73 1
a73 1
	int pfd, tfd = -1;
a74 1
	char *s = NULL;
d121 6
a126 7
	for (;;) {
		int i, c, d;

		for (i = 0; i < (s ? 64 : 8) && (tfd = pw_lock(0)) == -1; i++) {
			if (i == 0)
				(void)fputs("Please wait", stderr);
			(void)signal(SIGINT, kbintr);
d128 1
a128 20
			usleep(250000);
			(void)signal(SIGINT, SIG_IGN);
		}
		if (i)
			fputc('\n', stderr);
		if (tfd != -1)
			break;

		/* Unable to lock passwd file, let the user decide. */
		if (errno == EEXIST) {
			if (s == NULL)
				s = "The passwd file is busy,";
			else
				s = "The passwd file is still busy,";
		} else
			s = "Unable to open passwd temp file,";
		(void)fprintf(stderr,
		    "%s do you want to wait until it is available? [y/n] ", s);
		(void)signal(SIGINT, kbintr);
		c = getchar();
a129 7
		if (c != '\n')
			while ((d = getchar()) != '\n' && d != EOF)
				;
		if (tolower(c) != 'y') {
			printf("Password unchanged\n");
			exit(1);
		}
d131 2
d197 15
a211 1
	char msg[] = "\nPassword unchanged\n";
a212 1
	write(STDOUT_FILENO, msg, sizeof(msg) - 1);
@


1.19
log
@If we modify pw_change we cannot pass pw_mkdb() the secureonly flag.

We don't need to rebuild the v7 version of the file in this case but
we have no way to communicate that to pw_mkdb since we pass in a
boolean instead of a set of bit flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.18 2001/08/16 18:29:27 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.18 2001/08/16 18:29:27 millert Exp $";
d73 1
a73 1
	int secureonly = 0;
d110 1
a110 1
			secureonly = 1;
d164 1
a164 1
	if (pw_mkdb(uname, secureonly) < 0)
@


1.18
log
@extra arg to pw_mkdb
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.16 2001/07/07 00:10:49 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.16 2001/07/07 00:10:49 millert Exp $";
d73 1
d100 1
a100 1
	if (period > 0)
d102 10
a111 2
	else
		pw->pw_change = 0;
d164 2
a165 2
	if (pw_mkdb(uname, 1) < 0)
		pw_error((char *)NULL, 0, 1);
@


1.17
log
@At Theo's request only print 'Please wait' if don't get the lock
on the first try.
@
text
@d153 1
a153 1
	/* Update master.passwd file and build .db version. */
d155 1
a155 1
	if (pw_mkdb(uname) < 0)
@


1.16
log
@quiet some -Wall warnings for login_{l,}chpass
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.15 2001/07/04 17:20:24 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: local_passwd.c,v 1.15 2001/07/04 17:20:24 millert Exp $";
a114 1
		(void)fputs("Please wait", stderr);
d116 2
d123 2
a124 1
		fputc('\n', stderr);
@


1.15
log
@Move locking of the passwd file *after* we have gotten a new password
from the user.  Set real/effective/saved uids to 0 and block all signals
so the lock cannot be kept longer than necessary.  If we cannot lock,
try again every 1/4 second for 2 seconds and then ask the user what
they wish to do (keep trying, quit).
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.14 2001/06/18 21:09:23 millert Exp $	*/
d37 2
a38 2
/*static char sccsid[] = "from: @@(#)local_passwd.c	5.5 (Berkeley) 5/6/91";*/
static char rcsid[] = "$OpenBSD: local_passwd.c,v 1.14 2001/06/18 21:09:23 millert Exp $";
d72 1
a72 1
	int pfd, tfd;
@


1.14
log
@o move passwd.conf variables into login.conf
o no longer install passwd.conf (but it is used if it exists and the
  needed info is not in login.conf)
o added passwordtime and minpasswordlen login.conf variables
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.13 2000/12/12 02:19:58 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: local_passwd.c,v 1.13 2000/12/12 02:19:58 millert Exp $";
d51 1
d61 1
d70 2
d73 1
a73 1
	time_t period;
a93 12
	pw_init();
	tfd = pw_lock(0);
	if (tfd < 0) {
		if (errno == EEXIST)
			errx(1, "the passwd file is busy.");
		else
			err(1, "can't open passwd temp file");
	}
	pfd = open(_PATH_MASTERPASSWD, O_RDONLY, 0);
	if (pfd < 0 || fcntl(pfd, F_SETFD, 1) == -1)
		pw_error(_PATH_MASTERPASSWD, 1, 1);

d104 47
d205 10
@


1.13
log
@Minor interface changes to allow code reuse in login_chpass(8) and
login_lchpass(8)
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.12 2000/11/26 01:29:43 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: local_passwd.c,v 1.12 2000/11/26 01:29:43 millert Exp $";
d52 1
d55 5
a59 3
extern int pwd_gensalt __P(( char *, int, struct passwd *, char));
extern int pwd_check __P((struct passwd *, char *));
extern int pwd_gettries __P((struct passwd *));
d67 1
d69 1
a69 1
	char *getnewpasswd();
d79 4
d102 11
a112 7
	/*
	 * Get the new password.  Reset passwd change time to zero; when
	 * classes are implemented, go and get the "offset" value for this
	 * class and reset the timer.
	 */
	pw->pw_passwd = getnewpasswd(pw, authenticated);
	pw->pw_change = 0;
a113 1

d116 1
d121 3
a123 2
getnewpasswd(pw, authenticated)
	register struct passwd *pw;
d140 1
a140 1
	pwd_tries = pwd_gettries(pw);
d154 1
a154 1
		    && pwd_check(pw, p) == 0)
d161 1
a161 1
	if(!pwd_gensalt(salt, _PASSWORD_LEN, pw, 'l')) {
@


1.12
log
@Update for pw_mkdb(3) interface change.  All but vipw and userdel can
specify a username (and thus avoid rebuilding the while database).
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.11 2000/08/01 22:27:51 provos Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: local_passwd.c,v 1.11 2000/08/01 22:27:51 provos Exp $";
d59 1
a59 1
local_passwd(uname)
d61 1
d76 1
a76 1
	uid = getuid();
d99 1
a99 1
	pw->pw_passwd = getnewpasswd(pw);
d109 1
a109 1
getnewpasswd(pw)
d111 1
d113 1
a113 1
	register char *p, *t;
d115 1
a115 1
	char buf[_PASSWORD_LEN+1], salt[_PASSWORD_LEN], *crypt(), *getpass();
d117 8
a124 7
	(void)printf("Changing local password for %s.\n", pw->pw_name);

	if (uid && pw->pw_passwd[0] &&
	    strcmp(crypt(getpass("Old password:"), pw->pw_passwd),
	    pw->pw_passwd)) {
		errno = EACCES;
		pw_error(NULL, 1, 1);
d143 1
a143 2
		strncpy(buf, p, sizeof buf-1);
		buf[sizeof buf-1] = '\0';
d148 1
a148 1
	if( !pwd_gensalt( salt, _PASSWORD_LEN, pw, 'l' )) {
@


1.11
log
@integrate password quality checking, disallow all digit passwords motivated
by Solar Designer.  External password checking program can be spawned now,
number of password trials configurable.  work by me and Bob Beck.
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.10 1998/07/13 02:15:00 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: local_passwd.c,v 1.10 1998/07/13 02:15:00 deraadt Exp $";
d102 1
a102 1
	if (pw_mkdb() < 0)
@


1.10
log
@excessive paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.9 1998/02/24 20:46:14 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: local_passwd.c,v 1.9 1998/02/24 20:46:14 deraadt Exp $";
d54 3
a56 1

d90 1
a90 1
	if (pfd < 0)
d112 1
a112 1
	int tries;
a113 1
	int pwd_gensalt __P(( char *, int, struct passwd *, char));
d123 2
d136 3
a138 7
		if (strlen(p) <= 5 && ++tries < 2) {
			(void)printf("Please enter a longer password.\n");
			continue;
		}
		for (t = p; *t && islower(*t); ++t);
		if (!*t && ++tries < 2) {
			(void)printf("Please don't use an all-lower case password.\nUnusual capitalization, control characters or digits are suggested.\n");
a139 1
		}
@


1.9
log
@catch special password "s/key" and refuse it
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.8 1997/04/07 06:43:09 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: local_passwd.c,v 1.8 1997/04/07 06:43:09 millert Exp $";
d142 2
a143 1
		(void)strcpy(buf, p);
@


1.8
log
@Better error message when lookup of getlogin() != uid
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.7 1997/03/27 00:30:53 weingart Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: local_passwd.c,v 1.7 1997/03/27 00:30:53 weingart Exp $";
d128 4
@


1.7
log
@Slight cleanup, more needed
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.6 1997/02/16 20:08:56 provos Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: local_passwd.c,v 1.6 1997/02/16 20:08:56 provos Exp $";
d75 1
a75 1
		warnx("login != uid: %s", strerror(EACCES));
@


1.6
log
@cleaned up, moved pw_getconf to libutil, removed _'s in option names
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.5 1997/02/14 23:27:28 provos Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: local_passwd.c,v 1.5 1997/02/14 23:27:28 provos Exp $";
d44 1
d49 1
d53 1
a53 1
uid_t uid;
a54 2
char *progname = "passwd";
char *tempname;
d56 1
d69 1
a69 1
		(void)fprintf(stderr, "passwd: unknown user %s.\n", uname);
d75 1
a75 1
		(void)fprintf(stderr, "passwd: %s\n", strerror(EACCES));
@


1.5
log
@include blowfish cipher - free config of which cipher to use
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.4 1996/09/30 01:54:48 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: local_passwd.c,v 1.4 1996/09/30 01:54:48 millert Exp $";
d111 1
a111 1
	void pwd_gensalt __P(( char *, int, struct passwd *, char));
d142 4
a145 1
	pwd_gensalt( salt, _PASSWORD_LEN, pw, 'l' );
a146 14
}

static unsigned char itoa64[] =		/* 0 ... 63 => ascii - 64 */
	"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

to64(s, v, n)
	register char *s;
	register long v;
	register int n;
{
	while (--n >= 0) {
		*s++ = itoa64[v&0x3f];
		v >>= 6;
	}
@


1.4
log
@If can't open temp file (and it doesn't already exist) give real error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: local_passwd.c,v 1.3 1996/06/26 05:37:46 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: local_passwd.c,v 1.3 1996/06/26 05:37:46 deraadt Exp $";
d110 2
a111 1
	char buf[_PASSWORD_LEN+1], salt[9], *crypt(), *getpass();
d142 1
a142 9
	/* grab a random printable character that isn't a colon */
	(void)srandom((int)time((time_t *)NULL));
#ifdef NEWSALT
	salt[0] = _PASSWORD_EFMT1;
	to64(&salt[1], (long)(29 * 25), 4);
	to64(&salt[5], random(), 4);
#else
	to64(&salt[0], random(), 2);
#endif
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: local_passwd.c,v 1.2 1996/05/22 11:35:27 deraadt Exp $";
d80 6
a85 2
	if (tfd < 0)
		errx(1, "the passwd file is busy.");
@


1.2
log
@libutil
@
text
@d1 2
d38 1
a38 1
static char rcsid[] = "$Id: local_passwd.c,v 1.1.1.1 1995/10/18 08:45:54 deraadt Exp $";
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: local_passwd.c,v 1.7 1994/12/24 17:27:42 cgd Exp $";
d40 1
d45 3
d77 6
a82 2
	pfd = pw_lock();
	tfd = pw_tmp();
d93 1
a93 1
	if (!pw_mkdb())
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

