head	1.50;
access;
symbols
	OPENBSD_6_2_BASE:1.50
	OPENBSD_6_1:1.50.0.8
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.50.0.4
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.48.0.4
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.38.0.4
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.2
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.36.0.12
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.10
	OPENBSD_5_0:1.36.0.8
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.36.0.6
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.4
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.2
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.35.0.4
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.34.0.10
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.8
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.6
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.4
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.33.0.4
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.31.0.4
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.31.0.2
	OPENBSD_3_6_BASE:1.31
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.11.0.10
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.8
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.6
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.4
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.50
date	2015.10.29.03.00.31;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	06UDXZMn2Ng0SDPv;

1.49
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	0Dp7Dy9FuNZesYo2;

1.48
date	2015.03.15.00.41.28;	author millert;	state Exp;
branches;
next	1.47;
commitid	IbVxlqGw2UipKdDr;

1.47
date	2015.03.14.18.00.31;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	z0V7quTdhXS2Nibu;

1.46
date	2015.02.08.23.40.34;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	yGZX28AeTChVE8eY;

1.45
date	2015.01.16.06.40.09;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	Uu5nFG3wCl0LACBb;

1.44
date	2014.12.09.15.40.23;	author tedu;	state Exp;
branches;
next	1.43;
commitid	iI3BODDZbfU8EUzf;

1.43
date	2014.11.26.18.34.51;	author millert;	state Exp;
branches;
next	1.42;
commitid	9QOFSShUOtA0kQLF;

1.42
date	2014.04.22.12.36.36;	author okan;	state Exp;
branches;
next	1.41;

1.41
date	2014.04.17.14.49.11;	author okan;	state Exp;
branches;
next	1.40;

1.40
date	2014.04.17.09.56.09;	author guenther;	state Exp;
branches;
next	1.39;

1.39
date	2013.08.22.04.43.40;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2013.02.18.10.40.12;	author fgsch;	state Exp;
branches;
next	1.37;

1.37
date	2013.02.12.20.24.32;	author lum;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.27.23.59.39;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2009.05.01.10.38.17;	author chl;	state Exp;
branches;
next	1.34;

1.34
date	2006.10.27.07.16.25;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.14.15.38.05;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.01.02.10.24;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.16.22.30.08;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.08.13.36.52;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2003.11.09.20.13.57;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.14.21.02.09;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.10.22.20.47;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.03.02.56.09;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.29.17.21.39;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.25.07.13.55;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.14.02.04.58;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.06.18.40.14;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.05.16.24.59;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.23.04.10.14;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.16.21.27.47;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.04.17.40.59;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.05.09.42.13;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.18.17.17.39;	author pvalchev;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.12.05.17.13;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.06.22.10.09;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.31.17.42.26;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.12.09.16.03;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.07.13.02.11.33;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.04.25.00.40.18;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.03.10.00.50.40;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.08.25.23.11.12;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.08.21.05.46.56;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.02.23.34;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.07.20.09.07.17;	author jdm;	state Exp;
branches;
next	1.4;

1.4
date	97.07.20.07.54.09;	author jdm;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.42.41;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.34.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.28;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.50
log
@pledge "stdio rpath".
@
text
@/*	$OpenBSD: last.c,v 1.49 2015/08/20 22:32:41 deraadt Exp $	*/
/*	$NetBSD: last.c,v 1.6 1994/12/24 16:49:02 cgd Exp $	*/

/*
 * Copyright (c) 1987, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <fcntl.h>
#include <libgen.h>
#include <paths.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>
#include <utmp.h>

#define	NO	0				/* false/no */
#define	YES	1				/* true/yes */
#define ATOI2(ar)	((ar)[0] - '0') * 10 + ((ar)[1] - '0'); (ar) += 2;

static struct utmp	buf[1024];		/* utmp read buffer */

struct arg {
	char	*name;				/* argument */
#define	HOST_TYPE	-2
#define	TTY_TYPE	-3
#define	USER_TYPE	-4
	int	type;				/* type of arg */
	struct	arg *next;			/* linked list pointer */
} *arglist;

struct ttytab {
	time_t	logout;				/* log out time */
	char	tty[UT_LINESIZE + 1];		/* terminal name */
	struct	ttytab*next;			/* linked list pointer */
} *ttylist;

static time_t	currentout;			/* current logout value */
static long	maxrec = -1;			/* records to display */
static char	*file = _PATH_WTMP;		/* wtmp file */
static int	fulltime = 0;			/* Display seconds? */
static time_t	snaptime = 0;			/* report only at this time */
static int	calculate = 0;
static int	seconds = 0;

void	 addarg(int, char *);
struct ttytab	*addtty(char *);
void	 hostconv(char *);
void	 onintr(int);
char	*ttyconv(char *);
time_t	 dateconv(char *);
int	 want(struct utmp *, int);
void	 wtmp(void);
void	 checkargs(void);
void	 print_entry(const struct utmp *);
void	 usage(void);

#define NAME_WIDTH	9
#define HOST_WIDTH	24

#define SECSPERDAY	(24 * 60 * 60)

int
main(int argc, char *argv[])
{
	const char *errstr;
	int ch, lastch = '\0', newarg = 1, prevoptind = 1;

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "0123456789cf:h:n:st:d:T")) != -1) {
		switch (ch) {
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			/*
			 * kludge: last was originally designed to take
			 * a number after a dash.
			 */
			if (newarg || !isdigit(lastch))
				maxrec = 0;
			else if (maxrec > INT_MAX / 10)
				usage();
			maxrec = (maxrec * 10) + (ch - '0');
			break;
		case 'c':
			calculate = 1;
			break;
		case 'f':
			file = optarg;
			break;
		case 'h':
			hostconv(optarg);
			addarg(HOST_TYPE, optarg);
			break;
		case 'n':
			maxrec = strtonum(optarg, 0, LONG_MAX, &errstr);
			if (errstr != NULL)
				errx(1, "number of lines is %s: %s", errstr,
				    optarg);
			if (maxrec == 0)
				exit(0);
			break;
		case 's':
			seconds = 1;
			break;
		case 't':
			addarg(TTY_TYPE, ttyconv(optarg));
			break;
		case 'd':
			snaptime = dateconv(optarg);
			break;
		case 'T':
			fulltime = 1;
			break;
		default:
			usage();
		}
		lastch = ch;
		newarg = optind != prevoptind;
		prevoptind = optind;
	}
	if (maxrec == 0)
		exit(0);

	if (argc) {
		setvbuf(stdout, NULL, _IOLBF, 0);
		for (argv += optind; *argv; ++argv) {
#define	COMPATIBILITY
#ifdef	COMPATIBILITY
			/* code to allow "last p5" to work */
			addarg(TTY_TYPE, ttyconv(*argv));
#endif
			addarg(USER_TYPE, *argv);
		}
	}

	checkargs();
	wtmp();
	exit(0);
}

/*
 * if snaptime is set, print warning if usernames, or -t or -h
 * flags are also provided
 */
void
checkargs(void)
{
	int	ttyflag = 0;
	struct arg *step;

	if (!snaptime || !arglist)
		return;

	for (step = arglist; step; step = step->next)
		switch (step->type) {
		case HOST_TYPE:
			(void)fprintf(stderr,
			    "Warning: Ignoring hostname flag\n");
			break;
		case TTY_TYPE:
			if (!ttyflag) { /* don't print this twice */
				(void)fprintf(stderr,
				    "Warning: Ignoring tty flag\n");
				ttyflag = 1;
			}
			break;
		case USER_TYPE:
			(void)fprintf(stderr,
			    "Warning: Ignoring username[s]\n");
			break;
		default:
			break;
			/* PRINT NOTHING */
		}
}

void
print_entry(const struct utmp *bp)
{
	printf("%-*.*s %-*.*s %-*.*s ",
	    NAME_WIDTH, UT_NAMESIZE, bp->ut_name,
	    UT_LINESIZE, UT_LINESIZE, bp->ut_line,
	    HOST_WIDTH, UT_HOSTSIZE, bp->ut_host);

	if (seconds)
		printf("%lld", (long long)bp->ut_time);
	else {
		struct tm *tm;

		tm = localtime(&bp->ut_time);
		if (tm == NULL) {
			/* bogus entry?  format as epoch time... */
			printf("%lld", (long long)bp->ut_time);
		} else {
			char	tim[40];

			strftime(tim, sizeof tim,
			    fulltime ? "%a %b %d %H:%M:%S" : "%a %b %d %H:%M",
			    tm);
			printf("%s", tim);
		}
	}
}


/*
 * read through the wtmp file
 */
void
wtmp(void)
{
	time_t	delta, total = 0;
	int	timesize, wfd, snapfound = 0;
	char	*ct, *crmsg = "invalid";
	struct utmp	*bp;
	struct stat	stb;
	ssize_t	bytes;
	off_t	bl;
	struct ttytab	*T;

	if ((wfd = open(file, O_RDONLY, 0)) < 0 || fstat(wfd, &stb) == -1)
		err(1, "%s", file);
	bl = (stb.st_size + sizeof(buf) - 1) / sizeof(buf);

	if (fulltime)
		timesize = 8;	/* HH:MM:SS */
	else
		timesize = 5;	/* HH:MM */

	(void)time(&buf[0].ut_time);
	(void)signal(SIGINT, onintr);
	(void)signal(SIGQUIT, onintr);

	while (--bl >= 0) {
		if (lseek(wfd, bl * sizeof(buf), SEEK_SET) == -1 ||
		    (bytes = read(wfd, buf, sizeof(buf))) == -1)
			err(1, "%s", file);
		for (bp = &buf[bytes / sizeof(buf[0]) - 1]; bp >= buf; --bp) {
			/*
			 * if the terminal line is '~', the machine stopped.
			 * see utmp(5) for more info.
			 */
			if (bp->ut_line[0] == '~' && !bp->ut_line[1]) {
				/* everybody just logged out */
				for (T = ttylist; T; T = T->next)
					T->logout = -bp->ut_time;
				currentout = -bp->ut_time;
				crmsg = strncmp(bp->ut_name, "shutdown",
				    UT_NAMESIZE) ? "crash" : "shutdown";

				/*
				 * if we're in snapshot mode, we want to
				 * exit if this shutdown/reboot appears
				 * while we we are tracking the active
				 * range
				 */
				if (snaptime && snapfound) {
					close(wfd);
					return;
				}

				/*
				 * don't print shutdown/reboot entries
				 * unless flagged for
				 */
				if (want(bp, NO)) {
					print_entry(bp);
					printf("\n");
					if (maxrec != -1 && !--maxrec) {
						close(wfd);
						return;
					}
				}
				continue;
			}

			/*
			 * if the line is '{' or '|', date got set; see
			 * utmp(5) for more info.
			 */
			if ((bp->ut_line[0] == '{' || bp->ut_line[0] == '|') &&
			    !bp->ut_line[1]) {
				if (want(bp, NO)) {
					print_entry(bp);
					printf("\n");
					if (maxrec && !--maxrec) {
						close(wfd);
						return;
					}
				}
				continue;
			}

			/* find associated tty */
			for (T = ttylist;; T = T->next) {
				if (!T) {
					/* add new one */
					T = addtty(bp->ut_line);
					break;
				}
				if (!strncmp(T->tty, bp->ut_line, UT_LINESIZE))
					break;
			}

			/*
			 * print record if not in snapshot mode and wanted
			 * or in snapshot mode and in snapshot range
			 */
			if (bp->ut_name[0] &&
			    ((want(bp, YES)) || (bp->ut_time < snaptime &&
			    (T->logout > snaptime || !T->logout ||
			    T->logout < 0)))) {
				snapfound = 1;
				print_entry(bp);
				printf(" ");

				if (!T->logout)
					puts("  still logged in");
				else {
					if (T->logout < 0) {
						T->logout = -T->logout;
						printf("- %s", crmsg);
					} else {
						if (seconds)
							printf("- %lld",
							    (long long)T->logout);
						else
							printf("- %*.*s",
							    timesize, timesize,
							    ctime(&T->logout)+11);
					}
					delta = T->logout - bp->ut_time;
					if (seconds)
						printf("  (%lld)\n",
						    (long long)delta);
					else {
						if (delta < SECSPERDAY)
							printf("  (%*.*s)\n",
							    timesize, timesize,
							    asctime(gmtime(&delta))+11);
						else
							printf(" (%lld+%*.*s)\n",
							    (long long)delta / SECSPERDAY,
							    timesize, timesize,
							    asctime(gmtime(&delta))+11);
					}
					if (calculate)
						total += delta;
				}
				if (maxrec != -1 && !--maxrec) {
					close(wfd);
					return;
				}
			}
			T->logout = bp->ut_time;
		}
	}
	close(wfd);
	if (calculate) {
		if ((total / SECSPERDAY) > 0) {
			int days = (total / SECSPERDAY);
			total -= (days * SECSPERDAY);

			printf("\nTotal time: %d days, %*.*s\n",
			    days, timesize, timesize,
			    asctime(gmtime(&total))+11);
		} else
			printf("\nTotal time: %*.*s\n",
			    timesize, timesize,
			    asctime(gmtime(&total))+11);
	}
	ct = ctime(&buf[0].ut_time);
	printf("\n%s begins %10.10s %*.*s %4.4s\n", basename(file), ct,
	    timesize, timesize, ct + 11, ct + 20);
}

/*
 * see if want this entry
 */
int
want(struct utmp *bp, int check)
{
	struct arg *step;

	if (check) {
		/*
		 * some entries, such as ftp and uucp, will 
		 * include process name plus id; exclude entries
		 * that start with 'console' and 'tty' from
		 * having the process id stripped.
		 */
		if ((strncmp(bp->ut_line, "console", strlen("console")) != 0) &&
		    (strncmp(bp->ut_line, "tty", strlen("tty")) != 0)) {
			char *s;
			for (s = bp->ut_line;
			     *s != '\0' && !isdigit((unsigned char)*s); s++)
				;
			*s = '\0';
		}
	}

	if (snaptime)		/* if snaptime is set, return NO */
		return (NO);

	if (!arglist)
		return (YES);

	for (step = arglist; step; step = step->next)
		switch (step->type) {
		case HOST_TYPE:
			if (!strncasecmp(step->name, bp->ut_host, UT_HOSTSIZE))
				return (YES);
			break;
		case TTY_TYPE:
			if (!strncmp(step->name, bp->ut_line, UT_LINESIZE))
				return (YES);
			break;
		case USER_TYPE:
			if (!strncmp(step->name, bp->ut_name, UT_NAMESIZE))
				return (YES);
			break;
		}

	return (NO);
}

/*
 * add an entry to a linked list of arguments
 */
void
addarg(int type, char *arg)
{
	struct arg *cur;

	if (!(cur = malloc((u_int)sizeof(struct arg))))
		err(1, "malloc failure");
	cur->next = arglist;
	cur->type = type;
	cur->name = arg;
	arglist = cur;
}

/*
 * add an entry to a linked list of ttys
 */
struct ttytab *
addtty(char *ttyname)
{
	struct ttytab *cur;

	if (!(cur = malloc((u_int)sizeof(struct ttytab))))
		err(1, "malloc failure");
	cur->next = ttylist;
	cur->logout = currentout;
	memmove(cur->tty, ttyname, UT_LINESIZE);
	return (ttylist = cur);
}

/*
 * convert the hostname to search pattern; if the supplied host name
 * has a domain attached that is the same as the current domain, rip
 * off the domain suffix since that's what login(1) does.
 */
void
hostconv(char *arg)
{
	static char *hostdot, name[HOST_NAME_MAX+1];
	static int first = 1;
	char *argdot;

	if (!(argdot = strchr(arg, '.')))
		return;
	if (first) {
		first = 0;
		if (gethostname(name, sizeof(name)))
			err(1, "gethostname");
		hostdot = strchr(name, '.');
	}
	if (hostdot && !strcasecmp(hostdot, argdot))
		*argdot = '\0';
}

/*
 * convert tty to correct name.
 */
char *
ttyconv(char *arg)
{
	size_t len = 8;
	char *mval;

	/*
	 * kludge -- we assume that all tty's end with
	 * a two character suffix.
	 */
	if (strlen(arg) == 2) {
		/* either 6 for "ttyxx" or 8 for "console" */
		if (!(mval = malloc(len)))
			err(1, "malloc failure");
		if (!strcmp(arg, "co"))
			(void)strlcpy(mval, "console", len);
		else
			snprintf(mval, len, "tty%s", arg);
		return (mval);
	}
	if (!strncmp(arg, _PATH_DEV, sizeof(_PATH_DEV) - 1))
		return (arg + 5);
	return (arg);
}

/*
 * Convert the snapshot time in command line given in the format
 *	[[[CC]YY]MMDD]hhmm[.SS]] to a time_t.
 *	Derived from atime_arg1() in usr.bin/touch/touch.c
 */
time_t
dateconv(char *arg)
{
	time_t timet;
	struct tm *t;
	int yearset;
	char *p;

	/* Start with the current time. */
	if (time(&timet) < 0)
		err(1, "time");
	if ((t = localtime(&timet)) == NULL)
		err(1, "localtime");

	/* [[[CC]YY]MMDD]hhmm[.SS] */
	if ((p = strchr(arg, '.')) == NULL)
		t->tm_sec = 0;		/* Seconds defaults to 0. */
	else {
		if (strlen(p + 1) != 2)
			goto terr;
		*p++ = '\0';
		t->tm_sec = ATOI2(p);
	}

	yearset = 0;
	switch (strlen(arg)) {
	case 12:			/* CCYYMMDDhhmm */
		t->tm_year = ATOI2(arg);
		t->tm_year *= 100;
		yearset = 1;
		/* FALLTHROUGH */
	case 10:			/* YYMMDDhhmm */
		if (yearset) {
			yearset = ATOI2(arg);
			t->tm_year += yearset;
		} else {
			yearset = ATOI2(arg);
			if (yearset < 69)
				t->tm_year = yearset + 2000;
			else
				t->tm_year = yearset + 1900;
		}
		t->tm_year -= 1900;	/* Convert to UNIX time. */
		/* FALLTHROUGH */
	case 8:				/* MMDDhhmm */
		t->tm_mon = ATOI2(arg);
		--t->tm_mon;		/* Convert from 01-12 to 00-11 */
		t->tm_mday = ATOI2(arg);
		t->tm_hour = ATOI2(arg);
		t->tm_min = ATOI2(arg);
		break;
	case 4:				/* hhmm */
		t->tm_hour = ATOI2(arg);
		t->tm_min = ATOI2(arg);
		break;
	default:
		goto terr;
	}
	t->tm_isdst = -1;		/* Figure out DST. */
	timet = mktime(t);
	if (timet == -1)
terr:		errx(1, "out of range or illegal time specification: "
		    "[[[CC]YY]MMDD]hhmm[.SS]");
	return (timet);
}


/*
 * on interrupt, we inform the user how far we've gotten
 */
void
onintr(int signo)
{
	char str[1024], *ct, ctbuf[26];

	ct = ctime_r(&buf[0].ut_time, ctbuf);
	snprintf(str, sizeof str, "\ninterrupted %10.10s %8.8s \n",
	    ct, ct + 11);
	write(STDOUT_FILENO, str, strlen(str));
	if (signo == SIGINT)
		_exit(1);
}

void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-csT] [-d date] [-f file] [-h host]"
	    " [-n number] [-t tty] [user ...]\n", __progname);
	exit(1);
}
@


1.49
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.48 2015/03/15 00:41:28 millert Exp $	*/
d100 3
@


1.48
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.47 2015/03/14 18:00:31 deraadt Exp $	*/
d466 1
a466 1
	if (!(cur = (struct arg *)malloc((u_int)sizeof(struct arg))))
d482 1
a482 1
	if (!(cur = (struct ttytab *)malloc((u_int)sizeof(struct ttytab))))
@


1.47
log
@use ctime_r to avoid a re-entrancy signal race
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.46 2015/02/08 23:40:34 deraadt Exp $	*/
a44 1
#include <tzfile.h>
d92 2
@


1.46
log
@in getopt() blocks, stop incrementing flag variable which are supposed
to just be 0/1
ok miod florian
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.45 2015/01/16 06:40:09 deraadt Exp $	*/
d619 1
a619 1
	char str[1024], *ct;
d621 1
a621 1
	ct = ctime(&buf[0].ut_time);	/* XXX signal race */
@


1.45
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.44 2014/12/09 15:40:23 tedu Exp $	*/
d115 1
a115 1
			calculate++;
d133 1
a133 1
			seconds++;
@


1.44
log
@init crmsg to something so it doesn't crash on invalid wtmp files.
from david higgs
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.43 2014/11/26 18:34:51 millert Exp $	*/
a32 1
#include <sys/param.h>
d47 1
d497 1
a497 1
	static char *hostdot, name[MAXHOSTNAMELEN];
@


1.43
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.42 2014/04/22 12:36:36 okan Exp $	*/
d244 1
a244 1
	char	*ct, *crmsg;
@


1.42
log
@Instead of special casing ftpd, uucpd and others that may have entries
in wtmp, go the other way and exclude entries we know ('console' and
'tty') from pid stripping, then strip the rest.

idea, feedback and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.41 2014/04/17 14:49:11 okan Exp $	*/
d155 1
a155 1
		setlinebuf(stdout);
@


1.41
log
@remove special case for uucp entries.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.40 2014/04/17 09:56:09 guenther Exp $	*/
d417 4
a420 2
		 * when ftp logs in over a network, the entry in
		 * the utmp file is the name plus its process id.
d422 8
a429 2
		if (!strncmp(bp->ut_line, "ftp", sizeof("ftp") - 1))
			bp->ut_line[3] = '\0';
@


1.40
log
@Correct some time_t printing; factor out a grotty block while here

Based on a diff from Arto Jonsson (ajonsson (at) kapsi.fi)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.39 2013/08/22 04:43:40 guenther Exp $	*/
d417 2
a418 3
		 * when uucp and ftp log in over a network, the entry in
		 * the utmp file is the name plus their process id.  See
		 * etc/ftpd.c and usr.bin/uucp/uucpd.c for more information.
a421 2
		else if (!strncmp(bp->ut_line, "uucp", sizeof("uucp") - 1))
			bp->ut_line[4] = '\0';
@


1.39
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.38 2013/02/18 10:40:12 fgsch Exp $	*/
d88 1
d207 28
d244 1
a244 1
	char	*ct, *crmsg, tim[40];
d297 2
a298 15
					if (seconds) {
						snprintf(tim, sizeof tim, "%ld",
						    (long)bp->ut_time);
					} else {
						ct = ctime(&bp->ut_time);
						snprintf(tim, sizeof tim,
						    "%10.10s %*.*s", ct,
						    timesize, timesize, ct + 11);
					}
					printf("%-*.*s %-*.*s %-*.*s %s \n",
					    NAME_WIDTH, UT_NAMESIZE, bp->ut_name,
					    UT_LINESIZE, UT_LINESIZE, bp->ut_line,
					    HOST_WIDTH, UT_HOSTSIZE, bp->ut_host,
					    tim);

d314 2
a315 15
					if (seconds) {
						snprintf(tim, sizeof tim, "%ld",
						    (long)bp->ut_time);
					} else {
						ct = ctime(&bp->ut_time);
						snprintf(tim, sizeof tim,
						    "%10.10s %*.*s", ct,
						    timesize, timesize, ct + 11);
					}
					printf("%-*.*s %-*.*s %-*.*s %s \n",
					    NAME_WIDTH, UT_NAMESIZE, bp->ut_name,
					    UT_LINESIZE, UT_LINESIZE, bp->ut_line,
					    HOST_WIDTH, UT_HOSTSIZE, bp->ut_host,
					    tim);

d344 2
a345 14
				if (seconds) {
					snprintf(tim, sizeof tim, "%ld",
					    (long)bp->ut_time);
				} else {
					ct = ctime(&bp->ut_time);
					snprintf(tim, sizeof tim,
					    "%10.10s %*.*s", ct,
					    timesize, timesize, ct + 11);
				}
				printf("%-*.*s %-*.*s %-*.*s %s ",
				    NAME_WIDTH, UT_NAMESIZE, bp->ut_name,
				    UT_LINESIZE, UT_LINESIZE, bp->ut_line,
				    HOST_WIDTH, UT_HOSTSIZE, bp->ut_host,
				    tim);
d355 2
a356 2
							printf("- %ld",
							    (long)T->logout);
d364 2
a365 1
						printf("  (%ld)\n", (long)delta);
@


1.38
log
@Fix after last commit: add missing header.
sthen@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.37 2013/02/12 20:24:32 lum Exp $	*/
d380 2
a381 2
							printf(" (%ld+%*.*s)\n",
							    delta / SECSPERDAY,
@


1.37
log
@Reflect the -f option in last's output. Original diff from Jacob L. Leifman.
Other feedback from Callum Davies and sthen@@
ok mpi@@ ian@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.36 2009/10/27 23:59:39 deraadt Exp $	*/
d39 1
@


1.36
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.35 2009/05/01 10:38:17 chl Exp $	*/
d410 2
a411 2
	printf("\nwtmp begins %10.10s %*.*s %4.4s\n", ct, timesize, timesize,
	    ct + 11, ct + 20);
@


1.35
log
@add missing header needed by isdigit()

ok otto@@ millert@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.34 2006/10/27 07:16:25 jmc Exp $	*/
a31 13

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1987, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)last.c	8.2 (Berkeley) 4/2/94";
#endif
static char rcsid[] = "$OpenBSD: last.c,v 1.34 2006/10/27 07:16:25 jmc Exp $";
#endif /* not lint */
@


1.34
log
@- simplify and sort synopsis
- sort options
- some minor text tweaks
- sync usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.33 2005/11/14 15:38:05 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: last.c,v 1.33 2005/11/14 15:38:05 deraadt Exp $";
d49 1
@


1.33
log
@fix fd leak; then i got a bit carried away making the code prettier
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.32 2005/07/01 02:10:24 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: last.c,v 1.32 2005/07/01 02:10:24 millert Exp $";
d649 2
a650 2
	    "usage: %s [-#] [-csT] [-f file] [-n #] [-t tty] [-h host]"
	    " [-d [[[CC]YY]MMDD]hhmm[.SS]] [user ...]\n", __progname);
@


1.32
log
@Replace numeric argument handling (e.g. last -30) with something that
can deal with mixer number and normal arguments, adapted from my code
in diff(1).  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.31 2004/06/16 22:30:08 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: last.c,v 1.31 2004/06/16 22:30:08 millert Exp $";
d67 1
a67 1
typedef struct arg {
d73 2
a74 3
	struct arg	*next;			/* linked list pointer */
} ARG;
ARG	*arglist;				/* head of linked list */
d76 1
a76 1
typedef struct ttytab {
d79 2
a80 3
	struct ttytab	*next;			/* linked list pointer */
} TTY;
TTY	*ttylist;				/* head of linked list */
d83 1
a83 1
static long	maxrec;				/* records to display */
d86 3
a88 6
static time_t	snaptime;			/* if != 0, we will only
						 * report users logged in
						 * at this snapshot time
						 */
static int calculate = 0;
static int seconds = 0;
d91 1
a91 1
TTY	*addtty(char *);
d108 1
a108 2
	char *p;
	int ch, lastch, newarg, prevoptind;
a109 5
	maxrec = -1;
	snaptime = 0;
	lastch = '\0';
	newarg = 1;
	prevoptind = 1;
d182 2
a183 3
 * checkargs --
 *	if snaptime is set, print warning if usernames, or -t or -h
 *	flags are also provided
a184 1

a187 1
	ARG	*step;
d189 1
d191 1
a191 4
	if (!snaptime)
		return;

	if (!arglist)
d219 1
a219 2
 * wtmp --
 *	read through the wtmp file
d224 6
a229 5
	struct utmp	*bp;		/* current structure */
	TTY	*T;			/* tty list entry */
	struct stat	stb;		/* stat of file for size */
	time_t	delta;			/* time difference */
	time_t	total = 0;
d231 2
a232 4
	int	timesize;		/* how long time string gonna be */
	int	bytes, wfd;
	char	*ct, *crmsg;
	int	snapfound = 0;		/* found snapshot entry? */
d262 1
d269 2
a270 1
				if (snaptime && snapfound)
d272 2
d280 2
a281 6
						printf("%-*.*s %-*.*s %-*.*s %ld \n",
						    NAME_WIDTH, UT_NAMESIZE,
						    bp->ut_name, UT_LINESIZE,
						    UT_LINESIZE, bp->ut_line,
						    HOST_WIDTH, UT_HOSTSIZE,
						    bp->ut_host, (long)bp->ut_time);
d284 3
a286 7
						printf("%-*.*s %-*.*s %-*.*s %10.10s %*.*s \n",
						    NAME_WIDTH, UT_NAMESIZE,
						    bp->ut_name, UT_LINESIZE,
						    UT_LINESIZE, bp->ut_line,
						    HOST_WIDTH, UT_HOSTSIZE,
						    bp->ut_host, ct, timesize,
						    timesize, ct + 11);
d288 8
a295 1
					if (maxrec != -1 && !--maxrec)
d297 1
d301 1
d306 2
a307 2
			if ((bp->ut_line[0] == '{' || bp->ut_line[0] == '|')
			    && !bp->ut_line[1]) {
d310 1
a310 4
						printf("%-*.*s %-*.*s %-*.*s %ld \n",
						    NAME_WIDTH, UT_NAMESIZE, bp->ut_name,
						    UT_LINESIZE, UT_LINESIZE, bp->ut_line,
						    HOST_WIDTH, UT_HOSTSIZE, bp->ut_host,
d314 3
a316 5
						printf("%-*.*s %-*.*s %-*.*s %10.10s %*.*s \n",
						    NAME_WIDTH, UT_NAMESIZE, bp->ut_name,
						    UT_LINESIZE, UT_LINESIZE, bp->ut_line,
						    HOST_WIDTH, UT_HOSTSIZE, bp->ut_host,
						    ct, timesize, timesize, ct + 11);
d318 8
a325 1
					if (maxrec && !--maxrec)
d327 1
d331 1
d342 1
d353 1
a353 4
					printf("%-*.*s %-*.*s %-*.*s %ld ",
					    NAME_WIDTH, UT_NAMESIZE, bp->ut_name,
					    UT_LINESIZE, UT_LINESIZE, bp->ut_line,
					    HOST_WIDTH, UT_HOSTSIZE, bp->ut_host,
d357 3
a359 5
					printf("%-*.*s %-*.*s %-*.*s %10.10s %*.*s ",
					    NAME_WIDTH, UT_NAMESIZE, bp->ut_name,
					    UT_LINESIZE, UT_LINESIZE, bp->ut_line,
					    HOST_WIDTH, UT_HOSTSIZE, bp->ut_host,
					    ct, timesize, timesize, ct + 11);
d361 6
d399 2
a400 1
				if (maxrec != -1 && !--maxrec)
d402 1
d407 1
d427 1
a427 2
 * want --
 *	see if want this entry
d432 1
a432 1
	ARG *step;
d453 1
a453 1
		switch(step->type) {
d472 1
a472 2
 * addarg --
 *	add an entry to a linked list of arguments
d477 1
a477 1
	ARG *cur;
d479 1
a479 1
	if (!(cur = (ARG *)malloc((u_int)sizeof(ARG))))
d488 1
a488 2
 * addtty --
 *	add an entry to a linked list of ttys
d490 1
a490 1
TTY *
d493 1
a493 1
	TTY *cur;
d495 1
a495 1
	if (!(cur = (TTY *)malloc((u_int)sizeof(TTY))))
d504 3
a506 4
 * hostconv --
 *	convert the hostname to search pattern; if the supplied host name
 *	has a domain attached that is the same as the current domain, rip
 *	off the domain suffix since that's what login(1) does.
d511 1
a512 1
	static char *hostdot, name[MAXHOSTNAMELEN];
d528 1
a528 2
 * ttyconv --
 *	convert tty to correct name.
d533 1
a534 1
	size_t len = 8;
a555 1
 * dateconv --
d628 1
a628 2
 * onintr --
 *	on interrupt, we inform the user how far we've gotten
@


1.31
log
@Add a new -n option that replaces the old -number option (which now
only exists for backwards compat).
Based on a diff from robert@@; OK robert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.30 2004/01/08 13:36:52 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: last.c,v 1.30 2004/01/08 13:36:52 otto Exp $";
d114 1
a114 1
	int ch;
d118 4
a121 1
	while ((ch = getopt(argc, argv, "0123456789cf:h:n:st:d:T")) != -1)
d129 5
a133 9
			if (maxrec == -1) {
				p = argv[optind - 1];
				if (p[0] == '-' && p[1] == ch && !p[2])
					maxrec = atol(++p);
				else
					maxrec = atol(argv[optind] + 1);
				if (maxrec == 0)
					exit(0);
			}
a164 1
		case '?':
d168 6
@


1.30
log
@Fix uninitialized variable. From Ilya Voronin <ivoronin at trancom dot ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.29 2003/11/09 20:13:57 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: last.c,v 1.29 2003/11/09 20:13:57 otto Exp $";
d112 2
a113 2
	extern int optind;
	extern char *optarg;
a114 1
	char *p;
d118 1
a118 1
	while ((ch = getopt(argc, argv, "0123456789cf:h:st:d:T")) != -1)
d132 1
a132 1
				if (!maxrec)
d146 8
d656 1
a656 1
	    "usage: %s [-#] [-csT] [-f file] [-t tty] [-h host]"
@


1.29
log
@Typos in comments from Jared Yanovich <jjy2+ at pitt dot edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.28 2003/08/14 21:02:09 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: last.c,v 1.28 2003/08/14 21:02:09 deraadt Exp $";
d234 1
a234 1
	time_t	total;
@


1.28
log
@make 9-char login names not stretch the line; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.27 2003/06/10 22:20:47 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: last.c,v 1.27 2003/06/10 22:20:47 deraadt Exp $";
d589 1
a589 1
		/* FALLTHOUGH */
@


1.27
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.26 2003/06/03 02:56:09 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: last.c,v 1.26 2003/06/03 02:56:09 millert Exp $";
d106 1
a106 1
#define NAME_WIDTH	8
d291 1
a291 1
						printf("%-*.*s  %-*.*s %-*.*s %10.10s %*.*s \n",
d312 5
a316 5
				printf("%-*.*s %-*.*s %-*.*s %ld \n",
					NAME_WIDTH, UT_NAMESIZE, bp->ut_name,
					UT_LINESIZE, UT_LINESIZE, bp->ut_line,
					HOST_WIDTH, UT_HOSTSIZE, bp->ut_host,
					(long)bp->ut_time);
d319 5
a323 5
				printf("%-*.*s  %-*.*s %-*.*s %10.10s %*.*s \n",
					NAME_WIDTH, UT_NAMESIZE, bp->ut_name,
					UT_LINESIZE, UT_LINESIZE, bp->ut_line,
					HOST_WIDTH, UT_HOSTSIZE, bp->ut_host,
					ct, timesize, timesize, ct + 11);
d345 3
a347 4
			    ((want(bp, YES)) ||
			     (bp->ut_time < snaptime &&
			      (T->logout > snaptime || !T->logout ||
			       T->logout < 0)))) {
d350 5
a354 5
				printf("%-*.*s %-*.*s %-*.*s %ld ",
					NAME_WIDTH, UT_NAMESIZE, bp->ut_name,
					UT_LINESIZE, UT_LINESIZE, bp->ut_line,
					HOST_WIDTH, UT_HOSTSIZE, bp->ut_host,
					(long)bp->ut_time);
d357 5
a361 5
				printf("%-*.*s  %-*.*s %-*.*s %10.10s %*.*s ",
					NAME_WIDTH, UT_NAMESIZE, bp->ut_name,
					UT_LINESIZE, UT_LINESIZE, bp->ut_line,
					HOST_WIDTH, UT_HOSTSIZE, bp->ut_host,
					ct, timesize, timesize, ct + 11);
d407 2
a408 2
				days, timesize, timesize,
				asctime(gmtime(&total))+11);
d411 2
a412 2
				timesize, timesize,
				asctime(gmtime(&total))+11);
d601 1
a601 1
		t->tm_year -= 1900;     /* Convert to UNIX time. */
d620 2
a621 2
terr:	   errx(1,
	"out of range or illegal time specification: [[[CC]YY]MMDD]hhmm[.SS]");
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.25 2003/05/29 17:21:39 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: last.c,v 1.25 2003/05/29 17:21:39 deraadt Exp $";
d110 1
a110 3
main(argc, argv)
	int argc;
	char *argv[];
d188 1
a188 1
checkargs()
d228 1
a228 1
wtmp()
d425 1
a425 3
want(bp, check)
	struct utmp *bp;
	int check;
d471 1
a471 3
addarg(type, arg)
	int type;
	char *arg;
d488 1
a488 2
addtty(ttyname)
	char *ttyname;
d507 1
a507 2
hostconv(arg)
	char *arg;
d530 1
a530 2
ttyconv(arg)
	char *arg;
d561 1
a561 2
dateconv(arg)
	char *arg;
d632 1
a632 2
onintr(signo)
	int signo;
@


1.25
log
@avoid more signal races
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.24 2003/04/25 07:13:55 tedu Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: last.c,v 1.24 2003/04/25 07:13:55 tedu Exp $";
@


1.24
log
@minor tweak to error message, from Eric in pr3235
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.23 2003/04/14 02:04:58 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.23 2003/04/14 02:04:58 deraadt Exp $";
d649 1
a649 1
	char *ct;
d651 4
a654 3
	/* XXX signal race */
	ct = ctime(&buf[0].ut_time);
	printf("\ninterrupted %10.10s %8.8s \n", ct, ct + 11);
d656 1
a656 2
		exit(1);
	(void)fflush(stdout);			/* fix required for rsh */
@


1.23
log
@fix time spec even better; emmf26@@umr.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.22 2003/04/06 18:40:14 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.22 2003/04/06 18:40:14 deraadt Exp $";
d636 1
a636 1
	"out of range or illegal time specification: [[[CC]YY[MMDD]hhmm[.SS]");
@


1.22
log
@make usage exactly like in the man page; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.21 2003/04/05 16:24:59 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.21 2003/04/05 16:24:59 deraadt Exp $";
d570 1
a570 1
 *	[[CC]YY][MMDD]hhmm[.SS]] to a time_t.
d588 1
a588 1
	/* [[CC]YY][MMDD]hhmm[.SS] */
d636 1
a636 1
	"out of range or illegal time specification: [[CC]YY][MMDD]hhmm[.SS]");
d666 1
a666 1
	    " [-d [[CC]YY][MMDD]hhmm[.SS]] [user ...]\n", __progname);
@


1.21
log
@simple snprintf and strlcpy; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.20 2002/09/23 04:10:14 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.20 2002/09/23 04:10:14 millert Exp $";
d108 1
d167 1
a167 5
			(void)fprintf(stderr,
			    "usage: last [-#] [-cns] [-f file] [-T] [-t tty]"
			    " [-h host] [-d [[CC]YY][MMDD]hhmm[.SS]"
			    " [user ...]\n");
			exit(1);
d570 1
a570 1
 *	[[CC]YY][MMDD]hhmm[.ss]] to a time_t.
d588 1
a588 1
	/* [[yy]yy][mmdd]hhmm[.ss] */
d600 1
a600 1
	case 12:			/* ccyymmddhhmm */
d605 1
a605 1
	case 10:			/* yymmddhhmm */
d636 2
a637 2
	"out of range or illegal time specification: [[yy]yy][mmdd]hhmm[.ss]");
	return timet;
d657 11
@


1.20
log
@Add missing includes, breaks and semicolons to appease gcc3; David Krause
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.19 2002/02/16 21:27:47 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.19 2002/02/16 21:27:47 millert Exp $";
d549 1
d557 1
a557 1
		if (!(mval = malloc((u_int)8)))
d560 3
a562 5
			(void)strcpy(mval, "console");
		else {
			(void)strcpy(mval, "tty");
			(void)strcpy(mval + 3, arg);
		}
@


1.19
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.18 2002/02/04 17:40:59 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.18 2002/02/04 17:40:59 mickey Exp $";
d226 1
@


1.18
log
@fix a typo; from Sam Smith <S@@mSmith.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.17 2001/11/05 09:42:13 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.17 2001/11/05 09:42:13 deraadt Exp $";
d99 9
a107 9
void	 addarg __P((int, char *));
TTY	*addtty __P((char *));
void	 hostconv __P((char *));
void	 onintr __P((int));
char	*ttyconv __P((char *));
time_t	 dateconv __P((char *));
int	 want __P((struct utmp *, int));
void	 wtmp __P((void));
void	 checkargs __P((void));
@


1.17
log
@mark a zone of signal races
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.16 2001/07/18 17:17:39 pvalchev Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.16 2001/07/18 17:17:39 pvalchev Exp $";
d67 1
a67 1
#define ATOI2(ar)       ((ar)[0] - '0') * 10 + ((ar)[1] - '0'); (ar) += 2;
d107 1
a107 1
void 	 checkargs __P((void));
d184 1
a184 1
	
d192 1
a192 1
 * 	if snaptime is set, print warning if usernames, or -t or -h 
d199 2
a200 2
   	ARG 	*step;
	int 	ttyflag = 0;
d202 1
a202 1
	if (!snaptime) 
d204 1
a204 1
	
d215 1
a215 1
			if (!ttyflag) { /* don't print this twice */ 
d228 1
a228 1
}      
d247 1
a247 1
	int 	snapfound = 0;		/* found snapshot entry? */
d277 2
a278 2
				/* 
				 * if we're in snapshop mode, we want to
d285 1
a285 1
				/* 
d287 2
a288 2
				 * unless flagged for 
				 */ 
d325 1
a325 1
				    	} else {
d332 1
a332 1
				    	}
d348 1
a348 1
			/* 
d354 1
a354 1
			     (bp->ut_time < snaptime && 
d379 1
a379 1
						if (seconds) 
d451 1
a451 1
	if (snaptime) 		/* if snaptime is set, return NO */
d570 1
a570 1
/* 
d572 3
a574 3
 * 	Convert the snapshot time in command line given in the format
 * 	[[CC]YY][MMDD]hhmm[.ss]] to a time_t.
 * 	Derived from atime_arg1() in usr.bin/touch/touch.c
d593 1
a593 1
		t->tm_sec = 0; 		/* Seconds defaults to 0. */
d623 1
a623 1
		--t->tm_mon;    	/* Convert from 01-12 to 00-11 */
d635 1
a635 1
	t->tm_isdst = -1;       	/* Figure out DST. */
@


1.16
log
@-Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.15 2001/07/12 05:17:13 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.15 2001/07/12 05:17:13 deraadt Exp $";
d654 1
@


1.15
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.14 2001/02/06 22:10:09 fgsch Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.14 2001/02/06 22:10:09 fgsch Exp $";
d296 1
a296 1
						    bp->ut_host, bp->ut_time);
d324 1
a324 1
					bp->ut_time);
d363 1
a363 1
					bp->ut_time);
d381 1
a381 1
							    T->logout);
d389 1
a389 1
						printf("  (%ld)\n", delta);
@


1.14
log
@Change host width to 24 so last produces one line per user; deraadt ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.13 2001/01/31 17:42:26 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.13 2001/01/31 17:42:26 deraadt Exp $";
d291 6
a296 6
				printf("%-*.*s %-*.*s %-*.*s %ld \n",
						NAME_WIDTH, UT_NAMESIZE,
						bp->ut_name, UT_LINESIZE,
						UT_LINESIZE, bp->ut_line,
						HOST_WIDTH, UT_HOSTSIZE,
						bp->ut_host, bp->ut_time);
d299 7
a305 7
				printf("%-*.*s  %-*.*s %-*.*s %10.10s %*.*s \n",
						NAME_WIDTH, UT_NAMESIZE,
						bp->ut_name, UT_LINESIZE,
						UT_LINESIZE, bp->ut_line,
						HOST_WIDTH, UT_HOSTSIZE,
						bp->ut_host, ct, timesize,
						timesize, ct + 11);
d439 1
a439 1
	if (check)
d449 1
@


1.13
log
@move utmp to large format, usernames to 32 chars; downsj
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.12 2000/12/12 09:16:03 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.12 2000/12/12 09:16:03 deraadt Exp $";
d110 1
a110 1
#define HOST_WIDTH	32
@


1.12
log
@incorrect time specification; noted by sigh@@kuzirabekon.econ.nagasaki-u.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.11 1998/07/13 02:11:33 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.11 1998/07/13 02:11:33 millert Exp $";
d109 3
d292 1
a292 1
						UT_NAMESIZE, UT_NAMESIZE,
d295 1
a295 1
						UT_HOSTSIZE, UT_HOSTSIZE,
d300 1
a300 1
						UT_NAMESIZE, UT_NAMESIZE,
d303 1
a303 1
						UT_HOSTSIZE, UT_HOSTSIZE,
d321 1
a321 1
					UT_NAMESIZE, UT_NAMESIZE, bp->ut_name,
d323 1
a323 1
					UT_HOSTSIZE, UT_HOSTSIZE, bp->ut_host,
d328 1
a328 1
					UT_NAMESIZE, UT_NAMESIZE, bp->ut_name,
d330 1
a330 1
					UT_HOSTSIZE, UT_HOSTSIZE, bp->ut_host,
d360 1
a360 1
					UT_NAMESIZE, UT_NAMESIZE, bp->ut_name,
d362 1
a362 1
					UT_HOSTSIZE, UT_HOSTSIZE, bp->ut_host,
d367 1
a367 1
					UT_NAMESIZE, UT_NAMESIZE, bp->ut_name,
d369 1
a369 1
					UT_HOSTSIZE, UT_HOSTSIZE, bp->ut_host,
@


1.11
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.10 1998/04/25 00:40:18 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.10 1998/04/25 00:40:18 deraadt Exp $";
d165 1
a165 1
			    " [-h host] [-d [[yy]yy[mm[dd[hh]]]]mm[.ss]]"
d569 1
a569 1
 * 	[[yy]yy][mmdd]hhmm[.ss]] to a time_t.
@


1.10
log
@print year; mason@@primenet.com.au
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.9 1998/03/10 00:50:40 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.9 1998/03/10 00:50:40 downsj Exp $";
d259 1
a259 1
		if (lseek(wfd, bl * sizeof(buf), L_SET) == -1 ||
@


1.9
log
@Add -c (for humans) and -s (for machines).
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.8 1997/08/25 23:11:12 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.8 1997/08/25 23:11:12 deraadt Exp $";
d421 2
a422 1
	printf("\nwtmp begins %10.10s %*.*s \n", ct, timesize, timesize, ct + 11);
@


1.8
log
@incorrect type for variable; enami@@but-b.or.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.7 1997/08/21 05:46:56 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.7 1997/08/21 05:46:56 deraadt Exp $";
d96 2
d121 1
a121 1
	while ((ch = getopt(argc, argv, "0123456789f:h:t:d:T")) != -1)
d139 3
d149 3
d159 1
a159 1
			fulltime = -1;
d164 1
a164 1
			    "usage: last [-#] [-f file] [-T] [-t tty]"
d239 1
d287 9
a295 1
					ct = ctime(&bp->ut_time);
d297 7
a303 6
					    UT_NAMESIZE, UT_NAMESIZE,
					    bp->ut_name, UT_LINESIZE,
					    UT_LINESIZE, bp->ut_line,
					    UT_HOSTSIZE, UT_HOSTSIZE,
					    bp->ut_host, ct, timesize,
					    timesize, ct + 11);
d316 8
a323 1
					ct = ctime(&bp->ut_time);
d325 5
a329 4
				    UT_NAMESIZE, UT_NAMESIZE, bp->ut_name,
				    UT_LINESIZE, UT_LINESIZE, bp->ut_line,
				    UT_HOSTSIZE, UT_HOSTSIZE, bp->ut_host,
				    ct, timesize, timesize, ct + 11);
d355 8
a362 1
				ct = ctime(&bp->ut_time);
d368 1
d375 8
a383 4
					else
						printf("- %*.*s",
						    timesize, timesize,
						    ctime(&T->logout)+11);
d385 15
a399 9
					if (delta < SECSPERDAY)
						printf("  (%*.*s)\n",
						    timesize, timesize,
						    asctime(gmtime(&delta))+11);
					else
						printf(" (%ld+%*.*s)\n",
						    delta / SECSPERDAY,
						    timesize, timesize,
						    asctime(gmtime(&delta))+11);
d406 13
@


1.7
log
@correct [yy]yy stuff in manpages and usage
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.6 1997/07/25 02:23:34 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.6 1997/07/25 02:23:34 mickey Exp $";
d230 2
a231 1
	time_t	bl, delta;		/* time difference */
d250 1
a250 1
		if (lseek(wfd, (off_t)(bl * sizeof(buf)), L_SET) == -1 ||
@


1.6
log
@-T to display seconds, from jhawk netbsd-pr#1548
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.5 1997/07/20 09:07:17 jdm Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.5 1997/07/20 09:07:17 jdm Exp $";
d92 3
a94 3
static time_t	snaptime;		        /* if != 0, we will only
	                                         * report users logged in
		                                 * at this snapshot time
d156 3
a158 3
				      "usage: last [-#] [-f file] [-T] [-t tty]"
				      " [-h host] [-d [MMDD]hhmm[.SS]]"
			              " [user ...]\n");
d200 2
a201 2
			(void)fprintf(stderr, "Warning: Ignoring hostname "
				              "flag\n");
d205 2
a206 2
				(void)fprintf(stderr, "Warning: Ignoring "
						      "tty flag\n");
d211 2
a212 2
			(void)fprintf(stderr, "Warning: Ignoring "
				              "username[s]\n");
d510 1
a510 1
 * 	[[CC]YY][MMDD]hhmm[.SS]] to a time_t.
d515 1
a515 1
        char *arg;
d517 61
a577 61
        time_t timet;
        struct tm *t;
        int yearset;
        char *p;

        /* Start with the current time. */
        if (time(&timet) < 0)
                err(1, "time");
        if ((t = localtime(&timet)) == NULL)
                err(1, "localtime");

        /* [[CC]YY][MMDD]hhmm[.SS] */
        if ((p = strchr(arg, '.')) == NULL)
                t->tm_sec = 0; 		/* Seconds defaults to 0. */
        else {
                if (strlen(p + 1) != 2)
                        goto terr;
                *p++ = '\0';
                t->tm_sec = ATOI2(p);
        }

        yearset = 0;
        switch (strlen(arg)) {
        case 12:                	/* CCYYMMDDhhmm */
                t->tm_year = ATOI2(arg);
                t->tm_year *= 100;
                yearset = 1;
                /* FALLTHOUGH */
        case 10:                	/* YYMMDDhhmm */
                if (yearset) {
                        yearset = ATOI2(arg);
                        t->tm_year += yearset;
                } else {
                        yearset = ATOI2(arg);
                        if (yearset < 69)
                                t->tm_year = yearset + 2000;
                        else
                                t->tm_year = yearset + 1900;
                }
                t->tm_year -= 1900;     /* Convert to UNIX time. */
                /* FALLTHROUGH */
        case 8:				/* MMDDhhmm */
                t->tm_mon = ATOI2(arg);
                --t->tm_mon;    	/* Convert from 01-12 to 00-11 */
                t->tm_mday = ATOI2(arg);
                t->tm_hour = ATOI2(arg);
                t->tm_min = ATOI2(arg);
                break;
        case 4:				/* hhmm */
                t->tm_hour = ATOI2(arg);
                t->tm_min = ATOI2(arg);
                break;
        default:
                goto terr;
        }
        t->tm_isdst = -1;       	/* Figure out DST. */
        timet = mktime(t);
        if (timet == -1)
terr:           errx(1,
        "out of range or illegal time specification: [[CC]YY][MMDD]hhmm[.SS]");
        return timet;
@


1.5
log
@minor cleanup on the -d flag code
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.4 1997/07/20 07:54:09 jdm Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.4 1997/07/20 07:54:09 jdm Exp $";
d91 1
d119 1
a119 1
	while ((ch = getopt(argc, argv, "0123456789f:h:t:d:")) != -1)
d150 3
d156 1
a156 1
				      "usage: last [-#] [-f file] [-t tty]"
d227 5
a231 4
	struct utmp	*bp;			/* current structure */
	TTY	*T;				/* tty list entry */
	struct stat	stb;			/* stat of file for size */
	time_t	bl, delta;			/* time difference */
d234 1
a234 1
	int 	snapfound = 0;		        /* found snapshot entry? */
d239 5
d278 1
a278 1
				printf("%-*.*s  %-*.*s %-*.*s %10.10s %5.5s \n",
d283 2
a284 1
					    bp->ut_host, ct, ct + 11);
d298 1
a298 1
				printf("%-*.*s  %-*.*s %-*.*s %10.10s %5.5s \n",
d302 1
a302 1
				    ct, ct + 11);
d329 5
a333 5
				printf("%-*.*s  %-*.*s %-*.*s %10.10s %5.5s ",
				UT_NAMESIZE, UT_NAMESIZE, bp->ut_name,
				UT_LINESIZE, UT_LINESIZE, bp->ut_line,
				UT_HOSTSIZE, UT_HOSTSIZE, bp->ut_host,
				ct, ct + 11);
d342 2
a343 1
						printf("- %5.5s",
d347 2
a348 1
						printf("  (%5.5s)\n",
d351 1
a351 1
						printf(" (%ld+%5.5s)\n",
d353 1
d363 1
a363 1
	printf("\nwtmp begins %10.10s %5.5s \n", ct, ct + 11);
d592 1
a592 1
	printf("\ninterrupted %10.10s %5.5s \n", ct, ct + 11);
@


1.4
log
@add -d flag for reporting active sessions at a specified point in time.
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.3 1997/01/15 23:42:41 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.3 1997/01/15 23:42:41 millert Exp $";
d104 1
d169 2
d176 41
d264 1
a264 2
				 * unless flagged for and not in snapshot
				 * mode
d266 1
a266 1
				if (!snaptime && want(bp, NO)) {
d285 1
a285 1
				if (want(bp, NO) && !snaptime) {
d312 1
a312 1
			    ((!snaptime && want(bp, YES)) ||
d373 4
d394 2
a395 1
	}
d496 1
a496 1
 * 	[[CC]YY]MMDDhhmm[.SS]] to a time_t.
d514 1
a514 1
        /* [[CC]YY]MMDDhhmm[.SS] */
d562 1
a562 1
        "out of range or illegal time specification: [[CC]YY]MMDDhhmm[.SS]");
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.2 1996/06/26 05:34:51 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.2 1996/06/26 05:34:51 deraadt Exp $";
d67 1
d91 4
d101 1
d116 2
a117 1
	while ((ch = getopt(argc, argv, "0123456789f:h:t:")) != -1)
d145 3
d151 3
a153 1
	"usage: last [-#] [-f file] [-t tty] [-h hostname] [user ...]\n");
d185 1
a185 1

d210 14
a223 1
				if (want(bp, NO)) {
d242 1
a242 1
				if (want(bp, NO)) {
d264 10
a273 1
			if (bp->ut_name[0] && want(bp, YES)) {
d444 74
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: last.c,v 1.6 1994/12/24 16:49:02 cgd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: last.c,v 1.6 1994/12/24 16:49:02 cgd Exp $";
d110 1
a110 1
	while ((ch = getopt(argc, argv, "0123456789f:h:t:")) != EOF)
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: last.c,v 1.6 1994/12/24 16:49:02 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

