head	1.12;
access;
symbols
	OPENBSD_3_2:1.11.0.10
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.8
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.6
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	TCFS00:1.1.1.1
	PROVOS001:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2003.02.24.02.13.14;	author deraadt;	state dead;
branches;
next	1.11;

1.11
date	2000.06.20.07.58.57;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.20.07.33.51;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.20.07.09.45;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.19.23.06.24;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.19.22.42.28;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.19.20.35.47;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.19.20.06.19;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.19.14.24.06;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.19.03.23.01;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.18.22.26.56;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.18.22.07.24;	author provos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.06.18.22.07.24;	author provos;	state Exp;
branches;
next	;


desc
@@


1.12
log
@bye bye
@
text
@/*	$OpenBSD: tcfs_dbmaint.c,v 1.11 2000/06/20 07:58:57 fgsch Exp $	*/

/*
 *	Transparent Cryptographic File System (TCFS) for NetBSD 
 *	Author and mantainer: 	Luigi Catuogno [luicat@@tcfs.unisa.it]
 *	
 *	references:		http://tcfs.dia.unisa.it
 *				tcfs-bsd@@tcfs.unisa.it
 */

/*
 *	Base utility set v0.1
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <db.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include <miscfs/tcfs/tcfs.h>
#include "tcfslib.h"

#define PERM_SECURE	(S_IRUSR|S_IWUSR)

int 
tcfspwdbr_new(tcfspwdb **new)
{
	*new = (tcfspwdb *)calloc(1, sizeof(tcfspwdb));

	if (!*new)
		return (0);

	return (1);
}

int
tcfsgpwdbr_new(tcfsgpwdb **new)
{
	*new = (tcfsgpwdb *)calloc(1, sizeof(tcfsgpwdb));

	if (!*new)
		return (0);

	return (1);
}

int 
tcfspwdbr_edit(tcfspwdb **tmp, int flags, ...)
{
	va_list argv;
	char *d;

	if (!*tmp)
		if (!tcfspwdbr_new(tmp))
			return (0);

	va_start(argv, flags);

	if (flags & F_USR) {
		d = va_arg(argv, char *);
		strcpy((*tmp)->user, d);
	}

	if (flags & F_PWD) {
		d = va_arg(argv, char *);
		strcpy((*tmp)->upw, d);
	}

	va_end(argv);
	return (1);
}

int 
tcfsgpwdbr_edit(tcfsgpwdb **tmp, int flags, ...)
{
	va_list argv;
	char *d;

	if (!*tmp)
		if (!tcfsgpwdbr_new(tmp))
			return (0);

	va_start(argv, flags);

	if (flags & F_USR) {
		d = va_arg(argv, char *);
		strcpy((*tmp)->user, d);
	}

	if (flags & F_GKEY) {
		d = va_arg(argv, char *);
		strcpy((*tmp)->gkey, d);
	}

	if (flags & F_GID) {
		gid_t d;

		d = va_arg(argv, gid_t);
		(*tmp)->gid = d;
	}

	if (flags & F_MEMBERS) {
		int d;

		d = va_arg(argv, int);
		(*tmp)->n = d;
	}

	if (flags & F_THRESHOLD) {
		int d;

		d = va_arg(argv, int);
		(*tmp)->soglia = d;
	}

	va_end(argv);
	return (1);
}

int 
tcfspwdbr_read(tcfspwdb *t, int flags, ...)
{
	va_list argv;
	char *d;

	va_start(argv, flags);

	if (flags & F_USR) {
		d = va_arg(argv, char *);
		memset(d, 0, UserLen);
		strcpy(d, t->user);
	}

	if (flags & F_PWD) {
		d = va_arg(argv, char *);
		memset(d, 0, PassLen);
		strcpy(d, t->upw);
	}

	va_end(argv);
	return (0);
}

int 
tcfsgpwdbr_read(tcfsgpwdb *t, int flags, ...)
{
	va_list argv;
	char *d;

	va_start(argv, flags);

	if (flags & F_USR) {
		d = va_arg(argv, char *);
		strcpy(d, t->user);
	}

	if (flags & F_GKEY) {
		d = va_arg(argv, char *);
		strcpy(d, t->gkey);
	}

	if (flags & F_GID) {
		gid_t *d;

		d = va_arg(argv, gid_t *);
		memcpy(d, &t->gid, sizeof (gid_t));
	}
	/* Incomplete... */

	va_end(argv);
	return (0);
}

void 
tcfspwdbr_dispose(tcfspwdb *t)
{
	free((void *)t);
}

void 
tcfsgpwdbr_dispose(tcfsgpwdb *t)
{
	free((void *)t);
}

tcfspwdb *
tcfs_getpwnam(char *user, tcfspwdb **dest)
{
	DB *pdb;
	DBT srchkey, r;

	if (!*dest)
		if (!tcfspwdbr_new(dest))
			return (NULL);

	pdb = dbopen(TCFSPWDB, O_RDONLY, 0, DB_HASH, NULL);
	if (!pdb)
		return (NULL);

	srchkey.data = user;
	srchkey.size = (int)strlen(user);

	if (pdb->get(pdb, &srchkey, &r, 0)) {
		pdb->close(pdb);
		return (0);
	}

	if (r.size != sizeof(tcfspwdb)) {
		fprintf(stderr, "db: incorrect record size: %d != %d\n",
			r.size, sizeof(tcfspwdb));
		pdb->close(pdb);
		return (0);
	}

	memcpy(*dest, r.data, sizeof(tcfspwdb));

	pdb->close(pdb);

	return ((tcfspwdb *)*dest);
}

tcfsgpwdb *
tcfs_ggetpwnam(char *user, gid_t gid, tcfsgpwdb **dest)
{
	DB *pdb;
	DBT srchkey, r;
	char *key;
	int res;

	if (!*dest)
		if (!tcfsgpwdbr_new(dest))
			return (NULL);

	pdb = dbopen(TCFSGPWDB, O_RDONLY, 0, DB_HASH, NULL);
	if (!pdb)
		return (NULL);

	key = (char *)malloc(strlen(user) + 6);
	if (!key)
		return (NULL);

	sprintf(key, "%s\33%d", user, (int)gid);
	srchkey.data = key;
	srchkey.size = (int)strlen(key);

	if ((res = pdb->get(pdb, &srchkey, &r, 0))) {
		if (res == -1)
			perror("dbget");
		pdb->close(pdb);
		return (NULL);
	}

	memcpy(*dest, r.data, sizeof(tcfsgpwdb));

	pdb->close(pdb);

	return (*dest);
}

int 
tcfs_putpwnam(char *user, tcfspwdb *src, int flags)
{
	DB *pdb;
	static DBT srchkey, d;
	int open_flag = 0, res;

	open_flag = O_RDWR|O_EXCL;
	if (access(TCFSPWDB, F_OK) < 0)
		open_flag |= O_CREAT;

	pdb = dbopen(TCFSPWDB, open_flag, PERM_SECURE, DB_HASH, NULL);
	if (!pdb)
		return (0);

	srchkey.data = user;
	srchkey.size = (int)strlen(user);

	if (flags != U_DEL) {
		d.data = (char *)src;
		d.size = (int)sizeof(tcfspwdb);

		if (pdb->put(pdb, &srchkey, &d, 0) == -1) {
			fprintf(stderr, "db: put failed\n");
			pdb->close(pdb);
			return (0);
		}
	} else if ((res = pdb->del(pdb, &srchkey, 0))) {
		fprintf(stderr, "db: del failed: %s\n", 
			res == -1 ? "error" : "not found");
		pdb->close(pdb);
		return (0);
	}

	pdb->close(pdb);
	return (1);
}

int 
tcfs_gputpwnam(char *user, tcfsgpwdb *src, int flags)
{
	DB *pdb;
	static DBT srchkey, d;
	int open_flag = 0;
	char *key;

	open_flag = O_RDWR|O_EXCL;
	if (access(TCFSGPWDB, F_OK) < 0)
		open_flag |= O_CREAT;

	pdb = dbopen(TCFSGPWDB, open_flag, PERM_SECURE, DB_HASH, NULL);
	if (!pdb) {
		perror("dbopen");
		return (0);
	}

	key = (char *)malloc(strlen(src->user) + 6);
	sprintf(key, "%s\33%d", src->user, (int)src->gid);

	srchkey.data = key;
	srchkey.size = strlen(key);

	if (flags != U_DEL) {
		d.data = (char *)src;
		d.size = sizeof(tcfsgpwdb);

		if (pdb->put(pdb, &srchkey, &d, 0) == -1) {
			fprintf(stderr, "db: put failed\n");
			pdb->close(pdb);
			return (0);
		}
	} else if (pdb->del(pdb, &srchkey, 0)) {
		fprintf(stderr, "db: del failed\n");
		pdb->close(pdb);
		return (0);
	}

	pdb->close(pdb);
	return (1);
}

int
tcfs_rmgroup(gid_t gid)
{
	DB *gdb;
	DBT dbkey;

	gdb = dbopen(TCFSGPWDB, O_RDWR|O_EXCL, PERM_SECURE, DB_HASH, NULL);
	if (!gdb)
		return (0);

	if (gdb->seq(gdb, &dbkey, NULL, R_FIRST))
		dbkey.data = NULL;

	while (dbkey.data) {
		char *tmp;

		tmp = (char *)calloc(1024, sizeof(char));

		sprintf(tmp, "\33%d", gid);
		if (strstr(dbkey.data, tmp)) {
			if (gdb->del(gdb, &dbkey, 0)) {
				gdb->close(gdb);
				free(tmp);
				return (0);
			}
		}
		free(tmp);

		if (gdb->seq(gdb, &dbkey, NULL, R_NEXT)) {
			gdb->close(gdb);
			return (0);
		}
	}

	gdb->close(gdb);
	return (1);
}


int
tcfs_group_chgpwd(char *user, gid_t gid, char *old, char *new)
{
	tcfsgpwdb *group_info = NULL;
	unsigned char *key;

	key = (unsigned char *)calloc(UUGKEYSIZE + 1, sizeof (char));
	if (!key)
		return (0);

	if (!tcfs_decrypt_key(old, group_info->gkey, key, GKEYSIZE))
		return (0);

	if (!tcfs_encrypt_key(new, key, GKEYSIZE, group_info->gkey,
			       UUGKEYSIZE + 1))
		return (0);

	if (!tcfs_gputpwnam(user, group_info, U_CHG))
		return (0);

	free(group_info);
	free(key);

	return (1);
}

int 
tcfs_chgpwd(char *user, char *old, char *new)
{
	tcfspwdb *user_info = NULL;
	unsigned char *key;

	key = (unsigned char *)calloc(UUKEYSIZE + 1, sizeof(char));

	if (!tcfs_getpwnam(user, &user_info))
		return (0);

	if (!tcfs_decrypt_key(old,  user_info->upw, key, KEYSIZE))
		return (0);

	if (!tcfs_encrypt_key(new, key, KEYSIZE, user_info->upw, UUKEYSIZE + 1))
		return (0);

	if (!tcfs_putpwnam(user, user_info, U_CHG))
		return (0);

	free(user_info);
	free(key);

	return (1);
}

int
tcfs_chgpassword(char *user, char *old, char *new)
{
	int error1 = 0;
	DB *gpdb;
	DBT found, key;
	unsigned char *ckey;

	ckey = (unsigned char *)calloc(UUGKEYSIZE + 1, sizeof(char));
	if (!ckey)
		return (0);

	gpdb = dbopen(TCFSGPWDB, O_RDWR|O_EXCL, PERM_SECURE, DB_HASH, NULL);
	if (!gpdb)
		return (0);

	error1 = tcfs_chgpwd(user, old, new);
	if (!error1)
		return (0);

	/* Reencrypt group shares */
	if (gpdb->seq(gpdb, &key, NULL, R_FIRST)) 
		key.data = NULL;
	
	while (key.data) {
		if (strncmp(user, key.data, strlen(user))) {
			if (gpdb->seq(gpdb, &key, NULL, R_NEXT))
			    key.data = NULL;
			continue;
		}

		gpdb->get(gpdb, &key, &found, 0);

		if (!tcfs_decrypt_key(old, ((tcfsgpwdb *)found.data)->gkey,
		    ckey, GKEYSIZE))
			return (0);

		if (!tcfs_encrypt_key(new, ckey, GKEYSIZE,
		    ((tcfsgpwdb *)found.data)->gkey, UUGKEYSIZE + 1))
			return (0);

		if (gpdb->put(gpdb, &key, &found, 0)) {
			free(ckey);
			gpdb->close(gpdb);
			return (0);
		}

		free(ckey);

		if (gpdb->seq(gpdb, &key, NULL, R_NEXT))
			key.data = NULL;
	}

	return (1);
}
@


1.11
log
@add openbsd tags. rearrange headers as per style(9) and indent.
replace some strcpy by strlcpy.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfs_dbmaint.c,v 1.10 2000/06/20 07:33:51 fgsch Exp $	*/
@


1.10
log
@replace some calloc's with malloc's since there is no point in call
memset for a sprintf buffer. fix malloc's len.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfs_dbmaint.c,v 1.9 2000/06/20 07:09:45 fgsch Exp $	*/
d15 5
a21 2
#include <unistd.h>
#include <stdarg.h>
a22 1
#include <db.h>
d24 1
a24 3
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
@


1.9
log
@add missing declarations and includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfs_dbmaint.c,v 1.8 2000/06/19 23:06:24 aaron Exp $	*/
d244 1
a244 2
	key = (char *)calloc(strlen(user) + 4 /* gid length */ + 1 /* null */,
	    sizeof(char));
d248 1
a248 1
	sprintf(key, "%s\33%d\0", user, (int)gid);
d322 2
a323 2
	key = (char *)calloc(strlen(src->user) + 4 + 1, sizeof(char));
	sprintf(key, "%s\33%d\0", src->user, src->gid);
d365 1
a365 1
		sprintf(tmp, "\33%d\0", gid);
@


1.8
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfs_dbmaint.c,v 1.7 2000/06/19 22:42:28 aaron Exp $	*/
a27 1
#include "tcfspwdb.h"
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfs_dbmaint.c,v 1.6 2000/06/19 20:35:47 fgsch Exp $	*/
d55 1
a55 1
tcfspwdbr_edit (tcfspwdb **tmp, int flags, ...)
d104 1
d111 1
d118 1
d245 2
a246 1
	key = (char*)calloc(strlen(user)+4/*gid lenght*/+1/*null*/,sizeof(char));
d365 1
a365 1
		tmp = (char*)calloc(1024, sizeof(char));
d420 1
a420 1
	key = (unsigned char*)calloc(UUKEYSIZE + 1, sizeof(char));
d443 1
a443 1
	int error1=0;
d448 1
a448 1
	ckey = (unsigned char*)calloc(UUGKEYSIZE + 1, sizeof(char));
d473 2
a474 1
		if (!tcfs_decrypt_key(old, ((tcfsgpwdb *)found.data)->gkey, ckey, GKEYSIZE))
d477 2
a478 1
		if (!tcfs_encrypt_key(new, ckey, GKEYSIZE, ((tcfsgpwdb *)found.data)->gkey, UUGKEYSIZE + 1))
@


1.6
log
@add openbsd tag
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 1
a33 1
tcfspwdbr_new (tcfspwdb **new)
d44 1
a44 1
tcfsgpwdbr_new (tcfsgpwdb **new)
d55 1
a55 1
tcfspwdbr_edit (tcfspwdb **tmp, int flags,...)
d61 2
a62 2
		if (!tcfspwdbr_new (tmp))
			return 0;
d64 1
a64 1
	va_start (argv, flags);
d67 2
a68 2
		d = va_arg (argv, char *);
		strcpy ((*tmp)->user, d);
d72 2
a73 2
		d = va_arg (argv, char *);
		strcpy ((*tmp)->upw, d);
d76 2
a77 2
	va_end (argv);
	return 1;
d81 1
a81 1
tcfsgpwdbr_edit (tcfsgpwdb **tmp, int flags,...)
d87 2
a88 2
		if (!tcfsgpwdbr_new (tmp))
			return 0;
d90 1
a90 1
	va_start (argv, flags);
d93 2
a94 2
		d = va_arg (argv, char *);
		strcpy ((*tmp)->user, d);
d98 2
a99 2
		d = va_arg (argv, char *);
		strcpy ((*tmp)->gkey, d);
d104 1
a104 1
		d = va_arg (argv, gid_t);
d110 1
a110 1
		d = va_arg (argv, int);
d116 1
a116 1
		d = va_arg (argv, int);
d120 1
a120 1
	va_end (argv);
d125 1
a125 1
tcfspwdbr_read (tcfspwdb *t, int flags,...)
d130 1
a130 1
	va_start (argv, flags);
d133 3
a135 3
		d = va_arg (argv, char *);
		memset (d, 0, UserLen);
		strcpy (d, t->user);
d139 3
a141 3
		d = va_arg (argv, char *);
		memset (d, 0, PassLen);
		strcpy (d, t->upw);
d144 2
a145 2
	va_end (argv);
	return 0;
d149 1
a149 1
tcfsgpwdbr_read (tcfsgpwdb *t, int flags,...)
d154 1
a154 1
	va_start (argv, flags);
d157 2
a158 2
		d = va_arg (argv, char *);
		strcpy (d, t->user);
d162 2
a163 2
		d = va_arg (argv, char *);
		strcpy (d, t->gkey);
d169 2
a170 2
		d = va_arg (argv, gid_t *);
		memcpy (d, &t->gid, sizeof (gid_t));
d174 2
a175 2
	va_end (argv);
	return 0;
d179 1
a179 1
tcfspwdbr_dispose (tcfspwdb *t)
d181 1
a181 1
	free ((void *)t);
d185 1
a185 1
tcfsgpwdbr_dispose (tcfsgpwdb *t)
d187 1
a187 1
	free ((void *)t);
d191 1
a191 1
tcfs_getpwnam (char *user, tcfspwdb **dest)
d197 2
a198 2
		if (!tcfspwdbr_new (dest))
			return NULL;
d200 1
a200 1
	pdb = dbopen (TCFSPWDB, O_RDONLY, 0, DB_HASH, NULL);
d202 1
a202 1
		return NULL;
d205 1
a205 1
	srchkey.size = (int) strlen (user);
d209 1
a209 1
		return 0;
d216 1
a216 1
		return 0;
d219 1
a219 1
	memcpy (*dest, r.data, sizeof (tcfspwdb));
d221 1
a221 1
	pdb->close (pdb);
d223 1
a223 1
	return (tcfspwdb *)*dest;
d227 1
a227 1
tcfs_ggetpwnam (char *user, gid_t gid, tcfsgpwdb **dest)
d235 2
a236 2
		if (!tcfsgpwdbr_new (dest))
			return NULL;
d238 1
a238 1
	pdb = dbopen (TCFSGPWDB, O_RDONLY, 0, DB_HASH, NULL);
d240 1
a240 1
		return NULL;
d244 1
a244 1
		return NULL;
d246 1
a246 1
	sprintf (key, "%s\33%d\0", user, (int)gid);
d248 1
a248 1
	srchkey.size = (int)strlen (key);
d253 1
a253 1
		pdb->close (pdb);
d257 1
a257 1
	memcpy (*dest, r.data, sizeof (tcfsgpwdb));
d259 1
a259 1
	pdb->close (pdb);
d265 1
a265 1
tcfs_putpwnam (char *user, tcfspwdb *src, int flags)
d272 1
a272 1
	if (access (TCFSPWDB, F_OK) < 0)
d275 1
a275 1
	pdb = dbopen (TCFSPWDB, open_flag, PERM_SECURE, DB_HASH, NULL);
d277 1
a277 1
		return 0;
d280 1
a280 1
	srchkey.size = (int)strlen (user);
d288 2
a289 2
			pdb->close (pdb);
			return 0;
d291 1
a291 1
	} else if ((res = pdb->del (pdb, &srchkey, 0))) {
d294 2
a295 2
		pdb->close (pdb);
		return 0;
d298 2
a299 2
	pdb->close (pdb);
	return 1;
d303 1
a303 1
tcfs_gputpwnam (char *user, tcfsgpwdb *src, int flags)
d311 1
a311 1
	if (access (TCFSGPWDB, F_OK) < 0)
d314 1
a314 1
	pdb = dbopen (TCFSGPWDB, open_flag, PERM_SECURE, DB_HASH, NULL);
d317 1
a317 1
		return 0;
d320 2
a321 2
	key = (char *) calloc (strlen(src->user) + 4 + 1, sizeof(char));
	sprintf (key, "%s\33%d\0", src->user, src->gid);
d324 1
a324 1
	srchkey.size = strlen (key);
d330 1
a330 1
		if (pdb->put (pdb, &srchkey, &d, 0) == -1) {
d332 2
a333 2
			pdb->close (pdb);
			return 0;
d335 1
a335 1
	} else if (pdb->del (pdb, &srchkey, 0)) {
d337 2
a338 2
		pdb->close (pdb);
		return 0;
d341 2
a342 2
	pdb->close (pdb);
	return 1;
d346 1
a346 1
tcfs_rmgroup (gid_t gid)
d353 1
a353 1
		return 0;
d364 1
a364 1
		if (strstr (dbkey.data, tmp)) {
d366 3
a368 4
				gdb->close (gdb);

				free (tmp);
				return 0;
d371 1
a371 1
		free (tmp);
d379 1
a379 1
	gdb->close (gdb);
d385 1
a385 1
tcfs_group_chgpwd (char *user, gid_t gid, char *old, char *new)
d392 1
a392 1
		return 0;
d394 2
a395 2
	if (!tcfs_decrypt_key (old, group_info->gkey, key, GKEYSIZE))
		return 0;
d397 1
a397 1
	if (!tcfs_encrypt_key (new, key, GKEYSIZE, group_info->gkey,
d399 1
a399 1
		return 0;
d401 2
a402 2
	if (!tcfs_gputpwnam (user, group_info, U_CHG))
		return 0;
d404 2
a405 2
	free (group_info);
	free (key);
d407 1
a407 1
	return 1;
d411 1
a411 1
tcfs_chgpwd (char *user, char *old, char *new)
d413 1
a413 1
	tcfspwdb *user_info=NULL;
d418 2
a419 2
	if (!tcfs_getpwnam (user, &user_info))
		return 0;
d421 2
a422 2
	if (!tcfs_decrypt_key (old,  user_info->upw, key, KEYSIZE))
		return 0;
d424 2
a425 2
	if (!tcfs_encrypt_key (new, key, KEYSIZE, user_info->upw, UUKEYSIZE + 1))
		return 0;
d427 2
a428 2
	if (!tcfs_putpwnam (user, user_info, U_CHG))
		return 0;
d430 2
a431 2
	free (user_info);
	free (key);
d433 1
a433 1
	return 1;
d437 1
a437 1
tcfs_chgpassword (char *user, char *old, char *new)
d446 1
a446 1
		return 0;
d448 1
a448 1
	gpdb = dbopen (TCFSGPWDB, O_RDWR|O_EXCL, PERM_SECURE, DB_HASH, NULL);
d450 1
a450 1
		return 0;
d452 1
a452 1
	error1 = tcfs_chgpwd (user, old, new);
d454 1
a454 1
		return 0;
d461 1
a461 1
		if (strncmp (user, key.data, strlen(user))) {
d469 2
a470 2
		if (!tcfs_decrypt_key (old, ((tcfsgpwdb *)found.data)->gkey, ckey, GKEYSIZE))
			return 0;
d472 2
a473 2
		if (!tcfs_encrypt_key (new, ckey, GKEYSIZE, ((tcfsgpwdb *)found.data)->gkey, UUGKEYSIZE + 1))
			return 0;
d475 3
a477 4
		if (gpdb->put (gpdb, &key, &found, 0)) {
			free (ckey);

			gpdb->close (gpdb);
d481 1
a481 1
		free (ckey);
d484 1
a484 1
		    key.data = NULL;
d487 1
a487 1
	return 1;
@


1.5
log
@add missing headers, declare missing functions remove unused vars, KNF;
more to come.
@
text
@d1 2
@


1.4
log
@cleanup key encryption
@
text
@a125 1
	int r;
a149 1
	int r; 
d229 1
a229 1
	char *key, *buf;
d306 1
a306 2
	char *key, *buf;
	char *tmp;
d386 1
a386 1
	tcfsgpwdb *group_info;
d438 1
a438 1
	int error1=0, error2=0;
@


1.3
log
@fix a couple of bugs.  dont clobber tcfspwdb when adding group entries.
do the fgets correctly until aaron gets to them.
@
text
@d392 1
a392 1
	key=(unsigned char *)calloc(UUKEYSIZE, sizeof (char));
d396 1
a396 1
	if (!tcfs_decrypt_key (user, old, (unsigned char*)group_info->gkey, key, GROUPKEY))
d399 2
a400 1
	if (!tcfs_encrypt_key (user, new, key, (unsigned char *)group_info->gkey, GROUPKEY))
d418 1
a418 1
	key = (unsigned char*)calloc(UUKEYSIZE, sizeof(char));
d423 1
a423 1
	if (!tcfs_decrypt_key (user, old, (unsigned char *)user_info->upw, key, USERKEY))
d426 1
a426 1
	if (!tcfs_encrypt_key (user, new, key, (unsigned char *)user_info->upw, USERKEY))
d446 1
a446 1
	ckey = (unsigned char*)calloc(UUKEYSIZE, sizeof(char));
d471 1
a471 1
		if (!tcfs_decrypt_key (user, old, (unsigned char *)((tcfsgpwdb *)found.data)->gkey, ckey, USERKEY))
d474 1
a474 1
		if (!tcfs_encrypt_key (user, new, ckey, (unsigned char *)((tcfsgpwdb *)found.data)->gkey, USERKEY))
@


1.2
log
@more verbose errors, remove redundant free()s
@
text
@d232 1
d247 2
a248 2
	srchkey.data=key;
	srchkey.size=(int)strlen (key);
d250 3
a252 1
	if (pdb->get(pdb, &srchkey, &r, 0)) {
d312 1
a312 1
	if (access (TCFSPWDB, F_OK) < 0)
d315 3
a317 2
	pdb = dbopen (TCFSPWDB, open_flag, PERM_SECURE, DB_HASH, NULL);
	if (!pdb)
d319 1
@


1.1
log
@Initial revision
@
text
@a221 1
	free (r.data);
a256 1
	free (key);
d266 1
a266 1
	int open_flag=0, owf=0;
d277 1
a277 1
	srchkey.size=(int)strlen (user);
d288 3
a290 2
	} else if (pdb->del (pdb, &srchkey, 0)) {
		fprintf(stderr, "db: del failed\n");
d304 1
a304 1
	int open_flag = 0, owf = 0;
@


1.1.1.1
log
@Initial import of very much rewritten TCFS userland.  This code is still
nasty.
@
text
@@
