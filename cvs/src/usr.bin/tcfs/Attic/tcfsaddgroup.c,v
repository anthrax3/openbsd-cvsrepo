head	1.14;
access;
symbols
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.8
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.12.0.6
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.4
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	TCFS00:1.1.1.1
	PROVOS001:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2003.02.24.02.13.14;	author deraadt;	state dead;
branches;
next	1.13;

1.13
date	2002.06.09.02.37.03;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.20.18.15.57;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.20.08.59.52;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.20.06.45.16;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.19.23.06.25;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.19.22.42.28;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.19.21.23.44;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.19.20.50.58;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.19.20.35.47;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.19.20.25.30;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.19.20.06.19;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.19.03.23.04;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.18.22.07.24;	author provos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.06.18.22.07.24;	author provos;	state Exp;
branches;
next	;


desc
@@


1.14
log
@bye bye
@
text
@/*	$OpenBSD: tcfsaddgroup.c,v 1.13 2002/06/09 02:37:03 itojun Exp $	*/

/*
 *	Transparent Cryptographic File System (TCFS) for NetBSD 
 *	Author and mantainer: 	Luigi Catuogno [luicat@@tcfs.unisa.it]
 *	
 *	references:		http://tcfs.dia.unisa.it
 *				tcfs-bsd@@tcfs.unisa.it
 */

/*
 *	Base utility set v0.1
 */

#include <sys/types.h>
#include <grp.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <miscfs/tcfs/tcfs.h>
#include "tcfslib.h"
#include "tcfserrors.h"

char *addgroup_usage="Usage: %s [OPTION]
Add a TCFS group to the TCFS group database.

  -g <group>          Group id [or name] of the TCFS group
  -m <members>        Number of members of the group
  -t <threshold>      Threshold of the group
  -v                  Makes the output a little more verbose
  -h                  Shows this help\n";

int threshold;
unsigned char coeff[KEYSIZE][256];
unsigned char *S = NULL;          /* Pointer to a 64-bit TCFS group key */

union bobbit
{
	unsigned char byte;
	struct
	{ 
		unsigned char b1:1;
		unsigned char b2:1;
		unsigned char b3:1;
		unsigned char b4:1;
		unsigned char b5:1;
		unsigned char b6:1;
		unsigned char b7:1;
		unsigned char b8:1;
	} bf;
};

int
tcfsgetuid(char *login) 
{    
	struct passwd *entry;

	setpwent();

	while ((entry = getpwent()) != NULL) {
		if (strcmp(login, entry->pw_name) == 0)
			return (entry->pw_uid);
	}

	endpwent();
	free(entry);

	return (-1);
}    

void
gencoeff(void)
{    
	int i, j;

	for (i = 0; i < KEYSIZE; i++) {
		for (j = 1; j < threshold; j++) {
			coeff[j][i] = arc4random();
		}
	}
}

unsigned char *
gengrpkey(char *login)
{
	int x1, i, j, k = 0;
	unsigned int x;

	unsigned char *res = NULL;
	unsigned int tmp;
	union bobbit obits;

	res = (unsigned char *)calloc(KEYSIZE + KEYSIZE / 8, sizeof(char));
	if (!res)
		tcfs_error(ER_MEM, NULL);

	x1 = tcfsgetuid(login);
	x = (x1 % 257);

#ifdef DEBUG_TCFS
	printf("La chiave utente di %u e':\n", x);
#endif

	for (i = 0; i < KEYSIZE; i++) {
		tmp = 0;
		for (j = 1; j < threshold; j++) {
			tmp += (eleva(x1, j, 257) * coeff[j][i]) % 257;
#ifdef DEBUG_TCFS
			printf("x1= %u\tj=%d\tcoeff[%d][%d]=%u\ttmp=%u\tchiave: ", x1, j, j, i, coeff[j][i], tmp);
#endif
		}

		tmp += (unsigned int)S[i];
		tmp %= 257;

		memcpy(res+k++, &tmp, 1);
#ifdef DEBUG_TCFS
		printf("%u\n", *(res+k-1));
#endif
		switch (i % 8) {
		case 0:
			obits.bf.b1 = tmp >> 8;
			break;
		case 1:
			obits.bf.b2 = tmp >> 8;
			break;
		case 2:
			obits.bf.b3 = tmp >> 8;
			break;
		case 3:
			obits.bf.b4 = tmp >> 8;
			break;
		case 4:
			obits.bf.b5 = tmp >> 8;
			break;
		case 5:
			obits.bf.b6 = tmp >> 8;
			break;
		case 6:
			obits.bf.b7 = tmp >> 8;
			break;
		case 7:
			obits.bf.b8 = tmp >> 8;
			break;
		}

		if ((i % 8) == 7) {
			res[k] = obits.byte;
			k++;

#ifdef DEBUG_TCFS
			printf("%u\n", res[k-1]);
#endif

			obits.byte = 0;
		}
	}

	/*
	res[KEYSIZE]=obits.byte;
	*/
	return (res);
}

int 
addgroup_main(int argn, char *argv[])
{
	int val;
	gid_t gid = 0;
	int have_gid = FALSE, have_members = FALSE, have_threshold = FALSE;
	int be_verbose = FALSE;
	int temp_members, members = 0;
	tcfsgpwdb **group_info;

	/*
	 * Going to check the arguments
	 */
	while ((val = getopt(argn, argv, "vg:m:t:h")) != -1)
		switch (val) {
		case 'm':
			members = atoi(optarg);
			have_members = TRUE;
			break;
		case 'g':
			gid = (gid_t)atoi(optarg);
			if (!gid && optarg[0] != '0') { /* group name given */
				struct group *group_id;

				group_id = getgrnam(optarg);
				if (!group_id)
					tcfs_error(ER_CUSTOM,
						"Nonexistent group.");

				gid = group_id->gr_gid;
			}

			have_gid = TRUE;
			break;
		case 't':
			threshold = atoi(optarg);
			have_threshold = TRUE;
			break;
		case 'h':
			printf(addgroup_usage, argv[0]);
			exit(OK);
		case 'v':
			be_verbose = TRUE;
			break;
		default:
			fprintf(stderr,
			    "Try %s --help for more information.\n", argv[0]);
			exit(ER_UNKOPT);
		}

	if (argn-optind)
		tcfs_error(ER_UNKOPT, NULL);

	if (!have_gid) {
		char *buff = NULL;
		int len;

		buff = (char *)malloc(2048);
		if (!buff)
			tcfs_error(ER_MEM, NULL);

		printf("Group ID (or name) of TCFS group to add to the database: ");
		fgets(buff, 2048, stdin);
		len = strlen(buff) - 1;
		buff[len] = buff[len] == '\n' ? 0 : buff[len];
		gid = atoi(buff);

		if (!gid && buff[0] != '0') { /* group name given */ 
			struct group *group_id;

			group_id = getgrnam(buff);
			if (!group_id)
				tcfs_error(ER_CUSTOM, "Nonexistent group.");

			gid = group_id->gr_gid;
		}

		if (gid <= 0)
			tcfs_error(ER_CUSTOM, "A positive ID please!");

		free(buff);
	}

	if (!have_members) {
		char *buff = NULL;
		int len;

		buff = (char *)calloc(2048, sizeof(char));
		if (!buff)
			tcfs_error(ER_MEM, NULL);

		printf("Number of members for the TCFS group ID #%d: ", gid);
		fgets(buff, 2048, stdin);
		len = strlen(buff) - 1;
		buff[len] = buff[len] == '\n' ? 0 : buff[len];
		members = atoi(buff);

		free(buff);
	}

	if (!have_threshold) {
		char *buff = NULL;
		int len;

		buff = (char *)calloc(2048, sizeof(char));
		if (!buff)
			tcfs_error(ER_MEM, NULL);

		printf("Threshold for the TCFS group ID #%d: ", gid);
		fgets(buff, 2048, stdin);
		len = strlen(buff) - 1;
		buff[len] = buff[len] == '\n' ? 0 : buff[len];
		threshold = atoi(buff);

		free(buff);
	}

	if (members < 2)
		tcfs_error(ER_CUSTOM, "At least two members!");

	if (threshold > members || threshold <= 0)
		tcfs_error(ER_CUSTOM, "The threshold must be no greater than the number of members and greater than zero!");

	S = gentcfskey();
#ifdef DEBUG_TCFS
	{
		int i;

		printf("La chiave segreta e':\n");

		for (i = 0; i < KEYSIZE; i++)
			printf("%u:", S[i]);

		printf("\n");
	}
#endif

	gencoeff();

	temp_members = members;

	group_info = (tcfsgpwdb **)calloc(members, sizeof(tcfsgpwdb *));

	/*
	 * Creating user entry
	 */
	while (members) {
		char *user = NULL, *passwd = NULL;
		unsigned char *newkey = NULL, *cryptedkey = NULL;
		tcfsgpwdb *tmp = NULL;
		int tmpmemb = temp_members, cont = 0;

		group_info[members - 1] = (tcfsgpwdb *)calloc(1,
		    sizeof(tcfsgpwdb));

		group_info[members - 1]->gid = gid;
		group_info[members - 1]->n = members;
		group_info[members - 1]->soglia = threshold;

		if (!unix_auth(&user, &passwd, FALSE)) {
			fprintf(stderr, "Invalid password or the user does not exist.\n");
			continue;
		}

		if (tcfs_ggetpwnam(user, gid, &tmp))
			tcfs_error(ER_CUSTOM, "Group already exists.");

		while (tmpmemb > members) {
			if (!strcmp(user, group_info[tmpmemb-1]->user)) {
				fprintf(stderr, "User already present into the group.\n");
				cont = 1;
				break;
			}
			tmpmemb--;
		}

		if (cont)
			continue;

		strcpy(group_info[members - 1]->user, user);

		newkey = (unsigned char *)calloc(GKEYSIZE + 1, sizeof(char));
		if (!newkey)
			tcfs_error(ER_MEM, NULL);

		cryptedkey = (unsigned char *)calloc(UUGKEYSIZE, sizeof(char));
		if (!cryptedkey)
			tcfs_error(ER_MEM, NULL);

		memcpy(newkey, gengrpkey(user), GKEYSIZE);
		newkey[GKEYSIZE] = '\0';

		/*
		 * Encrypt the just generated key with the user password
		 */
		if (!tcfs_encrypt_key(passwd, newkey, GKEYSIZE, cryptedkey,
		    UUGKEYSIZE))
			tcfs_error(ER_MEM, NULL);

		free(newkey);

		strlcpy(group_info[members - 1]->gkey, cryptedkey,
		    sizeof(group_info[members - 1]->gkey));
		free(cryptedkey);

		members--;
	}

	members = temp_members;

	while (members) {
		if (be_verbose)
			printf("Creating a new entry for group %d and user %s in the TCFS database...\n", 
				group_info[members - 1]->gid,
				group_info[members - 1]->user);

		if (!tcfs_gputpwnam(group_info[members - 1]->user,
				     group_info[members - 1], U_NEW)) {
				/* TODO: Remove the group entries saved before */
			tcfs_error(ER_CUSTOM, "Error: cannot add a user to the group.");
		}

		if (be_verbose)
			printf("TCFS group entry for user %s created.\n", group_info[members - 1]->user);

		members--;
	}

	tcfs_error(ER_CUSTOM, "\nAll group keys generated.");

	return (0);
}


int
eleva(int x, int y, int z)
{
	int mask = 0x80000000;
	int res = 1, i;

	for (i = 0; i < 32; i++) {
		res = (res * res) % z;
		if (y & mask)
			res = (x * res) % z;
		mask = mask >> 1;
	}

	return (res);
}
@


1.13
log
@strlcpy fix, PR 2727
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfsaddgroup.c,v 1.12 2000/06/20 18:15:57 aaron Exp $	*/
@


1.12
log
@getopt(3) returns -1, not EOF
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfsaddgroup.c,v 1.11 2000/06/20 08:59:52 fgsch Exp $	*/
d370 1
a370 1
		    GKEYSIZE + 1);
@


1.11
log
@fix warnings during compilation. replace a few more calloc's with
malloc's; no need to clean the buffer for fgets.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfsaddgroup.c,v 1.10 2000/06/20 06:45:16 fgsch Exp $	*/
d181 1
a181 1
	while ((val = getopt(argn, argv, "vg:m:t:h")) != EOF)
@


1.10
log
@kill show_usage, it's only a printf. i'll replace this by err and friends
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfsaddgroup.c,v 1.9 2000/06/19 23:06:25 aaron Exp $	*/
d172 1
a172 1
	gid_t gid;
d175 1
a175 1
	int temp_members, members;
d225 1
a225 1
		buff = (char *)calloc(2048, sizeof(char));
@


1.9
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfsaddgroup.c,v 1.8 2000/06/19 22:42:28 aaron Exp $	*/
d207 1
a207 1
			show_usage(addgroup_usage, argv[0]);
@


1.8
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfsaddgroup.c,v 1.7 2000/06/19 21:23:44 fgsch Exp $	*/
d38 1
a38 1
unsigned char *S=NULL;          /* Pointer to a 64-bit TCFS group key */
d89 1
a89 1
	int x1, i, j, k=0;
d96 1
a96 1
	res = (unsigned char*)calloc(KEYSIZE + KEYSIZE/8, sizeof(char));
d125 1
a125 1
			obits.bf.b1=tmp>>8;
d128 1
a128 1
			obits.bf.b2=tmp>>8;
d131 1
a131 1
			obits.bf.b3=tmp>>8;
d134 1
a134 1
			obits.bf.b4=tmp>>8;
d137 1
a137 1
			obits.bf.b5=tmp>>8;
d140 1
a140 1
			obits.bf.b6=tmp>>8;
d143 1
a143 1
			obits.bf.b7=tmp>>8;
d146 1
a146 1
			obits.bf.b8=tmp>>8;
d194 2
a195 1
					tcfs_error(ER_CUSTOM, "Nonexistent group.");
d213 2
a214 1
			fprintf(stderr, "Try %s --help for more information.\n", argv[0]);
d225 1
a225 1
		buff = (char*)calloc(2048, sizeof(char));
d229 1
a229 1
		printf("Group id [or name] of the TCFS group to add to the database: ");
d255 1
a255 1
		buff = (char*)calloc(2048, sizeof(char));
d272 1
a272 1
		buff = (char*)calloc(2048, sizeof(char));
d318 1
a318 1
		int tmpmemb = temp_members, cont=0;
d320 2
a321 1
		group_info[members-1] = (tcfsgpwdb *)calloc(1, sizeof(tcfsgpwdb));
d323 3
a325 3
		group_info[members-1]->gid = gid;
		group_info[members-1]->n = members;
		group_info[members-1]->soglia = threshold;
d347 1
a347 1
		strcpy(group_info[members-1]->user, user);
d349 1
a349 1
		newkey = (unsigned char*)calloc(GKEYSIZE + 1, sizeof(char));
d353 1
a353 1
		cryptedkey = (unsigned char*)calloc(UUGKEYSIZE, sizeof(char));
d381 2
a382 2
				group_info[members-1]->gid,
				group_info[members-1]->user);
d384 2
a385 2
		if (!tcfs_gputpwnam(group_info[members-1]->user,
				     group_info[members-1], U_NEW)) {
d391 1
a391 1
			printf("TCFS group entry for user %s created.\n", group_info[members-1]->user);
@


1.7
log
@pass the correct size of the buffer
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfsaddgroup.c,v 1.6 2000/06/19 20:50:58 fgsch Exp $	*/
d57 1
a57 1
tcfsgetuid (char *login) 
d64 2
a65 2
		if (strcmp (login, entry->pw_name) == 0)
			return entry->pw_uid;
d71 1
a71 1
	return -1;
d75 1
a75 1
gencoeff (void)
d79 2
a80 2
	for (i = 0; i < KEYSIZE; i++){
		for (j = 1; j < threshold; j++){
d87 1
a87 1
gengrpkey (char *login)
d98 1
a98 1
		tcfs_error (ER_MEM, NULL);
d104 1
a104 1
	printf ("La chiave utente di %u e':\n", x);
d110 1
a110 1
			tmp += (eleva(x1,j,257)*coeff[j][i]) % 257;
d112 1
a112 1
			printf ("x1= %u\tj=%d\tcoeff[%d][%d]=%u\ttmp=%u\tchiave: ", x1, j, j, i, coeff[j][i], tmp);
d114 2
a115 1
			}
d119 1
a119 1
		memcpy (res+k++, &tmp, 1);
d121 1
a121 1
		printf ("%u\n", *(res+k-1));
d123 25
a147 25
		switch (i % 8){
			case 0:
				obits.bf.b1=tmp>>8;
				break;
			case 1:
				obits.bf.b2=tmp>>8;
				break;
			case 2:
				obits.bf.b3=tmp>>8;
				break;
			case 3:
				obits.bf.b4=tmp>>8;
				break;
			case 4:
				obits.bf.b5=tmp>>8;
				break;
			case 5:
				obits.bf.b6=tmp>>8;
				break;
			case 6:
				obits.bf.b7=tmp>>8;
				break;
			case 7:
				obits.bf.b8=tmp>>8;
				break;
d150 1
a150 1
		if ((i%8) == 7) {
d155 1
a155 1
			printf ("%u\n", res[k-1]);
d158 1
a158 1
			obits.byte=0;
d165 1
a165 1
	return res;
d169 1
a169 1
addgroup_main (int argn, char *argv[])
d181 1
a181 1
	while ((val = getopt (argn, argv, "vg:m:t:h")) != EOF)
d194 1
a194 1
					tcfs_error (ER_CUSTOM, "Nonexistent group.");
d196 1
a196 1
				gid=group_id->gr_gid;
d206 2
a207 2
			show_usage (addgroup_usage, argv[0]);
			exit (OK);
d212 2
a213 2
			fprintf (stderr, "Try %s --help for more information.\n", argv[0]);
			exit (ER_UNKOPT);
d217 1
a217 1
		tcfs_error (ER_UNKOPT, NULL);
d225 1
a225 1
			tcfs_error (ER_MEM, NULL);
d227 2
a228 2
		printf ("Group id [or name] of the TCFS group to add to the database: ");
		fgets (buff, 2048, stdin);
d238 1
a238 1
				tcfs_error (ER_CUSTOM, "Nonexistent group.");
d244 1
a244 1
			tcfs_error (ER_CUSTOM, "A positive ID please!");
d246 1
a246 1
		free (buff);
d253 1
a253 1
		buff=(char*)calloc(2048, sizeof(char));
d255 1
a255 1
			tcfs_error (ER_MEM, NULL);
d257 2
a258 2
		printf ("Number of members for the TCFS group ID #%d: ", gid);
		fgets (buff, 2048, stdin);
d272 1
a272 1
			tcfs_error (ER_MEM, NULL);
d274 2
a275 2
		printf ("Threshold for the TCFS group ID #%d: ", gid);
		fgets (buff, 2048, stdin);
d280 1
a280 1
		free (buff);
d284 1
a284 1
		tcfs_error (ER_CUSTOM, "At least two members!");
d287 1
a287 1
		tcfs_error (ER_CUSTOM, "The threshold must be no greater than the number of members and greater than zero!");
d294 1
a294 1
		printf ("La chiave segreta e':\n");
d296 2
a297 2
		for (i=0;i<KEYSIZE;i++)
			printf ("%u:", S[i]);
d299 1
a299 1
		printf ("\n");
d324 2
a325 2
		if (!unix_auth (&user, &passwd, FALSE)) {
			fprintf (stderr, "Invalid password or the user does not exist.\n");
d329 1
a329 1
		if (tcfs_ggetpwnam (user, gid, &tmp))
d333 2
a334 2
			if (!strcmp (user, group_info[tmpmemb-1]->user)) {
				fprintf (stderr, "User already present into the group.\n");
d344 1
a344 1
		strcpy (group_info[members-1]->user, user);
d346 1
a346 1
		newkey = (unsigned char*)calloc(GKEYSIZE + 1, sizeof (char));
d348 1
a348 1
			tcfs_error (ER_MEM, NULL);
d352 1
a352 1
			tcfs_error (ER_MEM, NULL);
d354 1
a354 1
		memcpy (newkey, gengrpkey (user), GKEYSIZE);
d360 9
a368 9
		if (!tcfs_encrypt_key (passwd, newkey, GKEYSIZE,
		    cryptedkey, UUGKEYSIZE))
			tcfs_error (ER_MEM, NULL);

		free (newkey);

		strlcpy (group_info[members - 1]->gkey, cryptedkey,
			 GKEYSIZE + 1);
		free (cryptedkey);
d377 1
a377 1
			printf ("Creating a new entry for group %d and user %s in the TCFS database...\n", 
d381 1
a381 1
		if (!tcfs_gputpwnam (group_info[members-1]->user,
d384 1
a384 1
			tcfs_error (ER_CUSTOM, "Error: cannot add a user to the group.");
d388 1
a388 1
			printf ("TCFS group entry for user %s created.\n", group_info[members-1]->user);
d393 1
a393 1
	tcfs_error (ER_CUSTOM, "\nAll group keys generated.");
d395 1
a395 1
	return 0;
d403 1
a403 1
	int res = 1,i;
d406 1
a406 1
		res = (res*res)%z;
d408 1
a408 1
			res = (x*res)%z;
d412 1
a412 1
	return res;
@


1.6
log
@fix parms in tcfs_encrypt_key. I'm not sure if this is fine, tho.
reading tcf_keymaint looks like args should be swapped. niels?
@
text
@d1 1
a1 1
/*	$OpenBSD: tcfsaddgroup.c,v 1.5 2000/06/19 20:35:47 fgsch Exp $	*/
d360 1
a360 1
		    cryptedkey, GROUPKEY))
@


1.5
log
@add openbsd tag
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d359 2
a360 1
		if (!tcfs_encrypt_key (user, passwd, newkey, cryptedkey, GROUPKEY))
@


1.4
log
@more cleaning. KNF
@
text
@d1 2
@


1.3
log
@add missing headers, declare missing functions remove unused vars, KNF;
more to come.
@
text
@d14 2
d17 2
a19 3
#include <stdlib.h>
#include <pwd.h>
#include <grp.h>
@


1.2
log
@fix a couple of bugs.  dont clobber tcfspwdb when adding group entries.
do the fgets correctly until aaron gets to them.
@
text
@d86 1
a86 1
	int l, x1, i, j, k=0;
d167 1
a167 1
	int index, val;
@


1.1
log
@Initial revision
@
text
@d225 1
a225 1
		len = strlen(buff) - 2;
d236 1
a236 1
			gid=group_id->gr_gid;
d255 1
a255 1
		len = strlen(buff) - 2;
d272 1
a272 1
		len = strlen(buff) - 2;
d342 1
a342 1
		newkey = (unsigned char*)calloc(KEYSIZE*2, sizeof (char));
d346 1
a346 1
		cryptedkey = (unsigned char*)calloc(UUKEYSIZE, sizeof(char));
d350 2
a351 12
		memcpy (newkey, gengrpkey (user), KEYSIZE + KEYSIZE/8);
		newkey[KEYSIZE + KEYSIZE/8] = '\0';
#ifdef DEBUG_TCFS
		{
			int i;

			printf ("%s newkey: ", user);
			for (i = 0;i <= KEYSIZE; i++)
				printf ("%u:", newkey[i]);
			printf ("\n");
		}
#endif
a358 18
#ifdef DEBUG_TCFS
		{
			unsigned char *key;
			int i;

			key=(unsigned char *)calloc(UUKEYSIZE, sizeof(char));
			if (!tcfs_decrypt_key (user, passwd, cryptedkey, key, GROUPKEY))
				exit (0);

			printf ("%s key: ", user);
			for (i=0;i<=KEYSIZE;i++)
				printf ("%u:", key[i]);
			printf ("\n");

			free (key);
		}
#endif

d361 2
a362 1
		strcpy (group_info[members-1]->gkey, cryptedkey);
d368 1
a368 1
	members=temp_members;
d372 3
a374 1
			printf ("Creating a new entry for user %s in the TCFS database...\n", group_info[members-1]->user);
d376 2
a377 1
		if (!tcfs_gputpwnam (group_info[members-1]->user, group_info[members-1], U_NEW)) {
@


1.1.1.1
log
@Initial import of very much rewritten TCFS userland.  This code is still
nasty.
@
text
@@
