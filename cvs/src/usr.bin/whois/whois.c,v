head	1.56;
access;
symbols
	OPENBSD_6_2:1.56.0.2
	OPENBSD_6_2_BASE:1.56
	OPENBSD_6_1:1.55.0.4
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.53.0.4
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.47.0.4
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.46.0.6
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.46.0.4
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.44.0.2
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.43.0.14
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.12
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.10
	OPENBSD_5_0:1.43.0.8
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.6
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.4
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.41.0.10
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.41.0.6
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.41.0.4
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.40.0.2
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.37.0.2
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.36.0.4
	OPENBSD_3_9_BASE:1.36
	OPENBSD_3_8:1.36.0.2
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.30.0.6
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.4
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.56
date	2017.07.26.15.48.38;	author sthen;	state Exp;
branches;
next	1.55;
commitid	khzzybKEvOIIJT00;

1.55
date	2017.03.17.14.59.01;	author millert;	state Exp;
branches;
next	1.54;
commitid	2ec92UNdtZnxfltq;

1.54
date	2017.03.15.16.45.25;	author millert;	state Exp;
branches;
next	1.53;
commitid	Fo9dbSOOo5kdQeX0;

1.53
date	2015.12.09.19.29.49;	author mmcc;	state Exp;
branches;
next	1.52;
commitid	T5Y5trrkrbvb2jXC;

1.52
date	2015.11.02.20.39.37;	author sthen;	state Exp;
branches;
next	1.51;
commitid	HJjhRu6ZGWP6xbVB;

1.51
date	2015.11.02.17.16.35;	author mmcc;	state Exp;
branches;
next	1.50;
commitid	ZrpYJHfnXgcL4nEe;

1.50
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	sbrB3Q5CNxcwZpfU;

1.49
date	2015.10.03.01.33.20;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	Rc7weegGgWiCQuAm;

1.48
date	2015.08.17.10.48.10;	author sthen;	state Exp;
branches;
next	1.47;
commitid	yDLLhSb90qzafd3A;

1.47
date	2015.04.09.19.29.53;	author sthen;	state Exp;
branches;
next	1.46;
commitid	izFm2lTxeZRSo2lG;

1.46
date	2014.01.03.15.25.18;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2013.11.25.18.06.32;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.05.16.09.10;	author sthen;	state Exp;
branches;
next	1.43;

1.43
date	2010.03.04.21.37.56;	author jmc;	state Exp;
branches;
next	1.42;

1.42
date	2010.03.04.18.17.03;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2007.08.29.08.59.18;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2007.08.06.19.16.06;	author sobrado;	state Exp;
branches;
next	1.39;

1.39
date	2007.07.05.02.12.28;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2006.09.17.17.07.16;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2006.06.01.18.17.35;	author mk;	state Exp;
branches;
next	1.36;

1.36
date	2005.07.22.14.23.13;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2005.06.27.21.01.43;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2005.06.25.14.27.36;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2005.06.25.14.21.34;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2005.06.22.16.50.49;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2005.06.22.10.29.57;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2003.10.12.13.26.09;	author jmc;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.04.03.18.38;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.18.22.16.15;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.10.22.20.54;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.03.02.56.23;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.15.23.30.33;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.15.23.24.45;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.15.23.16.29;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.01.07.17.24.08;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.06.20.47.19;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.05.00.27.55;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.19.21.34.28;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.19.20.37.24;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.17.20.17.49;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.05.17.22.16;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.29.18.33.40;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.27.59;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.21.00.55.55;	author stevesk;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.04.19.28.58;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.12.18.01.57;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	99.11.19.03.57.14;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.11.19.03.50.49;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.11.15.19.41.00;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.11.15.01.46.41;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.10.03.00.42.34;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.08.16.20.24.36;	author art;	state Exp;
branches;
next	1.4;

1.4
date	98.02.24.10.09.50;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.43.39;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.43.02;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.53;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.53;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Teach whois(1) to use the new whois referral field name which has now gone
live on at least .com/.net servers. Changes to this and other fields mentioned
in https://www.icann.org/resources/pages/rdds-labeling-policy-2017-02-01-en.
ok millert@@
@
text
@/*      $OpenBSD: whois.c,v 1.55 2017/03/17 14:59:01 millert Exp $   */

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define	NICHOST		"whois.crsnic.net"
#define	INICHOST	"whois.networksolutions.com"
#define	CNICHOST	"whois.corenic.net"
#define	DNICHOST	"whois.nic.mil"
#define	GNICHOST	"whois.nic.gov"
#define	ANICHOST	"whois.arin.net"
#define	RNICHOST	"whois.ripe.net"
#define	PNICHOST	"whois.apnic.net"
#define	RUNICHOST	"whois.ripn.net"
#define	MNICHOST	"whois.ra.net"
#define LNICHOST	"whois.lacnic.net"
#define	AFNICHOST	"whois.afrinic.net"
#define BNICHOST	"whois.registro.br"
#define	PDBHOST		"whois.peeringdb.com"
#define	IANAHOST	"whois.iana.org"
#define	QNICHOST_TAIL	".whois-servers.net"

#define	WHOIS_PORT	"whois"
#define	WHOIS_SERVER_ID	"Registrar WHOIS Server:"

#define WHOIS_RECURSE		0x01
#define WHOIS_QUICK		0x02

const char *port_whois = WHOIS_PORT;
const char *ip_whois[] = { LNICHOST, RNICHOST, PNICHOST, BNICHOST,
    AFNICHOST, NULL };

__dead void usage(void);
int whois(const char *, const char *, const char *, int);
char *choose_server(const char *, const char *, char **);

int
main(int argc, char *argv[])
{
	int ch, flags, rval;
	char *host, *name, *country;

	country = host = NULL;
	flags = rval = 0;
	while ((ch = getopt(argc, argv, "aAc:dgh:iIlmp:PqQrR")) != -1)
		switch (ch) {
		case 'a':
			host = ANICHOST;
			break;
		case 'A':
			host = PNICHOST;
			break;
		case 'c':
			country = optarg;
			break;
		case 'd':
			host = DNICHOST;
			break;
		case 'g':
			host = GNICHOST;
			break;
		case 'h':
			host = optarg;
			break;
		case 'i':
			host = INICHOST;
			break;
		case 'I':
			host = IANAHOST;
			break;
		case 'l':
			host = LNICHOST;
			break;
		case 'm':
			host = MNICHOST;
			break;
		case 'p':
			port_whois = optarg;
			break;
		case 'P':
			host = PDBHOST;
			break;
		case 'q':
			/* deprecated, now the default */
			break;
		case 'Q':
			flags |= WHOIS_QUICK;
			break;
		case 'r':
			host = RNICHOST;
			break;
		case 'R':
			host = RUNICHOST;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (!argc || (country != NULL && host != NULL))
		usage();

	if (pledge("stdio dns inet", NULL) == -1)
		err(1, "pledge");

	if (host == NULL && country == NULL && !(flags & WHOIS_QUICK))
		flags |= WHOIS_RECURSE;
	for (name = *argv; (name = *argv) != NULL; argv++) {
		char *tofree = NULL;
		const char *server =
		    host ? host : choose_server(name, country, &tofree);
		rval += whois(name, server, port_whois, flags);
		free(tofree);
	}
	return (rval);
}

int
whois(const char *query, const char *server, const char *port, int flags)
{
	FILE *fp;
	char *buf, *p, *nhost, *nbuf = NULL;
	size_t len;
	int i, s, error;
	const char *reason = NULL, *fmt;
	struct addrinfo hints, *res, *ai;

	memset(&hints, 0, sizeof(hints));
	hints.ai_flags = 0;
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	error = getaddrinfo(server, port, &hints, &res);
	if (error) {
		if (error == EAI_SERVICE)
			warnx("%s: bad port", port);
		else
			warnx("%s: %s", server, gai_strerror(error));
		return (1);
	}

	for (s = -1, ai = res; ai != NULL; ai = ai->ai_next) {
		s = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
		if (s == -1) {
			error = errno;
			reason = "socket";
			continue;
		}
		if (connect(s, ai->ai_addr, ai->ai_addrlen) == -1) {
			error = errno;
			reason = "connect";
			close(s);
			s = -1;
			continue;
		}
		break;	/*okay*/
	}
	if (s == -1) {
		if (reason) {
			errno = error;
			warn("%s: %s", server, reason);
		} else
			warn("unknown error in connection attempt");
		freeaddrinfo(res);
		return (1);
	}

	if (strcmp(server, "whois.denic.de") == 0 ||
	    strcmp(server, "de" QNICHOST_TAIL) == 0)
		fmt = "-T dn,ace -C ISO-8859-1 %s\r\n";
	else if (strcmp(server, "whois.dk-hostmaster.dk") == 0 ||
	    strcmp(server, "dk" QNICHOST_TAIL) == 0)
		fmt = "--show-handles %s\r\n";
	else
		fmt = "%s\r\n";

	fp = fdopen(s, "r+");
	if (fp == NULL)
		err(1, "fdopen");
	fprintf(fp, fmt, query);
	fflush(fp);
	nhost = NULL;
	while ((buf = fgetln(fp, &len)) != NULL) {
		p = buf + len - 1;
		if (isspace((unsigned char)*p)) {
			do
				*p = '\0';
			while (p > buf && isspace((unsigned char)*--p));
		} else {
			if ((nbuf = malloc(len + 1)) == NULL)
				err(1, "malloc");
			memcpy(nbuf, buf, len);
			nbuf[len] = '\0';
			buf = nbuf;
		}
		puts(buf);

		if (nhost != NULL || !(flags & WHOIS_RECURSE))
			continue;

		if ((p = strstr(buf, WHOIS_SERVER_ID))) {
			p += sizeof(WHOIS_SERVER_ID) - 1;
			while (isblank((unsigned char)*p))
				p++;
			if ((len = strcspn(p, " \t\n\r"))) {
				if ((nhost = malloc(len + 1)) == NULL)
					err(1, "malloc");
				memcpy(nhost, p, len);
				nhost[len] = '\0';
			}
		} else if (strcmp(server, ANICHOST) == 0) {
			for (p = buf; *p != '\0'; p++)
				*p = tolower((unsigned char)*p);
			for (i = 0; ip_whois[i] != NULL; i++) {
				if (strstr(buf, ip_whois[i]) != NULL) {
					nhost = strdup(ip_whois[i]);
					if (nhost == NULL)
						err(1, "strdup");
					break;
				}
			}
		}
	}
	fclose(fp);
	free(nbuf);

	if (nhost != NULL) {
		error = whois(query, nhost, port, 0);
		free(nhost);
	}
	freeaddrinfo(res);
	return (error);
}

/*
 * If no country is specified determine the top level domain from the query.
 * If the TLD is a number, query ARIN, otherwise, use TLD.whois-server.net.
 * If the domain does not contain '.', check to see if it is an NSI handle
 * (starts with '!') or a CORE handle (COCO-[0-9]+ or COHO-[0-9]+) or an
 * ASN (starts with AS). Fall back to NICHOST for the non-handle case.
 */
char *
choose_server(const char *name, const char *country, char **tofree)
{
	char *server;
	const char *qhead;
	char *ep;
	struct addrinfo hints, *res;

	memset(&hints, 0, sizeof(hints));
	hints.ai_flags = 0;
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;

	if (country != NULL)
		qhead = country;
	else if ((qhead = strrchr(name, '.')) == NULL) {
		if (*name == '!')
			return (INICHOST);
		else if ((strncasecmp(name, "COCO-", 5) == 0 ||
		    strncasecmp(name, "COHO-", 5) == 0) &&
		    strtol(name + 5, &ep, 10) > 0 && *ep == '\0')
			return (CNICHOST);
		else if ((strncasecmp(name, "AS", 2) == 0) &&
		    strtol(name + 2, &ep, 10) > 0 && *ep == '\0')
			return (MNICHOST);
		else
			return (NICHOST);
	} else if (isdigit((unsigned char)*(++qhead)))
		return (ANICHOST);

	/*
	 * Post-2003 ("new") gTLDs are all supposed to have "whois.nic.domain"
	 * (per registry agreement), some older gTLDs also support this...
	 */
	if (asprintf(&server, "whois.nic.%s", qhead) == -1)
		err(1, NULL);

	/* most ccTLDs don't do this, but QNICHOST/whois-servers mostly works */
	if ((strlen(qhead) == 2 ||
	    /* and is required for most of the <=2003 TLDs/gTLDs */
	    strcasecmp(qhead, "org") == 0 ||
	    strcasecmp(qhead, "com") == 0 ||
	    strcasecmp(qhead, "net") == 0 ||
	    strcasecmp(qhead, "cat") == 0 ||
	    strcasecmp(qhead, "pro") == 0 ||
	    strcasecmp(qhead, "info") == 0 ||
	    strcasecmp(qhead, "aero") == 0 ||
	    strcasecmp(qhead, "jobs") == 0 ||
	    strcasecmp(qhead, "mobi") == 0 ||
	    strcasecmp(qhead, "museum") == 0 ||
	     /* for others, if whois.nic.TLD doesn't exist, try whois-servers */
	    getaddrinfo(server, NULL, &hints, &res) != 0)) {
		free(server);
		if (asprintf(&server, "%s%s", qhead, QNICHOST_TAIL) == -1)
			err(1, NULL);
	}

	*tofree = server;
	return (server);
}

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-AadgIilmPQRr] [-c country-code | -h host] "
		"[-p port] name ...\n", __progname);
	exit(1);
}
@


1.55
log
@choose_server() does not always return malloc'd memory so pass
in a pointer that gets filled in when there is something to free.
Noticed by sthen@@ when looking up a numeric address.
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.54 2017/03/15 16:45:25 millert Exp $   */
d65 1
a65 1
#define	WHOIS_SERVER_ID	"Whois Server:"
@


1.54
log
@There's no need to realloc() a chunk of memory when you don't care
about the old contents, we don't want have to memcpy() the old
contents to the new chunk only to throw it away.
While here, use asprintf() to simplify things.  OK deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.53 2015/12/09 19:29:49 mmcc Exp $   */
d76 1
a76 1
char *choose_server(const char *, const char *);
d82 1
a82 1
	char *host, *name, *country, *server;
d151 3
a153 1
		server = host ? host : choose_server(name, country);
d155 1
a155 2
		if (host == NULL)
			free(server);
d284 1
a284 1
choose_server(const char *name, const char *country)
d340 1
@


1.53
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.52 2015/11/02 20:39:37 sthen Exp $   */
d82 1
a82 1
	char *host, *name, *country;
d150 7
a156 4
	for (name = *argv; (name = *argv) != NULL; argv++)
		rval += whois(name, host ? host : choose_server(name, country),
		    port_whois, flags);
	exit(rval);
d285 1
a285 1
	static char *server;
a286 1
	char *nserver;
a287 1
	size_t len;
a310 4
	len = strlen(qhead) + sizeof(QNICHOST_TAIL);
	if ((nserver = realloc(server, len)) == NULL)
		err(1, "realloc");
	server = nserver;
d316 2
a317 1
	snprintf(server, len, "whois.nic.%s", qhead);
d334 3
a336 2
		strlcpy(server, qhead, len);
		strlcat(server, QNICHOST_TAIL, len);
@


1.52
log
@add support for whois -I, to use whois.iana.org (root zone database).
ok millert@@, tweak/"everything else looks fine" jmc@@
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.51 2015/11/02 17:16:35 mmcc Exp $   */
d262 1
a262 2
	if (nbuf != NULL)
		free(nbuf);
@


1.51
log
@Cast isdigit()'s argument to unsigned char.

ok millert@@
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.50 2015/10/09 01:37:09 deraadt Exp $   */
d61 1
d86 1
a86 1
	while ((ch = getopt(argc, argv, "aAc:dgh:ilmp:PqQrR")) != -1)
d109 3
d350 1
a350 1
	    "usage: %s [-AadgilmPQRr] [-c country-code | -h host] "
@


1.50
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.49 2015/10/03 01:33:20 deraadt Exp $   */
d305 1
a305 1
	} else if (isdigit(*(++qhead)))
@


1.49
log
@whois uses dns to lookup whois servers, and then opens sockets to them.
it does not need to open any files, so we can tame with "stdio dns inet".
i think florian and i did this about 2 months ago.
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.48 2015/08/17 10:48:10 sthen Exp $   */
d141 2
a142 2
	if (tame("stdio dns inet", NULL) == -1)
		err(1, "tame");
@


1.48
log
@Fix whois server detection for new TLDs using whois.nic.<domain> where
<domain> has an old TLD as a substring. Specifically, fixes .network lookups.
While there, simplify a strlcpy+strlcat to snprintf. ok millert@@ phessler@@
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.47 2015/04/09 19:29:53 sthen Exp $   */
d140 3
@


1.47
log
@If looking up a string which looks like a gTLD, doesn't match a known set of
existing ones not using the new standard hostnames, and whois.nic.TLD exists,
head straight there for lookups rather than using whois-servers.net (who have
been a bit variable in their speed of picking up new zones). Bug spotted by
giovanni@@ and jasper@@, ok giovanni@@
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.46 2014/01/03 15:25:18 millert Exp $   */
d313 1
a313 2
	strlcpy(server, "whois.nic.", len);
	strlcat(server, qhead, len);
d318 10
a327 10
	    strncasecmp(qhead, "org", 3) == 0 ||
	    strncasecmp(qhead, "com", 3) == 0 ||
	    strncasecmp(qhead, "net", 3) == 0 ||
	    strncasecmp(qhead, "cat", 3) == 0 ||
	    strncasecmp(qhead, "pro", 3) == 0 ||
	    strncasecmp(qhead, "info", 4) == 0 ||
	    strncasecmp(qhead, "aero", 4) == 0 ||
	    strncasecmp(qhead, "jobs", 4) == 0 ||
	    strncasecmp(qhead, "mobi", 4) == 0 ||
	    strncasecmp(qhead, "museum", 6) == 0 ||
@


1.46
log
@The whois() function is called in a loop so make sure we close the
socket to the whois server before returning.  Adapted from a diff
from Loganaden Velvindron.
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.45 2013/11/25 18:06:32 deraadt Exp $   */
d281 6
d308 27
a334 2
	strlcpy(server, qhead, len);
	strlcat(server, QNICHOST_TAIL, len);
@


1.45
log
@obvious cast for isblank()
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.44 2013/03/05 16:09:10 sthen Exp $   */
d152 1
a152 1
	FILE *sfi, *sfo;
d207 2
a208 3
	sfi = fdopen(s, "r");
	sfo = fdopen(s, "w");
	if (sfi == NULL || sfo == NULL)
d210 2
a211 2
	fprintf(sfo, fmt, query);
	fflush(sfo);
d213 1
a213 1
	while ((buf = fgetln(sfi, &len)) != NULL) {
d254 1
@


1.44
log
@let whois -P do a query against peeringdb.  ok deraadt phessler, feedback jmc
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.43 2010/03/04 21:37:56 jmc Exp $   */
d234 1
a234 1
			while (isblank(*p))
@


1.43
log
@remove -6 from usage();
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.42 2010/03/04 18:17:03 krw Exp $   */
d60 1
d85 1
a85 1
	while ((ch = getopt(argc, argv, "aAc:dgh:ilmp:qQrR")) != -1)
d117 3
d313 1
a313 1
	    "usage: %s [-AadgilmQRr] [-c country-code | -h host] "
@


1.42
log
@6Bone is dead and doesn't respond to whois requests. Remove man
page mentions and '-6' related code. Pointed out by Sebastian Rother.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.41 2007/08/29 08:59:18 henning Exp $   */
d309 1
a309 1
	    "usage: %s [-6AadgilmQRr] [-c country-code | -h host] "
@


1.41
log
@add afrinic to the list of known whois servers so that referrals are
followed, part of PR 5566 From: Frank Habicht <geier@@tih.co.tz>
I am not convinced we really want to add new shortcuts on teh commandline
for all whois hosts. the number is increasing, do we really want to add
on option for each? shouldn't we rely on the referrals (working just fine)?
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.40 2007/08/06 19:16:06 sobrado Exp $   */
a58 1
#define SNICHOST	"whois.6bone.net"
d84 1
a84 1
	while ((ch = getopt(argc, argv, "aAc:dgh:ilmp:qQrR6")) != -1)
a126 3
			break;
		case '6':
			host = SNICHOST;
@


1.40
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.39 2007/07/05 02:12:28 millert Exp $   */
d58 1
d70 2
a71 1
const char *ip_whois[] = { LNICHOST, RNICHOST, PNICHOST, BNICHOST, NULL };
@


1.39
log
@Remove unused variable; Lawrence Teo
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.38 2006/09/17 17:07:16 henning Exp $   */
d311 1
a311 1
	    "usage: %s [-6AadgilmQRr] [-c country-code | -h hostname] "
@


1.38
log
@when looking up ASNs (ASxxxx), select radb
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.37 2006/06/01 18:17:35 mk Exp $   */
d79 1
a79 1
	char *host, *name, *country, *server;
d81 1
a81 1
	country = host = server = NULL;
@


1.37
log
@Like DENIC, DK-HOSTMASTER is requires extra attention.  This makes you
actually get handle information when looking up .dk domains.  While
there, make the DENIC stuff use the QNICHOST_TAIL symbol.

Original diff from Soeren Hansen because I was complaining about this,
tweaked by me.

ok beck (holding his nose).
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.36 2005/07/22 14:23:13 henning Exp $   */
d268 2
a269 2
 * (starts with '!') or a CORE handle (COCO-[0-9]+ or COHO-[0-9]+).
 * Fall back to NICHOST for the non-handle case.
d289 3
@


1.36
log
@for .de domains, we need to send more shit to the denic whois server so
that idn domains are handled correctly...
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.35 2005/06/27 21:01:43 henning Exp $   */
d197 1
a197 1
	    strcmp(server, "de.whois-servers.net") == 0)
d199 3
@


1.35
log
@        * pass -Wshadow as well (port_whois vs port)
        * save errno value properly
        * better realloc(3)
All changes taken from NetBSD (partly from -r1.23 and -r1.25).
From: Andrey Matveev <evol@@online.ptt.ru>, thanks!
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.34 2005/06/25 14:27:36 henning Exp $   */
d198 1
a198 1
		fmt = "-T dn %s\r\n";
@


1.34
log
@couldn't stop my fingers from doing some cleanup
@
text
@d1 1
a1 1
/*      $OpenBSD: whois.c,v 1.33 2005/06/25 14:21:34 henning Exp $   */
d41 1
d68 1
a68 1
const char *port = WHOIS_PORT;
d113 1
a113 1
			port = optarg;
d143 1
a143 1
		    port, flags);
d173 1
d178 1
d187 2
a188 1
		if (reason)
d190 1
a190 1
		else
d273 1
d291 1
a291 1
	if ((server = realloc(server, len)) == NULL)
d293 1
@


1.33
log
@$OpenBSD$, got botched
@
text
@d1 1
a1 1
/*      $OpenBSD$   */
a31 14
#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1980, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)whois.c	8.1 (Berkeley) 6/6/93";
#else
static const char rcsid[] = "$OpenBSD: whois.c,v 1.32 2005/06/22 16:50:49 henning Exp $";
#endif
#endif /* not lint */

d70 3
a72 3
static __dead void usage(void);
static int whois(const char *, const char *, const char *, int);
static char *choose_server(const char *, const char *);
a79 3
#ifdef SOCKS
	SOCKSinit(argv[0]);
#endif
d83 1
a83 1
		switch(ch) {
d146 1
a146 1
static int
d171 1
a171 1
		if (s < 0) {
d175 1
a175 1
		if (connect(s, ai->ai_addr, ai->ai_addrlen) < 0) {
d183 1
a183 1
	if (s < 0) {
d202 2
a203 2
	(void)fprintf(sfo, fmt, query);
	(void)fflush(sfo);
d218 1
a218 1
		(void)puts(buf);
d264 1
a264 1
static char *
d280 1
a280 1
			return (CNICHOST);  
d293 1
a293 1
static __dead void
d298 1
a298 1
	(void)fprintf(stderr,
@


1.32
log
@slightly simplify; christos@@netbsd
@
text
@d1 1
a1 1
/*      $NetBSD: whois.c,v 1.27 2005/06/22 12:17:56 christos Exp $   */
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: whois.c,v 1.30 2003/10/12 13:26:09 jmc Exp $";
@


1.31
log
@deal with german stupidity... nic.de decided that it is a good idea to
screw everybody trying to use whois and to require some esoteric flags to be
send with the query to get the regular whois output, which is not only
a pain in the ass to type, but also breaks the automatic server selection
via <tld>.whois-servers.net.
thus, deal with their stupidity by sending these flags unconditionally
whenever we talk to their server.
ok hshoexer claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.30 2003/10/12 13:26:09 jmc Exp $	*/
d167 1
a167 1
	char *buf, *p, *nhost, *nbuf = NULL, *nquery;
d170 1
a170 1
	const char *reason = NULL;
d209 5
a213 8
	if (!strcmp(server, "whois.denic.de") ||
	    !strcmp(server, "de.whois-servers.net")) {
		if (asprintf(&nquery, "-T dn %s", query) == -1)
			err(1, NULL);
	} else {
		if ((nquery = strdup(query)) == NULL)
			err(1, NULL);
	}
d219 1
a219 1
	(void)fprintf(sfo, "%s\r\n", nquery);
d263 2
a264 2
	free(nbuf);
	free(nquery);
@


1.30
log
@sort options and sync usage();
from wiz@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.29 2003/10/04 03:18:38 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: whois.c,v 1.29 2003/10/04 03:18:38 deraadt Exp $";
d167 1
a167 1
	char *buf, *p, *nhost, *nbuf = NULL;
d209 9
d222 1
a222 1
	(void)fprintf(sfo, "%s\r\n", query);
d266 2
a267 2
	if (nbuf != NULL)
		free(nbuf);
@


1.29
log
@whois port hack thingy; rperkins@@tcsg.net
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.28 2003/09/18 22:16:15 fgsch Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: whois.c,v 1.28 2003/09/18 22:16:15 fgsch Exp $";
d310 1
a310 1
	    "usage: %s [-aAdgilmQrR6] [-c country-code | -h hostname] "
@


1.28
log
@if length is 1, don't try to null memory that doesn't belong to us.
found by tedu@@, ok by millert@@ and him.
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.27 2003/06/10 22:20:54 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: whois.c,v 1.27 2003/06/10 22:20:54 deraadt Exp $";
d179 4
a182 1
		warnx("%s: %s", server, gai_strerror(error));
@


1.27
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.26 2003/06/03 02:56:23 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: whois.c,v 1.26 2003/06/03 02:56:23 millert Exp $";
d217 2
a218 2
				*p-- = '\0';
			while (p != buf && isspace((unsigned char)*p));
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.25 2003/04/15 23:30:33 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: whois.c,v 1.25 2003/04/15 23:30:33 millert Exp $";
d89 1
a89 1
main(int argc, char **argv)
@


1.25
log
@I lied, we didn't skip blanks after WHOIS_SERVER_ID; this fixes that.
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.24 2003/04/15 23:24:45 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: whois.c,v 1.24 2003/04/15 23:24:45 millert Exp $";
@


1.24
log
@Remove trailing space in "Whois Server: " since not all records
have whitespace separating that string and the hostname of the
whois server (and we strip out whitespace before the hostname anyway).
Fixes lookups of .org and probably others.
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.23 2003/01/15 23:16:29 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: whois.c,v 1.23 2003/01/15 23:16:29 millert Exp $";
d237 2
@


1.23
log
@Fixes from Andrey Matveev:
o Remove bogus cast to char in getopt() switch
o Check for strdup() failure
o Don't list -p option twice in usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.22 2003/01/07 17:24:08 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: whois.c,v 1.22 2003/01/07 17:24:08 millert Exp $";
d80 1
a80 1
#define	WHOIS_SERVER_ID	"Whois Server: "
d203 1
a203 1
			warn("%s", reason);
@


1.22
log
@Whois updates, mostly adapted from FreeBSD
 o make "whois -i" go to whois.networksolutions.com
 o add "-p port" option (renamed old -p to -A)
 o add support for recursive lookups of IP numbers
 o remove WHOIS_INIC_FALLBACK, it is no longer useful
 o man page updates
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.21 2003/01/06 20:47:19 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: whois.c,v 1.21 2003/01/06 20:47:19 millert Exp $";
d104 1
a104 1
		switch((char)ch) {
d249 2
d309 1
a309 1
	    "usage: %s [-aAdgilmpQrR6] [-c country-code | -h hostname] "
@


1.21
log
@Rename VNICHOST -> NNICHOST now that Verisign has spun off NSI.
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.20 2003/01/05 00:27:55 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: whois.c,v 1.20 2003/01/05 00:27:55 millert Exp $";
d65 1
a65 1
#define	INICHOST	"whois.internic.net"
a73 1
#define NNICHOST	"whois.networksolutions.com"
d76 1
d78 3
a80 1
#define	WHOIS_PORT	43
d83 4
a86 2
#define WHOIS_INIC_FALLBACK	0x02
#define WHOIS_QUICK		0x04
d89 1
a89 1
static int whois(const char *, const char *, int);
d103 1
a103 1
	while ((ch = getopt(argc, argv, "ac:dgh:ilmpqQrR6")) != -1)
d108 3
d133 1
a133 1
			host = PNICHOST;
d136 1
a136 1
			/* default */
d160 1
a160 1
		flags |= WHOIS_INIC_FALLBACK | WHOIS_RECURSE;
d162 2
a163 1
		rval += whois(name, host ? host : choose_server(name, country), flags);
d168 1
a168 1
whois(const char *name, const char *server, int flags)
d173 1
a173 1
	int s, nomatch, error;
d181 1
a181 1
	error = getaddrinfo(server, "whois", &hints, &res);
a198 1

d214 1
a214 1
	(void)fprintf(sfo, "%s\r\n", name);
d217 7
a223 7
	nomatch = 0;
	while ((buf = fgetln(sfi, &len))) {
		if (buf[len - 2] == '\r')
			buf[len - 2] = '\0';
		else if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else {
d230 1
d232 5
a236 3
		if ((flags & WHOIS_RECURSE) && nhost == NULL &&
		    (p = strstr(buf, "Whois Server: "))) {
			p += sizeof("Whois Server: ") - 1;
d243 9
a252 8
		if ((flags & WHOIS_INIC_FALLBACK) && nhost == NULL &&
		    !nomatch && (p = strstr(buf, "No match for \""))) {
			p += sizeof("No match for \"") - 1;
			if ((len = strcspn(p, "\"")) && len == strlen(name) &&
			    strncasecmp(name, p, len) == 0)
				nomatch = 1;
		}
		(void)puts(buf);
d257 3
a259 9
	/* Do second lookup as needed */
	if (nomatch && nhost == NULL) {
		(void)printf("Looking up %s at %s.\n\n", name, INICHOST);
		nhost = INICHOST;
	}
	if (nhost) {
		error += whois(name, nhost, 0);
		if (!nomatch)
			free(nhost);
d284 1
a284 1
			return (NNICHOST);
d307 2
a308 2
	    "usage: %s [-adgilmpqQrR6] [-c country-code | -h hostname] "
		"name ...\n", __progname);
@


1.20
log
@Use a temp variable when cycling through ai_addr's so we don't pass
freeaddrinfo() a NULL pointer if the hostname is not resolvable.
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.19 2002/12/19 21:34:28 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: whois.c,v 1.19 2002/12/19 21:34:28 millert Exp $";
d74 1
a76 1
#define VNICHOST	"whois.networksolutions.com"
d279 1
a279 1
			return (VNICHOST);
@


1.19
log
@Recognize CORENIC handles and use CNICHOST like we do VNICHOST ones.
By request and based on a diff from Henning Brauer
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.18 2002/12/19 20:37:24 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: whois.c,v 1.18 2002/12/19 20:37:24 millert Exp $";
d167 1
a167 1
	struct addrinfo hints, *res;
d179 2
a180 3
	s = -1;
	for (/*nothing*/; res; res = res->ai_next) {
		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
d185 1
a185 1
		if (connect(s, res->ai_addr, res->ai_addrlen) < 0) {
@


1.18
log
@o Add -6 and -c options from FreeBSD
o Get rid of sysexits.h from Andrey Matveev
o Some simplification and cleanup by me (improved readability, less code)
o Add logic to use whois.networksolutions.com if name is a handle starting
  with '!'
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.17 2002/12/17 20:17:49 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: whois.c,v 1.17 2002/12/17 20:17:49 millert Exp $";
d66 1
d263 4
a266 3
 * If the TLD is a number, query ARIN.  Otherwise, use TLD.whois-server.net.
 * If the domain does not contain '.', fall back to NICHOST (or VNICHOST
 * if name is a handle that starts with a '!').
d273 1
d278 10
a287 3
	else if ((qhead = strrchr(name, '.')) == NULL)
		return (*name == '!' ? VNICHOST : NICHOST);
	else if (isdigit(*(++qhead)))
@


1.17
log
@ANSIfu and if given multiple names, don't exit if we get an error
looking up just one.  Exit value is now the number of errors found
trying to lookup all the names.  Some bits from Andrey Matveev.
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.16 2002/09/05 17:22:16 fgsch Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: whois.c,v 1.16 2002/09/05 17:22:16 fgsch Exp $";
d57 1
a61 1
#include <sysexits.h>
d74 2
d84 2
a85 1
static int whois(char *, struct addrinfo *, int);
d90 2
a91 5
	int ch, i, j, error, rval;
	int use_qnichost, flags;
	size_t len;
	char *host, *qnichost, *name;
	struct addrinfo hints, *res;
d96 3
a98 7

	host = NULL;
	qnichost = NULL;
	flags = 0;
	use_qnichost = 0;
	rval = 0;
	while ((ch = getopt(argc, argv, "adgh:ilmpqQrR")) != -1)
d103 3
d139 3
a141 1
		case '?':
d148 1
a148 1
	if (!argc)
d151 4
a154 56
	/*
	 * If no nic host is specified, use whois-servers.net
	 * if there is a '.' in the name, else fall back to NICHOST.
	 */
	if (host == NULL) {
		use_qnichost = 1;
		host = NICHOST;
		if (!(flags & WHOIS_QUICK))
			flags |= WHOIS_INIC_FALLBACK | WHOIS_RECURSE;
	}
	for (name = *argv; (name = *argv) != NULL; argv++) {
		if (use_qnichost) {
			if (qnichost) {
				free(qnichost);
				qnichost = NULL;
			}
			for (i = j = 0; name[i]; i++)
				if (name[i] == '.')
					j = i;
			if (j != 0) {
				len = i - j + 1 + strlen(QNICHOST_TAIL);
				qnichost = (char *)calloc(len, sizeof(char));
				if (!qnichost)
					err(1, "calloc");
				strlcpy(qnichost, name + j + 1, len);
				strlcat(qnichost, QNICHOST_TAIL, len);
				memset(&hints, 0, sizeof(hints));
				hints.ai_flags = 0;
				hints.ai_family = AF_UNSPEC;
				hints.ai_socktype = SOCK_STREAM;
				error = getaddrinfo(qnichost, "whois",
				    &hints, &res);
				if (error) {
					warnx("%s: %s", qnichost,
					    gai_strerror(error));
					rval++;
					continue;
				}
			}
		}
		if (!qnichost) {
			memset(&hints, 0, sizeof(hints));
			hints.ai_flags = 0;
			hints.ai_family = AF_UNSPEC;
			hints.ai_socktype = SOCK_STREAM;
			error = getaddrinfo(host, "whois", &hints, &res);
			if (error) {
				warnx("%s: %s", host, gai_strerror(error));
				rval++;
				continue;
			}
		}

		whois(name, res, flags);
		freeaddrinfo(res);
	}
d159 1
a159 1
whois(char *name, struct addrinfo *res, int flags)
d164 1
a164 1
	int s, nomatch, rval;
d166 11
a178 1
	rval = 0;
d199 2
a200 1
		return (rval + 1);
d206 1
a206 1
		err(EX_OSERR, "fdopen");
d224 1
a224 1
		if ((flags & WHOIS_RECURSE) && !nhost &&
d234 2
a235 2
		if ((flags & WHOIS_INIC_FALLBACK) && !nhost && !nomatch &&
		    (p = strstr(buf, "No match for \""))) {
d243 1
a243 1
	if (nbuf)
d247 1
a247 1
	if (nomatch && !nhost) {
d252 1
a252 12
		struct addrinfo hints, *res2;
		int error;

		memset(&hints, 0, sizeof(hints));
		hints.ai_flags = 0;
		hints.ai_family = AF_UNSPEC;
		hints.ai_socktype = SOCK_STREAM;
		error = getaddrinfo(nhost, "whois", &hints, &res2);
		if (error) {
			warnx("%s: %s", nhost, gai_strerror(error));
			return (rval + 1);
		}
a254 2
		rval += whois(name, res2, 0);
		freeaddrinfo(res2);
d256 29
a284 1
	return (rval);
d290 1
d293 3
a295 2
	    "usage: whois [-adgilmpqQrR] [-h hostname] name ...\n");
	exit(EX_USAGE);
@


1.16
log
@lacnic support; from Loic Tortay <loict@@bougon.net>.
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.14 2002/02/16 21:27:59 millert Exp $	*/
d37 1
a37 1
static char copyright[] =
d44 1
a44 1
static char sccsid[] = "@@(#)whois.c	8.1 (Berkeley) 6/6/93";
d46 1
a46 1
static char rcsid[] = "$OpenBSD: whois.c,v 1.14 2002/02/16 21:27:59 millert Exp $";
d52 1
d56 1
d81 2
a82 2
static void usage(void);
static void whois(char *, struct addrinfo *, int);
d85 1
a85 3
main(argc, argv)
	int argc;
	char **argv;
d87 1
a87 1
	int ch, i, j, error;
d89 2
a90 2
	char *host;
	char *qnichost;
d101 1
d160 1
a160 1
	while (argc--) {
d166 2
a167 2
			for (i = j = 0; (*argv)[i]; i++)
				if ((*argv)[i] == '.')
d170 2
a171 3
				int len = i - j + 1 + strlen(QNICHOST_TAIL);

				qnichost = (char *) calloc(len, sizeof(char));
d173 2
a174 2
					err(1, "malloc");
				strlcpy(qnichost, *argv + j + 1, len);
d182 2
a183 2
				if (error != 0)
					errx(EX_NOHOST, "%s: %s", qnichost,
d185 3
d196 5
a200 3
			if (error != 0)
				errx(EX_NOHOST, "%s: %s", host,
				    gai_strerror(error));
d203 1
a203 1
		whois(*argv++, res, flags);
d206 1
a206 1
	exit(0);
d209 2
a210 5
static void
whois(name, res, flags)
	char *name;
	struct addrinfo *res;
	int flags;
d215 1
a215 1
	int s, nomatch;
d219 1
d237 1
a237 1
			err(EX_OSERR, "%s", reason);
d239 2
a240 1
			errx(EX_OSERR, "unknown error in connection attempt");
d257 2
a258 1
			nbuf = malloc(len + 1);
d300 1
a300 1
		if (error != 0) {
d302 1
a302 1
			return;
d306 1
a306 1
		whois(name, res2, 0);
d309 1
d312 2
a313 2
static void
usage()
@


1.15
log
@strlcat
@
text
@d71 1
d101 1
a101 1
	while ((ch = getopt(argc, argv, "adgh:impqQrR")) != -1)
d118 3
d311 1
a311 1
	    "usage: whois [-adgimpqQrR] [-h hostname] name ...\n");
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.13 2002/01/21 00:55:55 stevesk Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: whois.c,v 1.13 2002/01/21 00:55:55 stevesk Exp $";
d165 3
a167 2
				qnichost = (char *) calloc(i - j + 1 +
				    strlen(QNICHOST_TAIL), sizeof(char));
d170 2
a171 2
				strcpy(qnichost, *argv + j + 1);
				strcat(qnichost, QNICHOST_TAIL);
d177 1
a177 1
						&hints, &res);
d180 1
a180 1
						gai_strerror(error));
d191 1
a191 1
					gai_strerror(error));
@


1.13
log
@correct usage; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.12 2001/10/04 19:28:58 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: whois.c,v 1.12 2001/10/04 19:28:58 millert Exp $";
d78 2
a79 2
static void usage	__P((void));
static void whois	__P((char *, struct addrinfo *, int));
@


1.12
log
@Deal with whois output that lacks a final newline.  This is not legal
but apparently there are broken whois servers out there.
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.11 2000/07/12 18:01:57 itojun Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: whois.c,v 1.11 2000/07/12 18:01:57 itojun Exp $";
d306 1
a306 1
	    "usage: whois [-adgimpqQrR6] [-h hostname] name ...\n");
@


1.11
log
@make whois(1) IPv6-ready.  patch from deraadt + minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.10 1999/11/19 03:57:14 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: whois.c,v 1.10 1999/11/19 03:57:14 millert Exp $";
d206 1
a206 1
	char *buf, *p, *nhost;
d245 1
a245 1
		else
d247 6
d273 2
@


1.10
log
@When eearching for the string: No match for "FOO".
verify that the length of the quoted string == length of the name we
are looking up.  Inspired but not based on a FreeBSD change.
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.9 1999/11/19 03:50:49 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: whois.c,v 1.9 1999/11/19 03:50:49 millert Exp $";
d79 1
a79 1
static void whois	__P((char *, struct sockaddr_in *, int));
d86 1
a86 1
	int ch, i, j;
d90 1
a90 3
	struct servent *sp;
	struct hostent *hp;
	struct sockaddr_in sin;
a144 9
	memset(&sin, 0, sizeof sin);
	sin.sin_len = sizeof(sin);
	sin.sin_family = AF_INET;
	sp = getservbyname("whois", "tcp");
	if (sp == NULL)
		sin.sin_port = htons(WHOIS_PORT);
	else
		sin.sin_port = sp->s_port;

d171 9
a179 10

				if (inet_aton(qnichost, &sin.sin_addr) == 0) {
					hp = gethostbyname2(qnichost, AF_INET);
					if (hp == NULL) {
						free(qnichost);
						qnichost = NULL;
					} else {
						sin.sin_addr = *(struct in_addr *)hp->h_addr_list[0];
					}
				}
d182 7
a188 3
		if (!qnichost && inet_aton(host, &sin.sin_addr) == 0) {
			hp = gethostbyname2(host, AF_INET);
			if (hp == NULL)
d190 1
a190 3
				    hstrerror(h_errno));
			host = hp->h_name;
			sin.sin_addr = *(struct in_addr *)hp->h_addr_list[0];
d193 2
a194 1
		whois(*argv++, &sin, flags);
d200 1
a200 1
whois(name, sinp, flags)
d202 1
a202 1
	struct sockaddr_in *sinp;
d209 1
d211 13
a223 3
	s = socket(PF_INET, SOCK_STREAM, 0);
	if (s < 0)
		err(EX_OSERR, "socket");
d225 8
a232 2
	if (connect(s, (struct sockaddr *)sinp, sizeof(*sinp)) < 0)
		err(EX_OSERR, "connect");
d274 11
a284 5
		if (inet_aton(nhost, &sinp->sin_addr) == 0) {
			struct hostent *hp = gethostbyname2(nhost, AF_INET);
			if (hp == NULL)
				return;
			sinp->sin_addr = *(struct in_addr *)hp->h_addr_list[0];
d288 2
a289 1
		whois(name, sinp, 0);
d298 1
a298 1
	    "usage: whois [-adgimpqQrR] [-h hostname] name ...\n");
@


1.9
log
@o Add -Q option to usage string
o Add SOCKS support from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.8 1999/11/15 19:41:00 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: whois.c,v 1.8 1999/11/15 19:41:00 millert Exp $";
d253 1
a253 1
			if ((len = strcspn(p, "\"")) &&
@


1.8
log
@o Make -q option the default
o When invoked with no arguments and the record contains 'Whois Server: foo'
  also do the lookup using foo as the whois server.
o If an entry BAR is not found (No match for "BAR"), fall back on
  whois.internic.net.  This makes internic handle lookups work again.
o Fix lookup of multiple entries
o Add -Q (quick) option to turn off double lookup
Note:
Double lookups will not work properly until {com,net,org}.whois-servers.net
has been changed to point to whois.crsnic.net (in progress).
Man page still needs a bit of work.
@
text
@d1 1
a1 2
/*	$OpenBSD: whois.c,v 1.7 1999/11/15 01:46:41 millert Exp $	*/
/*	$NetBSD: whois.c,v 1.5 1994/11/14 05:13:25 jtc Exp $	*/
d45 2
a47 1
static char rcsid[] = "$OpenBSD: whois.c,v 1.7 1999/11/15 01:46:41 millert Exp $";
d94 4
d283 1
a283 1
	    "usage: whois [-adgimpqrR] [-h hostname] name ...\n");
@


1.7
log
@From FreeBSD:
o Change default nic host to whois.crsnic.net to also get hosts registered
  by registrars other than NSI.
o -i option to use NSI's nic host (whois.internic.net)
o -g option to use .gov nic host
o -R option to use .ru nic host
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.6 1999/10/03 00:42:34 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: whois.c,v 1.6 1999/10/03 00:42:34 deraadt Exp $";
d74 6
a79 1
static void usage __P((void));
d86 2
a87 6
	register FILE *sfi, *sfo;
	register int ch;
	struct sockaddr_in sin;
	struct hostent *hp;
	struct servent *sp;
	int s;
d90 3
a92 2
	int use_qnichost;
	int i, j;
d94 3
a96 1
	host = NICHOST;
d98 1
a98 1
	while ((ch = getopt(argc, argv, "adgh:impqrR")) != -1)
d122 4
a125 1
			use_qnichost = 1;
d143 25
a167 2
	if (use_qnichost != 0) {
		if (argc == 1) {
d169 2
a170 1
				if ((*argv)[i] == '.') j = i;
d172 1
a172 1
				qnichost = (char *) calloc(i - j + 1 + \
d178 10
a187 1
				host = qnichost;
d190 10
d201 13
d219 1
a219 19
	memset(&sin, 0, sizeof sin);
	sin.sin_len = sizeof sin;
	sin.sin_family = AF_INET;

	if (inet_aton(host, &sin.sin_addr) == 0) {
		hp = gethostbyname2(host, AF_INET);
		if (hp == NULL)
			errx(EX_NOHOST, "%s: %s", host, hstrerror(h_errno));
		host = hp->h_name;
		sin.sin_addr = *(struct in_addr *)hp->h_addr_list[0];
	}

	sp = getservbyname("whois", "tcp");
	if (sp == NULL)
		sin.sin_port = htons(WHOIS_PORT);
	else
		sin.sin_port = sp->s_port;

	if (connect(s, (struct sockaddr *)&sin, sizeof(sin)) < 0)
d226 1
a226 3
	while (argc-- > 1)
		(void)fprintf(sfo, "%s ", *argv++);
	(void)fprintf(sfo, "%s\r\n", *argv);
d228 44
a271 3
	while ((ch = getc(sfi)) != EOF)
		putchar(ch);
	exit(0);
@


1.6
log
@whois-servers.net and whois.ra.net support; jabley@@patho.gen.nz
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.5 1999/08/16 20:24:36 art Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: whois.c,v 1.5 1999/08/16 20:24:36 art Exp $";
d55 1
a60 1
#include <err.h>
d62 4
a65 2
#define	NICHOST		"whois.internic.net"
#define	DNICHOST	"nic.ddn.mil"
d69 1
d74 1
a74 1
static void usage();
a80 2
	extern char *optarg;
	extern int optind;
d94 1
a94 1
	while ((ch = getopt(argc, argv, "adh:pmqr")) != -1)
d102 3
d108 3
d123 3
d193 3
a195 1
	(void)fprintf(stderr, "usage: whois [-admpqr] [-h hostname] name ...\n");
@


1.5
log
@fix includes
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.4 1998/02/24 10:09:50 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: whois.c,v 1.4 1998/02/24 10:09:50 deraadt Exp $";
d67 2
d87 3
d92 2
a93 1
	while ((ch = getopt(argc, argv, "adh:pr")) != -1)
d104 3
d110 3
d126 16
d183 1
a183 1
	(void)fprintf(stderr, "usage: whois [-adpr] [-h hostname] name ...\n");
@


1.4
log
@add new flags for global NIC access; wollman
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.3 1997/01/15 23:43:39 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: whois.c,v 1.3 1997/01/15 23:43:39 millert Exp $";
d53 1
d60 1
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.2 1996/06/26 05:43:02 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: whois.c,v 1.2 1996/06/26 05:43:02 deraadt Exp $";
d57 1
d60 6
a65 1
#define	NICHOST	"whois.internic.net"
d85 1
a85 1
	while ((ch = getopt(argc, argv, "h:")) != -1)
d87 6
d96 6
d112 14
a125 5
	hp = gethostbyname(host);
	if (hp == NULL) {
		(void)fprintf(stderr, "whois: %s: ", host);
		herror((char *)NULL);
		exit(1);
d127 1
a127 13
	host = hp->h_name;
	s = socket(hp->h_addrtype, SOCK_STREAM, 0);
	if (s < 0) {
		perror("whois: socket");
		exit(1);
	}
	bzero((caddr_t)&sin, sizeof (sin));
	sin.sin_family = hp->h_addrtype;
	if (bind(s, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
		perror("whois: bind");
		exit(1);
	}
	bcopy(hp->h_addr, (char *)&sin.sin_addr, hp->h_length);
d129 8
a136 9
	if (sp == NULL) {
		(void)fprintf(stderr, "whois: whois/tcp: unknown service\n");
		exit(1);
	}
	sin.sin_port = sp->s_port;
	if (connect(s, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
		perror("whois: connect");
		exit(1);
	}
d139 2
a140 5
	if (sfi == NULL || sfo == NULL) {
		perror("whois: fdopen");
		(void)close(s);
		exit(1);
	}
d153 2
a154 2
	(void)fprintf(stderr, "usage: whois [-h hostname] name ...\n");
	exit(1);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: whois.c,v 1.5 1994/11/14 05:13:25 jtc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: whois.c,v 1.5 1994/11/14 05:13:25 jtc Exp $";
d79 1
a79 1
	while ((ch = getopt(argc, argv, "h:")) != EOF)
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: whois.c,v 1.5 1994/11/14 05:13:25 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
