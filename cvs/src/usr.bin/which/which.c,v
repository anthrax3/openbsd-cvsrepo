head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.6
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.12
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.8
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.6
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.10
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.8
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.6
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.14
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.12
	OPENBSD_2_8:1.5.0.10
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.26
date	2016.10.28.07.22.59;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	ZyVHGm9uxvQc0g4F;

1.25
date	2016.01.14.22.02.13;	author millert;	state Exp;
branches;
next	1.24;
commitid	TjYJcXWCaErupKY2;

1.24
date	2016.01.14.22.00.53;	author millert;	state Exp;
branches;
next	1.23;
commitid	eoonXEWDorcE61vL;

1.23
date	2016.01.14.21.54.24;	author millert;	state Exp;
branches;
next	1.22;
commitid	nWuoRy0DQUPGrxQ4;

1.22
date	2015.12.29.19.04.46;	author gsoares;	state Exp;
branches;
next	1.21;
commitid	k2UzU75zoPNqkN7K;

1.21
date	2015.10.10.19.02.19;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	6CYGMzCJBnS3NN3X;

1.20
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	Uu5nFG3wCl0LACBb;

1.19
date	2014.05.20.01.25.23;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2013.04.10.02.57.20;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2011.03.11.04.30.21;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2010.05.31.14.01.49;	author sobrado;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.08.14.17.41.10;	author sobrado;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.24.19.45.27;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.23.17.44.47;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.17.21.56.26;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.10.22.20.54;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.01.52.41;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.04.03.25.28;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.04.00.42.34;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.59;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.06.21.22.14.05;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.05.07.19.12.20;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.01.28.17.18.53;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.04.08.02.44.07;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.02.21.18.35.00;	author millert;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Delete some useless setlocale(3) calls in /usr/bin, no functional change.
Patches from Jan Stary <hans at stare dot cz>, tweaked by me and tb@@.
While here, apply some simple style improvements:
Sort headers, static void __dead usage(), return from main(),
zap case '?', drop /* NOTREACHED */, drop break after usage(), ...
OK tb@@ millert@@
@
text
@/*	$OpenBSD: which.c,v 1.25 2016/01/14 22:02:13 millert Exp $	*/

/*
 * Copyright (c) 1997 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/stat.h>
#include <sys/sysctl.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define PROG_WHICH	1
#define PROG_WHEREIS	2

extern char *__progname;

int findprog(char *, char *, int, int);
static void __dead usage(void);

/*
 * which(1) -- find an executable(s) in the user's path
 * whereis(1) -- find an executable(s) in the default user path
 *
 * Return values:
 *	0 - all executables found
 *	1 - some found, some not
 *	2 - none found
 */

int
main(int argc, char *argv[])
{
	char *path;
	size_t n;
	int ch, allmatches = 0, notfound = 0, progmode = PROG_WHICH;

	while ((ch = getopt(argc, argv, "a")) != -1)
		switch (ch) {
		case 'a':
			allmatches = 1;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (argc == 0)
		usage();

	if (strcmp(__progname, "whereis") == 0) {
		progmode = PROG_WHEREIS;
		path = _PATH_STDPATH;
	} else {
		if ((path = getenv("PATH")) == NULL || *path == '\0')
			path = _PATH_DEFPATH;
	}

	/* To make access(2) do what we want */
	if (setgid(getegid()))
		err(1, "Can't set gid to %u", getegid());
	if (setuid(geteuid()))
		err(1, "Can't set uid to %u", geteuid());

	if (pledge("stdio rpath", NULL) == -1)
		err(2, "pledge");

	for (n = 0; n < argc; n++)
		if (findprog(argv[n], path, progmode, allmatches) == 0)
			notfound++;

	return ((notfound == 0) ? 0 : ((notfound == argc) ? 2 : 1));
}

int
findprog(char *prog, char *path, int progmode, int allmatches)
{
	char *p, filename[PATH_MAX];
	int len, rval = 0;
	struct stat sbuf;
	char *pathcpy;

	/* Special case if prog contains '/' */
	if (strchr(prog, '/')) {
		if ((stat(prog, &sbuf) == 0) && S_ISREG(sbuf.st_mode) &&
		    access(prog, X_OK) == 0) {
			(void)puts(prog);
			return (1);
		} else {
			warnx("%s: Command not found.", prog);
			return (0);
		}
	}

	if ((path = strdup(path)) == NULL)
		err(1, "strdup");
	pathcpy = path;

	while ((p = strsep(&pathcpy, ":")) != NULL) {
		if (*p == '\0')
			p = ".";

		len = strlen(p);
		while (len > 0 && p[len-1] == '/')
			p[--len] = '\0';	/* strip trailing '/' */

		len = snprintf(filename, sizeof(filename), "%s/%s", p, prog);
		if (len < 0 || len >= sizeof(filename)) {
			warnc(ENAMETOOLONG, "%s/%s", p, prog);
			free(path);
			return (0);
		}
		if ((stat(filename, &sbuf) == 0) && S_ISREG(sbuf.st_mode) &&
		    access(filename, X_OK) == 0) {
			(void)puts(filename);
			rval = 1;
			if (!allmatches) {
				free(path);
				return (rval);
			}
		}
	}
	(void)free(path);

	/* whereis(1) is silent on failure. */
	if (!rval && progmode != PROG_WHEREIS)
		warnx("%s: Command not found.", prog);
	return (rval);
}

static void __dead
usage(void)
{
	(void)fprintf(stderr, "usage: %s [-a] name ...\n", __progname);
	exit(1);
}
@


1.25
log
@Check the return value of snprintf() for potential overflow instead
of doing a manual check beforehand.
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.23 2016/01/14 21:54:24 millert Exp $	*/
d24 1
a24 1
#include <locale.h>
a29 1
#include <limits.h>
d37 1
a37 1
__dead void usage(void);
a55 2
	(void)setlocale(LC_ALL, "");

d91 1
a91 1
	exit((notfound == 0) ? 0 : ((notfound == argc) ? 2 : 1));
d150 1
a150 1
__dead void
@


1.24
log
@Avoid potential read of one byte before the start of a malloc()ed
buffer.  From Max Fillinger.
@
text
@d101 1
a101 1
	int proglen, plen, rval = 0;
a120 1
	proglen = strlen(prog);
d125 3
a127 3
		plen = strlen(p);
		while (plen > 0 && p[plen-1] == '/')
			p[--plen] = '\0';	/* strip trailing '/' */
d129 2
a130 1
		if (plen + 1 + proglen >= sizeof(filename)) {
a134 2

		snprintf(filename, sizeof(filename), "%s/%s", p, prog);
@


1.23
log
@Use _PATH_DEFPATH if no PATH in the environment when invoked as which.
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.22 2015/12/29 19:04:46 gsoares Exp $	*/
d127 1
a127 1
		while (p[plen-1] == '/')
@


1.22
log
@fix exit status on pledge(2) failure.

OK tb@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.21 2015/10/10 19:02:19 deraadt Exp $	*/
d77 2
a78 2
		if ((path = getenv("PATH")) == NULL)
			err(1, "can't get $PATH from environment");
@


1.21
log
@pledge "stdio rpath"
ok beck doug
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.20 2015/01/16 06:40:14 deraadt Exp $	*/
d88 1
a88 1
		err(1, "pledge");
@


1.20
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.19 2014/05/20 01:25:23 guenther Exp $	*/
d86 3
@


1.19
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.18 2013/04/10 02:57:20 guenther Exp $	*/
a18 1
#include <sys/param.h>
d30 1
d97 1
a97 1
	char *p, filename[MAXPATHLEN];
@


1.18
log
@Get the standard path from _PATH_STDPATH instead of
sysctl({CTL_USER,USER_CS_PATH}).  Expand that into the manpage
too.

_PATH_STDPATH suggested by miod@@
Corrections from schwarze@@ and jmc@@
ok millert@@ miod@@ schwarze@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.17 2011/03/11 04:30:21 guenther Exp $	*/
d128 1
a128 1
			warnx("%s/%s: %s", p, prog, strerror(ENAMETOOLONG));
@


1.17
log
@The -a option shouldn't change the exit status
Patch from David Julio (david.a.julio at gmail.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.16 2010/05/31 14:01:49 sobrado Exp $	*/
d26 1
a72 4
	/*
	 * which(1) uses user's $PATH.
	 * whereis(1) uses user.cs_path from sysctl(3).
	 */
a73 2
		int mib[2];

d75 1
a75 10
		mib[0] = CTL_USER;
		mib[1] = USER_CS_PATH;
		if (sysctl(mib, 2, NULL, &n, NULL, 0) == -1)
			err(1, "unable to get length of user.cs_path");
		if (n == 0)
			errx(1, "user.cs_path was zero length!");
		if ((path = (char *)malloc(n)) == NULL)
			errx(1, "can't allocate memory.");
		if (sysctl(mib, 2, path, &n, NULL, 0) == -1)
			err(1, "unable to get user.cs_path");
@


1.16
log
@stderr should be used for error messages; this diff makes which(1)
output not only more standard but also more predictable, as it now
matches the behavior of the csh(1)'s built-in command.

diff from Tobias Ulmer.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.15 2009/10/27 23:59:50 deraadt Exp $	*/
d58 1
a58 5
	if (argc == 1)
		usage();

	/* Don't accept command args but check since old whereis(1) used to */
	while ((ch = getopt(argc, argv, "a")) != -1) {
d66 5
a70 1
	}
d101 1
a101 1
	for (n = optind; n < argc; n++)
d105 1
a105 1
	exit((notfound == 0) ? 0 : ((notfound == argc - 1) ? 2 : 1));
@


1.15
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.14 2007/08/14 17:41:10 sobrado Exp $	*/
d123 1
a123 1
			(void)printf("%s: Command not found.\n", prog);
d129 1
a129 1
		errx(1, "Can't allocate memory.");
d162 1
a162 1
		(void)printf("%s: Command not found.\n", prog);
@


1.14
log
@the ellipsis is not an optional argument; document the "-a" flag in whereis(1)

help and feedback by jmc@@ and otto@@

ok deraadt@@, jmc@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.13 2004/09/24 19:45:27 fgsch Exp $	*/
a17 4

#ifndef lint                                                              
static const char rcsid[] = "$OpenBSD: which.c,v 1.13 2004/09/24 19:45:27 fgsch Exp $";
#endif /* not lint */                                                        
@


1.13
log
@save a copy of the pointer before strsep; fixes an abort on free.
ok by millert, otto & pedro.
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.12 2004/09/23 17:44:47 millert Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: which.c,v 1.12 2004/09/23 17:44:47 millert Exp $";
d173 1
a173 1
	(void) fprintf(stderr, "Usage: %s [-a] name [...]\n", __progname);
@


1.12
log
@Add missing free on error; Alison Winters
Also KNF the return statements and make usage() __dead while I am here.
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.11 2003/06/17 21:56:26 millert Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: which.c,v 1.11 2003/06/17 21:56:26 millert Exp $";
d118 1
d134 1
d137 1
a137 1
	while ((p = strsep(&path, ":")) != NULL) {
@


1.11
log
@Sync with share/misc/license.template and add missing DARPA credit
where applicable.
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.10 2003/06/10 22:20:54 deraadt Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: which.c,v 1.10 2003/06/10 22:20:54 deraadt Exp $";
d41 1
a41 1
void usage(void);
d124 1
a124 1
			return(1);
d127 1
a127 1
			return(0);
d145 2
a146 1
			return(0);
d154 4
a157 2
			if (!allmatches)
				return(rval);
d165 1
a165 1
	return(rval);
d168 1
a168 1
void
@


1.10
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.9 2003/06/03 01:52:41 millert Exp $	*/
d10 7
a16 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: which.c,v 1.9 2003/06/03 01:52:41 millert Exp $";
@


1.9
log
@Use an ISC-tyle license for all my code; it is simpler and more permissive.
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.8 2003/04/04 03:25:28 millert Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: which.c,v 1.8 2003/04/04 03:25:28 millert Exp $";
d54 1
a54 1
main(int argc, char **argv)
@


1.8
log
@snprintf() is simpler than multiple strlcpy() and manual fiddling.
Also convert to C89 while I'm at it.
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.6 2002/02/16 21:27:59 millert Exp $	*/
a4 1
 * All rights reserved.
d6 3
a8 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: which.c,v 1.6 2002/02/16 21:27:59 millert Exp $";
@


1.7
log
@snprintf & strlcpy; tedu ok
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: which.c,v 1.6 2002/02/16 21:27:59 millert Exp $";
d65 1
a65 3
main(argc, argv)
	int argc;
	char **argv;
d124 1
a124 5
findprog(prog, path, progmode, allmatches)
	char *prog;
	char *path;
	int progmode;
	int allmatches;
d159 1
a159 3
		(void)strlcpy(filename, p, sizeof filename);
		filename[plen] = '/';
		(void)strlcpy(filename + plen + 1, prog, sizeof filename - (plen + 1));
d177 1
a177 1
usage()
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.5 1998/06/21 22:14:05 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: which.c,v 1.5 1998/06/21 22:14:05 millert Exp $";
d165 1
a165 1
		(void)strcpy(filename, p);
d167 1
a167 1
		(void)strcpy(filename + plen + 1, prog);
@


1.5
log
@Remove the advertising clause in my old license, it impedes free use
of the code as a large number of similar clauses makes it impossible
to write an ad for a product using the code...
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.4 1998/05/07 19:12:20 deraadt Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: which.c,v 1.4 1998/05/07 19:12:20 deraadt Exp $";
d51 2
a52 2
int findprog __P((char *, char *, int, int));
void usage __P((void));
@


1.4
log
@fix err() use
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.3 1998/01/28 17:18:53 millert Exp $	*/
d15 1
a15 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Todd C. Miller.
 * 4. The name of the author may not be used to endorse or promote products
d31 1
a31 1
static char rcsid[] = "$OpenBSD: which.c,v 1.3 1998/01/28 17:18:53 millert Exp $";
@


1.3
log
@Add -a flag.  Idea from bgrayson@@ece.utexas.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.2 1997/04/08 02:44:07 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: which.c,v 1.2 1997/04/08 02:44:07 millert Exp $";
d103 1
a103 1
			err(-1, "unable to get length of user.cs_path");
d105 1
a105 1
			errx(-1, "user.cs_path was zero length!");
d107 1
a107 1
			errx(-1, "can't allocate memory.");
d109 1
a109 1
			err(-1, "unable to get user.cs_path");
d112 1
a112 1
			err(-1, "can't get $PATH from environment");
d117 1
a117 1
		err(-1, "Can't set gid to %u", getegid());
d119 1
a119 1
		err(-1, "Can't set uid to %u", geteuid());
d152 1
a152 1
		errx(-1, "Can't allocate memory.");
@


1.2
log
@which(1) and whereis(1) are now the same program (hard linked).
@
text
@d1 1
a1 1
/*	$OpenBSD: which.c,v 1.1 1997/02/21 18:35:00 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: which.c,v 1.1 1997/02/21 18:35:00 millert Exp $";
d54 1
a54 1
int findprog __P((char *, char *, int));
d74 1
a74 1
	int ch, notfound = 0, progmode = PROG_WHICH;
d82 1
a82 1
	while ((ch = getopt(argc, argv, "")) != -1) {
d84 3
d121 2
a122 2
	for (n = 1; n < argc; n++)
		if (findprog(argv[n], path, progmode) == 0)
d129 1
a129 1
findprog(prog, path, progmode)
d133 1
d136 1
a136 1
	int proglen, plen;
d174 3
a176 1
			return(1);
d182 1
a182 1
	if (progmode != PROG_WHEREIS)
d184 1
a184 1
	return(0);
d190 1
a190 1
	(void) fprintf(stderr, "Usage: %s name [...]\n", __progname);
@


1.1
log
@which(1) is now a binary that works in any shell since csh(1) has a
which built-in.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.2 1997/01/03 22:49:22 millert Exp $";
d39 1
d49 3
d54 1
a54 1
int which __P((char *, char *));
d59 1
d73 2
a74 1
	int n, notfound = 0;
d81 30
a110 2
	if ((path = getenv("PATH")) == NULL)
		err(-1, "Can't get $PATH from environment");
d119 1
a119 1
		if (which(argv[n], path) == 0)
d126 1
a126 1
which(prog, path)
d129 1
d148 1
a148 1
		errx(1, "Can't allocate memory.");
d175 3
a177 1
	(void)printf("%s: Command not found.\n", prog);
d184 1
a184 1
	(void) fprintf(stderr, "Usage: %s [name ...]\n", __progname);
@
