head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.8
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.6
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.13.0.18
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.16
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.12
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.12
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.8
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.6
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.14
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.12
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.10
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.10
	OPENBSD_2_8:1.3.0.8
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.05.23.10.31.42;	author schwarze;	state Exp;
branches;
next	1.17;
commitid	rPKQvMT0zs2LfVQm;

1.17
date	2015.10.09.01.37.07;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	sbrB3Q5CNxcwZpfU;

1.16
date	2015.10.05.06.26.33;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	xQ6sYWcgKReCWXJd;

1.15
date	2015.02.06.09.10.55;	author tedu;	state Exp;
branches;
next	1.14;
commitid	s6hkCTlqTgprkpRs;

1.14
date	2015.02.06.08.53.01;	author tedu;	state Exp;
branches;
next	1.13;
commitid	rBVPf1nqJLGHrXTm;

1.13
date	2010.10.22.14.11.22;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.27.23.59.38;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2007.04.07.23.20.18;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.26.22.22.50;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.25.21.19.19;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.10.22.20.46;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.03.02.56.08;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.17.07.06.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.09.21.59.02;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	99.02.07.21.40.49;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.33.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.15;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.15;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@UTF-8 support.

Using feedback about bugs in earlier versions from Matthew Martin
<phy1729 at gmail dot com> and from tsg@@ who tested it with afl(1).

OK czarkoff@@ tsg@@
@
text
@/*	$OpenBSD: fold.c,v 1.17 2015/10/09 01:37:07 deraadt Exp $	*/
/*	$NetBSD: fold.c,v 1.6 1995/09/01 01:42:44 jtc Exp $	*/

/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Kevin Ruddy.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#include <err.h>
#include <limits.h>
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <wchar.h>

#define	DEFLINEWIDTH	80

static void fold(unsigned int);
static int isu8cont(unsigned char);
static __dead void usage(void);

int count_bytes = 0;
int split_words = 0;

int
main(int argc, char *argv[])
{
	int ch, lastch, newarg, prevoptind;
	unsigned int width;
	const char *errstr;

	setlocale(LC_CTYPE, "");

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	width = 0;
	lastch = '\0';
	prevoptind = 1;
	newarg = 1;
	while ((ch = getopt(argc, argv, "0123456789bsw:")) != -1) {
		switch (ch) {
		case 'b':
			count_bytes = 1;
			break;
		case 's':
			split_words = 1;
			break;
		case 'w':
			width = strtonum(optarg, 1, UINT_MAX, &errstr);
			if (errstr != NULL)
				errx(1, "illegal width value, %s: %s", errstr, 
					optarg);
			break;
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			if (newarg)
				width = 0;
			else if (!isdigit(lastch))
				usage();
			if (width > UINT_MAX / 10 - 1)
				errx(1, "illegal width value, too large");
			width = (width * 10) + (ch - '0');
			if (width < 1)
				errx(1, "illegal width value, too small");
			break;
		default:
			usage();
		}
		lastch = ch;
		newarg = optind != prevoptind;
		prevoptind = optind;
	}
	argv += optind;
	argc -= optind;

	if (width == 0)
		width = DEFLINEWIDTH;

	if (!*argv) {
		if (pledge("stdio", NULL) == -1)
			err(1, "pledge");
		fold(width);
	} else {
		for (; *argv; ++argv) {
			if (!freopen(*argv, "r", stdin))
				err(1, "%s", *argv);
			else
				fold(width);
		}
	}
	return 0;
}

/*
 * Fold the contents of standard input to fit within WIDTH columns
 * (or bytes) and write to standard output.
 *
 * If split_words is set, split the line at the last space character
 * on the line.  This flag necessitates storing the line in a buffer
 * until the current column > width, or a newline or EOF is read.
 *
 * The buffer can grow larger than WIDTH due to backspaces and carriage
 * returns embedded in the input stream.
 */
static void
fold(unsigned int max_width)
{
	static char	*buf = NULL;
	static size_t	 bufsz = 2048;
	char		*cp;	/* Current mb character. */
	char		*np;	/* Next mb character. */
	char		*sp;	/* To search for the last space. */
	char		*nbuf;	/* For buffer reallocation. */
	wchar_t		 wc;	/* Current wide character. */
	int		 ch;	/* Last byte read. */
	int		 len;	/* Bytes in the current mb character. */
	unsigned int	 col;	/* Current display position. */
	int		 width; /* Display width of wc. */

	if (buf == NULL && (buf = malloc(bufsz)) == NULL)
		err(1, NULL);

	np = cp = buf;
	ch = 0;
	col = 0;

	while (ch != EOF) {  /* Loop on input characters. */
		while ((ch = getchar()) != EOF) {  /* Loop on input bytes. */
			if (np + 1 == buf + bufsz) {
				nbuf = reallocarray(buf, 2, bufsz);
				if (nbuf == NULL)
					err(1, NULL);
				bufsz *= 2;
				cp = nbuf + (cp - buf);
				np = nbuf + (np - buf);
				buf = nbuf;
			}
			*np++ = ch;

			/*
			 * Read up to and including the first byte of
			 * the next character, such that we are sure
			 * to have a complete character in the buffer.
			 * There is no need to read more than five bytes
			 * ahead, since UTF-8 characters are four bytes
			 * long at most.
			 */

			if (np - cp > 4 || (np - cp > 1 && !isu8cont(ch)))
				break;
		}

		while (cp < np) {  /* Loop on output characters. */

			/* Handle end of line and backspace. */

			if (*cp == '\n' || (*cp == '\r' && !count_bytes)) {
				fwrite(buf, 1, ++cp - buf, stdout);
				memmove(buf, cp, np - cp);
				np = buf + (np - cp);
				cp = buf;
				col = 0;
				continue;
			}
			if (*cp == '\b' && !count_bytes) {
				if (col)
					col--;
				cp++;
				continue;
			}

			/*
			 * Measure display width.
			 * Process the last byte only if
			 * end of file was reached.
			 */

			if (np - cp > (ch != EOF)) {
				len = 1;
				width = 1;

				if (*cp == '\t') {
					if (count_bytes == 0)
						width = 8 - (col & 7);
				} else if ((len = mbtowc(&wc, cp,
				    np - cp)) < 1)
					len = 1;
				else if (count_bytes)
					width = len;
				else if ((width = wcwidth(wc)) < 0)
					width = 1;

				col += width;
				if (col <= max_width || cp == buf) {
					cp += len;
					continue;
				}
			}

			/* Line break required. */

			if (col > max_width) {
				if (split_words) {
					for (sp = cp; sp > buf; sp--) {
						if (sp[-1] == ' ') {
							cp = sp;
							break;
						}
					}
				}
				fwrite(buf, 1, cp - buf, stdout);
				putchar('\n');
				memmove(buf, cp, np - cp);
				np = buf + (np - cp);
				cp = buf;
				col = 0;
				continue;
			}

			/* Need more input. */

			break;
		}
	}
	fwrite(buf, 1, np - buf, stdout);

	if (ferror(stdin))
		err(1, NULL);
}

static int
isu8cont(unsigned char c)
{
	return MB_CUR_MAX > 1 && (c & (0x80 | 0x40)) == 0x80;
}

static __dead void
usage(void)
{
	(void)fprintf(stderr, "usage: fold [-bs] [-w width] [file ...]\n");
	exit(1);
}
@


1.17
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.16 2015/10/05 06:26:33 deraadt Exp $	*/
d36 4
d44 1
a44 3
#include <ctype.h>
#include <err.h>
#include <limits.h>
d49 1
a49 1
static unsigned int new_column_position(unsigned int, int);
d51 1
d62 2
a117 1
				/* NOTREACHED */
d122 1
a122 1
	exit(0);
d137 1
a137 1
fold(unsigned int width)
d139 43
a181 13
	static char *buf = NULL;
	static int   buf_max = 0;
	int ch;
	unsigned int col, indx;

	col = indx = 0;
	while ((ch = getchar()) != EOF) {
		if (ch == '\n') {
			if (indx != 0)
				fwrite(buf, 1, indx, stdout);
			putchar('\n');
			col = indx = 0;
			continue;
d184 17
a200 8
		col = new_column_position(col, ch);
		if (col > width) {
			unsigned int i, last_space;

			if (split_words) {
				for (i = 0, last_space = -1; i < indx; i++)
					if(buf[i] == ' ')
						last_space = i;
d203 27
a229 2
			if (split_words && last_space != -1) {
				last_space++;
d231 1
a231 2
				fwrite(buf, 1, last_space, stdout);
				memmove(buf, buf+last_space, indx-last_space);
d233 14
a246 1
				indx -= last_space;
d248 1
a248 6
				for (i = 0; i < indx; i++) {
					col = new_column_position(col, buf[i]);
				}
			} else {
				fwrite(buf, 1, indx, stdout);
				col = indx = 0;
a249 1
			putchar('\n');
d251 1
a251 3
			/* calculate the column position for the next line. */
			col = new_column_position(col, ch);
		}
d253 1
a253 11
		if (indx + 1 > buf_max) {
			int newmax = buf_max + 2048;
			char *newbuf;

			/* Allocate buffer in LINE_MAX increments */
			if ((newbuf = realloc(buf, newmax)) == NULL) {
				err(1, NULL);
				/* NOTREACHED */
			}
			buf = newbuf;
			buf_max = newmax;
a254 1
		buf[indx++] = ch;
d256 1
d258 2
a259 2
	if (indx != 0)
		fwrite(buf, 1, indx, stdout);
d262 2
a263 5
/*
 * calculate the column position 
 */
static unsigned int
new_column_position(unsigned int col, int ch)
d265 1
a265 21
	if (!count_bytes) {
		switch (ch) {
		case '\b':
			if (col > 0)
				--col;
			break;
		case '\r':
			col = 0;
			break;
		case '\t':
			col = (col + 8) & ~7;
			break;
		default:
			++col;
			break;
		}
	} else {
		++col;
	}

	return col;
@


1.16
log
@tame "stdio rpath" early on, but if we discover only stdin is being
operated on switch to tame "stdio".  Reformat a very ugly code block
without braces to squeeze the tame calls in.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.15 2015/02/06 09:10:55 tedu Exp $	*/
d59 2
a60 2
	if (tame("stdio rpath", NULL) == -1)
		err(1, "tame");
d106 2
a107 2
		if (tame("stdio", NULL) == -1)
			err(1, "tame");
@


1.15
log
@change the width types to unsigned. negative widths make no sense,
and as deraadt points out, monitors keep getting bigger. now supports
twice as many columns.
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.14 2015/02/06 08:53:01 tedu Exp $	*/
d59 3
d105 3
a107 1
	if (!*argv)
d109 9
a117 6
	else for (; *argv; ++argv)
		if (!freopen(*argv, "r", stdin)) {
			err(1, "%s", *argv);
			/* NOTREACHED */
		} else
			fold(width);
@


1.14
log
@fix an integer overflow found by mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.13 2010/10/22 14:11:22 millert Exp $	*/
d46 2
a47 2
static void fold(int);
static int new_column_position(int, int);
d55 2
a56 1
	int ch, lastch, newarg, prevoptind, width;
d72 1
a72 1
			width = strtonum(optarg, 1, INT_MAX, &errstr);
d83 1
a83 1
			if (width > INT_MAX / 10 - 1)
d125 1
a125 1
fold(int width)
d129 2
a130 2
	int ch, col;
	int indx;
d144 1
a144 1
			int i, last_space;
d195 2
a196 2
static int
new_column_position(int col, int ch)
@


1.13
log
@Fix a crash when mixing the legacy width option (e.g. fold -70)
with getopt()-style options, such as "fold -b70".  Mixing the
legacy width with another option is no longer permitted.  This
matches legacy behavior and other implementations.  OK kili@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.12 2009/10/27 23:59:38 deraadt Exp $	*/
d82 1
a82 1
			if (width > INT_MAX / 10)
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.11 2007/04/07 23:20:18 tedu Exp $	*/
d40 1
d48 1
d55 1
a55 4
	int ch;
	int width;
	char *p;
	char *w;
d58 5
a62 2
	width = -1;
	while ((ch = getopt(argc, argv, "0123456789bsw:")) != -1)
d78 9
a86 12
			if (width == -1) {
				p = argv[optind - 1];
				if (p[0] == '-' && p[1] == ch && !p[2])
					w = ++p;
				else
					w = argv[optind] + 1;

				width = strtonum(w, 1, INT_MAX, &errstr);
				if (errstr != NULL)
					errx(1, "illegal width value, %s: %s", 
						errstr, optarg);
			}
d89 1
a89 3
			(void)fprintf(stderr,
			    "usage: fold [-bs] [-w width] [file ...]\n");
			exit(1);
d91 4
d98 1
a98 1
	if (width == -1)
d218 7
@


1.11
log
@use strtonum, from jason dixon
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.10 2003/09/26 22:22:50 tedu Exp $	*/
a34 13

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1990, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)fold.c	8.1 (Berkeley) 6/6/93";
#endif
static char rcsid[] = "$OpenBSD: fold.c,v 1.10 2003/09/26 22:22:50 tedu Exp $";
#endif /* not lint */
@


1.10
log
@better realloc.  ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.9 2003/06/25 21:19:19 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fold.c,v 1.9 2003/06/25 21:19:19 deraadt Exp $";
d54 1
d69 2
d82 4
a85 2
			if ((width = atoi(optarg)) <= 0)
				errx(1, "illegal width value.");
d92 1
a92 1
					width = atoi(++p);
d94 6
a99 1
					width = atoi(argv[optind] + 1);
@


1.9
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.8 2003/06/10 22:20:46 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fold.c,v 1.8 2003/06/10 22:20:46 deraadt Exp $";
d175 3
d179 1
a179 2
			buf_max += 2048;
			if((buf = realloc(buf, buf_max)) == NULL) {
d183 2
@


1.8
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.7 2003/06/03 02:56:08 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fold.c,v 1.7 2003/06/03 02:56:08 millert Exp $";
d57 2
a58 2
static void fold ();
static int new_column_position ();
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.6 2002/06/17 07:06:12 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fold.c,v 1.6 2002/06/17 07:06:12 deraadt Exp $";
d63 1
a63 3
main(argc, argv)
	int argc;
	char **argv;
d126 1
a126 2
fold(width)
	int width;
d193 1
a193 3
new_column_position(col, ch)
	int col;
	int ch;
@


1.6
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.6 2002/06/17 06:56:18 deraadt Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: fold.c,v 1.6 2002/06/17 06:56:18 deraadt Exp $";
@


1.5
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.4 2001/07/09 21:59:02 pjanzen Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fold.c,v 1.4 2001/07/09 21:59:02 pjanzen Exp $";
d113 1
a113 1
			err (1, "%s", *argv);
d144 1
a144 1
				fwrite (buf, 1, indx, stdout);
d150 1
a150 1
		col = new_column_position (col, ch);
d156 2
a157 1
					if(buf[i] == ' ') last_space = i;
d163 2
a164 2
				fwrite (buf, 1, last_space, stdout);
				memmove (buf, buf+last_space, indx-last_space);
d169 1
a169 1
					col = new_column_position (col, buf[i]);
d172 1
a172 1
				fwrite (buf, 1, indx, stdout);
d178 1
a178 1
			col = new_column_position (col, ch);
d184 2
a185 2
			if((buf = realloc (buf, buf_max)) == NULL) {
				err (1, NULL);
d193 1
a193 1
		fwrite (buf, 1, indx, stdout);
d200 1
a200 1
new_column_position (col, ch)
@


1.4
log
@use errx()
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.3 1999/02/07 21:40:49 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fold.c,v 1.3 1999/02/07 21:40:49 deraadt Exp $";
d71 1
a71 1
	register int ch;
d133 1
a133 1
	register int width;
d137 2
a138 2
	register int ch, col;
	register int indx;
@


1.3
log
@fix fold -s early break; helbig@@Informatik.BA-Stuttgart.DE
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.2 1996/06/26 05:33:23 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fold.c,v 1.2 1996/06/26 05:33:23 deraadt Exp $";
d85 2
a86 5
			if ((width = atoi(optarg)) <= 0) {
				(void)fprintf(stderr,
				    "fold: illegal width value.\n");
				exit(1);
			}
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: fold.c,v 1.6 1995/09/01 01:42:44 jtc Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: fold.c,v 1.6 1995/09/01 01:42:44 jtc Exp $";
d171 1
a171 1
					col = new_column_position (col, ch);
@


1.1
log
@Initial revision
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: fold.c,v 1.6 1995/09/01 01:42:44 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
