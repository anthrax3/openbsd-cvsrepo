head	1.32;
access;
symbols
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4;
locks; strict;
comment	@ * @;


1.32
date	2016.10.20.05.48.50;	author ratchov;	state Exp;
branches;
next	1.31;
commitid	AAH1hthatrdJTPIW;

1.31
date	2016.03.23.06.16.35;	author ratchov;	state Exp;
branches;
next	1.30;
commitid	VkSMySsfDNHeK23b;

1.30
date	2016.01.09.10.06.57;	author ratchov;	state Exp;
branches;
next	1.29;
commitid	BIs6fl3ZsJEj6Zk3;

1.29
date	2016.01.09.08.57.34;	author ratchov;	state Exp;
branches;
next	1.28;
commitid	L2THkuxK6QNb189w;

1.28
date	2016.01.08.16.17.31;	author ratchov;	state Exp;
branches;
next	1.27;
commitid	LWS9HDcDMBciqd8t;

1.27
date	2016.01.08.15.55.05;	author ratchov;	state Exp;
branches;
next	1.26;
commitid	QlkVeMc6evWf1RrZ;

1.26
date	2016.01.08.13.56.33;	author ratchov;	state Exp;
branches;
next	1.25;
commitid	NXcKgi8hXMjTZuMj;

1.25
date	2016.01.08.13.32.17;	author ratchov;	state Exp;
branches;
next	1.24;
commitid	Vj25FinizEYMkkZU;

1.24
date	2016.01.08.13.19.34;	author ratchov;	state Exp;
branches;
next	1.23;
commitid	L6Fx8ZdXjVYJpYFC;

1.23
date	2016.01.08.13.14.11;	author ratchov;	state Exp;
branches;
next	1.22;
commitid	8QDtrFXNKcGztDUI;

1.22
date	2015.12.23.20.12.18;	author ratchov;	state Exp;
branches;
next	1.21;
commitid	Qy0NYwsLYfoWief7;

1.21
date	2015.12.23.12.24.12;	author ratchov;	state Exp;
branches;
next	1.20;
commitid	zprKTtQZURU94pGc;

1.20
date	2015.12.23.12.20.24;	author ratchov;	state Exp;
branches;
next	1.19;
commitid	zr0jJgwJxvJE20U8;

1.19
date	2015.12.21.22.03.47;	author ratchov;	state Exp;
branches;
next	1.18;
commitid	bNjmDyo6yDzTC2yr;

1.18
date	2015.12.20.11.38.33;	author ratchov;	state Exp;
branches;
next	1.17;
commitid	PJvo9au8yzagFJ6z;

1.17
date	2015.11.26.12.35.37;	author ratchov;	state Exp;
branches;
next	1.16;
commitid	8aZXEuCMvj6m1kw6;

1.16
date	2015.11.24.12.14.08;	author ratchov;	state Exp;
branches;
next	1.15;
commitid	VBbw4aYkuIDvMtim;

1.15
date	2015.11.23.12.33.20;	author ratchov;	state Exp;
branches;
next	1.14;
commitid	F4CcdhviVx8ur3lv;

1.14
date	2015.11.23.12.01.04;	author ratchov;	state Exp;
branches;
next	1.13;
commitid	FswJqJ4QurxlFhoD;

1.13
date	2015.11.22.16.52.06;	author ratchov;	state Exp;
branches;
next	1.12;
commitid	zLgdqr3JCyua27AA;

1.12
date	2015.11.18.08.36.20;	author ratchov;	state Exp;
branches;
next	1.11;
commitid	IIXiV87F8cFgHqty;

1.11
date	2015.10.02.12.21.59;	author ratchov;	state Exp;
branches;
next	1.10;
commitid	YfdLYqEuVvQj3dNO;

1.10
date	2015.10.02.09.36.24;	author ratchov;	state Exp;
branches;
next	1.9;
commitid	pbuL5fcKBZxeBbqF;

1.9
date	2015.10.02.09.21.46;	author ratchov;	state Exp;
branches;
next	1.8;
commitid	CyAOR3wqXN7z8qK9;

1.8
date	2015.04.26.17.26.59;	author dcoppa;	state Exp;
branches;
next	1.7;
commitid	BupyfccP1H2u6MCN;

1.7
date	2015.01.16.06.40.12;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	Uu5nFG3wCl0LACBb;

1.6
date	2014.03.05.20.24.16;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2013.11.18.17.37.45;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2012.12.01.12.06.14;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2012.11.30.21.04.35;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2012.11.23.07.25.07;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2012.11.23.07.03.28;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Move initialization of the helper process in its own routine to make
code more readable. No bahavior change.
@
text
@/*	$OpenBSD$	*/
/*
 * Copyright (c) 2008-2012 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/socket.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <grp.h>
#include <limits.h>
#include <pwd.h>
#include <signal.h>
#include <sndio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "amsg.h"
#include "defs.h"
#include "dev.h"
#include "fdpass.h"
#include "file.h"
#include "listen.h"
#include "midi.h"
#include "opt.h"
#include "sock.h"
#include "utils.h"

/*
 * unprivileged user name
 */
#ifndef SNDIO_USER
#define SNDIO_USER	"_sndio"
#endif

/*
 * privileged user name
 */
#ifndef SNDIO_PRIV_USER
#define SNDIO_PRIV_USER	"_sndiop"
#endif

/*
 * priority when run as root
 */
#ifndef SNDIO_PRIO
#define SNDIO_PRIO	(-20)
#endif

/*
 * sample rate if no ``-r'' is used
 */
#ifndef DEFAULT_RATE
#define DEFAULT_RATE	48000
#endif

/*
 * block size if neither ``-z'' nor ``-b'' is used
 */
#ifndef DEFAULT_ROUND
#define DEFAULT_ROUND	960
#endif

/*
 * buffer size if neither ``-z'' nor ``-b'' is used
 */
#ifndef DEFAULT_BUFSZ
#define DEFAULT_BUFSZ	7680
#endif

/*
 * default device in server mode
 */
#ifndef DEFAULT_DEV
#define DEFAULT_DEV "rsnd/0"
#endif

void sigint(int);
void opt_ch(int *, int *);
void opt_enc(struct aparams *);
int opt_mmc(void);
int opt_onoff(void);
int getword(char *, char **);
unsigned int opt_mode(void);
void getbasepath(char *);
void setsig(void);
void unsetsig(void);
struct dev *mkdev(char *, struct aparams *,
    int, int, int, int, int, int);
struct port *mkport(char *, int);
struct opt *mkopt(char *, struct dev *,
    int, int, int, int, int, int, int, int);

unsigned int log_level = 0;
volatile sig_atomic_t quit_flag = 0;

char usagestr[] = "usage: sndiod [-d] [-a flag] [-b nframes] "
    "[-C min:max] [-c min:max] [-e enc]\n\t"
    "[-f device] [-j flag] [-L addr] [-m mode] [-q port] [-r rate]\n\t"
    "[-s name] [-t mode] [-U unit] [-v volume] [-w flag] [-z nframes]\n";

/*
 * SIGINT handler, it raises the quit flag. If the flag is already set,
 * that means that the last SIGINT was not handled, because the process
 * is blocked somewhere, so exit.
 */
void
sigint(int s)
{
	if (quit_flag)
		_exit(1);
	quit_flag = 1;
}

void
opt_ch(int *rcmin, int *rcmax)
{
	char *next, *end;
	long cmin, cmax;

	errno = 0;
	cmin = strtol(optarg, &next, 10);
	if (next == optarg || *next != ':')
		goto failed;
	cmax = strtol(++next, &end, 10);
	if (end == next || *end != '\0')
		goto failed;
	if (cmin < 0 || cmax < cmin || cmax >= NCHAN_MAX)
		goto failed;
	*rcmin = cmin;
	*rcmax = cmax;
	return;
failed:
	errx(1, "%s: bad channel range", optarg);
}

void
opt_enc(struct aparams *par)
{
	int len;

	len = aparams_strtoenc(par, optarg);
	if (len == 0 || optarg[len] != '\0')
		errx(1, "%s: bad encoding", optarg);
}

int
opt_mmc(void)
{
	if (strcmp("off", optarg) == 0)
		return 0;
	if (strcmp("slave", optarg) == 0)
		return 1;
	errx(1, "%s: off/slave expected", optarg);
}

int
opt_onoff(void)
{
	if (strcmp("off", optarg) == 0)
		return 0;
	if (strcmp("on", optarg) == 0)
		return 1;
	errx(1, "%s: on/off expected", optarg);
}

int
getword(char *word, char **str)
{
	char *p = *str;

	for (;;) {
		if (*word == '\0')
			break;
		if (*word++ != *p++)
			return 0;
	}
	if (*p == ',' || *p == '\0') {
		*str = p;
		return 1;
	}
	return 0;
}

unsigned int
opt_mode(void)
{
	unsigned int mode = 0;
	char *p = optarg;

	for (;;) {
		if (getword("play", &p)) {
			mode |= MODE_PLAY;
		} else if (getword("rec", &p)) {
			mode |= MODE_REC;
		} else if (getword("mon", &p)) {
			mode |= MODE_MON;
		} else if (getword("midi", &p)) {
			mode |= MODE_MIDIMASK;
		} else
			errx(1, "%s: bad mode", optarg);
		if (*p == '\0')
			break;
		p++;
	}
	if (mode == 0)
		errx(1, "empty mode");
	return mode;
}

void
setsig(void)
{
	struct sigaction sa;

	quit_flag = 0;
	sigfillset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = sigint;
	if (sigaction(SIGINT, &sa, NULL) < 0)
		err(1, "sigaction(int) failed");
	if (sigaction(SIGTERM, &sa, NULL) < 0)
		err(1, "sigaction(term) failed");
	if (sigaction(SIGHUP, &sa, NULL) < 0)
		err(1, "sigaction(hup) failed");
}

void
unsetsig(void)
{
	struct sigaction sa;

	sigfillset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = SIG_DFL;
	if (sigaction(SIGHUP, &sa, NULL) < 0)
		err(1, "unsetsig(hup): sigaction failed");
	if (sigaction(SIGTERM, &sa, NULL) < 0)
		err(1, "unsetsig(term): sigaction failed");
	if (sigaction(SIGINT, &sa, NULL) < 0)
		err(1, "unsetsig(int): sigaction failed");
}

void
getbasepath(char *base)
{
	uid_t uid;
	struct stat sb;
	mode_t mask, omask;

	uid = geteuid();
	if (uid == 0) {
		mask = 022;
		snprintf(base, SOCKPATH_MAX, SOCKPATH_DIR);
	} else {
		mask = 077;
		snprintf(base, SOCKPATH_MAX, SOCKPATH_DIR "-%u", uid);
	}
	omask = umask(mask);
	if (mkdir(base, 0777) < 0) {
		if (errno != EEXIST)
			err(1, "mkdir(\"%s\")", base);
	}
	umask(omask);
	if (stat(base, &sb) < 0)
		err(1, "stat(\"%s\")", base);
	if (!S_ISDIR(sb.st_mode))
		errx(1, "%s is not a directory", base);
	if (sb.st_uid != uid || (sb.st_mode & mask) != 0)
		errx(1, "%s has wrong permissions", base);
}

struct dev *
mkdev(char *path, struct aparams *par,
    int mode, int bufsz, int round, int rate, int hold, int autovol)
{
	struct dev *d;

	for (d = dev_list; d != NULL; d = d->next) {
		if (strcmp(d->path, path) == 0)
			return d;
	}
	if (!bufsz && !round) {
		round = DEFAULT_ROUND;
		bufsz = DEFAULT_BUFSZ;
	} else if (!bufsz) {
		bufsz = round * 2;
	} else if (!round)
		round = bufsz / 2;
	d = dev_new(path, par, mode, bufsz, round, rate, hold, autovol);
	if (d == NULL)
		exit(1);
	return d;
}

struct port *
mkport(char *path, int hold)
{
	struct port *c;

	for (c = port_list; c != NULL; c = c->next) {
		if (strcmp(c->path, path) == 0)
			return c;
	}
	c = port_new(path, MODE_MIDIMASK, hold);
	if (c == NULL)
		exit(1);
	return c;
}

struct opt *
mkopt(char *path, struct dev *d,
    int pmin, int pmax, int rmin, int rmax,
    int mode, int vol, int mmc, int dup)
{
	struct opt *o;

	o = opt_new(path, d, pmin, pmax, rmin, rmax,
	    MIDI_TO_ADATA(vol), mmc, dup, mode);
	if (o == NULL)
		return NULL;
	dev_adjpar(d, o->mode, o->pmax, o->rmax);
	return o;
}

static int
start_helper(int background)
{
	struct passwd *pw;
	int s[2];
	pid_t pid;

	if (geteuid() == 0) {
		if ((pw = getpwnam(SNDIO_PRIV_USER)) == NULL)
			errx(1, "unknown user %s", SNDIO_PRIV_USER);
	} else
		pw = NULL;
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, s) < 0) {
		perror("socketpair");
		return 0;
	}
	pid = fork();
	if (pid	== -1) {
		log_puts("can't fork\n");
		return 0;
	}
	if (pid == 0) {
		setproctitle("helper");
		close(s[0]);
		if (fdpass_new(s[1], &helper_fileops) == NULL)
			return 0;
		if (background) {
			log_flush();
			log_level = 0;
			if (daemon(0, 0) < 0)
				err(1, "daemon");
		}
		if (pw != NULL) {
			if (setgroups(1, &pw->pw_gid) ||
			    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
			    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
				err(1, "cannot drop privileges");
		}
		if (pledge("stdio sendfd rpath wpath", NULL) < 0)
			err(1, "pledge");
		while (file_poll())
			; /* nothing */
		exit(0);
	} else {
		close(s[1]);
		if (fdpass_new(s[0], &worker_fileops) == NULL)
			return 0;
	}
	return 1;
}

static void
stop_helper(void)
{
	if (fdpass_peer)
		fdpass_close(fdpass_peer);
}

int
main(int argc, char **argv)
{
	int c, background, unit;
	int pmin, pmax, rmin, rmax;
	char base[SOCKPATH_MAX], path[SOCKPATH_MAX];
	unsigned int mode, dup, mmc, vol;
	unsigned int hold, autovol, bufsz, round, rate;
	const char *str;
	struct aparams par;
	struct dev *d;
	struct port *p;
	struct listen *l;
	struct passwd *pw;
	struct tcpaddr {
		char *host;
		struct tcpaddr *next;
	} *tcpaddr_list, *ta;

	atexit(log_flush);

	/*
	 * global options defaults
	 */
	vol = 118;
	dup = 1;
	mmc = 0;
	hold = 0;
	autovol = 1;
	bufsz = 0;
	round = 0;
	rate = DEFAULT_RATE;
	unit = 0;
	background = 1;
	pmin = 0;
	pmax = 1;
	rmin = 0;
	rmax = 1;
	aparams_init(&par);
	mode = MODE_PLAY | MODE_REC;
	tcpaddr_list = NULL;

	while ((c = getopt(argc, argv, "a:b:c:C:de:f:j:L:m:q:r:s:t:U:v:w:x:z:")) != -1) {
		switch (c) {
		case 'd':
			log_level++;
			background = 0;
			break;
		case 'U':
			unit = strtonum(optarg, 0, 15, &str);
			if (str)
				errx(1, "%s: unit number is %s", optarg, str);
			break;
		case 'L':
			ta = xmalloc(sizeof(struct tcpaddr));
			ta->host = optarg;
			ta->next = tcpaddr_list;
			tcpaddr_list = ta;
			break;
		case 'm':
			mode = opt_mode();
			break;
		case 'j':
			dup = opt_onoff();
			break;
		case 't':
			mmc = opt_mmc();
			break;
		case 'c':
			opt_ch(&pmin, &pmax);
			break;
		case 'C':
			opt_ch(&rmin, &rmax);
			break;
		case 'e':
			opt_enc(&par);
			break;
		case 'r':
			rate = strtonum(optarg, RATE_MIN, RATE_MAX, &str);
			if (str)
				errx(1, "%s: rate is %s", optarg, str);
			break;
		case 'v':
			vol = strtonum(optarg, 0, MIDI_MAXCTL, &str);
			if (str)
				errx(1, "%s: volume is %s", optarg, str);
			break;
		case 's':
			if ((d = dev_list) == NULL) {
				d = mkdev(DEFAULT_DEV, &par, 0, bufsz, round,
				    rate, hold, autovol);
			}
			if (mkopt(optarg, d, pmin, pmax, rmin, rmax,
				mode, vol, mmc, dup) == NULL)
				return 1;
			break;
		case 'q':
			mkport(optarg, hold);
			break;
		case 'a':
			hold = opt_onoff();
			break;
		case 'w':
			autovol = opt_onoff();
			break;
		case 'b':
			bufsz = strtonum(optarg, 1, RATE_MAX, &str);
			if (str)
				errx(1, "%s: buffer size is %s", optarg, str);
			break;
		case 'z':
			round = strtonum(optarg, 1, SHRT_MAX, &str);
			if (str)
				errx(1, "%s: block size is %s", optarg, str);
			break;
		case 'f':
			mkdev(optarg, &par, 0, bufsz, round,
			    rate, hold, autovol);
			break;
		default:
			fputs(usagestr, stderr);
			return 1;
		}
	}
	argc -= optind;
	argv += optind;
	if (argc > 0) {
		fputs(usagestr, stderr);
		return 1;
	}
	if (dev_list == NULL)
		mkdev(DEFAULT_DEV, &par, 0, bufsz, round, rate, hold, autovol);
	for (d = dev_list; d != NULL; d = d->next) {
		if (opt_byname("default", d->num))
			continue;
		if (mkopt("default", d, pmin, pmax, rmin, rmax,
			mode, vol, mmc, dup) == NULL)
			return 1;
	}

	setsig();
	filelist_init();

	if (!start_helper(background))
		return 1;

	if (geteuid() == 0) {
		if ((pw = getpwnam(SNDIO_USER)) == NULL)
			errx(1, "unknown user %s", SNDIO_USER);
	} else
		pw = NULL;
	getbasepath(base);
	snprintf(path, SOCKPATH_MAX, "%s/" SOCKPATH_FILE "%u", base, unit);
	if (!listen_new_un(path))
		return 1;
	for (ta = tcpaddr_list; ta != NULL; ta = ta->next) {
		if (!listen_new_tcp(ta->host, AUCAT_PORT + unit))
			return 1;
	}
	for (l = listen_list; l != NULL; l = l->next) {
		if (!listen_init(l))
			return 1;
	}
	midi_init();
	for (p = port_list; p != NULL; p = p->next) {
		if (!port_init(p))
			return 1;
	}
	for (d = dev_list; d != NULL; d = d->next) {
		if (!dev_init(d))
			return 1;
	}
	if (background) {
		log_flush();
		log_level = 0;
		if (daemon(0, 0) < 0)
			err(1, "daemon");
	}
	if (pw != NULL) {
		if (setpriority(PRIO_PROCESS, 0, SNDIO_PRIO) < 0)
			err(1, "setpriority");
		if (chroot(pw->pw_dir) != 0 || chdir("/") != 0)
			err(1, "cannot chroot to %s", pw->pw_dir);
		if (setgroups(1, &pw->pw_gid) ||
		    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
			err(1, "cannot drop privileges");
	}
	if (tcpaddr_list) {
		if (pledge("stdio audio recvfd unix inet", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio audio recvfd unix", NULL) == -1)
			err(1, "pledge");
	}
	for (;;) {
		if (quit_flag)
			break;
		if (!fdpass_peer)
			break;
		if (!file_poll())
			break;
	}
	stop_helper();
	while (listen_list != NULL)
		listen_close(listen_list);
	while (sock_list != NULL)
		sock_close(sock_list);
	for (d = dev_list; d != NULL; d = d->next)
		dev_done(d);
	for (p = port_list; p != NULL; p = p->next)
		port_done(p);
	while (file_poll())
		; /* nothing */
	midi_done();

	while (opt_list != NULL)
		opt_del(opt_list);
	while (dev_list)
		dev_del(dev_list);
	while (port_list)
		port_del(port_list);
	while (tcpaddr_list) {
		ta = tcpaddr_list;
		tcpaddr_list = ta->next;
		xfree(ta);
	}
	filelist_done();
	unsetsig();
	return 0;
}
@


1.31
log
@Remove unused arguments of dev_adjpar(), getbasepath() and all
slotops->onvol() implementations. From David CARLIER <devnexen at
gmail.com>. Thanks.
@
text
@d343 58
a418 5
	int s[2];
	pid_t pid;
	uid_t euid, hpw_uid, wpw_uid;
	gid_t hpw_gid, wpw_gid;
	char *wpw_dir;
d544 4
a547 6
	euid = geteuid();
	if (euid == 0) {
		if ((pw = getpwnam(SNDIO_PRIV_USER)) == NULL)
			errx(1, "unknown user %s", SNDIO_PRIV_USER);
		hpw_uid = pw->pw_uid;
		hpw_gid = pw->pw_gid;
d550 9
a558 6
		wpw_uid = pw->pw_uid;
		wpw_gid = pw->pw_gid;
		wpw_dir = xstrdup(pw->pw_dir);
	} else {
		hpw_uid = wpw_uid = hpw_gid = wpw_gid = 0xdeadbeef;
		wpw_dir = NULL;
d560 3
a562 6

	/* start subprocesses */

	if (socketpair(AF_UNIX, SOCK_STREAM, 0, s) < 0) {
		perror("socketpair");
		return 1;
d564 4
a567 4
	pid = fork();
	if (pid	== -1) {
		log_puts("can't fork\n");
		return 1;
d569 2
a570 4
	if (pid == 0) {
		setproctitle("helper");
		close(s[0]);
		if (fdpass_new(s[1], &helper_fileops) == NULL)
d572 19
a590 13
		if (background) {
			log_flush();
			log_level = 0;
			if (daemon(0, 0) < 0)
				err(1, "daemon");
		}
		if (euid == 0) {
			if (setgroups(1, &hpw_gid) ||
			    setresgid(hpw_gid, hpw_gid, hpw_gid) ||
			    setresuid(hpw_uid, hpw_uid, hpw_uid))
				err(1, "cannot drop privileges");
		}
		if (pledge("stdio sendfd rpath wpath", NULL) < 0)
a591 2
		while (file_poll())
			; /* nothing */
d593 23
a615 18
		close(s[1]);
		if (fdpass_new(s[0], &worker_fileops) == NULL)
			return 1;

		getbasepath(base);
		snprintf(path,
		    SOCKPATH_MAX, "%s/" SOCKPATH_FILE "%u",
		    base, unit);
		if (!listen_new_un(path))
			return 1;
		for (ta = tcpaddr_list; ta != NULL; ta = ta->next) {
			if (!listen_new_tcp(ta->host, AUCAT_PORT + unit))
				return 1;
		}
		for (l = listen_list; l != NULL; l = l->next) {
			if (!listen_init(l))
				return 1;
		}
a616 54
		midi_init();
		for (p = port_list; p != NULL; p = p->next) {
			if (!port_init(p))
				return 1;
		}
		for (d = dev_list; d != NULL; d = d->next) {
			if (!dev_init(d))
				return 1;
		}
		if (background) {
			log_flush();
			log_level = 0;
			if (daemon(0, 0) < 0)
				err(1, "daemon");
		}
		if (euid == 0) {
			if (setpriority(PRIO_PROCESS, 0, SNDIO_PRIO) < 0)
				err(1, "setpriority");
			if (chroot(wpw_dir) != 0 || chdir("/") != 0)
				err(1, "cannot chroot to %s", wpw_dir);
			if (setgroups(1, &wpw_gid) ||
			    setresgid(wpw_gid, wpw_gid, wpw_gid) ||
			    setresuid(wpw_uid, wpw_uid, wpw_uid))
				err(1, "cannot drop privileges");
		}
		if (tcpaddr_list) {
			if (pledge("stdio audio recvfd unix inet", NULL) == -1)
				err(1, "pledge");
		} else {
			if (pledge("stdio audio recvfd unix", NULL) == -1)
				err(1, "pledge");
		}
		for (;;) {
			if (quit_flag)
				break;
			if (!fdpass_peer)
				break;
			if (!file_poll())
				break;
		}
		if (fdpass_peer)
			fdpass_close(fdpass_peer);
		while (listen_list != NULL)
			listen_close(listen_list);
		while (sock_list != NULL)
			sock_close(sock_list);
		for (d = dev_list; d != NULL; d = d->next)
			dev_done(d);
		for (p = port_list; p != NULL; p = p->next)
			port_done(p);
		while (file_poll())
			; /* nothing */
		midi_done();
	}
@


1.30
log
@Check in advance that the socket path is a directory and report the
error if it isn't. Fixes ugly/delayed error messages in this case.
@
text
@d102 1
a102 1
void getbasepath(char *, size_t);
d262 1
a262 1
getbasepath(char *base, size_t size)
d339 1
a339 1
	dev_adjpar(d, o->mode, o->pmin, o->pmax, o->rmin, o->rmax);
d544 1
a544 1
		getbasepath(base, sizeof(base));
@


1.29
log
@Remove trailing '\n' from strings passed to err(1)
@
text
@d284 2
@


1.28
log
@Make code fit in 80 columns, remove trailing spaces & tabs.
@
text
@d254 1
a254 1
		err(1, "unsetsig(hup): sigaction failed\n");
d256 1
a256 1
		err(1, "unsetsig(term): sigaction failed\n");
d258 1
a258 1
		err(1, "unsetsig(int): sigaction failed\n");
@


1.27
log
@move code to add a midi port in a new mkport() routine
@
text
@d281 1
a281 1
	umask(omask);	
d435 2
a436 2
				d = mkdev(DEFAULT_DEV, &par, 0, bufsz, round, rate,
				    hold, autovol);
d462 2
a463 1
			mkdev(optarg, &par, 0, bufsz, round, rate, hold, autovol);
d494 1
a494 1
		hpw_gid = pw->pw_gid;		
d498 1
a498 1
		wpw_gid = pw->pw_gid;		
@


1.26
log
@Make mkopt() return NULL on failure
@
text
@d107 1
d311 15
d443 1
a443 3
			p = port_new(optarg, MODE_MIDIMASK, hold);
			if (!p)
				errx(1, "%s: can't open port", optarg);
@


1.25
log
@Unbreak support for multiple -L options.
@
text
@d320 1
a320 1
		errx(1, "%s: couldn't create subdev", path);
d422 3
a424 2
			mkopt(optarg, d, pmin, pmax, rmin, rmax,
			    mode, vol, mmc, dup);
d466 3
a468 2
		mkopt("default", d, pmin, pmax, rmin, rmax,
		    mode, vol, mmc, dup);
@


1.24
log
@No need to include sys/queue.h
@
text
@d330 1
a330 1
	char base[SOCKPATH_MAX], path[SOCKPATH_MAX], *tcpaddr;
d339 4
d370 1
a370 1
	tcpaddr = NULL;
d384 4
a387 1
			tcpaddr = optarg;
d531 2
a532 2
		if (tcpaddr) {
			if (!listen_new_tcp(tcpaddr, AUCAT_PORT + unit))
d565 1
a565 1
		if (tcpaddr) {
d600 5
@


1.23
log
@Make listen_new_xxx() routines return NULL on failure and check the
returned value wheneverer they are called.
@
text
@a16 1
#include <sys/queue.h>
@


1.22
log
@Add pledge calls to both "helper" and "worker" processes.

ok deraadt, semarie
@
text
@d523 6
a528 3
		listen_new_un(path);
		if (tcpaddr)
			listen_new_tcp(tcpaddr, AUCAT_PORT + unit);
@


1.21
log
@fix false-positive "uninitialized" gcc warning
@
text
@d510 2
d555 7
@


1.20
log
@Call getpwname() earlier, and if it fails, return the proper
exit code, so that the failure gets reported by /etc/rc.
@
text
@d478 2
a479 3
		//hpw_uid = wpw_uid = 0;
		//hpw_gid = wpw_gid = 0;
		//wpw_dir = NULL;
@


1.19
log
@Don't attempt to remove unix socket as it's owned by root and
we've already dropped root privileges.
@
text
@d342 3
d466 17
d505 4
a508 6
		if (geteuid() == 0) {
			if ((pw = getpwnam(SNDIO_PRIV_USER)) == NULL)
				errx(1, "unknown user %s", SNDIO_PRIV_USER);
			if (setgroups(1, &pw->pw_gid) ||
			    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
			    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
d545 1
a545 3
		if (geteuid() == 0) {
			if ((pw = getpwnam(SNDIO_USER)) == NULL)
				errx(1, "unknown user %s", SNDIO_USER);
d548 5
a552 5
			if (chroot(pw->pw_dir) != 0 || chdir("/") != 0)
				err(1, "cannot chroot to %s", pw->pw_dir);
			if (setgroups(1, &pw->pw_gid) ||
			    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
			    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
@


1.18
log
@In case of a bug in sndiod, an attacker (a local user) could run
arbitrary code as user _sndio, i.e. get a second uid.

Mitigate the risk by implementing initial privilege separation as
follows. Break sndiod in two processes: a chroot()ed "worker" process
processing input, and a non-chroot()ed "helper" process opening
devices and passing descriptors to the worker.

With help from benno, claudio, semarie and gilles.

ok benno, semarie and tb
@
text
@a559 2

		rmdir(base);
@


1.17
log
@Cleanup in the opposite order as initialization, inline privdrop()
function. No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sndiod.c,v 1.15 2015/11/23 12:33:20 ratchov Exp $	*/
d21 1
d39 1
d55 7
d340 2
d463 5
a467 9
	getbasepath(base, sizeof(base));
	snprintf(path, SOCKPATH_MAX, "%s/" SOCKPATH_FILE "%u", base, unit);
	listen_new_un(path);
	if (tcpaddr) {
#ifdef USE_TCP
		listen_new_tcp(tcpaddr, AUCAT_PORT + unit);
#else
		errx(1, "-L option disabled at compilation time");
#endif
d469 4
a472 14
	if (geteuid() == 0) {
		if ((pw = getpwnam(SNDIO_USER)) == NULL)
			errx(1, "unknown user %s", SNDIO_USER);
		if (setpriority(PRIO_PROCESS, 0, SNDIO_PRIO) < 0)
			err(1, "setpriority");
		if (setgroups(1, &pw->pw_gid) ||
		    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
			err(1, "cannot drop privileges");
	}
	midi_init();
	for (p = port_list; p != NULL; p = p->next) {
		if (!port_init(p))
			return 1;
d474 4
a477 2
	for (d = dev_list; d != NULL; d = d->next) {
		if (!dev_init(d))
d479 19
a497 3
	}
	for (l = listen_list; l != NULL; l = l->next) {
		if (!listen_init(l))
d499 63
a562 16
	if (background) {
		log_flush();
		log_level = 0;
		if (daemon(0, 0) < 0)
			err(1, "daemon");
	}
	for (;;) {
		if (quit_flag)
			break;
		if (!file_poll())
			break;
	}
	while (listen_list != NULL)
		listen_close(listen_list);
	while (sock_list != NULL)
		sock_close(sock_list);
a564 7
	for (d = dev_list; d != NULL; d = d->next)
		dev_done(d);
	for (p = port_list; p != NULL; p = p->next)
		port_done(p);
	midi_done();
	while (file_poll())
		; /* nothing */
a568 1
	rmdir(base);
@


1.16
log
@remove unused test when handling of -U option
@
text
@a96 1
void privdrop(void);
a278 15
void
privdrop(void)
{
	struct passwd *pw;

	if ((pw = getpwnam(SNDIO_USER)) == NULL)
		errx(1, "unknown user %s", SNDIO_USER);
	if (setpriority(PRIO_PROCESS, 0, SNDIO_PRIO) < 0)
		err(1, "setpriority");
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		err(1, "cannot drop privileges");
}

d330 1
a354 3
	setsig();
	filelist_init();

d448 4
d462 10
a471 2
	if (geteuid() == 0)
		privdrop();
a490 4

	/*
	 * Loop, start audio.
	 */
d514 1
a515 1
	rmdir(base);
@


1.15
log
@Remove unused -M option (2+ years get used to it is enough)
@
text
@d1 1
a1 1
/*	$OpenBSD: sndiod.c,v 1.14 2015/11/23 12:01:04 ratchov Exp $	*/
a379 2
			if (listen_list)
				errx(1, "-U must come before -L");
d471 1
a471 1
		listen_new_tcp(optarg, AUCAT_PORT + unit);
@


1.14
log
@Save and restore umask when creating /tmp/aucat/ to ensure the
directory gets the right permissions, as we do in other places.
@
text
@d1 1
a1 1
/*	$OpenBSD: sndiod.c,v 1.13 2015/11/22 16:52:06 ratchov Exp $	*/
d373 1
a373 1
	while ((c = getopt(argc, argv, "a:b:c:C:de:f:j:L:m:Mq:r:s:t:U:v:w:x:z:")) != -1) {
a447 3
			break;
		case 'M':
			/* XXX: for compatibility with aucat, remove this */
@


1.13
log
@Disallow multiple -L options and remove the constraint -U to
be used before -L. No behaviour change as -L is still disabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: sndiod.c,v 1.12 2015/11/18 08:36:20 ratchov Exp $	*/
d258 1
a258 1
	mode_t mask;
d268 2
a269 1
	if (mkdir(base, 0777 & ~mask) < 0) {
d273 1
@


1.12
log
@disable networking (i.e. -L option) until privilege separation is
implemented
@
text
@d1 1
a1 1
/*	$OpenBSD: sndiod.c,v 1.11 2015/10/02 12:21:59 ratchov Exp $	*/
d336 1
a336 1
	char base[SOCKPATH_MAX], path[SOCKPATH_MAX];
d366 1
d385 1
a385 5
#ifdef USE_TCP
			listen_new_tcp(optarg, AUCAT_PORT + unit);
#else
			errx(1, "-L option disabled at compilation time");
#endif
d472 7
@


1.11
log
@Replace %s in the format string, with its value (macro).
@
text
@d1 1
a1 1
/*	$OpenBSD: sndiod.c,v 1.10 2015/10/02 09:36:24 ratchov Exp $	*/
d384 1
d386 3
@


1.10
log
@As the socket path is known, use its size rather that PATH_MAX.
@
text
@d1 1
a1 1
/*	$OpenBSD: sndiod.c,v 1.9 2015/10/02 09:21:46 ratchov Exp $	*/
d469 1
a469 1
	snprintf(path, SOCKPATH_MAX, "%s/%s%u", base, SOCKPATH_FILE, unit);
@


1.9
log
@use macros instead of hard-coded strings for unix sockets paths
@
text
@d1 1
a1 1
/*	$OpenBSD: sndiod.c,v 1.8 2015/04/26 17:26:59 dcoppa Exp $	*/
d263 1
a263 1
		snprintf(base, PATH_MAX, SOCKPATH_DIR);
d266 1
a266 1
		snprintf(base, PATH_MAX, SOCKPATH_DIR "-%u", uid);
d336 1
a336 1
	char base[PATH_MAX], path[PATH_MAX];
d469 1
a469 1
	snprintf(path, PATH_MAX, "%s/%s%u", base, SOCKPATH_FILE, unit);
@


1.8
log
@
Fix typo in the buffer size value: 7680 in the manpage vs 7860 in
the sndiod.c code.
Initially, I thought the error was in the manpage, but Alexander
told me it was the code, so fix the code instead.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sndiod.c,v 1.7 2015/01/16 06:40:12 deraadt Exp $	*/
d263 1
a263 1
		snprintf(base, PATH_MAX, "/tmp/aucat");
d266 1
a266 1
		snprintf(base, PATH_MAX, "/tmp/aucat-%u", uid);
d469 1
a469 1
	snprintf(path, PATH_MAX, "%s/%s%u", base, AUCAT_PATH, unit);
@


1.7
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: sndiod.c,v 1.6 2014/03/05 20:24:16 ratchov Exp $	*/
d77 1
a77 1
#define DEFAULT_BUFSZ	7860
@


1.6
log
@remove unused "autostart" feature
@
text
@d1 1
a1 1
/*	$OpenBSD: sndiod.c,v 1.5 2013/11/18 17:37:45 ratchov Exp $	*/
a16 1
#include <sys/param.h>
@


1.5
log
@add missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: sndiod.c,v 1.4 2012/12/01 12:06:14 ratchov Exp $	*/
a481 2
		if (d->autostart && (d->mode & MODE_AUDIOMASK))
			dev_mmcstart(d);
@


1.4
log
@Parse "-m mode1,mode2,.. " strings strictly.
@
text
@d1 1
a1 1
/*	$OpenBSD: sndiod.c,v 1.3 2012/11/30 21:04:35 ratchov Exp $	*/
d87 16
@


1.3
log
@use the hold flag for midi ports as well
@
text
@d1 1
a1 1
/*	$OpenBSD: sndiod.c,v 1.2 2012/11/23 07:25:07 ratchov Exp $	*/
d161 18
a183 1
	size_t len;
d185 2
a186 3
	for (p = optarg; *p != '\0'; p++) {
		len = strcspn(p, ",");
		if (strncmp("play", p, len) == 0) {
d188 1
a188 1
		} else if (strncmp("rec", p, len) == 0) {
d190 1
a190 1
		} else if (strncmp("mon", p, len) == 0) {
d192 1
a192 1
		} else if (strncmp("midi", p, len) == 0) {
d194 1
a194 1
		} else 
a195 1
		p += len;
d198 1
d432 1
a432 1
			/* XXX: compatibility with aucat */
@


1.2
log
@add a -M flag that does nothing; allows setups with -M in sndiod_flags
to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: sndiod.c,v 1.1 2012/11/23 07:03:28 ratchov Exp $	*/
d392 1
a392 1
			p = port_new(optarg, MODE_MIDIMASK);
@


1.1
log
@Remplace aucat server by a new sndiod daemon aimed to be simpler
smaller and faster than aucat. It's a drop in replacement with the
following exceptions that don't affect the default setup:
  - The sample rate and the encoding are a per-device parameters
    thus -r and -e options must precede the corresponding -f option
  - MIDI thru boxes are dynamically created and no -M option
    is required anymore, so -M was removed.
  - MIDI ports are exposed with a new ``midi/N'' name, rather
    than abusing MIDI thru boxes.
with help from armani@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d339 1
a339 1
	while ((c = getopt(argc, argv, "a:b:c:C:de:f:j:L:m:q:r:s:t:U:v:w:x:z:")) != -1) {
d414 3
@

