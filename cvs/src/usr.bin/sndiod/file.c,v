head	1.23;
access;
symbols
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.14.0.2
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3;
locks; strict;
comment	@ * @;


1.23
date	2016.10.27.04.37.47;	author ratchov;	state Exp;
branches;
next	1.22;
commitid	1hTotz9iXHMP1ZS6;

1.22
date	2016.06.30.21.37.29;	author ratchov;	state Exp;
branches;
next	1.21;
commitid	rvwIw46ApGbbEXyN;

1.21
date	2016.05.25.05.37.12;	author ratchov;	state Exp;
branches;
next	1.20;
commitid	08x6cccLgo0fE3UU;

1.20
date	2016.01.18.11.41.13;	author ratchov;	state Exp;
branches;
next	1.19;
commitid	qyQ4brQgBvBtUjnY;

1.19
date	2016.01.08.16.17.31;	author ratchov;	state Exp;
branches;
next	1.18;
commitid	LWS9HDcDMBciqd8t;

1.18
date	2016.01.08.13.09.42;	author ratchov;	state Exp;
branches;
next	1.17;
commitid	ceMXGQEw9KmHLk0U;

1.17
date	2016.01.08.10.50.26;	author ratchov;	state Exp;
branches;
next	1.16;
commitid	x5Bn06X7PrVamc8D;

1.16
date	2016.01.08.10.44.15;	author ratchov;	state Exp;
branches;
next	1.15;
commitid	cvMrZDdlhoWC41KF;

1.15
date	2015.08.27.07.38.38;	author ratchov;	state Exp;
branches;
next	1.14;
commitid	pMuBxmSzLZg4I9gi;

1.14
date	2015.08.11.16.49.50;	author ratchov;	state Exp;
branches;
next	1.13;
commitid	ULKER5blI2BmXrAs;

1.13
date	2015.08.11.16.43.04;	author ratchov;	state Exp;
branches;
next	1.12;
commitid	EDXehqW5V940bcYV;

1.12
date	2015.08.01.10.47.30;	author ratchov;	state Exp;
branches;
next	1.11;
commitid	xnDJtx0utkvgZTYh;

1.11
date	2015.07.17.10.15.24;	author ratchov;	state Exp;
branches;
next	1.10;
commitid	5arPLZsc2Bs07miL;

1.10
date	2015.07.17.09.51.18;	author ratchov;	state Exp;
branches;
next	1.9;
commitid	XAaqsxFeShwLMVHY;

1.9
date	2015.07.17.09.43.28;	author ratchov;	state Exp;
branches;
next	1.8;
commitid	7r0VlLGyICD8RZci;

1.8
date	2015.07.17.09.37.07;	author ratchov;	state Exp;
branches;
next	1.7;
commitid	g8YUyCNmqxACWaLE;

1.7
date	2015.07.17.08.14.48;	author ratchov;	state Exp;
branches;
next	1.6;
commitid	HGC0b7WqbGxe2VnY;

1.6
date	2015.02.16.06.26.24;	author ratchov;	state Exp;
branches;
next	1.5;
commitid	SEurJCWOPAh9iUIn;

1.5
date	2014.03.17.17.17.01;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2013.11.18.17.37.45;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2013.02.01.09.06.27;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2012.12.07.08.04.58;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2012.11.23.07.03.28;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Fix many typos in comments, from Michael W. Bombardieri <mb at ii.net>
@
text
@/*	$OpenBSD: file.c,v 1.14 2015/08/11 16:49:50 ratchov Exp $	*/
/*
 * Copyright (c) 2008-2012 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * non-blocking file i/o module: each file can be read or written (or
 * both). To achieve non-blocking io, we simply use the poll() syscall
 * in an event loop and dispatch events to sub-modules.
 *
 * the module also provides trivial timeout implementation,
 * derived from:
 *
 * 	anoncvs@@moule.caoua.org:/midish
 *
 *		midish/timo.c rev 1.18
 * 		midish/mdep.c rev 1.71
 *
 * A timeout is used to schedule the call of a routine (the callback)
 * there is a global list of timeouts that is processed inside the
 * event loop. Timeouts work as follows:
 *
 *	first the timo structure must be initialized with timo_set()
 *
 *	then the timeout is scheduled (only once) with timo_add()
 *
 *	if the timeout expires, the call-back is called; then it can
 *	be scheduled again if needed. It's OK to reschedule it again
 *	from the callback
 *
 *	the timeout can be aborted with timo_del(), it is OK to try to
 *	abort a timout that has expired
 *
 */

#include <sys/types.h>

#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "file.h"
#include "utils.h"

#define MAXFDS 100
#define TIMER_MSEC 5

void timo_update(unsigned int);
void timo_init(void);
void timo_done(void);
void file_process(struct file *, struct pollfd *);

struct timespec file_ts;
struct file *file_list;
struct timo *timo_queue;
unsigned int timo_abstime;
int file_slowaccept = 0, file_nfds;
#ifdef DEBUG
long long file_wtime, file_utime;
#endif

/*
 * initialise a timeout structure, arguments are callback and argument
 * that will be passed to the callback
 */
void
timo_set(struct timo *o, void (*cb)(void *), void *arg)
{
	o->cb = cb;
	o->arg = arg;
	o->set = 0;
}

/*
 * schedule the callback in 'delta' 24-th of microseconds. The timeout
 * must not be already scheduled
 */
void
timo_add(struct timo *o, unsigned int delta)
{
	struct timo **i;
	unsigned int val;
	int diff;

#ifdef DEBUG
	if (o->set) {
		log_puts("timo_add: already set\n");
		panic();
	}
	if (delta == 0) {
		log_puts("timo_add: zero timeout is evil\n");
		panic();
	}
#endif
	val = timo_abstime + delta;
	for (i = &timo_queue; *i != NULL; i = &(*i)->next) {
		diff = (*i)->val - val;
		if (diff > 0) {
			break;
		}
	}
	o->set = 1;
	o->val = val;
	o->next = *i;
	*i = o;
}

/*
 * abort a scheduled timeout
 */
void
timo_del(struct timo *o)
{
	struct timo **i;

	for (i = &timo_queue; *i != NULL; i = &(*i)->next) {
		if (*i == o) {
			*i = o->next;
			o->set = 0;
			return;
		}
	}
#ifdef DEBUG
	if (log_level >= 4)
		log_puts("timo_del: not found\n");
#endif
}

/*
 * routine to be called by the timer when 'delta' 24-th of microsecond
 * elapsed. This routine updates time referece used by timeouts and
 * calls expired timeouts
 */
void
timo_update(unsigned int delta)
{
	struct timo *to;
	int diff;

	/*
	 * update time reference
	 */
	timo_abstime += delta;

	/*
	 * remove from the queue and run expired timeouts
	 */
	while (timo_queue != NULL) {
		/*
		 * there is no overflow here because + and - are
		 * modulo 2^32, they are the same for both signed and
		 * unsigned integers
		 */
		diff = timo_queue->val - timo_abstime;
		if (diff > 0)
			break;
		to = timo_queue;
		timo_queue = to->next;
		to->set = 0;
		to->cb(to->arg);
	}
}

/*
 * initialize timeout queue
 */
void
timo_init(void)
{
	timo_queue = NULL;
	timo_abstime = 0;
}

/*
 * destroy timeout queue
 */
void
timo_done(void)
{
#ifdef DEBUG
	if (timo_queue != NULL) {
		log_puts("timo_done: timo_queue not empty!\n");
		panic();
	}
#endif
	timo_queue = (struct timo *)0xdeadbeef;
}

#ifdef DEBUG
void
file_log(struct file *f)
{
	static char *states[] = { "ini", "zom" };

	log_puts(f->ops->name);
	if (log_level >= 3) {
		log_puts("(");
		log_puts(f->name);
		log_puts("|");
		log_puts(states[f->state]);
		log_puts(")");
	}
}
#endif

struct file *
file_new(struct fileops *ops, void *arg, char *name, unsigned int nfds)
{
	struct file *f;

	if (file_nfds + nfds > MAXFDS) {
#ifdef DEBUG
		if (log_level >= 1) {
			log_puts(name);
			log_puts(": too many polled files\n");
		}
#endif
		return NULL;
	}
	f = xmalloc(sizeof(struct file));
	f->max_nfds = nfds;
	f->ops = ops;
	f->arg = arg;
	f->name = name;
	f->state = FILE_INIT;
	f->next = file_list;
	file_list = f;
#ifdef DEBUG
	if (log_level >= 3) {
		file_log(f);
		log_puts(": created\n");
	}
#endif
	file_nfds += f->max_nfds;
	return f;
}

void
file_del(struct file *f)
{
#ifdef DEBUG
	if (f->state == FILE_ZOMB) {
		log_puts("bad state in file_del()\n");
		panic();
	}
#endif
	file_nfds -= f->max_nfds;
	f->state = FILE_ZOMB;
#ifdef DEBUG
	if (log_level >= 3) {
		file_log(f);
		log_puts(": destroyed\n");
	}
#endif
}

void
file_process(struct file *f, struct pollfd *pfd)
{
	int revents;
#ifdef DEBUG
	struct timespec ts0, ts1;
	long us;
#endif

#ifdef DEBUG
	if (log_level >= 3)
		clock_gettime(CLOCK_UPTIME, &ts0);
#endif
	revents = (f->state != FILE_ZOMB) ?
	    f->ops->revents(f->arg, pfd) : 0;
	if ((revents & POLLHUP) && (f->state != FILE_ZOMB))
		f->ops->hup(f->arg);
	if ((revents & POLLIN) && (f->state != FILE_ZOMB))
		f->ops->in(f->arg);
	if ((revents & POLLOUT) && (f->state != FILE_ZOMB))
		f->ops->out(f->arg);
#ifdef DEBUG
	if (log_level >= 3) {
		clock_gettime(CLOCK_UPTIME, &ts1);
		us = 1000000L * (ts1.tv_sec - ts0.tv_sec);
		us += (ts1.tv_nsec - ts0.tv_nsec) / 1000;
		if (log_level >= 4 || us >= 5000) {
			file_log(f);
			log_puts(": processed in ");
			log_putu(us);
			log_puts("us\n");
		}
	}
#endif
}

int
file_poll(void)
{
	struct pollfd pfds[MAXFDS], *pfd;
	struct file *f, **pf;
	struct timespec ts;
#ifdef DEBUG
	struct timespec sleepts;
	int i;
#endif
	long long delta_nsec;
	int nfds, res, timo;

	/*
	 * cleanup zombies
	 */
	pf = &file_list;
	while ((f = *pf) != NULL) {
		if (f->state == FILE_ZOMB) {
			*pf = f->next;
			xfree(f);
		} else
			pf = &f->next;
	}

	if (file_list == NULL && timo_queue == NULL) {
#ifdef DEBUG
		if (log_level >= 3)
			log_puts("nothing to do...\n");
#endif
		return 0;
	}

	/*
	 * fill pollfd structures
	 */
	nfds = 0;
	for (f = file_list; f != NULL; f = f->next) {
		f->nfds = f->ops->pollfd(f->arg, pfds + nfds);
		if (f->nfds == 0)
			continue;
		nfds += f->nfds;
	}
#ifdef DEBUG
	if (log_level >= 4) {
		log_puts("poll:");
		pfd = pfds;
		for (f = file_list; f != NULL; f = f->next) {
			log_puts(" ");
			log_puts(f->ops->name);
			log_puts(":");
			for (i = 0; i < f->nfds; i++) {
				log_puts(" ");
				log_putx(pfd->events);
				pfd++;
			}
		}
		log_puts("\n");
	}
#endif

	/*
	 * process files that do not rely on poll
	 */
	for (f = file_list; f != NULL; f = f->next) {
		if (f->nfds > 0)
			continue;
		file_process(f, NULL);
	}

	/*
	 * Sleep. Calculate the number of milliseconds poll(2) must
	 * wait before the timo_update() needs to be called. If there are
	 * no timeouts scheduled, then call poll(2) with infinite
	 * timeout (i.e -1).
	 */
#ifdef DEBUG
	clock_gettime(CLOCK_UPTIME, &sleepts);
	file_utime += 1000000000LL * (sleepts.tv_sec - file_ts.tv_sec);
	file_utime += sleepts.tv_nsec - file_ts.tv_nsec;
#endif
	if (timo_queue != NULL) {
		timo = ((int)timo_queue->val - (int)timo_abstime) / 1000;
		if (timo < TIMER_MSEC)
			timo = TIMER_MSEC;
	} else
		timo = -1;
	log_flush();
	res = poll(pfds, nfds, timo);
	if (res < 0) {
		if (errno != EINTR) {
			log_puts("poll failed");
			panic();
		}
		return 1;
	}

	/*
	 * run timeouts
	 */
	clock_gettime(CLOCK_UPTIME, &ts);
#ifdef DEBUG
	file_wtime += 1000000000LL * (ts.tv_sec - sleepts.tv_sec);
	file_wtime += ts.tv_nsec - sleepts.tv_nsec;
#endif
	if (timo_queue) {
		delta_nsec = 1000000000LL * (ts.tv_sec - file_ts.tv_sec);
		delta_nsec += ts.tv_nsec - file_ts.tv_nsec;
		if (delta_nsec >= 0 && delta_nsec < 60000000000LL)
			timo_update(delta_nsec / 1000);
		else {
			if (log_level >= 2)
				log_puts("out-of-bounds clock delta\n");
		}
	}
	file_ts = ts;

	/*
	 * process files that rely on poll
	 */
	pfd = pfds;
	for (f = file_list; f != NULL; f = f->next) {
		if (f->nfds == 0)
			continue;
		file_process(f, pfd);
		pfd += f->nfds;
	}
	return 1;
}

void
filelist_init(void)
{
	sigset_t set;

	if (clock_gettime(CLOCK_UPTIME, &file_ts) < 0) {
		log_puts("filelist_init: CLOCK_UPTIME unsupported\n");
		panic();
	}
	sigemptyset(&set);
	sigaddset(&set, SIGPIPE);
	sigprocmask(SIG_BLOCK, &set, NULL);
	file_list = NULL;
	log_sync = 0;
	timo_init();
}

void
filelist_done(void)
{
#ifdef DEBUG
	struct file *f;

	if (file_list != NULL) {
		for (f = file_list; f != NULL; f = f->next) {
			file_log(f);
			log_puts(" not closed\n");
		}
		panic();
	}
	log_sync = 1;
	log_flush();
#endif
	timo_done();
}
@


1.22
log
@Use CLOCK_UPTIME instead of CLOCK_MONOTONIC, as the later makes jumps
during suspend/resume cycles which triggers watchdog time-outs and
in turn prevents sndiod from resuming.
@
text
@d379 2
a380 2
	 * Sleep. Calculate the number off milliseconds poll(2) must
	 * wait before the timo_update() needs to be called. If there're
@


1.21
log
@Log files skipped during poll() as well, and flush the log buffer
right before we call poll().
@
text
@d283 1
a283 1
		clock_gettime(CLOCK_MONOTONIC, &ts0);
d295 1
a295 1
		clock_gettime(CLOCK_MONOTONIC, &ts1);
d385 1
a385 1
	clock_gettime(CLOCK_MONOTONIC, &sleepts);
d408 1
a408 1
	clock_gettime(CLOCK_MONOTONIC, &ts);
d443 2
a444 2
	if (clock_gettime(CLOCK_MONOTONIC, &file_ts) < 0) {
		log_puts("filelist_init: CLOCK_MONOTONIC unsupported\n");
@


1.20
log
@Allow time differences between two clock_gettime() calls to
be up to 60s without logging a warning.
@
text
@a320 2
	log_flush();

a355 2
			if (f->nfds == 0)
				continue;
d395 1
@


1.19
log
@Make code fit in 80 columns, remove trailing spaces & tabs.
@
text
@d419 1
a419 1
		if (delta_nsec >= 0 && delta_nsec < 1000000000LL)
@


1.18
log
@On programming error, flush log buffer and abort() rather than
calling exit().
@
text
@d261 1
a261 1
#endif	
d285 1
a285 1
	revents = (f->state != FILE_ZOMB) ? 
d426 1
a426 1
	file_ts = ts;	
@


1.17
log
@remove redundant debug message
@
text
@a48 1
#include <err.h>
d401 4
a404 2
		if (errno != EINTR)
			err(1, "poll");
d446 4
d451 2
a452 3
	(void)sigaddset(&set, SIGPIPE);
	if (sigprocmask(SIG_BLOCK, &set, NULL))
		err(1, "sigprocmask");
a453 4
	if (clock_gettime(CLOCK_MONOTONIC, &file_ts) < 0) {
		perror("clock_gettime");
		exit(1);
	}
@


1.16
log
@Don't calculate clock deltas is there are no time-outs. Removes (harmless)
warnings about out-of-bounds clock deltas.
@
text
@a417 4
#ifdef DEBUG
		if (delta_nsec < 0)
			log_puts("file_poll: negative time interval\n");
#endif
@


1.15
log
@backout previous for now, as it causes me portability problems
@
text
@d415 3
a417 2
	delta_nsec = 1000000000LL * (ts.tv_sec - file_ts.tv_sec);
	delta_nsec += ts.tv_nsec - file_ts.tv_nsec;
d419 2
a420 2
	if (delta_nsec < 0)
		log_puts("file_poll: negative time interval\n");
d422 6
a427 6
	file_ts = ts;
	if (delta_nsec >= 0 && delta_nsec < 1000000000LL)
		timo_update(delta_nsec / 1000);
	else {
		if (log_level >= 2)
			log_puts("ignored huge clock delta\n");
d429 1
@


1.14
log
@Use INTIM instead of -1 as poll(2) time-out argument.

Suggested by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.13 2015/08/11 16:43:04 ratchov Exp $	*/
d386 2
a387 1
	 * no timeouts scheduled, then call poll(2) with INFTIM timeout.
d399 1
a399 1
		timo = INFTIM;
@


1.13
log
@Don't call poll(2) with few millisecond time-out argument when -1
could be used. Avoids syscalls when the daemon is not being used.

Requested by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.12 2015/08/01 10:47:30 ratchov Exp $	*/
d386 1
a386 1
	 * no timeouts scheduled, then call poll(2) with -1 timeout.
d398 1
a398 1
		timo = -1;
@


1.12
log
@Move processing of polled files in its own function, and call it
twice: once for files that need immediate handling, and once for files
that would block. No behavior change.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.11 2015/07/17 10:15:24 ratchov Exp $	*/
d67 1
d320 1
a320 1
	int nfds, res;
d384 3
a386 1
	 * sleep
d393 7
a399 1
	res = poll(pfds, nfds, TIMER_MSEC);
@


1.11
log
@Use an offsets in the array of pollfd structures instead of pointers. No
behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.10 2015/07/17 09:51:18 ratchov Exp $	*/
d272 36
a315 2
	struct timespec ts0, ts1;
	long us;
d319 3
a321 1
	int nfds, revents, res, immed;
d343 3
a345 1
	log_flush();
a346 1
	immed = 0;
a350 4
		if (f->nfds < 0) {
			immed = 1;
			continue;
		}
d358 1
a358 1
			if (f->nfds <= 0)
d371 15
d390 3
a392 3
	if (!immed) {
		res = poll(pfds, nfds, TIMER_MSEC);
		if (res < 0 && errno != EINTR)
d394 6
a399 2
	} else
		res = 0;
d418 4
a421 2
	if (!immed && res <= 0)
		return 1;
d424 1
a424 1
		if (f->nfds <= 0)
d426 1
a426 25
#ifdef DEBUG
		if (log_level >= 3)
			clock_gettime(CLOCK_MONOTONIC, &ts0);
#endif
		revents = (f->state != FILE_ZOMB) ? 
		    f->ops->revents(f->arg, pfd) : 0;
		if ((revents & POLLHUP) && (f->state != FILE_ZOMB))
			f->ops->hup(f->arg);
		if ((revents & POLLIN) && (f->state != FILE_ZOMB))
			f->ops->in(f->arg);
		if ((revents & POLLOUT) && (f->state != FILE_ZOMB))
			f->ops->out(f->arg);
#ifdef DEBUG
		if (log_level >= 3) {
			clock_gettime(CLOCK_MONOTONIC, &ts1);
			us = 1000000L * (ts1.tv_sec - ts0.tv_sec);
			us += (ts1.tv_nsec - ts0.tv_nsec) / 1000;
			if (log_level >= 4 || us >= 5000) {
				file_log(f);
				log_puts(": processed in ");
				log_putu(us);
				log_puts("us\n");
			}
		}
#endif
@


1.10
log
@rename nfds to max_nfds, no object change
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.9 2015/07/17 09:43:28 ratchov Exp $	*/
d275 1
a275 1
	struct pollfd pfds[MAXFDS];
d285 1
a285 1
	int n, nfds, revents, res, immed;
d311 2
a312 3
		n = f->ops->pollfd(f->arg, pfds + nfds);
		if (n == 0) {
			f->pfd = NULL;
d314 1
a314 2
		}
		if (n < 0) {
d316 1
a316 1
			n = 0;
d318 1
a318 2
		f->pfd = pfds + nfds;
		nfds += n;
d323 4
a326 1
		for (i = 0; i < nfds; i++) {
d328 6
a333 5
			for (f = file_list; f != NULL; f = f->next) {
				if (f->pfd == &pfds[i]) {
					log_puts(f->ops->name);
					log_puts(": ");
				}
a334 1
			log_putx(pfds[i].events);
d368 1
a368 1

d370 1
a370 1
		if (f->pfd == NULL)
d377 1
a377 1
		    f->ops->revents(f->arg, f->pfd) : 0;
d397 1
@


1.9
log
@Move non-debug varibles outside #ifdef DEBUG block
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.8 2015/07/17 09:37:07 ratchov Exp $	*/
d236 1
a236 1
	f->nfds = nfds;
d249 1
a249 1
	file_nfds += f->nfds;
d262 1
a262 1
	file_nfds -= f->nfds;
@


1.8
log
@Simplify debug info: log poll descriptors on a single line, record
timestamps only when they are needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.7 2015/07/17 08:14:48 ratchov Exp $	*/
d282 1
a282 1
	int i, n, nfds;
d285 1
a285 1
	int revents, res, immed;
@


1.7
log
@Stop using interval timers (not inherited by fork(2), obsolete in
newer posix releases), use the poll(2) timeout parameter instead.
Fixes hangs during clean-up after the audio device is disconnected
or an unrecoverable error is detected. Suggested by and discussed
with millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.6 2015/02/16 06:26:24 ratchov Exp $	*/
a307 4
#ifdef DEBUG
	if (log_level >= 4) 
		log_puts("poll:");
#endif
a310 6
#ifdef DEBUG
		if (log_level >= 4) {
			log_puts(" ");
			file_log(f);
		}
#endif
d322 1
d324 9
a332 6
		if (log_level >= 4) {
			log_puts("=");
			for (i = 0; i < n; i++) {
				if (i > 0)
					log_puts(",");
				log_putx(f->pfd[i].events);
d334 1
d336 1
a336 1
#endif
a337 6
#ifdef DEBUG
	if (log_level >= 4)
		log_puts("\n");
#endif

#ifdef DEBUG
a345 10
#ifdef DEBUG
		if (log_level >= 4 && res >= 0) {
			log_puts("poll: return:");
			for (i = 0; i < nfds; i++) {
				log_puts(" ");
				log_putx(pfds[i].revents);
			}
			log_puts("\n");
		}
#endif
d373 2
a374 1
		clock_gettime(CLOCK_MONOTONIC, &ts0);
d385 10
a394 8
		clock_gettime(CLOCK_MONOTONIC, &ts1);
		us = 1000000L * (ts1.tv_sec - ts0.tv_sec);
		us += (ts1.tv_nsec - ts0.tv_nsec) / 1000;
		if (log_level >= 4 || (log_level >= 3 && us >= 5000)) {
			file_log(f);
			log_puts(": processed in ");
			log_putu(us);
			log_puts("us\n");
@


1.6
log
@Allow files to be skipped in the poll(2) event loop, in case
there are events already available (for immediate processing)
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.5 2014/03/17 17:17:01 ratchov Exp $	*/
a46 1
#include <sys/time.h>
d62 1
a62 1
#define TIMER_USEC 10000
a66 1
void file_sigalrm(int);
d354 1
a354 1
		res = poll(pfds, nfds, -1);
a418 10
/*
 * handler for SIGALRM, invoked periodically
 */
void
file_sigalrm(int i)
{
	/* nothing to do, we only want poll() to return EINTR */
}


a421 2
	static struct sigaction sa;
	struct itimerval it;
a432 15
        sa.sa_flags = SA_RESTART;
        sa.sa_handler = file_sigalrm;
        sigfillset(&sa.sa_mask);
        if (sigaction(SIGALRM, &sa, NULL) < 0) {
		perror("sigaction");
		exit(1);
	}
	it.it_interval.tv_sec = 0;
	it.it_interval.tv_usec = TIMER_USEC;
	it.it_value.tv_sec = 0;
	it.it_value.tv_usec = TIMER_USEC;
	if (setitimer(ITIMER_REAL, &it, NULL) < 0) {
		perror("setitimer");
		exit(1);
	}
a439 1
	struct itimerval it;
a452 6
	timerclear(&it.it_value);
	timerclear(&it.it_interval);
	if (setitimer(ITIMER_REAL, &it, NULL) < 0) {
		perror("setitimer");
		exit(1);
	}
@


1.5
log
@fix wrong file status strings
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.4 2013/11/18 17:37:45 ratchov Exp $	*/
a276 1
	nfds_t nfds, n;
d284 1
a284 1
	int i;
d287 1
a287 1
	int revents, res;
d315 1
d328 4
d355 12
a366 9
	res = poll(pfds, nfds, -1);
	if (res < 0 && errno != EINTR)
		err(1, "poll");
#ifdef DEBUG
	if (log_level >= 4) {
		log_puts("poll: return:");
		for (i = 0; i < nfds; i++) {
			log_puts(" ");
			log_putx(pfds[i].revents);
a367 2
		log_puts("\n");
	}
d369 2
d389 1
a389 1
	if (res <= 0)
@


1.4
log
@add missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.3 2013/02/01 09:06:27 ratchov Exp $	*/
d210 1
a210 1
	static char *states[] = { "ini", "bus", "clo", "zom" };
@


1.3
log
@if a device doesn't respond within two seconds, then just close it
and drop all connections. This is shameful but unfortunately it's
still necessery on certain MP machines and audio driver combinations
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.2 2012/12/07 08:04:58 ratchov Exp $	*/
d64 5
@


1.2
log
@move log_level in utils.h with other logging bits
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.1 2012/11/23 07:03:28 ratchov Exp $	*/
d386 2
a387 1
		revents = f->ops->revents(f->arg, f->pfd);
@


1.1
log
@Remplace aucat server by a new sndiod daemon aimed to be simpler
smaller and faster than aucat. It's a drop in replacement with the
following exceptions that don't affect the default setup:
  - The sample rate and the encoding are a per-device parameters
    thus -r and -e options must precede the corresponding -f option
  - MIDI thru boxes are dynamically created and no -M option
    is required anymore, so -M was removed.
  - MIDI ports are exposed with a new ``midi/N'' name, rather
    than abusing MIDI thru boxes.
with help from armani@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a58 1
#include "defs.h"
@

