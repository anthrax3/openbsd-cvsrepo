head	1.28;
access;
symbols
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.4
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.17.0.8
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4;
locks; strict;
comment	@ * @;


1.28
date	2017.02.15.21.28.23;	author ratchov;	state Exp;
branches;
next	1.27;
commitid	Ycbc6wfDBH9L7hPD;

1.27
date	2017.01.03.06.53.20;	author ratchov;	state Exp;
branches;
next	1.26;
commitid	ygqGANB8OK6FeBv5;

1.26
date	2016.05.25.05.34.23;	author ratchov;	state Exp;
branches;
next	1.25;
commitid	cMTUMzM46QUjIk2m;

1.25
date	2016.03.23.06.16.35;	author ratchov;	state Exp;
branches;
next	1.24;
commitid	VkSMySsfDNHeK23b;

1.24
date	2016.01.09.08.53.08;	author ratchov;	state Exp;
branches;
next	1.23;
commitid	vbHnfdaOYwi1ZKJu;

1.23
date	2016.01.08.16.17.31;	author ratchov;	state Exp;
branches;
next	1.22;
commitid	LWS9HDcDMBciqd8t;

1.22
date	2015.11.25.18.51.08;	author ratchov;	state Exp;
branches;
next	1.21;
commitid	e5qFASB2G1Mq2MbD;

1.21
date	2015.11.25.18.47.12;	author ratchov;	state Exp;
branches;
next	1.20;
commitid	sYMrHkjTYjG2IfUT;

1.20
date	2015.11.23.12.24.21;	author ratchov;	state Exp;
branches;
next	1.19;
commitid	OH2zksXwGSpvLQpb;

1.19
date	2015.11.23.10.02.42;	author ratchov;	state Exp;
branches;
next	1.18;
commitid	mwNNRQFCCWDFowtk;

1.18
date	2015.09.05.11.19.20;	author ratchov;	state Exp;
branches;
next	1.17;
commitid	r2fGFIBgFsQaqL57;

1.17
date	2014.06.02.07.51.25;	author ratchov;	state Exp;
branches;
next	1.16;
commitid	saTBIQi17E3TJd3I;

1.16
date	2014.03.17.17.53.33;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2014.03.17.17.16.06;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2014.03.07.10.23.05;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2014.03.07.10.15.38;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2014.03.05.20.31.22;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2014.03.05.20.24.16;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2014.02.08.15.17.37;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2013.12.31.12.27.49;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2013.12.20.08.47.37;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2013.11.18.17.37.45;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2013.05.05.20.42.53;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2013.05.05.09.50.21;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2013.02.26.22.52.08;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2012.11.30.20.44.31;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2012.11.30.20.25.32;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2012.11.23.07.03.28;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Fix the code supposed to abort when attempting to detach a slot that's
not on the slot list (the check was a no-op). Found by jsg@@, thanks!
@
text
@/*	$OpenBSD$	*/
/*
 * Copyright (c) 2008-2012 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <stdio.h>
#include <string.h>

#include "abuf.h"
#include "defs.h"
#include "dev.h"
#include "dsp.h"
#include "siofile.h"
#include "midi.h"
#include "sysex.h"
#include "utils.h"

void zomb_onmove(void *);
void zomb_onvol(void *);
void zomb_fill(void *);
void zomb_flush(void *);
void zomb_eof(void *);
void zomb_exit(void *);

void dev_log(struct dev *);
void dev_midi_qfr(struct dev *, int);
void dev_midi_full(struct dev *);
void dev_midi_vol(struct dev *, struct slot *);
void dev_midi_master(struct dev *);
void dev_midi_slotdesc(struct dev *, struct slot *);
void dev_midi_dump(struct dev *);
void dev_midi_imsg(void *, unsigned char *, int);
void dev_midi_omsg(void *, unsigned char *, int);
void dev_midi_fill(void *, int);
void dev_midi_exit(void *);

int play_filt_resamp(struct slot *, void *, void *, int);
int play_filt_dec(struct slot *, void *, void *, int);
void dev_mix_badd(struct dev *, struct slot *);
void dev_mix_adjvol(struct dev *);
int rec_filt_resamp(struct slot *, void *, void *, int);
int rec_filt_enc(struct slot *, void *, void *, int);
void dev_sub_bcopy(struct dev *, struct slot *);

void dev_onmove(struct dev *, int);
void dev_master(struct dev *, unsigned int);
void dev_cycle(struct dev *);
int dev_getpos(struct dev *);
struct dev *dev_new(char *, struct aparams *, unsigned int, unsigned int,
    unsigned int, unsigned int, unsigned int, unsigned int);
void dev_adjpar(struct dev *, int, int, int);
int dev_open(struct dev *);
void dev_close(struct dev *);
int dev_ref(struct dev *);
void dev_unref(struct dev *);
int dev_init(struct dev *);
void dev_done(struct dev *);
struct dev *dev_bynum(int);
void dev_del(struct dev *);
unsigned int dev_roundof(struct dev *, unsigned int);
void dev_wakeup(struct dev *);
void dev_sync_attach(struct dev *);
void dev_mmcstart(struct dev *);
void dev_mmcstop(struct dev *);
void dev_mmcloc(struct dev *, unsigned int);

void slot_log(struct slot *);
struct slot *slot_new(struct dev *, char *, struct slotops *, void *, int);
void slot_del(struct slot *);
void slot_setvol(struct slot *, unsigned int);
void slot_attach(struct slot *);
void slot_ready(struct slot *);
void slot_start(struct slot *);
void slot_detach(struct slot *);
void slot_stop(struct slot *);
void slot_skip_update(struct slot *);
void slot_write(struct slot *);
void slot_read(struct slot *);
int slot_skip(struct slot *);

struct midiops dev_midiops = {
	dev_midi_imsg,
	dev_midi_omsg,
	dev_midi_fill,
	dev_midi_exit
};

struct slotops zomb_slotops = {
	zomb_onmove,
	zomb_onvol,
	zomb_fill,
	zomb_flush,
	zomb_eof,
	zomb_exit
};

struct dev *dev_list = NULL;
unsigned int dev_sndnum = 0;

void
dev_log(struct dev *d)
{
#ifdef DEBUG
	static char *pstates[] = {
		"cfg", "ini", "run"
	};
#endif
	log_puts("snd");
	log_putu(d->num);
#ifdef DEBUG
	if (log_level >= 3) {
		log_puts(" pst=");
		log_puts(pstates[d->pstate]);
	}
#endif
}

void
slot_log(struct slot *s)
{
#ifdef DEBUG
	static char *pstates[] = {
		"ini", "sta", "rdy", "run", "stp", "mid"
	};
	static char *tstates[] = {
		"off", "sta", "run", "stp"
	};
#endif
	log_puts(s->name);
	log_putu(s->unit);
#ifdef DEBUG
	if (log_level >= 3) {
		log_puts(" vol=");
		log_putu(s->vol);
		if (s->ops) {
			log_puts(",pst=");
			log_puts(pstates[s->pstate]);
			log_puts(",mmc=");
			log_puts(tstates[s->tstate]);
		}
	}
#endif
}

void
zomb_onmove(void *arg)
{
}

void
zomb_onvol(void *arg)
{
}

void
zomb_fill(void *arg)
{
}

void
zomb_flush(void *arg)
{
}

void
zomb_eof(void *arg)
{
	struct slot *s = arg;

#ifdef DEBUG
	if (log_level >= 3) {
		slot_log(s);
		log_puts(": zomb_eof\n");
	}
#endif
	s->ops = NULL;
}

void
zomb_exit(void *arg)
{
#ifdef DEBUG
	struct slot *s = arg;

	if (log_level >= 3) {
		slot_log(s);
		log_puts(": zomb_exit\n");
	}
#endif
}

/*
 * send a quarter frame MTC message
 */
void
dev_midi_qfr(struct dev *d, int delta)
{
	unsigned char buf[2];
	unsigned int data;
	int qfrlen;

	d->mtc.delta += delta * MTC_SEC;
	qfrlen = d->rate * (MTC_SEC / (4 * d->mtc.fps));
	while (d->mtc.delta >= qfrlen) {
		switch (d->mtc.qfr) {
		case 0:
			data = d->mtc.fr & 0xf;
			break;
		case 1:
			data = d->mtc.fr >> 4;
			break;
		case 2:
			data = d->mtc.sec & 0xf;
			break;
		case 3:
			data = d->mtc.sec >> 4;
			break;
		case 4:
			data = d->mtc.min & 0xf;
			break;
		case 5:
			data = d->mtc.min >> 4;
			break;
		case 6:
			data = d->mtc.hr & 0xf;
			break;
		case 7:
			data = (d->mtc.hr >> 4) | (d->mtc.fps_id << 1);
			/*
			 * tick messages are sent 2 frames ahead
			 */
			d->mtc.fr += 2;
			if (d->mtc.fr < d->mtc.fps)
				break;
			d->mtc.fr -= d->mtc.fps;
			d->mtc.sec++;
			if (d->mtc.sec < 60)
				break;
			d->mtc.sec = 0;
			d->mtc.min++;
			if (d->mtc.min < 60)
				break;
			d->mtc.min = 0;
			d->mtc.hr++;
			if (d->mtc.hr < 24)
				break;
			d->mtc.hr = 0;
			break;
		default:
			/* NOTREACHED */
			data = 0;
		}
		buf[0] = 0xf1;
		buf[1] = (d->mtc.qfr << 4) | data;
		d->mtc.qfr++;
		d->mtc.qfr &= 7;
		midi_send(d->midi, buf, 2);
		d->mtc.delta -= qfrlen;
	}
}

/*
 * send a full frame MTC message
 */
void
dev_midi_full(struct dev *d)
{
	struct sysex x;
	unsigned int fps;

	d->mtc.delta = MTC_SEC * dev_getpos(d);
	if (d->rate % (30 * 4 * d->round) == 0) {
		d->mtc.fps_id = MTC_FPS_30;
		d->mtc.fps = 30;
	} else if (d->rate % (25 * 4 * d->round) == 0) {
		d->mtc.fps_id = MTC_FPS_25;
		d->mtc.fps = 25;
	} else {
		d->mtc.fps_id = MTC_FPS_24;
		d->mtc.fps = 24;
	}
#ifdef DEBUG
	if (log_level >= 3) {
		dev_log(d);
		log_puts(": mtc full frame at ");
		log_puti(d->mtc.delta);
		log_puts(", ");
		log_puti(d->mtc.fps);
		log_puts(" fps\n");
	}
#endif
	fps = d->mtc.fps;
	d->mtc.hr =  (d->mtc.origin / (MTC_SEC * 3600)) % 24;
	d->mtc.min = (d->mtc.origin / (MTC_SEC * 60))   % 60;
	d->mtc.sec = (d->mtc.origin / (MTC_SEC))        % 60;
	d->mtc.fr =  (d->mtc.origin / (MTC_SEC / fps))  % fps;

	x.start = SYSEX_START;
	x.type = SYSEX_TYPE_RT;
	x.dev = SYSEX_DEV_ANY;
	x.id0 = SYSEX_MTC;
	x.id1 = SYSEX_MTC_FULL;
	x.u.full.hr = d->mtc.hr | (d->mtc.fps_id << 5);
	x.u.full.min = d->mtc.min;
	x.u.full.sec = d->mtc.sec;
	x.u.full.fr = d->mtc.fr;
	x.u.full.end = SYSEX_END;
	d->mtc.qfr = 0;
	midi_send(d->midi, (unsigned char *)&x, SYSEX_SIZE(full));
}

/*
 * send a volume change MIDI message
 */
void
dev_midi_vol(struct dev *d, struct slot *s)
{
	unsigned char msg[3];

	msg[0] = MIDI_CTL | (s - d->slot);
	msg[1] = MIDI_CTL_VOL;
	msg[2] = s->vol;
	midi_send(d->midi, msg, 3);
}

/*
 * send a master volume MIDI message
 */
void
dev_midi_master(struct dev *d)
{
	struct sysex x;

	memset(&x, 0, sizeof(struct sysex));
	x.start = SYSEX_START;
	x.type = SYSEX_TYPE_RT;
	x.dev = SYSEX_DEV_ANY;
	x.id0 = SYSEX_CONTROL;
	x.id1 = SYSEX_MASTER;
	x.u.master.fine = 0;
	x.u.master.coarse = d->master;
	x.u.master.end = SYSEX_END;
	midi_send(d->midi, (unsigned char *)&x, SYSEX_SIZE(master));
}

/*
 * send a sndiod-specific slot description MIDI message
 */
void
dev_midi_slotdesc(struct dev *d, struct slot *s)
{
	struct sysex x;

	memset(&x, 0, sizeof(struct sysex));
	x.start = SYSEX_START;
	x.type = SYSEX_TYPE_EDU;
	x.dev = SYSEX_DEV_ANY;
	x.id0 = SYSEX_AUCAT;
	x.id1 = SYSEX_AUCAT_SLOTDESC;
	if (*s->name != '\0') {
		snprintf((char *)x.u.slotdesc.name, SYSEX_NAMELEN,
		    "%s%u", s->name, s->unit);
	}
	x.u.slotdesc.chan = s - d->slot;
	x.u.slotdesc.end = SYSEX_END;
	midi_send(d->midi, (unsigned char *)&x, SYSEX_SIZE(slotdesc));
}

void
dev_midi_dump(struct dev *d)
{
	struct sysex x;
	struct slot *s;
	int i;

	dev_midi_master(d);
	for (i = 0, s = d->slot; i < DEV_NSLOT; i++, s++) {
		dev_midi_slotdesc(d, s);
		dev_midi_vol(d, s);
	}
	x.start = SYSEX_START;
	x.type = SYSEX_TYPE_EDU;
	x.dev = SYSEX_DEV_ANY;
	x.id0 = SYSEX_AUCAT;
	x.id1 = SYSEX_AUCAT_DUMPEND;
	x.u.dumpend.end = SYSEX_END;
	midi_send(d->midi, (unsigned char *)&x, SYSEX_SIZE(dumpend));
}

void
dev_midi_imsg(void *arg, unsigned char *msg, int len)
{
#ifdef DEBUG
	struct dev *d = arg;

	dev_log(d);
	log_puts(": can't receive midi messages\n");
	panic();
#endif
}

void
dev_midi_omsg(void *arg, unsigned char *msg, int len)
{
	struct dev *d = arg;
	struct sysex *x;
	unsigned int fps, chan;

	if ((msg[0] & MIDI_CMDMASK) == MIDI_CTL && msg[1] == MIDI_CTL_VOL) {
		chan = msg[0] & MIDI_CHANMASK;
		if (chan >= DEV_NSLOT)
			return;
		slot_setvol(d->slot + chan, msg[2]);
		return;
	}
	x = (struct sysex *)msg;
	if (x->start != SYSEX_START)
		return;
	if (len < SYSEX_SIZE(empty))
		return;
	switch (x->type) {
	case SYSEX_TYPE_RT:
		if (x->id0 == SYSEX_CONTROL && x->id1 == SYSEX_MASTER) {
			if (len == SYSEX_SIZE(master))
				dev_master(d, x->u.master.coarse);
			return;
		}
		if (x->id0 != SYSEX_MMC)
			return;
		switch (x->id1) {
		case SYSEX_MMC_STOP:
			if (len != SYSEX_SIZE(stop))
				return;
			if (log_level >= 2) {
				dev_log(d);
				log_puts(": mmc stop\n");
			}
			dev_mmcstop(d);
			break;
		case SYSEX_MMC_START:
			if (len != SYSEX_SIZE(start))
				return;
			if (log_level >= 2) {
				dev_log(d);
				log_puts(": mmc start\n");
			}
			dev_mmcstart(d);
			break;
		case SYSEX_MMC_LOC:
			if (len != SYSEX_SIZE(loc) ||
			    x->u.loc.len != SYSEX_MMC_LOC_LEN ||
			    x->u.loc.cmd != SYSEX_MMC_LOC_CMD)
				return;
			switch (x->u.loc.hr >> 5) {
			case MTC_FPS_24:
				fps = 24;
				break;
			case MTC_FPS_25:
				fps = 25;
				break;
			case MTC_FPS_30:
				fps = 30;
				break;
			default:
				dev_mmcstop(d);
				return;
			}
			dev_mmcloc(d,
			    (x->u.loc.hr & 0x1f) * 3600 * MTC_SEC +
			     x->u.loc.min * 60 * MTC_SEC +
			     x->u.loc.sec * MTC_SEC +
			     x->u.loc.fr * (MTC_SEC / fps) +
			     x->u.loc.cent * (MTC_SEC / 100 / fps));
			break;
		}
		break;
	case SYSEX_TYPE_EDU:
		if (x->id0 != SYSEX_AUCAT || x->id1 != SYSEX_AUCAT_DUMPREQ)
			return;
		if (len != SYSEX_SIZE(dumpreq))
			return;
		dev_midi_dump(d);
		break;
	}
}

void
dev_midi_fill(void *arg, int count)
{
	/* nothing to do */
}

void
dev_midi_exit(void *arg)
{
	struct dev *d = arg;

	if (log_level >= 1) {
		dev_log(d);
		log_puts(": midi end point died\n");
	}
	if (d->pstate != DEV_CFG)
		dev_close(d);
}

int
slot_skip(struct slot *s)
{
	unsigned char *data = (unsigned char *)0xdeadbeef; /* please gcc */
	int max, count;

	max = s->skip;
	while (s->skip > 0) {
		if (s->pstate != SLOT_STOP && (s->mode & MODE_RECMASK)) {
			data = abuf_wgetblk(&s->sub.buf, &count);
			if (count < s->round * s->sub.bpf)
				break;
		}
		if (s->mode & MODE_PLAY) {
			if (s->mix.buf.used < s->round * s->mix.bpf)
				break;
		}
#ifdef DEBUG
		if (log_level >= 4) {
			slot_log(s);
			log_puts(": skipped a cycle\n");
		}
#endif
		if (s->pstate != SLOT_STOP && (s->mode & MODE_RECMASK)) {
			if (s->sub.encbuf)
				enc_sil_do(&s->sub.enc, data, s->round);
			else
				memset(data, 0, s->round * s->sub.bpf);
			abuf_wcommit(&s->sub.buf, s->round * s->sub.bpf);
		}
		if (s->mode & MODE_PLAY) {
			abuf_rdiscard(&s->mix.buf, s->round * s->mix.bpf);
		}
		s->skip--;
	}
	return max - s->skip;
}

int
play_filt_resamp(struct slot *s, void *res_in, void *out, int todo)
{
	int i, offs, vol, nch;
	void *in;

	if (s->mix.resampbuf) {
		todo = resamp_do(&s->mix.resamp,
		    res_in, s->mix.resampbuf, todo);
		in = s->mix.resampbuf;
	} else
		in = res_in;

	nch = s->mix.cmap.nch;
	vol = ADATA_MUL(s->mix.weight, s->mix.vol) / s->mix.join;
	cmap_add(&s->mix.cmap, in, out, vol, todo);

	offs = 0;
	for (i = s->mix.join - 1; i > 0; i--) {
		offs += nch;
		cmap_add(&s->mix.cmap, (adata_t *)in + offs, out, vol, todo);
	}
	offs = 0;
	for (i = s->mix.expand - 1; i > 0; i--) {
		offs += nch;
		cmap_add(&s->mix.cmap, in, (adata_t *)out + offs, vol, todo);
	}
	return todo;
}

int
play_filt_dec(struct slot *s, void *in, void *out, int todo)
{
	void *tmp;

	tmp = s->mix.decbuf;
	if (tmp)
		dec_do(&s->mix.dec, in, tmp, todo);
	return play_filt_resamp(s, tmp ? tmp : in, out, todo);
}

/*
 * mix "todo" frames from the input block over the output block; if
 * there are frames to drop, less frames are consumed from the input
 */
void
dev_mix_badd(struct dev *d, struct slot *s)
{
	adata_t *idata, *odata;
	int icount;

	odata = DEV_PBUF(d);
	idata = (adata_t *)abuf_rgetblk(&s->mix.buf, &icount);
#ifdef DEBUG
	if (icount < s->round * s->mix.bpf) {
		slot_log(s);
		log_puts(": not enough data to mix (");
		log_putu(icount);
		log_puts("bytes)\n");
		panic();
	}
#endif
	play_filt_dec(s, idata, odata, s->round);
	abuf_rdiscard(&s->mix.buf, s->round * s->mix.bpf);
}

/*
 * Normalize input levels.
 */
void
dev_mix_adjvol(struct dev *d)
{
	unsigned int n;
	struct slot *i, *j;
	int weight;

	for (i = d->slot_list; i != NULL; i = i->next) {
		if (!(i->mode & MODE_PLAY))
			continue;
		weight = ADATA_UNIT;
		if (d->autovol) {
			/*
			 * count the number of inputs that have
			 * overlapping channel sets
			 */
			n = 0;
			for (j = d->slot_list; j != NULL; j = j->next) {
				if (!(j->mode & MODE_PLAY))
					continue;
				if (i->mix.slot_cmin <= j->mix.slot_cmax &&
				    i->mix.slot_cmax >= j->mix.slot_cmin)
					n++;
			}
			weight /= n;
		}
		if (weight > i->mix.maxweight)
			weight = i->mix.maxweight;
		i->mix.weight = ADATA_MUL(weight, MIDI_TO_ADATA(d->master));
#ifdef DEBUG
		if (log_level >= 3) {
			slot_log(i);
			log_puts(": set weight: ");
			log_puti(i->mix.weight);
			log_puts("/");
			log_puti(i->mix.maxweight);
			log_puts("\n");
		}
#endif
	}
}

int
rec_filt_resamp(struct slot *s, void *in, void *res_out, int todo)
{
	int i, vol, offs, nch;
	void *out = res_out;

	out = (s->sub.resampbuf) ? s->sub.resampbuf : res_out;

	nch = s->sub.cmap.nch;
	vol = ADATA_UNIT / s->sub.join;
	cmap_copy(&s->sub.cmap, in, out, vol, todo);

	offs = 0;
	for (i = s->sub.join - 1; i > 0; i--) {
		offs += nch;
		cmap_add(&s->sub.cmap, (adata_t *)in + offs, out, vol, todo);
	}
	offs = 0;
	for (i = s->sub.expand - 1; i > 0; i--) {
		offs += nch;
		cmap_copy(&s->sub.cmap, in, (adata_t *)out + offs, vol, todo);
	}
	if (s->sub.resampbuf) {
		todo = resamp_do(&s->sub.resamp,
		    s->sub.resampbuf, res_out, todo);
	}
	return todo;
}

int
rec_filt_enc(struct slot *s, void *in, void *out, int todo)
{
	void *tmp;

	tmp = s->sub.encbuf;
	todo = rec_filt_resamp(s, in, tmp ? tmp : out, todo);
	if (tmp)
		enc_do(&s->sub.enc, tmp, out, todo);
	return todo;
}

/*
 * Copy data from slot to device
 */
void
dev_sub_bcopy(struct dev *d, struct slot *s)
{
	adata_t *idata, *odata;
	int ocount, moffs;

	if (s->mode & MODE_MON) {
		moffs = d->poffs + d->round;
		if (moffs == d->psize)
			moffs = 0;
		idata = d->pbuf + moffs * d->pchan;
	} else
		idata = d->rbuf;
	odata = (adata_t *)abuf_wgetblk(&s->sub.buf, &ocount);
#ifdef DEBUG
	if (ocount < s->round * s->sub.bpf) {
		log_puts("dev_sub_bcopy: not enough space\n");
		panic();
	}
#endif
	ocount = rec_filt_enc(s, idata, odata, d->round);
	abuf_wcommit(&s->sub.buf, ocount * s->sub.bpf);
}

/*
 * run a one block cycle: consume one recorded block from
 * rbuf and produce one play block in pbuf
 */
void
dev_cycle(struct dev *d)
{
	struct slot *s, **ps;
	unsigned char *base;
	int nsamp;

	/*
	 * check if the device is actually used. If it isn't,
	 * then close it
	 */
	if (d->slot_list == NULL && d->tstate != MMC_RUN) {
		if (log_level >= 2) {
			dev_log(d);
			log_puts(": device stopped\n");
		}
		dev_sio_stop(d);
		d->pstate = DEV_INIT;
		if (d->refcnt == 0)
			dev_close(d);
		return;
	}

	if (d->prime > 0) {
#ifdef DEBUG
		if (log_level >= 4) {
			dev_log(d);
			log_puts(": empty cycle, prime = ");
			log_putu(d->prime);
			log_puts("\n");
		}
#endif
		base = (unsigned char *)DEV_PBUF(d);
		nsamp = d->round * d->pchan;
		memset(base, 0, nsamp * sizeof(adata_t));
		if (d->encbuf) {
			enc_do(&d->enc, (unsigned char *)DEV_PBUF(d),
			    d->encbuf, d->round);
		}
		d->prime -= d->round;
		return;
	}

	d->delta -= d->round;
#ifdef DEBUG
	if (log_level >= 4) {
		dev_log(d);
		log_puts(": full cycle: delta = ");
		log_puti(d->delta);
		if (d->mode & MODE_PLAY) {
			log_puts(", poffs = ");
			log_puti(d->poffs);
		}
		log_puts("\n");
	}
#endif
	if (d->mode & MODE_PLAY) {
		base = (unsigned char *)DEV_PBUF(d);
		nsamp = d->round * d->pchan;
		memset(base, 0, nsamp * sizeof(adata_t));
	}
	if ((d->mode & MODE_REC) && d->decbuf)
		dec_do(&d->dec, d->decbuf, (unsigned char *)d->rbuf, d->round);
	ps = &d->slot_list;
	while ((s = *ps) != NULL) {
#ifdef DEBUG
		if (log_level >= 4) {
			slot_log(s);
			log_puts(": running");
			log_puts(", skip = ");
			log_puti(s->skip);
			log_puts("\n");
		}
#endif
		/*
		 * skip cycles for XRUN_SYNC correction
		 */
		slot_skip(s);
		if (s->skip < 0) {
			s->skip++;
			ps = &s->next;
			continue;
		}

#ifdef DEBUG
		if (s->pstate == SLOT_STOP && !(s->mode & MODE_PLAY)) {
			slot_log(s);
			log_puts(": rec-only slots can't be drained\n");
			panic();
		}
#endif
		/*
		 * check if stopped stream finished draining
		 */
		if (s->pstate == SLOT_STOP &&
		    s->mix.buf.used < s->round * s->mix.bpf) {
			/*
			 * partial blocks are zero-filled by socket
			 * layer, so s->mix.buf.used == 0 and we can
			 * destroy the buffer
			 */
			s->pstate = SLOT_INIT;
			abuf_done(&s->mix.buf);
			if (s->mix.decbuf)
				xfree(s->mix.decbuf);
			if (s->mix.resampbuf)
				xfree(s->mix.resampbuf);
			s->ops->eof(s->arg);
			*ps = s->next;
			dev_mix_adjvol(d);
			continue;
		}

		/*
		 * check for xruns
		 */
		if (((s->mode & MODE_PLAY) &&
			s->mix.buf.used < s->round * s->mix.bpf) ||
		    ((s->mode & MODE_RECMASK) &&
			s->sub.buf.len - s->sub.buf.used <
			s->round * s->sub.bpf)) {

#ifdef DEBUG
			if (log_level >= 3) {
				slot_log(s);
				log_puts(": xrun, pause cycle\n");
			}
#endif
			if (s->xrun == XRUN_IGNORE) {
				s->delta -= s->round;
				ps = &s->next;
			} else if (s->xrun == XRUN_SYNC) {
				s->skip++;
				ps = &s->next;
			} else if (s->xrun == XRUN_ERROR) {
				s->ops->exit(s->arg);
				*ps = s->next;
			} else {
#ifdef DEBUG
				slot_log(s);
				log_puts(": bad xrun mode\n");
				panic();
#endif
			}
			continue;
		}
		if ((s->mode & MODE_RECMASK) && !(s->pstate == SLOT_STOP)) {
			if (s->sub.prime == 0) {
				dev_sub_bcopy(d, s);
				s->ops->flush(s->arg);
			} else {
#ifdef DEBUG
				if (log_level >= 3) {
					slot_log(s);
					log_puts(": prime = ");
					log_puti(s->sub.prime);
					log_puts("\n");
				}
#endif
				s->sub.prime--;
			}
		}
		if (s->mode & MODE_PLAY) {
			dev_mix_badd(d, s);
			if (s->pstate != SLOT_STOP)
				s->ops->fill(s->arg);
		}
		ps = &s->next;
	}
	if ((d->mode & MODE_PLAY) && d->encbuf) {
		enc_do(&d->enc, (unsigned char *)DEV_PBUF(d),
		    d->encbuf, d->round);
	}
}

/*
 * called at every clock tick by the device
 */
void
dev_onmove(struct dev *d, int delta)
{
	long long pos;
	struct slot *s, *snext;

	d->delta += delta;

	for (s = d->slot_list; s != NULL; s = snext) {
		/*
		 * s->ops->onmove() may remove the slot
		 */
		snext = s->next;
		pos = (long long)delta * s->round + s->delta_rem;
		s->delta_rem = pos % d->round;
		s->delta += pos / (int)d->round;
		if (s->delta >= 0)
			s->ops->onmove(s->arg);
	}
	if (d->tstate == MMC_RUN)
		dev_midi_qfr(d, delta);
}

void
dev_master(struct dev *d, unsigned int master)
{
	if (log_level >= 2) {
		dev_log(d);
		log_puts(": master volume set to ");
		log_putu(master);
		log_puts("\n");
	}
	d->master = master;
	if (d->mode & MODE_PLAY)
		dev_mix_adjvol(d);
}

/*
 * return the latency that a stream would have if it's attached
 */
int
dev_getpos(struct dev *d)
{
	return (d->mode & MODE_PLAY) ? -d->bufsz : 0;
}

/*
 * Create a sndio device
 */
struct dev *
dev_new(char *path, struct aparams *par,
    unsigned int mode, unsigned int bufsz, unsigned int round,
    unsigned int rate, unsigned int hold, unsigned int autovol)
{
	struct dev *d;
	unsigned int i;

	if (dev_sndnum == DEV_NMAX) {
		if (log_level >= 1)
			log_puts("too many devices\n");
		return NULL;
	}
	d = xmalloc(sizeof(struct dev));
	d->path = xstrdup(path);
	d->num = dev_sndnum++;

	/*
	 * XXX: below, we allocate a midi input buffer, since we don't
	 *	receive raw midi data, so no need to allocate a input
	 *	ibuf.  Possibly set imsg & fill callbacks to NULL and
	 *	use this to in midi_new() to check if buffers need to be
	 *	allocated
	 */
	d->midi = midi_new(&dev_midiops, d, MODE_MIDIIN | MODE_MIDIOUT);
	midi_tag(d->midi, d->num);
	d->reqpar = *par;
	d->reqmode = mode;
	d->reqpchan = d->reqrchan = 0;
	d->reqbufsz = bufsz;
	d->reqround = round;
	d->reqrate = rate;
	d->hold = hold;
	d->autovol = autovol;
	d->refcnt = 0;
	d->pstate = DEV_CFG;
	d->serial = 0;
	for (i = 0; i < DEV_NSLOT; i++) {
		d->slot[i].unit = i;
		d->slot[i].ops = NULL;
		d->slot[i].vol = MIDI_MAXCTL;
		d->slot[i].tstate = MMC_OFF;
		d->slot[i].serial = d->serial++;
		strlcpy(d->slot[i].name, "prog", SLOT_NAMEMAX);
	}
	d->slot_list = NULL;
	d->master = MIDI_MAXCTL;
	d->mtc.origin = 0;
	d->tstate = MMC_STOP;
	d->next = dev_list;
	dev_list = d;
	return d;
}

/*
 * adjust device parameters and mode
 */
void
dev_adjpar(struct dev *d, int mode,
    int pmax, int rmax)
{
	d->reqmode |= mode & MODE_AUDIOMASK;
	if (mode & MODE_PLAY) {
		if (d->reqpchan < pmax + 1)
			d->reqpchan = pmax + 1;
	}
	if (mode & MODE_REC) {
		if (d->reqrchan < rmax + 1)
			d->reqrchan = rmax + 1;
	}
}

/*
 * Open the device with the dev_reqxxx capabilities. Setup a mixer, demuxer,
 * monitor, midi control, and any necessary conversions.
 */
int
dev_open(struct dev *d)
{
	d->mode = d->reqmode;
	d->round = d->reqround;
	d->bufsz = d->reqbufsz;
	d->rate = d->reqrate;
	d->pchan = d->reqpchan;
	d->rchan = d->reqrchan;
	d->par = d->reqpar;
	if (d->pchan == 0)
		d->pchan = 2;
	if (d->rchan == 0)
		d->rchan = 2;
	if (!dev_sio_open(d)) {
		if (log_level >= 1) {
			dev_log(d);
			log_puts(": ");
			log_puts(d->path);
			log_puts(": failed to open audio device\n");
		}
		return 0;
	}
	if (d->mode & MODE_REC) {
		/*
		 * Create device <-> demuxer buffer
		 */
		d->rbuf = xmalloc(d->round * d->rchan * sizeof(adata_t));

		/*
		 * Insert a converter, if needed.
		 */
		if (!aparams_native(&d->par)) {
			dec_init(&d->dec, &d->par, d->rchan);
			d->decbuf = xmalloc(d->round * d->rchan * d->par.bps);
		} else
			d->decbuf = NULL;
	}
	if (d->mode & MODE_PLAY) {
		/*
		 * Create device <-> mixer buffer
		 */
		d->poffs = 0;
		d->psize = d->bufsz + d->round;
		d->pbuf = xmalloc(d->psize * d->pchan * sizeof(adata_t));
		d->mode |= MODE_MON;

		/*
		 * Append a converter, if needed.
		 */
		if (!aparams_native(&d->par)) {
			enc_init(&d->enc, &d->par, d->pchan);
			d->encbuf = xmalloc(d->round * d->pchan * d->par.bps);
		} else
			d->encbuf = NULL;
	}
	d->pstate = DEV_INIT;
	if (log_level >= 2) {
		dev_log(d);
		log_puts(": ");
		log_putu(d->rate);
		log_puts("Hz, ");
		aparams_log(&d->par);
		if (d->mode & MODE_PLAY) {
			log_puts(", play 0:");
			log_puti(d->pchan - 1);
		}
		if (d->mode & MODE_REC) {
			log_puts(", rec 0:");
			log_puti(d->rchan - 1);
		}
		log_puts(", ");
		log_putu(d->bufsz / d->round);
		log_puts(" blocks of ");
		log_putu(d->round);
		log_puts(" frames\n");
	}
	return 1;
}

/*
 * force the device to go in DEV_CFG state, the caller is supposed to
 * ensure buffers are drained
 */
void
dev_close(struct dev *d)
{
	int i;
	struct slot *s;

#ifdef DEBUG
	if (log_level >= 3) {
		dev_log(d);
		log_puts(": closing\n");
	}
#endif
	d->pstate = DEV_CFG;
	for (s = d->slot, i = DEV_NSLOT; i > 0; i--, s++) {
		if (s->ops)
			s->ops->exit(s->arg);
		s->ops = NULL;
	}
	d->slot_list = NULL;
	dev_sio_close(d);
	if (d->mode & MODE_PLAY) {
		if (d->encbuf != NULL)
			xfree(d->encbuf);
		xfree(d->pbuf);
	}
	if (d->mode & MODE_REC) {
		if (d->decbuf != NULL)
			xfree(d->decbuf);
		xfree(d->rbuf);
	}
}

int
dev_ref(struct dev *d)
{
#ifdef DEBUG
	if (log_level >= 3) {
		dev_log(d);
		log_puts(": device requested\n");
	}
#endif
	if (d->pstate == DEV_CFG && !dev_open(d))
		return 0;
	d->refcnt++;
	return 1;
}

void
dev_unref(struct dev *d)
{
#ifdef DEBUG
	if (log_level >= 3) {
		dev_log(d);
		log_puts(": device released\n");
	}
#endif
	d->refcnt--;
	if (d->refcnt == 0 && d->pstate == DEV_INIT)
		dev_close(d);
}

/*
 * initialize the device with the current parameters
 */
int
dev_init(struct dev *d)
{
	if ((d->reqmode & MODE_AUDIOMASK) == 0) {
#ifdef DEBUG
		    dev_log(d);
		    log_puts(": has no streams\n");
#endif
		    return 0;
	}
	if (d->hold && !dev_ref(d))
		return 0;
	return 1;
}

/*
 * Unless the device is already in process of closing, request it to close
 */
void
dev_done(struct dev *d)
{
#ifdef DEBUG
	if (log_level >= 3) {
		dev_log(d);
		log_puts(": draining\n");
	}
#endif
	if (d->tstate != MMC_STOP)
		dev_mmcstop(d);
	if (d->hold)
		dev_unref(d);
}

struct dev *
dev_bynum(int num)
{
	struct dev *d;

	for (d = dev_list; d != NULL; d = d->next) {
		if (d->num == num)
			return d;
	}
	return NULL;
}

/*
 * Free the device
 */
void
dev_del(struct dev *d)
{
	struct dev **p;

#ifdef DEBUG
	if (log_level >= 3) {
		dev_log(d);
		log_puts(": deleting\n");
	}
#endif
	if (d->pstate != DEV_CFG)
		dev_close(d);
	for (p = &dev_list; *p != d; p = &(*p)->next) {
#ifdef DEBUG
		if (*p == NULL) {
			dev_log(d);
			log_puts(": device to delete not on the list\n");
			panic();
		}
#endif
	}
	midi_del(d->midi);
	*p = d->next;
	xfree(d->path);
	xfree(d);
}

unsigned int
dev_roundof(struct dev *d, unsigned int newrate)
{
	return (d->round * newrate + d->rate / 2) / d->rate;
}

/*
 * If the device is paused, then resume it.
 */
void
dev_wakeup(struct dev *d)
{
	if (d->pstate == DEV_INIT) {
		if (log_level >= 2) {
			dev_log(d);
			log_puts(": device started\n");
		}
		if (d->mode & MODE_PLAY) {
			d->prime = d->bufsz;
		} else {
			d->prime = 0;
		}
		d->poffs = 0;

		/*
		 * empty cycles don't increment delta, so it's ok to
		 * start at 0
		 **/
		d->delta = 0;

		d->pstate = DEV_RUN;
		dev_sio_start(d);
	}
}

/*
 * check that all clients controlled by MMC are ready to start, if so,
 * attach them all at the same position
 */
void
dev_sync_attach(struct dev *d)
{
	int i;
	struct slot *s;

	if (d->tstate != MMC_START) {
		if (log_level >= 2) {
			dev_log(d);
			log_puts(": not started by mmc yet, waiting...\n");
		}
		return;
	}
	for (i = 0; i < DEV_NSLOT; i++) {
		s = d->slot + i;
		if (!s->ops || s->tstate == MMC_OFF)
			continue;
		if (s->tstate != MMC_START || s->pstate != SLOT_READY) {
#ifdef DEBUG
			if (log_level >= 3) {
				slot_log(s);
				log_puts(": not ready, start delayed\n");
			}
#endif
			return;
		}
	}
	if (!dev_ref(d))
		return;
	for (i = 0; i < DEV_NSLOT; i++) {
		s = d->slot + i;
		if (!s->ops)
			continue;
		if (s->tstate == MMC_START) {
#ifdef DEBUG
			if (log_level >= 3) {
				slot_log(s);
				log_puts(": started\n");
			}
#endif
			s->tstate = MMC_RUN;
			slot_attach(s);
		}
	}
	d->tstate = MMC_RUN;
	dev_midi_full(d);
	dev_wakeup(d);
}

/*
 * start all slots simultaneously
 */
void
dev_mmcstart(struct dev *d)
{
	if (d->tstate == MMC_STOP) {
		d->tstate = MMC_START;
		dev_sync_attach(d);
#ifdef DEBUG
	} else {
		if (log_level >= 3) {
			dev_log(d);
			log_puts(": ignoring mmc start\n");
		}
#endif
	}
}

/*
 * stop all slots simultaneously
 */
void
dev_mmcstop(struct dev *d)
{
	switch (d->tstate) {
	case MMC_START:
		d->tstate = MMC_STOP;
		return;
	case MMC_RUN:
		d->tstate = MMC_STOP;
		dev_unref(d);
		break;
	default:
#ifdef DEBUG
		if (log_level >= 3) {
			dev_log(d);
			log_puts(": ignored mmc stop\n");
		}
#endif
		return;
	}
}

/*
 * relocate all slots simultaneously
 */
void
dev_mmcloc(struct dev *d, unsigned int origin)
{
	if (log_level >= 2) {
		dev_log(d);
		log_puts(": relocated to ");
		log_putu(origin);
		log_puts("\n");
	}
	if (d->tstate == MMC_RUN)
		dev_mmcstop(d);
	d->mtc.origin = origin;
	if (d->tstate == MMC_RUN)
		dev_mmcstart(d);
}

/*
 * allocate a new slot and register the given call-backs
 */
struct slot *
slot_new(struct dev *d, char *who, struct slotops *ops, void *arg, int mode)
{
	char *p;
	char name[SLOT_NAMEMAX];
	unsigned int i, unit, umap = 0;
	unsigned int ser, bestser, bestidx;
	struct slot *s;

	/*
	 * create a ``valid'' control name (lowcase, remove [^a-z], truncate)
	 */
	for (i = 0, p = who; ; p++) {
		if (i == SLOT_NAMEMAX - 1 || *p == '\0') {
			name[i] = '\0';
			break;
		} else if (*p >= 'A' && *p <= 'Z') {
			name[i++] = *p + 'a' - 'A';
		} else if (*p >= 'a' && *p <= 'z')
			name[i++] = *p;
	}
	if (i == 0)
		strlcpy(name, "noname", SLOT_NAMEMAX);

	/*
	 * find the first unused "unit" number for this name
	 */
	for (i = 0, s = d->slot; i < DEV_NSLOT; i++, s++) {
		if (s->ops == NULL)
			continue;
		if (strcmp(s->name, name) == 0)
			umap |= (1 << s->unit);
	}
	for (unit = 0; ; unit++) {
		if ((umap & (1 << unit)) == 0)
			break;
	}

	/*
	 * find a free controller slot with the same name/unit
	 */
	for (i = 0, s = d->slot; i < DEV_NSLOT; i++, s++) {
		if (s->ops == NULL &&
		    strcmp(s->name, name) == 0 &&
		    s->unit == unit) {
#ifdef DEBUG
			if (log_level >= 3) {
				log_puts(name);
				log_putu(unit);
				log_puts(": reused\n");
			}
#endif
			goto found;
		}
	}

	/*
	 * couldn't find a matching slot, pick oldest free slot
	 * and set its name/unit
	 */
	bestser = 0;
	bestidx = DEV_NSLOT;
	for (i = 0, s = d->slot; i < DEV_NSLOT; i++, s++) {
		if (s->ops != NULL)
			continue;
		ser = d->serial - s->serial;
		if (ser > bestser) {
			bestser = ser;
			bestidx = i;
		}
	}
	if (bestidx == DEV_NSLOT) {
		if (log_level >= 1) {
			log_puts(name);
			log_putu(unit);
			log_puts(": out of sub-device slots\n");
		}
		return NULL;
	}
	s = d->slot + bestidx;
	if (s->name[0] != '\0')
		s->vol = MIDI_MAXCTL;
	strlcpy(s->name, name, SLOT_NAMEMAX);
	s->serial = d->serial++;
	s->unit = unit;
#ifdef DEBUG
	if (log_level >= 3) {
		log_puts(name);
		log_putu(unit);
		log_puts(": overwritten slot ");
		log_putu(bestidx);
		log_puts("\n");
	}
#endif

found:
	if (!dev_ref(d))
		return NULL;
	s->dev = d;
	s->ops = ops;
	s->arg = arg;
	s->pstate = SLOT_INIT;
	s->tstate = MMC_OFF;

	if ((mode & s->dev->mode) != mode) {
		if (log_level >= 1) {
			slot_log(s);
			log_puts(": requested mode not supported\n");
		}
		return 0;
	}
	s->mode = mode;
	aparams_init(&s->par);
	if (s->mode & MODE_PLAY) {
		s->mix.slot_cmin = s->mix.dev_cmin = 0;
		s->mix.slot_cmax = s->mix.dev_cmax = d->pchan - 1;
	}
	if (s->mode & MODE_RECMASK) {
		s->sub.slot_cmin = s->sub.dev_cmin = 0;
		s->sub.slot_cmax = s->sub.dev_cmax =
		    ((s->mode & MODE_MON) ? d->pchan : d->rchan) - 1;
	}
	s->xrun = XRUN_IGNORE;
	s->dup = 0;
	s->appbufsz = d->bufsz;
	s->round = d->round;
	s->rate = d->rate;
	s->mix.maxweight = ADATA_UNIT;
	dev_midi_slotdesc(d, s);
	dev_midi_vol(d, s);
	return s;
}

/*
 * release the given slot
 */
void
slot_del(struct slot *s)
{
	s->arg = s;
	s->ops = &zomb_slotops;
	switch (s->pstate) {
	case SLOT_INIT:
		s->ops = NULL;
		break;
	case SLOT_START:
	case SLOT_READY:
	case SLOT_RUN:
		slot_stop(s);
		/* PASSTHROUGH */
	case SLOT_STOP:
		break;
	}
	dev_unref(s->dev);
	s->dev = NULL;
}

/*
 * change the slot play volume; called either by the slot or by MIDI
 */
void
slot_setvol(struct slot *s, unsigned int vol)
{
#ifdef DEBUG
	if (log_level >= 3) {
		slot_log(s);
		log_puts(": setting volume ");
		log_putu(vol);
		log_puts("\n");
	}
#endif
	s->vol = vol;
	if (s->ops == NULL)
		return;
	s->mix.vol = MIDI_TO_ADATA(s->vol);
}

/*
 * attach the slot to the device (ie start playing & recording
 */
void
slot_attach(struct slot *s)
{
	struct dev *d = s->dev;
	unsigned int slot_nch, dev_nch;
	long long pos;
	int startpos;

	/*
	 * start the device if not started
	 */
	dev_wakeup(d);

	/*
	 * get the current position, the origin is when the first sample
	 * played and/or recorded
	 */
	startpos = dev_getpos(d) * (int)s->round / (int)d->round;

	/*
	 * adjust initial clock
	 */
	pos = (long long)d->delta * s->round;
	s->delta = startpos + pos / (int)d->round;
	s->delta_rem = pos % d->round;

	s->pstate = SLOT_RUN;
#ifdef DEBUG
	if (log_level >= 2) {
		slot_log(s);
		log_puts(": attached at ");
		log_puti(startpos);
		log_puts(", delta = ");
		log_puti(d->delta);
		log_puts("\n");
	}
#endif

	/*
	 * We dont check whether the device is dying,
	 * because dev_xxx() functions are supposed to
	 * work (i.e., not to crash)
	 */
#ifdef DEBUG
	if ((s->mode & d->mode) != s->mode) {
		slot_log(s);
		log_puts(": mode beyond device mode, not attaching\n");
		panic();
	}
#endif
	s->next = d->slot_list;
	d->slot_list = s;
	s->skip = 0;
	if (s->mode & MODE_PLAY) {
		slot_nch = s->mix.slot_cmax - s->mix.slot_cmin + 1;
		dev_nch = s->mix.dev_cmax - s->mix.dev_cmin + 1;
		s->mix.decbuf = NULL;
		s->mix.resampbuf = NULL;
		s->mix.join = 1;
		s->mix.expand = 1;
		if (s->dup) {
			if (dev_nch > slot_nch)
				s->mix.expand = dev_nch / slot_nch;
			else if (dev_nch < slot_nch)
				s->mix.join = slot_nch / dev_nch;
		}
		cmap_init(&s->mix.cmap,
		    s->mix.slot_cmin, s->mix.slot_cmax,
		    s->mix.slot_cmin, s->mix.slot_cmax,
		    0, d->pchan - 1,
		    s->mix.dev_cmin, s->mix.dev_cmax);
		if (!aparams_native(&s->par)) {
			dec_init(&s->mix.dec, &s->par, slot_nch);
			s->mix.decbuf =
			    xmalloc(s->round * slot_nch * sizeof(adata_t));
		}
		if (s->rate != d->rate) {
			resamp_init(&s->mix.resamp, s->round, d->round,
			    slot_nch);
			s->mix.resampbuf =
			    xmalloc(d->round * slot_nch * sizeof(adata_t));
		}
		s->mix.vol = MIDI_TO_ADATA(s->vol);
		dev_mix_adjvol(d);
	}
	if (s->mode & MODE_RECMASK) {
		slot_nch = s->sub.slot_cmax - s->sub.slot_cmin + 1;
		dev_nch = s->sub.dev_cmax - s->sub.dev_cmin + 1;
		s->sub.encbuf = NULL;
		s->sub.resampbuf = NULL;
		s->sub.join = 1;
		s->sub.expand = 1;
		if (s->dup) {
			if (dev_nch > slot_nch)
				s->sub.join = dev_nch / slot_nch;
			else if (dev_nch < slot_nch)
				s->sub.expand = slot_nch / dev_nch;
		}
		cmap_init(&s->sub.cmap,
		    0, ((s->mode & MODE_MON) ? d->pchan : d->rchan) - 1,
		    s->sub.dev_cmin, s->sub.dev_cmax,
		    s->sub.slot_cmin, s->sub.slot_cmax,
		    s->sub.slot_cmin, s->sub.slot_cmax);
		if (s->rate != d->rate) {
			resamp_init(&s->sub.resamp, d->round, s->round,
			    slot_nch);
			s->sub.resampbuf =
			    xmalloc(d->round * slot_nch * sizeof(adata_t));
		}
		if (!aparams_native(&s->par)) {
			enc_init(&s->sub.enc, &s->par, slot_nch);
			s->sub.encbuf =
			    xmalloc(s->round * slot_nch * sizeof(adata_t));
		}

		/*
		 * N-th recorded block is the N-th played block
		 */
		s->sub.prime = -startpos / (int)s->round;
	}
}

/*
 * if MMC is enabled, and try to attach all slots synchronously, else
 * simply attach the slot
 */
void
slot_ready(struct slot *s)
{
	/*
	 * device may be disconnected, and if so we're called from
	 * slot->ops->exit() on a closed device
	 */
	if (s->dev->pstate == DEV_CFG)
		return;
	if (s->tstate == MMC_OFF)
		slot_attach(s);
	else {
		s->tstate = MMC_START;
		dev_sync_attach(s->dev);
	}
}

/*
 * setup buffers & conversion layers, prepare the slot to receive data
 * (for playback) or start (recording).
 */
void
slot_start(struct slot *s)
{
	unsigned int bufsz;
#ifdef DEBUG
	struct dev *d = s->dev;


	if (s->pstate != SLOT_INIT) {
		slot_log(s);
		log_puts(": slot_start: wrong state\n");
		panic();
	}
#endif
	bufsz = s->appbufsz;
	if (s->mode & MODE_PLAY) {
#ifdef DEBUG
		if (log_level >= 3) {
			slot_log(s);
			log_puts(": playing ");
			aparams_log(&s->par);
			log_puts(" -> ");
			aparams_log(&d->par);
			log_puts("\n");
		}
#endif
		s->mix.bpf = s->par.bps *
		    (s->mix.slot_cmax - s->mix.slot_cmin + 1);
		abuf_init(&s->mix.buf, bufsz * s->mix.bpf);
	}
	if (s->mode & MODE_RECMASK) {
#ifdef DEBUG
		if (log_level >= 3) {
			slot_log(s);
			log_puts(": recording ");
			aparams_log(&s->par);
			log_puts(" <- ");
			aparams_log(&d->par);
			log_puts("\n");
	}
#endif
		s->sub.bpf = s->par.bps *
		    (s->sub.slot_cmax - s->sub.slot_cmin + 1);
		abuf_init(&s->sub.buf, bufsz * s->sub.bpf);
	}
	s->mix.weight = MIDI_TO_ADATA(MIDI_MAXCTL);
#ifdef DEBUG
	if (log_level >= 3) {
		slot_log(s);
		log_puts(": allocated ");
		log_putu(s->appbufsz);
		log_puts("/");
		log_putu(SLOT_BUFSZ(s));
		log_puts(" fr buffers\n");
	}
#endif
	if (s->mode & MODE_PLAY) {
		s->pstate = SLOT_START;
	} else {
		s->pstate = SLOT_READY;
		slot_ready(s);
	}
}

/*
 * stop playback and recording, and free conversion layers
 */
void
slot_detach(struct slot *s)
{
	struct slot **ps;

#ifdef DEBUG
	if (log_level >= 3) {
		slot_log(s);
		log_puts(": detaching\n");
	}
#endif
	for (ps = &s->dev->slot_list; *ps != s; ps = &(*ps)->next) {
#ifdef DEBUG
		if (*ps == NULL) {
			slot_log(s);
			log_puts(": can't detach, not on list\n");
			panic();
		}
#endif
	}
	*ps = s->next;
	if (s->mode & MODE_RECMASK) {
		if (s->sub.encbuf)
			xfree(s->sub.encbuf);
		if (s->sub.resampbuf)
			xfree(s->sub.resampbuf);
	}
	if (s->mode & MODE_PLAY) {
		if (s->mix.decbuf)
			xfree(s->mix.decbuf);
		if (s->mix.resampbuf)
			xfree(s->mix.resampbuf);
		dev_mix_adjvol(s->dev);
	}
}

/*
 * put the slot in stopping state (draining play buffers) or
 * stop & detach if no data to drain.
 */
void
slot_stop(struct slot *s)
{
#ifdef DEBUG
	if (log_level >= 3) {
		slot_log(s);
		log_puts(": stopping\n");
	}
#endif
	if (s->pstate == SLOT_START) {
		if (s->mode & MODE_PLAY) {
			s->pstate = SLOT_READY;
			slot_ready(s);
		} else
			s->pstate = SLOT_INIT;
	}
	if (s->mode & MODE_RECMASK)
		abuf_done(&s->sub.buf);
	if (s->pstate == SLOT_READY) {
#ifdef DEBUG
		if (log_level >= 3) {
			slot_log(s);
			log_puts(": not drained (blocked by mmc)\n");
		}
#endif
		if (s->mode & MODE_PLAY)
			abuf_done(&s->mix.buf);
		s->ops->eof(s->arg);
		s->pstate = SLOT_INIT;
	} else {
		/* s->pstate == SLOT_RUN */
		if (s->mode & MODE_PLAY)
			s->pstate = SLOT_STOP;
		else {
			slot_detach(s);
			s->pstate = SLOT_INIT;
			s->ops->eof(s->arg);
		}
	}
	if (s->tstate != MMC_OFF)
		s->tstate = MMC_STOP;
}

void
slot_skip_update(struct slot *s)
{
	int skip;

	skip = slot_skip(s);
	while (skip > 0) {
#ifdef DEBUG
		if (log_level >= 4) {
			slot_log(s);
			log_puts(": catching skipped block\n");
		}
#endif
		if (s->mode & MODE_RECMASK)
			s->ops->flush(s->arg);
		if (s->mode & MODE_PLAY)
			s->ops->fill(s->arg);
		skip--;
	}
}

/*
 * notify the slot that we just wrote in the play buffer, must be called
 * after each write
 */
void
slot_write(struct slot *s)
{
	if (s->pstate == SLOT_START && s->mix.buf.used == s->mix.buf.len) {
#ifdef DEBUG
		if (log_level >= 4) {
			slot_log(s);
			log_puts(": switching to READY state\n");
		}
#endif
		s->pstate = SLOT_READY;
		slot_ready(s);
	}
	slot_skip_update(s);
}

/*
 * notify the slot that we freed some space in the rec buffer
 */
void
slot_read(struct slot *s)
{
	slot_skip_update(s);
}
@


1.27
log
@Many typos in comments. From Michael W. Bombardieri. Thanks.
@
text
@d1826 1
a1826 1
		if (s == NULL) {
@


1.26
log
@Set initial mixer slot name to "prog" to make all slots visible in
audioctl and alike.
@
text
@d1429 1
a1429 1
	 * create a ``valid'' control name (lowcase, remove [^a-z], trucate)
@


1.25
log
@Remove unused arguments of dev_adjpar(), getbasepath() and all
slotops->onvol() implementations. From David CARLIER <devnexen at
gmail.com>. Thanks.
@
text
@d1008 1
a1008 1
		d->slot[i].name[0] = '\0';
@


1.24
log
@unexpand tabs
@
text
@d30 1
a30 1
void zomb_onvol(void *, unsigned int);
d62 1
a62 1
void dev_adjpar(struct dev *, int, int, int, int, int);
d162 1
a162 1
zomb_onvol(void *arg, unsigned int vol)
d1024 1
a1024 1
    int pmin, int pmax, int rmin, int rmax)
@


1.23
log
@Make code fit in 80 columns, remove trailing spaces & tabs.
@
text
@d1645 1
a1645 1
	    	log_puts(": mode beyond device mode, not attaching\n");
@


1.22
log
@fix latest: don't set d->path as we just allocated it
@
text
@d550 1
a550 1
		s->skip--;		
d555 1
a555 1
int 
d585 1
a585 1
int 
d666 1
a666 1
int 
d695 1
a695 1
int 
d850 1
a850 1
		
d854 1
a854 1
		if (((s->mode & MODE_PLAY) && 
d920 1
a920 1
	struct slot *s, *snext;	
d1289 1
a1289 1
		/* 
d1293 1
a1293 1
		d->delta = 0; 
d1611 1
a1611 1
	
d1713 1
a1713 1
	
d1731 1
a1731 1
	 */	
d1772 1
a1772 1
		s->mix.bpf = s->par.bps * 
d1787 1
a1787 1
		s->sub.bpf = s->par.bps * 
d1832 1
a1832 1
	}	
@


1.21
log
@Allocate device names in the heap, so they can be generated.
@
text
@a990 1
	d->path = path;
@


1.20
log
@If the clock is ticking because of a MMC start message, then stop
it on exit. This avoids holding an extra ref to the device,
in turn preventing sndiod from exitting cleanly.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.19 2015/11/23 10:02:42 ratchov Exp $	*/
d979 1
d1262 1
@


1.19
log
@use device numbers stored in the dev structure rather than
assuming dev_list is ordered
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.18 2015/09/05 11:19:20 ratchov Exp $	*/
d1216 2
@


1.18
log
@typos in comments: xfree -> free
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.17 2014/06/02 07:51:25 ratchov Exp $	*/
d1226 1
a1226 1
		if (num-- == 0)
@


1.17
log
@log attach position only if log_level >= 0,
remove empty dev_mon_snoop() function
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.16 2014/03/17 17:53:33 ratchov Exp $	*/
d1455 1
a1455 1
	 * find a xfree controller slot with the same name/unit
d1473 1
a1473 1
	 * couldn't find a matching slot, pick oldest xfree slot
@


1.16
log
@Drop dev_clear(), merge dev_full_cycle() and dev_empty_cycle()
into dev_cycle(). No behavior change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.15 2014/03/17 17:16:06 ratchov Exp $	*/
a47 1
void dev_mon_snoop(struct dev *);
a554 9
/*
 * merge play buffer contents into record buffer as if the
 * play stream was recorded
 */
void
dev_mon_snoop(struct dev *d)
{
}

d1624 1
a1624 1
	if (log_level >= 0) {
@


1.15
log
@unbreak monitoring mode, which was shifted in time by 1 block
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.14 2014/03/07 10:23:05 ratchov Exp $	*/
a51 1
void dev_empty_cycle(struct dev *);
a55 1
void dev_full_cycle(struct dev *);
a73 1
void dev_clear(struct dev *);
a630 15
void
dev_empty_cycle(struct dev *d)
{
	unsigned char *base;
	int nsamp;

	base = (unsigned char *)DEV_PBUF(d);
	nsamp = d->round * d->pchan;
	memset(base, 0, nsamp * sizeof(adata_t));
	if (d->encbuf) {
		enc_do(&d->enc, (unsigned char *)DEV_PBUF(d),
		    d->encbuf, d->round);
	}
}

d744 4
d749 1
a749 1
dev_full_cycle(struct dev *d)
d755 36
d795 1
a795 1
		log_puts(": dev_full_cycle: clk=");
a962 32
void
dev_cycle(struct dev *d)
{
	if (d->slot_list == NULL && d->tstate != MMC_RUN) {
		if (log_level >= 2) {
			dev_log(d);
			log_puts(": device stopped\n");
		}
		dev_sio_stop(d);
		d->pstate = DEV_INIT;
		if (d->refcnt == 0)
			dev_close(d);
		else
			dev_clear(d);
		return;
	}
#ifdef DEBUG
	if (log_level >= 4) {
		dev_log(d);
		log_puts(": device cycle, prime = ");
		log_putu(d->prime);
		log_puts("\n");
	}
#endif
	if (d->prime > 0) {
		d->prime -= d->round;
		dev_empty_cycle(d);
	} else {
		dev_full_cycle(d);
	}
}

a1164 1
	dev_clear(d);
d1294 1
d1296 4
a1299 1
		/* empty cycles don't increment delta */
a1304 10
}

/*
 * Clear buffers of the play and record chains so that when the device
 * is started, playback and record start in sync.
 */
void
dev_clear(struct dev *d)
{
	d->poffs = 0;
@


1.14
log
@remove unused "delta" argument from onmove callbacks
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.13 2014/03/07 10:15:38 ratchov Exp $	*/
d742 1
a742 1
	int ocount;
d744 7
a750 1
	idata = (s->mode & MODE_MON) ? DEV_PBUF(d) : d->rbuf;
a871 5
		if (s->mode & MODE_PLAY) {
			dev_mix_badd(d, s);
			if (s->pstate != SLOT_STOP)
				s->ops->fill(s->arg);
		}
d888 5
a1102 1
		d->pbuf = xmalloc(d->bufsz * d->pchan * sizeof(adata_t));
d1104 2
@


1.13
log
@remove unused mmc start/stop/relocate call-backs as they don't
make sense for clients and are handled through midi anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.12 2014/03/05 20:31:22 ratchov Exp $	*/
d29 1
a29 1
void zomb_onmove(void *, int);
d161 1
a161 1
zomb_onmove(void *arg, int delta)
d915 1
a915 1
			s->ops->onmove(s->arg, delta);
@


1.12
log
@- properly set initial position: fixes incorrect position reporting
  on busy machines configured to use tiny block sizes
- run play and rec cycle in the same loop. No behavior change,
  but the code is much simpler this way.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.11 2014/03/05 20:24:16 ratchov Exp $	*/
a25 1
#include "opt.h"
a33 3
void zomb_mmcstart(void *);
void zomb_mmcstop(void *);
void zomb_mmcloc(void *, unsigned int);
a108 3
	zomb_mmcstart,
	zomb_mmcstop,
	zomb_mmcloc,
a194 15
zomb_mmcstart(void *arg)
{
}

void
zomb_mmcstop(void *arg)
{
}

void
zomb_mmcloc(void *arg, unsigned int pos)
{
}

void
a1394 3
	int i;
	struct slot *s;

a1411 13
	for (i = 0, s = d->slot; i < DEV_NSLOT; i++, s++) {
		if (!s->ops)
			continue;
		if (s->tstate == MMC_RUN) {
#ifdef DEBUG
			if (log_level >= 3) {
				slot_log(s);
				log_puts(": requested to stop\n");
			}
#endif
			s->ops->mmcstop(s->arg);
		}
	}
a1419 3
	int i;
	struct slot *s;

a1428 5
	for (i = 0, s = d->slot; i < DEV_NSLOT; i++, s++) {
		if (!s->ops)
			continue;
		s->ops->mmcloc(s->arg, d->mtc.origin);
	}
@


1.11
log
@remove unused "autostart" feature
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.10 2014/02/08 15:17:37 ratchov Exp $	*/
a57 1
void dev_mix_cycle(struct dev *);
d61 1
a61 1
void dev_sub_cycle(struct dev *);
d95 1
d98 1
a98 2
void slot_mix_drop(struct slot *);
void slot_sub_sil(struct slot *);
d543 2
a544 2
void
slot_mix_drop(struct slot *s)
d546 14
a559 1
	while (s->mix.drop > 0 && s->mix.buf.used >= s->round * s->mix.bpf) {
d563 1
a563 1
			log_puts(": dropped a play block\n");
d566 9
a574 19
		abuf_rdiscard(&s->mix.buf, s->round * s->mix.bpf);
		s->mix.drop--;
	}
}

void
slot_sub_sil(struct slot *s)
{
	unsigned char *data;
	int count;

	while (s->sub.silence > 0) {
		data = abuf_wgetblk(&s->sub.buf, &count);
		if (count < s->round * s->sub.bpf)
			break;
#ifdef DEBUG
		if (log_level >= 4) {
			slot_log(s);
			log_puts(": inserted a rec block of silence\n");
d576 1
a576 7
#endif
		if (s->sub.encbuf)
			enc_sil_do(&s->sub.enc, data, s->round);
		else
			memset(data, 0, s->round * s->sub.bpf);
		abuf_wcommit(&s->sub.buf, s->round * s->sub.bpf);
		s->sub.silence--;
d578 1
a715 93
void
dev_mix_cycle(struct dev *d)
{
	struct slot *s, **ps;
	unsigned char *base;
	int nsamp;

#ifdef DEBUG
	if (log_level >= 4) {
		dev_log(d);
		log_puts(": dev_mix_cycle, poffs = ");
		log_puti(d->poffs);
		log_puts("\n");
	}
#endif
	base = (unsigned char *)DEV_PBUF(d);
	nsamp = d->round * d->pchan;
	memset(base, 0, nsamp * sizeof(adata_t));
	ps = &d->slot_list;
	while ((s = *ps) != NULL) {
		if (!(s->mode & MODE_PLAY)) {
			ps = &s->next;
			continue;
		}
#ifdef DEBUG
		if (log_level >= 4) {
			slot_log(s);
			log_puts(": mixing, drop = ");
			log_puti(s->mix.drop);
			log_puts(" cycles\n");
		}
#endif		
		slot_mix_drop(s);
		if (s->mix.drop < 0) {
			s->mix.drop++;
			ps = &s->next;
			continue;
		}
		if (s->mix.buf.used < s->round * s->mix.bpf &&
		    s->pstate == SLOT_STOP) {
			/*
			 * partial blocks are zero-filled by socket
			 * layer
			 */
			s->pstate = SLOT_INIT;
			abuf_done(&s->mix.buf);
			if (s->mix.decbuf)
				xfree(s->mix.decbuf);
			if (s->mix.resampbuf)
				xfree(s->mix.resampbuf);
			s->ops->eof(s->arg);
			*ps = s->next;
			dev_mix_adjvol(d);
			continue;
		}
		if (s->mix.buf.used < s->round * s->mix.bpf &&
		    !(s->pstate == SLOT_STOP)) {
			if (s->xrun == XRUN_IGNORE) {
				if (s->mode & MODE_RECMASK)
					s->sub.silence--;
				s->delta -= s->round;
#ifdef DEBUG
				if (log_level >= 3) {
					slot_log(s);
					log_puts(": underrun, pause cycle\n");
				}
#endif
				ps = &s->next;
				continue;
			}
			if (s->xrun == XRUN_SYNC) {
				s->mix.drop++;
				ps = &s->next;
				continue;
			}
			if (s->xrun == XRUN_ERROR) {
				s->ops->exit(s->arg);
				*ps = s->next;
				continue;
			}
		} else {
			dev_mix_badd(d, s);
			if (s->pstate != SLOT_STOP)
				s->ops->fill(s->arg);
		}
		ps = &s->next;
	}
	if (d->encbuf) {
		enc_do(&d->enc, (unsigned char *)DEV_PBUF(d),
		    d->encbuf, d->round);
	}
}

d779 1
a779 1
dev_sub_cycle(struct dev *d)
d782 2
d785 1
d789 7
a795 1
		log_puts(": dev_sub_cycle\n");
d798 5
d807 15
a821 1
		if (!(s->mode & MODE_RECMASK) || s->pstate == SLOT_STOP) {
d825 27
a851 4
		slot_sub_sil(s);
		if (s->sub.silence < 0) {
			s->sub.silence++;
			ps = &s->next;
d854 16
a869 1
		if (s->sub.buf.len - s->sub.buf.used < s->round * s->sub.bpf) {
a870 2
				if (s->mode & MODE_PLAY)
					s->mix.drop--;
d872 26
d901 3
a903 1
					log_puts(": overrun, pause cycle\n");
d906 1
a906 2
				ps = &s->next;
				continue;
a907 13
			if (s->xrun == XRUN_SYNC) {
				s->sub.silence++;
				ps = &s->next;
				continue;
			}
			if (s->xrun == XRUN_ERROR) {
				s->ops->exit(s->arg);
				*ps = s->next;
				continue;
			}
		} else {
			dev_sub_bcopy(d, s);
			s->ops->flush(s->arg);
d911 4
d924 3
a926 1
	struct slot *s, *snext;
a927 3
	/*
	 * s->ops->onmove() may remove the slot
	 */
d929 3
d985 1
a985 4
		if (d->mode & MODE_RECMASK)
			dev_sub_cycle(d);
		if (d->mode & MODE_PLAY)
			dev_mix_cycle(d);
d1320 4
d1667 1
d1680 8
a1687 2
	s->delta = startpos;
	s->delta_rem = 0;
d1690 1
a1690 1
	if (log_level >= 3) {
d1694 2
d1714 1
a1743 1
		s->mix.drop = 0;
d1780 1
a1780 1
		s->sub.silence = startpos / (int)s->round;
d1959 21
a1986 2
	int drop;

d1997 1
a1997 12
	drop = s->mix.drop;
	slot_mix_drop(s);
	while (drop > s->mix.drop) {
#ifdef DEBUG
		if (log_level >= 4) {
			slot_log(s);
			log_puts(": catching play block\n");
		}
#endif
		s->ops->fill(s->arg);
		drop--;
	}
d2006 1
a2006 14
	int sil;

	sil = s->sub.silence;
	slot_sub_sil(s);
	while (sil > s->sub.silence) {
#ifdef DEBUG
		if (log_level >= 4) {
			slot_log(s);
			log_puts(": catching rec block\n");
		}
#endif
		s->ops->flush(s->arg);
		sil--;
	}
@


1.10
log
@copy the correct number of channels in join/expand
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.9 2013/12/31 12:27:49 ratchov Exp $	*/
a1049 1
	d->autostart = 0;
@


1.9
log
@Drop blocks and instert silence immediately in the socket rx/tx code
path rather than waiting for the next device cycle. This fixes deadocks
when the slot uses the SIO_SYNC mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.8 2013/12/20 08:47:37 ratchov Exp $	*/
d606 1
a606 1
	nch = s->mix.slot_cmax - s->mix.slot_cmin + 1;
a612 2
		if (offs > s->mix.cmap.inext)
			break;
a617 2
		if (offs > s->mix.cmap.onext)
			break;
d820 1
a820 1
	nch = s->sub.slot_cmax - s->sub.slot_cmin + 1;
@


1.8
log
@set the target device number of standard system exclusive
messages to 0x7f (aka "any device").
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.7 2013/11/18 17:37:45 ratchov Exp $	*/
d1973 2
d1985 12
d2005 14
a2018 1
	/* nothing yet */
@


1.7
log
@add missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.6 2013/05/05 20:42:53 ratchov Exp $	*/
d338 1
a338 1
	x.dev = 0x7f;
d375 1
d395 1
d421 1
a421 1
	x.dev = 0;
@


1.6
log
@Initialize channel ranges of new slots to full sub-device channels.
Fixes wrong channel mappings when the client specifies no channels.
Found by Dimitri Sokolyuk <sokolyuk at gmail.com>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.5 2013/05/05 09:50:21 ratchov Exp $	*/
a29 10
int  dev_open(struct dev *);
void dev_close(struct dev *);
void dev_clear(struct dev *);
void dev_master(struct dev *, unsigned int);

void slot_attach(struct slot *);
void slot_ready(struct slot *);
void slot_mix_drop(struct slot *);
void slot_sub_sil(struct slot *);

d40 7
d51 49
@


1.5
log
@Initialize client rate. Fixes crashes when the client doesn't set the
rate. Problem reported and analyzed by Dimitri Sokolyuk <sokolyuk at
gmail.com>. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.4 2013/02/26 22:52:08 ratchov Exp $	*/
d1562 1
a1562 1
	s->par = d->par;
d1564 2
a1565 2
		s->mix.slot_cmin = 0;
		s->mix.slot_cmax = d->pchan - 1;
d1568 3
a1570 3
		s->sub.slot_cmin = 0;
		s->sub.slot_cmax = ((s->mode & MODE_MON) ?
		    d->pchan : d->rchan) - 1;
d1577 1
@


1.4
log
@Encoding conversion buffer size is one stream block, not one device
block. Fix crashes occuring when the client sample frequency is much
larger than the device sample frequency. Found by Alexander Polakov,
thanks.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.3 2012/11/30 20:44:31 ratchov Exp $	*/
d1576 1
@


1.3
log
@When the audio device is closed, mark it as closed before
dropping connections otherwise clients may try to drain their
buffer and would attempt to reopen the device
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.2 2012/11/30 20:25:32 ratchov Exp $	*/
d1692 1
a1692 1
			    xmalloc(d->round * slot_nch * sizeof(adata_t));
d1731 1
a1731 1
			    xmalloc(d->round * slot_nch * sizeof(adata_t));
@


1.2
log
@don't exit if midi control port is destroyed (it never is)
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.1 2012/11/23 07:03:28 ratchov Exp $	*/
d80 5
d87 6
d97 1
a97 1
{	
d1135 2
a1136 1
	struct slot *s, *snext;
d1144 2
a1145 2
	while ((s = d->slot_list) != NULL) {
		snext = s->next;
a1148 1
		d->slot_list = snext;
d1150 1
a1162 1
	d->pstate = DEV_CFG;
d1748 6
@


1.1
log
@Remplace aucat server by a new sndiod daemon aimed to be simpler
smaller and faster than aucat. It's a drop in replacement with the
following exceptions that don't affect the default setup:
  - The sample rate and the encoding are a per-device parameters
    thus -r and -e options must precede the corresponding -f option
  - MIDI thru boxes are dynamically created and no -M option
    is required anymore, so -M was removed.
  - MIDI ports are exposed with a new ``midi/N'' name, rather
    than abusing MIDI thru boxes.
with help from armani@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d469 1
a469 7
#ifdef DEBUG
	struct dev *d = arg;

	dev_log(d);
	log_puts(": can't receive fill input\n");
	panic();
#endif
@

