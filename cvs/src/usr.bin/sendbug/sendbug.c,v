head	1.78;
access;
symbols
	OPENBSD_6_2:1.78.0.4
	OPENBSD_6_2_BASE:1.78
	OPENBSD_6_1:1.77.0.4
	OPENBSD_6_1_BASE:1.77
	OPENBSD_6_0:1.76.0.2
	OPENBSD_6_0_BASE:1.76
	OPENBSD_5_9:1.73.0.2
	OPENBSD_5_9_BASE:1.73
	OPENBSD_5_8:1.69.0.6
	OPENBSD_5_8_BASE:1.69
	OPENBSD_5_7:1.69.0.2
	OPENBSD_5_7_BASE:1.69
	OPENBSD_5_6:1.68.0.4
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.67.0.10
	OPENBSD_5_5_BASE:1.67
	OPENBSD_5_4:1.67.0.6
	OPENBSD_5_4_BASE:1.67
	OPENBSD_5_3:1.67.0.4
	OPENBSD_5_3_BASE:1.67
	OPENBSD_5_2:1.67.0.2
	OPENBSD_5_2_BASE:1.67
	OPENBSD_5_1_BASE:1.66
	OPENBSD_5_1:1.66.0.8
	OPENBSD_5_0:1.66.0.6
	OPENBSD_5_0_BASE:1.66
	OPENBSD_4_9:1.66.0.4
	OPENBSD_4_9_BASE:1.66
	OPENBSD_4_8:1.66.0.2
	OPENBSD_4_8_BASE:1.66
	OPENBSD_4_7:1.63.0.2
	OPENBSD_4_7_BASE:1.63
	OPENBSD_4_6:1.62.0.4
	OPENBSD_4_6_BASE:1.62
	OPENBSD_4_5:1.60.0.2
	OPENBSD_4_5_BASE:1.60
	OPENBSD_4_4:1.57.0.2
	OPENBSD_4_4_BASE:1.57
	OPENBSD_4_3:1.54.0.2
	OPENBSD_4_3_BASE:1.54
	OPENBSD_4_2:1.50.0.2
	OPENBSD_4_2_BASE:1.50
	SENDBUG_4_2:1.1.1.1
	RAY_20070322:1.1.1;
locks; strict;
comment	@ * @;


1.78
date	2017.08.21.21.41.13;	author deraadt;	state Exp;
branches;
next	1.77;
commitid	GetnLYY8Up3nxFbI;

1.77
date	2016.10.18.20.07.35;	author kettenis;	state Exp;
branches;
next	1.76;
commitid	XqvfyBgyxJMxxpUA;

1.76
date	2016.05.18.19.10.26;	author jca;	state Exp;
branches;
next	1.75;
commitid	iMXsjuKWJgZt9JL7;

1.75
date	2016.05.18.19.06.25;	author jca;	state Exp;
branches;
next	1.74;
commitid	GPGJH9ymqVIyQMgS;

1.74
date	2016.03.17.19.40.43;	author krw;	state Exp;
branches;
next	1.73;
commitid	aCmYZrmRmWHLuztW;

1.73
date	2015.10.26.13.12.10;	author deraadt;	state Exp;
branches;
next	1.72;
commitid	FsuttQ3mQPJ0Whip;

1.72
date	2015.10.11.21.23.15;	author deraadt;	state Exp;
branches;
next	1.71;
commitid	nRFt8M7uFiSWsGQ1;

1.71
date	2015.10.10.20.35.01;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	m38BXhkh3XknrpM6;

1.70
date	2015.10.10.19.10.20;	author deraadt;	state Exp;
branches;
next	1.69;
commitid	Mm5mju6HDKP2Du8B;

1.69
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.68;
commitid	Uu5nFG3wCl0LACBb;

1.68
date	2014.03.18.22.36.37;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2012.07.21.19.55.17;	author phessler;	state Exp;
branches;
next	1.66;

1.66
date	2010.04.20.21.33.25;	author sthen;	state Exp;
branches;
next	1.65;

1.65
date	2010.04.20.19.05.03;	author sthen;	state Exp;
branches;
next	1.64;

1.64
date	2010.03.23.19.19.53;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2009.08.26.20.40.40;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2009.06.07.15.36.45;	author ray;	state Exp;
branches;
next	1.61;

1.61
date	2009.06.06.04.46.26;	author ray;	state Exp;
branches;
next	1.60;

1.60
date	2009.01.28.20.43.24;	author ray;	state Exp;
branches;
next	1.59;

1.59
date	2008.12.14.07.46.24;	author ray;	state Exp;
branches;
next	1.58;

1.58
date	2008.10.06.04.58.37;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2008.06.14.20.45.45;	author pvalchev;	state Exp;
branches;
next	1.56;

1.56
date	2008.05.08.00.10.46;	author chl;	state Exp;
branches;
next	1.55;

1.55
date	2008.04.19.09.22.31;	author ray;	state Exp;
branches;
next	1.54;

1.54
date	2008.01.04.00.50.09;	author ray;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.03.03.19.36;	author ray;	state Exp;
branches;
next	1.52;

1.52
date	2007.10.17.20.02.33;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2007.09.18.00.38.58;	author ray;	state Exp;
branches;
next	1.50;

1.50
date	2007.07.31.03.44.21;	author ray;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.11.02.07.47;	author ray;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.11.02.00.49;	author ray;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.09.02.36.56;	author ray;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.07.02.11.12;	author ray;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.06.05.01.19;	author ray;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.06.04.50.26;	author ray;	state Exp;
branches;
next	1.43;

1.43
date	2007.04.25.04.56.14;	author ray;	state Exp;
branches;
next	1.42;

1.42
date	2007.04.07.04.58.50;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2007.04.07.00.40.43;	author ray;	state Exp;
branches;
next	1.40;

1.40
date	2007.04.07.00.24.59;	author ray;	state Exp;
branches;
next	1.39;

1.39
date	2007.04.06.21.51.09;	author ray;	state Exp;
branches;
next	1.38;

1.38
date	2007.04.06.20.29.18;	author ray;	state Exp;
branches;
next	1.37;

1.37
date	2007.04.06.07.24.53;	author ray;	state Exp;
branches;
next	1.36;

1.36
date	2007.04.06.03.24.08;	author ray;	state Exp;
branches;
next	1.35;

1.35
date	2007.04.06.01.32.39;	author ray;	state Exp;
branches;
next	1.34;

1.34
date	2007.03.28.04.05.52;	author ray;	state Exp;
branches;
next	1.33;

1.33
date	2007.03.27.04.15.00;	author ray;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.27.03.40.44;	author ray;	state Exp;
branches;
next	1.31;

1.31
date	2007.03.26.18.13.08;	author moritz;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.26.07.16.11;	author ray;	state Exp;
branches;
next	1.29;

1.29
date	2007.03.26.07.06.03;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2007.03.26.06.47.00;	author ray;	state Exp;
branches;
next	1.27;

1.27
date	2007.03.26.06.40.01;	author ray;	state Exp;
branches;
next	1.26;

1.26
date	2007.03.26.06.22.12;	author ray;	state Exp;
branches;
next	1.25;

1.25
date	2007.03.26.05.50.18;	author ray;	state Exp;
branches;
next	1.24;

1.24
date	2007.03.26.05.39.51;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2007.03.26.05.34.30;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2007.03.26.05.17.53;	author ray;	state Exp;
branches;
next	1.21;

1.21
date	2007.03.26.01.35.36;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.03.25.23.35.59;	author ray;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.25.23.27.38;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.25.23.23.29;	author ray;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.25.23.21.11;	author ray;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.25.23.18.56;	author ray;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.23.17.18.07;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.23.15.46.40;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.23.06.16.24;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.23.05.08.03;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.23.03.43.46;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.23.03.35.01;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.23.03.30.52;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.23.03.19.30;	author ray;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.23.03.13.22;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.23.02.46.32;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.23.02.45.21;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.23.02.41.02;	author ray;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.23.02.28.14;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.23.02.11.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.23.01.47.11;	author ray;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.03.23.01.47.11;	author ray;	state Exp;
branches;
next	;


desc
@@


1.78
log
@Use waitpid()/EINTR idiom for the specific pid, rather than generic wait(),
in case the parent process was started with a dangling child.  This style
ensures any potential parent:child interlock isn't disrupted due to the
"wrong" child being waited on first.  Then the other other childs can safely
zombie.
ok millert jca brynet
@
text
@/*	$OpenBSD: sendbug.c,v 1.77 2016/10/18 20:07:35 kettenis Exp $	*/

/*
 * Written by Ray Lai <ray@@cyth.net>.
 * Public domain.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <sys/wait.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "atomicio.h"

#define _PATH_DMESG "/var/run/dmesg.boot"
#define DMESG_START "OpenBSD "
#define BEGIN64 "begin-base64 "
#define END64 "===="

void	checkfile(const char *);
void	debase(void);
void	dmesg(FILE *);
int	editit(const char *);
void	hwdump(FILE *);
void	init(void);
int	matchline(const char *, const char *, size_t);
int	prompt(void);
int	send_file(const char *, int);
int	sendmail(const char *);
void	template(FILE *);
void	usbdevs(FILE *);

const char *categories = "system user library documentation kernel "
    "alpha amd64 arm hppa i386 m88k mips64 powerpc sh sparc sparc64 vax";
const char *comment[] = {
	"<synopsis of the problem (one line)>",
	"<PR category (one line)>",
	"<precise description of the problem (multiple lines)>",
	"<code/input/activities to reproduce the problem (multiple lines)>",
	"<how to correct or work around the problem, if known (multiple lines)>"
};

struct passwd *pw;
char os[BUFSIZ], rel[BUFSIZ], mach[BUFSIZ], details[BUFSIZ];
const char *tmpdir = _PATH_TMP;
char *tmppath;
int Dflag, Pflag, wantcleanup;

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-DEP]\n", __progname);
	exit(1);
}

void
cleanup()
{
	if (wantcleanup && tmppath && unlink(tmppath) == -1)
		warn("unlink");
}


int
main(int argc, char *argv[])
{
	int ch, c, fd, ret = 1;
	struct stat sb;
	char *pr_form;
	time_t mtime;
	FILE *fp;

	if (pledge("stdio rpath wpath cpath tmppath getpw proc exec", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "DEP")) != -1)
		switch (ch) {
		case 'D':
			Dflag = 1;
			break;
		case 'E':
			debase();
			exit(0);
		case 'P':
			Pflag = 1;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (argc > 0)
		usage();

	if (Pflag) {
		init();
		template(stdout);
		exit(0);
	}

	if (asprintf(&tmppath, "%s%sp.XXXXXXXXXX", tmpdir,
	    tmpdir[strlen(tmpdir) - 1] == '/' ? "" : "/") == -1)
		err(1, "asprintf");
	if ((fd = mkstemp(tmppath)) == -1)
		err(1, "mkstemp");
	wantcleanup = 1;
	atexit(cleanup);
	if ((fp = fdopen(fd, "w+")) == NULL)
		err(1, "fdopen");

	init();

	pr_form = getenv("PR_FORM");
	if (pr_form) {
		char buf[BUFSIZ];
		size_t len;
		FILE *frfp;

		frfp = fopen(pr_form, "r");
		if (frfp == NULL) {
			warn("can't seem to read your template file "
			    "(`%s'), ignoring PR_FORM", pr_form);
			template(fp);
		} else {
			while (!feof(frfp)) {
				len = fread(buf, 1, sizeof buf, frfp);
				if (len == 0)
					break;
				if (fwrite(buf, 1, len, fp) != len)
					break;
			}
			fclose(frfp);
		}
	} else
		template(fp);

	if (fflush(fp) == EOF || fstat(fd, &sb) == -1 || fclose(fp) == EOF)
		err(1, "error creating template");
	mtime = sb.st_mtime;

 edit:
	if (editit(tmppath) == -1)
		err(1, "error running editor");

	if (stat(tmppath, &sb) == -1)
		err(1, "stat");
	if (mtime == sb.st_mtime)
		errx(1, "report unchanged, nothing sent");

 prompt:
	checkfile(tmppath);
	c = prompt();
	switch (c) {
	case 'a':
	case EOF:
		wantcleanup = 0;
		errx(1, "unsent report in %s", tmppath);
	case 'e':
		goto edit;
	case 's':
		if (sendmail(tmppath) == -1)
			goto quit;
		break;
	default:
		goto prompt;
	}

	ret = 0;
quit:
	return (ret);
}

void
dmesg(FILE *fp)
{
	char buf[BUFSIZ];
	FILE *dfp;
	off_t offset = -1;

	dfp = fopen(_PATH_DMESG, "r");
	if (dfp == NULL) {
		warn("can't read dmesg");
		return;
	}

	/* Find last dmesg. */
	for (;;) {
		off_t o;

		o = ftello(dfp);
		if (fgets(buf, sizeof(buf), dfp) == NULL)
			break;
		if (!strncmp(DMESG_START, buf, sizeof(DMESG_START) - 1))
			offset = o;
	}
	if (offset != -1) {
		size_t len;

		clearerr(dfp);
		fseeko(dfp, offset, SEEK_SET);
		while (offset != -1 && !feof(dfp)) {
			len = fread(buf, 1, sizeof buf, dfp);
			if (len == 0)
				break;
			if (fwrite(buf, 1, len, fp) != len)
				break;
		}
	}
	fclose(dfp);
}

void
usbdevs(FILE *ofp)
{
	char buf[BUFSIZ];
	FILE *ifp;
	size_t len;

	if ((ifp = popen("usbdevs -v", "r")) != NULL) {
		while (!feof(ifp)) {
			len = fread(buf, 1, sizeof buf, ifp);
			if (len == 0)
				break;
			if (fwrite(buf, 1, len, ofp) != len)
				break;
		}
		pclose(ifp);
	}
}

/*
 * Execute an editor on the specified pathname, which is interpreted
 * from the shell.  This means flags may be included.
 *
 * Returns -1 on error, or the exit value on success.
 */
int
editit(const char *pathname)
{
	char *argp[] = {"sh", "-c", NULL, NULL}, *ed, *p;
	sig_t sighup, sigint, sigquit, sigchld;
	pid_t pid;
	int saved_errno, st, ret = -1;

	ed = getenv("VISUAL");
	if (ed == NULL || ed[0] == '\0')
		ed = getenv("EDITOR");
	if (ed == NULL || ed[0] == '\0')
		ed = _PATH_VI;
	if (asprintf(&p, "%s %s", ed, pathname) == -1)
		return (-1);
	argp[2] = p;

	sighup = signal(SIGHUP, SIG_IGN);
	sigint = signal(SIGINT, SIG_IGN);
	sigquit = signal(SIGQUIT, SIG_IGN);
	sigchld = signal(SIGCHLD, SIG_DFL);
	if ((pid = fork()) == -1)
		goto fail;
	if (pid == 0) {
		execv(_PATH_BSHELL, argp);
		_exit(127);
	}
	while (waitpid(pid, &st, 0) == -1) {
		if (errno != EINTR)
			goto fail;
	}
	if (!WIFEXITED(st))
		errno = EINTR;
	else
		ret = WEXITSTATUS(st);

 fail:
	saved_errno = errno;
	(void)signal(SIGHUP, sighup);
	(void)signal(SIGINT, sigint);
	(void)signal(SIGQUIT, sigquit);
	(void)signal(SIGCHLD, sigchld);
	free(p);
	errno = saved_errno;
	return (ret);
}

int
prompt(void)
{
	int c, ret;

	fpurge(stdin);
	fprintf(stderr, "a)bort, e)dit, or s)end: ");
	fflush(stderr);
	ret = getchar();
	if (ret == EOF || ret == '\n')
		return (ret);
	do {
		c = getchar();
	} while (c != EOF && c != '\n');
	return (ret);
}

int
sendmail(const char *pathname)
{
	int filedes[2];
	pid_t pid;

	if (pipe(filedes) == -1) {
		warn("pipe: unsent report in %s", pathname);
		return (-1);
	}
	switch ((pid = fork())) {
	case -1:
		warn("fork error: unsent report in %s",
		    pathname);
		return (-1);
	case 0:
		close(filedes[1]);
		if (dup2(filedes[0], STDIN_FILENO) == -1) {
			warn("dup2 error: unsent report in %s",
			    pathname);
			return (-1);
		}
		close(filedes[0]);
		execl(_PATH_SENDMAIL, "sendmail",
		    "-oi", "-t", (char *)NULL);
		warn("sendmail error: unsent report in %s",
		    pathname);
		return (-1);
	default:
		close(filedes[0]);
		/* Pipe into sendmail. */
		if (send_file(pathname, filedes[1]) == -1) {
			warn("send_file error: unsent report in %s",
			    pathname);
			return (-1);
		}
		close(filedes[1]);
		while (waitpid(pid, NULL, 0) == -1) {
			if (errno != EINTR)
				break;
		}
		break;
	}
	return (0);
}

void
init(void)
{
	size_t len;
	int sysname[2];
	char *cp;

	if ((pw = getpwuid(getuid())) == NULL)
		err(1, "getpwuid");

	sysname[0] = CTL_KERN;
	sysname[1] = KERN_OSTYPE;
	len = sizeof(os) - 1;
	if (sysctl(sysname, 2, &os, &len, NULL, 0) == -1)
		err(1, "sysctl");

	sysname[0] = CTL_KERN;
	sysname[1] = KERN_OSRELEASE;
	len = sizeof(rel) - 1;
	if (sysctl(sysname, 2, &rel, &len, NULL, 0) == -1)
		err(1, "sysctl");

	sysname[0] = CTL_KERN;
	sysname[1] = KERN_VERSION;
	len = sizeof(details) - 1;
	if (sysctl(sysname, 2, &details, &len, NULL, 0) == -1)
		err(1, "sysctl");

	cp = strchr(details, '\n');
	if (cp) {
		cp++;
		if (*cp)
			*cp++ = '\t';
		if (*cp)
			*cp++ = '\t';
		if (*cp)
			*cp++ = '\t';
	}

	sysname[0] = CTL_HW;
	sysname[1] = HW_MACHINE;
	len = sizeof(mach) - 1;
	if (sysctl(sysname, 2, &mach, &len, NULL, 0) == -1)
		err(1, "sysctl");
}

int
send_file(const char *file, int dst)
{
	size_t len;
	char *buf, *lbuf;
	FILE *fp;
	int rval = -1, saved_errno;

	if ((fp = fopen(file, "r")) == NULL)
		return (-1);
	lbuf = NULL;
	while ((buf = fgetln(fp, &len))) {
		if (buf[len - 1] == '\n') {
			buf[len - 1] = '\0';
			--len;
		} else {
			/* EOF without EOL, copy and add the NUL */
			if ((lbuf = malloc(len + 1)) == NULL)
				goto end;
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}

		/* Skip lines starting with "SENDBUG". */
		if (strncmp(buf, "SENDBUG", sizeof("SENDBUG") - 1) == 0)
			continue;
		while (len) {
			char *sp = NULL, *ep = NULL;
			size_t copylen;

			if ((sp = strchr(buf, '<')) != NULL) {
				size_t i;

				for (i = 0; i < sizeof(comment) / sizeof(*comment); ++i) {
					size_t commentlen = strlen(comment[i]);

					if (strncmp(sp, comment[i], commentlen) == 0) {
						ep = sp + commentlen - 1;
						break;
					}
				}
			}
			/* Length of string before comment. */
			if (ep)
				copylen = sp - buf;
			else
				copylen = len;
			if (atomicio(vwrite, dst, buf, copylen) != copylen)
				goto end;
			if (!ep)
				break;
			/* Skip comment. */
			len -= ep - buf + 1;
			buf = ep + 1;
		}
		if (atomicio(vwrite, dst, "\n", 1) != 1)
			goto end;
	}
	rval = 0;
 end:
	saved_errno = errno;
	free(lbuf);
	fclose(fp);
	errno = saved_errno;
	return (rval);
}

/*
 * Does line start with `s' and end with non-comment and non-whitespace?
 * Note: Does not treat `line' as a C string.
 */
int
matchline(const char *s, const char *line, size_t linelen)
{
	size_t slen;
	int iscomment;

	slen = strlen(s);
	/* Is line shorter than string? */
	if (linelen <= slen)
		return (0);
	/* Does line start with string? */
	if (memcmp(line, s, slen) != 0)
		return (0);
	/* Does line contain anything but comments and whitespace? */
	line += slen;
	linelen -= slen;
	iscomment = 0;
	while (linelen) {
		if (iscomment) {
			if (*line == '>')
				iscomment = 0;
		} else if (*line == '<')
			iscomment = 1;
		else if (!isspace((unsigned char)*line))
			return (1);
		++line;
		--linelen;
	}
	return (0);
}

/*
 * Are all required fields filled out?
 */
void
checkfile(const char *pathname)
{
	FILE *fp;
	size_t len;
	int category = 0, synopsis = 0, subject = 0;
	char *buf;

	if ((fp = fopen(pathname, "r")) == NULL) {
		warn("%s", pathname);
		return;
	}
	while ((buf = fgetln(fp, &len))) {
		if (matchline(">Category:", buf, len))
			category = 1;
		else if (matchline(">Synopsis:", buf, len))
			synopsis = 1;
		else if (matchline("Subject:", buf, len))
			subject = 1;
	}
	fclose(fp);
	if (!category || !synopsis || !subject) {
		fprintf(stderr, "Some fields are blank, please fill them in: ");
		if (!subject)
			fprintf(stderr, "Subject ");
		if (!synopsis)
			fprintf(stderr, "Synopsis ");
		if (!category)
			fprintf(stderr, "Category ");
		fputc('\n', stderr);
	}
}

void
template(FILE *fp)
{
	fprintf(fp, "SENDBUG: -*- sendbug -*-\n");
	fprintf(fp, "SENDBUG: Lines starting with `SENDBUG' will"
	    " be removed automatically.\n");
	fprintf(fp, "SENDBUG:\n");
	fprintf(fp, "SENDBUG: Choose from the following categories:\n");
	fprintf(fp, "SENDBUG:\n");
	fprintf(fp, "SENDBUG: %s\n", categories);
	fprintf(fp, "SENDBUG:\n");
	fprintf(fp, "SENDBUG:\n");
	fprintf(fp, "To: %s\n", "bugs@@openbsd.org");
	fprintf(fp, "Subject: \n");
	fprintf(fp, "From: %s\n", pw->pw_name);
	fprintf(fp, "Cc: %s\n", pw->pw_name);
	fprintf(fp, "Reply-To: %s\n", pw->pw_name);
	fprintf(fp, "\n");
	fprintf(fp, ">Synopsis:\t%s\n", comment[0]);
	fprintf(fp, ">Category:\t%s\n", comment[1]);
	fprintf(fp, ">Environment:\n");
	fprintf(fp, "\tSystem      : %s %s\n", os, rel);
	fprintf(fp, "\tDetails     : %s\n", details);
	fprintf(fp, "\tArchitecture: %s.%s\n", os, mach);
	fprintf(fp, "\tMachine     : %s\n", mach);
	fprintf(fp, ">Description:\n");
	fprintf(fp, "\t%s\n", comment[2]);
	fprintf(fp, ">How-To-Repeat:\n");
	fprintf(fp, "\t%s\n", comment[3]);
	fprintf(fp, ">Fix:\n");
	fprintf(fp, "\t%s\n", comment[4]);

	if (!Dflag) {
		int root;

		fprintf(fp, "\n");
		root = !geteuid();
		if (!root)
			fprintf(fp, "SENDBUG: Run sendbug as root "
			    "if this is an ACPI report!\n");
		fprintf(fp, "SENDBUG: dmesg%s and usbdevs are attached.\n"
		    "SENDBUG: Feel free to delete or use the -D flag if they "
		    "contain sensitive information.\n",
		    root ? ", pcidump, acpidump" : "");
		fputs("\ndmesg:\n", fp);
		dmesg(fp);
		fputs("\nusbdevs:\n", fp);
		usbdevs(fp);
		if (root)
			hwdump(fp);
	}
}

void
hwdump(FILE *ofp)
{
	char buf[BUFSIZ];
	FILE *ifp;
	char *cmd, *acpidir;
	size_t len;

	if (asprintf(&acpidir, "%s%sp.XXXXXXXXXX", tmpdir,
	    tmpdir[strlen(tmpdir) - 1] == '/' ? "" : "/") == -1)
		err(1, "asprintf");
	if (mkdtemp(acpidir) == NULL)
		err(1, "mkdtemp");

	if (asprintf(&cmd, "echo \"\\npcidump:\"; pcidump -xxv; "
	    "echo \"\\nacpidump:\"; cd %s && cp /var/db/acpi/* .; "
	    "for i in *; do b64encode $i $i; done; rm -rf %s",
	    acpidir, acpidir) == -1)
		err(1, "asprintf");

	if ((ifp = popen(cmd, "r")) != NULL) {
		while (!feof(ifp)) {
			len = fread(buf, 1, sizeof buf, ifp);
			if (len == 0)
				break;
			if (fwrite(buf, 1, len, ofp) != len)
				break;
		}
		pclose(ifp);
	}
	free(cmd);
	free(acpidir);
}

void
debase(void)
{
	char buf[BUFSIZ];
	FILE *fp = NULL;
	size_t len;

	while (fgets(buf, sizeof(buf), stdin) != NULL) {
		len = strlen(buf);
		if (!strncmp(buf, BEGIN64, sizeof(BEGIN64) - 1)) {
			if (fp)
				errx(1, "double begin");
			fp = popen("b64decode", "w");
			if (!fp)
				errx(1, "popen b64decode");
		}
		if (fp && fwrite(buf, 1, len, fp) != len)
			errx(1, "pipe error");
		if (!strncmp(buf, END64, sizeof(END64) - 1)) {
			if (pclose(fp) == -1)
				errx(1, "pclose b64decode");
			fp = NULL;
		}
	}
}
@


1.77
log
@Use the files in /var/db/acpi instead of trying to run acpidump.

ok brynet@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.76 2016/05/18 19:10:26 jca Exp $	*/
d280 1
a280 1
	while (waitpid(pid, &st, 0) == -1)
d283 1
d321 1
d327 1
a327 1
	switch (fork()) {
d354 4
a357 1
		wait(NULL);
@


1.76
log
@Also print a warning if the user doesn't fill the mail Subject

Alternative diff by Tim (trondd ! kagu-tsuchi . com), ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.74 2016/03/17 19:40:43 krw Exp $	*/
a603 4
	if (gethostname(buf, sizeof(buf)) == -1)
		err(1, "gethostname");
	buf[strcspn(buf, ".")] = '\0';

d611 1
a611 1
	    "echo \"\\nacpidump:\"; cd %s && acpidump -o %s; "
d613 1
a613 1
	    acpidir, buf, acpidir) == -1)
@


1.75
log
@Print a user-friendly message if some fields are missing; ok tedu@@
@
text
@d515 1
a515 1
	int category = 0, synopsis = 0;
d527 2
d531 1
a531 1
	if (!category || !synopsis) {
d533 2
@


1.74
log
@Last parameter to execl[e]() functions *must* be cast to a pointer.
Just NULL is not good practise as NULL is theoretically allowed to
be an integer rather than a pointer.

Use (char *)NULL consistently instead of scattering a few (char *)0
and (void *)NULL into the mix.

Prompted by and probably ok deraadt@@ millert@@ kettenis@@

Definitely ok mestre@@ ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.73 2015/10/26 13:12:10 deraadt Exp $	*/
d33 1
a33 1
int	checkfile(const char *);
d167 1
a167 2
	if (!checkfile(tmppath))
		fprintf(stderr, "fields are blank, must be filled in\n");
d510 1
a510 1
int
d520 1
a520 1
		return (0);
d529 8
a536 1
	return (category && synopsis);
@


1.73
log
@remove TMPDIR support
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.72 2015/10/11 21:23:15 deraadt Exp $	*/
d340 1
a340 1
		    "-oi", "-t", (void *)NULL);
@


1.72
log
@-version options on commands like this make no sense; the version number
makes no promises about compatibility nor the lack of compatibility.
suggestion & diff from micheal reed
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.71 2015/10/10 20:35:01 deraadt Exp $	*/
d58 1
a58 1
const char *tmpdir;
a109 3

	if ((tmpdir = getenv("TMPDIR")) == NULL || tmpdir[0] == '\0')
		tmpdir = _PATH_TMP;
@


1.71
log
@normalize a few more tame request orderings, to help review
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.70 2015/10/10 19:10:20 deraadt Exp $	*/
a47 1
char *version = "5.5";
d67 1
a67 1
	fprintf(stderr, "usage: %s [-DEPV]\n", __progname);
d91 1
a91 1
	while ((ch = getopt(argc, argv, "DEPV")) != -1)
a101 3
		case 'V':
			printf("%s\n", version);
			exit(0);
@


1.70
log
@pledge "stdio getpw rpath wpath cpath tmppath proc exec". doug pointed out
the need for getpw.  Not sure if I see ways to improve this program.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.69 2015/01/16 06:40:11 deraadt Exp $	*/
d89 1
a89 1
	if (pledge("stdio getpw rpath wpath cpath tmppath proc exec", NULL) == -1)
@


1.69
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.68 2014/03/18 22:36:37 miod Exp $	*/
d88 3
@


1.68
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.67 2012/07/21 19:55:17 phessler Exp $	*/
a8 1
#include <sys/param.h>
@


1.67
log
@Have sendbug(1) submit error reports to bugs@@, instead of gnats@@.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.66 2010/04/20 21:33:25 sthen Exp $	*/
d48 2
a49 2
    "alpha amd64 arm hppa i386 m68k m88k mips64 powerpc sh sparc sparc64 vax";
char *version = "4.2";
@


1.66
log
@Fix some pclose() calls, spotted by Peter Philipp. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.65 2010/04/20 19:05:03 sthen Exp $	*/
d550 1
a550 1
	fprintf(fp, "To: %s\n", "gnats@@openbsd.org");
@


1.65
log
@Include usbdevs -v output in the PR template, showing us device IDs which
cannot be deduced from the dmesg output.  Suggested by miod@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.64 2010/03/23 19:19:53 deraadt Exp $	*/
d249 1
a249 1
		pclose(ofp);
a250 1
	pclose(ifp);
d623 1
a623 1
		pclose(ofp);
a624 1
	pclose(ifp);
@


1.64
log
@fixes memory and FILE handle leaks.  `acpidir' is allocated via
asprintf(3) and `ifp' is opened via popen(3), but not closed.
from zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.63 2009/08/26 20:40:40 deraadt Exp $	*/
d45 1
d234 20
d579 4
a582 4
		fprintf(fp, "SENDBUG: dmesg%s attached.\n"
		    "SENDBUG: Feel free to delete or use the -D flag if it "
		    "contains sensitive information.\n",
		    root ? ", pcidump, and acpidump are" : " is");
d585 2
@


1.63
log
@initialize tmpdir before use; PR 6214
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.62 2009/06/07 15:36:45 ray Exp $	*/
d603 1
d605 1
@


1.62
log
@Remove gecos expanding code, since the expanded string is no longer
used.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.61 2009/06/06 04:46:26 ray Exp $	*/
d112 3
a120 2
	if ((tmpdir = getenv("TMPDIR")) == NULL || tmpdir[0] == '\0')
		tmpdir = _PATH_TMP;
@


1.61
log
@Include pcidump and acpidump output when sendbug is run as root,
to aid ACPI development.  Output files are base64 encoded in the
report.

Add a -E flag to decode files from a report to the current directory.

Requested by deraadt, "Sweet!" marco, "Looks good to me." pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.60 2009/01/28 20:43:24 ray Exp $	*/
d60 1
a60 1
char *fullname, *tmppath;
d346 1
a346 1
	size_t amp, len, gecoslen, namelen;
d348 1
a348 1
	char ch, *cp;
a351 34
	namelen = strlen(pw->pw_name);

	/* Count number of '&'. */
	for (amp = 0, cp = pw->pw_gecos; *cp && *cp != ','; ++cp)
		if (*cp == '&')
			++amp;

	/* Truncate gecos to full name. */
	gecoslen = cp - pw->pw_gecos;
	pw->pw_gecos[gecoslen] = '\0';

	/* Expanded str = orig str - '&' chars + concatenated logins. */
	len = gecoslen - amp + (amp * namelen) + 1;
	if ((fullname = malloc(len)) == NULL)
		err(1, "malloc");

	/* Upper case first char of login. */
	ch = pw->pw_name[0];
	pw->pw_name[0] = toupper((unsigned char)pw->pw_name[0]);

	cp = pw->pw_gecos;
	fullname[0] = '\0';
	while (cp != NULL) {
		char *token;

		token = strsep(&cp, "&");
		if (token != pw->pw_gecos &&
		    strlcat(fullname, pw->pw_name, len) >= len)
			errx(1, "truncated string");
		if (strlcat(fullname, token, len) >= len)
			errx(1, "truncated string");
	}
	/* Restore case of first char of login. */
	pw->pw_name[0] = ch;
@


1.60
log
@Re-add "Category" category to sendbug template. Without it, reports
were categorized as "pending" and the report was never acked.

Reported by RD Thrush and bernd@@, OK miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.58 2008/10/06 04:58:37 deraadt Exp $	*/
d31 2
d35 1
d38 1
d59 1
d68 1
a68 1
	fprintf(stderr, "usage: %s [-DPV]\n", __progname);
a83 1
	const char *tmpdir;
d89 1
a89 1
	while ((ch = getopt(argc, argv, "DPV")) != -1)
d94 3
a205 4
	fputs("\n"
	    "SENDBUG: dmesg is attached.\n"
	    "SENDBUG: Feel free to delete or use the -D flag if it contains "
	    "sensitive information.\n", fp);
d583 13
a595 1
	if (!Dflag)
d597 66
@


1.59
log
@Remove useless fields from template, they just serve to confuse
users.

Idea okayed by art and deraadt, feedback from jmc.
@
text
@d42 2
d47 1
d531 1
a531 1
	int rval = 0;
d539 4
a542 4
		if (matchline(">Synopsis:", buf, len)) {
			rval = 1;
			break;
		}
d545 1
a545 1
	return (rval);
d555 5
d567 1
d574 1
a574 1
	fprintf(fp, "\t%s\n", comment[1]);
d576 1
a576 1
	fprintf(fp, "\t%s\n", comment[2]);
d578 1
a578 1
	fprintf(fp, "\t%s\n", comment[3]);
@


1.58
log
@parse all arguments before going and doing the job requested by -P
(slight change made to check argc == 0)
from Daniel Dickman
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.57 2008/06/14 20:45:45 pvalchev Exp $	*/
a41 2
const char *categories = "system user library documentation kernel "
    "alpha amd64 arm hppa i386 m68k m88k mips64 powerpc sh sparc sparc64 vax";
a44 6
	"<[ non-critical | serious | critical ] (one line)>",
	"<[ low | medium | high ] (one line)>",
	"<PR category (one line)>",
	"<[ sw-bug | doc-bug | change-request | support ] (one line)>",
	"<release number or tag (one line)>",
	"<machine, os, target, libraries (multiple lines)>",
d60 1
a60 1
	fprintf(stderr, "usage: %s [-DLPV]\n", __progname);
d82 1
a82 1
	while ((ch = getopt(argc, argv, "DLPV")) != -1)
a86 4
		case 'L':
			printf("Known categories:\n");
			printf("%s\n\n", categories);
			exit(0);
d528 1
a528 1
	int category, class, priority, release, severity, synopsis;
a534 1
	category = class = priority = release = severity = synopsis = 0;
d536 4
a539 12
		if (matchline(">Category:", buf, len))
			category = 1;
		else if (matchline(">Class:", buf, len))
			class = 1;
		else if (matchline(">Priority:", buf, len))
			priority = 1;
		else if (matchline(">Release:", buf, len))
			release = 1;
		else if (matchline(">Severity:", buf, len))
			severity = 1;
		else if (matchline(">Synopsis:", buf, len))
			synopsis = 1;
d542 1
a542 2
	return (category && class && priority && release && severity &&
	    synopsis);
a551 5
	fprintf(fp, "SENDBUG: Choose from the following categories:\n");
	fprintf(fp, "SENDBUG:\n");
	fprintf(fp, "SENDBUG: %s\n", categories);
	fprintf(fp, "SENDBUG:\n");
	fprintf(fp, "SENDBUG:\n");
a556 2
	fprintf(fp, "X-sendbug-version: %s\n", version);
	fprintf(fp, "\n");
a557 4
	fprintf(fp, ">Submitter-Id:\tnet\n");
	fprintf(fp, ">Originator:\t%s\n", fullname);
	fprintf(fp, ">Organization:\n");
	fprintf(fp, "net\n");
a558 5
	fprintf(fp, ">Severity:\t%s\n", comment[1]);
	fprintf(fp, ">Priority:\t%s\n", comment[2]);
	fprintf(fp, ">Category:\t%s\n", comment[3]);
	fprintf(fp, ">Class:\t\t%s\n", comment[4]);
	fprintf(fp, ">Release:\t%s\n", comment[5]);
a559 1
	fprintf(fp, "\t%s\n", comment[6]);
d565 1
a565 1
	fprintf(fp, "\t%s\n", comment[7]);
d567 1
a567 1
	fprintf(fp, "\t%s\n", comment[8]);
d569 1
a569 1
	fprintf(fp, "\t%s\n", comment[9]);
@


1.57
log
@- remove ports category after discussion w/ many
- sync architectures list with reality and fix a few names
ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.56 2008/05/08 00:10:46 chl Exp $	*/
d61 1
a61 1
int Dflag, wantcleanup;
d100 2
a101 3
			init();
			template(stdout);
			exit(0);
d113 6
@


1.56
log
@replace "/usr/sbin/sendmail" with _PATH_SENDMAIL

no binary change

found by Daniel Dickman <didickman at gmail.com>

ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.55 2008/04/19 09:22:31 ray Exp $	*/
d42 2
a43 2
const char *categories = "system user library documentation ports kernel "
    "alpha amd64 arm i386 m68k m88k mips ppc sgi sparc sparc64 vax";
@


1.55
log
@Decrement len variable after removing newline, prevents copying the
NUL at the end of a string into the mail.  Discovered by dasn.

Move newline printing into outer loop, prevents multiple newlines
from appearing if there are multiple comments in a line.  Discovered
by okan.

OK okan.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.54 2008/01/04 00:50:09 ray Exp $	*/
d324 1
a324 1
		execl("/usr/sbin/sendmail", "sendmail",
@


1.54
log
@Eliminate false positives from <> comments, avoiding mangling
#include <bleh.h> in diffs:
- Only match <> comments from the template.  No other text surrounded
by angle brackets is deleted.
- Simplify code by using C strings.  We no longer handle binary
data, but I don't think binary data belongs in a bug report anyway.
- Remove dmesg and header comment checks.

"That's a nice approach." deraadt, "seems ok for me" chl.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.52 2007/10/17 20:02:33 deraadt Exp $	*/
d436 1
a436 1
		if (buf[len - 1] == '\n')
d438 2
a439 1
		else {
d472 1
a472 2
			if (atomicio(vwrite, dst, buf, copylen) != copylen ||
			    atomicio(vwrite, dst, "\n", 1) != 1)
d480 2
@


1.53
log
@In preparation of eliminating <> comment false positives:
- Move <> comments in template to an array, for easier reference later.
- Rename "comment" variable to avoid shadowing.
- Change some <> comments to SENDBUG comments.

OK chl@@
@
text
@d428 1
a428 1
	char *buf;
d430 1
a430 1
	int blank = 0, dmesg_line = 0;
d434 1
d436 11
d448 1
a448 2
		if (len >= sizeof("SENDBUG") - 1 &&
		    memcmp(buf, "SENDBUG", sizeof("SENDBUG") - 1) == 0)
a449 9
		/* Are we done with the headers? */
		if (!blank && len == 1 && buf[0] == '\n')
			blank = 1;
		/* Have we reached the dmesg? */
		if (blank && !dmesg_line &&
		    len >= sizeof(DMESG_START) - 1 &&
		    memcmp(buf, DMESG_START, sizeof(DMESG_START) - 1) == 0)
			dmesg_line = 1;
		/* Skip comments between headers and dmesg. */
d454 12
a465 3
			if (blank && !dmesg_line &&
			    (sp = memchr(buf, '<', len)) != NULL)
				ep = memchr(sp, '>', len - (sp - buf + 1));
d471 3
a473 7
			if (atomicio(vwrite, dst, buf, copylen) != copylen) {
				int saved_errno = errno;

				fclose(fp);
				errno = saved_errno;
				return (-1);
			}
d481 4
d486 2
a487 1
	return (0);
d565 1
a565 2
	    " be removed automatically, as\n");
	fprintf(fp, "SENDBUG: will all comments (text enclosed in `<' and `>').\n");
@


1.52
log
@- Be more careful about pre-existing SIGCHLD handlers (or SIG_IGN) by
  temporarily restoring default behaviour.  This is not 100% ideal.
  But this fixes editor handling in mail... bah, it is really unfortunate
  that got broken
- refactor the restoration code as well, to make it simpler
ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.51 2007/09/18 00:38:58 ray Exp $	*/
d45 12
d204 3
a206 3
	    "<dmesg is attached.>\n"
	    "<Feel free to delete or use the -D flag if it contains "
	    "sensitive information.>\n", fp);
d486 1
a486 1
	int comment;
d498 1
a498 1
	comment = 0;
d500 1
a500 1
		if (comment) {
d502 1
a502 1
				comment = 0;
d504 1
a504 1
			comment = 1;
d573 6
a578 8
	fprintf(fp, ">Synopsis:\t<synopsis of the problem (one line)>\n");
	fprintf(fp, ">Severity:\t"
	    "<[ non-critical | serious | critical ] (one line)>\n");
	fprintf(fp, ">Priority:\t<[ low | medium | high ] (one line)>\n");
	fprintf(fp, ">Category:\t<PR category (one line)>\n");
	fprintf(fp, ">Class:\t\t"
	    "<[ sw-bug | doc-bug | change-request | support ] (one line)>\n");
	fprintf(fp, ">Release:\t<release number or tag (one line)>\n");
d580 1
a580 1
	fprintf(fp, "\t<machine, os, target, libraries (multiple lines)>\n");
d586 1
a586 1
	fprintf(fp, "\t<precise description of the problem (multiple lines)>\n");
d588 1
a588 2
	fprintf(fp, "\t<code/input/activities to reproduce the problem"
	    " (multiple lines)>\n");
d590 1
a590 2
	fprintf(fp, "\t<how to correct or work around the problem,"
	    " if known (multiple lines)>\n");
@


1.51
log
@Don't treat lines in angle brackets <...> as comments in dmesg.

Discovered and tested by deanna.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.50 2007/07/31 03:44:21 ray Exp $	*/
d231 1
a231 1
	sig_t sighup, sigint, sigquit;
d233 1
a233 1
	int saved_errno, st;
d247 1
d257 1
a257 5
	free(p);
	(void)signal(SIGHUP, sighup);
	(void)signal(SIGINT, sigint);
	(void)signal(SIGQUIT, sigquit);
	if (!WIFEXITED(st)) {
d259 2
a260 3
		return (-1);
	}
	return (WEXITSTATUS(st));
d267 1
d270 1
a270 1
	return (-1);
@


1.50
log
@Remove some unused headers, from Igor Zinovik.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.49 2007/05/11 02:07:47 ray Exp $	*/
d30 1
d195 1
a195 1
	/* Find last line starting with "OpenBSD". */
d202 1
a202 1
		if (!strncmp("OpenBSD ", buf, sizeof("OpenBSD ") - 1))
a417 1
	int blank = 0;
d421 1
d430 2
a431 1
		if (len == 1 && buf[0] == '\n')
d433 6
a438 1
		/* Skip comments, but only if we encountered a blank line. */
d443 2
a444 1
			if (blank && (sp = memchr(buf, '<', len)) != NULL)
@


1.49
log
@If fork fails with EAGAIN, ignore errno and fail.  Looping just
worsens the problem.

cloder@@ and deraadt@@ agree.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.48 2007/05/11 02:00:49 ray Exp $	*/
a8 1
#include <sys/mman.h>
@


1.48
log
@Instead of returning -1 and setting errno to ECHILD if the editor
has a non-zero exit status, just return the exit status on success.
Hard errors still return -1.  If the editor is killed, return -1
and set EINTR.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.47 2007/05/09 02:36:56 ray Exp $	*/
d247 2
a248 5
	while ((pid = fork()) == -1)
		if (errno == EAGAIN)
			sleep(1);
		else
			goto fail;
@


1.47
log
@Be more consistent about when dmesg is attached to template.
Specifically, -V.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.46 2007/05/07 02:11:12 ray Exp $	*/
d146 1
a146 1
	if (editit(tmppath) == -1 && errno != ECHILD)
d221 6
d263 2
a264 2
	if (!WIFEXITED(st) || WEXITSTATUS(st) != 0) {
		errno = ECHILD;
d267 1
a267 1
	return (0);
@


1.46
log
@Simplify some loops.

OK jaredy@@ and moritz@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.45 2007/05/06 05:01:19 ray Exp $	*/
d49 1
a49 1
int wantcleanup;
d71 1
a71 1
	int ch, c, Dflag = 0, fd, ret = 1;
d138 1
a138 1
	} else {
a139 3
		if (!Dflag)
			dmesg(fp);
	}
d576 3
@


1.45
log
@Restore signals before returning.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.44 2007/05/06 04:50:26 ray Exp $	*/
d244 2
a245 5
 top:
	if ((pid = fork()) == -1) {
		saved_errno = errno;

		if (saved_errno == EAGAIN) {
d247 2
a248 9
			goto top;
		}
		(void)signal(SIGHUP, sighup);
		(void)signal(SIGINT, sigint);
		(void)signal(SIGQUIT, sigquit);
		free(p);
		errno = saved_errno;
		return (-1);
	}
d253 3
a256 13
	for (;;) {
		if (waitpid(pid, &st, 0) == -1) {
			if (errno != EINTR) {
				saved_errno = errno;
				(void)signal(SIGHUP, sighup);
				(void)signal(SIGINT, sigint);
				(void)signal(SIGQUIT, sigquit);
				errno = saved_errno;
				return (-1);
			}
		} else
			break;
	}
d265 9
@


1.44
log
@Save and restore signals once instead of each time fork fails with
EAGAIN.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.43 2007/04/25 04:56:14 ray Exp $	*/
d230 1
a230 1
	int st;
d246 1
a246 1
		int saved_errno = errno;
d266 6
a271 1
			if (errno != EINTR)
d273 1
@


1.43
log
@Remove extra code that only applies to setuid/setgid programs.

``Slacker!  We'll burn your hands if you don't get going!'' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.42 2007/04/07 04:58:50 ray Exp $	*/
a240 1
 top:
d244 1
a247 3
		(void)signal(SIGHUP, sighup);
		(void)signal(SIGINT, sigint);
		(void)signal(SIGQUIT, sigquit);
d252 3
@


1.42
log
@Sprinkle const poison, remove unneeded variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.41 2007/04/07 00:40:43 ray Exp $	*/
d265 1
a265 1
		if (waitpid(pid, &st, WUNTRACED) == -1) {
d268 1
a268 3
		} else if (WIFSTOPPED(st))
			raise(WSTOPSIG(st));
		else
@


1.41
log
@Use __progname and warn instead of fprintf where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.40 2007/04/07 00:24:59 ray Exp $	*/
d34 1
a34 1
int	editit(char *);
d225 1
a225 1
editit(char *pathname)
d229 1
a229 1
	pid_t pid, xpid;
d265 1
a265 2
		xpid = waitpid(pid, &st, WUNTRACED);
		if (xpid == -1) {
@


1.40
log
@De-lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.39 2007/04/06 21:51:09 ray Exp $	*/
d54 3
a56 1
	fprintf(stderr, "usage: sendbug [-DLPV]\n");
d125 2
a126 3
			fprintf(stderr, "sendbug: can't seem to read your"
			    " template file (`%s'), ignoring PR_FORM\n",
			    pr_form);
@


1.39
log
@Warn if one of the required fields is not filled out.  Requested
by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.38 2007/04/06 20:29:18 ray Exp $	*/
d36 1
a36 1
int	matchline(const char *, const unsigned char *, size_t);
d471 1
d474 1
a474 1
matchline(const char *s, const unsigned char *line, size_t linelen)
d496 1
a496 1
		else if (!isspace(*line))
@


1.38
log
@Don't shadow variables.  Enable -Wshadow.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.37 2007/04/06 07:24:53 ray Exp $	*/
d32 1
d36 1
d157 2
d467 69
@


1.37
log
@argc does not include __progname after subtracting optind.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.36 2007/04/06 03:24:08 ray Exp $	*/
d220 1
a220 1
editit(char *tmpfile)
d232 1
a232 1
	if (asprintf(&p, "%s %s", ed, tmpfile) == -1)
d297 1
a297 1
sendmail(const char *tmppath)
d302 1
a302 1
		warn("pipe: unsent report in %s", tmppath);
d308 1
a308 1
		    tmppath);
d314 1
a314 1
			    tmppath);
d321 1
a321 1
		    tmppath);
d326 1
a326 1
		if (send_file(tmppath, filedes[1]) == -1) {
d328 1
a328 1
			    tmppath);
@


1.36
log
@Only include newest dmesg.

``Come on, take some risks'' deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.34 2007/03/28 04:05:52 ray Exp $	*/
d96 1
a96 1
	if (argc > 1)
@


1.35
log
@Attach dmesg to sendbug reports by default.  Use -D flag to disable.

OK deraadt@@ and millert@@.
@
text
@d32 1
d137 2
a138 24
		if (!Dflag) {
			char buf[BUFSIZ];
			size_t len;
			FILE *dfp;

			dfp = fopen(_PATH_DMESG, "r");
			if (dfp == NULL) {
				warn("can't read dmesg");
			} else {
				fputs("\n"
				    "<dmesg is attached.>\n"
				    "<Feel free to delete or use the -D"
				    " flag if it contains sensitive "
				    "information.>\n", fp);
				while (!feof(dfp)) {
					len = fread(buf, 1, sizeof buf, dfp);
					if (len == 0)
						break;
					if (fwrite(buf, 1, len, fp) != len)
						break;
				}
				fclose(dfp);
			}
		}
d174 43
@


1.34
log
@CC: a copy of the bug report to sender.  Requested by Travers Buda.

OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.33 2007/03/27 04:15:00 ray Exp $	*/
d30 2
d51 1
a51 1
	fprintf(stderr, "usage: sendbug [-LPV]\n");
d66 1
a66 1
	int ch, c, fd, ret = 1;
d73 1
a73 1
	while ((ch = getopt(argc, argv, "LPV")) != -1)
d75 3
d92 2
d95 1
a95 1
	if (argc > 1) {
a96 1
	}
d134 1
a134 1
	} else
d136 25
@


1.33
log
@Replace some scary pointer code.  The new code is O(n^2) for strings
of '&', but gecos fields are usually short and most do not have '&'
so the impact should be minimal.  In return we get clearer and safer
code.

OK moritz@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.31 2007/03/26 18:13:08 moritz Exp $	*/
d428 1
a428 1
	fprintf(fp, "Cc: \n");
@


1.32
log
@Remove variable name from prototype.
@
text
@d288 1
a288 2
	size_t amp, len, namelen;
	const char *src;
d290 1
a290 1
	char *dst, *cp;
d297 2
a298 2
	for (amp = 0, src = pw->pw_gecos; *src && *src != ','; ++src)
		if (*src == '&')
d300 5
d306 2
a307 2
	len = (src - pw->pw_gecos) - amp + (amp * namelen);
	if ((fullname = malloc(len + 1)) == NULL)
d310 15
a324 15
	dst = fullname;
	src = pw->pw_gecos;
	while (*src != ',' && *src != '\0') {
		/* Copy text up to ',' or '&' and skip. */
		len = strcspn(src, ",&");
		memcpy(dst, src, len);
		dst += len;
		src += len;
		/* Replace '&' with login. */
		if (*src == '&') {
			memcpy(dst, pw->pw_name, namelen);
			*dst = toupper((unsigned char)*dst);
			dst += namelen;
			++src;
		}
d326 2
a327 1
	*dst = '\0';
@


1.31
log
@Simplify gecos parsing code and prevent buffer overflow
when gecos field contains multiple '&' characters with
other characters inbetween.

With and OK ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.30 2007/03/26 07:16:11 ray Exp $	*/
d33 1
a33 1
int	send_file(const char *, int dst);
@


1.30
log
@Remove pointless cast.  No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.29 2007/03/26 07:06:03 ray Exp $	*/
d288 1
a288 1
	size_t len = 0, namelen;
d297 6
a302 10
	/* Add length of expanded '&', minus existing '&'. */
	src = pw->pw_gecos;
	src += strcspn(src, ",&");
	while (*src == '&') {
		len += namelen - 1;
		/* Look for next '&', skipping the one we just found. */
		src += 1 + strcspn(src, ",&");
	}
	/* Add full name length, including all those '&' we skipped. */
	len += src - pw->pw_gecos;
@


1.29
log
@Break on waitpid success; we shouldn't continue on WIFSIGNALED, and
WIFCONTINUED can't happen in this case.

OK deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.28 2007/03/26 06:47:00 ray Exp $	*/
d207 1
a207 1
		xpid = waitpid(pid, (int *)&st, WUNTRACED);
@


1.28
log
@Certain errors in editit() should be fatal.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.27 2007/03/26 06:40:01 ray Exp $	*/
d213 1
a213 1
		else if (WIFEXITED(st))
@


1.27
log
@Don't print warnings in editit(), instead make errno reliable on
failure.  If the editor exits non-zero, errno is set to ECHILD.

OK deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.26 2007/03/26 06:22:12 ray Exp $	*/
d136 2
a137 1
	editit(tmppath);
@


1.26
log
@Accept $VISUAL in addition to $EDITOR.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.25 2007/03/26 05:50:18 ray Exp $	*/
d196 1
a197 2
		perror("fork");
		free(p);
d208 1
a208 2
			if (errno != EINTR) {
				warn("waidpid");
a209 1
			}
d218 2
a219 1
	if (!WIFEXITED(st) || WEXITSTATUS(st) != 0)
d221 1
@


1.25
log
@Save and restore signal handlers.  Although we do not install our
own signal handlers, this allows this code to be more easily reused
in other programs.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.24 2007/03/26 05:39:51 ray Exp $	*/
d173 4
a176 1
	if ((ed = getenv("EDITOR")) == (char *)0)
@


1.24
log
@Restore errno before calling perror().
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.23 2007/03/26 05:34:30 ray Exp $	*/
d169 1
d180 3
a182 3
	(void)signal(SIGHUP, SIG_IGN);
	(void)signal(SIGINT, SIG_IGN);
	(void)signal(SIGQUIT, SIG_IGN);
d186 3
a188 3
		(void)signal(SIGHUP, SIG_DFL);
		(void)signal(SIGINT, SIG_DFL);
		(void)signal(SIGQUIT, SIG_DFL);
d215 3
a217 3
	(void)signal(SIGHUP, SIG_DFL);
	(void)signal(SIGINT, SIG_DFL);
	(void)signal(SIGQUIT, SIG_DFL);
@


1.23
log
@Check fork() == -1 instead of fork() < 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.22 2007/03/26 05:17:53 ray Exp $	*/
d192 1
@


1.22
log
@When someone hits ^C in an editor, the editor does exit(130), I
don't know why.  Something to do with the shell, says deraadt@@.
Continuing to ignore these signals in the child fixes this.

Now editit()'s return value can be reliably checked.

OK deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.21 2007/03/26 01:35:36 deraadt Exp $	*/
d182 1
a182 1
	if ((pid = fork()) < 0) {
@


1.21
log
@more careful waitpid() discussed with ray (plus some knf)
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.20 2007/03/25 23:35:59 ray Exp $	*/
a196 3
		(void)signal(SIGHUP, SIG_DFL);
		(void)signal(SIGINT, SIG_DFL);
		(void)signal(SIGQUIT, SIG_DFL);
@


1.20
log
@fork() does not return EPROCLIM, so don't test for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.19 2007/03/25 23:27:38 deraadt Exp $	*/
d30 6
a35 6
int editit(char *);
void init(void);
int prompt(void);
int send_file(const char *, int dst);
int sendmail(const char *);
void template(FILE *);
d43 1
a43 2
char *fullname;
char *tmppath;
d170 1
a170 1
	int stat;
d205 9
a213 4
		xpid = waitpid(pid, (int *)&stat, WUNTRACED);
		if (WIFSTOPPED(stat))
			raise(WSTOPSIG(stat));
		else if (WIFEXITED(stat))
d219 1
a219 1
	if (!WIFEXITED(stat) || WEXITSTATUS(stat) != 0)
@


1.19
log
@more cleaning :)
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.18 2007/03/25 23:23:29 ray Exp $	*/
a188 5
		if (saved_errno == EPROCLIM) {
			warnx("you have too many processes");
			free(p);
			return (-1);
		}
@


1.18
log
@Change editit() to return -1 on error and 0 on success, like many
other C functions.  (Currently this return value is unchecked.)
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.17 2007/03/25 23:21:11 ray Exp $	*/
d65 1
d67 1
a68 2
	int ch, c, fd, ret = 1;
	struct stat sb;
d96 1
a96 1
	    tmpdir[strlen(tmpdir) - 1] == '/' ? "" : "/") == -1) {
a97 1
	}
d102 1
a102 1
	if ((fp = fdopen(fd, "w+")) == NULL) {
a103 1
	}
d132 1
a132 1
	if (fflush(fp) == EOF || fstat(fd, &sb) == -1 || fclose(fp) == EOF) {
a133 1
	}
d139 1
a139 1
	if (stat(tmppath, &sb) == -1) {
d141 1
a141 2
	}
	if (mtime == sb.st_mtime) {
a142 1
	}
d169 1
a170 2
	char *argp[] = {"sh", "-c", NULL, NULL};
	char *ed, *p;
d288 1
a289 1
	const char *src;
d292 1
a292 1
	if ((pw = getpwuid(getuid())) == NULL) {
a293 1
	}
d306 1
a306 1
	if ((fullname = malloc(len + 1)) == NULL) {
d308 1
a308 1
	}
d330 1
a330 1
	if (sysctl(sysname, 2, &os, &len, NULL, 0) == -1) {
a331 1
	}
d336 1
a336 1
	if (sysctl(sysname, 2, &rel, &len, NULL, 0) == -1) {
a337 1
	}
d342 1
a342 1
	if (sysctl(sysname, 2, &details, &len, NULL, 0) == -1) {
a343 1
	}
d359 1
a359 1
	if (sysctl(sysname, 2, &mach, &len, NULL, 0) == -1) {
a360 2
	}

d414 3
a416 2
	fprintf(fp, "SENDBUG: Lines starting with `SENDBUG' will be removed automatically, as\n");
	fprintf(fp, "SENDBUG: will all comments (text enclosed in `<' and `>').              \n");
d436 2
a437 1
	fprintf(fp, ">Severity:\t<[ non-critical | serious | critical ] (one line)>\n");
d440 2
a441 1
	fprintf(fp, ">Class:\t\t<[ sw-bug | doc-bug | change-request | support ] (one line)>\n");
d452 2
a453 1
	fprintf(fp, "\t<code/input/activities to reproduce the problem (multiple lines)>\n");
d455 2
a456 1
	fprintf(fp, "\t<how to correct or work around the problem, if known (multiple lines)>\n");
@


1.17
log
@KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.16 2007/03/25 23:18:56 ray Exp $	*/
d182 1
a182 1
		return (0);
d198 1
a198 1
			return (0);
d206 1
a206 1
		return (0);
d227 2
a228 2
		return (0);
	return (1);
@


1.16
log
@Save errno before calling signal().
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.15 2007/03/23 17:18:07 deraadt Exp $	*/
d198 1
a198 1
			return(0);
d206 1
a206 1
		return(0);
d227 2
a228 2
		return(0);
	return(1);
@


1.15
log
@correct signal handling and process waiting for the editor spawning
code, so that signals in the editor are handled right.  written by ray
after he started looking at other code that does this better
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.14 2007/03/23 15:46:40 deraadt Exp $	*/
d190 2
d195 1
a195 1
		if (errno == EPROCLIM) {
d200 1
a200 1
		if (errno == EAGAIN) {
@


1.14
log
@Since we now have our own program, we can export more things that
matter.  Include kern.version, which tells a hell of a lot. ok millert ray
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.13 2007/03/23 06:16:24 ray Exp $	*/
d22 1
d30 1
d65 2
a66 2
	const char *editor, *tmpdir;
	char *argp[] = {"sh", "-c", NULL, NULL}, *pr_form;
d140 1
a140 15
	if ((editor = getenv("EDITOR")) == NULL)
		editor = "vi";
	switch (fork()) {
	case -1:
		err(1, "fork");
	case 0:
		wantcleanup = 0;
		if (asprintf(&argp[2], "%s %s", editor, tmppath) == -1)
			err(1, "asprintf");
		execv(_PATH_BSHELL, argp);
		err(1, "execv");
	default:
		wait(NULL);
		break;
	}
d171 57
@


1.13
log
@Replace `&' in gecos field with login, prodded by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.12 2007/03/23 05:08:03 tedu Exp $	*/
d40 1
a40 1
char os[BUFSIZ], rel[BUFSIZ], mach[BUFSIZ];
d249 1
a249 1
	char *dst;
d301 18
d347 1
a347 1
			char *sp, *ep = NULL;
d408 1
@


1.12
log
@simplify cleanup by using an atexit handler.  lets us use err() instead
of a series of warn()/gotos.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.11 2007/03/23 03:43:46 deraadt Exp $	*/
d15 1
d246 1
a246 1
	size_t len;
d248 2
d254 1
d256 10
a265 2
	/* Get full name. */
	len = strcspn(pw->pw_gecos, ",");
d269 17
a285 2
	memcpy(fullname, pw->pw_gecos, len);
	fullname[len] = '\0';
@


1.11
log
@re-org something for prettiness
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.10 2007/03/23 03:35:01 deraadt Exp $	*/
d28 1
a28 1
int init(void);
d41 2
d44 1
a44 1
void
d48 8
d58 1
d63 1
a63 1
	char *argp[] = {"sh", "-c", NULL, NULL}, *tmppath = NULL, *pr_form;
d76 1
a76 2
			if (init() == -1)
				exit(1);
a83 1
			exit(1);
a87 1
		exit(1);
d94 1
a94 2
		warn("asprintf");
		goto quit;
d98 2
d101 1
a101 2
		warn("fdopen");
		goto cleanup;
d104 1
a104 2
	if (init() == -1)
		goto cleanup;
d132 1
a132 2
		warn("error creating template");
		goto cleanup;
d141 1
a141 2
		warn("fork");
		goto cleanup;
d143 1
d154 1
a154 2
		warn("stat");
		goto cleanup;
d157 1
a157 2
		warnx("report unchanged, nothing sent");
		goto cleanup;
d165 2
a166 2
		warnx("unsent report in %s", tmppath);
		goto quit;
d178 1
a178 6

 cleanup:
	if (tmppath && unlink(tmppath) == -1)
		warn("unlink");

 quit:
d182 1
d242 1
a242 1
int
d249 1
a249 2
		warn("getpwuid");
		return (-1);
d255 1
a255 2
		warn("malloc");
		return (-1);
d264 1
a264 2
		warn("sysctl");
		return (-1);
d271 1
a271 2
		warn("sysctl");
		return (-1);
d278 1
a278 2
		warn("sysctl");
		return (-1);
a280 1
	return (0);
@


1.10
log
@support $PR_FORM environment variable
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.9 2007/03/23 03:30:52 ray Exp $	*/
a33 1
struct passwd *pw;
d36 3
d41 1
a41 1
char *version = "4.2";
@


1.9
log
@Don't insert double slashes ("/tmp//p.XXXXXXXXXX") if TMPDIR ends
in "/".  Helps emacs and deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.8 2007/03/23 03:19:30 ray Exp $	*/
d50 1
a50 1
	char *argp[] = {"sh", "-c", NULL, NULL}, *tmppath = NULL;
d97 24
a120 1
	template(fp);
@


1.8
log
@Support command-line arguments in $EDITOR.  Prodded by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.7 2007/03/23 03:13:22 deraadt Exp $	*/
d82 2
a83 1
	if (asprintf(&tmppath, "%s/p.XXXXXXXXXX", tmpdir) == -1) {
@


1.7
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.6 2007/03/23 02:46:32 deraadt Exp $	*/
d50 1
a50 1
	char *tmppath = NULL;
d112 4
a115 2
		execlp(editor, editor, tmppath, (void *)NULL);
		err(1, "execlp");
@


1.6
log
@-V in usage
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.5 2007/03/23 02:45:21 deraadt Exp $	*/
d73 2
a74 2
		}		
	
@


1.5
log
@add -V (version) support
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.4 2007/03/23 02:41:02 ray Exp $	*/
d43 1
a43 1
	fprintf(stderr, "usage: sendbug [-LP]\n");
@


1.4
log
@Get rid of silly gcc warning.

OK deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.3 2007/03/23 02:28:14 deraadt Exp $	*/
d39 1
a39 1

d56 1
a56 1
	while ((ch = getopt(argc, argv, "LP")) != -1)
d67 3
d131 2
a132 1
	case 'a': case EOF:
d325 1
a325 1
	fprintf(fp, "X-sendbug-version: 4.2\n");
@


1.3
log
@handle the -L and -P options; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.2 2007/03/23 02:11:00 deraadt Exp $	*/
d282 4
a285 1
			copylen = ep ? sp - buf : len;
@


1.2
log
@some minor KNF, including sentinals; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: sendbug.c,v 1.1.1.1 2007/03/23 01:47:11 ray Exp $	*/
d40 6
d51 1
a51 1
	int c, fd, ret = 1;
d55 21
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a42 2
	struct stat sb;
	FILE *fp;
d45 2
d48 1
a48 1
	int c, fd, ret = 1;
d82 1
a82 1
		execlp(editor, editor, tmppath, NULL);
d164 1
a164 1
		    "-oi", "-t", NULL);
d233 3
a236 3
	char *buf;
	size_t len;
	int blank = 0;
@


1.1.1.1
log
@Import public domain rewrite of sendbug, written by Ray Lai. =)
Replaces GNU sendbug/sendpr, the wonderful shell script that had
trouble dealing with signals, behaved differently depending on what
file it read upon startup, and suffered from issues plaguing most
large shell scripts.

OK deraadt@@.
@
text
@@
