head	1.130;
access;
symbols
	OPENBSD_6_2:1.130.0.2
	OPENBSD_6_2_BASE:1.130
	OPENBSD_6_1:1.129.0.6
	OPENBSD_6_1_BASE:1.129
	OPENBSD_6_0:1.129.0.2
	OPENBSD_6_0_BASE:1.129
	OPENBSD_5_9:1.120.0.2
	OPENBSD_5_9_BASE:1.120
	OPENBSD_5_8:1.103.0.4
	OPENBSD_5_8_BASE:1.103
	OPENBSD_5_7:1.98.0.2
	OPENBSD_5_7_BASE:1.98
	OPENBSD_5_6:1.86.0.6
	OPENBSD_5_6_BASE:1.86
	OPENBSD_5_5:1.86.0.4
	OPENBSD_5_5_BASE:1.86
	OPENBSD_5_4:1.83.0.2
	OPENBSD_5_4_BASE:1.83
	OPENBSD_5_3:1.77.0.2
	OPENBSD_5_3_BASE:1.77
	OPENBSD_5_2:1.75.0.2
	OPENBSD_5_2_BASE:1.75
	OPENBSD_5_1_BASE:1.63
	OPENBSD_5_1:1.63.0.2
	OPENBSD_5_0:1.62.0.2
	OPENBSD_5_0_BASE:1.62
	OPENBSD_4_9:1.47.0.4
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.47.0.2
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.39.0.12
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.8
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.39.0.6
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.4
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.37.0.2
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.26.0.4
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.8
	OPENBSD_2_8:1.10.0.6
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.130
date	2017.04.28.13.53.05;	author mpi;	state Exp;
branches;
next	1.129;
commitid	XxhEFM06ZplmmabB;

1.129
date	2016.07.18.09.36.50;	author guenther;	state Exp;
branches;
next	1.128;
commitid	K5mI2UDdS4bCqHba;

1.128
date	2016.06.02.22.47.13;	author tedu;	state Exp;
branches;
next	1.127;
commitid	LikO5IJp83NTAxwG;

1.127
date	2016.03.30.08.00.01;	author guenther;	state Exp;
branches;
next	1.126;
commitid	OAOHRKjhl0xyBDsZ;

1.126
date	2016.03.24.05.05.42;	author guenther;	state Exp;
branches;
next	1.125;
commitid	NIOnZ8r96FhdMFWs;

1.125
date	2016.03.22.16.45.07;	author guenther;	state Exp;
branches;
next	1.124;
commitid	oNZOtQg98iFpTHGK;

1.124
date	2016.03.21.00.04.03;	author guenther;	state Exp;
branches;
next	1.123;
commitid	XVB3JqzJV5ukQRcx;

1.123
date	2016.03.06.22.33.48;	author guenther;	state Exp;
branches;
next	1.122;
commitid	ddS62ZEvVGGhlVCx;

1.122
date	2016.03.06.20.25.27;	author guenther;	state Exp;
branches;
next	1.121;
commitid	PPKYgV5KWXY1sNxp;

1.121
date	2016.02.28.15.55.58;	author naddy;	state Exp;
branches;
next	1.120;
commitid	o6rJVnaNbmcOQq3V;

1.120
date	2015.11.10.04.30.59;	author guenther;	state Exp;
branches;
next	1.119;
commitid	GTAoVjpQRAdNHXVz;

1.119
date	2015.10.28.16.03.06;	author deraadt;	state Exp;
branches;
next	1.118;
commitid	112tZjRkD90n5I56;

1.118
date	2015.10.26.11.17.52;	author deraadt;	state Exp;
branches;
next	1.117;
commitid	lE9hFu0XD39YNtcZ;

1.117
date	2015.10.25.20.39.54;	author deraadt;	state Exp;
branches;
next	1.116;
commitid	SIwCBDJKKae61tEi;

1.116
date	2015.10.18.01.32.05;	author deraadt;	state Exp;
branches;
next	1.115;
commitid	OJABC6fXXOUXNOyx;

1.115
date	2015.10.10.20.35.00;	author deraadt;	state Exp;
branches;
next	1.114;
commitid	m38BXhkh3XknrpM6;

1.114
date	2015.10.10.19.19.46;	author deraadt;	state Exp;
branches;
next	1.113;
commitid	6O80wfw0bfDPl3vx;

1.113
date	2015.10.09.01.37.08;	author deraadt;	state Exp;
branches;
next	1.112;
commitid	sbrB3Q5CNxcwZpfU;

1.112
date	2015.10.06.03.27.25;	author deraadt;	state Exp;
branches;
next	1.111;
commitid	7q91bjim04qTOor5;

1.111
date	2015.10.03.23.52.30;	author guenther;	state Exp;
branches;
next	1.110;
commitid	7fZFfLhcNPssv7ez;

1.110
date	2015.10.03.21.47.40;	author guenther;	state Exp;
branches;
next	1.109;
commitid	5iuKIXvSbNBP0J2x;

1.109
date	2015.10.03.09.12.39;	author zhuk;	state Exp;
branches;
next	1.108;
commitid	xVYfvMJePLttMhe2;

1.108
date	2015.10.03.05.15.36;	author deraadt;	state Exp;
branches;
next	1.107;
commitid	WMJ3U6zAhTR1OPDw;

1.107
date	2015.10.02.19.12.45;	author jmc;	state Exp;
branches;
next	1.106;
commitid	w4xFxWlVTIilCal4;

1.106
date	2015.10.02.05.07.41;	author guenther;	state Exp;
branches;
next	1.105;
commitid	m4jkpHQAAdeQKWoV;

1.105
date	2015.09.13.17.08.03;	author guenther;	state Exp;
branches;
next	1.104;
commitid	BssYI6s6zozAyfkk;

1.104
date	2015.09.07.15.38.45;	author guenther;	state Exp;
branches;
next	1.103;
commitid	P4QdNgT9HBzXxQ5B;

1.103
date	2015.07.19.04.45.25;	author guenther;	state Exp;
branches;
next	1.102;
commitid	ZlSuHVkn9uJBlE0T;

1.102
date	2015.07.19.02.52.35;	author deraadt;	state Exp;
branches;
next	1.101;
commitid	c6ZusgQMOBtLrH2w;

1.101
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.100;
commitid	6b2lLILbgCR1fvia;

1.100
date	2015.04.17.06.33.30;	author guenther;	state Exp;
branches;
next	1.99;
commitid	XKM4cRza07OqlflK;

1.99
date	2015.04.17.06.14.36;	author guenther;	state Exp;
branches;
next	1.98;
commitid	QuM5sTk8tPW0Icq2;

1.98
date	2015.01.26.04.38.23;	author guenther;	state Exp;
branches;
next	1.97;
commitid	NtnKDJ5YvraQm4Y7;

1.97
date	2015.01.16.06.40.09;	author deraadt;	state Exp;
branches;
next	1.96;
commitid	Uu5nFG3wCl0LACBb;

1.96
date	2014.12.28.11.11.01;	author bluhm;	state Exp;
branches;
next	1.95;
commitid	lO97Z7OBmqn0x1AX;

1.95
date	2014.12.15.07.01.12;	author jmc;	state Exp;
branches;
next	1.94;
commitid	PFP1cVZzpj0OGOTG;

1.94
date	2014.12.15.01.48.54;	author guenther;	state Exp;
branches;
next	1.93;
commitid	MEBmqIQlRpTSQJN4;

1.93
date	2014.12.09.00.46.43;	author jsg;	state Exp;
branches;
next	1.92;
commitid	xavQnkG9GBb1VowY;

1.92
date	2014.12.08.21.23.44;	author guenther;	state Exp;
branches;
next	1.91;
commitid	lpUmFxm44MKPkJek;

1.91
date	2014.10.13.03.46.33;	author guenther;	state Exp;
branches;
next	1.90;
commitid	GfyJFt2AC6kVCsla;

1.90
date	2014.10.08.04.02.46;	author doug;	state Exp;
branches;
next	1.89;
commitid	2wprcZVJcbZQpI59;

1.89
date	2014.09.17.19.12.55;	author guenther;	state Exp;
branches;
next	1.88;
commitid	qN9ETG5djk6G2h2J;

1.88
date	2014.08.18.03.29.53;	author guenther;	state Exp;
branches;
next	1.87;
commitid	4dBrlmlYPveGIWOd;

1.87
date	2014.08.17.22.25.53;	author guenther;	state Exp;
branches;
next	1.86;
commitid	RiUWSPM8QBS7bkJM;

1.86
date	2013.12.21.07.32.35;	author guenther;	state Exp;
branches;
next	1.85;

1.85
date	2013.09.09.05.08.26;	author guenther;	state Exp;
branches;
next	1.84;

1.84
date	2013.08.22.02.02.33;	author guenther;	state Exp;
branches;
next	1.83;

1.83
date	2013.07.03.23.04.33;	author guenther;	state Exp;
branches;
next	1.82;

1.82
date	2013.07.03.06.41.51;	author guenther;	state Exp;
branches;
next	1.81;

1.81
date	2013.06.01.09.51.30;	author miod;	state Exp;
branches;
next	1.80;

1.80
date	2013.04.23.20.03.05;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2013.04.16.22.11.10;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2013.04.15.16.47.14;	author guenther;	state Exp;
branches;
next	1.77;

1.77
date	2012.12.25.09.35.51;	author guenther;	state Exp;
branches;
next	1.76;

1.76
date	2012.12.05.12.54.15;	author millert;	state Exp;
branches;
next	1.75;

1.75
date	2012.07.11.11.18.40;	author guenther;	state Exp;
branches;
next	1.74;

1.74
date	2012.07.09.17.51.08;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2012.06.29.05.09.58;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2012.06.21.06.55.58;	author guenther;	state Exp;
branches;
next	1.71;

1.71
date	2012.06.20.07.31.33;	author guenther;	state Exp;
branches;
next	1.70;

1.70
date	2012.04.12.12.33.04;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2012.04.11.13.55.26;	author mikeb;	state Exp;
branches;
next	1.68;

1.68
date	2012.04.11.12.44.02;	author jmc;	state Exp;
branches;
next	1.67;

1.67
date	2012.04.10.20.39.37;	author mikeb;	state Exp;
branches;
next	1.66;

1.66
date	2012.03.31.18.59.14;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2012.03.19.09.05.39;	author guenther;	state Exp;
branches;
next	1.64;

1.64
date	2012.02.20.21.04.35;	author guenther;	state Exp;
branches;
next	1.63;

1.63
date	2011.09.19.22.00.37;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2011.07.28.10.33.36;	author otto;	state Exp;
branches;
next	1.61;

1.61
date	2011.07.19.18.20.11;	author matthew;	state Exp;
branches;
next	1.60;

1.60
date	2011.07.17.07.49.34;	author otto;	state Exp;
branches;
next	1.59;

1.59
date	2011.07.17.06.55.25;	author otto;	state Exp;
branches;
next	1.58;

1.58
date	2011.07.10.06.13.55;	author otto;	state Exp;
branches;
next	1.57;

1.57
date	2011.07.09.07.22.05;	author otto;	state Exp;
branches;
next	1.56;

1.56
date	2011.07.09.04.01.30;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2011.07.08.19.29.44;	author otto;	state Exp;
branches;
next	1.54;

1.54
date	2011.07.07.06.39.48;	author otto;	state Exp;
branches;
next	1.53;

1.53
date	2011.07.04.22.59.43;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2011.07.04.06.44.52;	author otto;	state Exp;
branches;
next	1.51;

1.51
date	2011.06.20.17.54.48;	author otto;	state Exp;
branches;
next	1.50;

1.50
date	2011.06.02.16.19.13;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2011.04.05.15.24.32;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2010.07.06.00.31.02;	author oga;	state Exp;
branches;
next	1.46;

1.46
date	2010.07.02.20.00.54;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2010.07.01.17.26.52;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2010.06.30.20.46.51;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2010.06.29.20.30.33;	author guenther;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.29.17.35.15;	author tedu;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.27.23.59.39;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2009.10.21.15.08.23;	author sobrado;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.29.02.01.03;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.03.03.23.36.15;	author jmc;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.17.02.12.17;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.11.12.26.42;	author jmc;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.11.07.24.03;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.11.07.15.08;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.11.07.13.17;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.11.06.52.04;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.11.06.49.00;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.31.20.56.37;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.20.07.37.21;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2005.09.10.21.06.21;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.06.02.17.32.02;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2004.07.09.23.51.40;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.09.21.52.21;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.04.20.39.27;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.13.00.44.25;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.02.20.54.17;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.03.02.56.09;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.19.19.30.13;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.17.17.20.49;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.06.19.14.20;	author nordin;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.23.20.01.25;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.12.06.07.15;	author mpech;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.12.10.40.33;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.22.19.19.32;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.27.47;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.18.00.48.57;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.12.05.17.12;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.09.25.19.35.47;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.11.04.07.58.38;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.02.28.07.09.08;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.02.06.13.46.36;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.30.08.16.45;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.12.10.15.42.38;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.34.43;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.27.07.59.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.24.09.19.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.27;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.27;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.130
log
@Display futex(2) operations and arguments.
@
text
@/*	$OpenBSD: kdump.c,v 1.129 2016/07/18 09:36:50 guenther Exp $	*/

/*-
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXCOMLEN nitems */
#include <sys/time.h>
#include <sys/signal.h>
#include <sys/uio.h>
#include <sys/ktrace.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/namei.h>
#include <sys/ptrace.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/siginfo.h>
#include <sys/vmmeter.h>
#include <sys/tty.h>
#include <sys/wait.h>
#define PLEDGENAMES
#include <sys/pledge.h>
#undef PLEDGENAMES
#define _KERNEL
#include <errno.h>
#undef _KERNEL
#include <ddb/db_var.h>
#include <machine/cpu.h>

#include <ctype.h>
#include <err.h>
#include <fcntl.h>
#include <limits.h>
#include <netdb.h>
#include <poll.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <vis.h>

#include "ktrace.h"
#include "kdump.h"
#include "kdump_subr.h"
#include "extern.h"

int timestamp, decimal, iohex, fancy = 1, maxdata = INT_MAX;
int needtid, tail, basecol;
char *tracefile = DEF_TRACEFILE;
struct ktr_header ktr_header;
pid_t pid_opt = -1;

#define eqs(s1, s2)	(strcmp((s1), (s2)) == 0)

#include <sys/syscall.h>

#define KTRACE
#define PTRACE
#define NFSCLIENT
#define NFSSERVER
#define SYSVSEM
#define SYSVMSG
#define SYSVSHM
#define ACCOUNTING
#include <kern/syscalls.c>
#undef KTRACE
#undef PTRACE
#undef NFSCLIENT
#undef NFSSERVER
#undef SYSVSEM
#undef SYSVMSG
#undef SYSVSHM
#undef ACCOUNTING


static char *ptrace_ops[] = {
	"PT_TRACE_ME",	"PT_READ_I",	"PT_READ_D",	"PT_READ_U",
	"PT_WRITE_I",	"PT_WRITE_D",	"PT_WRITE_U",	"PT_CONTINUE",
	"PT_KILL",	"PT_ATTACH",	"PT_DETACH",	"PT_IO",
	"PT_SET_EVENT_MASK", "PT_GET_EVENT_MASK", "PT_GET_PROCESS_STATE",
	"PT_GET_THREAD_FIRST", "PT_GET_THREAD_NEXT",
};

static int fread_tail(void *, size_t, size_t);
static void dumpheader(struct ktr_header *);
static void ktrgenio(struct ktr_genio *, size_t);
static void ktrnamei(const char *, size_t);
static void ktrpsig(struct ktr_psig *);
static void ktrsyscall(struct ktr_syscall *, size_t);
static const char *kresolvsysctl(int, const int *);
static void ktrsysret(struct ktr_sysret *, size_t);
static void ktruser(struct ktr_user *, size_t);
static void ktrexec(const char*, size_t);
static void ktrpledge(struct ktr_pledge *, size_t);
static void usage(void);
static void ioctldecode(int);
static void ptracedecode(int);
static void atfd(int);
static void polltimeout(int);
static void wait4pid(int);
static void signame(int);
static void semctlname(int);
static void shmctlname(int);
static void semgetname(int);
static void flagsandmodename(int);
static void clockname(int);
static void sockoptlevelname(int);
static void ktraceopname(int);

static int screenwidth;

int
main(int argc, char *argv[])
{
	int ch, silent;
	size_t ktrlen, size;
	int trpoints = ALL_POINTS;
	const char *errstr;
	void *m;

	if (screenwidth == 0) {
		struct winsize ws;

		if (fancy && ioctl(fileno(stderr), TIOCGWINSZ, &ws) != -1 &&
		    ws.ws_col > 8)
			screenwidth = ws.ws_col;
		else
			screenwidth = 80;
	}

	while ((ch = getopt(argc, argv, "f:dHlm:np:RTt:xX")) != -1)
		switch (ch) {
		case 'f':
			tracefile = optarg;
			break;
		case 'd':
			decimal = 1;
			break;
		case 'H':
			needtid = 1;
			break;
		case 'l':
			tail = 1;
			break;
		case 'm':
			maxdata = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-m %s: %s", optarg, errstr);
			break;
		case 'n':
			fancy = 0;
			break;
		case 'p':
			pid_opt = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-p %s: %s", optarg, errstr);
			break;
		case 'R':	/* relative timestamp */
			timestamp = timestamp == 1 ? 3 : 2;
			break;
		case 'T':
			timestamp = timestamp == 2 ? 3 : 1;
			break;
		case 't':
			trpoints = getpoints(optarg, DEF_POINTS);
			if (trpoints < 0)
				errx(1, "unknown trace point in %s", optarg);
			break;
		case 'x':
			iohex = 1;
			break;
		case 'X':
			iohex = 2;
			break;
		default:
			usage();
		}
	if (argc > optind)
		usage();

	if (pledge("stdio rpath getpw", NULL) == -1)
		err(1, "pledge");

	m = malloc(size = 1025);
	if (m == NULL)
		err(1, NULL);
	if (!freopen(tracefile, "r", stdin))
		err(1, "%s", tracefile);

	if (fread_tail(&ktr_header, sizeof(struct ktr_header), 1) == 0 ||
	    ktr_header.ktr_type != htobe32(KTR_START))
		errx(1, "%s: not a dump", tracefile);
	while (fread_tail(&ktr_header, sizeof(struct ktr_header), 1)) {
		silent = 0;
		if (pid_opt != -1 && pid_opt != ktr_header.ktr_pid)
			silent = 1;
		if (silent == 0 && trpoints & (1<<ktr_header.ktr_type))
			dumpheader(&ktr_header);
		ktrlen = ktr_header.ktr_len;
		if (ktrlen > size) {
			void *newm;

			if (ktrlen == SIZE_MAX)
				errx(1, "data too long");
			newm = realloc(m, ktrlen+1);
			if (newm == NULL)
				err(1, "realloc");
			m = newm;
			size = ktrlen;
		}
		if (ktrlen && fread_tail(m, ktrlen, 1) == 0)
			errx(1, "data too short");
		if (silent)
			continue;
		if ((trpoints & (1<<ktr_header.ktr_type)) == 0)
			continue;
		switch (ktr_header.ktr_type) {
		case KTR_SYSCALL:
			ktrsyscall((struct ktr_syscall *)m, ktrlen);
			break;
		case KTR_SYSRET:
			ktrsysret((struct ktr_sysret *)m, ktrlen);
			break;
		case KTR_NAMEI:
			ktrnamei(m, ktrlen);
			break;
		case KTR_GENIO:
			ktrgenio((struct ktr_genio *)m, ktrlen);
			break;
		case KTR_PSIG:
			ktrpsig((struct ktr_psig *)m);
			break;
		case KTR_STRUCT:
			ktrstruct(m, ktrlen);
			break;
		case KTR_USER:
			ktruser(m, ktrlen);
			break;
		case KTR_EXECARGS:
		case KTR_EXECENV:
			ktrexec(m, ktrlen);
			break;
		case KTR_PLEDGE:
			ktrpledge((struct ktr_pledge *)m, ktrlen);
			break;
		default:
			printf("\n");
			break;
		}
		if (tail)
			(void)fflush(stdout);
	}
	exit(0);
}

static int
fread_tail(void *buf, size_t size, size_t num)
{
	int i;

	while ((i = fread(buf, size, num, stdin)) == 0 && tail) {
		(void)sleep(1);
		clearerr(stdin);
	}
	return (i);
}

static void
dumpheader(struct ktr_header *kth)
{
	static struct timespec prevtime;
	char unknown[64], *type;
	struct timespec temp;

	switch (kth->ktr_type) {
	case KTR_SYSCALL:
		type = "CALL";
		break;
	case KTR_SYSRET:
		type = "RET ";
		break;
	case KTR_NAMEI:
		type = "NAMI";
		break;
	case KTR_GENIO:
		type = "GIO ";
		break;
	case KTR_PSIG:
		type = "PSIG";
		break;
	case KTR_STRUCT:
		type = "STRU";
		break;
	case KTR_USER:
		type = "USER";
		break;
	case KTR_EXECARGS:
		type = "ARGS";
		break;
	case KTR_EXECENV:
		type = "ENV ";
		break;
	case KTR_PLEDGE:
		type = "PLDG";
		break;
	default:
		/* htobe32() not guaranteed to work as case label */
		if (kth->ktr_type == htobe32(KTR_START)) {
			type = "STRT";
			break;
		}
		(void)snprintf(unknown, sizeof unknown, "UNKNOWN(%u)",
		    kth->ktr_type);
		type = unknown;
	}

	basecol = printf("%6ld", (long)kth->ktr_pid);
	if (needtid)
		basecol += printf("/%-7ld", (long)kth->ktr_tid);
	basecol += printf(" %-8.*s ", MAXCOMLEN, kth->ktr_comm);
	if (timestamp) {
		if (timestamp == 3) {
			if (prevtime.tv_sec == 0)
				prevtime = kth->ktr_time;
			timespecsub(&kth->ktr_time, &prevtime, &temp);
		} else if (timestamp == 2) {
			timespecsub(&kth->ktr_time, &prevtime, &temp);
			prevtime = kth->ktr_time;
		} else
			temp = kth->ktr_time;
		basecol += printf("%lld.%06ld ", (long long)temp.tv_sec,
		    temp.tv_nsec / 1000);
	}
	basecol += printf("%s  ", type);
}

/*
 * Base Formatters
 */

/* some syscalls have padding that shouldn't be shown */
static int
pad(long arg)
{
	/* nothing printed */
	return (1);
}

/* a formatter that just saves the argument for the next formatter */
int arg1;
static int
pass_two(long arg)
{
	arg1 = (int)arg;

	/* nothing printed */
	return (1);
}

static int
pdeclong(long arg)
{
	(void)printf("%ld", arg);
	return (0);
}

static int
pdeculong(long arg)
{
	(void)printf("%lu", arg);
	return (0);
}

static int
phexlong(long arg)
{
	(void)printf("%#lx", arg);
	return (0);
}

static int
pnonfancy(long arg)
{
	if (decimal)
		(void)printf("%ld", arg);
	else
		(void)printf("%#lx", arg);
	return (0);
}

static void
pdecint(int arg)
{
	(void)printf("%d", arg);
}

static void
pdecuint(int arg)
{
	(void)printf("%u", arg);
}

static void
phexint(int arg)
{
	(void)printf("%#x", arg);
}

static void
poctint(int arg)
{
	(void)printf("%#o", arg);
}


#ifdef __LP64__

/* on LP64, long long arguments are the same as long arguments */
#define Phexlonglong	Phexlong
#define phexll		NULL		/* not actually used on LP64 */

#else /* __LP64__ */

/* on ILP32, long long arguments are passed as two 32bit args */
#define Phexlonglong	PASS_LONGLONG, Phexll

static int
phexll(long arg2)
{
	long long val;

#if _BYTE_ORDER == _LITTLE_ENDIAN
	val = ((long long)arg2 << 32) | ((long long)arg1 & 0xffffffff);
#else
	val = ((long long)arg1 << 32) | ((long long)arg2 & 0xffffffff);
#endif

	if (fancy || !decimal)
		(void)printf("%#llx", val);
	else
		(void)printf("%lld", val);
	return (0);
}

#endif /* __LP64__ */

static int (*long_formatters[])(long) = {
	NULL,
	pdeclong,
	pdeculong,
	phexlong,
	pass_two,
	pass_two,
	phexll,
	pad,
	pnonfancy,
};

static void (*formatters[])(int) = {
	NULL,
	pdecint,
	phexint,
	poctint,
	pdecuint,
	ioctldecode,
	ptracedecode,
	atfd,
	polltimeout,
	wait4pid,
	signame,
	semctlname,
	shmctlname,
	semgetname,
	flagsandmodename,
	clockname,
	sockoptlevelname,
	ktraceopname,
	fcntlcmdname,
	modename,
	flagsname,
	openflagsname,
	atflagsname,
	accessmodename,
	mmapprotname,
	mmapflagsname,
	wait4optname,
	sendrecvflagsname,
	mountflagsname,
	rebootoptname,
	flockname,
	sockoptname,
	sockipprotoname,
	socktypename,
	sockflagsname,
	sockfamilyname,
	mlockallname,
	shmatname,
	whencename,
	pathconfname,
	rlimitname,
	shutdownhowname,
	prioname,
	madvisebehavname,
	msyncflagsname,
	clocktypename,
	rusagewho,
	sigactionflagname,
	sigprocmaskhowname,
	minheritname,
	quotactlname,
	sigill_name,
	sigtrap_name,
	sigemt_name,
	sigfpe_name,
	sigbus_name,
	sigsegv_name,
	sigchld_name,
	ktracefacname,
	itimername,
	sigset,
	uidname,
	gidname,
	syslogflagname,
	futexflagname,
};

enum {
	/* the end of the (known) arguments is recognized by the zero fill */
	end_of_args	=  0,

	/* negative are the negative of the index into long_formatters[] */
	Pdeclong	= -1,
	Pdeculong	= -2,
	Phexlong	= -3,
	PASS_TWO	= -4,

/* the remaining long formatters still get called when non-fancy (-n option) */
#define FMT_IS_NONFANCY(x)	((x) <= PASS_LONGLONG)
	PASS_LONGLONG	= -5,
	Phexll		= -6,
	PAD		= -7,
	Pnonfancy	= -8,

	/* positive values are the index into formatters[] */
	Pdecint		= 1,
	Phexint,
	Poctint,
	Pdecuint,
	Ioctldecode,
	Ptracedecode,
	Atfd,
	Polltimeout,
	Wait4pid,
	Signame,
	Semctlname,
	Shmctlname,
	Semgetname,
	Flagsandmodename,
	Clockname,
	Sockoptlevelname,
	Ktraceopname,
	Fcntlcmdname,
	Modename,
	Flagsname,
	Openflagsname,
	Atflagsname,
	Accessmodename,
	Mmapprotname,
	Mmapflagsname,
	Wait4optname,
	Sendrecvflagsname,
	Mountflagsname,
	Rebootoptname,
	Flockname,
	Sockoptname,
	Sockipprotoname,
	Socktypename,
	Sockflagsname,
	Sockfamilyname,
	Mlockallname,
	Shmatname,
	Whencename,
	Pathconfname,
	Rlimitname,
	Shutdownhowname,
	Prioname,
	Madvisebehavname,
	Msyncflagsname,
	Clocktypename,
	Rusagewho,
	Sigactionflagname,
	Sigprocmaskhowname,
	Minheritname,
	Quotactlname,
	Sigill_name,
	Sigtrap_name,
	Sigemt_name,
	Sigfpe_name,
	Sigbus_name,
	Sigsegv_name,
	Sigchld_name,
	Ktracefacname,
	Itimername,
	Sigset,
	Uidname,
	Gidname,
	Syslogflagname,
	Futexflagname,
};

#define Pptr		Phexlong
#define	Psize		Pdeculong	/* size_t for small buffers */
#define	Pbigsize	Phexlong	/* size_t for I/O buffers */
#define Pcount		Pdecint		/* int for a count of something */
#define Pfd		Pdecint
#define Ppath		Phexlong
#define Pdev_t		Pdecint
#define Ppid_t		Pdecint
#define Ppgid		Pdecint		/* pid or negative pgid */
#define Poff_t		Phexlonglong
#define Pmsqid		Pdecint
#define Pshmid		Pdecint
#define Psemid		Pdecint
#define Pkey_t		Pdecint
#define Pucount		Pdecuint
#define Chflagsname	Phexlong	/* to be added */
#define Sockprotoname	Phexlong	/* to be added */
#define Swapctlname	Phexlong	/* to be added */
#define Msgflgname	Phexlong	/* to be added */


typedef signed char formatter;
static const formatter scargs[][8] = {
    [SYS_exit]		= { Pdecint },
    [SYS_read]		= { Pfd, Pptr, Pbigsize },
    [SYS_write]		= { Pfd, Pptr, Pbigsize },
    [SYS_open]		= { Ppath, PASS_TWO, Flagsandmodename },
    [SYS_close]		= { Pfd },
    [SYS_getentropy]	= { Pptr, Psize },
    [SYS___tfork]	= { Pptr, Psize },
    [SYS_link]		= { Ppath, Ppath },
    [SYS_unlink]	= { Ppath },
    [SYS_wait4]		= { Wait4pid, Pptr, Wait4optname },
    [SYS_chdir]		= { Ppath },
    [SYS_fchdir]	= { Pfd },
    [SYS_mknod]		= { Ppath, Modename, Pdev_t },
    [SYS_chmod]		= { Ppath, Modename },
    [SYS_chown]		= { Ppath, Uidname, Gidname },
    [SYS_break]		= { Pptr },
    [SYS_getrusage]	= { Rusagewho, Pptr },
    [SYS_mount]		= { Pptr, Ppath, Mountflagsname, Pptr },
    [SYS_unmount]	= { Ppath, Mountflagsname },
    [SYS_setuid]	= { Uidname },
    [SYS_ptrace]	= { Ptracedecode, Ppid_t, Pptr, Pdecint },
    [SYS_recvmsg]	= { Pfd, Pptr, Sendrecvflagsname },
    [SYS_sendmsg]	= { Pfd, Pptr, Sendrecvflagsname },
    [SYS_recvfrom]	= { Pfd, Pptr, Pbigsize, Sendrecvflagsname },
    [SYS_accept]	= { Pfd, Pptr, Pptr },
    [SYS_getpeername]	= { Pfd, Pptr, Pptr },
    [SYS_getsockname]	= { Pfd, Pptr, Pptr },
    [SYS_access]	= { Ppath, Accessmodename },
    [SYS_chflags]	= { Ppath, Chflagsname },
    [SYS_fchflags]	= { Pfd, Chflagsname },
    [SYS_kill]		= { Ppgid, Signame },
    [SYS_stat]		= { Ppath, Pptr },
    [SYS_lstat]		= { Ppath, Pptr },
    [SYS_dup]		= { Pfd },
    [SYS_fstatat]	= { Atfd, Ppath, Pptr, Atflagsname },
    [SYS_profil]	= { Pptr, Pbigsize, Pbigsize, Pdecuint },
    [SYS_ktrace]	= { Ppath, Ktraceopname, Ktracefacname, Ppgid },
    [SYS_sigaction]	= { Signame, Pptr, Pptr },
    [SYS_sigprocmask]	= { Sigprocmaskhowname, Sigset },
    [SYS_getlogin_r]	= { Pptr, Psize },
    [SYS_setlogin]	= { Pptr },
    [SYS_acct]		= { Ppath },
    [SYS_fstat]		= { Pfd, Pptr },
    [SYS_ioctl]		= { Pfd, Ioctldecode, Pptr },
    [SYS_reboot]	= { Rebootoptname },
    [SYS_revoke]	= { Ppath },
    [SYS_symlink]	= { Ppath, Ppath },
    [SYS_readlink]	= { Ppath, Pptr, Psize },
    [SYS_execve]	= { Ppath, Pptr, Pptr },
    [SYS_umask]		= { Modename },
    [SYS_chroot]	= { Ppath },
    [SYS_getfsstat]	= { Pptr, Pbigsize, Mountflagsname },
    [SYS_statfs]	= { Ppath, Pptr },
    [SYS_fstatfs]	= { Pfd, Pptr },
    [SYS_fhstatfs]	= { Pptr, Pptr },
    [SYS_gettimeofday]	= { Pptr, Pptr },
    [SYS_settimeofday]	= { Pptr, Pptr },
    [SYS_setitimer]	= { Itimername, Pptr, Pptr },
    [SYS_getitimer]	= { Itimername, Pptr },
    [SYS_select]	= { Pcount, Pptr, Pptr, Pptr, Pptr },
    [SYS_kevent]	= { Pfd, Pptr, Pcount, Pptr, Pcount, Pptr },
    [SYS_munmap]	= { Pptr, Pbigsize },
    [SYS_mprotect]	= { Pptr, Pbigsize, Mmapprotname },
    [SYS_madvise]	= { Pptr, Pbigsize, Madvisebehavname },
    [SYS_utimes]	= { Ppath, Pptr },
    [SYS_futimes]	= { Pfd, Pptr },
    [SYS_kbind]		= { Pptr, Psize, Phexlonglong },
    [SYS_mincore]	= { Pptr, Pbigsize, Pptr },
    [SYS_getgroups]	= { Pcount, Pptr },
    [SYS_setgroups]	= { Pcount, Pptr },
    [SYS_setpgid]	= { Ppid_t, Ppid_t },
    [SYS_futex]		= { Pptr, Futexflagname, Pcount, Pptr, Pptr },
    [SYS_sendsyslog]	= { Pptr, Psize, Syslogflagname },
    [SYS_utimensat]	= { Atfd, Ppath, Pptr, Atflagsname },
    [SYS_futimens]	= { Pfd, Pptr },
    [SYS_clock_gettime]	= { Clockname, Pptr },
    [SYS_clock_settime]	= { Clockname, Pptr },
    [SYS_clock_getres]	= { Clockname, Pptr },
    [SYS_dup2]		= { Pfd, Pfd },
    [SYS_nanosleep]	= { Pptr, Pptr },
    [SYS_fcntl]		= { Pfd, PASS_TWO, Fcntlcmdname },
    [SYS_accept4]	= { Pfd, Pptr, Pptr, Sockflagsname },
    [SYS___thrsleep]	= { Pptr, Clockname, Pptr, Pptr, Pptr },
    [SYS_fsync]		= { Pfd },
    [SYS_setpriority]	= { Prioname, Ppid_t, Pdecint },
    [SYS_socket]	= { Sockfamilyname, Socktypename, Sockprotoname },
    [SYS_connect]	= { Pfd, Pptr, Pucount },
    [SYS_getdents]	= { Pfd, Pptr, Pbigsize },
    [SYS_getpriority]	= { Prioname, Ppid_t },
    [SYS_pipe2]		= { Pptr, Flagsname },
    [SYS_dup3]		= { Pfd, Pfd, Flagsname },
    [SYS_sigreturn]	= { Pptr },
    [SYS_bind]		= { Pfd, Pptr, Pucount },
    [SYS_setsockopt]	= { Pfd, PASS_TWO, Sockoptlevelname, Pptr, Pdecint },
    [SYS_listen]	= { Pfd, Pdecint },
    [SYS_chflagsat]	= { Atfd, Ppath, Chflagsname, Atflagsname },
    [SYS_ppoll]		= { Pptr, Pucount, Pptr, Pptr },
    [SYS_pselect]	= { Pcount, Pptr, Pptr, Pptr, Pptr, Pptr },
    [SYS_sigsuspend]	= { Sigset },
    [SYS_getsockopt]	= { Pfd, PASS_TWO, Sockoptlevelname, Pptr, Pptr },
    [SYS_thrkill]	= { Ppid_t, Signame, Pptr },
    [SYS_readv]		= { Pfd, Pptr, Pcount },
    [SYS_writev]	= { Pfd, Pptr, Pcount },
    [SYS_fchown]	= { Pfd, Uidname, Gidname },
    [SYS_fchmod]	= { Pfd, Modename },
    [SYS_setreuid]	= { Uidname, Uidname },
    [SYS_setregid]	= { Gidname, Gidname },
    [SYS_rename]	= { Ppath, Ppath },
    [SYS_flock]		= { Pfd, Flockname },
    [SYS_mkfifo]	= { Ppath, Modename },
    [SYS_sendto]	= { Pfd, Pptr, Pbigsize, Sendrecvflagsname },
    [SYS_shutdown]	= { Pfd, Shutdownhowname },
    [SYS_socketpair]	= { Sockfamilyname, Socktypename, Sockprotoname, Pptr },
    [SYS_mkdir]		= { Ppath, Modename },
    [SYS_rmdir]		= { Ppath },
    [SYS_adjtime]	= { Pptr, Pptr },
    [SYS_quotactl]	= { Ppath, Quotactlname, Uidname, Pptr },
    [SYS_nfssvc]	= { Phexint, Pptr },
    [SYS_getfh]		= { Ppath, Pptr },
    [SYS_sysarch]	= { Pdecint, Pptr },
    [SYS_pread]		= { Pfd, Pptr, Pbigsize, PAD, Poff_t },
    [SYS_pwrite]	= { Pfd, Pptr, Pbigsize, PAD, Poff_t },
    [SYS_setgid]	= { Gidname },
    [SYS_setegid]	= { Gidname },
    [SYS_seteuid]	= { Uidname },
    [SYS_pathconf]	= { Ppath, Pathconfname },
    [SYS_fpathconf]	= { Pfd, Pathconfname },
    [SYS_swapctl]	= { Swapctlname, Pptr, Pdecint },
    [SYS_getrlimit]	= { Rlimitname, Pptr },
    [SYS_setrlimit]	= { Rlimitname, Pptr },
    [SYS_mmap]		= { Pptr, Pbigsize, Mmapprotname, Mmapflagsname, Pfd, PAD, Poff_t },
    [SYS_lseek]		= { Pfd, PAD, Poff_t, Whencename },
    [SYS_truncate]	= { Ppath, PAD, Poff_t },
    [SYS_ftruncate]	= { Pfd, PAD, Poff_t },
    [SYS_sysctl]	= { Pptr, Pcount, Pptr, Pptr, Pptr, Psize },
    [SYS_mlock]		= { Pptr, Pbigsize },
    [SYS_munlock]	= { Pptr, Pbigsize },
    [SYS_getpgid]	= { Ppid_t },
    [SYS_utrace]	= { Pptr, Pptr, Psize },
    [SYS_semget]	= { Pkey_t, Pcount, Semgetname },
    [SYS_msgget]	= { Pkey_t, Msgflgname },
    [SYS_msgsnd]	= { Pmsqid, Pptr, Psize, Msgflgname },
    [SYS_msgrcv]	= { Pmsqid, Pptr, Psize, Pdeclong, Msgflgname },
    [SYS_shmat]		= { Pshmid, Pptr, Shmatname },
    [SYS_shmdt]		= { Pptr },
    [SYS_minherit]	= { Pptr, Pbigsize, Minheritname },
    [SYS_poll]		= { Pptr, Pucount, Polltimeout },
    [SYS_lchown]	= { Ppath, Uidname, Gidname },
    [SYS_getsid]	= { Ppid_t },
    [SYS_msync]		= { Pptr, Pbigsize, Msyncflagsname },
    [SYS_pipe]		= { Pptr },
    [SYS_fhopen]	= { Pptr, Openflagsname },
    [SYS_preadv]	= { Pfd, Pptr, Pcount, PAD, Poff_t },
    [SYS_pwritev]	= { Pfd, Pptr, Pcount, PAD, Poff_t },
    [SYS_mlockall]	= { Mlockallname },
    [SYS_getresuid]	= { Pptr, Pptr, Pptr },
    [SYS_setresuid]	= { Uidname, Uidname, Uidname },
    [SYS_getresgid]	= { Pptr, Pptr, Pptr },
    [SYS_setresgid]	= { Gidname, Gidname, Gidname },
    [SYS_mquery]	= { Pptr, Pbigsize, Mmapprotname, Mmapflagsname, Pfd, PAD, Poff_t },
    [SYS_closefrom]	= { Pfd },
    [SYS_sigaltstack]	= { Pptr, Pptr },
    [SYS_shmget]	= { Pkey_t, Pbigsize, Semgetname },
    [SYS_semop]		= { Psemid, Pptr, Psize },
    [SYS_fhstat]	= { Pptr, Pptr },
    [SYS___semctl]	= { Psemid, Pcount, Semctlname, Pptr },
    [SYS_shmctl]	= { Pshmid, Shmctlname, Pptr },
    [SYS_msgctl]	= { Pmsqid, Shmctlname, Pptr },
    [SYS___thrwakeup]	= { Pptr, Pcount },
    [SYS___threxit]	= { Pptr },
    [SYS___thrsigdivert] = { Sigset, Pptr, Pptr },
    [SYS___getcwd]	= { Pptr, Psize },
    [SYS_adjfreq]	= { Pptr, Pptr },
    [SYS_setrtable]	= { Pdecint },
    [SYS_faccessat]	= { Atfd, Ppath, Accessmodename, Atflagsname },
    [SYS_fchmodat]	= { Atfd, Ppath, Modename, Atflagsname },
    [SYS_fchownat]	= { Atfd, Ppath, Uidname, Gidname, Atflagsname },
    [SYS_linkat]	= { Atfd, Ppath, Atfd, Ppath, Atflagsname },
    [SYS_mkdirat]	= { Atfd, Ppath, Modename },
    [SYS_mkfifoat]	= { Atfd, Ppath, Modename },
    [SYS_mknodat]	= { Atfd, Ppath, Modename, Pdev_t },
    [SYS_openat]	= { Atfd, Ppath, PASS_TWO, Flagsandmodename },
    [SYS_readlinkat]	= { Atfd, Ppath, Pptr, Psize },
    [SYS_renameat]	= { Atfd, Ppath, Atfd, Ppath },
    [SYS_symlinkat]	= { Ppath, Atfd, Ppath },
    [SYS_unlinkat]	= { Atfd, Ppath, Atflagsname },
    [SYS___set_tcb]	= { Pptr },
};


static void
ktrsyscall(struct ktr_syscall *ktr, size_t ktrlen)
{
	register_t *ap;
	int narg;
	char sep;

	if (ktr->ktr_argsize > ktrlen)
		errx(1, "syscall argument length %d > ktr header length %zu",
		    ktr->ktr_argsize, ktrlen);

	narg = ktr->ktr_argsize / sizeof(register_t);
	sep = '\0';

	if (ktr->ktr_code >= SYS_MAXSYSCALL || ktr->ktr_code < 0)
		(void)printf("[%d]", ktr->ktr_code);
	else
		(void)printf("%s", syscallnames[ktr->ktr_code]);
	ap = (register_t *)((char *)ktr + sizeof(struct ktr_syscall));
	(void)putchar('(');

	if (ktr->ktr_code == SYS_sysctl && fancy) {
		const char *s;
		int n, i, *top;

		n = ap[1];
		if (n > CTL_MAXNAME)
			n = CTL_MAXNAME;
		if (n < 0)
			errx(1, "invalid sysctl length %d", n);
		if (n > 0) {
			top = (int *)(ap + 6);
			printf("%d", top[0]);
			for (i = 1; i < n; i++)
				printf(".%d", top[i]);
			if ((s = kresolvsysctl(0, top)) != NULL) {
				printf("<%s", s);
				for (i = 1; i < n; i++) {
					if ((s = kresolvsysctl(i, top)) != NULL)
						printf(".%s", s);
					else
						printf(".%d", top[i]);
				}
				putchar('>');
			}
		}

		sep = ',';
		ap += 2;
		narg -= 2;
	} else if (ktr->ktr_code < nitems(scargs)) {
		const formatter *fmts = scargs[ktr->ktr_code];
		int fmt;

		while (narg && (fmt = *fmts) != 0) {
			if (sep)
				putchar(sep);
			sep = ',';
			if (!fancy && !FMT_IS_NONFANCY(fmt))
				fmt = Pnonfancy;
			if (fmt > 0)
				formatters[fmt]((int)*ap);
			else if (long_formatters[-fmt](*ap))
				sep = '\0';
			fmts++;
			ap++;
			narg--;
		}
	}

	while (narg > 0) {
		if (sep)
			putchar(sep);
		if (decimal)
			(void)printf("%ld", (long)*ap);
		else
			(void)printf("%#lx", (long)*ap);
		sep = ',';
		ap++;
		narg--;
	}
	(void)printf(")\n");
}

static struct ctlname topname[] = CTL_NAMES;
static struct ctlname kernname[] = CTL_KERN_NAMES;
static struct ctlname vmname[] = CTL_VM_NAMES;
static struct ctlname fsname[] = CTL_FS_NAMES;
static struct ctlname netname[] = CTL_NET_NAMES;
static struct ctlname hwname[] = CTL_HW_NAMES;
static struct ctlname debugname[CTL_DEBUG_MAXID];
static struct ctlname kernmallocname[] = CTL_KERN_MALLOC_NAMES;
static struct ctlname forkstatname[] = CTL_KERN_FORKSTAT_NAMES;
static struct ctlname nchstatsname[] = CTL_KERN_NCHSTATS_NAMES;
static struct ctlname kernprocname[] = {
	{ NULL },
	{ "all" },
	{ "pid" },
	{ "pgrp" },
	{ "session" },
	{ "tty" },
	{ "uid" },
	{ "ruid" },
	{ "kthread" },
};
static struct ctlname ttysname[] = CTL_KERN_TTY_NAMES;
static struct ctlname semname[] = CTL_KERN_SEMINFO_NAMES;
static struct ctlname shmname[] = CTL_KERN_SHMINFO_NAMES;
static struct ctlname watchdogname[] = CTL_KERN_WATCHDOG_NAMES;
static struct ctlname tcname[] = CTL_KERN_TIMECOUNTER_NAMES;
#ifdef CTL_MACHDEP_NAMES
static struct ctlname machdepname[] = CTL_MACHDEP_NAMES;
#endif
static struct ctlname ddbname[] = CTL_DDB_NAMES;

#ifndef nitems
#define nitems(_a)    (sizeof((_a)) / sizeof((_a)[0]))
#endif

#define SETNAME(name) do { names = (name); limit = nitems(name); } while (0)

static const char *
kresolvsysctl(int depth, const int *top)
{
	struct ctlname *names;
	size_t		limit;
	int		idx = top[depth];

	names = NULL;

	switch (depth) {
	case 0:
		SETNAME(topname);
		break;
	case 1:
		switch (top[0]) {
		case CTL_KERN:
			SETNAME(kernname);
			break;
		case CTL_VM:
			SETNAME(vmname);
			break;
		case CTL_FS:
			SETNAME(fsname);
			break;
		case CTL_NET:
			SETNAME(netname);
			break;
		case CTL_DEBUG:
			SETNAME(debugname);
			break;
		case CTL_HW:
			SETNAME(hwname);
			break;
#ifdef CTL_MACHDEP_NAMES
		case CTL_MACHDEP:
			SETNAME(machdepname);
			break;
#endif
		case CTL_DDB:
			SETNAME(ddbname);
			break;
		}
		break;
	case 2:
		switch (top[0]) {
		case CTL_KERN:
			switch (top[1]) {
			case KERN_MALLOCSTATS:
				SETNAME(kernmallocname);
				break;
			case KERN_FORKSTAT:
				SETNAME(forkstatname);
				break;
			case KERN_NCHSTATS:
				SETNAME(nchstatsname);
				break;
			case KERN_TTY:
				SETNAME(ttysname);
				break;
			case KERN_SEMINFO:
				SETNAME(semname);
				break;
			case KERN_SHMINFO:
				SETNAME(shmname);
				break;
			case KERN_WATCHDOG:
				SETNAME(watchdogname);
				break;
			case KERN_PROC:
				idx++;	/* zero is valid at this level */
				SETNAME(kernprocname);
				break;
			case KERN_TIMECOUNTER:
				SETNAME(tcname);
				break;
			}
		}
		break;
	}
	if (names != NULL && idx > 0 && idx < limit)
		return (names[idx].ctl_name);
	return (NULL);
}

static void
ktrsysret(struct ktr_sysret *ktr, size_t ktrlen)
{
	register_t ret = 0;
	long long retll;
	int error = ktr->ktr_error;
	int code = ktr->ktr_code;

	if (ktrlen < sizeof(*ktr))
		errx(1, "sysret length %zu < ktr header length %zu",
		    ktrlen, sizeof(*ktr));
	ktrlen -= sizeof(*ktr);
	if (error == 0) {
		if (ktrlen == sizeof(ret)) {
			memcpy(&ret, ktr+1, sizeof(ret));
			retll = ret;
		} else if (ktrlen == sizeof(retll))
			memcpy(&retll, ktr+1, sizeof(retll));
		else
			errx(1, "sysret bogus length %zu", ktrlen);
	}

	if (code >= SYS_MAXSYSCALL || code < 0)
		(void)printf("[%d] ", code);
	else
		(void)printf("%s ", syscallnames[code]);

doerr:
	if (error == 0) {
		if (fancy) {
			switch (code) {
			case SYS_lseek:
				(void)printf("%lld", retll);
				if (retll < 0 || retll > 9)
					(void)printf("/%#llx", retll);
				break;
			case SYS_sigprocmask:
			case SYS_sigpending:
				sigset(ret);
				break;
			case SYS___thrsigdivert:
				signame(ret);
				break;
			case SYS_getuid:
			case SYS_geteuid:
				uidname(ret);
				break;
			case SYS_getgid:
			case SYS_getegid:
				gidname(ret);
				break;
			/* syscalls that return errno values */
			case SYS_getlogin_r:
			case SYS___thrsleep:
				if ((error = ret) != 0)
					goto doerr;
				/* FALLTHROUGH */
			default:
				(void)printf("%ld", (long)ret);
				if (ret < 0 || ret > 9)
					(void)printf("/%#lx", (long)ret);
			}
		} else {
			if (decimal)
				(void)printf("%lld", retll);
			else
				(void)printf("%#llx", retll);
		}
	} else if (error == ERESTART)
		(void)printf("RESTART");
	else if (error == EJUSTRETURN)
		(void)printf("JUSTRETURN");
	else {
		(void)printf("-1 errno %d", error);
		if (fancy)
			(void)printf(" %s", strerror(error));
	}
	(void)putchar('\n');
}

static void
ktrnamei(const char *cp, size_t len)
{
	showbufc(basecol, (unsigned char *)cp, len, VIS_DQ | VIS_TAB | VIS_NL);
}

void
showbufc(int col, unsigned char *dp, size_t datalen, int flags)
{
	int width;
	unsigned char visbuf[5], *cp;

	flags |= VIS_CSTYLE;
	putchar('"');
	col++;
	for (; datalen > 0; datalen--, dp++) {
		(void)vis(visbuf, *dp, flags, *(dp+1));
		cp = visbuf;

		/*
		 * Keep track of printables and
		 * space chars (like fold(1)).
		 */
		if (col == 0) {
			(void)putchar('\t');
			col = 8;
		}
		switch (*cp) {
		case '\n':
			col = 0;
			(void)putchar('\n');
			continue;
		case '\t':
			width = 8 - (col&07);
			break;
		default:
			width = strlen(cp);
		}
		if (col + width > (screenwidth-2)) {
			(void)printf("\\\n\t");
			col = 8;
		}
		col += width;
		do {
			(void)putchar(*cp++);
		} while (*cp);
	}
	if (col == 0)
		(void)printf("       ");
	(void)printf("\"\n");
}

static void
showbuf(unsigned char *dp, size_t datalen)
{
	int i, j;
	int col = 0, bpl;
	unsigned char c;

	if (iohex == 1) {
		putchar('\t');
		col = 8;
		for (i = 0; i < datalen; i++) {
			printf("%02x", dp[i]);
			col += 3;
			if (i < datalen - 1) {
				if (col + 3 > screenwidth) {
					printf("\n\t");
					col = 8;
				} else
					putchar(' ');
			}
		}
		putchar('\n');
		return;
	}
	if (iohex == 2) {
		bpl = (screenwidth - 13)/4;
		if (bpl <= 0)
			bpl = 1;
		for (i = 0; i < datalen; i += bpl) {
			printf("   %04x:  ", i);
			for (j = 0; j < bpl; j++) {
				if (i+j >= datalen)
					printf("   ");
				else
					printf("%02x ", dp[i+j]);
			}
			putchar(' ');
			for (j = 0; j < bpl; j++) {
				if (i+j >= datalen)
					break;
				c = dp[i+j];
				if (!isprint(c))
					c = '.';
				putchar(c);
			}
			putchar('\n');
		}
		return;
	}

	(void)printf("       ");
	showbufc(7, dp, datalen, 0);
}

static void
ktrgenio(struct ktr_genio *ktr, size_t len)
{
	unsigned char *dp = (unsigned char *)ktr + sizeof(struct ktr_genio);
	size_t datalen;

	if (len < sizeof(struct ktr_genio))
		errx(1, "invalid ktr genio length %zu", len);

	datalen = len - sizeof(struct ktr_genio);

	printf("fd %d %s %zu bytes\n", ktr->ktr_fd,
		ktr->ktr_rw == UIO_READ ? "read" : "wrote", datalen);
	if (maxdata == 0)
		return;
	if (datalen > maxdata)
		datalen = maxdata;
	if (iohex && !datalen)
		return;
	showbuf(dp, datalen);
}

static void
ktrpsig(struct ktr_psig *psig)
{
	signame(psig->signo);
	printf(" ");
	if (psig->action == SIG_DFL)
		(void)printf("SIG_DFL");
	else {
		(void)printf("caught handler=0x%lx mask=",
		    (u_long)psig->action);
		sigset(psig->mask);
	}
	if (psig->code) {
		printf(" code ");
		if (fancy) {
			switch (psig->signo) {
			case SIGILL:
				sigill_name(psig->code);
				break;
			case SIGTRAP:
				sigtrap_name(psig->code);
				break;
			case SIGEMT:
				sigemt_name(psig->code);
				break;
			case SIGFPE:
				sigfpe_name(psig->code);
				break;
			case SIGBUS:
				sigbus_name(psig->code);
				break;
			case SIGSEGV:
				sigsegv_name(psig->code);
				break;
			case SIGCHLD:
				sigchld_name(psig->code);
				break;
			}
		}
		printf("<%d>", psig->code);
	}

	switch (psig->signo) {
	case SIGSEGV:
	case SIGILL:
	case SIGBUS:
	case SIGFPE:
		printf(" addr=%p trapno=%d", psig->si.si_addr,
		    psig->si.si_trapno);
		break;
	default:
		break;
	}
	printf("\n");
}

static void
ktruser(struct ktr_user *usr, size_t len)
{
	if (len < sizeof(struct ktr_user))
		errx(1, "invalid ktr user length %zu", len);
	len -= sizeof(struct ktr_user);
	printf("%.*s:", KTR_USER_MAXIDLEN, usr->ktr_id);
	printf(" %zu bytes\n", len);
	showbuf((unsigned char *)(usr + 1), len);
}

static void
ktrexec(const char *ptr, size_t len)
{
	int i, col;
	size_t l;

	putchar('\n');
	i = 0;
	while (len > 0) {
		l = strnlen(ptr, len);
		col = printf("\t[%d] = ", i++);
		col += 7;	/* tab expands from 1 to 8 columns */
		showbufc(col, (unsigned char *)ptr, l, VIS_DQ|VIS_TAB|VIS_NL);
		if (l == len) {
			printf("\tunterminated argument\n");
			break;
		}
		len -= l + 1;
		ptr += l + 1;
	}
}

static void
ktrpledge(struct ktr_pledge *pledge, size_t len)
{
	char *name = "";
	int i;

	if (len < sizeof(struct ktr_pledge))
		errx(1, "invalid ktr pledge length %zu", len);

	if (pledge->syscall >= SYS_MAXSYSCALL || pledge->syscall < 0)
		(void)printf("[%d]", pledge->syscall);
	else
		(void)printf("%s", syscallnames[pledge->syscall]);
	printf(", ");
	for (i = 0; pledge->code && pledgenames[i].bits != 0; i++) {
		if (pledgenames[i].bits & pledge->code) {
			name = pledgenames[i].name;
			break;
		}
	}
	printf("\"%s\"", name);
	(void)printf(", errno %d", pledge->error);
	if (fancy)
		(void)printf(" %s", strerror(pledge->error));
	printf("\n");
}

static void
usage(void)
{

	extern char *__progname;
	fprintf(stderr, "usage: %s "
	    "[-dHlnRTXx] [-f file] [-m maxdata] [-p pid]\n"
	    "%*s[-t [cinpstuxX+]]\n",
	    __progname, (int)(sizeof("usage: ") + strlen(__progname)), "");
	exit(1);
}


/*
 * FORMATTERS
 */

static void
ioctldecode(int cmd)
{
	char dirbuf[4], *dir = dirbuf;
	const char *cp;

	if ((cp = ioctlname((unsigned)cmd)) != NULL) {
		(void)printf("%s", cp);
		return;
	}

	if (cmd & IOC_IN)
		*dir++ = 'W';
	if (cmd & IOC_OUT)
		*dir++ = 'R';
	*dir = '\0';

	printf("_IO%s('%c',%d",
	    dirbuf, (int)((cmd >> 8) & 0xff), cmd & 0xff);
	if ((cmd & IOC_VOID) == 0)
		printf(decimal ? ",%u)" : ",%#x)", (cmd >> 16) & 0xff);
	else
		printf(")");
}

static void
ptracedecode(int request)
{
	if (request >= 0 && request < nitems(ptrace_ops))
		(void)printf("%s", ptrace_ops[request]);
	else switch(request) {
#ifdef PT_GETFPREGS
	case PT_GETFPREGS:
		(void)printf("PT_GETFPREGS");
		break;
#endif
	case PT_GETREGS:
		(void)printf("PT_GETREGS");
		break;
#ifdef PT_GETXMMREGS
	case PT_GETXMMREGS:
		(void)printf("PT_GETXMMREGS");
		break;
#endif
#ifdef PT_SETFPREGS
	case PT_SETFPREGS:
		(void)printf("PT_SETFPREGS");
		break;
#endif
	case PT_SETREGS:
		(void)printf("PT_SETREGS");
		break;
#ifdef PT_SETXMMREGS
	case PT_SETXMMREGS:
		(void)printf("PT_SETXMMREGS");
		break;
#endif
#ifdef PT_STEP
	case PT_STEP:
		(void)printf("PT_STEP");
		break;
#endif
#ifdef PT_WCOOKIE
	case PT_WCOOKIE:
		(void)printf("PT_WCOOKIE");
		break;
#endif
	default:
		pdecint(request);
	}
}


static void
atfd(int fd)
{
	if (fd == AT_FDCWD)
		(void)printf("AT_FDCWD");
	else
		pdecint(fd);
}

static void
polltimeout(int timeout)
{
	if (timeout == INFTIM)
		(void)printf("INFTIM");
	else
		pdecint(timeout);
}

static void
wait4pid(int pid)
{
	if (pid == WAIT_ANY)
		(void)printf("WAIT_ANY");
	else if (pid == WAIT_MYPGRP)
		(void)printf("WAIT_MYPGRP");
	else
		pdecint(pid);		/* ppgid */
}

static void
signame(int sig)
{
	if (sig > 0 && sig < NSIG)
		(void)printf("SIG%s", sys_signame[sig]);
	else
		(void)printf("SIG %d", sig);
}

void
sigset(int ss)
{
	int	or = 0;
	int	cnt = 0;
	int	i;

	for (i = 1; i < NSIG; i++)
		if (sigismember(&ss, i))
			cnt++;
	if (cnt > (NSIG-1)/2) {
		ss = ~ss;
		putchar('~');
	}

	if (ss == 0) {
		(void)printf("0<>");
		return;
	}

	printf("%#x<", ss);
	for (i = 1; i < NSIG; i++)
		if (sigismember(&ss, i)) {
			if (or) putchar('|'); else or=1;
			signame(i);
		}
	printf(">");
}

static void
semctlname(int cmd)
{
	switch (cmd) {
	case GETNCNT:
		(void)printf("GETNCNT");
		break;
	case GETPID:
		(void)printf("GETPID");
		break;
	case GETVAL:
		(void)printf("GETVAL");
		break;
	case GETALL:
		(void)printf("GETALL");
		break;
	case GETZCNT:
		(void)printf("GETZCNT");
		break;
	case SETVAL:
		(void)printf("SETVAL");
		break;
	case SETALL:
		(void)printf("SETALL");
		break;
	case IPC_RMID:
		(void)printf("IPC_RMID");
		break;
	case IPC_SET:
		(void)printf("IPC_SET");
		break;
	case IPC_STAT:
		(void)printf("IPC_STAT");
		break;
	default: /* Should not reach */
		(void)printf("<invalid=%d>", cmd);
	}
}

static void
shmctlname(int cmd)
{
	switch (cmd) {
	case IPC_RMID:
		(void)printf("IPC_RMID");
		break;
	case IPC_SET:
		(void)printf("IPC_SET");
		break;
	case IPC_STAT:
		(void)printf("IPC_STAT");
		break;
	default: /* Should not reach */
		(void)printf("<invalid=%d>", cmd);
	}
}


static void
semgetname(int flag)
{
	int	or = 0;
	if_print_or(flag, IPC_CREAT, or);
	if_print_or(flag, IPC_EXCL, or);
	if_print_or(flag, SEM_R, or);
	if_print_or(flag, SEM_A, or);
	if_print_or(flag, (SEM_R>>3), or);
	if_print_or(flag, (SEM_A>>3), or);
	if_print_or(flag, (SEM_R>>6), or);
	if_print_or(flag, (SEM_A>>6), or);

	if (flag & ~(IPC_CREAT|IPC_EXCL|SEM_R|SEM_A|((SEM_R|SEM_A)>>3)|
	    ((SEM_R|SEM_A)>>6)))
		printf("<invalid=%#x>", flag);
}


/*
 * Only used by SYS_open and SYS_openat. Unless O_CREAT is set in flags, the
 * mode argument is unused (and often bogus and misleading).
 */
static void
flagsandmodename(int mode)
{
	openflagsname(arg1);
	if ((arg1 & O_CREAT) == O_CREAT) {
		(void)putchar(',');
		modename(mode);
	} else if (!fancy)
		(void)printf(",<unused>%#o", mode);
}

static void
clockname(int clockid)
{
	clocktypename(__CLOCK_TYPE(clockid));
	if (__CLOCK_PTID(clockid) != 0)
		printf("(%d)", __CLOCK_PTID(clockid));
}

/*
 * [g|s]etsockopt's level argument can either be SOL_SOCKET or a value
 * referring to a line in /etc/protocols.
 */
static void
sockoptlevelname(int optname)
{
	struct protoent *pe;

	if (arg1 == SOL_SOCKET) {
		(void)printf("SOL_SOCKET,");
		sockoptname(optname);
	} else {
		pe = getprotobynumber(arg1);
		(void)printf("%u<%s>,%d", arg1,
		    pe != NULL ? pe->p_name : "unknown", optname);
	}
}

static void
ktraceopname(int ops)
{
	int invalid = 0;

	printf("%#x<", ops);
	switch (KTROP(ops)) {
	case KTROP_SET:
		printf("KTROP_SET");
		break;
	case KTROP_CLEAR:
		printf("KTROP_CLEAR");
		break;
	case KTROP_CLEARFILE:
		printf("KTROP_CLEARFILE");
		break;
	default:
		printf("KTROP(%d)", KTROP(ops));
		invalid = 1;
		break;
	}
	if (ops & KTRFLAG_DESCEND) printf("|KTRFLAG_DESCEND");
	printf(">");
	if (invalid || (ops & ~(KTROP((unsigned)-1) | KTRFLAG_DESCEND)))
		(void)printf("<invalid>%d", ops);
}
@


1.129
log
@Add 'p' trace point for KTRFAC_PLEDGE, as noted by
Michal Mazurek <akfaew@@jasminek.net>

While here, fix handling of -t+ in ltrace.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.128 2016/06/02 22:47:13 tedu Exp $	*/
d554 1
d638 1
d735 1
@


1.128
log
@allow printing timestamps relative to beginnging of trace, -RT. ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.127 2016/03/30 08:00:01 guenther Exp $	*/
d195 1
a195 1
			trpoints = getpoints(optarg);
d1387 1
a1387 1
	    "%*s[-t [cinstuxX+]]\n",
@


1.127
log
@Handle error return by SYS_getlogin_r and SYS___thrsleep correct, and
parse args of SYS_getlogin_r
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.126 2016/03/24 05:05:42 guenther Exp $	*/
d188 2
a189 2
		case 'R':
			timestamp = 2;	/* relative timestamp */
d192 1
a192 1
			timestamp = 1;
d352 5
a356 1
		if (timestamp == 2) {
@


1.126
log
@Display NAMI records and AF_UNIX socket paths with vis, using
VIS_CSTYLE | VIS_DQ | VIS_TAB | VIS_NL; add the latter three flags
to the existing vis encoding of exec argv/environ and pledge
requests/paths.
Delete local variables left unused when showbuf() and showbufc() were split

ok otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.125 2016/03/22 16:45:07 guenther Exp $	*/
d697 1
a697 1
    [SYS_getlogin]	= { Pptr, Pucount },
d1079 1
d1103 6
d1125 1
a1125 1
		(void)printf("-1 errno %d", ktr->ktr_error);
d1127 1
a1127 1
			(void)printf(" %s", strerror(ktr->ktr_error));
@


1.125
log
@Format the flags argument to sendsyslog()

ok deraadt@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.124 2016/03/21 00:04:03 guenther Exp $	*/
d1128 1
a1128 1
	(void)printf("\"%.*s\"\n", (int)len, cp);
d1132 1
a1132 1
showbufc(int col, unsigned char *dp, size_t datalen)
d1134 2
a1135 3
	int i, j;
	int width, bpl;
	unsigned char visbuf[5], *cp, c;
d1137 1
d1141 1
a1141 1
		(void)vis(visbuf, *dp, VIS_CSTYLE, *(dp+1));
d1181 2
a1182 2
	int col = 0, width, bpl;
	unsigned char visbuf[5], *cp, c;
d1228 1
a1228 1
	showbufc(7, dp, datalen);
a1322 1
	char buf[sizeof("[2147483648] = ")];
d1332 1
a1332 1
		showbufc(col, (unsigned char *)ptr, l);
@


1.124
log
@Handle kbind()'s third argument correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.123 2016/03/06 22:33:48 guenther Exp $	*/
d549 1
d632 1
d729 1
a729 1
    [SYS_sendsyslog]	= { Pptr, Psize },
@


1.123
log
@Improve display of unknown and KTR_START records

request and ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.122 2016/03/06 20:25:27 guenther Exp $	*/
d722 1
@


1.122
log
@No more compat emulations, so remove ktrace EMUL records and the baggage
for generating and parsing them.

ok mpi@@ naddy@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.121 2016/02/28 15:55:58 naddy Exp $	*/
d276 3
d337 5
@


1.121
log
@drop the support for Linux emulation; ok guenther@@ visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.120 2015/11/10 04:30:59 guenther Exp $	*/
a104 22
struct emulation {
	char *name;		/* Emulation name */
	char **sysnames;	/* Array of system call names */
	int  nsysnames;		/* Number of */
};

static struct emulation emulations[] = {
	{ "native",	syscallnames,		SYS_MAXSYSCALL },
	{ NULL,		NULL,			0 }
};

static struct emulation *current;
static struct emulation *def_emul;

struct pid_emul {
	struct emulation *e;	
	pid_t p;
};

static struct pid_emul *pe_table;
static size_t pe_size;

a113 2
static void mappidtoemul(pid_t, struct emulation *);
static struct emulation * findemul(pid_t);
a115 1
static void ktremul(char *, size_t);
a124 1
static void setemul(const char *);
a150 2
	def_emul = current = &emulations[0];	/* native */

d161 1
a161 1
	while ((ch = getopt(argc, argv, "e:f:dHlm:nRp:Tt:xX")) != -1)
a162 4
		case 'e':
			setemul(optarg);
			def_emul = current;
			break;
a224 2
		if (pe_size == 0)
			mappidtoemul(ktr_header.ktr_pid, current);
a246 1
		current = findemul(ktr_header.ktr_pid);
a262 4
		case KTR_EMUL:
			ktremul(m, ktrlen);
			mappidtoemul(ktr_header.ktr_pid, current);
			break;
a282 32
static void
mappidtoemul(pid_t pid, struct emulation *emul)
{
	size_t i;
	struct pid_emul *tmp;

	for (i = 0; i < pe_size; i++) {
		if (pe_table[i].p == pid) {
			pe_table[i].e = emul;
			return;
		}
	}
	tmp = reallocarray(pe_table, pe_size + 1, sizeof(*pe_table));
	if (tmp == NULL)
		err(1, NULL);
	pe_table = tmp;
	pe_table[pe_size].p = pid;
	pe_table[pe_size].e = emul;
	pe_size++;
}

static struct emulation*
findemul(pid_t pid)
{
	size_t i;

	for (i = 0; i < pe_size; i++)
		if (pe_table[i].p == pid)
			return pe_table[i].e;
	return def_emul;
}

a317 3
	case KTR_EMUL:
		type = "EMUL";
		break;
d334 1
a334 1
		(void)snprintf(unknown, sizeof unknown, "UNKNOWN(%d)",
d780 1
a780 1
    /* [SYS_sysctl]	= { }, Magic */
d850 1
a850 1
	if (ktr->ktr_code >= current->nsysnames || ktr->ktr_code < 0)
d853 1
a853 1
		(void)printf("%s", current->sysnames[ktr->ktr_code]);
d857 1
a857 4
	if (current != &emulations[0])
		goto nonnative;

	if (ktr->ktr_code == SYS_sysctl) {
a860 2
		if (!fancy)
			goto nonnative;
a905 1
nonnative:
d1063 1
a1063 1
	if (code >= current->nsysnames || code < 0)
d1065 2
a1066 9
	else {
		(void)printf("%s ", current->sysnames[code]);
		if (error == 0 && ret > 0 &&
		    (strcmp(current->sysnames[code], "fork") == 0 ||
		    strcmp(current->sysnames[code], "vfork") == 0 ||
		    strcmp(current->sysnames[code], "__tfork") == 0 ||
		    strcmp(current->sysnames[code], "clone") == 0))
			mappidtoemul(ret, current);
	}
d1070 1
a1070 1
			switch (current == &emulations[0] ? code : -1) {
a1090 1
			case -1:	/* non-default emulation */
a1119 15
static void
ktremul(char *cp, size_t len)
{
	char name[1024];

	if (len >= sizeof(name))
		errx(1, "Emulation name too long");

	strncpy(name, cp, len);
	name[len] = '\0';
	(void)printf("\"%s\"\n", name);

	setemul(name);
}

d1341 1
a1341 1
	if (pledge->syscall >= current->nsysnames || pledge->syscall < 0)
d1344 1
a1344 1
		(void)printf("%s", current->sysnames[pledge->syscall]);
d1365 2
a1366 2
	    "[-dHlnRTXx] [-e emulation] [-f file] [-m maxdata] [-p pid]\n"
	    "%*s[-t [ceinstuxX+]]\n",
a1370 12
static void
setemul(const char *name)
{
	int i;

	for (i = 0; emulations[i].name != NULL; i++)
		if (strcmp(emulations[i].name, name) == 0) {
			current = &emulations[i];
			return;
		}
	warnx("Emulation `%s' unknown", name);
}
@


1.120
log
@Split the intra-thread functionality from kill(2) into its own syscall
thrkill(2), rolling the kill(2) syscall number with the ABI change to
avoid breaking binaries during during the transition.  thrkill(2) includes
a 'tcb' argument that eliminates the need for locking in pthread_kill()
and simplifies pthread_cancel().  Switch __stack_smash_handler() to use
thrkill(2) and explicitly unblock SIGABRT.

Minor bump to both libc and libpthread: make sure you install a new kernel!

ok semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.119 2015/10/28 16:03:06 deraadt Exp $	*/
a86 2
#include <compat/linux/linux_syscall.h>

a95 2

#include <compat/linux/linux_syscalls.c>
a112 1
	{ "linux",	linux_syscallnames,	LINUX_SYS_MAXSYSCALL },
@


1.119
log
@remove knowledge of dnssocket/dnsconnect
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.118 2015/10/26 11:17:52 deraadt Exp $	*/
d825 1
@


1.118
log
@If the system call is entirely unpermitted, code will be 0, and there is
no pledge to recommend.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.117 2015/10/25 20:39:54 deraadt Exp $	*/
a810 1
    [SYS_dnssocket]	= { Sockfamilyname, Socktypename, Sockprotoname },
a811 1
    [SYS_dnsconnect]	= { Pfd, Pptr, Pucount },
@


1.117
log
@Fold "malloc" into "stdio" and -- recognizing that no program so far has
used less than "stdio" -- include all the "self" operations.  Instead of
different defines, use regular PLEDGE_* in the "p_pledgenote" variable
(which indicates the operation subtype a system call is performing).  Many
checks before easier to understand.  p_pledgenote can often be passed
directly to ktrace, so that kdump says:
 15565 test     CALL  pledge(0xa9a3f804c51,0)
 15565 test     STRU  pledge request="stdio"
 15565 test     RET   pledge 0
 15565 test     CALL  open(0xa9a3f804c57,0x2<O_RDWR>)
 15565 test     NAMI  "/tmp/testfile"
 15565 test     PLDG  open, "wpath", errno 1 Operation not permitted
with help from semarie, ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.116 2015/10/18 01:32:05 deraadt Exp $	*/
d1444 1
d1455 1
a1455 1
	for (i = 0; pledgenames[i].bits != 0; i++) {
d1457 1
a1457 1
			printf("\"%s\"", pledgenames[i].name);
d1461 1
@


1.116
log
@Describe dnssocket / dnsconnect arguments
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.115 2015/10/10 20:35:00 deraadt Exp $	*/
d49 3
d154 1
d317 3
d409 3
d1439 25
@


1.115
log
@normalize a few more tame request orderings, to help review
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.114 2015/10/10 19:19:46 deraadt Exp $	*/
d801 1
d803 1
@


1.114
log
@since kdump may getprotobynumber() late, do not drop "rpath".  We could
potentially modify pledge() to permit /etc/protocols (/etc/rpc?
/etc/services? etc) without requiring a rpath attribute.. but where would
we draw the line for what /etc files libc functions need?  At present, we
draw that line closer to the minimum.
issue found by theo@@math.ethz.ch
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.113 2015/10/09 01:37:08 deraadt Exp $	*/
d244 1
a244 1
	if (pledge("stdio getpw rpath", NULL) == -1)
@


1.113
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.112 2015/10/06 03:27:25 deraadt Exp $	*/
a251 3

	if (pledge("stdio getpw", NULL) == -1)
		err(1, "pledge");
@


1.112
log
@tame "stdio getpw"
discussed with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.111 2015/10/03 23:52:30 guenther Exp $	*/
d244 2
a245 2
	if (tame("stdio getpw rpath", NULL) == -1)
		err(1, "tame");
d253 2
a254 2
	if (tame("stdio getpw", NULL) == -1)
		err(1, "tame");
@


1.111
log
@Add ktracing of tame()'s arguments' values

"every tool helps" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.110 2015/10/03 21:47:40 guenther Exp $	*/
d252 4
@


1.110
log
@option LFS is dead, but we missed option ACCOUNTING here
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.109 2015/10/03 09:12:39 zhuk Exp $	*/
d75 1
a75 1
int needtid, tail;
d407 1
a407 1
	(void)printf("%6ld", (long)kth->ktr_pid);
d409 2
a410 2
		(void)printf("/%-7ld", (long)kth->ktr_tid);
	(void)printf(" %-8.*s ", MAXCOMLEN, kth->ktr_comm);
d417 1
a417 1
		printf("%lld.%06ld ", (long long)temp.tv_sec,
d420 1
a420 1
	(void)printf("%s  ", type);
d1216 2
a1217 2
static void
showbufc(const char *prefix, unsigned char *dp, size_t datalen)
d1220 1
a1220 1
	int col, width, bpl;
a1222 8
	(void)printf("       ");

	col = 8;
	if (prefix != NULL) {
		printf("%s", prefix);
		col += strlen(prefix);
	}

d1224 1
d1311 3
a1313 1
	showbufc(NULL, dp, datalen);
d1409 1
a1409 1
	int i;
d1416 3
a1418 2
		snprintf(buf, sizeof(buf), "[%d] = ", i++);
		showbufc(buf, (unsigned char *)ptr, l);
@


1.109
log
@Fix wrong cast.

This one should be an unsigned long in theory, but the formatter function
argument we're printing from is already an int (being casted from register_t
at the formatter call time). So lets fix one bug at a time.

authoritative okay from guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.108 2015/10/03 05:15:36 deraadt Exp $	*/
d93 1
a93 1
#define LFS
d104 1
a104 1
#undef LFS
@


1.108
log
@tame "stdio getpw rpath" can be done quite early after the getopt.
it might seem we can hoist the open above tame and then drop "rpath",
but guenther found getprotobynumber can be called much later.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.107 2015/10/02 19:12:45 jmc Exp $	*/
d1478 1
a1478 1
	printf("_IO%s('%c',%lu",
@


1.107
log
@update the -t args list; ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.106 2015/10/02 05:07:41 guenther Exp $	*/
d243 3
@


1.106
log
@Add ktracing of argv and envp to execve(2), with envp not traced by default

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.105 2015/09/13 17:08:03 guenther Exp $	*/
d1436 1
a1436 1
	    "%*s[-t [ceinstuw]]\n",
@


1.105
log
@Rename __sysctl syscall to just sysctl, as the userland wrapper is no longer
necessary

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.104 2015/09/07 15:38:45 guenther Exp $	*/
d150 1
d305 4
d392 6
d1214 53
d1315 1
a1315 37
	(void)printf("       \"");
	col = 8;
	for (; datalen > 0; datalen--, dp++) {
		(void)vis(visbuf, *dp, VIS_CSTYLE, *(dp+1));
		cp = visbuf;

		/*
		 * Keep track of printables and
		 * space chars (like fold(1)).
		 */
		if (col == 0) {
			(void)putchar('\t');
			col = 8;
		}
		switch (*cp) {
		case '\n':
			col = 0;
			(void)putchar('\n');
			continue;
		case '\t':
			width = 8 - (col&07);
			break;
		default:
			width = strlen(cp);
		}
		if (col + width > (screenwidth-2)) {
			(void)printf("\\\n\t");
			col = 8;
		}
		col += width;
		do {
			(void)putchar(*cp++);
		} while (*cp);
	}
	if (col == 0)
		(void)printf("       ");
	(void)printf("\"\n");
d1405 22
@


1.104
log
@Delete ktracing of context switches: it's unused, and not particularly useful,
and doing VOP_WRITE() from inside tsleep/msleep makes the locking too
complicated, making it harder to move forward on MP changes.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.103 2015/07/19 04:45:25 guenther Exp $	*/
d833 1
a833 1
    /* [SYS___sysctl]	= { }, Magic */
d913 1
a913 1
	if (ktr->ktr_code == SYS___sysctl) {
@


1.103
log
@Make KTR_SYSRET records variables variables sized, leaving out the
retval on error, including a long long retval on successful lseek(),
and including a register_t retval for other successes.  This fixes
lseek reporting on ILP32 archs.

While here, reworking internal kern_ktrace.c bits to be able to pass
two buffers to ktrwriteraw(), so we can avoid mallocing a buffer
in some cases and so that KTR_GENIO logs are split at PAGE_SIZE,
not PAGE_SIZE-sizeof(struct ktrgenio)

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.102 2015/07/19 02:52:35 deraadt Exp $	*/
a141 1
static void ktrcsw(struct ktr_csw *);
a293 3
		case KTR_CSW:
			ktrcsw((struct ktr_csw *)m);
			break;
a377 3
	case KTR_CSW:
		type = "CSW";
		break;
a1365 7
}

static void
ktrcsw(struct ktr_csw *cs)
{
	(void)printf("%s %s\n", cs->out ? "stop" : "resume",
	    cs->user ? "user" : "kernel");
@


1.102
log
@Figure out the tty width using TIOCGWINSZ early on.  Will make tame(2)
integration easier in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.101 2015/04/18 18:28:37 deraadt Exp $	*/
d149 1
a149 1
static void ktrsysret(struct ktr_sysret *);
d284 1
a284 1
			ktrsysret((struct ktr_sysret *)m);
d1108 1
a1108 1
ktrsysret(struct ktr_sysret *ktr)
d1110 2
a1111 1
	register_t ret = ktr->ktr_retval;
d1115 14
d1133 2
a1134 1
		if (ret > 0 && (strcmp(current->sysnames[code], "fork") == 0 ||
d1144 5
d1172 1
a1172 1
				(void)printf("%ld", (long)ret);
d1174 1
a1174 1
				(void)printf("%#lx", (long)ret);
@


1.101
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.100 2015/04/17 06:33:30 guenther Exp $	*/
d167 2
d180 10
a1191 1
	static int screenwidth;
a1194 9
	if (screenwidth == 0) {
		struct winsize ws;

		if (fancy && ioctl(fileno(stderr), TIOCGWINSZ, &ws) != -1 &&
		    ws.ws_col > 8)
			screenwidth = ws.ws_col;
		else
			screenwidth = 80;
	}
@


1.100
log
@oops, started expecting sockoptlevelname() to handle two arguments
but never actually did so.  Fix that so that we stop losing the
second argument to {get,set}sockopt().  Handling of levels other than
SOL_SOCKET could be improved.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.99 2015/04/17 06:14:36 guenther Exp $	*/
d173 1
d197 3
a199 1
			maxdata = atoi(optarg);
d205 3
a207 1
			pid_opt = atoi(optarg);
@


1.99
log
@The first argument to socket/socketpair is an address family, not a protocol
family.  (sysctl(3) is practically the only place where PF_* is correct)
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.98 2015/01/26 04:38:23 guenther Exp $	*/
d59 1
d1636 1
a1636 2
 * referring to a line in /etc/protocols . It might be appropriate
 * to use getprotoent(3) here.
d1639 1
a1639 1
sockoptlevelname(int level)
d1641 10
a1650 4
	if (level == SOL_SOCKET)
		(void)printf("SOL_SOCKET");
	else
		pdecint(level);
@


1.98
log
@Oops: symlinkat()'s 'atfd' argument is its second, not its first
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.97 2015/01/16 06:40:09 deraadt Exp $	*/
a552 1
	sockdomainname,
a634 1
	Sockdomainname,
d774 1
a774 1
    [SYS_socket]	= { Sockdomainname, Socktypename, Sockprotoname },
d800 1
a800 1
    [SYS_socketpair]	= { Sockdomainname, Socktypename, Sockprotoname, Pptr },
@


1.97
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.96 2014/12/28 11:11:01 bluhm Exp $	*/
d874 1
a874 1
    [SYS_symlinkat]	= { Atfd, Ppath, Ppath },
@


1.96
log
@With revision 1.93 a space character got lost when printing the
signal action.  Print the space again.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.95 2014/12/15 07:01:12 jmc Exp $	*/
d32 1
a32 1
#include <sys/param.h>
d34 1
@


1.95
log
@remove -r from usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.94 2014/12/15 01:48:54 guenther Exp $	*/
d1295 1
@


1.94
log
@Eliminate the -r option and always do sysctl OID, username, groupname,
and ctime presentation, but combined with the numeric form ala 0<"root">.
Do username and groupname presentation on syscall arguments and retvals.

ok millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.93 2014/12/09 00:46:43 jsg Exp $	*/
d1370 1
a1370 1
	    "[-dHlnRrTXx] [-e emulation] [-f file] [-m maxdata] [-p pid]\n"
@


1.93
log
@Add some additional sanity checks to kdump.
Fixes a variety of crashes found with the afl fuzzer.
ok miod@@ on an earlier version.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.92 2014/12/08 21:23:44 guenther Exp $	*/
d73 1
a73 1
int needtid, resolv, tail;
d146 1
a146 1
static const char *kresolvsysctl(int, int *, int);
d175 1
a175 1
	while ((ch = getopt(argc, argv, "e:f:dHlm:nrRp:Tt:xX")) != -1)
a201 3
		case 'r':
			resolv = 1;
			break;
d582 2
d665 2
a683 2
#define Puid_t		Pdecuint
#define Pgid_t		Pdecuint
d706 1
a706 1
    [SYS_chown]		= { Ppath, Puid_t, Pgid_t },
d711 1
a711 1
    [SYS_setuid]	= { Puid_t },
d792 1
a792 1
    [SYS_fchown]	= { Pfd, Puid_t, Pgid_t },
d794 2
a795 2
    [SYS_setreuid]	= { Puid_t, Puid_t },
    [SYS_setregid]	= { Pgid_t, Pgid_t },
d805 1
a805 1
    [SYS_quotactl]	= { Ppath, Quotactlname, Puid_t, Pptr },
d811 3
a813 3
    [SYS_setgid]	= { Pgid_t },
    [SYS_setegid]	= { Pgid_t },
    [SYS_seteuid]	= { Puid_t },
d836 1
a836 1
    [SYS_lchown]	= { Ppath, Puid_t, Pgid_t },
d845 1
a845 1
    [SYS_setresuid]	= { Puid_t, Puid_t, Puid_t },
d847 1
a847 1
    [SYS_setresgid]	= { Pgid_t, Pgid_t, Pgid_t },
d865 1
a865 1
    [SYS_fchownat]	= { Atfd, Ppath, Puid_t, Pgid_t, Atflagsname },
d905 1
a905 1
		int *np, n, i, *top;
d914 15
a928 9
		np = top = (int *)(ap + 6);
		for (i = 0; n--; np++, i++) {
			if (sep)
				putchar(sep);
			if (resolv && (s = kresolvsysctl(i, top, *np)) != NULL)
				printf("%s", s);
			else
				printf("%d", *np);
			sep = '.';
d1007 1
a1007 1
kresolvsysctl(int depth, int *top, int idx)
d1011 1
d1117 8
@


1.92
log
@Convert syscall argument handling from a giant switch to a giant table.
While at it, use formatters for fds, counts, ids of all types, and "small
buffer sizes" that always show them in decimal, while paths, pointers, and
"big buffer sizes" get formatters that always show them in hex.  The -d
option only affects args when the -n option is used or for unknown syscalls,
as well as syscall return values, and unrecognized ioctls.

ok otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.91 2014/10/13 03:46:33 guenther Exp $	*/
d145 1
a145 1
static void ktrsyscall(struct ktr_syscall *);
d265 1
a265 1
			ktrsyscall((struct ktr_syscall *)m);
d881 1
a881 1
ktrsyscall(struct ktr_syscall *ktr)
d887 4
d913 2
d950 1
a950 1
	while (narg) {
d1259 6
a1264 1
	size_t datalen = len - sizeof(struct ktr_genio);
d1280 1
a1280 1
	(void)printf("SIG%s ", sys_signame[psig->signo]);
d1342 2
@


1.91
log
@Add dumping of struct dqblk done by quotactl(2)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.90 2014/10/08 04:02:46 doug Exp $	*/
a135 4
static int narg;
static register_t *ap;
static char sep;

d151 2
a154 1
static void pgid(int);
d160 1
a160 1
static void flagsandmodename(int, int);
d400 32
a431 2
static void
ioctldecode(u_long cmd)
d433 3
a435 1
	char dirbuf[4], *dir = dirbuf;
d437 6
a442 5
	if (cmd & IOC_IN)
		*dir++ = 'W';
	if (cmd & IOC_OUT)
		*dir++ = 'R';
	*dir = '\0';
d444 5
a448 4
	printf(decimal ? ",_IO%s('%c',%lu" : ",_IO%s('%c',%#lx",
	    dirbuf, (int)((cmd >> 8) & 0xff), cmd & 0xff);
	if ((cmd & IOC_VOID) == 0)
		printf(decimal ? ",%lu)" : ",%#lx)", (cmd >> 16) & 0xff);
d450 2
a451 1
		printf(")");
d455 1
a455 1
ptracedecode(void)
d457 1
a457 47
	if (*ap >= 0 && *ap <
	    sizeof(ptrace_ops) / sizeof(ptrace_ops[0]))
		(void)printf("%s", ptrace_ops[*ap]);
	else switch(*ap) {
#ifdef PT_GETFPREGS
	case PT_GETFPREGS:
		(void)printf("PT_GETFPREGS");
		break;
#endif
	case PT_GETREGS:
		(void)printf("PT_GETREGS");
		break;
#ifdef PT_GETXMMREGS
	case PT_GETXMMREGS:
		(void)printf("PT_GETXMMREGS");
		break;
#endif
#ifdef PT_SETFPREGS
	case PT_SETFPREGS:
		(void)printf("PT_SETFPREGS");
		break;
#endif
	case PT_SETREGS:
		(void)printf("PT_SETREGS");
		break;
#ifdef PT_SETXMMREGS
	case PT_SETXMMREGS:
		(void)printf("PT_SETXMMREGS");
		break;
#endif
#ifdef PT_STEP
	case PT_STEP:
		(void)printf("PT_STEP");
		break;
#endif
#ifdef PT_WCOOKIE
	case PT_WCOOKIE:
		(void)printf("PT_WCOOKIE");
		break;
#endif
	default:
		(void)printf("%ld", (long)*ap);
		break;
	}
	sep = ',';
	ap++;
	narg--;
d461 1
a461 1
pn(void (*f)(int))
d463 1
a463 11
	if (sep)
		(void)putchar(sep);
	if (fancy && f != NULL)
		f((int)*ap);
	else if (decimal)
		(void)printf("%ld", (long)*ap);
	else
		(void)printf("%#lx", (long)*ap);
	ap++;
	narg--;
	sep = ',';
a465 3
#ifdef __LP64__
#define plln()	pn(NULL)
#elif _BYTE_ORDER == _LITTLE_ENDIAN
d467 1
a467 1
plln(void)
d469 1
a469 12
	long long val = ((long long)*ap) & 0xffffffff;
	ap++;
	val |= ((long long)*ap) << 32;
	ap++;
	narg -= 2;
	if (sep)
		(void)putchar(sep);
	if (decimal)
		(void)printf("%lld", val);
	else
		(void)printf("%#llx", val);
	sep = ',';
d471 1
a471 1
#else
d473 19
a491 1
plln(void)
d493 11
a503 8
	long long val = ((long long)*ap) << 32;
	ap++;
	val |= ((long long)*ap) & 0xffffffff;
	ap++;
	narg -= 2;
	if (sep)
		(void)putchar(sep);
	if (decimal)
d505 1
a505 3
	else
		(void)printf("%#llx", val);
	sep = ',';
d507 372
a878 1
#endif
d883 4
d900 1
a900 16
	switch (ktr->ktr_code) {
	case SYS_ioctl: {
		const char *cp;

		pn(NULL);
		if (!fancy)
			break;
		if ((cp = ioctlname(*ap)) != NULL)
			(void)printf(",%s", cp);
		else
			ioctldecode(*ap);
		ap++;
		narg--;
		break;
	}
	case SYS___sysctl: {
d905 1
a905 1
			break;
d923 3
a925 120
		break;
	}
	case SYS_ptrace: 
		if (!fancy)
			break;
		ptracedecode();
		break;
	case SYS_accept4:
		pn(NULL);
		pn(NULL);
		pn(NULL);
		pn(sockflagsname);
		break;
	case SYS_access:
		pn(NULL);
		pn(accessmodename);
		break;
	case SYS_chmod:
	case SYS_fchmod: 
	case SYS_mkdir:
	case SYS_mkfifo:
	case SYS_mknod:
		pn(NULL);
		pn(modename);
		break;
	case SYS_umask:
		pn(modename);
		break;
	case SYS_dup3:
		pn(NULL);
		pn(NULL);
		pn(flagsname);
		break;
	case SYS_fcntl: {
		int cmd;
		int arg;
		pn(NULL);
		if (!fancy)
			break;
		cmd = ap[0];
		arg = ap[1];
		(void)putchar(',');
		fcntlcmdname(cmd, arg);
		ap += 2;
		narg -= 2;
		break;
	}
	case SYS_flock:
		pn(NULL);
		pn(flockname);
		break;
	case SYS_getrlimit:
	case SYS_setrlimit:
		pn(rlimitname);
		break;
	case SYS_getsockopt:
	case SYS_setsockopt: {
		int level;

		pn(NULL);
		level = *ap;
		pn(sockoptlevelname);
		if (level == SOL_SOCKET)
			pn(sockoptname);
		break;
	}
	case SYS_kill:
		pn(pgid);
		pn(signame);
		break;
	case SYS_lseek:
		pn(NULL);
		/* skip padding */
		ap++;
		narg--;
		plln();
		pn(whencename);
		break;
	case SYS_madvise:
		pn(NULL);
		pn(NULL);
		pn(madvisebehavname);
		break;
	case SYS_minherit:
		pn(NULL);
		pn(NULL);
		pn(minheritname);
		break;
	case SYS_mlockall:
		pn(mlockallname);
		break;
	case SYS_mmap:
	case SYS_mquery:
		pn(NULL);
		pn(NULL);
		pn(mmapprotname);
		pn(mmapflagsname);
		pn(NULL);
		/* skip padding */
		ap++;
		narg--;
		plln();
		break;
	case SYS_mprotect:
		pn(NULL);
		pn(NULL);
		pn(mmapprotname);
		break;
	case SYS_msync:
		pn(NULL);
		pn(NULL);
		pn(msyncflagsname);
		break;
	case SYS_msgctl:
		pn(NULL);
		pn(shmctlname);
		break;
	case SYS_open: {
		int     flags;
		int     mode;
d927 14
a940 216
		pn(NULL);
		if (!fancy)
			break;
		flags = ap[0];
		mode = ap[1];
		(void)putchar(',');
		flagsandmodename(flags, mode);
		ap += 2;
		narg -= 2;
		break;
	}
	case SYS_pipe2:
		pn(NULL);
		pn(flagsname);
		break;
	case SYS_pread:
	case SYS_preadv:
	case SYS_pwrite:
	case SYS_pwritev:
		pn(NULL);
		pn(NULL);
		pn(NULL);
		/* skip padding */
		ap++;
		narg--;
		plln();
		break;
	case SYS_recvmsg:
	case SYS_sendmsg:
		pn(NULL);
		pn(NULL);
		pn(sendrecvflagsname);
		break;
	case SYS_recvfrom:
	case SYS_sendto:
		pn(NULL);
		pn(NULL);
		pn(NULL);
		pn(sendrecvflagsname);
		break;
	case SYS_shutdown:
		pn(NULL);
		pn(shutdownhowname);
		break;
	case SYS___semctl:
		pn(NULL);
		pn(NULL);
		pn(semctlname);
		break;
	case SYS_semget:
		pn(NULL);
		pn(NULL);
		pn(semgetname);
		break;
	case SYS_shmat:
		pn(NULL);
		pn(NULL);
		pn(shmatname);
		break;
	case SYS_shmctl:
		pn(NULL);
		pn(shmctlname);
		break;
	case SYS_clock_gettime:
	case SYS_clock_settime:
	case SYS_clock_getres:
		pn(clockname);
		break;
	case SYS_poll:
		pn(NULL);
		pn(NULL);
		pn(polltimeout);
		break;
	case SYS_sigaction:
		pn(signame);
		break;
	case SYS_sigprocmask:
		pn(sigprocmaskhowname);
		pn(sigset);
		break;
	case SYS_sigsuspend:
		pn(sigset);
		break;
	case SYS_socket: {
		int sockdomain = *ap;

		pn(sockdomainname);
		pn(socktypename);
		if (sockdomain == PF_INET || sockdomain == PF_INET6)
			pn(sockipprotoname);
		break;
	}
	case SYS_socketpair:
		pn(sockdomainname);
		pn(socktypename);
		break;
	case SYS_truncate:
	case SYS_ftruncate:
		pn(NULL);
		/* skip padding */
		ap++;
		narg--;
		plln();
		break;
	case SYS_wait4:
		pn(wait4pid);
		pn(NULL);
		pn(wait4optname);
		break;
	case SYS_getrusage:
		pn(rusagewho);
		break;
	case SYS___thrsleep:
		pn(NULL);
		pn(clockname);
		break;
	case SYS___thrsigdivert:
		pn(sigset);
		break;
	case SYS_faccessat:
		pn(atfd);
		pn(NULL);
		pn(accessmodename);
		pn(atflagsname);
		break;
	case SYS_fchmodat:
		pn(atfd);
		pn(NULL);
		pn(modename);
		pn(atflagsname);
		break;
	case SYS_fchownat:
		pn(atfd);
		pn(NULL);
		pn(NULL);
		pn(NULL);
		pn(atflagsname);
		break;
	case SYS_fstatat:
		pn(atfd);
		pn(NULL);
		pn(NULL);
		pn(atflagsname);
		break;
	case SYS_linkat:
		pn(atfd);
		pn(NULL);
		pn(atfd);
		pn(NULL);
		pn(atflagsname);
		break;
	case SYS_mkdirat:
	case SYS_mkfifoat:
	case SYS_mknodat:
		pn(atfd);
		pn(NULL);
		pn(modename);
		break;
	case SYS_openat: {
		int     flags;
		int     mode;

		pn(atfd);
		pn(NULL);
		if (!fancy)
			break;
		flags = ap[0];
		mode = ap[1];
		(void)putchar(',');
		flagsandmodename(flags, mode);
		ap += 2;
		narg -= 2;
		break;
	}
	case SYS_readlinkat:
		pn(atfd);
		break;
	case SYS_renameat:
		pn(atfd);
		pn(NULL);
		pn(atfd);
		break;
	case SYS_symlinkat:
		pn(NULL);
		pn(atfd);
		break;
	case SYS_unlinkat:
		pn(atfd);
		pn(NULL);
		pn(atflagsname);
		break;
	case SYS_utimensat:
		pn(atfd);
		pn(NULL);
		pn(NULL);
		pn(atflagsname);
		break;
	case SYS_pathconf:
	case SYS_fpathconf: 
		pn(NULL);
		pn(pathconfname);
		break;
	case SYS_ktrace:
		pn(NULL);
		pn(ktraceopname);
		pn(ktracefacname);
		pn(pgid);
		break;
	case SYS_setitimer:
	case SYS_getitimer:
		pn(itimername);
		break;
	case SYS_quotactl:
		pn(NULL);
		pn(quotactlcmdname);
		break;
d1362 77
a1443 2
	else if (decimal)
		(void)printf("%d", fd);
d1445 1
a1445 1
		(void)printf("%#x", fd);
a1452 2
	else if (decimal)
		(void)printf("%d", timeout);
d1454 1
a1454 7
		(void)printf("%#x", timeout);
}

static void
pgid(int pid)
{
	(void)printf("%d", pid);
d1465 1
a1465 1
		pgid(pid);
d1541 1
a1541 1
		(void)printf("<invalid=%ld>", (long)cmd);
d1559 1
a1559 1
		(void)printf("<invalid=%ld>", (long)cmd);
d1576 4
d1584 1
a1584 1
 * Only used by SYS_open. Unless O_CREAT is set in flags, the
d1588 1
a1588 1
flagsandmodename(int flags, int mode)
d1590 2
a1591 5
	doflagsname(flags, 1);
	if ((flags & O_CREAT) == O_CREAT) {
		(void)putchar(',');
		modename (mode);
	} else if (!fancy) {
d1593 3
a1595 6
		if (decimal) {
			(void)printf("<unused>%ld", (long)mode);
		} else {
			(void)printf("<unused>%#lx", (long)mode);
		}
	}
d1614 1
a1614 1
	if (level == SOL_SOCKET) {
d1616 2
a1617 7
	} else {
		if (decimal) {
			(void)printf("%ld", (long)level);
		} else {
			(void)printf("%#lx", (long)level);
		}
	}
d1641 1
a1641 1
	if (ops & KTRFLAG_DESCEND) printf ("|%s", "KTRFLAG_DESCEND");
d1644 1
a1644 1
		(void)printf("<invalid>%ld", (long)ops);
@


1.90
log
@userland reallocarray audit.

Replace malloc() and realloc() calls that may have integer overflow in the
multiplication of the arguments with reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.89 2014/09/17 19:12:55 guenther Exp $	*/
d914 4
@


1.89
log
@Add display of the flags to pipe2, dup3, and accept4, display of
MSG_CMSG_CLOEXEC in recvmsg, and display of SOCK_{CLOEXEC,NONBLOCK}
in socket and socketpair.
Do _not_ display the O_ACCMODE bits in the arg to fcntl(F_SETFD)

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.88 2014/08/18 03:29:53 guenther Exp $	*/
d314 1
a314 1
	tmp = realloc(pe_table, (pe_size + 1) * sizeof(*pe_table));
@


1.88
log
@Add fancy printing of ktrace()'s ops argument
mquery() has the exact same argument layout as mmap(), so share the case
Fix a couple brace placement glitches
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.87 2014/08/17 22:25:53 guenther Exp $	*/
d589 6
d610 5
d714 4
d1493 1
a1493 1
	flagsname (flags);
@


1.87
log
@Display symbolicly the mode argument of mkdir, mkfifo, mknod, and umask
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.86 2013/12/21 07:32:35 guenther Exp $	*/
d166 1
d663 1
a678 11
	case SYS_mquery:
		pn(NULL);
		pn(NULL);
		pn(mmapprotname);
		pn(mmapflagsname);
		pn(NULL);
		/* skip padding */
		ap++;
		narg--;
		plln();
		break;
d892 1
a892 1
		pn(NULL);
d927 1
a927 2
static struct ctlname kernprocname[] =
{
d1438 2
a1439 1
shmctlname(int cmd) {
d1457 2
a1458 1
semgetname(int flag) {
d1476 2
a1477 1
flagsandmodename(int flags, int mode) {
d1519 26
@


1.86
log
@Recognize itimer and ktrace facility names to {get,set}itimer() and ktrace()

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.85 2013/09/09 05:08:26 guenther Exp $	*/
d594 3
d598 3
@


1.85
log
@Rename the 'pid' global to eliminate compiler warnings about shadowing

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.84 2013/08/22 02:02:33 guenther Exp $	*/
d892 10
@


1.84
log
@Split out from kdump.c the ktrstruct.c bits into ktrstruct.c
Reduce the #includes to take advantage of that.

ok millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.83 2013/07/03 23:04:33 guenther Exp $	*/
d76 1
a76 1
pid_t pid = -1;
d202 1
a202 1
			pid = atoi(optarg);
d242 1
a242 1
		if (pid != -1 && pid != ktr_header.ktr_pid)
@


1.83
log
@For consistency, move the functions that aren't generated at build-time
from mksubr to kdump.c

ok otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.82 2013/07/03 06:41:51 guenther Exp $	*/
a39 1
#include <sys/resource.h>
a44 1
#include <sys/un.h>
a45 1
#include <sys/stat.h>
a47 2
#include <netinet/in.h>
#include <arpa/inet.h>
d49 1
a49 1
#include <sys/errno.h>
a63 2
#include <grp.h>
#include <pwd.h>
a77 1
#define TIME_FORMAT	"%b %e %T %Y"
a151 1
static void ktrstruct(char *, size_t);
a159 1
static void sigset(int);
a1281 323
ktrsockaddr(struct sockaddr *sa)
{
/*
 TODO: Support additional address families
	#include <netnatm/natm.h>
	struct sockaddr_natm	*natm;
	#include <netsmb/netbios.h>
	struct sockaddr_nb	*nb;
*/
	char addr[64];

	/*
	 * note: ktrstruct() has already verified that sa points to a
	 * buffer at least sizeof(struct sockaddr) bytes long and exactly
	 * sa->sa_len bytes long.
	 */
	printf("struct sockaddr { ");
	sockfamilyname(sa->sa_family);
	printf(", ");

#define check_sockaddr_len(n)					\
	if (sa_##n->s##n##_len < sizeof(struct sockaddr_##n)) {	\
		printf("invalid");				\
		break;						\
	}

	switch(sa->sa_family) {
	case AF_INET: {
		struct sockaddr_in	*sa_in;

		sa_in = (struct sockaddr_in *)sa;
		check_sockaddr_len(in);
		inet_ntop(AF_INET, &sa_in->sin_addr, addr, sizeof addr);
		printf("%s:%u", addr, ntohs(sa_in->sin_port));
		break;
	}
	case AF_INET6: {
		struct sockaddr_in6	*sa_in6;

		sa_in6 = (struct sockaddr_in6 *)sa;
		check_sockaddr_len(in6);
		inet_ntop(AF_INET6, &sa_in6->sin6_addr, addr, sizeof addr);
		printf("[%s]:%u", addr, htons(sa_in6->sin6_port));
		break;
	}
#ifdef IPX
	case AF_IPX: {
		struct sockaddr_ipx	*sa_ipx;

		sa_ipx = (struct sockaddr_ipx *)sa;
		check_sockaddr_len(ipx);
		/* XXX wish we had ipx_ntop */
		printf("%s", ipx_ntoa(sa_ipx->sipx_addr));
		break;
	}
#endif
	case AF_UNIX: {
		struct sockaddr_un *sa_un;

		sa_un = (struct sockaddr_un *)sa;
		if (sa_un->sun_len <= sizeof(sa_un->sun_len) +
		    sizeof(sa_un->sun_family)) {
			printf("invalid");
			break;
		}
		printf("\"%.*s\"", (int)(sa_un->sun_len -
		    sizeof(sa_un->sun_len) - sizeof(sa_un->sun_family)),
		    sa_un->sun_path);
		break;
	}
	default:
		printf("unknown address family");
	}
	printf(" }\n");
}

static void
print_time(time_t t, int relative)
{
	char timestr[PATH_MAX + 4];
	struct tm *tm;

	if (resolv == 0 || relative)
		printf("%jd", (intmax_t)t);
	else {
		tm = localtime(&t);
		(void)strftime(timestr, sizeof(timestr), TIME_FORMAT, tm);
		printf("\"%s\"", timestr);
	}
}

static void
print_timespec(const struct timespec *tsp, int relative)
{
	print_time(tsp->tv_sec, relative);
	if (tsp->tv_nsec != 0)
		printf(".%09ld", tsp->tv_nsec);
}

static void
ktrstat(const struct stat *statp)
{
	char mode[12];
	struct passwd *pwd;
	struct group  *grp;

	/*
	 * note: ktrstruct() has already verified that statp points to a
	 * buffer exactly sizeof(struct stat) bytes long.
	 */
	printf("struct stat { ");
	strmode(statp->st_mode, mode);
	printf("dev=%d, ino=%llu, mode=%s, nlink=%u, ",
	    statp->st_dev, (unsigned long long)statp->st_ino,
	    mode, statp->st_nlink);
	if (resolv == 0 || (pwd = getpwuid(statp->st_uid)) == NULL)
		printf("uid=%u, ", statp->st_uid);
	else
		printf("uid=\"%s\", ", pwd->pw_name);
	if (resolv == 0 || (grp = getgrgid(statp->st_gid)) == NULL)
		printf("gid=%u, ", statp->st_gid);
	else
		printf("gid=\"%s\", ", grp->gr_name);
	printf("rdev=%d, ", statp->st_rdev);
	printf("atime=");
	print_timespec(&statp->st_atim, 0);
	printf(", mtime=");
	print_timespec(&statp->st_mtim, 0);
	printf(", ctime=");
	print_timespec(&statp->st_ctim, 0);
	printf(", size=%lld, blocks=%lld, blksize=%u, flags=0x%x, gen=0x%x",
	    statp->st_size, statp->st_blocks, statp->st_blksize,
	    statp->st_flags, statp->st_gen);
	printf(" }\n");
}

static void
ktrtimespec(const struct timespec *tsp, int relative)
{
	printf("struct timespec { ");
	print_timespec(tsp, relative);
	printf(" }\n");
}

static void
ktrtimeval(const struct timeval *tvp, int relative)
{
	printf("struct timeval { ");
	print_time(tvp->tv_sec, relative);
	if (tvp->tv_usec != 0)
		printf(".%06ld", tvp->tv_usec);
	printf(" }\n");
}

static void
ktrsigaction(const struct sigaction *sa)
{
	/*
	 * note: ktrstruct() has already verified that sa points to a
	 * buffer exactly sizeof(struct sigaction) bytes long.
	 */
	printf("struct sigaction { ");
	if (sa->sa_handler == SIG_DFL)
		printf("handler=SIG_DFL");
	else if (sa->sa_handler == SIG_IGN)
		printf("handler=SIG_IGN");
	else if (sa->sa_flags & SA_SIGINFO)
		printf("sigaction=%p", (void *)sa->sa_sigaction);
	else
		printf("handler=%p", (void *)sa->sa_handler);
	printf(", mask=");
	sigset(sa->sa_mask);
	printf(", flags=");
	sigactionflagname(sa->sa_flags);
	printf(" }\n");
}

static void
print_rlim(rlim_t lim)
{
	if (lim == RLIM_INFINITY)
		printf("infinite");
	else
		printf("%llu", (unsigned long long)lim);
}

static void
ktrrlimit(const struct rlimit *limp)
{
	printf("struct rlimit { ");
	printf("cur=");
	print_rlim(limp->rlim_cur);
	printf(", max=");
	print_rlim(limp->rlim_max);
	printf(" }\n");
}

static void
ktrtfork(const struct __tfork *tf)
{
	printf("struct __tfork { tcb=%p, tid=%p, stack=%p }\n",
	    tf->tf_tcb, (void *)tf->tf_tid, tf->tf_stack);
}

static void
ktrfdset(const struct fd_set *fds, int len)
{
	int nfds, i, start = -1;
	char sep = ' ';

	nfds = len * NBBY;
	printf("struct fd_set {");
	for (i = 0; i <= nfds; i++)
		if (i != nfds && FD_ISSET(i, fds)) {
			if (start == -1)
				start = i;
		} else if (start != -1) {
			putchar(sep);
			if (start == i - 1)
				printf("%d", start);
			else if (start == i - 2)
				printf("%d,%d", start, i - 1);
			else
				printf("%d-%d", start, i - 1);
			sep = ',';
			start = -1;
		}

	printf(" }\n");
}

static void
ktrstruct(char *buf, size_t buflen)
{
	char *name, *data;
	size_t namelen, datalen;
	int i;

	for (name = buf, namelen = 0; namelen < buflen && name[namelen] != '\0';
	     ++namelen)
		/* nothing */;
	if (namelen == buflen)
		goto invalid;
	if (name[namelen] != '\0')
		goto invalid;
	data = buf + namelen + 1;
	datalen = buflen - namelen - 1;
	if (datalen == 0)
		goto invalid;
	/* sanity check */
	for (i = 0; i < namelen; ++i)
		if (!isalpha((unsigned char)name[i]))
			goto invalid;
	if (strcmp(name, "stat") == 0) {
		struct stat sb;

		if (datalen != sizeof(struct stat))
			goto invalid;
		memcpy(&sb, data, datalen);
		ktrstat(&sb);
	} else if (strcmp(name, "sockaddr") == 0) {
		struct sockaddr_storage ss;

		if (datalen > sizeof(ss))
			goto invalid;
		memcpy(&ss, data, datalen);
		if ((ss.ss_family != AF_UNIX && 
		    datalen < sizeof(struct sockaddr)) || datalen != ss.ss_len)
			goto invalid;
		ktrsockaddr((struct sockaddr *)&ss);
	} else if (strcmp(name, "abstimespec") == 0 ||
	    strcmp(name, "reltimespec") == 0) {
		struct timespec ts;

		if (datalen != sizeof(ts))
			goto invalid;
		memcpy(&ts, data, datalen);
		ktrtimespec(&ts, name[0] == 'r');
	} else if (strcmp(name, "abstimeval") == 0 ||
	    strcmp(name, "reltimeval") == 0) {
		struct timeval tv;

		if (datalen != sizeof(tv))
			goto invalid;
		memcpy(&tv, data, datalen);
		ktrtimeval(&tv, name[0] == 'r');
	} else if (strcmp(name, "sigaction") == 0) {
		struct sigaction sa;

		if (datalen != sizeof(sa))
			goto invalid;
		memcpy(&sa, data, datalen);
		ktrsigaction(&sa);
	} else if (strcmp(name, "rlimit") == 0) {
		struct rlimit lim;

		if (datalen != sizeof(lim))
			goto invalid;
		memcpy(&lim, data, datalen);
		ktrrlimit(&lim);
	} else if (strcmp(name, "tfork") == 0) {
		struct __tfork tf;

		if (datalen != sizeof(tf))
			goto invalid;
		memcpy(&tf, data, datalen);
		ktrtfork(&tf);
	} else if (strcmp(name, "fdset") == 0) {
		struct fd_set *fds;
		if ((fds = malloc(datalen)) == NULL)
			err(1, "malloc");
		memcpy(fds, data, datalen);
		ktrfdset(fds, datalen);
		free(fds);
	} else {
		printf("unknown structure %s\n", name);
	}
	return;
invalid:
	printf("invalid record\n");
}

static void
d1363 1
a1363 1
static void
@


1.82
log
@Use WAIT_* for the first argument to wait4(), and otherwise treat it (and
the first argument to kill) as signed 32bit ints.

ok millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.81 2013/06/01 09:51:30 miod Exp $	*/
d168 8
d1686 157
@


1.81
log
@Userland bits for utrace record handling; from otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.80 2013/04/23 20:03:05 deraadt Exp $	*/
d50 1
d166 2
d633 1
a633 1
		pn(NULL);
d798 1
a798 1
		pn(NULL);
d1660 17
@


1.80
log
@simple large ino_t handling
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.79 2013/04/16 22:11:10 deraadt Exp $	*/
d160 1
d290 3
d376 3
d1104 1
a1104 1
ktrgenio(struct ktr_genio *ktr, size_t len)
a1105 1
	unsigned char *dp = (unsigned char *)ktr + sizeof(struct ktr_genio);
d1107 1
a1107 2
	size_t datalen = len - sizeof(struct ktr_genio);
	static int screenwidth = 0;
a1119 8
	printf("fd %d %s %zu bytes\n", ktr->ktr_fd,
		ktr->ktr_rw == UIO_READ ? "read" : "wrote", datalen);
	if (maxdata == 0)
		return;
	if (datalen > maxdata)
		datalen = maxdata;
	if (iohex && !datalen)
		return;
d1202 17
a1279 2


d1604 9
d1619 1
a1619 1
	    "%*s[-t [ceinsw]]\n",
@


1.79
log
@handle large time_t variables; ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.78 2013/04/15 16:47:14 guenther Exp $	*/
d1381 3
a1383 2
	printf("dev=%d, ino=%u, mode=%s, nlink=%u, ",
	    statp->st_dev, statp->st_ino, mode, statp->st_nlink);
@


1.78
log
@Remove CTL_USER hierarchy from sysctl()
(Use sysconf() or confstr() instead)

ok miod@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.77 2012/12/25 09:35:51 guenther Exp $	*/
d388 2
a389 1
		(void)printf("%ld.%06ld ", temp.tv_sec, temp.tv_nsec / 1000);
@


1.77
log
@Report macro names for the second argument to shutdown(), getrusage(),
pathconf(), and fpathconf(), and for poll()'s INFTIM.
When open()'s flag arg doesn't include O_CREAT, don't show the third argument
unless th e-n option is given.  Ditto for fcntl()'s F_GETFD and F_GETFL ops.
Show sysctl()'s KERN_PROC_KTHREAD as "kthread".

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.76 2012/12/05 12:54:15 millert Exp $	*/
a906 1
static struct ctlname username[] = CTL_USER_NAMES;
a975 3
		case CTL_USER:
			SETNAME(username);
			break;
@


1.76
log
@Explicitly include sys/resource.h for RLIM_INF, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.75 2012/07/11 11:18:40 guenther Exp $	*/
d62 1
d163 1
d722 4
d750 5
d791 3
d879 5
d922 1
d1627 11
@


1.75
log
@Report ptrace(PT_{GET,SET}XMMREGS) by name

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.74 2012/07/09 17:51:08 claudio Exp $	*/
d40 1
@


1.74
log
@Print the fd_set used by select in kdump.
OK guenther@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.73 2012/06/29 05:09:58 guenther Exp $	*/
d424 5
d437 5
@


1.73
log
@sigpending() returns a sigset just like sigprocmask(), so decode it the same

ok matthew@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.72 2012/06/21 06:55:58 guenther Exp $	*/
d1445 27
d1547 7
@


1.72
log
@Add dumping of struct __tfork done by the revised __tfork syscall
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.71 2012/06/20 07:31:33 guenther Exp $	*/
d1017 1
@


1.71
log
@Handle PT_GET_THREAD_*

ok otto@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.70 2012/04/12 12:33:04 deraadt Exp $	*/
d1437 7
d1512 7
@


1.70
log
@remove rfork(); ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.69 2012/04/11 13:55:26 mikeb Exp $	*/
d138 1
@


1.69
log
@guenther and kettenis say THREAD_PID_OFFSET shouldn't be subtracted
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.68 2012/04/11 12:44:02 jmc Exp $	*/
a1006 1
		    strcmp(current->sysnames[code], "rfork") == 0 ||
@


1.68
log
@add -H to usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.67 2012/04/10 20:39:37 mikeb Exp $	*/
d376 1
a376 1
		(void)printf("/%-5ld", (long)kth->ktr_tid - THREAD_PID_OFFSET);
@


1.67
log
@Add a start record to the ktrace and use a special magic string "KTR"
to identify ktrace files.  kdump(1) will now refuse to operate on
trace data without the start record and as a bonus will print only
PID, unless an -H flag is specified to print PID/TID pairs.  Initial
diff, input from and ok deraadt, guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.66 2012/03/31 18:59:14 deraadt Exp $	*/
d1519 1
a1519 1
	    "[-dlnRrTXx] [-e emulation] [-f file] [-m maxdata] [-p pid]\n"
@


1.66
log
@err(1, NULL) can drive people insane, so please avoid it.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.65 2012/03/19 09:05:39 guenther Exp $	*/
d76 2
a77 1
int timestamp, decimal, iohex, fancy = 1, tail, maxdata = INT_MAX, resolv;
d171 1
a171 1
	while ((ch = getopt(argc, argv, "e:f:dlm:nrRp:Tt:xX")) != -1)
d183 3
d229 3
d339 1
a339 1
	static struct timeval prevtime;
d341 1
a341 1
	struct timeval temp;
d374 4
a377 2
	(void)printf("%6ld %-8.*s ", (long)kth->ktr_pid, MAXCOMLEN,
	    kth->ktr_comm);
d380 1
a380 1
			timersub(&kth->ktr_time, &prevtime, &temp);
d384 1
a384 1
		(void)printf("%ld.%06ld ", temp.tv_sec, temp.tv_usec);
@


1.65
log
@Add tracing and dumping of "pointer to struct" syscall arguments for
structs timespec, timeval, sigaction, and rlimit.

ok otto@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.64 2012/02/20 21:04:35 guenther Exp $	*/
d241 1
a241 1
				err(1, NULL);
@


1.64
log
@- add more ptrace() ops
- be robust against a ktrace file the contains a record with
  ktr_len==SIZE_MAX, instead of reallocating its buffer to zero size
- format the clockid_t argument to clock_*() and __thrsleep() as CLOCK_*
- format the sigset_t argument to sigprocmask() and __thrsigdivert(), the
  return from sigprocmask(), and the mask reported for PSIG records
  as a bitset of SIG* values, except that if most the bits are set
  then invert it and prefix with '~'
- show the next level of the kern.proc sysctl
- __tfork() creates procs, so do the mappidtoemul() handling
- refactor ktrstat()'s time printing bits and fix a whitespace glitch
  in its output
- reduce stack usage in ktrstruct()
- a value of zero is not an error for mode bits (S_*), atflag bits
  (AT_*), wait options (W*), or shmat flags (SHM_*)

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.63 2011/09/19 22:00:37 deraadt Exp $	*/
d1367 61
d1466 30
@


1.63
log
@teach kdump about "siginfo-style" signal sub-codes, and the (currently)
limited subset of information the kernel supplies.
ok miod pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.62 2011/07/28 10:33:36 otto Exp $	*/
d60 1
d136 1
d237 2
d718 5
d728 4
d759 7
d872 11
d969 4
d999 1
d1006 13
a1018 3
			(void)printf("%ld", (long)ret);
			if (ret < 0 || ret > 9)
				(void)printf("/%#lx", (long)ret);
d1172 5
a1176 3
	else
		(void)printf("caught handler=0x%lx mask=0x%x",
		    (u_long)psig->action, psig->mask);
d1230 1
a1230 1
void
d1307 17
a1323 2
void
ktrstat(struct stat *statp)
d1325 9
a1333 1
	char mode[12], timestr[PATH_MAX + 4];
a1335 1
	struct tm *tm;
d1341 1
a1341 1
	printf("struct stat {");
d1355 6
a1360 36
	if (resolv == 0)
		printf("%jd", (intmax_t)statp->st_atim.tv_sec);
	else {
		tm = localtime(&statp->st_atim.tv_sec);
		(void)strftime(timestr, sizeof(timestr), TIME_FORMAT, tm);
		printf("\"%s\"", timestr);
	}
	if (statp->st_atim.tv_nsec != 0)
		printf(".%09ld, ", statp->st_atim.tv_nsec);
	else
		printf(", ");
	printf("stime=");
	if (resolv == 0)
		printf("%jd", (intmax_t)statp->st_mtim.tv_sec);
	else {
		tm = localtime(&statp->st_mtim.tv_sec);
		(void)strftime(timestr, sizeof(timestr), TIME_FORMAT, tm);
		printf("\"%s\"", timestr);
	}
	if (statp->st_mtim.tv_nsec != 0)
		printf(".%09ld, ", statp->st_mtim.tv_nsec);
	else
		printf(", ");
	printf("ctime=");
	if (resolv == 0)
		printf("%jd", (intmax_t)statp->st_ctim.tv_sec);
	else {
		tm = localtime(&statp->st_ctim.tv_sec);
		(void)strftime(timestr, sizeof(timestr), TIME_FORMAT, tm);
		printf("\"%s\"", timestr);
	}
	if (statp->st_ctim.tv_nsec != 0)
		printf(".%09ld, ", statp->st_ctim.tv_nsec);
	else
		printf(", ");
	printf("size=%lld, blocks=%lld, blksize=%u, flags=0x%x, gen=0x%x",
d1366 1
a1366 1
void
a1371 2
	struct stat sb;
	struct sockaddr_storage ss;
d1389 2
d1396 2
@


1.62
log
@Resolve sysctl numbers, original diff from nicm@@, man page bits from
guenther@@; ok guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.61 2011/07/19 18:20:11 matthew Exp $	*/
d44 1
a44 1
#include <sys/socket.h>
d1125 1
a1125 1
		(void)printf("SIG_DFL code %d", psig->code);
d1129 30
@


1.61
log
@Add fancy kdump support for the openat(2) system calls.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.60 2011/07/17 07:49:34 otto Exp $	*/
d37 2
d40 2
d46 1
d48 1
d54 2
d151 1
d523 2
a524 1
		int *np, n;
d531 2
a532 2
		np = (int *)(ap + 6);
		for (; n--; np++) {
d535 4
a538 1
			printf("%d", *np);
d839 109
@


1.60
log
@handle files produced by ktrace -a better by making a distinction
between default and current emulation; ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.59 2011/07/17 06:55:25 otto Exp $	*/
d51 1
d147 1
d545 1
a545 1
		pn( NULL);
d733 78
d1242 11
@


1.59
log
@since we're treating native emuls different (more fancy) than
non-native we should do a better job of tracking the emul
corresponding to a pid; ok guenther@@; also tested by pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.58 2011/07/10 06:13:55 otto Exp $	*/
d111 1
d155 1
a155 1
	current = &emulations[0];	/* native */
d161 1
d299 1
a299 1
	return current;
@


1.58
log
@Make -m 0 work as expected.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.57 2011/07/09 07:22:05 otto Exp $	*/
d110 9
a118 1
struct emulation *current;
d131 2
d212 2
d234 1
d256 1
d268 32
d755 1
a755 1
	else
d757 6
@


1.57
log
@print the name of an unknown struct, it has been verified to be sane;
prodded by tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.56 2011/07/09 04:01:30 deraadt Exp $	*/
d66 1
a66 1
int timestamp, decimal, iohex, fancy = 1, tail, maxdata, resolv;
d777 3
a779 1
	if (maxdata && datalen > maxdata)
@


1.56
log
@remove more atalk bits
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.55 2011/07/08 19:29:44 otto Exp $	*/
d1076 1
a1076 1
		printf("unknown structure\n");
@


1.55
log
@Support sending struct info to kdump. So far for struct stat and
struct sockaddress; mostly from freebsd. ok deraadt@@ tedu@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.54 2011/07/07 06:39:48 otto Exp $	*/
a930 14
#ifdef NETATALK
	case AF_APPLETALK: {
		struct sockaddr_at	*sa_at;
		struct netrange		*nr;

		sa_at = (struct sockaddr_at *)sa;
		check_sockaddr_len(at);
		nr = &sa_at->sat_range.r_netrange;
		printf("%d.%d, %d-%d, %d", ntohs(sa_at->sat_addr.s_net),
			sa_at->sat_addr.s_node, ntohs(nr->nr_firstnet),
			ntohs(nr->nr_lastnet), nr->nr_phase);
		break;
	}
#endif
@


1.54
log
@Don't crash on non-native emuls; ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.53 2011/07/04 22:59:43 tedu Exp $	*/
d40 5
d54 1
d56 2
d66 1
a66 1
int timestamp, decimal, iohex, fancy = 1, tail, maxdata;
d71 1
d132 1
d146 1
a146 1
	while ((ch = getopt(argc, argv, "e:f:dlm:nRp:Tt:xX")) != -1)
d169 3
d244 3
d295 3
d892 205
d1103 1
a1103 1
	    "[-dlnRTXx] [-e emulation] [-f file] [-m maxdata] [-p pid]\n"
@


1.53
log
@remove compat_svr4
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.52 2011/07/04 06:44:52 otto Exp $	*/
d426 3
d666 1
@


1.52
log
@Big restructuring of the main switch making it much more readable.
Also, handle offset_t (long long) args and padding in a consistent manner.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.51 2011/06/20 17:54:48 otto Exp $	*/
a67 1
#include <compat/svr4/svr4_syscall.h>
a79 1
#include <compat/svr4/svr4_syscalls.c>
a97 1
	{ "svr4",	svr4_syscallnames,	SVR4_SYS_MAXSYSCALL },
@


1.51
log
@more fancy kdump output, mostly from FreeBSD; ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.51 2011/06/20 17:51:33 otto Exp $	*/
d113 4
d320 95
a414 11
#define print_number(i, n, c) do {			\
	if (c)						\
		(void)putchar(c);			\
	if (decimal)					\
		(void)printf("%ld", (long)*i);		\
	else						\
		(void)printf("%#lx", (long)*i);		\
	i++;						\
	n--; 						\
	c = ',';					\
} while (0);
d419 2
a420 2
	int narg = ktr->ktr_argsize / sizeof(register_t);
	register_t *ap;
d428 30
a457 370
	if (narg) {
		char c = '\0';
		if (fancy) {
			switch (ktr->ktr_code) {
			case SYS_ioctl: {
				const char *cp;

				if (decimal)
					(void)printf("%ld", (long)*ap);
				else
					(void)printf("%#lx", (long)*ap);
				ap++;
				narg--;
				if ((cp = ioctlname(*ap)) != NULL)
					(void)printf(",%s", cp);
				else
					ioctldecode(*ap);
				c = ',';
				ap++;
				narg--;
				break;
			}
			case SYS___sysctl: {
				int *np, n;

				n = ap[1];
				if (n > CTL_MAXNAME)
					n = CTL_MAXNAME;
				np = (int *)(ap + 6);
				for (; n--; np++) {
					if (c)
						putchar(c);
					printf("%d", *np);
					c = '.';
				}

				c = ',';
				ap += 2;
				narg -= 2;
				break;
			}
			case SYS_ptrace: 
				if (*ap >= 0 && *ap <
				    sizeof(ptrace_ops) / sizeof(ptrace_ops[0]))
					(void)printf("%s", ptrace_ops[*ap]);
				else switch(*ap) {
#ifdef PT_GETFPREGS
				case PT_GETFPREGS:
					(void)printf("PT_GETFPREGS");
					break;
#endif
				case PT_GETREGS:
					(void)printf("PT_GETREGS");
					break;
#ifdef PT_SETFPREGS
				case PT_SETFPREGS:
					(void)printf("PT_SETFPREGS");
					break;
#endif
				case PT_SETREGS:
					(void)printf("PT_SETREGS");
					break;
#ifdef PT_STEP
				case PT_STEP:
					(void)printf("PT_STEP");
					break;
#endif
#ifdef PT_WCOOKIE
				case PT_WCOOKIE:
					(void)printf("PT_WCOOKIE");
					break;
#endif
				default:
					(void)printf("%ld", (long)*ap);
					break;
				}
				c = ',';
				ap++;
				narg--;
				break;
			case SYS_access:
				print_number(ap, narg, c);
				(void)putchar(',');
				accessmodename((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_chmod:
			case SYS_fchmod: 
				print_number(ap, narg, c);
				(void)putchar(',');
				modename((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_fcntl: {
				int cmd;
				int arg;
				print_number(ap, narg, c);
				cmd = *ap;
				arg = *++ap;
				(void)putchar(',');
				fcntlcmdname(cmd, arg, decimal);
				ap++;
				narg -= 2;
				break;
			}
			case SYS_flock:
				print_number(ap, narg, c);
				(void)putchar(',');
				flockname((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_getrlimit:
			case SYS_setrlimit:
				rlimitname((int)*ap);
				ap++;
				narg--;
				c = ',';
				break;
			case SYS_getsockopt:
			case SYS_setsockopt:
				print_number(ap, narg, c);
				(void)putchar(',');
				sockoptlevelname((int)*ap, decimal);
				if ((int)*ap == SOL_SOCKET) {
					ap++;
					narg--;
					(void)putchar(',');
					sockoptname((int)*ap);
				}
				ap++;
				narg--;
				break;
			case SYS_kill:
				print_number(ap, narg, c);
				(void)putchar(',');
				signame((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_lseek:
				print_number(ap, narg, c);
				/* skip padding */
				ap++;
				narg--;
				print_number(ap, narg, c);
				(void)putchar(',');
				whencename((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_madvise:
				print_number(ap, narg, c);
				print_number(ap, narg, c);
				(void)putchar(',');
				madvisebehavname((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_minherit:
				print_number(ap, narg, c);
				print_number(ap, narg, c);
				(void)putchar(',');
				minheritname((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_mlockall:
				mlockallname((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_mmap:
				print_number(ap, narg, c);
				print_number(ap, narg, c);
				(void)putchar(',');
				mmapprotname((int)*ap);
				(void)putchar(',');
				ap++;
				narg--;
				mmapflagsname((int)*ap);
				ap++;
				narg--;
				print_number(ap, narg, c);
				/* skip padding */
				ap++;
				narg--;
				break;
			case SYS_mprotect:
				print_number(ap, narg, c);
				print_number(ap, narg, c);
				(void)putchar(',');
				mmapprotname((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_mquery:
				print_number(ap, narg, c);
				print_number(ap, narg, c);
				(void)putchar(',');
				mmapprotname((int)*ap);
				ap++;
				narg--;
				(void)putchar(',');
				mmapflagsname((int)*ap);
				ap++;
				narg--;
				print_number(ap, narg, c);
				/* skip padding */
				ap++;
				narg--;
				break;
			case SYS_msync:
				print_number(ap, narg, c);
				print_number(ap, narg, c);
				(void)putchar(',');
				msyncflagsname((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_msgctl:
				print_number(ap, narg, c);
				(void)putchar(',');
				shmctlname((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_open: {
				int     flags;
				int     mode;
				print_number(ap, narg, c);
				flags = *ap;
				mode = *++ap;
				(void)putchar(',');
				flagsandmodename(flags, mode, decimal);
				ap++;
				narg -= 2;
				break;
			}
			case SYS_pread:
			case SYS_preadv:
			case SYS_pwrite:
			case SYS_pwritev:
				print_number(ap, narg, c);
				print_number(ap, narg, c);
				print_number(ap, narg, c);
				/* skip padding */
				ap++;
				narg--;
				break;
			case SYS_recvmsg:
			case SYS_sendmsg:
				print_number(ap, narg, c);
				print_number(ap, narg, c);
				(void)putchar(',');
				sendrecvflagsname((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_recvfrom:
			case SYS_sendto:
				print_number(ap, narg, c);
				print_number(ap, narg, c);
				print_number(ap, narg, c);
				(void)putchar(',');
				sendrecvflagsname((int)*ap);
				ap++;
				narg--;
				break;
			case SYS___semctl:
				print_number(ap, narg, c);
				print_number(ap, narg, c);
				(void)putchar(',');
				semctlname((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_semget:
				print_number(ap, narg, c);
				print_number(ap, narg, c);
				(void)putchar(',');
				semgetname((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_shmat:
				print_number(ap, narg, c);
				print_number(ap, narg, c);
				(void)putchar(',');
				shmatname((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_shmctl:
				print_number(ap, narg, c);
				(void)putchar(',');
				shmctlname((int)*ap);
				ap++;
				narg--;
				break;
			case SYS_sigaction:
				signame((int)*ap);
				ap++;
				narg--;
				c = ',';
				break;
			case SYS_sigprocmask:
				sigprocmaskhowname((int)*ap);
				ap++;
				narg--;
				c = ',';
				break;
			case SYS_socket: {
				int sockdomain = (int)*ap;
				sockdomainname(sockdomain);
				ap++;
				narg--;
				(void)putchar(',');
				socktypename((int)*ap);
				ap++;
				narg--;
				if (sockdomain == PF_INET ||
				    sockdomain == PF_INET6) {
					(void)putchar(',');
					sockipprotoname((int)*ap);
					ap++;
					narg--;
				}
				c = ',';
				break;
			}
			case SYS_socketpair:
				sockdomainname((int)*ap);
				ap++;
				narg--;
				(void)putchar(',');
				socktypename((int)*ap);
				ap++;
				narg--;
				c = ',';
				break;
			case SYS_truncate:
			case SYS_ftruncate:
				print_number(ap, narg, c);
				/* skip padding */
				ap++;
				narg--;
				break;
			case SYS_wait4:
				print_number(ap, narg, c);
				print_number(ap, narg, c);
				(void)putchar(',');
				wait4optname((int)*ap);
				ap++;
				narg--;
				break;
			}
		}
		while (narg) {
			if (c)
				putchar(c);
			if (decimal)
				(void)printf("%ld", (long)*ap);
			else
				(void)printf("%#lx", (long)*ap);
			c = ',';
			ap++;
			narg--;
d459 217
@


1.50
log
@Change ktr_retval to a register_t so that we can see the full 64-bits
when neccesary.  It is incredible this 64-bit bug has existed for
this long.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.49 2011/04/06 11:36:26 miod Exp $	*/
d38 1
d55 1
d316 12
d331 1
a331 1
	int argsize = ktr->ktr_argsize;
d340 1
a340 1
	if (argsize) {
d343 2
a344 1
			if (ktr->ktr_code == SYS_ioctl) {
d352 1
a352 1
				argsize -= sizeof(register_t);
d359 4
a362 2
				argsize -= sizeof(register_t);
			} else if (ktr->ktr_code == SYS___sysctl) {
d378 4
a381 2
				argsize -= 2 * sizeof(register_t);
			} else if (ktr->ktr_code == SYS_ptrace) {
d418 280
a697 1
				argsize -= sizeof(register_t);
d700 1
a700 1
		while (argsize) {
d709 1
a709 1
			argsize -= sizeof(register_t);
d915 1
a915 1
	    __progname, sizeof("usage: ") + strlen(__progname), "");
@


1.49
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.48 2011/04/05 15:24:32 guenther Exp $	*/
d420 1
a420 1
	int ret = ktr->ktr_retval;
d431 1
a431 1
			(void)printf("%d", ret);
d433 1
a433 1
				(void)printf("/%#x", ret);
d436 1
a436 1
				(void)printf("%d", ret);
d438 1
a438 1
				(void)printf("%#x", ret);
@


1.48
log
@Remove FREEBSD_COMPAT bits and obsolete RTHREAD define
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.47 2010/07/06 00:31:02 oga Exp $	*/
d99 1
a99 1
	{ NULL,		NULL,			NULL }
@


1.47
log
@make kdump build after COMPAT_BSDOS removal.

Bad tedu, no cookie.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.46 2010/07/02 20:00:54 tedu Exp $	*/
a64 1
#include <compat/freebsd/freebsd_syscall.h>
a75 1
#define RTHREADS
a77 1
#include <compat/freebsd/freebsd_syscalls.c>
a87 1
#undef RTHREADS
a98 1
	{ "freebsd",	freebsd_syscallnames,	FREEBSD_SYS_MAXSYSCALL },
@


1.46
log
@remove userland bits of compat_sunos
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.45 2010/07/01 17:26:52 tedu Exp $	*/
a64 1
#include <compat/bsdos/bsdos_syscall.h>
a79 1
#include <compat/bsdos/bsdos_syscalls.c>
a102 1
	{ "bsdos",	bsdos_syscallnames,	BSDOS_SYS_MAXSYSCALL },
@


1.45
log
@another day, another compat gets removed.  today is ibcs2's turn
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.44 2010/06/30 20:43:36 tedu Exp $	*/
a67 1
#include <compat/sunos/sunos_syscall.h>
a83 1
#include <compat/sunos/sunos_syscalls.c>
a103 1
	{ "sunos",	sunos_syscallnames,	SUNOS_SYS_MAXSYSCALL },
@


1.44
log
@remove compat_osf1.  ok deraadt miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.43 2010/06/29 20:30:33 guenther Exp $	*/
a66 1
#include <compat/ibcs2/ibcs2_syscall.h>
a83 1
#include <compat/ibcs2/ibcs2_syscalls.c>
a104 1
	{ "ibcs2",	ibcs2_syscallnames,	IBCS2_SYS_MAXSYSCALL },
@


1.43
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.42 2010/06/29 17:35:15 tedu Exp $	*/
a68 1
#include <compat/osf1/osf1_syscall.h>
a86 1
#include <compat/osf1/osf1_syscalls.c>
a108 1
	{ "osf1",	osf1_syscallnames,	OSF1_SYS_MAXSYSCALL },
@


1.42
log
@ultrix support going away, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.41 2009/10/27 23:59:39 deraadt Exp $	*/
a66 3
#if defined(__hppa__) || defined(__m68k__)
#include <compat/hpux/hpux_syscall.h>
#endif
a85 3
#if defined(__hppa__) || defined(__m68k__)
#include <compat/hpux/hpux_syscalls.c>
#endif
a108 3
#if defined(__hppa__) || defined(__m68k__)
	{ "hpux",	hpux_syscallnames,	HPUX_SYS_MAXSYSCALL },
#endif
@


1.41
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.40 2009/10/21 15:08:23 sobrado Exp $	*/
a74 1
#include <compat/ultrix/ultrix_syscall.h>
a96 1
#include <compat/ultrix/ultrix_syscalls.c>
a122 1
	{ "ultrix",	ultrix_syscallnames,	ULTRIX_SYS_MAXSYSCALL },
@


1.40
log
@sort options; synchronize argument names with synopsis;
split the usage's output in two lines to fit on standard displays.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.39 2007/05/29 02:01:03 deraadt Exp $	*/
a30 13

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1988, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)kdump.c	8.4 (Berkeley) 4/28/95";
#endif
static const char rcsid[] = "$OpenBSD: kdump.c,v 1.39 2007/05/29 02:01:03 deraadt Exp $";
#endif /* not lint */
@


1.39
log
@more parts of netbsd compat that go away
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.38 2007/03/03 23:36:15 jmc Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: kdump.c,v 1.38 2007/03/03 23:36:15 jmc Exp $";
d657 3
a659 2
	    "[-dlnRTXx] [-e emulation] [-p pid] [-f trfile] [-m maxdata] "
	    "[-t [ceinsw]]\n", __progname);
@


1.38
log
@`l' before `n';
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.37 2006/05/17 02:12:17 tedu Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: kdump.c,v 1.37 2006/05/17 02:12:17 tedu Exp $";
a79 1
#include <compat/netbsd/netbsd_syscall.h>
a102 1
#include <compat/netbsd/netbsd_syscalls.c>
a140 1
	{ "netbsd",	netbsd_syscallnames,	NETBSD_SYS_MAXSYSCALL },
@


1.37
log
@use lots more size_t instead of int running around
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.36 2006/05/11 12:26:42 jmc Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: kdump.c,v 1.36 2006/05/11 12:26:42 jmc Exp $";
d660 1
a660 1
	    "[-dnlRTXx] [-e emulation] [-p pid] [-f trfile] [-m maxdata] "
@


1.36
log
@- add -X and -x to SYNOPSIS
- sort options
- new sentence, new line
- sync usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.35 2006/05/11 07:24:03 tedu Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: kdump.c,v 1.35 2006/05/11 07:24:03 tedu Exp $";
d156 1
a156 1
static int fread_tail(void *, int, int);
d159 3
a161 3
static void ktremul(char *, int);
static void ktrgenio(struct ktr_genio *, int);
static void ktrnamei(const char *, int);
d171 2
a172 1
	int ch, ktrlen, size, silent;
d224 1
a224 1
	m = (void *)malloc(size = 1025);
d226 1
a226 1
		errx(1, "%s", strerror(ENOMEM));
d235 1
a235 2
		if ((ktrlen = ktr_header.ktr_len) < 0)
			errx(1, "bogus length 0x%x", ktrlen);
d241 1
a241 1
				errx(1, "%s", strerror(ENOMEM));
d281 1
a281 1
fread_tail(void *buf, int size, int num)
d498 1
a498 1
ktrnamei(const char *cp, int len)
d500 1
a500 1
	(void)printf("\"%.*s\"\n", len, cp);
d504 1
a504 1
ktremul(char *cp, int len)
d519 1
a519 1
ktrgenio(struct ktr_genio *ktr, int len)
d521 3
a523 2
	unsigned char *dp = (unsigned char *)ktr + sizeof (struct ktr_genio);
	int i, j, datalen = len - sizeof (struct ktr_genio);
d537 1
a537 1
	printf("fd %d %s %d bytes\n", ktr->ktr_fd,
@


1.35
log
@cedric points out 0xff mask isn't needed with unsigned chars
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.34 2006/05/11 07:15:08 tedu Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: kdump.c,v 1.34 2006/05/11 07:15:08 tedu Exp $";
d659 1
a659 1
	    "[-dnlRTxX] [-e emulation] [-p pid] [-f trfile] [-m maxdata] "
@


1.34
log
@oops, missed a %ld should be %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.33 2006/05/11 07:13:17 tedu Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: kdump.c,v 1.33 2006/05/11 07:13:17 tedu Exp $";
d546 1
a546 1
			printf("%02x", dp[i] & 0xff);
d569 1
a569 1
					printf("%02x ", dp[i+j] & 0xff);
@


1.33
log
@need ctype.h for isprint.
%c expects an int argument, cast a u_long value so it gets it.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.32 2006/05/11 06:52:04 tedu Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: kdump.c,v 1.32 2006/05/11 06:52:04 tedu Exp $";
d354 1
a354 1
		printf(decimal ? ",%ld)" : ",%#lx)", (cmd >> 16) & 0xff);
@


1.32
log
@C spells 'byte' as 'unsigned char'.  signed chars are not healthy for isprint
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.31 2006/05/11 06:49:00 tedu Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: kdump.c,v 1.31 2006/05/11 06:49:00 tedu Exp $";
d56 1
d351 2
a352 2
	printf(decimal ? ",_IO%s('%c',%ld" : ",_IO%s('%c',%#lx",
	    dirbuf, (cmd >> 8) & 0xff, cmd & 0xff);
@


1.31
log
@-x and -X options to print io output in hex.  from cedric berger
ok mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.30 2005/12/31 20:56:37 miod Exp $	*/
d33 1
a33 1
static char copyright[] =
d42 1
a42 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.30 2005/12/31 20:56:37 miod Exp $";
d520 1
a520 1
	char *dp = (char *)ktr + sizeof (struct ktr_genio);
d524 1
a524 1
	char visbuf[5], *cp, c;
@


1.30
log
@Grok rthreads system calls before Dale yiells after me.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.29 2005/12/20 07:37:21 miod Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.29 2005/12/20 07:37:21 miod Exp $";
d68 1
a68 1
int timestamp, decimal, fancy = 1, tail, maxdata;
d176 1
a176 1
	while ((ch = getopt(argc, argv, "e:f:dlm:nRp:Tt:")) != -1)
d210 6
d521 1
a521 1
	int datalen = len - sizeof (struct ktr_genio);
d523 2
a524 2
	int col = 0, width;
	char visbuf[5], *cp;
d539 44
d586 1
a586 1
		(void) vis(visbuf, *dp, VIS_CSTYLE, *(dp+1));
d658 1
a658 1
	    "[-dnlRT] [-e emulation] [-p pid] [-f trfile] [-m maxdata] "
@


1.29
log
@No need to define UFS_EXTATTR anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.28 2005/09/10 21:06:21 deraadt Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.28 2005/09/10 21:06:21 deraadt Exp $";
d98 1
d121 1
@


1.28
log
@for sysctl records, do not expect more than CTL_MAXNAME additional
"faked" arguments; ok uwe espie
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.27 2005/06/02 17:32:02 mickey Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.27 2005/06/02 17:32:02 mickey Exp $";
a97 1
#define UFS_EXTATTR
a119 1
#undef UFS_EXTATTR
@


1.27
log
@for sysctl syscall pass the mib[] back to kdump to parse;
always print () on syscalls w/ void args even (deraadt version)
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.26 2004/07/09 23:51:40 deraadt Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.26 2004/07/09 23:51:40 deraadt Exp $";
d51 1
d387 2
@


1.26
log
@#ifdef hpux only for m68k or hppa; this needs a revisit since this shows
something flawed in the way that the emulation system calls are being
handled
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.25 2004/07/09 21:52:21 mickey Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.25 2004/07/09 21:52:21 mickey Exp $";
d362 1
d364 1
a364 1
		char c = '(';
d370 1
a370 1
					(void)printf("(%ld", (long)*ap);
d372 1
a372 1
					(void)printf("(%#lx", (long)*ap);
d382 15
d400 1
a400 1
					(void)printf("(%s", ptrace_ops[*ap]);
d404 1
a404 1
					(void)printf("(PT_GETFPREGS");
d408 1
a408 1
					(void)printf("(PT_GETREGS");
d412 1
a412 1
					(void)printf("(PT_SETFPREGS");
d416 1
a416 1
					(void)printf("(PT_SETREGS");
d420 1
a420 1
					(void)printf("(PT_STEP");
d425 1
a425 1
					(void)printf("(PT_WCOOKIE");
d429 1
a429 1
					(void)printf("(%ld", (long)*ap);
d438 2
d441 1
a441 1
				(void)printf("%c%ld", c, (long)*ap);
d443 1
a443 1
				(void)printf("%c%#lx", c, (long)*ap);
a447 1
		(void)putchar(')');
d449 1
a449 1
	(void)putchar('\n');
@


1.25
log
@better includes for syscalls from kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.24 2004/03/04 20:39:27 miod Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.24 2004/03/04 20:39:27 miod Exp $";
d79 1
d81 1
d103 1
d105 1
d130 1
d132 1
@


1.24
log
@Better ptrace description, also fix an off-by-one spotted by otto
ok otto@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.23 2003/10/13 00:44:25 tedu Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.23 2003/10/13 00:44:25 tedu Exp $";
d76 10
a85 10
#include "../../sys/compat/bsdos/bsdos_syscall.h"
#include "../../sys/compat/freebsd/freebsd_syscall.h"
#include "../../sys/compat/netbsd/netbsd_syscall.h"
#include "../../sys/compat/hpux/hpux_syscall.h"
#include "../../sys/compat/ibcs2/ibcs2_syscall.h"
#include "../../sys/compat/linux/linux_syscall.h"
#include "../../sys/compat/osf1/osf1_syscall.h"
#include "../../sys/compat/sunos/sunos_syscall.h"
#include "../../sys/compat/svr4/svr4_syscall.h"
#include "../../sys/compat/ultrix/ultrix_syscall.h"
d96 1
a96 1
#include "../../sys/kern/syscalls.c"
d98 10
a107 10
#include "../../sys/compat/bsdos/bsdos_syscalls.c"
#include "../../sys/compat/freebsd/freebsd_syscalls.c"
#include "../../sys/compat/netbsd/netbsd_syscalls.c"
#include "../../sys/compat/hpux/hpux_syscalls.c"
#include "../../sys/compat/ibcs2/ibcs2_syscalls.c"
#include "../../sys/compat/linux/linux_syscalls.c"
#include "../../sys/compat/osf1/osf1_syscalls.c"
#include "../../sys/compat/sunos/sunos_syscalls.c"
#include "../../sys/compat/svr4/svr4_syscalls.c"
#include "../../sys/compat/ultrix/ultrix_syscalls.c"
@


1.23
log
@realloc stuff.  ok deraadt@@ jose@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.22 2003/07/02 20:54:17 deraadt Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.22 2003/07/02 20:54:17 deraadt Exp $";
d376 1
a376 1
				if (*ap >= 0 && *ap <=
d379 28
a406 1
				else
d408 2
@


1.22
log
@ioctlname() proto
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.21 2003/06/03 02:56:09 millert Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.21 2003/06/03 02:56:09 millert Exp $";
d223 4
a226 2
			m = (void *)realloc(m, ktrlen+1);
			if (m == NULL)
d228 1
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.20 2003/02/19 19:30:13 deraadt Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.20 2003/02/19 19:30:13 deraadt Exp $";
d64 1
@


1.20
log
@improve docs; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.19 2002/10/17 17:20:49 mickey Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.19 2002/10/17 17:20:49 mickey Exp $";
@


1.19
log
@missing defines for syscalls and a better formatting in usage
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.18 2002/07/06 19:14:20 nordin Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.18 2002/07/06 19:14:20 nordin Exp $";
d554 1
a554 1
	    "[-t [cnis]]\n", __progname);
@


1.18
log
@Remove kernel support for NTP. ok deraadt@@ and tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.17 2002/06/23 20:01:25 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.17 2002/06/23 20:01:25 deraadt Exp $";
d91 1
d98 1
d112 1
d119 1
d551 4
a554 2
	(void)fprintf(stderr,
"usage: kdump [-dnlRT] [-e emulation] [-p pid] [-f trfile] [-m maxdata] [-t [cnis]]\n");
@


1.17
log
@add -p pid feature, and ansi at the same time; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.16 2002/06/12 06:07:15 mpech Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.16 2002/06/12 06:07:15 mpech Exp $";
a96 1
#define NTP
a115 1
#undef NTP
@


1.16
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.15 2002/03/12 10:40:33 art Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.15 2002/03/12 10:40:33 art Exp $";
d73 1
d162 1
a162 3
main(argc, argv)
	int argc;
	char *argv[];
d164 2
a165 1
	int ch, ktrlen, size;
a166 1
	int trpoints = ALL_POINTS;
d170 1
a170 1
	while ((ch = getopt(argc, argv, "e:f:dlm:nRTt:")) != -1)
d190 3
d216 4
a219 1
		if (trpoints & (1<<ktr_header.ktr_type))
d231 2
d265 1
a265 3
fread_tail(buf, size, num)
	void *buf;
	int num, size;
d277 1
a277 2
dumpheader(kth)
	struct ktr_header *kth;
d279 1
a280 1
	static struct timeval prevtime;
d306 2
a307 1
		(void)sprintf(unknown, "UNKNOWN(%d)", kth->ktr_type);
d325 1
a325 2
ioctldecode(cmd)
	u_long cmd;
d344 1
a344 2
ktrsyscall(ktr)
	struct ktr_syscall *ktr;
d359 1
d399 1
a399 2
ktrsysret(ktr)
	struct ktr_sysret *ktr;
d434 1
a434 3
ktrnamei(cp, len) 
	const char *cp;
	int len;
d440 1
a440 3
ktremul(cp, len) 
	char *cp;
	int len;
d455 1
a455 3
ktrgenio(ktr, len)
	struct ktr_genio *ktr;
	int len;
d457 1
a458 5
	char *dp = (char *)ktr + sizeof (struct ktr_genio);
	char *cp;
	int col = 0;
	int width;
	char visbuf[5];
d460 2
d481 1
d490 1
a490 1
		switch(*cp) {
d516 1
a516 2
ktrpsig(psig)
	struct ktr_psig *psig;
d539 1
a539 2
ktrcsw(cs)
	struct ktr_csw *cs;
d546 1
a546 1
usage()
d550 1
a550 1
"usage: kdump [-dnlRT] [-e emulation] [-f trfile] [-m maxdata] [-t [cnis]]\n");
d555 1
a555 2
setemul(name)
	const char *name;
d558 1
@


1.15
log
@Add PT_IO to ptrace ops.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.14 2002/02/22 19:19:32 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.14 2002/02/22 19:19:32 deraadt Exp $";
d306 2
a307 1
	(void)printf("%6d %-8.*s ", kth->ktr_pid, MAXCOMLEN, kth->ktr_comm);
@


1.14
log
@include a siginfo_t with ktrace PSIG information, so that kdump can print
fault addresses and other information. (a small bug exists: in some signal
delivery cases, two PSIG records may be inserted, because postsig() is
unaware a PSIG record has already been placed.  but this small bug can
stay since the siginfo_t information helps us find and fix other bugs)
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.13 2002/02/16 21:27:47 millert Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.13 2002/02/16 21:27:47 millert Exp $";
d145 1
a145 1
	"PT_KILL",	"PT_ATTACH",	"PT_DETACH",
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.12 2001/08/18 00:48:57 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.12 2001/08/18 00:48:57 espie Exp $";
d524 1
a524 1
		(void)printf("SIG_DFL\n");
d526 14
a539 2
		(void)printf("caught handler=0x%lx mask=0x%x code=0x%x\n",
		    (u_long)psig->action, psig->mask, psig->code);
@


1.12
log
@Add lots of missing prototypes, constify a few things. Add explicit ints.
Makes gcc much happier, less warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.11 2001/07/12 05:17:12 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.11 2001/07/12 05:17:12 deraadt Exp $";
d148 11
a158 11
static int fread_tail __P((void *, int, int));
static void dumpheader __P((struct ktr_header *));
static void ktrcsw __P((struct ktr_csw *));
static void ktremul __P((char *, int));
static void ktrgenio __P((struct ktr_genio *, int));
static void ktrnamei __P((const char *, int));
static void ktrpsig __P((struct ktr_psig *));
static void ktrsyscall __P((struct ktr_syscall *));
static void ktrsysret __P((struct ktr_sysret *));
static void setemul __P((const char *));
static void usage __P((void));
@


1.11
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.10 1999/09/25 19:35:47 kstailey Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.10 1999/09/25 19:35:47 kstailey Exp $";
d68 1
d148 12
d166 1
a166 1
	register void *m;
d254 1
d257 1
a257 1
int
d259 1
a259 1
	char *buf;
d271 1
a271 1
void
d318 1
a318 1
void
d338 1
a338 1
void
d340 1
a340 1
	register struct ktr_syscall *ktr;
d342 2
a343 3
	register argsize = ktr->ktr_argsize;
	register register_t *ap;
	char *ioctlname();
d354 1
a354 1
				char *cp;
d393 1
d397 3
a399 3
	register int ret = ktr->ktr_retval;
	register int error = ktr->ktr_error;
	register int code = ktr->ktr_code;
d429 1
d431 2
a432 1
	char *cp;
d437 1
d440 1
d454 1
d457 1
d459 5
a463 5
	register int datalen = len - sizeof (struct ktr_genio);
	register char *dp = (char *)ktr + sizeof (struct ktr_genio);
	register char *cp;
	register int col = 0;
	register width;
d465 1
a465 1
	static screenwidth = 0;
d518 1
a518 1
void
d530 1
a530 1
void
d538 1
a538 1
void
d547 1
a547 1
void
d549 1
a549 1
	char *name;
@


1.10
log
@add processing of netbsd syscall emulation
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.9 1997/11/04 07:58:38 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.9 1997/11/04 07:58:38 deraadt Exp $";
d243 1
d257 1
d324 1
d498 1
d510 1
d518 1
d527 1
@


1.9
log
@add more emulations; problem noted by khym@@bga.com
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.8 1997/02/28 07:09:08 millert Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.8 1997/02/28 07:09:08 millert Exp $";
d79 1
d100 1
d134 1
@


1.8
log
@Only include sys/errno.h once.
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.7 1997/02/06 13:46:36 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.7 1997/02/06 13:46:36 deraadt Exp $";
d77 2
d97 2
d122 11
a132 9
	{ "native",	     syscallnames,        SYS_MAXSYSCALL },
	{ "hpux",	hpux_syscallnames,   HPUX_SYS_MAXSYSCALL },
	{ "ibcs2",     ibcs2_syscallnames,  IBCS2_SYS_MAXSYSCALL },
	{ "linux",     linux_syscallnames,  LINUX_SYS_MAXSYSCALL },
	{ "osf1",       osf1_syscallnames,   OSF1_SYS_MAXSYSCALL },
	{ "sunos",     sunos_syscallnames,  SUNOS_SYS_MAXSYSCALL },
	{ "svr4",       svr4_syscallnames,   SVR4_SYS_MAXSYSCALL },
	{ "ultrix",   ultrix_syscallnames, ULTRIX_SYS_MAXSYSCALL },
	{ NULL,			     NULL,		    NULL }
@


1.7
log
@make are of a whole number of missing system call names; interesting fix
from ghelmer@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.6 1997/01/30 08:16:45 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.6 1997/01/30 08:16:45 deraadt Exp $";
a49 1
#include <sys/errno.h>
@


1.6
log
@fix IOR/IOW/IOWR; cgd@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.5 1996/12/10 15:42:38 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.5 1996/12/10 15:42:38 deraadt Exp $";
d87 7
d104 7
@


1.5
log
@used to permit a single arg, which it ignored, now does usage(); fenner@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.4 1996/06/26 05:34:43 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.4 1996/06/26 05:34:43 deraadt Exp $";
d286 2
a288 2
		*dir++ = 'W';
	if (cmd & IOC_IN)
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: kdump.c,v 1.13 1996/05/13 21:12:25 christos Exp $";
d170 1
a170 4
	argv += optind;
	argc -= optind;

	if (argc > 1)
@


1.3
log
@native emul is now called "native"
@
text
@d1 2
d46 1
a46 1
static char *rcsid = "$NetBSD: kdump.c,v 1.13 1996/05/13 21:12:25 christos Exp $";
@


1.2
log
@Decode unknown ioctl commands to _IO{R,W,}('c',x[,y]), instead of 0xabcdef00
@
text
@d103 1
a103 1
	{ "netbsd",	     syscallnames,        SYS_MAXSYSCALL },
d132 1
a132 1
	current = &emulations[0];	/* NetBSD */
@


1.1
log
@Initial revision
@
text
@d44 1
a44 1
static char *rcsid = "$NetBSD: kdump.c,v 1.12 1995/08/31 23:18:33 jtc Exp $";
d281 19
d326 2
a327 8
				else {
					if (decimal)
						(void)printf(",%ld",
						    (long)*ap);
					else
						(void)printf(",%#lx ",
						    (long)*ap);
				}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
