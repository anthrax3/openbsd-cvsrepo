head	1.23;
access;
symbols
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.4
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.23
date	2016.10.08.02.16.43;	author guenther;	state Exp;
branches;
next	1.22;
commitid	MFxpqYD0syIKuFdZ;

1.22
date	2016.08.26.08.52.19;	author guenther;	state Exp;
branches;
next	1.21;
commitid	b584WJwE6uFMZS9t;

1.21
date	2016.06.07.06.12.37;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	3b5aikHetmWeZowP;

1.20
date	2016.06.07.01.34.39;	author tedu;	state Exp;
branches;
next	1.19;
commitid	lMax9KdM5NrRJghe;

1.19
date	2016.05.22.23.02.28;	author guenther;	state Exp;
branches;
next	1.18;
commitid	v4XUVOxCWXqDOj3S;

1.18
date	2016.03.24.05.05.42;	author guenther;	state Exp;
branches;
next	1.17;
commitid	NIOnZ8r96FhdMFWs;

1.17
date	2016.03.05.19.46.55;	author guenther;	state Exp;
branches;
next	1.16;
commitid	pZxzqYIi4aCVRcVJ;

1.16
date	2016.01.14.05.27.42;	author guenther;	state Exp;
branches;
next	1.15;
commitid	Bhcdwp3nHtW1NOl8;

1.15
date	2016.01.06.17.52.18;	author tedu;	state Exp;
branches;
next	1.14;
commitid	wHBcN8OA6cgt3SXR;

1.14
date	2015.12.25.02.11.47;	author tedu;	state Exp;
branches;
next	1.13;
commitid	fvUXpFRAgwWFb3GD;

1.13
date	2015.10.18.05.03.22;	author guenther;	state Exp;
branches;
next	1.12;
commitid	U4RUZjttP5OeHYc4;

1.12
date	2015.10.09.01.37.08;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	sbrB3Q5CNxcwZpfU;

1.11
date	2015.10.03.23.52.30;	author guenther;	state Exp;
branches;
next	1.10;
commitid	7fZFfLhcNPssv7ez;

1.10
date	2015.07.28.05.50.41;	author guenther;	state Exp;
branches;
next	1.9;
commitid	6ofl1o2NCJLJenZf;

1.9
date	2014.12.16.03.19.23;	author jsg;	state Exp;
branches;
next	1.8;
commitid	FrxNiuhxLHCLHKy4;

1.8
date	2014.12.15.01.48.54;	author guenther;	state Exp;
branches;
next	1.7;
commitid	MEBmqIQlRpTSQJN4;

1.7
date	2014.11.20.18.44.10;	author krw;	state Exp;
branches;
next	1.6;
commitid	MjmKBVr3Zxxr46JV;

1.6
date	2014.10.13.03.46.33;	author guenther;	state Exp;
branches;
next	1.5;
commitid	GfyJFt2AC6kVCsla;

1.5
date	2014.07.11.21.49.13;	author tedu;	state Exp;
branches;
next	1.4;
commitid	yJ1Hab2ywR0c9nHo;

1.4
date	2014.06.22.23.50.45;	author guenther;	state Exp;
branches;
next	1.3;
commitid	lJCKUASQl4I0n3GK;

1.3
date	2014.01.24.04.26.51;	author guenther;	state Exp;
branches;
next	1.2;

1.2
date	2013.09.09.05.10.32;	author guenther;	state Exp;
branches;
next	1.1;

1.1
date	2013.08.22.02.02.33;	author guenther;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Add ktracing of the fds returned by pipe() and socketpair()

ok deraadt@@
@
text
@/*	$OpenBSD: ktrstruct.c,v 1.22 2016/08/26 08:52:19 guenther Exp $	*/

/*-
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/event.h>
#include <sys/un.h>
#include <ufs/ufs/quota.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <err.h>
#include <limits.h>
#include <netdb.h>
#include <poll.h>
#include <signal.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <grp.h>
#include <pwd.h>
#include <unistd.h>
#include <vis.h>

#include "kdump.h"
#include "kdump_subr.h"

#define TIME_FORMAT	"%b %e %T %Y"

static void
ktrsockaddr(struct sockaddr *sa)
{
	/*
	 * TODO: Support additional address families
	 *	#include <netmpls/mpls.h>
	 *	struct sockaddr_mpls	*mpls;
	 */

	/*
	 * note: ktrstruct() has already verified that sa points to a
	 * buffer at least sizeof(struct sockaddr) bytes long and exactly
	 * sa->sa_len bytes long.
	 */
	printf("struct sockaddr { ");
	sockfamilyname(sa->sa_family);
	printf(", ");

#define check_sockaddr_len(n)					\
	if (sa_##n->s##n##_len < sizeof(struct sockaddr_##n)) {	\
		printf("invalid");				\
		break;						\
	}

	switch(sa->sa_family) {
	case AF_INET: {
		struct sockaddr_in	*sa_in;
		char addr[64];

		sa_in = (struct sockaddr_in *)sa;
		check_sockaddr_len(in);
		inet_ntop(AF_INET, &sa_in->sin_addr, addr, sizeof addr);
		printf("%s:%u", addr, ntohs(sa_in->sin_port));
		break;
	}
	case AF_INET6: {
		struct sockaddr_in6	*sa_in6;
		char addr[64];

		sa_in6 = (struct sockaddr_in6 *)sa;
		check_sockaddr_len(in6);
		inet_ntop(AF_INET6, &sa_in6->sin6_addr, addr, sizeof addr);
		printf("[%s]:%u", addr, htons(sa_in6->sin6_port));
		break;
	}
	case AF_UNIX: {
		struct sockaddr_un *sa_un;
		char path[4 * sizeof(sa_un->sun_path) + 1];
		size_t len;

		sa_un = (struct sockaddr_un *)sa;
		len = sa_un->sun_len;
		if (len <= offsetof(struct sockaddr_un, sun_path)) {
			printf("invalid");
			break;
		}
		len -= offsetof(struct sockaddr_un, sun_path);
		if (len > sizeof(sa_un->sun_path)) {
			printf("too long");
			break;
		}
		/* format, stopping at first NUL */
		len = strnlen(sa_un->sun_path, len);
		strvisx(path, sa_un->sun_path, len,
		    VIS_CSTYLE | VIS_DQ | VIS_TAB | VIS_NL);
		printf("\"%s\"", path);
		break;
	}
	default:
		printf("unknown address family");
	}
	printf(" }\n");
}

static void
print_time(time_t t, int relative, int have_subsec)
{
	char timestr[PATH_MAX + 4];
	struct tm *tm;

	if (t < 0 && have_subsec) {
		/* negative times with non-zero subsecs require care */
		printf("-%jd", -(intmax_t)(t + 1));
	} else
		printf("%jd", (intmax_t)t);

	/* 1970s times are probably relative */
	if (!relative && t > (10 * 365 * 24 * 3600)) {
		tm = localtime(&t);
		if (tm != NULL) {
			(void)strftime(timestr, sizeof(timestr), TIME_FORMAT,
			    tm);
			printf("<\"%s\">", timestr);
		}
	}
}

static void
print_timespec(const struct timespec *tsp, int relative)
{
	if (tsp->tv_nsec == UTIME_NOW)
		printf("UTIME_NOW");
	else if (tsp->tv_nsec == UTIME_OMIT)
		printf("UTIME_OMIT");
	else {
		print_time(tsp->tv_sec, relative, tsp->tv_nsec);
		if (tsp->tv_nsec != 0)
			printf(".%09ld", tsp->tv_sec >= 0 ? tsp->tv_nsec :
			    1000000000 - tsp->tv_nsec);
	}
}

void
uidname(int uid)
{
	const char *name;

	if (uid == -1)
		printf("-1");
	else {
		printf("%u<", (unsigned)uid);
		if (uid > UID_MAX || (name = user_from_uid(uid, 1)) == NULL)
			printf("unknown>");
		else
			printf("\"%s\">", name);
	}
}

void
gidname(int gid)
{
	const char *name;

	if (gid == -1)
		printf("-1");
	else {
		printf("%u<", (unsigned)gid);
		if (gid > GID_MAX || (name = group_from_gid(gid, 1)) == NULL)
			printf("unknown>");
		else
			printf("\"%s\">", name);
	}
}

static void
ktrstat(const struct stat *statp)
{
	char mode[12];

	/*
	 * note: ktrstruct() has already verified that statp points to a
	 * buffer exactly sizeof(struct stat) bytes long.
	 */
	printf("struct stat { ");
	strmode(statp->st_mode, mode);
	printf("dev=%d, ino=%llu, mode=%s, nlink=%u, uid=",
	    statp->st_dev, (unsigned long long)statp->st_ino,
	    mode, statp->st_nlink);
	uidname(statp->st_uid);
	printf(", gid=");
	gidname(statp->st_gid);
	printf(", rdev=%d, ", statp->st_rdev);
	printf("atime=");
	print_timespec(&statp->st_atim, 0);
	printf(", mtime=");
	print_timespec(&statp->st_mtim, 0);
	printf(", ctime=");
	print_timespec(&statp->st_ctim, 0);
	printf(", size=%lld, blocks=%lld, blksize=%d, flags=0x%x, gen=0x%x",
	    statp->st_size, statp->st_blocks, statp->st_blksize,
	    statp->st_flags, statp->st_gen);
	printf(" }\n");
}

static void
ktrtimespec(const struct timespec *tsp, int relative)
{
	printf("struct timespec { ");
	print_timespec(tsp, relative);
	printf(" }\n");
}

static void
print_timeval(const struct timeval *tvp, int relative)
{
	print_time(tvp->tv_sec, relative, tvp->tv_usec);
	if (tvp->tv_usec != 0)
		printf(".%06ld", tvp->tv_sec >= 0 ? tvp->tv_usec :
		    1000000 - tvp->tv_usec);
}

static void
ktrtimeval(const struct timeval *tvp, int relative)
{
	printf("struct timeval { ");
	print_timeval(tvp, relative);
	printf(" }\n");
}

static void
ktrsigaction(const struct sigaction *sa)
{
	/*
	 * note: ktrstruct() has already verified that sa points to a
	 * buffer exactly sizeof(struct sigaction) bytes long.
	 */
	/*
	 * Fuck!  Comparison of function pointers on hppa assumes you can
	 * dereference them if they're plabels!  Cast everything to void *
	 * to suppress that extra logic; sorry folks, the address we report
	 * here might not match what you see in your executable...
	 */
	printf("struct sigaction { ");
	if ((void *)sa->sa_handler == (void *)SIG_DFL)
		printf("handler=SIG_DFL");
	else if ((void *)sa->sa_handler == (void *)SIG_IGN)
		printf("handler=SIG_IGN");
	else if (sa->sa_flags & SA_SIGINFO)
		printf("sigaction=%p", (void *)sa->sa_sigaction);
	else
		printf("handler=%p", (void *)sa->sa_handler);
	printf(", mask=");
	sigset(sa->sa_mask);
	printf(", flags=");
	sigactionflagname(sa->sa_flags);
	printf(" }\n");
}

static void
print_rlim(rlim_t lim)
{
	if (lim == RLIM_INFINITY)
		printf("infinite");
	else
		printf("%llu", (unsigned long long)lim);
}

static void
ktrrlimit(const struct rlimit *limp)
{
	printf("struct rlimit { ");
	printf("cur=");
	print_rlim(limp->rlim_cur);
	printf(", max=");
	print_rlim(limp->rlim_max);
	printf(" }\n");
}

static void
ktrtfork(const struct __tfork *tf)
{
	printf("struct __tfork { tcb=%p, tid=%p, stack=%p }\n",
	    tf->tf_tcb, (void *)tf->tf_tid, tf->tf_stack);
}

static void
ktrfds(const char *data, size_t count)
{
	size_t i;
	int fd;

	for (i = 0; i < count - 1; i++) {
		memcpy(&fd, &data[i * sizeof(fd)], sizeof(fd));
		printf("fd[%zu] = %d, ", i, fd);
	}
	memcpy(&fd, &data[i * sizeof(fd)], sizeof(fd));
	printf("fd[%zu] = %d\n", i, fd);
}

static void
ktrfdset(struct fd_set *fds, int len)
{
	int nfds, i, start = -1;
	char sep = ' ';

	nfds = len * NBBY;
	printf("struct fd_set {");
	for (i = 0; i <= nfds; i++)
		if (i != nfds && FD_ISSET(i, fds)) {
			if (start == -1)
				start = i;
		} else if (start != -1) {
			putchar(sep);
			if (start == i - 1)
				printf("%d", start);
			else if (start == i - 2)
				printf("%d,%d", start, i - 1);
			else
				printf("%d-%d", start, i - 1);
			sep = ',';
			start = -1;
		}

	printf(" }\n");
}

static void
ktrrusage(const struct rusage *rup)
{
	printf("struct rusage { utime=");
	print_timeval(&rup->ru_utime, 1);
	printf(", stime=");
	print_timeval(&rup->ru_stime, 1);
	printf(", maxrss=%ld, ixrss=%ld, idrss=%ld, isrss=%ld,"
	    " minflt=%ld, majflt=%ld, nswap=%ld, inblock=%ld,"
	    " oublock=%ld, msgsnd=%ld, msgrcv=%ld, nsignals=%ld,"
	    " nvcsw=%ld, nivcsw=%ld }\n",
	    rup->ru_maxrss, rup->ru_ixrss, rup->ru_idrss, rup->ru_isrss,
	    rup->ru_minflt, rup->ru_majflt, rup->ru_nswap, rup->ru_inblock,
	    rup->ru_oublock, rup->ru_msgsnd, rup->ru_msgrcv, rup->ru_nsignals,
	    rup->ru_nvcsw, rup->ru_nivcsw);
}

static void
ktrquota(const struct dqblk *quota)
{
	printf("struct dqblk { bhardlimit=%u, bsoftlimit=%u, curblocks=%u,"
	    " ihardlimit=%u, isoftlimit=%u, curinodes=%u, btime=",
	    quota->dqb_bhardlimit, quota->dqb_bsoftlimit,
	    quota->dqb_curblocks, quota->dqb_ihardlimit,
	    quota->dqb_isoftlimit, quota->dqb_curinodes);
	print_time(quota->dqb_btime, 0, 0);
	printf(", itime=");
	print_time(quota->dqb_itime, 0, 0);
	printf(" }\n");
}

static void
ktrmsghdr(const struct msghdr *msg)
{
	printf("struct msghdr { name=%p, namelen=%u, iov=%p, iovlen=%u,"
	    " control=%p, controllen=%u, flags=",
	    msg->msg_name, msg->msg_namelen, msg->msg_iov, msg->msg_iovlen,
	    msg->msg_control, msg->msg_controllen);
	sendrecvflagsname(msg->msg_flags);
	printf(" }\n");
}

static void
ktriovec(const char *data, int count)
{
	struct iovec iov;
	int i;

	printf("struct iovec");
	if (count > 1)
		printf(" [%d]", count);
	for (i = 0; i < count; i++) {
		memcpy(&iov, data, sizeof(iov));
		data += sizeof(iov);
		printf(" { base=%p, len=%lu }", iov.iov_base, iov.iov_len);
	}
	printf("\n");
}

static void
ktrevent(const char *data, int count)
{
	struct kevent kev;
	int i;

	printf("struct kevent");
	if (count > 1)
		printf(" [%d]", count);
	for (i = 0; i < count; i++) {
		memcpy(&kev, data, sizeof(kev));
		data += sizeof(kev);
		printf(" { ident=%lu, filter=", kev.ident);
		evfiltername(kev.filter);
		printf(", flags=");
		evflagsname(kev.flags);
		printf(", fflags=");
		evfflagsname(kev.filter, kev.fflags);
		printf(", data=%llu", kev.data);
		if ((kev.flags & EV_ERROR) && fancy) {
			printf("<\"%s\">", strerror(kev.data));
		}
		printf(", udata=%p }", kev.udata);
	}
	printf("\n");
}

static void
ktrpollfd(const char *data, int count)
{
	struct pollfd pfd;
	int i;

	printf("struct pollfd");
	if (count > 1)
		printf(" [%d]", count);
	for (i = 0; i < count; i++) {
		memcpy(&pfd, data, sizeof(pfd));
		data += sizeof(pfd);
		printf(" { fd=%d, events=", pfd.fd);
		pollfdeventname(pfd.events);
		printf(", revents=");
		pollfdeventname(pfd.revents);
		printf(" }");
	}
	printf("\n");
}

static void
ktrcmsghdr(char *data, socklen_t len)
{
	struct msghdr msg;
	struct cmsghdr *cmsg;
	int i, count, *fds;

	msg.msg_control = data;
	msg.msg_controllen = len;

	/* count the control messages */
	count = 0;
	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;
	     cmsg = CMSG_NXTHDR(&msg, cmsg)) {
		count++;
	}

	printf("struct cmsghdr");
	if (count > 1)
		printf(" [%d]", count);

	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;
	     cmsg = CMSG_NXTHDR(&msg, cmsg)) {
		printf(" { len=%u, level=", cmsg->cmsg_len);
		if (cmsg->cmsg_level == SOL_SOCKET) {
			printf("SOL_SOCKET, type=");
			switch (cmsg->cmsg_type) {
			case SCM_RIGHTS:
				printf("SCM_RIGHTS, data=");
				fds = (int *)CMSG_DATA(cmsg);
				for (i = 0;
				    cmsg->cmsg_len > CMSG_LEN(sizeof(int) * i);
				    i++) {
					printf("%s%d", i ? "," : "", fds[i]);
				}
				break;
			case SCM_TIMESTAMP:
			default:
				printf("%d", cmsg->cmsg_type);
				break;
			}
		} else {
			struct protoent *p = getprotobynumber(cmsg->cmsg_level);

			printf("%u<%s>, type=%d", cmsg->cmsg_level,
			    p != NULL ? p->p_name : "unknown", cmsg->cmsg_type);
		}
		printf(" }");
	}
	printf("\n");
}

void
ktrstruct(char *buf, size_t buflen)
{
	char *name, *data;
	size_t namelen, datalen;
	int i;

	for (name = buf, namelen = 0; namelen < buflen && name[namelen] != '\0';
	     ++namelen)
		/* nothing */;
	if (namelen == buflen)
		goto invalid;
	if (name[namelen] != '\0')
		goto invalid;
	data = buf + namelen + 1;
	datalen = buflen - namelen - 1;
	if (datalen == 0)
		goto invalid;
	/* sanity check */
	for (i = 0; i < namelen; ++i)
		if (!isalpha((unsigned char)name[i]))
			goto invalid;
	if (strcmp(name, "stat") == 0) {
		struct stat sb;

		if (datalen != sizeof(struct stat))
			goto invalid;
		memcpy(&sb, data, datalen);
		ktrstat(&sb);
	} else if (strcmp(name, "sockaddr") == 0) {
		struct sockaddr_storage ss;

		if (datalen > sizeof(ss))
			goto invalid;
		memcpy(&ss, data, datalen);
		if ((ss.ss_family != AF_UNIX && 
		    datalen < sizeof(struct sockaddr)) || datalen != ss.ss_len)
			goto invalid;
		ktrsockaddr((struct sockaddr *)&ss);
	} else if (strcmp(name, "abstimespec") == 0 ||
	    strcmp(name, "reltimespec") == 0) {
		struct timespec ts;

		if (datalen != sizeof(ts))
			goto invalid;
		memcpy(&ts, data, datalen);
		ktrtimespec(&ts, name[0] == 'r');
	} else if (strcmp(name, "abstimeval") == 0 ||
	    strcmp(name, "reltimeval") == 0) {
		struct timeval tv;

		if (datalen != sizeof(tv))
			goto invalid;
		memcpy(&tv, data, datalen);
		ktrtimeval(&tv, name[0] == 'r');
	} else if (strcmp(name, "sigaction") == 0) {
		struct sigaction sa;

		if (datalen != sizeof(sa))
			goto invalid;
		memcpy(&sa, data, datalen);
		ktrsigaction(&sa);
	} else if (strcmp(name, "rlimit") == 0) {
		struct rlimit lim;

		if (datalen != sizeof(lim))
			goto invalid;
		memcpy(&lim, data, datalen);
		ktrrlimit(&lim);
	} else if (strcmp(name, "rusage") == 0) {
		struct rusage ru;

		if (datalen != sizeof(ru))
			goto invalid;
		memcpy(&ru, data, datalen);
		ktrrusage(&ru);
	} else if (strcmp(name, "tfork") == 0) {
		struct __tfork tf;

		if (datalen != sizeof(tf))
			goto invalid;
		memcpy(&tf, data, datalen);
		ktrtfork(&tf);
	} else if (strcmp(name, "fds") == 0) {
		if (datalen % sizeof(int))
			goto invalid;
		ktrfds(data, datalen / sizeof(int));
	} else if (strcmp(name, "fdset") == 0) {
		struct fd_set *fds;

		if ((fds = malloc(datalen)) == NULL)
			err(1, "malloc");
		memcpy(fds, data, datalen);
		ktrfdset(fds, datalen);
		free(fds);
	} else if (strcmp(name, "quota") == 0) {
		struct dqblk quota;

		if (datalen != sizeof(quota))
			goto invalid;
		memcpy(&quota, data, datalen);
		ktrquota(&quota);
	} else if (strcmp(name, "msghdr") == 0) {
		struct msghdr msg;

		if (datalen != sizeof(msg))
			goto invalid;
		memcpy(&msg, data, datalen);
		ktrmsghdr(&msg);
	} else if (strcmp(name, "iovec") == 0) {
		if (datalen % sizeof(struct iovec))
			goto invalid;
		ktriovec(data, datalen / sizeof(struct iovec));
	} else if (strcmp(name, "kevent") == 0) {
		if (datalen % sizeof(struct kevent))
			goto invalid;
		ktrevent(data, datalen / sizeof(struct kevent));
	} else if (strcmp(name, "pollfd") == 0) {
		if (datalen % sizeof(struct pollfd))
			goto invalid;
		ktrpollfd(data, datalen / sizeof(struct pollfd));
	} else if (strcmp(name, "cmsghdr") == 0) {
		char *cmsg;

		if ((cmsg = malloc(datalen)) == NULL)
			err(1, "malloc");
		memcpy(cmsg, data, datalen);
		ktrcmsghdr(cmsg, datalen);
		free(cmsg);
	} else if (strcmp(name, "pledgereq") == 0) {
		printf("pledge request=");
		showbufc(basecol + sizeof("pledge request=") - 1,
		    (unsigned char *)data, datalen, VIS_DQ | VIS_TAB | VIS_NL);
	} else if (strcmp(name, "pledgepath") == 0) {
		printf("pledge path=");
		showbufc(basecol + sizeof("pledge path=") - 1,
		    (unsigned char *)data, datalen, VIS_DQ | VIS_TAB | VIS_NL);
	} else {
		printf("unknown structure %s\n", name);
	}
	return;
invalid:
	printf("invalid record\n");
}
@


1.22
log
@Pull in <sys/select.h> for fd_set

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.21 2016/06/07 06:12:37 deraadt Exp $	*/
d321 14
d603 4
@


1.21
log
@ktrace support for pollfd[] arrays
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.20 2016/06/07 01:34:39 tedu Exp $	*/
d35 1
@


1.20
log
@add a hack to avoid printing the long string format for times in the 70s.
this is usually a result of a timestamp which hasn't been identified as
"relative" and decoding them to precise dates long in the past is a
distraction. (eagerly awaiting a cleaner, better diff to do the same.)
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.19 2016/05/22 23:02:28 guenther Exp $	*/
d433 21
d618 4
@


1.19
log
@On hppa, function pointer comparison can require dereferencing them.
kdump can't do that for a sigaction sa_handler pointer from the trace,
so cast to void* to suppress it.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.18 2016/03/24 05:05:42 guenther Exp $	*/
d150 2
a151 1
	if (!relative) {
@


1.18
log
@Display NAMI records and AF_UNIX socket paths with vis, using
VIS_CSTYLE | VIS_DQ | VIS_TAB | VIS_NL; add the latter three flags
to the existing vis encoding of exec argv/environ and pledge
requests/paths.
Delete local variables left unused when showbuf() and showbufc() were split

ok otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.17 2016/03/05 19:46:55 guenther Exp $	*/
d269 6
d276 1
a276 1
	if (sa->sa_handler == SIG_DFL)
d278 1
a278 1
	else if (sa->sa_handler == SIG_IGN)
@


1.17
log
@Make the fd_set* passed to FD_ISSET() non-const: the non-macro version is
stricter (per POSIX, dang it)
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.16 2016/01/14 05:27:42 guenther Exp $	*/
d57 1
d67 5
a71 6
/*
 TODO: Support additional address families
	#include <netmpls/mpls.h>
	struct sockaddr_mpls	*mpls;
*/
	char addr[64];
d91 1
d101 1
a108 11
#ifdef IPX
	case AF_IPX: {
		struct sockaddr_ipx	*sa_ipx;

		sa_ipx = (struct sockaddr_ipx *)sa;
		check_sockaddr_len(ipx);
		/* XXX wish we had ipx_ntop */
		printf("%s", ipx_ntoa(sa_ipx->sipx_addr));
		break;
	}
#endif
d111 2
d115 2
a116 1
		if (sa_un->sun_len <= offsetof(struct sockaddr_un, sun_path)) {
d120 10
a129 3
		printf("\"%.*s\"", (int)(sa_un->sun_len -
		    offsetof(struct sockaddr_un, sun_path)),
		    sa_un->sun_path);
d601 1
a601 1
		    (unsigned char *)data, datalen);
d605 1
a605 1
		    (unsigned char *)data, datalen);
@


1.16
log
@Display struct event more like other structs: show all members and use cpp
define names.  Use the mksubr infrastructure for EVFILT_*,
EV_*, and (with some kludging) NOTE_* values.  If EV_ERROR is set,
include the errno string for the data member.

Also, do MSG_* parsing on the msg_flags member of struct msghdr.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.15 2016/01/06 17:52:18 tedu Exp $	*/
d312 1
a312 1
ktrfdset(const struct fd_set *fds, int len)
@


1.15
log
@print more info about kevent
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.14 2015/12/25 02:11:47 tedu Exp $	*/
d373 1
a373 1
	    " control=%p, controllen=%u, flags=%d }\n",
d375 3
a377 1
	    msg->msg_control, msg->msg_controllen, msg->msg_flags);
a406 3
		char flags[100];
		const char *filter = "";
		const char *comma = "";
d409 9
a417 19
		switch (kev.filter) {
		case EVFILT_READ:
			filter = "read";
			break;
		case EVFILT_WRITE:
			filter = "write";
			break;
		case EVFILT_VNODE:
			filter = "vnode";
			break;
		case EVFILT_PROC:
			filter = "proc";
			break;
		case EVFILT_SIGNAL:
			filter = "signal";
			break;
		case EVFILT_TIMER:
			filter = "timer";
			break;
d419 1
a419 17
#define KEV_FLAG(value, name) \
	do if (kev.flags & value) { \
		strlcat(flags, comma, sizeof(flags)); \
		strlcat(flags, name, sizeof(flags)); \
		comma = ","; \
	} while (0)

		KEV_FLAG(EV_ADD, "add");
		KEV_FLAG(EV_ENABLE, "enable");
		KEV_FLAG(EV_DISABLE, "disable");
		KEV_FLAG(EV_DELETE, "delete");
		KEV_FLAG(EV_ONESHOT, "oneshot");
		KEV_FLAG(EV_CLEAR, "clear");
		KEV_FLAG(EV_EOF, "EOF");
		KEV_FLAG(EV_ERROR, "error");

		printf(" { filter=%s flags=%s ident=%lu }", filter, flags, kev.ident);
@


1.14
log
@very basic kevent printing
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.13 2015/10/18 05:03:22 guenther Exp $	*/
d405 3
d410 37
a446 1
		printf(" { ident=%lu }", kev.ident);
@


1.13
log
@Use offsetof() instead of adding the sizes of the preceeding struct members

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.12 2015/10/09 01:37:08 deraadt Exp $	*/
d37 1
d396 17
d573 4
@


1.12
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.11 2015/10/03 23:52:30 guenther Exp $	*/
d48 1
d121 1
a121 2
		if (sa_un->sun_len <= sizeof(sa_un->sun_len) +
		    sizeof(sa_un->sun_family)) {
d126 1
a126 1
		    sizeof(sa_un->sun_len) - sizeof(sa_un->sun_family)),
@


1.11
log
@Add ktracing of tame()'s arguments' values

"every tool helps" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.10 2015/07/28 05:50:41 guenther Exp $	*/
d563 3
a565 3
	} else if (strcmp(name, "tamereq") == 0) {
		printf("tame request=");
		showbufc(basecol + sizeof("tame request=") - 1,
d567 3
a569 3
	} else if (strcmp(name, "tamepath") == 0) {
		printf("tame path=");
		showbufc(basecol + sizeof("tame path=") - 1,
@


1.10
log
@Add ktracing of structs iovec, msghdr, and cmsghdr for {,p}{read,write}v(),
sendmsg(), and recvmsg().  For cmsghdr, the len, level, and type are always
shown, and for SOL_SOCKET,SCM_RIGHTS the fd numbers being passed are shown.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.9 2014/12/16 03:19:23 jsg Exp $	*/
d563 8
@


1.9
log
@Don't display formatted time if localtime() fails.
Avoids a crash in strftime() found with the afl fuzzer.
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.8 2014/12/15 01:48:54 guenther Exp $	*/
d45 1
d368 78
d531 1
d544 19
@


1.8
log
@Eliminate the -r option and always do sysctl OID, username, groupname,
and ctime presentation, but combined with the numeric form ala 0<"root">.
Do username and groupname presentation on syscall arguments and retvals.

ok millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.7 2014/11/20 18:44:10 krw Exp $	*/
d149 5
a153 2
		(void)strftime(timestr, sizeof(timestr), TIME_FORMAT, tm);
		printf("<\"%s\">", timestr);
@


1.7
log
@Be more POSIXy by using blksize_t (a.k.a. int32) for st_blksize, rather than the current uint32_t.

ok guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.6 2014/10/13 03:46:33 guenther Exp $	*/
d136 1
a136 1
print_time(time_t t, int relative)
d141 4
a144 1
	if (resolv == 0 || relative)
d146 2
a147 1
	else {
d150 1
a150 1
		printf("\"%s\"", timestr);
d161 2
a162 7
	else if ((resolv == 0 || relative) && tsp->tv_sec < 0 &&
	    tsp->tv_nsec > 0) {
		/* negative relative times with non-zero nsecs require care */
		printf("-%jd.%09ld", -(intmax_t)(tsp->tv_sec+1),
		    1000000000 - tsp->tv_nsec);
	} else {
		print_time(tsp->tv_sec, relative);
d164 34
a197 1
			printf(".%09ld", tsp->tv_nsec);
a204 2
	struct passwd *pwd;
	struct group  *grp;
d212 1
a212 1
	printf("dev=%d, ino=%llu, mode=%s, nlink=%u, ",
d215 4
a218 9
	if (resolv == 0 || (pwd = getpwuid(statp->st_uid)) == NULL)
		printf("uid=%u, ", statp->st_uid);
	else
		printf("uid=\"%s\", ", pwd->pw_name);
	if (resolv == 0 || (grp = getgrgid(statp->st_gid)) == NULL)
		printf("gid=%u, ", statp->st_gid);
	else
		printf("gid=\"%s\", ", grp->gr_name);
	printf("rdev=%d, ", statp->st_rdev);
d242 3
a244 4
	if ((resolv == 0 || relative) && tvp->tv_sec < 0 &&
	    tvp->tv_usec > 0) {
		/* negative relative times with non-zero usecs require care */
		printf("-%jd.%06ld", -(intmax_t)(tvp->tv_sec+1),
a245 5
	} else {
		print_time(tvp->tv_sec, relative);
		if (tvp->tv_usec != 0)
			printf(".%06ld", tvp->tv_usec);
	}
d358 1
a358 1
	print_time(quota->dqb_btime, 0);
d360 1
a360 1
	print_time(quota->dqb_itime, 0);
@


1.6
log
@Add dumping of struct dqblk done by quotactl(2)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.5 2014/07/11 21:49:13 tedu Exp $	*/
d200 1
a200 1
	printf(", size=%lld, blocks=%lld, blksize=%u, flags=0x%x, gen=0x%x",
@


1.5
log
@remove (commented) bluetooth reference
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.4 2014/06/22 23:50:45 guenther Exp $	*/
d38 1
d331 14
d435 7
@


1.4
log
@Negative time{spec,val}s with non-zero subsecond parts require extra
handling. E.g., a timeval of { -1, 1 } is -0.999999, as the subsecond
part is always positive.

Also, update the list of sockaddr_* types that we might add support for
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.3 2014/01/24 04:26:51 guenther Exp $	*/
a65 2
	#include <netbt/bluetooth.h>
	struct sockaddr_bt	*bt;
@


1.3
log
@exit1() needs to do a final aggregation of the thread's [us]ticks
and runtime to the process totals.  Also, add ktracing of struct
rusage in wait4() and getrusage().

problem pointed out by tedu@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.2 2013/09/09 05:10:32 guenther Exp $	*/
d64 4
a67 4
	#include <netnatm/natm.h>
	struct sockaddr_natm	*natm;
	#include <netsmb/netbios.h>
	struct sockaddr_nb	*nb;
d158 6
a163 1
	else {
d218 10
a227 3
	print_time(tvp->tv_sec, relative);
	if (tvp->tv_usec != 0)
		printf(".%06ld", tvp->tv_usec);
@


1.2
log
@Recognize the UTIME_OMIT and UTIME_NOW values when printing timespecs

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrstruct.c,v 1.1 2013/08/22 02:02:33 guenther Exp $	*/
d211 1
a211 1
ktrtimeval(const struct timeval *tvp, int relative)
a212 1
	printf("struct timeval { ");
d216 7
d303 17
d389 7
@


1.1
log
@Split out from kdump.c the ktrstruct.c bits into ktrstruct.c
Reduce the #includes to take advantage of that.

ok millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kdump.c,v 1.83 2013/07/03 23:04:33 guenther Exp $	*/
d154 9
a162 3
	print_time(tsp->tv_sec, relative);
	if (tsp->tv_nsec != 0)
		printf(".%09ld", tsp->tv_nsec);
@

