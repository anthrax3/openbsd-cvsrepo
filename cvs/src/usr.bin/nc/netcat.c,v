head	1.181;
access;
symbols
	OPENBSD_6_1:1.178.0.4
	OPENBSD_6_1_BASE:1.178
	OPENBSD_6_0:1.160.0.2
	OPENBSD_6_0_BASE:1.160
	OPENBSD_5_9:1.150.0.2
	OPENBSD_5_9_BASE:1.150
	OPENBSD_5_8:1.130.0.4
	OPENBSD_5_8_BASE:1.130
	OPENBSD_5_7:1.127.0.2
	OPENBSD_5_7_BASE:1.127
	OPENBSD_5_6:1.122.0.4
	OPENBSD_5_6_BASE:1.122
	OPENBSD_5_5:1.117.0.4
	OPENBSD_5_5_BASE:1.117
	OPENBSD_5_4:1.112.0.2
	OPENBSD_5_4_BASE:1.112
	OPENBSD_5_3:1.109.0.4
	OPENBSD_5_3_BASE:1.109
	OPENBSD_5_2:1.109.0.2
	OPENBSD_5_2_BASE:1.109
	OPENBSD_5_1_BASE:1.105
	OPENBSD_5_1:1.105.0.2
	OPENBSD_5_0:1.101.0.2
	OPENBSD_5_0_BASE:1.101
	OPENBSD_4_9:1.100.0.2
	OPENBSD_4_9_BASE:1.100
	OPENBSD_4_8:1.98.0.2
	OPENBSD_4_8_BASE:1.98
	OPENBSD_4_7:1.95.0.2
	OPENBSD_4_7_BASE:1.95
	OPENBSD_4_6:1.93.0.4
	OPENBSD_4_6_BASE:1.93
	OPENBSD_4_5:1.92.0.2
	OPENBSD_4_5_BASE:1.92
	OPENBSD_4_4:1.91.0.2
	OPENBSD_4_4_BASE:1.91
	OPENBSD_4_3:1.89.0.6
	OPENBSD_4_3_BASE:1.89
	OPENBSD_4_2:1.89.0.4
	OPENBSD_4_2_BASE:1.89
	OPENBSD_4_1:1.89.0.2
	OPENBSD_4_1_BASE:1.89
	OPENBSD_4_0:1.88.0.2
	OPENBSD_4_0_BASE:1.88
	OPENBSD_3_9:1.87.0.2
	OPENBSD_3_9_BASE:1.87
	OPENBSD_3_8:1.82.0.2
	OPENBSD_3_8_BASE:1.82
	OPENBSD_3_7:1.77.0.2
	OPENBSD_3_7_BASE:1.77
	OPENBSD_3_6:1.73.0.2
	OPENBSD_3_6_BASE:1.73
	OPENBSD_3_5:1.72.0.2
	OPENBSD_3_5_BASE:1.72
	OPENBSD_3_4:1.62.0.2
	OPENBSD_3_4_BASE:1.62
	OPENBSD_3_3:1.57.0.2
	OPENBSD_3_3_BASE:1.57
	OPENBSD_3_2:1.52.0.2
	OPENBSD_3_2_BASE:1.52
	OPENBSD_3_1:1.47.0.2
	OPENBSD_3_1_BASE:1.47
	OPENBSD_3_0:1.37.0.2
	OPENBSD_3_0_BASE:1.37
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.181
date	2017.04.16.15.11.01;	author deraadt;	state Exp;
branches;
next	1.180;
commitid	dWYjd14je5VwWW1P;

1.180
date	2017.04.05.06.55.59;	author jmc;	state Exp;
branches;
next	1.179;
commitid	ANcbTEXIr1rTVTTb;

1.179
date	2017.04.05.03.20.19;	author beck;	state Exp;
branches;
next	1.178;
commitid	RxtwJNn3R4j2CuAQ;

1.178
date	2017.03.09.13.58.00;	author bluhm;	state Exp;
branches;
next	1.177;
commitid	eozi4PzS80BnMOCr;

1.177
date	2017.02.09.22.55.45;	author bluhm;	state Exp;
branches;
next	1.176;
commitid	Gl61d41IFX8KU7Du;

1.176
date	2017.02.09.20.14.41;	author jca;	state Exp;
branches;
next	1.175;
commitid	p2nLlTbE2XsmDKiK;

1.175
date	2017.02.08.18.44.50;	author bluhm;	state Exp;
branches;
next	1.174;
commitid	htHnHrO9pmEYoa42;

1.174
date	2017.02.08.18.03.31;	author bluhm;	state Exp;
branches;
next	1.173;
commitid	XSXJcoAzu0WPAObp;

1.173
date	2017.02.08.13.43.33;	author bluhm;	state Exp;
branches;
next	1.172;
commitid	hTbqL7OZl5qOy6je;

1.172
date	2017.02.05.01.39.14;	author jca;	state Exp;
branches;
next	1.171;
commitid	C5UBzSIFG8LoFHVV;

1.171
date	2016.11.30.07.56.23;	author mestre;	state Exp;
branches;
next	1.170;
commitid	e9mstvc6pnVOJPmc;

1.170
date	2016.11.06.13.33.30;	author beck;	state Exp;
branches;
next	1.169;
commitid	3EUIUe7Tlmi6GoV1;

1.169
date	2016.11.05.16.03.09;	author jmc;	state Exp;
branches;
next	1.168;
commitid	pbxzEoh2L7WSIixj;

1.168
date	2016.11.05.15.13.26;	author beck;	state Exp;
branches;
next	1.167;
commitid	3VJnu6rXiOGWa3uh;

1.167
date	2016.11.04.05.13.13;	author beck;	state Exp;
branches;
next	1.166;
commitid	vHqLGL1n0DAh4s4y;

1.166
date	2016.11.03.15.54.39;	author beck;	state Exp;
branches;
next	1.165;
commitid	fcNCZJn2K1SPSTIX;

1.165
date	2016.11.03.15.52.10;	author beck;	state Exp;
branches;
next	1.164;
commitid	MHLY2ePQY9Bzhr1G;

1.164
date	2016.11.02.15.18.42;	author beck;	state Exp;
branches;
next	1.163;
commitid	OsrmWrsuHXqdXb2Z;

1.163
date	2016.09.03.17.35.34;	author bcook;	state Exp;
branches;
next	1.162;
commitid	jNcGyS3d6TY6WNx5;

1.162
date	2016.08.13.13.09.10;	author jsing;	state Exp;
branches;
next	1.161;
commitid	ebSRyq9QurZWZVWu;

1.161
date	2016.07.30.22.04.04;	author halex;	state Exp;
branches;
next	1.160;
commitid	xpaT1jrBmVZLfL4K;

1.160
date	2016.07.13.16.35.47;	author jsing;	state Exp;
branches;
next	1.159;
commitid	02rKn2WBJ6A1ygkh;

1.159
date	2016.07.07.14.09.44;	author jsing;	state Exp;
branches;
next	1.158;
commitid	oUnlhkhH6vqqvflj;

1.158
date	2016.07.06.16.31.18;	author jsing;	state Exp;
branches;
next	1.157;
commitid	EWSJKc0M8XiiOM6q;

1.157
date	2016.07.01.00.29.14;	author bcook;	state Exp;
branches;
next	1.156;
commitid	a4h41kwkKAfPlXI7;

1.156
date	2016.06.28.17.35.14;	author jca;	state Exp;
branches;
next	1.155;
commitid	UhqCIXE0XUOGTjxt;

1.155
date	2016.06.28.00.01.10;	author deraadt;	state Exp;
branches;
next	1.154;
commitid	540rNgk8PYmELtCl;

1.154
date	2016.06.27.23.58.08;	author deraadt;	state Exp;
branches;
next	1.153;
commitid	mR5hbOKu77sHH0P3;

1.153
date	2016.06.02.04.26.32;	author beck;	state Exp;
branches;
next	1.152;
commitid	8rVNkIzHg9DBcRmu;

1.152
date	2016.05.28.20.14.58;	author beck;	state Exp;
branches;
next	1.151;
commitid	TQxJYXfH7Qq8vQ83;

1.151
date	2016.05.28.19.39.16;	author beck;	state Exp;
branches;
next	1.150;
commitid	BCgkIvnCNUPDdpV0;

1.150
date	2016.01.04.02.18.31;	author bcook;	state Exp;
branches;
next	1.149;
commitid	cb2B98VDPSTgMkSY;

1.149
date	2015.12.28.14.17.47;	author bcook;	state Exp;
branches;
next	1.148;
commitid	ktmYFJdV1CsGJHVQ;

1.148
date	2015.12.17.19.30.28;	author mmcc;	state Exp;
branches;
next	1.147;
commitid	cX42dcn2TE4GeCFj;

1.147
date	2015.12.16.14.23.33;	author beck;	state Exp;
branches;
next	1.146;
commitid	k3kUzB0bnBmWA7yX;

1.146
date	2015.12.08.15.33.33;	author beck;	state Exp;
branches;
next	1.145;
commitid	2ybON5Na11uyoKPA;

1.145
date	2015.12.07.02.38.54;	author tb;	state Exp;
branches;
next	1.144;
commitid	uf5AVw7ff2Fcwe1p;

1.144
date	2015.11.23.01.23.56;	author bcook;	state Exp;
branches;
next	1.143;
commitid	JfWvj6D0GW5MOTxH;

1.143
date	2015.11.13.18.13.13;	author deraadt;	state Exp;
branches;
next	1.142;
commitid	FWImTspviWN2u31S;

1.142
date	2015.11.12.20.33.52;	author benno;	state Exp;
branches;
next	1.141;
commitid	HKUGD7nrU6PZw6PW;

1.141
date	2015.11.01.01.05.31;	author deraadt;	state Exp;
branches;
next	1.140;
commitid	u1PHO7pvVT7Ipx3r;

1.140
date	2015.10.23.05.27.17;	author beck;	state Exp;
branches;
next	1.139;
commitid	WgLvKpH1TozZ3Tyo;

1.139
date	2015.10.11.00.26.23;	author guenther;	state Exp;
branches;
next	1.138;
commitid	EiEgif09VdYpflOP;

1.138
date	2015.09.13.11.12.09;	author beck;	state Exp;
branches;
next	1.137;
commitid	SR3U5iBE4HRjmlrB;

1.137
date	2015.09.12.21.01.14;	author beck;	state Exp;
branches;
next	1.136;
commitid	YEnr7xDEFTVxAQ5K;

1.136
date	2015.09.12.08.38.33;	author deraadt;	state Exp;
branches;
next	1.135;
commitid	RlsVvgBSoMwS6Uaj;

1.135
date	2015.09.12.07.56.56;	author jmc;	state Exp;
branches;
next	1.134;
commitid	Eq1riRw6hS7TzqLl;

1.134
date	2015.09.11.21.22.54;	author deraadt;	state Exp;
branches;
next	1.133;
commitid	SZJowPkJiR0e72XC;

1.133
date	2015.09.11.21.07.01;	author beck;	state Exp;
branches;
next	1.132;
commitid	RH0sTFSd3Jn5fmAB;

1.132
date	2015.09.08.17.28.47;	author bluhm;	state Exp;
branches;
next	1.131;
commitid	G4fpBSh7f0FXpMSW;

1.131
date	2015.09.03.23.06.28;	author sobrado;	state Exp;
branches;
next	1.130;
commitid	utECaY8VafB0sCxQ;

1.130
date	2015.07.26.19.12.28;	author chl;	state Exp;
branches;
next	1.129;
commitid	HqmnUFwlU4oB0DDl;

1.129
date	2015.03.26.21.22.50;	author tobias;	state Exp;
branches;
next	1.128;
commitid	GUQOYmHtO5q0CtPG;

1.128
date	2015.03.26.10.36.03;	author tobias;	state Exp;
branches;
next	1.127;
commitid	AfZ5XxQx9i0hKohk;

1.127
date	2015.02.14.22.40.22;	author jca;	state Exp;
branches;
next	1.126;
commitid	OGpW5Hbw6xAEthNd;

1.126
date	2014.10.30.16.08.31;	author tedu;	state Exp;
branches;
next	1.125;
commitid	vaDMm1RTxTjeztus;

1.125
date	2014.10.30.16.06.07;	author tedu;	state Exp;
branches;
next	1.124;
commitid	S5TK8DntLKmJh4bO;

1.124
date	2014.10.26.13.59.30;	author millert;	state Exp;
branches;
next	1.123;
commitid	F4DyAe7BmxT5YAtI;

1.123
date	2014.10.24.02.01.20;	author lteo;	state Exp;
branches;
next	1.122;
commitid	K0sGF4uE2LYJ8DMA;

1.122
date	2014.07.20.01.38.40;	author guenther;	state Exp;
branches;
next	1.121;
commitid	0acpjAf5myNxgwB5;

1.121
date	2014.06.10.16.35.42;	author tedu;	state Exp;
branches;
next	1.120;
commitid	C96eetUXLU1UOtEp;

1.120
date	2014.06.10.16.23.07;	author tedu;	state Exp;
branches;
next	1.119;
commitid	ke56ir2igH6chlZu;

1.119
date	2014.05.20.01.25.23;	author guenther;	state Exp;
branches;
next	1.118;

1.118
date	2014.03.12.10.19.40;	author jca;	state Exp;
branches;
next	1.117;

1.117
date	2013.10.26.21.33.29;	author sthen;	state Exp;
branches;
next	1.116;

1.116
date	2013.10.21.09.12.55;	author phessler;	state Exp;
branches;
next	1.115;

1.115
date	2013.10.21.08.59.49;	author phessler;	state Exp;
branches;
next	1.114;

1.114
date	2013.08.20.21.04.40;	author jmc;	state Exp;
branches;
next	1.113;

1.113
date	2013.08.20.16.22.09;	author djm;	state Exp;
branches;
next	1.112;

1.112
date	2013.04.29.00.28.23;	author okan;	state Exp;
branches;
next	1.111;

1.111
date	2013.03.20.09.27.56;	author sthen;	state Exp;
branches;
next	1.110;

1.110
date	2013.03.12.02.57.37;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2012.07.07.15.33.02;	author haesbaert;	state Exp;
branches;
next	1.108;

1.108
date	2012.07.07.09.36.30;	author haesbaert;	state Exp;
branches;
next	1.107;

1.107
date	2012.04.01.02.58.57;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2012.03.17.10.16.41;	author dlg;	state Exp;
branches;
next	1.105;

1.105
date	2012.02.09.06.25.35;	author lum;	state Exp;
branches;
next	1.104;

1.104
date	2012.02.09.03.27.36;	author lum;	state Exp;
branches;
next	1.103;

1.103
date	2011.10.04.08.34.34;	author fgsch;	state Exp;
branches;
next	1.102;

1.102
date	2011.09.17.14.10.05;	author haesbaert;	state Exp;
branches;
next	1.101;

1.101
date	2011.06.21.17.31.07;	author mikeb;	state Exp;
branches;
next	1.100;

1.100
date	2011.01.09.22.16.46;	author jeremy;	state Exp;
branches;
next	1.99;

1.99
date	2011.01.08.00.44.19;	author jeremy;	state Exp;
branches;
next	1.98;

1.98
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.97;

1.97
date	2010.04.20.07.28.28;	author nicm;	state Exp;
branches;
next	1.96;

1.96
date	2010.04.20.07.26.34;	author nicm;	state Exp;
branches;
next	1.95;

1.95
date	2010.02.27.00.58.56;	author nicm;	state Exp;
branches;
next	1.94;

1.94
date	2009.10.08.15.56.46;	author mpf;	state Exp;
branches;
next	1.93;

1.93
date	2009.06.05.00.18.10;	author claudio;	state Exp;
branches;
next	1.92;

1.92
date	2008.09.19.13.24.41;	author sobrado;	state Exp;
branches;
next	1.91;

1.91
date	2008.05.09.09.00.11;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2008.05.06.05.47.39;	author djm;	state Exp;
branches;
next	1.89;

1.89
date	2007.02.20.14.11.17;	author jmc;	state Exp;
branches;
next	1.88;

1.88
date	2006.06.02.03.46.38;	author ray;	state Exp;
branches;
next	1.87;

1.87
date	2006.02.01.21.33.14;	author otto;	state Exp;
branches;
next	1.86;

1.86
date	2006.01.25.23.21.37;	author djm;	state Exp;
branches;
next	1.85;

1.85
date	2006.01.20.00.01.20;	author millert;	state Exp;
branches;
next	1.84;

1.84
date	2005.10.25.06.51.37;	author dtucker;	state Exp;
branches;
next	1.83;

1.83
date	2005.10.25.03.51.06;	author dtucker;	state Exp;
branches;
next	1.82;

1.82
date	2005.07.24.09.33.56;	author marius;	state Exp;
branches;
next	1.81;

1.81
date	2005.05.28.16.57.48;	author marius;	state Exp;
branches;
next	1.80;

1.80
date	2005.05.27.04.55.28;	author mcbride;	state Exp;
branches;
next	1.79;

1.79
date	2005.05.24.20.13.28;	author avsm;	state Exp;
branches;
next	1.78;

1.78
date	2005.04.10.19.43.34;	author otto;	state Exp;
branches;
next	1.77;

1.77
date	2005.02.08.15.26.23;	author otto;	state Exp;
branches;
next	1.76;

1.76
date	2004.12.10.16.51.31;	author hshoexer;	state Exp;
branches;
next	1.75;

1.75
date	2004.10.17.03.13.55;	author djm;	state Exp;
branches;
next	1.74;

1.74
date	2004.09.15.18.44.45;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2004.07.15.15.07.52;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2004.03.12.10.10.00;	author jmc;	state Exp;
branches;
next	1.71;

1.71
date	2004.03.07.07.55.55;	author mcbride;	state Exp;
branches;
next	1.70;

1.70
date	2004.03.03.06.50.13;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2004.03.03.06.45.54;	author tedu;	state Exp;
branches;
next	1.68;

1.68
date	2004.03.01.00.37.08;	author tedu;	state Exp;
branches;
next	1.67;

1.67
date	2004.02.20.10.53.10;	author jmc;	state Exp;
branches;
next	1.66;

1.66
date	2004.01.31.21.09.15;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2004.01.22.13.28.46;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2003.10.19.22.50.35;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2003.09.22.21.39.40;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2003.07.25.21.35.16;	author millert;	state Exp;
branches;
next	1.61;

1.61
date	2003.07.07.21.36.23;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2003.07.07.14.12.18;	author avsm;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.26.21.59.11;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.10.22.20.48;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2002.12.30.18.00.18;	author stevesk;	state Exp;
branches;
next	1.56;

1.56
date	2002.12.30.17.57.58;	author stevesk;	state Exp;
branches;
next	1.55;

1.55
date	2002.12.28.10.24.09;	author fgsch;	state Exp;
branches;
next	1.54;

1.54
date	2002.12.13.19.53.45;	author aaron;	state Exp;
branches;
next	1.53;

1.53
date	2002.11.13.22.26.15;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2002.07.04.04.42.25;	author vincent;	state Exp;
branches;
next	1.51;

1.51
date	2002.07.01.20.12.40;	author vincent;	state Exp;
branches;
next	1.50;

1.50
date	2002.07.01.15.40.40;	author vincent;	state Exp;
branches;
next	1.49;

1.49
date	2002.05.30.09.37.38;	author hugh;	state Exp;
branches;
next	1.48;

1.48
date	2002.05.29.09.23.25;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2002.03.10.20.26.09;	author ericj;	state Exp;
branches;
next	1.46;

1.46
date	2002.02.28.18.05.36;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.19.22.42.04;	author ericj;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.17.19.42.31;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2002.02.17.03.24.56;	author ericj;	state Exp;
branches;
next	1.42;

1.42
date	2002.02.17.03.03.06;	author ericj;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.17.02.04.57;	author ericj;	state Exp;
branches;
next	1.40;

1.40
date	2002.02.16.21.27.50;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2001.10.28.19.52.04;	author jakob;	state Exp;
branches;
next	1.38;

1.38
date	2001.10.28.19.48.33;	author jakob;	state Exp;
branches;
next	1.37;

1.37
date	2001.09.02.19.11.46;	author jakob;	state Exp;
branches;
next	1.36;

1.36
date	2001.09.02.19.07.17;	author jakob;	state Exp;
branches;
next	1.35;

1.35
date	2001.09.02.19.04.23;	author jakob;	state Exp;
branches;
next	1.34;

1.34
date	2001.09.02.18.45.41;	author jakob;	state Exp;
branches;
next	1.33;

1.33
date	2001.08.25.21.50.13;	author ericj;	state Exp;
branches;
next	1.32;

1.32
date	2001.08.02.21.00.14;	author ericj;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.27.07.23.58;	author ericj;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.27.03.14.28;	author smart;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.27.02.45.08;	author smart;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.26.23.25.22;	author ericj;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.26.23.06.53;	author ericj;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.26.21.57.35;	author ericj;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.26.21.19.14;	author ericj;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.26.20.53.14;	author ericj;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.26.19.31.10;	author ericj;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.26.07.38.05;	author jasoni;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.25.22.17.35;	author ericj;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.04.01.38.31;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.16.20.20.48;	author ericj;	state Exp;
branches;
next	1.18;

1.18
date	2000.12.01.02.25.58;	author ericj;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.26.18.53.13;	author ericj;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.26.17.46.40;	author ericj;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.26.05.19.37;	author ericj;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.26.05.16.00;	author ericj;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.26.05.03.31;	author ericj;	state Exp;
branches;
next	1.12;

1.12
date	2000.09.26.02.51.22;	author ericj;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.26.01.15.49;	author ericj;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.25.19.25.40;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.07.15.34.02;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.06.06.24.50;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.31.19.31.42;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.24.19.13.33;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.08.16.20.13.54;	author art;	state Exp;
branches;
next	1.4;

1.4
date	99.06.05.19.33.49;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.04.07.19.55.26;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.01.15.23.43.43;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.09.05.08.55.34;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.181
log
@Move comments into a block and uses {} to unconfuse reading.
@
text
@/* $OpenBSD: netcat.c,v 1.180 2017/04/05 06:55:59 jmc Exp $ */
/*
 * Copyright (c) 2001 Eric Jackson <ericj@@monkey.org>
 * Copyright (c) 2015 Bob Beck.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *   derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Re-written nc(1) for OpenBSD. Original implementation by
 * *Hobbit* <hobbit@@avian.org>.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/un.h>

#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netinet/ip.h>
#include <arpa/telnet.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <netdb.h>
#include <poll.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <tls.h>
#include "atomicio.h"

#define PORT_MAX	65535
#define UNIX_DG_TMP_SOCKET_SIZE	19

#define POLL_STDIN 0
#define POLL_NETOUT 1
#define POLL_NETIN 2
#define POLL_STDOUT 3
#define BUFSIZE 16384
#define DEFAULT_CA_FILE "/etc/ssl/cert.pem"

#define TLS_ALL	(1 << 1)
#define TLS_NOVERIFY	(1 << 2)
#define TLS_NONAME	(1 << 3)
#define TLS_CCERT	(1 << 4)
#define TLS_MUSTSTAPLE	(1 << 5)

/* Command Line Options */
int	dflag;					/* detached, no stdin */
int	Fflag;					/* fdpass sock to stdout */
unsigned int iflag;				/* Interval Flag */
int	kflag;					/* More than one connect */
int	lflag;					/* Bind to local port */
int	Nflag;					/* shutdown() network socket */
int	nflag;					/* Don't do name look up */
char   *Pflag;					/* Proxy username */
char   *pflag;					/* Localport flag */
int	rflag;					/* Random ports flag */
char   *sflag;					/* Source Address */
int	tflag;					/* Telnet Emulation */
int	uflag;					/* UDP - Default to TCP */
int	vflag;					/* Verbosity */
int	xflag;					/* Socks proxy */
int	zflag;					/* Port Scan Flag */
int	Dflag;					/* sodebug */
int	Iflag;					/* TCP receive buffer size */
int	Oflag;					/* TCP send buffer size */
int	Sflag;					/* TCP MD5 signature option */
int	Tflag = -1;				/* IP Type of Service */
int	rtableid = -1;

int	usetls;					/* use TLS */
char    *Cflag;					/* Public cert file */
char    *Kflag;					/* Private key file */
char    *oflag;					/* OCSP stapling file */
char    *Rflag = DEFAULT_CA_FILE;		/* Root CA file */
int	tls_cachanged;				/* Using non-default CA file */
int     TLSopt;					/* TLS options */
char	*tls_expectname;			/* required name in peer cert */
char	*tls_expecthash;			/* required hash of peer cert */
FILE	*Zflag;					/* file to save peer cert */

int timeout = -1;
int family = AF_UNSPEC;
char *portlist[PORT_MAX+1];
char *unix_dg_tmp_socket;
int ttl = -1;
int minttl = -1;

void	atelnet(int, unsigned char *, unsigned int);
void	build_ports(char *);
void	help(void);
int	local_listen(char *, char *, struct addrinfo);
void	readwrite(int, struct tls *);
void	fdpass(int nfd) __attribute__((noreturn));
int	remote_connect(const char *, const char *, struct addrinfo);
int	timeout_tls(int, struct tls *, int (*)(struct tls *));
int	timeout_connect(int, const struct sockaddr *, socklen_t);
int	socks_connect(const char *, const char *, struct addrinfo,
	    const char *, const char *, struct addrinfo, int, const char *);
int	udptest(int);
int	unix_bind(char *, int);
int	unix_connect(char *);
int	unix_listen(char *);
void	set_common_sockopts(int, int);
int	map_tos(char *, int *);
int	map_tls(char *, int *);
void    save_peer_cert(struct tls *_tls_ctx, FILE *_fp);
void	report_connect(const struct sockaddr *, socklen_t, char *);
void	report_tls(struct tls *tls_ctx, char * host, char *tls_expectname);
void	usage(int);
ssize_t drainbuf(int, unsigned char *, size_t *, struct tls *);
ssize_t fillbuf(int, unsigned char *, size_t *, struct tls *);
void	tls_setup_client(struct tls *, int, char *);
struct tls *tls_setup_server(struct tls *, int, char *);

int
main(int argc, char *argv[])
{
	int ch, s = -1, ret, socksv;
	char *host, *uport;
	struct addrinfo hints;
	struct servent *sv;
	socklen_t len;
	struct sockaddr_storage cliaddr;
	char *proxy, *proxyport = NULL;
	const char *errstr;
	struct addrinfo proxyhints;
	char unix_dg_tmp_socket_buf[UNIX_DG_TMP_SOCKET_SIZE];
	struct tls_config *tls_cfg = NULL;
	struct tls *tls_ctx = NULL;

	ret = 1;
	socksv = 5;
	host = NULL;
	uport = NULL;
	sv = NULL;

	signal(SIGPIPE, SIG_IGN);

	while ((ch = getopt(argc, argv,
	    "46C:cDde:FH:hI:i:K:klM:m:NnO:o:P:p:R:rSs:T:tUuV:vw:X:x:Z:z")) != -1) {
		switch (ch) {
		case '4':
			family = AF_INET;
			break;
		case '6':
			family = AF_INET6;
			break;
		case 'U':
			family = AF_UNIX;
			break;
		case 'X':
			if (strcasecmp(optarg, "connect") == 0)
				socksv = -1; /* HTTP proxy CONNECT */
			else if (strcmp(optarg, "4") == 0)
				socksv = 4; /* SOCKS v.4 */
			else if (strcmp(optarg, "5") == 0)
				socksv = 5; /* SOCKS v.5 */
			else
				errx(1, "unsupported proxy protocol");
			break;
		case 'C':
			Cflag = optarg;
			break;
		case 'c':
			usetls = 1;
			break;
		case 'd':
			dflag = 1;
			break;
		case 'e':
			tls_expectname = optarg;
			break;
		case 'F':
			Fflag = 1;
			break;
		case 'H':
			tls_expecthash = optarg;
			break;
		case 'h':
			help();
			break;
		case 'i':
			iflag = strtonum(optarg, 0, UINT_MAX, &errstr);
			if (errstr)
				errx(1, "interval %s: %s", errstr, optarg);
			break;
		case 'K':
			Kflag = optarg;
			break;
		case 'k':
			kflag = 1;
			break;
		case 'l':
			lflag = 1;
			break;
		case 'M':
			ttl = strtonum(optarg, 0, 255, &errstr);
			if (errstr)
				errx(1, "ttl is %s", errstr);
			break;
		case 'm':
			minttl = strtonum(optarg, 0, 255, &errstr);
			if (errstr)
				errx(1, "minttl is %s", errstr);
			break;
		case 'N':
			Nflag = 1;
			break;
		case 'n':
			nflag = 1;
			break;
		case 'P':
			Pflag = optarg;
			break;
		case 'p':
			pflag = optarg;
			break;
		case 'R':
			tls_cachanged = 1;
			Rflag = optarg;
			break;
		case 'r':
			rflag = 1;
			break;
		case 's':
			sflag = optarg;
			break;
		case 't':
			tflag = 1;
			break;
		case 'u':
			uflag = 1;
			break;
		case 'V':
			rtableid = (int)strtonum(optarg, 0,
			    RT_TABLEID_MAX, &errstr);
			if (errstr)
				errx(1, "rtable %s: %s", errstr, optarg);
			break;
		case 'v':
			vflag = 1;
			break;
		case 'w':
			timeout = strtonum(optarg, 0, INT_MAX / 1000, &errstr);
			if (errstr)
				errx(1, "timeout %s: %s", errstr, optarg);
			timeout *= 1000;
			break;
		case 'x':
			xflag = 1;
			if ((proxy = strdup(optarg)) == NULL)
				err(1, NULL);
			break;
		case 'Z':
			if (strcmp(optarg, "-") == 0)
				Zflag = stderr;
			else if ((Zflag = fopen(optarg, "w")) == NULL)
				err(1, "can't open %s", optarg);
			break;
		case 'z':
			zflag = 1;
			break;
		case 'D':
			Dflag = 1;
			break;
		case 'I':
			Iflag = strtonum(optarg, 1, 65536 << 14, &errstr);
			if (errstr != NULL)
				errx(1, "TCP receive window %s: %s",
				    errstr, optarg);
			break;
		case 'O':
			Oflag = strtonum(optarg, 1, 65536 << 14, &errstr);
			if (errstr != NULL)
				errx(1, "TCP send window %s: %s",
				    errstr, optarg);
			break;
		case 'o':
			oflag = optarg;
			break;
		case 'S':
			Sflag = 1;
			break;
		case 'T':
			errstr = NULL;
			errno = 0;
			if (map_tos(optarg, &Tflag))
				break;
			if (map_tls(optarg, &TLSopt))
				break;
			if (strlen(optarg) > 1 && optarg[0] == '0' &&
			    optarg[1] == 'x')
				Tflag = (int)strtol(optarg, NULL, 16);
			else
				Tflag = (int)strtonum(optarg, 0, 255,
				    &errstr);
			if (Tflag < 0 || Tflag > 255 || errstr || errno)
				errx(1, "illegal tos/tls value %s", optarg);
			break;
		default:
			usage(1);
		}
	}
	argc -= optind;
	argv += optind;

	if (rtableid >= 0)
		if (setrtable(rtableid) == -1)
			err(1, "setrtable");

	if (family == AF_UNIX) {
		if (pledge("stdio rpath wpath cpath tmppath unix", NULL) == -1)
			err(1, "pledge");
	} else if (Fflag) {
		if (Pflag) {
			if (pledge("stdio inet dns sendfd tty", NULL) == -1)
				err(1, "pledge");
		} else if (pledge("stdio inet dns sendfd", NULL) == -1)
			err(1, "pledge");
	} else if (Pflag) {
		if (pledge("stdio inet dns tty", NULL) == -1)
			err(1, "pledge");
	} else if (usetls) {
		if (pledge("stdio rpath inet dns", NULL) == -1)
			err(1, "pledge");
	} else if (pledge("stdio inet dns", NULL) == -1)
		err(1, "pledge");

	/* Cruft to make sure options are clean, and used properly. */
	if (argv[0] && !argv[1] && family == AF_UNIX) {
		host = argv[0];
		uport = NULL;
	} else if (argv[0] && !argv[1]) {
		if  (!lflag)
			usage(1);
		uport = argv[0];
		host = NULL;
	} else if (argv[0] && argv[1]) {
		host = argv[0];
		uport = argv[1];
	} else
		usage(1);

	if (lflag && sflag)
		errx(1, "cannot use -s and -l");
	if (lflag && pflag)
		errx(1, "cannot use -p and -l");
	if (lflag && zflag)
		errx(1, "cannot use -z and -l");
	if (!lflag && kflag)
		errx(1, "must use -l with -k");
	if (uflag && usetls)
		errx(1, "cannot use -c and -u");
	if ((family == AF_UNIX) && usetls)
		errx(1, "cannot use -c and -U");
	if ((family == AF_UNIX) && Fflag)
		errx(1, "cannot use -F and -U");
	if (Fflag && usetls)
		errx(1, "cannot use -c and -F");
	if (TLSopt && !usetls)
		errx(1, "you must specify -c to use TLS options");
	if (Cflag && !usetls)
		errx(1, "you must specify -c to use -C");
	if (Kflag && !usetls)
		errx(1, "you must specify -c to use -K");
	if (Zflag && !usetls)
		errx(1, "you must specify -c to use -Z");
	if (oflag && !Cflag)
		errx(1, "you must specify -C to use -o");
	if (tls_cachanged && !usetls)
		errx(1, "you must specify -c to use -R");
	if (tls_expecthash && !usetls)
		errx(1, "you must specify -c to use -H");
	if (tls_expectname && !usetls)
		errx(1, "you must specify -c to use -e");

	/* Get name of temporary socket for unix datagram client */
	if ((family == AF_UNIX) && uflag && !lflag) {
		if (sflag) {
			unix_dg_tmp_socket = sflag;
		} else {
			strlcpy(unix_dg_tmp_socket_buf, "/tmp/nc.XXXXXXXXXX",
			    UNIX_DG_TMP_SOCKET_SIZE);
			if (mktemp(unix_dg_tmp_socket_buf) == NULL)
				err(1, "mktemp");
			unix_dg_tmp_socket = unix_dg_tmp_socket_buf;
		}
	}

	/* Initialize addrinfo structure. */
	if (family != AF_UNIX) {
		memset(&hints, 0, sizeof(struct addrinfo));
		hints.ai_family = family;
		hints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;
		hints.ai_protocol = uflag ? IPPROTO_UDP : IPPROTO_TCP;
		if (nflag)
			hints.ai_flags |= AI_NUMERICHOST;
	}

	if (xflag) {
		if (uflag)
			errx(1, "no proxy support for UDP mode");

		if (lflag)
			errx(1, "no proxy support for listen");

		if (family == AF_UNIX)
			errx(1, "no proxy support for unix sockets");

		if (sflag)
			errx(1, "no proxy support for local source address");

		if (*proxy == '[') {
			++proxy;
			proxyport = strchr(proxy, ']');
			if (proxyport == NULL)
				errx(1, "missing closing bracket in proxy");
			*proxyport++ = '\0';
			if (*proxyport == '\0')
				/* Use default proxy port. */
				proxyport = NULL;
			else {
				if (*proxyport == ':')
					++proxyport;
				else
					errx(1, "garbage proxy port delimiter");
			}
		} else {
			proxyport = strrchr(proxy, ':');
			if (proxyport != NULL)
				*proxyport++ = '\0';
		}

		memset(&proxyhints, 0, sizeof(struct addrinfo));
		proxyhints.ai_family = family;
		proxyhints.ai_socktype = SOCK_STREAM;
		proxyhints.ai_protocol = IPPROTO_TCP;
		if (nflag)
			proxyhints.ai_flags |= AI_NUMERICHOST;
	}

	if (usetls) {
		if (Pflag) {
			if (pledge("stdio inet dns tty rpath", NULL) == -1)
				err(1, "pledge");
		} else if (pledge("stdio inet dns rpath", NULL) == -1)
			err(1, "pledge");

		if (tls_init() == -1)
			errx(1, "unable to initialize TLS");
		if ((tls_cfg = tls_config_new()) == NULL)
			errx(1, "unable to allocate TLS config");
		if (Rflag && tls_config_set_ca_file(tls_cfg, Rflag) == -1)
			errx(1, "%s", tls_config_error(tls_cfg));
		if (Cflag && tls_config_set_cert_file(tls_cfg, Cflag) == -1)
			errx(1, "%s", tls_config_error(tls_cfg));
		if (Kflag && tls_config_set_key_file(tls_cfg, Kflag) == -1)
			errx(1, "%s", tls_config_error(tls_cfg));
		if (oflag && tls_config_set_ocsp_staple_file(tls_cfg, oflag) == -1)
			errx(1, "%s", tls_config_error(tls_cfg));
		if (TLSopt & TLS_ALL) {
			if (tls_config_set_protocols(tls_cfg,
			    TLS_PROTOCOLS_ALL) != 0)
				errx(1, "%s", tls_config_error(tls_cfg));
			if (tls_config_set_ciphers(tls_cfg, "all") != 0)
				errx(1, "%s", tls_config_error(tls_cfg));
		}
		if (!lflag && (TLSopt & TLS_CCERT))
			errx(1, "clientcert is only valid with -l");
		if (TLSopt & TLS_NONAME)
			tls_config_insecure_noverifyname(tls_cfg);
		if (TLSopt & TLS_NOVERIFY) {
			if (tls_expecthash != NULL)
				errx(1, "-H and -T noverify may not be used"
				    "together");
			tls_config_insecure_noverifycert(tls_cfg);
		}
		if (TLSopt & TLS_MUSTSTAPLE)
			tls_config_ocsp_require_stapling(tls_cfg);

		if (Pflag) {
			if (pledge("stdio inet dns tty", NULL) == -1)
				err(1, "pledge");
		} else if (pledge("stdio inet dns", NULL) == -1)
			err(1, "pledge");
	}
	if (lflag) {
		struct tls *tls_cctx = NULL;
		int connfd;
		ret = 0;

		if (family == AF_UNIX) {
			if (uflag)
				s = unix_bind(host, 0);
			else
				s = unix_listen(host);
		}

		if (usetls) {
			tls_config_verify_client_optional(tls_cfg);
			if ((tls_ctx = tls_server()) == NULL)
				errx(1, "tls server creation failed");
			if (tls_configure(tls_ctx, tls_cfg) == -1)
				errx(1, "tls configuration failed (%s)",
				    tls_error(tls_ctx));
		}
		/* Allow only one connection at a time, but stay alive. */
		for (;;) {
			if (family != AF_UNIX)
				s = local_listen(host, uport, hints);
			if (s < 0)
				err(1, NULL);
			if (uflag && kflag) {
				/*
				 * For UDP and -k, don't connect the socket,
				 * let it receive datagrams from multiple
				 * socket pairs.
				 */
				readwrite(s, NULL);
			} else if (uflag && !kflag) {
				/*
				 * For UDP and not -k, we will use recvfrom()
				 * initially to wait for a caller, then use
				 * the regular functions to talk to the caller.
				 */
				int rv, plen;
				char buf[16384];
				struct sockaddr_storage z;

				len = sizeof(z);
				plen = 2048;
				rv = recvfrom(s, buf, plen, MSG_PEEK,
				    (struct sockaddr *)&z, &len);
				if (rv < 0)
					err(1, "recvfrom");

				rv = connect(s, (struct sockaddr *)&z, len);
				if (rv < 0)
					err(1, "connect");

				if (vflag)
					report_connect((struct sockaddr *)&z, len, NULL);

				readwrite(s, NULL);
			} else {
				len = sizeof(cliaddr);
				connfd = accept4(s, (struct sockaddr *)&cliaddr,
				    &len, SOCK_NONBLOCK);
				if (connfd == -1) {
					/* For now, all errnos are fatal */
					err(1, "accept");
				}
				if (vflag)
					report_connect((struct sockaddr *)&cliaddr, len,
					    family == AF_UNIX ? host : NULL);
				if ((usetls) &&
				    (tls_cctx = tls_setup_server(tls_ctx, connfd, host)))
					readwrite(connfd, tls_cctx);
				if (!usetls)
					readwrite(connfd, NULL);
				if (tls_cctx) {
					timeout_tls(s, tls_cctx, tls_close);
					tls_free(tls_cctx);
					tls_cctx = NULL;
				}
				close(connfd);
			}
			if (family != AF_UNIX)
				close(s);
			else if (uflag) {
				if (connect(s, NULL, 0) < 0)
					err(1, "connect");
			}

			if (!kflag)
				break;
		}
	} else if (family == AF_UNIX) {
		ret = 0;

		if ((s = unix_connect(host)) > 0) {
			if (!zflag)
				readwrite(s, NULL);
			close(s);
		} else
			ret = 1;

		if (uflag)
			unlink(unix_dg_tmp_socket);
		exit(ret);

	} else {
		int i = 0;

		/* Construct the portlist[] array. */
		build_ports(uport);

		/* Cycle through portlist, connecting to each port. */
		for (s = -1, i = 0; portlist[i] != NULL; i++) {
			if (s != -1)
				close(s);

			if (usetls) {
				if ((tls_ctx = tls_client()) == NULL)
					errx(1, "tls client creation failed");
				if (tls_configure(tls_ctx, tls_cfg) == -1)
					errx(1, "tls configuration failed (%s)",
					    tls_error(tls_ctx));
			}
			if (xflag)
				s = socks_connect(host, portlist[i], hints,
				    proxy, proxyport, proxyhints, socksv,
				    Pflag);
			else
				s = remote_connect(host, portlist[i], hints);

			if (s == -1)
				continue;

			ret = 0;
			if (vflag || zflag) {
				/* For UDP, make sure we are connected. */
				if (uflag) {
					if (udptest(s) == -1) {
						ret = 1;
						continue;
					}
				}

				/* Don't look up port if -n. */
				if (nflag)
					sv = NULL;
				else {
					sv = getservbyport(
					    ntohs(atoi(portlist[i])),
					    uflag ? "udp" : "tcp");
				}

				fprintf(stderr,
				    "Connection to %s %s port [%s/%s] "
				    "succeeded!\n", host, portlist[i],
				    uflag ? "udp" : "tcp",
				    sv ? sv->s_name : "*");
			}
			if (Fflag)
				fdpass(s);
			else {
				if (usetls)
					tls_setup_client(tls_ctx, s, host);
				if (!zflag)
					readwrite(s, tls_ctx);
				if (tls_ctx) {
					timeout_tls(s, tls_ctx, tls_close);
					tls_free(tls_ctx);
					tls_ctx = NULL;
				}
			}
		}
	}

	if (s != -1)
		close(s);

	tls_config_free(tls_cfg);

	exit(ret);
}

/*
 * unix_bind()
 * Returns a unix socket bound to the given path
 */
int
unix_bind(char *path, int flags)
{
	struct sockaddr_un s_un;
	int s, save_errno;

	/* Create unix domain socket. */
	if ((s = socket(AF_UNIX, flags | (uflag ? SOCK_DGRAM : SOCK_STREAM),
	    0)) < 0)
		return (-1);

	memset(&s_un, 0, sizeof(struct sockaddr_un));
	s_un.sun_family = AF_UNIX;

	if (strlcpy(s_un.sun_path, path, sizeof(s_un.sun_path)) >=
	    sizeof(s_un.sun_path)) {
		close(s);
		errno = ENAMETOOLONG;
		return (-1);
	}

	if (bind(s, (struct sockaddr *)&s_un, sizeof(s_un)) < 0) {
		save_errno = errno;
		close(s);
		errno = save_errno;
		return (-1);
	}
	return (s);
}

int
timeout_tls(int s, struct tls *tls_ctx, int (*func)(struct tls *))
{
	struct pollfd pfd;
	int ret;

	while ((ret = (*func)(tls_ctx)) != 0) {
		if (ret == TLS_WANT_POLLIN)
			pfd.events = POLLIN;
		else if (ret == TLS_WANT_POLLOUT)
			pfd.events = POLLOUT;
		else
			break;
		pfd.fd = s;
		if ((ret = poll(&pfd, 1, timeout)) == 1)
			continue;
		else if (ret == 0) {
			errno = ETIMEDOUT;
			ret = -1;
			break;
		} else
			err(1, "poll failed");
	}

	return (ret);
}

void
tls_setup_client(struct tls *tls_ctx, int s, char *host)
{
	const char *errstr;

	if (tls_connect_socket(tls_ctx, s,
		tls_expectname ? tls_expectname : host) == -1) {
		errx(1, "tls connection failed (%s)",
		    tls_error(tls_ctx));
	}
	if (timeout_tls(s, tls_ctx, tls_handshake) == -1) {
		if ((errstr = tls_error(tls_ctx)) == NULL)
			errstr = strerror(errno);
		errx(1, "tls handshake failed (%s)", errstr);
	}
	if (vflag)
		report_tls(tls_ctx, host, tls_expectname);
	if (tls_expecthash && tls_peer_cert_hash(tls_ctx) &&
	    strcmp(tls_expecthash, tls_peer_cert_hash(tls_ctx)) != 0)
		errx(1, "peer certificate is not %s", tls_expecthash);
	if (Zflag) {
		save_peer_cert(tls_ctx, Zflag);
		if (Zflag != stderr && (fclose(Zflag) != 0))
			err(1, "fclose failed saving peer cert");
	}
}

struct tls *
tls_setup_server(struct tls *tls_ctx, int connfd, char *host)
{
	struct tls *tls_cctx;
	const char *errstr;

	if (tls_accept_socket(tls_ctx, &tls_cctx, connfd) == -1) {
		warnx("tls accept failed (%s)", tls_error(tls_ctx));
	} else if (timeout_tls(connfd, tls_cctx, tls_handshake) == -1) {
		if ((errstr = tls_error(tls_cctx)) == NULL)
			errstr = strerror(errno);
		warnx("tls handshake failed (%s)", errstr);
	} else {
		int gotcert = tls_peer_cert_provided(tls_cctx);

		if (vflag && gotcert)
			report_tls(tls_cctx, host, tls_expectname);
		if ((TLSopt & TLS_CCERT) && !gotcert)
			warnx("No client certificate provided");
		else if (gotcert && tls_peer_cert_hash(tls_ctx) && tls_expecthash &&
		    strcmp(tls_expecthash, tls_peer_cert_hash(tls_ctx)) != 0)
			warnx("peer certificate is not %s", tls_expecthash);
		else if (gotcert && tls_expectname &&
		    (!tls_peer_cert_contains_name(tls_cctx, tls_expectname)))
			warnx("name (%s) not found in client cert",
			    tls_expectname);
		else {
			return tls_cctx;
		}
	}
	return NULL;
}

/*
 * unix_connect()
 * Returns a socket connected to a local unix socket. Returns -1 on failure.
 */
int
unix_connect(char *path)
{
	struct sockaddr_un s_un;
	int s, save_errno;

	if (uflag) {
		if ((s = unix_bind(unix_dg_tmp_socket, SOCK_CLOEXEC)) < 0)
			return (-1);
	} else {
		if ((s = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0)) < 0)
			return (-1);
	}

	memset(&s_un, 0, sizeof(struct sockaddr_un));
	s_un.sun_family = AF_UNIX;

	if (strlcpy(s_un.sun_path, path, sizeof(s_un.sun_path)) >=
	    sizeof(s_un.sun_path)) {
		close(s);
		errno = ENAMETOOLONG;
		return (-1);
	}
	if (connect(s, (struct sockaddr *)&s_un, sizeof(s_un)) < 0) {
		save_errno = errno;
		close(s);
		errno = save_errno;
		return (-1);
	}
	return (s);

}

/*
 * unix_listen()
 * Create a unix domain socket, and listen on it.
 */
int
unix_listen(char *path)
{
	int s;
	if ((s = unix_bind(path, 0)) < 0)
		return (-1);

	if (listen(s, 5) < 0) {
		close(s);
		return (-1);
	}
	return (s);
}

/*
 * remote_connect()
 * Returns a socket connected to a remote host. Properly binds to a local
 * port or source address if needed. Returns -1 on failure.
 */
int
remote_connect(const char *host, const char *port, struct addrinfo hints)
{
	struct addrinfo *res, *res0;
	int s = -1, error, on = 1, save_errno;

	if ((error = getaddrinfo(host, port, &hints, &res0)))
		errx(1, "getaddrinfo for host \"%s\" port %s: %s", host,
		    port, gai_strerror(error));

	for (res = res0; res; res = res->ai_next) {
		if ((s = socket(res->ai_family, res->ai_socktype |
		    SOCK_NONBLOCK, res->ai_protocol)) < 0)
			continue;

		/* Bind to a local port or source address if specified. */
		if (sflag || pflag) {
			struct addrinfo ahints, *ares;

			/* try SO_BINDANY, but don't insist */
			setsockopt(s, SOL_SOCKET, SO_BINDANY, &on, sizeof(on));
			memset(&ahints, 0, sizeof(struct addrinfo));
			ahints.ai_family = res->ai_family;
			ahints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;
			ahints.ai_protocol = uflag ? IPPROTO_UDP : IPPROTO_TCP;
			ahints.ai_flags = AI_PASSIVE;
			if ((error = getaddrinfo(sflag, pflag, &ahints, &ares)))
				errx(1, "getaddrinfo: %s", gai_strerror(error));

			if (bind(s, (struct sockaddr *)ares->ai_addr,
			    ares->ai_addrlen) < 0)
				err(1, "bind failed");
			freeaddrinfo(ares);
		}

		set_common_sockopts(s, res->ai_family);

		if (timeout_connect(s, res->ai_addr, res->ai_addrlen) == 0)
			break;
		if (vflag)
			warn("connect to %s port %s (%s) failed", host, port,
			    uflag ? "udp" : "tcp");

		save_errno = errno;
		close(s);
		errno = save_errno;
		s = -1;
	}

	freeaddrinfo(res0);

	return (s);
}

int
timeout_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
	struct pollfd pfd;
	socklen_t optlen;
	int optval;
	int ret;

	if ((ret = connect(s, name, namelen)) != 0 && errno == EINPROGRESS) {
		pfd.fd = s;
		pfd.events = POLLOUT;
		if ((ret = poll(&pfd, 1, timeout)) == 1) {
			optlen = sizeof(optval);
			if ((ret = getsockopt(s, SOL_SOCKET, SO_ERROR,
			    &optval, &optlen)) == 0) {
				errno = optval;
				ret = optval == 0 ? 0 : -1;
			}
		} else if (ret == 0) {
			errno = ETIMEDOUT;
			ret = -1;
		} else
			err(1, "poll failed");
	}

	return (ret);
}

/*
 * local_listen()
 * Returns a socket listening on a local port, binds to specified source
 * address. Returns -1 on failure.
 */
int
local_listen(char *host, char *port, struct addrinfo hints)
{
	struct addrinfo *res, *res0;
	int s = -1, ret, x = 1, save_errno;
	int error;

	/* Allow nodename to be null. */
	hints.ai_flags |= AI_PASSIVE;

	/*
	 * In the case of binding to a wildcard address
	 * default to binding to an ipv4 address.
	 */
	if (host == NULL && hints.ai_family == AF_UNSPEC)
		hints.ai_family = AF_INET;

	if ((error = getaddrinfo(host, port, &hints, &res0)))
		errx(1, "getaddrinfo: %s", gai_strerror(error));

	for (res = res0; res; res = res->ai_next) {
		if ((s = socket(res->ai_family, res->ai_socktype,
		    res->ai_protocol)) < 0)
			continue;

		ret = setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &x, sizeof(x));
		if (ret == -1)
			err(1, NULL);

		set_common_sockopts(s, res->ai_family);

		if (bind(s, (struct sockaddr *)res->ai_addr,
		    res->ai_addrlen) == 0)
			break;

		save_errno = errno;
		close(s);
		errno = save_errno;
		s = -1;
	}

	if (!uflag && s != -1) {
		if (listen(s, 1) < 0)
			err(1, "listen");
	}

	freeaddrinfo(res0);

	return (s);
}

/*
 * readwrite()
 * Loop that polls on the network file descriptor and stdin.
 */
void
readwrite(int net_fd, struct tls *tls_ctx)
{
	struct pollfd pfd[4];
	int stdin_fd = STDIN_FILENO;
	int stdout_fd = STDOUT_FILENO;
	unsigned char netinbuf[BUFSIZE];
	size_t netinbufpos = 0;
	unsigned char stdinbuf[BUFSIZE];
	size_t stdinbufpos = 0;
	int n, num_fds;
	ssize_t ret;

	/* don't read from stdin if requested */
	if (dflag)
		stdin_fd = -1;

	/* stdin */
	pfd[POLL_STDIN].fd = stdin_fd;
	pfd[POLL_STDIN].events = POLLIN;

	/* network out */
	pfd[POLL_NETOUT].fd = net_fd;
	pfd[POLL_NETOUT].events = 0;

	/* network in */
	pfd[POLL_NETIN].fd = net_fd;
	pfd[POLL_NETIN].events = POLLIN;

	/* stdout */
	pfd[POLL_STDOUT].fd = stdout_fd;
	pfd[POLL_STDOUT].events = 0;

	while (1) {
		/* both inputs are gone, buffers are empty, we are done */
		if (pfd[POLL_STDIN].fd == -1 && pfd[POLL_NETIN].fd == -1 &&
		    stdinbufpos == 0 && netinbufpos == 0)
			return;
		/* both outputs are gone, we can't continue */
		if (pfd[POLL_NETOUT].fd == -1 && pfd[POLL_STDOUT].fd == -1)
			return;
		/* listen and net in gone, queues empty, done */
		if (lflag && pfd[POLL_NETIN].fd == -1 &&
		    stdinbufpos == 0 && netinbufpos == 0)
			return;

		/* help says -i is for "wait between lines sent". We read and
		 * write arbitrary amounts of data, and we don't want to start
		 * scanning for newlines, so this is as good as it gets */
		if (iflag)
			sleep(iflag);

		/* poll */
		num_fds = poll(pfd, 4, timeout);

		/* treat poll errors */
		if (num_fds == -1)
			err(1, "polling error");

		/* timeout happened */
		if (num_fds == 0)
			return;

		/* treat socket error conditions */
		for (n = 0; n < 4; n++) {
			if (pfd[n].revents & (POLLERR|POLLNVAL)) {
				pfd[n].fd = -1;
			}
		}
		/* reading is possible after HUP */
		if (pfd[POLL_STDIN].events & POLLIN &&
		    pfd[POLL_STDIN].revents & POLLHUP &&
		    !(pfd[POLL_STDIN].revents & POLLIN))
			pfd[POLL_STDIN].fd = -1;

		if (pfd[POLL_NETIN].events & POLLIN &&
		    pfd[POLL_NETIN].revents & POLLHUP &&
		    !(pfd[POLL_NETIN].revents & POLLIN))
			pfd[POLL_NETIN].fd = -1;

		if (pfd[POLL_NETOUT].revents & POLLHUP) {
			if (Nflag)
				shutdown(pfd[POLL_NETOUT].fd, SHUT_WR);
			pfd[POLL_NETOUT].fd = -1;
		}
		/* if HUP, stop watching stdout */
		if (pfd[POLL_STDOUT].revents & POLLHUP)
			pfd[POLL_STDOUT].fd = -1;
		/* if no net out, stop watching stdin */
		if (pfd[POLL_NETOUT].fd == -1)
			pfd[POLL_STDIN].fd = -1;
		/* if no stdout, stop watching net in */
		if (pfd[POLL_STDOUT].fd == -1) {
			if (pfd[POLL_NETIN].fd != -1)
				shutdown(pfd[POLL_NETIN].fd, SHUT_RD);
			pfd[POLL_NETIN].fd = -1;
		}

		/* try to read from stdin */
		if (pfd[POLL_STDIN].revents & POLLIN && stdinbufpos < BUFSIZE) {
			ret = fillbuf(pfd[POLL_STDIN].fd, stdinbuf,
			    &stdinbufpos, NULL);
			if (ret == TLS_WANT_POLLIN)
				pfd[POLL_STDIN].events = POLLIN;
			else if (ret == TLS_WANT_POLLOUT)
				pfd[POLL_STDIN].events = POLLOUT;
			else if (ret == 0 || ret == -1)
				pfd[POLL_STDIN].fd = -1;
			/* read something - poll net out */
			if (stdinbufpos > 0)
				pfd[POLL_NETOUT].events = POLLOUT;
			/* filled buffer - remove self from polling */
			if (stdinbufpos == BUFSIZE)
				pfd[POLL_STDIN].events = 0;
		}
		/* try to write to network */
		if (pfd[POLL_NETOUT].revents & POLLOUT && stdinbufpos > 0) {
			ret = drainbuf(pfd[POLL_NETOUT].fd, stdinbuf,
			    &stdinbufpos, tls_ctx);
			if (ret == TLS_WANT_POLLIN)
				pfd[POLL_NETOUT].events = POLLIN;
			else if (ret == TLS_WANT_POLLOUT)
				pfd[POLL_NETOUT].events = POLLOUT;
			else if (ret == -1)
				pfd[POLL_NETOUT].fd = -1;
			/* buffer empty - remove self from polling */
			if (stdinbufpos == 0)
				pfd[POLL_NETOUT].events = 0;
			/* buffer no longer full - poll stdin again */
			if (stdinbufpos < BUFSIZE)
				pfd[POLL_STDIN].events = POLLIN;
		}
		/* try to read from network */
		if (pfd[POLL_NETIN].revents & POLLIN && netinbufpos < BUFSIZE) {
			ret = fillbuf(pfd[POLL_NETIN].fd, netinbuf,
			    &netinbufpos, tls_ctx);
			if (ret == TLS_WANT_POLLIN)
				pfd[POLL_NETIN].events = POLLIN;
			else if (ret == TLS_WANT_POLLOUT)
				pfd[POLL_NETIN].events = POLLOUT;
			else if (ret == -1)
				pfd[POLL_NETIN].fd = -1;
			/* eof on net in - remove from pfd */
			if (ret == 0) {
				shutdown(pfd[POLL_NETIN].fd, SHUT_RD);
				pfd[POLL_NETIN].fd = -1;
			}
			/* read something - poll stdout */
			if (netinbufpos > 0)
				pfd[POLL_STDOUT].events = POLLOUT;
			/* filled buffer - remove self from polling */
			if (netinbufpos == BUFSIZE)
				pfd[POLL_NETIN].events = 0;
			/* handle telnet */
			if (tflag)
				atelnet(pfd[POLL_NETIN].fd, netinbuf,
				    netinbufpos);
		}
		/* try to write to stdout */
		if (pfd[POLL_STDOUT].revents & POLLOUT && netinbufpos > 0) {
			ret = drainbuf(pfd[POLL_STDOUT].fd, netinbuf,
			    &netinbufpos, NULL);
			if (ret == TLS_WANT_POLLIN)
				pfd[POLL_STDOUT].events = POLLIN;
			else if (ret == TLS_WANT_POLLOUT)
				pfd[POLL_STDOUT].events = POLLOUT;
			else if (ret == -1)
				pfd[POLL_STDOUT].fd = -1;
			/* buffer empty - remove self from polling */
			if (netinbufpos == 0)
				pfd[POLL_STDOUT].events = 0;
			/* buffer no longer full - poll net in again */
			if (netinbufpos < BUFSIZE)
				pfd[POLL_NETIN].events = POLLIN;
		}

		/* stdin gone and queue empty? */
		if (pfd[POLL_STDIN].fd == -1 && stdinbufpos == 0) {
			if (pfd[POLL_NETOUT].fd != -1 && Nflag)
				shutdown(pfd[POLL_NETOUT].fd, SHUT_WR);
			pfd[POLL_NETOUT].fd = -1;
		}
		/* net in gone and queue empty? */
		if (pfd[POLL_NETIN].fd == -1 && netinbufpos == 0) {
			pfd[POLL_STDOUT].fd = -1;
		}
	}
}

ssize_t
drainbuf(int fd, unsigned char *buf, size_t *bufpos, struct tls *tls)
{
	ssize_t n;
	ssize_t adjust;

	if (tls)
		n = tls_write(tls, buf, *bufpos);
	else {
		n = write(fd, buf, *bufpos);
		/* don't treat EAGAIN, EINTR as error */
		if (n == -1 && (errno == EAGAIN || errno == EINTR))
			n = TLS_WANT_POLLOUT;
	}
	if (n <= 0)
		return n;
	/* adjust buffer */
	adjust = *bufpos - n;
	if (adjust > 0)
		memmove(buf, buf + n, adjust);
	*bufpos -= n;
	return n;
}

ssize_t
fillbuf(int fd, unsigned char *buf, size_t *bufpos, struct tls *tls)
{
	size_t num = BUFSIZE - *bufpos;
	ssize_t n;

	if (tls)
		n = tls_read(tls, buf + *bufpos, num);
	else {
		n = read(fd, buf + *bufpos, num);
		/* don't treat EAGAIN, EINTR as error */
		if (n == -1 && (errno == EAGAIN || errno == EINTR))
			n = TLS_WANT_POLLIN;
	}
	if (n <= 0)
		return n;
	*bufpos += n;
	return n;
}

/*
 * fdpass()
 * Pass the connected file descriptor to stdout and exit.
 */
void
fdpass(int nfd)
{
	struct msghdr mh;
	union {
		struct cmsghdr hdr;
		char buf[CMSG_SPACE(sizeof(int))];
	} cmsgbuf;
	struct cmsghdr *cmsg;
	struct iovec iov;
	char c = '\0';
	ssize_t r;
	struct pollfd pfd;

	/* Avoid obvious stupidity */
	if (isatty(STDOUT_FILENO))
		errx(1, "Cannot pass file descriptor to tty");

	bzero(&mh, sizeof(mh));
	bzero(&cmsgbuf, sizeof(cmsgbuf));
	bzero(&iov, sizeof(iov));

	mh.msg_control = (caddr_t)&cmsgbuf.buf;
	mh.msg_controllen = sizeof(cmsgbuf.buf);
	cmsg = CMSG_FIRSTHDR(&mh);
	cmsg->cmsg_len = CMSG_LEN(sizeof(int));
	cmsg->cmsg_level = SOL_SOCKET;
	cmsg->cmsg_type = SCM_RIGHTS;
	*(int *)CMSG_DATA(cmsg) = nfd;

	iov.iov_base = &c;
	iov.iov_len = 1;
	mh.msg_iov = &iov;
	mh.msg_iovlen = 1;

	bzero(&pfd, sizeof(pfd));
	pfd.fd = STDOUT_FILENO;
	pfd.events = POLLOUT;
	for (;;) {
		r = sendmsg(STDOUT_FILENO, &mh, 0);
		if (r == -1) {
			if (errno == EAGAIN || errno == EINTR) {
				if (poll(&pfd, 1, -1) == -1)
					err(1, "poll");
				continue;
			}
			err(1, "sendmsg");
		} else if (r != 1)
			errx(1, "sendmsg: unexpected return value %zd", r);
		else
			break;
	}
	exit(0);
}

/* Deal with RFC 854 WILL/WONT DO/DONT negotiation. */
void
atelnet(int nfd, unsigned char *buf, unsigned int size)
{
	unsigned char *p, *end;
	unsigned char obuf[4];

	if (size < 3)
		return;
	end = buf + size - 2;

	for (p = buf; p < end; p++) {
		if (*p != IAC)
			continue;

		obuf[0] = IAC;
		p++;
		if ((*p == WILL) || (*p == WONT))
			obuf[1] = DONT;
		else if ((*p == DO) || (*p == DONT))
			obuf[1] = WONT;
		else
			continue;

		p++;
		obuf[2] = *p;
		if (atomicio(vwrite, nfd, obuf, 3) != 3)
			warn("Write Error!");
	}
}


int
strtoport(char *portstr, int udp)
{
	struct servent *entry;
	const char *errstr;
	char *proto;
	int port = -1;

	proto = udp ? "udp" : "tcp";

	port = strtonum(portstr, 1, PORT_MAX, &errstr);
	if (errstr == NULL)
		return port;
	if (errno != EINVAL)
		errx(1, "port number %s: %s", errstr, portstr);
	if ((entry = getservbyname(portstr, proto)) == NULL)
		errx(1, "service \"%s\" unknown", portstr);
	return ntohs(entry->s_port);
}

/*
 * build_ports()
 * Build an array of ports in portlist[], listing each port
 * that we should try to connect to.
 */
void
build_ports(char *p)
{
	char *n;
	int hi, lo, cp;
	int x = 0;

	if ((n = strchr(p, '-')) != NULL) {
		*n = '\0';
		n++;

		/* Make sure the ports are in order: lowest->highest. */
		hi = strtoport(n, uflag);
		lo = strtoport(p, uflag);
		if (lo > hi) {
			cp = hi;
			hi = lo;
			lo = cp;
		}

		/*
		 * Initialize portlist with a random permutation.  Based on
		 * Knuth, as in ip_randomid() in sys/netinet/ip_id.c.
		 */
		if (rflag) {
			for (x = 0; x <= hi - lo; x++) {
				cp = arc4random_uniform(x + 1);
				portlist[x] = portlist[cp];
				if (asprintf(&portlist[cp], "%d", x + lo) < 0)
					err(1, "asprintf");
			}
		} else { /* Load ports sequentially. */
			for (cp = lo; cp <= hi; cp++) {
				if (asprintf(&portlist[x], "%d", cp) < 0)
					err(1, "asprintf");
				x++;
			}
		}
	} else {
		char *tmp;

		hi = strtoport(p, uflag);
		if (asprintf(&tmp, "%d", hi) != -1)
			portlist[0] = tmp;
		else
			err(1, NULL);
	}
}

/*
 * udptest()
 * Do a few writes to see if the UDP port is there.
 * Fails once PF state table is full.
 */
int
udptest(int s)
{
	int i, ret;

	for (i = 0; i <= 3; i++) {
		if (write(s, "X", 1) == 1)
			ret = 1;
		else
			ret = -1;
	}
	return (ret);
}

void
set_common_sockopts(int s, int af)
{
	int x = 1;

	if (Sflag) {
		if (setsockopt(s, IPPROTO_TCP, TCP_MD5SIG,
			&x, sizeof(x)) == -1)
			err(1, NULL);
	}
	if (Dflag) {
		if (setsockopt(s, SOL_SOCKET, SO_DEBUG,
			&x, sizeof(x)) == -1)
			err(1, NULL);
	}
	if (Tflag != -1) {
		if (af == AF_INET && setsockopt(s, IPPROTO_IP,
		    IP_TOS, &Tflag, sizeof(Tflag)) == -1)
			err(1, "set IP ToS");

		else if (af == AF_INET6 && setsockopt(s, IPPROTO_IPV6,
		    IPV6_TCLASS, &Tflag, sizeof(Tflag)) == -1)
			err(1, "set IPv6 traffic class");
	}
	if (Iflag) {
		if (setsockopt(s, SOL_SOCKET, SO_RCVBUF,
		    &Iflag, sizeof(Iflag)) == -1)
			err(1, "set TCP receive buffer size");
	}
	if (Oflag) {
		if (setsockopt(s, SOL_SOCKET, SO_SNDBUF,
		    &Oflag, sizeof(Oflag)) == -1)
			err(1, "set TCP send buffer size");
	}

	if (ttl != -1) {
		if (af == AF_INET && setsockopt(s, IPPROTO_IP,
		    IP_TTL, &ttl, sizeof(ttl)))
			err(1, "set IP TTL");

		else if (af == AF_INET6 && setsockopt(s, IPPROTO_IPV6,
		    IPV6_UNICAST_HOPS, &ttl, sizeof(ttl)))
			err(1, "set IPv6 unicast hops");
	}

	if (minttl != -1) {
		if (af == AF_INET && setsockopt(s, IPPROTO_IP,
		    IP_MINTTL, &minttl, sizeof(minttl)))
			err(1, "set IP min TTL");

		else if (af == AF_INET6 && setsockopt(s, IPPROTO_IPV6,
		    IPV6_MINHOPCOUNT, &minttl, sizeof(minttl)))
			err(1, "set IPv6 min hop count");
	}
}

int
map_tos(char *s, int *val)
{
	/* DiffServ Codepoints and other TOS mappings */
	const struct toskeywords {
		const char	*keyword;
		int		 val;
	} *t, toskeywords[] = {
		{ "af11",		IPTOS_DSCP_AF11 },
		{ "af12",		IPTOS_DSCP_AF12 },
		{ "af13",		IPTOS_DSCP_AF13 },
		{ "af21",		IPTOS_DSCP_AF21 },
		{ "af22",		IPTOS_DSCP_AF22 },
		{ "af23",		IPTOS_DSCP_AF23 },
		{ "af31",		IPTOS_DSCP_AF31 },
		{ "af32",		IPTOS_DSCP_AF32 },
		{ "af33",		IPTOS_DSCP_AF33 },
		{ "af41",		IPTOS_DSCP_AF41 },
		{ "af42",		IPTOS_DSCP_AF42 },
		{ "af43",		IPTOS_DSCP_AF43 },
		{ "critical",		IPTOS_PREC_CRITIC_ECP },
		{ "cs0",		IPTOS_DSCP_CS0 },
		{ "cs1",		IPTOS_DSCP_CS1 },
		{ "cs2",		IPTOS_DSCP_CS2 },
		{ "cs3",		IPTOS_DSCP_CS3 },
		{ "cs4",		IPTOS_DSCP_CS4 },
		{ "cs5",		IPTOS_DSCP_CS5 },
		{ "cs6",		IPTOS_DSCP_CS6 },
		{ "cs7",		IPTOS_DSCP_CS7 },
		{ "ef",			IPTOS_DSCP_EF },
		{ "inetcontrol",	IPTOS_PREC_INTERNETCONTROL },
		{ "lowdelay",		IPTOS_LOWDELAY },
		{ "netcontrol",		IPTOS_PREC_NETCONTROL },
		{ "reliability",	IPTOS_RELIABILITY },
		{ "throughput",		IPTOS_THROUGHPUT },
		{ NULL,			-1 },
	};

	for (t = toskeywords; t->keyword != NULL; t++) {
		if (strcmp(s, t->keyword) == 0) {
			*val = t->val;
			return (1);
		}
	}

	return (0);
}

int
map_tls(char *s, int *val)
{
	const struct tlskeywords {
		const char	*keyword;
		int		 val;
	} *t, tlskeywords[] = {
		{ "tlsall",		TLS_ALL },
		{ "noverify",		TLS_NOVERIFY },
		{ "noname",		TLS_NONAME },
		{ "clientcert",		TLS_CCERT},
		{ "muststaple",		TLS_MUSTSTAPLE},
		{ NULL,			-1 },
	};

	for (t = tlskeywords; t->keyword != NULL; t++) {
		if (strcmp(s, t->keyword) == 0) {
			*val |= t->val;
			return (1);
		}
	}
	return (0);
}

void
save_peer_cert(struct tls *tls_ctx, FILE *fp)
{
	const char *pem;
	size_t plen;
	FILE *out;

	if ((pem = tls_peer_cert_chain_pem(tls_ctx, &plen)) == NULL)
		errx(1, "Can't get peer certificate");
	if (fprintf(fp, "%.*s", plen, pem) < 0)
		err(1, "unable to save peer cert");
	if (fflush(fp) != 0)
		err(1, "unable to flush peer cert");
}

void
report_tls(struct tls * tls_ctx, char * host, char *tls_expectname)
{
	time_t t;
	const char *ocsp_url;

	fprintf(stderr, "TLS handshake negotiated %s/%s with host %s\n",
	    tls_conn_version(tls_ctx), tls_conn_cipher(tls_ctx), host);
	fprintf(stderr, "Peer name: %s\n",
	    tls_expectname ? tls_expectname : host);
	if (tls_peer_cert_subject(tls_ctx))
		fprintf(stderr, "Subject: %s\n",
		    tls_peer_cert_subject(tls_ctx));
	if (tls_peer_cert_issuer(tls_ctx))
		fprintf(stderr, "Issuer: %s\n",
		    tls_peer_cert_issuer(tls_ctx));
	if ((t = tls_peer_cert_notbefore(tls_ctx)) != -1)
		fprintf(stderr, "Valid From: %s", ctime(&t));
	if ((t = tls_peer_cert_notafter(tls_ctx)) != -1)
		fprintf(stderr, "Valid Until: %s", ctime(&t));
	if (tls_peer_cert_hash(tls_ctx))
		fprintf(stderr, "Cert Hash: %s\n",
		    tls_peer_cert_hash(tls_ctx));
	ocsp_url = tls_peer_ocsp_url(tls_ctx);
	if (ocsp_url != NULL)
		fprintf(stderr, "OCSP URL: %s\n", ocsp_url);
	switch (tls_peer_ocsp_response_status(tls_ctx)) {
	case TLS_OCSP_RESPONSE_SUCCESSFUL:
		fprintf(stderr, "OCSP Stapling: %s\n",
		    tls_peer_ocsp_result(tls_ctx) == NULL ?  "" :
		    tls_peer_ocsp_result(tls_ctx));
		fprintf(stderr,
		    "  response_status=%d cert_status=%d crl_reason=%d\n",
		    tls_peer_ocsp_response_status(tls_ctx),
		    tls_peer_ocsp_cert_status(tls_ctx),
		    tls_peer_ocsp_crl_reason(tls_ctx));
		t = tls_peer_ocsp_this_update(tls_ctx);
		fprintf(stderr, "  this update: %s",
		    t != -1 ? ctime(&t) : "\n");
		t =  tls_peer_ocsp_next_update(tls_ctx);
		fprintf(stderr, "  next update: %s",
		    t != -1 ? ctime(&t) : "\n");
		t =  tls_peer_ocsp_revocation_time(tls_ctx);
		fprintf(stderr, "  revocation: %s",
		    t != -1 ? ctime(&t) : "\n");
		break;
	case -1:
		break;
	default:
		fprintf(stderr, "OCSP Stapling:  failure - response_status %d (%s)\n",
		    tls_peer_ocsp_response_status(tls_ctx),
		    tls_peer_ocsp_result(tls_ctx) == NULL ?  "" :
		    tls_peer_ocsp_result(tls_ctx));
		break;

	}
}

void
report_connect(const struct sockaddr *sa, socklen_t salen, char *path)
{
	char remote_host[NI_MAXHOST];
	char remote_port[NI_MAXSERV];
	int herr;
	int flags = NI_NUMERICSERV;

	if (path != NULL) {
		fprintf(stderr, "Connection on %s received!\n", path);
		return;
	}

	if (nflag)
		flags |= NI_NUMERICHOST;

	if ((herr = getnameinfo(sa, salen,
	    remote_host, sizeof(remote_host),
	    remote_port, sizeof(remote_port),
	    flags)) != 0) {
		if (herr == EAI_SYSTEM)
			err(1, "getnameinfo");
		else
			errx(1, "getnameinfo: %s", gai_strerror(herr));
	}

	fprintf(stderr,
	    "Connection from %s %s "
	    "received!\n", remote_host, remote_port);
}

void
help(void)
{
	usage(0);
	fprintf(stderr, "\tCommand Summary:\n\
	\t-4		Use IPv4\n\
	\t-6		Use IPv6\n\
	\t-C certfile	Public key file\n\
	\t-c		Use TLS\n\
	\t-D		Enable the debug socket option\n\
	\t-d		Detach from stdin\n\
	\t-e name\t	Required name in peer certificate\n\
	\t-F		Pass socket fd\n\
	\t-H hash\t	Hash string of peer certificate\n\
	\t-h		This help text\n\
	\t-I length	TCP receive buffer length\n\
	\t-i interval	Delay interval for lines sent, ports scanned\n\
	\t-K keyfile	Private key file\n\
	\t-k		Keep inbound sockets open for multiple connects\n\
	\t-l		Listen mode, for inbound connects\n\
	\t-M ttl		Outgoing TTL / Hop Limit\n\
	\t-m minttl	Minimum incoming TTL / Hop Limit\n\
	\t-N		Shutdown the network socket after EOF on stdin\n\
	\t-n		Suppress name/port resolutions\n\
	\t-O length	TCP send buffer length\n\
	\t-o staplefile	Staple file\n\
	\t-P proxyuser\tUsername for proxy authentication\n\
	\t-p port\t	Specify local port for remote connects\n\
	\t-R CAfile	CA bundle\n\
	\t-r		Randomize remote ports\n\
	\t-S		Enable the TCP MD5 signature option\n\
	\t-s source	Local source address\n\
	\t-T keyword	TOS value or TLS options\n\
	\t-t		Answer TELNET negotiation\n\
	\t-U		Use UNIX domain socket\n\
	\t-u		UDP mode\n\
	\t-V rtable	Specify alternate routing table\n\
	\t-v		Verbose\n\
	\t-w timeout	Timeout for connects and final net reads\n\
	\t-X proto	Proxy protocol: \"4\", \"5\" (SOCKS) or \"connect\"\n\
	\t-x addr[:port]\tSpecify proxy address and port\n\
	\t-Z		Peer certificate file\n\
	\t-z		Zero-I/O mode [used for scanning]\n\
	Port numbers can be individual or ranges: lo-hi [inclusive]\n");
	exit(1);
}

void
usage(int ret)
{
	fprintf(stderr,
	    "usage: nc [-46cDdFhklNnrStUuvz] [-C certfile] [-e name] "
	    "[-H hash] [-I length]\n"
	    "\t  [-i interval] [-K keyfile] [-M ttl] [-m minttl] [-O length]\n"
	    "\t  [-o staplefile] [-P proxy_username] [-p source_port] "
	    "[-R CAfile]\n"
	    "\t  [-s source] [-T keyword] [-V rtable] [-w timeout] "
	    "[-X proxy_protocol]\n"
	    "\t  [-x proxy_address[:port]] [-Z peercertfile] "
	    "[destination] [port]\n");
	if (ret)
		exit(1);
}
@


1.180
log
@- -Z before -z in options list
- add -Z to help and usage()
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.179 2017/04/05 03:20:19 beck Exp $ */
d543 6
a548 5
			/*
			 * For UDP and -k, don't connect the socket, let it
			 * receive datagrams from multiple socket pairs.
			 */
			if (uflag && kflag)
d550 6
a555 6
			/*
			 * For UDP and not -k, we will use recvfrom() initially
			 * to wait for a caller, then use the regular functions
			 * to talk to the caller.
			 */
			else if (uflag && !kflag) {
@


1.179
log
@Allow nc to save the peer certificate and chain in a pem file specified
with -Z
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.178 2017/03/09 13:58:00 bluhm Exp $ */
d1711 1
d1728 2
a1729 1
	    "\t  [-x proxy_address[:port]] [destination] [port]\n");
@


1.178
log
@The netcat server did not print the correct TLS error message if
the handshake after accept had failed.  Use the context of the
accepted TLS connection.
OK beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.177 2017/02/09 22:55:45 bluhm Exp $ */
d109 1
d136 1
d170 1
a170 1
	    "46C:cDde:FH:hI:i:K:klM:m:NnO:o:P:p:R:rSs:T:tUuV:vw:X:x:z")) != -1) {
d284 6
d396 2
d779 5
d1564 15
@


1.177
log
@When netcat was started with -Uz, the exit status was always 1.  If
the unix connect is successful, let nc -z close the socket and exit
with 0.
OK jca@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.176 2017/02/09 20:14:41 jca Exp $ */
d780 1
a780 1
		if ((errstr = tls_error(tls_ctx)) == NULL)
@


1.176
log
@When getaddrinfo fails, print the requested host and port.

Should make debugging easier, especially when using -x literal_ipv6_address
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.175 2017/02/08 18:44:50 bluhm Exp $ */
d600 3
a602 2
		if ((s = unix_connect(host)) > 0 && !zflag) {
			readwrite(s, NULL);
@


1.175
log
@Avoid a busy loop in netcat's tls_close().  Reuse the tls_handshake()
wrapper that calls poll(2) and handles the -w timeout.
OK beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.174 2017/02/08 18:03:31 bluhm Exp $ */
d870 2
a871 1
		errx(1, "getaddrinfo: %s", gai_strerror(error));
@


1.174
log
@Avoid double close(2) in netcat.  After every call to readwrite()
there is already a close(2), so do not do it in readwrite().
OK beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.173 2017/02/08 13:43:33 bluhm Exp $ */
d124 1
a124 1
int	timeout_handshake(int, struct tls *);
d581 1
a581 6
					int i;

					do {
						i = tls_close(tls_cctx);
					} while (i == TLS_WANT_POLLIN ||
					    i == TLS_WANT_POLLOUT);
d671 1
a671 6
					int j;

					do {
						j = tls_close(tls_ctx);
					} while (j == TLS_WANT_POLLIN ||
					    j == TLS_WANT_POLLOUT);
d722 1
a722 1
timeout_handshake(int s, struct tls *tls_ctx)
d727 1
a727 1
	while ((ret = tls_handshake(tls_ctx)) != 0) {
d758 1
a758 1
	if (timeout_handshake(s, tls_ctx) == -1) {
d778 1
a778 1
	} else if (timeout_handshake(connfd, tls_cctx) == -1) {
@


1.173
log
@Due to non-blocking sockets, tls_handshake() could wait in a busy
loop.  Use an additional poll(2) during the handshake and also
respect the -w timeout option there.
From Shuo Chen; OK beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.172 2017/02/05 01:39:14 jca Exp $ */
d1050 1
a1050 2
		    stdinbufpos == 0 && netinbufpos == 0) {
			close(net_fd);
a1051 1
		}
d1053 1
a1053 2
		if (pfd[POLL_NETOUT].fd == -1 && pfd[POLL_STDOUT].fd == -1) {
			close(net_fd);
a1054 1
		}
d1057 1
a1057 2
		    stdinbufpos == 0 && netinbufpos == 0) {
			close(net_fd);
a1058 1
		}
d1070 1
a1070 2
		if (num_fds == -1) {
			close(net_fd);
a1071 1
		}
@


1.172
log
@Support IPv6 proxy addresses

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.171 2016/11/30 07:56:23 mestre Exp $ */
d124 1
d731 27
d761 1
a761 1
	int i;
d768 5
a772 5
	do {
		if ((i = tls_handshake(tls_ctx)) == -1)
			errx(1, "tls handshake failed (%s)",
			    tls_error(tls_ctx));
	} while (i == TLS_WANT_POLLIN || i == TLS_WANT_POLLOUT);
d784 1
d786 6
a791 5
	if (tls_accept_socket(tls_ctx, &tls_cctx,
		connfd) == -1) {
		warnx("tls accept failed (%s)",
		    tls_error(tls_ctx));
		tls_cctx = NULL;
a792 9
		int i;

		do {
			if ((i = tls_handshake(tls_cctx)) == -1)
				warnx("tls handshake failed (%s)",
				    tls_error(tls_cctx));
		} while(i == TLS_WANT_POLLIN || i == TLS_WANT_POLLOUT);
	}
	if (tls_cctx) {
@


1.171
log
@Check return value of tls_config_set_protocols(3) and tls_config_set_ciphers(3)
and bail out in case of failure

Feedback and OK jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.170 2016/11/06 13:33:30 beck Exp $ */
d151 2
a152 2
	char *proxy;
	const char *errstr, *proxyhost = "", *proxyport = NULL;
a428 4
		/* XXX IPv6 transport to proxy would probably work */
		if (family == AF_INET6)
			errx(1, "no proxy support for IPv6");

d432 20
a451 2
		proxyhost = strsep(&proxy, ":");
		proxyport = proxy;
d634 1
a634 1
				    proxyhost, proxyport, proxyhints, socksv,
@


1.170
log
@rename tlslegacy to tlsall, and better describe what it does.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.169 2016/11/05 16:03:09 jmc Exp $ */
d467 5
a471 2
			tls_config_set_protocols(tls_cfg, TLS_PROTOCOLS_ALL);
			tls_config_set_ciphers(tls_cfg, "all");
@


1.169
log
@zap trailing whitespace, and add -o to usage() and help (-h);
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.168 2016/11/05 15:13:26 beck Exp $ */
d70 1
a70 1
#define TLS_LEGACY	(1 << 1)
d466 1
a466 1
		if (TLSopt & TLS_LEGACY) {
d1512 1
a1512 1
		{ "tlslegacy",		TLS_LEGACY },
@


1.168
log
@Add support for server side OCSP stapling to libtls.
Add support for server side OCSP stapling to netcat.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.167 2016/11/04 05:13:13 beck Exp $ */
d1643 1
d1671 4
a1674 2
	    "\t  [-P proxy_username] [-p source_port] [-R CAfile] [-s source]\n"
	    "\t  [-T keyword] [-V rtable] [-w timeout] [-X proxy_protocol]\n"
@


1.167
log
@Add ocsp_require_stapling config option for tls - allows a connection
to indicate that it requires the peer to provide a stapled OCSP response
with the handshake.  Provide a "-T muststaple" for nc that uses it.
ok jsing@@, guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.166 2016/11/03 15:54:39 beck Exp $ */
d103 1
d167 1
a167 1
	    "46C:cDde:FH:hI:i:K:klM:m:NnO:P:p:R:rSs:T:tUuV:vw:X:x:z")) != -1) {
d299 3
d387 2
d463 2
@


1.166
log
@make OCSP_URL only show up when an OCSP url is actually present in the cert
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.165 2016/11/03 15:52:10 beck Exp $ */
d74 1
d472 2
d1508 1
@


1.165
log
@Make OCSP Stapling: only appear if there is stapling info present.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.164 2016/11/02 15:18:42 beck Exp $ */
d1541 2
a1542 1
	fprintf(stderr, "OCSP URL: %s\n", ocsp_url == NULL ? "" : ocsp_url);
@


1.164
log
@Add OCSP client side support to libtls.
   - Provide access to certificate OCSP URL
   - Provide ability to check a raw OCSP reply against an
     established TLS ctx
   - Check and validate OCSP stapling info in the TLS handshake
     if a stapled OCSP response is provided.`

Add example code to show OCSP URL and stapled info
into netcat.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.163 2016/09/03 17:35:34 bcook Exp $ */
a1541 1
	fprintf(stderr, "OCSP Stapling:");
d1544 1
a1544 1
		fprintf(stderr, " %s\n",
a1562 1
		fprintf(stderr, "\n");
d1565 1
a1565 1
		fprintf(stderr, " failure - response_status %d (%s)\n",
@


1.163
log
@squash some possibly-used-uninitialized warnings
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.162 2016/08/13 13:09:10 jsing Exp $ */
d1521 2
d1540 34
@


1.162
log
@Let libtls load the CA, certificate and key files for nc(1), now that it
does this at the time the tls_config_set_*_file() function is called.

ok bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.161 2016/07/30 22:04:04 halex Exp $ */
d828 1
a828 1
	int s, error, on = 1, save_errno;
d914 1
a914 1
	int s, ret, x = 1, save_errno;
@


1.161
log
@use the style from the man page examples for getaddrinfo, which makes a
bit more sense

ok jung@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.160 2016/07/13 16:35:47 jsing Exp $ */
a106 6
uint8_t *cacert;
size_t  cacertlen;
uint8_t *privkey;
size_t  privkeylen;
uint8_t *pubcert;
size_t  pubcertlen;
a440 7
		if (Rflag && (cacert = tls_load_file(Rflag, &cacertlen, NULL)) == NULL)
			errx(1, "unable to load root CA file %s", Rflag);
		if (Cflag && (pubcert = tls_load_file(Cflag, &pubcertlen, NULL)) == NULL)
			errx(1, "unable to load TLS certificate file %s", Cflag);
		if (Kflag && (privkey = tls_load_file(Kflag, &privkeylen, NULL)) == NULL)
			errx(1, "unable to load TLS key file %s", Kflag);

d442 1
a442 1
			if (pledge("stdio inet dns tty", NULL) == -1)
d444 1
a444 1
		} else if (pledge("stdio inet dns", NULL) == -1)
d451 6
a456 6
		if (Rflag && tls_config_set_ca_mem(tls_cfg, cacert, cacertlen) == -1)
			errx(1, "unable to set root CA file %s", Rflag);
		if (Cflag && tls_config_set_cert_mem(tls_cfg, pubcert, pubcertlen) == -1)
			errx(1, "unable to set TLS certificate file %s", Cflag);
		if (Kflag && tls_config_set_key_mem(tls_cfg, privkey, privkeylen) == -1)
			errx(1, "unable to set TLS key file %s", Kflag);
d471 6
@


1.160
log
@Adjust existing tls_config_set_cipher() callers for TLS cipher group
changes - map the previous configuration to the equivalent in the new
groups. This will be revisited post release.

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.159 2016/07/07 14:09:44 jsing Exp $ */
d837 1
a837 1
	if ((error = getaddrinfo(host, port, &hints, &res)))
d840 3
a842 4
	res0 = res;
	do {
		if ((s = socket(res0->ai_family, res0->ai_socktype |
		    SOCK_NONBLOCK, res0->ai_protocol)) < 0)
d852 1
a852 1
			ahints.ai_family = res0->ai_family;
d865 1
a865 1
		set_common_sockopts(s, res0->ai_family);
d867 1
a867 1
		if (timeout_connect(s, res0->ai_addr, res0->ai_addrlen) == 0)
d877 1
a877 1
	} while ((res0 = res0->ai_next) != NULL);
d879 1
a879 1
	freeaddrinfo(res);
d934 1
a934 1
	if ((error = getaddrinfo(host, port, &hints, &res)))
d937 3
a939 4
	res0 = res;
	do {
		if ((s = socket(res0->ai_family, res0->ai_socktype,
		    res0->ai_protocol)) < 0)
d946 1
a946 1
		set_common_sockopts(s, res0->ai_family);
d948 2
a949 2
		if (bind(s, (struct sockaddr *)res0->ai_addr,
		    res0->ai_addrlen) == 0)
d956 1
a956 1
	} while ((res0 = res0->ai_next) != NULL);
d963 1
a963 1
	freeaddrinfo(res);
@


1.159
log
@Revert previous since the libtls change has been reverted.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.157 2016/07/01 00:29:14 bcook Exp $ */
d472 1
a472 1
			tls_config_set_ciphers(tls_cfg, "legacy");
@


1.158
log
@Remove manual file loading (now that libtls does this for us) and adjust
pledge to match. Also use tls_config_error() to provide friendlier error
messages.
@
text
@d68 1
d102 1
a102 1
char    *Rflag;					/* Root CA file */
d107 6
d447 7
d455 1
a455 1
			if (pledge("stdio inet dns rpath tty", NULL) == -1)
d457 1
a457 1
		} else if (pledge("stdio inet dns rpath", NULL) == -1)
d464 6
a469 6
		if (Rflag && tls_config_set_ca_file(tls_cfg, Rflag) == -1)
			errx(1, "%s", tls_config_error(tls_cfg));
		if (Cflag && tls_config_set_cert_file(tls_cfg, Cflag) == -1)
			errx(1, "%s", tls_config_error(tls_cfg));
		if (Kflag && tls_config_set_key_file(tls_cfg, Kflag) == -1)
			errx(1, "%s", tls_config_error(tls_cfg));
a483 6

		if (Pflag) {
			if (pledge("stdio inet dns tty", NULL) == -1)
				err(1, "pledge");
		} else if (pledge("stdio inet dns", NULL) == -1)
			err(1, "pledge");
@


1.157
log
@Simplify IP proto-specific sockopt error handling.

This makes error messages more specific and simplifies
masking compatible sections for the portable version.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.156 2016/06/28 17:35:14 jca Exp $ */
a67 1
#define DEFAULT_CA_FILE "/etc/ssl/cert.pem"
d101 1
a101 1
char    *Rflag = DEFAULT_CA_FILE;		/* Root CA file */
a105 6
uint8_t *cacert;
size_t  cacertlen;
uint8_t *privkey;
size_t  privkeylen;
uint8_t *pubcert;
size_t  pubcertlen;
a439 7
		if (Rflag && (cacert = tls_load_file(Rflag, &cacertlen, NULL)) == NULL)
			errx(1, "unable to load root CA file %s", Rflag);
		if (Cflag && (pubcert = tls_load_file(Cflag, &pubcertlen, NULL)) == NULL)
			errx(1, "unable to load TLS certificate file %s", Cflag);
		if (Kflag && (privkey = tls_load_file(Kflag, &privkeylen, NULL)) == NULL)
			errx(1, "unable to load TLS key file %s", Kflag);

d441 1
a441 1
			if (pledge("stdio inet dns tty", NULL) == -1)
d443 1
a443 1
		} else if (pledge("stdio inet dns", NULL) == -1)
d450 6
a455 6
		if (Rflag && tls_config_set_ca_mem(tls_cfg, cacert, cacertlen) == -1)
			errx(1, "unable to set root CA file %s", Rflag);
		if (Cflag && tls_config_set_cert_mem(tls_cfg, pubcert, pubcertlen) == -1)
			errx(1, "unable to set TLS certificate file %s", Cflag);
		if (Kflag && tls_config_set_key_mem(tls_cfg, privkey, privkeylen) == -1)
			errx(1, "unable to set TLS key file %s", Kflag);
d470 6
@


1.156
log
@Add -M and -m options to specify the outgoing and incoming minimum TTL

Req by and ok blumh@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.155 2016/06/28 00:01:10 deraadt Exp $ */
d1415 3
a1417 1
		int proto, option;
d1419 3
a1421 10
		if (af == AF_INET6) {
			proto = IPPROTO_IPV6;
			option = IPV6_TCLASS;
		} else {
			proto = IPPROTO_IP;
			option = IP_TOS;
		}

		if (setsockopt(s, proto, option, &Tflag, sizeof(Tflag)) == -1)
			err(1, "set IP ToS");
d1433 19
a1451 22
	if (ttl != -1 || minttl != -1) {
		int proto, in_ttl_opt, out_ttl_opt;
		switch (af) {
		case AF_INET:
			proto = IPPROTO_IP;
			in_ttl_opt = IP_MINTTL;
			out_ttl_opt = IP_TTL;
			break;
		case AF_INET6:
			proto = IPPROTO_IPV6;
			in_ttl_opt = IPV6_MINHOPCOUNT;
			out_ttl_opt = IPV6_UNICAST_HOPS;
			break;
		default:
			errx(1, "unknown address family: %d", af);
		}
		if (minttl != -1 && setsockopt(s, proto, in_ttl_opt,
		    &minttl, sizeof(minttl)))
			err(1, "setsockopt minttl");
		if (ttl != -1 && setsockopt(s, proto, out_ttl_opt,
		    &ttl, sizeof(ttl)))
			err(1, "setsockopt ttl");
@


1.155
log
@If an error path if close() is called, save errno so that original error
is shown by errx
ok millert krw
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.154 2016/06/27 23:58:08 deraadt Exp $ */
d118 2
d171 1
a171 1
	    "46C:cDde:FH:hI:i:K:klNnO:P:p:R:rSs:T:tUuV:vw:X:x:z")) != -1) {
d227 10
d1438 23
d1608 2
d1639 4
a1642 5
	    "\t  [-i interval] [-K keyfile] [-O length] [-P proxy_username]\n"
	    "\t  [-p source_port] [-R CAfile] [-s source] "
	    "[-T keyword] [-V rtable]\n"
	    "\t  [-w timeout] [-X proxy_protocol] [-x proxy_address[:port]]\n"
	    "\t  [destination] [port]\n");
@


1.154
log
@Be more careful initializing and tracking socket s through main, this is
so complicated that a future refactoring could easily in introduce a bug.
ok millert krw
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.153 2016/06/02 04:26:32 beck Exp $ */
d671 1
a671 1
	int s;
d689 1
d691 1
d767 1
a767 1
	int s;
d787 1
d789 1
d823 1
a823 1
	int s, error, on = 1;
d862 1
d864 1
d910 1
a910 1
	int s, ret, x = 1;
d942 1
d944 1
@


1.153
log
@Let netcat support the use of service names instead of port numbers.
based on a diff from Andras Farkas <deepbluemistake@@gmail.com>
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.152 2016/05/28 20:14:58 beck Exp $ */
d147 1
a147 1
	int ch, s, ret, socksv;
a160 1
	s = 0;
d588 2
a589 2
		for (i = 0; portlist[i] != NULL; i++) {
			if (s)
d606 1
a606 1
			if (s < 0)
d655 1
a655 1
	if (s)
@


1.152
log
@Fix pledge violation with -P s used and we need to supply a password
for an http proxy - we need tty in this case.  Found and fixed by
Anthony Coulter <bsd@@anthonycoulter.name>.
ok tb@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.151 2016/05/28 19:39:16 beck Exp $ */
d1286 21
a1314 1
	const char *errstr;
d1324 2
a1325 7
		hi = strtonum(n, 1, PORT_MAX, &errstr);
		if (errstr)
			errx(1, "port number %s: %s", errstr, n);
		lo = strtonum(p, 1, PORT_MAX, &errstr);
		if (errstr)
			errx(1, "port number %s: %s", errstr, p);

d1351 6
a1356 5
		hi = strtonum(p, 1, PORT_MAX, &errstr);
		if (errstr)
			errx(1, "port number %s: %s", errstr, p);
		portlist[0] = strdup(p);
		if (portlist[0] == NULL)
@


1.151
log
@Fix nc -verbose mode when used on a unix domain socket.
Noticed by and a modified version of fix from <attila@@stalphonsos.com>
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.150 2016/01/04 02:18:31 bcook Exp $ */
d326 7
a332 1
		if (pledge("stdio inet dns sendfd", NULL) == -1)
d443 4
a446 1
		if (pledge("stdio inet dns", NULL) == -1)
@


1.150
log
@Use the correct values for TLS certificate / private key flags.

fix from Andreas Bartelt <obsd at bartula.de>
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.149 2015/12/28 14:17:47 bcook Exp $ */
d136 1
a136 1
void	report_connect(const struct sockaddr *, socklen_t);
d519 1
a519 1
					report_connect((struct sockaddr *)&z, len);
d531 2
a532 1
					report_connect((struct sockaddr *)&cliaddr, len);
d1491 1
a1491 1
report_connect(const struct sockaddr *sa, socklen_t salen)
d1497 5
@


1.149
log
@include time.h over sys/time.h for ctime(3)

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.148 2015/12/17 19:30:28 mmcc Exp $ */
d430 1
a430 1
		if (Rflag && (cacert=tls_load_file(Rflag, &cacertlen, NULL)) == NULL)
d432 1
a432 1
		if (Cflag && (pubcert=tls_load_file(Rflag, &pubcertlen, NULL)) == NULL)
d434 1
a434 1
		if (Kflag && (privkey=tls_load_file(Rflag, &privkeylen, NULL)) == NULL)
d446 1
a446 1
		if (Cflag && tls_config_set_cert_mem(tls_cfg, cacert, cacertlen) == -1)
@


1.148
log
@Add missing colon after "Peer name" in verbose output. Mentioned on the
lists recently.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.147 2015/12/16 14:23:33 beck Exp $ */
a36 1
#include <sys/time.h>
d55 1
@


1.147
log
@clean up some unused variables, and add the printing of the certificate validity
to the verbose output when using tls - from rob@@2keys.ca
ok mmcc@@ jsing@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.146 2015/12/08 15:33:33 beck Exp $ */
d1472 1
a1472 1
	fprintf(stderr, "Peer name %s\n",
@


1.146
log
@pledge nc better - Load the certificate into memory and then do the pledge,
this allows us to drop the rpath fromt the nc pledge.
ok deraadt@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.145 2015/12/07 02:38:54 tb Exp $ */
d1469 1
a1469 1
	char *subject = NULL, *issuer = NULL;
d1480 4
a1486 2
	free(subject);
	free(issuer);
d1488 1
@


1.145
log
@Get rid of modulo bias and replace the naive shuffle by the
Knuth-Fisher-Yates shuffle to make the random sequence of ports
less biased.  Based on the implementation in sys/netinet/ip_id.c.
With helpful input from daniel@@ and beck@@

ok beck@@ despite eye twitching
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.144 2015/11/23 01:23:56 bcook Exp $ */
d107 6
d430 10
d444 3
a446 1
		if (Cflag && (tls_config_set_cert_file(tls_cfg, Cflag) == -1))
d448 1
a448 1
		if (Kflag && (tls_config_set_key_file(tls_cfg, Kflag) == -1))
a449 2
		if (Rflag && (tls_config_set_ca_file(tls_cfg, Rflag) == -1))
			errx(1, "unable to set root CA file %s", Rflag);
@


1.144
log
@rename variable 'sun' to allow building on Solaris

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.143 2015/11/13 18:13:13 deraadt Exp $ */
a60 1
#define PORT_MAX_LEN	6
d1291 4
a1294 10
		/* Load ports sequentially. */
		for (cp = lo; cp <= hi; cp++) {
			portlist[x] = calloc(1, PORT_MAX_LEN);
			if (portlist[x] == NULL)
				err(1, NULL);
			snprintf(portlist[x], PORT_MAX_LEN, "%d", cp);
			x++;
		}

		/* Randomly swap ports. */
d1296 11
a1306 8
			int y;
			char *c;

			for (x = 0; x <= (hi - lo); x++) {
				y = (arc4random() & 0xFFFF) % (hi - lo);
				c = portlist[x];
				portlist[x] = portlist[y];
				portlist[y] = c;
@


1.143
log
@Since rtable was hoisted to the top with setrtable, it should have no
bearing on the following pledge setups anymore.
ok benno
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.142 2015/11/12 20:33:52 benno Exp $ */
d646 1
a646 1
	struct sockaddr_un sun;
d654 2
a655 2
	memset(&sun, 0, sizeof(struct sockaddr_un));
	sun.sun_family = AF_UNIX;
d657 2
a658 2
	if (strlcpy(sun.sun_path, path, sizeof(sun.sun_path)) >=
	    sizeof(sun.sun_path)) {
d664 1
a664 1
	if (bind(s, (struct sockaddr *)&sun, sizeof(sun)) < 0) {
d740 1
a740 1
	struct sockaddr_un sun;
d751 2
a752 2
	memset(&sun, 0, sizeof(struct sockaddr_un));
	sun.sun_family = AF_UNIX;
d754 2
a755 2
	if (strlcpy(sun.sun_path, path, sizeof(sun.sun_path)) >=
	    sizeof(sun.sun_path)) {
d760 1
a760 1
	if (connect(s, (struct sockaddr *)&sun, sizeof(sun)) < 0) {
@


1.142
log
@with -V argument, dont set rtable on the socket, instead set if for the whole
process, before pledge(). This way the rtable can be pledged too.
the discussion about removing -V is postponed.

diff from beck@@, i wrote the same diff without seeing his, and various
people at u2k15 agreed this is the right thing to do.
ok phessler@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.141 2015/11/01 01:05:31 deraadt Exp $ */
d313 1
a313 1
	if (rtableid >= 0) {
d316 1
a316 1
	}
d320 1
a320 2
	}
	else if (Fflag) {
d323 1
a323 2
	}
	else if (usetls) {
d326 1
a326 2
	}
	else if (pledge("stdio inet dns", NULL) == -1)
d830 1
a830 1
		else if (vflag)
@


1.141
log
@KNF; from Rob Pierce
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.140 2015/10/23 05:27:17 beck Exp $ */
d314 2
a315 5
		/*
		 * XXX No pledge if doing rtable manipulation!
		 * XXX the routing table stuff is dangerous and can't be pledged.
		 * XXX rtable should really have a better interface than sockopt
		 */
d317 1
a317 1
	else if (family == AF_UNIX) {
a808 4
		if (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_RTABLE,
		    &rtableid, sizeof(rtableid)) == -1))
			err(1, "setsockopt SO_RTABLE");

a903 4

		if (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_RTABLE,
		    &rtableid, sizeof(rtableid)) == -1))
			err(1, "setsockopt SO_RTABLE");
@


1.140
log
@Initial pledge of netcat - unfortunately flawed because fiddling the rtableid
in a socket option can be pretty scary and there is no better interface for this.
so if the -V option is used you get no pledge at all.. Otherwise, do what
works for the various options.  Still needs refinement for tls to drop rpath,
and a better solution for the routing table stuff
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.139 2015/10/11 00:26:23 guenther Exp $ */
a678 1

d698 1
d738 1
a1163 1

@


1.139
log
@Userspace doesn't need to use SUN_LEN(): connect() and bind() must accept
sizeof(struct sockaddr_un), so do the simple, portable thing

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.138 2015/09/13 11:12:09 beck Exp $ */
d313 22
d362 4
@


1.138
log
@display negotiated TLS version and cipher suite in verbose mode.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.137 2015/09/12 21:01:14 beck Exp $ */
a59 5
#ifndef SUN_LEN
#define SUN_LEN(su) \
	(sizeof(*(su)) - sizeof((su)->sun_path) + strlen((su)->sun_path))
#endif

d644 1
a644 1
	if (bind(s, (struct sockaddr *)&sun, SUN_LEN(&sun)) < 0) {
d739 1
a739 1
	if (connect(s, (struct sockaddr *)&sun, SUN_LEN(&sun)) < 0) {
@


1.137
log
@Adapt to just committed libtls api change
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.136 2015/09/12 08:38:33 deraadt Exp $ */
d1451 2
a1452 1
	fprintf(stderr, "TLS handshake completed with %s\n", host);
@


1.136
log
@use SOCK_CLOEXEC instead of fnctl; ok guenther beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.135 2015/09/12 07:56:56 jmc Exp $ */
a111 1
char	*tls_peerhash;				/* hash of peer cert */
a618 1
	free(tls_peerhash);
a671 2
	if (tls_peer_cert_hash(tls_ctx, &tls_peerhash) == -1)
		errx(1, "hash of peer certificate failed");
d674 2
a675 2
	if (tls_expecthash && tls_peerhash &&
	    strcmp(tls_expecthash, tls_peerhash) != 0)
a699 2
		if (gotcert && tls_peer_cert_hash(tls_cctx, &tls_peerhash) == -1)
			warn("hash of peer certificate failed");
d704 2
a705 2
		else if (gotcert && tls_peerhash && tls_expecthash &&
		    strcmp(tls_expecthash, tls_peerhash) != 0)
a1450 4
	if (tls_peer_cert_subject(tls_ctx, &subject) == -1)
		errx(1, "unable to get certificate subject");
	if (tls_peer_cert_issuer(tls_ctx, &issuer) == -1)
		errx(1, "unable to get certificate issuer");
d1454 9
a1462 6
	if (subject)
		fprintf(stderr, "Subject: %s\n", subject);
	if (issuer)
		fprintf(stderr, "Issuer: %s\n", issuer);
	if (tls_peerhash)
		fprintf(stderr, "Cert Hash: %s\n", tls_peerhash);
@


1.135
log
@fix previous;
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.134 2015/09/11 21:22:54 deraadt Exp $ */
a47 1
#include <fcntl.h>
d131 1
a131 1
int	unix_bind(char *);
d365 1
a365 1
				UNIX_DG_TMP_SOCKET_SIZE);
d443 1
a443 1
				s = unix_bind(host);
d510 1
d605 1
d631 1
a631 1
unix_bind(char *path)
d637 2
a638 2
	if ((s = socket(AF_UNIX, uflag ? SOCK_DGRAM : SOCK_STREAM,
	     0)) < 0)
d663 1
d686 1
d694 1
d703 1
d734 1
a734 1
		if ((s = unix_bind(unix_dg_tmp_socket)) < 0)
d737 1
a737 1
		if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
a739 1
	(void)fcntl(s, F_SETFD, FD_CLOEXEC);
d766 1
a766 1
	if ((s = unix_bind(path)) < 0)
@


1.134
log
@spaces found during a read
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.133 2015/09/11 21:07:01 beck Exp $ */
d1502 2
d1506 1
d1508 1
d1511 2
a1512 1
	\t-i secs\t	Delay interval for lines sent, ports scanned\n\
d1520 1
d1523 2
a1524 2
	\t-s addr\t	Local source address\n\
	\t-T toskeyword\tSet IP Type of Service\n\
d1530 1
a1530 1
	\t-w secs\t	Timeout for connects and final net reads\n\
d1542 6
a1547 5
	    "usage: nc [-46cDdFhklNnrStUuvz] [-C certfile] [-e name] \n"
	    "\t  [-I length] [-i interval] [-H hash] [-K keyfile] [-O length]\n"
	    "\t  [-P proxy_username] [-p source_port] [-R cafile] [-s source]\n"
	    "\t  [-T tls|toskeyword] [-V rtable] [-w timeout]\n"
	    "\t  [-X proxy_protocol] [-x proxy_address[:port]]\n"
@


1.133
log
@Add TLS suppport to nc. Provides a useful little test and script tool.
ok jsing@@ bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.132 2015/09/08 17:28:47 bluhm Exp $ */
d139 1
a139 1
void	report_tls(struct tls * tls_ctx, char * host, char *tls_expectname);
d144 1
a144 1
struct tls * tls_setup_server(struct tls *, int, char *);
d505 1
a505 2
				    (tls_cctx = tls_setup_server(tls_ctx, connfd,
					host)))
d709 1
a709 1
		    (! tls_peer_cert_contains_name(tls_cctx, tls_expectname)))
d959 2
a960 2
		if (pfd[POLL_STDIN].fd == -1 && pfd[POLL_NETIN].fd == -1
		    && stdinbufpos == 0 && netinbufpos == 0) {
d970 2
a971 2
		if (lflag && pfd[POLL_NETIN].fd == -1
		    && stdinbufpos == 0 && netinbufpos == 0) {
d1004 2
a1005 2
		    ! (pfd[POLL_STDIN].revents & POLLIN))
				pfd[POLL_STDIN].fd = -1;
d1009 2
a1010 2
		    ! (pfd[POLL_NETIN].revents & POLLIN))
				pfd[POLL_NETIN].fd = -1;
d1413 1
a1413 1
		{ NULL, 		-1 },
d1437 1
a1437 1
		{ NULL, 		-1 },
d1476 1
a1476 1
	
d1479 1
a1479 1
	
d1489 1
a1489 1
	
@


1.132
log
@Netcat could hang during write(2) although poll(2) reports that the
socket is writeable.  This happens because netcat tries to write
more than the low water mark of the socket write buffer.  With a
non-blocking socket you may get a short write, otherwise it blocks.
The latter could cause a total hang of the netcat process depending
on the upper protocol.  So make the network connection non-blocking.
OK claudio@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.131 2015/09/03 23:06:28 sobrado Exp $ */
d4 1
d58 1
d75 6
d106 10
d125 1
a125 1
void	readwrite(int);
d137 1
d139 1
d141 4
a144 2
ssize_t drainbuf(int, unsigned char *, size_t *);
ssize_t fillbuf(int, unsigned char *, size_t *);
d159 2
d172 1
a172 1
	    "46DdFhI:i:klNnO:P:p:rSs:tT:UuV:vw:X:x:z")) != -1) {
d193 6
d202 3
d208 3
d219 3
d240 4
d302 2
d311 1
a311 1
				errx(1, "illegal tos value %s", optarg);
d343 16
d411 26
d438 1
d449 8
d468 1
a468 1
				readwrite(s);
d493 1
a493 1
				readwrite(s);
d504 15
a518 2

				readwrite(connfd);
a520 1

d535 1
a535 1
			readwrite(s);
d555 7
d599 15
a613 2
			else if (!zflag)
				readwrite(s);
d620 3
d658 61
d926 1
a926 1
readwrite(int net_fd)
d1034 6
a1039 3
			    &stdinbufpos);
			/* error or eof on stdin - remove from pfd */
			if (ret == 0 || ret == -1)
d1051 6
a1056 2
			    &stdinbufpos);
			if (ret == -1)
d1068 6
a1073 2
			    &netinbufpos);
			if (ret == -1)
d1094 6
a1099 2
			    &netinbufpos);
			if (ret == -1)
d1123 1
a1123 1
drainbuf(int fd, unsigned char *buf, size_t *bufpos)
d1128 8
a1135 4
	n = write(fd, buf, *bufpos);
	/* don't treat EAGAIN, EINTR as error */
	if (n == -1 && (errno == EAGAIN || errno == EINTR))
		n = -2;
d1148 1
a1148 1
fillbuf(int fd, unsigned char *buf, size_t *bufpos)
d1153 8
a1160 4
	n = read(fd, buf + *bufpos, num);
	/* don't treat EAGAIN, EINTR as error */
	if (n == -1 && (errno == EAGAIN || errno == EINTR))
		n = -2;
d1427 43
d1537 6
a1542 4
	    "usage: nc [-46DdFhklNnrStUuvz] [-I length] [-i interval] [-O length]\n"
	    "\t  [-P proxy_username] [-p source_port] [-s source] [-T toskeyword]\n"
	    "\t  [-V rtable] [-w timeout] [-X proxy_protocol]\n"
	    "\t  [-x proxy_address[:port]] [destination] [port]\n");
@


1.131
log
@synchronize synopsis and usage.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.130 2015/07/26 19:12:28 chl Exp $ */
d400 2
a401 2
				connfd = accept(s, (struct sockaddr *)&cliaddr,
				    &len);
d597 2
a598 2
		if ((s = socket(res0->ai_family, res0->ai_socktype,
		    res0->ai_protocol)) < 0)
d647 1
a647 1
	int flags, optval;
a649 6
	if (timeout != -1) {
		flags = fcntl(s, F_GETFL, 0);
		if (fcntl(s, F_SETFL, flags | O_NONBLOCK) == -1)
			err(1, "set non-blocking mode");
	}

a665 3

	if (timeout != -1 && fcntl(s, F_SETFL, flags) == -1)
		err(1, "restoring flags");
@


1.130
log
@remove unused variable

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.129 2015/03/26 21:22:50 tobias Exp $ */
d1289 1
a1289 1
	    "\t  [-P proxy_username] [-p source_port] [-s source] [-T ToS]\n"
@


1.129
log
@The code in socks.c writes multiple times in a row to a socket. If the
socket becomes invalid between these calls (e.g. connection closed), write
will throw SIGPIPE. With this patch, SIGPIPE is ignored so we can
handle write's -1 return value (errno will be EPIPE). Ultimately, it leads
to program exit, too -- but with nicer error message. :)

with input by and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.128 2015/03/26 10:36:03 tobias Exp $ */
d752 1
a752 1
	int n, num_fds, flags;
@


1.128
log
@Check for short writes in fdpass(). Clean up while at it.

ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.127 2015/02/14 22:40:22 jca Exp $ */
d47 2
d51 1
a56 2
#include <fcntl.h>
#include <limits.h>
d144 2
@


1.127
log
@Support for nc -T on IPv6 addresses.

ok sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.126 2014/10/30 16:08:31 tedu Exp $ */
a982 1
	bzero(&pfd, sizeof(pfd));
d999 1
a1003 1
				pfd.events = POLLOUT;
d1009 1
a1009 1
		} else if (r == -1)
@


1.126
log
@my mistake. we already did increase buffers to 16k; increasing to 64k
would be the next stage of embiggening. restore 16k.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.125 2014/10/30 16:06:07 tedu Exp $ */
d116 1
a116 1
void	set_common_sockopts(int);
d622 1
a622 1
		set_common_sockopts(s);
d715 1
a715 1
		set_common_sockopts(s);
d1131 1
a1131 1
set_common_sockopts(int s)
d1146 11
a1156 2
		if (setsockopt(s, IPPROTO_IP, IP_TOS,
		    &Tflag, sizeof(Tflag)) == -1)
@


1.125
log
@rework the poll loop to poll in both directions so it doesn't get stuck
if one pipe stalls out. from a diff by Arne Becker.
(buffer size left alone for now)
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.124 2014/10/26 13:59:30 millert Exp $ */
d71 1
a71 1
#define BUFSIZE 2048
@


1.124
log
@POLLIN is not guaranteed to be set in revents for EOF so check for
POLLHUP too.  OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.123 2014/10/24 02:01:20 lteo Exp $ */
d67 6
d120 2
d401 1
a401 1
   					err(1, "accept");
d740 1
a740 1
readwrite(int nfd)
d742 48
a789 15
	struct pollfd pfd[2];
	unsigned char buf[16 * 1024];
	int n, wfd = fileno(stdin);
	int lfd = fileno(stdout);
	int plen;

	plen = sizeof(buf);

	/* Setup Network FD */
	pfd[0].fd = nfd;
	pfd[0].events = POLLIN;

	/* Set up STDIN FD. */
	pfd[1].fd = wfd;
	pfd[1].events = POLLIN;
d791 3
a793 1
	while (pfd[0].fd != -1) {
d797 7
a803 4
		if ((n = poll(pfd, 2 - dflag, timeout)) < 0) {
			int saved_errno = errno;
			close(nfd);
			errc(1, saved_errno, "Polling Error");
d806 2
a807 1
		if (n == 0)
d810 4
a813 12
		if (pfd[0].revents & (POLLIN|POLLHUP)) {
			if ((n = read(nfd, buf, plen)) < 0)
				return;
			else if (n == 0) {
				shutdown(nfd, SHUT_RD);
				pfd[0].fd = -1;
				pfd[0].events = 0;
			} else {
				if (tflag)
					atelnet(nfd, buf, n);
				if (atomicio(vwrite, lfd, buf, n) != n)
					return;
d816 28
d845 37
a881 11
		if (!dflag && pfd[1].revents & (POLLIN|POLLHUP)) {
			if ((n = read(wfd, buf, plen)) < 0)
				return;
			else if (n == 0) {
				if (Nflag)
					shutdown(nfd, SHUT_WR);
				pfd[1].fd = -1;
				pfd[1].events = 0;
			} else {
				if (atomicio(vwrite, nfd, buf, n) != n)
					return;
d883 34
d919 37
@


1.123
log
@Remove unnecessary include: netinet/in_systm.h is not needed by these
programs.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.122 2014/07/20 01:38:40 guenther Exp $ */
d763 1
a763 1
		if (pfd[0].revents & POLLIN) {
d778 1
a778 1
		if (!dflag && pfd[1].revents & POLLIN) {
@


1.122
log
@Make sure the correct errno is reported by warn* or err* and not
the errno of an intervening cleanup operation like close/unlink/etc.

Diff from Doug Hogan (doug (at) acyclic.org)
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.121 2014/06/10 16:35:42 tedu Exp $ */
a40 1
#include <netinet/in_systm.h>
@


1.121
log
@stick with 16k buffers for a little while to avoid bufferbloat.
atomicio writing out 64k in one direction will cause traffic in the other
direction to stall until it's complete. discussion with deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.120 2014/06/10 16:23:07 tedu Exp $ */
d756 1
d758 1
a758 1
			err(1, "Polling Error");
@


1.120
log
@increase buffer size to 64k, and actually use it. ok deraadt
from John-Mark Gurney
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.119 2014/05/20 01:25:23 guenther Exp $ */
d736 1
a736 1
	unsigned char buf[64 * 1024];
@


1.119
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.118 2014/03/12 10:19:40 jca Exp $ */
d736 1
a736 1
	unsigned char buf[16384];
d741 1
a741 1
	plen = 2048;
@


1.118
log
@Unbreak nc -6 -l.  Don't retrieve and thus later set the routing table
unless -V is passed (intent of the previous commit), and use SOL_SOCKET
instead of IPPROTO_IP to set the rtable in local_listen().  ok sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.117 2013/10/26 21:33:29 sthen Exp $ */
d611 1
a611 1
				errx(1, "bind failed: %s", strerror(errno));
@


1.117
log
@Only use setsockopt(..SO_RTABLE..) if the -V flag is given to nc/telnet,
same style as traceroute6 (change to int and use -1 as a flag, so rtable 0
can still be used as an explicit parameter).
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.116 2013/10/21 09:12:55 phessler Exp $ */
a135 1
	rtableid = getrtable();
d700 1
a700 1
		if (rtableid >= 0 && (setsockopt(s, IPPROTO_IP, SO_RTABLE,
@


1.116
log
@Oups, a little bit overzealous.  If we "route -T4 exec telnet foo", then
make sure telnet runs in rdomain 4 as expected.  Same for nc.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.115 2013/10/21 08:59:49 phessler Exp $ */
d90 1
a90 1
u_int	rtableid;
d205 1
a205 1
			rtableid = (unsigned int)strtonum(optarg, 0,
d592 2
a593 2
		if (setsockopt(s, SOL_SOCKET, SO_RTABLE, &rtableid,
		    sizeof(rtableid)) == -1)
d701 2
a702 2
		if (setsockopt(s, SOL_SOCKET, SO_RTABLE, &rtableid,
		    sizeof(rtableid)) == -1)
@


1.115
log
@Set the requested rdomain on the socket instead of only on the IPv4 part.

Also, switching to rdomain zero is a legit option so we should allow that.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.114 2013/08/20 21:04:40 jmc Exp $ */
d136 1
@


1.114
log
@add -F to usage() and help();
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.113 2013/08/20 16:22:09 djm Exp $ */
d591 3
a593 5
		if (rtableid) {
			if (setsockopt(s, SOL_SOCKET, SO_RTABLE, &rtableid,
			    sizeof(rtableid)) == -1)
				err(1, "setsockopt SO_RTABLE");
		}
d700 3
a702 5
		if (rtableid) {
			if (setsockopt(s, IPPROTO_IP, SO_RTABLE, &rtableid,
			    sizeof(rtableid)) == -1)
				err(1, "setsockopt SO_RTABLE");
		}
@


1.113
log
@add -F flag to enabled fd-pass mode: establish connection and pass
connected socket to stdout. This is useful in proxy mode to establish
a connection for use by ssh in conjunction with its new ProxyUseFDPass
option; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.112 2013/04/29 00:28:23 okan Exp $ */
d1085 1
d1117 1
a1117 1
	    "usage: nc [-46DdhklNnrStUuvz] [-I length] [-i interval] [-O length]\n"
@


1.112
log
@use FD_CLOEXEC instead of 1; from David Hill

ok otto
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.111 2013/03/20 09:27:56 sthen Exp $ */
d37 1
d70 1
d102 1
d138 1
a138 1
	    "46DdhI:i:klNnO:P:p:rSs:tT:UuV:vw:X:x:z")) != -1) {
d162 3
d472 3
a474 1
			if (!zflag)
d796 60
@


1.111
log
@Don't shutdown nc(1)'s network socket when stdin closes. Matches *Hobbit*'s
original netcat and GNU netcat; revert to old behaviour with the new -N flag
if needed. After much discussion with otto deraadt tedu and Martin Pelikan.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.110 2013/03/12 02:57:37 deraadt Exp $ */
d526 1
a526 1
	(void)fcntl(s, F_SETFD, 1);
@


1.110
log
@All accept() errors are considered fatal, until someone gives a different
reason.  No code changed, just documenting it...
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.109 2012/07/07 15:33:02 haesbaert Exp $ */
d72 1
d135 1
a135 1
	    "46DdhI:i:klnO:P:p:rSs:tT:UuV:vw:X:x:z")) != -1) {
d173 3
d778 2
a779 1
				shutdown(nfd, SHUT_WR);
d1022 1
d1048 1
a1048 1
	    "usage: nc [-46DdhklnrStUuvz] [-I length] [-i interval] [-O length]\n"
@


1.109
log
@Allow UDP server to receive datagrams from multiple socket pairs with -k
flag. Prompted by a question from dsp at 2f30 dot org, diff from Lazarom
Koromil with a few tweaks by me, many thanks.

ok mikeb@@ nicm@@ haesbaert@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.108 2012/07/07 09:36:30 haesbaert Exp $ */
d382 4
a385 3
				if (connfd == -1)
					err(1, "accept");

@


1.108
log
@Report incoming connections when -l is specified with -v.

From Ricky Zhou with a few tweaks by me.

ok henning@@ haesbaert@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.107 2012/04/01 02:58:57 deraadt Exp $ */
d348 2
a349 3
			 * For UDP, we will use recvfrom() initially
			 * to wait for a caller, then use the regular
			 * functions to talk to the caller.
d351 8
a358 1
			if (uflag) {
@


1.107
log
@error out if accept() fails
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.106 2012/03/17 10:16:41 dlg Exp $ */
d109 1
d368 3
d378 4
d968 26
@


1.106
log
@remove IP_JUMBO, SO_JUMBO, and RTF_JUMBO.

no objection from mcbride@@ krw@@ markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.105 2012/02/09 06:25:35 lum Exp $ */
d372 2
@


1.105
log
@Update comments. ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.104 2012/02/09 03:27:36 lum Exp $ */
a69 1
int	jflag;					/* use jumbo frames if we can */
d133 1
a133 1
	    "46DdhI:i:jklnO:P:p:rSs:tT:UuV:vw:X:x:z")) != -1) {
a164 3
		case 'j':
			jflag = 1;
			break;
d357 1
a357 1
				plen = jflag ? 16384 : 2048;
d716 1
a716 1
	plen = jflag ? 16384 : 2048;
a891 5
			&x, sizeof(x)) == -1)
			err(1, NULL);
	}
	if (jflag) {
		if (setsockopt(s, SOL_SOCKET, SO_JUMBO,
@


1.104
log
@Remove unused protocol value check. ok brynet@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.103 2011/10/04 08:34:34 fgsch Exp $ */
d805 1
a805 1
 * Build an array or ports in portlist[], listing each port
d868 1
a868 2
 * XXX - Better way of doing this? Doesn't work for IPv6.
 * Also fails after around 100 ports checked.
@


1.103
log
@change -w to apply to the connection as well. manpage bit from jmc@@
nicm@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.102 2011/09/17 14:10:05 haesbaert Exp $ */
a816 3
		if (lflag)
			errx(1, "Cannot use -l with multiple ports!");

@


1.102
log
@Standarize the ToS option across nc/ping/traceroute so that they'll
accept the same values as pf.conf. It accepts decimal, hexadecimal and
the dscp/tos keywords. The ping option was ripped of in SMALL.

ok mcbride@@ sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.101 2011/06/21 17:31:07 mikeb Exp $ */
d101 1
d594 1
a594 1
		if (connect(s, res0->ai_addr, res0->ai_addrlen) == 0)
d607 37
@


1.101
log
@Convert SO_RTABLE's protocol level to the SOL_SOCKET;  ok claudio
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.100 2011/01/09 22:16:46 jeremy Exp $ */
d108 1
a108 1
int	parse_iptos(char *);
d237 12
a248 1
			Tflag = parse_iptos(optarg);
d888 1
a888 1
parse_iptos(char *s)
d890 41
a930 1
	int tos = -1;
d932 1
a932 10
	if (strcmp(s, "lowdelay") == 0)
		return (IPTOS_LOWDELAY);
	if (strcmp(s, "throughput") == 0)
		return (IPTOS_THROUGHPUT);
	if (strcmp(s, "reliability") == 0)
		return (IPTOS_RELIABILITY);

	if (sscanf(s, "0x%x", &tos) != 1 || tos < 0 || tos > 0xff)
		errx(1, "invalid IP Type of Service");
	return (tos);
d956 1
a956 1
	\t-T ToS\t	Set IP Type of Service\n\
@


1.100
log
@Minor tweaks to nc(1) man page and usage.

OK jmc@@, nicm@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.99 2011/01/08 00:44:19 jeremy Exp $ */
d555 1
a555 1
			if (setsockopt(s, IPPROTO_IP, SO_RTABLE, &rtableid,
@


1.99
log
@Support unix domain sockets in nc(1) with -Uu.

Previously, using -U with -u was an error that was not documented
in the man page.  Now it will use a unix socket in datagram mode.

Bidirectional unix datagram communication requires a socket at
both ends, so in client mode (without -l), a temporary socket is
created so that responses from the server can be received.
If -s is specified with -U and -u, it specifies the location of
the temporary socket to create.

This was mostly written way back in 2007.  Since then, various
improvements implemented based on suggestions from guenther@@,
tedu@@, and nicm@@. Man page help from nicm@@ and jmc@@.

Unix datagram support requires a small change to atomicio.c
in order to function correctly, this will be committed separately
shortly.

OK nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.98 2010/07/03 04:44:51 guenther Exp $ */
d933 1
a933 1
	    "\t  [-P proxy_username] [-p source_port] [-s source_ip_address] [-T ToS]\n"
d935 1
a935 1
	    "\t  [-x proxy_address[:port]] [hostname] [port]\n");
@


1.98
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.97 2010/04/20 07:28:28 nicm Exp $ */
d65 1
d93 1
d104 1
d123 1
a247 2
		if (uflag)
			errx(1, "cannot use -u and -U");
d270 13
d325 6
a330 2
		if (family == AF_UNIX)
			s = unix_listen(host);
d359 1
a359 1
				connfd = s;
d364 2
a367 2
			readwrite(connfd);
			close(connfd);
d370 4
d387 2
d449 2
a450 2
 * unix_connect()
 * Returns a socket connected to a local unix socket. Returns -1 on failure.
d453 1
a453 1
unix_connect(char *path)
d458 3
a460 1
	if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
a461 1
	(void)fcntl(s, F_SETFD, 1);
d472 2
a473 1
	if (connect(s, (struct sockaddr *)&sun, SUN_LEN(&sun)) < 0) {
a477 1

d481 2
a482 2
 * unix_listen()
 * Create a unix domain socket, and listen on it.
d485 1
a485 1
unix_listen(char *path)
d490 8
a497 3
	/* Create unix domain socket. */
	if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
		return (-1);
d508 1
a508 2

	if (bind(s, (struct sockaddr *)&sun, SUN_LEN(&sun)) < 0) {
d512 14
@


1.97
log
@Bump the default buffer sizes to be larger than default MTUs, from Jan
Zeleny.

ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.96 2010/04/20 07:26:34 nicm Exp $ */
d87 1
a87 1
u_int	rdomain;
d192 1
a192 1
			rdomain = (unsigned int)strtonum(optarg, 0,
d195 1
a195 1
				errx(1, "rdomain %s: %s", errstr, optarg);
d510 4
a513 4
		if (rdomain) {
			if (setsockopt(s, IPPROTO_IP, SO_RDOMAIN, &rdomain,
			    sizeof(rdomain)) == -1)
				err(1, "setsockopt SO_RDOMAIN");
d584 4
a587 4
		if (rdomain) {
			if (setsockopt(s, IPPROTO_IP, SO_RDOMAIN, &rdomain,
			    sizeof(rdomain)) == -1)
				err(1, "setsockopt SO_RDOMAIN");
d874 1
a874 1
	\t-V rdomain	Specify alternate routing domain\n\
d890 1
a890 1
	    "\t  [-V rdomain] [-w timeout] [-X proxy_protocol]\n"
@


1.96
log
@Allocate the port number properly (don't allocate space then ignore it),
and use %zu for size_t.

ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.95 2010/02/27 00:58:56 nicm Exp $ */
d326 1
a326 1
				char buf[8192];
d330 1
a330 1
				plen = jflag ? 8192 : 1024;
d622 1
a622 1
	unsigned char buf[8192];
d627 1
a627 1
	plen = jflag ? 8192 : 1024;
@


1.95
log
@Fix the atelnet() function, which was wrong in several ways.

Pointed out by obsd at happyjack.org, fix based on a diff from kili@@.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.94 2009/10/08 15:56:46 mpf Exp $ */
d769 1
a769 1
		portlist[0] = calloc(1, PORT_MAX_LEN);
a771 1
		portlist[0] = p;
@


1.94
log
@Do not write "Connection to ... succeeded" messages to stdout.
OK gilles, rainer, millert, deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.93 2009/06/05 00:18:10 claudio Exp $ */
d686 3
a688 2
	end = buf + size;
	obuf[0] = '\0';
d692 1
a692 1
			break;
d698 1
a698 1
		if ((*p == DO) || (*p == DONT))
d700 7
a706 8
		if (obuf) {
			p++;
			obuf[2] = *p;
			obuf[3] = '\0';
			if (atomicio(vwrite, nfd, obuf, 3) != 3)
				warn("Write Error!");
			obuf[0] = '\0';
		}
@


1.93
log
@The networking swissarmy knife needs to work on alternate domains as well.
Again -V can be used to specify the domain.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.92 2008/09/19 13:24:41 sobrado Exp $ */
d406 4
a409 2
				printf("Connection to %s %s port [%s/%s] succeeded!\n",
				    host, portlist[i], uflag ? "udp" : "tcp",
@


1.92
log
@documentation tweaks; synchronize synopsis and usage.

written with help by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.91 2008/05/09 09:00:11 markus Exp $ */
d87 1
d129 1
a129 1
	    "46DdhI:i:jklnO:P:p:rSs:tT:Uuvw:X:x:z")) != -1) {
d191 6
d508 6
d582 6
d873 1
d889 2
a890 2
	    "\t  [-w timeout] [-X proxy_protocol] [-x proxy_address[:port]] [hostname]\n"
	    "\t  [port]\n");
@


1.91
log
@try SO_BINDANY for -s, but do not insist; ok bob, reyk
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.90 2008/05/06 05:47:39 djm Exp $ */
d866 5
a870 4
	fprintf(stderr, "usage: nc [-46DdhklnrStUuvz] [-I receive_buffer_len] [-i interval]\n");
	fprintf(stderr, "\t  [-O send_buffer_len] [-P proxy_username] [-p source_port]\n");
	fprintf(stderr, "\t  [-s source_ip_address] [-T ToS] [-w timeout] [-X proxy_protocol]\n");
	fprintf(stderr, "\t  [-x proxy_address[:port]] [hostname] [port[s]]\n");
@


1.90
log
@allow setting of TCP send/receive buffer sizes; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.89 2007/02/20 14:11:17 jmc Exp $ */
d490 1
a490 1
	int s, error;
d505 2
@


1.89
log
@usage(): add -P and tweak -X; from Igor Sobrado
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.88 2006/06/02 03:46:38 ray Exp $ */
d83 2
d128 1
a128 1
	    "46Ddhi:jklnP:p:rSs:tT:Uuvw:X:x:z")) != -1) {
d210 12
d798 10
d837 1
d842 1
d864 2
a865 1
	fprintf(stderr, "usage: nc [-46DdhklnrStUuvz] [-i interval] [-P proxy_username] [-p source_port]\n");
@


1.88
log
@strtoul() -> strtonum().  Also change iflag to unsigned int, since
sleep takes an unsigned integer.

OK moritz@@, jaredy@@, and dhill@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.87 2006/02/01 21:33:14 otto Exp $ */
d838 2
a839 2
	fprintf(stderr, "usage: nc [-46DdhklnrStUuvz] [-i interval] [-p source_port]\n");
	fprintf(stderr, "\t  [-s source_ip_address] [-T ToS] [-w timeout] [-X proxy_version]\n");
@


1.87
log
@remove obsolete code; from Ray Lai in PR 4998; ok tedu@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.86 2006/01/25 23:21:37 djm Exp $ */
d68 1
a68 1
int	iflag;					/* Interval Flag */
d109 1
a109 1
	char *host, *uport, *endp;
d115 1
a115 1
	const char *proxyhost = "", *proxyport = NULL;
a122 1
	endp = NULL;
d154 3
a156 3
			iflag = (int)strtoul(optarg, &endp, 10);
			if (iflag < 0 || *endp != '\0')
				errx(1, "interval cannot be negative");
d192 3
a194 5
			timeout = (int)strtoul(optarg, &endp, 10);
			if (timeout < 0 || *endp != '\0')
				errx(1, "timeout cannot be negative");
			if (timeout >= (INT_MAX / 1000))
				errx(1, "timeout too large");
d681 2
a682 1
	char *n, *endp;
d694 6
a699 6
		hi = (int)strtoul(n, &endp, 10);
		if (hi <= 0 || hi > PORT_MAX || *endp != '\0')
			errx(1, "port range not valid");
		lo = (int)strtoul(p, &endp, 10);
		if (lo <= 0 || lo > PORT_MAX || *endp != '\0')
			errx(1, "port range not valid");
d729 3
a731 3
		hi = (int)strtoul(p, &endp, 10);
		if (hi <= 0 || hi > PORT_MAX || *endp != '\0')
			errx(1, "port range not valid");
@


1.86
log
@implement HTTP proxy authentication support, very useful in a ssh_config
ProxyCommand; ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.85 2006/01/20 00:01:20 millert Exp $ */
a492 7

			if (!(sflag && pflag)) {
				if (!sflag)
					sflag = NULL;
				else
					pflag = NULL;
			}
@


1.85
log
@Explicitly include limits.h if we are going to use its contents.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.84 2005/10/25 06:51:37 dtucker Exp $ */
d73 1
d96 2
a97 2
int	socks_connect(const char *, const char *, struct addrinfo, const char *, const char *,
	struct addrinfo, int);
d127 1
a127 1
	    "46Ddhi:jklnp:rSs:tT:Uuvw:X:x:z")) != -1) {
d171 3
d361 2
a362 1
				    proxyhost, proxyport, proxyhints, socksv);
d826 1
@


1.84
log
@Make set_common_sockopts() a void since it doesn't return anything anyway.
Makes netcat -Wall clean.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.83 2005/10/25 03:51:06 dtucker Exp $ */
d55 1
@


1.83
log
@Add a -T option to nc to allow setting of IP type-of-service bits on
connections.  Man page corrections jmc@@, code corrections and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.82 2005/07/24 09:33:56 marius Exp $ */
d99 1
a99 1
int     set_common_sockopts(int);
d762 1
a762 1
int
@


1.82
log
@correct rval check for socket().  from alf schlichting.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.81 2005/05/28 16:57:48 marius Exp $ */
d40 1
d42 1
d82 1
d100 1
d125 1
a125 1
	    "46Ddhi:jklnp:rSs:tUuvw:X:x:z")) != -1) {
d209 3
d782 22
d824 1
d841 1
a841 1
	fprintf(stderr, "\t  [-s source_ip_address] [-w timeout] [-X proxy_version]\n");
@


1.81
log
@set jumbo flag on the listener, too.  consolidate some common code.

ok mcbride@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.80 2005/05/27 04:55:28 mcbride Exp $ */
d547 1
a547 1
		    res0->ai_protocol)) == 0)
@


1.80
log
@Experimental support for opportunitic use of jumbograms where only some hosts
on the local network support them.

This adds a new socket option, SO_JUMBO, and a new route flag,
RTF_JUMBO. If _both_ the socket option is set and the route for the host
has RTF_JUMBO set, ip_output will fragment the packet to the largest
possible size for the link, ignoring the card's MTU.

The semantics of this feature will be evolving rapidly; talk to us
if you intend to use it.

ok deraadt@@ marius@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.79 2005/05/24 20:13:28 avsm Exp $ */
d96 1
d466 1
a466 1
	int s, error, x = 1;
d501 2
a502 15
		if (Sflag) {
			if (setsockopt(s, IPPROTO_TCP, TCP_MD5SIG,
			    &x, sizeof(x)) == -1)
				err(1, NULL);
		}
		if (Dflag) {
			if (setsockopt(s, SOL_SOCKET, SO_DEBUG,
			    &x, sizeof(x)) == -1)
				err(1, NULL);
		}
		if (jflag) {
			if (setsockopt(s, SOL_SOCKET, SO_JUMBO,
			    &x, sizeof(x)) == -1)
				err(1, NULL);
		}
d553 2
a554 11
		if (Sflag) {
			ret = setsockopt(s, IPPROTO_TCP, TCP_MD5SIG,
			    &x, sizeof(x));
			if (ret == -1)
				err(1, NULL);
		}
		if (Dflag) {
			if (setsockopt(s, SOL_SOCKET, SO_DEBUG,
			    &x, sizeof(x)) == -1)
				err(1, NULL);
		}
d753 22
@


1.79
log
@Switch atomicio to a simpler interface which returns size_t and uses
0 to signal errors.  should be no functional change in nc apart from
different error messages.

"groovy", said deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.78 2005/04/10 19:43:34 otto Exp $ */
d66 1
d119 2
a120 1
	while ((ch = getopt(argc, argv, "46Ddhi:klnp:rSs:tUuvw:X:x:z")) != -1) {
d152 3
d294 2
a295 2
				int rv;
				char buf[1024];
d299 2
a300 1
				rv = recvfrom(s, buf, sizeof(buf), MSG_PEEK,
d510 5
d603 1
a603 1
	unsigned char buf[BUFSIZ];
d606 3
d631 1
a631 1
			if ((n = read(nfd, buf, sizeof(buf))) < 0)
d646 1
a646 1
			if ((n = read(wfd, buf, sizeof(buf))) < 0)
@


1.78
log
@Initialize len before calling accept(2). from mpech@@, ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.77 2005/02/08 15:26:23 otto Exp $ */
d53 1
a83 1
ssize_t	atomicio(ssize_t (*)(int, void *, size_t), int, void *, size_t);
d593 1
a593 1
	int wfd = fileno(stdin), n;
d626 1
a626 2
				if (atomicio((ssize_t (*)(int, void *, size_t))write,
				    lfd, buf, n) != n)
d639 1
a639 2
				if (atomicio((ssize_t (*)(int, void *, size_t))write,
				    nfd, buf, n) != n)
d670 2
a671 3
			if (atomicio((ssize_t (*)(int, void *, size_t))write,
			    nfd, obuf, 3) != 3)
				warnx("Write Error!");
@


1.77
log
@Some extra strict warning cleanup. From Xin Li <delphij at FreeBSD
dot ORG> with a twist from myself. No binary change. ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.76 2004/12/10 16:51:31 hshoexer Exp $ */
d305 1
@


1.76
log
@provide a valid sockaddr_storage structure to be used as second argument for
accept(2)

ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.75 2004/10/17 03:13:55 djm Exp $ */
d89 2
a90 2
int	remote_connect(char *, char *, struct addrinfo);
int	socks_connect(char *, char *, struct addrinfo, char *, char *,
d107 1
a107 1
	char *proxyhost = "", *proxyport = NULL;
d455 1
a455 1
remote_connect(char *host, char *port, struct addrinfo hints)
@


1.75
log
@http proxy CONNECT support; ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.74 2004/09/15 18:44:45 deraadt Exp $ */
d105 1
a105 1
	struct sockaddr *cliaddr;
@


1.74
log
@remove return error variables.. set but never used
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.73 2004/07/15 15:07:52 markus Exp $ */
d130 8
a137 3
			socksv = (int)strtoul(optarg, &endp, 10);
			if ((socksv != 4 && socksv != 5) || *endp != '\0')
				errx(1, "only SOCKS version 4 and 5 supported");
d787 2
a788 2
	\t-X vers\t	SOCKS version (4 or 5)\n\
	\t-x addr[:port]\tSpecify socks proxy address and port\n\
d798 1
a798 1
	fprintf(stderr, "\t  [-s source_ip_address] [-w timeout] [-X socks_version]\n");
@


1.73
log
@add -D for sodebug; ok deraadt, jmc
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.72 2004/03/12 10:10:00 jmc Exp $ */
d586 2
a587 2
	char buf[BUFSIZ];
	int wfd = fileno(stdin), n, ret;
d620 2
a621 3
				if ((ret = atomicio(
				    (ssize_t (*)(int, void *, size_t))write,
				    lfd, buf, n)) != n)
d634 2
a635 3
				if ((ret = atomicio(
				    (ssize_t (*)(int, void *, size_t))write,
				    nfd, buf, n)) != n)
a645 1
	int ret;
d666 2
a667 3
			if ((ret = atomicio(
			    (ssize_t (*)(int, void *, size_t))write,
			    nfd, obuf, 3)) != 3)
d748 1
a748 1
	int i, rv, ret;
d751 1
a751 1
		if ((rv = write(s, "X", 1)) == 1)
@


1.72
log
@add keeps to SYNOPSIS and sync usage();
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.71 2004/03/07 07:55:55 mcbride Exp $ */
d76 1
d118 1
a118 1
	while ((ch = getopt(argc, argv, "46UX:dhi:klnp:rs:tuvw:x:zS")) != -1) {
d188 3
d493 5
d554 5
d770 1
d796 1
a796 1
	fprintf(stderr, "usage: nc [-46dhklnrStUuvz] [-i interval] [-p source_port]\n");
@


1.71
log
@Print error when connect() fails. ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.70 2004/03/03 06:50:13 deraadt Exp $ */
d781 3
a783 3
	fprintf(stderr, "usage: nc [-46dhklnrStUuvz] [-i interval] [-p source_port] [-s source_ip_address]\n");
	fprintf(stderr, "\t  [-w timeout] [-X socks_version] [-x proxy_address[:port]] [hostname]\n");
	fprintf(stderr, "\t  [port[s]]\n");
@


1.70
log
@spaces, was reading code..
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.69 2004/03/03 06:45:54 tedu Exp $ */
d492 3
@


1.69
log
@add -d to usage too, from carson harding
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.68 2004/03/01 00:37:08 tedu Exp $ */
d171 1
a171 1
		case 'w': 
d525 1
a525 1
                errx(1, "getaddrinfo: %s", gai_strerror(error));
d618 1
a618 1
				if((ret = atomicio(
@


1.68
log
@resolve pr3694.  add -d [etached] to ignore stdin.  ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.67 2004/02/20 10:53:10 jmc Exp $ */
d753 1
d778 1
a778 1
	fprintf(stderr, "usage: nc [-46hklnrStUuvz] [-i interval] [-p source_port] [-s source_ip_address]\n");
@


1.67
log
@- sort options and SYNOPSIS
- better document which options do/don't work together
- add sections showing some possible uses of nc
- code (comment) typos
- sync usage() and help

suggestions/improvements from otto@@
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.66 2004/01/31 21:09:15 henning Exp $ */
d63 1
d117 1
a117 1
	while ((ch = getopt(argc, argv, "46UX:hi:klnp:rs:tuvw:x:zS")) != -1) {
d133 3
d585 1
a585 1
		if ((n = poll(pfd, 2, timeout)) < 0) {
d610 1
a610 1
		if (pfd[1].revents & POLLIN) {
@


1.66
log
@rename tcp sockopt TCP_SIGNATURE_ENABLE to TCP_MD5SIG
requested by theo
ok markus@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.65 2004/01/22 13:28:46 markus Exp $ */
d66 1
a66 1
int	nflag;					/* Dont do name lookup */
d219 1
a219 1
	/* Initialize addrinfo structure */
d264 1
a264 1
		/* Allow only one connection at a time, but stay alive */
d318 1
a318 1
		/* construct the portlist[] array */
d321 1
a321 1
		/* Cycle through portlist, connecting to each port */
d337 1
a337 1
				/* For UDP, make sure we are connected */
d345 1
a345 1
				/* Don't lookup port if -n */
d371 1
a371 1
 * Return's a socket connected to a local unix socket. Return's -1 on failure.
d402 1
a402 1
 * create a unix domain socket, and listen on it.
d410 1
a410 1
	/* create unix domain socket */
d438 2
a439 2
 * Return's a socket connected to a remote host. Properly bind's to a local
 * port or source address if needed. Return's -1 on failure.
d456 1
a456 1
		/* Bind to a local port or source address if specified */
d500 2
a501 2
 * Return's a socket listening on a local port, binds to specified source
 * address. Return's -1 on failure.
d510 1
a510 1
	/* Allow nodename to be null */
d573 1
a573 1
	/* Setup STDIN FD */
d623 1
a623 1
/* Deal with RFC854 WILL/WONT DO/DONT negotiation */
d660 1
a660 1
 * that we should try to connect too.
d676 1
a676 1
		/* Make sure the ports are in order: lowest->highest */
d690 1
a690 1
		/* Load ports sequentially */
d699 1
a699 1
		/* Randomly swap ports */
d725 1
a725 1
 * XXX - Better way of doing this? Doesn't work for IPv6
a748 3
	\t-S		Enable the TCP MD5 signature option\n\
	\t-U		Use UNIX domain socket\n\
	\t-X vers\t	SOCKS version (4 or 5)\n\
d756 1
d759 1
d763 1
d773 3
a775 3
	fprintf(stderr, "usage: nc [-46SUhklnrtuvz] [-i interval] [-p source port]\n");
	fprintf(stderr, "\t  [-s ip address] [-w timeout] [-X vers] [-x proxy address [:port]]\n");
	fprintf(stderr, "\t  [hostname] [port[s...]]\n");
@


1.65
log
@-S enables tcp md5 signature option; ok deraadt@@, mcbride@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.64 2003/10/19 22:50:35 deraadt Exp $ */
d481 1
a481 1
			if (setsockopt(s, IPPROTO_TCP, TCP_SIGNATURE_ENABLE,
d533 1
a533 1
			ret = setsockopt(s, IPPROTO_TCP, TCP_SIGNATURE_ENABLE,
@


1.64
log
@check alloca; pointed out by nimadeus@@pandora.be
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.63 2003/09/22 21:39:40 miod Exp $ */
d40 1
d75 1
d116 1
a116 1
	while ((ch = getopt(argc, argv, "46UX:hi:klnp:rs:tuvw:x:z")) != -1) {
d183 3
d445 1
a445 1
	int s, error;
d480 5
d532 6
d749 1
d773 1
a773 1
	fprintf(stderr, "usage: nc [-46Uhklnrtuvz] [-i interval] [-p source port]\n");
@


1.63
log
@Off-by-ones, from aaron@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.62 2003/07/25 21:35:16 millert Exp $ */
d175 2
a176 1
			proxy = strdup(optarg);
@


1.62
log
@Kill dead code after errx(). From Andrey Matveev; ericj@@ OK
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.61 2003/07/07 21:36:23 deraadt Exp $ */
d77 1
a77 1
char *portlist[PORT_MAX];
@


1.61
log
@protos
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.60 2003/07/07 14:12:18 avsm Exp $ */
d470 1
a470 1
			    ares->ai_addrlen) < 0) {
a471 3
				freeaddrinfo(ares);
				continue;
			}
@


1.60
log
@in the unix domain socket case, give an ENAMETOOLONG error instead of
silently truncating the socket file
millert@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.59 2003/06/26 21:59:11 deraadt Exp $ */
a221 1

@


1.59
log
@more proto fixes
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.58 2003/06/10 22:20:48 deraadt Exp $ */
d380 7
a386 1
	strlcpy(sun.sun_path, path, sizeof(sun.sun_path));
d409 1
a409 1
	strlcpy(sun.sun_path, path, sizeof(sun.sun_path));
d411 8
@


1.58
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.57 2002/12/30 18:00:18 stevesk Exp $ */
d79 1
a79 1
ssize_t	atomicio(ssize_t (*)(), int, void *, size_t);
d572 3
a574 1
				if ((ret = atomicio(write, lfd, buf, n)) != n)
d587 3
a589 1
				if((ret = atomicio(write, nfd, buf, n)) != n)
d621 3
a623 1
			if ((ret = atomicio(write , nfd, obuf, 3)) != 3)
@


1.57
log
@use err vs. errx and display function; from Owl.  ok fgsch@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.56 2002/12/30 17:57:58 stevesk Exp $ */
d710 1
a710 1
help()
@


1.56
log
@include function in error; from Owl.  ok fgsch@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.55 2002/12/28 10:24:09 fgsch Exp $ */
d279 1
a279 1
					errx(1, "%s", strerror(errno));
d283 1
a283 1
					errx(1, "%s", strerror(errno));
d522 1
a522 1
			errx(1, "%s", strerror(errno));
@


1.55
log
@fix calloc's. also check for errors; fixes PR/3043.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.53 2002/11/13 22:26:15 markus Exp $ */
d429 1
a429 1
		errx(1, "%s", gai_strerror(error));
d454 1
a454 1
				errx(1, "%s", gai_strerror(error));
d500 1
a500 1
                errx(1, "%s", gai_strerror(error));
@


1.54
log
@Recent modifications to netcat changed the behaviour to only exit when both
the read (network) and write (stdin) ends of the socket were both closed.
This is not how nc traditionally works. Instead, revert back to finishing up
when read() on the socket returns 0; deraadt@@, vincent@@ ok.
@
text
@d58 2
a59 1
#define PORT_MAX 65535
d659 4
a662 2
			portlist[x] = calloc(1, PORT_MAX);
			snprintf(portlist[x], PORT_MAX, "%d", cp);
d682 3
a684 1
		portlist[0] = calloc(1, PORT_MAX);
@


1.53
log
@update usage; ok ericj@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.52 2002/07/04 04:42:25 vincent Exp $ */
d549 1
a549 1
	while (pfd[0].fd != -1 || pfd[1].fd != -1) {
@


1.52
log
@  correct handling of EOF on both tty input and network.  for example,
this allows stuff like nc -l 10101 < /dev/null to have nc exit
automatically when it gets EOF from the network.

 ok ericj@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.51 2002/07/01 20:12:40 vincent Exp $ */
d712 1
d725 1
a725 1
	\t-x addr[:port]\tSpecify socks5 proxy address and port\n\
d735 1
a735 1
	fprintf(stderr, "\t  [-s ip address] [-w timeout] [-x proxy address [:port]]\n");
@


1.51
log
@define SUN_LEN if it is not already for portability.

millert made the same suggestion, so i guess it's ok ;)
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.50 2002/07/01 15:40:40 vincent Exp $ */
d536 1
a536 1
	struct pollfd *pfd;
a540 2
	pfd = malloc(2 * sizeof(struct pollfd));

d549 1
a549 1
	for (;;) {
d555 1
a555 3
			close(wfd);
			free(pfd);
			errx(1, "Polling Error");
d562 1
a562 1
			if ((n = read(nfd, buf, sizeof(buf))) <= 0) {
d564 4
d579 5
a583 1
			else {
d695 1
a695 1
	for (i=0; i <= 3; i++) {
@


1.50
log
@use SUN_LEN to calculate AF_UNIX sockaddr's length.  + some style

ok ericj@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.49 2002/05/30 09:37:38 hugh Exp $ */
d52 5
@


1.49
log
@Avoid spinning poll, and while we're at it more closely reproduce the
original netcat's timeout behaviour. Theo says go.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.48 2002/05/29 09:23:25 deraadt Exp $ */
d216 1
a216 1
		
a311 1
			
d328 1
a328 1
					if ((udptest(s)) == -1) {
d342 1
a342 1
				
d369 1
a369 1
			return (-1);
a372 1
	sun.sun_len = sizeof(path);
d375 3
a377 4

	if (connect(s, (struct sockaddr *)&sun, sizeof(sun)) < 0) {
			close(s);
			return (-1);
d380 1
a380 1
		
d397 1
d399 1
a399 3
	strlcpy(sun.sun_path, path, sizeof(sun.sun_path));

	if (bind(s, (struct sockaddr *)&sun, sizeof(sun)) < 0) {
d451 1
a451 1
			     ares->ai_addrlen) < 0) {
d572 1
a572 1
			if ((n = read(wfd, buf, sizeof(buf))) < 0) {
d574 1
a574 1
			} else
d577 1
d581 1
d599 1
a599 1
		if ((*p == WILL) || (*p == WONT)) {
d601 1
a601 2
		}
		if ((*p == DO) || (*p == DONT)) {
a602 1
		}
@


1.48
log
@more snprintf
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.47 2002/03/10 20:26:09 ericj Exp $ */
d69 1
a69 1
int timeout;
d163 3
d554 1
a554 1
		if (poll(pfd, 2, timeout) < 0) {
d560 3
@


1.47
log
@
check that we got the port before trying to listen
pr 2436; Alexander Yurchenko <grange@@rt.mipt.ru>
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.46 2002/02/28 18:05:36 markus Exp $ */
d648 1
a648 1
			sprintf(portlist[x], "%d", cp);
@


1.46
log
@add support for SOCKS4 with option -X socks_version, default is 5; ok ericj@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.45 2002/02/19 22:42:04 ericj Exp $ */
d515 1
a515 1
	if (!uflag) {
@


1.45
log
@
-Wall cleanup.
from Kevin Steves <stevesk@@pobox.com>
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.44 2002/02/17 19:42:31 millert Exp $ */
d81 1
a81 1
	struct addrinfo);
d90 1
a90 1
	int ch, s, ret;
d102 1
d108 1
a108 1
	while ((ch = getopt(argc, argv, "46Uhi:klnp:rs:tuvw:x:z")) != -1) {
d119 5
d315 1
a315 1
				    proxyhost, proxyport, proxyhints);
@


1.44
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.43 2002/02/17 03:24:56 ericj Exp $ */
d80 2
d97 1
a97 1
	char *proxyhost, *proxyport;
d394 1
a394 1
	if (bind(s, (struct sockaddr *)&sun, SUN_LEN(&sun)) < 0) {
@


1.43
log
@
oops, add -U to usage
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.42 2002/02/17 03:03:06 ericj Exp $ */
d73 1
a73 1
ssize_t	atomicio __P((ssize_t (*)(), int, void *, size_t));
@


1.42
log
@
add support for connecting too and listening on AF_UNIX sockets.
connect support from dave@@arbor.net.. rest by me
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.41 2002/02/17 02:04:57 ericj Exp $ */
d714 1
a714 1
	fprintf(stderr, "usage: nc [-46hklnrtuvz] [-i interval] [-p source port]\n");
@


1.41
log
@
fix pr#2091. patch applied.
patch from Brian J. Kifiak <bk@@rt.fm>
should be looked at closer..
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.40 2002/02/16 21:27:50 millert Exp $ */
d37 1
d51 1
d81 2
d105 1
a105 1
	while ((ch = getopt(argc, argv, "46hi:klnp:rs:tuvw:x:z")) != -1) {
d113 3
d171 6
a176 1
	if (argv[0] && !argv[1]) {
d197 9
a205 6
	memset(&hints, 0, sizeof(struct addrinfo));
	hints.ai_family = family;
	hints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;
	hints.ai_protocol = uflag ? IPPROTO_UDP : IPPROTO_TCP;
	if (nflag)
		hints.ai_flags |= AI_NUMERICHOST;
d214 3
d239 3
d244 3
a246 1
			if ((s = local_listen(host, uport, hints)) < 0)
d276 2
a277 1
			close(s);
d282 11
d349 56
d692 1
@


1.40
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.39 2001/10/28 19:52:04 jakob Exp $ */
d471 1
a471 1
			if ((n = read(wfd, buf, sizeof(buf))) <= 0) {
@


1.39
log
@remove bogus error-check, resolve pr#2147
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.38 2001/10/28 19:48:33 jakob Exp $ */
d72 8
a79 8
void	atelnet __P((int, unsigned char *, unsigned int));
void	build_ports __P((char *));
void	help __P((void));
int	local_listen __P((char *, char *, struct addrinfo));
void	readwrite __P((int));
int	remote_connect __P((char *, char *, struct addrinfo));
int	udptest __P((int));
void	usage __P((int));
@


1.38
log
@fix getaddrinfo error handling
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.37 2001/09/02 19:11:46 jakob Exp $ */
a363 3
		if (error == 0)
			break;
		
@


1.37
log
@KNF + ansi
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.36 2001/09/02 19:07:17 jakob Exp $ */
d349 1
a349 1
			if (getaddrinfo(sflag, pflag, &ahints, &ares))
@


1.36
log
@update command summary
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.35 2001/09/02 19:04:23 jakob Exp $ */
d82 1
a82 3
main(argc, argv)
	int argc;
	char *argv[];
d237 1
a237 1
					(struct sockaddr *)&z, &len);
d241 1
a241 2
				rv = connect(s, (struct sockaddr *)&z,
					len);
d248 1
a248 1
									&len);
d294 2
a295 2
						ntohs(atoi(portlist[i])),
						uflag ? "udp" : "tcp");
d299 2
a300 2
					host, portlist[i], uflag ? "udp" : "tcp",
					sv ? sv->s_name : "*");
d319 1
a319 3
remote_connect(host, port, hints)
	char *host, *port;
	struct addrinfo hints;
d330 1
a330 1
				res0->ai_protocol)) < 0)
d353 1
a353 1
							ares->ai_addrlen) < 0) {
d382 1
a382 3
local_listen(host, port, hints)
	char *host, *port;
	struct addrinfo hints;
d404 1
a404 1
				res0->ai_protocol)) == 0)
d412 1
a412 1
						res0->ai_addrlen) == 0)
d434 1
a434 2
readwrite(nfd)
	int nfd;
d484 1
a484 4
atelnet(nfd, buf, size)
	int nfd;
	unsigned char *buf;
	unsigned int size;
d522 1
a522 2
build_ports(p)
	char *p;
d584 1
a584 2
udptest(s)
        int s;
d623 1
a623 2
usage(ret)
	int ret;
@


1.35
log
@remove unused variable
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.34 2001/09/02 18:45:41 jakob Exp $ */
d622 1
a622 1
	\t-p		Specify local port for remote connects\n\
d640 2
a641 1
	fprintf(stderr, "\t  [-s ip address] [-w timeout] [hostname] [port[s...]]\n");
@


1.34
log
@add very basic proxy support using socks5 client code from niklas@@.
ok ericj@@.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.33 2001/08/25 21:50:13 ericj Exp $ */
a194 2
		char *tmp;

@


1.33
log
@
use calloc
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.32 2001/08/02 21:00:14 ericj Exp $ */
d64 1
d92 3
d103 1
a103 1
	while ((ch = getopt(argc, argv, "46hi:klnp:rs:tuvw:z")) != -1) {
d151 4
d194 27
d274 8
a281 2
	
			if ((s = remote_connect(host, portlist[i], hints)) < 0)
d370 3
d631 1
@


1.32
log
@
fix diagnostic messages
from Dima Dorfman <dima@@unixfreak.org>
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.31 2001/06/27 07:23:58 ericj Exp $ */
d521 1
a521 1
			portlist[x] = malloc(sizeof(PORT_MAX));
d542 1
a542 1
		portlist[0] = malloc(sizeof(PORT_MAX));
@


1.31
log
@
more magic stuff to define's
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.30 2001/06/27 03:14:28 smart Exp $ */
d174 1
a174 1
		errx(1, "cannot use -p and -l");
d176 1
a176 1
		errx(1, "must use -k with -l");
@


1.30
log
@Spit out errno message instead of just exitting.  ericj@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.29 2001/06/27 02:45:08 smart Exp $ */
d51 2
d68 1
a68 1
char *portlist[65535];
a70 1

d507 1
a507 1
		if (hi <= 0 || hi > 65535 || *endp != '\0')
d510 1
a510 1
		if (lo <= 0 || lo > 65535 || *endp != '\0')
d521 1
a521 1
			portlist[x] = malloc(sizeof(65535));
d540 1
a540 1
		if (hi <= 0 || hi > 65535 || *endp != '\0')
d542 1
a542 1
		portlist[0] = malloc(sizeof(65535));
@


1.29
log
@Compile cleanly with -Wall
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.28 2001/06/26 23:25:22 ericj Exp $ */
d192 1
a192 1
				exit(1);
d373 1
a373 1
			exit(1);
@


1.28
log
@
remove some unused var's.
from jasoni@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.27 2001/06/26 23:06:53 ericj Exp $ */
d40 1
d68 10
a77 8
void atelnet __P((int, unsigned char *, unsigned int));
void build_ports __P((char *));
void help __P((void));
int local_listen __P((char *, char *, struct addrinfo));
void readwrite __P((int));
int remote_connect __P((char *, char *, struct addrinfo));
int udptest __P((int));
void usage __P((int));
d84 1
a84 1
	int ch, s, ret = 1;
d87 1
a87 1
	struct servent *sv = 0;
d91 7
d192 1
a192 1
				errx(1, NULL);
d373 1
a373 1
			errx(1, NULL);
@


1.27
log
@
allow -k for udp and tcp
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.26 2001/06/26 21:57:35 ericj Exp $ */
a190 1
				char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];
d444 1
a444 1
	int ret, pos = 0;
@


1.26
log
@
be weary of atoi().
suggested by theo.. also do range checking on ports
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.25 2001/06/26 21:19:14 ericj Exp $ */
d177 1
a177 3
	
		if ((s = local_listen(host, uport, hints)) < 0)
			errx(1, NULL);
a178 1
		ret = 0;
d181 2
d213 2
@


1.25
log
@
dont set the source address to 127.0.0.1 if a local port is specified
but no source address
reported by jakob@@
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.24 2001/06/26 20:53:14 ericj Exp $ */
d82 1
a82 1
	char *host, *uport;
d100 3
a102 1
			iflag = atoi(optarg);
d131 4
a134 2
		case 'w':
			timeout = atoi(optarg);
d483 1
a483 1
	char *n;
d495 6
a500 2
		hi = atoi(n);
		lo = atoi(p);
d528 3
@


1.24
log
@
rewrite telnet negotiation
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.23 2001/06/26 19:31:10 ericj Exp $ */
d299 1
d451 1
a451 1
		obuf[0]=IAC;
@


1.23
log
@
rename variable, as not to conflict
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.22 2001/06/26 07:38:05 jasoni Exp $ */
d29 2
a30 3
/* 
 * Re-written nc(1) for OpenBSD. Only code shared with previous version
 * was the code for telnet emulation. Original implementation by
d432 1
a432 7

/*
 * Answer anything that looks like telnet negotiation with don't/won't.
 * This doesn't modify any data buffers, update the global output count,
 * or show up in a hexdump -- it just shits into the outgoing stream.
 * Idea and codebase from Mudge@@l0pht.com.
 */
d439 8
a446 9
	static unsigned char obuf[4];
	int x, ret;
	unsigned char y;
	unsigned char *p;

	y = 0;
	p = buf;
	x = size;
	while (x > 0) {
d448 12
a459 10
			goto notiac;
		obuf[0] = IAC;
		p++; x--;
		if ((*p == WILL) || (*p == WONT))
			y = DONT;
		if ((*p == DO) || (*p == DONT))
			y = WONT;
		if (y) {
			obuf[1] = y;
			p++; x--;
d461 1
d464 1
a464 1
			y = 0;
a465 2
notiac:
		p++; x--;
@


1.22
log
@type in usage: Surpress -> Suppress
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.21 2001/06/25 22:17:35 ericj Exp $ */
d187 1
a187 1
				int ret;
d193 1
a193 1
				ret = recvfrom(s, buf, sizeof(buf), MSG_PEEK,
d195 1
a195 1
				if (ret < 0)
d198 1
a198 1
				ret = connect(s, (struct sockaddr *)&z,
d200 1
a200 1
				if (ret < 0)
@


1.21
log
@
Import completely re-written netcat w/ support for IPv6.
very little usage has changed, man page soon to come for it as well.
deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d563 1
a563 1
	\t-n		Surpress name/port resolutions\n\
@


1.20
log
@GAPING_SECURITY_HOLE was removed so there is no -e option.
Removed from man page and usage; closes PR 1808
@
text
@d1 3
a3 3
/* $OpenBSD: netcat.c,v 1.19 2001/01/16 20:20:48 ericj Exp $ */

/* Netcat 1.10 RELEASE 960320
d5 3
a7 5
 *   A damn useful little "backend" utility begun 950915 or thereabouts,
 *   as *Hobbit*'s first real stab at some sockets programming.  Something that
 *   should have and indeed may have existed ten years ago, but never became a
 *   standard Unix utility.  IMHO, "nc" could take its place right next to cat,
 *   cp, rm, mv, dd, ls, and all those other cryptic and Unix-like things.
d9 7
a15 1
 *   Read the README for the whole story, doc, applications, etc.
d17 11
a27 17
 *   Layout:
 *	conditional includes:
 *	includes:
 *	handy defines:
 *	globals:
 *	malloced globals:
 *	cmd-flag globals:
 *	support routines:
 *	readwrite select loop:
 *	main:
 *
 *  bluesky:
 *	parse ranges of IP address as well as ports, perhaps
 *	RAW mode!
 *	backend progs to grab a pty and look like a real telnetd?!
 *	backend progs to do various encryption modes??!?!
*/
d29 5
d36 1
d38 1
a38 2
#include <sys/select.h>
#include <sys/socket.h>
d40 1
a40 7
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <netdb.h>		/* hostent, gethostby*, getservby* */
#include <stdio.h>
#include <string.h>
d43 2
a44 4
#include <setjmp.h>
#include <signal.h>
#include <fcntl.h>
#include <resolv.h>
d46 1
d48 1
d51 25
a75 2
#define SLEAZE_PORT 31337	/* for UDP-scan RTT trick, change if ya want */
#define BIGSIZ 8192		/* big buffers */
d77 11
a87 54
struct host_info {
	char	name[MAXHOSTNAMELEN];	/* DNS name */
	char	addrs[8][24];		/* ascii-format IP addresses */
	struct 	in_addr iaddrs[8];	/* in_addr.s_addr: ulong */
};

struct port_info {
	char    name[64];	/* name in /etc/services */
	char    anum[8];	/* ascii-format number */
	u_short  num;		/* real host-order number */
};

/* globals: */
jmp_buf jbuf;			/* timer jump buffer*/
int     jval = 0;		/* timer crud */
int     netfd = -1;
int     ofd = 0;		/* hexdump output fd */

int     gatesidx = 0;		/* LSRR hop count */
int     gatesptr = 4;		/* initial LSRR pointer, settable */
u_short  Single = 1;		/* zero if scanning */
unsigned int insaved = 0;	/* stdin-buffer size for multi-mode */
unsigned int wrote_out = 0;	/* total stdout bytes */
unsigned int wrote_net = 0;	/* total net bytes */
static char hexnibs[20] = "0123456789abcdef  ";

/* will malloc up the following globals: */
struct timeval timer1, timer2;
struct sockaddr_in    *lclend = NULL;	/* sockaddr_in structs */
struct sockaddr_in    *remend = NULL;
struct host_info  **gates = NULL;	/* LSRR hop hinfo */
char   *optbuf = NULL;			/* LSRR or sockopts */
char   *bigbuf_in;			/* data buffers */
char   *bigbuf_net;
fd_set fds1, fds2;
struct port_info   *pinfo = NULL;	/* for getpinfo / getservby* */
unsigned char *stage = NULL;		/* hexdump line buffer */

/* global cmd flags: */
u_short  o_alla = 0;
unsigned int o_interval = 0;
u_short  o_listen = 0;
u_short  o_nflag = 0;
u_short  o_wfile = 0;
u_short  o_random = 0;
u_short  o_udpmode = 0;
u_short  o_verbose = 0;
unsigned int o_wait = 0;
u_short  o_zero = 0;

/* Function Prototype's */
void	help __P(());
void	nlog __P((int, char *, ...));
void	usage __P((int));
d89 53
a141 4
/* 
 * support routines -- the bulk of this thing.  Placed in such an order that
 * we don't have to forward-declare anything: 
 */
d143 11
a153 11
/* 
 * catch :
 * no-brainer interrupt handler
 */
void 
catch()
{
	if (o_verbose)	/* normally we don't care */
		nlog(1, "Sent %i Rcvd %i", wrote_net, wrote_out);
	nlog(1, " punt!");
}
d155 16
a170 10
/* timeout and other signal handling cruft */
void 
tmtravel()
{
	signal(SIGALRM, SIG_IGN);
	alarm(0);
	if (jval == 0)
		nlog(1, "spurious timer interrupt!");
	longjmp(jbuf, jval);
}
d172 5
a176 19
/*
 * arm :
 * set the timer.  Zero secs arg means unarm
 */
void 
arm(num, secs)
	unsigned int num;
	unsigned int secs;
{
	if (secs == 0) {
		signal(SIGALRM, SIG_IGN);
		alarm(0);
		jval = 0;
	} else {
		signal(SIGALRM, tmtravel);
		alarm(secs);
		jval = num;
	}	
}
d178 24
a201 28
/*
 * findline :
 * find the next newline in a buffer; return inclusive size of that "line",
 * or the entire buffer size, so the caller knows how much to then write().
 * Not distinguishing \n vs \r\n for the nonce; it just works as is... 
 */
unsigned int 
findline(buf, siz)
	char   *buf;
	unsigned int siz;
{
	char *p;
	int x;
	if (!buf)		/* various sanity checks... */
		return (0);
	if (siz > BIGSIZ)
		return (0);
	x = siz;
	for (p = buf; x > 0; x--) {
		if (*p == '\n') {
			x = (int) (p - buf);
			x++;	/* 'sokay if it points just past the end! */
			    return (x);
		}
		p++;
	}
	    return (siz);
}
d203 5
a207 18
/*
 * comparehosts :
 * cross-check the host_info we have so far against new gethostby*() info,
 * and holler about mismatches.  Perhaps gratuitous, but it can't hurt to
 * point out when someone's DNS is fukt.  Returns 1 if mismatch, in case
 * someone else wants to do something about it. 
 */
int 
comparehosts(hinfo, hp)
	struct host_info   *hinfo;
	struct hostent *hp;
{
	if (strcasecmp(hinfo->name, hp->h_name) != 0) {
		nlog(0, "DNS fwd/rev mismatch: %s != %s", hinfo->name, hp->h_name);
		return (1);
	}
	return (0);
}
d209 4
a212 60
/* 
 * gethinfo:
 * resolve a host 8 ways from sunday; return a new host_info struct with its
 * info.  The argument can be a name or [ascii] IP address; it will try its
 * damndest to deal with it.  "numeric" governs whether we do any DNS at all,
 * and we also check o_verbose for what's appropriate work to do.
 */
struct host_info   *
gethinfo(name, numeric)
	char   *name;
	u_short  numeric;
{
	struct hostent *hostent;
	struct in_addr iaddr;
	struct host_info *hinfo = NULL;
	int x;

	if (name)
		hinfo = (struct host_info *) calloc(1, sizeof(struct host_info));

	if (!hinfo)
		nlog(1, "error obtaining host information");

	strlcpy(hinfo->name, "(UNKNOWN)", sizeof(hinfo->name));
	if (inet_aton(name, &iaddr) == 0) {
		if (numeric)
			nlog(1, "Can't parse %s as an IP address", name);

		/*
		 * failure to look up a name is fatal, 
		 * since we can't do anything with it.
		 */
		hostent = gethostbyname(name);
		if (!hostent)
			nlog(1, "%s: forward host lookup failed: ", name);

		strlcpy(hinfo->name, hostent->h_name, MAXHOSTNAMELEN);
		for (x = 0; hostent->h_addr_list[x] && (x < 8); x++) {
			memcpy(&hinfo->iaddrs[x], hostent->h_addr_list[x],
			    sizeof(struct in_addr));
			strlcpy(hinfo->addrs[x], inet_ntoa(hinfo->iaddrs[x]),
			    sizeof(hinfo->addrs[0]));
		}
		/* Go ahead and return if we don't want to view more */
		if (!o_verbose)	
			return (hinfo);

		/*
		 * Do inverse lookups in separate loop based on our collected 
	   	 * forward addrs, since gethostby* tends to crap into the same
		 * buffer over and over.
		 */
		for (x = 0; hinfo->iaddrs[x].s_addr && (x < 8); x++) {
			hostent = gethostbyaddr((char *) &hinfo->iaddrs[x],
			    sizeof(struct in_addr), AF_INET);
			if ((!hostent) || (!hostent->h_name))
				nlog(0, "Warning: inverse host lookup failed for %s: ",
				    hinfo->addrs[x]);
			else
				(void) comparehosts(hinfo, hostent);
d214 2
d217 2
a218 30
	} else {		/* not INADDR_NONE: numeric addresses... */
		memcpy(hinfo->iaddrs, &iaddr, sizeof(struct in_addr));
		strlcpy(hinfo->addrs[0], inet_ntoa(iaddr), sizeof(hinfo->addrs));
		/* If all that's wanted is numeric IP, go ahead and leave */
		if (numeric)	
			return (hinfo);

		/* Go ahead and return if we don't want to view more */
		if (!o_verbose)	
			return (hinfo);

		hostent = gethostbyaddr((char *) &iaddr, 
					sizeof(struct in_addr), AF_INET);

		/* 
		 * numeric or not, failure to look up a PTR is 
		 * *not* considered fatal 
		 */
		if (!hostent)
			nlog(0, "%s: inverse host lookup failed: ", name);
		else {
			strlcpy(hinfo->name, hostent->h_name, MAXHOSTNAMELEN);
			hostent = gethostbyname(hinfo->name);
			if ((!hostent) || (!hostent->h_addr_list[0]))
				nlog(0, "Warning: forward host lookup failed for %s: ",
				    hinfo->name);
			else
				(void) comparehosts(hinfo, hostent);
		}
	}
d220 8
a227 6
	/*
	 * Whatever-all went down previously, we should now have a host_info 
	 * struct with at least one IP address in it.
	 */
	return (hinfo);
}
d229 9
a237 17
/*
 * getpinfo:
 * Same general idea as gethinfo-- look up a port in /etc/services, fill
 * in global port_info, but return the actual port *number*.  Pass ONE of:
 *	pstring to resolve stuff like "23" or "exec";
 *	pnum to reverse-resolve something that's already a number.
 * If o_nflag is on, fill in what we can but skip the getservby??? stuff.
 * Might as well have consistent behavior here, and it *is* faster.
 */
u_short 
getpinfo(pstring, pnum)
	char   *pstring;
	unsigned int pnum;
{
	struct servent *servent;
	int x;
	int y;
d239 15
a253 23
	pinfo->name[0] = '?';/* fast preload */
	pinfo->name[1] = '\0';

	/*
	 * case 1: reverse-lookup of a number; placed first since this case
	 * is much more frequent if we're scanning.
	 */
	if (pnum) {
		/* Can't be both */
		if (pstring)
			return (0);

		x = pnum;
		if (o_nflag)	/* go faster, skip getservbyblah */
			goto gp_finish;
		y = htons(x);	/* gotta do this -- see Fig.1 below */
		servent = getservbyport(y, o_udpmode ? "udp" : "tcp");
		if (servent) {
			y = ntohs(servent->s_port);
			if (x != y)
				nlog(0, "Warning: port-bynum mismatch, %d != %d", x, y);
			strlcpy(pinfo->name, servent->s_name,
			    sizeof(pinfo->name));
a254 1
		goto gp_finish;
a255 27
	/*
	 * case 2: resolve a string, but we still give preference to numbers
	 * instead of trying to resolve conflicts.  None of the entries in *my*
	 * extensive /etc/services begins with a digit, so this should "always
	 * work" unless you're at 3com and have some company-internal services
	 * defined.
	 */
	if (pstring) {
		/* Can't be both */
		if (pnum)
			return (0);

		x = atoi(pstring);
		if (x)
			return (getpinfo(NULL, x));	/* recurse for
							 * numeric-string-arg */
		if (o_nflag)
			return (0);
		servent = getservbyname(pstring, o_udpmode ? "udp" : "tcp");
		if (servent) {
			strlcpy(pinfo->name, servent->s_name,
			    sizeof(pinfo->name));
			x = ntohs(servent->s_port);
			goto gp_finish;
		}		/* if servent */
	}			/* if pstring */
	return (0);		/* catches any problems so far */
d257 4
a260 9
gp_finish:
	/*
	 * Fall here whether or not we have a valid servent at this point, with
   	 * x containing our [host-order and therefore useful, dammit] port number.
	 */
	sprintf(pinfo->anum, "%d", x);	/* always load any numeric
						 * specs! */
	pinfo->num = (x & 0xffff);	/* u_short, remember... */
	return (pinfo->num);
d264 3
a266 7
 * nextport :
 * Come up with the next port to try, be it random or whatever.  "block" is
 * a ptr to randports array, whose bytes [so far] carry these meanings:
 *	0	ignore
 * 	1	to be tested
 *	2	tested [which is set as we find them here]
 * returns a u_short random port, or 0 if all the t-b-t ones are used up. 
d268 27
a294 6
u_short 
nextport(block)
	char   *block;
{
	unsigned int x;
	unsigned int y;
d296 14
a309 6
	y = 70000;			/* high safety count for rnd-tries */
	while (y > 0) {
		x = (arc4random() & 0xffff);
		if (block[x] == 1) {	/* try to find a not-done one... */
			block[x] = 2;
			break;
a310 5
		x = 0;		
		y--;
	}
	if (x)
		return (x);
d312 1
a312 4
	y = 65535;		/* no random one, try linear downsearch */
	while (y > 0) {		/* if they're all used, we *must* be sure! */
		if (block[y] == 1) {
			block[y] = 2;
d314 6
a319 5
		}
		y--;
	}
	if (y)
		return (y);	/* at least one left */
d321 1
a321 1
	return (0);
d325 3
a327 3
 * loadports :
 * set "to be tested" indications in BLOCK, from LO to HI.  Almost too small
 * to be a separate routine, but makes main() a little cleaner.
d329 8
a336 7
void 
loadports(block, lo, hi)
	char   *block;
	u_short  lo;
	u_short  hi;
{
	u_short  x;
d338 2
a339 10
	if (!block)
		nlog(1, "loadports: no block?!");
	if ((!lo) || (!hi))
		nlog(1, "loadports: bogus values %d, %d", lo, hi);
	x = hi;
	while (lo <= x) {
		block[x] = 1;
		x--;
	}
}
d341 6
d348 2
a349 29
/*
 * doconnect :
 * do all the socket stuff, and return an fd for one of
 *	an open outbound TCP connection
 * 	a UDP stub-socket thingie
 * with appropriate socket options set up if we wanted source-routing, or
 *	an unconnected TCP or UDP socket to listen on.
 * Examines various global o_blah flags to figure out what-all to do. 
 */
int 
doconnect(rad, rp, lad, lp)
	struct in_addr     *rad;
	u_short  rp;
	struct in_addr     *lad;
	u_short  lp;
{
	int nnetfd = 0;
	int rr;
	int     x, y;

	/* grab a socket; set opts */
	while (nnetfd == 0) {
		if (o_udpmode)
			nnetfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
		else
			nnetfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if (nnetfd < 0)
			nlog(1, "Can't get socket");
	}
d351 5
a355 57
	x = 1;
	rr = setsockopt(nnetfd, SOL_SOCKET, SO_REUSEADDR, &x, sizeof(x));
	if (rr == -1)
		nlog(1, NULL);

	/* fill in all the right sockaddr crud */
	lclend->sin_family = AF_INET;
	remend->sin_family = AF_INET;

	/* if lad/lp, do appropriate binding */
	if (lad)
		memcpy(&lclend->sin_addr.s_addr, lad, sizeof(struct in_addr));
	if (lp)
		lclend->sin_port = htons(lp);

	rr = 0;
	if (lad || lp) {
		x = (int) lp;
		/* try a few times for the local bind, a la ftp-data-port... */
		for (y = 4; y > 0; y--) {
			rr = bind(nnetfd, (struct sockaddr *) lclend,
			    sizeof(struct sockaddr_in));
			if (rr == 0)
				break;
			if (errno != EADDRINUSE)
				break;
			else {
				nlog(0, "retrying local %s:%d", inet_ntoa(lclend->sin_addr), lp);
				sleep(2);
			}
		}
	}
	if (rr)
		nlog(1, "Can't grab %s:%d with bind",
		    inet_ntoa(lclend->sin_addr), lp);

	if (o_listen)
		return (nnetfd);/* thanks, that's all for today */

	memcpy(&remend->sin_addr.s_addr, rad, sizeof(struct in_addr));
	remend->sin_port = htons(rp);

	/* wrap connect inside a timer, and hit it */
	arm(1, o_wait);
	if (setjmp(jbuf) == 0) {
		rr = connect(nnetfd, (struct sockaddr *) remend, 
						sizeof(struct sockaddr));
	} else {
		rr = -1;
		errno = ETIMEDOUT;
	}
	arm(0, 0);
	if (rr == 0)
		return (nnetfd);
	close(nnetfd);
	return (-1);
}
d357 3
a359 20
/*
 * dolisten :
 * just like doconnect, and in fact calls a hunk of doconnect, but listens for
 * incoming and returns an open connection *from* someplace.  If we were
 * given host/port args, any connections from elsewhere are rejected.  This
 * in conjunction with local-address binding should limit things nicely.
 */
int 
dolisten(rad, rp, lad, lp)
	struct in_addr     *rad;
	u_short  rp;
	struct in_addr     *lad;
	u_short  lp;
{
	int nnetfd;
	int rr;
	struct host_info   *whozis = NULL;
	int     x;
	char   *cp;
	u_short  z;
d361 3
a363 15
	/*
	 * Pass everything off to doconnect, 
	 * who in o_listen mode just gets a socket 
	 */
	nnetfd = doconnect(rad, rp, lad, lp);
	if (nnetfd <= 0)
		return (-1);
	if (o_udpmode) {
		if (!lp)
			nlog(1, "UDP listen needs -p arg");
	} else {
		rr = listen(nnetfd, 1);
		if (rr < 0)	
			nlog(1, "error listening");
	}
d365 3
a367 50
	if (o_verbose) {
		x = sizeof(struct sockaddr);
		rr = getsockname(nnetfd, (struct sockaddr *) lclend, &x);
		if (rr < 0)
			nlog(0, "local getsockname failed");
		strcpy(bigbuf_net, "listening on [");	/* buffer reuse... */
		if (lclend->sin_addr.s_addr)
			strcat(bigbuf_net, inet_ntoa(lclend->sin_addr));
		else
			strcat(bigbuf_net, "any");
		strcat(bigbuf_net, "] ...");
		z = ntohs(lclend->sin_port);
		nlog(0, "%s %d", bigbuf_net, z);
	}			/* verbose -- whew!! */
	/*
	 * UDP is a speeeeecial case -- we have to do I/O *and* get the
	 * calling party's particulars all at once, listen() and accept()
	 * don't apply. At least in the BSD universe, however, recvfrom/PEEK
	 * is enough to tell us something came in, and we can set things up so
	 * straight read/write actually does work after all.  Yow.  YMMV on
	 * strange platforms!
	 */
	if (o_udpmode) {
		x = sizeof(struct sockaddr);	/* retval for recvfrom */
		arm(2, o_wait);	/* might as well timeout this, too */
		if (setjmp(jbuf) == 0) {	/* do timeout for initial
						 * connect */
			rr = recvfrom(nnetfd, bigbuf_net, BIGSIZ, MSG_PEEK,
					(struct sockaddr *)remend, &x);
		} else
			goto dol_tmo;
		arm(0, 0);
		rr = connect(nnetfd, (struct sockaddr *)remend, 
						sizeof(struct sockaddr));
		goto whoisit;
	}
	/* fall here for TCP */
	x = sizeof(struct sockaddr);
	arm(2, o_wait);	
	if (setjmp(jbuf) == 0) {
		rr = accept(nnetfd, (struct sockaddr *) remend, &x);
	} else
		goto dol_tmo;
	arm(0, 0);
	close(nnetfd);		/* dump the old socket */
	nnetfd = rr;		/* here's our new one */

whoisit:
	if (rr < 0)
		goto dol_err;	/* bail out if any errors so far */
d369 3
a371 34
	/*
	 * Find out what address the connection was *to* on 
	 * our end, in case we're doing a listen-on-any on
	 * a multihomed machine. This allows one to offer 
	 * different services via different alias addresses,
	 * such as the "virtual web site" hack.
	 */
	memset(bigbuf_net, 0, 64);
	cp = &bigbuf_net[32];
	x = sizeof(struct sockaddr);
	rr = getsockname(nnetfd, (struct sockaddr *) lclend, &x);
	if (rr < 0)
		nlog(0, "post-rcv getsockname failed");
	strcpy(cp, inet_ntoa(lclend->sin_addr));

	z = ntohs(remend->sin_port);
	strcpy(bigbuf_net, inet_ntoa(remend->sin_addr));
	whozis = gethinfo(bigbuf_net, o_nflag);
	x = 0;
	if (rad)		/* xxx: fix to go down the *list* if we have
				 * one? */
		if (memcmp(rad, whozis->iaddrs, sizeof(struct sockaddr)))
			x = 1;
	if (rp) {
		if (z != rp)
			x = 1;
	}
	if (x) {
		nlog(1, "invalid connection to [%s] from %s [%s] %d",
		    cp, whozis->name, whozis->addrs[0], z);
	}
	if (o_verbose) {
		nlog(0, "connect to [%s] from %s [%s] %d",	
	    		cp, whozis->name, whozis->addrs[0], z);
a372 1
	return (nnetfd);
d374 1
a374 6
dol_tmo:
	errno = ETIMEDOUT;
dol_err:
	close(nnetfd);
	return (-1);
}
d376 1
a376 38
/*
 * udptest :
 * fire a couple of packets at a UDP target port, just to see if it's really
 * there.  On BSD kernels, ICMP host/port-unreachable errors get delivered to
 * our socket as ECONNREFUSED write errors.  On SV kernels, we lose; we'll have
 * to collect and analyze raw ICMP ourselves a la satan's probe_udp_ports
 * backend.  Guess where one could swipe the appropriate code from...
 * 
 * Use the time delay between writes if given, otherwise use the "tcp ping"
 * trick for getting the RTT.  [I got that idea from pluvius, and warped it.]
 * Return either the original fd, or clean up and return -1. 
 */
int
udptest(fd, where)
	int     fd;
	struct in_addr     *where;
{
	int rr;

	rr = write(fd, bigbuf_in, 1);
	if (rr != 1)
		nlog(0, "udptest first write failed: ");
	if (o_wait)
		sleep(o_wait);
	else {
		o_udpmode = 0;
		o_wait = 5;
		rr = doconnect(where, SLEAZE_PORT, 0, 0);
		if (rr > 0)
			close(rr);
		o_wait = 0;
		o_udpmode++;
	}
	rr = write(fd, bigbuf_in, 1);
	if (rr == 1)
		return (fd);
	close(fd);
	return (-1);
d380 2
a381 10
 * oprint :
 * Hexdump bytes shoveled either way to a running logfile, in the format:
 * D offset       -  - - - --- 16 bytes --- - - -  -     # .... ascii .....
 * where "which" sets the direction indicator, D:
 * 0 -- sent to network, or ">"
 * 1 -- rcvd and printed to stdout, or "<"
 * and "buf" and "n" are data-block and length.  If the current block generates
 * a partial line, so be it; we *want* that lockstep indication of who sent
 * what when.  Adapted from dgaudet's original example -- but must be ripping
 * *fast*, since we don't want to be too disk-bound.
d383 3
a385 5
void 
oprint(which, buf, n)
	int     which;
	char   *buf;
	int     n;
d387 34
a420 44
	int     bc;		/* in buffer count */
	int     obc;		/* current "global" offset */
	int     soc;		/* stage write count */
	unsigned char *p;	/* main buf ptr; m.b. unsigned here */
	unsigned char *op;	/* out hexdump ptr */
	unsigned char *a;	/* out asc-dump ptr */
	int x;
	unsigned int y;

	if (!ofd)
		nlog(1, "oprint called with no open fd?!");
	if (n == 0)
		return;

	op = stage;
	if (which) {
		*op = '<';
		obc = wrote_out;/* use the globals! */
	} else {
		*op = '>';
		obc = wrote_net;
	}
	op++;			/* preload "direction" */
	*op = ' ';
	p = (unsigned char *) buf;
	bc = n;
	stage[59] = '#';	/* preload separator */
	stage[60] = ' ';

	while (bc) {		/* for chunk-o-data ... */
		x = 16;
		soc = 78;	/* len of whole formatted line */
		if (bc < x) {
			soc = soc - 16 + bc;	/* fiddle for however much is
						 * left */
			x = (bc * 3) + 11;	/* 2 digits + space per, after
						 * D & offset */
			op = &stage[x];
			x = 16 - bc;
			while (x) {
				*op++ = ' ';	/* preload filler spaces */
				*op++ = ' ';
				*op++ = ' ';
				x--;
d422 9
a430 29
			x = bc;	/* re-fix current linecount */
		}		/* if bc < x */
		bc -= x;	/* fix wrt current line size */
		sprintf(&stage[2], "%8.8x ", obc);	/* xxx: still slow? */
		obc += x;	/* fix current offset */
		op = &stage[11];/* where hex starts */
		a = &stage[61];	/* where ascii starts */

		while (x) {	/* for line of dump, however long ... */
			y = (int) (*p >> 4);	/* hi half */
			*op = hexnibs[y];
			op++;
			y = (int) (*p & 0x0f);	/* lo half */
			*op = hexnibs[y];
			op++;
			*op = ' ';
			op++;
			if ((*p > 31) && (*p < 127))
				*a = *p;	/* printing */
			else
				*a = '.';	/* nonprinting, loose def */
			a++;
			p++;
			x--;
		}		/* while x */
		*a = '\n';	/* finish the line */
		x = write(ofd, stage, soc);
		if (x < 0)
			nlog(1, "ofd write err");
a433 3
#ifdef TELNET
u_short  o_tn = 0;		/* global -t option */

a434 1
 *  atelnet :
d440 4
a443 3
void 
atelnet(buf, size)
	unsigned char *buf;	/* has to be unsigned here! */
d446 2
a447 2
	static unsigned char obuf[4];	/* tiny thing to build responses into */
	int x;
d455 1
a455 1
		if (*p != 255)	/* IAC? */
d457 6
a462 7
		obuf[0] = 255;
		p++;
		x--;
		if ((*p == 251) || (*p == 252))	/* WILL or WONT */
			y = 254;/* -> DONT */
		if ((*p == 253) || (*p == 254))	/* DO or DONT */
			y = 252;/* -> WONT */
d465 1
a465 2
			p++;
			x--;
d467 2
a468 5
			(void) write(netfd, obuf, 3);
			/* 
			 * if one wanted to bump wrote_net or do
			 * a hexdump line, here's the place.
			 */ 
d472 1
a472 2
		p++;
		x--;
a474 1
#endif /* TELNET */
d477 3
a479 3
 *  readwrite :
 * handle stdin/stdout/network I/O.  Bwahaha!! -- the select loop from hell.
 * In this instance, return what might become our exit status.
d481 3
a483 3
int 
readwrite(fd)
	int     fd;
d485 38
a522 57
	int rr;
	char *zp;	/* stdin buf ptr */
	char *np;	/* net-in buf ptr */
	unsigned int rzleft;
	unsigned int rnleft;
	u_short  netretry;	/* net-read retry counter */
	u_short  wretry;	/* net-write sanity counter */
	u_short  wfirst;	/* one-shot flag to skip first net read */

	/*
	 * if you don't have all this FD_* macro hair in sys/types.h, 
	 * you'll have to either find it or do your own bit-bashing:
	 * *ds1 |= (1 << fd), etc.
	 */
	if (fd > FD_SETSIZE) {
		nlog(0, "Preposterous fd value %d", fd);
		return (1);
	}
	FD_SET(fd, &fds1);
	netretry = 2;
	wfirst = 0;
	rzleft = rnleft = 0;
	if (insaved) {
		rzleft = insaved;	/* preload multi-mode fakeouts */
		zp = bigbuf_in;
		wfirst = 1;
		/* If not scanning, this is a one-off first */
		if (Single)
			insaved = 0;
		else {
			FD_CLR(0, &fds1);
			close(0);
		}
	}
	if (o_interval)
		sleep(o_interval);

	while (FD_ISSET(fd, &fds1)) {	/* i.e. till the *net* closes! */
		struct timeval *tv;

		wretry = 8200;		/* more than we'll ever hafta write */
		if (wfirst) {		/* any saved stdin buffer? */
			wfirst = 0;	/* clear flag for the duration */
			goto shovel;	/* and go handle it first */
		}
		fds2 = fds1;
		if (timer1.tv_sec > 0 || timer1.tv_usec > 0) {
			memcpy(&timer2, &timer1, sizeof(struct timeval));
			tv = &timer2;
		} else
			tv = NULL;
		rr = select(getdtablesize(), &fds2, 0, 0, tv);
		if (rr < 0) {
			if (errno != EINTR) {
				nlog(0, "Select Failure");
				close(fd);
				return (1);
d525 3
a527 99
		/* if we have a timeout AND stdin is closed AND we haven't
		 * heard anything from the net during that time, assume it's
		 * dead and close it too. */
		if (rr == 0) {
			if (!FD_ISSET(0, &fds1))
				netretry--;	/* we actually try a coupla
						 * times. */
			if (!netretry) {
				if (o_verbose > 1)	/* normally we don't
							 * care */
					nlog(0, "net timeout");
				close(fd);
				return (0);	/* not an error! */
			}
		}		/* select timeout */
		/* XXX: should we check the exception fds too?  The read fds
		 * seem to give us the right info, and none of the examples I
		 * found bothered. */
		/* Ding!!  Something arrived, go check all the incoming
		 * hoppers, net first */
		if (FD_ISSET(fd, &fds2)) {	/* net: ding! */
			rr = read(fd, bigbuf_net, BIGSIZ);
			if (rr <= 0) {
				FD_CLR(fd, &fds1);	/* net closed, we'll
							 * finish up... */
				rzleft = 0;	/* can't write anymore: broken
						 * pipe */
			} else {
				rnleft = rr;
				np = bigbuf_net;
#ifdef TELNET
				if (o_tn)
					atelnet(np, rr);	/* fake out telnet stuff */
#endif /* TELNET */
			}
		}
		/* if we're in "slowly" mode there's probably still stuff in
		 * the stdin buffer, so don't read unless we really need MORE
		 * INPUT!  MORE INPUT! */
		if (rzleft)
			goto shovel;

		if (FD_ISSET(0, &fds2)) {
			rr = read(0, bigbuf_in, BIGSIZ);
			if (rr <= 0) {
				FD_CLR(0, &fds1);	/* disable and close */
				close(0);
			} else {
				rzleft = rr;
				zp = bigbuf_in;
				if (!Single) {
					insaved = rr;
					FD_CLR(0, &fds1);
					close(0);
				}
			}
		}
shovel:
		/* sanity check.  Works because they're both unsigned... */
		if ((rzleft > 8200) || (rnleft > 8200)) {
			rzleft = rnleft = 0;
		}
		/* net write retries sometimes happen on UDP connections */
		if (!wretry) {	/* is something hung? */
			nlog(0, "too many output retries");
			return (1);
		}
		if (rnleft) {
			rr = write(1, np, rnleft);
			if (rr > 0) {
				if (o_wfile)
					oprint(1, np, rr);
				np += rr;
				rnleft -= rr;
				wrote_out += rr;	/* global count */
			}
		}
		if (rzleft) {
			if (o_interval)
				rr = findline(zp, rzleft);
			else
				rr = rzleft;
			rr = write(fd, zp, rr);	
			if (rr > 0) {
				if (o_wfile)
					oprint(0, zp, rr);
				zp += rr;
				rzleft -= rr;
				wrote_net += rr;
			}
		}
		if (o_interval) {
			sleep(o_interval);
			continue;
		}
		if ((rzleft) || (rnleft)) {	
			wretry--;
			goto shovel;
		}
a528 299

	close(fd);
	return (0);
}

/* main :
   now we pull it all together... */
int
main(argc, argv)
	int     argc;
	char  **argv;
{
	int x, ch;
	char *cp;
	struct host_info   *gp;
	struct host_info   *whereto = NULL;
	struct host_info   *wherefrom = NULL;
	struct in_addr     *ouraddr = NULL;
	struct in_addr     *themaddr = NULL;
	u_short  o_lport = 0;
	u_short  ourport = 0;
	u_short  loport = 0;	/* for scanning stuff */
	u_short  hiport = 0;
	u_short  curport = 0;
	char   *randports = NULL;

	res_init();
	
	lclend = (struct sockaddr_in *) calloc(1, sizeof(struct sockaddr));
	remend = (struct sockaddr_in *) calloc(1, sizeof(struct sockaddr));
	bigbuf_in = calloc(1, BIGSIZ);
	bigbuf_net = calloc(1, BIGSIZ);
	pinfo= (struct port_info *) calloc(1, sizeof(struct port_info));

	gatesptr = 4;

	/*
	 * We want to catch a few of these signals. 
	 * Others we disgard.
	 */
	signal(SIGINT, catch);
	signal(SIGQUIT, catch);
	signal(SIGTERM, catch);
	signal(SIGURG, SIG_IGN);
	signal(SIGPIPE, SIG_IGN);	/* important! */

	/* 
	 * If no args given at all, get 'em from stdin, construct an argv, 
	 * and hand anything left over to readwrite().
	 */
	if (argc == 1) {
		/* Loop until we get a command to try */
		for (;;) {
			cp = argv[0];
			argv = (char **) calloc(1, 128 * sizeof(char *));
			argv[0] = cp;	/* leave old prog name intact */
			cp = calloc(1, BIGSIZ);
			argv[1] = cp;	/* head of new arg block */
			fprintf(stderr, "Cmd line: ");
			fflush(stderr);	/* I dont care if it's unbuffered or not! */
			insaved = read(0, cp, BIGSIZ-1); /* we're gonna fake fgets()
				 			  * here */
			cp[BIGSIZ-1] = '\0';
			if (*cp != '\n' && *cp != '\t')
				break;
		}
		if (insaved <= 0)
			nlog(1, "wrong");
		x = findline(cp, insaved);
		if (x)
			insaved -= x;	/* remaining chunk size to be sent */
		if (insaved)	/* which might be zero... */
			memcpy(bigbuf_in, &cp[x], insaved);
		cp = strchr(argv[1], '\n');
		if (cp)
			*cp = '\0';
		cp = strchr(argv[1], '\r');	/* look for ^M too */
		if (cp)
			*cp = '\0';

		/*
		 * Find and stash pointers to remaining new "args"
		 */
		cp = argv[1];
		cp++;		/* skip past first char */
		x = 2;		/* we know argv 0 and 1 already */
		for (; *cp != '\0'; cp++) {
			if (*cp == ' ') {
				*cp = '\0';	/* smash all spaces */
				continue;
			} else {
				if (*(cp - 1) == '\0') {
					argv[x] = cp;
					x++;
				}
			}	/* if space */
		}		/* for cp */
		argc = x;
	}

	while ((ch = getopt(argc, argv, "g:G:hi:lno:p:rs:tuvw:z")) != -1) {
		switch (ch) {
		case 'G':			/* srcrt gateways pointer val */
			x = atoi(optarg);
			/* Mask of bits */
			if ((x) && (x == (x & 0x1c)))
				gatesptr = x;
			else
				nlog(1, "invalid hop pointer %d, must be multiple of 4 <= 28", x);
			break;
		case 'g':			/* srcroute hop[s] */
			if (gatesidx > 8)
				nlog(1, "Too many -g hops!");
			if (gates == NULL)
				gates = (struct host_info **) calloc(1, 
						sizeof(struct host_info *) * 10);
			gp = gethinfo(optarg, o_nflag);
			if (gp)
				gates[gatesidx] = gp;
			gatesidx++;
			break;
		case 'h':
			help();
			break;
		case 'i':			/* line-interval time */
			o_interval = atoi(optarg) & 0xffff;
			if (!o_interval)
				nlog(1, "invalid interval time %s", optarg);
			break;
		case 'l':			/* listen mode */
			o_listen++;
			break;
		case 'n':			/* numeric-only, no DNS lookups */
			o_nflag++;
			break;
		case 'o':			/* hexdump log */
			stage = (unsigned char *) optarg;
			o_wfile++;
			break;
		case 'p':			/* local source port */
			o_lport = getpinfo(optarg, 0);
			if (o_lport == 0)
				nlog(1, "invalid local port %s", optarg);
			break;
		case 'r':			/* randomize various things */
			o_random++;
			break;
		/* 
		 * Do a full lookup [since everything else goes through the same 
		 * mill], unless -n was previously specified. In fact, careful
		 * placement of -n can be useful, so we'll still pass o_nflag
		 * here instead of forcing numeric.
		 */
		case 's':			/* local source address */
			wherefrom = gethinfo(optarg, o_nflag);
			ouraddr = &wherefrom->iaddrs[0];
			break;
#ifdef TELNET
		case 't':			/* do telnet fakeout */
			o_tn++;
			break;
#endif
		case 'u':			/* use UDP */
			o_udpmode++;
			break;
		case 'v':			/* verbose */
			o_verbose++;
			break;
		case 'w':			/* wait time */
			o_wait = atoi(optarg);
			if (o_wait <= 0)
				nlog(1, "invalid wait-time %s", optarg);
			timer1.tv_sec = o_wait;
			timer1.tv_usec = 0;
			break;
		case 'z':			/* little or no data xfer */
			o_zero++;
			break;
		default:
			usage(1);
		}
	}

	/* other misc initialization */
	FD_SET(0, &fds1);	/* stdin *is* initially open */
	if (o_random) {
		randports = calloc(1, 65536);   /* big flag array for ports */
	}
	if (o_wfile) {
		ofd = open(stage, O_WRONLY | O_CREAT | O_TRUNC, 0664);
		if (ofd <= 0)	/* must be > extant 0/1/2 */
			nlog(1, "%s: ", stage);
		stage = (unsigned char *) calloc(1, 100);
	}
	/* optind is now index of first non -x arg */
	if (argv[optind])
		whereto = gethinfo(argv[optind], o_nflag);
	if (whereto && whereto->iaddrs)
		themaddr = &whereto->iaddrs[0];
	if (themaddr)
		optind++;	/* skip past valid host lookup */

	/*
	 * Handle listen mode here, and exit afterward.  Only does one connect;
	 * this is arguably the right thing to do.  A "persistent listen-and-fork"
	 * mode a la inetd has been thought about, but not implemented.  A tiny
 	 * wrapper script can handle such things.
	 */
	if (o_listen) {
		curport = 0;
		if (argv[optind]) {
			curport = getpinfo(argv[optind], 0);
			if (curport == 0)
				nlog(1, "invalid port %s", argv[optind]);
		}
		netfd = dolisten(themaddr, curport, ouraddr, o_lport);
		if (netfd > 0) {
			x = readwrite(netfd);
			if (o_verbose)
				nlog(0, "Sent %i Rcvd %i", wrote_net, wrote_out);
			exit(x);
		} else	
			nlog(1, "no connection");
	}
	/* fall thru to outbound connects.  Now we're more picky about args... */
	if (!themaddr)
		nlog(1, "no destination");
	if (argv[optind] == NULL)
		nlog(1, "no port[s] to connect to");
	if (argv[optind + 1])
		Single = 0;
	ourport = o_lport;

	while (argv[optind]) {
		hiport = loport = 0;
		if (cp = strchr(argv[optind], '-')) {
			*cp = '\0';
			cp++;
			hiport = getpinfo(cp, 0);
			if (hiport == 0)
				nlog(1, "invalid port %s", cp);
		}
		loport = getpinfo(argv[optind], 0);
		if (loport == 0)
			nlog(1, "invalid port %s", argv[optind]);
		if (hiport > loport) {
			Single = 0;
			if (o_random) {	
				loadports(randports, loport, hiport);
				curport = nextport(randports);
			} else
				curport = hiport;
		} else
			curport = loport;
	  	    /*
		     * Now start connecting to these things.  
		     * curport is already preloaded.
		     */
		    while (loport <= curport) {
			curport = getpinfo(NULL, curport);
			netfd = doconnect(themaddr, curport, ouraddr, ourport);
			if (netfd > 0)
				if (o_zero && o_udpmode)
					netfd = udptest(netfd, themaddr);
			if (netfd > 0) {
				x = errno = 0;
				if (o_verbose) {
					nlog(0, "%s [%s] %d (%s) open",
				    		whereto->name, 
						whereto->addrs[0], curport, 
						pinfo->name);
				}
				if (!o_zero)
					x = readwrite(netfd);
			} else {
				x = 1;
				if ((Single || (o_verbose > 1)) 
				   || (errno != ECONNREFUSED)) {
					nlog(0, "%s [%s] %d (%s)",
					     whereto->name, whereto->addrs[0], 
					     curport, pinfo->name);
				}
			}
			close(netfd);
			if (o_interval)
				sleep(o_interval);
			if (o_random)
				curport = nextport(randports);
			else
				curport--;
		    }
		optind++;
	}
	errno = 0;
	if (o_verbose > 1)
		nlog(0, "Sent %i Rcvd %i", wrote_net, wrote_out);
	if (Single)
		exit(x);
	exit(0);
d532 4
a535 3
 * nlog:
 * dual purpose function, does both warn() and err()
 * and pays attention to o_verbose.
d537 3
a539 4
void
nlog(doexit, fmt)
	int doexit;
	char *fmt;
d541 1
a541 1
	va_list args;
d543 3
a545 7
	if (o_verbose || doexit) {
		va_start(args, fmt);
		vfprintf(stderr, fmt, args);
		if (h_errno)
                        herror(NULL);
		else if (errno)
			fprintf(stderr, "%s\n", strerror(errno));
d547 1
a547 2
			putc('\n', stderr);
		va_end(args);
d549 1
a549 5
 
	if (doexit)
		exit(1);

	h_errno = errno = 0;
d553 1
a553 2
usage(doexit)
	int doexit;
d555 19
a573 5
	fprintf(stderr, "netcat - [v1.10]\n");
	fprintf(stderr, "nc [-lnrtuvz] [-g intermediates] [-G hopcount] [-i interval] [-o filename]\n");
	fprintf(stderr, "   [-p source port] [-s ip address] [-w timeout] [hostname] [port[s...]]\n");
	if (doexit)
		exit(1);
d577 2
a578 1
help()
d580 4
a583 20
	usage(0);
	fprintf(stderr, "\tCommand Summary:\n\
	 \t-g gateway	source-routing hop point[s], up to 8\n\
  	 \t-G num\t	source-routing pointer: 4, 8, 12, ...\n\
	 \t-h		this help text\n\
	 \t-i secs\t	delay interval for lines sent, ports scanned\n\
	 \t-l		listen mode, for inbound connects\n\
	 \t-n		numeric-only IP addresses, no DNS\n\
	 \t-o file\t	hex dump of traffic\n\
	 \t-r		randomize local and remote ports\n\
	 \t-s addr\t	local source address\n");
#ifdef TELNET
	 fprintf(stderr, "\t\t-t		answer TELNET negotiation\n");
#endif
	 fprintf(stderr, "\t\t-u		UDP mode\n\
	 \t-v		verbose [use twice to be more verbose]\n\
	 \t-w secs\t	timeout for connects and final net reads\n\
	 \t-z		zero-I/O mode [used for scanning]\n\
	 Port numbers can be individual or ranges: lo-hi [inclusive]\n");
	exit(1);
@


1.19
log
@fix verbosity levels. pointed out by J.D. Carlson <jd@@noc7.uchsc.edu>
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.18 2000/12/01 02:25:58 ericj Exp $ */
d1370 2
a1371 3
	fprintf(stderr, "nc [-lnrtuvz] [-e command] [-g intermediates]\n");
	fprintf(stderr, "   [-G hopcount] [-i interval] [-o filename] [-p source port]\n");
	fprintf(stderr, "   [-s ip address] [-w timeout] [hostname] [port[s...]]\n");
@


1.18
log
@-Wall cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.17 2000/09/26 18:53:13 ericj Exp $ */
d942 1
a942 1
				if (o_verbose)	/* normally we don't
d1299 1
a1299 1
				x = 0;
d1310 1
a1310 1
				if ((Single || (o_verbose)) 
d1327 3
a1329 2

	nlog(0, "Sent %i Rcvd %i", wrote_net, wrote_out);
@


1.17
log
@
more cleanup and have nlog() deal with errno now as well.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.16 2000/09/26 17:46:40 ericj Exp $ */
d40 1
d49 1
d691 1
d1341 1
d1366 1
@


1.16
log
@
no need to reset h_errno
do the cmdline correctly, deal with \n and \t
fix up nlog()
use arc4random instead of srandom()/random()
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.15 2000/09/26 05:19:37 ericj Exp $ */
a31 2
#define HAVE_BIND		/* ASSUMPTION -- seems to work everywhere! */

d106 1
a106 2
void	help	__P(());
void	usage	__P((int));
d108 1
d122 1
a122 2
	errno = 0;
	if (o_verbose > 1)	/* normally we don't care */
a198 1
	errno = 0;
a222 1
	errno = 0;
a322 3
	char   *whichp = "tcp";
	if (o_udpmode)
		whichp = "udp";
d340 1
a340 1
		servent = getservbyport(y, whichp);
d343 1
a343 1
			if (x != y)	/* "never happen" */
d366 1
a366 1
		if (o_nflag)	/* can't use names! */
d368 1
a368 1
		servent = getservbyname(pstring, whichp);
a475 1
	errno = 0;
a515 1
				errno = 0;	/* clear from sleep */
a564 1
	errno = 0;
d644 1
a644 1
	if (rr < 0 && o_verbose)
a650 1
	errno = 0;
d696 2
a697 2
	if (rr != 1 && o_verbose)
		nlog(0, "udptest first write failed?! errno %d", errno);
a708 1
	errno = 0;
d717 1
a717 1
 *  oprint :
a907 1
	errno = 0;
a1023 1
			errno = 0;
a1056 1
#ifdef HAVE_BIND
d1058 1
a1058 1
#endif
a1064 1
	errno = 0;
d1215 1
a1215 1
	    FD_SET(0, &fds1);	/* stdin *is* initially open */
d1222 1
a1222 1
			nlog(1, "Can't open %s", stage);
a1231 1
	errno = 0;
d1266 1
a1266 2
		cp = strchr(argv[optind], '-');
		if (cp) {
d1272 1
a1272 1
		}		/* if found a dash */
d1283 1
a1283 1
		} else		/* not a range, including args like "25-25" */
d1307 1
a1307 1
				if ((Single || (o_verbose > 1)) 
d1321 1
a1321 1
		}
a1324 1
	errno = 0;
d1347 2
d1356 2
@


1.15
log
@fix minor typo
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.14 2000/09/26 05:16:00 ericj Exp $ */
a53 4
/* Random Numbers aren't too needed here */
#define SRAND srandom
#define RAND random

a74 2
/* extern int h_errno; */

a202 1
	h_errno = 0;
a227 1
	h_errno = 0;
a307 1
	h_errno = 0;
d415 1
a415 1
		x = (RAND() & 0xffff);
a502 3

	/* fill in all the right sockaddr crud */
	lclend->sin_family = AF_INET;
d1053 1
a1082 1
	h_errno = 0;
d1099 15
a1113 11
		cp = argv[0];
		/* XXX - 128 ? */
		argv = (char **) calloc(1, 128 * sizeof(char *));
		argv[0] = cp;	/* leave old prog name intact */
		cp = calloc(1, BIGSIZ);
		argv[1] = cp;	/* head of new arg block */
		fprintf(stderr, "Cmd line: ");
		fflush(stderr);	/* I dont care if it's unbuffered or not! */
		insaved = read(0, cp, BIGSIZ-1); /* we're gonna fake fgets()
						 * here */
		cp[BIGSIZ-1] = '\0';
a1233 1
		SRAND(time(0));
a1249 1
	h_errno = 0;
d1295 3
a1297 3
		if (hiport > loport) {	/* was it genuinely a range? */
			Single = 0;	/* multi-mode, case B */
			if (o_random) {	/* maybe populate the random array */
d1369 1
@


1.14
log
@no need to use goto..
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.13 2000/09/26 05:03:31 ericj Exp $ */
d615 1
a615 1
		strcat(bigbuf_net, "] %d ...");
@


1.13
log
@
Implement a function for errors
it pays attention to h_error so we now have no need to handle
this ourselves.
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.12 2000/09/26 02:51:22 ericj Exp $ */
d490 1
a490 1
	int nnetfd;
d496 9
a504 9
newskt:
	if (o_udpmode)
		nnetfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	else
		nnetfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (nnetfd < 0)
		nlog(1, "Can't get socket");
	if (nnetfd == 0)	/* if stdin was closed this might *be* 0, */
		goto newskt;	/* so grab another.  See text for why... */
d1368 1
a1368 1
        char *fmt;
d1370 1
a1370 1
        va_list args;
d1372 4
a1375 4
        if (o_verbose || doexit) {
                va_start(args, fmt);
                vfprintf(stderr, fmt, args);
                if (h_errno)
d1377 3
a1379 3
                else
                        putc('\n', stderr);
        }
d1381 2
a1382 2
        if (doexit)
                exit(1);
@


1.12
log
@some warnings should only be shown with -v
@
text
@d1 1
a1 1
/* $OpenBSD: netcat.c,v 1.11 2000/09/26 01:15:49 ericj Exp $ */
d50 1
d79 1
a79 9
extern int h_errno;
/* stolen almost wholesale from bsd herror.c */
static char *h_errs[] = {
	"Error 0",				/* but we *don't* use this */
	"Unknown host",				/* 1 HOST_NOT_FOUND */
	"Host name lookup failure",		/* 2 TRY_AGAIN */
	"Unknown server error",			/* 3 NO_RECOVERY */
	"No address associated with name",	/* 4 NO_ADDRESS */
};
d114 1
d116 1
a116 1
void	help	__P(());
d132 2
a133 2
		errx(1, "Sent %i Rcvd %i", wrote_net, wrote_out);
	errx(1, " punt!");
d143 1
a143 1
		errx(1, "spurious timer interrupt!");
d211 1
a211 1
		warn("DNS fwd/rev mismatch: %s != %s", hinfo->name, hp->h_name);
d240 1
a240 1
		errx(1, "error obtaining host information");
d245 1
a245 1
			errx(1, "Can't parse %s as an IP address", name);
d253 1
a253 1
			errx(1, "%s: forward host lookup failed: ", name);
d275 1
a275 1
				warn("Warning: inverse host lookup failed for %s: ",
d300 1
a300 1
			warn("%s: inverse host lookup failed: ", name);
d305 1
a305 1
				warn("Warning: forward host lookup failed for %s: ",
d361 1
a361 1
				warn("Warning: port-bynum mismatch, %d != %d", x, y);
d463 1
a463 1
		errx(1, "loadports: no block?!");
d465 1
a465 1
		errx(1, "loadports: bogus values %d, %d", lo, hi);
d502 1
a502 1
		errx(1, "Can't get socket");
d508 1
a508 1
		errx(1, NULL);
d535 1
a535 1
				warn("retrying local %s:%d", inet_ntoa(lclend->sin_addr), lp);
d542 1
a542 1
		errx(1, "Can't grab %s:%d with bind",
d598 1
a598 1
			errx(1, "UDP listen needs -p arg");
d602 1
a602 1
			errx(1, "error listening");
d609 1
a609 1
			warn("local getsockname failed");
d617 1
a617 1
		warn("%s %d", bigbuf_net, z);
d668 1
a668 1
		warn("post-rcv getsockname failed");
d685 1
a685 1
		errx(1, "invalid connection to [%s] from %s [%s] %d",
d689 1
a689 1
		warn("connect to [%s] from %s [%s] %d",	
d721 1
a721 1
		warn("udptest first write failed?! errno %d", errno);
d769 1
a769 1
		errx(1, "oprint called with no open fd?!");
d832 1
a832 1
			errx(1, "ofd write err");
d912 1
a912 1
		warn("Preposterous fd value %d", fd);
d952 1
a952 1
				warn("Select Failure");
d967 1
a967 1
					warn("net timeout");
d1021 1
a1021 1
			warn("too many output retries");
d1123 1
a1123 1
			errx(1, "wrong");
d1164 1
a1164 1
				errx(1, "invalid hop pointer %d, must be multiple of 4 <= 28", x);
d1168 1
a1168 1
				errx(1, "Too many -g hops!");
d1183 1
a1183 1
				errx(1, "invalid interval time %s", optarg);
d1198 1
a1198 1
				errx(1, "invalid local port %s", optarg);
d1227 1
a1227 1
				errx(1, "invalid wait-time %s", optarg);
d1248 1
a1248 1
			errx(1, "Can't open %s", stage);
d1272 1
a1272 1
				errx(1, "invalid port %s", argv[optind]);
d1278 1
a1278 1
				warn("Sent %i Rcvd %i", wrote_net, wrote_out);
d1281 1
a1281 1
			errx(1, "no connection");
d1285 1
a1285 1
		errx(1, "no destination");
d1287 1
a1287 1
		errx(1, "no port[s] to connect to");
d1300 1
a1300 1
				errx(1, "invalid port %s", cp);
d1304 1
a1304 1
			errx(1, "invalid port %s", argv[optind]);
d1327 1
a1327 1
					warn("%s [%s] %d (%s) open",
d1338 3
a1340 3
					warn("%s [%s] %d (%s)",
					    whereto->name, whereto->addrs[0], 
							curport, pinfo->name);
d1355 1
a1355 2
	if (o_verbose > 1)
		warn("Sent %i Rcvd %i", wrote_net, wrote_out);
d1359 24
@


1.11
log
@
Alot of cleanups to netcat
use errx/warn instead of homegrown functions
indent properly to make the code readable
get rid of generic.h as its not used
dont declare optarg
register is depreciated
get rid of undocumented options -a and -e
throw out IP_OPTIONS code for now, its not on by default
and doesnt work properly
make usage more like other bsd commands
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d514 1
a514 1
		warn("nnetfd reuseaddr failed");	/* ??? */
d623 1
a623 1
		warn(bigbuf_net, z);
d673 1
a673 1
	if (rr < 0)
d694 4
a697 2
	warn("connect to [%s] from %s [%s] %d",	
	    cp, whozis->name, whozis->addrs[0], z);
d726 1
a726 1
	if (rr != 1)
d971 1
a971 1
				if (o_verbose > 1)	/* normally we don't
a1022 1
			warn("Bogus buffers: %d, %d", rzleft, rnleft);
d1283 1
a1283 1
			if (o_verbose > 1)
@


1.10
log
@a quick fix, and then i run away screaming in terror
@
text
@d1 2
a30 1
#include "generic.h"		/* same as with L5, skey, etc */
a31 3
/* conditional includes -- a very messy section which you may have to dink
   for your own architecture [and please send diffs...]: */
/* #undef _POSIX_SOURCE		/* might need this for something? */
d45 1
d53 3
a55 7
#ifdef HAVE_RANDOM		/* aficionados of ?rand48() should realize */
#define SRAND srandom		/* that this doesn't need *strong* random */
#define RAND random		/* numbers just to mix up port numbers!! */
#else
#define SRAND srand
#define RAND rand
#endif				/* HAVE_RANDOM */
d61 3
a63 4
	char    name[MAXHOSTNAMELEN];	/* dns name */
	char    addrs[8][24];	/* ascii-format IP addresses */
	struct in_addr iaddrs[8];	/* real addresses: in_addr.s_addr:
					 * ulong */
d73 1
a73 1
jmp_buf jbuf;			/* timer crud */
d81 4
a84 4
	"Error 0",		/* but we *don't* use this */
	"Unknown host",		/* 1 HOST_NOT_FOUND */
	"Host name lookup failure",	/* 2 TRY_AGAIN */
	"Unknown server error",	/* 3 NO_RECOVERY */
a93 1
static char wrote_txt[] = " sent %d, rcvd %d";
d98 1
a98 1
struct sockaddr_in    *lclend = NULL;		/* sockaddr_in structs */
d100 3
a102 3
struct host_info  **gates = NULL;		/* LSRR hop hostpoop */
char   *optbuf = NULL;		/* LSRR or sockopts */
char   *bigbuf_in;		/* data buffers */
d105 2
a106 2
struct port_info   *portpoop = NULL;	/* for getportpoop / getservby* */
unsigned char *stage = NULL;	/* hexdump line buffer */
a118 43
/* o_tn in optional section */

/* Debug macro: squirt whatever message and sleep a bit so we can see it go
   by.  need to call like Debug ((stuff)) [with no ; ] so macro args match!
   Beware: writes to stdOUT... */
#ifdef DEBUG
#define Debug(x) printf x; printf ("\n"); fflush (stdout); sleep (1);
#else
#define Debug(x)		/* nil... */
#endif


/* support routines -- the bulk of this thing.  Placed in such an order that
   we don't have to forward-declare anything: */

/* holler :
   fake varargs -- need to do this way because we wind up calling through
   more levels of indirection than vanilla varargs can handle, and not all
   machines have vfprintf/vsyslog/whatever!  6 params oughta be enough. */
void 
holler(str, p1, p2, p3, p4, p5, p6)
	char   *str;
	char   *p1, *p2, *p3, *p4, *p5, *p6;
{
	if (o_verbose) {
		fprintf(stderr, str, p1, p2, p3, p4, p5, p6);
#ifdef HAVE_BIND
		if (h_errno) {	/* if host-lookup variety of error ... */
			if (h_errno > 4)	/* oh no you don't, either */
				fprintf(stderr, "preposterous h_errno: %d", h_errno);
			else
				fprintf(stderr, "%s", h_errs[h_errno]);
			h_errno = 0;	/* and reset for next call */
		}
#endif
		if (errno) {	/* this gives funny-looking messages, but */
			perror(" ");	/* it's more portable than
					 * sys_errlist[]... */
		} else		/* xxx: do something better?  */
			fprintf(stderr, "\n");
		fflush(stderr);
	}
}
d120 13
a132 15
/* bail :
   error-exit handler, callable from anywhere */
void 
bail(str, p1, p2, p3, p4, p5, p6)
	char   *str;
	char   *p1, *p2, *p3, *p4, *p5, *p6;
{
	o_verbose = 1;
	holler(str, p1, p2, p3, p4, p5, p6);
	close(netfd);
	exit(1);
}

/* catch :
   no-brainer interrupt handler */
d138 2
a139 2
		bail(wrote_txt, wrote_net, wrote_out);
	bail(" punt!");
d149 1
a149 1
		bail("spurious timer interrupt!");
d153 4
a156 2
/* arm :
   set the timer.  Zero secs arg means unarm */
d162 1
a162 1
	if (secs == 0) {	/* reset */
d166 1
a166 1
	} else {		/* set */
d170 1
a170 1
	}			/* if secs */
d173 6
a178 4
/* findline :
   find the next newline in a buffer; return inclusive size of that "line",
   or the entire buffer size, so the caller knows how much to then write().
   Not distinguishing \n vs \r\n for the nonce; it just works as is... */
d184 2
a185 2
	register char *p;
	register int x;
a194 1
			Debug(("findline returning %d", x))
d198 1
a198 2
	}			/* for */
	Debug(("findline returning whole thing: %d", siz))
d202 7
a208 5
/* comparehosts :
   cross-check the host_info we have so far against new gethostby*() info,
   and holler about mismatches.  Perhaps gratuitous, but it can't hurt to
   point out when someone's DNS is fukt.  Returns 1 if mismatch, in case
   someone else wants to do something about it. */
d210 2
a211 2
comparehosts(poop, hp)
	struct host_info   *poop;
d216 2
a217 2
	if (strcasecmp(poop->name, hp->h_name) != 0) {	/* normal */
		holler("DNS fwd/rev mismatch: %s != %s", poop->name, hp->h_name);
a220 1
/* ... do we need to do anything over and above that?? */
d223 7
a229 5
/* gethostpoop :
   resolve a host 8 ways from sunday; return a new host_info struct with its
   info.  The argument can be a name or [ascii] IP address; it will try its
   damndest to deal with it.  "numeric" governs whether we do any DNS at all,
   and we also check o_verbose for what's appropriate work to do. */
d231 1
a231 1
gethostpoop(name, numeric)
d237 2
a238 21
	register struct host_info *poop = NULL;
	register int x;

/* I really want to strangle the twit who dreamed up all these sockaddr and
   hostent abstractions, and then forced them all to be incompatible with
   each other so you *HAVE* to do all this ridiculous casting back and forth.
   If that wasn't bad enough, all the doc insists on referring to local ports
   and addresses as "names", which makes NO sense down at the bare metal.

   What an absolutely horrid paradigm, and to think of all the people who
   have been wasting significant amounts of time fighting with this stupid
   deliberate obfuscation over the last 10 years... then again, I like
   languages wherein a pointer is a pointer, what you put there is your own
   business, the compiler stays out of your face, and sheep are nervous.
   Maybe that's why my C code reads like assembler half the time... */

/* If we want to see all the DNS stuff, do the following hair --
   if inet_aton, do reverse and forward with any warnings; otherwise try
   to do forward and reverse with any warnings.  In other words, as long
   as we're here, do a complete DNS check on these clowns.  Yes, it slows
   things down a bit for a first run, but once it's cached, who cares? */
d243 6
a248 4
		poop = (struct host_info *) calloc(1, sizeof(struct host_info));
	if (!poop)
		bail("gethostpoop fuxored");
	strlcpy(poop->name, "(UNKNOWN)", sizeof(poop->name));
d250 2
d253 4
a256 2
		if (numeric)
			bail("Can't parse %s as an IP address", name);
d259 3
a261 3
/* failure to look up a name is fatal, since we can't do anything with it */
			bail("%s: forward host lookup failed: ", name);
		strlcpy(poop->name, hostent->h_name, MAXHOSTNAMELEN);
d263 1
a263 1
			memcpy(&poop->iaddrs[x], hostent->h_addr_list[x],
d265 2
a266 2
			strlcpy(poop->addrs[x], inet_ntoa(poop->iaddrs[x]),
			    sizeof(poop->addrs[0]));
d268 11
a278 6
		if (!o_verbose)	/* if we didn't want to see the */
			return (poop);	/* inverse stuff, we're done. */
/* do inverse lookups in separate loop based on our collected forward addrs,
   since gethostby* tends to crap into the same buffer over and over */
		for (x = 0; poop->iaddrs[x].s_addr && (x < 8); x++) {
			hostent = gethostbyaddr((char *) &poop->iaddrs[x],
d281 2
a282 2
				holler("Warning: inverse host lookup failed for %s: ",
				    poop->addrs[x]);
d284 2
a285 2
				(void) comparehosts(poop, hostent);
		}		/* for x -> addrs, part B */
d288 17
a304 8
		memcpy(poop->iaddrs, &iaddr, sizeof(struct in_addr));
		strlcpy(poop->addrs[0], inet_ntoa(iaddr), sizeof(poop->addrs));
		if (numeric)	/* if numeric-only, we're done */
			return (poop);
		if (!o_verbose)	/* likewise if we don't want */
			return (poop);	/* the full DNS hair */
		hostent = gethostbyaddr((char *) &iaddr, sizeof(struct in_addr), AF_INET);
/* numeric or not, failure to look up a PTR is *not* considered fatal */
d306 1
a306 1
			holler("%s: inverse host lookup failed: ", name);
d308 2
a309 2
			strlcpy(poop->name, hostent->h_name, MAXHOSTNAMELEN);
			hostent = gethostbyname(poop->name);
d311 2
a312 2
				holler("Warning: forward host lookup failed for %s: ",
				    poop->name);
d314 3
a316 3
				(void) comparehosts(poop, hostent);
		}		/* if hostent */
	}			/* INADDR_NONE Great Split */
d318 4
a321 2
/* whatever-all went down previously, we should now have a host_info struct
   with at least one IP address in it. */
d323 1
a323 1
	return (poop);
d326 9
a334 7
/* getportpoop :
   Same general idea as gethostpoop -- look up a port in /etc/services, fill
   in global port_info, but return the actual port *number*.  Pass ONE of:
	pstring to resolve stuff like "23" or "exec";
	pnum to reverse-resolve something that's already a number.
   If o_nflag is on, fill in what we can but skip the getservby??? stuff.
   Might as well have consistent behavior here, and it *is* faster. */
d336 1
a336 1
getportpoop(pstring, pnum)
d341 2
a342 2
	register int x;
	register int y;
a345 2
	portpoop->name[0] = '?';/* fast preload */
	portpoop->name[1] = '\0';
d347 7
a353 2
/* case 1: reverse-lookup of a number; placed first since this case is much
   more frequent if we're scanning */
d355 2
a356 1
		if (pstring)	/* one or the other, pleeze */
d358 1
d367 3
a369 3
				holler("Warning: port-bynum mismatch, %d != %d", x, y);
			strlcpy(portpoop->name, servent->s_name,
			    sizeof(portpoop->name));
d372 3
a374 2
	}			/* if pnum */
	/* case 2: resolve a string, but we still give preference to numbers
d378 2
a379 1
	 * defined... */
d381 2
a382 1
		if (pnum)	/* one or the other, pleeze */
d384 1
d387 1
a387 1
			return (getportpoop(NULL, x));	/* recurse for
d393 2
a394 2
			strlcpy(portpoop->name, servent->s_name,
			    sizeof(portpoop->name));
a400 11
/* Obligatory netdb.h-inspired rant: servent.s_port is supposed to be an int.
   Despite this, we still have to treat it as a short when copying it around.
   Not only that, but we have to convert it *back* into net order for
   getservbyport to work.  Manpages generally aren't clear on all this, but
   there are plenty of examples in which it is just quietly done.  More BSD
   lossage... since everything getserv* ever deals with is local to our own
   host, why bother with all this network-order/host-order crap at all?!
   That should be saved for when we want to actually plug the port[s] into
   some real network calls -- and guess what, we have to *re*-convert at that
   point as well.  Fuckheads. */

d402 5
a406 3
/* Fall here whether or not we have a valid servent at this point, with
   x containing our [host-order and therefore useful, dammit] port number */
	sprintf(portpoop->anum, "%d", x);	/* always load any numeric
d408 2
a409 2
	portpoop->num = (x & 0xffff);	/* u_short, remember... */
	return (portpoop->num);
d412 9
a420 7
/* nextport :
   Come up with the next port to try, be it random or whatever.  "block" is
   a ptr to randports array, whose bytes [so far] carry these meanings:
	0	ignore
	1	to be tested
	2	tested [which is set as we find them here]
   returns a u_short random port, or 0 if all the t-b-t ones are used up. */
d425 2
a426 2
	register unsigned int x;
	register unsigned int y;
d428 1
a428 1
	y = 70000;		/* high safety count for rnd-tries */
d435 1
a435 1
		x = 0;		/* bummer. */
d437 1
a437 1
	}			/* while y */
d448 1
a448 1
	}			/* while y */
d452 1
a452 1
	return (0);		/* no more left! */
d455 5
a459 3
/* loadports :
   set "to be tested" indications in BLOCK, from LO to HI.  Almost too small
   to be a separate routine, but makes main() a little cleaner... */
d469 1
a469 1
		bail("loadports: no block?!");
d471 1
a471 1
		bail("loadports: bogus values %d, %d", lo, hi);
a478 2
#ifdef GAPING_SECURITY_HOLE
char   *pr00gie = NULL;		/* global ptr to -e arg */
d480 9
a488 33
/* doexec :
   fiddle all the file descriptors around, and hand off to another prog.  Sort
   of like a one-off "poor man's inetd".  This is the only section of code
   that would be security-critical, which is why it's ifdefed out by default.
   Use at your own hairy risk; if you leave shells lying around behind open
   listening ports you deserve to lose!! */
doexec(fd)
	int     fd;
{
	register char *p;

	dup2(fd, 0);		/* the precise order of fiddlage */
	close(fd);		/* is apparently crucial; this is */
	dup2(0, 1);		/* swiped directly out of "inetd". */
	dup2(0, 2);
	p = strrchr(pr00gie, '/');	/* shorter argv[0] */
	if (p)
		p++;
	else
		p = pr00gie;
	Debug(("gonna exec %s as %s...", pr00gie, p))
	    execl(pr00gie, p, NULL);
	bail("exec %s failed", pr00gie);	/* this gets sent out.  Hmm... */
}
#endif				/* GAPING_SECURITY_HOLE */

/* doconnect :
   do all the socket stuff, and return an fd for one of
	an open outbound TCP connection
	a UDP stub-socket thingie
   with appropriate socket options set up if we wanted source-routing, or
	an unconnected TCP or UDP socket to listen on.
   Examines various global o_blah flags to figure out what-all to do. */
d496 2
a497 2
	register int nnetfd;
	register int rr;
d501 1
a501 1
/* grab a socket; set opts */
d508 1
a508 1
		bail("Can't get socket");
d514 1
a514 14
		holler("nnetfd reuseaddr failed");	/* ??? */
#ifdef SO_REUSEPORT		/* doesnt exist everywhere... */
	rr = setsockopt(nnetfd, SOL_SOCKET, SO_REUSEPORT, &x, sizeof(x));
	if (rr == -1)
		holler("nnetfd reuseport failed");	/* ??? */
#endif
#if 0
/* If you want to screw with RCVBUF/SNDBUF, do it here.  Liudvikas Bukys at
   Rochester sent this example, which would involve YET MORE options and is
   just archived here in case you want to mess with it.  o_xxxbuf are global
   integers set in main() getopt loop, and check for rr == 0 afterward. */
	rr = setsockopt(nnetfd, SOL_SOCKET, SO_RCVBUF, &o_rcvbuf, sizeof o_rcvbuf);
	rr = setsockopt(nnetfd, SOL_SOCKET, SO_SNDBUF, &o_sndbuf, sizeof o_sndbuf);
#endif
d519 1
a519 1
/* fill in all the right sockaddr crud */
d523 1
a523 1
/* if lad/lp, do appropriate binding */
d528 1
d532 1
a532 1
/* try a few times for the local bind, a la ftp-data-port... */
d541 1
a541 1
				holler("retrying local %s:%d", inet_ntoa(lclend->sin_addr), lp);
d544 3
a546 3
			}	/* if EADDRINUSE */
		}		/* for y counter */
	}			/* if lad or lp */
d548 1
a548 1
		bail("Can't grab %s:%d with bind",
a556 69
/* rough format of LSRR option and explanation of weirdness.
Option comes after IP-hdr dest addr in packet, padded to *4, and ihl > 5.
IHL is multiples of 4, i.e. real len = ip_hl << 2.
	type 131	1	; 0x83: copied, option class 0, number 3
	len		1	; of *whole* option!
	pointer		1	; nxt-hop-addr; 1-relative, not 0-relative
	addrlist...	var	; 4 bytes per hop-addr
	pad-to-32	var	; ones, i.e. "NOP"

If we want to route A -> B via hops C and D, we must add C, D, *and* B to the
options list.  Why?  Because when we hand the kernel A -> B with list C, D, B
the "send shuffle" inside the kernel changes it into A -> C with list D, B and
the outbound packet gets sent to C.  If B wasn't also in the hops list, the
final destination would have been lost at this point.

When C gets the packet, it changes it to A -> D with list C', B where C' is
the interface address that C used to forward the packet.  This "records" the
route hop from B's point of view, i.e. which address points "toward" B.  This
is to make B better able to return the packets.  The pointer gets bumped by 4,
so that D does the right thing instead of trying to forward back to C.

When B finally gets the packet, it sees that the pointer is at the end of the
LSRR list and is thus "completed".  B will then try to use the packet instead
of forwarding it, i.e. deliver it up to some application.

Note that by moving the pointer yourself, you could send the traffic directly
to B but have it return via your preconstructed source-route.  Playing with
this and watching "tcpdump -v" is the best way to understand what's going on.

Only works for TCP in BSD-flavor kernels.  UDP is a loss; udp_input calls
stripoptions() early on, and the code to save the srcrt is notdef'ed.
Linux is also still a loss at 1.3.x it looks like; the lsrr code is { }...
*/

/* if any -g arguments were given, set up source-routing.  We hit this after
   the gates are all looked up and ready to rock, any -G pointer is set,
   and gatesidx is now the *number* of hops */
	if (gatesidx) {		/* if we wanted any srcrt hops ... */
/* don't even bother compiling if we can't do IP options here! */
#ifdef IP_OPTIONS
		if (!optbuf) {	/* and don't already *have* a srcrt set */
			char   *opp;	/* then do all this setup hair */
			optbuf = calloc(1, 48);
			opp = optbuf;
			*opp++ = IPOPT_LSRR;	/* option */
			*opp++ = (char)
			    (((gatesidx + 1) * sizeof(struct in_addr)) + 3) & 0xff;	/* length */
			*opp++ = gatesptr;	/* pointer */
/* opp now points at first hop addr -- insert the intermediate gateways */
			for (x = 0; x < gatesidx; x++) {
				memcpy(opp, gates[x]->iaddrs, sizeof(struct in_addr));
				opp += sizeof(struct in_addr);
			}
/* and tack the final destination on the end [needed!] */
			memcpy(opp, rad, sizeof(struct in_addr));
			opp += sizeof(struct in_addr);
			*opp = IPOPT_NOP;	/* alignment filler */
		}		/* if empty optbuf */
		/* calculate length of whole option mess, which is (3 + [hops]
		 * + [final] + 1), and apply it [have to do this every time
		 * through, of course] */
		x = ((gatesidx + 1) * sizeof(struct in_addr)) + 4;
		rr = setsockopt(nnetfd, IPPROTO_IP, IP_OPTIONS, optbuf, x);
		if (rr == -1)
			bail("srcrt setsockopt fuxored");
#else				/* IP_OPTIONS */
		holler("Warning: source routing unavailable on this machine, ignoring");
#endif				/* IP_OPTIONS */
	}			/* if gatesidx */
d560 3
a562 2
		rr = connect(nnetfd, (struct sockaddr *) remend, sizeof(struct sockaddr));
	} else {		/* setjmp: connect failed... */
d564 1
a564 1
		errno = ETIMEDOUT;	/* fake it */
d569 1
a569 1
	close(nnetfd);		/* clean up junked socket FD!! */
d573 7
a579 5
/* dolisten :
   just like doconnect, and in fact calls a hunk of doconnect, but listens for
   incoming and returns an open connection *from* someplace.  If we were
   given host/port args, any connections from elsewhere are rejected.  This
   in conjunction with local-address binding should limit things nicely... */
d587 2
a588 2
	register int nnetfd;
	register int rr;
d595 4
a598 1
/* Pass everything off to doconnect, who in o_listen mode just gets a socket */
d602 3
a604 3
	if (o_udpmode) {	/* apparently UDP can listen ON */
		if (!lp)	/* "port 0",  but that's not useful */
			bail("UDP listen needs -p arg");
d606 3
a608 3
		rr = listen(nnetfd, 1);	/* gotta listen() before we can get */
		if (rr < 0)	/* our local random port.  sheesh. */
			bail("local listen fuxored");
a610 9
/* Various things that follow temporarily trash bigbuf_net, which might contain
   a copy of any recvfrom()ed packet, but we'll read() another copy later. */

/* I can't believe I have to do all this to get my own goddamn bound address
   and port number.  It should just get filled in during bind() or something.
   All this is only useful if we didn't say -p for listening, since if we
   struct sockaddr_ind -p we *know* what port we're listening on.  At any rate we won't bother
   with it all unless we wanted to see it, although listening quietly on a
   random unknown port is probably not very useful without "netstat". */
d612 1
a612 1
		x = sizeof(struct sockaddr);	/* how 'bout getsockNUM instead, pinheads?! */
d615 1
a615 1
			holler("local getsockname failed");
d623 1
a623 1
		holler(bigbuf_net, z);
d625 2
a626 1
	/* UDP is a speeeeecial case -- we have to do I/O *and* get the
d631 2
a632 1
	 * strange platforms!  */
d638 2
a639 3
			rr = recvfrom	/* and here we block... */
			    (nnetfd, bigbuf_net, BIGSIZ, MSG_PEEK, (struct sockaddr *) remend, &x);
			Debug(("dolisten/recvfrom ding, rr = %d, netbuf %s ", rr, bigbuf_net))
d641 1
a641 1
			goto dol_tmo;	/* timeout */
d643 2
a644 12
/* I'm not completely clear on how this works -- BSD seems to make UDP
   just magically work in a connect()ed context, but we'll undoubtedly run
   into systems this deal doesn't work on.  For now, we apparently have to
   issue a connect() on our just-tickled socket so we can write() back.
   Again, why the fuck doesn't it just get filled in and taken care of?!
   This hack is anything but optimal.  Basically, if you want your listener
   to also be able to send data back, you need this connect() line, which
   also has the side effect that now anything from a different source or even a
   different port on the other end won't show up and will cause ICMP errors.
   I guess that's what they meant by "connect".
   Let's try to remember what the "U" is *really* for, eh? */
		rr = connect(nnetfd, (struct sockaddr *) remend, sizeof(struct sockaddr));
d646 1
a646 1
	}			/* o_udpmode */
d648 2
a649 2
	x = sizeof(struct sockaddr);		/* retval for accept */
	arm(2, o_wait);		/* wrap this in a timer, too; 0 = forever */
d653 1
a653 1
		goto dol_tmo;	/* timeout */
d662 7
a668 37
/* If we can, look for any IP options.  Useful for testing the receiving end of
   such things, and is a good exercise in dealing with it.  We do this before
   the connect message, to ensure that the connect msg is uniformly the LAST
   thing to emerge after all the intervening crud.  Doesn't work for UDP on
   any machines I've tested, but feel free to surprise me. */
#ifdef IP_OPTIONS
	if (!o_verbose)		/* if we wont see it, we dont care */
		goto dol_noop;
	optbuf = calloc(1, 40);
	x = 40;
	rr = getsockopt(nnetfd, IPPROTO_IP, IP_OPTIONS, optbuf, &x);
	if (rr < 0)
		holler("getsockopt failed");
	Debug(("ipoptions ret len %d", x))
	    if (x) {		/* we've got options, lessee em... */
		unsigned char *q = (unsigned char *) optbuf;
		char   *p = bigbuf_net;	/* local variables, yuk! */
		char   *pp = &bigbuf_net[128];	/* get random space farther
						 * out... */
		memset(bigbuf_net, 0, 256);	/* clear it all first */
		while (x > 0) {
			sprintf(pp, "%2.2x ", *q);	/* clumsy, but works:
							 * turn into hex */
			strcat(p, pp);	/* and build the final string */
			q++;
			p++;
			x--;
		}
		holler("IP options: %s", bigbuf_net);
	}			/* if x, i.e. any options */
dol_noop:
#endif				/* IP_OPTIONS */

/* find out what address the connection was *to* on our end, in case we're
   doing a listen-on-any on a multihomed machine.  This allows one to
   offer different services via different alias addresses, such as the
   "virtual web site" hack. */
d674 1
a674 1
		holler("post-rcv getsockname failed");
a676 9
/* now check out who it is.  We don't care about mismatched DNS names here,
   but any ADDR and PORT we specified had better fucking well match the caller.
   Converting from addr to inet_ntoa and back again is a bit of a kludge, but
   gethostpoop wants a string and there's much gnarlier code out there already,
   so I don't feel bad.
   The *real* question is why BFD sockets wasn't designed to allow listens for
   connections *from* specific hosts/ports, instead of requiring the caller to
   accept the connection and then reject undesireable ones by closing.  In
   other words, we need a TCP MSG_PEEK. */
d679 1
a679 1
	whozis = gethostpoop(bigbuf_net, o_nflag);
d681 1
a681 1
	x = 0;			/* use as a flag... */
d686 1
a686 1
	if (rp)
d689 3
a691 2
	if (x)			/* guilty! */
		bail("invalid connection to [%s] from %s [%s] %d",
d693 2
a694 1
	holler("connect to [%s] from %s [%s] %d",	/* oh, you're okay.. */
d696 1
a696 1
	return (nnetfd);	/* open! */
d699 1
a699 1
	errno = ETIMEDOUT;	/* fake it */
d705 12
a716 10
/* udptest :
   fire a couple of packets at a UDP target port, just to see if it's really
   there.  On BSD kernels, ICMP host/port-unreachable errors get delivered to
   our socket as ECONNREFUSED write errors.  On SV kernels, we lose; we'll have
   to collect and analyze raw ICMP ourselves a la satan's probe_udp_ports
   backend.  Guess where one could swipe the appropriate code from...

   Use the time delay between writes if given, otherwise use the "tcp ping"
   trick for getting the RTT.  [I got that idea from pluvius, and warped it.]
   Return either the original fd, or clean up and return -1. */
d721 1
a721 1
	register int rr;
d725 1
a725 1
		holler("udptest first write failed?! errno %d", errno);
d729 2
a730 7
/* use the tcp-ping trick: try connecting to a normally refused port, which
   causes us to block for the time that SYN gets there and RST gets back.
   Not completely reliable, but it *does* mostly work. */
		o_udpmode = 0;	/* so doconnect does TCP this time */
/* Set a temporary connect timeout, so packet filtration doesnt cause
   us to hang forever, and hit it */
		o_wait = 5;	/* enough that we'll notice?? */
d733 5
a737 5
			close(rr);	/* in case it *did* open */
		o_wait = 0;	/* reset it */
		o_udpmode++;	/* we *are* still doing UDP, right? */
	}			/* if o_wait */
	errno = 0;		/* clear from sleep */
d739 1
a739 1
	if (rr == 1)		/* if write error, no UDP listener */
d741 1
a741 1
	close(fd);		/* use it or lose it! */
d745 12
a756 10
/* oprint :
   Hexdump bytes shoveled either way to a running logfile, in the format:
D offset       -  - - - --- 16 bytes --- - - -  -     # .... ascii .....
   where "which" sets the direction indicator, D:
	0 -- sent to network, or ">"
	1 -- rcvd and printed to stdout, or "<"
   and "buf" and "n" are data-block and length.  If the current block generates
   a partial line, so be it; we *want* that lockstep indication of who sent
   what when.  Adapted from dgaudet's original example -- but must be ripping
   *fast*, since we don't want to be too disk-bound... */
d766 5
a770 5
	register unsigned char *p;	/* main buf ptr; m.b. unsigned here */
	register unsigned char *op;	/* out hexdump ptr */
	register unsigned char *a;	/* out asc-dump ptr */
	register int x;
	register unsigned int y;
d773 1
a773 1
		bail("oprint called with no open fd?!");
d836 2
a837 2
			bail("ofd write err");
	}			/* while bc */
d843 7
a849 5
/* atelnet :
   Answer anything that looks like telnet negotiation with don't/won't.
   This doesn't modify any data buffers, update the global output count,
   or show up in a hexdump -- it just shits into the outgoing stream.
   Idea and codebase from Mudge@@l0pht.com. */
d856 3
a858 3
	register int x;
	register unsigned char y;
	register unsigned char *p;
d877 1
a877 1
			obuf[2] = *p;	/* copy actual option byte */
d879 4
a882 1
/* if one wanted to bump wrote_net or do a hexdump line, here's the place */
d884 1
a884 1
		}		/* if y */
d888 1
a888 1
	}			/* while x */
d890 1
d892 5
a896 5
#endif				/* TELNET */

/* readwrite :
   handle stdin/stdout/network I/O.  Bwahaha!! -- the select loop from hell.
   In this instance, return what might become our exit status. */
d901 3
a903 3
	register int rr;
	register char *zp;	/* stdin buf ptr */
	register char *np;	/* net-in buf ptr */
d907 2
a908 2
	u_short  wretry;		/* net-write sanity counter */
	u_short  wfirst;		/* one-shot flag to skip first net read */
d910 5
a914 2
/* if you don't have all this FD_* macro hair in sys/types.h, you'll have to
   either find it or do your own bit-bashing: *fds1 |= (1 << fd), etc... */
d916 1
a916 1
		holler("Preposterous fd value %d", fd);
d919 1
a919 1
	FD_SET(fd, &fds1);	/* global: the net is open */
d927 3
a929 3
		if (Single)	/* if not scanning, this is a one-off first */
			insaved = 0;	/* buffer left over from argv
					 * construction, */
d931 4
a934 5
			FD_CLR(0, &fds1);	/* OR we've already got our
						 * repeat chunk, */
			close(0);	/* so we won't need any more stdin */
		}		/* Single */
	}			/* insaved */
d936 2
a937 2
		sleep(o_interval);	/* pause *before* sending stuff, too */
	errno = 0;		/* clear from sleep, close, whatever */
a938 1
/* and now the big ol' select shoveling loop ... */
d942 2
a943 2
		wretry = 8200;	/* more than we'll ever hafta write */
		if (wfirst) {	/* any saved stdin buffer? */
d955 2
a956 3
			if (errno != EINTR) {	/* might have gotten ^Zed, etc
						 * ? */
				holler("select fuxored");
d960 1
a960 1
		}		/* select fuckup */
d971 1
a971 1
					holler("net timeout");
d976 1
a976 1
		/* xxx: should we check the exception fds too?  The read fds
d994 3
a996 4
#endif				/* TELNET */
			}	/* if rr */
			Debug(("got %d from the net, errno %d", rr, errno))
		}		/* net:ding */
d1003 1
a1003 2
/* okay, suck more stdin */
		if (FD_ISSET(0, &fds2)) {	/* stdin: ding! */
d1005 2
a1006 5
/* Considered making reads here smaller for UDP mode, but 8192-byte
   mobygrams are kinda fun and exercise the reassembler. */
			if (rr <= 0) {	/* at end, or fukt, or ... */
				FD_CLR(0, &fds1);	/* disable and close
							 * stdin */
d1011 7
a1017 10
/* special case for multi-mode -- we'll want to send this one buffer to every
   open TCP port or every UDP attempt, so save its size and clean up stdin */
				if (!Single) {	/* we might be scanning... */
					insaved = rr;	/* save len */
					FD_CLR(0, &fds1);	/* disable further junk
								 * from stdin */
					close(0);	/* really, I mean it */
				}	/* Single */
			}	/* if rr/read */
		}		/* stdin:ding */
d1019 1
a1019 5
/* now that we've dingdonged all our thingdings, send off the results.
   Geez, why does this look an awful lot like the big loop in "rsh"? ...
   not sure if the order of this matters, but write net -> stdout first. */

/* sanity check.  Works because they're both unsigned... */
d1021 1
a1021 1
			holler("Bogus buffers: %d, %d", rzleft, rnleft);
d1024 1
a1024 1
/* net write retries sometimes happen on UDP connections */
d1026 1
a1026 1
			holler("too many output retries");
d1033 3
a1035 4
					oprint(1, np, rr);	/* log the stdout */
				np += rr;	/* fix up ptrs and whatnot */
				rnleft -= rr;	/* will get sanity-checked
						 * above */
d1038 1
a1038 2
			Debug(("wrote %d to stdout, errno %d", rr, errno))
		}		/* rnleft */
d1040 1
a1040 1
			if (o_interval)	/* in "slowly" mode ?? */
d1044 1
a1044 2
			rr = write(fd, zp, rr);	/* one line, or the whole
						 * buffer */
d1047 1
a1047 1
					oprint(0, zp, rr);	/* log what got sent */
d1050 1
a1050 1
				wrote_net += rr;	/* global count */
d1052 2
a1053 3
			Debug(("wrote %d to net, errno %d", rr, errno))
		}		/* rzleft */
		if (o_interval) {	/* cycle between slow lines, or ... */
d1055 2
a1056 2
			errno = 0;	/* clear from sleep */
			continue;	/* ...with hairy select loop... */
d1058 2
a1059 3
		if ((rzleft) || (rnleft)) {	/* shovel that shit till they
						 * ain't */
			wretry--;	/* none left, and get another load */
d1062 1
a1062 1
	}			/* while fds1:netfd is open */
a1063 5
/* XXX: maybe want a more graceful shutdown() here, or screw around with
   linger times??  I suspect that I don't need to since I'm always doing
   blocking reads and writes and my own manual "last ditch" efforts to read
   the net again after a timeout.  I haven't seen any screwups yet, but it's
   not like my test network is particularly busy... */
d1074 2
a1075 6
#ifndef HAVE_GETOPT
	extern char *optarg;
	extern int optind, optopt;
#endif
	register int x;
	register char *cp;
a1088 1
/* can *you* say "cc -yaddayadda netcat.c -lresolv -l44bsd" on SunLOSs? */
a1090 2
/* I was in this barbershop quartet in Skokie IL ... */
/* round up the usual suspects, i.e. malloc up all the stuff we need */
d1095 1
a1095 1
	portpoop = (struct port_info *) calloc(1, sizeof(struct port_info));
d1101 4
a1104 1
/* catch a signal or two for cleanup */
a1107 2
/* and suppress others... */
#ifdef SIGURG
a1108 2
#endif
#ifdef SIGPIPE
a1109 1
#endif
d1111 4
a1114 2
/* if no args given at all, get 'em from stdin, construct an argv, and hand
   anything left over to readwrite(). */
d1117 2
a1118 1
		argv = (char **) calloc(1, 128 * sizeof(char *));	/* XXX: 128? */
d1128 1
a1128 1
			bail("wrong");
d1141 3
a1143 1
/* find and stash pointers to remaining new "args" */
d1159 5
a1163 18
	}			/* if no args given */
	/* If your shitbox doesn't have getopt, step into the nineties
	 * already. */
	/* optarg, optind = next-argv-component [i.e. flag arg]; optopt =
	 * last-char */
	while ((x = getopt(argc, argv, "ae:g:G:hi:lno:p:rs:tuvw:z")) != -1) {
/* Debug (("in go: x now %c, optarg %x optind %d", x, optarg, optind)) */
		switch (x) {
		case 'a':
			bail("all-A-records NIY");
			o_alla++;
			break;
#ifdef GAPING_SECURITY_HOLE
		case 'e':	/* prog to exec */
			pr00gie = optarg;
			break;
#endif
		case 'G':	/* srcrt gateways pointer val */
d1165 2
a1166 2
			if ((x) && (x == (x & 0x1c)))	/* mask off bits of fukt
							 * values */
d1169 1
a1169 1
				bail("invalid hop pointer %d, must be multiple of 4 <= 28", x);
d1171 1
a1171 1
		case 'g':	/* srcroute hop[s] */
d1173 5
a1177 4
				bail("too many -g hops");
			if (gates == NULL)	/* eat this, Billy-boy */
				gates = (struct host_info **) calloc(1, sizeof(struct host_info *) * 10);
			gp = gethostpoop(optarg, o_nflag);
d1183 3
a1185 3
			errno = 0;
			helpme();	/* exits by itself */
		case 'i':	/* line-interval time */
d1188 1
a1188 1
				bail("invalid interval time %s", optarg);
d1190 1
a1190 1
		case 'l':	/* listen mode */
d1193 1
a1193 1
		case 'n':	/* numeric-only, no DNS lookups */
d1196 1
a1196 1
		case 'o':	/* hexdump log */
d1200 2
a1201 2
		case 'p':	/* local source port */
			o_lport = getportpoop(optarg, 0);
d1203 1
a1203 1
				bail("invalid local port %s", optarg);
d1205 1
a1205 1
		case 'r':	/* randomize various things */
d1208 8
a1215 5
		case 's':	/* local source address */
/* do a full lookup [since everything else goes through the same mill],
   unless -n was previously specified.  In fact, careful placement of -n can
   be useful, so we'll still pass o_nflag here instead of forcing numeric.  */
			wherefrom = gethostpoop(optarg, o_nflag);
d1219 1
a1219 1
		case 't':	/* do telnet fakeout */
d1222 2
a1223 2
#endif				/* TELNET */
		case 'u':	/* use UDP */
d1226 1
a1226 1
		case 'v':	/* verbose */
d1229 1
a1229 1
		case 'w':	/* wait time */
d1232 1
a1232 1
				bail("invalid wait-time %s", optarg);
d1236 1
a1236 1
		case 'z':	/* little or no data xfer */
d1240 3
a1242 4
			errno = 0;
			bail("nc -h for help");
		}		/* switch x */
	}			/* while getopt */
d1244 1
a1244 2
/* other misc initialization */
	Debug(("fd_set size %d", sizeof(*fds1)))	/* how big *is* it? */
d1248 1
a1248 1
		randports = calloc(1, 65536);	/* big flag array for ports */
a1249 7
#ifdef GAPING_SECURITY_HOLE
	if (pr00gie) {
		close(0);	/* won't need stdin */
		o_wfile = 0;	/* -o with -e is meaningless! */
		ofd = 0;
	}
#endif				/* G_S_H */
d1253 1
a1253 1
			bail("can't open %s", stage);
d1256 3
a1258 8
/* optind is now index of first non -x arg */
	Debug(("after go: x now %c, optarg %x optind %d", x, optarg, optind))
/* Debug (("optind up to %d at host-arg %s", optind, argv[optind])) */
/* gonna only use first addr of host-list, like our IQ was normal; if you wanna
   get fancy with addresses, look up the list yourself and plug 'em in for now.
   unless we finally implement -a, that is. */
	    if (argv[optind])
		whereto = gethostpoop(argv[optind], o_nflag);
d1266 6
a1271 4
/* Handle listen mode here, and exit afterward.  Only does one connect;
   this is arguably the right thing to do.  A "persistent listen-and-fork"
   mode a la inetd has been thought about, but not implemented.  A tiny
   wrapper script can handle such things... */
d1273 6
a1278 7
		curport = 0;	/* rem port *can* be zero here... */
		if (argv[optind]) {	/* any rem-port-arg? */
			curport = getportpoop(argv[optind], 0);
			if (curport == 0)	/* if given, demand
						 * correctness */
				bail("invalid port %s", argv[optind]);
		}		/* if port-arg */
a1279 1
/* dolisten does its own connect reporting, so we don't holler anything here */
d1281 7
a1287 11
#ifdef GAPING_SECURITY_HOLE
			if (pr00gie)	/* -e given? */
				doexec(netfd);
#endif				/* GAPING_SECURITY_HOLE */
			x = readwrite(netfd);	/* it even works with UDP! */
			if (o_verbose > 1)	/* normally we don't care */
				holler(wrote_txt, wrote_net, wrote_out);
			exit(x);/* "pack out yer trash" */
		} else		/* if no netfd */
			bail("no connection");
	}			/* o_listen */
d1290 1
a1290 1
		bail("no destination");
d1292 5
a1296 9
		bail("no port[s] to connect to");
	if (argv[optind + 1])	/* look ahead: any more port args given? */
		Single = 0;	/* multi-mode, case A */
	ourport = o_lport;	/* which can be 0 */

/* everything from here down is treated as as ports and/or ranges thereof, so
   it's all enclosed in this big ol' argv-parsin' loop.  Any randomization is
   done within each given *range*, but in separate chunks per each succeeding
   argument, so we can control the pattern somewhat. */
d1299 1
a1299 1
		cp = strchr(argv[optind], '-');	/* nn-mm range? */
d1303 1
a1303 1
			hiport = getportpoop(cp, 0);
d1305 1
a1305 1
				bail("invalid port %s", cp);
d1307 1
a1307 1
		loport = getportpoop(argv[optind], 0);
d1309 1
a1309 1
			bail("invalid port %s", argv[optind]);
a1311 1
			curport = hiport;	/* start high by default */
d1315 2
a1316 1
			}
d1319 4
a1322 2
		Debug(("Single %d, curport %d", Single, curport))
/* Now start connecting to these things.  curport is already preloaded. */
d1324 1
a1324 10
			if ((!o_lport) && (o_random)) {	/* -p overrides random
							 * local-port */
				ourport = (RAND() & 0xffff);	/* random local-bind --
								 * well above */
				if (ourport < 8192)	/* resv and any likely
							 * listeners??? */
					ourport += 8192;	/* if it *still*
								 * conflicts, use -s. */
			}
			curport = getportpoop(NULL, curport);
d1326 2
a1327 3
			Debug(("netfd %d from port %d to port %d", netfd, ourport, curport))
			    if (netfd > 0)
				if (o_zero && o_udpmode)	/* if UDP scanning... */
d1329 8
a1336 9
			if (netfd > 0) {	/* Yow, are we OPEN YET?! */
				x = 0;	/* pre-exit status */
				holler("%s [%s] %d (%s) open",
				    whereto->name, whereto->addrs[0], curport, portpoop->name);
#ifdef GAPING_SECURITY_HOLE
				if (pr00gie)	/* exec is valid for outbound,
						 * too */
					doexec(netfd);
#endif				/* GAPING_SECURITY_HOLE */
d1338 11
a1348 10
					x = readwrite(netfd);	/* go shovel shit */
			} else {/* no netfd... */
				x = 1;	/* preload exit status for later */
/* if we're scanning at a "one -v" verbosity level, don't print refusals.
   Give it another -v if you want to see everything. */
				if ((Single || (o_verbose > 1)) || (errno != ECONNREFUSED))
					holler("%s [%s] %d (%s)",
					    whereto->name, whereto->addrs[0], curport, portpoop->name);
			}	/* if netfd */
			close(netfd);	/* just in case we didn't already */
d1350 1
a1350 2
				sleep(o_interval);	/* if -i, delay between
							 * ports too */
d1354 2
a1355 2
				curport--;	/* just decrement... */
		}		/* while curport within current range */
d1357 1
a1357 2
	}			/* while remaining port-args -- end of big
				 * argv-ports loop */
d1360 2
a1361 2
	if (o_verbose > 1)	/* normally we don't care */
		holler(wrote_txt, wrote_net, wrote_out);
d1363 2
a1364 2
		exit(x);	/* give us status on one connection */
	exit(0);		/* otherwise, we're just done */
d1367 2
a1368 3
/* helpme :
   the obvious */
helpme()
d1370 22
a1391 23
	o_verbose = 1;
	holler("[v1.10]\n\
connect to somewhere:	nc [-options] hostname port[s] [ports] ... \n\
listen for inbound:	nc -l -p port [-options] [hostname] [port]\n\
options:");
/* sigh, this necessarily gets messy.  And the trailing \ characters may be
   interpreted oddly by some compilers, generating or not generating extra
   newlines as they bloody please.  u-fix... */
#ifdef GAPING_SECURITY_HOLE	/* needs to be separate holler() */
	holler("\
	-e prog			program to exec after connect [dangerous!!]");
#endif
	holler("\
	-g gateway		source-routing hop point[s], up to 8\n\
	-G num			source-routing pointer: 4, 8, 12, ...\n\
	-h			this cruft\n\
	-i secs			delay interval for lines sent, ports scanned\n\
	-l			listen mode, for inbound connects\n\
	-n			numeric-only IP addresses, no DNS\n\
	-o file			hex dump of traffic\n\
	-p port			local port number\n\
	-r			randomize local and remote ports\n\
	-s addr			local source address");
d1393 1
a1393 2
	holler("\
	-t			answer TELNET negotiation");
d1395 6
a1400 6
	holler("\
	-u			UDP mode\n\
	-v			verbose [use twice to be more verbose]\n\
	-w secs			timeout for connects and final net reads\n\
	-z			zero-I/O mode [used for scanning]");
	bail("port numbers can be individual or ranges: lo-hi [inclusive]");
@


1.9
log
@If the timeout is not set, don't send a zeroed timeout to select.
This solves the problem with nc hogging all cpu.
@
text
@d1341 1
a1341 1
		insaved = read(0, cp, BIGSIZ);	/* we're gonna fake fgets()
d1343 1
@


1.8
log
@do not assume h_errs[] is clean, use %s
@
text
@d1128 2
d1136 6
a1141 2
		memcpy(&timer2, &timer1, sizeof(struct timeval));
		rr = select(getdtablesize(), &fds2, 0, 0, &timer2);
@


1.7
log
@massive indent pass
@
text
@d157 1
a157 1
				fprintf(stderr, h_errs[h_errno]);
@


1.6
log
@first cut at indent.. more to come
@
text
@d2 25
a26 25

   A damn useful little "backend" utility begun 950915 or thereabouts,
   as *Hobbit*'s first real stab at some sockets programming.  Something that
   should have and indeed may have existed ten years ago, but never became a
   standard Unix utility.  IMHO, "nc" could take its place right next to cat,
   cp, rm, mv, dd, ls, and all those other cryptic and Unix-like things.

   Read the README for the whole story, doc, applications, etc.

   Layout:
	conditional includes:
	includes:
	handy defines:
	globals:
	malloced globals:
	cmd-flag globals:
	support routines:
	readwrite select loop:
	main:

  bluesky:
	parse ranges of IP address as well as ports, perhaps
	RAW mode!
	backend progs to grab a pty and look like a real telnetd?!
	backend progs to do various encryption modes??!?!
a34 1
#define HAVE_HELP		/* undefine if you dont want the help text */
d36 15
a50 1
#ifdef HAVE_STDLIB_H
a51 7
#else
#include <malloc.h>
#endif
#ifdef HAVE_SELECT_H		/* random SV variants need this */
#include <sys/select.h>
#endif
#ifdef HAVE_UNISTD_H
a52 8
#endif

/* have to do this *before* including types.h. xxx: Linux still has it wrong */
#ifdef FD_SETSIZE		/* should be in types.h, butcha never know. */
#undef FD_SETSIZE		/* if we ever need more than 16 active */
#endif				/* fd's, something is horribly wrong! */
#define FD_SETSIZE 16		/* <-- this'll give us a long anyways, wtf */
#include <sys/types.h>		/* *now* do it.  Sigh, this is broken */
a61 20
/* includes: */
#include <sys/time.h>		/* timeval, time_t */
#include <setjmp.h>		/* jmp_buf et al */
#include <sys/socket.h>		/* basics, SO_ and AF_ defs, sockaddr, ... */
#include <netinet/in.h>		/* sockaddr_in, htons, in_addr */
#include <netinet/in_systm.h>	/* misc crud that netinet/ip.h references */
#include <netinet/ip.h>		/* IPOPT_LSRR, header stuff */
#include <netdb.h>		/* hostent, gethostby*, getservby* */
#include <arpa/inet.h>		/* inet_ntoa */
#include <stdio.h>
#include <string.h>		/* strcpy, strchr, yadda yadda */
#include <errno.h>
#include <signal.h>
#include <fcntl.h>		/* O_WRONLY et al */

/* handy stuff: */
#define SA struct sockaddr	/* socket overgeneralization braindeath */
#define SAI struct sockaddr_in	/* ... whoever came up with this model */
#define IA struct in_addr	/* ... should be taken out and shot, */
 /* ... not that TLI is any better.  sigh.. */
a62 1
#define USHORT unsigned short	/* use these for options an' stuff */
d65 1
a65 5
#ifndef INADDR_NONE
#define INADDR_NONE 0xffffffff
#endif

struct host_poop {
a70 1
#define HINF struct host_poop
d72 1
a72 1
struct port_poop {
d75 1
a75 1
	USHORT  num;		/* real host-order number */
a76 1
#define PINF struct port_poop
d83 1
a83 4
static char unknown[] = "(UNKNOWN)";
static char p_tcp[] = "tcp";	/* for getservby* */
static char p_udp[] = "udp";
#ifdef HAVE_BIND
d93 1
a93 3
#else
int     h_errno;		/* just so we *do* have it available */
#endif				/* HAVE_BIND */
d96 1
a96 1
USHORT  Single = 1;		/* zero if scanning */
d104 4
a107 5
struct timeval *timer1 = NULL;
struct timeval *timer2 = NULL;
SAI    *lclend = NULL;		/* sockaddr_in structs */
SAI    *remend = NULL;
HINF  **gates = NULL;		/* LSRR hop hostpoop */
d111 2
a112 3
fd_set *ding1;			/* for select loop */
fd_set *ding2;
PINF   *portpoop = NULL;	/* for getportpoop / getservby* */
d116 1
a116 1
USHORT  o_alla = 0;
d118 6
a123 6
USHORT  o_listen = 0;
USHORT  o_nflag = 0;
USHORT  o_wfile = 0;
USHORT  o_random = 0;
USHORT  o_udpmode = 0;
USHORT  o_verbose = 0;
d125 1
a125 1
USHORT  o_zero = 0;
d168 1
a168 1
}				/* holler */
a179 1
	sleep(1);
d181 1
a181 1
}				/* bail */
d221 1
a221 17
}				/* arm */

/* Hmalloc :
   malloc up what I want, rounded up to *4, and pre-zeroed.  Either succeeds
   or bails out on its own, so that callers don't have to worry about it. */
char   *
Hmalloc(size)
	unsigned int size;
{
	unsigned int s = (size + 4) & 0xfffffffc;	/* 4GB?! */
	char   *p = malloc(s);
	if (p != NULL)
		memset(p, 0, s);
	else
		bail("Hmalloc %d failed", s);
	return (p);
}				/* Hmalloc */
d250 1
a250 1
}				/* findline */
d253 1
a253 1
   cross-check the host_poop we have so far against new gethostby*() info,
d259 1
a259 1
	HINF   *poop;
d270 1
a270 1
}				/* comparehosts */
d273 1
a273 1
   resolve a host 8 ways from sunday; return a new host_poop struct with its
d277 1
a277 1
HINF   *
d280 1
a280 1
	USHORT  numeric;
d284 1
a284 1
	register HINF *poop = NULL;
d309 1
a309 1
		poop = (HINF *) Hmalloc(sizeof(HINF));
d312 2
a313 3
	strlcpy(poop->name, unknown, sizeof(poop->name));	/* preload it */
	if (inet_aton(name, &iaddr) == 0) {	/* here's the great split:
						 * names... */
d321 1
a321 2
		strncpy(poop->name, hostent->h_name, MAXHOSTNAMELEN - 1);
		poop->name[MAXHOSTNAMELEN - 1] = '\0';
d323 5
a327 5
			memcpy(&poop->iaddrs[x], hostent->h_addr_list[x], sizeof(IA));
			strncpy(poop->addrs[x], inet_ntoa(poop->iaddrs[x]),
			    sizeof(poop->addrs[0]) - 1);
			poop->addrs[x][sizeof(poop->addrs[0]) - 1] = '\0';
		}		/* for x -> addrs, part A */
d334 1
a334 1
			    sizeof(IA), AF_INET);
d343 2
a344 3
		memcpy(poop->iaddrs, &iaddr, sizeof(IA));
		strncpy(poop->addrs[0], inet_ntoa(iaddr), sizeof(poop->addrs) - 1);
		poop->addrs[0][sizeof(poop->addrs) - 1] = '\0';
d349 1
a349 1
		hostent = gethostbyaddr((char *) &iaddr, sizeof(IA), AF_INET);
d354 1
a354 2
			strncpy(poop->name, hostent->h_name, MAXHOSTNAMELEN - 1);
			poop->name[MAXHOSTNAMELEN - 1] = '\0';
d364 1
a364 1
/* whatever-all went down previously, we should now have a host_poop struct
d368 1
a368 1
}				/* gethostpoop */
d372 1
a372 1
   in global port_poop, but return the actual port *number*.  Pass ONE of:
d377 1
a377 1
USHORT 
d385 1
a385 1
	char   *whichp = p_tcp;
d387 1
a387 1
		whichp = p_udp;
d405 3
a407 3
			strncpy(portpoop->name, servent->s_name, sizeof(portpoop->name) - 1);
			portpoop->name[sizeof(portpoop->name) - 1] = '\0';
		}		/* if servent */
d426 2
a427 2
			strncpy(portpoop->name, servent->s_name, sizeof(portpoop->name) - 1);
			portpoop->name[sizeof(portpoop->name) - 1] = '\0';
d450 1
a450 1
	portpoop->num = (x & 0xffff);	/* ushort, remember... */
d452 1
a452 1
}				/* getportpoop */
d460 2
a461 2
   returns a USHORT random port, or 0 if all the t-b-t ones are used up. */
USHORT 
d493 1
a493 1
}				/* nextport */
d501 2
a502 2
	USHORT  lo;
	USHORT  hi;
d504 1
a504 1
	USHORT  x;
d515 2
a516 1
}				/* loadports */
d543 1
a543 1
}				/* doexec */
d555 4
a558 4
	IA     *rad;
	USHORT  rp;
	IA     *lad;
	USHORT  lp;
d602 1
a602 1
		memcpy(&lclend->sin_addr.s_addr, lad, sizeof(IA));
d610 2
a611 1
			rr = bind(nnetfd, (SA *) lclend, sizeof(SA));
d630 1
a630 1
	memcpy(&remend->sin_addr.s_addr, rad, sizeof(IA));
d675 1
a675 1
			optbuf = Hmalloc(48);
d679 1
a679 1
			    (((gatesidx + 1) * sizeof(IA)) + 3) & 0xff;	/* length */
d683 2
a684 2
				memcpy(opp, gates[x]->iaddrs, sizeof(IA));
				opp += sizeof(IA);
d687 2
a688 2
			memcpy(opp, rad, sizeof(IA));
			opp += sizeof(IA);
d694 1
a694 1
		x = ((gatesidx + 1) * sizeof(IA)) + 4;
d705 1
a705 1
		rr = connect(nnetfd, (SA *) remend, sizeof(SA));
d715 1
a715 1
}				/* doconnect */
d724 4
a727 4
	IA     *rad;
	USHORT  rp;
	IA     *lad;
	USHORT  lp;
d731 1
a731 1
	HINF   *whozis = NULL;
d734 1
a734 1
	USHORT  z;
d756 1
a756 1
   said -p we *know* what port we're listening on.  At any rate we won't bother
d760 2
a761 2
		x = sizeof(SA);	/* how 'bout getsockNUM instead, pinheads?! */
		rr = getsockname(nnetfd, (SA *) lclend, &x);
d780 1
a780 1
		x = sizeof(SA);	/* retval for recvfrom */
d785 1
a785 1
			    (nnetfd, bigbuf_net, BIGSIZ, MSG_PEEK, (SA *) remend, &x);
d801 1
a801 1
		rr = connect(nnetfd, (SA *) remend, sizeof(SA));
d805 1
a805 1
	x = sizeof(SA);		/* retval for accept */
d808 1
a808 1
		rr = accept(nnetfd, (SA *) remend, &x);
d827 1
a827 1
	optbuf = Hmalloc(40);
d858 2
a859 2
	x = sizeof(SA);
	rr = getsockname(nnetfd, (SA *) lclend, &x);
d880 1
a880 1
		if (memcmp(rad, whozis->iaddrs, sizeof(SA)))
d897 1
a897 1
}				/* dolisten */
d911 1
a911 1
	IA     *where;
d940 2
a941 1
}				/* udptest */
d1033 2
a1034 1
}				/* oprint */
d1036 1
a1036 1
USHORT  o_tn = 0;		/* global -t option */
d1079 2
a1080 1
}				/* atelnet */
d1095 3
a1097 3
	USHORT  netretry;	/* net-read retry counter */
	USHORT  wretry;		/* net-write sanity counter */
	USHORT  wfirst;		/* one-shot flag to skip first net read */
d1100 1
a1100 1
   either find it or do your own bit-bashing: *ding1 |= (1 << fd), etc... */
d1105 1
a1105 1
	FD_SET(fd, ding1);	/* global: the net is open */
d1117 1
a1117 1
			FD_CLR(0, ding1);	/* OR we've already got our
d1127 1
a1127 1
	while (FD_ISSET(fd, ding1)) {	/* i.e. till the *net* closes! */
d1133 3
a1135 6
		*ding2 = *ding1;/* FD_COPY ain't portable... */
/* some systems, notably linux, crap into their select timers on return, so
   we create a expendable copy and give *that* to select.  *Fuck* me ... */
		if (timer1)
			memcpy(timer2, timer1, sizeof(struct timeval));
		rr = select(16, ding2, 0, 0, timer2);	/* here it is, kiddies */
d1148 1
a1148 1
			if (!FD_ISSET(0, ding1))
d1164 1
a1164 1
		if (FD_ISSET(fd, ding2)) {	/* net: ding! */
d1167 1
a1167 1
				FD_CLR(fd, ding1);	/* net closed, we'll
d1188 1
a1188 1
		if (FD_ISSET(0, ding2)) {	/* stdin: ding! */
d1193 1
a1193 1
				FD_CLR(0, ding1);	/* disable and close
d1203 1
a1203 1
					FD_CLR(0, ding1);	/* disable further junk
d1262 1
a1262 1
	}			/* while ding1:netfd is open */
d1271 1
a1271 1
}				/* readwrite */
d1285 10
a1294 10
	HINF   *gp;
	HINF   *whereto = NULL;
	HINF   *wherefrom = NULL;
	IA     *ouraddr = NULL;
	IA     *themaddr = NULL;
	USHORT  o_lport = 0;
	USHORT  ourport = 0;
	USHORT  loport = 0;	/* for scanning stuff */
	USHORT  hiport = 0;
	USHORT  curport = 0;
d1303 5
a1307 7
	lclend = (SAI *) Hmalloc(sizeof(SA));
	remend = (SAI *) Hmalloc(sizeof(SA));
	bigbuf_in = Hmalloc(BIGSIZ);
	bigbuf_net = Hmalloc(BIGSIZ);
	ding1 = (fd_set *) Hmalloc(sizeof(fd_set));
	ding2 = (fd_set *) Hmalloc(sizeof(fd_set));
	portpoop = (PINF *) Hmalloc(sizeof(PINF));
d1329 1
a1329 1
		argv = (char **) Hmalloc(128 * sizeof(char *));	/* XXX: 128? */
d1331 1
a1331 1
		cp = Hmalloc(BIGSIZ);
d1396 1
a1396 1
				gates = (HINF **) Hmalloc(sizeof(HINF *) * 10);
a1403 1
#ifdef HAVE_HELP
a1404 3
#else
			bail("no help available, dork -- RTFS");
#endif
d1450 2
a1451 4
			timer1 = (struct timeval *) Hmalloc(sizeof(struct timeval));
			timer2 = (struct timeval *) Hmalloc(sizeof(struct timeval));
			timer1->tv_sec = o_wait;	/* we need two.  see
							 * readwrite()... */
d1463 2
a1464 2
	Debug(("fd_set size %d", sizeof(*ding1)))	/* how big *is* it? */
	    FD_SET(0, ding1);	/* stdin *is* initially open */
d1467 1
a1467 1
		randports = Hmalloc(65536);	/* big flag array for ports */
d1480 1
a1480 1
		stage = (unsigned char *) Hmalloc(100);
d1614 1
a1614 1
}				/* main */
a1615 1
#ifdef HAVE_HELP		/* unless we wanna be *really* cryptic */
d1653 1
a1653 4
}				/* helpme */
#endif				/* HAVE_HELP */

/* None genuine without this seal!  _H*/
@


1.5
log
@include unistd.h
@
text
@a35 1
/* #define ANAL			/* if you want case-sensitive DNS matching */
d62 1
a62 1
#endif /* HAVE_RANDOM */
d83 1
a83 1
				/* ... not that TLI is any better.  sigh.. */
d93 4
a96 3
  char name[MAXHOSTNAMELEN];	/* dns name */
  char addrs[8][24];		/* ascii-format IP addresses */
  struct in_addr iaddrs[8];	/* real addresses: in_addr.s_addr: ulong */
d101 3
a103 3
  char name [64];		/* name in /etc/services */
  char anum [8];		/* ascii-format number */
  USHORT num;			/* real host-order number */
d109 3
a111 3
int jval = 0;			/* timer crud */
int netfd = -1;
int ofd = 0;			/* hexdump output fd */
d118 6
a123 6
static char * h_errs[] = {
  "Error 0",				/* but we *don't* use this */
  "Unknown host",			/* 1 HOST_NOT_FOUND */
  "Host name lookup failure",		/* 2 TRY_AGAIN */
  "Unknown server error",		/* 3 NO_RECOVERY */
  "No address associated with name",	/* 4 NO_ADDRESS */
d126 5
a130 5
int h_errno;			/* just so we *do* have it available */
#endif /* HAVE_BIND */
int gatesidx = 0;		/* LSRR hop count */
int gatesptr = 4;		/* initial LSRR pointer, settable */
USHORT Single = 1;		/* zero if scanning */
d138 12
a149 12
struct timeval * timer1 = NULL;
struct timeval * timer2 = NULL;
SAI * lclend = NULL;		/* sockaddr_in structs */
SAI * remend = NULL;
HINF ** gates = NULL;		/* LSRR hop hostpoop */
char * optbuf = NULL;		/* LSRR or sockopts */
char * bigbuf_in;		/* data buffers */
char * bigbuf_net;
fd_set * ding1;			/* for select loop */
fd_set * ding2;
PINF * portpoop = NULL;		/* for getportpoop / getservby* */
unsigned char * stage = NULL;	/* hexdump line buffer */
d152 1
a152 1
USHORT o_alla = 0;
d154 6
a159 6
USHORT o_listen = 0;
USHORT o_nflag = 0;
USHORT o_wfile = 0;
USHORT o_random = 0;
USHORT o_udpmode = 0;
USHORT o_verbose = 0;
d161 1
a161 1
USHORT o_zero = 0;
d170 1
a170 1
#define Debug(x)	/* nil... */
d181 4
a184 3
void holler (str, p1, p2, p3, p4, p5, p6)
  char * str;
  char * p1, * p2, * p3, * p4, * p5, * p6;
d186 2
a187 2
  if (o_verbose) {
    fprintf (stderr, str, p1, p2, p3, p4, p5, p6);
d189 7
a195 7
    if (h_errno) {		/* if host-lookup variety of error ... */
      if (h_errno > 4)		/* oh no you don't, either */
	fprintf (stderr, "preposterous h_errno: %d", h_errno);
      else
	fprintf (stderr, h_errs[h_errno]);	/* handle it here */
      h_errno = 0;				/* and reset for next call */
    }
d197 8
a204 7
    if (errno) {		/* this gives funny-looking messages, but */
      perror (" ");		/* it's more portable than sys_errlist[]... */
    } else			/* xxx: do something better?  */
      fprintf (stderr, "\n");
    fflush (stderr);
  }
} /* holler */
d208 11
a218 10
void bail (str, p1, p2, p3, p4, p5, p6)
  char * str;
  char * p1, * p2, * p3, * p4, * p5, * p6;
{
  o_verbose = 1;
  holler (str, p1, p2, p3, p4, p5, p6);
  close (netfd);
  sleep (1);
  exit (1);
} /* bail */
d222 2
a223 1
void catch ()
d225 4
a228 4
  errno = 0;
  if (o_verbose > 1)		/* normally we don't care */
    bail (wrote_txt, wrote_net, wrote_out);
  bail (" punt!");
d232 2
a233 1
void tmtravel ()
d235 5
a239 5
  signal (SIGALRM, SIG_IGN);
  alarm (0);
  if (jval == 0)
    bail ("spurious timer interrupt!");
  longjmp (jbuf, jval);
d244 15
a258 14
void arm (num, secs)
  unsigned int num;
  unsigned int secs;
{
  if (secs == 0) {			/* reset */
    signal (SIGALRM, SIG_IGN);
    alarm (0);
    jval = 0;
  } else {				/* set */
    signal (SIGALRM, tmtravel);
    alarm (secs);
    jval = num;
  } /* if secs */
} /* arm */
d263 12
a274 11
char * Hmalloc (size)
  unsigned int size;
{
  unsigned int s = (size + 4) & 0xfffffffc;	/* 4GB?! */
  char * p = malloc (s);
  if (p != NULL)
    memset (p, 0, s);
  else
    bail ("Hmalloc %d failed", s);
  return (p);
} /* Hmalloc */
d280 24
a303 23
unsigned int findline (buf, siz)
  char * buf;
  unsigned int siz;
{
  register char * p;
  register int x;
  if (! buf)			/* various sanity checks... */
    return (0);
  if (siz > BIGSIZ)
    return (0);
  x = siz;
  for (p = buf; x > 0; x--) {
    if (*p == '\n') {
      x = (int) (p - buf);
      x++;			/* 'sokay if it points just past the end! */
Debug (("findline returning %d", x))
      return (x);
    }
    p++;
  } /* for */
Debug (("findline returning whole thing: %d", siz))
  return (siz);
} /* findline */
d310 12
a321 17
int comparehosts (poop, hp)
  HINF * poop;
  struct hostent * hp;
{
  errno = 0;
  h_errno = 0;
/* The DNS spec is officially case-insensitive, but for those times when you
   *really* wanna see any and all discrepancies, by all means define this. */
#ifdef ANAL			
  if (strcmp (poop->name, hp->h_name) != 0) {		/* case-sensitive */
#else
  if (strcasecmp (poop->name, hp->h_name) != 0) {	/* normal */
#endif
    holler ("DNS fwd/rev mismatch: %s != %s", poop->name, hp->h_name);
    return (1);
  }
  return (0);
d323 1
a323 1
} /* comparehosts */
d330 9
a338 8
HINF * gethostpoop (name, numeric)
  char * name;
  USHORT numeric;
{
  struct hostent * hostent;
  struct in_addr iaddr;
  register HINF * poop = NULL;
  register int x;
d359 14
a372 13
  errno = 0;
  h_errno = 0;
  if (name)
    poop = (HINF *) Hmalloc (sizeof (HINF));
  if (! poop)
    bail ("gethostpoop fuxored");
  strlcpy (poop->name, unknown, sizeof(poop->name));	/* preload it */
  if (inet_aton (name, &iaddr) == 0) { /* here's the great split: names... */

    if (numeric)
      bail ("Can't parse %s as an IP address", name);
    hostent = gethostbyname (name);
    if (! hostent)
d374 11
a384 11
      bail ("%s: forward host lookup failed: ", name);
    strncpy (poop->name, hostent->h_name, MAXHOSTNAMELEN - 1);
    poop->name[MAXHOSTNAMELEN - 1] = '\0';
    for (x = 0; hostent->h_addr_list[x] && (x < 8); x++) {
      memcpy (&poop->iaddrs[x], hostent->h_addr_list[x], sizeof (IA));
      strncpy (poop->addrs[x], inet_ntoa (poop->iaddrs[x]),
	sizeof (poop->addrs[0])-1);
      poop->addrs[x][sizeof (poop->addrs[0]) - 1] = '\0';
    } /* for x -> addrs, part A */
    if (! o_verbose)			/* if we didn't want to see the */
      return (poop);			/* inverse stuff, we're done. */
d387 19
a405 19
    for (x = 0; poop->iaddrs[x].s_addr && (x < 8); x++) {
      hostent = gethostbyaddr ((char *)&poop->iaddrs[x],
				sizeof (IA), AF_INET);
      if ((! hostent) || (! hostent-> h_name))
	holler ("Warning: inverse host lookup failed for %s: ",
	  poop->addrs[x]);
      else
	(void) comparehosts (poop, hostent);
    } /* for x -> addrs, part B */

  } else {  /* not INADDR_NONE: numeric addresses... */
    memcpy (poop->iaddrs, &iaddr, sizeof (IA));
    strncpy (poop->addrs[0], inet_ntoa (iaddr), sizeof (poop->addrs)-1);
    poop->addrs[0][sizeof (poop->addrs)-1] = '\0';
    if (numeric)			/* if numeric-only, we're done */
      return (poop);
    if (! o_verbose)			/* likewise if we don't want */
      return (poop);			/* the full DNS hair */
    hostent = gethostbyaddr ((char *) &iaddr, sizeof (IA), AF_INET);
d407 13
a419 13
    if (! hostent)
	holler ("%s: inverse host lookup failed: ", name);
    else {
	strncpy (poop->name, hostent->h_name, MAXHOSTNAMELEN - 1);
	poop->name[MAXHOSTNAMELEN-1] = '\0';
	hostent = gethostbyname (poop->name);
	if ((! hostent) || (! hostent->h_addr_list[0]))
	  holler ("Warning: forward host lookup failed for %s: ",
		poop->name);
	else
	  (void) comparehosts (poop, hostent);
    } /* if hostent */
  } /* INADDR_NONE Great Split */
d423 3
a425 3
  h_errno = 0;
  return (poop);
} /* gethostpoop */
d434 13
a446 12
USHORT getportpoop (pstring, pnum)
  char * pstring;
  unsigned int pnum;
{
  struct servent * servent;
  register int x;
  register int y;
  char * whichp = p_tcp;
  if (o_udpmode)
    whichp = p_udp;
  portpoop->name[0] = '?';		/* fast preload */
  portpoop->name[1] = '\0';
d450 40
a489 40
  if (pnum) {
    if (pstring)			/* one or the other, pleeze */
      return (0);
    x = pnum;
    if (o_nflag)			/* go faster, skip getservbyblah */
      goto gp_finish;
    y = htons (x);			/* gotta do this -- see Fig.1 below */
    servent = getservbyport (y, whichp);
    if (servent) {
      y = ntohs (servent->s_port);
      if (x != y)			/* "never happen" */
	holler ("Warning: port-bynum mismatch, %d != %d", x, y);
      strncpy (portpoop->name, servent->s_name, sizeof (portpoop->name)-1);
      portpoop->name[sizeof (portpoop->name)-1] = '\0';
    } /* if servent */
    goto gp_finish;
  } /* if pnum */

/* case 2: resolve a string, but we still give preference to numbers instead
   of trying to resolve conflicts.  None of the entries in *my* extensive
   /etc/services begins with a digit, so this should "always work" unless
   you're at 3com and have some company-internal services defined... */
  if (pstring) {
    if (pnum)				/* one or the other, pleeze */
      return (0);
    x = atoi (pstring);
    if (x)
      return (getportpoop (NULL, x));	/* recurse for numeric-string-arg */
    if (o_nflag)			/* can't use names! */
      return (0);
    servent = getservbyname (pstring, whichp);
    if (servent) {
      strncpy (portpoop->name, servent->s_name, sizeof (portpoop->name)-1);
      portpoop->name[sizeof (portpoop->name)-1] = '\0';
      x = ntohs (servent->s_port);
      goto gp_finish;
    } /* if servent */
  } /* if pstring */

  return (0);				/* catches any problems so far */
d505 5
a509 4
  sprintf (portpoop->anum, "%d", x);	/* always load any numeric specs! */
  portpoop->num = (x & 0xffff);		/* ushort, remember... */
  return (portpoop->num);
} /* getportpoop */
d518 30
a547 29
USHORT nextport (block)
  char * block;
{
  register unsigned int x;
  register unsigned int y;

  y = 70000;			/* high safety count for rnd-tries */
  while (y > 0) {
    x = (RAND() & 0xffff);
    if (block[x] == 1) {	/* try to find a not-done one... */
      block[x] = 2;
      break;
    }
    x = 0;			/* bummer. */
    y--;
  } /* while y */
  if (x)
    return (x);

  y = 65535;			/* no random one, try linear downsearch */
  while (y > 0) {		/* if they're all used, we *must* be sure! */
    if (block[y] == 1) {
      block[y] = 2;
      break;
    }
    y--;
  } /* while y */
  if (y)
    return (y);			/* at least one left */
d549 2
a550 2
  return (0);			/* no more left! */
} /* nextport */
d555 18
a572 18
void loadports (block, lo, hi)
  char * block;
  USHORT lo;
  USHORT hi;
{
  USHORT x;

  if (! block)
    bail ("loadports: no block?!");
  if ((! lo) || (! hi))
    bail ("loadports: bogus values %d, %d", lo, hi);
  x = hi;
  while (lo <= x) {
    block[x] = 1;
    x--;
  }
} /* loadports */

d574 1
a574 1
char * pr00gie = NULL;			/* global ptr to -e arg */
d582 2
a583 2
doexec (fd)
  int fd;
d585 1
a585 1
  register char * p;
d587 14
a600 14
  dup2 (fd, 0);				/* the precise order of fiddlage */
  close (fd);				/* is apparently crucial; this is */
  dup2 (0, 1);				/* swiped directly out of "inetd". */
  dup2 (0, 2);
  p = strrchr (pr00gie, '/');		/* shorter argv[0] */
  if (p)
    p++;
  else
    p = pr00gie;
Debug (("gonna exec %s as %s...", pr00gie, p))
  execl (pr00gie, p, NULL);
  bail ("exec %s failed", pr00gie);	/* this gets sent out.  Hmm... */
} /* doexec */
#endif /* GAPING_SECURITY_HOLE */
d609 11
a619 10
int doconnect (rad, rp, lad, lp)
  IA * rad;
  USHORT rp;
  IA * lad;
  USHORT lp;
{
  register int nnetfd;
  register int rr;
  int x, y;
  errno = 0;
d623 16
a638 16
  if (o_udpmode)
    nnetfd = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP);
  else
    nnetfd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (nnetfd < 0)
    bail ("Can't get socket");
  if (nnetfd == 0)		/* if stdin was closed this might *be* 0, */
    goto newskt;		/* so grab another.  See text for why... */
  x = 1;
  rr = setsockopt (nnetfd, SOL_SOCKET, SO_REUSEADDR, &x, sizeof (x));
  if (rr == -1)
    holler ("nnetfd reuseaddr failed");		/* ??? */
#ifdef SO_REUSEPORT	/* doesnt exist everywhere... */
  rr = setsockopt (nnetfd, SOL_SOCKET, SO_REUSEPORT, &x, sizeof (x));
  if (rr == -1)
    holler ("nnetfd reuseport failed");		/* ??? */
d645 2
a646 2
  rr = setsockopt(nnetfd, SOL_SOCKET, SO_RCVBUF, &o_rcvbuf, sizeof o_rcvbuf);
  rr = setsockopt(nnetfd, SOL_SOCKET, SO_SNDBUF, &o_sndbuf, sizeof o_sndbuf);
d648 3
a650 3
  
  /* fill in all the right sockaddr crud */
    lclend->sin_family = AF_INET;
d653 2
a654 2
  lclend->sin_family = AF_INET;
  remend->sin_family = AF_INET;
d657 7
a663 7
  if (lad)
    memcpy (&lclend->sin_addr.s_addr, lad, sizeof (IA));
  if (lp)
    lclend->sin_port = htons (lp);
  rr = 0;
  if (lad || lp) {
    x = (int) lp;
d665 16
a680 16
    for (y = 4; y > 0; y--) {
      rr = bind (nnetfd, (SA *)lclend, sizeof (SA));
      if (rr == 0)
	break;
      if (errno != EADDRINUSE)
	break;
      else {
	holler ("retrying local %s:%d", inet_ntoa (lclend->sin_addr), lp);
	sleep (2);
	errno = 0;			/* clear from sleep */
      } /* if EADDRINUSE */
    } /* for y counter */
  } /* if lad or lp */
  if (rr)
    bail ("Can't grab %s:%d with bind",
	inet_ntoa(lclend->sin_addr), lp);
d682 2
a683 2
  if (o_listen)
    return (nnetfd);			/* thanks, that's all for today */
d685 2
a686 2
  memcpy (&remend->sin_addr.s_addr, rad, sizeof (IA));
  remend->sin_port = htons (rp);
d725 1
a725 1
  if (gatesidx) {		/* if we wanted any srcrt hops ... */
d728 8
a735 8
    if (! optbuf) {		/* and don't already *have* a srcrt set */
      char * opp;		/* then do all this setup hair */
      optbuf = Hmalloc (48);
      opp = optbuf;
      *opp++ = IPOPT_LSRR;					/* option */
      *opp++ = (char)
	(((gatesidx + 1) * sizeof (IA)) + 3) & 0xff;		/* length */
      *opp++ = gatesptr;					/* pointer */
d737 4
a740 4
      for ( x = 0; x < gatesidx; x++) {
	memcpy (opp, gates[x]->iaddrs, sizeof (IA));
	opp += sizeof (IA);
      }
d742 29
a770 29
      memcpy (opp, rad, sizeof (IA));
      opp += sizeof (IA);
      *opp = IPOPT_NOP;			/* alignment filler */
    } /* if empty optbuf */
/* calculate length of whole option mess, which is (3 + [hops] + [final] + 1),
   and apply it [have to do this every time through, of course] */
    x = ((gatesidx + 1) * sizeof (IA)) + 4;
    rr = setsockopt (nnetfd, IPPROTO_IP, IP_OPTIONS, optbuf, x);
    if (rr == -1)
      bail ("srcrt setsockopt fuxored");
#else /* IP_OPTIONS */
    holler ("Warning: source routing unavailable on this machine, ignoring");
#endif /* IP_OPTIONS*/
  } /* if gatesidx */

/* wrap connect inside a timer, and hit it */
  arm (1, o_wait);
  if (setjmp (jbuf) == 0) {
    rr = connect (nnetfd, (SA *)remend, sizeof (SA));
  } else {				/* setjmp: connect failed... */
    rr = -1;
    errno = ETIMEDOUT;			/* fake it */
  }
  arm (0, 0);
  if (rr == 0)
    return (nnetfd);
  close (nnetfd);			/* clean up junked socket FD!! */
  return (-1);
} /* doconnect */
d777 14
a790 13
int dolisten (rad, rp, lad, lp)
  IA * rad;
  USHORT rp;
  IA * lad;
  USHORT lp;
{
  register int nnetfd;
  register int rr;
  HINF * whozis = NULL;
  int x;
  char * cp;
  USHORT z;
  errno = 0;
d793 11
a803 11
  nnetfd = doconnect (rad, rp, lad, lp);
  if (nnetfd <= 0)
    return (-1);
  if (o_udpmode) {			/* apparently UDP can listen ON */
    if (! lp)				/* "port 0",  but that's not useful */
      bail ("UDP listen needs -p arg");
  } else {
    rr = listen (nnetfd, 1);		/* gotta listen() before we can get */
    if (rr < 0)				/* our local random port.  sheesh. */
      bail ("local listen fuxored");
  }
d814 31
a844 30
  if (o_verbose) {
    x = sizeof (SA);		/* how 'bout getsockNUM instead, pinheads?! */
    rr = getsockname (nnetfd, (SA *) lclend, &x);
    if (rr < 0)
      holler ("local getsockname failed");
    strcpy (bigbuf_net, "listening on [");	/* buffer reuse... */
    if (lclend->sin_addr.s_addr)
      strcat (bigbuf_net, inet_ntoa (lclend->sin_addr));
    else
      strcat (bigbuf_net, "any");
    strcat (bigbuf_net, "] %d ...");
    z = ntohs (lclend->sin_port);
    holler (bigbuf_net, z);
  } /* verbose -- whew!! */

/* UDP is a speeeeecial case -- we have to do I/O *and* get the calling
   party's particulars all at once, listen() and accept() don't apply.
   At least in the BSD universe, however, recvfrom/PEEK is enough to tell
   us something came in, and we can set things up so straight read/write
   actually does work after all.  Yow.  YMMV on strange platforms!  */
  if (o_udpmode) {
    x = sizeof (SA);		/* retval for recvfrom */
    arm (2, o_wait);		/* might as well timeout this, too */
    if (setjmp (jbuf) == 0) {	/* do timeout for initial connect */
      rr = recvfrom		/* and here we block... */
	(nnetfd, bigbuf_net, BIGSIZ, MSG_PEEK, (SA *) remend, &x);
Debug (("dolisten/recvfrom ding, rr = %d, netbuf %s ", rr, bigbuf_net))
    } else
      goto dol_tmo;		/* timeout */
    arm (0, 0);
d856 13
a868 14
    rr = connect (nnetfd, (SA *)remend, sizeof (SA));
    goto whoisit;
  } /* o_udpmode */

/* fall here for TCP */
  x = sizeof (SA);		/* retval for accept */
  arm (2, o_wait);		/* wrap this in a timer, too; 0 = forever */
  if (setjmp (jbuf) == 0) {
    rr = accept (nnetfd, (SA *)remend, &x);
  } else
    goto dol_tmo;		/* timeout */
  arm (0, 0);
  close (nnetfd);		/* dump the old socket */
  nnetfd = rr;			/* here's our new one */
d871 2
a872 2
  if (rr < 0)
    goto dol_err;		/* bail out if any errors so far */
d880 24
a903 21
  if (! o_verbose)			/* if we wont see it, we dont care */
    goto dol_noop;
  optbuf = Hmalloc (40);
  x = 40;
  rr = getsockopt (nnetfd, IPPROTO_IP, IP_OPTIONS, optbuf, &x);
  if (rr < 0)
    holler ("getsockopt failed");
Debug (("ipoptions ret len %d", x))
  if (x) {				/* we've got options, lessee em... */
    unsigned char * q = (unsigned char *) optbuf;
    char * p = bigbuf_net;		/* local variables, yuk! */
    char * pp = &bigbuf_net[128];	/* get random space farther out... */
    memset (bigbuf_net, 0, 256);	/* clear it all first */
    while (x > 0) {
	sprintf (pp, "%2.2x ", *q);	/* clumsy, but works: turn into hex */
	strcat (p, pp);			/* and build the final string */
	q++; p++;
	x--;
    }
    holler ("IP options: %s", bigbuf_net);
  } /* if x, i.e. any options */
d905 1
a905 1
#endif /* IP_OPTIONS */
d911 7
a917 7
  memset (bigbuf_net, 0, 64);
  cp = &bigbuf_net[32];
  x = sizeof (SA);
  rr = getsockname (nnetfd, (SA *) lclend, &x);
  if (rr < 0)
    holler ("post-rcv getsockname failed");
  strcpy (cp, inet_ntoa (lclend->sin_addr));
d928 18
a945 17
  z = ntohs (remend->sin_port);
  strcpy (bigbuf_net, inet_ntoa (remend->sin_addr));
  whozis = gethostpoop (bigbuf_net, o_nflag);
  errno = 0;
  x = 0;				/* use as a flag... */
  if (rad)	/* xxx: fix to go down the *list* if we have one? */
    if (memcmp (rad, whozis->iaddrs, sizeof (SA)))
      x = 1;
  if (rp)
    if (z != rp)
      x = 1;
  if (x)					/* guilty! */
    bail ("invalid connection to [%s] from %s [%s] %d",
	cp, whozis->name, whozis->addrs[0], z);
  holler ("connect to [%s] from %s [%s] %d",		/* oh, you're okay.. */
	cp, whozis->name, whozis->addrs[0], z);
  return (nnetfd);				/* open! */
d948 1
a948 1
  errno = ETIMEDOUT;			/* fake it */
d950 3
a952 3
  close (nnetfd);
  return (-1);
} /* dolisten */
d964 12
a975 12
udptest (fd, where)
  int fd;
  IA * where;
{
  register int rr;

  rr = write (fd, bigbuf_in, 1);
  if (rr != 1)
    holler ("udptest first write failed?! errno %d", errno);
  if (o_wait)
    sleep (o_wait);
  else {
d979 1
a979 1
    o_udpmode = 0;			/* so doconnect does TCP this time */
d982 14
a995 15
    o_wait = 5;				/* enough that we'll notice?? */
    rr = doconnect (where, SLEAZE_PORT, 0, 0);
    if (rr > 0)
      close (rr);			/* in case it *did* open */
    o_wait = 0;				/* reset it */
    o_udpmode++;			/* we *are* still doing UDP, right? */
  } /* if o_wait */
  errno = 0;				/* clear from sleep */
  rr = write (fd, bigbuf_in, 1);
  if (rr == 1)				/* if write error, no UDP listener */
    return (fd);
  close (fd);				/* use it or lose it! */
  return (-1);
} /* udptest */

d1006 82
a1087 81
void oprint (which, buf, n)
  int which;
  char * buf;
  int n;
{
  int bc;			/* in buffer count */
  int obc;			/* current "global" offset */
  int soc;			/* stage write count */
  register unsigned char * p;	/* main buf ptr; m.b. unsigned here */
  register unsigned char * op;	/* out hexdump ptr */
  register unsigned char * a;	/* out asc-dump ptr */
  register int x;
  register unsigned int y;

  if (! ofd)
    bail ("oprint called with no open fd?!");
  if (n == 0)
    return;

  op = stage;
  if (which) {
    *op = '<';
    obc = wrote_out;		/* use the globals! */
  } else {
    *op = '>';
    obc = wrote_net;
  }
  op++;				/* preload "direction" */
  *op = ' ';
  p = (unsigned char *) buf;
  bc = n;
  stage[59] = '#';		/* preload separator */
  stage[60] = ' ';

  while (bc) {			/* for chunk-o-data ... */
    x = 16;
    soc = 78;			/* len of whole formatted line */
    if (bc < x) {
      soc = soc - 16 + bc;	/* fiddle for however much is left */
      x = (bc * 3) + 11;	/* 2 digits + space per, after D & offset */
      op = &stage[x];
      x = 16 - bc;
      while (x) {
	*op++ = ' ';		/* preload filler spaces */
	*op++ = ' ';
	*op++ = ' ';
	x--;
      }
      x = bc;			/* re-fix current linecount */
    } /* if bc < x */

    bc -= x;			/* fix wrt current line size */
    sprintf (&stage[2], "%8.8x ", obc);		/* xxx: still slow? */
    obc += x;			/* fix current offset */
    op = &stage[11];		/* where hex starts */
    a = &stage[61];		/* where ascii starts */

    while (x) {			/* for line of dump, however long ... */
      y = (int)(*p >> 4);	/* hi half */
      *op = hexnibs[y];
      op++;
      y = (int)(*p & 0x0f);	/* lo half */
      *op = hexnibs[y];
      op++;
      *op = ' ';
      op++;
      if ((*p > 31) && (*p < 127))
	*a = *p;		/* printing */
      else
	*a = '.';		/* nonprinting, loose def */
      a++;
      p++;
      x--;
    } /* while x */
    *a = '\n';			/* finish the line */
    x = write (ofd, stage, soc);
    if (x < 0)
      bail ("ofd write err");
  } /* while bc */
} /* oprint */

d1089 1
a1089 1
USHORT o_tn = 0;		/* global -t option */
d1096 29
a1124 26
void atelnet (buf, size)
  unsigned char * buf;		/* has to be unsigned here! */
  unsigned int size;
{
  static unsigned char obuf [4];  /* tiny thing to build responses into */
  register int x;
  register unsigned char y;
  register unsigned char * p;

  y = 0;
  p = buf;
  x = size;
  while (x > 0) {
    if (*p != 255)			/* IAC? */
      goto notiac;
    obuf[0] = 255;
    p++; x--;
    if ((*p == 251) || (*p == 252))	/* WILL or WONT */
      y = 254;				/* -> DONT */
    if ((*p == 253) || (*p == 254))	/* DO or DONT */
      y = 252;				/* -> WONT */
    if (y) {
      obuf[1] = y;
      p++; x--;
      obuf[2] = *p;			/* copy actual option byte */
      (void) write (netfd, obuf, 3);
d1126 2
a1127 2
      y = 0;
    } /* if y */
d1129 5
a1133 4
    p++; x--;
  } /* while x */
} /* atelnet */
#endif /* TELNET */
d1138 12
a1149 11
int readwrite (fd)
  int fd;
{
  register int rr;
  register char * zp;		/* stdin buf ptr */
  register char * np;		/* net-in buf ptr */
  unsigned int rzleft;
  unsigned int rnleft;
  USHORT netretry;		/* net-read retry counter */
  USHORT wretry;		/* net-write sanity counter */
  USHORT wfirst;		/* one-shot flag to skip first net read */
d1153 24
a1176 22
  if (fd > FD_SETSIZE) {
    holler ("Preposterous fd value %d", fd);
    return (1);
  }
  FD_SET (fd, ding1);		/* global: the net is open */
  netretry = 2;
  wfirst = 0;
  rzleft = rnleft = 0;
  if (insaved) {
    rzleft = insaved;		/* preload multi-mode fakeouts */
    zp = bigbuf_in;
    wfirst = 1;
    if (Single)			/* if not scanning, this is a one-off first */
      insaved = 0;		/* buffer left over from argv construction, */
    else {
      FD_CLR (0, ding1);	/* OR we've already got our repeat chunk, */
      close (0);		/* so we won't need any more stdin */
    } /* Single */
  } /* insaved */
  if (o_interval)
    sleep (o_interval);		/* pause *before* sending stuff, too */
  errno = 0;			/* clear from sleep, close, whatever */
d1179 7
a1185 7
  while (FD_ISSET (fd, ding1)) {	/* i.e. till the *net* closes! */
    wretry = 8200;			/* more than we'll ever hafta write */
    if (wfirst) {			/* any saved stdin buffer? */
      wfirst = 0;			/* clear flag for the duration */
      goto shovel;			/* and go handle it first */
    }
    *ding2 = *ding1;			/* FD_COPY ain't portable... */
d1188 41
a1228 34
    if (timer1)
      memcpy (timer2, timer1, sizeof (struct timeval));
    rr = select (16, ding2, 0, 0, timer2);	/* here it is, kiddies */
    if (rr < 0) {
	if (errno != EINTR) {		/* might have gotten ^Zed, etc ?*/
	  holler ("select fuxored");
	  close (fd);
	  return (1);
	}
    } /* select fuckup */
/* if we have a timeout AND stdin is closed AND we haven't heard anything
   from the net during that time, assume it's dead and close it too. */
    if (rr == 0) {
	if (! FD_ISSET (0, ding1))
	  netretry--;			/* we actually try a coupla times. */
	if (! netretry) {
	  if (o_verbose > 1)		/* normally we don't care */
	    holler ("net timeout");
	  close (fd);
	  return (0);			/* not an error! */
	}
    } /* select timeout */
/* xxx: should we check the exception fds too?  The read fds seem to give
   us the right info, and none of the examples I found bothered. */

/* Ding!!  Something arrived, go check all the incoming hoppers, net first */
    if (FD_ISSET (fd, ding2)) {		/* net: ding! */
	rr = read (fd, bigbuf_net, BIGSIZ);
	if (rr <= 0) {
	  FD_CLR (fd, ding1);		/* net closed, we'll finish up... */
	  rzleft = 0;			/* can't write anymore: broken pipe */
	} else {
	  rnleft = rr;
	  np = bigbuf_net;
d1230 11
a1240 11
	  if (o_tn)
	    atelnet (np, rr);		/* fake out telnet stuff */
#endif /* TELNET */
	} /* if rr */
Debug (("got %d from the net, errno %d", rr, errno))
    } /* net:ding */

/* if we're in "slowly" mode there's probably still stuff in the stdin
   buffer, so don't read unless we really need MORE INPUT!  MORE INPUT! */
    if (rzleft)
	goto shovel;
d1243 2
a1244 2
    if (FD_ISSET (0, ding2)) {		/* stdin: ding! */
	rr = read (0, bigbuf_in, BIGSIZ);
d1247 7
a1253 6
	if (rr <= 0) {			/* at end, or fukt, or ... */
	  FD_CLR (0, ding1);		/* disable and close stdin */
	  close (0);
	} else {
	  rzleft = rr;
	  zp = bigbuf_in;
d1256 8
a1263 8
	  if (! Single) {		/* we might be scanning... */
	    insaved = rr;		/* save len */
	    FD_CLR (0, ding1);		/* disable further junk from stdin */
	    close (0);			/* really, I mean it */
	  } /* Single */
	} /* if rr/read */
    } /* stdin:ding */

d1270 4
a1273 4
    if ((rzleft > 8200) || (rnleft > 8200)) {
	holler ("Bogus buffers: %d, %d", rzleft, rnleft);
	rzleft = rnleft = 0;
    }
d1275 43
a1317 40
    if (! wretry) {			/* is something hung? */
	holler ("too many output retries");
	return (1);
    }
    if (rnleft) {
	rr = write (1, np, rnleft);
	if (rr > 0) {
	  if (o_wfile)
	    oprint (1, np, rr);		/* log the stdout */
	  np += rr;			/* fix up ptrs and whatnot */
	  rnleft -= rr;			/* will get sanity-checked above */
	  wrote_out += rr;		/* global count */
	}
Debug (("wrote %d to stdout, errno %d", rr, errno))
    } /* rnleft */
    if (rzleft) {
	if (o_interval)			/* in "slowly" mode ?? */
	  rr = findline (zp, rzleft);
	else
	  rr = rzleft;
	rr = write (fd, zp, rr);	/* one line, or the whole buffer */
	if (rr > 0) {
	  if (o_wfile)
	    oprint (0, zp, rr);		/* log what got sent */
	  zp += rr;
	  rzleft -= rr;
	  wrote_net += rr;		/* global count */
	}
Debug (("wrote %d to net, errno %d", rr, errno))
    } /* rzleft */
    if (o_interval) {			/* cycle between slow lines, or ... */
	sleep (o_interval);
	errno = 0;			/* clear from sleep */
	continue;			/* ...with hairy select loop... */
    }
    if ((rzleft) || (rnleft)) {		/* shovel that shit till they ain't */
	wretry--;			/* none left, and get another load */
	goto shovel;
    }
  } /* while ding1:netfd is open */
d1324 3
a1326 3
  close (fd);
  return (0);
} /* readwrite */
d1330 3
a1332 3
main (argc, argv)
  int argc;
  char ** argv;
d1335 2
a1336 2
  extern char * optarg;
  extern int optind, optopt;
d1338 13
a1350 13
  register int x;
  register char *cp;
  HINF * gp;
  HINF * whereto = NULL;
  HINF * wherefrom = NULL;
  IA * ouraddr = NULL;
  IA * themaddr = NULL;
  USHORT o_lport = 0;
  USHORT ourport = 0;
  USHORT loport = 0;		/* for scanning stuff */
  USHORT hiport = 0;
  USHORT curport = 0;
  char * randports = NULL;
d1354 1
a1354 1
  res_init();
d1358 11
a1368 11
  lclend = (SAI *) Hmalloc (sizeof (SA));
  remend = (SAI *) Hmalloc (sizeof (SA));
  bigbuf_in = Hmalloc (BIGSIZ);
  bigbuf_net = Hmalloc (BIGSIZ);
  ding1 = (fd_set *) Hmalloc (sizeof (fd_set));
  ding2 = (fd_set *) Hmalloc (sizeof (fd_set));
  portpoop = (PINF *) Hmalloc (sizeof (PINF));

  errno = 0;
  gatesptr = 4;
  h_errno = 0;
d1371 3
a1373 3
  signal (SIGINT, catch);
  signal (SIGQUIT, catch);
  signal (SIGTERM, catch);
d1376 1
a1376 1
  signal (SIGURG, SIG_IGN);
d1379 1
a1379 1
  signal (SIGPIPE, SIG_IGN);		/* important! */
d1384 23
a1406 22
  if (argc == 1) {
    cp = argv[0];
    argv = (char **) Hmalloc (128 * sizeof (char *));	/* XXX: 128? */
    argv[0] = cp;			/* leave old prog name intact */
    cp = Hmalloc (BIGSIZ);
    argv[1] = cp;			/* head of new arg block */
    fprintf (stderr, "Cmd line: ");
    fflush (stderr);		/* I dont care if it's unbuffered or not! */
    insaved = read (0, cp, BIGSIZ);	/* we're gonna fake fgets() here */
    if (insaved <= 0)
      bail ("wrong");
    x = findline (cp, insaved);
    if (x)
      insaved -= x;		/* remaining chunk size to be sent */
    if (insaved)		/* which might be zero... */
      memcpy (bigbuf_in, &cp[x], insaved);
    cp = strchr (argv[1], '\n');
    if (cp)
      *cp = '\0';
    cp = strchr (argv[1], '\r');	/* look for ^M too */
    if (cp)
      *cp = '\0';
d1409 21
a1429 20
    cp = argv[1];
    cp++;				/* skip past first char */
    x = 2;				/* we know argv 0 and 1 already */
    for (; *cp != '\0'; cp++) {
      if (*cp == ' ') {
	*cp = '\0';			/* smash all spaces */
	continue;
      } else {
	if (*(cp-1) == '\0') {
	  argv[x] = cp;
	  x++;
	}
      } /* if space */
    } /* for cp */
    argc = x;
  } /* if no args given */

/* If your shitbox doesn't have getopt, step into the nineties already. */
/* optarg, optind = next-argv-component [i.e. flag arg]; optopt = last-char */
  while ((x = getopt (argc, argv, "ae:g:G:hi:lno:p:rs:tuvw:z")) != -1) {
d1431 5
a1435 4
    switch (x) {
      case 'a':
	bail ("all-A-records NIY");
	o_alla++; break;
d1437 3
a1439 3
      case 'e':				/* prog to exec */
	pr00gie = optarg;
	break;
d1441 20
a1460 19
      case 'G':				/* srcrt gateways pointer val */
	x = atoi (optarg);
	if ((x) && (x == (x & 0x1c)))	/* mask off bits of fukt values */
	  gatesptr = x;
	else
	  bail ("invalid hop pointer %d, must be multiple of 4 <= 28", x);
	break;
      case 'g':				/* srcroute hop[s] */
	if (gatesidx > 8)
	  bail ("too many -g hops");
	if (gates == NULL)		/* eat this, Billy-boy */
	  gates = (HINF **) Hmalloc (sizeof (HINF *) * 10);
	gp = gethostpoop (optarg, o_nflag);
	if (gp)
	  gates[gatesidx] = gp;
	gatesidx++;
	break;
      case 'h':
	errno = 0;
d1462 1
a1462 1
	helpme();			/* exits by itself */
d1464 1
a1464 1
	bail ("no help available, dork -- RTFS");
d1466 24
a1489 20
      case 'i':				/* line-interval time */
	o_interval = atoi (optarg) & 0xffff;
	if (! o_interval)
	  bail ("invalid interval time %s", optarg);
	break;
      case 'l':				/* listen mode */
	o_listen++; break;
      case 'n':				/* numeric-only, no DNS lookups */
	o_nflag++; break;
      case 'o':				/* hexdump log */
	stage = (unsigned char *) optarg;
	o_wfile++; break;
      case 'p':				/* local source port */
	o_lport = getportpoop (optarg, 0);
	if (o_lport == 0)
	  bail ("invalid local port %s", optarg);
	break;
      case 'r':				/* randomize various things */
	o_random++; break;
      case 's':				/* local source address */
d1493 3
a1495 3
	wherefrom = gethostpoop (optarg, o_nflag);
	ouraddr = &wherefrom->iaddrs[0];
	break;
d1497 27
a1523 23
      case 't':				/* do telnet fakeout */
	o_tn++; break;
#endif /* TELNET */
      case 'u':				/* use UDP */
	o_udpmode++; break;
      case 'v':				/* verbose */
	o_verbose++; break;
      case 'w':				/* wait time */
	o_wait = atoi (optarg);
	if (o_wait <= 0)
	  bail ("invalid wait-time %s", optarg);
	timer1 = (struct timeval *) Hmalloc (sizeof (struct timeval));
	timer2 = (struct timeval *) Hmalloc (sizeof (struct timeval));
	timer1->tv_sec = o_wait;	/* we need two.  see readwrite()... */
	break;
      case 'z':				/* little or no data xfer */
	o_zero++;
	break;
      default:
	errno = 0;
	bail ("nc -h for help");
    } /* switch x */
  } /* while getopt */
d1526 6
a1531 6
Debug (("fd_set size %d", sizeof (*ding1)))	/* how big *is* it? */
  FD_SET (0, ding1);			/* stdin *is* initially open */
  if (o_random) {
    SRAND (time (0));
    randports = Hmalloc (65536);	/* big flag array for ports */
  }
d1533 12
a1544 13
  if (pr00gie) {
    close (0);				/* won't need stdin */
    o_wfile = 0;			/* -o with -e is meaningless! */
    ofd = 0;
  }
#endif /* G_S_H */
  if (o_wfile) {
    ofd = open (stage, O_WRONLY | O_CREAT | O_TRUNC, 0664);
    if (ofd <= 0)			/* must be > extant 0/1/2 */
      bail ("can't open %s", stage);
    stage = (unsigned char *) Hmalloc (100);
  }

d1546 1
a1546 1
Debug (("after go: x now %c, optarg %x optind %d", x, optarg, optind))
d1551 8
a1558 8
  if (argv[optind])
    whereto = gethostpoop (argv[optind], o_nflag);
  if (whereto && whereto->iaddrs)
    themaddr = &whereto->iaddrs[0];
  if (themaddr)
    optind++;				/* skip past valid host lookup */
  errno = 0;
  h_errno = 0;
d1564 9
a1572 8
  if (o_listen) {
    curport = 0;			/* rem port *can* be zero here... */
    if (argv[optind]) {			/* any rem-port-arg? */
      curport = getportpoop (argv[optind], 0);
      if (curport == 0)			/* if given, demand correctness */
	bail ("invalid port %s", argv[optind]);
    } /* if port-arg */
    netfd = dolisten (themaddr, curport, ouraddr, o_lport);
d1574 1
a1574 1
    if (netfd > 0) {
d1576 18
a1593 19
      if (pr00gie)			/* -e given? */
	doexec (netfd);
#endif /* GAPING_SECURITY_HOLE */
      x = readwrite (netfd);		/* it even works with UDP! */
      if (o_verbose > 1)		/* normally we don't care */
	holler (wrote_txt, wrote_net, wrote_out);
      exit (x);				/* "pack out yer trash" */
    } else /* if no netfd */
      bail ("no connection");
  } /* o_listen */

/* fall thru to outbound connects.  Now we're more picky about args... */
  if (! themaddr)
    bail ("no destination");
  if (argv[optind] == NULL)
    bail ("no port[s] to connect to");
  if (argv[optind + 1])		/* look ahead: any more port args given? */
    Single = 0;				/* multi-mode, case A */
  ourport = o_lport;			/* which can be 0 */
d1599 23
a1621 24
  while (argv[optind]) {
    hiport = loport = 0;
    cp = strchr (argv[optind], '-');	/* nn-mm range? */
    if (cp) {
      *cp = '\0';
      cp++;
      hiport = getportpoop (cp, 0);
      if (hiport == 0)
	bail ("invalid port %s", cp);
    } /* if found a dash */
    loport = getportpoop (argv[optind], 0);
    if (loport == 0)
      bail ("invalid port %s", argv[optind]);
    if (hiport > loport) {		/* was it genuinely a range? */
      Single = 0;			/* multi-mode, case B */
      curport = hiport;			/* start high by default */
      if (o_random) {			/* maybe populate the random array */
	loadports (randports, loport, hiport);
	curport = nextport (randports);
      }
    } else			/* not a range, including args like "25-25" */
      curport = loport;
Debug (("Single %d, curport %d", Single, curport))

d1623 20
a1642 16
    while (loport <= curport) {
      if ((! o_lport) && (o_random)) {	/* -p overrides random local-port */
	ourport = (RAND() & 0xffff);	/* random local-bind -- well above */
	if (ourport < 8192)		/* resv and any likely listeners??? */
	  ourport += 8192;		/* if it *still* conflicts, use -s. */
      }
      curport = getportpoop (NULL, curport);
      netfd = doconnect (themaddr, curport, ouraddr, ourport);
Debug (("netfd %d from port %d to port %d", netfd, ourport, curport))
      if (netfd > 0)
	if (o_zero && o_udpmode)	/* if UDP scanning... */
	  netfd = udptest (netfd, themaddr);
      if (netfd > 0) {			/* Yow, are we OPEN YET?! */
	x = 0;				/* pre-exit status */
	holler ("%s [%s] %d (%s) open",
	  whereto->name, whereto->addrs[0], curport, portpoop->name);
d1644 8
a1651 7
	if (pr00gie)			/* exec is valid for outbound, too */
	  doexec (netfd);
#endif /* GAPING_SECURITY_HOLE */
	if (! o_zero)
	  x = readwrite (netfd);	/* go shovel shit */
      } else { /* no netfd... */
	x = 1;				/* preload exit status for later */
d1654 24
a1677 22
	if ((Single || (o_verbose > 1)) || (errno != ECONNREFUSED))
	  holler ("%s [%s] %d (%s)",
	    whereto->name, whereto->addrs[0], curport, portpoop->name);
      } /* if netfd */
      close (netfd);			/* just in case we didn't already */
      if (o_interval)
	sleep (o_interval);		/* if -i, delay between ports too */
      if (o_random)
	curport = nextport (randports);
      else
	curport--;			/* just decrement... */
    } /* while curport within current range */
    optind++;
  } /* while remaining port-args -- end of big argv-ports loop*/

  errno = 0;
  if (o_verbose > 1)		/* normally we don't care */
    holler (wrote_txt, wrote_net, wrote_out);
  if (Single)
    exit (x);			/* give us status on one connection */
  exit (0);			/* otherwise, we're just done */
} /* main */
d1684 2
a1685 2
  o_verbose = 1;
  holler ("[v1.10]\n\
d1693 1
a1693 1
  holler ("\
d1696 1
a1696 1
  holler ("\
d1708 1
a1708 1
  holler ("\
d1711 1
a1711 1
  holler ("\
d1716 3
a1718 3
  bail ("port numbers can be individual or ranges: lo-hi [inclusive]");
} /* helpme */
#endif /* HAVE_HELP */
@


1.4
log
@buf oflow; and use inet_aton()
@
text
@d46 3
@


1.3
log
@paranoid about MAXHOSTNAMELEN
@
text
@d347 1
a347 1
   if inet_addr, do reverse and forward with any warnings; otherwise try
d358 2
a359 3
  strcpy (poop->name, unknown);		/* preload it */
/* see wzv:workarounds.c for dg/ux return-a-struct inet_addr lossage */
  iaddr.s_addr = inet_addr (name);
a360 1
  if (iaddr.s_addr == INADDR_NONE) {	/* here's the great split: names... */
@


1.2
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@a88 4
#ifdef MAXHOSTNAMELEN
#undef MAXHOSTNAMELEN		/* might be too small on aix, so fix it */
#endif
#define MAXHOSTNAMELEN 256
d369 2
a370 1
    strncpy (poop->name, hostent->h_name, MAXHOSTNAMELEN - 2);
d374 2
a375 1
	sizeof (poop->addrs[0]));
d393 2
a394 1
    strncpy (poop->addrs[0], inet_ntoa (iaddr), sizeof (poop->addrs));
d404 2
a405 1
	strncpy (poop->name, hostent->h_name, MAXHOSTNAMELEN - 2);
d455 2
a456 1
      strncpy (portpoop->name, servent->s_name, sizeof (portpoop->name));
d475 2
a476 1
      strncpy (portpoop->name, servent->s_name, sizeof (portpoop->name));
@


1.1
log
@nc is *hobbit*'s netcat; let the sysadm have the same tools the crackers
have, so that he may learn what the network is about and protect it better.
@
text
@d1392 1
a1392 1
  while ((x = getopt (argc, argv, "ae:g:G:hi:lno:p:rs:tuvw:z")) != EOF) {
@
