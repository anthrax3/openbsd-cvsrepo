head	1.4;
access;
symbols
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.0.18
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.16
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2002.02.19.22.25.26;	author ericj;	state dead;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.12;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.05.08.55.38;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.4
log
@
remove old cruft
@
text
@/*	$OpenBSD: xor.c,v 1.3 2001/11/19 19:02:15 mpech Exp $	*/

/* Generic xor handler.

   With no args, xors stdin against 0xFF to stdout.  A single argument is a
   file to read xor-bytes out of.  Any zero in the xor-bytes array is treated
   as the end; if you need to xor against a string that *includes* zeros,
   you're on your own.

   The indirect file can be generated easily with data.c.

   Written because there are so many lame schemes for "masking" plaintext
   passwords and the like floating around, and it's handy to just run an
   obscure binary-format configuration file through this and look for strings.

   *Hobbit*, 960208 */

#include <stdio.h>
#include <fcntl.h>

char buf[8192];
char bytes[256];
char * py;

/* do the xor, in place.  Uses global ptr "py" to maintain "bytes" state */
xorb (buf, len)
  char * buf;
  int len;
{
  int x;
  char * pb;

  pb = buf;
  x = len;
  while (x > 0) {
    *pb = (*pb ^ *py);
    pb++;
    py++;
    if (! *py)
      py = bytes;
    x--;
  }
} /* xorb */

/* blah */
main (argc, argv)
  int argc;
  char ** argv;
{
  int x = 0;
  int y;

/* manually preload; xor-with-0xFF is all too common */
  memset (bytes, 0, sizeof (bytes));
  bytes[0] = 0xff;

/* if file named in any arg, reload from that */
#ifdef O_BINARY				/* DOS shit... */
  x = setmode (0, O_BINARY);		/* make stdin raw */
  if (x < 0) {
    fprintf (stderr, "stdin binary setmode oops: %d\n", x);
    exit (1);
  }
  x = setmode (1, O_BINARY);		/* make stdout raw */
  if (x < 0) {
    fprintf (stderr, "stdout binary setmode oops: %d\n", x);
    exit (1);
  }
#endif /* O_BINARY */
  
  if (argv[1])
#ifdef O_BINARY
    x = open (argv[1], O_RDONLY | O_BINARY);
#else
    x = open (argv[1], O_RDONLY);
#endif
  if (x > 0) {
    read (x, bytes, 250);		/* nothin' fancy here */
    close (x);
  }
  py = bytes;
  x = 1;
  while (x > 0) {
    x = read (0, buf, sizeof (buf));
    if (x <= 0)
      break;
    xorb (buf, x);
    y = write (1, buf, x);
    if (y <= 0)
      exit (1);
  }
  exit (0);
}

@


1.3
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: xor.c,v 1.2 2001/01/29 01:58:12 niklas Exp $	*/
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d30 2
a31 2
  register int x;
  register char * pb;
d50 2
a51 2
  register int x = 0;
  register int y;
@


1.1
log
@nc is *hobbit*'s netcat; let the sysadm have the same tools the crackers
have, so that he may learn what the network is about and protect it better.
@
text
@d1 2
@

