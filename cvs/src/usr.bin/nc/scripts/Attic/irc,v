head	1.3;
access;
symbols
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.0.18
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.16
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2002.02.19.23.19.39;	author ericj;	state dead;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.12;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.05.08.55.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.3
log
@
remove more old cruft
@
text
@#! /bin/sh
#	$OpenBSD: irc,v 1.2 2001/01/29 01:58:12 niklas Exp $

## Shit-simple script to supply the "privmsg <recipient>" of IRC typein, and
## keep the connection alive.  Pipe this thru "nc -v -w 5 irc-server port".
## Note that this mechanism makes the script easy to debug without being live,
## since it just echoes everything bound for the server.
## if you want autologin-type stuff, construct some appropriate files and
## shovel them in using the "<" mechanism.

# magic arg: if "tick", do keepalive process instead of main loop
if test "$1" = "tick" ; then
# ignore most signals; the parent will nuke the kid
# doesn't stop ^Z, of course.
  trap '' 1 2 3 13 14 15 16
  while true ; do
    sleep 60
    echo "PONG !"
  done
fi

# top level: fire ourselves off as the keepalive process, and keep track of it
sh $0 tick &
ircpp=$!
echo "[Keepalive: $ircpp]" >&2
# catch our own batch of signals: hup int quit pipe alrm term urg
trap 'kill -9 $ircpp ; exit 0' 1 2 3 13 14 15 16
sleep 2

sender=''
savecmd=''

# the big honkin' loop...
while read xx yy ; do
  case "${xx}" in
# blank line: do nothing
    "")
	continue
    ;;
# new channel or recipient; if bare ">", we're back to raw literal mode.
    ">")
	if test "${yy}" ; then
	  sender="privmsg ${yy} :"
	else
	  sender=''
	fi
	continue
    ;;
# send crud from a file, one line per second.  Can you say "skr1pt kidz"??
# *Note: uses current "recipient" if set.
    "<")
	if test -f "${yy}" ; then
	  ( while read zz ; do
	    sleep 1
	    echo "${sender}${zz}"
	  done ) < "$yy"
	  echo "[done]" >&2
	else
	  echo "[File $yy not found]" >&2
	fi
	continue
    ;;
# do and save a single command, for quick repeat
    "/")
	if test "${yy}" ; then
	  savecmd="${yy}"
	fi
	echo "${savecmd}"
    ;;
# default case goes to recipient, just like always
    *)
	echo "${sender}${xx} ${yy}"
	continue
    ;;
  esac
done

# parting shot, if you want it
echo "quit :Bye all!"
kill -9 $ircpp
exit 0
@


1.2
log
@$OpenBSD$
@
text
@d2 1
a2 1
#	$OpenBSD$
@


1.1
log
@nc is *hobbit*'s netcat; let the sysadm have the same tools the crackers
have, so that he may learn what the network is about and protect it better.
@
text
@d2 2
@

