head	1.24;
access;
symbols
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.2
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.20.0.8
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.12
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.10
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.6
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.4
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.6
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.12
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.14
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.10
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.8
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.6
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.24
date	2016.06.27.14.43.04;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	0uUO8adsXHtVoPd0;

1.23
date	2015.12.10.18.31.52;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	qfcGgXtDDKcbrRZB;

1.22
date	2015.12.10.16.49.28;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	1KRyZrX62Ht8TatS;

1.21
date	2015.03.26.21.19.51;	author tobias;	state Exp;
branches;
next	1.20;
commitid	P9sRO7h7165ZoO7l;

1.20
date	2012.03.08.09.56.28;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2011.02.12.15.54.18;	author okan;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.20.07.26.35;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2006.09.25.04.51.20;	author ray;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.25.23.21.37;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.24.20.13.28;	author avsm;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.20.22.46.08;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.20.11.06.58;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.19.08.40.59;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.19.04.29.46;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.08.15.26.23;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.17.03.13.55;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.07.21.36.23;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.03.20.49.29;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.30.17.55.25;	author stevesk;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.28.18.05.36;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.19.22.42.04;	author ericj;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.28.19.46.12;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.28.19.45.17;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.02.18.45.41;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.24
log
@whitespace
@
text
@/*	$OpenBSD: socks.c,v 1.23 2015/12/10 18:31:52 mmcc Exp $	*/

/*
 * Copyright (c) 1999 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2004, 2005 Damien Miller.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <resolv.h>
#include <readpassphrase.h>
#include "atomicio.h"

#define SOCKS_PORT	"1080"
#define HTTP_PROXY_PORT	"3128"
#define HTTP_MAXHDRS	64
#define SOCKS_V5	5
#define SOCKS_V4	4
#define SOCKS_NOAUTH	0
#define SOCKS_NOMETHOD	0xff
#define SOCKS_CONNECT	1
#define SOCKS_IPV4	1
#define SOCKS_DOMAIN	3
#define SOCKS_IPV6	4

int	remote_connect(const char *, const char *, struct addrinfo);
int	socks_connect(const char *, const char *, struct addrinfo,
	    const char *, const char *, struct addrinfo, int,
	    const char *);

static int
decode_addrport(const char *h, const char *p, struct sockaddr *addr,
    socklen_t addrlen, int v4only, int numeric)
{
	int r;
	struct addrinfo hints, *res;

	bzero(&hints, sizeof(hints));
	hints.ai_family = v4only ? PF_INET : PF_UNSPEC;
	hints.ai_flags = numeric ? AI_NUMERICHOST : 0;
	hints.ai_socktype = SOCK_STREAM;
	r = getaddrinfo(h, p, &hints, &res);
	/* Don't fatal when attempting to convert a numeric address */
	if (r != 0) {
		if (!numeric) {
			errx(1, "getaddrinfo(\"%.64s\", \"%.64s\"): %s", h, p,
			    gai_strerror(r));
		}
		return (-1);
	}
	if (addrlen < res->ai_addrlen) {
		freeaddrinfo(res);
		errx(1, "internal error: addrlen < res->ai_addrlen");
	}
	memcpy(addr, res->ai_addr, res->ai_addrlen);
	freeaddrinfo(res);
	return (0);
}

static int
proxy_read_line(int fd, char *buf, size_t bufsz)
{
	size_t off;

	for(off = 0;;) {
		if (off >= bufsz)
			errx(1, "proxy read too long");
		if (atomicio(read, fd, buf + off, 1) != 1)
			err(1, "proxy read");
		/* Skip CR */
		if (buf[off] == '\r')
			continue;
		if (buf[off] == '\n') {
			buf[off] = '\0';
			break;
		}
		off++;
	}
	return (off);
}

static const char *
getproxypass(const char *proxyuser, const char *proxyhost)
{
	char prompt[512];
	static char pw[256];

	snprintf(prompt, sizeof(prompt), "Proxy password for %s@@%s: ",
	   proxyuser, proxyhost);
	if (readpassphrase(prompt, pw, sizeof(pw), RPP_REQUIRE_TTY) == NULL)
		errx(1, "Unable to read proxy passphrase");
	return (pw);
}

/*
 * Error strings adapted from the generally accepted SOCKSv4 spec:
 *
 * http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol
 */
static const char *
socks4_strerror(int e)
{
	switch (e) {
	case 90:
		return "Succeeded";
	case 91:
		return "Request rejected or failed";
	case 92:
		return "SOCKS server cannot connect to identd on the client";
	case 93:
		return "Client program and identd report different user-ids";
	default:
		return "Unknown error";
	}
}

/*
 * Error strings taken almost directly from RFC 1928.
 */
static const char *
socks5_strerror(int e)
{
	switch (e) {
	case 0:
		return "Succeeded";
	case 1:
		return "General SOCKS server failure";
	case 2:
		return "Connection not allowed by ruleset";
	case 3:
		return "Network unreachable";
	case 4:
		return "Host unreachable";
	case 5:
		return "Connection refused";
	case 6:
		return "TTL expired";
	case 7:
		return "Command not supported";
	case 8:
		return "Address type not supported";
	default:
		return "Unknown error";
	}
}

int
socks_connect(const char *host, const char *port,
    struct addrinfo hints __attribute__ ((__unused__)),
    const char *proxyhost, const char *proxyport, struct addrinfo proxyhints,
    int socksv, const char *proxyuser)
{
	int proxyfd, r, authretry = 0;
	size_t hlen, wlen;
	unsigned char buf[1024];
	size_t cnt;
	struct sockaddr_storage addr;
	struct sockaddr_in *in4 = (struct sockaddr_in *)&addr;
	struct sockaddr_in6 *in6 = (struct sockaddr_in6 *)&addr;
	in_port_t serverport;
	const char *proxypass = NULL;

	if (proxyport == NULL)
		proxyport = (socksv == -1) ? HTTP_PROXY_PORT : SOCKS_PORT;

	/* Abuse API to lookup port */
	if (decode_addrport("0.0.0.0", port, (struct sockaddr *)&addr,
	    sizeof(addr), 1, 1) == -1)
		errx(1, "unknown port \"%.64s\"", port);
	serverport = in4->sin_port;

 again:
	if (authretry++ > 3)
		errx(1, "Too many authentication failures");

	proxyfd = remote_connect(proxyhost, proxyport, proxyhints);

	if (proxyfd < 0)
		return (-1);

	if (socksv == 5) {
		if (decode_addrport(host, port, (struct sockaddr *)&addr,
		    sizeof(addr), 0, 1) == -1)
			addr.ss_family = 0; /* used in switch below */

		/* Version 5, one method: no authentication */
		buf[0] = SOCKS_V5;
		buf[1] = 1;
		buf[2] = SOCKS_NOAUTH;
		cnt = atomicio(vwrite, proxyfd, buf, 3);
		if (cnt != 3)
			err(1, "write failed (%zu/3)", cnt);

		cnt = atomicio(read, proxyfd, buf, 2);
		if (cnt != 2)
			err(1, "read failed (%zu/3)", cnt);

		if (buf[1] == SOCKS_NOMETHOD)
			errx(1, "authentication method negotiation failed");

		switch (addr.ss_family) {
		case 0:
			/* Version 5, connect: domain name */

			/* Max domain name length is 255 bytes */
			hlen = strlen(host);
			if (hlen > 255)
				errx(1, "host name too long for SOCKS5");
			buf[0] = SOCKS_V5;
			buf[1] = SOCKS_CONNECT;
			buf[2] = 0;
			buf[3] = SOCKS_DOMAIN;
			buf[4] = hlen;
			memcpy(buf + 5, host, hlen);
			memcpy(buf + 5 + hlen, &serverport, sizeof serverport);
			wlen = 7 + hlen;
			break;
		case AF_INET:
			/* Version 5, connect: IPv4 address */
			buf[0] = SOCKS_V5;
			buf[1] = SOCKS_CONNECT;
			buf[2] = 0;
			buf[3] = SOCKS_IPV4;
			memcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);
			memcpy(buf + 8, &in4->sin_port, sizeof in4->sin_port);
			wlen = 10;
			break;
		case AF_INET6:
			/* Version 5, connect: IPv6 address */
			buf[0] = SOCKS_V5;
			buf[1] = SOCKS_CONNECT;
			buf[2] = 0;
			buf[3] = SOCKS_IPV6;
			memcpy(buf + 4, &in6->sin6_addr, sizeof in6->sin6_addr);
			memcpy(buf + 20, &in6->sin6_port,
			    sizeof in6->sin6_port);
			wlen = 22;
			break;
		default:
			errx(1, "internal error: silly AF");
		}

		cnt = atomicio(vwrite, proxyfd, buf, wlen);
		if (cnt != wlen)
			err(1, "write failed (%zu/%zu)", cnt, wlen);

		cnt = atomicio(read, proxyfd, buf, 4);
		if (cnt != 4)
			err(1, "read failed (%zu/4)", cnt);
		if (buf[1] != 0) {
			errx(1, "connection failed, SOCKSv5 error: %s",
			    socks5_strerror(buf[1]));
		}
		switch (buf[3]) {
		case SOCKS_IPV4:
			cnt = atomicio(read, proxyfd, buf + 4, 6);
			if (cnt != 6)
				err(1, "read failed (%zu/6)", cnt);
			break;
		case SOCKS_IPV6:
			cnt = atomicio(read, proxyfd, buf + 4, 18);
			if (cnt != 18)
				err(1, "read failed (%zu/18)", cnt);
			break;
		default:
			errx(1, "connection failed, unsupported address type");
		}
	} else if (socksv == 4) {
		/* This will exit on lookup failure */
		decode_addrport(host, port, (struct sockaddr *)&addr,
		    sizeof(addr), 1, 0);

		/* Version 4 */
		buf[0] = SOCKS_V4;
		buf[1] = SOCKS_CONNECT;	/* connect */
		memcpy(buf + 2, &in4->sin_port, sizeof in4->sin_port);
		memcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);
		buf[8] = 0;	/* empty username */
		wlen = 9;

		cnt = atomicio(vwrite, proxyfd, buf, wlen);
		if (cnt != wlen)
			err(1, "write failed (%zu/%zu)", cnt, wlen);

		cnt = atomicio(read, proxyfd, buf, 8);
		if (cnt != 8)
			err(1, "read failed (%zu/8)", cnt);
		if (buf[1] != 90) {
			errx(1, "connection failed, SOCKSv4 error: %s",
			    socks4_strerror(buf[1]));
		}
	} else if (socksv == -1) {
		/* HTTP proxy CONNECT */

		/* Disallow bad chars in hostname */
		if (strcspn(host, "\r\n\t []:") != strlen(host))
			errx(1, "Invalid hostname");

		/* Try to be sane about numeric IPv6 addresses */
		if (strchr(host, ':') != NULL) {
			r = snprintf(buf, sizeof(buf),
			    "CONNECT [%s]:%d HTTP/1.0\r\n",
			    host, ntohs(serverport));
		} else {
			r = snprintf(buf, sizeof(buf),
			    "CONNECT %s:%d HTTP/1.0\r\n",
			    host, ntohs(serverport));
		}
		if (r == -1 || (size_t)r >= sizeof(buf))
			errx(1, "hostname too long");
		r = strlen(buf);

		cnt = atomicio(vwrite, proxyfd, buf, r);
		if (cnt != r)
			err(1, "write failed (%zu/%d)", cnt, r);

		if (authretry > 1) {
			char resp[1024];

			proxypass = getproxypass(proxyuser, proxyhost);
			r = snprintf(buf, sizeof(buf), "%s:%s",
			    proxyuser, proxypass);
			if (r == -1 || (size_t)r >= sizeof(buf) ||
			    b64_ntop(buf, strlen(buf), resp,
			    sizeof(resp)) == -1)
				errx(1, "Proxy username/password too long");
			r = snprintf(buf, sizeof(buf), "Proxy-Authorization: "
			    "Basic %s\r\n", resp);
			if (r == -1 || (size_t)r >= sizeof(buf))
				errx(1, "Proxy auth response too long");
			r = strlen(buf);
			if ((cnt = atomicio(vwrite, proxyfd, buf, r)) != r)
				err(1, "write failed (%zu/%d)", cnt, r);
		}

		/* Terminate headers */
		if ((cnt = atomicio(vwrite, proxyfd, "\r\n", 2)) != 2)
			err(1, "write failed (%zu/2)", cnt);

		/* Read status reply */
		proxy_read_line(proxyfd, buf, sizeof(buf));
		if (proxyuser != NULL &&
		    strncmp(buf, "HTTP/1.0 407 ", 12) == 0) {
			if (authretry > 1) {
				fprintf(stderr, "Proxy authentication "
				    "failed\n");
			}
			close(proxyfd);
			goto again;
		} else if (strncmp(buf, "HTTP/1.0 200 ", 12) != 0 &&
		    strncmp(buf, "HTTP/1.1 200 ", 12) != 0)
			errx(1, "Proxy error: \"%s\"", buf);

		/* Headers continue until we hit an empty line */
		for (r = 0; r < HTTP_MAXHDRS; r++) {
			proxy_read_line(proxyfd, buf, sizeof(buf));
			if (*buf == '\0')
				break;
		}
		if (*buf != '\0')
			errx(1, "Too many proxy headers received");
	} else
		errx(1, "Unknown proxy protocol %d", socksv);

	return (proxyfd);
}
@


1.23
log
@Specify SOCKS version in error messages. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.22 2015/12/10 16:49:28 mmcc Exp $	*/
d244 1
a244 1
			memcpy(buf + 5, host, hlen);			
@


1.22
log
@Map SOCKS error codes to error strings. With input from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.21 2015/03/26 21:19:51 tobias Exp $	*/
d281 1
a281 1
			errx(1, "connection failed, SOCKS error: %s",
d319 1
a319 1
			errx(1, "connection failed, SOCKS error: %s",
@


1.21
log
@Fix error message in case of write failure.

ok djm
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.20 2012/03/08 09:56:28 espie Exp $	*/
d125 52
d280 4
a283 2
		if (buf[1] != 0)
			errx(1, "connection failed, SOCKS error %d", buf[1]);
d318 4
a321 2
		if (buf[1] != 90)
			errx(1, "connection failed, SOCKS error %d", buf[1]);
@


1.20
log
@fix format strings for size_t
ok okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.19 2011/02/12 15:54:18 okan Exp $	*/
d311 2
a312 2
		if ((r = atomicio(vwrite, proxyfd, "\r\n", 2)) != 2)
			err(1, "write failed (2/%d)", r);
@


1.19
log
@fix from pr 6207.  a bit more of an explanation: we write the correct
number of bits when connecting via a SOCKS 5 proxy over ipv6, but we
also need to read the same number depending on the received address
type.  this issue is not noticeable with ssh's SOCKS 5 support since it
always set the address type as ipv4.  this fixes connections via SOCKS 5
proxies which set their address type as ipv6 when using ipv6.

after review with, and ok, nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.18 2010/04/20 07:26:35 nicm Exp $	*/
d234 1
a234 1
				err(1, "read failed (%d/6)", cnt);
d239 1
a239 1
				err(1, "read failed (%d/18)", cnt);
@


1.18
log
@Allocate the port number properly (don't allocate space then ignore it),
and use %zu for size_t.

ok djm
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.17 2006/09/25 04:51:20 ray Exp $	*/
d225 3
a227 3
		cnt = atomicio(read, proxyfd, buf, 10);
		if (cnt != 10)
			err(1, "read failed (%zu/10)", cnt);
d230 14
@


1.17
log
@Also accept "HTTP/1.1 200" as a success response.

OK djm@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.16 2006/01/25 23:21:37 djm Exp $	*/
d170 1
a170 1
			err(1, "write failed (%d/3)", cnt);
d174 1
a174 1
			err(1, "read failed (%d/3)", cnt);
d223 1
a223 1
			err(1, "write failed (%d/%d)", cnt, wlen);
d227 1
a227 1
			err(1, "read failed (%d/10)", cnt);
d245 1
a245 1
			err(1, "write failed (%d/%d)", cnt, wlen);
d249 1
a249 1
			err(1, "read failed (%d/8)", cnt);
d275 1
a275 1
			err(1, "write failed (%d/%d)", cnt, r);
d293 1
a293 1
				err(1, "write failed (%d/%d)", cnt, r);
@


1.16
log
@implement HTTP proxy authentication support, very useful in a ssh_config
ProxyCommand; ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.15 2005/05/24 20:13:28 avsm Exp $	*/
d310 2
a311 1
		} else if (strncmp(buf, "HTTP/1.0 200 ", 12) != 0)
@


1.15
log
@Switch atomicio to a simpler interface which returns size_t and uses
0 to signal errors.  should be no functional change in nc apart from
different error messages.

"groovy", said deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.14 2005/05/20 22:46:08 djm Exp $	*/
d40 2
d57 3
a59 3
int	socks_connect(const char *host, const char *port, struct addrinfo hints,
	    const char *proxyhost, const char *proxyport, struct addrinfo proxyhints,
	    int socksv);
d112 13
d129 1
a129 1
    int socksv)
d131 1
a131 1
	int proxyfd, r;
d139 1
a143 5
	proxyfd = remote_connect(proxyhost, proxyport, proxyhints);

	if (proxyfd < 0)
		return (-1);

d150 9
d262 1
a262 1
			    "CONNECT [%s]:%d HTTP/1.0\r\n\r\n",
d266 1
a266 1
			    "CONNECT %s:%d HTTP/1.0\r\n\r\n",
d277 37
a313 1
		/* Read reply */
a315 3
			if (r == 0 && strncmp(buf, "HTTP/1.0 200 ", 12) != 0)
				errx(1, "Proxy error: \"%s\"", buf);
			/* Discard headers until we hit an empty line */
d319 2
@


1.14
log
@Teach the SOCKS5 code more of the protocol, so it can send domain names
to the proxy instead of resolving them locally and sending IPv4 addresses.
This improves privacy, e.g. when using nc with OpenSSH DynamicForward tunnels,
and gives us better IPv6 support; ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.13 2005/05/20 11:06:58 djm Exp $	*/
d40 1
a53 1
ssize_t	atomicio(ssize_t (*)(int, void *, size_t), int, void *, size_t);
d89 1
a89 1
proxy_read_line(int fd, char *buf, int bufsz)
d91 1
a91 1
	int r, off;
d96 1
a96 3
		if ((r = read(fd, buf + off, 1)) <= 0) {
			if (r == -1 && errno == EINTR)
				continue;
a97 1
		}
d119 1
a119 1
	ssize_t cnt;
d148 1
a148 3
		cnt = write(proxyfd, buf, 3);
		if (cnt == -1)
			err(1, "write failed");
d150 5
a154 1
			errx(1, "short write, %d (expected 3)", cnt);
a155 1
		read(proxyfd, buf, 2);
d201 1
a201 4
		cnt = atomicio((ssize_t (*)(int, void *, size_t))write,
		    proxyfd, buf, wlen);
		if (cnt == -1)
			err(1, "write failed");
d203 1
a203 1
			errx(1, "short write, %d (expected %d)", cnt, wlen);
a205 2
		if (cnt == -1)
			err(1, "read failed");
d207 1
a207 1
			errx(1, "unexpected reply size %d (expected 10)", cnt);
d223 1
a223 3
		cnt = write(proxyfd, buf, wlen);
		if (cnt == -1)
			err(1, "write failed");
d225 1
a225 1
			errx(1, "short write, %d (expected %d)", cnt, wlen);
a227 2
		if (cnt == -1)
			err(1, "read failed");
d229 1
a229 1
			errx(1, "unexpected reply size %d (expected 8)", cnt);
d253 1
a253 4
		cnt = atomicio((ssize_t (*)(int, void *, size_t))write,
		    proxyfd, buf, r);
		if (cnt == -1)
			err(1, "write failed");
d255 1
a255 1
			errx(1, "short write, %d (expected %d)", cnt, r);
@


1.13
log
@HTTP proxy doesn't need an address lookup - saves some time and avoids a
spurious error if the lookup fails. from Ray; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.12 2005/05/19 08:40:59 djm Exp $	*/
d5 1
d50 2
d53 1
a53 1

d59 3
a61 2
static in_addr_t
decode_addr(const char *s)
d63 2
a64 2
	struct hostent *hp = gethostbyname(s);
	struct in_addr retval;
d66 16
a81 19
	if (hp)
		return (*(in_addr_t *)hp->h_addr_list[0]);
	if (inet_aton(s, &retval))
		return (retval.s_addr);
	errx(1, "cannot decode address \"%s\"", s);
}

static in_port_t
decode_port(const char *s)
{
	struct servent *sp;
	in_port_t port;
	char *p;

	port = strtol(s, &p, 10);
	if (s == p) {
		sp = getservbyname(s, "tcp");
		if (sp)
			return (sp->s_port);
d83 3
a85 3
	if (*s != '\0' && *p == '\0')
		return (htons(port));
	errx (1, "cannot decode port \"%s\"", s);
d120 1
d123 3
a125 1
	in_addr_t serveraddr;
d136 5
a140 4
	/* HTTP proxies should use hostnames. (XXX so can SOCKS5) */
	if (socksv != -1)
		serveraddr = decode_addr(host);
	serverport = decode_port(port);
d143 4
d161 41
a201 7
		/* Version 5, connect: IPv4 address */
		buf[0] = SOCKS_V5;
		buf[1] = SOCKS_CONNECT;
		buf[2] = 0;
		buf[3] = SOCKS_IPV4;
		memcpy(buf + 4, &serveraddr, sizeof serveraddr);
		memcpy(buf + 8, &serverport, sizeof serverport);
d203 2
a204 2
		/* XXX Handle short writes better */
		cnt = write(proxyfd, buf, 10);
d207 2
a208 2
		if (cnt != 10)
			errx(1, "short write, %d (expected 10)", cnt);
d210 1
a210 2
		/* XXX Handle short reads better */
		cnt = read(proxyfd, buf, 10);
d218 4
d225 2
a226 2
		memcpy(buf + 2, &serverport, sizeof serverport);
		memcpy(buf + 4, &serveraddr, sizeof serveraddr);
d228 1
d230 1
a230 1
		cnt = write(proxyfd, buf, 9);
d233 2
a234 2
		if (cnt != 9)
			errx(1, "short write, %d (expected 9)", cnt);
d236 1
a236 2
		/* XXX Handle short reads better */
		cnt = read(proxyfd, buf, 8);
d264 2
a265 2
		/* XXX atomicio */
		cnt = write(proxyfd, buf, r);
@


1.12
log
@fix SOCKS5 code for case where data comes in the same packet as the response;
ok dtucker@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.11 2005/05/19 04:29:46 djm Exp $	*/
d132 3
a134 1
	serveraddr = decode_addr(host);
@


1.11
log
@KNF, no binary change; ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.10 2005/02/08 15:26:23 otto Exp $	*/
d166 1
a166 1
		cnt = read(proxyfd, buf, sizeof buf);
@


1.10
log
@Some extra strict warning cleanup. From Xin Li <delphij at FreeBSD
dot ORG> with a twist from myself. No binary change. ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.9 2004/10/17 03:13:55 djm Exp $	*/
d59 1
a59 1
	struct hostent *hp = gethostbyname (s);
d63 4
a66 4
		return *(in_addr_t *)hp->h_addr_list[0];
	if (inet_aton (s, &retval))
		return retval.s_addr;
	errx (1, "cannot decode address \"%s\"", s);
d76 1
a76 1
	port = strtol (s, &p, 10);
d78 1
a78 1
		sp = getservbyname (s, "tcp");
d80 1
a80 1
			return sp->s_port;
d83 1
a83 1
		return htons (port);
d130 1
a130 1
		return -1;
d132 2
a133 2
	serveraddr = decode_addr (host);
	serverport = decode_port (port);
d140 1
a140 1
		cnt = write (proxyfd, buf, 3);
d142 1
a142 1
			err (1, "write failed");
d144 1
a144 1
			errx (1, "short write, %d (expected 3)", cnt);
d146 1
a146 1
		read (proxyfd, buf, 2);
d148 1
a148 1
			errx (1, "authentication method negotiation failed");
d155 2
a156 2
		memcpy (buf + 4, &serveraddr, sizeof serveraddr);
		memcpy (buf + 8, &serverport, sizeof serverport);
d159 1
a159 1
		cnt = write (proxyfd, buf, 10);
d161 1
a161 1
			err (1, "write failed");
d163 1
a163 1
			errx (1, "short write, %d (expected 10)", cnt);
d166 1
a166 1
		cnt = read (proxyfd, buf, sizeof buf);
d168 1
a168 1
			err (1, "read failed");
d170 1
a170 1
			errx (1, "unexpected reply size %d (expected 10)", cnt);
d172 1
a172 1
			errx (1, "connection failed, SOCKS error %d", buf[1]);
d177 2
a178 2
		memcpy (buf + 2, &serverport, sizeof serverport);
		memcpy (buf + 4, &serveraddr, sizeof serveraddr);
d181 1
a181 1
		cnt = write (proxyfd, buf, 9);
d183 1
a183 1
			err (1, "write failed");
d185 1
a185 1
			errx (1, "short write, %d (expected 9)", cnt);
d188 1
a188 1
		cnt = read (proxyfd, buf, 8);
d190 1
a190 1
			err (1, "read failed");
d192 1
a192 1
			errx (1, "unexpected reply size %d (expected 8)", cnt);
d194 1
a194 1
			errx (1, "connection failed, SOCKS error %d", buf[1]);
d200 1
a200 1
			errx (1, "Invalid hostname");
d213 1
a213 1
			errx (1, "hostname too long");
d217 1
a217 1
		cnt = write (proxyfd, buf, r);
d219 1
a219 1
			err (1, "write failed");
d221 1
a221 1
			errx (1, "short write, %d (expected %d)", cnt, r);
d227 1
a227 1
				errx (1, "Proxy error: \"%s\"", buf);
d233 1
a233 1
		errx (1, "Unknown proxy protocol %d", socksv);
d235 1
a235 1
	return proxyfd;
@


1.9
log
@http proxy CONNECT support; ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.8 2003/07/07 21:36:23 deraadt Exp $	*/
d51 3
a53 3
int	remote_connect(char *, char *, struct addrinfo);
int	socks_connect(char *host, char *port, struct addrinfo hints,
	    char *proxyhost, char *proxyport, struct addrinfo proxyhints,
d113 3
a115 2
socks_connect(char *host, char *port, struct addrinfo hints,
    char *proxyhost, char *proxyport, struct addrinfo proxyhints,
d212 1
a212 1
		if (r == -1 || r >= sizeof(buf))
@


1.8
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.7 2003/06/03 20:49:29 deraadt Exp $	*/
d33 1
d41 2
d49 1
a49 1
#define SOCKS_MAXCMDSZ	10
d87 25
d117 2
a118 2
	int proxyfd;
	unsigned char buf[SOCKS_MAXCMDSZ];
d123 4
a126 4
	if (proxyport)
		proxyfd = remote_connect(proxyhost, proxyport, proxyhints);
	else
		proxyfd = remote_connect(proxyhost, SOCKS_PORT, proxyhints);
d172 1
a172 1
	} else {
d194 39
a232 1
	}
@


1.7
log
@fix various 3/4 licenses according to "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.6 2002/12/30 17:55:25 stevesk Exp $	*/
d49 3
d54 1
a54 1
decode_addr (const char *s)
d67 1
a67 1
decode_port (const char *s)
d85 1
a85 1
socks_connect (char *host, char *port, struct addrinfo hints,
@


1.6
log
@correct return code check; from Owl.  ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.5 2002/02/28 18:05:36 markus Exp $	*/
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Niklas Hallqvist.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.5
log
@add support for SOCKS4 with option -X socks_version, default is 5; ok ericj@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.4 2002/02/19 22:42:04 ericj Exp $	*/
d102 1
a102 1
	if (!proxyfd)
@


1.4
log
@
-Wall cleanup.
from Kevin Steves <stevesk@@pobox.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.3 2001/10/28 19:46:12 jakob Exp $	*/
d45 2
a46 1
#define SOCKS_VERSION	5
d88 2
a89 1
    char *proxyhost, char *proxyport, struct addrinfo proxyhints)
d108 61
a168 37
	/* Version 5, one method: no authentication */
	buf[0] = SOCKS_VERSION;
	buf[1] = 1;
	buf[2] = SOCKS_NOAUTH;
	cnt = write (proxyfd, buf, 3);
	if (cnt == -1)
		err (1, "write failed");
	if (cnt != 3)
		errx (1, "short write, %d (expected 3)", cnt);

	read (proxyfd, buf, 2);
	if (buf[1] == SOCKS_NOMETHOD)
		errx (1, "authentication method negotiation failed");

	/* Version 5, connect: IPv4 address */
	buf[0] = SOCKS_VERSION;
	buf[1] = SOCKS_CONNECT;
	buf[2] = 0;
	buf[3] = SOCKS_IPV4;
	memcpy (buf + 4, &serveraddr, sizeof serveraddr);
	memcpy (buf + 8, &serverport, sizeof serverport);

	/* XXX Handle short writes better */
	cnt = write (proxyfd, buf, 10);
	if (cnt == -1)
		err (1, "write failed");
	if (cnt != 10)
		errx (1, "short write, %d (expected 10)", cnt);

	/* XXX Handle short reads better */
	cnt = read (proxyfd, buf, sizeof buf);
	if (cnt == -1)
		err (1, "read failed");
	if (cnt != 10)
		errx (1, "unexpected reply size %d (expected 10)", cnt);
	if (buf[1] != 0)
		errx (1, "connection failed, SOCKS error %d", buf[1]);
@


1.3
log
@fix stupid typo
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.2 2001/10/28 19:45:17 jakob Exp $	*/
d51 2
@


1.2
log
@remove unused variable
@
text
@d1 1
a1 1
*	$OpenBSD: socks.c,v 1.1 2001/09/02 18:45:41 jakob Exp $	*/
@


1.1
log
@add very basic proxy support using socks5 client code from niklas@@.
ok ericj@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a86 1
	char *proxyport_default;
@

