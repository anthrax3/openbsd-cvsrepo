head	1.41;
access;
symbols
	OPENBSD_6_1:1.41.0.4
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.40.0.2
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.35.0.6
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.6
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.33.0.6
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.4
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.2
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.10
	OPENBSD_5_0:1.30.0.8
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.6
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.4
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.12
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.8
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.6
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.4
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.28.0.4
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.22.0.8
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.6
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.4
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.4.0.16
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.14
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2017.01.21.11.32.04;	author guenther;	state Exp;
branches;
next	1.40;
commitid	DpBZlpar7mq0CJFq;

1.40
date	2016.03.16.15.41.11;	author krw;	state Exp;
branches;
next	1.39;
commitid	JEVxsRygqcjPtWTf;

1.39
date	2015.11.11.01.12.10;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	nVtGolYSsQ6VkRrW;

1.38
date	2015.10.18.03.54.22;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	rQB89Wup6ZhbwGpK;

1.37
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	sbrB3Q5CNxcwZpfU;

1.36
date	2015.10.07.14.36.07;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	VSYZzJL6KT3GZt6L;

1.35
date	2015.01.16.06.40.13;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	Uu5nFG3wCl0LACBb;

1.34
date	2013.11.26.21.08.12;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2012.05.21.13.14.30;	author gsoares;	state Exp;
branches;
next	1.32;

1.32
date	2012.05.02.13.41.15;	author gsoares;	state Exp;
branches;
next	1.31;

1.31
date	2012.05.01.04.23.21;	author gsoares;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.27.23.59.44;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.11.01.47.48;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.26.22.43.53;	author mglocker;	state Exp;
branches;
next	1.27;

1.27
date	2006.07.26.09.10.03;	author mglocker;	state Exp;
branches;
next	1.26;

1.26
date	2006.07.24.17.29.58;	author mglocker;	state Exp;
branches;
next	1.25;

1.25
date	2006.07.12.16.58.51;	author mglocker;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.08.13.02.51;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.23.17.29.22;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.19.08.43.37;	author mpech;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.22.22.17.38;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.29.11.23.38;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.25.09.45.46;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.24.20.21.40;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.24.20.19.48;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.25.21.09.37;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.25.15.45.10;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.10.22.20.53;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.03.02.56.18;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.17.17.17.27;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.13.09.09.35;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.55;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.31.14.32.15;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.17.02.23.59;	author pvalchev;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.22.01.34.01;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.07.18.13.14;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.17.07.13.30;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.08.16.23.31.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.40.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.15;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.15;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.41
log
@The POSIX APIs that that sockaddrs all ignore the s*_len field in the
incoming socket, so userspace doesn't need to set it unless it has its
own reasons for tracking the size along with the sockaddr.

ok phessler@@ deraadt@@ florian@@
@
text
@/*	$OpenBSD: main.c,v 1.40 2016/03/16 15:41:11 krw Exp $	*/
/*	$NetBSD: main.c,v 1.6 1995/05/21 16:54:10 mycroft Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * TFTP User Program -- Command Interface
 *
 * This version includes many modifications by Jim Guyton <guyton@@rand-unix>
 */

#include <sys/socket.h>
#include <sys/file.h>

#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/tftp.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <netdb.h>
#include <poll.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "extern.h"

#define	LBUFLEN		200		/* size of input buffer */
#define	MAXARGV		20
#define HELPINDENT	(sizeof("connect"))

void			 get(int, char **);
void			 help(int, char **);
void			 modecmd(int, char **);
void			 put(int, char **);
void			 quit(int, char **);
void			 setascii(int, char **);
void			 setbinary(int, char **);
void			 setpeer(char *, char *);
void			 parsearg(int, char **);
void			 setrexmt(int, char **);
void			 settimeout(int, char **);
void			 settrace(int, char **);
void			 setverbose(int, char **);
void			 settsize(int, char **);
void			 settout(int, char **);
void			 setblksize(int, char **);
void			 status(int, char **);
int			 readcmd(char *, int, FILE *);
static void		 getusage(char *);
static int		 makeargv(void);
static void		 putusage(char *);
static void		 settftpmode(char *);
static __dead void	 command(void);
struct cmd	 	*getcmd(char *);
char			*tail(char *);

struct sockaddr_storage	 peeraddr;
int			 f;
int			 trace;
int			 verbose;
int			 connected;
char			 mode[32];
char			 line[LBUFLEN];
int			 margc;
char			*margv[MAXARGV+1];
char			*prompt = "tftp";
void			 intr(int);
int	 		 rexmtval = TIMEOUT;
int	 		 maxtimeout = 5 * TIMEOUT;
char	 		 hostname[HOST_NAME_MAX+1];
FILE			*file = NULL;
volatile sig_atomic_t	 intrflag = 0;
char			*ackbuf;
int			 has_options = 0;
int			 opt_tsize = 0;
int			 opt_tout = 0;
int			 opt_blksize = 0;

char	vhelp[] = "toggle verbose mode";
char	thelp[] = "toggle packet tracing";
char	chelp[] = "connect to remote tftp";
char	qhelp[] = "exit tftp";
char	hhelp[] = "print help information";
char	shelp[] = "send file";
char	rhelp[] = "receive file";
char	mhelp[] = "set file transfer mode";
char	sthelp[] = "show current status";
char	xhelp[] = "set per-packet retransmission timeout";
char	ihelp[] = "set total retransmission timeout";
char	ashelp[] = "set mode to netascii";
char	bnhelp[] = "set mode to octet";
char	oshelp[] = "toggle tsize option";
char	othelp[] = "toggle timeout option";
char	obhelp[] = "set alternative blksize option";

struct cmd {
	char	*name;
	char	*help;
	void	 (*handler)(int, char **);
};

struct cmd cmdtab[] = {
	{ "connect",	chelp,	parsearg },
	{ "mode",       mhelp,	modecmd },
	{ "put",	shelp,	put },
	{ "get",	rhelp,	get },
	{ "quit",	qhelp,	quit },
	{ "verbose",	vhelp,	setverbose },
	{ "trace",	thelp,	settrace },
	{ "status",	sthelp,	status },
	{ "binary",     bnhelp,	setbinary },
	{ "ascii",      ashelp,	setascii },
	{ "rexmt",	xhelp,	setrexmt },
	{ "timeout",	ihelp,	settimeout },
	{ "tsize",	oshelp, settsize },
	{ "tout",	othelp, settout },
	{ "blksize",	obhelp,	setblksize },
	{ "help",	hhelp,	help },
	{ "?",		hhelp,	help },
	{ NULL,		NULL,	NULL }
};

struct	modes {
	char	*m_name;
	char	*m_mode;
} modes[] = {
	{ "ascii",	"netascii" },
	{ "netascii",	"netascii" },
	{ "binary",	"octet" },
	{ "image",	"octet" },
	{ "octet",	"octet" },
/*	{ "mail",	"mail" }, */
	{ NULL,		NULL }
};

int
main(int argc, char *argv[])
{
	f = -1;

	if (pledge("stdio rpath wpath cpath dns inet", NULL) == -1)
		err(1, "pledge");

	/* set default transfer mode */
	strlcpy(mode, "netascii", sizeof(mode));

	/* set peer if given */
	if (argc > 1)
		parsearg(argc, argv);

	/* catch SIGINT */
	signal(SIGINT, intr);

	/* allocate memory for packets */
	if ((ackbuf = malloc(SEGSIZE_MAX + 4)) == NULL)
		err(1, "malloc");

	/* command prompt */
	command();

	return (0);
}

void
setpeer(char *host, char *port)
{
	struct addrinfo hints, *res0, *res;
	int error;
	struct sockaddr_storage ss;
	char *cause = "unknown";

	if (connected) {
		close(f);
		f = -1;
	}
	connected = 0;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM;
	hints.ai_protocol = IPPROTO_UDP;
	hints.ai_flags = AI_CANONNAME;
	if (!port)
		port = "tftp";
	error = getaddrinfo(host, port, &hints, &res0);
	if (error) {
		warnx("%s", gai_strerror(error));
		return;
	}

	for (res = res0; res; res = res->ai_next) {
		if (res->ai_addrlen > sizeof(peeraddr))
			continue;
		f = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
		if (f < 0) {
			cause = "socket";
			continue;
		}

		memset(&ss, 0, sizeof(ss));
		ss.ss_family = res->ai_family;
		if (bind(f, (struct sockaddr *)&ss, res->ai_addrlen) < 0) {
			cause = "bind";
			close(f);
			f = -1;
			continue;
		}

		break;
	}

	if (f < 0)
		warn("%s", cause);
	else {
		/* res->ai_addr <= sizeof(peeraddr) is guaranteed */
		memcpy(&peeraddr, res->ai_addr, res->ai_addrlen);
		if (res->ai_canonname) {
			(void)strlcpy(hostname, res->ai_canonname,
			    sizeof(hostname));
		} else
			(void)strlcpy(hostname, host, sizeof(hostname));
			connected = 1;
	}
	freeaddrinfo(res0);
}

void
parsearg(int argc, char *argv[])
{
	if (argc < 2) {
		strlcpy(line, "Connect ", sizeof(line));
		printf("(to) ");
		readcmd(&line[strlen(line)], LBUFLEN - strlen(line), stdin);
		if (makeargv())
			return;
		argc = margc;
		argv = margv;
	}
	if ((argc < 2) || (argc > 3)) {
		printf("usage: %s [host [port]]\n", argv[0]);
		return;
	}
	if (argc == 2)
		setpeer(argv[1], NULL);
	else
		setpeer(argv[1], argv[2]);
}

void
modecmd(int argc, char *argv[])
{
	struct modes	*p;
	char		*sep;

	if (argc < 2) {
		printf("Using %s mode to transfer files.\n", mode);
		return;
	}
	if (argc == 2) {
		for (p = modes; p->m_name != NULL; p++)
			if (strcmp(argv[1], p->m_name) == 0)
				break;
		if (p->m_name) {
			settftpmode(p->m_mode);
			return;
		}
		printf("%s: unknown mode\n", argv[1]);
		/* drop through and print usage message */
	}

	printf("usage: %s [", argv[0]);
	sep = " ";
	for (p = modes; p->m_name != NULL; p++) {
		printf("%s%s", sep, p->m_name);
		if (*sep == ' ')
			sep = " | ";
	}
	printf(" ]\n");

	return;
}

/* ARGSUSED */
void
setbinary(int argc, char *argv[])
{
	settftpmode("octet");
}

/* ARGSUSED */
void
setascii(int argc, char *argv[])
{
	settftpmode("netascii");
}

static void
settftpmode(char *newmode)
{
	strlcpy(mode, newmode, sizeof(mode));
	if (verbose)
		printf("mode set to %s\n", mode);
}

/*
 * Send file(s).
 */
void
put(int argc, char *argv[])
{
	int	 fd;
	int	 n;
	char	*cp, *targ;

	if (argc < 2) {
		strlcpy(line, "put ", sizeof(line));
		printf("(file) ");
		readcmd(&line[strlen(line)], LBUFLEN - strlen(line), stdin);
		if (makeargv())
			return;
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		putusage(argv[0]);
		return;
	}
	targ = argv[argc - 1];
	if (strrchr(argv[argc - 1], ':')) {

		for (n = 1; n < argc - 1; n++)
			if (strchr(argv[n], ':')) {
				putusage(argv[0]);
				return;
			}
		cp = argv[argc - 1];
		targ = strrchr(cp, ':');
		*targ++ = 0;
		if (cp[0] == '[' && cp[strlen(cp) - 1] == ']') {
			cp[strlen(cp) - 1] = '\0';
			cp++;
		}
		setpeer(cp, NULL);
	}
	if (!connected) {
		printf("No target machine specified.\n");
		return;
	}
	if (argc < 4) {
		cp = argc == 2 ? tail(targ) : argv[1];
		fd = open(cp, O_RDONLY);
		if (fd < 0) {
			warn("open: %s", cp);
			return;
		}
		if (verbose)
			printf("putting %s to %s:%s [%s]\n",
			    cp, hostname, targ, mode);
		sendfile(fd, targ, mode);
		return;
	}

	/*
	 * this assumes the target is a directory on
	 * on a remote unix system.  hmmmm.
	 */
	for (n = 1; n < argc - 1; n++) {
		if (asprintf(&cp, "%s/%s", targ, tail(argv[n])) == -1)
			err(1, "asprintf");
		fd = open(argv[n], O_RDONLY);
		if (fd < 0) {
			warn("open: %s", argv[n]);
			free(cp);
			continue;
		}
		if (verbose)
			printf("putting %s to %s:%s [%s]\n",
			    argv[n], hostname, cp, mode);
		sendfile(fd, cp, mode);
		free(cp);
	}
}

static void
putusage(char *s)
{
	printf("usage: %s file [[host:]remotename]\n", s);
	printf("       %s file1 file2 ... fileN [[host:]remote-directory]\n",
	    s);
}

/*
 * Receive file(s).
 */
void
get(int argc, char *argv[])
{
	int	 fd;
	int	 n;
	char	*cp;
	char	*src;

	if (argc < 2) {
		strlcpy(line, "get ", sizeof(line));
		printf("(files) ");
		readcmd(&line[strlen(line)], LBUFLEN - strlen(line), stdin);
		if (makeargv())
			return;
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		getusage(argv[0]);
		return;
	}
	if (!connected) {
		for (n = 1; n < argc; n++)
			if (strrchr(argv[n], ':') == 0) {
				getusage(argv[0]);
				return;
			}
	}
	for (n = 1; n < argc; n++) {
		src = strrchr(argv[n], ':');
		if (src == NULL)
			src = argv[n];
		else {
			char *cp;

			*src++ = 0;
			cp = argv[n];
			if (cp[0] == '[' && cp[strlen(cp) - 1] == ']') {
				cp[strlen(cp) - 1] = '\0';
				cp++;
			}
			setpeer(cp, NULL);
			if (!connected)
				continue;
		}
		if (argc < 4) {
			cp = argc == 3 ? argv[2] : tail(src);
			fd = open(cp, O_CREAT | O_TRUNC | O_WRONLY, 0644);
			if (fd < 0) {
				warn("create: %s", cp);
				return;
			}
			if (verbose)
				printf("getting from %s:%s to %s [%s]\n",
				    hostname, src, cp, mode);
			recvfile(fd, src, mode);
			break;
		}
		cp = tail(src);	/* new .. jdg */
		fd = open(cp, O_CREAT | O_TRUNC | O_WRONLY, 0644);
		if (fd < 0) {
			warn("create: %s", cp);
			continue;
		}
		if (verbose)
			printf("getting from %s:%s to %s [%s]\n",
			    hostname, src, cp, mode);
		recvfile(fd, src, mode);
	}
}

static void
getusage(char *s)
{
	printf("usage: %s [host:]file [localname]\n", s);
	printf("       %s [host1:]file1 [host2:]file2 ... [hostN:]fileN\n", s);
}

void
setrexmt(int argc, char *argv[])
{
	int		 t;
	const char	*errstr;

	if (argc < 2) {
		strlcpy(line, "Rexmt-timeout ", sizeof(line));
		printf("(value) ");
		readcmd(&line[strlen(line)], LBUFLEN - strlen(line), stdin);
		if (makeargv())
			return;
		argc = margc;
		argv = margv;
	}
	if (argc != 2) {
		printf("usage: %s value\n", argv[0]);
		return;
	}
	t = strtonum(argv[1], TIMEOUT_MIN, TIMEOUT_MAX, &errstr);
	if (errstr)
		printf("%s: value is %s\n", argv[1], errstr);
	else
		rexmtval = t;
}

void
settimeout(int argc, char *argv[])
{
	int		 t;
	const char	*errstr;

	if (argc < 2) {
		strlcpy(line, "Maximum-timeout ", sizeof(line));
		printf("(value) ");
		readcmd(&line[strlen(line)], LBUFLEN - strlen(line), stdin);
		if (makeargv())
			return;
		argc = margc;
		argv = margv;
	}
	if (argc != 2) {
		printf("usage: %s value\n", argv[0]);
		return;
	}
	t = strtonum(argv[1], TIMEOUT_MIN, TIMEOUT_MAX, &errstr);
	if (errstr)
		printf("%s: value is %s\n", argv[1], errstr);
	else
		maxtimeout = t;
}

/* ARGSUSED */
void
status(int argc, char *argv[])
{
	if (connected)
		printf("Connected to %s.\n", hostname);
	else
		printf("Not connected.\n");
	printf("Mode: %s Verbose: %s Tracing: %s\n",
	    mode, verbose ? "on" : "off", trace ? "on" : "off");
	printf("Rexmt-interval: %d seconds, Max-timeout: %d seconds\n",
	    rexmtval, maxtimeout);
}

/* ARGSUSED */
void
intr(int signo)
{
	intrflag = 1;
}

char *
tail(char *filename)
{
	char	*s;

	while (*filename) {
		s = strrchr(filename, '/');
		if (s == NULL)
			break;
		if (s[1])
			return (s + 1);
		*s = '\0';
	}

	return (filename);
}

/*
 * Command parser.
 */
static __dead void
command(void)
{
	struct cmd	*c;

	for (;;) {
		printf("%s> ", prompt);
		if (readcmd(line, LBUFLEN, stdin) < 1)
			continue;
		if ((line[0] == 0) || (line[0] == '\n'))
			continue;
		if (makeargv())
			continue;
		if (margc == 0)
			continue;
		c = getcmd(margv[0]);
		if (c == (struct cmd *) - 1) {
			printf("?Ambiguous command\n");
			continue;
		}
		if (c == 0) {
			printf("?Invalid command\n");
			continue;
		}
		(*c->handler)(margc, margv);
	}
}

struct cmd *
getcmd(char *name)
{
	char		*p, *q;
	struct cmd	*c, *found;
	int		 nmatches, longest;

	longest = 0;
	nmatches = 0;
	found = 0;
	intrflag = 0;
	for (c = cmdtab; (p = c->name) != NULL; c++) {
		for (q = name; *q == *p++; q++)
			if (*q == 0)		/* exact match? */
				return (c);
		if (!*q) {			/* the name was a prefix */
			if (q - name > longest) {
				longest = q - name;
				nmatches = 1;
				found = c;
			} else if (q - name == longest)
				nmatches++;
		}
	}
	if (nmatches > 1)
		return ((struct cmd *) - 1);

	return (found);
}

/*
 * Slice a string up into argc/argv.
 */
static int
makeargv(void)
{
	char	 *cp;
	char	**argp = margv;
	int	  ret = 0;

	margc = 0;
	for (cp = line; *cp;) {
		if (margc >= MAXARGV) {
			printf("too many arguments\n");
			ret = 1;
			break;
		}
		while (isspace((unsigned char)*cp))
			cp++;
		if (*cp == '\0')
			break;
		*argp++ = cp;
		margc += 1;
		while (*cp != '\0' && !isspace((unsigned char)*cp))
			cp++;
		if (*cp == '\0')
			break;
		*cp++ = '\0';
	}
	*argp++ = 0;

	return (ret);
}

/* ARGSUSED */
void
quit(int argc, char *argv[])
{
	exit(0);
}

/*
 * Help command.
 */
void
help(int argc, char *argv[])
{
	struct cmd	*c;

	if (argc == 1) {
		printf("Commands may be abbreviated.  Commands are:\n\n");
		for (c = cmdtab; c->name != NULL; c++)
			printf("%-*s\t%s\n", (int)HELPINDENT, c->name, c->help);
		return;
	}
	while (--argc > 0) {
		char *arg;
		arg = *++argv;
		c = getcmd(arg);
		if (c == (struct cmd *) - 1)
			printf("?Ambiguous help command %s\n", arg);
		else if (c == NULL)
			printf("?Invalid help command %s\n", arg);
		else
			printf("%s\n", c->help);
	}
}

/* ARGSUSED */
void
settrace(int argc, char *argv[])
{
	trace = !trace;
	printf("Packet tracing %s.\n", trace ? "on" : "off");
}

/* ARGSUSED */
void
setverbose(int argc, char *argv[])
{
	verbose = !verbose;
	printf("Verbose mode %s.\n", verbose ? "on" : "off");
}

/* ARGSUSED */
void
settsize(int argc, char *argv[])
{
	opt_tsize = !opt_tsize;
	printf("Tsize option %s.\n", opt_tsize ? "on" : "off");
	if (opt_tsize)
		has_options++;
	else
		has_options--;
}

/* ARGSUSED */
void
settout(int argc, char *argv[])
{
	opt_tout = !opt_tout;
	printf("Timeout option %s.\n", opt_tout ? "on" : "off");
	if (opt_tout)
		has_options++;
	else
		has_options--;
}

void
setblksize(int argc, char *argv[])
{
	int		 t;
	const char	*errstr;

	if (argc < 2) {
		strlcpy(line, "Blocksize ", sizeof(line));
		printf("(value) ");
		readcmd(&line[strlen(line)], LBUFLEN - strlen(line), stdin);
		if (makeargv())
			return;
		argc = margc;
		argv = margv;
	}
	if (argc != 2) {
		printf("usage: %s value\n", argv[0]);
		return;
	}
	t = strtonum(argv[1], SEGSIZE_MIN, SEGSIZE_MAX, &errstr);
	if (errstr)
		printf("%s: value is %s\n", argv[1], errstr);
	else {
		if (opt_blksize == 0)
			has_options++;
		opt_blksize = t;
	}
}

int
readcmd(char *input, int len, FILE *stream)
{
	int		nfds;
	struct pollfd	pfd[1];

	fflush(stdout);

	pfd[0].fd = 0;
	pfd[0].events = POLLIN;
	nfds = poll(pfd, 1, INFTIM);
	if (nfds == -1) {
		if (intrflag) {
			intrflag = 0;
			putchar('\n');
			return (0);
		}
		exit(1);
	}

	if (fgets(input, len, stream) == NULL) {
		if (feof(stdin))
			exit(0);
		else
			return (-1);
	}

	return (1);
}
@


1.40
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.39 2015/11/11 01:12:10 deraadt Exp $	*/
d235 1
a235 2
		ss.ss_len = res->ai_addrlen;
		if (bind(f, (struct sockaddr *)&ss, ss.ss_len) < 0) {
@


1.39
log
@creat() -> open equiv; from Frederic Nowak
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.38 2015/10/18 03:54:22 deraadt Exp $	*/
d719 1
a719 1
		else if (c == (struct cmd *)0)
@


1.38
log
@Add "dns" to the pledges.  Previously these worked because of "inet",
alas "dns" is now a mandatory statement if you want to do dns!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 2015/10/09 01:37:09 deraadt Exp $	*/
d476 1
a476 1
			fd = creat(cp, 0644);
d488 1
a488 1
		fd = creat(cp, 0644);
@


1.37
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.36 2015/10/07 14:36:07 deraadt Exp $	*/
d174 1
a174 1
	if (pledge("stdio inet rpath wpath cpath", NULL) == -1)
@


1.36
log
@tame "stdio inet rpath wpath cpath" supports all the functions of tftp.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.35 2015/01/16 06:40:13 deraadt Exp $	*/
d174 2
a175 2
	if (tame("stdio inet rpath wpath cpath", NULL) == -1)
		err(1, "tame");
@


1.35
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2013/11/26 21:08:12 deraadt Exp $	*/
d173 3
@


1.34
log
@unsigned char casts for ctype
ok okan
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 2012/05/21 13:14:30 gsoares Exp $	*/
a38 1
#include <sys/param.h>
d56 1
d103 1
a103 1
char	 		 hostname[MAXHOSTNAMELEN];
@


1.33
log
@fix put usage

ok sthen@@ henning@@ dlg@@
"looks right" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2012/05/02 13:41:15 gsoares Exp $	*/
d672 1
a672 1
		while (isspace(*cp))
d678 1
a678 1
		while (*cp != '\0' && !isspace(*cp))
@


1.32
log
@strncpy() -> strlcpy()

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2012/05/01 04:23:21 gsoares Exp $	*/
d347 1
a347 1
		strlcpy(line, "send ", sizeof(line));
@


1.31
log
@IPv6 support; mostly a sync with netbsd code done by itojun@@

tweaks/OK henning@@ sthen@@ jmc@@ jasper@@

feedback/tests weerd@@ brad@@ (thanks)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2009/10/27 23:59:44 deraadt Exp $	*/
d249 2
a250 2
			(void) strncpy(hostname, res->ai_canonname,
				sizeof(hostname));
d252 1
a252 2
			(void) strncpy(hostname, host, sizeof(hostname));
			hostname[sizeof(hostname)-1] = 0;
@


1.30
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2007/05/11 01:47:48 ray Exp $	*/
d71 2
a72 1
void			 setpeer(int, char **);
d90 1
a90 1
struct sockaddr_in	 peeraddr;
a91 1
short			 port;
a100 1
struct servent		*sp;
d136 1
a136 1
	{ "connect",	chelp,	setpeer },
d172 1
a172 13
	struct sockaddr_in	s_in;

	/* socket, bind */
	sp = getservbyname("tftp", "udp");
	if (sp == 0)
		errx(1, "udp/tftp: unknown service");
	f = socket(AF_INET, SOCK_DGRAM, 0);
	if (f < 0)
		err(3, "socket");
	bzero((char *)&s_in, sizeof(s_in));
	s_in.sin_family = AF_INET;
	if (bind(f, (struct sockaddr *)&s_in, sizeof(s_in)) < 0)
		err(1, "bind");
d179 1
a179 1
		setpeer(argc, argv);
d195 1
a195 1
setpeer(int argc, char *argv[])
d197 32
a228 2
	struct hostent	*host;
	const char	*errstr;
d230 32
d275 4
a278 26
	if (inet_aton(argv[1], &peeraddr.sin_addr) != 0) {
		peeraddr.sin_family = AF_INET;
		(void)strncpy(hostname, argv[1], sizeof(hostname));
		hostname[sizeof(hostname) - 1] = '\0';
	} else {
		host = gethostbyname(argv[1]);
		if (host == 0) {
			connected = 0;
			printf("%s: unknown host\n", argv[1]);
			return;
		}
		peeraddr.sin_family = host->h_addrtype;
		bcopy(host->h_addr, &peeraddr.sin_addr, host->h_length);
		(void)strlcpy(hostname, host->h_name, sizeof(hostname));
	}
	port = sp->s_port;
	if (argc == 3) {
		port = strtonum(argv[2], 1, 65535, &errstr);
		if (errstr) {
			printf("%s: port number is %s\n", argv[2], errstr);
			connected = 0;
			return;
		}
		port = htons(port);
	}
	connected = 1;
d361 1
a361 2
	if (strchr(argv[argc - 1], ':')) {
		struct hostent	*hp;
d369 1
a369 1
		targ = strchr(cp, ':');
d371 3
a373 4
		hp = gethostbyname(cp);
		if (hp == NULL) {
			warnx("%s: %s", cp, hstrerror(h_errno));
			return;
d375 1
a375 5
		bcopy(hp->h_addr, (caddr_t)&peeraddr.sin_addr, hp->h_length);
		peeraddr.sin_family = hp->h_addrtype;
		connected = 1;
		port = sp->s_port;
		strlcpy(hostname, hp->h_name, sizeof(hostname));
a390 1
		peeraddr.sin_port = port;
a410 1
		peeraddr.sin_port = port;
d450 1
a450 1
			if (strchr(argv[n], ':') == 0) {
d456 1
a456 1
		src = strchr(argv[n], ':');
d460 1
a460 1
			struct hostent	*hp;
d463 7
a469 3
			hp = gethostbyname(argv[n]);
			if (hp == NULL) {
				warnx("%s: %s", argv[n], hstrerror(h_errno));
a470 6
			}
			bcopy(hp->h_addr, (caddr_t)&peeraddr.sin_addr,
			    hp->h_length);
			peeraddr.sin_family = hp->h_addrtype;
			connected = 1;
			strlcpy(hostname, hp->h_name, sizeof(hostname));
a481 1
			peeraddr.sin_port = port;
a493 1
		peeraddr.sin_port = port;
@


1.29
log
@Delinting from tbert <bret dot lambert at gmail dot com>

OK moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2006/07/26 22:43:53 mglocker Exp $	*/
a31 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1983, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)main.c	8.1 (Berkeley) 6/6/93";
#endif
static const char rcsid[] =
    "$OpenBSD: main.c,v 1.28 2006/07/26 22:43:53 mglocker Exp $";
#endif /* not lint */
@


1.28
log
@Make tftp atoi() free.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 2006/07/26 09:10:03 mglocker Exp $	*/
d44 1
a44 1
    "$OpenBSD: main.c,v 1.27 2006/07/26 09:10:03 mglocker Exp $";
d302 1
d309 1
a348 1
		char		*cp;
d556 1
d570 1
d689 1
d723 1
d731 1
d739 1
d751 1
@


1.27
log
@Fixing several timeout quirks at tftpd and tftp:

- move TIMEOUT* defines to arpa/tftp.h, as they are used several times
  in tftpd and tftp, and the values are part of the RFC definition.
- tftpd and tftp did count the total retransmission time in retries
  instead in seconds.  fixed.
- tftpd rexmt timeout was hardcoded by a define and therefore didn't
  changed when the timeout option was sent.  fixed.
- limit total retransmission timeout in tftp to also 255 seconds.
- replace obvious atoi()'s by strtonum().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 2006/07/24 17:29:58 mglocker Exp $	*/
d44 1
a44 1
    "$OpenBSD: main.c,v 1.26 2006/07/24 17:29:58 mglocker Exp $";
d225 1
d257 3
a259 3
		port = atoi(argv[2]);
		if (port < 0) {
			printf("%s: bad port number\n", argv[2]);
a547 1
	t = atoi(argv[1]);
@


1.26
log
@Adding TFTP Option Extension to the tftp client according to RFC 2347.

Implemented options are:

- TFTP Blocksize Option, RFC 2348
- TFTP Timeout Interval and Transfer Size Options, RFC 2349

We have now on the tftp client side the same options supported as in
our tftp server.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2006/07/12 16:58:51 mglocker Exp $	*/
d44 1
a44 1
    "$OpenBSD: main.c,v 1.25 2006/07/12 16:58:51 mglocker Exp $";
a73 1
#define	TIMEOUT		5		/* secs between rexmt's */
d521 1
a521 1
	t = strtonum(argv[1], 1, 255, &errstr);
d531 2
a532 1
	int	t;
d548 3
a550 2
	if (t < 0)
		printf("%s: bad value\n", argv[1]);
@


1.25
log
@knf.  no binary change.

ok beck@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2006/05/08 13:02:51 claudio Exp $	*/
d44 1
a44 1
    "$OpenBSD: main.c,v 1.24 2006/05/08 13:02:51 claudio Exp $";
d59 1
d91 3
d122 5
d141 3
d164 3
d212 4
d506 2
a507 1
	int	t;
d522 3
a524 3
	t = atoi(argv[1]);
	if (t < 0)
		printf("%s: bad value\n", argv[1]);
d730 51
@


1.24
log
@Remove unsave setjmp/longjmp calls that were used in signal handlers with
a more sane poll loop. Includes some style(9) changes.
Diff made by Marcus Glocker
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2006/01/23 17:29:22 millert Exp $	*/
d43 2
a44 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.23 2006/01/23 17:29:22 millert Exp $";
a46 2
/* Many bug fixes are from Jim Guyton <guyton@@rand-unix> */

d48 3
a50 1
 * TFTP User Program -- Command Interface.
d61 1
d64 1
a69 2
#include <err.h>
#include <poll.h>
d78 40
a117 47
struct	sockaddr_in peeraddr;
int	f;
short	port;
int	trace;
int	verbose;
int	connected;
char	mode[32];
char	line[LBUFLEN];
int	margc;
char	*margv[MAXARGV+1];
char	*prompt = "tftp";
void	intr(int);
struct	servent *sp;
int	rexmtval = TIMEOUT;
int	maxtimeout = 5 * TIMEOUT;
char	hostname[MAXHOSTNAMELEN];
FILE	*file = NULL;

volatile sig_atomic_t intrflag = 0;

void	get(int, char **);
void	help(int, char **);
void	modecmd(int, char **);
void	put(int, char **);
void	quit(int, char **);
void	setascii(int, char **);
void	setbinary(int, char **);
void	setpeer(int, char **);
void	setrexmt(int, char **);
void	settimeout(int, char **);
void	settrace(int, char **);
void	setverbose(int, char **);
void	status(int, char **);
int	readcmd(char *, int, FILE *);

static __dead void command(void);

static void getusage(char *);
static int makeargv(void);
static void putusage(char *);
static void settftpmode(char *);

struct cmd {
	char	*name;
	char	*help;
	void	(*handler)(int, char **);
};
d133 6
d140 15
a154 15
	{ "connect",	chelp,		setpeer },
	{ "mode",       mhelp,          modecmd },
	{ "put",	shelp,		put },
	{ "get",	rhelp,		get },
	{ "quit",	qhelp,		quit },
	{ "verbose",	vhelp,		setverbose },
	{ "trace",	thelp,		settrace },
	{ "status",	sthelp,		status },
	{ "binary",     bnhelp,         setbinary },
	{ "ascii",      ashelp,         setascii },
	{ "rexmt",	xhelp,		setrexmt },
	{ "timeout",	ihelp,		settimeout },
	{ "help",	hhelp,		help },
	{ "?",		hhelp,		help },
	{ NULL,		NULL,		NULL }
d158 2
a159 2
	char *m_name;
	char *m_mode;
a169 3
struct	cmd *getcmd(char *);
char	*tail(char *);

d173 1
a173 1
	struct sockaddr_in s_in;
d206 1
a206 1
	struct hostent *host;
d209 1
a209 1
		strlcpy(line, "Connect ", sizeof line);
d211 1
a211 1
		readcmd(&line[strlen(line)], LBUFLEN-strlen(line), stdin);
d223 2
a224 2
		(void) strncpy(hostname, argv[1], sizeof hostname);
		hostname[sizeof(hostname)-1] = '\0';
d234 1
a234 1
		(void) strlcpy(hostname, host->h_name, sizeof hostname);
d252 2
a253 2
	struct modes *p;
	char *sep;
d279 1
d298 1
a298 1
	strlcpy(mode, newmode, sizeof mode);
d309 3
a311 3
	int fd;
	int n;
	char *cp, *targ;
d314 1
a314 1
		strlcpy(line, "send ", sizeof line);
d328 2
a329 2
		char *cp;
		struct hostent *hp;
d348 1
a348 1
		strlcpy(hostname, hp->h_name, sizeof hostname);
d405 4
a408 4
	int fd;
	int n;
	char *cp;
	char *src;
d411 1
a411 1
		strlcpy(line, "get ", sizeof line);
d413 1
a413 1
		readcmd(&line[strlen(line)], LBUFLEN-strlen(line), stdin);
d424 1
a424 1
		for (n = 1; n < argc ; n++)
d430 1
a430 1
	for (n = 1; n < argc ; n++) {
d435 1
a435 1
			struct hostent *hp;
d447 1
a447 1
			strlcpy(hostname, hp->h_name, sizeof hostname);
d463 1
a463 1
		cp = tail(src);         /* new .. jdg */
d487 1
a487 1
	int t;
d490 1
a490 1
		strlcpy(line, "Rexmt-timeout ", sizeof line);
d492 1
a492 1
		readcmd(&line[strlen(line)], LBUFLEN-strlen(line), stdin);
d512 1
a512 1
	int t;
d515 1
a515 1
		strlcpy(line, "Maximum-timeout ", sizeof line);
d517 1
a517 1
		readcmd(&line[strlen(line)], LBUFLEN-strlen(line), stdin);
d541 2
a542 2
	printf("Mode: %s Verbose: %s Tracing: %s\n", mode,
		verbose ? "on" : "off", trace ? "on" : "off");
d544 1
a544 1
		rexmtval, maxtimeout);
d556 1
a556 1
	char *s;
d566 1
d576 1
a576 1
	struct cmd *c;
d589 1
a589 1
		if (c == (struct cmd *)-1) {
d604 3
a606 3
	char *p, *q;
	struct cmd *c, *found;
	int nmatches, longest;
d626 2
a627 1
		return ((struct cmd *)-1);
d637 3
a639 3
	char *cp;
	char **argp = margv;
	int ret = 0;
d661 1
d677 1
a677 1
	struct cmd *c;
d689 1
a689 1
		if (c == (struct cmd *)-1)
@


1.23
log
@Include <sys/param.h> instead of <sys/types.h> so we get MAXHOSTNAMELEN
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2004/02/19 08:43:37 mpech Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.22 2004/02/19 08:43:37 mpech Exp $";
d51 1
a56 1

a61 1
#include <setjmp.h>
d68 1
d75 1
d79 1
a79 1
short   port;
a87 1
jmp_buf	toplevel;
d90 6
d110 1
a118 2
#define HELPINDENT (sizeof("connect"))

d136 2
a137 2
char    ashelp[] = "set mode to netascii";
char    bnhelp[] = "set mode to octet";
d152 1
d157 13
d178 1
d185 1
a185 1
	bzero((char *)&s_in, sizeof (s_in));
d187 1
a187 1
	if (bind(f, (struct sockaddr *)&s_in, sizeof (s_in)) < 0)
d189 9
a197 1
	strlcpy(mode, "netascii", sizeof mode);
d199 2
a200 7
	if (argc > 1) {
		if (setjmp(toplevel) != 0)
			exit(0);
		setpeer(argc, argv);
	}
	if (setjmp(toplevel) != 0)
		(void)putchar('\n');
d202 1
a205 2
char    hostname[MAXHOSTNAMELEN];

d214 1
a214 1
		fgets(&line[strlen(line)], LBUFLEN-strlen(line), stdin);
a251 13
struct	modes {
	char *m_name;
	char *m_mode;
} modes[] = {
	{ "ascii",	"netascii" },
	{ "netascii",   "netascii" },
	{ "binary",     "octet" },
	{ "image",      "octet" },
	{ "octet",     "octet" },
/*      { "mail",       "mail" },       */
	{ NULL,		NULL }
};

a287 1

a293 1

a304 1

d318 1
a318 1
		fgets(&line[strlen(line)], LBUFLEN-strlen(line), stdin);
d371 4
a374 2
	/* this assumes the target is a directory */
	/* on a remote unix system.  hmmmm.  */
d397 2
a398 1
	printf("       %s file1 file2 ... fileN [[host:]remote-directory]\n", s);
d415 1
a415 1
		fgets(&line[strlen(line)], LBUFLEN-strlen(line), stdin);
a485 2
int	rexmtval = TIMEOUT;

d494 1
a494 1
		fgets(&line[strlen(line)], LBUFLEN-strlen(line), stdin);
a510 2
int	maxtimeout = 5 * TIMEOUT;

d519 1
a519 1
		fgets(&line[strlen(line)], LBUFLEN-strlen(line), stdin);
d552 1
a552 4

	signal(SIGALRM, SIG_IGN);
	alarm(0);
	longjmp(toplevel, -1);
d581 2
a582 7
		if (fgets(line, LBUFLEN, stdin) == 0) {
			if (feof(stdin)) {
				exit(0);
			} else {
				continue;
			}
		}
d612 1
a666 1

d709 30
@


1.22
log
@fix mem leak.

hackers@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2003/12/22 22:17:38 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.21 2003/12/22 22:17:38 deraadt Exp $";
d51 1
a51 1
#include <sys/types.h>
@


1.21
log
@do not re-include name in err() call; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2003/09/29 11:23:38 jmc Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.20 2003/09/29 11:23:38 jmc Exp $";
d373 1
@


1.20
log
@correction to SYNOPSIS and usage(): host argument must be specified
if using port argument;

from simon@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2003/09/25 09:45:46 jmc Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.19 2003/09/25 09:45:46 jmc Exp $";
d164 1
a164 1
		err(3, "tftp: socket");
d168 1
a168 1
		err(1, "tftp: bind");
@


1.19
log
@- clarify "put" and "get" commands. This is based on a FreeBSD PR submitted
by Gary W. Swearingen and fixed by Simon L. Nielsen in rev. 1.15;
- some other small clarifications to the man page
- sync usage()'s with the man page
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2003/09/24 20:21:40 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.18 2003/09/24 20:21:40 deraadt Exp $";
d199 1
a199 1
		printf("usage: %s [host] [port]\n", argv[0]);
@


1.18
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2003/09/24 20:19:48 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.17 2003/09/24 20:19:48 deraadt Exp $";
d199 1
a199 1
		printf("usage: %s host-name [port]\n", argv[0]);
d387 2
a388 2
	printf("usage: %s file ... host:target, or\n", s);
	printf("       %s file ... target (when already connected)\n", s);
d472 2
a473 2
	printf("usage: %s host:file host:file ... file, or\n", s);
	printf("       %s file file ... file if connected\n", s);
@


1.17
log
@fix automatic connection which is supposed to be done in put command;
found by jmc, fixed by me
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 2003/06/25 21:09:37 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.16 2003/06/25 21:09:37 deraadt Exp $";
d359 1
a359 1
				cp, hostname, targ, mode);
d364 3
a366 2
				/* this assumes the target is a directory */
				/* on a remote unix system.  hmmmm.  */
d377 1
a377 1
				argv[n], hostname, cp, mode);
d450 1
a450 1
					hostname, src, cp, mode);
d463 1
a463 1
				hostname, src, cp, mode);
@


1.16
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 2003/06/25 15:45:10 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.15 2003/06/25 15:45:10 deraadt Exp $";
d343 1
@


1.15
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2003/06/10 22:20:53 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.14 2003/06/10 22:20:53 deraadt Exp $";
d88 1
a88 1
void	intr();
d542 1
a542 1
intr(void)
@


1.14
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 2003/06/03 02:56:18 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.13 2003/06/03 02:56:18 millert Exp $";
d468 1
a468 2
getusage(s)
	char *s;
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 2003/04/17 17:17:27 henning Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.12 2003/04/17 17:17:27 henning Exp $";
d151 2
a152 2
struct	cmd *getcmd();
char	*tail();
d155 1
a155 3
main(argc, argv)
	int argc;
	char *argv[];
d185 1
a185 3
setpeer(argc, argv)
	int argc;
	char *argv[];
d244 1
a244 3
modecmd(argc, argv)
	int argc;
	char *argv[];
d277 1
a277 3
setbinary(argc, argv)
	int argc;
	char *argv[];
d284 1
a284 3
setascii(argc, argv)
	int argc;
	char *argv[];
d291 1
a291 2
settftpmode(newmode)
	char *newmode;
d303 1
a303 3
put(argc, argv)
	int argc;
	char *argv[];
d383 1
a383 2
putusage(s)
	char *s;
d393 1
a393 3
get(argc, argv)
	int argc;
	char *argv[];
d478 1
a478 3
setrexmt(argc, argv)
	int argc;
	char *argv[];
d505 1
a505 3
settimeout(argc, argv)
	int argc;
	char *argv[];
d530 1
a530 3
status(argc, argv)
	int argc;
	char *argv[];
d543 1
a543 1
intr()
d552 1
a552 2
tail(filename)
	char *filename;
d571 1
a571 1
command()
d604 1
a604 2
getcmd(name)
	char *name;
d635 1
a635 1
makeargv()
d665 1
a665 3
quit(argc, argv)
	int argc;
	char *argv[];
d675 1
a675 3
help(argc, argv)
	int argc;
	char *argv[];
d699 1
a699 3
settrace(argc, argv)
	int argc;
	char **argv;
d706 1
a706 3
setverbose(argc, argv)
	int argc;
	char **argv;
@


1.12
log
@nuke strcpy + -Wall

parts from and ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 2003/03/13 09:09:35 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.11 2003/03/13 09:09:35 deraadt Exp $";
@


1.11
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 2002/02/16 21:27:55 millert Exp $	*/
d38 1
a38 1
static char copyright[] =
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.10 2002/02/16 21:27:55 millert Exp $";
a381 2
	cp = strchr(targ, '\0');
	*cp++ = '/';
d383 2
a384 1
		strcpy(cp, tail(argv[n]));
d392 1
a392 1
				argv[n], hostname, targ, mode);
d394 2
a395 1
		sendfile(fd, targ, mode);
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 2001/11/19 19:02:16 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.9 2001/11/19 19:02:16 mpech Exp $";
d175 1
a175 1
	strcpy(mode, "netascii");
d198 1
a198 1
		strcpy(line, "Connect ");
d223 1
a223 1
		(void) strcpy(hostname, host->h_name);
d308 1
a308 1
	strcpy(mode, newmode);
d327 1
a327 1
		strcpy(line, "send ");
d360 1
a360 1
		strcpy(hostname, hp->h_name);
d421 1
a421 1
		strcpy(line, "get ");
d457 1
a457 1
			strcpy(hostname, hp->h_name);
d505 1
a505 1
		strcpy(line, "Rexmt-timeout ");
d534 1
a534 1
		strcpy(line, "Maximum-timeout ");
@


1.9
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 2001/07/31 14:32:15 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.8 2001/07/31 14:32:15 mpech Exp $";
d95 20
a114 20
void	get __P((int, char **));
void	help __P((int, char **));
void	modecmd __P((int, char **));
void	put __P((int, char **));
void	quit __P((int, char **));
void	setascii __P((int, char **));
void	setbinary __P((int, char **));
void	setpeer __P((int, char **));
void	setrexmt __P((int, char **));
void	settimeout __P((int, char **));
void	settrace __P((int, char **));
void	setverbose __P((int, char **));
void	status __P((int, char **));

static __dead void command __P((void));

static void getusage __P((char *));
static int makeargv __P((void));
static void putusage __P((char *));
static void settftpmode __P((char *));
d121 1
a121 1
	void	(*handler) __P((int, char **));
@


1.8
log
@o) better struct handling;
o) use __progname in openlog(3);
o) better ERROR packets handling;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 2001/07/17 02:23:59 pvalchev Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.7 2001/07/17 02:23:59 pvalchev Exp $";
d256 1
a256 1
	register struct modes *p;
d323 2
a324 2
	register int n;
	register char *cp, *targ;
d416 2
a417 2
	register int n;
	register char *cp;
d581 1
a581 1
	register char *s;
d600 1
a600 1
	register struct cmd *c;
d632 1
a632 1
	register char *name;
d634 3
a636 3
	register char *p, *q;
	register struct cmd *c, *found;
	register int nmatches, longest;
d665 2
a666 2
	register char *cp;
	register char **argp = margv;
d709 1
a709 1
	register struct cmd *c;
d718 1
a718 1
		register char *arg;
@


1.7
log
@-Wall cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 2001/03/22 01:34:01 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.6 2001/03/22 01:34:01 mickey Exp $";
d152 1
a152 1
	{ 0 }
d248 1
a248 1
	{ 0,		0 }
d264 1
a264 1
		for (p = modes; p->m_name; p++)
d277 1
a277 1
	for (p = modes; p->m_name; p++) {
d713 1
a713 1
		for (c = cmdtab; c->name; c++)
@


1.6
log
@use err/warn, space police
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 2000/12/07 18:13:14 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.5 2000/12/07 18:13:14 deraadt Exp $";
d185 1
@


1.5
log
@tftp argv parsing overflow; fix by vogelke@@dnaco.net and I
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 1997/01/17 07:13:30 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.4 1997/01/17 07:13:30 millert Exp $";
d72 1
d166 2
a167 4
	if (sp == 0) {
		fprintf(stderr, "tftp: udp/tftp: unknown service\n");
		exit(1);
	}
d169 2
a170 4
	if (f < 0) {
		perror("tftp: socket");
		exit(3);
	}
d173 2
a174 4
	if (bind(f, (struct sockaddr *)&s_in, sizeof (s_in)) < 0) {
		perror("tftp: bind");
		exit(1);
	}
d289 1
a289 1
{      
d353 1
a353 2
			fprintf(stderr, "tftp: %s: ", cp);
			herror((char *)NULL);
d369 1
a369 1
			fprintf(stderr, "tftp: "); perror(cp);
d381 1
a381 1
	cp = strchr(targ, '\0'); 
d387 1
a387 1
			fprintf(stderr, "tftp: "); perror(argv[n]);
d449 1
a449 2
				fprintf(stderr, "tftp: %s: ", argv[n]);
				herror((char *)NULL);
d462 1
a462 1
				fprintf(stderr, "tftp: "); perror(cp);
d475 1
a475 1
			fprintf(stderr, "tftp: "); perror(cp);
d581 1
a581 1
	
@


1.4
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 1996/08/16 23:31:00 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.3 1996/08/16 23:31:00 deraadt Exp $";
d77 1
d88 1
a88 1
char	*margv[20];
d111 1
a111 1
static void makeargv __P((void));
d205 2
a206 1
		makeargv();
d334 2
a335 1
		makeargv();
d429 2
a430 1
		makeargv();
d514 2
a515 1
		makeargv();
d543 2
a544 1
		makeargv();
d619 2
a620 1
		makeargv();
d668 1
a668 1
static void
d673 1
d677 5
d695 1
@


1.3
log
@crank hostname length, fix one oflow; pointed out by dholland@@hcs.harvard.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.2 1996/06/26 05:40:34 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.2 1996/06/26 05:40:34 deraadt Exp $";
a154 2
char	*index();
char	*rindex();
d341 1
a341 1
	if (index(argv[argc - 1], ':')) {
d346 1
a346 1
			if (index(argv[n], ':')) {
d351 1
a351 1
		targ = index(cp, ':');
d384 1
a384 1
	cp = index(targ, '\0'); 
d436 1
a436 1
			if (index(argv[n], ':') == 0) {
d442 1
a442 1
		src = index(argv[n], ':');
d584 1
a584 1
		s = rindex(filename, '/');
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 1995/05/21 16:54:10 mycroft Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.6 1995/05/21 16:54:10 mycroft Exp $";
d193 1
a193 1
char    hostname[100];
d216 2
a217 1
		(void) strcpy(hostname, argv[1]);
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: main.c,v 1.6 1995/05/21 16:54:10 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
