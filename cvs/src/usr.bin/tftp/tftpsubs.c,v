head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.20
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.18
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.14
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.16
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.8
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.12
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.10
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.6
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.4
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.10
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.9.0.10
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2012.05.01.04.23.21;	author gsoares;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.44;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.10.14.29.53;	author tobias;	state Exp;
branches;
next	1.12;

1.12
date	2006.07.26.12.34.41;	author mglocker;	state Exp;
branches;
next	1.11;

1.11
date	2006.07.20.09.42.44;	author mglocker;	state Exp;
branches;
next	1.10;

1.10
date	2006.07.12.16.58.51;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.24.20.21.40;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.26.07.59.49;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.25.15.45.10;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.03.02.56.18;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.17.17.17.27;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.06.18.55.04;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.40.36;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.16;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@IPv6 support; mostly a sync with netbsd code done by itojun@@

tweaks/OK henning@@ sthen@@ jmc@@ jasper@@

feedback/tests weerd@@ brad@@ (thanks)
@
text
@/*	$OpenBSD: tftpsubs.c,v 1.14 2009/10/27 23:59:44 deraadt Exp $	*/
/*	$NetBSD: tftpsubs.c,v 1.3 1994/12/08 09:51:31 jtc Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Simple minded read-ahead/write-behind subroutines for tftp user and
 * server.  Written originally with multiple buffers in mind, but current
 * implementation has two buffer logic wired in.
 *
 * Todo:  add some sort of final error check so when the write-buffer
 * is finally flushed, the caller can detect if the disk filled up
 * (or had an i/o error) and return a nak to the other side.
 *
 *			Jim Guyton 10/85
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>

#include <netinet/in.h>
#include <arpa/tftp.h>

#include <stdio.h>
#include <unistd.h>

#include "tftpsubs.h"

					/* values for bf.counter */
#define BF_ALLOC	-3		/* alloc'd but not yet filled */
#define BF_FREE		-2		/* free */
/* [-1 .. SEGSIZE] = size of data in the data buffer */

static struct tftphdr	*rw_init(int);

struct bf {
	int	counter;		/* size of data in buffer, or flag */
	char	buf[SEGSIZE_MAX + 4];	/* room for data packet */
} bfs[2];

static int	nextone;	/* index of next buffer to use */
static int	current;	/* index of buffer in use */
				/* control flags for crlf conversions */
int		newline = 0;	/* fillbuf: in middle of newline expansion */
int		prevchar = -1;	/* putbuf: previous char (cr check) */

struct tftphdr *
w_init(void)
{
	return (rw_init(0));	/* write-behind */
}

struct tftphdr *
r_init(void)
{
	return (rw_init(1));	/* read-ahead */
}

/*
 * Init for either read-ahead or write-behind.
 * Zero for write-behind, one for read-head.
 */
static struct tftphdr *
rw_init(int x)
{
	newline = 0;			/* init crlf flag */
	prevchar = -1;
	bfs[0].counter = BF_ALLOC;	/* pass out the first buffer */
	current = 0;
	bfs[1].counter = BF_FREE;
	nextone = x;			/* ahead or behind? */

	return ((struct tftphdr *)bfs[0].buf);
}

/*
 * Have emptied current buffer by sending to net and getting ack.
 * Free it and return next buffer filled with data.
 */
int
readit(FILE *file, struct tftphdr **dpp, int convert, int segment_size)
{
	struct bf	*b;

	bfs[current].counter = BF_FREE;		/* free old one */
	current = !current;			/* "incr" current */

	b = &bfs[current];			/* look at new buffer */
	if (b->counter == BF_FREE)		/* if it's empty */
		read_ahead(file, convert, segment_size);	/* fill it */
	/* assert(b->counter != BF_FREE); */	/* check */
	*dpp = (struct tftphdr *)b->buf;	/* set caller's ptr */

	return (b->counter);
}

/*
 * Fill the input buffer, doing ascii conversions if requested.
 * Conversions are lf -> cr, lf and cr -> cr, nul.
 */
void
read_ahead(FILE *file, int convert, int segment_size)
{
	int		 i;
	char		*p;
	int		 c;
	struct bf	*b;
	struct tftphdr	*dp;

	b = &bfs[nextone];			/* look at "next" buffer */
	if (b->counter != BF_FREE)		/* nop if not free */
		return;
	nextone = !nextone;			/* "incr" next buffer ptr */

	dp = (struct tftphdr *)b->buf;

	if (convert == 0) {
		b->counter = read(fileno(file), dp->th_data, segment_size);
		return;
	}

	p = dp->th_data;
	for (i = 0; i < segment_size; i++) {
		if (newline) {
			if (prevchar == '\n')
				c = '\n';	/* lf to cr, lf */
			else
				c = '\0';	/* cr to cr, nul */
			newline = 0;
		} else {
			c = getc(file);
			if (c == EOF)
				break;
			if (c == '\n' || c == '\r') {
				prevchar = c;
				c = '\r';
				newline = 1;
			}
		}
	       *p++ = c;
	}
	b->counter = (int)(p - dp->th_data);
}

/*
 * Update count associated with the buffer, get new buffer
 * from the queue.  Calls write_behind only if next buffer not
 * available.
 */
int
writeit(FILE *file, struct tftphdr **dpp, int ct, int convert)
{
	bfs[current].counter = ct;		/* set size of data to write */
	current = !current;			/* switch to other buffer */
	if (bfs[current].counter != BF_FREE)	/* if not free */
		/* flush it */
		(void)write_behind(file, convert);
	bfs[current].counter = BF_ALLOC;	/* mark as alloc'd */
	*dpp =  (struct tftphdr *)bfs[current].buf;

	return (ct);				/* this is a lie of course */
}

/*
 * Output a buffer to a file, converting from netascii if requested.
 * CR, NUL -> CR and CR, LF -> LF.
 * Note spec is undefined if we get CR as last byte of file or a
 * CR followed by anything else.  In this case we leave it alone.
 */
int
write_behind(FILE *file, int convert)
{
	char		*buf;
	int		 count;
	int		 ct;
	char		*p;
	int		 c; /* current character */
	struct bf	*b;
	struct tftphdr	*dp;

	b = &bfs[nextone];
	if (b->counter < -1)		/* anything to flush? */
		return (0);		/* just nop if nothing to do */

	count = b->counter;		/* remember byte count */
	b->counter = BF_FREE;		/* reset flag */
	dp = (struct tftphdr *)b->buf;
	nextone = !nextone;		/* incr for next time */
	buf = dp->th_data;

	if (count <= 0)			/* nak logic? */
		return (-1);

	if (convert == 0)
		return (write(fileno(file), buf, count));

	p = buf;
	ct = count;
	while (ct--) {				/* loop over the buffer */
		c = *p++;			/* pick up a character */
		if (prevchar == '\r') {		/* if prev char was cr */
			if (c == '\n')		/* if have cr,lf then just */
				/* smash lf on top of the cr */
				fseek(file, -1, SEEK_CUR);
			else if (c == '\0')	/* if have cr,nul then */
				goto skipit;	/* just skip over the putc */
			/* FALLTHROUGH */
		}
		putc(c, file);
skipit:
		prevchar = c;
	}

	return (count);
}

/*
 * When an error has occurred, it is possible that the two sides
 * are out of synch.  Ie: that what I think is the other side's
 * response to packet N is really their response to packet N-1.
 *
 * So, to try to prevent that, we flush all the input queued up
 * for us on the network connection on our host.
 *
 * We return the number of packets we flushed (mostly for reporting
 * when trace is active).
 */
int
synchnet(int f)
{
	int			i, j = 0;
	char			rbuf[SEGSIZE_MIN];
	struct sockaddr_storage	from;
	socklen_t		fromlen;

	for (;;) {
		(void)ioctl(f, FIONREAD, &i);
		if (i) {
			j++;
			fromlen = sizeof(from);
			(void)recvfrom(f, rbuf, sizeof(rbuf), 0,
			    (struct sockaddr *)&from, &fromlen);
		} else
			return (j);
	}
}
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpsubs.c,v 1.13 2007/09/10 14:29:53 tobias Exp $	*/
d261 1
a261 1
	struct sockaddr_in	from;
@


1.13
log
@Proper use of fseek/fseeko macros.

OK joris@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpsubs.c,v 1.12 2006/07/26 12:34:41 mglocker Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)tftpsubs.c	8.1 (Berkeley) 6/6/93";
#endif
static const char rcsid[] =
    "$OpenBSD: tftpsubs.c,v 1.12 2006/07/26 12:34:41 mglocker Exp $";
#endif /* not lint */
@


1.12
log
@Mini KNF.  No binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpsubs.c,v 1.11 2006/07/20 09:42:44 mglocker Exp $	*/
d38 1
a38 1
    "$OpenBSD: tftpsubs.c,v 1.11 2006/07/20 09:42:44 mglocker Exp $";
d240 1
a240 1
				fseek(file, -1, 1);
@


1.11
log
@Add blksize option support for tftpd according to RFC 2348.

Note:
While testing the new option, we noticed that our stable tftpd has
a problem if any option is set (e.g. tsize) and you try to put a file.
This has nothing todo with our new blksize option.  We fix this as
next.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpsubs.c,v 1.10 2006/07/12 16:58:51 mglocker Exp $	*/
d38 1
a38 1
    "$OpenBSD: tftpsubs.c,v 1.10 2006/07/12 16:58:51 mglocker Exp $";
d104 1
a104 1
	bfs[0].counter =  BF_ALLOC;	/* pass out the first buffer */
@


1.10
log
@knf.  no binary change.

ok beck@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpsubs.c,v 1.9 2003/09/24 20:21:40 deraadt Exp $	*/
d38 1
a38 1
    "$OpenBSD: tftpsubs.c,v 1.9 2003/09/24 20:21:40 deraadt Exp $";
a64 1
#define PKTSIZE		SEGSIZE + 4	/* should be moved to tftp.h */
d73 2
a74 2
	int	counter;	/* size of data in buffer, or flag */
	char	buf[PKTSIZE];	/* room for data packet */
d117 1
a117 1
readit(FILE *file, struct tftphdr **dpp, int convert)
d126 1
a126 1
		read_ahead(file, convert);	/* fill it */
d138 1
a138 1
read_ahead(FILE *file, int convert)
d154 1
a154 1
		b->counter = read(fileno(file), dp->th_data, SEGSIZE);
d159 1
a159 1
	for (i = 0; i < SEGSIZE; i++) {
d268 1
a268 1
	char			rbuf[PKTSIZE];
@


1.9
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpsubs.c,v 1.8 2003/06/26 07:59:49 deraadt Exp $	*/
d37 2
a38 1
static const char rcsid[] = "$OpenBSD: tftpsubs.c,v 1.8 2003/06/26 07:59:49 deraadt Exp $";
d41 10
a50 9
/* Simple minded read-ahead/write-behind subroutines for tftp user and
   server.  Written originally with multiple buffers in mind, but current
   implementation has two buffer logic wired in.

   Todo:  add some sort of final error check so when the write-buffer
   is finally flushed, the caller can detect if the disk filled up
   (or had an i/o error) and return a nak to the other side.

			Jim Guyton 10/85
d56 1
d65 7
a71 1
#define PKTSIZE SEGSIZE+4       /* should be moved to tftp.h */
d74 2
a75 2
	int counter;            /* size of data in buffer, or flag */
	char buf[PKTSIZE];      /* room for data packet */
d78 2
a79 8
				/* Values for bf.counter  */
#define BF_ALLOC -3             /* alloc'd but not yet filled */
#define BF_FREE  -2             /* free */
/* [-1 .. SEGSIZE] = size of data in the data buffer */

static int nextone;		/* index of next buffer to use */
static int current;		/* index of buffer in use */

d81 2
a82 4
int newline = 0;		/* fillbuf: in middle of newline expansion */
int prevchar = -1;		/* putbuf: previous char (cr check) */

static struct tftphdr *rw_init(int);
d87 1
a87 1
	return rw_init(0);	/* write-behind */
d93 1
a93 1
	return rw_init(1);	/* read-ahead */
d96 4
a99 2
/* init for either read-ahead or write-behind */
/* zero for write-behind, one for read-head */
d103 1
a103 1
	newline = 0;		/* init crlf flag */
d105 1
a105 1
	bfs[0].counter =  BF_ALLOC;     /* pass out the first buffer */
d108 3
a110 2
	nextone = x;                    /* ahead or behind? */
	return (struct tftphdr *)bfs[0].buf;
d113 3
a115 3

/* Have emptied current buffer by sending to net and getting ack.
   Free it and return next buffer filled with data.
d120 4
a123 1
	struct bf *b;
d125 5
a129 2
	bfs[current].counter = BF_FREE; /* free old one */
	current = !current;             /* "incr" current */
d131 1
a131 6
	b = &bfs[current];              /* look at new buffer */
	if (b->counter == BF_FREE)      /* if it's empty */
		read_ahead(file, convert);      /* fill it */
/*      assert(b->counter != BF_FREE);*//* check */
	*dpp = (struct tftphdr *)b->buf;        /* set caller's ptr */
	return b->counter;
d135 2
a136 2
 * fill the input buffer, doing ascii conversions if requested
 * conversions are  lf -> cr,lf  and cr -> cr, nul
d141 5
a145 5
	int i;
	char *p;
	int c;
	struct bf *b;
	struct tftphdr *dp;
d147 2
a148 2
	b = &bfs[nextone];              /* look at "next" buffer */
	if (b->counter != BF_FREE)      /* nop if not free */
d150 1
a150 1
	nextone = !nextone;             /* "incr" next buffer ptr */
d160 1
a160 1
	for (i = 0 ; i < SEGSIZE; i++) {
d163 1
a163 1
				c = '\n';       /* lf to cr,lf */
d165 1
a165 1
				c = '\0';       /* cr to cr,nul */
d169 2
a170 1
			if (c == EOF) break;
d182 4
a185 3
/* Update count associated with the buffer, get new buffer
   from the queue.  Calls write_behind only if next buffer not
   available.
d190 6
a195 5
	bfs[current].counter = ct;      /* set size of data to write */
	current = !current;             /* switch to other buffer */
	if (bfs[current].counter != BF_FREE)     /* if not free */
		(void)write_behind(file, convert); /* flush it */
	bfs[current].counter = BF_ALLOC;        /* mark as alloc'd */
d197 2
a198 1
	return ct;                      /* this is a lie of course */
d203 1
a203 1
 * CR,NUL -> CR  and CR,LF => LF.
d206 1
a206 1
n */
d210 7
a216 7
	char *buf;
	int count;
	int ct;
	char *p;
	int c;                          /* current character */
	struct bf *b;
	struct tftphdr *dp;
d219 2
a220 2
	if (b->counter < -1)            /* anything to flush? */
		return 0;               /* just nop if nothing to do */
d222 2
a223 2
	count = b->counter;             /* remember byte count */
	b->counter = BF_FREE;           /* reset flag */
d225 1
a225 1
	nextone = !nextone;             /* incr for next time */
d228 2
a229 1
	if (count <= 0) return -1;      /* nak logic? */
d232 1
a232 1
		return write(fileno(file), buf, count);
d236 9
a244 8
	while (ct--) {                  /* loop over the buffer */
		c = *p++;                   /* pick up a character */
		if (prevchar == '\r') {     /* if prev char was cr */
			if (c == '\n')          /* if have cr,lf then just */
				fseek(file, -1, 1);  /* smash lf on top of the cr */
			else if (c == '\0')       /* if have cr,nul then */
				goto skipit;    /* just skip over the putc */
			/* else just fall through and allow it */
d250 2
a251 1
	return count;
d254 2
a255 2

/* When an error has occurred, it is possible that the two sides
a264 1

d268 4
a271 4
	int i, j = 0;
	char rbuf[PKTSIZE];
	struct sockaddr_in from;
	socklen_t fromlen;
d273 2
a274 2
	while (1) {
		(void) ioctl(f, FIONREAD, &i);
d277 2
a278 2
			fromlen = sizeof from;
			(void) recvfrom(f, rbuf, sizeof (rbuf), 0,
d280 2
a281 3
		} else {
			return(j);
		}
@


1.8
log
@another proto repair
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpsubs.c,v 1.7 2003/06/25 15:45:10 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tftpsubs.c,v 1.7 2003/06/25 15:45:10 deraadt Exp $";
d159 2
a160 1
			else    c = '\0';       /* cr to cr,nul */
d162 1
a162 2
		}
		else {
d197 1
a197 1
 */
d227 9
a235 10
	    c = *p++;                   /* pick up a character */
	    if (prevchar == '\r') {     /* if prev char was cr */
		if (c == '\n')          /* if have cr,lf then just */
		   fseek(file, -1, 1);  /* smash lf on top of the cr */
		else
		   if (c == '\0')       /* if have cr,nul then */
			goto skipit;    /* just skip over the putc */
		/* else just fall through and allow it */
	    }
	    putc(c, file);
d237 1
a237 1
	    prevchar = c;
d268 1
a268 1
				(struct sockaddr *)&from, &fromlen);
@


1.7
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpsubs.c,v 1.6 2003/06/03 02:56:18 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tftpsubs.c,v 1.6 2003/06/03 02:56:18 millert Exp $";
d81 1
a81 1
static struct tftphdr *rw_init();
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpsubs.c,v 1.5 2003/04/17 17:17:27 henning Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tftpsubs.c,v 1.5 2003/04/17 17:17:27 henning Exp $";
d83 11
a93 2
struct tftphdr *w_init() { return rw_init(0); }         /* write-behind */
struct tftphdr *r_init() { return rw_init(1); }         /* read-ahead */
d95 2
d98 1
a98 2
rw_init(x)			/* init for either read-ahead or write-behind */
	int x;			/* zero for write-behind, one for read-head */
d114 1
a114 4
readit(file, dpp, convert)
	FILE *file;                     /* file opened for read */
	struct tftphdr **dpp;
	int convert;                    /* if true, convert to ascii */
d134 1
a134 3
read_ahead(file, convert)
	FILE *file;                     /* file opened for read */
	int convert;                    /* if true, convert to ascii */
d181 1
a181 4
writeit(file, dpp, ct, convert)
	FILE *file;
	struct tftphdr **dpp;
	int ct, convert;
d199 1
a199 3
write_behind(file, convert)
	FILE *file;
	int convert;
d256 1
a256 2
synchnet(f)
	int	f;		/* socket to flush */
@


1.5
log
@nuke strcpy + -Wall

parts from and ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpsubs.c,v 1.4 2002/09/06 18:55:04 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: tftpsubs.c,v 1.4 2002/09/06 18:55:04 deraadt Exp $";
@


1.4
log
@use socklen_t where needed
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpsubs.c,v 1.3 2001/11/19 19:02:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tftpsubs.c,v 1.3 2001/11/19 19:02:16 mpech Exp $";
@


1.3
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpsubs.c,v 1.2 1996/06/26 05:40:36 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tftpsubs.c,v 1.2 1996/06/26 05:40:36 deraadt Exp $";
d266 1
a266 1
	int fromlen;
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpsubs.c,v 1.3 1994/12/08 09:51:31 jtc Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: tftpsubs.c,v 1.3 1994/12/08 09:51:31 jtc Exp $";
d135 3
a137 3
	register int i;
	register char *p;
	register int c;
d207 3
a209 3
	register int ct;
	register char *p;
	register int c;                 /* current character */
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: tftpsubs.c,v 1.3 1994/12/08 09:51:31 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
