head	1.57;
access;
symbols
	OPENBSD_6_1:1.56.0.4
	OPENBSD_6_1_BASE:1.56
	OPENBSD_6_0:1.55.0.2
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.48.0.4
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.42.0.6
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.4
	OPENBSD_5_0:1.42.0.2
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.39.0.4
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.2
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.36.0.8
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.36.0.10
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.6
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.4
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.34.0.4
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17;
locks; strict;
comment	@ * @;


1.57
date	2017.04.03.16.18.35;	author tedu;	state Exp;
branches;
next	1.56;
commitid	nyYm4bITVGETnWgS;

1.56
date	2016.08.25.15.11.05;	author tedu;	state Exp;
branches;
next	1.55;
commitid	rTjdngc7qP99nkUk;

1.55
date	2016.04.04.05.49.47;	author otto;	state Exp;
branches;
next	1.54;
commitid	tQyeRoThHvdSlWLZ;

1.54
date	2015.12.22.19.35.50;	author mmcc;	state Exp;
branches;
next	1.53;
commitid	GoKIBkaODjIVdIBB;

1.53
date	2015.12.22.17.07.06;	author millert;	state Exp;
branches;
next	1.52;
commitid	MlGs76lopDncNksC;

1.52
date	2015.12.14.20.02.07;	author mmcc;	state Exp;
branches;
next	1.51;
commitid	knZg7AThw4F5hT9N;

1.51
date	2015.12.07.18.50.06;	author mmcc;	state Exp;
branches;
next	1.50;
commitid	vDhClsSElrQbmYvf;

1.50
date	2015.06.25.02.04.08;	author uebayasi;	state Exp;
branches;
next	1.49;
commitid	lJr85pywqGCq0vnE;

1.49
date	2014.12.01.06.36.04;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	1N4D8AaCy2x3MRHz;

1.48
date	2014.05.20.01.25.23;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2013.11.26.13.21.16;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2013.05.04.00.26.20;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2012.12.29.01.32.44;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2012.12.12.11.12.24;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2012.12.11.16.40.01;	author otto;	state Exp;
branches;
next	1.42;

1.42
date	2011.07.17.19.39.21;	author aschrijver;	state Exp;
branches;
next	1.41;

1.41
date	2011.07.11.20.43.21;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.08.01.20.24;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2010.07.02.22.18.03;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.25.14.13.36;	author eric;	state Exp;
branches;
next	1.37;

1.37
date	2010.04.05.03.03.55;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.02.17.59.18;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.02.15.19.32;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2006.12.26.20.59.23;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.17.02.01.29;	author jaredy;	state Exp;
branches;
next	1.32;

1.32
date	2006.09.26.15.55.17;	author jaredy;	state Exp;
branches;
next	1.31;

1.31
date	2006.02.09.09.54.47;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.03.19.12.40;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2004.10.03.19.23.02;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2004.09.16.00.20.32;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2004.08.11.13.18.58;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.07.19.06.59;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.07.14.51.42;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.04.18.38.52;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.26.14.50.29;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.25.21.36.00;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.19.16.12.04;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.18.19.01.55;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.06.20.14.40;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.28.13.23.59;	author avsm;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.20.22.16.52;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.20.19.19.48;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.10.19.16.22;	author dhartmei;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.10.17.02.48;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.06.19.16.45;	author avsm;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.01.00.09.23;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.25.17.28.00;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.25.05.31.11;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.24.22.36.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.24.18.45.30;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.24.17.32.10;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.23.22.05.23;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.23.07.52.18;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.23.00.55.09;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.22.22.38.50;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.22.22.24.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.22.22.20.07;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.57
log
@initialize regmatch_t always, fixes grep -o ""
from Michael Santos
@
text
@/*	$OpenBSD: util.c,v 1.56 2016/08/25 15:11:05 tedu Exp $	*/

/*-
 * Copyright (c) 1999 James Howard and Dag-Erling Coïdan Smørgrav
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fts.h>
#include <regex.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <zlib.h>

#include "grep.h"

/*
 * Process a file line by line...
 */

static int	linesqueued;
static int	procline(str_t *l, int);
static int	grep_search(fastgrep_t *, char *, size_t, regmatch_t *pmatch, int);
#ifndef SMALL
static bool	grep_cmp(const char *, const char *, size_t);
static void	grep_revstr(unsigned char *, int);
#endif

int
grep_tree(char **argv)
{
	FTS	*fts;
	FTSENT	*p;
	int	c, fts_flags;

	c = 0;

	fts_flags = FTS_PHYSICAL | FTS_NOSTAT | FTS_NOCHDIR;

	if (!(fts = fts_open(argv, fts_flags, NULL)))
		err(2, NULL);
	while ((p = fts_read(fts)) != NULL) {
		switch (p->fts_info) {
		case FTS_DNR:
			break;
		case FTS_ERR:
			file_err = 1;
			if(!sflag)
				warnc(p->fts_errno, "%s", p->fts_path);
			break;
		case FTS_DP:
			break;
		default:
			c += procfile(p->fts_path);
			break;
		}
	}
	if (errno)
		err(2, "fts_read");
	fts_close(fts);
	return c;
}

int
procfile(char *fn)
{
	str_t ln;
	file_t *f;
	int c, t, z, nottext;

	if (fn == NULL) {
		fn = "(standard input)";
		f = grep_fdopen(STDIN_FILENO, "r");
	} else {
		f = grep_open(fn, "r");
	}
	if (f == NULL) {
		file_err = 1;
		if (!sflag)
			warn("%s", fn);
		return 0;
	}

	nottext = grep_bin_file(f);
	if (nottext && binbehave == BIN_FILE_SKIP) {
		grep_close(f);
		return 0;
	}

	ln.file = fn;
	ln.line_no = 0;
	ln.len = 0;
	linesqueued = 0;
	tail = 0;
	ln.off = -1;

	if (Bflag > 0)
		initqueue();
	for (c = 0;  c == 0 || !(lflag || qflag); ) {
		ln.off += ln.len + 1;
		if ((ln.dat = grep_fgetln(f, &ln.len)) == NULL)
			break;
		if (ln.len > 0 && ln.dat[ln.len - 1] == '\n')
			--ln.len;
		ln.line_no++;

		z = tail;

		if ((t = procline(&ln, nottext)) == 0 && Bflag > 0 && z == 0) {
			enqueue(&ln);
			linesqueued++;
		}
		c += t;
	}
	if (Bflag > 0)
		clearqueue();
	grep_close(f);

	if (cflag) {
		if (!hflag)
			printf("%s:", ln.file);
		printf("%u\n", c);
	}
	if (lflag && c != 0)
		printf("%s\n", fn);
	if (Lflag && c == 0)
		printf("%s\n", fn);
	if (c && !cflag && !lflag && !Lflag &&
	    binbehave == BIN_FILE_BIN && nottext && !qflag)
		printf("Binary file %s matches\n", fn);

	return c;
}


/*
 * Process an individual line in a file. Return non-zero if it matches.
 */

#define isword(x) (isalnum((unsigned char)x) || (x) == '_')

static int
procline(str_t *l, int nottext)
{
	regmatch_t	pmatch = { 0 };
	int		c, i, r;
	regoff_t	offset;

	/* size_t will be converted to regoff_t. ssize_t is guaranteed to fit
	 * into regoff_t */
	if (l->len > SSIZE_MAX) {
		errx(2, "Line is too big to process");
	}

	c = 0;
	i = 0;
	if (matchall) {
		c = 1;
		goto print;
	}

	for (i = 0; i < patterns; i++) {
		offset = 0;
redo:
		if (fg_pattern[i].pattern) {
			int flags = 0;
			if (offset)
				flags |= REG_NOTBOL;
			r = grep_search(&fg_pattern[i], l->dat + offset,
			    l->len - offset, &pmatch, flags);
			pmatch.rm_so += offset;
			pmatch.rm_eo += offset;
		} else {
			int flags = eflags;
			if (offset)
				flags |= REG_NOTBOL;
			pmatch.rm_so = offset;
			pmatch.rm_eo = l->len;
			r = regexec(&r_pattern[i], l->dat, 1, &pmatch, flags);
		}
		if (r == 0 && xflag) {
			if (pmatch.rm_so != 0 || pmatch.rm_eo != l->len)
				r = REG_NOMATCH;
		}
		if (r == 0) {
			c = 1;
			if (oflag && pmatch.rm_so != pmatch.rm_eo)
				goto print;
			break;
		}
	}
	if (oflag)
		return c;
print:
	if (vflag)
		c = !c;

	if (c && binbehave == BIN_FILE_BIN && nottext)
		return c; /* Binary file */

	if ((tail > 0 || c) && !cflag && !qflag) {
		if (c) {
			if (first > 0 && tail == 0 && (Bflag < linesqueued) &&
			    (Aflag || Bflag))
				printf("--\n");
			first = 1;
			tail = Aflag;
			if (Bflag > 0)
				printqueue();
			linesqueued = 0;
			printline(l, ':', oflag ? &pmatch : NULL);
		} else {
			printline(l, '-', oflag ? &pmatch : NULL);
			tail--;
		}
	}
	if (oflag && !matchall) {
		offset = pmatch.rm_eo;
		goto redo;
	}
	return c;
}

#ifndef SMALL
void
fgrepcomp(fastgrep_t *fg, const unsigned char *pattern)
{
	int i;

	/* Initialize. */
	fg->patternLen = strlen(pattern);
	fg->bol = 0;
	fg->eol = 0;
	fg->wmatch = wflag;
	fg->reversedSearch = 0;

	/*
	 * Make a copy and upper case it for later if in -i mode,
	 * else just copy the pointer.
	 */
	if (iflag) {
		fg->pattern = grep_malloc(fg->patternLen + 1);
		for (i = 0; i < fg->patternLen; i++)
			fg->pattern[i] = toupper(pattern[i]);
		fg->pattern[fg->patternLen] = '\0';
	} else
		fg->pattern = (unsigned char *)pattern;	/* really const */

	/* Preprocess pattern. */
	for (i = 0; i <= UCHAR_MAX; i++)
		fg->qsBc[i] = fg->patternLen;
	for (i = 1; i < fg->patternLen; i++) {
		fg->qsBc[fg->pattern[i]] = fg->patternLen - i;
		/*
		 * If case is ignored, make the jump apply to both upper and
		 * lower cased characters.  As the pattern is stored in upper
		 * case, apply the same to the lower case equivalents.
		 */
		if (iflag)
			fg->qsBc[tolower(fg->pattern[i])] = fg->patternLen - i;
	}
}
#endif

/*
 * Returns: -1 on failure, 0 on success
 */
int
fastcomp(fastgrep_t *fg, const char *pattern)
{
#ifdef SMALL
	return -1;
#else
	int i;
	int bol = 0;
	int eol = 0;
	int shiftPatternLen;
	int hasDot = 0;
	int firstHalfDot = -1;
	int firstLastHalfDot = -1;
	int lastHalfDot = 0;

	/* Initialize. */
	fg->patternLen = strlen(pattern);
	fg->bol = 0;
	fg->eol = 0;
	fg->wmatch = 0;
	fg->reversedSearch = 0;

	/* Remove end-of-line character ('$'). */
	if (fg->patternLen > 0 && pattern[fg->patternLen - 1] == '$') {
		eol++;
		fg->eol = 1;
		fg->patternLen--;
	}

	/* Remove beginning-of-line character ('^'). */
	if (pattern[0] == '^') {
		bol++;
		fg->bol = 1;
		fg->patternLen--;
	}

	/* Remove enclosing [[:<:]] and [[:>:]] (word match). */
	if (wflag) {
		/* basic re's use \( \), extended re's ( ) */
		int extra = Eflag ? 1 : 2;
		fg->patternLen -= 14 + 2 * extra;
		fg->wmatch = 7 + extra;
	} else if (fg->patternLen >= 14 &&
	    strncmp(pattern + fg->bol, "[[:<:]]", 7) == 0 &&
	    strncmp(pattern + fg->bol + fg->patternLen - 7, "[[:>:]]", 7) == 0) {
		fg->patternLen -= 14;
		fg->wmatch = 7;
	}

	/*
	 * Copy pattern minus '^' and '$' characters as well as word
	 * match character classes at the beginning and ending of the
	 * string respectively.
	 */
	fg->pattern = grep_malloc(fg->patternLen + 1);
	memcpy(fg->pattern, pattern + bol + fg->wmatch, fg->patternLen);
	fg->pattern[fg->patternLen] = '\0';

	/* Look for ways to cheat...er...avoid the full regex engine. */
	for (i = 0; i < fg->patternLen; i++)
	{
		switch (fg->pattern[i]) {
		case '.':
			hasDot = i;
			if (i < fg->patternLen / 2) {
				if (firstHalfDot < 0)
					/* Closest dot to the beginning */
					firstHalfDot = i;
			} else {
				/* Closest dot to the end of the pattern. */
				lastHalfDot = i;
				if (firstLastHalfDot < 0)
					firstLastHalfDot = i;
			}
			break;
		case '(': case ')':
		case '{': case '}':
			/* Special in BRE if preceded by '\\' */
		case '?':
		case '+':
		case '|':
			/* Not special in BRE. */
			if (!Eflag)
				goto nonspecial;
		case '\\':
		case '*':
		case '[': case ']':
			/* Free memory and let others know this is empty. */
			free(fg->pattern);
			fg->pattern = NULL;
			return (-1);
		default:
nonspecial:
			if (iflag)
				fg->pattern[i] = toupper(fg->pattern[i]);
			break;
		}
	}

	/*
	 * Determine if a reverse search would be faster based on the placement
	 * of the dots.
	 */
	if ((!(lflag || cflag || oflag)) && ((!(bol || eol)) &&
	    ((lastHalfDot) && ((firstHalfDot < 0) ||
	    ((fg->patternLen - (lastHalfDot + 1)) < firstHalfDot))))) {
		fg->reversedSearch = 1;
		hasDot = fg->patternLen - (firstHalfDot < 0 ?
		    firstLastHalfDot : firstHalfDot) - 1;
		grep_revstr(fg->pattern, fg->patternLen);
	}

	/*
	 * Normal Quick Search would require a shift based on the position the
	 * next character after the comparison is within the pattern.  With
	 * wildcards, the position of the last dot effects the maximum shift
	 * distance.
	 * The closer to the end the wild card is the slower the search.  A
	 * reverse version of this algorithm would be useful for wildcards near
	 * the end of the string.
	 *
	 * Examples:
	 * Pattern	Max shift
	 * -------	---------
	 * this		5
	 * .his		4
	 * t.is		3
	 * th.s		2
	 * thi.		1
	 */

	/* Adjust the shift based on location of the last dot ('.'). */
	shiftPatternLen = fg->patternLen - hasDot;

	/* Preprocess pattern. */
	for (i = 0; i <= UCHAR_MAX; i++)
		fg->qsBc[i] = shiftPatternLen;
	for (i = hasDot + 1; i < fg->patternLen; i++) {
		fg->qsBc[fg->pattern[i]] = fg->patternLen - i;
		/*
		 * If case is ignored, make the jump apply to both upper and
		 * lower cased characters.  As the pattern is stored in upper
		 * case, apply the same to the lower case equivalents.
		 */
		if (iflag)
			fg->qsBc[tolower(fg->pattern[i])] = fg->patternLen - i;
	}

	/*
	 * Put pattern back to normal after pre-processing to allow for easy
	 * comparisons later.
	 */
	if (fg->reversedSearch)
		grep_revstr(fg->pattern, fg->patternLen);

	return (0);
#endif
}

/*
 * Word boundaries using regular expressions are defined as the point
 * of transition from a non-word char to a word char, or vice versa.
 * This means that grep -w +a and grep -w a+ never match anything,
 * because they lack a starting or ending transition, but grep -w a+b
 * does match a line containing a+b.
 */
#define wmatch(d, l, s, e)	\
	((s == 0 || !isword(d[s-1])) && (e == l || !isword(d[e])) && \
	  e > s && isword(d[s]) && isword(d[e-1]))

static int
grep_search(fastgrep_t *fg, char *data, size_t dataLen, regmatch_t *pmatch,
    int flags)
{
#ifdef SMALL
	return 0;
#else
	regoff_t j;
	int rtrnVal = REG_NOMATCH;

	pmatch->rm_so = -1;
	pmatch->rm_eo = -1;

	/* No point in going farther if we do not have enough data. */
	if (dataLen < fg->patternLen)
		return (rtrnVal);

	/* Only try once at the beginning or ending of the line. */
	if (fg->bol || fg->eol) {
		if (fg->bol && (flags & REG_NOTBOL))
			return 0;
		/* Simple text comparison. */
		/* Verify data is >= pattern length before searching on it. */
		if (dataLen >= fg->patternLen) {
			/* Determine where in data to start search at. */
			if (fg->eol)
				j = dataLen - fg->patternLen;
			else
				j = 0;
			if (!((fg->bol && fg->eol) && (dataLen != fg->patternLen)))
				if (grep_cmp(fg->pattern, data + j,
				    fg->patternLen)) {
					pmatch->rm_so = j;
					pmatch->rm_eo = j + fg->patternLen;
					if (!fg->wmatch || wmatch(data, dataLen,
					    pmatch->rm_so, pmatch->rm_eo))
						rtrnVal = 0;
				}
		}
	} else if (fg->reversedSearch) {
		/* Quick Search algorithm. */
		j = dataLen;
		do {
			if (grep_cmp(fg->pattern, data + j - fg->patternLen,
			    fg->patternLen)) {
				pmatch->rm_so = j - fg->patternLen;
				pmatch->rm_eo = j;
				if (!fg->wmatch || wmatch(data, dataLen,
				    pmatch->rm_so, pmatch->rm_eo)) {
					rtrnVal = 0;
					break;
				}
			}
			/* Shift if within bounds, otherwise, we are done. */
			if (j == fg->patternLen)
				break;
			j -= fg->qsBc[(unsigned char)data[j - fg->patternLen - 1]];
		} while (j >= fg->patternLen);
	} else {
		/* Quick Search algorithm. */
		j = 0;
		do {
			if (grep_cmp(fg->pattern, data + j, fg->patternLen)) {
				pmatch->rm_so = j;
				pmatch->rm_eo = j + fg->patternLen;
				if (fg->patternLen == 0 || !fg->wmatch ||
				    wmatch(data, dataLen, pmatch->rm_so,
				    pmatch->rm_eo)) {
					rtrnVal = 0;
					break;
				}
			}

			/* Shift if within bounds, otherwise, we are done. */
			if (j + fg->patternLen == dataLen)
				break;
			else
				j += fg->qsBc[(unsigned char)data[j + fg->patternLen]];
		} while (j <= (dataLen - fg->patternLen));
	}

	return (rtrnVal);
#endif
}


void *
grep_malloc(size_t size)
{
	void	*ptr;

	if ((ptr = malloc(size)) == NULL)
		err(2, "malloc");
	return ptr;
}

void *
grep_calloc(size_t nmemb, size_t size)
{
	void	*ptr;

	if ((ptr = calloc(nmemb, size)) == NULL)
		err(2, "calloc");
	return ptr;
}

void *
grep_realloc(void *ptr, size_t size)
{
	if ((ptr = realloc(ptr, size)) == NULL)
		err(2, "realloc");
	return ptr;
}

void *
grep_reallocarray(void *ptr, size_t nmemb, size_t size)
{
	if ((ptr = reallocarray(ptr, nmemb, size)) == NULL)
		err(2, "reallocarray");
	return ptr;
}

#ifndef SMALL
/*
 * Returns:	true on success, false on failure
 */
static bool
grep_cmp(const char *pattern, const char *data, size_t len)
{
	size_t i;

	for (i = 0; i < len; i++) {
		if (((pattern[i] == data[i]) || (!Fflag && pattern[i] == '.'))
		    || (iflag && pattern[i] == toupper((unsigned char)data[i])))
			continue;
		return false;
	}

	return true;
}

static void
grep_revstr(unsigned char *str, int len)
{
	int i;
	char c;

	for (i = 0; i < len / 2; i++) {
		c = str[i];
		str[i] = str[len - i - 1];
		str[len - i - 1] = c;
	}
}
#endif

void
printline(str_t *line, int sep, regmatch_t *pmatch)
{
	int n;

	n = 0;
	if (!hflag) {
		fputs(line->file, stdout);
		++n;
	}
	if (nflag) {
		if (n)
			putchar(sep);
		printf("%lld", line->line_no);
		++n;
	}
	if (bflag) {
		if (n)
			putchar(sep);
		printf("%lld", (long long)line->off);
		++n;
	}
	if (n)
		putchar(sep);
	if (pmatch)
		fwrite(line->dat + pmatch->rm_so,
		    pmatch->rm_eo - pmatch->rm_so, 1, stdout);
	else
		fwrite(line->dat, line->len, 1, stdout);
	putchar('\n');
}
@


1.56
log
@when using -o, we may restart a match in the middle of the line.
set NOTBOL so that anchored patterns don't match.
from a patch by DaniÃ«l de Kok in freebsd bug 201650
ok martijn
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.55 2016/04/04 05:49:47 otto Exp $	*/
d174 1
a174 1
	regmatch_t	pmatch;
@


1.55
log
@Reverse search optimization makes no sense (and doesn't work) if
we are looking for all matches in a line; ok natano@@ miilert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.54 2015/12/22 19:35:50 mmcc Exp $	*/
d52 1
a52 1
static int	grep_search(fastgrep_t *, char *, size_t, regmatch_t *pmatch);
d195 3
d199 1
a199 1
			    l->len - offset, &pmatch);
d203 3
d208 1
a208 1
			r = regexec(&r_pattern[i], l->dat, 1, &pmatch, eflags);
d468 2
a469 1
grep_search(fastgrep_t *fg, char *data, size_t dataLen, regmatch_t *pmatch)
d486 2
@


1.54
log
@cast toupper's argument to unsigned char

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.53 2015/12/22 17:07:06 millert Exp $	*/
d394 1
a394 1
	if ((!(lflag || cflag)) && ((!(bol || eol)) &&
@


1.53
log
@The loop index in grep_cmp() should be size_t to match the type of
the length parameter.  The return value of grep_cmp() is only used
in a boolean context so make it return bool instead of the index.
OK mmcc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.52 2015/12/14 20:02:07 mmcc Exp $	*/
d591 1
a591 1
		    || (iflag && pattern[i] == toupper(data[i])))
@


1.52
log
@Use long long rather than off_t for line_no to ensure that it's always
64 bits.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.51 2015/12/07 18:50:06 mmcc Exp $	*/
d37 1
d54 1
a54 1
static int	grep_cmp(const char *, const char *, size_t);
d489 1
a489 1
				    fg->patternLen) == -1) {
d502 1
a502 1
			    fg->patternLen) == -1) {
d520 1
a520 1
			if (grep_cmp(fg->pattern, data + j, fg->patternLen) == -1) {
d582 1
a582 2
 * Returns:	i >= 0 on failure (position that it failed)
 *		-1 on success
d584 1
a584 1
static int
d587 1
a587 1
	int i;
d593 1
a593 1
		return (i);
d596 1
a596 1
	return (-1);
@


1.51
log
@Represent line numbers with off_t rather than int. This prevents
overflow on huge inputs. ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.50 2015/06/25 02:04:08 uebayasi Exp $	*/
d626 1
a626 1
		printf("%lld", (long long)line->line_no);
@


1.50
log
@Put fts_close() where missing.

Not bugs in short-lived commands that call exit() -> _exit() immediately,
but for idempotency.

Originally found in ls(1) by Valgrind.  Changes for other commands are
from deraadt@@.  Reviewed by me, tested in snapshots.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d626 1
a626 1
		printf("%d", line->line_no);
@


1.49
log
@use reallocarray()
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.48 2014/05/20 01:25:23 guenther Exp $	*/
d88 1
a88 1

@


1.48
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.47 2013/11/26 13:21:16 deraadt Exp $	*/
d568 8
@


1.47
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.46 2013/05/04 00:26:20 tedu Exp $	*/
d77 1
a77 1
				warnx("%s: %s", p->fts_path, strerror(p->fts_errno));
@


1.46
log
@blacklist a select few characters instead of a limited whitelist for
detecting non-regex patterns. makes the fast grep code more applicable.
with some improvements by Jeremie Courreges-Anglas
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.45 2012/12/29 01:32:44 millert Exp $	*/
d168 1
a168 1
#define isword(x) (isalnum(x) || (x) == '_')
d248 1
a248 1
fgrepcomp(fastgrep_t *fg, const char *pattern)
@


1.45
log
@Fix exit status when there is an error reading a file.
Reported by Jeramey Crawford, fix adapted from FreeBSD.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.44 2012/12/12 11:12:24 millert Exp $	*/
d351 2
a352 9
		/* Can still cheat? */
		if ((isalnum(fg->pattern[i])) || isspace(fg->pattern[i]) ||
		    (fg->pattern[i] == '_') || (fg->pattern[i] == ',') ||
		    (fg->pattern[i] == '=') || (fg->pattern[i] == '-') ||
		    (fg->pattern[i] == ':') || (fg->pattern[i] == '/')) {
			/* As long as it is good, upper case it for later. */
			if (iflag)
				fg->pattern[i] = toupper(fg->pattern[i]);
		} else if (fg->pattern[i] == '.') {
d364 13
a376 1
		} else {
d381 5
@


1.44
log
@Don't print zero length matches in -o mode.  Found by otto@@ who
initially proposed a different fix.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.43 2012/12/11 16:40:01 otto Exp $	*/
d75 3
a77 1
			errx(2, "%s: %s", p->fts_path, strerror(p->fts_errno));
d106 1
@


1.43
log
@use proper eol offset for -o matching; spotted by ajacoutot@@; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.42 2011/07/17 19:39:21 aschrijver Exp $	*/
d206 1
a206 1
			if (oflag)
@


1.42
log
@Fix an integer overflow for very long lines by replacing the datatype of 2 offsets from int to regoff_t.

Bail if the given size_t line length doesn't fit into the new regoff_t.

"I don't think you will ever be able to get a string longer than
SSIZE_MAX into memory, but that looks good." tedu@@

"Agreed" otto@@

regoff_t suggested by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.41 2011/07/11 20:43:21 tedu Exp $	*/
d197 1
a197 1
			pmatch.rm_eo = l->len - offset;
@


1.41
log
@the matchall magic shortcut requires we set c=1 to print now
fixes libpqxx build
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.40 2011/07/08 01:20:24 tedu Exp $	*/
d172 7
a178 1
	int		offset;
d453 1
a453 1
	int j;
@


1.40
log
@add support for -o to only print the match.
reminded this was useful by ajcoutot
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.39 2010/07/02 22:18:03 tedu Exp $	*/
d177 1
@


1.39
log
@Remove the "fast" grep code if SMALL.  This has the side effect of breaking
fgrep -w, but oh well.  ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.38 2010/04/25 14:13:36 eric Exp $	*/
d51 1
a51 1
static int	grep_search(fastgrep_t *, unsigned char *, size_t, regmatch_t *pmatch);
d53 1
a53 1
static int	grep_cmp(const unsigned char *, const unsigned char *, size_t);
d172 1
d174 2
a176 1
		c = !vflag;
d180 3
a182 1
	for (c = i = 0; i < patterns; i++) {
d184 4
a187 2
			r = grep_search(&fg_pattern[i], (unsigned char *)l->dat,
			    l->len, &pmatch);
d189 2
a190 2
			pmatch.rm_so = 0;
			pmatch.rm_eo = l->len;
d198 3
a200 1
			c++;
d204 3
a209 1
print:
d223 1
a223 1
			printline(l, ':');
d225 1
a225 1
			printline(l, '-');
d229 4
d441 1
a441 1
grep_search(fastgrep_t *fg, unsigned char *data, size_t dataLen, regmatch_t *pmatch)
d493 1
a493 1
			j -= fg->qsBc[data[j - fg->patternLen - 1]];
d514 1
a514 1
				j += fg->qsBc[data[j + fg->patternLen]];
d557 1
a557 1
grep_cmp(const unsigned char *pattern, const unsigned char *data, size_t len)
d586 1
a586 1
printline(str_t *line, int sep)
d609 5
a613 1
	fwrite(line->dat, line->len, 1, stdout);
@


1.38
log
@prevent out-of-bounds access with empty pattern (fixes  "grep -x ''")

ok millert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.37 2010/04/05 03:03:55 tedu Exp $	*/
d52 1
d55 1
d222 1
d261 1
d269 3
d412 1
d429 3
d505 1
d537 1
d569 1
@


1.37
log
@remove some non-POSIX standard non-GNU defacto standard options, mostly
relating to symlinks that you can get with find.  And a bonus fts flag fix.
With a small tweak by guenther.  ok deraadt guenther jmc millert nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.36 2007/10/02 17:59:18 otto Exp $	*/
d282 1
a282 1
	if (pattern[fg->patternLen - 1] == '$') {
@


1.36
log
@Process patterns containing $ end ^ (but not as last or first char)
using regcomp() instead of fastcomp(). ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.35 2007/09/02 15:19:32 deraadt Exp $	*/
d62 1
a62 1
	c = fts_flags = 0;
d64 1
a64 8
	if (Hflag)
		fts_flags = FTS_COMFOLLOW;
	if (Pflag)
		fts_flags = FTS_PHYSICAL;
	if (Sflag)
		fts_flags = FTS_LOGICAL;

	fts_flags |= FTS_NOSTAT | FTS_NOCHDIR;
@


1.35
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.34 2006/12/26 20:59:23 otto Exp $	*/
a329 1
		    (fg->pattern[i] == '^') || (fg->pattern[i] == '$') ||
@


1.34
log
@fts_read returning NULL and errno set is an error. ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.33 2006/11/17 02:01:29 jaredy Exp $	*/
d512 10
@


1.33
log
@Reset the number of lines of tail context left to print
before processing each file to avoid printing lines
intended from the previous file.

Reported and fix by Charles Longeau <chl@@tuxfamily.org>
via tech@@.

ok otto millert
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.32 2006/09/26 15:55:17 jaredy Exp $	*/
d89 2
@


1.32
log
@Allow zero-length patterns with -x so

  $ grep -x ""

matches empty lines as reported on misc@@ by
Martin Marusak <marusak@@fhpv.unipo.sk>.
Initial diff by otto@@ with tweaks by me.

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.31 2006/02/09 09:54:47 otto Exp $	*/
d122 1
@


1.31
log
@delint; remove redundant vars and functions; ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.30 2005/04/03 19:12:40 otto Exp $	*/
d482 3
a484 2
				if (!fg->wmatch || wmatch(data, dataLen,
				    pmatch->rm_so, pmatch->rm_eo)) {
@


1.30
log
@Protect begin and end of word markers added to the pattern when
using the -w option with parentheses, to avoid operators in the
expressions binding to the markers. Compare [[:<:]]foo|bar[[:>:]]
and [[:<:]](foo|bar)[[:>:]]. Problem spotted by aaron@@; ok millert@@
aaron@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.29 2004/10/03 19:23:02 otto Exp $	*/
d224 1
a224 4
/*
 * Returns: -1 on failure, 0 on success
 */
int
a260 2

	return (0);
@


1.29
log
@Remove block based mmap optimization. There are newline problems
(PR 3940, 3941) which can be fixed, but if a match starts at the
end of a block and continues into the next block, no match will be
found.  Measurements by millert@@ showed that the improvements of
this optimization are non-measurable anyway. Diff from Alexander Taler.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.28 2004/09/16 00:20:32 deraadt Exp $	*/
d305 6
a310 1
	if (fg->patternLen >= 14 &&
@


1.28
log
@unused variables; otto ok
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.27 2004/08/11 13:18:58 otto Exp $	*/
a294 1
		boleol = 1;
a301 1
		boleol = 1;
@


1.27
log
@Stop search when -q option is given and a match is found. Found by jmc@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.26 2004/05/07 19:06:59 otto Exp $	*/
d249 1
a249 1
		fg->pattern = (char *)pattern;	/* really const */
a276 1
	int origPatternLen;
d284 1
a284 1
	origPatternLen = fg->patternLen = strlen(pattern);
@


1.26
log
@Make grep -w behave the same for the fastcomp and the regex case,
by teaching fastcomp what word boundaries are according to regex.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.25 2004/05/07 14:51:42 millert Exp $	*/
d126 1
a126 1
	for (c = 0; !(lflag && c);) {
@


1.25
log
@Add a new past path for fgrep that is just a simplified version of
fastcomp.  This makes fgrep faster and fixes the -w flag w/ fgrep.
Also remove free_patterns() since calling free right before exit
is silly.  Problem noticed by espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.24 2004/02/04 18:38:52 millert Exp $	*/
d415 7
d423 2
a424 1
	((s == 0 || !isword(d[s-1])) && (e == l || !isword(d[e])))
@


1.24
log
@Fix anchors (^ or $) in -w mode broken by the last commit's -w overhaul.
With this change we pass the updated regress.  Tested and OK by ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.23 2004/01/26 14:50:29 millert Exp $	*/
d228 44
a283 5
	if (Fflag) {
		fg->pattern = NULL;
		return (-1);
	}

d524 2
a525 2
		if (((pattern[i] == data[i]) || (pattern[i] == '.')) ||
		    (iflag && pattern[i] == toupper(data[i])))
@


1.23
log
@dataLen should be size_t to match l->len; ok otto@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.22 2004/01/25 21:36:00 millert Exp $	*/
d269 1
a269 1
	if (fg->patternLen > 14 + fg->bol + fg->eol &&
d271 1
a271 1
	    strncmp(pattern + fg->patternLen - (7 + fg->eol), "[[:>:]]", 7) == 0) {
@


1.22
log
@Previously, in -w mode, for each match on a line grep would check
to see if the match was on a word boundary.  However, this missed
lines where the first match was not on a word boundary but a
subsequent match was.  Problem originally spotted by miod@@

We fix this by using the [[:<:]] and [[:>:]] character classes for
the slow path and by checking the word boundaries in grep_search()
for the fast path instead of doing the checks after running
regexec() or grep_search().

With this change, grep passes the new regress tests 15 and 16.
problem originally spotted by espie@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.21 2004/01/19 16:12:04 otto Exp $	*/
d51 1
a51 1
static int	grep_search(fastgrep_t *, unsigned char *, int, regmatch_t *pmatch);
d380 1
a380 1
grep_search(fastgrep_t *fg, unsigned char *data, int dataLen, regmatch_t *pmatch)
@


1.21
log
@Use off_t for file sizes, and don't forget to print a ':' when using
the -b option.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.20 2004/01/18 19:01:55 espie Exp $	*/
d181 1
a181 3
		pmatch.rm_so = 0;
		pmatch.rm_eo = l->len;
		if (fg_pattern[i].pattern)
d184 3
a186 1
		else
d188 4
a191 12
		if (r == 0) {
			if (wflag) {
				if ((pmatch.rm_so != 0 &&
				    isword(l->dat[pmatch.rm_so - 1])) ||
				    (pmatch.rm_eo != l->len &&
				    isword(l->dat[pmatch.rm_eo])))
					r = REG_NOMATCH;
			}
			if (xflag) {
				if (pmatch.rm_so != 0 || pmatch.rm_eo != l->len)
					r = REG_NOMATCH;
			}
d249 1
d268 8
d277 3
a279 2
	 * Copy pattern minus '^' and '$' characters at the beginning and
	 * ending of the string respectively.
d281 3
a283 1
	fg->pattern = grep_strdup(pattern + bol);
d376 3
d403 2
a404 2
				if (grep_cmp(fg->pattern, data + j, fg->patternLen) == -1) {
					rtrnVal = 0;
d407 3
a417 1
				rtrnVal = 0;
d420 5
a424 1
				break;
a435 1
				rtrnVal = 0;
d438 5
a442 1
				break;
a471 10
	return ptr;
}

unsigned char *
grep_strdup(const char *str)
{
	unsigned char *ptr;

	if ((ptr = (unsigned char *)strdup(str)) == NULL)
		err(2, "strdup");
@


1.20
log
@make sure ln.len gets initialized. Okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.19 2003/12/06 20:14:40 otto Exp $	*/
d520 2
a521 1
		printf("%lu", (unsigned long)line->off);
@


1.19
log
@Unbreak grepping for some patterns containing multiple dots. Fixes PR 3597.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.18 2003/10/28 13:23:59 avsm Exp $	*/
d120 1
@


1.18
log
@prototype declared static, but function was not. add static to function.
millert@@ otto@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.17 2003/07/20 22:16:52 millert Exp $	*/
d295 1
a295 1
				if (firstHalfDot < -1)
@


1.17
log
@After some discussion on icb it seems a do {} while is what we want
after all since there's no need to check an invariant the first
time through.  I've fixed the loop invariants (we need to take
special care with the "j == fg->patternLen" case) and hopefully
made things a tad bit clearer.  tedu@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.16 2003/07/20 19:19:48 millert Exp $	*/
d472 1
a472 1
int
@


1.16
log
@Close PR 3358 by changing the loop from do {} while -> for;  tdeval@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.15 2003/07/10 19:16:22 dhartmei Exp $	*/
d403 2
a404 2
		for (j = dataLen; j >= fg->patternLen;
		    j -= fg->qsBc[data[j - fg->patternLen - 1]]) {
d412 5
a416 1
		}
@


1.15
log
@restore grep -v semantics, print lines that don't match any (mismatch all)
patterns. ok tedu@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.14 2003/07/10 17:02:48 millert Exp $	*/
d403 2
a404 2
		j = dataLen;
		do {
d412 1
a412 6

			/* Shift if within bounds, otherwise, we are done. */
			if (j - fg->patternLen - 1 < 0)
				break;
			j -= fg->qsBc[data[j - fg->patternLen - 1]];
		} while (j >= 0);
@


1.14
log
@grep should exit(2) on error, not exit(1) (1 means no matches found).
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.13 2003/07/06 19:16:45 avsm Exp $	*/
d172 1
a172 1
	int		c, i, r, t;
a178 1
	t = vflag ? REG_NOMATCH : 0;
a186 2
		if (r == REG_NOMATCH && t == 0)
			continue;
d200 1
a200 1
		if (r == t) {
d205 2
@


1.13
log
@no need to redefine strlcpy here; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.12 2003/07/01 00:09:23 millert Exp $	*/
d74 1
a74 1
		err(1, NULL);
d80 1
a80 1
			errx(1, "%s: %s", p->fts_path, strerror(p->fts_errno));
d448 1
a448 1
		err(1, "malloc");
d456 1
a456 1
		err(1, "realloc");
d466 1
a466 1
		err(1, "strdup");
@


1.12
log
@Fix bounds check in the fast grep code that caused an incorrect
array access (and a core dump on sparc64 at least).  Noticed by
sturm@@ and pvalchev@@.  Fix tested an OK by pvalchev@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.11 2003/06/25 17:28:00 millert Exp $	*/
a526 26
}

size_t
strlcpy(char *dst, const char *src, size_t siz)
{
	register char *d = dst;
	register const char *s = src;
	register size_t n = siz;

	/* Copy as many bytes as will fit */
	if (n != 0 && --n != 0) {
		do {
			if ((*d++ = *s++) == 0)
				break;
		} while (--n != 0);
	}

	/* Not enough room in dst, add NUL and traverse rest of src */
	if (n == 0) {
		if (siz != 0)
			*d = '\0';		/* NUL-terminate dst */
		while (*s++)
			;
	}

	return(s - src - 1);	/* count does not include NUL */
@


1.11
log
@o remove useless cast to int from gzread() call
o maxPatternLen should be size_t since that's what it is compared against
o remove useless casts of NULL to various pointer types
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.10 2003/06/25 05:31:11 deraadt Exp $	*/
d415 1
a415 1
			if (j == 0)
d417 1
a417 2
			else
				j -= fg->qsBc[data[j - fg->patternLen - 1]];
@


1.10
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.9 2003/06/24 22:36:40 millert Exp $	*/
d73 1
a73 1
	if (!(fts = fts_open(argv, fts_flags, (int (*) ()) NULL)))
@


1.9
log
@Make 'grep -w' work; OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.8 2003/06/24 18:45:30 tedu Exp $	*/
d58 3
a60 3
	FTS	       *fts;
	FTSENT	       *p;
	int		c, fts_flags;
d233 1
a233 2
 * Returns: -1 on failure
 *           0 on success
d332 1
a332 1
	 * reverse version of this algorithm would be useful for wildcards near 
d446 1
a446 1
	void	       *ptr;
@


1.8
log
@actually do fgrep.  -G -F and -E are now mutally exclusive, and override
the program name as expected.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.7 2003/06/24 17:32:10 tedu Exp $	*/
d51 1
a51 1
static int	grep_search(fastgrep_t *, unsigned char *, int);
a179 2
	pmatch.rm_so = 0;
	pmatch.rm_eo = l->len;
d181 2
d185 1
a185 1
			    l->len);
d187 1
a187 1
			r = regexec(&r_pattern[i], l->dat, 0, &pmatch, eflags);
d373 2
a374 1
static int grep_search(fastgrep_t *fg, unsigned char *data, int dataLen)
d379 3
d397 1
a397 1
				if (grep_cmp(fg->pattern, data + j, fg->patternLen) == -1)
d399 3
d410 2
d427 2
d477 1
a477 2
grep_cmp(const unsigned char *pattern, const unsigned char *data,
    size_t len)
@


1.7
log
@don't print "Binary file matches" with -q flag.  from Sean Farley
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.6 2003/06/23 22:05:23 tedu Exp $	*/
d249 5
d277 2
a278 2
	 * Copy pattern minus '^' and '$' characters at the beginning and ending of
	 * the string respectively.
@


1.6
log
@faster grep for simple patterns.  derived from a patch by sean farley.
this makes searching for constant strings much faster by avoiding regex.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.5 2003/06/23 07:52:18 deraadt Exp $	*/
d155 1
a155 1
	    binbehave == BIN_FILE_BIN && nottext)
d514 26
@


1.5
log
@minor tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.4 2003/06/23 00:55:09 tedu Exp $	*/
d51 3
d183 5
a187 1
		r = regexec(&r_pattern[i], l->dat, 0, &pmatch, eflags);
d232 196
d444 43
@


1.4
log
@better detetection/handling of binary files.
make -a do the right thing, doc and implement -U, -I.
add --help and --mmap for compatibility.
some other minor fixes.

some from NetBSD.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.3 2003/06/22 22:38:50 deraadt Exp $	*/
d180 1
a180 1
		r = regexec(&r_pattern[i], l->dat, 0, &pmatch,  eflags);
d185 4
a188 2
				if ((pmatch.rm_so != 0 && isword(l->dat[pmatch.rm_so - 1]))
				    || (pmatch.rm_eo != l->len && isword(l->dat[pmatch.rm_eo])))
d208 2
a209 1
			if (first > 0 && tail == 0 && (Bflag < linesqueued) && (Aflag || Bflag))
@


1.3
log
@proper $OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
a50 1
static int	procline(str_t *l);
d95 1
a95 1
	int c, t, z;
d108 3
a110 1
	if (aflag && grep_bin_file(f)) {
d132 1
a132 1
		if ((t = procline(&ln)) == 0 && Bflag > 0 && z == 0) {
d151 4
d166 1
a166 1
procline(str_t *l)
d201 3
@


1.2
log
@-DNOZ flag to be used by install media for removing z*grep support, if
needed.  (and knf)
@
text
@d1 2
a26 2
 *
 *	$Id$
@


1.1
log
@freegrep 0.16
@
text
@d52 1
a52 1
int 
d129 1
a129 1
		
d169 1
a169 1
	
d193 1
a193 1
	
d235 1
a235 1
	
@

