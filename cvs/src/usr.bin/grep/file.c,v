head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.8
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.6
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.20
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.18
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.14
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.12
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.10
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.8
	OPENBSD_5_0:1.11.0.6
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.9.0.12
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.10
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.8
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.6
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.13
date	2015.03.16.13.27.59;	author millert;	state Exp;
branches;
next	1.12;
commitid	pfgWWhvHWftLteOH;

1.12
date	2015.01.16.06.40.08;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	Uu5nFG3wCl0LACBb;

1.11
date	2010.07.02.20.48.48;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2008.10.16.22.56.32;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.09.09.54.46;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.07.22.05.54;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.07.08.47.18;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.02.06.17.17;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.29.21.20.55;	author canacar;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.10.17.02.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.22.22.38.50;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.22.22.24.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.22.22.20.07;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Don't include limits.h or sys/limits.h since grep.h already does it
for us.
@
text
@/*	$OpenBSD: file.c,v 1.12 2015/01/16 06:40:08 deraadt Exp $	*/

/*-
 * Copyright (c) 1999 James Howard and Dag-Erling Coïdan Smørgrav
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <zlib.h>

#include "grep.h"

static char	 fname[PATH_MAX];
#ifndef NOZ
static char	*lnbuf;
static size_t	 lnbuflen;
#endif

#define FILE_STDIO	0
#define FILE_MMAP	1
#define FILE_GZIP	2

struct file {
	int	 type;
	int	 noseek;
	FILE	*f;
	mmf_t	*mmf;
	gzFile	*gzf;
};

#ifndef NOZ
static char *
gzfgetln(gzFile *f, size_t *len)
{
	size_t		n;
	int		c;

	for (n = 0; ; ++n) {
		c = gzgetc(f);
		if (c == -1) {
			const char *gzerrstr;
			int gzerr;

			if (gzeof(f))
				break;

			gzerrstr = gzerror(f, &gzerr);
			if (gzerr == Z_ERRNO)
				err(2, "%s", fname);
			else
				errx(2, "%s: %s", fname, gzerrstr);
		}
		if (n >= lnbuflen) {
			lnbuflen *= 2;
			lnbuf = grep_realloc(lnbuf, ++lnbuflen);
		}
		if (c == '\n')
			break;
		lnbuf[n] = c;
	}

	if (gzeof(f) && n == 0)
		return NULL;
	*len = n;
	return lnbuf;
}
#endif

file_t *
grep_fdopen(int fd, char *mode)
{
	file_t *f;

	if (fd == STDIN_FILENO)
		snprintf(fname, sizeof fname, "(standard input)");
	else
		snprintf(fname, sizeof fname, "(fd %d)", fd);

	f = grep_malloc(sizeof *f);

#ifndef NOZ
	if (Zflag) {
		f->type = FILE_GZIP;
		f->noseek = lseek(fd, 0L, SEEK_SET) == -1;
		if ((f->gzf = gzdopen(fd, mode)) != NULL)
			return f;
	} else
#endif
	{
		f->type = FILE_STDIO;
		f->noseek = isatty(fd);
		if ((f->f = fdopen(fd, mode)) != NULL)
			return f;
	}

	free(f);
	return NULL;
}

file_t *
grep_open(char *path, char *mode)
{
	file_t *f;

	snprintf(fname, sizeof fname, "%s", path);

	f = grep_malloc(sizeof *f);
	f->noseek = 0;

#ifndef NOZ
	if (Zflag) {
		f->type = FILE_GZIP;
		if ((f->gzf = gzopen(fname, mode)) != NULL)
			return f;
	} else
#endif
	{
#ifndef SMALL
		/* try mmap first; if it fails, try stdio */
		if ((f->mmf = mmopen(fname, mode)) != NULL) {
			f->type = FILE_MMAP;
			return f;
		}
#endif
		f->type = FILE_STDIO;
		if ((f->f = fopen(path, mode)) != NULL)
			return f;
	}

	free(f);
	return NULL;
}

int
grep_bin_file(file_t *f)
{
	if (f->noseek)
		return 0;

	switch (f->type) {
	case FILE_STDIO:
		return bin_file(f->f);
#ifndef SMALL
	case FILE_MMAP:
		return mmbin_file(f->mmf);
#endif
#ifndef NOZ
	case FILE_GZIP:
		return gzbin_file(f->gzf);
#endif
	default:
		/* can't happen */
		errx(2, "invalid file type");
	}
}

char *
grep_fgetln(file_t *f, size_t *l)
{
	switch (f->type) {
	case FILE_STDIO:
		return fgetln(f->f, l);
#ifndef SMALL
	case FILE_MMAP:
		return mmfgetln(f->mmf, l);
#endif
#ifndef NOZ
	case FILE_GZIP:
		return gzfgetln(f->gzf, l);
#endif
	default:
		/* can't happen */
		errx(2, "invalid file type");
	}
}

void
grep_close(file_t *f)
{
	switch (f->type) {
	case FILE_STDIO:
		fclose(f->f);
		break;
#ifndef SMALL
	case FILE_MMAP:
		mmclose(f->mmf);
		break;
#endif
#ifndef NOZ
	case FILE_GZIP:
		gzclose(f->gzf);
		break;
#endif
	default:
		/* can't happen */
		errx(2, "invalid file type");
	}
	free(f);
}
@


1.12
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.11 2010/07/02 20:48:48 nicm Exp $	*/
a31 1
#include <limits.h>
@


1.11
log
@Do not include mmap support with -DSMALL.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.10 2008/10/16 22:56:32 deraadt Exp $	*/
a28 2
#include <sys/param.h>

d32 1
d37 1
a37 1
static char	 fname[MAXPATHLEN];
@


1.10
log
@two globals not needed in NOZ mode
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.9 2006/02/09 09:54:46 otto Exp $	*/
d143 1
d149 1
d168 1
d171 1
d188 1
d191 1
d209 1
d213 1
@


1.9
log
@delint; remove redundant vars and functions; ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.8 2006/02/07 22:05:54 otto Exp $	*/
d39 1
d42 1
@


1.8
log
@restore cosmic balance by plugging a mem leak; problem reported by
Benjamin Pineau in PR 5008; ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.7 2005/02/07 08:47:18 otto Exp $	*/
a168 18
#endif
	default:
		/* can't happen */
		errx(2, "invalid file type");
	}
}

long
grep_tell(file_t *f)
{
	switch (f->type) {
	case FILE_STDIO:
		return ftell(f->f);
	case FILE_MMAP:
		return mmtell(f->mmf);
#ifndef NOZ
	case FILE_GZIP:
		return gztell(f->gzf);
@


1.7
log
@Due to a braindead zlib, the test for seekability of a gzstream using
gzseek(f, 0L, SEEK_CUR) does not work as expected. Instead test the
underlying stream and remember that. This repairs echo foo | gzip | zgrep foo.
Problem spotted by Han Boetes in PR 4089; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.6 2005/02/02 06:17:17 tedu Exp $	*/
d231 1
@


1.6
log
@replace 0 with STDIN_FILENO.  from han boetes and jared yanovich
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.5 2003/12/29 21:20:55 canacar Exp $	*/
d48 1
d107 1
d114 1
d131 1
d158 3
@


1.5
log
@fix zgrep failure when the uncompressed file begins with a newline
also, search from the beginning if a stream or compressed file is
identified as 'binary'.
ok millert@@, reported by tedu@@, tested by jose@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.4 2003/07/10 17:02:48 millert Exp $	*/
d96 1
a96 1
	if (fd == 0)
@


1.4
log
@grep should exit(2) on error, not exit(1) (1 means no matches found).
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.3 2003/06/22 22:38:50 deraadt Exp $	*/
a74 2
		if (c == '\n')
			break;
d79 2
@


1.3
log
@proper $OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 1
a71 1
				err(1, "%s", fname);
d73 1
a73 1
				errx(1, "%s: %s", fname, gzerrstr);
d165 1
a165 1
		errx(1, "invalid file type");
d183 1
a183 1
		errx(1, "invalid file type");
d201 1
a201 1
		errx(1, "invalid file type");
d222 1
a222 1
		errx(1, "invalid file type");
@


1.2
log
@-DNOZ flag to be used by install media for removing z*grep support, if
needed.  (and knf)
@
text
@d1 2
a26 2
 *
 *	$Id$
@


1.1
log
@freegrep 0.16
@
text
@d40 1
a40 1
static int	 lnbuflen;
d53 1
d68 1
a68 1
			
d89 1
d97 1
a97 1
		sprintf(fname, "(standard input)");
d99 2
a100 2
		sprintf(fname, "(fd %d)", fd);
	
d102 2
a103 1
	
d108 3
a110 1
	} else {
d115 1
a115 1
	
d125 2
a126 2
	snprintf(fname, MAXPATHLEN, "%s", path);
	
d128 2
a129 1
	
d134 3
a136 1
	} else {
d146 1
a146 1
	
d159 1
d162 1
d177 1
d180 1
d195 1
d198 1
d215 1
d219 1
@

