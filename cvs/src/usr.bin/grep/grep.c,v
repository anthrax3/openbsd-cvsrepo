head	1.55;
access;
symbols
	OPENBSD_6_2:1.55.0.10
	OPENBSD_6_2_BASE:1.55
	OPENBSD_6_1:1.55.0.8
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.55.0.4
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.51.0.4
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.45.0.10
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.45.0.8
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.45.0.4
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.44.0.6
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.4
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.42.0.4
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.39.0.8
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.39.0.10
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.6
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.39.0.4
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.2
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.38.0.4
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.31.0.2
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.1.0.6
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.4
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.55
date	2015.11.28.01.17.12;	author gsoares;	state Exp;
branches;
next	1.54;
commitid	1E4rVlQU7ZpA9Z0M;

1.54
date	2015.10.09.01.37.07;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	sbrB3Q5CNxcwZpfU;

1.53
date	2015.10.03.05.36.34;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	Klw9Uhkvc6dYH8h4;

1.52
date	2015.08.27.05.11.39;	author dlg;	state Exp;
branches;
next	1.51;
commitid	Cb9VQdhHsCqrQowK;

1.51
date	2015.04.30.13.49.04;	author millert;	state Exp;
branches;
next	1.50;
commitid	5WXs9zeqrTHXhnd2;

1.50
date	2015.03.16.13.27.59;	author millert;	state Exp;
branches;
next	1.49;
commitid	pfgWWhvHWftLteOH;

1.49
date	2015.01.10.13.48.02;	author tedu;	state Exp;
branches;
next	1.48;
commitid	fEKdbP2GB4w2Blvu;

1.48
date	2014.12.01.06.36.04;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	1N4D8AaCy2x3MRHz;

1.47
date	2014.11.26.18.34.51;	author millert;	state Exp;
branches;
next	1.46;
commitid	9QOFSShUOtA0kQLF;

1.46
date	2014.11.26.17.26.40;	author millert;	state Exp;
branches;
next	1.45;
commitid	BQcrCpoH97o2p2Re;

1.45
date	2012.12.29.01.32.44;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2011.07.08.01.20.24;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2011.03.04.03.11.23;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2010.07.02.22.18.03;	author tedu;	state Exp;
branches;
next	1.41;

1.41
date	2010.04.20.15.58.08;	author jacekm;	state Exp;
branches;
next	1.40;

1.40
date	2010.04.05.03.03.55;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.02.15.19.32;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.02.13.21.48.20;	author kili;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.02.18.00.03;	author ray;	state Exp;
branches;
next	1.36;

1.36
date	2006.09.26.15.55.17;	author jaredy;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.07.20.59.56;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2006.02.09.09.54.46;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.03.19.18.33;	author jaredy;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.03.19.12.40;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2004.10.03.19.23.02;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2004.09.28.20.51.15;	author jmc;	state Exp;
branches;
next	1.29;

1.29
date	2004.08.05.21.47.33;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.07.14.51.42;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.02.18.39.36;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.04.18.38.52;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.25.21.36.00;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.11.20.49.20;	author mcbride;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.07.19.40.54;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.16.19.08.21;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.14.23.22.35;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.10.17.02.48;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.10.16.51.12;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.10.16.49.12;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.25.17.28.00;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.24.18.45.30;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.23.22.32.48;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.23.22.27.09;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.23.22.05.23;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.23.07.52.18;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.23.03.23.40;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.23.02.02.41;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.23.00.55.09;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.22.23.51.22;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.22.23.12.38;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.22.22.38.50;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.22.22.24.13;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.22.22.23.06;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.22.22.20.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.16.03.46.04;	author cloder;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.21.23.12.00;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.55
log
@fix exit status on pledge(2) error, where it should be >1

OK millert@@ deraadt@@
@
text
@/*	$OpenBSD: grep.c,v 1.54 2015/10/09 01:37:07 deraadt Exp $	*/

/*-
 * Copyright (c) 1999 James Howard and Dag-Erling Coïdan Smørgrav
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/queue.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <getopt.h>
#include <regex.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "grep.h"

/* Flags passed to regcomp() and regexec() */
int	 cflags;
int	 eflags = REG_STARTEND;

int	 matchall;	/* shortcut */
int	 patterns, pattern_sz;
char   **pattern;
regex_t	*r_pattern;
fastgrep_t *fg_pattern;

/* For regex errors  */
char	 re_error[RE_ERROR_BUF + 1];

/* Command-line flags */
int	 Aflag;		/* -A x: print x lines trailing each match */
int	 Bflag;		/* -B x: print x lines leading each match */
int	 Eflag;		/* -E: interpret pattern as extended regexp */
int	 Fflag;		/* -F: interpret pattern as list of fixed strings */
int	 Hflag;		/* -H: always print filename header */
int	 Lflag;		/* -L: only show names of files with no matches */
int	 Rflag;		/* -R: recursively search directory trees */
#ifndef NOZ
int	 Zflag;		/* -Z: decompress input before processing */
#endif
int	 bflag;		/* -b: show block numbers for each match */
int	 cflag;		/* -c: only show a count of matching lines */
int	 hflag;		/* -h: don't print filename headers */
int	 iflag;		/* -i: ignore case */
int	 lflag;		/* -l: only show names of files with matches */
int	 nflag;		/* -n: show line numbers in front of matching lines */
int	 oflag;		/* -o: print each match */
int	 qflag;		/* -q: quiet mode (don't output anything) */
int	 sflag;		/* -s: silent mode (ignore errors) */
int	 vflag;		/* -v: only show non-matching lines */
int	 wflag;		/* -w: pattern must start and end on word boundaries */
int	 xflag;		/* -x: pattern must match entire line */
int	 lbflag;	/* --line-buffered */

int binbehave = BIN_FILE_BIN;

enum {
	BIN_OPT = CHAR_MAX + 1,
	HELP_OPT,
	MMAP_OPT,
	LINEBUF_OPT
};

/* Housekeeping */
int	 first;		/* flag whether or not this is our first match */
int	 tail;		/* lines left to print */
int	 file_err;	/* file reading error */

struct patfile {
	const char		*pf_file;
	SLIST_ENTRY(patfile)	 pf_next;
};
SLIST_HEAD(, patfile)		 patfilelh;

extern char *__progname;

static void
usage(void)
{
	fprintf(stderr,
#ifdef NOZ
	    "usage: %s [-abcEFGHhIiLlnoqRsUVvwx] [-A num] [-B num] [-C[num]]\n"
#else
	    "usage: %s [-abcEFGHhIiLlnoqRsUVvwxZ] [-A num] [-B num] [-C[num]]\n"
#endif
	    "\t[-e pattern] [-f file] [--binary-files=value] [--context[=num]]\n"
	    "\t[--line-buffered] [pattern] [file ...]\n", __progname);
	exit(2);
}

#ifdef NOZ
static const char optstr[] = "0123456789A:B:CEFGHILRUVabce:f:hilnoqrsuvwxy";
#else
static const char optstr[] = "0123456789A:B:CEFGHILRUVZabce:f:hilnoqrsuvwxy";
#endif

static const struct option long_options[] =
{
	{"binary-files",	required_argument,	NULL, BIN_OPT},
	{"help",		no_argument,		NULL, HELP_OPT},
	{"mmap",		no_argument,		NULL, MMAP_OPT},
	{"line-buffered",	no_argument,		NULL, LINEBUF_OPT},
	{"after-context",	required_argument,	NULL, 'A'},
	{"before-context",	required_argument,	NULL, 'B'},
	{"context",		optional_argument,	NULL, 'C'},
	{"devices",		required_argument,	NULL, 'D'},
	{"extended-regexp",	no_argument,		NULL, 'E'},
	{"fixed-strings",	no_argument,		NULL, 'F'},
	{"basic-regexp",	no_argument,		NULL, 'G'},
	{"with-filename",	no_argument,		NULL, 'H'},
	{"binary",		no_argument,		NULL, 'U'},
	{"version",		no_argument,		NULL, 'V'},
	{"text",		no_argument,		NULL, 'a'},
	{"byte-offset",		no_argument,		NULL, 'b'},
	{"count",		no_argument,		NULL, 'c'},
	{"regexp",		required_argument,	NULL, 'e'},
	{"file",		required_argument,	NULL, 'f'},
	{"no-filename",		no_argument,		NULL, 'h'},
	{"ignore-case",		no_argument,		NULL, 'i'},
	{"files-without-match",	no_argument,		NULL, 'L'},
	{"files-with-matches",	no_argument,		NULL, 'l'},
	{"line-number",		no_argument,		NULL, 'n'},
	{"quiet",		no_argument,		NULL, 'q'},
	{"silent",		no_argument,		NULL, 'q'},
	{"recursive",		no_argument,		NULL, 'r'},
	{"no-messages",		no_argument,		NULL, 's'},
	{"revert-match",	no_argument,		NULL, 'v'},
	{"word-regexp",		no_argument,		NULL, 'w'},
	{"line-regexp",		no_argument,		NULL, 'x'},
	{"unix-byte-offsets",	no_argument,		NULL, 'u'},
#ifndef NOZ
	{"decompress",		no_argument,		NULL, 'Z'},
#endif
	{NULL,			no_argument,		NULL, 0}
};


static void
add_pattern(char *pat, size_t len)
{
	if (!xflag && (len == 0 || matchall)) {
		matchall = 1;
		return;
	}
	if (patterns == pattern_sz) {
		pattern_sz *= 2;
		pattern = grep_reallocarray(pattern, ++pattern_sz, sizeof(*pattern));
	}
	if (len > 0 && pat[len - 1] == '\n')
		--len;
	/* pat may not be NUL-terminated */
	if (wflag && !Fflag) {
		int bol = 0, eol = 0, extra;
		if (pat[0] == '^')
			bol = 1;
		if (len > 0 && pat[len - 1] == '$')
			eol = 1;
		extra = Eflag ? 2 : 4;
		pattern[patterns] = grep_malloc(len + 15 + extra);
		snprintf(pattern[patterns], len + 15 + extra,
		   "%s[[:<:]]%s%.*s%s[[:>:]]%s",
		    bol ? "^" : "",
		    Eflag ? "(" : "\\(",
		    (int)len - bol - eol, pat + bol,
		    Eflag ? ")" : "\\)",
		    eol ? "$" : "");
		len += 14 + extra;
	} else {
		pattern[patterns] = grep_malloc(len + 1);
		memcpy(pattern[patterns], pat, len);
		pattern[patterns][len] = '\0';
	}
	++patterns;
}

static void
add_patterns(char *pats)
{
	char *nl;

	while ((nl = strchr(pats, '\n')) != NULL) {
		add_pattern(pats, nl - pats);
		pats = nl + 1;
	}
	add_pattern(pats, strlen(pats));
}

static void
read_patterns(const char *fn)
{
	FILE *f;
	char *line;
	size_t len;

	if ((f = fopen(fn, "r")) == NULL)
		err(2, "%s", fn);
	while ((line = fgetln(f, &len)) != NULL)
		add_pattern(line, *line == '\n' ? 0 : len);
	if (ferror(f))
		err(2, "%s", fn);
	fclose(f);
}

int
main(int argc, char *argv[])
{
	int c, lastc, prevoptind, newarg, i, needpattern, exprs, expr_sz;
	struct patfile *patfile, *pf_next;
	long l;
	char **expr;
	const char *errstr;

	if (pledge("stdio rpath", NULL) == -1)
		err(2, "pledge");

	SLIST_INIT(&patfilelh);
	switch (__progname[0]) {
	case 'e':
		Eflag = 1;
		break;
	case 'f':
		Fflag = 1;
		break;
#ifndef NOZ
	case 'z':
		Zflag = 1;
		switch(__progname[1]) {
		case 'e':
			Eflag = 1;
			break;
		case 'f':
			Fflag = 1;
			break;
		}
		break;
#endif
	}

	lastc = '\0';
	newarg = 1;
	prevoptind = 1;
	needpattern = 1;
	expr_sz = exprs = 0;
	expr = NULL;
	while ((c = getopt_long(argc, argv, optstr,
				long_options, NULL)) != -1) {
		switch (c) {
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			if (newarg || !isdigit(lastc))
				Aflag = 0;
			else if (Aflag > INT_MAX / 10)
				errx(2, "context out of range");
			Aflag = Bflag = (Aflag * 10) + (c - '0');
			break;
		case 'A':
		case 'B':
			l = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr != NULL)
				errx(2, "context %s", errstr);
			if (c == 'A')
				Aflag = (int)l;
			else
				Bflag = (int)l;
			break;
		case 'C':
			if (optarg == NULL)
				Aflag = Bflag = 2;
			else {
				l = strtonum(optarg, 1, INT_MAX, &errstr);
				if (errstr != NULL)
					errx(2, "context %s", errstr);
				Aflag = Bflag = (int)l;
			}
			break;
		case 'E':
			Fflag = 0;
			Eflag = 1;
			break;
		case 'F':
			Eflag = 0;
			Fflag = 1;
			break;
		case 'G':
			Eflag = Fflag = 0;
			break;
		case 'H':
			Hflag = 1;
			break;
		case 'I':
			binbehave = BIN_FILE_SKIP;
			break;
		case 'L':
			lflag = 0;
			Lflag = qflag = 1;
			break;
		case 'R':
		case 'r':
			Rflag = 1;
			break;
		case 'U':
			binbehave = BIN_FILE_BIN;
			break;
		case 'V':
			fprintf(stderr, "grep version %u.%u\n", VER_MAJ, VER_MIN);
			exit(0);
			break;
#ifndef NOZ
		case 'Z':
			Zflag = 1;
			break;
#endif
		case 'a':
			binbehave = BIN_FILE_TEXT;
			break;
		case 'b':
			bflag = 1;
			break;
		case 'c':
			cflag = 1;
			break;
		case 'e':
			/* defer adding of expressions until all arguments are parsed */
			if (exprs == expr_sz) {
				expr_sz *= 2;
				expr = grep_reallocarray(expr, ++expr_sz,
				    sizeof(*expr));
			}
			needpattern = 0;
			expr[exprs] = optarg;
			++exprs;
			break;
		case 'f':
			patfile = grep_malloc(sizeof(*patfile));
			patfile->pf_file = optarg;
			SLIST_INSERT_HEAD(&patfilelh, patfile, pf_next);
			needpattern = 0;
			break;
		case 'h':
			hflag = 1;
			break;
		case 'i':
		case 'y':
			iflag = 1;
			cflags |= REG_ICASE;
			break;
		case 'l':
			Lflag = 0;
			lflag = qflag = 1;
			break;
		case 'n':
			nflag = 1;
			break;
		case 'o':
			oflag = 1;
			break;
		case 'q':
			qflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		case 'v':
			vflag = 1;
			break;
		case 'w':
			wflag = 1;
			break;
		case 'x':
			xflag = 1;
			break;
		case BIN_OPT:
			if (strcmp("binary", optarg) == 0)
				binbehave = BIN_FILE_BIN;
			else if (strcmp("without-match", optarg) == 0)
				binbehave = BIN_FILE_SKIP;
			else if (strcmp("text", optarg) == 0)
				binbehave = BIN_FILE_TEXT;
			else
				errx(2, "Unknown binary-files option");
			break;
		case 'u':
		case MMAP_OPT:
			/* default, compatibility */
			break;
		case LINEBUF_OPT:
			lbflag = 1;
			break;
		case HELP_OPT:
		default:
			usage();
		}
		lastc = c;
		newarg = optind != prevoptind;
		prevoptind = optind;
	}
	argc -= optind;
	argv += optind;

	for (i = 0; i < exprs; i++)
		add_patterns(expr[i]);
	free(expr);
	expr = NULL;

	for (patfile = SLIST_FIRST(&patfilelh); patfile != NULL;
	    patfile = pf_next) {
		pf_next = SLIST_NEXT(patfile, pf_next);
		read_patterns(patfile->pf_file);
		free(patfile);
	}

	if (argc == 0 && needpattern)
		usage();

	if (argc != 0 && needpattern) {
		add_patterns(*argv);
		--argc;
		++argv;
	}

	if (Rflag && argc == 0)
		warnx("warning: recursive search of stdin");
	if (Eflag)
		cflags |= REG_EXTENDED;
	if (Fflag)
		cflags |= REG_NOSPEC;
#ifdef SMALL
	/* Sorry, this won't work */
	if (Fflag && wflag)
		errx(1, "Can't use small fgrep with -w");
#endif
	fg_pattern = grep_calloc(patterns, sizeof(*fg_pattern));
	r_pattern = grep_calloc(patterns, sizeof(*r_pattern));
	for (i = 0; i < patterns; ++i) {
		/* Check if cheating is allowed (always is for fgrep). */
#ifndef SMALL
		if (Fflag) {
			fgrepcomp(&fg_pattern[i], pattern[i]);
		} else
#endif
		{
			if (fastcomp(&fg_pattern[i], pattern[i])) {
				/* Fall back to full regex library */
				c = regcomp(&r_pattern[i], pattern[i], cflags);
				if (c != 0) {
					regerror(c, &r_pattern[i], re_error,
					    RE_ERROR_BUF);
					errx(2, "%s", re_error);
				}
			}
		}
	}

	if (lbflag)
		setvbuf(stdout, NULL, _IOLBF, 0);

	if ((argc == 0 || argc == 1) && !Rflag && !Hflag)
		hflag = 1;

	if (argc == 0)
		exit(!procfile(NULL));

	if (Rflag)
		c = grep_tree(argv);
	else
		for (c = 0; argc--; ++argv)
			c += procfile(*argv);

	exit(c ? (file_err ? (qflag ? 0 : 2) : 0) : (file_err ? 2 : 1));
}
@


1.54
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.53 2015/10/03 05:36:34 deraadt Exp $	*/
d242 1
a242 1
		err(1, "pledge");
@


1.53
log
@grep only opens files read-only, reads via stdio or other methods, performs
computation, and outputs result to stdout.  (note: in the tame model,
malloc is implicit because stdio needs it, and mmap is implicit since
malloc needs it; libz is satisfied by this environment also).

this tame change consists of 1 line, setting "stdio rpath" before
getopt.  this protection is fairly strict.  grep could be improved
further by computing a wpathlist based on argv, keeping -R in mind.
feel free to take a shot at it.

grep was an early target of capsicum also.  know anyone running capsicum grep?

ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.52 2015/08/27 05:11:39 dlg Exp $	*/
d241 2
a242 2
	if (tame("stdio rpath", NULL) == -1)
		err(1, "tame");
@


1.52
log
@use strtonum to parse the number of lines of context.

this provides better error messages.

ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.51 2015/04/30 13:49:04 millert Exp $	*/
d240 3
@


1.51
log
@Add warning when user specifies -R but no files, like GNU grep.
OK schwarze@@ ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.50 2015/03/16 13:27:59 millert Exp $	*/
d238 2
a239 1
	char *ep, **expr;
d283 3
a285 4
			l = strtol(optarg, &ep, 10);
			if (ep == optarg || *ep != '\0' ||
			    l <= 0 || l >= INT_MAX)
				errx(2, "context out of range");
d295 3
a297 4
				l = strtol(optarg, &ep, 10);
				if (ep == optarg || *ep != '\0' ||
				    l <= 0 || l >= INT_MAX)
					errx(2, "context out of range");
@


1.50
log
@Don't include limits.h or sys/limits.h since grep.h already does it
for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.49 2015/01/10 13:48:02 tedu Exp $	*/
d447 2
@


1.49
log
@1. They're flags, not counters. Set to one instead of incrementing.
2. The G flag is useless and never checked. Remove it.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.48 2014/12/01 06:36:04 deraadt Exp $	*/
a29 1
#include <sys/limits.h>
@


1.48
log
@use reallocarray()
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.47 2014/11/26 18:34:51 millert Exp $	*/
a63 1
int	 Gflag;		/* -G: interpret pattern as basic regexp */
d244 1
a244 1
		Eflag++;
d247 1
a247 4
		Fflag++;
		break;
	case 'g':
		Gflag++;
d251 1
a251 1
		Zflag++;
d254 1
a254 1
			Eflag++;
d257 1
a257 4
			Fflag++;
			break;
		case 'g':
			Gflag++;
d304 2
a305 2
			Fflag = Gflag = 0;
			Eflag++;
d308 2
a309 2
			Eflag = Gflag = 0;
			Fflag++;
a312 1
			Gflag++;
d315 1
a315 1
			Hflag++;
d326 1
a326 1
			Rflag++;
d337 1
a337 1
			Zflag++;
@


1.47
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.46 2014/11/26 17:26:40 millert Exp $	*/
d177 1
a177 1
		pattern = grep_realloc(pattern, ++pattern_sz * sizeof(*pattern));
d361 2
a362 1
				expr = grep_realloc(expr, ++expr_sz * sizeof(*expr));
@


1.46
log
@Make option string/struct const (since it is...).  I've had this
in my tree for ages.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.45 2012/12/29 01:32:44 millert Exp $	*/
d487 1
a487 1
		setlinebuf(stdout);
@


1.45
log
@Fix exit status when there is an error reading a file.
Reported by Jeramey Crawford, fix adapted from FreeBSD.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.44 2011/07/08 01:20:24 tedu Exp $	*/
d122 1
a122 1
static char *optstr = "0123456789A:B:CEFGHILRUVabce:f:hilnoqrsuvwxy";
d124 1
a124 1
static char *optstr = "0123456789A:B:CEFGHILRUVZabce:f:hilnoqrsuvwxy";
d127 1
a127 1
struct option long_options[] =
@


1.44
log
@add support for -o to only print the match.
reminded this was useful by ajcoutot
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.43 2011/03/04 03:11:23 tedu Exp $	*/
d97 1
d501 1
a501 1
	exit(!c);
@


1.43
log
@add -H (opposite of -h) to always print name. ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.42 2010/07/02 22:18:03 tedu Exp $	*/
d77 1
d111 1
a111 1
	    "usage: %s [-abcEFGHhIiLlnqRsUVvwx] [-A num] [-B num] [-C[num]]\n"
d113 1
a113 1
	    "usage: %s [-abcEFGHhIiLlnqRsUVvwxZ] [-A num] [-B num] [-C[num]]\n"
d121 1
a121 1
static char *optstr = "0123456789A:B:CEFGHILRUVabce:f:hilnqrsuvwxy";
d123 1
a123 1
static char *optstr = "0123456789A:B:CEFGHILRUVZabce:f:hilnqrsuvwxy";
d386 3
@


1.42
log
@Remove the "fast" grep code if SMALL.  This has the side effect of breaking
fgrep -w, but oh well.  ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.41 2010/04/20 15:58:08 jacekm Exp $	*/
d65 1
d110 1
a110 1
	    "usage: %s [-abcEFGhIiLlnqRsUVvwx] [-A num] [-B num] [-C[num]]\n"
d112 1
a112 1
	    "usage: %s [-abcEFGhIiLlnqRsUVvwxZ] [-A num] [-B num] [-C[num]]\n"
d120 1
a120 1
static char *optstr = "0123456789A:B:CEFGILRUVabce:f:hilnqrsuvwxy";
d122 1
a122 1
static char *optstr = "0123456789A:B:CEFGILRUVZabce:f:hilnqrsuvwxy";
d138 1
d320 3
d484 1
a484 1
	if ((argc == 0 || argc == 1) && !Rflag)
@


1.41
log
@Fix "grep -e foo -w" crash.  The problem lies in 'e' getopt clause
calling add_pattern, which in turn assumes that the getopt phase
has already finished.

OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.40 2010/04/05 03:03:55 tedu Exp $	*/
d447 7
d458 1
d461 3
a463 1
		} else {
@


1.40
log
@remove some non-POSIX standard non-GNU defacto standard options, mostly
relating to symlinks that you can get with find.  And a bonus fts flag fix.
With a small tweak by guenther.  ok deraadt guenther jmc millert nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.39 2007/09/02 15:19:32 deraadt Exp $	*/
d233 1
a233 1
	int c, lastc, prevoptind, newarg, i, needpattern;
d236 1
a236 1
	char *ep;
d271 2
d351 5
a355 1
			add_patterns(optarg);
d357 2
d423 5
@


1.39
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.38 2007/02/13 21:48:20 kili Exp $	*/
a64 1
int	 Hflag;		/* -H: if -R, follow explicitly listed symlinks */
a65 1
int	 Pflag;		/* -P: if -R, no symlinks are followed */
a66 1
int	 Sflag;		/* -S: if -R, follow all symlinks */
a75 1
int	 oflag;		/* -o: always print file name */
d109 1
a109 1
	    "usage: %s [-abcEFGHhIiLlnoPqRSsUVvwx] [-A num] [-B num] [-C[num]]\n"
d111 1
a111 1
	    "usage: %s [-abcEFGHhIiLlnoPqRSsUVvwxZ] [-A num] [-B num] [-C[num]]\n"
d119 1
a119 1
static char *optstr = "0123456789A:B:CEFGHILPSRUVabce:f:hilnoqrsuvwxy";
d121 1
a121 1
static char *optstr = "0123456789A:B:CEFGHILPSRUVZabce:f:hilnoqrsuvwxy";
a315 3
		case 'H':
			Hflag++;
			break;
a322 6
		case 'P':
			Pflag++;
			break;
		case 'S':
			Sflag++;
			break;
a325 1
			oflag++;
a358 1
			oflag = 0;
a372 4
		case 'o':
			hflag = 0;
			oflag = 1;
			break;
d456 1
a456 1
	if ((argc == 0 || argc == 1) && !oflag)
@


1.38
log
@
- Be explicit on command line checking, instead of relying on patterns,
  which may be NULL (e.g. -e '').
- let add_pattern() decide how to deal with empty patterns, don't do
  magic in read_patterns().

This unbreaks stuff like grep -e '', and makes grep -f <file> more
POSIX compliant. Semantics for grep -f /dev/null (or any other empty
file) may be questionable, but this case isn't specified by POSIX,
and matching nothing at all seems to be sane.

Thanks to otto@@, who mentioned potential problems related to the
-x option with the first patch i sent.

ok jaredy@@ (some time ago), otto@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.37 2006/11/02 18:00:03 ray Exp $	*/
d453 2
a454 2
	fg_pattern = grep_malloc(patterns * sizeof(*fg_pattern));
	r_pattern = grep_malloc(patterns * sizeof(*r_pattern));
@


1.37
log
@Check length before checking index of len - 1.

OK moritz@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.36 2006/09/26 15:55:17 jaredy Exp $	*/
a223 1
	int nl;
d227 2
a228 13
	nl = 0;
	while ((line = fgetln(f, &len)) != NULL) {
		if (*line == '\n') {
			++nl;
			continue;
		}
		if (nl) {
			matchall = 1;
			break;
		}
		nl = 0;
		add_pattern(line, len);
	}
d237 1
a237 1
	int c, lastc, prevoptind, newarg, i;
d274 1
d364 1
d370 1
d442 1
a442 1
	if (argc == 0 && patterns == 0)
d445 1
a445 1
	if (patterns == 0) {
@


1.36
log
@Allow zero-length patterns with -x so

  $ grep -x ""

matches empty lines as reported on misc@@ by
Martin Marusak <marusak@@fhpv.unipo.sk>.
Initial diff by otto@@ with tweaks by me.

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.35 2006/03/07 20:59:56 otto Exp $	*/
d179 1
a179 1
	if (pat[len - 1] == '\n')
@


1.35
log
@Break patterns containing newlines into multiple patterns like POSIX says.
Report by Ralf dot Wildenhues at gmx dot de;
testing by jmc@@ ok beck@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.34 2006/02/09 09:54:46 otto Exp $	*/
d171 1
a171 1
	if (len == 0 || matchall) {
d186 1
a186 1
		if (pat[len - 1] == '$')
@


1.34
log
@delint; remove redundant vars and functions; ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.33 2005/04/03 19:18:33 jaredy Exp $	*/
d207 12
d374 1
a374 1
			add_pattern(optarg, strlen(optarg));
d455 1
a455 1
		add_pattern(*argv, strlen(*argv));
@


1.33
log
@Make the processing of patterns collected from files specified by -f
delayed so options that affect pattern-building (such as -w) can be
applied evenly to all such patterns.

ok and help otto, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.32 2005/04/03 19:12:40 otto Exp $	*/
a69 1
int	 Vflag;		/* -V: display version information */
a98 1
int	 lead;		/* number of lines in leading context queue */
@


1.32
log
@Protect begin and end of word markers added to the pattern when
using the -w option with parentheses, to avoid operators in the
expressions binding to the markers. Compare [[:<:]]foo|bar[[:>:]]
and [[:<:]](foo|bar)[[:>:]]. Problem spotted by aaron@@; ok millert@@
aaron@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.31 2004/10/03 19:23:02 otto Exp $	*/
d32 1
d102 6
d209 1
a209 1
read_patterns(char *fn)
d240 1
d244 1
d367 3
a369 1
			read_patterns(optarg);
d433 7
@


1.31
log
@Remove block based mmap optimization. There are newline problems
(PR 3940, 3941) which can be fixed, but if a match starts at the
end of a block and continues into the next block, no match will be
found.  Measurements by millert@@ showed that the improvements of
this optimization are non-measurable anyway. Diff from Alexander Taler.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.30 2004/09/28 20:51:15 jmc Exp $	*/
d178 1
a178 1
		int bol = 0, eol = 0;
d183 8
a190 3
		pattern[patterns] = grep_malloc(len + 15);
		snprintf(pattern[patterns], len + 15, "%s[[:<:]]%.*s[[:>:]]%s",
		    bol ? "^" : "", (int)len - bol - eol, pat + bol,
d192 1
a192 1
		len += 14;
@


1.30
log
@various fixes to make this page a bit clearer and hopefully a bit
more helpful;

this includes some ideas/fixes from otto and jared;
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.29 2004/08/05 21:47:33 deraadt Exp $	*/
a99 2
int	 boleol;	/* At least one pattern has a bol or eol */
size_t	 maxPatternLen;	/* Longest length of all patterns */
a193 3

	if (len > maxPatternLen)
		maxPatternLen = len;
@


1.29
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.28 2004/05/07 14:51:42 millert Exp $	*/
d110 1
a110 1
	    "usage: %s [-AB num] [-CEFGHILPRSUVabchilnoqsvwx]\n"
d112 1
a112 1
	    "usage: %s [-AB num] [-CEFGHILPRSUVZabchilnoqsvwx]\n"
d114 2
a115 2
	    "\t[--context[=num]] [--binary-files=value] [--line-buffered]\n"
	    "\t[-e pattern] [-f file] [pattern] [file ...]\n", __progname);
@


1.28
log
@Add a new past path for fgrep that is just a simplified version of
fastcomp.  This makes fgrep faster and fixes the -w flag w/ fgrep.
Also remove free_patterns() since calling free right before exit
is silly.  Problem noticed by espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.27 2004/04/02 18:39:36 otto Exp $	*/
d452 1
a452 1
	
@


1.27
log
@Implement --line-buffered
ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.26 2004/02/04 18:38:52 millert Exp $	*/
d179 1
a179 1
	if (wflag) {
a228 18
static void
free_patterns(void)
{
	int i;

	for (i = 0; i < patterns; i++) {
		if (fg_pattern[i].pattern)
			free(fg_pattern[i].pattern);
		else
			regfree(&r_pattern[i]);
		free(pattern[i]);
	}

	free(fg_pattern);
	free(r_pattern);
	free(pattern);
}

a433 2
	else if (Fflag)
		cflags |= REG_NOSPEC;
d437 12
a448 7
		/* Check if cheating is allowed */
		if (fastcomp(&fg_pattern[i], pattern[i])) {
			/* Fall back to full regex library */
			if ((c = regcomp(&r_pattern[i], pattern[i], cflags))) {
				regerror(c, &r_pattern[i], re_error,
				    RE_ERROR_BUF);
				errx(2, "%s", re_error);
a466 2

	free_patterns();
@


1.26
log
@Fix anchors (^ or $) in -w mode broken by the last commit's -w overhaul.
With this change we pass the updated regress.  Tested and OK by ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.25 2004/01/25 21:36:00 millert Exp $	*/
d85 1
d92 2
a93 1
	MMAP_OPT
d114 1
a114 1
	    "\t[--context[=num]] [--binary-files=value]\n"
d130 1
d427 3
d467 3
@


1.25
log
@Previously, in -w mode, for each match on a line grep would check
to see if the match was on a word boundary.  However, this missed
lines where the first match was not on a word boundary but a
subsequent match was.  Problem originally spotted by miod@@

We fix this by using the [[:<:]] and [[:>:]] character classes for
the slow path and by checking the word boundaries in grep_search()
for the fast path instead of doing the checks after running
regexec() or grep_search().

With this change, grep passes the new regress tests 15 and 16.
problem originally spotted by espie@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.24 2003/12/11 20:49:20 mcbride Exp $	*/
d177 5
d183 4
a186 2
		snprintf(pattern[patterns], len + 15, "[[:<:]]%.*s[[:>:]]",
		    (int)len, pat);
@


1.24
log
@Sync usage() with SYNOPSIS in grep(1).

ok deraadt@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.23 2003/09/07 19:40:54 millert Exp $	*/
a174 1
	pattern[patterns] = grep_malloc(len + 1);
d176 9
a184 2
	memcpy(pattern[patterns], pat, len);
	pattern[patterns][len] = '\0';
@


1.23
log
@Fix "grep -number" support for multi-digit numbers.  At issue is
the fact that optind refers to the *next* argument to be consumed
by getopt(), not the current one.  This means we have to keep track
of when we are working with a new argv entry by hand.  OK hugh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.22 2003/07/16 19:08:21 millert Exp $	*/
d108 1
a108 1
	    "usage: %s [-[AB] num] [-CEFGHILPRSUVabchilnoqsvwx]"
d110 1
a110 1
	    "usage: %s [-[AB] num] [-CEFGHILPRSUVZabchilnoqsvwx]"
d112 2
a113 1
	    " [-e pattern] [-f file] [file ...]\n", __progname);
@


1.22
log
@When reallocing pattern, use sizeof(*pattern) not sizeof(int).
Fixes a problem on sparc64 where sizeof(int) != sizeof(pointer).
Based on a patch from Brian Poole; tedu@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.21 2003/07/14 23:22:35 millert Exp $	*/
d233 1
a233 1
	int c, lastc, prevoptind, i;
d266 2
a267 1
	prevoptind = 0;
d273 5
a277 6
			if (optind == prevoptind && isdigit(lastc)) {
				if (Aflag > INT_MAX / 10)
					errx(2, "context out of range");
				Aflag = Bflag = (Aflag * 10) + (c - '0');
			} else
				Aflag = Bflag = c - '0';
d415 1
a417 1

@


1.21
log
@range-check numeric arguments (-num, -A num, -B num)
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.20 2003/07/10 17:02:48 millert Exp $	*/
d170 1
a170 1
		pattern = grep_realloc(pattern, ++pattern_sz * sizeof(int));
d435 1
a435 1
	r_pattern = grep_malloc(patterns * sizeof(regex_t));
@


1.20
log
@grep should exit(2) on error, not exit(1) (1 means no matches found).
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.19 2003/07/10 16:51:12 deraadt Exp $	*/
d234 2
d272 3
a274 1
			if (optind == prevoptind && isdigit(lastc))
d276 1
a276 1
			else
a279 2
			Aflag = strtol(optarg, NULL, 10);
			break;
d281 8
a288 1
			Bflag = strtol(optarg, NULL, 10);
d293 7
a299 2
			else
				Aflag = Bflag = strtol(optarg, NULL, 10);
@


1.19
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.18 2003/07/10 16:49:12 millert Exp $	*/
d193 1
a193 1
		err(1, "%s", fn);
d208 1
a208 1
		err(1, "%s", fn);
d429 1
a429 1
				errx(1, "%s", re_error);
@


1.18
log
@Fix parsing of -NUMBER.  We now do things a digit at a time and
keep track of what the last char from getopt was as well as the
previous value of optind so we know when a new number has started.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.17 2003/06/25 17:28:00 millert Exp $	*/
d124 30
a153 30
	{"binary-files",        required_argument, NULL, BIN_OPT},
	{"help",                no_argument,       NULL, HELP_OPT},
	{"mmap",                no_argument,       NULL, MMAP_OPT},
	{"after-context",       required_argument, NULL, 'A'},
	{"before-context",      required_argument, NULL, 'B'},
	{"context",             optional_argument, NULL, 'C'},
	{"devices",             required_argument, NULL, 'D'},
	{"extended-regexp",     no_argument,       NULL, 'E'},
	{"fixed-strings",       no_argument,       NULL, 'F'},
	{"basic-regexp",        no_argument,       NULL, 'G'},
	{"binary",              no_argument,       NULL, 'U'},
	{"version",             no_argument,       NULL, 'V'},
	{"text",                no_argument,       NULL, 'a'},
	{"byte-offset",         no_argument,       NULL, 'b'},
	{"count",               no_argument,       NULL, 'c'},
	{"regexp",              required_argument, NULL, 'e'},
	{"file",                required_argument, NULL, 'f'},
	{"no-filename",         no_argument,       NULL, 'h'},
	{"ignore-case",         no_argument,       NULL, 'i'},
	{"files-without-match", no_argument,       NULL, 'L'},
	{"files-with-matches",  no_argument,       NULL, 'l'},
	{"line-number",         no_argument,       NULL, 'n'},
	{"quiet",               no_argument,       NULL, 'q'},
	{"silent",              no_argument,       NULL, 'q'},
	{"recursive",           no_argument,       NULL, 'r'},
	{"no-messages",         no_argument,       NULL, 's'},
	{"revert-match",        no_argument,       NULL, 'v'},
	{"word-regexp",         no_argument,       NULL, 'w'},
	{"line-regexp",         no_argument,       NULL, 'x'},
	{"unix-byte-offsets",   no_argument,       NULL, 'u'},
d155 1
a155 1
	{"decompress",          no_argument,       NULL, 'Z'},
d157 1
a157 1
	{NULL,                  no_argument,       NULL, 0}
@


1.17
log
@o remove useless cast to int from gzread() call
o maxPatternLen should be size_t since that's what it is compared against
o remove useless casts of NULL to various pointer types
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.16 2003/06/24 18:45:30 tedu Exp $	*/
d33 1
d233 1
a233 2
	char *tmp;
	int c, i;
d263 2
d270 2
a271 3
			tmp = argv[optind - 1];
			if (tmp[0] == '-' && tmp[1] == c && !tmp[2])
				Aflag = Bflag = strtol(++tmp, NULL, 10);
d273 1
a273 2
				Aflag = Bflag = strtol(argv[optind] + 1,
				    NULL, 10);
d400 2
@


1.16
log
@actually do fgrep.  -G -F and -E are now mutally exclusive, and override
the program name as expected.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.15 2003/06/23 22:32:48 tedu Exp $	*/
d98 1
a98 1
int	 maxPatternLen;	/* Longest length of all patterns */
d264 1
a264 1
				long_options, (int *)NULL)) != -1) {
d270 1
a270 1
				Aflag = Bflag = strtol(++tmp, (char **)NULL, 10);
d273 1
a273 1
				    (char **)NULL, 10);
d276 1
a276 1
			Aflag = strtol(optarg, (char **)NULL, 10);
d279 1
a279 1
			Bflag = strtol(optarg, (char **)NULL, 10);
d285 1
a285 1
				Aflag = Bflag = strtol(optarg, (char **)NULL, 10);
@


1.15
log
@strncpy -> memcpy per deraadt suggestion.
also add a note why we can't use strlcpy.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.14 2003/06/23 22:27:09 tedu Exp $	*/
d235 28
d288 1
d292 1
d296 1
d414 4
a417 29
	switch (__progname[0]) {
	case 'e':
		Eflag++;
		break;
	case 'f':
		Fflag++;
		break;
	case 'g':
		Gflag++;
		break;
#ifndef NOZ
	case 'z':
		Zflag++;
		switch(__progname[1]) {
		case 'e':
			Eflag++;
			break;
		case 'f':
			Fflag++;
			break;
		case 'g':
			Gflag++;
			break;
		}
		break;
#endif
	}

	cflags |= Eflag ? REG_EXTENDED : REG_BASIC;
@


1.14
log
@go back to using strncpy.  for long patterns, strlcpy reads too much
of a potentially nontermined src.
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.13 2003/06/23 22:05:23 tedu Exp $	*/
d174 2
a175 1
	strncpy(pattern[patterns], pat, len);
@


1.13
log
@faster grep for simple patterns.  derived from a patch by sean farley.
this makes searching for constant strings much faster by avoiding regex.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.12 2003/06/23 07:52:18 deraadt Exp $	*/
d174 2
a175 1
	strlcpy(pattern[patterns], pat, len + 1);
@


1.12
log
@minor tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.11 2003/06/23 03:23:40 tedu Exp $	*/
d52 1
d97 2
d169 1
a169 1
		pattern = grep_realloc(pattern, ++pattern_sz);
d176 3
d209 18
d320 1
d410 1
d413 8
a420 3
		if ((c = regcomp(&r_pattern[i], pattern[i], cflags))) {
			regerror(c, &r_pattern[i], re_error, RE_ERROR_BUF);
			errx(1, "%s", re_error);
d435 2
@


1.11
log
@use strlcpy, not strncpy.  ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.10 2003/06/23 02:02:41 tedu Exp $	*/
d218 2
a219 1
				Aflag = Bflag = strtol(argv[optind] + 1, (char **)NULL, 10);
@


1.10
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.9 2003/06/23 00:55:09 tedu Exp $	*/
d168 1
a168 1
	if (pat[len-1] == '\n')
d170 2
a171 3
	pattern[patterns] = grep_malloc(len+1);
	strncpy(pattern[patterns], pat, len);
	pattern[patterns][len] = '\0';
@


1.9
log
@better detetection/handling of binary files.
make -a do the right thing, doc and implement -U, -I.
add --help and --mmap for compatibility.
some other minor fixes.

some from NetBSD.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.7 2003/06/22 23:12:38 deraadt Exp $	*/
d93 1
a93 1
int	 first;		/* flag whether or not this is our fist match */
@


1.8
log
@use __progname instead of progname.  ok deraadt
@
text
@d30 1
a70 1
int	 aflag;		/* -a: only search ascii files */
d84 8
d104 1
a104 1
	    "usage: %s [-[AB] num] [-CEFGHLPRSVabchilnoqsvwx]"
d106 1
a106 1
	    "usage: %s [-[AB] num] [-CEFGHLPRSVZabchilnoqsvwx]"
d113 1
a113 1
static char *optstr = "0123456789A:B:CEFGHLPSRUVabce:f:hilnoqrsuvwxy";
d115 1
a115 1
static char *optstr = "0123456789A:B:CEFGHLPSRUVZabce:f:hilnoqrsuvwxy";
d120 3
a122 3
	{"basic-regexp",        no_argument,       NULL, 'G'},
	{"extended-regexp",     no_argument,       NULL, 'E'},
	{"fixed-strings",       no_argument,       NULL, 'F'},
d126 5
d132 1
a145 1
	{"text",                no_argument,       NULL, 'a'},
a148 1
	{"binary",              no_argument,       NULL, 'U'},
d245 3
d264 1
a264 2
		case 'u':
			/* these are here for compatability */
d268 1
a268 2
			fprintf(stderr, argv[0]);
			usage();
d276 1
a276 1
			aflag = 1;
d324 15
@


1.7
log
@fix usage
@
text
@d1 1
a1 1
/*	$OpenBSD: grep.c,v 1.6 2003/06/22 22:38:50 deraadt Exp $	*/
d89 1
a89 1
char	*progname;
d100 1
a100 1
	    " [-e pattern] [-f file] [file ...]\n", progname);
a197 5
	if ((progname = strrchr(*argv, '/')) != NULL)
		++progname;
	else
		progname = *argv;

d328 1
a328 1
	switch (*progname) {
d341 1
a341 1
		switch(progname[1]) {
@


1.6
log
@proper $OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d100 1
a100 1
	    " [-e patttern] [-f file]\n", progname);
@


1.5
log
@-DNOZ flag to be used by install media for removing z*grep support, if
needed.  (and knf)
@
text
@d1 2
a26 2
 *
 *	$Id$
@


1.4
log
@support z{e,f}grep
@
text
@d26 1
a26 1
 *	$Id: grep.c,v 1.3 2003/06/22 22:20:07 deraadt Exp $
d67 1
d69 1
d94 7
a100 4
	fprintf(stderr, "usage: %s %s %s\n",
		progname,
		"[-[AB] num] [-CEFGHLPRSVZabchilnoqsvwx]",
		"[-e patttern] [-f file]");
d104 3
d108 1
d110 1
a110 1
struct option long_options[] = 
d138 1
d140 1
a140 1
	
d203 1
a203 1
	while ((c = getopt_long(argc, argv, optstr, 
d221 1
a221 1
			if (optarg == NULL) 
d262 1
d266 1
d332 1
a332 1
	
d343 1
d358 1
d375 1
a375 1
	
@


1.3
log
@freegrep 0.16
@
text
@d26 1
a26 1
 *	$Id$
d333 11
@


1.2
log
@Fix format string bug.  I believe this grep is currently not used (in
favor of the GNU version), but it gets fixed anyways.  ok mickey@@
@
text
@a0 2
/*	$OpenBSD: grep.c,v 1.1 2001/09/21 23:12:00 deraadt Exp $	*/

d2 2
a3 2
 * Copyright (c) 2000 Carson Harding. All rights reserved.
 * This code was written and contributed to OpenBSD by Carson Harding.
a12 3
 * 3. Neither the name of the author, or the names of contributors may be 
 *    used to endorse or promote products derived from this software without
 *    specific prior written permission.
d25 2
d29 2
a30 3
#ifndef lint
static char rcsid[] = "$OpenBSD: grep.c,v 1.1 2001/09/21 23:12:00 deraadt Exp $";
#endif /* not lint */
d32 4
a35 1
#include <sys/types.h>
d38 1
a39 6
#include <regex.h>
#include <string.h>
#include <ctype.h>
#include <sys/param.h>
#include <fts.h>
#include <err.h>
d41 93
a133 1
extern	char *__progname;
d135 18
d154 27
a180 36
void	usage(void);
void	err_regerror(int r, regex_t *rexp);
int	grep_files(int regexc, regex_t *regexv, char **files);
int	grep_tree(int regexc, regex_t *regexv, char **paths);
int	grep_file(int regexc, regex_t *rexp, char *fname);
void	arg_patt(char *s);
char	*chop_patt(char *s, size_t *len);
void	add_patt(char *s, size_t len);
void	load_patt(char *fname);
regex_t *regcomp_patt(int pattc, char *pattvp[], int cflags);


int	f_bytecount;		/* -b prepend byte count */
int	f_countonly;		/* -c return only count */
int	f_nofname;		/* -h do not prepend filenames on multiple */
int	f_fnameonly;		/* -l only print file name with match */
int	f_suppress;		/* -s suppress error messages; 1/2 -q */
int	f_lineno;		/* -n prepend with line numbers */
int	f_quiet;		/* -q no output, only status */
int	f_wmatch;		/* -w match words */
int	f_xmatch;		/* -x match line */
int	f_zerobyte;		/* -z NUL character after filename with -l */
int	f_match;		/* = REG_MATCH; else = REG_NOMATCH for -v */
int	f_multifile;		/* multiple files: prepend file names */
int	f_matchall;		/* empty pattern, matches all input */
int	f_error;		/* saw error; set exit status */

				/* default traversal flags */
int	f_ftsflags = FTS_LOGICAL|FTS_NOCHDIR|FTS_NOSTAT;

int	f_debug;		/* temporary debugging flag */

#define START_PATT_SZ	 8	/* start with room for 8 patterns */
char	**pattv;		/* array of patterns from -e and -f */
int	pattc;			/* patterns in pattern array */
int	pattn;			/* patterns we have seen, including nulls */
d183 1
a183 1
main(int argc, char **argv)
d185 30
a214 21
	int	c;
	int	ch;
	int	cflags;		/* flags to regcomp() */
	int	sawfile;	/* did we see a pattern file? */
	regex_t *regexv;	/* start of array of compiled patterns */

	int (*grepf)(int regexc, regex_t *regexv, char **argv);

	sawfile = 0;
	cflags	= REG_BASIC|REG_NEWLINE;
	grepf	= grep_files;

	if (*__progname == 'e')
		cflags |= REG_EXTENDED;
	else if (*__progname == 'f')
		cflags |= REG_NOSPEC;

	while ((ch = getopt(argc, argv, "DEFRHLPXabce:f:hilnqsvwxz")) != -1) {
		switch(ch) {
		case 'D':
			f_debug = 1;
d217 1
a217 1
			cflags |= REG_EXTENDED;
d220 4
a223 1
			cflags |= REG_NOSPEC;
d226 1
a226 1
			f_ftsflags |= FTS_COMFOLLOW;
d229 2
a230 1
			f_ftsflags |= FTS_LOGICAL;
d233 4
a236 1
			f_ftsflags |= FTS_PHYSICAL;
d239 12
a250 7
			grepf = grep_tree;
			/* 
			 * If walking the tree we don't know how many files
			 * we'll actually find. So assume multiple, if
			 * you don't want names, there's always -h ....
			 */
			f_multifile = 1;
d252 2
a253 2
		case 'X':
			f_ftsflags |= FTS_XDEV;
d256 1
a256 4
			/* 
			 * Silently eat -a; we don't use the default
			 * behaviour it toggles off in gnugrep.
			 */
d259 1
a259 1
			f_bytecount = 1;
d262 1
a262 1
			f_countonly = 1;
d265 1
a265 1
			arg_patt(optarg);
d268 1
a268 2
			load_patt(optarg);
			sawfile = 1;
d271 2
a272 1
			f_nofname = 1;
d275 1
d279 2
a280 1
			f_fnameonly = 1;
d283 5
a287 1
			f_lineno = 1;
d290 1
a290 1
			f_quiet = 1;
d293 1
a293 1
			f_suppress = 1;
d296 1
a296 1
			f_match = REG_NOMATCH;
d299 1
a299 1
			f_wmatch = 1;
d302 1
a302 4
			f_xmatch = 1;
			break;
		case 'z':
			f_zerobyte = 1;
a305 1
			break;
d309 4
a312 1
	if ((cflags & REG_EXTENDED) && (cflags & REG_NOSPEC))
d315 27
a341 83
	/*
	 * If we read one or more pattern files, and still 
	 * didn't end up with any pattern, any pattern file 
	 * we read was empty. This is different than failing
	 * to provide a pattern as an argument, and we fail
	 * on this case as if we had searched and found
	 * no matches. (At least this is what GNU grep and
	 * Solaris's grep do.)
	 */
	if (!pattn && !argv[optind]) {
		if (sawfile)
			exit(1);
		else usage();
	}

	if (!pattn) {
		arg_patt(argv[optind]);
		optind++;
	}

	/* why bother ... just do nothing sooner */
	if (f_matchall && f_match == REG_NOMATCH)
		exit(1);

	regexv = regcomp_patt(pattc, pattv, cflags);

	if (optind == argc) {
		c = grep_file(pattc, regexv, NULL);
	} else {
		if (argc - optind > 1 && !f_nofname)
			f_multifile = 1;
		c = (*grepf)(pattc, regexv, &argv[optind]);
	}

	/* XX ugh */
	if (f_error) {
		if (c && f_quiet) 
			exit(0);
		else
			exit(2);
	} else if (c) 
		exit(0);
	else
		exit(1);
}

void
usage(void)
{
	fprintf(stderr, "usage: %s [-E|-F] [-abchilnqsvwx] [-RXH[-L|-P]]"
	    " {patt | -e patt | -f patt_file} [files]\n", 
	    __progname);
	exit(2);
}

/*
 * Patterns as arguments may have embedded newlines.
 * When read from file, these are detected by fgetln();
 * in arguments we have to find and cut out the segments.
 */
void
arg_patt(char *s)
{
	size_t len;
	char *sp;

	if (f_debug)
		fprintf(stderr, "arg_patt(\"%s\")\n", s);

	len = strlen(s);
	if (!len) {		     /* got "" on the command-line */
		add_patt(s, len);
		return;
	}
	for (sp = chop_patt(s, &len); sp; sp = chop_patt(NULL, &len)) {
		if (f_debug) {
			fprintf(stderr, "adding pattern \"");
			fwrite(sp, len, 1, stderr);
			fprintf(stderr, "\", length %lu\n",(unsigned long)len);
			if (pattc > 20) {
				fprintf(stderr, "too many, exiting ...\n");
				exit(2);
			}
a342 1
		add_patt(sp, len);
a343 1
}
d345 2
a346 10
/* 
 * Kind of like strtok; pass char *, then NULL for rest.
 * Call it memtok()... New size gets written into len.
 */
char *
chop_patt(char *s, size_t *len)
{
	char	*cp;
	static	char *save_s;
	static	int   save_n;
d348 5
a352 2
	if (s)
		save_n = *len;
d354 2
a355 1
		s = save_s;
d357 1
a357 133
	if (save_n <= 0) {
		s = save_s = NULL;
	} else if (s) {
		if ((cp = memchr(s, '\n', save_n)) != NULL) {
			*len = cp - s;	/* returned segment */
			save_n -= *len;
			save_s = ++cp;	/* adjust past newline */
			save_n--;
		} else {
			*len = save_n;	/* else return the whole string */
			save_n = 0;
		}
	}

	return s;
}

/*
 * Start with an array for 8 patterns, and double it 
 * each time we outgrow it. If pattern is empty (0 length),
 * or if f_matchall is already set, set f_matchall and return.
 * No use adding a pattern if all input is going to match
 * anyhow.
 */
void
add_patt(char *s, size_t len)
{
	char	*p;
	static	size_t	pattmax = START_PATT_SZ;
	static size_t sumlen;

	pattn++;
	sumlen += len;

	if (!len || f_matchall) {
		f_matchall = 1;
		return;
	}

	if (!pattv) { 
		pattv = malloc(START_PATT_SZ * sizeof(char *));
		if (!pattv)
			err(2, "malloc");
		pattc = 0;
	} else if (pattc >= pattmax) {
		pattmax *= 2;
		pattv = realloc(pattv, pattmax * sizeof(char *));
		if (!pattv)
			err(2, "realloc");
	}
	p = malloc(len+1);
	if (!p) err(2, "malloc");
	memmove(p, s, len);
	p[len] = '\0';
	pattv[pattc++] = p;
}

/*
 * Load patterns from file.
 */
void
load_patt(char *fname)
{
	char	*buf;
	size_t	len;
	FILE	*fr;

	fr = fopen(fname, "r");
	if (!fr)
		err(2, "%s", fname);
	while ((buf = fgetln(fr, &len)) != NULL) {
		if (buf[len-1] == '\n')
			buf[--len] = '\0';
		add_patt(buf, len);
	}
	fclose(fr);
}

/*
 * Compile the collected pattern strings into an array
 * of regex_t.
 */
regex_t *
regcomp_patt(int lpattc, char *lpattv[], int cflags)
{
	int	i;
	int	r;
	regex_t *rxv;

	if (f_matchall)
		return NULL;

	rxv = malloc(sizeof(regex_t) * lpattc);
	if (!rxv)
		err(2, "malloc");
	for (i = 0; i < lpattc; i++) {
		if ((r = regcomp(&rxv[i], lpattv[i], cflags)) != 0)
			err_regerror(r, &rxv[i]);
	}
	return rxv;
}

/*
 * Print out regcomp error, and exit.
 */
void
err_regerror(int r, regex_t *rexp)
{
	size_t	n;
	char	*buf;

	n = regerror(r, rexp, NULL, 0);
	buf = malloc(n);
	if (!buf)
		err(2, "malloc");
	(void)regerror(r, rexp, buf, n);
	errx(2, "%s", buf);
}

/* 
 * Little wrapper so we can use function pointer above.
 */
int
grep_files(int regexc, regex_t *regexv, char **files)
{
	int	c;
	char	**fname;

	c = 0;
	for (fname = files; *fname; fname++)
		c += grep_file(regexc, regexv, *fname);

	return c;
a358 161

/* 
 * Modified from James Howard and Dag-Erling Co?dan Sm?rgrav's grep:
 * add FTS_D to FTS_DP (especially since D was the one being used)
 * pass in regex_t array, and set fts flags above in main().
 */
int 
grep_tree(int regexc, regex_t *regexv, char **paths)
{
	int	c;
	FTS	*fts;
	FTSENT	*p;

	c = 0;

	if (!(fts = fts_open(paths, f_ftsflags, (int (*) ()) NULL)))
		err(2, "fts_open");
	while ((p = fts_read(fts)) != NULL) {
		switch (p->fts_info) {
		case FTS_D:
		case FTS_DP:
		case FTS_DNR:
			break;
		case FTS_ERR:
			errx(2, "%s: %s", p->fts_path, strerror(p->fts_errno));
			break;
		default:
			if (f_debug) 
				printf("%s\n", p->fts_path);
			c += grep_file(regexc, regexv, p->fts_path);
			break;
		}
	}

	return c;
}

/*
 * Open and grep the named file. If fname is NULL, read
 * from stdin. 
 */

#define isword(x) (isalnum(x) || (x) == '_')

int
grep_file(int regexc, regex_t *regexv, char *fname)
{
	int	i;
	int	c;
	int	n;
	int	r;
	int	match;
	char	*buf;
	size_t	b;
	size_t	len;
	FILE	*fr;
	regmatch_t pmatch[1];
	regoff_t   so, eo;

	b = 0;		/* byte count */
	c = 0;		/* match count */
	n = 0;		/* line count */

	if (!fname) {
		fr = stdin;
		fname = "(standard input)";
	} else {
		fr = fopen(fname, "r");
		if (!fr) {
			if (!f_suppress)
				warn("%s", fname);
			f_error = 1;
			return 0;
		}
	}

	while ((buf = fgetln(fr, &len)) != NULL) {
		n++;
		if (f_matchall)
			goto printmatch;
		match = 0;
		for (i = 0; i < regexc; i++) {
			pmatch[0].rm_so = 0;
			pmatch[0].rm_eo = len-1;
			r = regexec(&regexv[i], buf, 1, pmatch, REG_STARTEND);
			if (r == f_match) {
				/*
				 * XX gnu grep allows both -w and -x;
				 * XX but seems bizarre. sometimes -w seems
				 * XX to override, at other times, not.
				 * XX Need to figure that out.
				 * XX It seems logical to go with the most
				 * XX restrictive argument: -x, as -x is
				 * XX a boundary case of -w anyhow. 
				 */
				if (f_xmatch) {
					if (pmatch[0].rm_so != 0 ||
					    pmatch[0].rm_eo != len-1)
						continue;
				} else if (f_wmatch) {
					so = pmatch[0].rm_so;
					eo = pmatch[0].rm_eo;
					if (!((so == 0 || !isword(buf[so-1])) &&
					    (eo == len || !isword(buf[eo]))))
						continue;
				} 
				match = 1;
				break;
			}
			/* XX test for regexec() errors ?? */
		}
		if (match) {
printmatch:
			c++;
			if (f_fnameonly || f_quiet)
				break;
			if (f_countonly)
				continue;
			if (f_multifile && !f_nofname)
				printf("%s:", fname);
			if (f_lineno)
				printf("%d:", n);
			if (f_bytecount)
				printf("%lu:", (unsigned long)b);
			fwrite(buf, len, 1, stdout);
		}
		/* save position in stream before next line */
		b += len;
	}

	if (!buf && ferror(fr)) {
		warn("%s", fname);
		f_error = 1;
		/* 
		 * XX or do we spit out what result we did have?
		 */
	} else if (!f_quiet) {
		/*
		 * XX test -c and -l together: gnu grep
		 * XX allows (although ugly), do others?
		 */
		if (f_countonly) {
			if (f_multifile)
				printf("%s:", fname);
			printf("%d\n", c);
		}
		if (c && f_fnameonly) {
			fputs(fname, stdout);
			if (f_zerobyte)
				fputc('\0', stdout);
			else 
				fputc('\n', stdout);
		}
	}

	if (fr != stdin)
		fclose(fr);

	return c;
}

@


1.1
log
@complete grep clone by harding@@motd.ca; everything is there, but it is
slow because libc regexp is slow.  Anyone out there have the balls to sit
down and optimize libc regexp?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 1
a33 1
static char rcsid[] = "$OpenBSD$";
d370 1
a370 1
		err(2, fname);
@

