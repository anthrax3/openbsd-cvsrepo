head	1.25;
access;
symbols
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.8
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.4
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.6
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.16.0.6
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.16
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.14
	OPENBSD_2_8:1.6.0.12
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.10
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.8
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2015.02.12.23.31.12;	author claudio;	state Exp;
branches;
next	1.24;
commitid	subnpd857rOYrBI2;

1.24
date	2015.02.09.12.25.03;	author claudio;	state Exp;
branches;
next	1.23;
commitid	83gy3puTH63xWYWh;

1.23
date	2015.01.16.06.40.10;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	Uu5nFG3wCl0LACBb;

1.22
date	2014.08.14.12.34.04;	author mpi;	state Exp;
branches;
next	1.21;
commitid	isX7L94Rk3C0rXQv;

1.21
date	2014.06.23.03.46.17;	author guenther;	state Exp;
branches;
next	1.20;
commitid	uXnRK9VvnFZsAqfW;

1.20
date	2013.04.18.15.44.01;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.13.19.13.41;	author michele;	state Exp;
branches;
next	1.18;

1.18
date	2009.02.07.15.06.04;	author chl;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.14.18.35.46;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.27.19.16.37;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.17.19.09.36;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.30.07.50.11;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.25.17.01.04;	author jaredy;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.14.15.00.44;	author mcbride;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.07.21.36.52;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.03.02.56.13;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.01.01.51.31;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.02.15.49.05;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	98.02.27.12.07.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.06.29.21.46.03;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.06.29.20.18.02;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.37.23;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.24.09.18.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.51;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.51;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Free the buffers used for the sysctl. OK sthen@@
@
text
@/*	$OpenBSD: mroute.c,v 1.24 2015/02/09 12:25:03 claudio Exp $	*/
/*	$NetBSD: mroute.c,v 1.10 1996/05/11 13:51:27 mycroft Exp $	*/

/*
 * Copyright (c) 1989 Stephen Deering
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Stephen Deering of Stanford University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)mroute.c	8.1 (Berkeley) 6/6/93
 */

/*
 * Print multicast routing structures and statistics.
 *
 * MROUTING 1.0
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/sysctl.h>

#include <netinet/in.h>
#include <netinet/igmp.h>
#include <netinet/ip_mroute.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <util.h>
#include "netstat.h"

void
mroutepr(void)
{
	u_int mrtproto;
	struct vifinfo *v;
	struct mfcinfo *m;
	size_t needed, numvifs, nummfcs, vifi, mfci;
	char *buf = NULL;
	char fmtbuf[FMT_SCALED_STRSIZE];
	vifi_t maxvif = 0;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_IP, IPCTL_MRTPROTO };
	size_t len = sizeof(int);
	int banner_printed = 0, saved_nflag;

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &mrtproto, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("mroute");
		return;
	}
	switch (mrtproto) {
	case 0:
		printf("no multicast routing compiled into this system\n");
		return;
	case IGMP_DVMRP:
		break;
	default:
		printf("multicast routing protocol %u, unknown\n", mrtproto);
		return;
	}

	saved_nflag = nflag;
	nflag = 1;

	mib[3] = IPCTL_MRTVIF;
	needed = get_sysctl(mib, sizeof(mib) / sizeof(mib[0]), &buf);
	numvifs = needed / sizeof(*v);
	v = (struct vifinfo *)buf;
	if (numvifs)
		maxvif = v[numvifs - 1].v_vifi;

	for (vifi = 0; vifi < numvifs; ++vifi, ++v) {
		if (!banner_printed) {
			printf("\nVirtual Interface Table\n %s%s",
			    "Vif  Thresh  Limit  Local-Address    ",
			    "Remote-Address   Pkt_in  Pkt_out\n");
			banner_printed = 1;
		}

		printf(" %3u     %3u  %-15.15s",
		    v->v_vifi, v->v_threshold,
		    routename4(v->v_lcl_addr.s_addr));
		printf("  %-15.15s  %6lu  %7lu\n", (v->v_flags & VIFF_TUNNEL) ?
		    routename4(v->v_rmt_addr.s_addr) : "",
		    v->v_pkt_in, v->v_pkt_out);
	}
	if (!banner_printed)
		printf("Virtual Interface Table is empty\n");

	banner_printed = 0;

	mib[3] = IPCTL_MRTMFC;
	needed = get_sysctl(mib, sizeof(mib) / sizeof(mib[0]), &buf);
	nummfcs = needed / sizeof(*m);
	m = (struct mfcinfo *)buf;

	for (mfci = 0; mfci < nummfcs; ++mfci, ++m) {
		if (!banner_printed) {
			printf("\nMulticast Forwarding Cache\n %s%s",
			    "Hash  Origin           Mcastgroup       ",
			    "Traffic  In-Vif  Out-Vifs/Forw-ttl\n");
			banner_printed = 1;
		}

		printf("  %3zu  %-15.15s",
		    mfci, routename4(m->mfc_origin.s_addr));
		fmt_scaled(m->mfc_pkt_cnt, fmtbuf);
		printf("  %-15.15s  %7s     %3u ",
		    routename4(m->mfc_mcastgrp.s_addr),
		    buf, m->mfc_parent);
		for (vifi = 0; vifi <= maxvif; ++vifi)
			if (m->mfc_ttls[vifi])
				printf(" %zu/%u", vifi, m->mfc_ttls[vifi]);

		printf("\n");
	}
	if (!banner_printed)
		printf("Multicast Forwarding Cache is empty\n");
	else
		printf("\nTotal no. of entries in cache: %zu\n", nummfcs);

	printf("\n");
	nflag = saved_nflag;

	free(buf);
}

void
mrt_stats(void)
{
	u_int mrtproto;
	struct mrtstat mrtstat;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_IP, IPCTL_MRTPROTO };
	int mib2[] = { CTL_NET, PF_INET, IPPROTO_IP, IPCTL_MRTSTATS };
	size_t len = sizeof(int);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &mrtproto, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("mroute");
		return;
	}
	switch (mrtproto) {
	case 0:
		printf("no multicast routing compiled into this system\n");
		return;

	case IGMP_DVMRP:
		break;

	default:
		printf("multicast routing protocol %u, unknown\n", mrtproto);
		return;
	}

	len = sizeof(mrtstat);
	if (sysctl(mib2, sizeof(mib2) / sizeof(mib2[0]),
	    &mrtstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("mroute");
		return;
	}

	printf("multicast routing:\n");
	printf("\t%lu datagram%s with no route for origin\n",
	    mrtstat.mrts_no_route, plural(mrtstat.mrts_no_route));
	printf("\t%lu upcall%s made to mrouted\n",
	    mrtstat.mrts_upcalls, plural(mrtstat.mrts_upcalls));
	printf("\t%lu datagram%s with malformed tunnel options\n",
	    mrtstat.mrts_bad_tunnel, plural(mrtstat.mrts_bad_tunnel));
	printf("\t%lu datagram%s with no room for tunnel options\n",
	    mrtstat.mrts_cant_tunnel, plural(mrtstat.mrts_cant_tunnel));
	printf("\t%lu datagram%s arrived on wrong interface\n",
	    mrtstat.mrts_wrong_if, plural(mrtstat.mrts_wrong_if));
	printf("\t%lu datagram%s dropped due to upcall Q overflow\n",
	    mrtstat.mrts_upq_ovflw, plural(mrtstat.mrts_upq_ovflw));
	printf("\t%lu datagram%s dropped due to upcall socket overflow\n",
	    mrtstat.mrts_upq_sockfull, plural(mrtstat.mrts_upq_sockfull));
	printf("\t%lu datagram%s cleaned up by the cache\n",
	    mrtstat.mrts_cache_cleanups, plural(mrtstat.mrts_cache_cleanups));
	printf("\t%lu datagram%s dropped selectively by ratelimiter\n",
	    mrtstat.mrts_drop_sel, plural(mrtstat.mrts_drop_sel));
	printf("\t%lu datagram%s dropped - bucket Q overflow\n",
	    mrtstat.mrts_q_overflow, plural(mrtstat.mrts_q_overflow));
	printf("\t%lu datagram%s dropped - larger than bkt size\n",
	    mrtstat.mrts_pkt2large, plural(mrtstat.mrts_pkt2large));
}
@


1.24
log
@Get rid of another KVM reader and convert the multicast output to use
the new sysctls. Looks good deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.23 2015/01/16 06:40:10 deraadt Exp $	*/
d154 2
@


1.23
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.22 2014/08/14 12:34:04 mpi Exp $	*/
a46 2
#include <sys/socketvar.h>
#include <sys/protosw.h>
a48 2
#include <net/if.h>
#include <net/route.h>
a50 1
#define _KERNEL
a51 1
#undef _KERNEL
d58 1
a60 20
static char *
pktscale(u_long n)
{
	static char buf[8];
	char t;

	if (n < 1024)
		t = ' ';
	else if (n < 1024 * 1024) {
		t = 'k';
		n /= 1024;
	} else {
		t = 'm';
		n /= 1048576;
	}

	snprintf(buf, sizeof buf, "%lu%c", n, t);
	return (buf);
}

d62 1
a62 1
mroutepr(u_long mfchashtbladdr, u_long mfchashaddr, u_long vifaddr)
d65 6
a70 5
	LIST_HEAD(, mfc) *mfchashtbl;
	u_long mfchash;
	struct vif viftable[MAXVIFS], *v;
	struct mfc *mfcp, mfc;
	vifi_t vifi;
d73 1
a73 2
	int i, banner_printed = 0, saved_nflag, numvifs = 0;
	int nmfc;		/* No. of cache entries */
a91 13
	if (mfchashtbladdr == 0) {
		printf("mfchashtbl: symbol not in namelist\n");
		return;
	}
	if (mfchashaddr == 0) {
		printf("mfchash: symbol not in namelist\n");
		return;
	}
	if (vifaddr == 0) {
		printf("viftable: symbol not in namelist\n");
		return;
	}

d95 6
a100 6
	kread(vifaddr, &viftable, sizeof(viftable));

	for (vifi = 0, v = viftable; vifi < MAXVIFS; ++vifi, ++v) {
		if (v->v_lcl_addr.s_addr == 0)
			continue;
		numvifs = vifi;
d102 1
d111 1
a111 1
		    vifi, v->v_threshold,
a119 2
	kread(mfchashtbladdr, &mfchashtbl, sizeof(mfchashtbl));
	kread(mfchashaddr, &mfchash, sizeof(mfchash));
a120 1
	nmfc = 0;
d122 4
a125 22
	if (mfchashtbl != 0)
		for (i = 0; i <= mfchash; ++i) {
			kread((u_long)&mfchashtbl[i], &mfcp, sizeof(mfcp));

			for (; mfcp != 0; mfcp = LIST_NEXT(&mfc, mfc_hash)) {
				if (!banner_printed) {
					printf("\nMulticast Forwarding Cache\n %s%s",
					    "Hash  Origin           Mcastgroup       ",
					    "Traffic  In-Vif  Out-Vifs/Forw-ttl\n");
					banner_printed = 1;
				}

				kread((u_long)mfcp, &mfc, sizeof(mfc));
				printf("  %3u  %-15.15s",
				    i, routename4(mfc.mfc_origin.s_addr));
				printf("  %-15.15s  %7s     %3u ",
				    routename4(mfc.mfc_mcastgrp.s_addr),
				    pktscale(mfc.mfc_pkt_cnt), mfc.mfc_parent);
				for (vifi = 0; vifi <= numvifs; ++vifi)
					if (mfc.mfc_ttls[vifi])
						printf(" %u/%u", vifi,
						    mfc.mfc_ttls[vifi]);
d127 17
a143 1
				printf("\n");
d145 2
a146 3
				nmfc++;
			}
		}
d150 1
a150 1
		printf("\nTotal no. of entries in cache: %d\n", nmfc);
@


1.22
log
@Kill bandwidth monitoring meters.
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.21 2014/06/23 03:46:17 guenther Exp $	*/
d45 1
a45 1
#include <sys/param.h>
@


1.21
log
@The second level of the CTL_NET sysctl is a PF_*, not an AF_*

inconsistent usage in route(8) noted by Gregor Best (gbe (at) ring0.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.20 2013/04/18 15:44:01 deraadt Exp $	*/
a65 2
static void print_bw_meter(struct bw_meter *bw_meter, int *banner_printed);

a186 20
				/* Print the bw meter information */
				{
					struct bw_meter bw_meter, *bwm;
					int banner_printed2 = 0;

					bwm = mfc.mfc_bw_meter;
					while (bwm) {
						kread((u_long)bwm,
						    &bw_meter,
						    sizeof bw_meter);
						print_bw_meter(&bw_meter,
						    &banner_printed2);
						bwm = bw_meter.bm_mfc_next;
					}
#if 0	/* Don't ever print it? */
					if (! banner_printed2)
						printf("\n  No Bandwidth Meters\n");
#endif
				}

a196 77
}

static void
print_bw_meter(struct bw_meter *bw_meter, int *banner_printed)
{
	char s0[256], s1[256], s2[256], s3[256];
	struct timeval now, end, delta;

	gettimeofday(&now, NULL);

	if (! *banner_printed) {
		printf(" Bandwidth Meters\n");
		printf("  %-30s", "Measured(Start|Packets|Bytes)");
		printf(" %s", "Type");
		printf("  %-30s", "Thresh(Interval|Packets|Bytes)");
		printf(" Remain");
		printf("\n");
		*banner_printed = 1;
	}

	/* The measured values */
	if (bw_meter->bm_flags & BW_METER_UNIT_PACKETS)
		snprintf(s1, sizeof s1, "%llu",
			 bw_meter->bm_measured.b_packets);
	else
		snprintf(s1, sizeof s1, "?");
	if (bw_meter->bm_flags & BW_METER_UNIT_BYTES)
		snprintf(s2, sizeof s2, "%llu", bw_meter->bm_measured.b_bytes);
	else
		snprintf(s2, sizeof s2, "?");
	snprintf(s0, sizeof s0, "%lld.%ld|%s|%s",
		 (long long)bw_meter->bm_start_time.tv_sec,
		 bw_meter->bm_start_time.tv_usec,
		 s1, s2);
	printf("  %-30s", s0);

	/* The type of entry */
	snprintf(s0, sizeof s0, "%s", "?");
	if (bw_meter->bm_flags & BW_METER_GEQ)
		snprintf(s0, sizeof s0, "%s", ">=");
	else if (bw_meter->bm_flags & BW_METER_LEQ)
		snprintf(s0, sizeof s0, "%s", "<=");
	printf("  %-3s", s0);

	/* The threshold values */
	if (bw_meter->bm_flags & BW_METER_UNIT_PACKETS)
		snprintf(s1, sizeof s1, "%llu",
			 bw_meter->bm_threshold.b_packets);
	else
		snprintf(s1, sizeof s1, "?");
	if (bw_meter->bm_flags & BW_METER_UNIT_BYTES)
		snprintf(s2, sizeof s2, "%llu",
			 bw_meter->bm_threshold.b_bytes);
	else
		snprintf(s2, sizeof s2, "?");
	snprintf(s0, sizeof s0, "%lld.%ld|%s|%s",
		 (long long)bw_meter->bm_threshold.b_time.tv_sec,
		 bw_meter->bm_threshold.b_time.tv_usec,
		 s1, s2);
	printf("  %-30s", s0);

	/* Remaining time */
	timeradd(&bw_meter->bm_start_time,
		 &bw_meter->bm_threshold.b_time, &end);
	if (timercmp(&now, &end, <=)) {
		timersub(&end, &now, &delta);
		snprintf(s3, sizeof s3, "%lld.%ld",
			 (long long)delta.tv_sec, delta.tv_usec);
	} else {
		/* Negative time */
		timersub(&now, &end, &delta);
		snprintf(s3, sizeof s3, "-%lld.%ld",
			 (long long)delta.tv_sec, delta.tv_usec);
	}
	printf(" %s", s3);

	printf("\n");
@


1.20
log
@improve time_t handling here, too
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.19 2009/07/13 19:13:41 michele Exp $	*/
d97 1
a97 1
	int mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_MRTPROTO };
d303 2
a304 2
	int mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_MRTPROTO };
	int mib2[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_MRTSTATS };
@


1.19
log
@Token bucket filter has been killed.

ok claudio@@ henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.18 2009/02/07 15:06:04 chl Exp $	*/
d249 2
a250 2
	snprintf(s0, sizeof s0, "%lu.%lu|%s|%s",
		 bw_meter->bm_start_time.tv_sec,
d274 2
a275 2
	snprintf(s0, sizeof s0, "%lu.%lu|%s|%s",
		 bw_meter->bm_threshold.b_time.tv_sec,
d285 2
a286 2
		snprintf(s3, sizeof s3, "%lu.%lu",
			 delta.tv_sec, delta.tv_usec);
d290 2
a291 2
		snprintf(s3, sizeof s3, "-%lu.%lu",
			 delta.tv_sec, delta.tv_usec);
@


1.18
log
@add missing headers needed for warn() and err().

ok claudio@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.17 2007/12/14 18:35:46 deraadt Exp $	*/
d149 2
a150 2
		printf(" %3u     %3u  %5u  %-15.15s",
		    vifi, v->v_threshold, v->v_rate_limit,
@


1.17
log
@remove 21 nlist variables, and instead use sysctl to query the kernel
turn on INET6 the default (remove the #ifdef's)
ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.16 2006/05/27 19:16:37 claudio Exp $	*/
d59 2
a63 1
#include <errno.h>
@


1.16
log
@Moving netstat from kvm snooping to retrieving the routing tables via
sysctl. Most code is stolen from route -- which was stolen from netstat.
kvm snooping code is still in and useable. Put it in deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.15 2005/10/17 19:09:36 otto Exp $	*/
d49 1
d62 1
d88 1
a88 1
mroutepr(u_long mrpaddr, u_long mfchashtbladdr, u_long mfchashaddr, u_long vifaddr)
d93 1
a93 1
	struct vif viftable[MAXVIFS];
a94 1
	struct vif *v;
d96 3
a98 4
	int i;
	int banner_printed;
	int saved_nflag;
	int numvifs;
d101 4
a104 2
	if (mrpaddr == 0) {
		printf("ip_mrtproto: symbol not in namelist\n");
a106 2

	kread(mrpaddr, &mrtproto, sizeof(mrtproto));
a110 1

a112 1

a134 2
	banner_printed = 0;
	numvifs = 0;
d156 1
a156 1
		printf("\nVirtual Interface Table is empty\n");
d212 1
a212 1
		printf("\nMulticast Forwarding Cache is empty\n");
d298 1
a298 1
mrt_stats(u_long mrpaddr, u_long mstaddr)
d302 8
a309 3

	if (mrpaddr == 0) {
		printf("ip_mrtproto: symbol not in namelist\n");
a311 2

	kread(mrpaddr, &mrtproto, sizeof(mrtproto));
d325 5
a329 2
	if (mstaddr == 0) {
		printf("mrtstat: symbol not in namelist\n");
a332 1
	kread(mstaddr, &mrtstat, sizeof(mrtstat));
@


1.15
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.14 2005/03/30 07:50:11 deraadt Exp $	*/
d154 1
a154 1
		    routename(v->v_lcl_addr.s_addr));
d156 1
a156 1
		    routename(v->v_rmt_addr.s_addr) : "",
d181 1
a181 1
				    i, routename(mfc.mfc_origin.s_addr));
d183 1
a183 1
				    routename(mfc.mfc_mcastgrp.s_addr),
@


1.14
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.13 2005/03/25 17:01:04 jaredy Exp $	*/
d171 1
a171 1
			for (; mfcp != 0; mfcp = mfc.mfc_hash.le_next) {
@


1.13
log
@kill unneeded (char *) casts.  ok millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.12 2005/01/14 15:00:44 mcbride Exp $	*/
d200 2
a201 2
						      &bw_meter,
						      sizeof bw_meter);
d203 1
a203 1
							       &banner_printed2);
@


1.12
log
@Allow netstat to print PIM statistics.

From Pavlin Radoslavov <pavlin@@icir.org>

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.11 2003/07/07 21:36:52 deraadt Exp $	*/
d106 1
a106 1
	kread(mrpaddr, (char *)&mrtproto, sizeof(mrtproto));
d136 1
a136 1
	kread(vifaddr, (char *)&viftable, sizeof(viftable));
d162 2
a163 2
	kread(mfchashtbladdr, (char *)&mfchashtbl, sizeof(mfchashtbl));
	kread(mfchashaddr, (char *)&mfchash, sizeof(mfchash));
d169 1
a169 1
			kread((u_long)&mfchashtbl[i], (char *)&mfcp, sizeof(mfcp));
d179 1
a179 1
				kread((u_long)mfcp, (char *)&mfc, sizeof(mfc));
d200 1
a200 1
						      (char *)&bw_meter,
d312 1
a312 1
	kread(mrpaddr, (char *)&mrtproto, sizeof(mrtproto));
d331 1
a331 1
	kread(mstaddr, (char *)&mrtstat, sizeof(mrtstat));
@


1.11
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.10 2003/06/03 02:56:13 millert Exp $	*/
d40 1
a40 1
 * Print DVMRP multicast routing structures and statistics.
d63 2
d191 21
d224 76
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.9 2003/02/01 01:51:31 deraadt Exp $	*/
d63 1
a63 1
char *
@


1.9
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.8 2002/06/02 15:49:05 itojun Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@mrtstat members are u_long, so use %lu not %ld
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.7 2001/11/19 19:02:15 mpech Exp $	*/
d68 1
a68 2
pktscale(n)
	u_long n;
d88 1
a88 2
mroutepr(mrpaddr, mfchashtbladdr, mfchashaddr, vifaddr)
	u_long mrpaddr, mfchashtbladdr, mfchashaddr, vifaddr;
d207 1
a207 2
mrt_stats(mrpaddr, mstaddr)
	u_long mrpaddr, mstaddr;
@


1.7
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.6 1998/02/27 12:07:37 deraadt Exp $	*/
d241 1
a241 1
	printf("\t%ld datagram%s with no route for origin\n",
d243 1
a243 1
	printf("\t%ld upcall%s made to mrouted\n",
d245 1
a245 1
	printf("\t%ld datagram%s with malformed tunnel options\n",
d247 1
a247 1
	printf("\t%ld datagram%s with no room for tunnel options\n",
d249 1
a249 1
	printf("\t%ld datagram%s arrived on wrong interface\n",
d251 1
a251 1
	printf("\t%ld datagram%s dropped due to upcall Q overflow\n",
d253 1
a253 1
	printf("\t%ld datagram%s dropped due to upcall socket overflow\n",
d255 1
a255 1
	printf("\t%ld datagram%s cleaned up by the cache\n",
d257 1
a257 1
	printf("\t%ld datagram%s dropped selectively by ratelimiter\n",
d259 1
a259 1
	printf("\t%ld datagram%s dropped - bucket Q overflow\n",
d261 1
a261 1
	printf("\t%ld datagram%s dropped - larger than bkt size\n",
@


1.6
log
@oflow paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.5 1997/06/29 21:46:03 millert Exp $	*/
d97 2
a98 2
	register struct vif *v;
	register vifi_t vifi;
@


1.5
log
@Use correct spacing on both 32bit and 64bit machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.4 1997/06/29 20:18:02 millert Exp $	*/
d84 1
a84 1
	sprintf(buf, "%lu%c", n, t);
@


1.4
log
@Mostly clean -Wall + 64bit issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.3 1996/06/26 05:37:23 deraadt Exp $	*/
d62 1
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute.c,v 1.10 1996/05/11 13:51:27 mycroft Exp $	*/
d83 1
a83 1
	sprintf(buf, "%u%c", n, t);
a97 1
	struct in_addr *grp;
d158 1
a158 1
		printf("  %-15.15s  %6u  %7u\n", (v->v_flags & VIFF_TUNNEL) ?
d240 1
a240 1
	printf("\t%d datagram%s with no route for origin\n",
d242 1
a242 1
	printf("\t%d upcall%s made to mrouted\n",
d244 1
a244 1
	printf("\t%d datagram%s with malformed tunnel options\n",
d246 1
a246 1
	printf("\t%d datagram%s with no room for tunnel options\n",
d248 1
a248 1
	printf("\t%d datagram%s arrived on wrong interface\n",
d250 1
a250 1
	printf("\t%d datagram%s dropped due to upcall Q overflow\n",
d252 1
a252 1
	printf("\t%d datagram%s dropped due to upcall socket overflow\n",
d254 1
a254 1
	printf("\t%d datagram%s cleaned up by the cache\n",
d256 1
a256 1
	printf("\t%d datagram%s dropped selectively by ratelimiter\n",
d258 1
a258 1
	printf("\t%d datagram%s dropped - bucket Q overflow\n",
d260 1
a260 1
	printf("\t%d datagram%s dropped - larger than bkt size\n",
@


1.2
log
@do not print a non-existant mfc
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mroute.c,v 1.9 1995/10/03 21:42:42 thorpej Exp $	*/
d170 22
a191 2
	for (i = 0; i <= mfchash; ++i) {
		kread((u_long)&mfchashtbl[i], (char *)&mfcp, sizeof(mfcp));
d193 2
a194 6
		for (; mfcp != 0; mfcp = mfc.mfc_hash.le_next) {
			if (!banner_printed) {
				printf("\nMulticast Forwarding Cache\n %s%s",
				    "Hash  Origin           Mcastgroup       ",
				    "Traffic  In-Vif  Out-Vifs/Forw-ttl\n");
				banner_printed = 1;
a195 13

			kread((u_long)mfcp, (char *)&mfc, sizeof(mfc));
			printf("  %3u  %-15.15s",
			    i, routename(mfc.mfc_origin.s_addr));
			printf("  %-15.15s  %7s     %3u ",
			    routename(mfc.mfc_mcastgrp.s_addr),
			    pktscale(mfc.mfc_pkt_cnt), mfc.mfc_parent);
			for (vifi = 0; vifi <= numvifs; ++vifi)
				if (mfc.mfc_ttls[vifi])
					printf(" %u/%u", vifi, mfc.mfc_ttls[vifi]);

			printf("\n");
			nmfc++;
a196 1
	}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

