head	1.160;
access;
symbols
	OPENBSD_6_2_BASE:1.160
	OPENBSD_6_1:1.156.0.4
	OPENBSD_6_1_BASE:1.156
	OPENBSD_6_0:1.147.0.2
	OPENBSD_6_0_BASE:1.147
	OPENBSD_5_9:1.144.0.2
	OPENBSD_5_9_BASE:1.144
	OPENBSD_5_8:1.143.0.4
	OPENBSD_5_8_BASE:1.143
	OPENBSD_5_7:1.140.0.2
	OPENBSD_5_7_BASE:1.140
	OPENBSD_5_6:1.133.0.4
	OPENBSD_5_6_BASE:1.133
	OPENBSD_5_5:1.132.0.4
	OPENBSD_5_5_BASE:1.132
	OPENBSD_5_4:1.123.0.2
	OPENBSD_5_4_BASE:1.123
	OPENBSD_5_3:1.121.0.2
	OPENBSD_5_3_BASE:1.121
	OPENBSD_5_2:1.119.0.4
	OPENBSD_5_2_BASE:1.119
	OPENBSD_5_1_BASE:1.119
	OPENBSD_5_1:1.119.0.2
	OPENBSD_5_0:1.118.0.2
	OPENBSD_5_0_BASE:1.118
	OPENBSD_4_9:1.114.0.2
	OPENBSD_4_9_BASE:1.114
	OPENBSD_4_8:1.113.0.2
	OPENBSD_4_8_BASE:1.113
	OPENBSD_4_7:1.112.0.2
	OPENBSD_4_7_BASE:1.112
	OPENBSD_4_6:1.110.0.6
	OPENBSD_4_6_BASE:1.110
	OPENBSD_4_5:1.110.0.2
	OPENBSD_4_5_BASE:1.110
	OPENBSD_4_4:1.106.0.2
	OPENBSD_4_4_BASE:1.106
	OPENBSD_4_3:1.105.0.2
	OPENBSD_4_3_BASE:1.105
	OPENBSD_4_2:1.100.0.2
	OPENBSD_4_2_BASE:1.100
	OPENBSD_4_1:1.99.0.6
	OPENBSD_4_1_BASE:1.99
	OPENBSD_4_0:1.99.0.4
	OPENBSD_4_0_BASE:1.99
	OPENBSD_3_9:1.99.0.2
	OPENBSD_3_9_BASE:1.99
	OPENBSD_3_8:1.98.0.2
	OPENBSD_3_8_BASE:1.98
	OPENBSD_3_7:1.92.0.2
	OPENBSD_3_7_BASE:1.92
	OPENBSD_3_6:1.88.0.2
	OPENBSD_3_6_BASE:1.88
	OPENBSD_3_5:1.84.0.2
	OPENBSD_3_5_BASE:1.84
	OPENBSD_3_4:1.68.0.2
	OPENBSD_3_4_BASE:1.68
	OPENBSD_3_3:1.64.0.2
	OPENBSD_3_3_BASE:1.64
	OPENBSD_3_2:1.62.0.2
	OPENBSD_3_2_BASE:1.62
	OPENBSD_3_1:1.58.0.2
	OPENBSD_3_1_BASE:1.58
	OPENBSD_3_0:1.53.0.2
	OPENBSD_3_0_BASE:1.53
	OPENBSD_2_9_BASE:1.49
	OPENBSD_2_9:1.49.0.2
	OPENBSD_2_8:1.48.0.2
	OPENBSD_2_8_BASE:1.48
	OPENBSD_2_7:1.46.0.2
	OPENBSD_2_7_BASE:1.46
	OPENBSD_2_6:1.33.0.4
	OPENBSD_2_6_BASE:1.33
	OPENBSD_2_5:1.33.0.2
	OPENBSD_2_5_BASE:1.33
	OPENBSD_2_4:1.24.0.4
	OPENBSD_2_4_BASE:1.24
	OPENBSD_2_3:1.24.0.2
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.21.0.2
	OPENBSD_2_2_BASE:1.21
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.160
date	2017.08.12.03.21.02;	author benno;	state Exp;
branches;
next	1.159;
commitid	fnpEGPaVcvCK3SUD;

1.159
date	2017.07.27.19.59.46;	author florian;	state Exp;
branches;
next	1.158;
commitid	Aihf9xXv0hltMu66;

1.158
date	2017.05.16.21.42.14;	author bluhm;	state Exp;
branches;
next	1.157;
commitid	NVRS0dCtndxFQCI6;

1.157
date	2017.05.04.14.23.00;	author bluhm;	state Exp;
branches;
next	1.156;
commitid	ULwpKJpSQM8XFSFk;

1.156
date	2017.03.07.23.35.06;	author jca;	state Exp;
branches;
next	1.155;
commitid	PgAFt411fYnb1Ztm;

1.155
date	2017.02.20.17.04.25;	author jca;	state Exp;
branches;
next	1.154;
commitid	GZyyhrJ9miKYlIqA;

1.154
date	2017.02.07.18.18.16;	author bluhm;	state Exp;
branches;
next	1.153;
commitid	d6u53XQpFaxImDPZ;

1.153
date	2016.12.22.11.04.44;	author rzalamena;	state Exp;
branches;
next	1.152;
commitid	T2qzeepA7r1EGy1x;

1.152
date	2016.11.11.15.01.43;	author bluhm;	state Exp;
branches;
next	1.151;
commitid	oJau65NVggWbqZIT;

1.151
date	2016.09.02.09.39.32;	author vgross;	state Exp;
branches;
next	1.150;
commitid	ZAyx9RbdVJtASCJK;

1.150
date	2016.08.27.04.13.43;	author guenther;	state Exp;
branches;
next	1.149;
commitid	zhvm7groPE9hsJC6;

1.149
date	2016.08.13.17.51.25;	author krw;	state Exp;
branches;
next	1.148;
commitid	44hKIoGxOYFJDGyP;

1.148
date	2016.08.13.17.36.04;	author krw;	state Exp;
branches;
next	1.147;
commitid	n8OerXOaninbCHKm;

1.147
date	2016.07.20.19.57.54;	author bluhm;	state Exp;
branches;
next	1.146;
commitid	iB1JO3v9iwYOTdxI;

1.146
date	2016.04.26.22.24.10;	author bluhm;	state Exp;
branches;
next	1.145;
commitid	kiCFgq8JieJfmhOM;

1.145
date	2016.03.21.15.52.27;	author bluhm;	state Exp;
branches;
next	1.144;
commitid	7wNIPXOo0aTQzUHP;

1.144
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.143;
commitid	0Dp7Dy9FuNZesYo2;

1.143
date	2015.06.21.12.11.13;	author claudio;	state Exp;
branches;
next	1.142;
commitid	gppti2vjQiKLuZPq;

1.142
date	2015.04.16.19.24.13;	author markus;	state Exp;
branches;
next	1.141;
commitid	2c41FFL8044mZVko;

1.141
date	2015.04.14.17.53.13;	author mikeb;	state Exp;
branches;
next	1.140;
commitid	vOQZOhEq2DoyosJA;

1.140
date	2015.02.12.01.49.02;	author claudio;	state Exp;
branches;
next	1.139;
commitid	EszVZ4RtthRFw1UZ;

1.139
date	2015.02.08.04.40.50;	author yasuoka;	state Exp;
branches;
next	1.138;
commitid	v0TRBcxZUQjo1nf8;

1.138
date	2015.01.16.06.40.09;	author deraadt;	state Exp;
branches;
next	1.137;
commitid	Uu5nFG3wCl0LACBb;

1.137
date	2014.11.03.17.20.46;	author bluhm;	state Exp;
branches;
next	1.136;
commitid	Jo3b0hfgHpuqTRST;

1.136
date	2014.10.26.14.43.03;	author chl;	state Exp;
branches;
next	1.135;
commitid	9DZSa6fimqjV0m2W;

1.135
date	2014.10.23.16.45.57;	author schwarze;	state Exp;
branches;
next	1.134;
commitid	IvHOKuDOlqzgwkmv;

1.134
date	2014.08.14.12.55.50;	author mpi;	state Exp;
branches;
next	1.133;
commitid	gdOWXDzOPG8ZFusi;

1.133
date	2014.06.23.03.46.17;	author guenther;	state Exp;
branches;
next	1.132;
commitid	uXnRK9VvnFZsAqfW;

1.132
date	2014.01.25.10.03.32;	author claudio;	state Exp;
branches;
next	1.131;

1.131
date	2014.01.23.23.51.53;	author henning;	state Exp;
branches;
next	1.130;

1.130
date	2014.01.19.05.03.29;	author claudio;	state Exp;
branches;
next	1.129;

1.129
date	2013.12.25.01.46.00;	author tedu;	state Exp;
branches;
next	1.128;

1.128
date	2013.12.24.22.26.19;	author tedu;	state Exp;
branches;
next	1.127;

1.127
date	2013.12.23.22.39.50;	author tedu;	state Exp;
branches;
next	1.126;

1.126
date	2013.12.20.02.04.09;	author krw;	state Exp;
branches;
next	1.125;

1.125
date	2013.10.24.09.33.20;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2013.08.18.16.32.24;	author guenther;	state Exp;
branches;
next	1.123;

1.123
date	2013.04.18.15.43.22;	author deraadt;	state Exp;
branches;
next	1.122;

1.122
date	2013.03.20.15.23.37;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2013.02.05.13.58.02;	author bluhm;	state Exp;
branches;
next	1.120;

1.120
date	2012.12.04.02.30.34;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2011.11.01.00.00.01;	author mikeb;	state Exp;
branches;
next	1.118;

1.118
date	2011.07.05.05.14.41;	author bluhm;	state Exp;
branches;
next	1.117;

1.117
date	2011.03.18.22.34.58;	author sthen;	state Exp;
branches;
next	1.116;

1.116
date	2011.03.15.13.10.31;	author jsing;	state Exp;
branches;
next	1.115;

1.115
date	2011.03.02.21.51.14;	author bluhm;	state Exp;
branches;
next	1.114;

1.114
date	2010.10.30.23.06.05;	author bluhm;	state Exp;
branches;
next	1.113;

1.113
date	2010.06.29.03.09.29;	author blambert;	state Exp;
branches;
next	1.112;

1.112
date	2009.11.05.20.50.14;	author michele;	state Exp;
branches;
next	1.111;

1.111
date	2009.10.04.16.08.37;	author michele;	state Exp;
branches;
next	1.110;

1.110
date	2009.02.07.15.06.04;	author chl;	state Exp;
branches;
next	1.109;

1.109
date	2009.02.02.17.19.13;	author mbalmer;	state Exp;
branches;
next	1.108;

1.108
date	2008.10.14.21.36.27;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2008.09.16.15.48.12;	author gollo;	state Exp;
branches;
next	1.106;

1.106
date	2008.05.08.03.13.55;	author mpf;	state Exp;
branches;
next	1.105;

1.105
date	2008.02.05.16.14.31;	author sthen;	state Exp;
branches;
next	1.104;

1.104
date	2007.12.19.01.47.00;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2007.12.14.18.35.46;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2007.12.13.20.00.53;	author reyk;	state Exp;
branches;
next	1.101;

1.101
date	2007.09.03.06.10.54;	author joel;	state Exp;
branches;
next	1.100;

1.100
date	2007.06.19.05.28.30;	author ray;	state Exp;
branches;
next	1.99;

1.99
date	2005.10.17.19.09.36;	author otto;	state Exp;
branches;
next	1.98;

1.98
date	2005.08.11.15.52.14;	author markus;	state Exp;
branches;
next	1.97;

1.97
date	2005.08.11.12.55.31;	author mpf;	state Exp;
branches;
next	1.96;

1.96
date	2005.06.15.10.53.23;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2005.04.05.20.27.35;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2005.03.30.17.45.36;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2005.03.25.17.01.03;	author jaredy;	state Exp;
branches;
next	1.92;

1.92
date	2005.02.10.14.25.08;	author itojun;	state Exp;
branches;
next	1.91;

1.91
date	2005.02.10.05.28.58;	author itojun;	state Exp;
branches;
next	1.90;

1.90
date	2005.01.14.15.00.44;	author mcbride;	state Exp;
branches;
next	1.89;

1.89
date	2004.11.17.01.09.45;	author mcbride;	state Exp;
branches;
next	1.88;

1.88
date	2004.09.09.10.30.23;	author otto;	state Exp;
branches;
next	1.87;

1.87
date	2004.04.28.01.53.45;	author mcbride;	state Exp;
branches;
next	1.86;

1.86
date	2004.04.28.00.47.06;	author mcbride;	state Exp;
branches;
next	1.85;

1.85
date	2004.04.24.18.51.13;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2004.03.13.22.02.13;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2004.02.29.14.17.51;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2004.02.26.19.38.41;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2004.02.26.08.51.45;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2004.01.15.10.17.33;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2004.01.13.20.03.28;	author otto;	state Exp;
branches;
next	1.78;

1.78
date	2004.01.06.17.38.12;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2003.12.27.23.17.34;	author mcbride;	state Exp;
branches;
next	1.76;

1.76
date	2003.12.22.22.25.34;	author mickey;	state Exp;
branches;
next	1.75;

1.75
date	2003.12.15.07.11.31;	author mcbride;	state Exp;
branches;
next	1.74;

1.74
date	2003.12.02.23.16.29;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	2003.11.07.23.38.48;	author mcbride;	state Exp;
branches;
next	1.72;

1.72
date	2003.11.02.10.23.58;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2003.10.31.09.00.32;	author mcbride;	state Exp;
branches;
next	1.70;

1.70
date	2003.10.25.19.33.05;	author mcbride;	state Exp;
branches;
next	1.69;

1.69
date	2003.10.17.21.04.59;	author mcbride;	state Exp;
branches;
next	1.68;

1.68
date	2003.09.04.20.05.19;	author tedu;	state Exp;
branches;
next	1.67;

1.67
date	2003.09.04.03.20.17;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2003.07.07.21.36.52;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2003.06.03.02.56.13;	author millert;	state Exp;
branches;
next	1.64;

1.64
date	2003.02.19.19.15.13;	author jason;	state Exp;
branches;
next	1.63;

1.63
date	2003.02.01.01.51.31;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.09.04.07.10;	author jsyn;	state Exp;
branches;
next	1.61;

1.61
date	2002.06.09.01.39.43;	author aaron;	state Exp;
branches;
next	1.60;

1.60
date	2002.05.27.01.50.36;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2002.05.16.14.18.34;	author kjc;	state Exp;
branches;
next	1.58;

1.58
date	2002.02.19.21.11.23;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2002.02.19.18.38.02;	author mpech;	state Exp;
branches;
next	1.56;

1.56
date	2002.02.16.21.27.50;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2002.01.17.21.34.58;	author mickey;	state Exp;
branches;
next	1.54;

1.54
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.53;

1.53
date	2001.08.26.09.42.04;	author brian;	state Exp;
branches;
next	1.52;

1.52
date	2001.07.05.08.54.41;	author angelos;	state Exp;
branches;
next	1.51;

1.51
date	2001.07.05.08.47.43;	author jjbg;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.23.06.09.09;	author angelos;	state Exp;
branches;
next	1.49;

1.49
date	2001.03.03.01.00.20;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2000.06.30.20.04.01;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2000.06.15.20.05.48;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2000.03.20.02.38.35;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2000.01.21.03.24.06;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2000.01.09.23.44.03;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	2000.01.05.00.07.08;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2000.01.03.04.27.57;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	99.12.09.09.02.28;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	99.12.09.08.55.16;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	99.12.09.04.21.55;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	99.12.08.12.30.17;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	99.12.06.11.17.26;	author niklas;	state Exp;
branches;
next	1.36;

1.36
date	99.12.06.11.04.22;	author niklas;	state Exp;
branches;
next	1.35;

1.35
date	99.12.06.00.45.17;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	99.10.29.03.26.40;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	99.04.11.19.41.40;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	99.04.09.23.30.05;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	99.03.27.21.04.21;	author provos;	state Exp;
branches;
next	1.30;

1.30
date	99.02.24.22.57.34;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	99.02.18.08.25.51;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	99.02.17.23.50.38;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	99.02.04.16.05.03;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	98.11.30.03.57.15;	author provos;	state Exp;
branches;
next	1.25;

1.25
date	98.11.25.02.11.44;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	98.03.18.02.43.04;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	98.02.27.12.07.33;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.11.09.16.33.09;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	97.07.28.01.47.43;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.07.14.21.31.33;	author angelos;	state Exp;
branches;
next	1.19;

1.19
date	97.07.01.20.32.14;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	97.06.29.21.46.01;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.06.29.20.52.39;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.06.29.20.17.59;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.06.25.07.56.18;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	97.06.24.02.26.18;	author dgregor;	state Exp;
branches;
next	1.13;

1.13
date	97.06.15.13.47.27;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.02.27.01.48.26;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	97.02.26.03.08.43;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	97.02.21.09.09.50;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	97.02.21.02.46.49;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.02.16.10.55.08;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.02.16.10.31.23;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.02.16.10.26.36;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.02.16.10.22.24;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.17.07.12.57;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.37.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.05.15.45.40;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.51;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.51;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.160
log
@add option -l to show only listening sockets (for tcp)
feedback and ok awhile ago bluhm@@ job@@
@
text
@/*	$OpenBSD: inet.c,v 1.159 2017/07/27 19:59:46 florian Exp $	*/
/*	$NetBSD: inet.c,v 1.14 1995/10/03 21:42:37 thorpej Exp $	*/

/*
 * Copyright (c) 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/queue.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/sysctl.h>
#define _KERNEL
#include <sys/file.h>
#undef _KERNEL

#include <net/route.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_icmp.h>
#include <netinet/icmp_var.h>
#include <netinet/igmp_var.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <netinet/tcp_seq.h>
#define TCPSTATES
#include <netinet/tcp_fsm.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/ip_ipsp.h>
#include <netinet/ip_ah.h>
#include <netinet/ip_esp.h>
#include <netinet/ip_ipip.h>
#include <netinet/ip_ipcomp.h>
#include <netinet/ip_ether.h>
#include <netinet/ip_carp.h>
#include <netinet/ip_divert.h>
#include <net/if.h>
#include <net/pfvar.h>
#include <net/if_pfsync.h>
#include <net/if_pflow.h>

#include <rpc/rpc.h>
#include <rpc/pmap_prot.h>
#include <rpc/pmap_clnt.h>

#include <arpa/inet.h>
#include <err.h>
#include <limits.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include "netstat.h"

struct	inpcb inpcb;
struct	tcpcb tcpcb;
struct	socket sockb;

char	*inetname(struct in_addr *);
void	inetprint(struct in_addr *, in_port_t, const char *, int);
char	*inet6name(struct in6_addr *);
void	sosplice_dump(u_long);
void	sockbuf_dump(struct sockbuf *, const char *);
void	protosw_dump(u_long, u_long);
void	domain_dump(u_long, u_long, short);
void	inpcb_dump(u_long, short, int);
void	tcpcb_dump(u_long);
int	kf_comp(const void *, const void *);

int type_map[] = { -1, 2, 3, 1, 4, 5 };

int
kf_comp(const void *a, const void *b)
{
	const struct kinfo_file *ka = a, *kb = b;

	if (ka->so_family != kb->so_family) {
		/* AF_INET < AF_INET6 < AF_LOCAL */
		if (ka->so_family == AF_INET)
			return (-1);
		if (ka->so_family == AF_LOCAL)
			return (1);
		if (kb->so_family == AF_LOCAL)
			return (-1);
		return (1);
	}
	if (ka->so_family == AF_LOCAL) {
		if (type_map[ka->so_type] < type_map[kb->so_type])
			return (-1);
		if (type_map[ka->so_type] > type_map[kb->so_type])
			return (1);
	} else if (ka->so_family == AF_INET || ka->so_family == AF_INET6) {
		if (ka->so_protocol < kb->so_protocol)
			return (-1);
		if (ka->so_protocol > kb->so_protocol)
			return (1);
		if (ka->so_type == SOCK_DGRAM || ka->so_type == SOCK_STREAM) {
			/* order sockets by remote port desc */
			if (ka->inp_fport > kb->inp_fport)
				return (-1);
			if (ka->inp_fport < kb->inp_fport)
				return (1);
		} else if (ka->so_type == SOCK_RAW) {
			if (ka->inp_proto > kb->inp_proto)
				return (-1);
			if (ka->inp_proto < kb->inp_proto)
				return (1);
		}
	}
	return (0);
}

void
protopr(kvm_t *kvmd, u_long pcbaddr, u_int tableid, int proto)
{
	struct kinfo_file *kf;
	int i, fcnt;

	kf = kvm_getfiles(kvmd, KERN_FILE_BYFILE, DTYPE_SOCKET,
	    sizeof(*kf), &fcnt);
	if (kf == NULL) {
		printf("Out of memory (file table).\n");
		return;
	}
	
	/* sort sockets by AF and type */
	qsort(kf, fcnt, sizeof(*kf), kf_comp);

	for (i = 0; i < fcnt; i++) {
		if (Pflag) {
			switch (kf[i].so_family) {
			case AF_INET:
			case AF_INET6:
				/*
				 * XXX at the moment fstat returns the pointer
				 * to the so_pcb or for tcp sockets the tcpcb
				 * pointer (inp_ppcb) so check both.
				 */
				if (pcbaddr == kf[i].so_pcb) {
					inpcb_dump(kf[i].so_pcb,
					    kf[i].so_protocol,
					    kf[i].so_family);
					return;
				} else if (pcbaddr == kf[i].inp_ppcb &&
				    kf[i].so_protocol == IPPROTO_TCP) {
					if (vflag)
						inpcb_dump(kf[i].so_pcb,
						    kf[i].so_protocol,
						    kf[i].so_family);
					else
						tcpcb_dump(kf[i].inp_ppcb);
					return;
				}
				break;
			case AF_UNIX:
				if (pcbaddr == kf[i].so_pcb) {
					unpcb_dump(pcbaddr);
					return;
				}
				break;
			}
			continue;
		}
		if (kf[i].so_family == AF_LOCAL && (kf[i].so_pcb != 0 ||
		    kf[i].unp_path[0] != '\0'))
			if ((af == AF_LOCAL || af == AF_UNSPEC) && !proto)
				unixdomainpr(&kf[i]);
		if (kf[i].so_family == AF_INET && kf[i].so_pcb != 0 &&
		    kf[i].inp_rtableid == tableid)
			if (af == AF_INET || af == AF_UNSPEC)
				netdomainpr(&kf[i], proto);
		if (kf[i].so_family == AF_INET6 && kf[i].so_pcb != 0 &&
		    kf[i].inp_rtableid == tableid)
			if (af == AF_INET6 || af == AF_UNSPEC)
				netdomainpr(&kf[i], proto);
	}
}

/*
 * Print a summary of connections related to an Internet
 * protocol.  For TCP, also give state of connection.
 * Listening processes (aflag) are suppressed unless the
 * -a (all) flag is specified.
 */
void
netdomainpr(struct kinfo_file *kf, int proto)
{
	static int af = 0, type = 0;
	struct in_addr laddr, faddr;
	struct in6_addr laddr6, faddr6;
	const char *name, *name6;
	int addrlen = 22;
	int isany = 0;
	int istcp = 0;
	int isip6 = 0;

	/* XXX should fix kinfo_file instead but not now */
	if (kf->so_pcb == -1)
		kf->so_pcb = 0;

	switch (proto) {
	case IPPROTO_TCP:
	case IPPROTO_UDP:
	case IPPROTO_DIVERT:
		if (kf->so_protocol != proto)
			return;
		break;
	case IPPROTO_IPV4:
		if (kf->so_type != SOCK_RAW || kf->so_family != AF_INET)
			return;
		break;
	case IPPROTO_IPV6:
		if (kf->so_type != SOCK_RAW || kf->so_family != AF_INET6)
			return;
		break;
	}

	/* make in_addr6 access a bit easier */
#define s6_addr32 __u6_addr.__u6_addr32
	laddr.s_addr = kf->inp_laddru[0];
	laddr6.s6_addr32[0] = kf->inp_laddru[0];
	laddr6.s6_addr32[1] = kf->inp_laddru[1];
	laddr6.s6_addr32[2] = kf->inp_laddru[2];
	laddr6.s6_addr32[3] = kf->inp_laddru[3];

	faddr.s_addr = kf->inp_faddru[0];
	faddr6.s6_addr32[0] = kf->inp_faddru[0];
	faddr6.s6_addr32[1] = kf->inp_faddru[1];
	faddr6.s6_addr32[2] = kf->inp_faddru[2];
	faddr6.s6_addr32[3] = kf->inp_faddru[3];
#undef s6_addr32

	switch (kf->so_family) {
	case AF_INET:
		isany = faddr.s_addr == INADDR_ANY;
		break;
	case AF_INET6:
		isany = IN6_IS_ADDR_UNSPECIFIED(&faddr6);
		isip6 = 1;
		break;
	}

	switch (kf->so_protocol) {
	case IPPROTO_TCP:
		name = "tcp";
		name6 = "tcp6";
		istcp = 1;
		break;
	case IPPROTO_UDP:
		name = "udp";
		name6 = "udp6";
		break;
	case IPPROTO_DIVERT:
		name = "divert";
		name6 = "divert6";
		break;
	default:
		name = "ip";
		name6 = "ip6";
		break;
	}

	/* filter listening sockets out unless -a is set */
	if (!(aflag || lflag) && istcp && kf->t_state <= TCPS_LISTEN)
		return;
	else if (!(aflag || lflag) && isany)
		return;

	/* when -l is set, show only listening sockets */
	if (!aflag && lflag && istcp &&
	    kf->t_state != TCPS_LISTEN)
		return;

	if (af != kf->so_family || type != kf->so_type) {
		af = kf->so_family;
		type = kf->so_type;
		printf("Active Internet connections");
		if (aflag)
			printf(" (including servers)");
		else if (lflag)
			printf(" (only servers)");
		putchar('\n');
		if (Aflag) {
			addrlen = 18;
			printf("%-*.*s ", PLEN, PLEN, "PCB");
		}
		printf("%-7.7s %-6.6s %-6.6s ",
		    "Proto", "Recv-Q", "Send-Q");
		if (Bflag && istcp)
			printf("%-6.6s %-6.6s %-6.6s ",
			    "Recv-W", "Send-W", "Cgst-W");
		printf(" %-*.*s %-*.*s %s\n",
		    addrlen, addrlen, "Local Address",
		    addrlen, addrlen, "Foreign Address", "(state)");
	}

	if (Aflag)
		printf("%#*llx%s ", FAKE_PTR(kf->so_protocol == IPPROTO_TCP ?
		    kf->inp_ppcb : kf->so_pcb));

	printf("%-7.7s %6llu %6llu ",
	    isip6 ? name6: name, kf->so_rcv_cc, kf->so_snd_cc);
	if (Bflag && istcp)
		printf("%6llu %6llu %6llu ", kf->t_rcv_wnd, kf->t_snd_wnd,
		    (kf->t_state == TCPS_ESTABLISHED) ?
		    kf->t_snd_cwnd : 0);

	if (isip6) {
		inet6print(&laddr6, kf->inp_lport, name);
		inet6print(&faddr6, kf->inp_fport, name);
	} else {
		inetprint(&laddr, kf->inp_lport, name, 1);
		inetprint(&faddr, kf->inp_fport, name, 0);
	}
	if (istcp) {
		if (kf->t_state >= TCP_NSTATES)
			printf(" %u", kf->t_state);
		else
			printf(" %s", tcpstates[kf->t_state]);
	} else if (kf->so_type == SOCK_RAW) {
		printf(" %u", kf->inp_proto);
	}
	putchar('\n');
}

/*
 * Dump TCP statistics structure.
 */
void
tcp_stats(char *name)
{
	struct tcpstat tcpstat;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_TCP, TCPCTL_STATS };
	size_t len = sizeof(tcpstat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &tcpstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define	p(f, m) if (tcpstat.f || sflag <= 1) \
	printf(m, tcpstat.f, plural(tcpstat.f))
#define	p1(f, m) if (tcpstat.f || sflag <= 1) \
	printf(m, tcpstat.f)
#define	p2(f1, f2, m) if (tcpstat.f1 || tcpstat.f2 || sflag <= 1) \
	printf(m, tcpstat.f1, plural(tcpstat.f1), tcpstat.f2, plural(tcpstat.f2))
#define	p2a(f1, f2, m) if (tcpstat.f1 || tcpstat.f2 || sflag <= 1) \
	printf(m, tcpstat.f1, plural(tcpstat.f1), tcpstat.f2)
#define	p2b(f1, f2, m) if (tcpstat.f1 || sflag <= 1) \
	printf(m, tcpstat.f1, tcpstat.f2)
#define	p2bys(f1, f2, m) if (tcpstat.f1 || sflag <= 1) \
	printf(m, tcpstat.f1, pluralys(tcpstat.f1), tcpstat.f2)
#define	pes(f, m) if (tcpstat.f || sflag <= 1) \
	printf(m, tcpstat.f, plurales(tcpstat.f))
#define	pys(f, m) if (tcpstat.f || sflag <= 1) \
	printf(m, tcpstat.f, pluralys(tcpstat.f))

	p(tcps_sndtotal, "\t%u packet%s sent\n");
	p2(tcps_sndpack,tcps_sndbyte,
	    "\t\t%u data packet%s (%llu byte%s)\n");
	p2(tcps_sndrexmitpack, tcps_sndrexmitbyte,
	    "\t\t%u data packet%s (%llu byte%s) retransmitted\n");
	p(tcps_sndrexmitfast, "\t\t%llu fast retransmitted packet%s\n");
	p2a(tcps_sndacks, tcps_delack,
	    "\t\t%u ack-only packet%s (%u delayed)\n");
	p(tcps_sndurg, "\t\t%u URG only packet%s\n");
	p(tcps_sndprobe, "\t\t%u window probe packet%s\n");
	p(tcps_sndwinup, "\t\t%u window update packet%s\n");
	p(tcps_sndctrl, "\t\t%u control packet%s\n");
	p(tcps_outswcsum, "\t\t%u packet%s software-checksummed\n");
	p(tcps_rcvtotal, "\t%u packet%s received\n");
	p2(tcps_rcvackpack, tcps_rcvackbyte, "\t\t%u ack%s (for %llu byte%s)\n");
	p(tcps_rcvdupack, "\t\t%u duplicate ack%s\n");
	p(tcps_rcvacktoomuch, "\t\t%u ack%s for unsent data\n");
	p(tcps_rcvacktooold, "\t\t%u ack%s for old data\n");
	p2(tcps_rcvpack, tcps_rcvbyte,
	    "\t\t%u packet%s (%llu byte%s) received in-sequence\n");
	p2(tcps_rcvduppack, tcps_rcvdupbyte,
	    "\t\t%u completely duplicate packet%s (%llu byte%s)\n");
	p(tcps_pawsdrop, "\t\t%u old duplicate packet%s\n");
	p2(tcps_rcvpartduppack, tcps_rcvpartdupbyte,
	    "\t\t%u packet%s with some duplicate data (%llu byte%s duplicated)\n");
	p2(tcps_rcvoopack, tcps_rcvoobyte,
	    "\t\t%u out-of-order packet%s (%llu byte%s)\n");
	p2(tcps_rcvpackafterwin, tcps_rcvbyteafterwin,
	    "\t\t%u packet%s (%llu byte%s) of data after window\n");
	p(tcps_rcvwinprobe, "\t\t%u window probe%s\n");
	p(tcps_rcvwinupd, "\t\t%u window update packet%s\n");
	p(tcps_rcvafterclose, "\t\t%u packet%s received after close\n");
	p(tcps_rcvbadsum, "\t\t%u discarded for bad checksum%s\n");
	p(tcps_rcvbadoff, "\t\t%u discarded for bad header offset field%s\n");
	p1(tcps_rcvshort, "\t\t%u discarded because packet too short\n");
	p1(tcps_rcvnosec, "\t\t%u discarded for missing IPsec protection\n");
	p1(tcps_rcvmemdrop, "\t\t%u discarded due to memory shortage\n");
	p(tcps_inswcsum, "\t\t%u packet%s software-checksummed\n");
	p(tcps_rcvbadsig, "\t\t%u bad/missing md5 checksum%s\n");
	p(tcps_rcvgoodsig, "\t\t%llu good md5 checksum%s\n");
	p(tcps_connattempt, "\t%u connection request%s\n");
	p(tcps_accepts, "\t%u connection accept%s\n");
	p(tcps_connects, "\t%u connection%s established (including accepts)\n");
	p2(tcps_closed, tcps_drops,
	    "\t%u connection%s closed (including %u drop%s)\n");
	p(tcps_conndrained, "\t%llu connection%s drained\n");
	p(tcps_conndrops, "\t%u embryonic connection%s dropped\n");
	p2(tcps_rttupdated, tcps_segstimed,
	    "\t%u segment%s updated rtt (of %u attempt%s)\n");
	p(tcps_rexmttimeo, "\t%u retransmit timeout%s\n");
	p(tcps_timeoutdrop, "\t\t%u connection%s dropped by rexmit timeout\n");
	p(tcps_persisttimeo, "\t%u persist timeout%s\n");
	p(tcps_keeptimeo, "\t%u keepalive timeout%s\n");
	p(tcps_keepprobe, "\t\t%u keepalive probe%s sent\n");
	p(tcps_keepdrops, "\t\t%u connection%s dropped by keepalive\n");
	p(tcps_predack, "\t%u correct ACK header prediction%s\n");
	p(tcps_preddat, "\t%u correct data packet header prediction%s\n");
	pes(tcps_pcbhashmiss, "\t%u PCB cache miss%s\n");
	p1(tcps_noport, "\t%u dropped due to no socket\n");

	p(tcps_ecn_accepts, "\t%u ECN connection%s accepted\n");
	p(tcps_ecn_rcvece, "\t\t%u ECE packet%s received\n");
	p(tcps_ecn_rcvcwr, "\t\t%u CWR packet%s received\n");
	p(tcps_ecn_rcvce, "\t\t%u CE packet%s received\n");
	p(tcps_ecn_sndect, "\t\t%u ECT packet%s sent\n");
	p(tcps_ecn_sndece, "\t\t%u ECE packet%s sent\n");
	p(tcps_ecn_sndcwr, "\t\t%u CWR packet%s sent\n");
	p1(tcps_cwr_frecovery, "\t\t\tcwr by fastrecovery: %u\n");
	p1(tcps_cwr_timeout, "\t\t\tcwr by timeout: %u\n");
	p1(tcps_cwr_ecn, "\t\t\tcwr by ecn: %u\n");

	p(tcps_badsyn, "\t%u bad connection attempt%s\n");
	p(tcps_dropsyn, "\t%u SYN packet%s dropped due to queue or memory full\n");
	pys(tcps_sc_added, "\t%llu SYN cache entr%s added\n");
	p(tcps_sc_collisions, "\t\t%llu hash collision%s\n");
	p1(tcps_sc_completed, "\t\t%llu completed\n");
	p1(tcps_sc_aborted, "\t\t%llu aborted (no space to build PCB)\n");
	p1(tcps_sc_timed_out, "\t\t%llu timed out\n");
	p1(tcps_sc_overflowed, "\t\t%llu dropped due to overflow\n");
	p1(tcps_sc_bucketoverflow, "\t\t%llu dropped due to bucket overflow\n");
	p1(tcps_sc_reset, "\t\t%llu dropped due to RST\n");
	p1(tcps_sc_unreach, "\t\t%llu dropped due to ICMP unreachable\n");
	p(tcps_sc_retransmitted, "\t%llu SYN,ACK%s retransmitted\n");
	p(tcps_sc_dupesyn, "\t%llu duplicate SYN%s received for entries "
	    "already in the cache\n");
	p(tcps_sc_dropped, "\t%llu SYN%s dropped (no route or no space)\n");
	p(tcps_sc_seedrandom, "\t%llu SYN cache seed%s with new random\n");
	p1(tcps_sc_hash_size, "\t%llu hash bucket array size in current "
	    "SYN cache\n");
	p2bys(tcps_sc_entry_count, tcps_sc_entry_limit,
	    "\t%llu entr%s in current SYN cache, limit is %llu\n");
	p2b(tcps_sc_bucket_maxlen, tcps_sc_bucket_limit,
	    "\t%llu longest bucket length in current SYN cache, limit is %llu\n");
	p(tcps_sc_uses_left, "\t%llu use%s of current SYN cache left\n");

	p(tcps_sack_recovery_episode, "\t%llu SACK recovery episode%s\n");
	p(tcps_sack_rexmits,
		"\t\t%llu segment rexmit%s in SACK recovery episodes\n");
	p(tcps_sack_rexmit_bytes,
		"\t\t%llu byte rexmit%s in SACK recovery episodes\n");
	p(tcps_sack_rcv_opts,
		"\t%llu SACK option%s received\n");
	p(tcps_sack_snd_opts, "\t%llu SACK option%s sent\n");

#undef p
#undef p1
#undef p2
#undef p2a
#undef p2b
#undef p2bys
#undef pes
#undef pys
}

/*
 * Dump UDP statistics structure.
 */
void
udp_stats(char *name)
{
	struct udpstat udpstat;
	u_long delivered;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_UDP, UDPCTL_STATS };
	size_t len = sizeof(udpstat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &udpstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define	p(f, m) if (udpstat.f || sflag <= 1) \
	printf(m, udpstat.f, plural(udpstat.f))
#define	p1(f, m) if (udpstat.f || sflag <= 1) \
	printf(m, udpstat.f)

	p(udps_ipackets, "\t%lu datagram%s received\n");
	p1(udps_hdrops, "\t%lu with incomplete header\n");
	p1(udps_badlen, "\t%lu with bad data length field\n");
	p1(udps_badsum, "\t%lu with bad checksum\n");
	p1(udps_nosum, "\t%lu with no checksum\n");
	p(udps_inswcsum, "\t%lu input packet%s software-checksummed\n");
	p(udps_outswcsum, "\t%lu output packet%s software-checksummed\n");
	p1(udps_noport, "\t%lu dropped due to no socket\n");
	p(udps_noportbcast, "\t%lu broadcast/multicast datagram%s dropped due to no socket\n");
	p1(udps_nosec, "\t%lu dropped due to missing IPsec protection\n");
	p1(udps_fullsock, "\t%lu dropped due to full socket buffers\n");
	delivered = udpstat.udps_ipackets - udpstat.udps_hdrops -
	    udpstat.udps_badlen - udpstat.udps_badsum -
	    udpstat.udps_noport - udpstat.udps_noportbcast -
	    udpstat.udps_fullsock;
	if (delivered || sflag <= 1)
		printf("\t%lu delivered\n", delivered);
	p(udps_opackets, "\t%lu datagram%s output\n");
	p1(udps_pcbhashmiss, "\t%lu missed PCB cache\n");
#undef p
#undef p1
}

/*
 * Dump IP statistics structure.
 */
void
ip_stats(char *name)
{
	struct ipstat ipstat;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_IP, IPCTL_STATS };
	size_t len = sizeof(ipstat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define	p(f, m) if (ipstat.f || sflag <= 1) \
	printf(m, ipstat.f, plural(ipstat.f))
#define	p1(f, m) if (ipstat.f || sflag <= 1) \
	printf(m, ipstat.f)

	p(ips_total, "\t%lu total packet%s received\n");
	p(ips_badsum, "\t%lu bad header checksum%s\n");
	p1(ips_toosmall, "\t%lu with size smaller than minimum\n");
	p1(ips_tooshort, "\t%lu with data size < data length\n");
	p1(ips_badhlen, "\t%lu with header length < data size\n");
	p1(ips_badlen, "\t%lu with data length < header length\n");
	p1(ips_badoptions, "\t%lu with bad options\n");
	p1(ips_badvers, "\t%lu with incorrect version number\n");
	p(ips_fragments, "\t%lu fragment%s received\n");
	p(ips_fragdropped, "\t%lu fragment%s dropped (duplicates or out of space)\n");
	p(ips_badfrags, "\t%lu malformed fragment%s dropped\n");
	p(ips_fragtimeout, "\t%lu fragment%s dropped after timeout\n");
	p(ips_reassembled, "\t%lu packet%s reassembled ok\n");
	p(ips_delivered, "\t%lu packet%s for this host\n");
	p(ips_noproto, "\t%lu packet%s for unknown/unsupported protocol\n");
	p(ips_forward, "\t%lu packet%s forwarded\n");
	p(ips_cantforward, "\t%lu packet%s not forwardable\n");
	p(ips_redirectsent, "\t%lu redirect%s sent\n");
	p(ips_localout, "\t%lu packet%s sent from this host\n");
	p(ips_rawout, "\t%lu packet%s sent with fabricated ip header\n");
	p(ips_odropped, "\t%lu output packet%s dropped due to no bufs, etc.\n");
	p(ips_noroute, "\t%lu output packet%s discarded due to no route\n");
	p(ips_fragmented, "\t%lu output datagram%s fragmented\n");
	p(ips_ofragments, "\t%lu fragment%s created\n");
	p(ips_cantfrag, "\t%lu datagram%s that can't be fragmented\n");
	p1(ips_rcvmemdrop, "\t%lu fragment floods\n");
	p(ips_toolong, "\t%lu packet%s with ip length > max ip packet size\n");
	p(ips_nogif, "\t%lu tunneling packet%s that can't find gif\n");
	p(ips_badaddr, "\t%lu datagram%s with bad address in header\n");
	p(ips_inswcsum, "\t%lu input datagram%s software-checksummed\n");
	p(ips_outswcsum, "\t%lu output datagram%s software-checksummed\n");
	p(ips_notmember, "\t%lu multicast packet%s which we don't join\n");
#undef p
#undef p1
}

/*
 * Dump DIVERT statistics structure.
 */
void
div_stats(char *name)
{
	struct divstat divstat;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_DIVERT, DIVERTCTL_STATS };
	size_t len = sizeof(divstat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &divstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define	p(f, m) if (divstat.f || sflag <= 1) \
	printf(m, divstat.f, plural(divstat.f))
#define	p1(f, m) if (divstat.f || sflag <= 1) \
	printf(m, divstat.f)
	p(divs_ipackets, "\t%lu total packet%s received\n");
	p1(divs_noport, "\t%lu dropped due to no socket\n");
	p1(divs_fullsock, "\t%lu dropped due to full socket buffers\n");
	p(divs_opackets, "\t%lu packet%s output\n");
	p1(divs_errors, "\t%lu errors\n");
#undef p
#undef p1
}

static	char *icmpnames[ICMP_MAXTYPE + 1] = {
	"echo reply",
	"#1",
	"#2",
	"destination unreachable",
	"source quench",
	"routing redirect",
	"#6",
	"#7",
	"echo",
	"router advertisement",
	"router solicitation",
	"time exceeded",
	"parameter problem",
	"time stamp",
	"time stamp reply",
	"information request",
	"information request reply",
	"address mask request",
	"address mask reply",
	"#19",
	"#20",
	"#21",
	"#22",
	"#23",
	"#24",
	"#25",
	"#26",
	"#27",
	"#28",
	"#29",
	"traceroute",
	"data conversion error",
	"mobile host redirect",
	"IPv6 where-are-you",
	"IPv6 i-am-here",
	"mobile registration request",
	"mobile registration reply",
	"#37",
	"#38",
	"SKIP",
	"Photuris",
};

/*
 * Dump ICMP statistics.
 */
void
icmp_stats(char *name)
{
	struct icmpstat icmpstat;
	int i, first;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_ICMP, ICMPCTL_STATS };
	size_t len = sizeof(icmpstat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &icmpstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define	p(f, m) if (icmpstat.f || sflag <= 1) \
	printf(m, icmpstat.f, plural(icmpstat.f))

	p(icps_error, "\t%lu call%s to icmp_error\n");
	p(icps_oldicmp,
	    "\t%lu error%s not generated because old message was icmp\n");
	p(icps_toofreq,
	    "\t%lu error%s not generated because of rate limitation\n");

	for (first = 1, i = 0; i < ICMP_MAXTYPE + 1; i++)
		if (icmpstat.icps_outhist[i] != 0) {
			if (first) {
				printf("\tOutput packet histogram:\n");
				first = 0;
			}
			if (icmpnames[i])
				printf("\t\t%s:", icmpnames[i]);
			else
				printf("\t\t#%d:", i);
			printf(" %lu\n", icmpstat.icps_outhist[i]);
		}
	p(icps_badcode, "\t%lu message%s with bad code fields\n");
	p(icps_tooshort, "\t%lu message%s < minimum length\n");
	p(icps_checksum, "\t%lu bad checksum%s\n");
	p(icps_badlen, "\t%lu message%s with bad length\n");
	p(icps_bmcastecho, "\t%lu echo request%s to broadcast/multicast "
	    "rejected\n");
	for (first = 1, i = 0; i < ICMP_MAXTYPE + 1; i++)
		if (icmpstat.icps_inhist[i] != 0) {
			if (first) {
				printf("\tInput packet histogram:\n");
				first = 0;
			}
			if (icmpnames[i])
				printf("\t\t%s:", icmpnames[i]);
			else
				printf("\t\t#%d:", i);
			printf(" %lu\n", icmpstat.icps_inhist[i]);
		}
	p(icps_reflect, "\t%lu message response%s generated\n");
#undef p
}

/*
 * Dump IGMP statistics structure.
 */
void
igmp_stats(char *name)
{
	struct igmpstat igmpstat;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_IGMP, IGMPCTL_STATS };
	size_t len = sizeof(igmpstat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &igmpstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define	p(f, m) if (igmpstat.f || sflag <= 1) \
	printf(m, igmpstat.f, plural(igmpstat.f))
#define	py(f, m) if (igmpstat.f || sflag <= 1) \
	printf(m, igmpstat.f, igmpstat.f != 1 ? "ies" : "y")

	p(igps_rcv_total, "\t%lu message%s received\n");
	p(igps_rcv_tooshort, "\t%lu message%s received with too few bytes\n");
	p(igps_rcv_badsum, "\t%lu message%s received with bad checksum\n");
	py(igps_rcv_queries, "\t%lu membership quer%s received\n");
	py(igps_rcv_badqueries, "\t%lu membership quer%s received with invalid field(s)\n");
	p(igps_rcv_reports, "\t%lu membership report%s received\n");
	p(igps_rcv_badreports, "\t%lu membership report%s received with invalid field(s)\n");
	p(igps_rcv_ourreports, "\t%lu membership report%s received for groups to which we belong\n");
	p(igps_snd_reports, "\t%lu membership report%s sent\n");
#undef p
#undef py
}

struct rpcnams {
	struct rpcnams *next;
	in_port_t port;
	int	  proto;
	char	*rpcname;
};

static char *
getrpcportnam(in_port_t port, int proto)
{
	struct sockaddr_in server_addr;
	struct hostent *hp;
	static struct pmaplist *head;
	int socket = RPC_ANYSOCK;
	struct timeval minutetimeout;
	CLIENT *client;
	struct rpcent *rpc;
	static int first;
	static struct rpcnams *rpcn;
	struct rpcnams *n;
	char num[20];

	if (first == 0) {
		first = 1;
		memset(&server_addr, 0, sizeof server_addr);
		server_addr.sin_family = AF_INET;
		if ((hp = gethostbyname("localhost")) != NULL)
			memmove((caddr_t)&server_addr.sin_addr, hp->h_addr,
			    hp->h_length);
		else
			(void) inet_aton("0.0.0.0", &server_addr.sin_addr);

		minutetimeout.tv_sec = 60;
		minutetimeout.tv_usec = 0;
		server_addr.sin_port = htons(PMAPPORT);
		if ((client = clnttcp_create(&server_addr, PMAPPROG,
		    PMAPVERS, &socket, 50, 500)) == NULL)
			return (NULL);
		if (clnt_call(client, PMAPPROC_DUMP, xdr_void, NULL,
		    xdr_pmaplist, &head, minutetimeout) != RPC_SUCCESS) {
			clnt_destroy(client);
			return (NULL);
		}
		for (; head != NULL; head = head->pml_next) {
			n = malloc(sizeof(struct rpcnams));
			if (n == NULL)
				continue;
			n->next = rpcn;
			rpcn = n;
			n->port = head->pml_map.pm_port;
			n->proto = head->pml_map.pm_prot;

			rpc = getrpcbynumber(head->pml_map.pm_prog);
			if (rpc)
				n->rpcname = strdup(rpc->r_name);
			else {
				snprintf(num, sizeof num, "%ld",
				    head->pml_map.pm_prog);
				n->rpcname = strdup(num);
			}
		}
		clnt_destroy(client);
	}

	for (n = rpcn; n; n = n->next)
		if (n->port == port && n->proto == proto)
			return (n->rpcname);
	return (NULL);
}

/*
 * Pretty print an Internet address (net address + port).
 * If the nflag was specified, use numbers instead of names.
 */
void
inetprint(struct in_addr *in, in_port_t port, const char *proto, int local)
{
	struct servent *sp = 0;
	char line[80], *cp, *nam;
	int width;

	snprintf(line, sizeof line, "%.*s.", (Aflag && !nflag) ? 12 : 16,
	    inetname(in));
	cp = strchr(line, '\0');
	if (!nflag && port)
		sp = getservbyport((int)port, proto);
	if (sp || port == 0)
		snprintf(cp, line + sizeof line - cp, "%.8s",
		    sp ? sp->s_name : "*");
	else if (local && !nflag && (nam = getrpcportnam(ntohs(port),
	    (strcmp(proto, "tcp") == 0 ? IPPROTO_TCP : IPPROTO_UDP))))
		snprintf(cp, line + sizeof line - cp, "%d[%.8s]",
		    ntohs(port), nam);
	else
		snprintf(cp, line + sizeof line - cp, "%d", ntohs(port));
	width = Aflag ? 18 : 22;
	printf(" %-*.*s", width, width, line);
}

/*
 * Construct an Internet address representation.
 * If the nflag has been supplied, give
 * numeric value, otherwise try for symbolic name.
 */
char *
inetname(struct in_addr *inp)
{
	char *cp;
	static char line[50];
	struct hostent *hp;
	static char domain[HOST_NAME_MAX+1];
	static int first = 1;

	if (first && !nflag) {
		first = 0;
		if (gethostname(domain, sizeof(domain)) == 0 &&
		    (cp = strchr(domain, '.')))
			(void) strlcpy(domain, cp + 1, sizeof domain);
		else
			domain[0] = '\0';
	}
	cp = NULL;
	if (!nflag && inp->s_addr != INADDR_ANY) {
		hp = gethostbyaddr((char *)inp, sizeof (*inp), AF_INET);
		if (hp) {
			if ((cp = strchr(hp->h_name, '.')) &&
			    !strcmp(cp + 1, domain))
				*cp = '\0';
			cp = hp->h_name;
		}
	}
	if (inp->s_addr == INADDR_ANY)
		snprintf(line, sizeof line, "*");
	else if (cp)
		snprintf(line, sizeof line, "%s", cp);
	else {
		inp->s_addr = ntohl(inp->s_addr);
#define C(x)	((x) & 0xff)
		snprintf(line, sizeof line, "%u.%u.%u.%u",
		    C(inp->s_addr >> 24), C(inp->s_addr >> 16),
		    C(inp->s_addr >> 8), C(inp->s_addr));
	}
	return (line);
}

/*
 * Dump AH statistics structure.
 */
void
ah_stats(char *name)
{
	struct ahstat ahstat;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_AH, AHCTL_STATS };
	size_t len = sizeof(ahstat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ahstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define p(f, m) if (ahstat.f || sflag <= 1) \
	printf(m, ahstat.f, plural(ahstat.f))
#define p1(f, m) if (ahstat.f || sflag <= 1) \
	printf(m, ahstat.f)

	p1(ahs_input, "\t%u input AH packets\n");
	p1(ahs_output, "\t%u output AH packets\n");
	p(ahs_nopf, "\t%u packet%s from unsupported protocol families\n");
	p(ahs_hdrops, "\t%u packet%s shorter than header shows\n");
	p(ahs_pdrops, "\t%u packet%s dropped due to policy\n");
	p(ahs_notdb, "\t%u packet%s for which no TDB was found\n");
	p(ahs_badkcr, "\t%u input packet%s that failed to be processed\n");
	p(ahs_badauth, "\t%u packet%s that failed verification received\n");
	p(ahs_noxform, "\t%u packet%s for which no XFORM was set in TDB received\n");
	p(ahs_qfull, "\t%u packet%s were dropped due to full output queue\n");
	p(ahs_wrap, "\t%u packet%s where counter wrapping was detected\n");
	p(ahs_replay, "\t%u possibly replayed packet%s received\n");
	p(ahs_badauthl, "\t%u packet%s with bad authenticator length received\n");
	p(ahs_invalid, "\t%u packet%s attempted to use an invalid TDB\n");
	p(ahs_toobig, "\t%u packet%s got larger than max IP packet size\n");
	p(ahs_crypto, "\t%u packet%s that failed crypto processing\n");
	p(ahs_outfail, "\t%u output packet%s could not be sent\n");
	p(ahs_ibytes, "\t%llu input byte%s\n");
	p(ahs_obytes, "\t%llu output byte%s\n");

#undef p
#undef p1
}

/*
 * Dump etherip statistics structure.
 */
void
etherip_stats(char *name)
{
	struct etheripstat etheripstat;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_ETHERIP, ETHERIPCTL_STATS };
	size_t len = sizeof(etheripstat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &etheripstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define p(f, m) if (etheripstat.f || sflag <= 1) \
	printf(m, etheripstat.f, plural(etheripstat.f))

	p(etherips_hdrops, "\t%llu packet%s shorter than header shows\n");
	p(etherips_qfull, "\t%llu packet%s were dropped due to full output queue\n");
	p(etherips_noifdrops, "\t%llu packet%s were dropped because of no interface/bridge information\n");
	p(etherips_pdrops, "\t%llu packet%s dropped due to policy\n");
	p(etherips_adrops, "\t%llu packet%s dropped for other reasons\n");
	p(etherips_ipackets, "\t%llu input ethernet-in-IP packet%s\n");
	p(etherips_opackets, "\t%llu output ethernet-in-IP packet%s\n");
	p(etherips_ibytes, "\t%llu input byte%s\n");
	p(etherips_obytes, "\t%llu output byte%s\n");
#undef p
}

/*
 * Dump ESP statistics structure.
 */
void
esp_stats(char *name)
{
	struct espstat espstat;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_ESP, ESPCTL_STATS };
	size_t len = sizeof(espstat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &espstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define p(f, m) if (espstat.f || sflag <= 1) \
	printf(m, espstat.f, plural(espstat.f))

	p(esps_input, "\t%u input ESP packet%s\n");
	p(esps_output, "\t%u output ESP packet%s\n");
	p(esps_nopf, "\t%u packet%s from unsupported protocol families\n");
	p(esps_hdrops, "\t%u packet%s shorter than header shows\n");
	p(esps_pdrops, "\t%u packet%s dropped due to policy\n");
	p(esps_notdb, "\t%u packet%s for which no TDB was found\n");
	p(esps_badkcr, "\t%u input packet%s that failed to be processed\n");
	p(esps_badenc, "\t%u packet%s with bad encryption received\n");
	p(esps_badauth, "\t%u packet%s that failed verification received\n");
	p(esps_noxform, "\t%u packet%s for which no XFORM was set in TDB received\n");
	p(esps_qfull, "\t%u packet%s were dropped due to full output queue\n");
	p(esps_wrap, "\t%u packet%s where counter wrapping was detected\n");
	p(esps_replay, "\t%u possibly replayed packet%s received\n");
	p(esps_badilen, "\t%u packet%s with bad payload size or padding received\n");
	p(esps_invalid, "\t%u packet%s attempted to use an invalid TDB\n");
	p(esps_toobig, "\t%u packet%s got larger than max IP packet size\n");
	p(esps_crypto, "\t%u packet%s that failed crypto processing\n");
	p(esps_outfail, "\t%u output packet%s could not be sent\n");
	p(esps_udpencin, "\t%u input UDP encapsulated ESP packet%s\n");
	p(esps_udpencout, "\t%u output UDP encapsulated ESP packet%s\n");
	p(esps_udpinval, "\t%u UDP packet%s for non-encapsulating TDB received\n");
	p(esps_udpneeded, "\t%u raw ESP packet%s for encapsulating TDB received\n");
	p(esps_ibytes, "\t%llu input byte%s\n");
	p(esps_obytes, "\t%llu output byte%s\n");

#undef p
}

/*
 * Dump IP-in-IP statistics structure.
 */
void
ipip_stats(char *name)
{
	struct ipipstat ipipstat;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_IPIP, IPIPCTL_STATS };
	size_t len = sizeof(ipipstat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipipstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define p(f, m) if (ipipstat.f || sflag <= 1) \
	printf(m, ipipstat.f, plural(ipipstat.f))

	p(ipips_ipackets, "\t%llu total input packet%s\n");
	p(ipips_opackets, "\t%llu total output packet%s\n");
	p(ipips_hdrops, "\t%llu packet%s shorter than header shows\n");
	p(ipips_pdrops, "\t%llu packet%s dropped due to policy\n");
	p(ipips_spoof, "\t%llu packet%s with possibly spoofed local addresses\n");
	p(ipips_qfull, "\t%llu packet%s were dropped due to full output queue\n");
	p(ipips_ibytes, "\t%llu input byte%s\n");
	p(ipips_obytes, "\t%llu output byte%s\n");
	p(ipips_family, "\t%llu protocol family mismatche%s\n");
	p(ipips_unspec, "\t%llu attempt%s to use tunnel with unspecified endpoint(s)\n");
#undef p
}

/*
 * Dump CARP statistics structure.
 */
void
carp_stats(char *name)
{
	struct carpstats carpstat;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_CARP, CARPCTL_STATS };
	size_t len = sizeof(carpstat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &carpstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define p(f, m) if (carpstat.f || sflag <= 1) \
	printf(m, carpstat.f, plural(carpstat.f))
#define p2(f, m) if (carpstat.f || sflag <= 1) \
	printf(m, carpstat.f)

	p(carps_ipackets, "\t%llu packet%s received (IPv4)\n");
	p(carps_ipackets6, "\t%llu packet%s received (IPv6)\n");
	p(carps_badif, "\t\t%llu packet%s discarded for bad interface\n");
	p(carps_badttl, "\t\t%llu packet%s discarded for wrong TTL\n");
	p(carps_hdrops, "\t\t%llu packet%s shorter than header\n");
	p(carps_badsum, "\t\t%llu discarded for bad checksum%s\n");
	p(carps_badver,	"\t\t%llu discarded packet%s with a bad version\n");
	p2(carps_badlen, "\t\t%llu discarded because packet too short\n");
	p2(carps_badauth, "\t\t%llu discarded for bad authentication\n");
	p2(carps_badvhid, "\t\t%llu discarded for unknown vhid\n");
	p2(carps_badaddrs, "\t\t%llu discarded because of a bad address list\n");
	p(carps_opackets, "\t%llu packet%s sent (IPv4)\n");
	p(carps_opackets6, "\t%llu packet%s sent (IPv6)\n");
	p2(carps_onomem, "\t\t%llu send failed due to mbuf memory error\n");
	p(carps_preempt, "\t%llu transition%s to master\n");
#undef p
#undef p2
}

/*
 * Dump pfsync statistics structure.
 */
void
pfsync_stats(char *name)
{
	struct pfsyncstats pfsyncstat;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_PFSYNC, PFSYNCCTL_STATS };
	size_t len = sizeof(pfsyncstat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &pfsyncstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define p(f, m) if (pfsyncstat.f || sflag <= 1) \
	printf(m, pfsyncstat.f, plural(pfsyncstat.f))
#define p2(f, m) if (pfsyncstat.f || sflag <= 1) \
	printf(m, pfsyncstat.f)

	p(pfsyncs_ipackets, "\t%llu packet%s received (IPv4)\n");
	p(pfsyncs_ipackets6, "\t%llu packet%s received (IPv6)\n");
	p(pfsyncs_badif, "\t\t%llu packet%s discarded for bad interface\n");
	p(pfsyncs_badttl, "\t\t%llu packet%s discarded for bad ttl\n");
	p(pfsyncs_hdrops, "\t\t%llu packet%s shorter than header\n");
	p(pfsyncs_badver, "\t\t%llu packet%s discarded for bad version\n");
	p(pfsyncs_badauth, "\t\t%llu packet%s discarded for bad HMAC\n");
	p(pfsyncs_badact,"\t\t%llu packet%s discarded for bad action\n");
	p(pfsyncs_badlen, "\t\t%llu packet%s discarded for short packet\n");
	p(pfsyncs_badval, "\t\t%llu state%s discarded for bad values\n");
	p(pfsyncs_stale, "\t\t%llu stale state%s\n");
	p(pfsyncs_badstate, "\t\t%llu failed state lookup/insert%s\n");
	p(pfsyncs_opackets, "\t%llu packet%s sent (IPv4)\n");
	p(pfsyncs_opackets6, "\t%llu packet%s sent (IPv6)\n");
	p2(pfsyncs_onomem, "\t\t%llu send failed due to mbuf memory error\n");
	p2(pfsyncs_oerrors, "\t\t%llu send error\n");
#undef p
#undef p2
}

/*
 * Dump pflow statistics structure.
 */
void
pflow_stats(char *name)
{
	struct pflowstats flowstats;
	int mib[] = { CTL_NET, PF_PFLOW, NET_PFLOW_STATS };
	size_t len = sizeof(struct pflowstats);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]), &flowstats, &len,
	    NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define p(f, m) if (flowstats.f || sflag <= 1) \
	printf(m, flowstats.f, plural(flowstats.f))
#define p2(f, m) if (flowstats.f || sflag <= 1) \
	printf(m, flowstats.f)

	p(pflow_flows, "\t%llu flow%s sent\n");
	p(pflow_packets, "\t%llu packet%s sent\n");
	p2(pflow_onomem, "\t\t%llu send failed due to mbuf memory error\n");
	p2(pflow_oerrors, "\t\t%llu send error\n");
#undef p
#undef p2
}

/*
 * Dump IPCOMP statistics structure.
 */
void
ipcomp_stats(char *name)
{
	struct ipcompstat ipcompstat;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_IPCOMP, IPCOMPCTL_STATS };
	size_t len = sizeof(ipcompstat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ipcompstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define p(f, m) if (ipcompstat.f || sflag <= 1) \
	printf(m, ipcompstat.f, plural(ipcompstat.f))

	p(ipcomps_input, "\t%u input IPCOMP packet%s\n");
	p(ipcomps_output, "\t%u output IPCOMP packet%s\n");
	p(ipcomps_nopf, "\t%u packet%s from unsupported protocol families\n");
	p(ipcomps_hdrops, "\t%u packet%s shorter than header shows\n");
	p(ipcomps_pdrops, "\t%u packet%s dropped due to policy\n");
	p(ipcomps_notdb, "\t%u packet%s for which no TDB was found\n");
	p(ipcomps_badkcr, "\t%u input packet%s that failed to be processed\n");
	p(ipcomps_noxform, "\t%u packet%s for which no XFORM was set in TDB received\n");
	p(ipcomps_qfull, "\t%u packet%s were dropped due to full output queue\n");
	p(ipcomps_wrap, "\t%u packet%s where counter wrapping was detected\n");
	p(ipcomps_invalid, "\t%u packet%s attempted to use an invalid TDB\n");
	p(ipcomps_toobig, "\t%u packet%s got larger than max IP packet size\n");
	p(ipcomps_crypto, "\t%u packet%s that failed (de)compression processing\n");
	p(ipcomps_outfail, "\t%u output packet%s could not be sent\n");
	p(ipcomps_minlen, "\t%u packet%s less than minimum compression length\n");
	p(ipcomps_ibytes, "\t%llu input byte%s\n");
	p(ipcomps_obytes, "\t%llu output byte%s\n");

#undef p
}

/*
 * Dump the contents of a socket structure
 */
void
socket_dump(u_long off)
{
	struct socket so;

	if (off == 0)
		return;
	kread(off, &so, sizeof(so));

#define	p(fmt, v, sep) printf(#v " " fmt sep, so.v);
#define	pp(fmt, v, sep) printf(#v " " fmt sep, so.v);
	printf("socket %#lx\n ", off);
	p("%#.4x", so_type, "\n ");
	p("%#.4x", so_options, "\n ");
	p("%d", so_linger, "\n ");
	p("%#.4x", so_state, "\n ");
	pp("%p", so_pcb, ", ");
	pp("%p", so_proto, ", ");
	pp("%p", so_head, "\n ");
	p("%d", so_q0len, ", ");
	p("%d", so_qlen, ", ");
	p("%d", so_qlimit, "\n ");
	p("%d", so_timeo, "\n ");
	p("%u", so_error, "\n ");
	p("%d", so_pgid, ", ");
	p("%u", so_siguid, ", ");
	p("%u", so_sigeuid, "\n ");
	p("%lu", so_oobmark, "\n ");
	if (so.so_sp)
		sosplice_dump((u_long)so.so_sp);
	sockbuf_dump(&so.so_rcv, "so_rcv");
	sockbuf_dump(&so.so_snd, "so_snd");
	p("%u", so_euid, ", ");
	p("%u", so_ruid, ", ");
	p("%u", so_egid, ", ");
	p("%u", so_rgid, "\n ");
	p("%d", so_cpid, "\n");
#undef	p
#undef	pp

	protosw_dump((u_long)so.so_proto, (u_long)so.so_pcb);
}

/*
 * Dump the contents of a struct sosplice
 */
void
sosplice_dump(u_long off)
{
	struct sosplice ssp;

	if (off == 0)
		return;
	kread(off, &ssp, sizeof(ssp));

#define	p(fmt, v, sep) printf(#v " " fmt sep, ssp.v);
#define	pll(fmt, v, sep) printf(#v " " fmt sep, (long long) ssp.v);
#define	pp(fmt, v, sep) printf(#v " " fmt sep, ssp.v);
	pp("%p", ssp_socket, ", ");
	pp("%p", ssp_soback, "\n ");
	p("%lld", ssp_len, ", ");
	p("%lld", ssp_max, ", ");
	pll("%lld", ssp_idletv.tv_sec, ", ");
	p("%ld", ssp_idletv.tv_usec, "\n ");
#undef	p
#undef	pll
#undef	pp
}

/*
 * Dump the contents of a socket buffer
 */
void
sockbuf_dump(struct sockbuf *sb, const char *name)
{
#define	p(fmt, v, sep) printf(#v " " fmt sep, sb->v);
	printf("%s ", name);
	p("%lu", sb_cc, ", ");
	p("%lu", sb_datacc, ", ");
	p("%lu", sb_hiwat, ", ");
	p("%lu", sb_wat, "\n ");
	printf("%s ", name);
	p("%lu", sb_mbcnt, ", ");
	p("%lu", sb_mbmax, ", ");
	p("%ld", sb_lowat, "\n ");
	printf("%s ", name);
	p("%#.8x", sb_flagsintr, ", ");
	p("%#.4x", sb_flags, ", ");
	p("%u", sb_timeo, "\n ");
#undef	p
}

/*
 * Dump the contents of a protosw structure
 */
void
protosw_dump(u_long off, u_long pcb)
{
	struct protosw proto;

	if (off == 0)
		return;
	kread(off, &proto, sizeof(proto));

#define	p(fmt, v, sep) printf(#v " " fmt sep, proto.v);
#define	pp(fmt, v, sep) printf(#v " " fmt sep, proto.v);
	printf("protosw %#lx\n ", off);
	p("%#.4x", pr_type, "\n ");
	pp("%p", pr_domain, "\n ");
	p("%d", pr_protocol, "\n ");
	p("%#.4x", pr_flags, "\n");
#undef	p
#undef	pp

	domain_dump((u_long)proto.pr_domain, pcb, proto.pr_protocol);
}

/*
 * Dump the contents of a domain structure
 */
void
domain_dump(u_long off, u_long pcb, short protocol)
{
	struct domain dom;
	char name[256];

	if (off == 0)
		return;
	kread(off, &dom, sizeof(dom));
	kread((u_long)dom.dom_name, name, sizeof(name));

#define	p(fmt, v, sep) printf(#v " " fmt sep, dom.v);
	printf("domain %#lx\n ", off);
	p("%d", dom_family, "\n ");
	printf("dom_name %.*s\n", (int)sizeof(name), name);
#undef	p
}

/*
 * Dump the contents of a internet PCB
 */
void
inpcb_dump(u_long off, short protocol, int af)
{
	struct inpcb inp;
	char faddr[256], laddr[256], raddr[256];

	if (off == 0)
		return;
	kread(off, &inp, sizeof(inp));

	if (vflag)
		socket_dump((u_long)inp.inp_socket);

	switch (af) {
	case AF_INET:
		inet_ntop(af, &inp.inp_faddr, faddr, sizeof(faddr));
		inet_ntop(af, &inp.inp_laddr, laddr, sizeof(laddr));
		inet_ntop(af, &((struct sockaddr_in *)
		    (&inp.inp_route.ro_dst))->sin_addr, raddr, sizeof(raddr));
		break;
	case AF_INET6:
		inet_ntop(af, &inp.inp_faddr6, faddr, sizeof(faddr));
		inet_ntop(af, &inp.inp_laddr6, laddr, sizeof(laddr));
		inet_ntop(af, &inp.inp_route6.ro_dst.sin6_addr,
		    raddr, sizeof(raddr));
		break;
	default:
		faddr[0] = laddr[0] = '\0';
	}

#define	p(fmt, v, sep) printf(#v " " fmt sep, inp.v);
#define	pp(fmt, v, sep) printf(#v " " fmt sep, inp.v);
	printf("inpcb %#lx\n ", off);
	pp("%p", inp_table, "\n ");
	printf("inp_faddru %s, inp_laddru %s\n ", faddr, laddr);
	HTONS(inp.inp_fport);
	HTONS(inp.inp_lport);
	p("%u", inp_fport, ", ");
	p("%u", inp_lport, "\n ");
	pp("%p", inp_socket, ", ");
	pp("%p", inp_ppcb, "\n ");
	pp("%p", inp_route.ro_rt, ", ");
	printf("ro_dst %s\n ", raddr);
	p("%#.8x", inp_flags, "\n ");
	p("%d", inp_hops, "\n ");
	p("%u", inp_seclevel[0], ", ");
	p("%u", inp_seclevel[1], ", ");
	p("%u", inp_seclevel[2], ", ");
	p("%u", inp_seclevel[3], "\n ");
	p("%u", inp_ip_minttl, "\n ");
	p("%d", inp_cksum6, "\n ");
	pp("%p", inp_icmp6filt, "\n ");
	pp("%p", inp_pf_sk, "\n ");
	p("%u", inp_rtableid, "\n ");
	p("%d", inp_pipex, "\n");
#undef	p
#undef	pp

	switch (protocol) {
	case IPPROTO_TCP:
		tcpcb_dump((u_long)inp.inp_ppcb);
		break;
	}
}

/*
 * Dump the contents of a TCP PCB
 */
void
tcpcb_dump(u_long off)
{
	struct tcpcb tcpcb;

	if (off == 0)
		return;
	kread(off, (char *)&tcpcb, sizeof (tcpcb));

#define	p(fmt, v, sep) printf(#v " " fmt sep, tcpcb.v);
#define	pp(fmt, v, sep) printf(#v " " fmt sep, tcpcb.v);
	printf("tcpcb %#lx\n ", off);
	pp("%p", t_inpcb, "\n ");
	p("%d", t_state, "");
	if (tcpcb.t_state >= 0 && tcpcb.t_state < TCP_NSTATES)
		printf(" (%s)", tcpstates[tcpcb.t_state]);
	printf("\n ");
	p("%d", t_rxtshift, ", ");
	p("%d", t_rxtcur, ", ");
	p("%d", t_dupacks, "\n ");
	p("%u", t_maxseg, ", ");
	p("%u", t_maxopd, ", ");
	p("%u", t_peermss, "\n ");
	p("0x%x", t_flags, ", ");
	p("%u", t_force, "\n ");
	p("%u", iss, "\n ");
	p("%u", snd_una, ", ");
	p("%u", snd_nxt, ", ");
	p("%u", snd_up, "\n ");
	p("%u", snd_wl1, ", ");
	p("%u", snd_wl2, ", ");
	p("%lu", snd_wnd, "\n ");
	p("%d", sack_enable, ", ");
	p("%d", snd_numholes, ", ");
	p("%u", snd_fack, ", ");
	p("%lu",snd_awnd, "\n ");
	p("%u", retran_data, ", ");
	p("%u", snd_last, "\n ");
	p("%u", irs, "\n ");
	p("%u", rcv_nxt, ", ");
	p("%u", rcv_up, ", ");
	p("%lu", rcv_wnd, "\n ");
	p("%u", rcv_lastsack, "\n ");
	p("%d", rcv_numsacks, "\n ");
	p("%u", rcv_adv, ", ");
	p("%u", snd_max, "\n ");
	p("%lu", snd_cwnd, ", ");
	p("%lu", snd_ssthresh, ", ");
	p("%lu", max_sndwnd, "\n ");
	p("%u", t_rcvtime, ", ");
	p("%u", t_rtttime, ", ");
	p("%u", t_rtseq, "\n ");
	p("%u", t_srtt, ", ");
	p("%u", t_rttvar, ", ");
	p("%u", t_rttmin, "\n ");
	p("%u", t_oobflags, ", ");
	p("%u", t_iobc, "\n ");
	p("%u", t_softerror, "\n ");
	p("%u", snd_scale, ", ");
	p("%u", rcv_scale, ", ");
	p("%u", request_r_scale, ", ");
	p("%u", requested_s_scale, "\n ");
	p("%u", ts_recent, ", ");
	p("%u", ts_recent_age, "\n ");
	p("%u", last_ack_sent, "\n ");
	HTONS(tcpcb.t_pmtud_ip_len);
	HTONS(tcpcb.t_pmtud_nextmtu);
	p("%u", t_pmtud_mss_acked, ", ");
	p("%u", t_pmtud_mtu_sent, "\n ");
	p("%u", t_pmtud_nextmtu, ", ");
	p("%u", t_pmtud_ip_len, ", ");
	p("%u", t_pmtud_ip_hl, "\n ");
	p("%u", t_pmtud_th_seq, "\n ");
	p("%u", pf, "\n");
#undef	p
#undef	pp
}
@


1.159
log
@uint32_t is never < 0; pointed out by clang.

While we originally get a short passed from the kernel, it's probably
better for debugging purposes to show what we are actually having
which is a uin32_t hence the %u format.

OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.158 2017/05/16 21:42:14 bluhm Exp $	*/
d297 1
a297 1
	if (!aflag && istcp && kf->t_state <= TCPS_LISTEN)
d299 6
a304 1
	else if (!aflag && isany)
d313 2
@


1.158
log
@When printing a tcpcb with -P and -v, also show the inp in netstat
output.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.157 2017/05/04 14:23:00 bluhm Exp $	*/
d342 2
a343 2
		if (kf->t_state < 0 || kf->t_state >= TCP_NSTATES)
			printf(" %d", kf->t_state);
@


1.157
log
@For TCP sockets netstat -A must print the address of the TCP protocol
control block.  This is documented in fstat(1) and makes it possible
to compare the values from both tools.
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.156 2017/03/07 23:35:06 jca Exp $	*/
d173 2
a174 1
					inpcb_dump(pcbaddr, kf[i].so_protocol,
d179 6
a184 1
					tcpcb_dump(pcbaddr);
@


1.156
log
@Rename struct etheripstat members for consistency, move them all to 64bits

Will make transition to percpu counters easier.  ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.155 2017/02/20 17:04:25 jca Exp $	*/
d318 2
a319 1
		printf("%#*llx%s ", FAKE_PTR(kf->so_pcb));
@


1.155
log
@Crank all members of struct ipipstat to 64 bits

Will make conversion to percpu counters easier.  ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.154 2017/02/07 18:18:16 bluhm Exp $	*/
d986 9
a994 9
	p(etherip_hdrops, "\t%u packet%s shorter than header shows\n");
	p(etherip_qfull, "\t%u packet%s were dropped due to full output queue\n");
	p(etherip_noifdrops, "\t%u packet%s were dropped because of no interface/bridge information\n");
	p(etherip_pdrops, "\t%u packet%s dropped due to policy\n");
	p(etherip_adrops, "\t%u packet%s dropped for other reasons\n");
	p(etherip_ipackets, "\t%u input ethernet-in-IP packet%s\n");
	p(etherip_opackets, "\t%u output ethernet-in-IP packet%s\n");
	p(etherip_ibytes, "\t%llu input byte%s\n");
	p(etherip_obytes, "\t%llu output byte%s\n");
@


1.154
log
@IPsec packets could be dropped unaccounted if output after crypto
failed.  Add a counter for that case.
OK dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.153 2016/12/22 11:04:44 rzalamena Exp $	*/
d1068 6
a1073 6
	p(ipips_ipackets, "\t%u total input packet%s\n");
	p(ipips_opackets, "\t%u total output packet%s\n");
	p(ipips_hdrops, "\t%u packet%s shorter than header shows\n");
	p(ipips_pdrops, "\t%u packet%s dropped due to policy\n");
	p(ipips_spoof, "\t%u packet%s with possibly spoofed local addresses\n");
	p(ipips_qfull, "\t%u packet%s were dropped due to full output queue\n");
d1076 2
a1077 2
	p(ipips_family, "\t%u protocol family mismatche%s\n");
	p(ipips_unspec, "\t%u attempt%s to use tunnel with unspecified endpoint(s)\n");
@


1.153
log
@Remove PIM support from the multicast stack.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.152 2016/11/11 15:01:43 bluhm Exp $	*/
d957 1
d1036 1
d1231 1
@


1.152
log
@Print the route cached at the inp with netstat -P.  While there,
fix a compiler warning about missing prototype.
OK claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.151 2016/09/02 09:39:32 vgross Exp $	*/
a51 1
#include <netinet/pim_var.h>
a768 38
#undef p
#undef py
}

/*
 * Dump PIM statistics structure.
 */
void
pim_stats(char *name)
{
	struct pimstat pimstat;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_PIM, PIMCTL_STATS };
	size_t len = sizeof(pimstat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &pimstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define	p(f, m) if (pimstat.f || sflag <= 1) \
	printf(m, pimstat.f, plural(pimstat.f))
#define	py(f, m) if (pimstat.f || sflag <= 1) \
	printf(m, pimstat.f, pimstat.f != 1 ? "ies" : "y")

	p(pims_rcv_total_msgs, "\t%llu message%s received\n");
	p(pims_rcv_total_bytes, "\t%llu byte%s received\n");
	p(pims_rcv_tooshort, "\t%llu message%s received with too few bytes\n");
	p(pims_rcv_badsum, "\t%llu message%s received with bad checksum\n");
	p(pims_rcv_badversion, "\t%llu message%s received with bad version\n");
	p(pims_rcv_registers_msgs, "\t%llu data register message%s received\n");
	p(pims_rcv_registers_bytes, "\t%llu data register byte%s received\n");
	p(pims_rcv_registers_wrongiif, "\t%llu data register message%s received on wrong iif\n");
	p(pims_rcv_badregisters, "\t%llu bad register%s received\n");
	p(pims_snd_registers_msgs, "\t%llu data register message%s sent\n");
	p(pims_snd_registers_bytes, "\t%llu data register byte%s sent\n");
@


1.151
log
@Drop non-encapulated ESP packets using a UDP-encapsulating TDB, and add
the relevant counters.

Ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.150 2016/08/27 04:13:43 guenther Exp $	*/
d102 1
d1423 1
a1423 1
	char faddr[256], laddr[256];
d1436 2
d1442 2
d1460 2
@


1.150
log
@Pull in <sys/select.h> for howmany() and NBBY, used by various net*/*.h

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.149 2016/08/13 17:51:25 krw Exp $	*/
d1076 1
@


1.149
log
@%lld -> %llu for u_int64_t struct fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.148 2016/08/13 17:36:04 krw Exp $	*/
d34 1
@


1.148
log
@As the relevant struct's (e.g. tcpstat) use [u_]int64_t types, the
proper printf() format is %ll[ud], not the antediluvian %q[ud].
Reminded by guenther@@'s proposed retirement of quad types.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.147 2016/07/20 19:57:54 bluhm Exp $	*/
d381 1
a381 1
	    "\t\t%u data packet%s (%lld byte%s)\n");
d383 2
a384 2
	    "\t\t%u data packet%s (%lld byte%s) retransmitted\n");
	p(tcps_sndrexmitfast, "\t\t%lld fast retransmitted packet%s\n");
d393 1
a393 1
	p2(tcps_rcvackpack, tcps_rcvackbyte, "\t\t%u ack%s (for %lld byte%s)\n");
d400 1
a400 1
	    "\t\t%u completely duplicate packet%s (%lld byte%s)\n");
d403 1
a403 1
	    "\t\t%u packet%s with some duplicate data (%lld byte%s duplicated)\n");
d405 1
a405 1
	    "\t\t%u out-of-order packet%s (%lld byte%s)\n");
d407 1
a407 1
	    "\t\t%u packet%s (%lld byte%s) of data after window\n");
d418 1
a418 1
	p(tcps_rcvgoodsig, "\t\t%lld good md5 checksum%s\n");
d424 1
a424 1
	p(tcps_conndrained, "\t%lld connection%s drained\n");
d452 11
a462 11
	pys(tcps_sc_added, "\t%lld SYN cache entr%s added\n");
	p(tcps_sc_collisions, "\t\t%lld hash collision%s\n");
	p1(tcps_sc_completed, "\t\t%lld completed\n");
	p1(tcps_sc_aborted, "\t\t%lld aborted (no space to build PCB)\n");
	p1(tcps_sc_timed_out, "\t\t%lld timed out\n");
	p1(tcps_sc_overflowed, "\t\t%lld dropped due to overflow\n");
	p1(tcps_sc_bucketoverflow, "\t\t%lld dropped due to bucket overflow\n");
	p1(tcps_sc_reset, "\t\t%lld dropped due to RST\n");
	p1(tcps_sc_unreach, "\t\t%lld dropped due to ICMP unreachable\n");
	p(tcps_sc_retransmitted, "\t%lld SYN,ACK%s retransmitted\n");
	p(tcps_sc_dupesyn, "\t%lld duplicate SYN%s received for entries "
d464 3
a466 3
	p(tcps_sc_dropped, "\t%lld SYN%s dropped (no route or no space)\n");
	p(tcps_sc_seedrandom, "\t%lld SYN cache seed%s with new random\n");
	p1(tcps_sc_hash_size, "\t%lld hash bucket array size in current "
d469 1
a469 1
	    "\t%lld entr%s in current SYN cache, limit is %lld\n");
d471 2
a472 2
	    "\t%lld longest bucket length in current SYN cache, limit is %lld\n");
	p(tcps_sc_uses_left, "\t%lld use%s of current SYN cache left\n");
d474 1
a474 1
	p(tcps_sack_recovery_episode, "\t%lld SACK recovery episode%s\n");
d476 1
a476 1
		"\t\t%lld segment rexmit%s in SACK recovery episodes\n");
d478 1
a478 1
		"\t\t%lld byte rexmit%s in SACK recovery episodes\n");
d480 2
a481 2
		"\t%lld SACK option%s received\n");
	p(tcps_sack_snd_opts, "\t%lld SACK option%s sent\n");
@


1.147
log
@To tune the TCP SYN cache we need more information.  Print the
relevant counters with netstat -s -p tcp.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.146 2016/04/26 22:24:10 bluhm Exp $	*/
d381 1
a381 1
	    "\t\t%u data packet%s (%qd byte%s)\n");
d383 2
a384 2
	    "\t\t%u data packet%s (%qd byte%s) retransmitted\n");
	p(tcps_sndrexmitfast, "\t\t%qd fast retransmitted packet%s\n");
d393 1
a393 1
	p2(tcps_rcvackpack, tcps_rcvackbyte, "\t\t%u ack%s (for %qd byte%s)\n");
d398 1
a398 1
	    "\t\t%u packet%s (%qu byte%s) received in-sequence\n");
d400 1
a400 1
	    "\t\t%u completely duplicate packet%s (%qd byte%s)\n");
d403 1
a403 1
	    "\t\t%u packet%s with some duplicate data (%qd byte%s duplicated)\n");
d405 1
a405 1
	    "\t\t%u out-of-order packet%s (%qd byte%s)\n");
d407 1
a407 1
	    "\t\t%u packet%s (%qd byte%s) of data after window\n");
d418 1
a418 1
	p(tcps_rcvgoodsig, "\t\t%qd good md5 checksum%s\n");
d424 1
a424 1
	p(tcps_conndrained, "\t%qd connection%s drained\n");
d452 11
a462 11
	pys(tcps_sc_added, "\t%qd SYN cache entr%s added\n");
	p(tcps_sc_collisions, "\t\t%qd hash collision%s\n");
	p1(tcps_sc_completed, "\t\t%qd completed\n");
	p1(tcps_sc_aborted, "\t\t%qd aborted (no space to build PCB)\n");
	p1(tcps_sc_timed_out, "\t\t%qd timed out\n");
	p1(tcps_sc_overflowed, "\t\t%qd dropped due to overflow\n");
	p1(tcps_sc_bucketoverflow, "\t\t%qd dropped due to bucket overflow\n");
	p1(tcps_sc_reset, "\t\t%qd dropped due to RST\n");
	p1(tcps_sc_unreach, "\t\t%qd dropped due to ICMP unreachable\n");
	p(tcps_sc_retransmitted, "\t%qd SYN,ACK%s retransmitted\n");
	p(tcps_sc_dupesyn, "\t%qd duplicate SYN%s received for entries "
d464 3
a466 3
	p(tcps_sc_dropped, "\t%qd SYN%s dropped (no route or no space)\n");
	p(tcps_sc_seedrandom, "\t%qd SYN cache seed%s with new random\n");
	p1(tcps_sc_hash_size, "\t%qd hash bucket array size in current "
d469 1
a469 1
	    "\t%qd entr%s in current SYN cache, limit is %qd\n");
d471 2
a472 2
	    "\t%qd longest bucket length in current SYN cache, limit is %qd\n");
	p(tcps_sc_uses_left, "\t%qd use%s of current SYN cache left\n");
d474 1
a474 1
	p(tcps_sack_recovery_episode, "\t%qd SACK recovery episode%s\n");
d476 1
a476 1
		"\t\t%qd segment rexmit%s in SACK recovery episodes\n");
d478 1
a478 1
		"\t\t%qd byte rexmit%s in SACK recovery episodes\n");
d480 2
a481 2
		"\t%qd SACK option%s received\n");
	p(tcps_sack_snd_opts, "\t%qd SACK option%s sent\n");
d994 2
a995 2
	p(ahs_ibytes, "\t%qu input byte%s\n");
	p(ahs_obytes, "\t%qu output byte%s\n");
d1029 2
a1030 2
	p(etherip_ibytes, "\t%qu input byte%s\n");
	p(etherip_obytes, "\t%qu output byte%s\n");
d1075 2
a1076 2
	p(esps_ibytes, "\t%qu input byte%s\n");
	p(esps_obytes, "\t%qu output byte%s\n");
d1108 2
a1109 2
	p(ipips_ibytes, "\t%qu input byte%s\n");
	p(ipips_obytes, "\t%qu output byte%s\n");
d1266 2
a1267 2
	p(ipcomps_ibytes, "\t%qu input byte%s\n");
	p(ipcomps_obytes, "\t%qu output byte%s\n");
@


1.146
log
@Print tcps_noport with netstat -s like it is already done for udp.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.145 2016/03/21 15:52:27 bluhm Exp $	*/
d370 5
a374 1
#define	p3(f, m) if (tcpstat.f || sflag <= 1) \
d376 2
d436 1
a436 1
	p3(tcps_pcbhashmiss, "\t%u PCB cache miss%s\n");
d452 1
a452 1
	p1(tcps_sc_added, "\t%qd SYN cache entries added\n");
d463 1
a463 1
		"already in the cache\n");
d466 7
d487 4
a490 1
#undef p3
@


1.145
log
@Add a tcps_sc_seedrandom counter in TCP SYN cache and netstat -s.
This shows how often the hash function is reseeded and the random
bucket distribution changes.
OK mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.144 2015/08/20 22:32:41 deraadt Exp $	*/
d431 1
@


1.144
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.143 2015/06/21 12:11:13 claudio Exp $	*/
d458 1
@


1.143
log
@There is no need to include sys/ucred.h. Only sys/file.h is needed for the
DTYPE defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.142 2015/04/16 19:24:13 markus Exp $	*/
d836 1
a836 1
			n = (struct rpcnams *)malloc(sizeof(struct rpcnams));
@


1.142
log
@remove unfinished/unused support for socket-attached ipsec-policies
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.141 2015/04/14 17:53:13 mikeb Exp $	*/
a39 1
#include <sys/ucred.h>
@


1.141
log
@IPsec auth and credentials are not stored in the kernel anymore;
noticed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.140 2015/02/12 01:49:02 claudio Exp $	*/
a1441 2
	p("%#x", inp_secrequire, ", ");
	p("%#x", inp_secresult, "\n ");
a1442 3
	pp("%p", inp_tdb_in, ", ");
	pp("%p", inp_tdb_out, ", ");
	pp("%p", inp_ipo, "\n ");
@


1.140
log
@Switch the printing of open sockets from ugly KVM internals to use
kvm_getfiles. This allows to run netstat without any extra privileges
and removes another setgid program from base..
There is still kvm reader code in there which is used for debugging
purposes (crashdump). netstat should still behave mostly the same.
deraadt@@ and sthen@@ agree that it is time to get this puppy in.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.139 2015/02/08 04:40:50 yasuoka Exp $	*/
a1447 2
	pp("%p", inp_ipsec_remotecred, ", ");
	pp("%p", inp_ipsec_remoteauth, "\n ");
@


1.139
log
@Count dropped SYN packets on the tcpstat.  They are dropped due to the
listen queue (backlog) limit or the memory shortage in syn-cache.

ok henning reyk claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.138 2015/01/16 06:40:09 deraadt Exp $	*/
d39 4
d94 1
a94 1
void	inetprint(struct in_addr *, in_port_t, char *, int);
a95 1
void	inet6print(struct in6_addr *, int, char *);
d103 103
d213 1
a213 1
protopr(u_long off, char *name, int af, u_int tableid, u_long pcbaddr)
d215 4
a218 4
	struct inpcbtable table;
	struct inpcb *prev, *next;
	struct inpcb inpcb, prevpcb;
	int istcp, israw, isany;
d220 24
a243 3
	int first = 1;
	char *name0;
	char namebuf[20];
d245 14
a258 20
	name0 = name;
	if (off == 0)
		return;
	istcp = strcmp(name, "tcp") == 0;
	israw = strncmp(name, "ip", 2) == 0;
	kread(off, &table, sizeof table);
	prev = NULL;
	next = TAILQ_FIRST(&table.inpt_queue);

	while (next != NULL) {
		kread((u_long)next, &inpcb, sizeof inpcb);
		if (prev != NULL) {
			kread((u_long)prev, &prevpcb, sizeof prevpcb);
			if (TAILQ_NEXT(&prevpcb, inp_queue) != next) {
				printf("PCB list changed\n");
				break;
			}
		}
		prev = next;
		next = TAILQ_NEXT(&inpcb, inp_queue);
d260 9
a268 15
		switch (af) {
		case AF_INET:
			if ((inpcb.inp_flags & INP_IPV6) != 0)
				continue;
			isany = inet_lnaof(inpcb.inp_faddr) == INADDR_ANY;
			break;
		case AF_INET6:
			if ((inpcb.inp_flags & INP_IPV6) == 0)
				continue;
			isany = IN6_IS_ADDR_UNSPECIFIED(&inpcb.inp_faddr6);
			break;
		default:
			isany = 0;
			break;
		}
d270 19
a288 14
		if (Pflag) {
			if (istcp && pcbaddr == (u_long)inpcb.inp_ppcb) {
				if (vflag)
					socket_dump((u_long)inpcb.inp_socket);
				else
					tcpcb_dump(pcbaddr);
			} else if (pcbaddr == (u_long)prev) {
				if (vflag)
					socket_dump((u_long)inpcb.inp_socket);
				else
					inpcb_dump(pcbaddr, 0, af);
			}
			continue;
		}
d290 5
a294 2
		if (inpcb.inp_rtableid != tableid)
			continue;
d296 7
a302 26
		kread((u_long)inpcb.inp_socket, &sockb, sizeof (sockb));
		if (istcp) {
			kread((u_long)inpcb.inp_ppcb, &tcpcb, sizeof (tcpcb));
			if (!aflag && tcpcb.t_state <= TCPS_LISTEN)
				continue;
		} else if (!aflag && isany)
			continue;
		if (first) {
			printf("Active Internet connections");
			if (aflag)
				printf(" (including servers)");
			putchar('\n');
			if (Aflag) {
				addrlen = 18;
				printf("%-*.*s ", PLEN, PLEN, "PCB");
			}
			printf("%-7.7s %-6.6s %-6.6s ",
			    "Proto", "Recv-Q", "Send-Q");
			if (Bflag && istcp)
				printf("%-6.6s %-6.6s %-6.6s ",
				    "Recv-W", "Send-W", "Cgst-W");
			printf(" %-*.*s %-*.*s %s\n",
			    addrlen, addrlen, "Local Address",
			    addrlen, addrlen, "Foreign Address", "(state)");
			first = 0;
		}
d304 2
a305 4
			if (istcp)
				printf("%*p ", PLEN, hideroot ? 0 : inpcb.inp_ppcb);
			else
				printf("%*p ", PLEN, hideroot ? 0 : prev);
d307 2
a308 8
		if (inpcb.inp_flags & INP_IPV6 && !israw) {
			strlcpy(namebuf, name0, sizeof namebuf);
			strlcat(namebuf, "6", sizeof namebuf);
			name = namebuf;
		} else
			name = name0;
		printf("%-7.7s %6lu %6lu ",
		    name, sockb.so_rcv.sb_cc, sockb.so_snd.sb_cc);
d310 31
a340 30
			printf("%6lu %6lu %6lu ", tcpcb.rcv_wnd, tcpcb.snd_wnd,
			    (tcpcb.t_state == TCPS_ESTABLISHED) ?
			    tcpcb.snd_cwnd : 0);

		if (inpcb.inp_flags & INP_IPV6) {
			inet6print(&inpcb.inp_laddr6, (int)inpcb.inp_lport,
			    name);
			inet6print(&inpcb.inp_faddr6, (int)inpcb.inp_fport,
			    name);
		} else {
			inetprint(&inpcb.inp_laddr, (int)inpcb.inp_lport,
			    name, 1);
			inetprint(&inpcb.inp_faddr, (int)inpcb.inp_fport,
			    name, 0);
		}
		if (istcp) {
			if (tcpcb.t_state < 0 || tcpcb.t_state >= TCP_NSTATES)
				printf(" %d", tcpcb.t_state);
			else
				printf(" %s", tcpstates[tcpcb.t_state]);
		} else if (israw) {
			u_int8_t proto;

			if (inpcb.inp_flags & INP_IPV6)
				proto = inpcb.inp_ipv6.ip6_nxt;
			else
				proto = inpcb.inp_ip.ip_p;
			printf(" %u", proto);
		}
		putchar('\n');
d342 1
d868 1
a868 1
inetprint(struct in_addr *in, in_port_t port, char *proto, int local)
d1268 2
a1269 2
#define	pp(fmt, v, sep) printf(#v " " fmt sep, hideroot ? 0 : so.v);
	printf("socket %#lx\n ", hideroot ? 0 : off);
a1297 2
	if (!vflag)
		return;
d1315 1
a1315 1
#define	pp(fmt, v, sep) printf(#v " " fmt sep, hideroot ? 0 : ssp.v);
d1363 2
a1364 2
#define	pp(fmt, v, sep) printf(#v " " fmt sep, hideroot ? 0 : proto.v);
	printf("protosw %#lx\n ", hideroot ? 0 : off);
d1390 1
a1390 1
	printf("domain %#lx\n ", hideroot ? 0 : off);
a1393 10

	switch (dom.dom_family) {
	case AF_INET:
	case AF_INET6:
		inpcb_dump(pcb, protocol, dom.dom_family);
		break;
	case AF_UNIX:
		unpcb_dump(pcb);
		break;
	}
d1408 4
d1426 2
a1427 2
#define	pp(fmt, v, sep) printf(#v " " fmt sep, hideroot ? 0 : inp.v);
	printf("inpcb %#lx\n ", hideroot ? 0 : off);
d1478 2
a1479 2
#define	pp(fmt, v, sep) printf(#v " " fmt sep, hideroot ? 0 : tcpcb.v);
	printf("tcpcb %#lx\n ", hideroot ? 0 : off);
@


1.138
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.137 2014/11/03 17:20:46 bluhm Exp $	*/
d347 1
@


1.137
log
@Put the socket splicing fields into a seperate struct sosplice that
gets only allocated when needed.  This way struct socket shrinks
from 472 to 392 bytes on amd64.  When splicing gets active, another
88 bytes are allocated for struct sosplice.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.136 2014/10/26 14:43:03 chl Exp $	*/
a32 1
#include <sys/param.h>
d804 1
a804 1
	static char domain[MAXHOSTNAMELEN];
@


1.136
log
@remove unused variables

ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.135 2014/10/23 16:45:57 schwarze Exp $	*/
d94 1
a1169 1
#define	pll(fmt, v, sep) printf(#v " " fmt sep, (long long) so.v);
d1188 2
a1189 6
	pp("%p", so_splice, ", ");
	pp("%p", so_spliceback, "\n ");
	p("%lld", so_splicelen, ", ");
	p("%lld", so_splicemax, ", ");
	pll("%lld", so_idletv.tv_sec, ", ");
	p("%ld", so_idletv.tv_usec, "\n ");
d1203 26
@


1.135
log
@Remove networks(5) support.
In particular, do not call getnetbyaddr(3), use gethostbyaddr(3) only.
Do not call setnetent(3) and the dummy sethostent(3).
OK henning@@; and deraadt@@ agrees with the general direction.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.134 2014/08/14 12:55:50 mpi Exp $	*/
a816 3
		int net = inet_netof(*inp);
		int lna = inet_lnaof(*inp);

@


1.134
log
@No need for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.133 2014/06/23 03:46:17 guenther Exp $	*/
a803 1
	struct netent *np;
d820 6
a825 13
		if (lna == INADDR_ANY) {
			np = getnetbyaddr(net, AF_INET);
			if (np)
				cp = np->n_name;
		}
		if (cp == NULL) {
			hp = gethostbyaddr((char *)inp, sizeof (*inp), AF_INET);
			if (hp) {
				if ((cp = strchr(hp->h_name, '.')) &&
				    !strcmp(cp + 1, domain))
					*cp = '\0';
				cp = hp->h_name;
			}
@


1.133
log
@The second level of the CTL_NET sysctl is a PF_*, not an AF_*

inconsistent usage in route(8) noted by Gregor Best (gbe (at) ring0.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.132 2014/01/25 10:03:32 claudio Exp $	*/
a42 1
#include <netinet/in_systm.h>
a50 1
#include <netinet/tcpip.h>
a55 1
#include <netinet/tcp_debug.h>
@


1.132
log
@Fix printing of icps_toofreq unlike IPv6 the IPv4 value is just a u_long.
Found by csszep (at) gmail.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.131 2014/01/23 23:51:53 henning Exp $	*/
d257 1
a257 1
	int mib[] = { CTL_NET, AF_INET, IPPROTO_TCP, TCPCTL_STATS };
d388 1
a388 1
	int mib[] = { CTL_NET, AF_INET, IPPROTO_UDP, UDPCTL_STATS };
d434 1
a434 1
	int mib[] = { CTL_NET, AF_INET, IPPROTO_IP, IPCTL_STATS };
d493 1
a493 1
	int mib[] = { CTL_NET, AF_INET, IPPROTO_DIVERT, DIVERTCTL_STATS };
d569 1
a569 1
	int mib[] = { CTL_NET, AF_INET, IPPROTO_ICMP, ICMPCTL_STATS };
d630 1
a630 1
	int mib[] = { CTL_NET, AF_INET, IPPROTO_IGMP, IGMPCTL_STATS };
d666 1
a666 1
	int mib[] = { CTL_NET, AF_INET, IPPROTO_PIM, PIMCTL_STATS };
d860 1
a860 1
	int mib[] = { CTL_NET, AF_INET, IPPROTO_AH, AHCTL_STATS };
d906 1
a906 1
	int mib[] = { CTL_NET, AF_INET, IPPROTO_ETHERIP, ETHERIPCTL_STATS };
d939 1
a939 1
	int mib[] = { CTL_NET, AF_INET, IPPROTO_ESP, ESPCTL_STATS };
d986 1
a986 1
	int mib[] = { CTL_NET, AF_INET, IPPROTO_IPIP, IPIPCTL_STATS };
d1020 1
a1020 1
	int mib[] = { CTL_NET, AF_INET, IPPROTO_CARP, CARPCTL_STATS };
d1062 1
a1062 1
	int mib[] = { CTL_NET, AF_INET, IPPROTO_PFSYNC, PFSYNCCTL_STATS };
d1136 1
a1136 1
	int mib[] = { CTL_NET, AF_INET, IPPROTO_IPCOMP, IPCOMPCTL_STATS };
@


1.131
log
@hardware cecksummed counters -> software checksummed counters
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.129 2013/12/25 01:46:00 tedu Exp $	*/
d587 1
a587 1
	    "\t%llu error%s not generated because of rate limitation\n");
@


1.130
log
@Report the number of dropped ICMP error because the rate limit got exceeded.
OK benno@@ deraadt@@
@
text
@d291 1
a291 1
	p(tcps_outhwcsum, "\t\t%u packet%s hardware-checksummed\n");
d316 1
a316 1
	p(tcps_inhwcsum, "\t\t%u packet%s hardware-checksummed\n");
d409 2
a410 2
	p(udps_inhwcsum, "\t%lu input packet%s hardware-checksummed\n");
	p(udps_outhwcsum, "\t%lu output packet%s hardware-checksummed\n");
d479 2
a480 2
	p(ips_inhwcsum, "\t%lu input datagram%s checksum-processed by hardware\n");
	p(ips_outhwcsum, "\t%lu output datagram%s checksum-processed by hardware\n");
@


1.129
log
@final circleq to tailq fix. restore the previous pointer check by reading
the previous value again and checking prev.next is still next.
maybe ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.128 2013/12/24 22:26:19 tedu Exp $	*/
d586 3
@


1.128
log
@more fixing after circleq conversion. a better fix to check the prev
pointer is forthcoming.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.127 2013/12/23 22:39:50 tedu Exp $	*/
d114 1
a114 1
	struct inpcb inpcb;
d132 7
@


1.127
log
@fix circleq tailq conversion
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.126 2013/12/20 02:04:09 krw Exp $	*/
d127 2
a128 1
	prev = next = TAILQ_FIRST(&table.inpt_queue);
a131 4
		if (TAILQ_PREV(&inpcb, inpthead, inp_queue) != prev) {
			printf("???\n");
			break;
		}
@


1.126
log
@Switch inpt_queue from CIRCLEQ to TAILQ. Thus ending use of CIRCLEQ
in the base. Ports fixes to follow shortly for the two ports (gkrellm
and net-snmp) affected.

ok zhuk@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.125 2013/10/24 09:33:20 deraadt Exp $	*/
d113 1
a113 1
	struct inpcb *head, *next, *prev;
d127 1
a127 3
	prev = head =
	    (struct inpcb *)&TAILQ_FIRST(&((struct inpcbtable *)off)->inpt_queue);
	next = TAILQ_FIRST(&table.inpt_queue);
d129 1
a129 1
	while (next != head) {
@


1.125
log
@These two programs got fooled by the KAME/NRL split and need type repair.
They do not indicate a problem with the reduction of namespace export,
but got suckered into the 1999 plan.
ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.124 2013/08/18 16:32:24 guenther Exp $	*/
d128 2
a129 2
	    (struct inpcb *)&CIRCLEQ_FIRST(&((struct inpcbtable *)off)->inpt_queue);
	next = CIRCLEQ_FIRST(&table.inpt_queue);
d133 1
a133 1
		if (CIRCLEQ_PREV(&inpcb, inp_queue) != prev) {
d138 1
a138 1
		next = CIRCLEQ_NEXT(&inpcb, inp_queue);
@


1.124
log
@Fix calls to printf-like functions which passed a non-fixed string
as the format and no variable args.
Replace "%#0.*X" with "%#.*X": the zero-fill flag is ignored/implied
on numeric conversions when a precision is specified.

ok jung@@ millert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.123 2013/04/18 15:43:22 deraadt Exp $	*/
d1347 1
a1347 1
	p("%d", in6p_cksum, "\n ");
@


1.123
log
@improve time_t printing; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.122 2013/03/20 15:23:37 deraadt Exp $	*/
d261 1
a261 1
			warn(name);
d392 1
a392 1
			warn(name);
d438 1
a438 1
			warn(name);
d497 1
a497 1
			warn(name);
d573 1
a573 1
			warn(name);
d631 1
a631 1
			warn(name);
d667 1
a667 1
			warn(name);
d861 1
a861 1
			warn(name);
d907 1
a907 1
			warn(name);
d940 1
a940 1
			warn(name);
d987 1
a987 1
			warn(name);
d1021 1
a1021 1
			warn(name);
d1063 1
a1063 1
			warn(name);
d1106 1
a1106 1
			warn(name);
d1137 1
a1137 1
			warn(name);
d1181 2
a1182 2
	p("%#0.4x", so_type, "\n ");
	p("%#0.4x", so_options, "\n ");
d1184 1
a1184 1
	p("%#0.4x", so_state, "\n ");
d1235 2
a1236 2
	p("%#0.8x", sb_flagsintr, ", ");
	p("%#0.4x", sb_flags, ", ");
d1256 1
a1256 1
	p("%#0.4x", pr_type, "\n ");
d1259 1
a1259 1
	p("%#0.4x", pr_flags, "\n");
d1283 1
a1283 1
	printf("dom_name %.*s\n", sizeof(name), name);
d1333 1
a1333 1
	p("%#0.8x", inp_flags, "\n ");
@


1.122
log
@As non-root, whenever netstat is about to print out a kernel pointer...
print 0x0 instead.  Hides a lot stuff people don't need to see.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.121 2013/02/05 13:58:02 bluhm Exp $	*/
d1178 1
d1201 1
a1201 1
	p("%ld", so_idletv.tv_sec, ", ");
@


1.121
log
@netstat -vP also shows the new struct sockbuf field sb_flagsintr.
OK markus@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.120 2012/12/04 02:30:34 deraadt Exp $	*/
d202 1
a202 1
				printf("%*p ", PLEN, inpcb.inp_ppcb);
d204 1
a204 1
				printf("%*p ", PLEN, prev);
d1178 2
a1179 1
	printf("socket %#lx\n ", off);
d1184 3
a1186 3
	p("%p", so_pcb, ", ");
	p("%p", so_proto, ", ");
	p("%p", so_head, "\n ");
d1196 2
a1197 2
	p("%p", so_splice, ", ");
	p("%p", so_spliceback, "\n ");
d1210 1
d1253 2
a1254 1
	printf("protosw %#lx\n ", off);
d1256 1
a1256 1
	p("%p", pr_domain, "\n ");
d1260 1
d1280 1
a1280 1
	printf("domain %#lx\n ", off);
d1322 3
a1324 2
	printf("inpcb %#lx\n ", off);
	p("%p", inp_table, "\n ");
d1330 2
a1331 2
	p("%p", inp_socket, ", ");
	p("%p", inp_ppcb, "\n ");
d1341 5
a1345 5
	p("%p", inp_tdb_in, ", ");
	p("%p", inp_tdb_out, ", ");
	p("%p", inp_ipo, "\n ");
	p("%p", inp_ipsec_remotecred, ", ");
	p("%p", inp_ipsec_remoteauth, "\n ");
d1347 2
a1348 2
	p("%p", inp_icmp6filt, "\n ");
	p("%p", inp_pf_sk, "\n ");
d1352 1
d1374 3
a1376 2
	printf("tcpcb %#lx\n ", off);
	p("%p", t_inpcb, "\n ");
d1439 1
@


1.120
log
@remove some unnecessary sys/mbuf.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.119 2011/11/01 00:00:01 mikeb Exp $	*/
d1232 1
@


1.119
log
@List sockets existing only in the specified or current routing domain.
Prompted by the mail from Andreas Bartelt, tested by Andreas and me.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.118 2011/07/05 05:14:41 bluhm Exp $	*/
a36 1
#include <sys/mbuf.h>
@


1.118
log
@Add so_idletv to netstat -vP pcb-address output.
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.117 2011/03/18 22:34:58 sthen Exp $	*/
d111 1
a111 1
protopr(u_long off, char *name, int af, u_long pcbaddr)
d171 3
@


1.117
log
@print icps_bmcastecho as "XX echo requests to broadcast/multicast rejected".
from Christiano Haesbert with a small tweak to wording
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.116 2011/03/15 13:10:31 jsing Exp $	*/
d1196 3
a1198 1
	p("%lld", so_splicemax, "\n ");
@


1.116
log
@Add a -B flag to netstat which displays buffer sizes for TCP sockets.

With feedback from bluhm@@

ok bluhm@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.114 2010/10/30 23:06:05 bluhm Exp $	*/
d598 2
@


1.115
log
@Add the socket splicing fields of struct socket to netstat -vP
output for debugging.
ok markus@@, claudio@@
@
text
@d117 1
d184 12
a195 10
			if (Aflag)
				printf("%-*.*s %-7.7s %-6.6s %-6.6s  %-18.18s %-18.18s %s\n",
				    PLEN, PLEN, "PCB", "Proto", "Recv-Q",
				    "Send-Q", "Local Address",
				    "Foreign Address", "(state)");
			else
				printf("%-7.7s %-6.6s %-6.6s  %-22.22s %-22.22s %s\n",
				    "Proto", "Recv-Q", "Send-Q",
				    "Local Address", "Foreign Address",
				    "(state)");
d210 7
a216 2
		printf("%-7.7s %6ld %6ld ", name, sockb.so_rcv.sb_cc,
		    sockb.so_snd.sb_cc);
@


1.114
log
@Print socket structure internals when netstat -P pcbaddr is called
with -v.  Also netstat -P supports more than TCP now.
ok markus@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.113 2010/06/29 03:09:29 blambert Exp $	*/
d1183 4
@


1.113
log
@Allow selecting both address family and protocol by passing the address family
directly to the appropriate print functions.

Found by jdixon@@, tested jdixon@@ and weerd@@, ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.112 2009/11/05 20:50:14 michele Exp $	*/
d38 1
d98 5
d111 1
a111 1
protopr(u_long off, char *name, int af)
d156 15
d1154 184
a1337 1
 * Dump the contents of a TCPCB
d1340 1
a1340 1
tcp_dump(u_long off)
d1349 2
a1350 2
	printf("pcb %#lx, ", off);
	p("%p", t_inpcb, "\n");
d1352 1
a1352 1
        if (tcpcb.t_state >= 0 && tcpcb.t_state < TCP_NSTATES)
d1354 1
a1354 1
	printf("\n");
d1357 1
a1357 1
	p("%d", t_dupacks, "\n");
d1360 1
a1360 1
	p("%u", t_peermss, "\n");
d1362 2
a1363 2
	p("%u", t_force, "\n");
	p("%u", iss, "\n");
d1366 1
a1366 1
	p("%u", snd_up, "\n");
d1369 1
a1369 1
	p("%lu", snd_wnd, "\n");
d1373 1
a1373 1
	p("%lu",snd_awnd, "\n");
d1375 2
a1376 2
	p("%u", snd_last, "\n");
	p("%u", irs, "\n");
d1379 3
a1381 3
	p("%lu", rcv_wnd, "\n");
	p("%u", rcv_lastsack, "\n");
	p("%d", rcv_numsacks, "\n");
d1383 1
a1383 1
	p("%u", snd_max, "\n");
d1386 1
a1386 1
	p("%lu", max_sndwnd, "\n");
d1389 1
a1389 1
	p("%u", t_rtseq, "\n");
d1392 1
a1392 1
	p("%u", t_rttmin, "\n");
d1394 2
a1395 2
	p("%u", t_iobc, "\n");
	p("%u", t_softerror, "\n");
d1399 1
a1399 1
	p("%u", requested_s_scale, "\n");
d1401 2
a1402 2
	p("%u", ts_recent_age, "\n");
	p("%u", last_ack_sent, "\n");
d1406 1
a1406 1
	p("%u", t_pmtud_mtu_sent, "\n");
d1409 2
a1410 2
	p("%u", t_pmtud_ip_hl, "\n");
	p("%u", t_pmtud_th_seq, "\n");
@


1.112
log
@IPv6 support for divert sockets.

tested by phessler@@ pyr@@
ok claudio@@
"go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.111 2009/10/04 16:08:37 michele Exp $	*/
a92 2
static void protopr0(u_long, char *, int);

d105 1
a105 13
protopr(u_long off, char *name)
{
	protopr0(off, name, AF_INET);
}

void
ip6protopr(u_long off, char *name)
{
	protopr0(off, name, AF_INET6);
}

static void
protopr0(u_long off, char *name, int af)
@


1.111
log
@Add (again) support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 1

A lot of discussion have happened since my last commit that resulted
in many changes and improvements.
I would *really* like to thank everyone who took part in the discussion
especially canacar@@ who spotted out which are the limitations of this approach.

OpenBSD divert(4) is meant to be compatible with software running on
top of FreeBSD's divert sockets even though they are pretty different and will
become even more with time.

discusses with many, but mainly reyk@@ canacar@@ deraadt@@ dlg@@ claudio@@ beck@@
tested by reyk@@ and myself
ok reyk@@ claudio@@ beck@@
manpage help and ok by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.110 2009/02/07 15:06:04 chl Exp $	*/
d177 1
a177 1
				printf("%-*.*s %-6.6s %-6.6s %-6.6s  %-18.18s %-18.18s %s\n",
d182 1
a182 1
				printf("%-6.6s %-6.6s %-6.6s  %-22.22s %-22.22s %s\n",
d200 1
a200 1
		printf("%-6.6s %6ld %6ld ", name, sockb.so_rcv.sb_cc,
@


1.110
log
@add missing headers needed for warn() and err().

ok claudio@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.109 2009/02/02 17:19:13 mbalmer Exp $	*/
d68 1
d177 1
a177 1
				printf("%-*.*s %-5.5s %-6.6s %-6.6s  %-18.18s %-18.18s %s\n",
d182 1
a182 1
				printf("%-5.5s %-6.6s %-6.6s  %-22.22s %-22.22s %s\n",
d200 1
a200 1
		printf("%-5.5s %6ld %6ld ", name, sockb.so_rcv.sb_cc,
d463 31
@


1.109
log
@Fix typo, from Joao Salvatti <salvatti@@gmail.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.108 2008/10/14 21:36:27 deraadt Exp $	*/
d78 1
@


1.108
log
@inet6print() has no 4th argument
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.107 2008/09/16 15:48:12 gollo Exp $	*/
d414 1
a414 1
	size_t len = sizeof(ipstat);;
@


1.107
log
@netstat statistics for pflow(4) via pseudo family

ok cluadio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.106 2008/05/08 03:13:55 mpf Exp $	*/
d96 1
a96 1
void	inet6print(struct in6_addr *, int, char *, int);
d202 1
a202 1
			    name, 1);
d204 1
a204 1
			    name, 0);
@


1.106
log
@Receiving carp packets for unknown vhid's is not really an error.
Change the wording accordingly.
OK markus@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.105 2008/02/05 16:14:31 sthen Exp $	*/
d71 1
d1037 31
@


1.105
log
@Change the method of identifying server connections to hide from
netstat without -a: use the connection state to identify TCP
servers, check the foreign address (not local address) to
identify servers on UDP and raw sockets.

From Philip Guenther, style changes suggested by Claudio.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.104 2007/12/19 01:47:00 deraadt Exp $	*/
d987 1
a987 1
	p2(carps_badvhid, "\t\t%llu discarded for bad vhid\n");
@


1.104
log
@delete rcsid crud
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.103 2007/12/14 18:35:46 deraadt Exp $	*/
d121 1
a121 1
	int istcp, israw;
d149 1
d154 1
d157 1
a160 3
		if (!aflag &&
		    inet_lnaof(inpcb.inp_laddr) == INADDR_ANY)
			continue;
d164 4
a167 1
		}
@


1.103
log
@remove 21 nlist variables, and instead use sysctl to query the kernel
turn on INET6 the default (remove the #ifdef's)
ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.102 2007/12/13 20:00:53 reyk Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "from: @@(#)inet.c	8.4 (Berkeley) 4/20/94";
#else
static const char *rcsid = "$OpenBSD: inet.c,v 1.102 2007/12/13 20:00:53 reyk Exp $";
#endif
#endif /* not lint */
@


1.102
log
@implement sysctls to report IP, TCP, UDP, and ICMP statistics and
change netstat to use them instead of accessing kvm for it. more
protocols will be added later.

discussed with deraadt@@ claudio@@ gilles@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.101 2007/09/03 06:10:54 joel Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.101 2007/09/03 06:10:54 joel Exp $";
d80 4
d91 1
a93 4
#include <rpc/rpc.h>
#include <rpc/pmap_prot.h>
#include <rpc/pmap_clnt.h>

a101 1
#ifdef INET6
a103 1
#endif
a116 1
#ifdef INET6
a121 1
#endif
a195 1
#ifdef INET6
a201 1
#endif
a203 1
#ifdef INET6
d209 1
a209 3
		} else
#endif
		{
d222 1
a222 1
#ifdef INET6
a225 1
#endif
d237 1
a237 1
tcp_stats(u_long off, char *name)
a239 1
	size_t len;
d241 1
a242 4
	if (off == 0)
		return;

	len = sizeof(tcpstat);
d245 2
a246 1
		warn(name);
d367 1
a367 1
udp_stats(u_long off, char *name)
a370 1
	size_t len;
d372 1
a373 4
	if (off == 0)
		return;

	len = sizeof(udpstat);
d376 2
a377 1
		warn(name);
d414 1
a414 1
ip_stats(u_long off, char *name)
a416 1
	size_t len;
d418 1
a419 4
	if (off == 0)
		return;

	len = sizeof(ipstat);
d422 2
a423 1
		warn(name);
d517 1
a517 1
icmp_stats(u_long off, char *name)
d522 1
a522 4
	size_t len;

	if (off == 0)
		return;
a523 1
	len = sizeof(icmpstat);
d526 2
a527 1
		warn(name);
d574 1
a574 1
igmp_stats(u_long off, char *name)
d577 2
d580 4
a583 1
	if (off == 0)
d585 2
a586 1
	kread(off, &igmpstat, sizeof (igmpstat));
a587 1

d610 1
a610 1
pim_stats(u_long off, char *name)
d613 2
d616 4
a619 4
	if (off == 0)
		return;
	if (kread(off, &pimstat, sizeof (pimstat)) != 0) {
		/* XXX: PIM is probably not enabled in the kernel */
a623 1

d804 1
a804 1
ah_stats(u_long off, char *name)
d807 2
d810 4
a813 1
	if (off == 0)
d815 2
a816 1
	kread(off, &ahstat, sizeof (ahstat));
a817 1

d850 1
a850 1
etherip_stats(u_long off, char *name)
d853 2
d856 4
a859 1
	if (off == 0)
d861 2
a862 1
	kread(off, &etheripstat, sizeof (etheripstat));
a863 1

d883 1
a883 1
esp_stats(u_long off, char *name)
d886 2
d889 4
a892 1
	if (off == 0)
d894 2
a895 1
	kread(off, &espstat, sizeof (espstat));
a896 1

d930 1
a930 1
ipip_stats(u_long off, char *name)
d933 2
d936 4
a939 1
	if (off == 0)
d941 2
a942 1
	kread(off, &ipipstat, sizeof (ipipstat));
a943 1

d964 1
a964 1
carp_stats(u_long off, char *name)
d967 2
d970 4
a973 1
	if (off == 0)
d975 2
a976 1
	kread(off, &carpstat, sizeof(carpstat));
a977 1

d1006 1
a1006 1
pfsync_stats(u_long off, char *name)
d1009 2
d1012 4
a1015 1
	if (off == 0)
d1017 2
a1018 1
	kread(off, &pfsyncstat, sizeof(pfsyncstat));
a1019 1

d1049 1
a1049 1
ipcomp_stats(u_long off, char *name)
d1052 2
d1055 4
a1058 1
	if (off == 0)
d1060 2
a1061 1
	kread(off, &ipcompstat, sizeof (ipcompstat));
a1062 1

@


1.101
log
@Make use of the carp preempt counter to signal number of transitions of
any carp group to master status.


ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.100 2007/06/19 05:28:30 ray Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.100 2007/06/19 05:28:30 ray Exp $";
d47 1
d249 2
d254 8
a262 2
	kread(off, &tcpstat, sizeof (tcpstat));

d383 2
d388 8
a395 1
	kread(off, &udpstat, sizeof (udpstat));
d432 2
d437 8
a444 1
	kread(off, &ipstat, sizeof (ipstat));
a445 1

d539 2
d544 8
a551 1
	kread(off, &icmpstat, sizeof (icmpstat));
a552 1

@


1.100
log
@"off" isn't a pointer, it's a ulong.  According to printf(3), %#lx
is equivalent to %p.

OK markus and itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.99 2005/10/17 19:09:36 otto Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.99 2005/10/17 19:09:36 otto Exp $";
d953 1
@


1.99
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.98 2005/08/11 15:52:14 markus Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.98 2005/08/11 15:52:14 markus Exp $";
d1044 1
a1044 1
	printf("pcb %p, ", off);
@


1.98
log
@print pmtu TCB variables
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.97 2005/08/11 12:55:31 mpf Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.97 2005/08/11 12:55:31 mpf Exp $";
d143 2
a144 2
	    (struct inpcb *)&((struct inpcbtable *)off)->inpt_queue.cqh_first;
	next = table.inpt_queue.cqh_first;
d148 1
a148 1
		if (inpcb.inp_queue.cqe_prev != prev) {
d153 1
a153 1
		next = inpcb.inp_queue.cqe_next;
@


1.97
log
@New counter for not joined IPv4 multicast groups.
Don't count link local scope multicast as not forwardable.
This stops ips_cantforward growing on carp(4) networks.
tested and ok mcbride@@, ok markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.96 2005/06/15 10:53:23 markus Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.96 2005/06/15 10:53:23 markus Exp $";
d1098 8
d1108 1
a1108 1
};
@


1.96
log
@add -P for dumping PCB infos, similar to netbsd; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.95 2005/04/05 20:27:35 markus Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.95 2005/04/05 20:27:35 markus Exp $";
d456 1
@


1.95
log
@add tcp sack stats, similar to freebsd; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.94 2005/03/30 17:45:36 deraadt Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.94 2005/03/30 17:45:36 deraadt Exp $";
d1029 71
@


1.94
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.93 2005/03/25 17:01:03 jaredy Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.93 2005/03/25 17:01:03 jaredy Exp $";
d349 9
@


1.93
log
@kill unneeded (char *) casts.  ok millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.92 2005/02/10 14:25:08 itojun Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.92 2005/02/10 14:25:08 itojun Exp $";
d947 1
a947 1
/* 
@


1.92
log
@backout previous; i committed to wrong repository (i meant to commit kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.90 2005/01/14 15:00:44 mcbride Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.90 2005/01/14 15:00:44 mcbride Exp $";
d141 1
a141 1
	kread(off, (char *)&table, sizeof table);
d147 1
a147 1
		kread((u_long)next, (char *)&inpcb, sizeof inpcb);
d171 1
a171 1
		kread((u_long)inpcb.inp_socket, (char *)&sockb, sizeof (sockb));
d173 1
a173 2
			kread((u_long)inpcb.inp_ppcb,
			    (char *)&tcpcb, sizeof (tcpcb));
d252 1
a252 1
	kread(off, (char *)&tcpstat, sizeof (tcpstat));
d368 1
a368 1
	kread(off, (char *)&udpstat, sizeof (udpstat));
d408 1
a408 1
	kread(off, (char *)&ipstat, sizeof (ipstat));
d506 1
a506 1
	kread(off, (char *)&icmpstat, sizeof (icmpstat));
d557 1
a557 1
	kread(off, (char *)&igmpstat, sizeof (igmpstat));
d588 1
a588 1
	if (kread(off, (char *)&pimstat, sizeof (pimstat)) != 0) {
d639 1
a639 1
		memset((char *)&server_addr, 0, sizeof server_addr);
d781 1
a781 1
	kread(off, (char *)&ahstat, sizeof (ahstat));
d822 1
a822 1
	kread(off, (char *)&etheripstat, sizeof (etheripstat));
d850 1
a850 1
	kread(off, (char *)&espstat, sizeof (espstat));
d892 1
a892 1
	kread(off, (char *)&ipipstat, sizeof (ipipstat));
d921 1
a921 1
	kread(off, (char *)&carpstat, sizeof(carpstat));
d957 1
a957 1
	kread(off, (char *)&pfsyncstat, sizeof(pfsyncstat));
d995 1
a995 1
	kread(off, (char *)&ipcompstat, sizeof (ipcompstat));
@


1.91
log
@dccp support
@
text
@a73 5
#ifdef DCCP
#include <netinet/dccp.h>
#define DCCPSTATES
#include <netinet/dccp_var.h>
#endif
a93 3
#ifdef DCCP
struct  dccpcb dccpcb;
#endif
a131 3
#ifdef DCCP
	int isdccp;
#endif
a140 3
#ifdef DCCP
	isdccp = strcmp(name, "dccp") == 0;
#endif
a175 6
#ifdef DCCP
		if (isdccp) {
			kread((u_long)inpcb.inp_ppcb,
			    (char *)&dccpcb, sizeof (dccpcb));
		}
#endif
a193 3
#ifdef DCCP
			if (istcp || isdccp)
#else
a194 1
#endif
a397 50

#ifdef DCCP
void
dccp_stats(off, name)
	u_long off;
	char *name;
{
	struct dccpstat dccpstat;

	if (off == 0)
		return;
	printf("%s:\n", name);
	kread(off, (char *)&dccpstat, sizeof (dccpstat));

#define	p(f, m) if (dccpstat.f || sflag <= 1) \
    printf(m, dccpstat.f, plural(dccpstat.f))
#define	p1a(f, m) if (dccpstat.f || sflag <= 1) \
    printf(m, dccpstat.f)
	p(dccps_ipackets, "\t%lu packet%s received\n");
	p(dccps_ibytes, "\t%lu byte%s received\n");
	p(dccps_connattempt, "\t%lu connection request%s\n");
	p(dccps_connects, "\t%lu connection%s established\n");
	p(dccps_drops, "\t%lu packet%s dropped\n");
	p(dccps_badlen, "\t%lu packet%s with bad data length field\n");
	p(dccps_badsum, "\t%lu packet%s with bad checksum\n");
	p(dccps_badseq, "\t%lu packet%s with bad sequencenumber\n");
	p(dccps_noport, "\t%lu packet%s dropped due to no socket\n");
	p(dccps_opackets, "\t%lu packet%s output\n");
	p(dccps_obytes, "\t%lu byte%s output\n");

	printf("\n\tTCPlike Sender:\n");
	p(tcplikes_send_conn, "\t%lu connection%s established\n");
	p(tcplikes_send_reploss, "\t%lu data packet%s reported lost\n");
	p(tcplikes_send_assloss, "\t%lu data packet%s assumed lost\n");
	p(tcplikes_send_ackrecv, "\t%lu acknowledgement%s received\n");
	p(tcplikes_send_missack, "\t%lu ack packet%s assumed lost\n");
	p(tcplikes_send_badseq, "\t%lu bad sequence number on outgoing packet%s\n");
	p(tcplikes_send_memerr, "\t%lu memory allocation error%s\n");

	printf("\tTCPlike Receiver:\n");
	p(tcplikes_recv_conn, "\t%lu connection%s established\n");
	p(tcplikes_recv_datarecv, "\t%lu data packet%s received\n");
	p(tcplikes_recv_ackack, "\t%lu Ack-on-ack%s received\n");
	p(tcplikes_recv_acksent, "\t%lu acknowledgement packet%s sent\n");
	p(tcplikes_recv_memerr, "\t%lu memory allocation error%s\n");

#undef p
#undef p1a
}
#endif
@


1.90
log
@Allow netstat to print PIM statistics.

From Pavlin Radoslavov <pavlin@@icir.org>

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.89 2004/11/17 01:09:45 mcbride Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.89 2004/11/17 01:09:45 mcbride Exp $";
d74 5
d99 3
d140 3
d152 3
d190 6
d214 3
d218 1
d422 50
@


1.89
log
@Add missing counters to 'netstat -sp carp' output.

From camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.88 2004/09/09 10:30:23 otto Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.88 2004/09/09 10:30:23 otto Exp $";
d57 1
d575 37
@


1.88
log
@printing the raw ip protocol name breaks the protocol loop, so just
print the number. ok henning@@ markus@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.87 2004/04/28 01:53:45 mcbride Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.87 2004/04/28 01:53:45 mcbride Exp $";
d895 1
d905 1
@


1.87
log
@carp stats cleanup:
- convert counters to 64 bits
- remove junk from netstat

ok pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.86 2004/04/28 00:47:06 mcbride Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.86 2004/04/28 00:47:06 mcbride Exp $";
a227 1
			struct protoent *pe = NULL;
d235 1
a235 6
			if (!nflag)
				pe = getprotobynumber(proto);
			if (pe)
				printf(" %s", pe->p_name);
			else
				printf(" %u", proto);
@


1.86
log
@pfsync stats fixups:
- convert counters to 64 bits
- add dedicated counters for sanity checks added right before release
- clean up netstat output
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.85 2004/04/24 18:51:13 markus Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.85 2004/04/24 18:51:13 markus Exp $";
d898 12
a909 15
	p(carps_ipackets, "\t%lu packet%s received (IPv4)\n");
	p(carps_ipackets6, "\t%lu packet%s received (IPv6)\n");
	p(carps_badif, "\t\t%lu packet%s discarded for bad interface\n");
	p(carps_hdrops, "\t\t%lu packet%s shorter than header\n");
	p(carps_badsum, "\t\t%lu discarded for bad checksum%s\n");
	p(carps_badver,	"\t\t%lu discarded packet%s with a bad version\n");
	p2(carps_badlen, "\t\t%lu discarded because packet too short\n");
	p2(carps_badauth, "\t\t%lu discarded for bad authentication\n");
	p2(carps_badvhid, "\t\t%lu discarded for bad vhid\n");
	p2(carps_badaddrs, "\t\t%lu discarded because of a bad address list\n");
	p(carps_opackets, "\t%lu packet%s sent (IPv4)\n");
	p(carps_opackets6, "\t%lu packet%s sent (IPv6)\n");
#if notyet
	p(carps_ostates, "\t\t%s state update%s sent\n");
#endif
@


1.85
log
@print tcps_rcvacktooold; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.84 2004/03/13 22:02:13 deraadt Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.84 2004/03/13 22:02:13 deraadt Exp $";
d935 16
a950 14
	p(pfsyncs_ipackets, "\t%lu packet%s received (IPv4)\n");
	p(pfsyncs_ipackets6, "\t%lu packet%s received (IPv6)\n");
	p(pfsyncs_badif, "\t\t%lu packet%s discarded for bad interface\n");
	p(pfsyncs_badttl, "\t\t%lu packet%s discarded for bad ttl\n");
	p(pfsyncs_hdrops, "\t\t%lu packet%s shorter than header\n");
	p(pfsyncs_badver,	"\t\t%lu discarded packet%s with a bad version\n");
	p(pfsyncs_badact,	"\t\t%lu discarded packet%s with a bad action\n");
	p2(pfsyncs_badlen, "\t\t%lu discarded because packet too short\n");
	p2(pfsyncs_badauth, "\t\t%lu discarded for bad authentication\n");
	p(pfsyncs_badstate, "\t%lu failed state lookup/insert%s\n");
	p(pfsyncs_opackets, "\t%lu packet%s sent (IPv4)\n");
	p(pfsyncs_opackets6, "\t%lu packet%s sent (IPv6)\n");
	p2(pfsyncs_onomem, "\t\t%lu send failed due to mbuf memory error\n");
	p2(pfsyncs_oerrors, "\t\t%lu send error\n");
@


1.84
log
@some NULL vs 0 and knf; parts from nimadeus@@pandora.be
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.83 2004/02/29 14:17:51 markus Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.83 2004/02/29 14:17:51 markus Exp $";
d288 1
@


1.83
log
@print tcps_conndrained; reminder from mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.82 2004/02/26 19:38:41 markus Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.82 2004/02/26 19:38:41 markus Exp $";
d705 1
a705 1
	cp = 0;
d715 1
a715 1
		if (cp == 0) {
d720 1
a720 1
					*cp = 0;
d879 1
a879 1
/* 
@


1.82
log
@better english
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.81 2004/02/26 08:51:45 markus Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.81 2004/02/26 08:51:45 markus Exp $";
d315 1
@


1.81
log
@print tcps_rcvmemdrop; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.80 2004/01/15 10:17:33 markus Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.80 2004/01/15 10:17:33 markus Exp $";
d306 1
a306 1
	p1(tcps_rcvmemdrop, "\t\t%u discarded for memory shortage\n");
@


1.80
log
@print stats for tcp md5 checksums (aka 'signature'); ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.79 2004/01/13 20:03:28 otto Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.79 2004/01/13 20:03:28 otto Exp $";
d306 1
@


1.79
log
@Fix printf formats and add missing include.

ok mcbride@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.78 2004/01/06 17:38:12 markus Exp $	*/
d37 1
a37 1
static const char *rcsid = "$OpenBSD: inet.c,v 1.78 2004/01/06 17:38:12 markus Exp $";
d307 2
@


1.78
log
@import netbsd's version of David Borman's syncache code
http://www.kohala.com/start/borman.97jun06.txt; ok deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.77 2003/12/27 23:17:34 mcbride Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: inet.c,v 1.77 2003/12/27 23:17:34 mcbride Exp $";
d893 12
a904 12
	p(carps_ipackets, "\t%u packet%s received (IPv4)\n");
	p(carps_ipackets6, "\t%u packet%s received (IPv6)\n");
	p(carps_badif, "\t\t%u packet%s discarded for bad interface\n");
	p(carps_hdrops, "\t\t%u packet%s shorter than header\n");
	p(carps_badsum, "\t\t%u discarded for bad checksum%s\n");
	p(carps_badver,	"\t\t%u discarded packet%s with a bad version\n");
	p2(carps_badlen, "\t\t%u discarded because packet too short\n");
	p2(carps_badauth, "\t\t%u discarded for bad authentication\n");
	p2(carps_badvhid, "\t\t%u discarded for bad vhid\n");
	p2(carps_badaddrs, "\t\t%u discarded because of a bad address list\n");
	p(carps_opackets, "\t%u packet%s sent (IPv4)\n");
	p(carps_opackets6, "\t%u packet%s sent (IPv6)\n");
d930 14
a943 14
	p(pfsyncs_ipackets, "\t%u packet%s received (IPv4)\n");
	p(pfsyncs_ipackets6, "\t%u packet%s received (IPv6)\n");
	p(pfsyncs_badif, "\t\t%u packet%s discarded for bad interface\n");
	p(pfsyncs_badttl, "\t\t%u packet%s discarded for bad ttl\n");
	p(pfsyncs_hdrops, "\t\t%u packet%s shorter than header\n");
	p(pfsyncs_badver,	"\t\t%u discarded packet%s with a bad version\n");
	p(pfsyncs_badact,	"\t\t%u discarded packet%s with a bad action\n");
	p2(pfsyncs_badlen, "\t\t%u discarded because packet too short\n");
	p2(pfsyncs_badauth, "\t\t%u discarded for bad authentication\n");
	p(pfsyncs_badstate, "\t%u failed state lookup/insert%s\n");
	p(pfsyncs_opackets, "\t%u packet%s sent (IPv4)\n");
	p(pfsyncs_opackets6, "\t%u packet%s sent (IPv6)\n");
	p2(pfsyncs_onomem, "\t\t%u send failed due to mbuf memory error\n");
	p2(pfsyncs_oerrors, "\t\t%u send error\n");
@


1.77
log
@Fix cut-n-paste oversight in pfsync_stats().
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.76 2003/12/22 22:25:34 mickey Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: inet.c,v 1.76 2003/12/22 22:25:34 mickey Exp $";
a323 1
	p(tcps_badsyn, "\t%u SYN packet%s received with same src/dst address/port\n");
d335 15
@


1.76
log
@remove a suplicate comment
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.75 2003/12/15 07:11:31 mcbride Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: inet.c,v 1.75 2003/12/15 07:11:31 mcbride Exp $";
d919 1
a919 1
	p(pfsyncs_badttl, "\t\t%u packet%s discarded for bad interface\n");
@


1.75
log
@Add initial support for pf state synchronization over the network.
Implemented as an in-kernel multicast IP protocol.

Turn it on like this:

# ifconfig pfsync0 up syncif fxp0

There is not yet any authentication on this protocol, so the syncif
must be on a trusted network. ie, a crossover cable between the two
firewalls.

NOTABLE CHANGES:
- A new index based on a unique (creatorid, stateid) tuple has been
  added to the state tree.
- Updates now appear on the pfsync(4) interface; multiple updates may
  be compressed into a single update.
- Applications which use bpf on pfsync(4) will need modification;
  packets on pfsync no longer contains regular pf_state structs,
  but pfsync_state structs which contain no pointers.

Much more to come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.74 2003/12/02 23:16:29 markus Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: inet.c,v 1.74 2003/12/02 23:16:29 markus Exp $";
a933 3
/*
 * Dump IPCOMP statistics structure.
 */
@


1.74
log
@UDP encapsulation for ESP in transport mode (draft-ietf-ipsec-udp-encaps-XX.txt)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.73 2003/11/07 23:38:48 mcbride Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: inet.c,v 1.73 2003/11/07 23:38:48 mcbride Exp $";
d74 3
d898 39
@


1.73
log
@Check to make sure that the packet was received on a carp-enabled interface.

Pointed out by Marco Pfatschbacher, ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.72 2003/11/02 10:23:58 markus Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: inet.c,v 1.72 2003/11/02 10:23:58 markus Exp $";
d820 3
@


1.72
log
@print raw ip[46] sockets; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.71 2003/10/31 09:00:32 mcbride Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: inet.c,v 1.71 2003/10/31 09:00:32 mcbride Exp $";
d875 1
@


1.71
log
@Add IPv6 support to CARP.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.70 2003/10/25 19:33:05 mcbride Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: inet.c,v 1.70 2003/10/25 19:33:05 mcbride Exp $";
d127 1
a127 1
	int istcp;
d136 1
d196 1
a196 1
		if (inpcb.inp_flags & INP_IPV6) {
d224 15
@


1.70
log
@#undef p2 in carp_stats()

Pointed out by Max Laier
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.69 2003/10/17 21:04:59 mcbride Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: inet.c,v 1.69 2003/10/17 21:04:59 mcbride Exp $";
d857 2
a858 1
	p(carps_ipackets, "\t%u packet%s received\n");
d866 2
a867 1
	p(carps_opackets, "\t%u packet%s sent\n");
@


1.69
log
@Common Address Redundancy Protocol

Allows multiple hosts to share an IP address, providing high availability
and load balancing.

Based on code by mickey@@, with additional help from markus@@
and Marco_Pfatschbacher@@genua.de

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.68 2003/09/04 20:05:19 tedu Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: inet.c,v 1.68 2003/09/04 20:05:19 tedu Exp $";
d870 1
@


1.68
log
@fix crash and add new icmpnames.  based on pr3439.  some input fgsch@@.
ok deraadt@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.67 2003/09/04 03:20:17 deraadt Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: inet.c,v 1.67 2003/09/04 03:20:17 deraadt Exp $";
d73 1
d836 33
@


1.67
log
@typo; aldo@@nullcube.com
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.66 2003/07/07 21:36:52 deraadt Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: inet.c,v 1.66 2003/07/07 21:36:52 deraadt Exp $";
d418 1
a418 1
static	char *icmpnames[] = {
d438 22
d488 5
a492 2
			printf("\t\t%s: %lu\n", icmpnames[i],
			    icmpstat.icps_outhist[i]);
d504 5
a508 2
			printf("\t\t%s: %lu\n", icmpnames[i],
			    icmpstat.icps_inhist[i]);
@


1.66
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.65 2003/06/03 02:56:13 millert Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: inet.c,v 1.65 2003/06/03 02:56:13 millert Exp $";
d782 1
a782 1
 * Dump ESP statistics structure.
@


1.65
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.64 2003/02/19 19:15:13 jason Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: inet.c,v 1.64 2003/02/19 19:15:13 jason Exp $";
d524 1
a524 1
char *
@


1.64
log
@add a counter for times ipcomp is skipped because the packet is below the
minimum compression threshold.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.63 2003/02/01 01:51:31 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char *rcsid = "$OpenBSD: inet.c,v 1.63 2003/02/01 01:51:31 deraadt Exp $";
@


1.63
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.62 2002/06/09 04:07:10 jsyn Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.62 2002/06/09 04:07:10 jsyn Exp $";
d843 1
@


1.62
log
@Standardization -- s/tdb/TDB/ and various dup expansions.

ok aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.61 2002/06/09 01:39:43 aaron Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.61 2002/06/09 01:39:43 aaron Exp $";
d98 1
a98 1
void	inetprint(struct in_addr *, int, char *, int);
d111 1
a111 3
protopr(off, name)
	u_long off;
	char *name;
d118 1
a118 3
ip6protopr(off, name)
	u_long off;
	char *name;
d125 1
a125 4
protopr0(off, name, af)
	u_long off;
	char *name;
	int af;
d206 1
a206 1
			sockb.so_snd.sb_cc);
d210 1
a210 1
				name, 1);
d212 1
a212 1
				name, 0);
d217 1
a217 1
				name, 1);
d219 1
a219 1
				name, 0);
d235 1
a235 3
tcp_stats(off, name)
	u_long off;
	char *name;
d241 1
a241 1
	printf ("%s:\n", name);
d332 1
a332 3
udp_stats(off, name)
	u_long off;
	char *name;
d373 1
a373 3
ip_stats(off, name)
	u_long off;
	char *name;
d448 1
a448 3
icmp_stats(off, name)
	u_long off;
	char *name;
d494 1
a494 3
igmp_stats(off, name)
	u_long off;
	char *name;
d529 1
a529 3
getrpcportnam(port, proto)
	in_port_t port;
	int proto;
d596 1
a596 5
inetprint(in, port, proto, local)
	struct in_addr *in;
	in_port_t port;
	char *proto;
	int local;
d626 1
a626 2
inetname(inp)
	struct in_addr *inp;
d681 1
a681 3
ah_stats(off, name)
	u_long off;
	char *name;
d722 1
a722 3
etherip_stats(off, name)
	u_long off;
	char *name;
a733 1

d750 1
a750 3
esp_stats(off, name)
	u_long off;
	char *name;
d789 1
a789 3
ipip_stats(off, name)
	u_long off;
	char *name;
d809 2
a810 2
	p(ipips_family, "\t%u protocol family mismatches\n");
	p(ipips_unspec, "\t%u attempts to use tunnel with unspecified endpoint(s)\n");
d818 1
a818 3
ipcomp_stats(off, name)
	u_long off;
	char *name;
@


1.61
log
@'cuz -> because; deraadt@@ ok, pvalchev@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.60 2002/05/27 01:50:36 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.60 2002/05/27 01:50:36 deraadt Exp $";
d287 1
a287 1
	    "\t\t%u packet%s with some dup. data (%qd byte%s duped)\n");
d409 1
a409 1
	p(ips_fragdropped, "\t%lu fragment%s dropped (dup or out of space)\n");
d734 1
a734 1
	p(ahs_invalid, "\t%u packet%s attempted to use an invalid tdb\n");
d807 1
a807 1
	p(esps_invalid, "\t%u packet%s attempted to use an invalid tdb\n");
d875 1
a875 1
	p(ipcomps_invalid, "\t%u packet%s attempted to use an invalid tdb\n");
@


1.60
log
@a night of cleanup, so i can read this easier
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.59 2002/05/16 14:18:34 kjc Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.59 2002/05/16 14:18:34 kjc Exp $";
d478 1
a478 1
	    "\t%lu error%s not generated 'cuz old message was icmp\n");
@


1.59
log
@display the ECN related statistics.
it is a bit verbose and will be cleaned up once we figure out which
counters are more useful than others.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.58 2002/02/19 21:11:23 miod Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.58 2002/02/19 21:11:23 miod Exp $";
d206 2
a207 2
			strcpy(namebuf, name0);
			strcat(namebuf, "6");
d254 1
a254 1
    printf(m, tcpstat.f, plural(tcpstat.f))
d256 1
a256 1
    printf(m, tcpstat.f)
d258 1
a258 1
    printf(m, tcpstat.f1, plural(tcpstat.f1), tcpstat.f2, plural(tcpstat.f2))
d260 1
a260 1
    printf(m, tcpstat.f1, plural(tcpstat.f1), tcpstat.f2)
d262 1
a262 1
    printf(m, tcpstat.f, plurales(tcpstat.f))
d266 1
a266 1
		"\t\t%u data packet%s (%qd byte%s)\n");
d268 1
a268 1
		"\t\t%u data packet%s (%qd byte%s) retransmitted\n");
d271 1
a271 1
		"\t\t%u ack-only packet%s (%u delayed)\n");
d282 1
a282 1
		"\t\t%u packet%s (%qu byte%s) received in-sequence\n");
d284 1
a284 1
		"\t\t%u completely duplicate packet%s (%qd byte%s)\n");
d287 1
a287 1
		"\t\t%u packet%s with some dup. data (%qd byte%s duped)\n");
d289 1
a289 1
		"\t\t%u out-of-order packet%s (%qd byte%s)\n");
d291 1
a291 1
		"\t\t%u packet%s (%qd byte%s) of data after window\n");
d304 1
a304 1
		"\t%u connection%s closed (including %u drop%s)\n");
d307 1
a307 1
		"\t%u segment%s updated rtt (of %u attempt%s)\n");
d353 1
a353 1
    printf(m, udpstat.f, plural(udpstat.f))
d355 2
a356 1
    printf(m, udpstat.f)
d368 4
a371 7
	delivered = udpstat.udps_ipackets -
		    udpstat.udps_hdrops -
		    udpstat.udps_badlen -
		    udpstat.udps_badsum -
		    udpstat.udps_noport -
		    udpstat.udps_noportbcast -
		    udpstat.udps_fullsock;
d396 1
a396 1
    printf(m, ipstat.f, plural(ipstat.f))
d398 1
a398 1
    printf(m, ipstat.f)
d474 1
a474 1
    printf(m, icmpstat.f, plural(icmpstat.f))
d486 1
a486 1
				icmpstat.icps_outhist[i]);
d499 1
a499 1
				icmpstat.icps_inhist[i]);
d521 1
a521 1
    printf(m, igmpstat.f, plural(igmpstat.f))
d523 2
a524 1
    printf(m, igmpstat.f, igmpstat.f != 1 ? "ies" : "y")
d663 1
a663 1
			(void) strcpy(domain, cp + 1);
d665 1
a665 1
			domain[0] = 0;
d717 1
a717 1
    printf(m, ahstat.f, plural(ahstat.f))
d719 1
a719 1
    printf(m, ahstat.f)
d760 1
a760 1
    printf(m, etheripstat.f, plural(etheripstat.f))
d791 1
a791 1
    printf(m, espstat.f, plural(espstat.f))
d832 1
a832 1
    printf(m, ipipstat.f, plural(ipipstat.f))
d863 1
a863 1
    printf(m, ipcompstat.f, plural(ipcompstat.f))
@


1.58
log
@IPsec is written ``IPsec'', not ``IPSec''.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.57 2002/02/19 18:38:02 mpech Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.57 2002/02/19 18:38:02 mpech Exp $";
d318 12
@


1.57
log
@Fix gethostname() usage.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.56 2002/02/16 21:27:50 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.56 2002/02/16 21:27:50 millert Exp $";
d298 1
a298 1
	p1(tcps_rcvnosec, "\t\t%u discarded for missing IPSec protection\n");
d353 1
a353 1
	p1(udps_nosec, "\t%lu dropped due to missing IPSec protection\n");
@


1.56
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.55 2002/01/17 21:34:58 mickey Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.55 2002/01/17 21:34:58 mickey Exp $";
d645 1
a645 1
	static char domain[MAXHOSTNAMELEN + 1];
d650 1
a650 1
		if (gethostname(domain, MAXHOSTNAMELEN) == 0 &&
@


1.55
log
@evil, annoying spaces and tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.54 2001/11/19 19:02:15 mpech Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.54 2001/11/19 19:02:15 mpech Exp $";
d95 1
a95 1
static void protopr0 __P((u_long, char *, int));
d97 2
a98 2
char	*inetname __P((struct in_addr *));
void	inetprint __P((struct in_addr *, int, char *, int));
d100 2
a101 2
char	*inet6name __P((struct in6_addr *));
void	inet6print __P((struct in6_addr *, int, char *, int));
@


1.54
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.53 2001/08/26 09:42:04 brian Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.53 2001/08/26 09:42:04 brian Exp $";
d515 8
a522 8
        p(igps_rcv_tooshort, "\t%lu message%s received with too few bytes\n");
        p(igps_rcv_badsum, "\t%lu message%s received with bad checksum\n");
        py(igps_rcv_queries, "\t%lu membership quer%s received\n");
        py(igps_rcv_badqueries, "\t%lu membership quer%s received with invalid field(s)\n");
        p(igps_rcv_reports, "\t%lu membership report%s received\n");
        p(igps_rcv_badreports, "\t%lu membership report%s received with invalid field(s)\n");
        p(igps_rcv_ourreports, "\t%lu membership report%s received for groups to which we belong\n");
        p(igps_snd_reports, "\t%lu membership report%s sent\n");
d550 1
a550 1
	
d695 2
a696 2
        u_long off;
        char *name;
d698 1
a698 1
        struct ahstat ahstat;
d700 4
a703 4
        if (off == 0)
                return;
        kread(off, (char *)&ahstat, sizeof (ahstat));
        printf("%s:\n", name);
d712 11
a722 11
        p(ahs_nopf, "\t%u packet%s from unsupported protocol families\n");
        p(ahs_hdrops, "\t%u packet%s shorter than header shows\n");
        p(ahs_pdrops, "\t%u packet%s dropped due to policy\n");
        p(ahs_notdb, "\t%u packet%s for which no TDB was found\n");
        p(ahs_badkcr, "\t%u input packet%s that failed to be processed\n");
        p(ahs_badauth, "\t%u packet%s that failed verification received\n");
        p(ahs_noxform, "\t%u packet%s for which no XFORM was set in TDB received\n");
        p(ahs_qfull, "\t%u packet%s were dropped due to full output queue\n");
        p(ahs_wrap, "\t%u packet%s where counter wrapping was detected\n");
        p(ahs_replay, "\t%u possibly replayed packet%s received\n");
        p(ahs_badauthl, "\t%u packet%s with bad authenticator length received\n");
d741 1
a741 1
        struct etheripstat etheripstat;
d743 4
a746 5
	
        if (off == 0)
                return;
        kread(off, (char *)&etheripstat, sizeof (etheripstat));
        printf("%s:\n", name);
d769 2
a770 2
        u_long off;
        char *name;
d772 1
a772 1
        struct espstat espstat;
d774 4
a777 5
	
        if (off == 0)
                return;
        kread(off, (char *)&espstat, sizeof (espstat));
        printf("%s:\n", name);
d784 12
a795 12
        p(esps_nopf, "\t%u packet%s from unsupported protocol families\n");
        p(esps_hdrops, "\t%u packet%s shorter than header shows\n");
        p(esps_pdrops, "\t%u packet%s dropped due to policy\n");
        p(esps_notdb, "\t%u packet%s for which no TDB was found\n");
        p(esps_badkcr, "\t%u input packet%s that failed to be processed\n");
        p(esps_badenc, "\t%u packet%s with bad encryption received\n");
        p(esps_badauth, "\t%u packet%s that failed verification received\n");
        p(esps_noxform, "\t%u packet%s for which no XFORM was set in TDB received\n");   
        p(esps_qfull, "\t%u packet%s were dropped due to full output queue\n");
        p(esps_wrap, "\t%u packet%s where counter wrapping was detected\n");
        p(esps_replay, "\t%u possibly replayed packet%s received\n"); 
        p(esps_badilen, "\t%u packet%s with bad payload size or padding received\n");
d810 2
a811 2
        u_long off;
        char *name;
d813 1
a813 1
        struct ipipstat ipipstat;
d815 4
a818 4
        if (off == 0)
                return;
        kread(off, (char *)&ipipstat, sizeof (ipipstat));
        printf("%s:\n", name);
d823 6
a828 6
        p(ipips_ipackets, "\t%u total input packet%s\n");
        p(ipips_opackets, "\t%u total output packet%s\n");
        p(ipips_hdrops, "\t%u packet%s shorter than header shows\n");
        p(ipips_pdrops, "\t%u packet%s dropped due to policy\n");
        p(ipips_spoof, "\t%u packet%s with possibly spoofed local addresses\n");
        p(ipips_qfull, "\t%u packet%s were dropped due to full output queue\n");
a845 1
	
d861 1
a861 1
	p(ipcomps_noxform, "\t%u packet%s for which no XFORM was set in TDB received\n");   
@


1.53
log
@Add a -q to silence zero-output lines and fix some whitespace and text nits.

Submitted by:	Sam Smith <S@@mSmith.net>
Ok:		theo
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.52 2001/07/05 08:54:41 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.52 2001/07/05 08:54:41 angelos Exp $";
d135 1
a135 1
	register struct inpcb *head, *next, *prev;
d138 1
a138 1
	static int first = 1;
d456 1
a456 1
	register int i, first;
d540 1
a540 1
	register struct hostent *hp;
d544 1
a544 1
	register CLIENT *client;
d605 1
a605 1
	register struct in_addr *in;
d641 1
a641 1
	register char *cp;
@


1.52
log
@Make it compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.51 2001/07/05 08:47:43 jjbg Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.51 2001/07/05 08:47:43 jjbg Exp $";
d753 2
a754 2
        p(etherip_hdrops, "\t%u packet%s shorter than header shows\n");
        p(etherip_qfull, "\t%u packet%s were dropped due to full output queue\n");
d756 4
a759 4
        p(etherip_pdrops, "\t%u packet%s dropped due to policy\n");
        p(etherip_adrops, "\t%u packet%s dropped for other reasons\n");
	p(etherip_ipackets, "\t%u input ethernet-in-IP packets\n");
	p(etherip_opackets, "\t%u output ethernet-in-IP packets\n");
@


1.51
log
@IPComp support. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.50 2001/06/23 06:09:09 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.50 2001/06/23 06:09:09 angelos Exp $";
d75 1
a863 2
	p(ipcomps_badenc, "\t%u packet%s with bad compression received\n");
	p(ipcomps_badauth, "\t%u packet%s that failed verification received\n");
a866 2
	p(ipcomps_replay, "\t%u possibly replayed packet%s received\n"); 
	p(ipcomps_badilen, "\t%u packet%s with bad payload size or padding received\n");
@


1.50
log
@Print hardware checksumming statistics.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.49 2001/03/03 01:00:20 itojun Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.49 2001/03/03 01:00:20 itojun Exp $";
d834 42
@


1.49
log
@drop packets with 127.0.0.0/8 in header field, if the packet is from outside.
under RFC1122 sender rule 127.0.0.8 must not appear on the wire.
count incidents by ipstat.ips_badaddr.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.48 2000/06/30 20:04:01 itojun Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.48 2000/06/30 20:04:01 itojun Exp $";
d275 1
d298 1
d348 2
d418 2
@


1.48
log
@split netstat -an -f inet and netstat -an -f inet6, for consistency.
Suggested by: fgs
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.47 2000/06/15 20:05:48 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.47 2000/06/15 20:05:48 angelos Exp $";
d413 1
@


1.47
log
@Reflect reality in the error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.46 2000/03/20 02:38:35 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.46 2000/03/20 02:38:35 angelos Exp $";
d94 2
d114 19
d158 13
@


1.46
log
@Print statistics about crypto failures in IPsec processing.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.45 2000/01/21 03:24:06 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.45 2000/01/21 03:24:06 angelos Exp $";
d755 1
a755 1
        p(esps_badilen, "\t%u packet%s with payload not a multiple of 8 received\n");
@


1.45
log
@ip4 -> ipip
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.44 2000/01/09 23:44:03 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.44 2000/01/09 23:44:03 angelos Exp $";
d683 1
d758 1
@


1.44
log
@Add new ESP/AH statistic.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.43 2000/01/05 00:07:08 itojun Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.43 2000/01/05 00:07:08 itojun Exp $";
d74 1
a74 1
#include <netinet/ip_ip4.h>
d767 1
a767 1
ip4_stats(off, name)
d771 1
a771 1
        struct ip4stat ip4stat;
d775 1
a775 1
        kread(off, (char *)&ip4stat, sizeof (ip4stat));
d778 2
a779 2
#define p(f, m) if (ip4stat.f || sflag <= 1) \
    printf(m, ip4stat.f, plural(ip4stat.f))
d781 10
a790 10
        p(ip4s_ipackets, "\t%u total input packet%s\n");
        p(ip4s_opackets, "\t%u total output packet%s\n");
        p(ip4s_hdrops, "\t%u packet%s shorter than header shows\n");
        p(ip4s_pdrops, "\t%u packet%s dropped due to policy\n");
        p(ip4s_spoof, "\t%u packet%s with possibly spoofed local addresses\n");
        p(ip4s_qfull, "\t%u packet%s were dropped due to full output queue\n");
	p(ip4s_ibytes, "\t%qu input byte%s\n");
	p(ip4s_obytes, "\t%qu output byte%s\n");
	p(ip4s_family, "\t%u protocol family mismatches\n");
	p(ip4s_unspec, "\t%u attempts to use tunnel with unspecified endpoint(s)\n");
@


1.43
log
@s/input histogram/input packet/histogram/
suggested by: deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.42 2000/01/03 04:27:57 itojun Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.42 2000/01/03 04:27:57 itojun Exp $";
d670 1
d743 1
@


1.42
log
@add missing stat items in ip section.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.41 1999/12/09 09:02:28 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.41 1999/12/09 09:02:28 angelos Exp $";
d430 1
a430 1
				printf("\tOutput histogram:\n");
d443 1
a443 1
				printf("\tInput histogram:\n");
@


1.41
log
@Add "unspecified tunnel endpoint" statistic.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.40 1999/12/09 08:55:16 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.40 1999/12/09 08:55:16 angelos Exp $";
d377 2
@


1.40
log
@Protocol family mismatch counter for IP-IP.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.39 1999/12/09 04:21:55 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.39 1999/12/09 04:21:55 angelos Exp $";
d786 1
@


1.39
log
@Remove unnecessary statistic.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.38 1999/12/08 12:30:17 itojun Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.38 1999/12/08 12:30:17 itojun Exp $";
d785 1
a785 1

@


1.38
log
@add IPv6 support from KAME.  cleanup type matches with printf() format.
KAME_SCOPEID should be enabled after KAME get{addr,name}info(3) merge.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.37 1999/12/06 11:17:26 niklas Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.37 1999/12/06 11:17:26 niklas Exp $";
a781 1
        p(ip4s_notip4, "\t%u packet%s with internal header not IPv4 received\n");
@


1.37
log
@so sorry angelos, I am too stressed out, reverted my goofup.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.35 1999/12/06 00:45:17 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.35 1999/12/06 00:45:17 angelos Exp $";
d96 4
d117 2
d120 1
d163 1
a163 1
		if (Aflag)
d168 9
d179 14
a192 2
		inetprint(&inpcb.inp_laddr, (int)inpcb.inp_lport, name, 1);
		inetprint(&inpcb.inp_faddr, (int)inpcb.inp_fport, name, 0);
d220 2
d224 2
d229 1
a229 1
	p(tcps_sndtotal, "\t%ld packet%s sent\n");
d231 1
a231 1
		"\t\t%ld data packet%s (%qd byte%s)\n");
d233 1
a233 1
		"\t\t%ld data packet%s (%qd byte%s) retransmitted\n");
d235 10
a244 10
	p2(tcps_sndacks, tcps_delack,
		"\t\t%ld ack-only packet%s (%ld delayed)\n");
	p(tcps_sndurg, "\t\t%ld URG only packet%s\n");
	p(tcps_sndprobe, "\t\t%ld window probe packet%s\n");
	p(tcps_sndwinup, "\t\t%ld window update packet%s\n");
	p(tcps_sndctrl, "\t\t%ld control packet%s\n");
	p(tcps_rcvtotal, "\t%ld packet%s received\n");
	p2(tcps_rcvackpack, tcps_rcvackbyte, "\t\t%ld ack%s (for %qd byte%s)\n");
	p(tcps_rcvdupack, "\t\t%ld duplicate ack%s\n");
	p(tcps_rcvacktoomuch, "\t\t%ld ack%s for unsent data\n");
d246 1
a246 1
		"\t\t%ld packet%s (%qd byte%s) received in-sequence\n");
d248 2
a249 2
		"\t\t%ld completely duplicate packet%s (%qd byte%s)\n");
	p(tcps_pawsdrop, "\t\t%ld old duplicate packet%s\n");
d251 1
a251 1
		"\t\t%ld packet%s with some dup. data (%qd byte%s duped)\n");
d253 1
a253 1
		"\t\t%ld out-of-order packet%s (%qd byte%s)\n");
d255 11
a265 11
		"\t\t%ld packet%s (%qd byte%s) of data after window\n");
	p(tcps_rcvwinprobe, "\t\t%ld window probe%s\n");
	p(tcps_rcvwinupd, "\t\t%ld window update packet%s\n");
	p(tcps_rcvafterclose, "\t\t%ld packet%s received after close\n");
	p(tcps_rcvbadsum, "\t\t%ld discarded for bad checksum%s\n");
	p(tcps_rcvbadoff, "\t\t%ld discarded for bad header offset field%s\n");
	p(tcps_rcvshort, "\t\t%ld discarded because packet too short\n");
	p(tcps_rcvnosec, "\t\t%ld discarded for missing IPSec protection\n");
	p(tcps_connattempt, "\t%ld connection request%s\n");
	p(tcps_accepts, "\t%ld connection accept%s\n");
	p(tcps_connects, "\t%ld connection%s established (including accepts)\n");
d267 2
a268 2
		"\t%ld connection%s closed (including %ld drop%s)\n");
	p(tcps_conndrops, "\t%ld embryonic connection%s dropped\n");
d270 11
a280 11
		"\t%ld segment%s updated rtt (of %ld attempt%s)\n");
	p(tcps_rexmttimeo, "\t%ld retransmit timeout%s\n");
	p(tcps_timeoutdrop, "\t\t%ld connection%s dropped by rexmit timeout\n");
	p(tcps_persisttimeo, "\t%ld persist timeout%s\n");
	p(tcps_keeptimeo, "\t%ld keepalive timeout%s\n");
	p(tcps_keepprobe, "\t\t%ld keepalive probe%s sent\n");
	p(tcps_keepdrops, "\t\t%ld connection%s dropped by keepalive\n");
	p(tcps_predack, "\t%ld correct ACK header prediction%s\n");
	p(tcps_preddat, "\t%ld correct data packet header prediction%s\n");
	p3(tcps_pcbhashmiss, "\t%ld PCB cache miss%s\n");
	p(tcps_badsyn, "\t%ld SYN packet%s received with same src/dst address/port\n");
d282 1
d284 1
d305 2
d308 5
a312 5
	p(udps_hdrops, "\t%lu with incomplete header\n");
	p(udps_badlen, "\t%lu with bad data length field\n");
	p(udps_badsum, "\t%lu with bad checksum\n");
	p(udps_nosum, "\t%lu with no checksum\n");
	p(udps_noport, "\t%lu dropped due to no socket\n");
d314 2
a315 2
	p(udps_nosec, "\t%lu dropped due to missing IPSec protection\n");
	p(udps_fullsock, "\t%lu dropped due to full socket buffers\n");
d326 1
a326 1
	p(udps_pcbhashmiss, "\t%lu missed PCB cache\n");
d328 1
d348 2
d353 6
a358 6
	p(ips_toosmall, "\t%lu with size smaller than minimum\n");
	p(ips_tooshort, "\t%lu with data size < data length\n");
	p(ips_badhlen, "\t%lu with header length < data size\n");
	p(ips_badlen, "\t%lu with data length < header length\n");
	p(ips_badoptions, "\t%lu with bad options\n");
	p(ips_badvers, "\t%lu with incorrect version number\n");
d376 1
a376 1
	p(ips_rcvmemdrop, "\t%lu fragment floods\n");
d378 1
a567 1
	int proton;
d663 2
d666 2
a667 2
	p(ahs_input, "\t%u input AH packets\n");
	p(ahs_output, "\t%u output AH packets\n");
d684 1
d738 2
a739 2
	p(esps_input, "\t%u input ESP packets\n");
	p(esps_output, "\t%u output ESP packets\n");
@


1.36
log
@angelos, altering kernel structures may have impact on userland.
@
text
@d702 1
@


1.35
log
@Display esps_badenc
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.34 1999/10/29 03:26:40 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.34 1999/10/29 03:26:40 angelos Exp $";
a701 1
        p(esps_badenc, "\t%u packet%s with bad encryption received\n");
@


1.34
log
@etherip statistics
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.33 1999/04/11 19:41:40 niklas Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.33 1999/04/11 19:41:40 niklas Exp $";
d702 1
@


1.33
log
@Introduce net.inet.{ah,esp}.enable sysctl controls that are off by default.
If you are going to use either of AH or ESP or both, enable these in
/etc/sysctl.conf.  Also correct the IPSec debugging sysctl code, it is now
named net.inet.ip.encdebug.  Some corrected function signatures too.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.32 1999/04/09 23:30:05 niklas Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.32 1999/04/09 23:30:05 niklas Exp $";
d75 1
d642 32
@


1.32
log
@The userland parts of a sysctl that can switch on/off IP-in-IP (protocol 4)
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.31 1999/03/27 21:04:21 provos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.31 1999/03/27 21:04:21 provos Exp $";
d627 1
d666 1
@


1.31
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.30 1999/02/24 22:57:34 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.30 1999/02/24 22:57:34 angelos Exp $";
d702 2
@


1.30
log
@Grok protocol/address family PF_KEY.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.29 1999/02/18 08:25:51 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.29 1999/02/18 08:25:51 deraadt Exp $";
d229 1
d277 1
@


1.29
log
@fix netstat -A header
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.28 1999/02/17 23:50:38 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.28 1999/02/17 23:50:38 deraadt Exp $";
d71 1
@


1.28
log
@print ips_rcvmemdrop
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.27 1999/02/04 16:05:03 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.27 1999/02/04 16:05:03 deraadt Exp $";
d143 1
a143 1
				printf("%-*.*s %-5.5s %-6.6s %-6.6s  %-*.*s %-*.*s %s\n",
d145 2
a146 2
				    "Send-Q", PLEN, PLEN, "Local Address",
				    PLEN, PLEN, "Foreign Address", "(state)");
@


1.27
log
@report on no udp checksum
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.26 1998/11/30 03:57:15 provos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.26 1998/11/30 03:57:15 provos Exp $";
d333 1
@


1.26
log
@stats for fast retransmits
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.25 1998/11/25 02:11:44 niklas Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.25 1998/11/25 02:11:44 niklas Exp $";
d272 1
@


1.25
log
@Present new statistics field in ah/esp stats
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.24 1998/03/18 02:43:04 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.24 1998/03/18 02:43:04 angelos Exp $";
d200 1
@


1.24
log
@Update for new tcp stat.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.23 1998/02/27 12:07:33 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.23 1998/02/27 12:07:33 deraadt Exp $";
d630 1
d668 1
@


1.23
log
@oflow paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.22 1997/11/09 16:33:09 provos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.22 1997/11/09 16:33:09 provos Exp $";
d244 1
@


1.22
log
@also report udp PCB cache misses.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.21 1997/07/28 01:47:43 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.21 1997/07/28 01:47:43 deraadt Exp $";
d457 1
a457 1
	char num[10];
d493 2
a494 1
				sprintf(num, "%ld", head->pml_map.pm_prog);
d523 2
a524 1
	sprintf(line, "%.*s.", (Aflag && !nflag) ? 12 : 16, inetname(in));
d529 2
a530 1
		sprintf(cp, "%.8s", sp ? sp->s_name : "*");
d533 2
a534 1
		sprintf(cp, "%d[%.8s]", ntohs(port), nam);
d536 1
a536 1
		sprintf(cp, "%d", ntohs(port));
d586 1
a586 1
		strcpy(line, "*");
d588 1
a588 1
		strcpy(line, cp);
d592 3
a594 2
		sprintf(line, "%u.%u.%u.%u", C(inp->s_addr >> 24),
		    C(inp->s_addr >> 16), C(inp->s_addr >> 8), C(inp->s_addr));
@


1.21
log
@for rpc port names, consider protocol too
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.20 1997/07/14 21:31:33 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.20 1997/07/14 21:31:33 angelos Exp $";
d283 1
@


1.20
log
@Print the new input/output bytes for sipp-ah/sipp-esp/ipencap.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.19 1997/07/01 20:32:14 provos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.19 1997/07/01 20:32:14 provos Exp $";
d437 1
d442 1
a442 1
getrpcportnam(port)
d444 1
d486 1
d500 1
a500 1
		if (n->port == port)
d518 1
d527 2
a528 1
	else if (local && !nflag && (nam = getrpcportnam(ntohs(port))))
@


1.19
log
@typos
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.18 1997/06/29 21:46:01 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.18 1997/06/29 21:46:01 millert Exp $";
d618 3
d634 1
d655 2
d684 2
@


1.18
log
@Use correct spacing on both 32bit and 64bit machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.17 1997/06/29 20:52:39 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.17 1997/06/29 20:52:39 millert Exp $";
d613 1
a613 1
        p(ahs_qfull, "\t%u packet%s were dropeed due to full output queue\n");
d646 1
a646 1
        p(esps_qfull, "\t%u packet%s were dropeed due to full output queue\n");
d677 1
a677 1
        p(ip4s_qfull, "\t%u packet%s were dropeed due to full output queue\n");
@


1.17
log
@Make fields line up nicely for 64-bit addresses.  Should probably #if
some things based on sizeof(long).
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.16 1997/06/29 20:17:59 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.16 1997/06/29 20:17:59 millert Exp $";
d76 1
d143 9
a151 6
				printf("%-18.18s ", "PCB");
			printf(Aflag ?
				"%-5.5s %-6.6s %-6.6s  %-18.18s %-18.18s %s\n" :
				"%-5.5s %-6.6s %-6.6s  %-22.22s %-22.22s %s\n",
				"Proto", "Recv-Q", "Send-Q",
				"Local Address", "Foreign Address", "(state)");
d156 1
a156 1
				printf("%18p ", inpcb.inp_ppcb);
d158 1
a158 1
				printf("%18p ", prev);
@


1.16
log
@Mostly clean -Wall + 64bit issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.15 1997/06/25 07:56:18 provos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.15 1997/06/25 07:56:18 provos Exp $";
d142 1
a142 1
				printf("%-8.8s ", "PCB");
d152 1
a152 1
				printf("%8p ", inpcb.inp_ppcb);
d154 1
a154 1
				printf("%8p ", prev);
@


1.15
log
@show statistics about new timers/counters
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.14 1997/06/24 02:26:18 dgregor Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.14 1997/06/24 02:26:18 dgregor Exp $";
d152 1
a152 1
				printf("%8x ", inpcb.inp_ppcb);
d154 2
a155 2
				printf("%8x ", prev);
		printf("%-5.5s %6d %6d ", name, sockb.so_rcv.sb_cc,
d191 1
a191 1
	p(tcps_sndtotal, "\t%d packet%s sent\n");
d193 1
a193 1
		"\t\t%d data packet%s (%qd byte%s)\n");
d195 1
a195 1
		"\t\t%d data packet%s (%qd byte%s) retransmitted\n");
d197 9
a205 9
		"\t\t%d ack-only packet%s (%d delayed)\n");
	p(tcps_sndurg, "\t\t%d URG only packet%s\n");
	p(tcps_sndprobe, "\t\t%d window probe packet%s\n");
	p(tcps_sndwinup, "\t\t%d window update packet%s\n");
	p(tcps_sndctrl, "\t\t%d control packet%s\n");
	p(tcps_rcvtotal, "\t%d packet%s received\n");
	p2(tcps_rcvackpack, tcps_rcvackbyte, "\t\t%d ack%s (for %qd byte%s)\n");
	p(tcps_rcvdupack, "\t\t%d duplicate ack%s\n");
	p(tcps_rcvacktoomuch, "\t\t%d ack%s for unsent data\n");
d207 1
a207 1
		"\t\t%d packet%s (%qd byte%s) received in-sequence\n");
d209 2
a210 2
		"\t\t%d completely duplicate packet%s (%qd byte%s)\n");
	p(tcps_pawsdrop, "\t\t%d old duplicate packet%s\n");
d212 1
a212 1
		"\t\t%d packet%s with some dup. data (%qd byte%s duped)\n");
d214 1
a214 1
		"\t\t%d out-of-order packet%s (%qd byte%s)\n");
d216 10
a225 10
		"\t\t%d packet%s (%qd byte%s) of data after window\n");
	p(tcps_rcvwinprobe, "\t\t%d window probe%s\n");
	p(tcps_rcvwinupd, "\t\t%d window update packet%s\n");
	p(tcps_rcvafterclose, "\t\t%d packet%s received after close\n");
	p(tcps_rcvbadsum, "\t\t%d discarded for bad checksum%s\n");
	p(tcps_rcvbadoff, "\t\t%d discarded for bad header offset field%s\n");
	p(tcps_rcvshort, "\t\t%d discarded because packet too short\n");
	p(tcps_connattempt, "\t%d connection request%s\n");
	p(tcps_accepts, "\t%d connection accept%s\n");
	p(tcps_connects, "\t%d connection%s established (including accepts)\n");
d227 2
a228 2
		"\t%d connection%s closed (including %d drop%s)\n");
	p(tcps_conndrops, "\t%d embryonic connection%s dropped\n");
d230 10
a239 10
		"\t%d segment%s updated rtt (of %d attempt%s)\n");
	p(tcps_rexmttimeo, "\t%d retransmit timeout%s\n");
	p(tcps_timeoutdrop, "\t\t%d connection%s dropped by rexmit timeout\n");
	p(tcps_persisttimeo, "\t%d persist timeout%s\n");
	p(tcps_keeptimeo, "\t%d keepalive timeout%s\n");
	p(tcps_keepprobe, "\t\t%d keepalive probe%s sent\n");
	p(tcps_keepdrops, "\t\t%d connection%s dropped by keepalive\n");
	p(tcps_predack, "\t%d correct ACK header prediction%s\n");
	p(tcps_preddat, "\t%d correct data packet header prediction%s\n");
	p3(tcps_pcbhashmiss, "\t%d PCB cache miss%s\n");
d262 7
a268 7
	p(udps_ipackets, "\t%u datagram%s received\n");
	p(udps_hdrops, "\t%u with incomplete header\n");
	p(udps_badlen, "\t%u with bad data length field\n");
	p(udps_badsum, "\t%u with bad checksum\n");
	p(udps_noport, "\t%u dropped due to no socket\n");
	p(udps_noportbcast, "\t%u broadcast/multicast datagram%s dropped due to no socket\n");
	p(udps_fullsock, "\t%u dropped due to full socket buffers\n");
d277 2
a278 2
		printf("\t%u delivered\n", delivered);
	p(udps_opackets, "\t%u datagram%s output\n");
d300 25
a324 25
	p(ips_total, "\t%u total packet%s received\n");
	p(ips_badsum, "\t%u bad header checksum%s\n");
	p(ips_toosmall, "\t%u with size smaller than minimum\n");
	p(ips_tooshort, "\t%u with data size < data length\n");
	p(ips_badhlen, "\t%u with header length < data size\n");
	p(ips_badlen, "\t%u with data length < header length\n");
	p(ips_badoptions, "\t%u with bad options\n");
	p(ips_badvers, "\t%u with incorrect version number\n");
	p(ips_fragments, "\t%u fragment%s received\n");
	p(ips_fragdropped, "\t%u fragment%s dropped (dup or out of space)\n");
	p(ips_badfrags, "\t%u malformed fragment%s dropped\n");
	p(ips_fragtimeout, "\t%u fragment%s dropped after timeout\n");
	p(ips_reassembled, "\t%u packet%s reassembled ok\n");
	p(ips_delivered, "\t%u packet%s for this host\n");
	p(ips_noproto, "\t%u packet%s for unknown/unsupported protocol\n");
	p(ips_forward, "\t%u packet%s forwarded\n");
	p(ips_cantforward, "\t%u packet%s not forwardable\n");
	p(ips_redirectsent, "\t%u redirect%s sent\n");
	p(ips_localout, "\t%u packet%s sent from this host\n");
	p(ips_rawout, "\t%u packet%s sent with fabricated ip header\n");
	p(ips_odropped, "\t%u output packet%s dropped due to no bufs, etc.\n");
	p(ips_noroute, "\t%u output packet%s discarded due to no route\n");
	p(ips_fragmented, "\t%u output datagram%s fragmented\n");
	p(ips_ofragments, "\t%u fragment%s created\n");
	p(ips_cantfrag, "\t%u datagram%s that can't be fragmented\n");
d369 1
a369 1
	p(icps_error, "\t%u call%s to icmp_error\n");
d371 1
a371 1
	    "\t%u error%s not generated 'cuz old message was icmp\n");
d378 1
a378 1
			printf("\t\t%s: %u\n", icmpnames[i],
d381 4
a384 4
	p(icps_badcode, "\t%u message%s with bad code fields\n");
	p(icps_tooshort, "\t%u message%s < minimum length\n");
	p(icps_checksum, "\t%u bad checksum%s\n");
	p(icps_badlen, "\t%u message%s with bad length\n");
d391 1
a391 1
			printf("\t\t%s: %u\n", icmpnames[i],
d394 1
a394 1
	p(icps_reflect, "\t%u message response%s generated\n");
d417 9
a425 9
	p(igps_rcv_total, "\t%u message%s received\n");
        p(igps_rcv_tooshort, "\t%u message%s received with too few bytes\n");
        p(igps_rcv_badsum, "\t%u message%s received with bad checksum\n");
        py(igps_rcv_queries, "\t%u membership quer%s received\n");
        py(igps_rcv_badqueries, "\t%u membership quer%s received with invalid field(s)\n");
        p(igps_rcv_reports, "\t%u membership report%s received\n");
        p(igps_rcv_badreports, "\t%u membership report%s received with invalid field(s)\n");
        p(igps_rcv_ourreports, "\t%u membership report%s received for groups to which we belong\n");
        p(igps_snd_reports, "\t%u membership report%s sent\n");
d432 1
a432 1
	int	port;
d438 1
a438 1
	int port;
d485 1
a485 1
				sprintf(num, "%d", head->pml_map.pm_prog);
d505 1
a505 1
	int port;
d519 2
a520 2
	else if (local && !nflag && (nam = getrpcportnam(ntohs((u_short)port))))
		sprintf(cp, "%d[%.8s]", ntohs((u_short)port), nam);
d522 1
a522 1
		sprintf(cp, "%d", ntohs((u_short)port));
@


1.14
log
@Add '#include <stdlib.h>' for malloc()
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.13 1997/06/15 13:47:27 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.13 1997/06/15 13:47:27 deraadt Exp $";
d613 1
d646 1
@


1.13
log
@change byte counters to u_quad_t
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.12 1997/02/27 01:48:26 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.12 1997/02/27 01:48:26 angelos Exp $";
d80 1
@


1.12
log
@Now reports ESP I/O packet counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.11 1997/02/26 03:08:43 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.11 1997/02/26 03:08:43 angelos Exp $";
d192 1
a192 1
		"\t\t%d data packet%s (%d byte%s)\n");
d194 1
a194 1
		"\t\t%d data packet%s (%d byte%s) retransmitted\n");
d202 1
a202 1
	p2(tcps_rcvackpack, tcps_rcvackbyte, "\t\t%d ack%s (for %d byte%s)\n");
d206 1
a206 1
		"\t\t%d packet%s (%d byte%s) received in-sequence\n");
d208 1
a208 1
		"\t\t%d completely duplicate packet%s (%d byte%s)\n");
d211 1
a211 1
		"\t\t%d packet%s with some dup. data (%d byte%s duped)\n");
d213 1
a213 1
		"\t\t%d out-of-order packet%s (%d byte%s)\n");
d215 1
a215 1
		"\t\t%d packet%s (%d byte%s) of data after window\n");
@


1.11
log
@Updated to print the IP-in-IP/AH I/O counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.10 1997/02/21 09:09:50 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.10 1997/02/21 09:09:50 angelos Exp $";
d633 2
@


1.10
log
@netstat now understands SIPP-AH/SIPP-ESP (IPsec) and ENCAP protocols.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.9 1997/02/21 02:46:49 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.9 1997/02/21 02:46:49 deraadt Exp $";
d601 2
d665 1
@


1.9
log
@flesh out icmp, no rpc info for -n
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.8 1997/02/16 10:55:08 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.8 1997/02/16 10:55:08 deraadt Exp $";
d71 3
d581 87
@


1.8
log
@duh
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.7 1997/02/16 10:31:23 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.7 1997/02/16 10:31:23 deraadt Exp $";
d334 2
a335 2
	"#9",
	"#10",
d515 1
a515 1
	else if (local && (nam = getrpcportnam(ntohs((u_short)port))))
@


1.7
log
@deal with errors in recent change better
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.6 1997/02/16 10:26:36 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.6 1997/02/16 10:26:36 deraadt Exp $";
d465 1
a465 1
		    xdr_pmaplist, &head, minutetimeout) != RPC_SUCCESS)
@


1.6
log
@change from <> to [] and document
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.5 1997/02/16 10:22:24 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.5 1997/02/16 10:22:24 deraadt Exp $";
d450 1
a450 1
		bzero((char *)&server_addr, sizeof server_addr);
d453 1
a453 1
			bcopy(hp->h_addr, (caddr_t)&server_addr.sin_addr,
d462 2
a463 4
		    PMAPVERS, &socket, 50, 500)) == NULL) {
			clnt_pcreateerror("rpcinfo: can't contact portmapper");
			exit(1);
		}
d465 3
a467 4
		    xdr_pmaplist, &head, minutetimeout) != RPC_SUCCESS) {
			fprintf(stderr, "rpcinfo: can't contact portmapper: ");
			clnt_perror(client, "rpcinfo");
			exit(1);
@


1.5
log
@when printing local port numbers, print rpc service name in <> after port number, if available
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.4 1997/01/17 07:12:57 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.4 1997/01/17 07:12:57 millert Exp $";
d519 1
a519 1
		sprintf(cp, "%d<%.8s>", ntohs((u_short)port), nam);
@


1.4
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.3 1996/06/26 05:37:21 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.3 1996/06/26 05:37:21 deraadt Exp $";
d79 4
d88 1
a88 1
void	inetprint __P((struct in_addr *, int, char *));
d153 2
a154 2
		inetprint(&inpcb.inp_laddr, (int)inpcb.inp_lport, name);
		inetprint(&inpcb.inp_faddr, (int)inpcb.inp_fport, name);
d426 71
d502 1
a502 1
inetprint(in, port, proto)
d506 1
d509 1
a509 1
	char line[80], *cp;
d518 2
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: inet.c,v 1.14 1995/10/03 21:42:37 thorpej Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: inet.c,v 1.14 1995/10/03 21:42:37 thorpej Exp $";
d437 1
a437 1
	cp = index(line, '\0');
d467 1
a467 1
		    (cp = index(domain, '.')))
d485 1
a485 1
				if ((cp = index(hp->h_name, '.')) &&
@


1.2
log
@Changes according to the /sys/netinet/tcp_var.h changes.
@
text
@d1 1
d41 1
a41 1
static char *rcsid = "$NetBSD: inet.c,v 1.14 1995/10/03 21:42:37 thorpej Exp $";
@


1.1
log
@Initial revision
@
text
@d230 1
a230 1
	p3(tcps_pcbcachemiss, "\t%d PCB cache miss%s\n");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

