head	1.111;
access;
symbols
	OPENBSD_6_1:1.111.0.4
	OPENBSD_6_1_BASE:1.111
	OPENBSD_6_0:1.110.0.2
	OPENBSD_6_0_BASE:1.110
	OPENBSD_5_9:1.109.0.2
	OPENBSD_5_9_BASE:1.109
	OPENBSD_5_8:1.106.0.6
	OPENBSD_5_8_BASE:1.106
	OPENBSD_5_7:1.106.0.2
	OPENBSD_5_7_BASE:1.106
	OPENBSD_5_6:1.101.0.4
	OPENBSD_5_6_BASE:1.101
	OPENBSD_5_5:1.100.0.4
	OPENBSD_5_5_BASE:1.100
	OPENBSD_5_4:1.95.0.2
	OPENBSD_5_4_BASE:1.95
	OPENBSD_5_3:1.94.0.2
	OPENBSD_5_3_BASE:1.94
	OPENBSD_5_2:1.92.0.4
	OPENBSD_5_2_BASE:1.92
	OPENBSD_5_1_BASE:1.92
	OPENBSD_5_1:1.92.0.2
	OPENBSD_5_0:1.89.0.2
	OPENBSD_5_0_BASE:1.89
	OPENBSD_4_9:1.87.0.2
	OPENBSD_4_9_BASE:1.87
	OPENBSD_4_8:1.85.0.2
	OPENBSD_4_8_BASE:1.85
	OPENBSD_4_7:1.82.0.2
	OPENBSD_4_7_BASE:1.82
	OPENBSD_4_6:1.79.0.4
	OPENBSD_4_6_BASE:1.79
	OPENBSD_4_5:1.78.0.2
	OPENBSD_4_5_BASE:1.78
	OPENBSD_4_4:1.75.0.2
	OPENBSD_4_4_BASE:1.75
	OPENBSD_4_3:1.74.0.2
	OPENBSD_4_3_BASE:1.74
	OPENBSD_4_2:1.68.0.2
	OPENBSD_4_2_BASE:1.68
	OPENBSD_4_1:1.63.0.4
	OPENBSD_4_1_BASE:1.63
	OPENBSD_4_0:1.63.0.2
	OPENBSD_4_0_BASE:1.63
	OPENBSD_3_9:1.61.0.4
	OPENBSD_3_9_BASE:1.61
	OPENBSD_3_8:1.61.0.2
	OPENBSD_3_8_BASE:1.61
	OPENBSD_3_7:1.52.0.2
	OPENBSD_3_7_BASE:1.52
	OPENBSD_3_6:1.49.0.2
	OPENBSD_3_6_BASE:1.49
	OPENBSD_3_5:1.44.0.2
	OPENBSD_3_5_BASE:1.44
	OPENBSD_3_4:1.38.0.2
	OPENBSD_3_4_BASE:1.38
	OPENBSD_3_3:1.35.0.2
	OPENBSD_3_3_BASE:1.35
	OPENBSD_3_2:1.33.0.2
	OPENBSD_3_2_BASE:1.33
	OPENBSD_3_1:1.30.0.2
	OPENBSD_3_1_BASE:1.30
	OPENBSD_3_0:1.27.0.2
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_9:1.24.0.2
	OPENBSD_2_8:1.23.0.2
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.21.0.2
	OPENBSD_2_7_BASE:1.21
	OPENBSD_2_6:1.17.0.4
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.111
date	2016.12.22.11.04.44;	author rzalamena;	state Exp;
branches;
next	1.110;
commitid	T2qzeepA7r1EGy1x;

1.110
date	2016.07.20.19.57.54;	author bluhm;	state Exp;
branches;
next	1.109;
commitid	iB1JO3v9iwYOTdxI;

1.109
date	2016.01.01.17.38.45;	author mpi;	state Exp;
branches;
next	1.108;
commitid	B1Ac2hEflCqBPmZL;

1.108
date	2015.10.23.08.18.57;	author tedu;	state Exp;
branches;
next	1.107;
commitid	sikidoYSuyHCQTuI;

1.107
date	2015.10.23.08.03.48;	author tedu;	state Exp;
branches;
next	1.106;
commitid	cwN14QdJaRk6BKex;

1.106
date	2015.02.12.01.49.02;	author claudio;	state Exp;
branches;
next	1.105;
commitid	EszVZ4RtthRFw1UZ;

1.105
date	2015.02.09.12.25.03;	author claudio;	state Exp;
branches;
next	1.104;
commitid	83gy3puTH63xWYWh;

1.104
date	2015.02.06.03.22.00;	author reyk;	state Exp;
branches;
next	1.103;
commitid	2ShTul7wSa8iiu5L;

1.103
date	2015.01.16.06.40.10;	author deraadt;	state Exp;
branches;
next	1.102;
commitid	Uu5nFG3wCl0LACBb;

1.102
date	2014.10.23.16.45.57;	author schwarze;	state Exp;
branches;
next	1.101;
commitid	IvHOKuDOlqzgwkmv;

1.101
date	2014.06.23.03.46.17;	author guenther;	state Exp;
branches;
next	1.100;
commitid	uXnRK9VvnFZsAqfW;

1.100
date	2014.02.13.20.51.21;	author tedu;	state Exp;
branches;
next	1.99;

1.99
date	2014.01.10.04.54.35;	author guenther;	state Exp;
branches;
next	1.98;

1.98
date	2013.11.20.21.34.25;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2013.10.28.19.59.25;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2013.10.22.16.40.28;	author guenther;	state Exp;
branches;
next	1.95;

1.95
date	2013.03.20.15.23.37;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2012.08.22.06.08.07;	author tedu;	state Exp;
branches;
next	1.93;

1.93
date	2012.08.22.00.11.57;	author tedu;	state Exp;
branches;
next	1.92;

1.92
date	2011.11.01.17.30.04;	author mikeb;	state Exp;
branches;
next	1.91;

1.91
date	2011.11.01.10.14.06;	author mikeb;	state Exp;
branches;
next	1.90;

1.90
date	2011.11.01.00.00.01;	author mikeb;	state Exp;
branches;
next	1.89;

1.89
date	2011.07.09.00.45.40;	author henning;	state Exp;
branches;
next	1.88;

1.88
date	2011.03.15.13.10.31;	author jsing;	state Exp;
branches;
next	1.87;

1.87
date	2010.10.30.23.06.05;	author bluhm;	state Exp;
branches;
next	1.86;

1.86
date	2010.10.11.12.33.36;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2010.07.14.23.44.41;	author dhill;	state Exp;
branches;
next	1.84;

1.84
date	2010.06.30.03.32.55;	author lum;	state Exp;
branches;
next	1.83;

1.83
date	2010.06.29.03.09.29;	author blambert;	state Exp;
branches;
next	1.82;

1.82
date	2009.11.22.22.22.14;	author tedu;	state Exp;
branches;
next	1.81;

1.81
date	2009.11.05.20.50.14;	author michele;	state Exp;
branches;
next	1.80;

1.80
date	2009.10.04.16.08.37;	author michele;	state Exp;
branches;
next	1.79;

1.79
date	2009.05.07.15.51.53;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2009.02.21.20.07.49;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2009.01.27.13.49.21;	author claudio;	state Exp;
branches;
next	1.76;

1.76
date	2008.09.16.15.48.13;	author gollo;	state Exp;
branches;
next	1.75;

1.75
date	2008.05.08.07.18.47;	author claudio;	state Exp;
branches;
next	1.74;

1.74
date	2008.01.03.21.01.40;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2007.12.19.08.49.23;	author claudio;	state Exp;
branches;
next	1.72;

1.72
date	2007.12.19.01.47.00;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2007.12.14.18.35.46;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2007.12.11.20.14.45;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2007.10.20.18.08.57;	author sobrado;	state Exp;
branches;
next	1.68;

1.68
date	2007.07.25.11.50.47;	author claudio;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.28.14.27.02;	author claudio;	state Exp;
branches;
next	1.66;

1.66
date	2007.06.04.12.20.24;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2007.03.23.15.37.57;	author jmc;	state Exp;
branches;
next	1.64;

1.64
date	2007.03.23.10.59.38;	author pyr;	state Exp;
branches;
next	1.63;

1.63
date	2006.08.29.21.51.13;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.27.19.16.37;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2005.07.04.01.54.10;	author djm;	state Exp;
branches;
next	1.60;

1.60
date	2005.06.16.16.03.32;	author jaredy;	state Exp;
branches;
next	1.59;

1.59
date	2005.06.15.10.53.23;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2005.06.08.04.47.04;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2005.05.02.10.07.19;	author jmc;	state Exp;
branches;
next	1.56;

1.56
date	2005.04.12.14.11.49;	author reyk;	state Exp;
branches;
next	1.55;

1.55
date	2005.03.30.17.45.51;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.30.08.23.47;	author jaredy;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.25.17.01.04;	author jaredy;	state Exp;
branches;
next	1.52;

1.52
date	2005.02.10.14.25.08;	author itojun;	state Exp;
branches;
next	1.51;

1.51
date	2005.02.10.05.28.58;	author itojun;	state Exp;
branches;
next	1.50;

1.50
date	2005.01.14.15.00.44;	author mcbride;	state Exp;
branches;
next	1.49;

1.49
date	2004.06.29.08.18.20;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2004.06.25.20.05.40;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2004.06.06.22.08.59;	author jmc;	state Exp;
branches;
next	1.46;

1.46
date	2004.06.06.16.55.31;	author cedric;	state Exp;
branches;
next	1.45;

1.45
date	2004.04.01.07.55.17;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.13.22.02.13;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.15.07.11.31;	author mcbride;	state Exp;
branches;
next	1.42;

1.42
date	2003.11.28.23.10.49;	author jmc;	state Exp;
branches;
next	1.41;

1.41
date	2003.11.28.10.05.43;	author jmc;	state Exp;
branches;
next	1.40;

1.40
date	2003.11.02.10.23.58;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2003.10.17.21.04.59;	author mcbride;	state Exp;
branches;
next	1.38;

1.38
date	2003.06.26.21.59.11;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.12.07.39.16;	author jmc;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.03.02.56.13;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.01.14.09.16;	author dhartmei;	state Exp;
branches;
next	1.34;

1.34
date	2003.02.01.01.51.31;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2002.08.04.16.52.07;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.07.21.58.38;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2002.05.27.01.50.36;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.02.16.21.27.50;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.01.17.21.34.58;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.26.09.42.04;	author brian;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.05.08.47.44;	author jjbg;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.18.02.41.38;	author provos;	state Exp;
branches;
next	1.24;

1.24
date	2000.12.13.15.52.58;	author camield;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.30.23.32.14;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.30.20.04.01;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2000.01.21.03.24.06;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	2000.01.11.01.14.26;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	99.12.08.12.30.17;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	99.10.29.03.26.40;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	99.03.01.01.28.13;	author d;	state Exp;
branches;
next	1.16;

1.16
date	99.02.24.22.57.34;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	98.08.01.05.36.18;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	98.07.08.22.14.15;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.02.26.10.06.07;	author peter;	state Exp;
branches;
next	1.12;

1.12
date	97.07.23.04.38.33;	author denny;	state Exp;
branches;
next	1.11;

1.11
date	97.06.29.20.18.01;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.06.18.01.52.27;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	97.02.22.04.35.24;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	97.02.21.09.09.52;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	97.02.01.17.31.19;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.42.55;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.12.22.03.25.58;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.09.29.33;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.37.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.10.13.02.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.51;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.51;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.111
log
@Remove PIM support from the multicast stack.

ok mpi@@
@
text
@/*	$OpenBSD: main.c,v 1.110 2016/07/20 19:57:54 bluhm Exp $	*/
/*	$NetBSD: main.c,v 1.9 1996/05/07 02:55:02 thorpej Exp $	*/

/*
 * Copyright (c) 1983, 1988, 1993
 *	Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/sysctl.h>

#include <net/route.h>
#include <netinet/in.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <kvm.h>
#include <limits.h>
#include <netdb.h>
#include <nlist.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "netstat.h"

struct nlist nl[] = {
#define N_RTREE		0
	{ "_rt_tables"},
#define N_RTMASK	1
	{ "_mask_rnhead" },
#define N_AF2RTAFIDX	2
	{ "_af2rtafidx" },
#define N_RTBLIDMAX	3
	{ "_rtbl_id_max" },

	{ "" }
};

struct protox {
	void	(*pr_stats)(char *);	/* statistics printing routine */
	char	*pr_name;		/* well-known name */
	int	pr_proto;		/* protocol number */
} protox[] = {
	{ ip_stats,	"ip",	IPPROTO_IPV4 },
	{ icmp_stats,	"icmp", 0 },
	{ igmp_stats,	"igmp", 0 },
	{ ipip_stats,	"ipencap", 0 },
	{ tcp_stats,	"tcp",	IPPROTO_TCP },
	{ udp_stats,	"udp",	IPPROTO_UDP },
	{ esp_stats,	"esp", 0 },
	{ ah_stats,	"ah", 0 },
	{ etherip_stats,"etherip", 0 },
	{ ipcomp_stats,	"ipcomp", 0 },
	{ carp_stats,	"carp", 0 },
	{ pfsync_stats,	"pfsync", 0 },
	{ div_stats,	"divert", IPPROTO_DIVERT },
	{ pflow_stats,	"pflow", 0 },
	{ NULL,		NULL, 0 }
};

struct protox ip6protox[] = {
	{ ip6_stats,	"ip6", IPPROTO_IPV6 },
	{ div6_stats,	"divert6", IPPROTO_DIVERT },
	{ icmp6_stats,	"icmp6", 0 },
	{ rip6_stats,	"rip6", 0 },
	{ NULL,		NULL, 0 }
};

struct protox *protoprotox[] = {
	protox, ip6protox, NULL
};

static void usage(void);
static struct protox *name2protox(char *);
static struct protox *knownname(char *);
u_int gettable(const char *);

kvm_t *kvmd;

int
main(int argc, char *argv[])
{
	extern char *optarg;
	extern int optind;
	const char *errstr;
	struct protox *tp = NULL; /* for printing cblocks & stats */
	int ch;
	char *nlistf = NULL, *memf = NULL, *ep;
	char buf[_POSIX2_LINE_MAX];
	u_long pcbaddr = 0;
	u_int tableid;
	int Tflag = 0;
	int repeatcount = 0;
	int proto = 0;
	int need_nlist, kvm_flags = O_RDONLY;

	af = AF_UNSPEC;
	tableid = getrtable();

	while ((ch = getopt(argc, argv,
	    "AaBbc:dFf:ghI:ilM:mN:np:P:qrsT:tuvW:w:")) != -1)
		switch (ch) {
		case 'A':
			Aflag = 1;
			break;
		case 'a':
			aflag = 1;
			break;
		case 'B':
			Bflag = 1;
			break;
		case 'b':
			bflag = 1;
			break;
		case 'c':
			repeatcount = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "count is %s", errstr);
			break;
		case 'd':
			dflag = 1;
			break;
		case 'F':
			Fflag = 1;
			break;
		case 'f':
			if (strcmp(optarg, "inet") == 0)
				af = AF_INET;
			else if (strcmp(optarg, "inet6") == 0)
				af = AF_INET6;
			else if (strcmp(optarg, "local") == 0)
				af = AF_LOCAL;
			else if (strcmp(optarg, "unix") == 0)
				af = AF_UNIX;
			else if (strcmp(optarg, "mpls") == 0)
				af = AF_MPLS;
			else if (strcmp(optarg, "mask") == 0)
				af = 0xff;
			else {
				(void)fprintf(stderr,
				    "%s: %s: unknown address family\n",
				    __progname, optarg);
				exit(1);
			}
			break;
		case 'g':
			gflag = 1;
			break;
		case 'h':
			hflag = 1;
			break;
		case 'I':
			iflag = 1;
			interface = optarg;
			break;
		case 'i':
			iflag = 1;
			break;
		case 'l':
			lflag = 1;
			break;
		case 'M':
			memf = optarg;
			break;
		case 'm':
			mflag = 1;
			break;
		case 'N':
			nlistf = optarg;
			break;
		case 'n':
			nflag = 1;
			break;
		case 'p':
			if ((tp = name2protox(optarg)) == NULL) {
				(void)fprintf(stderr,
				    "%s: %s: unknown protocol\n",
				    __progname, optarg);
				exit(1);
			}
			pflag = 1;
			break;
		case 'P':
			errno = 0;
			pcbaddr = strtoul(optarg, &ep, 16);
			if (optarg[0] == '\0' || *ep != '\0' ||
			    errno == ERANGE) {
				(void)fprintf(stderr,
				    "%s: %s: invalid PCB address\n",
				    __progname, optarg);
				exit(1);
			}
			Pflag = 1;
			break;
		case 'q':
			qflag = 1;
			break;
		case 'r':
			rflag = 1;
			break;
		case 's':
			++sflag;
			break;
		case 'T':
			Tflag = 1;
			tableid = gettable(optarg);
			break;
		case 't':
			tflag = 1;
			break;
		case 'u':
			af = AF_UNIX;
			break;
		case 'v':
			vflag = 1;
			break;
		case 'W':
			Wflag = 1;
			interface = optarg;
			break;
		case 'w':
			interval = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "interval is %s", errstr);
			iflag = 1;
			break;
		case '?':
		default:
			usage();
		}
	argv += optind;
	argc -= optind;

	if (argc) {
		interval = strtonum(*argv, 1, INT_MAX, &errstr);
		if (errstr)
			errx(1, "interval is %s", errstr);
		++argv;
		--argc;
		iflag = 1;
	}
	if (argc)
		usage();

	/*
	 * Show per-interface statistics which don't need access to
	 * kernel memory (they're using IOCTLs)
	 */
	if (Wflag) {
		if (interface == NULL)
			usage();
		net80211_ifstats(interface);
		exit(0);
	}

	if (mflag) {
		mbpr();
		exit(0);
	}
	if (iflag) {
		intpr(interval, repeatcount);
		exit(0);
	}
	if (sflag) {
		if (rflag) {
			rt_stats();
		} else if (gflag) {
			if (af == AF_INET || af == AF_UNSPEC)
				mrt_stats();
			if (af == AF_INET6 || af == AF_UNSPEC)
				mrt6_stats();
		} else if (pflag && tp->pr_name) {
			(*tp->pr_stats)(tp->pr_name);
		} else {
			if (af == AF_INET || af == AF_UNSPEC)
				for (tp = protox; tp->pr_name; tp++)
					(*tp->pr_stats)(tp->pr_name);
			if (af == AF_INET6 || af == AF_UNSPEC)
				for (tp = ip6protox; tp->pr_name; tp++)
					(*tp->pr_stats)(tp->pr_name);
		}
		exit(0);
	}
	if (gflag) {
		if (af == AF_INET || af == AF_UNSPEC)
			mroutepr();
		if (af == AF_INET6 || af == AF_UNSPEC)
			mroute6pr();
		exit(0);
	}

	/*
	 * The remaining code may need kvm so lets try to open it.
	 * -r and -P are the only bits left that actually can use this.
	 */
	need_nlist = (nlistf != NULL) || (memf != NULL) || (Aflag && rflag);
	if (!need_nlist && !Pflag)
		kvm_flags |= KVM_NO_FILES;

	if ((kvmd = kvm_openfiles(nlistf, memf, NULL, kvm_flags, buf)) == NULL)
		errx(1, "kvm_openfiles: %s", buf);

	if (need_nlist && (kvm_nlist(kvmd, nl) < 0 || nl[0].n_type == 0)) {
		if (nlistf)
			errx(1, "%s: no namelist", nlistf);
		else
			errx(1, "no namelist");
	}

	if (rflag) {
		if (Aflag || nlistf != NULL || memf != NULL)
			routepr(nl[N_RTREE].n_value, nl[N_RTMASK].n_value,
			    nl[N_AF2RTAFIDX].n_value, nl[N_RTBLIDMAX].n_value,
			    tableid);
		else
			p_rttables(af, tableid);
		exit(0);
	}

	if (pflag) {
		if (tp->pr_proto == 0)
			errx(1, "no protocol handler for protocol %s",
			    tp->pr_name);
		else
			proto = tp->pr_proto;
	}

	protopr(kvmd, pcbaddr, tableid, proto);
	exit(0);
}

/*
 * Read kernel memory, return 0 on success.
 */
int
kread(u_long addr, void *buf, int size)
{

	if (kvm_read(kvmd, addr, buf, size) != size) {
		(void)fprintf(stderr, "%s: %s\n", __progname,
		    kvm_geterr(kvmd));
		return (-1);
	}
	return (0);
}

char *
plural(u_int64_t n)
{
	return (n != 1 ? "s" : "");
}

char *
plurales(u_int64_t n)
{
	return (n != 1 ? "es" : "");
}

char *
pluralys(u_int64_t n)
{
	return (n != 1 ? "ies" : "y");
}

/*
 * Find the protox for the given "well-known" name.
 */
static struct protox *
knownname(char *name)
{
	struct protox **tpp, *tp;

	for (tpp = protoprotox; *tpp; tpp++)
		for (tp = *tpp; tp->pr_name; tp++)
			if (strcmp(tp->pr_name, name) == 0)
				return (tp);
	return (NULL);
}

/*
 * Find the protox corresponding to name.
 */
static struct protox *
name2protox(char *name)
{
	struct protox *tp;
	char **alias;			/* alias from p->aliases */
	struct protoent *p;

	/*
	 * Try to find the name in the list of "well-known" names. If that
	 * fails, check if name is an alias for an Internet protocol.
	 */
	if ((tp = knownname(name)))
		return (tp);

	setprotoent(1);			/* make protocol lookup cheaper */
	while ((p = getprotoent())) {
		/* assert: name not same as p->name */
		for (alias = p->p_aliases; *alias; alias++)
			if (strcmp(name, *alias) == 0) {
				endprotoent();
				return (knownname(p->p_name));
			}
	}
	endprotoent();
	return (NULL);
}

static void
usage(void)
{
	(void)fprintf(stderr,
	    "usage: %s [-AaBn] [-f address_family] [-M core] [-N system]\n"
	    "       %s [-bdFgilmnqrstu] [-f address_family] [-M core] [-N system]\n"
	    "               [-T tableid]\n"
	    "       %s [-bdhn] [-c count] [-I interface] [-M core] [-N system] [-w wait]\n"
	    "       %s [-v] [-M core] [-N system] -P pcbaddr\n"
	    "       %s [-s] [-M core] [-N system] [-p protocol]\n"
	    "       %s [-a] [-f address_family] [-i | -I interface]\n"
	    "       %s [-W interface]\n",
	    __progname, __progname, __progname, __progname,
	    __progname, __progname, __progname);
	exit(1);
}

u_int
gettable(const char *s)
{
	const char *errstr;
	struct rt_tableinfo info;
	int mib[6];
	size_t len;
	u_int tableid;

	tableid = strtonum(s, 0, RT_TABLEID_MAX, &errstr);
	if (errstr)
		errx(1, "invalid table id: %s", errstr);

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = 0;
	mib[4] = NET_RT_TABLE;
	mib[5] = tableid;

	len = sizeof(info);
	if (sysctl(mib, 6, &info, &len, NULL, 0) == -1)
		err(1, "routing table %d", tableid);

	return (tableid);
}
@


1.110
log
@To tune the TCP SYN cache we need more information.  Print the
relevant counters with netstat -s -p tcp.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.109 2016/01/01 17:38:45 mpi Exp $	*/
a86 1
	{ pim_stats,	"pim", 0 },
a94 1
	{ pim6_stats,	"pim6", 0 },
@


1.109
log
@The "-P" option does not need to read routing table symbols so do not
check for them.

ok benno@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.108 2015/10/23 08:18:57 tedu Exp $	*/
d389 6
@


1.108
log
@further simplify argv
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.107 2015/10/23 08:03:48 tedu Exp $	*/
d127 1
a127 1
	int need_nlist;
d328 3
a330 1
	need_nlist = nlistf != NULL || memf != NULL || Pflag || (Aflag && rflag);
d332 1
a332 2
	if ((kvmd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY |
	    (need_nlist ? 0 : KVM_NO_FILES), buf)) == NULL)
@


1.107
log
@simplify backcompat. no more support for kernel or kmem on argv
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.106 2015/02/12 01:49:02 claudio Exp $	*/
d266 7
a272 9
	if (*argv) {
		if (isdigit((unsigned char)**argv)) {
			interval = strtonum(*argv, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "interval is %s", errstr);
			++argv;
			--argc;
			iflag = 1;
		}
@


1.106
log
@Switch the printing of open sockets from ugly KVM internals to use
kvm_getfiles. This allows to run netstat without any extra privileges
and removes another setgid program from base..
There is still kvm reader code in there which is used for debugging
purposes (crashdump). netstat should still behave mostly the same.
deraadt@@ and sthen@@ agree that it is time to get this puppy in.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.105 2015/02/09 12:25:03 claudio Exp $	*/
a265 2
#define	BACKWARD_COMPATIBILITY
#ifdef	BACKWARD_COMPATIBILITY
d272 1
a274 5
		if (*argv) {
			nlistf = *argv;
			if (*++argv)
				memf = *argv;
		}
d276 2
a277 1
#endif
@


1.105
log
@Get rid of another KVM reader and convert the multicast output to use
the new sysctls. Looks good deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.104 2015/02/06 03:22:00 reyk Exp $	*/
d57 1
a57 6
#define N_TCBTABLE	0
	{ "_tcbtable" },
#define N_UDBTABLE	1
	{ "_udbtable" },

#define N_RTREE		7
d59 1
a59 1
#define N_RTMASK	8
d61 1
a61 1
#define N_AF2RTAFIDX	9
d63 1
a63 1
#define N_RTBLIDMAX	10
a65 9
#define N_RAWIPTABLE	11
	{ "_rawcbtable" },
#define N_RAWIP6TABLE	12
	{ "_rawin6pcbtable" },
#define N_DIVBTABLE	13
	{ "_divbtable" },
#define N_DIVB6TABLE	14
	{ "_divb6table" },

a69 3
	u_char	pr_index;		/* index into nlist of cb head */
	void	(*pr_cblocks)(u_long, char *, int, u_int, u_long);
					/* control blocks printing routine */
d72 1
d74 16
a89 16
	{ N_TCBTABLE,	protopr,	tcp_stats,	"tcp" },
	{ N_UDBTABLE,	protopr,	udp_stats,	"udp" },
	{ N_RAWIPTABLE,	protopr,	ip_stats,	"ip" },
	{ N_DIVBTABLE,	protopr,	div_stats,	"divert" },
	{ -1,		NULL,		icmp_stats,	"icmp" },
	{ -1,		NULL,		igmp_stats,	"igmp" },
	{ -1,		NULL,		ah_stats,	"ah" },
	{ -1,		NULL,		esp_stats,	"esp" },
	{ -1,		NULL,		ipip_stats,	"ipencap" },
	{ -1,		NULL,		etherip_stats,	"etherip" },
	{ -1,		NULL,		ipcomp_stats,	"ipcomp" },
	{ -1,		NULL,		carp_stats,	"carp" },
	{ -1,		NULL,		pfsync_stats,	"pfsync" },
	{ -1,		NULL,		pim_stats,	"pim" },
	{ -1,		NULL,		pflow_stats,	"pflow" },
	{ -1,		NULL,		NULL,		NULL }
d93 6
a98 8
	{ N_TCBTABLE,	protopr,	NULL,		"tcp" },
	{ N_UDBTABLE,	protopr,	NULL,		"udp" },
	{ N_RAWIP6TABLE,protopr,	ip6_stats,	"ip6" },
	{ N_DIVB6TABLE,	protopr,	div6_stats,	"divert6" },
	{ -1,		NULL,		icmp6_stats,	"icmp6" },
	{ -1,		NULL,		pim6_stats,	"pim6" },
	{ -1,		NULL,		rip6_stats,	"rip6" },
	{ -1,		NULL,		NULL,		NULL }
a104 1
static void printproto(struct protox *, char *, int, u_int, u_long);
a109 2
int hideroot;

a117 1
	struct protoent *p;
a121 1
	gid_t gid;
d126 1
a128 2
	hideroot = getuid();

a168 2
			else if (strcmp(optarg, "pflow") == 0)
				af = PF_PFLOW;
a265 11
	/*
	 * Show per-interface statistics which don't need access to
	 * kernel memory (they're using IOCTLs)
	 */
	if (Wflag) {
		if (interface == NULL)
			usage();
		net80211_ifstats(interface);
		exit(0);
	}

a283 4
	need_nlist = !mflag && (pflag || nlistf != NULL || memf != NULL ||
	    (!iflag && !sflag && !gflag && (rflag ? Aflag :
	    (af != AF_UNIX || Pflag))));

d285 2
a286 3
	 * Discard setgid privileges if not the running kernel so that bad
	 * guys can't print interesting stuff from kernel memory.
	 * Dumping PCB info is also restricted.
d288 5
a292 9
	gid = getgid();
	if (nlistf != NULL || memf != NULL || Pflag)
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");

	if ((kvmd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY |
	    (need_nlist ? 0 : KVM_NO_FILES), buf)) == NULL) {
		fprintf(stderr, "%s: kvm_openfiles: %s\n", __progname, buf);
		exit(1);
a294 12
	if (nlistf == NULL && memf == NULL && !Pflag)
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");

	if (need_nlist && (kvm_nlist(kvmd, nl) < 0 || nl[0].n_type == 0)) {
		if (nlistf)
			fprintf(stderr, "%s: %s: no namelist\n", __progname,
			    nlistf);
		else
			fprintf(stderr, "%s: no namelist\n", __progname);
		exit(1);
	}
a298 4
	if (pflag) {
		printproto(tp, tp->pr_name, af, tableid, pcbaddr);
		exit(0);
	}
d303 2
a304 2
	if (rflag) {
		if (sflag)
d306 1
a306 10
		else if (Aflag || nlistf != NULL || memf != NULL)
			routepr(nl[N_RTREE].n_value, nl[N_RTMASK].n_value,
			    nl[N_AF2RTAFIDX].n_value, nl[N_RTBLIDMAX].n_value,
			    tableid);
		else
			p_rttables(af, tableid);
		exit(0);
	}
	if (gflag) {
		if (sflag) {
d311 2
d315 2
a316 1
				mroutepr();
d318 2
a319 1
				mroute6pr();
d323 23
a345 13
	if (af == AF_INET || af == AF_UNSPEC) {
		setprotoent(1);
		setservent(1);
		/* ugh, this is O(MN) ... why do we do this? */
		while ((p = getprotoent())) {
			for (tp = protox; tp->pr_name; tp++)
				if (strcmp(tp->pr_name, p->p_name) == 0)
					break;
			if (tp->pr_name == 0)
				continue;
			printproto(tp, p->p_name, AF_INET, tableid, pcbaddr);
		}
		endprotoent();
d347 9
a355 3
	if (af == PF_PFLOW || af == AF_UNSPEC) {
		tp = name2protox("pflow");
		printproto(tp, tp->pr_name, af, tableid, pcbaddr);
a356 8
	if (af == AF_INET6 || af == AF_UNSPEC)
		for (tp = ip6protox; tp->pr_name; tp++)
			printproto(tp, tp->pr_name, AF_INET6, tableid,
			    pcbaddr);
	if ((af == AF_UNIX || af == AF_UNSPEC) && !sflag)
		unixpr(kvmd, pcbaddr);
	exit(0);
}
d358 6
a363 19
/*
 * Print out protocol statistics or control blocks (per sflag).
 * If the interface was not specifically requested, and the symbol
 * is not in the namelist, ignore this one.
 */
static void
printproto(struct protox *tp, char *name, int af, u_int tableid,
    u_long pcbaddr)
{
	if (sflag) {
		if (tp->pr_stats != NULL)
			(*tp->pr_stats)(name);
	} else {
		u_char i = tp->pr_index;
		if (tp->pr_cblocks != NULL &&
		    i < sizeof(nl) / sizeof(nl[0]) &&
		    (nl[i].n_value || af != AF_UNSPEC))
			(*tp->pr_cblocks)(nl[i].n_value, name, af, tableid,
			    pcbaddr);
d365 3
@


1.104
log
@Remove route/netstat -f encap in favor of ipsecctl -s flow.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.103 2015/01/16 06:40:10 deraadt Exp $	*/
a61 12
#define N_MFCHASHTBL	2
	{ "_mfchashtbl" },
#define N_MFCHASH	3
	{ "_mfchash" },
#define N_VIFTABLE	4
	{ "_viftable" },

#define N_MF6CTABLE	5
	{ "_mf6ctable" },
#define N_MIF6TABLE	6
	{ "_mif6table" },

d322 2
a323 2
	    (!iflag && !sflag && (rflag ? Aflag :
	    (gflag || af != AF_UNIX || Pflag))));
d384 1
a384 3
				mroutepr(nl[N_MFCHASHTBL].n_value,
				    nl[N_MFCHASH].n_value,
				    nl[N_VIFTABLE].n_value);
d386 1
a386 2
				mroute6pr(nl[N_MF6CTABLE].n_value,
				    nl[N_MIF6TABLE].n_value);
@


1.103
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.102 2014/10/23 16:45:57 schwarze Exp $	*/
a202 2
			else if (strcmp(optarg, "encap") == 0)
				af = PF_KEY;
@


1.102
log
@Remove networks(5) support.
In particular, do not call getnetbyaddr(3), use gethostbyaddr(3) only.
Do not call setnetent(3) and the dummy sethostent(3).
OK henning@@; and deraadt@@ agrees with the general direction.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.101 2014/06/23 03:46:17 guenther Exp $	*/
d33 1
a33 1
#include <sys/param.h>
@


1.101
log
@The second level of the CTL_NET sysctl is a PF_*, not an AF_*

inconsistent usage in route(8) noted by Gregor Best (gbe (at) ring0.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.100 2014/02/13 20:51:21 tedu Exp $	*/
a374 7
	/*
	 * Keep file descriptors open to avoid overhead
	 * of open/close on each call to get* routines.
	 */
	sethostent(1);
	setnetent(1);

@


1.100
log
@use strtonum. ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.99 2014/01/10 04:54:35 guenther Exp $	*/
d566 1
a566 1
	mib[1] = AF_ROUTE;
@


1.99
log
@ddpcb and unixsw symbols are no longer used with kvm_read

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.98 2013/11/20 21:34:25 deraadt Exp $	*/
d185 2
d294 3
a296 1
			interval = atoi(optarg);
d321 3
a323 3
			interval = atoi(*argv);
			if (interval <= 0)
				usage();
@


1.98
log
@unsigned char cast for isdigit, dealing with argv
ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.97 2013/10/28 19:59:25 deraadt Exp $	*/
a60 4
#define N_DDPCB		2
	{ "_ddpcb"},
#define N_UNIXSW	3
	{ "_unixsw" },
d62 1
a62 1
#define N_MFCHASHTBL	4
d64 1
a64 1
#define N_MFCHASH	5
d66 1
a66 1
#define N_VIFTABLE	6
d69 1
a69 1
#define N_MF6CTABLE	7
d71 1
a71 1
#define N_MIF6TABLE	8
d74 1
a74 1
#define N_RTREE		9
d76 1
a76 1
#define N_RTMASK	10
d78 1
a78 1
#define N_AF2RTAFIDX	11
d80 1
a80 1
#define N_RTBLIDMAX	12
d83 1
a83 1
#define N_RAWIPTABLE	13
d85 1
a85 1
#define N_RAWIP6TABLE	14
d87 1
a87 1
#define N_DIVBTABLE	15
d89 1
a89 1
#define N_DIVB6TABLE	16
@


1.97
log
@use %d instea of %i
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.96 2013/10/22 16:40:28 guenther Exp $	*/
d320 1
a320 1
		if (isdigit(**argv)) {
@


1.96
log
@- add UNIX-domain socket info to struct kinfo_file2
- convert netstat from kvm_getfiles() to kvm_getfile2() using that
- delete kvm_getfiles() and KERN_FILE as no longer used (bump libkvm's major)
- rename kvm_getfile2() to kvm_getfiles(), kinfo_file2 to kinfo_file
  and KERN_FILE2 to KERN_FILE.

ok deraadt@@, millert@@
ports scan sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.95 2013/03/20 15:23:37 deraadt Exp $	*/
d574 1
a574 1
		err(1, "routing table %i", tableid);
@


1.95
log
@As non-root, whenever netstat is about to print out a kernel pointer...
print 0x0 instead.  Hides a lot stuff people don't need to see.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.94 2012/08/22 06:08:07 tedu Exp $	*/
a33 1
#include <sys/file.h>
d44 1
d165 1
d335 4
d349 2
a350 2
	if ((kvmd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY,
	    buf)) == NULL) {
d359 1
a359 1
	if (kvm_nlist(kvmd, nl) < 0 || nl[0].n_type == 0) {
d437 1
a437 1
		unixpr(nl[N_UNIXSW].n_value, pcbaddr);
@


1.94
log
@i missed usage and the manpage.  prod by jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.93 2012/08/22 00:11:57 tedu Exp $	*/
d145 1
d165 2
@


1.93
log
@-h flag to print human numbers in conjunction with -w -b
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.92 2011/11/01 17:30:04 mikeb Exp $	*/
d534 1
a534 1
	    "       %s [-bdn] [-c count] [-I interface] [-M core] [-N system] [-w wait]\n"
@


1.92
log
@Do some cleanup and improve the manpage. From Andreas Bartelt; ok henning, jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.91 2011/11/01 10:14:06 mikeb Exp $	*/
d169 1
a169 1
	    "AaBbc:dFf:gI:ilM:mN:np:P:qrsT:tuvW:w:")) != -1)
d218 3
@


1.91
log
@Fixup previous: don't forget to actually get the current rtable;
reminded by Andreas Bartelt.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.90 2011/11/01 00:00:01 mikeb Exp $	*/
d383 1
a383 1
			p_rttables(af, tableid, Tflag);
@


1.90
log
@List sockets existing only in the specified or current routing domain.
Prompted by the mail from Andreas Bartelt, tested by Andreas and me.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.89 2011/07/09 00:45:40 henning Exp $	*/
d161 1
a161 1
	u_int tableid = 0;
d166 1
@


1.89
log
@rmove rotten netatalk bits
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.88 2011/03/15 13:10:31 jsing Exp $	*/
d101 1
a101 1
	void	(*pr_cblocks)(u_long, char *, int, u_long);
d139 1
a139 1
static void printproto(struct protox *, char *, int, u_long);
d360 1
a360 1
		printproto(tp, tp->pr_name, af, pcbaddr);
d412 1
a412 1
			printproto(tp, p->p_name, AF_INET, pcbaddr);
d418 1
a418 1
		printproto(tp, tp->pr_name, af, pcbaddr);
d422 2
a423 1
			printproto(tp, tp->pr_name, AF_INET6, pcbaddr);
d435 2
a436 1
printproto(struct protox *tp, char *name, int af, u_long pcbaddr)
d446 2
a447 1
			(*tp->pr_cblocks)(nl[i].n_value, name, af, pcbaddr);
@


1.88
log
@Add a -B flag to netstat which displays buffer sizes for TCP sockets.

With feedback from bluhm@@

ok bluhm@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.86 2010/10/11 12:33:36 claudio Exp $	*/
a134 5
struct protox atalkprotox[] = {
	{ N_DDPCB,	atalkprotopr,	ddp_stats,	"ddp" },
	{ -1,		NULL,		NULL,		NULL }
};

d136 1
a136 1
	protox, ip6protox, atalkprotox, NULL
a201 2
			else if (strcmp(optarg, "atalk") == 0)
				af = AF_APPLETALK;
a424 3
	if (af == AF_APPLETALK || af == AF_UNSPEC)
		for (tp = atalkprotox; tp->pr_name; tp++)
			printproto(tp, tp->pr_name, af, pcbaddr);
@


1.87
log
@Print socket structure internals when netstat -P pcbaddr is called
with -v.  Also netstat -P supports more than TCP now.
ok markus@@ jmc@@
@
text
@d172 2
a173 1
	while ((ch = getopt(argc, argv, "Aabc:dFf:gI:ilM:mN:np:P:qrsT:tuvW:w:")) != -1)
d181 3
d534 1
a534 1
	    "usage: %s [-Aan] [-f address_family] [-M core] [-N system]\n"
@


1.86
log
@Do similar changes to netstat as done to route(8). Try to show the
most expected rtable when doing a netstat -rn.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.85 2010/07/14 23:44:41 dhill Exp $	*/
d96 1
a96 1
	{ ""}
d100 5
a104 5
	u_char	pr_index;			/* index into nlist of cb head */
	void	(*pr_cblocks)(u_long, char *, int); /* control blocks printing routine */
	void	(*pr_stats)(char *);		/* statistics printing routine */
	void	(*pr_dump)(u_long);		/* pcb printing routine */
	char	*pr_name;			/* well-known name */
d106 16
a121 16
	{ N_TCBTABLE,	protopr,	tcp_stats,	tcp_dump,	"tcp" },
	{ N_UDBTABLE,	protopr,	udp_stats,	NULL,		"udp" },
	{ N_RAWIPTABLE,	protopr,	ip_stats,	NULL,		"ip" },
	{ N_DIVBTABLE,	protopr,	div_stats,	NULL,		"divert" },
	{ -1,		NULL,		icmp_stats,	NULL,		"icmp" },
	{ -1,		NULL,		igmp_stats,	NULL,		"igmp" },
	{ -1,		NULL,		ah_stats,	NULL,		"ah" },
	{ -1,		NULL,		esp_stats,	NULL,		"esp" },
	{ -1,		NULL,		ipip_stats,	NULL,		"ipencap" },
	{ -1,		NULL,		etherip_stats,	NULL,		"etherip" },
	{ -1,		NULL,		ipcomp_stats,	NULL,		"ipcomp" },
	{ -1,		NULL,		carp_stats,	NULL,		"carp" },
	{ -1,		NULL,		pfsync_stats,	NULL,		"pfsync" },
	{ -1,		NULL,		pim_stats,	NULL,		"pim" },
	{ -1,		NULL,		pflow_stats,	NULL,		"pflow" },
	{ -1,		NULL,		NULL,		NULL,		NULL }
d125 8
a132 8
	{ N_TCBTABLE,	protopr,	NULL,		tcp_dump,	"tcp" },
	{ N_UDBTABLE,	protopr,	NULL,		NULL,		"udp" },
	{ N_RAWIP6TABLE,protopr,	ip6_stats,	NULL,		"ip6" },
	{ N_DIVB6TABLE,	protopr,	div6_stats,	NULL,		"divert6" },
	{ -1,		NULL,		icmp6_stats,	NULL,		"icmp6" },
	{ -1,		NULL,		pim6_stats,	NULL,		"pim6" },
	{ -1,		NULL,		rip6_stats,	NULL,		"rip6" },
	{ -1,		NULL,		NULL,		NULL,		NULL }
d136 2
a137 2
	{ N_DDPCB,	atalkprotopr,	ddp_stats,	NULL,		"ddp" },
	{ -1,		NULL,		NULL,		NULL,		NULL }
d144 1
a144 1
static void printproto(struct protox *, char *, int);
d363 1
a363 12
		printproto(tp, tp->pr_name, af);
		exit(0);
	}
	if (Pflag) {
		if (tp == NULL && (tp = name2protox("tcp")) == NULL) {
			(void)fprintf(stderr,
			    "%s: %s: unknown protocol\n",
			    __progname, "tcp");
			exit(1);
		}
		if (tp->pr_dump)
			(tp->pr_dump)(pcbaddr);
d415 1
a415 1
			printproto(tp, p->p_name, AF_INET);
d421 1
a421 1
		printproto(tp, tp->pr_name, af);
d425 1
a425 1
			printproto(tp, tp->pr_name, AF_INET6);
d427 1
a427 1
		unixpr(nl[N_UNIXSW].n_value);
d430 1
a430 1
			printproto(tp, tp->pr_name, af);
d440 1
a440 1
printproto(struct protox *tp, char *name, int af)
d450 1
a450 1
			(*tp->pr_cblocks)(nl[i].n_value, name, af);
d534 1
a534 1
	    "       %s [-M core] [-N system] -P pcbaddr\n"
a568 1

@


1.85
log
@pass the correct af if not specified.

fixes printing active connections twice.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.84 2010/06/30 03:32:55 lum Exp $	*/
d37 1
d148 2
d167 1
d274 2
a275 3
			tableid = strtonum(optarg, 0, RT_TABLEID_MAX, &errstr);
			if (errstr)
				errx(1, "invalid table id: %s", errstr);
d396 1
a396 1
			p_rttables(af, tableid);
d553 28
@


1.84
log
@Make deprecated command line argument for extracting
name list work properly.
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.83 2010/06/29 03:09:29 blambert Exp $	*/
d423 1
a423 1
			printproto(tp, p->p_name, af);
d433 1
a433 1
			printproto(tp, tp->pr_name, af);
@


1.83
log
@Allow selecting both address family and protocol by passing the address family
directly to the appropriate print functions.

Found by jdixon@@, tested jdixon@@ and weerd@@, ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.82 2009/11/22 22:22:14 tedu Exp $	*/
d309 18
a345 18

#define	BACKWARD_COMPATIBILITY
#ifdef	BACKWARD_COMPATIBILITY
	if (*argv) {
		if (isdigit(**argv)) {
			interval = atoi(*argv);
			if (interval <= 0)
				usage();
			++argv;
			iflag = 1;
		}
		if (*argv) {
			nlistf = *argv;
			if (*++argv)
				memf = *argv;
		}
	}
#endif
@


1.82
log
@don't repeat the banner if not a tty.
add a -c count option to netstat.
tweak spacing to not smear fields in vmstat.
ok deraadt sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.81 2009/11/05 20:50:14 michele Exp $	*/
d100 1
a100 1
	void	(*pr_cblocks)(u_long, char *);	/* control blocks printing routine */
d124 4
a127 4
	{ N_TCBTABLE,	ip6protopr,	NULL,		tcp_dump,	"tcp" },
	{ N_UDBTABLE,	ip6protopr,	NULL,		NULL,		"udp" },
	{ N_RAWIP6TABLE,ip6protopr,	ip6_stats,	NULL,		"ip6" },
	{ N_DIVB6TABLE,	ip6protopr,	div6_stats,	NULL,		"divert6" },
d143 1
a143 1
static void printproto(struct protox *, char *);
d360 1
a360 1
		printproto(tp, tp->pr_name);
d423 1
a423 1
			printproto(tp, p->p_name);
d429 1
a429 1
		printproto(tp, tp->pr_name);
d433 1
a433 1
			printproto(tp, tp->pr_name);
d438 1
a438 1
			printproto(tp, tp->pr_name);
d448 1
a448 1
printproto(struct protox *tp, char *name)
d458 1
a458 1
			(*tp->pr_cblocks)(nl[i].n_value, name);
@


1.81
log
@IPv6 support for divert sockets.

tested by phessler@@ pyr@@
ok claudio@@
"go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.80 2009/10/04 16:08:37 michele Exp $	*/
d164 1
d168 1
a168 1
	while ((ch = getopt(argc, argv, "AabdFf:gI:ilM:mN:np:P:qrsT:tuvW:w:")) != -1)
d179 3
d382 1
a382 1
		intpr(interval);
d541 1
a541 1
	    "       %s [-bdn] [-I interface] [-M core] [-N system] [-w wait]\n"
@


1.80
log
@Add (again) support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 1

A lot of discussion have happened since my last commit that resulted
in many changes and improvements.
I would *really* like to thank everyone who took part in the discussion
especially canacar@@ who spotted out which are the limitations of this approach.

OpenBSD divert(4) is meant to be compatible with software running on
top of FreeBSD's divert sockets even though they are pretty different and will
become even more with time.

discusses with many, but mainly reyk@@ canacar@@ deraadt@@ dlg@@ claudio@@ beck@@
tested by reyk@@ and myself
ok reyk@@ claudio@@ beck@@
manpage help and ok by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.79 2009/05/07 15:51:53 claudio Exp $	*/
d92 2
d127 1
@


1.79
log
@Make the kvm routing table code grok multiple routing tables and do not
default to table 0 by default. Makes debugging alternate tables possible.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.78 2009/02/21 20:07:49 deraadt Exp $	*/
d90 2
d106 1
@


1.78
log
@we use kvm_openfiles() not kvm_open(); Amarendra Godbole
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.77 2009/01/27 13:49:21 claudio Exp $	*/
d380 2
a381 1
			    nl[N_AF2RTAFIDX].n_value, nl[N_RTBLIDMAX].n_value);
@


1.77
log
@Fix some interger overflows when accounting the used mbuf memory percentage
and while there use a better type for the plural{,es}() functions.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.76 2008/09/16 15:48:13 gollo Exp $	*/
d311 1
a311 1
		fprintf(stderr, "%s: kvm_open: %s\n", __progname, buf);
@


1.76
log
@netstat statistics for pflow(4) via pseudo family

ok cluadio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.75 2008/05/08 07:18:47 claudio Exp $	*/
d467 1
a467 1
plural(int n)
d473 1
a473 1
plurales(int n)
@


1.75
log
@make -f mpls work. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.74 2008/01/03 21:01:40 claudio Exp $	*/
d114 1
d193 2
d415 4
@


1.74
log
@Make if.c kvm free by fetching the interface stats via sysctl like in systat
and ospfd. What is not yet covered is the -d and -t flags to show interface
queue drops and the if_timer.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.73 2007/12/19 08:49:23 claudio Exp $	*/
d190 2
@


1.73
log
@Remove the kvm code in rt_stats() and use the sysctl code all the time.
While there remove the ugly rflag checks and make it more consistent with
the rest of the code. Another step in making netstat setgid free.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.72 2007/12/19 01:47:00 deraadt Exp $	*/
d62 1
a62 3
#define N_IFNET		3
	{ "_ifnet" },
#define N_UNIXSW	4
d65 1
a65 1
#define N_MFCHASHTBL	5
d67 1
a67 1
#define N_MFCHASH	6
d69 1
a69 1
#define N_VIFTABLE	7
d72 1
a72 1
#define N_MF6CTABLE	8
d74 1
a74 1
#define N_MIF6TABLE	9
d77 1
a77 1
#define N_RTREE		10
d79 1
a79 1
#define N_RTMASK	11
d81 1
a81 1
#define N_AF2RTAFIDX	12
d83 1
a83 1
#define N_RTBLIDMAX	13
d86 1
a86 1
#define N_RAWIPTABLE	14
d88 1
a88 1
#define N_RAWIP6TABLE	15
d367 1
a367 1
		intpr(interval, nl[N_IFNET].n_value);
@


1.72
log
@delete rcsid crud
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.71 2007/12/14 18:35:46 deraadt Exp $	*/
a92 3
#define N_RTSTAT	16
	{ "_rtstat" },

d305 1
a305 10
	if (nlistf == NULL && memf == NULL && rflag && !Aflag) {
		/* printing the routing table no longer needs kvm */
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");
		if (sflag)
			rt_stats(1, 0);
		else
			p_rttables(af, tableid);
		exit(0);
	}
d374 2
a375 2
			rt_stats(0, nl[N_RTSTAT].n_value);
		else
d378 2
@


1.71
log
@remove 21 nlist variables, and instead use sysctl to query the kernel
turn on INET6 the default (remove the #ifdef's)
ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.70 2007/12/11 20:14:45 deraadt Exp $	*/
a31 14

#ifndef lint
char copyright[] =
"@@(#) Copyright (c) 1983, 1988, 1993\n\
	Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "from: @@(#)main.c	8.4 (Berkeley) 3/1/94";
#else
static char *rcsid = "$OpenBSD: main.c,v 1.70 2007/12/11 20:14:45 deraadt Exp $";
#endif
#endif /* not lint */
@


1.70
log
@mbuf stats are always gotten via sysctl(), so remove old nlist stuff
ok claudio pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.69 2007/10/20 18:08:57 sobrado Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.69 2007/10/20 18:08:57 sobrado Exp $";
d70 1
a70 3
#define N_IPSTAT	0
	{ "_ipstat" },
#define N_TCBTABLE	1
d72 1
a72 3
#define N_TCPSTAT	2
	{ "_tcpstat" },
#define N_UDBTABLE	3
d74 3
a76 3
#define N_UDPSTAT	4
	{ "_udpstat" },
#define N_IFNET		5
d78 1
a78 5
#define N_ICMPSTAT	6
	{ "_icmpstat" },
#define N_RTSTAT	7
	{ "_rtstat" },
#define N_UNIXSW	8
d80 2
a81 11
#define N_RTREE		9
	{ "_rt_tables"},
#define N_FILE		10
	{ "_file" },
#define N_IGMPSTAT	11
	{ "_igmpstat" },
#define N_MRTPROTO	12
	{ "_ip_mrtproto" },
#define N_MRTSTAT	13
	{ "_mrtstat" },
#define N_MFCHASHTBL	14
d83 1
a83 1
#define N_MFCHASH	15
d85 1
a85 1
#define N_VIFTABLE	16
d87 2
a88 23
#define N_AHSTAT	17
	{ "_ahstat"},
#define N_ESPSTAT	18
	{ "_espstat"},
#define N_IP4STAT	19
	{ "_ipipstat"},
#define N_DDPSTAT	20
	{ "_ddpstat"},
#define N_DDPCB		21
	{ "_ddpcb"},
#define N_ETHERIPSTAT	22
	{ "_etheripstat"},
#define N_IP6STAT	23
	{ "_ip6stat" },
#define N_ICMP6STAT	24
	{ "_icmp6stat" },
#define N_PIM6STAT	25
	{ "_pim6stat" },
#define N_MRT6PROTO	26
	{ "_ip6_mrtproto" },
#define N_MRT6STAT	27
	{ "_mrt6stat" },
#define N_MF6CTABLE	28
d90 1
a90 1
#define N_MIF6TABLE	29
d92 11
a102 7
#define N_IPCOMPSTAT	30
	{ "_ipcompstat" },
#define N_RIP6STAT	31
	{ "_rip6stat" },
#define N_CARPSTAT	32
	{ "_carpstats" },
#define N_RAWIPTABLE	33
d104 1
a104 1
#define N_RAWIP6TABLE	34
d106 4
a109 10
#define N_PFSYNCSTAT	35
	{ "_pfsyncstats" },
#define N_PIMSTAT	36
	{ "_pimstat" },
#define N_AF2RTAFIDX	37
	{ "_af2rtafidx" },
#define N_RTBLIDMAX	38
	{ "_rtbl_id_max" },
#define N_RTMASK	39
	{ "_mask_rnhead" },
a114 2
	u_char	pr_sindex;			/* index into nlist of stat block */
	u_char	pr_wanted;			/* 1 if wanted, 0 otherwise */
d116 1
a116 1
	void	(*pr_stats)(u_long, char *);	/* statistics printing routine */
d120 14
a133 28
	{ N_TCBTABLE,	N_TCPSTAT,	1,	protopr,
	  tcp_stats,	tcp_dump,	"tcp" },
	{ N_UDBTABLE,	N_UDPSTAT,	1,	protopr,
	  udp_stats,	0,		"udp" },
	{ N_RAWIPTABLE,	N_IPSTAT,	1,	protopr,
	  ip_stats,	0,		"ip" },
	{ -1,		N_ICMPSTAT,	1,	0,
	  icmp_stats,	0,		"icmp" },
	{ -1,		N_IGMPSTAT,	1,	0,
	  igmp_stats,	0,		"igmp" },
	{ -1,		N_AHSTAT,	1,	0,
	  ah_stats,	0,		"ah" },
	{ -1,		N_ESPSTAT,	1,	0,
	  esp_stats,	0,		"esp" },
	{ -1,		N_IP4STAT,	1,	0,
	  ipip_stats,	0,		"ipencap" },
	{ -1,		N_ETHERIPSTAT,	1,	0,
	  etherip_stats,0,		"etherip" },
	{ -1,		N_IPCOMPSTAT,	1,	0,
	  ipcomp_stats,	0,		"ipcomp" },
	{ -1,		N_CARPSTAT,	1,	0,
	  carp_stats,	0,		"carp" },
	{ -1,		N_PFSYNCSTAT,	1,	0,
	  pfsync_stats,	0,		"pfsync" },
	{ -1,		N_PIMSTAT,	1,	0,
	  pim_stats,	0,		"pim" },
	{ -1,		-1,		0,	0,
	  0,		0,		0 }
a135 1
#ifdef INET6
d137 7
a143 14
	{ N_TCBTABLE,	N_TCPSTAT,	1,	ip6protopr,
	  0,		tcp_dump,	"tcp" },
	{ N_UDBTABLE,	N_UDPSTAT,	1,	ip6protopr,
	  0,		0,		"udp" },
	{ N_RAWIP6TABLE,N_IP6STAT,	1,	ip6protopr,
	  ip6_stats,	0,		"ip6" },
	{ -1,		N_ICMP6STAT,	1,	0,
	  icmp6_stats,	0,		"icmp6" },
	{ -1,		N_PIM6STAT,	1,	0,
	  pim6_stats,	0,		"pim6" },
	{ -1,		N_RIP6STAT,	1,	0,
	  rip6_stats,	0,		"rip6" },
	{ -1,		-1,		0,	0,
	  0,		0,		0 }
a144 1
#endif
d147 2
a148 4
	{ N_DDPCB,	N_DDPSTAT,	1,	atalkprotopr,
	  ddp_stats,	0,		"ddp" },
	{ -1,		-1,		0,	0,
	  0,		0,		0 }
a150 5
#ifndef INET6
struct protox *protoprotox[] = {
	protox, atalkprotox, NULL
};
#else
a153 1
#endif
d393 1
a393 1
	
d409 1
a409 3
				mrt_stats(nl[N_MRTPROTO].n_value,
				    nl[N_MRTSTAT].n_value);
#ifdef INET6
d411 1
a411 3
				mrt6_stats(nl[N_MRT6PROTO].n_value,
				    nl[N_MRT6STAT].n_value);
#endif
d414 1
a414 2
				mroutepr(nl[N_MRTPROTO].n_value,
				    nl[N_MFCHASHTBL].n_value,
a416 1
#ifdef INET6
d418 1
a418 2
				mroute6pr(nl[N_MRT6PROTO].n_value,
				    nl[N_MF6CTABLE].n_value,
a419 1
#endif
d431 1
a431 1
			if (tp->pr_name == 0 || tp->pr_wanted == 0)
a436 1
#ifdef INET6
a439 1
#endif
a455 3
	void (*pr)(u_long, char *);
	u_char i;

d457 2
a458 2
		pr = tp->pr_stats;
		i = tp->pr_sindex;
d460 5
a464 2
		pr = tp->pr_cblocks;
		i = tp->pr_index;
a465 3
	if (pr != NULL && i < sizeof(nl) / sizeof(nl[0]) &&
	    (nl[i].n_value || af != AF_UNSPEC))
		(*pr)(nl[i].n_value, name);
@


1.69
log
@an usage message should fit on a 80-column display

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.68 2007/07/25 11:50:47 claudio Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.68 2007/07/25 11:50:47 claudio Exp $";
d70 1
a70 3
#define N_MBSTAT	0
	{ "_mbstat" },
#define N_IPSTAT	1
d72 1
a72 1
#define N_TCBTABLE	2
d74 1
a74 1
#define N_TCPSTAT	3
d76 1
a76 1
#define N_UDBTABLE	4
d78 1
a78 1
#define N_UDPSTAT	5
d80 1
a80 1
#define N_IFNET		6
d82 1
a82 1
#define N_ICMPSTAT	7
d84 1
a84 1
#define N_RTSTAT	8
d86 1
a86 1
#define N_UNIXSW	9
d88 1
a88 1
#define N_RTREE		10
d90 1
a90 1
#define N_FILE		11
d92 1
a92 1
#define N_IGMPSTAT	12
d94 1
a94 1
#define N_MRTPROTO	13
d96 1
a96 1
#define N_MRTSTAT	14
d98 1
a98 1
#define N_MFCHASHTBL	15
d100 1
a100 1
#define N_MFCHASH	16
d102 1
a102 1
#define N_VIFTABLE	17
d104 1
a104 1
#define N_AHSTAT	18
d106 1
a106 1
#define N_ESPSTAT	19
d108 1
a108 1
#define N_IP4STAT	20
d110 1
a110 1
#define N_DDPSTAT	21
d112 1
a112 1
#define N_DDPCB		22
d114 1
a114 1
#define N_ETHERIPSTAT	23
d116 1
a116 1
#define N_IP6STAT	24
d118 1
a118 1
#define N_ICMP6STAT	25
d120 1
a120 1
#define N_PIM6STAT	26
d122 1
a122 1
#define N_MRT6PROTO	27
d124 1
a124 1
#define N_MRT6STAT	28
d126 1
a126 1
#define N_MF6CTABLE	29
d128 1
a128 1
#define N_MIF6TABLE	30
d130 1
a130 5
#define N_MBPOOL	31
	{ "_mbpool" },
#define N_MCLPOOL	32
	{ "_mclpool" },
#define N_IPCOMPSTAT	33
d132 1
a132 1
#define N_RIP6STAT	34
d134 1
a134 1
#define N_CARPSTAT	35
d136 1
a136 1
#define N_RAWIPTABLE	36
d138 1
a138 1
#define N_RAWIP6TABLE	37
d140 1
a140 1
#define N_PFSYNCSTAT	38
d142 1
a142 1
#define N_PIMSTAT	39
d144 1
a144 1
#define N_AF2RTAFIDX	40
d146 1
a146 1
#define N_RTBLIDMAX	41
d148 1
a148 1
#define N_RTMASK	42
d442 1
a442 2
		mbpr(nl[N_MBSTAT].n_value, nl[N_MBPOOL].n_value,
		    nl[N_MCLPOOL].n_value);
d489 1
a489 2
		}
		else {
@


1.68
log
@Make it possible to show alternate routing tables in netstat. This mostly
comes from route(8) which already had the -T option.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.67 2007/06/28 14:27:02 claudio Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.67 2007/06/28 14:27:02 claudio Exp $";
d639 2
a640 1
	    "       %s [-bdFgilmnqrstu] [-f address_family] [-M core] [-N system] [-T tableid]\n"
@


1.67
log
@Bring the index defines back in sync with struct nlist after removal of IPX
symbols from the table. This fixes the netstat issues some people reported.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.66 2007/06/04 12:20:24 henning Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.66 2007/06/04 12:20:24 henning Exp $";
d52 1
d246 1
d254 1
d258 1
a258 1
	while ((ch = getopt(argc, argv, "AabdFf:gI:ilM:mN:np:P:qrstuvW:w:")) != -1)
d352 5
d408 1
a408 1
			p_rttables(af);
d639 1
a639 1
	    "       %s [-bdFgilmnqrstu] [-f address_family] [-M core] [-N system]\n"
@


1.66
log
@remove IPX support, agreed by many
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.65 2007/03/23 15:37:57 jmc Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.65 2007/03/23 15:37:57 jmc Exp $";
d105 1
a105 1
#define N_AHSTAT	21
d107 1
a107 1
#define N_ESPSTAT	22
d109 1
a109 1
#define N_IP4STAT	23
d111 1
a111 1
#define N_DDPSTAT	24
d113 1
a113 1
#define N_DDPCB		25
d115 1
a115 1
#define N_ETHERIPSTAT	26
d117 1
a117 1
#define N_IP6STAT	27
d119 1
a119 1
#define N_ICMP6STAT	28
d121 1
a121 1
#define N_PIM6STAT	29
d123 1
a123 1
#define N_MRT6PROTO	30
d125 1
a125 1
#define N_MRT6STAT	31
d127 1
a127 1
#define N_MF6CTABLE	32
d129 1
a129 1
#define N_MIF6TABLE	33
d131 1
a131 1
#define N_MBPOOL	34
d133 1
a133 1
#define N_MCLPOOL	35
d135 1
a135 1
#define N_IPCOMPSTAT	36
d137 1
a137 1
#define N_RIP6STAT	37
d139 1
a139 1
#define N_CARPSTAT	38
d141 1
a141 1
#define N_RAWIPTABLE	39
d143 1
a143 1
#define N_RAWIP6TABLE	40
d145 1
a145 1
#define N_PFSYNCSTAT	41
d147 1
a147 1
#define N_PIMSTAT	42
d149 1
a149 1
#define N_AF2RTAFIDX	43
d151 1
a151 1
#define N_RTBLIDMAX	44
d153 1
a153 1
#define N_RTMASK	45
@


1.65
log
@add -F to usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.64 2007/03/23 10:59:38 pyr Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.64 2007/03/23 10:59:38 pyr Exp $";
a104 6
#define N_IPX		18
	{ "_ipxcbtable"},
#define N_IPXSTAT	19
	{ "_ipxstat"},
#define N_SPXSTAT	20
	{ "_spx_istat"},
a215 9
struct protox ipxprotox[] = {
	{ N_IPX,	N_IPXSTAT,	1,	ipxprotopr,
	  ipx_stats,	0,		"ipx" },
	{ N_IPX,	N_SPXSTAT,	1,	ipxprotopr,
	  spx_stats,	0,		"spx" },
	{ -1,		-1,		0,	0,
	  0,		0,		0 }
};

d225 1
a225 1
	protox, ipxprotox, atalkprotox, NULL
d229 1
a229 1
	protox, ip6protox, ipxprotox, atalkprotox, NULL
a280 2
			else if (strcmp(optarg, "ipx") == 0)
				af = AF_IPX;
a522 3
	if (af == AF_IPX || af == AF_UNSPEC)
		for (tp = ipxprotox; tp->pr_name; tp++)
			printproto(tp, tp->pr_name);
@


1.64
log
@Add a new flag -F to netstat restricting route display in conjuction
with -r to routes in the same address family as the destination.
ok henning@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.63 2006/08/29 21:51:13 claudio Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.63 2006/08/29 21:51:13 claudio Exp $";
d651 1
a651 1
	    "       %s [-bdgilmnqrstu] [-f address_family] [-M core] [-N system]\n"
@


1.63
log
@Fix KVM snooping code of netstat that got broken by the multiple table
"support". This makes netstat -A work again. OK markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.62 2006/05/27 19:16:37 claudio Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.62 2006/05/27 19:16:37 claudio Exp $";
d270 1
a270 1
	while ((ch = getopt(argc, argv, "Aabdf:gI:ilM:mN:np:P:qrstuvW:w:")) != -1)
d283 3
@


1.62
log
@Moving netstat from kvm snooping to retrieving the routing tables via
sysctl. Most code is stolen from route -- which was stolen from netstat.
kvm snooping code is still in and useable. Put it in deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.61 2005/07/04 01:54:10 djm Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.61 2005/07/04 01:54:10 djm Exp $";
d155 6
d299 2
d488 2
a489 1
			routepr(nl[N_RTREE].n_value);
@


1.61
log
@make these use setres[ug]id for simple privilege dropping;
ok deraadt@@ millert@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.60 2005/06/16 16:03:32 jaredy Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.60 2005/06/16 16:03:32 jaredy Exp $";
d399 10
a408 1

d478 1
a478 1
			rt_stats(nl[N_RTSTAT].n_value);
@


1.60
log
@add -P to docs and usage/synopsis; ok markus jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.59 2005/06/15 10:53:23 markus Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.59 2005/06/15 10:53:23 markus Exp $";
d55 1
d259 1
d395 4
a398 4
	if (nlistf != NULL || memf != NULL || Pflag) {
		setegid(getgid());
		setgid(getgid());
	}
d405 4
a408 2
	setegid(getgid());
	setgid(getgid());
@


1.59
log
@add -P for dumping PCB infos, similar to netbsd; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.58 2005/06/08 04:47:04 henning Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.58 2005/06/08 04:47:04 henning Exp $";
d625 9
a633 11
"usage: %s [-Aan] [-f address_family] [-M core] [-N system]\n", __progname);
	(void)fprintf(stderr,
"       %s [-bdgilmnqrstu] [-f address_family] [-M core] [-N system]\n", __progname);
	(void)fprintf(stderr,
"       %s [-bdn] [-I interface] [-M core] [-N system] [-w wait]\n", __progname);
	(void)fprintf(stderr,
"       %s [-s] [-M core] [-N system] [-p protocol]\n", __progname);
	(void)fprintf(stderr,
"       %s [-a] [-f address_family] [-i | -I interface]\n", __progname);
	(void)fprintf(stderr,
"       %s [-W interface]\n", __progname);
@


1.58
log
@bye bye, Xerox NS protocols
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.57 2005/05/02 10:07:19 jmc Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.57 2005/05/02 10:07:19 jmc Exp $";
d163 1
d167 1
a167 1
	  tcp_stats,	"tcp" },
d169 1
a169 1
	  udp_stats,	"udp" },
d171 1
a171 1
	  ip_stats,	"ip" },
d173 1
a173 1
	  icmp_stats,	"icmp" },
d175 1
a175 1
	  igmp_stats,	"igmp" },
d177 1
a177 1
	  ah_stats,	"ah" },
d179 1
a179 1
	  esp_stats,	"esp" },
d181 1
a181 1
	  ipip_stats,	"ipencap" },
d183 1
a183 1
	  etherip_stats,"etherip" },
d185 1
a185 1
	  ipcomp_stats,	"ipcomp" },
d187 1
a187 1
	  carp_stats,	"carp" },
d189 1
a189 1
	  pfsync_stats,	"pfsync" },
d191 1
a191 1
	  pim_stats,	"pim" },
d193 1
a193 1
	  0,		0 }
d199 1
a199 1
	  0,		"tcp" },
d201 1
a201 1
	  0,		"udp" },
d203 1
a203 1
	  ip6_stats,	"ip6" },
d205 1
a205 1
	  icmp6_stats,	"icmp6" },
d207 1
a207 1
	  pim6_stats,	"pim6" },
d209 1
a209 1
	  rip6_stats,	"rip6" },
d211 1
a211 1
	  0,		0 }
d217 1
a217 1
	  ipx_stats,	"ipx" },
d219 1
a219 1
	  spx_stats,	"spx" },
d221 1
a221 1
	  0,		0 }
d226 1
a226 1
	  ddp_stats,	"ddp" },
d228 1
a228 1
	  0,		0 }
d256 1
a256 1
	char *nlistf = NULL, *memf = NULL;
d258 1
d262 1
a262 1
	while ((ch = getopt(argc, argv, "Aabdf:gI:ilM:mN:np:qrstuvW:w:")) != -1)
d332 12
d391 1
d393 1
a393 1
	if (nlistf != NULL || memf != NULL) {
d439 11
@


1.57
log
@- add a small description of final synopsis form
- tweak a spacing issue in usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.56 2005/04/12 14:11:49 reyk Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.56 2005/04/12 14:11:49 reyk Exp $";
d88 1
a88 9
#define N_IDP		10
	{ "_nspcb"},
#define N_IDPSTAT	11
	{ "_idpstat"},
#define N_SPPSTAT	12
	{ "_spp_istat"},
#define N_NSERR		13
	{ "_ns_errstat"},
#define N_RTREE		14
d90 1
a90 1
#define N_FILE		15
d92 1
a92 1
#define N_IGMPSTAT	16
d94 1
a94 1
#define N_MRTPROTO	17
d96 1
a96 1
#define N_MRTSTAT	18
d98 1
a98 1
#define N_MFCHASHTBL	19
d100 1
a100 1
#define N_MFCHASH	20
d102 1
a102 1
#define N_VIFTABLE	21
d104 1
a104 1
#define N_IPX		22
d106 1
a106 1
#define N_IPXSTAT	23
d108 1
a108 1
#define N_SPXSTAT	24
d110 1
a110 1
#define N_AHSTAT	25
d112 1
a112 1
#define N_ESPSTAT	26
d114 1
a114 1
#define N_IP4STAT	27
d116 1
a116 1
#define N_DDPSTAT	28
d118 1
a118 1
#define N_DDPCB		29
d120 1
a120 1
#define N_ETHERIPSTAT	30
d122 1
a122 1
#define N_IP6STAT	31
d124 1
a124 1
#define N_ICMP6STAT	32
d126 1
a126 1
#define N_PIM6STAT	33
d128 1
a128 1
#define N_MRT6PROTO	34
d130 1
a130 1
#define N_MRT6STAT	35
d132 1
a132 1
#define N_MF6CTABLE	36
d134 1
a134 1
#define N_MIF6TABLE	37
d136 1
a136 1
#define N_MBPOOL	38
d138 1
a138 1
#define N_MCLPOOL	39
d140 1
a140 1
#define N_IPCOMPSTAT	40
d142 1
a142 1
#define N_RIP6STAT	41
d144 1
a144 1
#define N_CARPSTAT	42
d146 1
a146 1
#define N_RAWIPTABLE	43
d148 1
a148 1
#define N_RAWIP6TABLE	44
d150 1
a150 1
#define N_PFSYNCSTAT	45
d152 1
a152 1
#define N_PIMSTAT	46
a222 11
struct protox nsprotox[] = {
	{ N_IDP,	N_IDPSTAT,	1,	nsprotopr,
	  idp_stats,	"idp" },
	{ N_IDP,	N_SPPSTAT,	1,	nsprotopr,
	  spp_stats,	"spp" },
	{ -1,		N_NSERR,	1,	0,
	  nserr_stats,	"ns_err" },
	{ -1,		-1,		0,	0,
	  0,		0 }
};

d232 1
a232 1
	protox, ipxprotox, nsprotox, atalkprotox, NULL
d236 1
a236 1
	protox, ip6protox, ipxprotox, nsprotox, atalkprotox, NULL
a284 2
			else if (strcmp(optarg, "ns") == 0)
				af = AF_NS;
a490 3
			printproto(tp, tp->pr_name);
	if (af == AF_NS || af == AF_UNSPEC)
		for (tp = nsprotox; tp->pr_name; tp++)
@


1.56
log
@add '-W interface' for 802.11 wireless statistics of the net80211 stack.

ok dlg@@ deraadt@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.55 2005/03/30 17:45:51 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.55 2005/03/30 17:45:51 deraadt Exp $";
d633 1
a633 1
"	%s [-W interface]\n", __progname);
@


1.55
log
@remove nlist items no longer used; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.54 2005/03/30 08:23:47 jaredy Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.54 2005/03/30 08:23:47 jaredy Exp $";
d279 1
a279 1
	while ((ch = getopt(argc, argv, "Aabdf:gI:ilM:mN:np:qrstuvw:")) != -1)
d369 4
d385 11
d453 1
d632 2
@


1.54
log
@kill -S; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.53 2005/03/25 17:01:04 jaredy Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.53 2005/03/25 17:01:04 jaredy Exp $";
d68 1
a68 1
#define	N_MBSTAT	0
d70 1
a70 1
#define	N_IPSTAT	1
d72 1
a72 1
#define	N_TCBTABLE	2
d74 1
a74 1
#define	N_TCPSTAT	3
d76 1
a76 1
#define	N_UDBTABLE	4
d78 1
a78 1
#define	N_UDPSTAT	5
d80 1
a80 1
#define	N_IFNET		6
d82 1
a82 3
#define	N_IMP		7
	{ "_imp_softc" },
#define	N_ICMPSTAT	8
d84 1
a84 1
#define	N_RTSTAT	9
d86 1
a86 1
#define	N_UNIXSW	10
d88 1
a88 1
#define N_IDP		11
d90 1
a90 1
#define N_IDPSTAT	12
d92 1
a92 1
#define N_SPPSTAT	13
d94 1
a94 1
#define N_NSERR		14
d96 1
a96 13
#define	N_CLNPSTAT	15
	{ "_clnp_stat"},
#define	IN_NOTUSED	16
	{ "_tp_inpcb" },
#define	ISO_NOTUSED	16
	{ "_tp_refinfo" },
#define	N_TPSTAT	18
	{ "_tp_stat" },
#define	N_ESISSTAT	19
	{ "_esis_stat"},
#define N_NIMP		20
	{ "_nimp"},
#define N_RTREE		21
d98 1
a98 7
#define N_CLTP		22
	{ "_cltb"},
#define N_CLTPSTAT	23
	{ "_cltpstat"},
#define	N_NFILE		24
	{ "_nfile" },
#define	N_FILE		25
d100 1
a100 1
#define N_IGMPSTAT	26
d102 1
a102 1
#define N_MRTPROTO	27
d104 1
a104 1
#define N_MRTSTAT	28
d106 1
a106 1
#define N_MFCHASHTBL	29
d108 1
a108 1
#define	N_MFCHASH	30
d110 1
a110 1
#define N_VIFTABLE	31
d112 1
a112 1
#define N_IPX		32
d114 1
a114 1
#define N_IPXSTAT	33
d116 1
a116 1
#define N_SPXSTAT	34
d118 1
a118 3
#define N_IPXERR	35
	{ "_ipx_errstat"},
#define N_AHSTAT	36
d120 1
a120 1
#define N_ESPSTAT	37
d122 1
a122 1
#define N_IP4STAT	38
d124 1
a124 1
#define N_DDPSTAT	39
d126 1
a126 1
#define N_DDPCB		40
d128 1
a128 1
#define N_ETHERIPSTAT	41
d130 1
a130 1
#define N_IP6STAT	42
d132 1
a132 1
#define N_ICMP6STAT	43
d134 1
a134 5
#define N_IPSECSTAT	44
	{ "_ipsecstat" },
#define N_IPSEC6STAT	45
	{ "_ipsec6stat" },
#define N_PIM6STAT	46
d136 1
a136 1
#define N_MRT6PROTO	47
d138 1
a138 1
#define N_MRT6STAT	48
d140 1
a140 1
#define N_MF6CTABLE	49
d142 1
a142 1
#define N_MIF6TABLE	50
d144 1
a144 1
#define N_MBPOOL	51
d146 1
a146 1
#define N_MCLPOOL	52
d148 1
a148 1
#define N_IPCOMPSTAT	53
d150 1
a150 1
#define N_RIP6STAT	54
d152 1
a152 1
#define N_CARPSTAT	55
d154 1
a154 1
#define	N_RAWIPTABLE	56
d156 1
a156 1
#define	N_RAWIP6TABLE	57
d158 1
a158 1
#define N_PFSYNCSTAT	58
d160 1
a160 1
#define N_PIMSTAT	59
d162 1
a162 1
	{ ""},
@


1.53
log
@kill unneeded (char *) casts.  ok millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.52 2005/02/10 14:25:08 itojun Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.52 2005/02/10 14:25:08 itojun Exp $";
d305 1
a305 1
	while ((ch = getopt(argc, argv, "Aabdf:gI:ilM:mN:np:qrSstuvw:")) != -1)
a382 3
		case 'S':
			Sflag = 1;
			break;
d635 1
a635 1
"       %s [-bdgilmnqrSstu] [-f address_family] [-M core] [-N system]\n", __progname);
@


1.52
log
@backout previous; i committed to wrong repository (i meant to commit kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.50 2005/01/14 15:00:44 mcbride Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.50 2005/01/14 15:00:44 mcbride Exp $";
d564 1
a564 1
kread(u_long addr, char *buf, int size)
@


1.51
log
@dccp support
@
text
@a187 4
#define N_DCCPSTAT	60
	{ "_dccpstat" },
#define	N_DCCPBTABLE	61
	{ "_dccpbtable" },
a202 4
#ifdef DCCP
	{ N_DCCPBTABLE,	N_DCCPSTAT,	1,	protopr,
	  dccp_stats,	"dccp" },
#endif	
a234 4
#ifdef DCCP
	{ N_DCCPBTABLE,	N_DCCPSTAT,	1,	ip6protopr,
	  dccp_stats,	"dccp" },
#endif	
@


1.50
log
@Allow netstat to print PIM statistics.

From Pavlin Radoslavov <pavlin@@icir.org>

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.49 2004/06/29 08:18:20 henning Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.49 2004/06/29 08:18:20 henning Exp $";
d188 4
d207 4
d243 4
@


1.49
log
@repair, Chris Kuethe <ckuethe@@ualberta.ca>
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.48 2004/06/25 20:05:40 henning Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.48 2004/06/25 20:05:40 henning Exp $";
d186 2
d223 2
@


1.48
log
@remove netiso
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47 2004/06/06 22:08:59 jmc Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.47 2004/06/06 22:08:59 jmc Exp $";
d102 2
@


1.47
log
@- add -S to usage()
- for some reason -s was also missing from one of them - sync
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.46 2004/06/06 16:55:31 cedric Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.46 2004/06/06 16:55:31 cedric Exp $";
a101 2
#define	ISO_TP		17
	{ "_tp_refinfo" },
a261 13
struct protox isoprotox[] = {
	{ ISO_TP,	N_TPSTAT,	1,	iso_protopr,
	  tp_stats,	"tp" },
	{ N_CLTP,	N_CLTPSTAT,	1,	iso_protopr,
	  cltp_stats,	"cltp" },
	{ -1,		N_CLNPSTAT,	1,	 0,
	  clnp_stats,	"clnp"},
	{ -1,		N_ESISSTAT,	1,	 0,
	  esis_stats,	"esis"},
	{ -1,		-1,		0,	0,
	  0,		0 }
};

d271 1
a271 1
	protox, ipxprotox, nsprotox, isoprotox, atalkprotox, NULL
d275 1
a275 1
	protox, ip6protox, ipxprotox, nsprotox, isoprotox, atalkprotox, NULL
a325 2
			else if (strcmp(optarg, "iso") == 0)
				af = AF_ISO;
a521 3
			printproto(tp, tp->pr_name);
	if (af == AF_ISO || af == AF_UNSPEC)
		for (tp = isoprotox; tp->pr_name; tp++)
@


1.46
log
@Add new '-S' flag to display the source selector part of the routing table
entry. "netstat -nrSf inet". ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.45 2004/04/01 07:55:17 markus Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.45 2004/04/01 07:55:17 markus Exp $";
d652 1
a652 1
"       %s [-bdgilmnqrstu] [-f address_family] [-M core] [-N system]\n", __progname);
d656 1
a656 1
"       %s [-M core] [-N system] [-p protocol]\n", __progname);
@


1.45
log
@change -p to restrict output to protocol (not just for -s);
ok deraadt@@, hshoexer@@, tdeval@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.44 2004/03/13 22:02:13 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.44 2004/03/13 22:02:13 deraadt Exp $";
d314 1
a314 1
	while ((ch = getopt(argc, argv, "Aabdf:gI:ilM:mN:np:qrstuvw:")) != -1)
d393 3
@


1.44
log
@some NULL vs 0 and knf; parts from nimadeus@@pandora.be
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.43 2003/12/15 07:11:31 mcbride Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.43 2003/12/15 07:11:31 mcbride Exp $";
d466 1
a466 5
		if (tp->pr_stats)
			(*tp->pr_stats)(nl[tp->pr_sindex].n_value,
				tp->pr_name);
		else
			printf("%s: no stats routine\n", tp->pr_name);
@


1.43
log
@Add initial support for pf state synchronization over the network.
Implemented as an in-kernel multicast IP protocol.

Turn it on like this:

# ifconfig pfsync0 up syncif fxp0

There is not yet any authentication on this protocol, so the syncif
must be on a trusted network. ie, a crossover cable between the two
firewalls.

NOTABLE CHANGES:
- A new index based on a unique (creatorid, stateid) tuple has been
  added to the state tree.
- Updates now appear on the pfsync(4) interface; multiple updates may
  be compressed into a single update.
- Applications which use bpf on pfsync(4) will need modification;
  packets on pfsync no longer contains regular pf_state structs,
  but pfsync_state structs which contain no pointers.

Much more to come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.42 2003/11/28 23:10:49 jmc Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.42 2003/11/28 23:10:49 jmc Exp $";
d217 4
a220 4
 	{ -1,		N_CARPSTAT,	1,	0,
 	  carp_stats,	"carp" },
 	{ -1,		N_PFSYNCSTAT,	1,	0,
 	  pfsync_stats,	"pfsync" },
@


1.42
log
@remove "or uninstrumented" from "unknown or uninstrumented protocol";
simplified by marc@@ and ok millert@@;
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.41 2003/11/28 10:05:43 jmc Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.41 2003/11/28 10:05:43 jmc Exp $";
d184 2
d219 2
@


1.41
log
@netstat.1:
- In SYNOPSIS, -a goes with interface display, not -s
- In SYNOPSIS, -i and -I are mutually exclusive
- expand -a description (shows multicast with interface display)
- expand -b and -d descriptions and fix parenthesis typo
- consistently refer to multicast (not Multicast) and MTU (not mtu)
- expand -I description (interaction with -a)
- two missing full stops
- update SEE ALSO

main.c:
- sync with SYNOPSIS
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.40 2003/11/02 10:23:58 markus Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.40 2003/11/02 10:23:58 markus Exp $";
d378 1
a378 1
				    "%s: %s: unknown or uninstrumented protocol\n",
@


1.40
log
@print raw ip[46] sockets; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.39 2003/10/17 21:04:59 mcbride Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.39 2003/10/17 21:04:59 mcbride Exp $";
d655 1
a655 1
"       %s [-s] [-f address_family] [-i] [-I interface]\n", __progname);
@


1.39
log
@Common Address Redundancy Protocol

Allows multiple hosts to share an IP address, providing high availability
and load balancing.

Based on code by mickey@@, with additional help from markus@@
and Marco_Pfatschbacher@@genua.de

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.38 2003/06/26 21:59:11 deraadt Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.38 2003/06/26 21:59:11 deraadt Exp $";
d180 4
d199 1
a199 1
	{ -1,		N_IPSTAT,	1,	0,
d227 1
a227 1
	{ -1,		N_IP6STAT,	1,	0,
@


1.38
log
@more proto fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 2003/06/12 07:39:16 jmc Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.37 2003/06/12 07:39:16 jmc Exp $";
d178 2
d211 2
@


1.37
log
@- document -ltu options;
from PR 3307 (Zoltan Glozik)
- sync SYNOPSIS and usage();

ok henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.36 2003/06/03 02:56:13 millert Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.36 2003/06/03 02:56:13 millert Exp $";
d182 6
a187 6
	u_char	pr_index;		/* index into nlist of cb head */
	u_char	pr_sindex;		/* index into nlist of stat block */
	u_char	pr_wanted;		/* 1 if wanted, 0 otherwise */
	void	(*pr_cblocks)();	/* control blocks printing routine */
	void	(*pr_stats)();		/* statistics printing routine */
	char	*pr_name;		/* well-known name */
d548 1
a548 1
	void (*pr)();
@


1.36
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.35 2003/02/01 14:09:16 dhartmei Exp $	*/
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.35 2003/02/01 14:09:16 dhartmei Exp $";
d641 1
a641 1
"       %s [-gimnrs] [-f address_family] [-M core] [-N system]\n", __progname);
d643 1
a643 1
"       %s [-n] [-I interface] [-M core] [-N system] [-w wait]\n", __progname);
d646 2
@


1.35
log
@Fix out-of-bounds access to nl[255], found by naddy@@ in context of
propolice. ok theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2003/02/01 01:51:31 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char *rcsid = "$OpenBSD: main.c,v 1.34 2003/02/01 01:51:31 deraadt Exp $";
@


1.34
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 2002/08/04 16:52:07 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.33 2002/08/04 16:52:07 deraadt Exp $";
d553 1
a553 1
	u_long off;
d557 1
a557 1
		off = nl[tp->pr_sindex].n_value;
d560 1
a560 1
		off = nl[tp->pr_index].n_value;
d562 3
a564 2
	if (pr != NULL && (off || af != AF_UNSPEC))
		(*pr)(off, name);
@


1.33
log
@revoke privs earlier
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2002/06/07 21:58:38 itojun Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.32 2002/06/07 21:58:38 itojun Exp $";
d277 3
a279 1
struct protox *protoprotox[] = { protox, ipxprotox, nsprotox, isoprotox, atalkprotox, NULL };
d281 3
a283 1
struct protox *protoprotox[] = { protox, ip6protox, ipxprotox, nsprotox, isoprotox, atalkprotox, NULL };
d294 1
a294 3
main(argc, argv)
	int argc;
	char *argv[];
d550 1
a550 3
printproto(tp, name)
	struct protox *tp;
	char *name;
d570 1
a570 4
kread(addr, buf, size)
	u_long addr;
	char *buf;
	int size;
d582 1
a582 2
plural(n)
	int n;
d588 1
a588 2
plurales(n)
	int n;
d597 1
a597 2
knownname(name)
	char *name;
d612 1
a612 2
name2protox(name)
	char *name;
d639 1
a639 1
usage()
@


1.32
log
@print rip6stat
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2002/05/27 01:50:36 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.31 2002/05/27 01:50:36 deraadt Exp $";
d407 17
a440 17

	/*
	 * Discard setgid privileges if not the running kernel so that bad
	 * guys can't print interesting stuff from kernel memory.
	 */
	if (nlistf != NULL || memf != NULL) {
		setegid(getgid());
		setgid(getgid());
	}

	if ((kvmd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY,
	    buf)) == NULL) {
		fprintf(stderr, "%s: kvm_open: %s\n", __progname, buf);
		exit(1);
	}
	setegid(getgid());
	setgid(getgid());
@


1.31
log
@a night of cleanup, so i can read this easier
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2002/02/16 21:27:50 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.30 2002/02/16 21:27:50 millert Exp $";
d180 2
d229 2
@


1.30
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2002/01/17 21:34:58 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.29 2002/01/17 21:34:58 mickey Exp $";
d301 1
a301 1
		switch(ch) {
@


1.29
log
@evil, annoying spaces and tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2001/11/19 19:02:15 mpech Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.28 2001/11/19 19:02:15 mpech Exp $";
d278 4
a281 4
static void printproto __P((struct protox *, char *));
static void usage __P((void));
static struct protox *name2protox __P((char *));
static struct protox *knownname __P((char *));
@


1.28
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 2001/08/26 09:42:04 brian Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.27 2001/08/26 09:42:04 brian Exp $";
d178 1
a178 1
#define N_IPCOMPSTAT    53
d209 2
a210 2
	{ -1,           N_IPCOMPSTAT,   1,      0,
	  ipcomp_stats, "ipcomp" },
@


1.27
log
@Add a -q to silence zero-output lines and fix some whitespace and text nits.

Submitted by:	Sam Smith <S@@mSmith.net>
Ok:		theo
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 2001/07/05 08:47:44 jjbg Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.26 2001/07/05 08:47:44 jjbg Exp $";
d292 2
a293 2
	register struct protoent *p;
	register struct protox *tp = NULL; /* for printing cblocks & stats */
d545 1
a545 1
	register struct protox *tp;
@


1.26
log
@IPComp support. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2001/05/18 02:41:38 provos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.25 2001/05/18 02:41:38 provos Exp $";
d300 1
a300 1
	while ((ch = getopt(argc, argv, "Aabdf:gI:ilM:mN:np:rstuvw:")) != -1)
d373 3
@


1.25
log
@adapt to use pool
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2000/12/13 15:52:58 camield Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.24 2000/12/13 15:52:58 camield Exp $";
d178 2
d209 2
@


1.24
log
@Bytecounter stats. (-b switch)
From NetBSD. ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2000/06/30 23:32:14 itojun Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.23 2000/06/30 23:32:14 itojun Exp $";
d174 4
d440 2
a441 1
		mbpr(nl[N_MBSTAT].n_value);
@


1.23
log
@do not prin tcp/udp twice.  from: fgs
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2000/06/30 20:04:01 itojun Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.22 2000/06/30 20:04:01 itojun Exp $";
d292 1
a292 1
	while ((ch = getopt(argc, argv, "Aadf:gI:ilM:mN:np:rstuvw:")) != -1)
d299 3
@


1.22
log
@split netstat -an -f inet and netstat -an -f inet6, for consistency.
Suggested by: fgs
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2000/01/21 03:24:06 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.21 2000/01/21 03:24:06 angelos Exp $";
d210 1
a210 1
	  tcp_stats,	"tcp" },
d212 1
a212 1
	  udp_stats,	"udp" },
@


1.21
log
@ip4 -> ipip
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2000/01/11 01:14:26 fgsch Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.20 2000/01/11 01:14:26 fgsch Exp $";
d209 4
@


1.20
log
@Remove references to ipx_error.h; it's going to be away.
(commented it out in ipx.c by now).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 1999/12/08 12:30:17 itojun Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.19 1999/12/08 12:30:17 itojun Exp $";
d149 1
a149 1
	{ "_ip4stat"},
d200 1
a200 1
	  ip4_stats,	"ipencap" },
@


1.19
log
@add IPv6 support from KAME.  cleanup type matches with printf() format.
KAME_SCOPEID should be enabled after KAME get{addr,name}info(3) merge.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 1999/10/29 03:26:40 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.18 1999/10/29 03:26:40 angelos Exp $";
a224 2
	{ -1,		N_IPXERR,	1,	0,
	  ipxerr_stats,	"ipx_err" },
@


1.18
log
@etherip statistics
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 1999/03/01 01:28:13 d Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.17 1999/03/01 01:28:13 d Exp $";
d156 18
d207 13
d262 1
d264 3
d283 1
a283 1
	register struct protox *tp;	/* for printing cblocks & stats */
d290 1
a290 1
	while ((ch = getopt(argc, argv, "Aadf:gI:iM:mN:np:rstuvw:")) != -1)
d304 2
d337 3
d460 23
a482 8
		if (sflag)
			mrt_stats(nl[N_MRTPROTO].n_value,
			    nl[N_MRTSTAT].n_value);
		else
			mroutepr(nl[N_MRTPROTO].n_value,
			    nl[N_MFCHASHTBL].n_value,
			    nl[N_MFCHASH].n_value,
			    nl[N_VIFTABLE].n_value);
d499 5
@


1.17
log
@There is no -h flag
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 1999/02/24 22:57:34 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.16 1999/02/24 22:57:34 angelos Exp $";
d154 2
d183 2
@


1.16
log
@Grok protocol/address family PF_KEY.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 1998/08/01 05:36:18 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.15 1998/08/01 05:36:18 angelos Exp $";
d251 1
a251 1
	while ((ch = getopt(argc, argv, "Aadf:ghI:iM:mN:np:rstuvw:")) != -1)
d566 1
a566 1
"       %s [-ghimnrs] [-f address_family] [-M core] [-N system]\n", __progname);
@


1.15
log
@sipp-esp/sipp-ah -> esp/ah
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 1998/07/08 22:14:15 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.14 1998/07/08 22:14:15 deraadt Exp $";
d276 1
a276 1
				af = AF_ENCAP;
@


1.14
log
@whack kmem gid after kvm_openfiles()
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 1998/02/26 10:06:07 peter Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.13 1998/02/26 10:06:07 peter Exp $";
d176 1
a176 1
	  ah_stats,	"sipp-ah" },
d178 1
a178 1
	  esp_stats,	"sipp-esp" },
@


1.13
log
@* netstat -r [-n] now prints netmasks for network routes (in XXX/24 format).

* beginnings of a -v (verbose) option.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 1997/07/23 04:38:33 denny Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.12 1997/07/23 04:38:33 denny Exp $";
d375 3
@


1.12
log
@Add AppleTalk support. TODO: route.c does not handle netranges.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 1997/06/29 20:18:01 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.11 1997/06/29 20:18:01 millert Exp $";
d251 1
a251 1
	while ((ch = getopt(argc, argv, "Aadf:ghI:iM:mN:np:rstuw:")) != -1)
d328 3
@


1.11
log
@Mostly clean -Wall + 64bit issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 1997/06/18 01:52:27 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.10 1997/06/18 01:52:27 angelos Exp $";
d150 4
d220 8
a227 1
struct protox *protoprotox[] = { protox, ipxprotox, nsprotox, isoprotox, NULL };
d277 2
d445 3
@


1.10
log
@Be a bit more verbose for AF_ENCAP "routing" entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 1997/02/22 04:35:24 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.9 1997/02/22 04:35:24 angelos Exp $";
d150 1
a150 1
	"",
a233 1
	register char *cp;
d411 1
a411 1
		while (p = getprotoent()) {
d522 1
a522 1
	if (tp = knownname(name))
d526 1
a526 1
	while (p = getprotoent()) {
@


1.9
log
@Corrected protocol name.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1997/02/21 09:09:52 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.8 1997/02/21 09:09:52 angelos Exp $";
d265 2
@


1.8
log
@netstat now understands SIPP-AH/SIPP-ESP (IPsec) and ENCAP protocols.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 1997/02/01 17:31:19 kstailey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.7 1997/02/01 17:31:19 kstailey Exp $";
d176 1
a176 1
	  ip4_stats,	"encap" },
@


1.7
log
@accept "-f local" for AF_LOCAL"
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 1997/01/15 23:42:55 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.6 1997/01/15 23:42:55 millert Exp $";
d144 6
d171 6
@


1.6
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1996/12/22 03:25:58 tholo Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.5 1996/12/22 03:25:58 tholo Exp $";
d243 2
@


1.5
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 1996/08/16 09:29:33 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.4 1996/08/16 09:29:33 mickey Exp $";
d229 1
a229 1
	while ((ch = getopt(argc, argv, "Aadf:ghI:iM:mN:np:rstuw:")) != EOF)
@


1.4
log
@ipx.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 1996/06/26 05:37:22 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.3 1996/06/26 05:37:22 deraadt Exp $";
d334 2
a335 1
	if (nlistf != NULL || memf != NULL)
d337 1
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 1996/05/07 02:55:02 thorpej Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: main.c,v 1.9 1996/05/07 02:55:02 thorpej Exp $";
d136 8
d169 11
d204 1
a204 1
struct protox *protoprotox[] = { protox, nsprotox, isoprotox, NULL };
d241 1
a241 3
			if (strcmp(optarg, "ns") == 0)
				af = AF_NS;
			else if (strcmp(optarg, "inet") == 0)
d245 4
d404 3
@


1.2
log
@if_name/if_unit -> if_xname/if_softc
network list is a TAILQ
@
text
@d1 1
d47 1
a47 1
static char *rcsid = "$NetBSD: main.c,v 1.9 1996/05/07 02:55:02 thorpej Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: main.c,v 1.8 1995/10/03 21:42:40 thorpej Exp $	*/
d46 1
a46 1
static char *rcsid = "$NetBSD: main.c,v 1.8 1995/10/03 21:42:40 thorpej Exp $";
a206 4
	if (cp = rindex(argv[0], '/'))
		prog = cp + 1;
	else
		prog = argv[0];
d232 1
a232 1
				    prog, optarg);
d239 1
a239 3
		case 'I': {
			char *cp;

d241 1
a241 4
			for (cp = interface = optarg; isalpha(*cp); cp++)
				continue;
			unit = atoi(cp);
			*cp = '\0';
a242 1
		}
d262 1
a262 1
				    prog, optarg);
d315 3
a317 2
	if ((kvmd = kvm_open(nlistf, memf, NULL, O_RDONLY, prog)) == NULL) {
		fprintf(stderr, "%s: kvm_open: %s\n", prog, buf);
d322 2
a323 1
			fprintf(stderr, "%s: %s: no namelist\n", prog, nlistf);
d325 1
a325 1
			fprintf(stderr, "%s: no namelist\n", prog);
d428 1
a428 2
		/* XXX this duplicates kvm_read's error printout */
		(void)fprintf(stderr, "%s: kvm_read %s\n", prog,
d500 1
a500 1
"usage: %s [-Aan] [-f address_family] [-M core] [-N system]\n", prog);
d502 1
a502 1
"       %s [-ghimnrs] [-f address_family] [-M core] [-N system]\n", prog);
d504 1
a504 1
"       %s [-n] [-I interface] [-M core] [-N system] [-w wait]\n", prog);
d506 1
a506 1
"       %s [-M core] [-N system] [-p protocol]\n", prog);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

