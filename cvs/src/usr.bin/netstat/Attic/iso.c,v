head	1.16;
access;
symbols
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.7.0.16
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.14
	OPENBSD_2_8:1.7.0.12
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.10
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2004.06.25.20.05.40;	author henning;	state dead;
branches;
next	1.15;

1.15
date	2004.05.07.15.51.11;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.13.22.02.13;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.26.21.59.11;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.03.02.56.13;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.01.01.51.31;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.27.01.50.36;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.50;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	98.02.27.12.07.36;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.06.29.21.46.02;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.06.29.20.52.41;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.06.29.20.18.00;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.17.07.12.58;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.37.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.51;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.51;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@remove netiso
@
text
@/*	$OpenBSD: iso.c,v 1.15 2004/05/07 15:51:11 millert Exp $	*/
/*	$NetBSD: iso.c,v 1.12 1995/10/03 21:42:38 thorpej Exp $	*/

/*
 * Copyright (c) 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
#if 0
static char sccsid[] = "from: @@(#)iso.c	8.1 (Berkeley) 6/6/93";
#else
static char *rcsid = "$OpenBSD: iso.c,v 1.15 2004/05/07 15:51:11 millert Exp $";
#endif
#endif /* not lint */

/*******************************************************************************
	          Copyright IBM Corporation 1987

                      All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of IBM not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

*******************************************************************************/

/*
 * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison
 */

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/mbuf.h>
#include <sys/time.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <errno.h>
#include <net/if.h>
#include <net/route.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netiso/iso.h>
#include <netiso/iso_errno.h>
#include <netiso/clnp.h>
#include <netiso/esis.h>
#include <netiso/clnp_stat.h>
#include <netiso/argo_debug.h>
#undef satosiso
#include <netiso/tp_param.h>
#include <netiso/tp_states.h>
#include <netiso/tp_pcb.h>
#include <netiso/tp_stat.h>
#include <netiso/iso_pcb.h>
#include <netiso/cltp_var.h>
#include <netiso/cons.h>
#ifdef IncStat
#undef IncStat
#endif
#include <netiso/cons_pcb.h>
#include <arpa/inet.h>
#include <limits.h>
#include <netdb.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "netstat.h"

static void tprintstat(struct tp_stat *, int);
static void isonetprint(struct sockaddr_iso *, int);
static void hexprint(int, char *, char *);
extern void inetprint(struct in_addr *, int, char *);

/*
 *	Dump esis stats
 */
void
esis_stats(u_long off, char *name)
{
	struct esis_stat esis_stat;

	if (off == 0 ||
	    kread(off, (char *)&esis_stat, sizeof (struct esis_stat)))
		return;
	printf("%s:\n", name);
	printf("\t%d esh sent, %d esh received\n", esis_stat.es_eshsent,
	    esis_stat.es_eshrcvd);
	printf("\t%d ish sent, %d ish received\n", esis_stat.es_ishsent,
	    esis_stat.es_ishrcvd);
	printf("\t%d rd sent, %d rd received\n", esis_stat.es_rdsent,
	    esis_stat.es_rdrcvd);
	printf("\t%d pdus not sent due to insufficient memory\n",
	    esis_stat.es_nomem);
	printf("\t%d pdus received with bad checksum\n", esis_stat.es_badcsum);
	printf("\t%d pdus received with bad version number\n",
	    esis_stat.es_badvers);
	printf("\t%d pdus received with bad type field\n", esis_stat.es_badtype);
	printf("\t%d short pdus received\n", esis_stat.es_toosmall);
}

/*
 * Dump clnp statistics structure.
 */
void
clnp_stats(u_long off, char *name)
{
	struct clnp_stat clnp_stat;

	if (off == 0 ||
	    kread(off, (char *)&clnp_stat, sizeof (clnp_stat)))
		return;

	printf("%s:\n\t%d total packets sent\n", name, clnp_stat.cns_sent);
	printf("\t%d total fragments sent\n", clnp_stat.cns_fragments);
	printf("\t%d total packets received\n", clnp_stat.cns_total);
	printf("\t%d with fixed part of header too small\n",
	    clnp_stat.cns_toosmall);
	printf("\t%d with header length not reasonable\n", clnp_stat.cns_badhlen);
	printf("\t%d incorrect checksum%s\n",
	    clnp_stat.cns_badcsum, plural(clnp_stat.cns_badcsum));
	printf("\t%d with unreasonable address lengths\n", clnp_stat.cns_badaddr);
	printf("\t%d with forgotten segmentation information\n",
	    clnp_stat.cns_noseg);
	printf("\t%d with an incorrect protocol identifier\n", clnp_stat.cns_noproto);
	printf("\t%d with an incorrect version\n", clnp_stat.cns_badvers);
	printf("\t%d dropped because the ttl has expired\n",
	    clnp_stat.cns_ttlexpired);
	printf("\t%d clnp cache misses\n", clnp_stat.cns_cachemiss);
	printf("\t%d clnp congestion experience bits set\n",
	    clnp_stat.cns_congest_set);
	printf("\t%d clnp congestion experience bits received\n",
	    clnp_stat.cns_congest_rcvd);
}
/*
 * Dump CLTP statistics structure.
 */
void
cltp_stats(u_long off, char *name)
{
	struct cltpstat cltpstat;

	if (off == 0 ||
	    kread(off, (char *)&cltpstat, sizeof (cltpstat)))
		return;
	printf("%s:\n\t%u incomplete header%s\n", name,
	    cltpstat.cltps_hdrops, plural(cltpstat.cltps_hdrops));
	printf("\t%u bad data length field%s\n",
	    cltpstat.cltps_badlen, plural(cltpstat.cltps_badlen));
	printf("\t%u bad checksum%s\n",
	    cltpstat.cltps_badsum, plural(cltpstat.cltps_badsum));
}

struct	tp_pcb tpcb;
struct	isopcb isopcb;
struct	socket sockb;
union	{
	struct sockaddr_iso	siso;
	char	data[128];
} laddr, faddr;
#define kget(o, p) \
	(kread((u_long)(o), (char *)&p, sizeof (p)))

static	int first = 1;

/*
 * Print a summary of connections related to an Internet
 * protocol.  For TP, also give state of connection.
 * Listening processes (aflag) are suppressed unless the
 * -a (all) flag is specified.
 */
void
iso_protopr(u_long off, char *name)
{
	struct isopcb cb;
	struct isopcb *prev, *next;

	if (off == 0) {
		printf("%s control block: symbol not in namelist\n", name);
		return;
	}
	if (strcmp(name, "tp") == 0) {
		tp_protopr(off, name);
		return;
	}
	if (kread(off, (char *)&cb, sizeof(cb)))
		return;
	isopcb = cb;
	prev = (struct isopcb *)off;
	if (isopcb.isop_next == (struct isopcb *)off)
		return;
	while (isopcb.isop_next != (struct isopcb *)off) {
		next = isopcb.isop_next;
		kget(next, isopcb);
		if (isopcb.isop_prev != prev) {
			printf("prev %p next %p isop_prev %p isop_next %p???\n",
			    prev, next, isopcb.isop_prev, isopcb.isop_next);
			break;
		}
		kget(isopcb.isop_socket, sockb);
		iso_protopr1((u_long)next, 0);
		putchar('\n');
		prev = next;
	}
}

void
iso_protopr1(u_long kern_addr, int istp)
{
	if (first) {
		printf("Active ISO net connections");
		if (aflag)
			printf(" (including servers)");
		putchar('\n');
		if (Aflag)
			printf("%-*.*s %-5.5s %-6.6s %-6.6s  %-*.*s %-*.*s %s\n",
			    PLEN, PLEN, "PCB", "Proto", "Recv-Q",
			    "Send-Q", PLEN, PLEN, "Local Address",
			    PLEN, PLEN, "Foreign Address", "(state)");
		else
			printf("%-5.5s %-6.6s %-6.6s  %-22.22s %-22.22s %s\n",
			    "Proto", "Recv-Q", "Send-Q",
			    "Local Address", "Foreign Address",
			    "(state)");
		first = 0;
	}
	if (Aflag)
			printf("%*p ", PLEN,
			    (sockb.so_pcb ? (void *)sockb.so_pcb : (void *)kern_addr));
	printf("%-5.5s %6ld %6ld ", "tp", sockb.so_rcv.sb_cc,
	    sockb.so_snd.sb_cc);
	if (istp && tpcb.tp_lsuffixlen) {
		hexprint(tpcb.tp_lsuffixlen, tpcb.tp_lsuffix, "()");
		printf("\t");
	} else if (isopcb.isop_laddr == 0)
		printf("*.*\t");
	else {
		if ((char *)isopcb.isop_laddr == ((char *)kern_addr) +
		    _offsetof(struct isopcb, isop_sladdr))
			laddr.siso = isopcb.isop_sladdr;
		else
			kget(isopcb.isop_laddr, laddr);
		isonetprint((struct sockaddr_iso *)&laddr, 1);
	}
	if (istp && tpcb.tp_fsuffixlen) {
		hexprint(tpcb.tp_fsuffixlen, tpcb.tp_fsuffix, "()");
		printf("\t");
	} else if (isopcb.isop_faddr == 0)
		printf("*.*\t");
	else {
		if ((char *)isopcb.isop_faddr == ((char *)kern_addr) +
		    _offsetof(struct isopcb, isop_sfaddr))
			faddr.siso = isopcb.isop_sfaddr;
		else
			kget(isopcb.isop_faddr, faddr);
		isonetprint((struct sockaddr_iso *)&faddr, 0);
	}
}

void
tp_protopr(u_long off, char *name)
{
	extern char *tp_sstring[];
	struct tp_ref *tpr, *tpr_base;
	struct tp_refinfo tpkerninfo;
	int size;

	kget(off, tpkerninfo);
	size = tpkerninfo.tpr_size * sizeof (*tpr);
	tpr_base = (struct tp_ref *)malloc(size);
	if (tpr_base == 0)
		return;
	kread((u_long)(tpkerninfo.tpr_base), (char *)tpr_base, size);
	for (tpr = tpr_base; tpr < tpr_base + tpkerninfo.tpr_size; tpr++) {
		if (tpr->tpr_pcb == 0)
			continue;
		kget(tpr->tpr_pcb, tpcb);
		if (tpcb.tp_state == ST_ERROR)
			printf("undefined tpcb state: %p\n", tpr->tpr_pcb);
		if (!aflag &&
		    (tpcb.tp_state == TP_LISTENING ||
		    tpcb.tp_state == TP_CLOSED ||
		    tpcb.tp_state == TP_REFWAIT))
			continue;
		kget(tpcb.tp_sock, sockb);
		if (tpcb.tp_npcb)
			switch (tpcb.tp_netservice) {
			case IN_CLNS:
				tp_inproto((u_long)tpkerninfo.tpr_base);
				break;
			default:
				kget(tpcb.tp_npcb, isopcb);
				iso_protopr1((u_long)tpcb.tp_npcb, 1);
				break;
		}
		if (tpcb.tp_state >= tp_NSTATES)
			printf(" %d", tpcb.tp_state);
		else
			printf(" %-12.12s", tp_sstring[tpcb.tp_state]);
		putchar('\n');
	}
}

void
tp_inproto(u_long pcb)
{
	struct inpcb inpcb;

	kget(tpcb.tp_npcb, inpcb);
	if (!aflag && inet_lnaof(inpcb.inp_laddr) == INADDR_ANY)
		return;
	if (Aflag)
		printf("%8lx ", pcb);
	printf("%-5.5s %6ld %6ld ", "tpip",
	    sockb.so_rcv.sb_cc, sockb.so_snd.sb_cc);
	inetprint(&inpcb.inp_laddr, inpcb.inp_lport, "tp");
	inetprint(&inpcb.inp_faddr, inpcb.inp_fport, "tp");
}

/*
 * Pretty print an iso address (net address + port).
 * If the nflag was specified, use numbers instead of names.
 */

#ifdef notdef
char *
isonetname(struct iso_addr *iso)
{
	struct sockaddr_iso sa;
	struct iso_hostent *ihe = 0;
	struct iso_hostent *iso_gethostentrybyaddr();
	struct iso_hostent *iso_getserventrybytsel();
	struct iso_hostent Ihe;
	static char line[80];

	bzero(line, sizeof(line));
	if (iso->isoa_afi) {
		sa.siso_family = AF_ISO;
		sa.siso_addr = *iso;
		sa.siso_tsuffix = 0;

		if (!nflag)
			ihe = iso_gethostentrybyaddr( &sa, 0, 0 );
		if (ihe) {
			Ihe = *ihe;
			ihe = &Ihe;
			snprintf(line, sizeof line, "%s", ihe->isoh_hname);
		} else {
			snprintf(line, sizeof line, "%s", iso_ntoa(iso));
		}
	} else {
		snprintf(line, sizeof line, "*");
	}
	return line;
}

static void
isonetprint(struct iso_addr *iso, char *sufx, u_short sufxlen, int islocal)
{
	struct iso_hostent *iso_getserventrybytsel(), *ihe;
	struct iso_hostent Ihe;
	char *line, *cp;
	int Alen = Aflag?18:22;

	line = isonetname(iso);
	cp = strchr(line, '\0');
	ihe = (struct iso_hostent *)0;

	if (islocal)
		islocal = 20;
	else
		islocal = 22 + Alen;

	if (Aflag)
		islocal += 10 ;

	if (!nflag) {
		if ((cp -line)>10) {
			cp = line+10;
			bzero(cp, strlen(cp));
		}
	}

	*cp++ = '.';
	if (sufxlen) {
		if (!Aflag && !nflag && (ihe=iso_getserventrybytsel(sufx, sufxlen))) {
			Ihe = *ihe;
			ihe = &Ihe;
		}
		if (ihe && (strlen(ihe->isoh_aname)>0) ) {
			snprintf(cp, line + sizeof line - cp, "%s",
			    ihe->isoh_aname);
		} else {
			iso_sprinttsel(cp, sufx, sufxlen);
		}
	} else
		snprintf(cp, line + sizeof line - cp, "*");

	if (strlen(line) > Alen ) {
		fprintf(stdout, " %s", line);
		fprintf(stdout, "\n %*.s", islocal+Alen," ");
	} else {
		fprintf(stdout, " %-*.*s", Alen, Alen,line);
	}
}
#endif

#ifdef notdef
static void
x25_protopr(u_long off, char *name)
{
	static char *xpcb_states[] = {
		"CLOSED",
		"LISTENING",
		"CLOSING",
		"CONNECTING",
		"ACKWAIT",
		"OPEN",
	};
	struct isopcb *prev, *next;
	struct x25_pcb xpcb;

	if (off == 0) {
		printf("%s control block: symbol not in namelist\n", name);
		return;
	}
	kread(off, &xpcb, sizeof (struct x25_pcb));
	prev = (struct isopcb *)off;
	if (xpcb.x_next == (struct isopcb *)off)
		return;
	while (xpcb.x_next != (struct isopcb *)off) {
		next = isopcb.isop_next;
		kread((u_long)next, &xpcb, sizeof (struct x25_pcb));
		if (xpcb.x_prev != prev) {
			printf("???\n");
			break;
		}
		kread((u_long)xpcb.x_socket, &sockb, sizeof (sockb));

		if (!aflag &&
			xpcb.x_state == LISTENING ||
			xpcb.x_state == TP_CLOSED ) {
			prev = next;
			continue;
		}
		if (first) {
			printf("Active X25 net connections");
			if (aflag)
				printf(" (including servers)");
			putchar('\n');
			if (Aflag)
				printf("%-*.*s %-5.5s %-6.6s %-6.6s  %-*.*s %-*.*s %s\n",
				    PLEN, PLEN, "PCB", "Proto", "Recv-Q",
				    "Send-Q", PLEN, PLEN, "Local Address",
				    PLEN, PLEN, "Foreign Address", "(state)");
			else
				printf("%-5.5s %-6.6s %-6.6s  %-22.22s %-22.22s %s\n",
				    "Proto", "Recv-Q", "Send-Q",
				    "Local Address", "Foreign Address",
				    "(state)");
			first = 0;
		}
		printf("%-5.5s %6d %6d ", name, sockb.so_rcv.sb_cc,
		    sockb.so_snd.sb_cc);
		isonetprint(&xpcb.x_laddr.siso_addr, &xpcb.x_lport,
		    sizeof(xpcb.x_lport), 1);
		isonetprint(&xpcb.x_faddr.siso_addr, &xpcb.x_fport,
		    sizeof(xpcb.x_lport), 0);
		if (xpcb.x_state < 0 || xpcb.x_state >= x25_NSTATES)
			printf(" 0x0x0x0x0x0x0x0x0x%x", xpcb.x_state);
		else
			printf(" %-12.12s", xpcb_states[xpcb.x_state]);
		putchar('\n');
		prev = next;
	}
}
#endif

struct	tp_stat tp_stat;

void
tp_stats(u_long off, char *name)
{
	if (off == 0) {
		printf("TP not configured\n\n");
		return;
	}
	printf("%s:\n", name);
	kget(off, tp_stat);
	tprintstat(&tp_stat, 8);
}

#define OUT stdout

static void
tprintstat(struct tp_stat *s, int indent)
{
	fprintf(OUT,
	    "%*sReceiving:\n",indent," ");
	fprintf(OUT,
	    "\t%*s%ld variable parameter%s ignored\n", indent," ",
	    s->ts_param_ignored ,plural(s->ts_param_ignored));
	fprintf(OUT,
	    "\t%*s%ld invalid parameter code%s\n", indent, " ",
	    s->ts_inv_pcode ,plural(s->ts_inv_pcode));
	fprintf(OUT,
	    "\t%*s%ld invalid parameter value%s\n", indent, " ",
	    s->ts_inv_pval ,plural(s->ts_inv_pval));
	fprintf(OUT,
	    "\t%*s%ld invalid dutype%s\n", indent, " ",
	    s->ts_inv_dutype ,plural(s->ts_inv_dutype));
	fprintf(OUT,
	    "\t%*s%ld negotiation failure%s\n", indent, " ",
	    s->ts_negotfailed ,plural(s->ts_negotfailed));
	fprintf(OUT,
	    "\t%*s%ld invalid destination reference%s\n", indent, " ",
	    s->ts_inv_dref ,plural(s->ts_inv_dref));
	fprintf(OUT,
	    "\t%*s%ld invalid suffix parameter%s\n", indent, " ",
	    s->ts_inv_sufx ,plural(s->ts_inv_sufx));
	fprintf(OUT,
	    "\t%*s%ld invalid length\n",indent, " ", s->ts_inv_length);
	fprintf(OUT,
	    "\t%*s%ld invalid checksum%s\n", indent, " ",
	    s->ts_bad_csum ,plural(s->ts_bad_csum));
	fprintf(OUT,
	    "\t%*s%ld DT%s out of order\n", indent, " ",
	    s->ts_dt_ooo ,plural(s->ts_dt_ooo));
	fprintf(OUT,
	    "\t%*s%ld DT%s not in window\n", indent, " ",
	    s->ts_dt_niw ,plural(s->ts_dt_niw));
	fprintf(OUT,
	    "\t%*s%ld duplicate DT%s\n", indent, " ",
	    s->ts_dt_dup ,plural(s->ts_dt_dup));
	fprintf(OUT,
	    "\t%*s%ld XPD%s not in window\n", indent, " ",
	    s->ts_xpd_niw ,plural(s->ts_xpd_niw));
	fprintf(OUT,
	    "\t%*s%ld XPD%s w/o credit to stash\n", indent, " ",
	    s->ts_xpd_dup ,plural(s->ts_xpd_dup));
	fprintf(OUT,
	    "\t%*s%ld time%s local credit reneged\n", indent, " ",
	    s->ts_lcdt_reduced ,plural(s->ts_lcdt_reduced));
	fprintf(OUT,
	    "\t%*s%ld concatenated TPDU%s\n", indent, " ",
	    s->ts_concat_rcvd ,plural(s->ts_concat_rcvd));
	fprintf(OUT,
	    "%*sSending:\n", indent, " ");
	fprintf(OUT,
	    "\t%*s%ld XPD mark%s discarded\n", indent, " ",
	    s->ts_xpdmark_del ,plural(s->ts_xpdmark_del));
	fprintf(OUT,
	    "\t%*sXPD stopped data flow %ld time%s\n", indent, " ",
	    s->ts_xpd_intheway ,plural(s->ts_xpd_intheway));
	fprintf(OUT,
	    "\t%*s%ld time%s foreign window closed\n", indent, " ",
	    s->ts_zfcdt ,plural(s->ts_zfcdt));
	fprintf(OUT,
	    "%*sMiscellaneous:\n", indent, " ");
	fprintf(OUT,
	    "\t%*s%ld small mbuf%s\n", indent, " ",
	    s->ts_mb_small ,plural(s->ts_mb_small));
	fprintf(OUT,
	    "\t%*s%ld cluster%s\n", indent, " ",
	    s->ts_mb_cluster, plural(s->ts_mb_cluster));
	fprintf(OUT,
	    "\t%*s%ld source quench \n",indent, " ",
	    s->ts_quench);
	fprintf(OUT,
	    "\t%*s%ld dec bit%s\n", indent, " ",
	    s->ts_rcvdecbit, plural(s->ts_rcvdecbit));
	fprintf(OUT,
	    "\t%*sM:L ( M mbuf chains of length L)\n", indent, " ");
	{
		int j;

		fprintf(OUT, "\t%*s%ld: over 16\n", indent, " ",
		s->ts_mb_len_distr[0]);
		for (j=1; j<=8; j++) {
			fprintf(OUT,
			    "\t%*s%ld: %d\t\t%ld: %d\n", indent, " ",
			    s->ts_mb_len_distr[j],j,
			    s->ts_mb_len_distr[j<<1],j<<1);
		}
	}
	fprintf(OUT,
	    "\t%*s%ld EOT rcvd\n",  indent, " ", s->ts_eot_input);
	fprintf(OUT,
	    "\t%*s%ld EOT sent\n",  indent, " ", s->ts_EOT_sent);
	fprintf(OUT,
	    "\t%*s%ld EOT indication%s\n",  indent, " ",
	    s->ts_eot_user ,plural(s->ts_eot_user));

	fprintf(OUT,
	    "%*sConnections:\n", indent, " ");
	fprintf(OUT,
	    "\t%*s%ld connection%s used extended format\n",  indent, " ",
	    s->ts_xtd_fmt ,plural(s->ts_xtd_fmt));
	fprintf(OUT,
	    "\t%*s%ld connection%s allowed transport expedited data\n",  indent, " ",
	    s->ts_use_txpd ,plural(s->ts_use_txpd));
	fprintf(OUT,
	    "\t%*s%ld connection%s turned off checksumming\n",  indent, " ",
	    s->ts_csum_off ,plural(s->ts_csum_off));
	fprintf(OUT,
	    "\t%*s%ld connection%s dropped due to retrans limit\n",  indent, " ",
	    s->ts_conn_gaveup ,plural(s->ts_conn_gaveup));
	fprintf(OUT,
	    "\t%*s%ld tp 4 connection%s\n",  indent, " ",
	    s->ts_tp4_conn ,plural(s->ts_tp4_conn));
	fprintf(OUT,
	    "\t%*s%ld tp 0 connection%s\n",  indent, " ",
	    s->ts_tp0_conn ,plural(s->ts_tp0_conn));
	{
		int j;
		static char *name[]= {
			"~LOCAL, PDN",
			"~LOCAL,~PDN",
			" LOCAL,~PDN",
			" LOCAL, PDN"
		};

		fprintf(OUT,
		    "\n%*sRound trip times, listed in ticks:\n", indent, " ");
		fprintf(OUT,
		    "\t%*s%11.11s  %12.12s | %12.12s | %s\n", indent, " ",
		    "Category",	"Smoothed avg", "Deviation", "Deviation/Avg");
		for (j = 0; j <= 3; j++) {
			fprintf(OUT,
			    "\t%*s%11.11s: %-11d | %-11d | %-11d | %-11d\n", indent, " ",
			    name[j], s->ts_rtt[j], s->ts_rtt[j],
			    s->ts_rtv[j], s->ts_rtv[j]);
		}
	}
	fprintf(OUT,
		"\n%*sTpdus RECVD [%ld valid, %3.6f %% of total (%ld); %ld dropped]\n",indent," ",
	    s->ts_tpdu_rcvd ,
	    ((s->ts_pkt_rcvd > 0) ?
	    ((100 * (float)s->ts_tpdu_rcvd)/(float)s->ts_pkt_rcvd) : 0),
	    s->ts_pkt_rcvd,
	    s->ts_recv_drop );

	fprintf(OUT,
	    "\t%*sDT  %6ld   AK  %6ld   DR  %4ld   CR  %4ld \n", indent,
	    " ", s->ts_DT_rcvd, s->ts_AK_rcvd, s->ts_DR_rcvd, s->ts_CR_rcvd);
	fprintf(OUT,
	    "\t%*sXPD %6ld   XAK %6ld   DC  %4ld   CC  %4ld   ER  %4ld\n",
	    indent, " ", s->ts_XPD_rcvd, s->ts_XAK_rcvd, s->ts_DC_rcvd,
	    s->ts_CC_rcvd, s->ts_ER_rcvd);
	fprintf(OUT,
	    "\n%*sTpdus SENT [%ld total, %ld dropped]\n",  indent, " ",
	    s->ts_tpdu_sent, s->ts_send_drop);

	fprintf(OUT,
	    "\t%*sDT  %6ld   AK  %6ld   DR  %4ld   CR  %4ld \n", indent,
	    " ", s->ts_DT_sent, s->ts_AK_sent, s->ts_DR_sent, s->ts_CR_sent);
	fprintf(OUT,
	    "\t%*sXPD %6ld   XAK %6ld   DC  %4ld   CC  %4ld   ER  %4ld\n",
	    indent, " ", s->ts_XPD_sent, s->ts_XAK_sent, s->ts_DC_sent,
	    s->ts_CC_sent, s->ts_ER_sent);

	fprintf(OUT,
	    "\n%*sRetransmissions:\n", indent, " ");
#define PERCENT(X,Y) (((Y)>0)?((100 *(float)(X)) / (float) (Y)):0)

	fprintf(OUT,
	    "\t%*sCR  %6ld   CC  %6ld   DR  %6ld \n", indent, " ",
	    s->ts_retrans_cr, s->ts_retrans_cc, s->ts_retrans_dr);
	fprintf(OUT,
	    "\t%*sDT  %6ld (%5.2f%%)\n", indent, " ",
	    s->ts_retrans_dt,
	    PERCENT(s->ts_retrans_dt, s->ts_DT_sent));
	fprintf(OUT,
	    "\t%*sXPD %6ld (%5.2f%%)\n",  indent, " ",
	    s->ts_retrans_xpd,
	    PERCENT(s->ts_retrans_xpd, s->ts_XPD_sent));

	fprintf(OUT,
	    "\n%*sE Timers: [%6ld ticks]\n", indent, " ", s->ts_Eticks);
	fprintf(OUT,
	    "%*s%6ld timer%s set \t%6ld timer%s expired \t%6ld timer%s cancelled\n",indent, " ",
	    s->ts_Eset ,plural(s->ts_Eset),
	    s->ts_Eexpired ,plural(s->ts_Eexpired),
	    s->ts_Ecan_act ,plural(s->ts_Ecan_act));

	fprintf(OUT,
	    "\n%*sC Timers: [%6ld ticks]\n",  indent, " ",s->ts_Cticks);
	fprintf(OUT,
	    "%*s%6ld timer%s set \t%6ld timer%s expired \t%6ld timer%s cancelled\n",
	    indent, " ",
	    s->ts_Cset ,plural(s->ts_Cset),
	    s->ts_Cexpired ,plural(s->ts_Cexpired),
	    s->ts_Ccan_act ,plural(s->ts_Ccan_act));
	fprintf(OUT,
	    "%*s%6ld inactive timer%s cancelled\n", indent, " ",
	    s->ts_Ccan_inact ,plural(s->ts_Ccan_inact));

	fprintf(OUT,
	    "\n%*sPathological debugging activity:\n", indent, " ");
	fprintf(OUT,
	    "\t%*s%6ld CC%s sent to zero dref\n", indent, " ",
	    s->ts_zdebug ,plural(s->ts_zdebug));
	/* SAME LINE AS ABOVE */
	fprintf(OUT,
	    "\t%*s%6ld random DT%s dropped\n", indent, " ",
	    s->ts_ydebug ,plural(s->ts_ydebug));
	fprintf(OUT,
	    "\t%*s%6ld illegally large XPD TPDU%s\n", indent, " ",
	    s->ts_vdebug ,plural(s->ts_vdebug));
	fprintf(OUT,
	    "\t%*s%6ld faked reneging of cdt\n", indent, " ",
	    s->ts_ldebug );

	fprintf(OUT,
	    "\n%*sACK reasons:\n", indent, " ");
	fprintf(OUT, "\t%*s%6ld not acked immediately\n", indent, " ",
	    s->ts_ackreason[_ACK_DONT_] );
	fprintf(OUT, "\t%*s%6ld strategy==each\n", indent, " ",
	    s->ts_ackreason[_ACK_STRAT_EACH_] );
	fprintf(OUT, "\t%*s%6ld strategy==fullwindow\n", indent, " ",
	    s->ts_ackreason[_ACK_STRAT_FULLWIN_] );
	fprintf(OUT, "\t%*s%6ld duplicate DT\n", indent, " ",
	    s->ts_ackreason[_ACK_DUP_] );
	fprintf(OUT, "\t%*s%6ld EOTSDU\n", indent, " ",
	    s->ts_ackreason[_ACK_EOT_] );
	fprintf(OUT, "\t%*s%6ld reordered DT\n", indent, " ",
	    s->ts_ackreason[_ACK_REORDER_] );
	fprintf(OUT, "\t%*s%6ld user rcvd\n", indent, " ",
	    s->ts_ackreason[_ACK_USRRCV_] );
	fprintf(OUT, "\t%*s%6ld fcc reqd\n", indent, " ",
	    s->ts_ackreason[_ACK_FCC_] );
}
#ifndef SSEL
#define SSEL(s) ((s)->siso_tlen + TSEL(s))
#define PSEL(s) ((s)->siso_slen + SSEL(s))
#endif

static void
isonetprint(struct sockaddr_iso *siso, int islocal)
{
	hexprint(siso->siso_nlen, siso->siso_addr.isoa_genaddr, "{}");
	if (siso->siso_tlen || siso->siso_slen || siso->siso_plen)
		hexprint(siso->siso_tlen, TSEL(siso), "()");
	if (siso->siso_slen || siso->siso_plen)
		hexprint(siso->siso_slen, SSEL(siso), "[]");
	if (siso->siso_plen)
		hexprint(siso->siso_plen, PSEL(siso), "<>");
	putchar(' ');
}

static char hexlist[] = "0123456789abcdef", obuf[128];

static void
hexprint(int n, char *buf, char *delim)
{
	u_char *in = (u_char *)buf, *top = in + n;
	char *out = obuf;
	int i;

	if (n == 0)
		return;
	while (in < top) {
		i = *in++;
		*out++ = '.';
		if (i > 0xf) {
			out[1] = hexlist[i & 0xf];
			i >>= 4;
			out[0] = hexlist[i];
			out += 2;
		} else
			*out++ = hexlist[i];
	}
	*obuf = *delim; *out++ = delim[1]; *out = 0;
	printf("%s", obuf);
}
@


1.15
log
@Fix some sizeof(ptr) bugs based on diffs from aaron@@.
Note that this is not code that actually gets compiled.
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.c,v 1.14 2004/03/13 22:02:13 deraadt Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: iso.c,v 1.14 2004/03/13 22:02:13 deraadt Exp $";
@


1.14
log
@some NULL vs 0 and knf; parts from nimadeus@@pandora.be
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.c,v 1.13 2003/06/26 21:59:11 deraadt Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: iso.c,v 1.13 2003/06/26 21:59:11 deraadt Exp $";
d420 1
a420 1
			bzero(cp, sizeof(line)-10);
@


1.13
log
@more proto fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.c,v 1.12 2003/06/03 02:56:13 millert Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: iso.c,v 1.12 2003/06/03 02:56:13 millert Exp $";
d322 2
a323 2
		     tpcb.tp_state == TP_CLOSED ||
		     tpcb.tp_state == TP_REFWAIT))
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.c,v 1.11 2003/02/01 01:51:31 deraadt Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: iso.c,v 1.11 2003/02/01 01:51:31 deraadt Exp $";
d522 1
a522 1
tp_stats(caddr_t off, char *name)
@


1.11
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.c,v 1.10 2002/05/27 01:50:36 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char *rcsid = "$OpenBSD: iso.c,v 1.10 2002/05/27 01:50:36 deraadt Exp $";
@


1.10
log
@a night of cleanup, so i can read this easier
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.c,v 1.9 2002/02/16 21:27:50 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: iso.c,v 1.9 2002/02/16 21:27:50 millert Exp $";
d123 1
a123 3
esis_stats(off, name)
	u_long	off;
	char	*name;
d150 1
a150 3
clnp_stats(off, name)
	u_long off;
	char *name;
d183 1
a183 3
cltp_stats(off, name)
	u_long off;
	char *name;
d217 1
a217 3
iso_protopr(off, name)
	u_long off;
	char *name;
d252 1
a252 3
iso_protopr1(kern_addr, istp)
	u_long kern_addr;
	int istp;
d277 2
a278 2
			hexprint(tpcb.tp_lsuffixlen, tpcb.tp_lsuffix, "()");
			printf("\t");
d280 1
a280 1
			printf("*.*\t");
d305 1
a305 3
tp_protopr(off, name)
	u_long off;
	char *name;
d349 1
a349 2
tp_inproto(pcb)
	u_long pcb;
d371 1
a371 2
isonetname(iso)
	struct iso_addr *iso;
d402 1
a402 5
isonetprint(iso, sufx, sufxlen, islocal)
	struct iso_addr *iso;
	char *sufx;
	u_short	sufxlen;
	int islocal;
a441 3
	/*
	fprintf(stdout, Aflag?" %-18.18s":" %-22.22s", line);
	*/
d454 1
a454 3
x25_protopr(off, name)
	u_long off;
	char *name;
d526 1
a526 2
tp_stats(off, name)
	caddr_t off, name;
d540 1
a540 3
tprintstat(s, indent)
	struct tp_stat *s;
	int indent;
d783 1
a783 3
isonetprint(siso, islocal)
	struct sockaddr_iso *siso;
	int islocal;
d798 1
a798 3
hexprint(n, buf, delim)
	int n;
	char *buf, *delim;
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.c,v 1.8 2001/11/19 19:02:15 mpech Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: iso.c,v 1.8 2001/11/19 19:02:15 mpech Exp $";
d134 1
a134 1
		esis_stat.es_eshrcvd);
d136 1
a136 1
		esis_stat.es_ishrcvd);
d138 1
a138 1
		esis_stat.es_rdrcvd);
d140 1
a140 1
		esis_stat.es_nomem);
d143 1
a143 1
		esis_stat.es_badvers);
d166 1
a166 1
		clnp_stat.cns_toosmall);
d169 1
a169 1
		clnp_stat.cns_badcsum, plural(clnp_stat.cns_badcsum));
d172 1
a172 1
		clnp_stat.cns_noseg);
d176 1
a176 1
		clnp_stat.cns_ttlexpired);
d179 1
a179 1
		clnp_stat.cns_congest_set);
d181 1
a181 1
		clnp_stat.cns_congest_rcvd);
d197 1
a197 1
		cltpstat.cltps_hdrops, plural(cltpstat.cltps_hdrops));
d199 1
a199 1
		cltpstat.cltps_badlen, plural(cltpstat.cltps_badlen));
d201 1
a201 1
		cltpstat.cltps_badsum, plural(cltpstat.cltps_badsum));
d249 1
a249 1
				prev, next, isopcb.isop_prev, isopcb.isop_next);
d292 6
a297 6
			if ((char *)isopcb.isop_laddr == ((char *)kern_addr) +
					_offsetof(struct isopcb, isop_sladdr))
					laddr.siso = isopcb.isop_sladdr;
			else
					kget(isopcb.isop_laddr, laddr);
			isonetprint((struct sockaddr_iso *)&laddr, 1);
d300 2
a301 2
			hexprint(tpcb.tp_fsuffixlen, tpcb.tp_fsuffix, "()");
			printf("\t");
d306 1
a306 1
			_offsetof(struct isopcb, isop_sfaddr))
d337 3
a339 3
			(tpcb.tp_state == TP_LISTENING ||
			 tpcb.tp_state == TP_CLOSED ||
			 tpcb.tp_state == TP_REFWAIT)) {
a340 1
		}
d342 2
a343 1
		if (tpcb.tp_npcb) switch(tpcb.tp_netservice) {
d365 1
d395 1
a395 1
	if( iso->isoa_afi ) {
d400 1
a400 1
		if (!nflag )
d402 1
a402 1
		if( ihe ) {
d427 1
a427 1
	line =  isonetname(iso);
d431 1
a431 1
	if( islocal )
d436 1
a436 1
	if(Aflag)
d439 2
a440 2
	if(!nflag) {
		if( (cp -line)>10 ) {
d447 2
a448 2
	if(sufxlen) {
		if( !Aflag && !nflag && (ihe=iso_getserventrybytsel(sufx, sufxlen))) {
d452 1
a452 1
		if( ihe && (strlen(ihe->isoh_aname)>0) ) {
d455 1
a455 1
		} else  {
d464 1
a464 1
	if( strlen(line) > Alen ) {
d531 1
a531 1
			sockb.so_snd.sb_cc);
d533 1
a533 1
			sizeof(xpcb.x_lport), 1);
d535 1
a535 1
			sizeof(xpcb.x_lport), 0);
d569 4
a572 1
		"%*sReceiving:\n",indent," ");
d574 2
a575 2
		"\t%*s%ld variable parameter%s ignored\n", indent," ",
		s->ts_param_ignored ,plural(s->ts_param_ignored));
d577 2
a578 2
		"\t%*s%ld invalid parameter code%s\n", indent, " ",
		s->ts_inv_pcode ,plural(s->ts_inv_pcode));
d580 2
a581 2
		"\t%*s%ld invalid parameter value%s\n", indent, " ",
		s->ts_inv_pval ,plural(s->ts_inv_pval));
d583 2
a584 2
		"\t%*s%ld invalid dutype%s\n", indent, " ",
		s->ts_inv_dutype ,plural(s->ts_inv_dutype));
d586 2
a587 2
		"\t%*s%ld negotiation failure%s\n", indent, " ",
		s->ts_negotfailed ,plural(s->ts_negotfailed));
d589 2
a590 2
		"\t%*s%ld invalid destination reference%s\n", indent, " ",
		s->ts_inv_dref ,plural(s->ts_inv_dref));
d592 1
a592 2
		"\t%*s%ld invalid suffix parameter%s\n", indent, " ",
		s->ts_inv_sufx ,plural(s->ts_inv_sufx));
d594 2
a595 1
		"\t%*s%ld invalid length\n",indent, " ", s->ts_inv_length);
d597 2
a598 2
		"\t%*s%ld invalid checksum%s\n", indent, " ",
		s->ts_bad_csum ,plural(s->ts_bad_csum));
d600 2
a601 2
		"\t%*s%ld DT%s out of order\n", indent, " ",
		s->ts_dt_ooo ,plural(s->ts_dt_ooo));
d603 2
a604 2
		"\t%*s%ld DT%s not in window\n", indent, " ",
		s->ts_dt_niw ,plural(s->ts_dt_niw));
d606 2
a607 2
		"\t%*s%ld duplicate DT%s\n", indent, " ",
		s->ts_dt_dup ,plural(s->ts_dt_dup));
d609 2
a610 5
			"\t%*s%ld XPD%s not in window\n", indent, " ",
			s->ts_xpd_niw ,plural(s->ts_xpd_niw));
		fprintf(OUT,
			"\t%*s%ld XPD%s w/o credit to stash\n", indent, " ",
		s->ts_xpd_dup ,plural(s->ts_xpd_dup));
d612 2
a613 2
		"\t%*s%ld time%s local credit reneged\n", indent, " ",
		s->ts_lcdt_reduced ,plural(s->ts_lcdt_reduced));
d615 2
a616 2
		"\t%*s%ld concatenated TPDU%s\n", indent, " ",
		s->ts_concat_rcvd ,plural(s->ts_concat_rcvd));
d618 1
a618 1
		"%*sSending:\n", indent, " ");
d620 2
a621 2
		"\t%*s%ld XPD mark%s discarded\n", indent, " ",
		s->ts_xpdmark_del ,plural(s->ts_xpdmark_del));
d623 2
a624 2
		"\t%*sXPD stopped data flow %ld time%s\n", indent, " ",
		s->ts_xpd_intheway ,plural(s->ts_xpd_intheway));
d626 2
a627 2
		"\t%*s%ld time%s foreign window closed\n", indent, " ",
		s->ts_zfcdt ,plural(s->ts_zfcdt));
d629 1
a629 1
		"%*sMiscellaneous:\n", indent, " ");
d631 2
a632 2
		"\t%*s%ld small mbuf%s\n", indent, " ",
		s->ts_mb_small ,plural(s->ts_mb_small));
d634 2
a635 2
		"\t%*s%ld cluster%s\n", indent, " ",
		s->ts_mb_cluster, plural(s->ts_mb_cluster));
d637 2
a638 2
		"\t%*s%ld source quench \n",indent, " ",
		s->ts_quench);
d640 2
a641 2
		"\t%*s%ld dec bit%s\n", indent, " ",
		s->ts_rcvdecbit, plural(s->ts_rcvdecbit));
d643 1
a643 1
		"\t%*sM:L ( M mbuf chains of length L)\n", indent, " ");
d649 1
a649 1
		for( j=1; j<=8; j++) {
d651 3
a653 4
				"\t%*s%ld: %d\t\t%ld: %d\n", indent, " ",
				s->ts_mb_len_distr[j],j,
				s->ts_mb_len_distr[j<<1],j<<1
				);
d657 1
a657 1
		"\t%*s%ld EOT rcvd\n",  indent, " ", s->ts_eot_input);
d659 1
a659 1
		"\t%*s%ld EOT sent\n",  indent, " ", s->ts_EOT_sent);
d661 2
a662 2
		"\t%*s%ld EOT indication%s\n",  indent, " ",
		s->ts_eot_user ,plural(s->ts_eot_user));
d665 1
a665 1
		"%*sConnections:\n", indent, " ");
d667 2
a668 2
		"\t%*s%ld connection%s used extended format\n",  indent, " ",
		s->ts_xtd_fmt ,plural(s->ts_xtd_fmt));
d670 2
a671 2
		"\t%*s%ld connection%s allowed transport expedited data\n",  indent, " ",
		s->ts_use_txpd ,plural(s->ts_use_txpd));
d673 2
a674 2
		"\t%*s%ld connection%s turned off checksumming\n",  indent, " ",
		s->ts_csum_off ,plural(s->ts_csum_off));
d676 2
a677 2
		"\t%*s%ld connection%s dropped due to retrans limit\n",  indent, " ",
		s->ts_conn_gaveup ,plural(s->ts_conn_gaveup));
d679 2
a680 2
		"\t%*s%ld tp 4 connection%s\n",  indent, " ",
		s->ts_tp4_conn ,plural(s->ts_tp4_conn));
d682 3
a684 3
		"\t%*s%ld tp 0 connection%s\n",  indent, " ",
		s->ts_tp0_conn ,plural(s->ts_tp0_conn));
    {
d694 1
a694 1
			"\n%*sRound trip times, listed in ticks:\n", indent, " ");
d696 2
a697 3
			"\t%*s%11.11s  %12.12s | %12.12s | %s\n", indent, " ",
				"Category",
				"Smoothed avg", "Deviation", "Deviation/Avg");
d700 3
a702 6
				"\t%*s%11.11s: %-11d | %-11d | %-11d | %-11d\n", indent, " ",
				name[j],
				s->ts_rtt[j],
				s->ts_rtt[j],
				s->ts_rtv[j],
				s->ts_rtv[j]);
d706 6
a711 7
"\n%*sTpdus RECVD [%ld valid, %3.6f %% of total (%ld); %ld dropped]\n",indent," ",
		s->ts_tpdu_rcvd ,
		((s->ts_pkt_rcvd > 0) ?
			((100 * (float)s->ts_tpdu_rcvd)/(float)s->ts_pkt_rcvd)
			: 0),
		s->ts_pkt_rcvd,
		s->ts_recv_drop );
d714 2
a715 2
		"\t%*sDT  %6ld   AK  %6ld   DR  %4ld   CR  %4ld \n", indent,
		" ", s->ts_DT_rcvd, s->ts_AK_rcvd, s->ts_DR_rcvd, s->ts_CR_rcvd);
d717 3
a719 3
		"\t%*sXPD %6ld   XAK %6ld   DC  %4ld   CC  %4ld   ER  %4ld\n",
		indent, " ", s->ts_XPD_rcvd, s->ts_XAK_rcvd, s->ts_DC_rcvd,
		s->ts_CC_rcvd, s->ts_ER_rcvd);
d721 2
a722 2
		"\n%*sTpdus SENT [%ld total, %ld dropped]\n",  indent, " ",
		s->ts_tpdu_sent, s->ts_send_drop);
d725 2
a726 2
		"\t%*sDT  %6ld   AK  %6ld   DR  %4ld   CR  %4ld \n", indent,
		" ", s->ts_DT_sent, s->ts_AK_sent, s->ts_DR_sent, s->ts_CR_sent);
d728 3
a730 3
		"\t%*sXPD %6ld   XAK %6ld   DC  %4ld   CC  %4ld   ER  %4ld\n",
		indent, " ", s->ts_XPD_sent, s->ts_XAK_sent, s->ts_DC_sent,
		s->ts_CC_sent, s->ts_ER_sent);
d733 1
a733 1
		"\n%*sRetransmissions:\n", indent, " ");
d737 2
a738 2
	"\t%*sCR  %6ld   CC  %6ld   DR  %6ld \n", indent, " ",
		s->ts_retrans_cr, s->ts_retrans_cc, s->ts_retrans_dr);
d740 3
a742 3
	"\t%*sDT  %6ld (%5.2f%%)\n", indent, " ",
		s->ts_retrans_dt,
		PERCENT(s->ts_retrans_dt, s->ts_DT_sent));
d744 3
a746 4
	"\t%*sXPD %6ld (%5.2f%%)\n",  indent, " ",
		s->ts_retrans_xpd,
		PERCENT(s->ts_retrans_xpd, s->ts_XPD_sent));

d749 1
a749 1
		"\n%*sE Timers: [%6ld ticks]\n", indent, " ", s->ts_Eticks);
d751 4
a754 4
		"%*s%6ld timer%s set \t%6ld timer%s expired \t%6ld timer%s cancelled\n",indent, " ",
		s->ts_Eset ,plural(s->ts_Eset),
		s->ts_Eexpired ,plural(s->ts_Eexpired),
		s->ts_Ecan_act ,plural(s->ts_Ecan_act));
d757 1
a757 1
		"\n%*sC Timers: [%6ld ticks]\n",  indent, " ",s->ts_Cticks);
d759 5
a763 5
	"%*s%6ld timer%s set \t%6ld timer%s expired \t%6ld timer%s cancelled\n",
		indent, " ",
		s->ts_Cset ,plural(s->ts_Cset),
		s->ts_Cexpired ,plural(s->ts_Cexpired),
		s->ts_Ccan_act ,plural(s->ts_Ccan_act));
d765 2
a766 2
		"%*s%6ld inactive timer%s cancelled\n", indent, " ",
		s->ts_Ccan_inact ,plural(s->ts_Ccan_inact));
d769 1
a769 1
		"\n%*sPathological debugging activity:\n", indent, " ");
d771 2
a772 2
		"\t%*s%6ld CC%s sent to zero dref\n", indent, " ",
		s->ts_zdebug ,plural(s->ts_zdebug));
d775 2
a776 2
		"\t%*s%6ld random DT%s dropped\n", indent, " ",
		s->ts_ydebug ,plural(s->ts_ydebug));
d778 2
a779 2
		"\t%*s%6ld illegally large XPD TPDU%s\n", indent, " ",
		s->ts_vdebug ,plural(s->ts_vdebug));
d781 2
a782 2
		"\t%*s%6ld faked reneging of cdt\n", indent, " ",
		s->ts_ldebug );
d785 1
a785 1
		"\n%*sACK reasons:\n", indent, " ");
d787 1
a787 1
		s->ts_ackreason[_ACK_DONT_] );
d789 1
a789 1
		s->ts_ackreason[_ACK_STRAT_EACH_] );
d791 1
a791 1
		s->ts_ackreason[_ACK_STRAT_FULLWIN_] );
d793 1
a793 1
		s->ts_ackreason[_ACK_DUP_] );
d795 1
a795 1
		s->ts_ackreason[_ACK_EOT_] );
d797 1
a797 1
		s->ts_ackreason[_ACK_REORDER_] );
d799 1
a799 1
		s->ts_ackreason[_ACK_USRRCV_] );
d801 1
a801 1
		s->ts_ackreason[_ACK_FCC_] );
@


1.8
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.c,v 1.7 1998/02/27 12:07:36 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: iso.c,v 1.7 1998/02/27 12:07:36 deraadt Exp $";
d114 4
a117 4
static void tprintstat __P((struct tp_stat *, int));
static void isonetprint __P((struct sockaddr_iso *, int));
static void hexprint __P((int, char *, char *));
extern void inetprint __P((struct in_addr *, int, char *));
@


1.7
log
@oflow paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.c,v 1.6 1997/06/29 21:46:02 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: iso.c,v 1.6 1997/06/29 21:46:02 millert Exp $";
d228 1
a228 1
	register struct isopcb *prev, *next;
d384 1
a384 1
	register struct iso_addr *iso;
d416 1
a416 1
	register struct iso_addr *iso;
d486 1
a486 1
	register struct isopcb *prev, *next;
d564 1
a564 1
	register struct tp_stat *s;
d644 1
a644 1
		register int j;
d685 1
a685 1
		register int j;
d816 1
a816 1
	register struct sockaddr_iso *siso;
d836 3
a838 3
	register u_char *in = (u_char *)buf, *top = in + n;
	register char *out = obuf;
	register int i;
@


1.6
log
@Use correct spacing on both 32bit and 64bit machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.c,v 1.5 1997/06/29 20:52:41 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: iso.c,v 1.5 1997/06/29 20:52:41 millert Exp $";
d404 1
a404 1
			sprintf(line, "%s", ihe->isoh_hname);
d406 1
a406 1
			sprintf(line, "%s", iso_ntoa(iso));
d409 1
a409 1
		sprintf(line, "*");
d452 2
a453 1
			sprintf(cp, "%s", ihe->isoh_aname);
d458 1
a458 1
		sprintf(cp, "*");
@


1.5
log
@Make fields line up nicely for 64-bit addresses.  Should probably #if
some things based on sizeof(long).
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.c,v 1.4 1997/06/29 20:18:00 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: iso.c,v 1.4 1997/06/29 20:18:00 millert Exp $";
d107 1
d270 9
a278 6
			printf("%-18.18s ", "PCB");
		printf(Aflag ?
			"%-5.5s %-6.6s %-6.6s  %-18.18s %-18.18s %s\n" :
			"%-5.5s %-6.6s %-6.6s  %-22.22s %-22.22s %s\n",
			"Proto", "Recv-Q", "Send-Q",
			"Local Address", "Foreign Address", "(state)");
d282 2
a283 2
			printf("%18p ",
					(sockb.so_pcb ? (void *)sockb.so_pcb : (void *)kern_addr));
d517 9
a525 6
				printf("%-8.8s ", "PCB");
			printf(Aflag ?
				"%-5.5s %-6.6s %-6.6s  %-18.18s %-18.18s %s\n" :
				"%-5.5s %-6.6s %-6.6s  %-22.22s %-22.22s %s\n",
				"Proto", "Recv-Q", "Send-Q",
				"Local Address", "Foreign Address", "(state)");
@


1.4
log
@Mostly clean -Wall + 64bit issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.c,v 1.3 1997/01/17 07:12:58 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: iso.c,v 1.3 1997/01/17 07:12:58 millert Exp $";
d247 1
a247 1
			printf("prev 0x%p next 0x%p isop_prev 0x%p isop_next 0x%p???\n",
d269 1
a269 1
			printf("%-8.8s ", "PCB");
d278 1
a278 1
			printf("%8p ",
d331 1
a331 1
			printf("undefined tpcb state: 0x%p\n", tpr->tpr_pcb);
@


1.3
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.c,v 1.2 1996/06/26 05:37:21 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: iso.c,v 1.2 1996/06/26 05:37:21 deraadt Exp $";
d247 1
a247 1
			printf("prev 0x%x next 0x%x isop_prev 0x%x isop_next 0x%x???\n",
d278 1
a278 1
			printf("%8x ",
d280 2
a281 1
	printf("%-5.5s %6d %6d ", "tp", sockb.so_rcv.sb_cc, sockb.so_snd.sb_cc);
d331 1
a331 1
			printf("undefined tpcb state: 0x%x\n", tpr->tpr_pcb);
d365 2
a366 2
		printf("%8x ", pcb);
	printf("%-5.5s %6d %6d ", "tpip",
d562 1
a562 1
		"\t%*s%d variable parameter%s ignored\n", indent," ",
d565 1
a565 1
		"\t%*s%d invalid parameter code%s\n", indent, " ",
d568 1
a568 1
		"\t%*s%d invalid parameter value%s\n", indent, " ",
d571 1
a571 1
		"\t%*s%d invalid dutype%s\n", indent, " ",
d574 1
a574 1
		"\t%*s%d negotiation failure%s\n", indent, " ",
d577 1
a577 1
		"\t%*s%d invalid destination reference%s\n", indent, " ",
d580 1
a580 1
		"\t%*s%d invalid suffix parameter%s\n", indent, " ",
d583 1
a583 1
		"\t%*s%d invalid length\n",indent, " ", s->ts_inv_length);
d585 1
a585 1
		"\t%*s%d invalid checksum%s\n", indent, " ",
d588 1
a588 1
		"\t%*s%d DT%s out of order\n", indent, " ",
d591 1
a591 1
		"\t%*s%d DT%s not in window\n", indent, " ",
d594 1
a594 1
		"\t%*s%d duplicate DT%s\n", indent, " ",
d597 1
a597 1
			"\t%*s%d XPD%s not in window\n", indent, " ",
d600 1
a600 1
			"\t%*s%d XPD%s w/o credit to stash\n", indent, " ",
d603 1
a603 1
		"\t%*s%d time%s local credit reneged\n", indent, " ",
d606 1
a606 1
		"\t%*s%d concatenated TPDU%s\n", indent, " ",
d611 1
a611 1
		"\t%*s%d XPD mark%s discarded\n", indent, " ",
d614 1
a614 1
		"\t%*sXPD stopped data flow %d time%s\n", indent, " ",
d617 1
a617 1
		"\t%*s%d time%s foreign window closed\n", indent, " ",
d622 1
a622 1
		"\t%*s%d small mbuf%s\n", indent, " ",
d625 1
a625 1
		"\t%*s%d cluster%s\n", indent, " ",
d628 1
a628 1
		"\t%*s%d source quench \n",indent, " ",
d631 1
a631 1
		"\t%*s%d dec bit%s\n", indent, " ",
d638 1
a638 1
		fprintf(OUT, "\t%*s%d: over 16\n", indent, " ",
d642 1
a642 1
				"\t%*s%d: %d\t\t%d: %d\n", indent, " ",
d649 1
a649 1
		"\t%*s%d EOT rcvd\n",  indent, " ", s->ts_eot_input);
d651 1
a651 1
		"\t%*s%d EOT sent\n",  indent, " ", s->ts_EOT_sent);
d653 1
a653 1
		"\t%*s%d EOT indication%s\n",  indent, " ",
d659 1
a659 1
		"\t%*s%d connection%s used extended format\n",  indent, " ",
d662 1
a662 1
		"\t%*s%d connection%s allowed transport expedited data\n",  indent, " ",
d665 1
a665 1
		"\t%*s%d connection%s turned off checksumming\n",  indent, " ",
d668 1
a668 1
		"\t%*s%d connection%s dropped due to retrans limit\n",  indent, " ",
d671 1
a671 1
		"\t%*s%d tp 4 connection%s\n",  indent, " ",
d674 1
a674 1
		"\t%*s%d tp 0 connection%s\n",  indent, " ",
d702 1
a702 1
"\n%*sTpdus RECVD [%d valid, %3.6f %% of total (%d); %d dropped]\n",indent," ",
d711 2
a712 2
		"\t%*sDT  %6d   AK  %6d   DR  %4d   CR  %4d \n", indent, " ",
		s->ts_DT_rcvd, s->ts_AK_rcvd, s->ts_DR_rcvd, s->ts_CR_rcvd);
d714 3
a716 3
		"\t%*sXPD %6d   XAK %6d   DC  %4d   CC  %4d   ER  %4d\n",  indent, " ",
		s->ts_XPD_rcvd, s->ts_XAK_rcvd, s->ts_DC_rcvd, s->ts_CC_rcvd,
		s->ts_ER_rcvd);
d718 1
a718 1
		"\n%*sTpdus SENT [%d total, %d dropped]\n",  indent, " ",
d722 2
a723 2
		"\t%*sDT  %6d   AK  %6d   DR  %4d   CR  %4d \n", indent, " ",
		s->ts_DT_sent, s->ts_AK_sent, s->ts_DR_sent, s->ts_CR_sent);
d725 3
a727 3
		"\t%*sXPD %6d   XAK %6d   DC  %4d   CC  %4d   ER  %4d\n",  indent, " ",
		s->ts_XPD_sent, s->ts_XAK_sent, s->ts_DC_sent, s->ts_CC_sent,
		s->ts_ER_sent);
d734 1
a734 1
	"\t%*sCR  %6d   CC  %6d   DR  %6d \n", indent, " ",
d737 1
a737 1
	"\t%*sDT  %6d (%5.2f%%)\n", indent, " ",
d741 1
a741 1
	"\t%*sXPD %6d (%5.2f%%)\n",  indent, " ",
d747 1
a747 1
		"\n%*sE Timers: [%6d ticks]\n", indent, " ", s->ts_Eticks);
d749 1
a749 1
		"%*s%6d timer%s set \t%6d timer%s expired \t%6d timer%s cancelled\n",indent, " ",
d755 1
a755 1
		"\n%*sC Timers: [%6d ticks]\n",  indent, " ",s->ts_Cticks);
d757 1
a757 1
	"%*s%6d timer%s set \t%6d timer%s expired \t%6d timer%s cancelled\n",
d763 1
a763 1
		"%*s%6d inactive timer%s cancelled\n", indent, " ",
d769 1
a769 1
		"\t%*s%6d CC%s sent to zero dref\n", indent, " ",
d773 1
a773 1
		"\t%*s%6d random DT%s dropped\n", indent, " ",
d776 1
a776 1
		"\t%*s%6d illegally large XPD TPDU%s\n", indent, " ",
d779 1
a779 1
		"\t%*s%6d faked reneging of cdt\n", indent, " ",
d784 1
a784 1
	fprintf(OUT, "\t%*s%6d not acked immediately\n", indent, " ",
d786 1
a786 1
	fprintf(OUT, "\t%*s%6d strategy==each\n", indent, " ",
d788 1
a788 1
	fprintf(OUT, "\t%*s%6d strategy==fullwindow\n", indent, " ",
d790 1
a790 1
	fprintf(OUT, "\t%*s%6d duplicate DT\n", indent, " ",
d792 1
a792 1
	fprintf(OUT, "\t%*s%6d EOTSDU\n", indent, " ",
d794 1
a794 1
	fprintf(OUT, "\t%*s%6d reordered DT\n", indent, " ",
d796 1
a796 1
	fprintf(OUT, "\t%*s%6d user rcvd\n", indent, " ",
d798 1
a798 1
	fprintf(OUT, "\t%*s%6d fcc reqd\n", indent, " ",
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.c,v 1.12 1995/10/03 21:42:38 thorpej Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: iso.c,v 1.12 1995/10/03 21:42:38 thorpej Exp $";
d422 1
a422 1
	cp = index(line, '\0');
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char *rcsid = "$NetBSD: iso.c,v 1.12 1995/10/03 21:42:38 thorpej Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

