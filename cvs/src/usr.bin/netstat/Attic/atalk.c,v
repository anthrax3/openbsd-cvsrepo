head	1.21;
access;
symbols
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.17.0.4
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.14.0.10
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.8
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.6
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.4
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.0.4
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.21
date	2011.07.09.00.45.40;	author henning;	state dead;
branches;
next	1.20;

1.20
date	2010.10.30.23.06.05;	author bluhm;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.29.03.09.29;	author blambert;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.23.10.12.42;	author chl;	state Exp;
branches;
next	1.17;

1.17
date	2009.02.07.15.06.04;	author chl;	state Exp;
branches;
next	1.16;

1.16
date	2007.12.19.01.47.00;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.12.14.18.35.46;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.30.06.45.34;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.25.17.01.03;	author jaredy;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.13.22.02.13;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.03.02.56.13;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.01.01.51.31;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.25.03.58.56;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.27.01.50.36;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.50;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.17.21.34.58;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.18.22.14.03;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.01.58.13;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.06.23.22.40.39;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.07.23.16.07.56;	author denny;	state Exp;
branches;
next	;


desc
@@


1.21
log
@rmove rotten netatalk bits
@
text
@/*	$OpenBSD: atalk.c,v 1.20 2010/10/30 23:06:05 bluhm Exp $	*/
/*	$NetBSD: atalk.c,v 1.2 1997/05/22 17:21:26 christos Exp $	*/

/*
 * Copyright (c) 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/sysctl.h>
#include <netdb.h>

#include <net/route.h>
#include <net/if.h>

/* #include <netinet/tcp_fsm.h> */

#include <netatalk/at.h>
#include <netatalk/ddp_var.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include "netstat.h"

struct ddpcb    ddpcb;
struct socket   sockb;

static int first = 1;

static char *at_pr_net(struct sockaddr_at *, int);
static char *at_pr_host(struct sockaddr_at *, int);
static char *at_pr_range(struct sockaddr_at *);
static char *at_pr_port(struct sockaddr_at *);

/*
 * Print a summary of connections related to a Network Systems
 * protocol.  For XXX, also give state of connection.
 * Listening processes (aflag) are suppressed unless the
 * -a (all) flag is specified.
 */

static char *
at_pr_net(struct sockaddr_at *sat, int numeric)
{
	static char mybuf[50];

	if (!numeric) {
		switch (sat->sat_addr.s_net) {
		case 0xffff:
			return "????";
		case ATADDR_ANYNET:
			return ("*");
		}
	}
	(void) snprintf(mybuf, sizeof(mybuf), "%hu",
	    ntohs(sat->sat_addr.s_net));
	return mybuf;
}

static char *
at_pr_host(struct sockaddr_at *sat, int numeric)
{
	static char mybuf[50];

	if (!numeric) {
		switch (sat->sat_addr.s_node) {
		case ATADDR_BCAST:
			return "bcast";
		case ATADDR_ANYNODE:
			return ("*");
		}
	}
	(void) snprintf(mybuf, sizeof(mybuf), "%d",
	    (unsigned int) sat->sat_addr.s_node);
	return mybuf;
}

static char *
at_pr_port(struct sockaddr_at *sat)
{
	static char mybuf[50];
	struct servent *serv;

	switch (sat->sat_port) {
	case ATADDR_ANYPORT:
		return ("*");
	case 0xff:
		return "????";
	default:
		if (nflag)
			(void) snprintf(mybuf, sizeof(mybuf), "%d",
			    (unsigned int) sat->sat_port);
		else {
			serv = getservbyport(sat->sat_port, "ddp");
			if (serv == NULL)
				(void) snprintf(mybuf, sizeof(mybuf), "%d",
				    (unsigned int) sat->sat_port);
			else
				(void) snprintf(mybuf, sizeof(mybuf), "%s",
				    serv->s_name);
		}

		return mybuf;
	}
}

static char *
at_pr_range(struct sockaddr_at *sat)
{
	static char mybuf[50];

	if (sat->sat_range.r_netrange.nr_firstnet !=
	    sat->sat_range.r_netrange.nr_lastnet) {
		(void) snprintf(mybuf, sizeof(mybuf), "%d-%d",
		    ntohs(sat->sat_range.r_netrange.nr_firstnet),
		    ntohs(sat->sat_range.r_netrange.nr_lastnet));
	} else {
		(void) snprintf(mybuf, sizeof(mybuf), "%d",
		    ntohs(sat->sat_range.r_netrange.nr_firstnet));
	}
	return mybuf;
}


/* what == 0 for addr only == 3
 *	1 for net
 *	2 for host
 *	4 for port
 *	8 for numeric only
 */
char *
atalk_print(const struct sockaddr *sa, int what)
{
	struct sockaddr_at *sat = (struct sockaddr_at *) sa;
	static char mybuf[50];
	int numeric = (what & 0x08);

	mybuf[0] = 0;
	switch (what & 0x13) {
	case 0:
		mybuf[0] = 0;
		break;
	case 1:
		(void) snprintf(mybuf, sizeof(mybuf), "%s",
		    at_pr_net(sat, numeric));
		break;
	case 2:
		(void) snprintf(mybuf, sizeof(mybuf), "%s",
		    at_pr_host(sat, numeric));
		break;
	case 3:
		(void) snprintf(mybuf, sizeof(mybuf), "%s.%s",
		    at_pr_net(sat, numeric),
		    at_pr_host(sat, numeric));
		break;
	case 0x10:
		(void) snprintf(mybuf, sizeof(mybuf), "%s", at_pr_range(sat));
	}
	if (what & 4) {
		(void) snprintf(mybuf + strlen(mybuf),
		    sizeof(mybuf) - strlen(mybuf), ".%s",
		    at_pr_port(sat));
	}
	return mybuf;
}

void
atalkprotopr(u_long off, char *name, int af, u_long pcbaddr)
{
	struct ddpcb    cb;
	struct ddpcb *prev, *next;
	struct ddpcb   *initial;

	if (off == 0)
		return;
	if (kread(off, &initial, sizeof(struct ddpcb *)) < 0)
		return;
	ddpcb = cb;
	prev = (struct ddpcb *) off;
	for (next = initial; next != NULL; prev = next) {
		u_long	ppcb = (u_long) next;

		if (kread((u_long) next, &ddpcb, sizeof(ddpcb)) < 0)
			return;
		next = ddpcb.ddp_next;
		if (Pflag) {
			if (pcbaddr == ppcb)
				socket_dump((u_long)ddpcb.ddp_socket);
			continue;
		}
#if 0
		if (!aflag && atalk_nullhost(ddpcb.ddp_lsat)) {
			continue;
		}
#endif
		if (kread((u_long) ddpcb.ddp_socket, &sockb,
		    sizeof(sockb)) < 0)
			return;
		if (first) {
			printf("Active ATALK connections");
			if (aflag)
				printf(" (including servers)");
			putchar('\n');
			if (Aflag)
				printf("%-8.8s ", "PCB");
			printf(Aflag ?
			    "%-5.5s %-6.6s %-6.6s  %-18.18s %-18.18s %s\n" :
			    "%-5.5s %-6.6s %-6.6s  %-22.22s %-22.22s %s\n",
			    "Proto", "Recv-Q", "Send-Q",
			    "Local Address", "Foreign Address", "(state)");
			first = 0;
		}
		if (Aflag)
			printf("%8lx ", ppcb);
		printf("%-5.5s %6ld %6ld ", name, sockb.so_rcv.sb_cc,
		    sockb.so_snd.sb_cc);
		printf(Aflag ? " %-18.18s" : " %-22.22s", atalk_print(
		    (struct sockaddr *) & ddpcb.ddp_lsat, 7));
		printf(Aflag ? " %-18.18s" : " %-22.22s", atalk_print(
		    (struct sockaddr *) & ddpcb.ddp_fsat, 7));
		putchar('\n');
	}
}

#define p(f, m) if (ddpstat.f || sflag <= 1) \
	printf(m, ddpstat.f, plural(ddpstat.f))
#define p2(f1, f2, m) if (ddpstat.f1 || ddpstat.f2 || sflag <= 1) \
	printf(m, ddpstat.f1, plural(ddpstat.f1), ddpstat.f2, plural(ddpstat.f2))
#define p3(f, m) if (ddpstat.f || sflag <= 1) \
	printf(m, ddpstat.f, plurales(ddpstat.f))

/*
 * Dump DDP statistics structure.
 */
void
ddp_stats(char *name)
{
	struct ddpstat  ddpstat;
	int mib[] = { CTL_NET, AF_APPLETALK, ATPROTO_DDP, DDPCTL_STATS };
	size_t len = sizeof(ddpstat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ddpstat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn(name);
		return;
	}

	printf("%s:\n", name);
	p(ddps_short, "\t%ld packet%s with short headers\n");
	p(ddps_long, "\t%ld packet%s with long headers\n");
	p(ddps_nosum, "\t%ld packet%s with no checksum\n");
	p(ddps_tooshort, "\t%ld packet%s were too short\n");
	p(ddps_badsum, "\t%ld packet%s with bad checksum\n");
	p(ddps_toosmall, "\t%ld packet%s with not enough data\n");
	p(ddps_forward, "\t%ld packet%s forwarded\n");
	p(ddps_cantforward, "\t%ld packet%s rcvd for unreachable dest\n");
	p(ddps_nosockspace, "\t%ld packet%s dropped due to no socket space\n");
}
@


1.20
log
@Print socket structure internals when netstat -P pcbaddr is called
with -v.  Also netstat -P supports more than TCP now.
ok markus@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.19 2010/06/29 03:09:29 blambert Exp $	*/
@


1.19
log
@Allow selecting both address family and protocol by passing the address family
directly to the appropriate print functions.

Found by jdixon@@, tested jdixon@@ and weerd@@, ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.18 2010/05/23 10:12:42 chl Exp $	*/
d199 1
a199 1
atalkprotopr(u_long off, char *name, int af)
d217 5
@


1.18
log
@remove unused function

from tobias@@ (loooooong time ago)

ok henning@@ claudio@@ tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.17 2009/02/07 15:06:04 chl Exp $	*/
d199 1
a199 1
atalkprotopr(u_long off, char *name)
@


1.17
log
@add missing headers needed for warn() and err().

ok claudio@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.16 2007/12/19 01:47:00 deraadt Exp $	*/
a195 40
}

char *
atalk_print2(const struct sockaddr *sa, const struct sockaddr *mask, int what)
{
	size_t		n, l;
	static char	buf[100];
	struct sockaddr_at *sat1, *sat2;
	struct sockaddr_at thesockaddr;
	struct sockaddr *sa2;

	sat1 = (struct sockaddr_at *) sa;
	sat2 = (struct sockaddr_at *) mask;
	sa2 = (struct sockaddr *) & thesockaddr;

	thesockaddr.sat_addr.s_net = sat1->sat_addr.s_net &
	    sat2->sat_addr.s_net;
	if ((n = snprintf(buf, sizeof(buf), "%s",
	    atalk_print(sa2, 1 | (what & 8)))) >= sizeof(buf))
		n = sizeof(buf) - 1;
	else if (n < 0)
		n = 0;	/* What else can be done ? */
	if (sat2->sat_addr.s_net != 0xFFFF) {
		thesockaddr.sat_addr.s_net = sat1->sat_addr.s_net |
		    ~sat2->sat_addr.s_net;
		if ((l = snprintf(buf + n, sizeof(buf) - n,
		    "-%s", atalk_print(sa2, 1 | (what & 8)))) >= sizeof(buf) - n)
			l = sizeof(buf) - n - 1;
		if (l > 0)
			n += l;
	}
	if (what & 2) {
		l = snprintf(buf + n, sizeof(buf) - n, ".%s",
		    atalk_print(sa, what & (~1)));
		if (l >= sizeof(buf) - n)
			l = sizeof(buf) - n - 1;
		if (l > 0)
			n += l;
	}
	return (buf);
@


1.16
log
@delete rcsid crud
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.15 2007/12/14 18:35:46 deraadt Exp $	*/
d50 1
@


1.15
log
@remove 21 nlist variables, and instead use sysctl to query the kernel
turn on INET6 the default (remove the #ifdef's)
ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.14 2005/03/30 06:45:34 deraadt Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "from @@(#)atalk.c	1.1 (Whistle) 6/6/96";
#else
static char rcsid[] = "$OpenBSD: atalk.c,v 1.14 2005/03/30 06:45:34 deraadt Exp $";
#endif
#endif /* not lint */
@


1.14
log
@include nlist.h not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.13 2005/03/25 17:01:03 jaredy Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: atalk.c,v 1.13 2005/03/25 17:01:03 jaredy Exp $";
d47 1
d309 1
a309 1
ddp_stats(u_long off, char *name)
d312 2
d315 4
a318 3
	if (off == 0)
		return;
	if (kread(off, &ddpstat, sizeof(ddpstat)) < 0)
d320 2
@


1.13
log
@kill unneeded (char *) casts.  ok millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.12 2004/03/13 22:02:13 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: atalk.c,v 1.12 2004/03/13 22:02:13 deraadt Exp $";
a56 1
#include <nlist.h>
@


1.12
log
@some NULL vs 0 and knf; parts from nimadeus@@pandora.be
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.11 2003/06/03 02:56:13 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: atalk.c,v 1.11 2003/06/03 02:56:13 millert Exp $";
d254 1
a254 1
	if (kread(off, (char *) &initial, sizeof(struct ddpcb *)) < 0)
d261 1
a261 1
		if (kread((u_long) next, (char *) &ddpcb, sizeof(ddpcb)) < 0)
d269 2
a270 2
		if (kread((u_long) ddpcb.ddp_socket,
		    (char *) &sockb, sizeof(sockb)) < 0)
d315 1
a315 1
	if (kread(off, (char *) &ddpstat, sizeof(ddpstat)) < 0)
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.10 2003/02/01 01:51:31 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: atalk.c,v 1.10 2003/02/01 01:51:31 deraadt Exp $";
d209 1
a209 1
	static char     buf[100];
@


1.10
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.9 2002/07/25 03:58:56 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: atalk.c,v 1.9 2002/07/25 03:58:56 deraadt Exp $";
@


1.9
log
@handle < 0 and such better
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.8 2002/05/27 01:50:36 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: atalk.c,v 1.8 2002/05/27 01:50:36 deraadt Exp $";
d85 1
a85 3
at_pr_net(sat, numeric)
	struct sockaddr_at *sat;
	int numeric;
d103 1
a103 3
at_pr_host(sat, numeric)
	struct sockaddr_at *sat;
	int numeric;
d121 1
a121 2
at_pr_port(sat)
	struct sockaddr_at *sat;
d150 1
a150 2
at_pr_range(sat)
	struct sockaddr_at *sat;
d154 2
a155 2
	if (sat->sat_range.r_netrange.nr_firstnet
	    != sat->sat_range.r_netrange.nr_lastnet) {
d174 1
a174 3
atalk_print(sa, what)
	const struct sockaddr *sa;
	int what;
d210 1
a210 4
atalk_print2(sa, mask, what)
	const struct sockaddr *sa;
	const struct sockaddr *mask;
	int what;
d250 1
a250 3
atalkprotopr(off, name)
	u_long off;
	char  *name;
d313 1
a313 3
ddp_stats(off, name)
	u_long off;
	char *name;
@


1.8
log
@a night of cleanup, so i can read this easier
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.7 2002/02/16 21:27:50 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: atalk.c,v 1.7 2002/02/16 21:27:50 millert Exp $";
d235 2
a236 2
	n = snprintf(buf, sizeof(buf), "%s", atalk_print(sa2, 1 | (what & 8)));
	if (n >= sizeof(buf))
d238 1
a238 1
	else if (n == -1)
d243 2
a244 3
		l = snprintf(buf + n, sizeof(buf) - n,
		    "-%s", atalk_print(sa2, 1 | (what & 8)));
		if (l >= sizeof(buf) - n)
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.6 2002/01/17 21:34:58 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: atalk.c,v 1.6 2002/01/17 21:34:58 mickey Exp $";
d163 2
a164 2
			ntohs(sat->sat_range.r_netrange.nr_firstnet),
			ntohs(sat->sat_range.r_netrange.nr_lastnet));
d167 1
a167 1
			ntohs(sat->sat_range.r_netrange.nr_firstnet));
d203 2
a204 2
			at_pr_net(sat, numeric),
			at_pr_host(sat, numeric));
d288 1
a288 1
			  (char *) &sockb, sizeof(sockb)) < 0)
d299 3
a301 3
			     "%-5.5s %-6.6s %-6.6s  %-22.22s %-22.22s %s\n",
			       "Proto", "Recv-Q", "Send-Q",
			     "Local Address", "Foreign Address", "(state)");
d309 1
a309 1
			  (struct sockaddr *) & ddpcb.ddp_lsat, 7));
d311 1
a311 1
			  (struct sockaddr *) & ddpcb.ddp_fsat, 7));
d317 1
a317 1
    printf(m, ddpstat.f, plural(ddpstat.f))
d319 1
a319 1
    printf(m, ddpstat.f1, plural(ddpstat.f1), ddpstat.f2, plural(ddpstat.f2))
d321 1
a321 1
    printf(m, ddpstat.f, plurales(ddpstat.f))
@


1.6
log
@evil, annoying spaces and tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.5 2001/11/19 19:02:15 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: atalk.c,v 1.5 2001/11/19 19:02:15 mpech Exp $";
d72 4
a75 4
static char *at_pr_net __P((struct sockaddr_at *, int));
static char *at_pr_host __P((struct sockaddr_at *, int));
static char *at_pr_range __P((struct sockaddr_at *));
static char *at_pr_port __P((struct sockaddr_at *));
@


1.5
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.4 2001/08/18 22:14:03 brian Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: atalk.c,v 1.4 2001/08/18 22:14:03 brian Exp $";
d99 1
a99 1
	(void) snprintf(mybuf, sizeof(mybuf), "%hu", 
d119 1
a119 1
	(void) snprintf(mybuf, sizeof(mybuf), "%d", 
d149 1
a149 1
			
d223 1
a223 1
	size_t          n, l;
d277 1
a277 1
		u_long          ppcb = (u_long) next;
d307 1
a307 1
		       sockb.so_snd.sb_cc);
@


1.4
log
@Handle snprintf returning -1
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.3 2001/01/29 01:58:13 niklas Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: atalk.c,v 1.3 2001/01/29 01:58:13 niklas Exp $";
d267 1
a267 1
	register struct ddpcb *prev, *next;
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: atalk.c,v 1.2 1997/05/22 17:21:26 christos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: atalk.c,v 1.2 1997/05/22 17:21:26 christos Exp $";
d238 2
d247 2
a248 1
		n += l;
d255 2
a256 1
		n += l;
@


1.2
log
@Fix snprintf return value usage.
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: atalk.c,v 1.2 1997/05/22 17:21:26 christos Exp $";
@


1.1
log
@AppleTalk specifics
@
text
@d222 1
a222 1
	int             n;
d235 2
d240 1
a240 1
		n += snprintf(buf + n, sizeof(buf) - n,
d242 3
d246 2
a247 2
	if (what & 2)
		n += snprintf(buf + n, sizeof(buf) - n, ".%s",
d249 4
@

