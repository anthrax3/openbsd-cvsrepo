head	1.52;
access;
symbols
	OPENBSD_6_0:1.50.0.2
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.48.0.6
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.44.0.4
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.43.0.4
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.2
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.42.0.8
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.6
	OPENBSD_5_0:1.42.0.4
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.40.0.4
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.37.0.6
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.36.0.4
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.33.0.4
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.32.0.6
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.32.0.4
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.31.0.2
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.30.0.4
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.27.0.2
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.52
date	2017.01.21.11.32.04;	author guenther;	state Exp;
branches;
next	1.51;
commitid	DpBZlpar7mq0CJFq;

1.51
date	2016.12.22.11.04.44;	author rzalamena;	state Exp;
branches;
next	1.50;
commitid	T2qzeepA7r1EGy1x;

1.50
date	2016.03.28.07.30.28;	author jca;	state Exp;
branches;
next	1.49;
commitid	K3e2AhXGqkCLaUFu;

1.49
date	2015.09.11.19.35.37;	author mpi;	state Exp;
branches;
next	1.48;
commitid	VObusOUb029PxhGP;

1.48
date	2015.02.12.01.49.02;	author claudio;	state Exp;
branches;
next	1.47;
commitid	EszVZ4RtthRFw1UZ;

1.47
date	2015.01.16.06.40.10;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	Uu5nFG3wCl0LACBb;

1.46
date	2014.08.14.12.55.50;	author mpi;	state Exp;
branches;
next	1.45;
commitid	gdOWXDzOPG8ZFusi;

1.45
date	2014.06.23.03.46.17;	author guenther;	state Exp;
branches;
next	1.44;
commitid	uXnRK9VvnFZsAqfW;

1.44
date	2013.08.18.16.32.24;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2012.12.04.02.30.34;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2010.12.21.13.12.13;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2010.10.21.10.51.05;	author bluhm;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.05.20.50.14;	author michele;	state Exp;
branches;
next	1.39;

1.39
date	2009.07.17.14.21.37;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2009.07.16.23.14.10;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2009.02.07.15.06.04;	author chl;	state Exp;
branches;
next	1.36;

1.36
date	2007.12.19.01.47.00;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.12.14.18.35.46;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.11.18.16.48;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.25.17.01.03;	author jaredy;	state Exp;
branches;
next	1.31;

1.31
date	2004.11.17.01.47.20;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.06.06.18.20;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.03.02.56.13;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.14.23.37.05;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.16.19.10.46;	author sturm;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.13.09.09.33;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.01.01.51.31;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.10.26.18.56.53;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.09.04.07.10;	author jsyn;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.09.02.16.39;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.07.21.58.38;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.27.01.50.36;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.19.18.38.02;	author mpech;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.16.21.27.50;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.17.21.34.58;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.13.02.29.15;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.07.11.43.50;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.11.17.53.29;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.11.17.40.52;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.26.03.01.50;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.13.19.01.38;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.12.16.16.57;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.06.10.16.56;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.16.02.10.50;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.17.11.54.50;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.28.11.57.32;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.18.05.39.35;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.05.00.07.08;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.30.20.31.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.12.30.17;	author itojun;	state Exp;
branches;
next	;


desc
@@


1.52
log
@The POSIX APIs that that sockaddrs all ignore the s*_len field in the
incoming socket, so userspace doesn't need to set it unless it has its
own reasons for tracking the size along with the sockaddr.

ok phessler@@ deraadt@@ florian@@
@
text
@/*	$OpenBSD: inet6.c,v 1.51 2016/12/22 11:04:44 rzalamena Exp $	*/
/*	BSDI inet.c,v 2.3 1995/10/24 02:19:29 prb Exp	*/
/*
 * Copyright (c) 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/ioctl.h>
#include <sys/protosw.h>
#include <sys/sysctl.h>

#include <net/route.h>
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/ip6.h>
#include <netinet/icmp6.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet6/ip6_var.h>
#include <netinet6/in6_var.h>
#include <netinet6/raw_ip6.h>
#include <netinet6/ip6_divert.h>

#include <arpa/inet.h>
#include <netdb.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include "netstat.h"

struct	socket sockb;

char	*inet6name(struct in6_addr *);

static	char *ip6nh[] = {
	"hop by hop",
	"ICMP",
	"IGMP",
	"#3",
	"IP",
	"#5",
	"TCP",
	"#7",
	"#8",
	"#9",
	"#10",
	"#11",
	"#12",
	"#13",
	"#14",
	"#15",
	"#16",
	"UDP",
	"#18",
	"#19",
	"#20",
	"#21",
	"IDP",
	"#23",
	"#24",
	"#25",
	"#26",
	"#27",
	"#28",
	"TP",
	"#30",
	"#31",
	"#32",
	"#33",
	"#34",
	"#35",
	"#36",
	"#37",
	"#38",
	"#39",
	"#40",
	"IP6",
	"#42",
	"routing",
	"fragment",
	"#45",
	"#46",
	"#47",
	"#48",
	"#49",
	"ESP",
	"AH",
	"#52",
	"#53",
	"#54",
	"#55",
	"#56",
	"#57",
	"ICMP6",
	"no next header",
	"destination option",
	"#61",
	"#62",
	"#63",
	"#64",
	"#65",
	"#66",
	"#67",
	"#68",
	"#69",
	"#70",
	"#71",
	"#72",
	"#73",
	"#74",
	"#75",
	"#76",
	"#77",
	"#78",
	"#79",
	"ISOIP",
	"#81",
	"#82",
	"#83",
	"#84",
	"#85",
	"#86",
	"#87",
	"#88",
	"OSPF",
	"#80",
	"#91",
	"#92",
	"#93",
	"#94",
	"#95",
	"#96",
	"Ethernet",
	"#98",
	"#99",
	"#100",
	"#101",
	"#102",
	"#103",
	"#104",
	"#105",
	"#106",
	"#107",
	"#108",
	"#109",
	"#110",
	"#111",
	"#112",
	"#113",
	"#114",
	"#115",
	"#116",
	"#117",
	"#118",
	"#119",
	"#120",
	"#121",
	"#122",
	"#123",
	"#124",
	"#125",
	"#126",
	"#127",
	"#128",
	"#129",
	"#130",
	"#131",
	"#132",
	"#133",
	"#134",
	"#135",
	"#136",
	"#137",
	"#138",
	"#139",
	"#140",
	"#141",
	"#142",
	"#143",
	"#144",
	"#145",
	"#146",
	"#147",
	"#148",
	"#149",
	"#150",
	"#151",
	"#152",
	"#153",
	"#154",
	"#155",
	"#156",
	"#157",
	"#158",
	"#159",
	"#160",
	"#161",
	"#162",
	"#163",
	"#164",
	"#165",
	"#166",
	"#167",
	"#168",
	"#169",
	"#170",
	"#171",
	"#172",
	"#173",
	"#174",
	"#175",
	"#176",
	"#177",
	"#178",
	"#179",
	"#180",
	"#181",
	"#182",
	"#183",
	"#184",
	"#185",
	"#186",
	"#187",
	"#188",
	"#189",
	"#180",
	"#191",
	"#192",
	"#193",
	"#194",
	"#195",
	"#196",
	"#197",
	"#198",
	"#199",
	"#200",
	"#201",
	"#202",
	"#203",
	"#204",
	"#205",
	"#206",
	"#207",
	"#208",
	"#209",
	"#210",
	"#211",
	"#212",
	"#213",
	"#214",
	"#215",
	"#216",
	"#217",
	"#218",
	"#219",
	"#220",
	"#221",
	"#222",
	"#223",
	"#224",
	"#225",
	"#226",
	"#227",
	"#228",
	"#229",
	"#230",
	"#231",
	"#232",
	"#233",
	"#234",
	"#235",
	"#236",
	"#237",
	"#238",
	"#239",
	"#240",
	"#241",
	"#242",
	"#243",
	"#244",
	"#245",
	"#246",
	"#247",
	"#248",
	"#249",
	"#250",
	"#251",
	"#252",
	"#253",
	"#254",
	"#255",
};

/*
 * Dump IP6 statistics structure.
 */
void
ip6_stats(char *name)
{
	struct ip6stat ip6stat;
	int first, i;
	struct protoent *ep;
	const char *n;
	int mib[] = { CTL_NET, PF_INET6, IPPROTO_IPV6, IPV6CTL_STATS };
	size_t len = sizeof(ip6stat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &ip6stat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define	p(f, m) if (ip6stat.f || sflag <= 1) \
	printf(m, (unsigned long long)ip6stat.f, plural(ip6stat.f))
#define	p1(f, m) if (ip6stat.f || sflag <= 1) \
	printf(m, (unsigned long long)ip6stat.f)

	p(ip6s_total, "\t%llu total packet%s received\n");
	p1(ip6s_toosmall, "\t%llu with size smaller than minimum\n");
	p1(ip6s_tooshort, "\t%llu with data size < data length\n");
	p1(ip6s_badoptions, "\t%llu with bad options\n");
	p1(ip6s_badvers, "\t%llu with incorrect version number\n");
	p(ip6s_fragments, "\t%llu fragment%s received\n");
	p(ip6s_fragdropped,
	    "\t%llu fragment%s dropped (duplicates or out of space)\n");
	p(ip6s_fragtimeout, "\t%llu fragment%s dropped after timeout\n");
	p(ip6s_fragoverflow, "\t%llu fragment%s that exceeded limit\n");
	p(ip6s_reassembled, "\t%llu packet%s reassembled ok\n");
	p(ip6s_delivered, "\t%llu packet%s for this host\n");
	p(ip6s_forward, "\t%llu packet%s forwarded\n");
	p(ip6s_cantforward, "\t%llu packet%s not forwardable\n");
	p(ip6s_redirectsent, "\t%llu redirect%s sent\n");
	p(ip6s_localout, "\t%llu packet%s sent from this host\n");
	p(ip6s_rawout, "\t%llu packet%s sent with fabricated ip header\n");
	p(ip6s_odropped,
	    "\t%llu output packet%s dropped due to no bufs, etc.\n");
	p(ip6s_noroute, "\t%llu output packet%s discarded due to no route\n");
	p(ip6s_fragmented, "\t%llu output datagram%s fragmented\n");
	p(ip6s_ofragments, "\t%llu fragment%s created\n");
	p(ip6s_cantfrag, "\t%llu datagram%s that can't be fragmented\n");
	p(ip6s_badscope, "\t%llu packet%s that violated scope rules\n");
	p(ip6s_notmember, "\t%llu multicast packet%s which we don't join\n");
	for (first = 1, i = 0; i < 256; i++)
		if (ip6stat.ip6s_nxthist[i] != 0) {
			if (first) {
				printf("\tInput packet histogram:\n");
				first = 0;
			}
			n = NULL;
			if (ip6nh[i])
				n = ip6nh[i];
			else if ((ep = getprotobynumber(i)) != NULL)
				n = ep->p_name;
			if (n)
				printf("\t\t%s: %llu\n", n,
				    (unsigned long long)ip6stat.ip6s_nxthist[i]);
			else
				printf("\t\t#%d: %llu\n", i,
				    (unsigned long long)ip6stat.ip6s_nxthist[i]);
		}
	printf("\tMbuf statistics:\n");
	p(ip6s_m1, "\t\t%llu one mbuf%s\n");
	for (first = 1, i = 0; i < 32; i++) {
		char ifbuf[IFNAMSIZ];
		if (ip6stat.ip6s_m2m[i] != 0) {
			if (first) {
				printf("\t\ttwo or more mbuf:\n");
				first = 0;
			}
			printf("\t\t\t%s = %llu\n",
			    if_indextoname(i, ifbuf),
			    (unsigned long long)ip6stat.ip6s_m2m[i]);
		}
	}
	p(ip6s_mext1, "\t\t%llu one ext mbuf%s\n");
	p(ip6s_mext2m, "\t\t%llu two or more ext mbuf%s\n");
	p(ip6s_nogif, "\t%llu tunneling packet%s that can't find gif\n");
	p(ip6s_toomanyhdr,
	    "\t%llu packet%s discarded due to too many headers\n");

	/* for debugging source address selection */
#define PRINT_SCOPESTAT(s,i) do {\
		switch(i) { /* XXX hardcoding in each case */\
		case 1:\
			p(s, "\t\t%llu node-local%s\n");\
			break;\
		case 2:\
			p(s, "\t\t%llu link-local%s\n");\
			break;\
		case 5:\
			p(s, "\t\t%llu site-local%s\n");\
			break;\
		case 14:\
			p(s, "\t\t%llu global%s\n");\
			break;\
		default:\
			printf("\t\t%llu addresses scope=%x\n",\
			    (unsigned long long)ip6stat.s, i);\
		}\
	} while(0);

	p(ip6s_sources_none,
	    "\t%llu failure%s of source address selection\n");
	for (first = 1, i = 0; i < 16; i++) {
		if (ip6stat.ip6s_sources_sameif[i]) {
			if (first) {
				printf("\tsource addresses on an outgoing I/F\n");
				first = 0;
			}
			PRINT_SCOPESTAT(ip6s_sources_sameif[i], i);
		}
	}
	for (first = 1, i = 0; i < 16; i++) {
		if (ip6stat.ip6s_sources_otherif[i]) {
			if (first) {
				printf("\tsource addresses on a non-outgoing I/F\n");
				first = 0;
			}
			PRINT_SCOPESTAT(ip6s_sources_otherif[i], i);
		}
	}
	for (first = 1, i = 0; i < 16; i++) {
		if (ip6stat.ip6s_sources_samescope[i]) {
			if (first) {
				printf("\tsource addresses of same scope\n");
				first = 0;
			}
			PRINT_SCOPESTAT(ip6s_sources_samescope[i], i);
		}
	}
	for (first = 1, i = 0; i < 16; i++) {
		if (ip6stat.ip6s_sources_otherscope[i]) {
			if (first) {
				printf("\tsource addresses of a different scope\n");
				first = 0;
			}
			PRINT_SCOPESTAT(ip6s_sources_otherscope[i], i);
		}
	}
	for (first = 1, i = 0; i < 16; i++) {
		if (ip6stat.ip6s_sources_deprecated[i]) {
			if (first) {
				printf("\tdeprecated source addresses\n");
				first = 0;
			}
			PRINT_SCOPESTAT(ip6s_sources_deprecated[i], i);
		}
	}

	p1(ip6s_forward_cachehit, "\t%llu forward cache hit\n");
	p1(ip6s_forward_cachemiss, "\t%llu forward cache miss\n");
#undef p
#undef p1
}

static	char *icmp6names[] = {
	"#0",
	"unreach",
	"packet too big",
	"time exceed",
	"parameter problem",
	"#5",
	"#6",
	"#7",
	"#8",
	"#9",
	"#10",
	"#11",
	"#12",
	"#13",
	"#14",
	"#15",
	"#16",
	"#17",
	"#18",
	"#19",
	"#20",
	"#21",
	"#22",
	"#23",
	"#24",
	"#25",
	"#26",
	"#27",
	"#28",
	"#29",
	"#30",
	"#31",
	"#32",
	"#33",
	"#34",
	"#35",
	"#36",
	"#37",
	"#38",
	"#39",
	"#40",
	"#41",
	"#42",
	"#43",
	"#44",
	"#45",
	"#46",
	"#47",
	"#48",
	"#49",
	"#50",
	"#51",
	"#52",
	"#53",
	"#54",
	"#55",
	"#56",
	"#57",
	"#58",
	"#59",
	"#60",
	"#61",
	"#62",
	"#63",
	"#64",
	"#65",
	"#66",
	"#67",
	"#68",
	"#69",
	"#70",
	"#71",
	"#72",
	"#73",
	"#74",
	"#75",
	"#76",
	"#77",
	"#78",
	"#79",
	"#80",
	"#81",
	"#82",
	"#83",
	"#84",
	"#85",
	"#86",
	"#87",
	"#88",
	"#89",
	"#80",
	"#91",
	"#92",
	"#93",
	"#94",
	"#95",
	"#96",
	"#97",
	"#98",
	"#99",
	"#100",
	"#101",
	"#102",
	"#103",
	"#104",
	"#105",
	"#106",
	"#107",
	"#108",
	"#109",
	"#110",
	"#111",
	"#112",
	"#113",
	"#114",
	"#115",
	"#116",
	"#117",
	"#118",
	"#119",
	"#120",
	"#121",
	"#122",
	"#123",
	"#124",
	"#125",
	"#126",
	"#127",
	"echo",
	"echo reply",
	"multicast listener query",
	"multicast listener report",
	"multicast listener done",
	"router solicitation",
	"router advertisement",
	"neighbor solicitation",
	"neighbor advertisement",
	"redirect",
	"router renumbering",
	"node information request",
	"node information reply",
	"#141",
	"#142",
	"#143",
	"#144",
	"#145",
	"#146",
	"#147",
	"#148",
	"#149",
	"#150",
	"#151",
	"#152",
	"#153",
	"#154",
	"#155",
	"#156",
	"#157",
	"#158",
	"#159",
	"#160",
	"#161",
	"#162",
	"#163",
	"#164",
	"#165",
	"#166",
	"#167",
	"#168",
	"#169",
	"#170",
	"#171",
	"#172",
	"#173",
	"#174",
	"#175",
	"#176",
	"#177",
	"#178",
	"#179",
	"#180",
	"#181",
	"#182",
	"#183",
	"#184",
	"#185",
	"#186",
	"#187",
	"#188",
	"#189",
	"#180",
	"#191",
	"#192",
	"#193",
	"#194",
	"#195",
	"#196",
	"#197",
	"#198",
	"#199",
	"#200",
	"#201",
	"#202",
	"#203",
	"#204",
	"#205",
	"#206",
	"#207",
	"#208",
	"#209",
	"#210",
	"#211",
	"#212",
	"#213",
	"#214",
	"#215",
	"#216",
	"#217",
	"#218",
	"#219",
	"#220",
	"#221",
	"#222",
	"#223",
	"#224",
	"#225",
	"#226",
	"#227",
	"#228",
	"#229",
	"#230",
	"#231",
	"#232",
	"#233",
	"#234",
	"#235",
	"#236",
	"#237",
	"#238",
	"#239",
	"#240",
	"#241",
	"#242",
	"#243",
	"#244",
	"#245",
	"#246",
	"#247",
	"#248",
	"#249",
	"#250",
	"#251",
	"#252",
	"#253",
	"#254",
	"#255",
};

/*
 * Dump ICMPv6 statistics.
 */
void
icmp6_stats(char *name)
{
	struct icmp6stat icmp6stat;
	int i, first;
	int mib[] = { CTL_NET, PF_INET6, IPPROTO_ICMPV6, ICMPV6CTL_STATS };
	size_t len = sizeof(icmp6stat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &icmp6stat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define	p(f, m) if (icmp6stat.f || sflag <= 1) \
	printf(m, (unsigned long long)icmp6stat.f, plural(icmp6stat.f))
#define p_5(f, m) if (icmp6stat.f || sflag <= 1) \
	printf(m, (unsigned long long)icmp6stat.f)

	p(icp6s_error, "\t%llu call%s to icmp6_error\n");
	p(icp6s_canterror,
	    "\t%llu error%s not generated because old message was icmp6 or so\n");
	p(icp6s_toofreq,
	    "\t%llu error%s not generated because of rate limitation\n");
	for (first = 1, i = 0; i < 256; i++)
		if (icmp6stat.icp6s_outhist[i] != 0) {
			if (first) {
				printf("\tOutput packet histogram:\n");
				first = 0;
			}
			printf("\t\t%s: %llu\n", icmp6names[i],
			    (unsigned long long)icmp6stat.icp6s_outhist[i]);
		}
	p(icp6s_badcode, "\t%llu message%s with bad code fields\n");
	p(icp6s_tooshort, "\t%llu message%s < minimum length\n");
	p(icp6s_checksum, "\t%llu bad checksum%s\n");
	p(icp6s_badlen, "\t%llu message%s with bad length\n");
	for (first = 1, i = 0; i < ICMP6_MAXTYPE; i++)
		if (icmp6stat.icp6s_inhist[i] != 0) {
			if (first) {
				printf("\tInput packet histogram:\n");
				first = 0;
			}
			printf("\t\t%s: %llu\n", icmp6names[i],
			    (unsigned long long)icmp6stat.icp6s_inhist[i]);
		}
	printf("\tHistogram of error messages to be generated:\n");
	p_5(icp6s_odst_unreach_noroute, "\t\t%llu no route\n");
	p_5(icp6s_odst_unreach_admin, "\t\t%llu administratively prohibited\n");
	p_5(icp6s_odst_unreach_beyondscope, "\t\t%llu beyond scope\n");
	p_5(icp6s_odst_unreach_addr, "\t\t%llu address unreachable\n");
	p_5(icp6s_odst_unreach_noport, "\t\t%llu port unreachable\n");
	p_5(icp6s_opacket_too_big, "\t\t%llu packet too big\n");
	p_5(icp6s_otime_exceed_transit, "\t\t%llu time exceed transit\n");
	p_5(icp6s_otime_exceed_reassembly, "\t\t%llu time exceed reassembly\n");
	p_5(icp6s_oparamprob_header, "\t\t%llu erroneous header field\n");
	p_5(icp6s_oparamprob_nextheader, "\t\t%llu unrecognized next header\n");
	p_5(icp6s_oparamprob_option, "\t\t%llu unrecognized option\n");
	p_5(icp6s_oredirect, "\t\t%llu redirect\n");
	p_5(icp6s_ounknown, "\t\t%llu unknown\n");

	p(icp6s_reflect, "\t%llu message response%s generated\n");
	p(icp6s_nd_toomanyopt, "\t%llu message%s with too many ND options\n");
	p(icp6s_nd_badopt, "\t%llu message%s with bad ND options\n");
	p(icp6s_badns, "\t%llu bad neighbor solicitation message%s\n");
	p(icp6s_badna, "\t%llu bad neighbor advertisement message%s\n");
	p(icp6s_badrs, "\t%llu bad router solicitation message%s\n");
	p(icp6s_badra, "\t%llu bad router advertisement message%s\n");
	p(icp6s_badredirect, "\t%llu bad redirect message%s\n");
	p(icp6s_pmtuchg, "\t%llu path MTU change%s\n");
#undef p
#undef p_5
}

/*
 * Dump raw ip6 statistics structure.
 */
void
rip6_stats(char *name)
{
	struct rip6stat rip6stat;
	u_int64_t delivered;
	int mib[] = { CTL_NET, PF_INET6, IPPROTO_RAW, RIPV6CTL_STATS };
	size_t len = sizeof(rip6stat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &rip6stat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);

#define	p(f, m) if (rip6stat.f || sflag <= 1) \
    printf(m, (unsigned long long)rip6stat.f, plural(rip6stat.f))
	p(rip6s_ipackets, "\t%llu message%s received\n");
	p(rip6s_isum, "\t%llu checksum calculation%s on inbound\n");
	p(rip6s_badsum, "\t%llu message%s with bad checksum\n");
	p(rip6s_nosock, "\t%llu message%s dropped due to no socket\n");
	p(rip6s_nosockmcast,
	    "\t%llu multicast message%s dropped due to no socket\n");
	p(rip6s_fullsock,
	    "\t%llu message%s dropped due to full socket buffers\n");
	delivered = rip6stat.rip6s_ipackets -
		    rip6stat.rip6s_badsum -
		    rip6stat.rip6s_nosock -
		    rip6stat.rip6s_nosockmcast -
		    rip6stat.rip6s_fullsock;
	if (delivered || sflag <= 1)
		printf("\t%llu delivered\n", (unsigned long long)delivered);
	p(rip6s_opackets, "\t%llu datagram%s output\n");
#undef p
}

/*
 * Dump divert6 statistics structure.
 */
void
div6_stats(char *name)
{
	struct div6stat div6stat;
	int mib[] = { CTL_NET, PF_INET6, IPPROTO_DIVERT, DIVERT6CTL_STATS };
	size_t len = sizeof(div6stat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &div6stat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define p(f, m) if (div6stat.f || sflag <= 1) \
    printf(m, div6stat.f, plural(div6stat.f))
#define p1(f, m) if (div6stat.f || sflag <= 1) \
    printf(m, div6stat.f)
	p(divs_ipackets, "\t%lu total packet%s received\n");
	p1(divs_noport, "\t%lu dropped due to no socket\n");
	p1(divs_fullsock, "\t%lu dropped due to full socket buffers\n");
	p(divs_opackets, "\t%lu packet%s output\n");
	p1(divs_errors, "\t%lu errors\n");
#undef p
#undef p1
}

/*
 * Pretty print an Internet address (net address + port).
 * If the nflag was specified, use numbers instead of names.
 */

void
inet6print(struct in6_addr *in6, int port, const char *proto)
{

#define GETSERVBYPORT6(port, proto, ret) do { \
	if (strcmp((proto), "tcp6") == 0) \
		(ret) = getservbyport((int)(port), "tcp"); \
	else if (strcmp((proto), "udp6") == 0) \
		(ret) = getservbyport((int)(port), "udp"); \
	else \
		(ret) = getservbyport((int)(port), (proto)); \
	} while (0)

	struct servent *sp = 0;
	char line[80], *cp;
	int width;
	int len = sizeof line;

	width = Aflag ? 12 : 16;
	if (vflag && width < strlen(inet6name(in6)))
		width = strlen(inet6name(in6));
	snprintf(line, len, "%.*s.", width, inet6name(in6));
	len -= strlen(line);
	if (len <= 0)
		goto bail;

	cp = strchr(line, '\0');
	if (!nflag && port)
		GETSERVBYPORT6(port, proto, sp);
	if (sp || port == 0)
		snprintf(cp, len, "%.8s", sp ? sp->s_name : "*");
	else
		snprintf(cp, len, "%d", ntohs((u_short)port));
	width = Aflag ? 18 : 22;
	if (vflag && width < strlen(line))
		width = strlen(line);
bail:
	printf(" %-*.*s", width, width, line);
}

/*
 * Construct an Internet address representation.
 * If the nflag has been supplied, give
 * numeric value, otherwise try for symbolic name.
 */

char *
inet6name(struct in6_addr *in6p)
{
	char *cp;
	static char line[NI_MAXHOST];
	struct hostent *hp;
	static char domain[HOST_NAME_MAX+1];
	static int first = 1;
	char hbuf[NI_MAXHOST];
	struct sockaddr_in6 sin6;
	const int niflag = NI_NUMERICHOST;

	if (first && !nflag) {
		first = 0;
		if (gethostname(domain, sizeof(domain)) == 0 &&
		    (cp = strchr(domain, '.')))
			(void) strlcpy(domain, cp + 1, sizeof domain);
		else
			domain[0] = '\0';
	}
	cp = 0;
	if (!nflag && !IN6_IS_ADDR_UNSPECIFIED(in6p)) {
		hp = gethostbyaddr((char *)in6p, sizeof(*in6p), AF_INET6);
		if (hp) {
			if ((cp = strchr(hp->h_name, '.')) &&
			    !strcmp(cp + 1, domain))
				*cp = 0;
			cp = hp->h_name;
		}
	}
	if (IN6_IS_ADDR_UNSPECIFIED(in6p))
		strlcpy(line, "*", sizeof(line));
	else if (cp)
		strlcpy(line, cp, sizeof(line));
	else {
		memset(&sin6, 0, sizeof(sin6));
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = *in6p;
#ifdef __KAME__
		if (IN6_IS_ADDR_LINKLOCAL(in6p) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(in6p) ||
		    IN6_IS_ADDR_MC_INTFACELOCAL(in6p)) {
			sin6.sin6_scope_id =
			    ntohs(*(u_int16_t *)&in6p->s6_addr[2]);
			sin6.sin6_addr.s6_addr[2] = 0;
			sin6.sin6_addr.s6_addr[3] = 0;
		}
#endif
		if (getnameinfo((struct sockaddr *)&sin6, sizeof(sin6),
		    hbuf, sizeof(hbuf), NULL, 0, niflag) != 0)
			strlcpy(hbuf, "?", sizeof hbuf);
		strlcpy(line, hbuf, sizeof(line));
	}
	return (line);
}
@


1.51
log
@Remove PIM support from the multicast stack.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.50 2016/03/28 07:30:28 jca Exp $	*/
a985 1
		sin6.sin6_len = sizeof(sin6);
d998 1
a998 1
		if (getnameinfo((struct sockaddr *)&sin6, sin6.sin6_len,
@


1.50
log
@Drop if-zeroed gethostbyname2.h header, remnant from KAME times
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.49 2015/09/11 19:35:37 mpi Exp $	*/
a47 1
#include <netinet6/pim6_var.h>
d170 1
a170 1
	"PIM",
a824 31
}

/*
 * Dump PIM statistics structure.
 */
void
pim6_stats(char *name)
{
	struct pim6stat pim6stat;
	int mib[] = { CTL_NET, PF_INET6, IPPROTO_PIM, PIM6CTL_STATS };
	size_t len = sizeof(pim6stat);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &pim6stat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("%s", name);
		return;
	}

	printf("%s:\n", name);
#define	p(f, m) if (pim6stat.f || sflag <= 1) \
	printf(m, (unsigned long long)pim6stat.f, plural(pim6stat.f))

	p(pim6s_rcv_total, "\t%llu message%s received\n");
	p(pim6s_rcv_tooshort, "\t%llu message%s received with too few bytes\n");
	p(pim6s_rcv_badsum, "\t%llu message%s received with bad checksum\n");
	p(pim6s_rcv_badversion, "\t%llu message%s received with bad version\n");
	p(pim6s_rcv_registers, "\t%llu register%s received\n");
	p(pim6s_rcv_badregisters, "\t%llu bad register%s received\n");
	p(pim6s_snd_registers, "\t%llu register%s sent\n");
#undef p
@


1.49
log
@Remove never called functions to dump per-ifp IPv6 statistics now that
the kernel buffers are gone.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.48 2015/02/12 01:49:02 claudio Exp $	*/
a52 3
#if 0
#include "gethostbyname2.h"
#endif
@


1.48
log
@Switch the printing of open sockets from ugly KVM internals to use
kvm_getfiles. This allows to run netstat without any extra privileges
and removes another setgid program from base..
There is still kvm reader code in there which is used for debugging
purposes (crashdump). netstat should still behave mostly the same.
deraadt@@ and sthen@@ agree that it is time to get this puppy in.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.47 2015/01/16 06:40:10 deraadt Exp $	*/
a492 58
/*
 * Dump IPv6 per-interface statistics based on RFC 2465.
 */
void
ip6_ifstats(char *ifname)
{
	struct in6_ifreq ifr;
	int s;

#define	p(f, m) if (ifr.ifr_ifru.ifru_stat.f || sflag <= 1) \
	printf(m, (unsigned long long)ifr.ifr_ifru.ifru_stat.f, \
	    plural(ifr.ifr_ifru.ifru_stat.f))
#define	p_5(f, m) if (ifr.ifr_ifru.ifru_stat.f || sflag <= 1) \
	printf(m, (unsigned long long)ip6stat.f)

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
		perror("Warning: socket(AF_INET6)");
		return;
	}

	strlcpy(ifr.ifr_name, ifname, sizeof ifr.ifr_name);
	printf("ip6 on %s:\n", ifr.ifr_name);

	if (ioctl(s, SIOCGIFSTAT_IN6, &ifr) < 0) {
		perror("Warning: ioctl(SIOCGIFSTAT_IN6)");
		goto end;
	}

	p(ifs6_in_receive, "\t%llu total input datagram%s\n");
	p(ifs6_in_hdrerr, "\t%llu datagram%s with invalid header received\n");
	p(ifs6_in_toobig, "\t%llu datagram%s exceeded MTU received\n");
	p(ifs6_in_noroute, "\t%llu datagram%s with no route received\n");
	p(ifs6_in_addrerr, "\t%llu datagram%s with invalid dst received\n");
	p(ifs6_in_truncated, "\t%llu truncated datagram%s received\n");
	p(ifs6_in_protounknown, "\t%llu datagram%s with unknown proto received\n");
	p(ifs6_in_discard, "\t%llu input datagram%s discarded\n");
	p(ifs6_in_deliver,
	    "\t%llu datagram%s delivered to an upper layer protocol\n");
	p(ifs6_out_forward, "\t%llu datagram%s forwarded to this interface\n");
	p(ifs6_out_request,
	    "\t%llu datagram%s sent from an upper layer protocol\n");
	p(ifs6_out_discard, "\t%llu total discarded output datagram%s\n");
	p(ifs6_out_fragok, "\t%llu output datagram%s fragmented\n");
	p(ifs6_out_fragfail, "\t%llu output datagram%s failed on fragment\n");
	p(ifs6_out_fragcreat, "\t%llu output datagram%s succeeded on fragment\n");
	p(ifs6_reass_reqd, "\t%llu incoming datagram%s fragmented\n");
	p(ifs6_reass_ok, "\t%llu datagram%s reassembled\n");
	p(ifs6_reass_fail, "\t%llu datagram%s failed on reassembling\n");
	p(ifs6_in_mcast, "\t%llu multicast datagram%s received\n");
	p(ifs6_out_mcast, "\t%llu multicast datagram%s sent\n");

  end:
	close(s);

#undef p
#undef p_5
}

a828 67
}

/*
 * Dump ICMPv6 per-interface statistics based on RFC 2466.
 */
void
icmp6_ifstats(char *ifname)
{
	struct in6_ifreq ifr;
	int s;

#define	p(f, m) if (ifr.ifr_ifru.ifru_icmp6stat.f || sflag <= 1) \
	printf(m, (unsigned long long)ifr.ifr_ifru.ifru_icmp6stat.f, \
	    plural(ifr.ifr_ifru.ifru_icmp6stat.f))

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
		perror("Warning: socket(AF_INET6)");
		return;
	}

	strlcpy(ifr.ifr_name, ifname, sizeof ifr.ifr_name);
	printf("icmp6 on %s:\n", ifr.ifr_name);

	if (ioctl(s, SIOCGIFSTAT_ICMP6, &ifr) < 0) {
		perror("Warning: ioctl(SIOCGIFSTAT_ICMP6)");
		goto end;
	}

	p(ifs6_in_msg, "\t%llu total input message%s\n");
	p(ifs6_in_error, "\t%llu total input error message%s\n");
	p(ifs6_in_dstunreach, "\t%llu input destination unreachable error%s\n");
	p(ifs6_in_adminprohib, "\t%llu input administratively prohibited error%s\n");
	p(ifs6_in_timeexceed, "\t%llu input time exceeded error%s\n");
	p(ifs6_in_paramprob, "\t%llu input parameter problem error%s\n");
	p(ifs6_in_pkttoobig, "\t%llu input packet too big error%s\n");
	p(ifs6_in_echo, "\t%llu input echo request%s\n");
	p(ifs6_in_echoreply, "\t%llu input echo reply%s\n");
	p(ifs6_in_routersolicit, "\t%llu input router solicitation%s\n");
	p(ifs6_in_routeradvert, "\t%llu input router advertisement%s\n");
	p(ifs6_in_neighborsolicit, "\t%llu input neighbor solicitation%s\n");
	p(ifs6_in_neighboradvert, "\t%llu input neighbor advertisement%s\n");
	p(ifs6_in_redirect, "\t%llu input redirect%s\n");
	p(ifs6_in_mldquery, "\t%llu input MLD query%s\n");
	p(ifs6_in_mldreport, "\t%llu input MLD report%s\n");
	p(ifs6_in_mlddone, "\t%llu input MLD done%s\n");

	p(ifs6_out_msg, "\t%llu total output message%s\n");
	p(ifs6_out_error, "\t%llu total output error message%s\n");
	p(ifs6_out_dstunreach, "\t%llu output destination unreachable error%s\n");
	p(ifs6_out_adminprohib, "\t%llu output administratively prohibited error%s\n");
	p(ifs6_out_timeexceed, "\t%llu output time exceeded error%s\n");
	p(ifs6_out_paramprob, "\t%llu output parameter problem error%s\n");
	p(ifs6_out_pkttoobig, "\t%llu output packet too big error%s\n");
	p(ifs6_out_echo, "\t%llu output echo request%s\n");
	p(ifs6_out_echoreply, "\t%llu output echo reply%s\n");
	p(ifs6_out_routersolicit, "\t%llu output router solicitation%s\n");
	p(ifs6_out_routeradvert, "\t%llu output router advertisement%s\n");
	p(ifs6_out_neighborsolicit, "\t%llu output neighbor solicitation%s\n");
	p(ifs6_out_neighboradvert, "\t%llu output neighbor advertisement%s\n");
	p(ifs6_out_redirect, "\t%llu output redirect%s\n");
	p(ifs6_out_mldquery, "\t%llu output MLD query%s\n");
	p(ifs6_out_mldreport, "\t%llu output MLD report%s\n");
	p(ifs6_out_mlddone, "\t%llu output MLD done%s\n");

  end:
	close(s);
#undef p
@


1.47
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.46 2014/08/14 12:55:50 mpi Exp $	*/
a68 1
void	inet6print(struct in6_addr *, int, char *);
d1065 1
a1065 1
inet6print(struct in6_addr *in6, int port, char *proto)
@


1.46
log
@No need for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.45 2014/06/23 03:46:17 guenther Exp $	*/
d32 1
a32 1
#include <sys/param.h>
d63 1
d1117 1
a1117 1
	static char domain[MAXHOSTNAMELEN];
@


1.45
log
@The second level of the CTL_NET sysctl is a PF_*, not an AF_*

inconsistent usage in route(8) noted by Gregor Best (gbe (at) ring0.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.44 2013/08/18 16:32:24 guenther Exp $	*/
a43 1
#include <netinet/in_systm.h>
@


1.44
log
@Fix calls to printf-like functions which passed a non-fixed string
as the format and no variable args.
Replace "%#0.*X" with "%#.*X": the zero-fill flag is ignored/implied
on numeric conversions when a precision is specified.

ok jung@@ millert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.43 2012/12/04 02:30:34 deraadt Exp $	*/
d340 1
a340 1
	int mib[] = { CTL_NET, AF_INET6, IPPROTO_IPV6, IPV6CTL_STATS };
d819 1
a819 1
	int mib[] = { CTL_NET, AF_INET6, IPPROTO_ICMPV6, ICMPV6CTL_STATS };
d964 1
a964 1
	int mib[] = { CTL_NET, AF_INET6, IPPROTO_PIM, PIM6CTL_STATS };
d996 1
a996 1
	int mib[] = { CTL_NET, AF_INET6, IPPROTO_RAW, RIPV6CTL_STATS };
d1036 1
a1036 1
	int mib[] = { CTL_NET, AF_INET6, IPPROTO_DIVERT, DIVERT6CTL_STATS };
@


1.43
log
@remove some unnecessary sys/mbuf.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.42 2010/12/21 13:12:13 claudio Exp $	*/
d346 1
a346 1
			warn(name);
d825 1
a825 1
			warn(name);
d970 1
a970 1
			warn(name);
d1002 1
a1002 1
			warn(name);
d1042 1
a1042 1
			warn(name);
@


1.42
log
@ip6s_exthdrtoolong is always zero so remove it here which is the last user.
OK mikeb@@, henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.41 2010/10/21 10:51:05 bluhm Exp $	*/
a35 1
#include <sys/mbuf.h>
@


1.41
log
@There is neither TCP6 nor struct tcp6cb in our kernel.  So remove
tcp6_dump() from netstat.  It was never called anyway.  No binary
change.
ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.40 2009/11/05 20:50:14 michele Exp $	*/
a415 2
	p(ip6s_exthdrtoolong,
	    "\t%llu packet%s whose headers are not continuous\n");
@


1.40
log
@IPv6 support for divert sockets.

tested by phessler@@ pyr@@
ok claudio@@
"go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.39 2009/07/17 14:21:37 tedu Exp $	*/
a45 1
#ifndef TCP6
a47 1
#endif
a1169 57

#ifdef TCP6
/*
 * Dump the contents of a TCP6 PCB.
 */
void
tcp6_dump(u_long pcbaddr)
{
	struct tcp6cb tcp6cb;
	int i;

	kread(pcbaddr, &tcp6cb, sizeof(tcp6cb));

	printf("TCP Protocol Control Block at 0x%08lx:\n\n", pcbaddr);

	printf("Timers:\n");
	for (i = 0; i < TCP6T_NTIMERS; i++)
		printf("\t%s: %u", tcp6timers[i], tcp6cb.t_timer[i]);
	printf("\n\n");

	if (tcp6cb.t_state < 0 || tcp6cb.t_state >= TCP6_NSTATES)
		printf("State: %d", tcp6cb.t_state);
	else
		printf("State: %s", tcp6states[tcp6cb.t_state]);
	printf(", flags 0x%x, in6pcb 0x%lx\n\n", tcp6cb.t_flags,
	    (u_long)tcp6cb.t_in6pcb);

	printf("rxtshift %d, rxtcur %d, dupacks %d\n", tcp6cb.t_rxtshift,
	    tcp6cb.t_rxtcur, tcp6cb.t_dupacks);
	printf("peermaxseg %u, maxseg %u, force %d\n\n", tcp6cb.t_peermaxseg,
	    tcp6cb.t_maxseg, tcp6cb.t_force);

	printf("snd_una %u, snd_nxt %u, snd_up %u\n",
	    tcp6cb.snd_una, tcp6cb.snd_nxt, tcp6cb.snd_up);
	printf("snd_wl1 %u, snd_wl2 %u, iss %u, snd_wnd %lu\n\n",
	    tcp6cb.snd_wl1, tcp6cb.snd_wl2, tcp6cb.iss, tcp6cb.snd_wnd);

	printf("rcv_wnd %lu, rcv_nxt %u, rcv_up %u, irs %u\n\n",
	    tcp6cb.rcv_wnd, tcp6cb.rcv_nxt, tcp6cb.rcv_up, tcp6cb.irs);

	printf("rcv_adv %u, snd_max %u, snd_cwnd %lu, snd_ssthresh %lu\n",
	    tcp6cb.rcv_adv, tcp6cb.snd_max, tcp6cb.snd_cwnd, tcp6cb.snd_ssthresh);

	printf("idle %d, rtt %d, rtseq %u, srtt %d, rttvar %d, rttmin %d, "
	    "max_sndwnd %lu\n\n", tcp6cb.t_idle, tcp6cb.t_rtt, tcp6cb.t_rtseq,
	    tcp6cb.t_srtt, tcp6cb.t_rttvar, tcp6cb.t_rttmin, tcp6cb.max_sndwnd);

	printf("oobflags %d, iobc %d, softerror %d\n\n", tcp6cb.t_oobflags,
	    tcp6cb.t_iobc, tcp6cb.t_softerror);

	printf("snd_scale %d, rcv_scale %d, req_r_scale %d, req_s_scale %d\n",
	    tcp6cb.snd_scale, tcp6cb.rcv_scale, tcp6cb.request_r_scale,
	    tcp6cb.requested_s_scale);
	printf("ts_recent %u, ts_regent_age %d, last_ack_sent %u\n",
	    tcp6cb.ts_recent, tcp6cb.ts_recent_age, tcp6cb.last_ack_sent);
}
#endif
@


1.39
log
@revert 1.38: naddy looked closer at the output and some of the sections don't make sense without the headers anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.37 2009/02/07 15:06:04 chl Exp $	*/
d54 1
d1032 31
@


1.38
log
@make the inet6 output a little more like everything else.
ok deraadt + a small fix from damien
@
text
@d383 1
a383 1
	for (i = 0; i < 256; i++)
d385 4
d395 2
a396 2
				printf("\t%llu %s packets\n",
				    (unsigned long long)ip6stat.ip6s_nxthist[i], n);
d398 2
a399 2
				printf("\t%llu proto %d packets\n",
				    (unsigned long long)ip6stat.ip6s_nxthist[i], i);
d407 1
a407 1
				printf("\t\ttwo or more mbufs:\n");
d822 1
a822 1
	int i;
d844 1
a844 1
	for (i = 0; i < 256; i++)
d846 4
d857 1
a857 1
	for (i = 0; i < ICMP6_MAXTYPE; i++)
d859 4
d866 1
@


1.37
log
@add missing headers needed for warn() and err().

ok claudio@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.36 2007/12/19 01:47:00 deraadt Exp $	*/
d383 1
a383 1
	for (first = 1, i = 0; i < 256; i++)
a384 4
			if (first) {
				printf("\tInput packet histogram:\n");
				first = 0;
			}
d391 2
a392 2
				printf("\t\t%s: %llu\n", n,
				    (unsigned long long)ip6stat.ip6s_nxthist[i]);
d394 2
a395 2
				printf("\t\t#%d: %llu\n", i,
				    (unsigned long long)ip6stat.ip6s_nxthist[i]);
d403 1
a403 1
				printf("\t\ttwo or more mbuf:\n");
d818 1
a818 1
	int i, first;
d840 1
a840 1
	for (first = 1, i = 0; i < 256; i++)
a841 4
			if (first) {
				printf("\tOutput packet histogram:\n");
				first = 0;
			}
d849 1
a849 1
	for (first = 1, i = 0; i < ICMP6_MAXTYPE; i++)
a850 4
			if (first) {
				printf("\tInput packet histogram:\n");
				first = 0;
			}
a853 1
	printf("\tHistogram of error messages to be generated:\n");
@


1.36
log
@delete rcsid crud
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.35 2007/12/14 18:35:46 deraadt Exp $	*/
d61 2
a65 1
#include <errno.h>
@


1.35
log
@remove 21 nlist variables, and instead use sysctl to query the kernel
turn on INET6 the default (remove the #ifdef's)
ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.34 2007/09/11 18:16:48 henning Exp $	*/
a30 10

#include <sys/cdefs.h>
#ifndef lint
#if 0
static char sccsid[] = "@@(#)inet.c	8.4 (Berkeley) 4/20/94";
#else
/*__RCSID("$OpenBSD: inet6.c,v 1.34 2007/09/11 18:16:48 henning Exp $");*/
/*__RCSID("KAME Id: inet6.c,v 1.10 2000/02/09 10:49:31 itojun Exp");*/
#endif
#endif /* not lint */
@


1.34
log
@u_quad_t -> u_int64_t and %qu -> %llu, from brad
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.33 2006/11/17 01:11:23 itojun Exp $	*/
d37 1
a37 1
/*__RCSID("$OpenBSD: inet6.c,v 1.33 2006/11/17 01:11:23 itojun Exp $");*/
d48 1
d74 1
a76 2
#ifdef INET6

d345 1
a345 1
ip6_stats(u_long off, char *name)
d351 2
d354 4
a357 1
	if (off == 0)
d359 1
a360 1
	kread(off, &ip6stat, sizeof (ip6stat));
a361 1

d828 1
a828 1
icmp6_stats(u_long off, char *name)
d832 2
d835 4
a838 1
	if (off == 0)
d840 2
a841 1
	kread(off, &icmp6stat, sizeof (icmp6stat));
a842 1

d974 1
a974 1
pim6_stats(u_long off, char *name)
d977 2
d980 4
a983 1
	if (off == 0)
d985 2
a986 1
	kread(off, &pim6stat, sizeof(pim6stat));
a987 1

d1005 1
a1005 1
rip6_stats(u_long off, char *name)
d1009 2
d1012 4
a1015 1
	if (off == 0)
d1017 2
a1018 1
	kread(off, &rip6stat, sizeof(rip6stat));
a1205 2

#endif /*INET6*/
@


1.33
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.32 2005/03/25 17:01:03 jaredy Exp $	*/
d37 1
a37 1
/*__RCSID("$OpenBSD: inet6.c,v 1.32 2005/03/25 17:01:03 jaredy Exp $");*/
d994 1
a994 1
	u_quad_t delivered;
@


1.32
log
@kill unneeded (char *) casts.  ok millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.31 2004/11/17 01:47:20 itojun Exp $	*/
d37 1
a37 1
/*__RCSID("$OpenBSD: inet6.c,v 1.31 2004/11/17 01:47:20 itojun Exp $");*/
d1114 2
a1115 1
		    IN6_IS_ADDR_MC_LINKLOCAL(in6p)) {
@


1.31
log
@remove NI_WITHSCOPEID (which is not standard)
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.30 2003/11/06 06:18:20 itojun Exp $	*/
d37 1
a37 1
/*__RCSID("$OpenBSD: inet6.c,v 1.30 2003/11/06 06:18:20 itojun Exp $");*/
d355 1
a355 1
	kread(off, (char *)&ip6stat, sizeof (ip6stat));
d526 1
a526 1
	if (ioctl(s, SIOCGIFSTAT_IN6, (char *)&ifr) < 0) {
d831 1
a831 1
	kread(off, (char *)&icmp6stat, sizeof (icmp6stat));
d915 1
a915 1
	if (ioctl(s, SIOCGIFSTAT_ICMP6, (char *)&ifr) < 0) {
d971 1
a971 1
	kread(off, (char *)&pim6stat, sizeof(pim6stat));
d998 1
a998 1
	kread(off, (char *)&rip6stat, sizeof(rip6stat));
d1139 1
a1139 1
	kread(pcbaddr, (char *)&tcp6cb, sizeof(tcp6cb));
@


1.30
log
@fix linklocal multicast address handling.  Matthias Drochner
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.29 2003/06/03 02:56:13 millert Exp $	*/
d37 1
a37 1
/*__RCSID("$OpenBSD: inet6.c,v 1.29 2003/06/03 02:56:13 millert Exp $");*/
a1082 3
#ifdef NI_WITHSCOPEID
	const int niflag = NI_NUMERICHOST | NI_WITHSCOPEID;
#else
a1083 1
#endif
@


1.29
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.28 2003/05/14 23:37:05 itojun Exp $	*/
d37 1
a37 1
/*__RCSID("$OpenBSD: inet6.c,v 1.28 2003/05/14 23:37:05 itojun Exp $");*/
d1117 2
a1118 1
		if (IN6_IS_ADDR_LINKLOCAL(in6p)) {
@


1.28
log
@use __KAME__ to determine kame-based kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.27 2003/03/16 19:10:46 sturm Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
/*__RCSID("$OpenBSD: inet6.c,v 1.27 2003/03/16 19:10:46 sturm Exp $");*/
@


1.27
log
@correctly initialize a pointer

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.26 2003/03/13 09:09:33 deraadt Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.26 2003/03/13 09:09:33 deraadt Exp $");*/
d1120 1
a1120 1
#ifdef KAME_SCOPEID
@


1.26
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.25 2003/02/01 01:51:31 deraadt Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.25 2003/02/01 01:51:31 deraadt Exp $");*/
d1057 1
a1057 1
	cp += len;
@


1.25
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.24 2002/10/26 18:56:53 itojun Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.24 2002/10/26 18:56:53 itojun Exp $");*/
d1047 1
d1052 6
a1057 2
	snprintf(line, sizeof line, "%.*s.", width, inet6name(in6));
	cp = strchr(line, '\0');
d1061 1
a1061 1
		sprintf(cp, "%.8s", sp ? sp->s_name : "*");
d1063 1
a1063 1
		sprintf(cp, "%d", ntohs((u_short)port));
d1067 1
@


1.24
log
@typo.  NetBSD PR 18816
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.23 2002/06/09 04:07:10 jsyn Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.23 2002/06/09 04:07:10 jsyn Exp $");*/
d349 1
a349 3
ip6_stats(off, name)
	u_long off;
	char *name;
d511 1
a511 2
ip6_ifstats(ifname)
	char *ifname;
d828 1
a828 3
icmp6_stats(off, name)
	u_long off;
	char *name;
d855 1
a855 1
				(unsigned long long)icmp6stat.icp6s_outhist[i]);
d868 1
a868 1
				(unsigned long long)icmp6stat.icp6s_inhist[i]);
d902 1
a902 2
icmp6_ifstats(ifname)
	char *ifname;
d969 1
a969 3
pim6_stats(off, name)
	u_long off;
	char *name;
d995 1
a995 3
rip6_stats(off, name)
	u_long off;
	char *name;
d1032 1
a1032 4
inet6print(in6, port, proto)
	struct in6_addr *in6;
	int port;
	char *proto;
d1034 10
a1043 9
#define GETSERVBYPORT6(port, proto, ret)\
do {\
	if (strcmp((proto), "tcp6") == 0)\
		(ret) = getservbyport((int)(port), "tcp");\
	else if (strcmp((proto), "udp6") == 0)\
		(ret) = getservbyport((int)(port), "udp");\
	else\
		(ret) = getservbyport((int)(port), (proto));\
} while (0)
d1072 1
a1072 2
inet6name(in6p)
	struct in6_addr *in6p;
d1135 1
a1135 2
tcp6_dump(pcbaddr)
	u_long pcbaddr;
@


1.23
log
@Standardization -- s/tdb/TDB/ and various dup expansions.

ok aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.22 2002/06/09 02:16:39 deraadt Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.22 2002/06/09 02:16:39 deraadt Exp $");*/
d1018 1
a1018 1
	p(rip6s_isum, "\t%llu checksum calcuration%s on inbound\n");
@


1.22
log
@use strchr() instead of index()
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.21 2002/06/07 21:58:38 itojun Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.21 2002/06/07 21:58:38 itojun Exp $");*/
d376 1
a376 1
	    "\t%llu fragment%s dropped (dup or out of space)\n");
@


1.21
log
@print rip6stat
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.20 2002/05/27 01:50:36 deraadt Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.20 2002/05/27 01:50:36 deraadt Exp $");*/
d1064 1
a1064 1
	cp = index(line, '\0');
d1103 1
a1103 1
		    (cp = index(domain, '.')))
d1112 1
a1112 1
			if ((cp = index(hp->h_name, '.')) &&
@


1.20
log
@a night of cleanup, so i can read this easier
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.19 2002/02/19 18:38:02 mpech Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.19 2002/02/19 18:38:02 mpech Exp $");*/
d66 1
d996 37
@


1.19
log
@Fix gethostname() usage.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.18 2002/02/16 21:27:50 millert Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.18 2002/02/16 21:27:50 millert Exp $");*/
d364 1
a364 1
    printf(m, (unsigned long long)ip6stat.f, plural(ip6stat.f))
d366 1
a366 1
    printf(m, (unsigned long long)ip6stat.f)
d421 2
a422 2
			       if_indextoname(i, ifbuf),
			       (unsigned long long)ip6stat.ip6s_m2m[i]);
d450 1
a450 1
			       (unsigned long long)ip6stat.s, i);\
d455 1
a455 1
	  "\t%llu failure%s of source address selection\n");
d517 1
d519 2
a520 2
    printf(m, (unsigned long long)ifr.ifr_ifru.ifru_stat.f, \
	plural(ifr.ifr_ifru.ifru_stat.f))
d522 1
a522 1
    printf(m, (unsigned long long)ip6stat.f)
d529 1
a529 1
	strcpy(ifr.ifr_name, ifname);
d546 1
a546 1
	  "\t%llu datagram%s delivered to an upper layer protocol\n");
d549 1
a549 1
	  "\t%llu datagram%s sent from an upper layer protocol\n");
d843 1
a843 1
    printf(m, (unsigned long long)icmp6stat.f, plural(icmp6stat.f))
d845 1
a845 1
    printf(m, (unsigned long long)icmp6stat.f)
d911 1
d913 2
a914 2
    printf(m, (unsigned long long)ifr.ifr_ifru.ifru_icmp6stat.f, \
	plural(ifr.ifr_ifru.ifru_icmp6stat.f))
d921 1
a921 1
	strcpy(ifr.ifr_name, ifname);
d986 2
a987 1
    printf(m, (unsigned long long)pim6stat.f, plural(pim6stat.f))
d1025 1
a1025 1
	sprintf(line, "%.*s.", width, inet6name(in6));
d1066 1
a1066 1
			(void) strcpy(domain, cp + 1);
d1068 1
a1068 1
			domain[0] = 0;
d1092 1
a1092 1
				ntohs(*(u_int16_t *)&in6p->s6_addr[2]);
d1098 2
a1099 2
				hbuf, sizeof(hbuf), NULL, 0, niflag) != 0)
			strcpy(hbuf, "?");
@


1.18
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.17 2002/01/17 21:34:58 mickey Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.17 2002/01/17 21:34:58 mickey Exp $");*/
d1049 1
a1049 1
	static char domain[MAXHOSTNAMELEN + 1];
d1061 1
a1061 1
		if (gethostname(domain, MAXHOSTNAMELEN) == 0 &&
@


1.17
log
@evil, annoying spaces and tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.16 2001/11/19 19:02:15 mpech Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.16 2001/11/19 19:02:15 mpech Exp $");*/
d82 2
a83 2
char	*inet6name __P((struct in6_addr *));
void	inet6print __P((struct in6_addr *, int, char *));
@


1.16
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.15 2001/06/13 02:29:15 itojun Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.15 2001/06/13 02:29:15 itojun Exp $");*/
d105 1
a105 1
	"#19",	
d115 1
a115 1
	"TP",	
d125 1
a125 1
	"#39",	
d135 1
a135 1
	"#49",	
d145 1
a145 1
	"no next header",	
d155 1
a155 1
	"#69",	
d165 1
a165 1
	"#79",	
d175 1
a175 1
	"OSPF",	
d185 1
a185 1
	"#99",	
d195 1
a195 1
	"#109",	
d205 1
a205 1
	"#119",	
d215 1
a215 1
	"#129",	
d225 1
a225 1
	"#139",	
d235 1
a235 1
	"#149",	
d245 1
a245 1
	"#159",	
d255 1
a255 1
	"#169",	
d265 1
a265 1
	"#179",	
d275 1
a275 1
	"#189",	
d285 1
a285 1
	"#199",	
d295 1
a295 1
	"#209",	
d305 1
a305 1
	"#219",	
d315 1
a315 1
	"#229",	
d325 1
a325 1
	"#239",	
d335 1
a335 1
	"#249",	
d415 1
a415 1
		if (ip6stat.ip6s_m2m[i] != 0) {		
d586 1
a586 1
	"#19",	
d596 1
a596 1
	"#29",	
d606 1
a606 1
	"#39",	
d616 1
a616 1
	"#49",	
d626 1
a626 1
	"#59",	
d636 1
a636 1
	"#69",	
d646 1
a646 1
	"#79",	
d656 1
a656 1
	"#89",	
d666 1
a666 1
	"#99",	
d676 1
a676 1
	"#109",	
d686 1
a686 1
	"#119",	
d696 1
a696 1
	"echo reply",	
d716 1
a716 1
	"#149",	
d726 1
a726 1
	"#159",	
d736 1
a736 1
	"#169",	
d746 1
a746 1
	"#179",	
d756 1
a756 1
	"#189",	
d766 1
a766 1
	"#199",	
d776 1
a776 1
	"#209",	
d786 1
a786 1
	"#219",	
d796 1
a796 1
	"#229",	
d806 1
a806 1
	"#239",	
d816 1
a816 1
	"#249",	
d928 1
a928 1
	p(ifs6_in_error, "\t%llu total input error message%s\n"); 
@


1.15
log
@typo in icmp6 stat printing
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.14 2001/02/07 11:43:50 itojun Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.14 2001/02/07 11:43:50 itojun Exp $");*/
d834 1
a834 1
	register int i, first;
d1002 1
a1002 1
	register struct in6_addr *in6;
d1046 1
a1046 1
	register char *cp;
@


1.14
log
@by default, don't bark on inbound ND messages, as outsider may be able to
fill up /var with bogus packets.
setting net.inet6.icmp6.nd6_debug will re-enable kernel messages on invalid
ND packet and other occasions.

improve icmp6 stats.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.13 2000/12/11 17:53:29 itojun Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.13 2000/12/11 17:53:29 itojun Exp $");*/
d701 1
a701 1
	"router advertisment",
d703 1
a703 1
	"neighbor advertisment",
@


1.13
log
@typo in -s message
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.12 2000/12/11 17:40:52 itojun Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.12 2000/12/11 17:40:52 itojun Exp $");*/
d354 2
d364 1
a364 1
    printf(m, ip6stat.f, plural(ip6stat.f))
d366 1
a366 1
    printf(m, ip6stat.f)
d368 25
a392 23
	p(ip6s_total, "\t%qu total packet%s received\n");
	p1(ip6s_toosmall, "\t%qu with size smaller than minimum\n");
	p1(ip6s_tooshort, "\t%qu with data size < data length\n");
	p1(ip6s_badoptions, "\t%qu with bad options\n");
	p1(ip6s_badvers, "\t%qu with incorrect version number\n");
	p(ip6s_fragments, "\t%qu fragment%s received\n");
	p(ip6s_fragdropped, "\t%qu fragment%s dropped (dup or out of space)\n");
	p(ip6s_fragtimeout, "\t%qu fragment%s dropped after timeout\n");
	p(ip6s_fragoverflow, "\t%qu fragment%s that exceeded limit\n");
	p(ip6s_reassembled, "\t%qu packet%s reassembled ok\n");
	p(ip6s_delivered, "\t%qu packet%s for this host\n");
	p(ip6s_forward, "\t%qu packet%s forwarded\n");
	p(ip6s_cantforward, "\t%qu packet%s not forwardable\n");
	p(ip6s_redirectsent, "\t%qu redirect%s sent\n");
	p(ip6s_localout, "\t%qu packet%s sent from this host\n");
	p(ip6s_rawout, "\t%qu packet%s sent with fabricated ip header\n");
	p(ip6s_odropped, "\t%qu output packet%s dropped due to no bufs, etc.\n");
	p(ip6s_noroute, "\t%qu output packet%s discarded due to no route\n");
	p(ip6s_fragmented, "\t%qu output datagram%s fragmented\n");
	p(ip6s_ofragments, "\t%qu fragment%s created\n");
	p(ip6s_cantfrag, "\t%qu datagram%s that can't be fragmented\n");
	p(ip6s_badscope, "\t%qu packet%s that violated scope rules\n");
	p(ip6s_notmember, "\t%qu multicast packet%s which we don't join\n");
d399 11
a409 2
			printf("\t\t%s: %qu\n", ip6nh[i],
			       ip6stat.ip6s_nxthist[i]);
d412 1
a412 1
	p(ip6s_m1, "\t\t%qu one mbuf%s\n");
d420 1
a420 1
			printf("\t\t\t%s = %qu\n",
d422 1
a422 1
			       ip6stat.ip6s_m2m[i]);
d425 7
a431 5
	p(ip6s_mext1, "\t\t%qu one ext mbuf%s\n");
	p(ip6s_mext2m, "\t\t%qu two or more ext mbuf%s\n");
	p(ip6s_exthdrtoolong, "\t%qu packet%s whose headers are not continuous\n");
	p(ip6s_nogif, "\t%qu tunneling packet%s that can't find gif\n");
	p(ip6s_toomanyhdr, "\t%qu packet%s discarded due to too many headers\n");
d437 1
a437 1
			p(s, "\t\t%qu node-local%s\n");\
d440 1
a440 1
			p(s,"\t\t%qu link-local%s\n");\
d443 1
a443 1
			p(s,"\t\t%qu site-local%s\n");\
d446 1
a446 1
			p(s,"\t\t%qu global%s\n");\
d449 2
a450 2
			printf("\t\t%qu addresses scope=%x\n",\
			       ip6stat.s, i);\
d455 1
a455 1
	  "\t%qu failure%s of source address selection\n");
d518 2
a519 1
    printf(m, ifr.ifr_ifru.ifru_stat.f, plural(ifr.ifr_ifru.ifru_stat.f))
d521 1
a521 1
    printf(m, ip6stat.f)
d536 8
a543 7
	p(ifs6_in_receive, "\t%qu total input datagram%s\n");
	p(ifs6_in_hdrerr, "\t%qu datagram%s with invalid header received\n");
	p(ifs6_in_toobig, "\t%qu datagram%s exceeded MTU received\n");
	p(ifs6_in_noroute, "\t%qu datagram%s with no route received\n");
	p(ifs6_in_addrerr, "\t%qu datagram%s with invalid dst received\n");
	p(ifs6_in_protounknown, "\t%qu datagram%s with unknown proto received\n");
	p(ifs6_in_discard, "\t%qu input datagram%s discarded\n");
d545 2
a546 2
	  "\t%qu datagram%s delivered to an upper layer protocol\n");
	p(ifs6_out_forward, "\t%qu datagram%s forwarded to this interface\n");
d548 10
a557 10
	  "\t%qu datagram%s sent from an upper layer protocol\n");
	p(ifs6_out_discard, "\t%qu total discarded output datagram%s\n");
	p(ifs6_out_fragok, "\t%qu output datagram%s fragmented\n");
	p(ifs6_out_fragfail, "\t%qu output datagram%s failed on fragment\n");
	p(ifs6_out_fragcreat, "\t%qu output datagram%s succeeded on fragment\n");
	p(ifs6_reass_reqd, "\t%qu incoming datagram%s fragmented\n");
	p(ifs6_reass_ok, "\t%qu datagram%s reassembled\n");
	p(ifs6_reass_fail, "\t%qu datagram%s failed on reassembling\n");
	p(ifs6_in_mcast, "\t%qu multicast datagram%s received\n");
	p(ifs6_out_mcast, "\t%qu multicast datagram%s sent\n");
d842 1
a842 1
    printf(m, icmp6stat.f, plural(icmp6stat.f))
d844 1
a844 1
    printf(m, icmp6stat.f)
d846 1
a846 1
	p(icp6s_error, "\t%qu call%s to icmp6_error\n");
d848 1
a848 1
	    "\t%qu error%s not generated because old message was icmp6 or so\n");
d850 1
a850 1
	    "\t%qu error%s not generated because of rate limitation\n");
d857 2
a858 2
			printf("\t\t%s: %qu\n", icmp6names[i],
				icmp6stat.icp6s_outhist[i]);
d860 4
a863 4
	p(icp6s_badcode, "\t%qu message%s with bad code fields\n");
	p(icp6s_tooshort, "\t%qu message%s < minimum length\n");
	p(icp6s_checksum, "\t%qu bad checksum%s\n");
	p(icp6s_badlen, "\t%qu message%s with bad length\n");
d870 2
a871 2
			printf("\t\t%s: %qu\n", icmp6names[i],
				icmp6stat.icp6s_inhist[i]);
d874 22
a895 16
	p_5(icp6s_odst_unreach_noroute, "\t\t%qu no route\n");
	p_5(icp6s_odst_unreach_admin, "\t\t%qu administratively prohibited\n");
	p_5(icp6s_odst_unreach_beyondscope, "\t\t%qu beyond scope\n");
	p_5(icp6s_odst_unreach_addr, "\t\t%qu address unreachable\n");
	p_5(icp6s_odst_unreach_noport, "\t\t%qu port unreachable\n");
	p_5(icp6s_opacket_too_big, "\t\t%qu packet too big\n");
	p_5(icp6s_otime_exceed_transit, "\t\t%qu time exceed transit\n");
	p_5(icp6s_otime_exceed_reassembly, "\t\t%qu time exceed reassembly\n");
	p_5(icp6s_oparamprob_header, "\t\t%qu erroneous header field\n");
	p_5(icp6s_oparamprob_nextheader, "\t\t%qu unrecognized next header\n");
	p_5(icp6s_oparamprob_option, "\t\t%qu unrecognized option\n");
	p_5(icp6s_oredirect, "\t\t%qu redirect\n");
	p_5(icp6s_ounknown, "\t\t%qu unknown\n");

	p(icp6s_reflect, "\t%qu message response%s generated\n");
	p(icp6s_nd_toomanyopt, "\t%qu message%s with too many ND options\n");
d897 1
a898 1
#undef p
d911 2
a912 1
    printf(m, (u_quad_t)ifr.ifr_ifru.ifru_icmp6stat.f, plural(ifr.ifr_ifru.ifru_icmp6stat.f))
d927 35
a961 35
	p(ifs6_in_msg, "\t%qu total input message%s\n");
	p(ifs6_in_error, "\t%qu total input error message%s\n"); 
	p(ifs6_in_dstunreach, "\t%qu input destination unreachable error%s\n");
	p(ifs6_in_adminprohib, "\t%qu input administratively prohibited error%s\n");
	p(ifs6_in_timeexceed, "\t%qu input time exceeded error%s\n");
	p(ifs6_in_paramprob, "\t%qu input parameter problem error%s\n");
	p(ifs6_in_pkttoobig, "\t%qu input packet too big error%s\n");
	p(ifs6_in_echo, "\t%qu input echo request%s\n");
	p(ifs6_in_echoreply, "\t%qu input echo reply%s\n");
	p(ifs6_in_routersolicit, "\t%qu input router solicitation%s\n");
	p(ifs6_in_routeradvert, "\t%qu input router advertisement%s\n");
	p(ifs6_in_neighborsolicit, "\t%qu input neighbor solicitation%s\n");
	p(ifs6_in_neighboradvert, "\t%qu input neighbor advertisement%s\n");
	p(ifs6_in_redirect, "\t%qu input redirect%s\n");
	p(ifs6_in_mldquery, "\t%qu input MLD query%s\n");
	p(ifs6_in_mldreport, "\t%qu input MLD report%s\n");
	p(ifs6_in_mlddone, "\t%qu input MLD done%s\n");

	p(ifs6_out_msg, "\t%qu total output message%s\n");
	p(ifs6_out_error, "\t%qu total output error message%s\n");
	p(ifs6_out_dstunreach, "\t%qu output destination unreachable error%s\n");
	p(ifs6_out_adminprohib, "\t%qu output administratively prohibited error%s\n");
	p(ifs6_out_timeexceed, "\t%qu output time exceeded error%s\n");
	p(ifs6_out_paramprob, "\t%qu output parameter problem error%s\n");
	p(ifs6_out_pkttoobig, "\t%qu output packet too big error%s\n");
	p(ifs6_out_echo, "\t%qu output echo request%s\n");
	p(ifs6_out_echoreply, "\t%qu output echo reply%s\n");
	p(ifs6_out_routersolicit, "\t%qu output router solicitation%s\n");
	p(ifs6_out_routeradvert, "\t%qu output router advertisement%s\n");
	p(ifs6_out_neighborsolicit, "\t%qu output neighbor solicitation%s\n");
	p(ifs6_out_neighboradvert, "\t%qu output neighbor advertisement%s\n");
	p(ifs6_out_redirect, "\t%qu output redirect%s\n");
	p(ifs6_out_mldquery, "\t%qu output MLD query%s\n");
	p(ifs6_out_mldreport, "\t%qu output MLD report%s\n");
	p(ifs6_out_mlddone, "\t%qu output MLD done%s\n");
d984 8
a991 8
    printf(m, pim6stat.f, plural(pim6stat.f))
	p(pim6s_rcv_total, "\t%qu message%s received\n");
	p(pim6s_rcv_tooshort, "\t%qu message%s received with too few bytes\n");
	p(pim6s_rcv_badsum, "\t%qu message%s received with bad checksum\n");
	p(pim6s_rcv_badversion, "\t%qu message%s received with bad version\n");
	p(pim6s_rcv_registers, "\t%qu register%s received\n");
	p(pim6s_rcv_badregisters, "\t%qu bad register%s received\n");
	p(pim6s_snd_registers, "\t%qu register%s sent\n");
d1007 1
a1007 1
{\
d1014 1
a1014 1
};
d1019 4
a1022 1
	sprintf(line, "%.*s.", (Aflag && !nflag) ? 12 : 16, inet6name(in6));
d1031 2
d1047 1
a1047 1
	static char line[50];
d1051 1
a1051 1
	static char hbuf[NI_MAXHOST];
d1078 1
a1078 1
		strcpy(line, "*");
d1080 1
a1080 1
		strcpy(line, cp);
d1097 1
a1097 1
		strncpy(line, hbuf, sizeof(line));
@


1.12
log
@show # of successful IPv6 path MTU changes with -s.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.11 2000/08/26 03:01:50 itojun Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.11 2000/08/26 03:01:50 itojun Exp $");*/
d833 1
a833 1
	    "\t%qu error%s not generated because rate limitation\n");
@


1.11
log
@typo. sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.10 2000/08/13 19:01:38 itojun Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.10 2000/08/13 19:01:38 itojun Exp $");*/
d873 1
@


1.10
log
@typo.  be more friendly with netstat -ssn.  from jhawk@@netbsd (via kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.9 2000/07/12 16:16:57 itojun Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.9 2000/07/12 16:16:57 itojun Exp $");*/
d416 1
a416 1
	p(ip6s_toomanyhdr, "\t%qu packet%s discarded due to too may headers\n");
@


1.9
log
@remove m_pulldown statistics, it is purely experimental and belongs to
kame system only (not for *bsd-merged systems).
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.8 2000/07/06 10:16:56 itojun Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.8 2000/07/06 10:16:56 itojun Exp $");*/
d398 2
a399 2
	printf("\tMbuf statics:\n");
	printf("\t\t%qu one mbuf\n", ip6stat.ip6s_m1);
d412 2
a413 2
	printf("\t\t%qu one ext mbuf\n", ip6stat.ip6s_mext1);
	printf("\t\t%qu two or more ext mbuf\n", ip6stat.ip6s_mext2m);	
@


1.8
log
@more stats
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.7 2000/06/16 02:10:50 itojun Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.7 2000/06/16 02:10:50 itojun Exp $");*/
a416 32

	if (ip6stat.ip6s_exthdrget || ip6stat.ip6s_exthdrget0) {
		p(ip6s_exthdrget, "\t%qu use%s of IP6_EXTHDR_GET\n");
		p(ip6s_exthdrget0, "\t%qu use%s of IP6_EXTHDR_GET0\n");
		p(ip6s_pulldown, "\t%qu call%s to m_pulldown\n");
		p(ip6s_pulldown_alloc,
		    "\t%qu mbuf allocation%s in m_pulldown\n");
		if (ip6stat.ip6s_pulldown_copy != 1) {
			p1(ip6s_pulldown_copy,
			    "\t%qu mbuf copies in m_pulldown\n");
		} else {
			p1(ip6s_pulldown_copy,
			    "\t%qu mbuf copy in m_pulldown\n");
		}
		p(ip6s_pullup, "\t%qu call%s to m_pullup\n");
		p(ip6s_pullup_alloc, "\t%qu mbuf allocation%s in m_pullup\n");
		if (ip6stat.ip6s_pullup_copy != 1) {
			p1(ip6s_pullup_copy, "\t%qu mbuf copies in m_pullup\n");
		} else {
			p1(ip6s_pullup_copy, "\t%qu mbuf copy in m_pullup\n");
		}
		p(ip6s_pullup_fail, "\t%qu failure%s in m_pullup\n");
		p(ip6s_pullup2, "\t%qu call%s to m_pullup2\n");
		p(ip6s_pullup2_alloc, "\t%qu mbuf allocation%s in m_pullup2\n");
		if (ip6stat.ip6s_pullup2_copy != 1) {
			p1(ip6s_pullup2_copy,
			    "\t%qu mbuf copies in m_pullup2\n");
		} else {
			p1(ip6s_pullup2_copy, "\t%qu mbuf copy in m_pullup2\n");
		}
		p(ip6s_pullup2_fail, "\t%qu failure%s in m_pullup2\n");
	}
@


1.7
log
@print # of icmp6 error suppressed by rate limit
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.6 2000/05/17 11:54:50 itojun Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.6 2000/05/17 11:54:50 itojun Exp $");*/
d518 3
d858 2
d888 15
d904 2
@


1.6
log
@s/icmp/icmp6/ in message
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.5 2000/02/28 11:57:32 itojun Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.5 2000/02/28 11:57:32 itojun Exp $");*/
d175 1
a175 1
	"#89",	
d859 2
@


1.5
log
@update IPv6 portion to match latest sys/netinet6.
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.4 2000/01/18 05:39:35 itojun Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.4 2000/01/18 05:39:35 itojun Exp $");*/
d856 1
a856 1
	p(icp6s_error, "\t%qu call%s to icmp_error\n");
d858 1
a858 1
	    "\t%qu error%s not generated because old message was icmp or so\n");
@


1.4
log
@print IPv6 multicast groups on -ia.
align multicast addresses on output (broken on 1.15 -> 1.16).
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.3 2000/01/05 00:07:08 itojun Exp $	*/
d41 2
a42 2
/*__RCSID("$OpenBSD: inet6.c,v 1.3 2000/01/05 00:07:08 itojun Exp $");*/
/*__RCSID("KAME Id: inet6.c,v 1.4 1999/12/02 04:47:27 itojun Exp");*/
d63 1
a64 1
#include <netinet6/ip6_var.h>
a84 90
#if 0
/*
 * Print a summary of connections related to an Internet
 * protocol.  For TCP, also give state of connection.
 * Listening processes (aflag) are suppressed unless the
 * -a (all) flag is specified.
 */
void
ip6protopr(off, name)
	u_long off;
	char *name;
{
	struct in6pcb cb;
	register struct in6pcb *prev, *next;
	int istcp;
	static int first = 1;

	if (off == 0)
		return;
	istcp = strcmp(name, "tcp6") == 0;
	kread(off, (char *)&cb, sizeof (struct in6pcb));
	in6pcb = cb;
	prev = (struct in6pcb *)off;
	if (in6pcb.in6p_next == (struct in6pcb *)off)
		return;
	while (in6pcb.in6p_next != (struct in6pcb *)off) {
		next = in6pcb.in6p_next;
		kread((u_long)next, (char *)&in6pcb, sizeof (in6pcb));
		if (in6pcb.in6p_prev != prev) {
			printf("???\n");
			break;
		}
		if (!aflag && IN6_IS_ADDR_UNSPECIFIED(&in6pcb.in6p_laddr)) {
			prev = next;
			continue;
		}
		kread((u_long)in6pcb.in6p_socket, (char *)&sockb, sizeof (sockb));
		if (istcp) {
#ifdef TCP6
			kread((u_long)in6pcb.in6p_ppcb,
			    (char *)&tcp6cb, sizeof (tcp6cb));
#else
			kread((u_long)in6pcb.in6p_ppcb,
			    (char *)&tcpcb, sizeof (tcpcb));
#endif
		}
		if (first) {
			printf("Active Internet6 connections");
			if (aflag)
				printf(" (including servers)");
			putchar('\n');
			if (Aflag)
				printf("%-8.8s ", "PCB");
			printf(Aflag ?
				"%-5.5s %-6.6s %-6.6s  %-18.18s %-18.18s %s\n" :
				"%-5.5s %-6.6s %-6.6s  %-22.22s %-22.22s %s\n",
				"Proto", "Recv-Q", "Send-Q",
				"Local Address", "Foreign Address", "(state)");
			first = 0;
		}
		if (Aflag) {
			if (istcp)
				printf("%8p ", in6pcb.in6p_ppcb);
			else
				printf("%8p ", next);
		}
		printf("%-5.5s %6ld %6ld ", name, sockb.so_rcv.sb_cc,
			sockb.so_snd.sb_cc);
		/* xxx */
		inet6print(&in6pcb.in6p_laddr, (int)in6pcb.in6p_lport, name);
		inet6print(&in6pcb.in6p_faddr, (int)in6pcb.in6p_fport, name);
		if (istcp) {
#ifdef TCP6
			if (tcp6cb.t_state < 0 || tcp6cb.t_state >= TCP6_NSTATES)
				printf(" %d", tcp6cb.t_state);
			else
				printf(" %s", tcp6states[tcp6cb.t_state]);
#else
			if (tcpcb.t_state < 0 || tcpcb.t_state >= TCP_NSTATES)
				printf(" %d", tcpcb.t_state);
			else
				printf(" %s", tcpstates[tcpcb.t_state]);
#endif
		}
		putchar('\n');
		prev = next;
	}
}
#endif

d398 2
a399 3
	if (ip6stat.ip6s_m1 || sflag <= 1)
		printf("\tMbuf statics:\n");
	p(ip6s_m1, "\t\t%qu one mbuf\n");
d412 2
a413 2
	p(ip6s_mext1, "\t\t%qu one ext mbuf\n");
	p(ip6s_mext2m, "\t\t%qu two or more ext mbuf\n");
d416 102
@


1.3
log
@s/input histogram/input packet/histogram/
suggested by: deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.2 1999/12/30 20:31:31 deraadt Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.2 1999/12/30 20:31:31 deraadt Exp $");*/
a62 1
#include <netinet6/in6_pcb.h>
a79 1
struct	in6pcb in6pcb;
@


1.2
log
@fix netstat -ss; some zeroed counters were displayed
@
text
@d1 1
a1 1
/*	$OpenBSD: inet6.c,v 1.1 1999/12/08 12:30:17 itojun Exp $	*/
d41 1
a41 1
/*__RCSID("$OpenBSD: inet6.c,v 1.1 1999/12/08 12:30:17 itojun Exp $");*/
d484 1
a484 1
				printf("\tInput histogram:\n");
d853 1
a853 1
				printf("\tOutput histogram:\n");
d866 1
a866 1
				printf("\tInput histogram:\n");
@


1.1
log
@add IPv6 support from KAME.  cleanup type matches with printf() format.
KAME_SCOPEID should be enabled after KAME get{addr,name}info(3) merge.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
/*__RCSID("$OpenBSD$");*/
d490 3
a492 2
	printf("\tMbuf statics:\n");
	printf("\t\t%qu one mbuf\n", ip6stat.ip6s_m1);
d505 2
a506 2
	printf("\t\t%qu one ext mbuf\n", ip6stat.ip6s_mext1);
	printf("\t\t%qu two or more ext mbuf\n", ip6stat.ip6s_mext2m);	
@

