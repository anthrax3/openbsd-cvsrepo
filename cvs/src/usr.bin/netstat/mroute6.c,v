head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.2
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.20.0.8
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.4
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.20
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.18
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.16
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.14
	OPENBSD_5_0:1.11.0.12
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.10
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.8
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.4
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.8.0.10
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.8
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.6
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.1.0.8
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2017.05.08.09.31.34;	author rzalamena;	state Exp;
branches;
next	1.22;
commitid	g4vmRD6EM6L2XiPR;

1.22
date	2016.12.22.11.04.44;	author rzalamena;	state Exp;
branches;
next	1.21;
commitid	T2qzeepA7r1EGy1x;

1.21
date	2016.08.27.04.13.43;	author guenther;	state Exp;
branches;
next	1.20;
commitid	zhvm7groPE9hsJC6;

1.20
date	2015.02.13.13.28.17;	author dcoppa;	state Exp;
branches;
next	1.19;
commitid	Vs6D3tzbQiaUXNmJ;

1.19
date	2015.02.12.23.31.12;	author claudio;	state Exp;
branches;
next	1.18;
commitid	subnpd857rOYrBI2;

1.18
date	2015.02.12.13.06.47;	author sthen;	state Exp;
branches;
next	1.17;
commitid	hJvQITX9Ktx1ErFv;

1.17
date	2015.02.09.12.25.03;	author claudio;	state Exp;
branches;
next	1.16;
commitid	83gy3puTH63xWYWh;

1.16
date	2015.01.17.07.09.50;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	i5jcZSY20P9dXR8J;

1.15
date	2015.01.16.06.40.10;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	Uu5nFG3wCl0LACBb;

1.14
date	2014.11.21.17.49.00;	author mikeb;	state Exp;
branches;
next	1.13;
commitid	lNiE9sUYcBWNesjg;

1.13
date	2014.06.23.03.46.17;	author guenther;	state Exp;
branches;
next	1.12;
commitid	uXnRK9VvnFZsAqfW;

1.12
date	2013.11.21.17.32.13;	author mikeb;	state Exp;
branches;
next	1.11;

1.11
date	2009.02.07.15.06.04;	author chl;	state Exp;
branches;
next	1.10;

1.10
date	2007.12.14.18.35.46;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.11.18.16.48;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.25.17.01.04;	author jaredy;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.03.02.56.13;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.01.01.51.31;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.02.01.30.24;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.27.01.50.36;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.17.21.34.58;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.12.30.17;	author itojun;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Make netstat(8) always ask for IPv6 multicast routing information. Worst
case is that we get an empty response instead of a message saying that
there is no multicast support.

ok mpi@@
@
text
@/*	$OpenBSD: mroute6.c,v 1.22 2016/12/22 11:04:44 rzalamena Exp $	*/

/*
 * Copyright (C) 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1989 Stephen Deering
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Stephen Deering of Stanford University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)mroute.c	8.2 (Berkeley) 4/28/95
 */

#include <sys/types.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <netinet/in.h>
#include <netinet6/ip6_mroute.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <util.h>
#include "netstat.h"

#define	WID_ORG	(lflag ? 39 : (nflag ? 29 : 18)) /* width of origin column */
#define	WID_GRP	(lflag ? 18 : (nflag ? 16 : 18)) /* width of group column */

void
mroute6pr(void)
{
	char *buf = NULL;
	char fmtbuf[FMT_SCALED_STRSIZE];
	struct mf6cinfo *mfc;
	struct mif6info *mif;
	size_t needed, mifi, nummifs, mfci, nummfcs;
	int banner_printed, saved_nflag;
	mifi_t maxmif = 0;
	u_int mrtproto;
	int mib[] = { CTL_NET, PF_INET6, IPPROTO_IPV6, IPV6CTL_MRTPROTO };
	size_t len = sizeof(int);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &mrtproto, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("mroute");
		return;
	}
	switch (mrtproto) {
	case 0:
		break;
	default:
		printf("IPv6 multicast routing protocol %u, unknown\n",
		    mrtproto);
		return;
	}

	saved_nflag = nflag;
	nflag = 1;

	mib[3] = IPV6CTL_MRTMIF;
	needed = get_sysctl(mib, sizeof(mib) / sizeof(mib[0]), &buf);
	nummifs = needed / sizeof(*mif);
	mif = (struct mif6info *)buf;
	if (nummifs)
		maxmif = mif[nummifs - 1].m6_mifi;

	banner_printed = 0;
	for (mifi = 0; mifi < nummifs; ++mifi, ++mif) {
		char ifname[IFNAMSIZ];

		if (mif->m6_ifindex == 0)
			continue;

		if (!banner_printed) {
			printf("\nIPv6 Multicast Interface Table\n"
			    " Mif   Rate   PhyIF   "
			    "Pkts-In   Pkts-Out\n");
			banner_printed = 1;
		}

		printf("  %2u   %4d",
		    mif->m6_mifi, mif->m6_rate_limit);
		printf("   %5s", (mif->m6_flags & MIFF_REGISTER) ?
		    "reg0" : if_indextoname(mif->m6_ifindex, ifname));

		printf(" %9llu  %9llu\n", mif->m6_pkt_in, mif->m6_pkt_out);
	}
	if (!banner_printed)
		printf("IPv6 Multicast Interface Table is empty\n");

	mib[3] = IPV6CTL_MRTMFC;
	needed = get_sysctl(mib, sizeof(mib) / sizeof(mib[0]), &buf);
	nummfcs = needed / sizeof(*mfc);
	mfc = (struct mf6cinfo *)buf;

	banner_printed = 0;
	for (mfci = 0; mfci < nummfcs; ++mfci, ++mfc) {
		if (!banner_printed) {
			printf("\nIPv6 Multicast Forwarding Cache\n");
			printf(" %-*.*s %-*.*s %s",
			    WID_ORG, WID_ORG, "Origin",
			    WID_GRP, WID_GRP, "Group",
			    "  Packets Waits In-Mif  Out-Mifs\n");
			banner_printed = 1;
		}

		printf(" %-*.*s", WID_ORG, WID_ORG,
		    routename6(&mfc->mf6c_origin));
		printf(" %-*.*s", WID_GRP, WID_GRP,
		    routename6(&mfc->mf6c_mcastgrp));
		fmt_scaled(mfc->mf6c_pkt_cnt, fmtbuf);
		printf(" %9s", fmtbuf);

		printf("   %3llu", mfc->mf6c_stall_cnt);

		if (mfc->mf6c_parent == MF6C_INCOMPLETE_PARENT)
			printf("  ---   ");
		else
			printf("  %3d   ", mfc->mf6c_parent);
		for (mifi = 0; mifi <= MAXMIFS; mifi++) {
			if (IF_ISSET(mifi, &mfc->mf6c_ifset))
				printf(" %zu", mifi);
		}
		printf("\n");
	}
	if (!banner_printed)
		printf("IPv6 Multicast Routing Table is empty");

	printf("\n");
	nflag = saved_nflag;

	free(buf);
}

void
mrt6_stats(void)
{
	struct mrt6stat mrt6stat;
	u_int mrt6proto;
	int mib[] = { CTL_NET, PF_INET6, IPPROTO_IPV6, IPV6CTL_MRTPROTO };
	int mib2[] = { CTL_NET, PF_INET6, IPPROTO_IPV6, IPV6CTL_MRTSTATS };
	size_t len = sizeof(int);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &mrt6proto, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("mroute");
		return;
	}
	switch (mrt6proto) {
	case 0:
		printf("no IPv6 multicast routing compiled into this system\n");
		return;
	default:
		printf("IPv6 multicast routing protocol %u, unknown\n",
		    mrt6proto);
		return;
	}

	len = sizeof(mrt6stat);
	if (sysctl(mib2, sizeof(mib2) / sizeof(mib2[0]),
	    &mrt6stat, &len, NULL, 0) == -1) {
		if (errno != ENOPROTOOPT)
			warn("mroute");
		return;
	}

	printf("multicast forwarding:\n");
	printf("\t%llu multicast forwarding cache lookup%s\n",
	    mrt6stat.mrt6s_mfc_lookups, plural(mrt6stat.mrt6s_mfc_lookups));
	printf("\t%llu multicast forwarding cache miss%s\n",
	    mrt6stat.mrt6s_mfc_misses, plurales(mrt6stat.mrt6s_mfc_misses));
	printf("\t%llu upcall%s to mrouted\n",
	    mrt6stat.mrt6s_upcalls, plural(mrt6stat.mrt6s_upcalls));
	printf("\t%llu upcall queue overflow%s\n",
	    mrt6stat.mrt6s_upq_ovflw, plural(mrt6stat.mrt6s_upq_ovflw));
	printf("\t%llu upcall%s dropped due to full socket buffer\n",
	    mrt6stat.mrt6s_upq_sockfull, plural(mrt6stat.mrt6s_upq_sockfull));
	printf("\t%llu cache cleanup%s\n",
	    mrt6stat.mrt6s_cache_cleanups, plural(mrt6stat.mrt6s_cache_cleanups));
	printf("\t%llu datagram%s with no route for origin\n",
	    mrt6stat.mrt6s_no_route, plural(mrt6stat.mrt6s_no_route));
	printf("\t%llu datagram%s arrived with bad tunneling\n",
	    mrt6stat.mrt6s_bad_tunnel, plural(mrt6stat.mrt6s_bad_tunnel));
	printf("\t%llu datagram%s could not be tunneled\n",
	    mrt6stat.mrt6s_cant_tunnel, plural(mrt6stat.mrt6s_cant_tunnel));
	printf("\t%llu datagram%s arrived on wrong interface\n",
	    mrt6stat.mrt6s_wrong_if, plural(mrt6stat.mrt6s_wrong_if));
	printf("\t%llu datagram%s selectively dropped\n",
	    mrt6stat.mrt6s_drop_sel, plural(mrt6stat.mrt6s_drop_sel));
	printf("\t%llu datagram%s dropped due to queue overflow\n",
	    mrt6stat.mrt6s_q_overflow, plural(mrt6stat.mrt6s_q_overflow));
	printf("\t%llu datagram%s dropped for being too large\n",
	    mrt6stat.mrt6s_pkt2large, plural(mrt6stat.mrt6s_pkt2large));
}
@


1.22
log
@Remove PIM support from the multicast stack.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.21 2016/08/27 04:13:43 guenther Exp $	*/
d108 1
a108 2
		printf("no IPv6 multicast routing compiled into this system\n");
		return;
@


1.21
log
@Pull in <sys/select.h> for howmany() and NBBY, used by various net*/*.h

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.20 2015/02/13 13:28:17 dcoppa Exp $	*/
a109 2
	case IPPROTO_PIM:
		break;
a212 2
	case IPPROTO_PIM:
		break;
@


1.20
log
@
implicit declaration of function 'free'; add missing stdlib.h

OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.19 2015/02/12 23:31:12 claudio Exp $	*/
d68 1
@


1.19
log
@Free the buffers used for the sysctl. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.18 2015/02/12 13:06:47 sthen Exp $	*/
d78 1
@


1.18
log
@Initialize buffer pointers passed to get_sysctl to NULL; otherwise they point
to random memory so when the sysctl-estimate is too small, the realloc() fails.
Problem reported by Ze Loff, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.17 2015/02/09 12:25:03 claudio Exp $	*/
d190 2
@


1.17
log
@Get rid of another KVM reader and convert the multicast output to use
the new sysctls. Looks good deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.16 2015/01/17 07:09:50 deraadt Exp $	*/
d87 1
a87 1
	char *buf;
@


1.16
log
@_KERNEL 1?  no, just _KERNEL
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.15 2015/01/16 06:40:10 deraadt Exp $	*/
a67 1
#include <sys/queue.h>
a68 1
#include <sys/protosw.h>
a71 2
#include <net/if_var.h>

a72 2

#define _KERNEL
a73 1
#undef _KERNEL
d78 1
d85 1
a85 1
mroute6pr(u_long mfcaddr, u_long mifaddr)
d87 7
a93 6
	int banner_printed, saved_nflag, waitings, i;
	struct mf6c *mf6ctable[MF6CTBLSIZ], *mfcp;
	struct mif6 mif6table[MAXMIFS], *mifp;
	struct rtdetq rte, *rtep;
	mifi_t maxmif = 0, mifi;
	struct mf6c mfc;
a115 9
	if (mfcaddr == 0) {
		printf("mf6ctable: symbol not in namelist\n");
		return;
	}
	if (mifaddr == 0) {
		printf("miftable: symbol not in namelist\n");
		return;
	}

d119 7
a125 1
	kread(mifaddr, &mif6table, sizeof(mif6table));
d127 1
a127 2
	for (mifi = 0, mifp = mif6table; mifi < MAXMIFS; ++mifi, ++mifp) {
		struct ifnet ifnet;
d130 1
a130 1
		if (mifp->m6_ifp == NULL)
a132 2
		kread((u_long)mifp->m6_ifp, &ifnet, sizeof(ifnet));
		maxmif = mifi;
d141 3
a143 3
		    mifi, mifp->m6_rate_limit);
		printf("   %5s", (mifp->m6_flags & MIFF_REGISTER) ?
		    "reg0" : if_indextoname(ifnet.if_index, ifname));
d145 1
a145 1
		printf(" %9llu  %9llu\n", mifp->m6_pkt_in, mifp->m6_pkt_out);
d150 5
a154 1
	kread(mfcaddr, &mf6ctable, sizeof(mf6ctable));
d156 9
a164 35
	for (i = 0; i < MF6CTBLSIZ; ++i) {
		mfcp = mf6ctable[i];
		while (mfcp) {
			kread((u_long)mfcp, &mfc, sizeof(mfc));
			if (!banner_printed) {
				printf("\nIPv6 Multicast Forwarding Cache\n");
				printf(" %-*.*s %-*.*s %s",
				    WID_ORG, WID_ORG, "Origin",
				    WID_GRP, WID_GRP, "Group",
				    "  Packets Waits In-Mif  Out-Mifs\n");
				banner_printed = 1;
			}

			printf(" %-*.*s", WID_ORG, WID_ORG,
			    routename6(&mfc.mf6c_origin));
			printf(" %-*.*s", WID_GRP, WID_GRP,
			    routename6(&mfc.mf6c_mcastgrp));
			printf(" %9llu", mfc.mf6c_pkt_cnt);

			for (waitings = 0, rtep = mfc.mf6c_stall; rtep; ) {
				waitings++;
				kread((u_long)rtep, &rte, sizeof(rte));
				rtep = rte.next;
			}
			printf("   %3d", waitings);

			if (mfc.mf6c_parent == MF6C_INCOMPLETE_PARENT)
				printf("  ---   ");
			else
				printf("  %3d   ", mfc.mf6c_parent);
			for (mifi = 0; mifi <= MAXMIFS; mifi++) {
				if (IF_ISSET(mifi, &mfc.mf6c_ifset))
					printf(" %u", mifi);
			}
			printf("\n");
d166 16
a181 1
			mfcp = mfc.mf6c_next;
d183 1
@


1.15
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.14 2014/11/21 17:49:00 mikeb Exp $	*/
d78 1
a78 1
#define _KERNEL 1
@


1.14
log
@remove pointless if_var.h and socketvar.h includes; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.13 2014/06/23 03:46:17 guenther Exp $	*/
d67 1
a67 1
#include <sys/param.h>
@


1.13
log
@The second level of the CTL_NET sysctl is a PF_*, not an AF_*

inconsistent usage in route(8) noted by Gregor Best (gbe (at) ring0.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.12 2013/11/21 17:32:13 mikeb Exp $	*/
a69 1
#include <sys/socketvar.h>
@


1.12
log
@split kernel parts of the if.h into a separate header file if_var.h
which allows us to modify ifnet structure in a relatively safe way;
discussed with deraadt, ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.11 2009/02/07 15:06:04 chl Exp $	*/
d101 1
a101 1
	int mib[] = { CTL_NET, AF_INET6, IPPROTO_IPV6, IPV6CTL_MRTPROTO };
d215 2
a216 2
	int mib[] = { CTL_NET, AF_INET6, IPPROTO_IPV6, IPV6CTL_MRTPROTO };
	int mib2[] = { CTL_NET, AF_INET6, IPPROTO_IPV6, IPV6CTL_MRTSTATS };
@


1.11
log
@add missing headers needed for warn() and err().

ok claudio@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.10 2007/12/14 18:35:46 deraadt Exp $	*/
d75 1
@


1.10
log
@remove 21 nlist variables, and instead use sysctl to query the kernel
turn on INET6 the default (remove the #ifdef's)
ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.9 2007/09/11 18:16:48 henning Exp $	*/
d82 2
a84 1
#include <errno.h>
@


1.9
log
@u_quad_t -> u_int64_t and %qu -> %llu, from brad
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.8 2005/03/25 17:01:04 jaredy Exp $	*/
d72 1
d83 1
a85 2
#ifdef INET6

d90 1
a90 1
mroute6pr(u_long mrpaddr, u_long mfcaddr, u_long mifaddr)
d99 2
d102 4
a105 2
	if (mrpaddr == 0) {
		printf("mroute6pr: symbol not in namelist\n");
a107 2

	kread(mrpaddr, &mrtproto, sizeof(mrtproto));
a108 1

a111 1

a113 1

d158 1
a158 1
		printf("\nIPv6 Multicast Interface Table is empty\n");
d167 1
a167 1
				printf ("\nIPv6 Multicast Forwarding Cache\n");
d202 1
a202 1
		printf("\nIPv6 Multicast Routing Table is empty\n");
d209 1
a209 1
mrt6_stats(u_long mrpaddr, u_long mstaddr)
d211 10
a220 5
	struct mrt6stat mrtstat;
	u_int mrtproto;

	if (mrpaddr == 0) {
		printf("mrt6_stats: symbol not in namelist\n");
d223 1
a223 3

	kread(mrpaddr, &mrtproto, sizeof(mrtproto));
	switch (mrtproto) {
d225 2
a226 3
		 printf("no IPv6 multicast routing compiled into this system\n");
		 return;

d228 1
a228 2
		 break;

d231 1
a231 1
		    mrtproto);
d235 5
a239 2
	if (mstaddr == 0) {
		printf("mrt6_stats: symbol not in namelist\n");
a242 1
	kread(mstaddr, &mrtstat, sizeof(mrtstat));
d244 26
a269 26
	printf(" %10llu multicast forwarding cache lookup%s\n",
	    mrtstat.mrt6s_mfc_lookups, plural(mrtstat.mrt6s_mfc_lookups));
	printf(" %10llu multicast forwarding cache miss%s\n",
	    mrtstat.mrt6s_mfc_misses, plurales(mrtstat.mrt6s_mfc_misses));
	printf(" %10llu upcall%s to mrouted\n",
	    mrtstat.mrt6s_upcalls, plural(mrtstat.mrt6s_upcalls));
	printf(" %10llu upcall queue overflow%s\n",
	    mrtstat.mrt6s_upq_ovflw, plural(mrtstat.mrt6s_upq_ovflw));
	printf(" %10llu upcall%s dropped due to full socket buffer\n",
	    mrtstat.mrt6s_upq_sockfull, plural(mrtstat.mrt6s_upq_sockfull));
	printf(" %10llu cache cleanup%s\n",
	    mrtstat.mrt6s_cache_cleanups, plural(mrtstat.mrt6s_cache_cleanups));
	printf(" %10llu datagram%s with no route for origin\n",
	    mrtstat.mrt6s_no_route, plural(mrtstat.mrt6s_no_route));
	printf(" %10llu datagram%s arrived with bad tunneling\n",
	    mrtstat.mrt6s_bad_tunnel, plural(mrtstat.mrt6s_bad_tunnel));
	printf(" %10llu datagram%s could not be tunneled\n",
	    mrtstat.mrt6s_cant_tunnel, plural(mrtstat.mrt6s_cant_tunnel));
	printf(" %10llu datagram%s arrived on wrong interface\n",
	    mrtstat.mrt6s_wrong_if, plural(mrtstat.mrt6s_wrong_if));
	printf(" %10llu datagram%s selectively dropped\n",
	    mrtstat.mrt6s_drop_sel, plural(mrtstat.mrt6s_drop_sel));
	printf(" %10llu datagram%s dropped due to queue overflow\n",
	    mrtstat.mrt6s_q_overflow, plural(mrtstat.mrt6s_q_overflow));
	printf(" %10llu datagram%s dropped for being too large\n",
	    mrtstat.mrt6s_pkt2large, plural(mrtstat.mrt6s_pkt2large));
a270 1
#endif /*INET6*/
@


1.8
log
@kill unneeded (char *) casts.  ok millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.7 2003/06/03 02:56:13 millert Exp $	*/
d156 1
a156 1
		printf(" %9qu  %9qu\n", mifp->m6_pkt_in, mifp->m6_pkt_out);
d180 1
a180 1
			printf(" %9qu", mfc.mf6c_pkt_cnt);
d242 1
a242 1
	printf(" %10qu multicast forwarding cache lookup%s\n",
d244 1
a244 1
	printf(" %10qu multicast forwarding cache miss%s\n",
d246 1
a246 1
	printf(" %10qu upcall%s to mrouted\n",
d248 1
a248 1
	printf(" %10qu upcall queue overflow%s\n",
d250 1
a250 1
	printf(" %10qu upcall%s dropped due to full socket buffer\n",
d252 1
a252 1
	printf(" %10qu cache cleanup%s\n",
d254 1
a254 1
	printf(" %10qu datagram%s with no route for origin\n",
d256 1
a256 1
	printf(" %10qu datagram%s arrived with bad tunneling\n",
d258 1
a258 1
	printf(" %10qu datagram%s could not be tunneled\n",
d260 1
a260 1
	printf(" %10qu datagram%s arrived on wrong interface\n",
d262 1
a262 1
	printf(" %10qu datagram%s selectively dropped\n",
d264 1
a264 1
	printf(" %10qu datagram%s dropped due to queue overflow\n",
d266 1
a266 1
	printf(" %10qu datagram%s dropped for being too large\n",
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.6 2003/02/01 01:51:31 deraadt Exp $	*/
d105 1
a105 1
	kread(mrpaddr, (char *)&mrtproto, sizeof(mrtproto));
d133 1
a133 1
	kread(mifaddr, (char *)&mif6table, sizeof(mif6table));
d142 1
a142 1
		kread((u_long)mifp->m6_ifp, (char *)&ifnet, sizeof(ifnet));
d161 1
a161 1
	kread(mfcaddr, (char *)&mf6ctable, sizeof(mf6ctable));
d166 1
a166 1
			kread((u_long)mfcp, (char *)&mfc, sizeof(mfc));
d184 1
a184 1
				kread((u_long)rtep, (char *)&rte, sizeof(rte));
d220 1
a220 1
	kread(mrpaddr, (char *)&mrtproto, sizeof(mrtproto));
d240 1
a240 1
	kread(mstaddr, (char *)&mrtstat, sizeof(mrtstat));
@


1.6
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.5 2002/06/02 01:30:24 deraadt Exp $	*/
d48 1
a48 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.5
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.4 2002/05/27 01:50:36 deraadt Exp $	*/
d94 1
a94 2
mroute6pr(mrpaddr, mfcaddr, mifaddr)
	u_long mrpaddr, mfcaddr, mifaddr;
d96 1
a96 1
	u_int mrtproto;
d98 3
a100 1
	struct mif6 mif6table[MAXMIFS];
d102 1
a102 8
	struct rtdetq rte, *rtep;
	struct mif6 *mifp;
	mifi_t mifi;
	int i;
	int banner_printed;
	int saved_nflag;
	mifi_t maxmif = 0;
	int waitings;
d121 1
a121 1
			mrtproto);
d214 1
a214 2
mrt6_stats(mrpaddr, mstaddr)
	u_long mrpaddr, mstaddr;
d216 1
a217 1
	struct mrt6stat mrtstat;
d255 1
a255 1
	      mrtstat.mrt6s_upq_sockfull, plural(mrtstat.mrt6s_upq_sockfull));
@


1.4
log
@a night of cleanup, so i can read this easier
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.3 2002/01/17 21:34:58 mickey Exp $	*/
d118 3
a120 3
	 case 0:
		 printf("no IPv6 multicast routing compiled into this system\n");
		 return;
d122 2
a123 2
	 case IPPROTO_PIM:
		 break;
d125 2
a126 2
	 default:
		 printf("IPv6 multicast routing protocol %u, unknown\n",
d128 1
a128 1
		 return;
d156 2
a157 2
			       " Mif   Rate   PhyIF   "
			       "Pkts-In   Pkts-Out\n");
d162 1
a162 1
		       mifi, mifp->m6_rate_limit);
d164 1
a164 1
		       "reg0" : if_indextoname(ifnet.if_index, ifname));
d180 3
a182 3
				       WID_ORG, WID_ORG, "Origin",
				       WID_GRP, WID_GRP, "Group",
				       "  Packets Waits In-Mif  Out-Mifs\n");
d187 1
a187 1
			       routename6(&mfc.mf6c_origin));
d189 1
a189 1
			       routename6(&mfc.mf6c_mcastgrp));
d241 3
a243 3
		 printf("IPv6 multicast routing protocol %u, unknown\n",
			mrtproto);
		 return;
d254 1
a254 1
	       mrtstat.mrt6s_mfc_lookups, plural(mrtstat.mrt6s_mfc_lookups));
d256 1
a256 1
	       mrtstat.mrt6s_mfc_misses, plurales(mrtstat.mrt6s_mfc_misses));
d258 1
a258 1
	       mrtstat.mrt6s_upcalls, plural(mrtstat.mrt6s_upcalls));
d260 1
a260 1
	  mrtstat.mrt6s_upq_ovflw, plural(mrtstat.mrt6s_upq_ovflw));
d262 1
a262 1
	  mrtstat.mrt6s_upq_sockfull, plural(mrtstat.mrt6s_upq_sockfull));
d264 1
a264 1
	  mrtstat.mrt6s_cache_cleanups, plural(mrtstat.mrt6s_cache_cleanups));
d266 1
a266 1
	  mrtstat.mrt6s_no_route, plural(mrtstat.mrt6s_no_route));
d268 1
a268 1
	  mrtstat.mrt6s_bad_tunnel, plural(mrtstat.mrt6s_bad_tunnel));
d270 1
a270 1
	  mrtstat.mrt6s_cant_tunnel, plural(mrtstat.mrt6s_cant_tunnel));
d272 1
a272 1
	  mrtstat.mrt6s_wrong_if, plural(mrtstat.mrt6s_wrong_if));
d274 1
a274 1
	  mrtstat.mrt6s_drop_sel, plural(mrtstat.mrt6s_drop_sel));
d276 1
a276 1
	  mrtstat.mrt6s_q_overflow, plural(mrtstat.mrt6s_q_overflow));
d278 1
a278 1
	  mrtstat.mrt6s_pkt2large, plural(mrtstat.mrt6s_pkt2large));
@


1.3
log
@evil, annoying spaces and tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.2 2001/11/19 19:02:15 mpech Exp $	*/
d175 1
a175 1
		while(mfcp) {
d226 1
a226 1
	if(mrpaddr == 0) {
d233 1
a233 1
	 case 0:
d237 1
a237 1
	 case IPPROTO_PIM:
d240 1
a240 1
	 default:
@


1.2
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mroute6.c,v 1.1 1999/12/08 12:30:17 itojun Exp $	*/
d6 1
a6 1
 * 
d18 1
a18 1
 * 
d185 1
a185 1
			
@


1.1
log
@add IPv6 support from KAME.  cleanup type matches with printf() format.
KAME_SCOPEID should be enabled after KAME get{addr,name}info(3) merge.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d102 5
a106 5
	register struct mif6 *mifp;
	register mifi_t mifi;
	register int i;
	register int banner_printed;
	register int saved_nflag;
@

