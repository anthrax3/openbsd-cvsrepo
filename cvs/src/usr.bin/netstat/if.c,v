head	1.74;
access;
symbols
	OPENBSD_6_0:1.74.0.4
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.74.0.2
	OPENBSD_5_9_BASE:1.74
	OPENBSD_5_8:1.73.0.6
	OPENBSD_5_8_BASE:1.73
	OPENBSD_5_7:1.73.0.2
	OPENBSD_5_7_BASE:1.73
	OPENBSD_5_6:1.68.0.4
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.67.0.4
	OPENBSD_5_5_BASE:1.67
	OPENBSD_5_4:1.66.0.4
	OPENBSD_5_4_BASE:1.66
	OPENBSD_5_3:1.66.0.2
	OPENBSD_5_3_BASE:1.66
	OPENBSD_5_2:1.64.0.6
	OPENBSD_5_2_BASE:1.64
	OPENBSD_5_1_BASE:1.64
	OPENBSD_5_1:1.64.0.4
	OPENBSD_5_0:1.64.0.2
	OPENBSD_5_0_BASE:1.64
	OPENBSD_4_9:1.63.0.2
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.62.0.4
	OPENBSD_4_8_BASE:1.62
	OPENBSD_4_7:1.62.0.2
	OPENBSD_4_7_BASE:1.62
	OPENBSD_4_6:1.60.0.6
	OPENBSD_4_6_BASE:1.60
	OPENBSD_4_5:1.60.0.2
	OPENBSD_4_5_BASE:1.60
	OPENBSD_4_4:1.57.0.2
	OPENBSD_4_4_BASE:1.57
	OPENBSD_4_3:1.56.0.2
	OPENBSD_4_3_BASE:1.56
	OPENBSD_4_2:1.51.0.2
	OPENBSD_4_2_BASE:1.51
	OPENBSD_4_1:1.49.0.2
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.48.0.2
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.46.0.2
	OPENBSD_3_9_BASE:1.46
	OPENBSD_3_8:1.44.0.2
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.42.0.2
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.39.0.2
	OPENBSD_3_6_BASE:1.39
	OPENBSD_3_5:1.38.0.2
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	OPENBSD_3_3:1.33.0.2
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	OPENBSD_2_6:1.17.0.8
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.17.0.6
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.17.0.4
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.17.0.2
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.16.0.2
	OPENBSD_2_2_BASE:1.16
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.74
date	2015.10.05.15.40.39;	author uebayasi;	state Exp;
branches;
next	1.73;
commitid	IQSLYkMRLuB7gZwy;

1.73
date	2015.02.12.13.06.47;	author sthen;	state Exp;
branches;
next	1.72;
commitid	hJvQITX9Ktx1ErFv;

1.72
date	2015.02.09.12.25.03;	author claudio;	state Exp;
branches;
next	1.71;
commitid	83gy3puTH63xWYWh;

1.71
date	2015.02.08.04.25.56;	author claudio;	state Exp;
branches;
next	1.70;
commitid	KHq1PapEy3sdEhoi;

1.70
date	2015.01.16.06.40.09;	author deraadt;	state Exp;
branches;
next	1.69;
commitid	Uu5nFG3wCl0LACBb;

1.69
date	2014.11.21.17.49.00;	author mikeb;	state Exp;
branches;
next	1.68;
commitid	lNiE9sUYcBWNesjg;

1.68
date	2014.06.23.03.46.17;	author guenther;	state Exp;
branches;
next	1.67;
commitid	uXnRK9VvnFZsAqfW;

1.67
date	2013.11.21.17.32.13;	author mikeb;	state Exp;
branches;
next	1.66;

1.66
date	2012.08.26.19.42.53;	author tedu;	state Exp;
branches;
next	1.65;

1.65
date	2012.08.22.00.11.57;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2011.07.09.00.45.40;	author henning;	state Exp;
branches;
next	1.63;

1.63
date	2011.01.09.19.12.19;	author tedu;	state Exp;
branches;
next	1.62;

1.62
date	2009.11.22.22.22.14;	author tedu;	state Exp;
branches;
next	1.61;

1.61
date	2009.08.04.03.45.47;	author tedu;	state Exp;
branches;
next	1.60;

1.60
date	2009.02.07.15.06.04;	author chl;	state Exp;
branches;
next	1.59;

1.59
date	2009.01.26.20.30.26;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2008.12.24.16.53.22;	author dhill;	state Exp;
branches;
next	1.57;

1.57
date	2008.03.18.20.03.37;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2008.01.03.21.01.40;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2007.12.19.01.47.00;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2007.12.14.18.35.46;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.11.16.14.41;	author mk;	state Exp;
branches;
next	1.52;

1.52
date	2007.09.05.20.27.04;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.15.01.25.05;	author ray;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.04.12.20.24;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.27.19.24.01;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.27.19.16.37;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.11.17.25.03;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2005.10.17.19.09.36;	author otto;	state Exp;
branches;
next	1.44;

1.44
date	2005.06.08.04.47.04;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.25.17.01.03;	author jaredy;	state Exp;
branches;
next	1.42;

1.42
date	2005.03.13.16.05.50;	author mpf;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.04.20.22.16;	author jaredy;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.02.16.47.56;	author dhartmei;	state Exp;
branches;
next	1.39;

1.39
date	2004.06.25.20.05.40;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.13.22.02.13;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2003.09.26.06.17.02;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.10.00.06.51;	author david;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.03.02.56.13;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.14.23.37.05;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2003.02.01.01.51.31;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.19.23.40.20;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.19.15.12.09;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.27.01.50.36;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2002.02.16.21.27.50;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.17.21.34.58;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.04.23.35.59;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.26.09.42.04;	author brian;	state Exp;
branches;
next	1.24;

1.24
date	2001.07.18.17.17.39;	author pvalchev;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.06.05.24.10;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2000.12.13.15.52.58;	author camield;	state Exp;
branches;
next	1.21;

1.21
date	2000.10.23.19.17.08;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.05.18.46.50;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.18.05.39.34;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	99.12.08.12.30.17;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	98.02.27.12.07.32;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.07.25.04.28.59;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.07.23.04.38.33;	author denny;	state Exp;
branches;
next	1.14;

1.14
date	97.06.30.03.11.53;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.06.29.21.46.00;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.06.29.20.52.39;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.06.29.20.17.58;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.01.17.07.12.55;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.08.16.09.38.56;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.08.16.09.29.32;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.06.26.05.37.20;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.06.18.09.58.05;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.06.16.12.42.29;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.10.07.48.31;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.10.13.02.34;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.31.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.50;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.50;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Handle ifi_oqdrops in netstat(8).

OK mpi@@ dlg@@
@
text
@/*	$OpenBSD$	*/
/*	$NetBSD: if.c,v 1.16.4.2 1996/06/07 21:46:46 thorpej Exp $	*/

/*
 * Copyright (c) 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* roundup() */
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>
#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/if_ether.h>
#include <arpa/inet.h>

#include <err.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include "netstat.h"

static void print_addr(struct sockaddr *, struct sockaddr **, struct if_data *);
static void sidewaysintpr(u_int, int);
static void catchalarm(int);
static void get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
static void fetchifs(void);

/*
 * Print a description of the network interfaces.
 * NOTE: ifnetaddr is the location of the kernel global "ifnet",
 * which is a TAILQ_HEAD.
 */
void
intpr(int interval, int repeatcount)
{
	struct if_msghdr ifm;
	int mib[6] = { CTL_NET, PF_ROUTE, 0, 0, NET_RT_IFLIST, 0 };
	char name[IFNAMSIZ + 1];	/* + 1 for the '*' */
	char *buf = NULL, *next, *lim, *cp;
	struct rt_msghdr *rtm;
	struct ifa_msghdr *ifam;
	struct if_data *ifd;
	struct sockaddr *sa, *rti_info[RTAX_MAX];
	struct sockaddr_dl *sdl;
	u_int64_t total = 0;
	size_t len;

	if (interval) {
		sidewaysintpr((unsigned)interval, repeatcount);
		return;
	}

	len = get_sysctl(mib, 6, &buf);

	printf("%-7.7s %-5.5s %-11.11s %-17.17s ",
	    "Name", "Mtu", "Network", "Address");
	if (bflag)
		printf("%10.10s %10.10s", "Ibytes", "Obytes");
	else
		printf("%8.8s %5.5s %8.8s %5.5s %5.5s",
		    "Ipkts", "Ierrs", "Opkts", "Oerrs", "Colls");
	if (tflag)
		printf(" %s", "Time");
	if (dflag)
		printf(" %s", "Drop");
	putchar('\n');

	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		switch (rtm->rtm_type) {
		case RTM_IFINFO:
			total = 0;
			bcopy(next, &ifm, sizeof ifm);
			ifd = &ifm.ifm_data;

			sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
			get_rtaddrs(ifm.ifm_addrs, sa, rti_info);

			sdl = (struct sockaddr_dl *)rti_info[RTAX_IFP];
			if (sdl == NULL || sdl->sdl_family != AF_LINK)
				continue;
			bzero(name, sizeof(name));
			if (sdl->sdl_nlen >= IFNAMSIZ)
				memcpy(name, sdl->sdl_data, IFNAMSIZ - 1);
			else if (sdl->sdl_nlen > 0) 
				memcpy(name, sdl->sdl_data, sdl->sdl_nlen);

			if (interface != 0 && strcmp(name, interface) != 0)
				continue;

			/* mark inactive interfaces with a '*' */
			cp = strchr(name, '\0');
			if ((ifm.ifm_flags & IFF_UP) == 0)
				*cp++ = '*';
			*cp = '\0';

			if (qflag) {
				total = ifd->ifi_ibytes + ifd->ifi_obytes +
				    ifd->ifi_ipackets + ifd->ifi_ierrors +
				    ifd->ifi_opackets + ifd->ifi_oerrors +
				    ifd->ifi_collisions;
				if (tflag)
					total += 0; // XXX ifnet.if_timer;
				if (dflag)
					total += ifd->ifi_oqdrops;
				if (total == 0)
					continue;
			}

			printf("%-7s %-5d ", name, ifd->ifi_mtu);
			print_addr(rti_info[RTAX_IFP], rti_info, ifd);
			break;
		case RTM_NEWADDR:
			if (qflag && total == 0)
				continue;
			if (interface != 0 && strcmp(name, interface) != 0)
				continue;

			ifam = (struct ifa_msghdr *)next;
			if ((ifam->ifam_addrs & (RTA_NETMASK | RTA_IFA |
			    RTA_BRD)) == 0)
				break;

			sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
			get_rtaddrs(ifam->ifam_addrs, sa, rti_info);

			printf("%-7s %-5d ", name, ifd->ifi_mtu);
			print_addr(rti_info[RTAX_IFA], rti_info, ifd);
			break;
		}
	}
	free(buf);
}

static void
print_addr(struct sockaddr *sa, struct sockaddr **rtinfo, struct if_data *ifd)
{
	struct sockaddr_dl *sdl;
	struct sockaddr_in *sin;
	struct sockaddr_in6 *sin6;
	char *cp;
	int m, n;

	switch (sa->sa_family) {
	case AF_UNSPEC:
		printf("%-11.11s ", "none");
		printf("%-17.17s ", "none");
		break;
	case AF_INET:
		sin = (struct sockaddr_in *)sa;
		cp = netname4(sin->sin_addr.s_addr,
		    ((struct sockaddr_in *)rtinfo[RTAX_NETMASK])->sin_addr.s_addr);
		if (vflag)
			n = strlen(cp) < 11 ? 11 : strlen(cp);
		else
			n = 11;
		printf("%-*.*s ", n, n, cp);
		cp = routename4(sin->sin_addr.s_addr);
		if (vflag)
			n = strlen(cp) < 17 ? 17 : strlen(cp);
		else
			n = 17;
		printf("%-*.*s ", n, n, cp);

		break;
	case AF_INET6:
		sin6 = (struct sockaddr_in6 *)sa;
#ifdef __KAME__
		if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {
			sin6->sin6_scope_id =
			    ntohs(*(u_int16_t *)
			    &sin6->sin6_addr.s6_addr[2]);
			sin6->sin6_addr.s6_addr[2] = 0;
			sin6->sin6_addr.s6_addr[3] = 0;
		}
#endif
		cp = netname6(sin6,
		    (struct sockaddr_in6 *)rtinfo[RTAX_NETMASK]);
		if (vflag)
			n = strlen(cp) < 11 ? 11 : strlen(cp);
		else
			n = 11;
		printf("%-*.*s ", n, n, cp);
		cp = routename6(sin6);
		if (vflag)
			n = strlen(cp) < 17 ? 17 : strlen(cp);
		else
			n = 17;
		printf("%-*.*s ", n, n, cp);
		break;
	case AF_LINK:
		sdl = (struct sockaddr_dl *)sa;
		m = printf("%-11.11s ", "<Link>");
		if (sdl->sdl_type == IFT_ETHER ||
		    sdl->sdl_type == IFT_CARP ||
		    sdl->sdl_type == IFT_FDDI ||
		    sdl->sdl_type == IFT_ISO88025)
			printf("%-17.17s ",
			    ether_ntoa((struct ether_addr *)LLADDR(sdl)));
		else {
			cp = (char *)LLADDR(sdl);
			n = sdl->sdl_alen;
			goto hexprint;
		}
		break;
	default:
		m = printf("(%d)", sa->sa_family);
		for (cp = sa->sa_len + (char *)sa;
			--cp > sa->sa_data && (*cp == 0);) {}
		n = cp - sa->sa_data + 1;
		cp = sa->sa_data;
hexprint:
		while (--n >= 0)
			m += printf("%x%c", *cp++ & 0xff,
				    n > 0 ? '.' : ' ');
		m = 30 - m;
		while (m-- > 0)
			putchar(' ');
		break;
	}
	if (bflag) {
		if (hflag) {
			char ibytes[FMT_SCALED_STRSIZE];
			char obytes[FMT_SCALED_STRSIZE];
			fmt_scaled(ifd->ifi_ibytes, ibytes);
			fmt_scaled(ifd->ifi_obytes, obytes);
			printf("%10s %10s", ibytes, obytes);
		} else
			printf("%10llu %10llu",
			    ifd->ifi_ibytes, ifd->ifi_obytes);
	} else
		printf("%8llu %5llu %8llu %5llu %5llu",
		    ifd->ifi_ipackets, ifd->ifi_ierrors,
		    ifd->ifi_opackets, ifd->ifi_oerrors,
		    ifd->ifi_collisions);
	if (tflag)
		printf(" %4d", 0 /* XXX ifnet.if_timer */);
	if (dflag)
		printf(" %5llu", ifd->ifi_oqdrops);
	putchar('\n');
}

struct	iftot {
	char	ift_name[IFNAMSIZ];	/* interface name */
	u_int64_t ift_ip;		/* input packets */
	u_int64_t ift_ib;		/* input bytes */
	u_int64_t ift_ie;		/* input errors */
	u_int64_t ift_op;		/* output packets */
	u_int64_t ift_ob;		/* output bytes */
	u_int64_t ift_oe;		/* output errors */
	u_int64_t ift_co;		/* collisions */
	u_int64_t ift_dr;		/* drops */
} ip_cur, ip_old, sum_cur, sum_old;

volatile sig_atomic_t signalled;	/* set if alarm goes off "early" */

/*
 * Print a running summary of interface statistics.
 * Repeat display every interval seconds, showing statistics
 * collected over that interval.  Assumes that interval is non-zero.
 * First line printed at top of screen is always cumulative.
 */
static void
sidewaysintpr(unsigned int interval, int repeatcount)
{
	sigset_t emptyset;
	int line;
	char ibytes[FMT_SCALED_STRSIZE];
	char obytes[FMT_SCALED_STRSIZE];

	fetchifs();
	if (ip_cur.ift_name[0] == '\0') {
		fprintf(stderr, "%s: %s: unknown interface\n",
		    __progname, interface);
		exit(1);
	}

	(void)signal(SIGALRM, catchalarm);
	signalled = 0;
	(void)alarm(interval);
banner:
	if (bflag)
		printf("%7.7s in %8.8s %6.6s out %5.5s",
		    ip_cur.ift_name, " ",
		    ip_cur.ift_name, " ");
	else
		printf("%5.5s in %5.5s%5.5s out %5.5s %5.5s",
		    ip_cur.ift_name, " ",
		    ip_cur.ift_name, " ", " ");
	if (dflag)
		printf(" %5.5s", " ");

	if (bflag)
		printf("  %7.7s in %8.8s %6.6s out %5.5s",
		    "total", " ", "total", " ");
	else
		printf("  %5.5s in %5.5s%5.5s out %5.5s %5.5s",
		    "total", " ", "total", " ", " ");
	if (dflag)
		printf(" %5.5s", " ");
	putchar('\n');
	if (bflag)
		printf("%10.10s %8.8s %10.10s %5.5s",
		    "bytes", " ", "bytes", " ");
	else
		printf("%8.8s %5.5s %8.8s %5.5s %5.5s",
		    "packets", "errs", "packets", "errs", "colls");
	if (dflag)
		printf(" %5.5s", "drops");

	if (bflag)
		printf("%10.10s %8.8s %10.10s %5.5s",
		    "bytes", " ", "bytes", " ");
	else
		printf("  %8.8s %5.5s %8.8s %5.5s %5.5s",
		    "packets", "errs", "packets", "errs", "colls");
	if (dflag)
		printf(" %5.5s", "drops");
	putchar('\n');
	fflush(stdout);
	line = 0;
	bzero(&ip_old, sizeof(ip_old));
	bzero(&sum_old, sizeof(sum_old));
loop:
	bzero(&sum_cur, sizeof(sum_cur));

	fetchifs();

	if (bflag) {
		if (hflag) {
			fmt_scaled(ip_cur.ift_ib - ip_old.ift_ib, ibytes);
			fmt_scaled(ip_cur.ift_ob - ip_old.ift_ob, obytes);
			printf("%10s %8.8s %10s %5.5s",
			    ibytes, " ", obytes, " ");
		} else
			printf("%10llu %8.8s %10llu %5.5s",
			    ip_cur.ift_ib - ip_old.ift_ib, " ",
			    ip_cur.ift_ob - ip_old.ift_ob, " ");
	} else
		printf("%8llu %5llu %8llu %5llu %5llu",
		    ip_cur.ift_ip - ip_old.ift_ip,
		    ip_cur.ift_ie - ip_old.ift_ie,
		    ip_cur.ift_op - ip_old.ift_op,
		    ip_cur.ift_oe - ip_old.ift_oe,
		    ip_cur.ift_co - ip_old.ift_co);
	if (dflag)
		printf(" %5llu",
		    ip_cur.ift_dr - ip_old.ift_dr);

	ip_old = ip_cur;

	if (bflag) {
		if (hflag) {
			fmt_scaled(sum_cur.ift_ib - sum_old.ift_ib, ibytes);
			fmt_scaled(sum_cur.ift_ob - sum_old.ift_ob, obytes);
			printf("  %10s %8.8s %10s %5.5s",
			    ibytes, " ", obytes, " ");
		} else
			printf("  %10llu %8.8s %10llu %5.5s",
			    sum_cur.ift_ib - sum_old.ift_ib, " ",
			    sum_cur.ift_ob - sum_old.ift_ob, " ");
	} else
		printf("  %8llu %5llu %8llu %5llu %5llu",
		    sum_cur.ift_ip - sum_old.ift_ip,
		    sum_cur.ift_ie - sum_old.ift_ie,
		    sum_cur.ift_op - sum_old.ift_op,
		    sum_cur.ift_oe - sum_old.ift_oe,
		    sum_cur.ift_co - sum_old.ift_co);
	if (dflag)
		printf(" %5llu", sum_cur.ift_dr - sum_old.ift_dr);

	sum_old = sum_cur;

	putchar('\n');
	fflush(stdout);
	if (repeatcount && --repeatcount == 0)
		return;
	line++;
	sigemptyset(&emptyset);
	if (!signalled)
		sigsuspend(&emptyset);
	signalled = 0;
	(void)alarm(interval);
	if (line == 21 && isatty(STDOUT_FILENO))
		goto banner;
	goto loop;
}

/*
 * Called if an interval expires before sidewaysintpr has completed a loop.
 * Sets a flag to not wait for the alarm.
 */
/* ARGSUSED */
static void
catchalarm(int signo)
{
	signalled = 1;
}

static void
get_rtaddrs(int addrs, struct sockaddr *sa, struct sockaddr **rti_info)
{   
	int i;

	for (i = 0; i < RTAX_MAX; i++) {
		if (addrs & (1 << i)) {
			rti_info[i] = sa;
			sa = (struct sockaddr *)((char *)(sa) +
			    roundup(sa->sa_len, sizeof(long)));
		} else 
			rti_info[i] = NULL;
	}
}


static int
isegress(char *name)
{
	static int s = -1;
	int len;
	struct ifgroupreq ifgr;
	struct ifg_req *ifg;
	int rv = 0;

	if (s == -1) {
		if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
			return 0;
	}

	memset(&ifgr, 0, sizeof(ifgr));
	strlcpy(ifgr.ifgr_name, name, IFNAMSIZ);

	if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifgr) == -1) {
		return 0;
	}

	len = ifgr.ifgr_len;
	ifgr.ifgr_groups = calloc(len, 1);
	if (ifgr.ifgr_groups == NULL)
		err(1, "getifgroups");
	if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifgr) == -1)
		err(1, "SIOCGIFGROUP");

	ifg = ifgr.ifgr_groups;
	for (; ifg && len >= sizeof(struct ifg_req); ifg++) {
		len -= sizeof(struct ifg_req);
		if (strcmp(ifg->ifgrq_group, IFG_EGRESS) == 0)
			rv = 1;
	}

	free(ifgr.ifgr_groups);
	return rv;
}

static void
fetchifs(void)
{
	struct if_msghdr ifm;
	int mib[6] = { CTL_NET, PF_ROUTE, 0, 0, NET_RT_IFLIST, 0 };
	struct rt_msghdr *rtm;
	struct if_data *ifd;
	struct sockaddr *sa, *rti_info[RTAX_MAX];
	struct sockaddr_dl *sdl;
	char *buf = NULL, *next, *lim;
	char name[IFNAMSIZ];
	size_t len;
	int takeit = 0;
	int foundone = 0;

	len = get_sysctl(mib, 6, &buf);

	memset(&ip_cur, 0, sizeof(ip_cur));
	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		switch (rtm->rtm_type) {
		case RTM_IFINFO:
			bcopy(next, &ifm, sizeof ifm);
			ifd = &ifm.ifm_data;

			sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
			get_rtaddrs(ifm.ifm_addrs, sa, rti_info);

			sdl = (struct sockaddr_dl *)rti_info[RTAX_IFP];
			if (sdl == NULL || sdl->sdl_family != AF_LINK)
				continue;
			bzero(name, sizeof(name));
			if (sdl->sdl_nlen >= IFNAMSIZ)
				memcpy(name, sdl->sdl_data, IFNAMSIZ - 1);
			else if (sdl->sdl_nlen > 0) 
				memcpy(name, sdl->sdl_data, sdl->sdl_nlen);

			if (interface != NULL && !strcmp(name, interface)) {
				takeit = 1;
			} else if (interface == NULL && foundone == 0 &&
			    isegress(name)) {
				takeit = 1;
				foundone = 1;
			} else
				takeit = 0;
			if (takeit) {
				strlcpy(ip_cur.ift_name, name,
				    sizeof(ip_cur.ift_name));
				ip_cur.ift_ip = ifd->ifi_ipackets;
				ip_cur.ift_ib = ifd->ifi_ibytes;
				ip_cur.ift_ie = ifd->ifi_ierrors;
				ip_cur.ift_op = ifd->ifi_opackets;
				ip_cur.ift_ob = ifd->ifi_obytes;
				ip_cur.ift_oe = ifd->ifi_oerrors;
				ip_cur.ift_co = ifd->ifi_collisions;
				ip_cur.ift_dr = ifd->ifi_oqdrops;
			}

			sum_cur.ift_ip += ifd->ifi_ipackets;
			sum_cur.ift_ib += ifd->ifi_ibytes;
			sum_cur.ift_ie += ifd->ifi_ierrors;
			sum_cur.ift_op += ifd->ifi_opackets;
			sum_cur.ift_ob += ifd->ifi_obytes;
			sum_cur.ift_oe += ifd->ifi_oerrors;
			sum_cur.ift_co += ifd->ifi_collisions;
			sum_cur.ift_dr += ifd->ifi_oqdrops;
			break;
		}
	}
	if (interface == NULL && foundone == 0) {
		strlcpy(ip_cur.ift_name, name,
		    sizeof(ip_cur.ift_name));
		ip_cur.ift_ip = ifd->ifi_ipackets;
		ip_cur.ift_ib = ifd->ifi_ibytes;
		ip_cur.ift_ie = ifd->ifi_ierrors;
		ip_cur.ift_op = ifd->ifi_opackets;
		ip_cur.ift_ob = ifd->ifi_obytes;
		ip_cur.ift_oe = ifd->ifi_oerrors;
		ip_cur.ift_co = ifd->ifi_collisions;
		ip_cur.ift_dr = ifd->ifi_oqdrops;
	}
	free(buf);
}
@


1.73
log
@Initialize buffer pointers passed to get_sysctl to NULL; otherwise they point
to random memory so when the sysctl-estimate is too small, the realloc() fails.
Problem reported by Ze Loff, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.72 2015/02/09 12:25:03 claudio Exp $	*/
d146 1
a146 1
					total += 0; // XXX ifnet.if_snd.ifq_drops;
d280 1
a280 1
		printf(" %4d", 0 /* XXX ifnet.if_snd.ifq_drops */);
d389 1
a389 2
		    /* XXX ifnet.if_snd.ifq_drops - ip->ift_dr); */
		    0LL);
d554 1
a554 2
				ip_cur.ift_dr = 0;
				    /* XXX ifnet.if_snd.ifq_drops */
d564 1
a564 1
			sum_cur.ift_dr += 0; /* XXX ifnet.if_snd.ifq_drops */
d578 1
a578 2
		ip_cur.ift_dr = 0;
		    /* XXX ifnet.if_snd.ifq_drops */
@


1.72
log
@Get rid of another KVM reader and convert the multicast output to use
the new sysctls. Looks good deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.71 2015/02/08 04:25:56 claudio Exp $	*/
d506 1
a506 1
	char *buf, *next, *lim;
@


1.71
log
@The multicast address printing code has been disabled for 7 years.
Nobody complained about it missing. It is time to kill it for real.
OK phessler, henning, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.70 2015/01/16 06:40:09 deraadt Exp $	*/
d77 1
a77 1
	char *buf, *next, *lim, *cp;
d91 1
a91 6
	if (sysctl(mib, 6, NULL, &len, NULL, 0) == -1)
		err(1, "sysctl");
	if ((buf = malloc(len)) == NULL)
		err(1, NULL);
	if (sysctl(mib, 6, buf, &len, NULL, 0) == -1)
		err(1, "sysctl");
d512 1
a512 6
	if (sysctl(mib, 6, NULL, &len, NULL, 0) == -1)
		err(1, "sysctl");
	if ((buf = malloc(len)) == NULL)
		err(1, NULL);
	if (sysctl(mib, 6, buf, &len, NULL, 0) == -1)
		err(1, "sysctl");
@


1.70
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.69 2014/11/21 17:49:00 mikeb Exp $	*/
a210 14
#if 0
		if (aflag) {
			u_long multiaddr;
			struct in_multi inm;

			multiaddr = (u_long)LIST_FIRST(&ifaddr.in.ia_multiaddrs);
			while (multiaddr != 0) {
				kread(multiaddr, &inm, sizeof inm);
				printf("\n%25s %-17.17s ", "",
				    routename4(inm.inm_addr.s_addr));
				multiaddr = (u_long)LIST_NEXT(&inm, inm_list);
			}
		}
#endif
a235 34
#if 0
		if (aflag) {
			u_long multiaddr;
			struct in6_multi inm;
			struct sockaddr_in6 m6;

			multiaddr = (u_long)LIST_FIRST(&ifaddr.in6.ia6_multiaddrs);
			while (multiaddr != 0) {
				kread(multiaddr, &inm, sizeof inm);
				memset(&m6, 0, sizeof(m6));
				m6.sin6_len = sizeof(struct sockaddr_in6);
				m6.sin6_family = AF_INET6;
				m6.sin6_addr = inm.in6m_addr;
#ifdef __KAME__
				if (IN6_IS_ADDR_MC_LINKLOCAL(&m6.sin6_addr) ||
				    IN6_IS_ADDR_MC_INTFACELOCAL(&m6.sin6_addr)) {
					m6.sin6_scope_id =
					    ntohs(*(u_int16_t *)
					    &m6.sin6_addr.s6_addr[2]);
					m6.sin6_addr.s6_addr[2] = 0;
					m6.sin6_addr.s6_addr[3] = 0;
				}
#endif
				cp = routename6(&m6);
				if (vflag)
					n = strlen(cp) < 17 ? 17 : strlen(cp);
				else
					n = 17;
				printf("\n%25s %-*.*s ", "",
				    n, n, cp);
				multiaddr = (u_long)LIST_NEXT(&inm, in6m_entry);
			}
		}
#endif
@


1.69
log
@remove pointless if_var.h and socketvar.h includes; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.68 2014/06/23 03:46:17 guenther Exp $	*/
d33 1
a33 1
#include <sys/param.h>
@


1.68
log
@The second level of the CTL_NET sysctl is a PF_*, not an AF_*

inconsistent usage in route(8) noted by Gregor Best (gbe (at) ring0.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.67 2013/11/21 17:32:13 mikeb Exp $	*/
a40 1
#include <net/if_var.h>
@


1.67
log
@split kernel parts of the if.h into a separate header file if_var.h
which allows us to modify ifnet structure in a relatively safe way;
discussed with deraadt, ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.66 2012/08/26 19:42:53 tedu Exp $	*/
d76 1
a76 1
	int mib[6] = { CTL_NET, AF_ROUTE, 0, 0, NET_RT_IFLIST, 0 };
d555 1
a555 1
	int mib[6] = { CTL_NET, AF_ROUTE, 0, 0, NET_RT_IFLIST, 0 };
@


1.66
log
@oops, i added a stray character.  spotted by jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.65 2012/08/22 00:11:57 tedu Exp $	*/
d41 1
@


1.65
log
@-h flag to print human numbers in conjunction with -w -b
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.64 2011/07/09 00:45:40 henning Exp $	*/
d323 1
a323 1
			printf("x %10llu %10llu",
@


1.64
log
@rmove rotten netatalk bits
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.63 2011/01/09 19:12:19 tedu Exp $	*/
d56 1
d315 11
a325 4
	if (bflag)
		printf("%10llu %10llu",
		    ifd->ifi_ibytes, ifd->ifi_obytes);
	else
d362 2
d406 1
a406 1
		printf("  %10.10s %8.8s %10.10s %5.5s",
d423 11
a433 5
	if (bflag)
		printf("%10llu %8.8s %10llu %5.5s",
		    ip_cur.ift_ib - ip_old.ift_ib, " ",
		    ip_cur.ift_ob - ip_old.ift_ob, " ");
	else
d447 11
a457 5
	if (bflag)
		printf("  %10llu %8.8s %10llu %5.5s",
		    sum_cur.ift_ib - sum_old.ift_ib, " ",
		    sum_cur.ift_ob - sum_old.ift_ob, " ");
	else
@


1.63
log
@have netstat -w default to the first egress interface, which is usually more
interesting than whatever happens to be the last interface.
ok deraadt nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.62 2009/11/22 22:22:14 tedu Exp $	*/
a282 4
		break;
	case AF_APPLETALK:
		printf("atlk:%-12s",atalk_print(sa,0x10) );
		printf("%-12s ",atalk_print(sa,0x0b) );
@


1.62
log
@don't repeat the banner if not a tty.
add a -c count option to netstat.
tweak spacing to not smear fields in vmstat.
ok deraadt sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.61 2009/08/04 03:45:47 tedu Exp $	*/
d35 1
d492 40
d544 2
d554 1
d578 8
d610 1
a610 1
	if (interface == NULL) {
@


1.61
log
@fix some warnings.  there are others, but nobody wants to look at them.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.60 2009/02/07 15:06:04 chl Exp $	*/
d59 1
a59 1
static void sidewaysintpr(u_int);
d70 1
a70 1
intpr(int interval)
d85 1
a85 1
		sidewaysintpr((unsigned)interval);
d353 1
a353 1
sidewaysintpr(unsigned int interval)
d452 2
d460 1
a460 1
	if (line == 21)
a462 1
	/*NOTREACHED*/
@


1.60
log
@add missing headers needed for warn() and err().

ok claudio@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.59 2009/01/26 20:30:26 claudio Exp $	*/
d154 1
a154 1
			printf("%-7s %-5ld ", name, ifd->ifi_mtu);
d171 1
a171 1
			printf("%-7s %-5ld ", name, ifd->ifi_mtu);
a354 1
	struct ifnet ifnet;
d430 1
a430 1
		    0);
@


1.59
log
@NULL instead of 0 in comparison
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.58 2008/12/24 16:53:22 dhill Exp $	*/
d48 1
@


1.58
log
@Plug a couple of memory leaks noticed by deraadt.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.57 2008/03/18 20:03:37 claudio Exp $	*/
d532 1
a532 1
			if (interface != 0 && !strcmp(name, interface)) {
@


1.57
log
@Make -I work correctly. RTM_NEWADDR needs to filter the ifname as well.
Found by and tested jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.56 2008/01/03 21:01:40 claudio Exp $	*/
d175 1
d570 1
@


1.56
log
@Make if.c kvm free by fetching the interface stats via sysctl like in systat
and ospfd. What is not yet covered is the -d and -t flags to show interface
queue drops and the if_timer.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.55 2007/12/19 01:47:00 deraadt Exp $	*/
d159 3
@


1.55
log
@delete rcsid crud
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.54 2007/12/14 18:35:46 deraadt Exp $	*/
d33 1
d37 1
d42 1
d57 2
a58 4
#define	YES	1
#define	NO	0

static void sidewaysintpr(u_int, u_long);
d60 2
d69 1
a69 1
intpr(int interval, u_long ifnetaddr)
d71 11
a81 11
	struct ifnet ifnet;
	union {
		struct ifaddr ifa;
		struct in_ifaddr in;
		struct in6_ifaddr in6;
	} ifaddr;
	u_int64_t total;
	u_long ifaddraddr;
	struct sockaddr *sa;
	struct ifnet_head ifhead;	/* TAILQ_HEAD */
	char name[IFNAMSIZ];
a82 4
	if (ifnetaddr == 0) {
		printf("ifnet: symbol not defined\n");
		return;
	}
d84 1
a84 1
		sidewaysintpr((unsigned)interval, ifnetaddr);
d88 6
a93 8
	/*
	 * Find the pointer to the first ifnet structure.  Replace
	 * the pointer to the TAILQ_HEAD with the actual pointer
	 * to the first list element.
	 */
	if (kread(ifnetaddr, &ifhead, sizeof ifhead))
		return;
	ifnetaddr = (u_long)TAILQ_FIRST(&ifhead);
d107 24
a130 13
	ifaddraddr = 0;
	while (ifnetaddr || ifaddraddr) {
		struct sockaddr_in *sin;
		struct sockaddr_in6 *sin6;
		char *cp;
		int n, m;

		if (ifaddraddr == 0) {
			if (kread(ifnetaddr, &ifnet, sizeof ifnet))
				return;
			bcopy(ifnet.if_xname, name, IFNAMSIZ);
			name[IFNAMSIZ - 1] = '\0';	/* sanity */
			ifnetaddr = (u_long)TAILQ_NEXT(&ifnet, if_list);
d133 2
d136 1
a136 1
			if ((ifnet.if_flags & IFF_UP) == 0)
a138 2
			ifaddraddr = (u_long)TAILQ_FIRST(&ifnet.if_addrlist);
		}
d140 18
a157 11
		if (qflag) {
			total = ifnet.if_ibytes + ifnet.if_obytes +
			    ifnet.if_ipackets + ifnet.if_ierrors +
			    ifnet.if_opackets + ifnet.if_oerrors +
			    ifnet.if_collisions;
			if (tflag)
				total += ifnet.if_timer;
			if (dflag)
				total += ifnet.if_snd.ifq_drops;
			if (total == 0) {
				ifaddraddr = 0;
d159 11
a169 1
			}
d171 2
d174 41
a214 8
		printf("%-7s %-5ld ", name, ifnet.if_mtu);
		if (ifaddraddr == 0) {
			printf("%-11.11s ", "none");
			printf("%-17.17s ", "none");
		} else {
			if (kread(ifaddraddr, &ifaddr, sizeof ifaddr)) {
				ifaddraddr = 0;
				continue;
d216 13
a228 21
#define CP(x) ((char *)(x))
			cp = (CP(ifaddr.ifa.ifa_addr) - CP(ifaddraddr)) +
				CP(&ifaddr); sa = (struct sockaddr *)cp;
			switch (sa->sa_family) {
			case AF_UNSPEC:
				printf("%-11.11s ", "none");
				printf("%-17.17s ", "none");
				break;
			case AF_INET:
				sin = (struct sockaddr_in *)sa;
#ifdef notdef
				/* can't use inet_makeaddr because kernel
				 * keeps nets unshifted.
				 */
				in = inet_makeaddr(ifaddr.in.ia_subnet,
				    INADDR_ANY);
				cp = netname4(in.s_addr,
				    ifaddr.in.ia_subnetmask);
#else
				cp = netname4(ifaddr.in.ia_subnet,
				    ifaddr.in.ia_subnetmask);
d230 26
a255 27
				if (vflag)
					n = strlen(cp) < 11 ? 11 : strlen(cp);
				else
					n = 11;
				printf("%-*.*s ", n, n, cp);
				cp = routename4(sin->sin_addr.s_addr);
				if (vflag)
					n = strlen(cp) < 17 ? 17 : strlen(cp);
				else
					n = 17;
				printf("%-*.*s ", n, n, cp);

				if (aflag) {
					u_long multiaddr;
					struct in_multi inm;

					multiaddr = (u_long)LIST_FIRST(&ifaddr.in.ia_multiaddrs);
					while (multiaddr != 0) {
						kread(multiaddr, &inm, sizeof inm);
						printf("\n%25s %-17.17s ", "",
						    routename4(inm.inm_addr.s_addr));
						multiaddr = (u_long)LIST_NEXT(&inm, inm_list);
					}
				}
				break;
			case AF_INET6:
				sin6 = (struct sockaddr_in6 *)sa;
d257 3
a259 2
				if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {
					sin6->sin6_scope_id =
d261 3
a263 3
					    &sin6->sin6_addr.s6_addr[2]);
					sin6->sin6_addr.s6_addr[2] = 0;
					sin6->sin6_addr.s6_addr[3] = 0;
d266 1
a266 8
				cp = netname6(&ifaddr.in6.ia_addr,
				    &ifaddr.in6.ia_prefixmask);
				if (vflag)
					n = strlen(cp) < 11 ? 11 : strlen(cp);
				else
					n = 11;
				printf("%-*.*s ", n, n, cp);
				cp = routename6(sin6);
d271 5
a275 22
				printf("%-*.*s ", n, n, cp);
				if (aflag) {
					u_long multiaddr;
					struct in6_multi inm;
					struct sockaddr_in6 m6;

					multiaddr = (u_long)LIST_FIRST(&ifaddr.in6.ia6_multiaddrs);
					while (multiaddr != 0) {
						kread(multiaddr, &inm, sizeof inm);
						memset(&m6, 0, sizeof(m6));
						m6.sin6_len = sizeof(struct sockaddr_in6);
						m6.sin6_family = AF_INET6;
						m6.sin6_addr = inm.in6m_addr;
#ifdef __KAME__
						if (IN6_IS_ADDR_MC_LINKLOCAL(&m6.sin6_addr) ||
						    IN6_IS_ADDR_MC_INTFACELOCAL(&m6.sin6_addr)) {
							m6.sin6_scope_id =
							    ntohs(*(u_int16_t *)
							    &m6.sin6_addr.s6_addr[2]);
							m6.sin6_addr.s6_addr[2] = 0;
							m6.sin6_addr.s6_addr[3] = 0;
						}
d277 18
a294 49
						cp = routename6(&m6);
						if (vflag)
							n = strlen(cp) < 17 ? 17 : strlen(cp);
						else
							n = 17;
						printf("\n%25s %-*.*s ", "",
						    n, n, cp);
						multiaddr = (u_long)LIST_NEXT(&inm, in6m_entry);
					}
				}
				break;
			case AF_APPLETALK:
				printf("atlk:%-12s",atalk_print(sa,0x10) );
				printf("%-12s ",atalk_print(sa,0x0b) );
				break;
			case AF_LINK:
				{
				struct sockaddr_dl *sdl =
					(struct sockaddr_dl *)sa;
				m = printf("%-11.11s ", "<Link>");
				if (sdl->sdl_type == IFT_ETHER ||
				    sdl->sdl_type == IFT_CARP ||
				    sdl->sdl_type == IFT_FDDI ||
				    sdl->sdl_type == IFT_ISO88025)
					printf("%-17.17s ",
					    ether_ntoa((struct ether_addr *)LLADDR(sdl)));
				else {
					cp = (char *)LLADDR(sdl);
					n = sdl->sdl_alen;
					goto hexprint;
				}
				}
				break;
			default:
				m = printf("(%d)", sa->sa_family);
				for (cp = sa->sa_len + (char *)sa;
					--cp > sa->sa_data && (*cp == 0);) {}
				n = cp - sa->sa_data + 1;
				cp = sa->sa_data;
			hexprint:
				while (--n >= 0)
					m += printf("%x%c", *cp++ & 0xff,
						    n > 0 ? '.' : ' ');
				m = 30 - m;
				while (m-- > 0)
					putchar(' ');
				break;
			}
			ifaddraddr = (u_long)TAILQ_NEXT(&ifaddr.ifa, ifa_list);
d296 15
a310 13
		if (bflag)
			printf("%10llu %10llu",
			    ifnet.if_ibytes, ifnet.if_obytes);
		else
			printf("%8llu %5llu %8llu %5llu %5llu",
			    ifnet.if_ipackets, ifnet.if_ierrors,
			    ifnet.if_opackets, ifnet.if_oerrors,
			    ifnet.if_collisions);
		if (tflag)
			printf(" %4d", ifnet.if_timer);
		if (dflag)
			printf(" %4d", ifnet.if_snd.ifq_drops);
		putchar('\n');
d312 13
a326 1
#define	MAXIF	100
d337 1
a337 1
} iftot[MAXIF];
d348 1
a348 1
sidewaysintpr(unsigned int interval, u_long off)
d351 1
a351 2
	u_long firstifnet;
	struct iftot *ip, *total;
a352 12
	struct iftot *lastif, *sum, *interesting;
	struct ifnet_head ifhead;	/* TAILQ_HEAD */
	sigset_t emptyset;

	/*
	 * Find the pointer to the first ifnet structure.  Replace
	 * the pointer to the TAILQ_HEAD with the actual pointer
	 * to the first list element.
	 */
	if (kread(off, &ifhead, sizeof ifhead))
		return;
	firstifnet = (u_long)TAILQ_FIRST(&ifhead);
d354 2
a355 17
	lastif = iftot;
	sum = iftot + MAXIF - 1;
	total = sum - 1;
	interesting = (interface == NULL) ? iftot : NULL;
	for (off = firstifnet, ip = iftot; off;) {
		if (kread(off, &ifnet, sizeof ifnet))
			break;
		bzero(ip->ift_name, sizeof(ip->ift_name));
		snprintf(ip->ift_name, IFNAMSIZ, "%s", ifnet.if_xname);
		if (interface && strcmp(ifnet.if_xname, interface) == 0)
			interesting = ip;
		ip++;
		if (ip >= iftot + MAXIF - 2)
			break;
		off = (u_long)TAILQ_NEXT(&ifnet, if_list);
	}
	if (interesting == NULL) {
a359 1
	lastif = ip;
d362 1
a362 1
	signalled = NO;
d367 2
a368 2
		    interesting->ift_name, " ",
		    interesting->ift_name, " ");
d371 11
a381 2
		    interesting->ift_name, " ",
		    interesting->ift_name, " ", " ");
a383 20
	if (lastif - iftot > 0) {
		if (bflag)
			printf("  %7.7s in %8.8s %6.6s out %5.5s",
			    "total", " ", "total", " ");
		else
			printf("  %5.5s in %5.5s%5.5s out %5.5s %5.5s",
			    "total", " ", "total", " ", " ");
		if (dflag)
			printf(" %5.5s", " ");
	}
	for (ip = iftot; ip < iftot + MAXIF; ip++) {
		ip->ift_ip = 0;
		ip->ift_ib = 0;
		ip->ift_ie = 0;
		ip->ift_op = 0;
		ip->ift_ob = 0;
		ip->ift_oe = 0;
		ip->ift_co = 0;
		ip->ift_dr = 0;
	}
d393 9
a401 10
	if (lastif - iftot > 0) {
		if (bflag)
			printf("  %10.10s %8.8s %10.10s %5.5s",
			    "bytes", " ", "bytes", " ");
		else
			printf("  %8.8s %5.5s %8.8s %5.5s %5.5s",
			    "packets", "errs", "packets", "errs", "colls");
		if (dflag)
			printf(" %5.5s", "drops");
	}
d405 2
d408 38
a445 63
	sum->ift_ip = 0;
	sum->ift_ib = 0;
	sum->ift_ie = 0;
	sum->ift_op = 0;
	sum->ift_ob = 0;
	sum->ift_oe = 0;
	sum->ift_co = 0;
	sum->ift_dr = 0;
	for (off = firstifnet, ip = iftot; off && ip < lastif; ip++) {
		if (kread(off, &ifnet, sizeof ifnet)) {
			off = 0;
			continue;
		}
		if (ip == interesting) {
			if (bflag)
				printf("%10llu %8.8s %10llu %5.5s",
				    ifnet.if_ibytes - ip->ift_ib, " ",
				    ifnet.if_obytes - ip->ift_ob, " ");
			else
				printf("%8llu %5llu %8llu %5llu %5llu",
				    ifnet.if_ipackets - ip->ift_ip,
				    ifnet.if_ierrors - ip->ift_ie,
				    ifnet.if_opackets - ip->ift_op,
				    ifnet.if_oerrors - ip->ift_oe,
				    ifnet.if_collisions - ip->ift_co);
			if (dflag)
				printf(" %5llu",
				    ifnet.if_snd.ifq_drops - ip->ift_dr);
		}
		ip->ift_ip = ifnet.if_ipackets;
		ip->ift_ib = ifnet.if_ibytes;
		ip->ift_ie = ifnet.if_ierrors;
		ip->ift_op = ifnet.if_opackets;
		ip->ift_ob = ifnet.if_obytes;
		ip->ift_oe = ifnet.if_oerrors;
		ip->ift_co = ifnet.if_collisions;
		ip->ift_dr = ifnet.if_snd.ifq_drops;
		sum->ift_ip += ip->ift_ip;
		sum->ift_ib += ip->ift_ib;
		sum->ift_ie += ip->ift_ie;
		sum->ift_op += ip->ift_op;
		sum->ift_ob += ip->ift_ob;
		sum->ift_oe += ip->ift_oe;
		sum->ift_co += ip->ift_co;
		sum->ift_dr += ip->ift_dr;
		off = (u_long)TAILQ_NEXT(&ifnet, if_list);
	}
	if (lastif - iftot > 0) {
		if (bflag)
			printf("  %10llu %8.8s %10llu %5.5s",
			    sum->ift_ib - total->ift_ib, " ",
			    sum->ift_ob - total->ift_ob, " ");
		else
			printf("  %8llu %5llu %8llu %5llu %5llu",
			    sum->ift_ip - total->ift_ip,
			    sum->ift_ie - total->ift_ie,
			    sum->ift_op - total->ift_op,
			    sum->ift_oe - total->ift_oe,
			    sum->ift_co - total->ift_co);
		if (dflag)
			printf(" %5llu", sum->ift_dr - total->ift_dr);
	}
	*total = *sum;
d452 1
a452 1
	signalled = NO;
d468 98
a565 1
	signalled = YES;
@


1.54
log
@remove 21 nlist variables, and instead use sysctl to query the kernel
turn on INET6 the default (remove the #ifdef's)
ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.53 2007/09/11 16:14:41 mk Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "from: @@(#)if.c	8.2 (Berkeley) 2/21/94";
#else
static char *rcsid = "$OpenBSD: if.c,v 1.53 2007/09/11 16:14:41 mk Exp $";
#endif
#endif /* not lint */
@


1.53
log
@More 64 bits counters fixes.

From brad.

ok mk claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.52 2007/09/05 20:27:04 claudio Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.52 2007/09/05 20:27:04 claudio Exp $";
a79 1
#ifdef INET6
a80 1
#endif
a120 1
#ifdef INET6
a121 1
#endif
a210 1
#ifdef INET6
a267 1
#endif
@


1.52
log
@Counters switched to u_int64_t so use %llu to print them.
Found by and OK mk@@ + OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.51 2007/06/15 01:25:05 ray Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.51 2007/06/15 01:25:05 ray Exp $";
d332 8
a339 8
	u_long	ift_ip;			/* input packets */
	u_long	ift_ib;			/* input bytes */
	u_long	ift_ie;			/* input errors */
	u_long	ift_op;			/* output packets */
	u_long	ift_ob;			/* output bytes */
	u_long	ift_oe;			/* output errors */
	u_long	ift_co;			/* collisions */
	u_long	ift_dr;			/* drops */
d465 1
a465 1
				printf("%10lu %8.8s %10lu %5.5s",
d469 1
a469 1
				printf("%8lu %5lu %8lu %5lu %5lu",
d476 1
a476 1
				printf(" %5lu",
d499 1
a499 1
			printf("  %10lu %8.8s %10lu %5.5s",
d503 1
a503 1
			printf("  %8lu %5lu %8lu %5lu %5lu",
d510 1
a510 1
			printf(" %5lu", sum->ift_dr - total->ift_dr);
@


1.51
log
@Don't truncate interface name.

Fixes PR 5460.

OK deraadt, agreed with by krw.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.50 2007/06/04 12:20:24 henning Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.50 2007/06/04 12:20:24 henning Exp $";
d84 2
a85 1
	u_long total, ifaddraddr;
d314 1
a314 1
			printf("%10lu %10lu",
d317 1
a317 1
			printf("%8lu %5lu %8lu %5lu %5lu",
@


1.50
log
@remove IPX support, agreed by many
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.49 2006/11/17 01:11:23 itojun Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.49 2006/11/17 01:11:23 itojun Exp $";
d158 1
a158 1
		printf("%-7.7s %-5ld ", name, ifnet.if_mtu);
@


1.49
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.48 2006/05/27 19:24:01 claudio Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.48 2006/05/27 19:24:01 claudio Exp $";
a50 2
#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
a82 1
		struct ipx_ifaddr ipx;
a272 15
			case AF_IPX:
				{
				struct sockaddr_ipx *sipx =
					(struct sockaddr_ipx *)sa;
				u_long net;
				char netnum[8];

				*(union ipx_net *)&net = sipx->sipx_addr.ipx_net;
				snprintf(netnum, sizeof netnum, "%XH",
				    ntohl(net));
				printf("ipx:%-8s", netnum);
				printf("%-17s ",
				    ipx_phost((struct sockaddr *)sipx));
				}
				break;
a535 19

char *
ipx_phost(struct sockaddr *sa)
{
	struct sockaddr_ipx *sipx = (struct sockaddr_ipx *)sa;
	struct sockaddr_ipx work;
	static union ipx_net ipx_zeronet;
	char *p;

	work = *sipx;
	work.sipx_addr.ipx_port = 0;
	work.sipx_addr.ipx_net = ipx_zeronet;

	p = ipx_print((struct sockaddr *)&work);
	if (strncmp("0H.", p, 3) == 0)
		p += 3;
	return(p);
}

@


1.48
log
@Kill upHex and use %X instead. Crazy old code found by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.47 2006/05/27 19:16:37 claudio Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.47 2006/05/27 19:16:37 claudio Exp $";
d255 2
a256 1
						if (IN6_IS_ADDR_MC_LINKLOCAL(&m6.sin6_addr)) {
@


1.47
log
@Moving netstat from kvm snooping to retrieving the routing tables via
sysctl. Most code is stolen from route -- which was stolen from netstat.
kvm snooping code is still in and useable. Put it in deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.46 2005/12/11 17:25:03 deraadt Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.46 2005/12/11 17:25:03 deraadt Exp $";
d283 1
a283 1
				snprintf(netnum, sizeof netnum, "%xH",
a284 1
				upHex(netnum);
a551 18
}

void
upHex(char *p0)
{
	char *p = p0;

	for (; *p; p++)
		switch (*p) {
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
			*p += ('A' - 'a');
			break;
	}
@


1.46
log
@ARGSUSED
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.45 2005/10/17 19:09:36 otto Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.45 2005/10/17 19:09:36 otto Exp $";
d186 1
a186 1
				cp = netname(in.s_addr,
d189 1
a189 1
				cp = netname(ifaddr.in.ia_subnet,
d197 1
a197 1
				cp = routename(sin->sin_addr.s_addr);
d212 1
a212 1
						    routename(inm.inm_addr.s_addr));
d230 1
a230 1
				    &ifaddr.in6.ia_prefixmask.sin6_addr);
d554 37
@


1.45
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.44 2005/06/08 04:47:04 henning Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.44 2005/06/08 04:47:04 henning Exp $";
d548 1
@


1.44
log
@bye bye, Xerox NS protocols
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.43 2005/03/25 17:01:03 jaredy Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.43 2005/03/25 17:01:03 jaredy Exp $";
d108 1
a108 1
	ifnetaddr = (u_long)ifhead.tqh_first;
d136 1
a136 1
			ifnetaddr = (u_long)ifnet.if_list.tqe_next;
d143 1
a143 1
			ifaddraddr = (u_long)ifnet.if_addrlist.tqh_first;
d208 1
a208 1
					multiaddr = (u_long)ifaddr.in.ia_multiaddrs.lh_first;
d213 1
a213 1
						multiaddr = (u_long)inm.inm_list.le_next;
d247 1
a247 1
					multiaddr = (u_long)ifaddr.in6.ia6_multiaddrs.lh_first;
d270 1
a270 1
						multiaddr = (u_long)inm.in6m_entry.le_next;
d328 1
a328 1
			ifaddraddr = (u_long)ifaddr.ifa.ifa_list.tqe_next;
d385 1
a385 1
	firstifnet = (u_long)ifhead.tqh_first;
d401 1
a401 1
		off = (u_long)ifnet.if_list.tqe_next;
d512 1
a512 1
		off = (u_long)ifnet.if_list.tqe_next;
@


1.43
log
@kill unneeded (char *) casts.  ok millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.42 2005/03/13 16:05:50 mpf Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.42 2005/03/13 16:05:50 mpf Exp $";
a50 2
#include <netns/ns.h>
#include <netns/ns_if.h>
a84 1
		struct ns_ifaddr ns;
a293 16
				break;
			case AF_NS:
				{
				struct sockaddr_ns *sns =
					(struct sockaddr_ns *)sa;
				u_long net;
				char netnum[8];

				*(union ns_net *)&net = sns->sns_addr.x_net;
				snprintf(netnum, sizeof netnum, "%xH",
				    ntohl(net));
				upHex(netnum);
				printf("ns:%-8s ", netnum);
				printf("%-17s ",
				    ns_phost((struct sockaddr *)sns));
				}
@


1.42
log
@make 'netstat -i' print carp link addresses correctly.
ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.41 2005/03/04 20:22:16 jaredy Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.41 2005/03/04 20:22:16 jaredy Exp $";
d109 1
a109 1
	if (kread(ifnetaddr, (char *)&ifhead, sizeof ifhead))
d135 1
a135 1
			if (kread(ifnetaddr, (char *)&ifnet, sizeof ifnet))
d169 1
a169 1
			if (kread(ifaddraddr, (char *)&ifaddr, sizeof ifaddr)) {
d213 1
a213 2
						kread(multiaddr, (char *)&inm,
						    sizeof inm);
d252 1
a252 2
						kread(multiaddr, (char *)&inm,
						    sizeof inm);
d402 1
a402 1
	if (kread(off, (char *)&ifhead, sizeof ifhead))
d411 1
a411 1
		if (kread(off, (char *)&ifnet, sizeof ifnet))
d495 1
a495 1
		if (kread(off, (char *)&ifnet, sizeof ifnet)) {
@


1.41
log
@remove unneeded casts of if stats; ok krw miod dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.40 2005/03/02 16:47:56 dhartmei Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.40 2005/03/02 16:47:56 dhartmei Exp $";
d322 1
@


1.40
log
@make counters in struct iftot u_long instead of int, as they overflow
on amd64. from Peter Philipp. closes PR 4107.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.39 2004/06/25 20:05:40 henning Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.39 2004/06/25 20:05:40 henning Exp $";
d513 1
a513 1
				printf(" %5d",
d537 2
a538 2
			    (unsigned long)sum->ift_ib -  total->ift_ib, " ",
			    (unsigned long)sum->ift_ob -  total->ift_ob, " ");
d541 5
a545 5
			    (unsigned long)sum->ift_ip - total->ift_ip,
			    (unsigned long)sum->ift_ie - total->ift_ie,
			    (unsigned long)sum->ift_op - total->ift_op,
			    (unsigned long)sum->ift_oe - total->ift_oe,
			    (unsigned long)sum->ift_co - total->ift_co);
d547 1
a547 1
			printf(" %5d", sum->ift_dr - total->ift_dr);
@


1.39
log
@remove netiso
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.38 2004/03/13 22:02:13 deraadt Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.38 2004/03/13 22:02:13 deraadt Exp $";
d369 8
a376 8
	int	ift_ip;			/* input packets */
	int	ift_ib;			/* input bytes */
	int	ift_ie;			/* input errors */
	int	ift_op;			/* output packets */
	int	ift_ob;			/* output bytes */
	int	ift_oe;			/* output errors */
	int	ift_co;			/* collisions */
	int	ift_dr;			/* drops */
@


1.38
log
@some NULL vs 0 and knf; parts from nimadeus@@pandora.be
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.37 2003/09/26 06:17:02 deraadt Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.37 2003/09/26 06:17:02 deraadt Exp $";
a54 2
#include <netiso/iso.h>
#include <netiso/iso_var.h>
a88 1
		struct iso_ifaddr iso;
@


1.37
log
@fix columns; sahara@@surt.net
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.36 2003/07/10 00:06:51 david Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.36 2003/07/10 00:06:51 david Exp $";
d231 1
a231 1
					      &sin6->sin6_addr.s6_addr[2]);
d266 1
a266 1
							      &m6.sin6_addr.s6_addr[2]);
@


1.36
log
@add missing includes
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.35 2003/06/03 02:56:13 millert Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.35 2003/06/03 02:56:13 millert Exp $";
d170 1
a170 1
			printf("%-15.15s ", "none");
@


1.35
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.34 2003/05/14 23:37:05 itojun Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.34 2003/05/14 23:37:05 itojun Exp $";
d62 1
@


1.34
log
@use __KAME__ to determine kame-based kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.33 2003/02/01 01:51:31 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char *rcsid = "$OpenBSD: if.c,v 1.33 2003/02/01 01:51:31 deraadt Exp $";
@


1.33
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.32 2002/06/19 23:40:20 itojun Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.32 2002/06/19 23:40:20 itojun Exp $";
d230 1
a230 1
#ifdef KAME_SCOPEID
d265 1
a265 1
#ifdef KAME_SCOPEID
@


1.32
log
@use macro to determine link-local multicast addr
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.31 2002/06/19 15:12:09 itojun Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.31 2002/06/19 15:12:09 itojun Exp $";
d83 1
a83 3
intpr(interval, ifnetaddr)
	int interval;
	u_long ifnetaddr;
d96 1
a96 2
	u_long total;
	u_long ifaddraddr;
d120 1
a120 1
	       "Name", "Mtu", "Network", "Address");
d394 1
a394 3
sidewaysintpr(interval, off)
	unsigned interval;
	u_long off;
d575 1
a575 2
catchalarm(signo)
	int signo;
@


1.31
log
@decode embedded scopeid on -inalv multicast address printing
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.30 2002/05/27 01:50:36 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.30 2002/05/27 01:50:36 deraadt Exp $";
d269 1
a269 1
						if (m6.sin6_addr.s6_addr[1] == 0x02) {
@


1.30
log
@a night of cleanup, so i can read this easier
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.29 2002/02/16 21:27:50 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.29 2002/02/16 21:27:50 millert Exp $";
a237 3
					/* too little width */
					if (!vflag)
						sin6->sin6_scope_id = 0;
d258 1
a258 1
					char hbuf[INET6_ADDRSTRLEN];
d264 14
a277 2
						inet_ntop(AF_INET6, &inm.in6m_addr,
						    hbuf, sizeof(hbuf));
d279 1
a279 1
							n = strlen(hbuf) < 17 ? 17 : strlen(hbuf);
d283 1
a283 1
						    n, n, hbuf);
@


1.29
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.28 2002/01/17 21:34:58 mickey Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.28 2002/01/17 21:34:58 mickey Exp $";
d197 1
a197 1
					INADDR_ANY);
d199 1
a199 1
			    	    ifaddr.in.ia_subnetmask);
d236 2
a237 2
						ntohs(*(u_int16_t *)
						  &sin6->sin6_addr.s6_addr[2]);
d246 1
a246 1
					&ifaddr.in6.ia_prefixmask.sin6_addr);
d268 1
a268 1
							hbuf, sizeof(hbuf));
@


1.28
log
@evil, annoying spaces and tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.27 2001/11/19 19:02:15 mpech Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.27 2001/11/19 19:02:15 mpech Exp $";
d74 2
a75 2
static void sidewaysintpr __P((u_int, u_long));
static void catchalarm __P((int));
@


1.27
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.26 2001/09/04 23:35:59 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.26 2001/09/04 23:35:59 millert Exp $";
d219 1
a219 1
		
d262 1
a262 1
		
@


1.26
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.25 2001/08/26 09:42:04 brian Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.25 2001/08/26 09:42:04 brian Exp $";
d140 1
a140 1
		register char *cp;
d394 2
a395 2
	register struct iftot *ip, *total;
	register int line;
@


1.25
log
@Add a -q to silence zero-output lines and fix some whitespace and text nits.

Submitted by:	Sam Smith <S@@mSmith.net>
Ok:		theo
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.24 2001/07/18 17:17:39 pvalchev Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.24 2001/07/18 17:17:39 pvalchev Exp $";
d379 1
a379 1
u_char	signalled;			/* set if alarm goes off "early" */
d398 1
a398 1
	int oldmask;
d555 3
a557 5
	oldmask = sigblock(sigmask(SIGALRM));
	if (! signalled) {
		sigpause(0);
	}
	sigsetmask(oldmask);
@


1.24
log
@-Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.23 2001/02/06 05:24:10 fgsch Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.23 2001/02/06 05:24:10 fgsch Exp $";
d98 1
d157 16
@


1.23
log
@If sdl type is ISO88025, print the address using `:' as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.22 2000/12/13 15:52:58 camield Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.22 2000/12/13 15:52:58 camield Exp $";
a101 1
	int n;
d522 2
a523 2
			    sum->ift_ib -  total->ift_ib, " ",
			    sum->ift_ob -  total->ift_ob, " ");
d526 5
a530 5
			    sum->ift_ip - total->ift_ip,
			    sum->ift_ie - total->ift_ie,
			    sum->ift_op - total->ift_op,
			    sum->ift_oe - total->ift_oe,
			    sum->ift_co - total->ift_co);
@


1.22
log
@Bytecounter stats. (-b switch)
From NetBSD. ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.21 2000/10/23 19:17:08 mickey Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.21 2000/10/23 19:17:08 mickey Exp $";
d306 2
a307 1
				    sdl->sdl_type == IFT_FDDI)
@


1.21
log
@fix a few signed/unsigned/long printf formats; millert@@ & deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.20 2000/02/05 18:46:50 itojun Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.20 2000/02/05 18:46:50 itojun Exp $";
d122 7
a128 4
	printf("%-7.7s %-5.5s %-11.11s %-17.17s %8.8s %5.5s %8.8s %5.5s",
		"Name", "Mtu", "Network", "Address", "Ipkts", "Ierrs",
		"Opkts", "Oerrs");
	printf(" %5s", "Coll");
d333 8
a340 4
		printf("%8lu %5lu %8lu %5lu %5lu",
		    ifnet.if_ipackets, ifnet.if_ierrors,
		    ifnet.if_opackets, ifnet.if_oerrors,
		    ifnet.if_collisions);
d342 1
a342 1
			printf(" %3d", ifnet.if_timer);
d344 1
a344 1
			printf(" %3d", ifnet.if_snd.ifq_drops);
d353 1
d356 1
d400 1
a400 1
		snprintf(ip->ift_name, IFNAMSIZ, "(%s)", ifnet.if_xname);
d419 10
a428 1
	printf("   input    %-6.6s    output       ", interesting->ift_name);
d430 6
d437 1
a437 2
			printf("      ");
		printf("     input   (Total)    output");
d441 1
d444 1
d450 6
a455 7
	printf("%8.8s %5.5s %8.8s %5.5s %5.5s ",
		"packets", "errs", "packets", "errs", "colls");
	if (dflag)
		printf("%5.5s ", "drops");
	if (lastif - iftot > 0)
		printf(" %8.8s %5.5s %8.8s %5.5s %5.5s",
			"packets", "errs", "packets", "errs", "colls");
d458 10
d473 1
d476 1
d486 11
a496 6
			printf("%8ld %5ld %8ld %5ld %5ld",
				ifnet.if_ipackets - ip->ift_ip,
				ifnet.if_ierrors - ip->ift_ie,
				ifnet.if_opackets - ip->ift_op,
				ifnet.if_oerrors - ip->ift_oe,
				ifnet.if_collisions - ip->ift_co);
d502 1
d505 1
d510 1
d513 1
d520 11
a530 6
		printf("  %8d %5d %8d %5d %5d",
			sum->ift_ip - total->ift_ip,
			sum->ift_ie - total->ift_ie,
			sum->ift_op - total->ift_op,
			sum->ift_oe - total->ift_oe,
			sum->ift_co - total->ift_co);
@


1.20
log
@fix -in printing on IPv6 (network portion was not masked properly).
enable scopeid for -in.
don't truncate output on -inv.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.19 2000/01/18 05:39:34 itojun Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.19 2000/01/18 05:39:34 itojun Exp $";
d330 1
a330 1
		printf("%8ld %5ld %8ld %5ld %5ld",
@


1.19
log
@print IPv6 multicast groups on -ia.
align multicast addresses on output (broken on 1.15 -> 1.16).
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.18 1999/12/08 12:30:17 itojun Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.18 1999/12/08 12:30:17 itojun Exp $";
d102 1
d179 2
a180 2
				printf("%-11.11s ", netname(in.s_addr,
				    ifaddr.in.ia_subnetmask));
d182 2
a183 3
				printf("%-11.11s ",
				    netname(ifaddr.in.ia_subnet,
				    ifaddr.in.ia_subnetmask));
d185 11
a195 2
				printf("%-17.17s ",
				    routename(sin->sin_addr.s_addr));
d214 25
a238 4
				printf("%-11.11s ",
				    netname6(&ifaddr.in6.ia_addr,
					&ifaddr.in6.ia_prefixmask.sin6_addr));
				printf("%-17.17s ", routename6(sin6));
@


1.18
log
@add IPv6 support from KAME.  cleanup type matches with printf() format.
KAME_SCOPEID should be enabled after KAME get{addr,name}info(3) merge.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.17 1998/02/27 12:07:32 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.17 1998/02/27 12:07:32 deraadt Exp $";
d196 1
a196 1
						printf("\n%23s %-17.17s ", "",
d209 20
@


1.17
log
@oflow paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.16 1997/07/25 04:28:59 mickey Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.16 1997/07/25 04:28:59 mickey Exp $";
d91 3
d133 3
d202 9
@


1.16
log
@make CIA fit
make interface names fit
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.15 1997/07/23 04:38:33 denny Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.15 1997/07/23 04:38:33 denny Exp $";
d203 3
a205 2
				*(union ipx_net *) &net = sipx->sipx_addr.ipx_net;
				sprintf(netnum, "%xH", ntohl(net));
d223 3
a225 2
				*(union ns_net *) &net = sns->sns_addr.x_net;
				sprintf(netnum, "%xH", ntohl(net));
@


1.15
log
@Add AppleTalk support. TODO: route.c does not handle netranges.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.14 1997/06/30 03:11:53 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.14 1997/06/30 03:11:53 millert Exp $";
d118 1
a118 1
	printf("%-5.5s %-5.5s %-11.11s %-17.17s %8.8s %5.5s %8.8s %5.5s",
d147 1
a147 1
		printf("%-5.5s %-5ld ", name, ifnet.if_mtu);
@


1.14
log
@Make "netstat -ia" line up nicely.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.13 1997/06/29 21:46:00 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.13 1997/06/29 21:46:00 millert Exp $";
d210 4
@


1.13
log
@Use correct spacing on both 32bit and 64bit machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.12 1997/06/29 20:52:39 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.12 1997/06/29 20:52:39 millert Exp $";
d190 1
a190 1
						printf("\n%23s %-15.15s ", "",
@


1.12
log
@Make fields line up nicely for 64-bit addresses.  Should probably #if
some things based on sizeof(long).
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.11 1997/06/29 20:17:58 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.11 1997/06/29 20:17:58 millert Exp $";
d63 1
@


1.11
log
@Mostly clean -Wall + 64bit issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.10 1997/01/17 07:12:55 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.10 1997/01/17 07:12:55 millert Exp $";
d203 1
a203 1
				sprintf(netnum, "%lxH", ntohl(net));
d218 1
a218 1
				sprintf(netnum, "%lxH", ntohl(net));
@


1.10
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.9 1996/08/16 09:38:56 mickey Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.9 1996/08/16 09:38:56 mickey Exp $";
d54 1
d146 1
a146 1
		printf("%-5.5s %-5d ", name, ifnet.if_mtu);
d203 1
a203 1
				sprintf(netnum, "%xH", ntohl(net));
d218 1
a218 1
				sprintf(netnum, "%xH", ntohl(net));
d233 1
a233 1
					    ether_ntoa(LLADDR(sdl)));
d258 1
a258 1
		printf("%8d %5d %8d %5d %5d",
d378 1
a378 1
			printf("%8d %5d %8d %5d %5d",
@


1.9
log
@ipx.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.8 1996/08/16 09:29:32 mickey Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.8 1996/08/16 09:29:32 mickey Exp $";
d139 1
a139 1
			cp = index(name, '\0');
@


1.8
log
@ipx.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.7 1996/06/26 05:37:20 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.7 1996/06/26 05:37:20 deraadt Exp $";
d202 1
a202 1
				sprintf(netnum, "%lxH", ntohl(net));
d217 1
a217 1
				sprintf(netnum, "%lxH", ntohl(net));
@


1.7
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.16.4.2 1996/06/07 21:46:46 thorpej Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: if.c,v 1.16.4.2 1996/06/07 21:46:46 thorpej Exp $";
d56 2
d90 1
d192 15
@


1.6
log
@from netbsd Fix missing `)' in the sideways view of interfaces
(i.e. netstat -w 1). Bug pointed out by Chris G. Demetriou.
@
text
@d1 1
d41 1
a41 1
static char *rcsid = "$NetBSD: if.c,v 1.16.4.2 1996/06/07 21:46:46 thorpej Exp $";
@


1.5
log
@print ether/fddi addresses seperated by : not .; netbsd pr#2473; from jhawk@@mit.edu
@
text
@d1 1
a1 1
/*	$NetBSD: if.c,v 1.16.4.1 1996/06/04 20:27:06 cgd Exp $	*/
d40 1
a40 1
static char *rcsid = "$NetBSD: if.c,v 1.16.4.1 1996/06/04 20:27:06 cgd Exp $";
d298 3
a300 4
		ip->ift_name[0] = '(';
		bcopy(ifnet.if_xname, ip->ift_name + 1, IFNAMSIZ - 1);
		if (interface &&
		    strcmp(ip->ift_name + 1, interface) == 0)
a301 1
		ip->ift_name[IFNAMSIZ - 1] = '\0';
@


1.4
log
@handle up to 100 interfaces, nice message for non-existing interface
@
text
@d50 1
d198 1
a198 1
		sprintf(netnum, "%lxH", ntohl(net));
d209 10
a218 2
				    cp = (char *)LLADDR(sdl);
				    n = sdl->sdl_alen;
d220 1
a220 2
				m = printf("%-11.11s ", "<Link>");
				goto hexprint;
@


1.3
log
@if_name/if_unit -> if_xname/if_softc
network list is a TAILQ
@
text
@d1 1
a1 1
/*	$NetBSD: if.c,v 1.16 1996/05/07 05:30:45 thorpej Exp $	*/
d40 1
a40 1
static char *rcsid = "$NetBSD: if.c,v 1.16 1996/05/07 05:30:45 thorpej Exp $";
d242 1
a242 1
#define	MAXIF	10
d286 1
a286 1
	interesting = iftot;
d300 5
@


1.2
log
@resize an output field
@
text
@d1 1
a1 1
/*	$NetBSD: if.c,v 1.14 1995/10/17 07:17:04 jtc Exp $	*/
d40 1
a40 1
static char *rcsid = "$NetBSD: if.c,v 1.14 1995/10/17 07:17:04 jtc Exp $";
d73 2
d90 2
a91 1
	char name[16];
d101 7
a107 1
	if (kread(ifnetaddr, (char *)&ifnetaddr, sizeof ifnetaddr))
d109 2
d127 1
a127 2
			if (kread(ifnetaddr, (char *)&ifnet, sizeof ifnet) ||
			    kread((u_long)ifnet.if_name, name, 16))
d129 2
a130 1
			name[15] = '\0';
d132 1
a132 2
			if (interface != 0 && (strcmp(name, interface) != 0 ||
			    unit != ifnet.if_unit))
a134 1
			cp += sprintf(cp, "%d", ifnet.if_unit);
d244 1
a244 1
	char	ift_name[16];		/* interface name */
d271 1
d274 6
a279 1
	if (kread(off, (char *)&firstifnet, sizeof (u_long)))
d281 2
a287 2
		char *cp;

d291 3
a293 4
		if (kread((u_long)ifnet.if_name, ip->ift_name + 1, 15))
			break;
		if (interface && strcmp(ip->ift_name + 1, interface) == 0 &&
		    unit == ifnet.if_unit)
d295 1
a295 3
		ip->ift_name[15] = '\0';
		cp = index(ip->ift_name, '\0');
		sprintf(cp, "%d)", ifnet.if_unit);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: if.c,v 1.13 1995/10/03 21:42:36 thorpej Exp $	*/
d40 1
a40 1
static char *rcsid = "$NetBSD: if.c,v 1.13 1995/10/03 21:42:36 thorpej Exp $";
d100 1
a100 1
	printf("%-5.5s %-5.5s %-11.11s %-15.15s %10.10s %5.5s %8.8s %5.5s",
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

