head	1.101;
access;
symbols
	OPENBSD_6_2:1.101.0.6
	OPENBSD_6_2_BASE:1.101
	OPENBSD_6_1:1.101.0.4
	OPENBSD_6_1_BASE:1.101
	OPENBSD_6_0:1.99.0.4
	OPENBSD_6_0_BASE:1.99
	OPENBSD_5_9:1.99.0.2
	OPENBSD_5_9_BASE:1.99
	OPENBSD_5_8:1.98.0.6
	OPENBSD_5_8_BASE:1.98
	OPENBSD_5_7:1.98.0.2
	OPENBSD_5_7_BASE:1.98
	OPENBSD_5_6:1.93.0.6
	OPENBSD_5_6_BASE:1.93
	OPENBSD_5_5:1.93.0.4
	OPENBSD_5_5_BASE:1.93
	OPENBSD_5_4:1.90.0.2
	OPENBSD_5_4_BASE:1.90
	OPENBSD_5_3:1.89.0.2
	OPENBSD_5_3_BASE:1.89
	OPENBSD_5_2:1.88.0.6
	OPENBSD_5_2_BASE:1.88
	OPENBSD_5_1_BASE:1.88
	OPENBSD_5_1:1.88.0.4
	OPENBSD_5_0:1.88.0.2
	OPENBSD_5_0_BASE:1.88
	OPENBSD_4_9:1.87.0.6
	OPENBSD_4_9_BASE:1.87
	OPENBSD_4_8:1.87.0.4
	OPENBSD_4_8_BASE:1.87
	OPENBSD_4_7:1.87.0.2
	OPENBSD_4_7_BASE:1.87
	OPENBSD_4_6:1.86.0.4
	OPENBSD_4_6_BASE:1.86
	OPENBSD_4_5:1.84.0.2
	OPENBSD_4_5_BASE:1.84
	OPENBSD_4_4:1.81.0.2
	OPENBSD_4_4_BASE:1.81
	OPENBSD_4_3:1.78.0.2
	OPENBSD_4_3_BASE:1.78
	OPENBSD_4_2:1.74.0.4
	OPENBSD_4_2_BASE:1.74
	OPENBSD_4_1:1.74.0.2
	OPENBSD_4_1_BASE:1.74
	OPENBSD_4_0:1.73.0.2
	OPENBSD_4_0_BASE:1.73
	OPENBSD_3_9:1.70.0.4
	OPENBSD_3_9_BASE:1.70
	OPENBSD_3_8:1.70.0.2
	OPENBSD_3_8_BASE:1.70
	OPENBSD_3_7:1.66.0.2
	OPENBSD_3_7_BASE:1.66
	OPENBSD_3_6:1.64.0.2
	OPENBSD_3_6_BASE:1.64
	OPENBSD_3_5:1.62.0.2
	OPENBSD_3_5_BASE:1.62
	OPENBSD_3_4:1.56.0.2
	OPENBSD_3_4_BASE:1.56
	OPENBSD_3_3:1.51.0.2
	OPENBSD_3_3_BASE:1.51
	OPENBSD_3_2:1.49.0.2
	OPENBSD_3_2_BASE:1.49
	OPENBSD_3_1:1.45.0.2
	OPENBSD_3_1_BASE:1.45
	OPENBSD_3_0:1.42.0.2
	OPENBSD_3_0_BASE:1.42
	OPENBSD_2_9_BASE:1.39
	OPENBSD_2_9:1.39.0.2
	OPENBSD_2_8:1.38.0.2
	OPENBSD_2_8_BASE:1.38
	OPENBSD_2_7:1.35.0.2
	OPENBSD_2_7_BASE:1.35
	OPENBSD_2_6:1.29.0.2
	OPENBSD_2_6_BASE:1.29
	OPENBSD_2_5:1.27.0.2
	OPENBSD_2_5_BASE:1.27
	OPENBSD_2_4:1.25.0.2
	OPENBSD_2_4_BASE:1.25
	OPENBSD_2_3:1.23.0.2
	OPENBSD_2_3_BASE:1.23
	OPENBSD_2_2:1.20.0.2
	OPENBSD_2_2_BASE:1.20
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.101
date	2016.09.15.01.01.07;	author dlg;	state Exp;
branches;
next	1.100;
commitid	SH0rHlfoxqPDqFgT;

1.100
date	2016.08.27.04.13.43;	author guenther;	state Exp;
branches;
next	1.99;
commitid	zhvm7groPE9hsJC6;

1.99
date	2015.12.03.15.42.07;	author mpi;	state Exp;
branches;
next	1.98;
commitid	EC4eHRhabwq19H6j;

1.98
date	2015.02.12.01.49.02;	author claudio;	state Exp;
branches;
next	1.97;
commitid	EszVZ4RtthRFw1UZ;

1.97
date	2015.02.06.03.22.00;	author reyk;	state Exp;
branches;
next	1.96;
commitid	2ShTul7wSa8iiu5L;

1.96
date	2015.01.19.16.49.04;	author deraadt;	state Exp;
branches;
next	1.95;
commitid	V2o55D2oGJk5KNhj;

1.95
date	2015.01.16.06.40.10;	author deraadt;	state Exp;
branches;
next	1.94;
commitid	Uu5nFG3wCl0LACBb;

1.94
date	2014.12.26.05.47.23;	author tedu;	state Exp;
branches;
next	1.93;
commitid	nsFoJ51uh7UJImea;

1.93
date	2013.11.25.12.48.39;	author bluhm;	state Exp;
branches;
next	1.92;

1.92
date	2013.11.21.17.32.13;	author mikeb;	state Exp;
branches;
next	1.91;

1.91
date	2013.09.29.10.45.40;	author bluhm;	state Exp;
branches;
next	1.90;

1.90
date	2013.03.20.15.23.37;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2013.01.16.10.53.14;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.87;

1.87
date	2009.08.04.03.45.47;	author tedu;	state Exp;
branches;
next	1.86;

1.86
date	2009.05.31.18.03.42;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2009.05.07.15.51.53;	author claudio;	state Exp;
branches;
next	1.84;

1.84
date	2009.01.28.17.19.47;	author claudio;	state Exp;
branches;
next	1.83;

1.83
date	2008.11.09.23.00.56;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2008.09.15.20.13.10;	author claudio;	state Exp;
branches;
next	1.81;

1.81
date	2008.06.13.21.44.32;	author claudio;	state Exp;
branches;
next	1.80;

1.80
date	2008.06.13.05.59.05;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2008.06.13.05.57.50;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2007.12.19.08.49.23;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2007.12.19.01.47.00;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2007.12.14.18.35.46;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2007.09.05.20.29.05;	author claudio;	state Exp;
branches;
next	1.74;

1.74
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.73;

1.73
date	2006.08.29.21.51.13;	author claudio;	state Exp;
branches;
next	1.72;

1.72
date	2006.05.27.19.16.37;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2006.04.12.09.24.44;	author hshoexer;	state Exp;
branches;
next	1.70;

1.70
date	2005.06.08.04.47.04;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2005.06.07.00.53.25;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2005.03.30.08.23.47;	author jaredy;	state Exp;
branches;
next	1.67;

1.67
date	2005.03.25.17.01.04;	author jaredy;	state Exp;
branches;
next	1.66;

1.66
date	2004.11.17.01.47.20;	author itojun;	state Exp;
branches;
next	1.65;

1.65
date	2004.10.15.20.16.12;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2004.06.06.16.55.31;	author cedric;	state Exp;
branches;
next	1.63;

1.63
date	2004.05.04.22.50.18;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2004.03.13.22.02.13;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2004.01.13.20.03.28;	author otto;	state Exp;
branches;
next	1.60;

1.60
date	2003.10.07.19.48.07;	author tedu;	state Exp;
branches;
next	1.59;

1.59
date	2003.10.04.23.15.06;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2003.10.04.21.18.57;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2003.10.03.21.22.32;	author itojun;	state Exp;
branches;
next	1.56;

1.56
date	2003.08.27.00.33.33;	author henric;	state Exp;
branches;
next	1.55;

1.55
date	2003.08.26.08.33.12;	author itojun;	state Exp;
branches;
next	1.54;

1.54
date	2003.06.26.21.59.11;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2003.06.03.02.56.13;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2003.05.14.23.37.05;	author itojun;	state Exp;
branches;
next	1.51;

1.51
date	2003.02.12.14.41.08;	author jason;	state Exp;
branches;
next	1.50;

1.50
date	2003.02.01.01.51.31;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2002.09.23.17.48.46;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2002.09.19.16.22.33;	author ho;	state Exp;
branches;
next	1.47;

1.47
date	2002.07.25.03.58.56;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2002.05.27.01.50.36;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.16.21.27.50;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2002.01.17.21.34.58;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.42;

1.42
date	2001.10.09.09.21.10;	author brian;	state Exp;
branches;
next	1.41;

1.41
date	2001.08.18.22.14.03;	author brian;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.25.00.41.39;	author niklas;	state Exp;
branches;
next	1.39;

1.39
date	2000.12.11.17.33.07;	author provos;	state Exp;
branches;
next	1.38;

1.38
date	2000.09.19.03.18.46;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	2000.05.18.01.32.12;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2000.05.18.01.20.48;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2000.02.05.18.46.50;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2000.01.14.19.59.18;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2000.01.09.22.57.37;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	99.12.20.06.24.49;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	99.12.20.06.17.20;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	99.12.08.12.30.17;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	99.09.22.05.10.04;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	99.06.26.21.21.46;	author ho;	state Exp;
branches;
next	1.27;

1.27
date	99.03.15.15.59.08;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.02.24.22.57.35;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	98.06.23.22.40.40;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	98.05.18.19.03.29;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.02.27.12.07.40;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	98.02.26.10.13.08;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	98.02.26.10.06.13;	author peter;	state Exp;
branches;
next	1.20;

1.20
date	97.07.28.18.56.03;	author kstailey;	state Exp;
branches;
next	1.19;

1.19
date	97.07.25.04.29.00;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	97.07.23.04.38.34;	author denny;	state Exp;
branches;
next	1.17;

1.17
date	97.07.14.00.34.27;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	97.07.13.23.02.42;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	97.06.29.21.46.06;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.06.29.20.52.41;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.06.29.20.18.03;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.06.29.08.45.23;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	97.06.24.03.53.01;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.06.18.01.58.32;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.06.18.01.52.27;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	97.01.25.23.26.42;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	97.01.17.07.13.00;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.10.25.10.50.52;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.16.09.29.34;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.08.06.18.35.09;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.37.26;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.10.13.02.36;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.51;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.51;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.101
log
@dont #define _KERNEL around some #includes

the data structures are now readable without _KERNEL needing to be defined.

ok deraadt@@

there's probably a lot more of these that can be cleaned up if
anyone is interested in looking into it.
@
text
@/*	$OpenBSD: route.c,v 1.100 2016/08/27 04:13:43 guenther Exp $	*/
/*	$NetBSD: route.c,v 1.15 1996/05/07 02:55:06 thorpej Exp $	*/

/*
 * Copyright (c) 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/protosw.h>
#include <sys/select.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>
#include <netinet/ip_ipsp.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <sys/sysctl.h>

#include <err.h>
#include <limits.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "netstat.h"

/* alignment constraint for routing socket */
#define ROUNDUP(a) \
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
#define ADVANCE(x, n) (x += ROUNDUP((n)->sa_len))

struct radix_node_head ***rt_head;
struct radix_node_head ***rnt;
struct radix_node_head *rt_tables[AF_MAX+1];	/* provides enough space */
u_int8_t		  af2rtafidx[AF_MAX+1];

static union {
	struct		sockaddr u_sa;
	u_int32_t	u_data[64];
	int		u_dummy;	/* force word-alignment */
} pt_u;

int	do_rtent = 0;
struct	rtentry rtentry;
struct	radix_node rnode;
struct	radix_mask rmask;

static struct sockaddr *kgetsa(struct sockaddr *);
static void p_tree(struct radix_node *);
static void p_rtnode(void);
static void p_rtflags(u_char);
static void p_krtentry(struct rtentry *);

/*
 * Print routing tables.
 */
void
routepr(u_long rtree, u_long mtree, u_long af2idx, u_long rtbl_id_max,
    u_int tableid)
{
	struct radix_node_head *rnh, head;
	int i, idxmax = 0;
	u_int rtidxmax;

	printf("Routing tables\n");

	if (rtree == 0 || af2idx == 0) {
		printf("rt_tables: symbol not in namelist\n");
		return;
	}

	kread((u_long)rtree, &rt_head, sizeof(rt_head));
	kread((u_long)rtbl_id_max, &rtidxmax, sizeof(rtidxmax));
	kread((long)af2idx, &af2rtafidx, sizeof(af2rtafidx));

	for (i = 0; i <= AF_MAX; i++) {
		if (af2rtafidx[i] > idxmax)
			idxmax = af2rtafidx[i];
	}

	if ((rnt = calloc(rtidxmax + 1, sizeof(struct radix_node_head **))) ==
	    NULL)
		err(1, NULL);

	kread((u_long)rt_head, rnt, (rtidxmax + 1) *
	    sizeof(struct radix_node_head **));
	if (tableid > rtidxmax || rnt[tableid] == NULL) {
		printf("Bad table %u\n", tableid);
		return;
	}
	kread((u_long)rnt[tableid], rt_tables, (idxmax + 1) * sizeof(rnh));

	for (i = 0; i <= AF_MAX; i++) {
		if (i == AF_UNSPEC) {
			if (Aflag && (af == AF_UNSPEC || af == 0xff)) {
				kread(mtree, &rnh, sizeof(rnh));
				kread((u_long)rnh, &head, sizeof(head));
				printf("Netmasks:\n");
				p_tree(head.rnh_treetop);
			}
			continue;
		}
		if (af2rtafidx[i] == 0)
			/* no table for this AF */
			continue;
		if ((rnh = rt_tables[af2rtafidx[i]]) == NULL)
			continue;
		kread((u_long)rnh, &head, sizeof(head));
		if (af == AF_UNSPEC || af == i) {
			pr_family(i);
			do_rtent = 1;
			pr_rthdr(i, Aflag);
			p_tree(head.rnh_treetop);
		}
	}
}

static struct sockaddr *
kgetsa(struct sockaddr *dst)
{

	kread((u_long)dst, &pt_u.u_sa, sizeof(pt_u.u_sa));
	if (pt_u.u_sa.sa_len > sizeof (pt_u.u_sa))
		kread((u_long)dst, pt_u.u_data, pt_u.u_sa.sa_len);
	return (&pt_u.u_sa);
}

static void
p_tree(struct radix_node *rn)
{

again:
	kread((u_long)rn, &rnode, sizeof(rnode));
	if (rnode.rn_b < 0) {
		if (Aflag)
			printf("%-16p ", rn);
		if (rnode.rn_flags & RNF_ROOT) {
			if (Aflag)
				printf("(root node)%s",
				    rnode.rn_dupedkey ? " =>\n" : "\n");
		} else if (do_rtent) {
			kread((u_long)rn, &rtentry, sizeof(rtentry));
			p_krtentry(&rtentry);
			if (Aflag)
				p_rtnode();
		} else {
			p_sockaddr(kgetsa((struct sockaddr *)rnode.rn_key),
			    0, 0, 44);
			putchar('\n');
		}
		if ((rn = rnode.rn_dupedkey))
			goto again;
	} else {
		if (Aflag && do_rtent) {
			printf("%-16p ", rn);
			p_rtnode();
		}
		rn = rnode.rn_r;
		p_tree(rnode.rn_l);
		p_tree(rn);
	}
}

static void
p_rtflags(u_char flags)
{
	putchar('<');
	if (flags & RNF_NORMAL)
		putchar('N');
	if (flags & RNF_ROOT)
		putchar('R');
	if (flags & RNF_ACTIVE)
		putchar('A');
	if (flags & ~(RNF_NORMAL | RNF_ROOT | RNF_ACTIVE))
		printf("/0x%02x", flags);
	putchar('>');
}

char	nbuf[25];

static void
p_rtnode(void)
{
	struct radix_mask *rm = rnode.rn_mklist;

	if (rnode.rn_b < 0) {
		snprintf(nbuf, sizeof nbuf, " => %p", rnode.rn_dupedkey);
		printf("\t  (%p)%s", rnode.rn_p, rnode.rn_dupedkey ? nbuf : "");
		if (rnode.rn_mask) {
			printf(" mask ");
			p_sockaddr(kgetsa((struct sockaddr *)rnode.rn_mask),
			    0, 0, -1);
		} else if (rm == NULL) {
			putchar('\n');
			return;
		}
	} else {
		snprintf(nbuf, sizeof nbuf, "(%d)", rnode.rn_b);
		printf("%6.6s (%p) %16p : %16p", nbuf,
		    rnode.rn_p, rnode.rn_l, rnode.rn_r);
	}

	putchar(' ');
	p_rtflags(rnode.rn_flags);

	while (rm) {
		kread((u_long)rm, &rmask, sizeof(rmask));
		snprintf(nbuf, sizeof nbuf, " %d refs, ", rmask.rm_refs);
		printf("\n\tmk = %p {(%d),%s", rm, -1 - rmask.rm_b,
		    rmask.rm_refs ? nbuf : " ");
		p_rtflags(rmask.rm_flags);
		printf(", ");
		if (rmask.rm_flags & RNF_NORMAL) {
			struct radix_node rnode_aux;

			printf("leaf = %p ", rmask.rm_leaf);
			kread((u_long)rmask.rm_leaf, &rnode_aux, sizeof(rnode_aux));
			p_sockaddr(kgetsa((struct sockaddr *)rnode_aux.rn_mask),
			    0, 0, -1);
		} else
			p_sockaddr(kgetsa((struct sockaddr *)rmask.rm_mask),
			    0, 0, -1);
		putchar('}');
		if ((rm = rmask.rm_mklist))
			printf(" ->");
	}
	putchar('\n');
}

static void
p_krtentry(struct rtentry *rt)
{
	struct sockaddr_storage sock1, sock2;
	struct sockaddr *sa = (struct sockaddr *)&sock1;
	struct sockaddr *mask = (struct sockaddr *)&sock2;

	bcopy(kgetsa(rt_key(rt)), sa, sizeof(struct sockaddr));
	if (sa->sa_len > sizeof(struct sockaddr))
		bcopy(kgetsa(rt_key(rt)), sa, sa->sa_len);

	if (sa->sa_family == PF_KEY) {
		/* Ignore PF_KEY entries */
		return;
	}

	if (rt_mask(rt)) {
		bcopy(kgetsa(rt_mask(rt)), mask, sizeof(struct sockaddr));
		if (sa->sa_len > sizeof(struct sockaddr))
			bcopy(kgetsa(rt_mask(rt)), mask, sa->sa_len);
	} else
		mask = 0;

	p_addr(sa, mask, rt->rt_flags);
	p_gwaddr(kgetsa(rt->rt_gateway), sa->sa_family);
	p_flags(rt->rt_flags, "%-6.6s ");
	printf("%5u %8lld ", rt->rt_refcnt, rt->rt_use);
	if (rt->rt_rmx.rmx_mtu)
		printf("%5u ", rt->rt_rmx.rmx_mtu);
	else
		printf("%5s ", "-");
	putchar((rt->rt_rmx.rmx_locks & RTV_MTU) ? 'L' : ' ');
	printf("  %2d", rt->rt_priority);

	if (rt->rt_ifidx != 0) {
		printf(" if%d%s", rt->rt_ifidx,
		    rt->rt_nodes[0].rn_dupedkey ? " =>" : "");
	}
	putchar('\n');
	if (vflag)
		printf("\texpire   %10lld%c\n",
		    (long long)rt->rt_rmx.rmx_expire,
		    (rt->rt_rmx.rmx_locks & RTV_EXPIRE) ? 'L' : ' ');
}

/*
 * Print routing statistics
 */
void
rt_stats(void)
{
	struct rtstat rtstat;
	int mib[6];
	size_t size;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = 0;
	mib[4] = NET_RT_STATS;
	mib[5] = 0;
	size = sizeof (rtstat);

	if (sysctl(mib, 6, &rtstat, &size, NULL, 0) < 0) {
		perror("sysctl of routing table statistics");
		exit(1);
	}

	printf("routing:\n");
	printf("\t%u bad routing redirect%s\n",
	    rtstat.rts_badredirect, plural(rtstat.rts_badredirect));
	printf("\t%u dynamically created route%s\n",
	    rtstat.rts_dynamic, plural(rtstat.rts_dynamic));
	printf("\t%u new gateway%s due to redirects\n",
	    rtstat.rts_newgateway, plural(rtstat.rts_newgateway));
	printf("\t%u destination%s found unreachable\n",
	    rtstat.rts_unreach, plural(rtstat.rts_unreach));
	printf("\t%u use%s of a wildcard route\n",
	    rtstat.rts_wildcard, plural(rtstat.rts_wildcard));
}
@


1.100
log
@Pull in <sys/select.h> for howmany() and NBBY, used by various net*/*.h

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.99 2015/12/03 15:42:07 mpi Exp $	*/
a40 1
#define _KERNEL
a42 1
#undef _KERNEL
@


1.99
log
@Print the interface index, we no longer have a pointer to the interface.

Found the hardway by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.98 2015/02/12 01:49:02 claudio Exp $	*/
d35 1
@


1.98
log
@Switch the printing of open sockets from ugly KVM internals to use
kvm_getfiles. This allows to run netstat without any extra privileges
and removes another setgid program from base..
There is still kvm reader code in there which is used for debugging
purposes (crashdump). netstat should still behave mostly the same.
deraadt@@ and sthen@@ agree that it is time to get this puppy in.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.97 2015/02/06 03:22:00 reyk Exp $	*/
a37 1
#include <net/if_var.h>
a264 1
	static struct ifnet ifnet, *lastif;
d296 2
a297 6
	if (rt->rt_ifp) {
		if (rt->rt_ifp != lastif) {
			kread((u_long)rt->rt_ifp, &ifnet, sizeof(ifnet));
			lastif = rt->rt_ifp;
		}
		printf(" %.16s%s", ifnet.if_xname,
@


1.97
log
@Remove route/netstat -f encap in favor of ipsecctl -s flow.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.96 2015/01/19 16:49:04 deraadt Exp $	*/
d169 1
a169 1
			printf("%-16p ", hideroot ? 0 : rn);
d188 1
a188 1
			printf("%-16p ", hideroot ? 0 : rn);
d220 2
a221 4
		snprintf(nbuf, sizeof nbuf, " => %p",
		    hideroot ? 0 : rnode.rn_dupedkey);
		printf("\t  (%p)%s", hideroot ? 0 : rnode.rn_p,
		    rnode.rn_dupedkey ? nbuf : "");
d233 1
a233 3
		    hideroot ? 0 : rnode.rn_p,
		    hideroot ? 0 : rnode.rn_l,
		    hideroot ? 0 : rnode.rn_r);
d242 2
a243 3
		printf("\n\tmk = %p {(%d),%s",
		    hideroot ? 0 : rm,
		    -1 - rmask.rm_b, rmask.rm_refs ? nbuf : " ");
d249 1
a249 1
			printf("leaf = %p ", hideroot ? 0 : rmask.rm_leaf);
@


1.96
log
@First step of hiding many kernel-only parts of <netinet/ip_ipsp.h>
under _KERNEL, and adjust the one consumer (netstat) so that it requests
the exposure.  Will take a few more rounds to get this right.
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.95 2015/01/16 06:40:10 deraadt Exp $	*/
a85 1
static void encap_print(struct rtentry *);
d281 1
a281 1
		encap_print(rt);
a351 132
}

static void
encap_print(struct rtentry *rt)
{
	struct sockaddr_encap sen1, sen2, sen3;
	struct ipsec_policy ipo;
	struct sockaddr_in6 s61, s62;

	bcopy(kgetsa(rt_key(rt)), &sen1, sizeof(sen1));
	bcopy(kgetsa(rt_mask(rt)), &sen2, sizeof(sen2));
	bcopy(kgetsa(rt->rt_gateway), &sen3, sizeof(sen3));

	if (sen1.sen_type == SENT_IP4) {
		printf("%-18s %-5u ", netname4(sen1.sen_ip_src.s_addr,
		    sen2.sen_ip_src.s_addr), ntohs(sen1.sen_sport));
		printf("%-18s %-5u %-5u ", netname4(sen1.sen_ip_dst.s_addr,
		    sen2.sen_ip_dst.s_addr),
		    ntohs(sen1.sen_dport), sen1.sen_proto);
	}

	if (sen1.sen_type == SENT_IP6) {
		bzero(&s61, sizeof(s61));
		bzero(&s62, sizeof(s62));
		s61.sin6_family = s62.sin6_family = AF_INET6;
		s61.sin6_len = s62.sin6_len = sizeof(s61);
		bcopy(&sen1.sen_ip6_src, &s61.sin6_addr, sizeof(struct in6_addr));
#ifdef __KAME__
		if (IN6_IS_ADDR_LINKLOCAL(&s61.sin6_addr) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(&s61.sin6_addr) ||
		    IN6_IS_ADDR_MC_INTFACELOCAL(&s61.sin6_addr)) {
			s61.sin6_scope_id =
			    ((u_int16_t)s61.sin6_addr.s6_addr[2] << 8) |
			    s61.sin6_addr.s6_addr[3];
			s61.sin6_addr.s6_addr[2] = s61.sin6_addr.s6_addr[3] = 0;
		}
#endif
		bcopy(&sen2.sen_ip6_src, &s62.sin6_addr, sizeof(struct in6_addr));
#ifdef __KAME__
		if (IN6_IS_ADDR_LINKLOCAL(&s62.sin6_addr) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(&s62.sin6_addr) ||
		    IN6_IS_ADDR_MC_INTFACELOCAL(&s62.sin6_addr)) {
			s62.sin6_scope_id =
			    ((u_int16_t)s62.sin6_addr.s6_addr[2] << 8) |
			    s62.sin6_addr.s6_addr[3];
			s62.sin6_addr.s6_addr[2] = s62.sin6_addr.s6_addr[3] = 0;
		}
#endif

		printf("%-42s %-5u ", netname6(&s61, &s62),
		    ntohs(sen1.sen_ip6_sport));

		bzero(&s61, sizeof(s61));
		bzero(&s62, sizeof(s62));
		s61.sin6_family = s62.sin6_family = AF_INET6;
		s61.sin6_len = s62.sin6_len = sizeof(s61);
		bcopy(&sen1.sen_ip6_dst, &s61.sin6_addr, sizeof(struct in6_addr));
#ifdef __KAME__
		if (IN6_IS_ADDR_LINKLOCAL(&s61.sin6_addr) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(&s61.sin6_addr) ||
		    IN6_IS_ADDR_MC_INTFACELOCAL(&s61.sin6_addr)) {
			s61.sin6_scope_id =
			    ((u_int16_t)s61.sin6_addr.s6_addr[2] << 8) |
			    s61.sin6_addr.s6_addr[3];
			s61.sin6_addr.s6_addr[2] = s61.sin6_addr.s6_addr[3] = 0;
		}
#endif
		bcopy(&sen2.sen_ip6_dst, &s62.sin6_addr, sizeof(struct in6_addr));
#ifdef __KAME__
		if (IN6_IS_ADDR_LINKLOCAL(&s62.sin6_addr) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(&s62.sin6_addr) ||
		    IN6_IS_ADDR_MC_INTFACELOCAL(&s62.sin6_addr)) {
			s62.sin6_scope_id =
			    ((u_int16_t)s62.sin6_addr.s6_addr[2] << 8) |
			    s62.sin6_addr.s6_addr[3];
			s62.sin6_addr.s6_addr[2] = s62.sin6_addr.s6_addr[3] = 0;
		}
#endif

		printf("%-42s %-5u %-5u ", netname6(&s61, &s62),
		    ntohs(sen1.sen_ip6_dport), sen1.sen_ip6_proto);
	}

	if (sen3.sen_type == SENT_IPSP) {
		char hostn[NI_MAXHOST];

		kread((u_long)sen3.sen_ipsp, &ipo, sizeof(ipo));

		if (getnameinfo(&ipo.ipo_dst.sa, ipo.ipo_dst.sa.sa_len,
		    hostn, NI_MAXHOST, NULL, 0, NI_NUMERICHOST) != 0)
			strlcpy (hostn, "none", NI_MAXHOST);

		printf("%s", hostn);
		printf("/%-u", ipo.ipo_sproto);

		switch (ipo.ipo_type) {
		case IPSP_IPSEC_REQUIRE:
			printf("/require");
			break;
		case IPSP_IPSEC_ACQUIRE:
			printf("/acquire");
			break;
		case IPSP_IPSEC_USE:
			printf("/use");
			break;
		case IPSP_IPSEC_DONTACQ:
			printf("/dontacq");
			break;
		case IPSP_PERMIT:
			printf("/bypass");
			break;
		case IPSP_DENY:
			printf("/deny");
			break;
		default:
			printf("/<unknown type!>");
			break;
		}

		if ((ipo.ipo_addr.sen_type == SENT_IP4 &&
		    ipo.ipo_addr.sen_direction == IPSP_DIRECTION_IN) ||
		    (ipo.ipo_addr.sen_type == SENT_IP6 &&
		    ipo.ipo_addr.sen_ip6_direction == IPSP_DIRECTION_IN))
			printf("/in\n");
		else if ((ipo.ipo_addr.sen_type == SENT_IP4 &&
		    ipo.ipo_addr.sen_direction == IPSP_DIRECTION_OUT) ||
		    (ipo.ipo_addr.sen_type == SENT_IP6 &&
		    ipo.ipo_addr.sen_ip6_direction == IPSP_DIRECTION_OUT))
			printf("/out\n");
		else
			printf("/<unknown>\n");
	}
@


1.95
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.94 2014/12/26 05:47:23 tedu Exp $	*/
d43 1
a57 1
#include <netinet/ip_ipsp.h>
@


1.94
log
@not necessary to define INET anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.93 2013/11/25 12:48:39 bluhm Exp $	*/
d33 1
a33 1
#include <sys/param.h>
@


1.93
log
@netstat -Ar leaked some kernel pointers to unprivileged users.  Use
hideroot to show them only to root.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.92 2013/11/21 17:32:13 mikeb Exp $	*/
a55 4

#ifndef INET
#define INET
#endif
@


1.92
log
@split kernel parts of the if.h into a separate header file if_var.h
which allows us to modify ifnet structure in a relatively safe way;
discussed with deraadt, ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.91 2013/09/29 10:45:40 bluhm Exp $	*/
d174 1
a174 1
			printf("%-16p ", rn);
d193 1
a193 1
			printf("%-16p ", rn);
d240 3
a242 2
		    hideroot ? 0 : rnode.rn_p, rnode.rn_l,
		    rnode.rn_r);
@


1.91
log
@Prepare netstat for printing 64 bit route expire time.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.90 2013/03/20 15:23:37 deraadt Exp $	*/
d38 1
@


1.90
log
@As non-root, whenever netstat is about to print out a kernel pointer...
print 0x0 instead.  Hides a lot stuff people don't need to see.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.89 2013/01/16 10:53:14 deraadt Exp $	*/
d316 2
a317 2
		printf("\texpire   %10u%c\n",
		    rt->rt_rmx.rmx_expire,
@


1.89
log
@sys/mbuf.h not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.88 2011/04/06 11:36:26 miod Exp $	*/
d224 3
a226 2
		snprintf(nbuf, sizeof nbuf, " => %p", rnode.rn_dupedkey);
		printf("\t  (%p)%s", rnode.rn_p,
d238 2
a239 1
		printf("%6.6s (%p) %16p : %16p", nbuf, rnode.rn_p, rnode.rn_l,
d250 2
a251 1
		    rm, -1 - rmask.rm_b, rmask.rm_refs ? nbuf : " ");
d257 1
a257 1
			printf("leaf = %p ", rmask.rm_leaf);
@


1.88
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.87 2009/08/04 03:45:47 tedu Exp $	*/
a35 1
#include <sys/mbuf.h>
@


1.87
log
@fix some warnings.  there are others, but nobody wants to look at them.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.86 2009/05/31 18:03:42 claudio Exp $	*/
d105 1
a105 1
	if (rtree == NULL || af2idx == NULL) {
d141 1
a141 1
		if (af2rtafidx[i] == NULL)
@


1.86
log
@There is no need to mask priority with RTP_MASK because it is already done
by the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.85 2009/05/07 15:51:53 claudio Exp $	*/
d296 1
a296 1
	printf("%5u %8ld ", rt->rt_refcnt, rt->rt_use);
@


1.85
log
@Make the kvm routing table code grok multiple routing tables and do not
default to table 0 by default. Makes debugging alternate tables possible.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.84 2009/01/28 17:19:47 claudio Exp $	*/
d302 1
a302 1
	printf("  %2d", rt->rt_priority & RTP_MASK);
@


1.84
log
@Make the -A a bit more readable by adding a newline between the route and
mk list.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.83 2008/11/09 23:00:56 deraadt Exp $	*/
d96 2
a97 1
routepr(u_long rtree, u_long mtree, u_long af2idx, u_long rtbl_id_max)
d125 5
a129 1
	kread((u_long)rnt[0], rt_tables, (idxmax + 1) * sizeof(rnh));
@


1.83
log
@the extra kget() macro just befuddles the things we need to replace with a sysctl mechanism later
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.82 2008/09/15 20:13:10 claudio Exp $	*/
d243 1
a243 1
		printf(" mk = %16p {(%d),%s",
@


1.82
log
@Similar to route(8) change mask rtm->rtm_priority with RTP_MASK to show
correct values. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.81 2008/06/13 21:44:32 claudio Exp $	*/
a63 2
#define kget(p, d) (kread((u_long)(p), &(d), sizeof (d)))

d104 1
a104 1
	if (rtree == 0 || af2idx == 0) {
d109 3
a111 3
	kget(rtree, rt_head);
	kget(rtbl_id_max, rtidxmax);
	kget(af2idx, af2rtafidx);
d129 2
a130 2
				kget(mtree, rnh);
				kget(rnh, head);
d136 1
a136 1
		if (af2rtafidx[i] == 0)
d139 1
a139 1
		if ((rnh = rt_tables[af2rtafidx[i]]) == 0)
d141 1
a141 1
		kget(rnh, head);
d155 1
a155 1
	kget(dst, pt_u.u_sa);
d166 1
a166 1
	kget(rn, rnode);
d175 1
a175 1
			kget(rn, rtentry);
d227 1
a227 1
		} else if (rm == 0) {
d241 1
a241 1
		kget(rm, rmask);
d251 1
a251 1
			kget(rmask.rm_leaf, rnode_aux);
d301 1
a301 1
			kget(rt->rt_ifp, ifnet);
d434 1
a434 1
		kget(sen3.sen_ipsp, ipo);
@


1.81
log
@Include some additional pointers, etc that I really need for debugging
nasty routing table issues. Mainly the pointer to the previous node.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.80 2008/06/13 05:59:05 claudio Exp $	*/
d299 1
a299 1
	printf("  %2d", rt->rt_priority);
@


1.80
log
@remove a rather silly comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.79 2008/06/13 05:57:50 claudio Exp $	*/
d222 3
d226 1
a226 1
			printf("\t  mask ");
d229 2
a230 1
		} else if (rm == 0)
d232 1
d235 1
a235 1
		printf("%6.6s %16p : %16p", nbuf, rnode.rn_l,
@


1.79
log
@Let the kvm output of netstat grok rt priorities like the "normal" show code.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.78 2007/12/19 08:49:23 claudio Exp $	*/
d72 1
a72 1
struct radix_node_head ***rnt;			/* provides enough space */
@


1.78
log
@Remove the kvm code in rt_stats() and use the sysctl code all the time.
While there remove the ugly rflag checks and make it more consistent with
the rest of the code. Another step in making netstat setgid free.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.77 2007/12/19 01:47:00 deraadt Exp $	*/
d288 1
a288 1
	printf("%6d %8ld ", rt->rt_refcnt, rt->rt_use);
d290 1
a290 1
		printf("%6u ", rt->rt_rmx.rmx_mtu);
d292 1
a292 1
		printf("%6s ", "-");
d294 1
@


1.77
log
@delete rcsid crud
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.76 2007/12/14 18:35:46 deraadt Exp $	*/
d314 1
a314 1
rt_stats(int usesysctl, u_long off)
d320 12
a331 18
	if (usesysctl) {
		mib[0] = CTL_NET;
		mib[1] = PF_ROUTE;
		mib[2] = 0;
		mib[3] = 0;
		mib[4] = NET_RT_STATS;
		mib[5] = 0;
		size = sizeof (rtstat);

		if (sysctl(mib, 6, &rtstat, &size, NULL, 0) < 0) {
			perror("sysctl of routing table statistics");
			exit(1);
		}
	} else if (off == 0) {
		printf("rtstat: symbol not in namelist\n");
		return;
	} else
		kread(off, &rtstat, sizeof (rtstat));
@


1.76
log
@remove 21 nlist variables, and instead use sysctl to query the kernel
turn on INET6 the default (remove the #ifdef's)
ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.75 2007/09/05 20:29:05 claudio Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "from: @@(#)route.c	8.3 (Berkeley) 3/9/94";
#else
static char *rcsid = "$OpenBSD: route.c,v 1.75 2007/09/05 20:29:05 claudio Exp $";
#endif
#endif /* not lint */
@


1.75
log
@Correct the format strings after the recent rt_metrics changes.
rmx_pksent is not u_int64_t all others are just u_int.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.74 2006/11/17 01:11:23 itojun Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.74 2006/11/17 01:11:23 itojun Exp $";
d327 1
a327 1
 
a364 2

#ifdef INET6
a365 1
#endif /* INET6 */
a378 1
#ifdef INET6
a439 1
#endif /* INET6 */
@


1.74
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.73 2006/08/29 21:51:13 claudio Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.73 2006/08/29 21:51:13 claudio Exp $";
d298 1
a298 1
		printf("%6ld ", rt->rt_rmx.rmx_mtu);
d313 1
a313 1
		printf("\texpire   %10lu%c\n",
@


1.73
log
@Fix KVM snooping code of netstat that got broken by the multiple table
"support". This makes netstat -A work again. OK markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.72 2006/05/27 19:16:37 claudio Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.72 2006/05/27 19:16:37 claudio Exp $";
d391 2
a392 1
		    IN6_IS_ADDR_MC_LINKLOCAL(&s61.sin6_addr)) {
d402 2
a403 1
		    IN6_IS_ADDR_MC_LINKLOCAL(&s62.sin6_addr)) {
d421 2
a422 1
		    IN6_IS_ADDR_MC_LINKLOCAL(&s61.sin6_addr)) {
d432 2
a433 1
		    IN6_IS_ADDR_MC_LINKLOCAL(&s62.sin6_addr)) {
@


1.72
log
@Moving netstat from kvm snooping to retrieving the routing tables via
sysctl. Most code is stolen from route -- which was stolen from netstat.
kvm snooping code is still in and useable. Put it in deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.71 2006/04/12 09:24:44 hshoexer Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.71 2006/04/12 09:24:44 hshoexer Exp $";
d79 4
a82 1
struct radix_node_head *rt_tables[AF_MAX+1];
d106 1
a106 1
routepr(u_long rtree)
d109 2
a110 1
	int i;
d114 1
a114 1
	if (rtree == 0) {
d119 17
a135 1
	kget(rtree, rt_tables);
a136 3
		if ((rnh = rt_tables[i]) == 0)
			continue;
		kget(rnh, head);
d138 3
a140 1
			if (Aflag && (af == 0 || af == 0xff)) {
d144 9
a152 1
		} else if (af == AF_UNSPEC || af == i) {
@


1.71
log
@use "/bypass" instead of "/permit" when showing bypass flows

ok henning claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.70 2005/06/08 04:47:04 henning Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.70 2005/06/08 04:47:04 henning Exp $";
a54 4
#include <netipx/ipx.h>

#include <netatalk/at.h>

a56 2
#include <arpa/inet.h>

a80 27
/*
 * Definitions for showing gateway flags.
 */
struct bits {
	int	b_mask;
	char	b_val;
} bits[] = {
	{ RTF_UP,	'U' },
	{ RTF_GATEWAY,	'G' },
	{ RTF_HOST,	'H' },
	{ RTF_REJECT,	'R' },
	{ RTF_BLACKHOLE, 'B' },
	{ RTF_DYNAMIC,	'D' },
	{ RTF_MODIFIED,	'M' },
	{ RTF_DONE,	'd' }, /* Completed -- for routing messages only */
	{ RTF_MASK,	'm' }, /* Mask Present -- for routing messages only */
	{ RTF_CLONING,	'C' },
	{ RTF_XRESOLVE,	'X' },
	{ RTF_LLINFO,	'L' },
	{ RTF_STATIC,	'S' },
	{ RTF_PROTO1,	'1' },
	{ RTF_PROTO2,	'2' },
	{ RTF_PROTO3,	'3' },
	{ RTF_CLONED,	'c' },
	{ 0 }
};

a91 2
int	NewTree = 0;

d96 1
a96 5
static void ntreestuff(void);
static void np_rtentry(struct rt_msghdr *);
static void p_sockaddr(struct sockaddr *, struct sockaddr *, int, int);
static void p_flags(int, char *);
static void p_rtentry(struct rtentry *);
d110 4
a113 7
	if (Aflag == 0 && NewTree)
		ntreestuff();
	else {
		if (rtree == 0) {
			printf("rt_tables: symbol not in namelist\n");
			return;
		}
d115 8
a122 17
		kget(rtree, rt_tables);
		for (i = 0; i <= AF_MAX; i++) {
			if ((rnh = rt_tables[i]) == 0)
				continue;
			kget(rnh, head);
			if (i == AF_UNSPEC) {
				if (Aflag && af == 0) {
					printf("Netmasks:\n");
					p_tree(head.rnh_treetop);
				}
			} else if (af == AF_UNSPEC || af == i) {
				pr_family(i);
				do_rtent = 1;
				if (i != PF_KEY)
					pr_rthdr(i);
				else
					pr_encaphdr();
d125 5
a133 81
/*
 * Print address family header before a section of the routing table.
 */
void
pr_family(int af)
{
	char *afname;

	switch (af) {
	case AF_INET:
		afname = "Internet";
		break;
#ifdef INET6
	case AF_INET6:
		afname = "Internet6";
		break;
#endif
	case AF_IPX:
		afname = "IPX";
		break;
	case PF_KEY:
		afname = "Encap";
		break;
	case AF_APPLETALK:
		afname = "AppleTalk";
		break;
	default:
		afname = NULL;
		break;
	}
	if (afname)
		printf("\n%s:\n", afname);
	else
		printf("\nProtocol Family %d:\n", af);
}

/* column widths; each followed by one space */
#ifndef INET6
#define	WID_DST(af)	18	/* width of destination column */
#define	WID_GW(af)	18	/* width of gateway column */
#else
/* width of destination/gateway column */
#if 1
/* strlen("fe80::aaaa:bbbb:cccc:dddd@@gif0") == 30, strlen("/128") == 4 */
#define	WID_DST(af)	((af) == AF_INET6 ? (nflag ? 34 : 18) : 18)
#define	WID_GW(af)	((af) == AF_INET6 ? (nflag ? 30 : 18) : 18)
#else
/* strlen("fe80::aaaa:bbbb:cccc:dddd") == 25, strlen("/128") == 4 */
#define	WID_DST(af)	((af) == AF_INET6 ? (nflag ? 29 : 18) : 18)
#define	WID_GW(af)	((af) == AF_INET6 ? (nflag ? 25 : 18) : 18)
#endif
#endif /* INET6 */

/*
 * Print header for routing table columns.
 */
void
pr_rthdr(int af)
{

	if (Aflag)
		printf("%-*.*s ", PLEN, PLEN, "Address");
	printf("%-*.*s %-*.*s %-6.6s  %6.6s  %6.6s %6.6s  %s\n",
	    WID_DST(af), WID_DST(af), "Destination",
	    WID_GW(af), WID_GW(af), "Gateway",
	    "Flags", "Refs", "Use", "Mtu", "Interface");
}

/*
 * Print header for PF_KEY entries.
 */
void
pr_encaphdr(void)
{
	if (Aflag)
		printf("%-*s ", PLEN, "Address");
	printf("%-18s %-5s %-18s %-5s %-5s %-22s\n",
	    "Source", "Port", "Destination",
	    "Port", "Proto", "SA(Address/Proto/Type/Direction)");
}

d159 1
a159 1
			p_rtentry(&rtentry);
d243 1
a243 224
ntreestuff(void)
{
	size_t needed;
	int mib[6];
	char *buf, *next, *lim;
	struct rt_msghdr *rtm;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = 0;
	mib[4] = NET_RT_DUMP;
	mib[5] = 0;
	if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0) {
		perror("route-sysctl-estimate");
		exit(1);
	}
	if ((buf = malloc(needed)) == NULL)
		err(1, NULL);
	if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0) {
		perror("sysctl of routing table");
		exit(1);
	}
	lim = buf + needed;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		np_rtentry(rtm);
	}
	free(buf);
}

static void
np_rtentry(struct rt_msghdr *rtm)
{
	struct sockaddr *sa = (struct sockaddr *)(rtm + 1);
#ifdef notdef
	static int masks_done, banner_printed;
#endif
	static int old_af;
	int af = 0, interesting = RTF_UP | RTF_GATEWAY | RTF_HOST;

#ifdef notdef
	/* for the moment, netmasks are skipped over */
	if (!banner_printed) {
		printf("Netmasks:\n");
		banner_printed = 1;
	}
	if (masks_done == 0) {
		if (rtm->rtm_addrs != RTA_DST ) {
			masks_done = 1;
			af = sa->sa_family;
		}
	} else
#endif
		af = sa->sa_family;
	if (af != old_af) {
		pr_family(af);
		old_af = af;
	}
	if (rtm->rtm_addrs == RTA_DST)
		p_sockaddr(sa, 0, 0, 36);
	else {
		p_sockaddr(sa, 0, rtm->rtm_flags, 16);
		sa = (struct sockaddr *)(ROUNDUP(sa->sa_len) + (char *)sa);
		p_sockaddr(sa, 0, 0, 18);
	}
	p_flags(rtm->rtm_flags & interesting, "%-6.6s ");
	putchar('\n');
}

static void
p_sockaddr(struct sockaddr *sa, struct sockaddr *mask, int flags, int width)
{
	char workbuf[128], *cplim;
	char *cp = workbuf;
	size_t n;

	switch (sa->sa_family) {
	case AF_INET:
	    {
		struct sockaddr_in *sin = (struct sockaddr_in *)sa;
		struct sockaddr_in *msin = (struct sockaddr_in *)mask;

		cp = (sin->sin_addr.s_addr == 0 && mask &&
		    msin->sin_addr.s_addr == 0) ? "default" :
		    (mask == NULL || msin->sin_addr.s_addr == (in_addr_t)-1 ?
		    routename(sin->sin_addr.s_addr) :
		    netname(sin->sin_addr.s_addr, msin->sin_addr.s_addr));

		break;
	    }

#ifdef INET6
	case AF_INET6:
	    {
		struct sockaddr_in6 *sa6 = (struct sockaddr_in6 *)sa;
#ifdef __KAME__
		struct in6_addr *in6 = &sa6->sin6_addr;

		/*
		 * XXX: This is a special workaround for KAME kernels.
		 * sin6_scope_id field of SA should be set in the future.
		 */
		if (IN6_IS_ADDR_LINKLOCAL(in6) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(in6)) {
			/* XXX: override is ok? */
			sa6->sin6_scope_id = (u_int32_t)ntohs(*(u_short *)
			    &in6->s6_addr[2]);
			*(u_short *)&in6->s6_addr[2] = 0;
		}
#endif
		if (flags & RTF_HOST)
			cp = routename6(sa6);
		else if (mask) {
			cp = netname6(sa6,
			    &((struct sockaddr_in6 *)mask)->sin6_addr);
		} else
			cp = netname6(sa6, NULL);
		break;
	    }
#endif

	case AF_IPX:
		cp = ipx_print(sa);
		break;

	case AF_LINK:
	    {
		struct sockaddr_dl *sdl = (struct sockaddr_dl *)sa;

		if (sdl->sdl_nlen == 0 && sdl->sdl_alen == 0 &&
		    sdl->sdl_slen == 0)
			(void) snprintf(workbuf, sizeof workbuf,
			    "link#%d", sdl->sdl_index);
		else switch (sdl->sdl_type) {
		case IFT_ETHER:
		    {
			int i;
			u_char *lla = (u_char *)sdl->sdl_data +
			    sdl->sdl_nlen;

			cplim = "";
			for (i = 0; i < sdl->sdl_alen; i++, lla++) {
				n = snprintf(cp,
				    workbuf + sizeof (workbuf) - cp,
				    "%s%x", cplim, *lla);
				cplim = ":";
				if (n < 0)	/* What else to do ? */
					continue;
				if (n >= workbuf + sizeof (workbuf) - cp)
					n = workbuf + sizeof (workbuf) - cp - 1;
				cp += n;
			}
			cp = workbuf;
			break;
		    }
		default:
			cp = link_ntoa(sdl);
			break;
		}
		break;
	    }

	case AF_APPLETALK:
	    {
		/* XXX could do better */
		cp = atalk_print(sa,11);
		break;
	    }
	default:
	    {
		u_char *s = (u_char *)sa->sa_data, *slim;

		slim = sa->sa_len + (u_char *) sa;
		cplim = cp + sizeof(workbuf) - 6;
		if ((n = snprintf(cp, cplim - cp, "(%d)", sa->sa_family)) >=
		    cplim - cp)
			n = cplim - cp - 1;
		if (n > 0)
			cp += n;
		while (s < slim && cp < cplim) {
			if ((n = snprintf(cp, workbuf + sizeof (workbuf) - cp,
			    " %02x", *s++)) >= workbuf + sizeof (workbuf) - cp)
				n = workbuf + sizeof (workbuf) - cp - 1;
			if (n > 0)
				cp += n;
			if (s < slim) {
				if ((n = snprintf(cp,
				    workbuf + sizeof (workbuf) - cp,
				    "%02x", *s++)) >=
				    workbuf + sizeof (workbuf) - cp)
					n = workbuf + sizeof (workbuf) - cp - 1;
				if (n > 0)
					cp += n;
			}
		}
		cp = workbuf;
	    }
	}
	if (width < 0 )
		printf("%s ", cp);
	else {
		if (nflag)
			printf("%-*s ", width, cp);
		else
			printf("%-*.*s ", width, width, cp);
	}
}

static void
p_flags(int f, char *format)
{
	char name[33], *flags;
	struct bits *p = bits;

	for (flags = name; p->b_mask; p++)
		if (p->b_mask & f)
			*flags++ = p->b_val;
	*flags = '\0';
	printf(format, name);
}

static void
p_rtentry(struct rtentry *rt)
d266 2
a267 2
	p_sockaddr(sa, mask, rt->rt_flags, WID_DST(sa->sa_family));
	p_sockaddr(kgetsa(rt->rt_gateway), 0, RTF_HOST, WID_GW(sa->sa_family));
d275 1
a290 180
char *
routename(in_addr_t in)
{
	char *cp;
	static char line[MAXHOSTNAMELEN];
	struct hostent *hp;
	static char domain[MAXHOSTNAMELEN];
	static int first = 1;

	if (first) {
		first = 0;
		if (gethostname(domain, sizeof domain) == 0 &&
		    (cp = strchr(domain, '.')))
			(void) strlcpy(domain, cp + 1, sizeof domain);
		else
			domain[0] = '\0';
	}
	cp = NULL;
	if (!nflag) {
		hp = gethostbyaddr((char *)&in, sizeof (struct in_addr),
		    AF_INET);
		if (hp) {
			if ((cp = strchr(hp->h_name, '.')) &&
			    !strcmp(cp + 1, domain))
				*cp = '\0';
			cp = hp->h_name;
		}
	}
	if (cp) {
		strlcpy(line, cp, sizeof(line));
	} else {
#define C(x)	((x) & 0xff)
		in = ntohl(in);
		snprintf(line, sizeof line, "%u.%u.%u.%u",
		    C(in >> 24), C(in >> 16), C(in >> 8), C(in));
	}
	return (line);
}

/*
 * Return the name of the network whose address is given.
 * The address is assumed to be that of a net or subnet, not a host.
 */
char *
netname(in_addr_t in, in_addr_t mask)
{
	char *cp = NULL;
	static char line[MAXHOSTNAMELEN];
	struct netent *np = NULL;
	int mbits;

	in = ntohl(in);
	mask = ntohl(mask);
	if (!nflag && in != INADDR_ANY) {
		if ((np = getnetbyaddr(in, AF_INET)) != NULL)
			cp = np->n_name;
	}
	mbits = mask ? 33 - ffs(mask) : 0;
	if (cp) {
		strlcpy(line, cp, sizeof(line));
	} else if (mbits < 9)
		snprintf(line, sizeof line, "%u/%d", C(in >> 24), mbits);
	else if (mbits < 17)
		snprintf(line, sizeof line, "%u.%u/%d",
		    C(in >> 24) , C(in >> 16), mbits);
	else if (mbits < 25)
		snprintf(line, sizeof line, "%u.%u.%u/%d",
		    C(in >> 24), C(in >> 16), C(in >> 8), mbits);
	else
		snprintf(line, sizeof line, "%u.%u.%u.%u/%d", C(in >> 24),
		    C(in >> 16), C(in >> 8), C(in), mbits);
	return (line);
}

#ifdef INET6
char *
netname6(struct sockaddr_in6 *sa6, struct in6_addr *mask)
{
	static char line[MAXHOSTNAMELEN + 1];
	struct sockaddr_in6 sin6;
	u_char *p;
	u_char *lim;
	int masklen, final = 0, illegal = 0;
	int i;
	char hbuf[NI_MAXHOST];
	int flag = 0;
	int error;

	sin6 = *sa6;

	masklen = 0;
	lim = (u_char *)(mask + 1);
	i = 0;
	if (mask) {
		for (p = (u_char *)mask; p < lim; p++) {
			if (final && *p) {
				illegal++;
				sin6.sin6_addr.s6_addr[i++] = 0x00;
				continue;
			}

			switch (*p & 0xff) {
			case 0xff:
				masklen += 8;
				break;
			case 0xfe:
				masklen += 7;
				final++;
				break;
			case 0xfc:
				masklen += 6;
				final++;
				break;
			case 0xf8:
				masklen += 5;
				final++;
				break;
			case 0xf0:
				masklen += 4;
				final++;
				break;
			case 0xe0:
				masklen += 3;
				final++;
				break;
			case 0xc0:
				masklen += 2;
				final++;
				break;
			case 0x80:
				masklen += 1;
				final++;
				break;
			case 0x00:
				final++;
				break;
			default:
				final++;
				illegal++;
				break;
			}

			if (!illegal)
				sin6.sin6_addr.s6_addr[i++] &= *p;
			else
				sin6.sin6_addr.s6_addr[i++] = 0x00;
		}
	} else
		masklen = 128;

	if (masklen == 0 && IN6_IS_ADDR_UNSPECIFIED(&sin6.sin6_addr))
		return("default");

	if (illegal)
		fprintf(stderr, "illegal prefixlen\n");

	if (nflag)
		flag |= NI_NUMERICHOST;
	error = getnameinfo((struct sockaddr *)&sin6, sin6.sin6_len,
	    hbuf, sizeof(hbuf), NULL, 0, flag);
	if (error)
		snprintf(hbuf, sizeof(hbuf), "invalid");

	snprintf(line, sizeof(line), "%s/%d", hbuf, masklen);
	return line;
}

char *
routename6(struct sockaddr_in6 *sa6)
{
	static char line[NI_MAXHOST];
	const int niflag = NI_NUMERICHOST;

	if (getnameinfo((struct sockaddr *)sa6, sa6->sin6_len,
	    line, sizeof(line), NULL, 0, niflag) != 0)
		strlcpy(line, "", sizeof line);
	return line;
}
#endif /*INET6*/

d295 1
a295 1
rt_stats(u_long off)
d298 17
a314 2

	if (off == 0) {
d317 3
a319 2
	}
	kread(off, &rtstat, sizeof (rtstat));
a332 66
u_short ipx_nullh[] = {0,0,0};
u_short ipx_bh[] = {0xffff,0xffff,0xffff};

char *
ipx_print(struct sockaddr *sa)
{
	struct sockaddr_ipx *sipx = (struct sockaddr_ipx*)sa;
	struct ipx_addr work;
	union { union ipx_net net_e; u_long long_e; } net;
	in_port_t port;
	static char mybuf[50], cport[10], chost[25];
	char *host = "";
	char *q;

	work = sipx->sipx_addr;
	port = ntohs(work.ipx_port);
	work.ipx_port = 0;
	net.net_e = work.ipx_net;
	if (ipx_nullhost(work) && net.long_e == 0) {
		if (port != 0) {
			snprintf(mybuf, sizeof mybuf, "*.%xH", port);
			upHex(mybuf);
		} else
			snprintf(mybuf, sizeof mybuf, "*.*");
		return (mybuf);
	}

	if (bcmp(ipx_bh, work.ipx_host.c_host, 6) == 0) {
		host = "any";
	} else if (bcmp(ipx_nullh, work.ipx_host.c_host, 6) == 0) {
		host = "*";
	} else {
		q = work.ipx_host.c_host;
		snprintf(chost, sizeof chost, "%02x:%02x:%02x:%02x:%02x:%02x",
		    q[0], q[1], q[2], q[3], q[4], q[5]);
		host = chost;
	}
	if (port)
		snprintf(cport, sizeof cport, ".%xH", htons(port));
	else
		*cport = 0;

	snprintf(mybuf, sizeof mybuf, "%xH.%s%s", ntohl(net.long_e),
	    host, cport);
	upHex(mybuf);
	return(mybuf);
}

char *
ipx_phost(struct sockaddr *sa)
{
	struct sockaddr_ipx *sipx = (struct sockaddr_ipx *)sa;
	struct sockaddr_ipx work;
	static union ipx_net ipx_zeronet;
	char *p;

	work = *sipx;
	work.sipx_addr.ipx_port = 0;
	work.sipx_addr.ipx_net = ipx_zeronet;

	p = ipx_print((struct sockaddr *)&work);
	if (strncmp("0H.", p, 3) == 0)
		p += 3;
	return(p);
}

d348 1
a348 1
		printf("%-18s %-5u ", netname(sen1.sen_ip_src.s_addr,
d350 1
a350 1
		printf("%-18s %-5u %-5u ", netname(sen1.sen_ip_dst.s_addr,
d382 1
a382 1
		printf("%-42s %-5u ", netname6(&s61, &s62.sin6_addr),
d410 1
a410 1
		printf("%-42s %-5u %-5u ", netname6(&s61, &s62.sin6_addr),
a462 18
	}
}

void
upHex(char *p0)
{
	char *p = p0;

	for (; *p; p++)
		switch (*p) {
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
			*p += ('A' - 'a');
			break;
@


1.70
log
@bye bye, Xerox NS protocols
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.69 2005/06/07 00:53:25 henning Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.69 2005/06/07 00:53:25 henning Exp $";
d1020 1
a1020 1
			printf("/permit");
@


1.69
log
@remove tiny AF_CCITT trace
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.68 2005/03/30 08:23:47 jaredy Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.68 2005/03/30 08:23:47 jaredy Exp $";
a54 2
#include <netns/ns.h>

a196 3
	case AF_NS:
		afname = "XNS";
		break;
a491 4
	case AF_NS:
		cp = ns_print(sa);
		break;

a843 69
}

short ns_nullh[] = {0,0,0};
short ns_bh[] = {-1,-1,-1};

char *
ns_print(struct sockaddr *sa)
{
	struct sockaddr_ns *sns = (struct sockaddr_ns*)sa;
	struct ns_addr work;
	union { union ns_net net_e; u_long long_e; } net;
	in_port_t port;
	static char mybuf[50], cport[10], chost[25];
	char *host = "";
	char *p;
	u_char *q;

	work = sns->sns_addr;
	port = ntohs(work.x_port);
	work.x_port = 0;
	net.net_e = work.x_net;
	if (ns_nullhost(work) && net.long_e == 0) {
		if (port ) {
			snprintf(mybuf, sizeof mybuf, "*.%xH", port);
			upHex(mybuf);
		} else
			snprintf(mybuf, sizeof mybuf, "*.*");
		return (mybuf);
	}

	if (bcmp(ns_bh, work.x_host.c_host, 6) == 0) {
		host = "any";
	} else if (bcmp(ns_nullh, work.x_host.c_host, 6) == 0) {
		host = "*";
	} else {
		q = work.x_host.c_host;
		snprintf(chost, sizeof chost, "%02x%02x%02x%02x%02x%02xH",
		    q[0], q[1], q[2], q[3], q[4], q[5]);
		for (p = chost; *p == '0' && p < chost + 12; p++)
			continue;
		host = p;
	}
	if (port)
		snprintf(cport, sizeof cport, ".%xH", htons(port));
	else
		*cport = 0;

	snprintf(mybuf, sizeof mybuf, "%xH.%s%s", ntohl(net.long_e),
	    host, cport);
	upHex(mybuf);
	return(mybuf);
}

char *
ns_phost(struct sockaddr *sa)
{
	struct sockaddr_ns *sns = (struct sockaddr_ns *)sa;
	struct sockaddr_ns work;
	static union ns_net ns_zeronet;
	char *p;

	work = *sns;
	work.sns_addr.x_port = 0;
	work.sns_addr.x_net = ns_zeronet;

	p = ns_print((struct sockaddr *)&work);
	if (strncmp("0H.", p, 3) == 0)
		p += 3;
	return(p);
@


1.68
log
@kill -S; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.67 2005/03/25 17:01:04 jaredy Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.67 2005/03/25 17:01:04 jaredy Exp $";
a203 3
		break;
	case AF_CCITT:
		afname = "X.25";
@


1.67
log
@kill unneeded (char *) casts.  ok millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.66 2004/11/17 01:47:20 itojun Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.66 2004/11/17 01:47:20 itojun Exp $";
a112 1
	{ RTF_SOURCE,	's' },
a138 1
static void sa_src2dst(struct sockaddr *);
d250 2
a251 6
	if (Sflag)
		printf("%-*.*s ",
		    WID_DST(af), WID_DST(af), "Source");
	printf("%-*.*s ",
	    WID_DST(af), WID_DST(af), "Destination");
	printf("%-*.*s %-6.6s  %6.6s  %6.6s %6.6s  %s\n",
a627 7
	if (Sflag && sa->sa_family == AF_INET) {
		sa_src2dst(sa);
		sa_src2dst(mask);
		p_sockaddr(sa, mask, rt->rt_flags, WID_DST(sa->sa_family));
		sa_src2dst(sa);
		sa_src2dst(mask);
	}
a1140 13
	}
}

void
sa_src2dst(struct sockaddr *sa)
{
	struct sockaddr_rtin	*rtin = satortin(sa);
	struct in_addr		 tmp;

	if (sa != NULL) {
		tmp = rtin->rtin_dst;
		rtin->rtin_dst = rtin->rtin_src;
		rtin->rtin_src = tmp;
@


1.66
log
@remove NI_WITHSCOPEID (which is not standard)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.65 2004/10/15 20:16:12 henning Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.65 2004/10/15 20:16:12 henning Exp $";
d80 1
a80 1
#define kget(p, d) (kread((u_long)(p), (char *)&(d), sizeof (d)))
d281 1
a281 1
		kread((u_long)dst, (char *)pt_u.u_data, pt_u.u_sa.sa_len);
d857 1
a857 1
	kread(off, (char *)&rtstat, sizeof (rtstat));
@


1.65
log
@the default route is exactly 0.0.0.0/0, and nothing else. stop ignoring
the netmask, do not print a 0.0.0.0/32 route as "default"; it is not. neither
is 0.0.0.0/24.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.64 2004/06/06 16:55:31 cedric Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.64 2004/06/06 16:55:31 cedric Exp $";
a749 3
#ifdef NI_WITHSCOPEID
	int flag = NI_WITHSCOPEID;
#else
a750 1
#endif
a835 3
#ifdef NI_WITHSCOPEID
	const int niflag = NI_NUMERICHOST | NI_WITHSCOPEID;
#else
d837 1
a837 1
#endif
@


1.64
log
@Add new '-S' flag to display the source selector part of the routing table
entry. "netstat -nrSf inet". ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.63 2004/05/04 22:50:18 claudio Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.63 2004/05/04 22:50:18 claudio Exp $";
a206 3
	case AF_ISO:
		afname = "ISO";
		break;
d467 2
a468 1
		cp = (sin->sin_addr.s_addr == 0) ? "default" :
@


1.63
log
@The tcp specific routing metrics are almost never used so reduce the routing
table from these metrics. struct rt_msghdr used by the routing socket is not
affected and so most userland apps don't need to be changed.
some man page polishing by jmc@@
OK henning@@ markus@@ theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.62 2004/03/13 22:02:13 deraadt Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.62 2004/03/13 22:02:13 deraadt Exp $";
d113 1
d140 1
d255 6
a260 2
	printf("%-*.*s %-*.*s %-6.6s  %6.6s  %6.6s %6.6s  %s\n",
	    WID_DST(af), WID_DST(af), "Destination",
d471 1
a471 1
		    ((flags & RTF_HOST) || mask == NULL ?
d636 7
d1163 13
@


1.62
log
@some NULL vs 0 and knf; parts from nimadeus@@pandora.be
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.61 2004/01/13 20:03:28 otto Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.61 2004/01/13 20:03:28 otto Exp $";
d648 2
a649 3
	if (vflag) {
		printf("\texpire   %10lu%c  recvpipe %10ld%c  "
		    "sendpipe %10ld%c\n",
d651 1
a651 14
		    (rt->rt_rmx.rmx_locks & RTV_EXPIRE) ? 'L' : ' ',
		    rt->rt_rmx.rmx_recvpipe,
		    (rt->rt_rmx.rmx_locks & RTV_RPIPE) ? 'L' : ' ',
		    rt->rt_rmx.rmx_sendpipe,
		    (rt->rt_rmx.rmx_locks & RTV_SPIPE) ? 'L' : ' ');
		printf("\tssthresh %10lu%c  rtt      %10ld%c  "
		    "rttvar   %10ld%c\n",
		    rt->rt_rmx.rmx_ssthresh,
		    (rt->rt_rmx.rmx_locks & RTV_SSTHRESH) ? 'L' : ' ',
		    rt->rt_rmx.rmx_rtt,
		    (rt->rt_rmx.rmx_locks & RTV_RTT) ? 'L' : ' ',
		    rt->rt_rmx.rmx_rttvar,
		    (rt->rt_rmx.rmx_locks & RTV_RTTVAR) ? 'L' : ' ');
	}
@


1.61
log
@Fix printf formats and add missing include.

ok mcbride@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.60 2003/10/07 19:48:07 tedu Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.60 2003/10/07 19:48:07 tedu Exp $";
d685 1
a685 1
	cp = 0;
d692 1
a692 1
				*cp = 0;
d714 1
a714 1
	char *cp = 0;
d716 1
a716 1
	struct netent *np = 0;
@


1.60
log
@missing free().  Andrey Matveev via deraadt@@. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.59 2003/10/04 23:15:06 deraadt Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.59 2003/10/04 23:15:06 deraadt Exp $";
d65 1
@


1.59
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.58 2003/10/04 21:18:57 deraadt Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.58 2003/10/04 21:18:57 deraadt Exp $";
d408 1
@


1.58
log
@tweaks from andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.57 2003/10/03 21:22:32 itojun Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.57 2003/10/03 21:22:32 itojun Exp $";
d398 1
a398 1
		errx(1, NULL);
@


1.57
log
@deal with KAME embedded scope-id for PF_KEY (Encap) route dump.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.56 2003/08/27 00:33:33 henric Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.56 2003/08/27 00:33:33 henric Exp $";
a75 1
#include <sys/socket.h>
d397 2
a398 4
	if ((buf = malloc(needed)) == 0) {
		printf("out of space\n");
		exit(1);
	}
@


1.56
log
@RNF_IGNORE can corrupt the radix tree when an interface is down, it
makes routing lookups slightly more expensive, and serves no useful
purpose.

ok itojun@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.55 2003/08/26 08:33:12 itojun Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.55 2003/08/26 08:33:12 itojun Exp $";
d1046 9
d1056 9
d1074 9
d1084 9
@


1.55
log
@mark cloned route with RTF_CLONED.  remove RTF_CLONED route when clone parent
disappers.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.54 2003/06/26 21:59:11 deraadt Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.54 2003/06/26 21:59:11 deraadt Exp $";
d328 1
a328 3
	if (flags & RNF_IGNORE)
		putchar('I');
	if (flags & ~(RNF_NORMAL | RNF_ROOT | RNF_ACTIVE | RNF_IGNORE))
@


1.54
log
@more proto fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.53 2003/06/03 02:56:13 millert Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.53 2003/06/03 02:56:13 millert Exp $";
d93 1
a93 1
	short	b_mask;
d112 1
@


1.53
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.52 2003/05/14 23:37:05 itojun Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.52 2003/05/14 23:37:05 itojun Exp $";
d130 1
a130 1
static void p_rtnode();
d132 1
a132 1
static void ntreestuff();
@


1.52
log
@use __KAME__ to determine kame-based kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.51 2003/02/12 14:41:08 jason Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char *rcsid = "$OpenBSD: route.c,v 1.51 2003/02/12 14:41:08 jason Exp $";
@


1.51
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.50 2003/02/01 01:51:31 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.50 2003/02/01 01:51:31 deraadt Exp $";
d236 1
a236 1
#ifdef KAME_SCOPEID
d482 1
a482 1
#ifdef KAME_SCOPEID
@


1.50
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.49 2002/09/23 17:48:46 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.49 2002/09/23 17:48:46 deraadt Exp $";
d90 2
@


1.49
log
@correctly dump radix_node; henric@@attbi.com
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.48 2002/09/19 16:22:33 ho Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.48 2002/09/19 16:22:33 ho Exp $";
d145 1
a145 2
routepr(rtree)
	u_long rtree;
d187 1
a187 2
pr_family(af)
	int af;
d249 1
a249 2
pr_rthdr(af)
	int af;
d264 1
a264 1
pr_encaphdr()
d274 1
a274 2
kgetsa(dst)
	struct sockaddr *dst;
d284 1
a284 2
p_tree(rn)
	struct radix_node *rn;
d339 1
a339 1
p_rtnode()
d384 1
a384 1
ntreestuff()
d417 1
a417 2
np_rtentry(rtm)
	struct rt_msghdr *rtm;
d456 1
a456 3
p_sockaddr(sa, mask, flags, width)
	struct sockaddr *sa, *mask;
	int flags, width;
d598 1
a598 3
p_flags(f, format)
	int f;
	char *format;
d611 1
a611 2
p_rtentry(rt)
	struct rtentry *rt;
d649 1
a649 1
			rt->rt_nodes[0].rn_dupedkey ? " =>" : "");
d673 1
a673 2
routename(in)
	in_addr_t in;
d716 1
a716 2
netname(in, mask)
	in_addr_t in, mask;
d748 1
a748 3
netname6(sa6, mask)
	struct sockaddr_in6 *sa6;
	struct in6_addr *mask;
d844 1
a844 2
routename6(sa6)
	struct sockaddr_in6 *sa6;
d863 1
a863 2
rt_stats(off)
	u_long off;
d889 1
a889 2
ns_print(sa)
	struct sockaddr *sa;
d937 1
a937 2
ns_phost(sa)
	struct sockaddr *sa;
d958 1
a958 2
ipx_print(sa)
	struct sockaddr *sa;
d1003 1
a1003 2
ipx_phost(sa)
	struct sockaddr *sa;
d1021 1
a1021 2
encap_print(rt)
	struct rtentry *rt;
a1027 1
	char ip6addr[64];
d1118 1
a1118 2
upHex(p0)
	char *p0;
@


1.48
log
@Don't print garbage when getnameinfo fails. henning@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.47 2002/07/25 03:58:56 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.47 2002/07/25 03:58:56 deraadt Exp $";
d133 1
d324 17
d360 4
d369 12
a380 1
		p_sockaddr(kgetsa((struct sockaddr *)rmask.rm_mask), 0, 0, -1);
@


1.47
log
@handle < 0 and such better
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.46 2002/05/27 01:50:36 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.46 2002/05/27 01:50:36 deraadt Exp $";
d1061 4
a1064 2
		getnameinfo(&ipo.ipo_dst.sa, ipo.ipo_dst.sa.sa_len,
		    hostn, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);
@


1.46
log
@a night of cleanup, so i can read this easier
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.45 2002/02/16 21:27:50 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.45 2002/02/16 21:27:50 millert Exp $";
d510 1
a510 1
				if (n == -1)	/* What else to do ? */
d538 2
a539 2
		n = snprintf(cp, cplim - cp, "(%d)", sa->sa_family);
		if (n >= cplim - cp)
d544 2
a545 3
			n = snprintf(cp, workbuf + sizeof (workbuf) - cp,
			    " %02x", *s++);
			if (n >= workbuf + sizeof (workbuf) - cp)
d550 1
a550 1
				n = snprintf(cp,
d552 2
a553 2
				    "%02x", *s++);
				if (n >= workbuf + sizeof (workbuf) - cp)
@


1.45
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.44 2002/01/17 21:34:58 mickey Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.44 2002/01/17 21:34:58 mickey Exp $";
d257 3
a259 3
		WID_DST(af), WID_DST(af), "Destination",
		WID_GW(af), WID_GW(af), "Gateway",
		"Flags", "Refs", "Use", "Mtu", "Interface");
d346 1
a346 1
			rm, -1 - rmask.rm_b, rmask.rm_refs ? nbuf : " ");
d444 3
a446 3
		      ((flags & RTF_HOST) || mask == NULL ?
			routename(sin->sin_addr.s_addr) :
			netname(sin->sin_addr.s_addr, msin->sin_addr.s_addr));
d464 4
a467 3
		    /* XXX: override is ok? */
		    sa6->sin6_scope_id = (u_int32_t)ntohs(*(u_short *)&in6->s6_addr[2]);
		    *(u_short *)&in6->s6_addr[2] = 0;
a469 1

d474 1
a474 1
				&((struct sockaddr_in6 *)mask)->sin6_addr);
d511 1
a511 1
				  continue;
d596 1
a596 1
	
d612 1
a612 1
	
d633 7
a639 7
		       "sendpipe %10ld%c\n",
			rt->rt_rmx.rmx_expire,
			(rt->rt_rmx.rmx_locks & RTV_EXPIRE) ? 'L' : ' ',
			rt->rt_rmx.rmx_recvpipe,
			(rt->rt_rmx.rmx_locks & RTV_RPIPE) ? 'L' : ' ',
			rt->rt_rmx.rmx_sendpipe,
			(rt->rt_rmx.rmx_locks & RTV_SPIPE) ? 'L' : ' ');
d641 8
a648 8
		       "rttvar   %10ld%c\n",
			rt->rt_rmx.rmx_ssthresh,
			(rt->rt_rmx.rmx_locks & RTV_SSTHRESH) ? 'L' : ' ',
			rt->rt_rmx.rmx_rtt,
			(rt->rt_rmx.rmx_locks & RTV_RTT) ? 'L' : ' ',
			rt->rt_rmx.rmx_rttvar,
			(rt->rt_rmx.rmx_locks & RTV_RTTVAR) ? 'L' : ' ');
	}	
d665 1
a665 1
			(void) strcpy(domain, cp + 1);
d667 1
a667 1
			domain[0] = 0;
d672 1
a672 1
			AF_INET);
d681 1
a681 2
		strncpy(line, cp, sizeof(line) - 1);
		line[sizeof(line) - 1] = '\0';
d712 1
a712 2
		strncpy(line, cp, sizeof(line) - 1);
		line[sizeof(line) - 1] = '\0';
d723 1
a723 1
			C(in >> 16), C(in >> 8), C(in), mbits);
d748 1
a748 1
	
d837 2
a838 2
			line, sizeof(line), NULL, 0, niflag) != 0)
		strcpy(line, "");
d859 1
a859 1
		rtstat.rts_badredirect, plural(rtstat.rts_badredirect));
d861 1
a861 1
		rtstat.rts_dynamic, plural(rtstat.rts_dynamic));
d863 1
a863 1
		rtstat.rts_newgateway, plural(rtstat.rts_newgateway));
d865 1
a865 1
		rtstat.rts_unreach, plural(rtstat.rts_unreach));
d867 1
a867 1
		rtstat.rts_wildcard, plural(rtstat.rts_wildcard));
d906 1
a906 1
			q[0], q[1], q[2], q[3], q[4], q[5]);
d936 2
a937 1
	if (strncmp("0H.", p, 3) == 0) p += 3;
d1004 2
a1005 1
	if (strncmp("0H.", p, 3) == 0) p += 3;
d1025 6
a1030 9
	if (sen1.sen_type == SENT_IP4)
	{
	    printf("%-18s %-5u ", netname(sen1.sen_ip_src.s_addr,
					  sen2.sen_ip_src.s_addr),
		   ntohs(sen1.sen_sport));

	    printf("%-18s %-5u %-5u ", netname(sen1.sen_ip_dst.s_addr,
					       sen2.sen_ip_dst.s_addr),
		   ntohs(sen1.sen_dport), sen1.sen_proto);
d1034 17
a1050 18
	if (sen1.sen_type == SENT_IP6)
	{
	    bzero(&s61, sizeof(s61));
	    bzero(&s62, sizeof(s62));
	    s61.sin6_family = s62.sin6_family = AF_INET6;
	    s61.sin6_len = s62.sin6_len = sizeof(s61);
	    bcopy(&sen1.sen_ip6_src, &s61.sin6_addr, sizeof(struct in6_addr));
	    bcopy(&sen2.sen_ip6_src, &s62.sin6_addr, sizeof(struct in6_addr));

	    printf("%-42s %-5u ", netname6(&s61, &s62.sin6_addr),
		   ntohs(sen1.sen_ip6_sport));

	    bzero(&s61, sizeof(s61));
	    bzero(&s62, sizeof(s62));
	    s61.sin6_family = s62.sin6_family = AF_INET6;
	    s61.sin6_len = s62.sin6_len = sizeof(s61);
	    bcopy(&sen1.sen_ip6_dst, &s61.sin6_addr, sizeof(struct in6_addr));
	    bcopy(&sen2.sen_ip6_dst, &s62.sin6_addr, sizeof(struct in6_addr));
d1052 2
a1053 2
	    printf("%-42s %-5u %-5u ", netname6(&s61, &s62.sin6_addr),
		   ntohs(sen1.sen_ip6_dport), sen1.sen_ip6_proto);
d1057 2
a1058 5
	if (sen3.sen_type == SENT_IPSP)
	{
	    char hostn[NI_MAXHOST];

	    kget(sen3.sen_ipsp, ipo);
d1060 1
a1060 3
	    getnameinfo(&ipo.ipo_dst.sa, ipo.ipo_dst.sa.sa_len,
			hostn, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);
	    printf("%s", hostn);
d1062 4
a1065 1
	    printf("/%-u", ipo.ipo_sproto);
d1067 1
a1067 2
	    switch (ipo.ipo_type)
	    {
d1069 2
a1070 3
		    printf("/require");
		    break;

d1072 2
a1073 3
		    printf("/acquire");
		    break;

d1075 2
a1076 3
		    printf("/use");
		    break;

d1078 2
a1079 3
		    printf("/dontacq");
		    break;

d1081 2
a1082 3
		    printf("/permit");
		    break;

d1084 2
a1085 3
		    printf("/deny");
		    break;

d1087 3
a1089 2
		    printf("/<unknown type!>");
	    }
d1091 12
a1102 13
	    if ((ipo.ipo_addr.sen_type == SENT_IP4 &&
		 ipo.ipo_addr.sen_direction == IPSP_DIRECTION_IN) ||
		(ipo.ipo_addr.sen_type == SENT_IP6 &&
		 ipo.ipo_addr.sen_ip6_direction == IPSP_DIRECTION_IN))
	      printf("/in\n");
	    else
	      if ((ipo.ipo_addr.sen_type == SENT_IP4 &&
		   ipo.ipo_addr.sen_direction == IPSP_DIRECTION_OUT) ||
		  (ipo.ipo_addr.sen_type == SENT_IP6 &&
		   ipo.ipo_addr.sen_ip6_direction == IPSP_DIRECTION_OUT))
		printf("/out\n");
	      else
		printf("/<unknown>\n");
a1110 1
	for (; *p; p++) switch (*p) {
d1112 10
a1121 2
	case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
		*p += ('A' - 'a');
@


1.44
log
@evil, annoying spaces and tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.43 2001/11/19 19:02:15 mpech Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.43 2001/11/19 19:02:15 mpech Exp $";
d130 9
a138 9
static struct sockaddr *kgetsa __P((struct sockaddr *));
static void p_tree __P((struct radix_node *));
static void p_rtnode __P(());
static void ntreestuff __P(());
static void np_rtentry __P((struct rt_msghdr *));
static void p_sockaddr __P((struct sockaddr *, struct sockaddr *, int, int));
static void p_flags __P((int, char *));
static void p_rtentry __P((struct rtentry *));
static void encap_print __P((struct rtentry *));
@


1.43
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.42 2001/10/09 09:21:10 brian Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.42 2001/10/09 09:21:10 brian Exp $";
d200 1
a200 1
#endif 
d271 1
a271 1
	    "Source", "Port", "Destination", 
d377 1
a377 1
        if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0) {
d479 1
a479 1
#endif 
d488 1
a488 1
		
d631 2
a632 2
 	if (vflag) {
 		printf("\texpire   %10lu%c  recvpipe %10ld%c  "
d634 7
a640 7
 			rt->rt_rmx.rmx_expire, 
 			(rt->rt_rmx.rmx_locks & RTV_EXPIRE) ? 'L' : ' ',
 			rt->rt_rmx.rmx_recvpipe,
 			(rt->rt_rmx.rmx_locks & RTV_RPIPE) ? 'L' : ' ',
 			rt->rt_rmx.rmx_sendpipe,
 			(rt->rt_rmx.rmx_locks & RTV_SPIPE) ? 'L' : ' ');
 		printf("\tssthresh %10lu%c  rtt      %10ld%c  "
d642 5
a646 5
 			rt->rt_rmx.rmx_ssthresh, 
 			(rt->rt_rmx.rmx_locks & RTV_SSTHRESH) ? 'L' : ' ',
 			rt->rt_rmx.rmx_rtt, 
 			(rt->rt_rmx.rmx_locks & RTV_RTT) ? 'L' : ' ',
 			rt->rt_rmx.rmx_rttvar, 
d648 1
a648 1
 	}	
d1014 1
a1014 1
        struct ipsec_policy ipo;
d1025 1
a1025 1
        if (sen1.sen_type == SENT_IP4)
d1027 3
a1029 3
	    printf("%-18s %-5u ", netname(sen1.sen_ip_src.s_addr, 
				          sen2.sen_ip_src.s_addr),
	           ntohs(sen1.sen_sport));
d1031 1
a1031 1
	    printf("%-18s %-5u %-5u ", netname(sen1.sen_ip_dst.s_addr, 
d1033 1
a1033 1
	           ntohs(sen1.sen_dport), sen1.sen_proto);
d1057 1
a1057 1
	           ntohs(sen1.sen_ip6_dport), sen1.sen_ip6_proto);
d1062 2
a1063 2
        {
            char hostn[NI_MAXHOST];
d1067 2
a1068 2
            getnameinfo(&ipo.ipo_dst.sa, ipo.ipo_dst.sa.sa_len,
                        hostn, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);
d1071 27
a1097 1
            printf("/%-u", ipo.ipo_sproto);
d1099 18
a1116 44
            switch (ipo.ipo_type)
            {
                case IPSP_IPSEC_REQUIRE:
                    printf("/require");
                    break;

                case IPSP_IPSEC_ACQUIRE:
                    printf("/acquire");
                    break;

                case IPSP_IPSEC_USE:
                    printf("/use");
                    break;

                case IPSP_IPSEC_DONTACQ:
                    printf("/dontacq");
                    break;

                case IPSP_PERMIT:
                    printf("/permit");
                    break;

                case IPSP_DENY:
                    printf("/deny");
                    break;

                default:
                    printf("/<unknown type!>");
            }

            if ((ipo.ipo_addr.sen_type == SENT_IP4 &&
                 ipo.ipo_addr.sen_direction == IPSP_DIRECTION_IN) ||
                (ipo.ipo_addr.sen_type == SENT_IP6 &&
                 ipo.ipo_addr.sen_ip6_direction == IPSP_DIRECTION_IN))
              printf("/in\n");
            else
              if ((ipo.ipo_addr.sen_type == SENT_IP4 &&
                   ipo.ipo_addr.sen_direction == IPSP_DIRECTION_OUT) ||
                  (ipo.ipo_addr.sen_type == SENT_IP6 &&
                   ipo.ipo_addr.sen_ip6_direction == IPSP_DIRECTION_OUT))
                printf("/out\n");
              else
                printf("/<unknown>\n");
        }
@


1.42
log
@Don't assume that the RTF_HOST flag implies that a netmask is available.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.41 2001/08/18 22:14:03 brian Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.41 2001/08/18 22:14:03 brian Exp $";
d277 1
a277 1
	register struct sockaddr *dst;
d361 1
a361 1
	register struct rt_msghdr *rtm;
d390 1
a390 1
	register struct rt_msghdr *rtm;
d392 1
a392 1
	register struct sockaddr *sa = (struct sockaddr *)(rtm + 1);
d434 1
a434 1
	register char *cp = workbuf;
d440 2
a441 2
		register struct sockaddr_in *sin = (struct sockaddr_in *)sa;
		register struct sockaddr_in *msin = (struct sockaddr_in *)mask;
d491 1
a491 1
		register struct sockaddr_dl *sdl = (struct sockaddr_dl *)sa;
d500 2
a501 2
			register int i;
			register u_char *lla = (u_char *)sdl->sdl_data +
d534 1
a534 1
		register u_char *s = (u_char *)sa->sa_data, *slim;
d575 1
a575 1
	register int f;
d579 1
a579 1
	register struct bits *p = bits;
d590 1
a590 1
	register struct rtentry *rt;
d655 1
a655 1
	register char *cp;
d877 1
a877 1
	register struct sockaddr *sa;
d879 1
a879 1
	register struct sockaddr_ns *sns = (struct sockaddr_ns*)sa;
d885 2
a886 1
	register char *p; register u_char *q;
d928 1
a928 1
	register struct sockaddr_ns *sns = (struct sockaddr_ns *)sa;
d947 1
a947 1
	register struct sockaddr *sa;
d949 1
a949 1
	register struct sockaddr_ipx *sipx = (struct sockaddr_ipx*)sa;
d955 1
a955 1
	register char *q;
d995 1
a995 1
	register struct sockaddr_ipx *sipx = (struct sockaddr_ipx *)sa;
d1011 1
a1011 1
	register struct rtentry *rt;
d1123 1
a1123 1
	register char *p = p0;
@


1.41
log
@Handle snprintf returning -1
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.40 2001/06/25 00:41:39 niklas Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.40 2001/06/25 00:41:39 niklas Exp $";
d444 1
a444 1
		      ((flags & RTF_HOST) ?
@


1.40
log
@Show a "3" in -r output if RTF_PROTO3 is set; ok itojun@@ and millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.39 2000/12/11 17:33:07 provos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.39 2000/12/11 17:33:07 provos Exp $";
d509 3
a514 1
				cplim = ":";
d541 2
a542 1
		cp += n;
d548 2
a549 1
			cp += n;
d556 2
a557 1
				cp += n;
@


1.39
log
@show when pmtu is disabled on routes, more information when verbose,
from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.38 2000/09/19 03:18:46 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.38 2000/09/19 03:18:46 angelos Exp $";
d113 1
@


1.38
log
@Display SPD entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.37 2000/05/18 01:32:12 itojun Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.37 2000/05/18 01:32:12 itojun Exp $";
d615 1
d625 18
@


1.37
log
@check getnameinfo error proprely.  this can be visited on printing
radix_mask on netstat -rnAv (actually, I think it's a bad idea to
use p_sockaddr for printing mask portion in radix_mask, since address
family is not properly filled)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.36 2000/05/18 01:20:48 itojun Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.36 2000/05/18 01:20:48 itojun Exp $";
d271 1
a271 1
	    "Port", "Proto", "SA(Address/SPI/Proto)");
d988 2
d1036 4
a1039 2
	  printf("%s/%08x/%-u\n", inet_ntoa(sen3.sen_ipsp_dst),
	         ntohl(sen3.sen_ipsp_spi), sen3.sen_ipsp_sproto);
d1041 50
a1090 9
#ifdef INET6
	if (sen3.sen_type == SENT_IPSP6)
	{
	    inet_ntop(AF_INET6, &sen3.sen_ipsp6_dst,
		      ip6addr, sizeof(ip6addr));
	    printf("%s/%08x/%-u\n", ip6addr, ntohl(sen3.sen_ipsp6_spi),
		   sen3.sen_ipsp6_sproto);
	}
#endif /* INET6 */
@


1.36
log
@allow mask == NULL in netname6.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.35 2000/02/05 18:46:50 itojun Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.35 2000/02/05 18:46:50 itojun Exp $";
d722 1
d794 5
a798 2
	getnameinfo((struct sockaddr *)&sin6, sin6.sin6_len, hbuf, sizeof(hbuf),
		    NULL, 0, flag);
@


1.35
log
@fix -in printing on IPv6 (network portion was not masked properly).
enable scopeid for -in.
don't truncate output on -inv.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.34 2000/01/14 19:59:18 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.34 2000/01/14 19:59:18 deraadt Exp $";
d436 1
a436 1
	switch(sa->sa_family) {
d728 48
a775 6
	for (p = (u_char *)mask; p < lim; p++) {
		if (final && *p) {
			illegal++;
			sin6.sin6_addr.s6_addr[i++] = 0x00;
			continue;
		}
d777 4
a780 39
		switch (*p & 0xff) {
		case 0xff:
			masklen += 8;
			break;
		case 0xfe:
			masklen += 7;
			final++;
			break;
		case 0xfc:
			masklen += 6;
			final++;
			break;
		case 0xf8:
			masklen += 5;
			final++;
			break;
		case 0xf0:
			masklen += 4;
			final++;
			break;
		case 0xe0:
			masklen += 3;
			final++;
			break;
		case 0xc0:
			masklen += 2;
			final++;
			break;
		case 0x80:
			masklen += 1;
			final++;
			break;
		case 0x00:
			final++;
			break;
		default:
			final++;
			illegal++;
			break;
d782 2
a783 6

		if (!illegal)
			sin6.sin6_addr.s6_addr[i++] &= *p;
		else
			sin6.sin6_addr.s6_addr[i++] = 0x00;
	}
@


1.34
log
@show blackhole flag; ura@@hiru.aoba.yokohama.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.33 2000/01/09 22:57:37 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.33 2000/01/09 22:57:37 angelos Exp $";
d711 1
a711 1
	struct in6_addr net6;
d723 1
a723 3
	net6 = sa6->sin6_addr;
	for (i = 0; i < sizeof(net6); i++)
		net6.s6_addr[i] &= mask->s6_addr[i];
d726 2
a727 1
	lim = (u_char *)mask + 16;
d731 1
d775 5
d782 1
a782 1
	if (masklen == 0 && IN6_IS_ADDR_UNSPECIFIED(&sa6->sin6_addr))
d790 1
a790 1
	getnameinfo((struct sockaddr *)sa6, sa6->sin6_len, hbuf, sizeof(hbuf),
@


1.33
log
@Transport protocol ports are in network order.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.32 1999/12/20 06:24:49 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.32 1999/12/20 06:24:49 angelos Exp $";
d102 1
@


1.32
log
@Oops, forgot ports/protocol numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.31 1999/12/20 06:17:20 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.31 1999/12/20 06:17:20 angelos Exp $";
d988 1
a988 1
	           sen1.sen_sport);
d992 1
a992 1
	           sen1.sen_dport, sen1.sen_proto);
d1006 1
a1006 1
		   sen1.sen_ip6_sport);
d1016 1
a1016 1
	           sen1.sen_ip6_dport, sen1.sen_ip6_proto);
@


1.31
log
@Correctly print IPv6 addresses in IPsec flows.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.30 1999/12/08 12:30:17 itojun Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.30 1999/12/08 12:30:17 itojun Exp $";
d1006 1
a1006 1
		   sen1.sen_sport);
d1016 1
a1016 1
	           sen1.sen_dport, sen1.sen_proto);
@


1.30
log
@add IPv6 support from KAME.  cleanup type matches with printf() format.
KAME_SCOPEID should be enabled after KAME get{addr,name}info(3) merge.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.29 1999/09/22 05:10:04 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.29 1999/09/22 05:10:04 deraadt Exp $";
d975 4
d984 49
a1032 10
	printf("%-18s %-5u ", netname(sen1.sen_ip_src.s_addr, 
				      sen2.sen_ip_src.s_addr),
	       sen1.sen_sport);
	
	printf("%-18s %-5u %-5u ", netname(sen1.sen_ip_dst.s_addr, 
					   sen2.sen_ip_dst.s_addr),
	       sen1.sen_dport, sen1.sen_proto);
	
	printf("%s/%08x/%-u\n", inet_ntoa(sen3.sen_ipsp_dst),
	       ntohl(sen3.sen_ipsp_spi), sen3.sen_ipsp_sproto);
@


1.29
log
@routing interface sends aligned to long word boundaries; itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.28 1999/06/26 21:21:46 ho Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.28 1999/06/26 21:21:46 ho Exp $";
d67 2
d172 1
a172 1
					pr_rthdr();
d194 5
d228 15
a242 2
#define	WID_DST		18	/* width of destination column */
#define	WID_GW		18	/* width of gateway column */
d248 2
a249 1
pr_rthdr()
d255 2
a256 2
		WID_DST, WID_DST, "Destination",
		WID_GW, WID_GW, "Gateway",
d449 30
d586 3
a588 2
	struct sockaddr sock1, sock2;
	struct sockaddr *sa = &sock1, *mask = &sock2;
d591 2
d599 1
a599 1
	if (rt_mask(rt))
d601 3
a603 1
	else
d606 2
a607 2
	p_sockaddr(sa, mask, rt->rt_flags, WID_DST);
	p_sockaddr(kgetsa(rt->rt_gateway), 0, RTF_HOST, WID_GW);
a676 1
	in_addr_t net, subnetshift;
d682 1
a682 1
		if (np = getnetbyaddr(in, AF_INET))
d703 104
d988 1
a988 1
	printf("%s/%08x/%-lu\n", inet_ntoa(sen3.sen_ipsp_dst),
@


1.28
log
@Use a.b.c.d/nn syntax for encap route output.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.27 1999/03/15 15:59:08 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.27 1999/03/15 15:59:08 deraadt Exp $";
d84 5
d116 1
d398 1
a398 3
		if (sa->sa_len == 0)
			sa->sa_len = sizeof(in_addr_t);
		sa = (struct sockaddr *)(sa->sa_len + (char *)sa);
@


1.27
log
@print subnets containing 0 octets correctly; peter
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.26 1999/02/24 22:57:35 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.26 1999/02/24 22:57:35 angelos Exp $";
d241 2
a242 2
	printf("%-31s %-5s %-31s %-5s %-5s %-26s\n",
	    "Source address/netmask", "Port", "Destination address/netmask", 
a811 2
	u_char buffer[32];
	int i;
d817 8
a824 17
	bzero(buffer, 32);
	strncpy(buffer, inet_ntoa(sen1.sen_ip_src), 15);
	i = strlen(buffer);
	strncpy(buffer + i, "/", 1);
	i++;
	strncpy(buffer + i, inet_ntoa(sen2.sen_ip_src), 15);

	printf("%-31s %-5u ", buffer, sen1.sen_sport);

	bzero(buffer, 32);
	strncpy(buffer, inet_ntoa(sen1.sen_ip_dst), 15);
	i = strlen(buffer);
	strncpy(buffer + i, "/", 1);
	i++;
	strncpy(buffer + i, inet_ntoa(sen2.sen_ip_dst), 15);

	printf("%-31s %-5u %-5u ", buffer, sen1.sen_dport, sen1.sen_proto);
@


1.26
log
@Grok protocol/address family PF_KEY.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.25 1998/06/23 22:40:40 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.25 1998/06/23 22:40:40 millert Exp $";
d630 1
a630 1
	} else if ((in & 0xffffff) == 0)
d632 1
a632 1
	else if ((in & 0xffff) == 0)
d635 1
a635 1
	else if ((in & 0xff) == 0)
@


1.25
log
@Fix snprintf return value usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.24 1998/05/18 19:03:29 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.24 1998/05/18 19:03:29 deraadt Exp $";
d78 2
a79 1
#include <net/encap.h>
d163 1
a163 1
				if (i != AF_ENCAP)
d198 1
a198 1
	case AF_ENCAP:
d234 1
a234 1
 * Print header for AF_ENCAP entries.
d536 1
a536 1
	if (sa->sa_family == AF_ENCAP) {
@


1.24
log
@you want MAXHOSTNAMELEN, not MAXHOSTNAMELEN+1
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.23 1998/02/27 12:07:40 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.23 1998/02/27 12:07:40 deraadt Exp $";
d407 1
d448 1
a448 1
				cp += snprintf(cp,
d451 3
d478 4
a481 1
		cp += snprintf(cp, cplim - cp, "(%d)", sa->sa_family);
d483 1
a483 1
			cp += snprintf(cp, workbuf + sizeof (workbuf) - cp,
d485 5
a489 2
			if (s < slim)
				cp += snprintf(cp,
d492 4
@


1.23
log
@oflow paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.22 1998/02/26 10:13:08 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.22 1998/02/26 10:13:08 deraadt Exp $";
d555 1
a555 1
	static char line[MAXHOSTNAMELEN + 1];
d557 1
a557 1
	static char domain[MAXHOSTNAMELEN + 1];
d562 1
a562 1
		if (gethostname(domain, MAXHOSTNAMELEN) == 0 &&
d600 1
a600 1
	static char line[MAXHOSTNAMELEN + 1];
@


1.22
log
@strncpy sanitization
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.21 1998/02/26 10:06:13 peter Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.21 1998/02/26 10:06:13 peter Exp $";
d293 1
a293 1
char	nbuf[20];
d308 1
a308 1
		sprintf(nbuf, "(%d)", rnode.rn_b);
d314 1
a314 1
		sprintf(nbuf, " %d refs, ", rmask.rm_refs);
d436 2
a437 1
			(void) sprintf(workbuf, "link#%d", sdl->sdl_index);
d474 1
a474 1
		cp += sprintf(cp, "(%d)", sa->sa_family);
d585 1
a585 1
		sprintf(line, "%u.%u.%u.%u",
d616 1
a616 1
		sprintf(line, "%u/%d", C(in >> 24), mbits);
d618 2
a619 1
		sprintf(line, "%u.%u/%d", C(in >> 24) , C(in >> 16), mbits);
d621 2
a622 1
		sprintf(line, "%u.%u.%u/%d", C(in >> 24), C(in >> 16), C(in >> 8), mbits);
d624 1
a624 1
		sprintf(line, "%u.%u.%u.%u/%d", C(in >> 24),
d677 1
a677 1
			sprintf(mybuf, "*.%xH", port);
d680 1
a680 1
			sprintf(mybuf, "*.*");
d690 1
a690 1
		sprintf(chost, "%02x%02x%02x%02x%02x%02xH",
d697 1
a697 1
		sprintf(cport, ".%xH", htons(port));
d701 2
a702 1
	sprintf(mybuf,"%xH.%s%s", ntohl(net.long_e), host, cport);
d746 1
a746 1
			sprintf(mybuf, "*.%xH", port);
d749 1
a749 1
			sprintf(mybuf, "*.*");
d759 2
a760 2
		sprintf(chost, "%02x:%02x:%02x:%02x:%02x:%02x",
			q[0], q[1], q[2], q[3], q[4], q[5]);
d764 1
a764 1
		sprintf(cport, ".%xH", htons(port));
d768 2
a769 1
	sprintf(mybuf,"%xH.%s%s", ntohl(net.long_e), host, cport);
@


1.21
log
@* netstat -r [-n] now prints netmasks for network routes (in XXX/24 format).

* beginnings of a -v (verbose) option.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.20 1997/07/28 18:56:03 kstailey Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.20 1997/07/28 18:56:03 kstailey Exp $";
d578 1
a578 1
	if (cp)
d580 2
a581 1
	else {
d611 1
a611 1
	if (cp)
d613 2
a614 1
	else if ((in & 0xffffff) == 0)
@


1.20
log
@line up headers when showing route table
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.19 1997/07/25 04:29:00 mickey Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.19 1997/07/25 04:29:00 mickey Exp $";
d124 1
a124 1
static void p_sockaddr __P((struct sockaddr *, int, int));
d277 1
a277 1
			    0, 44);
d304 1
a304 1
			    0, -1);
d317 1
a317 1
		p_sockaddr(kgetsa((struct sockaddr *)rmask.rm_mask), 0, -1);
d388 1
a388 1
		p_sockaddr(sa, 0, 36);
d390 1
a390 1
		p_sockaddr(sa, rtm->rtm_flags, 16);
d394 1
a394 1
		p_sockaddr(sa, 0, 18);
d401 2
a402 2
p_sockaddr(sa, flags, width)
	struct sockaddr *sa;
d412 1
d417 2
a418 1
			netname(sin->sin_addr.s_addr, INADDR_ANY));
d515 2
a516 3
	struct sockaddr *sa;
	
	sa = kgetsa(rt_key(rt));
d518 2
d524 5
d530 2
a531 2
	p_sockaddr(sa, rt->rt_flags, WID_DST);
	p_sockaddr(kgetsa(rt->rt_gateway), RTF_HOST, WID_GW);
d601 1
d606 1
a606 28
		np = getnetbyaddr(in, AF_INET);
		if (np == NULL) {
			if (mask == INADDR_ANY) {
				if (IN_CLASSA(in)) {
					mask = IN_CLASSA_NET;
					subnetshift = 8;
				} else if (IN_CLASSB(in)) {
					mask = IN_CLASSB_NET;
					subnetshift = 8;
				} else {
					mask = IN_CLASSC_NET;
					subnetshift = 4;
				}
				/*
			 	* If there are more bits than the standard mask
			 	* would suggest, subnets must be in use.
			 	* Guess at the subnet mask, assuming reasonable
			 	* width subnet fields.
			 	*/
				while (in &~ mask)
					mask = (int)mask >> subnetshift;
			}
			net = in & mask;
			while ((mask & 1) == 0)
				mask >>= 1, net >>= 1;
			np = getnetbyaddr(net, AF_INET);
		}
		if (np)
d609 1
d613 1
a613 1
		sprintf(line, "%u", C(in >> 24));
d615 1
a615 1
		sprintf(line, "%u.%u", C(in >> 24) , C(in >> 16));
d617 1
a617 1
		sprintf(line, "%u.%u.%u", C(in >> 24), C(in >> 16), C(in >> 8));
d619 2
a620 2
		sprintf(line, "%u.%u.%u.%u", C(in >> 24),
			C(in >> 16), C(in >> 8), C(in));
@


1.19
log
@make CIA fit
make interface names fit
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.18 1997/07/23 04:38:34 denny Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.18 1997/07/23 04:38:34 denny Exp $";
d226 1
a226 1
	printf("%-*.*s %-*.*s %-6.6s  %6.6s%16.16s %6.6s  %s\n",
@


1.18
log
@Add AppleTalk support. TODO: route.c does not handle netranges.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.17 1997/07/14 00:34:27 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.17 1997/07/14 00:34:27 angelos Exp $";
d214 1
a214 1
#define	WID_DST		16	/* width of destination column */
@


1.17
log
@Adjusted the spaces a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.16 1997/07/13 23:02:42 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.16 1997/07/13 23:02:42 angelos Exp $";
d63 2
d200 3
d459 6
@


1.16
log
@Show the new field in the encap sockaddrs.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.15 1997/06/29 21:46:06 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.15 1997/06/29 21:46:06 millert Exp $";
d235 1
a235 1
	printf("%-30s %-5s %-30s %-5s %-5s %-26s\n",
d796 1
a796 1
	u_char buffer[31];
d803 1
a803 1
	bzero(buffer, 31);
d810 1
a810 1
	printf("%-30s %-5u ", buffer, sen1.sen_sport);
d812 1
a812 1
	bzero(buffer, 31);
d819 1
a819 1
	printf("%-30s %-5u %-5u ", buffer, sen1.sen_dport, sen1.sen_proto);
@


1.15
log
@Use correct spacing on both 32bit and 64bit machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.14 1997/06/29 20:52:41 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.14 1997/06/29 20:52:41 millert Exp $";
d235 3
a237 4
	printf("%-15s %-15s %-5s %-15s %-15s %-5s %-5s %-15s %-8s %s\n",
	    "Source address", "Source mask", "Port", "Dest. address", 
	    "Dest. mask", "Port", "Proto", "Tunnel exit",
	    "SPI", "Use");
d796 2
d803 19
a821 7
	printf("%-15s ", inet_ntoa(sen1.sen_ip_src));
	printf("%-15s %-5u ", inet_ntoa(sen2.sen_ip_src), sen1.sen_sport);
	printf("%-15s ", inet_ntoa(sen1.sen_ip_dst));
	printf("%-15s %-5u %-5u ", inet_ntoa(sen2.sen_ip_dst),
	    sen1.sen_dport, sen1.sen_proto);
	printf("%-15s %08x %-lu\n", inet_ntoa(sen3.sen_ipsp_dst),
	    ntohl(sen3.sen_ipsp_spi), rt->rt_use);
@


1.14
log
@Make fields line up nicely for 64-bit addresses.  Should probably #if
some things based on sizeof(long).
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.13 1997/06/29 20:18:03 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.13 1997/06/29 20:18:03 millert Exp $";
d65 1
d220 1
a220 1
		printf("%-18.18s ","Address");
d234 1
a234 1
		printf("%-18s ", "Address");
@


1.13
log
@Mostly clean -Wall + 64bit issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.12 1997/06/29 08:45:23 provos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.12 1997/06/29 08:45:23 provos Exp $";
d219 2
a220 2
		printf("%-8.8s ","Address");
	printf("%-*.*s %-*.*s %-6.6s  %6.6s%8.8s %6.6s  %s\n",
d233 1
a233 1
		printf("%-8s ", "Address");
d260 1
a260 1
			printf("%-8.8lx ", rn);
d279 1
a279 1
			printf("%-8.8lx ", rn);
d304 2
a305 1
		printf("%6.6s %8.8lx : %8.8lx", nbuf, rnode.rn_l, rnode.rn_r);
d310 1
a310 1
		printf(" mk = %8.8lx {(%d),%s",
@


1.12
log
@leave out some fields for ipsp not any longer used in new encap
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.11 1997/06/24 03:53:01 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.11 1997/06/24 03:53:01 millert Exp $";
d57 1
d260 1
a260 1
			printf("%-8.8x ", rn);
d275 1
a275 1
		if (rn = rnode.rn_dupedkey)
d279 1
a279 1
			printf("%-8.8x ", rn);
d304 1
a304 1
		printf("%6.6s %8.8x : %8.8x", nbuf, rnode.rn_l, rnode.rn_r);
d309 1
a309 1
		printf(" mk = %8.8x {(%d),%s",
d313 1
a313 1
		if (rm = rmask.rm_mklist)
d386 1
a386 1
			sa->sa_len = sizeof(u_int32_t);
d513 1
a513 1
	printf("%6d %8d ", rt->rt_refcnt, rt->rt_use);
d515 1
a515 1
		printf("%6d ", rt->rt_rmx.rmx_mtu);
d531 1
a531 1
	u_int32_t in;
d575 1
a575 1
	u_int32_t in, mask;
d580 1
a580 1
	u_int32_t net, subnetshift;
d666 1
a666 1
	u_short port;
d734 1
a734 1
	u_short port;
d737 1
a737 1
	register char *p; register u_char *q;
d805 1
a805 1
	printf("%-15s %08x %-u\n", inet_ntoa(sen3.sen_ipsp_dst),
@


1.11
log
@64bit fixes similar to some in sbin/route/route.c
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.10 1997/06/18 01:58:32 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.10 1997/06/18 01:58:32 deraadt Exp $";
d233 1
a233 1
	printf("%-15s %-15s %-5s %-15s %-15s %-5s %-5s %-15s %-15s %-8s %-9s %s\n",
d235 2
a236 2
	    "Dest. mask", "Port", "Proto", "Tunnel entry", "Tunnel exit",
	    "SPI", "Interface", "Use");
d804 2
a805 3
	printf("%-15s ", inet_ntoa(sen3.sen_ipsp_src));
	printf("%-15s %08x enc%-6u %-u\n", inet_ntoa(sen3.sen_ipsp_dst),
	    ntohl(sen3.sen_ipsp_spi), sen3.sen_ipsp_ifn, rt->rt_use);
@


1.10
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.9 1997/06/18 01:52:27 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.9 1997/06/18 01:52:27 angelos Exp $";
d385 1
a385 1
			sa->sa_len = sizeof(long);
d579 1
a579 2
	u_int32_t net;
	int subnetshift;
d604 1
a604 1
					mask = (long)mask >> subnetshift;
@


1.9
log
@Be a bit more verbose for AF_ENCAP "routing" entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.8 1997/01/25 23:26:42 tholo Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.8 1997/01/25 23:26:42 tholo Exp $";
d159 1
a159 1
				  pr_rthdr();
d161 1
a161 1
				  pr_encaphdr();
d194 1
a194 1
	        afname = "Encap";
d231 6
a236 6
    if (Aflag)
            printf("%-8s ", "Address");
    printf("%-15s %-15s %-5s %-15s %-15s %-5s %-5s %-15s %-15s %-8s %-9s %s\n",
	   "Source address", "Source mask", "Port", "Dest. address", 
	   "Dest. mask", "Port", "Proto", "Tunnel entry", "Tunnel exit",
	   "SPI", "Interface", "Use");
d298 1
a298 1
				    0, -1);
d326 19
a344 13
        mib[0] = CTL_NET;
        mib[1] = PF_ROUTE;
        mib[2] = 0;
        mib[3] = 0;
        mib[4] = NET_RT_DUMP;
        mib[5] = 0;
        if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)
		{ perror("route-sysctl-estimate"); exit(1);}
	if ((buf = malloc(needed)) == 0)
		{ printf("out of space\n"); exit(1);}
        if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0)
		{ perror("sysctl of routing table"); exit(1);}
	lim  = buf + needed;
d383 1
a383 1
	        p_sockaddr(sa, rtm->rtm_flags, 16);
d385 1
a385 1
		      sa->sa_len = sizeof(long);
d456 1
a456 1
		slim =  sa->sa_len + (u_char *) sa;
d504 3
a506 4
	if (sa->sa_family == AF_ENCAP)
	{
	    encap_print(rt);
	    return;
d674 1
a674 1
	net.net_e  = work.x_net;
d742 1
a742 1
	net.net_e  = work.ipx_net;
d794 1
a794 1
        struct sockaddr_encap sen1, sen2, sen3;
d804 1
a804 1
	       sen1.sen_dport, sen1.sen_proto);
d807 1
a807 1
	       ntohl(sen3.sen_ipsp_spi), sen3.sen_ipsp_ifn, rt->rt_use);
@


1.8
log
@Attempt to give the entire passed address to getnetbyaddr() before starting
to try various network masks
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.7 1997/01/17 07:13:00 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.7 1997/01/17 07:13:00 millert Exp $";
d69 6
d123 1
d158 4
a161 1
				pr_rthdr();
d193 3
d225 14
d377 1
a377 1
		p_sockaddr(sa, rtm->rtm_flags, 16);
d379 1
a379 1
			sa->sa_len = sizeof(long);
d414 1
a414 1

d494 11
a504 2

	p_sockaddr(kgetsa(rt_key(rt)), rt->rt_flags, WID_DST);
d783 20
@


1.7
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.6 1996/10/25 10:50:52 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.6 1996/10/25 10:50:52 deraadt Exp $";
d544 21
a564 10
		if (mask == INADDR_ANY) {
			if (IN_CLASSA(in)) {
				mask = IN_CLASSA_NET;
				subnetshift = 8;
			} else if (IN_CLASSB(in)) {
				mask = IN_CLASSB_NET;
				subnetshift = 8;
			} else {
				mask = IN_CLASSC_NET;
				subnetshift = 4;
d566 4
a569 8
			/*
			 * If there are more bits than the standard mask
			 * would suggest, subnets must be in use.
			 * Guess at the subnet mask, assuming reasonable
			 * width subnet fields.
			 */
			while (in &~ mask)
				mask = (long)mask >> subnetshift;
a570 4
		net = in & mask;
		while ((mask & 1) == 0)
			mask >>= 1, net >>= 1;
		np = getnetbyaddr(net, AF_INET);
@


1.6
log
@fix a freak of misalignment
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.4 1996/08/06 18:35:09 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.4 1996/08/06 18:35:09 deraadt Exp $";
d500 1
a500 1
		    (cp = index(domain, '.')))
d510 1
a510 1
			if ((cp = index(hp->h_name, '.')) &&
@


1.5
log
@ipx.
@
text
@d98 2
a99 2
	struct	sockaddr u_sa;
	u_short	u_data[128];
@


1.4
log
@no oflow in case of really bizzare routing tables
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.3 1996/06/26 05:37:26 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.3 1996/06/26 05:37:26 deraadt Exp $";
d60 2
d174 3
d384 4
d611 1
d676 66
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.15 1996/05/07 02:55:06 thorpej Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: route.c,v 1.15 1996/05/07 02:55:06 thorpej Exp $";
d395 3
a397 1
				cp += sprintf(cp, "%s%x", cplim, *lla);
d418 2
a419 1
			cp += sprintf(cp, " %02x", *s++);
d421 3
a423 1
			    cp += sprintf(cp, "%02x", *s++);
@


1.2
log
@if_name/if_unit -> if_xname/if_softc
network list is a TAILQ
@
text
@d1 1
d41 1
a41 1
static char *rcsid = "$NetBSD: route.c,v 1.15 1996/05/07 02:55:06 thorpej Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: route.c,v 1.14 1995/10/03 21:42:47 thorpej Exp $	*/
d40 1
a40 1
static char *rcsid = "$NetBSD: route.c,v 1.14 1995/10/03 21:42:47 thorpej Exp $";
a451 1
	static char name[16];
a463 1
			kread((u_long)ifnet.if_name, name, 16);
d466 1
a466 1
		printf(" %.15s%d%s", name, ifnet.if_unit,
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

