head	1.19;
access;
symbols
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.10.0.8
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.9.0.12
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.8
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.6
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.4
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.7.0.22
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.20
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.18
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.14
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.16
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	W32EN7Zp77efb8wW;

1.18
date	2016.03.16.15.36.26;	author mmcc;	state Exp;
branches;
next	1.17;
commitid	P9ytq8HKajWPxZf9;

1.17
date	2016.03.16.04.33.01;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	wxFIPBrj1KAUJsFv;

1.16
date	2015.12.27.17.51.19;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	MjVV3dRto2yUI2yi;

1.15
date	2015.11.09.16.42.35;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	mkNNke62XFQvJVUG;

1.14
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	ZtGimechwgSRYqRW;

1.13
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.12;
commitid	QKrr6AuGzNx9nehL;

1.12
date	2015.11.05.22.47.33;	author tedu;	state Exp;
branches;
next	1.11;
commitid	vLFUUyhjlRQmhpMd;

1.11
date	2015.11.05.22.08.43;	author nicm;	state Exp;
branches;
next	1.10;
commitid	yKv9Ck9ZDgwWTRTo;

1.10
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.9;

1.9
date	2011.09.21.19.01.49;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.02.00.55.32;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.06.21.08.07;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.14.14.33.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.13.18.26.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.00;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.41;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.41;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.00;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.41;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.19
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Low level character input from the input file.
 * We use these special purpose routines which optimize moving
 * both forward and backward from the current read pointer.
 */

#include <sys/stat.h>

#include "less.h"

extern dev_t curr_dev;
extern ino_t curr_ino;
extern int less_is_more;

typedef off_t BLOCKNUM;

int ignore_eoi;

/*
 * Pool of buffers holding the most recently used blocks of the input file.
 * The buffer pool is kept as a doubly-linked circular list,
 * in order from most- to least-recently used.
 * The circular list is anchored by the file state "thisfile".
 */
struct bufnode {
	struct bufnode *next, *prev;
	struct bufnode *hnext, *hprev;
};

#define	LBUFSIZE	8192
struct buf {
	struct bufnode node;
	BLOCKNUM block;
	unsigned int datasize;
	unsigned char data[LBUFSIZE];
};
#define	bufnode_buf(bn)  ((struct buf *)bn)

/*
 * The file state is maintained in a filestate structure.
 * A pointer to the filestate is kept in the ifile structure.
 */
#define	BUFHASH_SIZE	64
struct filestate {
	struct bufnode buflist;
	struct bufnode hashtbl[BUFHASH_SIZE];
	int file;
	int flags;
	off_t fpos;
	int nbufs;
	BLOCKNUM block;
	unsigned int offset;
	off_t fsize;
};

#define	ch_bufhead	thisfile->buflist.next
#define	ch_buftail	thisfile->buflist.prev
#define	ch_nbufs	thisfile->nbufs
#define	ch_block	thisfile->block
#define	ch_offset	thisfile->offset
#define	ch_fpos		thisfile->fpos
#define	ch_fsize	thisfile->fsize
#define	ch_flags	thisfile->flags
#define	ch_file		thisfile->file

#define	END_OF_CHAIN	(&thisfile->buflist)
#define	END_OF_HCHAIN(h) (&thisfile->hashtbl[h])
#define	BUFHASH(blk)	((blk) & (BUFHASH_SIZE-1))

/*
 * Macros to manipulate the list of buffers in thisfile->buflist.
 */
#define	FOR_BUFS(bn) \
	for ((bn) = ch_bufhead; (bn) != END_OF_CHAIN; (bn) = (bn)->next)

#define	BUF_RM(bn) \
	(bn)->next->prev = (bn)->prev; \
	(bn)->prev->next = (bn)->next;

#define	BUF_INS_HEAD(bn) \
	(bn)->next = ch_bufhead; \
	(bn)->prev = END_OF_CHAIN; \
	ch_bufhead->prev = (bn); \
	ch_bufhead = (bn);

#define	BUF_INS_TAIL(bn) \
	(bn)->next = END_OF_CHAIN; \
	(bn)->prev = ch_buftail; \
	ch_buftail->next = (bn); \
	ch_buftail = (bn);

/*
 * Macros to manipulate the list of buffers in thisfile->hashtbl[n].
 */
#define	FOR_BUFS_IN_CHAIN(h, bn) \
	for ((bn) = thisfile->hashtbl[h].hnext; \
	    (bn) != END_OF_HCHAIN(h); (bn) = (bn)->hnext)

#define	BUF_HASH_RM(bn) \
	(bn)->hnext->hprev = (bn)->hprev; \
	(bn)->hprev->hnext = (bn)->hnext;

#define	BUF_HASH_INS(bn, h) \
	(bn)->hnext = thisfile->hashtbl[h].hnext; \
	(bn)->hprev = END_OF_HCHAIN(h); \
	thisfile->hashtbl[h].hnext->hprev = (bn); \
	thisfile->hashtbl[h].hnext = (bn);

static struct filestate *thisfile;
static int ch_ungotchar = -1;
static int maxbufs = -1;

extern int autobuf;
extern volatile sig_atomic_t sigs;
extern int secure;
extern int screen_trashed;
extern int follow_mode;
extern IFILE curr_ifile;
extern int logfile;
extern char *namelogfile;

static int ch_addbuf(void);


/*
 * Get the character pointed to by the read pointer.
 */
int
ch_get(void)
{
	struct buf *bp;
	struct bufnode *bn;
	int n;
	int slept;
	int h;
	off_t pos;
	off_t len;

	if (thisfile == NULL)
		return (EOI);

	/*
	 * Quick check for the common case where
	 * the desired char is in the head buffer.
	 */
	if (ch_bufhead != END_OF_CHAIN) {
		bp = bufnode_buf(ch_bufhead);
		if (ch_block == bp->block && ch_offset < bp->datasize)
			return (bp->data[ch_offset]);
	}

	slept = FALSE;

	/*
	 * Look for a buffer holding the desired block.
	 */
	h = BUFHASH(ch_block);
	FOR_BUFS_IN_CHAIN(h, bn) {
		bp = bufnode_buf(bn);
		if (bp->block == ch_block) {
			if (ch_offset >= bp->datasize)
				/*
				 * Need more data in this buffer.
				 */
				break;
			goto found;
		}
	}
	if (bn == END_OF_HCHAIN(h)) {
		/*
		 * Block is not in a buffer.
		 * Take the least recently used buffer
		 * and read the desired block into it.
		 * If the LRU buffer has data in it,
		 * then maybe allocate a new buffer.
		 */
		if (ch_buftail == END_OF_CHAIN ||
		    bufnode_buf(ch_buftail)->block != -1) {
			/*
			 * There is no empty buffer to use.
			 * Allocate a new buffer if:
			 * 1. We can't seek on this file and -b is not in
			 *    effect; or
			 * 2. We haven't allocated the max buffers for this
			 *    file yet.
			 */
			if ((autobuf && !(ch_flags & CH_CANSEEK)) ||
			    (maxbufs < 0 || ch_nbufs < maxbufs))
				if (ch_addbuf())
					/*
					 * Allocation failed: turn off autobuf.
					 */
					autobuf = OPT_OFF;
		}
		bn = ch_buftail;
		bp = bufnode_buf(bn);
		BUF_HASH_RM(bn); /* Remove from old hash chain. */
		bp->block = ch_block;
		bp->datasize = 0;
		BUF_HASH_INS(bn, h); /* Insert into new hash chain. */
	}

read_more:
	pos = (ch_block * LBUFSIZE) + bp->datasize;
	if ((len = ch_length()) != -1 && pos >= len)
		/*
		 * At end of file.
		 */
		return (EOI);

	if (pos != ch_fpos) {
		/*
		 * Not at the correct position: must seek.
		 * If input is a pipe, we're in trouble (can't seek on a pipe).
		 * Some data has been lost: just return "?".
		 */
		if (!(ch_flags & CH_CANSEEK))
			return ('?');
		if (lseek(ch_file, (off_t)pos, SEEK_SET) == (off_t)-1) {
			error("seek error", NULL);
			clear_eol();
			return (EOI);
		}
		ch_fpos = pos;
	}

	/*
	 * Read the block.
	 * If we read less than a full block, that's ok.
	 * We use partial block and pick up the rest next time.
	 */
	if (ch_ungotchar != -1) {
		bp->data[bp->datasize] = (unsigned char)ch_ungotchar;
		n = 1;
		ch_ungotchar = -1;
	} else {
		n = iread(ch_file, &bp->data[bp->datasize],
		    (unsigned int)(LBUFSIZE - bp->datasize));
	}

	if (n == READ_INTR)
		return (EOI);
	if (n < 0) {
		error("read error", NULL);
		clear_eol();
		n = 0;
	}

	/*
	 * If we have a log file, write the new data to it.
	 */
	if (!secure && logfile >= 0 && n > 0)
		(void) write(logfile, (char *)&bp->data[bp->datasize], n);

	ch_fpos += n;
	bp->datasize += n;

	/*
	 * If we have read to end of file, set ch_fsize to indicate
	 * the position of the end of file.
	 */
	if (n == 0) {
		ch_fsize = pos;
		if (ignore_eoi) {
			/*
			 * We are ignoring EOF.
			 * Wait a while, then try again.
			 */
			if (!slept) {
				PARG parg;
				parg.p_string = wait_message();
				ierror("%s", &parg);
			}
			sleep(1);
			slept = TRUE;

			if (follow_mode == FOLLOW_NAME) {
				/*
				 * See whether the file's i-number has changed.
				 * If so, force the file to be closed and
				 * reopened.
				 */
				struct stat st;
				int r = stat(get_filename(curr_ifile), &st);
				if (r == 0 && (st.st_ino != curr_ino ||
				    st.st_dev != curr_dev)) {
					/*
					 * screen_trashed=2 causes
					 * make_display to reopen the file.
					 */
					screen_trashed = 2;
					return (EOI);
				}
			}
		}
		if (sigs)
			return (EOI);
	}

found:
	if (ch_bufhead != bn) {
		/*
		 * Move the buffer to the head of the buffer chain.
		 * This orders the buffer chain, most- to least-recently used.
		 */
		BUF_RM(bn);
		BUF_INS_HEAD(bn);

		/*
		 * Move to head of hash chain too.
		 */
		BUF_HASH_RM(bn);
		BUF_HASH_INS(bn, h);
	}

	if (ch_offset >= bp->datasize)
		/*
		 * After all that, we still don't have enough data.
		 * Go back and try again.
		 */
		goto read_more;

	return (bp->data[ch_offset]);
}

/*
 * ch_ungetchar is a rather kludgy and limited way to push
 * a single char onto an input file descriptor.
 */
void
ch_ungetchar(int c)
{
	if (c != -1 && ch_ungotchar != -1)
		error("ch_ungetchar overrun", NULL);
	ch_ungotchar = c;
}

/*
 * Close the logfile.
 * If we haven't read all of standard input into it, do that now.
 */
void
end_logfile(void)
{
	static int tried = FALSE;

	if (logfile < 0)
		return;
	if (!tried && ch_fsize == -1) {
		tried = TRUE;
		ierror("Finishing logfile", NULL);
		while (ch_forw_get() != EOI)
			if (ABORT_SIGS())
				break;
	}
	close(logfile);
	logfile = -1;
	namelogfile = NULL;
}

/*
 * Start a log file AFTER less has already been running.
 * Invoked from the - command; see toggle_option().
 * Write all the existing buffered data to the log file.
 */
void
sync_logfile(void)
{
	struct buf *bp;
	struct bufnode *bn;
	int warned = FALSE;
	BLOCKNUM block;
	BLOCKNUM nblocks;

	nblocks = (ch_fpos + LBUFSIZE - 1) / LBUFSIZE;
	for (block = 0; block < nblocks; block++) {
		int wrote = FALSE;
		FOR_BUFS(bn) {
			bp = bufnode_buf(bn);
			if (bp->block == block) {
				(void) write(logfile, (char *)bp->data,
				    bp->datasize);
				wrote = TRUE;
				break;
			}
		}
		if (!wrote && !warned) {
			error("Warning: log file is incomplete", NULL);
			warned = TRUE;
		}
	}
}

/*
 * Determine if a specific block is currently in one of the buffers.
 */
static int
buffered(BLOCKNUM block)
{
	struct buf *bp;
	struct bufnode *bn;
	int h;

	h = BUFHASH(block);
	FOR_BUFS_IN_CHAIN(h, bn) {
		bp = bufnode_buf(bn);
		if (bp->block == block)
			return (TRUE);
	}
	return (FALSE);
}

/*
 * Seek to a specified position in the file.
 * Return 0 if successful, non-zero if can't seek there.
 */
int
ch_seek(off_t pos)
{
	BLOCKNUM new_block;
	off_t len;

	if (thisfile == NULL)
		return (0);

	len = ch_length();
	if (pos < ch_zero() || (len != -1 && pos > len))
		return (1);

	new_block = pos / LBUFSIZE;
	if (!(ch_flags & CH_CANSEEK) && pos != ch_fpos &&
	    !buffered(new_block)) {
		if (ch_fpos > pos)
			return (1);
		while (ch_fpos < pos) {
			if (ch_forw_get() == EOI)
				return (1);
			if (ABORT_SIGS())
				return (1);
		}
		return (0);
	}
	/*
	 * Set read pointer.
	 */
	ch_block = new_block;
	ch_offset = pos % LBUFSIZE;
	return (0);
}

/*
 * Seek to the end of the file.
 */
int
ch_end_seek(void)
{
	off_t len;

	if (thisfile == NULL)
		return (0);

	if (ch_flags & CH_CANSEEK)
		ch_fsize = filesize(ch_file);

	len = ch_length();
	if (len != -1)
		return (ch_seek(len));

	/*
	 * Do it the slow way: read till end of data.
	 */
	while (ch_forw_get() != EOI)
		if (ABORT_SIGS())
			return (1);
	return (0);
}

/*
 * Seek to the beginning of the file, or as close to it as we can get.
 * We may not be able to seek there if input is a pipe and the
 * beginning of the pipe is no longer buffered.
 */
int
ch_beg_seek(void)
{
	struct bufnode *bn;
	struct bufnode *firstbn;

	/*
	 * Try a plain ch_seek first.
	 */
	if (ch_seek(ch_zero()) == 0)
		return (0);

	/*
	 * Can't get to position 0.
	 * Look thru the buffers for the one closest to position 0.
	 */
	firstbn = ch_bufhead;
	if (firstbn == END_OF_CHAIN)
		return (1);
	FOR_BUFS(bn) {
		if (bufnode_buf(bn)->block < bufnode_buf(firstbn)->block)
			firstbn = bn;
	}
	ch_block = bufnode_buf(firstbn)->block;
	ch_offset = 0;
	return (0);
}

/*
 * Return the length of the file, if known.
 */
off_t
ch_length(void)
{
	if (thisfile == NULL)
		return (-1);
	if (ignore_eoi)
		return (-1);
	if (ch_flags & CH_NODATA)
		return (0);
	return (ch_fsize);
}

/*
 * Return the current position in the file.
 */
off_t
ch_tell(void)
{
	if (thisfile == NULL)
		return (-1);
	return ((ch_block * LBUFSIZE) + ch_offset);
}

/*
 * Get the current char and post-increment the read pointer.
 */
int
ch_forw_get(void)
{
	int c;

	if (thisfile == NULL)
		return (EOI);
	c = ch_get();
	if (c == EOI)
		return (EOI);
	if (ch_offset < LBUFSIZE-1) {
		ch_offset++;
	} else {
		ch_block ++;
		ch_offset = 0;
	}
	return (c);
}

/*
 * Pre-decrement the read pointer and get the new current char.
 */
int
ch_back_get(void)
{
	if (thisfile == NULL)
		return (EOI);
	if (ch_offset > 0) {
		ch_offset --;
	} else {
		if (ch_block <= 0)
			return (EOI);
		if (!(ch_flags & CH_CANSEEK) && !buffered(ch_block-1))
			return (EOI);
		ch_block--;
		ch_offset = LBUFSIZE-1;
	}
	return (ch_get());
}

/*
 * Set max amount of buffer space.
 * bufspace is in units of 1024 bytes.  -1 mean no limit.
 */
void
ch_setbufspace(int bufspace)
{
	if (bufspace < 0) {
		maxbufs = -1;
	} else {
		maxbufs = ((bufspace * 1024) + LBUFSIZE-1) / LBUFSIZE;
		if (maxbufs < 1)
			maxbufs = 1;
	}
}

/*
 * Flush (discard) any saved file state, including buffer contents.
 */
void
ch_flush(void)
{
	struct bufnode *bn;

	if (thisfile == NULL)
		return;

	if (!(ch_flags & CH_CANSEEK)) {
		/*
		 * If input is a pipe, we don't flush buffer contents,
		 * since the contents can't be recovered.
		 */
		ch_fsize = -1;
		return;
	}

	/*
	 * Initialize all the buffers.
	 */
	FOR_BUFS(bn) {
		bufnode_buf(bn)->block = -1;
	}

	/*
	 * Figure out the size of the file, if we can.
	 */
	ch_fsize = filesize(ch_file);

	/*
	 * Seek to a known position: the beginning of the file.
	 */
	ch_fpos = 0;
	ch_block = 0; /* ch_fpos / LBUFSIZE; */
	ch_offset = 0; /* ch_fpos % LBUFSIZE; */

#if 1
	/*
	 * This is a kludge to workaround a Linux kernel bug: files in
	 * /proc have a size of 0 according to fstat() but have readable
	 * data.  They are sometimes, but not always, seekable.
	 * Force them to be non-seekable here.
	 */
	if (ch_fsize == 0) {
		ch_fsize = -1;
		ch_flags &= ~CH_CANSEEK;
	}
#endif

	if (lseek(ch_file, (off_t)0, SEEK_SET) == (off_t)-1) {
		/*
		 * Warning only; even if the seek fails for some reason,
		 * there's a good chance we're at the beginning anyway.
		 * {{ I think this is bogus reasoning. }}
		 */
		error("seek error to 0", NULL);
	}
}

/*
 * Allocate a new buffer.
 * The buffer is added to the tail of the buffer chain.
 */
static int
ch_addbuf(void)
{
	struct buf *bp;
	struct bufnode *bn;

	/*
	 * Allocate and initialize a new buffer and link it
	 * onto the tail of the buffer list.
	 */
	bp = calloc(1, sizeof (struct buf));
	if (bp == NULL)
		return (1);
	ch_nbufs++;
	bp->block = -1;
	bn = &bp->node;

	BUF_INS_TAIL(bn);
	BUF_HASH_INS(bn, 0);
	return (0);
}

/*
 *
 */
static void
init_hashtbl(void)
{
	int h;

	for (h = 0; h < BUFHASH_SIZE; h++) {
		thisfile->hashtbl[h].hnext = END_OF_HCHAIN(h);
		thisfile->hashtbl[h].hprev = END_OF_HCHAIN(h);
	}
}

/*
 * Delete all buffers for this file.
 */
static void
ch_delbufs(void)
{
	struct bufnode *bn;

	while (ch_bufhead != END_OF_CHAIN) {
		bn = ch_bufhead;
		BUF_RM(bn);
		free(bufnode_buf(bn));
	}
	ch_nbufs = 0;
	init_hashtbl();
}

/*
 * Is it possible to seek on a file descriptor?
 */
int
seekable(int f)
{
	return (lseek(f, (off_t)1, SEEK_SET) != (off_t)-1);
}

/*
 * Force EOF to be at the current read position.
 * This is used after an ignore_eof read, during which the EOF may change.
 */
void
ch_set_eof(void)
{
	ch_fsize = ch_fpos;
}


/*
 * Initialize file state for a new file.
 */
void
ch_init(int f, int flags)
{
	/*
	 * See if we already have a filestate for this file.
	 */
	thisfile = get_filestate(curr_ifile);
	if (thisfile == NULL) {
		/*
		 * Allocate and initialize a new filestate.
		 */
		thisfile = calloc(1, sizeof (struct filestate));
		thisfile->buflist.next = thisfile->buflist.prev = END_OF_CHAIN;
		thisfile->nbufs = 0;
		thisfile->flags = 0;
		thisfile->fpos = 0;
		thisfile->block = 0;
		thisfile->offset = 0;
		thisfile->file = -1;
		thisfile->fsize = -1;
		ch_flags = flags;
		init_hashtbl();
		/*
		 * Try to seek; set CH_CANSEEK if it works.
		 */
		if ((flags & CH_CANSEEK) && !seekable(f))
			ch_flags &= ~CH_CANSEEK;
		set_filestate(curr_ifile, (void *) thisfile);
	}
	if (thisfile->file == -1)
		thisfile->file = f;
	ch_flush();
}

/*
 * Close a filestate.
 */
void
ch_close(void)
{
	int keepstate = FALSE;

	if (thisfile == NULL)
		return;

	if (ch_flags & (CH_CANSEEK|CH_POPENED|CH_HELPFILE)) {
		/*
		 * We can seek or re-open, so we don't need to keep buffers.
		 */
		ch_delbufs();
	} else {
		keepstate = TRUE;
	}
	if (!(ch_flags & CH_KEEPOPEN)) {
		/*
		 * We don't need to keep the file descriptor open
		 * (because we can re-open it.)
		 * But don't really close it if it was opened via popen(),
		 * because pclose() wants to close it.
		 */
		if (!(ch_flags & CH_POPENED))
			close(ch_file);
		ch_file = -1;
	} else {
		keepstate = TRUE;
	}
	if (!keepstate) {
		/*
		 * We don't even need to keep the filestate structure.
		 */
		free(thisfile);
		thisfile = NULL;
		set_filestate(curr_ifile, NULL);
	}
}

/*
 * Return ch_flags for the current file.
 */
int
ch_getflags(void)
{
	if (thisfile == NULL)
		return (0);
	return (ch_flags);
}
@


1.18
log
@style(9) includes

ok nicm@@
@
text
@d85 1
a85 1
	for ((bn) = ch_bufhead;  (bn) != END_OF_CHAIN;  (bn) = (bn)->next)
d107 1
a107 1
	for ((bn) = thisfile->hashtbl[h].hnext;  \
d387 1
a387 1
	for (block = 0;  block < nblocks;  block++) {
@


1.17
log
@Wrap a macro's args in parentheses. No binary change.

I'm discussing with deraadt@@ whether it's a good idea to convert some of
these to functions. The one changed by this commit probably isn't
eligible because it defines only a for loop's condition, but many others
in less(1) should probably be converted.

ok millert@@
@
text
@d18 2
a21 1
#include <sys/stat.h>
@


1.16
log
@Put macro arg in parentheses.

ok nicm@@
@
text
@d106 2
a107 2
	for (bn = thisfile->hashtbl[h].hnext;  \
	    bn != END_OF_HCHAIN(h);  bn = bn->hnext)
@


1.15
log
@use (off_t)-1 rather than a BAD_LSEEK wrapper
@
text
@d84 1
a84 1
	for (bn = ch_bufhead;  bn != END_OF_CHAIN;  bn = bn->next)
@


1.14
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@d229 1
a229 1
		if (lseek(ch_file, (off_t)pos, SEEK_SET) == BAD_LSEEK) {
d658 1
a658 1
	if (lseek(ch_file, (off_t)0, SEEK_SET) == BAD_LSEEK) {
d731 1
a731 1
	return (lseek(f, (off_t)1, SEEK_SET) != BAD_LSEEK);
@


1.13
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d230 1
a230 1
			error("seek error", NULL_PARG);
d254 1
a254 1
		error("read error", NULL_PARG);
d344 1
a344 1
		error("ch_ungetchar overrun", NULL_PARG);
d361 1
a361 1
		ierror("Finishing logfile", NULL_PARG);
d398 1
a398 1
			error("Warning: log file is incomplete", NULL_PARG);
d664 1
a664 1
		error("seek error to 0", NULL_PARG);
@


1.12
log
@deregister
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.11
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d412 3
a414 3
	register struct buf *bp;
	register struct bufnode *bn;
	register int h;
@


1.10
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

a20 4
#if MSDOS_COMPILER==WIN32C
#include <errno.h>
#include <windows.h>
#endif
a21 1
#if HAVE_STAT_INO
d25 1
a25 1
#endif
d27 1
a27 1
typedef POSITION BLOCKNUM;
d29 1
a29 1
public int ignore_eoi;
d49 1
a49 1
#define bufnode_buf(bn)  ((struct buf *) bn)
d61 1
a61 1
	POSITION fpos;
d65 1
a65 1
	POSITION fsize;
d80 1
a80 1
#define BUFHASH(blk)	((blk) & (BUFHASH_SIZE-1))
d88 1
a88 1
#define BUF_RM(bn) \
d92 1
a92 1
#define BUF_INS_HEAD(bn) \
d98 1
a98 1
#define BUF_INS_TAIL(bn) \
d107 1
a107 1
#define	FOR_BUFS_IN_CHAIN(h,bn) \
d109 1
a109 1
	     bn != END_OF_HCHAIN(h);  bn = bn->hnext)
d115 1
a115 1
#define	BUF_HASH_INS(bn,h) \
a130 1
#if LOGFILE
a132 1
#endif
d134 1
a134 1
static int ch_addbuf();
d140 2
a141 2
	int
ch_get()
d143 7
a149 7
	register struct buf *bp;
	register struct bufnode *bn;
	register int n;
	register int slept;
	register int h;
	POSITION pos;
	POSITION len;
d155 1
a155 1
	 * Quick check for the common case where 
d158 1
a158 2
	if (ch_bufhead != END_OF_CHAIN)
	{
d161 1
a161 1
			return bp->data[ch_offset];
d170 1
a170 2
	FOR_BUFS_IN_CHAIN(h, bn)
	{
d172 1
a172 2
		if (bp->block == ch_block)
		{
d181 1
a181 2
	if (bn == END_OF_HCHAIN(h))
	{
d183 2
a184 2
		 * Block is not in a buffer.  
		 * Take the least recently used buffer 
d186 1
a186 1
		 * If the LRU buffer has data in it, 
d189 2
a190 3
		if (ch_buftail == END_OF_CHAIN || 
			bufnode_buf(ch_buftail)->block != -1)
		{
d194 4
a197 2
			 * 1. We can't seek on this file and -b is not in effect; or
			 * 2. We haven't allocated the max buffers for this file yet.
d200 1
a200 1
				(maxbufs < 0 || ch_nbufs < maxbufs))
d215 1
a215 1
    read_more:
d217 1
a217 1
	if ((len = ch_length()) != NULL_POSITION && pos >= len)
d223 1
a223 2
	if (pos != ch_fpos)
	{
d231 2
a232 3
		if (lseek(ch_file, (off_t)pos, SEEK_SET) == BAD_LSEEK)
		{
 			error("seek error", NULL_PARG);
d235 3
a237 3
 		}
 		ch_fpos = pos;
 	}
d244 2
a245 3
	if (ch_ungotchar != -1)
	{
		bp->data[bp->datasize] = ch_ungotchar;
d248 3
a250 4
	} else
	{
		n = iread(ch_file, &bp->data[bp->datasize], 
			(unsigned int)(LBUFSIZE - bp->datasize));
d255 3
a257 9
	if (n < 0)
	{
#if MSDOS_COMPILER==WIN32C
		if (errno != EPIPE)
#endif
		{
			error("read error", NULL_PARG);
			clear_eol();
		}
a260 1
#if LOGFILE
d265 1
a265 2
		write(logfile, (char *) &bp->data[bp->datasize], n);
#endif
d274 1
a274 2
	if (n == 0)
	{
d276 1
a276 2
		if (ignore_eoi)
		{
d281 1
a281 2
			if (!slept)
			{
d286 1
a286 7
#if !MSDOS_COMPILER
	 		sleep(1);
#else
#if MSDOS_COMPILER==WIN32C
			Sleep(1000);
#endif
#endif
d289 3
a291 4
#if HAVE_STAT_INO
			if (follow_mode == FOLLOW_NAME)
			{
				/* See whether the file's i-number has changed.
d293 2
a294 1
				 * reopened. */
d298 5
a302 4
					st.st_dev != curr_dev))
				{
					/* screen_trashed=2 causes
					 * make_display to reopen the file. */
a306 1
#endif
d312 2
a313 3
    found:
	if (ch_bufhead != bn)
	{
d339 1
a339 1
 * ch_ungetchar is a rather kludgy and limited way to push 
d342 2
a343 3
	public void
ch_ungetchar(c)
	int c;
a349 1
#if LOGFILE
d354 2
a355 2
	public void
end_logfile()
d361 1
a361 2
	if (!tried && ch_fsize == NULL_POSITION)
	{
d378 2
a379 2
	public void
sync_logfile()
d381 2
a382 2
	register struct buf *bp;
	register struct bufnode *bn;
d388 1
a388 2
	for (block = 0;  block < nblocks;  block++)
	{
d390 1
a390 2
		FOR_BUFS(bn)
		{
d392 3
a394 3
			if (bp->block == block)
			{
				write(logfile, (char *) bp->data, bp->datasize);
d399 2
a400 4
		if (!wrote && !warned)
		{
			error("Warning: log file is incomplete",
				NULL_PARG);
a405 2
#endif

d409 2
a410 3
	static int
buffered(block)
	BLOCKNUM block;
d417 1
a417 2
	FOR_BUFS_IN_CHAIN(h, bn)
	{
d429 2
a430 3
	public int
ch_seek(pos)
	register POSITION pos;
d433 1
a433 1
	POSITION len;
d439 1
a439 1
	if (pos < ch_zero() || (len != NULL_POSITION && pos > len))
d443 2
a444 2
	if (!(ch_flags & CH_CANSEEK) && pos != ch_fpos && !buffered(new_block))
	{
d447 1
a447 2
		while (ch_fpos < pos)
		{
d466 2
a467 2
	public int
ch_end_seek()
d469 1
a469 1
	POSITION len;
d478 1
a478 1
	if (len != NULL_POSITION)
d495 2
a496 2
	public int
ch_beg_seek()
d498 2
a499 2
	register struct bufnode *bn;
	register struct bufnode *firstbn;
d514 1
a514 2
	FOR_BUFS(bn)
	{
d526 2
a527 2
	public POSITION
ch_length()
d530 1
a530 1
		return (NULL_POSITION);
d532 1
a532 1
		return (NULL_POSITION);
d541 2
a542 2
	public POSITION
ch_tell()
d545 2
a546 2
		return (NULL_POSITION);
	return (ch_block * LBUFSIZE) + ch_offset;
d552 2
a553 2
	public int
ch_forw_get()
d555 1
a555 1
	register int c;
d562 1
a562 1
	if (ch_offset < LBUFSIZE-1)
d564 1
a564 2
	else
	{
d574 2
a575 2
	public int
ch_back_get()
d579 1
a579 1
	if (ch_offset > 0)
d581 1
a581 2
	else
	{
d596 2
a597 3
	public void
ch_setbufspace(bufspace)
	int bufspace;
d599 1
a599 1
	if (bufspace < 0)
d601 1
a601 2
	else
	{
d611 2
a612 2
	public void
ch_flush()
d614 1
a614 1
	register struct bufnode *bn;
d619 1
a619 2
	if (!(ch_flags & CH_CANSEEK))
	{
d624 1
a624 1
		ch_fsize = NULL_POSITION;
d631 1
a631 2
	FOR_BUFS(bn)
	{
d650 1
a650 1
	 * /proc have a size of 0 according to fstat() but have readable 
d654 2
a655 3
	if (ch_fsize == 0)
	{
		ch_fsize = NULL_POSITION;
d660 1
a660 2
	if (lseek(ch_file, (off_t)0, SEEK_SET) == BAD_LSEEK)
	{
d674 2
a675 2
	static int
ch_addbuf()
d677 2
a678 2
	register struct buf *bp;
	register struct bufnode *bn;
d681 1
a681 1
	 * Allocate and initialize a new buffer and link it 
d684 1
a684 1
	bp = (struct buf *) calloc(1, sizeof(struct buf));
d699 2
a700 2
	static void
init_hashtbl()
d702 1
a702 1
	register int h;
d704 1
a704 2
	for (h = 0;  h < BUFHASH_SIZE;  h++)
	{
d713 2
a714 2
	static void
ch_delbufs()
d716 1
a716 1
	register struct bufnode *bn;
d718 1
a718 2
	while (ch_bufhead != END_OF_CHAIN)
	{
d730 3
a732 15
	public int
seekable(f)
	int f;
{
#if MSDOS_COMPILER
	extern int fd0;
	if (f == fd0 && !isatty(fd0))
	{
		/*
		 * In MS-DOS, pipes are seekable.  Check for
		 * standard input, and pretend it is not seekable.
		 */
		return (0);
	}
#endif
d740 2
a741 2
	public void
ch_set_eof()
d750 2
a751 4
	public void
ch_init(f, flags)
	int f;
	int flags;
d756 2
a757 3
	thisfile = (struct filestate *) get_filestate(curr_ifile);
	if (thisfile == NULL)
	{
d761 1
a761 2
		thisfile = (struct filestate *) 
				calloc(1, sizeof(struct filestate));
d769 1
a769 1
		thisfile->fsize = NULL_POSITION;
d787 2
a788 2
	public void
ch_close()
d795 1
a795 2
	if (ch_flags & (CH_CANSEEK|CH_POPENED|CH_HELPFILE))
	{
d800 1
a800 1
	} else
d802 2
a803 2
	if (!(ch_flags & CH_KEEPOPEN))
	{
d813 1
a813 1
	} else
d815 2
a816 2
	if (!keepstate)
	{
d822 1
a822 1
		set_filestate(curr_ifile, (void *) NULL);
d829 2
a830 2
	public int
ch_getflags()
a835 32

#if 0
	public void
ch_dump(struct filestate *fs)
{
	struct buf *bp;
	struct bufnode *bn;
	unsigned char *s;

	if (fs == NULL)
	{
		printf(" --no filestate\n");
		return;
	}
	printf(" file %d, flags %x, fpos %x, fsize %x, blk/off %x/%x\n",
		fs->file, fs->flags, fs->fpos, 
		fs->fsize, fs->block, fs->offset);
	printf(" %d bufs:\n", fs->nbufs);
	for (bn = fs->next; bn != &fs->buflist;  bn = bn->next)
	{
		bp = bufnode_buf(bn);
		printf("%x: blk %x, size %x \"",
			bp, bp->block, bp->datasize);
		for (s = bp->data;  s < bp->data + 30;  s++)
			if (*s >= ' ' && *s < 0x7F)
				printf("%c", *s);
			else
				printf(".");
		printf("\"\n");
	}
}
#endif
@


1.9
log
@Use volatile sig_atomic_t, not int, for the sigs variable.  Also
move the call to bell() out of u_interrupt() (a signal handler).
OK and with help from deraadt@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d576 2
d800 11
@


1.8
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d129 1
a129 1
extern int sigs;
@


1.7
log
@use SEEK_* for lseek()
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d24 6
d40 5
d47 1
a47 2
	struct buf *next, *prev;
	struct buf *hnext, *hprev;
d52 1
a52 6

struct buflist {
	/* -- Following members must match struct buf */
	struct buf *buf_next, *buf_prev;
	struct buf *buf_hnext, *buf_hprev;
};
d60 2
a61 2
	struct buf *buf_next, *buf_prev;
	struct buflist hashtbl[BUFHASH_SIZE];
d71 2
a72 2
#define	ch_bufhead	thisfile->buf_next
#define	ch_buftail	thisfile->buf_prev
d81 2
a82 2
#define	END_OF_CHAIN	((struct buf *)&thisfile->buf_next)
#define	END_OF_HCHAIN(h) ((struct buf *)&thisfile->hashtbl[h])
d85 38
a122 13
#define	FOR_BUFS_IN_CHAIN(h,bp) \
	for (bp = thisfile->hashtbl[h].buf_hnext;  \
	     bp != END_OF_HCHAIN(h);  bp = bp->hnext)

#define	HASH_RM(bp) \
	(bp)->hnext->hprev = (bp)->hprev; \
	(bp)->hprev->hnext = (bp)->hnext;

#define	HASH_INS(bp,h) \
	(bp)->hnext = thisfile->hashtbl[h].buf_hnext; \
	(bp)->hprev = END_OF_HCHAIN(h); \
	thisfile->hashtbl[h].buf_hnext->hprev = (bp); \
	thisfile->hashtbl[h].buf_hnext = (bp);
d131 2
d144 1
a144 7
 * ch_get() is a macro which is more efficient to call
 * than fch_get (the function), in the usual case 
 * that the block desired is at the head of the chain.
 */
#define	ch_get()   ((ch_block == ch_bufhead->block && \
		     ch_offset < ch_bufhead->datasize) ? \
			ch_bufhead->data[ch_offset] : fch_get())
d146 1
a146 1
fch_get()
d149 1
d156 14
d176 1
a176 1
	FOR_BUFS_IN_CHAIN(h, bp)
d178 1
d185 1
a185 1
				goto read_more;
d189 32
a220 22
	/*
	 * Block is not in a buffer.  
	 * Take the least recently used buffer 
	 * and read the desired block into it.
	 * If the LRU buffer has data in it, 
	 * then maybe allocate a new buffer.
	 */
	if (ch_buftail == END_OF_CHAIN || ch_buftail->block != -1)
	{
		/*
		 * There is no empty buffer to use.
		 * Allocate a new buffer if:
		 * 1. We can't seek on this file and -b is not in effect; or
		 * 2. We haven't allocated the max buffers for this file yet.
		 */
		if ((autobuf && !(ch_flags & CH_CANSEEK)) ||
		    (maxbufs < 0 || ch_nbufs < maxbufs))
			if (ch_addbuf())
				/*
				 * Allocation failed: turn off autobuf.
				 */
				autobuf = OPT_OFF;
a221 5
	bp = ch_buftail;
	HASH_RM(bp); /* Remove from old hash chain. */
	bp->block = ch_block;
	bp->datasize = 0;
	HASH_INS(bp, h); /* Insert into new hash chain. */
d317 19
d342 1
a342 1
	if (ch_bufhead != bp)
d348 2
a349 6
		bp->next->prev = bp->prev;
		bp->prev->next = bp->next;
		bp->next = ch_bufhead;
		bp->prev = END_OF_CHAIN;
		ch_bufhead->prev = bp;
		ch_bufhead = bp;
d354 2
a355 2
		HASH_RM(bp);
		HASH_INS(bp, h);
d415 1
d423 2
a424 1
		for (bp = ch_bufhead;  ;  bp = bp->next)
d426 1
a426 10
			if (bp == END_OF_CHAIN)
			{
				if (!warned)
				{
					error("Warning: log file is incomplete",
						NULL_PARG);
					warned = TRUE;
				}
				break;
			}
d430 1
d434 6
d453 1
d457 1
a457 1
	FOR_BUFS_IN_CHAIN(h, bp)
d459 1
d477 3
d514 3
d541 2
a542 1
	register struct buf *bp, *firstbp;
d554 2
a555 2
	firstbp = bp = ch_bufhead;
	if (bp == END_OF_CHAIN)
d557 6
a562 4
	while ((bp = bp->next) != END_OF_CHAIN)
		if (bp->block < firstbp->block)
			firstbp = bp;
	ch_block = firstbp->block;
d573 2
d586 2
d599 2
d620 2
d660 4
a663 1
	register struct buf *bp;
d678 4
a681 2
	for (bp = ch_bufhead;  bp != END_OF_CHAIN;  bp = bp->next)
		bp->block = -1;
d728 1
d739 4
a742 5
	bp->next = END_OF_CHAIN;
	bp->prev = ch_buftail;
	ch_buftail->next = bp;
	ch_buftail = bp;
	HASH_INS(bp, 0);
d756 2
a757 2
		thisfile->hashtbl[h].buf_hnext = END_OF_HCHAIN(h);
		thisfile->hashtbl[h].buf_hprev = END_OF_HCHAIN(h);
d767 1
a767 1
	register struct buf *bp;
d771 3
a773 4
		bp = ch_bufhead;
		bp->next->prev = bp->prev;
		bp->prev->next = bp->next;
		free(bp);
d819 1
a819 1
		thisfile->buf_next = thisfile->buf_prev = END_OF_CHAIN;
d849 4
a852 1
	if (ch_flags & (CH_CANSEEK|CH_POPENED))
d890 2
d900 1
d912 1
a912 1
	for (bp = fs->buf_next; bp != (struct buf *)fs;  bp = bp->next)
d914 1
@


1.6
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d193 1
a193 1
		if (lseek(ch_file, (off_t)pos, 0) == BAD_LSEEK)
d623 1
a623 1
	if (lseek(ch_file, (off_t)0, 0) == BAD_LSEEK)
d712 1
a712 1
	return (lseek(f, (off_t)1, 0) != BAD_LSEEK);
@


1.5
log
@o go back to using a help file instead of embedding it in the binary
o deal with HELPFILE not being defined
o add a SMALL definition to make a smaller less for the boot floppies
This still needs to be pared down a bit for the SMALL case
@
text
@d686 1
a686 1
		bp->next->prev = bp->prev;;
@


1.4
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@a100 2
extern constant char helpdata[];
extern constant int size_helpdata;
a211 4
	} else if (ch_flags & CH_HELPFILE)
	{
		bp->data[bp->datasize] = helpdata[ch_fpos];
		n = 1;
a501 2
	if (ch_flags & CH_HELPFILE)
		return (size_helpdata);
d764 1
a764 1
	if (ch_flags & (CH_CANSEEK|CH_POPENED|CH_HELPFILE))
d780 1
a780 1
		if (!(ch_flags & (CH_POPENED|CH_HELPFILE)))
@


1.3
log
@kill more registers

millert@@ ok
@
text
@a0 2
/*	$OpenBSD: ch.c,v 1.2 2001/01/29 01:58:00 niklas Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d19 6
d34 1
a34 1
#define LBUFSIZE	1024
d36 3
a38 2
	struct buf *next, *prev;  /* Must be first to match struct filestate */
	long block;
d43 6
d53 1
a54 1
	/* -- Following members must match struct buf */
d56 1
a56 2
	long buf_block;
	/* -- End of struct buf copy */
d61 2
a62 2
	long block;
	int offset;
a65 2

#define	END_OF_CHAIN	((struct buf *)thisfile)
d76 18
d96 1
d100 3
a102 1
extern int cbufs;
d124 4
a127 3
	struct buf *bp;
	int n;
	int slept;
d136 3
a138 1
	for (bp = ch_bufhead;  bp != END_OF_CHAIN;  bp = bp->next)
d148 1
d156 1
a156 1
	if (ch_buftail == END_OF_CHAIN || ch_buftail->block != (long)(-1))
d165 1
a165 1
		    (cbufs == -1 || ch_nbufs < cbufs))
d173 1
d176 1
d209 1
a209 5
	if (ch_ungotchar == -1)
	{
		n = iread(ch_file, &bp->data[bp->datasize], 
			(unsigned int)(LBUFSIZE - bp->datasize));
	} else
d214 8
d228 7
a234 2
		error("read error", NULL_PARG);
		clear_eol();
d242 1
a242 1
	if (logfile >= 0 && n > 0)
d263 6
a268 2
				ierror("Waiting for data", NULL_PARG);
#if !MSOFTC
d270 4
d277 1
a277 1
		if (ABORT_SIGS())
a289 1

d294 6
d358 1
a358 1
	struct buf *bp;
d360 2
a361 2
	long block;
	long nblocks;
d394 1
a394 1
	long block;
d396 2
a397 1
	struct buf *bp;
d399 3
a401 1
	for (bp = ch_bufhead;  bp != END_OF_CHAIN;  bp = bp->next)
d404 1
d414 1
a414 1
	POSITION pos;
d416 1
a416 1
	long new_block;
d477 1
a477 1
	struct buf *bp, *firstbp;
d508 2
a515 2
#define	tellpos(blk,off)   ((POSITION)((((long)(blk)) * LBUFSIZE) + (off)))

d519 1
a519 1
	return (tellpos(ch_block, ch_offset));
d528 1
a528 1
	int c;
d564 2
a565 2
 * Allocate buffers.
 * Caller wants us to have a total of at least want_nbufs buffers.
d567 3
a569 3
	public int
ch_nbuf(want_nbufs)
	int want_nbufs;
d571 3
a573 3
	PARG parg;

	while (ch_nbufs < want_nbufs)
d575 3
a577 13
		if (ch_addbuf())
		{
			/*
			 * Cannot allocate enough buffers.
			 * If we don't have ANY, then quit.
			 * Otherwise, just report the error and return.
			 */
			parg.p_int = want_nbufs - ch_nbufs;
			error("Cannot allocate %d buffers", &parg);
			if (ch_nbufs == 0)
				quit(QUIT_ERROR);
			break;
		}
a578 1
	return (ch_nbufs);
d587 1
a587 1
	struct buf *bp;
d603 1
a603 1
		bp->block = (long)(-1);
d617 14
d649 1
a649 1
	struct buf *bp;
d659 1
a659 1
	bp->block = (long)(-1);
d664 1
d669 15
d689 1
a689 1
	struct buf *bp;
d699 1
d709 11
a742 1
		thisfile->buf_block = (long)(-1);
d751 1
d755 2
a756 2
		if (seekable(f))
			ch_flags |= CH_CANSEEK;
d772 1
a772 1
	if (ch_flags & (CH_CANSEEK|CH_POPENED))
d788 1
a788 1
		if (!(ch_flags & CH_POPENED))
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d111 3
a113 3
	register struct buf *bp;
	register int n;
	register int slept;
d317 1
a317 1
	register struct buf *bp;
d355 1
a355 1
	register struct buf *bp;
d369 1
a369 1
	register POSITION pos;
d432 1
a432 1
	register struct buf *bp, *firstbp;
d483 1
a483 1
	register int c;
d553 1
a553 1
	register struct buf *bp;
d601 1
a601 1
	register struct buf *bp;
d625 1
a625 1
	register struct buf *bp;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
a34 6
#if MSDOS_COMPILER==WIN32C
#include <errno.h>
#include <windows.h>
#endif

typedef POSITION BLOCKNUM;
d44 1
a44 1
#define	LBUFSIZE	8192
d46 2
a47 3
	struct buf *next, *prev;
	struct buf *hnext, *hprev;
	BLOCKNUM block;
a51 6
struct buflist {
	/* -- Following members must match struct buf */
	struct buf *buf_next, *buf_prev;
	struct buf *buf_hnext, *buf_hprev;
};

a55 1
#define	BUFHASH_SIZE	64
d57 1
d59 2
a60 1
	struct buflist hashtbl[BUFHASH_SIZE];
d65 2
a66 2
	BLOCKNUM block;
	unsigned int offset;
d70 2
a81 18
#define	END_OF_CHAIN	((struct buf *)&thisfile->buf_next)
#define	END_OF_HCHAIN(h) ((struct buf *)&thisfile->hashtbl[h])
#define BUFHASH(blk)	((blk) & (BUFHASH_SIZE-1))

#define	FOR_BUFS_IN_CHAIN(h,bp) \
	for (bp = thisfile->hashtbl[h].buf_hnext;  \
	     bp != END_OF_HCHAIN(h);  bp = bp->hnext)

#define	HASH_RM(bp) \
	(bp)->hnext->hprev = (bp)->hprev; \
	(bp)->hprev->hnext = (bp)->hnext;

#define	HASH_INS(bp,h) \
	(bp)->hnext = thisfile->hashtbl[h].buf_hnext; \
	(bp)->hprev = END_OF_HCHAIN(h); \
	thisfile->hashtbl[h].buf_hnext->hprev = (bp); \
	thisfile->hashtbl[h].buf_hnext = (bp);

a83 1
static int maxbufs = -1;
d87 1
a87 3
extern int secure;
extern constant char helpdata[];
extern constant int size_helpdata;
a111 1
	register int h;
d120 1
a120 3
	h = BUFHASH(ch_block);
	FOR_BUFS_IN_CHAIN(h, bp)
	{
a129 1
	}
d137 1
a137 1
	if (ch_buftail == END_OF_CHAIN || ch_buftail->block != -1)
d146 1
a146 1
		    (maxbufs < 0 || ch_nbufs < maxbufs))
a153 1
	HASH_RM(bp); /* Remove from old hash chain. */
a155 1
	HASH_INS(bp, h); /* Insert into new hash chain. */
d188 5
a192 1
	if (ch_ungotchar != -1)
a196 8
	} else if (ch_flags & CH_HELPFILE)
	{
		bp->data[bp->datasize] = helpdata[ch_fpos];
		n = 1;
	} else
	{
		n = iread(ch_file, &bp->data[bp->datasize], 
			(unsigned int)(LBUFSIZE - bp->datasize));
d203 2
a204 7
#if MSDOS_COMPILER==WIN32C
		if (errno != EPIPE)
#endif
		{
			error("read error", NULL_PARG);
			clear_eol();
		}
d212 1
a212 1
	if (!secure && logfile >= 0 && n > 0)
d233 2
a234 6
			{
				PARG parg;
				parg.p_string = wait_message();
				ierror("%s", &parg);
			}
#if !MSDOS_COMPILER
a235 4
#else
#if MSDOS_COMPILER==WIN32C
			Sleep(1000);
#endif
d239 1
a239 1
		if (sigs)
d252 1
a256 6

		/*
		 * Move to head of hash chain too.
		 */
		HASH_RM(bp);
		HASH_INS(bp, h);
d317 2
a318 2
	BLOCKNUM block;
	BLOCKNUM nblocks;
d351 1
a351 1
	BLOCKNUM block;
a353 1
	register int h;
d355 1
a355 3
	h = BUFHASH(block);
	FOR_BUFS_IN_CHAIN(h, bp)
	{
a357 1
	}
d369 1
a369 1
	BLOCKNUM new_block;
a460 2
	if (ch_flags & CH_HELPFILE)
		return (size_helpdata);
d467 2
d472 1
a472 1
	return (ch_block * LBUFSIZE) + ch_offset;
d517 2
a518 2
 * Set max amount of buffer space.
 * bufspace is in units of 1024 bytes.  -1 mean no limit.
d520 3
a522 3
	public void
ch_setbufspace(bufspace)
	int bufspace;
d524 3
a526 3
	if (bufspace < 0)
		maxbufs = -1;
	else
d528 13
a540 3
		maxbufs = ((bufspace * 1024) + LBUFSIZE-1) / LBUFSIZE;
		if (maxbufs < 1)
			maxbufs = 1;
d542 1
d567 1
a567 1
		bp->block = -1;
a580 14
#if 1
	/*
	 * This is a kludge to workaround a Linux kernel bug: files in
	 * /proc have a size of 0 according to fstat() but have readable 
	 * data.  They are sometimes, but not always, seekable.
	 * Force them to be non-seekable here.
	 */
	if (ch_fsize == 0)
	{
		ch_fsize = NULL_POSITION;
		ch_flags &= ~CH_CANSEEK;
	}
#endif

d609 1
a609 1
	bp->block = -1;
a613 1
	HASH_INS(bp, 0);
a617 15
 *
 */
	static void
init_hashtbl()
{
	register int h;

	for (h = 0;  h < BUFHASH_SIZE;  h++)
	{
		thisfile->hashtbl[h].buf_hnext = END_OF_HCHAIN(h);
		thisfile->hashtbl[h].buf_hprev = END_OF_HCHAIN(h);
	}
}

/*
a632 1
	init_hashtbl();
a641 11
#if MSDOS_COMPILER
	extern int fd0;
	if (f == fd0 && !isatty(fd0))
	{
		/*
		 * In MS-DOS, pipes are seekable.  Check for
		 * standard input, and pretend it is not seekable.
		 */
		return (0);
	}
#endif
d665 1
a673 1
		init_hashtbl();
d677 2
a678 2
		if ((flags & CH_CANSEEK) && !seekable(f))
			ch_flags &= ~CH_CANSEEK;
d694 1
a694 1
	if (ch_flags & (CH_CANSEEK|CH_POPENED|CH_HELPFILE))
d710 1
a710 1
		if (!(ch_flags & (CH_POPENED|CH_HELPFILE)))
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
a23 6
#if HAVE_STAT_INO
#include <sys/stat.h>
extern dev_t curr_dev;
extern ino_t curr_ino;
#endif

a33 5
struct bufnode {
	struct bufnode *next, *prev;
	struct bufnode *hnext, *hprev;
};

d36 2
a37 1
	struct bufnode node;
d42 6
a47 1
#define bufnode_buf(bn)  ((struct buf *) bn)
d55 2
a56 2
	struct bufnode buflist;
	struct bufnode hashtbl[BUFHASH_SIZE];
d66 2
a67 2
#define	ch_bufhead	thisfile->buflist.next
#define	ch_buftail	thisfile->buflist.prev
d76 2
a77 2
#define	END_OF_CHAIN	(&thisfile->buflist)
#define	END_OF_HCHAIN(h) (&thisfile->hashtbl[h])
d80 13
a92 38
/*
 * Macros to manipulate the list of buffers in thisfile->buflist.
 */
#define	FOR_BUFS(bn) \
	for (bn = ch_bufhead;  bn != END_OF_CHAIN;  bn = bn->next)

#define BUF_RM(bn) \
	(bn)->next->prev = (bn)->prev; \
	(bn)->prev->next = (bn)->next;

#define BUF_INS_HEAD(bn) \
	(bn)->next = ch_bufhead; \
	(bn)->prev = END_OF_CHAIN; \
	ch_bufhead->prev = (bn); \
	ch_bufhead = (bn);

#define BUF_INS_TAIL(bn) \
	(bn)->next = END_OF_CHAIN; \
	(bn)->prev = ch_buftail; \
	ch_buftail->next = (bn); \
	ch_buftail = (bn);

/*
 * Macros to manipulate the list of buffers in thisfile->hashtbl[n].
 */
#define	FOR_BUFS_IN_CHAIN(h,bn) \
	for (bn = thisfile->hashtbl[h].hnext;  \
	     bn != END_OF_HCHAIN(h);  bn = bn->hnext)

#define	BUF_HASH_RM(bn) \
	(bn)->hnext->hprev = (bn)->hprev; \
	(bn)->hprev->hnext = (bn)->hnext;

#define	BUF_HASH_INS(bn,h) \
	(bn)->hnext = thisfile->hashtbl[h].hnext; \
	(bn)->hprev = END_OF_HCHAIN(h); \
	thisfile->hashtbl[h].hnext->hprev = (bn); \
	thisfile->hashtbl[h].hnext = (bn);
a100 2
extern int screen_trashed;
extern int follow_mode;
d114 7
a120 1
 */
d122 1
a122 1
ch_get()
a124 1
	register struct bufnode *bn;
a130 14
	if (thisfile == NULL)
		return (EOI);

	/*
	 * Quick check for the common case where 
	 * the desired char is in the head buffer.
	 */
	if (ch_bufhead != END_OF_CHAIN)
	{
		bp = bufnode_buf(ch_bufhead);
		if (ch_block == bp->block && ch_offset < bp->datasize)
			return bp->data[ch_offset];
	}

d137 1
a137 1
	FOR_BUFS_IN_CHAIN(h, bn)
a138 1
		bp = bufnode_buf(bn);
d145 1
a145 1
				break;
d149 22
a170 32
	if (bn == END_OF_HCHAIN(h))
	{
		/*
		 * Block is not in a buffer.  
		 * Take the least recently used buffer 
		 * and read the desired block into it.
		 * If the LRU buffer has data in it, 
		 * then maybe allocate a new buffer.
		 */
		if (ch_buftail == END_OF_CHAIN || 
			bufnode_buf(ch_buftail)->block != -1)
		{
			/*
			 * There is no empty buffer to use.
			 * Allocate a new buffer if:
			 * 1. We can't seek on this file and -b is not in effect; or
			 * 2. We haven't allocated the max buffers for this file yet.
			 */
			if ((autobuf && !(ch_flags & CH_CANSEEK)) ||
				(maxbufs < 0 || ch_nbufs < maxbufs))
				if (ch_addbuf())
					/*
					 * Allocation failed: turn off autobuf.
					 */
					autobuf = OPT_OFF;
		}
		bn = ch_buftail;
		bp = bufnode_buf(bn);
		BUF_HASH_RM(bn); /* Remove from old hash chain. */
		bp->block = ch_block;
		bp->datasize = 0;
		BUF_HASH_INS(bn, h); /* Insert into new hash chain. */
d172 5
d195 1
a195 1
		if (lseek(ch_file, (off_t)pos, SEEK_SET) == BAD_LSEEK)
a275 19

#if HAVE_STAT_INO
			if (follow_mode == FOLLOW_NAME)
			{
				/* See whether the file's i-number has changed.
				 * If so, force the file to be closed and
				 * reopened. */
				struct stat st;
				int r = stat(get_filename(curr_ifile), &st);
				if (r == 0 && (st.st_ino != curr_ino ||
					st.st_dev != curr_dev))
				{
					/* screen_trashed=2 causes
					 * make_display to reopen the file. */
					screen_trashed = 2;
					return (EOI);
				}
			}
#endif
d282 1
a282 1
	if (ch_bufhead != bn)
d288 6
a293 2
		BUF_RM(bn);
		BUF_INS_HEAD(bn);
d298 2
a299 2
		BUF_HASH_RM(bn);
		BUF_HASH_INS(bn, h);
a358 1
	register struct bufnode *bn;
d366 1
a366 2
		int wrote = FALSE;
		FOR_BUFS(bn)
d368 10
a377 1
			bp = bufnode_buf(bn);
a380 1
				wrote = TRUE;
a383 6
		if (!wrote && !warned)
		{
			error("Warning: log file is incomplete",
				NULL_PARG);
			warned = TRUE;
		}
a396 1
	register struct bufnode *bn;
d400 1
a400 1
	FOR_BUFS_IN_CHAIN(h, bn)
a401 1
		bp = bufnode_buf(bn);
a418 3
	if (thisfile == NULL)
		return (0);

a452 3
	if (thisfile == NULL)
		return (0);

d477 1
a477 2
	register struct bufnode *bn;
	register struct bufnode *firstbn;
d489 2
a490 2
	firstbn = ch_bufhead;
	if (firstbn == END_OF_CHAIN)
d492 4
a495 6
	FOR_BUFS(bn)
	{
		if (bufnode_buf(bn)->block < bufnode_buf(firstbn)->block)
			firstbn = bn;
	}
	ch_block = bufnode_buf(firstbn)->block;
a505 2
	if (thisfile == NULL)
		return (NULL_POSITION);
a518 2
	if (thisfile == NULL)
		return (NULL_POSITION);
a529 2
	if (thisfile == NULL)
		return (EOI);
a548 2
	if (thisfile == NULL)
		return (EOI);
d587 1
a587 4
	register struct bufnode *bn;

	if (thisfile == NULL)
		return;
d602 2
a603 4
	FOR_BUFS(bn)
	{
		bufnode_buf(bn)->block = -1;
	}
d631 1
a631 1
	if (lseek(ch_file, (off_t)0, SEEK_SET) == BAD_LSEEK)
a649 1
	register struct bufnode *bn;
d660 5
a664 4
	bn = &bp->node;

	BUF_INS_TAIL(bn);
	BUF_HASH_INS(bn, 0);
d678 2
a679 2
		thisfile->hashtbl[h].hnext = END_OF_HCHAIN(h);
		thisfile->hashtbl[h].hprev = END_OF_HCHAIN(h);
d689 1
a689 1
	register struct bufnode *bn;
d693 4
a696 3
		bn = ch_bufhead;
		BUF_RM(bn);
		free(bufnode_buf(bn));
d720 1
a720 1
	return (lseek(f, (off_t)1, SEEK_SET) != BAD_LSEEK);
d742 1
a742 1
		thisfile->buflist.next = thisfile->buflist.prev = END_OF_CHAIN;
a771 3
	if (thisfile == NULL)
		return;

a809 2
	if (thisfile == NULL)
		return (0);
a817 1
	struct bufnode *bn;
d829 1
a829 1
	for (bn = fs->next; bn != &fs->buflist;  bn = bn->next)
a830 1
		bp = bufnode_buf(bn);
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d129 1
a129 1
extern volatile sig_atomic_t sigs;
d133 2
d261 4
d583 2
a584 2
	if (ch_flags & CH_NODATA)
		return (0);
a808 11
 * Force EOF to be at the current read position.
 * This is used after an ignore_eof read, during which the EOF may change.
 */
	public void
ch_set_eof()
{
	ch_fsize = ch_fpos;
}


/*
d876 1
a876 1
		if (!(ch_flags & CH_POPENED))
@


