head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.4
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.29.0.2
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.17.0.8
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.11.0.12
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.8
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.6
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.4
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.8.0.34
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.32
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.30
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.26
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.28
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.24
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.22
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.20
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.18
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	OpenBSD_1_2:1.2
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2017.01.12.20.32.01;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	fCB8yVOGwo8TiAdm;

1.30
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	W32EN7Zp77efb8wW;

1.29
date	2016.03.16.15.36.26;	author mmcc;	state Exp;
branches;
next	1.28;
commitid	P9ytq8HKajWPxZf9;

1.28
date	2016.01.12.17.48.04;	author mmcc;	state Exp;
branches;
next	1.27;
commitid	O36S2Tb0ReI34f9s;

1.27
date	2015.11.23.09.26.51;	author nicm;	state Exp;
branches;
next	1.26;
commitid	kcUyxO9zLNo75SlC;

1.26
date	2015.11.13.16.48.48;	author nicm;	state Exp;
branches;
next	1.25;
commitid	1UhnxVLYjgAT43E3;

1.25
date	2015.11.09.16.46.42;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	rJ6tmXbM6ZZSV1zd;

1.24
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	ZtGimechwgSRYqRW;

1.23
date	2015.11.09.14.25.32;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	bgQj8bNZKDat4TZ4;

1.22
date	2015.11.07.18.07.44;	author tedu;	state Exp;
branches;
next	1.21;
commitid	DJUwzdj0cG1bCfEw;

1.21
date	2015.11.06.15.58.01;	author nicm;	state Exp;
branches;
next	1.20;
commitid	y4I2iN2XAfMdlxNX;

1.20
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.19;
commitid	QKrr6AuGzNx9nehL;

1.19
date	2015.11.05.22.47.33;	author tedu;	state Exp;
branches;
next	1.18;
commitid	vLFUUyhjlRQmhpMd;

1.18
date	2015.11.05.22.08.43;	author nicm;	state Exp;
branches;
next	1.17;
commitid	yKv9Ck9ZDgwWTRTo;

1.17
date	2014.05.10.20.09.38;	author chl;	state Exp;
branches;
next	1.16;

1.16
date	2014.05.10.16.45.23;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.29.12.11.25;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.26.05.58.43;	author shadchin;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.14.20.10.33;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2011.10.08.19.55.39;	author shadchin;	state Exp;
branches;
next	1.10;

1.10
date	2011.09.21.19.01.49;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.14.15.09.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.14.14.33.57;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.13.18.26.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.10.15.53.30;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.01.58.00;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.09.21.06.06.38;	author etheisen;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.02;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.42;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Fix the "t" command for the case where we go down by just a few lines:
clear the status before printing content on the last line of the screen.
OK millert@@ tom@@
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * User-level command processor.
 */

#include "cmd.h"
#include "less.h"
#include "option.h"
#include "position.h"

extern int erase_char, erase2_char, kill_char;
extern volatile sig_atomic_t sigs;
extern int quit_if_one_screen;
extern int less_is_more;
extern int squished;
extern int sc_width;
extern int sc_height;
extern int swindow;
extern int jump_sline;
extern int quitting;
extern int wscroll;
extern int top_scroll;
extern int ignore_eoi;
extern int secure;
extern int hshift;
extern int show_attn;
extern off_t highest_hilite;
extern char *every_first_cmd;
extern char *curr_altfilename;
extern char version[];
extern struct scrpos initial_scrpos;
extern IFILE curr_ifile;
extern void *ml_search;
extern void *ml_examine;
extern void *ml_shell;
extern char *editor;
extern char *editproto;
extern int screen_trashed;	/* The screen has been overwritten */
extern int shift_count;
extern int oldbot;
extern int forw_prompt;

static int mca;			/* The multicharacter command (action) */
static int search_type;		/* The previous type of search */
static off_t number;		/* The number typed by the user */
static long fraction;		/* The fractional part of the number */
static struct loption *curropt;
static int opt_lower;
static int optflag;
static int optgetname;
static off_t bottompos;
static int save_hshift;
static int pipec;

struct ungot {
	struct ungot *ug_next;
	int ug_char;
};
static struct ungot *ungot = NULL;
static int unget_end = 0;

static void multi_search(char *, int);

/*
 * Move the cursor to start of prompt line before executing a command.
 * This looks nicer if the command takes a long time before
 * updating the screen.
 */
static void
cmd_exec(void)
{
	clear_attn();
	clear_bot();
	flush(0);
}

/*
 * Set up the display to start a new multi-character command.
 */
static void
start_mca(int action, const char *prompt, void *mlist, int cmdflags)
{
	mca = action;
	clear_bot();
	clear_cmd();
	cmd_putstr((char *)prompt);
	set_mlist(mlist, cmdflags);
}

int
in_mca(void)
{
	return (mca != 0 && mca != A_PREFIX);
}

/*
 * Set up the display to start a new search command.
 */
static void
mca_search(void)
{
	if (search_type & SRCH_FILTER)
		mca = A_FILTER;
	else if (search_type & SRCH_FORW)
		mca = A_F_SEARCH;
	else
		mca = A_B_SEARCH;

	clear_bot();
	clear_cmd();

	if (search_type & SRCH_NO_MATCH)
		cmd_putstr("Non-match ");
	if (search_type & SRCH_FIRST_FILE)
		cmd_putstr("First-file ");
	if (search_type & SRCH_PAST_EOF)
		cmd_putstr("EOF-ignore ");
	if (search_type & SRCH_NO_MOVE)
		cmd_putstr("Keep-pos ");
	if (search_type & SRCH_NO_REGEX)
		cmd_putstr("Regex-off ");

	if (search_type & SRCH_FILTER)
		cmd_putstr("&/");
	else if (search_type & SRCH_FORW)
		cmd_putstr("/");
	else
		cmd_putstr("?");
	set_mlist(ml_search, 0);
}

/*
 * Set up the display to start a new toggle-option command.
 */
static void
mca_opt_toggle(void)
{
	int no_prompt;
	int flag;
	char *dash;

	no_prompt = (optflag & OPT_NO_PROMPT);
	flag = (optflag & ~OPT_NO_PROMPT);
	dash = (flag == OPT_NO_TOGGLE) ? "_" : "-";

	mca = A_OPT_TOGGLE;
	clear_bot();
	clear_cmd();
	cmd_putstr(dash);
	if (optgetname)
		cmd_putstr(dash);
	if (no_prompt)
		cmd_putstr("(P)");
	switch (flag) {
	case OPT_UNSET:
		cmd_putstr("+");
		break;
	case OPT_SET:
		cmd_putstr("!");
		break;
	}
	set_mlist(NULL, 0);
}

/*
 * Execute a multicharacter command.
 */
static void
exec_mca(void)
{
	char *cbuf;

	cmd_exec();
	cbuf = get_cmdbuf();

	switch (mca) {
	case A_F_SEARCH:
	case A_B_SEARCH:
		multi_search(cbuf, (int)number);
		break;
	case A_FILTER:
		search_type ^= SRCH_NO_MATCH;
		set_filter_pattern(cbuf, search_type);
		break;
	case A_FIRSTCMD:
		/*
		 * Skip leading spaces or + signs in the string.
		 */
		while (*cbuf == '+' || *cbuf == ' ')
			cbuf++;
		free(every_first_cmd);
		if (*cbuf == '\0')
			every_first_cmd = NULL;
		else
			every_first_cmd = estrdup(cbuf);
		break;
	case A_OPT_TOGGLE:
		toggle_option(curropt, opt_lower, cbuf, optflag);
		curropt = NULL;
		break;
	case A_F_BRACKET:
		match_brac(cbuf[0], cbuf[1], 1, (int)number);
		break;
	case A_B_BRACKET:
		match_brac(cbuf[1], cbuf[0], 0, (int)number);
		break;
	case A_EXAMINE:
		if (secure)
			break;

		/* POSIX behavior, but possibly generally useful */
		if (strlen(cbuf) == 0) {
			reopen_curr_ifile();
			jump_back(1);
			break;
		}
		/* POSIX behavior - probably not generally useful */
		if (less_is_more && (strcmp(cbuf, "#") == 0)) {
			if (ntags()) {
				error("No previous file", NULL);
				break;
			}
			if (edit_prev(1)) {
				error("No previous file", NULL);
			} else {
				jump_back(1);
			}
			break;
		}
		edit_list(cbuf);
		/* If tag structure is loaded then clean it up. */
		cleantags();
		break;
	case A_PIPE:
		if (secure)
			break;
		(void) pipe_mark(pipec, cbuf);
		error("|done", NULL);
		break;
	}
}

/*
 * Is a character an erase or kill char?
 */
static int
is_erase_char(int c)
{
	return (c == erase_char || c == erase2_char || c == kill_char);
}

/*
 * Handle the first char of an option (after the initial dash).
 */
static int
mca_opt_first_char(int c)
{
	int flag = (optflag & ~OPT_NO_PROMPT);
	if (flag == OPT_NO_TOGGLE) {
		switch (c) {
		case '_':
			/* "__" = long option name. */
			optgetname = TRUE;
			mca_opt_toggle();
			return (MCA_MORE);
		}
	} else {
		switch (c) {
		case '+':
			/* "-+" = UNSET. */
			optflag = (flag == OPT_UNSET) ? OPT_TOGGLE : OPT_UNSET;
			mca_opt_toggle();
			return (MCA_MORE);
		case '!':
			/* "-!" = SET */
			optflag = (flag == OPT_SET) ? OPT_TOGGLE : OPT_SET;
			mca_opt_toggle();
			return (MCA_MORE);
		case CONTROL('P'):
			optflag ^= OPT_NO_PROMPT;
			mca_opt_toggle();
			return (MCA_MORE);
		case '-':
			/* "--" = long option name. */
			optgetname = TRUE;
			mca_opt_toggle();
			return (MCA_MORE);
		}
	}
	/* Char was not handled here. */
	return (NO_MCA);
}

/*
 * Add a char to a long option name.
 * See if we've got a match for an option name yet.
 * If so, display the complete name and stop
 * accepting chars until user hits RETURN.
 */
static int
mca_opt_nonfirst_char(int c)
{
	char *p;
	char *oname;

	if (curropt != NULL) {
		/*
		 * Already have a match for the name.
		 * Don't accept anything but erase/kill.
		 */
		if (is_erase_char(c))
			return (MCA_DONE);
		return (MCA_MORE);
	}
	/*
	 * Add char to cmd buffer and try to match
	 * the option name.
	 */
	if (cmd_char(c) == CC_QUIT)
		return (MCA_DONE);
	p = get_cmdbuf();
	opt_lower = islower(p[0]);
	curropt = findopt_name(&p, &oname, NULL);
	if (curropt != NULL) {
		/*
		 * Got a match.
		 * Remember the option and
		 * display the full option name.
		 */
		cmd_reset();
		mca_opt_toggle();
		for (p = oname; *p != '\0'; p++) {
			c = *p;
			if (!opt_lower && islower(c))
				c = toupper(c);
			if (cmd_char(c) != CC_OK)
				return (MCA_DONE);
		}
	}
	return (MCA_MORE);
}

/*
 * Handle a char of an option toggle command.
 */
static int
mca_opt_char(int c)
{
	PARG parg;

	/*
	 * This may be a short option (single char),
	 * or one char of a long option name,
	 * or one char of the option parameter.
	 */
	if (curropt == NULL && len_cmdbuf() == 0) {
		int ret = mca_opt_first_char(c);
		if (ret != NO_MCA)
			return (ret);
	}
	if (optgetname) {
		/* We're getting a long option name.  */
		if (c != '\n' && c != '\r')
			return (mca_opt_nonfirst_char(c));
		if (curropt == NULL) {
			parg.p_string = get_cmdbuf();
			error("There is no --%s option", &parg);
			return (MCA_DONE);
		}
		optgetname = FALSE;
		cmd_reset();
	} else {
		if (is_erase_char(c))
			return (NO_MCA);
		if (curropt != NULL)
			/* We're getting the option parameter. */
			return (NO_MCA);
		curropt = findopt(c);
		if (curropt == NULL) {
			parg.p_string = propt(c);
			error("There is no %s option", &parg);
			return (MCA_DONE);
		}
	}
	/*
	 * If the option which was entered does not take a
	 * parameter, toggle the option immediately,
	 * so user doesn't have to hit RETURN.
	 */
	if ((optflag & ~OPT_NO_PROMPT) != OPT_TOGGLE ||
	    !opt_has_param(curropt)) {
		toggle_option(curropt, islower(c), "", optflag);
		return (MCA_DONE);
	}
	/*
	 * Display a prompt appropriate for the option parameter.
	 */
	start_mca(A_OPT_TOGGLE, opt_prompt(curropt), NULL, 0);
	return (MCA_MORE);
}

/*
 * Handle a char of a search command.
 */
static int
mca_search_char(int c)
{
	int flag = 0;

	/*
	 * Certain characters as the first char of
	 * the pattern have special meaning:
	 *	!  Toggle the NO_MATCH flag
	 *	*  Toggle the PAST_EOF flag
	 *	@@  Toggle the FIRST_FILE flag
	 */
	if (len_cmdbuf() > 0)
		return (NO_MCA);

	switch (c) {
	case CONTROL('E'): /* ignore END of file */
	case '*':
		if (mca != A_FILTER)
			flag = SRCH_PAST_EOF;
		break;
	case CONTROL('F'): /* FIRST file */
	case '@@':
		if (mca != A_FILTER)
			flag = SRCH_FIRST_FILE;
		break;
	case CONTROL('K'): /* KEEP position */
		if (mca != A_FILTER)
			flag = SRCH_NO_MOVE;
		break;
	case CONTROL('R'): /* Don't use REGULAR EXPRESSIONS */
		flag = SRCH_NO_REGEX;
		break;
	case CONTROL('N'): /* NOT match */
	case '!':
		flag = SRCH_NO_MATCH;
		break;
	}

	if (flag != 0) {
		search_type ^= flag;
		mca_search();
		return (MCA_MORE);
	}
	return (NO_MCA);
}

/*
 * Handle a character of a multi-character command.
 */
static int
mca_char(int c)
{
	int ret;

	switch (mca) {
	case 0:
		/*
		 * We're not in a multicharacter command.
		 */
		return (NO_MCA);

	case A_PREFIX:
		/*
		 * In the prefix of a command.
		 * This not considered a multichar command
		 * (even tho it uses cmdbuf, etc.).
		 * It is handled in the commands() switch.
		 */
		return (NO_MCA);

	case A_DIGIT:
		/*
		 * Entering digits of a number.
		 * Terminated by a non-digit.
		 */
		if (!((c >= '0' && c <= '9') || c == '.') && editchar(c,
		    EC_PEEK|EC_NOHISTORY|EC_NOCOMPLETE|EC_NORIGHTLEFT) ==
		    A_INVALID) {
			/*
			 * Not part of the number.
			 * End the number and treat this char
			 * as a normal command character.
			 */
			number = cmd_int(&fraction);
			mca = 0;
			cmd_accept();
			return (NO_MCA);
		}
		break;

	case A_OPT_TOGGLE:
		ret = mca_opt_char(c);
		if (ret != NO_MCA)
			return (ret);
		break;

	case A_F_SEARCH:
	case A_B_SEARCH:
	case A_FILTER:
		ret = mca_search_char(c);
		if (ret != NO_MCA)
			return (ret);
		break;

	default:
		/* Other multicharacter command. */
		break;
	}

	/*
	 * The multichar command is terminated by a newline.
	 */
	if (c == '\n' || c == '\r') {
		/*
		 * Execute the command.
		 */
		exec_mca();
		return (MCA_DONE);
	}

	/*
	 * Append the char to the command buffer.
	 */
	if (cmd_char(c) == CC_QUIT)
		/*
		 * Abort the multi-char command.
		 */
		return (MCA_DONE);

	if ((mca == A_F_BRACKET || mca == A_B_BRACKET) && len_cmdbuf() >= 2) {
		/*
		 * Special case for the bracket-matching commands.
		 * Execute the command after getting exactly two
		 * characters from the user.
		 */
		exec_mca();
		return (MCA_DONE);
	}

	/*
	 * Need another character.
	 */
	return (MCA_MORE);
}

/*
 * Discard any buffered file data.
 */
static void
clear_buffers(void)
{
	if (!(ch_getflags() & CH_CANSEEK))
		return;
	ch_flush();
	clr_linenum();
	clr_hilite();
}

/*
 * Make sure the screen is displayed.
 */
static void
make_display(void)
{
	/*
	 * If nothing is displayed yet, display starting from initial_scrpos.
	 */
	if (empty_screen()) {
		if (initial_scrpos.pos == -1)
			/*
			 * {{ Maybe this should be:
			 *    jump_loc(ch_zero(), jump_sline);
			 *    but this behavior seems rather unexpected
			 *    on the first screen. }}
			 */
			jump_loc(ch_zero(), 1);
		else
			jump_loc(initial_scrpos.pos, initial_scrpos.ln);
	} else if (screen_trashed) {
		int save_top_scroll = top_scroll;
		int save_ignore_eoi = ignore_eoi;
		top_scroll = 1;
		ignore_eoi = 0;
		if (screen_trashed == 2) {
			/*
			 * Special case used by ignore_eoi: re-open the input
			 * file and jump to the end of the file.
			 */
			reopen_curr_ifile();
			jump_forw();
		}
		repaint();
		top_scroll = save_top_scroll;
		ignore_eoi = save_ignore_eoi;
	}
}

/*
 * Display the appropriate prompt.
 */
static void
prompt(void)
{
	const char *p;

	if (ungot != NULL) {
		/*
		 * No prompt necessary if commands are from
		 * ungotten chars rather than from the user.
		 */
		return;
	}

	/*
	 * Make sure the screen is displayed.
	 */
	make_display();
	bottompos = position(BOTTOM_PLUS_ONE);

	/*
	 * If we've hit EOF on the last file and the -E flag is set, quit.
	 */
	if (get_quit_at_eof() == OPT_ONPLUS &&
	    eof_displayed() && !(ch_getflags() & CH_HELPFILE) &&
	    next_ifile(curr_ifile) == NULL)
		quit(QUIT_OK);

	/*
	 * If the entire file is displayed and the -F flag is set, quit.
	 */
	if (quit_if_one_screen &&
	    entire_file_displayed() && !(ch_getflags() & CH_HELPFILE) &&
	    next_ifile(curr_ifile) == NULL)
		quit(QUIT_OK);

	/*
	 * Select the proper prompt and display it.
	 */
	/*
	 * If the previous action was a forward movement,
	 * don't clear the bottom line of the display;
	 * just print the prompt since the forward movement guarantees
	 * that we're in the right position to display the prompt.
	 * Clearing the line could cause a problem: for example, if the last
	 * line displayed ended at the right screen edge without a newline,
	 * then clearing would clear the last displayed line rather than
	 * the prompt line.
	 */
	if (!forw_prompt)
		clear_bot();
	clear_cmd();
	forw_prompt = 0;
	p = prompt_string();
	if (is_filtering())
		putstr("& ");
	if (p == NULL || *p == '\0') {
		putchr(':');
	} else {
		at_enter(AT_STANDOUT);
		putstr(p);
		at_exit();
	}
	clear_eol();
}

/*
 * Display the less version message.
 */
void
dispversion(void)
{
	PARG parg;

	parg.p_string = version;
	error("less %s", &parg);
}

/*
 * Get command character.
 * The character normally comes from the keyboard,
 * but may come from ungotten characters
 * (characters previously given to ungetcc or ungetsc).
 */
int
getcc(void)
{
	if (unget_end) {
		/*
		 * We have just run out of ungotten chars.
		 */
		unget_end = 0;
		if (len_cmdbuf() == 0 || !empty_screen())
			return (getchr());
		/*
		 * Command is incomplete, so try to complete it.
		 */
		switch (mca) {
		case A_DIGIT:
			/*
			 * We have a number but no command.  Treat as #g.
			 */
			return ('g');

		case A_F_SEARCH:
		case A_B_SEARCH:
			/*
			 * We have "/string" but no newline.  Add the \n.
			 */
			return ('\n');

		default:
			/*
			 * Some other incomplete command.  Let user complete it.
			 */
			return (getchr());
		}
	}

	if (ungot == NULL) {
		/*
		 * Normal case: no ungotten chars, so get one from the user.
		 */
		return (getchr());
	}

	/*
	 * Return the next ungotten char.
	 */
	{
		struct ungot *ug = ungot;
		int c = ug->ug_char;
		ungot = ug->ug_next;
		free(ug);
		unget_end = (ungot == NULL);
		return (c);
	}
}

/*
 * "Unget" a command character.
 * The next getcc() will return this character.
 */
void
ungetcc(int c)
{
	struct ungot *ug = ecalloc(1, sizeof (struct ungot));

	ug->ug_char = c;
	ug->ug_next = ungot;
	ungot = ug;
	unget_end = 0;
}

/*
 * Unget a whole string of command characters.
 * The next sequence of getcc()'s will return this string.
 */
void
ungetsc(char *s)
{
	char *p;

	for (p = s + strlen(s) - 1; p >= s; p--)
		ungetcc(*p);
}

/*
 * Search for a pattern, possibly in multiple files.
 * If SRCH_FIRST_FILE is set, begin searching at the first file.
 * If SRCH_PAST_EOF is set, continue the search thru multiple files.
 */
static void
multi_search(char *pattern, int n)
{
	int nomore;
	IFILE save_ifile;
	int changed_file;

	changed_file = 0;
	save_ifile = save_curr_ifile();

	if (search_type & SRCH_FIRST_FILE) {
		/*
		 * Start at the first (or last) file
		 * in the command line list.
		 */
		if (search_type & SRCH_FORW)
			nomore = edit_first();
		else
			nomore = edit_last();
		if (nomore) {
			unsave_ifile(save_ifile);
			return;
		}
		changed_file = 1;
		search_type &= ~SRCH_FIRST_FILE;
	}

	for (;;) {
		n = search(search_type, pattern, n);
		/*
		 * The SRCH_NO_MOVE flag doesn't "stick": it gets cleared
		 * after being used once.  This allows "n" to work after
		 * using a /@@@@ search.
		 */
		search_type &= ~SRCH_NO_MOVE;
		if (n == 0) {
			/*
			 * Found it.
			 */
			unsave_ifile(save_ifile);
			return;
		}

		if (n < 0)
			/*
			 * Some kind of error in the search.
			 * Error message has been printed by search().
			 */
			break;

		if ((search_type & SRCH_PAST_EOF) == 0)
			/*
			 * We didn't find a match, but we're
			 * supposed to search only one file.
			 */
			break;
		/*
		 * Move on to the next file.
		 */
		if (search_type & SRCH_FORW)
			nomore = edit_next(1);
		else
			nomore = edit_prev(1);
		if (nomore)
			break;
		changed_file = 1;
	}

	/*
	 * Didn't find it.
	 * Print an error message if we haven't already.
	 */
	if (n > 0)
		error("Pattern not found", NULL);

	if (changed_file) {
		/*
		 * Restore the file we were originally viewing.
		 */
		reedit_ifile(save_ifile);
	} else {
		unsave_ifile(save_ifile);
	}
}

/*
 * Forward forever, or until a highlighted line appears.
 */
static int
forw_loop(int until_hilite)
{
	off_t curr_len;

	if (ch_getflags() & CH_HELPFILE)
		return (A_NOACTION);

	cmd_exec();
	jump_forw();
	curr_len = ch_length();
	highest_hilite = until_hilite ? curr_len : -1;
	ignore_eoi = 1;
	while (!sigs) {
		if (until_hilite && highest_hilite > curr_len) {
			ring_bell();
			break;
		}
		make_display();
		forward(1, 0, 0);
	}
	ignore_eoi = 0;
	ch_set_eof();

	/*
	 * This gets us back in "F mode" after processing
	 * a non-abort signal (e.g. window-change).
	 */
	if (sigs && !ABORT_SIGS())
		return (until_hilite ? A_F_UNTIL_HILITE : A_F_FOREVER);

	return (A_NOACTION);
}

/*
 * Main command processor.
 * Accept and execute commands until a quit command.
 */
void
commands(void)
{
	int c = 0;
	int action;
	char *cbuf;
	int newaction;
	int save_search_type;
	char *extra;
	char tbuf[2];
	PARG parg;
	IFILE old_ifile;
	IFILE new_ifile;
	char *tagfile;

	search_type = SRCH_FORW;
	wscroll = (sc_height + 1) / 2;
	newaction = A_NOACTION;

	for (;;) {
		mca = 0;
		cmd_accept();
		number = 0;
		curropt = NULL;

		/*
		 * See if any signals need processing.
		 */
		if (sigs) {
			psignals();
			if (quitting)
				quit(QUIT_SAVED_STATUS);
		}

		/*
		 * Display prompt and accept a character.
		 */
		cmd_reset();
		prompt();
		if (sigs)
			continue;
		if (newaction == A_NOACTION)
			c = getcc();

again:
		if (sigs)
			continue;

		if (newaction != A_NOACTION) {
			action = newaction;
			newaction = A_NOACTION;
		} else {
			/*
			 * If we are in a multicharacter command, call mca_char.
			 * Otherwise we call fcmd_decode to determine the
			 * action to be performed.
			 */
			if (mca)
				switch (mca_char(c)) {
				case MCA_MORE:
					/*
					 * Need another character.
					 */
					c = getcc();
					goto again;
				case MCA_DONE:
					/*
					 * Command has been handled by mca_char.
					 * Start clean with a prompt.
					 */
					continue;
				case NO_MCA:
					/*
					 * Not a multi-char command
					 * (at least, not anymore).
					 */
					break;
				}

			/*
			 * Decode the command character and decide what to do.
			 */
			if (mca) {
				/*
				 * We're in a multichar command.
				 * Add the character to the command buffer
				 * and display it on the screen.
				 * If the user backspaces past the start
				 * of the line, abort the command.
				 */
				if (cmd_char(c) == CC_QUIT || len_cmdbuf() == 0)
					continue;
				cbuf = get_cmdbuf();
			} else {
				/*
				 * Don't use cmd_char if we're starting fresh
				 * at the beginning of a command, because we
				 * don't want to echo the command until we know
				 * it is a multichar command.  We also don't
				 * want erase_char/kill_char to be treated
				 * as line editing characters.
				 */
				tbuf[0] = (char)c;
				tbuf[1] = '\0';
				cbuf = tbuf;
			}
			extra = NULL;
			action = fcmd_decode(cbuf, &extra);
			/*
			 * If an "extra" string was returned,
			 * process it as a string of command characters.
			 */
			if (extra != NULL)
				ungetsc(extra);
		}
		/*
		 * Clear the cmdbuf string.
		 * (But not if we're in the prefix of a command,
		 * because the partial command string is kept there.)
		 */
		if (action != A_PREFIX)
			cmd_reset();

		switch (action) {
		case A_DIGIT:
			/*
			 * First digit of a number.
			 */
			start_mca(A_DIGIT, ":", (void*)NULL, CF_QUIT_ON_ERASE);
			goto again;

		case A_F_WINDOW:
			/*
			 * Forward one window (and set the window size).
			 */
			if (number > 0)
				swindow = (int)number;
			/* FALLTHRU */
		case A_F_SCREEN:
			/*
			 * Forward one screen.
			 */
			if (number <= 0)
				number = get_swindow();
			cmd_exec();
			if (show_attn)
				set_attnpos(bottompos);
			forward((int)number, 0, 1);
			break;

		case A_B_WINDOW:
			/*
			 * Backward one window (and set the window size).
			 */
			if (number > 0)
				swindow = (int)number;
			/* FALLTHRU */
		case A_B_SCREEN:
			/*
			 * Backward one screen.
			 */
			if (number <= 0)
				number = get_swindow();
			cmd_exec();
			backward((int)number, 0, 1);
			break;

		case A_F_LINE:
			/*
			 * Forward N (default 1) line.
			 */
			if (number <= 0)
				number = 1;
			cmd_exec();
			if (show_attn == OPT_ONPLUS && number > 1)
				set_attnpos(bottompos);
			forward((int)number, 0, 0);
			break;

		case A_B_LINE:
			/*
			 * Backward N (default 1) line.
			 */
			if (number <= 0)
				number = 1;
			cmd_exec();
			backward((int)number, 0, 0);
			break;

		case A_F_SKIP:
			/*
			 * Skip ahead one screen, and then number lines.
			 */
			if (number <= 0) {
				number = get_swindow();
			} else {
				number += get_swindow();
			}
			cmd_exec();
			if (show_attn == OPT_ONPLUS)
				set_attnpos(bottompos);
			forward((int)number, 0, 1);
			break;

		case A_FF_LINE:
			/*
			 * Force forward N (default 1) line.
			 */
			if (number <= 0)
				number = 1;
			cmd_exec();
			if (show_attn == OPT_ONPLUS && number > 1)
				set_attnpos(bottompos);
			forward((int)number, 1, 0);
			break;

		case A_BF_LINE:
			/*
			 * Force backward N (default 1) line.
			 */
			if (number <= 0)
				number = 1;
			cmd_exec();
			backward((int)number, 1, 0);
			break;

		case A_FF_SCREEN:
			/*
			 * Force forward one screen.
			 */
			if (number <= 0)
				number = get_swindow();
			cmd_exec();
			if (show_attn == OPT_ONPLUS)
				set_attnpos(bottompos);
			forward((int)number, 1, 0);
			break;

		case A_F_FOREVER:
			/*
			 * Forward forever, ignoring EOF.
			 */
			newaction = forw_loop(0);
			break;

		case A_F_UNTIL_HILITE:
			newaction = forw_loop(1);
			break;

		case A_F_SCROLL:
			/*
			 * Forward N lines
			 * (default same as last 'd' or 'u' command).
			 */
			if (number > 0)
				wscroll = (int)number;
			cmd_exec();
			if (show_attn == OPT_ONPLUS)
				set_attnpos(bottompos);
			forward(wscroll, 0, 0);
			break;

		case A_B_SCROLL:
			/*
			 * Forward N lines
			 * (default same as last 'd' or 'u' command).
			 */
			if (number > 0)
				wscroll = (int)number;
			cmd_exec();
			backward(wscroll, 0, 0);
			break;

		case A_FREPAINT:
			/*
			 * Flush buffers, then repaint screen.
			 * Don't flush the buffers on a pipe!
			 */
			clear_buffers();
			/* FALLTHRU */
		case A_REPAINT:
			/*
			 * Repaint screen.
			 */
			cmd_exec();
			repaint();
			break;

		case A_GOLINE:
			/*
			 * Go to line N, default beginning of file.
			 */
			if (number <= 0)
				number = 1;
			cmd_exec();
			jump_back(number);
			break;

		case A_PERCENT:
			/*
			 * Go to a specified percentage into the file.
			 */
			if (number < 0) {
				number = 0;
				fraction = 0;
			}
			if (number > 100) {
				number = 100;
				fraction = 0;
			}
			cmd_exec();
			jump_percent((int)number, fraction);
			break;

		case A_GOEND:
			/*
			 * Go to line N, default end of file.
			 */
			cmd_exec();
			if (number <= 0)
				jump_forw();
			else
				jump_back(number);
			break;

		case A_GOPOS:
			/*
			 * Go to a specified byte position in the file.
			 */
			cmd_exec();
			if (number < 0)
				number = 0;
			jump_line_loc((off_t) number, jump_sline);
			break;

		case A_STAT:
			/*
			 * Print file name, etc.
			 */
			if (ch_getflags() & CH_HELPFILE)
				break;
			cmd_exec();
			parg.p_string = eq_message();
			error("%s", &parg);
			break;

		case A_VERSION:
			/*
			 * Print version number, without the "@@(#)".
			 */
			cmd_exec();
			dispversion();
			break;

		case A_QUIT:
			/*
			 * Exit.
			 */
			if (curr_ifile != NULL &&
			    ch_getflags() & CH_HELPFILE) {
				/*
				 * Quit while viewing the help file
				 * just means return to viewing the
				 * previous file.
				 */
				hshift = save_hshift;
				if (edit_prev(1) == 0)
					break;
			}
			if (extra != NULL)
				quit(*extra);
			quit(QUIT_OK);
			break;

/*
 * Define abbreviation for a commonly used sequence below.
 */
#define	DO_SEARCH() \
			if (number <= 0) number = 1;	\
			mca_search();			\
			cmd_exec();			\
			multi_search(NULL, (int)number);


		case A_F_SEARCH:
			/*
			 * Search forward for a pattern.
			 * Get the first char of the pattern.
			 */
			search_type = SRCH_FORW;
			if (number <= 0)
				number = 1;
			mca_search();
			c = getcc();
			goto again;

		case A_B_SEARCH:
			/*
			 * Search backward for a pattern.
			 * Get the first char of the pattern.
			 */
			search_type = SRCH_BACK;
			if (number <= 0)
				number = 1;
			mca_search();
			c = getcc();
			goto again;

		case A_FILTER:
			search_type = SRCH_FORW | SRCH_FILTER;
			mca_search();
			c = getcc();
			goto again;

		case A_AGAIN_SEARCH:
			/*
			 * Repeat previous search.
			 */
			DO_SEARCH();
			break;

		case A_T_AGAIN_SEARCH:
			/*
			 * Repeat previous search, multiple files.
			 */
			search_type |= SRCH_PAST_EOF;
			DO_SEARCH();
			break;

		case A_REVERSE_SEARCH:
			/*
			 * Repeat previous search, in reverse direction.
			 */
			save_search_type = search_type;
			search_type = SRCH_REVERSE(search_type);
			DO_SEARCH();
			search_type = save_search_type;
			break;

		case A_T_REVERSE_SEARCH:
			/*
			 * Repeat previous search,
			 * multiple files in reverse direction.
			 */
			save_search_type = search_type;
			search_type = SRCH_REVERSE(search_type);
			search_type |= SRCH_PAST_EOF;
			DO_SEARCH();
			search_type = save_search_type;
			break;

		case A_UNDO_SEARCH:
			undo_search();
			break;

		case A_HELP:
			/*
			 * Help.
			 */
			if (ch_getflags() & CH_HELPFILE)
				break;
			if (ungot != NULL || unget_end) {
				error(less_is_more
				    ? "Invalid option -p h"
				    : "Invalid option ++h",
				    NULL);
				break;
			}
			cmd_exec();
			save_hshift = hshift;
			hshift = 0;
			(void) edit(helpfile());
			break;

		case A_EXAMINE:
			/*
			 * Edit a new file.  Get the filename.
			 */
			if (secure) {
				error("Command not available", NULL);
				break;
			}
			start_mca(A_EXAMINE, "Examine: ", ml_examine, 0);
			c = getcc();
			goto again;

		case A_VISUAL:
			/*
			 * Invoke an editor on the input file.
			 */
			if (secure) {
				error("Command not available", NULL);
				break;
			}
			if (ch_getflags() & CH_HELPFILE)
				break;
			if (strcmp(get_filename(curr_ifile), "-") == 0) {
				error("Cannot edit standard input", NULL);
				break;
			}
			if (curr_altfilename != NULL) {
				error("WARNING: This file was viewed via "
				    "LESSOPEN", NULL);
			}
			/*
			 * Expand the editor prototype string
			 * and pass it to the system to execute.
			 * (Make sure the screen is displayed so the
			 * expansion of "+%lm" works.)
			 */
			make_display();
			cmd_exec();
			lsystem(pr_expand(editproto, 0), NULL);
			break;

		case A_NEXT_FILE:
			/*
			 * Examine next file.
			 */
			if (ntags()) {
				error("No next file", NULL);
				break;
			}
			if (number <= 0)
				number = 1;
			if (edit_next((int)number)) {
				if (get_quit_at_eof() && eof_displayed() &&
				    !(ch_getflags() & CH_HELPFILE))
					quit(QUIT_OK);
				parg.p_string = (number > 1) ? "(N-th) " : "";
				error("No %snext file", &parg);
			}
			break;

		case A_PREV_FILE:
			/*
			 * Examine previous file.
			 */
			if (ntags()) {
				error("No previous file", NULL);
				break;
			}
			if (number <= 0)
				number = 1;
			if (edit_prev((int)number)) {
				parg.p_string = (number > 1) ? "(N-th) " : "";
				error("No %sprevious file", &parg);
			}
			break;

		case A_NEXT_TAG:
			if (number <= 0)
				number = 1;
			cmd_exec();
			tagfile = nexttag((int)number);
			if (tagfile == NULL) {
				error("No next tag", NULL);
				break;
			}
			if (edit(tagfile) == 0) {
				off_t pos = tagsearch();
				if (pos != -1)
					jump_loc(pos, jump_sline);
			}
			break;

		case A_PREV_TAG:
			if (number <= 0)
				number = 1;
			tagfile = prevtag((int)number);
			if (tagfile == NULL) {
				error("No previous tag", NULL);
				break;
			}
			if (edit(tagfile) == 0) {
				off_t pos = tagsearch();
				if (pos != -1)
					jump_loc(pos, jump_sline);
			}
			break;

		case A_INDEX_FILE:
			/*
			 * Examine a particular file.
			 */
			if (number <= 0)
				number = 1;
			if (edit_index((int)number))
				error("No such file", NULL);
			break;

		case A_REMOVE_FILE:
			if (ch_getflags() & CH_HELPFILE)
				break;
			old_ifile = curr_ifile;
			new_ifile = getoff_ifile(curr_ifile);
			if (new_ifile == NULL) {
				ring_bell();
				break;
			}
			if (edit_ifile(new_ifile) != 0) {
				reedit_ifile(old_ifile);
				break;
			}
			del_ifile(old_ifile);
			break;

		case A_OPT_TOGGLE:
			optflag = OPT_TOGGLE;
			optgetname = FALSE;
			mca_opt_toggle();
			c = getcc();
			goto again;

		case A_DISP_OPTION:
			/*
			 * Report a flag setting.
			 */
			optflag = OPT_NO_TOGGLE;
			optgetname = FALSE;
			mca_opt_toggle();
			c = getcc();
			goto again;

		case A_FIRSTCMD:
			/*
			 * Set an initial command for new files.
			 */
			start_mca(A_FIRSTCMD, "+", NULL, 0);
			c = getcc();
			goto again;

		case A_SETMARK:
			/*
			 * Set a mark.
			 */
			if (ch_getflags() & CH_HELPFILE)
				break;
			start_mca(A_SETMARK, "mark: ", (void*)NULL, 0);
			c = getcc();
			if (c == erase_char || c == erase2_char ||
			    c == kill_char || c == '\n' || c == '\r')
				break;
			setmark(c);
			break;

		case A_GOMARK:
			/*
			 * Go to a mark.
			 */
			start_mca(A_GOMARK, "goto mark: ", (void*)NULL, 0);
			c = getcc();
			if (c == erase_char || c == erase2_char ||
			    c == kill_char || c == '\n' || c == '\r')
				break;
			cmd_exec();
			gomark(c);
			break;

		case A_PIPE:
			if (secure) {
				error("Command not available", NULL);
				break;
			}
			start_mca(A_PIPE, "|mark: ", (void*)NULL, 0);
			c = getcc();
			if (c == erase_char || c == erase2_char ||
			    c == kill_char)
				break;
			if (c == '\n' || c == '\r')
				c = '.';
			if (badmark(c))
				break;
			pipec = c;
			start_mca(A_PIPE, "!", ml_shell, 0);
			c = getcc();
			goto again;

		case A_B_BRACKET:
		case A_F_BRACKET:
			start_mca(action, "Brackets: ", (void*)NULL, 0);
			c = getcc();
			goto again;

		case A_LSHIFT:
			if (number > 0)
				shift_count = number;
			else
				number = (shift_count > 0) ?
				    shift_count : sc_width / 2;
			if (number > hshift)
				number = hshift;
			hshift -= number;
			screen_trashed = 1;
			break;

		case A_RSHIFT:
			if (number > 0)
				shift_count = number;
			else
				number = (shift_count > 0) ?
				    shift_count : sc_width / 2;
			hshift += number;
			screen_trashed = 1;
			break;

		case A_PREFIX:
			/*
			 * The command is incomplete (more chars are needed).
			 * Display the current char, so the user knows
			 * what's going on, and get another character.
			 */
			if (mca != A_PREFIX) {
				cmd_reset();
				start_mca(A_PREFIX, " ", (void*)NULL,
				    CF_QUIT_ON_ERASE);
				(void) cmd_char(c);
			}
			c = getcc();
			goto again;

		case A_NOACTION:
			break;

		default:
			ring_bell();
			break;
		}
	}
}
@


1.30
log
@little bit more KNF
@
text
@d1466 1
@


1.29
log
@style(9) includes

ok nicm@@
@
text
@d342 1
a342 1
		for (p = oname;  *p != '\0';  p++) {
d778 1
a778 1
	for (p = s + strlen(s) - 1;  p >= s;  p--)
@


1.28
log
@Remove LINUNUM, a needless alias for off_t. Also, remove a redundant
condition.

ok nicm@@
@
text
@d16 1
d18 1
a19 2
#include "option.h"
#include "cmd.h"
@


1.27
log
@A couple more prototypes without arguments.
@
text
@d55 1
a55 1
static LINENUM number;		/* The number typed by the user */
@


1.26
log
@Add a flag argument to flush() to stop it calling quit() on error, then
use this from quit() to stop less blowing up the stack looping through
quit()/flush() if stderr is closed (for example "less /missing
2</dev/null"). ok millert
@
text
@d72 1
a72 1
static void multi_search();
@


1.25
log
@NULL_IFILE has no weird use patterns.  NULL is sufficient.
@
text
@d84 1
a84 1
	flush();
@


1.24
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@d640 1
a640 1
	    next_ifile(curr_ifile) == NULL_IFILE)
d648 1
a648 1
	    next_ifile(curr_ifile) == NULL_IFILE)
d1271 1
a1271 1
			if (curr_ifile != NULL_IFILE &&
d1508 1
a1508 1
			if (new_ifile == NULL_IFILE) {
@


1.23
log
@Remove NULL-checks before free(), a needless comment, and a needless
void* cast.

ok nicm@@
@
text
@d230 1
a230 1
				error("No previous file", NULL_PARG);
d234 1
a234 1
				error("No previous file", NULL_PARG);
d248 1
a248 1
		error("|done", NULL_PARG);
d860 1
a860 1
		error("Pattern not found", NULL_PARG);
d1378 1
a1378 1
				    NULL_PARG);
d1392 1
a1392 1
				error("Command not available", NULL_PARG);
d1404 1
a1404 1
				error("Command not available", NULL_PARG);
d1410 1
a1410 1
				error("Cannot edit standard input", NULL_PARG);
d1415 1
a1415 1
				    "LESSOPEN", NULL_PARG);
d1433 1
a1433 1
				error("No next file", NULL_PARG);
d1452 1
a1452 1
				error("No previous file", NULL_PARG);
d1468 1
a1468 1
				error("No next tag", NULL_PARG);
d1483 1
a1483 1
				error("No previous tag", NULL_PARG);
d1500 1
a1500 1
				error("No such file", NULL_PARG);
d1573 1
a1573 1
				error("Command not available", NULL_PARG);
@


1.22
log
@replace save() with estrdup() and make estrdup() exit like all the other
ecalloc, etc. functions do.
ok mmcc nicm
@
text
@d201 1
a201 2
		if (every_first_cmd != NULL)
			free(every_first_cmd);
@


1.21
log
@Remove support for ! to run a shell command, we have ^Z around these
parts. ok ratchov jung millert
@
text
@d206 1
a206 1
			every_first_cmd = save(cbuf);
@


1.20
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@a52 1
static char *shellcmd = NULL;	/* For holding last shell command for "!!" */
a244 19
	case A_SHELL:
		/*
		 * !! just uses whatever is in shellcmd.
		 * Otherwise, copy cmdbuf to shellcmd,
		 * expanding any special characters ("%" or "#").
		 */
		if (*cbuf != '!') {
			if (shellcmd != NULL)
				free(shellcmd);
			shellcmd = fexpand(cbuf);
		}

		if (secure)
			break;
		if (shellcmd == NULL)
			lsystem("", "!done");
		else
			lsystem(shellcmd, "!done");
		break;
a1417 1
			start_mca(A_SHELL, "!", ml_shell, 0);
a1541 12
			c = getcc();
			goto again;

		case A_SHELL:
			/*
			 * Shell escape.
			 */
			if (secure) {
				error("Command not available", NULL_PARG);
				break;
			}
			start_mca(A_SHELL, "!", ml_shell, 0);
@


1.19
log
@deregister
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.18
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d799 1
a799 1
	register char *p;
@


1.17
log
@remove unused variable

ok shadchin@@
@
text
@d9 4
a12 1

a18 3
#if MSDOS_COMPILER==WIN32C
#include <windows.h>
#endif
d26 1
d39 1
a39 1
extern POSITION highest_hilite;
d45 3
a47 6
extern void constant *ml_search;
extern void constant *ml_examine;
#if SHELL_ESCAPE || PIPEC
extern void constant *ml_shell;
#endif
#if EDITOR
a49 1
#endif
a53 1
extern int less_is_more;
a54 1
#if SHELL_ESCAPE
a55 1
#endif
d64 1
a64 1
static POSITION bottompos;
d66 1
a66 3
#if PIPEC
static char pipec;
#endif
d70 1
a70 1
	char ug_char;
d72 1
a72 1
static struct ungot* ungot = NULL;
d82 2
a83 2
	static void
cmd_exec()
a84 1
#if HILITE_SEARCH
a85 1
#endif
d93 2
a94 6
	static void
start_mca(action, prompt, mlist, cmdflags)
	int action;
	constant char *prompt;
	constant void *mlist;
	int cmdflags;
d99 1
a99 1
	cmd_putstr(prompt);
d103 2
a104 2
	public int
in_mca()
d112 2
a113 2
	static void
mca_search()
a114 1
#if HILITE_SEARCH
d117 1
a117 3
	else 
#endif
	if (search_type & SRCH_FORW)
a135 1
#if HILITE_SEARCH
d138 1
a138 3
	else 
#endif
	if (search_type & SRCH_FORW)
d148 2
a149 2
	static void
mca_opt_toggle()
d154 1
a154 1
	
a162 1
#if GNU_OPTIONS
a164 1
#endif
d167 1
a167 2
	switch (flag)
	{
d181 2
a182 2
	static void
exec_mca()
d184 1
a184 1
	register char *cbuf;
d189 1
a189 2
	switch (mca)
	{
d192 1
a192 1
		multi_search(cbuf, (int) number);
a193 1
#if HILITE_SEARCH
a197 1
#endif
d216 1
a216 1
		match_brac(cbuf[0], cbuf[1], 1, (int) number);
d219 1
a219 1
		match_brac(cbuf[1], cbuf[0], 0, (int) number);
a220 1
#if EXAMINE
d224 20
a244 1
#if TAGS
a246 1
#endif
a247 2
#endif
#if SHELL_ESCAPE
d254 1
a254 2
		if (*cbuf != '!')
		{
a266 2
#endif
#if PIPEC
a272 1
#endif
d279 2
a280 3
	static int
is_erase_char(c)
	int c;
d288 2
a289 3
	static int
mca_opt_first_char(c)
    int c;
d292 2
a293 5
#if GNU_OPTIONS
	if (flag == OPT_NO_TOGGLE)
	{
		switch (c)
		{
d300 2
a301 5
	} else
#endif
	{
		switch (c)
		{
d304 1
a304 2
			optflag = (flag == OPT_UNSET) ?
				OPT_TOGGLE : OPT_UNSET;
d309 1
a309 2
			optflag = (flag == OPT_SET) ?
				OPT_TOGGLE : OPT_SET;
a315 1
#if GNU_OPTIONS
a320 1
#endif
a326 1
#if GNU_OPTIONS
d330 1
a330 1
 * If so, display the complete name and stop 
d333 2
a334 3
	static int
mca_opt_nonfirst_char(c)
	int c;
d339 1
a339 2
	if (curropt != NULL)
	{
d355 1
a355 1
	opt_lower = ASCII_IS_LOWER(p[0]);
d357 1
a357 2
	if (curropt != NULL)
	{
d365 1
a365 2
		for (p = oname;  *p != '\0';  p++)
		{
d367 2
a368 2
			if (!opt_lower && ASCII_IS_LOWER(c))
				c = ASCII_TO_UPPER(c);
a374 1
#endif
d379 2
a380 3
	static int
mca_opt_char(c)
	int c;
d389 1
a389 2
	if (curropt == NULL && len_cmdbuf() == 0)
	{
d394 1
a394 3
#if GNU_OPTIONS
	if (optgetname)
	{
d398 1
a398 2
		if (curropt == NULL)
		{
d405 1
a405 3
	} else
#endif
	{
d412 1
a412 2
		if (curropt == NULL)
		{
d419 1
a419 1
	 * If the option which was entered does not take a 
d424 2
a425 3
	    !opt_has_param(curropt))
	{
		toggle_option(curropt, ASCII_IS_LOWER(c), "", optflag);
d431 1
a431 1
	start_mca(A_OPT_TOGGLE, opt_prompt(curropt), (void*)NULL, 0);
d438 2
a439 3
	static int
mca_search_char(c)
	int c;
d444 1
a444 1
	 * Certain characters as the first char of 
d453 1
a453 2
	switch (c)
	{
d477 1
a477 2
	if (flag != 0)
	{
d488 2
a489 3
	static int
mca_char(c)
	int c;
d493 1
a493 2
	switch (mca)
	{
d514 3
a516 3
		if (!((c >= '0' && c <= '9') || c == '.') && 
		  editchar(c, EC_PEEK|EC_NOHISTORY|EC_NOCOMPLETE|EC_NORIGHTLEFT) == A_INVALID)
		{
d519 1
a519 1
			 * End the number and treat this char 
d551 1
a551 2
	if (c == '\n' || c == '\r')
	{
d568 1
a568 2
	if ((mca == A_F_BRACKET || mca == A_B_BRACKET) && len_cmdbuf() >= 2)
	{
d587 2
a588 2
	static void
clear_buffers()
a593 1
#if HILITE_SEARCH
a594 1
#endif
d600 2
a601 2
	static void
make_display()
d606 2
a607 3
	if (empty_screen())
	{
		if (initial_scrpos.pos == NULL_POSITION)
d611 1
a611 1
			 *    but this behavior seems rather unexpected 
d617 1
a617 2
	} else if (screen_trashed)
	{
d622 5
a626 4
		if (screen_trashed == 2)
		{
			/* Special case used by ignore_eoi: re-open the input file
			 * and jump to the end of the file. */
d639 2
a640 2
	static void
prompt()
d642 1
a642 1
	register constant char *p;
d644 1
a644 2
	if (ungot != NULL)
	{
d646 1
a646 1
		 * No prompt necessary if commands are from 
d662 1
a662 1
	    eof_displayed() && !(ch_getflags() & CH_HELPFILE) && 
d670 1
a670 1
	    entire_file_displayed() && !(ch_getflags() & CH_HELPFILE) && 
a673 7
#if MSDOS_COMPILER==WIN32C
	/* 
	 * In Win32, display the file name in the window title.
	 */
	if (!(ch_getflags() & CH_HELPFILE))
		SetConsoleTitle(pr_expand("Less?f - %f.", 0));
#endif
d678 1
a678 1
	 * If the previous action was a forward movement, 
d680 1
a680 1
	 * just print the prompt since the forward movement guarantees 
d691 1
a691 1
	p = pr_string();
d694 1
a694 1
	if (p == NULL || *p == '\0')
d696 1
a696 2
	else
	{
d707 2
a708 2
	public void
dispversion()
d722 2
a723 2
	public int
getcc()
d725 1
a725 2
	if (unget_end) 
	{
d735 1
a735 2
		switch (mca)
		{
d747 1
a747 1
			return ('\n'); 
d757 1
a757 2
	if (ungot == NULL)
	{
d769 1
a769 1
		char c = ug->ug_char;
d781 2
a782 3
	public void
ungetcc(c)
	int c;
d784 1
a784 1
	struct ungot *ug = (struct ungot *) ecalloc(1, sizeof(struct ungot));
d796 2
a797 3
	public void
ungetsc(s)
	char *s;
d810 2
a811 4
	static void
multi_search(pattern, n)
	char *pattern;
	int n;
d813 1
a813 1
	register int nomore;
d820 1
a820 2
	if (search_type & SRCH_FIRST_FILE)
	{
d822 1
a822 1
		 * Start at the first (or last) file 
d829 1
a829 2
		if (nomore)
		{
d837 1
a837 2
	for (;;)
	{
d845 1
a845 2
		if (n == 0)
		{
d885 1
a885 2
	if (changed_file)
	{
d890 1
a890 2
	} else
	{
d898 2
a899 3
	static int
forw_loop(until_hilite)
	int until_hilite;
d901 1
a901 1
	POSITION curr_len;
d909 1
a909 1
	highest_hilite = until_hilite ? curr_len : NULL_POSITION;
d911 3
a913 5
	while (!sigs)
	{
		if (until_hilite && highest_hilite > curr_len)
		{
			bell();
d923 2
a924 2
	 * This gets us back in "F mode" after processing 
	 * a non-abort signal (e.g. window-change).  
d936 2
a937 2
	public void
commands()
d939 3
a941 3
	register int c;
	register int action;
	register char *cbuf;
d955 1
a955 2
	for (;;)
	{
d964 1
a964 2
		if (sigs)
		{
a970 6
		 * See if window size changed, for systems that don't
		 * generate SIGWINCH.
		 */
		check_winch();

		/*
d980 1
a980 1
	again:
d984 1
a984 2
		if (newaction != A_NOACTION)
		{
d987 1
a987 2
		} else
		{
d994 1
a994 2
				switch (mca_char(c))
				{
d1018 1
a1018 2
			if (mca)
			{
d1023 1
a1023 1
				 * If the user backspaces past the start 
d1029 1
a1029 2
			} else
			{
d1038 1
a1038 1
				tbuf[0] = c;
d1059 1
a1059 2
		switch (action)
		{
d1072 1
a1072 1
				swindow = (int) number;
d1083 1
a1083 1
			forward((int) number, 0, 1);
d1091 1
a1091 1
				swindow = (int) number;
d1100 1
a1100 1
			backward((int) number, 0, 1);
d1112 1
a1112 1
			forward((int) number, 0, 0);
d1122 16
a1137 1
			backward((int) number, 0, 0);
d1149 1
a1149 1
			forward((int) number, 1, 0);
d1159 1
a1159 1
			backward((int) number, 1, 0);
d1161 1
a1161 1
		
d1171 1
a1171 1
			forward((int) number, 1, 0);
d1187 1
a1187 1
			 * Forward N lines 
d1191 1
a1191 1
				wscroll = (int) number;
d1200 1
a1200 1
			 * Forward N lines 
d1204 1
a1204 1
				wscroll = (int) number;
d1238 1
a1238 2
			if (number < 0)
			{
d1242 1
a1242 2
			if (number > 100)
			{
d1247 1
a1247 1
			jump_percent((int) number, fraction);
d1268 1
a1268 1
			jump_line_loc((POSITION) number, jump_sline);
d1294 2
a1295 4
#if !SMALL
			if (curr_ifile != NULL_IFILE && 
			    ch_getflags() & CH_HELPFILE)
			{
a1304 1
#endif /* !SMALL */
d1317 1
a1317 1
			multi_search((char *)NULL, (int) number);
a1344 1
#if HILITE_SEARCH
a1348 4
#else
			error("Command not available", NULL_PARG);
			break;
#endif
d1356 1
a1356 1
		
d1376 2
a1377 2
			/* 
			 * Repeat previous search, 
a1394 1
#if !SMALL
a1407 1
#endif /* !SMALL */
a1410 1
#if EXAMINE
d1414 1
a1414 2
			if (secure)
			{
d1421 1
a1421 5
#else
			error("Command not available", NULL_PARG);
			break;
#endif
			
d1426 1
a1426 3
#if EDITOR
			if (secure)
			{
d1432 1
a1432 2
			if (strcmp(get_filename(curr_ifile), "-") == 0)
			{
d1436 3
a1438 4
			if (curr_altfilename != NULL)
			{
				error("WARNING: This file was viewed via LESSOPEN",
					NULL_PARG);
d1449 1
a1449 1
			lsystem(pr_expand(editproto, 0), (char*)NULL);
a1450 4
#else
			error("Command not available", NULL_PARG);
			break;
#endif
d1456 1
a1456 3
#if TAGS
			if (ntags())
			{
a1459 1
#endif
d1462 2
a1463 3
			if (edit_next((int) number))
			{
				if (get_quit_at_eof() && eof_displayed() && 
d1475 1
a1475 3
#if TAGS
			if (ntags())
			{
a1478 1
#endif
d1481 1
a1481 2
			if (edit_prev((int) number))
			{
a1487 1
#if TAGS
d1490 2
a1491 3
			tagfile = nexttag((int) number);
			if (tagfile == NULL)
			{
d1495 3
a1497 4
			if (edit(tagfile) == 0)
			{
				POSITION pos = tagsearch();
				if (pos != NULL_POSITION)
a1499 3
#else
			error("Command not available", NULL_PARG);
#endif
a1502 1
#if TAGS
d1505 2
a1506 3
			tagfile = prevtag((int) number);
			if (tagfile == NULL)
			{
d1510 3
a1512 4
			if (edit(tagfile) == 0)
			{
				POSITION pos = tagsearch();
				if (pos != NULL_POSITION)
a1514 3
#else
			error("Command not available", NULL_PARG);
#endif
d1523 1
a1523 1
			if (edit_index((int) number))
d1532 2
a1533 3
			if (new_ifile == NULL_IFILE)
			{
				bell();
d1536 1
a1536 2
			if (edit_ifile(new_ifile) != 0)
			{
d1564 1
a1564 1
			start_mca(A_FIRSTCMD, "+", (void*)NULL, 0);
d1572 1
a1572 3
#if SHELL_ESCAPE
			if (secure)
			{
a1578 4
#else
			error("Command not available", NULL_PARG);
			break;
#endif
d1608 1
a1608 3
#if PIPEC
			if (secure)
			{
d1614 2
a1615 1
			if (c == erase_char || c == erase2_char || c == kill_char)
a1624 4
#else
			error("Command not available", NULL_PARG);
			break;
#endif
d1637 1
a1637 1
					shift_count : sc_width / 2;
d1649 1
a1649 1
					shift_count : sc_width / 2;
d1660 1
a1660 2
			if (mca != A_PREFIX)
			{
d1663 1
a1663 1
					CF_QUIT_ON_ERASE);
d1673 1
a1673 1
			bell();
@


1.16
log
@Give more(1) its own help file, shorter than the one for less(1).
The helpfile itself was prepared by jmc@@, the glue by me.
OK millert@@ jmc@@
@
text
@a1026 1
	int until_hilite = 0;
@


1.15
log
@Remove support for the obsolete (non-POSIX) "more -d" prompt.
This was a local change that was only enabled when the LESS_IS_MORE
environment variable was set and not when invoked as "more".
OK shadchin@@ jmc@@
@
text
@d1495 1
a1495 1
			(void) edit(HELPFILE);
@


1.14
log
@Revert 1.11. That patch is not only not necessary, it is quite harmful now.

ok schwarze@@
@
text
@a56 1
extern int be_helpful;
a71 1
static char *help_prompt;
d751 1
a751 1
	p = help_prompt ? help_prompt : pr_string();
a759 2
		if (be_helpful && !help_prompt && strlen(p) + 40 < sc_width)
			putstr(" [Press space to continue, 'q' to quit.]");
a761 1
	help_prompt = NULL;
d1810 1
a1810 4
			if (be_helpful)
				help_prompt = "[Press 'h' for instructions.]";
			else
				bell();
@


1.13
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@a58 1
extern int quit_at_eof;
a1260 2
			if (less_is_more)
				quit_at_eof = OPT_ON;
@


1.12
log
@Deny requests to display interactive help unless we can be really sure
that they actually result from the user interactively asking for help.
Help requests originating from various other sources caused infinite loops.
OK millert@@ "better than getting stuck in a help loop (sweet irony ;)" jmc@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d38 1
d109 2
a110 2
	char *prompt;
	void *mlist;
d697 1
a697 1
	register char *p;
d976 40
d1033 1
d1261 1
a1261 17
			if (ch_getflags() & CH_HELPFILE)
				break;
			cmd_exec();
			jump_forw();
			ignore_eoi = 1;
			while (!sigs)
			{
				make_display();
				forward(1, 0, 0);
			}
			ignore_eoi = 0;
			/*
			 * This gets us back in "F mode" after processing 
			 * a non-abort signal (e.g. window-change).  
			 */
			if (sigs && !ABORT_SIGS())
				newaction = A_F_FOREVER;
d1266 4
a1486 1
#if !SMALL
d1490 1
@


1.11
log
@return the old behaviour for "more":
if you press F ^C, you would be left at a prompt at the end of the file.

ok nicm@@
@
text
@d1464 7
@


1.10
log
@Use volatile sig_atomic_t, not int, for the sigs variable.  Also
move the call to bell() out of u_interrupt() (a signal handler).
OK and with help from deraadt@@
@
text
@d58 2
d1237 2
@


1.9
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d25 1
a25 1
extern int sigs;
@


1.8
log
@Make the GNU_OPTIONS define actually do something (was a no-op)
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d24 1
a24 1
extern int erase_char, kill_char;
a25 1
extern int quit_at_eof;
a27 1
extern int hit_eof;
a33 1
extern int nohelp;
d55 2
a58 2
static char ungot[UNGOT_SIZE];
static char *ungotp = NULL;
d65 3
a67 1
static char optchar;
d71 1
d77 7
d87 1
a87 1
 * Move the cursor to lower left before executing a command.
d94 1
d96 2
a97 1
	lower_left();
d112 1
d130 5
d140 1
d154 5
d181 1
d219 6
d239 2
a240 2
		toggle_option(optchar, cbuf, optflag);
		optchar = '\0';
d293 68
a360 1
 * Add a character to a multi-character command.
d363 1
a363 1
mca_char(c)
d367 50
a416 2
	int flag;
	char buf[3];
d419 121
d544 1
a544 1
		 * Not in a multicharacter command.
d562 1
a562 1
		if ((c < '0' || c > '9') && 
d567 2
a568 1
			 * Treat as a normal command character.
d570 1
a570 1
			number = cmd_int();
d578 4
a581 157
		/*
		 * Special case for the TOGGLE_OPTION command.
		 * If the option letter which was entered is a
		 * single-char option, execute the command immediately,
		 * so user doesn't have to hit RETURN.
		 * If the first char is + or -, this indicates
		 * OPT_UNSET or OPT_SET respectively, instead of OPT_TOGGLE.
		 * "--" begins inputting a long option name.
		 */
		if (optchar == '\0' && len_cmdbuf() == 0)
		{
			flag = (optflag & ~OPT_NO_PROMPT);
#if GNU_OPTIONS
			if (flag == OPT_NO_TOGGLE)
			{
				switch (c)
				{
				case '_':
					/* "__" = long option name. */
					optgetname = TRUE;
					mca_opt_toggle();
					return (MCA_MORE);
				}
			} else
#endif
			{
				switch (c)
				{
				case '+':
					/* "-+" = UNSET. */
					optflag = (flag == OPT_UNSET) ?
						OPT_TOGGLE : OPT_UNSET;
					mca_opt_toggle();
					return (MCA_MORE);
				case '!':
					/* "-!" = SET */
					optflag = (flag == OPT_SET) ?
						OPT_TOGGLE : OPT_SET;
					mca_opt_toggle();
					return (MCA_MORE);
				case CONTROL('P'):
					optflag ^= OPT_NO_PROMPT;
					mca_opt_toggle();
					return (MCA_MORE);
#if GNU_OPTIONS
				case '-':
					/* "--" = long option name. */
					optgetname = TRUE;
					mca_opt_toggle();
					return (MCA_MORE);
#endif
				}
			}
		}
#if GNU_OPTIONS
		if (optgetname)
		{
			/*
			 * We're getting a long option name.
			 * See if we've matched an option name yet.
			 * If so, display the complete name and stop 
			 * accepting chars until user hits RETURN.
			 */
			struct loption *o;
			char *oname;
			int lc;

			if (c == '\n' || c == '\r')
			{
				/*
				 * When the user hits RETURN, make sure
				 * we've matched an option name, then
				 * pretend he just entered the equivalent
				 * option letter.
				 */
				if (optchar == '\0')
				{
					parg.p_string = get_cmdbuf();
					error("There is no --%s option", &parg);
					return (MCA_DONE);
				}
				optgetname = FALSE;
				cmd_reset();
				c = optchar;
			} else
			{
				if (optchar != '\0')
				{
					/*
					 * Already have a match for the name.
					 * Don't accept anything but erase/kill.
					 */
					if (c == erase_char || c == kill_char)
						return (MCA_DONE);
					return (MCA_MORE);
				}
				/*
				 * Add char to cmd buffer and try to match
				 * the option name.
				 */
				if (cmd_char(c) == CC_QUIT)
					return (MCA_DONE);
				p = get_cmdbuf();
				lc = islower(p[0]);
				o = findopt_name(&p, &oname, NULL);
				if (o != NULL)
				{
					/*
					 * Got a match.
					 * Remember the option letter and
					 * display the full option name.
					 */
					optchar = o->oletter;
					if (!lc && islower(optchar))
						optchar = toupper(optchar);
					cmd_reset();
					mca_opt_toggle();
					for (p = oname;  *p != '\0';  p++)
					{
						c = *p;
						if (!lc && islower(c))
							c = toupper(c);
						if (cmd_char(c) != CC_OK)
							return (MCA_DONE);
					}
				}
				return (MCA_MORE);
			}
		} else
#endif
		{
			if (c == erase_char || c == kill_char)
				break;
			if (optchar != '\0')
				/* We already have the option letter. */
				break;
		}

		optchar = c;
		if ((optflag & ~OPT_NO_PROMPT) != OPT_TOGGLE ||
		    single_char_option(c))
		{
			toggle_option(c, "", optflag);
			return (MCA_DONE);
		}
		/*
		 * Display a prompt appropriate for the option letter.
		 */
		if ((p = opt_prompt(c)) == NULL)
		{
			buf[0] = '-';
			buf[1] = c;
			buf[2] = '\0';
			p = buf;
		}
		start_mca(A_OPT_TOGGLE, p, (void*)NULL, 0);
		return (MCA_MORE);
d585 5
a589 13
		/*
		 * Special case for search commands.
		 * Certain characters as the first char of 
		 * the pattern have special meaning:
		 *	!  Toggle the NO_MATCH flag
		 *	*  Toggle the PAST_EOF flag
		 *	@@  Toggle the FIRST_FILE flag
		 */
		if (len_cmdbuf() > 0)
			/*
			 * Only works for the first char of the pattern.
			 */
			break;
d591 2
a592 28
		flag = 0;
		switch (c)
		{
		case CONTROL('E'): /* ignore END of file */
		case '*':
			flag = SRCH_PAST_EOF;
			break;
		case CONTROL('F'): /* FIRST file */
		case '@@':
			flag = SRCH_FIRST_FILE;
			break;
		case CONTROL('K'): /* KEEP position */
			flag = SRCH_NO_MOVE;
			break;
		case CONTROL('R'): /* Don't use REGULAR EXPRESSIONS */
			flag = SRCH_NO_REGEX;
			break;
		case CONTROL('N'): /* NOT match */
		case '!':
			flag = SRCH_NO_MATCH;
			break;
		}
		if (flag != 0)
		{
			search_type ^= flag;
			mca_search();
			return (MCA_MORE);
		}
d597 1
a597 2
	 * Any other multicharacter command
	 * is terminated by a newline.
d635 15
d672 2
a673 2
		int save_top_scroll;
		save_top_scroll = top_scroll;
d675 8
d685 1
d697 1
a697 1
	if (ungotp != NULL && ungotp > ungot)
d713 1
a713 1
	 * If the -E flag is set and we've hit EOF on the last file, quit.
d715 3
a717 2
	if ((quit_at_eof == OPT_ONPLUS || quit_if_one_screen) &&
	    hit_eof && next_ifile(curr_ifile) == NULL_IFILE)
d719 1
a719 2
	quit_if_one_screen = FALSE;
#if 0 /* This doesn't work well because some "te"s clear the screen. */
d721 1
a721 2
	 * If the -e flag is set and we've hit EOF on the last file,
	 * and the file is squished (shorter than the screen), quit.
d723 2
a724 1
	if (quit_at_eof && squished &&
d727 7
a734 1

d738 12
d751 1
d753 3
a755 1
	if (p == NULL)
d759 1
a759 1
		so_enter();
d763 1
a763 1
		so_exit();
d766 1
d790 2
a791 1
	if (ungotp == NULL)
d793 1
a793 1
		 * Normal case: no ungotten chars, so get one from the user.
d795 3
a797 3
		return (getchr());

	if (ungotp > ungot)
d799 1
a799 1
		 * Return the next ungotten char.
d801 7
a807 1
		return (*--ungotp);
d809 6
a814 16
	/*
	 * We have just run out of ungotten chars.
	 */
	ungotp = NULL;
	if (len_cmdbuf() == 0 || !empty_screen())
		return (getchr());
	/*
	 * Command is incomplete, so try to complete it.
	 */
	switch (mca)
	{
	case A_DIGIT:
		/*
		 * We have a number but no command.  Treat as #g.
		 */
		return ('g');
d816 7
a822 6
	case A_F_SEARCH:
	case A_B_SEARCH:
		/*
		 * We have "/string" but no newline.  Add the \n.
		 */
		return ('\n'); 
d824 2
a825 1
	default:
d827 1
a827 1
		 * Some other incomplete command.  Let user complete it.
d831 12
d853 6
a858 8
	if (ungotp == NULL)
		ungotp = ungot;
	if (ungotp >= ungot + sizeof(ungot))
	{
		error("ungetcc overflow", NULL_PARG);
		quit(QUIT_ERROR);
	}
	*ungotp++ = c;
d967 3
d1001 1
a1001 1
		optchar = '\0';
d1218 2
a1222 1
			hit_eof = 0;
d1224 2
d1227 1
d1266 1
a1266 8
			if (ch_getflags() & CH_CANSEEK)
			{
				ch_flush();
				clr_linenum();
#if HILITE_SEARCH
				clr_hilite();
#endif
			}
d1291 1
d1293 2
d1296 1
d1298 2
d1301 1
a1301 1
			jump_percent((int) number);
d1329 2
d1348 14
d1370 2
a1371 1
#define	DO_SEARCH()	if (number <= 0) number = 1;	\
d1401 11
d1454 1
d1458 1
a1458 3
			if (nohelp)
			{
				bell();
a1459 3
			}
			clear_bot();
			putstr(" help");
d1461 4
a1464 1
			help(0);
d1495 2
d1504 1
a1504 1
				error("Cannot edit file processed with LESSOPEN", 
a1505 1
				break;
d1538 2
a1539 1
				if (quit_at_eof && hit_eof)
d1619 2
d1683 2
d1687 2
a1688 2
			if (c == erase_char || c == kill_char ||
			    c == '\n' || c == '\r')
d1699 2
a1700 2
			if (c == erase_char || c == kill_char || 
			    c == '\n' || c == '\r')
d1702 1
d1715 1
a1715 1
			if (c == erase_char || c == kill_char)
@


1.7
log
@o go back to using a help file instead of embedding it in the binary
o deal with HELPFILE not being defined
o add a SMALL definition to make a smaller less for the boot floppies
This still needs to be pared down a bit for the SMALL case
@
text
@d162 1
d165 1
d325 1
d337 1
d357 1
d363 1
d367 1
d442 1
@


1.6
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d36 1
d607 1
a607 2
	    hit_eof && !(ch_getflags() & CH_HELPFILE) && 
	    next_ifile(curr_ifile) == NULL_IFILE)
a619 7
#if MSDOS_COMPILER==WIN32C
	/* 
	 * In Win32, display the file name in the window title.
	 */
	if (!(ch_getflags() & CH_HELPFILE))
		SetConsoleTitle(pr_expand("Less?f - %f.", 0));
#endif
a1074 2
			if (ch_getflags() & CH_HELPFILE)
				break;
a1182 2
			if (ch_getflags() & CH_HELPFILE)
				break;
a1199 11
			if (curr_ifile != NULL_IFILE && 
			    ch_getflags() & CH_HELPFILE)
			{
				/*
				 * Quit while viewing the help file
				 * just means return to viewing the
				 * previous file.
				 */
				if (edit_prev(1) == 0)
					break;
			}
d1283 3
a1285 1
			if (ch_getflags() & CH_HELPFILE)
d1287 3
d1291 1
a1291 1
			(void) edit(FAKE_HELPFILE);
a1321 2
			if (ch_getflags() & CH_HELPFILE)
				break;
d1364 1
a1364 2
				if (quit_at_eof && hit_eof && 
				    !(ch_getflags() & CH_HELPFILE))
a1443 2
			if (ch_getflags() & CH_HELPFILE)
				break;
a1505 2
			if (ch_getflags() & CH_HELPFILE)
				break;
@


1.5
log
@Only print the "helpful" prompt in -d mode if there is room on the
bottom line for it.  Closes PR 3189.
@
text
@a0 2
/*	$OpenBSD: command.c,v 1.4 2001/11/19 19:02:14 mpech Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d17 3
d27 2
a35 1
extern int nohelp;
d38 3
d46 2
a47 3
#if CMD_HISTORY
extern void *ml_search;
extern void *ml_examine;
d49 1
a49 7
extern void *ml_shell;
#endif
#else
/* No CMD_HISTORY */
#define	ml_search	NULL
#define	ml_examine	NULL
#define	ml_shell  	NULL
d56 1
d59 1
a59 3
public int helpprompt;

static char ungot[100];
d66 1
a66 1
static int number;		/* The number typed by the user */
d69 3
d86 1
d95 1
a95 1
start_mca(action, prompt, mlist)
d99 1
d102 1
a102 1
	clear_bot();
d104 1
a104 3
#if CMD_HISTORY
	set_mlist(mlist);
#endif
d124 1
a124 1
	clear_bot();
d126 2
d129 1
a129 2
		cmd_putstr("@@");

d131 5
a135 4
		cmd_putstr("*");

	if (search_type & SRCH_NOMATCH)
		cmd_putstr("!");
d141 34
a174 3
#if CMD_HISTORY
	set_mlist(ml_search);
#endif
d183 1
a183 1
	char *cbuf;
d192 1
a192 1
		multi_search(cbuf, number);
d212 1
a212 1
		match_brac(cbuf[0], cbuf[1], 1, number);
d215 1
a215 1
		match_brac(cbuf[1], cbuf[0], 0, number);
d219 2
d222 4
d242 2
d245 1
a245 1
			lsystem("");
d247 1
a247 2
			lsystem(shellcmd);
		error("!done", NULL_PARG);
d252 2
d271 1
d296 1
a296 1
		  editchar(c, EC_PEEK|EC_NOHISTORY|EC_NOCOMPLETE) == A_INVALID)
d317 1
d319 43
a361 3
		if (c == erase_char || c == kill_char)
			break;
		if (optchar != '\0' && optchar != '+' && optchar != '-')
d363 27
a389 14
			 * We already have the option letter.
			 */
			break;
		switch (c)
		{
		case '+':
			optflag = OPT_UNSET;
			break;
		case '-':
			optflag = OPT_SET;
			break;
		default:
			optchar = c;
			if (optflag != OPT_TOGGLE || single_char_option(c))
d391 41
a431 2
				toggle_option(c, "", optflag);
				return (MCA_DONE);
d433 7
a439 1
			break;
d441 4
a444 1
		if (optchar == '+' || optchar == '-')
d446 2
a447 2
			optchar = c;
			break;
d459 1
a459 1
		start_mca(A_OPT_TOGGLE, p, (void*)NULL);
d468 1
a468 1
		 *	!  Toggle the NOMATCH flag
d481 3
a483 2
		case '!':
			flag = SRCH_NOMATCH;
d485 1
d489 9
a497 2
		case '*':
			flag = SRCH_PAST_EOF;
d521 1
d549 1
a549 1
 * Display the appropriate prompt.
d552 1
a552 1
prompt()
a553 11
	char *p;

	if (ungotp != NULL && ungotp > ungot)
	{
		/*
		 * No prompt necessary if commands are from 
		 * ungotten chars rather than from the user.
		 */
		return;
	}

d577 24
d605 2
a606 1
	if (quit_at_eof == OPT_ONPLUS && hit_eof && 
d609 10
d620 7
d630 6
a635 2
	clear_bot();
	if (helpprompt) {
d637 3
a639 1
		putstr("[Press 'h' for instructions.]");
a640 13
		helpprompt = 0;
	} else {
		p = pr_string();
		if (p == NULL)
			putchr(':');
		else
		{
			so_enter();
			putstr(p);
			if (be_helpful && strlen(p) + 40 < sc_width)
				putstr(" [Press space to continue, 'q' to quit.]");
			so_exit();
		}
d642 1
d645 3
d654 1
a654 1
	error("less  version %s", &parg);
d736 1
a736 1
	char *p;
d752 1
a752 1
	int nomore;
d757 1
a757 1
	save_ifile = curr_ifile;
d770 2
d773 1
d780 9
a788 1
		if ((n = search(search_type, pattern, n)) == 0)
d792 1
d794 1
d833 1
a833 2
		if (edit_ifile(save_ifile))
			quit(QUIT_ERROR);
d844 4
a847 3
	int c;
	int action;
	char *cbuf;
d849 1
a849 1
	char *s;
d852 3
d858 1
d876 7
a882 1
			
d890 2
a891 1
		c = getcc();
d897 38
a934 7
		/*
		 * If we are in a multicharacter command, call mca_char.
		 * Otherwise we call fcmd_decode to determine the
		 * action to be performed.
		 */
		if (mca)
			switch (mca_char(c))
a935 1
			case MCA_MORE:
d937 5
a941 1
				 * Need another character.
d943 5
a947 9
				c = getcc();
				goto again;
			case MCA_DONE:
				/*
				 * Command has been handled by mca_char.
				 * Start clean with a prompt.
				 */
				continue;
			case NO_MCA:
d949 6
a954 2
				 * Not a multi-char command
				 * (at least, not anymore).
d956 3
a958 1
				break;
d960 2
a961 6

		/*
		 * Decode the command character and decide what to do.
		 */
		if (mca)
		{
d963 5
a967 22
			 * We're in a multichar command.
			 * Add the character to the command buffer
			 * and display it on the screen.
			 * If the user backspaces past the start 
			 * of the line, abort the command.
			 */
			if (cmd_char(c) == CC_QUIT || len_cmdbuf() == 0)
				continue;
			cbuf = get_cmdbuf();
		} else
		{
			/*
			 * Don't use cmd_char if we're starting fresh
			 * at the beginning of a command, because we
			 * don't want to echo the command until we know
			 * it is a multichar command.  We also don't
			 * want erase_char/kill_char to be treated
			 * as line editing characters.
			 */
			tbuf[0] = c;
			tbuf[1] = '\0';
			cbuf = tbuf;
a968 8
		s = NULL;
		action = fcmd_decode(cbuf, &s);
		/*
		 * If an "extra" string was returned,
		 * process it as a string of command characters.
		 */
		if (s != NULL)
			ungetsc(s);
d983 1
a983 1
			start_mca(A_DIGIT, ":", (void*)NULL);
d991 1
a991 1
				swindow = number;
d1000 3
a1002 1
			forward(number, 0, 1);
d1010 1
a1010 1
				swindow = number;
d1019 1
a1019 1
			backward(number, 0, 1);
d1029 3
a1031 1
			forward(number, 0, 0);
d1041 1
a1041 1
			backward(number, 0, 0);
d1051 3
a1053 1
			forward(number, 1, 0);
d1063 1
a1063 1
			backward(number, 1, 0);
d1066 12
d1082 2
d1088 1
a1088 1
			while (!ABORT_SIGS())
d1091 6
d1105 1
a1105 1
				wscroll = number;
d1107 2
d1118 1
a1118 1
				wscroll = number;
d1132 3
d1164 1
a1164 1
			jump_percent(number);
d1185 1
a1185 1
			jump_line_loc((POSITION)number, jump_sline);
d1192 2
d1198 1
a1198 1
			
d1211 13
d1225 1
d1233 1
a1233 1
			multi_search((char *)NULL, number);
d1305 1
a1305 3
			if (nohelp)
			{
				bell();
a1306 3
			}
			clear_bot();
			putstr(" help");
d1308 1
a1308 1
			help(0);
d1316 6
a1321 1
			start_mca(A_EXAMINE, "Examine: ", ml_examine);
d1334 7
d1352 1
d1356 2
d1359 1
d1361 1
a1361 8
			lsystem(pr_expand(editproto, 0));
			/*
			 * Re-edit the file, since data may have changed.
			 * Some editors even recreate the file, so flushing
			 * buffers is not sufficient.
			 */
			if (edit_ifile(curr_ifile))
				quit(QUIT_ERROR);
d1372 7
d1381 1
a1381 1
			if (edit_next(number))
d1383 2
a1384 1
				if (quit_at_eof && hit_eof)
d1395 7
d1404 1
a1404 1
			if (edit_prev(number))
d1411 42
d1459 1
a1459 1
			if (edit_index(number))
d1463 18
a1481 1
			start_mca(A_OPT_TOGGLE, "-", (void*)NULL);
d1483 2
d1492 3
a1494 1
			start_mca(A_DISP_OPTION, "_", (void*)NULL);
d1496 1
a1496 4
			if (c == erase_char || c == kill_char)
				break;
			toggle_option(c, "", OPT_NO_TOGGLE);
			break;
d1502 1
a1502 1
			start_mca(A_FIRSTCMD, "+", (void*)NULL);
d1511 6
a1516 1
			start_mca(A_SHELL, "!", ml_shell);
d1528 3
a1530 1
			start_mca(A_SETMARK, "mark: ", (void*)NULL);
d1542 1
a1542 1
			start_mca(A_GOMARK, "goto mark: ", (void*)NULL);
d1552 6
a1557 1
			start_mca(A_PIPE, "|mark: ", (void*)NULL);
d1566 1
a1566 1
			start_mca(A_PIPE, "!", ml_shell);
d1576 1
a1576 1
			start_mca(action, "Brackets: ", (void*)NULL);
d1580 22
a1609 1
				start_mca(A_PREFIX, " ", (void*)NULL);
d1611 2
d1623 1
a1623 1
				helpprompt = 1;
@


1.4
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: command.c,v 1.3 2001/01/29 01:58:00 niklas Exp $	*/
d474 1
a474 1
			if (be_helpful)
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d166 1
a166 1
	register char *cbuf;
d415 1
a415 1
	register char *p;
d569 1
a569 1
	register char *p;
d585 1
a585 1
	register int nomore;
d665 3
a667 3
	register int c;
	register int action;
	register char *cbuf;
@


1.2
log
@Incorporate less modifications for more and our bug fixes from previous
version.
@
text
@d1 2
@


1.1
log
@Initial revision
@
text
@d72 3
d459 1
a459 5
	p = pr_string();
	if (p == NULL)
		putchr(':');
	else
	{
d461 1
a461 1
		putstr(p);
d463 13
d1261 4
a1264 1
			bell();
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
a32 3
#if MSDOS_COMPILER==WIN32C
#include <windows.h>
#endif
a39 2
extern int quit_if_one_screen;
extern int squished;
d47 1
a49 3
extern int secure;
extern int hshift;
extern int show_attn;
d55 3
a57 2
extern void constant *ml_search;
extern void constant *ml_examine;
d59 7
a65 1
extern void constant *ml_shell;
a71 1
extern int shift_count;
d73 1
a73 1
static char ungot[UNGOT_SIZE];
d80 1
a80 1
static LINENUM number;		/* The number typed by the user */
a82 2
static int optgetname;
static POSITION bottompos;
a96 1
	clear_attn();
d105 1
a105 1
start_mca(action, prompt, mlist, cmdflags)
a108 1
	int cmdflags;
d111 1
a111 1
	clear_cmd();
d113 3
a115 1
	set_mlist(mlist, cmdflags);
d135 1
a135 1
	clear_cmd();
a136 2
	if (search_type & SRCH_NO_MATCH)
		cmd_putstr("Non-match ");
d138 2
a139 1
		cmd_putstr("First-file ");
d141 4
a144 5
		cmd_putstr("EOF-ignore ");
	if (search_type & SRCH_NO_MOVE)
		cmd_putstr("Keep-pos ");
	if (search_type & SRCH_NO_REGEX)
		cmd_putstr("Regex-off ");
d150 3
a152 34
	set_mlist(ml_search, 0);
}

/*
 * Set up the display to start a new toggle-option command.
 */
	static void
mca_opt_toggle()
{
	int no_prompt;
	int flag;
	char *dash;
	
	no_prompt = (optflag & OPT_NO_PROMPT);
	flag = (optflag & ~OPT_NO_PROMPT);
	dash = (flag == OPT_NO_TOGGLE) ? "_" : "-";

	mca = A_OPT_TOGGLE;
	clear_cmd();
	cmd_putstr(dash);
	if (optgetname)
		cmd_putstr(dash);
	if (no_prompt)
		cmd_putstr("(P)");
	switch (flag)
	{
	case OPT_UNSET:
		cmd_putstr("+");
		break;
	case OPT_SET:
		cmd_putstr("!");
		break;
	}
	set_mlist(NULL, 0);
d170 1
a170 1
		multi_search(cbuf, (int) number);
d190 1
a190 1
		match_brac(cbuf[0], cbuf[1], 1, (int) number);
d193 1
a193 1
		match_brac(cbuf[1], cbuf[0], 0, (int) number);
a196 2
		if (secure)
			break;
a197 4
#if TAGS
		/* If tag structure is loaded then clean it up. */
		cleantags();
#endif
a213 2
		if (secure)
			break;
d215 1
a215 1
			lsystem("", "!done");
d217 2
a218 1
			lsystem(shellcmd, "!done");
a222 2
		if (secure)
			break;
a239 1
	PARG parg;
d264 1
a264 1
		  editchar(c, EC_PEEK|EC_NOHISTORY|EC_NOCOMPLETE|EC_NORIGHTLEFT) == A_INVALID)
a284 1
		 * "--" begins inputting a long option name.
d286 8
a293 1
		if (optchar == '\0' && len_cmdbuf() == 0)
d295 9
a303 2
			flag = (optflag & ~OPT_NO_PROMPT);
			if (flag == OPT_NO_TOGGLE)
d305 2
a306 34
				switch (c)
				{
				case '_':
					/* "__" = long option name. */
					optgetname = TRUE;
					mca_opt_toggle();
					return (MCA_MORE);
				}
			} else
			{
				switch (c)
				{
				case '+':
					/* "-+" = UNSET. */
					optflag = (flag == OPT_UNSET) ?
						OPT_TOGGLE : OPT_UNSET;
					mca_opt_toggle();
					return (MCA_MORE);
				case '!':
					/* "-!" = SET */
					optflag = (flag == OPT_SET) ?
						OPT_TOGGLE : OPT_SET;
					mca_opt_toggle();
					return (MCA_MORE);
				case CONTROL('P'):
					optflag ^= OPT_NO_PROMPT;
					mca_opt_toggle();
					return (MCA_MORE);
				case '-':
					/* "--" = long option name. */
					optgetname = TRUE;
					mca_opt_toggle();
					return (MCA_MORE);
				}
d308 1
d310 1
a310 1
		if (optgetname)
d312 2
a313 86
			/*
			 * We're getting a long option name.
			 * See if we've matched an option name yet.
			 * If so, display the complete name and stop 
			 * accepting chars until user hits RETURN.
			 */
			struct loption *o;
			char *oname;
			int lc;

			if (c == '\n' || c == '\r')
			{
				/*
				 * When the user hits RETURN, make sure
				 * we've matched an option name, then
				 * pretend he just entered the equivalent
				 * option letter.
				 */
				if (optchar == '\0')
				{
					parg.p_string = get_cmdbuf();
					error("There is no --%s option", &parg);
					return (MCA_DONE);
				}
				optgetname = FALSE;
				cmd_reset();
				c = optchar;
			} else
			{
				if (optchar != '\0')
				{
					/*
					 * Already have a match for the name.
					 * Don't accept anything but erase/kill.
					 */
					if (c == erase_char || c == kill_char)
						return (MCA_DONE);
					return (MCA_MORE);
				}
				/*
				 * Add char to cmd buffer and try to match
				 * the option name.
				 */
				if (cmd_char(c) == CC_QUIT)
					return (MCA_DONE);
				p = get_cmdbuf();
				lc = islower(p[0]);
				o = findopt_name(&p, &oname, NULL);
				if (o != NULL)
				{
					/*
					 * Got a match.
					 * Remember the option letter and
					 * display the full option name.
					 */
					optchar = o->oletter;
					if (!lc && islower(optchar))
						optchar = toupper(optchar);
					cmd_reset();
					mca_opt_toggle();
					for (p = oname;  *p != '\0';  p++)
					{
						c = *p;
						if (!lc && islower(c))
							c = toupper(c);
						if (cmd_char(c) != CC_OK)
							return (MCA_DONE);
					}
				}
				return (MCA_MORE);
			}
		} else
		{
			if (c == erase_char || c == kill_char)
				break;
			if (optchar != '\0')
				/* We already have the option letter. */
				break;
		}

		optchar = c;
		if ((optflag & ~OPT_NO_PROMPT) != OPT_TOGGLE ||
		    single_char_option(c))
		{
			toggle_option(c, "", optflag);
			return (MCA_DONE);
d325 1
a325 1
		start_mca(A_OPT_TOGGLE, p, (void*)NULL, 0);
d334 1
a334 1
		 *	!  Toggle the NO_MATCH flag
d347 2
a348 3
		case CONTROL('E'): /* ignore END of file */
		case '*':
			flag = SRCH_PAST_EOF;
a349 1
		case CONTROL('F'): /* FIRST file */
d353 2
a354 9
		case CONTROL('K'): /* KEEP position */
			flag = SRCH_NO_MOVE;
			break;
		case CONTROL('R'): /* Don't use REGULAR EXPRESSIONS */
			flag = SRCH_NO_REGEX;
			break;
		case CONTROL('N'): /* NOT match */
		case '!':
			flag = SRCH_NO_MATCH;
a377 1

d405 1
a405 1
 * Make sure the screen is displayed.
d408 1
a408 1
make_display()
d410 11
a443 24
}

/*
 * Display the appropriate prompt.
 */
	static void
prompt()
{
	register char *p;

	if (ungotp != NULL && ungotp > ungot)
	{
		/*
		 * No prompt necessary if commands are from 
		 * ungotten chars rather than from the user.
		 */
		return;
	}

	/*
	 * Make sure the screen is displayed.
	 */
	make_display();
	bottompos = position(BOTTOM_PLUS_ONE);
d448 1
a448 2
	if ((quit_at_eof == OPT_ONPLUS || quit_if_one_screen) &&
	    hit_eof && !(ch_getflags() & CH_HELPFILE) && 
a450 10
	quit_if_one_screen = FALSE;
#if 0 /* This doesn't work well because some "te"s clear the screen. */
	/*
	 * If the -e flag is set and we've hit EOF on the last file,
	 * and the file is squished (shorter than the screen), quit.
	 */
	if (quit_at_eof && squished &&
	    next_ifile(curr_ifile) == NULL_IFILE)
		quit(QUIT_OK);
#endif
a451 7
#if MSDOS_COMPILER==WIN32C
	/* 
	 * In Win32, display the file name in the window title.
	 */
	if (!(ch_getflags() & CH_HELPFILE))
		SetConsoleTitle(pr_expand("Less?f - %f.", 0));
#endif
d455 1
a455 1
	clear_cmd();
a466 3
/*
 * Display the less version message.
 */
d473 1
a473 1
	error("less %s", &parg);
d576 1
a576 1
	save_ifile = save_curr_ifile();
a588 2
		{
			unsave_ifile(save_ifile);
a589 1
		}
d596 1
a596 9
		n = search(search_type, pattern, n);
		/*
		 * The SRCH_NO_MOVE flag doesn't "stick": it gets cleared
		 * after being used once.  This allows "n" to work after
		 * using a /@@@@ search.
		 */
		search_type &= ~SRCH_NO_MOVE;
		if (n == 0)
		{
a599 1
			unsave_ifile(save_ifile);
a600 1
		}
d639 2
a640 1
		reedit_ifile(save_ifile);
a653 1
	int newaction;
d655 1
a655 1
	char *extra;
a657 3
	IFILE old_ifile;
	IFILE new_ifile;
	char *tagfile;
a660 1
	newaction = A_NOACTION;
d678 1
a678 7

		/*
		 * See if window size changed, for systems that don't
		 * generate SIGWINCH.
		 */
		check_winch();

d686 1
a686 2
		if (newaction == A_NOACTION)
			c = getcc();
d692 7
a698 38
		if (newaction != A_NOACTION)
		{
			action = newaction;
			newaction = A_NOACTION;
		} else
		{
			/*
			 * If we are in a multicharacter command, call mca_char.
			 * Otherwise we call fcmd_decode to determine the
			 * action to be performed.
			 */
			if (mca)
				switch (mca_char(c))
				{
				case MCA_MORE:
					/*
					 * Need another character.
					 */
					c = getcc();
					goto again;
				case MCA_DONE:
					/*
					 * Command has been handled by mca_char.
					 * Start clean with a prompt.
					 */
					continue;
				case NO_MCA:
					/*
					 * Not a multi-char command
					 * (at least, not anymore).
					 */
					break;
				}

			/*
			 * Decode the command character and decide what to do.
			 */
			if (mca)
d700 1
d702 1
a702 5
				 * We're in a multichar command.
				 * Add the character to the command buffer
				 * and display it on the screen.
				 * If the user backspaces past the start 
				 * of the line, abort the command.
d704 9
a712 5
				if (cmd_char(c) == CC_QUIT || len_cmdbuf() == 0)
					continue;
				cbuf = get_cmdbuf();
			} else
			{
d714 2
a715 6
				 * Don't use cmd_char if we're starting fresh
				 * at the beginning of a command, because we
				 * don't want to echo the command until we know
				 * it is a multichar command.  We also don't
				 * want erase_char/kill_char to be treated
				 * as line editing characters.
d717 1
a717 3
				tbuf[0] = c;
				tbuf[1] = '\0';
				cbuf = tbuf;
d719 6
a724 2
			extra = NULL;
			action = fcmd_decode(cbuf, &extra);
d726 22
a747 5
			 * If an "extra" string was returned,
			 * process it as a string of command characters.
			 */
			if (extra != NULL)
				ungetsc(extra);
d749 8
d771 1
a771 1
			start_mca(A_DIGIT, ":", (void*)NULL, CF_QUIT_ON_ERASE);
d779 1
a779 1
				swindow = (int) number;
d788 1
a788 3
			if (show_attn)
				set_attnpos(bottompos);
			forward((int) number, 0, 1);
d796 1
a796 1
				swindow = (int) number;
d805 1
a805 1
			backward((int) number, 0, 1);
d815 1
a815 3
			if (show_attn == OPT_ONPLUS && number > 1)
				set_attnpos(bottompos);
			forward((int) number, 0, 0);
d825 1
a825 1
			backward((int) number, 0, 0);
d835 1
a835 3
			if (show_attn == OPT_ONPLUS && number > 1)
				set_attnpos(bottompos);
			forward((int) number, 1, 0);
d845 1
a845 1
			backward((int) number, 1, 0);
a847 12
		case A_FF_SCREEN:
			/*
			 * Force forward one screen.
			 */
			if (number <= 0)
				number = get_swindow();
			cmd_exec();
			if (show_attn == OPT_ONPLUS)
				set_attnpos(bottompos);
			forward((int) number, 1, 0);
			break;

a851 2
			if (ch_getflags() & CH_HELPFILE)
				break;
d856 1
a856 1
			while (!sigs)
a858 6
			/*
			 * This gets us back in "F mode" after processing 
			 * a non-abort signal (e.g. window-change).  
			 */
			if (sigs && !ABORT_SIGS())
				newaction = A_F_FOREVER;
d867 1
a867 1
				wscroll = (int) number;
a868 2
			if (show_attn == OPT_ONPLUS)
				set_attnpos(bottompos);
d878 1
a878 1
				wscroll = (int) number;
a891 3
#if HILITE_SEARCH
				clr_hilite();
#endif
d921 1
a921 1
			jump_percent((int) number);
d942 1
a942 1
			jump_line_loc((POSITION) number, jump_sline);
a948 2
			if (ch_getflags() & CH_HELPFILE)
				break;
d953 1
a953 1

a965 13
			if (curr_ifile != NULL_IFILE && 
			    ch_getflags() & CH_HELPFILE)
			{
				/*
				 * Quit while viewing the help file
				 * just means return to viewing the
				 * previous file.
				 */
				if (edit_prev(1) == 0)
					break;
			}
			if (extra != NULL)
				quit(*extra);
a966 1
			break;
d974 1
a974 1
			multi_search((char *)NULL, (int) number);
d1046 3
a1048 1
			if (ch_getflags() & CH_HELPFILE)
d1050 3
d1054 1
a1054 1
			(void) edit(FAKE_HELPFILE);
d1062 1
a1062 6
			if (secure)
			{
				error("Command not available", NULL_PARG);
				break;
			}
			start_mca(A_EXAMINE, "Examine: ", ml_examine, 0);
a1074 7
			if (secure)
			{
				error("Command not available", NULL_PARG);
				break;
			}
			if (ch_getflags() & CH_HELPFILE)
				break;
a1085 1
			start_mca(A_SHELL, "!", ml_shell, 0);
a1088 2
			 * (Make sure the screen is displayed so the
			 * expansion of "+%lm" works.)
a1089 1
			make_display();
d1091 8
a1098 1
			lsystem(pr_expand(editproto, 0), (char*)NULL);
a1108 7
#if TAGS
			if (ntags())
			{
				error("No next file", NULL_PARG);
				break;
			}
#endif
d1111 1
a1111 1
			if (edit_next((int) number))
d1113 1
a1113 2
				if (quit_at_eof && hit_eof && 
				    !(ch_getflags() & CH_HELPFILE))
a1123 7
#if TAGS
			if (ntags())
			{
				error("No previous file", NULL_PARG);
				break;
			}
#endif
d1126 1
a1126 1
			if (edit_prev((int) number))
a1132 42
		case A_NEXT_TAG:
#if TAGS
			if (number <= 0)
				number = 1;
			tagfile = nexttag((int) number);
			if (tagfile == NULL)
			{
				error("No next tag", NULL_PARG);
				break;
			}
			if (edit(tagfile) == 0)
			{
				POSITION pos = tagsearch();
				if (pos != NULL_POSITION)
					jump_loc(pos, jump_sline);
			}
#else
			error("Command not available", NULL_PARG);
#endif
			break;

		case A_PREV_TAG:
#if TAGS
			if (number <= 0)
				number = 1;
			tagfile = prevtag((int) number);
			if (tagfile == NULL)
			{
				error("No previous tag", NULL_PARG);
				break;
			}
			if (edit(tagfile) == 0)
			{
				POSITION pos = tagsearch();
				if (pos != NULL_POSITION)
					jump_loc(pos, jump_sline);
			}
#else
			error("Command not available", NULL_PARG);
#endif
			break;

d1139 1
a1139 1
			if (edit_index((int) number))
a1142 18
		case A_REMOVE_FILE:
			if (ch_getflags() & CH_HELPFILE)
				break;
			old_ifile = curr_ifile;
			new_ifile = getoff_ifile(curr_ifile);
			if (new_ifile == NULL_IFILE)
			{
				bell();
				break;
			}
			if (edit_ifile(new_ifile) != 0)
			{
				reedit_ifile(old_ifile);
				break;
			}
			del_ifile(old_ifile);
			break;

d1144 1
a1145 2
			optgetname = FALSE;
			mca_opt_toggle();
d1153 1
a1153 3
			optflag = OPT_NO_TOGGLE;
			optgetname = FALSE;
			mca_opt_toggle();
d1155 4
a1158 1
			goto again;
d1164 1
a1164 1
			start_mca(A_FIRSTCMD, "+", (void*)NULL, 0);
d1173 1
a1173 6
			if (secure)
			{
				error("Command not available", NULL_PARG);
				break;
			}
			start_mca(A_SHELL, "!", ml_shell, 0);
d1185 1
a1185 3
			if (ch_getflags() & CH_HELPFILE)
				break;
			start_mca(A_SETMARK, "mark: ", (void*)NULL, 0);
d1197 1
a1197 1
			start_mca(A_GOMARK, "goto mark: ", (void*)NULL, 0);
d1207 1
a1207 6
			if (secure)
			{
				error("Command not available", NULL_PARG);
				break;
			}
			start_mca(A_PIPE, "|mark: ", (void*)NULL, 0);
d1216 1
a1216 1
			start_mca(A_PIPE, "!", ml_shell, 0);
d1226 1
a1226 1
			start_mca(action, "Brackets: ", (void*)NULL, 0);
a1229 22
		case A_LSHIFT:
			if (number > 0)
				shift_count = number;
			else
				number = (shift_count > 0) ?
					shift_count : sc_width / 2;
			if (number > hshift)
				number = hshift;
			hshift -= number;
			screen_trashed = 1;
			break;

		case A_RSHIFT:
			if (number > 0)
				shift_count = number;
			else
				number = (shift_count > 0) ?
					shift_count : sc_width / 2;
			hshift += number;
			screen_trashed = 1;
			break;

d1238 1
a1239 2
				start_mca(A_PREFIX, " ", (void*)NULL,
					CF_QUIT_ON_ERASE);
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d24 1
a24 1
extern int erase_char, erase2_char, kill_char;
d26 1
d29 1
a56 2
extern int oldbot;
extern int forw_prompt;
d58 2
d66 1
a66 3
static long fraction;		/* The fractional part of the number */
static struct loption *curropt;
static int opt_lower;
a69 1
static int save_hshift;
a73 7
struct ungot {
	struct ungot *ug_next;
	char ug_char;
};
static struct ungot* ungot = NULL;
static int unget_end = 0;

d77 1
a77 1
 * Move the cursor to start of prompt line before executing a command.
a83 1
#if HILITE_SEARCH
d85 1
a85 2
#endif
	clear_bot();
a99 1
	clear_bot();
a116 5
#if HILITE_SEARCH
	if (search_type & SRCH_FILTER)
		mca = A_FILTER;
	else 
#endif
a121 1
	clear_bot();
a134 5
#if HILITE_SEARCH
	if (search_type & SRCH_FILTER)
		cmd_putstr("&/");
	else 
#endif
a156 1
	clear_bot();
a191 6
#if HILITE_SEARCH
	case A_FILTER:
		search_type ^= SRCH_NO_MATCH;
		set_filter_pattern(cbuf, search_type);
		break;
#endif
d206 2
a207 2
		toggle_option(curropt, opt_lower, cbuf, optflag);
		curropt = NULL;
d260 1
a260 1
 * Is a character an erase or kill char?
d263 1
a263 63
is_erase_char(c)
	int c;
{
	return (c == erase_char || c == erase2_char || c == kill_char);
}

/*
 * Handle the first char of an option (after the initial dash).
 */
	static int
mca_opt_first_char(c)
    int c;
{
	int flag = (optflag & ~OPT_NO_PROMPT);
	if (flag == OPT_NO_TOGGLE)
	{
		switch (c)
		{
		case '_':
			/* "__" = long option name. */
			optgetname = TRUE;
			mca_opt_toggle();
			return (MCA_MORE);
		}
	} else
	{
		switch (c)
		{
		case '+':
			/* "-+" = UNSET. */
			optflag = (flag == OPT_UNSET) ?
				OPT_TOGGLE : OPT_UNSET;
			mca_opt_toggle();
			return (MCA_MORE);
		case '!':
			/* "-!" = SET */
			optflag = (flag == OPT_SET) ?
				OPT_TOGGLE : OPT_SET;
			mca_opt_toggle();
			return (MCA_MORE);
		case CONTROL('P'):
			optflag ^= OPT_NO_PROMPT;
			mca_opt_toggle();
			return (MCA_MORE);
		case '-':
			/* "--" = long option name. */
			optgetname = TRUE;
			mca_opt_toggle();
			return (MCA_MORE);
		}
	}
	/* Char was not handled here. */
	return (NO_MCA);
}

/*
 * Add a char to a long option name.
 * See if we've got a match for an option name yet.
 * If so, display the complete name and stop 
 * accepting chars until user hits RETURN.
 */
	static int
mca_opt_nonfirst_char(c)
d267 2
a268 49
	char *oname;

	if (curropt != NULL)
	{
		/*
		 * Already have a match for the name.
		 * Don't accept anything but erase/kill.
		 */
		if (is_erase_char(c))
			return (MCA_DONE);
		return (MCA_MORE);
	}
	/*
	 * Add char to cmd buffer and try to match
	 * the option name.
	 */
	if (cmd_char(c) == CC_QUIT)
		return (MCA_DONE);
	p = get_cmdbuf();
	opt_lower = ASCII_IS_LOWER(p[0]);
	curropt = findopt_name(&p, &oname, NULL);
	if (curropt != NULL)
	{
		/*
		 * Got a match.
		 * Remember the option and
		 * display the full option name.
		 */
		cmd_reset();
		mca_opt_toggle();
		for (p = oname;  *p != '\0';  p++)
		{
			c = *p;
			if (!opt_lower && ASCII_IS_LOWER(c))
				c = ASCII_TO_UPPER(c);
			if (cmd_char(c) != CC_OK)
				return (MCA_DONE);
		}
	}
	return (MCA_MORE);
}

/*
 * Handle a char of an option toggle command.
 */
	static int
mca_opt_char(c)
	int c;
{
a270 119
	/*
	 * This may be a short option (single char),
	 * or one char of a long option name,
	 * or one char of the option parameter.
	 */
	if (curropt == NULL && len_cmdbuf() == 0)
	{
		int ret = mca_opt_first_char(c);
		if (ret != NO_MCA)
			return (ret);
	}
	if (optgetname)
	{
		/* We're getting a long option name.  */
		if (c != '\n' && c != '\r')
			return (mca_opt_nonfirst_char(c));
		if (curropt == NULL)
		{
			parg.p_string = get_cmdbuf();
			error("There is no --%s option", &parg);
			return (MCA_DONE);
		}
		optgetname = FALSE;
		cmd_reset();
	} else
	{
		if (is_erase_char(c))
			return (NO_MCA);
		if (curropt != NULL)
			/* We're getting the option parameter. */
			return (NO_MCA);
		curropt = findopt(c);
		if (curropt == NULL)
		{
			parg.p_string = propt(c);
			error("There is no %s option", &parg);
			return (MCA_DONE);
		}
	}
	/*
	 * If the option which was entered does not take a 
	 * parameter, toggle the option immediately,
	 * so user doesn't have to hit RETURN.
	 */
	if ((optflag & ~OPT_NO_PROMPT) != OPT_TOGGLE ||
	    !opt_has_param(curropt))
	{
		toggle_option(curropt, ASCII_IS_LOWER(c), "", optflag);
		return (MCA_DONE);
	}
	/*
	 * Display a prompt appropriate for the option parameter.
	 */
	start_mca(A_OPT_TOGGLE, opt_prompt(curropt), (void*)NULL, 0);
	return (MCA_MORE);
}

/*
 * Handle a char of a search command.
 */
	static int
mca_search_char(c)
	int c;
{
	int flag = 0;

	/*
	 * Certain characters as the first char of 
	 * the pattern have special meaning:
	 *	!  Toggle the NO_MATCH flag
	 *	*  Toggle the PAST_EOF flag
	 *	@@  Toggle the FIRST_FILE flag
	 */
	if (len_cmdbuf() > 0)
		return (NO_MCA);

	switch (c)
	{
	case CONTROL('E'): /* ignore END of file */
	case '*':
		if (mca != A_FILTER)
			flag = SRCH_PAST_EOF;
		break;
	case CONTROL('F'): /* FIRST file */
	case '@@':
		if (mca != A_FILTER)
			flag = SRCH_FIRST_FILE;
		break;
	case CONTROL('K'): /* KEEP position */
		if (mca != A_FILTER)
			flag = SRCH_NO_MOVE;
		break;
	case CONTROL('R'): /* Don't use REGULAR EXPRESSIONS */
		flag = SRCH_NO_REGEX;
		break;
	case CONTROL('N'): /* NOT match */
	case '!':
		flag = SRCH_NO_MATCH;
		break;
	}

	if (flag != 0)
	{
		search_type ^= flag;
		mca_search();
		return (MCA_MORE);
	}
	return (NO_MCA);
}

/*
 * Handle a character of a multi-character command.
 */
	static int
mca_char(c)
	int c;
{
	int ret;

d275 1
a275 1
		 * We're not in a multicharacter command.
d293 1
a293 1
		if (!((c >= '0' && c <= '9') || c == '.') && 
d298 1
a298 2
			 * End the number and treat this char 
			 * as a normal command character.
d300 1
a300 1
			number = cmd_int(&fraction);
d308 151
a458 4
		ret = mca_opt_char(c);
		if (ret != NO_MCA)
			return (ret);
		break;
d462 13
a474 5
	case A_FILTER:
		ret = mca_search_char(c);
		if (ret != NO_MCA)
			return (ret);
		break;
d476 28
a503 2
	default:
		/* Other multicharacter command. */
d508 2
a509 1
	 * The multichar command is terminated by a newline.
a546 15
 * Discard any buffered file data.
 */
	static void
clear_buffers()
{
	if (!(ch_getflags() & CH_CANSEEK))
		return;
	ch_flush();
	clr_linenum();
#if HILITE_SEARCH
	clr_hilite();
#endif
}

/*
d569 2
a570 2
		int save_top_scroll = top_scroll;
		int save_ignore_eoi = ignore_eoi;
a571 8
		ignore_eoi = 0;
		if (screen_trashed == 2)
		{
			/* Special case used by ignore_eoi: re-open the input file
			 * and jump to the end of the file. */
			reopen_curr_ifile();
			jump_forw();
		}
a573 1
		ignore_eoi = save_ignore_eoi;
d585 1
a585 1
	if (ungot != NULL)
d601 1
a601 1
	 * If we've hit EOF on the last file and the -E flag is set, quit.
d603 2
a604 2
	if (get_quit_at_eof() == OPT_ONPLUS &&
	    eof_displayed() && !(ch_getflags() & CH_HELPFILE) && 
d607 2
a608 1

d610 2
a611 1
	 * If the entire file is displayed and the -F flag is set, quit.
d613 1
a613 2
	if (quit_if_one_screen &&
	    entire_file_displayed() && !(ch_getflags() & CH_HELPFILE) && 
d616 1
a627 12
	/*
	 * If the previous action was a forward movement, 
	 * don't clear the bottom line of the display;
	 * just print the prompt since the forward movement guarantees 
	 * that we're in the right position to display the prompt.
	 * Clearing the line could cause a problem: for example, if the last
	 * line displayed ended at the right screen edge without a newline,
	 * then clearing would clear the last displayed line rather than
	 * the prompt line.
	 */
	if (!forw_prompt)
		clear_bot();
a628 1
	forw_prompt = 0;
d630 1
a630 3
	if (is_filtering())
		putstr("& ");
	if (p == NULL || *p == '\0')
d634 1
a634 1
		at_enter(AT_STANDOUT);
d636 1
a636 1
		at_exit();
a637 1
	clear_eol();
d661 1
a661 2
	if (unget_end) 
	{
d663 1
a663 1
		 * We have just run out of ungotten chars.
d665 3
a667 3
		unget_end = 0;
		if (len_cmdbuf() == 0 || !empty_screen())
			return (getchr());
d669 1
a669 1
		 * Command is incomplete, so try to complete it.
d671 1
a671 7
		switch (mca)
		{
		case A_DIGIT:
			/*
			 * We have a number but no command.  Treat as #g.
			 */
			return ('g');
d673 16
a688 6
		case A_F_SEARCH:
		case A_B_SEARCH:
			/*
			 * We have "/string" but no newline.  Add the \n.
			 */
			return ('\n'); 
d690 6
a695 7
		default:
			/*
			 * Some other incomplete command.  Let user complete it.
			 */
			return (getchr());
		}
	}
d697 1
a697 2
	if (ungot == NULL)
	{
d699 1
a699 1
		 * Normal case: no ungotten chars, so get one from the user.
a702 12

	/*
	 * Return the next ungotten char.
	 */
	{
		struct ungot *ug = ungot;
		char c = ug->ug_char;
		ungot = ug->ug_next;
		free(ug);
		unget_end = (ungot == NULL);
		return (c);
	}
d713 8
a720 6
	struct ungot *ug = (struct ungot *) ecalloc(1, sizeof(struct ungot));

	ug->ug_char = c;
	ug->ug_next = ungot;
	ungot = ug;
	unget_end = 0;
a828 3
	} else
	{
		unsave_ifile(save_ifile);
d860 1
a860 1
		curropt = NULL;
d1082 1
a1083 2
			{
				make_display();
a1084 1
			}
d1123 8
a1130 1
			clear_buffers();
a1154 1
			{
a1155 2
				fraction = 0;
			}
a1156 1
			{
a1157 2
				fraction = 0;
			}
d1159 1
a1159 1
			jump_percent((int) number, fraction);
a1213 1
				hshift = save_hshift;
d1225 1
a1225 2
#define	DO_SEARCH() \
			if (number <= 0) number = 1;	\
a1254 11
		case A_FILTER:
#if HILITE_SEARCH
			search_type = SRCH_FORW | SRCH_FILTER;
			mca_search();
			c = getcc();
			goto again;
#else
			error("Command not available", NULL_PARG);
			break;
#endif

a1302 2
			save_hshift = hshift;
			hshift = 0;
d1343 1
a1343 1
				error("WARNING: This file was viewed via LESSOPEN",
d1345 1
d1378 1
a1378 1
				if (get_quit_at_eof() && eof_displayed() && 
d1527 2
a1528 2
			if (c == erase_char || c == erase2_char ||
			    c == kill_char || c == '\n' || c == '\r')
d1539 2
a1540 2
			if (c == erase_char || c == erase2_char ||
			    c == kill_char || c == '\n' || c == '\r')
a1541 1
			cmd_exec();
d1554 1
a1554 1
			if (c == erase_char || c == erase2_char || c == kill_char)
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d25 1
a25 1
extern volatile sig_atomic_t sigs;
a38 1
extern POSITION highest_hilite;
a56 3
extern int be_helpful;
extern int less_is_more;
extern int quit_at_eof;
a70 1
static char *help_prompt;
d105 2
a106 2
	constant char *prompt;
	constant void *mlist;
a181 1
#if GNU_OPTIONS
a183 1
#endif
a305 1
#if GNU_OPTIONS
a316 1
#endif
a335 1
#if GNU_OPTIONS
a340 1
#endif
a346 1
#if GNU_OPTIONS
a398 1
#endif
a419 1
#if GNU_OPTIONS
a433 1
#endif
d683 1
a683 1
	register constant char *p;
d740 1
a740 1
	p = help_prompt ? help_prompt : pr_string();
a748 2
		if (be_helpful && !help_prompt && strlen(p) + 40 < sc_width)
			putstr(" [Press space to continue, 'q' to quit.]");
a750 1
	help_prompt = NULL;
a958 40
 * Forward forever, or until a highlighted line appears.
 */
	static int
forw_loop(until_hilite)
	int until_hilite;
{
	POSITION curr_len;

	if (ch_getflags() & CH_HELPFILE)
		return (A_NOACTION);

	cmd_exec();
	jump_forw();
	curr_len = ch_length();
	highest_hilite = until_hilite ? curr_len : NULL_POSITION;
	ignore_eoi = 1;
	while (!sigs)
	{
		if (until_hilite && highest_hilite > curr_len)
		{
			bell();
			break;
		}
		make_display();
		forward(1, 0, 0);
	}
	ignore_eoi = 0;
	ch_set_eof();

	/*
	 * This gets us back in "F mode" after processing 
	 * a non-abort signal (e.g. window-change).  
	 */
	if (sigs && !ABORT_SIGS())
		return (until_hilite ? A_F_UNTIL_HILITE : A_F_FOREVER);

	return (A_NOACTION);
}

/*
a975 1
	int until_hilite = 0;
d1203 17
a1219 7
			newaction = forw_loop(0);
			if (less_is_more)
				quit_at_eof = OPT_ON;
			break;

		case A_F_UNTIL_HILITE:
			newaction = forw_loop(1);
a1332 1
#if !SMALL
a1344 1
#endif /* !SMALL */
a1439 1
#if !SMALL
a1441 7
			if (ungot != NULL || unget_end) {
				error(less_is_more
				    ? "Invalid option -p h"
				    : "Invalid option ++h",
				    NULL_PARG);
				break;
			}
d1445 1
a1445 2
			(void) edit(HELPFILE);
#endif /* !SMALL */
d1759 1
a1759 4
			if (be_helpful)
				help_prompt = "[Press 'h' for instructions.]";
			else
				bell();
@


