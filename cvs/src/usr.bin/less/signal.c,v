head	1.17;
access;
symbols
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.8.0.12
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.8
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.6
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.4
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.6.0.34
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.32
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.30
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.26
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.28
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.24
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.22
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.20
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.18
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	W32EN7Zp77efb8wW;

1.16
date	2016.03.16.15.36.26;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	P9ytq8HKajWPxZf9;

1.15
date	2016.01.12.23.01.23;	author mmcc;	state Exp;
branches;
next	1.14;
commitid	5Pl94glX7ncfN0bb;

1.14
date	2015.11.13.16.48.48;	author nicm;	state Exp;
branches;
next	1.13;
commitid	1UhnxVLYjgAT43E3;

1.13
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.12;
commitid	QKrr6AuGzNx9nehL;

1.12
date	2015.11.06.00.02.22;	author nicm;	state Exp;
branches;
next	1.11;
commitid	192w0RBe8ykYa3qb;

1.11
date	2015.11.05.22.47.33;	author tedu;	state Exp;
branches;
next	1.10;
commitid	vLFUUyhjlRQmhpMd;

1.10
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.9;
commitid	yKv9Ck9ZDgwWTRTo;

1.9
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.8;

1.8
date	2011.09.21.19.01.49;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.18.18.40.09;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.07.03.35.19;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.08;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.51;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.17
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2015 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Routines dealing with signals.
 *
 * A signal usually merely causes a bit to be set in the "signals" word.
 * At some convenient time, the mainline code checks to see if any
 * signals need processing by calling psignal().
 */

#include <signal.h>

#include "less.h"

/*
 * "sigs" contains bits indicating signals which need to be processed.
 */
volatile sig_atomic_t sigs;

extern int sc_width, sc_height;
extern int screen_trashed;
extern int linenums;
extern int wscroll;
extern int quit_on_intr;
extern long jump_sline_fraction;

/*
 * Interrupt signal handler.
 */
static void
u_interrupt(int type)
{
	sigs |= S_INTERRUPT;
}

/*
 * "Stop" (^Z) signal handler.
 */
static void
stop(int type)
{
	sigs |= S_STOP;
}

/*
 * "Window" change handler
 */
void
sigwinch(int type)
{
	sigs |= S_WINCH;
}

/*
 * Set up the signal handlers.
 */
void
init_signals(int on)
{
	if (on) {
		/*
		 * Set signal handlers.
		 */
		(void) lsignal(SIGINT, u_interrupt);
		(void) lsignal(SIGTSTP, stop);
		(void) lsignal(SIGWINCH, sigwinch);
		(void) lsignal(SIGQUIT, SIG_IGN);
	} else {
		/*
		 * Restore signals to defaults.
		 */
		(void) lsignal(SIGINT, SIG_DFL);
		(void) lsignal(SIGTSTP, SIG_DFL);
		(void) lsignal(SIGWINCH, SIG_IGN);
		(void) lsignal(SIGQUIT, SIG_DFL);
	}
}

/*
 * Process any signals we have received.
 * A received signal cause a bit to be set in "sigs".
 */
void
psignals(void)
{
	int tsignals;

	if ((tsignals = sigs) == 0)
		return;
	sigs = 0;

	if (tsignals & S_STOP) {
		/*
		 * Clean up the terminal.
		 */
		lsignal(SIGTTOU, SIG_IGN);
		clear_bot();
		deinit();
		flush(0);
		raw_mode(0);
		lsignal(SIGTTOU, SIG_DFL);
		lsignal(SIGTSTP, SIG_DFL);
		kill(getpid(), SIGTSTP);
		/*
		 * ... Bye bye. ...
		 * Hopefully we'll be back later and resume here...
		 * Reset the terminal and arrange to repaint the
		 * screen when we get back to the main command loop.
		 */
		lsignal(SIGTSTP, stop);
		raw_mode(1);
		init();
		screen_trashed = 1;
		tsignals |= S_WINCH;
	}
	if (tsignals & S_WINCH) {
		int old_width, old_height;
		/*
		 * Re-execute scrsize() to read the new window size.
		 */
		old_width = sc_width;
		old_height = sc_height;
		get_term();
		if (sc_width != old_width || sc_height != old_height) {
			wscroll = (sc_height + 1) / 2;
			calc_jump_sline();
			calc_shift_count();
			screen_trashed = 1;
		}
	}
	if (tsignals & S_INTERRUPT) {
		ring_bell();
		if (quit_on_intr)
			quit(QUIT_INTERRUPT);
	}
}

/*
 * Custom version of signal() that causes syscalls to be interrupted.
 */
void *
lsignal(int s, void (*a)(int))
{
	struct sigaction sa, osa;

	sa.sa_handler = a;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;		/* don't restart system calls */
	if (sigaction(s, &sa, &osa) != 0)
		return (SIG_ERR);
	return (osa.sa_handler);
}
@


1.16
log
@style(9) includes

ok nicm@@
@
text
@d157 1
a157 1
	sa.sa_flags = 0;                /* don't restart system calls */
@


1.15
log
@remove lint annotations

ok nicm@@
@
text
@d20 2
a22 1
#include <signal.h>
@


1.14
log
@Add a flag argument to flush() to stop it calling quit() on error, then
use this from quit() to stop less blowing up the stack looping through
quit()/flush() if stderr is closed (for example "less /missing
2</dev/null"). ok millert
@
text
@a37 1
/* ARGSUSED */
a46 1
/* ARGSUSED */
a55 1
/* ARGSUSED */
@


1.13
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d110 1
a110 1
		flush();
@


1.12
log
@Remove LSIGNAL which is just the same as lsignal() now.
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2015 Garrett D'Amore <garrett@@damore.org>
@


1.11
log
@deregister
@
text
@d77 4
a80 4
		(void) LSIGNAL(SIGINT, u_interrupt);
		(void) LSIGNAL(SIGTSTP, stop);
		(void) LSIGNAL(SIGWINCH, sigwinch);
		(void) LSIGNAL(SIGQUIT, SIG_IGN);
d85 4
a88 4
		(void) LSIGNAL(SIGINT, SIG_DFL);
		(void) LSIGNAL(SIGTSTP, SIG_DFL);
		(void) LSIGNAL(SIGWINCH, SIG_IGN);
		(void) LSIGNAL(SIGQUIT, SIG_DFL);
d109 1
a109 1
		LSIGNAL(SIGTTOU, SIG_IGN);
d114 2
a115 2
		LSIGNAL(SIGTTOU, SIG_DFL);
		LSIGNAL(SIGTSTP, SIG_DFL);
d123 1
a123 1
		LSIGNAL(SIGTSTP, stop);
@


1.10
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d99 1
a99 1
	register int tsignals;
@


1.9
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

d28 1
a28 1
public volatile sig_atomic_t sigs;
a31 1
extern int lnloop;
d40 4
a43 8
	/* ARGSUSED*/
	static RETSIGTYPE
u_interrupt(type)
	int type;
{
#if OS2
	LSIGNAL(SIGINT, SIG_ACK);
#endif
a44 9
#if MSDOS_COMPILER==DJGPPC
	/*
	 * If a keyboard has been hit, it must be Ctrl-C
	 * (as opposed to Ctrl-Break), so consume it.
	 * (Otherwise, Less will beep when it sees Ctrl-C from keyboard.)
	 */
	if (kbhit())
		getkey();
#endif
a46 1
#ifdef SIGTSTP
d50 3
a52 4
	/* ARGSUSED*/
	static RETSIGTYPE
stop(type)
	int type;
a55 1
#endif
a56 13
#ifdef SIGWINCH
/*
 * "Window" change handler
 */
	/* ARGSUSED*/
	public RETSIGTYPE
winch(type)
	int type;
{
	sigs |= S_WINCH;
}
#else
#ifdef SIGWIND
d60 3
a62 4
	/* ARGSUSED*/
	public RETSIGTYPE
winch(type)
	int type;
a65 25
#endif
#endif

#if MSDOS_COMPILER==WIN32C
/*
 * Handle CTRL-C and CTRL-BREAK keys.
 */
#include "windows.h"

	static BOOL WINAPI 
wbreak_handler(dwCtrlType)
	DWORD dwCtrlType;
{
	switch (dwCtrlType)
	{
	case CTRL_C_EVENT:
	case CTRL_BREAK_EVENT:
		sigs |= S_INTERRUPT;
		return (TRUE);
	default:
		break;
	}
	return (FALSE);
}
#endif
d70 2
a71 3
	public void
init_signals(on)
	int on;
d73 1
a73 2
	if (on)
	{
a77 4
#if MSDOS_COMPILER==WIN32C
		SetConsoleCtrlHandler(wbreak_handler, TRUE);
#endif
#ifdef SIGTSTP
d79 1
a79 8
#endif
#ifdef SIGWINCH
		(void) LSIGNAL(SIGWINCH, winch);
#endif
#ifdef SIGWIND
		(void) LSIGNAL(SIGWIND, winch);
#endif
#ifdef SIGQUIT
d81 1
a81 3
#endif
	} else
	{
a85 4
#if MSDOS_COMPILER==WIN32C
		SetConsoleCtrlHandler(wbreak_handler, FALSE);
#endif
#ifdef SIGTSTP
a86 2
#endif
#ifdef SIGWINCH
a87 5
#endif
#ifdef SIGWIND
		(void) LSIGNAL(SIGWIND, SIG_IGN);
#endif
#ifdef SIGQUIT
a88 1
#endif
d96 2
a97 2
	public void
psignals()
d105 1
a105 3
#ifdef SIGTSTP
	if (tsignals & S_STOP)
	{
a108 1
#ifdef SIGTTOU
a109 1
#endif
a113 1
#ifdef SIGTTOU
a114 1
#endif
d129 1
a129 4
#endif
#ifdef S_WINCH
	if (tsignals & S_WINCH)
	{
d137 1
a137 2
		if (sc_width != old_width || sc_height != old_height)
		{
d144 2
a145 4
#endif
	if (tsignals & S_INTERRUPT)
	{
		bell();
d154 2
a155 4
	public void
(*lsignal(s, a))()
	int s;
	void (*a) ();
d161 1
a161 1
	sa.sa_flags = 0;		/* don't restart system calls */
@


1.8
log
@Use volatile sig_atomic_t, not int, for the sigs variable.  Also
move the call to bell() out of u_interrupt() (a signal handler).
OK and with help from deraadt@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
@


1.7
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d26 1
a26 1
public int sigs;
a43 1
	bell();
d238 1
@


1.6
log
@Use OPT_ONPLUS instead of hard-coding '2'
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d33 2
d44 1
d143 1
a143 1
#else
a149 1
#endif
d231 2
d239 2
a240 19
		bell();
		/*
		 * {{ You may wish to replace the bell() with 
		 *    error("Interrupt", NULL_PARG); }}
		 */

		/*
		 * If we were interrupted while in the "calculating 
		 * line numbers" loop, turn off line numbers.
		 */
		if (lnloop)
		{
			lnloop = 0;
			if (linenums == OPT_ONPLUS)
				screen_trashed = 1;
			linenums = 0;
			error("Line numbers turned off", NULL_PARG);
		}

@


1.5
log
@Use interruptible syscalls instead of setjmp/longjmp.  This makes
less's signal handlers safe.  No one has reported problems so far...
@
text
@d248 1
a248 1
			if (linenums == 2)
@


1.4
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@a17 2
 * If we happen to be reading from a file [in iread()] at the time
 * the signal is received, we call intread to interrupt the iread.
a32 1
extern int reading;
a44 1
	LSIGNAL(SIGINT, u_interrupt);
a54 2
	if (reading)
		intread();
a65 1
	LSIGNAL(SIGTSTP, stop);
a66 2
	if (reading)
		intread();
a78 1
	LSIGNAL(SIGWINCH, winch);
a79 2
	if (reading)
		intread();
a90 1
	LSIGNAL(SIGWIND, winch);
a91 2
	if (reading)
		intread();
d255 18
@


1.3
log
@kill more registers

millert@@ ok
@
text
@a0 2
/*	$OpenBSD: signal.c,v 1.2 2001/01/29 01:58:04 niklas Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d46 1
a46 1
	SIGNAL(SIGINT, SIG_ACK);
d48 1
a48 1
	SIGNAL(SIGINT, u_interrupt);
d50 9
d72 1
a72 1
	SIGNAL(SIGTSTP, stop);
d88 1
a88 1
	SIGNAL(SIGWINCH, winch);
d103 1
a103 1
	SIGNAL(SIGWIND, winch);
d111 23
d146 4
a149 1
		(void) SIGNAL(SIGINT, u_interrupt);
d151 1
a151 1
		(void) SIGNAL(SIGTSTP, stop);
d154 1
a154 1
		(void) SIGNAL(SIGWINCH, winch);
d157 4
a160 1
		(void) SIGNAL(SIGWIND, winch);
d168 4
a171 1
		(void) SIGNAL(SIGINT, SIG_DFL);
d173 1
a173 1
		(void) SIGNAL(SIGTSTP, SIG_DFL);
d176 1
a176 1
		(void) SIGNAL(SIGWINCH, SIG_IGN);
d179 4
a182 1
		(void) SIGNAL(SIGWIND, SIG_IGN);
d194 1
a194 1
	int tsignals;
d207 1
a207 1
		SIGNAL(SIGTTOU, SIG_IGN);
d214 1
a214 1
		SIGNAL(SIGTTOU, SIG_DFL);
d216 1
a216 1
		SIGNAL(SIGTSTP, SIG_DFL);
d224 1
a224 1
		SIGNAL(SIGTSTP, stop);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d168 1
a168 1
	register int tsignals;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d62 1
a62 1
	LSIGNAL(SIGINT, SIG_ACK);
d64 1
a64 1
	LSIGNAL(SIGINT, u_interrupt);
a65 9
#if MSDOS_COMPILER==DJGPPC
	/*
	 * If a keyboard has been hit, it must be Ctrl-C
	 * (as opposed to Ctrl-Break), so consume it.
	 * (Otherwise, Less will beep when it sees Ctrl-C from keyboard.)
	 */
	if (kbhit())
		getkey();
#endif
d79 1
a79 1
	LSIGNAL(SIGTSTP, stop);
d95 1
a95 1
	LSIGNAL(SIGWINCH, winch);
d110 1
a110 1
	LSIGNAL(SIGWIND, winch);
a117 23
#if MSDOS_COMPILER==WIN32C
/*
 * Handle CTRL-C and CTRL-BREAK keys.
 */
#include "windows.h"

	static BOOL WINAPI 
wbreak_handler(dwCtrlType)
	DWORD dwCtrlType;
{
	switch (dwCtrlType)
	{
	case CTRL_C_EVENT:
	case CTRL_BREAK_EVENT:
		sigs |= S_INTERRUPT;
		return (TRUE);
	default:
		break;
	}
	return (FALSE);
}
#endif

d130 1
a130 4
		(void) LSIGNAL(SIGINT, u_interrupt);
#if MSDOS_COMPILER==WIN32C
		SetConsoleCtrlHandler(wbreak_handler, TRUE);
#endif
d132 1
a132 1
		(void) LSIGNAL(SIGTSTP, stop);
d135 1
a135 1
		(void) LSIGNAL(SIGWINCH, winch);
d138 1
a138 4
		(void) LSIGNAL(SIGWIND, winch);
#endif
#ifdef SIGQUIT
		(void) LSIGNAL(SIGQUIT, SIG_IGN);
d146 1
a146 4
		(void) LSIGNAL(SIGINT, SIG_DFL);
#if MSDOS_COMPILER==WIN32C
		SetConsoleCtrlHandler(wbreak_handler, FALSE);
#endif
d148 1
a148 1
		(void) LSIGNAL(SIGTSTP, SIG_DFL);
d151 1
a151 1
		(void) LSIGNAL(SIGWINCH, SIG_IGN);
d154 1
a154 4
		(void) LSIGNAL(SIGWIND, SIG_IGN);
#endif
#ifdef SIGQUIT
		(void) LSIGNAL(SIGQUIT, SIG_DFL);
d179 1
a179 1
		LSIGNAL(SIGTTOU, SIG_IGN);
d186 1
a186 1
		LSIGNAL(SIGTTOU, SIG_DFL);
d188 1
a188 1
		LSIGNAL(SIGTSTP, SIG_DFL);
d196 1
a196 1
		LSIGNAL(SIGTSTP, stop);
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
a35 2
extern int quit_on_intr;
extern long jump_sline_fraction;
a44 1
	bell();
d60 1
a60 1
		intread(); /* May longjmp */
d155 1
a155 1
#endif
d162 1
a243 2
			calc_jump_sline();
			calc_shift_count();
d250 19
a268 2
		if (quit_on_intr)
			quit(QUIT_INTERRUPT);
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d18 2
d28 1
a28 1
public volatile sig_atomic_t sigs;
d35 1
d47 1
d51 1
d62 2
d75 1
d77 2
d91 1
d93 2
d106 1
d108 2
a253 1
		bell();
a256 18
}

/*
 * Custom version of signal() that causes syscalls to be interrupted.
 */
	public void
(*lsignal(s, a))()
	int s;
	void (*a) ();
{
	struct sigaction sa, osa;

	sa.sa_handler = a;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;		/* don't restart system calls */
	if (sigaction(s, &sa, &osa) != 0)
		return (SIG_ERR);
	return (osa.sa_handler);
@


