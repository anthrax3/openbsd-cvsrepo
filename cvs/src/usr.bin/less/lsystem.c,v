head	1.18;
access;
symbols
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.6
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.8.0.12
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.8
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.6
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.4
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.7.0.18
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.16
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.14
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.10
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.12
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.8
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.6
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.03.16.15.36.26;	author mmcc;	state Exp;
branches;
next	1.17;
commitid	P9ytq8HKajWPxZf9;

1.17
date	2015.11.13.16.48.48;	author nicm;	state Exp;
branches;
next	1.16;
commitid	1UhnxVLYjgAT43E3;

1.16
date	2015.11.09.16.46.43;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	rJ6tmXbM6ZZSV1zd;

1.15
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	ZtGimechwgSRYqRW;

1.14
date	2015.11.09.02.59.06;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	krM8GIm0ktfoy1dx;

1.13
date	2015.11.07.18.07.44;	author tedu;	state Exp;
branches;
next	1.12;
commitid	DJUwzdj0cG1bCfEw;

1.12
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.11;
commitid	QKrr6AuGzNx9nehL;

1.11
date	2015.11.06.00.02.22;	author nicm;	state Exp;
branches;
next	1.10;
commitid	192w0RBe8ykYa3qb;

1.10
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.9;
commitid	yKv9Ck9ZDgwWTRTo;

1.9
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.8;

1.8
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.7;

1.7
date	2007.04.19.05.56.45;	author mbalmer;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.19.13.27.08;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.06.23.38.07;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.06;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.49;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.18
log
@style(9) includes

ok nicm@@
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Routines to execute other programs.
 * Necessarily very OS dependent.
 */

#include <signal.h>

#include "less.h"
#include "position.h"

extern int screen_trashed;
extern IFILE curr_ifile;

static int pipe_data(char *cmd, off_t spos, off_t epos);

/*
 * Pass the specified command to a shell to be executed.
 * Like plain "system()", but handles resetting terminal modes, etc.
 */
void
lsystem(const char *cmd, const char *donemsg)
{
	int inp;
	char *shell;
	char *p;
	IFILE save_ifile;

	/*
	 * Print the command which is to be executed,
	 * unless the command starts with a "-".
	 */
	if (cmd[0] == '-')
		cmd++;
	else {
		clear_bot();
		putstr("!");
		putstr(cmd);
		putstr("\n");
	}

	/*
	 * Close the current input file.
	 */
	save_ifile = save_curr_ifile();
	(void) edit_ifile(NULL);

	/*
	 * De-initialize the terminal and take out of raw mode.
	 */
	deinit();
	flush(0);	/* Make sure the deinit chars get out */
	raw_mode(0);

	/*
	 * Restore signals to their defaults.
	 */
	init_signals(0);

	/*
	 * Force standard input to be the user's terminal
	 * (the normal standard input), even if less's standard input
	 * is coming from a pipe.
	 */
	inp = dup(0);
	(void) close(0);
	if (open("/dev/tty", O_RDONLY) < 0)
		(void) dup(inp);

	/*
	 * Pass the command to the system to be executed.
	 * If we have a SHELL environment variable, use
	 * <$SHELL -c "command"> instead of just <command>.
	 * If the command is empty, just invoke a shell.
	 */
	p = NULL;
	if ((shell = lgetenv("SHELL")) != NULL && *shell != '\0') {
		if (*cmd == '\0') {
			p = estrdup(shell);
		} else {
			char *esccmd = shell_quote(cmd);
			if (esccmd != NULL) {
				p = easprintf("%s -c %s", shell, esccmd);
				free(esccmd);
			}
		}
	}
	if (p == NULL) {
		if (*cmd == '\0')
			p = estrdup("sh");
		else
			p = estrdup(cmd);
	}
	(void) system(p);
	free(p);

	/*
	 * Restore standard input, reset signals, raw mode, etc.
	 */
	(void) close(0);
	(void) dup(inp);
	(void) close(inp);

	init_signals(1);
	raw_mode(1);
	if (donemsg != NULL) {
		putstr(donemsg);
		putstr("  (press RETURN)");
		get_return();
		(void) putchr('\n');
		flush(0);
	}
	init();
	screen_trashed = 1;

	/*
	 * Reopen the current input file.
	 */
	reedit_ifile(save_ifile);

	/*
	 * Since we were ignoring window change signals while we executed
	 * the system command, we must assume the window changed.
	 * Warning: this leaves a signal pending (in "sigs"),
	 * so psignals() should be called soon after lsystem().
	 */
	sigwinch(0);
}

/*
 * Pipe a section of the input file into the given shell command.
 * The section to be piped is the section "between" the current
 * position and the position marked by the given letter.
 *
 * If the mark is after the current screen, the section between
 * the top line displayed and the mark is piped.
 * If the mark is before the current screen, the section between
 * the mark and the bottom line displayed is piped.
 * If the mark is on the current screen, or if the mark is ".",
 * the whole current screen is piped.
 */
int
pipe_mark(int c, char *cmd)
{
	off_t mpos, tpos, bpos;

	/*
	 * mpos = the marked position.
	 * tpos = top of screen.
	 * bpos = bottom of screen.
	 */
	mpos = markpos(c);
	if (mpos == -1)
		return (-1);
	tpos = position(TOP);
	if (tpos == -1)
		tpos = ch_zero();
	bpos = position(BOTTOM);

	if (c == '.')
		return (pipe_data(cmd, tpos, bpos));
	else if (mpos <= tpos)
		return (pipe_data(cmd, mpos, bpos));
	else if (bpos == -1)
		return (pipe_data(cmd, tpos, bpos));
	else
		return (pipe_data(cmd, tpos, mpos));
}

/*
 * Create a pipe to the given shell command.
 * Feed it the file contents between the positions spos and epos.
 */
static int
pipe_data(char *cmd, off_t spos, off_t epos)
{
	FILE *f;
	int c;

	/*
	 * This is structured much like lsystem().
	 * Since we're running a shell program, we must be careful
	 * to perform the necessary deinitialization before running
	 * the command, and reinitialization after it.
	 */
	if (ch_seek(spos) != 0) {
		error("Cannot seek to start position", NULL);
		return (-1);
	}

	if ((f = popen(cmd, "w")) == NULL) {
		error("Cannot create pipe", NULL);
		return (-1);
	}
	clear_bot();
	putstr("!");
	putstr(cmd);
	putstr("\n");

	deinit();
	flush(0);
	raw_mode(0);
	init_signals(0);
	lsignal(SIGPIPE, SIG_IGN);

	c = EOI;
	while (epos == -1 || spos++ <= epos) {
		/*
		 * Read a character from the file and give it to the pipe.
		 */
		c = ch_forw_get();
		if (c == EOI)
			break;
		if (putc(c, f) == EOF)
			break;
	}

	/*
	 * Finish up the last line.
	 */
	while (c != '\n' && c != EOI) {
		c = ch_forw_get();
		if (c == EOI)
			break;
		if (putc(c, f) == EOF)
			break;
	}

	(void) pclose(f);

	lsignal(SIGPIPE, SIG_DFL);
	init_signals(1);
	raw_mode(1);
	init();
	screen_trashed = 1;
	/* {{ Probably don't need this here. }} */
	sigwinch(0);
	return (0);
}
@


1.17
log
@Add a flag argument to flush() to stop it calling quit() on error, then
use this from quit() to stop less blowing up the stack looping through
quit()/flush() if stderr is closed (for example "less /missing
2</dev/null"). ok millert
@
text
@d17 2
a19 1
#include <signal.h>
@


1.16
log
@NULL_IFILE has no weird use patterns.  NULL is sufficient.
@
text
@d61 1
a61 1
	flush();	/* Make sure the deinit chars get out */
d120 1
a120 1
		flush();
d210 1
a210 1
	flush();
@


1.15
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@d55 1
a55 1
	(void) edit_ifile(NULL_IFILE);
@


1.14
log
@do not need wrappers around O_RDONLY and such
@
text
@d196 1
a196 1
		error("Cannot seek to start position", NULL_PARG);
d201 1
a201 1
		error("Cannot create pipe", NULL_PARG);
@


1.13
log
@replace save() with estrdup() and make estrdup() exit like all the other
ecalloc, etc. functions do.
ok mmcc nicm
@
text
@d76 1
a76 1
	if (open("/dev/tty", OPEN_READ) < 0)
@


1.12
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d88 1
a88 1
			p = save(shell);
d99 1
a99 1
			p = save("sh");
d101 1
a101 1
			p = save(cmd);
@


1.11
log
@Remove LSIGNAL which is just the same as lsignal() now.
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.10
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d215 1
a215 1
	LSIGNAL(SIGPIPE, SIG_IGN);
d242 1
a242 1
	LSIGNAL(SIGPIPE, SIG_DFL);
@


1.9
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

a22 10
#if MSDOS_COMPILER
#include <dos.h>
#ifdef _MSC_VER
#include <direct.h>
#define setdisk(n) _chdrive((n)+1)
#else
#include <dir.h>
#endif
#endif

d26 1
a26 2

#if HAVE_SYSTEM
d32 2
a33 4
	public void
lsystem(cmd, donemsg)
	char *cmd;
	char *donemsg;
d35 3
a37 5
	register int inp;
#if HAVE_SHELL
	register char *shell;
	register char *p;
#endif
a38 3
#if MSDOS_COMPILER && MSDOS_COMPILER!=WIN32C
	char cwd[FILENAME_MAX+1];
#endif
d46 1
a46 2
	else
	{
a52 16
#if MSDOS_COMPILER
#if MSDOS_COMPILER==WIN32C
	if (*cmd == '\0')
		cmd = getenv("COMSPEC");
#else
	/*
	 * Working directory is global on MSDOS.
	 * The child might change the working directory, so we
	 * must save and restore CWD across calls to "system",
	 * or else we won't find our file when we return and
	 * try to "reedit_ifile" it.
	 */
	getcwd(cwd, FILENAME_MAX);
#endif
#endif

a64 3
#if MSDOS_COMPILER==WIN32C
	close_getchr();
#endif
a70 1
#if HAVE_DUP
d73 1
a73 1
	 * (the normal standard input), even if less's standard input 
d77 1
a77 5
	close(0);
#if OS2
	/* The __open() system call translates "/dev/tty" to "con". */
	if (__open("/dev/tty", OPEN_READ) < 0)
#else
d79 1
a79 3
#endif
		dup(inp);
#endif
a86 1
#if HAVE_SHELL
d88 2
a89 3
	if ((shell = lgetenv("SHELL")) != NULL && *shell != '\0')
	{
		if (*cmd == '\0')
d91 1
a91 2
		else
		{
d93 2
a94 5
			if (esccmd != NULL)
			{
				size_t len = strlen(shell) + strlen(esccmd) + 5;
				p = (char *) ecalloc(len, sizeof(char));
				SNPRINTF3(p, len, "%s %s %s", shell, shell_coption(), esccmd);
d99 1
a99 2
	if (p == NULL)
	{
d105 1
a105 1
	system(p);
a106 17
#else
#if MSDOS_COMPILER==DJGPPC
	/*
	 * Make stdin of the child be in cooked mode.
	 */
	setmode(0, O_TEXT);
	/*
	 * We don't need to catch signals of the child (it
	 * also makes trouble with some DPMI servers).
	 */
	__djgpp_exception_toggle();
  	system(cmd);
	__djgpp_exception_toggle();
#else
	system(cmd);
#endif
#endif
a107 1
#if HAVE_DUP
d111 4
a114 8
	close(0);
	dup(inp);
	close(inp);
#endif

#if MSDOS_COMPILER==WIN32C
	open_getchr();
#endif
d117 1
a117 2
	if (donemsg != NULL)
	{
d121 1
a121 1
		putchr('\n');
a126 21
#if MSDOS_COMPILER && MSDOS_COMPILER!=WIN32C
	/*
	 * Restore the previous directory (possibly
	 * changed by the child program we just ran).
	 */
	chdir(cwd);
#if MSDOS_COMPILER != DJGPPC
	/*
	 * Some versions of chdir() don't change to the drive
	 * which is part of CWD.  (DJGPP does this in chdir.)
	 */
	if (cwd[1] == ':')
	{
		if (cwd[0] >= 'a' && cwd[0] <= 'z')
			setdisk(cwd[0] - 'a');
		else if (cwd[0] >= 'A' && cwd[0] <= 'Z')
			setdisk(cwd[0] - 'A');
	}
#endif
#endif

a131 1
#if defined(SIGWINCH) || defined(SIGWIND)
d138 1
a138 2
	winch(0);
#endif
a140 4
#endif

#if PIPEC

d153 2
a154 4
	public int
pipe_mark(c, cmd)
	int c;
	char *cmd;
d156 1
a156 1
	POSITION mpos, tpos, bpos;
d164 1
a164 1
	if (mpos == NULL_POSITION)
d167 1
a167 1
	if (tpos == NULL_POSITION)
d171 8
a178 8
 	if (c == '.') 
 		return (pipe_data(cmd, tpos, bpos));
 	else if (mpos <= tpos)
 		return (pipe_data(cmd, mpos, bpos));
 	else if (bpos == NULL_POSITION)
 		return (pipe_data(cmd, tpos, bpos));
 	else
 		return (pipe_data(cmd, tpos, mpos));
d185 2
a186 5
	public int
pipe_data(cmd, spos, epos)
	char *cmd;
	POSITION spos;
	POSITION epos;
d188 2
a189 3
	register FILE *f;
	register int c;
	extern FILE *popen();
d197 1
a197 2
	if (ch_seek(spos) != 0)
	{
d202 1
a202 2
	if ((f = popen(cmd, "w")) == NULL)
	{
a214 4
#if MSDOS_COMPILER==WIN32C
	close_getchr();
#endif
#ifdef SIGPIPE
a215 1
#endif
d218 1
a218 2
	while (epos == NULL_POSITION || spos++ <= epos)
	{
d232 7
a238 8
 	while (c != '\n' && c != EOI ) 
 	{
 		c = ch_forw_get();
 		if (c == EOI)
 			break;
 		if (putc(c, f) == EOF)
 			break;
 	}
d240 1
a240 1
	pclose(f);
a241 1
#ifdef SIGPIPE
a242 4
#endif
#if MSDOS_COMPILER==WIN32C
	open_getchr();
#endif
a246 1
#if defined(SIGWINCH) || defined(SIGWIND)
d248 1
a248 2
	winch(0);
#endif
a250 2

#endif
@


1.8
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
@


1.7
log
@Update to less version 382.  This removes some code that is licensed under
a non-BSD license and which was not used on OpenBSD.  No functional changes.

From Daniel Dickmann <didickman@@gmail.com>, ok itojun, millert, ray, matthieu
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d52 1
a52 1
#if MSDOS_COMPILER
d71 4
d84 1
d143 1
a143 2
				snprintf(p, len, "%s %s %s", shell,
				    shell_coption(), esccmd);
d200 1
a200 1
#if MSDOS_COMPILER
@


1.6
log
@use strchr instead of index
@
text
@a370 140

#ifdef _OSK
/*
 *    Popen, and Pclose, for OS-9.
 *
 *    Based on code copyright (c) 1988 by Wolfgang Ocker, Puchheim,
 *                                        Ulli Dessauer, Germering and
 *                                        Reimer Mellin, Muenchen
 *                                        (W-Germany)
 *
 *    These functions can be copied and distributed freely for any
 *    non-commercial purposes.  It can only be incorporated into
 *    commercial software with the written permission of the authors.
 *
 *    TOP-specific code stripped out and adapted for less by M.Gregorie, 1996
 *
 *    address:    Wolfgang Ocker
 *                Lochhauserstrasse 35a
 *                D-8039 Puchheim
 *                West Germany
 *
 *    e-mail:     weo@@altger.UUCP, ud@@altger.UUCP, ram@@altger.UUCP
 *                pyramid!tmpmbx!recco!weo
 *                pyramid!tmpmbx!nitmar!ud
 *                pyramid!tmpmbx!ramsys!ram
 *
 *                Martin Gregorie
 *                10 Sadlers Mead
 *                Harlow
 *                Essex, CM18 6HG
 *                U.K.
 *
 *                gregorie@@logica.com
 */
#include <strings.h>
#include <errno.h>
extern char **environ;
extern char *getenv();
extern int  os9forkc();
static int pids[_NFILE] = { 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0 };
/* 
 * p o p e n
 */
FILE *popen(name, mode)
	char *name;
	char *mode;
{
    int          fd, fd2, fdsav, pid;
    static char  *argv[] = {NULL, NULL, NULL };
    static char  cmd[200];
    static char  cmd_path[200];
    char         *cp;
    char         *shell;
    FILE         *r;
    if ((shell = getenv("SHELL")) == NULL)
        return(NULL);
    cp = name;
    while (*cp == ' ')
        cp++;
    strlcpy(cmd_path, cp, sizeof(cmd_path));
    if (cp = strchr(cmd_path, ' '))
        *cp++ = '\0';
    strlcpy(cmd, "ex ", sizeof(cmd));
    strlcat(cmd, cmd_path, sizeof(cmd));
    if (cp)
    {
        strlcat(cmd, " ", sizeof(cmd));
        strlcat(cmd, cp, sizeof(cmd));
    }
    argv[0] = shell;
    argv[1] = cmd;
    /*
         mode is "r" (stdout) or "w" (stdin)
    */
    switch(mode[0])
    {
        case 'w':   fd = 0;
                    break;
        case 'r':   fd = 1;
                    break;
        default:    return(NULL);
    }
    if (fd == 1)
        fflush(stdout);
    fdsav = dup(fd);
    close(fd);
 
    creat("/pipe", S_IWRITE+S_IREAD);
    pid = os9exec(os9forkc, argv[0], argv, environ, 0, 0, 3);
    fd2 = dup(fd);
    close(fd);
    dup(fdsav);
    close(fdsav);
    if (pid > 0)
    {
        pids[fd2] = pid;
        r = fdopen(fd2, mode);
    }
    else
    {
        close(fd2);
        r = NULL;
    }
    return(r);
}

/*
 * p c l o s e
 */
int pclose(fp)
	FILE *fp;
{
    unsigned int    status;
    int             pid;
    int             fd,
                    i;
    fd = fileno(fp);
    if (pids[fd] == 0)
        return(-1);
    fflush(fp);
    fclose(fp);
    while ((pid = wait(&status)) != -1)
        if (pid == pids[fd])
            break;
        else
            for (i = 0; i < _NFILE; i++)
                if (pids[i] == pid)
                {
                    pids[i] = 0;
                    break;
                }
    if (pid == -1)
        status = -1;
    pids[fd] = 0;
    return(status);
}
#endif /* _OSK */
@


1.5
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d434 1
a434 1
    if (cp = index(cmd_path, ' '))
@


1.4
log
@more strlcpy/strlcat/snprintf, less strcpy/strcat/sprintf
reviewed by tdeval, millert, dhartmei and others.  more bits coming here
from some of them i think
@
text
@a0 2
/*	$OpenBSD: lsystem.c,v 1.3 2001/11/19 19:02:14 mpech Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d17 1
a18 1
#include "less.h"
d21 1
a21 1
#if MSOFTC
d23 6
d42 1
a42 1
lsystem(cmd)
d44 1
d46 4
a49 3
	int inp;
#if MSOFTC || OS2
	int inp2;
a50 2
	char *shell;
	char *p;
d52 3
d70 11
d84 1
a84 1
	save_ifile = curr_ifile;
d93 3
d102 1
d110 6
a115 1
	if (OPEN_TTYIN() < 0)
d117 1
d127 1
a127 1
	if ((shell = getenv("SHELL")) != NULL && *shell != '\0')
d133 9
a141 3
			size_t l = strlen(shell) + strlen(cmd) + 7;
			p = (char *) ecalloc(l, sizeof(char));
			snprintf(p, l, "%s -c \"%s\"", shell, cmd);
a150 1

d154 14
a167 3
#if OS2
	if (*cmd == '\0')
		cmd = "cmd.exe";
a168 1
	system(cmd);
d171 1
d178 1
d180 3
d185 8
d196 21
d220 1
a220 2
	if (edit_ifile(save_ifile))
		quit(QUIT_ERROR);
d242 6
a247 4
 * The "current" position means the top line displayed if the mark
 * is after the current screen, or the bottom line displayed if
 * the mark is before the current screen.
 * If the mark is on the current screen, the whole screen is displayed.
d272 1
a272 1
 		return (pipe_data(cmd, mpos, tpos));
d289 2
a290 2
	FILE *f;
	int c;
d319 3
d323 1
a323 1
	SIGNAL(SIGPIPE, SIG_IGN);
d354 4
a357 1
	SIGNAL(SIGPIPE, SIG_DFL);
d371 140
@


1.3
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lsystem.c,v 1.2 2001/01/29 01:58:02 niklas Exp $	*/
d121 3
a123 3
			p = (char *) ecalloc(strlen(shell) + strlen(cmd) + 7, 
					sizeof(char));
			sprintf(p, "%s -c \"%s\"", shell, cmd);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 1
a57 1
	register int inp;
d59 1
a59 1
	register int inp2;
d61 2
a62 2
	register char *shell;
	register char *p;
d227 2
a228 2
	register FILE *f;
	register int c;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d33 1
a34 1
#include <signal.h>
d37 1
a37 1
#if MSDOS_COMPILER
a38 6
#ifdef _MSC_VER
#include <direct.h>
#define setdisk(n) _chdrive((n)+1)
#else
#include <dir.h>
#endif
d52 1
a52 1
lsystem(cmd, donemsg)
a53 1
	char *donemsg;
d56 3
a58 1
#if HAVE_SHELL
a60 1
#endif
a61 3
#if MSDOS_COMPILER
	char cwd[FILENAME_MAX+1];
#endif
a76 11
#if MSDOS_COMPILER
	/*
	 * Working directory is global on MSDOS.
	 * The child might change the working directory, so we
	 * must save and restore CWD across calls to "system",
	 * or else we won't find our file when we return and
	 * try to "reedit_ifile" it.
	 */
	getcwd(cwd, FILENAME_MAX);
#endif

d80 1
a80 1
	save_ifile = save_curr_ifile();
a88 3
#if MSDOS_COMPILER==WIN32C
	close_getchr();
#endif
a94 1
#if HAVE_DUP
d102 1
a102 6
#if OS2
	/* The __open() system call translates "/dev/tty" to "con". */
	if (__open("/dev/tty", OPEN_READ) < 0)
#else
	if (open("/dev/tty", OPEN_READ) < 0)
#endif
a103 1
#endif
d113 1
a113 1
	if ((shell = lgetenv("SHELL")) != NULL && *shell != '\0')
d119 3
a121 8
			char *esccmd = shell_quote(cmd);
			if (esccmd != NULL)
			{
				p = (char *) ecalloc(strlen(shell) +
					strlen(esccmd) + 5, sizeof(char));
				sprintf(p, "%s %s %s", shell, shell_coption(), esccmd);
				free(esccmd);
			}
d131 1
d135 4
a138 13
#if MSDOS_COMPILER==DJGPPC
	/*
	 * Make stdin of the child be in cooked mode.
	 */
	setmode(0, O_TEXT);
	/*
	 * We don't need to catch signals of the child (it
	 * also makes trouble with some DPMI servers).
	 */
	__djgpp_exception_toggle();
  	system(cmd);
	__djgpp_exception_toggle();
#else
a140 1
#endif
a141 1
#if HAVE_DUP
a147 1
#endif
a148 3
#if MSDOS_COMPILER==WIN32C
	open_getchr();
#endif
a150 8
	if (donemsg != NULL)
	{
		putstr(donemsg);
		putstr("  (press RETURN)");
		get_return();
		putchr('\n');
		flush();
	}
a153 21
#if MSDOS_COMPILER
	/*
	 * Restore the previous directory (possibly
	 * changed by the child program we just ran).
	 */
	chdir(cwd);
#if MSDOS_COMPILER != DJGPPC
	/*
	 * Some versions of chdir() don't change to the drive
	 * which is part of CWD.  (DJGPP does this in chdir.)
	 */
	if (cwd[1] == ':')
	{
		if (cwd[0] >= 'a' && cwd[0] <= 'z')
			setdisk(cwd[0] - 'a');
		else if (cwd[0] >= 'A' && cwd[0] <= 'Z')
			setdisk(cwd[0] - 'A');
	}
#endif
#endif

d157 2
a158 1
	reedit_ifile(save_ifile);
d180 4
a183 6
 * If the mark is after the current screen, the section between
 * the top line displayed and the mark is piped.
 * If the mark is before the current screen, the section between
 * the mark and the bottom line displayed is piped.
 * If the mark is on the current screen, or if the mark is ".",
 * the whole current screen is piped.
d208 1
a208 1
 		return (pipe_data(cmd, mpos, bpos));
a254 3
#if MSDOS_COMPILER==WIN32C
	close_getchr();
#endif
d256 1
a256 1
	LSIGNAL(SIGPIPE, SIG_IGN);
d287 1
a287 4
	LSIGNAL(SIGPIPE, SIG_DFL);
#endif
#if MSDOS_COMPILER==WIN32C
	open_getchr();
a300 140

#ifdef _OSK
/*
 *    Popen, and Pclose, for OS-9.
 *
 *    Based on code copyright (c) 1988 by Wolfgang Ocker, Puchheim,
 *                                        Ulli Dessauer, Germering and
 *                                        Reimer Mellin, Muenchen
 *                                        (W-Germany)
 *
 *    These functions can be copied and distributed freely for any
 *    non-commercial purposes.  It can only be incorporated into
 *    commercial software with the written permission of the authors.
 *
 *    TOP-specific code stripped out and adapted for less by M.Gregorie, 1996
 *
 *    address:    Wolfgang Ocker
 *                Lochhauserstrasse 35a
 *                D-8039 Puchheim
 *                West Germany
 *
 *    e-mail:     weo@@altger.UUCP, ud@@altger.UUCP, ram@@altger.UUCP
 *                pyramid!tmpmbx!recco!weo
 *                pyramid!tmpmbx!nitmar!ud
 *                pyramid!tmpmbx!ramsys!ram
 *
 *                Martin Gregorie
 *                10 Sadlers Mead
 *                Harlow
 *                Essex, CM18 6HG
 *                U.K.
 *
 *                gregorie@@logica.com
 */
#include <strings.h>
#include <errno.h>
extern char **environ;
extern char *getenv();
extern int  os9forkc();
static int pids[_NFILE] = { 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0 };
/* 
 * p o p e n
 */
FILE *popen(name, mode)
	char *name;
	char *mode;
{
    int          fd, fd2, fdsav, pid;
    static char  *argv[] = {NULL, NULL, NULL };
    static char  cmd[200];
    static char  cmd_path[200];
    char         *cp;
    char         *shell;
    FILE         *r;
    if ((shell = getenv("SHELL")) == NULL)
        return(NULL);
    cp = name;
    while (*cp == ' ')
        cp++;
    strcpy(cmd_path, cp);
    if (cp = index(cmd_path, ' '))
        *cp++ = '\0';
    strcpy(cmd, "ex ");
    strcat(cmd, cmd_path);
    if (cp)
    {
        strcat(cmd, " ");
        strcat(cmd, cp);
    }
    argv[0] = shell;
    argv[1] = cmd;
    /*
         mode is "r" (stdout) or "w" (stdin)
    */
    switch(mode[0])
    {
        case 'w':   fd = 0;
                    break;
        case 'r':   fd = 1;
                    break;
        default:    return(NULL);
    }
    if (fd == 1)
        fflush(stdout);
    fdsav = dup(fd);
    close(fd);
 
    creat("/pipe", S_IWRITE+S_IREAD);
    pid = os9exec(os9forkc, argv[0], argv, environ, 0, 0, 3);
    fd2 = dup(fd);
    close(fd);
    dup(fdsav);
    close(fdsav);
    if (pid > 0)
    {
        pids[fd2] = pid;
        r = fdopen(fd2, mode);
    }
    else
    {
        close(fd2);
        r = NULL;
    }
    return(r);
}

/*
 * p c l o s e
 */
int pclose(fp)
	FILE *fp;
{
    unsigned int    status;
    int             pid;
    int             fd,
                    i;
    fd = fileno(fp);
    if (pids[fd] == 0)
        return(-1);
    fflush(fp);
    fclose(fp);
    while ((pid = wait(&status)) != -1)
        if (pid == pids[fd])
            break;
        else
            for (i = 0; i < _NFILE; i++)
                if (pids[i] == pid)
                {
                    pids[i] = 0;
                    break;
                }
    if (pid == -1)
        status = -1;
    pids[fd] = 0;
    return(status);
}
#endif /* _OSK */
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d52 1
a52 1
#if MSDOS_COMPILER && MSDOS_COMPILER!=WIN32C
a70 4
#if MSDOS_COMPILER==WIN32C
	if (*cmd == '\0')
		cmd = getenv("COMSPEC");
#else
a79 1
#endif
d136 3
a138 3
				int len = strlen(shell) + strlen(esccmd) + 5;
				p = (char *) ecalloc(len, sizeof(char));
				SNPRINTF3(p, len, "%s %s %s", shell, shell_coption(), esccmd);
d195 1
a195 1
#if MSDOS_COMPILER && MSDOS_COMPILER!=WIN32C
d370 140
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d141 1
a141 1
				size_t len = strlen(shell) + strlen(esccmd) + 5;
@


