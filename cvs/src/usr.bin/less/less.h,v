head	1.27;
access;
symbols
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.6
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.8.0.12
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.8
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.6
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.4
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.6.0.34
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.32
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.30
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.26
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.28
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.24
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.22
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.20
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.18
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.10
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.8
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.6
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.8
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.6
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2016.03.26.08.59.29;	author natano;	state Exp;
branches;
next	1.26;
commitid	aHC2gPZgpee3p3uV;

1.26
date	2016.01.29.16.13.17;	author mmcc;	state Exp;
branches;
next	1.25;
commitid	Dbgj9jceUiZ2eosU;

1.25
date	2016.01.29.16.10.48;	author mmcc;	state Exp;
branches;
next	1.24;
commitid	XYEYIHOr3I7SDqwd;

1.24
date	2016.01.26.01.51.06;	author mmcc;	state Exp;
branches;
next	1.23;
commitid	srJYJwfAmHQyrX7w;

1.23
date	2016.01.15.20.49.59;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	UgVQIBS5JMWdKPwM;

1.22
date	2016.01.13.22.47.45;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	Uz3YEYZCcKwdp847;

1.21
date	2016.01.12.17.48.04;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	O36S2Tb0ReI34f9s;

1.20
date	2016.01.09.17.34.43;	author mmcc;	state Exp;
branches;
next	1.19;
commitid	gBXOEcHR6DypqbaI;

1.19
date	2015.11.09.16.46.43;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	rJ6tmXbM6ZZSV1zd;

1.18
date	2015.11.09.16.44.07;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	m4uIjOimh16xQ6Tb;

1.17
date	2015.11.09.16.42.35;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	mkNNke62XFQvJVUG;

1.16
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	ZtGimechwgSRYqRW;

1.15
date	2015.11.09.04.10.57;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	E4Lg0tTt0vh4nd97;

1.14
date	2015.11.09.02.59.06;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	krM8GIm0ktfoy1dx;

1.13
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.12;
commitid	QKrr6AuGzNx9nehL;

1.12
date	2015.11.06.00.02.22;	author nicm;	state Exp;
branches;
next	1.11;
commitid	192w0RBe8ykYa3qb;

1.11
date	2015.11.05.22.18.27;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	ZMka2O4VZNCDWtqb;

1.10
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.9;
commitid	yKv9Ck9ZDgwWTRTo;

1.9
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.8;

1.8
date	2011.09.21.19.01.49;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.07.03.35.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.14.14.33.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.13.18.26.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.01.58.02;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	99.02.20.19.00.38;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.44;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.44;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.05;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.48;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Improve handling of ambiguous overstrike sequences. A sequence of _\b_
can either mean an underlined underscore or a bold underscore. This
ambiguity can be 'resolved' by takeing the state of the surrounding text
into account. If surrounded by bold text, the result should probably be
bold and likewise for underlined. less(1) previously only looked at the
preceding text and ul(1) didn't examine the context at all.

tweaks and ok schwarze
ok tb (on a previous version of the diff)
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Standard include file for "less".
 */

#include "defines.h"

#include <sys/types.h>

#include <ctype.h>
#include <fcntl.h>
#include <libgen.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <wctype.h>

/*
 * Simple lowercase test which can be used during option processing
 * (before options are parsed which might tell us what charset to use).
 */

#undef IS_SPACE
#undef IS_DIGIT

#define	IS_SPACE(c)	isspace((unsigned char)(c))
#define	IS_DIGIT(c)	isdigit((unsigned char)(c))

#define	IS_CSI_START(c)	(((LWCHAR)(c)) == ESC || (((LWCHAR)(c)) == CSI))

#ifndef TRUE
#define	TRUE		1
#endif
#ifndef FALSE
#define	FALSE		0
#endif

#define	OPT_OFF		0
#define	OPT_ON		1
#define	OPT_ONPLUS	2

/*
 * Special types and constants.
 */
typedef unsigned long LWCHAR;
#define	MIN_LINENUM_WIDTH  7	/* Min printing width of a line number */
#define	MAX_UTF_CHAR_LEN   6	/* Max bytes in one UTF-8 char */

#define	SHELL_META_QUEST 1

/*
 * An IFILE represents an input file.
 */
#define	IFILE		void *

/*
 * The structure used to represent a "screen position".
 * This consists of a file position, and a screen line number.
 * The meaning is that the line starting at the given file
 * position is displayed on the ln-th line of the screen.
 * (Screen lines before ln are empty.)
 */
struct scrpos {
	off_t pos;
	int ln;
};

typedef union parg {
	char *p_string;
	int p_int;
	off_t p_linenum;
} PARG;

struct textlist {
	char *string;
	char *endstring;
};

#define	EOI		(-1)

#define	READ_INTR	(-2)

/* A fraction is represented by an int n; the fraction is n/NUM_FRAC_DENOM */
#define	NUM_FRAC_DENOM			1000000
#define	NUM_LOG_FRAC_DENOM		6

/* How quiet should we be? */
#define	NOT_QUIET	0	/* Ring bell at eof and for errors */
#define	LITTLE_QUIET	1	/* Ring bell only for errors */
#define	VERY_QUIET	2	/* Never ring bell */

/* How should we prompt? */
#define	PR_SHORT	0	/* Prompt with colon */
#define	PR_MEDIUM	1	/* Prompt with message */
#define	PR_LONG		2	/* Prompt with longer message */

/* How should we handle backspaces? */
#define	BS_SPECIAL	0	/* Do special things for underlining and bold */
#define	BS_NORMAL	1	/* \b treated as normal char; actually output */
#define	BS_CONTROL	2	/* \b treated as control char; prints as ^H */

/* How should we search? */
#define	SRCH_FORW	(1 << 0)  /* Search forward from current position */
#define	SRCH_BACK	(1 << 1)  /* Search backward from current position */
#define	SRCH_NO_MOVE	(1 << 2)  /* Highlight, but don't move */
#define	SRCH_FIND_ALL	(1 << 4)  /* Find and highlight all matches */
#define	SRCH_NO_MATCH	(1 << 8)  /* Search for non-matching lines */
#define	SRCH_PAST_EOF	(1 << 9)  /* Search past end-of-file, into next file */
#define	SRCH_FIRST_FILE	(1 << 10) /* Search starting at the first file */
#define	SRCH_NO_REGEX	(1 << 12) /* Don't use regular expressions */
#define	SRCH_FILTER	(1 << 13) /* Search is for '&' (filter) command */
#define	SRCH_AFTER_TARGET (1 << 14) /* Start search after the target line */

#define	SRCH_REVERSE(t)	(((t) & SRCH_FORW) ? \
				(((t) & ~SRCH_FORW) | SRCH_BACK) : \
				(((t) & ~SRCH_BACK) | SRCH_FORW))

/* */
#define	NO_MCA		0
#define	MCA_DONE	1
#define	MCA_MORE	2

#define	CC_OK		0	/* Char was accepted & processed */
#define	CC_QUIT		1	/* Char was a request to abort current cmd */
#define	CC_ERROR	2	/* Char could not be accepted due to error */
#define	CC_PASS		3	/* Char was rejected (internal) */

#define	CF_QUIT_ON_ERASE 0001   /* Abort cmd if its entirely erased */

/* Special char bit-flags used to tell put_line() to do something special */
#define	AT_NORMAL	(0)
#define	AT_UNDERLINE	(1 << 0)
#define	AT_BOLD		(1 << 1)
#define	AT_BLINK	(1 << 2)
#define	AT_STANDOUT	(1 << 3)
#define	AT_ANSI		(1 << 4)  /* Content-supplied "ANSI" escape sequence */
#define	AT_BINARY	(1 << 5)  /* LESS*BINFMT representation */
#define	AT_HILITE	(1 << 6)  /* Internal highlights (e.g., for search) */
#define	AT_INDET	(1 << 7)  /* Indeterminate: either bold or underline */

#define	CONTROL(c)	((c)&037)

#define	ESC		CONTROL('[')
#define	CSI		((unsigned char)'\233')

#define	S_INTERRUPT	01
#define	S_STOP		02
#define	S_WINCH		04
#define	ABORT_SIGS()	(sigs & (S_INTERRUPT|S_STOP))

#define	QUIT_OK		0
#define	QUIT_ERROR	1
#define	QUIT_INTERRUPT	2
#define	QUIT_SAVED_STATUS (-1)

#define	FOLLOW_DESC	0
#define	FOLLOW_NAME	1

/* filestate flags */
#define	CH_CANSEEK	001
#define	CH_KEEPOPEN	002
#define	CH_POPENED	004
#define	CH_HELPFILE	010
#define	CH_NODATA	020	/* Special case for zero length files */


#define	ch_zero()	(0)

#define	FAKE_EMPTYFILE	"@@/\\less/\\empty/\\file/\\@@"

/* Flags for cvt_text */
#define	CVT_TO_LC	01	/* Convert upper-case to lower-case */
#define	CVT_BS		02	/* Do backspace processing */
#define	CVT_CRLF	04	/* Remove CR after LF */
#define	CVT_ANSI	010	/* Remove ANSI escape sequences */

#include "funcs.h"

/* Functions not included in funcs.h */
void postoa(off_t, char *, size_t);
void inttoa(int, char *, size_t);
@


1.26
log
@sort includes

from Michael Reed
@
text
@d152 1
@


1.25
log
@remove unneeded CHAR_BIT macro

from Michael Reed
@
text
@d18 1
a18 1
/* Library function declarations */
d20 1
a20 2
#include <sys/types.h>
#include <stdio.h>
d22 1
a22 3
#include <unistd.h>
#include <ctype.h>
#include <wctype.h>
d24 2
d28 2
a29 2
#include <libgen.h>
#include <signal.h>
@


1.24
log
@Remove a fancy macro that calculates the necessary buffer size for
int-to-str conversions and just use constants instead. The only binary
change is caused by using an unnecessarily large buffer for an int. This
is a consequence of simplifying some code that will be gone soon.

ok nicm@@
@
text
@a55 4
#ifndef CHAR_BIT
#define	CHAR_BIT 8
#endif

@


1.23
log
@Use quotes rather than angle brackets for local header. Fixes building
with Clang 3.7.

ok millert@@
@
text
@a60 7
 * Upper bound on the string length of an integer converted to string.
 * 302 / 1000 is ceil (log10 (2.0)).  Subtract 1 for the sign bit;
 * add 1 for integer division truncation; add 1 more for a minus sign.
 */
#define	INT_STRLEN_BOUND(t) ((sizeof (t) * CHAR_BIT - 1) * 302 / 1000 + 1 + 1)

/*
@


1.22
log
@unify two identical function pairs now that we've removed less's off_t
aliases

ok nicm@@
@
text
@d16 1
a16 5
/*
 * Include the file of compile-time options.
 * The <> make cc search for it in -I., not srcdir.
 */
#include <defines.h>
@


1.21
log
@Remove LINUNUM, a needless alias for off_t. Also, remove a redundant
condition.

ok nicm@@
@
text
@a208 1
void linenumtoa(off_t, char *, size_t);
@


1.20
log
@Remove superfluous and barely used macro aliases for wctype.h functions.

ok nicm@@
@
text
@a74 1
typedef off_t		LINENUM;
d100 1
a100 1
	LINENUM p_linenum;
d209 1
a209 1
void linenumtoa(LINENUM, char *, size_t);
@


1.19
log
@NULL_IFILE has no weird use patterns.  NULL is sufficient.
@
text
@a40 4
#undef IS_UPPER
#undef IS_LOWER
#undef TO_UPPER
#undef TO_LOWER
a42 5

#define	IS_UPPER(c)	iswupper(c)
#define	IS_LOWER(c)	iswlower(c)
#define	TO_UPPER(c)	towupper(c)
#define	TO_LOWER(c)	towlower(c)
@


1.18
log
@define of SPACES_IN_FILENAMES is never used
@
text
@a93 1
#define	NULL_IFILE	(NULL)
@


1.17
log
@use (off_t)-1 rather than a BAD_LSEEK wrapper
@
text
@a89 2
#define	SPACES_IN_FILENAMES 1

@


1.16
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@a68 2
#define	BAD_LSEEK	((off_t)-1)

@


1.15
log
@cleanup struct definitions
@
text
@a117 2
#define	NULL_PARG	((PARG *)NULL)

@


1.14
log
@do not need wrappers around O_RDONLY and such
@
text
@d112 1
a112 2
typedef union parg
{
d120 1
a120 2
struct textlist
{
@


1.13
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@a89 6
/*
 * Flags for open()
 */
#define	OPEN_READ	(O_RDONLY)
#define	OPEN_APPEND	(O_APPEND|O_WRONLY)

@


1.12
log
@Remove LSIGNAL which is just the same as lsignal() now.
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.11
log
@whitespace
@
text
@a200 2
#define	LSIGNAL(sig, func)	lsignal(sig, func)

@


1.10
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d221 1
a221 1
#define	CH_NODATA  	020	/* Special case for zero length files */
@


1.9
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@a8 3

#define NEWBOT 1

d10 2
a11 1
 * Standard include file for "less".
d15 1
a15 1
 * Defines for MSDOS_COMPILER.
a16 4
#define	MSOFTC		1	/* Microsoft C */
#define	BORLANDC	2	/* Borland C */
#define	WIN32C		3	/* Windows (Borland C or Microsoft C) */
#define	DJGPPC		4	/* DJGPP C */
a23 26
#ifdef _SEQUENT_
/*
 * Kludge for Sequent Dynix systems that have sigsetmask, but
 * it's not compatible with the way less calls it.
 * {{ Do other systems need this? }}
 */
#undef HAVE_SIGSETMASK
#endif

/*
 * Language details.
 */
#if HAVE_VOID
#define	VOID_POINTER	void *
#else
#define	VOID_POINTER	char *
#define	void  int
#endif
#if HAVE_CONST
#define	constant	const
#else
#define	constant
#endif

#define	public		/* PUBLIC FUNCTION */

a25 1
#if HAVE_SYS_TYPES_H
a26 2
#endif
#if HAVE_STDIO_H
a27 2
#endif
#if HAVE_FCNTL_H
a28 2
#endif
#if HAVE_UNISTD_H
a29 2
#endif
#if HAVE_CTYPE_H
a30 2
#endif
#if HAVE_WCTYPE_H
a31 2
#endif
#if HAVE_LIMITS_H
a32 2
#endif
#if HAVE_STDLIB_H
a33 2
#endif
#if HAVE_STRING_H
d35 1
a35 1
#endif
a37 28
/* OS-specific includes */
#ifdef _OSK
#include <modes.h>
#include <strings.h>
#endif

#ifdef __TANDEM
#include <floss.h>
#endif

#if MSDOS_COMPILER==WIN32C || OS2
#include <io.h>
#endif

#if MSDOS_COMPILER==DJGPPC
#include <io.h>
#include <sys/exceptn.h>
#include <conio.h>
#include <pc.h>
#endif

#if !HAVE_STDLIB_H
char *getenv();
off_t lseek();
VOID_POINTER calloc();
void free();
#endif

a41 4
#define ASCII_IS_UPPER(c)	((c) >= 'A' && (c) <= 'Z')
#define ASCII_IS_LOWER(c)	((c) >= 'a' && (c) <= 'z')
#define	ASCII_TO_UPPER(c)	((c) - 'a' + 'A')
#define	ASCII_TO_LOWER(c)	((c) - 'A' + 'a')
a49 1
#if HAVE_WCTYPE
a53 19
#else
#if HAVE_UPPER_LOWER
#define	IS_UPPER(c)	isupper((unsigned char) (c))
#define	IS_LOWER(c)	islower((unsigned char) (c))
#define	TO_UPPER(c)	toupper((unsigned char) (c))
#define	TO_LOWER(c)	tolower((unsigned char) (c))
#else
#define	IS_UPPER(c)	ASCII_IS_UPPER(c)
#define	IS_LOWER(c)	ASCII_IS_LOWER(c)
#define	TO_UPPER(c)	ASCII_TO_UPPER(c)
#define	TO_LOWER(c)	ASCII_TO_LOWER(c)
#endif
#endif

#ifdef isspace
#define IS_SPACE(c)	isspace((unsigned char)(c))
#else
#define IS_SPACE(c)	((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) == '\r' || (c) == '\f')
#endif
d55 2
a56 7
#ifdef isdigit
#define IS_DIGIT(c)	isdigit((unsigned char)(c))
#else
#define IS_DIGIT(c)	((c) >= '0' && (c) <= '9')
#endif

#define IS_CSI_START(c)	(((LWCHAR)(c)) == ESC || (((LWCHAR)(c)) == CSI))
d58 1
a58 3
#ifndef NULL
#define	NULL	0
#endif
a70 19
#if !HAVE_MEMCPY
#ifndef memcpy
#define	memcpy(to,from,len)	bcopy((from),(to),(len))
#endif
#endif

#if HAVE_SNPRINTF
#define SNPRINTF1(str, size, fmt, v1)             snprintf((str), (size), (fmt), (v1))
#define SNPRINTF2(str, size, fmt, v1, v2)         snprintf((str), (size), (fmt), (v1), (v2))
#define SNPRINTF3(str, size, fmt, v1, v2, v3)     snprintf((str), (size), (fmt), (v1), (v2), (v3))
#define SNPRINTF4(str, size, fmt, v1, v2, v3, v4) snprintf((str), (size), (fmt), (v1), (v2), (v3), (v4))
#else
/* Use unsafe sprintf if we don't have snprintf. */
#define SNPRINTF1(str, size, fmt, v1)             sprintf((str), (fmt), (v1))
#define SNPRINTF2(str, size, fmt, v1, v2)         sprintf((str), (fmt), (v1), (v2))
#define SNPRINTF3(str, size, fmt, v1, v2, v3)     sprintf((str), (fmt), (v1), (v2), (v3))
#define SNPRINTF4(str, size, fmt, v1, v2, v3, v4) sprintf((str), (fmt), (v1), (v2), (v3), (v4))
#endif

a72 7
#ifndef SEEK_SET
#define SEEK_SET 0
#endif
#ifndef SEEK_END
#define SEEK_END 2
#endif

d74 1
a74 1
#define CHAR_BIT 8
d82 1
a82 1
#define INT_STRLEN_BOUND(t) ((sizeof(t) * CHAR_BIT - 1) * 302 / 1000 + 1 + 1)
a87 1
typedef off_t		POSITION;
d89 2
a90 4
#define MIN_LINENUM_WIDTH  7	/* Min printing width of a line number */
#define MAX_UTF_CHAR_LEN   6	/* Max bytes in one UTF-8 char */

#define	NULL_POSITION	((POSITION)(-1))
a94 7
#if MSDOS_COMPILER || OS2
#define	OPEN_READ	(O_RDONLY|O_BINARY)
#else
#ifdef _OSK
#define	OPEN_READ	(S_IREAD)
#else
#ifdef O_RDONLY
a95 7
#else
#define	OPEN_READ	(0)
#endif
#endif
#endif

#if defined(O_WRONLY) && defined(O_APPEND)
a96 7
#else
#ifdef _OSK
#define OPEN_APPEND	(S_IWRITE)
#else
#define	OPEN_APPEND	(1)
#endif
#endif
a97 19
/*
 * Set a file descriptor to binary mode.
 */
#if MSDOS_COMPILER==MSOFTC
#define	SET_BINARY(f)	_setmode(f, _O_BINARY);
#else
#if MSDOS_COMPILER || OS2
#define	SET_BINARY(f)	setmode(f, O_BINARY)
#else
#define	SET_BINARY(f)
#endif
#endif

/*
 * Does the shell treat "?" as a metacharacter?
 */
#if MSDOS_COMPILER || OS2 || _OSK
#define	SHELL_META_QUEST 0
#else
a98 1
#endif
d105 2
a106 2
#define	IFILE		VOID_POINTER
#define	NULL_IFILE	((IFILE)NULL)
d115 2
a116 3
struct scrpos
{
	POSITION pos;
d140 2
a141 2
#define NUM_FRAC_DENOM			1000000
#define NUM_LOG_FRAC_DENOM		6
d159 10
a168 10
#define	SRCH_FORW       (1 << 0)  /* Search forward from current position */
#define	SRCH_BACK       (1 << 1)  /* Search backward from current position */
#define SRCH_NO_MOVE    (1 << 2)  /* Highlight, but don't move */
#define SRCH_FIND_ALL   (1 << 4)  /* Find and highlight all matches */
#define SRCH_NO_MATCH   (1 << 8)  /* Search for non-matching lines */
#define SRCH_PAST_EOF   (1 << 9)  /* Search past end-of-file, into next file */
#define SRCH_FIRST_FILE (1 << 10) /* Search starting at the first file */
#define SRCH_NO_REGEX   (1 << 12) /* Don't use regular expressions */
#define SRCH_FILTER     (1 << 13) /* Search is for '&' (filter) command */
#define SRCH_AFTER_TARGET (1 << 14) /* Start search after the target line */
d184 1
a184 1
#define CF_QUIT_ON_ERASE 0001   /* Abort cmd if its entirely erased */
a195 69
#if '0' == 240
#define IS_EBCDIC_HOST 1
#endif

#if IS_EBCDIC_HOST
/*
 * Long definition for EBCDIC.
 * Since the argument is usually a constant, this macro normally compiles
 * into a constant.
 */
#define CONTROL(c) ( \
	(c)=='[' ? '\047' : \
	(c)=='a' ? '\001' : \
	(c)=='b' ? '\002' : \
	(c)=='c' ? '\003' : \
	(c)=='d' ? '\067' : \
	(c)=='e' ? '\055' : \
	(c)=='f' ? '\056' : \
	(c)=='g' ? '\057' : \
	(c)=='h' ? '\026' : \
	(c)=='i' ? '\005' : \
	(c)=='j' ? '\025' : \
	(c)=='k' ? '\013' : \
	(c)=='l' ? '\014' : \
	(c)=='m' ? '\015' : \
	(c)=='n' ? '\016' : \
	(c)=='o' ? '\017' : \
	(c)=='p' ? '\020' : \
	(c)=='q' ? '\021' : \
	(c)=='r' ? '\022' : \
	(c)=='s' ? '\023' : \
	(c)=='t' ? '\074' : \
	(c)=='u' ? '\075' : \
	(c)=='v' ? '\062' : \
	(c)=='w' ? '\046' : \
	(c)=='x' ? '\030' : \
	(c)=='y' ? '\031' : \
	(c)=='z' ? '\077' : \
	(c)=='A' ? '\001' : \
	(c)=='B' ? '\002' : \
	(c)=='C' ? '\003' : \
	(c)=='D' ? '\067' : \
	(c)=='E' ? '\055' : \
	(c)=='F' ? '\056' : \
	(c)=='G' ? '\057' : \
	(c)=='H' ? '\026' : \
	(c)=='I' ? '\005' : \
	(c)=='J' ? '\025' : \
	(c)=='K' ? '\013' : \
	(c)=='L' ? '\014' : \
	(c)=='M' ? '\015' : \
	(c)=='N' ? '\016' : \
	(c)=='O' ? '\017' : \
	(c)=='P' ? '\020' : \
	(c)=='Q' ? '\021' : \
	(c)=='R' ? '\022' : \
	(c)=='S' ? '\023' : \
	(c)=='T' ? '\074' : \
	(c)=='U' ? '\075' : \
	(c)=='V' ? '\062' : \
	(c)=='W' ? '\046' : \
	(c)=='X' ? '\030' : \
	(c)=='Y' ? '\031' : \
	(c)=='Z' ? '\077' : \
	(c)=='|' ? '\031' : \
	(c)=='\\' ? '\034' : \
	(c)=='^' ? '\036' : \
	(c)&077)
#else
a196 1
#endif /* IS_EBCDIC_HOST */
d201 1
a201 19
#if _OSK_MWC32
#define	LSIGNAL(sig,func)	os9_signal(sig,func)
#else
#define	LSIGNAL(sig,func)	lsignal(sig,func)
#endif

#if HAVE_SIGPROCMASK
#if HAVE_SIGSET_T
#else
#undef HAVE_SIGPROCMASK
#endif
#endif
#if HAVE_SIGPROCMASK
#if HAVE_SIGEMPTYSET
#else
#undef  sigemptyset
#define sigemptyset(mp) *(mp) = 0
#endif
#endif
d205 1
a205 1
#define S_WINCH		04
d213 2
a214 2
#define FOLLOW_DESC     0
#define FOLLOW_NAME     1
d224 1
a224 1
#define	ch_zero()	((POSITION)0)
d226 1
a226 2
#define	FAKE_HELPFILE	"@@/\\less/\\help/\\file/\\@@"
#define FAKE_EMPTYFILE	"@@/\\less/\\empty/\\file/\\@@"
d237 3
a239 3
void postoa();
void linenumtoa();
void inttoa();
@


1.8
log
@Use volatile sig_atomic_t, not int, for the sigs variable.  Also
move the call to bell() out of u_interrupt() (a signal handler).
OK and with help from deraadt@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d488 2
d492 3
@


1.7
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d86 1
@


1.6
log
@Use interruptible syscalls instead of setjmp/longjmp.  This makes
less's signal handlers safe.  No one has reported problems so far...
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d11 1
d74 3
d86 2
d92 5
d100 1
d119 41
a159 10
#define SIMPLE_IS_UPPER(c)	((c) >= 'A' && (c) <= 'Z')
#define SIMPLE_IS_LOWER(c)	((c) >= 'a' && (c) <= 'z')
#define	SIMPLE_TO_UPPER(c)	((c) - 'a' + 'A')
#define	SIMPLE_TO_LOWER(c)	((c) - 'A' + 'a')

#if !HAVE_UPPER_LOWER
#define	isupper(c)	SIMPLE_IS_UPPER(c)
#define	islower(c)	SIMPLE_IS_LOWER(c)
#define	toupper(c)	SIMPLE_TO_UPPER(c)
#define	tolower(c)	SIMPLE_TO_LOWER(c)
d162 2
d185 13
d200 7
d221 1
d225 1
d318 4
d338 10
a347 8
#define	SRCH_FORW	000001	/* Search forward from current position */
#define	SRCH_BACK	000002	/* Search backward from current position */
#define	SRCH_NO_MOVE	000004	/* Highlight, but don't move */
#define	SRCH_FIND_ALL	000010	/* Find and highlight all matches */
#define	SRCH_NO_MATCH	000100	/* Search for non-matching lines */
#define	SRCH_PAST_EOF	000200	/* Search past end-of-file, into next file */
#define	SRCH_FIRST_FILE	000400	/* Search starting at the first file */
#define	SRCH_NO_REGEX	001000	/* Don't use regular expressions */
d365 1
a365 1
/* Special chars used to tell put_line() to do something special */
d367 7
a373 5
#define	AT_UNDERLINE	(1)
#define	AT_BOLD		(2)
#define	AT_BLINK	(3)
#define	AT_INVIS	(4)
#define	AT_STANDOUT	(5)
d448 1
d477 1
d480 3
d487 1
d490 6
@


1.5
log
@o go back to using a help file instead of embedding it in the binary
o deal with HELPFILE not being defined
o add a SMALL definition to make a smaller less for the boot floppies
This still needs to be pared down a bit for the SMALL case
@
text
@d377 1
a377 1
#define	LSIGNAL(sig,func)	signal(sig,func)
@


1.4
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@a406 1
#define	CH_HELPFILE	010
a408 2

#define	FAKE_HELPFILE	"@@/\\less/\\help/\\file/\\@@"
@


1.3
log
@$OpenBSD$
@
text
@a0 2
/*	$OpenBSD$	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d17 8
d48 5
d73 4
a76 1
#if STDC_HEADERS
d78 2
d82 13
d96 1
a96 1
#if !STDC_HEADERS
d103 9
d113 4
a116 4
#define	isupper(c)	((c) >= 'A' && (c) <= 'Z')
#define	islower(c)	((c) >= 'a' && (c) <= 'z')
#define	toupper(c)	((c) - 'a' + 'A')
#define	tolower(c)	((c) - 'A' + 'a')
d134 1
a134 1
#ifndef HAVE_MEMCPY
d142 11
d157 2
a158 5
/*
 * {{ Warning: if POSITION is changed to other than "long",
 *    you may have to change some of the printfs which use "%ld"
 *    to print a variable of type POSITION. }}
 */
d165 1
a165 1
#if MSOFTC || OS2
d168 6
d176 4
a179 1
#if MSOFTC || OS2
d182 3
d187 1
d189 18
a206 2
#if MSOFTC || OS2
#define	OPEN_TTYIN()	open("CON", O_BINARY|O_RDONLY)
d208 1
a208 1
#define	OPEN_TTYIN()	open("/dev/tty", 0)
d211 2
d236 1
d267 8
a274 6
#define	SRCH_FORW	0001	/* Search forward from current position */
#define	SRCH_BACK	0002	/* Search backward from current position */
#define	SRCH_FIND_ALL	0010	/* Find and highlight all matches */
#define	SRCH_NOMATCH	0100	/* Search for non-matching lines */
#define	SRCH_PAST_EOF	0200	/* Search past end-of-file, into next file */
#define	SRCH_FIRST_FILE	0400	/* Search starting at the first file */
d290 2
d300 69
d370 2
d374 19
a392 1
#define	SIGNAL(sig,func)	signal(sig,func)
d407 1
d411 2
d414 5
@


1.2
log
@First step at supporting files > 2gig.  Use off_t as POSITION
and replace get_maxlong() with a get_maxpos() and modify percentage()
appropriately.  There are still problems seeking to the end of a large
file and line numbers should probably be 64bit (or at the very least
unsigned).  This has been sitting in my tree for quite some time now
so I am committing what I have now since I don't know when I'll have
a chance to really finish it.
@
text
@d1 2
@


1.1
log
@Initial revision
@
text
@d121 1
a121 1
typedef long		POSITION;
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
a32 8
 * Defines for MSDOS_COMPILER.
 */
#define	MSOFTC		1	/* Microsoft C */
#define	BORLANDC	2	/* Borland C */
#define	WIN32C		3	/* Windows (Borland C or Microsoft C) */
#define	DJGPPC		4	/* DJGPP C */

/*
a55 5
#if HAVE_CONST
#define	constant	const
#else
#define	constant
#endif
d76 1
a76 4
#if HAVE_LIMITS_H
#include <limits.h>
#endif
#if HAVE_STDLIB_H
a77 2
#endif
#if HAVE_STRING_H
a79 13
#ifdef _OSK
#include <modes.h>
#include <strings.h>
#endif
#if MSDOS_COMPILER==WIN32C || OS2
#include <io.h>
#endif
#if MSDOS_COMPILER==DJGPPC
#include <io.h>
#include <sys/exceptn.h>
#include <conio.h>
#include <pc.h>
#endif
d81 1
a81 1
#if !HAVE_STDLIB_H
a87 9
/*
 * Simple lowercase test which can be used during option processing
 * (before options are parsed which might tell us what charset to use).
 */
#define SIMPLE_IS_UPPER(c)	((c) >= 'A' && (c) <= 'Z')
#define SIMPLE_IS_LOWER(c)	((c) >= 'a' && (c) <= 'z')
#define	SIMPLE_TO_UPPER(c)	((c) - 'a' + 'A')
#define	SIMPLE_TO_LOWER(c)	((c) - 'A' + 'a')

d89 4
a92 4
#define	isupper(c)	SIMPLE_IS_UPPER(c)
#define	islower(c)	SIMPLE_IS_LOWER(c)
#define	toupper(c)	SIMPLE_TO_UPPER(c)
#define	tolower(c)	SIMPLE_TO_LOWER(c)
d110 1
a110 1
#if !HAVE_MEMCPY
a117 4
#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif

d119 1
a119 3
 * Upper bound on the string length of an integer converted to string.
 * 302 / 1000 is ceil (log10 (2.0)).  Subtract 1 for the sign bit;
 * add 1 for integer division truncation; add 1 more for a minus sign.
d121 1
a121 2
#define INT_STRLEN_BOUND(t) ((sizeof(t) * CHAR_BIT - 1) * 302 / 1000 + 1 + 1)

d123 3
a125 1
 * Special types and constants.
a126 3
typedef off_t		POSITION;
typedef off_t		LINENUM;
#define MIN_LINENUM_WIDTH  7	/* Min printing width of a line number */
d133 1
a133 1
#if MSDOS_COMPILER || OS2
a135 6
#ifdef _OSK
#define	OPEN_READ	(S_IREAD)
#else
#ifdef O_RDONLY
#define	OPEN_READ	(O_RDONLY)
#else
d138 1
a138 4
#endif
#endif

#if defined(O_WRONLY) && defined(O_APPEND)
a140 3
#ifdef _OSK
#define OPEN_APPEND	(S_IWRITE)
#else
a142 1
#endif
d144 2
a145 5
/*
 * Set a file descriptor to binary mode.
 */
#if MSDOS_COMPILER==MSOFTC
#define	SET_BINARY(f)	_setmode(f, _O_BINARY);
d147 1
a147 5
#if MSDOS_COMPILER || OS2
#define	SET_BINARY(f)	setmode(f, O_BINARY)
#else
#define	SET_BINARY(f)
#endif
a150 11
 * Does the shell treat "?" as a metacharacter?
 */
#if MSDOS_COMPILER || OS2 || _OSK
#define	SHELL_META_QUEST 0
#else
#define	SHELL_META_QUEST 1
#endif

#define	SPACES_IN_FILENAMES 1

/*
a172 1
	LINENUM p_linenum;
d203 6
a208 8
#define	SRCH_FORW	000001	/* Search forward from current position */
#define	SRCH_BACK	000002	/* Search backward from current position */
#define	SRCH_NO_MOVE	000004	/* Highlight, but don't move */
#define	SRCH_FIND_ALL	000010	/* Find and highlight all matches */
#define	SRCH_NO_MATCH	000100	/* Search for non-matching lines */
#define	SRCH_PAST_EOF	000200	/* Search past end-of-file, into next file */
#define	SRCH_FIRST_FILE	000400	/* Search starting at the first file */
#define	SRCH_NO_REGEX	001000	/* Don't use regular expressions */
a223 2
#define CF_QUIT_ON_ERASE 0001   /* Abort cmd if its entirely erased */

a231 69
#if '0' == 240
#define IS_EBCDIC_HOST 1
#endif

#if IS_EBCDIC_HOST
/*
 * Long definition for EBCDIC.
 * Since the argument is usually a constant, this macro normally compiles
 * into a constant.
 */
#define CONTROL(c) ( \
	(c)=='[' ? '\047' : \
	(c)=='a' ? '\001' : \
	(c)=='b' ? '\002' : \
	(c)=='c' ? '\003' : \
	(c)=='d' ? '\067' : \
	(c)=='e' ? '\055' : \
	(c)=='f' ? '\056' : \
	(c)=='g' ? '\057' : \
	(c)=='h' ? '\026' : \
	(c)=='i' ? '\005' : \
	(c)=='j' ? '\025' : \
	(c)=='k' ? '\013' : \
	(c)=='l' ? '\014' : \
	(c)=='m' ? '\015' : \
	(c)=='n' ? '\016' : \
	(c)=='o' ? '\017' : \
	(c)=='p' ? '\020' : \
	(c)=='q' ? '\021' : \
	(c)=='r' ? '\022' : \
	(c)=='s' ? '\023' : \
	(c)=='t' ? '\074' : \
	(c)=='u' ? '\075' : \
	(c)=='v' ? '\062' : \
	(c)=='w' ? '\046' : \
	(c)=='x' ? '\030' : \
	(c)=='y' ? '\031' : \
	(c)=='z' ? '\077' : \
	(c)=='A' ? '\001' : \
	(c)=='B' ? '\002' : \
	(c)=='C' ? '\003' : \
	(c)=='D' ? '\067' : \
	(c)=='E' ? '\055' : \
	(c)=='F' ? '\056' : \
	(c)=='G' ? '\057' : \
	(c)=='H' ? '\026' : \
	(c)=='I' ? '\005' : \
	(c)=='J' ? '\025' : \
	(c)=='K' ? '\013' : \
	(c)=='L' ? '\014' : \
	(c)=='M' ? '\015' : \
	(c)=='N' ? '\016' : \
	(c)=='O' ? '\017' : \
	(c)=='P' ? '\020' : \
	(c)=='Q' ? '\021' : \
	(c)=='R' ? '\022' : \
	(c)=='S' ? '\023' : \
	(c)=='T' ? '\074' : \
	(c)=='U' ? '\075' : \
	(c)=='V' ? '\062' : \
	(c)=='W' ? '\046' : \
	(c)=='X' ? '\030' : \
	(c)=='Y' ? '\031' : \
	(c)=='Z' ? '\077' : \
	(c)=='|' ? '\031' : \
	(c)=='\\' ? '\034' : \
	(c)=='^' ? '\036' : \
	(c)&077)
#else
a232 2
#endif /* IS_EBCDIC_HOST */

d235 1
a235 19
#if _OSK_MWC32
#define	LSIGNAL(sig,func)	os9_signal(sig,func)
#else
#define	LSIGNAL(sig,func)	signal(sig,func)
#endif

#if HAVE_SIGPROCMASK
#if HAVE_SIGSET_T
#else
#undef HAVE_SIGPROCMASK
#endif
#endif
#if HAVE_SIGPROCMASK
#if HAVE_SIGEMPTYSET
#else
#undef  sigemptyset
#define sigemptyset(mp) *(mp) = 0
#endif
#endif
a249 1
#define	CH_HELPFILE	010
a252 2
#define	FAKE_HELPFILE	"@@/\\less/\\help/\\file/\\@@"

a253 5

/* Functions not included in funcs.h */
void postoa();
void linenumtoa();
void inttoa();
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
a10 1
#define NEWBOT 1
a72 3
#if HAVE_WCTYPE_H
#include <wctype.h>
#endif
a81 2

/* OS-specific includes */
a85 5

#ifdef __TANDEM
#include <floss.h>
#endif

a88 1

d107 10
a116 41
#define ASCII_IS_UPPER(c)	((c) >= 'A' && (c) <= 'Z')
#define ASCII_IS_LOWER(c)	((c) >= 'a' && (c) <= 'z')
#define	ASCII_TO_UPPER(c)	((c) - 'a' + 'A')
#define	ASCII_TO_LOWER(c)	((c) - 'A' + 'a')

#undef IS_UPPER
#undef IS_LOWER
#undef TO_UPPER
#undef TO_LOWER
#undef IS_SPACE
#undef IS_DIGIT

#if HAVE_WCTYPE
#define	IS_UPPER(c)	iswupper(c)
#define	IS_LOWER(c)	iswlower(c)
#define	TO_UPPER(c)	towupper(c)
#define	TO_LOWER(c)	towlower(c)
#else
#if HAVE_UPPER_LOWER
#define	IS_UPPER(c)	isupper((unsigned char) (c))
#define	IS_LOWER(c)	islower((unsigned char) (c))
#define	TO_UPPER(c)	toupper((unsigned char) (c))
#define	TO_LOWER(c)	tolower((unsigned char) (c))
#else
#define	IS_UPPER(c)	ASCII_IS_UPPER(c)
#define	IS_LOWER(c)	ASCII_IS_LOWER(c)
#define	TO_UPPER(c)	ASCII_TO_UPPER(c)
#define	TO_LOWER(c)	ASCII_TO_LOWER(c)
#endif
#endif

#ifdef isspace
#define IS_SPACE(c)	isspace((unsigned char)(c))
#else
#define IS_SPACE(c)	((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) == '\r' || (c) == '\f')
#endif

#ifdef isdigit
#define IS_DIGIT(c)	isdigit((unsigned char)(c))
#else
#define IS_DIGIT(c)	((c) >= '0' && (c) <= '9')
a118 2
#define IS_CSI_START(c)	(((LWCHAR)(c)) == ESC || (((LWCHAR)(c)) == CSI))

a139 13
#if HAVE_SNPRINTF
#define SNPRINTF1(str, size, fmt, v1)             snprintf((str), (size), (fmt), (v1))
#define SNPRINTF2(str, size, fmt, v1, v2)         snprintf((str), (size), (fmt), (v1), (v2))
#define SNPRINTF3(str, size, fmt, v1, v2, v3)     snprintf((str), (size), (fmt), (v1), (v2), (v3))
#define SNPRINTF4(str, size, fmt, v1, v2, v3, v4) snprintf((str), (size), (fmt), (v1), (v2), (v3), (v4))
#else
/* Use unsafe sprintf if we don't have snprintf. */
#define SNPRINTF1(str, size, fmt, v1)             sprintf((str), (fmt), (v1))
#define SNPRINTF2(str, size, fmt, v1, v2)         sprintf((str), (fmt), (v1), (v2))
#define SNPRINTF3(str, size, fmt, v1, v2, v3)     sprintf((str), (fmt), (v1), (v2), (v3))
#define SNPRINTF4(str, size, fmt, v1, v2, v3, v4) sprintf((str), (fmt), (v1), (v2), (v3), (v4))
#endif

a141 7
#ifndef SEEK_SET
#define SEEK_SET 0
#endif
#ifndef SEEK_END
#define SEEK_END 2
#endif

a155 1
typedef unsigned long LWCHAR;
a158 1
#define MAX_UTF_CHAR_LEN   6	/* Max bytes in one UTF-8 char */
a250 4
/* A fraction is represented by an int n; the fraction is n/NUM_FRAC_DENOM */
#define NUM_FRAC_DENOM			1000000
#define NUM_LOG_FRAC_DENOM		6

d267 8
a274 10
#define	SRCH_FORW       (1 << 0)  /* Search forward from current position */
#define	SRCH_BACK       (1 << 1)  /* Search backward from current position */
#define SRCH_NO_MOVE    (1 << 2)  /* Highlight, but don't move */
#define SRCH_FIND_ALL   (1 << 4)  /* Find and highlight all matches */
#define SRCH_NO_MATCH   (1 << 8)  /* Search for non-matching lines */
#define SRCH_PAST_EOF   (1 << 9)  /* Search past end-of-file, into next file */
#define SRCH_FIRST_FILE (1 << 10) /* Search starting at the first file */
#define SRCH_NO_REGEX   (1 << 12) /* Don't use regular expressions */
#define SRCH_FILTER     (1 << 13) /* Search is for '&' (filter) command */
#define SRCH_AFTER_TARGET (1 << 14) /* Start search after the target line */
d292 1
a292 1
/* Special char bit-flags used to tell put_line() to do something special */
d294 5
a298 7
#define	AT_UNDERLINE	(1 << 0)
#define	AT_BOLD		(1 << 1)
#define	AT_BLINK	(1 << 2)
#define	AT_STANDOUT	(1 << 3)
#define	AT_ANSI		(1 << 4)  /* Content-supplied "ANSI" escape sequence */
#define	AT_BINARY	(1 << 5)  /* LESS*BINFMT representation */
#define	AT_HILITE	(1 << 6)  /* Internal highlights (e.g., for search) */
a372 1
#define	CSI		((unsigned char)'\233')
a400 1
#define	QUIT_INTERRUPT	2
a402 3
#define FOLLOW_DESC     0
#define FOLLOW_NAME     1

a411 6

/* Flags for cvt_text */
#define	CVT_TO_LC	01	/* Convert upper-case to lower-case */
#define	CVT_BS		02	/* Do backspace processing */
#define	CVT_CRLF	04	/* Remove CR after LF */
#define	CVT_ANSI	010	/* Remove ANSI escape sequences */
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
a85 1
#include <signal.h>
d453 1
a453 1
#define	LSIGNAL(sig,func)	lsignal(sig,func)
a487 2
#define	CH_NODATA  	020	/* Special case for zero length files */

a491 1
#define FAKE_EMPTYFILE	"@@/\\less/\\empty/\\file/\\@@"
@


