head	1.25;
access;
symbols
	OPENBSD_6_2:1.25.0.2
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.24.0.2
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.16.0.8
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.15.0.12
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.8
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.6
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.4
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.14.0.6
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.13.0.12
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.14
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.10
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.10.0.8
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.6
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	W32EN7Zp77efb8wW;

1.24
date	2016.03.16.15.36.26;	author mmcc;	state Exp;
branches;
next	1.23;
commitid	P9ytq8HKajWPxZf9;

1.23
date	2016.01.29.04.51.26;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	eq1xnMvuoGPThu5g;

1.22
date	2015.11.09.16.46.42;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	rJ6tmXbM6ZZSV1zd;

1.21
date	2015.11.09.16.42.35;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	mkNNke62XFQvJVUG;

1.20
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	ZtGimechwgSRYqRW;

1.19
date	2015.11.07.18.07.44;	author tedu;	state Exp;
branches;
next	1.18;
commitid	DJUwzdj0cG1bCfEw;

1.18
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.17;
commitid	QKrr6AuGzNx9nehL;

1.17
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.16;
commitid	yKv9Ck9ZDgwWTRTo;

1.16
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.15;

1.15
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.14;

1.14
date	2010.07.03.16.29.46;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.06.05.03.29;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.23.18.32.52;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.02.00.55.32;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.23.17.56.20;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.14.14.33.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.13.18.26.25;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.06.23.38.06;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.06.18.42.57;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.05.01.03.35;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.13.09.09.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.01;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.04;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.46;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.25
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Routines to mess around with filenames (and files).
 * Much of this is very OS dependent.
 *
 * Modified for illumos/POSIX -- it uses native glob(3C) rather than
 * popen to a shell to perform the expansion.
 */

#include <sys/stat.h>

#include <glob.h>
#include <stdarg.h>

#include "less.h"

extern int force_open;
extern int secure;
extern int use_lessopen;
extern int ctldisp;
extern int utf_mode;
extern IFILE curr_ifile;
extern IFILE old_ifile;
extern char openquote;
extern char closequote;

/*
 * Remove quotes around a filename.
 */
char *
shell_unquote(char *str)
{
	char *name;
	char *p;

	name = p = ecalloc(strlen(str)+1, sizeof (char));
	if (*str == openquote) {
		str++;
		while (*str != '\0') {
			if (*str == closequote) {
				if (str[1] != closequote)
					break;
				str++;
			}
			*p++ = *str++;
		}
	} else {
		char *esc = get_meta_escape();
		int esclen = strlen(esc);
		while (*str != '\0') {
			if (esclen > 0 && strncmp(str, esc, esclen) == 0)
				str += esclen;
			*p++ = *str++;
		}
	}
	*p = '\0';
	return (name);
}

/*
 * Get the shell's escape character.
 */
char *
get_meta_escape(void)
{
	char *s;

	s = lgetenv("LESSMETAESCAPE");
	if (s == NULL)
		s = "\\";
	return (s);
}

/*
 * Get the characters which the shell considers to be "metacharacters".
 */
static char *
metachars(void)
{
	static char *mchars = NULL;

	if (mchars == NULL) {
		mchars = lgetenv("LESSMETACHARS");
		if (mchars == NULL)
			mchars = DEF_METACHARS;
	}
	return (mchars);
}

/*
 * Is this a shell metacharacter?
 */
static int
metachar(char c)
{
	return (strchr(metachars(), c) != NULL);
}

/*
 * Insert a backslash before each metacharacter in a string.
 */
char *
shell_quote(const char *s)
{
	const char *p;
	char *r;
	char *newstr;
	int len;
	char *esc = get_meta_escape();
	int esclen = strlen(esc);
	int use_quotes = 0;
	int have_quotes = 0;

	/*
	 * Determine how big a string we need to allocate.
	 */
	len = 1; /* Trailing null byte */
	for (p = s; *p != '\0'; p++) {
		len++;
		if (*p == openquote || *p == closequote)
			have_quotes = 1;
		if (metachar(*p)) {
			if (esclen == 0) {
				/*
				 * We've got a metachar, but this shell
				 * doesn't support escape chars.  Use quotes.
				 */
				use_quotes = 1;
			} else {
				/*
				 * Allow space for the escape char.
				 */
				len += esclen;
			}
		}
	}
	/*
	 * Allocate and construct the new string.
	 */
	if (use_quotes) {
		/* We can't quote a string that contains quotes. */
		if (have_quotes)
			return (NULL);
		newstr  = easprintf("%c%s%c", openquote, s, closequote);
	} else {
		newstr = r = ecalloc(len, sizeof (char));
		while (*s != '\0') {
			if (metachar(*s)) {
				/*
				 * Add the escape char.
				 */
				(void) strlcpy(r, esc, newstr + len - p);
				r += esclen;
			}
			*r++ = *s++;
		}
		*r = '\0';
	}
	return (newstr);
}

/*
 * Return a pathname that points to a specified file in a specified directory.
 * Return NULL if the file does not exist in the directory.
 */
static char *
dirfile(const char *dirname, const char *filename)
{
	char *pathname;
	char *qpathname;
	int f;

	if (dirname == NULL || *dirname == '\0')
		return (NULL);
	/*
	 * Construct the full pathname.
	 */
	pathname = easprintf("%s/%s", dirname, filename);
	/*
	 * Make sure the file exists.
	 */
	qpathname = shell_unquote(pathname);
	f = open(qpathname, O_RDONLY);
	if (f < 0) {
		free(pathname);
		pathname = NULL;
	} else {
		(void) close(f);
	}
	free(qpathname);
	return (pathname);
}

/*
 * Return the full pathname of the given file in the "home directory".
 */
char *
homefile(char *filename)
{
	return (dirfile(lgetenv("HOME"), filename));
}

/*
 * Expand a string, substituting any "%" with the current filename,
 * and any "#" with the previous filename.
 * But a string of N "%"s is just replaced with N-1 "%"s.
 * Likewise for a string of N "#"s.
 * {{ This is a lot of work just to support % and #. }}
 */
char *
fexpand(char *s)
{
	char *fr, *to;
	int n;
	char *e;
	IFILE ifile;

#define	fchar_ifile(c) \
	((c) == '%' ? curr_ifile : (c) == '#' ? old_ifile : NULL)

	/*
	 * Make one pass to see how big a buffer we
	 * need to allocate for the expanded string.
	 */
	n = 0;
	for (fr = s; *fr != '\0'; fr++) {
		switch (*fr) {
		case '%':
		case '#':
			if (fr > s && fr[-1] == *fr) {
				/*
				 * Second (or later) char in a string
				 * of identical chars.  Treat as normal.
				 */
				n++;
			} else if (fr[1] != *fr) {
				/*
				 * Single char (not repeated).  Treat specially.
				 */
				ifile = fchar_ifile(*fr);
				if (ifile == NULL)
					n++;
				else
					n += strlen(get_filename(ifile));
			}
			/*
			 * Else it is the first char in a string of
			 * identical chars.  Just discard it.
			 */
			break;
		default:
			n++;
			break;
		}
	}

	e = ecalloc(n+1, sizeof (char));

	/*
	 * Now copy the string, expanding any "%" or "#".
	 */
	to = e;
	for (fr = s; *fr != '\0'; fr++) {
		switch (*fr) {
		case '%':
		case '#':
			if (fr > s && fr[-1] == *fr) {
				*to++ = *fr;
			} else if (fr[1] != *fr) {
				ifile = fchar_ifile(*fr);
				if (ifile == NULL) {
					*to++ = *fr;
				} else {
					(void) strlcpy(to, get_filename(ifile),
					    e + n + 1 - to);
					to += strlen(to);
				}
			}
			break;
		default:
			*to++ = *fr;
			break;
		}
	}
	*to = '\0';
	return (e);
}

/*
 * Return a blank-separated list of filenames which "complete"
 * the given string.
 */
char *
fcomplete(char *s)
{
	char *fpat;
	char *qs;

	if (secure)
		return (NULL);
	/*
	 * Complete the filename "s" by globbing "s*".
	 */
	fpat =  easprintf("%s*", s);

	qs = lglob(fpat);
	s = shell_unquote(qs);
	if (strcmp(s, fpat) == 0) {
		/*
		 * The filename didn't expand.
		 */
		free(qs);
		qs = NULL;
	}
	free(s);
	free(fpat);
	return (qs);
}

/*
 * Try to determine if a file is "binary".
 * This is just a guess, and we need not try too hard to make it accurate.
 */
int
bin_file(int f)
{
	int n;
	int bin_count = 0;
	char data[256];
	char *p;
	char *pend;

	if (!seekable(f))
		return (0);
	if (lseek(f, (off_t)0, SEEK_SET) == (off_t)-1)
		return (0);
	n = read(f, data, sizeof (data));
	pend = &data[n];
	for (p = data; p < pend; ) {
		LWCHAR c = step_char(&p, +1, pend);
		if (ctldisp == OPT_ONPLUS && IS_CSI_START(c)) {
			do {
				c = step_char(&p, +1, pend);
			} while (p < pend && is_ansi_middle(c));
		} else if (binary_char(c))
			bin_count++;
	}
	/*
	 * Call it a binary file if there are more than 5 binary characters
	 * in the first 256 bytes of the file.
	 */
	return (bin_count > 5);
}

/*
 * Try to determine the size of a file by seeking to the end.
 */
static off_t
seek_filesize(int f)
{
	off_t spos;

	spos = lseek(f, (off_t)0, SEEK_END);
	if (spos == (off_t)-1)
		return (-1);
	return (spos);
}

/*
 * Read a string from a file.
 * Return a pointer to the string in memory.
 */
static char *
readfd(FILE *fd)
{
	int len;
	int ch;
	char *buf;
	char *p;

	/*
	 * Make a guess about how many chars in the string
	 * and allocate a buffer to hold it.
	 */
	len = 100;
	buf = ecalloc(len, sizeof (char));
	for (p = buf; ; p++) {
		if ((ch = getc(fd)) == '\n' || ch == EOF)
			break;
		if (p >= buf + len-1) {
			/*
			 * The string is too big to fit in the buffer we have.
			 * Allocate a new buffer, twice as big.
			 */
			len *= 2;
			*p = '\0';
			p = ecalloc(len, sizeof (char));
			strlcpy(p, buf, len);
			free(buf);
			buf = p;
			p = buf + strlen(buf);
		}
		*p = (char)ch;
	}
	*p = '\0';
	return (buf);
}

/*
 * Execute a shell command.
 * Return a pointer to a pipe connected to the shell command's standard output.
 */
static FILE *
shellcmd(char *cmd)
{
	FILE *fd;

	char *shell;

	shell = lgetenv("SHELL");
	if (shell != NULL && *shell != '\0') {
		char *scmd;
		char *esccmd;

		/*
		 * Read the output of <$SHELL -c cmd>.
		 * Escape any metacharacters in the command.
		 */
		esccmd = shell_quote(cmd);
		if (esccmd == NULL) {
			fd = popen(cmd, "r");
		} else {
			scmd = easprintf("%s -c %s", shell, esccmd);
			free(esccmd);
			fd = popen(scmd, "r");
			free(scmd);
		}
	} else {
		fd = popen(cmd, "r");
	}
	/*
	 * Redirection in `popen' might have messed with the
	 * standard devices.  Restore binary input mode.
	 */
	return (fd);
}

/*
 * Expand a filename, doing any system-specific metacharacter substitutions.
 */
char *
lglob(char *filename)
{
	char *gfilename;
	char *ofilename;
	glob_t list;
	int i;
	int length;
	char *p;
	char *qfilename;

	ofilename = fexpand(filename);
	if (secure)
		return (ofilename);
	filename = shell_unquote(ofilename);

	/*
	 * The globbing function returns a list of names.
	 */

#ifndef	GLOB_TILDE
#define	GLOB_TILDE	0
#endif
#ifndef	GLOB_LIMIT
#define	GLOB_LIMIT	0
#endif
	if (glob(filename, GLOB_TILDE | GLOB_LIMIT, NULL, &list) != 0) {
		free(filename);
		return (ofilename);
	}
	length = 1; /* Room for trailing null byte */
	for (i = 0; i < list.gl_pathc; i++) {
		p = list.gl_pathv[i];
		qfilename = shell_quote(p);
		if (qfilename != NULL) {
			length += strlen(qfilename) + 1;
			free(qfilename);
		}
	}
	gfilename = ecalloc(length, sizeof (char));
	for (i = 0; i < list.gl_pathc; i++) {
		p = list.gl_pathv[i];
		qfilename = shell_quote(p);
		if (qfilename != NULL) {
			if (i != 0) {
				(void) strlcat(gfilename, " ", length);
			}
			(void) strlcat(gfilename, qfilename, length);
			free(qfilename);
		}
	}
	globfree(&list);
	free(filename);
	free(ofilename);
	return (gfilename);
}

/*
 * Expand LESSOPEN or LESSCLOSE.  Returns a newly allocated string
 * on success, NULL otherwise.
 */
static char *
expand_pct_s(const char *fmt, ...)
{
	int		n;
	int		len;
	char		*r, *d;
	const char	*f[3];		/* max expansions + 1 for NULL */
	va_list		ap;

	va_start(ap, fmt);
	for (n = 0; n < ((sizeof (f)/sizeof (f[0])) - 1); n++) {
		f[n] = (const char *)va_arg(ap, const char *);
		if (f[n] == NULL) {
			break;
		}
	}
	va_end(ap);
	f[n] = NULL;	/* terminate list */

	len = strlen(fmt) + 1;
	for (n = 0; f[n] != NULL; n++) {
		len += strlen(f[n]);	/* technically could -2 for "%s" */
	}
	r = ecalloc(len, sizeof (char));

	for (n = 0, d = r; *fmt != 0; ) {
		if (*fmt != '%') {
			*d++ = *fmt++;
			continue;
		}
		fmt++;
		/* Permit embedded "%%" */
		switch (*fmt) {
		case '%':
			*d++ = '%';
			fmt++;
			break;
		case 's':
			if (f[n] == NULL) {
				va_end(ap);
				free(r);
				return (NULL);
			}
			(void) strlcpy(d, f[n++], r + len - d);
			fmt++;
			d += strlen(d);
			break;
		default:
			va_end(ap);
			free(r);
			return (NULL);
		}
	}
	*d = '\0';
	return (r);
}

/*
 * See if we should open a "replacement file"
 * instead of the file we're about to open.
 */
char *
open_altfile(char *filename, int *pf, void **pfd)
{
	char *lessopen;
	char *cmd;
	FILE *fd;
	int returnfd = 0;

	if (!use_lessopen || secure)
		return (NULL);
	ch_ungetchar(-1);
	if ((lessopen = lgetenv("LESSOPEN")) == NULL)
		return (NULL);
	while (*lessopen == '|') {
		/*
		 * If LESSOPEN starts with a |, it indicates
		 * a "pipe preprocessor".
		 */
		lessopen++;
		returnfd++;
	}
	if (*lessopen == '-') {
		/*
		 * Lessopen preprocessor will accept "-" as a filename.
		 */
		lessopen++;
	} else {
		if (strcmp(filename, "-") == 0)
			return (NULL);
	}

	if ((cmd = expand_pct_s(lessopen, filename, NULL)) == NULL) {
		error("Invalid LESSOPEN variable", NULL);
		return (NULL);
	}
	fd = shellcmd(cmd);
	free(cmd);
	if (fd == NULL) {
		/*
		 * Cannot create the pipe.
		 */
		return (NULL);
	}
	if (returnfd) {
		int f;
		char c;

		/*
		 * Read one char to see if the pipe will produce any data.
		 * If it does, push the char back on the pipe.
		 */
		f = fileno(fd);
		if (read(f, &c, 1) != 1) {
			/*
			 * Pipe is empty.
			 * If more than 1 pipe char was specified,
			 * the exit status tells whether the file itself
			 * is empty, or if there is no alt file.
			 * If only one pipe char, just assume no alt file.
			 */
			int status = pclose(fd);
			if (returnfd > 1 && status == 0) {
				*pfd = NULL;
				*pf = -1;
				return (estrdup(FAKE_EMPTYFILE));
			}
			return (NULL);
		}
		ch_ungetchar(c);
		*pfd = (void *) fd;
		*pf = f;
		return (estrdup("-"));
	}
	cmd = readfd(fd);
	pclose(fd);
	if (*cmd == '\0')
		/*
		 * Pipe is empty.  This means there is no alt file.
		 */
		return (NULL);
	return (cmd);
}

/*
 * Close a replacement file.
 */
void
close_altfile(char *altfilename, char *filename, void *pipefd)
{
	char *lessclose;
	FILE *fd;
	char *cmd;

	if (secure)
		return;
	if (pipefd != NULL) {
		pclose((FILE *)pipefd);
	}
	if ((lessclose = lgetenv("LESSCLOSE")) == NULL)
		return;
	cmd = expand_pct_s(lessclose, filename, altfilename, NULL);
	if (cmd == NULL) {
		error("Invalid LESSCLOSE variable", NULL);
		return;
	}
	fd = shellcmd(cmd);
	free(cmd);
	if (fd != NULL)
		(void) pclose(fd);
}

/*
 * Is the specified file a directory?
 */
int
is_dir(char *filename)
{
	int isdir = 0;
	int r;
	struct stat statbuf;

	filename = shell_unquote(filename);

	r = stat(filename, &statbuf);
	isdir = (r >= 0 && S_ISDIR(statbuf.st_mode));
	free(filename);
	return (isdir);
}

/*
 * Returns NULL if the file can be opened and
 * is an ordinary file, otherwise an error message
 * (if it cannot be opened or is a directory, etc.)
 */
char *
bad_file(char *filename)
{
	char *m = NULL;

	filename = shell_unquote(filename);
	if (!force_open && is_dir(filename)) {
		m = easprintf("%s is a directory", filename);
	} else {
		int r;
		struct stat statbuf;

		r = stat(filename, &statbuf);
		if (r < 0) {
			m = errno_message(filename);
		} else if (force_open) {
			m = NULL;
		} else if (!S_ISREG(statbuf.st_mode)) {
			m = easprintf("%s is not a regular file (use -f to "
			    "see it)", filename);
		}
	}
	free(filename);
	return (m);
}

/*
 * Return the size of a file, as cheaply as possible.
 * In Unix, we can stat the file.
 */
off_t
filesize(int f)
{
	struct stat statbuf;

	if (fstat(f, &statbuf) >= 0)
		return (statbuf.st_size);
	return (seek_filesize(f));
}

/*
 * Return last component of a pathname.
 */
char *
last_component(char *name)
{
	char *slash;

	for (slash = name + strlen(name); slash > name; ) {
		--slash;
		if (*slash == '/')
			return (slash + 1);
	}
	return (name);
}
@


1.24
log
@style(9) includes

ok nicm@@
@
text
@d128 1
a128 1
	for (p = s;  *p != '\0';  p++) {
d236 1
a236 1
	for (fr = s;  *fr != '\0';  fr++) {
d273 1
a273 1
	for (fr = s;  *fr != '\0';  fr++) {
d765 1
a765 1
	for (slash = name + strlen(name);  slash > name; ) {
@


1.23
log
@remove superfluous macro

ok nicm
@
text
@d20 1
a20 1
#include "less.h"
a21 1
#include <sys/stat.h>
d24 2
@


1.22
log
@NULL_IFILE has no weird use patterns.  NULL is sufficient.
@
text
@d79 1
a79 1
		s = DEF_METAESCAPE;
@


1.21
log
@use (off_t)-1 rather than a BAD_LSEEK wrapper
@
text
@d228 1
a228 1
	((c) == '%' ? curr_ifile : (c) == '#' ? old_ifile : NULL_IFILE)
d250 1
a250 1
				if (ifile == NULL_IFILE)
d280 1
a280 1
				if (ifile == NULL_IFILE) {
@


1.20
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@d344 1
a344 1
	if (lseek(f, (off_t)0, SEEK_SET) == BAD_LSEEK)
d373 1
a373 1
	if (spos == BAD_LSEEK)
@


1.19
log
@replace save() with estrdup() and make estrdup() exit like all the other
ecalloc, etc. functions do.
ok mmcc nicm
@
text
@d614 1
a614 1
		error("Invalid LESSOPEN variable", NULL_PARG);
d684 1
a684 1
		error("Invalid LESSCLOSE variable", NULL_PARG);
@


1.18
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d646 1
a646 1
				return (save(FAKE_EMPTYFILE));
d653 1
a653 1
		return (save("-"));
@


1.17
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.16
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

d17 3
a22 21
#include "lglob.h"
#if MSDOS_COMPILER
#include <dos.h>
#if MSDOS_COMPILER==WIN32C && !defined(_MSC_VER)
#include <dir.h>
#endif
#if MSDOS_COMPILER==DJGPPC
#include <glob.h>
#include <dir.h>
#define _MAX_PATH	PATH_MAX
#endif
#endif
#ifdef _OSK
#include <rbf.h>
#ifndef _OSK_MWC32
#include <modes.h>
#endif
#endif
#if OS2
#include <signal.h>
#endif
a23 1
#if HAVE_STAT
d25 2
a26 8
#ifndef S_ISDIR
#define	S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
#endif
#ifndef S_ISREG
#define	S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)
#endif
#endif

a34 1
#if SPACES_IN_FILENAMES
a36 1
#endif
d41 2
a42 3
	public char *
shell_unquote(str)
	char *str;
d47 2
a48 3
	name = p = (char *) ecalloc(strlen(str)+1, sizeof(char));
	if (*str == openquote)
	{
d50 2
a51 4
		while (*str != '\0')
		{
			if (*str == closequote)
			{
d58 1
a58 2
	} else
	{
d61 1
a61 2
		while (*str != '\0')
		{
d74 2
a75 2
	public char *
get_meta_escape()
d88 2
a89 2
	static char *
metachars()
d93 1
a93 2
	if (mchars == NULL)
	{
d104 2
a105 3
	static int
metachar(c)
	char c;
d113 2
a114 3
	public char *
shell_quote(s)
	char *s;
d116 2
a117 1
	char *p;
d129 1
a129 2
	for (p = s;  *p != '\0';  p++)
	{
d133 2
a134 4
		if (metachar(*p))
		{
			if (esclen == 0)
			{
d136 1
a136 1
				 * We've got a metachar, but this shell 
d140 1
a140 2
			} else
			{
a147 9
	if (use_quotes)
	{
		if (have_quotes)
			/*
			 * We can't quote a string that contains quotes.
			 */
			return (NULL);
		len = strlen(s) + 3;
	}
d151 9
a159 10
	newstr = p = (char *) ecalloc(len, sizeof(char));
	if (use_quotes)
	{
		SNPRINTF3(newstr, len, "%c%s%c", openquote, s, closequote);
	} else
	{
		while (*s != '\0')
		{
			if (metachar(*s))
			{
d163 2
a164 2
				strlcpy(p, esc, newstr + len - p);
				p += esclen;
d166 1
a166 1
			*p++ = *s++;
d168 1
a168 1
		*p = '\0';
d177 2
a178 4
	static char *
dirfile(dirname, filename)
	char *dirname;
	char *filename;
a181 1
	size_t len;
d189 1
a189 5
	len= strlen(dirname) + strlen(filename) + 2;
	pathname = (char *) calloc(len, sizeof(char));
	if (pathname == NULL)
		return (NULL);
	SNPRINTF3(pathname, len, "%s%s%s", dirname, PATHNAME_SEP, filename);
d194 2
a195 3
	f = open(qpathname, OPEN_READ);
	if (f < 0)
	{
d198 2
a199 3
	} else
	{
		close(f);
a204 1
#if USERFILE
d208 2
a209 3
	public char *
homefile(filename)
	char *filename;
d211 1
a211 37
	register char *pathname;

	/*
	 * Try $HOME/filename.
	 */
	pathname = dirfile(lgetenv("HOME"), filename);
	if (pathname != NULL)
		return (pathname);
#if OS2
	/*
	 * Try $INIT/filename.
	 */
	pathname = dirfile(lgetenv("INIT"), filename);
	if (pathname != NULL)
		return (pathname);
#endif
#if MSDOS_COMPILER || OS2
	/*
	 * Look for the file anywhere on search path.
	 */
	pathname = (char *) calloc(_MAX_PATH, sizeof(char));
#if MSDOS_COMPILER==DJGPPC
	{
		char *res = searchpath(filename);
		if (res == 0)
			*pathname = '\0';
		else
			strlcpy(pathname, res, _MAX_PATH);
	}
#else
	_searchenv(filename, "PATH", pathname);
#endif
	if (*pathname != '\0')
		return (pathname);
	free(pathname);
#endif
	return (NULL);
a212 1
#endif /* USERFILE */
d221 2
a222 3
	public char *
fexpand(s)
	char *s;
d224 3
a226 3
	register char *fr, *to;
	register int n;
	register char *e;
d230 1
a230 2
	((c) == '%' ? curr_ifile : \
	 (c) == '#' ? old_ifile : NULL_IFILE)
d233 1
a233 1
	 * Make one pass to see how big a buffer we 
d237 2
a238 4
	for (fr = s;  *fr != '\0';  fr++)
	{
		switch (*fr)
		{
d241 1
a241 2
			if (fr > s && fr[-1] == *fr)
			{
d247 1
a247 2
			} else if (fr[1] != *fr)
			{
d268 1
a268 1
	e = (char *) ecalloc(n+1, sizeof(char));
d274 2
a275 4
	for (fr = s;  *fr != '\0';  fr++)
	{
		switch (*fr)
		{
d278 1
a278 2
			if (fr > s && fr[-1] == *fr)
			{
d280 1
a280 2
			} else if (fr[1] != *fr)
			{
d282 1
a282 1
				if (ifile == NULL_IFILE)
d284 2
a285 3
				else
				{
					strlcpy(to, get_filename(ifile),
a299 3

#if TAB_COMPLETE_FILENAME

d304 2
a305 3
	public char *
fcomplete(s)
	char *s;
a308 1
	size_t len;
d315 2
a316 27
#if MSDOS_COMPILER && (MSDOS_COMPILER == MSOFTC || MSDOS_COMPILER == BORLANDC)
	/*
	 * But in DOS, we have to glob "s*.*".
	 * But if the final component of the filename already has
	 * a dot in it, just do "s*".  
	 * (Thus, "FILE" is globbed as "FILE*.*", 
	 *  but "FILE.A" is globbed as "FILE.A*").
	 */
	{
		char *slash;
		for (slash = s+strlen(s)-1;  slash > s;  slash--)
			if (*slash == *PATHNAME_SEP || *slash == '/')
				break;
		len = strlen(s) + 4;
		fpat = (char *) ecalloc(len, sizeof(char));
		if (strchr(slash, '.') == NULL)
			SNPRINTF1(fpat, len, "%s*.*", s);
		else
			SNPRINTF1(fpat, len, "%s*", s);
	}
#else
	{
	len = strlen(s) + 2;
	fpat = (char *) ecalloc(len, sizeof(char));
	SNPRINTF1(fpat, len, "%s*", s);
	}
#endif
d319 1
a319 2
	if (strcmp(s,fpat) == 0)
	{
a329 1
#endif
d335 2
a336 3
	public int
bin_file(f)
	int f;
d341 2
a342 2
	char* p;
	char* pend;
d348 1
a348 1
	n = read(f, data, sizeof(data));
d350 1
a350 2
	for (p = data;  p < pend;  )
	{
d352 1
a352 2
		if (ctldisp == OPT_ONPLUS && IS_CSI_START(c))
		{
d369 2
a370 3
	static POSITION
seek_filesize(f)
	int f;
d376 2
a377 2
		return (NULL_POSITION);
	return ((POSITION) spos);
d384 2
a385 3
	static char *
readfd(fd)
	FILE *fd;
d391 2
a392 2
	
	/* 
d397 2
a398 3
	buf = (char *) ecalloc(len, sizeof(char));
	for (p = buf;  ;  p++)
	{
d401 1
a401 2
		if (p - buf >= len-1)
		{
d408 1
a408 1
			p = (char *) ecalloc(len, sizeof(char));
d414 1
a414 1
		*p = ch;
a419 6


#if HAVE_POPEN

FILE *popen();

d424 2
a425 3
	static FILE *
shellcmd(cmd)
	char *cmd;
a428 1
#if HAVE_SHELL
d432 1
a432 2
	if (shell != NULL && *shell != '\0')
	{
d437 1
a437 1
		 * Read the output of <$SHELL -c cmd>.  
d441 1
a441 2
		if (esccmd == NULL)
		{
d443 2
a444 5
		} else
		{
			size_t len = strlen(shell) + strlen(esccmd) + 5;
			scmd = (char *) ecalloc(len, sizeof(char));
			SNPRINTF3(scmd, len, "%s %s %s", shell, shell_coption(), esccmd);
d449 1
a449 3
	} else
#endif
	{
a455 1
	SET_BINARY(0);
a458 4
#endif /* HAVE_POPEN */


#if !SMALL
d462 2
a463 3
	public char *
lglob(filename)
	char *filename;
d467 5
a477 2
#ifdef DECL_GLOB_LIST
{
a480 4
	int length;
	char *p;
	char *qfilename;
	DECL_GLOB_LIST(list)
d482 7
a488 3
	GLOB_LIST(filename, list);
	if (GLOB_LIST_FAILED(list))
	{
d493 2
a494 3
	for (SCAN_GLOB_LIST(list, p))
	{
		INIT_GLOB_LIST(list, p);
d496 2
a497 3
		if (qfilename != NULL)
		{
	  		length += strlen(qfilename) + 1;
d501 3
a503 4
	gfilename = (char *) ecalloc(length, sizeof(char));
	for (SCAN_GLOB_LIST(list, p))
	{
		INIT_GLOB_LIST(list, p);
d505 5
a509 4
		if (qfilename != NULL)
		{
			snprintf(gfilename + strlen(gfilename),
			    length - strlen(gfilename), "%s ", qfilename);
d513 1
a513 132
	/*
	 * Overwrite the final trailing space with a null terminator.
	 */
	if (gfilename[0] != '\0' && gfilename[strlen(gfilename) - 1] == ' ')
		gfilename[strlen(gfilename) - 1] = '\0';
	GLOB_LIST_DONE(list);
}
#else
#ifdef DECL_GLOB_NAME
{
	/*
	 * The globbing function returns a single name, and
	 * is called multiple times to walk thru all names.
	 */
	register char *p;
	register int len;
	register int n;
	char *pathname;
	char *qpathname;
	DECL_GLOB_NAME(fnd,drive,dir,fname,ext,handle)
	
	GLOB_FIRST_NAME(filename, &fnd, handle);
	if (GLOB_FIRST_FAILED(handle))
	{
		free(filename);
		return (ofilename);
	}

	_splitpath(filename, drive, dir, fname, ext);
	len = 100;
	gfilename = (char *) ecalloc(len, sizeof(char));
	p = gfilename;
	do {
		n = strlen(drive) + strlen(dir) + strlen(fnd.GLOB_NAME) + 1;
		pathname = (char *) ecalloc(n, sizeof(char));
		SNPRINTF3(pathname, n, "%s%s%s", drive, dir, fnd.GLOB_NAME);
		qpathname = shell_quote(pathname);
		free(pathname);
		if (qpathname != NULL)
		{
			n = strlen(qpathname);
			while (p - gfilename + n + 2 >= len)
			{
				/*
				 * No room in current buffer.
				 * Allocate a bigger one.
				 */
				len *= 2;
				*p = '\0';
				p = (char *) ecalloc(len, sizeof(char));
				strlcpy(p, gfilename, len);
				free(gfilename);
				gfilename = p;
				p = gfilename + strlen(gfilename);
			}
			strlcpy(p, qpathname, gfilename + len - p);
			free(qpathname);
			p += n;
			*p++ = ' ';
		}
	} while (GLOB_NEXT_NAME(handle, &fnd) == 0);

	/*
	 * Overwrite the final trailing space with a null terminator.
	 */
	*--p = '\0';
	GLOB_NAME_DONE(handle);
}
#else
#if HAVE_POPEN
{
	/*
	 * We get the shell to glob the filename for us by passing
	 * an "echo" command to the shell and reading its output.
	 */
	FILE *fd;
	char *s;
	char *lessecho;
	char *cmd;
	char *esc;
	size_t len;

	esc = get_meta_escape();
	if (strlen(esc) == 0)
		esc = "-";
	esc = shell_quote(esc);
	if (esc == NULL)
	{
		free(filename);
		return (ofilename);
	}
	lessecho = lgetenv("LESSECHO");
	if (lessecho == NULL || *lessecho == '\0')
		lessecho = "lessecho";
	/*
	 * Invoke lessecho, and read its output (a globbed list of filenames).
	 */
	len = strlen(lessecho) + strlen(ofilename) + (7*strlen(metachars())) + 24;
	cmd = (char *) ecalloc(len, sizeof(char));
	SNPRINTF4(cmd, len, "%s -p0x%x -d0x%x -e%s ", lessecho, openquote, closequote, esc);
	free(esc);
	for (s = metachars();  *s != '\0';  s++)
		snprintf(cmd + strlen(cmd), len - strlen(cmd), "-n0x%x ", *s);
	snprintf(cmd + strlen(cmd), len - strlen(cmd), "-- %s", ofilename);
	fd = shellcmd(cmd);
	free(cmd);
	if (fd == NULL)
	{
		/*
		 * Cannot create the pipe.
		 * Just return the original (fexpanded) filename.
		 */
		free(filename);
		return (ofilename);
	}
	gfilename = readfd(fd);
	pclose(fd);
	if (*gfilename == '\0')
	{
		free(gfilename);
		free(filename);
		return (ofilename);
	}
}
#else
	/*
	 * No globbing functions at all.  Just use the fexpanded filename.
	 */
	gfilename = save(filename);
#endif
#endif
#endif
a517 1
#endif /* !SMALL */
d520 2
a521 2
 * Return number of %s escapes in a string.
 * Return a large number if there are any other % escapes besides %s.
d523 2
a524 3
	static int
num_pct_s(lessopen)
	char *lessopen;
d526 15
a540 1
	int num;
d542 17
a558 4
	for (num = 0;; num++)
	{
		lessopen = strchr(lessopen, '%');
		if (lessopen == NULL)
d560 15
a574 2
		if (*++lessopen != 's')
			return (999);
d576 2
a577 1
	return (num);
d581 1
a581 1
 * See if we should open a "replacement file" 
d584 3
a586 9
	public char *
open_altfile(filename, pf, pfd)
	char *filename;
	int *pf;
	void **pfd;
{
#if !HAVE_POPEN
	return (NULL);
#else
a588 1
	size_t len;
a589 1
#if HAVE_FILENO
d591 1
a591 2
#endif
	
d597 1
a597 2
	while (*lessopen == '|')
	{
d599 1
a599 1
		 * If LESSOPEN starts with a |, it indicates 
a601 4
#if !HAVE_FILENO
		error("LESSOPEN pipe is not supported", NULL_PARG);
		return (NULL);
#else
a603 1
#endif
d614 2
a615 2
	if (num_pct_s(lessopen) > 1)
	{
a618 4

	len = strlen(lessopen) + strlen(filename) + 2;
	cmd = (char *) ecalloc(len, sizeof(char));
	SNPRINTF1(cmd, len, lessopen, filename);
d621 1
a621 2
	if (fd == NULL)
	{
d627 1
a627 3
#if HAVE_FILENO
	if (returnfd)
	{
d636 1
a636 3
		SET_BINARY(f);
		if (read(f, &c, 1) != 1)
		{
d640 1
a640 1
			 * the exit status tells whether the file itself 
a656 1
#endif
a664 1
#endif /* HAVE_POPEN */
d670 2
a671 5
	public void
close_altfile(altfilename, filename, pipefd)
	char *altfilename;
	char *filename;
	void *pipefd;
a672 1
#if HAVE_POPEN
d676 1
a676 2
	size_t len;
	
d679 2
a680 10
	if (pipefd != NULL)
	{
#if OS2
		/*
		 * The pclose function of OS/2 emx sometimes fails.
		 * Send SIGINT to the piped process before closing it.
		 */
		kill(((FILE*)pipefd)->_pid, SIGINT);
#endif
		pclose((FILE*) pipefd);
d683 4
a686 4
	     	return;
	if (num_pct_s(lessclose) > 2) 
	{
		error("Invalid LESSCLOSE variable");
a688 3
	len = strlen(lessclose) + strlen(filename) + strlen(altfilename) + 2;
	cmd = (char *) ecalloc(len, sizeof(char));
	SNPRINTF2(cmd, len, lessclose, filename, altfilename);
d692 1
a692 2
		pclose(fd);
#endif
d694 1
a694 1
		
d698 2
a699 3
	public int
is_dir(filename)
	char *filename;
d702 2
a705 4
#if HAVE_STAT
{
	int r;
	struct stat statbuf;
a708 13
}
#else
#ifdef _OSK
{
	register int f;

	f = open(filename, S_IREAD | S_IFDIR);
	if (f >= 0)
		close(f);
	isdir = (f >= 0);
}
#endif
#endif
d718 2
a719 3
	public char *
bad_file(filename)
	char *filename;
d721 1
a721 2
	register char *m = NULL;
	size_t len;
d724 3
a726 11
	if (!force_open && is_dir(filename))
	{
		static char is_a_dir[] = " is a directory";

		len = strlen(filename) + sizeof(is_a_dir);
		m = (char *) ecalloc(len, sizeof(char));
		strlcpy(m, filename, len);
		strlcat(m, is_a_dir, len);
	} else
	{
#if HAVE_STAT
d731 1
a731 2
		if (r < 0)
		{
d733 1
a733 2
		} else if (force_open)
		{
d735 3
a737 7
		} else if (!S_ISREG(statbuf.st_mode))
		{
			static char not_reg[] = " is not a regular file (use -f to see it)";
			len = strlen(filename) + sizeof(not_reg);
			m = (char *) ecalloc(len, sizeof(char));
			strlcpy(m, filename, len);
			strlcat(m, not_reg, len);
a738 1
#endif
d748 2
a749 3
	public POSITION
filesize(f)
	int f;
a750 1
#if HAVE_STAT
d754 1
a754 9
		return ((POSITION) statbuf.st_size);
#else
#ifdef _OSK
	long size;

	if ((size = (long) _gs_size(f)) >= 0)
		return ((POSITION) size);
#endif
#endif
a758 9
 * 
 */
	public char *
shell_coption()
{
	return ("-c");
}

/*
d761 2
a762 3
	public char *
last_component(name)
	char *name;
d766 1
a766 2
	for (slash = name + strlen(name);  slash > name; )
	{
d768 1
a768 1
		if (*slash == *PATHNAME_SEP || *slash == '/')
a772 1

@


1.15
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d621 1
d816 21
d850 2
a851 1
	char *cmd, *cp;
a852 2
	size_t i, len;
	int found;
d862 1
a862 1
	if (*lessopen == '|')
d873 1
a873 1
		returnfd = 1;
d885 5
d891 1
a891 2
	/* strlen(filename) is guaranteed to be > 0 */
	len = strlen(lessopen) + strlen(filename);
d893 1
a893 9
	for (cp = cmd, i = 0, found = 0; i < strlen(lessopen); i++) {
		if (!found && lessopen[i] == '%' && lessopen[i + 1] == 's') {
			found = 1;
			strlcat(cmd, filename, len);
			cp += strlen(filename);
			i++;
		} else
			*cp++ = lessopen[i];
	}
d918 5
a922 1
			 * Pipe is empty.  This means there is no alt file.
d924 6
a929 1
			pclose(fd);
d961 2
a962 3
	char *cmd, *cp;
	size_t i, len;
	int found;
d979 6
a984 2
	/* strlen(filename) is guaranteed to be > 0 */
	len = strlen(lessclose) + strlen(filename) + strlen(altfilename);
d986 1
a986 13
	for (cp = cmd, i = 0, found = 0; i < strlen(lessclose); i++) {
		if (found < 2 && lessclose[i] == '%' && lessclose[i + 1] == 's') {
			if (++found == 1) {
				strlcat(cmd, filename, len);
				cp += strlen(filename);
			} else {
				strlcat(cmd, altfilename, len);
				cp += strlen(altfilename);
			}
			i++;
		} else
			*cp++ = lessclose[i];
	}
@


1.14
log
@use SMALL_PROGRAM to knock out some code
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d54 2
d200 1
a200 1
		snprintf(newstr, len, "%c%s%c", openquote, s, closequote);
d231 1
a232 1
	size_t len;
d239 1
a239 1
	len = strlen(dirname) + strlen(filename) + 2;
d243 1
a243 1
	snprintf(pathname, len, "%s%s%s", dirname, PATHNAME_SEP, filename);
d261 1
a261 1
#ifndef SMALL_PROGRAM
d307 1
a307 20
#endif /* SMALL_PROGRAM */

#ifdef HELPFILE
/*
 * Find out where the help file is.
 */
	public char *
find_helpfile()
{
	char *helpfile;
	
	if ((helpfile = getenv("LESSHELP")) != NULL && *helpfile != '\0')
		return (save(helpfile));
#if MSDOS_COMPILER || OS2
	return (homefile(HELPFILE));
#else
	return (save(HELPFILE));
#endif
}
#endif
d406 1
d442 1
a442 1
			snprintf(fpat, len, "%s*.*", s);
d444 1
a444 1
			snprintf(fpat, len, "%s*", s);
d447 1
d450 2
a451 1
	snprintf(fpat, len, "%s*", s);
a476 1
	int i;
d478 4
a481 1
	unsigned char data[64];
d488 17
a504 4
	for (i = 0;  i < n;  i++)
		if (binary_char(data[i]))
			return (1);
	return (0);
a579 1
	size_t len;
d600 1
a600 1
			len = strlen(shell) + strlen(esccmd) + 5;
d602 1
a602 2
			snprintf(scmd, len, "%s %s %s", shell, shell_coption(),
			    esccmd);
d622 1
a622 1

d712 1
a712 1
		snprintf(pathname, n, "%s%s%s", drive, dir, fnd.GLOB_NAME);
d776 1
a776 2
	snprintf(cmd, len, "%s -p0x%x -d0x%x -e%s ", lessecho, openquote,
	    closequote, esc);
d813 1
a841 2
	if (strcmp(filename, "-") == 0)
		return (NULL);
d848 4
a851 1
#if HAVE_FILENO
a853 3
#else
		error("LESSOPEN pipe is not supported", NULL_PARG);
		return (NULL);
d856 9
d1025 1
a1025 1
	if (is_dir(filename))
d1092 19
@


1.13
log
@Don't access buf[strlen(buf) - 1] for zero-length strings.

OK jaredy@@.
@
text
@d259 1
d305 1
@


1.12
log
@Fix removing of trailing space in file name completion list.
From Matthew Haub; ok krw@@
@
text
@d679 2
a680 1
	gfilename[strlen(gfilename) - 1] = '\0';
@


1.11
log
@use SEEK_* for lseek()
@
text
@d679 1
a679 1
	*--p = '\0';
@


1.10
log
@Do %s replacement for LESSOPEN and LESSCLOSE ourselves instead
of using snprintf().  Based on a patch from Brent Graveland.
Ok tdeval@@ and otto@@
@
text
@d495 1
a495 1
	if (lseek(f, (off_t)0, 0) == BAD_LSEEK)
d513 1
a513 1
	spos = lseek(f, (off_t)0, 2);
@


1.9
log
@o go back to using a help file instead of embedding it in the binary
o deal with HELPFILE not being defined
o add a SMALL definition to make a smaller less for the boot floppies
This still needs to be pared down a bit for the SMALL case
@
text
@d827 1
a827 1
	char *cmd;
d829 2
a830 1
	size_t len;
d857 2
a858 1
	len = strlen(lessopen) + strlen(filename) + 2;
d860 9
a868 1
	snprintf(cmd, len, lessopen, filename);
d927 3
a929 2
	char *cmd;
	size_t len;
d946 2
a947 1
	len = strlen(lessclose) + strlen(filename) + strlen(altfilename) + 2;
d949 13
a961 1
	snprintf(cmd, len, lessclose, filename, altfilename);
@


1.8
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d305 19
@


1.7
log
@more strlcpy/strlcat/snprintf, less strcpy/strcat/sprintf
reviewed by tdeval, millert, dhartmei and others.  more bits coming here
from some of them i think
@
text
@a0 2
/*	$OpenBSD: filename.c,v 1.6 2003/04/06 18:42:57 deraadt Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d18 2
a19 1
#if MSOFTC
d21 27
d50 1
d52 2
d56 161
d228 3
a230 1
	int f, len;
d241 1
a241 5
#if MSOFTC || OS2
	snprintf(pathname, len, "%s\\%s", dirname, filename);
#else
	snprintf(pathname, len, "%s/%s", dirname, filename);
#endif
d245 2
a246 1
	f = open(pathname, OPEN_READ);
d253 1
a253 1
		close (f);
d255 1
d266 1
a266 1
	char *pathname;
d271 1
a271 1
	pathname = dirfile(getenv("HOME"), filename);
d278 1
a278 1
	pathname = dirfile(getenv("INIT"), filename);
d282 1
a282 1
#if MSOFTC || OS2
d287 9
d297 1
a305 17
 * Find out where the help file is.
 */
	public char *
find_helpfile()
{
	char *helpfile;
	
	if ((helpfile = getenv("LESSHELP")) != NULL)
		return (save(helpfile));
#if MSOFTC || OS2
	return (homefile(HELPFILE));
#else
	return (save(HELPFILE));
#endif
}

/*
d308 2
d316 8
a323 3
	char *fr, *to;
	int n;
	char *e;
d335 2
a336 1
			if (curr_ifile == NULL_IFILE)
d338 6
a343 7
				/* error("No current file", NULL_PARG); */
				return (save(s));
			}
			n += strlen(get_filename(curr_ifile));
			break;
		case '#':
			if (old_ifile == NULL_IFILE)
d345 8
a352 2
				/* error("No previous file", NULL_PARG); */
				return (save(s));
d354 4
a357 1
			n += strlen(get_filename(old_ifile));
a375 3
			strlcpy(to, get_filename(curr_ifile), e + n + 1 - to);
			to += strlen(to);
			break;
d377 15
a391 2
			strlcpy(to, get_filename(old_ifile), e + n + 1 - to);
			to += strlen(to);
d413 2
a414 1
	size_t l;
d416 2
d421 1
a421 1
#if MSOFTC
d429 12
a440 10
	char *slash;
	for (slash = s+strlen(s)-1;  slash > s;  slash--)
		if (*slash == '/' || *slash == '\\')
			break;
	l = strlen(s)+4;
	fpat = (char *) ecalloc(l, sizeof(char));
	if (strchr(slash, '.') == NULL)
		snprintf(fpat, l, "%s*.*", s);
	else
		snprintf(fpat, l, "%s*", s);
d442 3
a444 3
	l = strlen(s)+2;
	fpat = (char *) ecalloc(l, sizeof(char));
	snprintf(fpat, l, "%s*", s);
d446 2
a447 1
	s = glob(fpat);
d453 2
a454 2
		free(s);
		s = NULL;
d456 1
d458 1
a458 1
	return (s);
a499 4
#if GLOB

FILE *popen();

d543 6
d554 1
a554 1
shellcmd(cmd, s1, s2)
a555 2
	char *s1;
	char *s2;
a556 3
	char *scmd;
	char *scmd2;
	char *shell;
d558 2
a559 7
	int len;
	
	len = strlen(cmd) + 
		(s1 == NULL ? 0 : strlen(s1)) + 
		(s2 == NULL ? 0 : strlen(s2)) + 1;
	scmd = (char *) ecalloc(len, sizeof(char));
	snprintf(scmd, len, cmd, s1, s2);
d561 3
a563 1
	shell = getenv("SHELL");
d566 3
d570 2
a571 1
		 * Read the output of <$SHELL -c "cmd">.
d573 18
a590 5
		len = strlen(shell) + strlen(scmd) + 7;
		scmd2 = (char *) ecalloc(len, sizeof(char));
		snprintf(scmd2, len, "%s -c \"%s\"", shell, scmd);
		free(scmd);
		scmd = scmd2;
d592 5
a596 3
#endif
	fd = popen(scmd, "r");
	free(scmd);
d600 3
d604 1
a604 1
 * Expand a filename, doing any shell-level substitutions.
d607 1
a607 1
glob(filename)
d611 1
d613 6
a618 2
	filename = fexpand(filename);
#if OS2
d620 3
a622 2
	char **list;
	int cnt;
d624 3
d628 17
a644 6
	list = _fnexplode(filename);
	if (list == NULL)
		return (filename);
	length = 0;
	for (cnt = 0;  list[cnt] != NULL;  cnt++)
	  	length += strlen(list[cnt]) + 1;
d646 1
a646 1
	for (cnt = 0;  list[cnt] != NULL;  cnt++)
d648 8
a655 2
		strlcat(gfilename, list[cnt], length);
	  	strlcat(gfilename, " ", length);
d657 5
a661 1
	_fnexplodefree(list);
d664 1
d666 65
d732 5
d738 12
d751 1
a751 2
	 * We get the shell to expand the filename for us by passing
	 * an "echo" command to the shell and reading its output.
d753 10
a762 1
	fd = shellcmd("echo %s", filename, (char*)NULL);
d769 2
a770 1
		return (filename);
d777 2
a778 1
		return (filename);
a779 1
	free(filename);
d781 7
d789 2
d804 3
d808 4
a811 1
	char *gfilename;
d813 1
a813 1
	FILE *fd;
d815 2
d818 1
a818 1
	if ((lessopen = getenv("LESSOPEN")) == NULL)
d828 1
d831 4
d836 6
a841 1
	fd = shellcmd(lessopen, filename, (char*)NULL);
d849 1
a851 1
#if HAVE_FILENO
d860 1
d873 1
a873 3
#else
		error("LESSOPEN pipe is not supported", NULL_PARG);
		return (NULL);
d875 1
a875 2
	}
	gfilename = readfd(fd);
d877 1
a877 1
	if (*gfilename == '\0')
d882 2
a883 1
	return (gfilename);
d895 1
d898 2
d901 2
d904 8
d913 2
a914 1
	if ((lessclose = getenv("LESSCLOSE")) == NULL)
d916 8
a923 2
	fd = shellcmd(lessclose, filename, altfilename);
	pclose(fd);
d926 5
a930 5
#else
#if MSOFTC

	public char *
glob(filename)
d933 4
a936 42
	char *gfilename;
	char *p;
	int len;
	int n;
	struct find_t fnd;
	char drive[_MAX_DRIVE];
	char dir[_MAX_DIR];
	char fname[_MAX_FNAME];
	char ext[_MAX_EXT];
	
	filename = fexpand(filename);
	if (_dos_findfirst(filename, ~0, &fnd) != 0)
		return (filename);
		
	_splitpath(filename, drive, dir, fname, ext);
	len = 100;
	gfilename = (char *) ecalloc(len, sizeof(char));
	p = gfilename;
	do {
		n = strlen(drive) + strlen(dir) + strlen(fnd.name);
		while (p - gfilename + n+2 >= len)
		{
			len *= 2;
			*p = '\0';
			p = (char *) ecalloc(len, sizeof(char));
			strlcpy(p, gfilename, len);
			free(gfilename);
			gfilename = p;
			p = gfilename + strlen(gfilename);
		}
		sprintf(p, "%s%s%s", drive, dir, fnd.name);
		p += n;
		*p++ = ' ';
	} while (_dos_findnext(&fnd) == 0);
	
	*--p = '\0';
	return (gfilename);
}
	
	public char *
open_altfile(filename)
	char *filename;
d938 2
a939 2
	return (NULL);
}
d941 2
a942 5
	public void
close_altfile(altfilename, filename)
	char *altfilename;
	char *filename;
{
a943 1
		
d945 1
a945 4

	public char *
glob(filename)
	char *filename;
d947 1
a947 2
	return (fexpand(filename));
}
d949 4
a952 13
	
	public char *
open_altfile(filename)
	char *filename;
{
     	return (NULL);
}

	public void
close_altfile(altfilename, filename)
	char *altfilename;
	char *filename;
{
a953 1
		
d956 3
a958 11


#if HAVE_STAT

#include <sys/stat.h>
#ifndef S_ISDIR
#define	S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
#endif
#ifndef S_ISREG
#define	S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)
#endif
d969 2
a970 5
	char *m;
	struct stat statbuf;

	if (stat(filename, &statbuf) < 0)
		return (errno_message(filename));
d972 2
a973 4
	if (force_open)
		return (NULL);

	if (S_ISDIR(statbuf.st_mode))
d975 1
a975 2
		static char is_dir[] = " is a directory";
		size_t len;
d977 1
a977 1
		len = strlen(filename) + sizeof(is_dir);
d980 2
a981 4
		strlcat(m, is_dir, len);
		return (m);
	}
	if (!S_ISREG(statbuf.st_mode))
d983 3
a985 2
		static char not_reg[] = " is not a regular file";
		size_t len;
d987 16
a1002 5
		len = strlen(filename) + sizeof(not_reg);
		m = (char *) ecalloc(len, sizeof(char));
		strlcpy(m, filename, len);
		strlcat(m, not_reg, len);
		return (m);
d1004 2
a1005 2

	return (NULL);
d1016 1
d1019 5
a1023 5
	if (fstat(f, &statbuf) < 0)
		/*
		 * Can't stat; try seeking to the end.
		 */
		return (seek_filesize(f));
d1025 5
a1029 1
	return ((POSITION) statbuf.st_size);
a1031 2
#else

d1033 1
a1033 1
 * If we have no way to find out, just say the file is good.
d1036 1
a1036 2
bad_file(filename)
	char *filename;
d1038 1
a1038 1
	return (NULL);
a1039 12

/*
 * We can find the file size by seeking.
 */
	public POSITION
filesize(f)
	int f;
{
	return (seek_filesize(f));
}

#endif
@


1.6
log
@very simple strlcat calls
@
text
@d1 1
a1 1
/*	$OpenBSD: filename.c,v 1.5 2003/04/05 01:03:35 deraadt Exp $	*/
d66 1
a66 1
	sprintf(pathname, "%s\\%s", dirname, filename);
d193 1
a193 1
			strcpy(to, get_filename(curr_ifile));
d197 1
a197 1
			strcpy(to, get_filename(old_ifile));
d220 2
d237 2
a238 1
	fpat = (char *) ecalloc(strlen(s)+4, sizeof(char));
d240 1
a240 1
		sprintf(fpat, "%s*.*", s);
d242 1
a242 1
		sprintf(fpat, "%s*", s);
d244 3
a246 2
	fpat = (char *) ecalloc(strlen(s)+2, sizeof(char));
	snprintf(fpat, strlen(s)+2, "%s*", s);
d412 2
a413 2
		strcat(gfilename, list[cnt], length);
	  	strcat(gfilename, " ", length);
@


1.5
log
@some more string shit; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: filename.c,v 1.4 2003/03/13 09:09:32 deraadt Exp $	*/
d408 2
a409 2
		strcat(gfilename, list[cnt]);
	  	strcat(gfilename, " ");
@


1.4
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: filename.c,v 1.3 2001/11/19 19:02:14 mpech Exp $	*/
d332 1
a332 1
			strcpy(p, buf);
d570 1
a570 1
			strcpy(p, gfilename);
d657 6
a662 4
		m = (char *) ecalloc(strlen(filename) + sizeof(is_dir), 
			sizeof(char));
		strcpy(m, filename);
		strcat(m, is_dir);
d668 6
a673 4
		m = (char *) ecalloc(strlen(filename) + sizeof(not_reg), 
			sizeof(char));
		strcpy(m, filename);
		strcat(m, not_reg);
@


1.3
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: filename.c,v 1.2 2001/01/29 01:58:01 niklas Exp $	*/
d54 1
a54 1
	int f;
d61 2
a62 2
	pathname = (char *) calloc(strlen(dirname) + strlen(filename) + 2, 
					sizeof(char));
d68 1
a68 1
	sprintf(pathname, "%s/%s", dirname, filename);
d242 1
a242 1
	sprintf(fpat, "%s*", s);
d363 1
a363 1
	sprintf(scmd, cmd, s1, s2);
d371 3
a373 3
		scmd2 = (char *) ecalloc(strlen(shell) + strlen(scmd) + 7,
					sizeof(char));
		sprintf(scmd2, "%s -c \"%s\"", shell, scmd);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d92 1
a92 1
	register char *pathname;
d127 1
a127 1
	register char *helpfile;
d147 3
a149 3
	register char *fr, *to;
	register int n;
	register char *e;
d545 4
a548 4
	register char *gfilename;
	register char *p;
	register int len;
	register int n;
d645 1
a645 1
	register char *m;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d34 1
a34 2
#include "lglob.h"
#if MSDOS_COMPILER
a35 17
#if MSDOS_COMPILER==WIN32C && !defined(_MSC_VER)
#include <dir.h>
#endif
#if MSDOS_COMPILER==DJGPPC
#include <glob.h>
#include <dir.h>
#define _MAX_PATH	PATH_MAX
#endif
#endif
#ifdef _OSK
#include <rbf.h>
#ifndef _OSK_MWC32
#include <modes.h>
#endif
#endif
#if OS2
#include <signal.h>
a37 11
#if HAVE_STAT
#include <sys/stat.h>
#ifndef S_ISDIR
#define	S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
#endif
#ifndef S_ISREG
#define	S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)
#endif
#endif


a38 2
extern int secure;
extern int use_lessopen;
a40 161
#if SPACES_IN_FILENAMES
extern char openquote;
extern char closequote;
#endif

/*
 * Remove quotes around a filename.
 */
	public char *
shell_unquote(str)
	char *str;
{
	char *name;
	char *p;

	name = p = (char *) ecalloc(strlen(str)+1, sizeof(char));
	if (*str == openquote)
	{
		str++;
		while (*str != '\0')
		{
			if (*str == closequote)
			{
				if (str[1] != closequote)
					break;
				str++;
			}
			*p++ = *str++;
		}
	} else
	{
		char *esc = get_meta_escape();
		int esclen = strlen(esc);
		while (*str != '\0')
		{
			if (esclen > 0 && strncmp(str, esc, esclen) == 0)
				str += esclen;
			*p++ = *str++;
		}
	}
	*p = '\0';
	return (name);
}

/*
 * Get the shell's escape character.
 */
	public char *
get_meta_escape()
{
	char *s;

	s = lgetenv("LESSMETAESCAPE");
	if (s == NULL)
		s = DEF_METAESCAPE;
	return (s);
}

/*
 * Get the characters which the shell considers to be "metacharacters".
 */
	static char *
metachars()
{
	static char *mchars = NULL;

	if (mchars == NULL)
	{
		mchars = lgetenv("LESSMETACHARS");
		if (mchars == NULL)
			mchars = DEF_METACHARS;
	}
	return (mchars);
}

/*
 * Is this a shell metacharacter?
 */
	static int
metachar(c)
	char c;
{
	return (strchr(metachars(), c) != NULL);
}

/*
 * Insert a backslash before each metacharacter in a string.
 */
	public char *
shell_quote(s)
	char *s;
{
	char *p;
	char *newstr;
	int len;
	char *esc = get_meta_escape();
	int esclen = strlen(esc);
	int use_quotes = 0;
	int have_quotes = 0;

	/*
	 * Determine how big a string we need to allocate.
	 */
	len = 1; /* Trailing null byte */
	for (p = s;  *p != '\0';  p++)
	{
		len++;
		if (*p == openquote || *p == closequote)
			have_quotes = 1;
		if (metachar(*p))
		{
			if (esclen == 0)
			{
				/*
				 * We've got a metachar, but this shell 
				 * doesn't support escape chars.  Use quotes.
				 */
				use_quotes = 1;
			} else
			{
				/*
				 * Allow space for the escape char.
				 */
				len += esclen;
			}
		}
	}
	if (use_quotes)
	{
		if (have_quotes)
			/*
			 * We can't quote a string that contains quotes.
			 */
			return (NULL);
		len = strlen(s) + 3;
	}
	/*
	 * Allocate and construct the new string.
	 */
	newstr = p = (char *) ecalloc(len, sizeof(char));
	if (use_quotes)
	{
		sprintf(newstr, "%c%s%c", openquote, s, closequote);
	} else
	{
		while (*s != '\0')
		{
			if (metachar(*s))
			{
				/*
				 * Add the escape char.
				 */
				strcpy(p, esc);
				p += esclen;
			}
			*p++ = *s++;
		}
		*p = '\0';
	}
	return (newstr);
}
a51 1
	char *qpathname;
d63 5
a67 1
	sprintf(pathname, "%s%s%s", dirname, PATHNAME_SEP, filename);
d71 1
a71 2
	qpathname = shell_unquote(pathname);
	f = open(qpathname, OPEN_READ);
d78 1
a78 1
		close(f);
a79 1
	free(qpathname);
d95 1
a95 1
	pathname = dirfile(lgetenv("HOME"), filename);
d102 1
a102 1
	pathname = dirfile(lgetenv("INIT"), filename);
d106 1
a106 1
#if MSDOS_COMPILER || OS2
a110 9
#if MSDOS_COMPILER==DJGPPC
	{
		char *res = searchpath(filename);
		if (res == 0)
			*pathname = '\0';
		else
			strcpy(pathname, res);
	}
#else
a111 1
#endif
d120 17
a138 2
 * But a string of N "%"s is just replaced with N-1 "%"s.
 * Likewise for a string of N "#"s.
a147 5
	IFILE ifile;

#define	fchar_ifile(c) \
	((c) == '%' ? curr_ifile : \
	 (c) == '#' ? old_ifile : NULL_IFILE)
d159 7
d167 1
a167 8
			if (fr > s && fr[-1] == *fr)
			{
				/*
				 * Second (or later) char in a string
				 * of identical chars.  Treat as normal.
				 */
				n++;
			} else if (fr[1] != *fr)
d169 2
a170 8
				/*
				 * Single char (not repeated).  Treat specially.
				 */
				ifile = fchar_ifile(*fr);
				if (ifile == NULL_IFILE)
					n++;
				else
					n += strlen(get_filename(ifile));
d172 1
a172 4
			/*
			 * Else it is the first char in a string of
			 * identical chars.  Just discard it.
			 */
d191 3
d195 2
a196 14
			if (fr > s && fr[-1] == *fr)
			{
				*to++ = *fr;
			} else if (fr[1] != *fr)
			{
				ifile = fchar_ifile(*fr);
				if (ifile == NULL_IFILE)
					*to++ = *fr;
				else
				{
					strcpy(to, get_filename(ifile));
					to += strlen(to);
				}
			}
a217 4
	char *qs;

	if (secure)
		return (NULL);
d221 1
a221 1
#if MSDOS_COMPILER && (MSDOS_COMPILER == MSOFTC || MSDOS_COMPILER == BORLANDC)
d229 9
a237 11
	{
		char *slash;
		for (slash = s+strlen(s)-1;  slash > s;  slash--)
			if (*slash == *PATHNAME_SEP || *slash == '/')
				break;
		fpat = (char *) ecalloc(strlen(s)+4, sizeof(char));
		if (strchr(slash, '.') == NULL)
			sprintf(fpat, "%s*.*", s);
		else
			sprintf(fpat, "%s*", s);
	}
d242 1
a242 2
	qs = lglob(fpat);
	s = shell_unquote(qs);
d248 2
a249 2
		free(qs);
		qs = NULL;
a250 1
	free(s);
d252 1
a252 1
	return (qs);
d294 4
a340 6


#if HAVE_POPEN

FILE *popen();

d346 1
a346 1
shellcmd(cmd)
d348 2
d351 3
d355 7
a361 1

d363 1
a363 3
	char *shell;

	shell = lgetenv("SHELL");
a365 3
		char *scmd;
		char *esccmd;

d367 1
a367 2
		 * Read the output of <$SHELL -c cmd>.  
		 * Escape any metacharacters in the command.
d369 6
a374 14
		esccmd = shell_quote(cmd);
		if (esccmd == NULL)
		{
			fd = popen(cmd, "r");
		} else
		{
			scmd = (char *) ecalloc(strlen(shell) + strlen(esccmd) + 5,
						sizeof(char));
			sprintf(scmd, "%s %s %s", shell, shell_coption(), esccmd);
			free(esccmd);
			fd = popen(scmd, "r");
			free(scmd);
		}
	} else
d376 2
a377 8
	{
		fd = popen(cmd, "r");
	}
	/*
	 * Redirection in `popen' might have messed with the
	 * standard devices.  Restore binary input mode.
	 */
	SET_BINARY(0);
a380 3
#endif /* HAVE_POPEN */


d382 1
a382 1
 * Expand a filename, doing any system-specific metacharacter substitutions.
d385 1
a385 1
lglob(filename)
a388 1
	char *ofilename;
d390 2
a391 6
	ofilename = fexpand(filename);
	if (secure)
		return (ofilename);
	filename = shell_unquote(ofilename);

#ifdef DECL_GLOB_LIST
d393 2
a394 3
	/*
	 * The globbing function returns a list of names.
	 */
a395 3
	char *p;
	char *qfilename;
	DECL_GLOB_LIST(list)
d397 6
a402 17
	GLOB_LIST(filename, list);
	if (GLOB_LIST_FAILED(list))
	{
		free(filename);
		return (ofilename);
	}
	length = 1; /* Room for trailing null byte */
	for (SCAN_GLOB_LIST(list, p))
	{
		INIT_GLOB_LIST(list, p);
		qfilename = shell_quote(p);
		if (qfilename != NULL)
		{
	  		length += strlen(qfilename) + 1;
			free(qfilename);
		}
	}
d404 1
a404 1
	for (SCAN_GLOB_LIST(list, p))
d406 2
a407 7
		INIT_GLOB_LIST(list, p);
		qfilename = shell_quote(p);
		if (qfilename != NULL)
		{
			sprintf(gfilename + strlen(gfilename), "%s ", qfilename);
			free(qfilename);
		}
d409 1
a409 5
	/*
	 * Overwrite the final trailing space with a null terminator.
	 */
	*--p = '\0';
	GLOB_LIST_DONE(list);
a411 1
#ifdef DECL_GLOB_NAME
d413 1
a413 51
	/*
	 * The globbing function returns a single name, and
	 * is called multiple times to walk thru all names.
	 */
	register char *p;
	register int len;
	register int n;
	char *pathname;
	char *qpathname;
	DECL_GLOB_NAME(fnd,drive,dir,fname,ext,handle)
	
	GLOB_FIRST_NAME(filename, &fnd, handle);
	if (GLOB_FIRST_FAILED(handle))
	{
		free(filename);
		return (ofilename);
	}

	_splitpath(filename, drive, dir, fname, ext);
	len = 100;
	gfilename = (char *) ecalloc(len, sizeof(char));
	p = gfilename;
	do {
		n = strlen(drive) + strlen(dir) + strlen(fnd.GLOB_NAME) + 1;
		pathname = (char *) ecalloc(n, sizeof(char));
		sprintf(pathname, "%s%s%s", drive, dir, fnd.GLOB_NAME);
		qpathname = shell_quote(pathname);
		free(pathname);
		if (qpathname != NULL)
		{
			n = strlen(qpathname);
			while (p - gfilename + n + 2 >= len)
			{
				/*
				 * No room in current buffer.
				 * Allocate a bigger one.
				 */
				len *= 2;
				*p = '\0';
				p = (char *) ecalloc(len, sizeof(char));
				strcpy(p, gfilename);
				free(gfilename);
				gfilename = p;
				p = gfilename + strlen(gfilename);
			}
			strcpy(p, qpathname);
			free(qpathname);
			p += n;
			*p++ = ' ';
		}
	} while (GLOB_NEXT_NAME(handle, &fnd) == 0);
d416 1
a416 10
	 * Overwrite the final trailing space with a null terminator.
	 */
	*--p = '\0';
	GLOB_NAME_DONE(handle);
}
#else
#if HAVE_POPEN
{
	/*
	 * We get the shell to glob the filename for us by passing
d419 1
a419 29
	FILE *fd;
	char *s;
	char *lessecho;
	char *cmd;
	char *esc;

	esc = get_meta_escape();
	if (strlen(esc) == 0)
		esc = "-";
	esc = shell_quote(esc);
	if (esc == NULL)
	{
		free(filename);
		return (ofilename);
	}
	lessecho = lgetenv("LESSECHO");
	if (lessecho == NULL || *lessecho == '\0')
		lessecho = "lessecho";
	/*
	 * Invoke lessecho, and read its output (a globbed list of filenames).
	 */
	cmd = (char *) ecalloc(strlen(lessecho) + strlen(ofilename) + (7*strlen(metachars())) + 24, sizeof(char));
	sprintf(cmd, "%s -p0x%x -d0x%x -e%s ", lessecho, openquote, closequote, esc);
	free(esc);
	for (s = metachars();  *s != '\0';  s++)
		sprintf(cmd + strlen(cmd), "-n0x%x ", *s);
	sprintf(cmd + strlen(cmd), "-- %s", ofilename);
	fd = shellcmd(cmd);
	free(cmd);
d426 1
a426 2
		free(filename);
		return (ofilename);
d433 1
a433 2
		free(filename);
		return (ofilename);
d435 1
a436 7
#else
	/*
	 * No globbing functions at all.  Just use the fexpanded filename.
	 */
	gfilename = save(filename);
#endif
#endif
a437 2
	free(filename);
	free(ofilename);
a450 3
#if !HAVE_POPEN
	return (NULL);
#else
d452 2
a453 1
	char *cmd;
a454 3
#if HAVE_FILENO
	int returnfd = 0;
#endif
a455 2
	if (!use_lessopen || secure)
		return (NULL);
d457 1
a457 1
	if ((lessopen = lgetenv("LESSOPEN")) == NULL)
a466 1
#if HAVE_FILENO
a468 4
#else
		error("LESSOPEN pipe is not supported", NULL_PARG);
		return (NULL);
#endif
d470 1
a470 6

	cmd = (char *) ecalloc(strlen(lessopen) + strlen(filename) + 2, 
			sizeof(char));
	sprintf(cmd, lessopen, filename);
	fd = shellcmd(cmd);
	free(cmd);
a477 1
#if HAVE_FILENO
d480 1
a488 1
		SET_BINARY(f);
d501 4
d506 1
a506 2
#endif
	cmd = readfd(fd);
d508 1
a508 1
	if (*cmd == '\0')
d513 1
a513 2
	return (cmd);
#endif /* HAVE_POPEN */
a524 1
#if HAVE_POPEN
a526 1
	char *cmd;
a527 2
	if (secure)
		return;
a528 8
	{
#if OS2
		/*
		 * The pclose function of OS/2 emx sometimes fails.
		 * Send SIGINT to the piped process before closing it.
		 */
		kill(((FILE*)pipefd)->_pid, SIGINT);
#endif
d530 1
a530 2
	}
	if ((lessclose = lgetenv("LESSCLOSE")) == NULL)
d532 2
a533 8
	cmd = (char *) ecalloc(strlen(lessclose) + strlen(filename) + 
			strlen(altfilename) + 2, sizeof(char));
	sprintf(cmd, lessclose, filename, altfilename);
	fd = shellcmd(cmd);
	free(cmd);
	if (fd != NULL)
		pclose(fd);
#endif
d536 48
a583 5
/*
 * Is the specified file a directory?
 */
	public int
is_dir(filename)
d586 2
a587 1
	int isdir = 0;
d589 4
a592 2
	filename = shell_unquote(filename);
#if HAVE_STAT
d594 3
a596 2
	int r;
	struct stat statbuf;
d598 5
a602 2
	r = stat(filename, &statbuf);
	isdir = (r >= 0 && S_ISDIR(statbuf.st_mode));
d604 5
a608 2
#else
#ifdef _OSK
d610 2
a611 1
	register int f;
d613 5
a617 4
	f = open(filename, S_IREAD | S_IFDIR);
	if (f >= 0)
		close(f);
	isdir = (f >= 0);
d619 1
d622 11
a632 3
	free(filename);
	return (isdir);
}
d643 8
a650 1
	register char *m = NULL;
d652 1
a652 2
	filename = shell_unquote(filename);
	if (is_dir(filename))
d654 2
a655 3
		static char is_a_dir[] = " is a directory";

		m = (char *) ecalloc(strlen(filename) + sizeof(is_a_dir), 
d658 4
a661 2
		strcat(m, is_a_dir);
	} else
d663 7
a669 3
#if HAVE_STAT
		int r;
		struct stat statbuf;
d671 1
a671 19
		r = stat(filename, &statbuf);
		if (r < 0)
		{
			m = errno_message(filename);
		} else if (force_open)
		{
			m = NULL;
		} else if (!S_ISREG(statbuf.st_mode))
		{
			static char not_reg[] = " is not a regular file (use -f to see it)";
			m = (char *) ecalloc(strlen(filename) + sizeof(not_reg),
				sizeof(char));
			strcpy(m, filename);
			strcat(m, not_reg);
		}
#endif
	}
	free(filename);
	return (m);
a681 1
#if HAVE_STAT
d684 9
a692 2
	if (fstat(f, &statbuf) >= 0)
		return ((POSITION) statbuf.st_size);
a693 2
#ifdef _OSK
	long size;
d695 8
a702 5
	if ((size = (long) _gs_size(f)) >= 0)
		return ((POSITION) size);
#endif
#endif
	return (seek_filesize(f));
d706 1
a706 1
 * 
d708 3
a710 2
	public char *
shell_coption()
d712 1
a712 1
	return ("-c");
d714 2
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
a53 2
extern int ctldisp;
extern int utf_mode;
d198 1
a198 1
		SNPRINTF3(newstr, len, "%c%s%c", openquote, s, closequote);
a228 1
	int len;
d236 2
a237 2
	len= strlen(dirname) + strlen(filename) + 2;
	pathname = (char *) calloc(len, sizeof(char));
d240 1
a240 1
	SNPRINTF3(pathname, len, "%s%s%s", dirname, PATHNAME_SEP, filename);
a399 1

a427 1
		int len;
d431 1
a431 2
		len = strlen(s) + 4;
		fpat = (char *) ecalloc(len, sizeof(char));
d433 1
a433 1
			SNPRINTF1(fpat, len, "%s*.*", s);
d435 1
a435 1
			SNPRINTF1(fpat, len, "%s*", s);
d438 2
a439 5
	{
	int len = strlen(s) + 2;
	fpat = (char *) ecalloc(len, sizeof(char));
	SNPRINTF1(fpat, len, "%s*", s);
	}
d465 1
d467 1
a467 4
	int bin_count = 0;
	char data[256];
	char* p;
	char* pend;
d471 1
a471 1
	if (lseek(f, (off_t)0, SEEK_SET) == BAD_LSEEK)
d474 4
a477 17
	pend = &data[n];
	for (p = data;  p < pend;  )
	{
		LWCHAR c = step_char(&p, +1, pend);
		if (ctldisp == OPT_ONPLUS && IS_CSI_START(c))
		{
			do {
				c = step_char(&p, +1, pend);
			} while (p < pend && is_ansi_middle(c));
		} else if (binary_char(c))
			bin_count++;
	}
	/*
	 * Call it a binary file if there are more than 5 binary characters
	 * in the first 256 bytes of the file.
	 */
	return (bin_count > 5);
d489 1
a489 1
	spos = lseek(f, (off_t)0, SEEK_END);
d573 3
a575 3
			int len = strlen(shell) + strlen(esccmd) + 5;
			scmd = (char *) ecalloc(len, sizeof(char));
			SNPRINTF3(scmd, len, "%s %s %s", shell, shell_coption(), esccmd);
d683 1
a683 1
		SNPRINTF3(pathname, n, "%s%s%s", drive, dir, fnd.GLOB_NAME);
a727 1
	int len;
d744 2
a745 3
	len = strlen(lessecho) + strlen(ofilename) + (7*strlen(metachars())) + 24;
	cmd = (char *) ecalloc(len, sizeof(char));
	SNPRINTF4(cmd, len, "%s -p0x%x -d0x%x -e%s ", lessecho, openquote, closequote, esc);
a797 1
	int len;
d808 2
d816 4
a819 1
#if !HAVE_FILENO
a821 3
#else
		lessopen++;
		returnfd = 1;
a823 9
	if (*lessopen == '-') {
		/*
		 * Lessopen preprocessor will accept "-" as a filename.
		 */
		lessopen++;
	} else {
		if (strcmp(filename, "-") == 0)
			return (NULL);
	}
d825 3
a827 3
	len = strlen(lessopen) + strlen(filename) + 2;
	cmd = (char *) ecalloc(len, sizeof(char));
	SNPRINTF1(cmd, len, lessopen, filename);
a886 1
	int len;
d903 3
a905 3
	len = strlen(lessclose) + strlen(filename) + strlen(altfilename) + 2;
	cmd = (char *) ecalloc(len, sizeof(char));
	SNPRINTF2(cmd, len, lessclose, filename, altfilename);
d959 1
a959 1
	if (!force_open && is_dir(filename))
a1025 19

/*
 * Return last component of a pathname.
 */
	public char *
last_component(name)
	char *name;
{
	char *slash;

	for (slash = name + strlen(name);  slash > name; )
	{
		--slash;
		if (*slash == *PATHNAME_SEP || *slash == '/')
			return (slash + 1);
	}
	return (name);
}

@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d210 1
a210 1
				strlcpy(p, esc, newstr + len - p);
d231 1
a231 1
	size_t len;
a260 1
#if USERFILE
d295 1
a295 1
			strlcpy(pathname, res, _MAX_PATH);
a305 1
#endif /* USERFILE */
d389 1
a389 2
					strlcpy(to, get_filename(ifile),
					    e + n + 1 - to);
a415 1
	size_t len;
d432 1
d445 1
a445 1
	len = strlen(s) + 2;
d551 1
a551 1
			strlcpy(p, buf, len);
d597 1
a597 1
			size_t len = strlen(shell) + strlen(esccmd) + 5;
a619 1
#if !SMALL
d669 1
a669 2
			snprintf(gfilename + strlen(gfilename),
			    length - strlen(gfilename), "%s ", qfilename);
d676 1
a676 2
	if (gfilename[0] != '\0' && gfilename[strlen(gfilename) - 1] == ' ')
		gfilename[strlen(gfilename) - 1] = '\0';
d722 1
a722 1
				strlcpy(p, gfilename, len);
d727 1
a727 1
			strlcpy(p, qpathname, gfilename + len - p);
d752 1
a752 1
	size_t len;
d774 2
a775 2
		snprintf(cmd + strlen(cmd), len - strlen(cmd), "-n0x%x ", *s);
	snprintf(cmd + strlen(cmd), len - strlen(cmd), "-- %s", ofilename);
a807 22
#endif /* !SMALL */

/*
 * Return number of %s escapes in a string.
 * Return a large number if there are any other % escapes besides %s.
 */
	static int
num_pct_s(lessopen)
	char *lessopen;
{
	int num;

	for (num = 0;; num++)
	{
		lessopen = strchr(lessopen, '%');
		if (lessopen == NULL)
			break;
		if (*++lessopen != 's')
			return (999);
	}
	return (num);
}
d824 1
a824 1
	size_t len;
d835 1
a835 1
	while (*lessopen == '|')
d846 1
a846 1
		returnfd++;
a857 5
	if (num_pct_s(lessopen) > 1)
	{
		error("Invalid LESSOPEN variable", NULL_PARG);
		return (NULL);
	}
d886 1
a886 5
			 * Pipe is empty.
			 * If more than 1 pipe char was specified,
			 * the exit status tells whether the file itself 
			 * is empty, or if there is no alt file.
			 * If only one pipe char, just assume no alt file.
d888 1
a888 6
			int status = pclose(fd);
			if (returnfd > 1 && status == 0) {
				*pfd = NULL;
				*pf = -1;
				return (save(FAKE_EMPTYFILE));
			}
d921 1
a921 1
	size_t len;
a937 5
	if (num_pct_s(lessclose) > 2) 
	{
		error("Invalid LESSCLOSE variable");
		return;
	}
a991 1
	size_t len;
d998 4
a1001 4
		len = strlen(filename) + sizeof(is_a_dir);
		m = (char *) ecalloc(len, sizeof(char));
		strlcpy(m, filename, len);
		strlcat(m, is_a_dir, len);
d1018 4
a1021 4
			len = strlen(filename) + sizeof(not_reg);
			m = (char *) ecalloc(len, sizeof(char));
			strlcpy(m, filename, len);
			strlcat(m, not_reg, len);
@


