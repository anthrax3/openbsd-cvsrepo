head	1.23;
access;
symbols
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.4
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.11.0.8
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.9.0.12
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.8
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.6
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.4
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.7.0.6
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.4
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.6.0.14
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.16
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.12
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	W32EN7Zp77efb8wW;

1.22
date	2016.03.16.15.36.26;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	P9ytq8HKajWPxZf9;

1.21
date	2016.01.12.23.01.23;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	5Pl94glX7ncfN0bb;

1.20
date	2015.11.13.16.48.48;	author nicm;	state Exp;
branches;
next	1.19;
commitid	1UhnxVLYjgAT43E3;

1.19
date	2015.11.09.16.46.42;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	rJ6tmXbM6ZZSV1zd;

1.18
date	2015.11.09.16.42.35;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	mkNNke62XFQvJVUG;

1.17
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	ZtGimechwgSRYqRW;

1.16
date	2015.11.09.15.38.52;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	oEMv76q01Jkt8aJk;

1.15
date	2015.11.09.02.59.06;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	krM8GIm0ktfoy1dx;

1.14
date	2015.11.07.18.07.44;	author tedu;	state Exp;
branches;
next	1.13;
commitid	DJUwzdj0cG1bCfEw;

1.13
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.12;
commitid	QKrr6AuGzNx9nehL;

1.12
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.11;
commitid	yKv9Ck9ZDgwWTRTo;

1.11
date	2014.05.10.16.45.23;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.9;

1.9
date	2011.09.21.19.01.49;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.03.16.29.46;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.02.00.55.32;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.14.14.33.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.13.18.26.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.01;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.04;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.46;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.23
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

#include <sys/stat.h>

#include "less.h"

static int fd0 = 0;

extern int new_file;
extern int errmsgs;
extern char *every_first_cmd;
extern int any_display;
extern int force_open;
extern int is_tty;
extern volatile sig_atomic_t sigs;
extern IFILE curr_ifile;
extern IFILE old_ifile;
extern struct scrpos initial_scrpos;
extern void *ml_examine;
extern char openquote;
extern char closequote;
extern int less_is_more;
extern int logfile;
extern int force_logfile;
extern char *namelogfile;

dev_t curr_dev;
ino_t curr_ino;

char *curr_altfilename = NULL;
static void *curr_altpipe;


/*
 * Textlist functions deal with a list of words separated by spaces.
 * init_textlist sets up a textlist structure.
 * forw_textlist uses that structure to iterate thru the list of
 * words, returning each one as a standard null-terminated string.
 * back_textlist does the same, but runs thru the list backwards.
 */
void
init_textlist(struct textlist *tlist, char *str)
{
	char *s;
	int meta_quoted = 0;
	int delim_quoted = 0;
	char *esc = get_meta_escape();
	int esclen = strlen(esc);

	tlist->string = skipsp(str);
	tlist->endstring = tlist->string + strlen(tlist->string);
	for (s = str; s < tlist->endstring; s++) {
		if (meta_quoted) {
			meta_quoted = 0;
		} else if (esclen > 0 && s + esclen < tlist->endstring &&
		    strncmp(s, esc, esclen) == 0) {
			meta_quoted = 1;
			s += esclen - 1;
		} else if (delim_quoted) {
			if (*s == closequote)
				delim_quoted = 0;
		} else /* (!delim_quoted) */ {
			if (*s == openquote)
				delim_quoted = 1;
			else if (*s == ' ')
				*s = '\0';
		}
	}
}

char *
forw_textlist(struct textlist *tlist, char *prev)
{
	char *s;

	/*
	 * prev == NULL means return the first word in the list.
	 * Otherwise, return the word after "prev".
	 */
	if (prev == NULL)
		s = tlist->string;
	else
		s = prev + strlen(prev);
	if (s >= tlist->endstring)
		return (NULL);
	while (*s == '\0')
		s++;
	if (s >= tlist->endstring)
		return (NULL);
	return (s);
}

char *
back_textlist(struct textlist *tlist, char *prev)
{
	char *s;

	/*
	 * prev == NULL means return the last word in the list.
	 * Otherwise, return the word before "prev".
	 */
	if (prev == NULL)
		s = tlist->endstring;
	else if (prev <= tlist->string)
		return (NULL);
	else
		s = prev - 1;
	while (*s == '\0')
		s--;
	if (s <= tlist->string)
		return (NULL);
	while (s[-1] != '\0' && s > tlist->string)
		s--;
	return (s);
}

/*
 * Close the current input file.
 */
static void
close_file(void)
{
	struct scrpos scrpos;

	if (curr_ifile == NULL)
		return;

	/*
	 * Save the current position so that we can return to
	 * the same position if we edit this file again.
	 */
	get_scrpos(&scrpos);
	if (scrpos.pos != -1) {
		store_pos(curr_ifile, &scrpos);
		lastmark();
	}
	/*
	 * Close the file descriptor, unless it is a pipe.
	 */
	ch_close();
	/*
	 * If we opened a file using an alternate name,
	 * do special stuff to close it.
	 */
	if (curr_altfilename != NULL) {
		close_altfile(curr_altfilename, get_filename(curr_ifile),
		    curr_altpipe);
		free(curr_altfilename);
		curr_altfilename = NULL;
	}
	curr_ifile = NULL;
	curr_ino = curr_dev = 0;
}

/*
 * Edit a new file (given its name).
 * Filename == "-" means standard input.
 * Filename == NULL means just close the current file.
 */
int
edit(char *filename)
{
	if (filename == NULL)
		return (edit_ifile(NULL));
	return (edit_ifile(get_ifile(filename, curr_ifile)));
}

/*
 * Edit a new file (given its IFILE).
 * ifile == NULL means just close the current file.
 */
int
edit_ifile(IFILE ifile)
{
	int f;
	int answer;
	int no_display;
	int chflags;
	char *filename;
	char *open_filename;
	char *qopen_filename;
	char *alt_filename;
	void *alt_pipe;
	IFILE was_curr_ifile;
	PARG parg;

	if (ifile == curr_ifile) {
		/*
		 * Already have the correct file open.
		 */
		return (0);
	}

	/*
	 * We must close the currently open file now.
	 * This is necessary to make the open_altfile/close_altfile pairs
	 * nest properly (or rather to avoid nesting at all).
	 * {{ Some stupid implementations of popen() mess up if you do:
	 *    fA = popen("A"); fB = popen("B"); pclose(fA); pclose(fB); }}
	 */
	end_logfile();
	was_curr_ifile = save_curr_ifile();
	if (curr_ifile != NULL) {
		chflags = ch_getflags();
		close_file();
		if ((chflags & CH_HELPFILE) &&
		    held_ifile(was_curr_ifile) <= 1) {
			/*
			 * Don't keep the help file in the ifile list.
			 */
			del_ifile(was_curr_ifile);
			was_curr_ifile = old_ifile;
		}
	}

	if (ifile == NULL) {
		/*
		 * No new file to open.
		 * (Don't set old_ifile, because if you call edit_ifile(NULL),
		 *  you're supposed to have saved curr_ifile yourself,
		 *  and you'll restore it if necessary.)
		 */
		unsave_ifile(was_curr_ifile);
		return (0);
	}

	filename = estrdup(get_filename(ifile));
	/*
	 * See if LESSOPEN specifies an "alternate" file to open.
	 */
	alt_pipe = NULL;
	alt_filename = open_altfile(filename, &f, &alt_pipe);
	open_filename = (alt_filename != NULL) ? alt_filename : filename;
	qopen_filename = shell_unquote(open_filename);

	chflags = 0;
	if (strcmp(open_filename, helpfile()) == 0)
		chflags |= CH_HELPFILE;
	if (alt_pipe != NULL) {
		/*
		 * The alternate "file" is actually a pipe.
		 * f has already been set to the file descriptor of the pipe
		 * in the call to open_altfile above.
		 * Keep the file descriptor open because it was opened
		 * via popen(), and pclose() wants to close it.
		 */
		chflags |= CH_POPENED;
	} else if (strcmp(open_filename, "-") == 0) {
		/*
		 * Use standard input.
		 * Keep the file descriptor open because we can't reopen it.
		 */
		f = fd0;
		chflags |= CH_KEEPOPEN;
	} else if (strcmp(open_filename, FAKE_EMPTYFILE) == 0) {
		f = -1;
		chflags |= CH_NODATA;
	} else if ((parg.p_string = bad_file(open_filename)) != NULL) {
		/*
		 * It looks like a bad file.  Don't try to open it.
		 */
		error("%s", &parg);
		free(parg.p_string);
err1:
		if (alt_filename != NULL) {
			close_altfile(alt_filename, filename, alt_pipe);
			free(alt_filename);
		}
		del_ifile(ifile);
		free(qopen_filename);
		free(filename);
		/*
		 * Re-open the current file.
		 */
		if (was_curr_ifile == ifile) {
			/*
			 * Whoops.  The "current" ifile is the one we just
			 * deleted. Just give up.
			 */
			quit(QUIT_ERROR);
		}
		reedit_ifile(was_curr_ifile);
		return (1);
	} else if ((f = open(qopen_filename, O_RDONLY)) < 0) {
		/*
		 * Got an error trying to open it.
		 */
		parg.p_string = errno_message(filename);
		error("%s", &parg);
		free(parg.p_string);
		goto err1;
	} else {
		chflags |= CH_CANSEEK;
		if (!force_open && !opened(ifile) && bin_file(f)) {
			/*
			 * Looks like a binary file.
			 * Ask user if we should proceed.
			 */
			parg.p_string = filename;
			answer = query("\"%s\" may be a binary file.  "
			    "See it anyway? ", &parg);
			if (answer != 'y' && answer != 'Y') {
				(void) close(f);
				goto err1;
			}
		}
	}

	/*
	 * Get the new ifile.
	 * Get the saved position for the file.
	 */
	if (was_curr_ifile != NULL) {
		old_ifile = was_curr_ifile;
		unsave_ifile(was_curr_ifile);
	}
	curr_ifile = ifile;
	curr_altfilename = alt_filename;
	curr_altpipe = alt_pipe;
	set_open(curr_ifile); /* File has been opened */
	get_pos(curr_ifile, &initial_scrpos);
	new_file = TRUE;
	ch_init(f, chflags);

	if (!(chflags & CH_HELPFILE)) {
		struct stat statbuf;
		int r;

		if (namelogfile != NULL && is_tty)
			use_logfile(namelogfile);
		/* Remember the i-number and device of opened file. */
		r = stat(qopen_filename, &statbuf);
		if (r == 0) {
			curr_ino = statbuf.st_ino;
			curr_dev = statbuf.st_dev;
		}
		if (every_first_cmd != NULL)
			ungetsc(every_first_cmd);
	}
	free(qopen_filename);
	no_display = !any_display;
	flush(0);
	any_display = TRUE;

	if (is_tty) {
		/*
		 * Output is to a real tty.
		 */

		/*
		 * Indicate there is nothing displayed yet.
		 */
		pos_clear();
		clr_linenum();
		clr_hilite();
		cmd_addhist(ml_examine, filename);
		if (no_display && errmsgs > 0) {
			/*
			 * We displayed some messages on error output
			 * (file descriptor 2; see error() function).
			 * Before erasing the screen contents,
			 * display the file name and wait for a keystroke.
			 */
			parg.p_string = filename;
			error("%s", &parg);
		}
	}
	free(filename);
	return (0);
}

/*
 * Edit a space-separated list of files.
 * For each filename in the list, enter it into the ifile list.
 * Then edit the first one.
 */
int
edit_list(char *filelist)
{
	IFILE save_ifile;
	char *good_filename;
	char *filename;
	char *gfilelist;
	char *gfilename;
	struct textlist tl_files;
	struct textlist tl_gfiles;

	save_ifile = save_curr_ifile();
	good_filename = NULL;

	/*
	 * Run thru each filename in the list.
	 * Try to glob the filename.
	 * If it doesn't expand, just try to open the filename.
	 * If it does expand, try to open each name in that list.
	 */
	init_textlist(&tl_files, filelist);
	filename = NULL;
	while ((filename = forw_textlist(&tl_files, filename)) != NULL) {
		gfilelist = lglob(filename);
		init_textlist(&tl_gfiles, gfilelist);
		gfilename = NULL;
		while ((gfilename = forw_textlist(&tl_gfiles, gfilename)) !=
		    NULL) {
			if (edit(gfilename) == 0 && good_filename == NULL)
				good_filename = get_filename(curr_ifile);
		}
		free(gfilelist);
	}
	/*
	 * Edit the first valid filename in the list.
	 */
	if (good_filename == NULL) {
		unsave_ifile(save_ifile);
		return (1);
	}
	if (get_ifile(good_filename, curr_ifile) == curr_ifile) {
		/*
		 * Trying to edit the current file; don't reopen it.
		 */
		unsave_ifile(save_ifile);
		return (0);
	}
	reedit_ifile(save_ifile);
	return (edit(good_filename));
}

/*
 * Edit the first file in the command line (ifile) list.
 */
int
edit_first(void)
{
	curr_ifile = NULL;
	return (edit_next(1));
}

/*
 * Edit the last file in the command line (ifile) list.
 */
int
edit_last(void)
{
	curr_ifile = NULL;
	return (edit_prev(1));
}


/*
 * Edit the n-th next or previous file in the command line (ifile) list.
 */
static int
edit_istep(IFILE h, int n, int dir)
{
	IFILE next;

	/*
	 * Skip n filenames, then try to edit each filename.
	 */
	for (;;) {
		next = (dir > 0) ? next_ifile(h) : prev_ifile(h);
		if (--n < 0) {
			if (edit_ifile(h) == 0)
				break;
		}
		if (next == NULL) {
			/*
			 * Reached end of the ifile list.
			 */
			return (1);
		}
		if (ABORT_SIGS()) {
			/*
			 * Interrupt breaks out, if we're in a long
			 * list of files that can't be opened.
			 */
			return (1);
		}
		h = next;
	}
	/*
	 * Found a file that we can edit.
	 */
	return (0);
}

static int
edit_inext(IFILE h, int n)
{
	return (edit_istep(h, n, +1));
}

int
edit_next(int n)
{
	return (edit_istep(curr_ifile, n, +1));
}

static int
edit_iprev(IFILE h, int n)
{
	return (edit_istep(h, n, -1));
}

int
edit_prev(int n)
{
	return (edit_istep(curr_ifile, n, -1));
}

/*
 * Edit a specific file in the command line (ifile) list.
 */
int
edit_index(int n)
{
	IFILE h;

	h = NULL;
	do {
		if ((h = next_ifile(h)) == NULL) {
			/*
			 * Reached end of the list without finding it.
			 */
			return (1);
		}
	} while (get_index(h) != n);

	return (edit_ifile(h));
}

IFILE
save_curr_ifile(void)
{
	if (curr_ifile != NULL)
		hold_ifile(curr_ifile, 1);
	return (curr_ifile);
}

void
unsave_ifile(IFILE save_ifile)
{
	if (save_ifile != NULL)
		hold_ifile(save_ifile, -1);
}

/*
 * Reedit the ifile which was previously open.
 */
void
reedit_ifile(IFILE save_ifile)
{
	IFILE next;
	IFILE prev;

	/*
	 * Try to reopen the ifile.
	 * Note that opening it may fail (maybe the file was removed),
	 * in which case the ifile will be deleted from the list.
	 * So save the next and prev ifiles first.
	 */
	unsave_ifile(save_ifile);
	next = next_ifile(save_ifile);
	prev = prev_ifile(save_ifile);
	if (edit_ifile(save_ifile) == 0)
		return;
	/*
	 * If can't reopen it, open the next input file in the list.
	 */
	if (next != NULL && edit_inext(next, 0) == 0)
		return;
	/*
	 * If can't open THAT one, open the previous input file in the list.
	 */
	if (prev != NULL && edit_iprev(prev, 0) == 0)
		return;
	/*
	 * If can't even open that, we're stuck.  Just quit.
	 */
	quit(QUIT_ERROR);
}

void
reopen_curr_ifile(void)
{
	IFILE save_ifile = save_curr_ifile();
	close_file();
	reedit_ifile(save_ifile);
}

/*
 * Edit standard input.
 */
int
edit_stdin(void)
{
	if (isatty(fd0)) {
		if (less_is_more) {
			error("Missing filename (\"more -h\" for help)",
			    NULL);
		} else {
			error("Missing filename (\"less --help\" for help)",
			    NULL);
		}
		quit(QUIT_OK);
	}
	return (edit("-"));
}

/*
 * Copy a file directly to standard output.
 * Used if standard output is not a tty.
 */
void
cat_file(void)
{
	int c;

	while ((c = ch_forw_get()) != EOI)
		putchr(c);
	flush(0);
}

/*
 * If the user asked for a log file and our input file
 * is standard input, create the log file.
 * We take care not to blindly overwrite an existing file.
 */
void
use_logfile(char *filename)
{
	int exists;
	int answer;
	PARG parg;

	if (ch_getflags() & CH_CANSEEK)
		/*
		 * Can't currently use a log file on a file that can seek.
		 */
		return;

	/*
	 * {{ We could use access() here. }}
	 */
	filename = shell_unquote(filename);
	exists = open(filename, O_RDONLY);
	close(exists);
	exists = (exists >= 0);

	/*
	 * Decide whether to overwrite the log file or append to it.
	 * If it doesn't exist we "overwrite" it.
	 */
	if (!exists || force_logfile) {
		/*
		 * Overwrite (or create) the log file.
		 */
		answer = 'O';
	} else {
		/*
		 * Ask user what to do.
		 */
		parg.p_string = filename;
		answer = query("Warning: \"%s\" exists; "
		    "Overwrite, Append or Don't log? ", &parg);
	}

loop:
	switch (answer) {
	case 'O': case 'o':
		/*
		 * Overwrite: create the file.
		 */
		logfile = open(filename, O_CREAT | O_TRUNC | O_WRONLY, 0644);
		break;
	case 'A': case 'a':
		/*
		 * Append: open the file and seek to the end.
		 */
		logfile = open(filename, O_WRONLY | O_APPEND);
		if (lseek(logfile, (off_t)0, SEEK_END) == (off_t)-1) {
			close(logfile);
			logfile = -1;
		}
		break;
	case 'D': case 'd':
		/*
		 * Don't do anything.
		 */
		free(filename);
		return;
	case 'q':
		quit(QUIT_OK);
	default:
		/*
		 * Eh?
		 */
		answer = query("Overwrite, Append, or Don't log? "
		    "(Type \"O\", \"A\", \"D\" or \"q\") ", NULL);
		goto loop;
	}

	if (logfile < 0) {
		/*
		 * Error in opening logfile.
		 */
		parg.p_string = filename;
		error("Cannot write to \"%s\"", &parg);
		free(filename);
		return;
	}
	free(filename);
}
@


1.22
log
@style(9) includes

ok nicm@@
@
text
@d61 1
a61 1
	for (s = str;  s < tlist->endstring;  s++) {
@


1.21
log
@remove lint annotations

ok nicm@@
@
text
@d12 2
a14 1
#include <sys/stat.h>
@


1.20
log
@Add a flag argument to flush() to stop it calling quit() on error, then
use this from quit() to stop less blowing up the stack looping through
quit()/flush() if stderr is closed (for example "less /missing
2</dev/null"). ok millert
@
text
@a701 1
		/*NOTREACHED*/
@


1.19
log
@NULL_IFILE has no weird use patterns.  NULL is sufficient.
@
text
@d350 1
a350 1
	flush();
d629 1
a629 1
	flush();
@


1.18
log
@use (off_t)-1 rather than a BAD_LSEEK wrapper
@
text
@d133 1
a133 1
	if (curr_ifile == NULL_IFILE)
d159 1
a159 1
	curr_ifile = NULL_IFILE;
d172 1
a172 1
		return (edit_ifile(NULL_IFILE));
d211 1
a211 1
	if (curr_ifile != NULL_IFILE) {
d224 1
a224 1
	if (ifile == NULL_IFILE) {
d321 1
a321 1
	if (was_curr_ifile != NULL_IFILE) {
d442 1
a442 1
	curr_ifile = NULL_IFILE;
d452 1
a452 1
	curr_ifile = NULL_IFILE;
d474 1
a474 1
		if (next == NULL_IFILE) {
d527 1
a527 1
	h = NULL_IFILE;
d529 1
a529 1
		if ((h = next_ifile(h)) == NULL_IFILE) {
d543 1
a543 1
	if (curr_ifile != NULL_IFILE)
d551 1
a551 1
	if (save_ifile != NULL_IFILE)
d578 1
a578 1
	if (next != NULL_IFILE && edit_inext(next, 0) == 0)
d583 1
a583 1
	if (prev != NULL_IFILE && edit_iprev(prev, 0) == 0)
@


1.17
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@d689 1
a689 1
		if (lseek(logfile, (off_t)0, SEEK_END) == BAD_LSEEK) {
@


1.16
log
@use open() with flags instead of creat()
@
text
@d608 1
a608 1
			    NULL_PARG);
d611 1
a611 1
			    NULL_PARG);
d708 1
a708 1
		    "(Type \"O\", \"A\", \"D\" or \"q\") ", NULL_PARG);
@


1.15
log
@do not need wrappers around O_RDONLY and such
@
text
@d682 1
a682 1
		logfile = creat(filename, 0644);
@


1.14
log
@replace save() with estrdup() and make estrdup() exit like all the other
ecalloc, etc. functions do.
ok mmcc nicm
@
text
@d654 1
a654 1
	exists = open(filename, OPEN_READ);
d688 1
a688 1
		logfile = open(filename, OPEN_APPEND);
@


1.13
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d235 1
a235 1
	filename = save(get_filename(ifile));
@


1.12
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.11
log
@Give more(1) its own help file, shorter than the one for less(1).
The helpfile itself was prepared by jmc@@, the glue by me.
OK millert@@ jmc@@
@
text
@d9 4
a12 1

a14 1
#if HAVE_STAT
a15 1
#endif
d17 1
a17 1
public int fd0 = 0;
a20 1
extern int cbufs;
d29 1
a29 2
extern void constant *ml_examine;
#if SPACES_IN_FILENAMES
d32 1
a32 3
#endif

#if LOGFILE
a35 1
#endif
d37 2
a38 4
#if HAVE_STAT_INO
public dev_t curr_dev;
public ino_t curr_ino;
#endif
d43 1
a43 1
#if EXAMINE || TAB_COMPLETE_FILENAME
d51 2
a52 4
	public void
init_textlist(tlist, str)
	struct textlist *tlist;
	char *str;
a54 1
#if SPACES_IN_FILENAMES
d59 1
a59 2
#endif
	
d62 2
a63 5
	for (s = str;  s < tlist->endstring;  s++)
	{
#if SPACES_IN_FILENAMES
		if (meta_quoted)
		{
d66 1
a66 2
		           strncmp(s, esc, esclen) == 0)
		{
d69 1
a69 2
		} else if (delim_quoted)
		{
d72 1
a72 2
		} else /* (!delim_quoted) */
		{
a77 4
#else
		if (*s == ' ')
			*s = '\0';
#endif
d81 2
a82 4
	public char *
forw_textlist(tlist, prev)
	struct textlist *tlist;
	char *prev;
d85 1
a85 1
	
d103 2
a104 4
	public char *
back_textlist(tlist, prev)
	struct textlist *tlist;
	char *prev;
d107 1
a107 1
	
a125 1
#endif /* EXAMINE || TAB_COMPLETE_FILENAME */
d130 2
a131 2
	static void
close_file()
d134 1
a134 1
	
d143 1
a143 2
	if (scrpos.pos != NULL_POSITION)
	{
d155 1
a155 2
	if (curr_altfilename != NULL)
	{
d157 1
a157 1
				curr_altpipe);
a161 1
#if HAVE_STAT_INO
a162 1
#endif
d170 2
a171 3
	public int
edit(filename)
	char *filename;
d177 1
a177 1
	
d182 2
a183 3
	public int
edit_ifile(ifile)
	IFILE ifile;
d196 2
a197 3
		
	if (ifile == curr_ifile)
	{
a210 1
#if LOGFILE
a211 1
#endif
d213 1
a213 2
	if (curr_ifile != NULL_IFILE)
	{
d216 2
a217 3
#if !SMALL
		if ((chflags & CH_HELPFILE) && held_ifile(was_curr_ifile) <= 1)
		{
a223 1
#endif /* !SMALL */
d226 1
a226 2
	if (ifile == NULL_IFILE)
	{
a246 1
#if !SMALL
d249 1
a249 3
#endif /* !SMALL */
	if (alt_pipe != NULL)
	{
d254 1
a254 1
		 * Keep the file descriptor open because it was opened 
d258 2
a259 3
	} else if (strcmp(open_filename, "-") == 0)
	{
		/* 
d265 1
a265 14
		/*
		 * Must switch stdin to BINARY mode.
		 */
		SET_BINARY(f);
#if MSDOS_COMPILER==DJGPPC
		/*
		 * Setting stdin to binary by default causes
		 * Ctrl-C to not raise SIGINT.  We must undo
		 * that side-effect.
		 */
		__djgpp_set_ctrl_c(1);
#endif
	} else if (strcmp(open_filename, FAKE_EMPTYFILE) == 0)
	{
d268 1
a268 2
	} else if ((parg.p_string = bad_file(open_filename)) != NULL)
	{
d274 2
a275 3
	    err1:
		if (alt_filename != NULL)
		{
d285 1
a285 2
		if (was_curr_ifile == ifile)
		{
d287 2
a288 2
			 * Whoops.  The "current" ifile is the one we just deleted.
			 * Just give up.
d294 1
a294 2
	} else if ((f = open(qopen_filename, OPEN_READ)) < 0)
	{
d301 2
a302 3
	    	goto err1;
	} else 
	{
d304 1
a304 2
		if (!force_open && !opened(ifile) && bin_file(f))
		{
d306 1
a306 1
			 * Looks like a binary file.  
d310 4
a313 5
			answer = query("\"%s\" may be a binary file.  See it anyway? ",
				&parg);
			if (answer != 'y' && answer != 'Y')
			{
				close(f);
d323 1
a323 2
	if (was_curr_ifile != NULL_IFILE)
	{
d335 4
a338 3
	if (!(chflags & CH_HELPFILE))
	{
#if LOGFILE
d341 5
a345 11
#endif
#if HAVE_STAT_INO
		/* Remember the i-number and device of the opened file. */
		{
			struct stat statbuf;
			int r = stat(qopen_filename, &statbuf);
			if (r == 0)
			{
				curr_ino = statbuf.st_ino;
				curr_dev = statbuf.st_dev;
			}
a346 1
#endif
a349 1

d355 1
a355 2
	if (is_tty)
	{
a364 1
#if HILITE_SEARCH
a365 1
#endif
d367 1
a367 2
		if (no_display && errmsgs > 0)
		{
a381 1
#if EXAMINE
d387 2
a388 3
	public int
edit_list(filelist)
	char *filelist;
d400 1
a400 1
	
d403 1
a403 1
	 * Try to glob the filename.  
d409 1
a409 2
	while ((filename = forw_textlist(&tl_files, filename)) != NULL)
	{
d413 2
a414 2
		while ((gfilename = forw_textlist(&tl_gfiles, gfilename)) != NULL)
		{
d423 1
a423 2
	if (good_filename == NULL)
	{
d427 1
a427 2
	if (get_ifile(good_filename, curr_ifile) == curr_ifile)
	{
a436 1
#endif /* EXAMINE */
d441 2
a442 2
	public int
edit_first()
d451 2
a452 2
	public int
edit_last()
d462 2
a463 5
	static int
edit_istep(h, n, dir)
	IFILE h;
	int n;
	int dir;
d470 1
a470 2
	for (;;)
	{
d472 1
a472 2
		if (--n < 0)
		{
d476 1
a476 2
		if (next == NULL_IFILE)
		{
d482 1
a482 2
		if (ABORT_SIGS())
		{
d490 1
a490 1
	} 
d497 2
a498 4
	static int
edit_inext(h, n)
	IFILE h;
	int n;
d503 2
a504 3
	public int
edit_next(n)
	int n;
d506 1
a506 1
	return edit_istep(curr_ifile, n, +1);
d509 2
a510 4
	static int
edit_iprev(h, n)
	IFILE h;
	int n;
d515 2
a516 3
	public int
edit_prev(n)
	int n;
d518 1
a518 1
	return edit_istep(curr_ifile, n, -1);
d524 2
a525 3
	public int
edit_index(n)
	int n;
d530 2
a531 4
	do
	{
		if ((h = next_ifile(h)) == NULL_IFILE)
		{
d542 2
a543 2
	public IFILE
save_curr_ifile()
d550 2
a551 3
	public void
unsave_ifile(save_ifile)
	IFILE save_ifile;
d560 2
a561 3
	public void
reedit_ifile(save_ifile)
	IFILE save_ifile;
d593 2
a594 2
	public void
reopen_curr_ifile()
d604 2
a605 2
	public int
edit_stdin()
d607 8
a614 3
	if (isatty(fd0))
	{
		error("Missing filename (\"less --help\" for help)", NULL_PARG);
d624 2
a625 2
	public void
cat_file()
d627 1
a627 1
	register int c;
a633 2
#if LOGFILE

d636 1
a636 1
 * is standard input, create the log file.  
d639 2
a640 3
	public void
use_logfile(filename)
	char *filename;
d642 2
a643 2
	register int exists;
	register int answer;
d664 1
a664 2
	if (!exists || force_logfile)
	{
d669 1
a669 2
	} else
	{
d674 2
a675 1
		answer = query("Warning: \"%s\" exists; Overwrite, Append or Don't log? ", &parg);
d679 1
a679 2
	switch (answer)
	{
d691 1
a691 2
		if (lseek(logfile, (off_t)0, SEEK_END) == BAD_LSEEK)
		{
d709 2
a710 1
		answer = query("Overwrite, Append, or Don't log? (Type \"O\", \"A\", \"D\" or \"q\") ", NULL_PARG);
d714 1
a714 2
	if (logfile < 0)
	{
a723 1
	SET_BINARY(logfile);
a724 2

#endif
@


1.10
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d286 1
a286 1
	if (strcmp(open_filename, HELPFILE) == 0)
@


1.9
log
@Use volatile sig_atomic_t, not int, for the sigs variable.  Also
move the call to bell() out of u_interrupt() (a signal handler).
OK and with help from deraadt@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d319 4
@


1.8
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d26 1
a26 1
extern int sigs;
@


1.7
log
@use SMALL_PROGRAM to knock out some code
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d13 3
d42 5
d50 1
a50 1

a125 1
#ifndef SMALL_PROGRAM
d151 1
a151 1
#endif /* SMALL_PROGRAM */
d190 3
d252 10
d286 4
d339 8
a376 1
	free(qopen_filename);
d395 2
d398 2
a399 2
	if (namelogfile != NULL && is_tty)
		use_logfile(namelogfile);
d401 15
a415 2
	if (every_first_cmd != NULL)
		ungetsc(every_first_cmd);
d417 1
d453 1
a453 1
#ifndef SMALL_PROGRAM
d513 1
a513 1
#endif /* SMALL_PROGRAM */
d537 1
a537 1
 * Edit the next or previous file in the command line (ifile) list.
d586 1
a586 1
	return (edit_istep(h, n, 1));
d593 1
a593 1
	return edit_istep(curr_ifile, n, 1);
d686 8
@


1.6
log
@use SEEK_* for lseek()
@
text
@d118 1
d144 1
d406 1
d466 1
@


1.5
log
@o go back to using a help file instead of embedding it in the binary
o deal with HELPFILE not being defined
o add a SMALL definition to make a smaller less for the boot floppies
This still needs to be pared down a bit for the SMALL case
@
text
@d727 1
a727 1
		if (lseek(logfile, (off_t)0, 2) == BAD_LSEEK)
@


1.4
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@a239 8
		if ((chflags & CH_HELPFILE) && held_ifile(was_curr_ifile) <= 1)
		{
			/*
			 * Don't keep the help file in the ifile list.
			 */
			del_ifile(was_curr_ifile);
			was_curr_ifile = old_ifile;
		}
a293 4
	} else if (strcmp(open_filename, FAKE_HELPFILE) == 0)
	{
		f = -1;
		chflags |= CH_HELPFILE;
a361 2
	if (!(chflags & CH_HELPFILE))
	{
d363 2
a364 2
		if (namelogfile != NULL && is_tty)
			use_logfile(namelogfile);
d366 2
a367 3
		if (every_first_cmd != NULL)
			ungetsc(every_first_cmd);
	}
@


1.3
log
@kill more registers

millert@@ ok
@
text
@a0 2
/*	$OpenBSD: edit.c,v 1.2 2001/01/29 01:58:01 niklas Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a17 1
extern int quit_at_eof;
d23 1
d27 5
d56 6
d67 21
d90 1
d154 1
d176 1
a176 1
			curr_altpipe);
d211 1
d235 1
a235 1
	was_curr_ifile = curr_ifile;
d238 1
d240 8
d258 1
d262 1
a262 1
	filename = get_filename(ifile);
d269 1
d290 16
d320 2
d325 1
a325 1
		(void) edit_ifile(was_curr_ifile);
d327 1
a327 1
	} else if ((f = open(open_filename, OPEN_READ)) < 0)
d336 1
a336 1
	} else if (!force_open && !opened(ifile) && bin_file(f))
d338 2
a339 7
		/*
		 * Looks like a binary file.  Ask user if we should proceed.
		 */
		parg.p_string = filename;
		answer = query("\"%s\" may be a binary file.  See it anyway? ",
			&parg);
		if (answer != 'y' && answer != 'Y')
d341 12
a352 2
			close(f);
			goto err1;
d355 1
d362 1
d364 2
d373 3
d377 2
a378 2
	if (namelogfile != NULL && is_tty)
		use_logfile(namelogfile);
d380 3
a382 3

	if (every_first_cmd != NULL)
		ungetsc(every_first_cmd);
d402 1
d415 1
d428 1
a428 1
	IFILE save_curr_ifile;
d436 1
a436 1
	save_curr_ifile = curr_ifile;
d449 1
a449 1
		gfilelist = glob(filename);
d463 2
d466 1
d468 1
d472 1
d474 2
a475 2
	if (edit_ifile(save_curr_ifile))
		quit(QUIT_ERROR);
d501 1
a501 1
 * Edit the next file in the command line (ifile) list.
d503 3
a505 2
	public int
edit_next(n)
d507 1
a508 1
	IFILE h;
a510 1
	h = curr_ifile;
d516 1
a516 1
		next = next_ifile(h);
d529 8
d545 8
a552 3
/*
 * Edit the previous file in the command line list.
 */
d554 1
a554 1
edit_prev(n)
d557 5
d563 4
a566 1
	IFILE next;
d568 5
a572 25
	h = curr_ifile;
	/*
	 * Skip n filenames, then try to edit each filename.
	 */
	for (;;)
	{
		next = prev_ifile(h);
		if (--n < 0)
		{
			if (edit_ifile(h) == 0)
				break;
		}
		if (next == NULL_IFILE)
		{
			/*
			 * Reached beginning of the ifile list.
			 */
			return (1);
		}
		h = next;
	} 
	/*
	 * Found a file that we can edit.
	 */
	return (0);
d599 53
d660 1
a660 5
#if MSOFTC || OS2
		error("Missing filename (\"less -?\" for help)", NULL_PARG);
#else
		error("Missing filename (\"less -\\?\" for help)", NULL_PARG);
#endif
d673 1
a673 1
	int c;
d691 2
a692 2
	int exists;
	int answer;
d704 1
d752 1
d772 2
d775 2
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d558 1
a558 1
	register int c;
d576 2
a577 2
	register int exists;
	register int answer;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d34 1
a39 1
extern int sigs;
a42 5
extern void constant *ml_examine;
#if SPACES_IN_FILENAMES
extern char openquote;
extern char closequote;
#endif
a66 6
#if SPACES_IN_FILENAMES
	int meta_quoted = 0;
	int delim_quoted = 0;
	char *esc = get_meta_escape();
	int esclen = strlen(esc);
#endif
a71 21
#if SPACES_IN_FILENAMES
		if (meta_quoted)
		{
			meta_quoted = 0;
		} else if (esclen > 0 && s + esclen < tlist->endstring &&
		           strncmp(s, esc, esclen) == 0)
		{
			meta_quoted = 1;
			s += esclen - 1;
		} else if (delim_quoted)
		{
			if (*s == closequote)
				delim_quoted = 0;
		} else /* (!delim_quoted) */
		{
			if (*s == openquote)
				delim_quoted = 1;
			else if (*s == ' ')
				*s = '\0';
		}
#else
a73 1
#endif
a136 1

d158 1
a158 1
				curr_altpipe);
a192 1
	char *qopen_filename;
d216 1
a216 1
	was_curr_ifile = save_curr_ifile();
a218 1
		chflags = ch_getflags();
a219 8
		if ((chflags & CH_HELPFILE) && held_ifile(was_curr_ifile) <= 1)
		{
			/*
			 * Don't keep the help file in the ifile list.
			 */
			del_ifile(was_curr_ifile);
			was_curr_ifile = old_ifile;
		}
a229 1
		unsave_ifile(was_curr_ifile);
d233 1
a233 1
	filename = save(get_filename(ifile));
a239 1
	qopen_filename = shell_unquote(open_filename);
a259 16
		/*
		 * Must switch stdin to BINARY mode.
		 */
		SET_BINARY(f);
#if MSDOS_COMPILER==DJGPPC
		/*
		 * Setting stdin to binary by default causes
		 * Ctrl-C to not raise SIGINT.  We must undo
		 * that side-effect.
		 */
		__djgpp_set_ctrl_c(1);
#endif
	} else if (strcmp(open_filename, FAKE_HELPFILE) == 0)
	{
		f = -1;
		chflags |= CH_HELPFILE;
a273 2
		free(qopen_filename);
		free(filename);
d277 1
a277 1
		reedit_ifile(was_curr_ifile);
d279 1
a279 1
	} else if ((f = open(qopen_filename, OPEN_READ)) < 0)
d288 1
a288 1
	} else 
d290 7
a296 2
		chflags |= CH_CANSEEK;
		if (!force_open && !opened(ifile) && bin_file(f))
d298 2
a299 12
			/*
			 * Looks like a binary file.  
			 * Ask user if we should proceed.
			 */
			parg.p_string = filename;
			answer = query("\"%s\" may be a binary file.  See it anyway? ",
				&parg);
			if (answer != 'y' && answer != 'Y')
			{
				close(f);
				goto err1;
			}
a301 1
	free(qopen_filename);
a307 1
	{
a308 2
		unsave_ifile(was_curr_ifile);
	}
a315 3

	if (!(chflags & CH_HELPFILE))
	{
d317 2
a318 2
		if (namelogfile != NULL && is_tty)
			use_logfile(namelogfile);
d320 3
a322 3
		if (every_first_cmd != NULL)
			ungetsc(every_first_cmd);
	}
a341 1
		cmd_addhist(ml_examine, filename);
a353 1
	free(filename);
d366 1
a366 1
	IFILE save_ifile;
d374 1
a374 1
	save_ifile = save_curr_ifile();
d387 1
a387 1
		gfilelist = lglob(filename);
a400 2
	{
		unsave_ifile(save_ifile);
a401 1
	}
a402 1
	{
a405 1
		unsave_ifile(save_ifile);
d407 2
a408 2
	}
	reedit_ifile(save_ifile);
d434 1
a434 1
 * Edit the next or previous file in the command line (ifile) list.
d436 2
a437 3
	static int
edit_istep(h, n, dir)
	IFILE h;
a438 1
	int dir;
d440 1
d443 1
d449 1
a449 1
		next = (dir > 0) ? next_ifile(h) : prev_ifile(h);
a461 8
		if (ABORT_SIGS())
		{
			/*
			 * Interrupt breaks out, if we're in a long
			 * list of files that can't be opened.
			 */
			return (1);
		}
d470 3
a472 8
	static int
edit_inext(h, n)
	IFILE h;
	int n;
{
	return (edit_istep(h, n, 1));
}

d474 1
a474 1
edit_next(n)
a476 5
	return edit_istep(curr_ifile, n, 1);
}

	static int
edit_iprev(h, n)
d478 1
a478 4
	int n;
{
	return (edit_istep(h, n, -1));
}
d480 25
a504 5
	public int
edit_prev(n)
	int n;
{
	return edit_istep(curr_ifile, n, -1);
a530 53
	public IFILE
save_curr_ifile()
{
	if (curr_ifile != NULL_IFILE)
		hold_ifile(curr_ifile, 1);
	return (curr_ifile);
}

	public void
unsave_ifile(save_ifile)
	IFILE save_ifile;
{
	if (save_ifile != NULL_IFILE)
		hold_ifile(save_ifile, -1);
}

/*
 * Reedit the ifile which was previously open.
 */
	public void
reedit_ifile(save_ifile)
	IFILE save_ifile;
{
	IFILE next;
	IFILE prev;

	/*
	 * Try to reopen the ifile.
	 * Note that opening it may fail (maybe the file was removed),
	 * in which case the ifile will be deleted from the list.
	 * So save the next and prev ifiles first.
	 */
	unsave_ifile(save_ifile);
	next = next_ifile(save_ifile);
	prev = prev_ifile(save_ifile);
	if (edit_ifile(save_ifile) == 0)
		return;
	/*
	 * If can't reopen it, open the next input file in the list.
	 */
	if (next != NULL_IFILE && edit_inext(next, 0) == 0)
		return;
	/*
	 * If can't open THAT one, open the previous input file in the list.
	 */
	if (prev != NULL_IFILE && edit_iprev(prev, 0) == 0)
		return;
	/*
	 * If can't even open that, we're stuck.  Just quit.
	 */
	quit(QUIT_ERROR);
}

d539 5
a543 1
		error("Missing filename (\"less --help\" for help)", NULL_PARG);
a586 1
	filename = shell_unquote(filename);
a633 1
		free(filename);
a652 2
		free(filename);
		return;
a653 2
	free(filename);
	SET_BINARY(logfile);
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
a12 3
#if HAVE_STAT
#include <sys/stat.h>
#endif
a38 5
#if HAVE_STAT_INO
public dev_t curr_dev;
public ino_t curr_ino;
#endif

a180 3
#if HAVE_STAT_INO
	curr_ino = curr_dev = 0;
#endif
a324 8
		if (was_curr_ifile == ifile)
		{
			/*
			 * Whoops.  The "current" ifile is the one we just deleted.
			 * Just give up.
			 */
			quit(QUIT_ERROR);
		}
d355 1
a379 12
#if HAVE_STAT_INO
		/* Remember the i-number and device of the opened file. */
		{
			struct stat statbuf;
			int r = stat(qopen_filename, &statbuf);
			if (r == 0)
			{
				curr_ino = statbuf.st_ino;
				curr_dev = statbuf.st_dev;
			}
		}
#endif
a383 1
	free(qopen_filename);
d501 1
a501 1
 * Edit the n-th next or previous file in the command line (ifile) list.
d550 1
a550 1
	return (edit_istep(h, n, +1));
d557 1
a557 1
	return edit_istep(curr_ifile, n, +1);
a651 8
	public void
reopen_curr_ifile()
{
	IFILE save_ifile = save_curr_ifile();
	close_file();
	reedit_ifile(save_ifile);
}

d742 1
a742 1
		if (lseek(logfile, (off_t)0, SEEK_END) == BAD_LSEEK)
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d26 1
a26 1
extern volatile sig_atomic_t sigs;
d50 1
a50 1
#if EXAMINE || TAB_COMPLETE_FILENAME
a150 1
#endif /* EXAMINE || TAB_COMPLETE_FILENAME */
a250 1
#if !SMALL
a258 1
#endif /* !SMALL */
a282 4
#if !SMALL
	if (strcmp(open_filename, HELPFILE) == 0)
		chflags |= CH_HELPFILE;
#endif /* !SMALL */
d313 1
a313 1
	} else if (strcmp(open_filename, FAKE_EMPTYFILE) == 0)
d316 1
a316 1
		chflags |= CH_NODATA;
a449 1
#if EXAMINE
a508 1
#endif /* EXAMINE */
@


