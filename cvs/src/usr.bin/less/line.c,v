head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.2
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.12.0.8
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.11.0.12
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.8
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.6
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.4
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.9.0.24
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.22
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.20
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.16
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.18
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.14
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.12
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.10
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.8
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.6
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	W32EN7Zp77efb8wW;

1.20
date	2016.03.26.08.59.29;	author natano;	state Exp;
branches;
next	1.19;
commitid	aHC2gPZgpee3p3uV;

1.19
date	2016.03.16.15.36.26;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	P9ytq8HKajWPxZf9;

1.18
date	2016.01.26.01.51.06;	author mmcc;	state Exp;
branches;
next	1.17;
commitid	srJYJwfAmHQyrX7w;

1.17
date	2016.01.13.22.47.45;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	Uz3YEYZCcKwdp847;

1.16
date	2016.01.12.17.48.04;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	O36S2Tb0ReI34f9s;

1.15
date	2015.11.09.14.25.32;	author mmcc;	state Exp;
branches;
next	1.14;
commitid	bgQj8bNZKDat4TZ4;

1.14
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.13;
commitid	QKrr6AuGzNx9nehL;

1.13
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.12;
commitid	yKv9Ck9ZDgwWTRTo;

1.12
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.11;

1.11
date	2011.09.21.19.01.49;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.11.19.20.10;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.27.17.17.54;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.08.15.18.28;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.18.18.39.52;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.06.23.38.07;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.06;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.49;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.21
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Routines to manipulate the "line buffer".
 * The line buffer holds a line of output as it is being built
 * in preparation for output to the screen.
 */

#include "charset.h"
#include "less.h"

static char *linebuf = NULL;	/* Buffer which holds the current output line */
static char *attr = NULL;	/* Extension of linebuf to hold attributes */
int size_linebuf = 0;		/* Size of line buffer (and attr buffer) */

static int cshift;		/* Current left-shift of output line buffer */
int hshift;			/* Desired left-shift of output line buffer */
int tabstops[TABSTOP_MAX] = { 0 }; /* Custom tabstops */
int ntabstops = 1;		/* Number of tabstops */
int tabdefault = 8;		/* Default repeated tabstops */
off_t highest_hilite;		/* Pos of last hilite in file found so far */

static int curr;		/* Index into linebuf */
static int column;	/* Printable length, accounting for backspaces, etc. */
static int overstrike;		/* Next char should overstrike previous char */
static int is_null_line;	/* There is no current line */
static int lmargin;		/* Left margin */
static char pendc;
static off_t pendpos;
static char *end_ansi_chars;
static char *mid_ansi_chars;

static int attr_swidth(int);
static int attr_ewidth(int);
static int do_append(LWCHAR, char *, off_t);

extern volatile sig_atomic_t sigs;
extern int bs_mode;
extern int linenums;
extern int ctldisp;
extern int twiddle;
extern int binattr;
extern int status_col;
extern int auto_wrap, ignaw;
extern int bo_s_width, bo_e_width;
extern int ul_s_width, ul_e_width;
extern int bl_s_width, bl_e_width;
extern int so_s_width, so_e_width;
extern int sc_width, sc_height;
extern int utf_mode;
extern off_t start_attnpos;
extern off_t end_attnpos;

static char mbc_buf[MAX_UTF_CHAR_LEN];
static int mbc_buf_len = 0;
static int mbc_buf_index = 0;
static off_t mbc_pos;

/*
 * Initialize from environment variables.
 */
void
init_line(void)
{
	end_ansi_chars = lgetenv("LESSANSIENDCHARS");
	if (end_ansi_chars == NULL || *end_ansi_chars == '\0')
		end_ansi_chars = "m";

	mid_ansi_chars = lgetenv("LESSANSIMIDCHARS");
	if (mid_ansi_chars == NULL || *mid_ansi_chars == '\0')
		mid_ansi_chars = "0123456789;[?!\"'#%()*+ ";

	linebuf = ecalloc(LINEBUF_SIZE, sizeof (char));
	attr = ecalloc(LINEBUF_SIZE, sizeof (char));
	size_linebuf = LINEBUF_SIZE;
}

/*
 * Expand the line buffer.
 */
static int
expand_linebuf(void)
{
	/* Double the size of the line buffer. */
	int new_size = size_linebuf * 2;

	/* Just realloc to expand the buffer, if we can. */
	char *new_buf = realloc(linebuf, new_size);
	char *new_attr = realloc(attr, new_size);
	if (new_buf == NULL || new_attr == NULL) {
		free(new_attr);
		free(new_buf);
		return (1);
	}
	linebuf = new_buf;
	attr = new_attr;
	size_linebuf = new_size;
	return (0);
}

/*
 * Is a character ASCII?
 */
int
is_ascii_char(LWCHAR ch)
{
	return (ch <= 0x7F);
}

/*
 * Rewind the line buffer.
 */
void
prewind(void)
{
	curr = 0;
	column = 0;
	cshift = 0;
	overstrike = 0;
	mbc_buf_len = 0;
	is_null_line = 0;
	pendc = '\0';
	lmargin = 0;
	if (status_col)
		lmargin += 1;
}

/*
 * Insert the line number (of the given position) into the line buffer.
 */
void
plinenum(off_t pos)
{
	off_t linenum = 0;
	int i;

	if (linenums == OPT_ONPLUS) {
		/*
		 * Get the line number and put it in the current line.
		 * {{ Note: since find_linenum calls forw_raw_line,
		 *    it may seek in the input file, requiring the caller
		 *    of plinenum to re-seek if necessary. }}
		 * {{ Since forw_raw_line modifies linebuf, we must
		 *    do this first, before storing anything in linebuf. }}
		 */
		linenum = find_linenum(pos);
	}

	/*
	 * Display a status column if the -J option is set.
	 */
	if (status_col) {
		linebuf[curr] = ' ';
		if (start_attnpos != -1 &&
		    pos >= start_attnpos && pos < end_attnpos)
			attr[curr] = AT_NORMAL|AT_HILITE;
		else
			attr[curr] = AT_NORMAL;
		curr++;
		column++;
	}
	/*
	 * Display the line number at the start of each line
	 * if the -N option is set.
	 */
	if (linenums == OPT_ONPLUS) {
		char buf[23];
		int n;

		postoa(linenum, buf, sizeof(buf));
		n = strlen(buf);
		if (n < MIN_LINENUM_WIDTH)
			n = MIN_LINENUM_WIDTH;
		snprintf(linebuf+curr, size_linebuf-curr, "%*s ", n, buf);
		n++;	/* One space after the line number. */
		for (i = 0; i < n; i++)
			attr[curr+i] = AT_NORMAL;
		curr += n;
		column += n;
		lmargin += n;
	}

	/*
	 * Append enough spaces to bring us to the lmargin.
	 */
	while (column < lmargin) {
		linebuf[curr] = ' ';
		attr[curr++] = AT_NORMAL;
		column++;
	}
}

/*
 * Shift the input line left.
 * This means discarding N printable chars at the start of the buffer.
 */
static void
pshift(int shift)
{
	LWCHAR prev_ch = 0;
	unsigned char c;
	int shifted = 0;
	int to;
	int from;
	int len;
	int width;
	int prev_attr;
	int next_attr;

	if (shift > column - lmargin)
		shift = column - lmargin;
	if (shift > curr - lmargin)
		shift = curr - lmargin;

	to = from = lmargin;
	/*
	 * We keep on going when shifted == shift
	 * to get all combining chars.
	 */
	while (shifted <= shift && from < curr) {
		c = linebuf[from];
		if (ctldisp == OPT_ONPLUS && IS_CSI_START(c)) {
			/* Keep cumulative effect.  */
			linebuf[to] = c;
			attr[to++] = attr[from++];
			while (from < curr && linebuf[from]) {
				linebuf[to] = linebuf[from];
				attr[to++] = attr[from];
				if (!is_ansi_middle(linebuf[from++]))
					break;
			}
			continue;
		}

		width = 0;

		if (!IS_ASCII_OCTET(c) && utf_mode) {
			/* Assumes well-formedness validation already done.  */
			LWCHAR ch;

			len = utf_len(c);
			if (from + len > curr)
				break;
			ch = get_wchar(linebuf + from);
			if (!is_composing_char(ch) &&
			    !is_combining_char(prev_ch, ch))
				width = is_wide_char(ch) ? 2 : 1;
			prev_ch = ch;
		} else {
			len = 1;
			if (c == '\b')
				/* XXX - Incorrect if several '\b' in a row.  */
				width = (utf_mode && is_wide_char(prev_ch)) ?
				    -2 : -1;
			else if (!control_char(c))
				width = 1;
			prev_ch = 0;
		}

		if (width == 2 && shift - shifted == 1) {
			/* Should never happen when called by pshift_all().  */
			attr[to] = attr[from];
			/*
			 * Assume a wide_char will never be the first half of a
			 * combining_char pair, so reset prev_ch in case we're
			 * followed by a '\b'.
			 */
			prev_ch = linebuf[to++] = ' ';
			from += len;
			shifted++;
			continue;
		}

		/* Adjust width for magic cookies. */
		prev_attr = (to > 0) ? attr[to-1] : AT_NORMAL;
		next_attr = (from + len < curr) ? attr[from + len] : prev_attr;
		if (!is_at_equiv(attr[from], prev_attr) &&
		    !is_at_equiv(attr[from], next_attr)) {
			width += attr_swidth(attr[from]);
			if (from + len < curr)
				width += attr_ewidth(attr[from]);
			if (is_at_equiv(prev_attr, next_attr)) {
				width += attr_ewidth(prev_attr);
				if (from + len < curr)
					width += attr_swidth(next_attr);
			}
		}

		if (shift - shifted < width)
			break;
		from += len;
		shifted += width;
		if (shifted < 0)
			shifted = 0;
	}
	while (from < curr) {
		linebuf[to] = linebuf[from];
		attr[to++] = attr[from++];
	}
	curr = to;
	column -= shifted;
	cshift += shifted;
}

/*
 *
 */
void
pshift_all(void)
{
	pshift(column);
}

/*
 * Return the printing width of the start (enter) sequence
 * for a given character attribute.
 */
static int
attr_swidth(int a)
{
	int w = 0;

	a = apply_at_specials(a);

	if (a & AT_UNDERLINE)
		w += ul_s_width;
	if (a & AT_BOLD)
		w += bo_s_width;
	if (a & AT_BLINK)
		w += bl_s_width;
	if (a & AT_STANDOUT)
		w += so_s_width;

	return (w);
}

/*
 * Return the printing width of the end (exit) sequence
 * for a given character attribute.
 */
static int
attr_ewidth(int a)
{
	int w = 0;

	a = apply_at_specials(a);

	if (a & AT_UNDERLINE)
		w += ul_e_width;
	if (a & AT_BOLD)
		w += bo_e_width;
	if (a & AT_BLINK)
		w += bl_e_width;
	if (a & AT_STANDOUT)
		w += so_e_width;

	return (w);
}

/*
 * Return the printing width of a given character and attribute,
 * if the character were added to the current position in the line buffer.
 * Adding a character with a given attribute may cause an enter or exit
 * attribute sequence to be inserted, so this must be taken into account.
 */
static int
pwidth(LWCHAR ch, int a, LWCHAR prev_ch)
{
	int w;

	if (ch == '\b')
		/*
		 * Backspace moves backwards one or two positions.
		 * XXX - Incorrect if several '\b' in a row.
		 */
		return ((utf_mode && is_wide_char(prev_ch)) ? -2 : -1);

	if (!utf_mode || is_ascii_char(ch)) {
		if (control_char((char)ch)) {
			/*
			 * Control characters do unpredictable things,
			 * so we don't even try to guess; say it doesn't move.
			 * This can only happen if the -r flag is in effect.
			 */
			return (0);
		}
	} else {
		if (is_composing_char(ch) || is_combining_char(prev_ch, ch)) {
			/*
			 * Composing and combining chars take up no space.
			 *
			 * Some terminals, upon failure to compose a
			 * composing character with the character(s) that
			 * precede(s) it will actually take up one column
			 * for the composing character; there isn't much
			 * we could do short of testing the (complex)
			 * composition process ourselves and printing
			 * a binary representation when it fails.
			 */
			return (0);
		}
	}

	/*
	 * Other characters take one or two columns,
	 * plus the width of any attribute enter/exit sequence.
	 */
	w = 1;
	if (is_wide_char(ch))
		w++;
	if (curr > 0 && !is_at_equiv(attr[curr-1], a))
		w += attr_ewidth(attr[curr-1]);
	if ((apply_at_specials(a) != AT_NORMAL) &&
	    (curr == 0 || !is_at_equiv(attr[curr-1], a)))
		w += attr_swidth(a);
	return (w);
}

/*
 * Delete to the previous base character in the line buffer.
 * Return 1 if one is found.
 */
static int
backc(void)
{
	LWCHAR prev_ch;
	char *p = linebuf + curr;
	LWCHAR ch = step_char(&p, -1, linebuf + lmargin);
	int width;

	/* This assumes that there is no '\b' in linebuf.  */
	while (curr > lmargin && column > lmargin &&
	    (!(attr[curr - 1] & (AT_ANSI|AT_BINARY)))) {
		curr = p - linebuf;
		prev_ch = step_char(&p, -1, linebuf + lmargin);
		width = pwidth(ch, attr[curr], prev_ch);
		column -= width;
		if (width > 0)
			return (1);
		ch = prev_ch;
	}

	return (0);
}

/*
 * Are we currently within a recognized ANSI escape sequence?
 */
static int
in_ansi_esc_seq(void)
{
	char *p;

	/*
	 * Search backwards for either an ESC (which means we ARE in a seq);
	 * or an end char (which means we're NOT in a seq).
	 */
	for (p = &linebuf[curr]; p > linebuf; ) {
		LWCHAR ch = step_char(&p, -1, linebuf);
		if (IS_CSI_START(ch))
			return (1);
		if (!is_ansi_middle(ch))
			return (0);
	}
	return (0);
}

/*
 * Is a character the end of an ANSI escape sequence?
 */
int
is_ansi_end(LWCHAR ch)
{
	if (!is_ascii_char(ch))
		return (0);
	return (strchr(end_ansi_chars, (char)ch) != NULL);
}

/*
 *
 */
int
is_ansi_middle(LWCHAR ch)
{
	if (!is_ascii_char(ch))
		return (0);
	if (is_ansi_end(ch))
		return (0);
	return (strchr(mid_ansi_chars, (char)ch) != NULL);
}

/*
 * Append a character and attribute to the line buffer.
 */
#define	STORE_CHAR(ch, a, rep, pos)				\
		if (store_char((ch), (a), (rep), (pos)))	\
			return (1)

static int
store_char(LWCHAR ch, char a, char *rep, off_t pos)
{
	int w;
	int replen;
	char cs;
	int matches;

	if (is_hilited(pos, pos+1, 0, &matches)) {
		/*
		 * This character should be highlighted.
		 * Override the attribute passed in.
		 */
		if (a != AT_ANSI) {
			if (highest_hilite != -1 && pos > highest_hilite)
				highest_hilite = pos;
			a |= AT_HILITE;
		}
	}

	if (ctldisp == OPT_ONPLUS && in_ansi_esc_seq()) {
		if (!is_ansi_end(ch) && !is_ansi_middle(ch)) {
			/* Remove whole unrecognized sequence.  */
			char *p = &linebuf[curr];
			LWCHAR bch;
			do {
				bch = step_char(&p, -1, linebuf);
			} while (p > linebuf && !IS_CSI_START(bch));
			curr = p - linebuf;
			return (0);
		}
		a = AT_ANSI;	/* Will force re-AT_'ing around it.  */
		w = 0;
	} else if (ctldisp == OPT_ONPLUS && IS_CSI_START(ch)) {
		a = AT_ANSI;	/* Will force re-AT_'ing around it.  */
		w = 0;
	} else {
		char *p = &linebuf[curr];
		LWCHAR prev_ch = step_char(&p, -1, linebuf);
		w = pwidth(ch, a, prev_ch);
	}

	if (ctldisp != OPT_ON && column + w + attr_ewidth(a) > sc_width)
		/*
		 * Won't fit on screen.
		 */
		return (1);

	if (rep == NULL) {
		cs = (char)ch;
		rep = &cs;
		replen = 1;
	} else {
		replen = utf_len(rep[0]);
	}
	if (curr + replen >= size_linebuf-6) {
		/*
		 * Won't fit in line buffer.
		 * Try to expand it.
		 */
		if (expand_linebuf())
			return (1);
	}

	while (replen-- > 0) {
		linebuf[curr] = *rep++;
		attr[curr] = a;
		curr++;
	}
	column += w;
	return (0);
}

/*
 * Append a tab to the line buffer.
 * Store spaces to represent the tab.
 */
#define	STORE_TAB(a, pos)		\
	if (store_tab((a), (pos)))	\
		return (1)

static int
store_tab(int attr, off_t pos)
{
	int to_tab = column + cshift - lmargin;
	int i;

	if (ntabstops < 2 || to_tab >= tabstops[ntabstops-1])
		to_tab = tabdefault -
		    ((to_tab - tabstops[ntabstops-1]) % tabdefault);
	else {
		for (i = ntabstops - 2; i >= 0; i--)
			if (to_tab >= tabstops[i])
				break;
		to_tab = tabstops[i+1] - to_tab;
	}

	if (column + to_tab - 1 + pwidth(' ', attr, 0) +
	    attr_ewidth(attr) > sc_width)
		return (1);

	do {
		STORE_CHAR(' ', attr, " ", pos);
	} while (--to_tab > 0);
	return (0);
}

#define	STORE_PRCHAR(c, pos)		\
	if (store_prchar((c), (pos)))	\
		return (1)

static int
store_prchar(char c, off_t pos)
{
	char *s;

	/*
	 * Convert to printable representation.
	 */
	s = prchar(c);

	/*
	 * Make sure we can get the entire representation
	 * of the character on this line.
	 */
	if (column + (int)strlen(s) - 1 +
	    pwidth(' ', binattr, 0) + attr_ewidth(binattr) > sc_width)
		return (1);

	for (; *s != 0; s++) {
		STORE_CHAR(*s, AT_BINARY, NULL, pos);
	}
	return (0);
}

static int
flush_mbc_buf(off_t pos)
{
	int i;

	for (i = 0; i < mbc_buf_index; i++)
		if (store_prchar(mbc_buf[i], pos))
			return (mbc_buf_index - i);

	return (0);
}

/*
 * Append a character to the line buffer.
 * Expand tabs into spaces, handle underlining, boldfacing, etc.
 * Returns 0 if ok, 1 if couldn't fit in buffer.
 */
int
pappend(char c, off_t pos)
{
	int r;

	if (pendc) {
		if (do_append(pendc, NULL, pendpos))
			/*
			 * Oops.  We've probably lost the char which
			 * was in pendc, since caller won't back up.
			 */
			return (1);
		pendc = '\0';
	}

	if (c == '\r' && bs_mode == BS_SPECIAL) {
		if (mbc_buf_len > 0)  /* utf_mode must be on. */ {
			/* Flush incomplete (truncated) sequence. */
			r = flush_mbc_buf(mbc_pos);
			mbc_buf_index = r + 1;
			mbc_buf_len = 0;
			if (r)
				return (mbc_buf_index);
		}

		/*
		 * Don't put the CR into the buffer until we see
		 * the next char.  If the next char is a newline,
		 * discard the CR.
		 */
		pendc = c;
		pendpos = pos;
		return (0);
	}

	if (!utf_mode) {
		r = do_append((LWCHAR) c, NULL, pos);
	} else {
		/* Perform strict validation in all possible cases. */
		if (mbc_buf_len == 0) {
retry:
			mbc_buf_index = 1;
			*mbc_buf = c;
			if (IS_ASCII_OCTET(c)) {
				r = do_append((LWCHAR) c, NULL, pos);
			} else if (IS_UTF8_LEAD(c)) {
				mbc_buf_len = utf_len(c);
				mbc_pos = pos;
				return (0);
			} else {
				/* UTF8_INVALID or stray UTF8_TRAIL */
				r = flush_mbc_buf(pos);
			}
		} else if (IS_UTF8_TRAIL(c)) {
			mbc_buf[mbc_buf_index++] = c;
			if (mbc_buf_index < mbc_buf_len)
				return (0);
			if (is_utf8_well_formed(mbc_buf))
				r = do_append(get_wchar(mbc_buf), mbc_buf,
				    mbc_pos);
			else
				/* Complete, but not shortest form, sequence. */
				mbc_buf_index = r = flush_mbc_buf(mbc_pos);
			mbc_buf_len = 0;
		} else {
			/* Flush incomplete (truncated) sequence.  */
			r = flush_mbc_buf(mbc_pos);
			mbc_buf_index = r + 1;
			mbc_buf_len = 0;
			/* Handle new char.  */
			if (!r)
				goto retry;
		}
	}

	/*
	 * If we need to shift the line, do it.
	 * But wait until we get to at least the middle of the screen,
	 * so shifting it doesn't affect the chars we're currently
	 * pappending.  (Bold & underline can get messed up otherwise.)
	 */
	if (cshift < hshift && column > sc_width / 2) {
		linebuf[curr] = '\0';
		pshift(hshift - cshift);
	}
	if (r) {
		/* How many chars should caller back up? */
		r = (!utf_mode) ? 1 : mbc_buf_index;
	}
	return (r);
}

static int
do_append(LWCHAR ch, char *rep, off_t pos)
{
	int a;
	LWCHAR prev_ch;

	a = AT_NORMAL;

	if (ch == '\b') {
		if (bs_mode == BS_CONTROL)
			goto do_control_char;

		/*
		 * A better test is needed here so we don't
		 * backspace over part of the printed
		 * representation of a binary character.
		 */
		if (curr <= lmargin ||
		    column <= lmargin ||
		    (attr[curr - 1] & (AT_ANSI|AT_BINARY))) {
			STORE_PRCHAR('\b', pos);
		} else if (bs_mode == BS_NORMAL) {
			STORE_CHAR(ch, AT_NORMAL, NULL, pos);
		} else if (bs_mode == BS_SPECIAL) {
			overstrike = backc();
		}

		return (0);
	}

	if (overstrike > 0) {
		/*
		 * Overstrike the character at the current position
		 * in the line buffer.  This will cause either
		 * underline (if a "_" is overstruck),
		 * bold (if an identical character is overstruck),
		 * or just deletion of the character in the buffer.
		 */
		overstrike = utf_mode ? -1 : 0;
		/* To be correct, this must be a base character.  */
		prev_ch = get_wchar(linebuf + curr);
		a = attr[curr];
		if (ch == prev_ch) {
			/*
			 * Overstriking a char with itself means make it bold.
			 * But overstriking an underscore with itself is
			 * ambiguous.  It could mean make it bold, or
			 * it could mean make it underlined.
			 * Use the previous overstrike to resolve it.
			 */
			if (ch == '_') {
				if ((a & (AT_BOLD|AT_UNDERLINE)) != AT_NORMAL)
					a |= (AT_BOLD|AT_UNDERLINE);
				else if (curr > 0 && attr[curr - 1] & AT_UNDERLINE)
					a |= AT_UNDERLINE;
				else if (curr > 0 && attr[curr - 1] & AT_BOLD)
					a |= AT_BOLD;
				else
					a |= AT_INDET;
			} else {
				a |= AT_BOLD;
			}
		} else if (ch == '_') {
			a |= AT_UNDERLINE;
			ch = prev_ch;
			rep = linebuf + curr;
		} else if (prev_ch == '_') {
			a |= AT_UNDERLINE;
		}
		/* Else we replace prev_ch, but we keep its attributes.  */
	} else if (overstrike < 0) {
		if (is_composing_char(ch) ||
		    is_combining_char(get_wchar(linebuf + curr), ch)) {
			/* Continuation of the same overstrike.  */
			if (curr > 0)
				a = attr[curr - 1] & (AT_UNDERLINE | AT_BOLD);
			else
				a = AT_NORMAL;
		} else
			overstrike = 0;
	}

	if (ch == '\t') {
		/*
		 * Expand a tab into spaces.
		 */
		switch (bs_mode) {
		case BS_CONTROL:
			goto do_control_char;
		case BS_NORMAL:
		case BS_SPECIAL:
			STORE_TAB(a, pos);
			break;
		}
	} else if ((!utf_mode || is_ascii_char(ch)) && control_char((char)ch)) {
do_control_char:
		if (ctldisp == OPT_ON ||
		    (ctldisp == OPT_ONPLUS && IS_CSI_START(ch))) {
			/*
			 * Output as a normal character.
			 */
			STORE_CHAR(ch, AT_NORMAL, rep, pos);
		} else {
			STORE_PRCHAR((char)ch, pos);
		}
	} else if (utf_mode && ctldisp != OPT_ON && is_ubin_char(ch)) {
		char *s;

		s = prutfchar(ch);

		if (column + (int)strlen(s) - 1 +
		    pwidth(' ', binattr, 0) + attr_ewidth(binattr) > sc_width)
			return (1);

		for (; *s != 0; s++)
			STORE_CHAR(*s, AT_BINARY, NULL, pos);
	} else {
		STORE_CHAR(ch, a, rep, pos);
	}
	return (0);
}

/*
 *
 */
int
pflushmbc(void)
{
	int r = 0;

	if (mbc_buf_len > 0) {
		/* Flush incomplete (truncated) sequence.  */
		r = flush_mbc_buf(mbc_pos);
		mbc_buf_len = 0;
	}
	return (r);
}

/*
 * Terminate the line in the line buffer.
 */
void
pdone(int endline, int forw)
{
	int i;

	(void) pflushmbc();

	if (pendc && (pendc != '\r' || !endline))
		/*
		 * If we had a pending character, put it in the buffer.
		 * But discard a pending CR if we are at end of line
		 * (that is, discard the CR in a CR/LF sequence).
		 */
		(void) do_append(pendc, NULL, pendpos);

	for (i = curr - 1; i >= 0; i--) {
		if (attr[i] & AT_INDET) {
			attr[i] &= ~AT_INDET;
			if (i < curr - 1 && attr[i + 1] & AT_BOLD)
				attr[i] |= AT_BOLD;
			else
				attr[i] |= AT_UNDERLINE;
		}
	}

	/*
	 * Make sure we've shifted the line, if we need to.
	 */
	if (cshift < hshift)
		pshift(hshift - cshift);

	if (ctldisp == OPT_ONPLUS && is_ansi_end('m')) {
		/* Switch to normal attribute at end of line. */
		char *p = "\033[m";
		for (; *p != '\0'; p++) {
			linebuf[curr] = *p;
			attr[curr++] = AT_ANSI;
		}
	}

	/*
	 * Add a newline if necessary,
	 * and append a '\0' to the end of the line.
	 * We output a newline if we're not at the right edge of the screen,
	 * or if the terminal doesn't auto wrap,
	 * or if this is really the end of the line AND the terminal ignores
	 * a newline at the right edge.
	 * (In the last case we don't want to output a newline if the terminal
	 * doesn't ignore it since that would produce an extra blank line.
	 * But we do want to output a newline if the terminal ignores it in case
	 * the next line is blank.  In that case the single newline output for
	 * that blank line would be ignored!)
	 */
	if (column < sc_width || !auto_wrap || (endline && ignaw) ||
	    ctldisp == OPT_ON) {
		linebuf[curr] = '\n';
		attr[curr] = AT_NORMAL;
		curr++;
	} else if (ignaw && column >= sc_width && forw) {
		/*
		 * Terminals with "ignaw" don't wrap until they *really* need
		 * to, i.e. when the character *after* the last one to fit on a
		 * line is output. But they are too hard to deal with when they
		 * get in the state where a full screen width of characters
		 * have been output but the cursor is sitting on the right edge
		 * instead of at the start of the next line.
		 * So we nudge them into wrapping by outputting a space
		 * character plus a backspace.  But do this only if moving
		 * forward; if we're moving backward and drawing this line at
		 * the top of the screen, the space would overwrite the first
		 * char on the next line.  We don't need to do this "nudge"
		 * at the top of the screen anyway.
		 */
		linebuf[curr] = ' ';
		attr[curr++] = AT_NORMAL;
		linebuf[curr] = '\b';
		attr[curr++] = AT_NORMAL;
	}
	linebuf[curr] = '\0';
	attr[curr] = AT_NORMAL;
}

/*
 *
 */
void
set_status_col(char c)
{
	linebuf[0] = c;
	attr[0] = AT_NORMAL|AT_HILITE;
}

/*
 * Get a character from the current line.
 * Return the character as the function return value,
 * and the character attribute in *ap.
 */
int
gline(int i, int *ap)
{
	if (is_null_line) {
		/*
		 * If there is no current line, we pretend the line is
		 * either "~" or "", depending on the "twiddle" flag.
		 */
		if (twiddle) {
			if (i == 0) {
				*ap = AT_BOLD;
				return ('~');
			}
			--i;
		}
		/* Make sure we're back to AT_NORMAL before the '\n'.  */
		*ap = AT_NORMAL;
		return (i ? '\0' : '\n');
	}

	*ap = attr[i];
	return (linebuf[i] & 0xFF);
}

/*
 * Indicate that there is no current line.
 */
void
null_line(void)
{
	is_null_line = 1;
	cshift = 0;
}

/*
 * Analogous to forw_line(), but deals with "raw lines":
 * lines which are not split for screen width.
 * {{ This is supposed to be more efficient than forw_line(). }}
 */
off_t
forw_raw_line(off_t curr_pos, char **linep, int *line_lenp)
{
	int n;
	int c;
	off_t new_pos;

	if (curr_pos == -1 || ch_seek(curr_pos) ||
	    (c = ch_forw_get()) == EOI)
		return (-1);

	n = 0;
	for (;;) {
		if (c == '\n' || c == EOI || ABORT_SIGS()) {
			new_pos = ch_tell();
			break;
		}
		if (n >= size_linebuf-1) {
			if (expand_linebuf()) {
				/*
				 * Overflowed the input buffer.
				 * Pretend the line ended here.
				 */
				new_pos = ch_tell() - 1;
				break;
			}
		}
		linebuf[n++] = (char)c;
		c = ch_forw_get();
	}
	linebuf[n] = '\0';
	if (linep != NULL)
		*linep = linebuf;
	if (line_lenp != NULL)
		*line_lenp = n;
	return (new_pos);
}

/*
 * Analogous to back_line(), but deals with "raw lines".
 * {{ This is supposed to be more efficient than back_line(). }}
 */
off_t
back_raw_line(off_t curr_pos, char **linep, int *line_lenp)
{
	int n;
	int c;
	off_t new_pos;

	if (curr_pos == -1 || curr_pos <= ch_zero() || ch_seek(curr_pos - 1))
		return (-1);

	n = size_linebuf;
	linebuf[--n] = '\0';
	for (;;) {
		c = ch_back_get();
		if (c == '\n' || ABORT_SIGS()) {
			/*
			 * This is the newline ending the previous line.
			 * We have hit the beginning of the line.
			 */
			new_pos = ch_tell() + 1;
			break;
		}
		if (c == EOI) {
			/*
			 * We have hit the beginning of the file.
			 * This must be the first line in the file.
			 * This must, of course, be the beginning of the line.
			 */
			new_pos = ch_zero();
			break;
		}
		if (n <= 0) {
			int old_size_linebuf = size_linebuf;
			if (expand_linebuf()) {
				/*
				 * Overflowed the input buffer.
				 * Pretend the line ended here.
				 */
				new_pos = ch_tell() + 1;
				break;
			}
			/*
			 * Shift the data to the end of the new linebuf.
			 */
			n = size_linebuf - old_size_linebuf;
			memmove(linebuf + n, linebuf, old_size_linebuf);
		}
		linebuf[--n] = c;
	}
	if (linep != NULL)
		*linep = &linebuf[n];
	if (line_lenp != NULL)
		*line_lenp = size_linebuf - 1 - n;
	return (new_pos);
}
@


1.20
log
@Improve handling of ambiguous overstrike sequences. A sequence of _\b_
can either mean an underlined underscore or a bold underscore. This
ambiguity can be 'resolved' by takeing the state of the surrounding text
into account. If surrounded by bold text, the result should probably be
bold and likewise for underlined. less(1) previously only looked at the
preceding text and ul(1) didn't examine the context at all.

tweaks and ok schwarze
ok tb (on a previous version of the diff)
@
text
@d184 1
a184 1
		n++;  /* One space after the line number. */
d467 1
a467 1
	for (p = &linebuf[curr];  p > linebuf; ) {
d599 1
a599 1
		for (i = ntabstops - 2;  i >= 0;  i--)
@


1.19
log
@style(9) includes

ok nicm@@
@
text
@a34 1
static int last_overstrike = AT_NORMAL;
a128 1
	last_overstrike = AT_NORMAL;
a515 4
	w = (a & (AT_UNDERLINE|AT_BOLD));	/* Pre-use w.  */
	if (w != AT_NORMAL)
		last_overstrike = w;

d805 4
a808 2
				else if (last_overstrike != AT_NORMAL)
					a |= last_overstrike;
d810 1
a810 1
					a |= AT_BOLD;
d824 1
a824 1
		    is_combining_char(get_wchar(linebuf + curr), ch))
d826 5
a830 2
			a = last_overstrike;
		else
d896 2
d907 10
@


1.18
log
@Remove a fancy macro that calculates the necessary buffer size for
int-to-str conversions and just use constants instead. The only binary
change is caused by using an unnecessarily large buffer for an int. This
is a consequence of simplifying some code that will be gone soon.

ok nicm@@
@
text
@d18 1
a19 1
#include "charset.h"
@


1.17
log
@unify two identical function pairs now that we've removed less's off_t
aliases

ok nicm@@
@
text
@d178 1
a178 1
		char buf[INT_STRLEN_BOUND(pos) + 2];
@


1.16
log
@Remove LINUNUM, a needless alias for off_t. Also, remove a redundant
condition.

ok nicm@@
@
text
@d181 1
a181 1
		linenumtoa(linenum, buf, sizeof (buf));
@


1.15
log
@Remove NULL-checks before free(), a needless comment, and a needless
void* cast.

ok nicm@@
@
text
@d145 1
a145 1
	LINENUM linenum = 0;
@


1.14
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d101 2
a102 4
		if (new_attr != NULL)
			free(new_attr);
		if (new_buf != NULL)
			free(new_buf);
@


1.13
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.12
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

a22 2
#include <err.h>

d25 1
a25 1
public int size_linebuf = 0;	/* Size of line buffer (and attr buffer) */
d28 5
a32 5
public int hshift;		/* Desired left-shift of output line buffer */
public int tabstops[TABSTOP_MAX] = { 0 }; /* Custom tabstops */
public int ntabstops = 1;	/* Number of tabstops */
public int tabdefault = 8;	/* Default repeated tabstops */
public POSITION highest_hilite;	/* Pos of last hilite in file found so far */
d35 1
a35 2
static int column;		/* Printable length, accounting for
				   backspaces, etc. */
d41 1
a41 1
static POSITION pendpos;
d45 3
a47 3
static int attr_swidth();
static int attr_ewidth();
static int do_append();
d63 2
a64 2
extern POSITION start_attnpos;
extern POSITION end_attnpos;
d69 1
a69 1
static POSITION mbc_pos;
d74 2
a75 2
	public void
init_line()
d85 2
a86 2
	linebuf = (char *) ecalloc(LINEBUF_SIZE, sizeof(char));
	attr = (char *) ecalloc(LINEBUF_SIZE, sizeof(char));
d93 2
a94 2
	static int
expand_linebuf()
d100 8
a107 13
	char *new_buf;
	char *new_attr;

	new_buf = realloc(linebuf, new_size);
	if (new_buf == NULL)
		return 1;
	new_attr = realloc(attr, new_size);
	if (new_attr == NULL) {
		/* realloc linebuf back to original size */
		linebuf = realloc(new_buf, size_linebuf);
		if (linebuf == NULL)
			err(1, NULL);
		return 1;
a108 5
	/*
	 * We realloc'd the buffers; they already have the old contents.
	 */
	memset(new_buf + size_linebuf, 0, new_size - size_linebuf);
	memset(new_attr + size_linebuf, 0, new_size - size_linebuf);
d112 1
a112 1
	return 0;
d118 2
a119 3
	public int
is_ascii_char(ch)
	LWCHAR ch;
d127 2
a128 2
	public void
prewind()
d146 2
a147 3
	public void
plinenum(pos)
	POSITION pos;
d149 2
a150 2
	register LINENUM linenum = 0;
	register int i;
d152 1
a152 2
	if (linenums == OPT_ONPLUS)
	{
d156 1
a156 1
		 *    it may seek in the input file, requiring the caller 
d167 1
a167 2
	if (status_col)
	{
d169 1
a169 1
		if (start_attnpos != NULL_POSITION &&
d181 1
a181 2
	if (linenums == OPT_ONPLUS)
	{
d185 1
a185 1
		linenumtoa(linenum, buf, sizeof(buf));
d201 1
a201 2
	while (column < lmargin)
	{
d212 2
a213 3
	static void
pshift(shift)
	int shift;
d235 1
a235 2
	while (shifted <= shift && from < curr)
	{
d237 1
a237 2
		if (ctldisp == OPT_ONPLUS && IS_CSI_START(c))
		{
d241 1
a241 2
			while (from < curr && linebuf[from])
			{
d246 1
a246 1
			} 
d252 1
a252 3
#if !SMALL
		if (!IS_ASCII_OCTET(c) && utf_mode)
		{
d260 2
a261 1
			if (!is_composing_char(ch) && !is_combining_char(prev_ch, ch))
d264 1
a264 3
		} else
#endif /* !SMALL */
		{
d268 2
a269 5
#if !SMALL
				width = (utf_mode && is_wide_char(prev_ch)) ? -2 : -1;
#else
				width = -1;
#endif /* !SMALL */
d292 2
a293 3
		if (!is_at_equiv(attr[from], prev_attr) && 
			!is_at_equiv(attr[from], next_attr))
		{
d297 1
a297 2
			if (is_at_equiv(prev_attr, next_attr))
			{
d311 1
a311 2
	while (from < curr)
	{
d323 2
a324 2
	public void
pshift_all()
d333 2
a334 3
	static int
attr_swidth(a)
	int a;
d349 1
a349 1
	return w;
d356 2
a357 3
	static int
attr_ewidth(a)
	int a;
d372 1
a372 1
	return w;
d381 2
a382 5
	static int
pwidth(ch, a, prev_ch)
	LWCHAR ch;
	int a;
	LWCHAR prev_ch;
d391 4
a394 10
#if !SMALL
		return (utf_mode && is_wide_char(prev_ch)) ? -2 : -1;
#else
		return -1;
#endif /* !SMALL */

	if (!utf_mode || is_ascii_char(ch))
	{
		if (control_char((char)ch))
		{
d402 2
a403 6
	}
#if !SMALL
	else
	{
		if (is_composing_char(ch) || is_combining_char(prev_ch, ch))
		{
a417 1
#endif /* !SMALL */
a423 1
#if !SMALL
a425 1
#endif /* !SMALL */
d438 2
a439 2
	static int
backc()
d447 2
a448 4
	while (   curr > lmargin
	       && column > lmargin
	       && (!(attr[curr - 1] & (AT_ANSI|AT_BINARY))))
	{
d454 1
a454 1
			return 1;
d458 1
a458 1
	return 0;
d464 2
a465 2
	static int
in_ansi_esc_seq()
d473 1
a473 2
	for (p = &linebuf[curr];  p > linebuf; )
	{
d486 2
a487 3
	public int
is_ansi_end(ch)
	LWCHAR ch;
d491 1
a491 1
	return (strchr(end_ansi_chars, (char) ch) != NULL);
d497 2
a498 3
	public int
is_ansi_middle(ch)
	LWCHAR ch;
d504 1
a504 1
	return (strchr(mid_ansi_chars, (char) ch) != NULL);
d510 6
a515 11
#define	STORE_CHAR(ch,a,rep,pos) \
	do { \
		if (store_char((ch),(a),(rep),(pos))) return (1); \
	} while (0)

	static int
store_char(ch, a, rep, pos)
	LWCHAR ch;
	int a;
	char *rep;
	POSITION pos;
d520 1
d526 9
a534 16
#if HILITE_SEARCH
	{
		int matches;
		if (is_hilited(pos, pos+1, 0, &matches))
		{
			/*
			 * This character should be highlighted.
			 * Override the attribute passed in.
			 */
			if (a != AT_ANSI)
			{
				if (highest_hilite != NULL_POSITION &&
				    pos > highest_hilite)
				    	highest_hilite = pos;
				a |= AT_HILITE;
			}
a536 1
#endif
d538 1
a538 2
	if (ctldisp == OPT_ONPLUS && in_ansi_esc_seq())
	{
d547 1
a547 1
			return 0;
d551 1
a551 3
	}
	else if (ctldisp == OPT_ONPLUS && IS_CSI_START(ch))
	{
d554 1
a554 3
	}
	else
	{
d566 2
a567 3
	if (rep == NULL)
	{
		cs = (char) ch;
d570 1
a570 3
	} else
	{
#if !SMALL
a571 3
#else
		replen = 1;
#endif /* !SMALL */
d573 1
a573 2
	if (curr + replen >= size_linebuf-6)
	{
d582 1
a582 2
	while (replen-- > 0)
	{
d595 3
a597 2
#define	STORE_TAB(a,pos) \
	do { if (store_tab((a),(pos))) return (1); } while (0)
d599 2
a600 4
	static int
store_tab(attr, pos)
	int attr;
	POSITION pos;
d607 2
a608 3
		     ((to_tab - tabstops[ntabstops-1]) % tabdefault);
	else
	{
d615 3
a617 2
	if (column + to_tab - 1 + pwidth(' ', attr, 0) + attr_ewidth(attr) > sc_width)
		return 1;
d622 1
a622 1
	return 0;
d625 3
a627 2
#define STORE_PRCHAR(c, pos) \
	do { if (store_prchar((c), (pos))) return 1; } while (0)
d629 2
a630 4
	static int
store_prchar(c, pos)
	char c;
	POSITION pos;
d643 3
a645 3
	if (column + (int) strlen(s) - 1 +
            pwidth(' ', binattr, 0) + attr_ewidth(binattr) > sc_width)
		return 1;
d647 1
a647 1
	for ( ;  *s != 0;  s++)
d649 2
a650 2

	return 0;
d653 2
a654 4
#if !SMALL
	static int
flush_mbc_buf(pos)
	POSITION pos;
d660 1
a660 1
			return mbc_buf_index - i;
d662 1
a662 1
	return 0;
a663 1
#endif /* !SMALL */
d670 2
a671 4
	public int
pappend(c, pos)
	char c;
	POSITION pos;
d675 1
a675 2
	if (pendc)
	{
d685 2
a686 5
	if (c == '\r' && bs_mode == BS_SPECIAL)
	{
#if !SMALL
		if (mbc_buf_len > 0)  /* utf_mode must be on. */
		{
a693 1
#endif /* !SMALL */
d696 1
a696 1
		 * Don't put the CR into the buffer until we see 
d705 1
a705 2
	if (!utf_mode)
	{
d707 1
a707 4
	}
#if !SMALL
	else
	{
d709 2
a710 3
		if (mbc_buf_len == 0)
		{
		retry:
d713 1
a713 1
			if (IS_ASCII_OCTET(c))
d715 1
a715 2
			else if (IS_UTF8_LEAD(c))
			{
d719 1
a719 1
			} else
d722 2
a723 2
		} else if (IS_UTF8_TRAIL(c))
		{
d728 2
a729 1
				r = do_append(get_wchar(mbc_buf), mbc_buf, mbc_pos);
d734 1
a734 2
		} else
		{
d742 1
a742 1
 		}
a743 1
#endif /* !SMALL */
d751 1
a751 2
	if (cshift < hshift && column > sc_width / 2)
	{
d755 1
a755 2
	if (r)
	{
d762 2
a763 5
	static int
do_append(ch, rep, pos)
	LWCHAR ch;
	char *rep;
	POSITION pos;
d765 1
a765 1
	register int a;
d770 1
a770 2
	if (ch == '\b')
	{
d779 3
a781 3
		if (   curr <= lmargin
		    || column <= lmargin
		    || (attr[curr - 1] & (AT_ANSI|AT_BINARY)))
d783 1
a783 1
		else if (bs_mode == BS_NORMAL)
d785 1
a785 1
		else if (bs_mode == BS_SPECIAL)
d787 1
d789 1
a789 1
		return 0;
d792 1
a792 2
	if (overstrike > 0)
	{
d795 2
a796 2
		 * in the line buffer.  This will cause either 
		 * underline (if a "_" is overstruck), 
a801 1
#if !SMALL
a802 3
#else
		prev_ch = (LWCHAR)((char)(linebuf + curr)[0] & 0xFF);
#endif /* !SMALL */
d804 1
a804 2
		if (ch == prev_ch)
		{
d812 1
a812 2
			if (ch == '_')
			{
d819 1
a819 1
			} else
d821 2
a822 2
		} else if (ch == '_')
		{
d826 1
a826 2
		} else if (prev_ch == '_')
		{
d830 3
a832 5
	} else if (overstrike < 0)
	{
#if !SMALL
		if (   is_composing_char(ch)
		    || is_combining_char(get_wchar(linebuf + curr), ch))
a835 1
#endif /* !SMALL */
d839 1
a839 2
	if (ch == '\t') 
	{
d843 1
a843 2
		switch (bs_mode)
		{
d851 4
a854 5
	} else if ((!utf_mode || is_ascii_char(ch)) && control_char((char)ch))
	{
	do_control_char:
		if (ctldisp == OPT_ON || (ctldisp == OPT_ONPLUS && IS_CSI_START(ch)))
		{
d859 2
a860 3
		} else 
		{
			STORE_PRCHAR((char) ch, pos);
d862 1
a862 4
	}
#if !SMALL
	else if (utf_mode && ctldisp != OPT_ON && is_ubin_char(ch))
	{
d867 1
a867 1
		if (column + (int) strlen(s) - 1 +
d871 1
a871 1
		for ( ;  *s != 0;  s++)
d873 1
a873 4
 	}
#endif /* !SMALL */
	else
	{
d876 1
a876 1
 	return (0);
d882 2
a883 2
	public int
pflushmbc()
d887 1
a887 3
#if !SMALL
	if (mbc_buf_len > 0)
	{
d892 1
a892 2
#endif /* !SMALL */
	return r;
d898 2
a899 4
	public void
pdone(endline, forw)
	int endline;
	int forw;
d917 1
a917 2
	if (ctldisp == OPT_ONPLUS && is_ansi_end('m'))
	{
d920 1
a920 2
		for ( ;  *p != '\0';  p++)
		{
d933 1
a933 1
	 * (In the last case we don't want to output a newline if the terminal 
d939 2
a940 2
	if (column < sc_width || !auto_wrap || (endline && ignaw) || ctldisp == OPT_ON)
	{
d944 1
a944 3
	} 
	else if (ignaw && column >= sc_width && forw)
	{
d952 2
a953 2
		 * So we nudge them into wrapping by outputting a space 
		 * character plus a backspace.  But do this only if moving 
d956 1
a956 1
		 * char on the next line.  We don't need to do this "nudge" 
d961 1
a961 1
		linebuf[curr] = '\b'; 
d971 2
a972 3
	public void
set_status_col(c)
	char c;
d983 2
a984 4
	public int
gline(i, ap)
	register int i;
	register int *ap;
d986 1
a986 2
	if (is_null_line)
	{
d991 2
a992 4
		if (twiddle)
		{
			if (i == 0)
			{
d994 1
a994 1
				return '~';
d1000 1
a1000 1
		return i ? '\0' : '\n';
d1010 2
a1011 2
	public void
null_line()
d1022 10
a1031 13
	public POSITION
forw_raw_line(curr_pos, linep, line_lenp)
	POSITION curr_pos;
	char **linep;
	int *line_lenp;
{
	register int n;
	register int c;
	POSITION new_pos;

	if (curr_pos == NULL_POSITION || ch_seek(curr_pos) ||
		(c = ch_forw_get()) == EOI)
		return (NULL_POSITION);
d1034 2
a1035 4
	for (;;)
	{
		if (c == '\n' || c == EOI || ABORT_SIGS())
		{
d1039 2
a1040 4
		if (n >= size_linebuf-1)
		{
			if (expand_linebuf())
			{
d1049 1
a1049 1
		linebuf[n++] = c;
d1064 9
a1072 13
	public POSITION
back_raw_line(curr_pos, linep, line_lenp)
	POSITION curr_pos;
	char **linep;
	int *line_lenp;
{
	register int n;
	register int c;
	POSITION new_pos;

	if (curr_pos == NULL_POSITION || curr_pos <= ch_zero() ||
		ch_seek(curr_pos-1))
		return (NULL_POSITION);
d1076 1
a1076 2
	for (;;)
	{
d1078 1
a1078 2
		if (c == '\n' || ABORT_SIGS())
		{
d1086 1
a1086 2
		if (c == EOI)
		{
d1095 1
a1095 2
		if (n <= 0)
		{
d1097 1
a1097 2
			if (expand_linebuf())
			{
@


1.11
log
@Use volatile sig_atomic_t, not int, for the sigs variable.  Also
move the call to bell() out of u_interrupt() (a signal handler).
OK and with help from deraadt@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d31 1
d592 4
d597 1
d646 1
a646 1
#endif
@


1.10
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d49 1
a49 1
extern int sigs;
@


1.9
log
@Fix recovery of realloc failure, which causes a segv on files with
very lone lines, as reported by Steffen Wendzel.  ok deraadt@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d19 1
d21 1
a21 1
#define IS_CONT(c)  (((c) & 0xC0) == 0x80)
d23 1
a23 1
public char *linebuf = NULL;	/* Buffer which holds the current output line */
d27 1
a27 1
public int cshift;		/* Current left-shift of output line buffer */
a39 1
static int hilites;		/* Number of hilites in this line */
d43 1
d45 2
d49 1
d66 5
d80 5
d93 1
a93 1
 	static int
d96 1
d98 2
d114 3
d126 10
d143 1
d145 2
a151 3
#if HILITE_SEARCH
	hilites = 0;
#endif
d185 1
a185 1
			attr[curr] = AT_STANDOUT;
d187 1
a187 1
			attr[curr] = 0;
d225 2
a226 1
 * Determine how many characters are required to shift N columns.
d228 9
a236 3
	static int
shift_chars(s, len)
	char *s;
d238 8
a245 2
{
	char *p = s;
d247 1
d249 2
a250 2
	 * Each char counts for one column, except ANSI color escape
	 * sequences use no columns since they don't move the cursor.
d252 1
a252 1
	while (*p != '\0' && len > 0)
d254 20
a273 1
		if (*p++ != ESC)
d275 10
a284 1
			len--;
d286 34
d321 4
a324 1
			while (*p != '\0')
d326 3
a328 2
				if (is_ansi_end(*p++))
					break;
a330 3
	}
	return (p - s);
}
d332 15
a346 24
/*
 * Determine how many characters are required to shift N columns (UTF version).
 * {{ FIXME: what about color escape sequences in UTF mode? }}
 */
	static int
utf_shift_chars(s, len)
	char *s;
	int len;
{
	int ulen = 0;

	while (*s != '\0' && len > 0)
	{
		if (!IS_CONT(*s))
			len--;
		s++;
		ulen++;
	}
	while (IS_CONT(*s))
	{
		s++;
		ulen++;
	}
	return (ulen);
d350 1
a350 2
 * Shift the input line left.
 * This means discarding N printable chars at the start of the buffer.
d352 2
a353 3
	static void
pshift(shift)
	int shift;
d355 1
a355 22
	int i;
	int nchars;

	if (shift > column - lmargin)
		shift = column - lmargin;
	if (shift > curr - lmargin)
		shift = curr - lmargin;

	if (utf_mode)
		nchars = utf_shift_chars(linebuf + lmargin, shift);
	else
		nchars = shift_chars(linebuf + lmargin, shift);
	if (nchars > curr)
		nchars = curr;
	for (i = 0;  i < curr - nchars;  i++)
	{
		linebuf[lmargin + i] = linebuf[lmargin + i + nchars];
		attr[lmargin + i] = attr[lmargin + i + nchars];
	}
	curr -= nchars;
	column -= shift;
	cshift += shift;
d366 14
a379 8
	switch (a)
	{
	case AT_BOLD:		return (bo_s_width);
	case AT_UNDERLINE:	return (ul_s_width);
	case AT_BLINK:		return (bl_s_width);
	case AT_STANDOUT:	return (so_s_width);
	}
	return (0);
d390 14
a403 8
	switch (a)
	{
	case AT_BOLD:		return (bo_e_width);
	case AT_UNDERLINE:	return (ul_e_width);
	case AT_BLINK:		return (bl_e_width);
	case AT_STANDOUT:	return (so_e_width);
	}
	return (0);
d413 2
a414 2
pwidth(c, a)
	int c;
d416 1
d418 1
a418 4
	register int w;

	if (utf_mode && IS_CONT(c))
		return (0);
d420 1
a420 1
	if (c == '\b')
d422 2
a423 1
		 * Backspace moves backwards one position.
d425 5
a429 1
		return (-1);
d431 32
a462 7
	if (control_char(c))
		/*
		 * Control characters do unpredicatable things,
		 * so we don't even try to guess; say it doesn't move.
		 * This can only happen if the -r flag is in effect.
		 */
		return (0);
d465 1
a465 1
	 * Other characters take one space,
d469 5
a473 1
	if (curr > 0 && attr[curr-1] != a)
d475 2
a476 1
	if (a && (curr == 0 || attr[curr-1] != a))
d482 2
a483 1
 * Delete the previous character in the line buffer.
d485 1
a485 1
	static void
d488 20
a507 2
	curr--;
	column -= pwidth(linebuf[curr], attr[curr]);
d516 1
a516 1
	int i;
d522 1
a522 1
	for (i = curr-1;  i >= 0;  i--)
d524 2
a525 1
		if (linebuf[i] == ESC)
d527 1
a527 1
		if (is_ansi_end(linebuf[i]))
d537 14
a550 2
is_ansi_end(c)
	char c;
d552 5
a556 1
	return (strchr(end_ansi_chars, c) != NULL);
d562 4
a565 2
#define	STORE_CHAR(c,a,pos) \
	do { if (store_char((c),(a),(pos))) return (1); else curr++; } while (0)
d568 2
a569 2
store_char(c, a, pos)
	int c;
d571 1
d574 7
a580 1
	register int w;
a581 2
	if (a != AT_NORMAL)
		last_overstrike = a;
a582 1
	if (is_hilited(pos, pos+1, 0))
d584 10
a593 6
		/*
		 * This character should be highlighted.
		 * Override the attribute passed in.
		 */
		a = AT_STANDOUT;
		hilites++;
d596 1
d598 12
d611 6
d618 6
a623 1
		w = pwidth(c, a);
d630 14
a643 1
	if (curr >= size_linebuf-2)
d653 1
a653 13
	/*
	 * Special handling for "magic cookie" terminals.
	 * If an attribute enter/exit sequence has a printing width > 0,
	 * and the sequence is adjacent to a space, delete the space.
	 * We just mark the space as invisible, to avoid having too
	 * many spaces deleted.
	 * {{ Note that even if the attribute width is > 1, we
	 *    delete only one space.  It's not worth trying to do more.
	 *    It's hardly worth doing this much. }}
	 */
	if (curr > 0 && a != AT_NORMAL && 
		linebuf[curr-1] == ' ' && attr[curr-1] == AT_NORMAL &&
		attr_swidth(a) > 0)
d655 3
a657 16
		/*
		 * We are about to append an enter-attribute sequence
		 * just after a space.  Delete the space.
		 */
		attr[curr-1] = AT_INVIS;
		column--;
	} else if (curr > 0 && attr[curr-1] != AT_NORMAL && 
		attr[curr-1] != AT_INVIS && c == ' ' && a == AT_NORMAL &&
		attr_ewidth(attr[curr-1]) > 0)
	{
		/*
		 * We are about to append a space just after an 
		 * exit-attribute sequence.  Delete the space.
		 */
		a = AT_INVIS;
		column--;
a658 4
	/* End of magic cookie handling. */

	linebuf[curr] = c;
	attr[curr] = a;
d689 3
d693 1
a693 1
		STORE_CHAR(' ', attr, pos);
d698 44
d749 1
a749 1
	register int c;
d756 1
a756 1
		if (do_append(pendc, pendpos))
d767 12
d789 47
a835 1
	r = do_append(c, pos);
d847 5
a854 5
#define IS_UTF8_4BYTE(c) ( ((c) & 0xf8) == 0xf0 )
#define IS_UTF8_3BYTE(c) ( ((c) & 0xf0) == 0xe0 )
#define IS_UTF8_2BYTE(c) ( ((c) & 0xe0) == 0xc0 )
#define IS_UTF8_TRAIL(c) ( ((c) & 0xc0) == 0x80 )

d856 3
a858 2
do_append(c, pos)
	int c;
a860 1
	register char *s;
d862 1
d864 1
a864 2
#define STOREC(c,a) \
	if ((c) == '\t') STORE_TAB((a),pos); else STORE_CHAR((c),(a),pos)
d866 1
a866 1
	if (c == '\b')
d868 1
a868 6
		switch (bs_mode)
		{
		case BS_NORMAL:
			STORE_CHAR(c, AT_NORMAL, pos);
			break;
		case BS_CONTROL:
d870 19
a888 8
		case BS_SPECIAL:
			if (curr == 0)
				break;
			backc();
			overstrike = 1;
			break;
		}
	} else if (overstrike)
d897 9
a905 23
		overstrike--;
		if (utf_mode && IS_UTF8_4BYTE(c) && curr > 2 && (char)c == linebuf[curr-3])
		{
			backc();
			backc();
			backc();
			STORE_CHAR(linebuf[curr], AT_BOLD, pos);
			overstrike = 3;
		} else if (utf_mode && (IS_UTF8_3BYTE(c) || (overstrike==2 && IS_UTF8_TRAIL(c))) && curr > 1 && (char)c == linebuf[curr-2])
		{
			backc();
			backc();
			STORE_CHAR(linebuf[curr], AT_BOLD, pos);
			overstrike = 2;
		} else if (utf_mode && curr > 0 && (IS_UTF8_2BYTE(c) || (overstrike==1 && IS_UTF8_TRAIL(c))) && (char)c == linebuf[curr-1])
		{
			backc();
			STORE_CHAR(linebuf[curr], AT_BOLD, pos);
			overstrike = 1;
		} else if (utf_mode && curr > 0 && IS_UTF8_TRAIL(c) && attr[curr-1] == AT_UNDERLINE)
		{
			STOREC(c, AT_UNDERLINE);
		} else if ((char)c == linebuf[curr])
d914 11
a924 5
			if (c == '_' && last_overstrike != AT_NORMAL)
				STOREC(c, last_overstrike);
			else
				STOREC(c, AT_BOLD);
		} else if (c == '_')
d926 4
a929 12
			if (utf_mode)
			{
				int i;
				for (i = 0;  i < 5;  i++)
				{
					if (curr <= i || !IS_CONT(linebuf[curr-i]))
						break;
					attr[curr-i-1] = AT_UNDERLINE;
				}
			}
			STOREC(linebuf[curr], AT_UNDERLINE);
		} else if (linebuf[curr] == '_')
d931 10
a940 12
			if (utf_mode)
			{
				if (IS_UTF8_2BYTE(c))
					overstrike = 1;
				else if (IS_UTF8_3BYTE(c))
					overstrike = 2;
				else if (IS_UTF8_4BYTE(c))
					overstrike = 3;
			}
			STOREC(c, AT_UNDERLINE);
		} else if (control_char(c))
			goto do_control_char;
d942 5
a946 2
			STOREC(c, AT_NORMAL);
	} else if (c == '\t') 
d957 1
a957 1
			STORE_TAB(AT_NORMAL, pos);
d960 1
a960 1
	} else if (control_char(c))
d963 1
a963 1
		if (ctldisp == OPT_ON || (ctldisp == OPT_ONPLUS && c == ESC))
d968 1
a968 1
			STORE_CHAR(c, AT_NORMAL, pos);
d971 9
a979 5
			/*
			 * Convert to printable representation.
			 */
			s = prchar(c);  
			a = binattr;
d981 3
a983 7
			/*
			 * Make sure we can get the entire representation
			 * of the character on this line.
			 */
			if (column + (int) strlen(s) + 
			    attr_swidth(a) + attr_ewidth(a) > sc_width)
				return (1);
d985 5
a989 4
			for ( ;  *s != 0;  s++)
				STORE_CHAR(*s, a, pos);
		}
	} else
d991 1
a991 1
		STOREC(c, AT_NORMAL);
d993 10
d1004 9
a1012 1
	return (0);
d1019 1
a1019 1
pdone(endline)
d1021 1
d1023 2
d1031 1
a1031 1
		(void) do_append(pendc, pendpos);
d1039 11
d1053 9
d1063 1
a1063 1
	if (column < sc_width || !auto_wrap || ignaw || ctldisp == OPT_ON)
d1068 21
d1092 1
d1094 9
a1102 12
#if HILITE_SEARCH
	if (status_col && hilites > 0)
	{
		linebuf[0] = '*';
		attr[0] = AT_STANDOUT;
	}
#endif
	/*
	 * If we are done with this line, reset the current shift.
	 */
	if (endline)
		cshift = 0;
a1114 2
	char *s;
	
d1121 12
a1132 3
		*ap = AT_BOLD;
		s = (twiddle) ? "~\n" : "\n";
		return (s[i]);
d1136 1
a1136 1
	return (linebuf[i] & 0377);
d1155 1
a1155 1
forw_raw_line(curr_pos, linep)
d1158 1
d1171 1
a1171 1
		if (c == '\n' || c == EOI)
d1194 2
d1204 1
a1204 1
back_raw_line(curr_pos, linep)
d1207 1
d1222 1
a1222 1
		if (c == '\n')
d1263 2
@


1.8
log
@Fix off-by-one when moving a line to the end of the buffer.  Instead
of doing our own memmove() (incorrectly) just use memmove().
Bug found by Matthias Scheler <tron@@zhadum.de>.
OK deraadt@@ henning@@ krw@@
@
text
@d83 12
a94 8
	char *new_buf = (char *) realloc(linebuf, new_size);
	char *new_attr = (char *) realloc(attr, new_size);
	if (new_buf == NULL || new_attr == NULL)
	{
		if (new_attr != NULL)
			free(new_attr);
		if (new_buf != NULL)
			free(new_buf);
@


1.7
log
@When reallocating the line buffer, double the existing buffer
size instead of just incrementing it by LINEBUF_SIZE and use realloc()
+ memset() instead of calloc() + memcpy().  Prevents excessive resource
usage when displaying very long lines.  OK deraadt@@, krw@@ and otto@@
@
text
@a897 2
			char *fm;
			char *to;
a909 4
			for (fm = linebuf + old_size_linebuf,
			      to = linebuf + size_linebuf;
			     fm >= linebuf;  fm--, to--)
				*to = *fm;
d911 1
@


1.6
log
@Fix sizeof(char *) in snprintf that broke the -N option.
@
text
@d82 3
a84 3
	int new_size = size_linebuf + LINEBUF_SIZE;
	char *new_buf = (char *) calloc(new_size, sizeof(char));
	char *new_attr = (char *) calloc(new_size, sizeof(char));
d93 2
a94 4
	memcpy(new_buf, linebuf, size_linebuf * sizeof(char));
	memcpy(new_attr, attr, size_linebuf * sizeof(char));
	free(attr);
	free(linebuf);
@


1.5
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d172 1
a172 1
		snprintf(linebuf+curr, sizeof(linebuf)-curr, "%*s ", n, buf);
@


1.4
log
@more strlcpy/strlcat/snprintf, less strcpy/strcat/sprintf
reviewed by tdeval, millert, dhartmei and others.  more bits coming here
from some of them i think
@
text
@a0 2
/*	$OpenBSD: line.c,v 1.3 2001/11/19 19:02:14 mpech Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d20 11
a30 2
public char linebuf[1024];	/* Buffer which holds the current output line */
public int size_linebuf = sizeof(linebuf);
a31 1
static char attr[1024];		/* Extension of linebuf to hold attributes */
a34 1
static int lno_indent;		/* Number of chars used for line number */
d36 1
d38 2
d42 1
a46 1
extern int tabstop;
d51 1
d58 44
a112 1
	lno_indent = 0;
d114 6
d129 15
a143 3
	int lno;
	int i;
	int n;
d146 1
a146 2
	 * We display the line number at the start of each line
	 * only if the -N option is set.
d148 11
a158 3
	if (linenums != OPT_ONPLUS)
		return;

d160 2
a161 4
	 * Get the line number and put it in the current line.
	 * {{ Note: since find_linenum calls forw_raw_line,
	 *    it may seek in the input file, requiring the caller 
	 *    of plinenum to re-seek if necessary. }}
d163 4
a166 1
	lno = find_linenum(pos);
d168 12
a179 5
	snprintf(&linebuf[curr], sizeof linebuf - curr, "%6d", lno);
	n = strlen(&linebuf[curr]);
	column += n;
	for (i = 0;  i < n;  i++)
		attr[curr++] = 0;
d182 1
a182 3
	 * Append enough spaces to bring us to the next tab stop.
	 * {{ We could avoid this at the cost of adding some
	 *    complication to the tab stop logic in pappend(). }}
d184 1
a184 3
	if (tabstop == 0)
		tabstop = 1;
	do
d189 90
a278 2
	} while ((column % tabstop) != 0);
	lno_indent = column;
d285 1
a285 1
	int
d303 1
a303 1
	int
d328 4
a331 1
	int w;
d370 32
d404 3
d408 1
a408 1
storec(c, a, pos)
d413 1
a413 1
	int w;
d415 2
d419 1
d425 2
d428 5
a432 2
	w = pwidth(c, a);
	if (ctldisp > 0 && column + w + attr_ewidth(a) > sc_width)
d438 2
a439 1
	if (curr >= sizeof(linebuf)-2)
d442 1
d444 3
a446 1
		return (1);
d488 32
d526 1
a526 1
	int c;
d529 2
d554 13
a566 1
	return (do_append(c, pos));
d569 5
d579 2
a580 2
	char *s;
	int a;
d582 2
a583 2
#define	STOREC(c,a) \
	if (storec((c),(a),pos)) return (1); else curr++
d585 17
a601 1
	if (overstrike)
d610 47
a656 4
		overstrike = 0;
		if ((char)c == linebuf[curr])
			STOREC(linebuf[curr], AT_BOLD);
		else if (c == '_')
d658 11
a668 1
		else if (linebuf[curr] == '_')
d670 1
a670 1
		else if (control_char(c))
d674 1
a674 1
	} else if (c == '\b')
d676 3
a680 3
		case BS_NORMAL:
			STOREC(c, AT_NORMAL);
			break;
d683 1
d685 1
a685 4
			if (curr == 0)
				break;
			backc();
			overstrike = 1;
a687 11
	} else if (c == '\t') 
	{
		/*
		 * Expand a tab into spaces.
		 */
		if (tabstop == 0)
			tabstop = 1;
		do
		{
			STOREC(' ', AT_NORMAL);
		} while ((column % tabstop) != 0);
d691 1
a691 1
		if (ctldisp == 0)
d696 1
a696 1
			STOREC(c, AT_NORMAL);
d714 1
a714 1
				STOREC(*s, a);
d740 6
d749 1
a749 1
	if (column < sc_width || !auto_wrap || ignaw || ctldisp == 0)
d757 13
d779 2
a780 2
	int i;
	int *ap;
d790 1
a790 1
		*ap = AT_NORMAL;
d806 1
a808 1
#if 1
d819 2
a820 2
	char *p;
	int c;
d827 1
a827 2
	p = linebuf;

d835 1
a835 1
		if (p >= &linebuf[sizeof(linebuf)-1])
d837 9
a845 8
			/*
			 * Overflowed the input buffer.
			 * Pretend the line ended here.
			 * {{ The line buffer is supposed to be big
			 *    enough that this never happens. }}
			 */
			new_pos = ch_tell() - 1;
			break;
d847 1
a847 1
		*p++ = c;
d850 1
a850 1
	*p = '\0';
d865 2
a866 2
	char *p;
	int c;
d873 2
a874 3
	p = &linebuf[sizeof(linebuf)];
	*--p = '\0';

d897 1
a897 1
		if (p <= linebuf)
d899 12
d912 1
a912 2
			 * Overflowed the input buffer.
			 * Pretend the line ended here.
d914 5
a918 2
			new_pos = ch_tell() + 1;
			break;
d920 1
a920 1
		*--p = c;
d923 1
a923 1
		*linep = p;
a925 1
#endif
@


1.3
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.2 2001/01/29 01:58:02 niklas Exp $	*/
d106 1
a106 1
	sprintf(&linebuf[curr], "%6d", lno);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d87 3
a89 3
	register int lno;
	register int i;
	register int n;
d175 1
a175 1
	register int w;
d222 1
a222 1
	register int w;
d291 1
a291 1
	register int c;
d325 2
a326 2
	register char *s;
	register int a;
d450 2
a451 2
	register int i;
	register int *ap;
d490 2
a491 2
	register char *p;
	register int c;
d536 2
a537 2
	register char *p;
	register int c;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d36 2
a37 11
#define IS_CONT(c)  (((c) & 0xC0) == 0x80)

public char *linebuf = NULL;	/* Buffer which holds the current output line */
static char *attr = NULL;	/* Extension of linebuf to hold attributes */
public int size_linebuf = 0;	/* Size of line buffer (and attr buffer) */

public int cshift;		/* Current left-shift of output line buffer */
public int hshift;		/* Desired left-shift of output line buffer */
public int tabstops[TABSTOP_MAX] = { 0 }; /* Custom tabstops */
public int ntabstops = 1;	/* Number of tabstops */
public int tabdefault = 8;	/* Default repeated tabstops */
d39 1
d43 1
a44 1
static int last_overstrike = AT_NORMAL;
a45 2
static int lmargin;		/* Left margin */
static int hilites;		/* Number of hilites in this line */
a47 1
static char *end_ansi_chars;
d52 1
a56 1
extern int status_col;
a62 44
extern int utf_mode;
extern POSITION start_attnpos;
extern POSITION end_attnpos;

/*
 * Initialize from environment variables.
 */
	public void
init_line()
{
	end_ansi_chars = lgetenv("LESSANSIENDCHARS");
	if (end_ansi_chars == NULL || *end_ansi_chars == '\0')
		end_ansi_chars = "m";
	linebuf = (char *) ecalloc(LINEBUF_SIZE, sizeof(char));
	attr = (char *) ecalloc(LINEBUF_SIZE, sizeof(char));
	size_linebuf = LINEBUF_SIZE;
}

/*
 * Expand the line buffer.
 */
 	static int
expand_linebuf()
{
	int new_size = size_linebuf + LINEBUF_SIZE;
	char *new_buf = (char *) calloc(new_size, sizeof(char));
	char *new_attr = (char *) calloc(new_size, sizeof(char));
	if (new_buf == NULL || new_attr == NULL)
	{
		if (new_attr != NULL)
			free(new_attr);
		if (new_buf != NULL)
			free(new_buf);
		return 1;
	}
	memcpy(new_buf, linebuf, size_linebuf * sizeof(char));
	memcpy(new_attr, attr, size_linebuf * sizeof(char));
	free(attr);
	free(linebuf);
	linebuf = new_buf;
	attr = new_attr;
	size_linebuf = new_size;
	return 0;
}
d74 1
a75 6
	lmargin = 0;
	if (status_col)
		lmargin += 1;
#if HILITE_SEARCH
	hilites = 0;
#endif
d85 1
a85 1
	register LINENUM linenum = 0;
d87 1
a87 13

	if (linenums == OPT_ONPLUS)
	{
		/*
		 * Get the line number and put it in the current line.
		 * {{ Note: since find_linenum calls forw_raw_line,
		 *    it may seek in the input file, requiring the caller 
		 *    of plinenum to re-seek if necessary. }}
		 * {{ Since forw_raw_line modifies linebuf, we must
		 *    do this first, before storing anything in linebuf. }}
		 */
		linenum = find_linenum(pos);
	}
d90 2
a91 1
	 * Display a status column if the -J option is set.
d93 3
a95 11
	if (status_col)
	{
		linebuf[curr] = ' ';
		if (start_attnpos != NULL_POSITION &&
		    pos >= start_attnpos && pos < end_attnpos)
			attr[curr] = AT_STANDOUT;
		else
			attr[curr] = 0;
		curr++;
		column++;
	}
d97 4
a100 2
	 * Display the line number at the start of each line
	 * if the -N option is set.
d102 1
a102 4
	if (linenums == OPT_ONPLUS)
	{
		char buf[INT_STRLEN_BOUND(pos) + 2];
		int n;
d104 5
a108 12
		linenumtoa(linenum, buf);
		n = strlen(buf);
		if (n < MIN_LINENUM_WIDTH)
			n = MIN_LINENUM_WIDTH;
		sprintf(linebuf+curr, "%*s ", n, buf);
		n++;  /* One space after the line number. */
		for (i = 0; i < n; i++)
			attr[curr+i] = AT_NORMAL;
		curr += n;
		column += n;
		lmargin += n;
	}
d111 3
a113 1
	 * Append enough spaces to bring us to the lmargin.
d115 3
a117 1
	while (column < lmargin)
d122 2
a123 90
	}
}

/*
 * Determine how many characters are required to shift N columns.
 */
	static int
shift_chars(s, len)
	char *s;
	int len;
{
	char *p = s;

	/*
	 * Each char counts for one column, except ANSI color escape
	 * sequences use no columns since they don't move the cursor.
	 */
	while (*p != '\0' && len > 0)
	{
		if (*p++ != ESC)
		{
			len--;
		} else
		{
			while (*p != '\0')
			{
				if (is_ansi_end(*p++))
					break;
			}
		}
	}
	return (p - s);
}

/*
 * Determine how many characters are required to shift N columns (UTF version).
 * {{ FIXME: what about color escape sequences in UTF mode? }}
 */
	static int
utf_shift_chars(s, len)
	char *s;
	int len;
{
	int ulen = 0;

	while (*s != '\0' && len > 0)
	{
		if (!IS_CONT(*s))
			len--;
		s++;
		ulen++;
	}
	while (IS_CONT(*s))
	{
		s++;
		ulen++;
	}
	return (ulen);
}

/*
 * Shift the input line left.
 * This means discarding N printable chars at the start of the buffer.
 */
	static void
pshift(shift)
	int shift;
{
	int i;
	int nchars;

	if (shift > column - lmargin)
		shift = column - lmargin;
	if (shift > curr - lmargin)
		shift = curr - lmargin;

	if (utf_mode)
		nchars = utf_shift_chars(linebuf + lmargin, shift);
	else
		nchars = shift_chars(linebuf + lmargin, shift);
	if (nchars > curr)
		nchars = curr;
	for (i = 0;  i < curr - nchars;  i++)
	{
		linebuf[lmargin + i] = linebuf[lmargin + i + nchars];
		attr[lmargin + i] = attr[lmargin + i + nchars];
	}
	curr -= nchars;
	column -= shift;
	cshift += shift;
d130 1
a130 1
	static int
d148 1
a148 1
	static int
a174 3
	if (utf_mode && IS_CONT(c))
		return (0);

a211 32
 * Are we currently within a recognized ANSI escape sequence?
 */
	static int
in_ansi_esc_seq()
{
	int i;

	/*
	 * Search backwards for either an ESC (which means we ARE in a seq);
	 * or an end char (which means we're NOT in a seq).
	 */
	for (i = curr-1;  i >= 0;  i--)
	{
		if (linebuf[i] == ESC)
			return (1);
		if (is_ansi_end(linebuf[i]))
			return (0);
	}
	return (0);
}

/*
 * Is a character the end of an ANSI escape sequence?
 */
	public int
is_ansi_end(c)
	char c;
{
	return (strchr(end_ansi_chars, c) != NULL);
}

/*
a213 3
#define	STORE_CHAR(c,a,pos) \
	do { if (store_char((c),(a),(pos))) return (1); else curr++; } while (0)

d215 1
a215 1
store_char(c, a, pos)
a221 2
	if (a != AT_NORMAL)
		last_overstrike = a;
a223 1
	{
a228 2
		hilites++;
	}
d230 2
a231 5
	if (ctldisp == OPT_ONPLUS && in_ansi_esc_seq())
		w = 0;
	else
		w = pwidth(c, a);
	if (ctldisp != OPT_ON && column + w + attr_ewidth(a) > sc_width)
d237 1
a237 2
	if (curr >= size_linebuf-2)
	{
a239 1
		 * Try to expand it.
d241 1
a241 3
		if (expand_linebuf())
			return (1);
	}
a282 32
 * Append a tab to the line buffer.
 * Store spaces to represent the tab.
 */
#define	STORE_TAB(a,pos) \
	do { if (store_tab((a),(pos))) return (1); } while (0)

	static int
store_tab(attr, pos)
	int attr;
	POSITION pos;
{
	int to_tab = column + cshift - lmargin;
	int i;

	if (ntabstops < 2 || to_tab >= tabstops[ntabstops-1])
		to_tab = tabdefault -
		     ((to_tab - tabstops[ntabstops-1]) % tabdefault);
	else
	{
		for (i = ntabstops - 2;  i >= 0;  i--)
			if (to_tab >= tabstops[i])
				break;
		to_tab = tabstops[i+1] - to_tab;
	}

	do {
		STORE_CHAR(' ', attr, pos);
	} while (--to_tab > 0);
	return 0;
}

/*
a291 2
	int r;

d315 1
a315 13
	r = do_append(c, pos);
	/*
	 * If we need to shift the line, do it.
	 * But wait until we get to at least the middle of the screen,
	 * so shifting it doesn't affect the chars we're currently
	 * pappending.  (Bold & underline can get messed up otherwise.)
	 */
	if (cshift < hshift && column > sc_width / 2)
	{
		linebuf[curr] = '\0';
		pshift(hshift - cshift);
	}
	return (r);
a317 5
#define IS_UTF8_4BYTE(c) ( ((c) & 0xf8) == 0xf0 )
#define IS_UTF8_3BYTE(c) ( ((c) & 0xf0) == 0xe0 )
#define IS_UTF8_2BYTE(c) ( ((c) & 0xe0) == 0xc0 )
#define IS_UTF8_TRAIL(c) ( ((c) & 0xc0) == 0x80 )

d326 2
a327 2
#define STOREC(c,a) \
	if ((c) == '\t') STORE_TAB((a),pos); else STORE_CHAR((c),(a),pos)
d329 1
a329 17
	if (c == '\b')
	{
		switch (bs_mode)
		{
		case BS_NORMAL:
			STORE_CHAR(c, AT_NORMAL, pos);
			break;
		case BS_CONTROL:
			goto do_control_char;
		case BS_SPECIAL:
			if (curr == 0)
				break;
			backc();
			overstrike = 1;
			break;
		}
	} else if (overstrike)
d338 4
a341 47
		overstrike--;
		if (utf_mode && IS_UTF8_4BYTE(c) && curr > 2 && (char)c == linebuf[curr-3])
		{
			backc();
			backc();
			backc();
			STORE_CHAR(linebuf[curr], AT_BOLD, pos);
			overstrike = 3;
		} else if (utf_mode && (IS_UTF8_3BYTE(c) || (overstrike==2 && IS_UTF8_TRAIL(c))) && curr > 1 && (char)c == linebuf[curr-2])
		{
			backc();
			backc();
			STORE_CHAR(linebuf[curr], AT_BOLD, pos);
			overstrike = 2;
		} else if (utf_mode && curr > 0 && (IS_UTF8_2BYTE(c) || (overstrike==1 && IS_UTF8_TRAIL(c))) && (char)c == linebuf[curr-1])
		{
			backc();
			STORE_CHAR(linebuf[curr], AT_BOLD, pos);
			overstrike = 1;
		} else if (utf_mode && curr > 0 && IS_UTF8_TRAIL(c) && attr[curr-1] == AT_UNDERLINE)
		{
			STOREC(c, AT_UNDERLINE);
		} else if ((char)c == linebuf[curr])
		{
			/*
			 * Overstriking a char with itself means make it bold.
			 * But overstriking an underscore with itself is
			 * ambiguous.  It could mean make it bold, or
			 * it could mean make it underlined.
			 * Use the previous overstrike to resolve it.
			 */
			if (c == '_' && last_overstrike != AT_NORMAL)
				STOREC(c, last_overstrike);
			else
				STOREC(c, AT_BOLD);
		} else if (c == '_')
		{
			if (utf_mode)
			{
				int i;
				for (i = 0;  i < 5;  i++)
				{
					if (curr <= i || !IS_CONT(linebuf[curr-i]))
						break;
					attr[curr-i-1] = AT_UNDERLINE;
				}
			}
d343 1
a343 11
		} else if (linebuf[curr] == '_')
		{
			if (utf_mode)
			{
				if (IS_UTF8_2BYTE(c))
					overstrike = 1;
				else if (IS_UTF8_3BYTE(c))
					overstrike = 2;
				else if (IS_UTF8_4BYTE(c))
					overstrike = 3;
			}
d345 1
a345 1
		} else if (control_char(c))
d349 1
a349 1
	} else if (c == '\t') 
a350 3
		/*
		 * Expand a tab into spaces.
		 */
d353 3
a357 1
		case BS_NORMAL:
d359 4
a362 1
			STORE_TAB(AT_NORMAL, pos);
d365 11
d379 1
a379 1
		if (ctldisp == OPT_ON || (ctldisp == OPT_ONPLUS && c == ESC))
d384 1
a384 1
			STORE_CHAR(c, AT_NORMAL, pos);
d402 1
a402 1
				STORE_CHAR(*s, a, pos);
a427 6
	 * Make sure we've shifted the line, if we need to.
	 */
	if (cshift < hshift)
		pshift(hshift - cshift);

	/*
d431 1
a431 1
	if (column < sc_width || !auto_wrap || ignaw || ctldisp == OPT_ON)
a438 13

#if HILITE_SEARCH
	if (status_col && hilites > 0)
	{
		linebuf[0] = '*';
		attr[0] = AT_STANDOUT;
	}
#endif
	/*
	 * If we are done with this line, reset the current shift.
	 */
	if (endline)
		cshift = 0;
d459 1
a459 1
		*ap = AT_BOLD;
a474 1
	cshift = 0;
d477 1
d488 1
a488 1
	register int n;
d496 2
a497 1
	n = 0;
d505 1
a505 1
		if (n >= size_linebuf-1)
d507 8
a514 9
			if (expand_linebuf())
			{
				/*
				 * Overflowed the input buffer.
				 * Pretend the line ended here.
				 */
				new_pos = ch_tell() - 1;
				break;
			}
d516 1
a516 1
		linebuf[n++] = c;
d519 1
a519 1
	linebuf[n] = '\0';
d534 1
a534 1
	register int n;
d542 3
a544 2
	n = size_linebuf;
	linebuf[--n] = '\0';
d567 1
a567 1
		if (n <= 0)
a568 12
			int old_size_linebuf = size_linebuf;
			char *fm;
			char *to;
			if (expand_linebuf())
			{
				/*
				 * Overflowed the input buffer.
				 * Pretend the line ended here.
				 */
				new_pos = ch_tell() + 1;
				break;
			}
d570 2
a571 1
			 * Shift the data to the end of the new linebuf.
d573 2
a574 5
			for (fm = linebuf + old_size_linebuf,
			      to = linebuf + size_linebuf;
			     fm >= linebuf;  fm--, to--)
				*to = *fm;
			n = size_linebuf - old_size_linebuf;
d576 1
a576 1
		linebuf[--n] = c;
d579 1
a579 1
		*linep = &linebuf[n];
d582 1
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
a18 1
#include "charset.h"
d20 3
a22 1
static char *linebuf = NULL;	/* Buffer which holds the current output line */
d26 1
a26 1
static int cshift;		/* Current left-shift of output line buffer */
d39 1
a42 1
static char *mid_ansi_chars;
a43 2
static int attr_swidth();
static int attr_ewidth();
a45 1
extern int sigs;
a61 5
static char mbc_buf[MAX_UTF_CHAR_LEN];
static int mbc_buf_len = 0;
static int mbc_buf_index = 0;
static POSITION mbc_pos;

a70 5

	mid_ansi_chars = lgetenv("LESSANSIMIDCHARS");
	if (mid_ansi_chars == NULL || *mid_ansi_chars == '\0')
		mid_ansi_chars = "0123456789;[?!\"'#%()*+ ";

d79 1
a79 1
	static int
d82 1
a82 8
	/* Double the size of the line buffer. */
	int new_size = size_linebuf * 2;

	/* Just realloc to expand the buffer, if we can. */
#if HAVE_REALLOC
	char *new_buf = (char *) realloc(linebuf, new_size);
	char *new_attr = (char *) realloc(attr, new_size);
#else
a84 1
#endif
a92 12
#if HAVE_REALLOC
	/*
	 * We realloc'd the buffers; they already have the old contents.
	 */
	#if 0
	memset(new_buf + size_linebuf, 0, new_size - size_linebuf);
	memset(new_attr + size_linebuf, 0, new_size - size_linebuf);
	#endif
#else
	/*
	 * We just calloc'd the buffers; copy the old contents.
	 */
a96 1
#endif
a103 10
 * Is a character ASCII?
 */
	public int
is_ascii_char(ch)
	LWCHAR ch;
{
	return (ch <= 0x7F);
}

/*
a110 1
	cshift = 0;
a111 2
	last_overstrike = AT_NORMAL;
	mbc_buf_len = 0;
d117 3
d153 1
a153 1
			attr[curr] = AT_NORMAL|AT_HILITE;
d155 1
a155 1
			attr[curr] = AT_NORMAL;
d193 1
a193 2
 * Shift the input line left.
 * This means discarding N printable chars at the start of the buffer.
d195 4
a198 3
	static void
pshift(shift)
	int shift;
d200 1
a200 9
	LWCHAR prev_ch = 0;
	unsigned char c;
	int shifted = 0;
	int to;
	int from;
	int len;
	int width;
	int prev_attr;
	int next_attr;
a201 6
	if (shift > column - lmargin)
		shift = column - lmargin;
	if (shift > curr - lmargin)
		shift = curr - lmargin;

	to = from = lmargin;
d203 2
a204 2
	 * We keep on going when shifted == shift
	 * to get all combining chars.
d206 1
a206 1
	while (shifted <= shift && from < curr)
d208 1
a208 2
		c = linebuf[from];
		if (ctldisp == OPT_ONPLUS && IS_CSI_START(c))
d210 1
a210 27
			/* Keep cumulative effect.  */
			linebuf[to] = c;
			attr[to++] = attr[from++];
			while (from < curr && linebuf[from])
			{
				linebuf[to] = linebuf[from];
				attr[to++] = attr[from];
				if (!is_ansi_middle(linebuf[from++]))
					break;
			} 
			continue;
		}

		width = 0;

		if (!IS_ASCII_OCTET(c) && utf_mode)
		{
			/* Assumes well-formedness validation already done.  */
			LWCHAR ch;

			len = utf_len(c);
			if (from + len > curr)
				break;
			ch = get_wchar(linebuf + from);
			if (!is_composing_char(ch) && !is_combining_char(prev_ch, ch))
				width = is_wide_char(ch) ? 2 : 1;
			prev_ch = ch;
d213 1
a213 33
			len = 1;
			if (c == '\b')
				/* XXX - Incorrect if several '\b' in a row.  */
				width = (utf_mode && is_wide_char(prev_ch)) ? -2 : -1;
			else if (!control_char(c))
				width = 1;
			prev_ch = 0;
		}

		if (width == 2 && shift - shifted == 1) {
			/* Should never happen when called by pshift_all().  */
			attr[to] = attr[from];
			/*
			 * Assume a wide_char will never be the first half of a
			 * combining_char pair, so reset prev_ch in case we're
			 * followed by a '\b'.
			 */
			prev_ch = linebuf[to++] = ' ';
			from += len;
			shifted++;
			continue;
		}

		/* Adjust width for magic cookies. */
		prev_attr = (to > 0) ? attr[to-1] : AT_NORMAL;
		next_attr = (from + len < curr) ? attr[from + len] : prev_attr;
		if (!is_at_equiv(attr[from], prev_attr) && 
			!is_at_equiv(attr[from], next_attr))
		{
			width += attr_swidth(attr[from]);
			if (from + len < curr)
				width += attr_ewidth(attr[from]);
			if (is_at_equiv(prev_attr, next_attr))
d215 2
a216 3
				width += attr_ewidth(prev_attr);
				if (from + len < curr)
					width += attr_swidth(next_attr);
d219 3
d223 24
a246 15
		if (shift - shifted < width)
			break;
		from += len;
		shifted += width;
		if (shifted < 0)
			shifted = 0;
	}
	while (from < curr)
	{
		linebuf[to] = linebuf[from];
		attr[to++] = attr[from++];
	}
	curr = to;
	column -= shifted;
	cshift += shifted;
d250 2
a251 1
 *
d253 3
a255 2
	public void
pshift_all()
d257 22
a278 1
	pshift(column);
d289 8
a296 14
	int w = 0;

	a = apply_at_specials(a);

	if (a & AT_UNDERLINE)
		w += ul_s_width;
	if (a & AT_BOLD)
		w += bo_s_width;
	if (a & AT_BLINK)
		w += bl_s_width;
	if (a & AT_STANDOUT)
		w += so_s_width;

	return w;
d307 8
a314 14
	int w = 0;

	a = apply_at_specials(a);

	if (a & AT_UNDERLINE)
		w += ul_e_width;
	if (a & AT_BOLD)
		w += bo_e_width;
	if (a & AT_BLINK)
		w += bl_e_width;
	if (a & AT_STANDOUT)
		w += so_e_width;

	return w;
d324 2
a325 2
pwidth(ch, a, prev_ch)
	LWCHAR ch;
a326 1
	LWCHAR prev_ch;
d328 4
a331 1
	int w;
d333 1
a333 1
	if (ch == '\b')
d335 1
a335 2
		 * Backspace moves backwards one or two positions.
		 * XXX - Incorrect if several '\b' in a row.
d337 1
a337 1
		return (utf_mode && is_wide_char(prev_ch)) ? -2 : -1;
d339 7
a345 29
	if (!utf_mode || is_ascii_char(ch))
	{
		if (control_char((char)ch))
		{
			/*
			 * Control characters do unpredictable things,
			 * so we don't even try to guess; say it doesn't move.
			 * This can only happen if the -r flag is in effect.
			 */
			return (0);
		}
	} else
	{
		if (is_composing_char(ch) || is_combining_char(prev_ch, ch))
		{
			/*
			 * Composing and combining chars take up no space.
			 *
			 * Some terminals, upon failure to compose a
			 * composing character with the character(s) that
			 * precede(s) it will actually take up one column
			 * for the composing character; there isn't much
			 * we could do short of testing the (complex)
			 * composition process ourselves and printing
			 * a binary representation when it fails.
			 */
			return (0);
		}
	}
d348 1
a348 1
	 * Other characters take one or two columns,
d352 1
a352 3
	if (is_wide_char(ch))
		w++;
	if (curr > 0 && !is_at_equiv(attr[curr-1], a))
d354 1
a354 2
	if ((apply_at_specials(a) != AT_NORMAL) &&
	    (curr == 0 || !is_at_equiv(attr[curr-1], a)))
d360 1
a360 2
 * Delete to the previous base character in the line buffer.
 * Return 1 if one is found.
d362 1
a362 1
	static int
d365 2
a366 20
	LWCHAR prev_ch;
	char *p = linebuf + curr;
	LWCHAR ch = step_char(&p, -1, linebuf + lmargin);
	int width;

	/* This assumes that there is no '\b' in linebuf.  */
	while (   curr > lmargin
	       && column > lmargin
	       && (!(attr[curr - 1] & (AT_ANSI|AT_BINARY))))
	{
		curr = p - linebuf;
		prev_ch = step_char(&p, -1, linebuf + lmargin);
		width = pwidth(ch, attr[curr], prev_ch);
		column -= width;
		if (width > 0)
			return 1;
		ch = prev_ch;
	}

	return 0;
d375 1
a375 1
	char *p;
d381 1
a381 1
	for (p = &linebuf[curr];  p > linebuf; )
d383 1
a383 2
		LWCHAR ch = step_char(&p, -1, linebuf);
		if (IS_CSI_START(ch))
d385 1
a385 1
		if (!is_ansi_middle(ch))
d395 2
a396 2
is_ansi_end(ch)
	LWCHAR ch;
d398 1
a398 17
	if (!is_ascii_char(ch))
		return (0);
	return (strchr(end_ansi_chars, (char) ch) != NULL);
}

/*
 *
 */
	public int
is_ansi_middle(ch)
	LWCHAR ch;
{
	if (!is_ascii_char(ch))
		return (0);
	if (is_ansi_end(ch))
		return (0);
	return (strchr(mid_ansi_chars, (char) ch) != NULL);
d404 2
a405 4
#define	STORE_CHAR(ch,a,rep,pos) \
	do { \
		if (store_char((ch),(a),(rep),(pos))) return (1); \
	} while (0)
d408 2
a409 2
store_char(ch, a, rep, pos)
	LWCHAR ch;
a410 1
	char *rep;
d413 1
a413 7
	int w;
	int replen;
	char cs;

	w = (a & (AT_UNDERLINE|AT_BOLD));	/* Pre-use w.  */
	if (w != AT_NORMAL)
		last_overstrike = w;
d415 2
d418 1
d420 6
a425 10
		int matches;
		if (is_hilited(pos, pos+1, 0, &matches))
		{
			/*
			 * This character should be highlighted.
			 * Override the attribute passed in.
			 */
			if (a != AT_ANSI)
				a |= AT_HILITE;
		}
a427 1

a428 17
	{
		if (!is_ansi_end(ch) && !is_ansi_middle(ch)) {
			/* Remove whole unrecognized sequence.  */
			char *p = &linebuf[curr];
			LWCHAR bch;
			do {
				bch = step_char(&p, -1, linebuf);
			} while (p > linebuf && !IS_CSI_START(bch));
			curr = p - linebuf;
			return 0;
		}
		a = AT_ANSI;	/* Will force re-AT_'ing around it.  */
		w = 0;
	}
	else if (ctldisp == OPT_ONPLUS && IS_CSI_START(ch))
	{
		a = AT_ANSI;	/* Will force re-AT_'ing around it.  */
a429 1
	}
d431 1
a431 6
	{
		char *p = &linebuf[curr];
		LWCHAR prev_ch = step_char(&p, -1, linebuf);
		w = pwidth(ch, a, prev_ch);
	}

d438 1
a438 10
	if (rep == NULL)
	{
		cs = (char) ch;
		rep = &cs;
		replen = 1;
	} else
	{
		replen = utf_len(rep[0]);
	}
	if (curr + replen >= size_linebuf-6)
d448 23
a470 1
	while (replen-- > 0)
d472 6
a477 3
		linebuf[curr] = *rep++;
		attr[curr] = a;
		curr++;
d479 4
a512 3
	if (column + to_tab - 1 + pwidth(' ', attr, 0) + attr_ewidth(attr) > sc_width)
		return 1;

d514 1
a514 1
		STORE_CHAR(' ', attr, " ", pos);
a518 42
#define STORE_PRCHAR(c, pos) \
	do { if (store_prchar((c), (pos))) return 1; } while (0)

	static int
store_prchar(c, pos)
	char c;
	POSITION pos;
{
	char *s;

	/*
	 * Convert to printable representation.
	 */
	s = prchar(c);

	/*
	 * Make sure we can get the entire representation
	 * of the character on this line.
	 */
	if (column + (int) strlen(s) - 1 +
            pwidth(' ', binattr, 0) + attr_ewidth(binattr) > sc_width)
		return 1;

	for ( ;  *s != 0;  s++)
		STORE_CHAR(*s, AT_BINARY, NULL, pos);

	return 0;
}

	static int
flush_mbc_buf(pos)
	POSITION pos;
{
	int i;

	for (i = 0; i < mbc_buf_index; i++)
		if (store_prchar(mbc_buf[i], pos))
			return mbc_buf_index - i;

	return 0;
}

d526 1
a526 1
	char c;
d533 1
a533 1
		if (do_append(pendc, NULL, pendpos))
a543 10
		if (mbc_buf_len > 0)  /* utf_mode must be on. */
		{
			/* Flush incomplete (truncated) sequence. */
			r = flush_mbc_buf(mbc_pos);
			mbc_buf_index = r + 1;
			mbc_buf_len = 0;
			if (r)
				return (mbc_buf_index);
		}

d554 1
a554 44
	if (!utf_mode)
	{
		r = do_append((LWCHAR) c, NULL, pos);
	} else
	{
		/* Perform strict validation in all possible cases. */
		if (mbc_buf_len == 0)
		{
		retry:
			mbc_buf_index = 1;
			*mbc_buf = c;
			if (IS_ASCII_OCTET(c))
				r = do_append((LWCHAR) c, NULL, pos);
			else if (IS_UTF8_LEAD(c))
			{
				mbc_buf_len = utf_len(c);
				mbc_pos = pos;
				return (0);
			} else
				/* UTF8_INVALID or stray UTF8_TRAIL */
				r = flush_mbc_buf(pos);
		} else if (IS_UTF8_TRAIL(c))
		{
			mbc_buf[mbc_buf_index++] = c;
			if (mbc_buf_index < mbc_buf_len)
				return (0);
			if (is_utf8_well_formed(mbc_buf))
				r = do_append(get_wchar(mbc_buf), mbc_buf, mbc_pos);
			else
				/* Complete, but not shortest form, sequence. */
				mbc_buf_index = r = flush_mbc_buf(mbc_pos);
			mbc_buf_len = 0;
		} else
		{
			/* Flush incomplete (truncated) sequence.  */
			r = flush_mbc_buf(mbc_pos);
			mbc_buf_index = r + 1;
			mbc_buf_len = 0;
			/* Handle new char.  */
			if (!r)
				goto retry;
 		}
	}

a565 5
	if (r)
	{
		/* How many chars should caller back up? */
		r = (!utf_mode) ? 1 : mbc_buf_index;
	}
d569 5
d575 2
a576 3
do_append(ch, rep, pos)
	LWCHAR ch;
	char *rep;
d579 1
a580 1
	LWCHAR prev_ch;
d582 2
a583 1
	a = AT_NORMAL;
d585 1
a585 1
	if (ch == '\b')
d587 6
a592 1
		if (bs_mode == BS_CONTROL)
d594 8
a601 19

		/*
		 * A better test is needed here so we don't
		 * backspace over part of the printed
		 * representation of a binary character.
		 */
		if (   curr <= lmargin
		    || column <= lmargin
		    || (attr[curr - 1] & (AT_ANSI|AT_BINARY)))
			STORE_PRCHAR('\b', pos);
		else if (bs_mode == BS_NORMAL)
			STORE_CHAR(ch, AT_NORMAL, NULL, pos);
		else if (bs_mode == BS_SPECIAL)
			overstrike = backc();

		return 0;
	}

	if (overstrike > 0)
d610 23
a632 5
		overstrike = utf_mode ? -1 : 0;
		/* To be correct, this must be a base character.  */
		prev_ch = get_wchar(linebuf + curr);
		a = attr[curr];
		if (ch == prev_ch)
d641 7
a647 1
			if (ch == '_')
d649 10
a658 9
				if ((a & (AT_BOLD|AT_UNDERLINE)) != AT_NORMAL)
					a |= (AT_BOLD|AT_UNDERLINE);
				else if (last_overstrike != AT_NORMAL)
					a |= last_overstrike;
				else
					a |= AT_BOLD;
			} else
				a |= AT_BOLD;
		} else if (ch == '_')
d660 12
a671 14
			a |= AT_UNDERLINE;
			ch = prev_ch;
			rep = linebuf + curr;
		} else if (prev_ch == '_')
		{
			a |= AT_UNDERLINE;
		}
		/* Else we replace prev_ch, but we keep its attributes.  */
	} else if (overstrike < 0)
	{
		if (   is_composing_char(ch)
		    || is_combining_char(get_wchar(linebuf + curr), ch))
			/* Continuation of the same overstrike.  */
			a = last_overstrike;
d673 2
a674 4
			overstrike = 0;
	}

	if (ch == '\t') 
d685 1
a685 1
			STORE_TAB(a, pos);
d688 1
a688 1
	} else if ((!utf_mode || is_ascii_char(ch)) && control_char((char)ch))
d691 1
a691 1
		if (ctldisp == OPT_ON || (ctldisp == OPT_ONPLUS && IS_CSI_START(ch)))
d696 1
a696 1
			STORE_CHAR(ch, AT_NORMAL, rep, pos);
d699 5
a703 5
			STORE_PRCHAR((char) ch, pos);
		}
	} else if (utf_mode && ctldisp != OPT_ON && is_ubin_char(ch))
	{
		char *s;
d705 7
a711 1
		s = prutfchar(ch);
d713 4
a716 7
		if (column + (int) strlen(s) - 1 +
		    pwidth(' ', binattr, 0) + attr_ewidth(binattr) > sc_width)
			return (1);

		for ( ;  *s != 0;  s++)
			STORE_CHAR(*s, AT_BINARY, NULL, pos);
 	} else
d718 1
a718 1
		STORE_CHAR(ch, a, rep, pos);
a719 2
 	return (0);
}
d721 1
a721 15
/*
 *
 */
	public int
pflushmbc()
{
	int r = 0;

	if (mbc_buf_len > 0)
	{
		/* Flush incomplete (truncated) sequence.  */
		r = flush_mbc_buf(mbc_pos);
		mbc_buf_len = 0;
	}
	return r;
d728 1
a728 1
pdone(endline, forw)
a729 1
	int forw;
a730 2
	(void) pflushmbc();

d737 1
a737 1
		(void) do_append(pendc, NULL, pendpos);
a744 11
	if (ctldisp == OPT_ONPLUS && is_ansi_end('m'))
	{
		/* Switch to normal attribute at end of line. */
		char *p = "\033[m";
		for ( ;  *p != '\0';  p++)
		{
			linebuf[curr] = *p;
			attr[curr++] = AT_ANSI;
		}
	}

a747 9
	 * We output a newline if we're not at the right edge of the screen,
	 * or if the terminal doesn't auto wrap,
	 * or if this is really the end of the line AND the terminal ignores
	 * a newline at the right edge.
	 * (In the last case we don't want to output a newline if the terminal 
	 * doesn't ignore it since that would produce an extra blank line.
	 * But we do want to output a newline if the terminal ignores it in case
	 * the next line is blank.  In that case the single newline output for
	 * that blank line would be ignored!)
d749 1
a749 1
	if (column < sc_width || !auto_wrap || (endline && ignaw) || ctldisp == OPT_ON)
a753 21
	} 
	else if (ignaw && column >= sc_width && forw)
	{
		/*
		 * Terminals with "ignaw" don't wrap until they *really* need
		 * to, i.e. when the character *after* the last one to fit on a
		 * line is output. But they are too hard to deal with when they
		 * get in the state where a full screen width of characters
		 * have been output but the cursor is sitting on the right edge
		 * instead of at the start of the next line.
		 * So we nudge them into wrapping by outputting a space 
		 * character plus a backspace.  But do this only if moving 
		 * forward; if we're moving backward and drawing this line at
		 * the top of the screen, the space would overwrite the first
		 * char on the next line.  We don't need to do this "nudge" 
		 * at the top of the screen anyway.
		 */
		linebuf[curr] = ' ';
		attr[curr++] = AT_NORMAL;
		linebuf[curr] = '\b'; 
		attr[curr++] = AT_NORMAL;
a756 1
}
d758 12
a769 9
/*
 *
 */
	public void
set_status_col(c)
	char c;
{
	linebuf[0] = c;
	attr[0] = AT_NORMAL|AT_HILITE;
d782 2
d790 3
a792 12
		if (twiddle)
		{
			if (i == 0)
			{
				*ap = AT_BOLD;
				return '~';
			}
			--i;
		}
		/* Make sure we're back to AT_NORMAL before the '\n'.  */
		*ap = AT_NORMAL;
		return i ? '\0' : '\n';
d796 1
a796 1
	return (linebuf[i] & 0xFF);
d815 1
a815 1
forw_raw_line(curr_pos, linep, line_lenp)
a817 1
	int *line_lenp;
d830 1
a830 1
		if (c == '\n' || c == EOI || ABORT_SIGS())
a852 2
	if (line_lenp != NULL)
		*line_lenp = n;
d861 1
a861 1
back_raw_line(curr_pos, linep, line_lenp)
a863 1
	int *line_lenp;
d878 1
a878 1
		if (c == '\n' || ABORT_SIGS())
d914 2
a915 2
			for (fm = linebuf + old_size_linebuf - 1,
			      to = linebuf + size_linebuf - 1;
a923 2
	if (line_lenp != NULL)
		*line_lenp = size_linebuf - 1 - n;
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
a20 2
#include <err.h>

a29 1
public POSITION highest_hilite;	/* Pos of last hilite in file found so far */
d47 1
a47 1
extern volatile sig_atomic_t sigs;
d98 13
a110 12
	char *new_buf;
	char *new_attr;

	new_buf = realloc(linebuf, new_size);
	if (new_buf == NULL)
		return 1;
	new_attr = realloc(attr, new_size);
	if (new_attr == NULL) {
		/* realloc linebuf back to original size */
		linebuf = realloc(new_buf, size_linebuf);
		if (linebuf == NULL)
			err(1, NULL);
d113 1
d117 1
d120 10
d211 1
a211 1
		linenumtoa(linenum, buf, sizeof(buf));
d215 1
a215 1
		snprintf(linebuf+curr, size_linebuf-curr, "%*s ", n, buf);
a282 1
#if !SMALL
a295 1
#endif /* !SMALL */
a299 1
#if !SMALL
a300 3
#else
				width = -1;
#endif /* !SMALL */
a429 1
#if !SMALL
a430 3
#else
		return -1;
#endif /* !SMALL */
d443 1
a443 3
	}
#if !SMALL
	else
a460 1
#endif /* !SMALL */
a466 1
#if !SMALL
a468 1
#endif /* !SMALL */
a587 4
			{
				if (highest_hilite != NULL_POSITION &&
				    pos > highest_hilite)
				    	highest_hilite = pos;
a588 1
			}
a632 1
#if !SMALL
a633 3
#else
		replen = 1;
#endif /* !SMALL */
a718 1
#if !SMALL
a730 1
#endif /* !SMALL */
a756 1
#if !SMALL
a765 1
#endif /* !SMALL */
d780 1
a780 3
	}
#if !SMALL
	else
a819 1
#endif /* !SMALL */
a883 1
#if !SMALL
a884 3
#else
		prev_ch = (LWCHAR)((char)(linebuf + curr)[0] & 0xFF);
#endif /* !SMALL */
a916 1
#if !SMALL
a921 1
#endif /* !SMALL */
d952 1
a952 3
	}
#if !SMALL
	else if (utf_mode && ctldisp != OPT_ON && is_ubin_char(ch))
d964 1
a964 3
 	}
#endif /* !SMALL */
	else
a978 1
#if !SMALL
a984 1
#endif /* !SMALL */
d1217 2
d1231 4
a1235 1
			memmove(linebuf + n, linebuf, old_size_linebuf);
@


