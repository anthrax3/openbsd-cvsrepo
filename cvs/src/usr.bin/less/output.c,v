head	1.17;
access;
symbols
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.8.0.10
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.6
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.5.0.34
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.32
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.30
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	OpenBSD_1_2:1.2
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	W32EN7Zp77efb8wW;

1.16
date	2016.01.26.01.51.06;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	srJYJwfAmHQyrX7w;

1.15
date	2016.01.13.22.47.45;	author mmcc;	state Exp;
branches;
next	1.14;
commitid	Uz3YEYZCcKwdp847;

1.14
date	2016.01.12.17.48.04;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	O36S2Tb0ReI34f9s;

1.13
date	2015.11.13.16.48.48;	author nicm;	state Exp;
branches;
next	1.12;
commitid	1UhnxVLYjgAT43E3;

1.12
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.11;
commitid	QKrr6AuGzNx9nehL;

1.11
date	2015.11.05.22.47.33;	author tedu;	state Exp;
branches;
next	1.10;
commitid	vLFUUyhjlRQmhpMd;

1.10
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.9;
commitid	yKv9Ck9ZDgwWTRTo;

1.9
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.8;

1.8
date	2012.05.17.18.00.19;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2011.09.21.19.01.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.01.58.03;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.09.21.06.06.41;	author etheisen;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.07;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.50;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.17
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * High level routines dealing with the output to the screen.
 */

#include "less.h"

int errmsgs;	/* Count of messages displayed by error() */

extern volatile sig_atomic_t sigs;
extern int sc_width;
extern int so_s_width, so_e_width;
extern int screen_trashed;
extern int any_display;
extern int is_tty;
extern int oldbot;

static int need_clr;

/*
 * Display the line which is in the line buffer.
 */
void
put_line(void)
{
	int c;
	int i;
	int a;

	if (ABORT_SIGS()) {
		/*
		 * Don't output if a signal is pending.
		 */
		screen_trashed = 1;
		return;
	}

	for (i = 0; (c = gline(i, &a)) != '\0'; i++) {
		at_switch(a);
		if (c == '\b')
			putbs();
		else
			(void) putchr(c);
	}

	at_exit();
}

static char obuf[OUTBUF_SIZE];
static char *ob = obuf;

/*
 * Flush buffered output.
 *
 * If we haven't displayed any file data yet,
 * output messages on error output (file descriptor 2),
 * otherwise output on standard output (file descriptor 1).
 *
 * This has the desirable effect of producing all
 * error messages on error output if standard output
 * is directed to a file.  It also does the same if
 * we never produce any real output; for example, if
 * the input file(s) cannot be opened.  If we do
 * eventually produce output, code in edit() makes
 * sure these messages can be seen before they are
 * overwritten or scrolled away.
 */
void
flush(int ignore_errors)
{
	int n;
	int fd;
	ssize_t nwritten;

	n = (intptr_t)ob - (intptr_t)obuf;
	if (n == 0)
		return;

	fd = (any_display) ? STDOUT_FILENO : STDERR_FILENO;
	nwritten = write(fd, obuf, n);
	if (nwritten != n) {
		if (nwritten == -1 && !ignore_errors)
			quit(QUIT_ERROR);
		screen_trashed = 1;
	}
	ob = obuf;
}

/*
 * Output a character.
 */
int
putchr(int c)
{
	if (need_clr) {
		need_clr = 0;
		clear_bot();
	}
	/*
	 * Some versions of flush() write to *ob, so we must flush
	 * when we are still one char from the end of obuf.
	 */
	if (ob >= &obuf[sizeof (obuf)-1])
		flush(0);
	*ob++ = (char)c;
	return (c);
}

/*
 * Output a string.
 */
void
putstr(const char *s)
{
	while (*s != '\0')
		(void) putchr(*s++);
}


/*
 * Convert an integral type to a string.
 */
#define	TYPE_TO_A_FUNC(funcname, type)		\
void						\
funcname(type num, char *buf, size_t len)	\
{						\
	int neg = (num < 0);			\
	char tbuf[23];	\
	char *s = tbuf + sizeof (tbuf);		\
	if (neg)				\
		num = -num;			\
	*--s = '\0';				\
	do {					\
		*--s = (num % 10) + '0';	\
	} while ((num /= 10) != 0);		\
	if (neg)				\
		 *--s = '-';			\
	(void) strlcpy(buf, s, len);		\
}

TYPE_TO_A_FUNC(postoa, off_t)
TYPE_TO_A_FUNC(inttoa, int)

/*
 * Output an integer in a given radix.
 */
static int
iprint_int(int num)
{
	char buf[11];

	inttoa(num, buf, sizeof (buf));
	putstr(buf);
	return (strlen(buf));
}

/*
 * Output a line number in a given radix.
 */
static int
iprint_linenum(off_t num)
{
	char buf[21];

	postoa(num, buf, sizeof(buf));
	putstr(buf);
	return (strlen(buf));
}

/*
 * This function implements printf-like functionality
 * using a more portable argument list mechanism than printf's.
 */
static int
less_printf(const char *fmt, PARG *parg)
{
	char *s;
	int col;

	col = 0;
	while (*fmt != '\0') {
		if (*fmt != '%') {
			(void) putchr(*fmt++);
			col++;
		} else {
			++fmt;
			switch (*fmt++) {
			case 's':
				s = parg->p_string;
				parg++;
				while (*s != '\0') {
					(void) putchr(*s++);
					col++;
				}
				break;
			case 'd':
				col += iprint_int(parg->p_int);
				parg++;
				break;
			case 'n':
				col += iprint_linenum(parg->p_linenum);
				parg++;
				break;
			}
		}
	}
	return (col);
}

/*
 * Get a RETURN.
 * If some other non-trivial char is pressed, unget it, so it will
 * become the next command.
 */
void
get_return(void)
{
	int c;

	c = getchr();
	if (c != '\n' && c != '\r' && c != ' ' && c != READ_INTR)
		ungetcc(c);
}

/*
 * Output a message in the lower left corner of the screen
 * and wait for carriage return.
 */
void
error(const char *fmt, PARG *parg)
{
	int col = 0;
	static char return_to_continue[] = "  (press RETURN)";

	errmsgs++;

	if (any_display && is_tty) {
		if (!oldbot)
			squish_check();
		at_exit();
		clear_bot();
		at_enter(AT_STANDOUT);
		col += so_s_width;
	}

	col += less_printf(fmt, parg);

	if (!(any_display && is_tty)) {
		(void) putchr('\n');
		return;
	}

	putstr(return_to_continue);
	at_exit();
	col += sizeof (return_to_continue) + so_e_width;

	get_return();
	lower_left();
	clear_eol();

	if (col >= sc_width)
		/*
		 * Printing the message has probably scrolled the screen.
		 * {{ Unless the terminal doesn't have auto margins,
		 *    in which case we just hammered on the right margin. }}
		 */
		screen_trashed = 1;

	flush(0);
}

static char intr_to_abort[] = "... (interrupt to abort)";

/*
 * Output a message in the lower left corner of the screen
 * and don't wait for carriage return.
 * Usually used to warn that we are beginning a potentially
 * time-consuming operation.
 */
void
ierror(const char *fmt, PARG *parg)
{
	at_exit();
	clear_bot();
	at_enter(AT_STANDOUT);
	(void) less_printf(fmt, parg);
	putstr(intr_to_abort);
	at_exit();
	flush(0);
	need_clr = 1;
}

/*
 * Output a message in the lower left corner of the screen
 * and return a single-character response.
 */
int
query(const char *fmt, PARG *parg)
{
	int c;
	int col = 0;

	if (any_display && is_tty)
		clear_bot();

	(void) less_printf(fmt, parg);
	c = getchr();

	if (!(any_display && is_tty)) {
		(void) putchr('\n');
		return (c);
	}

	lower_left();
	if (col >= sc_width)
		screen_trashed = 1;
	flush(0);

	return (c);
}
@


1.16
log
@Remove a fancy macro that calculates the necessary buffer size for
int-to-str conversions and just use constants instead. The only binary
change is caused by using an unnecessarily large buffer for an int. This
is a consequence of simplifying some code that will be gone soon.

ok nicm@@
@
text
@d48 1
a48 1
	for (i = 0;  (c = gline(i, &a)) != '\0';  i++) {
@


1.15
log
@unify two identical function pairs now that we've removed less's off_t
aliases

ok nicm@@
@
text
@d138 1
a138 1
	char tbuf[INT_STRLEN_BOUND(num)+2];	\
d160 1
a160 1
	char buf[INT_STRLEN_BOUND(num)];
d173 1
a173 1
	char buf[INT_STRLEN_BOUND(num)];
@


1.14
log
@Remove LINUNUM, a needless alias for off_t. Also, remove a redundant
condition.

ok nicm@@
@
text
@a151 1
TYPE_TO_A_FUNC(linenumtoa, off_t)
d175 1
a175 1
	linenumtoa(num, buf, sizeof (buf));
@


1.13
log
@Add a flag argument to flush() to stop it calling quit() on error, then
use this from quit() to stop less blowing up the stack looping through
quit()/flush() if stderr is closed (for example "less /missing
2</dev/null"). ok millert
@
text
@d152 1
a152 1
TYPE_TO_A_FUNC(linenumtoa, LINENUM)
d172 1
a172 1
iprint_linenum(LINENUM num)
@


1.12
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d79 1
a79 1
flush(void)
d92 1
a92 1
		if (nwritten == -1)
d114 1
a114 1
		flush();
d280 1
a280 1
	flush();
d300 1
a300 1
	flush();
d328 1
a328 1
	flush();
@


1.11
log
@deregister
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.10
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d190 2
a191 2
	register char *s;
	register int col;
d313 1
a313 1
	register int c;
@


1.9
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

d19 2
a20 8
#if MSDOS_COMPILER==WIN32C
#include "windows.h"
#endif

public int errmsgs;	/* Count of messages displayed by error() */
public int need_clr;
public int final_attr;
public int at_prompt;
d30 1
a30 8
#if MSDOS_COMPILER==WIN32C || MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
extern int ctldisp;
extern int nm_fg_color, nm_bg_color;
extern int bo_fg_color, bo_bg_color;
extern int ul_fg_color, ul_bg_color;
extern int so_fg_color, so_bg_color;
extern int bl_fg_color, bl_bg_color;
#endif
d35 2
a36 2
	public void
put_line()
d38 2
a39 2
	register int c;
	register int i;
d42 1
a42 2
	if (ABORT_SIGS())
	{
d50 1
a50 4
	final_attr = AT_NORMAL;

	for (i = 0;  (c = gline(i, &a)) != '\0';  i++)
	{
a51 1
		final_attr = a;
d55 1
a55 1
			putchr(c);
d80 2
a81 2
	public void
flush()
d83 2
a84 2
	register int n;
	register int fd;
d87 1
a87 1
	n = ob - obuf;
a90 215
#if MSDOS_COMPILER==MSOFTC
	if (is_tty && any_display)
	{
		*ob = '\0';
		_outtext(obuf);
		ob = obuf;
		return;
	}
#else
#if MSDOS_COMPILER==WIN32C || MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
	if (is_tty && any_display)
	{
		*ob = '\0';
		if (ctldisp != OPT_ONPLUS)
			WIN32textout(obuf, ob - obuf);
		else
		{
			/*
			 * Look for SGR escape sequences, and convert them
			 * to color commands.  Replace bold, underline,
			 * and italic escapes into colors specified via
			 * the -D command-line option.
			 */
			char *anchor, *p, *p_next;
			unsigned char fg, bg;
			static unsigned char at;
#if MSDOS_COMPILER==WIN32C
			/* Screen colors used by 3x and 4x SGR commands. */
			static unsigned char screen_color[] = {
				0, /* BLACK */
				FOREGROUND_RED,
				FOREGROUND_GREEN,
				FOREGROUND_RED|FOREGROUND_GREEN,
				FOREGROUND_BLUE, 
				FOREGROUND_BLUE|FOREGROUND_RED,
				FOREGROUND_BLUE|FOREGROUND_GREEN,
				FOREGROUND_BLUE|FOREGROUND_GREEN|FOREGROUND_RED
			};
#else
			static enum COLORS screen_color[] = {
				BLACK, RED, GREEN, BROWN,
				BLUE, MAGENTA, CYAN, LIGHTGRAY
			};
#endif

			for (anchor = p_next = obuf;
			     (p_next = memchr(p_next, ESC, ob - p_next)) != NULL; )
			{
				p = p_next;
				if (p[1] == '[')  /* "ESC-[" sequence */
				{
					if (p > anchor)
					{
						/*
						 * If some chars seen since
						 * the last escape sequence,
						 * write them out to the screen.
						 */
						WIN32textout(anchor, p-anchor);
						anchor = p;
					}
					p += 2;  /* Skip the "ESC-[" */
					if (is_ansi_end(*p))
					{
						/*
						 * Handle null escape sequence
						 * "ESC[m", which restores
						 * the normal color.
						 */
						p++;
						anchor = p_next = p;
						at = 0;
						WIN32setcolors(nm_fg_color, nm_bg_color);
						continue;
					}
					p_next = p;

					/*
					 * Select foreground/background colors
					 * based on the escape sequence. 
					 */
					fg = nm_fg_color;
					bg = nm_bg_color;
					while (!is_ansi_end(*p))
					{
						char *q;
						long code = strtol(p, &q, 10);

						if (*q == '\0')
						{
							/*
							 * Incomplete sequence.
							 * Leave it unprocessed
							 * in the buffer.
							 */
							int slop = q - anchor;
							/* {{ strlcpy args overlap! }} */
							strlcpy(obuf, anchor,
							    sizeof(obuf));
							ob = &obuf[slop];
							return;
						}

						if (q == p ||
						    code > 49 || code < 0 ||
						    (!is_ansi_end(*q) && *q != ';'))
						{
							p_next = q;
							break;
						}
						if (*q == ';')
							q++;

						switch (code)
						{
						default:
						/* case 0: all attrs off */
							fg = nm_fg_color;
							bg = nm_bg_color;
							at = 0;
							break;
						case 1:	/* bold on */
							at |= 1;
							break;
						case 3:	/* italic on */
						case 7: /* inverse on */
							at |= 2;
							break;
						case 4:	/* underline on */
							at |= 4;
							break;
						case 5: /* slow blink on */
						case 6: /* fast blink on */
							at |= 8;
							break;
						case 8:	/* concealed on */
							fg = (bg & 7) | 8;
							break;
						case 22: /* bold off */
							at &= ~1;
							break;
						case 23: /* italic off */
						case 27: /* inverse off */
							at &= ~2;
							break;
						case 24: /* underline off */
							at &= ~4;
							break;
						case 30: case 31: case 32:
						case 33: case 34: case 35:
						case 36: case 37:
							fg = (fg & 8) | (screen_color[code - 30]);
							break;
						case 39: /* default fg */
							fg = nm_fg_color;
							break;
						case 40: case 41: case 42:
						case 43: case 44: case 45:
						case 46: case 47:
							bg = (bg & 8) | (screen_color[code - 40]);
							break;
						case 49: /* default fg */
							bg = nm_bg_color;
							break;
						}
						p = q;
					}
					if (!is_ansi_end(*p) || p == p_next)
						break;
					if (at & 1)
					{
						/*
						 * If \e[1m use defined bold
						 * color, else set intensity.
						 */
						if (p[-2] == '[')
						{
#if MSDOS_COMPILER==WIN32C
							fg |= FOREGROUND_INTENSITY;
							bg |= BACKGROUND_INTENSITY;
#else
							fg = bo_fg_color;
							bg = bo_bg_color;
#endif
						} else
							fg |= 8;
					} else if (at & 2)
					{
						fg = so_fg_color;
						bg = so_bg_color;
					} else if (at & 4)
					{
						fg = ul_fg_color;
						bg = ul_bg_color;
					} else if (at & 8)
					{
						fg = bl_fg_color;
						bg = bl_bg_color;
					}
					fg &= 0xf;
					bg &= 0xf;
					WIN32setcolors(fg, bg);
					p_next = anchor = p + 1;
				} else
					p_next++;
			}

			/* Output what's left in the buffer.  */
			WIN32textout(anchor, ob - anchor);
		}
		ob = obuf;
		return;
	}
#endif
#endif
d104 2
a105 3
	public int
putchr(c)
	int c;
d107 1
a107 21
#if 0 /* fake UTF-8 output for testing */
	extern int utf_mode;
	if (utf_mode)
	{
		static char ubuf[MAX_UTF_CHAR_LEN];
		static int ubuf_len = 0;
		static int ubuf_index = 0;
		if (ubuf_len == 0)
		{
			ubuf_len = utf_len(c);
			ubuf_index = 0;
		}
		ubuf[ubuf_index++] = c;
		if (ubuf_index < ubuf_len)
			return c;
		c = get_wchar(ubuf) & 0xFF;
		ubuf_len = 0;
	}
#endif
	if (need_clr)
	{
a110 12
#if MSDOS_COMPILER
	if (c == '\n' && is_tty)
	{
		/* remove_top(1); */
		putchr('\r');
	}
#else
#ifdef _OSK
	if (c == '\n' && is_tty)  /* In OS-9, '\n' == 0x0D */
		putchr(0x0A);
#endif
#endif
d115 1
a115 1
	if (ob >= &obuf[sizeof(obuf)-1])
d117 1
a117 2
	*ob++ = c;
	at_prompt = 0;
d124 2
a125 3
	public void
putstr(s)
	register char *s;
d128 1
a128 1
		putchr(*s++);
d135 16
a150 16
#define TYPE_TO_A_FUNC(funcname, type) \
void funcname(num, buf, len) \
	type num; \
	char *buf; \
	size_t len; \
{ \
	int neg = (num < 0); \
	char tbuf[INT_STRLEN_BOUND(num)+2]; \
	register char *s = tbuf + sizeof(tbuf); \
	if (neg) num = -num; \
	*--s = '\0'; \
	do { \
		*--s = (num % 10) + '0'; \
	} while ((num /= 10) != 0); \
	if (neg) *--s = '-'; \
	strlcpy(buf, s, len); \
d153 1
a153 1
TYPE_TO_A_FUNC(postoa, POSITION)
d160 2
a161 3
	static int
iprint_int(num)
	int num;
d165 1
a165 1
	inttoa(num, buf, sizeof(buf));
d173 2
a174 3
	static int
iprint_linenum(num)
	LINENUM num;
d178 1
a178 1
	linenumtoa(num, buf, sizeof(buf));
d187 2
a188 4
	static int
less_printf(fmt, parg)
	register char *fmt;
	PARG *parg;
d194 3
a196 5
	while (*fmt != '\0')
	{
		if (*fmt != '%')
		{
			putchr(*fmt++);
d198 1
a198 2
		} else
		{
d200 1
a200 2
			switch (*fmt++)
			{
d204 2
a205 3
				while (*s != '\0')
				{
					putchr(*s++);
d228 2
a229 2
	public void
get_return()
a232 4
#if ONLY_RETURN
	while ((c = getchr()) != '\n' && c != '\r')
		bell();
#else
a235 1
#endif
d242 2
a243 4
	public void
error(fmt, parg)
	char *fmt;
	PARG *parg;
d250 1
a250 2
	if (any_display && is_tty)
	{
d261 2
a262 3
	if (!(any_display && is_tty))
	{
		putchr('\n');
d268 1
a268 1
	col += sizeof(return_to_continue) + so_e_width;
d272 1
a272 1
    clear_eol();
d293 2
a294 4
	public void
ierror(fmt, parg)
	char *fmt;
	PARG *parg;
d310 2
a311 4
	public int
query(fmt, parg)
	char *fmt;
	PARG *parg;
d322 2
a323 3
	if (!(any_display && is_tty))
	{
		putchr('\n');
@


1.8
log
@Quit if write(2) returns -1 when writing to the tty, which can
happen if the tty is revoked.  OK deraadt@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d177 1
d277 10
d289 3
d294 2
a295 2
							fg = so_fg_color;
							bg = so_bg_color;
d298 2
a299 2
							fg = ul_fg_color;
							bg = ul_bg_color;
d302 2
a303 2
							fg = bl_fg_color;
							bg = bl_bg_color;
@


1.7
log
@Use volatile sig_atomic_t, not int, for the sigs variable.  Also
move the call to bell() out of u_interrupt() (a signal handler).
OK and with help from deraadt@@
@
text
@d101 1
d309 4
a312 1
	if (write(fd, obuf, n) != n)
d314 1
@


1.6
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d26 1
a26 1
extern int sigs;
@


1.5
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d24 1
d32 1
d34 1
a34 1
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
a51 1
	int curr_attr;
d62 1
a62 1
	curr_attr = AT_NORMAL;
d66 2
a67 25
		if (a != curr_attr)
		{
			/*
			 * Changing attributes.
			 * Display the exit sequence for the old attribute
			 * and the enter sequence for the new one.
			 */
			switch (curr_attr)
			{
			case AT_UNDERLINE:	ul_exit();	break;
			case AT_BOLD:		bo_exit();	break;
			case AT_BLINK:		bl_exit();	break;
			case AT_STANDOUT:	so_exit();	break;
			}
			switch (a)
			{
			case AT_UNDERLINE:	ul_enter();	break;
			case AT_BOLD:		bo_enter();	break;
			case AT_BLINK:		bl_enter();	break;
			case AT_STANDOUT:	so_enter();	break;
			}
			curr_attr = a;
		}
		if (curr_attr == AT_INVIS)
			continue;
d74 1
a74 8
	switch (curr_attr)
	{
	case AT_UNDERLINE:	ul_exit();	break;
	case AT_BOLD:		bo_exit();	break;
	case AT_BLINK:		bl_exit();	break;
	case AT_STANDOUT:	so_exit();	break;
	}
	final_attr = curr_attr;
a104 10
#if MSDOS_COMPILER==WIN32C
	if (is_tty && any_display)
	{
		char *op;
		DWORD nwritten = 0;
		CONSOLE_SCREEN_BUFFER_INFO scr;
		int row;
		int col;
		int olen;
		extern HANDLE con_out;
a105 36
		olen = ob - obuf;
		/*
		 * There is a bug in Win32 WriteConsole() if we're
		 * writing in the last cell with a different color.
		 * To avoid color problems in the bottom line,
		 * we scroll the screen manually, before writing.
		 */
		GetConsoleScreenBufferInfo(con_out, &scr);
		col = scr.dwCursorPosition.X;
		row = scr.dwCursorPosition.Y;
		for (op = obuf;  op < obuf + olen;  op++)
		{
			if (*op == '\n')
			{
				col = 0;
				row++;
			} else if (*op == '\r')
			{
				col = 0;
			} else
			{
				col++;
				if (col >= sc_width)
				{
					col = 0;
					row++;
				}
			}
		}
		if (row > scr.srWindow.Bottom)
			win32_scroll_up(row - scr.srWindow.Bottom);
		WriteConsole(con_out, obuf, olen, &nwritten, NULL);
		ob = obuf;
		return;
	}
#else
d115 1
a115 1
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
d120 1
a120 1
			cputs(obuf);
d130 15
a144 6
			int buflen = ob - obuf;
			unsigned char fg, bg, norm_attr;
			/*
			 * Only dark colors mentioned here, so that
			 * bold has visible effect.
			 */
d149 1
a150 4
			/* Normal text colors are used as baseline. */
			bg = nm_bg_color & 0xf;
			fg = nm_fg_color & 0xf;
			norm_attr = (bg << 4) | fg;
d152 1
a152 3
			     (p_next = memchr (p_next, ESC,
					       buflen - (p_next - obuf)))
			       != NULL; )
d155 1
a155 7

				/*
				 * Handle the null escape sequence
				 * (ESC-[m), which is used to restore
				 * the original color.
				 */
				if (p[1] == '[' && is_ansi_end(p[2]))
a156 14
					textattr(norm_attr);
					p += 3;
					anchor = p_next = p;
					continue;
				}

				if (p[1] == '[')	/* "Esc-[" sequence */
				{
					/*
					 * If some chars seen since
					 * the last escape sequence,
					 * write it out to the screen
					 * using current text attributes.
					 */
d159 6
a164 3
						*p = '\0';
						cputs (anchor);
						*p = ESC;
d167 13
a179 1
					p += 2;
d181 7
d193 1
a193 1
						if (!*q)
d201 1
d208 3
a210 4
						if (q == p
						    || code > 49 || code < 0
						    || (!is_ansi_end(*q)
							&& *q != ';'))
d220 6
d227 1
a227 2
							fg = bo_fg_color;
							bg = bo_bg_color;
d230 2
a231 2
							fg = so_fg_color;
							bg = so_bg_color;
d234 5
a238 2
							fg = ul_fg_color;
							bg = ul_bg_color;
d243 9
a251 6
						case 0:	/* all attrs off */
						case 22:/* bold off */
						case 23:/* italic off */
						case 24:/* underline off */
							fg = nm_fg_color;
							bg = nm_bg_color;
d272 15
a286 1
					if (is_ansi_end(*p) && p > p_next)
d288 7
a294 6
						bg &= 15;
						fg &= 15;
						textattr ((bg << 4)| fg);
						p_next = anchor = p + 1;
					} else
						break;
d300 1
a300 1
			cputs (anchor);
d307 1
a307 2
#endif
	fd = (any_display) ? 1 : 2;
d320 19
d363 1
a493 2
	if (c == 'q')
		quit(QUIT_OK);
d515 3
d519 1
a519 1
		so_enter();
d532 1
a532 1
	so_exit();
d537 1
d563 1
d565 1
a565 1
	so_enter();
d568 1
a568 1
	so_exit();
@


1.4
log
@kill more registers

millert@@ ok
@
text
@a0 2
/*	$OpenBSD: output.c,v 1.3 2001/01/29 01:58:03 niklas Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d17 3
d23 1
d30 10
d47 2
a48 2
	int c;
	int i;
d103 1
d106 1
a106 1
static char obuf[1024];
d128 2
a129 2
	int n;
	int fd;
a130 5
#if MSOFTC
	*ob = '\0';
	_outtext(obuf);
	ob = obuf;
#else
d134 217
a354 1
#endif
a363 2
	if (ob >= &obuf[sizeof(obuf)])
		flush();
d369 4
a372 2
#if MSOFTC
	if (c == '\n')
d374 5
d380 7
d396 1
a396 1
	char *s;
d404 25
d432 1
a432 1
iprintnum(num, radix)
a433 1
	int radix;
d435 1
a435 4
	char *s;
	int r;
	int neg;
	char buf[10];
d437 4
a440 2
	if (neg = (num < 0))
		num = -num;
d442 8
a449 9
	s = buf;
	do
	{
		*s++ = (num % radix) + '0';
	} while ((num /= radix) != 0);

	if (neg)
		*s++ = '-';
	r = s - buf;
d451 3
a453 3
	while (s > buf)
		putchr(*--s);
	return (r);
d461 2
a462 2
iprintf(fmt, parg)
	char *fmt;
d465 2
a466 3
	char *s;
	int n;
	int col;
d478 2
a479 1
			switch (*fmt++) {
d490 5
a494 1
				n = parg->p_int;
a495 1
				col += iprintnum(n, 10);
d504 22
a533 1
	int c;
d539 1
a539 1
	if (any_display)
d546 1
a546 1
	col += iprintf(fmt, parg);
d548 1
a548 1
	if (!any_display)
d558 1
a558 10
#if ONLY_RETURN
	while ((c = getchr()) != '\n' && c != '\r')
		bell();
#else
	c = getchr();
	if (c == 'q')
		quit(QUIT_OK);
	if (c != '\n' && c != '\r' && c != ' ' && c != READ_INTR)
		ungetcc(c);
#endif
d587 1
a587 1
	(void) iprintf(fmt, parg);
d603 1
a603 1
	int c;
d606 1
a606 1
	if (any_display)
d609 1
a609 1
	(void) iprintf(fmt, parg);
d612 1
a612 1
	if (!any_display)
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 2
a52 2
	register int c;
	register int i;
d131 2
a132 2
	register int n;
	register int fd;
d176 1
a176 1
	register char *s;
d191 1
a191 1
	register char *s;
d220 1
a220 1
	register char *fmt;
d223 3
a225 3
	register char *s;
	register int n;
	register int col;
d346 1
a346 1
	register int c;
@


1.2
log
@Incorporate less modifications for more and our bug fixes from previous
version.
@
text
@d1 2
@


1.1
log
@Initial revision
@
text
@d295 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
a32 3
#if MSDOS_COMPILER==WIN32C
#include "windows.h"
#endif
a35 1
public int final_attr;
a41 10
extern int is_tty;

#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
extern int ctldisp;
extern int nm_fg_color, nm_bg_color;
extern int bo_fg_color, bo_bg_color;
extern int ul_fg_color, ul_bg_color;
extern int so_fg_color, so_bg_color;
extern int bl_fg_color, bl_bg_color;
#endif
a104 1
	final_attr = curr_attr;
d107 1
a107 1
static char obuf[OUTBUF_SIZE];
d132 5
a139 216
#if MSDOS_COMPILER==WIN32C
	if (is_tty && any_display)
	{
		char *op;
		DWORD nwritten = 0;
		CONSOLE_SCREEN_BUFFER_INFO scr;
		int row;
		int col;
		int olen;
		extern HANDLE con_out;

		olen = ob - obuf;
		/*
		 * There is a bug in Win32 WriteConsole() if we're
		 * writing in the last cell with a different color.
		 * To avoid color problems in the bottom line,
		 * we scroll the screen manually, before writing.
		 */
		GetConsoleScreenBufferInfo(con_out, &scr);
		col = scr.dwCursorPosition.X;
		row = scr.dwCursorPosition.Y;
		for (op = obuf;  op < obuf + olen;  op++)
		{
			if (*op == '\n')
			{
				col = 0;
				row++;
			} else if (*op == '\r')
			{
				col = 0;
			} else
			{
				col++;
				if (col >= sc_width)
				{
					col = 0;
					row++;
				}
			}
		}
		if (row > scr.srWindow.Bottom)
			win32_scroll_up(row - scr.srWindow.Bottom);
		WriteConsole(con_out, obuf, olen, &nwritten, NULL);
		ob = obuf;
		return;
	}
#else
#if MSDOS_COMPILER==MSOFTC
	if (is_tty && any_display)
	{
		*ob = '\0';
		_outtext(obuf);
		ob = obuf;
		return;
	}
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
	if (is_tty && any_display)
	{
		*ob = '\0';
		if (ctldisp != OPT_ONPLUS)
			cputs(obuf);
		else
		{
			/*
			 * Look for SGR escape sequences, and convert them
			 * to color commands.  Replace bold, underline,
			 * and italic escapes into colors specified via
			 * the -D command-line option.
			 */
			char *anchor, *p, *p_next;
			int buflen = ob - obuf;
			unsigned char fg, bg, norm_attr;
			/*
			 * Only dark colors mentioned here, so that
			 * bold has visible effect.
			 */
			static enum COLORS screen_color[] = {
				BLACK, RED, GREEN, BROWN,
				BLUE, MAGENTA, CYAN, LIGHTGRAY
			};

			/* Normal text colors are used as baseline. */
			bg = nm_bg_color & 0xf;
			fg = nm_fg_color & 0xf;
			norm_attr = (bg << 4) | fg;
			for (anchor = p_next = obuf;
			     (p_next = memchr (p_next, ESC,
					       buflen - (p_next - obuf)))
			       != NULL; )
			{
				p = p_next;

				/*
				 * Handle the null escape sequence
				 * (ESC-[m), which is used to restore
				 * the original color.
				 */
				if (p[1] == '[' && is_ansi_end(p[2]))
				{
					textattr(norm_attr);
					p += 3;
					anchor = p_next = p;
					continue;
				}

				if (p[1] == '[')	/* "Esc-[" sequence */
				{
					/*
					 * If some chars seen since
					 * the last escape sequence,
					 * write it out to the screen
					 * using current text attributes.
					 */
					if (p > anchor)
					{
						*p = '\0';
						cputs (anchor);
						*p = ESC;
						anchor = p;
					}
					p += 2;
					p_next = p;
					while (!is_ansi_end(*p))
					{
						char *q;
						long code = strtol(p, &q, 10);

						if (!*q)
						{
							/*
							 * Incomplete sequence.
							 * Leave it unprocessed
							 * in the buffer.
							 */
							int slop = q - anchor;
							strcpy(obuf, anchor);
							ob = &obuf[slop];
							return;
						}

						if (q == p
						    || code > 49 || code < 0
						    || (!is_ansi_end(*q)
							&& *q != ';'))
						{
							p_next = q;
							break;
						}
						if (*q == ';')
							q++;

						switch (code)
						{
						case 1:	/* bold on */
							fg = bo_fg_color;
							bg = bo_bg_color;
							break;
						case 3:	/* italic on */
							fg = so_fg_color;
							bg = so_bg_color;
							break;
						case 4:	/* underline on */
							fg = ul_fg_color;
							bg = ul_bg_color;
							break;
						case 8:	/* concealed on */
							fg = (bg & 7) | 8;
							break;
						case 0:	/* all attrs off */
						case 22:/* bold off */
						case 23:/* italic off */
						case 24:/* underline off */
							fg = nm_fg_color;
							bg = nm_bg_color;
							break;
						case 30: case 31: case 32:
						case 33: case 34: case 35:
						case 36: case 37:
							fg = (fg & 8) | (screen_color[code - 30]);
							break;
						case 39: /* default fg */
							fg = nm_fg_color;
							break;
						case 40: case 41: case 42:
						case 43: case 44: case 45:
						case 46: case 47:
							bg = (bg & 8) | (screen_color[code - 40]);
							break;
						case 49: /* default fg */
							bg = nm_bg_color;
							break;
						}
						p = q;
					}
					if (is_ansi_end(*p) && p > p_next)
					{
						bg &= 15;
						fg &= 15;
						textattr ((bg << 4)| fg);
						p_next = anchor = p + 1;
					} else
						break;
				} else
					p_next++;
			}

			/* Output what's left in the buffer.  */
			cputs (anchor);
		}
		ob = obuf;
		return;
	}
#endif
#endif
#endif
d144 1
d154 2
d161 2
a162 4
#if MSDOS_COMPILER
	if (c == '\n' && is_tty)
	{
		/* remove_top(1); */
a163 6
	}
#else
#ifdef _OSK
	if (c == '\n' && is_tty)  /* In OS-9, '\n' == 0x0D */
		putchr(0x0A);
#endif
a164 6
	/*
	 * Some versions of flush() write to *ob, so we must flush
	 * when we are still one char from the end of obuf.
	 */
	if (ob >= &obuf[sizeof(obuf)-1])
		flush();
a181 24
 * Convert an integral type to a string.
 */
#define TYPE_TO_A_FUNC(funcname, type) \
void funcname(num, buf) \
	type num; \
	char *buf; \
{ \
	int neg = (num < 0); \
	char tbuf[INT_STRLEN_BOUND(num)+2]; \
	register char *s = tbuf + sizeof(tbuf); \
	if (neg) num = -num; \
	*--s = '\0'; \
	do { \
		*--s = (num % 10) + '0'; \
	} while ((num /= 10) != 0); \
	if (neg) *--s = '-'; \
	strcpy(buf, s); \
}

TYPE_TO_A_FUNC(postoa, POSITION)
TYPE_TO_A_FUNC(linenumtoa, LINENUM)
TYPE_TO_A_FUNC(inttoa, int)

/*
d185 1
a185 1
iprint_int(num)
d187 1
d189 21
a209 19
	char buf[INT_STRLEN_BOUND(num)];

	inttoa(num, buf);
	putstr(buf);
	return (strlen(buf));
}

/*
 * Output a line number in a given radix.
 */
	static int
iprint_linenum(num)
	LINENUM num;
{
	char buf[INT_STRLEN_BOUND(num)];

	linenumtoa(num, buf);
	putstr(buf);
	return (strlen(buf));
d217 1
a217 1
less_printf(fmt, parg)
d222 1
d235 1
a235 2
			switch (*fmt++)
			{
d246 1
a246 5
				col += iprint_int(parg->p_int);
				parg++;
				break;
			case 'n':
				col += iprint_linenum(parg->p_linenum);
d248 1
a256 20
 * Get a RETURN.
 * If some other non-trivial char is pressed, unget it, so it will
 * become the next command.
 */
	public void
get_return()
{
	int c;

#if ONLY_RETURN
	while ((c = getchr()) != '\n' && c != '\r')
		bell();
#else
	c = getchr();
	if (c != '\n' && c != '\r' && c != ' ' && c != READ_INTR)
		ungetcc(c);
#endif
}

/*
d265 1
d271 1
a271 1
	if (any_display && is_tty)
d278 1
a278 1
	col += less_printf(fmt, parg);
d280 1
a280 1
	if (!(any_display && is_tty))
d290 8
a297 1
	get_return();
d326 1
a326 1
	(void) less_printf(fmt, parg);
d345 1
a345 1
	if (any_display && is_tty)
d348 1
a348 1
	(void) less_printf(fmt, parg);
d351 1
a351 1
	if (!(any_display && is_tty))
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
a23 1
public int at_prompt;
a30 1
extern int oldbot;
d32 1
a32 1
#if MSDOS_COMPILER==WIN32C || MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
d50 1
d61 1
a61 1
	final_attr = AT_NORMAL;
d65 25
a89 2
		at_switch(a);
		final_attr = a;
d96 8
a103 1
	at_exit();
d134 10
d145 36
d190 1
a190 1
#if MSDOS_COMPILER==WIN32C || MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
d195 1
a195 1
			WIN32textout(obuf, ob - obuf);
d205 6
a210 15
			unsigned char fg, bg;
			static unsigned char at;
#if MSDOS_COMPILER==WIN32C
			/* Screen colors used by 3x and 4x SGR commands. */
			static unsigned char screen_color[] = {
				0, /* BLACK */
				FOREGROUND_RED,
				FOREGROUND_GREEN,
				FOREGROUND_RED|FOREGROUND_GREEN,
				FOREGROUND_BLUE, 
				FOREGROUND_BLUE|FOREGROUND_RED,
				FOREGROUND_BLUE|FOREGROUND_GREEN,
				FOREGROUND_BLUE|FOREGROUND_GREEN|FOREGROUND_RED
			};
#else
a214 1
#endif
d216 4
d221 3
a223 1
			     (p_next = memchr(p_next, ESC, ob - p_next)) != NULL; )
d226 7
a232 1
				if (p[1] == '[')  /* "ESC-[" sequence */
d234 14
d250 3
a252 6
						/*
						 * If some chars seen since
						 * the last escape sequence,
						 * write them out to the screen.
						 */
						WIN32textout(anchor, p-anchor);
d255 1
a255 13
					p += 2;  /* Skip the "ESC-[" */
					if (is_ansi_end(*p))
					{
						/*
						 * Handle null escape sequence
						 * "ESC[m", which restores
						 * the normal color.
						 */
						p++;
						anchor = p_next = p;
						WIN32setcolors(nm_fg_color, nm_bg_color);
						continue;
					}
a256 7

					/*
					 * Select foreground/background colors
					 * based on the escape sequence. 
					 */
					fg = nm_fg_color;
					bg = nm_bg_color;
d262 1
a262 1
						if (*q == '\0')
a269 1
							/* {{ strcpy args overlap! }} */
d275 4
a278 3
						if (q == p ||
						    code > 49 || code < 0 ||
						    (!is_ansi_end(*q) && *q != ';'))
a287 6
						default:
						/* case 0: all attrs off */
							fg = nm_fg_color;
							bg = nm_bg_color;
							at = 0;
							break;
d289 2
a290 1
							at |= 1;
d293 2
a294 2
						case 7: /* inverse on */
							at |= 2;
d297 2
a298 5
							at |= 4;
							break;
						case 5: /* slow blink on */
						case 6: /* fast blink on */
							at |= 8;
d303 6
a308 9
						case 22: /* bold off */
							at &= ~1;
							break;
						case 23: /* italic off */
						case 27: /* inverse off */
							at &= ~2;
							break;
						case 24: /* underline off */
							at &= ~4;
d329 7
a335 1
					if (!is_ansi_end(*p) || p == p_next)
a336 21
					if (at & 1)
					{
							fg = bo_fg_color;
							bg = bo_bg_color;
					} else if (at & 2)
					{
							fg = so_fg_color;
							bg = so_bg_color;
					} else if (at & 4)
					{
							fg = ul_fg_color;
							bg = ul_bg_color;
					} else if (at & 8)
					{
							fg = bl_fg_color;
							bg = bl_bg_color;
					}
					fg &= 0xf;
					bg &= 0xf;
					WIN32setcolors(fg, bg);
					p_next = anchor = p + 1;
d342 1
a342 1
			WIN32textout(anchor, ob - anchor);
d349 1
a362 19
#if 0 /* fake UTF-8 output for testing */
	extern int utf_mode;
	if (utf_mode)
	{
		static char ubuf[MAX_UTF_CHAR_LEN];
		static int ubuf_len = 0;
		static int ubuf_index = 0;
		if (ubuf_len == 0)
		{
			ubuf_len = utf_len(c);
			ubuf_index = 0;
		}
		ubuf[ubuf_index++] = c;
		if (ubuf_index < ubuf_len)
			return c;
		c = get_wchar(ubuf) & 0xFF;
		ubuf_len = 0;
	}
#endif
a386 1
	at_prompt = 0;
a536 3
		if (!oldbot)
			squish_check();
		at_exit();
d538 1
a538 1
		at_enter(AT_STANDOUT);
d551 1
a551 1
	at_exit();
a555 1
    clear_eol();
a580 1
	at_exit();
d582 1
a582 1
	at_enter(AT_STANDOUT);
d585 1
a585 1
	at_exit();
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d26 1
a26 1
extern volatile sig_atomic_t sigs;
a100 1
	ssize_t nwritten;
a176 1
						at = 0;
d201 2
a202 3
							/* {{ strlcpy args overlap! }} */
							strlcpy(obuf, anchor,
							    sizeof(obuf));
a274 10
						/*
						 * If \e[1m use defined bold
						 * color, else set intensity.
						 */
						if (p[-2] == '[')
						{
#if MSDOS_COMPILER==WIN32C
							fg |= FOREGROUND_INTENSITY;
							bg |= BACKGROUND_INTENSITY;
#else
a276 3
#endif
						} else
							fg |= 8;
d279 2
a280 2
						fg = so_fg_color;
						bg = so_bg_color;
d283 2
a284 2
						fg = ul_fg_color;
						bg = ul_bg_color;
d287 2
a288 2
						fg = bl_fg_color;
						bg = bl_bg_color;
d306 2
a307 5
	fd = (any_display) ? STDOUT_FILENO : STDERR_FILENO;
	nwritten = write(fd, obuf, n);
	if (nwritten != n) {
		if (nwritten == -1)
			quit(QUIT_ERROR);
a308 1
	}
d382 1
a382 1
void funcname(num, buf, len) \
a384 1
	size_t len; \
d395 1
a395 1
	strlcpy(buf, s, len); \
d411 1
a411 1
	inttoa(num, buf, sizeof(buf));
d425 1
a425 1
	linenumtoa(num, buf, sizeof(buf));
@


