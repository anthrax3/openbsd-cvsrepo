head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.6
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.6.0.12
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.8
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.4
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.26
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.28
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.24
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	W32EN7Zp77efb8wW;

1.11
date	2015.11.09.16.46.42;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	rJ6tmXbM6ZZSV1zd;

1.10
date	2015.11.07.18.07.44;	author tedu;	state Exp;
branches;
next	1.9;
commitid	DJUwzdj0cG1bCfEw;

1.9
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.8;
commitid	QKrr6AuGzNx9nehL;

1.8
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.7;
commitid	yKv9Ck9ZDgwWTRTo;

1.7
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.03.16.29.46;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.13.18.26.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.04;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.47;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.12
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * An IFILE represents an input file.
 *
 * It is actually a pointer to an ifile structure,
 * but is opaque outside this module.
 * Ifile structures are kept in a linked list in the order they
 * appear on the command line.
 * Any new file which does not already appear in the list is
 * inserted after the current file.
 */

#include "less.h"

extern IFILE	curr_ifile;

struct ifile {
	struct ifile *h_next;		/* Links for command line list */
	struct ifile *h_prev;
	char *h_filename;		/* Name of the file */
	void *h_filestate;		/* File state (used in ch.c) */
	int h_index;			/* Index within command line list */
	int h_hold;			/* Hold count */
	char h_opened;			/* Has this ifile been opened? */
	struct scrpos h_scrpos;		/* Saved position within the file */
};

/*
 * Convert an IFILE (external representation)
 * to a struct file (internal representation), and vice versa.
 */
#define	int_ifile(h)	((struct ifile *)(h))
#define	ext_ifile(h)	((IFILE)(h))

/*
 * Anchor for linked list.
 */
static struct ifile anchor = { &anchor, &anchor, NULL, NULL, 0, 0, '\0',
				{ -1, 0 } };
static int ifiles = 0;

static void
incr_index(struct ifile *p, int incr)
{
	for (; p != &anchor; p = p->h_next)
		p->h_index += incr;
}

/*
 * Link an ifile into the ifile list.
 */
static void
link_ifile(struct ifile *p, struct ifile *prev)
{
	/*
	 * Link into list.
	 */
	if (prev == NULL)
		prev = &anchor;
	p->h_next = prev->h_next;
	p->h_prev = prev;
	prev->h_next->h_prev = p;
	prev->h_next = p;
	/*
	 * Calculate index for the new one,
	 * and adjust the indexes for subsequent ifiles in the list.
	 */
	p->h_index = prev->h_index + 1;
	incr_index(p->h_next, 1);
	ifiles++;
}

/*
 * Unlink an ifile from the ifile list.
 */
static void
unlink_ifile(struct ifile *p)
{
	p->h_next->h_prev = p->h_prev;
	p->h_prev->h_next = p->h_next;
	incr_index(p->h_next, -1);
	ifiles--;
}

/*
 * Allocate a new ifile structure and stick a filename in it.
 * It should go after "prev" in the list
 * (or at the beginning of the list if "prev" is NULL).
 * Return a pointer to the new ifile structure.
 */
static struct ifile *
new_ifile(char *filename, struct ifile *prev)
{
	struct ifile *p;

	/*
	 * Allocate and initialize structure.
	 */
	p = ecalloc(1, sizeof (struct ifile));
	p->h_filename = estrdup(filename);
	p->h_scrpos.pos = -1;
	p->h_opened = 0;
	p->h_hold = 0;
	p->h_filestate = NULL;
	link_ifile(p, prev);
	return (p);
}

/*
 * Delete an existing ifile structure.
 */
void
del_ifile(IFILE h)
{
	struct ifile *p;

	if (h == NULL)
		return;
	/*
	 * If the ifile we're deleting is the currently open ifile,
	 * move off it.
	 */
	unmark(h);
	if (h == curr_ifile)
		curr_ifile = getoff_ifile(curr_ifile);
	p = int_ifile(h);
	unlink_ifile(p);
	free(p->h_filename);
	free(p);
}

/*
 * Get the ifile after a given one in the list.
 */
IFILE
next_ifile(IFILE h)
{
	struct ifile *p;

	p = (h == NULL) ? &anchor : int_ifile(h);
	if (p->h_next == &anchor)
		return (NULL);
	return (ext_ifile(p->h_next));
}

/*
 * Get the ifile before a given one in the list.
 */
IFILE
prev_ifile(IFILE h)
{
	struct ifile *p;

	p = (h == NULL) ? &anchor : int_ifile(h);
	if (p->h_prev == &anchor)
		return (NULL);
	return (ext_ifile(p->h_prev));
}

/*
 * Return a different ifile from the given one.
 */
IFILE
getoff_ifile(IFILE ifile)
{
	IFILE newifile;

	if ((newifile = prev_ifile(ifile)) != NULL)
		return (newifile);
	if ((newifile = next_ifile(ifile)) != NULL)
		return (newifile);
	return (NULL);
}

/*
 * Return the number of ifiles.
 */
int
nifile(void)
{
	return (ifiles);
}

/*
 * Find an ifile structure, given a filename.
 */
static struct ifile *
find_ifile(const char *filename)
{
	struct ifile *p;

	for (p = anchor.h_next; p != &anchor; p = p->h_next)
		if (strcmp(filename, p->h_filename) == 0)
			return (p);
	return (NULL);
}

/*
 * Get the ifile associated with a filename.
 * If the filename has not been seen before,
 * insert the new ifile after "prev" in the list.
 */
IFILE
get_ifile(char *filename, IFILE prev)
{
	struct ifile *p;

	if ((p = find_ifile(filename)) == NULL)
		p = new_ifile(filename, int_ifile(prev));
	return (ext_ifile(p));
}

/*
 * Get the filename associated with a ifile.
 */
char *
get_filename(IFILE ifile)
{
	if (ifile == NULL)
		return (NULL);
	return (int_ifile(ifile)->h_filename);
}

/*
 * Get the index of the file associated with a ifile.
 */
int
get_index(IFILE ifile)
{
	return (int_ifile(ifile)->h_index);
}

/*
 * Save the file position to be associated with a given file.
 */
void
store_pos(IFILE ifile, struct scrpos *scrpos)
{
	int_ifile(ifile)->h_scrpos = *scrpos;
}

/*
 * Recall the file position associated with a file.
 * If no position has been associated with the file, return -1.
 */
void
get_pos(IFILE ifile, struct scrpos *scrpos)
{
	*scrpos = int_ifile(ifile)->h_scrpos;
}

/*
 * Mark the ifile as "opened".
 */
void
set_open(IFILE ifile)
{
	int_ifile(ifile)->h_opened = 1;
}

/*
 * Return whether the ifile has been opened previously.
 */
int
opened(IFILE ifile)
{
	return (int_ifile(ifile)->h_opened);
}

void
hold_ifile(IFILE ifile, int incr)
{
	int_ifile(ifile)->h_hold += incr;
}

int
held_ifile(IFILE ifile)
{
	return (int_ifile(ifile)->h_hold);
}

void *
get_filestate(IFILE ifile)
{
	return (int_ifile(ifile)->h_filestate);
}

void
set_filestate(IFILE ifile, void *filestate)
{
	int_ifile(ifile)->h_filestate = filestate;
}
@


1.11
log
@NULL_IFILE has no weird use patterns.  NULL is sufficient.
@
text
@d202 1
a202 1
	for (p = anchor.h_next;  p != &anchor;  p = p->h_next)
@


1.10
log
@replace save() with estrdup() and make estrdup() exit like all the other
ecalloc, etc. functions do.
ok mmcc nicm
@
text
@d127 1
a127 1
	if (h == NULL_IFILE)
d150 1
a150 1
	p = (h == NULL_IFILE) ? &anchor : int_ifile(h);
d152 1
a152 1
		return (NULL_IFILE);
d164 1
a164 1
	p = (h == NULL_IFILE) ? &anchor : int_ifile(h);
d166 1
a166 1
		return (NULL_IFILE);
d178 1
a178 1
	if ((newifile = prev_ifile(ifile)) != NULL_IFILE)
d180 1
a180 1
	if ((newifile = next_ifile(ifile)) != NULL_IFILE)
d182 1
a182 1
	return (NULL_IFILE);
@


1.9
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d110 1
a110 1
	p->h_filename = save(filename);
@


1.8
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.7
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

d19 1
a19 1
 * Ifile structures are kept in a linked list in the order they 
d44 2
a45 2
#define int_ifile(h)	((struct ifile *)(h))
#define ext_ifile(h)	((IFILE)(h))
d51 1
a51 1
				{ NULL_POSITION, 0 } };
d54 2
a55 4
	static void
incr_index(p, incr)
	register struct ifile *p;
	int incr;
d57 1
a57 1
	for (;  p != &anchor;  p = p->h_next)
d64 2
a65 4
	static void
link_ifile(p, prev)
	struct ifile *p;
	struct ifile *prev;
d84 1
a84 1
	
d88 2
a89 3
	static void
unlink_ifile(p)
	struct ifile *p;
d103 2
a104 4
	static struct ifile *
new_ifile(filename, prev)
	char *filename;
	struct ifile *prev;
d106 1
a106 1
	register struct ifile *p;
d111 1
a111 1
	p = (struct ifile *) ecalloc(1, sizeof(struct ifile));
d113 1
a113 1
	p->h_scrpos.pos = NULL_POSITION;
d124 2
a125 3
	public void
del_ifile(h)
	IFILE h;
d127 1
a127 1
	register struct ifile *p;
d147 2
a148 3
	public IFILE
next_ifile(h)
	IFILE h;
d150 1
a150 1
	register struct ifile *p;
d161 2
a162 3
	public IFILE
prev_ifile(h)
	IFILE h;
d164 1
a164 1
	register struct ifile *p;
d175 2
a176 3
	public IFILE
getoff_ifile(ifile)
	IFILE ifile;
d179 1
a179 1
	
d190 2
a191 2
	public int
nifile()
d199 2
a200 3
	static struct ifile *
find_ifile(filename)
	char *filename;
d202 1
a202 1
	register struct ifile *p;
d215 2
a216 4
	public IFILE
get_ifile(filename, prev)
	char *filename;
	IFILE prev;
d218 1
a218 1
	register struct ifile *p;
d228 2
a229 3
	public char *
get_filename(ifile)
	IFILE ifile;
d239 2
a240 3
	public int
get_index(ifile)
	IFILE ifile;
d242 1
a242 1
	return (int_ifile(ifile)->h_index); 
d248 2
a249 4
	public void
store_pos(ifile, scrpos)
	IFILE ifile;
	struct scrpos *scrpos;
d256 1
a256 1
 * If no position has been associated with the file, return NULL_POSITION.
d258 2
a259 4
	public void
get_pos(ifile, scrpos)
	IFILE ifile;
	struct scrpos *scrpos;
d267 2
a268 3
	public void
set_open(ifile)
	IFILE ifile;
d276 2
a277 3
	public int
opened(ifile)
	IFILE ifile;
d282 2
a283 4
	public void
hold_ifile(ifile, incr)
	IFILE ifile;
	int incr;
d288 2
a289 4
#if !SMALL
	public int
held_ifile(ifile)
	IFILE ifile;
a292 1
#endif /* !SMALL */
d294 2
a295 3
	public void *
get_filestate(ifile)
	IFILE ifile;
d300 2
a301 4
	public void
set_filestate(ifile, filestate)
	IFILE ifile;
	void *filestate;
a304 16

#if 0
	public void
if_dump()
{
	register struct ifile *p;

	for (p = anchor.h_next;  p != &anchor;  p = p->h_next)
	{
		printf("%x: %d. <%s> pos %d,%x\n", 
			p, p->h_index, p->h_filename, 
			p->h_scrpos.ln, p->h_scrpos.pos);
		ch_dump(p->h_filestate);
	}
}
#endif
@


1.6
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
@


1.5
log
@use SMALL_PROGRAM to knock out some code
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d310 1
a310 1
#ifndef SMALL_PROGRAM
d317 1
a317 1
#endif /* SMALL_PROGRAM */
@


1.4
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d310 1
d317 1
@


1.3
log
@kill more registers

millert@@ ok
@
text
@a0 2
/*	$OpenBSD: ifile.c,v 1.2 2001/01/29 01:58:02 niklas Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d33 2
a34 1
	int h_opened;			/* Only need one bit */
d48 2
a49 1
static struct ifile anchor = { &anchor, &anchor, 0 };
d54 1
a54 1
	struct ifile *p;
d61 3
d87 3
d111 1
a111 1
	struct ifile *p;
d120 2
d133 1
a133 1
	struct ifile *p;
d141 1
d157 1
a157 1
	struct ifile *p;
d172 1
a172 1
	struct ifile *p;
d212 1
a212 1
	struct ifile *p;
d230 1
a230 1
	struct ifile *p;
d302 15
d336 1
a336 1
	struct ifile *p;
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 1
a70 1
	register struct ifile *p;
d121 1
a121 1
	register struct ifile *p;
d141 1
a141 1
	register struct ifile *p;
d164 1
a164 1
	register struct ifile *p;
d179 1
a179 1
	register struct ifile *p;
d219 1
a219 1
	register struct ifile *p;
d237 1
a237 1
	register struct ifile *p;
d328 1
a328 1
	register struct ifile *p;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d49 1
a49 2
	int h_hold;			/* Hold count */
	char h_opened;			/* Has this ifile been opened? */
d63 1
a63 2
static struct ifile anchor = { &anchor, &anchor, NULL, NULL, 0, 0, '\0',
				{ NULL_POSITION, 0 } };
a74 3
/*
 * Link an ifile into the ifile list.
 */
a97 3
/*
 * Unlink an ifile from the ifile list.
 */
a127 2
	p->h_hold = 0;
	p->h_filestate = NULL;
a146 1
	unmark(h);
a304 15
}

	public void
hold_ifile(ifile, incr)
	IFILE ifile;
	int incr;
{
	int_ifile(ifile)->h_hold += incr;
}

	public int
held_ifile(ifile)
	IFILE ifile;
{
	return (int_ifile(ifile)->h_hold);
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
a309 1
#if !SMALL
a315 1
#endif /* !SMALL */
@


