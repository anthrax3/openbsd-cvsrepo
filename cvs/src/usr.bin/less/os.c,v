head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.11.0.8
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.10.0.12
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.8
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.6
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.4
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.7.0.34
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.32
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.30
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.26
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.28
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.24
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.22
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.20
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.18
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.16
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.14
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.8
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.6
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.03.16.15.36.26;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	P9ytq8HKajWPxZf9;

1.15
date	2015.11.13.16.48.48;	author nicm;	state Exp;
branches;
next	1.14;
commitid	1UhnxVLYjgAT43E3;

1.14
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.13;
commitid	QKrr6AuGzNx9nehL;

1.13
date	2015.11.06.15.09.07;	author tedu;	state Exp;
branches;
next	1.12;
commitid	z4qVin3ZEtVsatp2;

1.12
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.11;
commitid	yKv9Ck9ZDgwWTRTo;

1.11
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.10;

1.10
date	2011.09.21.19.01.49;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2011.09.21.18.45.16;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.07.03.35.19;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.13.09.09.32;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.01.58.03;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	99.02.20.19.00.39;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.07;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.49;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.16
log
@style(9) includes

ok nicm@@
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Operating system dependent routines.
 *
 * Most of the stuff in here is based on Unix, but an attempt
 * has been made to make things work on other operating systems.
 * This will sometimes result in a loss of functionality, unless
 * someone rewrites code specifically for the new operating system.
 *
 * The makefile provides defines to decide whether various
 * Unix features are present.
 */

#include <errno.h>
#include <signal.h>
#include <time.h>

#include "less.h"

extern volatile sig_atomic_t sigs;

/*
 * Like read() system call, but is deliberately interruptible.
 */
int
iread(int fd, unsigned char *buf, unsigned int len)
{
	int n;

start:
	flush(0);
	n = read(fd, buf, len);
	if (n < 0) {
		/*
		 * Certain values of errno indicate we should just retry the
		 * read.
		 */
		if (errno == EINTR)
			return (READ_INTR);
		if (errno == EAGAIN)
			goto start;
		return (-1);
	}
	return (n);
}

/*
 * errno_message: Return an error message based on the value of "errno".
 */
char *
errno_message(char *filename)
{
	return (easprintf("%s: %s", filename, strerror(errno)));
}

static off_t
muldiv(off_t val, off_t num, off_t den)
{
	double v = (((double)val) * num) / den;
	return ((off_t)(v + 0.5));
}

/*
 * Return the ratio of two off_t, as a percentage.
 * {{ Assumes a off_t is a long int. }}
 */
int
percentage(off_t num, off_t den)
{
	return ((int)muldiv(num, (off_t)100, den));
}

/*
 * Return the specified percentage of a off_t.
 */
off_t
percent_pos(off_t pos, int percent, long fraction)
{
	/*
	 * Change percent (parts per 100) to perden
	 * (parts per NUM_FRAC_DENOM).
	 */
	off_t perden = (percent * (NUM_FRAC_DENOM / 100)) + (fraction / 100);

	if (perden == 0)
		return (0);
	return (muldiv(pos, perden, (off_t)NUM_FRAC_DENOM));
}
@


1.15
log
@Add a flag argument to flush() to stop it calling quit() on error, then
use this from quit() to stop less blowing up the stack looping through
quit()/flush() if stderr is closed (for example "less /missing
2</dev/null"). ok millert
@
text
@d24 1
a24 1
#include "less.h"
d27 2
a28 1
#include <errno.h>
@


1.14
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d40 1
a40 1
	flush();
@


1.13
log
@time_t is not a long. remove incorrect abstraction around time().
ok nicm
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.12
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@a58 12
 * Return the current time.
 */
long
get_time(void)
{
	time_t t;

	(void) time(&t);
	return (t);
}

/*
@


1.11
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

a27 1
#if HAVE_TIME_H
a28 2
#endif
#if HAVE_ERRNO_H
a29 10
#endif
#if HAVE_VALUES_H
#include <values.h>
#endif

#if HAVE_TIME_T
#define time_type	time_t
#else
#define	time_type	long
#endif
d36 2
a37 5
	public int
iread(fd, buf, len)
	int fd;
	char *buf;
	unsigned int len;
d39 1
a39 1
	register int n;
a41 17
#if MSDOS_COMPILER==WIN32C
	if (ABORT_SIGS())
		return (READ_INTR);
#else
#if MSDOS_COMPILER && MSDOS_COMPILER != DJGPPC
	if (kbhit())
	{
		int c;
		
		c = getch();
		if (c == '\003')
			return (READ_INTR);
		ungetch(c);
	}
#endif
#endif

a42 17
#if MSDOS_COMPILER==DJGPPC
	if (isatty(fd))
	{
		/*
		 * Don't try reading from a TTY until a character is
		 * available, because that makes some background programs
		 * believe DOS is busy in a way that prevents those
		 * programs from working while "less" waits.
		 */
		fd_set readfds;

		FD_ZERO(&readfds);
		FD_SET(fd, &readfds);
		if (select(fd+1, &readfds, 0, 0, 0) == -1)
			return (-1);
	}
#endif
d44 1
a44 23
#if 1
	/*
	 * This is a kludge to workaround a problem on some systems
	 * where terminating a remote tty connection causes read() to
	 * start returning 0 forever, instead of -1.
	 */
	{
		extern int ignore_eoi;
		if (!ignore_eoi)
		{
			static int consecutive_nulls = 0;
			if (n == 0)
				consecutive_nulls++;
			else
				consecutive_nulls = 0;
			if (consecutive_nulls > 20)
				quit(QUIT_ERROR);
		}
	}
#endif
	if (n < 0)
	{
#if HAVE_ERRNO
d46 2
a47 1
		 * Certain values of errno indicate we should just retry the read.
a48 4
#if MUST_DEFINE_ERRNO
		extern int errno;
#endif
#ifdef EINTR
a50 2
#endif
#ifdef EAGAIN
a52 2
#endif
#endif
d61 2
a62 3
#if HAVE_TIME
	public long
get_time()
d64 1
a64 1
	time_type t;
d66 1
a66 1
	time(&t);
a68 25
#endif


#if !HAVE_STRERROR
/*
 * Local version of strerror, if not available from the system.
 */
	static char *
strerror(err)
	int err;
{
#if HAVE_SYS_ERRLIST
	static char buf[16];
	extern char *sys_errlist[];
	extern int sys_nerr;
  
	if (err < sys_nerr)
		return sys_errlist[err];
	snprintf(buf, sizeof(buf), "Error %d", err);
	return buf;
#else
	return ("cannot open");
#endif
}
#endif
d73 2
a74 3
	public char *
errno_message(filename)
	char *filename;
d76 1
a76 15
	register char *p;
	register char *m;
	size_t len;
#if HAVE_ERRNO
#if MUST_DEFINE_ERRNO
	extern int errno;
#endif
	p = strerror(errno);
#else
	p = "cannot open";
#endif
	len = strlen(filename) + strlen(p) + 3;
	m = (char *) ecalloc(len, sizeof(char));
	SNPRINTF2(m, len, "%s: %s", filename, p);
	return (m);
d79 2
a80 5
/* #define HAVE_FLOAT 0 */

	static POSITION
muldiv(val, num, den)
	POSITION val, num, den;
d82 2
a83 14
#if HAVE_FLOAT
	double v = (((double) val) * num) / den;
	return ((POSITION) (v + 0.5));
#else
	POSITION v = ((POSITION) val) * num;

	if (v / num == val)
		/* No overflow */
		return (POSITION) (v / den);
	else
		/* Above calculation overflows; 
		 * use a method that is less precise but won't overflow. */
		return (POSITION) (val / (den / num));
#endif
d87 2
a88 2
 * Return the ratio of two POSITIONS, as a percentage.
 * {{ Assumes a POSITION is a long int. }}
d90 2
a91 3
	public int
percentage(num, den)
	POSITION num, den;
d93 1
a93 1
	return (int) muldiv(num,  (POSITION) 100, den);
d97 1
a97 1
 * Return the specified percentage of a POSITION.
d99 2
a100 5
	public POSITION
percent_pos(pos, percent, fraction)
	POSITION pos;
	int percent;
	long fraction;
d102 5
a106 2
	/* Change percent (parts per 100) to perden (parts per NUM_FRAC_DENOM). */
	POSITION perden = (percent * (NUM_FRAC_DENOM / 100)) + (fraction / 100);
d110 1
a110 62
	return (POSITION) muldiv(pos, perden, (POSITION) NUM_FRAC_DENOM);
}

#if !HAVE_STRCHR
/*
 * strchr is used by regexp.c.
 */
	char *
strchr(s, c)
	char *s;
	int c;
{
	for ( ;  *s != '\0';  s++)
		if (*s == c)
			return (s);
	if (c == '\0')
		return (s);
	return (NULL);
}
#endif

#if !HAVE_MEMCPY
	VOID_POINTER
memcpy(dst, src, len)
	VOID_POINTER dst;
	VOID_POINTER src;
	int len;
{
	char *dstp = (char *) dst;
	char *srcp = (char *) src;
	int i;

	for (i = 0;  i < len;  i++)
		dstp[i] = srcp[i];
	return (dst);
}
#endif

#ifdef _OSK_MWC32

/*
 * This implements an ANSI-style intercept setup for Microware C 3.2
 */
	public int 
os9_signal(type, handler)
	int type;
	RETSIGTYPE (*handler)();
{
	intercept(handler);
}

#include <sgstat.h>

	int 
isatty(f)
	int f;
{
	struct sgbuf sgbuf;

	if (_gs_opt(f, &sgbuf) < 0)
		return -1;
	return (sgbuf.sg_class == 0);
a111 2
	
#endif
@


1.10
log
@Use volatile sig_atomic_t, not int, for the sigs variable.  Also
move the call to bell() out of u_interrupt() (a signal handler).
OK and with help from deraadt@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
@


1.9
log
@Repair interrupted reads; fixes ^Z.  OK deraadt@@
@
text
@d42 1
a42 1
extern int sigs;
@


1.8
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d123 1
a123 1
			goto start;
@


1.7
log
@Use interruptible syscalls instead of setjmp/longjmp.  This makes
less's signal handlers safe.  No one has reported problems so far...
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d55 1
d113 19
a131 1
		return (errno == EINTR ? READ_INTR : -1);
d193 1
a193 1
	snprintf(m, len, "%s: %s", filename, p);
d197 22
d227 1
a227 6
	POSITION num100 = num * 100;

	if (num100 / 100 == num)
		return (num100 / den);
	else
		return (num / (den / 100));
d234 1
a234 1
percent_pos(pos, percent)
d237 1
d239 2
a240 1
	POSITION result100;
d242 1
a242 1
	if (percent == 0)
d244 1
a244 4
	else if ((result100 = pos * percent) / percent == pos)
		return (result100 / 100);
	else
		return (percent * (pos / 100));
@


1.6
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@a25 1
#include <setjmp.h>
a41 19
/*
 * BSD setjmp() saves (and longjmp() restores) the signal mask.
 * This costs a system call or two per setjmp(), so if possible we clear the
 * signal mask with sigsetmask(), and use _setjmp()/_longjmp() instead.
 * On other systems, setjmp() doesn't affect the signal mask and so
 * _setjmp() does not exist; we just use setjmp().
 */
#if HAVE__SETJMP && HAVE_SIGSETMASK
#define SET_JUMP	_setjmp
#define LONG_JUMP	_longjmp
#else
#define SET_JUMP	setjmp
#define LONG_JUMP	longjmp
#endif

public int reading;

static jmp_buf read_label;

a45 2
 * A call to intread() from a signal handler will interrupt
 * any pending iread().
a70 23
	if (SET_JUMP(read_label))
	{
		/*
		 * We jumped here from intread.
		 */
		reading = 0;
#if HAVE_SIGPROCMASK
		{
		  sigset_t mask;
		  sigemptyset(&mask);
		  sigprocmask(SIG_SETMASK, &mask, NULL);
		}
#else
#if HAVE_SIGSETMASK
		sigsetmask(0);
#else
#ifdef _OSK
		sigmask(~0);
#endif
#endif
#endif
		return (READ_INTR);
	}
a72 1
	reading = 1;
a110 1
	reading = 0;
d112 1
a112 1
		return (-1);
a113 9
}

/*
 * Interrupt a pending iread().
 */
	public void
intread()
{
	LONG_JUMP(read_label, 1);
@


1.5
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@a0 2
/*	$OpenBSD: os.c,v 1.4 2001/11/19 19:02:14 mpech Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a24 1
#include <limits.h>
d62 2
d75 1
a75 1
	int n;
d77 5
a81 1
#if MSOFTC
d92 1
d99 7
d108 5
d119 17
d137 20
d202 1
a202 1
	snprintf(buf, sizeof buf, "Error %d", err);
d217 3
a219 3
	char *p;
	char *m;
	int len;
d221 1
d223 1
d235 17
a251 1
 * Return the largest possible number that can fit in a POSITION.
d253 4
a256 3
#ifdef QUAD_MAX
	static POSITION
get_maxpos()
d258 8
a265 1
	return (QUAD_MAX);
d267 9
a275 3
#else
	static POSITION
get_maxpos()
d277 8
a284 1
	POSITION n, n2;
d286 14
a299 12
	/*
	 * Keep doubling n until we overflow.
	 * {{ This actually only returns the largest power of two that
	 *    can fit in a POSITION, but percentage() doesn't really need
	 *    it any more accurate than that. }}
	 */
	n2 = 128;  /* Hopefully no maxpos is less than 128! */
	do {
		n = n2;
		n2 *= 2;
	} while (n2 / 2 == n);
	return (n);
d303 2
d306 1
a306 1
 * Return the ratio of two POSITIONs, as a percentage.
d308 13
a320 3
	public int
percentage(num, den)
	POSITION num, den;
d322 6
a327 1
	static POSITION maxpos100 = 0;
d329 1
a329 7
	if (maxpos100 == 0)
		maxpos100 = get_maxpos() / 100;
	if (num > maxpos100)
		return (num / (den/100));
	else
		return (100*num / den);
}
@


1.4
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: os.c,v 1.3 2001/01/29 01:58:03 niklas Exp $	*/
d165 1
a165 1
	sprintf(buf, "Error %d", err);
d182 1
d189 3
a191 2
	m = (char *) ecalloc(strlen(filename) + strlen(p) + 3, sizeof(char));
	sprintf(m, "%s: %s", filename, p);
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d92 1
a92 1
	register int n;
d180 2
a181 2
	register char *p;
	register char *m;
@


1.2
log
@First step at supporting files > 2gig.  Use off_t as POSITION
and replace get_maxlong() with a get_maxpos() and modify percentage()
appropriately.  There are still problems seeking to the end of a large
file and line numbers should probably be 64bit (or at the very least
unsigned).  This has been sitting in my tree for quite some time now
so I am committing what I have now since I don't know when I'll have
a chance to really finish it.
@
text
@d1 2
@


1.1
log
@Initial revision
@
text
@d41 1
d192 1
a192 1
 * Return the largest possible number that can fit in a long.
d194 3
a196 3
#ifdef MAXLONG
	static long
get_maxlong()
d198 1
a198 1
	return (MAXLONG);
d201 2
a202 2
	static long
get_maxlong()
d204 1
a204 1
	long n, n2;
d209 1
a209 1
	 *    can fit in a long, but percentage() doesn't really need
d212 1
a212 1
	n2 = 128;  /* Hopefully no maxlong is less than 128! */
d222 1
a222 1
 * Return the ratio of two longs, as a percentage.
d226 1
a226 1
	long num, den;
d228 1
a228 1
	static long maxlong100 = 0;
d230 3
a232 3
	if (maxlong100 == 0)
		maxlong100 = get_maxlong() / 100;
	if (num > maxlong100)
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
a77 2
extern int sigs;

d91 1
a91 5
#if MSDOS_COMPILER==WIN32C
	if (ABORT_SIGS())
		return (READ_INTR);
#else
#if MSDOS_COMPILER && MSDOS_COMPILER != DJGPPC
a101 1
#endif
a107 7
#if HAVE_SIGPROCMASK
		{
		  sigset_t mask;
		  sigemptyset(&mask);
		  sigprocmask(SIG_SETMASK, &mask, NULL);
		}
#else
a109 5
#else
#ifdef _OSK
		sigmask(~0);
#endif
#endif
a115 17
#if MSDOS_COMPILER==DJGPPC
	if (isatty(fd))
	{
		/*
		 * Don't try reading from a TTY until a character is
		 * available, because that makes some background programs
		 * believe DOS is busy in a way that prevents those
		 * programs from working while "less" waits.
		 */
		fd_set readfds;

		FD_ZERO(&readfds);
		FD_SET(fd, &readfds);
		if (select(fd+1, &readfds, 0, 0, 0) == -1)
			return (-1);
	}
#endif
a116 20
#if 1
	/*
	 * This is a kludge to workaround a problem on some systems
	 * where terminating a remote tty connection causes read() to
	 * start returning 0 forever, instead of -1.
	 */
	{
		extern int ignore_eoi;
		if (!ignore_eoi)
		{
			static int consecutive_nulls = 0;
			if (n == 0)
				consecutive_nulls++;
			else
				consecutive_nulls = 0;
			if (consecutive_nulls > 20)
				quit(QUIT_ERROR);
		}
	}
#endif
a179 1
#if MUST_DEFINE_ERRNO
a180 1
#endif
d191 1
a191 2
 * Return the ratio of two POSITIONS, as a percentage.
 * {{ Assumes a POSITION is a long int. }}
d193 3
a195 3
	public int
percentage(num, den)
	POSITION num, den;
d197 1
a197 6
	POSITION num100 = num * 100;

	if (num100 / 100 == num)
		return (num100 / den);
	else
		return (num / (den / 100));
d199 3
a201 8

/*
 * Return the specified percentage of a POSITION.
 */
	public POSITION
percent_pos(pos, percent)
	POSITION pos;
	int percent;
d203 1
a203 1
	POSITION result100;
d205 12
a216 40
	if (percent == 0)
		return (0);
	else if ((result100 = pos * percent) / percent == pos)
		return (result100 / 100);
	else
		return (percent * (pos / 100));
}

#if !HAVE_STRCHR
/*
 * strchr is used by regexp.c.
 */
	char *
strchr(s, c)
	char *s;
	int c;
{
	for ( ;  *s != '\0';  s++)
		if (*s == c)
			return (s);
	if (c == '\0')
		return (s);
	return (NULL);
}
#endif

#if !HAVE_MEMCPY
	VOID_POINTER
memcpy(dst, src, len)
	VOID_POINTER dst;
	VOID_POINTER src;
	int len;
{
	char *dstp = (char *) dst;
	char *srcp = (char *) src;
	int i;

	for (i = 0;  i < len;  i++)
		dstp[i] = srcp[i];
	return (dst);
a219 2
#ifdef _OSK_MWC32

d221 1
a221 1
 * This implements an ANSI-style intercept setup for Microware C 3.2
d223 3
a225 4
	public int 
os9_signal(type, handler)
	int type;
	RETSIGTYPE (*handler)();
d227 8
a234 1
	intercept(handler);
a235 15

#include <sgstat.h>

	int 
isatty(f)
	int f;
{
	struct sgbuf sgbuf;

	if (_gs_opt(f, &sgbuf) < 0)
		return -1;
	return (sgbuf.sg_class == 0);
}
	
#endif
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
a76 1
start:
a158 17
	{
#if HAVE_ERRNO
		/*
		 * Certain values of errno indicate we should just retry the read.
		 */
#if MUST_DEFINE_ERRNO
		extern int errno;
#endif
#ifdef EINTR
		if (errno == EINTR)
			goto start;
#endif
#ifdef EAGAIN
		if (errno == EAGAIN)
			goto start;
#endif
#endif
a159 1
	}
a218 1
	int len;
d227 2
a228 3
	len = strlen(filename) + strlen(p) + 3;
	m = (char *) ecalloc(len, sizeof(char));
	SNPRINTF2(m, len, "%s: %s", filename, p);
a231 22
/* #define HAVE_FLOAT 0 */

	static POSITION
muldiv(val, num, den)
	POSITION val, num, den;
{
#if HAVE_FLOAT
	double v = (((double) val) * num) / den;
	return ((POSITION) (v + 0.5));
#else
	POSITION v = ((POSITION) val) * num;

	if (v / num == val)
		/* No overflow */
		return (POSITION) (v / den);
	else
		/* Above calculation overflows; 
		 * use a method that is less precise but won't overflow. */
		return (POSITION) (val / (den / num));
#endif
}

d240 6
a245 1
	return (int) muldiv(num,  (POSITION) 100, den);
d252 1
a252 1
percent_pos(pos, percent, fraction)
a254 1
	long fraction;
d256 1
a256 2
	/* Change percent (parts per 100) to perden (parts per NUM_FRAC_DENOM). */
	POSITION perden = (percent * (NUM_FRAC_DENOM / 100)) + (fraction / 100);
d258 1
a258 1
	if (perden == 0)
d260 4
a263 1
	return (POSITION) muldiv(pos, perden, (POSITION) NUM_FRAC_DENOM);
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d26 1
d43 20
a62 1
extern volatile sig_atomic_t sigs;
d66 2
d94 23
d119 1
d158 1
d170 1
a170 1
			return (READ_INTR);
d183 9
d221 1
a221 1
	snprintf(buf, sizeof(buf), "Error %d", err);
d238 1
a238 1
	size_t len;
@


