head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.7.0.12
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.8
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.6
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	W32EN7Zp77efb8wW;

1.12
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	ZtGimechwgSRYqRW;

1.11
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.10;
commitid	QKrr6AuGzNx9nehL;

1.10
date	2015.11.05.22.47.33;	author tedu;	state Exp;
branches;
next	1.9;
commitid	vLFUUyhjlRQmhpMd;

1.9
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.8;
commitid	yKv9Ck9ZDgwWTRTo;

1.8
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.7;

1.7
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.03.16.29.46;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.14.14.33.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.03;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.06;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.49;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.13
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

#include "less.h"

extern IFILE curr_ifile;
extern int sc_height;
extern int jump_sline;

/*
 * A mark is an ifile (input file) plus a position within the file.
 */
struct mark {
	IFILE m_ifile;
	struct scrpos m_scrpos;
};

/*
 * The table of marks.
 * Each mark is identified by a lowercase or uppercase letter.
 * The final one is lmark, for the "last mark"; addressed by the apostrophe.
 */
#define	NMARKS		((2*26)+1)	/* a-z, A-Z, lastmark */
#define	LASTMARK	(NMARKS-1)
static struct mark marks[NMARKS];

/*
 * Initialize the mark table to show no marks are set.
 */
void
init_mark(void)
{
	int i;

	for (i = 0; i < NMARKS; i++)
		marks[i].m_scrpos.pos = -1;
}

/*
 * See if a mark letter is valid (between a and z).
 */
static struct mark *
getumark(int c)
{
	if (c >= 'a' && c <= 'z')
		return (&marks[c-'a']);

	if (c >= 'A' && c <= 'Z')
		return (&marks[c-'A'+26]);

	error("Invalid mark letter", NULL);
	return (NULL);
}

/*
 * Get the mark structure identified by a character.
 * The mark struct may come either from the mark table
 * or may be constructed on the fly for certain characters like ^, $.
 */
static struct mark *
getmark(int c)
{
	struct mark *m;
	static struct mark sm;

	switch (c) {
	case '^':
		/*
		 * Beginning of the current file.
		 */
		m = &sm;
		m->m_scrpos.pos = ch_zero();
		m->m_scrpos.ln = 0;
		m->m_ifile = curr_ifile;
		break;
	case '$':
		/*
		 * End of the current file.
		 */
		if (ch_end_seek()) {
			error("Cannot seek to end of file", NULL);
			return (NULL);
		}
		m = &sm;
		m->m_scrpos.pos = ch_tell();
		m->m_scrpos.ln = sc_height-1;
		m->m_ifile = curr_ifile;
		break;
	case '.':
		/*
		 * Current position in the current file.
		 */
		m = &sm;
		get_scrpos(&m->m_scrpos);
		m->m_ifile = curr_ifile;
		break;
	case '\'':
		/*
		 * The "last mark".
		 */
		m = &marks[LASTMARK];
		break;
	default:
		/*
		 * Must be a user-defined mark.
		 */
		m = getumark(c);
		if (m == NULL)
			break;
		if (m->m_scrpos.pos == -1) {
			error("Mark not set", NULL);
			return (NULL);
		}
		break;
	}
	return (m);
}

/*
 * Is a mark letter is invalid?
 */
int
badmark(int c)
{
	return (getmark(c) == NULL);
}

/*
 * Set a user-defined mark.
 */
void
setmark(int c)
{
	struct mark *m;
	struct scrpos scrpos;

	m = getumark(c);
	if (m == NULL)
		return;
	get_scrpos(&scrpos);
	m->m_scrpos = scrpos;
	m->m_ifile = curr_ifile;
}

/*
 * Set lmark (the mark named by the apostrophe).
 */
void
lastmark(void)
{
	struct scrpos scrpos;

	if (ch_getflags() & CH_HELPFILE)
		return;
	get_scrpos(&scrpos);
	if (scrpos.pos == -1)
		return;
	marks[LASTMARK].m_scrpos = scrpos;
	marks[LASTMARK].m_ifile = curr_ifile;
}

/*
 * Go to a mark.
 */
void
gomark(int c)
{
	struct mark *m;
	struct scrpos scrpos;

	m = getmark(c);
	if (m == NULL)
		return;

	/*
	 * If we're trying to go to the lastmark and
	 * it has not been set to anything yet,
	 * set it to the beginning of the current file.
	 */
	if (m == &marks[LASTMARK] && m->m_scrpos.pos == -1) {
		m->m_ifile = curr_ifile;
		m->m_scrpos.pos = ch_zero();
		m->m_scrpos.ln = jump_sline;
	}

	/*
	 * If we're using lmark, we must save the screen position now,
	 * because if we call edit_ifile() below, lmark will change.
	 * (We save the screen position even if we're not using lmark.)
	 */
	scrpos = m->m_scrpos;
	if (m->m_ifile != curr_ifile) {
		/*
		 * Not in the current file; edit the correct file.
		 */
		if (edit_ifile(m->m_ifile))
			return;
	}

	jump_loc(scrpos.pos, scrpos.ln);
}

/*
 * Return the position associated with a given mark letter.
 *
 * We don't return which screen line the position
 * is associated with, but this doesn't matter much,
 * because it's always the first non-blank line on the screen.
 */
off_t
markpos(int c)
{
	struct mark *m;

	m = getmark(c);
	if (m == NULL)
		return (-1);

	if (m->m_ifile != curr_ifile) {
		error("Mark not in current file", NULL);
		return (-1);
	}
	return (m->m_scrpos.pos);
}

/*
 * Clear the marks associated with a specified ifile.
 */
void
unmark(IFILE ifile)
{
	int i;

	for (i = 0; i < NMARKS; i++)
		if (marks[i].m_ifile == ifile)
			marks[i].m_scrpos.pos = -1;
}
@


1.12
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@d43 1
a43 1
	for (i = 0;  i < NMARKS;  i++)
d242 1
a242 1
	for (i = 0;  i < NMARKS;  i++)
@


1.11
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d59 1
a59 1
	error("Invalid mark letter", NULL_PARG);
d89 1
a89 1
			error("Cannot seek to end of file", NULL_PARG);
d119 1
a119 1
			error("Mark not set", NULL_PARG);
d228 1
a228 1
		error("Mark not in current file", NULL_PARG);
@


1.10
log
@deregister
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.9
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d73 1
a73 1
	register struct mark *m;
d144 1
a144 1
	register struct mark *m;
@


1.8
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

d40 2
a41 2
	public void
init_mark()
d46 1
a46 1
		marks[i].m_scrpos.pos = NULL_POSITION;
d52 2
a53 3
	static struct mark *
getumark(c)
	int c;
d70 2
a71 3
	static struct mark *
getmark(c)
	int c;
d76 1
a76 2
	switch (c)
	{
d90 1
a90 2
		if (ch_end_seek())
		{
d120 1
a120 2
		if (m->m_scrpos.pos == NULL_POSITION)
		{
a128 1
#if PIPEC
d132 2
a133 3
	public int
badmark(c)
	int c;
a136 1
#endif /* PIPEC */
d141 2
a142 3
	public void
setmark(c)
	int c;
d158 2
a159 2
	public void
lastmark()
d166 1
a166 1
	if (scrpos.pos == NULL_POSITION)
d175 2
a176 3
	public void
gomark(c)
	int c;
d178 1
a178 1
	register struct mark *m;
d186 1
a186 1
	 * If we're trying to go to the lastmark and 
d190 1
a190 2
	if (m == &marks[LASTMARK] && m->m_scrpos.pos == NULL_POSITION)
	{
d202 1
a202 2
	if (m->m_ifile != curr_ifile)
	{
a212 1
#if PIPEC
d216 1
a216 1
 * We don't return which screen line the position 
d220 2
a221 3
	public POSITION
markpos(c)
	int c;
d223 1
a223 1
	register struct mark *m;
d227 1
a227 1
		return (NULL_POSITION);
d229 1
a229 2
	if (m->m_ifile != curr_ifile)
	{
d231 1
a231 1
		return (NULL_POSITION);
a234 1
#endif /* PIPEC */
d239 2
a240 3
	public void
unmark(ifile)
	IFILE ifile;
d246 1
a246 1
			marks[i].m_scrpos.pos = NULL_POSITION;
@


1.7
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d141 1
a141 1
#endif
@


1.6
log
@use SMALL_PROGRAM to knock out some code
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d132 1
a132 1
#ifndef SMALL_PROGRAM
d142 1
a142 1
#endif /* SMALL_PROGRAM */
d170 2
d223 1
a223 1
#ifndef SMALL_PROGRAM
d248 1
a248 1
#endif /* SMALL_PROGRAM */
@


1.5
log
@o go back to using a help file instead of embedding it in the binary
o deal with HELPFILE not being defined
o add a SMALL definition to make a smaller less for the boot floppies
This still needs to be pared down a bit for the SMALL case
@
text
@d132 1
d142 1
d221 1
d246 1
@


1.4
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@a167 2
	if (ch_getflags() & CH_HELPFILE)
		return;
@


1.3
log
@kill more registers

millert@@ ok
@
text
@a0 2
/*	$OpenBSD: mark.c,v 1.2 2001/01/29 01:58:03 niklas Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a12 1
#include "position.h"
d29 1
d31 2
a32 1
#define	NMARKS		(2*26)		/* a-z, A-Z */
a35 5
 * Special mark for the "last mark"; addressed by the apostrophe.
 */
static struct mark lmark;

/*
a44 1
	lmark.m_scrpos.pos = NULL_POSITION;
d73 1
a73 1
	struct mark *m;
d106 1
a106 2
		m->m_scrpos.pos = ch_tell();
		m->m_scrpos.ln = 0;
d113 1
a113 1
		m = &lmark;
d149 1
a149 1
	struct mark *m;
d168 2
d173 2
a174 2
	lmark.m_scrpos = scrpos;
	lmark.m_ifile = curr_ifile;
d184 1
a184 1
	struct mark *m;
d196 1
a196 1
	if (m == &lmark && m->m_scrpos.pos == NULL_POSITION)
d232 1
a232 1
	struct mark *m;
d244 14
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d96 1
a96 1
	register struct mark *m;
d173 1
a173 1
	register struct mark *m;
d206 1
a206 1
	register struct mark *m;
d254 1
a254 1
	register struct mark *m;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d29 1
a45 1
 * The final one is lmark, for the "last mark"; addressed by the apostrophe.
d47 1
a47 2
#define	NMARKS		((2*26)+1)	/* a-z, A-Z, lastmark */
#define	LASTMARK	(NMARKS-1)
d51 5
d65 1
d127 2
a128 1
		get_scrpos(&m->m_scrpos);
d135 1
a135 1
		m = &marks[LASTMARK];
a189 2
	if (ch_getflags() & CH_HELPFILE)
		return;
d193 2
a194 2
	marks[LASTMARK].m_scrpos = scrpos;
	marks[LASTMARK].m_ifile = curr_ifile;
d216 1
a216 1
	if (m == &marks[LASTMARK] && m->m_scrpos.pos == NULL_POSITION)
a263 14
}

/*
 * Clear the marks associated with a specified ifile.
 */
	public void
unmark(ifile)
	IFILE ifile;
{
	int i;

	for (i = 0;  i < NMARKS;  i++)
		if (marks[i].m_ifile == ifile)
			marks[i].m_scrpos.pos = NULL_POSITION;
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
a131 1
#if PIPEC
a140 1
#endif /* PIPEC */
a220 1
#if PIPEC
a244 1
#endif /* PIPEC */
@


