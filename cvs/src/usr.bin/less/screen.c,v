head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.8
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.6
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.2
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.17.0.8
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.16.0.12
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.8
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.6
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.4
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.14.0.26
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.24
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.22
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.18
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.20
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.16
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.14
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.12
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.10
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.8
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.6
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.10
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.6
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	OpenBSD_1_2:1.2
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2016.07.08.15.23.44;	author millert;	state Exp;
branches;
next	1.23;
commitid	adJrMJBXve121suv;

1.23
date	2016.03.16.15.36.26;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	P9ytq8HKajWPxZf9;

1.22
date	2015.11.23.05.26.23;	author tedu;	state Exp;
branches;
next	1.21;
commitid	UYqPVbDrWj9kUOpg;

1.21
date	2015.11.20.16.25.15;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	p1xMixaxcJh0gdvi;

1.20
date	2015.11.09.18.05.57;	author millert;	state Exp;
branches;
next	1.19;
commitid	iaFwizGnF00uaNGA;

1.19
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.18;
commitid	QKrr6AuGzNx9nehL;

1.18
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.17;
commitid	yKv9Ck9ZDgwWTRTo;

1.17
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.16;

1.16
date	2011.09.21.19.01.49;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.11.19.59.07;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.25.23.36.20;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.01.22.01.37;	author david;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.06.23.38.07;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.05.01.03.35;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.29.01.58.04;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	98.07.20.07.14.10;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.11.12.06.28.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.11.12.04.40.51;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.22.07.01.30;	author etheisen;	state Exp;
branches;
next	1.2;

1.2
date	96.09.21.06.06.42;	author etheisen;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.41;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.41;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.07;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.51;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Pass errret pointer to setupterm() to prevent setupterm()
from calling exit() when given an unknown terminal type.
From Anton Lindqvist, who also upstreamed the fix.
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Routines which deal with the characteristics of the terminal.
 * Uses termcap to be as terminal-independent as possible.
 */

#include <sys/ioctl.h>

#include <err.h>
#include <term.h>
#include <termios.h>

#include "cmd.h"
#include "less.h"

#define	DEFAULT_TERM		"unknown"

/*
 * Strings passed to tputs() to do various terminal functions.
 */
static char
	*sc_home,		/* Cursor home */
	*sc_addline,		/* Add line, scroll down following lines */
	*sc_lower_left,		/* Cursor to last line, first column */
	*sc_return,		/* Cursor to beginning of current line */
	*sc_move,		/* General cursor positioning */
	*sc_clear,		/* Clear screen */
	*sc_eol_clear,		/* Clear to end of line */
	*sc_eos_clear,		/* Clear to end of screen */
	*sc_s_in,		/* Enter standout (highlighted) mode */
	*sc_s_out,		/* Exit standout mode */
	*sc_u_in,		/* Enter underline mode */
	*sc_u_out,		/* Exit underline mode */
	*sc_b_in,		/* Enter bold mode */
	*sc_b_out,		/* Exit bold mode */
	*sc_bl_in,		/* Enter blink mode */
	*sc_bl_out,		/* Exit blink mode */
	*sc_visual_bell,	/* Visual bell (flash screen) sequence */
	*sc_backspace,		/* Backspace cursor */
	*sc_s_keypad,		/* Start keypad mode */
	*sc_e_keypad,		/* End keypad mode */
	*sc_init,		/* Startup terminal initialization */
	*sc_deinit;		/* Exit terminal de-initialization */

static int init_done = 0;

int auto_wrap;			/* Terminal does \r\n when write past margin */
int ignaw;			/* Terminal ignores \n immediately after wrap */
int erase_char;			/* The user's erase char */
int erase2_char;		/* The user's other erase char */
int kill_char;			/* The user's line-kill char */
int werase_char;		/* The user's word-erase char */
int sc_width, sc_height;	/* Height & width of screen */
int bo_s_width, bo_e_width;	/* Printing width of boldface seq */
int ul_s_width, ul_e_width;	/* Printing width of underline seq */
int so_s_width, so_e_width;	/* Printing width of standout seq */
int bl_s_width, bl_e_width;	/* Printing width of blink seq */
int can_goto_line;		/* Can move cursor to any line */
int missing_cap = 0;		/* Some capability is missing */
static int above_mem;		/* Memory retained above screen */
static int below_mem;		/* Memory retained below screen */

static int attrmode = AT_NORMAL;
extern int binattr;

static char *cheaper(char *, char *, char *);
static void tmodes(char *, char *, char **, char **, char *, char *);

extern int quiet;		/* If VERY_QUIET, use visual bell for bell */
extern int no_back_scroll;
extern int swindow;
extern int no_init;
extern int no_keypad;
extern volatile sig_atomic_t sigs;
extern int wscroll;
extern int screen_trashed;
extern int tty;
extern int top_scroll;
extern int oldbot;
extern int hilite_search;

/*
 * Change terminal to "raw mode", or restore to "normal" mode.
 * "Raw mode" means
 *	1. An outstanding read will complete on receipt of a single keystroke.
 *	2. Input is not echoed.
 *	3. On output, \n is mapped to \r\n.
 *	4. \t is NOT expanded into spaces.
 *	5. Signal-causing characters such as ctrl-C (interrupt),
 *	   etc. are NOT disabled.
 * It doesn't matter whether an input \n is mapped to \r, or vice versa.
 */
void
raw_mode(int on)
{
	static int curr_on = 0;
	struct termios s;
	static struct termios save_term;
	static int saved_term = 0;

	if (on == curr_on)
		return;
	erase2_char = '\b'; /* in case OS doesn't know about erase2 */

	if (on) {
		/*
		 * Get terminal modes.
		 */
		(void) tcgetattr(tty, &s);

		/*
		 * Save modes and set certain variables dependent on modes.
		 */
		if (!saved_term) {
			save_term = s;
			saved_term = 1;
		}

		erase_char = s.c_cc[VERASE];
#ifdef VERASE2
		erase2_char = s.c_cc[VERASE2];
#endif
		kill_char = s.c_cc[VKILL];
#ifdef VWERASE
		werase_char = s.c_cc[VWERASE];
#endif

		/*
		 * Set the modes to the way we want them.
		 */
		s.c_lflag &= ~(ICANON | ECHO | ECHOE | ECHOK | ECHONL);

#ifndef	TAB3
#define	TAB3	0	/* Its a lie, but TAB3 isn't defined by POSIX. */
#endif
		s.c_oflag |= (TAB3 | OPOST | ONLCR);
		s.c_oflag &= ~(OCRNL | ONOCR | ONLRET);
		s.c_cc[VMIN] = 1;
		s.c_cc[VTIME] = 0;
#ifdef VLNEXT
		s.c_cc[VLNEXT] = 0;
#endif
#ifdef VDSUSP
		s.c_cc[VDSUSP] = 0;
#endif
	} else {
		/*
		 * Restore saved modes.
		 */
		s = save_term;
	}
	(void) tcsetattr(tty, TCSASOFT | TCSADRAIN, &s);
	curr_on = on;
}

/*
 * Some glue to prevent calling termcap functions if tgetent() failed.
 */
static int hardcopy;

/*
 * Get size of the output screen.
 */
static void
scrsize(void)
{
	int sys_height = 0, sys_width = 0, n;
	struct winsize w;
	char *s;

#define	DEF_SC_WIDTH	80
#define	DEF_SC_HEIGHT	24

	if (ioctl(2, TIOCGWINSZ, &w) == 0) {
		if (w.ws_row > 0)
			sys_height = w.ws_row;
		if (w.ws_col > 0)
			sys_width = w.ws_col;
	}

	if (sys_height > 0)
		sc_height = sys_height;
	else if ((s = lgetenv("LINES")) != NULL)
		sc_height = atoi(s);
	else if (!hardcopy && (n = lines) > 0)
		sc_height = n;
	if (sc_height <= 0)
		sc_height = DEF_SC_HEIGHT;

	if (sys_width > 0)
		sc_width = sys_width;
	else if ((s = lgetenv("COLUMNS")) != NULL)
		sc_width = atoi(s);
	else if (!hardcopy && (n = columns) > 0)
		sc_width = n;
	if (sc_width <= 0)
		sc_width = DEF_SC_WIDTH;
}

/*
 * Return the characters actually input by a "special" key.
 */
char *
special_key_str(int key)
{
	char *s;
	static char ctrlk[] = { CONTROL('K'), 0 };

	if (hardcopy)
		return (NULL);

	switch (key) {
	case SK_RIGHT_ARROW:
		s = key_right;
		break;
	case SK_LEFT_ARROW:
		s = key_left;
		break;
	case SK_UP_ARROW:
		s = key_up;
		break;
	case SK_DOWN_ARROW:
		s = key_down;
		break;
	case SK_PAGE_UP:
		s = key_ppage;
		break;
	case SK_PAGE_DOWN:
		s = key_npage;
		break;
	case SK_HOME:
		s = key_home;
		break;
	case SK_END:
		s = key_end;
		break;
	case SK_DELETE:
		s = key_dc;
		if (s == NULL) {
			s = "\177\0";
		}
		break;
	case SK_CONTROL_K:
		s = ctrlk;
		break;
	default:
		return (NULL);
	}
	return (s);
}

/*
 * Get terminal capabilities via termcap.
 */
void
get_term(void)
{
	char *t1, *t2;
	char *term;
	int  err;

	/*
	 * Find out what kind of terminal this is.
	 */
	if ((term = lgetenv("TERM")) == NULL)
		term = DEFAULT_TERM;
	hardcopy = 0;

	if (setupterm(term, 1, &err) < 0) {
		if (err == 1)
			hardcopy = 1;
		else
			errx(1, "%s: unknown terminal type", term);
	}
	if (hard_copy == 1)
		hardcopy = 1;

	/*
	 * Get size of the screen.
	 */
	scrsize();
	pos_init();

	auto_wrap = hardcopy ? 0 : auto_right_margin;
	ignaw = hardcopy ? 0 : eat_newline_glitch;
	above_mem = hardcopy ? 0 : memory_above;
	below_mem = hardcopy ? 0 : memory_below;

	/*
	 * Assumes termcap variable "sg" is the printing width of:
	 * the standout sequence, the end standout sequence,
	 * the underline sequence, the end underline sequence,
	 * the boldface sequence, and the end boldface sequence.
	 */
	if (hardcopy || (so_s_width = magic_cookie_glitch) < 0)
		so_s_width = 0;
	so_e_width = so_s_width;

	bo_s_width = bo_e_width = so_s_width;
	ul_s_width = ul_e_width = so_s_width;
	bl_s_width = bl_e_width = so_s_width;

	if (so_s_width > 0 || so_e_width > 0)
		/*
		 * Disable highlighting by default on magic cookie terminals.
		 * Turning on highlighting might change the displayed width
		 * of a line, causing the display to get messed up.
		 * The user can turn it back on with -g,
		 * but she won't like the results.
		 */
		hilite_search = 0;

	/*
	 * Get various string-valued capabilities.
	 */

	sc_s_keypad = keypad_xmit;
	if (hardcopy || sc_s_keypad == NULL)
		sc_s_keypad = "";
	sc_e_keypad = keypad_local;
	if (hardcopy || sc_e_keypad == NULL)
		sc_e_keypad = "";

	sc_init = enter_ca_mode;
	if (hardcopy || sc_init == NULL)
		sc_init = "";

	sc_deinit = exit_ca_mode;
	if (hardcopy || sc_deinit == NULL)
		sc_deinit = "";

	sc_eol_clear = clr_eol;
	if (hardcopy || sc_eol_clear == NULL || *sc_eol_clear == '\0') {
		missing_cap = 1;
		sc_eol_clear = "";
	}

	sc_eos_clear = clr_eos;
	if (below_mem &&
	    (hardcopy || sc_eos_clear == NULL || *sc_eos_clear == '\0')) {
		missing_cap = 1;
		sc_eos_clear = "";
	}

	sc_clear = clear_screen;
	if (hardcopy || sc_clear == NULL || *sc_clear == '\0') {
		missing_cap = 1;
		sc_clear = "\n\n";
	}

	sc_move = cursor_address;
	if (hardcopy || sc_move == NULL || *sc_move == '\0') {
		/*
		 * This is not an error here, because we don't
		 * always need sc_move.
		 * We need it only if we don't have home or lower-left.
		 */
		sc_move = "";
		can_goto_line = 0;
	} else {
		can_goto_line = 1;
	}

	tmodes(enter_standout_mode, exit_standout_mode, &sc_s_in, &sc_s_out,
	    "", "");
	tmodes(enter_underline_mode, exit_underline_mode, &sc_u_in, &sc_u_out,
	    sc_s_in, sc_s_out);
	tmodes(enter_bold_mode, exit_attribute_mode, &sc_b_in, &sc_b_out,
	    sc_s_in, sc_s_out);
	tmodes(enter_blink_mode, exit_attribute_mode, &sc_bl_in, &sc_bl_out,
	    sc_s_in, sc_s_out);

	sc_visual_bell = flash_screen;
	if (hardcopy || sc_visual_bell == NULL)
		sc_visual_bell = "";

	sc_backspace = "\b";

	/*
	 * Choose between using "ho" and "cm" ("home" and "cursor move")
	 * to move the cursor to the upper left corner of the screen.
	 */
	t1 = cursor_home;
	if (hardcopy || t1 == NULL)
		t1 = "";
	if (*sc_move == '\0') {
		t2 = "";
	} else {
		t2 = estrdup(tparm(sc_move, 0, 0, 0, 0, 0, 0, 0, 0, 0));
	}
	sc_home = cheaper(t1, t2, "|\b^");

	/*
	 * Choose between using "ll" and "cm"  ("lower left" and "cursor move")
	 * to move the cursor to the lower left corner of the screen.
	 */
	t1 = cursor_to_ll;
	if (hardcopy || t1 == NULL)
		t1 = "";
	if (*sc_move == '\0') {
		t2 = "";
	} else {
		t2 = estrdup(tparm(sc_move, sc_height-1,
		    0, 0, 0, 0, 0, 0, 0, 0));
	}
	sc_lower_left = cheaper(t1, t2, "\r");

	/*
	 * Get carriage return string.
	 */
	sc_return = carriage_return;
	if (hardcopy || sc_return == NULL)
		sc_return = "\r";

	/*
	 * Choose between using insert_line or scroll_reverse
	 * to add a line at the top of the screen.
	 */
	t1 = insert_line;
	if (hardcopy || t1 == NULL)
		t1 = "";
	t2 = scroll_reverse;
	if (hardcopy || t2 == NULL)
		t2 = "";
	if (above_mem)
		sc_addline = t1;
	else
		sc_addline = cheaper(t1, t2, "");
	if (*sc_addline == '\0') {
		/*
		 * Force repaint on any backward movement.
		 */
		no_back_scroll = 1;
	}
}

/*
 * Return the cost of displaying a termcap string.
 * We use the trick of calling tputs, but as a char printing function
 * we give it inc_costcount, which just increments "costcount".
 * This tells us how many chars would be printed by using this string.
 * {{ Couldn't we just use strlen? }}
 */
static int costcount;

static int
inc_costcount(int c)
{
	costcount++;
	return (c);
}

static int
cost(char *t)
{
	costcount = 0;
	(void) tputs(t, sc_height, inc_costcount);
	return (costcount);
}

/*
 * Return the "best" of the two given termcap strings.
 * The best, if both exist, is the one with the lower
 * cost (see cost() function).
 */
static char *
cheaper(char *t1, char *t2, char *def)
{
	if (*t1 == '\0' && *t2 == '\0') {
		missing_cap = 1;
		return (def);
	}
	if (*t1 == '\0')
		return (t2);
	if (*t2 == '\0')
		return (t1);
	if (cost(t1) < cost(t2))
		return (t1);
	return (t2);
}

static void
tmodes(char *incap, char *outcap, char **instr, char **outstr,
    char *def_instr, char *def_outstr)
{
	if (hardcopy) {
		*instr = "";
		*outstr = "";
		return;
	}

	*instr = incap;
	*outstr = outcap;

	if (*instr == NULL) {
		/* Use defaults. */
		*instr = def_instr;
		*outstr = def_outstr;
		return;
	}

	if (*outstr == NULL)
		/* No specific out capability; use exit_attribute_mode. */
		*outstr = exit_attribute_mode;
	if (*outstr == NULL)
		/* Don't even have that, use an empty string */
		*outstr = "";
}

/*
 * Below are the functions which perform all the
 * terminal-specific screen manipulation.
 */

/*
 * Initialize terminal
 */
void
init(void)
{
	if (!no_init)
		(void) tputs(sc_init, sc_height, putchr);
	if (!no_keypad)
		(void) tputs(sc_s_keypad, sc_height, putchr);
	if (top_scroll) {
		int i;

		/*
		 * This is nice to terminals with no alternate screen,
		 * but with saved scrolled-off-the-top lines.  This way,
		 * no previous line is lost, but we start with a whole
		 * screen to ourself.
		 */
		for (i = 1; i < sc_height; i++)
			(void) putchr('\n');
	} else
		line_left();
	init_done = 1;
}

/*
 * Deinitialize terminal
 */
void
deinit(void)
{
	if (!init_done)
		return;
	if (!no_keypad)
		(void) tputs(sc_e_keypad, sc_height, putchr);
	if (!no_init)
		(void) tputs(sc_deinit, sc_height, putchr);
	init_done = 0;
}

/*
 * Home cursor (move to upper left corner of screen).
 */
void
home(void)
{
	(void) tputs(sc_home, 1, putchr);
}

/*
 * Add a blank line (called with cursor at home).
 * Should scroll the display down.
 */
void
add_line(void)
{
	(void) tputs(sc_addline, sc_height, putchr);
}

/*
 * Move cursor to lower left corner of screen.
 */
void
lower_left(void)
{
	(void) tputs(sc_lower_left, 1, putchr);
}

/*
 * Move cursor to left position of current line.
 */
void
line_left(void)
{
	(void) tputs(sc_return, 1, putchr);
}

/*
 * Goto a specific line on the screen.
 */
void
goto_line(int slinenum)
{
	(void) tputs(tparm(sc_move, slinenum, 0, 0, 0, 0, 0, 0, 0, 0), 1,
	    putchr);
}

/*
 * Output the "visual bell", if there is one.
 */
void
vbell(void)
{
	if (*sc_visual_bell == '\0')
		return;
	(void) tputs(sc_visual_bell, sc_height, putchr);
}

/*
 * Make a noise.
 */
static void
beep(void)
{
	(void) putchr(CONTROL('G'));
}

/*
 * Ring the terminal bell.
 */
void
ring_bell(void)
{
	if (quiet == VERY_QUIET)
		vbell();
	else
		beep();
}

/*
 * Clear the screen.
 */
void
do_clear(void)
{
	(void) tputs(sc_clear, sc_height, putchr);
}

/*
 * Clear from the cursor to the end of the cursor's line.
 * {{ This must not move the cursor. }}
 */
void
clear_eol(void)
{
	(void) tputs(sc_eol_clear, 1, putchr);
}

/*
 * Clear the current line.
 * Clear the screen if there's off-screen memory below the display.
 */
static void
clear_eol_bot(void)
{
	if (below_mem)
		(void) tputs(sc_eos_clear, 1, putchr);
	else
		(void) tputs(sc_eol_clear, 1, putchr);
}

/*
 * Clear the bottom line of the display.
 * Leave the cursor at the beginning of the bottom line.
 */
void
clear_bot(void)
{
	/*
	 * If we're in a non-normal attribute mode, temporarily exit
	 * the mode while we do the clear.  Some terminals fill the
	 * cleared area with the current attribute.
	 */
	if (oldbot)
		lower_left();
	else
		line_left();

	if (attrmode == AT_NORMAL)
		clear_eol_bot();
	else
	{
		int saved_attrmode = attrmode;

		at_exit();
		clear_eol_bot();
		at_enter(saved_attrmode);
	}
}

void
at_enter(int attr)
{
	attr = apply_at_specials(attr);

	/* The one with the most priority is last.  */
	if (attr & AT_UNDERLINE)
		(void) tputs(sc_u_in, 1, putchr);
	if (attr & AT_BOLD)
		(void) tputs(sc_b_in, 1, putchr);
	if (attr & AT_BLINK)
		(void) tputs(sc_bl_in, 1, putchr);
	if (attr & AT_STANDOUT)
		(void) tputs(sc_s_in, 1, putchr);

	attrmode = attr;
}

void
at_exit(void)
{
	/* Undo things in the reverse order we did them.  */
	if (attrmode & AT_STANDOUT)
		(void) tputs(sc_s_out, 1, putchr);
	if (attrmode & AT_BLINK)
		(void) tputs(sc_bl_out, 1, putchr);
	if (attrmode & AT_BOLD)
		(void) tputs(sc_b_out, 1, putchr);
	if (attrmode & AT_UNDERLINE)
		(void) tputs(sc_u_out, 1, putchr);

	attrmode = AT_NORMAL;
}

void
at_switch(int attr)
{
	int new_attrmode = apply_at_specials(attr);
	int ignore_modes = AT_ANSI;

	if ((new_attrmode & ~ignore_modes) != (attrmode & ~ignore_modes)) {
		at_exit();
		at_enter(attr);
	}
}

int
is_at_equiv(int attr1, int attr2)
{
	attr1 = apply_at_specials(attr1);
	attr2 = apply_at_specials(attr2);

	return (attr1 == attr2);
}

int
apply_at_specials(int attr)
{
	if (attr & AT_BINARY)
		attr |= binattr;
	if (attr & AT_HILITE)
		attr |= AT_STANDOUT;
	attr &= ~(AT_BINARY|AT_HILITE);

	return (attr);
}

/*
 * Output a plain backspace, without erasing the previous char.
 */
void
putbs(void)
{
	(void) tputs(sc_backspace, 1, putchr);
}
@


1.23
log
@style(9) includes

ok nicm@@
@
text
@d19 1
d270 1
d279 5
a283 2
	if (setupterm(term, 1, NULL) < 0) {
		hardcopy = 1;
@


1.22
log
@calling ioctl() requires include sys/ioctl.h
@
text
@d17 1
a17 2
#include "less.h"
#include "cmd.h"
d19 1
a19 1
#include <sys/ioctl.h>
d21 3
a23 1
#include <term.h>
@


1.21
log
@wrapping an ioctl for TIOCGWINSZ inside #ifdef TIOCGWINSIZE (entirely
different) makes no sense; instead, accept all modern systems have
TIOCGWINSZ.
@
text
@d20 1
@


1.20
log
@fsync() on a tty is meaningless; ok deraadt@@
@
text
@d174 2
a176 6
	int sys_height;
	int sys_width;
	int n;
#ifdef	TIOCGWINSIZE
	struct winsize w;
#endif
a180 3
	sys_width = sys_height = 0;

#ifdef	TIOCGWINSIZE
a186 1
#endif
@


1.19
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@a159 1
	(void) fsync(tty);
@


1.18
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.17
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

a21 26
#if MSDOS_COMPILER
#include "pckeys.h"
#if MSDOS_COMPILER==MSOFTC
#include <graph.h>
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
#include <conio.h>
#if MSDOS_COMPILER==DJGPPC
#include <pc.h>
extern int fd0;
#endif
#else
#if MSDOS_COMPILER==WIN32C
#include <windows.h>
#endif
#endif
#endif
#include <time.h>

#else

#if HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif

#if HAVE_TERMIOS_H && HAVE_TERMIOS_FUNCS
d23 1
a23 40
#else
#if HAVE_TERMIO_H
#include <termio.h>
#else
#if HAVE_SGSTAT_H
#include <sgstat.h>
#else
#include <sgtty.h>
#endif
#endif
#endif

#if HAVE_TERMCAP_H
#include <termcap.h>
#endif
#ifdef _OSK
#include <signal.h>
#endif
#if OS2
#include <sys/signal.h>
#include "pckeys.h"
#endif
#if HAVE_SYS_STREAM_H
#include <sys/stream.h>
#endif
#if HAVE_SYS_PTEM_H
#include <sys/ptem.h>
#endif

#endif /* MSDOS_COMPILER */

/*
 * Check for broken termios package that forces you to manually
 * set the line discipline.
 */
#ifdef __ultrix__
#define MUST_SET_LINE_DISCIPLINE 1
#else
#define MUST_SET_LINE_DISCIPLINE 0
#endif
a24 4
#if OS2
#define	DEFAULT_TERM		"ansi"
static char *windowid;
#else
a25 64
#endif

#if MSDOS_COMPILER==MSOFTC
static int videopages;
static long msec_loops;
static int flash_created = 0;
#define	SETCOLORS(fg,bg)	{ _settextcolor(fg); _setbkcolor(bg); }
#endif

#if MSDOS_COMPILER==BORLANDC
static unsigned short *whitescreen;
static int flash_created = 0;
#endif
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
#define _settextposition(y,x)   gotoxy(x,y)
#define _clearscreen(m)         clrscr()
#define _outtext(s)             cputs(s)
#define	SETCOLORS(fg,bg)	{ textcolor(fg); textbackground(bg); }
extern int sc_height;
#endif

#if MSDOS_COMPILER==WIN32C
struct keyRecord
{
	int ascii;
	int scan;
} currentKey;

static int keyCount = 0;
static WORD curr_attr;
static int pending_scancode = 0;
static WORD *whitescreen;

static HANDLE con_out_save = INVALID_HANDLE_VALUE; /* previous console */
static HANDLE con_out_ours = INVALID_HANDLE_VALUE; /* our own */
HANDLE con_out = INVALID_HANDLE_VALUE;             /* current console */

extern int quitting;
static void win32_init_term();
static void win32_deinit_term();

#define FG_COLORS       (FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY)
#define BG_COLORS       (BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE | BACKGROUND_INTENSITY)
#define	MAKEATTR(fg,bg)		((WORD)((fg)|((bg)<<4)))
#define	SETCOLORS(fg,bg)	{ curr_attr = MAKEATTR(fg,bg); \
				if (SetConsoleTextAttribute(con_out, curr_attr) == 0) \
				error("SETCOLORS failed"); }
#endif

#if MSDOS_COMPILER
public int nm_fg_color;		/* Color of normal text */
public int nm_bg_color;
public int bo_fg_color;		/* Color of bold text */
public int bo_bg_color;
public int ul_fg_color;		/* Color of underlined text */
public int ul_bg_color;
public int so_fg_color;		/* Color of standout text */
public int so_bg_color;
public int bl_fg_color;		/* Color of blinking text */
public int bl_bg_color;
static int sy_fg_color;		/* Color of system text (before less) */
static int sy_bg_color;

#else
a30 1
	*sc_pad,		/* Pad string */
a52 1
#endif
d56 15
a70 15
public int auto_wrap;		/* Terminal does \r\n when write past margin */
public int ignaw;		/* Terminal ignores \n immediately after wrap */
public int erase_char;		/* The user's erase char */
public int erase2_char;		/* The user's other erase char */
public int kill_char;		/* The user's line-kill char */
public int werase_char;		/* The user's word-erase char */
public int sc_width, sc_height;	/* Height & width of screen */
public int bo_s_width, bo_e_width;	/* Printing width of boldface seq */
public int ul_s_width, ul_e_width;	/* Printing width of underline seq */
public int so_s_width, so_e_width;	/* Printing width of standout seq */
public int bl_s_width, bl_e_width;	/* Printing width of blink seq */
public int above_mem, below_mem;	/* Memory retained above/below screen */
public int can_goto_line;		/* Can move cursor to any line */
public int clear_bg;		/* Clear fills with background color */
public int missing_cap = 0;	/* Some capability is missing */
d75 2
a76 17
#if !MSDOS_COMPILER
static char *cheaper();
static void tmodes();
#endif

/*
 * These two variables are sometimes defined in,
 * and needed by, the termcap library.
 */
#if MUST_DEFINE_OSPEED
extern short ospeed;	/* Terminal output baud rate */
extern char PC;		/* Pad character */
#endif
#ifdef _OSK
short ospeed;
char PC_, *UP, *BC;
#endif
a88 1
#if HILITE_SEARCH
a89 5
#endif

extern char *tgetstr();
extern char *tgoto();

d93 1
a93 1
 * "Raw mode" means 
d95 1
a95 1
 *	2. Input is not echoed.  
d102 2
a103 3
	public void
raw_mode(on)
	int on;
d106 3
a112 5
#if HAVE_TERMIOS_H && HAVE_TERMIOS_FUNCS
    {
	struct termios s;
	static struct termios save_term;
	static int saved_term = 0;
d114 1
a114 2
	if (on) 
	{
d118 1
a118 1
		tcgetattr(tty, &s);
d123 1
a123 2
		if (!saved_term)
		{
d127 1
a127 60
#if HAVE_OSPEED
		switch (cfgetospeed(&s))
		{
#ifdef B0
		case B0: ospeed = 0; break;
#endif
#ifdef B50
		case B50: ospeed = 1; break;
#endif
#ifdef B75
		case B75: ospeed = 2; break;
#endif
#ifdef B110
		case B110: ospeed = 3; break;
#endif
#ifdef B134
		case B134: ospeed = 4; break;
#endif
#ifdef B150
		case B150: ospeed = 5; break;
#endif
#ifdef B200
		case B200: ospeed = 6; break;
#endif
#ifdef B300
		case B300: ospeed = 7; break;
#endif
#ifdef B600
		case B600: ospeed = 8; break;
#endif
#ifdef B1200
		case B1200: ospeed = 9; break;
#endif
#ifdef B1800
		case B1800: ospeed = 10; break;
#endif
#ifdef B2400
		case B2400: ospeed = 11; break;
#endif
#ifdef B4800
		case B4800: ospeed = 12; break;
#endif
#ifdef B9600
		case B9600: ospeed = 13; break;
#endif
#ifdef EXTA
		case EXTA: ospeed = 14; break;
#endif
#ifdef EXTB
		case EXTB: ospeed = 15; break;
#endif
#ifdef B57600
		case B57600: ospeed = 16; break;
#endif
#ifdef B115200
		case B115200: ospeed = 17; break;
#endif
		default: ;
		}
#endif
a134 2
#else
		werase_char = CONTROL('W');
d140 1
a140 17
		s.c_lflag &= ~(0
#ifdef ICANON
			| ICANON
#endif
#ifdef ECHO
			| ECHO
#endif
#ifdef ECHOE
			| ECHOE
#endif
#ifdef ECHOK
			| ECHOK
#endif
#if ECHONL
			| ECHONL
#endif
		);
d142 2
a143 32
		s.c_oflag |= (0
#ifdef OXTABS
			| OXTABS
#else
#ifdef TAB3
			| TAB3
#else
#ifdef XTABS
			| XTABS
#endif
#endif
#endif
#ifdef OPOST
			| OPOST
#endif
#ifdef ONLCR
			| ONLCR
#endif
		);

		s.c_oflag &= ~(0
#ifdef ONOEOT
			| ONOEOT
#endif
#ifdef OCRNL
			| OCRNL
#endif
#ifdef ONOCR
			| ONOCR
#endif
#ifdef ONLRET
			| ONLRET
d145 2
a146 1
		);
d155 1
a155 159
#if MUST_SET_LINE_DISCIPLINE
		/*
		 * System's termios is broken; need to explicitly 
		 * request TERMIODISC line discipline.
		 */
		s.c_line = TERMIODISC;
#endif
	} else
	{
		/*
		 * Restore saved modes.
		 */
		s = save_term;
	}
	tcsetattr(tty, TCSASOFT | TCSADRAIN, &s);
#if HAVE_FSYNC
	fsync(tty);
#endif
#if MUST_SET_LINE_DISCIPLINE
	if (!on)
	{
		/*
		 * Broken termios *ignores* any line discipline
		 * except TERMIODISC.  A different old line discipline
		 * is therefore not restored, yet.  Restore the old
		 * line discipline by hand.
		 */
		ioctl(tty, TIOCSETD, &save_term.c_line);
	}
#endif
    }
#else
#ifdef TCGETA
    {
	struct termio s;
	static struct termio save_term;
	static int saved_term = 0;

	if (on)
	{
		/*
		 * Get terminal modes.
		 */
		ioctl(tty, TCGETA, &s);

		/*
		 * Save modes and set certain variables dependent on modes.
		 */
		if (!saved_term)
		{
			save_term = s;
			saved_term = 1;
		}
#if HAVE_OSPEED
		ospeed = s.c_cflag & CBAUD;
#endif
		erase_char = s.c_cc[VERASE];
		kill_char = s.c_cc[VKILL];
#ifdef VWERASE
		werase_char = s.c_cc[VWERASE];
#else
		werase_char = CONTROL('W');
#endif

		/*
		 * Set the modes to the way we want them.
		 */
		s.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL);
		s.c_oflag |=  (OPOST|ONLCR|TAB3);
		s.c_oflag &= ~(OCRNL|ONOCR|ONLRET);
		s.c_cc[VMIN] = 1;
		s.c_cc[VTIME] = 0;
	} else
	{
		/*
		 * Restore saved modes.
		 */
		s = save_term;
	}
	ioctl(tty, TCSETAW, &s);
    }
#else
#ifdef TIOCGETP
    {
	struct sgttyb s;
	static struct sgttyb save_term;
	static int saved_term = 0;

	if (on)
	{
		/*
		 * Get terminal modes.
		 */
		ioctl(tty, TIOCGETP, &s);

		/*
		 * Save modes and set certain variables dependent on modes.
		 */
		if (!saved_term)
		{
			save_term = s;
			saved_term = 1;
		}
#if HAVE_OSPEED
		ospeed = s.sg_ospeed;
#endif
		erase_char = s.sg_erase;
		kill_char = s.sg_kill;
		werase_char = CONTROL('W');

		/*
		 * Set the modes to the way we want them.
		 */
		s.sg_flags |= CBREAK;
		s.sg_flags &= ~(ECHO|XTABS);
	} else
	{
		/*
		 * Restore saved modes.
		 */
		s = save_term;
	}
	ioctl(tty, TIOCSETN, &s);
    }
#else
#ifdef _OSK
    {
	struct sgbuf s;
	static struct sgbuf save_term;
	static int saved_term = 0;

	if (on)
	{
		/*
		 * Get terminal modes.
		 */
		_gs_opt(tty, &s);

		/*
		 * Save modes and set certain variables dependent on modes.
		 */
		if (!saved_term)
		{
			save_term = s;
			saved_term = 1;
		}
		erase_char = s.sg_bspch;
		kill_char = s.sg_dlnch;
		werase_char = CONTROL('W');

		/*
		 * Set the modes to the way we want them.
		 */
		s.sg_echo = 0;
		s.sg_eofch = 0;
		s.sg_pause = 0;
		s.sg_psch = 0;
	} else
	{
d161 2
a162 28
	_ss_opt(tty, &s);
    }
#else
	/* MS-DOS, Windows, or OS2 */
#if OS2
	/* OS2 */
	LSIGNAL(SIGINT, SIG_IGN);
#endif
	erase_char = '\b';
#if MSDOS_COMPILER==DJGPPC
	kill_char = CONTROL('U');
	/*
	 * So that when we shell out or run another program, its
	 * stdin is in cooked mode.  We do not switch stdin to binary 
	 * mode if fd0 is zero, since that means we were called before
	 * tty was reopened in open_getchr, in which case we would be
	 * changing the original stdin device outside less.
	 */
	if (fd0 != 0)
		setmode(0, on ? O_BINARY : O_TEXT);
#else
	kill_char = ESC;
#endif
	werase_char = CONTROL('W');
#endif
#endif
#endif
#endif
a165 1
#if !MSDOS_COMPILER
a170 72
	static char *
ltget_env(capname)
	char *capname;
{
	char name[16];
	char *s;

	s = lgetenv("LESS_TERMCAP_DEBUG");
	if (s != NULL && *s != '\0')
	{
		struct env { struct env *next; char *name; char *value; };
		static struct env *envs = NULL;
		struct env *p;
		size_t len;
		for (p = envs;  p != NULL;  p = p->next)
			if (strcmp(p->name, capname) == 0)
				return p->value;
		p = (struct env *) ecalloc(1, sizeof(struct env));
		p->name = save(capname);
		len = strlen(capname) + 3;
		p->value = (char *) ecalloc(len, sizeof(char));
		snprintf(p->value, len, "<%s>", capname);
		p->next = envs;
		envs = p;
		return p->value;
	}
	strlcpy(name, "LESS_TERMCAP_", sizeof(name));
	strlcat(name, capname, sizeof(name));
	return (lgetenv(name));
}

	static int
ltgetflag(capname)
	char *capname;
{
	char *s;

	if ((s = ltget_env(capname)) != NULL)
		return (*s != '\0' && *s != '0');
	if (hardcopy)
		return (0);
	return (tgetflag(capname));
}

	static int
ltgetnum(capname)
	char *capname;
{
	char *s;

	if ((s = ltget_env(capname)) != NULL)
		return (atoi(s));
	if (hardcopy)
		return (-1);
	return (tgetnum(capname));
}

	static char *
ltgetstr(capname, pp)
	char *capname;
	char **pp;
{
	char *s;

	if ((s = ltget_env(capname)) != NULL)
		return (s);
	if (hardcopy)
		return (NULL);
	return (tgetstr(capname, pp));
}
#endif /* MSDOS_COMPILER */

d174 2
a175 2
	public void
scrsize()
d177 1
a177 1
	register char *s;
a179 1
#if !MSDOS_COMPILER
d181 2
a185 3
#if MSDOS_COMPILER
#define	DEF_SC_HEIGHT	25
#else
a186 2
#endif

d190 6
a195 63
#if MSDOS_COMPILER==MSOFTC
	{
		struct videoconfig w;
		_getvideoconfig(&w);
		sys_height = w.numtextrows;
		sys_width = w.numtextcols;
	}
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
	{
		struct text_info w;
		gettextinfo(&w);
		sys_height = w.screenheight;
		sys_width = w.screenwidth;
	}
#else
#if MSDOS_COMPILER==WIN32C
	{
		CONSOLE_SCREEN_BUFFER_INFO scr;
		GetConsoleScreenBufferInfo(con_out, &scr);
		sys_height = scr.srWindow.Bottom - scr.srWindow.Top + 1;
		sys_width = scr.srWindow.Right - scr.srWindow.Left + 1;
	}
#else
#if OS2
	{
		int s[2];
		_scrsize(s);
		sys_width = s[0];
		sys_height = s[1];
		/*
		 * When using terminal emulators for XFree86/OS2, the
		 * _scrsize function does not work well.
		 * Call the scrsize.exe program to get the window size.
		 */
		windowid = getenv("WINDOWID");
		if (windowid != NULL)
		{
			FILE *fd = popen("scrsize", "rt");
			if (fd != NULL)
			{
				int w, h;
				fscanf(fd, "%i %i", &w, &h);
				if (w > 0 && h > 0)
				{
					sys_width = w;
					sys_height = h;
				}
				pclose(fd);
			}
		}
	}
#else
#ifdef TIOCGWINSZ
	{
		struct winsize w;
		if (ioctl(2, TIOCGWINSZ, &w) == 0)
		{
			if (w.ws_row > 0)
				sys_height = w.ws_row;
			if (w.ws_col > 0)
				sys_width = w.ws_col;
		}
a196 17
#else
#ifdef WIOCGETD
	{
		struct uwdata w;
		if (ioctl(2, WIOCGETD, &w) == 0)
		{
			if (w.uw_height > 0)
				sys_height = w.uw_height / w.uw_vs;
			if (w.uw_width > 0)
				sys_width = w.uw_width / w.uw_hs;
		}
	}
#endif
#endif
#endif
#endif
#endif
d203 2
a204 4
#if !MSDOS_COMPILER
	else if ((n = ltgetnum("li")) > 0)
 		sc_height = n;
#endif
d212 2
a213 4
#if !MSDOS_COMPILER
	else if ((n = ltgetnum("co")) > 0)
 		sc_width = n;
#endif
a217 59
#if MSDOS_COMPILER==MSOFTC
/*
 * Figure out how many empty loops it takes to delay a millisecond.
 */
	static void
get_clock()
{
	clock_t start;
	
	/*
	 * Get synchronized at the start of a tick.
	 */
	start = clock();
	while (clock() == start)
		;
	/*
	 * Now count loops till the next tick.
	 */
	start = clock();
	msec_loops = 0;
	while (clock() == start)
		msec_loops++;
	/*
	 * Convert from (loops per clock) to (loops per millisecond).
	 */
	msec_loops *= CLOCKS_PER_SEC;
	msec_loops /= 1000;
}

/*
 * Delay for a specified number of milliseconds.
 */
	static void
dummy_func()
{
	static long delay_dummy = 0;
	delay_dummy++;
}

	static void
delay(msec)
	int msec;
{
	long i;
	
	while (msec-- > 0)
	{
		for (i = 0;  i < msec_loops;  i++)
		{
			/*
			 * Make it look like we're doing something here,
			 * so the optimizer doesn't remove the whole loop.
			 */
			dummy_func();
		}
	}
}
#endif

d221 2
a222 3
	public char *
special_key_str(key)
	int key;
a223 1
	static char tbuf[40];
d225 4
a228 21
#if MSDOS_COMPILER || OS2
	static char k_right[]		= { '\340', PCK_RIGHT, 0 };
	static char k_left[]		= { '\340', PCK_LEFT, 0  };
	static char k_ctl_right[]	= { '\340', PCK_CTL_RIGHT, 0  };
	static char k_ctl_left[]	= { '\340', PCK_CTL_LEFT, 0  };
	static char k_insert[]		= { '\340', PCK_INSERT, 0  };
	static char k_delete[]		= { '\340', PCK_DELETE, 0  };
	static char k_ctl_delete[]	= { '\340', PCK_CTL_DELETE, 0  };
	static char k_ctl_backspace[]	= { '\177', 0 };
	static char k_home[]		= { '\340', PCK_HOME, 0 };
	static char k_end[]		= { '\340', PCK_END, 0 };
	static char k_up[]		= { '\340', PCK_UP, 0 };
	static char k_down[]		= { '\340', PCK_DOWN, 0 };
	static char k_backtab[]		= { '\340', PCK_SHIFT_TAB, 0 };
	static char k_pagedown[]	= { '\340', PCK_PAGEDOWN, 0 };
	static char k_pageup[]		= { '\340', PCK_PAGEUP, 0 };
	static char k_f1[]		= { '\340', PCK_F1, 0 };
#endif
#if !MSDOS_COMPILER
	char *sp = tbuf;
#endif
d230 1
a230 97
	switch (key)
	{
#if OS2
	/*
	 * If windowid is not NULL, assume less is executed in 
	 * the XFree86 environment.
	 */
	case SK_RIGHT_ARROW:
		s = windowid ? ltgetstr("kr", &sp) : k_right;
		break;
	case SK_LEFT_ARROW:
		s = windowid ? ltgetstr("kl", &sp) : k_left;
		break;
	case SK_UP_ARROW:
		s = windowid ? ltgetstr("ku", &sp) : k_up;
		break;
	case SK_DOWN_ARROW:
		s = windowid ? ltgetstr("kd", &sp) : k_down;
		break;
	case SK_PAGE_UP:
		s = windowid ? ltgetstr("kP", &sp) : k_pageup;
		break;
	case SK_PAGE_DOWN:
		s = windowid ? ltgetstr("kN", &sp) : k_pagedown;
		break;
	case SK_HOME:
		s = windowid ? ltgetstr("kh", &sp) : k_home;
		break;
	case SK_END:
		s = windowid ? ltgetstr("@@7", &sp) : k_end;
		break;
	case SK_DELETE:
		if (windowid)
		{
			s = ltgetstr("kD", &sp);
			if (s == NULL)
			{
				tbuf[0] = '\177';
				tbuf[1] = '\0';
				s = tbuf;
			}
		} else
			s = k_delete;
		break;
#endif
#if MSDOS_COMPILER
	case SK_RIGHT_ARROW:
		s = k_right;
		break;
	case SK_LEFT_ARROW:
		s = k_left;
		break;
	case SK_UP_ARROW:
		s = k_up;
		break;
	case SK_DOWN_ARROW:
		s = k_down;
		break;
	case SK_PAGE_UP:
		s = k_pageup;
		break;
	case SK_PAGE_DOWN:
		s = k_pagedown;
		break;
	case SK_HOME:
		s = k_home;
		break;
	case SK_END:
		s = k_end;
		break;
	case SK_DELETE:
		s = k_delete;
		break;
#endif
#if MSDOS_COMPILER || OS2
	case SK_INSERT:
		s = k_insert;
		break;
	case SK_CTL_LEFT_ARROW:
		s = k_ctl_left;
		break;
	case SK_CTL_RIGHT_ARROW:
		s = k_ctl_right;
		break;
	case SK_CTL_BACKSPACE:
		s = k_ctl_backspace;
		break;
	case SK_CTL_DELETE:
		s = k_ctl_delete;
		break;
	case SK_F1:
		s = k_f1;
		break;
	case SK_BACKTAB:
		s = k_backtab;
		break;
#else
d232 1
a232 1
		s = ltgetstr("kr", &sp);
d235 1
a235 1
		s = ltgetstr("kl", &sp);
d238 1
a238 1
		s = ltgetstr("ku", &sp);
d241 1
a241 1
		s = ltgetstr("kd", &sp);
d244 1
a244 1
		s = ltgetstr("kP", &sp);
d247 1
a247 1
		s = ltgetstr("kN", &sp);
d250 1
a250 1
		s = ltgetstr("kh", &sp);
d253 1
a253 1
		s = ltgetstr("@@7", &sp);
d256 3
a258 6
		s = ltgetstr("kD", &sp);
		if (s == NULL)
		{
			tbuf[0] = '\177';
			tbuf[1] = '\0';
			s = tbuf;
a260 1
#endif
d262 1
a262 3
		tbuf[0] = CONTROL('K');
		tbuf[1] = '\0';
		s = tbuf;
d273 2
a274 2
	public void
get_term()
d276 1
a276 64
#if MSDOS_COMPILER
	auto_wrap = 1;
	ignaw = 0;
	can_goto_line = 1;
	clear_bg = 1;
	/*
	 * Set up default colors.
	 * The xx_s_width and xx_e_width vars are already initialized to 0.
	 */
#if MSDOS_COMPILER==MSOFTC
	sy_bg_color = _getbkcolor();
	sy_fg_color = _gettextcolor();
	get_clock();
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
    {
	struct text_info w;
	gettextinfo(&w);
	sy_bg_color = (w.attribute >> 4) & 0x0F;
	sy_fg_color = (w.attribute >> 0) & 0x0F;
    }
#else
#if MSDOS_COMPILER==WIN32C
    {
	DWORD nread;
	CONSOLE_SCREEN_BUFFER_INFO scr;

	con_out_save = con_out = GetStdHandle(STD_OUTPUT_HANDLE);
	/*
	 * Always open stdin in binary. Note this *must* be done
	 * before any file operations have been done on fd0.
	 */
	SET_BINARY(0);
	GetConsoleScreenBufferInfo(con_out, &scr);
	ReadConsoleOutputAttribute(con_out, &curr_attr, 
					1, scr.dwCursorPosition, &nread);
	sy_bg_color = (curr_attr & BG_COLORS) >> 4; /* normalize */
	sy_fg_color = curr_attr & FG_COLORS;
    }
#endif
#endif
#endif
	nm_fg_color = sy_fg_color;
	nm_bg_color = sy_bg_color;
	bo_fg_color = 11;
	bo_bg_color = 0;
	ul_fg_color = 9;
	ul_bg_color = 0;
	so_fg_color = 15;
	so_bg_color = 9;
	bl_fg_color = 15;
	bl_bg_color = 0;

	/*
	 * Get size of the screen.
	 */
	scrsize();
	pos_init();


#else /* !MSDOS_COMPILER */

	char *sp;
	register char *t1, *t2;
a277 1
	char termbuf[TERMBUF_SIZE];
a278 20
	static char sbuf[TERMSBUF_SIZE];

#if OS2
	/*
	 * Make sure the termcap database is available.
	 */
	sp = lgetenv("TERMCAP");
	if (sp == NULL || *sp == '\0')
	{
		char *termcap;
		if ((sp = homefile("termcap.dat")) != NULL)
		{
			size_t len = strlen(sp) + 9;
			termcap = (char *) ecalloc(len, sizeof(char));
			snprintf(termcap, len, "TERMCAP=%s", sp);
			free(sp);
			putenv(termcap);
		}
	}
#endif
d282 2
a283 2
 	if ((term = lgetenv("TERM")) == NULL)
 		term = DEFAULT_TERM;
d285 5
a289 3
 	if (tgetent(termbuf, term) != TGETENT_OK)
 		hardcopy = 1;
 	if (ltgetflag("hc"))
d298 4
a301 5
	auto_wrap = ltgetflag("am");
	ignaw = ltgetflag("xn");
	above_mem = ltgetflag("da");
	below_mem = ltgetflag("db");
	clear_bg = ltgetflag("ut");
d309 1
a309 1
	if ((so_s_width = ltgetnum("sg")) < 0)
a316 1
#if HILITE_SEARCH
d322 1
a322 1
		 * The user can turn it back on with -g, 
a325 1
#endif
a329 1
	sp = sbuf;
d331 2
a332 8
#if HAVE_OSPEED
	sc_pad = ltgetstr("pc", &sp);
	if (sc_pad != NULL)
		PC = *sc_pad;
#endif

	sc_s_keypad = ltgetstr("ks", &sp);
	if (sc_s_keypad == NULL)
d334 2
a335 2
	sc_e_keypad = ltgetstr("ke", &sp);
	if (sc_e_keypad == NULL)
d337 3
a339 3
		
	sc_init = ltgetstr("ti", &sp);
	if (sc_init == NULL)
d342 2
a343 2
	sc_deinit= ltgetstr("te", &sp);
	if (sc_deinit == NULL)
d346 2
a347 3
	sc_eol_clear = ltgetstr("ce", &sp);
	if (sc_eol_clear == NULL || *sc_eol_clear == '\0')
	{
d352 3
a354 3
	sc_eos_clear = ltgetstr("cd", &sp);
	if (below_mem && (sc_eos_clear == NULL || *sc_eos_clear == '\0'))
	{
d359 2
a360 3
	sc_clear = ltgetstr("cl", &sp);
	if (sc_clear == NULL || *sc_clear == '\0')
	{
d365 2
a366 3
	sc_move = ltgetstr("cm", &sp);
	if (sc_move == NULL || *sc_move == '\0')
	{
d368 1
a368 1
		 * This is not an error here, because we don't 
d374 1
a374 1
	} else
d376 1
d378 8
a385 4
	tmodes("so", "se", &sc_s_in, &sc_s_out, "", "", &sp);
	tmodes("us", "ue", &sc_u_in, &sc_u_out, sc_s_in, sc_s_out, &sp);
	tmodes("md", "me", &sc_b_in, &sc_b_out, sc_s_in, sc_s_out, &sp);
	tmodes("mb", "me", &sc_bl_in, &sc_bl_out, sc_s_in, sc_s_out, &sp);
d387 2
a388 2
	sc_visual_bell = ltgetstr("vb", &sp);
	if (sc_visual_bell == NULL)
d391 1
a391 8
	if (ltgetflag("bs"))
		sc_backspace = "\b";
	else
	{
		sc_backspace = ltgetstr("bc", &sp);
		if (sc_backspace == NULL || *sc_backspace == '\0')
			sc_backspace = "\b";
	}
d397 2
a398 2
	t1 = ltgetstr("ho", &sp);
	if (t1 == NULL)
d400 1
a400 1
	if (*sc_move == '\0')
d402 2
a403 5
	else
	{
		strlcpy(sp, tgoto(sc_move, 0, 0), sbuf + sizeof(sbuf) - sp);
		t2 = sp;
		sp += strlen(sp) + 1;
d411 2
a412 2
	t1 = ltgetstr("ll", &sp);
	if (t1 == NULL)
d414 1
a414 1
	if (*sc_move == '\0')
d416 3
a418 6
	else
	{
		strlcpy(sp, tgoto(sc_move, 0, sc_height-1),
		    sbuf + sizeof(sbuf) - sp);
		t2 = sp;
		sp += strlen(sp) + 1;
d425 2
a426 2
	sc_return = ltgetstr("cr", &sp);
	if (sc_return == NULL)
d430 1
a430 1
	 * Choose between using "al" or "sr" ("add line" or "scroll reverse")
d433 2
a434 2
	t1 = ltgetstr("al", &sp);
	if (t1 == NULL)
d436 2
a437 2
	t2 = ltgetstr("sr", &sp);
	if (t2 == NULL)
a438 5
#if OS2
	if (*t1 == '\0' && *t2 == '\0')
		sc_addline = "";
	else
#endif
d443 1
a443 2
	if (*sc_addline == '\0')
	{
a448 1
#endif /* MSDOS_COMPILER */
a450 1
#if !MSDOS_COMPILER
d460 2
a461 4
/*ARGSUSED*/
	static int
inc_costcount(c)
	int c;
d467 2
a468 3
	static int
cost(t)
	char *t;
d471 1
a471 1
	tputs(t, sc_height, inc_costcount);
d477 1
a477 1
 * The best, if both exist, is the one with the lower 
d480 2
a481 4
	static char *
cheaper(t1, t2, def)
	char *t1, *t2;
	char *def;
d483 1
a483 2
	if (*t1 == '\0' && *t2 == '\0')
	{
d496 3
a498 9
	static void
tmodes(incap, outcap, instr, outstr, def_instr, def_outstr, spp)
	char *incap;
	char *outcap;
	char **instr;
	char **outstr;
	char *def_instr;
	char *def_outstr;
	char **spp;
d500 10
a509 3
	*instr = ltgetstr(incap, spp);
	if (*instr == NULL)
	{
a515 1
	*outstr = ltgetstr(outcap, spp);
d517 2
a518 2
		/* No specific out capability; use "me". */
		*outstr = ltgetstr("me", spp);
d520 1
a520 1
		/* Don't even have "me"; use a null string. */
a523 3
#endif /* MSDOS_COMPILER */


d525 1
a525 1
 * Below are the functions which perform all the 
a528 101

#if MSDOS_COMPILER

#if MSDOS_COMPILER==WIN32C
	static void
_settextposition(int row, int col)
{
	COORD cpos;
	CONSOLE_SCREEN_BUFFER_INFO csbi;

	GetConsoleScreenBufferInfo(con_out, &csbi);
	cpos.X = csbi.srWindow.Left + (col - 1);
	cpos.Y = csbi.srWindow.Top + (row - 1);
	SetConsoleCursorPosition(con_out, cpos);
}
#endif

/*
 * Initialize the screen to the correct color at startup.
 */
	static void
initcolor()
{
	SETCOLORS(nm_fg_color, nm_bg_color);
#if 0
	/*
	 * This clears the screen at startup.  This is different from
	 * the behavior of other versions of less.  Disable it for now.
	 */
	char *blanks;
	int row;
	int col;
	
	/*
	 * Create a complete, blank screen using "normal" colors.
	 */
	SETCOLORS(nm_fg_color, nm_bg_color);
	blanks = (char *) ecalloc(width+1, sizeof(char));
	for (col = 0;  col < sc_width;  col++)
		blanks[col] = ' ';
	blanks[sc_width] = '\0';
	for (row = 0;  row < sc_height;  row++)
		_outtext(blanks);
	free(blanks);
#endif
}
#endif

#if MSDOS_COMPILER==WIN32C

/*
 * Termcap-like init with a private win32 console.
 */
	static void
win32_init_term()
{
	CONSOLE_SCREEN_BUFFER_INFO scr;
	COORD size;

	if (con_out_save == INVALID_HANDLE_VALUE)
		return;

	GetConsoleScreenBufferInfo(con_out_save, &scr);

	if (con_out_ours == INVALID_HANDLE_VALUE)
	{
		/*
		 * Create our own screen buffer, so that we
		 * may restore the original when done.
		 */
		con_out_ours = CreateConsoleScreenBuffer(
			GENERIC_WRITE | GENERIC_READ,
			FILE_SHARE_WRITE | FILE_SHARE_READ,
			(LPSECURITY_ATTRIBUTES) NULL,
			CONSOLE_TEXTMODE_BUFFER,
			(LPVOID) NULL);
	}

	size.X = scr.srWindow.Right - scr.srWindow.Left + 1;
	size.Y = scr.srWindow.Bottom - scr.srWindow.Top + 1;
	SetConsoleScreenBufferSize(con_out_ours, size);
	SetConsoleActiveScreenBuffer(con_out_ours);
	con_out = con_out_ours;
}

/*
 * Restore the startup console.
 */
static void
win32_deinit_term()
{
	if (con_out_save == INVALID_HANDLE_VALUE)
		return;
	if (quitting)
		(void) CloseHandle(con_out_ours);
	SetConsoleActiveScreenBuffer(con_out_save);
	con_out = con_out_save;
}

#endif

d532 2
a533 2
	public void
init()
a534 1
#if !MSDOS_COMPILER
d536 1
a536 1
		tputs(sc_init, sc_height, putchr);
d538 2
a539 3
		tputs(sc_s_keypad, sc_height, putchr);
	if (top_scroll) 
	{
d549 1
a549 1
			putchr('\n');
a551 8
#else
#if MSDOS_COMPILER==WIN32C
	if (!no_init)
		win32_init_term();
#endif
	initcolor();
	flush();
#endif
d558 2
a559 2
	public void
deinit()
a562 1
#if !MSDOS_COMPILER
d564 1
a564 7
		tputs(sc_e_keypad, sc_height, putchr);
	if (!no_init)
		tputs(sc_deinit, sc_height, putchr);
#else
	/* Restore system colors. */
	SETCOLORS(sy_fg_color, sy_bg_color);
#if MSDOS_COMPILER==WIN32C
d566 1
a566 6
		win32_deinit_term();
#else
	/* Need clreol to make SETCOLORS take effect. */
	clreol();
#endif
#endif
d573 2
a574 2
	public void
home()
d576 1
a576 6
#if !MSDOS_COMPILER
	tputs(sc_home, 1, putchr);
#else
	flush();
	_settextposition(1,1);
#endif
d583 2
a584 146
	public void
add_line()
{
#if !MSDOS_COMPILER
	tputs(sc_addline, sc_height, putchr);
#else
	flush();
#if MSDOS_COMPILER==MSOFTC
	_scrolltextwindow(_GSCROLLDOWN);
	_settextposition(1,1);
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
	movetext(1,1, sc_width,sc_height-1, 1,2);
	gotoxy(1,1);
	clreol();
#else
#if MSDOS_COMPILER==WIN32C
    {
	CHAR_INFO fillchar;
	SMALL_RECT rcSrc, rcClip;
	COORD new_org;
	CONSOLE_SCREEN_BUFFER_INFO csbi;

	GetConsoleScreenBufferInfo(con_out,&csbi);

	/* The clip rectangle is the entire visible screen. */
	rcClip.Left = csbi.srWindow.Left;
	rcClip.Top = csbi.srWindow.Top;
	rcClip.Right = csbi.srWindow.Right;
	rcClip.Bottom = csbi.srWindow.Bottom;

	/* The source rectangle is the visible screen minus the last line. */
	rcSrc = rcClip;
	rcSrc.Bottom--;

	/* Move the top left corner of the source window down one row. */
	new_org.X = rcSrc.Left;
	new_org.Y = rcSrc.Top + 1;

	/* Fill the right character and attributes. */
	fillchar.Char.AsciiChar = ' ';
	curr_attr = MAKEATTR(nm_fg_color, nm_bg_color);
	fillchar.Attributes = curr_attr;
	ScrollConsoleScreenBuffer(con_out, &rcSrc, &rcClip, new_org, &fillchar);
	_settextposition(1,1);
    }
#endif
#endif
#endif
#endif
}

#if 0
/*
 * Remove the n topmost lines and scroll everything below it in the 
 * window upward.  This is needed to stop leaking the topmost line 
 * into the scrollback buffer when we go down-one-line (in WIN32).
 */
	public void
remove_top(n)
	int n;
{
#if MSDOS_COMPILER==WIN32C
	SMALL_RECT rcSrc, rcClip;
	CHAR_INFO fillchar;
	COORD new_org;
	CONSOLE_SCREEN_BUFFER_INFO csbi; /* to get buffer info */

	if (n >= sc_height - 1)
	{
		clear();
		home();
		return;
	}

	flush();

	GetConsoleScreenBufferInfo(con_out, &csbi);

	/* Get the extent of all-visible-rows-but-the-last. */
	rcSrc.Left    = csbi.srWindow.Left;
	rcSrc.Top     = csbi.srWindow.Top + n;
	rcSrc.Right   = csbi.srWindow.Right;
	rcSrc.Bottom  = csbi.srWindow.Bottom;

	/* Get the clip rectangle. */
	rcClip.Left   = rcSrc.Left;
	rcClip.Top    = csbi.srWindow.Top;
	rcClip.Right  = rcSrc.Right;
	rcClip.Bottom = rcSrc.Bottom ;

	/* Move the source window up n rows. */
	new_org.X = rcSrc.Left;
	new_org.Y = rcSrc.Top - n;

	/* Fill the right character and attributes. */
	fillchar.Char.AsciiChar = ' ';
	curr_attr = MAKEATTR(nm_fg_color, nm_bg_color);
	fillchar.Attributes = curr_attr;

	ScrollConsoleScreenBuffer(con_out, &rcSrc, &rcClip, new_org, &fillchar);

	/* Position cursor on first blank line. */
	goto_line(sc_height - n - 1);
#endif
}
#endif

#if MSDOS_COMPILER==WIN32C
/*
 * Clear the screen.
 */
	static void
win32_clear()
{
	/*
	 * This will clear only the currently visible rows of the NT
	 * console buffer, which means none of the precious scrollback
	 * rows are touched making for faster scrolling.  Note that, if
	 * the window has fewer columns than the console buffer (i.e.
	 * there is a horizontal scrollbar as well), the entire width
	 * of the visible rows will be cleared.
	 */
	COORD topleft;
	DWORD nchars;
	DWORD winsz;
	CONSOLE_SCREEN_BUFFER_INFO csbi;

	/* get the number of cells in the current buffer */
	GetConsoleScreenBufferInfo(con_out, &csbi);
	winsz = csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.srWindow.Top + 1);
	topleft.X = 0;
	topleft.Y = csbi.srWindow.Top;

	curr_attr = MAKEATTR(nm_fg_color, nm_bg_color);
	FillConsoleOutputCharacter(con_out, ' ', winsz, topleft, &nchars);
	FillConsoleOutputAttribute(con_out, curr_attr, winsz, topleft, &nchars);
}

/*
 * Remove the n topmost lines and scroll everything below it in the 
 * window upward.
 */
	public void
win32_scroll_up(n)
	int n;
d586 1
a586 56
	SMALL_RECT rcSrc, rcClip;
	CHAR_INFO fillchar;
	COORD topleft;
	COORD new_org;
	DWORD nchars;
	DWORD size;
	CONSOLE_SCREEN_BUFFER_INFO csbi;

	if (n <= 0)
		return;

	if (n >= sc_height - 1)
	{
		win32_clear();
		_settextposition(1,1);
		return;
	}

	/* Get the extent of what will remain visible after scrolling. */
	GetConsoleScreenBufferInfo(con_out, &csbi);
	rcSrc.Left    = csbi.srWindow.Left;
	rcSrc.Top     = csbi.srWindow.Top + n;
	rcSrc.Right   = csbi.srWindow.Right;
	rcSrc.Bottom  = csbi.srWindow.Bottom;

	/* Get the clip rectangle. */
	rcClip.Left   = rcSrc.Left;
	rcClip.Top    = csbi.srWindow.Top;
	rcClip.Right  = rcSrc.Right;
	rcClip.Bottom = rcSrc.Bottom ;

	/* Move the source text to the top of the screen. */
	new_org.X = rcSrc.Left;
	new_org.Y = rcClip.Top;

	/* Fill the right character and attributes. */
	fillchar.Char.AsciiChar = ' ';
	fillchar.Attributes = MAKEATTR(nm_fg_color, nm_bg_color);

	/* Scroll the window. */
	SetConsoleTextAttribute(con_out, fillchar.Attributes);
	ScrollConsoleScreenBuffer(con_out, &rcSrc, &rcClip, new_org, &fillchar);

	/* Clear remaining lines at bottom. */
	topleft.X = csbi.dwCursorPosition.X;
	topleft.Y = rcSrc.Bottom - n;
	size = (n * csbi.dwSize.X) + (rcSrc.Right - topleft.X);
	FillConsoleOutputCharacter(con_out, ' ', size, topleft,
		&nchars);
	FillConsoleOutputAttribute(con_out, fillchar.Attributes, size, topleft,
		&nchars);
	SetConsoleTextAttribute(con_out, curr_attr);

	/* Move cursor n lines up from where it was. */
	csbi.dwCursorPosition.Y -= n;
	SetConsoleCursorPosition(con_out, csbi.dwCursorPosition);
a587 1
#endif
d592 2
a593 2
	public void
lower_left()
d595 1
a595 6
#if !MSDOS_COMPILER
	tputs(sc_lower_left, 1, putchr);
#else
	flush();
	_settextposition(sc_height, 1);
#endif
d601 2
a602 2
	public void
line_left()
d604 1
a604 23
#if !MSDOS_COMPILER
	tputs(sc_return, 1, putchr);
#else
	int row;
	flush();
#if MSDOS_COMPILER==WIN32C
	{
		CONSOLE_SCREEN_BUFFER_INFO scr;
		GetConsoleScreenBufferInfo(con_out, &scr);
		row = scr.dwCursorPosition.Y - scr.srWindow.Top + 1;
	}
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
		row = wherey();
#else
	{
		struct rccoord tpos = _gettextposition();
		row = tpos.row;
	}
#endif
#endif
	_settextposition(row, 1);
#endif
d608 1
a608 2
 * Check if the console size has changed and reset internals 
 * (in lieu of SIGWINCH for WIN32).
d610 2
a611 2
	public void
check_winch()
d613 2
a614 99
#if MSDOS_COMPILER==WIN32C
	CONSOLE_SCREEN_BUFFER_INFO scr;
	COORD size;

	if (con_out == INVALID_HANDLE_VALUE)
		return;
 
	flush();
	GetConsoleScreenBufferInfo(con_out, &scr);
	size.Y = scr.srWindow.Bottom - scr.srWindow.Top + 1;
	size.X = scr.srWindow.Right - scr.srWindow.Left + 1;
	if (size.Y != sc_height || size.X != sc_width)
	{
		sc_height = size.Y;
		sc_width = size.X;
		if (!no_init && con_out_ours == con_out)
			SetConsoleScreenBufferSize(con_out, size);
		pos_init();
		wscroll = (sc_height + 1) / 2;
		screen_trashed = 1;
	}
#endif
}

/*
 * Goto a specific line on the screen.
 */
	public void
goto_line(slinenum)
	int slinenum;
{
#if !MSDOS_COMPILER
	tputs(tgoto(sc_move, 0, slinenum), 1, putchr);
#else
	flush();
	_settextposition(slinenum+1, 1);
#endif
}

#if MSDOS_COMPILER==MSOFTC || MSDOS_COMPILER==BORLANDC
/*
 * Create an alternate screen which is all white.
 * This screen is used to create a "flash" effect, by displaying it
 * briefly and then switching back to the normal screen.
 * {{ Yuck!  There must be a better way to get a visual bell. }}
 */
	static void
create_flash()
{
#if MSDOS_COMPILER==MSOFTC
	struct videoconfig w;
	char *blanks;
	int row, col;
	
	_getvideoconfig(&w);
	videopages = w.numvideopages;
	if (videopages < 2)
	{
		at_enter(AT_STANDOUT);
		at_exit();
	} else
	{
		_setactivepage(1);
		at_enter(AT_STANDOUT);
		blanks = (char *) ecalloc(w.numtextcols, sizeof(char));
		for (col = 0;  col < w.numtextcols;  col++)
			blanks[col] = ' ';
		for (row = w.numtextrows;  row > 0;  row--)
			_outmem(blanks, w.numtextcols);
		_setactivepage(0);
		_setvisualpage(0);
		free(blanks);
		at_exit();
	}
#else
#if MSDOS_COMPILER==BORLANDC
	register int n;

	whitescreen = (unsigned short *) 
		malloc(sc_width * sc_height * sizeof(short));
	if (whitescreen == NULL)
		return;
	for (n = 0;  n < sc_width * sc_height;  n++)
		whitescreen[n] = 0x7020;
#else
#if MSDOS_COMPILER==WIN32C
	register int n;

	whitescreen = (WORD *)
		malloc(sc_height * sc_width * sizeof(WORD));
	if (whitescreen == NULL)
		return;
	/* Invert the standard colors. */
	for (n = 0;  n < sc_width * sc_height;  n++)
		whitescreen[n] = (WORD)((nm_fg_color << 4) | nm_bg_color);
#endif
#endif
#endif
	flash_created = 1;
a615 1
#endif /* MSDOS_COMPILER */
d620 2
a621 2
	public void
vbell()
a622 1
#if !MSDOS_COMPILER
d625 1
a625 53
	tputs(sc_visual_bell, sc_height, putchr);
#else
#if MSDOS_COMPILER==DJGPPC
	ScreenVisualBell();
#else
#if MSDOS_COMPILER==MSOFTC
	/*
	 * Create a flash screen on the second video page.
	 * Switch to that page, then switch back.
	 */
	if (!flash_created)
		create_flash();
	if (videopages < 2)
		return;
	_setvisualpage(1);
	delay(100);
	_setvisualpage(0);
#else
#if MSDOS_COMPILER==BORLANDC
	unsigned short *currscreen;

	/*
	 * Get a copy of the current screen.
	 * Display the flash screen.
	 * Then restore the old screen.
	 */
	if (!flash_created)
		create_flash();
	if (whitescreen == NULL)
		return;
	currscreen = (unsigned short *) 
		malloc(sc_width * sc_height * sizeof(short));
	if (currscreen == NULL) return;
	gettext(1, 1, sc_width, sc_height, currscreen);
	puttext(1, 1, sc_width, sc_height, whitescreen);
	delay(100);
	puttext(1, 1, sc_width, sc_height, currscreen);
	free(currscreen);
#else
#if MSDOS_COMPILER==WIN32C
	/* paint screen with an inverse color */
	clear();

	/* leave it displayed for 100 msec. */
	Sleep(100);

	/* restore with a redraw */
	repaint();
#endif
#endif
#endif
#endif
#endif
d631 2
a632 2
	static void
beep()
d634 1
a634 9
#if !MSDOS_COMPILER
	putchr(CONTROL('G'));
#else
#if MSDOS_COMPILER==WIN32C
	MessageBeep(0);
#else
	write(STDOUT_FILENO, "\7", 1);
#endif
#endif
d640 2
a641 2
	public void
bell()
d652 2
a653 2
	public void
clear()
d655 1
a655 10
#if !MSDOS_COMPILER
	tputs(sc_clear, sc_height, putchr);
#else
	flush();
#if MSDOS_COMPILER==WIN32C
	win32_clear();
#else
	_clearscreen(_GCLEARSCREEN);
#endif
#endif
d662 2
a663 2
	public void
clear_eol()
d665 1
a665 50
#if !MSDOS_COMPILER
	tputs(sc_eol_clear, 1, putchr);
#else
#if MSDOS_COMPILER==MSOFTC
	short top, left;
	short bot, right;
	struct rccoord tpos;
	
	flush();
	/*
	 * Save current state.
	 */
	tpos = _gettextposition();
	_gettextwindow(&top, &left, &bot, &right);
	/*
	 * Set a temporary window to the current line,
	 * from the cursor's position to the right edge of the screen.
	 * Then clear that window.
	 */
	_settextwindow(tpos.row, tpos.col, tpos.row, sc_width);
	_clearscreen(_GWINDOW);
	/*
	 * Restore state.
	 */
	_settextwindow(top, left, bot, right);
	_settextposition(tpos.row, tpos.col);
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
	flush();
	clreol();
#else
#if MSDOS_COMPILER==WIN32C
	DWORD           nchars;
	COORD           cpos;
	CONSOLE_SCREEN_BUFFER_INFO scr;

	flush();
	memset(&scr, 0, sizeof(scr));
	GetConsoleScreenBufferInfo(con_out, &scr);
	cpos.X = scr.dwCursorPosition.X;
	cpos.Y = scr.dwCursorPosition.Y;
	curr_attr = MAKEATTR(nm_fg_color, nm_bg_color);
	FillConsoleOutputAttribute(con_out, curr_attr,
		scr.dwSize.X - cpos.X, cpos, &nchars);
	FillConsoleOutputCharacter(con_out, ' ',
		scr.dwSize.X - cpos.X, cpos, &nchars);
#endif
#endif
#endif
#endif
d672 2
a673 2
	static void
clear_eol_bot()
a674 3
#if MSDOS_COMPILER
	clear_eol();
#else
d676 1
a676 1
		tputs(sc_eos_clear, 1, putchr);
d678 1
a678 2
		tputs(sc_eol_clear, 1, putchr);
#endif
d685 2
a686 2
	public void
clear_bot()
d710 2
a711 3
	public void
at_enter(attr)
	int attr;
a714 1
#if !MSDOS_COMPILER
d717 1
a717 1
		tputs(sc_u_in, 1, putchr);
d719 1
a719 1
		tputs(sc_b_in, 1, putchr);
d721 1
a721 6
		tputs(sc_bl_in, 1, putchr);
	if (attr & AT_STANDOUT)
		tputs(sc_s_in, 1, putchr);
#else
	flush();
	/* The one with the most priority is first.  */
d723 1
a723 15
	{
		SETCOLORS(so_fg_color, so_bg_color);
	} else if (attr & AT_BLINK)
	{
		SETCOLORS(bl_fg_color, bl_bg_color);
	}
	else if (attr & AT_BOLD)
	{
		SETCOLORS(bo_fg_color, bo_bg_color);
	}
	else if (attr & AT_UNDERLINE)
	{
		SETCOLORS(ul_fg_color, ul_bg_color);
	}
#endif
d728 2
a729 2
	public void
at_exit()
a730 1
#if !MSDOS_COMPILER
d733 1
a733 1
		tputs(sc_s_out, 1, putchr);
d735 1
a735 1
		tputs(sc_bl_out, 1, putchr);
d737 1
a737 1
		tputs(sc_b_out, 1, putchr);
d739 1
a739 5
		tputs(sc_u_out, 1, putchr);
#else
	flush();
	SETCOLORS(nm_fg_color, nm_bg_color);
#endif
d744 2
a745 3
	public void
at_switch(attr)
	int attr;
d750 1
a750 2
	if ((new_attrmode & ~ignore_modes) != (attrmode & ~ignore_modes))
	{
d756 2
a757 4
	public int
is_at_equiv(attr1, attr2)
	int attr1;
	int attr2;
d765 2
a766 3
	public int
apply_at_specials(attr)
	int attr;
d774 1
a774 51
	return attr;
}

#if 0 /* No longer used */
/*
 * Erase the character to the left of the cursor 
 * and move the cursor left.
 */
	public void
backspace()
{
#if !MSDOS_COMPILER
	/* 
	 * Erase the previous character by overstriking with a space.
	 */
	tputs(sc_backspace, 1, putchr);
	putchr(' ');
	tputs(sc_backspace, 1, putchr);
#else
#if MSDOS_COMPILER==MSOFTC
	struct rccoord tpos;
	
	flush();
	tpos = _gettextposition();
	if (tpos.col <= 1)
		return;
	_settextposition(tpos.row, tpos.col-1);
	_outtext(" ");
	_settextposition(tpos.row, tpos.col-1);
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
	cputs("\b");
#else
#if MSDOS_COMPILER==WIN32C
	COORD cpos;
	DWORD cChars;
	CONSOLE_SCREEN_BUFFER_INFO scr;

	flush();
	GetConsoleScreenBufferInfo(con_out, &scr);
	cpos = scr.dwCursorPosition;
	if (cpos.X <= 0)
		return;
	cpos.X--;
	SetConsoleCursorPosition(con_out, cpos);
	FillConsoleOutputCharacter(con_out, (TCHAR)' ', 1, cpos, &cChars);
	SetConsoleCursorPosition(con_out, cpos);
#endif
#endif
#endif
#endif
a775 1
#endif /* 0 */
d780 2
a781 152
	public void
putbs()
{
#if !MSDOS_COMPILER
	tputs(sc_backspace, 1, putchr);
#else
	int row, col;

	flush();
	{
#if MSDOS_COMPILER==MSOFTC
		struct rccoord tpos;
		tpos = _gettextposition();
		row = tpos.row;
		col = tpos.col;
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
		row = wherey();
		col = wherex();
#else
#if MSDOS_COMPILER==WIN32C
		CONSOLE_SCREEN_BUFFER_INFO scr;
		GetConsoleScreenBufferInfo(con_out, &scr);
		row = scr.dwCursorPosition.Y - scr.srWindow.Top + 1;
		col = scr.dwCursorPosition.X - scr.srWindow.Left + 1;
#endif
#endif
#endif
	}
	if (col <= 1)
		return;
	_settextposition(row, col-1);
#endif /* MSDOS_COMPILER */
}

#if MSDOS_COMPILER==WIN32C
/*
 * Determine whether an input character is waiting to be read.
 */
	static int
win32_kbhit(tty)
	HANDLE tty;
{
	INPUT_RECORD ip;
	DWORD read;

	if (keyCount > 0)
		return (TRUE);

	currentKey.ascii = 0;
	currentKey.scan = 0;

	/*
	 * Wait for a real key-down event, but
	 * ignore SHIFT and CONTROL key events.
	 */
	do
	{
		PeekConsoleInput(tty, &ip, 1, &read);
		if (read == 0)
			return (FALSE);
		ReadConsoleInput(tty, &ip, 1, &read);
	} while (ip.EventType != KEY_EVENT ||
		ip.Event.KeyEvent.bKeyDown != TRUE ||
		ip.Event.KeyEvent.wVirtualScanCode == 0 ||
		ip.Event.KeyEvent.wVirtualKeyCode == VK_SHIFT ||
		ip.Event.KeyEvent.wVirtualKeyCode == VK_CONTROL ||
		ip.Event.KeyEvent.wVirtualKeyCode == VK_MENU);
		
	currentKey.ascii = ip.Event.KeyEvent.uChar.AsciiChar;
	currentKey.scan = ip.Event.KeyEvent.wVirtualScanCode;
	keyCount = ip.Event.KeyEvent.wRepeatCount;

	if (ip.Event.KeyEvent.dwControlKeyState & 
		(LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED))
	{
		switch (currentKey.scan)
		{
		case PCK_ALT_E:     /* letter 'E' */
			currentKey.ascii = 0;
			break;
		}
	} else if (ip.Event.KeyEvent.dwControlKeyState & 
		(LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED))
	{
		switch (currentKey.scan)
		{
		case PCK_RIGHT: /* right arrow */
			currentKey.scan = PCK_CTL_RIGHT;
			break;
		case PCK_LEFT: /* left arrow */
			currentKey.scan = PCK_CTL_LEFT;
			break;
		case PCK_DELETE: /* delete */
			currentKey.scan = PCK_CTL_DELETE;
			break;
		}
	}
	return (TRUE);
}

/*
 * Read a character from the keyboard.
 */
	public char
WIN32getch(tty)
	int tty;
{
	int ascii;

	if (pending_scancode)
	{
		pending_scancode = 0;
		return ((char)(currentKey.scan & 0x00FF));
	}

	while (win32_kbhit((HANDLE)tty) == FALSE)
	{
		Sleep(20);
		if (ABORT_SIGS())
			return ('\003');
		continue;
	}
	keyCount --;
	ascii = currentKey.ascii;
	/*
	 * On PC's, the extended keys return a 2 byte sequence beginning 
	 * with '00', so if the ascii code is 00, the next byte will be 
	 * the lsb of the scan code.
	 */
	pending_scancode = (ascii == 0x00);
	return ((char)ascii);
}
#endif

#if MSDOS_COMPILER
/*
 */
	public void
WIN32setcolors(fg, bg)
	int fg;
	int bg;
{
	SETCOLORS(fg, bg);
}

/*
 */
	public void
WIN32textout(text, len)
	char *text;
	int len;
d783 1
a783 9
#if MSDOS_COMPILER==WIN32C
	DWORD written;
	WriteConsole(con_out, text, len, &written, NULL);
#else
	char c = text[len];
	text[len] = '\0';
	cputs(text);
	text[len] = c;
#endif
a784 1
#endif
@


1.16
log
@Use volatile sig_atomic_t, not int, for the sigs variable.  Also
move the call to bell() out of u_interrupt() (a signal handler).
OK and with help from deraadt@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d806 1
a806 1
	else
d817 1
a817 1
	else
@


1.15
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d231 1
a231 1
extern int sigs;
@


1.14
log
@use STDERR_FILENO; ok cloder
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
a40 2
#if HAVE_TERMIOS_H && HAVE_TERMIOS_FUNCS
#include <termios.h>
d44 3
a55 3
#if HAVE_SYS_IOCTL_H && (defined(TIOCGWINSZ) || defined(TCGETA) || defined(TIOCGETP) || defined(WIOCGETD))
#include <sys/ioctl.h>
#endif
d166 1
d191 3
a193 1
public int erase_char, kill_char; /* The user's erase and line-kill chars */
d206 1
d235 2
a236 2
extern int quit_at_eof;
extern int ismore;
d264 1
d347 3
d626 1
d628 19
d1153 1
a1153 1
 	if (tgetent(termbuf, term) <= 0)
d1214 1
a1214 9
	/*
	 * This loses for terminals with termcap entries with ti/te strings
	 * that switch to/from an alternate screen, and we're in quit_at_eof
	 * (eg, more(1)).
	 */
	if (!quit_at_eof && !ismore) {
		sc_init = ltgetstr("ti", &sp);
		sc_deinit= ltgetstr("te", &sp);
	}
d1218 1
d1233 1
a1233 1
		sc_eol_clear = "";
d1310 7
d1545 14
d1795 1
a1795 1
	new_org.Y = 0;
d1836 31
d1931 2
a1932 2
		so_enter();
		so_exit();
d1936 1
a1936 1
		so_enter();
d1945 1
a1945 1
		so_exit();
d2174 8
a2181 2
	lower_left();
	switch (attrmode)
d2183 3
a2185 12
	case AT_STANDOUT:
		so_exit();
		clear_eol_bot();
		so_enter();
		break;
	case AT_UNDERLINE:
		ul_exit();
		clear_eol_bot();
		ul_enter();
		break;
	case AT_BOLD:
		bo_exit();
d2187 1
a2187 10
		bo_enter();
		break;
	case AT_BLINK:
		bl_exit();
		clear_eol_bot();
		bl_enter();
		break;
	default:
		clear_eol_bot();
		break;
a2190 3
/*
 * Begin "standout" (bold, underline, or whatever).
 */
d2192 2
a2193 1
so_enter()
d2195 2
d2198 9
a2206 1
	tputs(sc_s_in, 1, putchr);
d2209 16
a2224 1
	SETCOLORS(so_fg_color, so_bg_color);
d2226 2
a2227 1
	attrmode = AT_STANDOUT;
a2229 3
/*
 * End "standout".
 */
d2231 1
a2231 1
so_exit()
d2234 9
a2242 1
	tputs(sc_s_out, 1, putchr);
d2247 1
a2250 4
/*
 * Begin "underline" (hopefully real underlining, 
 * otherwise whatever the terminal provides).
 */
d2252 2
a2253 1
ul_enter()
d2255 2
a2256 8
#if !MSDOS_COMPILER
	tputs(sc_u_in, 1, putchr);
#else
	flush();
	SETCOLORS(ul_fg_color, ul_bg_color);
#endif
	attrmode = AT_UNDERLINE;
}
d2258 5
a2262 13
/*
 * End "underline".
 */
	public void
ul_exit()
{
#if !MSDOS_COMPILER
	tputs(sc_u_out, 1, putchr);
#else
	flush();
	SETCOLORS(nm_fg_color, nm_bg_color);
#endif
	attrmode = AT_NORMAL;
d2265 4
a2268 5
/*
 * Begin "bold"
 */
	public void
bo_enter()
d2270 2
a2271 8
#if !MSDOS_COMPILER
	tputs(sc_b_in, 1, putchr);
#else
	flush();
	SETCOLORS(bo_fg_color, bo_bg_color);
#endif
	attrmode = AT_BOLD;
}
d2273 1
a2273 13
/*
 * End "bold".
 */
	public void
bo_exit()
{
#if !MSDOS_COMPILER
	tputs(sc_b_out, 1, putchr);
#else
	flush();
	SETCOLORS(nm_fg_color, nm_bg_color);
#endif
	attrmode = AT_NORMAL;
d2276 3
a2278 5
/*
 * Begin "blink"
 */
	public void
bl_enter()
d2280 5
a2284 8
#if !MSDOS_COMPILER
	tputs(sc_bl_in, 1, putchr);
#else
	flush();
	SETCOLORS(bl_fg_color, bl_bg_color);
#endif
	attrmode = AT_BLINK;
}
d2286 1
a2286 13
/*
 * End "blink".
 */
	public void
bl_exit()
{
#if !MSDOS_COMPILER
	tputs(sc_bl_out, 1, putchr);
#else
	flush();
	SETCOLORS(nm_fg_color, nm_bg_color);
#endif
	attrmode = AT_NORMAL;
d2475 30
@


1.13
log
@Call fsync() _after_ tcsetattr() and pass tcsetattr the TCSASOFT
flag.  Seems to help the occasional problem with messed up terminal
input after suspending less.
@
text
@d1980 1
a1980 1
	write(1, "\7", 1);
@


1.12
log
@another round of missing system includes
ok tedu@@
@
text
@d428 1
a431 1
	tcsetattr(tty, TCSADRAIN, &s);
@


1.11
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d43 1
a43 1
#if HAVE_SYS_IOCTL_H && !defined(TIOCGWINSZ)
@


1.10
log
@more strlcpy/strlcat/snprintf, less strcpy/strcat/sprintf
reviewed by tdeval, millert, dhartmei and others.  more bits coming here
from some of them i think
@
text
@a0 2
/*	$OpenBSD: screen.c,v 1.9 2003/04/05 01:03:35 deraadt Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a14 2
 *
 * {{ Maybe someday this should be rewritten to use curses or terminfo. }}
d20 21
d50 3
d54 1
d60 1
d64 4
a67 7

#ifndef TIOCGWINSZ
/*
 * For the Unix PC (ATT 7300 & 3B1):
 * Since WIOCGETD is defined in sys/window.h, we can't use that to decide
 * whether to include sys/window.h.  Use SIGPHONE from sys/signal.h instead.
 */
d69 1
a69 3
#ifdef SIGPHONE
#include <sys/window.h>
#endif
a70 1

d78 12
d92 1
d97 63
d186 1
a188 1
static int tty_fd = -1;
d201 4
d206 1
d208 2
d219 4
d225 1
a225 2
extern int know_dumb;		/* Don't complain about a dumb terminal */
extern int back_scroll;
d228 5
d234 1
a234 1
extern int more_mode;
a261 9

	if (tty_fd == -1 && (tty_fd = open("/dev/tty", O_RDWR)) < 0)
		tty_fd = 2;

#if OS2
	signal(SIGINT, SIG_IGN);
	erase_char = '\b';
	kill_char = '\033';
#else
d266 1
d273 1
a273 2
		if (tcgetattr(tty_fd, &s) == -1)
			return;
d278 5
a282 1
		save_term = s;
d348 1
a348 1
		werase_char = 0;
d373 2
a374 2
#ifdef XTABS
			| XTABS
d379 2
a380 2
#ifdef OXTABS
			| OXTABS
d408 13
d428 16
a443 2
	if (tcsetattr(tty_fd, TCSANOW, &s) == -1)
		return;
d450 1
d457 1
a457 1
		ioctl(tty_fd, TCGETA, &s);
d462 5
a466 1
		save_term = s;
d475 1
a475 1
		werase_char = 0;
d493 1
a493 1
	ioctl(tty_fd, TCSETAW, &s);
d496 1
d500 1
d507 1
a507 1
		ioctl(tty_fd, TIOCGETP, &s);
d512 5
a516 1
		save_term = s;
d522 1
a522 1
		werase_char = 0;
d536 43
a578 1
	ioctl(tty_fd, TIOCSETN, &s);
d580 23
d609 9
a617 3
	static void
cannot(s)
	char *s;
d619 1
a619 8
	PARG parg;

	if (know_dumb || more_mode)
		/* 
		 * User knows this is a dumb terminal, so don't tell him.
		 * more doesn't complain about these, either.
		 */
		return;
d621 3
a623 2
	parg.p_string = s;
	error("WARNING: terminal cannot %s", &parg);
d626 3
a628 6
/*
 * Get size of the output screen.
 */
#if OS2
	public void
scrsize()
d630 1
a630 1
	int s[2];
d632 5
a636 3
	_scrsize(s);
	sc_width = s[0];
	sc_height = s[1];
d639 3
a641 4
#else

	public void
scrsize()
a643 7
#ifdef TIOCGWINSZ
	struct winsize w;
#else
#ifdef WIOCGETD
	struct uwdata w;
#endif
#endif
d645 6
a650 2
	if (tty_fd == -1 && (tty_fd = open("/dev/tty", O_RDWR)) < 0)
		tty_fd = 2;
d652 6
a657 33
#ifdef TIOCGWINSZ
	if (ioctl(tty_fd, TIOCGWINSZ, &w) == 0 && w.ws_row > 0)
		sc_height = w.ws_row;
	else
#else
#ifdef WIOCGETD
	if (ioctl(tty_fd, WIOCGETD, &w) == 0 && w.uw_height > 0)
		sc_height = w.uw_height/w.uw_vs;
	else
#endif
#endif
	if ((s = getenv("LINES")) != NULL)
		sc_height = atoi(s);
	else
 		sc_height = tgetnum("li");

	if (sc_height <= 0)
		sc_height = 24;

#ifdef TIOCGWINSZ
 	if (ioctl(tty_fd, TIOCGWINSZ, &w) == 0 && w.ws_col > 0)
		sc_width = w.ws_col;
	else
#ifdef WIOCGETD
	if (ioctl(tty_fd, WIOCGETD, &w) == 0 && w.uw_width > 0)
		sc_width = w.uw_width/w.uw_hs;
	else
#endif
#endif
	if ((s = getenv("COLUMNS")) != NULL)
		sc_width = atoi(s);
	else
 		sc_width = tgetnum("co");
d659 5
a663 2
 	if (sc_width <= 0)
  		sc_width = 80;
d665 1
a665 1
#endif /* OS2 */
d668 1
a668 4
 * Take care of the "variable" keys.
 * Certain keys send escape sequences which differ on different terminals
 * (such as the arrow keys, INSERT, DELETE, etc.)
 * Construct the commands based on these keys.
d671 1
a671 1
get_editkeys()
d673 6
a678 3
	char *sp;
	char *s;
	char tbuf[40];
d680 6
a685 12
	static char kfcmdtable[400];
	int sz_kfcmdtable = 0;
	static char kecmdtable[400];
	int sz_kecmdtable = 0;

#define	put_cmd(str,action,tbl,sz) { \
	strcpy(tbl+sz, str);	\
	sz += strlen(str) + 1;	\
	tbl[sz++] = action; }
#define	put_esc_cmd(str,action,tbl,sz) { \
	tbl[sz++] = ESC; \
	put_cmd(str,action,tbl,sz); }
a686 4
#define	put_fcmd(str,action)	put_cmd(str,action,kfcmdtable,sz_kfcmdtable)
#define	put_ecmd(str,action)	put_cmd(str,action,kecmdtable,sz_kecmdtable)
#define	put_esc_fcmd(str,action) put_esc_cmd(str,action,kfcmdtable,sz_kfcmdtable)
#define	put_esc_ecmd(str,action) put_esc_cmd(str,action,kecmdtable,sz_kecmdtable)
d688 1
a688 4
	/*
	 * Look at some interesting keys and see what strings they send.
	 * Create commands (both command keys and line-edit keys).
	 */
d690 1
a690 3
	/* RIGHT ARROW */
	sp = tbuf;
	if ((s = tgetstr("kr", &sp)) != NULL)
d692 4
a695 2
		put_ecmd(s, EC_RIGHT);
		put_esc_ecmd(s, EC_W_RIGHT);
d697 2
a698 4
	
	/* LEFT ARROW */
	sp = tbuf;
	if ((s = tgetstr("kl", &sp)) != NULL)
d700 4
a703 2
		put_ecmd(s, EC_LEFT);
		put_esc_ecmd(s, EC_W_LEFT);
d705 2
a706 4
	
	/* UP ARROW */
	sp = tbuf;
	if ((s = tgetstr("ku", &sp)) != NULL) 
d708 4
a711 2
		put_ecmd(s, EC_UP);
		put_fcmd(s, A_B_LINE);
d713 2
a714 4
		
	/* DOWN ARROW */
	sp = tbuf;
	if ((s = tgetstr("kd", &sp)) != NULL) 
d716 25
a740 2
		put_ecmd(s, EC_DOWN);
		put_fcmd(s, A_F_LINE);
d742 2
a743 4

	/* PAGE UP */
	sp = tbuf;
	if ((s = tgetstr("kP", &sp)) != NULL) 
d745 8
a752 1
		put_fcmd(s, A_B_SCREEN);
d754 2
a755 4

	/* PAGE DOWN */
	sp = tbuf;
	if ((s = tgetstr("kN", &sp)) != NULL) 
d757 8
a764 8
		put_fcmd(s, A_F_SCREEN);
	}
	
	/* HOME */
	sp = tbuf;
	if ((s = tgetstr("kh", &sp)) != NULL) 
	{
		put_ecmd(s, EC_HOME);
d766 6
d773 10
a782 6
	/* END */
	sp = tbuf;
	if ((s = tgetstr("@@7", &sp)) != NULL) 
	{
		put_ecmd(s, EC_END);
	}
d784 11
a794 24
	/* DELETE */
	sp = tbuf;
	if ((s = tgetstr("kD", &sp)) == NULL) 
	{
		/* Use DEL (\177) if no "kD" termcap. */
		tbuf[1] = '\177';
		tbuf[2] = '\0';
		s = tbuf+1;
	}
	put_ecmd(s, EC_DELETE);
	put_esc_ecmd(s, EC_W_DELETE);
		
	/* BACKSPACE */
	tbuf[0] = ESC;
	tbuf[1] = erase_char;
	tbuf[2] = '\0';
	put_ecmd(tbuf, EC_W_BACKSPACE);

	if (werase_char != 0)
	{
		tbuf[0] = werase_char;
		tbuf[1] = '\0';
		put_ecmd(tbuf, EC_W_BACKSPACE);
	}
d796 22
d819 1
a819 1
	 * Register the two tables.
d821 12
a832 2
	add_fcmd_table(kfcmdtable, sz_kfcmdtable);
	add_ecmd_table(kecmdtable, sz_kecmdtable);
a834 1
#if DEBUG
d836 2
a837 1
get_debug_term()
d839 13
a851 27
	auto_wrap = 1;
	ignaw = 1;
	so_s_width = so_e_width = 0;
	bo_s_width = bo_e_width = 0;
	ul_s_width = ul_e_width = 0;
	bl_s_width = bl_e_width = 0;
	sc_s_keypad =	"(InitKey)";
	sc_e_keypad =	"(DeinitKey)";
	sc_init =	"(InitTerm)";
	sc_deinit =	"(DeinitTerm)";
	sc_eol_clear =	"(ClearEOL)";
	sc_eos_clear =	"(ClearEOS)";
	sc_clear =	"(ClearScreen)";
	sc_move =	"(Move<%d,%d>)";
	sc_s_in =	"(SO+)";
	sc_s_out =	"(SO-)";
	sc_u_in =	"(UL+)";
	sc_u_out =	"(UL-)";
	sc_b_in =	"(BO+)";
	sc_b_out =	"(BO-)";
	sc_bl_in =	"(BL+)";
	sc_bl_out =	"(BL-)";
	sc_visual_bell ="(VBell)";
	sc_backspace =	"(BS)";
	sc_home =	"(Home)";
	sc_lower_left =	"(LL)";
	sc_addline =	"(AddLine)";
d856 1
a856 1
 * Get terminal capabilities via termcap.
d858 3
a860 2
	public void
get_term()
d862 23
a884 5
	char *sp;
	char *t1, *t2;
	int hard;
	char *term;
	char termbuf[2048];
d886 3
a888 3
	static char sbuf[1024];

#ifdef OS2
d890 2
a891 1
	 * Make sure the termcap database is available.
d893 117
a1009 5
	sp = getenv("TERMCAP");
	if (sp == NULL || *sp == '\0')
	{
		char *termcap;
		if ((sp = homefile("termcap.dat")) != NULL)
d1011 107
a1117 5
			size_t l = strlen(sp)+9;
			termcap = (char *) ecalloc(l, sizeof(char));
			snprintf(termcap, l, "TERMCAP=%s", sp);
			free(sp);
			putenv(termcap);
d1124 1
a1124 1
 	if ((term = getenv("TERM")) == NULL)
d1126 1
d1128 3
a1130 3
 		strlcpy(termbuf, "dumb:hc:", sizeof termbuf);

 	hard = tgetflag("hc");
d1138 5
a1142 12
#if DEBUG
	if (strncmp(term,"LESSDEBUG",9) == 0)
	{
		get_debug_term();
		return;
	}
#endif /* DEBUG */

	auto_wrap = tgetflag("am");
	ignaw = tgetflag("xn");
	above_mem = tgetflag("da");
	below_mem = tgetflag("db");
d1150 1
a1150 1
	if ((so_s_width = tgetnum("sg")) < 0)
d1176 1
a1176 1
	sc_pad = tgetstr("pc", &sp);
d1181 1
a1181 1
	sc_s_keypad = tgetstr("ks", &sp);
d1184 1
a1184 1
	sc_e_keypad = tgetstr("ke", &sp);
d1193 3
a1195 3
	if (!quit_at_eof && !more_mode) {
		sc_init = tgetstr("ti", &sp);
		sc_deinit = tgetstr("te", &sp);
d1199 1
d1203 2
a1204 2
	sc_eol_clear = tgetstr("ce", &sp);
	if (hard || sc_eol_clear == NULL || *sc_eol_clear == '\0')
d1206 1
a1206 1
		cannot("clear to end of line");
d1210 2
a1211 3
	sc_eos_clear = tgetstr("cd", &sp);
	if (below_mem && 
		(hard || sc_eos_clear == NULL || *sc_eos_clear == '\0'))
d1213 1
a1213 1
		cannot("clear to end of screen");
d1217 2
a1218 2
	sc_clear = tgetstr("cl", &sp);
	if (hard || sc_clear == NULL || *sc_clear == '\0')
d1220 1
a1220 1
		cannot("clear screen");
d1224 2
a1225 2
	sc_move = tgetstr("cm", &sp);
	if (hard || sc_move == NULL || *sc_move == '\0')
d1237 4
a1240 27
	sc_s_in = tgetstr("so", &sp);
	if (hard || sc_s_in == NULL)
		sc_s_in = "";

	sc_s_out = tgetstr("se", &sp);
	if (hard || sc_s_out == NULL)
		sc_s_out = "";

	sc_u_in = tgetstr("us", &sp);
	if (hard || sc_u_in == NULL)
		sc_u_in = sc_s_in;

	sc_u_out = tgetstr("ue", &sp);
	if (hard || sc_u_out == NULL)
		sc_u_out = sc_s_out;

	sc_b_in = tgetstr("md", &sp);
	if (hard || sc_b_in == NULL)
	{
		sc_b_in = sc_s_in;
		sc_b_out = sc_s_out;
	} else
	{
		sc_b_out = tgetstr("me", &sp);
		if (hard || sc_b_out == NULL)
			sc_b_out = "";
	}
d1242 2
a1243 14
	sc_bl_in = tgetstr("mb", &sp);
	if (hard || sc_bl_in == NULL)
	{
		sc_bl_in = sc_s_in;
		sc_bl_out = sc_s_out;
	} else
	{
		sc_bl_out = tgetstr("me", &sp);
		if (hard || sc_bl_out == NULL)
			sc_bl_out = "";
	}

	sc_visual_bell = tgetstr("vb", &sp);
	if (hard || sc_visual_bell == NULL)
d1246 1
a1246 1
	if (tgetflag("bs"))
d1250 1
a1250 1
		sc_backspace = tgetstr("bc", &sp);
d1259 2
a1260 2
	t1 = tgetstr("ho", &sp);
	if (hard || t1 == NULL)
d1266 1
a1266 1
		strlcpy(sp, tgoto(sc_move, 0, 0), sbuf + sizeof sbuf - sp);
d1270 1
a1270 1
	sc_home = cheaper(t1, t2, "home cursor", "|\b^");
d1276 2
a1277 2
	t1 = tgetstr("ll", &sp);
	if (hard || t1 == NULL)
d1283 2
a1284 1
		strlcpy(sp, tgoto(sc_move, 0, sc_height-1), sbuf + sizeof sbuf - sp);
d1288 1
a1288 2
	sc_lower_left = cheaper(t1, t2,
		"move cursor to lower left of screen", "\r");
d1294 2
a1295 2
	t1 = tgetstr("al", &sp);
	if (hard || t1 == NULL)
d1297 2
a1298 2
	t2 = tgetstr("sr", &sp);
	if (hard || t2 == NULL)
d1308 1
a1308 1
		sc_addline = cheaper(t1, t2, "scroll backwards", "");
d1314 1
a1314 1
		back_scroll = 0;
d1316 1
d1319 1
d1353 1
a1353 1
cheaper(t1, t2, doit, def)
a1354 1
	char *doit;
d1359 1
a1359 1
		cannot(doit);
d1371 30
d1408 100
d1514 13
a1526 4
	if (no_init)
		return;
	tputs(sc_init, sc_height, putchr);
	tputs(sc_s_keypad, sc_height, putchr);
a1535 2
	if (no_init)
		return;
d1538 16
a1553 2
	tputs(sc_e_keypad, sc_height, putchr);
	tputs(sc_deinit, sc_height, putchr);
d1563 1
d1565 4
d1578 1
d1580 100
d1681 99
d1787 1
d1789 35
d1833 6
a1838 4
	char *sc_goto;

	sc_goto = tgoto(sc_move, 0, slinenum);
	tputs(sc_goto, 1, putchr);
d1841 1
d1843 4
a1846 1
 * Ring the terminal bell.
d1848 2
a1849 2
	public void
bell()
d1851 50
a1900 4
	if (quiet == VERY_QUIET)
		vbell();
	else
		putchr('\7');
d1902 1
d1910 1
d1914 81
d2003 1
d2005 8
d2022 1
d2024 65
d2098 5
d2104 26
a2129 4
	if (below_mem)
		tputs(sc_eos_clear, 1, putchr);
	else
		tputs(sc_eol_clear, 1, putchr);
d2138 1
d2140 5
d2153 1
d2155 5
d2169 1
d2171 5
d2184 1
d2186 5
d2199 1
d2201 5
d2214 1
d2216 5
d2229 1
d2231 5
d2244 1
d2246 5
d2253 1
d2261 1
d2263 1
a2263 1
	 * Try to erase the previous character by overstriking with a space.
d2268 33
d2302 1
d2310 1
d2312 28
d2341 100
@


1.9
log
@some more string shit; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: screen.c,v 1.8 2001/11/19 19:02:14 mpech Exp $	*/
d693 3
a695 2
			termcap = (char *) ecalloc(strlen(sp)+9, sizeof(char));
			sprintf(termcap, "TERMCAP=%s", sp);
d887 1
a887 1
		strcpy(sp, tgoto(sc_move, 0, 0));
d904 1
a904 1
		strcpy(sp, tgoto(sc_move, 0, sc_height-1));
@


1.8
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: screen.c,v 1.7 2001/01/29 01:58:04 niklas Exp $	*/
d706 1
a706 1
 		strcpy(termbuf, "dumb:hc:");
@


1.7
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d456 1
a456 1
	register char *s;
d676 2
a677 2
	register char *t1, *t2;
	register int hard;
@


1.6
log
@use sc_e_keypad, sc_s_keypad, and use ti/te. Undoes previous revs which disabled. Unclear why that was done, must wait for that old bug to resurface and fix it in a different way
@
text
@d1 2
@


1.5
log
@Do termios ops on /dev/tty if available, else fd 2.
@
text
@d776 1
a776 1
	if (!more_mode) {
a1003 1
#if 0
a1004 1
#endif
a1017 1
#if 0
a1018 1
#endif
@


1.4
log
@TCSADRAIN -> TCSANOW.  Using TCSADRAIN appears to cause a race condition
whereby the change is done with the wrong tcpgrp.  This fixes suspending
less/more when invoked in mail(1) or via sh -c "less somefile".
@
text
@d110 1
d169 4
d188 2
a189 1
		tcgetattr(2, &s);
d327 2
a328 1
	tcsetattr(2, TCSANOW, &s);
d341 1
a341 1
		ioctl(2, TCGETA, &s);
d373 1
a373 1
	ioctl(2, TCSETAW, &s);
d385 1
a385 1
		ioctl(2, TIOCGETP, &s);
d410 1
a410 1
	ioctl(2, TIOCSETN, &s);
d463 3
d467 1
a467 1
	if (ioctl(2, TIOCGWINSZ, &w) == 0 && w.ws_row > 0)
d472 1
a472 1
	if (ioctl(2, WIOCGETD, &w) == 0 && w.uw_height > 0)
d486 1
a486 1
 	if (ioctl(2, TIOCGWINSZ, &w) == 0 && w.ws_col > 0)
d490 1
a490 1
	if (ioctl(2, WIOCGETD, &w) == 0 && w.uw_width > 0)
@


1.3
log
@No broken push/pop for Theo's less -ewm.
@
text
@d321 1
a321 1
	tcsetattr(2, TCSADRAIN, &s);
@


1.2
log
@Incorporate less modifications for more and our bug fixes from previous
version.
@
text
@d766 1
a766 1
	if (!quit_at_eof && !more_mode) {
@


1.1
log
@Initial revision
@
text
@d139 2
d417 1
a417 1
	if (know_dumb)
d420 1
d761 9
a769 1
	sc_init = tgetstr("ti", &sp);
a771 2

	sc_deinit= tgetstr("te", &sp);
d994 1
d996 1
d1010 1
d1012 1
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d31 2
a37 21
#if MSDOS_COMPILER
#include "pckeys.h"
#if MSDOS_COMPILER==MSOFTC
#include <graph.h>
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
#include <conio.h>
#if MSDOS_COMPILER==DJGPPC
#include <pc.h>
extern int fd0;
#endif
#else
#if MSDOS_COMPILER==WIN32C
#include <windows.h>
#endif
#endif
#endif
#include <time.h>

#else

a46 3
#if HAVE_SGSTAT_H
#include <sgstat.h>
#else
a47 1
#endif
a52 1

d56 10
a65 2
#ifdef _OSK
#include <signal.h>
a66 3
#if OS2
#include <sys/signal.h>
#include "pckeys.h"
d68 1
a75 12
#endif /* MSDOS_COMPILER */

/*
 * Check for broken termios package that forces you to manually
 * set the line discipline.
 */
#ifdef __ultrix__
#define MUST_SET_LINE_DISCIPLINE 1
#else
#define MUST_SET_LINE_DISCIPLINE 0
#endif

a77 1
static char *windowid;
a81 63
#if MSDOS_COMPILER==MSOFTC
static int videopages;
static long msec_loops;
static int flash_created = 0;
#define	SETCOLORS(fg,bg)	{ _settextcolor(fg); _setbkcolor(bg); }
#endif

#if MSDOS_COMPILER==BORLANDC
static unsigned short *whitescreen;
static int flash_created = 0;
#endif
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
#define _settextposition(y,x)   gotoxy(x,y)
#define _clearscreen(m)         clrscr()
#define _outtext(s)             cputs(s)
#define	SETCOLORS(fg,bg)	{ textcolor(fg); textbackground(bg); }
extern int sc_height;
#endif

#if MSDOS_COMPILER==WIN32C
struct keyRecord
{
	int ascii;
	int scan;
} currentKey;

static int keyCount = 0;
static WORD curr_attr;
static int pending_scancode = 0;
static WORD *whitescreen;

static HANDLE con_out_save = INVALID_HANDLE_VALUE; /* previous console */
static HANDLE con_out_ours = INVALID_HANDLE_VALUE; /* our own */
HANDLE con_out = INVALID_HANDLE_VALUE;             /* current console */

extern int quitting;
static void win32_init_term();
static void win32_deinit_term();

#define FG_COLORS       (FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY)
#define BG_COLORS       (BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE | BACKGROUND_INTENSITY)
#define	MAKEATTR(fg,bg)		((WORD)((fg)|((bg)<<4)))
#define	SETCOLORS(fg,bg)	{ curr_attr = MAKEATTR(fg,bg); \
				if (SetConsoleTextAttribute(con_out, curr_attr) == 0) \
				error("SETCOLORS failed"); }
#endif

#if MSDOS_COMPILER
public int nm_fg_color;		/* Color of normal text */
public int nm_bg_color;
public int bo_fg_color;		/* Color of bold text */
public int bo_bg_color;
public int ul_fg_color;		/* Color of underlined text */
public int ul_bg_color;
public int so_fg_color;		/* Color of standout text */
public int so_bg_color;
public int bl_fg_color;		/* Color of blinking text */
public int bl_bg_color;
static int sy_fg_color;		/* Color of system text (before less) */
static int sy_bg_color;

#else

a107 1
#endif
a121 2
public int clear_bg;		/* Clear fills with background color */
public int missing_cap = 0;	/* Some capability is missing */
a122 3
static int attrmode = AT_NORMAL;

#if !MSDOS_COMPILER
a123 2
static void tmodes();
#endif
a132 4
#ifdef _OSK
short ospeed;
char PC_, *UP, *BC;
#endif
d135 2
a136 1
extern int no_back_scroll;
a138 5
extern int no_keypad;
extern int sigs;
extern int wscroll;
extern int screen_trashed;
extern int tty;
d166 5
a174 1
	static int saved_term = 0;
d181 1
a181 1
		tcgetattr(tty, &s);
d186 1
a186 5
		if (!saved_term)
		{
			save_term = s;
			saved_term = 1;
		}
d252 1
a252 1
		werase_char = CONTROL('W');
d277 2
a278 2
#ifdef OXTABS
			| OXTABS
d283 2
a284 2
#ifdef XTABS
			| XTABS
a311 13
#ifdef VLNEXT
		s.c_cc[VLNEXT] = 0;
#endif
#ifdef VDSUSP
		s.c_cc[VDSUSP] = 0;
#endif
#if MUST_SET_LINE_DISCIPLINE
		/*
		 * System's termios is broken; need to explicitly 
		 * request TERMIODISC line discipline.
		 */
		s.c_line = TERMIODISC;
#endif
d319 1
a319 16
#if HAVE_FSYNC
	fsync(tty);
#endif
	tcsetattr(tty, TCSADRAIN, &s);
#if MUST_SET_LINE_DISCIPLINE
	if (!on)
	{
		/*
		 * Broken termios *ignores* any line discipline
		 * except TERMIODISC.  A different old line discipline
		 * is therefore not restored, yet.  Restore the old
		 * line discipline by hand.
		 */
		ioctl(tty, TIOCSETD, &save_term.c_line);
	}
#endif
a325 1
	static int saved_term = 0;
d332 1
a332 1
		ioctl(tty, TCGETA, &s);
d337 1
a337 5
		if (!saved_term)
		{
			save_term = s;
			saved_term = 1;
		}
d346 1
a346 1
		werase_char = CONTROL('W');
d364 1
a364 1
	ioctl(tty, TCSETAW, &s);
a366 1
#ifdef TIOCGETP
a369 1
	static int saved_term = 0;
d376 1
a376 1
		ioctl(tty, TIOCGETP, &s);
d381 1
a381 5
		if (!saved_term)
		{
			save_term = s;
			saved_term = 1;
		}
d387 1
a387 1
		werase_char = CONTROL('W');
d401 1
a401 43
	ioctl(tty, TIOCSETN, &s);
    }
#else
#ifdef _OSK
    {
	struct sgbuf s;
	static struct sgbuf save_term;
	static int saved_term = 0;

	if (on)
	{
		/*
		 * Get terminal modes.
		 */
		_gs_opt(tty, &s);

		/*
		 * Save modes and set certain variables dependent on modes.
		 */
		if (!saved_term)
		{
			save_term = s;
			saved_term = 1;
		}
		erase_char = s.sg_bspch;
		kill_char = s.sg_dlnch;
		werase_char = CONTROL('W');

		/*
		 * Set the modes to the way we want them.
		 */
		s.sg_echo = 0;
		s.sg_eofch = 0;
		s.sg_pause = 0;
		s.sg_psch = 0;
	} else
	{
		/*
		 * Restore saved modes.
		 */
		s = save_term;
	}
	_ss_opt(tty, &s);
a402 23
#else
	/* MS-DOS, Windows, or OS2 */
#if OS2
	/* OS2 */
	LSIGNAL(SIGINT, SIG_IGN);
#endif
	erase_char = '\b';
#if MSDOS_COMPILER==DJGPPC
	kill_char = CONTROL('U');
	/*
	 * So that when we shell out or run another program, its
	 * stdin is in cooked mode.  We do not switch stdin to binary 
	 * mode if fd0 is zero, since that means we were called before
	 * tty was reopened in open_getchr, in which case we would be
	 * changing the original stdin device outside less.
	 */
	if (fd0 != 0)
		setmode(0, on ? O_BINARY : O_TEXT);
#else
	kill_char = ESC;
#endif
	werase_char = CONTROL('W');
#endif
d409 5
a413 5
#if !MSDOS_COMPILER
/*
 * Some glue to prevent calling termcap functions if tgetent() failed.
 */
static int hardcopy;
d415 5
a419 5
	static char *
ltget_env(capname)
	char *capname;
{
	char name[16];
d421 2
a422 3
	strcpy(name, "LESS_TERMCAP_");
	strcat(name, capname);
	return (lgetenv(name));
d425 6
a430 3
	static int
ltgetflag(capname)
	char *capname;
d432 1
a432 1
	char *s;
d434 3
a436 5
	if ((s = ltget_env(capname)) != NULL)
		return (*s != '\0' && *s != '0');
	if (hardcopy)
		return (0);
	return (tgetflag(capname));
d439 4
a442 3
	static int
ltgetnum(capname)
	char *capname;
d444 24
a467 1
	char *s;
d469 2
a470 6
	if ((s = ltget_env(capname)) != NULL)
		return (atoi(s));
	if (hardcopy)
		return (-1);
	return (tgetnum(capname));
}
d472 14
a485 6
	static char *
ltgetstr(capname, pp)
	char *capname;
	char **pp;
{
	char *s;
d487 2
a488 5
	if ((s = ltget_env(capname)) != NULL)
		return (s);
	if (hardcopy)
		return (NULL);
	return (tgetstr(capname, pp));
d490 1
a490 1
#endif /* MSDOS_COMPILER */
d493 4
a496 1
 * Get size of the output screen.
d499 1
a499 1
scrsize()
d501 8
a508 6
	register char *s;
	int sys_height;
	int sys_width;
#if !MSDOS_COMPILER
	int n;
#endif
d510 7
a516 6
#define	DEF_SC_WIDTH	80
#if MSDOS_COMPILER
#define	DEF_SC_HEIGHT	25
#else
#define	DEF_SC_HEIGHT	24
#endif
d518 4
d523 4
a526 1
	sys_width = sys_height = 0;
d528 19
a546 1
#if MSDOS_COMPILER==MSOFTC
d548 2
a549 4
		struct videoconfig w;
		_getvideoconfig(&w);
		sys_height = w.numtextrows;
		sys_width = w.numtextcols;
d551 12
a562 2
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
d564 1
a564 4
		struct text_info w;
		gettextinfo(&w);
		sys_height = w.screenheight;
		sys_width = w.screenwidth;
d566 4
a569 2
#else
#if MSDOS_COMPILER==WIN32C
d571 1
a571 4
		CONSOLE_SCREEN_BUFFER_INFO scr;
		GetConsoleScreenBufferInfo(con_out, &scr);
		sys_height = scr.srWindow.Bottom - scr.srWindow.Top + 1;
		sys_width = scr.srWindow.Right - scr.srWindow.Left + 1;
d573 4
a576 2
#else
#if OS2
d578 1
a578 25
		int s[2];
		_scrsize(s);
		sys_width = s[0];
		sys_height = s[1];
		/*
		 * When using terminal emulators for XFree86/OS2, the
		 * _scrsize function does not work well.
		 * Call the scrsize.exe program to get the window size.
		 */
		windowid = getenv("WINDOWID");
		if (windowid != NULL)
		{
			FILE *fd = popen("scrsize", "rt");
			if (fd != NULL)
			{
				int w, h;
				fscanf(fd, "%i %i", &w, &h);
				if (w > 0 && h > 0)
				{
					sys_width = w;
					sys_height = h;
				}
				pclose(fd);
			}
		}
d580 4
a583 2
#else
#ifdef TIOCGWINSZ
d585 1
a585 8
		struct winsize w;
		if (ioctl(2, TIOCGWINSZ, &w) == 0)
		{
			if (w.ws_row > 0)
				sys_height = w.ws_row;
			if (w.ws_col > 0)
				sys_width = w.ws_col;
		}
d587 4
a590 2
#else
#ifdef WIOCGETD
d592 4
a595 8
		struct uwdata w;
		if (ioctl(2, WIOCGETD, &w) == 0)
		{
			if (w.uw_height > 0)
				sys_height = w.uw_height / w.uw_vs;
			if (w.uw_width > 0)
				sys_width = w.uw_width / w.uw_hs;
		}
d597 8
a604 6
#endif
#endif
#endif
#endif
#endif
#endif
d606 6
a611 10
	if (sys_height > 0)
		sc_height = sys_height;
	else if ((s = lgetenv("LINES")) != NULL)
		sc_height = atoi(s);
#if !MSDOS_COMPILER
	else if ((n = ltgetnum("li")) > 0)
 		sc_height = n;
#endif
	else
		sc_height = DEF_SC_HEIGHT;
d613 5
a617 10
	if (sys_width > 0)
		sc_width = sys_width;
	else if ((s = lgetenv("COLUMNS")) != NULL)
		sc_width = atoi(s);
#if !MSDOS_COMPILER
	else if ((n = ltgetnum("co")) > 0)
 		sc_width = n;
#endif
	else
		sc_width = DEF_SC_WIDTH;
d620 1
a620 4
#if MSDOS_COMPILER==MSOFTC
/*
 * Figure out how many empty loops it takes to delay a millisecond.
 */
d622 1
a622 1
get_clock()
d624 27
a650 20
	clock_t start;
	
	/*
	 * Get synchronized at the start of a tick.
	 */
	start = clock();
	while (clock() == start)
		;
	/*
	 * Now count loops till the next tick.
	 */
	start = clock();
	msec_loops = 0;
	while (clock() == start)
		msec_loops++;
	/*
	 * Convert from (loops per clock) to (loops per millisecond).
	 */
	msec_loops *= CLOCKS_PER_SEC;
	msec_loops /= 1000;
d652 1
d655 1
a655 1
 * Delay for a specified number of milliseconds.
d657 2
a658 2
	static void
dummy_func()
d660 7
a666 3
	static long delay_dummy = 0;
	delay_dummy++;
}
d668 6
a673 7
	static void
delay(msec)
	int msec;
{
	long i;
	
	while (msec-- > 0)
d675 2
a676 1
		for (i = 0;  i < msec_loops;  i++)
d678 4
a681 5
			/*
			 * Make it look like we're doing something here,
			 * so the optimizer doesn't remove the whole loop.
			 */
			dummy_func();
a683 1
}
d685 7
d693 1
a693 30
/*
 * Return the characters actually input by a "special" key.
 */
	public char *
special_key_str(key)
	int key;
{
	static char tbuf[40];
	char *s;
#if MSDOS_COMPILER || OS2
	static char k_right[]		= { '\340', PCK_RIGHT, 0 };
	static char k_left[]		= { '\340', PCK_LEFT, 0  };
	static char k_ctl_right[]	= { '\340', PCK_CTL_RIGHT, 0  };
	static char k_ctl_left[]	= { '\340', PCK_CTL_LEFT, 0  };
	static char k_insert[]		= { '\340', PCK_INSERT, 0  };
	static char k_delete[]		= { '\340', PCK_DELETE, 0  };
	static char k_ctl_delete[]	= { '\340', PCK_CTL_DELETE, 0  };
	static char k_ctl_backspace[]	= { '\177', 0 };
	static char k_home[]		= { '\340', PCK_HOME, 0 };
	static char k_end[]		= { '\340', PCK_END, 0 };
	static char k_up[]		= { '\340', PCK_UP, 0 };
	static char k_down[]		= { '\340', PCK_DOWN, 0 };
	static char k_backtab[]		= { '\340', PCK_SHIFT_TAB, 0 };
	static char k_pagedown[]	= { '\340', PCK_PAGEDOWN, 0 };
	static char k_pageup[]		= { '\340', PCK_PAGEUP, 0 };
	static char k_f1[]		= { '\340', PCK_F1, 0 };
#endif
#if !MSDOS_COMPILER
	char *sp = tbuf;
#endif
a694 3
	switch (key)
	{
#if OS2
d696 1
a696 2
	 * If windowid is not NULL, assume less is executed in 
	 * the XFree86 environment.
d698 2
a699 199
	case SK_RIGHT_ARROW:
		s = windowid ? ltgetstr("kr", &sp) : k_right;
		break;
	case SK_LEFT_ARROW:
		s = windowid ? ltgetstr("kl", &sp) : k_left;
		break;
	case SK_UP_ARROW:
		s = windowid ? ltgetstr("ku", &sp) : k_up;
		break;
	case SK_DOWN_ARROW:
		s = windowid ? ltgetstr("kd", &sp) : k_down;
		break;
	case SK_PAGE_UP:
		s = windowid ? ltgetstr("kP", &sp) : k_pageup;
		break;
	case SK_PAGE_DOWN:
		s = windowid ? ltgetstr("kN", &sp) : k_pagedown;
		break;
	case SK_HOME:
		s = windowid ? ltgetstr("kh", &sp) : k_home;
		break;
	case SK_END:
		s = windowid ? ltgetstr("@@7", &sp) : k_end;
		break;
	case SK_DELETE:
		if (windowid)
		{
			s = ltgetstr("kD", &sp);
			if (s == NULL)
			{
				tbuf[0] = '\177';
				tbuf[1] = '\0';
				s = tbuf;
			}
		} else
			s = k_delete;
		break;
#endif
#if MSDOS_COMPILER
	case SK_RIGHT_ARROW:
		s = k_right;
		break;
	case SK_LEFT_ARROW:
		s = k_left;
		break;
	case SK_UP_ARROW:
		s = k_up;
		break;
	case SK_DOWN_ARROW:
		s = k_down;
		break;
	case SK_PAGE_UP:
		s = k_pageup;
		break;
	case SK_PAGE_DOWN:
		s = k_pagedown;
		break;
	case SK_HOME:
		s = k_home;
		break;
	case SK_END:
		s = k_end;
		break;
	case SK_DELETE:
		s = k_delete;
		break;
#endif
#if MSDOS_COMPILER || OS2
	case SK_INSERT:
		s = k_insert;
		break;
	case SK_CTL_LEFT_ARROW:
		s = k_ctl_left;
		break;
	case SK_CTL_RIGHT_ARROW:
		s = k_ctl_right;
		break;
	case SK_CTL_BACKSPACE:
		s = k_ctl_backspace;
		break;
	case SK_CTL_DELETE:
		s = k_ctl_delete;
		break;
	case SK_F1:
		s = k_f1;
		break;
	case SK_BACKTAB:
		s = k_backtab;
		break;
#else
	case SK_RIGHT_ARROW:
		s = ltgetstr("kr", &sp);
		break;
	case SK_LEFT_ARROW:
		s = ltgetstr("kl", &sp);
		break;
	case SK_UP_ARROW:
		s = ltgetstr("ku", &sp);
		break;
	case SK_DOWN_ARROW:
		s = ltgetstr("kd", &sp);
		break;
	case SK_PAGE_UP:
		s = ltgetstr("kP", &sp);
		break;
	case SK_PAGE_DOWN:
		s = ltgetstr("kN", &sp);
		break;
	case SK_HOME:
		s = ltgetstr("kh", &sp);
		break;
	case SK_END:
		s = ltgetstr("@@7", &sp);
		break;
	case SK_DELETE:
		s = ltgetstr("kD", &sp);
		if (s == NULL)
		{
			tbuf[0] = '\177';
			tbuf[1] = '\0';
			s = tbuf;
		}
		break;
#endif
	case SK_CONTROL_K:
		tbuf[0] = CONTROL('K');
		tbuf[1] = '\0';
		s = tbuf;
		break;
	default:
		return (NULL);
	}
	return (s);
}

/*
 * Get terminal capabilities via termcap.
 */
	public void
get_term()
{
#if MSDOS_COMPILER
	auto_wrap = 1;
	ignaw = 0;
	can_goto_line = 1;
	clear_bg = 1;
	/*
	 * Set up default colors.
	 * The xx_s_width and xx_e_width vars are already initialized to 0.
	 */
#if MSDOS_COMPILER==MSOFTC
	sy_bg_color = _getbkcolor();
	sy_fg_color = _gettextcolor();
	get_clock();
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
    {
	struct text_info w;
	gettextinfo(&w);
	sy_bg_color = (w.attribute >> 4) & 0x0F;
	sy_fg_color = (w.attribute >> 0) & 0x0F;
    }
#else
#if MSDOS_COMPILER==WIN32C
    {
	DWORD nread;
	CONSOLE_SCREEN_BUFFER_INFO scr;

	con_out_save = con_out = GetStdHandle(STD_OUTPUT_HANDLE);
	/*
	 * Always open stdin in binary. Note this *must* be done
	 * before any file operations have been done on fd0.
	 */
	SET_BINARY(0);
	GetConsoleScreenBufferInfo(con_out, &scr);
	ReadConsoleOutputAttribute(con_out, &curr_attr, 
					1, scr.dwCursorPosition, &nread);
	sy_bg_color = (curr_attr & BG_COLORS) >> 4; /* normalize */
	sy_fg_color = curr_attr & FG_COLORS;
    }
#endif
#endif
#endif
	nm_fg_color = sy_fg_color;
	nm_bg_color = sy_bg_color;
	bo_fg_color = 11;
	bo_bg_color = 0;
	ul_fg_color = 9;
	ul_bg_color = 0;
	so_fg_color = 15;
	so_bg_color = 9;
	bl_fg_color = 15;
	bl_bg_color = 0;

	/*
	 * Get size of the screen.
	 */
	scrsize();
	pos_init();
d701 2
a702 16

#else /* !MSDOS_COMPILER */

	char *sp;
	register char *t1, *t2;
	char *term;
	char termbuf[TERMBUF_SIZE];

	static char sbuf[TERMSBUF_SIZE];

#if OS2
	/*
	 * Make sure the termcap database is available.
	 */
	sp = lgetenv("TERMCAP");
	if (sp == NULL || *sp == '\0')
d704 2
a705 8
		char *termcap;
		if ((sp = homefile("termcap.dat")) != NULL)
		{
			termcap = (char *) ecalloc(strlen(sp)+9, sizeof(char));
			sprintf(termcap, "TERMCAP=%s", sp);
			free(sp);
			putenv(termcap);
		}
d707 1
a707 17
#endif
	/*
	 * Find out what kind of terminal this is.
	 */
 	if ((term = lgetenv("TERM")) == NULL)
 		term = DEFAULT_TERM;
	hardcopy = 0;
 	if (tgetent(termbuf, term) <= 0)
 		hardcopy = 1;
 	if (ltgetflag("hc"))
		hardcopy = 1;

	/*
	 * Get size of the screen.
	 */
	scrsize();
	pos_init();
d709 4
a712 5
	auto_wrap = ltgetflag("am");
	ignaw = ltgetflag("xn");
	above_mem = ltgetflag("da");
	below_mem = ltgetflag("db");
	clear_bg = ltgetflag("ut");
d720 1
a720 1
	if ((so_s_width = ltgetnum("sg")) < 0)
d746 1
a746 1
	sc_pad = ltgetstr("pc", &sp);
d751 1
a751 1
	sc_s_keypad = ltgetstr("ks", &sp);
d754 1
a754 1
	sc_e_keypad = ltgetstr("ke", &sp);
d758 1
a758 1
	sc_init = ltgetstr("ti", &sp);
d762 1
a762 1
	sc_deinit= ltgetstr("te", &sp);
d766 2
a767 2
	sc_eol_clear = ltgetstr("ce", &sp);
	if (sc_eol_clear == NULL || *sc_eol_clear == '\0')
d769 1
a769 1
		missing_cap = 1;
d773 3
a775 2
	sc_eos_clear = ltgetstr("cd", &sp);
	if (below_mem && (sc_eos_clear == NULL || *sc_eos_clear == '\0'))
d777 1
a777 1
		missing_cap = 1;
d781 2
a782 2
	sc_clear = ltgetstr("cl", &sp);
	if (sc_clear == NULL || *sc_clear == '\0')
d784 1
a784 1
		missing_cap = 1;
d788 2
a789 2
	sc_move = ltgetstr("cm", &sp);
	if (sc_move == NULL || *sc_move == '\0')
d801 15
a815 4
	tmodes("so", "se", &sc_s_in, &sc_s_out, "", "", &sp);
	tmodes("us", "ue", &sc_u_in, &sc_u_out, sc_s_in, sc_s_out, &sp);
	tmodes("md", "me", &sc_b_in, &sc_b_out, sc_s_in, sc_s_out, &sp);
	tmodes("mb", "me", &sc_bl_in, &sc_bl_out, sc_s_in, sc_s_out, &sp);
d817 26
a842 2
	sc_visual_bell = ltgetstr("vb", &sp);
	if (sc_visual_bell == NULL)
d845 1
a845 1
	if (ltgetflag("bs"))
d849 1
a849 1
		sc_backspace = ltgetstr("bc", &sp);
d858 2
a859 2
	t1 = ltgetstr("ho", &sp);
	if (t1 == NULL)
d869 1
a869 1
	sc_home = cheaper(t1, t2, "|\b^");
d875 2
a876 2
	t1 = ltgetstr("ll", &sp);
	if (t1 == NULL)
d886 2
a887 1
	sc_lower_left = cheaper(t1, t2, "\r");
d893 2
a894 2
	t1 = ltgetstr("al", &sp);
	if (t1 == NULL)
d896 2
a897 2
	t2 = ltgetstr("sr", &sp);
	if (t2 == NULL)
d907 1
a907 1
		sc_addline = cheaper(t1, t2, "");
d913 1
a913 1
		no_back_scroll = 1;
a914 1
#endif /* MSDOS_COMPILER */
a916 1
#if !MSDOS_COMPILER
d950 1
a950 1
cheaper(t1, t2, def)
d952 1
d957 1
a957 1
		missing_cap = 1;
a968 30
	static void
tmodes(incap, outcap, instr, outstr, def_instr, def_outstr, spp)
	char *incap;
	char *outcap;
	char **instr;
	char **outstr;
	char *def_instr;
	char *def_outstr;
	char **spp;
{
	*instr = ltgetstr(incap, spp);
	if (*instr == NULL)
	{
		/* Use defaults. */
		*instr = def_instr;
		*outstr = def_outstr;
		return;
	}

	*outstr = ltgetstr(outcap, spp);
	if (*outstr == NULL)
		/* No specific out capability; use "me". */
		*outstr = ltgetstr("me", spp);
	if (*outstr == NULL)
		/* Don't even have "me"; use a null string. */
		*outstr = "";
}

#endif /* MSDOS_COMPILER */

a975 100
#if MSDOS_COMPILER

#if MSDOS_COMPILER==WIN32C
	static void
_settextposition(int row, int col)
{
	COORD cpos;
	CONSOLE_SCREEN_BUFFER_INFO csbi;

	GetConsoleScreenBufferInfo(con_out, &csbi);
	cpos.X = csbi.srWindow.Left + (col - 1);
	cpos.Y = csbi.srWindow.Top + (row - 1);
	SetConsoleCursorPosition(con_out, cpos);
}
#endif

/*
 * Initialize the screen to the correct color at startup.
 */
	static void
initcolor()
{
	SETCOLORS(nm_fg_color, nm_bg_color);
#if 0
	/*
	 * This clears the screen at startup.  This is different from
	 * the behavior of other versions of less.  Disable it for now.
	 */
	char *blanks;
	int row;
	int col;
	
	/*
	 * Create a complete, blank screen using "normal" colors.
	 */
	SETCOLORS(nm_fg_color, nm_bg_color);
	blanks = (char *) ecalloc(width+1, sizeof(char));
	for (col = 0;  col < sc_width;  col++)
		blanks[col] = ' ';
	blanks[sc_width] = '\0';
	for (row = 0;  row < sc_height;  row++)
		_outtext(blanks);
	free(blanks);
#endif
}
#endif

#if MSDOS_COMPILER==WIN32C

/*
 * Termcap-like init with a private win32 console.
 */
	static void
win32_init_term()
{
	CONSOLE_SCREEN_BUFFER_INFO scr;
	COORD size;

	if (con_out_save == INVALID_HANDLE_VALUE)
		return;

	GetConsoleScreenBufferInfo(con_out_save, &scr);

	if (con_out_ours == INVALID_HANDLE_VALUE)
	{
		/*
		 * Create our own screen buffer, so that we
		 * may restore the original when done.
		 */
		con_out_ours = CreateConsoleScreenBuffer(
			GENERIC_WRITE | GENERIC_READ,
			FILE_SHARE_WRITE | FILE_SHARE_READ,
			(LPSECURITY_ATTRIBUTES) NULL,
			CONSOLE_TEXTMODE_BUFFER,
			(LPVOID) NULL);
	}

	size.X = scr.srWindow.Right - scr.srWindow.Left + 1;
	size.Y = scr.srWindow.Bottom - scr.srWindow.Top + 1;
	SetConsoleScreenBufferSize(con_out_ours, size);
	SetConsoleActiveScreenBuffer(con_out_ours);
	con_out = con_out_ours;
}

/*
 * Restore the startup console.
 */
static void
win32_deinit_term()
{
	if (con_out_save == INVALID_HANDLE_VALUE)
		return;
	if (quitting)
		(void) CloseHandle(con_out_ours);
	SetConsoleActiveScreenBuffer(con_out_save);
	con_out = con_out_save;
}

#endif

d982 4
a985 13
#if !MSDOS_COMPILER
	if (!no_init)
		tputs(sc_init, sc_height, putchr);
	if (!no_keypad)
		tputs(sc_s_keypad, sc_height, putchr);
#else
#if MSDOS_COMPILER==WIN32C
	if (!no_init)
		win32_init_term();
#endif
	initcolor();
	flush();
#endif
d995 2
d999 2
a1000 16
#if !MSDOS_COMPILER
	if (!no_keypad)
		tputs(sc_e_keypad, sc_height, putchr);
	if (!no_init)
		tputs(sc_deinit, sc_height, putchr);
#else
	/* Restore system colors. */
	SETCOLORS(sy_fg_color, sy_bg_color);
#if MSDOS_COMPILER==WIN32C
	if (!no_init)
		win32_deinit_term();
#else
	/* Need clreol to make SETCOLORS take effect. */
	clreol();
#endif
#endif
a1009 1
#if !MSDOS_COMPILER
a1010 4
#else
	flush();
	_settextposition(1,1);
#endif
a1019 1
#if !MSDOS_COMPILER
a1020 198
#else
	flush();
#if MSDOS_COMPILER==MSOFTC
	_scrolltextwindow(_GSCROLLDOWN);
	_settextposition(1,1);
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
	movetext(1,1, sc_width,sc_height-1, 1,2);
	gotoxy(1,1);
	clreol();
#else
#if MSDOS_COMPILER==WIN32C
    {
	CHAR_INFO fillchar;
	SMALL_RECT rcSrc, rcClip;
	COORD new_org;
	CONSOLE_SCREEN_BUFFER_INFO csbi;

	GetConsoleScreenBufferInfo(con_out,&csbi);

	/* The clip rectangle is the entire visible screen. */
	rcClip.Left = csbi.srWindow.Left;
	rcClip.Top = csbi.srWindow.Top;
	rcClip.Right = csbi.srWindow.Right;
	rcClip.Bottom = csbi.srWindow.Bottom;

	/* The source rectangle is the visible screen minus the last line. */
	rcSrc = rcClip;
	rcSrc.Bottom--;

	/* Move the top left corner of the source window down one row. */
	new_org.X = rcSrc.Left;
	new_org.Y = rcSrc.Top + 1;

	/* Fill the right character and attributes. */
	fillchar.Char.AsciiChar = ' ';
	curr_attr = MAKEATTR(nm_fg_color, nm_bg_color);
	fillchar.Attributes = curr_attr;
	ScrollConsoleScreenBuffer(con_out, &rcSrc, &rcClip, new_org, &fillchar);
	_settextposition(1,1);
    }
#endif
#endif
#endif
#endif
}

#if 0
/*
 * Remove the n topmost lines and scroll everything below it in the 
 * window upward.  This is needed to stop leaking the topmost line 
 * into the scrollback buffer when we go down-one-line (in WIN32).
 */
	public void
remove_top(n)
	int n;
{
#if MSDOS_COMPILER==WIN32C
	SMALL_RECT rcSrc, rcClip;
	CHAR_INFO fillchar;
	COORD new_org;
	CONSOLE_SCREEN_BUFFER_INFO csbi; /* to get buffer info */

	if (n >= sc_height - 1)
	{
		clear();
		home();
		return;
	}

	flush();

	GetConsoleScreenBufferInfo(con_out, &csbi);

	/* Get the extent of all-visible-rows-but-the-last. */
	rcSrc.Left    = csbi.srWindow.Left;
	rcSrc.Top     = csbi.srWindow.Top + n;
	rcSrc.Right   = csbi.srWindow.Right;
	rcSrc.Bottom  = csbi.srWindow.Bottom;

	/* Get the clip rectangle. */
	rcClip.Left   = rcSrc.Left;
	rcClip.Top    = csbi.srWindow.Top;
	rcClip.Right  = rcSrc.Right;
	rcClip.Bottom = rcSrc.Bottom ;

	/* Move the source window up n rows. */
	new_org.X = rcSrc.Left;
	new_org.Y = rcSrc.Top - n;

	/* Fill the right character and attributes. */
	fillchar.Char.AsciiChar = ' ';
	curr_attr = MAKEATTR(nm_fg_color, nm_bg_color);
	fillchar.Attributes = curr_attr;

	ScrollConsoleScreenBuffer(con_out, &rcSrc, &rcClip, new_org, &fillchar);

	/* Position cursor on first blank line. */
	goto_line(sc_height - n - 1);
#endif
}
#endif

#if MSDOS_COMPILER==WIN32C
/*
 * Clear the screen.
 */
	static void
win32_clear()
{
	/*
	 * This will clear only the currently visible rows of the NT
	 * console buffer, which means none of the precious scrollback
	 * rows are touched making for faster scrolling.  Note that, if
	 * the window has fewer columns than the console buffer (i.e.
	 * there is a horizontal scrollbar as well), the entire width
	 * of the visible rows will be cleared.
	 */
	COORD topleft;
	DWORD nchars;
	DWORD winsz;
	CONSOLE_SCREEN_BUFFER_INFO csbi;

	/* get the number of cells in the current buffer */
	GetConsoleScreenBufferInfo(con_out, &csbi);
	winsz = csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.srWindow.Top + 1);
	topleft.X = 0;
	topleft.Y = csbi.srWindow.Top;

	curr_attr = MAKEATTR(nm_fg_color, nm_bg_color);
	FillConsoleOutputCharacter(con_out, ' ', winsz, topleft, &nchars);
	FillConsoleOutputAttribute(con_out, curr_attr, winsz, topleft, &nchars);
}

/*
 * Remove the n topmost lines and scroll everything below it in the 
 * window upward.
 */
	public void
win32_scroll_up(n)
	int n;
{
	SMALL_RECT rcSrc, rcClip;
	CHAR_INFO fillchar;
	COORD topleft;
	COORD new_org;
	DWORD nchars;
	DWORD size;
	CONSOLE_SCREEN_BUFFER_INFO csbi;

	if (n <= 0)
		return;

	if (n >= sc_height - 1)
	{
		win32_clear();
		_settextposition(1,1);
		return;
	}

	/* Get the extent of what will remain visible after scrolling. */
	GetConsoleScreenBufferInfo(con_out, &csbi);
	rcSrc.Left    = csbi.srWindow.Left;
	rcSrc.Top     = csbi.srWindow.Top + n;
	rcSrc.Right   = csbi.srWindow.Right;
	rcSrc.Bottom  = csbi.srWindow.Bottom;

	/* Get the clip rectangle. */
	rcClip.Left   = rcSrc.Left;
	rcClip.Top    = csbi.srWindow.Top;
	rcClip.Right  = rcSrc.Right;
	rcClip.Bottom = rcSrc.Bottom ;

	/* Move the source text to the top of the screen. */
	new_org.X = rcSrc.Left;
	new_org.Y = 0;

	/* Fill the right character and attributes. */
	fillchar.Char.AsciiChar = ' ';
	fillchar.Attributes = MAKEATTR(nm_fg_color, nm_bg_color);

	/* Scroll the window. */
	SetConsoleTextAttribute(con_out, fillchar.Attributes);
	ScrollConsoleScreenBuffer(con_out, &rcSrc, &rcClip, new_org, &fillchar);

	/* Clear remaining lines at bottom. */
	topleft.X = csbi.dwCursorPosition.X;
	topleft.Y = rcSrc.Bottom - n;
	size = (n * csbi.dwSize.X) + (rcSrc.Right - topleft.X);
	FillConsoleOutputCharacter(con_out, ' ', size, topleft,
		&nchars);
	FillConsoleOutputAttribute(con_out, fillchar.Attributes, size, topleft,
		&nchars);
	SetConsoleTextAttribute(con_out, curr_attr);

	/* Move cursor n lines up from where it was. */
	csbi.dwCursorPosition.Y -= n;
	SetConsoleCursorPosition(con_out, csbi.dwCursorPosition);
a1021 1
#endif
a1028 1
#if !MSDOS_COMPILER
a1029 35
#else
	flush();
	_settextposition(sc_height, 1);
#endif
}

/*
 * Check if the console size has changed and reset internals 
 * (in lieu of SIGWINCH for WIN32).
 */
	public void
check_winch()
{
#if MSDOS_COMPILER==WIN32C
	CONSOLE_SCREEN_BUFFER_INFO scr;
	COORD size;

	if (con_out == INVALID_HANDLE_VALUE)
		return;
 
	flush();
	GetConsoleScreenBufferInfo(con_out, &scr);
	size.Y = scr.srWindow.Bottom - scr.srWindow.Top + 1;
	size.X = scr.srWindow.Right - scr.srWindow.Left + 1;
	if (size.Y != sc_height || size.X != sc_width)
	{
		sc_height = size.Y;
		sc_width = size.X;
		if (!no_init && con_out_ours == con_out)
			SetConsoleScreenBufferSize(con_out, size);
		pos_init();
		wscroll = (sc_height + 1) / 2;
		screen_trashed = 1;
	}
#endif
d1039 4
a1042 6
#if !MSDOS_COMPILER
	tputs(tgoto(sc_move, 0, slinenum), 1, putchr);
#else
	flush();
	_settextposition(slinenum+1, 1);
#endif
a1044 1
#if MSDOS_COMPILER==MSOFTC || MSDOS_COMPILER==BORLANDC
d1046 1
a1046 4
 * Create an alternate screen which is all white.
 * This screen is used to create a "flash" effect, by displaying it
 * briefly and then switching back to the normal screen.
 * {{ Yuck!  There must be a better way to get a visual bell. }}
d1048 2
a1049 2
	static void
create_flash()
d1051 4
a1054 50
#if MSDOS_COMPILER==MSOFTC
	struct videoconfig w;
	char *blanks;
	int row, col;
	
	_getvideoconfig(&w);
	videopages = w.numvideopages;
	if (videopages < 2)
	{
		so_enter();
		so_exit();
	} else
	{
		_setactivepage(1);
		so_enter();
		blanks = (char *) ecalloc(w.numtextcols, sizeof(char));
		for (col = 0;  col < w.numtextcols;  col++)
			blanks[col] = ' ';
		for (row = w.numtextrows;  row > 0;  row--)
			_outmem(blanks, w.numtextcols);
		_setactivepage(0);
		_setvisualpage(0);
		free(blanks);
		so_exit();
	}
#else
#if MSDOS_COMPILER==BORLANDC
	register int n;

	whitescreen = (unsigned short *) 
		malloc(sc_width * sc_height * sizeof(short));
	if (whitescreen == NULL)
		return;
	for (n = 0;  n < sc_width * sc_height;  n++)
		whitescreen[n] = 0x7020;
#else
#if MSDOS_COMPILER==WIN32C
	register int n;

	whitescreen = (WORD *)
		malloc(sc_height * sc_width * sizeof(WORD));
	if (whitescreen == NULL)
		return;
	/* Invert the standard colors. */
	for (n = 0;  n < sc_width * sc_height;  n++)
		whitescreen[n] = (WORD)((nm_fg_color << 4) | nm_bg_color);
#endif
#endif
#endif
	flash_created = 1;
a1055 1
#endif /* MSDOS_COMPILER */
a1062 1
#if !MSDOS_COMPILER
a1065 81
#else
#if MSDOS_COMPILER==DJGPPC
	ScreenVisualBell();
#else
#if MSDOS_COMPILER==MSOFTC
	/*
	 * Create a flash screen on the second video page.
	 * Switch to that page, then switch back.
	 */
	if (!flash_created)
		create_flash();
	if (videopages < 2)
		return;
	_setvisualpage(1);
	delay(100);
	_setvisualpage(0);
#else
#if MSDOS_COMPILER==BORLANDC
	unsigned short *currscreen;

	/*
	 * Get a copy of the current screen.
	 * Display the flash screen.
	 * Then restore the old screen.
	 */
	if (!flash_created)
		create_flash();
	if (whitescreen == NULL)
		return;
	currscreen = (unsigned short *) 
		malloc(sc_width * sc_height * sizeof(short));
	if (currscreen == NULL) return;
	gettext(1, 1, sc_width, sc_height, currscreen);
	puttext(1, 1, sc_width, sc_height, whitescreen);
	delay(100);
	puttext(1, 1, sc_width, sc_height, currscreen);
	free(currscreen);
#else
#if MSDOS_COMPILER==WIN32C
	/* paint screen with an inverse color */
	clear();

	/* leave it displayed for 100 msec. */
	Sleep(100);

	/* restore with a redraw */
	repaint();
#endif
#endif
#endif
#endif
#endif
}

/*
 * Make a noise.
 */
	static void
beep()
{
#if !MSDOS_COMPILER
	putchr(CONTROL('G'));
#else
#if MSDOS_COMPILER==WIN32C
	MessageBeep(0);
#else
	write(1, "\7", 1);
#endif
#endif
}

/*
 * Ring the terminal bell.
 */
	public void
bell()
{
	if (quiet == VERY_QUIET)
		vbell();
	else
		beep();
a1073 1
#if !MSDOS_COMPILER
a1074 8
#else
	flush();
#if MSDOS_COMPILER==WIN32C
	win32_clear();
#else
	_clearscreen(_GCLEARSCREEN);
#endif
#endif
a1083 1
#if !MSDOS_COMPILER
a1084 65
#else
#if MSDOS_COMPILER==MSOFTC
	short top, left;
	short bot, right;
	struct rccoord tpos;
	
	flush();
	/*
	 * Save current state.
	 */
	tpos = _gettextposition();
	_gettextwindow(&top, &left, &bot, &right);
	/*
	 * Set a temporary window to the current line,
	 * from the cursor's position to the right edge of the screen.
	 * Then clear that window.
	 */
	_settextwindow(tpos.row, tpos.col, tpos.row, sc_width);
	_clearscreen(_GWINDOW);
	/*
	 * Restore state.
	 */
	_settextwindow(top, left, bot, right);
	_settextposition(tpos.row, tpos.col);
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
	flush();
	clreol();
#else
#if MSDOS_COMPILER==WIN32C
	DWORD           nchars;
	COORD           cpos;
	CONSOLE_SCREEN_BUFFER_INFO scr;

	flush();
	memset(&scr, 0, sizeof(scr));
	GetConsoleScreenBufferInfo(con_out, &scr);
	cpos.X = scr.dwCursorPosition.X;
	cpos.Y = scr.dwCursorPosition.Y;
	curr_attr = MAKEATTR(nm_fg_color, nm_bg_color);
	FillConsoleOutputAttribute(con_out, curr_attr,
		scr.dwSize.X - cpos.X, cpos, &nchars);
	FillConsoleOutputCharacter(con_out, ' ',
		scr.dwSize.X - cpos.X, cpos, &nchars);
#endif
#endif
#endif
#endif
}

/*
 * Clear the current line.
 * Clear the screen if there's off-screen memory below the display.
 */
	static void
clear_eol_bot()
{
#if MSDOS_COMPILER
	clear_eol();
#else
	if (below_mem)
		tputs(sc_eos_clear, 1, putchr);
	else
		tputs(sc_eol_clear, 1, putchr);
#endif
a1093 5
	/*
	 * If we're in a non-normal attribute mode, temporarily exit
	 * the mode while we do the clear.  Some terminals fill the
	 * cleared area with the current attribute.
	 */
d1095 4
a1098 26
	switch (attrmode)
	{
	case AT_STANDOUT:
		so_exit();
		clear_eol_bot();
		so_enter();
		break;
	case AT_UNDERLINE:
		ul_exit();
		clear_eol_bot();
		ul_enter();
		break;
	case AT_BOLD:
		bo_exit();
		clear_eol_bot();
		bo_enter();
		break;
	case AT_BLINK:
		bl_exit();
		clear_eol_bot();
		bl_enter();
		break;
	default:
		clear_eol_bot();
		break;
	}
a1106 1
#if !MSDOS_COMPILER
a1107 5
#else
	flush();
	SETCOLORS(so_fg_color, so_bg_color);
#endif
	attrmode = AT_STANDOUT;
a1115 1
#if !MSDOS_COMPILER
a1116 5
#else
	flush();
	SETCOLORS(nm_fg_color, nm_bg_color);
#endif
	attrmode = AT_NORMAL;
a1125 1
#if !MSDOS_COMPILER
a1126 5
#else
	flush();
	SETCOLORS(ul_fg_color, ul_bg_color);
#endif
	attrmode = AT_UNDERLINE;
a1134 1
#if !MSDOS_COMPILER
a1135 5
#else
	flush();
	SETCOLORS(nm_fg_color, nm_bg_color);
#endif
	attrmode = AT_NORMAL;
a1143 1
#if !MSDOS_COMPILER
a1144 5
#else
	flush();
	SETCOLORS(bo_fg_color, bo_bg_color);
#endif
	attrmode = AT_BOLD;
a1152 1
#if !MSDOS_COMPILER
a1153 5
#else
	flush();
	SETCOLORS(nm_fg_color, nm_bg_color);
#endif
	attrmode = AT_NORMAL;
a1161 1
#if !MSDOS_COMPILER
a1162 5
#else
	flush();
	SETCOLORS(bl_fg_color, bl_bg_color);
#endif
	attrmode = AT_BLINK;
a1170 1
#if !MSDOS_COMPILER
a1171 5
#else
	flush();
	SETCOLORS(nm_fg_color, nm_bg_color);
#endif
	attrmode = AT_NORMAL;
a1173 1
#if 0 /* No longer used */
a1180 1
#if !MSDOS_COMPILER
d1182 1
a1182 1
	 * Erase the previous character by overstriking with a space.
a1186 33
#else
#if MSDOS_COMPILER==MSOFTC
	struct rccoord tpos;
	
	flush();
	tpos = _gettextposition();
	if (tpos.col <= 1)
		return;
	_settextposition(tpos.row, tpos.col-1);
	_outtext(" ");
	_settextposition(tpos.row, tpos.col-1);
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
	cputs("\b");
#else
#if MSDOS_COMPILER==WIN32C
	COORD cpos;
	DWORD cChars;
	CONSOLE_SCREEN_BUFFER_INFO scr;

	flush();
	GetConsoleScreenBufferInfo(con_out, &scr);
	cpos = scr.dwCursorPosition;
	if (cpos.X <= 0)
		return;
	cpos.X--;
	SetConsoleCursorPosition(con_out, cpos);
	FillConsoleOutputCharacter(con_out, (TCHAR)' ', 1, cpos, &cChars);
	SetConsoleCursorPosition(con_out, cpos);
#endif
#endif
#endif
#endif
a1187 1
#endif /* 0 */
a1194 1
#if !MSDOS_COMPILER
a1195 28
#else
	int row, col;

	flush();
	{
#if MSDOS_COMPILER==MSOFTC
		struct rccoord tpos;
		tpos = _gettextposition();
		row = tpos.row;
		col = tpos.col;
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
		row = wherey();
		col = wherex();
#else
#if MSDOS_COMPILER==WIN32C
		CONSOLE_SCREEN_BUFFER_INFO scr;
		GetConsoleScreenBufferInfo(con_out, &scr);
		row = scr.dwCursorPosition.Y - scr.srWindow.Top + 1;
		col = scr.dwCursorPosition.X - scr.srWindow.Left + 1;
#endif
#endif
#endif
	}
	if (col <= 1)
		return;
	_settextposition(row, col-1);
#endif /* MSDOS_COMPILER */
a1196 100

#if MSDOS_COMPILER==WIN32C
/*
 * Determine whether an input character is waiting to be read.
 */
	static int
win32_kbhit(tty)
	HANDLE tty;
{
	INPUT_RECORD ip;
	DWORD read;

	if (keyCount > 0)
		return (TRUE);

	currentKey.ascii = 0;
	currentKey.scan = 0;

	/*
	 * Wait for a real key-down event, but
	 * ignore SHIFT and CONTROL key events.
	 */
	do
	{
		PeekConsoleInput(tty, &ip, 1, &read);
		if (read == 0)
			return (FALSE);
		ReadConsoleInput(tty, &ip, 1, &read);
	} while (ip.EventType != KEY_EVENT ||
		ip.Event.KeyEvent.bKeyDown != TRUE ||
		ip.Event.KeyEvent.wVirtualScanCode == 0 ||
		ip.Event.KeyEvent.wVirtualKeyCode == VK_SHIFT ||
		ip.Event.KeyEvent.wVirtualKeyCode == VK_CONTROL ||
		ip.Event.KeyEvent.wVirtualKeyCode == VK_MENU);
		
	currentKey.ascii = ip.Event.KeyEvent.uChar.AsciiChar;
	currentKey.scan = ip.Event.KeyEvent.wVirtualScanCode;
	keyCount = ip.Event.KeyEvent.wRepeatCount;

	if (ip.Event.KeyEvent.dwControlKeyState & 
		(LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED))
	{
		switch (currentKey.scan)
		{
		case PCK_ALT_E:     /* letter 'E' */
			currentKey.ascii = 0;
			break;
		}
	} else if (ip.Event.KeyEvent.dwControlKeyState & 
		(LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED))
	{
		switch (currentKey.scan)
		{
		case PCK_RIGHT: /* right arrow */
			currentKey.scan = PCK_CTL_RIGHT;
			break;
		case PCK_LEFT: /* left arrow */
			currentKey.scan = PCK_CTL_LEFT;
			break;
		case PCK_DELETE: /* delete */
			currentKey.scan = PCK_CTL_DELETE;
			break;
		}
	}
	return (TRUE);
}

/*
 * Read a character from the keyboard.
 */
	public char
WIN32getch(tty)
	int tty;
{
	int ascii;

	if (pending_scancode)
	{
		pending_scancode = 0;
		return ((char)(currentKey.scan & 0x00FF));
	}

	while (win32_kbhit((HANDLE)tty) == FALSE)
	{
		Sleep(20);
		if (ABORT_SIGS())
			return ('\003');
		continue;
	}
	keyCount --;
	ascii = currentKey.ascii;
	/*
	 * On PC's, the extended keys return a 2 byte sequence beginning 
	 * with '00', so if the ascii code is 00, the next byte will be 
	 * the lsb of the scan code.
	 */
	pending_scancode = (ascii == 0x00);
	return ((char)ascii);
}
#endif
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d41 3
a43 1
#if HAVE_SYS_IOCTL_H
a45 3

#if HAVE_TERMIOS_H && HAVE_TERMIOS_FUNCS
#include <termios.h>
d55 3
a167 1
	*sc_return,		/* Cursor to beginning of current line */
d192 1
a192 3
public int erase_char;		/* The user's erase char */
public int erase2_char;		/* The user's other erase char */
public int kill_char;		/* The user's line-kill char */
a204 1
extern int binattr;
a232 2
extern int top_scroll;
extern int oldbot;
a259 1
	erase2_char = '\b'; /* in case OS doesn't know about erase2 */
a341 3
#ifdef VERASE2
		erase2_char = s.c_cc[VERASE2];
#endif
a617 1
	char *s;
a618 17
	s = lgetenv("LESS_TERMCAP_DEBUG");
	if (s != NULL && *s != '\0')
	{
		struct env { struct env *next; char *name; char *value; };
		static struct env *envs = NULL;
		struct env *p;
		for (p = envs;  p != NULL;  p = p->next)
			if (strcmp(p->name, capname) == 0)
				return p->value;
		p = (struct env *) ecalloc(1, sizeof(struct env));
		p->name = save(capname);
		p->value = (char *) ecalloc(strlen(capname)+3, sizeof(char));
		sprintf(p->value, "<%s>", capname);
		p->next = envs;
		envs = p;
		return p->value;
	}
d1124 1
a1124 1
 	if (tgetent(termbuf, term) != TGETENT_OK)
d1204 1
a1204 1
		sc_eos_clear = "";
a1279 7
	 * Get carriage return string.
	 */
	sc_return = ltgetstr("cr", &sp);
	if (sc_return == NULL)
		sc_return = "\r";

	/*
a1507 14
	if (top_scroll) 
	{
		int i;

		/*
		 * This is nice to terminals with no alternate screen,
		 * but with saved scrolled-off-the-top lines.  This way,
		 * no previous line is lost, but we start with a whole
		 * screen to ourself.
		 */
		for (i = 1; i < sc_height; i++)
			putchr('\n');
	} else
		line_left();
d1744 1
a1744 1
	new_org.Y = rcClip.Top;
a1784 31
 * Move cursor to left position of current line.
 */
	public void
line_left()
{
#if !MSDOS_COMPILER
	tputs(sc_return, 1, putchr);
#else
	int row;
	flush();
#if MSDOS_COMPILER==WIN32C
	{
		CONSOLE_SCREEN_BUFFER_INFO scr;
		GetConsoleScreenBufferInfo(con_out, &scr);
		row = scr.dwCursorPosition.Y - scr.srWindow.Top + 1;
	}
#else
#if MSDOS_COMPILER==BORLANDC || MSDOS_COMPILER==DJGPPC
		row = wherey();
#else
	{
		struct rccoord tpos = _gettextposition();
		row = tpos.row;
	}
#endif
#endif
	_settextposition(row, 1);
#endif
}

/*
d1849 2
a1850 2
		at_enter(AT_STANDOUT);
		at_exit();
d1854 1
a1854 1
		at_enter(AT_STANDOUT);
d1863 1
a1863 1
		at_exit();
d2092 20
a2111 6
	if (oldbot)
		lower_left();
	else
		line_left();

	if (attrmode == AT_NORMAL)
d2113 3
a2115 5
	else
	{
		int saved_attrmode = attrmode;

		at_exit();
d2117 1
a2117 1
		at_enter(saved_attrmode);
d2121 3
d2125 1
a2125 2
at_enter(attr)
	int attr;
d2127 8
a2134 1
	attr = apply_at_specials(attr);
d2136 6
d2143 1
a2143 9
	/* The one with the most priority is last.  */
	if (attr & AT_UNDERLINE)
		tputs(sc_u_in, 1, putchr);
	if (attr & AT_BOLD)
		tputs(sc_b_in, 1, putchr);
	if (attr & AT_BLINK)
		tputs(sc_bl_in, 1, putchr);
	if (attr & AT_STANDOUT)
		tputs(sc_s_in, 1, putchr);
d2146 1
a2146 16
	/* The one with the most priority is first.  */
	if (attr & AT_STANDOUT)
	{
		SETCOLORS(so_fg_color, so_bg_color);
	} else if (attr & AT_BLINK)
	{
		SETCOLORS(bl_fg_color, bl_bg_color);
	}
	else if (attr & AT_BOLD)
	{
		SETCOLORS(bo_fg_color, bo_bg_color);
	}
	else if (attr & AT_UNDERLINE)
	{
		SETCOLORS(ul_fg_color, ul_bg_color);
	}
d2148 2
d2151 14
a2164 1
	attrmode = attr;
d2167 3
d2171 1
a2171 1
at_exit()
d2174 1
a2174 9
	/* Undo things in the reverse order we did them.  */
	if (attrmode & AT_STANDOUT)
		tputs(sc_s_out, 1, putchr);
	if (attrmode & AT_BLINK)
		tputs(sc_bl_out, 1, putchr);
	if (attrmode & AT_BOLD)
		tputs(sc_b_out, 1, putchr);
	if (attrmode & AT_UNDERLINE)
		tputs(sc_u_out, 1, putchr);
a2178 1

d2182 3
d2186 1
a2186 2
at_switch(attr)
	int attr;
d2188 8
a2195 2
	int new_attrmode = apply_at_specials(attr);
	int ignore_modes = AT_ANSI;
d2197 13
a2209 5
	if ((new_attrmode & ~ignore_modes) != (attrmode & ~ignore_modes))
	{
		at_exit();
		at_enter(attr);
	}
d2212 5
a2216 4
	public int
is_at_equiv(attr1, attr2)
	int attr1;
	int attr2;
d2218 7
a2224 4
	attr1 = apply_at_specials(attr1);
	attr2 = apply_at_specials(attr2);

	return (attr1 == attr2);
d2227 5
a2231 3
	public int
apply_at_specials(attr)
	int attr;
d2233 7
a2239 7
	if (attr & AT_BINARY)
		attr |= binattr;
	if (attr & AT_HILITE)
		attr |= AT_STANDOUT;
	attr &= ~(AT_BINARY|AT_HILITE);

	return attr;
a2427 30
}
#endif

#if MSDOS_COMPILER
/*
 */
	public void
WIN32setcolors(fg, bg)
	int fg;
	int bg;
{
	SETCOLORS(fg, bg);
}

/*
 */
	public void
WIN32textout(text, len)
	char *text;
	int len;
{
#if MSDOS_COMPILER==WIN32C
	DWORD written;
	WriteConsole(con_out, text, len, &written, NULL);
#else
	char c = text[len];
	text[len] = '\0';
	cputs(text);
	text[len] = c;
#endif
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d231 1
a231 1
extern volatile sig_atomic_t sigs;
a433 1
	tcsetattr(tty, TCSASOFT | TCSADRAIN, &s);
d437 1
a633 1
		size_t len;
d639 2
a640 3
		len = strlen(capname) + 3;
		p->value = (char *) ecalloc(len, sizeof(char));
		snprintf(p->value, len, "<%s>", capname);
d645 2
a646 2
	strlcpy(name, "LESS_TERMCAP_", sizeof(name));
	strlcat(name, capname, sizeof(name));
d805 1
a805 1
	if (sc_height <= 0)
d816 1
a816 1
	if (sc_width <= 0)
d1137 2
a1138 3
			size_t len = strlen(sp) + 9;
			termcap = (char *) ecalloc(len, sizeof(char));
			snprintf(termcap, len, "TERMCAP=%s", sp);
d1282 1
a1282 1
		strlcpy(sp, tgoto(sc_move, 0, 0), sbuf + sizeof(sbuf) - sp);
d1299 1
a1299 2
		strlcpy(sp, tgoto(sc_move, 0, sc_height-1),
		    sbuf + sizeof(sbuf) - sp);
d2047 1
a2047 1
	write(STDOUT_FILENO, "\7", 1);
@


