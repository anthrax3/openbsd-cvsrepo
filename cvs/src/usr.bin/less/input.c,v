head	1.10;
access;
symbols
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.8
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.6.0.12
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.8
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.4.0.34
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.32
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.30
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.26
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.28
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.24
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.9;
commitid	QKrr6AuGzNx9nehL;

1.9
date	2015.11.05.22.47.33;	author tedu;	state Exp;
branches;
next	1.8;
commitid	vLFUUyhjlRQmhpMd;

1.8
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.7;
commitid	yKv9Ck9ZDgwWTRTo;

1.7
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2011.09.21.19.01.49;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.13.18.26.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.04;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.48;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * High level routines dealing with getting lines of input
 * from the file being viewed.
 *
 * When we speak of "lines" here, we mean PRINTABLE lines;
 * lines processed with respect to the screen width.
 * We use the term "raw line" to refer to lines simply
 * delimited by newlines; not processed with respect to screen width.
 */

#include "less.h"

extern int squeeze;
extern int chopline;
extern int hshift;
extern int quit_if_one_screen;
extern volatile sig_atomic_t sigs;
extern int ignore_eoi;
extern int status_col;
extern off_t start_attnpos;
extern off_t end_attnpos;
extern int hilite_search;
extern int size_linebuf;

/*
 * Get the next line.
 * A "current" position is passed and a "new" position is returned.
 * The current position is the position of the first character of
 * a line.  The new position is the position of the first character
 * of the NEXT line.  The line obtained is the line starting at curr_pos.
 */
off_t
forw_line(off_t curr_pos)
{
	off_t base_pos;
	off_t new_pos;
	int c;
	int blankline;
	int endline;
	int backchars;

get_forw_line:
	if (curr_pos == -1) {
		null_line();
		return (-1);
	}
	if (hilite_search == OPT_ONPLUS || is_filtering() || status_col)
		/*
		 * If we are ignoring EOI (command F), only prepare
		 * one line ahead, to avoid getting stuck waiting for
		 * slow data without displaying the data we already have.
		 * If we're not ignoring EOI, we *could* do the same, but
		 * for efficiency we prepare several lines ahead at once.
		 */
		prep_hilite(curr_pos, curr_pos + 3*size_linebuf,
		    ignore_eoi ? 1 : -1);
	if (ch_seek(curr_pos)) {
		null_line();
		return (-1);
	}

	/*
	 * Step back to the beginning of the line.
	 */
	base_pos = curr_pos;
	for (;;) {
		if (ABORT_SIGS()) {
			null_line();
			return (-1);
		}
		c = ch_back_get();
		if (c == EOI)
			break;
		if (c == '\n') {
			(void) ch_forw_get();
			break;
		}
		--base_pos;
	}

	/*
	 * Read forward again to the position we should start at.
	 */
	prewind();
	plinenum(base_pos);
	(void) ch_seek(base_pos);
	new_pos = base_pos;
	while (new_pos < curr_pos) {
		if (ABORT_SIGS()) {
			null_line();
			return (-1);
		}
		c = ch_forw_get();
		backchars = pappend(c, new_pos);
		new_pos++;
		if (backchars > 0) {
			pshift_all();
			new_pos -= backchars;
			while (--backchars >= 0)
				(void) ch_back_get();
		}
	}
	(void) pflushmbc();
	pshift_all();

	/*
	 * Read the first character to display.
	 */
	c = ch_forw_get();
	if (c == EOI) {
		null_line();
		return (-1);
	}
	blankline = (c == '\n' || c == '\r');

	/*
	 * Read each character in the line and append to the line buffer.
	 */
	for (;;) {
		if (ABORT_SIGS()) {
			null_line();
			return (-1);
		}
		if (c == '\n' || c == EOI) {
			/*
			 * End of the line.
			 */
			backchars = pflushmbc();
			new_pos = ch_tell();
			if (backchars > 0 && !chopline && hshift == 0) {
				new_pos -= backchars + 1;
				endline = FALSE;
			} else
				endline = TRUE;
			break;
		}
		if (c != '\r')
			blankline = 0;

		/*
		 * Append the char to the line and get the next char.
		 */
		backchars = pappend(c, ch_tell()-1);
		if (backchars > 0) {
			/*
			 * The char won't fit in the line; the line
			 * is too long to print in the screen width.
			 * End the line here.
			 */
			if (chopline || hshift > 0) {
				do {
					if (ABORT_SIGS()) {
						null_line();
						return (-1);
					}
					c = ch_forw_get();
				} while (c != '\n' && c != EOI);
				new_pos = ch_tell();
				endline = TRUE;
				quit_if_one_screen = FALSE;
			} else {
				new_pos = ch_tell() - backchars;
				endline = FALSE;
			}
			break;
		}
		c = ch_forw_get();
	}

	pdone(endline, 1);

	if (is_filtered(base_pos)) {
		/*
		 * We don't want to display this line.
		 * Get the next line.
		 */
		curr_pos = new_pos;
		goto get_forw_line;
	}

	if (status_col && is_hilited(base_pos, ch_tell()-1, 1, NULL))
		set_status_col('*');

	if (squeeze && blankline) {
		/*
		 * This line is blank.
		 * Skip down to the last contiguous blank line
		 * and pretend it is the one which we are returning.
		 */
		while ((c = ch_forw_get()) == '\n' || c == '\r')
			if (ABORT_SIGS()) {
				null_line();
				return (-1);
			}
		if (c != EOI)
			(void) ch_back_get();
		new_pos = ch_tell();
	}

	return (new_pos);
}

/*
 * Get the previous line.
 * A "current" position is passed and a "new" position is returned.
 * The current position is the position of the first character of
 * a line.  The new position is the position of the first character
 * of the PREVIOUS line.  The line obtained is the one starting at new_pos.
 */
off_t
back_line(off_t curr_pos)
{
	off_t new_pos, begin_new_pos, base_pos;
	int c;
	int endline;
	int backchars;

get_back_line:
	if (curr_pos == -1 || curr_pos <= ch_zero()) {
		null_line();
		return (-1);
	}
	if (hilite_search == OPT_ONPLUS || is_filtering() || status_col)
		prep_hilite((curr_pos < 3*size_linebuf) ?
		    0 : curr_pos - 3*size_linebuf, curr_pos, -1);
	if (ch_seek(curr_pos-1)) {
		null_line();
		return (-1);
	}

	if (squeeze) {
		/*
		 * Find out if the "current" line was blank.
		 */
		(void) ch_forw_get();	/* Skip the newline */
		c = ch_forw_get();	/* First char of "current" line */
		(void) ch_back_get();	/* Restore our position */
		(void) ch_back_get();

		if (c == '\n' || c == '\r') {
			/*
			 * The "current" line was blank.
			 * Skip over any preceding blank lines,
			 * since we skipped them in forw_line().
			 */
			while ((c = ch_back_get()) == '\n' || c == '\r')
				if (ABORT_SIGS()) {
					null_line();
					return (-1);
				}
			if (c == EOI) {
				null_line();
				return (-1);
			}
			(void) ch_forw_get();
		}
	}

	/*
	 * Scan backwards until we hit the beginning of the line.
	 */
	for (;;) {
		if (ABORT_SIGS()) {
			null_line();
			return (-1);
		}
		c = ch_back_get();
		if (c == '\n') {
			/*
			 * This is the newline ending the previous line.
			 * We have hit the beginning of the line.
			 */
			base_pos = ch_tell() + 1;
			break;
		}
		if (c == EOI) {
			/*
			 * We have hit the beginning of the file.
			 * This must be the first line in the file.
			 * This must, of course, be the beginning of the line.
			 */
			base_pos = ch_tell();
			break;
		}
	}

	/*
	 * Now scan forwards from the beginning of this line.
	 * We keep discarding "printable lines" (based on screen width)
	 * until we reach the curr_pos.
	 *
	 * {{ This algorithm is pretty inefficient if the lines
	 *    are much longer than the screen width,
	 *    but I don't know of any better way. }}
	 */
	new_pos = base_pos;
	if (ch_seek(new_pos)) {
		null_line();
		return (-1);
	}
	endline = FALSE;
	prewind();
	plinenum(new_pos);
loop:
	begin_new_pos = new_pos;
	(void) ch_seek(new_pos);

	do {
		c = ch_forw_get();
		if (c == EOI || ABORT_SIGS()) {
			null_line();
			return (-1);
		}
		new_pos++;
		if (c == '\n') {
			backchars = pflushmbc();
			if (backchars > 0 && !chopline && hshift == 0) {
				backchars++;
				goto shift;
			}
			endline = TRUE;
			break;
		}
		backchars = pappend(c, ch_tell()-1);
		if (backchars > 0) {
			/*
			 * Got a full printable line, but we haven't
			 * reached our curr_pos yet.  Discard the line
			 * and start a new one.
			 */
			if (chopline || hshift > 0) {
				endline = TRUE;
				quit_if_one_screen = FALSE;
				break;
			}
		shift:
			pshift_all();
			while (backchars-- > 0) {
				(void) ch_back_get();
				new_pos--;
			}
			goto loop;
		}
	} while (new_pos < curr_pos);

	pdone(endline, 0);

	if (is_filtered(base_pos)) {
		/*
		 * We don't want to display this line.
		 * Get the previous line.
		 */
		curr_pos = begin_new_pos;
		goto get_back_line;
	}

	if (status_col && curr_pos > 0 &&
	    is_hilited(base_pos, curr_pos-1, 1, NULL))
		set_status_col('*');

	return (begin_new_pos);
}

/*
 * Set attnpos.
 */
void
set_attnpos(off_t pos)
{
	int c;

	if (pos != -1) {
		if (ch_seek(pos))
			return;
		for (;;) {
			c = ch_forw_get();
			if (c == EOI)
				return;
			if (c != '\n' && c != '\r')
				break;
			pos++;
		}
	}
	start_attnpos = pos;
	for (;;) {
		c = ch_forw_get();
		pos++;
		if (c == EOI || c == '\n' || c == '\r')
			break;
	}
	end_attnpos = pos;
}
@


1.9
log
@deregister
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.8
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d50 1
a50 1
	register int c;
@


1.7
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

d15 1
a15 1
 * High level routines dealing with getting lines of input 
d33 2
a34 3
extern POSITION start_attnpos;
extern POSITION end_attnpos;
#if HILITE_SEARCH
a36 1
#endif
d45 2
a46 3
	public POSITION
forw_line(curr_pos)
	POSITION curr_pos;
d48 2
a49 2
	POSITION base_pos;
	POSITION new_pos;
d56 1
a56 2
	if (curr_pos == NULL_POSITION)
	{
d58 1
a58 1
		return (NULL_POSITION);
a59 1
#if HILITE_SEARCH
d68 3
a70 5
		prep_hilite(curr_pos, curr_pos + 3*size_linebuf, 
				ignore_eoi ? 1 : -1);
#endif
	if (ch_seek(curr_pos))
	{
d72 1
a72 1
		return (NULL_POSITION);
d79 2
a80 4
	for (;;)
	{
		if (ABORT_SIGS())
		{
d82 1
a82 1
			return (NULL_POSITION);
d87 1
a87 2
		if (c == '\n')
		{
d97 1
a97 1
 	prewind();
d101 2
a102 4
	while (new_pos < curr_pos)
	{
		if (ABORT_SIGS())
		{
d104 1
a104 1
			return (NULL_POSITION);
d109 1
a109 2
		if (backchars > 0)
		{
d123 1
a123 2
	if (c == EOI)
	{
d125 1
a125 1
		return (NULL_POSITION);
d132 2
a133 4
	for (;;)
	{
		if (ABORT_SIGS())
		{
d135 1
a135 1
			return (NULL_POSITION);
d137 1
a137 2
		if (c == '\n' || c == EOI)
		{
d143 1
a143 2
			if (backchars > 0 && !chopline && hshift == 0)
			{
d157 1
a157 2
		if (backchars > 0)
		{
d163 3
a165 6
			if (chopline || hshift > 0)
			{
				do
				{
					if (ABORT_SIGS())
					{
d167 1
a167 1
						return (NULL_POSITION);
d174 1
a174 2
			} else
			{
d185 1
a185 3
#if HILITE_SEARCH
	if (is_filtered(base_pos))
	{
a195 1
#endif
d197 1
a197 2
	if (squeeze && blankline)
	{
d204 1
a204 2
			if (ABORT_SIGS())
			{
d206 1
a206 1
				return (NULL_POSITION);
d223 2
a224 3
	public POSITION
back_line(curr_pos)
	POSITION curr_pos;
d226 1
a226 1
	POSITION new_pos, begin_new_pos, base_pos;
d232 1
a232 2
	if (curr_pos == NULL_POSITION || curr_pos <= ch_zero())
	{
d234 1
a234 1
		return (NULL_POSITION);
a235 1
#if HILITE_SEARCH
d237 3
a239 5
		prep_hilite((curr_pos < 3*size_linebuf) ? 
				0 : curr_pos - 3*size_linebuf, curr_pos, -1);
#endif
	if (ch_seek(curr_pos-1))
	{
d241 1
a241 1
		return (NULL_POSITION);
d244 1
a244 2
	if (squeeze)
	{
d248 3
a250 3
		(void) ch_forw_get();    /* Skip the newline */
		c = ch_forw_get();       /* First char of "current" line */
		(void) ch_back_get();    /* Restore our position */
d253 1
a253 2
		if (c == '\n' || c == '\r')
		{
d260 1
a260 2
				if (ABORT_SIGS())
				{
d262 1
a262 1
					return (NULL_POSITION);
d264 1
a264 2
			if (c == EOI)
			{
d266 1
a266 1
				return (NULL_POSITION);
d275 2
a276 4
	for (;;)
	{
		if (ABORT_SIGS())
		{
d278 1
a278 1
			return (NULL_POSITION);
d281 1
a281 2
		if (c == '\n')
		{
d289 1
a289 2
		if (c == EOI)
		{
d306 1
a306 1
	 *    are much longer than the screen width, 
d310 1
a310 2
	if (ch_seek(new_pos))
	{
d312 1
a312 1
		return (NULL_POSITION);
d317 1
a317 1
    loop:
d321 1
a321 2
	do
	{
d323 1
a323 2
		if (c == EOI || ABORT_SIGS())
		{
d325 1
a325 1
			return (NULL_POSITION);
d328 1
a328 2
		if (c == '\n')
		{
d330 1
a330 2
			if (backchars > 0 && !chopline && hshift == 0)
			{
d338 1
a338 2
		if (backchars > 0)
		{
d344 1
a344 2
			if (chopline || hshift > 0)
			{
d351 1
a351 2
			while (backchars-- > 0)
			{
d361 1
a361 3
#if HILITE_SEARCH
	if (is_filtered(base_pos))
	{
d370 2
a371 1
	if (status_col && curr_pos > 0 && is_hilited(base_pos, curr_pos-1, 1, NULL))
a372 1
#endif
d380 2
a381 3
	public void
set_attnpos(pos)
	POSITION pos;
d385 1
a385 2
	if (pos != NULL_POSITION)
	{
d388 1
a388 2
		for (;;)
		{
d398 1
a398 2
	for (;;)
	{
@


1.6
log
@Use volatile sig_atomic_t, not int, for the sigs variable.  Also
move the call to bell() out of u_interrupt() (a signal handler).
OK and with help from deraadt@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d418 1
a418 1
	if (status_col && is_hilited(base_pos, ch_tell()-1, 1, NULL))
@


1.5
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d28 1
a28 1
extern int sigs;
@


1.4
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d30 1
d49 1
d54 1
d56 1
d63 1
a63 1
	if (hilite_search == OPT_ONPLUS)
d80 49
a128 3
	prewind();
	plinenum(curr_pos);
	(void) ch_seek(curr_pos);
d130 3
d141 3
d156 1
d158 6
a163 1
			endline = TRUE;
d166 2
d172 2
a173 1
		if (pappend(c, ch_tell()-1))
d184 5
d196 1
a196 1
				new_pos = ch_tell() - 1;
d203 17
a219 1
	pdone(endline);
d253 1
a253 1
	POSITION new_pos, begin_new_pos;
d256 1
d258 1
d265 1
a265 1
	if (hilite_search == OPT_ONPLUS)
d280 3
a282 3
		(void) ch_forw_get();	/* Skip the newline */
		c = ch_forw_get();	/* First char of "current" line */
		(void) ch_back_get();	/* Restore our position */
d324 1
a324 1
			new_pos = ch_tell() + 1;
d334 1
a334 1
			new_pos = ch_tell();
d348 1
d355 2
a358 2
	prewind();
	plinenum(new_pos);
d372 6
d381 2
a382 1
		if (pappend(c, ch_tell()-1))
d395 7
a401 3
			pdone(0);
			(void) ch_back_get();
			new_pos--;
d406 16
a421 1
	pdone(endline);
@


1.3
log
@kill more registers

millert@@ ok
@
text
@a0 2
/*	$OpenBSD: input.c,v 1.2 2001/01/29 01:58:02 niklas Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d26 2
d29 3
d49 1
a49 1
	int c;
d60 9
a68 1
		prep_hilite(curr_pos, curr_pos + 3*size_linebuf);
d101 1
a101 1
			endline = 1;
d115 1
a115 1
			if (chopline)
d122 2
a123 1
				endline = 1;
d127 1
a127 1
				endline = 0;
d179 1
a179 1
				0 : curr_pos - 3*size_linebuf, curr_pos);
d265 1
a265 1
	endline = 0;
d283 1
a283 1
			endline = 1;
d293 1
a293 1
			if (chopline)
d295 2
a296 1
				endline = 1;
d309 34
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 1
a62 1
	register int c;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
a41 2
extern int hshift;
extern int quit_if_one_screen;
a42 3
extern int ignore_eoi;
extern POSITION start_attnpos;
extern POSITION end_attnpos;
d71 1
a71 9
		/*
		 * If we are ignoring EOI (command F), only prepare
		 * one line ahead, to avoid getting stuck waiting for
		 * slow data without displaying the data we already have.
		 * If we're not ignoring EOI, we *could* do the same, but
		 * for efficiency we prepare several lines ahead at once.
		 */
		prep_hilite(curr_pos, curr_pos + 3*size_linebuf, 
				ignore_eoi ? 1 : -1);
d104 1
a104 1
			endline = TRUE;
d118 1
a118 1
			if (chopline || hshift > 0)
d125 1
a125 2
				endline = TRUE;
				quit_if_one_screen = FALSE;
d129 1
a129 1
				endline = FALSE;
d181 1
a181 1
				0 : curr_pos - 3*size_linebuf, curr_pos, -1);
d267 1
a267 1
	endline = FALSE;
d285 1
a285 1
			endline = TRUE;
d295 1
a295 1
			if (chopline || hshift > 0)
d297 1
a297 2
				endline = TRUE;
				quit_if_one_screen = FALSE;
a309 34
}

/*
 * Set attnpos.
 */
	public void
set_attnpos(pos)
	POSITION pos;
{
	int c;

	if (pos != NULL_POSITION)
	{
		if (ch_seek(pos))
			return;
		for (;;)
		{
			c = ch_forw_get();
			if (c == EOI)
				return;
			if (c != '\n' && c != '\r')
				break;
			pos++;
		}
	}
	start_attnpos = pos;
	for (;;)
	{
		c = ch_forw_get();
		pos++;
		if (c == EOI || c == '\n' || c == '\r')
			break;
	}
	end_attnpos = pos;
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
a29 1
extern int status_col;
a47 1
	POSITION base_pos;
a51 1
	int backchars;
a52 1
get_forw_line:
d59 1
a59 1
	if (hilite_search == OPT_ONPLUS || is_filtering() || status_col)
d76 3
a78 21
	/*
	 * Step back to the beginning of the line.
	 */
	base_pos = curr_pos;
	for (;;)
	{
		if (ABORT_SIGS())
		{
			null_line();
			return (NULL_POSITION);
		}
		c = ch_back_get();
		if (c == EOI)
			break;
		if (c == '\n')
		{
			(void) ch_forw_get();
			break;
		}
		--base_pos;
	}
a79 31
	/*
	 * Read forward again to the position we should start at.
	 */
 	prewind();
	plinenum(base_pos);
	(void) ch_seek(base_pos);
	new_pos = base_pos;
	while (new_pos < curr_pos)
	{
		if (ABORT_SIGS())
		{
			null_line();
			return (NULL_POSITION);
		}
		c = ch_forw_get();
		backchars = pappend(c, new_pos);
		new_pos++;
		if (backchars > 0)
		{
			pshift_all();
			new_pos -= backchars;
			while (--backchars >= 0)
				(void) ch_back_get();
		}
	}
	(void) pflushmbc();
	pshift_all();

	/*
	 * Read the first character to display.
	 */
a87 3
	/*
	 * Read each character in the line and append to the line buffer.
	 */
a99 1
			backchars = pflushmbc();
d101 1
a101 6
			if (backchars > 0 && !chopline && hshift == 0)
			{
				new_pos -= backchars + 1;
				endline = FALSE;
			} else
				endline = TRUE;
a103 2
		if (c != '\r')
			blankline = 0;
d108 1
a108 2
		backchars = pappend(c, ch_tell()-1);
		if (backchars > 0)
a118 5
					if (ABORT_SIGS())
					{
						null_line();
						return (NULL_POSITION);
					}
d126 1
a126 1
				new_pos = ch_tell() - backchars;
d133 1
a133 17

	pdone(endline, 1);

#if HILITE_SEARCH
	if (is_filtered(base_pos))
	{
		/*
		 * We don't want to display this line.
		 * Get the next line.
		 */
		curr_pos = new_pos;
		goto get_forw_line;
	}

	if (status_col && is_hilited(base_pos, ch_tell()-1, 1, NULL))
		set_status_col('*');
#endif
d167 1
a167 1
	POSITION new_pos, begin_new_pos, base_pos;
a169 1
	int backchars;
a170 1
get_back_line:
d177 1
a177 1
	if (hilite_search == OPT_ONPLUS || is_filtering() || status_col)
d192 3
a194 3
		(void) ch_forw_get();    /* Skip the newline */
		c = ch_forw_get();       /* First char of "current" line */
		(void) ch_back_get();    /* Restore our position */
d236 1
a236 1
			base_pos = ch_tell() + 1;
d246 1
a246 1
			base_pos = ch_tell();
a259 1
	new_pos = base_pos;
d266 2
a269 2
    loop:
	begin_new_pos = new_pos;
a282 6
			backchars = pflushmbc();
			if (backchars > 0 && !chopline && hshift == 0)
			{
				backchars++;
				goto shift;
			}
d286 1
a286 2
		backchars = pappend(c, ch_tell()-1);
		if (backchars > 0)
d299 3
a301 7
		shift:
			pshift_all();
			while (backchars-- > 0)
			{
				(void) ch_back_get();
				new_pos--;
			}
d306 1
a306 16
	pdone(endline, 0);

#if HILITE_SEARCH
	if (is_filtered(base_pos))
	{
		/*
		 * We don't want to display this line.
		 * Get the previous line.
		 */
		curr_pos = begin_new_pos;
		goto get_back_line;
	}

	if (status_col && is_hilited(base_pos, ch_tell()-1, 1, NULL))
		set_status_col('*');
#endif
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d28 1
a28 1
extern volatile sig_atomic_t sigs;
d419 1
a419 1
	if (status_col && curr_pos > 0 && is_hilited(base_pos, curr_pos-1, 1, NULL))
@


