head	1.16;
access;
symbols
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.7.0.12
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.8
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.6
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.6.0.34
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.32
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.30
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.26
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.28
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.24
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.22
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.20
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.18
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	W32EN7Zp77efb8wW;

1.15
date	2015.11.23.09.26.51;	author nicm;	state Exp;
branches;
next	1.14;
commitid	kcUyxO9zLNo75SlC;

1.14
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	ZtGimechwgSRYqRW;

1.13
date	2015.11.09.14.25.32;	author mmcc;	state Exp;
branches;
next	1.12;
commitid	bgQj8bNZKDat4TZ4;

1.12
date	2015.11.07.18.07.44;	author tedu;	state Exp;
branches;
next	1.11;
commitid	DJUwzdj0cG1bCfEw;

1.11
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.10;
commitid	QKrr6AuGzNx9nehL;

1.10
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.9;
commitid	yKv9Ck9ZDgwWTRTo;

1.9
date	2014.04.25.18.07.41;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.7;

1.7
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.14.15.09.57;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.13.09.09.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.03;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.07;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.49;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.16
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Process command line options.
 *
 * Each option is a single letter which controls a program variable.
 * The options have defaults which may be changed via
 * the command line option, toggled via the "-" command,
 * or queried via the "_" command.
 */

#include "less.h"
#include "option.h"

static struct loption *pendopt;
int plusoption = FALSE;

static char *optstring(char *, char **, char *, char *);
static int flip_triple(int, int);

extern int screen_trashed;
extern int less_is_more;
extern int quit_at_eof;
extern char *every_first_cmd;
extern int opt_use_backslash;

/*
 * Return a printable description of an option.
 */
static char *
opt_desc(struct loption *o)
{
	static char buf[OPTNAME_MAX + 10];
	if (o->oletter == OLETTER_NONE)
		(void) snprintf(buf, sizeof (buf), "--%s", o->onames->oname);
	else
		(void) snprintf(buf, sizeof (buf), "-%c (--%s)",
		    o->oletter, o->onames->oname);
	return (buf);
}

/*
 * Return a string suitable for printing as the "name" of an option.
 * For example, if the option letter is 'x', just return "-x".
 */
char *
propt(int c)
{
	static char buf[8];

	(void) snprintf(buf, sizeof (buf), "-%s", prchar(c));
	return (buf);
}

/*
 * Scan an argument (either from the command line or from the
 * LESS environment variable) and process it.
 */
void
scan_option(char *s)
{
	struct loption *o;
	int optc;
	char *optname;
	char *printopt;
	char *str;
	int set_default;
	int lc;
	int err;
	int moreopt;
	PARG parg;

	if (s == NULL)
		return;

	/*
	 * If we have a pending option which requires an argument,
	 * handle it now.
	 * This happens if the previous option was, for example, "-P"
	 * without a following string.  In that case, the current
	 * option is simply the argument for the previous option.
	 */
	if (pendopt != NULL) {
		switch (pendopt->otype & OTYPE) {
		case STRING:
			(*pendopt->ofunc)(INIT, s);
			break;
		case NUMBER:
			printopt = opt_desc(pendopt);
			*(pendopt->ovar) = getnum(&s, printopt, NULL);
			break;
		}
		pendopt = NULL;
		return;
	}

	set_default = FALSE;
	optname = NULL;
	moreopt = 0;
	o = NULL;

	while (*s != '\0') {
		/*
		 * Check some special cases first.
		 */
		switch (optc = *s++) {
		case ' ':
		case '\t':
		case END_OPTION_STRING:
			continue;
		case '-':
			/*
			 * "--" indicates an option name instead of a letter.
			 */
			if (*s == '-') {
				if (!less_is_more) {
					optname = ++s;
				}
				break;
			}
			/*
			 * "-+" means set these options back to their defaults.
			 * (They may have been set otherwise by previous
			 * options.)
			 */
			if (!less_is_more) {
				set_default = (*s == '+');
				if (set_default)
					s++;
			}
			continue;
		case '+':
			/*
			 * An option prefixed by a "+" is ungotten, so
			 * that it is interpreted as less commands
			 * processed at the start of the first input file.
			 * "++" means process the commands at the start of
			 * EVERY input file.
			 */
			plusoption = TRUE;
			s = optstring(s, &str, propt('+'), NULL);
			if (s == NULL)
				return;
			if (*str == '+')
				every_first_cmd = estrdup(str+1);
			else
				ungetsc(str);
			free(str);
			continue;
		case '0':  case '1':  case '2':  case '3':  case '4':
		case '5':  case '6':  case '7':  case '8':  case '9':
			/*
			 * Special "more" compatibility form "-<number>"
			 * instead of -z<number> to set the scrolling
			 * window size.
			 */
			s--;
			optc = 'z';
			moreopt = 1;
			break;
		case 'n':
			if (less_is_more) {
				moreopt = 1;
				optc = 'z';
			}
			break;
		case 'i':
			if (less_is_more) {
				moreopt = 1;
				optc = 'I';
			}
			break;
		case 'u':
			if (less_is_more) {
				moreopt = 1;
				optc = 'U';
			}
			break;
		case 'e':
			if (less_is_more) {
				moreopt = 1;
				optc = 'E';
			}
			break;
		case 'h':
			if (less_is_more) {
				moreopt = 1;
				optc = '?';
			}
			break;
		case 'd':
			if (less_is_more) {
				moreopt = 1;
				optc = 'M';
			}
			break;
		}

		/*
		 * Not a special case.
		 * Look up the option letter in the option table.
		 */
		err = 0;
		if (optname == NULL) {
			printopt = propt(optc);
			lc = islower(optc);
			o = findopt(optc);
			if (less_is_more && (!moreopt) && (o != NULL) &&
			    ((o->otype & MORE_OK) == 0)) {
				o = NULL;
			}
		} else {
			printopt = optname;
			lc = islower(optname[0]);
			o = findopt_name(&optname, NULL, &err);
			s = optname;
			optname = NULL;
			switch (*s) {
			case ' ':	/* name matches exactly */
			case '\0':
				break;

			case '=':	/* name followed by "=value" */
				if (o != NULL &&
				    (o->otype & OTYPE) != STRING &&
				    (o->otype & OTYPE) != NUMBER) {
					parg.p_string = printopt;
					error("The %s option should not be "
					    "followed by =", &parg);
					return;
				}
				s++;
				break;
			default:	/* name longer than option, bad */
				o = NULL;
			}
		}
		if (o == NULL) {
			parg.p_string = printopt;
			if (less_is_more) {
				error("Illegal option %s (more -h for help)",
				    &parg);
			} else if (err == OPT_AMBIG) {
				error("%s is an ambiguous abbreviation "
				    "(\"less --help\" for help)", &parg);
			} else {
				error("There is no %s option "
				    "(\"less --help\" for help)", &parg);
			}
			return;
		}

		str = NULL;
		switch (o->otype & OTYPE) {
		case BOOL:
			if (set_default)
				*(o->ovar) = o->odefault;
			else
				*(o->ovar) = ! o->odefault;
			break;
		case TRIPLE:
			if (set_default)
				*(o->ovar) = o->odefault;
			else
				*(o->ovar) = flip_triple(o->odefault, lc);
			break;
		case STRING:
			if (*s == '\0') {
				/*
				 * Set pendopt and return.
				 * We will get the string next time
				 * scan_option is called.
				 */
				pendopt = o;
				return;
			}
			/*
			 * Don't do anything here.
			 * All processing of STRING options is done by
			 * the handling function.
			 */
			while (*s == ' ')
				s++;
			s = optstring(s, &str, printopt, o->odesc[1]);
			if (s == NULL)
				return;
			break;
		case NUMBER:
			if (*s == '\0') {
				pendopt = o;
				return;
			}
			*(o->ovar) = getnum(&s, printopt, NULL);
			break;
		}
		/*
		 * If the option has a handling function, call it.
		 */
		if (o->ofunc != NULL)
			(*o->ofunc)(INIT, str);
		free(str);
	}
}

/*
 * Toggle command line flags from within the program.
 * Used by the "-" and "_" commands.
 * how_toggle may be:
 *	OPT_NO_TOGGLE	just report the current setting, without changing it.
 *	OPT_TOGGLE	invert the current setting
 *	OPT_UNSET	set to the default value
 *	OPT_SET		set to the inverse of the default value
 */
void
toggle_option(struct loption *o, int lower, char *s, int how_toggle)
{
	int num;
	int no_prompt;
	int err;
	PARG parg;

	no_prompt = (how_toggle & OPT_NO_PROMPT);
	how_toggle &= ~OPT_NO_PROMPT;

	if (o == NULL) {
		error("No such option", NULL);
		return;
	}

	if (how_toggle == OPT_TOGGLE && (o->otype & NO_TOGGLE)) {
		parg.p_string = opt_desc(o);
		error("Cannot change the %s option", &parg);
		return;
	}

	if (how_toggle == OPT_NO_TOGGLE && (o->otype & NO_QUERY)) {
		parg.p_string = opt_desc(o);
		error("Cannot query the %s option", &parg);
		return;
	}

	/*
	 * Check for something which appears to be a do_toggle
	 * (because the "-" command was used), but really is not.
	 * This could be a string option with no string, or
	 * a number option with no number.
	 */
	switch (o->otype & OTYPE) {
	case STRING:
	case NUMBER:
		if (how_toggle == OPT_TOGGLE && *s == '\0')
			how_toggle = OPT_NO_TOGGLE;
		break;
	}

	if (how_toggle != OPT_NO_TOGGLE && (o->otype & HL_REPAINT))
		repaint_hilite(0);

	/*
	 * Now actually toggle (change) the variable.
	 */
	if (how_toggle != OPT_NO_TOGGLE) {
		switch (o->otype & OTYPE) {
		case BOOL:
			/*
			 * Boolean.
			 */
			switch (how_toggle) {
			case OPT_TOGGLE:
				*(o->ovar) = ! *(o->ovar);
				break;
			case OPT_UNSET:
				*(o->ovar) = o->odefault;
				break;
			case OPT_SET:
				*(o->ovar) = ! o->odefault;
				break;
			}
			break;
		case TRIPLE:
			/*
			 * Triple:
			 *	If user gave the lower case letter, then switch
			 *	to 1 unless already 1, in which case make it 0.
			 *	If user gave the upper case letter, then switch
			 *	to 2 unless already 2, in which case make it 0.
			 */
			switch (how_toggle) {
			case OPT_TOGGLE:
				*(o->ovar) = flip_triple(*(o->ovar), lower);
				break;
			case OPT_UNSET:
				*(o->ovar) = o->odefault;
				break;
			case OPT_SET:
				*(o->ovar) = flip_triple(o->odefault, lower);
				break;
			}
			break;
		case STRING:
			/*
			 * String: don't do anything here.
			 *	The handling function will do everything.
			 */
			switch (how_toggle) {
			case OPT_SET:
			case OPT_UNSET:
				error("Cannot use \"-+\" or \"--\" "
				    "for a string option", NULL);
				return;
			}
			break;
		case NUMBER:
			/*
			 * Number: set the variable to the given number.
			 */
			switch (how_toggle) {
			case OPT_TOGGLE:
				num = getnum(&s, NULL, &err);
				if (!err)
					*(o->ovar) = num;
				break;
			case OPT_UNSET:
				*(o->ovar) = o->odefault;
				break;
			case OPT_SET:
				error("Can't use \"-!\" for a numeric option",
				    NULL);
				return;
			}
			break;
		}
	}

	/*
	 * Call the handling function for any special action
	 * specific to this option.
	 */
	if (o->ofunc != NULL)
		(*o->ofunc)((how_toggle == OPT_NO_TOGGLE) ? QUERY : TOGGLE, s);

	if (how_toggle != OPT_NO_TOGGLE && (o->otype & HL_REPAINT))
		chg_hilite();

	if (!no_prompt) {
		/*
		 * Print a message describing the new setting.
		 */
		switch (o->otype & OTYPE) {
		case BOOL:
		case TRIPLE:
			/*
			 * Print the odesc message.
			 */
			error(o->odesc[*(o->ovar)], NULL);
			break;
		case NUMBER:
			/*
			 * The message is in odesc[1] and has a %d for
			 * the value of the variable.
			 */
			parg.p_int = *(o->ovar);
			error(o->odesc[1], &parg);
			break;
		case STRING:
			/*
			 * Message was already printed by the handling function.
			 */
			break;
		}
	}

	if (how_toggle != OPT_NO_TOGGLE && (o->otype & REPAINT))
		screen_trashed = TRUE;
}

/*
 * "Toggle" a triple-valued option.
 */
static int
flip_triple(int val, int lc)
{
	if (lc)
		return ((val == OPT_ON) ? OPT_OFF : OPT_ON);
	else
		return ((val == OPT_ONPLUS) ? OPT_OFF : OPT_ONPLUS);
}

/*
 * Determine if an option takes a parameter.
 */
int
opt_has_param(struct loption *o)
{
	if (o == NULL)
		return (0);
	if (o->otype & (BOOL|TRIPLE|NOVAR|NO_TOGGLE))
		return (0);
	return (1);
}

/*
 * Return the prompt to be used for a given option letter.
 * Only string and number valued options have prompts.
 */
char *
opt_prompt(struct loption *o)
{
	if (o == NULL || (o->otype & (STRING|NUMBER)) == 0)
		return ("?");
	return (o->odesc[0]);
}

/*
 * Return whether or not there is a string option pending;
 * that is, if the previous option was a string-valued option letter
 * (like -P) without a following string.
 * In that case, the current option is taken to be the string for
 * the previous option.
 */
int
isoptpending(void)
{
	return (pendopt != NULL);
}

/*
 * Print error message about missing string.
 */
static void
nostring(char *printopt)
{
	PARG parg;
	parg.p_string = printopt;
	error("Value is required after %s", &parg);
}

/*
 * Print error message if a STRING type option is not followed by a string.
 */
void
nopendopt(void)
{
	nostring(opt_desc(pendopt));
}

/*
 * Scan to end of string or to an END_OPTION_STRING character.
 * In the latter case, replace the char with a null char.
 * Return a pointer to the remainder of the string, if any.
 */
static char *
optstring(char *s, char **p_str, char *printopt, char *validchars)
{
	char *p;
	char *out;

	if (*s == '\0') {
		nostring(printopt);
		return (NULL);
	}
	/* Alloc could be more than needed, but not worth trimming. */
	*p_str = ecalloc(strlen(s)+1, sizeof (char));
	out = *p_str;

	for (p = s; *p != '\0'; p++) {
		if (opt_use_backslash && *p == '\\' && p[1] != '\0') {
			/* Take next char literally. */
			++p;
		} else {
			if (*p == END_OPTION_STRING ||
			    (validchars != NULL &&
			    strchr(validchars, *p) == NULL))
				/* End of option string. */
				break;
		}
		*out++ = *p;
	}
	*out = '\0';
	return (p);
}

/*
 */
static int
num_error(char *printopt, int *errp)
{
	PARG parg;

	if (errp != NULL) {
		*errp = TRUE;
		return (-1);
	}
	if (printopt != NULL) {
		parg.p_string = printopt;
		error("Number is required after %s", &parg);
	}
	return (-1);
}

/*
 * Translate a string into a number.
 * Like atoi(), but takes a pointer to a char *, and updates
 * the char * to point after the translated number.
 */
int
getnum(char **sp, char *printopt, int *errp)
{
	char *s;
	int n;
	int neg;

	s = skipsp(*sp);
	neg = FALSE;
	if (*s == '-') {
		neg = TRUE;
		s++;
	}
	if (*s < '0' || *s > '9')
		return (num_error(printopt, errp));

	n = 0;
	while (*s >= '0' && *s <= '9')
		n = 10 * n + *s++ - '0';
	*sp = s;
	if (errp != NULL)
		*errp = FALSE;
	if (neg)
		n = -n;
	return (n);
}

/*
 * Translate a string into a fraction, represented by the part of a
 * number which would follow a decimal point.
 * The value of the fraction is returned as parts per NUM_FRAC_DENOM.
 * That is, if "n" is returned, the fraction intended is n/NUM_FRAC_DENOM.
 */
long
getfraction(char **sp, char *printopt, int *errp)
{
	char *s;
	long frac = 0;
	int fraclen = 0;

	s = skipsp(*sp);
	if (*s < '0' || *s > '9')
		return (num_error(printopt, errp));

	for (; *s >= '0' && *s <= '9'; s++) {
		frac = (frac * 10) + (*s - '0');
		fraclen++;
	}
	if (fraclen > NUM_LOG_FRAC_DENOM)
		while (fraclen-- > NUM_LOG_FRAC_DENOM)
			frac /= 10;
	else
		while (fraclen++ < NUM_LOG_FRAC_DENOM)
			frac *= 10;
	*sp = s;
	if (errp != NULL)
		*errp = FALSE;
	return (frac);
}


/*
 * Get the value of the -e flag.
 */
int
get_quit_at_eof(void)
{
	return (quit_at_eof);
}
@


1.15
log
@A couple more prototypes without arguments.
@
text
@d575 1
a575 1
	for (p = s;  *p != '\0';  p++) {
@


1.14
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@d27 2
a28 2
static char *optstring();
static int flip_triple();
@


1.13
log
@Remove NULL-checks before free(), a needless comment, and a needless
void* cast.

ok nicm@@
@
text
@d335 1
a335 1
		error("No such option", NULL_PARG);
d418 1
a418 1
				    "for a string option", NULL_PARG);
d437 1
a437 1
				    NULL_PARG);
d464 1
a464 1
			error(o->odesc[*(o->ovar)], NULL_PARG);
@


1.12
log
@replace save() with estrdup() and make estrdup() exit like all the other
ecalloc, etc. functions do.
ok mmcc nicm
@
text
@d310 1
a310 2
		if (str != NULL)
			free(str);
@


1.11
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d154 1
a154 1
				every_first_cmd = save(str+1);
@


1.10
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.9
log
@Make more(1) POSIX compliant with respect to the -e option.
By default, "more" now works like "less -e", and "more -e" now
works like "less -E", and more never exits just because the file
fits on the first screen, like "less -F" would.

While documenting this, add some text to the DESCRIPTION explaining
how paging works.  That allows a very concise description of -e.

code change ok millert@@
manual page joint work with and ok jmc@@
@
text
@d9 4
a12 1

d19 1
a19 1
 * the command line option, toggled via the "-" command, 
d27 1
a27 1
public int plusoption = FALSE;
d41 2
a42 3
	static char *
opt_desc(o)
	struct loption *o;
d46 1
a46 1
		SNPRINTF1(buf, sizeof(buf), "--%s", o->onames->oname);
d48 2
a49 1
		SNPRINTF2(buf, sizeof(buf), "-%c (--%s)", o->oletter, o->onames->oname);
d57 2
a58 3
	public char *
propt(c)
	int c;
d62 1
a62 1
	snprintf(buf, sizeof(buf), "-%s", prchar(c));
d66 2
a67 2
/* 
 * Scan an argument (either from the command line or from the 
d70 2
a71 3
	public void
scan_option(s)
	char *s;
d73 2
a74 2
	register struct loption *o;
	register int optc;
d81 1
d94 2
a95 4
	if (pendopt != NULL)
	{
		switch (pendopt->otype & OTYPE)
		{
d101 1
a101 1
			*(pendopt->ovar) = getnum(&s, printopt, (int*)NULL);
d110 2
d113 1
a113 2
	while (*s != '\0')
	{
d117 1
a117 2
		switch (optc = *s++)
		{
a122 1
#if GNU_OPTIONS
d126 4
a129 3
			if (*s == '-')
			{
				optname = ++s;
a131 1
#endif
d134 1
a134 1
			 * (They may have been set otherwise by previous 
d137 5
a141 3
			set_default = (*s == '+');
			if (set_default)
				s++;
d145 2
a146 2
			 * An option prefixed by a "+" is ungotten, so 
			 * that it is interpreted as less commands 
d165 1
a165 1
			 * instead of -z<number> to set the scrolling 
d170 1
d173 2
a174 1
			if (less_is_more)
d176 31
d215 1
a215 2
		if (optname == NULL)
		{
d217 1
a217 1
			lc = ASCII_IS_LOWER(optc);
d219 5
a223 4
		}
#if GNU_OPTIONS
		else
		{
d225 1
a225 1
			lc = ASCII_IS_LOWER(optname[0]);
d229 6
a234 11
			if (*s == '\0' || *s == ' ')
			{
				/*
				 * The option name matches exactly.
				 */
				;
			} else if (*s == '=')
			{
				/*
				 * The option name is followed by "=value".
				 */
d237 1
a237 2
				    (o->otype & OTYPE) != NUMBER)
				{
d239 2
a240 2
					error("The %s option should not be followed by =",
						&parg);
d244 2
a245 6
			} else
			{
				/*
				 * The specified name is longer than the
				 * real option name.
				 */
d249 1
a249 3
#endif
		if (o == NULL)
		{
d251 10
a260 6
			if (err == OPT_AMBIG)
				error("%s is an ambiguous abbreviation (\"less --help\" for help)",
					&parg);
			else
				error("There is no %s option (\"less --help\" for help)",
					&parg);
d265 1
a265 2
		switch (o->otype & OTYPE)
		{
d279 1
a279 2
			if (*s == '\0')
			{
d290 1
a290 1
			 * All processing of STRING options is done by 
d300 1
a300 2
			if (*s == '\0')
			{
d304 1
a304 1
			*(o->ovar) = getnum(&s, printopt, (int*)NULL);
d326 2
a327 6
	public void
toggle_option(o, lower, s, how_toggle)
	struct loption *o;
	int lower;
	char *s;
	int how_toggle;
d329 1
a329 1
	register int num;
d337 1
a337 2
	if (o == NULL)
	{
d342 1
a342 2
	if (how_toggle == OPT_TOGGLE && (o->otype & NO_TOGGLE))
	{
d348 1
a348 2
	if (how_toggle == OPT_NO_TOGGLE && (o->otype & NO_QUERY))
	{
d352 1
a352 1
	} 
d360 1
a360 2
	switch (o->otype & OTYPE)
	{
a367 1
#if HILITE_SEARCH
a369 1
#endif
d374 2
a375 4
	if (how_toggle != OPT_NO_TOGGLE)
	{
		switch (o->otype & OTYPE)
		{
d380 1
a380 2
			switch (how_toggle)
			{
d395 1
a395 1
			 *	If user gave the lower case letter, then switch 
d400 1
a400 2
			switch (how_toggle)
			{
d417 1
a417 2
			switch (how_toggle)
			{
d420 2
a421 2
				error("Cannot use \"-+\" or \"--\" for a string option",
					NULL_PARG);
d429 1
a429 2
			switch (how_toggle)
			{
d440 1
a440 1
					NULL_PARG);
d448 1
a448 1
	 * Call the handling function for any special action 
d452 1
a452 1
		(*o->ofunc)((how_toggle==OPT_NO_TOGGLE) ? QUERY : TOGGLE, s);
a453 1
#if HILITE_SEARCH
a455 1
#endif
d457 1
a457 2
	if (!no_prompt)
	{
d461 1
a461 2
		switch (o->otype & OTYPE)
		{
d471 1
a471 1
			 * The message is in odesc[1] and has a %d for 
d492 2
a493 4
	static int
flip_triple(val, lc)
	int val;
	int lc;
d504 2
a505 3
	public int
opt_has_param(o)
	struct loption *o;
d518 2
a519 3
	public char *
opt_prompt(o)
	struct loption *o;
d528 1
a528 1
 * that is, if the previous option was a string-valued option letter 
d533 2
a534 2
	public int
isoptpending()
d542 2
a543 3
	static void
nostring(printopt)
	char *printopt;
d553 2
a554 2
	public void
nopendopt()
d564 2
a565 6
	static char *
optstring(s, p_str, printopt, validchars)
	char *s;
	char **p_str;
	char *printopt;
	char *validchars;
d567 2
a568 2
	register char *p;
	register char *out;
d570 1
a570 2
	if (*s == '\0')
	{
d575 1
a575 1
	*p_str = (char *) ecalloc(strlen(s)+1, sizeof(char));
d578 2
a579 4
	for (p = s;  *p != '\0';  p++)
	{
		if (opt_use_backslash && *p == '\\' && p[1] != '\0')
		{
d582 4
a585 4
		} else 
		{
			if (*p == END_OPTION_STRING || 
			    (validchars != NULL && strchr(validchars, *p) == NULL))
d597 2
a598 4
	static int
num_error(printopt, errp)
	char *printopt;
	int *errp;
d602 1
a602 2
	if (errp != NULL)
	{
d606 1
a606 2
	if (printopt != NULL)
	{
d618 2
a619 5
	public int
getnum(sp, printopt, errp)
	char **sp;
	char *printopt;
	int *errp;
d621 3
a623 3
	register char *s;
	register int n;
	register int neg;
d627 1
a627 2
	if (*s == '-')
	{
d651 2
a652 5
	public long
getfraction(sp, printopt, errp)
	char **sp;
	char *printopt;
	int *errp;
d654 1
a654 1
	register char *s;
d662 1
a662 2
	for ( ;  *s >= '0' && *s <= '9';  s++)
	{
d682 2
a683 2
	public int
get_quit_at_eof()
d685 1
a685 4
	if (!less_is_more)
		return quit_at_eof;
	/* When less_is_more is set, the -e flag semantics are different. */
	return quit_at_eof ? OPT_ONPLUS : OPT_ON;
@


1.8
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d709 1
a709 1
	return quit_at_eof ? OPT_ON : OPT_ONPLUS;
@


1.7
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d33 1
d152 2
d155 1
a155 1
				every_first_cmd = save(++str);
d158 1
d213 1
a213 1
					quit(QUIT_ERROR);
d235 1
a235 1
			quit(QUIT_ERROR);
d272 2
d289 2
d574 1
d579 1
a579 1
		quit(QUIT_ERROR);
d581 4
a584 1
	*p_str = s;
d587 5
a591 2
		if (*p == END_OPTION_STRING ||
		    (validchars != NULL && strchr(validchars, *p) == NULL))
d593 3
a595 12
			switch (*p)
			{
			case END_OPTION_STRING:
			case ' ':  case '\t':  case '-':
				/* Replace the char with a null to terminate string. */
				*p++ = '\0';
				break;
			default:
				/* Cannot replace char; make a copy of the string. */
				*p_str = (char *) ecalloc(p-s+1, sizeof(char));
				strncpy(*p_str, s, p-s);
				(*p_str)[p-s] = '\0';
a596 2
			}
			break;
d598 1
d600 1
a622 2
	quit(QUIT_ERROR);
	/* NOTREACHED */
@


1.6
log
@Make the GNU_OPTIONS define actually do something (was a no-op)
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
a26 1
static char *propt();
d31 2
d35 29
d100 1
a100 1
			printopt = propt(pendopt->oletter);
d167 4
d181 1
a181 1
			lc = SIMPLE_IS_LOWER(optc);
d188 1
a188 1
			lc = SIMPLE_IS_LOWER(optname[0]);
d297 3
a299 2
toggle_option(c, s, how_toggle)
	int c;
a302 1
	register struct loption *o;
a310 4
	/*
	 * Look up the option letter in the option table.
	 */
	o = findopt(c);
d313 1
a313 2
		parg.p_string = propt(c);
		error("There is no %s option", &parg);
d319 1
a319 1
		parg.p_string = propt(c);
d322 1
a322 1
	} 
d326 1
a326 1
		parg.p_string = propt(c);
d386 1
a386 2
				*(o->ovar) = flip_triple(*(o->ovar), 
						islower(c));
d392 1
a392 2
				*(o->ovar) = flip_triple(o->odefault,
						islower(c));
d494 1
a494 16
 * Return a string suitable for printing as the "name" of an option.
 * For example, if the option letter is 'x', just return "-x".
 */
	static char *
propt(c)
	int c;
{
	static char buf[8];

	snprintf(buf, sizeof(buf), "-%s", prchar(c));
	return (buf);
}

/*
 * Determine if an option is a single character option (BOOL or TRIPLE),
 * or if it a multi-character option (NUMBER).
d497 2
a498 2
single_char_option(c)
	int c;
a499 3
	register struct loption *o;

	o = findopt(c);
d501 4
a504 2
		return (TRUE);
	return ((o->otype & (BOOL|TRIPLE|NOVAR|NO_TOGGLE)) != 0);
d512 2
a513 2
opt_prompt(c)
	int c;
a514 3
	register struct loption *o;

	o = findopt(c);
d516 1
a516 1
		return (NULL);
d551 1
a551 1
	nostring(propt(pendopt->oletter));
d600 24
a636 1
	PARG parg;
d646 1
a646 13
	{
		if (errp != NULL)
		{
			*errp = TRUE;
			return (-1);
		}
		if (printopt != NULL)
		{
			parg.p_string = printopt;
			error("Number is required after %s", &parg);
		}
		quit(QUIT_ERROR);
	}
d657 50
@


1.5
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d93 1
d102 1
d149 3
a151 1
		} else
d188 1
@


1.4
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@a0 2
/*	$OpenBSD: option.c,v 1.3 2001/11/19 19:02:14 mpech Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d24 1
a24 1
static struct option *pendopt;
d42 4
a45 2
	struct option *o;
	int c;
d48 2
d56 2
a57 1
	 * If we have a pending string-valued option, handle it now.
d60 1
a60 1
	 * option is simply the string for the previous option.
d64 10
a73 1
		(*pendopt->ofunc)(INIT, s);
d79 1
d86 1
a86 1
		switch (c = *s++)
d94 8
d106 2
a107 1
			if (set_default = (*s == '+'))
d119 3
a121 2
			if (*s == '+')
				every_first_cmd = save(++s);
d123 1
a123 2
				ungetsc(s);
			s = optstring(s, c);
d133 1
a133 1
			c = 'z';
d141 43
a183 1
		o = findopt(c);
d186 7
a192 8
			parg.p_string = propt(c);
#if MSOFTC || OS2
			error("There is no %s flag (\"less -?\" for help)",
				&parg);
#else
			error("There is no %s flag (\"less -\\?\" for help)",
				&parg);
#endif
d196 1
d209 1
a209 2
				*(o->ovar) = flip_triple(o->odefault,
						(o->oletter == c));
d227 3
a229 2
			str = s;
			s = optstring(s, c);
d232 6
a237 1
			*(o->ovar) = getnum(&s, c, (int*)NULL);
d263 3
a265 2
	struct option *o;
	int num;
d269 3
d279 1
a279 1
		error("There is no %s flag", &parg);
d286 1
a286 1
		error("Cannot change the %s flag", &parg);
d293 1
a293 1
		error("Cannot query the %s flag", &parg);
d353 1
a353 1
						o->oletter == c);
d360 1
a360 1
						o->oletter == c);
d373 1
a373 1
				error("Can't use \"-+\" or \"--\" for a string flag",
d385 1
a385 1
				num = getnum(&s, '\0', &err);
d393 1
a393 1
				error("Can't use \"--\" for a numeric flag",
d413 1
a413 4
	/*
	 * Print a message describing the new setting.
	 */
	switch (o->otype & OTYPE)
a414 2
	case BOOL:
	case TRIPLE:
d416 1
a416 1
		 * Print the odesc message.
d418 23
a440 15
		error(o->odesc[*(o->ovar)], NULL_PARG);
		break;
	case NUMBER:
		/*
		 * The message is in odesc[1] and has a %d for 
		 * the value of the variable.
		 */
		parg.p_int = *(o->ovar);
		error(o->odesc[1], &parg);
		break;
	case STRING:
		/*
		 * Message was already printed by the handling function.
		 */
		break;
d471 1
a471 1
	snprintf(buf, sizeof buf, "-%s", prchar(c));
d483 1
a483 1
	struct option *o;
d499 1
a499 1
	struct option *o;
d524 2
a525 2
nostring(c)
	int c;
d528 2
a529 2
	parg.p_string = propt(c);
	error("String is required after %s", &parg);
d538 1
a538 1
	nostring(pendopt->oletter);
d547 1
a547 1
optstring(s, c)
d549 3
a551 1
	int c;
d553 1
a553 1
	char *p;
d557 1
a557 1
		nostring(c);
d560 1
d562 3
a564 1
		if (*p == END_OPTION_STRING)
d566 15
a580 2
			*p = '\0';
			return (p+1);
d582 1
d592 1
a592 1
getnum(sp, c, errp)
d594 1
a594 1
	int c;
d597 3
a599 3
	char *s;
	int n;
	int neg;
d616 5
a620 2
		parg.p_string = propt(c);
		error("Number is required after %s", &parg);
@


1.3
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: option.c,v 1.2 2001/01/29 01:58:03 niklas Exp $	*/
d411 1
a411 1
	sprintf(buf, "-%s", prchar(c));
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 2
a61 2
	register struct option *o;
	register int c;
d210 2
a211 2
	register struct option *o;
	register int num;
d423 1
a423 1
	register struct option *o;
d439 1
a439 1
	register struct option *o;
d491 1
a491 1
	register char *p;
d518 3
a520 3
	register char *s;
	register int n;
	register int neg;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d40 1
a40 1
static struct loption *pendopt;
d58 2
a59 4
	register struct loption *o;
	register int optc;
	char *optname;
	char *printopt;
a61 2
	int lc;
	int err;
d68 1
a68 2
	 * If we have a pending option which requires an argument,
	 * handle it now.
d71 1
a71 1
	 * option is simply the argument for the previous option.
d75 1
a75 10
		switch (pendopt->otype & OTYPE)
		{
		case STRING:
			(*pendopt->ofunc)(INIT, s);
			break;
		case NUMBER:
			printopt = propt(pendopt->oletter);
			*(pendopt->ovar) = getnum(&s, printopt, (int*)NULL);
			break;
		}
a80 1
	optname = NULL;
d87 1
a87 1
		switch (optc = *s++)
a94 8
			 * "--" indicates an option name instead of a letter.
			 */
			if (*s == '-')
			{
				optname = ++s;
				break;
			}
			/*
d99 1
a99 2
			set_default = (*s == '+');
			if (set_default)
d111 2
a112 3
			s = optstring(s, &str, propt('+'), NULL);
			if (*str == '+')
				every_first_cmd = save(++str);
d114 2
a115 1
				ungetsc(str);
d125 1
a125 1
			optc = 'z';
d133 1
a133 43
		err = 0;
		if (optname == NULL)
		{
			printopt = propt(optc);
			lc = SIMPLE_IS_LOWER(optc);
			o = findopt(optc);
		} else
		{
			printopt = optname;
			lc = SIMPLE_IS_LOWER(optname[0]);
			o = findopt_name(&optname, NULL, &err);
			s = optname;
			optname = NULL;
			if (*s == '\0' || *s == ' ')
			{
				/*
				 * The option name matches exactly.
				 */
				;
			} else if (*s == '=')
			{
				/*
				 * The option name is followed by "=value".
				 */
				if (o != NULL &&
				    (o->otype & OTYPE) != STRING &&
				    (o->otype & OTYPE) != NUMBER)
				{
					parg.p_string = printopt;
					error("The %s option should not be followed by =",
						&parg);
					quit(QUIT_ERROR);
				}
				s++;
			} else
			{
				/*
				 * The specified name is longer than the
				 * real option name.
				 */
				o = NULL;
			}
		}
d136 8
a143 7
			parg.p_string = printopt;
			if (err == OPT_AMBIG)
				error("%s is an ambiguous abbreviation (\"less --help\" for help)",
					&parg);
			else
				error("There is no %s option (\"less --help\" for help)",
					&parg);
a146 1
		str = NULL;
d159 2
a160 1
				*(o->ovar) = flip_triple(o->odefault, lc);
d178 2
a179 3
			while (*s == ' ')
				s++;
			s = optstring(s, &str, printopt, o->odesc[1]);
d182 1
a182 6
			if (*s == '\0')
			{
				pendopt = o;
				return;
			}
			*(o->ovar) = getnum(&s, printopt, (int*)NULL);
d208 1
a208 1
	register struct loption *o;
a209 1
	int no_prompt;
a212 3
	no_prompt = (how_toggle & OPT_NO_PROMPT);
	how_toggle &= ~OPT_NO_PROMPT;

d220 1
a220 1
		error("There is no %s option", &parg);
d227 1
a227 1
		error("Cannot change the %s option", &parg);
d234 1
a234 1
		error("Cannot query the %s option", &parg);
d294 1
a294 1
						islower(c));
d301 1
a301 1
						islower(c));
d314 1
a314 1
				error("Cannot use \"-+\" or \"--\" for a string option",
d326 1
a326 1
				num = getnum(&s, NULL, &err);
d334 1
a334 1
				error("Can't use \"-!\" for a numeric option",
d354 4
a357 1
	if (!no_prompt)
d359 8
d368 2
a369 1
		 * Print a message describing the new setting.
d371 8
a378 23
		switch (o->otype & OTYPE)
		{
		case BOOL:
		case TRIPLE:
			/*
			 * Print the odesc message.
			 */
			error(o->odesc[*(o->ovar)], NULL_PARG);
			break;
		case NUMBER:
			/*
			 * The message is in odesc[1] and has a %d for 
			 * the value of the variable.
			 */
			parg.p_int = *(o->ovar);
			error(o->odesc[1], &parg);
			break;
		case STRING:
			/*
			 * Message was already printed by the handling function.
			 */
			break;
		}
d421 1
a421 1
	register struct loption *o;
d437 1
a437 1
	register struct loption *o;
d462 2
a463 2
nostring(printopt)
	char *printopt;
d466 2
a467 2
	parg.p_string = printopt;
	error("Value is required after %s", &parg);
d476 1
a476 1
	nostring(propt(pendopt->oletter));
d485 1
a485 1
optstring(s, p_str, printopt, validchars)
d487 1
a487 3
	char **p_str;
	char *printopt;
	char *validchars;
d493 1
a493 1
		nostring(printopt);
a495 1
	*p_str = s;
d497 1
a497 3
	{
		if (*p == END_OPTION_STRING ||
		    (validchars != NULL && strchr(validchars, *p) == NULL))
d499 2
a500 15
			switch (*p)
			{
			case END_OPTION_STRING:
			case ' ':  case '\t':  case '-':
				/* Replace the char with a null to terminate string. */
				*p++ = '\0';
				break;
			default:
				/* Cannot replace char; make a copy of the string. */
				*p_str = (char *) ecalloc(p-s+1, sizeof(char));
				strncpy(*p_str, s, p-s);
				(*p_str)[p-s] = '\0';
				break;
			}
			break;
a501 1
	}
d511 1
a511 1
getnum(sp, printopt, errp)
d513 1
a513 1
	char *printopt;
d535 2
a536 5
		if (printopt != NULL)
		{
			parg.p_string = printopt;
			error("Number is required after %s", &parg);
		}
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d27 1
a31 2
extern int less_is_more;
extern int quit_at_eof;
a33 29
/*
 * Return a printable description of an option.
 */
	static char *
opt_desc(o)
	struct loption *o;
{
	static char buf[OPTNAME_MAX + 10];
	if (o->oletter == OLETTER_NONE)
		SNPRINTF1(buf, sizeof(buf), "--%s", o->onames->oname);
	else
		SNPRINTF2(buf, sizeof(buf), "-%c (--%s)", o->oletter, o->onames->oname);
	return (buf);
}

/*
 * Return a string suitable for printing as the "name" of an option.
 * For example, if the option letter is 'x', just return "-x".
 */
	public char *
propt(c)
	int c;
{
	static char buf[8];

	sprintf(buf, "-%s", prchar(c));
	return (buf);
}

d70 1
a70 1
			printopt = opt_desc(pendopt);
a134 4
		case 'n':
			if (less_is_more)
				optc = 'z';
			break;
d145 1
a145 1
			lc = ASCII_IS_LOWER(optc);
d150 1
a150 1
			lc = ASCII_IS_LOWER(optname[0]);
d258 2
a259 3
toggle_option(o, lower, s, how_toggle)
	struct loption *o;
	int lower;
d263 1
d272 4
d278 2
a279 1
		error("No such option", NULL_PARG);
d285 1
a285 1
		parg.p_string = opt_desc(o);
d288 1
a288 1
	}
d292 1
a292 1
		parg.p_string = opt_desc(o);
d352 2
a353 1
				*(o->ovar) = flip_triple(*(o->ovar), lower);
d359 2
a360 1
				*(o->ovar) = flip_triple(o->odefault, lower);
d462 16
a477 1
 * Determine if an option takes a parameter.
d480 2
a481 2
opt_has_param(o)
	struct loption *o;
d483 3
d487 2
a488 4
		return (0);
	if (o->otype & (BOOL|TRIPLE|NOVAR|NO_TOGGLE))
		return (0);
	return (1);
d496 2
a497 2
opt_prompt(o)
	struct loption *o;
d499 3
d503 1
a503 1
		return ("?");
d538 1
a538 1
	nostring(opt_desc(pendopt));
a586 24
 */
	static int
num_error(printopt, errp)
	char *printopt;
	int *errp;
{
	PARG parg;

	if (errp != NULL)
	{
		*errp = TRUE;
		return (-1);
	}
	if (printopt != NULL)
	{
		parg.p_string = printopt;
		error("Number is required after %s", &parg);
	}
	quit(QUIT_ERROR);
	/* NOTREACHED */
	return (-1);
}

/*
d600 1
d610 13
a622 1
		return (num_error(printopt, errp));
a632 50
}

/*
 * Translate a string into a fraction, represented by the part of a
 * number which would follow a decimal point.
 * The value of the fraction is returned as parts per NUM_FRAC_DENOM.
 * That is, if "n" is returned, the fraction intended is n/NUM_FRAC_DENOM.
 */
	public long
getfraction(sp, printopt, errp)
	char **sp;
	char *printopt;
	int *errp;
{
	register char *s;
	long frac = 0;
	int fraclen = 0;

	s = skipsp(*sp);
	if (*s < '0' || *s > '9')
		return (num_error(printopt, errp));

	for ( ;  *s >= '0' && *s <= '9';  s++)
	{
		frac = (frac * 10) + (*s - '0');
		fraclen++;
	}
	if (fraclen > NUM_LOG_FRAC_DENOM)
		while (fraclen-- > NUM_LOG_FRAC_DENOM)
			frac /= 10;
	else
		while (fraclen++ < NUM_LOG_FRAC_DENOM)
			frac *= 10;
	*sp = s;
	if (errp != NULL)
		*errp = FALSE;
	return (frac);
}


/*
 * Get the value of the -e flag.
 */
	public int
get_quit_at_eof()
{
	if (!less_is_more)
		return quit_at_eof;
	/* When less_is_more is set, the -e flag semantics are different. */
	return quit_at_eof ? OPT_ON : OPT_ONPLUS;
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
a33 1
extern int opt_use_backslash;
d60 1
a60 1
	snprintf(buf, sizeof(buf), "-%s", prchar(c));
a122 1
#if GNU_OPTIONS
a130 1
#endif
a149 2
			if (s == NULL)
				return;
d151 1
a151 1
				every_first_cmd = save(str+1);
a153 1
			free(str);
d181 1
a181 3
		}
#if GNU_OPTIONS
		else
d206 1
a206 1
					return;
a217 1
#endif
d227 1
a227 1
			return;
a263 2
			if (s == NULL)
				return;
a278 2
		if (str != NULL)
			free(str);
a561 1
	register char *out;
d566 1
a566 1
		return (NULL);
d568 1
a568 4
	/* Alloc could be more than needed, but not worth trimming. */
	*p_str = (char *) ecalloc(strlen(s)+1, sizeof(char));
	out = *p_str;

d571 2
a572 1
		if (opt_use_backslash && *p == '\\' && p[1] != '\0')
d574 12
a585 7
			/* Take next char literally. */
			++p;
		} else 
		{
			if (*p == END_OPTION_STRING || 
			    (validchars != NULL && strchr(validchars, *p) == NULL))
				/* End of option string. */
d587 2
a589 1
		*out++ = *p;
a590 1
	*out = '\0';
d613 2
@


