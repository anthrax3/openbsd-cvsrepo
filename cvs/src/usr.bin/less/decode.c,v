head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.2
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.6.0.12
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.8
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.5.0.22
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.20
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.18
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.14
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.16
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.12
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	W32EN7Zp77efb8wW;

1.17
date	2016.03.16.15.36.26;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	P9ytq8HKajWPxZf9;

1.16
date	2015.11.09.16.42.35;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	mkNNke62XFQvJVUG;

1.15
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	ZtGimechwgSRYqRW;

1.14
date	2015.11.09.04.10.57;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	E4Lg0tTt0vh4nd97;

1.13
date	2015.11.09.02.59.06;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	krM8GIm0ktfoy1dx;

1.12
date	2015.11.07.18.07.44;	author tedu;	state Exp;
branches;
next	1.11;
commitid	DJUwzdj0cG1bCfEw;

1.11
date	2015.11.06.15.58.01;	author nicm;	state Exp;
branches;
next	1.10;
commitid	y4I2iN2XAfMdlxNX;

1.10
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.9;
commitid	QKrr6AuGzNx9nehL;

1.9
date	2015.11.05.22.18.27;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	ZMka2O4VZNCDWtqb;

1.8
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.7;
commitid	yKv9Ck9ZDgwWTRTo;

1.7
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.02.00.55.32;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.13.18.26.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.01;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.04;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.45;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.18
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Routines to decode user commands.
 *
 * This is all table driven.
 * A command table is a sequence of command descriptors.
 * Each command descriptor is a sequence of bytes with the following format:
 *	<c1><c2>...<cN><0><action>
 * The characters c1,c2,...,cN are the command string; that is,
 * the characters which the user must type.
 * It is terminated by a null <0> byte.
 * The byte after the null byte is the action code associated
 * with the command string.
 * If an action byte is OR-ed with A_EXTRA, this indicates
 * that the option byte is followed by an extra string.
 *
 * There may be many command tables.
 * The first (default) table is built-in.
 * Other tables are read in from "lesskey" files.
 * All the tables are linked together and are searched in order.
 */

#include "cmd.h"
#include "less.h"
#include "lesskey.h"

extern int erase_char, erase2_char, kill_char;
extern int secure, less_is_more;

#define	SK(k) \
	SK_SPECIAL_KEY, (k), 6, 1, 1, 1
/*
 * Command table is ordered roughly according to expected
 * frequency of use, so the common commands are near the beginning.
 */

static unsigned char cmdtable[] =
{
	'\r', 0,			A_F_LINE,
	'\n', 0,			A_F_LINE,
	'e', 0,				A_F_LINE,
	'j', 0,				A_F_LINE,
	SK(SK_DOWN_ARROW), 0,		A_F_LINE,
	CONTROL('E'), 0,		A_F_LINE,
	CONTROL('N'), 0,		A_F_LINE,
	'k', 0,				A_B_LINE,
	'y', 0,				A_B_LINE,
	CONTROL('Y'), 0,		A_B_LINE,
	SK(SK_CONTROL_K), 0,		A_B_LINE,
	CONTROL('P'), 0,		A_B_LINE,
	SK(SK_UP_ARROW), 0,		A_B_LINE,
	'J', 0,				A_FF_LINE,
	'K', 0,				A_BF_LINE,
	'Y', 0,				A_BF_LINE,
	'd', 0,				A_F_SCROLL,
	CONTROL('D'), 0,		A_F_SCROLL,
	'u', 0,				A_B_SCROLL,
	CONTROL('U'), 0,		A_B_SCROLL,
	' ', 0,				A_F_SCREEN,
	'f', 0,				A_F_SCREEN,
	CONTROL('F'), 0,		A_F_SCREEN,
	CONTROL('V'), 0,		A_F_SCREEN,
	SK(SK_PAGE_DOWN), 0,		A_F_SCREEN,
	'b', 0,				A_B_SCREEN,
	CONTROL('B'), 0,		A_B_SCREEN,
	ESC, 'v', 0,			A_B_SCREEN,
	SK(SK_PAGE_UP), 0,		A_B_SCREEN,
	'z', 0,				A_F_WINDOW,
	'w', 0,				A_B_WINDOW,
	ESC, ' ', 0,			A_FF_SCREEN,
	'F', 0,				A_F_FOREVER,
	ESC, 'F', 0,			A_F_UNTIL_HILITE,
	'R', 0,				A_FREPAINT,
	'r', 0,				A_REPAINT,
	CONTROL('R'), 0,		A_REPAINT,
	CONTROL('L'), 0,		A_REPAINT,
	ESC, 'u', 0,			A_UNDO_SEARCH,
	'g', 0,				A_GOLINE,
	SK(SK_HOME), 0,			A_GOLINE,
	'<', 0,				A_GOLINE,
	ESC, '<', 0,			A_GOLINE,
	'p', 0,				A_PERCENT,
	'%', 0,				A_PERCENT,
	ESC, '[', 0,			A_LSHIFT,
	ESC, ']', 0,			A_RSHIFT,
	ESC, '(', 0,			A_LSHIFT,
	ESC, ')', 0,			A_RSHIFT,
	SK(SK_RIGHT_ARROW), 0,		A_RSHIFT,
	SK(SK_LEFT_ARROW), 0,		A_LSHIFT,
	'{', 0,				A_F_BRACKET|A_EXTRA,	'{', '}', 0,
	'}', 0,				A_B_BRACKET|A_EXTRA,	'{', '}', 0,
	'(', 0,				A_F_BRACKET|A_EXTRA,	'(', ')', 0,
	')', 0,				A_B_BRACKET|A_EXTRA,	'(', ')', 0,
	'[', 0,				A_F_BRACKET|A_EXTRA,	'[', ']', 0,
	']', 0,				A_B_BRACKET|A_EXTRA,	'[', ']', 0,
	ESC, CONTROL('F'), 0,		A_F_BRACKET,
	ESC, CONTROL('B'), 0,		A_B_BRACKET,
	'G', 0,				A_GOEND,
	ESC, '>', 0,			A_GOEND,
	'>', 0,				A_GOEND,
	SK(SK_END), 0,			A_GOEND,
	'P', 0,				A_GOPOS,

	'0', 0,				A_DIGIT,
	'1', 0,				A_DIGIT,
	'2', 0,				A_DIGIT,
	'3', 0,				A_DIGIT,
	'4', 0,				A_DIGIT,
	'5', 0,				A_DIGIT,
	'6', 0,				A_DIGIT,
	'7', 0,				A_DIGIT,
	'8', 0,				A_DIGIT,
	'9', 0,				A_DIGIT,
	'.', 0,				A_DIGIT,

	'=', 0,				A_STAT,
	CONTROL('G'), 0,		A_STAT,
	':', 'f', 0,			A_STAT,
	'/', 0,				A_F_SEARCH,
	'?', 0,				A_B_SEARCH,
	ESC, '/', 0,			A_F_SEARCH|A_EXTRA,	'*', 0,
	ESC, '?', 0,			A_B_SEARCH|A_EXTRA,	'*', 0,
	'n', 0,				A_AGAIN_SEARCH,
	ESC, 'n', 0,			A_T_AGAIN_SEARCH,
	'N', 0,				A_REVERSE_SEARCH,
	ESC, 'N', 0,			A_T_REVERSE_SEARCH,
	'&', 0,				A_FILTER,
	'm', 0,				A_SETMARK,
	'\'', 0,			A_GOMARK,
	CONTROL('X'), CONTROL('X'), 0,	A_GOMARK,
	'E', 0,				A_EXAMINE,
	':', 'e', 0,			A_EXAMINE,
	CONTROL('X'), CONTROL('V'), 0,	A_EXAMINE,
	':', 'n', 0,			A_NEXT_FILE,
	':', 'p', 0,			A_PREV_FILE,
	't', 0,				A_NEXT_TAG,
	'T', 0,				A_PREV_TAG,
	':', 'x', 0,			A_INDEX_FILE,
	':', 'd', 0,			A_REMOVE_FILE,
	':', 't', 0,			A_OPT_TOGGLE|A_EXTRA,	't', 0,
	'|', 0,				A_PIPE,
	'v', 0,				A_VISUAL,
	'+', 0,				A_FIRSTCMD,

	'H', 0,				A_HELP,
	'h', 0,				A_HELP,
	SK(SK_F1), 0,			A_HELP,
	'V', 0,				A_VERSION,
	'q', 0,				A_QUIT,
	'Q', 0,				A_QUIT,
	':', 'q', 0,			A_QUIT,
	':', 'Q', 0,			A_QUIT,
	'Z', 'Z', 0,			A_QUIT
};

static unsigned char lesstable[] = {
	'-', 0,				A_OPT_TOGGLE,
	's', 0,				A_OPT_TOGGLE|A_EXTRA,	'o', 0,
	'_', 0,				A_DISP_OPTION
};

static unsigned char moretable[] = {
	's', 0,				A_F_SKIP
};

static unsigned char edittable[] =
{
	'\t', 0,			EC_F_COMPLETE,	/* TAB */
	'\17', 0,			EC_B_COMPLETE,	/* BACKTAB */
	SK(SK_BACKTAB), 0,		EC_B_COMPLETE,	/* BACKTAB */
	ESC, '\t', 0,			EC_B_COMPLETE,	/* ESC TAB */
	CONTROL('L'), 0,		EC_EXPAND,	/* CTRL-L */
	CONTROL('V'), 0,		EC_LITERAL,	/* BACKSLASH */
	CONTROL('A'), 0,		EC_LITERAL,	/* BACKSLASH */
	ESC, 'l', 0,			EC_RIGHT,	/* ESC l */
	SK(SK_RIGHT_ARROW), 0,		EC_RIGHT,	/* RIGHTARROW */
	ESC, 'h', 0,			EC_LEFT,	/* ESC h */
	SK(SK_LEFT_ARROW), 0,		EC_LEFT,	/* LEFTARROW */
	ESC, 'b', 0,			EC_W_LEFT,	/* ESC b */
	ESC, SK(SK_LEFT_ARROW), 0,	EC_W_LEFT,	/* ESC LEFTARROW */
	SK(SK_CTL_LEFT_ARROW), 0,	EC_W_LEFT,	/* CTRL-LEFTARROW */
	ESC, 'w', 0,			EC_W_RIGHT,	/* ESC w */
	ESC, SK(SK_RIGHT_ARROW), 0,	EC_W_RIGHT,	/* ESC RIGHTARROW */
	SK(SK_CTL_RIGHT_ARROW), 0,	EC_W_RIGHT,	/* CTRL-RIGHTARROW */
	ESC, 'i', 0,			EC_INSERT,	/* ESC i */
	SK(SK_INSERT), 0,		EC_INSERT,	/* INSERT */
	ESC, 'x', 0,			EC_DELETE,	/* ESC x */
	SK(SK_DELETE), 0,		EC_DELETE,	/* DELETE */
	ESC, 'X', 0,			EC_W_DELETE,	/* ESC X */
	ESC, SK(SK_DELETE), 0,		EC_W_DELETE,	/* ESC DELETE */
	SK(SK_CTL_DELETE), 0,		EC_W_DELETE,	/* CTRL-DELETE */
	SK(SK_CTL_BACKSPACE), 0,	EC_W_BACKSPACE, /* CTRL-BACKSPACE */
	ESC, '\b', 0,			EC_W_BACKSPACE,	/* ESC BACKSPACE */
	ESC, '0', 0,			EC_HOME,	/* ESC 0 */
	SK(SK_HOME), 0,			EC_HOME,	/* HOME */
	ESC, '$', 0,			EC_END,		/* ESC $ */
	SK(SK_END), 0,			EC_END,		/* END */
	ESC, 'k', 0,			EC_UP,		/* ESC k */
	SK(SK_UP_ARROW), 0,		EC_UP,		/* UPARROW */
	ESC, 'j', 0,			EC_DOWN,	/* ESC j */
	SK(SK_DOWN_ARROW), 0,		EC_DOWN,	/* DOWNARROW */
	CONTROL('G'), 0,		EC_ABORT,	/* CTRL-G */
};

/*
 * Structure to support a list of command tables.
 */
struct tablelist {
	struct tablelist *t_next;
	char *t_start;
	char *t_end;
};

/*
 * List of command tables and list of line-edit tables.
 */
static struct tablelist *list_fcmd_tables = NULL;
static struct tablelist *list_ecmd_tables = NULL;
static struct tablelist *list_var_tables = NULL;
static struct tablelist *list_sysvar_tables = NULL;


/*
 * Expand special key abbreviations in a command table.
 */
static void
expand_special_keys(char *table, int len)
{
	char *fm;
	char *to;
	int a;
	char *repl;
	int klen;

	for (fm = table; fm < table + len; ) {
		/*
		 * Rewrite each command in the table with any
		 * special key abbreviations expanded.
		 */
		for (to = fm; *fm != '\0'; ) {
			if (*fm != SK_SPECIAL_KEY) {
				*to++ = *fm++;
				continue;
			}
			/*
			 * After SK_SPECIAL_KEY, next byte is the type
			 * of special key (one of the SK_* contants),
			 * and the byte after that is the number of bytes,
			 * N, reserved by the abbreviation (including the
			 * SK_SPECIAL_KEY and key type bytes).
			 * Replace all N bytes with the actual bytes
			 * output by the special key on this terminal.
			 */
			repl = special_key_str(fm[1]);
			klen = fm[2] & 0377;
			fm += klen;
			if (repl == NULL || strlen(repl) > klen)
				repl = "\377";
			while (*repl != '\0')
				*to++ = *repl++;
		}
		*to++ = '\0';
		/*
		 * Fill any unused bytes between end of command and
		 * the action byte with A_SKIP.
		 */
		while (to <= fm)
			*to++ = A_SKIP;
		fm++;
		a = *fm++ & 0377;
		if (a & A_EXTRA) {
			while (*fm++ != '\0')
				continue;
		}
	}
}

/*
 * Initialize the command lists.
 */
void
init_cmds(void)
{
	/*
	 * Add the default command tables.
	 */
	add_fcmd_table((char *)cmdtable, sizeof (cmdtable));
	add_ecmd_table((char *)edittable, sizeof (edittable));
	if (less_is_more) {
		add_fcmd_table((char *)moretable, sizeof (moretable));
		return;
	} else {
		add_fcmd_table((char *)lesstable, sizeof (lesstable));
	}

	/*
	 * Try to add the tables in the system lesskey file.
	 */
	add_hometable("LESSKEY_SYSTEM", LESSKEYFILE_SYS, 1);
	/*
	 * Try to add the tables in the standard lesskey file "$HOME/.less".
	 */
	add_hometable("LESSKEY", LESSKEYFILE, 0);
}

/*
 * Add a command table.
 */
static int
add_cmd_table(struct tablelist **tlist, char *buf, int len)
{
	struct tablelist *t;

	if (len == 0)
		return (0);
	/*
	 * Allocate a tablelist structure, initialize it,
	 * and link it into the list of tables.
	 */
	if ((t = calloc(1, sizeof (struct tablelist))) == NULL) {
		return (-1);
	}
	expand_special_keys(buf, len);
	t->t_start = buf;
	t->t_end = buf + len;
	t->t_next = *tlist;
	*tlist = t;
	return (0);
}

/*
 * Add a command table.
 */
void
add_fcmd_table(char *buf, int len)
{
	if (add_cmd_table(&list_fcmd_tables, buf, len) < 0)
		error("Warning: some commands disabled", NULL);
}

/*
 * Add an editing command table.
 */
void
add_ecmd_table(char *buf, int len)
{
	if (add_cmd_table(&list_ecmd_tables, buf, len) < 0)
		error("Warning: some edit commands disabled", NULL);
}

/*
 * Add an environment variable table.
 */
static void
add_var_table(struct tablelist **tlist, char *buf, int len)
{
	if (add_cmd_table(tlist, buf, len) < 0)
		error("Warning: environment variables from "
		    "lesskey file unavailable", NULL);
}

/*
 * Search a single command table for the command string in cmd.
 */
static int
cmd_search(const char *cmd, char *table, char *endtable, char **sp)
{
	char *p;
	const char *q;
	int a;

	*sp = NULL;
	for (p = table, q = cmd; p < endtable; p++, q++) {
		if (*p == *q) {
			/*
			 * Current characters match.
			 * If we're at the end of the string, we've found it.
			 * Return the action code, which is the character
			 * after the null at the end of the string
			 * in the command table.
			 */
			if (*p == '\0') {
				a = *++p & 0377;
				while (a == A_SKIP)
					a = *++p & 0377;
				if (a == A_END_LIST) {
					/*
					 * We get here only if the original
					 * cmd string passed in was empty ("").
					 * I don't think that can happen,
					 * but just in case ...
					 */
					return (A_UINVALID);
				}
				/*
				 * Check for an "extra" string.
				 */
				if (a & A_EXTRA) {
					*sp = ++p;
					a &= ~A_EXTRA;
				}
				return (a);
			}
		} else if (*q == '\0') {
			/*
			 * Hit the end of the user's command,
			 * but not the end of the string in the command table.
			 * The user's command is incomplete.
			 */
			return (A_PREFIX);
		} else {
			/*
			 * Not a match.
			 * Skip ahead to the next command in the
			 * command table, and reset the pointer
			 * to the beginning of the user's command.
			 */
			if (*p == '\0' && p[1] == A_END_LIST) {
				/*
				 * A_END_LIST is a special marker that tells
				 * us to abort the cmd search.
				 */
				return (A_UINVALID);
			}
			while (*p++ != '\0')
				continue;
			while (*p == A_SKIP)
				p++;
			if (*p & A_EXTRA)
				while (*++p != '\0')
					continue;
			q = cmd-1;
		}
	}
	/*
	 * No match found in the entire command table.
	 */
	return (A_INVALID);
}

/*
 * Decode a command character and return the associated action.
 * The "extra" string, if any, is returned in sp.
 */
static int
cmd_decode(struct tablelist *tlist, const char *cmd, char **sp)
{
	struct tablelist *t;
	int action = A_INVALID;

	/*
	 * Search thru all the command tables.
	 * Stop when we find an action which is not A_INVALID.
	 */
	for (t = tlist; t != NULL; t = t->t_next) {
		action = cmd_search(cmd, t->t_start, t->t_end, sp);
		if (action != A_INVALID)
			break;
	}
	if (action == A_UINVALID)
		action = A_INVALID;
	return (action);
}

/*
 * Decode a command from the cmdtables list.
 */
int
fcmd_decode(const char *cmd, char **sp)
{
	return (cmd_decode(list_fcmd_tables, cmd, sp));
}

/*
 * Decode a command from the edittables list.
 */
int
ecmd_decode(const char *cmd, char **sp)
{
	return (cmd_decode(list_ecmd_tables, cmd, sp));
}

/*
 * Get the value of an environment variable.
 * Looks first in the lesskey file, then in the real environment.
 */
char *
lgetenv(char *var)
{
	int a;
	char *s;

	/*
	 * Ignore lookups of any LESS* setting when we are more, and ignore
	 * the less key files
	 */
	if (less_is_more) {
		if (strncmp(var, "LESS", 4) == 0) {
			return (NULL);
		}
		return (getenv(var));
	}
	a = cmd_decode(list_var_tables, var, &s);
	if (a == EV_OK)
		return (s);
	s = getenv(var);
	if (s != NULL && *s != '\0')
		return (s);
	a = cmd_decode(list_sysvar_tables, var, &s);
	if (a == EV_OK)
		return (s);
	return (NULL);
}

/*
 * Get an "integer" from a lesskey file.
 * Integers are stored in a funny format:
 * two bytes, low order first, in radix KRADIX.
 */
static int
gint(char **sp)
{
	int n;

	n = *(*sp)++;
	n += *(*sp)++ * KRADIX;
	return (n);
}

/*
 * Process an old (pre-v241) lesskey file.
 */
static int
old_lesskey(char *buf, int len)
{
	/*
	 * Old-style lesskey file.
	 * The file must end with either
	 *	..,cmd,0,action
	 * or	...,cmd,0,action|A_EXTRA,string,0
	 * So the last byte or the second to last byte must be zero.
	 */
	if (buf[len-1] != '\0' && buf[len-2] != '\0')
		return (-1);
	add_fcmd_table(buf, len);
	return (0);
}

/*
 * Process a new (post-v241) lesskey file.
 */
static int
new_lesskey(char *buf, int len, int sysvar)
{
	char *p;
	int c;
	int n;

	/*
	 * New-style lesskey file.
	 * Extract the pieces.
	 */
	if (buf[len-3] != C0_END_LESSKEY_MAGIC ||
	    buf[len-2] != C1_END_LESSKEY_MAGIC ||
	    buf[len-1] != C2_END_LESSKEY_MAGIC)
		return (-1);
	p = buf + 4;
	for (;;) {
		c = *p++;
		switch (c) {
		case CMD_SECTION:
			n = gint(&p);
			add_fcmd_table(p, n);
			p += n;
			break;
		case EDIT_SECTION:
			n = gint(&p);
			add_ecmd_table(p, n);
			p += n;
			break;
		case VAR_SECTION:
			n = gint(&p);
			add_var_table((sysvar) ?
			    &list_sysvar_tables : &list_var_tables, p, n);
			p += n;
			break;
		case END_SECTION:
			return (0);
		default:
			/*
			 * Unrecognized section type.
			 */
			return (-1);
		}
	}
}

/*
 * Set up a user command table, based on a "lesskey" file.
 */
int
lesskey(char *filename, int sysvar)
{
	char *buf;
	off_t len;
	long n;
	int f;

	if (secure)
		return (1);
	/*
	 * Try to open the lesskey file.
	 */
	filename = shell_unquote(filename);
	f = open(filename, O_RDONLY);
	free(filename);
	if (f < 0)
		return (1);

	/*
	 * Read the file into a buffer.
	 * We first figure out the size of the file and allocate space for it.
	 * {{ Minimal error checking is done here.
	 *    A garbage .less file will produce strange results.
	 *    To avoid a large amount of error checking code here, we
	 *    rely on the lesskey program to generate a good .less file. }}
	 */
	len = filesize(f);
	if (len == -1 || len < 3) {
		/*
		 * Bad file (valid file must have at least 3 chars).
		 */
		(void) close(f);
		return (-1);
	}
	if ((buf = calloc((int)len, sizeof (char))) == NULL) {
		(void) close(f);
		return (-1);
	}
	if (lseek(f, (off_t)0, SEEK_SET) == (off_t)-1) {
		free(buf);
		(void) close(f);
		return (-1);
	}
	n = read(f, buf, (unsigned int) len);
	close(f);
	if (n != len) {
		free(buf);
		return (-1);
	}

	/*
	 * Figure out if this is an old-style (before version 241)
	 * or new-style lesskey file format.
	 */
	if (buf[0] != C0_LESSKEY_MAGIC || buf[1] != C1_LESSKEY_MAGIC ||
	    buf[2] != C2_LESSKEY_MAGIC || buf[3] != C3_LESSKEY_MAGIC)
		return (old_lesskey(buf, (int)len));
	return (new_lesskey(buf, (int)len, sysvar));
}

/*
 * Add the standard lesskey file "$HOME/.less"
 */
void
add_hometable(char *envname, char *def_filename, int sysvar)
{
	char *filename;
	PARG parg;

	if (envname != NULL && (filename = lgetenv(envname)) != NULL)
		filename = estrdup(filename);
	else if (sysvar)
		filename = estrdup(def_filename);
	else
		filename = homefile(def_filename);
	if (filename == NULL)
		return;
	if (lesskey(filename, sysvar) < 0) {
		parg.p_string = filename;
		error("Cannot use lesskey file \"%s\"", &parg);
	}
	free(filename);
}

/*
 * See if a char is a special line-editing command.
 */
int
editchar(int c, int flags)
{
	int action;
	int nch;
	char *s;
	char usercmd[MAX_CMDLEN+1];

	/*
	 * An editing character could actually be a sequence of characters;
	 * for example, an escape sequence sent by pressing the uparrow key.
	 * To match the editing string, we use the command decoder
	 * but give it the edit-commands command table
	 * This table is constructed to match the user's keyboard.
	 */
	if (c == erase_char || c == erase2_char)
		return (EC_BACKSPACE);
	if (c == kill_char)
		return (EC_LINEKILL);

	/*
	 * Collect characters in a buffer.
	 * Start with the one we have, and get more if we need them.
	 */
	nch = 0;
	do {
		if (nch > 0)
			c = getcc();
		usercmd[nch] = (char)c;
		usercmd[nch+1] = '\0';
		nch++;
		action = ecmd_decode(usercmd, &s);
	} while (action == A_PREFIX);

	if (flags & EC_NORIGHTLEFT) {
		switch (action) {
		case EC_RIGHT:
		case EC_LEFT:
			action = A_INVALID;
			break;
		}
	}
	if (flags & EC_NOHISTORY) {
		/*
		 * The caller says there is no history list.
		 * Reject any history-manipulation action.
		 */
		switch (action) {
		case EC_UP:
		case EC_DOWN:
			action = A_INVALID;
			break;
		}
	}
	if (flags & EC_NOCOMPLETE) {
		/*
		 * The caller says we don't want any filename completion cmds.
		 * Reject them.
		 */
		switch (action) {
		case EC_F_COMPLETE:
		case EC_B_COMPLETE:
		case EC_EXPAND:
			action = A_INVALID;
			break;
		}
	}
	if ((flags & EC_PEEK) || action == A_INVALID) {
		/*
		 * We're just peeking, or we didn't understand the command.
		 * Unget all the characters we read in the loop above.
		 * This does NOT include the original character that was
		 * passed in as a parameter.
		 */
		while (nch > 1) {
			ungetcc(usercmd[--nch]);
		}
	} else {
		if (s != NULL)
			ungetsc(s);
	}
	return (action);
}
@


1.17
log
@style(9) includes

ok nicm@@
@
text
@d245 1
a245 1
	for (fm = table;  fm < table + len; ) {
d250 1
a250 1
		for (to = fm;  *fm != '\0'; ) {
d383 1
a383 1
	for (p = table, q = cmd;  p < endtable;  p++, q++) {
d465 1
a465 1
	for (t = tlist;  t != NULL;  t = t->t_next) {
@


1.16
log
@use (off_t)-1 rather than a BAD_LSEEK wrapper
@
text
@d33 1
a34 1
#include "cmd.h"
@


1.15
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@d650 1
a650 1
	if (lseek(f, (off_t)0, SEEK_SET) == BAD_LSEEK) {
@


1.14
log
@cleanup struct definitions
@
text
@d348 1
a348 1
		error("Warning: some commands disabled", NULL_PARG);
d358 1
a358 1
		error("Warning: some edit commands disabled", NULL_PARG);
d369 1
a369 1
		    "lesskey file unavailable", NULL_PARG);
@


1.13
log
@do not need wrappers around O_RDONLY and such
@
text
@d218 1
a218 2
struct tablelist
{
@


1.12
log
@replace save() with estrdup() and make estrdup() exit like all the other
ecalloc, etc. functions do.
ok mmcc nicm
@
text
@d626 1
a626 1
	f = open(filename, OPEN_READ);
@


1.11
log
@Remove support for ! to run a shell command, we have ^Z around these
parts. ok ratchov jung millert
@
text
@d683 1
a683 1
		filename = save(filename);
d685 1
a685 1
		filename = save(def_filename);
@


1.10
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@a152 1
	'!', 0,				A_SHELL,
@


1.9
log
@whitespace
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.8
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d181 1
a181 1
	'\t', 0,    			EC_F_COMPLETE,	/* TAB */
d553 1
a553 1
	 * 	..,cmd,0,action
@


1.7
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

d40 1
a40 1
extern int secure;
d42 1
a42 1
#define SK(k) \
d51 126
a176 119
	'\r',0,				A_F_LINE,
	'\n',0,				A_F_LINE,
	'e',0,				A_F_LINE,
	'j',0,				A_F_LINE,
	SK(SK_DOWN_ARROW),0,		A_F_LINE,
	CONTROL('E'),0,			A_F_LINE,
	CONTROL('N'),0,			A_F_LINE,
	'k',0,				A_B_LINE,
	'y',0,				A_B_LINE,
	CONTROL('Y'),0,			A_B_LINE,
	SK(SK_CONTROL_K),0,		A_B_LINE,
	CONTROL('P'),0,			A_B_LINE,
	SK(SK_UP_ARROW),0,		A_B_LINE,
	'J',0,				A_FF_LINE,
	'K',0,				A_BF_LINE,
	'Y',0,				A_BF_LINE,
	'd',0,				A_F_SCROLL,
	CONTROL('D'),0,			A_F_SCROLL,
	'u',0,				A_B_SCROLL,
	CONTROL('U'),0,			A_B_SCROLL,
	' ',0,				A_F_SCREEN,
	'f',0,				A_F_SCREEN,
	CONTROL('F'),0,			A_F_SCREEN,
	CONTROL('V'),0,			A_F_SCREEN,
	SK(SK_PAGE_DOWN),0,		A_F_SCREEN,
	'b',0,				A_B_SCREEN,
	CONTROL('B'),0,			A_B_SCREEN,
	ESC,'v',0,			A_B_SCREEN,
	SK(SK_PAGE_UP),0,		A_B_SCREEN,
	'z',0,				A_F_WINDOW,
	'w',0,				A_B_WINDOW,
	ESC,' ',0,			A_FF_SCREEN,
	'F',0,				A_F_FOREVER,
	ESC,'F',0,			A_F_UNTIL_HILITE,
	'R',0,				A_FREPAINT,
	'r',0,				A_REPAINT,
	CONTROL('R'),0,			A_REPAINT,
	CONTROL('L'),0,			A_REPAINT,
	ESC,'u',0,			A_UNDO_SEARCH,
	'g',0,				A_GOLINE,
	SK(SK_HOME),0,			A_GOLINE,
	'<',0,				A_GOLINE,
	ESC,'<',0,			A_GOLINE,
	'p',0,				A_PERCENT,
	'%',0,				A_PERCENT,
	ESC,'[',0,			A_LSHIFT,
	ESC,']',0,			A_RSHIFT,
	ESC,'(',0,			A_LSHIFT,
	ESC,')',0,			A_RSHIFT,
	SK(SK_RIGHT_ARROW),0,		A_RSHIFT,
	SK(SK_LEFT_ARROW),0,		A_LSHIFT,
	'{',0,				A_F_BRACKET|A_EXTRA,	'{','}',0,
	'}',0,				A_B_BRACKET|A_EXTRA,	'{','}',0,
	'(',0,				A_F_BRACKET|A_EXTRA,	'(',')',0,
	')',0,				A_B_BRACKET|A_EXTRA,	'(',')',0,
	'[',0,				A_F_BRACKET|A_EXTRA,	'[',']',0,
	']',0,				A_B_BRACKET|A_EXTRA,	'[',']',0,
	ESC,CONTROL('F'),0,		A_F_BRACKET,
	ESC,CONTROL('B'),0,		A_B_BRACKET,
	'G',0,				A_GOEND,
	ESC,'>',0,			A_GOEND,
	'>',0,				A_GOEND,
	SK(SK_END),0,			A_GOEND,
	'P',0,				A_GOPOS,

	'0',0,				A_DIGIT,
	'1',0,				A_DIGIT,
	'2',0,				A_DIGIT,
	'3',0,				A_DIGIT,
	'4',0,				A_DIGIT,
	'5',0,				A_DIGIT,
	'6',0,				A_DIGIT,
	'7',0,				A_DIGIT,
	'8',0,				A_DIGIT,
	'9',0,				A_DIGIT,
	'.',0,				A_DIGIT,

	'=',0,				A_STAT,
	CONTROL('G'),0,			A_STAT,
	':','f',0,			A_STAT,
	'/',0,				A_F_SEARCH,
	'?',0,				A_B_SEARCH,
	ESC,'/',0,			A_F_SEARCH|A_EXTRA,	'*',0,
	ESC,'?',0,			A_B_SEARCH|A_EXTRA,	'*',0,
	'n',0,				A_AGAIN_SEARCH,
	ESC,'n',0,			A_T_AGAIN_SEARCH,
	'N',0,				A_REVERSE_SEARCH,
	ESC,'N',0,			A_T_REVERSE_SEARCH,
	'&',0,				A_FILTER,
	'm',0,				A_SETMARK,
	'\'',0,				A_GOMARK,
	CONTROL('X'),CONTROL('X'),0,	A_GOMARK,
	'E',0,				A_EXAMINE,
	':','e',0,			A_EXAMINE,
	CONTROL('X'),CONTROL('V'),0,	A_EXAMINE,
	':','n',0,			A_NEXT_FILE,
	':','p',0,			A_PREV_FILE,
	't',0,				A_NEXT_TAG,
	'T',0,				A_PREV_TAG,
	':','x',0,			A_INDEX_FILE,
	':','d',0,			A_REMOVE_FILE,
	'-',0,				A_OPT_TOGGLE,
	':','t',0,			A_OPT_TOGGLE|A_EXTRA,	't',0,
	's',0,				A_OPT_TOGGLE|A_EXTRA,	'o',0,
	'_',0,				A_DISP_OPTION,
	'|',0,				A_PIPE,
	'v',0,				A_VISUAL,
	'!',0,				A_SHELL,
	'+',0,				A_FIRSTCMD,

	'H',0,				A_HELP,
	'h',0,				A_HELP,
	SK(SK_F1),0,			A_HELP,
	'V',0,				A_VERSION,
	'q',0,				A_QUIT,
	'Q',0,				A_QUIT,
	':','q',0,			A_QUIT,
	':','Q',0,			A_QUIT,
	'Z','Z',0,			A_QUIT
d181 35
a215 35
	'\t',0,	    			EC_F_COMPLETE,	/* TAB */
	'\17',0,			EC_B_COMPLETE,	/* BACKTAB */
	SK(SK_BACKTAB),0,		EC_B_COMPLETE,	/* BACKTAB */
	ESC,'\t',0,			EC_B_COMPLETE,	/* ESC TAB */
	CONTROL('L'),0,			EC_EXPAND,	/* CTRL-L */
	CONTROL('V'),0,			EC_LITERAL,	/* BACKSLASH */
	CONTROL('A'),0,			EC_LITERAL,	/* BACKSLASH */
   	ESC,'l',0,			EC_RIGHT,	/* ESC l */
	SK(SK_RIGHT_ARROW),0,		EC_RIGHT,	/* RIGHTARROW */
	ESC,'h',0,			EC_LEFT,	/* ESC h */
	SK(SK_LEFT_ARROW),0,		EC_LEFT,	/* LEFTARROW */
	ESC,'b',0,			EC_W_LEFT,	/* ESC b */
	ESC,SK(SK_LEFT_ARROW),0,	EC_W_LEFT,	/* ESC LEFTARROW */
	SK(SK_CTL_LEFT_ARROW),0,	EC_W_LEFT,	/* CTRL-LEFTARROW */
	ESC,'w',0,			EC_W_RIGHT,	/* ESC w */
	ESC,SK(SK_RIGHT_ARROW),0,	EC_W_RIGHT,	/* ESC RIGHTARROW */
	SK(SK_CTL_RIGHT_ARROW),0,	EC_W_RIGHT,	/* CTRL-RIGHTARROW */
	ESC,'i',0,			EC_INSERT,	/* ESC i */
	SK(SK_INSERT),0,		EC_INSERT,	/* INSERT */
	ESC,'x',0,			EC_DELETE,	/* ESC x */
	SK(SK_DELETE),0,		EC_DELETE,	/* DELETE */
	ESC,'X',0,			EC_W_DELETE,	/* ESC X */
	ESC,SK(SK_DELETE),0,		EC_W_DELETE,	/* ESC DELETE */
	SK(SK_CTL_DELETE),0,		EC_W_DELETE,	/* CTRL-DELETE */
	SK(SK_CTL_BACKSPACE),0,		EC_W_BACKSPACE, /* CTRL-BACKSPACE */
	ESC,'\b',0,			EC_W_BACKSPACE,	/* ESC BACKSPACE */
	ESC,'0',0,			EC_HOME,	/* ESC 0 */
	SK(SK_HOME),0,			EC_HOME,	/* HOME */
	ESC,'$',0,			EC_END,		/* ESC $ */
	SK(SK_END),0,			EC_END,		/* END */
	ESC,'k',0,			EC_UP,		/* ESC k */
	SK(SK_UP_ARROW),0,		EC_UP,		/* UPARROW */
	ESC,'j',0,			EC_DOWN,	/* ESC j */
	SK(SK_DOWN_ARROW),0,		EC_DOWN,	/* DOWNARROW */
	CONTROL('G'),0,			EC_ABORT,	/* CTRL-G */
d240 6
a245 8
	static void
expand_special_keys(table, len)
	char *table;
	int len;
{
	register char *fm;
	register char *to;
	register int a;
d249 1
a249 2
	for (fm = table;  fm < table + len; )
	{
d254 2
a255 4
		for (to = fm;  *fm != '\0'; )
		{
			if (*fm != SK_SPECIAL_KEY)
			{
d271 1
a271 1
			if (repl == NULL || (int) strlen(repl) > klen)
d278 1
a278 1
		 * Fill any unused bytes between end of command and 
d285 1
a285 2
		if (a & A_EXTRA)
		{
d295 2
a296 2
	public void
init_cmds()
d301 9
a309 10
	add_fcmd_table((char*)cmdtable, sizeof(cmdtable));
	add_ecmd_table((char*)edittable, sizeof(edittable));
#if USERFILE
	/*
	 * For backwards compatibility,
	 * try to add tables in the OLD system lesskey file.
	 */
#ifdef BINDIR
	add_hometable(NULL, BINDIR "/.sysless", 1);
#endif
a317 1
#endif
d323 2
a324 5
	static int
add_cmd_table(tlist, buf, len)
	struct tablelist **tlist;
	char *buf;
	int len;
d326 1
a326 1
	register struct tablelist *t;
d331 1
a331 1
	 * Allocate a tablelist structure, initialize it, 
d334 1
a334 3
	if ((t = (struct tablelist *) 
			calloc(1, sizeof(struct tablelist))) == NULL)
	{
d348 2
a349 4
	public void
add_fcmd_table(buf, len)
	char *buf;
	int len;
d358 2
a359 4
	public void
add_ecmd_table(buf, len)
	char *buf;
	int len;
d368 2
a369 5
	static void
add_var_table(tlist, buf, len)
	struct tablelist **tlist;
	char *buf;
	int len;
d372 2
a373 1
		error("Warning: environment variables from lesskey file unavailable", NULL_PARG);
d379 6
a384 10
	static int
cmd_search(cmd, table, endtable, sp)
	char *cmd;
	char *table;
	char *endtable;
	char **sp;
{
	register char *p;
	register char *q;
	register int a;
d387 2
a388 4
	for (p = table, q = cmd;  p < endtable;  p++, q++)
	{
		if (*p == *q)
		{
d396 1
a396 2
			if (*p == '\0')
			{
d400 1
a400 2
				if (a == A_END_LIST)
				{
d412 1
a412 2
				if (a & A_EXTRA)
				{
d418 1
a418 2
		} else if (*q == '\0')
		{
d425 1
a425 2
		} else
		{
d432 1
a432 2
			if (*p == '\0' && p[1] == A_END_LIST)
			{
d434 1
a434 1
				 * A_END_LIST is a special marker that tells 
d459 2
a460 5
	static int
cmd_decode(tlist, cmd, sp)
	struct tablelist *tlist;
	char *cmd;
	char **sp;
d462 2
a463 2
	register struct tablelist *t;
	register int action = A_INVALID;
d469 1
a469 2
	for (t = tlist;  t != NULL;  t = t->t_next)
	{
d482 2
a483 4
	public int
fcmd_decode(cmd, sp)
	char *cmd;
	char **sp;
d491 2
a492 4
	public int
ecmd_decode(cmd, sp)
	char *cmd;
	char **sp;
d501 2
a502 3
	public char *
lgetenv(var)
	char *var;
d507 10
a528 1
#if USERFILE
d531 1
a531 1
 * Integers are stored in a funny format: 
d534 2
a535 3
	static int
gint(sp)
	char **sp;
d547 2
a548 4
	static int
old_lesskey(buf, len)
	char *buf;
	int len;
d552 3
a554 3
	 * The file must end with either 
	 *     ...,cmd,0,action
	 * or  ...,cmd,0,action|A_EXTRA,string,0
d563 1
a563 1
/* 
d566 2
a567 5
	static int
new_lesskey(buf, len, sysvar)
	char *buf;
	int len;
	int sysvar;
d570 2
a571 2
	register int c;
	register int n;
d582 1
a582 2
	for (;;)
	{
d584 1
a584 2
		switch (c)
		{
d597 2
a598 2
			add_var_table((sysvar) ? 
				&list_sysvar_tables : &list_var_tables, p, n);
d615 2
a616 4
	public int
lesskey(filename, sysvar)
	char *filename;
	int sysvar;
d618 4
a621 4
	register char *buf;
	register POSITION len;
	register long n;
	register int f;
d643 1
a643 2
	if (len == NULL_POSITION || len < 3)
	{
d647 1
a647 1
		close(f);
d650 2
a651 3
	if ((buf = (char *) calloc((int)len, sizeof(char))) == NULL)
	{
		close(f);
d654 1
a654 2
	if (lseek(f, (off_t)0, SEEK_SET) == BAD_LSEEK)
	{
d656 1
a656 1
		close(f);
d661 1
a661 2
	if (n != len)
	{
d679 2
a680 5
	public void
add_hometable(envname, def_filename, sysvar)
	char *envname;
	char *def_filename;
	int sysvar;
d693 1
a693 2
	if (lesskey(filename, sysvar) < 0)
	{
a698 1
#endif
d703 2
a704 4
	public int
editchar(c, flags)
	int c;
	int flags;
d710 1
a710 1
	
d722 1
a722 1
		
d729 1
a729 1
	  	if (nch > 0)
d731 1
a731 1
		usercmd[nch] = c;
d736 3
a738 5
	
	if (flags & EC_NORIGHTLEFT)
	{
		switch (action)
		{
d745 1
a745 3
#if CMD_HISTORY
	if (flags & EC_NOHISTORY) 
	{
d750 1
a750 2
		switch (action)
		{
d757 1
a757 4
#endif
#if TAB_COMPLETE_FILENAME
	if (flags & EC_NOCOMPLETE) 
	{
d762 1
a762 2
		switch (action)
		{
d770 1
a770 3
#endif
	if ((flags & EC_PEEK) || action == A_INVALID)
	{
d774 1
a774 1
		 * This does NOT include the original character that was 
d777 1
a777 2
		while (nch > 1) 
		{
d780 1
a780 2
	} else
	{
d784 1
a784 1
	return action;
a785 1

@


1.6
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d81 1
@


1.5
log
@use SEEK_* for lseek()
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d37 1
a37 1
extern int erase_char, kill_char;
d123 1
d136 1
d205 1
d760 1
a760 1
	if (c == erase_char)
@


1.4
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d684 1
a684 1
	if (lseek(f, (off_t)0, 0) == BAD_LSEEK)
@


1.3
log
@kill more registers

millert@@ ok
@
text
@a0 2
/*	$OpenBSD: decode.c,v 1.2 2001/01/29 01:58:01 niklas Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d38 1
d40 2
d46 1
d53 1
d59 1
a59 1
	CONTROL('K'),0,			A_B_LINE,
d61 1
d73 1
d77 1
d80 1
d88 1
d93 6
d110 1
d143 2
d146 1
d158 1
d161 1
d169 34
a202 18
	'\t',0,	    		EC_F_COMPLETE,	/* TAB */
	'\17',0,		EC_B_COMPLETE,	/* BACKTAB */
	'\14',0,		EC_EXPAND,	/* CTRL-L */
	CONTROL('V'),0,		EC_LITERAL,	/* BACKSLASH */
	CONTROL('A'),0,		EC_LITERAL,	/* BACKSLASH */
   	ESC,'l',0,		EC_RIGHT,	/* ESC l */
	ESC,'h',0,		EC_LEFT,	/* ESC h */
	ESC,'b',0,		EC_W_LEFT,	/* ESC b */
	ESC,'w',0,		EC_W_RIGHT,	/* ESC w */
	ESC,'i',0,		EC_INSERT,	/* ESC i */
	ESC,'x',0,		EC_DELETE,	/* ESC x */
	ESC,'X',0,		EC_W_DELETE,	/* ESC X */
	ESC,'\b',0,		EC_W_BACKSPACE,	/* ESC BACKSPACE */
	ESC,'0',0,		EC_HOME,	/* ESC 0 */
	ESC,'$',0,		EC_END,		/* ESC $ */
	ESC,'k',0,		EC_UP,		/* ESC k */
	ESC,'j',0,		EC_DOWN,	/* ESC j */
	ESC,'\t',0,		EC_B_COMPLETE	/* ESC TAB */
d220 2
d225 61
a295 1
	get_editkeys();
d298 11
d311 1
a311 1
	add_hometable();
d316 1
a316 1
 * 
d324 1
a324 1
	struct tablelist *t;
d337 1
d370 13
d385 1
a385 1
	public int
d392 3
a394 3
	char *p;
	char *q;
	int a;
d396 1
d411 2
d430 1
a430 2
				} else
					*sp = NULL;
d457 4
a460 1
			while (*p++ != '\0') ;
d462 2
a463 1
				while (*++p != '\0') ;
d483 2
a484 2
	struct tablelist *t;
	int action = A_INVALID;
d496 2
d523 23
d547 5
d563 3
d584 3
d588 1
a588 1
new_lesskey(buf, len)
d591 1
d594 2
a595 3
	int c;
	int done;
	int n;
d606 1
a606 2
	done = 0;
	while (!done)
d621 6
d628 1
a628 2
			done = 1;
			break;
d630 3
a632 1
			free(buf);
a635 1
	return (0);
d642 1
a642 1
lesskey(filename)
d644 1
d646 4
a649 4
	char *buf;
	POSITION len;
	long n;
	int f;
d651 2
d656 1
d658 1
d705 1
a705 1
	return (new_lesskey(buf, (int)len));
d712 4
a715 1
add_hometable()
d720 6
a725 1
	filename = homefile(LESSKEYFILE);
d728 1
a728 1
	if (lesskey(filename) < 0)
d776 11
d801 2
d818 1
d827 2
a828 1
		while (nch > 1) {
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d231 1
a231 1
	register struct tablelist *t;
d285 3
a287 3
	register char *p;
	register char *q;
	register int a;
d370 2
a371 2
	register struct tablelist *t;
	register int action = A_INVALID;
d444 3
a446 3
	register int c;
	register int done;
	register int n;
d491 4
a494 4
	register char *buf;
	register POSITION len;
	register long n;
	register int f;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
a53 1
extern int secure;
a54 2
#define SK(k) \
	SK_SPECIAL_KEY, (k), 6, 1, 1, 1
a58 1

a64 1
	SK(SK_DOWN_ARROW),0,		A_F_LINE,
d70 1
a70 1
	SK(SK_CONTROL_K),0,		A_B_LINE,
a71 1
	SK(SK_UP_ARROW),0,		A_B_LINE,
a82 1
	SK(SK_PAGE_DOWN),0,		A_F_SCREEN,
a85 1
	SK(SK_PAGE_UP),0,		A_B_SCREEN,
a87 1
	ESC,' ',0,			A_FF_SCREEN,
a94 1
	SK(SK_HOME),0,			A_GOLINE,
a98 6
	ESC,'[',0,			A_LSHIFT,
	ESC,']',0,			A_RSHIFT,
	ESC,'(',0,			A_LSHIFT,
	ESC,')',0,			A_RSHIFT,
	SK(SK_RIGHT_ARROW),0,		A_RSHIFT,
	SK(SK_LEFT_ARROW),0,		A_LSHIFT,
a109 1
	SK(SK_END),0,			A_GOEND,
a141 2
	't',0,				A_NEXT_TAG,
	'T',0,				A_PREV_TAG,
a142 1
	':','d',0,			A_REMOVE_FILE,
a153 1
	SK(SK_F1),0,			A_HELP,
a155 1
	'Q',0,				A_QUIT,
d163 18
a180 34
	'\t',0,	    			EC_F_COMPLETE,	/* TAB */
	'\17',0,			EC_B_COMPLETE,	/* BACKTAB */
	SK(SK_BACKTAB),0,		EC_B_COMPLETE,	/* BACKTAB */
	ESC,'\t',0,			EC_B_COMPLETE,	/* ESC TAB */
	CONTROL('L'),0,			EC_EXPAND,	/* CTRL-L */
	CONTROL('V'),0,			EC_LITERAL,	/* BACKSLASH */
	CONTROL('A'),0,			EC_LITERAL,	/* BACKSLASH */
   	ESC,'l',0,			EC_RIGHT,	/* ESC l */
	SK(SK_RIGHT_ARROW),0,		EC_RIGHT,	/* RIGHTARROW */
	ESC,'h',0,			EC_LEFT,	/* ESC h */
	SK(SK_LEFT_ARROW),0,		EC_LEFT,	/* LEFTARROW */
	ESC,'b',0,			EC_W_LEFT,	/* ESC b */
	ESC,SK(SK_LEFT_ARROW),0,	EC_W_LEFT,	/* ESC LEFTARROW */
	SK(SK_CTL_LEFT_ARROW),0,	EC_W_LEFT,	/* CTRL-LEFTARROW */
	ESC,'w',0,			EC_W_RIGHT,	/* ESC w */
	ESC,SK(SK_RIGHT_ARROW),0,	EC_W_RIGHT,	/* ESC RIGHTARROW */
	SK(SK_CTL_RIGHT_ARROW),0,	EC_W_RIGHT,	/* CTRL-RIGHTARROW */
	ESC,'i',0,			EC_INSERT,	/* ESC i */
	SK(SK_INSERT),0,		EC_INSERT,	/* INSERT */
	ESC,'x',0,			EC_DELETE,	/* ESC x */
	SK(SK_DELETE),0,		EC_DELETE,	/* DELETE */
	ESC,'X',0,			EC_W_DELETE,	/* ESC X */
	ESC,SK(SK_DELETE),0,		EC_W_DELETE,	/* ESC DELETE */
	SK(SK_CTL_DELETE),0,		EC_W_DELETE,	/* CTRL-DELETE */
	SK(SK_CTL_BACKSPACE),0,		EC_W_BACKSPACE, /* CTRL-BACKSPACE */
	ESC,'\b',0,			EC_W_BACKSPACE,	/* ESC BACKSPACE */
	ESC,'0',0,			EC_HOME,	/* ESC 0 */
	SK(SK_HOME),0,			EC_HOME,	/* HOME */
	ESC,'$',0,			EC_END,		/* ESC $ */
	SK(SK_END),0,			EC_END,		/* END */
	ESC,'k',0,			EC_UP,		/* ESC k */
	SK(SK_UP_ARROW),0,		EC_UP,		/* UPARROW */
	ESC,'j',0,			EC_DOWN,	/* ESC j */
	SK(SK_DOWN_ARROW),0,		EC_DOWN,	/* DOWNARROW */
a197 17
static struct tablelist *list_var_tables = NULL;
static struct tablelist *list_sysvar_tables = NULL;


/*
 * Expand special key abbreviations in a command table.
 */
	static void
expand_special_keys(table, len)
	char *table;
	int len;
{
	register char *fm;
	register char *to;
	register int a;
	char *repl;
	int klen;
a198 46
	for (fm = table;  fm < table + len; )
	{
		/*
		 * Rewrite each command in the table with any
		 * special key abbreviations expanded.
		 */
		for (to = fm;  *fm != '\0'; )
		{
			if (*fm != SK_SPECIAL_KEY)
			{
				*to++ = *fm++;
				continue;
			}
			/*
			 * After SK_SPECIAL_KEY, next byte is the type
			 * of special key (one of the SK_* contants),
			 * and the byte after that is the number of bytes,
			 * N, reserved by the abbreviation (including the
			 * SK_SPECIAL_KEY and key type bytes).
			 * Replace all N bytes with the actual bytes
			 * output by the special key on this terminal.
			 */
			repl = special_key_str(fm[1]);
			klen = fm[2] & 0377;
			fm += klen;
			if (repl == NULL || (int) strlen(repl) > klen)
				repl = "\377";
			while (*repl != '\0')
				*to++ = *repl++;
		}
		*to++ = '\0';
		/*
		 * Fill any unused bytes between end of command and 
		 * the action byte with A_SKIP.
		 */
		while (to <= fm)
			*to++ = A_SKIP;
		fm++;
		a = *fm++ & 0377;
		if (a & A_EXTRA)
		{
			while (*fm++ != '\0')
				continue;
		}
	}
}
d211 1
a213 11
	 * For backwards compatibility,
	 * try to add tables in the OLD system lesskey file.
	 */
#ifdef BINDIR
	add_hometable(NULL, BINDIR "/.sysless", 1);
#endif
	/*
	 * Try to add the tables in the system lesskey file.
	 */
	add_hometable("LESSKEY_SYSTEM", LESSKEYFILE_SYS, 1);
	/*
d216 1
a216 1
	add_hometable("LESSKEY", LESSKEYFILE, 0);
d221 1
a221 1
 * Add a command table.
a241 1
	expand_special_keys(buf, len);
a273 13
 * Add an environment variable table.
 */
	static void
add_var_table(tlist, buf, len)
	struct tablelist **tlist;
	char *buf;
	int len;
{
	if (add_cmd_table(tlist, buf, len) < 0)
		error("Warning: environment variables from lesskey file unavailable", NULL_PARG);
}

/*
d276 1
a276 1
	static int
a286 1
	*sp = NULL;
a300 2
				while (a == A_SKIP)
					a = *++p & 0377;
d318 2
a319 1
				}
d346 1
a346 4
			while (*p++ != '\0')
				continue;
			while (*p == A_SKIP)
				p++;
d348 1
a348 2
				while (*++p != '\0')
					continue;
a380 2
	if (action == A_UINVALID)
		action = A_INVALID;
a405 23
/*
 * Get the value of an environment variable.
 * Looks first in the lesskey file, then in the real environment.
 */
	public char *
lgetenv(var)
	char *var;
{
	int a;
	char *s;

	a = cmd_decode(list_var_tables, var, &s);
	if (a == EV_OK)
		return (s);
	s = getenv(var);
	if (s != NULL && *s != '\0')
		return (s);
	a = cmd_decode(list_sysvar_tables, var, &s);
	if (a == EV_OK)
		return (s);
	return (NULL);
}

a406 5
/*
 * Get an "integer" from a lesskey file.
 * Integers are stored in a funny format: 
 * two bytes, low order first, in radix KRADIX.
 */
a417 3
/*
 * Process an old (pre-v241) lesskey file.
 */
a435 3
/* 
 * Process a new (post-v241) lesskey file.
 */
d437 1
a437 1
new_lesskey(buf, len, sysvar)
a439 1
	int sysvar;
d443 1
d455 2
a456 1
	for (;;)
d471 2
a472 5
		case VAR_SECTION:
			n = gint(&p);
			add_var_table((sysvar) ? 
				&list_sysvar_tables : &list_var_tables, p, n);
			p += n;
a473 2
		case END_SECTION:
			return (0);
d475 1
a475 3
			/*
			 * Unrecognized section type.
			 */
d479 1
d486 1
a486 1
lesskey(filename, sysvar)
a487 1
	int sysvar;
a493 2
	if (secure)
		return (1);
a496 1
	filename = shell_unquote(filename);
a497 1
	free(filename);
d544 1
a544 1
	return (new_lesskey(buf, (int)len, sysvar));
d551 1
a551 4
add_hometable(envname, def_filename, sysvar)
	char *envname;
	char *def_filename;
	int sysvar;
d556 1
a556 6
	if (envname != NULL && (filename = lgetenv(envname)) != NULL)
		filename = save(filename);
	else if (sysvar)
		filename = save(def_filename);
	else
		filename = homefile(def_filename);
d559 1
a559 1
	if (lesskey(filename, sysvar) < 0)
a606 11
	if (flags & EC_NORIGHTLEFT)
	{
		switch (action)
		{
		case EC_RIGHT:
		case EC_LEFT:
			action = A_INVALID;
			break;
		}
	}
#if CMD_HISTORY
a620 2
#endif
#if TAB_COMPLETE_FILENAME
a635 1
#endif
d644 1
a644 2
		while (nch > 1) 
		{
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d37 1
a37 1
extern int erase_char, erase2_char, kill_char;
a122 1
	'.',0,				A_DIGIT,
a134 1
	'&',0,				A_FILTER,
a202 1
	CONTROL('G'),0,			EC_ABORT,	/* CTRL-G */
d684 1
a684 1
	if (lseek(f, (off_t)0, SEEK_SET) == BAD_LSEEK)
d757 1
a757 1
	if (c == erase_char || c == erase2_char)
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
a81 1
	ESC,'F',0,			A_F_UNTIL_HILITE,
@


