head	1.19;
access;
symbols
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.7.0.12
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.8
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.6
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.5.0.34
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.32
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.30
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2017.08.02.19.35.57;	author anton;	state Exp;
branches;
next	1.18;
commitid	b2AbYJzb5gHyU4ia;

1.18
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	W32EN7Zp77efb8wW;

1.17
date	2016.03.16.15.36.26;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	P9ytq8HKajWPxZf9;

1.16
date	2016.01.12.17.48.04;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	O36S2Tb0ReI34f9s;

1.15
date	2015.12.09.19.25.44;	author mmcc;	state Exp;
branches;
next	1.14;
commitid	PLFXc3A1QQy4rfbO;

1.14
date	2015.11.21.13.29.12;	author tedu;	state Exp;
branches;
next	1.13;
commitid	1K0ek8cCYSq3jMmD;

1.13
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	ZtGimechwgSRYqRW;

1.12
date	2015.11.09.14.25.32;	author mmcc;	state Exp;
branches;
next	1.11;
commitid	bgQj8bNZKDat4TZ4;

1.11
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.10;
commitid	QKrr6AuGzNx9nehL;

1.10
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.9;
commitid	yKv9Ck9ZDgwWTRTo;

1.9
date	2014.05.28.11.39.15;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.7;

1.7
date	2011.09.21.19.01.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.06.23.38.07;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.08;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.51;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.19
log
@When performing an inverted search in less, make sure to invalidate the match
bounds prior calling regexec(). In this inverted scenario a match is found when
regexec() returns false causing the bounds to not be updated. This is
problematic since the bounds will then refer to a previous match and future
pointer arithmetic will eventually be off which is manifested in a SIGSEGV.

Issue reported by Larry Hynes on tech@@
ok martijn@@ tb@@
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Routines to search a file for a pattern.
 */

#include "charset.h"
#include "less.h"
#include "pattern.h"
#include "position.h"

#define	MINPOS(a, b)	(((a) < (b)) ? (a) : (b))
#define	MAXPOS(a, b)	(((a) > (b)) ? (a) : (b))

extern volatile sig_atomic_t sigs;
extern int how_search;
extern int caseless;
extern int linenums;
extern int sc_height;
extern int jump_sline;
extern int bs_mode;
extern int ctldisp;
extern int status_col;
extern void *const ml_search;
extern off_t start_attnpos;
extern off_t end_attnpos;
extern int utf_mode;
extern int screen_trashed;
extern int hilite_search;
extern int size_linebuf;
extern int squished;
extern int can_goto_line;
static int hide_hilite;
static off_t prep_startpos;
static off_t prep_endpos;
static int is_caseless;
static int is_ucase_pattern;

struct hilite {
	struct hilite *hl_next;
	off_t hl_startpos;
	off_t hl_endpos;
};
static struct hilite hilite_anchor = { NULL, -1, -1 };
static struct hilite filter_anchor = { NULL, -1, -1 };
#define	hl_first	hl_next

/*
 * These are the static variables that represent the "remembered"
 * search pattern and filter pattern.
 */
struct pattern_info {
	regex_t *compiled;
	char *text;
	int search_type;
};

#define	info_compiled(info) ((info)->compiled)

static struct pattern_info search_info;
static struct pattern_info filter_info;

/*
 * Are there any uppercase letters in this string?
 */
static int
is_ucase(char *str)
{
	char *str_end = str + strlen(str);
	LWCHAR ch;

	while (str < str_end) {
		ch = step_char(&str, +1, str_end);
		if (isupper(ch))
			return (1);
	}
	return (0);
}

/*
 * Compile and save a search pattern.
 */
static int
set_pattern(struct pattern_info *info, char *pattern, int search_type)
{
	if (pattern == NULL)
		info->compiled = NULL;
	else if (compile_pattern(pattern, search_type, &info->compiled) < 0)
		return (-1);
	/* Pattern compiled successfully; save the text too. */
	free(info->text);
	info->text = NULL;
	if (pattern != NULL)
		info->text = estrdup(pattern);
	info->search_type = search_type;

	/*
	 * Ignore case if -I is set OR
	 * -i is set AND the pattern is all lowercase.
	 */
	is_ucase_pattern = is_ucase(pattern);
	if (is_ucase_pattern && caseless != OPT_ONPLUS)
		is_caseless = 0;
	else
		is_caseless = caseless;
	return (0);
}

/*
 * Discard a saved pattern.
 */
static void
clear_pattern(struct pattern_info *info)
{
	free(info->text);
	info->text = NULL;
	uncompile_pattern(&info->compiled);
}

/*
 * Initialize saved pattern to nothing.
 */
static void
init_pattern(struct pattern_info *info)
{
	info->compiled = NULL;
	info->text = NULL;
	info->search_type = 0;
}

/*
 * Initialize search variables.
 */
void
init_search(void)
{
	init_pattern(&search_info);
	init_pattern(&filter_info);
}

/*
 * Determine which text conversions to perform before pattern matching.
 */
static int
get_cvt_ops(void)
{
	int ops = 0;
	if (is_caseless || bs_mode == BS_SPECIAL) {
		if (is_caseless)
			ops |= CVT_TO_LC;
		if (bs_mode == BS_SPECIAL)
			ops |= CVT_BS;
		if (bs_mode != BS_CONTROL)
			ops |= CVT_CRLF;
	} else if (bs_mode != BS_CONTROL) {
		ops |= CVT_CRLF;
	}
	if (ctldisp == OPT_ONPLUS)
		ops |= CVT_ANSI;
	return (ops);
}

/*
 * Is there a previous (remembered) search pattern?
 */
static int
prev_pattern(struct pattern_info *info)
{
	if ((info->search_type & SRCH_NO_REGEX) == 0)
		return (info->compiled != NULL);
	return (info->text != NULL);
}

/*
 * Repaint the hilites currently displayed on the screen.
 * Repaint each line which contains highlighted text.
 * If on==0, force all hilites off.
 */
void
repaint_hilite(int on)
{
	int slinenum;
	off_t pos;
	int save_hide_hilite;

	if (squished)
		repaint();

	save_hide_hilite = hide_hilite;
	if (!on) {
		if (hide_hilite)
			return;
		hide_hilite = 1;
	}

	if (!can_goto_line) {
		repaint();
		hide_hilite = save_hide_hilite;
		return;
	}

	for (slinenum = TOP; slinenum < TOP + sc_height-1; slinenum++) {
		pos = position(slinenum);
		if (pos == -1)
			continue;
		(void) forw_line(pos);
		goto_line(slinenum);
		put_line();
	}
	lower_left();
	hide_hilite = save_hide_hilite;
}

/*
 * Clear the attn hilite.
 */
void
clear_attn(void)
{
	int slinenum;
	off_t old_start_attnpos;
	off_t old_end_attnpos;
	off_t pos;
	off_t epos;
	int moved = 0;

	if (start_attnpos == -1)
		return;
	old_start_attnpos = start_attnpos;
	old_end_attnpos = end_attnpos;
	start_attnpos = end_attnpos = -1;

	if (!can_goto_line) {
		repaint();
		return;
	}
	if (squished)
		repaint();

	for (slinenum = TOP; slinenum < TOP + sc_height-1; slinenum++) {
		pos = position(slinenum);
		if (pos == -1)
			continue;
		epos = position(slinenum+1);
		if (pos < old_end_attnpos &&
		    (epos == -1 || epos > old_start_attnpos)) {
			(void) forw_line(pos);
			goto_line(slinenum);
			put_line();
			moved = 1;
		}
	}
	if (moved)
		lower_left();
}

/*
 * Hide search string highlighting.
 */
void
undo_search(void)
{
	if (!prev_pattern(&search_info)) {
		error("No previous regular expression", NULL);
		return;
	}
	hide_hilite = !hide_hilite;
	repaint_hilite(1);
}

/*
 * Clear the hilite list.
 */
static void
clr_hlist(struct hilite *anchor)
{
	struct hilite *hl;
	struct hilite *nexthl;

	for (hl = anchor->hl_first; hl != NULL; hl = nexthl) {
		nexthl = hl->hl_next;
		free(hl);
	}
	anchor->hl_first = NULL;
	prep_startpos = prep_endpos = -1;
}

void
clr_hilite(void)
{
	clr_hlist(&hilite_anchor);
}

static void
clr_filter(void)
{
	clr_hlist(&filter_anchor);
}

/*
 * Should any characters in a specified range be highlighted?
 */
	static int
is_hilited_range(off_t pos, off_t epos)
{
	struct hilite *hl;

	/*
	 * Look at each highlight and see if any part of it falls in the range.
	 */
	for (hl = hilite_anchor.hl_first; hl != NULL; hl = hl->hl_next) {
		if (hl->hl_endpos > pos &&
		    (epos == -1 || epos > hl->hl_startpos))
			return (1);
	}
	return (0);
}

/*
 * Is a line "filtered" -- that is, should it be hidden?
 */
int
is_filtered(off_t pos)
{
	struct hilite *hl;

	if (ch_getflags() & CH_HELPFILE)
		return (0);

	/*
	 * Look at each filter and see if the start position
	 * equals the start position of the line.
	 */
	for (hl = filter_anchor.hl_first; hl != NULL; hl = hl->hl_next) {
		if (hl->hl_startpos == pos)
			return (1);
	}
	return (0);
}

/*
 * Should any characters in a specified range be highlighted?
 * If nohide is nonzero, don't consider hide_hilite.
 */
int
is_hilited(off_t pos, off_t epos, int nohide, int *p_matches)
{
	int match;

	if (p_matches != NULL)
		*p_matches = 0;

	if (!status_col &&
	    start_attnpos != -1 &&
	    pos < end_attnpos &&
	    (epos == -1 || epos > start_attnpos))
		/*
		 * The attn line overlaps this range.
		 */
		return (1);

	match = is_hilited_range(pos, epos);
	if (!match)
		return (0);

	if (p_matches != NULL)
		/*
		 * Report matches, even if we're hiding highlights.
		 */
		*p_matches = 1;

	if (hilite_search == 0)
		/*
		 * Not doing highlighting.
		 */
		return (0);

	if (!nohide && hide_hilite)
		/*
		 * Highlighting is hidden.
		 */
		return (0);

	return (1);
}

/*
 * Add a new hilite to a hilite list.
 */
static void
add_hilite(struct hilite *anchor, struct hilite *hl)
{
	struct hilite *ihl;

	/*
	 * Hilites are sorted in the list; find where new one belongs.
	 * Insert new one after ihl.
	 */
	for (ihl = anchor; ihl->hl_next != NULL; ihl = ihl->hl_next)
	{
		if (ihl->hl_next->hl_startpos > hl->hl_startpos)
			break;
	}

	/*
	 * Truncate hilite so it doesn't overlap any existing ones
	 * above and below it.
	 */
	if (ihl != anchor)
		hl->hl_startpos = MAXPOS(hl->hl_startpos, ihl->hl_endpos);
	if (ihl->hl_next != NULL)
		hl->hl_endpos = MINPOS(hl->hl_endpos,
		    ihl->hl_next->hl_startpos);
	if (hl->hl_startpos >= hl->hl_endpos) {
		/*
		 * Hilite was truncated out of existence.
		 */
		free(hl);
		return;
	}
	hl->hl_next = ihl->hl_next;
	ihl->hl_next = hl;
}

/*
 * Hilight every character in a range of displayed characters.
 */
static void
create_hilites(off_t linepos, int start_index, int end_index, int *chpos)
{
	struct hilite *hl;
	int i;

	/* Start the first hilite. */
	hl = ecalloc(1, sizeof (struct hilite));
	hl->hl_startpos = linepos + chpos[start_index];

	/*
	 * Step through the displayed chars.
	 * If the source position (before cvt) of the char is one more
	 * than the source pos of the previous char (the usual case),
	 * just increase the size of the current hilite by one.
	 * Otherwise (there are backspaces or something involved),
	 * finish the current hilite and start a new one.
	 */
	for (i = start_index+1; i <= end_index; i++) {
		if (chpos[i] != chpos[i-1] + 1 || i == end_index) {
			hl->hl_endpos = linepos + chpos[i-1] + 1;
			add_hilite(&hilite_anchor, hl);
			/* Start new hilite unless this is the last char. */
			if (i < end_index) {
				hl = ecalloc(1, sizeof (struct hilite));
				hl->hl_startpos = linepos + chpos[i];
			}
		}
	}
}

/*
 * Make a hilite for each string in a physical line which matches
 * the current pattern.
 * sp,ep delimit the first match already found.
 */
static void
hilite_line(off_t linepos, char *line, int line_len, int *chpos,
    char *sp, char *ep)
{
	char *searchp;
	char *line_end = line + line_len;

	/*
	 * sp and ep delimit the first match in the line.
	 * Mark the corresponding file positions, then
	 * look for further matches and mark them.
	 * {{ This technique, of calling match_pattern on subsequent
	 *    substrings of the line, may mark more than is correct
	 *    if the pattern starts with "^".  This bug is fixed
	 *    for those regex functions that accept a notbol parameter
	 *    (currently POSIX, PCRE and V8-with-regexec2). }}
	 */
	searchp = line;
	do {
		if (sp == NULL || ep == NULL)
			return;

		create_hilites(linepos, (intptr_t)sp - (intptr_t)line,
		    (intptr_t)ep - (intptr_t)line, chpos);
		/*
		 * If we matched more than zero characters,
		 * move to the first char after the string we matched.
		 * If we matched zero, just move to the next char.
		 */
		if (ep > searchp)
			searchp = ep;
		else if (searchp != line_end)
			searchp++;
		else /* end of line */
			break;
	} while (match_pattern(info_compiled(&search_info), search_info.text,
	    searchp, (intptr_t)line_end - (intptr_t)searchp, &sp, &ep, 1,
	    search_info.search_type));
}

/*
 * Change the caseless-ness of searches.
 * Updates the internal search state to reflect a change in the -i flag.
 */
void
chg_caseless(void)
{
	if (!is_ucase_pattern)
		/*
		 * Pattern did not have uppercase.
		 * Just set the search caselessness to the global caselessness.
		 */
		is_caseless = caseless;
	else
		/*
		 * Pattern did have uppercase.
		 * Discard the pattern; we can't change search caselessness now.
		 */
		clear_pattern(&search_info);
}

/*
 * Find matching text which is currently on screen and highlight it.
 */
static void
hilite_screen(void)
{
	struct scrpos scrpos;

	get_scrpos(&scrpos);
	if (scrpos.pos == -1)
		return;
	prep_hilite(scrpos.pos, position(BOTTOM_PLUS_ONE), -1);
	repaint_hilite(1);
}

/*
 * Change highlighting parameters.
 */
void
chg_hilite(void)
{
	/*
	 * Erase any highlights currently on screen.
	 */
	clr_hilite();
	hide_hilite = 0;

	if (hilite_search == OPT_ONPLUS)
		/*
		 * Display highlights.
		 */
		hilite_screen();
}

/*
 * Figure out where to start a search.
 */
static off_t
search_pos(int search_type)
{
	off_t pos;
	int linenum;

	if (empty_screen()) {
		/*
		 * Start at the beginning (or end) of the file.
		 * The empty_screen() case is mainly for
		 * command line initiated searches;
		 * for example, "+/xyz" on the command line.
		 * Also for multi-file (SRCH_PAST_EOF) searches.
		 */
		if (search_type & SRCH_FORW) {
			pos = ch_zero();
		} else {
			pos = ch_length();
			if (pos == -1) {
				(void) ch_end_seek();
				pos = ch_length();
			}
		}
		linenum = 0;
	} else {
		int add_one = 0;

		if (how_search == OPT_ON) {
			/*
			 * Search does not include current screen.
			 */
			if (search_type & SRCH_FORW)
				linenum = BOTTOM_PLUS_ONE;
			else
				linenum = TOP;
		} else if (how_search == OPT_ONPLUS &&
		    !(search_type & SRCH_AFTER_TARGET)) {
			/*
			 * Search includes all of displayed screen.
			 */
			if (search_type & SRCH_FORW)
				linenum = TOP;
			else
				linenum = BOTTOM_PLUS_ONE;
		} else {
			/*
			 * Search includes the part of current screen beyond
			 * the jump target.
			 * It starts at the jump target (if searching
			 * backwards), or at the jump target plus one
			 * (if forwards).
			 */
			linenum = jump_sline;
			if (search_type & SRCH_FORW)
				add_one = 1;
		}
		linenum = adjsline(linenum);
		pos = position(linenum);
		if (add_one)
			pos = forw_raw_line(pos, NULL, NULL);
	}

	/*
	 * If the line is empty, look around for a plausible starting place.
	 */
	if (search_type & SRCH_FORW) {
		while (pos == -1) {
			if (++linenum >= sc_height)
				break;
			pos = position(linenum);
		}
	} else {
		while (pos == -1) {
			if (--linenum < 0)
				break;
			pos = position(linenum);
		}
	}
	return (pos);
}

/*
 * Search a subset of the file, specified by start/end position.
 */
static int
search_range(off_t pos, off_t endpos, int search_type, int matches,
    int maxlines, off_t *plinepos, off_t *pendpos)
{
	char *line;
	char *cline;
	int line_len;
	off_t linenum;
	char *sp, *ep;
	int line_match;
	int cvt_ops;
	int cvt_len;
	int *chpos;
	off_t linepos, oldpos;

	linenum = find_linenum(pos);
	oldpos = pos;
	for (;;) {
		/*
		 * Get lines until we find a matching one or until
		 * we hit end-of-file (or beginning-of-file if we're
		 * going backwards), or until we hit the end position.
		 */
		if (ABORT_SIGS()) {
			/*
			 * A signal aborts the search.
			 */
			return (-1);
		}

		if ((endpos != -1 && pos >= endpos) ||
		    maxlines == 0) {
			/*
			 * Reached end position without a match.
			 */
			if (pendpos != NULL)
				*pendpos = pos;
			return (matches);
		}
		if (maxlines > 0)
			maxlines--;

		if (search_type & SRCH_FORW) {
			/*
			 * Read the next line, and save the
			 * starting position of that line in linepos.
			 */
			linepos = pos;
			pos = forw_raw_line(pos, &line, &line_len);
			if (linenum != 0)
				linenum++;
		} else {
			/*
			 * Read the previous line and save the
			 * starting position of that line in linepos.
			 */
			pos = back_raw_line(pos, &line, &line_len);
			linepos = pos;
			if (linenum != 0)
				linenum--;
		}

		if (pos == -1) {
			/*
			 * Reached EOF/BOF without a match.
			 */
			if (pendpos != NULL)
				*pendpos = oldpos;
			return (matches);
		}

		/*
		 * If we're using line numbers, we might as well
		 * remember the information we have now (the position
		 * and line number of the current line).
		 * Don't do it for every line because it slows down
		 * the search.  Remember the line number only if
		 * we're "far" from the last place we remembered it.
		 */
		if (linenums && abs((int)(pos - oldpos)) > 2048)
			add_lnum(linenum, pos);
		oldpos = pos;

		if (is_filtered(linepos))
			continue;

		/*
		 * If it's a caseless search, convert the line to lowercase.
		 * If we're doing backspace processing, delete backspaces.
		 */
		cvt_ops = get_cvt_ops();
		cvt_len = cvt_length(line_len);
		cline = ecalloc(1, cvt_len);
		chpos = cvt_alloc_chpos(cvt_len);
		cvt_text(cline, line, chpos, &line_len, cvt_ops);

		/*
		 * Check to see if the line matches the filter pattern.
		 * If so, add an entry to the filter list.
		 */
		if ((search_type & SRCH_FIND_ALL) &&
		    prev_pattern(&filter_info)) {
			int line_filter =
			    match_pattern(info_compiled(&filter_info),
			    filter_info.text, cline, line_len, &sp, &ep, 0,
			    filter_info.search_type);
			if (line_filter) {
				struct hilite *hl =
				    ecalloc(1, sizeof (struct hilite));
				hl->hl_startpos = linepos;
				hl->hl_endpos = pos;
				add_hilite(&filter_anchor, hl);
			}
		}

		/*
		 * Test the next line to see if we have a match.
		 * We are successful if we either want a match and got one,
		 * or if we want a non-match and got one.
		 */
		if (prev_pattern(&search_info)) {
			line_match = match_pattern(info_compiled(&search_info),
			    search_info.text, cline, line_len, &sp, &ep, 0,
			    search_type);
			if (line_match) {
				/*
				 * Got a match.
				 */
				if (search_type & SRCH_FIND_ALL) {
					/*
					 * We are supposed to find all matches
					 * in the range.
					 * Just add the matches in this line
					 * to the hilite list and keep
					 * searching.
					 */
					hilite_line(linepos, cline, line_len,
					    chpos, sp, ep);
				} else if (--matches <= 0) {
					/*
					 * Found the one match we're looking
					 * for.  Return it.
					 */
					if (hilite_search == OPT_ON) {
						/*
						 * Clear the hilite list and
						 * add only
						 * the matches in this one line.
						 */
						clr_hilite();
						hilite_line(linepos, cline,
						    line_len, chpos, sp, ep);
					}
					free(cline);
					free(chpos);
					if (plinepos != NULL)
						*plinepos = linepos;
					return (0);
				}
			}
		}
		free(cline);
		free(chpos);
	}
}

/*
 * search for a pattern in history. If found, compile that pattern.
 */
static int
hist_pattern(int search_type)
{
	char *pattern;

	set_mlist(ml_search, 0);
	pattern = cmd_lastpattern();
	if (pattern == NULL)
		return (0);

	if (set_pattern(&search_info, pattern, search_type) < 0)
		return (0);

	if (hilite_search == OPT_ONPLUS && !hide_hilite)
		hilite_screen();

	return (1);
}

/*
 * Search for the n-th occurrence of a specified pattern,
 * either forward or backward.
 * Return the number of matches not yet found in this file
 * (that is, n minus the number of matches found).
 * Return -1 if the search should be aborted.
 * Caller may continue the search in another file
 * if less than n matches are found in this file.
 */
int
search(int search_type, char *pattern, int n)
{
	off_t pos;

	if (pattern == NULL || *pattern == '\0') {
		/*
		 * A null pattern means use the previously compiled pattern.
		 */
		search_type |= SRCH_AFTER_TARGET;
		if (!prev_pattern(&search_info) && !hist_pattern(search_type)) {
			error("No previous regular expression", NULL);
			return (-1);
		}
		if ((search_type & SRCH_NO_REGEX) !=
		    (search_info.search_type & SRCH_NO_REGEX)) {
			error("Please re-enter search pattern", NULL);
			return (-1);
		}
		if (hilite_search == OPT_ON) {
			/*
			 * Erase the highlights currently on screen.
			 * If the search fails, we'll redisplay them later.
			 */
			repaint_hilite(0);
		}
		if (hilite_search == OPT_ONPLUS && hide_hilite) {
			/*
			 * Highlight any matches currently on screen,
			 * before we actually start the search.
			 */
			hide_hilite = 0;
			hilite_screen();
		}
		hide_hilite = 0;
	} else {
		/*
		 * Compile the pattern.
		 */
		if (set_pattern(&search_info, pattern, search_type) < 0)
			return (-1);
		if (hilite_search) {
			/*
			 * Erase the highlights currently on screen.
			 * Also permanently delete them from the hilite list.
			 */
			repaint_hilite(0);
			hide_hilite = 0;
			clr_hilite();
		}
		if (hilite_search == OPT_ONPLUS) {
			/*
			 * Highlight any matches currently on screen,
			 * before we actually start the search.
			 */
			hilite_screen();
		}
	}

	/*
	 * Figure out where to start the search.
	 */
	pos = search_pos(search_type);
	if (pos == -1) {
		/*
		 * Can't find anyplace to start searching from.
		 */
		if (search_type & SRCH_PAST_EOF)
			return (n);
		/* repaint(); -- why was this here? */
		error("Nothing to search", NULL);
		return (-1);
	}

	n = search_range(pos, -1, search_type, n, -1, &pos, NULL);
	if (n != 0) {
		/*
		 * Search was unsuccessful.
		 */
		if (hilite_search == OPT_ON && n > 0)
			/*
			 * Redisplay old hilites.
			 */
			repaint_hilite(1);
		return (n);
	}

	if (!(search_type & SRCH_NO_MOVE)) {
		/*
		 * Go to the matching line.
		 */
		jump_loc(pos, jump_sline);
	}

	if (hilite_search == OPT_ON)
		/*
		 * Display new hilites in the matching line.
		 */
		repaint_hilite(1);
	return (0);
}


/*
 * Prepare hilites in a given range of the file.
 *
 * The pair (prep_startpos,prep_endpos) delimits a contiguous region
 * of the file that has been "prepared"; that is, scanned for matches for
 * the current search pattern, and hilites have been created for such matches.
 * If prep_startpos == -1, the prep region is empty.
 * If prep_endpos == -1, the prep region extends to EOF.
 * prep_hilite asks that the range (spos,epos) be covered by the prep region.
 */
void
prep_hilite(off_t spos, off_t epos, int maxlines)
{
	off_t nprep_startpos = prep_startpos;
	off_t nprep_endpos = prep_endpos;
	off_t new_epos;
	off_t max_epos;
	int result;
	int i;

/*
 * Search beyond where we're asked to search, so the prep region covers
 * more than we need.  Do one big search instead of a bunch of small ones.
 */
#define	SEARCH_MORE (3*size_linebuf)

	if (!prev_pattern(&search_info) && !is_filtering())
		return;

	/*
	 * If we're limited to a max number of lines, figure out the
	 * file position we should stop at.
	 */
	if (maxlines < 0) {
		max_epos = -1;
	} else {
		max_epos = spos;
		for (i = 0; i < maxlines; i++)
			max_epos = forw_raw_line(max_epos, NULL, NULL);
	}

	/*
	 * Find two ranges:
	 * The range that we need to search (spos,epos); and the range that
	 * the "prep" region will then cover (nprep_startpos,nprep_endpos).
	 */

	if (prep_startpos == -1 ||
	    (epos != -1 && epos < prep_startpos) ||
	    spos > prep_endpos) {
		/*
		 * New range is not contiguous with old prep region.
		 * Discard the old prep region and start a new one.
		 */
		clr_hilite();
		clr_filter();
		if (epos != -1)
			epos += SEARCH_MORE;
		nprep_startpos = spos;
	} else {
		/*
		 * New range partially or completely overlaps old prep region.
		 */
		if (epos != -1) {
			if (epos > prep_endpos) {
				/*
				 * New range ends after old prep region.
				 * Extend prep region to end at end of new
				 * range.
				 */
				epos += SEARCH_MORE;

			} else {
				/*
				 * New range ends within old prep region.
				 * Truncate search to end at start of old prep
				 * region.
				 */
				epos = prep_startpos;
			}
		}

		if (spos < prep_startpos) {
			/*
			 * New range starts before old prep region.
			 * Extend old prep region backwards to start at
			 * start of new range.
			 */
			if (spos < SEARCH_MORE)
				spos = 0;
			else
				spos -= SEARCH_MORE;
			nprep_startpos = spos;
		} else { /* (spos >= prep_startpos) */
			/*
			 * New range starts within or after old prep region.
			 * Trim search to start at end of old prep region.
			 */
			spos = prep_endpos;
		}
	}

	if (epos != -1 && max_epos != -1 &&
	    epos > max_epos)
		/*
		 * Don't go past the max position we're allowed.
		 */
		epos = max_epos;

	if (epos == -1 || epos > spos) {
		int search_type = SRCH_FORW | SRCH_FIND_ALL;
		search_type |= (search_info.search_type & SRCH_NO_REGEX);
		result = search_range(spos, epos, search_type, 0,
		    maxlines, NULL, &new_epos);
		if (result < 0)
			return;
		if (prep_endpos == -1 || new_epos > prep_endpos)
			nprep_endpos = new_epos;
	}
	prep_startpos = nprep_startpos;
	prep_endpos = nprep_endpos;
}

/*
 * Set the pattern to be used for line filtering.
 */
void
set_filter_pattern(char *pattern, int search_type)
{
	clr_filter();
	if (pattern == NULL || *pattern == '\0')
		clear_pattern(&filter_info);
	else
		(void) set_pattern(&filter_info, pattern, search_type);
	screen_trashed = 1;
}

/*
 * Is there a line filter in effect?
 */
int
is_filtering(void)
{
	if (ch_getflags() & CH_HELPFILE)
		return (0);
	return (prev_pattern(&filter_info));
}
@


1.18
log
@little bit more KNF
@
text
@a479 2
	if (sp == NULL || ep == NULL)
		return;
d492 3
@


1.17
log
@style(9) includes

ok nicm@@
@
text
@d211 1
a211 1
	for (slinenum = TOP;  slinenum < TOP + sc_height-1;  slinenum++) {
d408 1
a408 1
	for (ihl = anchor;  ihl->hl_next != NULL;  ihl = ihl->hl_next)
@


1.16
log
@Remove LINUNUM, a needless alias for off_t. Also, remove a redundant
condition.

ok nicm@@
@
text
@d16 1
a19 1
#include "charset.h"
@


1.15
log
@Remove NULL-check before free().
@
text
@d661 1
a661 1
	LINENUM linenum;
@


1.14
log
@remove fancy null check function in favor of checking for null.
from Ricardo Mestre
@
text
@d124 1
a124 2
	if (info->text != NULL)
		free(info->text);
@


1.13
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@d180 1
a180 1
		return (!is_null_pattern(info->compiled));
@


1.12
log
@Remove NULL-checks before free(), a needless comment, and a needless
void* cast.

ok nicm@@
@
text
@d274 1
a274 1
		error("No previous regular expression", NULL_PARG);
d863 1
a863 1
			error("No previous regular expression", NULL_PARG);
d868 1
a868 1
			error("Please re-enter search pattern", NULL_PARG);
d922 1
a922 1
		error("Nothing to search", NULL_PARG);
@


1.11
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d100 1
a100 2
	if (info->text != NULL)
		free(info->text);
d102 1
a102 1
	if (pattern != NULL) {
a103 1
	}
d292 1
a292 1
		free((void*)hl);
@


1.10
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.9
log
@When invoked as more, make the -i option behave the same as less's
-I to match POSIX.  OK and man bits from jmc@@
@
text
@d9 4
a12 1

d23 2
a24 2
#define	MINPOS(a,b)	(((a) < (b)) ? (a) : (b))
#define	MAXPOS(a,b)	(((a) > (b)) ? (a) : (b))
d35 3
a37 3
extern void * constant ml_search;
extern POSITION start_attnpos;
extern POSITION end_attnpos;
a39 1
#if HILITE_SEARCH
a43 1
extern int less_is_more;
d45 2
a46 2
static POSITION prep_startpos;
static POSITION prep_endpos;
d50 1
a50 2
struct hilite
{
d52 2
a53 2
	POSITION hl_startpos;
	POSITION hl_endpos;
d55 2
a56 2
static struct hilite hilite_anchor = { NULL, NULL_POSITION, NULL_POSITION };
static struct hilite filter_anchor = { NULL, NULL_POSITION, NULL_POSITION };
a57 1
#endif
d64 2
a65 2
	DEFINE_PATTERN(compiled);
	char* text;
d69 2
a70 6
#if NO_REGEX
#define info_compiled(info) ((void*)0)
#else
#define info_compiled(info) ((info)->compiled)
#endif
	
d77 2
a78 3
	static int
is_ucase(str)
	char *str;
d83 1
a83 2
	while (str < str_end)
	{
d85 1
a85 1
		if (IS_UPPER(ch))
d94 2
a95 5
	static int
set_pattern(info, pattern, search_type)
	struct pattern_info *info;
	char *pattern;
	int search_type;
a96 1
#if !NO_REGEX
d98 1
a98 1
		CLEAR_PATTERN(info->compiled);
d100 1
a100 2
		return -1;
#endif
d105 3
a107 2
	if (pattern != NULL)
		info->text = save(pattern);
d115 1
a115 1
	if (is_ucase_pattern && caseless != OPT_ONPLUS && (caseless != OPT_ON || !less_is_more))
d119 1
a119 1
	return 0;
d125 2
a126 3
	static void
clear_pattern(info)
	struct pattern_info *info;
a130 1
#if !NO_REGEX
a131 1
#endif
d137 2
a138 3
	static void
init_pattern(info)
	struct pattern_info *info;
d140 1
a140 1
	CLEAR_PATTERN(info->compiled);
d148 2
a149 2
	public void
init_search()
d158 2
a159 2
	static int
get_cvt_ops()
d162 2
a163 3
	if (is_caseless || bs_mode == BS_SPECIAL)
	{
		if (is_caseless) 
d169 1
a169 2
	} else if (bs_mode != BS_CONTROL)
	{
d180 2
a181 3
	static int
prev_pattern(info)
	struct pattern_info *info;
a182 1
#if !NO_REGEX
a184 1
#endif
a187 1
#if HILITE_SEARCH
d193 2
a194 3
	public void
repaint_hilite(on)
	int on;
d197 1
a197 2
	POSITION pos;
	POSITION epos;
d204 1
a204 2
	if (!on)
	{
d210 1
a210 2
	if (!can_goto_line)
	{
d216 1
a216 2
	for (slinenum = TOP;  slinenum < TOP + sc_height-1;  slinenum++)
	{
d218 1
a218 1
		if (pos == NULL_POSITION)
a219 1
		epos = position(slinenum+1);
d231 2
a232 2
	public void
clear_attn()
d235 4
a238 4
	POSITION old_start_attnpos;
	POSITION old_end_attnpos;
	POSITION pos;
	POSITION epos;
d241 1
a241 1
	if (start_attnpos == NULL_POSITION)
d245 1
a245 1
	start_attnpos = end_attnpos = NULL_POSITION;
d247 1
a247 2
	if (!can_goto_line)
	{
d254 1
a254 2
	for (slinenum = TOP;  slinenum < TOP + sc_height-1;  slinenum++)
	{
d256 1
a256 1
		if (pos == NULL_POSITION)
d260 1
a260 2
		     (epos == NULL_POSITION || epos > old_start_attnpos))
		{
a269 1
#endif
d274 2
a275 2
	public void
undo_search()
d277 1
a277 2
	if (!prev_pattern(&search_info))
	{
a280 1
#if HILITE_SEARCH
a282 1
#endif
a284 1
#if HILITE_SEARCH
d288 2
a289 3
	public void
clr_hlist(anchor)
	struct hilite *anchor;
d294 1
a294 2
	for (hl = anchor->hl_first;  hl != NULL;  hl = nexthl)
	{
d299 1
a299 1
	prep_startpos = prep_endpos = NULL_POSITION;
d302 2
a303 2
	public void
clr_hilite()
d308 2
a309 2
	public void
clr_filter()
d318 1
a318 3
is_hilited_range(pos, epos)
	POSITION pos;
	POSITION epos;
d325 1
a325 2
	for (hl = hilite_anchor.hl_first;  hl != NULL;  hl = hl->hl_next)
	{
d327 1
a327 1
		    (epos == NULL_POSITION || epos > hl->hl_startpos))
d333 1
a333 1
/* 
d336 2
a337 3
	public int
is_filtered(pos)
	POSITION pos;
d348 1
a348 2
	for (hl = filter_anchor.hl_first;  hl != NULL;  hl = hl->hl_next)
	{
d359 2
a360 6
	public int
is_hilited(pos, epos, nohide, p_matches)
	POSITION pos;
	POSITION epos;
	int nohide;
	int *p_matches;
d368 1
a368 1
	    start_attnpos != NULL_POSITION && 
d370 1
a370 1
	     (epos == NULL_POSITION || epos > start_attnpos))
d404 2
a405 4
	static void
add_hilite(anchor, hl)
	struct hilite *anchor;
	struct hilite *hl;
d426 3
a428 3
		hl->hl_endpos = MINPOS(hl->hl_endpos, ihl->hl_next->hl_startpos);
	if (hl->hl_startpos >= hl->hl_endpos)
	{
d442 2
a443 6
	static void
create_hilites(linepos, start_index, end_index, chpos)
	POSITION linepos;
	int start_index;
	int end_index;
	int *chpos;
d449 1
a449 1
	hl = (struct hilite *) ecalloc(1, sizeof(struct hilite));
d460 2
a461 4
	for (i = start_index+1;  i <= end_index;  i++)
	{
		if (chpos[i] != chpos[i-1] + 1 || i == end_index)
		{
d465 2
a466 3
			if (i < end_index)
			{
				hl = (struct hilite *) ecalloc(1, sizeof(struct hilite));
d474 1
a474 1
 * Make a hilite for each string in a physical line which matches 
d478 3
a480 9
	static void
hilite_line(linepos, line, line_len, chpos, sp, ep, cvt_ops)
	POSITION linepos;
	char *line;
	int line_len;
	int *chpos;
	char *sp;
	char *ep;
	int cvt_ops;
d499 2
a500 1
		create_hilites(linepos, sp-line, ep-line, chpos);
d513 2
a514 1
			searchp, line_end - searchp, &sp, &ep, 1, search_info.search_type));
a515 1
#endif
d518 1
a518 1
 * Change the caseless-ness of searches.  
d521 2
a522 2
	public void
chg_caseless()
a537 1
#if HILITE_SEARCH
d541 2
a542 2
	static void
hilite_screen()
d547 1
a547 1
	if (scrpos.pos == NULL_POSITION)
d556 2
a557 2
	public void
chg_hilite()
a570 1
#endif
d575 2
a576 3
	static POSITION
search_pos(search_type)
	int search_type;
d578 1
a578 1
	POSITION pos;
d581 1
a581 2
	if (empty_screen())
	{
d584 1
a584 1
		 * The empty_screen() case is mainly for 
d589 1
a589 2
		if (search_type & SRCH_FORW)
		{
d591 1
a591 2
		} else
		{
d593 1
a593 2
			if (pos == NULL_POSITION)
			{
d599 1
a599 2
	} else 
	{
d602 1
a602 2
		if (how_search == OPT_ON)
		{
d610 2
a611 2
		} else if (how_search == OPT_ONPLUS && !(search_type & SRCH_AFTER_TARGET))
		{
d619 1
a619 2
		} else 
		{
d621 5
a625 3
			 * Search includes the part of current screen beyond the jump target.
			 * It starts at the jump target (if searching backwards),
			 * or at the jump target plus one (if forwards).
d628 2
a629 2
			if (search_type & SRCH_FORW) 
			    add_one = 1;
d634 1
a634 1
			pos = forw_raw_line(pos, (char **)NULL, (int *)NULL);
d640 12
a651 16
	if (search_type & SRCH_FORW) 
	{
	    while (pos == NULL_POSITION)
	    {
	        if (++linenum >= sc_height)
	            break;
	        pos = position(linenum);
	    }
	} else 
	{
	    while (pos == NULL_POSITION)
	    {
	        if (--linenum < 0)
	            break;
	        pos = position(linenum);
	    }
d659 3
a661 9
	static int
search_range(pos, endpos, search_type, matches, maxlines, plinepos, pendpos)
	POSITION pos;
	POSITION endpos;
	int search_type;
	int matches;
	int maxlines;
	POSITION *plinepos;
	POSITION *pendpos;
d672 1
a672 1
	POSITION linepos, oldpos;
d676 1
a676 2
	for (;;)
	{
d679 1
a679 1
		 * we hit end-of-file (or beginning-of-file if we're 
d682 1
a682 2
		if (ABORT_SIGS())
		{
d689 2
a690 2
		if ((endpos != NULL_POSITION && pos >= endpos) || maxlines == 0)
		{
d701 1
a701 2
		if (search_type & SRCH_FORW)
		{
d703 1
a703 1
			 * Read the next line, and save the 
d710 1
a710 2
		} else
		{
d721 1
a721 2
		if (pos == NULL_POSITION)
		{
d750 2
a751 2
		cvt_len = cvt_length(line_len, cvt_ops);
		cline = (char *) ecalloc(1, cvt_len);
a754 1
#if HILITE_SEARCH
d759 9
a767 7
		if ((search_type & SRCH_FIND_ALL) && prev_pattern(&filter_info)) {
			int line_filter = match_pattern(info_compiled(&filter_info), filter_info.text,
				cline, line_len, &sp, &ep, 0, filter_info.search_type);
			if (line_filter)
			{
				struct hilite *hl = (struct hilite *)
					ecalloc(1, sizeof(struct hilite));
a772 1
#endif
d779 5
a783 6
		if (prev_pattern(&search_info))
		{
			line_match = match_pattern(info_compiled(&search_info), search_info.text,
				cline, line_len, &sp, &ep, 0, search_type);
			if (line_match)
			{
d787 1
a787 3
				if (search_type & SRCH_FIND_ALL)
				{
#if HILITE_SEARCH
d789 5
a793 3
					 * We are supposed to find all matches in the range.
					 * Just add the matches in this line to the 
					 * hilite list and keep searching.
d795 3
a797 4
					hilite_line(linepos, cline, line_len, chpos, sp, ep, cvt_ops);
#endif
				} else if (--matches <= 0)
				{
d799 2
a800 2
					 * Found the one match we're looking for.
					 * Return it.
d802 1
a802 3
#if HILITE_SEARCH
					if (hilite_search == OPT_ON)
					{
d804 2
a805 1
						 * Clear the hilite list and add only
d809 2
a810 1
						hilite_line(linepos, cline, line_len, chpos, sp, ep, cvt_ops);
a811 1
#endif
d828 2
a829 3
	static int 
hist_pattern(search_type) 
	int search_type;
a830 1
#if CMD_HISTORY
a840 1
#if HILITE_SEARCH
a842 1
#endif
a844 3
#else /* CMD_HISTORY */
	return (0);
#endif /* CMD_HISTORY */
d848 1
a848 1
 * Search for the n-th occurrence of a specified pattern, 
d853 1
a853 1
 * Caller may continue the search in another file 
d856 2
a857 5
	public int
search(search_type, pattern, n)
	int search_type;
	char *pattern;
	int n;
d859 1
a859 1
	POSITION pos;
d861 1
a861 2
	if (pattern == NULL || *pattern == '\0')
	{
d866 1
a866 2
		if (!prev_pattern(&search_info) && !hist_pattern(search_type))
		{
d870 2
a871 3
		if ((search_type & SRCH_NO_REGEX) != 
		      (search_info.search_type & SRCH_NO_REGEX))
		{
d873 1
a873 1
			return -1;
d875 1
a875 3
#if HILITE_SEARCH
		if (hilite_search == OPT_ON)
		{
d882 1
a882 2
		if (hilite_search == OPT_ONPLUS && hide_hilite)
		{
d891 1
a891 3
#endif
	} else
	{
d897 1
a897 3
#if HILITE_SEARCH
		if (hilite_search)
		{
d906 1
a906 2
		if (hilite_search == OPT_ONPLUS)
		{
a912 1
#endif
d919 1
a919 2
	if (pos == NULL_POSITION)
	{
d930 2
a931 4
	n = search_range(pos, NULL_POSITION, search_type, n, -1,
			&pos, (POSITION*)NULL);
	if (n != 0)
	{
a934 1
#if HILITE_SEARCH
a939 1
#endif
d943 1
a943 2
	if (!(search_type & SRCH_NO_MOVE))
	{
a949 1
#if HILITE_SEARCH
a954 1
#endif
a958 1
#if HILITE_SEARCH
d965 2
a966 2
 * If prep_startpos == NULL_POSITION, the prep region is empty.
 * If prep_endpos == NULL_POSITION, the prep region extends to EOF.
d969 7
a975 10
	public void
prep_hilite(spos, epos, maxlines)
	POSITION spos;
	POSITION epos;
	int maxlines;
{
	POSITION nprep_startpos = prep_startpos;
	POSITION nprep_endpos = prep_endpos;
	POSITION new_epos;
	POSITION max_epos;
d992 3
a994 4
	if (maxlines < 0)
		max_epos = NULL_POSITION;
	else
	{
d996 2
a997 2
		for (i = 0;  i < maxlines;  i++)
			max_epos = forw_raw_line(max_epos, (char **)NULL, (int *)NULL);
d1006 3
a1008 4
	if (prep_startpos == NULL_POSITION ||
	    (epos != NULL_POSITION && epos < prep_startpos) ||
	    spos > prep_endpos)
	{
d1015 1
a1015 1
		if (epos != NULL_POSITION)
d1018 1
a1018 2
	} else
	{
d1022 17
a1038 20
		if (epos == NULL_POSITION)
		{
			/*
			 * New range goes to end of file.
			 */
			;
		} else if (epos > prep_endpos)
		{
			/*
			 * New range ends after old prep region.
			 * Extend prep region to end at end of new range.
			 */
			epos += SEARCH_MORE;
		} else /* (epos <= prep_endpos) */
		{
			/*
			 * New range ends within old prep region.
			 * Truncate search to end at start of old prep region.
			 */
			epos = prep_startpos;
d1041 1
a1041 2
		if (spos < prep_startpos)
		{
d1044 1
a1044 1
			 * Extend old prep region backwards to start at 
d1052 1
a1052 2
		} else /* (spos >= prep_startpos) */
		{
d1061 1
a1061 1
	if (epos != NULL_POSITION && max_epos != NULL_POSITION &&
d1068 1
a1068 2
	if (epos == NULL_POSITION || epos > spos)
	{
d1072 1
a1072 1
				maxlines, (POSITION*)NULL, &new_epos);
d1075 1
a1075 1
		if (prep_endpos == NULL_POSITION || new_epos > prep_endpos)
d1085 2
a1086 4
	public void
set_filter_pattern(pattern, search_type)
	char *pattern;
	int search_type;
d1092 1
a1092 1
		set_pattern(&filter_info, pattern, search_type);
d1099 2
a1100 2
	public int
is_filtering()
d1104 1
a1104 17
	return prev_pattern(&filter_info);
}
#endif

#if HAVE_V8_REGCOMP
/*
 * This function is called by the V8 regcomp to report 
 * errors in regular expressions.
 */
	void 
regerror(s) 
	char *s; 
{
	PARG parg;

	parg.p_string = s;
	error("%s", &parg);
a1105 2
#endif

@


1.8
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d42 1
d126 1
a126 1
	if (is_ucase_pattern && caseless != OPT_ONPLUS)
@


1.7
log
@Use volatile sig_atomic_t, not int, for the sigs variable.  Also
move the call to bell() out of u_interrupt() (a signal handler).
OK and with help from deraadt@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d68 6
d106 1
d108 1
a108 1
		CLEAR_PATTERN(search_info.compiled);
d111 1
d142 1
d144 1
d200 5
a204 3
	if (info->search_type & SRCH_NO_REGEX)
		return (info->text != NULL);
	return (!is_null_pattern(info->compiled));
d487 41
a543 1
	struct hilite *hl;
d559 1
a559 7
		if (ep > sp)
		{
			hl = (struct hilite *) ecalloc(1, sizeof(struct hilite));
			hl->hl_startpos = linepos + chpos[sp-line];
			hl->hl_endpos = linepos + chpos[ep-line];
			add_hilite(&hilite_anchor, hl);
		}
d571 1
a571 1
	} while (match_pattern(search_info.compiled, search_info.text,
d843 1
a843 1
			int line_filter = match_pattern(filter_info.compiled, filter_info.text,
d863 1
a863 1
			line_match = match_pattern(search_info.compiled, search_info.text,
@


1.6
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d24 1
a24 1
extern int sigs;
@


1.5
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d17 1
d19 1
a23 26
#if HAVE_POSIX_REGCOMP
#include <regex.h>
#ifdef REG_EXTENDED
#define	REGCOMP_FLAG	REG_EXTENDED
#else
#define	REGCOMP_FLAG	0
#endif
#endif
#if HAVE_PCRE
#include <pcre.h>
#endif
#if HAVE_RE_COMP
char *re_comp();
int re_exec();
#endif
#if HAVE_REGCMP
char *regcmp();
char *regex();
extern char *__loc1;
#endif
#if HAVE_V8_REGCOMP
#include "regexp.h"
#endif

static int match();

d33 1
d36 2
a39 1
extern int screen_trashed;
d46 2
d56 1
d62 32
a93 1
 * search pattern.  
d95 17
a111 15
#if HAVE_POSIX_REGCOMP
static regex_t *regpattern = NULL;
#endif
#if HAVE_PCRE
pcre *regpattern = NULL;
#endif
#if HAVE_RE_COMP
int re_pattern = 0;
#endif
#if HAVE_REGCMP
static char *cpattern = NULL;
#endif
#if HAVE_V8_REGCOMP
static struct regexp *regpattern = NULL;
#endif
d113 11
a123 4
static int is_caseless;
static int is_ucase_pattern;
static int last_search_type;
static char *last_pattern = NULL;
d126 1
a126 1
 * Convert text.  Perform one or more of these transformations:
d128 9
a136 4
#define	CVT_TO_LC	01	/* Convert upper-case to lower-case */
#define	CVT_BS		02	/* Do backspace processing */
#define	CVT_CRLF	04	/* Remove CR after LF */
#define	CVT_ANSI	010	/* Remove ANSI escape sequences */
d138 3
d142 16
a157 29
cvt_text(odst, osrc, ops)
	char *odst;
	char *osrc;
	int ops;
{
	register char *dst;
	register char *src;

	for (src = osrc, dst = odst;  *src != '\0';  src++)
	{
		if ((ops & CVT_TO_LC) && isupper((unsigned char) *src))
			/* Convert uppercase to lowercase. */
			*dst++ = tolower((unsigned char) *src);
		else if ((ops & CVT_BS) && *src == '\b' && dst > odst)
			/* Delete BS and preceding char. */
			dst--;
		else if ((ops & CVT_ANSI) && *src == ESC)
		{
			/* Skip to end of ANSI escape sequence. */
			while (src[1] != '\0')
				if (is_ansi_end(*++src))
					break;
		} else 
			/* Just copy. */
			*dst++ = *src;
	}
	if ((ops & CVT_CRLF) && dst > odst && dst[-1] == '\r')
		dst--;
	*dst = '\0';
d161 1
a161 1
 * Determine which conversions to perform.
a184 15
 * Are there any uppercase letters in this string?
 */
	static int
is_ucase(s)
	char *s;
{
	register char *p;

	for (p = s;  *p != '\0';  p++)
		if (isupper((unsigned char) *p))
			return (1);
	return (0);
}

/*
d188 2
a189 1
prev_pattern()
d191 3
a193 20
	if (last_search_type & SRCH_NO_REGEX)
		return (last_pattern != NULL);
#if HAVE_POSIX_REGCOMP
	return (regpattern != NULL);
#endif
#if HAVE_PCRE
	return (regpattern != NULL);
#endif
#if HAVE_RE_COMP
	return (re_pattern != 0);
#endif
#if HAVE_REGCMP
	return (cpattern != NULL);
#endif
#if HAVE_V8_REGCOMP
	return (regpattern != NULL);
#endif
#if NO_REGEX
	return (last_pattern != NULL);
#endif
d235 3
a237 10
		/*
		 * If any character in the line is highlighted, 
		 * repaint the line.
		 */
		if (is_hilited(pos, epos, 1))
		{
			(void) forw_line(pos);
			goto_line(slinenum);
			put_line();
		}
d239 1
d254 1
d282 1
d285 2
d296 1
a296 1
	if (!prev_pattern())
d307 1
d309 1
a309 1
 * Compile a search pattern, for future use by match_pattern.
d311 3
a313 4
	static int
compile_pattern(pattern, search_type)
	char *pattern;
	int search_type;
d315 4
a318 1
	if ((search_type & SRCH_NO_REGEX) == 0)
d320 2
a321 61
#if HAVE_POSIX_REGCOMP
		regex_t *s = (regex_t *) ecalloc(1, sizeof(regex_t));
		if (regcomp(s, pattern, REGCOMP_FLAG))
		{
			free(s);
			error("Invalid pattern", NULL_PARG);
			return (-1);
		}
		if (regpattern != NULL)
			regfree(regpattern);
		regpattern = s;
#endif
#if HAVE_PCRE
		pcre *comp;
		const char *errstring;
		int erroffset;
		PARG parg;
		comp = pcre_compile(pattern, 0,
				&errstring, &erroffset, NULL);
		if (comp == NULL)
		{
			parg.p_string = (char *) errstring;
			error("%s", &parg);
			return (-1);
		}
		regpattern = comp;
#endif
#if HAVE_RE_COMP
		PARG parg;
		if ((parg.p_string = re_comp(pattern)) != NULL)
		{
			error("%s", &parg);
			return (-1);
		}
		re_pattern = 1;
#endif
#if HAVE_REGCMP
		char *s;
		if ((s = regcmp(pattern, 0)) == NULL)
		{
			error("Invalid pattern", NULL_PARG);
			return (-1);
		}
		if (cpattern != NULL)
			free(cpattern);
		cpattern = s;
#endif
#if HAVE_V8_REGCOMP
		struct regexp *s;
		if ((s = regcomp(pattern)) == NULL)
		{
			/*
			 * regcomp has already printed an error message 
			 * via regerror().
			 */
			return (-1);
		}
		if (regpattern != NULL)
			free(regpattern);
		regpattern = s;
#endif
d323 3
d327 4
a330 6
	if (last_pattern != NULL)
		free(last_pattern);
	last_pattern = save(pattern);

	last_search_type = search_type;
	return (0);
d333 2
a334 5
/*
 * Forget that we have a compiled pattern.
 */
	static void
uncompile_pattern()
d336 1
a336 24
#if HAVE_POSIX_REGCOMP
	if (regpattern != NULL)
		regfree(regpattern);
	regpattern = NULL;
#endif
#if HAVE_PCRE
	if (regpattern != NULL)
		pcre_free(regpattern);
	regpattern = NULL;
#endif
#if HAVE_RE_COMP
	re_pattern = 0;
#endif
#if HAVE_REGCMP
	if (cpattern != NULL)
		free(cpattern);
	cpattern = NULL;
#endif
#if HAVE_V8_REGCOMP
	if (regpattern != NULL)
		free(regpattern);
	regpattern = NULL;
#endif
	last_pattern = NULL;
d340 1
a340 2
 * Perform a pattern match with the previously compiled pattern.
 * Set sp and ep to the start and end of the matched string.
d343 10
a352 28
match_pattern(line, sp, ep, notbol)
	char *line;
	char **sp;
	char **ep;
	int notbol;
{
	int matched;

	if (last_search_type & SRCH_NO_REGEX)
		return (match(last_pattern, line, sp, ep));

#if HAVE_POSIX_REGCOMP
	{
		regmatch_t rm;
		int flags = (notbol) ? REG_NOTBOL : 0;
		matched = !regexec(regpattern, line, 1, &rm, flags);
		if (!matched)
			return (0);
#ifndef __WATCOMC__
		*sp = line + rm.rm_so;
		*ep = line + rm.rm_eo;
#else
		*sp = rm.rm_sp;
		*ep = rm.rm_ep;
#endif
	}
#endif
#if HAVE_PCRE
d354 3
a356 8
		int flags = (notbol) ? PCRE_NOTBOL : 0;
		int ovector[3];
		matched = pcre_exec(regpattern, NULL, line, strlen(line),
			0, flags, ovector, 3) >= 0;
		if (!matched)
			return (0);
		*sp = line + ovector[0];
		*ep = line + ovector[1];
d358 1
a358 30
#endif
#if HAVE_RE_COMP
	matched = (re_exec(line) == 1);
	/*
	 * re_exec doesn't seem to provide a way to get the matched string.
	 */
	*sp = *ep = NULL;
#endif
#if HAVE_REGCMP
	*ep = regex(cpattern, line);
	matched = (*ep != NULL);
	if (!matched)
		return (0);
	*sp = __loc1;
#endif
#if HAVE_V8_REGCOMP
#if HAVE_REGEXEC2
	matched = regexec2(regpattern, line, notbol);
#else
	matched = regexec(regpattern, line);
#endif
	if (!matched)
		return (0);
	*sp = regpattern->startp[0];
	*ep = regpattern->endp[0];
#endif
#if NO_REGEX
	matched = match(last_pattern, line, sp, ep);
#endif
	return (matched);
d361 2
a362 3
#if HILITE_SEARCH
/*
 * Clear the hilite list.
d364 3
a366 2
	public void
clr_hilite()
a368 1
	struct hilite *nexthl;
d370 8
a377 1
	for (hl = hilite_anchor.hl_first;  hl != NULL;  hl = nexthl)
d379 2
a380 2
		nexthl = hl->hl_next;
		free((void*)hl);
d382 1
a382 2
	hilite_anchor.hl_first = NULL;
	prep_startpos = prep_endpos = NULL_POSITION;
d390 1
a390 1
is_hilited(pos, epos, nohide)
d394 1
d396 4
a399 1
	struct hilite *hl;
d410 10
d432 1
a432 10
	/*
	 * Look at each highlight and see if any part of it falls in the range.
	 */
	for (hl = hilite_anchor.hl_first;  hl != NULL;  hl = hl->hl_next)
	{
		if (hl->hl_endpos > pos &&
		    (epos == NULL_POSITION || epos > hl->hl_startpos))
			return (1);
	}
	return (0);
a475 86
 * Adjust hl_startpos & hl_endpos to account for backspace processing.
 */
	static void
adj_hilite(anchor, linepos, cvt_ops)
	struct hilite *anchor;
	POSITION linepos;
	int cvt_ops;
{
	char *line;
	struct hilite *hl;
	int checkstart;
	POSITION opos;
	POSITION npos;

	/*
	 * The line was already scanned and hilites were added (in hilite_line).
	 * But it was assumed that each char position in the line 
	 * correponds to one char position in the file.
	 * This may not be true if there are backspaces in the line.
	 * Get the raw line again.  Look at each character.
	 */
	(void) forw_raw_line(linepos, &line);
	opos = npos = linepos;
	hl = anchor->hl_first;
	checkstart = TRUE;
	while (hl != NULL)
	{
		/*
		 * See if we need to adjust the current hl_startpos or 
		 * hl_endpos.  After adjusting startpos[i], move to endpos[i].
		 * After adjusting endpos[i], move to startpos[i+1].
		 * The hilite list must be sorted thus: 
		 * startpos[0] < endpos[0] <= startpos[1] < endpos[1] <= etc.
		 */
		if (checkstart && hl->hl_startpos == opos)
		{
			hl->hl_startpos = npos;
			checkstart = FALSE;
			continue; /* {{ not really necessary }} */
		} else if (!checkstart && hl->hl_endpos == opos)
		{
			hl->hl_endpos = npos;
			checkstart = TRUE;
			hl = hl->hl_next;
			continue; /* {{ necessary }} */
		}
		if (*line == '\0')
			break;
		if (cvt_ops & CVT_ANSI)
		{
			while (line[0] == ESC)
			{
				/*
				 * Found an ESC.  The file position moves
				 * forward past the entire ANSI escape sequence.
				 */
				line++;
				npos++;
				while (*line != '\0')
				{
					npos++;
					if (is_ansi_end(*line++))
						break;
				}
			}
		}
		opos++;
		npos++;
		line++;
		if (cvt_ops & CVT_BS)
		{
			while (line[0] == '\b' && line[1] != '\0')
			{
				/*
				 * Found a backspace.  The file position moves
				 * forward by 2 relative to the processed line
				 * which was searched in hilite_line.
				 */
				npos += 2;
				line += 2;
			}
		}
	}
}

/*
d481 1
a481 1
hilite_line(linepos, line, sp, ep, cvt_ops)
d484 2
d491 1
a492 1
	struct hilite hilites;
d504 1
a504 1
	 *    (currently POSIX and V8-with-regexec2). }}
a506 4
	/*
	 * Put the hilites into a temporary list until they're adjusted.
	 */
	hilites.hl_first = NULL;
a509 5
			/*
			 * Assume that each char position in the "line"
			 * buffer corresponds to one char position in the file.
			 * This is not quite true; we need to adjust later.
			 */
d511 3
a513 3
			hl->hl_startpos = linepos + (sp-line);
			hl->hl_endpos = linepos + (ep-line);
			add_hilite(&hilites, hl);
d522 1
a522 1
		else if (*searchp != '\0')
d526 2
a527 17
	} while (match_pattern(searchp, &sp, &ep, 1));

	/*
	 * If there were backspaces in the original line, they
	 * were removed, and hl_startpos/hl_endpos are not correct.
	 * {{ This is very ugly. }}
	 */
	adj_hilite(&hilites, linepos, cvt_ops);

	/*
	 * Now put the hilites into the real list.
	 */
	while ((hl = hilites.hl_next) != NULL)
	{
		hilites.hl_next = hl->hl_next;
		add_hilite(&hilite_anchor, hl);
	}
d549 1
a549 1
		uncompile_pattern();
d609 1
a609 1
			return (ch_zero());
a617 1
			return (pos);
d619 2
a620 2
	}
	if (how_search)
d622 12
a633 18
		/*
		 * Search does not include current screen.
		 */
		if (search_type & SRCH_FORW)
			linenum = BOTTOM_PLUS_ONE;
		else
			linenum = TOP;
		pos = position(linenum);
	} else
	{
		/*
		 * Search includes current screen.
		 * It starts at the jump target (if searching backwards),
		 * or at the jump target plus one (if forwards).
		 */
		linenum = adjsline(jump_sline);
		pos = position(linenum);
		if (search_type & SRCH_FORW)
d635 7
a641 7
			pos = forw_raw_line(pos, (char **)NULL);
			while (pos == NULL_POSITION)
			{
				if (++linenum >= sc_height)
					break;
				pos = position(linenum);
			}
d644 8
a651 6
			while (pos == NULL_POSITION)
			{
				if (--linenum < 0)
					break;
				pos = position(linenum);
			}
d653 25
d696 2
d702 2
d742 1
a742 1
			pos = forw_raw_line(pos, &line);
d751 1
a751 1
			pos = back_raw_line(pos, &line);
d775 1
a775 1
		if (linenums && abs((int)(pos - oldpos)) > 1024)
d779 3
d787 23
a809 1
		cvt_text(line, line, cvt_ops);
d816 1
a816 9
		line_match = match_pattern(line, &sp, &ep, 0);
		line_match = (!(search_type & SRCH_NO_MATCH) && line_match) ||
				((search_type & SRCH_NO_MATCH) && !line_match);
		if (!line_match)
			continue;
		/*
		 * Got a match.
		 */
		if (search_type & SRCH_FIND_ALL)
d818 2
a819 6
#if HILITE_SEARCH
			/*
			 * We are supposed to find all matches in the range.
			 * Just add the matches in this line to the 
			 * hilite list and keep searching.
			 */
a820 10
				hilite_line(linepos, line, sp, ep, cvt_ops);
#endif
		} else if (--matches <= 0)
		{
			/*
			 * Found the one match we're looking for.
			 * Return it.
			 */
#if HILITE_SEARCH
			if (hilite_search == 1)
d823 1
a823 2
				 * Clear the hilite list and add only
				 * the matches in this one line.
d825 33
a857 3
				clr_hilite();
				if (line_match)
					hilite_line(linepos, line, sp, ep, cvt_ops);
a858 4
#endif
			if (plinepos != NULL)
				*plinepos = linepos;
			return (0);
d860 2
d866 29
a909 1
	int ucase;
d916 2
a917 1
		if (!prev_pattern())
d923 1
a923 1
		    (last_search_type & SRCH_NO_REGEX))
d953 1
a953 4
		ucase = is_ucase(pattern);
		if (caseless == OPT_ONPLUS)
			cvt_text(pattern, pattern, CVT_TO_LC);
		if (compile_pattern(pattern, search_type) < 0)
a954 9
		/*
		 * Ignore case if -I is set OR
		 * -i is set AND the pattern is all lowercase.
		 */
		is_ucase_pattern = ucase;
		if (is_ucase_pattern && caseless != OPT_ONPLUS)
			is_caseless = 0;
		else
			is_caseless = caseless;
d1052 1
d1059 1
a1059 1
	if (!prev_pattern())
d1072 1
a1072 1
			max_epos = forw_raw_line(max_epos, (char **)NULL);
d1090 1
d1152 3
a1154 1
		result = search_range(spos, epos, SRCH_FORW|SRCH_FIND_ALL, 0,
a1163 1
#endif
d1166 17
a1182 2
 * Simple pattern matching function.
 * It supports no metacharacters like *, etc.
d1184 6
a1189 22
	static int
match(pattern, buf, pfound, pend)
	char *pattern, *buf;
	char **pfound, **pend;
{
	register char *pp, *lp;

	for ( ;  *buf != '\0';  buf++)
	{
		for (pp = pattern, lp = buf;  *pp == *lp;  pp++, lp++)
			if (*pp == '\0' || *lp == '\0')
				break;
		if (*pp == '\0')
		{
			if (pfound != NULL)
				*pfound = buf;
			if (pend != NULL)
				*pend = lp;
			return (1);
		}
	}
	return (0);
d1191 1
@


1.4
log
@more strlcpy/strlcat/snprintf, less strcpy/strcat/sprintf
reviewed by tdeval, millert, dhartmei and others.  more bits coming here
from some of them i think
@
text
@a0 2
/*	$OpenBSD: search.c,v 1.3 2001/11/19 19:02:14 mpech Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d24 8
d45 1
a45 1
#if NO_REGEX
a46 1
#endif
d55 4
d63 2
d75 1
a75 1
static struct hilite hilite_anchor = { NULL };
d86 3
a97 3
#if NO_REGEX
static char *last_pattern = NULL;
#endif
d101 2
d109 2
d118 2
a119 2
	char *dst;
	char *src;
d121 1
a121 1
	for (src = osrc, dst = odst;  *src != '\0';  src++, dst++)
d123 1
a123 1
		if ((ops & CVT_TO_LC) && isupper(*src))
d125 1
a125 1
			*dst = tolower(*src);
d128 8
a135 2
			dst -= 2;
		else 
d137 1
a137 1
			*dst = *src;
d139 2
d145 24
d175 1
a175 1
	char *p;
d178 1
a178 1
		if (isupper(*p))
d189 2
d194 3
d225 3
a227 1
	extern int can_goto_line;
d263 42
d328 1
a328 1
compile_pattern(pattern)
d330 1
d332 2
d335 25
a359 10
	regex_t *s = (regex_t *) ecalloc(1, sizeof(regex_t));
	if (regcomp(s, pattern, 0))
	{
		free(s);
		error("Invalid pattern", NULL_PARG);
		return (-1);
	}
	if (regpattern != NULL)
		regfree(regpattern);
	regpattern = s;
d362 7
a368 7
	PARG parg;
	if ((parg.p_string = re_comp(pattern)) != NULL)
	{
		error("%s", &parg);
		return (-1);
	}
	re_pattern = 1;
d371 9
a379 9
	char *s;
	if ((s = regcmp(pattern, 0)) == NULL)
	{
		error("Invalid pattern", NULL_PARG);
		return (-1);
	}
	if (cpattern != NULL)
		free(cpattern);
	cpattern = s;
d382 13
a394 7
	struct regexp *s;
	if ((s = regcomp(pattern)) == NULL)
	{
		/*
		 * regcomp has already printed error message via regerror().
		 */
		return (-1);
d396 6
a401 9
	if (regpattern != NULL)
		free(regpattern);
	regpattern = s;
#endif
#if NO_REGEX
	static char lpbuf[100];
	strlcpy(lpbuf, pattern, sizeof lbuf);
	last_pattern = lpbuf;
#endif
d416 5
a433 1
#if NO_REGEX
a434 1
#endif
d442 1
a442 1
match_pattern(line, sp, ep)
d446 1
d449 4
d454 26
a479 6
	regmatch_t rm;
	matched = !regexec(regpattern, line, 1, &rm, 0);
	if (!matched)
		return (0);
	*sp = line + rm.rm_so;
	*ep = line + rm.rm_eo;
d496 3
d500 1
d543 9
d620 1
a620 1
adj_hilite(anchor, linepos)
d623 1
d665 18
d686 1
a686 1
		while (line[0] == '\b' && line[1] != '\0')
d688 10
a697 7
			/*
			 * Found a backspace.  The file position moves
			 * forward by 2 relative to the processed line
			 * which was searched in hilite_line.
			 */
			npos += 2;
			line += 2;
d708 1
a708 1
hilite_line(linepos, line, sp, ep)
d713 1
d727 3
a729 1
	 *    if, for example, the pattern starts with "^". }}
d760 8
a767 1
	} while (match_pattern(searchp, &sp, &ep));
a768 9
	if (bs_mode == BS_SPECIAL) 
	{
		/*
		 * If there were backspaces in the original line, they
		 * were removed, and hl_startpos/hl_endpos are not correct.
		 * {{ This is very ugly. }}
		 */
		adj_hilite(&hilites, linepos);
	}
d813 1
a813 1
	prep_hilite(scrpos.pos, position(BOTTOM_PLUS_ONE));
d890 1
d892 15
d915 1
a915 1
search_range(pos, endpos, search_type, n, plinepos, pendpos)
d919 2
a920 1
	int n;
d925 1
a925 1
	int linenum;
d928 1
d948 1
a948 1
		if (endpos != NULL_POSITION && pos >= endpos)
d955 1
a955 1
			return (n);
d957 2
d988 2
a989 2
				*pendpos = NULL_POSITION;
			return (n);
a1000 1
		{
d1002 1
a1002 2
			oldpos = pos;
		}
d1008 2
a1009 9
		if (is_caseless || bs_mode == BS_SPECIAL)
		{
			int ops = 0;
			if (is_caseless) 
				ops |= CVT_TO_LC;
			if (bs_mode == BS_SPECIAL)
				ops |= CVT_BS;
			cvt_text(line, line, ops);
		}
d1016 3
a1018 3
		line_match = match_pattern(line, &sp, &ep);
		line_match = (!(search_type & SRCH_NOMATCH) && line_match) ||
				((search_type & SRCH_NOMATCH) && !line_match);
d1033 1
a1033 1
				hilite_line(linepos, line, sp, ep);
d1035 1
a1035 1
		} else if (--n <= 0)
d1050 1
a1050 1
					hilite_line(linepos, line, sp, ep);
d1088 6
d1122 1
a1122 1
		if (compile_pattern(pattern) < 0)
d1166 1
d1171 1
a1171 1
	n = search_range(pos, NULL_POSITION, search_type, n, 
d1188 7
a1194 4
	/*
	 * Go to the matching line.
	 */
	jump_loc(pos, jump_sline);
d1206 1
d1212 1
a1212 1
 *  of the file that has been "prepared"; that is, scanned for matches for
d1219 1
a1219 1
prep_hilite(spos, epos)
d1222 1
d1226 4
d1238 14
d1260 1
a1260 1
	    (prep_endpos != NULL_POSITION && spos > prep_endpos))
a1269 1
		nprep_endpos = epos;
d1280 1
a1280 1
			nprep_endpos = NULL_POSITION;
a1287 1
			nprep_endpos = epos;
d1313 1
a1313 2
			 * Trim search to start near end of old prep region
			 * (actually, one linebuf before end of old range).
d1315 1
a1315 6
			if (prep_endpos == NULL_POSITION)
				return;
			else if (prep_endpos < size_linebuf)
				spos = 0;
			else 
				spos = prep_endpos - size_linebuf;
d1319 7
d1328 6
a1333 6
		if (search_range(spos, epos, SRCH_FORW|SRCH_FIND_ALL, 0,
				(POSITION*)NULL, &epos) >= 0)
		{
			if (epos == NULL_POSITION || epos > nprep_endpos)
				nprep_endpos = epos;
		}
a1339 1
#if NO_REGEX
d1341 1
a1341 2
 * We have no pattern matching function from the library.
 * We use this function to do simple pattern matching.
d1349 1
a1349 1
	char *pp, *lp;
a1366 1
#endif
a1380 18
}
#endif

#if !HAVE_STRCHR
/*
 * strchr is used by regexp.c.
 */
	char *
strchr(s, c)
	char *s;
	int c;
{
	for ( ;  *s != '\0';  s++)
		if (*s == c)
			return (s);
	if (c == '\0')
		return (s);
	return (NULL);
@


1.3
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.2 2001/01/29 01:58:04 niklas Exp $	*/
d298 1
a298 1
	strcpy(lpbuf, pattern);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d119 2
a120 2
	register char *dst;
	register char *src;
d144 1
a144 1
	register char *p;
d1146 1
a1146 1
	register char *pp, *lp;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
a39 8
#ifdef REG_EXTENDED
#define	REGCOMP_FLAG	REG_EXTENDED
#else
#define	REGCOMP_FLAG	0
#endif
#endif
#if HAVE_PCRE
#include <pcre.h>
d53 1
a53 1

d55 1
a63 4
extern int ctldisp;
extern int status_col;
extern POSITION start_attnpos;
extern POSITION end_attnpos;
a67 2
extern int squished;
extern int can_goto_line;
d78 1
a78 1
static struct hilite hilite_anchor = { NULL, NULL_POSITION, NULL_POSITION };
a88 3
#if HAVE_PCRE
pcre *regpattern = NULL;
#endif
d98 3
a103 2
static int last_search_type;
static char *last_pattern = NULL;
a109 2
#define	CVT_CRLF	04	/* Remove CR after LF */
#define	CVT_ANSI	010	/* Remove ANSI escape sequences */
d120 1
a120 1
	for (src = osrc, dst = odst;  *src != '\0';  src++)
d122 1
a122 1
		if ((ops & CVT_TO_LC) && isupper((unsigned char) *src))
d124 1
a124 1
			*dst++ = tolower((unsigned char) *src);
d127 2
a128 8
			dst--;
		else if ((ops & CVT_ANSI) && *src == ESC)
		{
			/* Skip to end of ANSI escape sequence. */
			while (src[1] != '\0')
				if (is_ansi_end(*++src))
					break;
		} else 
d130 1
a130 1
			*dst++ = *src;
a131 2
	if ((ops & CVT_CRLF) && dst > odst && dst[-1] == '\r')
		dst--;
a135 24
 * Determine which conversions to perform.
 */
	static int
get_cvt_ops()
{
	int ops = 0;
	if (is_caseless || bs_mode == BS_SPECIAL)
	{
		if (is_caseless) 
			ops |= CVT_TO_LC;
		if (bs_mode == BS_SPECIAL)
			ops |= CVT_BS;
		if (bs_mode != BS_CONTROL)
			ops |= CVT_CRLF;
	} else if (bs_mode != BS_CONTROL)
	{
		ops |= CVT_CRLF;
	}
	if (ctldisp == OPT_ONPLUS)
		ops |= CVT_ANSI;
	return (ops);
}

/*
d145 1
a145 1
		if (isupper((unsigned char) *p))
a155 2
	if (last_search_type & SRCH_NO_REGEX)
		return (last_pattern != NULL);
a158 3
#if HAVE_PCRE
	return (regpattern != NULL);
#endif
d187 1
a187 3

	if (squished)
		repaint();
a222 42

/*
 * Clear the attn hilite.
 */
	public void
clear_attn()
{
	int slinenum;
	POSITION old_start_attnpos;
	POSITION old_end_attnpos;
	POSITION pos;
	POSITION epos;

	if (start_attnpos == NULL_POSITION)
		return;
	old_start_attnpos = start_attnpos;
	old_end_attnpos = end_attnpos;
	start_attnpos = end_attnpos = NULL_POSITION;

	if (!can_goto_line)
	{
		repaint();
		return;
	}
	if (squished)
		repaint();

	for (slinenum = TOP;  slinenum < TOP + sc_height-1;  slinenum++)
	{
		pos = position(slinenum);
		if (pos == NULL_POSITION)
			continue;
		epos = position(slinenum+1);
		if (pos < old_end_attnpos &&
		     (epos == NULL_POSITION || epos > old_start_attnpos))
		{
			(void) forw_line(pos);
			goto_line(slinenum);
			put_line();
		}
	}
}
d246 1
a246 1
compile_pattern(pattern, search_type)
a247 1
	int search_type;
d249 3
a251 1
	if ((search_type & SRCH_NO_REGEX) == 0)
d253 7
a259 26
#if HAVE_POSIX_REGCOMP
		regex_t *s = (regex_t *) ecalloc(1, sizeof(regex_t));
		if (regcomp(s, pattern, REGCOMP_FLAG))
		{
			free(s);
			error("Invalid pattern", NULL_PARG);
			return (-1);
		}
		if (regpattern != NULL)
			regfree(regpattern);
		regpattern = s;
#endif
#if HAVE_PCRE
		pcre *comp;
		const char *errstring;
		int erroffset;
		PARG parg;
		comp = pcre_compile(pattern, 0,
				&errstring, &erroffset, NULL);
		if (comp == NULL)
		{
			parg.p_string = (char *) errstring;
			error("%s", &parg);
			return (-1);
		}
		regpattern = comp;
d262 7
a268 7
		PARG parg;
		if ((parg.p_string = re_comp(pattern)) != NULL)
		{
			error("%s", &parg);
			return (-1);
		}
		re_pattern = 1;
d271 9
a279 9
		char *s;
		if ((s = regcmp(pattern, 0)) == NULL)
		{
			error("Invalid pattern", NULL_PARG);
			return (-1);
		}
		if (cpattern != NULL)
			free(cpattern);
		cpattern = s;
d282 16
a297 12
		struct regexp *s;
		if ((s = regcomp(pattern)) == NULL)
		{
			/*
			 * regcomp has already printed an error message 
			 * via regerror().
			 */
			return (-1);
		}
		if (regpattern != NULL)
			free(regpattern);
		regpattern = s;
a298 9
	}

	if (last_pattern != NULL)
		free(last_pattern);
	last_pattern = (char *) calloc(1, strlen(pattern)+1);
	if (last_pattern != NULL)
		strcpy(last_pattern, pattern);

	last_search_type = search_type;
a312 5
#if HAVE_PCRE
	if (regpattern != NULL)
		pcre_free(regpattern);
	regpattern = NULL;
#endif
d326 1
d328 1
d336 1
a336 1
match_pattern(line, sp, ep, notbol)
a339 1
	int notbol;
a341 4

	if (last_search_type & SRCH_NO_REGEX)
		return (match(last_pattern, line, sp, ep));

d343 6
a348 26
	{
		regmatch_t rm;
		int flags = (notbol) ? REG_NOTBOL : 0;
		matched = !regexec(regpattern, line, 1, &rm, flags);
		if (!matched)
			return (0);
#ifndef __WATCOMC__
		*sp = line + rm.rm_so;
		*ep = line + rm.rm_eo;
#else
		*sp = rm.rm_sp;
		*ep = rm.rm_ep;
#endif
	}
#endif
#if HAVE_PCRE
	{
		int flags = (notbol) ? PCRE_NOTBOL : 0;
		int ovector[3];
		matched = pcre_exec(regpattern, NULL, line, strlen(line),
			0, flags, ovector, 3) >= 0;
		if (!matched)
			return (0);
		*sp = line + ovector[0];
		*ep = line + ovector[1];
	}
a364 3
#if HAVE_REGEXEC2
	matched = regexec2(regpattern, line, notbol);
#else
a365 1
#endif
a407 9
	if (!status_col &&
	    start_attnpos != NULL_POSITION && 
	    pos < end_attnpos &&
	     (epos == NULL_POSITION || epos > start_attnpos))
		/*
		 * The attn line overlaps this range.
		 */
		return (1);

d476 1
a476 1
adj_hilite(anchor, linepos, cvt_ops)
a478 1
	int cvt_ops;
a519 18
		if (cvt_ops & CVT_ANSI)
		{
			while (line[0] == ESC)
			{
				/*
				 * Found an ESC.  The file position moves
				 * forward past the entire ANSI escape sequence.
				 */
				line++;
				npos++;
				while (*line != '\0')
				{
					npos++;
					if (is_ansi_end(*line++))
						break;
				}
			}
		}
d523 1
a523 1
		if (cvt_ops & CVT_BS)
d525 7
a531 10
			while (line[0] == '\b' && line[1] != '\0')
			{
				/*
				 * Found a backspace.  The file position moves
				 * forward by 2 relative to the processed line
				 * which was searched in hilite_line.
				 */
				npos += 2;
				line += 2;
			}
d542 1
a542 1
hilite_line(linepos, line, sp, ep, cvt_ops)
a546 1
	int cvt_ops;
d560 1
a560 3
	 *    if the pattern starts with "^".  This bug is fixed
	 *    for those regex functions that accept a notbol parameter
	 *    (currently POSIX and V8-with-regexec2). }}
d591 1
a591 8
	} while (match_pattern(searchp, &sp, &ep, 1));

	/*
	 * If there were backspaces in the original line, they
	 * were removed, and hl_startpos/hl_endpos are not correct.
	 * {{ This is very ugly. }}
	 */
	adj_hilite(&hilites, linepos, cvt_ops);
d593 9
d646 1
a646 1
	prep_hilite(scrpos.pos, position(BOTTOM_PLUS_ONE), -1);
a722 1
		{
a723 15
			while (pos == NULL_POSITION)
			{
				if (++linenum >= sc_height)
					break;
				pos = position(linenum);
			}
		} else 
		{
			while (pos == NULL_POSITION)
			{
				if (--linenum < 0)
					break;
				pos = position(linenum);
			}
		}
d732 1
a732 1
search_range(pos, endpos, search_type, matches, maxlines, plinepos, pendpos)
d736 1
a736 2
	int matches;
	int maxlines;
d741 1
a741 1
	LINENUM linenum;
a743 1
	int cvt_ops;
d763 1
a763 1
		if ((endpos != NULL_POSITION && pos >= endpos) || maxlines == 0)
d770 1
a770 1
			return (matches);
a771 2
		if (maxlines > 0)
			maxlines--;
d801 2
a802 2
				*pendpos = oldpos;
			return (matches);
d814 1
d816 2
a817 1
		oldpos = pos;
d823 9
a831 2
		cvt_ops = get_cvt_ops();
		cvt_text(line, line, cvt_ops);
d838 3
a840 3
		line_match = match_pattern(line, &sp, &ep, 0);
		line_match = (!(search_type & SRCH_NO_MATCH) && line_match) ||
				((search_type & SRCH_NO_MATCH) && !line_match);
d855 1
a855 1
				hilite_line(linepos, line, sp, ep, cvt_ops);
d857 1
a857 1
		} else if (--matches <= 0)
d872 1
a872 1
					hilite_line(linepos, line, sp, ep, cvt_ops);
a909 6
		if ((search_type & SRCH_NO_REGEX) != 
		    (last_search_type & SRCH_NO_REGEX))
		{
			error("Please re-enter search pattern", NULL_PARG);
			return -1;
		}
d938 1
a938 1
		if (compile_pattern(pattern, search_type) < 0)
a981 1
		/* repaint(); -- why was this here? */
d986 1
a986 1
	n = search_range(pos, NULL_POSITION, search_type, n, -1,
d1003 4
a1006 7
	if (!(search_type & SRCH_NO_MOVE))
	{
		/*
		 * Go to the matching line.
		 */
		jump_loc(pos, jump_sline);
	}
a1017 1

d1023 1
a1023 1
 * of the file that has been "prepared"; that is, scanned for matches for
d1030 1
a1030 1
prep_hilite(spos, epos, maxlines)
a1032 1
	int maxlines;
a1035 4
	POSITION new_epos;
	POSITION max_epos;
	int result;
	int i;
a1043 14

	/*
	 * If we're limited to a max number of lines, figure out the
	 * file position we should stop at.
	 */
	if (maxlines < 0)
		max_epos = NULL_POSITION;
	else
	{
		max_epos = spos;
		for (i = 0;  i < maxlines;  i++)
			max_epos = forw_raw_line(max_epos, (char **)NULL);
	}

d1052 1
a1052 1
	    spos > prep_endpos)
d1062 1
d1073 1
a1073 1
			;
d1081 1
d1107 2
a1108 1
			 * Trim search to start at end of old prep region.
d1110 6
a1115 1
			spos = prep_endpos;
a1118 7
	if (epos != NULL_POSITION && max_epos != NULL_POSITION &&
	    epos > max_epos)
		/*
		 * Don't go past the max position we're allowed.
		 */
		epos = max_epos;

d1121 6
a1126 6
		result = search_range(spos, epos, SRCH_FORW|SRCH_FIND_ALL, 0,
				maxlines, (POSITION*)NULL, &new_epos);
		if (result < 0)
			return;
		if (prep_endpos == NULL_POSITION || new_epos > prep_endpos)
			nprep_endpos = new_epos;
d1133 1
d1135 2
a1136 1
 * Simple pattern matching function.
d1162 1
d1177 18
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
a16 1
#include "pattern.h"
a17 1
#include "charset.h"
d22 26
a56 1
extern void * constant ml_search;
a58 2
extern int utf_mode;
extern int screen_trashed;
d61 1
a67 2
static int is_caseless;
static int is_ucase_pattern;
a75 1
static struct hilite filter_anchor = { NULL, NULL_POSITION, NULL_POSITION };
d81 1
a81 1
 * search pattern and filter pattern.
d83 15
a97 8
struct pattern_info {
	DEFINE_PATTERN(compiled);
	char* text;
	int search_type;
};
	
static struct pattern_info search_info;
static struct pattern_info filter_info;
d99 4
a102 18
/*
 * Are there any uppercase letters in this string?
 */
	static int
is_ucase(str)
	char *str;
{
	char *str_end = str + strlen(str);
	LWCHAR ch;

	while (str < str_end)
	{
		ch = step_char(&str, +1, str_end);
		if (IS_UPPER(ch))
			return (1);
	}
	return (0);
}
d105 1
a105 1
 * Compile and save a search pattern.
d107 4
a110 20
	static int
set_pattern(info, pattern, search_type)
	struct pattern_info *info;
	char *pattern;
	int search_type;
{
	if (pattern == NULL)
		CLEAR_PATTERN(search_info.compiled);
	else if (compile_pattern(pattern, search_type, &info->compiled) < 0)
		return -1;
	/* Pattern compiled successfully; save the text too. */
	if (info->text != NULL)
		free(info->text);
	info->text = NULL;
	if (pattern != NULL)
	{
		info->text = (char *) ecalloc(1, strlen(pattern)+1);
		strcpy(info->text, pattern);
	}
	info->search_type = search_type;
a111 15
	/*
	 * Ignore case if -I is set OR
	 * -i is set AND the pattern is all lowercase.
	 */
	is_ucase_pattern = is_ucase(pattern);
	if (is_ucase_pattern && caseless != OPT_ONPLUS)
		is_caseless = 0;
	else
		is_caseless = caseless;
	return 0;
}

/*
 * Discard a saved pattern.
 */
d113 29
a141 7
clear_pattern(info)
	struct pattern_info *info;
{
	if (info->text != NULL)
		free(info->text);
	info->text = NULL;
	uncompile_pattern(&info->compiled);
d145 1
a145 23
 * Initialize saved pattern to nothing.
 */
	static void
init_pattern(info)
	struct pattern_info *info;
{
	CLEAR_PATTERN(info->compiled);
	info->text = NULL;
	info->search_type = 0;
}

/*
 * Initialize search variables.
 */
	public void
init_search()
{
	init_pattern(&search_info);
	init_pattern(&filter_info);
}

/*
 * Determine which text conversions to perform before pattern matching.
d169 15
d187 1
a187 2
prev_pattern(info)
	struct pattern_info *info;
d189 20
a208 3
	if (info->search_type & SRCH_NO_REGEX)
		return (info->text != NULL);
	return (!is_null_pattern(info->compiled));
d250 10
a259 3
		(void) forw_line(pos);
		goto_line(slinenum);
		put_line();
a260 1
	lower_left();
a274 1
	int moved = 0;
a301 1
			moved = 1;
a303 2
	if (moved)
		lower_left();
d313 1
a313 1
	if (!prev_pattern(&search_info))
a323 1
#if HILITE_SEARCH
d325 1
a325 1
 * Clear the hilite list.
d327 4
a330 3
	public void
clr_hlist(anchor)
	struct hilite *anchor;
d332 1
a332 4
	struct hilite *hl;
	struct hilite *nexthl;

	for (hl = anchor->hl_first;  hl != NULL;  hl = nexthl)
d334 61
a394 2
		nexthl = hl->hl_next;
		free((void*)hl);
a395 3
	anchor->hl_first = NULL;
	prep_startpos = prep_endpos = NULL_POSITION;
}
d397 8
a404 4
	public void
clr_hilite()
{
	clr_hlist(&hilite_anchor);
d407 5
a411 2
	public void
clr_filter()
d413 24
a436 1
	clr_hlist(&filter_anchor);
d440 2
a441 1
 * Should any characters in a specified range be highlighted?
d444 41
a484 6
is_hilited_range(pos, epos)
	POSITION pos;
	POSITION epos;
{
	struct hilite *hl;

d486 1
a486 1
	 * Look at each highlight and see if any part of it falls in the range.
d488 24
a511 7
	for (hl = hilite_anchor.hl_first;  hl != NULL;  hl = hl->hl_next)
	{
		if (hl->hl_endpos > pos &&
		    (epos == NULL_POSITION || epos > hl->hl_startpos))
			return (1);
	}
	return (0);
d514 3
a516 2
/* 
 * Is a line "filtered" -- that is, should it be hidden?
d518 2
a519 3
	public int
is_filtered(pos)
	POSITION pos;
d522 1
d524 1
a524 8
	if (ch_getflags() & CH_HELPFILE)
		return (0);

	/*
	 * Look at each filter and see if the start position
	 * equals the start position of the line.
	 */
	for (hl = filter_anchor.hl_first;  hl != NULL;  hl = hl->hl_next)
d526 2
a527 2
		if (hl->hl_startpos == pos)
			return (1);
d529 2
a530 1
	return (0);
d538 1
a538 1
is_hilited(pos, epos, nohide, p_matches)
a541 1
	int *p_matches;
d543 1
a543 4
	int match;

	if (p_matches != NULL)
		*p_matches = 0;
a553 10
	match = is_hilited_range(pos, epos);
	if (!match)
		return (0);

	if (p_matches != NULL)
		/*
		 * Report matches, even if we're hiding highlights.
		 */
		*p_matches = 1;

d566 10
a575 1
	return (1);
d619 86
d710 1
a710 1
hilite_line(linepos, line, line_len, chpos, sp, ep, cvt_ops)
a712 2
	int line_len;
	int *chpos;
a717 1
	char *line_end = line + line_len;
d719 1
d731 1
a731 1
	 *    (currently POSIX, PCRE and V8-with-regexec2). }}
d734 4
d741 5
d747 3
a749 3
			hl->hl_startpos = linepos + chpos[sp-line];
			hl->hl_endpos = linepos + chpos[ep-line];
			add_hilite(&hilite_anchor, hl);
d758 1
a758 1
		else if (searchp != line_end)
d762 17
a778 2
	} while (match_pattern(search_info.compiled, search_info.text,
			searchp, line_end - searchp, &sp, &ep, 1, search_info.search_type));
d800 1
a800 1
		clear_pattern(&search_info);
d860 1
a860 1
			pos = ch_zero();
d869 1
d871 2
a872 2
		linenum = 0;
	} else 
d874 18
a891 3
		int add_one = 0;

		if (how_search == OPT_ON)
d893 7
a899 16
			/*
			 * Search does not include current screen.
			 */
			if (search_type & SRCH_FORW)
				linenum = BOTTOM_PLUS_ONE;
			else
				linenum = TOP;
		} else if (how_search == OPT_ONPLUS && !(search_type & SRCH_AFTER_TARGET))
		{
			/*
			 * Search includes all of displayed screen.
			 */
			if (search_type & SRCH_FORW)
				linenum = TOP;
			else
				linenum = BOTTOM_PLUS_ONE;
d902 6
a907 8
			/*
			 * Search includes the part of current screen beyond the jump target.
			 * It starts at the jump target (if searching backwards),
			 * or at the jump target plus one (if forwards).
			 */
			linenum = jump_sline;
			if (search_type & SRCH_FORW) 
			    add_one = 1;
a908 25
		linenum = adjsline(linenum);
		pos = position(linenum);
		if (add_one)
			pos = forw_raw_line(pos, (char **)NULL, (int *)NULL);
	}

	/*
	 * If the line is empty, look around for a plausible starting place.
	 */
	if (search_type & SRCH_FORW) 
	{
	    while (pos == NULL_POSITION)
	    {
	        if (++linenum >= sc_height)
	            break;
	        pos = position(linenum);
	    }
	} else 
	{
	    while (pos == NULL_POSITION)
	    {
	        if (--linenum < 0)
	            break;
	        pos = position(linenum);
	    }
a926 2
	char *cline;
	int line_len;
a930 2
	int cvt_len;
	int *chpos;
d969 1
a969 1
			pos = forw_raw_line(pos, &line, &line_len);
d978 1
a978 1
			pos = back_raw_line(pos, &line, &line_len);
d1002 1
a1002 1
		if (linenums && abs((int)(pos - oldpos)) > 2048)
a1005 3
		if (is_filtered(linepos))
			continue;

d1011 1
a1011 23
		cvt_len = cvt_length(line_len, cvt_ops);
		cline = (char *) ecalloc(1, cvt_len);
		chpos = cvt_alloc_chpos(cvt_len);
		cvt_text(cline, line, chpos, &line_len, cvt_ops);

#if HILITE_SEARCH
		/*
		 * Check to see if the line matches the filter pattern.
		 * If so, add an entry to the filter list.
		 */
		if ((search_type & SRCH_FIND_ALL) && prev_pattern(&filter_info)) {
			int line_filter = match_pattern(filter_info.compiled, filter_info.text,
				cline, line_len, &sp, &ep, 0, filter_info.search_type);
			if (line_filter)
			{
				struct hilite *hl = (struct hilite *)
					ecalloc(1, sizeof(struct hilite));
				hl->hl_startpos = linepos;
				hl->hl_endpos = pos;
				add_hilite(&filter_anchor, hl);
			}
		}
#endif
d1018 9
a1026 1
		if (prev_pattern(&search_info))
d1028 6
a1033 2
			line_match = match_pattern(search_info.compiled, search_info.text,
				cline, line_len, &sp, &ep, 0, search_type);
d1035 10
d1047 2
a1048 1
				 * Got a match.
d1050 4
a1053 9
				if (search_type & SRCH_FIND_ALL)
				{
#if HILITE_SEARCH
					/*
					 * We are supposed to find all matches in the range.
					 * Just add the matches in this line to the 
					 * hilite list and keep searching.
					 */
					hilite_line(linepos, cline, line_len, chpos, sp, ep, cvt_ops);
d1055 3
a1057 24
				} else if (--matches <= 0)
				{
					/*
					 * Found the one match we're looking for.
					 * Return it.
					 */
#if HILITE_SEARCH
					if (hilite_search == OPT_ON)
					{
						/*
						 * Clear the hilite list and add only
						 * the matches in this one line.
						 */
						clr_hilite();
						hilite_line(linepos, cline, line_len, chpos, sp, ep, cvt_ops);
					}
#endif
					free(cline);
					free(chpos);
					if (plinepos != NULL)
						*plinepos = linepos;
					return (0);
				}
			}
a1058 2
		free(cline);
		free(chpos);
a1062 29
 * search for a pattern in history. If found, compile that pattern.
 */
	static int 
hist_pattern(search_type) 
	int search_type;
{
#if CMD_HISTORY
	char *pattern;

	set_mlist(ml_search, 0);
	pattern = cmd_lastpattern();
	if (pattern == NULL)
		return (0);

	if (set_pattern(&search_info, pattern, search_type) < 0)
		return (0);

#if HILITE_SEARCH
	if (hilite_search == OPT_ONPLUS && !hide_hilite)
		hilite_screen();
#endif

	return (1);
#else /* CMD_HISTORY */
	return (0);
#endif /* CMD_HISTORY */
}

/*
d1078 1
d1085 1
a1085 2
		search_type |= SRCH_AFTER_TARGET;
		if (!prev_pattern(&search_info) && !hist_pattern(search_type))
d1091 1
a1091 1
		      (search_info.search_type & SRCH_NO_REGEX))
d1121 4
a1124 1
		if (set_pattern(&search_info, pattern, search_type) < 0)
d1126 9
a1231 1

d1238 1
a1238 1
	if (!prev_pattern(&search_info) && !is_filtering())
d1251 1
a1251 1
			max_epos = forw_raw_line(max_epos, (char **)NULL, (int *)NULL);
a1268 1
		clr_filter();
d1330 1
a1330 3
		int search_type = SRCH_FORW | SRCH_FIND_ALL;
		search_type |= (search_info.search_type & SRCH_NO_REGEX);
		result = search_range(spos, epos, search_type, 0,
d1340 1
d1343 2
a1344 1
 * Set the pattern to be used for line filtering.
d1346 22
a1367 22
	public void
set_filter_pattern(pattern, search_type)
	char *pattern;
	int search_type;
{
	clr_filter();
	if (pattern == NULL || *pattern == '\0')
		clear_pattern(&filter_info);
	else
		set_pattern(&filter_info, pattern, search_type);
	screen_trashed = 1;
}

/*
 * Is there a line filter in effect?
 */
	public int
is_filtering()
{
	if (ch_getflags() & CH_HELPFILE)
		return (0);
	return prev_pattern(&filter_info);
a1368 1
#endif
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d24 1
a24 1
extern volatile sig_atomic_t sigs;
a68 6

#if NO_REGEX
#define info_compiled(info) ((void*)0)
#else
#define info_compiled(info) ((info)->compiled)
#endif
a100 1
#if !NO_REGEX
d102 1
a102 1
		CLEAR_PATTERN(info->compiled);
a104 1
#endif
d110 4
a113 1
		info->text = save(pattern);
a137 1
#if !NO_REGEX
a138 1
#endif
d194 3
a196 5
#if !NO_REGEX
	if ((info->search_type & SRCH_NO_REGEX) == 0)
		return (!is_null_pattern(info->compiled));
#endif
	return (info->text != NULL);
a478 41
 * Hilight every character in a range of displayed characters.
 */
	static void
create_hilites(linepos, start_index, end_index, chpos)
	POSITION linepos;
	int start_index;
	int end_index;
	int *chpos;
{
	struct hilite *hl;
	int i;

	/* Start the first hilite. */
	hl = (struct hilite *) ecalloc(1, sizeof(struct hilite));
	hl->hl_startpos = linepos + chpos[start_index];

	/*
	 * Step through the displayed chars.
	 * If the source position (before cvt) of the char is one more
	 * than the source pos of the previous char (the usual case),
	 * just increase the size of the current hilite by one.
	 * Otherwise (there are backspaces or something involved),
	 * finish the current hilite and start a new one.
	 */
	for (i = start_index+1;  i <= end_index;  i++)
	{
		if (chpos[i] != chpos[i-1] + 1 || i == end_index)
		{
			hl->hl_endpos = linepos + chpos[i-1] + 1;
			add_hilite(&hilite_anchor, hl);
			/* Start new hilite unless this is the last char. */
			if (i < end_index)
			{
				hl = (struct hilite *) ecalloc(1, sizeof(struct hilite));
				hl->hl_startpos = linepos + chpos[i];
			}
		}
	}
}

/*
d495 1
d511 7
a517 1
		create_hilites(linepos, sp-line, ep-line, chpos);
d529 1
a529 1
	} while (match_pattern(info_compiled(&search_info), search_info.text,
d801 1
a801 1
			int line_filter = match_pattern(info_compiled(&filter_info), filter_info.text,
d821 1
a821 1
			line_match = match_pattern(info_compiled(&search_info), search_info.text,
@


