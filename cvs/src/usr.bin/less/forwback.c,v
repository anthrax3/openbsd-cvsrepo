head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.10
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.8
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.8.0.12
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.8
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.6
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.4
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.6.0.34
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.32
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.30
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.26
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.28
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.24
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.22
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.20
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.18
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	OpenBSD_1_2:1.2
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.10;
commitid	QKrr6AuGzNx9nehL;

1.10
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.9;
commitid	yKv9Ck9ZDgwWTRTo;

1.9
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.8;

1.8
date	2011.09.21.19.01.49;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.14.14.33.57;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.13.18.26.25;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.01.58.01;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.09.21.06.06.39;	author etheisen;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.04;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.47;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Primitives for displaying the file on the screen,
 * scrolling either forward or backward.
 */

#include "less.h"
#include "position.h"

int screen_trashed;
int squished;
int no_back_scroll = 0;
int forw_prompt;

extern volatile sig_atomic_t sigs;
extern int top_scroll;
extern int quiet;
extern int sc_width, sc_height;
extern int plusoption;
extern int forw_scroll;
extern int back_scroll;
extern int ignore_eoi;
extern int clear_bg;
extern int final_attr;
extern int oldbot;
extern char *tagoption;

/*
 * Sound the bell to indicate user is trying to move past end of file.
 */
static void
eof_bell(void)
{
	if (quiet == NOT_QUIET)
		ring_bell();
	else
		vbell();
}

/*
 * Check to see if the end of file is currently displayed.
 */
int
eof_displayed(void)
{
	off_t pos;

	if (ignore_eoi)
		return (0);

	if (ch_length() == -1)
		/*
		 * If the file length is not known,
		 * we can't possibly be displaying EOF.
		 */
		return (0);

	/*
	 * If the bottom line is empty, we are at EOF.
	 * If the bottom line ends at the file length,
	 * we must be just at EOF.
	 */
	pos = position(BOTTOM_PLUS_ONE);
	return (pos == -1 || pos == ch_length());
}

/*
 * Check to see if the entire file is currently displayed.
 */
int
entire_file_displayed(void)
{
	off_t pos;

	/* Make sure last line of file is displayed. */
	if (!eof_displayed())
		return (0);

	/* Make sure first line of file is displayed. */
	pos = position(0);
	return (pos == -1 || pos == 0);
}

/*
 * If the screen is "squished", repaint it.
 * "Squished" means the first displayed line is not at the top
 * of the screen; this can happen when we display a short file
 * for the first time.
 */
void
squish_check(void)
{
	if (!squished)
		return;
	squished = 0;
	repaint();
}

/*
 * Display n lines, scrolling forward,
 * starting at position pos in the input file.
 * "force" means display the n lines even if we hit end of file.
 * "only_last" means display only the last screenful if n > screen size.
 * "nblank" is the number of blank lines to draw before the first
 *   real line.  If nblank > 0, the pos must be -1.
 *   The first real line after the blanks will start at ch_zero().
 */
void
forw(int n, off_t pos, int force, int only_last, int nblank)
{
	int nlines = 0;
	int do_repaint;
	static int first_time = 1;

	squish_check();

	/*
	 * do_repaint tells us not to display anything till the end,
	 * then just repaint the entire screen.
	 * We repaint if we are supposed to display only the last
	 * screenful and the request is for more than a screenful.
	 * Also if the request exceeds the forward scroll limit
	 * (but not if the request is for exactly a screenful, since
	 * repainting itself involves scrolling forward a screenful).
	 */
	do_repaint = (only_last && n > sc_height-1) ||
	    (forw_scroll >= 0 && n > forw_scroll && n != sc_height-1);

	if (!do_repaint) {
		if (top_scroll && n >= sc_height - 1 && pos != ch_length()) {
			/*
			 * Start a new screen.
			 * {{ This is not really desirable if we happen
			 *    to hit eof in the middle of this screen,
			 *    but we don't yet know if that will happen. }}
			 */
			pos_clear();
			add_forw_pos(pos);
			force = 1;
			do_clear();
			home();
		}

		if (pos != position(BOTTOM_PLUS_ONE) || empty_screen()) {
			/*
			 * This is not contiguous with what is
			 * currently displayed.  Clear the screen image
			 * (position table) and start a new screen.
			 */
			pos_clear();
			add_forw_pos(pos);
			force = 1;
			if (top_scroll) {
				do_clear();
				home();
			} else if (!first_time) {
				putstr("...skipping...\n");
			}
		}
	}

	while (--n >= 0) {
		/*
		 * Read the next line of input.
		 */
		if (nblank > 0) {
			/*
			 * Still drawing blanks; don't get a line
			 * from the file yet.
			 * If this is the last blank line, get ready to
			 * read a line starting at ch_zero() next time.
			 */
			if (--nblank == 0)
				pos = ch_zero();
		} else {
			/*
			 * Get the next line from the file.
			 */
			pos = forw_line(pos);
			if (pos == -1) {
				/*
				 * End of file: stop here unless the top line
				 * is still empty, or "force" is true.
				 * Even if force is true, stop when the last
				 * line in the file reaches the top of screen.
				 */
				if (!force && position(TOP) != -1)
					break;
				if (!empty_lines(0, 0) &&
				    !empty_lines(1, 1) &&
				    empty_lines(2, sc_height-1))
					break;
			}
		}
		/*
		 * Add the position of the next line to the position table.
		 * Display the current line on the screen.
		 */
		add_forw_pos(pos);
		nlines++;
		if (do_repaint)
			continue;
		/*
		 * If this is the first screen displayed and
		 * we hit an early EOF (i.e. before the requested
		 * number of lines), we "squish" the display down
		 * at the bottom of the screen.
		 * But don't do this if a + option or a -t option
		 * was given.  These options can cause us to
		 * start the display after the beginning of the file,
		 * and it is not appropriate to squish in that case.
		 */
		if (first_time && pos == -1 && !top_scroll &&
		    tagoption == NULL && !plusoption) {
			squished = 1;
			continue;
		}
		put_line();
		forw_prompt = 1;
	}

	if (nlines == 0)
		eof_bell();
	else if (do_repaint)
		repaint();
	first_time = 0;
	(void) currline(BOTTOM);
}

/*
 * Display n lines, scrolling backward.
 */
void
back(int n, off_t pos, int force, int only_last)
{
	int nlines = 0;
	int do_repaint;

	squish_check();
	do_repaint = (n > get_back_scroll() || (only_last && n > sc_height-1));
	while (--n >= 0) {
		/*
		 * Get the previous line of input.
		 */
		pos = back_line(pos);
		if (pos == -1) {
			/*
			 * Beginning of file: stop here unless "force" is true.
			 */
			if (!force)
				break;
		}
		/*
		 * Add the position of the previous line to the position table.
		 * Display the line on the screen.
		 */
		add_back_pos(pos);
		nlines++;
		if (!do_repaint) {
			home();
			add_line();
			put_line();
		}
	}

	if (nlines == 0)
		eof_bell();
	else if (do_repaint)
		repaint();
	else if (!oldbot)
		lower_left();
	(void) currline(BOTTOM);
}

/*
 * Display n more lines, forward.
 * Start just after the line currently displayed at the bottom of the screen.
 */
void
forward(int n, int force, int only_last)
{
	off_t pos;

	if (get_quit_at_eof() && eof_displayed() &&
	    !(ch_getflags() & CH_HELPFILE)) {
		/*
		 * If the -e flag is set and we're trying to go
		 * forward from end-of-file, go on to the next file.
		 */
		if (edit_next(1))
			quit(QUIT_OK);
		return;
	}

	pos = position(BOTTOM_PLUS_ONE);
	if (pos == -1 && (!force || empty_lines(2, sc_height-1))) {
		if (ignore_eoi) {
			/*
			 * ignore_eoi is to support A_F_FOREVER.
			 * Back up until there is a line at the bottom
			 * of the screen.
			 */
			if (empty_screen()) {
				pos = ch_zero();
			} else {
				do {
					back(1, position(TOP), 1, 0);
					pos = position(BOTTOM_PLUS_ONE);
				} while (pos == -1);
			}
		} else {
			eof_bell();
			return;
		}
	}
	forw(n, pos, force, only_last, 0);
}

/*
 * Display n more lines, backward.
 * Start just before the line currently displayed at the top of the screen.
 */
void
backward(int n, int force, int only_last)
{
	off_t pos;

	pos = position(TOP);
	if (pos == -1 && (!force || position(BOTTOM) == 0)) {
		eof_bell();
		return;
	}
	back(n, pos, force, only_last);
}

/*
 * Get the backwards scroll limit.
 * Must call this function instead of just using the value of
 * back_scroll, because the default case depends on sc_height and
 * top_scroll, as well as back_scroll.
 */
int
get_back_scroll(void)
{
	if (no_back_scroll)
		return (0);
	if (back_scroll >= 0)
		return (back_scroll);
	if (top_scroll)
		return (sc_height - 2);
	return (10000); /* infinity */
}
@


1.10
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.9
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

d22 4
a25 4
public int screen_trashed;
public int squished;
public int no_back_scroll = 0;
public int forw_prompt;
a37 1
#if TAGS
a38 1
#endif
d43 2
a44 2
	static void
eof_bell()
d47 1
a47 1
		bell();
d55 2
a56 2
	public int
eof_displayed()
d58 1
a58 1
	POSITION pos;
d63 1
a63 1
	if (ch_length() == NULL_POSITION)
d76 1
a76 1
	return (pos == NULL_POSITION || pos == ch_length());
d82 2
a83 2
	public int
entire_file_displayed()
d85 1
a85 1
	POSITION pos;
d93 1
a93 1
	return (pos == NULL_POSITION || pos == 0);
d102 2
a103 2
	public void
squish_check()
d112 1
a112 1
 * Display n lines, scrolling forward, 
d117 1
a117 1
 *   real line.  If nblank > 0, the pos must be NULL_POSITION.
d120 2
a121 7
	public void
forw(n, pos, force, only_last, nblank)
	register int n;
	POSITION pos;
	int force;
	int only_last;
	int nblank;
a122 1
	int eof = 0;
d130 1
a130 1
	 * do_repaint tells us not to display anything till the end, 
d132 1
a132 1
	 * We repaint if we are supposed to display only the last 
d138 2
a139 2
	do_repaint = (only_last && n > sc_height-1) || 
		(forw_scroll >= 0 && n > forw_scroll && n != sc_height-1);
d141 2
a142 4
	if (!do_repaint)
	{
		if (top_scroll && n >= sc_height - 1 && pos != ch_length())
		{
d152 1
a152 1
			clear();
d156 1
a156 2
		if (pos != position(BOTTOM_PLUS_ONE) || empty_screen())
		{
d159 1
a159 1
			 * currently displayed.  Clear the screen image 
d165 2
a166 3
			if (top_scroll)
			{
				clear();
d168 1
a168 2
			} else if (!first_time)
			{
d174 1
a174 2
	while (--n >= 0)
	{
d178 1
a178 2
		if (nblank > 0)
		{
d180 1
a180 1
			 * Still drawing blanks; don't get a line 
d187 2
a188 3
		} else
		{
			/* 
d192 1
a192 2
			if (pos == NULL_POSITION)
			{
d194 1
a194 1
				 * End of file: stop here unless the top line 
d199 1
a199 2
				eof = 1;
				if (!force && position(TOP) != NULL_POSITION)
d201 1
a201 1
				if (!empty_lines(0, 0) && 
d203 1
a203 1
				     empty_lines(2, sc_height-1))
d225 2
a226 6
		if (first_time && pos == NULL_POSITION && !top_scroll && 
#if TAGS
		    tagoption == NULL &&
#endif
		    !plusoption)
		{
a230 21
#if 0
		/* {{ 
		 * Can't call clear_eol here.  The cursor might be at end of line
		 * on an ignaw terminal, so clear_eol would clear the last char
		 * of the current line instead of all of the next line.
		 * If we really need to do this on clear_bg terminals, we need
		 * to find a better way.
		 * }}
		 */
		if (clear_bg && apply_at_specials(final_attr) != AT_NORMAL)
		{
			/*
			 * Writing the last character on the last line
			 * of the display may have scrolled the screen.
			 * If we were in standout mode, clear_bg terminals 
			 * will fill the new line with the standout color.
			 * Now we're in normal mode again, so clear the line.
			 */
			clear_eol();
		}
#endif
d245 2
a246 6
	public void
back(n, pos, force, only_last)
	register int n;
	POSITION pos;
	int force;
	int only_last;
d253 1
a253 2
	while (--n >= 0)
	{
d258 1
a258 2
		if (pos == NULL_POSITION)
		{
d271 1
a271 2
		if (!do_repaint)
		{
d291 2
a292 5
	public void
forward(n, force, only_last)
	int n;
	int force;
	int only_last;
d294 1
a294 1
	POSITION pos;
d296 2
a297 2
	if (get_quit_at_eof() && eof_displayed() && !(ch_getflags() & CH_HELPFILE))
	{
d308 2
a309 4
	if (pos == NULL_POSITION && (!force || empty_lines(2, sc_height-1)))
	{
		if (ignore_eoi)
		{
d315 1
a315 1
			if (empty_screen())
d317 2
a318 4
			else
			{
				do
				{
d321 1
a321 1
				} while (pos == NULL_POSITION);
d323 1
a323 2
		} else
		{
d335 2
a336 5
	public void
backward(n, force, only_last)
	int n;
	int force;
	int only_last;
d338 1
a338 1
	POSITION pos;
d341 1
a341 2
	if (pos == NULL_POSITION && (!force || position(BOTTOM) == 0))
	{
d343 1
a343 1
		return;   
d354 2
a355 2
	public int
get_back_scroll()
@


1.8
log
@Use volatile sig_atomic_t, not int, for the sigs variable.  Also
move the call to bell() out of u_interrupt() (a signal handler).
OK and with help from deraadt@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
@


1.7
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d25 1
a25 1
extern int sigs;
@


1.6
log
@o go back to using a help file instead of embedding it in the binary
o deal with HELPFILE not being defined
o add a SMALL definition to make a smaller less for the boot floppies
This still needs to be pared down a bit for the SMALL case
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
a19 1
public int hit_eof;	/* Keeps track of how many times we hit end of file */
d23 1
a28 1
extern int quit_at_eof;
d35 1
d53 1
a53 1
 * Check to see if the end of file is currently "displayed".
d55 2
a56 2
	static void
eof_check()
d61 9
a69 3
		return;
	if (ABORT_SIGS())
		return;
d76 18
a93 2
	if (pos == NULL_POSITION || pos == ch_length())
		hit_eof++;
d102 1
a102 1
	static void
a148 7
		/*
		 * Forget any current line shift we might have
		 * (from the last line of the previous screenful).
		 */
		extern int cshift;
		cshift = 0;

d160 1
a160 2
			if (top_scroll == OPT_ONPLUS || first_time)
				clear();
a161 3
		} else
		{
			clear_bot();
d176 1
a176 2
				if (top_scroll == OPT_ONPLUS)
					clear();
a249 2
		if (top_scroll == OPT_ON)
			clear_eol();
d251 10
a260 1
		if (clear_bg && final_attr != AT_NORMAL)
d271 2
a274 6
	if (ignore_eoi)
		hit_eof = 0;
	else if (eof && !ABORT_SIGS())
		hit_eof++;
	else
		eof_check();
a297 1
	hit_eof = 0;
a325 1
	eof_check();
d330 2
d347 1
a347 1
	if (quit_at_eof && hit_eof)
a380 1
			hit_eof++;
@


1.5
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d334 1
a334 1
	if (quit_at_eof && hit_eof && !(ch_getflags() & CH_HELPFILE))
@


1.4
log
@kill more registers

millert@@ ok
@
text
@a0 2
/*	$OpenBSD: forwback.c,v 1.3 2001/01/29 01:58:01 niklas Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d23 1
a29 1
extern int less_mode;
a32 1
extern int need_clr;
d34 2
d100 1
a100 1
	int n;
d127 7
d142 3
a147 1
			force = 1;
d201 2
d207 4
d240 1
a240 1
		if (top_scroll == 1)
d243 11
d275 1
a275 1
	int n;
d334 1
a334 1
	if (quit_at_eof && hit_eof)
d365 2
a366 1
		} else {
d405 2
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d117 1
a117 1
	register int n;
d266 1
a266 1
	register int n;
@


1.2
log
@Incorporate less modifications for more and our bug fixes from previous
version.
@
text
@d1 2
@


1.1
log
@Initial revision
@
text
@d45 1
d354 1
a354 2
		} else
		{
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
a38 1
public int no_back_scroll = 0;
d48 1
a49 2
extern int clear_bg;
extern int final_attr;
a140 7
		/*
		 * Forget any current line shift we might have
		 * (from the last line of the previous screenful).
		 */
		extern int cshift;
		cshift = 0;

a148 3
			pos_clear();
			add_forw_pos(pos);
			force = 1;
d152 1
a205 2
				 * Even if force is true, stop when the last
				 * line in the file reaches the top of screen.
a209 4
				if (!empty_lines(0, 0) && 
				    !empty_lines(1, 1) &&
				     empty_lines(2, sc_height-1))
					break;
d239 1
a239 1
		if (top_scroll == OPT_ON)
a241 11
		if (clear_bg && final_attr != AT_NORMAL)
		{
			/*
			 * Writing the last character on the last line
			 * of the display may have scrolled the screen.
			 * If we were in standout mode, clear_bg terminals 
			 * will fill the new line with the standout color.
			 * Now we're in normal mode again, so clear the line.
			 */
			clear_eol();
		}
d322 1
a322 1
	if (quit_at_eof && hit_eof && !(ch_getflags() & CH_HELPFILE))
a392 2
	if (no_back_scroll)
		return (0);
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d20 1
a23 1
public int forw_prompt;
d29 1
a35 1
extern int oldbot;
d53 1
a53 1
 * Check to see if the end of file is currently displayed.
d55 2
a56 2
	public int
eof_displayed()
d61 3
a63 9
		return (0);

	if (ch_length() == NULL_POSITION)
		/*
		 * If the file length is not known,
		 * we can't possibly be displaying EOF.
		 */
		return (0);

d70 2
a71 18
	return (pos == NULL_POSITION || pos == ch_length());
}

/*
 * Check to see if the entire file is currently displayed.
 */
	public int
entire_file_displayed()
{
	POSITION pos;

	/* Make sure last line of file is displayed. */
	if (!eof_displayed())
		return (0);

	/* Make sure first line of file is displayed. */
	pos = position(0);
	return (pos == NULL_POSITION || pos == 0);
d80 1
a80 1
	public void
d127 7
d145 2
a146 1
			clear();
d148 3
d165 2
a166 1
				clear();
d240 2
d243 1
a243 10
#if 0
		/* {{ 
		 * Can't call clear_eol here.  The cursor might be at end of line
		 * on an ignaw terminal, so clear_eol would clear the last char
		 * of the current line instead of all of the next line.
		 * If we really need to do this on clear_bg terminals, we need
		 * to find a better way.
		 * }}
		 */
		if (clear_bg && apply_at_specials(final_attr) != AT_NORMAL)
a253 2
#endif
		forw_prompt = 1;
d256 6
d285 1
d314 1
a318 2
	else if (!oldbot)
		lower_left();
d334 1
a334 1
	if (get_quit_at_eof() && eof_displayed() && !(ch_getflags() & CH_HELPFILE))
d368 1
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d25 1
a25 1
extern volatile sig_atomic_t sigs;
@


