head	1.19;
access;
symbols
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.11.0.8
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.10.0.12
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.8
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.6
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.4
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.8.0.6
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.4
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.10
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.12
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.8
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.6
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2017.05.03.11.59.25;	author millert;	state Exp;
branches;
next	1.18;
commitid	gFKwy5MRqsrNW97l;

1.18
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	W32EN7Zp77efb8wW;

1.17
date	2016.01.12.17.48.04;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	O36S2Tb0ReI34f9s;

1.16
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	ZtGimechwgSRYqRW;

1.15
date	2015.11.08.08.53.49;	author nicm;	state Exp;
branches;
next	1.14;
commitid	Dw5SP1wFTHo1OcR2;

1.14
date	2015.11.07.18.07.44;	author tedu;	state Exp;
branches;
next	1.13;
commitid	DJUwzdj0cG1bCfEw;

1.13
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.12;
commitid	QKrr6AuGzNx9nehL;

1.12
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.11;
commitid	yKv9Ck9ZDgwWTRTo;

1.11
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.10;

1.10
date	2011.09.21.19.01.49;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.8;

1.8
date	2010.07.02.22.43.38;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.20.03.50.39;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.10.19.54.06;	author cloder;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.08.19.17.29;	author jmc;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.08;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.52;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.19
log
@While freeing tag entries, make sure to free the copied strings.
From Anton Lindqvist.  OK tobias@@ nicm@@
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

#include "less.h"

#define	WHITESP(c)	((c) == ' ' || (c) == '\t')

char *tags = "tags";

static int total;
static int curseq;

extern int linenums;
extern volatile sig_atomic_t sigs;

enum tag_result {
	TAG_FOUND,
	TAG_NOFILE,
	TAG_NOTAG,
	TAG_NOTYPE,
	TAG_INTR
};

static enum tag_result findctag(char *);
static char *nextctag(void);
static char *prevctag(void);
static off_t ctagsearch(void);

/*
 * The list of tags generated by the last findctag() call.
 */
struct taglist {
	struct tag *tl_first;
	struct tag *tl_last;
};
#define	TAG_END  ((struct tag *)&taglist)
static struct taglist taglist = { TAG_END, TAG_END };
struct tag {
	struct tag *next, *prev; /* List links */
	char *tag_file;		/* Source file containing the tag */
	off_t tag_linenum;	/* Appropriate line number in source file */
	char *tag_pattern;	/* Pattern used to find the tag */
	int tag_endline;	/* True if the pattern includes '$' */
};
static struct tag *curtag;

#define	TAG_INS(tp) \
	(tp)->next = TAG_END; \
	(tp)->prev = taglist.tl_last; \
	taglist.tl_last->next = (tp); \
	taglist.tl_last = (tp);

#define	TAG_RM(tp) \
	(tp)->next->prev = (tp)->prev; \
	(tp)->prev->next = (tp)->next;

/*
 * Delete tag structures.
 */
void
cleantags(void)
{
	struct tag *tp;

	/*
	 * Delete any existing tag list.
	 * {{ Ideally, we wouldn't do this until after we know that we
	 *    can load some other tag information. }}
	 */
	while ((tp = taglist.tl_first) != TAG_END) {
		TAG_RM(tp);
		free(tp->tag_file);
		free(tp->tag_pattern);
		free(tp);
	}
	curtag = NULL;
	total = curseq = 0;
}

/*
 * Create a new tag entry.
 */
static struct tag *
maketagent(char *file, off_t linenum, char *pattern, int endline)
{
	struct tag *tp;

	tp = ecalloc(sizeof (struct tag), 1);
	tp->tag_file = estrdup(file);
	tp->tag_linenum = linenum;
	tp->tag_endline = endline;
	if (pattern == NULL)
		tp->tag_pattern = NULL;
	else
		tp->tag_pattern = estrdup(pattern);
	return (tp);
}

/*
 * Find tags in tag file.
 */
void
findtag(char *tag)
{
	enum tag_result result;

	result = findctag(tag);
	switch (result) {
	case TAG_FOUND:
	case TAG_INTR:
		break;
	case TAG_NOFILE:
		error("No tags file", NULL);
		break;
	case TAG_NOTAG:
		error("No such tag in tags file", NULL);
		break;
	case TAG_NOTYPE:
		error("unknown tag type", NULL);
		break;
	}
}

/*
 * Search for a tag.
 */
off_t
tagsearch(void)
{
	if (curtag == NULL)
		return (-1);	/* No tags loaded! */
	if (curtag->tag_linenum != 0)
		return (find_pos(curtag->tag_linenum));
	return (ctagsearch());
}

/*
 * Go to the next tag.
 */
char *
nexttag(int n)
{
	char *tagfile = NULL;

	while (n-- > 0)
		tagfile = nextctag();
	return (tagfile);
}

/*
 * Go to the previous tag.
 */
char *
prevtag(int n)
{
	char *tagfile = NULL;

	while (n-- > 0)
		tagfile = prevctag();
	return (tagfile);
}

/*
 * Return the total number of tags.
 */
int
ntags(void)
{
	return (total);
}

/*
 * Return the sequence number of current tag.
 */
int
curr_tag(void)
{
	return (curseq);
}

/*
 * Find tags in the "tags" file.
 * Sets curtag to the first tag entry.
 */
static enum tag_result
findctag(char *tag)
{
	char *p;
	FILE *f;
	int taglen;
	off_t taglinenum;
	char *tagfile;
	char *tagpattern;
	int tagendline;
	int search_char;
	int err;
	char tline[TAGLINE_SIZE];
	struct tag *tp;

	p = shell_unquote(tags);
	f = fopen(p, "r");
	free(p);
	if (f == NULL)
		return (TAG_NOFILE);

	cleantags();
	total = 0;
	taglen = strlen(tag);

	/*
	 * Search the tags file for the desired tag.
	 */
	while (fgets(tline, sizeof (tline), f) != NULL) {
		if (tline[0] == '!')
			/* Skip header of extended format. */
			continue;
		if (strncmp(tag, tline, taglen) != 0 || !WHITESP(tline[taglen]))
			continue;

		/*
		 * Found it.
		 * The line contains the tag, the filename and the
		 * location in the file, separated by white space.
		 * The location is either a decimal line number,
		 * or a search pattern surrounded by a pair of delimiters.
		 * Parse the line and extract these parts.
		 */
		tagpattern = NULL;

		/*
		 * Skip over the whitespace after the tag name.
		 */
		p = skipsp(tline+taglen);
		if (*p == '\0')
			/* File name is missing! */
			continue;

		/*
		 * Save the file name.
		 * Skip over the whitespace after the file name.
		 */
		tagfile = p;
		while (!WHITESP(*p) && *p != '\0')
			p++;
		*p++ = '\0';
		p = skipsp(p);
		if (*p == '\0')
			/* Pattern is missing! */
			continue;

		/*
		 * First see if it is a line number.
		 */
		tagendline = 0;
		taglinenum = getnum(&p, 0, &err);
		if (err) {
			/*
			 * No, it must be a pattern.
			 * Delete the initial "^" (if present) and
			 * the final "$" from the pattern.
			 * Delete any backslash in the pattern.
			 */
			taglinenum = 0;
			search_char = *p++;
			if (*p == '^')
				p++;
			tagpattern = p;
			while (*p != search_char && *p != '\0') {
				if (*p == '\\')
					p++;
				p++;
			}
			tagendline = (p[-1] == '$');
			if (tagendline)
				p--;
			*p = '\0';
		}
		tp = maketagent(tagfile, taglinenum, tagpattern, tagendline);
		TAG_INS(tp);
		total++;
	}
	fclose(f);
	if (total == 0)
		return (TAG_NOTAG);
	curtag = taglist.tl_first;
	curseq = 1;
	return (TAG_FOUND);
}

/*
 * Edit current tagged file.
 */
int
edit_tagfile(void)
{
	if (curtag == NULL)
		return (1);
	return (edit(curtag->tag_file));
}

/*
 * Search for a tag.
 * This is a stripped-down version of search().
 * We don't use search() for several reasons:
 *   -	We don't want to blow away any search string we may have saved.
 *   -	The various regular-expression functions (from different systems:
 *	regcmp vs. re_comp) behave differently in the presence of
 *	parentheses (which are almost always found in a tag).
 */
static off_t
ctagsearch(void)
{
	off_t pos, linepos;
	off_t linenum;
	int len;
	char *line;

	pos = ch_zero();
	linenum = find_linenum(pos);

	for (;;) {
		/*
		 * Get lines until we find a matching one or
		 * until we hit end-of-file.
		 */
		if (ABORT_SIGS())
			return (-1);

		/*
		 * Read the next line, and save the
		 * starting position of that line in linepos.
		 */
		linepos = pos;
		pos = forw_raw_line(pos, &line, (int *)NULL);
		if (linenum != 0)
			linenum++;

		if (pos == -1) {
			/*
			 * We hit EOF without a match.
			 */
			error("Tag not found", NULL);
			return (-1);
		}

		/*
		 * If we're using line numbers, we might as well
		 * remember the information we have now (the position
		 * and line number of the current line).
		 */
		if (linenums)
			add_lnum(linenum, pos);

		/*
		 * Test the line to see if we have a match.
		 * Use strncmp because the pattern may be
		 * truncated (in the tags file) if it is too long.
		 * If tagendline is set, make sure we match all
		 * the way to end of line (no extra chars after the match).
		 */
		len = strlen(curtag->tag_pattern);
		if (strncmp(curtag->tag_pattern, line, len) == 0 &&
		    (!curtag->tag_endline || line[len] == '\0' ||
		    line[len] == '\r')) {
			curtag->tag_linenum = find_linenum(linepos);
			break;
		}
	}

	return (linepos);
}

static int circular = 0;	/* 1: circular tag structure */

/*
 * Return the filename required for the next tag in the queue that was setup
 * by findctag().  The next call to ctagsearch() will try to position at the
 * appropriate tag.
 */
static char *
nextctag(void)
{
	struct tag *tp;

	if (curtag == NULL)
		/* No tag loaded */
		return (NULL);

	tp = curtag->next;
	if (tp == TAG_END) {
		if (!circular)
			return (NULL);
		/* Wrapped around to the head of the queue */
		curtag = taglist.tl_first;
		curseq = 1;
	} else {
		curtag = tp;
		curseq++;
	}
	return (curtag->tag_file);
}

/*
 * Return the filename required for the previous ctag in the queue that was
 * setup by findctag().  The next call to ctagsearch() will try to position
 * at the appropriate tag.
 */
static char *
prevctag(void)
{
	struct tag *tp;

	if (curtag == NULL)
		/* No tag loaded */
		return (NULL);

	tp = curtag->prev;
	if (tp == TAG_END) {
		if (!circular)
			return (NULL);
		/* Wrapped around to the tail of the queue */
		curtag = taglist.tl_last;
		curseq = total;
	} else {
		curtag = tp;
		curseq--;
	}
	return (curtag->tag_file);
}
@


1.18
log
@little bit more KNF
@
text
@d80 2
@


1.17
log
@Remove LINUNUM, a needless alias for off_t. Also, remove a redundant
condition.

ok nicm@@
@
text
@d137 1
a137 1
		return (-1);   /* No tags loaded! */
@


1.16
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@d49 1
a49 1
	LINENUM tag_linenum;	/* Appropriate line number in source file */
d90 1
a90 1
maketagent(char *file, LINENUM linenum, char *pattern, int endline)
d197 1
a197 1
	LINENUM taglinenum;
d320 1
a320 1
	LINENUM linenum;
@


1.15
log
@Remove support for LESSGLOBALTAGS, we do not have global(1) (standard
ctags(1) support remains). ok tedu
@
text
@d119 1
a119 1
		error("No tags file", NULL_PARG);
d122 1
a122 1
		error("No such tag in tags file", NULL_PARG);
d125 1
a125 1
		error("unknown tag type", NULL_PARG);
d348 1
a348 1
			error("Tag not found", NULL_PARG);
@


1.14
log
@replace save() with estrdup() and make estrdup() exit like all the other
ecalloc, etc. functions do.
ok mmcc nicm
@
text
@d32 4
a35 19
/*
 * Tag type
 */
enum {
	T_CTAGS,	/* 'tags': standard and extended format (ctags) */
	T_CTAGS_X,	/* stdin: cross reference format (ctags) */
	T_GTAGS,	/* 'GTAGS': function defenition (global) */
	T_GRTAGS,	/* 'GRTAGS': function reference (global) */
	T_GSYMS,	/* 'GSYMS': other symbols (global) */
	T_GPATH		/* 'GPATH': path name (global) */
};

static enum tag_result findctag();
static enum tag_result findgtag();
static char *nextgtag();
static char *prevgtag();
static off_t ctagsearch();
static off_t gtagsearch();
static int getentry();
d38 1
a38 6
 * The list of tags generated by the last findgtag() call.
 *
 * Use either pattern or line number.
 * findgtag() always uses line number, so pattern is always NULL.
 * findctag() uses either pattern (in which case line number is 0),
 * or line number (in which case pattern is NULL).
a105 26
 * Get tag mode.
 */
static int
gettagtype(void)
{
	int f;

	if (strcmp(tags, "GTAGS") == 0)
		return (T_GTAGS);
	if (strcmp(tags, "GRTAGS") == 0)
		return (T_GRTAGS);
	if (strcmp(tags, "GSYMS") == 0)
		return (T_GSYMS);
	if (strcmp(tags, "GPATH") == 0)
		return (T_GPATH);
	if (strcmp(tags, "-") == 0)
		return (T_CTAGS_X);
	f = open(tags, OPEN_READ);
	if (f >= 0) {
		(void) close(f);
		return (T_CTAGS);
	}
	return (T_GTAGS);
}

/*
a106 4
 * Find a tag in the "tags" file.
 * Sets "tag_file" to the name of the file containing the tag,
 * and "tagpattern" to the search pattern which should be used
 * to find the tag.
a110 1
	int type = gettagtype();
d113 1
a113 4
	if (type == T_CTAGS)
		result = findctag(tag);
	else
		result = findgtag(tag, type);
d137 1
a137 1
		return (-1);  /* No gtags loaded! */
d139 2
a140 3
		return (gtagsearch());
	else
		return (ctagsearch());
d152 1
a152 1
		tagfile = nextgtag();
d165 1
a165 1
		tagfile = prevgtag();
a187 4
 * ctags
 */

/*
a378 119
/*
 * gtags
 */

/*
 * Find tags in the GLOBAL's tag file.
 * The findgtag() will try and load information about the requested tag.
 * It does this by calling "global -x tag" and storing the parsed output
 * for future use by gtagsearch().
 * Sets curtag to the first tag entry.
 */
static enum tag_result
findgtag(char *tag, int type)
{
	char buf[256];
	FILE *fp;
	struct tag *tp;

	if (type != T_CTAGS_X && tag == NULL)
		return (TAG_NOFILE);

	cleantags();
	total = 0;

	/*
	 * If type == T_CTAGS_X then read ctags's -x format from stdin
	 * else execute global(1) and read from it.
	 */
	if (type == T_CTAGS_X) {
		fp = stdin;
		/* Set tag default because we cannot read stdin again. */
		tags = "tags";
	} else {
		char *command;
		char *flag;
		char *qtag;
		char *cmd = lgetenv("LESSGLOBALTAGS");

		if (cmd == NULL || *cmd == '\0')
			return (TAG_NOFILE);
		/* Get suitable flag value for global(1). */
		switch (type) {
		case T_GTAGS:
			flag = "";
			break;
		case T_GRTAGS:
			flag = "r";
			break;
		case T_GSYMS:
			flag = "s";
			break;
		case T_GPATH:
			flag = "P";
			break;
		default:
			return (TAG_NOTYPE);
		}

		/* Get our data from global(1). */
		qtag = shell_quote(tag);
		if (qtag == NULL)
			qtag = tag;
		command = easprintf("%s -x%s %s", cmd, flag, qtag);
		if (qtag != tag)
			free(qtag);
		fp = popen(command, "r");
		free(command);
	}
	if (fp != NULL) {
		while (fgets(buf, sizeof (buf), fp)) {
			char *name, *file, *line;
			int len;

			if (sigs) {
				if (fp != stdin)
					pclose(fp);
				return (TAG_INTR);
			}
			len = strlen(buf);
			if (len > 0 && buf[len-1] == '\n') {
				buf[len-1] = '\0';
			} else {
				int c;
				do {
					c = fgetc(fp);
				} while (c != '\n' && c != EOF);
			}

			if (getentry(buf, &name, &file, &line)) {
				/*
				 * Couldn't parse this line for some reason.
				 * We'll just pretend it never happened.
				 */
				break;
			}

			/* Make new entry and add to list. */
			tp = maketagent(file, (LINENUM) atoi(line), NULL, 0);
			TAG_INS(tp);
			total++;
		}
		if (fp != stdin) {
			if (pclose(fp)) {
				curtag = NULL;
				total = curseq = 0;
				return (TAG_NOFILE);
			}
		}
	}

	/* Check to see if we found anything. */
	tp = taglist.tl_first;
	if (tp == TAG_END)
		return (TAG_NOTAG);
	curtag = tp;
	curseq = 1;
	return (TAG_FOUND);
}

d382 2
a383 2
 * Return the filename required for the next gtag in the queue that was setup
 * by findgtag().  The next call to gtagsearch() will try to position at the
d387 1
a387 1
nextgtag(void)
d410 2
a411 2
 * Return the filename required for the previous gtag in the queue that was
 * setup by findgtat().  The next call to gtagsearch() will try to position
d415 1
a415 1
prevgtag(void)
a434 90
}

/*
 * Position the current file at at what is hopefully the tag that was chosen
 * using either findtag() or one of nextgtag() and prevgtag().  Returns -1
 * if it was unable to position at the tag, 0 if successful.
 */
static off_t
gtagsearch(void)
{
	if (curtag == NULL)
		return (-1);  /* No gtags loaded! */
	return (find_pos(curtag->tag_linenum));
}

/*
 * The getentry() parses both standard and extended ctags -x format.
 *
 * [standard format]
 * <tag>   <lineno>  <file>         <image>
 * +------------------------------------------------
 * |main     30      main.c         main(argc, argv)
 * |func     21      subr.c         func(arg)
 *
 * The following commands write this format.
 *	o Traditinal Ctags with -x option
 *	o Global with -x option
 *		See <http://www.gnu.org/software/global/global.html>
 *
 * [extended format]
 * <tag>   <type>  <lineno>   <file>        <image>
 * +----------------------------------------------------------
 * |main     function 30      main.c         main(argc, argv)
 * |func     function 21      subr.c         func(arg)
 *
 * The following commands write this format.
 *	o Exuberant Ctags with -x option
 *		See <http://ctags.sourceforge.net>
 *
 * Returns 0 on success, -1 on error.
 * The tag, file, and line will each be NUL-terminated pointers
 * into buf.
 */
static int
getentry(char *buf, char **tag, char **file, char **line)
{
	char *p = buf;

	for (*tag = p; *p && !isspace(*p); p++)		/* tag name */
		;
	if (*p == 0)
		return (-1);
	*p++ = 0;
	for (; *p && isspace(*p); p++)			/* (skip blanks) */
		;
	if (*p == 0)
		return (-1);
	/*
	 * If the second part begin with other than digit,
	 * it is assumed tag type. Skip it.
	 */
	if (!isdigit(*p)) {
		for (; *p && !isspace(*p); p++)		/* (skip tag type) */
			;
		for (; *p && isspace(*p); p++)		/* (skip blanks) */
			;
	}
	if (!isdigit(*p))
		return (-1);
	*line = p;					/* line number */
	for (*line = p;  *p && !isspace(*p);  p++)
		;
	if (*p == 0)
		return (-1);
	*p++ = 0;
	for (; *p && isspace(*p); p++)		/* (skip blanks) */
		;
	if (*p == 0)
		return (-1);
	*file = p;					/* file name */
	for (*file = p;  *p && !isspace(*p);  p++)
		;
	if (*p == 0)
		return (-1);
	*p = 0;

	/* value check */
	if (strlen(*tag) && strlen(*line) && strlen(*file) && atoi(*line) > 0)
		return (0);
	return (-1);
@


1.13
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d115 1
a115 1
	tp->tag_file = save(file);
d121 1
a121 1
		tp->tag_pattern = save(pattern);
@


1.12
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.11
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

d16 1
a16 1
#define	WHITESP(c)	((c)==' ' || (c)=='\t')
d18 1
a18 3
#if TAGS

public char *tags = "tags";
d50 2
a51 2
static POSITION ctagsearch();
static POSITION gtagsearch();
d66 1
a66 1
#define TAG_END  ((struct tag *) &taglist)
d73 1
a73 1
	char tag_endline;	/* True if the pattern includes '$' */
d77 1
a77 1
#define TAG_INS(tp) \
d83 1
a83 1
#define TAG_RM(tp) \
d90 2
a91 2
	public void
cleantags()
d93 1
a93 1
	register struct tag *tp;
d100 1
a100 2
	while ((tp = taglist.tl_first) != TAG_END)
	{
d111 2
a112 7
	static struct tag *
maketagent(name, file, linenum, pattern, endline)
	char *name;
	char *file;
	LINENUM linenum;
	char *pattern;
	int endline;
d114 1
a114 1
	register struct tag *tp;
d116 1
a116 1
	tp = (struct tag *) ecalloc(sizeof(struct tag), 1);
d130 2
a131 2
	public int
gettagtype()
d136 1
a136 1
		return T_GTAGS;
d138 1
a138 1
		return T_GRTAGS;
d140 1
a140 1
		return T_GSYMS;
d142 1
a142 1
		return T_GPATH;
d144 1
a144 1
		return T_CTAGS_X;
d146 3
a148 4
	if (f >= 0)
	{
		close(f);
		return T_CTAGS;
d150 1
a150 1
	return T_GTAGS;
d160 2
a161 3
	public void
findtag(tag)
	register char *tag;
d170 1
a170 2
	switch (result)
	{
d189 2
a190 2
	public POSITION
tagsearch()
d193 1
a193 1
		return (NULL_POSITION);  /* No gtags loaded! */
d195 1
a195 1
		return gtagsearch();
d197 1
a197 1
		return ctagsearch();
d203 2
a204 3
	public char *
nexttag(n)
	int n;
d206 1
a206 1
	char *tagfile = (char *) NULL;
d210 1
a210 1
	return tagfile;
d216 2
a217 3
	public char *
prevtag(n)
	int n;
d219 1
a219 1
	char *tagfile = (char *) NULL;
d223 1
a223 1
	return tagfile;
d229 2
a230 2
	public int
ntags()
d232 1
a232 1
	return total;
d238 2
a239 2
	public int
curr_tag()
d241 1
a241 1
	return curseq;
d244 1
a244 1
/*****************************************************************************
d252 2
a253 3
	static enum tag_result
findctag(tag)
	register char *tag;
d256 2
a257 2
	register FILE *f;
	register int taglen;
d271 1
a271 1
		return TAG_NOFILE;
d280 1
a280 2
	while (fgets(tline, sizeof(tline), f) != NULL)
	{
d291 1
a291 1
		 * The location is either a decimal line number, 
d319 1
a319 1
		 * First see if it is a line number. 
d323 1
a323 2
		if (err)
		{
d326 1
a326 1
			 * Delete the initial "^" (if present) and 
d335 1
a335 2
			while (*p != search_char && *p != '\0')
			{
d345 1
a345 1
		tp = maketagent(tag, tagfile, taglinenum, tagpattern, tagendline);
d351 1
a351 1
		return TAG_NOTAG;
d354 1
a354 1
	return TAG_FOUND;
d360 2
a361 2
	public int
edit_tagfile()
d374 1
a374 1
 *	regcmp vs. re_comp) behave differently in the presence of 
d377 2
a378 2
	static POSITION
ctagsearch()
d380 1
a380 1
	POSITION pos, linepos;
d388 1
a388 2
	for (;;)
	{
d390 1
a390 1
		 * Get lines until we find a matching one or 
d394 1
a394 1
			return (NULL_POSITION);
d397 1
a397 1
		 * Read the next line, and save the 
d405 1
a405 2
		if (pos == NULL_POSITION)
		{
d410 1
a410 1
			return (NULL_POSITION);
d430 2
a431 2
		    (!curtag->tag_endline || line[len] == '\0' || line[len] == '\r'))
		{
d440 1
a440 1
/*******************************************************************************
d451 2
a452 4
	static enum tag_result
findgtag(tag, type)
	char *tag;		/* tag to load */
	int type;		/* tags type */
a456 1
	size_t len;
d459 1
a459 1
		return TAG_NOFILE;
d468 1
a468 2
	if (type == T_CTAGS_X)
	{
d472 1
a472 5
	} else
	{
#if !HAVE_POPEN
		return TAG_NOFILE;
#else
d479 1
a479 1
			return TAG_NOFILE;
d481 1
a481 2
		switch (type)
		{
d483 1
a483 1
			flag = "" ;
d495 1
a495 1
			return TAG_NOTYPE;
d502 1
a502 3
		len = strlen(cmd) + strlen(flag) + strlen(qtag) + 5;
		command = (char *) ecalloc(len, sizeof(char));
		snprintf(command, len, "%s -x%s %s", cmd, flag, qtag);
a506 1
#endif
d508 2
a509 4
	if (fp != NULL)
	{
		while (fgets(buf, sizeof(buf), fp))
		{
d511 1
d513 1
a513 3
			if (sigs)
			{
#if HAVE_POPEN
d516 1
a516 2
#endif
				return TAG_INTR;
d519 1
a519 1
			if (len > 0 && buf[len-1] == '\n')
d521 1
a521 2
			else
			{
d528 1
a528 2
 			if (getentry(buf, &name, &file, &line))
			{
d537 1
a537 1
			tp = maketagent(name, file, (LINENUM) atoi(line), NULL, 0);
d541 2
a542 4
		if (fp != stdin)
		{
			if (pclose(fp))
			{
d545 1
a545 1
				return TAG_NOFILE;
d553 1
a553 1
		return TAG_NOTAG;
d556 1
a556 1
	return TAG_FOUND;
d566 2
a567 2
	static char *
nextgtag()
d573 1
a573 1
		return NULL;
d576 1
a576 2
	if (tp == TAG_END)
	{
d578 1
a578 1
			return NULL;
d582 1
a582 2
	} else
	{
d594 2
a595 2
	static char *
prevgtag()
d601 1
a601 1
		return NULL;
d604 1
a604 2
	if (tp == TAG_END)
	{
d606 1
a606 1
			return NULL;
d610 1
a610 2
	} else
	{
d622 2
a623 2
	static POSITION
gtagsearch()
d626 1
a626 1
		return (NULL_POSITION);  /* No gtags loaded! */
d658 2
a659 6
	static int
getentry(buf, tag, file, line)
	char *buf;	/* standard or extended ctags -x format data */
	char **tag;	/* name of the tag we actually found */
	char **file;	/* file in which to find this tag */
	char **line;	/* line number of file where this tag is found */
d663 1
a663 1
	for (*tag = p;  *p && !IS_SPACE(*p);  p++)	/* tag name */
d668 1
a668 1
	for ( ;  *p && IS_SPACE(*p);  p++)		/* (skip blanks) */
d676 2
a677 3
	if (!IS_DIGIT(*p))
	{
		for ( ;  *p && !IS_SPACE(*p);  p++)	/* (skip tag type) */
d679 1
a679 1
		for (;  *p && IS_SPACE(*p);  p++)	/* (skip blanks) */
d682 1
a682 1
	if (!IS_DIGIT(*p))
d685 1
a685 1
	for (*line = p;  *p && !IS_SPACE(*p);  p++)
d690 1
a690 1
	for ( ; *p && IS_SPACE(*p);  p++)		/* (skip blanks) */
d695 1
a695 1
	for (*file = p;  *p && !IS_SPACE(*p);  p++)
a705 2
  
#endif
@


1.10
log
@Use volatile sig_atomic_t, not int, for the sigs variable.  Also
move the call to bell() out of u_interrupt() (a signal handler).
OK and with help from deraadt@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d15 2
d751 2
a752 1

@


1.9
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d22 1
a22 1
extern int sigs;
@


1.8
log
@tags.c isn't needed at all, so exclude the entire object instead of
commenting it out top-to-bottom
ok deraadt@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d57 1
a57 1
 * findctag() usually either pattern (in which case line number is 0),
d76 4
a79 4
	(tp)->next = taglist.tl_first; \
	(tp)->prev = TAG_END; \
	taglist.tl_first->prev = (tp); \
	taglist.tl_first = (tp);
d415 1
a415 1
		pos = forw_raw_line(pos, &line);
d474 1
d496 1
a496 1
		char command[512];
d526 3
a528 2
		snprintf(command, sizeof(command), "%s -x%s %s", cmd,
		    flag, qtag);
d532 1
a539 1
			size_t len;
d549 3
a551 2
			if ((len = strlen(buf)) && buf[len - 1] == '\n')
				buf[len - 1] = 0;
a696 8

#ifndef isspace
#define isspace(c)	((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) == '\r' || (c) == '\f')
#endif
#ifndef isdigit
#define isdigit(c)	((c) >= '0' && (c <= '9'))
#endif

d706 1
a706 1
	for (*tag = p;  *p && !isspace(*p);  p++)	/* tag name */
d711 1
a711 1
	for ( ;  isspace(*p);  p++)			/* (skip blanks) */
d719 1
a719 1
	if (!isdigit(*p))
d721 1
a721 1
		for ( ;  *p && !isspace(*p);  p++)	/* (skip tag type) */
d723 1
a723 1
		for (;  isspace(*p);  p++)		/* (skip blanks) */
d726 1
a726 1
	if (!isdigit(*p))
d729 1
a729 1
	for (*line = p;  *p && !isspace(*p);  p++)
d734 1
a734 1
	for ( ; isspace(*p);  p++)			/* (skip blanks) */
d739 1
a739 1
	for (*file = p;  *p && !isspace(*p);  p++)
@


1.7
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@a15 2
#if TAGS

d755 1
a755 2
  
#endif
@


1.6
log
@Fix an instance of foo[strlen(foo) - 1] = something, which is dangerous
because strlen(foo) could be 0.
OK beck@@
@
text
@d718 1
a718 1
	for ( ;  *p && isspace(*p);  p++)		/* (skip blanks) */
d730 1
a730 1
		for (;  *p && isspace(*p);  p++)	/* (skip blanks) */
d741 1
a741 1
	for ( ; *p && isspace(*p);  p++)		/* (skip blanks) */
@


1.5
log
@typos from Jonathon Gray;
@
text
@d539 1
d549 2
a550 2
			if (buf[strlen(buf) - 1] == '\n')
				buf[strlen(buf) - 1] = 0;
@


1.4
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d657 1
a657 1
 * if it was unable to position at the tag, 0 if succesful.
@


1.3
log
@kill more registers

millert@@ ok
@
text
@a0 2
/*	$OpenBSD: tags.c,v 1.2 2001/01/29 01:58:04 niklas Exp $	*/

d2 4
a5 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d7 2
a8 20
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a17 1
public char *tagfile;
d20 2
a21 2
static char *tagpattern;
static int taglinenum;
d25 134
a158 1
extern int jump_sline;
d161 1
d163 1
a163 1
 * Sets "tagfile" to the name of the file containing the tag,
d169 97
a265 1
	char *tag;
d268 6
a273 3
	char *q;
	FILE *f;
	int taglen;
d276 2
a277 1
	static char tline[200];
d279 5
a283 6
	if ((f = fopen(tags, "r")) == NULL)
	{
		error("No tags file", NULL_PARG);
		tagfile = NULL;
		return;
	}
d285 2
d294 3
d308 1
a308 2
		tagfile = tagpattern = NULL;
		taglinenum = 0;
d334 1
d348 1
a348 1
			tagpattern = q = p;
d353 1
a353 1
				*q++ = *p++;
d355 4
a358 3
			if (q[-1] == '$')
				q--;
			*q = '\0';
d360 3
a362 3

		fclose(f);
		return;
d365 16
a380 2
	error("No such tag in tags file", NULL_PARG);
	tagfile = NULL;
d392 2
a393 2
	public POSITION
tagsearch()
d396 2
a397 1
	int linenum;
a399 7
	/*
	 * If we have the line number of the tag instead of the pattern,
	 * just use find_pos.
	 */
	if (taglinenum)
		return (find_pos(taglinenum));

d442 2
d445 5
a449 1
		if (strncmp(tagpattern, line, strlen(tagpattern)) == 0)
d451 1
d457 300
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 1
a54 1
	register char *tag;
d58 2
a59 2
	register FILE *f;
	register int taglen;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 20
a24 5
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d34 1
d37 2
a38 2
static int total;
static int curseq;
d42 1
a42 61

enum tag_result {
	TAG_FOUND,
	TAG_NOFILE,
	TAG_NOTAG,
	TAG_NOTYPE,
	TAG_INTR
};

/*
 * Tag type
 */
enum {
	T_CTAGS,	/* 'tags': standard and extended format (ctags) */
	T_CTAGS_X,	/* stdin: cross reference format (ctags) */
	T_GTAGS,	/* 'GTAGS': function defenition (global) */
	T_GRTAGS,	/* 'GRTAGS': function reference (global) */
	T_GSYMS,	/* 'GSYMS': other symbols (global) */
	T_GPATH		/* 'GPATH': path name (global) */
};

static enum tag_result findctag();
static enum tag_result findgtag();
static char *nextgtag();
static char *prevgtag();
static POSITION ctagsearch();
static POSITION gtagsearch();
static int getentry();

/*
 * The list of tags generated by the last findgtag() call.
 *
 * Use either pattern or line number.
 * findgtag() always uses line number, so pattern is always NULL.
 * findctag() usually either pattern (in which case line number is 0),
 * or line number (in which case pattern is NULL).
 */
struct taglist {
	struct tag *tl_first;
	struct tag *tl_last;
};
#define TAG_END  ((struct tag *) &taglist)
static struct taglist taglist = { TAG_END, TAG_END };
struct tag {
	struct tag *next, *prev; /* List links */
	char *tag_file;		/* Source file containing the tag */
	LINENUM tag_linenum;	/* Appropriate line number in source file */
	char *tag_pattern;	/* Pattern used to find the tag */
	char tag_endline;	/* True if the pattern includes '$' */
};
static struct tag *curtag;

#define TAG_INS(tp) \
	(tp)->next = taglist.tl_first; \
	(tp)->prev = TAG_END; \
	taglist.tl_first->prev = (tp); \
	taglist.tl_first = (tp);

#define TAG_RM(tp) \
	(tp)->next->prev = (tp)->prev; \
	(tp)->prev->next = (tp)->next;
a44 78
 * Delete tag structures.
 */
	public void
cleantags()
{
	register struct tag *tp;

	/*
	 * Delete any existing tag list.
	 * {{ Ideally, we wouldn't do this until after we know that we
	 *    can load some other tag information. }}
	 */
	while ((tp = taglist.tl_first) != TAG_END)
	{
		TAG_RM(tp);
		free(tp);
	}
	curtag = NULL;
	total = curseq = 0;
}

/*
 * Create a new tag entry.
 */
	static struct tag *
maketagent(name, file, linenum, pattern, endline)
	char *name;
	char *file;
	LINENUM linenum;
	char *pattern;
	int endline;
{
	register struct tag *tp;

	tp = (struct tag *) ecalloc(sizeof(struct tag), 1);
	tp->tag_file = (char *) ecalloc(strlen(file) + 1, sizeof(char));
	strcpy(tp->tag_file, file);
	tp->tag_linenum = linenum;
	tp->tag_endline = endline;
	if (pattern == NULL)
		tp->tag_pattern = NULL;
	else
	{
		tp->tag_pattern = (char *) ecalloc(strlen(pattern) + 1, sizeof(char));
		strcpy(tp->tag_pattern, pattern);
	}
	return (tp);
}

/*
 * Get tag mode.
 */
	public int
gettagtype()
{
	int f;

	if (strcmp(tags, "GTAGS") == 0)
		return T_GTAGS;
	if (strcmp(tags, "GRTAGS") == 0)
		return T_GRTAGS;
	if (strcmp(tags, "GSYMS") == 0)
		return T_GSYMS;
	if (strcmp(tags, "GPATH") == 0)
		return T_GPATH;
	if (strcmp(tags, "-") == 0)
		return T_CTAGS_X;
	f = open(tags, OPEN_READ);
	if (f >= 0)
	{
		close(f);
		return T_CTAGS;
	}
	return T_GTAGS;
}

/*
 * Find tags in tag file.
d46 1
a46 1
 * Sets "tag_file" to the name of the file containing the tag,
a53 96
	int type = gettagtype();
	enum tag_result result;

	if (type == T_CTAGS)
		result = findctag(tag);
	else
		result = findgtag(tag, type);
	switch (result)
	{
	case TAG_FOUND:
	case TAG_INTR:
		break;
	case TAG_NOFILE:
		error("No tags file", NULL_PARG);
		break;
	case TAG_NOTAG:
		error("No such tag in tags file", NULL_PARG);
		break;
	case TAG_NOTYPE:
		error("unknown tag type", NULL_PARG);
		break;
	}
}

/*
 * Search for a tag.
 */
	public POSITION
tagsearch()
{
	if (curtag == NULL)
		return (NULL_POSITION);  /* No gtags loaded! */
	if (curtag->tag_linenum != 0)
		return gtagsearch();
	else
		return ctagsearch();
}

/*
 * Go to the next tag.
 */
	public char *
nexttag(n)
	int n;
{
	char *tagfile = (char *) NULL;

	while (n-- > 0)
		tagfile = nextgtag();
	return tagfile;
}

/*
 * Go to the previous tag.
 */
	public char *
prevtag(n)
	int n;
{
	char *tagfile = (char *) NULL;

	while (n-- > 0)
		tagfile = prevgtag();
	return tagfile;
}

/*
 * Return the total number of tags.
 */
	public int
ntags()
{
	return total;
}

/*
 * Return the sequence number of current tag.
 */
	public int
curr_tag()
{
	return curseq;
}

/*****************************************************************************
 * ctags
 */

/*
 * Find tags in the "tags" file.
 * Sets curtag to the first tag entry.
 */
	static enum tag_result
findctag(tag)
	register char *tag;
{
d55 1
a57 4
	LINENUM taglinenum;
	char *tagfile;
	char *tagpattern;
	int tagendline;
d60 1
a60 2
	char tline[TAGLINE_SIZE];
	struct tag *tp;
d62 6
a67 5
	p = shell_unquote(tags);
	f = fopen(p, "r");
	free(p);
	if (f == NULL)
		return TAG_NOFILE;
a68 2
	cleantags();
	total = 0;
a75 3
		if (tline[0] == '!')
			/* Skip header of extended format. */
			continue;
d87 2
a88 1
		tagpattern = NULL;
a113 1
		tagendline = 0;
d127 1
a127 1
			tagpattern = p;
d132 1
a132 1
				p++;
d134 3
a136 4
			tagendline = (p[-1] == '$');
			if (tagendline)
				p--;
			*p = '\0';
d138 3
a140 3
		tp = maketagent(tag, tagfile, taglinenum, tagpattern, tagendline);
		TAG_INS(tp);
		total++;
d143 2
a144 16
	if (total == 0)
		return TAG_NOTAG;
	curtag = taglist.tl_first;
	curseq = 1;
	return TAG_FOUND;
}

/*
 * Edit current tagged file.
 */
	public int
edit_tagfile()
{
	if (curtag == NULL)
		return (1);
	return (edit(curtag->tag_file));
d156 2
a157 2
	static POSITION
ctagsearch()
d160 1
a160 2
	LINENUM linenum;
	int len;
d163 7
a211 2
		 * If tagendline is set, make sure we match all
		 * the way to end of line (no extra chars after the match).
d213 1
a213 5
		len = strlen(curtag->tag_pattern);
		if (strncmp(curtag->tag_pattern, line, len) == 0 &&
		    (!curtag->tag_endline || line[len] == '\0' || line[len] == '\r'))
		{
			curtag->tag_linenum = find_linenum(linepos);
a214 1
		}
a219 299
/*******************************************************************************
 * gtags
 */

/*
 * Find tags in the GLOBAL's tag file.
 * The findgtag() will try and load information about the requested tag.
 * It does this by calling "global -x tag" and storing the parsed output
 * for future use by gtagsearch().
 * Sets curtag to the first tag entry.
 */
	static enum tag_result
findgtag(tag, type)
	char *tag;		/* tag to load */
	int type;		/* tags type */
{
	char buf[256];
	FILE *fp;
	struct tag *tp;

	if (type != T_CTAGS_X && tag == NULL)
		return TAG_NOFILE;

	cleantags();
	total = 0;

	/*
	 * If type == T_CTAGS_X then read ctags's -x format from stdin
	 * else execute global(1) and read from it.
	 */
	if (type == T_CTAGS_X)
	{
		fp = stdin;
		/* Set tag default because we cannot read stdin again. */
		tags = "tags";
	} else
	{
#if !HAVE_POPEN
		return TAG_NOFILE;
#else
		char command[512];
		char *flag;
		char *qtag;
		char *cmd = lgetenv("LESSGLOBALTAGS");

		if (cmd == NULL || *cmd == '\0')
			return TAG_NOFILE;
		/* Get suitable flag value for global(1). */
		switch (type)
		{
		case T_GTAGS:
			flag = "" ;
			break;
		case T_GRTAGS:
			flag = "r";
			break;
		case T_GSYMS:
			flag = "s";
			break;
		case T_GPATH:
			flag = "P";
			break;
		default:
			return TAG_NOTYPE;
		}

		/* Get our data from global(1). */
		qtag = shell_quote(tag);
		if (qtag == NULL)
			qtag = tag;
		sprintf(command, "%s -x%s %s", cmd, flag, qtag);
		if (qtag != tag)
			free(qtag);
		fp = popen(command, "r");
#endif
	}
	if (fp != NULL)
	{
		while (fgets(buf, sizeof(buf), fp))
		{
			char *name, *file, *line;

			if (sigs)
			{
#if HAVE_POPEN
				if (fp != stdin)
					pclose(fp);
#endif
				return TAG_INTR;
			}
			if (buf[strlen(buf) - 1] == '\n')
				buf[strlen(buf) - 1] = 0;
			else
			{
				int c;
				do {
					c = fgetc(fp);
				} while (c != '\n' && c != EOF);
			}

 			if (getentry(buf, &name, &file, &line))
			{
				/*
				 * Couldn't parse this line for some reason.
				 * We'll just pretend it never happened.
				 */
				break;
			}

			/* Make new entry and add to list. */
			tp = maketagent(name, file, (LINENUM) atoi(line), NULL, 0);
			TAG_INS(tp);
			total++;
		}
		if (fp != stdin)
		{
			if (pclose(fp))
			{
				curtag = NULL;
				total = curseq = 0;
				return TAG_NOFILE;
			}
		}
	}

	/* Check to see if we found anything. */
	tp = taglist.tl_first;
	if (tp == TAG_END)
		return TAG_NOTAG;
	curtag = tp;
	curseq = 1;
	return TAG_FOUND;
}

static int circular = 0;	/* 1: circular tag structure */

/*
 * Return the filename required for the next gtag in the queue that was setup
 * by findgtag().  The next call to gtagsearch() will try to position at the
 * appropriate tag.
 */
	static char *
nextgtag()
{
	struct tag *tp;

	if (curtag == NULL)
		/* No tag loaded */
		return NULL;

	tp = curtag->next;
	if (tp == TAG_END)
	{
		if (!circular)
			return NULL;
		/* Wrapped around to the head of the queue */
		curtag = taglist.tl_first;
		curseq = 1;
	} else
	{
		curtag = tp;
		curseq++;
	}
	return (curtag->tag_file);
}

/*
 * Return the filename required for the previous gtag in the queue that was
 * setup by findgtat().  The next call to gtagsearch() will try to position
 * at the appropriate tag.
 */
	static char *
prevgtag()
{
	struct tag *tp;

	if (curtag == NULL)
		/* No tag loaded */
		return NULL;

	tp = curtag->prev;
	if (tp == TAG_END)
	{
		if (!circular)
			return NULL;
		/* Wrapped around to the tail of the queue */
		curtag = taglist.tl_last;
		curseq = total;
	} else
	{
		curtag = tp;
		curseq--;
	}
	return (curtag->tag_file);
}

/*
 * Position the current file at at what is hopefully the tag that was chosen
 * using either findtag() or one of nextgtag() and prevgtag().  Returns -1
 * if it was unable to position at the tag, 0 if succesful.
 */
	static POSITION
gtagsearch()
{
	if (curtag == NULL)
		return (NULL_POSITION);  /* No gtags loaded! */
	return (find_pos(curtag->tag_linenum));
}

/*
 * The getentry() parses both standard and extended ctags -x format.
 *
 * [standard format]
 * <tag>   <lineno>  <file>         <image>
 * +------------------------------------------------
 * |main     30      main.c         main(argc, argv)
 * |func     21      subr.c         func(arg)
 *
 * The following commands write this format.
 *	o Traditinal Ctags with -x option
 *	o Global with -x option
 *		See <http://www.gnu.org/software/global/global.html>
 *
 * [extended format]
 * <tag>   <type>  <lineno>   <file>        <image>
 * +----------------------------------------------------------
 * |main     function 30      main.c         main(argc, argv)
 * |func     function 21      subr.c         func(arg)
 *
 * The following commands write this format.
 *	o Exuberant Ctags with -x option
 *		See <http://ctags.sourceforge.net>
 *
 * Returns 0 on success, -1 on error.
 * The tag, file, and line will each be NUL-terminated pointers
 * into buf.
 */

#ifndef isspace
#define isspace(c)	((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) == '\r' || (c) == '\f')
#endif
#ifndef isdigit
#define isdigit(c)	((c) >= '0' && (c <= '9'))
#endif

	static int
getentry(buf, tag, file, line)
	char *buf;	/* standard or extended ctags -x format data */
	char **tag;	/* name of the tag we actually found */
	char **file;	/* file in which to find this tag */
	char **line;	/* line number of file where this tag is found */
{
	char *p = buf;

	for (*tag = p;  *p && !isspace(*p);  p++)	/* tag name */
		;
	if (*p == 0)
		return (-1);
	*p++ = 0;
	for ( ;  *p && isspace(*p);  p++)		/* (skip blanks) */
		;
	if (*p == 0)
		return (-1);
	/*
	 * If the second part begin with other than digit,
	 * it is assumed tag type. Skip it.
	 */
	if (!isdigit(*p))
	{
		for ( ;  *p && !isspace(*p);  p++)	/* (skip tag type) */
			;
		for (;  *p && isspace(*p);  p++)	/* (skip blanks) */
			;
	}
	if (!isdigit(*p))
		return (-1);
	*line = p;					/* line number */
	for (*line = p;  *p && !isspace(*p);  p++)
		;
	if (*p == 0)
		return (-1);
	*p++ = 0;
	for ( ; *p && isspace(*p);  p++)		/* (skip blanks) */
		;
	if (*p == 0)
		return (-1);
	*file = p;					/* file name */
	for (*file = p;  *p && !isspace(*p);  p++)
		;
	if (*p == 0)
		return (-1);
	*p = 0;

	/* value check */
	if (strlen(*tag) && strlen(*line) && strlen(*file) && atoi(*line) > 0)
		return (0);
	return (-1);
}
  
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d59 1
a59 1
 * findctag() uses either pattern (in which case line number is 0),
d78 4
a81 4
	(tp)->next = TAG_END; \
	(tp)->prev = taglist.tl_last; \
	taglist.tl_last->next = (tp); \
	taglist.tl_last = (tp);
d421 1
a421 1
		pos = forw_raw_line(pos, &line, (int *)NULL);
d501 1
a501 1
		char *command;
a530 2
		command = (char *) ecalloc(strlen(cmd) + strlen(flag) +
				strlen(qtag) + 5, sizeof(char));
a534 1
		free(command);
a541 1
			int len;
d551 2
a552 3
			len = strlen(buf);
			if (len > 0 && buf[len-1] == '\n')
				buf[len-1] = '\0';
d660 1
a660 1
 * if it was unable to position at the tag, 0 if successful.
d698 8
d715 1
a715 1
	for (*tag = p;  *p && !IS_SPACE(*p);  p++)	/* tag name */
d720 1
a720 1
	for ( ;  *p && IS_SPACE(*p);  p++)		/* (skip blanks) */
d728 1
a728 1
	if (!IS_DIGIT(*p))
d730 1
a730 1
		for ( ;  *p && !IS_SPACE(*p);  p++)	/* (skip tag type) */
d732 1
a732 1
		for (;  *p && IS_SPACE(*p);  p++)	/* (skip blanks) */
d735 1
a735 1
	if (!IS_DIGIT(*p))
d738 1
a738 1
	for (*line = p;  *p && !IS_SPACE(*p);  p++)
d743 1
a743 1
	for ( ; *p && IS_SPACE(*p);  p++)		/* (skip blanks) */
d748 1
a748 1
	for (*file = p;  *p && !IS_SPACE(*p);  p++)
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d24 1
a24 1
extern volatile sig_atomic_t sigs;
d123 2
a124 1
	tp->tag_file = save(file);
d130 4
a133 1
		tp->tag_pattern = save(pattern);
a479 1
	size_t len;
d531 3
a533 3
		len = strlen(cmd) + strlen(flag) + strlen(qtag) + 5;
		command = (char *) ecalloc(len, sizeof(char));
		snprintf(command, len, "%s -x%s %s", cmd, flag, qtag);
d545 1
@


