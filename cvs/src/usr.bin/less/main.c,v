head	1.35;
access;
symbols
	OPENBSD_6_2:1.35.0.6
	OPENBSD_6_2_BASE:1.35
	OPENBSD_6_1:1.35.0.4
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.16.0.8
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.12.0.10
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.6
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.4
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.10.0.6
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.4
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.26
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.28
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.24
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.22
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.8
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	OpenBSD_1_2:1.2
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	W32EN7Zp77efb8wW;

1.34
date	2016.08.28.07.25.47;	author nicm;	state Exp;
branches;
next	1.33;
commitid	GxpayrHEjjCH9M4M;

1.33
date	2016.03.16.15.36.26;	author mmcc;	state Exp;
branches;
next	1.32;
commitid	P9ytq8HKajWPxZf9;

1.32
date	2016.01.12.23.01.23;	author mmcc;	state Exp;
branches;
next	1.31;
commitid	5Pl94glX7ncfN0bb;

1.31
date	2015.11.20.16.22.33;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	B1Ny5e4Kn14jjLRQ;

1.30
date	2015.11.14.20.13.29;	author guenther;	state Exp;
branches;
next	1.29;
commitid	R592sLbAQft26kZs;

1.29
date	2015.11.13.16.48.48;	author nicm;	state Exp;
branches;
next	1.28;
commitid	1UhnxVLYjgAT43E3;

1.28
date	2015.11.11.02.56.07;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	sHbEIn89mzvIcvg6;

1.27
date	2015.11.09.21.25.06;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	s7dC4pmFhYSy4rNW;

1.26
date	2015.11.09.18.41.46;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	0EQBWootSCRN4Sp8;

1.25
date	2015.11.09.16.46.43;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	rJ6tmXbM6ZZSV1zd;

1.24
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	ZtGimechwgSRYqRW;

1.23
date	2015.11.09.16.36.10;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	RecxLoLROPThbWbO;

1.22
date	2015.11.09.16.34.02;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	yC7hgwPRm2ZT4TPY;

1.21
date	2015.11.09.03.09.19;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	TRcvZryKRossxvnZ;

1.20
date	2015.11.07.18.07.44;	author tedu;	state Exp;
branches;
next	1.19;
commitid	DJUwzdj0cG1bCfEw;

1.19
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.18;
commitid	QKrr6AuGzNx9nehL;

1.18
date	2015.11.05.22.18.27;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	ZMka2O4VZNCDWtqb;

1.17
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.16;
commitid	yKv9Ck9ZDgwWTRTo;

1.16
date	2014.05.13.02.34.58;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2014.05.10.16.45.23;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.25.18.07.41;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.12;

1.12
date	2012.03.27.06.22.45;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.03.16.29.46;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.04.04.45.01;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.14.14.33.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.05.01.03.35;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.03;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	99.03.05.18.44.02;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.09.21.06.06.40;	author etheisen;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.41;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.41;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.06;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.49;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.35
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Entry point, initialization, miscellaneous routines.
 */

#include <sys/types.h>

#include <libgen.h>
#include <stdarg.h>

#include "less.h"

char	*every_first_cmd = NULL;
int	new_file;
int	is_tty;
IFILE	curr_ifile = NULL;
IFILE	old_ifile = NULL;
struct scrpos initial_scrpos;
int	any_display = FALSE;
off_t	start_attnpos = -1;
off_t	end_attnpos = -1;
int	wscroll;

static char	*progname;

int	quitting;
int	secure;
int	dohelp;

int logfile = -1;
int force_logfile = FALSE;
char *namelogfile = NULL;
char *editor;
char *editproto;

extern char	*tags;
extern char	*tagoption;
extern int	jump_sline;
extern int	less_is_more;
extern int	missing_cap;
extern int	know_dumb;
extern int	quit_if_one_screen;
extern int	quit_at_eof;
extern int	pr_type;
extern int	hilite_search;
extern int	use_lessopen;
extern int	no_init;
extern int	top_scroll;
extern int	errmsgs;


/*
 * Entry point.
 */
int
main(int argc, char *argv[])
{
	IFILE ifile;
	char *s;

	progname = basename(argv[0]);
	argv++;
	argc--;

	/*
	 * If the name of the executable program is "more",
	 * act like LESS_IS_MORE is set.  We have to set this as early
	 * as possible for POSIX.
	 */
	if (strcmp(progname, "more") == 0)
		less_is_more = 1;
	else {
		s = lgetenv("LESS_IS_MORE");
		if (s != NULL && *s != '\0')
			less_is_more = 1;
	}

	secure = 0;
	s = lgetenv("LESSSECURE");
	if (s != NULL && *s != '\0')
		secure = 1;

	if (secure) {
		if (pledge("stdio rpath wpath tty", NULL) == -1) {
			perror("pledge");
			exit(1);
		}
	} else {
		if (pledge("stdio rpath wpath cpath fattr proc exec tty", NULL) == -1) {
			perror("pledge");
			exit(1);
		}
	}

	/*
	 * Process command line arguments and LESS environment arguments.
	 * Command line arguments override environment arguments.
	 */
	is_tty = isatty(1);
	get_term();
	init_cmds();
	init_charset();
	init_line();
	init_cmdhist();
	init_option();
	init_search();


	init_prompt();

	if (less_is_more) {
		/* this is specified by XPG */
		quit_at_eof = OPT_ON;

		/* more users don't like the warning */
		know_dumb = OPT_ON;

		/* default prompt is medium */
		pr_type = OPT_ON;

		/* do not hilight search terms */
		hilite_search = OPT_OFF;

		/* do not use LESSOPEN */
		use_lessopen = OPT_OFF;

		/* do not set init strings to terminal */
		no_init = OPT_ON;

		/* repaint from top of screen */
		top_scroll = OPT_OFF;
	}

	s = lgetenv(less_is_more ? "MORE" : "LESS");
	if (s != NULL)
		scan_option(estrdup(s));

#define	isoptstring(s)	(((s)[0] == '-' || (s)[0] == '+') && (s)[1] != '\0')
	while (argc > 0 && (isoptstring(*argv) || isoptpending())) {
		s = *argv++;
		argc--;
		if (strcmp(s, "--") == 0)
			break;
		scan_option(s);
	}
#undef isoptstring

	if (isoptpending()) {
		/*
		 * Last command line option was a flag requiring a
		 * following string, but there was no following string.
		 */
		nopendopt();
		quit(QUIT_OK);
	}

	if (errmsgs) {
		quit(QUIT_ERROR);
	}
	if (less_is_more && quit_at_eof == OPT_ONPLUS) {
		extern int no_init;
		no_init = OPT_ON;
	}
	if (less_is_more && pr_type == OPT_ONPLUS) {
		extern int quiet;
		quiet = VERY_QUIET;
	}

	editor = lgetenv("VISUAL");
	if (editor == NULL || *editor == '\0') {
		editor = lgetenv("EDITOR");
		if (editor == NULL || *editor == '\0')
			editor = EDIT_PGM;
	}
	editproto = lgetenv("LESSEDIT");
	if (editproto == NULL || *editproto == '\0')
		editproto = "%E ?lm+%lm. %f";

	/*
	 * Call get_ifile with all the command line filenames
	 * to "register" them with the ifile system.
	 */
	ifile = NULL;
	if (dohelp)
		ifile = get_ifile(helpfile(), ifile);
	while (argc-- > 0) {
		char *filename;
		filename = shell_quote(*argv);
		if (filename == NULL)
			filename = *argv;
		argv++;
		(void) get_ifile(filename, ifile);
		ifile = prev_ifile(NULL);
		free(filename);
	}
	/*
	 * Set up terminal, etc.
	 */
	if (!is_tty) {
		/*
		 * Output is not a tty.
		 * Just copy the input file(s) to output.
		 */
		if (nifile() == 0) {
			if (edit_stdin() == 0)
				cat_file();
		} else if (edit_first() == 0) {
			do {
				cat_file();
			} while (edit_next(1) == 0);
		}
		quit(QUIT_OK);
	}

	if (missing_cap && !know_dumb)
		error("WARNING: terminal is not fully functional", NULL);
	init_mark();
	open_getchr();

	if (secure)
		if (pledge("stdio rpath tty", NULL) == -1) {
			perror("pledge");
			exit(1);
		}

	raw_mode(1);
	init_signals(1);

	/*
	 * Select the first file to examine.
	 */
	if (tagoption != NULL || strcmp(tags, "-") == 0) {
		/*
		 * A -t option was given.
		 * Verify that no filenames were also given.
		 * Edit the file selected by the "tags" search,
		 * and search for the proper line in the file.
		 */
		if (nifile() > 0) {
			error("No filenames allowed with -t option", NULL);
			quit(QUIT_ERROR);
		}
		findtag(tagoption);
		if (edit_tagfile())  /* Edit file which contains the tag */
			quit(QUIT_ERROR);
		/*
		 * Search for the line which contains the tag.
		 * Set up initial_scrpos so we display that line.
		 */
		initial_scrpos.pos = tagsearch();
		if (initial_scrpos.pos == -1)
			quit(QUIT_ERROR);
		initial_scrpos.ln = jump_sline;
	} else if (nifile() == 0) {
		if (edit_stdin())  /* Edit standard input */
			quit(QUIT_ERROR);
	} else {
		if (edit_first())  /* Edit first valid file in cmd line */
			quit(QUIT_ERROR);
	}

	init();
	commands();
	quit(QUIT_OK);
	return (0);
}

/*
 * Allocate memory.
 * Like calloc(), but never returns an error (NULL).
 */
void *
ecalloc(int count, unsigned int size)
{
	void *p;

	p = calloc(count, size);
	if (p != NULL)
		return (p);
	error("Cannot allocate memory", NULL);
	quit(QUIT_ERROR);
	return (NULL);
}

char *
easprintf(const char *fmt, ...)
{
	char *p = NULL;
	int rv;
	va_list ap;

	va_start(ap, fmt);
	rv = vasprintf(&p, fmt, ap);
	va_end(ap);

	if (p == NULL || rv < 0) {
		error("Cannot allocate memory", NULL);
		quit(QUIT_ERROR);
	}
	return (p);
}

char *
estrdup(const char *str)
{
	char *n;

	n = strdup(str);
	if (n == NULL) {
		error("Cannot allocate memory", NULL);
		quit(QUIT_ERROR);
	}
	return (n);
}

/*
 * Skip leading spaces in a string.
 */
char *
skipsp(char *s)
{
	while (*s == ' ' || *s == '\t')
		s++;
	return (s);
}

/*
 * See how many characters of two strings are identical.
 * If uppercase is true, the first string must begin with an uppercase
 * character; the remainder of the first string may be either case.
 */
int
sprefix(char *ps, char *s, int uppercase)
{
	int c;
	int sc;
	int len = 0;

	for (; *s != '\0'; s++, ps++) {
		c = *ps;
		if (uppercase) {
			if (len == 0 && islower(c))
				return (-1);
			c = tolower(c);
		}
		sc = *s;
		if (len > 0)
			sc = tolower(sc);
		if (c != sc)
			break;
		len++;
	}
	return (len);
}

/*
 * Exit the program.
 */
void
quit(int status)
{
	static int save_status;

	/*
	 * Put cursor at bottom left corner, clear the line,
	 * reset the terminal modes, and exit.
	 */
	if (status < 0)
		status = save_status;
	else
		save_status = status;
	quitting = 1;
	edit(NULL);
	if (!secure)
		save_cmdhist();
	if (any_display && is_tty)
		clear_bot();
	deinit();
	flush(1);
	raw_mode(0);
	exit(status);
}

char *
helpfile(void)
{
	return (less_is_more ? HELPDIR "/more.help" : HELPDIR "/less.help");
}
@


1.34
log
@Check the MORE (or LESS) environment variables after forcing the various
more(1) options, so it is possible to change them using MORE. From Ross
L Richardson. ok deraadt millert
@
text
@d349 1
a349 1
	for (; *s != '\0';  s++, ps++) {
@


1.33
log
@style(9) includes

ok nicm@@
@
text
@a120 4
	s = lgetenv(less_is_more ? "MORE" : "LESS");
	if (s != NULL)
		scan_option(estrdup(s));

d143 4
@


1.32
log
@remove lint annotations

ok nicm@@
@
text
@d16 2
d20 1
a20 1
#include <sys/types.h>
@


1.31
log
@spaces
@
text
@a272 1
	/*NOTREACHED*/
a289 1
	/*NOTREACHED*/
a306 1
		/*NOTREACHED*/
@


1.30
log
@Correct check flipped in earlier commit.
Eliminate unnecessary isupper() tests before tolower() use

ok millert@@
@
text
@d318 1
a318 1
	
@


1.29
log
@Add a flag argument to flush() to stop it calling quit() on error, then
use this from quit() to stop less blowing up the stack looping through
quit()/flush() if stderr is closed (for example "less /missing
2</dev/null"). ok millert
@
text
@d353 1
a353 1
			if (len == 0 && isupper(c))
d355 1
a355 2
			if (isupper(c))
				c = tolower(c);
d358 1
a358 1
		if (len > 0 && isupper(sc))
@


1.28
log
@exit if pledge fails
@
text
@d391 1
a391 1
	flush();
@


1.27
log
@use perror() instead, as in lesskey
@
text
@d92 1
a92 1
		if (pledge("stdio rpath wpath tty", NULL) == -1)
d94 2
d97 1
a97 1
		if (pledge("stdio rpath wpath cpath fattr proc exec tty", NULL) == -1)
d99 2
d229 1
a229 1
		if (pledge("stdio rpath tty", NULL) == -1)
d231 2
@


1.26
log
@stop acting like "more" if progname is "page"; ok millert
@
text
@d93 1
a93 1
			err(1, "pledge");
d96 1
a96 1
			err(1, "pledge");
d226 1
a226 1
			err(1, "pledge");
@


1.25
log
@NULL_IFILE has no weird use patterns.  NULL is sufficient.
@
text
@d78 1
a78 2
	if ((strcmp(progname, "more") == 0) ||
	    (strcmp(progname, "page") == 0)) {
d80 1
a80 1
	} else {
@


1.24
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@d24 2
a25 2
IFILE	curr_ifile = NULL_IFILE;
IFILE	old_ifile = NULL_IFILE;
d188 1
a188 1
	ifile = NULL_IFILE;
d198 1
a198 1
		ifile = prev_ifile(NULL_IFILE);
@


1.23
log
@3 pledge calls; 2 are for secure mode and will help track down if this
code really meets the promise of "no writes".
Some hints from nicm and semarie.
@
text
@d221 1
a221 1
		error("WARNING: terminal is not fully functional", NULL_PARG);
d243 1
a243 1
			error("No filenames allowed with -t option", NULL_PARG);
d284 1
a284 1
	error("Cannot allocate memory", NULL_PARG);
d302 1
a302 1
		error("Cannot allocate memory", NULL_PARG);
d316 1
a316 1
		error("Cannot allocate memory", NULL_PARG);
@


1.22
log
@do not save history in secure mode
@
text
@d92 8
d224 5
@


1.21
log
@close_getchr() is now a noop
@
text
@d368 2
a369 1
	save_cmdhist();
@


1.20
log
@replace save() with estrdup() and make estrdup() exit like all the other
ecalloc, etc. functions do.
ok mmcc nicm
@
text
@a373 1
	close_getchr();
@


1.19
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d110 1
a110 1
		scan_option(save(s));
a259 14
 * Copy a string to a "safe" place
 * (that is, to a buffer allocated by calloc).
 */
char *
save(const char *s)
{
	char *p;

	if ((p = estrdup(s)) == NULL)
		quit(QUIT_ERROR);
	return (p);
}

/*
d299 4
a302 2
	char *n = strdup(str);
	if (n == NULL && str != NULL) {
d304 1
@


1.18
log
@whitespace
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.17
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d34 1
a34 1
static char 	*progname;
d46 2
a47 2
extern char 	*tags;
extern char 	*tagoption;
@


1.16
log
@All callers of helpfile() are #ifdef SMALL so only define that
function when SMALL is not defined.  OK guenther@@
@
text
@d9 4
a12 1

d18 3
a21 35
#if MSDOS_COMPILER==WIN32C
#include <windows.h>
#endif

public char *	every_first_cmd = NULL;
public int	new_file;
public int	is_tty;
public IFILE	curr_ifile = NULL_IFILE;
public IFILE	old_ifile = NULL_IFILE;
public struct scrpos initial_scrpos;
public int	any_display = FALSE;
public POSITION	start_attnpos = NULL_POSITION;
public POSITION	end_attnpos = NULL_POSITION;
public int	wscroll;
public char *	progname;
public int	quitting;
public int	secure;
public int	dohelp;

#if LOGFILE
public int	logfile = -1;
public int	force_logfile = FALSE;
public char *	namelogfile = NULL;
#endif

#if EDITOR
public char *	editor;
public char *	editproto;
#endif

#if TAGS
extern char *	tags;
extern char *	tagoption;
extern int	jump_sline;
#endif
d23 22
a44 3
#ifdef WIN32
static char consoleTitle[256];
#endif
d46 3
d52 2
d55 5
d66 1
a66 3
main(argc, argv)
	int argc;
	char *argv[];
d71 3
a73 4
#ifdef __EMX__
	_response(&argc, &argv);
	_wildcard(&argc, &argv);
#endif
d75 13
a87 2
	progname = *argv++;
	argc--;
a93 22
#ifdef WIN32
	if (getenv("HOME") == NULL)
	{
		/*
		 * If there is no HOME environment variable,
		 * try the concatenation of HOMEDRIVE + HOMEPATH.
		 */
		char *drive = getenv("HOMEDRIVE");
		char *path  = getenv("HOMEPATH");
		if (drive != NULL && path != NULL)
		{
			size_t len = strlen(drive) + strlen(path) + 6;
			char *env = (char *) ecalloc(len, sizeof(char));
			strlcpy(env, "HOME=", len);
			strlcat(env, drive, len);
			strlcat(env, path, len);
			putenv(env);
		}
	}
	GetConsoleTitle(consoleTitle, sizeof(consoleTitle)/sizeof(char));
#endif /* WIN32 */

a106 11
	/*
	 * If the name of the executable program is "more",
	 * act like LESS_IS_MORE is set.
	 */
	for (s = progname + strlen(progname);  s > progname;  s--)
	{
		if (s[-1] == PATHNAME_SEP[0])
			break;
	}
	if (strcmp(s, "more") == 0)
		less_is_more = 1;
a109 7
	if (less_is_more) {
		scan_option("-G");
		scan_option("-L");
		scan_option("-X");
		scan_option("-c");
	}

d114 23
d138 1
a138 2
	while (argc > 0 && (isoptstring(*argv) || isoptpending()))
	{
d147 1
a147 2
	if (isoptpending())
	{
d156 12
a167 1
#if EDITOR
d169 1
a169 2
	if (editor == NULL || *editor == '\0')
	{
a176 1
#endif
a182 1
#if !SMALL
d185 1
a185 3
#endif /* !SMALL */
	while (argc-- > 0)
	{
a186 20
#if (MSDOS_COMPILER && MSDOS_COMPILER != DJGPPC)
		/*
		 * Because the "shell" doesn't expand filename patterns,
		 * treat each argument as a filename pattern rather than
		 * a single filename.  
		 * Expand the pattern and iterate over the expanded list.
		 */
		struct textlist tlist;
		char *gfilename;
		
		gfilename = lglob(*argv++);
		init_textlist(&tlist, gfilename);
		filename = NULL;
		while ((filename = forw_textlist(&tlist, filename)) != NULL)
		{
			(void) get_ifile(filename, ifile);
			ifile = prev_ifile(NULL_IFILE);
		}
		free(gfilename);
#else
a193 1
#endif
d198 1
a198 2
	if (!is_tty)
	{
d203 1
a203 3
		SET_BINARY(1);
		if (nifile() == 0)
		{
d206 1
a206 2
		} else if (edit_first() == 0)
		{
d214 1
a214 1
	if (missing_cap && !know_dumb && !less_is_more)
d224 1
a224 3
#if TAGS
	if (tagoption != NULL || strcmp(tags, "-") == 0)
	{
d231 1
a231 2
		if (nifile() > 0)
		{
d243 1
a243 1
		if (initial_scrpos.pos == NULL_POSITION)
d246 1
a246 4
	} else
#endif
	if (nifile() == 0)
	{
d249 1
a249 2
	} else 
	{
d265 2
a266 3
	public char *
save(s)
	char *s;
d268 1
a268 2
	register char *p;
	size_t len = strlen(s) + 1;
d270 2
a271 2
	p = (char *) ecalloc(len, sizeof(char));
	strlcpy(p, s, len);
d279 2
a280 4
	public VOID_POINTER
ecalloc(count, size)
	int count;
	unsigned int size;
d282 1
a282 1
	register VOID_POINTER p;
d284 1
a284 1
	p = (VOID_POINTER) calloc(count, size);
d293 29
d325 2
a326 3
	public char *
skipsp(s)
	register char *s;
d328 1
a328 1
	while (*s == ' ' || *s == '\t')	
a332 1
#if GNU_OPTIONS
d338 2
a339 5
	public int
sprefix(ps, s, uppercase)
	char *ps;
	char *s;
	int uppercase;
d341 3
a343 3
	register int c;
	register int sc;
	register int len = 0;
d345 1
a345 2
	for ( ;  *s != '\0';  s++, ps++)
	{
d347 2
a348 3
		if (uppercase)
		{
			if (len == 0 && ASCII_IS_LOWER(c))
d350 2
a351 2
			if (ASCII_IS_UPPER(c))
				c = ASCII_TO_LOWER(c);
d354 2
a355 2
		if (len > 0 && ASCII_IS_UPPER(sc))
			sc = ASCII_TO_LOWER(sc);
a361 1
#endif /* GNU_OPTIONS */
d366 2
a367 3
	public void
quit(status)
	int status;
d380 1
a380 1
	edit((char*)NULL);
a386 12
#if MSDOS_COMPILER && MSDOS_COMPILER != DJGPPC
	/* 
	 * If we don't close 2, we get some garbage from
	 * 2's buffer when it flushes automatically.
	 * I cannot track this one down  RB
	 * The same bug shows up if we use ^C^C to abort.
	 */
	close(2);
#endif
#ifdef WIN32
	SetConsoleTitle(consoleTitle);
#endif
d391 1
a391 2
#if !SMALL
	public char *
a395 1
#endif /* !SMALL */
@


1.15
log
@Give more(1) its own help file, shorter than the one for less(1).
The helpfile itself was prepared by jmc@@, the glue by me.
OK millert@@ jmc@@
@
text
@d424 1
d430 1
@


1.14
log
@Make more(1) POSIX compliant with respect to the -e option.
By default, "more" now works like "less -e", and "more -e" now
works like "less -E", and more never exits just because the file
fits on the first screen, like "less -F" would.

While documenting this, add some text to the DESCRIPTION explaining
how paging works.  That allows a very concise description of -e.

code change ok millert@@
manual page joint work with and ok jmc@@
@
text
@d187 1
a187 1
		ifile = get_ifile(HELPFILE, ifile);
d422 6
@


1.13
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@a58 1
extern int	quit_if_one_screen;
a165 3

	if (less_is_more && get_quit_at_eof())
		quit_if_one_screen = TRUE;
@


1.12
log
@Reverse the default of the -c flag from off to on to prevent the text
being displayed in the wrong place initially and then jumping when first
redrawn (such as when searching).

ok deraadt sthen
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d222 1
@


1.11
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d141 1
@


1.10
log
@use SMALL_PROGRAM to knock out some code
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d34 1
a34 1
public int	ismore;
d57 1
d60 2
a62 1
extern char *	__progname;
a113 1
	ismore = !strcmp(__progname, "more");
a116 1
	init_prompt();
d119 1
d121 17
a137 2
	if (ismore) {
		scan_option("-E");
d140 4
a143 4
		scan_option("-m");
		s = lgetenv("MORE");
	} else
		s = lgetenv("LESS");
d168 3
d189 4
d247 1
a247 1
	if (missing_cap && !know_dumb && !ismore)
d310 1
a310 1
	size_t len;
a311 1
	len = strlen(s)+1, sizeof(char);
d349 1
a349 1
#ifndef SMALL_PROGRAM
d370 1
a370 1
			if (len == 0 && SIMPLE_IS_LOWER(c))
d372 2
a373 2
			if (SIMPLE_IS_UPPER(c))
				c = SIMPLE_TO_LOWER(c);
d376 2
a377 2
		if (len > 0 && SIMPLE_IS_UPPER(sc))
			sc = SIMPLE_TO_LOWER(sc);
d384 1
a384 1
#endif /* SMALL_PROGRAM */
d405 1
d420 1
a420 1
#if WIN32
@


1.9
log
@It turns out that POSIX specifies more should prompt with the file name,
not --More-- like the old UCB more did.  Back out a hack I did to
make the prompt look like the old UCB more.
@
text
@d327 1
d362 1
@


1.8
log
@o go back to using a help file instead of embedding it in the binary
o deal with HELPFILE not being defined
o add a SMALL definition to make a smaller less for the boot floppies
This still needs to be pared down a bit for the SMALL case
@
text
@d124 1
@


1.7
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@a33 1
public int	dohelp;
a168 2
	if (dohelp)
		ifile = get_ifile(FAKE_HELPFILE, ifile);
@


1.6
log
@some more string shit; krw ok
@
text
@a0 2
/*	$OpenBSD: main.c,v 1.5 2001/11/19 19:02:14 mpech Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d17 3
a19 1
#include "position.h"
d28 2
d33 3
a35 7
public int	more_mode = 0;

extern int	quit_at_eof;
extern int	cbufs;
extern int	errmsgs;
extern int	screen_trashed;
extern int	force_open;
d49 1
a49 1
extern char *	tagfile;
d54 3
d58 4
d72 1
a72 1
	extern char *__progname;
d80 28
d113 2
a114 3
	if (strcmp(__progname, "more") == 0)
		more_mode = 1;

d119 1
d121 1
a121 2

	if (more_mode) {
a122 1
		scan_option("-m");
d124 2
a125 1
		scan_option(getenv("MORE"));
d127 3
a129 1
		scan_option(getenv("LESS"));
d131 2
a132 5
#if GNU_OPTIONS
	/*
	 * Special case for "less --help" and "less --version".
	 */
	if (argc == 2)
d134 3
a136 11
		if (strcmp(argv[0], "--help") == 0)
			scan_option("-?");
		if (strcmp(argv[0], "--version") == 0)
			scan_option("-V");
	}
#endif
#define	isoptstring(s)	(((s)[0] == '-' || (s)[0] == '+') && (s)[1] != '\0')
	while (--argc > 0 && (isoptstring(argv[0]) || isoptpending())) {
		if (strcmp(argv[0], "--") == 0) {
			argv++;
			argc--;
d138 1
a138 2
		}
		scan_option(*argv++);
d153 1
a153 1
	editor = getenv("VISUAL");
d156 1
a156 1
		editor = getenv("EDITOR");
d160 1
a160 1
	editproto = getenv("LESSEDIT");
d170 3
a172 1
	while (--argc >= 0)
d174 2
a175 1
#if MSOFTC || OS2
a183 1
		char *filename;
d185 1
a185 1
		gfilename = glob(*argv++);
d189 4
a192 1
			ifile = get_ifile(filename, ifile);
d195 6
a200 1
		ifile = get_ifile(*argv++, ifile);
a205 1
	is_tty = isatty(1);
d212 1
d226 2
d229 1
a230 1
	open_getchr();
d237 1
a237 1
	if (tagoption != NULL)
d251 1
a251 3
		if (tagfile == NULL)
			quit(QUIT_ERROR);
		if (edit(tagfile))  /* Edit file which contains the tag */
d277 1
a277 14
}

/*
 * Copy a string, truncating to the specified length if necessary.
 * Unlike strncpy(), the resulting string is guaranteed to be null-terminated.
 */
	public void
strtcpy(to, from, len)
	char *to;
	char *from;
	unsigned int len;
{
	strncpy(to, from, len);
	to[len-1] = '\0';
d288 1
a288 1
	char *p;
d291 1
a291 1
	len = strlen(s)+1;
d306 1
a306 1
	VOID_POINTER p;
d314 1
d322 1
a322 1
	char *s;
d330 35
d383 1
a383 1
	if (is_tty && any_display)
d388 1
a388 1
#if MSOFTC
d397 4
@


1.5
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 2001/01/29 01:58:03 niklas Exp $	*/
d286 1
d288 3
a290 2
	p = (char *) ecalloc(strlen(s)+1, sizeof(char));
	strcpy(p, s);
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d285 1
a285 1
	register char *p;
d301 1
a301 1
	register VOID_POINTER p;
d316 1
a316 1
	register char *s;
@


1.3
log
@provide support for -- argument seperator
@
text
@d1 2
@


1.2
log
@Incorporate less modifications for more and our bug fixes from previous
version.
@
text
@d124 6
a129 1
	while (--argc > 0 && (isoptstring(argv[0]) || isoptpending()))
d131 1
@


1.1
log
@Initial revision
@
text
@d45 1
d81 1
d94 3
d102 8
a109 1
	scan_option(getenv("LESS"));
d334 1
a334 1
	if (any_display)
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d33 1
a33 3
#if MSDOS_COMPILER==WIN32C
#include <windows.h>
#endif
a41 2
public POSITION	start_attnpos = NULL_POSITION;
public POSITION	end_attnpos = NULL_POSITION;
d45 6
a50 2
public int	secure;
public int	dohelp;
d64 1
a64 1
extern char *	tags;
a68 6
#ifdef WIN32
static char consoleTitle[256];
#endif

extern int	missing_cap;
extern int	know_dumb;
a79 1
	char *s;
a86 28
	argc--;

	secure = 0;
	s = lgetenv("LESSSECURE");
	if (s != NULL && *s != '\0')
		secure = 1;

#ifdef WIN32
	if (getenv("HOME") == NULL)
	{
		/*
		 * If there is no HOME environment variable,
		 * try the concatenation of HOMEDRIVE + HOMEPATH.
		 */
		char *drive = getenv("HOMEDRIVE");
		char *path  = getenv("HOMEPATH");
		if (drive != NULL && path != NULL)
		{
			char *env = (char *) ecalloc(strlen(drive) + 
					strlen(path) + 6, sizeof(char));
			strcpy(env, "HOME=");
			strcat(env, drive);
			strcat(env, path);
			putenv(env);
		}
	}
	GetConsoleTitle(consoleTitle, sizeof(consoleTitle)/sizeof(char));
#endif /* WIN32 */
a91 1
	is_tty = isatty(1);
a95 1
	init_line();
d97 1
a97 3
	s = lgetenv("LESS");
	if (s != NULL)
		scan_option(save(s));
d99 5
a103 2
#define	isoptstring(s)	(((s)[0] == '-' || (s)[0] == '+') && (s)[1] != '\0')
	while (argc > 0 && (isoptstring(*argv) || isoptpending()))
d105 4
a108 5
		s = *argv++;
		argc--;
		if (strcmp(s, "--") == 0)
			break;
		scan_option(s);
d110 4
d127 1
a127 1
	editor = lgetenv("VISUAL");
d130 1
a130 1
		editor = lgetenv("EDITOR");
d134 1
a134 1
	editproto = lgetenv("LESSEDIT");
d144 1
a144 3
	if (dohelp)
		ifile = get_ifile(FAKE_HELPFILE, ifile);
	while (argc-- > 0)
d146 1
a146 2
		char *filename;
#if (MSDOS_COMPILER && MSDOS_COMPILER != DJGPPC)
d155 1
d157 1
a157 1
		gfilename = lglob(*argv++);
d161 1
a161 4
		{
			(void) get_ifile(filename, ifile);
			ifile = prev_ifile(NULL_IFILE);
		}
d164 1
a164 6
		filename = shell_quote(*argv);
		if (filename == NULL)
			filename = *argv;
		argv++;
		(void) get_ifile(filename, ifile);
		ifile = prev_ifile(NULL_IFILE);
d170 1
a176 1
		SET_BINARY(1);
a189 2
	if (missing_cap && !know_dumb)
		error("WARNING: terminal is not fully functional", NULL_PARG);
d191 1
a192 1
	raw_mode(1);
d199 1
a199 1
	if (tagoption != NULL || strcmp(tags, "-") == 0)
d213 3
a215 1
		if (edit_tagfile())  /* Edit file which contains the tag */
d241 14
a254 1
	return (0);
a288 1
	return (NULL);
a303 35
 * See how many characters of two strings are identical.
 * If uppercase is true, the first string must begin with an uppercase
 * character; the remainder of the first string may be either case.
 */
	public int
sprefix(ps, s, uppercase)
	char *ps;
	char *s;
	int uppercase;
{
	register int c;
	register int sc;
	register int len = 0;

	for ( ;  *s != '\0';  s++, ps++)
	{
		c = *ps;
		if (uppercase)
		{
			if (len == 0 && SIMPLE_IS_LOWER(c))
				return (-1);
			if (SIMPLE_IS_UPPER(c))
				c = SIMPLE_TO_LOWER(c);
		}
		sc = *s;
		if (len > 0 && SIMPLE_IS_UPPER(sc))
			sc = SIMPLE_TO_LOWER(sc);
		if (c != sc)
			break;
		len++;
	}
	return (len);
}

/*
d322 1
a322 1
	if (any_display && is_tty)
d327 1
a327 1
#if MSDOS_COMPILER && MSDOS_COMPILER != DJGPPC
a335 4
#if WIN32
	SetConsoleTitle(consoleTitle);
#endif
	close_getchr();
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
a56 1
extern int	less_is_more;
a58 2
extern int	quit_if_one_screen;
extern int	pr_type;
d114 1
a116 1
	init_cmdhist();
d118 1
a118 17
	init_search();

	/*
	 * If the name of the executable program is "more",
	 * act like LESS_IS_MORE is set.
	 */
	for (s = progname + strlen(progname);  s > progname;  s--)
	{
		if (s[-1] == PATHNAME_SEP[0])
			break;
	}
	if (strcmp(s, "more") == 0)
		less_is_more = 1;

	init_prompt();

	s = lgetenv(less_is_more ? "MORE" : "LESS");
a142 3
	if (less_is_more && get_quit_at_eof())
		quit_if_one_screen = TRUE;

d338 1
a338 1
			if (len == 0 && ASCII_IS_LOWER(c))
d340 2
a341 2
			if (ASCII_IS_UPPER(c))
				c = ASCII_TO_LOWER(c);
d344 2
a345 2
		if (len > 0 && ASCII_IS_UPPER(sc))
			sc = ASCII_TO_LOWER(sc);
a371 1
	save_cmdhist();
d386 1
a386 1
#ifdef WIN32
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d99 5
a103 5
			size_t len = strlen(drive) + strlen(path) + 6;
			char *env = (char *) ecalloc(len, sizeof(char));
			strlcpy(env, "HOME=", len);
			strlcat(env, drive, len);
			strlcat(env, path, len);
a136 7
	if (less_is_more) {
		scan_option("-G");
		scan_option("-L");
		scan_option("-X");
		scan_option("-c");
	}

a182 1
#if !SMALL
d184 1
a184 2
		ifile = get_ifile(HELPFILE, ifile);
#endif /* !SMALL */
a213 1
		free(filename);
d239 1
a239 1
	if (missing_cap && !know_dumb && !less_is_more)
a301 1
	size_t len = strlen(s) + 1;
d303 2
a304 2
	p = (char *) ecalloc(len, sizeof(char));
	strlcpy(p, s, len);
a339 1
#if GNU_OPTIONS
a373 1
#endif /* GNU_OPTIONS */
@


