head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.2
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.6.0.12
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.8
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.5.0.34
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.32
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.30
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	W32EN7Zp77efb8wW;

1.16
date	2016.03.16.15.36.26;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	P9ytq8HKajWPxZf9;

1.15
date	2016.01.27.15.36.46;	author gsoares;	state Exp;
branches;
next	1.14;
commitid	k0Af260y5HvvBGng;

1.14
date	2015.11.23.09.39.55;	author nicm;	state Exp;
branches;
next	1.13;
commitid	oXH2wNdadwbRnYrk;

1.13
date	2015.11.19.18.39.49;	author tedu;	state Exp;
branches;
next	1.12;
commitid	VmRuKYoWAx77e75n;

1.12
date	2015.11.14.20.31.36;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	K4VP2PkB1SeSRAQI;

1.11
date	2015.11.09.04.10.57;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	E4Lg0tTt0vh4nd97;

1.10
date	2015.11.06.15.58.01;	author nicm;	state Exp;
branches;
next	1.9;
commitid	y4I2iN2XAfMdlxNX;

1.9
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.8;
commitid	QKrr6AuGzNx9nehL;

1.8
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.7;
commitid	yKv9Ck9ZDgwWTRTo;

1.7
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.05.01.03.35;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.44;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.44;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.06;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.48;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.17
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 *	lesskey [-o output] [input]
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *	Make a .less file.
 *	If no input file is specified, standard input is used.
 *	If no output file is specified, $HOME/.less is used.
 *
 *	The .less file is used to specify (to "less") user-defined
 *	key bindings.  Basically any sequence of 1 to MAX_CMDLEN
 *	keystrokes may be bound to an existing less function.
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *	The input file is an ascii file consisting of a
 *	sequence of lines of the form:
 *		string <whitespace> action [chars] <newline>
 *
 *	"string" is a sequence of command characters which form
 *		the new user-defined command.  The command
 *		characters may be:
 *		1. The actual character itself.
 *		2. A character preceded by ^ to specify a
 *		   control character (e.g. ^X means control-X).
 *		3. A backslash followed by one to three octal digits
 *		   to specify a character by its octal value.
 *		4. A backslash followed by b, e, n, r or t
 *		   to specify \b, ESC, \n, \r or \t, respectively.
 *		5. Any character (other than those mentioned above) preceded
 *		   by a \ to specify the character itself (characters which
 *		   must be preceded by \ include ^, \, and whitespace.
 *	"action" is the name of a "less" action, from the table below.
 *	"chars" is an optional sequence of characters which is treated
 *		as keyboard input after the command is executed.
 *
 *	Blank lines and lines which start with # are ignored,
 *	except for the special control lines:
 *		#command	Signals the beginning of the command
 *				keys section.
 *		#line-edit	Signals the beginning of the line-editing
 *				keys section.
 *		#env		Signals the beginning of the environment
 *				variable section.
 *		#stop		Stops command parsing in less;
 *				causes all default keys to be disabled.
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *	The output file is a non-ascii file, consisting of a header,
 *	one or more sections, and a trailer.
 *	Each section begins with a section header, a section length word
 *	and the section data.  Normally there are three sections:
 *		CMD_SECTION	Definition of command keys.
 *		EDIT_SECTION	Definition of editing keys.
 *		END_SECTION	A special section header, with no
 *				length word or section data.
 *
 *	Section data consists of zero or more byte sequences of the form:
 *		string <0> <action>
 *	or
 *		string <0> <action|A_EXTRA> chars <0>
 *
 *	"string" is the command string.
 *	"<0>" is one null byte.
 *	"<action>" is one byte containing the action code (the A_xxx value).
 *	If action is ORed with A_EXTRA, the action byte is followed
 *		by the null-terminated "chars" string.
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 */

#include <err.h>

#include "cmd.h"
#include "less.h"
#include "lesskey.h"

struct cmdname {
	char *cn_name;
	int cn_action;
};

static void	lkerr(char *);

struct cmdname cmdnames[] = {
	{ "back-bracket",		A_B_BRACKET },
	{ "back-line",			A_B_LINE },
	{ "back-line-force",		A_BF_LINE },
	{ "back-screen",		A_B_SCREEN },
	{ "back-scroll",		A_B_SCROLL },
	{ "back-search",		A_B_SEARCH },
	{ "back-window",		A_B_WINDOW },
	{ "debug",			A_DEBUG },
	{ "digit",			A_DIGIT },
	{ "display-flag",		A_DISP_OPTION },
	{ "display-option",		A_DISP_OPTION },
	{ "end",			A_GOEND },
	{ "examine",			A_EXAMINE },
	{ "filter",			A_FILTER },
	{ "first-cmd",			A_FIRSTCMD },
	{ "firstcmd",			A_FIRSTCMD },
	{ "flush-repaint",		A_FREPAINT },
	{ "forw-bracket",		A_F_BRACKET },
	{ "forw-forever",		A_F_FOREVER },
	{ "forw-until-hilite",		A_F_UNTIL_HILITE },
	{ "forw-line",			A_F_LINE },
	{ "forw-line-force",		A_FF_LINE },
	{ "forw-screen",		A_F_SCREEN },
	{ "forw-screen-force",		A_FF_SCREEN },
	{ "forw-scroll",		A_F_SCROLL },
	{ "forw-search",		A_F_SEARCH },
	{ "forw-skip",			A_F_SKIP },
	{ "forw-window",		A_F_WINDOW },
	{ "goto-end",			A_GOEND },
	{ "goto-line",			A_GOLINE },
	{ "goto-mark",			A_GOMARK },
	{ "help",			A_HELP },
	{ "index-file",			A_INDEX_FILE },
	{ "invalid",			A_UINVALID },
	{ "left-scroll",		A_LSHIFT },
	{ "next-file",			A_NEXT_FILE },
	{ "next-tag",			A_NEXT_TAG },
	{ "noaction",			A_NOACTION },
	{ "percent",			A_PERCENT },
	{ "pipe",			A_PIPE },
	{ "prev-file",			A_PREV_FILE },
	{ "prev-tag",			A_PREV_TAG },
	{ "quit",			A_QUIT },
	{ "remove-file",		A_REMOVE_FILE },
	{ "repaint",			A_REPAINT },
	{ "repaint-flush",		A_FREPAINT },
	{ "repeat-search",		A_AGAIN_SEARCH },
	{ "repeat-search-all",		A_T_AGAIN_SEARCH },
	{ "reverse-search",		A_REVERSE_SEARCH },
	{ "reverse-search-all",		A_T_REVERSE_SEARCH },
	{ "right-scroll",		A_RSHIFT },
	{ "set-mark",			A_SETMARK },
	{ "status",			A_STAT },
	{ "toggle-flag",		A_OPT_TOGGLE },
	{ "toggle-option",		A_OPT_TOGGLE },
	{ "undo-hilite",		A_UNDO_SEARCH },
	{ "version",			A_VERSION },
	{ "visual",			A_VISUAL },
	{ NULL,				0 }
};

struct cmdname editnames[] = {
	{ "back-complete",	EC_B_COMPLETE },
	{ "backspace",		EC_BACKSPACE },
	{ "delete",		EC_DELETE },
	{ "down",		EC_DOWN },
	{ "end",		EC_END },
	{ "expand",		EC_EXPAND },
	{ "forw-complete",	EC_F_COMPLETE },
	{ "home",		EC_HOME },
	{ "insert",		EC_INSERT },
	{ "invalid",		EC_UINVALID },
	{ "kill-line",		EC_LINEKILL },
	{ "abort",		EC_ABORT },
	{ "left",		EC_LEFT },
	{ "literal",		EC_LITERAL },
	{ "right",		EC_RIGHT },
	{ "up",			EC_UP },
	{ "word-backspace",	EC_W_BACKSPACE },
	{ "word-delete",	EC_W_DELETE },
	{ "word-left",		EC_W_LEFT },
	{ "word-right",		EC_W_RIGHT },
	{ NULL, 0 }
};

struct table {
	struct cmdname *names;
	char *pbuffer;
	char buffer[MAX_USERCMD];
};

struct table cmdtable;
struct table edittable;
struct table vartable;
struct table *currtable = &cmdtable;

char fileheader[] = {
	C0_LESSKEY_MAGIC,
	C1_LESSKEY_MAGIC,
	C2_LESSKEY_MAGIC,
	C3_LESSKEY_MAGIC
};
char filetrailer[] = {
	C0_END_LESSKEY_MAGIC,
	C1_END_LESSKEY_MAGIC,
	C2_END_LESSKEY_MAGIC
};
char cmdsection[1] =	{ CMD_SECTION };
char editsection[1] =	{ EDIT_SECTION };
char varsection[1] =	{ VAR_SECTION };
char endsection[1] =	{ END_SECTION };

char *infile = NULL;
char *outfile = NULL;

int linenum;
int errors;

extern char version[];

static void
usage(void)
{
	(void) fprintf(stderr, "usage: lesskey [-o output] [input]\n");
	exit(1);
}

static char *
mkpathname(char *dirname, char *filename)
{
	char *pathname;
	size_t len;

	len = strlen(dirname) + strlen(filename) + 2;
	pathname = calloc(1, len);
	if (pathname == NULL) {
		fprintf(stderr, "mkpathname: out of memory\n");
		exit(1);
	}
	(void) snprintf(pathname, len, "%s/%s", dirname, filename);
	return (pathname);
}

/*
 * Figure out the name of a default file (in the user's HOME directory).
 */
char *
homefile(char *filename)
{
	char *p;
	char *pathname;

	if ((p = getenv("HOME")) != NULL && *p != '\0') {
		pathname = mkpathname(p, filename);
	} else {
		(void) fprintf(stderr, "cannot find $HOME - "
		    "using current directory\n");
		pathname = mkpathname(".", filename);
	}
	return (pathname);
}

/*
 * Parse command line arguments.
 */
static void
parse_args(int argc, char **argv)
{
	char *arg;

	outfile = NULL;
	while (--argc > 0) {
		arg = *++argv;
		if (arg[0] != '-')
			/* Arg does not start with "-"; it's not an option. */
			break;
		if (arg[1] == '\0')
			/* "-" means standard input. */
			break;
		if (arg[1] == '-' && arg[2] == '\0') {
			/* "--" means end of options. */
			argc--;
			argv++;
			break;
		}
		switch (arg[1]) {
		case '-':
			if (strncmp(arg, "--output", 8) == 0) {
				if (arg[8] == '\0')
					outfile = &arg[8];
				else if (arg[8] == '=')
					outfile = &arg[9];
				else
					usage();
				goto opt_o;
			}
			if (strcmp(arg, "--version") == 0) {
				goto opt_V;
			}
			usage();
			break;
		case 'o':
			outfile = &argv[0][2];
		opt_o:
			if (*outfile == '\0') {
				if (--argc <= 0)
					usage();
				outfile = *(++argv);
			}
			break;
		case 'V':
		opt_V:
			(void) printf("lesskey  version %s\n", version);
			exit(0);
		default:
			usage();
		}
	}
	if (argc > 1)
		usage();
	/*
	 * Open the input file, or use DEF_LESSKEYINFILE if none specified.
	 */
	if (argc > 0)
		infile = *argv;
	else
		infile = homefile(DEF_LESSKEYINFILE);
}

/*
 * Initialize data structures.
 */
static void
init_tables(void)
{
	cmdtable.names = cmdnames;
	cmdtable.pbuffer = cmdtable.buffer;

	edittable.names = editnames;
	edittable.pbuffer = edittable.buffer;

	vartable.names = NULL;
	vartable.pbuffer = vartable.buffer;
}

/*
 * Parse one character of a string.
 */
static char *
tstr(char **pp, int xlate)
{
	char *p;
	char ch;
	int i;
	static char buf[10];
	static char tstr_control_k[] =
		{ SK_SPECIAL_KEY, SK_CONTROL_K, 6, 1, 1, 1, '\0' };

	p = *pp;
	switch (*p) {
	case '\\':
		++p;
		switch (*p) {
		case '0': case '1': case '2': case '3':
		case '4': case '5': case '6': case '7':
			/*
			 * Parse an octal number.
			 */
			ch = 0;
			i = 0;
			do
				ch = 8*ch + (*p - '0');
			while (*++p >= '0' && *p <= '7' && ++i < 3)
				;
			*pp = p;
			if (xlate && ch == CONTROL('K'))
				return (tstr_control_k);
			buf[0] = ch;
			buf[1] = '\0';
			return (buf);
		case 'b':
			*pp = p+1;
			return ("\b");
		case 'e':
			*pp = p+1;
			buf[0] = ESC;
			buf[1] = '\0';
			return (buf);
		case 'n':
			*pp = p+1;
			return ("\n");
		case 'r':
			*pp = p+1;
			return ("\r");
		case 't':
			*pp = p+1;
			return ("\t");
		case 'k':
			if (xlate) {
				switch (*++p) {
				case 'u': ch = SK_UP_ARROW; break;
				case 'd': ch = SK_DOWN_ARROW; break;
				case 'r': ch = SK_RIGHT_ARROW; break;
				case 'l': ch = SK_LEFT_ARROW; break;
				case 'U': ch = SK_PAGE_UP; break;
				case 'D': ch = SK_PAGE_DOWN; break;
				case 'h': ch = SK_HOME; break;
				case 'e': ch = SK_END; break;
				case 'x': ch = SK_DELETE; break;
				default:
					lkerr("illegal char after \\k");
					*pp = p+1;
					return ("");
				}
				*pp = p+1;
				buf[0] = SK_SPECIAL_KEY;
				buf[1] = ch;
				buf[2] = 6;
				buf[3] = 1;
				buf[4] = 1;
				buf[5] = 1;
				buf[6] = '\0';
				return (buf);
			}
			/* FALLTHRU */
		default:
			/*
			 * Backslash followed by any other char
			 * just means that char.
			 */
			*pp = p+1;
			buf[0] = *p;
			buf[1] = '\0';
			if (xlate && buf[0] == CONTROL('K'))
				return (tstr_control_k);
			return (buf);
		}
	case '^':
		/*
		 * Caret means CONTROL.
		 */
		*pp = p+2;
		buf[0] = CONTROL(p[1]);
		buf[1] = '\0';
		if (buf[0] == CONTROL('K'))
			return (tstr_control_k);
		return (buf);
	}
	*pp = p+1;
	buf[0] = *p;
	buf[1] = '\0';
	if (xlate && buf[0] == CONTROL('K'))
		return (tstr_control_k);
	return (buf);
}

/*
 * Skip leading spaces in a string.
 */
char *
skipsp(char *s)
{
	while (*s == ' ' || *s == '\t')
		s++;
	return (s);
}

/*
 * Skip non-space characters in a string.
 */
static char *
skipnsp(char *s)
{
	while (*s != '\0' && *s != ' ' && *s != '\t')
		s++;
	return (s);
}

/*
 * Clean up an input line:
 * strip off the trailing newline & any trailing # comment.
 */
static char *
clean_line(char *s)
{
	int i;

	s = skipsp(s);
	for (i = 0; s[i] != '\n' && s[i] != '\r' && s[i] != '\0'; i++)
		if (s[i] == '#' && (i == 0 || s[i-1] != '\\'))
			break;
	s[i] = '\0';
	return (s);
}

/*
 * Add a byte to the output command table.
 */
static void
add_cmd_char(int c)
{
	if (currtable->pbuffer >= currtable->buffer + MAX_USERCMD) {
		lkerr("too many commands");
		exit(1);
	}
	*(currtable->pbuffer)++ = (char)c;
}

/*
 * Add a string to the output command table.
 */
static void
add_cmd_str(char *s)
{
	for (; *s != '\0'; s++)
		add_cmd_char(*s);
}

/*
 * See if we have a special "control" line.
 */
static int
control_line(char *s)
{
#define	PREFIX(str, pat)	(strncmp(str, pat, strlen(pat)) == 0)

	if (PREFIX(s, "#line-edit")) {
		currtable = &edittable;
		return (1);
	}
	if (PREFIX(s, "#command")) {
		currtable = &cmdtable;
		return (1);
	}
	if (PREFIX(s, "#env")) {
		currtable = &vartable;
		return (1);
	}
	if (PREFIX(s, "#stop")) {
		add_cmd_char('\0');
		add_cmd_char(A_END_LIST);
		return (1);
	}
	return (0);
}

/*
 * Output some bytes.
 */
static void
fputbytes(FILE *fd, char *buf, int len)
{
	while (len-- > 0) {
		(void) fwrite(buf, sizeof (char), 1, fd);
		buf++;
	}
}

/*
 * Output an integer, in special KRADIX form.
 */
static void
fputint(FILE *fd, unsigned int val)
{
	char c;

	if (val >= KRADIX*KRADIX) {
		(void) fprintf(stderr, "error: integer too big (%d > %d)\n",
		    val, KRADIX*KRADIX);
		exit(1);
	}
	c = val % KRADIX;
	(void) fwrite(&c, sizeof (char), 1, fd);
	c = val / KRADIX;
	(void) fwrite(&c, sizeof (char), 1, fd);
}

/*
 * Find an action, given the name of the action.
 */
static int
findaction(char *actname)
{
	int i;

	for (i = 0; currtable->names[i].cn_name != NULL; i++)
		if (strcmp(currtable->names[i].cn_name, actname) == 0)
			return (currtable->names[i].cn_action);
	lkerr("unknown action");
	return (A_INVALID);
}

static void
lkerr(char *s)
{
	(void) fprintf(stderr, "line %d: %s\n", linenum, s);
	errors++;
}


static void
parse_cmdline(char *p)
{
	int cmdlen;
	char *actname;
	int action;
	char *s;
	char c;

	/*
	 * Parse the command string and store it in the current table.
	 */
	cmdlen = 0;
	do {
		s = tstr(&p, 1);
		cmdlen += strlen(s);
		if (cmdlen > MAX_CMDLEN)
			lkerr("command too long");
		else
			add_cmd_str(s);
	} while (*p != ' ' && *p != '\t' && *p != '\0');
	/*
	 * Terminate the command string with a null byte.
	 */
	add_cmd_char('\0');

	/*
	 * Skip white space between the command string
	 * and the action name.
	 * Terminate the action name with a null byte.
	 */
	p = skipsp(p);
	if (*p == '\0') {
		lkerr("missing action");
		return;
	}
	actname = p;
	p = skipnsp(p);
	c = *p;
	*p = '\0';

	/*
	 * Parse the action name and store it in the current table.
	 */
	action = findaction(actname);

	/*
	 * See if an extra string follows the action name.
	 */
	*p = c;
	p = skipsp(p);
	if (*p == '\0') {
		add_cmd_char(action);
	} else {
		/*
		 * OR the special value A_EXTRA into the action byte.
		 * Put the extra string after the action byte.
		 */
		add_cmd_char(action | A_EXTRA);
		while (*p != '\0')
			add_cmd_str(tstr(&p, 0));
		add_cmd_char('\0');
	}
}

static void
parse_varline(char *p)
{
	char *s;

	do {
		s = tstr(&p, 0);
		add_cmd_str(s);
	} while (*p != ' ' && *p != '\t' && *p != '=' && *p != '\0');
	/*
	 * Terminate the variable name with a null byte.
	 */
	add_cmd_char('\0');

	p = skipsp(p);
	if (*p++ != '=') {
		lkerr("missing =");
		return;
	}

	add_cmd_char(EV_OK|A_EXTRA);

	p = skipsp(p);
	while (*p != '\0') {
		s = tstr(&p, 0);
		add_cmd_str(s);
	}
	add_cmd_char('\0');
}

/*
 * Parse a line from the lesskey file.
 */
static void
parse_line(char *line)
{
	char *p;

	/*
	 * See if it is a control line.
	 */
	if (control_line(line))
		return;
	/*
	 * Skip leading white space.
	 * Replace the final newline with a null byte.
	 * Ignore blank lines and comments.
	 */
	p = clean_line(line);
	if (*p == '\0')
		return;

	if (currtable == &vartable)
		parse_varline(p);
	else
		parse_cmdline(p);
}

int
main(int argc, char **argv)
{
	FILE *desc;
	FILE *out;
	char line[1024];

	if (pledge("stdio rpath wpath cpath", NULL) == -1)
		err(1, "pledge");

	/*
	 * Process command line arguments.
	 */
	parse_args(argc, argv);
	init_tables();

	/*
	 * Open the input file.
	 */
	if (strcmp(infile, "-") == 0)
		desc = stdin;
	else if ((desc = fopen(infile, "r")) == NULL) {
		perror(infile);
		usage();
	}

	/*
	 * Read and parse the input file, one line at a time.
	 */
	errors = 0;
	linenum = 0;
	while (fgets(line, sizeof (line), desc) != NULL) {
		++linenum;
		parse_line(line);
	}
	fclose(desc);

	/*
	 * Write the output file.
	 * If no output file was specified, use "$HOME/.less"
	 */
	if (errors > 0) {
		(void) fprintf(stderr, "%d errors; no output produced\n",
		    errors);
		exit(1);
	}

	if (outfile == NULL)
		outfile = getenv("LESSKEY");
	if (outfile == NULL)
		outfile = homefile(LESSKEYFILE);
	if ((out = fopen(outfile, "wb")) == NULL) {
		perror(outfile);
		exit(1);
	}

	/* File header */
	fputbytes(out, fileheader, sizeof (fileheader));

	/* Command key section */
	fputbytes(out, cmdsection, sizeof (cmdsection));
	fputint(out, cmdtable.pbuffer - cmdtable.buffer);
	fputbytes(out, (char *)cmdtable.buffer,
	    cmdtable.pbuffer-cmdtable.buffer);

	/* Edit key section */
	fputbytes(out, editsection, sizeof (editsection));
	fputint(out, edittable.pbuffer - edittable.buffer);
	fputbytes(out, (char *)edittable.buffer,
	    edittable.pbuffer-edittable.buffer);

	/* Environment variable section */
	fputbytes(out, varsection, sizeof (varsection));
	fputint(out, vartable.pbuffer - vartable.buffer);
	fputbytes(out, (char *)vartable.buffer,
	    vartable.pbuffer-vartable.buffer);

	/* File trailer */
	fputbytes(out, endsection, sizeof (endsection));
	fputbytes(out, filetrailer, sizeof (filetrailer));
	fclose(out);
	return (0);
}
@


1.16
log
@style(9) includes

ok nicm@@
@
text
@d486 1
a486 1
	for (i = 0;  s[i] != '\n' && s[i] != '\r' && s[i] != '\0';  i++)
d583 1
a583 1
	for (i = 0;  currtable->names[i].cn_name != NULL;  i++)
@


1.15
log
@missing fclose(3). (silence cppcheck warnings).
OK mmcc@@
@
text
@d84 3
a88 3
#include "cmd.h"

#include <err.h>
@


1.14
log
@Most of these functions can be static.
@
text
@d756 1
d801 1
@


1.13
log
@if you're going to call err(), need to use <err.h>
@
text
@d95 1
a95 1
static void lkerr(char *s);
d218 1
a218 1
void
d225 1
a225 1
char *
d263 1
a263 1
void
d330 1
a330 1
void
d346 1
a346 1
char *
d468 1
a468 1
char *
d480 1
a480 1
char *
d496 1
a496 1
void
d509 1
a509 1
void
d519 1
a519 1
int
d547 1
a547 1
void
d559 1
a559 1
void
d578 1
a578 1
int
d590 1
a590 1
void
d598 1
a598 1
void
d663 1
a663 1
void
d696 1
a696 1
void
@


1.12
log
@Symbol table tells me to use pledge "stdio rpath wpath cpath"
@
text
@d88 2
@


1.11
log
@cleanup struct definitions
@
text
@d726 3
@


1.10
log
@Remove support for ! to run a shell command, we have ^Z around these
parts. ok ratchov jung millert
@
text
@d88 1
a88 2
struct cmdname
{
d95 1
a95 2
struct cmdname cmdnames[] =
{
d181 1
a181 2
struct table
{
@


1.9
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@a149 1
	{ "shell",			A_SHELL },
@


1.8
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.7
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

d17 1
a17 1
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
d27 1
a27 1
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
d29 1
a29 1
 *	The input file is an ascii file consisting of a 
d43 1
a43 1
 *		5. Any character (other than those mentioned above) preceded 
d50 1
a50 1
 *	Blank lines and lines which start with # are ignored, 
d61 1
a61 1
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
d69 1
a69 1
 *		END_SECTION	A special section header, with no 
d83 1
a83 1
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
d96 3
a98 1
struct cmdname cmdnames[] = 
d100 60
a159 59
	{ "back-bracket",         A_B_BRACKET },
	{ "back-line",            A_B_LINE },
	{ "back-line-force",      A_BF_LINE },
	{ "back-screen",          A_B_SCREEN },
	{ "back-scroll",          A_B_SCROLL },
	{ "back-search",          A_B_SEARCH },
	{ "back-window",          A_B_WINDOW },
	{ "debug",                A_DEBUG },
	{ "digit",                A_DIGIT },
	{ "display-flag",         A_DISP_OPTION },
	{ "display-option",       A_DISP_OPTION },
	{ "end",                  A_GOEND },
	{ "examine",              A_EXAMINE },
	{ "filter",               A_FILTER },
	{ "first-cmd",            A_FIRSTCMD },
	{ "firstcmd",             A_FIRSTCMD },
	{ "flush-repaint",        A_FREPAINT },
	{ "forw-bracket",         A_F_BRACKET },
	{ "forw-forever",         A_F_FOREVER },
	{ "forw-until-hilite",    A_F_UNTIL_HILITE },
	{ "forw-line",            A_F_LINE },
	{ "forw-line-force",      A_FF_LINE },
	{ "forw-screen",          A_F_SCREEN },
	{ "forw-screen-force",    A_FF_SCREEN },
	{ "forw-scroll",          A_F_SCROLL },
	{ "forw-search",          A_F_SEARCH },
	{ "forw-window",          A_F_WINDOW },
	{ "goto-end",             A_GOEND },
	{ "goto-line",            A_GOLINE },
	{ "goto-mark",            A_GOMARK },
	{ "help",                 A_HELP },
	{ "index-file",           A_INDEX_FILE },
	{ "invalid",              A_UINVALID },
	{ "left-scroll",          A_LSHIFT },
	{ "next-file",            A_NEXT_FILE },
	{ "next-tag",             A_NEXT_TAG },
	{ "noaction",             A_NOACTION },
	{ "percent",              A_PERCENT },
	{ "pipe",                 A_PIPE },
	{ "prev-file",            A_PREV_FILE },
	{ "prev-tag",             A_PREV_TAG },
	{ "quit",                 A_QUIT },
	{ "remove-file",          A_REMOVE_FILE },
	{ "repaint",              A_REPAINT },
	{ "repaint-flush",        A_FREPAINT },
	{ "repeat-search",        A_AGAIN_SEARCH },
	{ "repeat-search-all",    A_T_AGAIN_SEARCH },
	{ "reverse-search",       A_REVERSE_SEARCH },
	{ "reverse-search-all",   A_T_REVERSE_SEARCH },
	{ "right-scroll",         A_RSHIFT },
	{ "set-mark",             A_SETMARK },
	{ "shell",                A_SHELL },
	{ "status",               A_STAT },
	{ "toggle-flag",          A_OPT_TOGGLE },
	{ "toggle-option",        A_OPT_TOGGLE },
	{ "undo-hilite",          A_UNDO_SEARCH },
	{ "version",              A_VERSION },
	{ "visual",               A_VISUAL },
	{ NULL,   0 }
d162 1
a162 2
struct cmdname editnames[] = 
{
d199 3
a201 3
	C0_LESSKEY_MAGIC, 
	C1_LESSKEY_MAGIC, 
	C2_LESSKEY_MAGIC, 
d205 2
a206 2
	C0_END_LESSKEY_MAGIC, 
	C1_END_LESSKEY_MAGIC, 
d215 1
a215 1
char *outfile = NULL ;
d222 2
a223 2
	void
usage()
d225 1
a225 1
	fprintf(stderr, "usage: lesskey [-o output] [input]\n");
d229 2
a230 4
	char *
mkpathname(dirname, filename)
	char *dirname;
	char *filename;
d236 6
a241 4
	pathname = calloc(len, sizeof(char));
	strlcpy(pathname, dirname, len);
	strlcat(pathname, PATHNAME_SEP, len);
	strlcat(pathname, filename, len);
d248 2
a249 3
	char *
homefile(filename)
	char *filename;
d254 1
a254 4
	if ((p = getenv("HOME")) != NULL && *p != '\0')
		pathname = mkpathname(p, filename);
#if OS2
	else if ((p = getenv("INIT")) != NULL && *p != '\0')
d256 3
a258 4
#endif
	else
	{
		fprintf(stderr, "cannot find $HOME - using current directory\n");
d267 2
a268 4
	void
parse_args(argc, argv)
	int argc;
	char **argv;
d273 1
a273 2
	while (--argc > 0)
	{
d281 1
a281 2
		if (arg[1] == '-' && arg[2] == '\0')
		{
d287 1
a287 2
		switch (arg[1])
		{
d289 1
a289 2
			if (strncmp(arg, "--output", 8) == 0)
			{
d298 1
a298 2
			if (strcmp(arg, "--version") == 0)
			{
d306 1
a306 2
			if (*outfile == '\0')
			{
d314 1
a314 1
			printf("lesskey  version %s\n", version);
d334 2
a335 2
	void
init_tables()
d350 6
a355 8
	char *
tstr(pp, xlate)
	char **pp;
	int xlate;
{
	register char *p;
	register char ch;
	register int i;
d361 1
a361 2
	switch (*p)
	{
d364 1
a364 2
		switch (*p)
		{
d374 2
a375 1
			while (*++p >= '0' && *p <= '7' && ++i < 3);
d378 1
a378 1
				return tstr_control_k;
d400 2
a401 4
			if (xlate)
			{
				switch (*++p)
				{
d412 1
a412 1
					error("illegal char after \\k");
d429 1
a429 1
			 * Backslash followed by any other char 
d436 1
a436 1
				return tstr_control_k;
d447 1
a447 1
			return tstr_control_k;
d454 1
a454 1
		return tstr_control_k;
d461 2
a462 3
	public char *
skipsp(s)
	register char *s;
d464 1
a464 1
	while (*s == ' ' || *s == '\t')	
d472 2
a473 3
	public char *
skipnsp(s)
	register char *s;
d484 2
a485 3
	char *
clean_line(s)
	char *s;
d487 1
a487 1
	register int i;
d500 5
a504 7
	void
add_cmd_char(c)
	int c;
{
	if (currtable->pbuffer >= currtable->buffer + MAX_USERCMD)
	{
		error("too many commands");
d507 1
a507 1
	*(currtable->pbuffer)++ = c;
d513 2
a514 3
	void
add_cmd_str(s)
	char *s;
d516 1
a516 1
	for ( ;  *s != '\0';  s++)
d523 2
a524 3
	int
control_line(s)
	char *s;
d526 1
a526 1
#define	PREFIX(str,pat)	(strncmp(str,pat,strlen(pat)) == 0)
d528 1
a528 2
	if (PREFIX(s, "#line-edit"))
	{
d532 1
a532 2
	if (PREFIX(s, "#command"))
	{
d536 1
a536 2
	if (PREFIX(s, "#env"))
	{
d540 1
a540 2
	if (PREFIX(s, "#stop"))
	{
d551 5
a555 9
	void
fputbytes(fd, buf, len)
	FILE *fd;
	char *buf;
	int len;
{
	while (len-- > 0)
	{
		fwrite(buf, sizeof(char), 1, fd);
d563 2
a564 4
	void
fputint(fd, val)
	FILE *fd;
	unsigned int val;
d568 3
a570 4
	if (val >= KRADIX*KRADIX)
	{
		fprintf(stderr, "error: integer too big (%d > %d)\n", 
			val, KRADIX*KRADIX);
d574 1
a574 1
	fwrite(&c, sizeof(char), 1, fd);
d576 1
a576 1
	fwrite(&c, sizeof(char), 1, fd);
d582 2
a583 3
	int
findaction(actname)
	char *actname;
d590 1
a590 1
	error("unknown action");
d594 2
a595 3
	void
error(s)
	char *s;
d597 1
a597 1
	fprintf(stderr, "line %d: %s\n", linenum, s);
d602 2
a603 3
	void
parse_cmdline(p)
	char *p;
d615 1
a615 2
	do
	{
d619 1
a619 1
			error("command too long");
d634 2
a635 3
	if (*p == '\0')
	{
		error("missing action");
d653 1
a653 2
	if (*p == '\0')
	{
d655 1
a655 2
	} else
	{
d667 2
a668 3
	void
parse_varline(p)
	char *p;
d672 1
a672 2
	do
	{
d682 2
a683 3
	if (*p++ != '=')
	{
		error("missing =");
d690 1
a690 2
	while (*p != '\0')
	{
d700 2
a701 3
	void
parse_line(line)
	char *line;
d725 2
a726 4
	int
main(argc, argv)
	int argc;
	char *argv[];
a731 21
#ifdef WIN32
	if (getenv("HOME") == NULL)
	{
		/*
		 * If there is no HOME environment variable,
		 * try the concatenation of HOMEDRIVE + HOMEPATH.
		 */
		char *drive = getenv("HOMEDRIVE");
		char *path  = getenv("HOMEPATH");
		if (drive != NULL && path != NULL)
		{
			size_t len = strlen(drive) + strlen(path) + 6;
			char *env = (char *) calloc(len, sizeof(char));
			strlcpy(env, "HOME=", len);
			strlcat(env, drive, len);
			strlcat(env, path, len);
			putenv(env);
		}
	}
#endif /* WIN32 */

d743 1
a743 3
	else if ((desc = fopen(infile, "r")) == NULL)
	{
#if HAVE_PERROR
a744 3
#else
		fprintf(stderr, "Cannot open %s\n", infile);
#endif
d753 1
a753 2
	while (fgets(line, sizeof(line), desc) != NULL)
	{
d762 3
a764 3
	if (errors > 0)
	{
		fprintf(stderr, "%d errors; no output produced\n", errors);
d772 1
a772 3
	if ((out = fopen(outfile, "wb")) == NULL)
	{
#if HAVE_PERROR
a773 3
#else
		fprintf(stderr, "Cannot open %s\n", outfile);
#endif
d778 1
a778 1
	fputbytes(out, fileheader, sizeof(fileheader));
d781 1
a781 1
	fputbytes(out, cmdsection, sizeof(cmdsection));
d783 3
a785 1
	fputbytes(out, (char *)cmdtable.buffer, cmdtable.pbuffer-cmdtable.buffer);
d787 1
a787 1
	fputbytes(out, editsection, sizeof(editsection));
d789 2
a790 1
	fputbytes(out, (char *)edittable.buffer, edittable.pbuffer-edittable.buffer);
d793 1
a793 1
	fputbytes(out, varsection, sizeof(varsection)); 
d795 2
a796 1
	fputbytes(out, (char *)vartable.buffer, vartable.pbuffer-vartable.buffer);
d799 2
a800 2
	fputbytes(out, endsection, sizeof(endsection));
	fputbytes(out, filetrailer, sizeof(filetrailer));
@


1.6
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d114 1
d454 1
a454 1
		 * Carat means CONTROL.
@


1.5
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d96 58
a153 57
	{ "back-bracket",	A_B_BRACKET },
	{ "back-line",		A_B_LINE },
	{ "back-line-force",	A_BF_LINE },
	{ "back-screen",	A_B_SCREEN },
	{ "back-scroll",	A_B_SCROLL },
	{ "back-search",	A_B_SEARCH },
	{ "back-window",	A_B_WINDOW },
	{ "debug",		A_DEBUG },
	{ "digit",		A_DIGIT },
	{ "display-flag",	A_DISP_OPTION },
	{ "display-option",	A_DISP_OPTION },
	{ "end",		A_GOEND },
	{ "examine",		A_EXAMINE },
	{ "first-cmd",		A_FIRSTCMD },
	{ "firstcmd",		A_FIRSTCMD },
	{ "flush-repaint",	A_FREPAINT },
	{ "forw-bracket",	A_F_BRACKET },
	{ "forw-forever",	A_F_FOREVER },
	{ "forw-line",		A_F_LINE },
	{ "forw-line-force",	A_FF_LINE },
	{ "forw-screen",	A_F_SCREEN },
	{ "forw-screen-force",	A_FF_SCREEN },
	{ "forw-scroll",	A_F_SCROLL },
	{ "forw-search",	A_F_SEARCH },
	{ "forw-window",	A_F_WINDOW },
	{ "goto-end",		A_GOEND },
	{ "goto-line",		A_GOLINE },
	{ "goto-mark",		A_GOMARK },
	{ "help",		A_HELP },
	{ "index-file",		A_INDEX_FILE },
	{ "invalid",		A_UINVALID },
	{ "left-scroll",	A_LSHIFT },
	{ "next-file",		A_NEXT_FILE },
	{ "next-tag",		A_NEXT_TAG },
	{ "noaction",		A_NOACTION },
	{ "percent",		A_PERCENT },
	{ "pipe",		A_PIPE },
	{ "prev-file",		A_PREV_FILE },
	{ "prev-tag",		A_PREV_TAG },
	{ "quit",		A_QUIT },
	{ "remove-file",	A_REMOVE_FILE },
	{ "repaint",		A_REPAINT },
	{ "repaint-flush",	A_FREPAINT },
	{ "repeat-search",	A_AGAIN_SEARCH },
	{ "repeat-search-all",	A_T_AGAIN_SEARCH },
	{ "reverse-search",	A_REVERSE_SEARCH },
	{ "reverse-search-all",	A_T_REVERSE_SEARCH },
	{ "right-scroll",	A_RSHIFT },
	{ "set-mark",		A_SETMARK },
	{ "shell",		A_SHELL },
	{ "status",		A_STAT },
	{ "toggle-flag",	A_OPT_TOGGLE },
	{ "toggle-option",	A_OPT_TOGGLE },
	{ "undo-hilite",	A_UNDO_SEARCH },
	{ "version",		A_VERSION },
	{ "visual",		A_VISUAL },
	{ NULL, 0 }
d169 1
d546 1
a546 1
#define	PREFIX(str,pat)	(strncmp(str,pat,strlen(pat)-1) == 0)
@


1.4
log
@some more string shit; krw ok
@
text
@a0 2
/*	$OpenBSD: lesskey.c,v 1.3 2001/11/19 19:02:14 mpech Exp $	*/

d2 4
a5 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d7 2
a8 20
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d50 2
d54 2
d96 57
a152 50
	"back-bracket",		A_B_BRACKET,
	"back-line",		A_B_LINE,
	"back-line-force",	A_BF_LINE,
	"back-screen",		A_B_SCREEN,
	"back-scroll",		A_B_SCROLL,
	"back-search",		A_B_SEARCH,
	"back-window",		A_B_WINDOW,
	"debug",		A_DEBUG,
	"display-flag",		A_DISP_OPTION,
	"display-option",	A_DISP_OPTION,
	"end",			A_GOEND,
	"examine",		A_EXAMINE,
	"first-cmd",		A_FIRSTCMD,
	"firstcmd",		A_FIRSTCMD,
	"flush-repaint",	A_FREPAINT,
	"forw-bracket",		A_F_BRACKET,
	"forw-forever",		A_F_FOREVER,
	"forw-line",		A_F_LINE,
	"forw-line-force",	A_FF_LINE,
	"forw-screen",		A_F_SCREEN,
	"forw-scroll",		A_F_SCROLL,
	"forw-search",		A_F_SEARCH,
	"forw-window",		A_F_WINDOW,
	"goto-end",		A_GOEND,
	"goto-line",		A_GOLINE,
	"goto-mark",		A_GOMARK,
	"help",			A_HELP,
	"index-file",		A_INDEX_FILE,
	"invalid",		A_UINVALID,
	"next-file",		A_NEXT_FILE,
	"noaction",		A_NOACTION,
	"percent",		A_PERCENT,
	"pipe",			A_PIPE,
	"prev-file",		A_PREV_FILE,
	"quit",			A_QUIT,
	"repaint",		A_REPAINT,
	"repaint-flush",	A_FREPAINT,
	"repeat-search",	A_AGAIN_SEARCH,
	"repeat-search-all",	A_T_AGAIN_SEARCH,
	"reverse-search",	A_REVERSE_SEARCH,
	"reverse-search-all",	A_T_REVERSE_SEARCH,
	"set-mark",		A_SETMARK,
	"shell",		A_SHELL,
	"status",		A_STAT,
	"toggle-flag",		A_OPT_TOGGLE,
	"toggle-option",	A_OPT_TOGGLE,
	"undo-hilite",		A_UNDO_SEARCH,
	"version",		A_VERSION,
	"visual",		A_VISUAL,
	NULL,			0
d157 20
a176 20
	"back-complete",	EC_B_COMPLETE,
	"backspace",		EC_BACKSPACE,
	"delete",		EC_DELETE,
	"down",			EC_DOWN,
	"end",			EC_END,
	"expand",		EC_EXPAND,
	"forw-complete",	EC_F_COMPLETE,
	"home",			EC_HOME,
	"insert",		EC_INSERT,
	"invalid",		EC_UINVALID,
	"kill-line",		EC_LINEKILL,
	"left",			EC_LEFT,
	"literal",		EC_LITERAL,
	"right",		EC_RIGHT,
	"up",			EC_UP,
	"word-backspace",	EC_W_BACKSPACE,
	"word-delete",		EC_W_DELETE,
	"word-left",		EC_W_RIGHT,
	"word-right",		EC_W_LEFT,
	NULL,			0
d188 1
d204 1
d215 7
d233 1
a233 5
#if MSOFTC || OS2
	strlcat(pathname, "\\", len);
#else
	strlcat(pathname, "/", len);
#endif
d270 2
d273 1
a273 1
	while (--argc > 0 && **(++argv) == '-' && argv[0][1] != '\0')
d275 15
a289 1
		switch (argv[0][1])
d291 17
d310 1
d319 1
d348 3
d356 2
a357 2
	int
tchar(pp)
d359 1
d361 6
a366 3
	char *p;
	char ch;
	int i;
d386 5
a390 1
			return (ch);
d393 1
a393 1
			return ('\r');
d396 3
a398 1
			return (ESC);
d401 1
a401 1
			return ('\n');
d404 1
a404 1
			return ('\r');
d407 31
a437 1
			return ('\t');
d444 5
a448 1
			return (*p);
d455 5
a459 1
		return (CONTROL(p[1]));
d462 5
a466 1
	return (*p);
d474 1
a474 1
	char *s;
d486 1
a486 1
	char *s;
d501 1
a501 1
	int i;
d504 1
a504 1
	for (i = 0;  s[i] != '\n' && s[i] != '\0';  i++)
d527 11
d556 5
a623 6
usage()
{
	fprintf(stderr, "usage: lesskey [-o output] [input]\n");
	exit(1);
}

a632 3
/*
 * Parse a line from the lesskey file.
 */
d634 2
a635 2
parse_line(line)
	char *line;
a636 1
	char *p;
d640 2
a641 15
	int c;

	/*
	 * See if it is a control line.
	 */
	if (control_line(line))
		return;
	/*
	 * Skip leading white space.
	 * Replace the final newline with a null byte.
	 * Ignore blank lines and comments.
	 */
	p = clean_line(line);
	if (*p == '\0')
		return;
d649 3
a651 2
		c = tchar(&p);
		if (++cmdlen > MAX_CMDLEN)
d654 1
a654 1
			add_cmd_char(c);
d698 1
a698 1
			add_cmd_char(tchar(&p));
d703 64
d773 22
a794 1
	char line[200];
d809 1
d811 4
a814 1
		exit(1);
d839 2
d844 1
d846 3
d864 5
d872 1
a872 1
	exit(0);
@


1.3
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lesskey.c,v 1.2 2001/01/29 01:58:02 niklas Exp $	*/
d226 1
d228 3
a230 2
	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
d232 1
a232 1
	strcat(pathname, "\\");
d234 1
a234 1
	strcat(pathname, "/");
d236 1
a236 1
	strcat(pathname, filename);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d322 3
a324 3
	register char *p;
	register char ch;
	register int i;
d384 1
a384 1
	register char *s;
d396 1
a396 1
	register char *s;
d411 1
a411 1
	register int i;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 20
a24 5
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
a65 2
 *		#command	Signals the beginning of the command
 *				keys section.
a67 2
 *		#env		Signals the beginning of the environment
 *				variable section.
d108 50
a157 57
	{ "back-bracket",	A_B_BRACKET },
	{ "back-line",		A_B_LINE },
	{ "back-line-force",	A_BF_LINE },
	{ "back-screen",	A_B_SCREEN },
	{ "back-scroll",	A_B_SCROLL },
	{ "back-search",	A_B_SEARCH },
	{ "back-window",	A_B_WINDOW },
	{ "debug",		A_DEBUG },
	{ "digit",		A_DIGIT },
	{ "display-flag",	A_DISP_OPTION },
	{ "display-option",	A_DISP_OPTION },
	{ "end",		A_GOEND },
	{ "examine",		A_EXAMINE },
	{ "first-cmd",		A_FIRSTCMD },
	{ "firstcmd",		A_FIRSTCMD },
	{ "flush-repaint",	A_FREPAINT },
	{ "forw-bracket",	A_F_BRACKET },
	{ "forw-forever",	A_F_FOREVER },
	{ "forw-line",		A_F_LINE },
	{ "forw-line-force",	A_FF_LINE },
	{ "forw-screen",	A_F_SCREEN },
	{ "forw-screen-force",	A_FF_SCREEN },
	{ "forw-scroll",	A_F_SCROLL },
	{ "forw-search",	A_F_SEARCH },
	{ "forw-window",	A_F_WINDOW },
	{ "goto-end",		A_GOEND },
	{ "goto-line",		A_GOLINE },
	{ "goto-mark",		A_GOMARK },
	{ "help",		A_HELP },
	{ "index-file",		A_INDEX_FILE },
	{ "invalid",		A_UINVALID },
	{ "left-scroll",	A_LSHIFT },
	{ "next-file",		A_NEXT_FILE },
	{ "next-tag",		A_NEXT_TAG },
	{ "noaction",		A_NOACTION },
	{ "percent",		A_PERCENT },
	{ "pipe",		A_PIPE },
	{ "prev-file",		A_PREV_FILE },
	{ "prev-tag",		A_PREV_TAG },
	{ "quit",		A_QUIT },
	{ "remove-file",	A_REMOVE_FILE },
	{ "repaint",		A_REPAINT },
	{ "repaint-flush",	A_FREPAINT },
	{ "repeat-search",	A_AGAIN_SEARCH },
	{ "repeat-search-all",	A_T_AGAIN_SEARCH },
	{ "reverse-search",	A_REVERSE_SEARCH },
	{ "reverse-search-all",	A_T_REVERSE_SEARCH },
	{ "right-scroll",	A_RSHIFT },
	{ "set-mark",		A_SETMARK },
	{ "shell",		A_SHELL },
	{ "status",		A_STAT },
	{ "toggle-flag",	A_OPT_TOGGLE },
	{ "toggle-option",	A_OPT_TOGGLE },
	{ "undo-hilite",	A_UNDO_SEARCH },
	{ "version",		A_VERSION },
	{ "visual",		A_VISUAL },
	{ NULL, 0 }
d162 20
a181 20
	{ "back-complete",	EC_B_COMPLETE },
	{ "backspace",		EC_BACKSPACE },
	{ "delete",		EC_DELETE },
	{ "down",		EC_DOWN },
	{ "end",		EC_END },
	{ "expand",		EC_EXPAND },
	{ "forw-complete",	EC_F_COMPLETE },
	{ "home",		EC_HOME },
	{ "insert",		EC_INSERT },
	{ "invalid",		EC_UINVALID },
	{ "kill-line",		EC_LINEKILL },
	{ "left",		EC_LEFT },
	{ "literal",		EC_LITERAL },
	{ "right",		EC_RIGHT },
	{ "up",			EC_UP },
	{ "word-backspace",	EC_W_BACKSPACE },
	{ "word-delete",	EC_W_DELETE },
	{ "word-left",		EC_W_LEFT },
	{ "word-right",		EC_W_RIGHT },
	{ NULL, 0 }
a192 1
struct table vartable;
a207 1
char varsection[1] =	{ VAR_SECTION };
a217 7
	void
usage()
{
	fprintf(stderr, "usage: lesskey [-o output] [input]\n");
	exit(1);
}

d227 5
a231 1
	strcat(pathname, PATHNAME_SEP);
a267 2
	char *arg;

d269 1
a269 1
	while (--argc > 0)
d271 1
a271 15
		arg = *++argv;
		if (arg[0] != '-')
			/* Arg does not start with "-"; it's not an option. */
			break;
		if (arg[1] == '\0')
			/* "-" means standard input. */
			break;
		if (arg[1] == '-' && arg[2] == '\0')
		{
			/* "--" means end of options. */
			argc--;
			argv++;
			break;
		}
		switch (arg[1])
a272 17
		case '-':
			if (strncmp(arg, "--output", 8) == 0)
			{
				if (arg[8] == '\0')
					outfile = &arg[8];
				else if (arg[8] == '=')
					outfile = &arg[9];
				else
					usage();
				goto opt_o;
			}
			if (strcmp(arg, "--version") == 0)
			{
				goto opt_V;
			}
			usage();
			break;
a274 1
		opt_o:
a282 1
		opt_V:
a310 3

	vartable.names = NULL;
	vartable.pbuffer = vartable.buffer;
d316 2
a317 2
	char *
tstr(pp, xlate)
a318 1
	int xlate;
a322 3
	static char buf[10];
	static char tstr_control_k[] =
		{ SK_SPECIAL_KEY, SK_CONTROL_K, 6, 1, 1, 1, '\0' };
d342 1
a342 5
			if (xlate && ch == CONTROL('K'))
				return tstr_control_k;
			buf[0] = ch;
			buf[1] = '\0';
			return (buf);
d345 1
a345 1
			return ("\b");
d348 1
a348 3
			buf[0] = ESC;
			buf[1] = '\0';
			return (buf);
d351 1
a351 1
			return ("\n");
d354 1
a354 1
			return ("\r");
d357 1
a357 31
			return ("\t");
		case 'k':
			if (xlate)
			{
				switch (*++p)
				{
				case 'u': ch = SK_UP_ARROW; break;
				case 'd': ch = SK_DOWN_ARROW; break;
				case 'r': ch = SK_RIGHT_ARROW; break;
				case 'l': ch = SK_LEFT_ARROW; break;
				case 'U': ch = SK_PAGE_UP; break;
				case 'D': ch = SK_PAGE_DOWN; break;
				case 'h': ch = SK_HOME; break;
				case 'e': ch = SK_END; break;
				case 'x': ch = SK_DELETE; break;
				default:
					error("illegal char after \\k");
					*pp = p+1;
					return ("");
				}
				*pp = p+1;
				buf[0] = SK_SPECIAL_KEY;
				buf[1] = ch;
				buf[2] = 6;
				buf[3] = 1;
				buf[4] = 1;
				buf[5] = 1;
				buf[6] = '\0';
				return (buf);
			}
			/* FALLTHRU */
d364 1
a364 5
			buf[0] = *p;
			buf[1] = '\0';
			if (xlate && buf[0] == CONTROL('K'))
				return tstr_control_k;
			return (buf);
d371 1
a371 5
		buf[0] = CONTROL(p[1]);
		buf[1] = '\0';
		if (buf[0] == CONTROL('K'))
			return tstr_control_k;
		return (buf);
d374 1
a374 5
	buf[0] = *p;
	buf[1] = '\0';
	if (xlate && buf[0] == CONTROL('K'))
		return tstr_control_k;
	return (buf);
d412 1
a412 1
	for (i = 0;  s[i] != '\n' && s[i] != '\r' && s[i] != '\0';  i++)
a434 11
 * Add a string to the output command table.
 */
	void
add_cmd_str(s)
	char *s;
{
	for ( ;  *s != '\0';  s++)
		add_cmd_char(*s);
}

/*
a452 5
	if (PREFIX(s, "#env"))
	{
		currtable = &vartable;
		return (1);
	}
d516 6
d531 3
d535 3
a537 1
parse_cmdline(p)
a538 1
{
d542 15
a556 2
	char *s;
	char c;
d564 2
a565 3
		s = tstr(&p, 1);
		cmdlen += strlen(s);
		if (cmdlen > MAX_CMDLEN)
d568 1
a568 1
			add_cmd_str(s);
d612 1
a612 1
			add_cmd_str(tstr(&p, 0));
a616 64
	void
parse_varline(p)
	char *p;
{
	char *s;

	do
	{
		s = tstr(&p, 0);
		add_cmd_str(s);
	} while (*p != ' ' && *p != '\t' && *p != '=' && *p != '\0');
	/*
	 * Terminate the variable name with a null byte.
	 */
	add_cmd_char('\0');

	p = skipsp(p);
	if (*p++ != '=')
	{
		error("missing =");
		return;
	}

	add_cmd_char(EV_OK|A_EXTRA);

	p = skipsp(p);
	while (*p != '\0')
	{
		s = tstr(&p, 0);
		add_cmd_str(s);
	}
	add_cmd_char('\0');
}

/*
 * Parse a line from the lesskey file.
 */
	void
parse_line(line)
	char *line;
{
	char *p;

	/*
	 * See if it is a control line.
	 */
	if (control_line(line))
		return;
	/*
	 * Skip leading white space.
	 * Replace the final newline with a null byte.
	 * Ignore blank lines and comments.
	 */
	p = clean_line(line);
	if (*p == '\0')
		return;

	if (currtable == &vartable)
		parse_varline(p);
	else
		parse_cmdline(p);
}

	int
d623 1
a623 22
	char line[1024];

#ifdef WIN32
	if (getenv("HOME") == NULL)
	{
		/*
		 * If there is no HOME environment variable,
		 * try the concatenation of HOMEDRIVE + HOMEPATH.
		 */
		char *drive = getenv("HOMEDRIVE");
		char *path  = getenv("HOMEPATH");
		if (drive != NULL && path != NULL)
		{
			char *env = (char *) calloc(strlen(drive) + 
					strlen(path) + 6, sizeof(char));
			strcpy(env, "HOME=");
			strcat(env, drive);
			strcat(env, path);
			putenv(env);
		}
	}
#endif /* WIN32 */
a637 1
#if HAVE_PERROR
d639 1
a639 4
#else
		fprintf(stderr, "Cannot open %s\n", infile);
#endif
		usage();
a663 2
		outfile = getenv("LESSKEY");
	if (outfile == NULL)
a666 1
#if HAVE_PERROR
a667 3
#else
		fprintf(stderr, "Cannot open %s\n", outfile);
#endif
a682 5
	/* Environment variable section */
	fputbytes(out, varsection, sizeof(varsection)); 
	fputint(out, vartable.pbuffer - vartable.buffer);
	fputbytes(out, (char *)vartable.buffer, vartable.pbuffer-vartable.buffer);

d686 1
a686 1
	return (0);
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d96 57
a152 58
	{ "back-bracket",         A_B_BRACKET },
	{ "back-line",            A_B_LINE },
	{ "back-line-force",      A_BF_LINE },
	{ "back-screen",          A_B_SCREEN },
	{ "back-scroll",          A_B_SCROLL },
	{ "back-search",          A_B_SEARCH },
	{ "back-window",          A_B_WINDOW },
	{ "debug",                A_DEBUG },
	{ "digit",                A_DIGIT },
	{ "display-flag",         A_DISP_OPTION },
	{ "display-option",       A_DISP_OPTION },
	{ "end",                  A_GOEND },
	{ "examine",              A_EXAMINE },
	{ "filter",               A_FILTER },
	{ "first-cmd",            A_FIRSTCMD },
	{ "firstcmd",             A_FIRSTCMD },
	{ "flush-repaint",        A_FREPAINT },
	{ "forw-bracket",         A_F_BRACKET },
	{ "forw-forever",         A_F_FOREVER },
	{ "forw-line",            A_F_LINE },
	{ "forw-line-force",      A_FF_LINE },
	{ "forw-screen",          A_F_SCREEN },
	{ "forw-screen-force",    A_FF_SCREEN },
	{ "forw-scroll",          A_F_SCROLL },
	{ "forw-search",          A_F_SEARCH },
	{ "forw-window",          A_F_WINDOW },
	{ "goto-end",             A_GOEND },
	{ "goto-line",            A_GOLINE },
	{ "goto-mark",            A_GOMARK },
	{ "help",                 A_HELP },
	{ "index-file",           A_INDEX_FILE },
	{ "invalid",              A_UINVALID },
	{ "left-scroll",          A_LSHIFT },
	{ "next-file",            A_NEXT_FILE },
	{ "next-tag",             A_NEXT_TAG },
	{ "noaction",             A_NOACTION },
	{ "percent",              A_PERCENT },
	{ "pipe",                 A_PIPE },
	{ "prev-file",            A_PREV_FILE },
	{ "prev-tag",             A_PREV_TAG },
	{ "quit",                 A_QUIT },
	{ "remove-file",          A_REMOVE_FILE },
	{ "repaint",              A_REPAINT },
	{ "repaint-flush",        A_FREPAINT },
	{ "repeat-search",        A_AGAIN_SEARCH },
	{ "repeat-search-all",    A_T_AGAIN_SEARCH },
	{ "reverse-search",       A_REVERSE_SEARCH },
	{ "reverse-search-all",   A_T_REVERSE_SEARCH },
	{ "right-scroll",         A_RSHIFT },
	{ "set-mark",             A_SETMARK },
	{ "shell",                A_SHELL },
	{ "status",               A_STAT },
	{ "toggle-flag",          A_OPT_TOGGLE },
	{ "toggle-option",        A_OPT_TOGGLE },
	{ "undo-hilite",          A_UNDO_SEARCH },
	{ "version",              A_VERSION },
	{ "visual",               A_VISUAL },
	{ NULL,   0 }
a167 1
	{ "abort",		EC_ABORT },
d542 1
a542 1
#define	PREFIX(str,pat)	(strncmp(str,pat,strlen(pat)) == 0)
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
a114 1
	{ "forw-until-hilite",    A_F_UNTIL_HILITE },
a229 1
	size_t len;
d231 4
a234 5
	len = strlen(dirname) + strlen(filename) + 2;
	pathname = calloc(len, sizeof(char));
	strlcpy(pathname, dirname, len);
	strlcat(pathname, PATHNAME_SEP, len);
	strlcat(pathname, filename, len);
d452 1
a452 1
		 * Caret means CONTROL.
d786 5
a790 5
			size_t len = strlen(drive) + strlen(path) + 6;
			char *env = (char *) calloc(len, sizeof(char));
			strlcpy(env, "HOME=", len);
			strlcat(env, drive, len);
			strlcat(env, path, len);
@


