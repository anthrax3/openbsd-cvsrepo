head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.5.0.12
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.4.0.34
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.32
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.30
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.26
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.28
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.24
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	W32EN7Zp77efb8wW;

1.10
date	2016.01.12.17.48.04;	author mmcc;	state Exp;
branches;
next	1.9;
commitid	O36S2Tb0ReI34f9s;

1.9
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	ZtGimechwgSRYqRW;

1.8
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.7;
commitid	QKrr6AuGzNx9nehL;

1.7
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.6;
commitid	yKv9Ck9ZDgwWTRTo;

1.6
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.5;

1.5
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.13.18.26.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.05;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.48;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.11
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Routines which jump to a new location in the file.
 */

#include "less.h"
#include "position.h"

extern int jump_sline;
extern int squished;
extern int screen_trashed;
extern int sc_width, sc_height;
extern int show_attn;
extern int top_scroll;

/*
 * Jump to the end of the file.
 */
void
jump_forw(void)
{
	off_t pos;
	off_t end_pos;

	if (ch_end_seek()) {
		error("Cannot seek to end of file", NULL);
		return;
	}
	/*
	 * Note; lastmark will be called later by jump_loc, but it fails
	 * because the position table has been cleared by pos_clear below.
	 * So call it here before calling pos_clear.
	 */
	lastmark();
	/*
	 * Position the last line in the file at the last screen line.
	 * Go back one line from the end of the file
	 * to get to the beginning of the last line.
	 */
	pos_clear();
	end_pos = ch_tell();
	pos = back_line(end_pos);
	if (pos == -1) {
		jump_loc(0, sc_height-1);
	} else {
		jump_loc(pos, sc_height-1);
		if (position(sc_height-1) != end_pos)
			repaint();
	}
}

/*
 * Jump to line n in the file.
 */
void
jump_back(off_t linenum)
{
	off_t pos;
	PARG parg;

	/*
	 * Find the position of the specified line.
	 * If we can seek there, just jump to it.
	 * If we can't seek, but we're trying to go to line number 1,
	 * use ch_beg_seek() to get as close as we can.
	 */
	pos = find_pos(linenum);
	if (pos != -1 && ch_seek(pos) == 0) {
		if (show_attn)
			set_attnpos(pos);
		jump_loc(pos, jump_sline);
	} else if (linenum <= 1 && ch_beg_seek() == 0) {
		jump_loc(ch_tell(), jump_sline);
		error("Cannot seek to beginning of file", NULL);
	} else {
		parg.p_linenum = linenum;
		error("Cannot seek to line number %n", &parg);
	}
}

/*
 * Repaint the screen.
 */
void
repaint(void)
{
	struct scrpos scrpos;
	/*
	 * Start at the line currently at the top of the screen
	 * and redisplay the screen.
	 */
	get_scrpos(&scrpos);
	pos_clear();
	jump_loc(scrpos.pos, scrpos.ln);
}

/*
 * Jump to a specified percentage into the file.
 */
void
jump_percent(int percent, long fraction)
{
	off_t pos, len;

	/*
	 * Determine the position in the file
	 * (the specified percentage of the file's length).
	 */
	if ((len = ch_length()) == -1) {
		ierror("Determining length of file", NULL);
		ch_end_seek();
	}
	if ((len = ch_length()) == -1) {
		error("Don't know length of file", NULL);
		return;
	}
	pos = percent_pos(len, percent, fraction);
	if (pos >= len)
		pos = len-1;

	jump_line_loc(pos, jump_sline);
}

/*
 * Jump to a specified position in the file.
 * Like jump_loc, but the position need not be
 * the first character in a line.
 */
void
jump_line_loc(off_t pos, int sline)
{
	int c;

	if (ch_seek(pos) == 0) {
		/*
		 * Back up to the beginning of the line.
		 */
		while ((c = ch_back_get()) != '\n' && c != EOI)
			;
		if (c == '\n')
			(void) ch_forw_get();
		pos = ch_tell();
	}
	if (show_attn)
		set_attnpos(pos);
	jump_loc(pos, sline);
}

/*
 * Jump to a specified position in the file.
 * The position must be the first character in a line.
 * Place the target line on a specified line on the screen.
 */
void
jump_loc(off_t pos, int sline)
{
	int nline;
	off_t tpos;
	off_t bpos;

	/*
	 * Normalize sline.
	 */
	sline = adjsline(sline);

	if ((nline = onscreen(pos)) >= 0) {
		/*
		 * The line is currently displayed.
		 * Just scroll there.
		 */
		nline -= sline;
		if (nline > 0)
			forw(nline, position(BOTTOM_PLUS_ONE), 1, 0, 0);
		else
			back(-nline, position(TOP), 1, 0);
		if (show_attn)
			repaint_hilite(1);
		return;
	}

	/*
	 * Line is not on screen.
	 * Seek to the desired location.
	 */
	if (ch_seek(pos)) {
		error("Cannot seek to that file position", NULL);
		return;
	}

	/*
	 * See if the desired line is before or after
	 * the currently displayed screen.
	 */
	tpos = position(TOP);
	bpos = position(BOTTOM_PLUS_ONE);
	if (tpos == -1 || pos >= tpos) {
		/*
		 * The desired line is after the current screen.
		 * Move back in the file far enough so that we can
		 * call forw() and put the desired line at the
		 * sline-th line on the screen.
		 */
		for (nline = 0; nline < sline; nline++) {
			if (bpos != -1 && pos <= bpos) {
				/*
				 * Surprise!  The desired line is
				 * close enough to the current screen
				 * that we can just scroll there after all.
				 */
				forw(sc_height-sline+nline-1, bpos, 1, 0, 0);
				if (show_attn)
					repaint_hilite(1);
				return;
			}
			pos = back_line(pos);
			if (pos == -1) {
				/*
				 * Oops.  Ran into the beginning of the file.
				 * Exit the loop here and rely on forw()
				 * below to draw the required number of
				 * blank lines at the top of the screen.
				 */
				break;
			}
		}
		lastmark();
		squished = 0;
		screen_trashed = 0;
		forw(sc_height-1, pos, 1, 0, sline-nline);
	} else {
		/*
		 * The desired line is before the current screen.
		 * Move forward in the file far enough so that we
		 * can call back() and put the desired line at the
		 * sline-th line on the screen.
		 */
		for (nline = sline; nline < sc_height - 1; nline++) {
			pos = forw_line(pos);
			if (pos == -1) {
				/*
				 * Ran into end of file.
				 * This shouldn't normally happen,
				 * but may if there is some kind of read error.
				 */
				break;
			}
			if (pos >= tpos) {
				/*
				 * Surprise!  The desired line is
				 * close enough to the current screen
				 * that we can just scroll there after all.
				 */
				back(nline + 1, tpos, 1, 0);
				if (show_attn)
					repaint_hilite(1);
				return;
			}
		}
		lastmark();
		if (!top_scroll)
			do_clear();
		else
			home();
		screen_trashed = 0;
		add_back_pos(pos);
		back(sc_height-1, pos, 1, 0);
	}
}
@


1.10
log
@Remove LINUNUM, a needless alias for off_t. Also, remove a redundant
condition.

ok nicm@@
@
text
@d213 1
a213 1
		for (nline = 0;  nline < sline;  nline++) {
d247 1
a247 1
		for (nline = sline;  nline < sc_height - 1;  nline++) {
@


1.9
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@d66 1
a66 1
jump_back(LINENUM linenum)
@


1.8
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d36 1
a36 1
		error("Cannot seek to end of file", NULL_PARG);
d84 1
a84 1
		error("Cannot seek to beginning of file", NULL_PARG);
d120 1
a120 1
		ierror("Determining length of file", NULL_PARG);
d124 1
a124 1
		error("Don't know length of file", NULL_PARG);
d196 1
a196 1
		error("Cannot seek to that file position", NULL_PARG);
@


1.7
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.6
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

d31 2
a32 2
	public void
jump_forw()
d34 2
a35 2
	POSITION pos;
	POSITION end_pos;
d37 1
a37 2
	if (ch_end_seek())
	{
d41 1
a41 1
	/* 
d55 3
a57 4
	if (pos == NULL_POSITION)
		jump_loc((POSITION)0, sc_height-1);
	else
	{
d67 2
a68 3
	public void
jump_back(linenum)
	LINENUM linenum;
d70 1
a70 1
	POSITION pos;
d80 1
a80 2
	if (pos != NULL_POSITION && ch_seek(pos) == 0)
	{
d84 1
a84 2
	} else if (linenum <= 1 && ch_beg_seek() == 0)
	{
d87 1
a87 2
	} else
	{
d96 2
a97 2
	public void
repaint()
d112 2
a113 4
	public void
jump_percent(percent, fraction)
	int percent;
	long fraction;
d115 1
a115 1
	POSITION pos, len;
d121 1
a121 2
	if ((len = ch_length()) == NULL_POSITION)
	{
d125 1
a125 2
	if ((len = ch_length()) == NULL_POSITION)
	{
d138 1
a138 1
 * Like jump_loc, but the position need not be 
d141 2
a142 4
	public void
jump_line_loc(pos, sline)
	POSITION pos;
	int sline;
d146 1
a146 2
	if (ch_seek(pos) == 0)
	{
d166 2
a167 4
	public void
jump_loc(pos, sline)
	POSITION pos;
	int sline;
d169 3
a171 3
	register int nline;
	POSITION tpos;
	POSITION bpos;
d178 1
a178 2
	if ((nline = onscreen(pos)) >= 0)
	{
d180 1
a180 1
		 * The line is currently displayed.  
a187 1
#if HILITE_SEARCH
a189 1
#endif
d197 1
a197 2
	if (ch_seek(pos))
	{
d203 1
a203 1
	 * See if the desired line is before or after 
d208 1
a208 2
	if (tpos == NULL_POSITION || pos >= tpos)
	{
d212 1
a212 1
		 * call forw() and put the desired line at the 
d215 2
a216 4
		for (nline = 0;  nline < sline;  nline++)
		{
			if (bpos != NULL_POSITION && pos <= bpos)
			{
a222 1
#if HILITE_SEARCH
a224 1
#endif
d228 1
a228 2
			if (pos == NULL_POSITION)
			{
d242 1
a242 2
	} else
	{
d246 1
a246 1
		 * can call back() and put the desired line at the 
d249 1
a249 2
		for (nline = sline;  nline < sc_height - 1;  nline++)
		{
d251 1
a251 2
			if (pos == NULL_POSITION)
			{
d254 1
a254 1
				 * This shouldn't normally happen, 
d259 2
a260 3
			if (pos >= tpos)
			{
				/* 
d265 1
a265 2
				back(nline+1, tpos, 1, 0);
#if HILITE_SEARCH
a267 1
#endif
d273 1
a273 1
			clear();
@


1.5
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
@


1.4
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
a18 1
extern int hit_eof;
d24 1
d33 1
d40 6
d51 3
a53 1
	pos = back_line(ch_tell());
d57 1
d59 3
d117 1
a117 1
jump_percent(percent)
d119 1
d137 1
a137 1
	pos = percent_pos(len, percent);
d202 1
d205 1
d243 1
d246 1
a261 1
		hit_eof = 0;
d293 1
d296 1
d301 4
a304 1
		clear();
@


1.3
log
@kill more registers

millert@@ ok
@
text
@a0 2
/*	$OpenBSD: jump.c,v 1.2 2001/01/29 01:58:02 niklas Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d24 1
d55 2
a56 2
jump_back(n)
	int n;
d67 1
a67 1
	pos = find_pos(n);
d70 2
d73 1
a73 1
	} else if (n <= 1 && ch_beg_seek() == 0)
d79 2
a80 2
		parg.p_int = n;
		error("Cannot seek to line number %d", &parg);
d123 1
a123 4
	/*
	 * {{ This calculation may overflow! }}
	 */
	pos = (percent * len) / 100;
d153 2
d168 1
a168 1
	int nline;
d188 2
d227 2
d276 2
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d184 1
a184 1
	register int nline;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
a39 1
extern int show_attn;
d70 2
a71 2
jump_back(linenum)
	LINENUM linenum;
d82 1
a82 1
	pos = find_pos(linenum);
a84 2
		if (show_attn)
			set_attnpos(pos);
d86 1
a86 1
	} else if (linenum <= 1 && ch_beg_seek() == 0)
d92 2
a93 2
		parg.p_linenum = linenum;
		error("Cannot seek to line number %n", &parg);
d136 4
a139 1
	pos = percent_pos(len, percent);
a168 2
	if (show_attn)
		set_attnpos(pos);
a201 2
		if (show_attn)
			repaint_hilite(1);
a238 2
				if (show_attn)
					repaint_hilite(1);
a285 2
				if (show_attn)
					repaint_hilite(1);
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d19 1
a24 1
extern int top_scroll;
a32 1
	POSITION end_pos;
a38 6
	/* 
	 * Note; lastmark will be called later by jump_loc, but it fails
	 * because the position table has been cleared by pos_clear below.
	 * So call it here before calling pos_clear.
	 */
	lastmark();
d44 1
a44 3
	pos_clear();
	end_pos = ch_tell();
	pos = back_line(end_pos);
a47 1
	{
a48 3
		if (position(sc_height-1) != end_pos)
			repaint();
	}
d104 1
a104 1
jump_percent(percent, fraction)
a105 1
	long fraction;
d123 1
a123 1
	pos = percent_pos(len, percent, fraction);
a187 1
#if HILITE_SEARCH
a189 1
#endif
a226 1
#if HILITE_SEARCH
a228 1
#endif
d244 1
a275 1
#if HILITE_SEARCH
a277 1
#endif
d282 1
a282 4
		if (!top_scroll)
			clear();
		else
			home();
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
@


