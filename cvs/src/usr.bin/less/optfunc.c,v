head	1.16;
access;
symbols
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.7.0.12
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.8
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.6
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	W32EN7Zp77efb8wW;

1.15
date	2016.02.03.15.47.27;	author mmcc;	state Exp;
branches;
next	1.14;
commitid	QAFGgFVsaQEzstuy;

1.14
date	2016.01.12.23.01.23;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	5Pl94glX7ncfN0bb;

1.13
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	ZtGimechwgSRYqRW;

1.12
date	2015.11.07.18.07.44;	author tedu;	state Exp;
branches;
next	1.11;
commitid	DJUwzdj0cG1bCfEw;

1.11
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.10;
commitid	QKrr6AuGzNx9nehL;

1.10
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.9;
commitid	yKv9Ck9ZDgwWTRTo;

1.9
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.09.20.50.36;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.03.16.29.46;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.14.14.33.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.03;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.06;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.49;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.16
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Handling functions for command line options.
 *
 * Most options are handled by the generic code in option.c.
 * But all string options, and a few non-string options, require
 * special handling specific to the particular option.
 * This special processing is done by the "handling functions" in this file.
 *
 * Each handling function is passed a "type" and, if it is a string
 * option, the string which should be "assigned" to the option.
 * The type may be one of:
 *	INIT	The option is being initialized from the command line.
 *	TOGGLE	The option is being changed from within the program.
 *	QUERY	The setting of the option is merely being queried.
 */

#include "less.h"
#include "option.h"

extern int bufspace;
extern int pr_type;
extern int plusoption;
extern int swindow;
extern int sc_width;
extern int sc_height;
extern int secure;
extern int dohelp;
extern int any_display;
extern char openquote;
extern char closequote;
extern char *prproto[];
extern char *eqproto;
extern char *hproto;
extern char *wproto;
extern IFILE curr_ifile;
extern char version[];
extern int jump_sline;
extern int jump_sline_fraction;
extern int less_is_more;
extern char *namelogfile;
extern int force_logfile;
extern int logfile;
char *tagoption = NULL;
extern char *tags;

int shift_count;	/* Number of positions to shift horizontally */
static int shift_count_fraction = -1;

/*
 * Handler for -o option.
 */
void
opt_o(int type, char *s)
{
	PARG parg;

	if (secure) {
		error("log file support is not available", NULL);
		return;
	}
	switch (type) {
	case INIT:
		namelogfile = s;
		break;
	case TOGGLE:
		if (ch_getflags() & CH_CANSEEK) {
			error("Input is not a pipe", NULL);
			return;
		}
		if (logfile >= 0) {
			error("Log file is already in use", NULL);
			return;
		}
		s = skipsp(s);
		namelogfile = lglob(s);
		use_logfile(namelogfile);
		sync_logfile();
		break;
	case QUERY:
		if (logfile < 0) {
			error("No log file", NULL);
		} else {
			parg.p_string = namelogfile;
			error("Log file \"%s\"", &parg);
		}
		break;
	}
}

/*
 * Handler for -O option.
 */
void
opt__O(int type, char *s)
{
	force_logfile = TRUE;
	opt_o(type, s);
}

/*
 * Handlers for -j option.
 */
void
opt_j(int type, char *s)
{
	PARG parg;
	char buf[16];
	int len;
	int err;

	switch (type) {
	case INIT:
	case TOGGLE:
		if (*s == '.') {
			s++;
			jump_sline_fraction = getfraction(&s, "j", &err);
			if (err)
				error("Invalid line fraction", NULL);
			else
				calc_jump_sline();
		} else {
			int sline = getnum(&s, "j", &err);
			if (err) {
				error("Invalid line number", NULL);
			} else {
				jump_sline = sline;
				jump_sline_fraction = -1;
			}
		}
		break;
	case QUERY:
		if (jump_sline_fraction < 0) {
			parg.p_int =  jump_sline;
			error("Position target at screen line %d", &parg);
		} else {
			(void) snprintf(buf, sizeof (buf), ".%06d",
			    jump_sline_fraction);
			len = strlen(buf);
			while (len > 2 && buf[len-1] == '0')
				len--;
			buf[len] = '\0';
			parg.p_string = buf;
			error("Position target at screen position %s", &parg);
		}
		break;
	}
}

void
calc_jump_sline(void)
{
	if (jump_sline_fraction < 0)
		return;
	jump_sline = sc_height * jump_sline_fraction / NUM_FRAC_DENOM;
}

/*
 * Handlers for -# option.
 */
void
opt_shift(int type, char *s)
{
	PARG parg;
	char buf[16];
	int len;
	int err;

	switch (type) {
	case INIT:
	case TOGGLE:
		if (*s == '.') {
			s++;
			shift_count_fraction = getfraction(&s, "#", &err);
			if (err)
				error("Invalid column fraction", NULL);
			else
				calc_shift_count();
		} else {
			int hs = getnum(&s, "#", &err);
			if (err) {
				error("Invalid column number", NULL);
			} else {
				shift_count = hs;
				shift_count_fraction = -1;
			}
		}
		break;
	case QUERY:
		if (shift_count_fraction < 0) {
			parg.p_int = shift_count;
			error("Horizontal shift %d columns", &parg);
		} else {

			(void) snprintf(buf, sizeof (buf), ".%06d",
			    shift_count_fraction);
			len = strlen(buf);
			while (len > 2 && buf[len-1] == '0')
				len--;
			buf[len] = '\0';
			parg.p_string = buf;
			error("Horizontal shift %s of screen width", &parg);
		}
		break;
	}
}

void
calc_shift_count(void)
{
	if (shift_count_fraction < 0)
		return;
	shift_count = sc_width * shift_count_fraction / NUM_FRAC_DENOM;
}

void
opt_k(int type, char *s)
{
	PARG parg;

	switch (type) {
	case INIT:
		if (lesskey(s, 0)) {
			parg.p_string = s;
			error("Cannot use lesskey file \"%s\"", &parg);
		}
		break;
	}
}

/*
 * Handler for -t option.
 */
void
opt_t(int type, char *s)
{
	IFILE save_ifile;
	off_t pos;

	switch (type) {
	case INIT:
		tagoption = s;
		/* Do the rest in main() */
		break;
	case TOGGLE:
		if (secure) {
			error("tags support is not available", NULL);
			break;
		}
		findtag(skipsp(s));
		save_ifile = save_curr_ifile();
		/*
		 * Try to open the file containing the tag
		 * and search for the tag in that file.
		 */
		if (edit_tagfile() || (pos = tagsearch()) == -1) {
			/* Failed: reopen the old file. */
			reedit_ifile(save_ifile);
			break;
		}
		unsave_ifile(save_ifile);
		jump_loc(pos, jump_sline);
		break;
	}
}

/*
 * Handler for -T option.
 */
void
opt__T(int type, char *s)
{
	PARG parg;

	switch (type) {
	case INIT:
		tags = s;
		break;
	case TOGGLE:
		s = skipsp(s);
		tags = lglob(s);
		break;
	case QUERY:
		parg.p_string = tags;
		error("Tags file \"%s\"", &parg);
		break;
	}
}

/*
 * Handler for -p option.
 */
void
opt_p(int type, char *s)
{
	switch (type) {
	case INIT:
		/*
		 * Unget a search command for the specified string.
		 * {{ This won't work if the "/" command is
		 *    changed or invalidated by a .lesskey file. }}
		 */
		plusoption = TRUE;
		ungetsc(s);
		/*
		 * In "more" mode, the -p argument is a command,
		 * not a search string, so we don't need a slash.
		 */
		if (!less_is_more)
			ungetsc("/");
		break;
	}
}

/*
 * Handler for -P option.
 */
void
opt__P(int type, char *s)
{
	char **proto;
	PARG parg;

	switch (type) {
	case INIT:
	case TOGGLE:
		/*
		 * Figure out which prototype string should be changed.
		 */
		switch (*s) {
		case 's':  proto = &prproto[PR_SHORT];	s++;	break;
		case 'm':  proto = &prproto[PR_MEDIUM];	s++;	break;
		case 'M':  proto = &prproto[PR_LONG];	s++;	break;
		case '=':  proto = &eqproto;		s++;	break;
		case 'h':  proto = &hproto;		s++;	break;
		case 'w':  proto = &wproto;		s++;	break;
		default:   proto = &prproto[PR_SHORT];		break;
		}
		free(*proto);
		*proto = estrdup(s);
		break;
	case QUERY:
		parg.p_string = prproto[pr_type];
		error("%s", &parg);
		break;
	}
}

/*
 * Handler for the -b option.
 */
void
opt_b(int type, char *s)
{
	switch (type) {
	case INIT:
	case TOGGLE:
		/*
		 * Set the new number of buffers.
		 */
		ch_setbufspace(bufspace);
		break;
	case QUERY:
		break;
	}
}

/*
 * Handler for the -i option.
 */
void
opt_i(int type, char *s)
{
	switch (type) {
	case TOGGLE:
		chg_caseless();
		break;
	case QUERY:
	case INIT:
		break;
	}
}

/*
 * Handler for the -V option.
 */
void
opt__V(int type, char *s)
{
	switch (type) {
	case TOGGLE:
	case QUERY:
		dispversion();
		break;
	case INIT:
		/*
		 * Force output to stdout per GNU standard for --version output.
		 */
		any_display = 1;
		putstr("less ");
		putstr(version);
		putstr(" (");
		putstr("POSIX ");
		putstr("regular expressions)\n");
		putstr("Copyright (C) 1984-2012 Mark Nudelman\n");
		putstr("Modified for use with illumos by Garrett D'Amore.\n");
		putstr("Copyright 2014 Garrett D'Amore\n\n");
		putstr("less comes with NO WARRANTY, ");
		putstr("to the extent permitted by law.\n");
		putstr("For information about the terms of redistribution,\n");
		putstr("see the file named README in the less distribution.\n");
		putstr("Homepage: http://www.greenwoodsoftware.com/less\n");
		putstr("\n");
		quit(QUIT_OK);
		break;
	}
}

/*
 * Handler for the -x option.
 */
void
opt_x(int type, char *s)
{
	extern int tabstops[];
	extern int ntabstops;
	extern int tabdefault;
	char tabs[60+(4*TABSTOP_MAX)];
	int i;
	PARG p;

	switch (type) {
	case INIT:
	case TOGGLE:
		/* Start at 1 because tabstops[0] is always zero. */
		for (i = 1; i < TABSTOP_MAX; ) {
			int n = 0;
			s = skipsp(s);
			while (*s >= '0' && *s <= '9')
				n = (10 * n) + (*s++ - '0');
			if (n > tabstops[i-1])
				tabstops[i++] = n;
			s = skipsp(s);
			if (*s++ != ',')
				break;
		}
		if (i < 2)
			return;
		ntabstops = i;
		tabdefault = tabstops[ntabstops-1] - tabstops[ntabstops-2];
		break;
	case QUERY:
		(void) strlcpy(tabs, "Tab stops ", sizeof(tabs));
		if (ntabstops > 2) {
			for (i = 1; i < ntabstops; i++) {
				if (i > 1)
					strlcat(tabs, ",", sizeof(tabs));
				(void) snprintf(tabs+strlen(tabs),
				    sizeof(tabs)-strlen(tabs),
				    "%d", tabstops[i]);
			}
			(void) snprintf(tabs+strlen(tabs),
			    sizeof(tabs)-strlen(tabs), " and then ");
		}
		(void) snprintf(tabs+strlen(tabs), sizeof(tabs)-strlen(tabs),
		    "every %d spaces", tabdefault);
		p.p_string = tabs;
		error("%s", &p);
		break;
	}
}


/*
 * Handler for the -" option.
 */
void
opt_quote(int type, char *s)
{
	char buf[3];
	PARG parg;

	switch (type) {
	case INIT:
	case TOGGLE:
		if (s[0] == '\0') {
			openquote = closequote = '\0';
			break;
		}
		if (s[1] != '\0' && s[2] != '\0') {
			error("-\" must be followed by 1 or 2 chars",
			    NULL);
			return;
		}
		openquote = s[0];
		if (s[1] == '\0')
			closequote = openquote;
		else
			closequote = s[1];
		break;
	case QUERY:
		buf[0] = openquote;
		buf[1] = closequote;
		buf[2] = '\0';
		parg.p_string = buf;
		error("quotes %s", &parg);
		break;
	}
}

/*
 * "-?" means display a help message.
 * If from the command line, exit immediately.
 */
void
opt_query(int type, char *s)
{
	switch (type) {
	case QUERY:
	case TOGGLE:
		error("Use \"h\" for help", NULL);
		break;
	case INIT:
		dohelp = 1;
	}
}

/*
 * Get the "screen window" size.
 */
int
get_swindow(void)
{
	if (swindow > 0)
		return (swindow);
	return (sc_height + swindow);
}
@


1.15
log
@Rename a local var so that we can call the global message buffer msg.

ok nicm, tb
@
text
@d465 1
a465 1
			for (i = 1;  i < ntabstops;  i++) {
@


1.14
log
@remove lint annotations

ok nicm@@
@
text
@d438 1
a438 1
	char msg[60+(4*TABSTOP_MAX)];
d463 1
a463 1
		(void) strlcpy(msg, "Tab stops ", sizeof(msg));
d467 4
a470 3
					strlcat(msg, ",", sizeof(msg));
				(void) snprintf(msg+strlen(msg),
				    sizeof(msg)-strlen(msg), "%d", tabstops[i]);
d472 2
a473 2
			(void) snprintf(msg+strlen(msg), sizeof(msg)-strlen(msg),
			    " and then ");
d475 1
a475 1
		(void) snprintf(msg+strlen(msg), sizeof(msg)-strlen(msg),
d477 1
a477 1
		p.p_string = msg;
@


1.13
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@a361 1
/*ARGSUSED*/
a380 1
/*ARGSUSED*/
a396 1
/*ARGSUSED*/
a523 1
/*ARGSUSED*/
@


1.12
log
@replace save() with estrdup() and make estrdup() exit like all the other
ecalloc, etc. functions do.
ok mmcc nicm
@
text
@d69 1
a69 1
		error("log file support is not available", NULL_PARG);
d78 1
a78 1
			error("Input is not a pipe", NULL_PARG);
d82 1
a82 1
			error("Log file is already in use", NULL_PARG);
d92 1
a92 1
			error("No log file", NULL_PARG);
d129 1
a129 1
				error("Invalid line fraction", NULL_PARG);
d135 1
a135 1
				error("Invalid line number", NULL_PARG);
d186 1
a186 1
				error("Invalid column fraction", NULL_PARG);
d192 1
a192 1
				error("Invalid column number", NULL_PARG);
d257 1
a257 1
			error("tags support is not available", NULL_PARG);
d504 1
a504 1
			    NULL_PARG);
d534 1
a534 1
		error("Use \"h\" for help", NULL_PARG);
@


1.11
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d350 1
a350 1
		*proto = save(s);
@


1.10
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a10 4
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 */
d418 3
a420 1
		putstr("Copyright (C) 1984-2012 Mark Nudelman\n\n");
a426 2
		putstr("Modified for use with illumos.\n");
		putstr("Copyright 2014 Garrett D'Amore\n");
@


1.9
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

a32 1
extern int nbufs;
a51 2
extern int shift_count;
extern int shift_count_fraction;
a52 1
#if LOGFILE
d56 1
a56 3
#endif
#if TAGS
public char *tagoption = NULL;
a57 9
#endif
#if MSDOS_COMPILER
extern int nm_fg_color, nm_bg_color;
extern int bo_fg_color, bo_bg_color;
extern int ul_fg_color, ul_bg_color;
extern int so_fg_color, so_bg_color;
extern int bl_fg_color, bl_bg_color;
#endif
extern char *every_first_cmd;
d59 2
a61 1
#if LOGFILE
d65 2
a66 4
	public void
opt_o(type, s)
	int type;
	char *s;
d70 1
a70 2
	if (secure)
	{
d74 1
a74 2
	switch (type)
	{
d79 1
a79 2
		if (ch_getflags() & CH_CANSEEK)
		{
d83 1
a83 2
		if (logfile >= 0)
		{
d93 1
a93 1
		if (logfile < 0)
d95 1
a95 2
		else
		{
d106 2
a107 4
	public void
opt__O(type, s)
	int type;
	char *s;
a111 1
#endif
d116 2
a117 4
	public void
opt_j(type, s)
	int type;
	char *s;
d124 1
a124 2
	switch (type)
	{
d127 1
a127 2
		if (*s == '.')
		{
d134 1
a134 2
		} else
		{
d136 1
a136 1
			if (err)
d138 1
a138 2
			else
			{
d145 1
a145 2
		if (jump_sline_fraction < 0)
		{
d148 3
a150 4
		} else
		{

			snprintf(buf, sizeof(buf), ".%06d", jump_sline_fraction);
d162 2
a163 2
	public void
calc_jump_sline()
d173 2
a174 4
	public void
opt_shift(type, s)
	int type;
	char *s;
d181 1
a181 2
	switch (type)
	{
d184 1
a184 2
		if (*s == '.')
		{
d191 1
a191 2
		} else
		{
d193 1
a193 1
			if (err)
d195 1
a195 2
			else
			{
d202 1
a202 2
		if (shift_count_fraction < 0)
		{
d205 1
a205 2
		} else
		{
d207 2
a208 1
			snprintf(buf, sizeof(buf), ".%06d", shift_count_fraction);
d219 3
a221 2
	public void
calc_shift_count()
d228 2
a229 5
#if USERFILE
	public void
opt_k(type, s)
	int type;
	char *s;
d233 1
a233 2
	switch (type)
	{
d235 1
a235 2
		if (lesskey(s, 0))
		{
a241 1
#endif
a242 1
#if TAGS
d246 2
a247 4
	public void
opt_t(type, s)
	int type;
	char *s;
d250 1
a250 1
	POSITION pos;
d252 1
a252 2
	switch (type)
	{
d258 1
a258 2
		if (secure)
		{
d268 1
a268 2
		if (edit_tagfile() || (pos = tagsearch()) == NULL_POSITION)
		{
d282 2
a283 4
	public void
opt__T(type, s)
	int type;
	char *s;
d287 1
a287 2
	switch (type)
	{
a300 1
#endif
d305 2
a306 4
	public void
opt_p(type, s)
	int type;
	register char *s;
d308 1
a308 2
	switch (type)
	{
d315 7
a321 9
		if (less_is_more) {
			/*
			 * In "more" mode, the -p argument is a command,
			 * not a search string, run for each file.
			 */
			every_first_cmd = save(s);
		} else {
			plusoption = TRUE;
			ungetsc(s);
a322 1
		}
d330 2
a331 4
	public void
opt__P(type, s)
	int type;
	register char *s;
d333 1
a333 1
	register char **proto;
d336 1
a336 2
	switch (type)
	{
d342 1
a342 2
		switch (*s)
		{
d364 3
a366 5
	/*ARGSUSED*/
	public void
opt_b(type, s)
	int type;
	char *s;
d368 1
a368 2
	switch (type)
	{
d384 3
a386 5
	/*ARGSUSED*/
	public void
opt_i(type, s)
	int type;
	char *s;
d388 1
a388 2
	switch (type)
	{
d401 3
a403 5
	/*ARGSUSED*/
	public void
opt__V(type, s)
	int type;
	char *s;
d405 1
a405 2
	switch (type)
	{
a417 4
#if HAVE_GNU_REGEX
		putstr("GNU ");
#endif
#if HAVE_POSIX_REGCOMP
a418 16
#endif
#if HAVE_PCRE
		putstr("PCRE ");
#endif
#if HAVE_RE_COMP
		putstr("BSD ");
#endif
#if HAVE_REGCMP
		putstr("V8 ");
#endif
#if HAVE_V8_REGCOMP
		putstr("Spencer V8 ");
#endif
#if !HAVE_GNU_REGEX && !HAVE_POSIX_REGCOMP && !HAVE_PCRE && !HAVE_RE_COMP && !HAVE_REGCMP && !HAVE_V8_REGCOMP
		putstr("no ");
#endif
d421 2
a422 1
		putstr("less comes with NO WARRANTY, to the extent permitted by law.\n");
d426 3
a433 83
#if MSDOS_COMPILER
/*
 * Parse an MSDOS color descriptor.
 */
   	static void
colordesc(s, fg_color, bg_color)
	char *s;
	int *fg_color;
	int *bg_color;
{
	int fg, bg;
	int err;
	
	fg = getnum(&s, "D", &err);
	if (err)
	{
		error("Missing fg color in -D", NULL_PARG);
		return;
	}
	if (*s != '.')
		bg = nm_bg_color;
	else
	{
		s++;
		bg = getnum(&s, "D", &err);
		if (err)
		{
			error("Missing bg color in -D", NULL_PARG);
			return;
		}
	}
	if (*s != '\0')
		error("Extra characters at end of -D option", NULL_PARG);
	*fg_color = fg;
	*bg_color = bg;
}

/*
 * Handler for the -D option.
 */
	/*ARGSUSED*/
	public void
opt_D(type, s)
	int type;
	char *s;
{
	switch (type)
	{
	case INIT:
	case TOGGLE:
		switch (*s++)
		{
		case 'n':
			colordesc(s, &nm_fg_color, &nm_bg_color);
			break;
		case 'd':
			colordesc(s, &bo_fg_color, &bo_bg_color);
			break;
		case 'u':
			colordesc(s, &ul_fg_color, &ul_bg_color);
			break;
		case 'k':
			colordesc(s, &bl_fg_color, &bl_bg_color);
			break;
		case 's':
			colordesc(s, &so_fg_color, &so_bg_color);
			break;
		default:
			error("-D must be followed by n, d, u, k or s", NULL_PARG);
			break;
		}
		if (type == TOGGLE)
		{
			at_enter(AT_STANDOUT);
			at_exit();
		}
		break;
	case QUERY:
		break;
	}
}
#endif

d437 2
a438 4
	public void
opt_x(type, s)
	int type;
	register char *s;
d447 1
a447 2
	switch (type)
	{
d451 1
a451 2
		for (i = 1;  i < TABSTOP_MAX;  )
		{
d468 3
a470 5
		strlcpy(msg, "Tab stops ", sizeof(msg));
		if (ntabstops > 2)
		{
			for (i = 1;  i < ntabstops;  i++)
			{
d473 1
a473 1
				snprintf(msg+strlen(msg),
d476 1
a476 1
			snprintf(msg+strlen(msg), sizeof(msg)-strlen(msg),
d479 1
a479 1
		snprintf(msg+strlen(msg), sizeof(msg)-strlen(msg),
d491 2
a492 4
	public void
opt_quote(type, s)
	int type;
	register char *s;
d497 1
a497 2
	switch (type)
	{
d500 1
a500 2
		if (s[0] == '\0')
		{
d504 3
a506 3
		if (s[1] != '\0' && s[2] != '\0')
		{
			error("-\" must be followed by 1 or 2 chars", NULL_PARG);
d529 3
a531 5
	/*ARGSUSED*/
	public void
opt_query(type, s)
	int type;
	char *s;
d533 1
a533 2
	switch (type)
	{
d546 2
a547 2
	public int
get_swindow()
a552 1

@


1.8
log
@In "more" mode, POSIX says the command specified by the -p option
should apply to every edited file, not just the first one.  It is
equivalent to less's ++ option.  Patch sent to upstream.  OK shadchin@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d487 24
a510 1
		putstr("\nCopyright (C) 1984-2009 Mark Nudelman\n\n");
@


1.7
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d70 1
d370 9
a378 7
		plusoption = TRUE;
		ungetsc(s);
		/*
		 * In "more" mode, the -p argument is a command,
		 * not a search string, so we don't need a slash.
		 */
		if (!less_is_more)
d380 1
@


1.6
log
@use SMALL_PROGRAM to knock out some code
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
a30 1
#ifndef SMALL_PROGRAM
a31 1
#endif
a33 1
extern int nohelp;
d36 1
d39 1
d49 5
a61 1
extern int jump_sline;
d135 1
a135 1
 * Handlers for -l option.
d138 1
a138 1
opt_l(type, s)
d142 3
d146 66
a211 3
	int n;
	char *t;
	
d215 27
a241 3
		t = s;
		n = getnum(&t, "l", &err);
		if (err || n <= 0)
d243 8
a250 2
			error("Line number is required after -l", NULL_PARG);
			return;
a251 2
		plusoption = TRUE;
		ungetsc(s);
d255 7
d310 5
a314 3
		if (edit_tagfile())
			break;
		if ((pos = tagsearch()) == NULL_POSITION)
d316 1
d371 6
a376 1
		ungetsc("/");
d484 1
a484 1
		putstr("\nCopyright (C) 2002 Mark Nudelman\n\n");
d514 1
a514 1
		bg = 0;
d521 1
a521 1
			error("Missing fg color in -D", NULL_PARG);
d567 2
a568 2
			so_enter();
			so_exit();
d629 1
a629 2
		    "every %d spaces",
			tabdefault);
a687 2
	if (nohelp)
		return;
d695 1
a695 14
		/*
		 * This is "less -?".
		 * It rather ungracefully grabs control,
		 * does the initializations normally done in main,
		 * shows the help file and exits.
		 */
		raw_mode(1);
		get_term();
		open_getchr();
		init();
		any_display = TRUE;
		help(1);
		quit(QUIT_OK);
		/*NOTREACHED*/
@


1.5
log
@o go back to using a help file instead of embedding it in the binary
o deal with HELPFILE not being defined
o add a SMALL definition to make a smaller less for the boot floppies
This still needs to be pared down a bit for the SMALL case
@
text
@d31 1
d33 1
@


1.4
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d34 1
a38 1
extern int dohelp;
d575 2
d584 14
a597 1
		dohelp = 1;
@


1.3
log
@kill more registers

millert@@ ok
@
text
@a0 2
/*	$OpenBSD: optfunc.c,v 1.2 2001/01/29 01:58:03 niklas Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d32 1
a32 1
extern int cbufs;
a33 1
extern int nohelp;
d37 2
d40 2
d44 2
d47 1
a54 1
extern char *tagfile;
d58 1
a58 1
#if MSOFTC
d78 5
d100 1
a100 1
		namelogfile = glob(s);
d145 1
a145 1
		n = getnum(&t, 'l', &err);
d168 1
a168 1
		if (lesskey(s))
d197 5
d203 2
a204 4
		if (tagfile == NULL)
			break;
		save_ifile = curr_ifile;
		if (edit(tagfile))
d208 1
a208 2
			if (edit_ifile(save_ifile))
				quit(QUIT_ERROR);
d211 1
d234 1
a234 1
		tags = glob(s);
d250 1
a250 1
	char *s;
d273 1
a273 1
	char *s;
d275 1
a275 1
	char **proto;
d287 1
d291 2
d316 1
a317 1
	case QUERY:
d319 1
a319 1
		 * Allocate the new number of buffers.
d321 1
a321 1
		cbufs = ch_nbuf(cbufs);
d323 1
a323 1
	case INIT:
d361 2
d364 12
a375 3
		dispversion();
		if (type == INIT)
			quit(QUIT_OK);
d380 1
a380 1
#if MSOFTC
d382 1
a382 1
 *
d393 1
a393 1
	fg = getnum(&s, 'D', &err);
d404 1
a404 1
		bg = getnum(&s, 'D', &err);
d411 2
d464 102
a574 2
	if (nohelp)
		return;
d582 1
a582 14
		/*
		 * This is "less -?".
		 * It rather ungracefully grabs control, 
		 * does the initializations normally done in main,
		 * shows the help file and exits.
		 */
		raw_mode(1);
		get_term();
		open_getchr();
		init();
		any_display = TRUE;
		help(1);
		quit(QUIT_OK);
		/*NOTREACHED*/
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d255 1
a255 1
	register char *s;
d278 1
a278 1
	register char *s;
d280 1
a280 1
	register char **proto;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d48 1
a48 1
extern int bufspace;
d50 1
a53 2
extern int secure;
extern int dohelp;
a54 2
extern char openquote;
extern char closequote;
a56 2
extern char *hproto;
extern char *wproto;
a57 1
extern char version[];
d65 1
d69 1
a69 1
#if MSDOS_COMPILER
a88 5
	if (secure)
	{
		error("log file support is not available", NULL_PARG);
		return;
	}
d106 1
a106 1
		namelogfile = lglob(s);
d151 1
a151 1
		n = getnum(&t, "l", &err);
d174 1
a174 1
		if (lesskey(s, 0))
d203 2
a204 3
		if (secure)
		{
			error("tags support is not available", NULL_PARG);
d206 2
a207 4
		}
		findtag(skipsp(s));
		save_ifile = save_curr_ifile();
		if (edit_tagfile())
d211 2
a212 1
			reedit_ifile(save_ifile);
a214 1
		unsave_ifile(save_ifile);
d237 1
a237 1
		tags = lglob(s);
a289 1
		case 's':  proto = &prproto[PR_SHORT];	s++;	break;
a292 2
		case 'h':  proto = &hproto;		s++;	break;
		case 'w':  proto = &wproto;		s++;	break;
a315 1
	case INIT:
d317 1
d319 1
a319 1
		 * Set the new number of buffers.
d321 1
a321 1
		ch_setbufspace(bufspace);
d323 1
a323 1
	case QUERY:
d361 1
d363 2
a364 14
		break;
	case INIT:
		/*
		 * Force output to stdout per GNU standard for --version output.
		 */
		any_display = 1;
		putstr("less ");
		putstr(version);
		putstr("\nCopyright (C) 2002 Mark Nudelman\n\n");
		putstr("less comes with NO WARRANTY, to the extent permitted by law.\n");
		putstr("For information about the terms of redistribution,\n");
		putstr("see the file named README in the less distribution.\n");
		putstr("Homepage: http://www.greenwoodsoftware.com/less\n");
		quit(QUIT_OK);
d369 1
a369 1
#if MSDOS_COMPILER
d371 1
a371 1
 * Parse an MSDOS color descriptor.
d382 1
a382 1
	fg = getnum(&s, "D", &err);
d393 1
a393 1
		bg = getnum(&s, "D", &err);
a399 2
	if (*s != '\0')
		error("Extra characters at end of -D option", NULL_PARG);
a450 99
 * Handler for the -x option.
 */
	public void
opt_x(type, s)
	int type;
	register char *s;
{
	extern int tabstops[];
	extern int ntabstops;
	extern int tabdefault;
	char msg[60+(4*TABSTOP_MAX)];
	int i;
	PARG p;

	switch (type)
	{
	case INIT:
	case TOGGLE:
		/* Start at 1 because tabstops[0] is always zero. */
		for (i = 1;  i < TABSTOP_MAX;  )
		{
			int n = 0;
			s = skipsp(s);
			while (*s >= '0' && *s <= '9')
				n = (10 * n) + (*s++ - '0');
			if (n > tabstops[i-1])
				tabstops[i++] = n;
			s = skipsp(s);
			if (*s++ != ',')
				break;
		}
		if (i < 2)
			return;
		ntabstops = i;
		tabdefault = tabstops[ntabstops-1] - tabstops[ntabstops-2];
		break;
	case QUERY:
		strcpy(msg, "Tab stops ");
		if (ntabstops > 2)
		{
			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, ",");
				sprintf(msg+strlen(msg), "%d", tabstops[i]);
			}
			sprintf(msg+strlen(msg), " and then ");
		}
		sprintf(msg+strlen(msg), "every %d spaces",
			tabdefault);
		p.p_string = msg;
		error("%s", &p);
		break;
	}
}


/*
 * Handler for the -" option.
 */
	public void
opt_quote(type, s)
	int type;
	register char *s;
{
	char buf[3];
	PARG parg;

	switch (type)
	{
	case INIT:
	case TOGGLE:
		if (s[0] == '\0')
		{
			openquote = closequote = '\0';
			break;
		}
		if (s[1] != '\0' && s[2] != '\0')
		{
			error("-\" must be followed by 1 or 2 chars", NULL_PARG);
			return;
		}
		openquote = s[0];
		if (s[1] == '\0')
			closequote = openquote;
		else
			closequote = s[1];
		break;
	case QUERY:
		buf[0] = openquote;
		buf[1] = closequote;
		buf[2] = '\0';
		parg.p_string = buf;
		error("quotes %s", &parg);
		break;
	}
}

/*
d460 2
d469 14
a482 1
		dohelp = 1;
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
a35 1
extern int sc_width;
a47 5
extern int jump_sline;
extern int jump_sline_fraction;
extern int shift_count;
extern int shift_count_fraction;
extern int less_is_more;
d56 1
d130 1
a130 1
 * Handlers for -j option.
d133 1
a133 1
opt_j(type, s)
a136 3
	PARG parg;
	char buf[16];
	int len;
d138 3
a140 1

d144 3
a146 2
	case TOGGLE:
		if (*s == '.')
d148 2
a149 98
			s++;
			jump_sline_fraction = getfraction(&s, "j", &err);
			if (err)
				error("Invalid line fraction", NULL_PARG);
			else
				calc_jump_sline();
		} else
		{
			int sline = getnum(&s, "j", &err);
			if (err)
				error("Invalid line number", NULL_PARG);
			else
			{
				jump_sline = sline;
				jump_sline_fraction = -1;
			}
		}
		break;
	case QUERY:
		if (jump_sline_fraction < 0)
		{
			parg.p_int =  jump_sline;
			error("Position target at screen line %d", &parg);
		} else
		{

			sprintf(buf, ".%06d", jump_sline_fraction);
			len = strlen(buf);
			while (len > 2 && buf[len-1] == '0')
				len--;
			buf[len] = '\0';
			parg.p_string = buf;
			error("Position target at screen position %s", &parg);
		}
		break;
	}
}

	public void
calc_jump_sline()
{
	if (jump_sline_fraction < 0)
		return;
	jump_sline = sc_height * jump_sline_fraction / NUM_FRAC_DENOM;
}

/*
 * Handlers for -# option.
 */
	public void
opt_shift(type, s)
	int type;
	char *s;
{
	PARG parg;
	char buf[16];
	int len;
	int err;

	switch (type)
	{
	case INIT:
	case TOGGLE:
		if (*s == '.')
		{
			s++;
			shift_count_fraction = getfraction(&s, "#", &err);
			if (err)
				error("Invalid column fraction", NULL_PARG);
			else
				calc_shift_count();
		} else
		{
			int hs = getnum(&s, "#", &err);
			if (err)
				error("Invalid column number", NULL_PARG);
			else
			{
				shift_count = hs;
				shift_count_fraction = -1;
			}
		}
		break;
	case QUERY:
		if (shift_count_fraction < 0)
		{
			parg.p_int = shift_count;
			error("Horizontal shift %d columns", &parg);
		} else
		{

			sprintf(buf, ".%06d", shift_count_fraction);
			len = strlen(buf);
			while (len > 2 && buf[len-1] == '0')
				len--;
			buf[len] = '\0';
			parg.p_string = buf;
			error("Horizontal shift %s of screen width", &parg);
d151 2
a155 7
	public void
calc_shift_count()
{
	if (shift_count_fraction < 0)
		return;
	shift_count = sc_width * shift_count_fraction / NUM_FRAC_DENOM;
}
d204 3
a206 5
		/*
		 * Try to open the file containing the tag
		 * and search for the tag in that file.
		 */
		if (edit_tagfile() || (pos = tagsearch()) == NULL_POSITION)
a207 1
			/* Failed: reopen the old file. */
d262 1
a262 6
		/*
		 * In "more" mode, the -p argument is a command,
		 * not a search string, so we don't need a slash.
		 */
		if (!less_is_more)
			ungetsc("/");
d370 1
a370 1
		putstr("\nCopyright (C) 1984-2009 Mark Nudelman\n\n");
d400 1
a400 1
		bg = nm_bg_color;
d407 1
a407 1
			error("Missing bg color in -D", NULL_PARG);
d453 2
a454 2
			at_enter(AT_STANDOUT);
			at_exit();
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
a69 1
extern char *every_first_cmd;
d179 1
a179 1
			snprintf(buf, sizeof(buf), ".%06d", jump_sline_fraction);
d244 1
a244 1
			snprintf(buf, sizeof(buf), ".%06d", shift_count_fraction);
d369 7
a375 9
		if (less_is_more) {
			/*
			 * In "more" mode, the -p argument is a command,
			 * not a search string, run for each file.
			 */
			every_first_cmd = save(s);
		} else {
			plusoption = TRUE;
			ungetsc(s);
a376 1
		}
d484 1
a484 24
		putstr(" (");
#if HAVE_GNU_REGEX
		putstr("GNU ");
#endif
#if HAVE_POSIX_REGCOMP
		putstr("POSIX ");
#endif
#if HAVE_PCRE
		putstr("PCRE ");
#endif
#if HAVE_RE_COMP
		putstr("BSD ");
#endif
#if HAVE_REGCMP
		putstr("V8 ");
#endif
#if HAVE_V8_REGCOMP
		putstr("Spencer V8 ");
#endif
#if !HAVE_GNU_REGEX && !HAVE_POSIX_REGCOMP && !HAVE_PCRE && !HAVE_RE_COMP && !HAVE_REGCMP && !HAVE_V8_REGCOMP
		putstr("no ");
#endif
		putstr("regular expressions)\n");
		putstr("Copyright (C) 1984-2012 Mark Nudelman\n\n");
d615 1
a615 1
		strlcpy(msg, "Tab stops ", sizeof(msg));
d621 2
a622 3
					strlcat(msg, ",", sizeof(msg));
				snprintf(msg+strlen(msg),
				    sizeof(msg)-strlen(msg), "%d", tabstops[i]);
d624 1
a624 2
			snprintf(msg+strlen(msg), sizeof(msg)-strlen(msg),
			    " and then ");
d626 2
a627 2
		snprintf(msg+strlen(msg), sizeof(msg)-strlen(msg),
		    "every %d spaces", tabdefault);
@


