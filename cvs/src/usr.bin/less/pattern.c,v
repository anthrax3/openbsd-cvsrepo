head	1.10;
access;
symbols
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.9.0.8
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.5.0.8
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	LESS_458:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.12
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.8
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.6
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	LESS_444:1.1.1.1
	MARK_NUDELMAN:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2017.08.02.19.35.57;	author anton;	state Exp;
branches;
next	1.9;
commitid	b2AbYJzb5gHyU4ia;

1.9
date	2015.11.21.13.29.12;	author tedu;	state Exp;
branches;
next	1.8;
commitid	1K0ek8cCYSq3jMmD;

1.8
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	ZtGimechwgSRYqRW;

1.7
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.6;
commitid	QKrr6AuGzNx9nehL;

1.6
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.5;
commitid	yKv9Ck9ZDgwWTRTo;

1.5
date	2014.05.28.11.39.15;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2014.05.23.19.49.15;	author guenther;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.12.01.01.19;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2011.09.16.17.47.07;	author shadchin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.09.16.17.47.07;	author shadchin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.04.25.13.33.50;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.10
log
@When performing an inverted search in less, make sure to invalidate the match
bounds prior calling regexec(). In this inverted scenario a match is found when
regexec() returns false causing the bounds to not be updated. This is
problematic since the bounds will then refer to a previous match and future
pointer arithmetic will eventually be off which is manifested in a SIGSEGV.

Issue reported by Larry Hynes on tech@@
ok martijn@@ tb@@
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Routines to do pattern matching.
 */

#include "less.h"
#include "pattern.h"

extern int caseless;
extern int less_is_more;

/*
 * Compile a search pattern, for future use by match_pattern.
 */
static int
compile_pattern2(char *pattern, int search_type, regex_t **comp_pattern)
{
	regex_t *comp;

	if (search_type & SRCH_NO_REGEX)
		return (0);
	comp = ecalloc(1, sizeof (regex_t));
	if (regcomp(comp, pattern, less_is_more ? 0 : REGCOMP_FLAG)) {
		free(comp);
		error("Invalid pattern", NULL);
		return (-1);
	}
	if (*comp_pattern != NULL)
		regfree(*comp_pattern);
	*comp_pattern = comp;
	return (0);
}

/*
 * Like compile_pattern2, but convert the pattern to lowercase if necessary.
 */
int
compile_pattern(char *pattern, int search_type, regex_t **comp_pattern)
{
	char *cvt_pattern;
	int result;

	if (caseless != OPT_ONPLUS) {
		cvt_pattern = pattern;
	} else {
		cvt_pattern = ecalloc(1, cvt_length(strlen(pattern)));
		cvt_text(cvt_pattern, pattern, NULL, NULL, CVT_TO_LC);
	}
	result = compile_pattern2(cvt_pattern, search_type, comp_pattern);
	if (cvt_pattern != pattern)
		free(cvt_pattern);
	return (result);
}

/*
 * Forget that we have a compiled pattern.
 */
void
uncompile_pattern(regex_t **pattern)
{
	if (*pattern != NULL)
		regfree(*pattern);
	*pattern = NULL;
}

/*
 * Simple pattern matching function.
 * It supports no metacharacters like *, etc.
 */
static int
match(char *pattern, int pattern_len, char *buf, int buf_len,
    char **pfound, char **pend)
{
	char *pp, *lp;
	char *pattern_end = pattern + pattern_len;
	char *buf_end = buf + buf_len;

	for (; buf < buf_end; buf++) {
		for (pp = pattern, lp = buf; *pp == *lp; pp++, lp++)
			if (pp == pattern_end || lp == buf_end)
				break;
		if (pp == pattern_end) {
			if (pfound != NULL)
				*pfound = buf;
			if (pend != NULL)
				*pend = lp;
			return (1);
		}
	}
	return (0);
}

/*
 * Perform a pattern match with the previously compiled pattern.
 * Set sp and ep to the start and end of the matched string.
 */
int
match_pattern(void *pattern, char *tpattern, char *line, int line_len,
    char **sp, char **ep, int notbol, int search_type)
{
	int matched;
	regex_t *spattern = (regex_t *)pattern;

	if (search_type & SRCH_NO_REGEX) {
		matched = match(tpattern, strlen(tpattern), line, line_len,
		    sp, ep);
	} else {
		regmatch_t rm;
		int flags = (notbol) ? REG_NOTBOL : 0;
#ifdef	REG_STARTEND
		flags |= REG_STARTEND;
		rm.rm_so = 0;
		rm.rm_eo = line_len;
#endif
		*sp = NULL;
		*ep = NULL;
		matched = !regexec(spattern, line, 1, &rm, flags);
		if (matched) {
			*sp = line + rm.rm_so;
			*ep = line + rm.rm_eo;
		}
	}
	matched = (!(search_type & SRCH_NO_MATCH) && matched) ||
	    ((search_type & SRCH_NO_MATCH) && !matched);
	return (matched);
}
@


1.9
log
@remove fancy null check function in favor of checking for null.
from Ricardo Mestre
@
text
@d125 2
@


1.8
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@a76 9
 * Is a compiled pattern null?
 */
int
is_null_pattern(void *pattern)
{
	return (pattern == NULL);
}

/*
@


1.7
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d35 1
a35 1
		error("Invalid pattern", NULL_PARG);
@


1.6
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.5
log
@When invoked as more, make the -i option behave the same as less's
-I to match POSIX.  OK and man bits from jmc@@
@
text
@d9 4
d27 2
a28 5
	static int
compile_pattern2(pattern, search_type, comp_pattern)
	char *pattern;
	int search_type;
	void **comp_pattern;
d30 2
d34 2
a35 22
  {
#if HAVE_GNU_REGEX
	struct re_pattern_buffer *comp = (struct re_pattern_buffer *)
		ecalloc(1, sizeof(struct re_pattern_buffer));
	struct re_pattern_buffer **pcomp = 
		(struct re_pattern_buffer **) comp_pattern;
	re_set_syntax(RE_SYNTAX_POSIX_EXTENDED);
	if (re_compile_pattern(pattern, strlen(pattern), comp))
	{
		free(comp);
		error("Invalid pattern", NULL_PARG);
		return (-1);
	}
	if (*pcomp != NULL)
		regfree(*pcomp);
	*pcomp = comp;
#endif
#if HAVE_POSIX_REGCOMP
	regex_t *comp = (regex_t *) ecalloc(1, sizeof(regex_t));
	regex_t **pcomp = (regex_t **) comp_pattern;
	if (regcomp(comp, pattern, less_is_more ? 0 : REGCOMP_FLAG))
	{
d40 3
a42 58
	if (*pcomp != NULL)
		regfree(*pcomp);
	*pcomp = comp;
#endif
#if HAVE_PCRE
	pcre *comp;
	pcre **pcomp = (pcre **) comp_pattern;
	constant char *errstring;
	int erroffset;
	PARG parg;
	comp = pcre_compile(pattern, 0,
			&errstring, &erroffset, NULL);
	if (comp == NULL)
	{
		parg.p_string = (char *) errstring;
		error("%s", &parg);
		return (-1);
	}
	*pcomp = comp;
#endif
#if HAVE_RE_COMP
	PARG parg;
	int *pcomp = (int *) comp_pattern;
	if ((parg.p_string = re_comp(pattern)) != NULL)
	{
		error("%s", &parg);
		return (-1);
	}
	*pcomp = 1;
#endif
#if HAVE_REGCMP
	char *comp;
	char **pcomp = (char **) comp_pattern;
	if ((comp = regcmp(pattern, 0)) == NULL)
	{
		error("Invalid pattern", NULL_PARG);
		return (-1);
	}
	if (pcomp != NULL)
		free(*pcomp);
	*pcomp = comp;
#endif
#if HAVE_V8_REGCOMP
	struct regexp *comp;
	struct regexp **pcomp = (struct regexp **) comp_pattern;
	if ((comp = regcomp(pattern)) == NULL)
	{
		/*
		 * regcomp has already printed an error message 
		 * via regerror().
		 */
		return (-1);
	}
	if (*pcomp != NULL)
		free(*pcomp);
	*pcomp = comp;
#endif
  }
d49 2
a50 5
	public int
compile_pattern(pattern, search_type, comp_pattern)
	char *pattern;
	int search_type;
	void **comp_pattern;
d55 1
a55 1
	if (caseless != OPT_ONPLUS && (caseless != OPT_ON || !less_is_more))
d57 3
a59 4
	else
	{
		cvt_pattern = (char*) ecalloc(1, cvt_length(strlen(pattern), CVT_TO_LC));
		cvt_text(cvt_pattern, pattern, (int *)NULL, (int *)NULL, CVT_TO_LC);
d70 2
a71 3
	public void
uncompile_pattern(pattern)
	void **pattern;
d73 3
a75 34
#if HAVE_GNU_REGEX
	struct re_pattern_buffer **pcomp = (struct re_pattern_buffer **) pattern;
	if (*pcomp != NULL)
		regfree(*pcomp);
	*pcomp = NULL;
#endif
#if HAVE_POSIX_REGCOMP
	regex_t **pcomp = (regex_t **) pattern;
	if (*pcomp != NULL)
		regfree(*pcomp);
	*pcomp = NULL;
#endif
#if HAVE_PCRE
	pcre **pcomp = (pcre **) pattern;
	if (*pcomp != NULL)
		pcre_free(*pcomp);
	*pcomp = NULL;
#endif
#if HAVE_RE_COMP
	int *pcomp = (int *) pattern;
	*pcomp = 0;
#endif
#if HAVE_REGCMP
	char **pcomp = (char **) pattern;
	if (*pcomp != NULL)
		free(*pcomp);
	*pcomp = NULL;
#endif
#if HAVE_V8_REGCOMP
	struct regexp **pcomp = (struct regexp **) pattern;
	if (*pcomp != NULL)
		free(*pcomp);
	*pcomp = NULL;
#endif
d81 2
a82 3
	public int
is_null_pattern(pattern)
	void *pattern;
a83 7
#if HAVE_GNU_REGEX
	return (pattern == NULL);
#endif
#if HAVE_POSIX_REGCOMP
	return (pattern == NULL);
#endif
#if HAVE_PCRE
a84 10
#endif
#if HAVE_RE_COMP
	return (pattern == 0);
#endif
#if HAVE_REGCMP
	return (pattern == NULL);
#endif
#if HAVE_V8_REGCOMP
	return (pattern == NULL);
#endif
d91 10
a100 15
	static int
match(pattern, pattern_len, buf, buf_len, pfound, pend)
	char *pattern;
	int pattern_len;
	char *buf;
	int buf_len;
	char **pfound, **pend;
{
	register char *pp, *lp;
	register char *pattern_end = pattern + pattern_len;
	register char *buf_end = buf + buf_len;

	for ( ;  buf < buf_end;  buf++)
	{
		for (pp = pattern, lp = buf;  *pp == *lp;  pp++, lp++)
d103 1
a103 2
		if (pp == pattern_end)
		{
d118 3
a120 10
	public int
match_pattern(pattern, tpattern, line, line_len, sp, ep, notbol, search_type)
	void *pattern;
	char *tpattern;
	char *line;
	int line_len;
	char **sp;
	char **ep;
	int notbol;
	int search_type;
d123 1
a123 18
#if HAVE_GNU_REGEX
	struct re_pattern_buffer *spattern = (struct re_pattern_buffer *) pattern;
#endif
#if HAVE_POSIX_REGCOMP
	regex_t *spattern = (regex_t *) pattern;
#endif
#if HAVE_PCRE
	pcre *spattern = (pcre *) pattern;
#endif
#if HAVE_RE_COMP
	int spattern = (int) pattern;
#endif
#if HAVE_REGCMP
	char *spattern = (char *) pattern;
#endif
#if HAVE_V8_REGCOMP
	struct regexp *spattern = (struct regexp *) pattern;
#endif
d125 4
a128 26
#if NO_REGEX
	search_type |= SRCH_NO_REGEX;
#endif
	if (search_type & SRCH_NO_REGEX)
		matched = match(tpattern, strlen(tpattern), line, line_len, sp, ep);
	else
	{
#if HAVE_GNU_REGEX
	{
		struct re_registers search_regs;
		regoff_t *starts = (regoff_t *) ecalloc(1, sizeof (regoff_t));
		regoff_t *ends = (regoff_t *) ecalloc(1, sizeof (regoff_t));
		spattern->not_bol = notbol;
		re_set_registers(spattern, &search_regs, 1, starts, ends);
		matched = re_search(spattern, line, line_len, 0, line_len, &search_regs) >= 0;
		if (matched)
		{
			*sp = line + search_regs.start[0];
			*ep = line + search_regs.end[0];
		}
		free(starts);
		free(ends);
	}
#endif
#if HAVE_POSIX_REGCOMP
	{
d131 1
a131 1
#ifdef REG_STARTEND
d137 1
a137 3
		if (matched)
		{
#ifndef __WATCOMC__
a139 4
#else
			*sp = rm.rm_sp;
			*ep = rm.rm_ep;
#endif
a141 40
#endif
#if HAVE_PCRE
	{
		int flags = (notbol) ? PCRE_NOTBOL : 0;
		int ovector[3];
		matched = pcre_exec(spattern, NULL, line, line_len,
			0, flags, ovector, 3) >= 0;
		if (matched)
		{
			*sp = line + ovector[0];
			*ep = line + ovector[1];
		}
	}
#endif
#if HAVE_RE_COMP
	matched = (re_exec(line) == 1);
	/*
	 * re_exec doesn't seem to provide a way to get the matched string.
	 */
	*sp = *ep = NULL;
#endif
#if HAVE_REGCMP
	*ep = regex(spattern, line);
	matched = (*ep != NULL);
	if (matched)
		*sp = __loc1;
#endif
#if HAVE_V8_REGCOMP
#if HAVE_REGEXEC2
	matched = regexec2(spattern, line, notbol);
#else
	matched = regexec(spattern, line);
#endif
	if (matched)
	{
		*sp = spattern->startp[0];
		*ep = spattern->endp[0];
	}
#endif
	}
d143 1
a143 1
			((search_type & SRCH_NO_MATCH) && !matched);
a145 1

@


1.4
log
@Use REG_STARTEND to permit searches to work past/across NUL bytes.

ok millert@@ shadchin@@
@
text
@d130 1
a130 1
	if (caseless != OPT_ONPLUS)
@


1.3
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d309 5
@


1.2
log
@Unlike less, more should use basic regular expressions.
OK schwarze@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d29 10
a38 1
	if ((search_type & SRCH_NO_REGEX) == 0)
d40 8
d49 11
a59 11
		regex_t *comp = (regex_t *) ecalloc(1, sizeof(regex_t));
		regex_t **pcomp = (regex_t **) comp_pattern;
		if (regcomp(comp, pattern, less_is_more ? 0 : REGCOMP_FLAG))
		{
			free(comp);
			error("Invalid pattern", NULL_PARG);
			return (-1);
		}
		if (*pcomp != NULL)
			regfree(*pcomp);
		*pcomp = comp;
d62 14
a75 14
		pcre *comp;
		pcre **pcomp = (pcre **) comp_pattern;
		const char *errstring;
		int erroffset;
		PARG parg;
		comp = pcre_compile(pattern, 0,
				&errstring, &erroffset, NULL);
		if (comp == NULL)
		{
			parg.p_string = (char *) errstring;
			error("%s", &parg);
			return (-1);
		}
		*pcomp = comp;
d78 8
a85 8
		PARG parg;
		int *pcomp = (int *) comp_pattern;
		if ((parg.p_string = re_comp(pattern)) != NULL)
		{
			error("%s", &parg);
			return (-1);
		}
		*pcomp = 1;
d88 10
a97 10
		char *comp;
		char **pcomp = (char **) comp_pattern;
		if ((comp = regcmp(pattern, 0)) == NULL)
		{
			error("Invalid pattern", NULL_PARG);
			return (-1);
		}
		if (pcomp != NULL)
			free(*pcomp);
		*pcomp = comp;
d100 13
a112 13
		struct regexp *comp;
		struct regexp **pcomp = (struct regexp **) comp_pattern;
		if ((comp = regcomp(pattern)) == NULL)
		{
			/*
			 * regcomp has already printed an error message 
			 * via regerror().
			 */
			return (-1);
		}
		if (*pcomp != NULL)
			free(*pcomp);
		*pcomp = comp;
d114 1
a114 1
	}
d150 6
d193 3
a210 3
#if NO_REGEX
	return (search_pattern != NULL);
#endif
d262 3
d281 3
d288 17
a358 3
#endif
#if NO_REGEX
	matched = match(tpattern, strlen(tpattern), line, line_len, sp, ep);
@


1.1
log
@Initial revision
@
text
@d19 1
d35 1
a35 1
		if (regcomp(comp, pattern, REGCOMP_FLAG))
@


1.1.1.1
log
@Import of Less 444

ok nicm@@
@
text
@@


1.1.1.2
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
a18 1
extern int less_is_more;
d29 1
a29 10
	if (search_type & SRCH_NO_REGEX)
		return (0);
  {
#if HAVE_GNU_REGEX
	struct re_pattern_buffer *comp = (struct re_pattern_buffer *)
		ecalloc(1, sizeof(struct re_pattern_buffer));
	struct re_pattern_buffer **pcomp = 
		(struct re_pattern_buffer **) comp_pattern;
	re_set_syntax(RE_SYNTAX_POSIX_EXTENDED);
	if (re_compile_pattern(pattern, strlen(pattern), comp))
a30 8
		free(comp);
		error("Invalid pattern", NULL_PARG);
		return (-1);
	}
	if (*pcomp != NULL)
		regfree(*pcomp);
	*pcomp = comp;
#endif
d32 11
a42 11
	regex_t *comp = (regex_t *) ecalloc(1, sizeof(regex_t));
	regex_t **pcomp = (regex_t **) comp_pattern;
	if (regcomp(comp, pattern, less_is_more ? 0 : REGCOMP_FLAG))
	{
		free(comp);
		error("Invalid pattern", NULL_PARG);
		return (-1);
	}
	if (*pcomp != NULL)
		regfree(*pcomp);
	*pcomp = comp;
d45 14
a58 14
	pcre *comp;
	pcre **pcomp = (pcre **) comp_pattern;
	constant char *errstring;
	int erroffset;
	PARG parg;
	comp = pcre_compile(pattern, 0,
			&errstring, &erroffset, NULL);
	if (comp == NULL)
	{
		parg.p_string = (char *) errstring;
		error("%s", &parg);
		return (-1);
	}
	*pcomp = comp;
d61 8
a68 8
	PARG parg;
	int *pcomp = (int *) comp_pattern;
	if ((parg.p_string = re_comp(pattern)) != NULL)
	{
		error("%s", &parg);
		return (-1);
	}
	*pcomp = 1;
d71 10
a80 10
	char *comp;
	char **pcomp = (char **) comp_pattern;
	if ((comp = regcmp(pattern, 0)) == NULL)
	{
		error("Invalid pattern", NULL_PARG);
		return (-1);
	}
	if (pcomp != NULL)
		free(*pcomp);
	*pcomp = comp;
d83 14
a96 9
	struct regexp *comp;
	struct regexp **pcomp = (struct regexp **) comp_pattern;
	if ((comp = regcomp(pattern)) == NULL)
	{
		/*
		 * regcomp has already printed an error message 
		 * via regerror().
		 */
		return (-1);
a97 5
	if (*pcomp != NULL)
		free(*pcomp);
	*pcomp = comp;
#endif
  }
a132 6
#if HAVE_GNU_REGEX
	struct re_pattern_buffer **pcomp = (struct re_pattern_buffer **) pattern;
	if (*pcomp != NULL)
		regfree(*pcomp);
	*pcomp = NULL;
#endif
a169 3
#if HAVE_GNU_REGEX
	return (pattern == NULL);
#endif
d185 3
a238 3
#if HAVE_GNU_REGEX
	struct re_pattern_buffer *spattern = (struct re_pattern_buffer *) pattern;
#endif
a254 3
#if NO_REGEX
	search_type |= SRCH_NO_REGEX;
#endif
a258 17
#if HAVE_GNU_REGEX
	{
		struct re_registers search_regs;
		regoff_t *starts = (regoff_t *) ecalloc(1, sizeof (regoff_t));
		regoff_t *ends = (regoff_t *) ecalloc(1, sizeof (regoff_t));
		spattern->not_bol = notbol;
		re_set_registers(spattern, &search_regs, 1, starts, ends);
		matched = re_search(spattern, line, line_len, 0, line_len, &search_regs) >= 0;
		if (matched)
		{
			*sp = line + search_regs.start[0];
			*ep = line + search_regs.end[0];
		}
		free(starts);
		free(ends);
	}
#endif
d313 3
@

