head	1.16;
access;
symbols
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.6.0.12
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.8
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.4.0.34
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.32
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.30
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.26
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.28
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.24
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	W32EN7Zp77efb8wW;

1.15
date	2016.03.16.15.36.26;	author mmcc;	state Exp;
branches;
next	1.14;
commitid	P9ytq8HKajWPxZf9;

1.14
date	2016.01.12.17.48.04;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	O36S2Tb0ReI34f9s;

1.13
date	2015.11.23.09.42.57;	author nicm;	state Exp;
branches;
next	1.12;
commitid	5ESIlalVyuROskbp;

1.12
date	2015.11.09.14.25.32;	author mmcc;	state Exp;
branches;
next	1.11;
commitid	bgQj8bNZKDat4TZ4;

1.11
date	2015.11.09.04.10.57;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	E4Lg0tTt0vh4nd97;

1.10
date	2015.11.07.18.07.44;	author tedu;	state Exp;
branches;
next	1.9;
commitid	DJUwzdj0cG1bCfEw;

1.9
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.8;
commitid	QKrr6AuGzNx9nehL;

1.8
date	2015.11.05.22.08.43;	author nicm;	state Exp;
branches;
next	1.7;
commitid	yKv9Ck9ZDgwWTRTo;

1.7
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.16.11.30.02;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.13.18.26.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.00;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.41;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.41;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.01;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.42;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.16
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Functions which manipulate the command buffer.
 * Used only by command() and related functions.
 */

#include <sys/stat.h>

#include "charset.h"
#include "cmd.h"
#include "less.h"

extern int sc_width;
extern int utf_mode;

static char cmdbuf[CMDBUF_SIZE]; /* Buffer for holding a multi-char command */
static int cmd_col;		/* Current column of the cursor */
static int prompt_col;		/* Column of cursor just after prompt */
static char *cp;		/* Pointer into cmdbuf */
static int cmd_offset;		/* Index into cmdbuf of first displayed char */
static int literal;		/* Next input char should not be interpreted */
static int updown_match = -1;	/* Prefix length in up/down movement */

static int cmd_complete(int);
/*
 * These variables are statics used by cmd_complete.
 */
static int in_completion = 0;
static char *tk_text;
static char *tk_original;
static char *tk_ipoint;
static char *tk_trial;
static struct textlist tk_tlist;

static int cmd_left(void);
static int cmd_right(void);

char openquote = '"';
char closequote = '"';

/* History file */
#define	HISTFILE_FIRST_LINE	".less-history-file:"
#define	HISTFILE_SEARCH_SECTION	".search"
#define	HISTFILE_SHELL_SECTION	".shell"

/*
 * A mlist structure represents a command history.
 */
struct mlist {
	struct mlist *next;
	struct mlist *prev;
	struct mlist *curr_mp;
	char *string;
	int modified;
};

/*
 * These are the various command histories that exist.
 */
struct mlist mlist_search =
	{ &mlist_search,  &mlist_search,  &mlist_search,  NULL, 0 };
void * const ml_search = (void *) &mlist_search;

struct mlist mlist_examine =
	{ &mlist_examine, &mlist_examine, &mlist_examine, NULL, 0 };
void * const ml_examine = (void *) &mlist_examine;

struct mlist mlist_shell =
	{ &mlist_shell,   &mlist_shell,   &mlist_shell,   NULL, 0 };
void * const ml_shell = (void *) &mlist_shell;

/*
 * History for the current command.
 */
static struct mlist *curr_mlist = NULL;
static int curr_cmdflags;

static char cmd_mbc_buf[MAX_UTF_CHAR_LEN];
static int cmd_mbc_buf_len;
static int cmd_mbc_buf_index;


/*
 * Reset command buffer (to empty).
 */
void
cmd_reset(void)
{
	cp = cmdbuf;
	*cp = '\0';
	cmd_col = 0;
	cmd_offset = 0;
	literal = 0;
	cmd_mbc_buf_len = 0;
	updown_match = -1;
}

/*
 * Clear command line.
 */
void
clear_cmd(void)
{
	cmd_col = prompt_col = 0;
	cmd_mbc_buf_len = 0;
	updown_match = -1;
}

/*
 * Display a string, usually as a prompt for input into the command buffer.
 */
void
cmd_putstr(char *s)
{
	LWCHAR prev_ch = 0;
	LWCHAR ch;
	char *endline = s + strlen(s);
	while (*s != '\0') {
		char *ns = s;
		ch = step_char(&ns, +1, endline);
		while (s < ns)
			putchr(*s++);
		if (!utf_mode) {
			cmd_col++;
			prompt_col++;
		} else if (!is_composing_char(ch) &&
		    !is_combining_char(prev_ch, ch)) {
			int width = is_wide_char(ch) ? 2 : 1;
			cmd_col += width;
			prompt_col += width;
		}
		prev_ch = ch;
	}
}

/*
 * How many characters are in the command buffer?
 */
int
len_cmdbuf(void)
{
	char *s = cmdbuf;
	char *endline = s + strlen(s);
	int len = 0;

	while (*s != '\0') {
		step_char(&s, +1, endline);
		len++;
	}
	return (len);
}

/*
 * Common part of cmd_step_right() and cmd_step_left().
 */
static char *
cmd_step_common(char *p, LWCHAR ch, int len, int *pwidth, int *bswidth)
{
	char *pr;

	if (len == 1) {
		pr = prchar((int)ch);
		if (pwidth != NULL || bswidth != NULL) {
			int prlen = strlen(pr);
			if (pwidth != NULL)
				*pwidth = prlen;
			if (bswidth != NULL)
				*bswidth = prlen;
		}
	} else {
		pr = prutfchar(ch);
		if (pwidth != NULL || bswidth != NULL) {
			if (is_composing_char(ch)) {
				if (pwidth != NULL)
					*pwidth = 0;
				if (bswidth != NULL)
					*bswidth = 0;
			} else if (is_ubin_char(ch)) {
				int prlen = strlen(pr);
				if (pwidth != NULL)
					*pwidth = prlen;
				if (bswidth != NULL)
					*bswidth = prlen;
			} else {
				LWCHAR prev_ch = step_char(&p, -1, cmdbuf);
				if (is_combining_char(prev_ch, ch)) {
					if (pwidth != NULL)
						*pwidth = 0;
					if (bswidth != NULL)
						*bswidth = 0;
				} else {
					if (pwidth != NULL)
						*pwidth	= is_wide_char(ch)
						    ? 2 : 1;
					if (bswidth != NULL)
						*bswidth = 1;
				}
			}
		}
	}

	return (pr);
}

/*
 * Step a pointer one character right in the command buffer.
 */
static char *
cmd_step_right(char **pp, int *pwidth, int *bswidth)
{
	char *p = *pp;
	LWCHAR ch = step_char(pp, +1, p + strlen(p));

	return (cmd_step_common(p, ch, *pp - p, pwidth, bswidth));
}

/*
 * Step a pointer one character left in the command buffer.
 */
static char *
cmd_step_left(char **pp, int *pwidth, int *bswidth)
{
	char *p = *pp;
	LWCHAR ch = step_char(pp, -1, cmdbuf);

	return (cmd_step_common(*pp, ch, p - *pp, pwidth, bswidth));
}

/*
 * Repaint the line from cp onwards.
 * Then position the cursor just after the char old_cp (a pointer into cmdbuf).
 */
static void
cmd_repaint(char *old_cp)
{
	/*
	 * Repaint the line from the current position.
	 */
	clear_eol();
	while (*cp != '\0') {
		char *np = cp;
		int width;
		char *pr = cmd_step_right(&np, &width, NULL);
		if (cmd_col + width >= sc_width)
			break;
		cp = np;
		putstr(pr);
		cmd_col += width;
	}
	while (*cp != '\0') {
		char *np = cp;
		int width;
		char *pr = cmd_step_right(&np, &width, NULL);
		if (width > 0)
			break;
		cp = np;
		putstr(pr);
	}

	/*
	 * Back up the cursor to the correct position.
	 */
	while (cp > old_cp)
		cmd_left();
}

/*
 * Put the cursor at "home" (just after the prompt),
 * and set cp to the corresponding char in cmdbuf.
 */
static void
cmd_home(void)
{
	while (cmd_col > prompt_col) {
		int width, bswidth;

		cmd_step_left(&cp, &width, &bswidth);
		while (bswidth-- > 0)
			putbs();
		cmd_col -= width;
	}

	cp = &cmdbuf[cmd_offset];
}

/*
 * Shift the cmdbuf display left a half-screen.
 */
static void
cmd_lshift(void)
{
	char *s;
	char *save_cp;
	int cols;

	/*
	 * Start at the first displayed char, count how far to the
	 * right we'd have to move to reach the center of the screen.
	 */
	s = cmdbuf + cmd_offset;
	cols = 0;
	while (cols < (sc_width - prompt_col) / 2 && *s != '\0') {
		int width;
		cmd_step_right(&s, &width, NULL);
		cols += width;
	}
	while (*s != '\0') {
		int width;
		char *ns = s;
		cmd_step_right(&ns, &width, NULL);
		if (width > 0)
			break;
		s = ns;
	}

	cmd_offset = s - cmdbuf;
	save_cp = cp;
	cmd_home();
	cmd_repaint(save_cp);
}

/*
 * Shift the cmdbuf display right a half-screen.
 */
static void
cmd_rshift(void)
{
	char *s;
	char *save_cp;
	int cols;

	/*
	 * Start at the first displayed char, count how far to the
	 * left we'd have to move to traverse a half-screen width
	 * of displayed characters.
	 */
	s = cmdbuf + cmd_offset;
	cols = 0;
	while (cols < (sc_width - prompt_col) / 2 && s > cmdbuf) {
		int width;
		cmd_step_left(&s, &width, NULL);
		cols += width;
	}

	cmd_offset = s - cmdbuf;
	save_cp = cp;
	cmd_home();
	cmd_repaint(save_cp);
}

/*
 * Move cursor right one character.
 */
static int
cmd_right(void)
{
	char *pr;
	char *ncp;
	int width;

	if (*cp == '\0') {
		/* Already at the end of the line. */
		return (CC_OK);
	}
	ncp = cp;
	pr = cmd_step_right(&ncp, &width, NULL);
	if (cmd_col + width >= sc_width)
		cmd_lshift();
	else if (cmd_col + width == sc_width - 1 && cp[1] != '\0')
		cmd_lshift();
	cp = ncp;
	cmd_col += width;
	putstr(pr);
	while (*cp != '\0') {
		pr = cmd_step_right(&ncp, &width, NULL);
		if (width > 0)
			break;
		putstr(pr);
		cp = ncp;
	}
	return (CC_OK);
}

/*
 * Move cursor left one character.
 */
static int
cmd_left(void)
{
	char *ncp;
	int width, bswidth;

	if (cp <= cmdbuf) {
		/* Already at the beginning of the line */
		return (CC_OK);
	}
	ncp = cp;
	while (ncp > cmdbuf) {
		cmd_step_left(&ncp, &width, &bswidth);
		if (width > 0)
			break;
	}
	if (cmd_col < prompt_col + width)
		cmd_rshift();
	cp = ncp;
	cmd_col -= width;
	while (bswidth-- > 0)
		putbs();
	return (CC_OK);
}

/*
 * Insert a char into the command buffer, at the current position.
 */
static int
cmd_ichar(char *cs, int clen)
{
	char *s;

	if (strlen(cmdbuf) + clen >= sizeof (cmdbuf)-1) {
		/* No room in the command buffer for another char. */
		ring_bell();
		return (CC_ERROR);
	}

	/*
	 * Make room for the new character (shift the tail of the buffer right).
	 */
	for (s = &cmdbuf[strlen(cmdbuf)]; s >= cp; s--)
		s[clen] = s[0];
	/*
	 * Insert the character into the buffer.
	 */
	for (s = cp; s < cp + clen; s++)
		*s = *cs++;
	/*
	 * Reprint the tail of the line from the inserted char.
	 */
	updown_match = -1;
	cmd_repaint(cp);
	cmd_right();
	return (CC_OK);
}

/*
 * Backspace in the command buffer.
 * Delete the char to the left of the cursor.
 */
static int
cmd_erase(void)
{
	char *s;
	int clen;

	if (cp == cmdbuf) {
		/*
		 * Backspace past beginning of the buffer:
		 * this usually means abort the command.
		 */
		return (CC_QUIT);
	}
	/*
	 * Move cursor left (to the char being erased).
	 */
	s = cp;
	cmd_left();
	clen = s - cp;

	/*
	 * Remove the char from the buffer (shift the buffer left).
	 */
	for (s = cp; ; s++) {
		s[0] = s[clen];
		if (s[0] == '\0')
			break;
	}

	/*
	 * Repaint the buffer after the erased char.
	 */
	updown_match = -1;
	cmd_repaint(cp);

	/*
	 * We say that erasing the entire command string causes us
	 * to abort the current command, if CF_QUIT_ON_ERASE is set.
	 */
	if ((curr_cmdflags & CF_QUIT_ON_ERASE) && cp == cmdbuf && *cp == '\0')
		return (CC_QUIT);
	return (CC_OK);
}

/*
 * Delete the char under the cursor.
 */
static int
cmd_delete(void)
{
	if (*cp == '\0') {
		/* At end of string; there is no char under the cursor. */
		return (CC_OK);
	}
	/*
	 * Move right, then use cmd_erase.
	 */
	cmd_right();
	cmd_erase();
	return (CC_OK);
}

/*
 * Delete the "word" to the left of the cursor.
 */
static int
cmd_werase(void)
{
	if (cp > cmdbuf && cp[-1] == ' ') {
		/*
		 * If the char left of cursor is a space,
		 * erase all the spaces left of cursor (to the first non-space).
		 */
		while (cp > cmdbuf && cp[-1] == ' ')
			(void) cmd_erase();
	} else {
		/*
		 * If the char left of cursor is not a space,
		 * erase all the nonspaces left of cursor (the whole "word").
		 */
		while (cp > cmdbuf && cp[-1] != ' ')
			(void) cmd_erase();
	}
	return (CC_OK);
}

/*
 * Delete the "word" under the cursor.
 */
static int
cmd_wdelete(void)
{
	if (*cp == ' ') {
		/*
		 * If the char under the cursor is a space,
		 * delete it and all the spaces right of cursor.
		 */
		while (*cp == ' ')
			(void) cmd_delete();
	} else {
		/*
		 * If the char under the cursor is not a space,
		 * delete it and all nonspaces right of cursor (the whole word).
		 */
		while (*cp != ' ' && *cp != '\0')
			(void) cmd_delete();
	}
	return (CC_OK);
}

/*
 * Delete all chars in the command buffer.
 */
static int
cmd_kill(void)
{
	if (cmdbuf[0] == '\0') {
		/* Buffer is already empty; abort the current command. */
		return (CC_QUIT);
	}
	cmd_offset = 0;
	cmd_home();
	*cp = '\0';
	updown_match = -1;
	cmd_repaint(cp);

	/*
	 * We say that erasing the entire command string causes us
	 * to abort the current command, if CF_QUIT_ON_ERASE is set.
	 */
	if (curr_cmdflags & CF_QUIT_ON_ERASE)
		return (CC_QUIT);
	return (CC_OK);
}

/*
 * Select an mlist structure to be the current command history.
 */
void
set_mlist(void *mlist, int cmdflags)
{
	curr_mlist = (struct mlist *)mlist;
	curr_cmdflags = cmdflags;

	/* Make sure the next up-arrow moves to the last string in the mlist. */
	if (curr_mlist != NULL)
		curr_mlist->curr_mp = curr_mlist;
}

/*
 * Move up or down in the currently selected command history list.
 * Only consider entries whose first updown_match chars are equal to
 * cmdbuf's corresponding chars.
 */
static int
cmd_updown(int action)
{
	char *s;
	struct mlist *ml;

	if (curr_mlist == NULL) {
		/*
		 * The current command has no history list.
		 */
		ring_bell();
		return (CC_OK);
	}

	if (updown_match < 0) {
		updown_match = cp - cmdbuf;
	}

	/*
	 * Find the next history entry which matches.
	 */
	for (ml = curr_mlist->curr_mp; ; ) {
		ml = (action == EC_UP) ? ml->prev : ml->next;
		if (ml == curr_mlist) {
			/*
			 * We reached the end (or beginning) of the list.
			 */
			break;
		}
		if (strncmp(cmdbuf, ml->string, updown_match) == 0) {
			/*
			 * This entry matches; stop here.
			 * Copy the entry into cmdbuf and echo it on the screen.
			 */
			curr_mlist->curr_mp = ml;
			s = ml->string;
			if (s == NULL)
				s = "";
			cmd_home();
			clear_eol();
			strlcpy(cmdbuf, s, sizeof (cmdbuf));
			for (cp = cmdbuf; *cp != '\0'; )
				cmd_right();
			return (CC_OK);
		}
	}
	/*
	 * We didn't find a history entry that matches.
	 */
	ring_bell();
	return (CC_OK);
}

/*
 * Add a string to a history list.
 */
void
cmd_addhist(struct mlist *mlist, const char *cmd)
{
	struct mlist *ml;

	/*
	 * Don't save a trivial command.
	 */
	if (strlen(cmd) == 0)
		return;

	/*
	 * Save the command unless it's a duplicate of the
	 * last command in the history.
	 */
	ml = mlist->prev;
	if (ml == mlist || strcmp(ml->string, cmd) != 0) {
		/*
		 * Did not find command in history.
		 * Save the command and put it at the end of the history list.
		 */
		ml = ecalloc(1, sizeof (struct mlist));
		ml->string = estrdup(cmd);
		ml->next = mlist;
		ml->prev = mlist->prev;
		mlist->prev->next = ml;
		mlist->prev = ml;
	}
	/*
	 * Point to the cmd just after the just-accepted command.
	 * Thus, an UPARROW will always retrieve the previous command.
	 */
	mlist->curr_mp = ml->next;
}

/*
 * Accept the command in the command buffer.
 * Add it to the currently selected history list.
 */
void
cmd_accept(void)
{
	/*
	 * Nothing to do if there is no currently selected history list.
	 */
	if (curr_mlist == NULL)
		return;
	cmd_addhist(curr_mlist, cmdbuf);
	curr_mlist->modified = 1;
}

/*
 * Try to perform a line-edit function on the command buffer,
 * using a specified char as a line-editing command.
 * Returns:
 *	CC_PASS	The char does not invoke a line edit function.
 *	CC_OK	Line edit function done.
 *	CC_QUIT	The char requests the current command to be aborted.
 */
static int
cmd_edit(int c)
{
	int action;
	int flags;

#define	not_in_completion()	in_completion = 0

	/*
	 * See if the char is indeed a line-editing command.
	 */
	flags = 0;
	if (curr_mlist == NULL)
		/*
		 * No current history; don't accept history manipulation cmds.
		 */
		flags |= EC_NOHISTORY;
	if (curr_mlist == ml_search)
		/*
		 * In a search command; don't accept file-completion cmds.
		 */
		flags |= EC_NOCOMPLETE;

	action = editchar(c, flags);

	switch (action) {
	case EC_RIGHT:
		not_in_completion();
		return (cmd_right());
	case EC_LEFT:
		not_in_completion();
		return (cmd_left());
	case EC_W_RIGHT:
		not_in_completion();
		while (*cp != '\0' && *cp != ' ')
			cmd_right();
		while (*cp == ' ')
			cmd_right();
		return (CC_OK);
	case EC_W_LEFT:
		not_in_completion();
		while (cp > cmdbuf && cp[-1] == ' ')
			cmd_left();
		while (cp > cmdbuf && cp[-1] != ' ')
			cmd_left();
		return (CC_OK);
	case EC_HOME:
		not_in_completion();
		cmd_offset = 0;
		cmd_home();
		cmd_repaint(cp);
		return (CC_OK);
	case EC_END:
		not_in_completion();
		while (*cp != '\0')
			cmd_right();
		return (CC_OK);
	case EC_INSERT:
		not_in_completion();
		return (CC_OK);
	case EC_BACKSPACE:
		not_in_completion();
		return (cmd_erase());
	case EC_LINEKILL:
		not_in_completion();
		return (cmd_kill());
	case EC_ABORT:
		not_in_completion();
		(void) cmd_kill();
		return (CC_QUIT);
	case EC_W_BACKSPACE:
		not_in_completion();
		return (cmd_werase());
	case EC_DELETE:
		not_in_completion();
		return (cmd_delete());
	case EC_W_DELETE:
		not_in_completion();
		return (cmd_wdelete());
	case EC_LITERAL:
		literal = 1;
		return (CC_OK);
	case EC_UP:
	case EC_DOWN:
		not_in_completion();
		return (cmd_updown(action));
	case EC_F_COMPLETE:
	case EC_B_COMPLETE:
	case EC_EXPAND:
		return (cmd_complete(action));
	case EC_NOACTION:
		return (CC_OK);
	default:
		not_in_completion();
		return (CC_PASS);
	}
}

/*
 * Insert a string into the command buffer, at the current position.
 */
static int
cmd_istr(char *str)
{
	char *s;
	int action;
	char *endline = str + strlen(str);

	for (s = str; *s != '\0'; ) {
		char *os = s;
		step_char(&s, +1, endline);
		action = cmd_ichar(os, s - os);
		if (action != CC_OK) {
			ring_bell();
			return (action);
		}
	}
	return (CC_OK);
}

/*
 * Find the beginning and end of the "current" word.
 * This is the word which the cursor (cp) is inside or at the end of.
 * Return pointer to the beginning of the word and put the
 * cursor at the end of the word.
 */
static char *
delimit_word(void)
{
	char *word;
	char *p;
	int delim_quoted = 0;
	int meta_quoted = 0;
	char *esc = get_meta_escape();
	int esclen = strlen(esc);

	/*
	 * Move cursor to end of word.
	 */
	if (*cp != ' ' && *cp != '\0') {
		/*
		 * Cursor is on a nonspace.
		 * Move cursor right to the next space.
		 */
		while (*cp != ' ' && *cp != '\0')
			cmd_right();
	}

	/*
	 * Find the beginning of the word which the cursor is in.
	 */
	if (cp == cmdbuf)
		return (NULL);
	/*
	 * If we have an unbalanced quote (that is, an open quote
	 * without a corresponding close quote), we return everything
	 * from the open quote, including spaces.
	 */
	for (word = cmdbuf; word < cp; word++)
		if (*word != ' ')
			break;
	if (word >= cp)
		return (cp);
	for (p = cmdbuf; p < cp; p++) {
		if (meta_quoted) {
			meta_quoted = 0;
		} else if (esclen > 0 && p + esclen < cp &&
		    strncmp(p, esc, esclen) == 0) {
			meta_quoted = 1;
			p += esclen - 1;
		} else if (delim_quoted) {
			if (*p == closequote)
				delim_quoted = 0;
		} else { /* (!delim_quoted) */
			if (*p == openquote)
				delim_quoted = 1;
			else if (*p == ' ')
				word = p+1;
		}
	}
	return (word);
}

/*
 * Set things up to enter completion mode.
 * Expand the word under the cursor into a list of filenames
 * which start with that word, and set tk_text to that list.
 */
static void
init_compl(void)
{
	char *word;
	char c;

	free(tk_text);
	tk_text = NULL;
	/*
	 * Find the original (uncompleted) word in the command buffer.
	 */
	word = delimit_word();
	if (word == NULL)
		return;
	/*
	 * Set the insertion point to the point in the command buffer
	 * where the original (uncompleted) word now sits.
	 */
	tk_ipoint = word;
	/*
	 * Save the original (uncompleted) word
	 */
	free(tk_original);
	tk_original = ecalloc(cp-word+1, sizeof (char));
	(void) strncpy(tk_original, word, cp-word);
	/*
	 * Get the expanded filename.
	 * This may result in a single filename, or
	 * a blank-separated list of filenames.
	 */
	c = *cp;
	*cp = '\0';
	if (*word != openquote) {
		tk_text = fcomplete(word);
	} else {
		char *qword = shell_quote(word+1);
		if (qword == NULL)
			tk_text = fcomplete(word+1);
		else
			tk_text = fcomplete(qword);
		free(qword);
	}
	*cp = c;
}

/*
 * Return the next word in the current completion list.
 */
static char *
next_compl(int action, char *prev)
{
	switch (action) {
	case EC_F_COMPLETE:
		return (forw_textlist(&tk_tlist, prev));
	case EC_B_COMPLETE:
		return (back_textlist(&tk_tlist, prev));
	}
	/* Cannot happen */
	return ("?");
}

/*
 * Complete the filename before (or under) the cursor.
 * cmd_complete may be called multiple times.  The global in_completion
 * remembers whether this call is the first time (create the list),
 * or a subsequent time (step thru the list).
 */
static int
cmd_complete(int action)
{
	char *s;

	if (!in_completion || action == EC_EXPAND) {
		/*
		 * Expand the word under the cursor and
		 * use the first word in the expansion
		 * (or the entire expansion if we're doing EC_EXPAND).
		 */
		init_compl();
		if (tk_text == NULL) {
			ring_bell();
			return (CC_OK);
		}
		if (action == EC_EXPAND) {
			/*
			 * Use the whole list.
			 */
			tk_trial = tk_text;
		} else {
			/*
			 * Use the first filename in the list.
			 */
			in_completion = 1;
			init_textlist(&tk_tlist, tk_text);
			tk_trial = next_compl(action, NULL);
		}
	} else {
		/*
		 * We already have a completion list.
		 * Use the next/previous filename from the list.
		 */
		tk_trial = next_compl(action, tk_trial);
	}

	/*
	 * Remove the original word, or the previous trial completion.
	 */
	while (cp > tk_ipoint)
		(void) cmd_erase();

	if (tk_trial == NULL) {
		/*
		 * There are no more trial completions.
		 * Insert the original (uncompleted) filename.
		 */
		in_completion = 0;
		if (cmd_istr(tk_original) != CC_OK)
			goto fail;
	} else {
		/*
		 * Insert trial completion.
		 */
		if (cmd_istr(tk_trial) != CC_OK)
			goto fail;
		/*
		 * If it is a directory, append a slash.
		 */
		if (is_dir(tk_trial)) {
			if (cp > cmdbuf && cp[-1] == closequote)
				(void) cmd_erase();
			s = lgetenv("LESSSEPARATOR");
			if (s == NULL)
				s = "/";
			if (cmd_istr(s) != CC_OK)
				goto fail;
		}
	}

	return (CC_OK);

fail:
	in_completion = 0;
	ring_bell();
	return (CC_OK);
}

/*
 * Process a single character of a multi-character command, such as
 * a number, or the pattern of a search command.
 * Returns:
 *	CC_OK		The char was accepted.
 *	CC_QUIT		The char requests the command to be aborted.
 *	CC_ERROR	The char could not be accepted due to an error.
 */
int
cmd_char(int c)
{
	int action;
	int len;

	if (!utf_mode) {
		cmd_mbc_buf[0] = c & 0xff;
		len = 1;
	} else {
		/* Perform strict validation in all possible cases.  */
		if (cmd_mbc_buf_len == 0) {
retry:
			cmd_mbc_buf_index = 1;
			*cmd_mbc_buf = c & 0xff;
			if (IS_ASCII_OCTET(c))
				cmd_mbc_buf_len = 1;
			else if (IS_UTF8_LEAD(c)) {
				cmd_mbc_buf_len = utf_len(c);
				return (CC_OK);
			} else {
				/* UTF8_INVALID or stray UTF8_TRAIL */
				ring_bell();
				return (CC_ERROR);
			}
		} else if (IS_UTF8_TRAIL(c)) {
			cmd_mbc_buf[cmd_mbc_buf_index++] = c & 0xff;
			if (cmd_mbc_buf_index < cmd_mbc_buf_len)
				return (CC_OK);
			if (!is_utf8_well_formed(cmd_mbc_buf)) {
				/*
				 * complete, but not well formed
				 * (non-shortest form), sequence
				 */
				cmd_mbc_buf_len = 0;
				ring_bell();
				return (CC_ERROR);
			}
		} else {
			/* Flush incomplete (truncated) sequence.  */
			cmd_mbc_buf_len = 0;
			ring_bell();
			/* Handle new char.  */
			goto retry;
		}

		len = cmd_mbc_buf_len;
		cmd_mbc_buf_len = 0;
	}

	if (literal) {
		/*
		 * Insert the char, even if it is a line-editing char.
		 */
		literal = 0;
		return (cmd_ichar(cmd_mbc_buf, len));
	}

	/*
	 * See if it is a line-editing character.
	 */
	if (in_mca() && len == 1) {
		action = cmd_edit(c);
		switch (action) {
		case CC_OK:
		case CC_QUIT:
			return (action);
		case CC_PASS:
			break;
		}
	}

	/*
	 * Insert the char into the command buffer.
	 */
	return (cmd_ichar(cmd_mbc_buf, len));
}

/*
 * Return the number currently in the command buffer.
 */
off_t
cmd_int(long *frac)
{
	char *p;
	off_t n = 0;
	int err;

	for (p = cmdbuf; *p >= '0' && *p <= '9'; p++)
		n = (n * 10) + (*p - '0');
	*frac = 0;
	if (*p++ == '.') {
		*frac = getfraction(&p, NULL, &err);
		/* {{ do something if err is set? }} */
	}
	return (n);
}

/*
 * Return a pointer to the command buffer.
 */
char *
get_cmdbuf(void)
{
	return (cmdbuf);
}

/*
 * Return the last (most recent) string in the current command history.
 */
char *
cmd_lastpattern(void)
{
	if (curr_mlist == NULL)
		return (NULL);
	return (curr_mlist->curr_mp->prev->string);
}

/*
 * Get the name of the history file.
 */
static char *
histfile_name(void)
{
	char *home;
	char *name;

	/* See if filename is explicitly specified by $LESSHISTFILE. */
	name = lgetenv("LESSHISTFILE");
	if (name != NULL && *name != '\0') {
		if (strcmp(name, "-") == 0 || strcmp(name, "/dev/null") == 0)
			/* $LESSHISTFILE == "-" means don't use history file */
			return (NULL);
		return (estrdup(name));
	}

	/* Otherwise, file is in $HOME if enabled. */
	if (strcmp(LESSHISTFILE, "-") == 0)
		return (NULL);
	home = lgetenv("HOME");
	if (home == NULL || *home == '\0') {
		return (NULL);
	}
	return (easprintf("%s/%s", home, LESSHISTFILE));
}

/*
 * Initialize history from a .lesshist file.
 */
void
init_cmdhist(void)
{
	struct mlist *ml = NULL;
	char line[CMDBUF_SIZE];
	char *filename;
	FILE *f;
	char *p;

	filename = histfile_name();
	if (filename == NULL)
		return;
	f = fopen(filename, "r");
	free(filename);
	if (f == NULL)
		return;
	if (fgets(line, sizeof (line), f) == NULL ||
	    strncmp(line, HISTFILE_FIRST_LINE,
	    strlen(HISTFILE_FIRST_LINE)) != 0) {
		(void) fclose(f);
		return;
	}
	while (fgets(line, sizeof (line), f) != NULL) {
		for (p = line; *p != '\0'; p++) {
			if (*p == '\n' || *p == '\r') {
				*p = '\0';
				break;
			}
		}
		if (strcmp(line, HISTFILE_SEARCH_SECTION) == 0)
			ml = &mlist_search;
		else if (strcmp(line, HISTFILE_SHELL_SECTION) == 0) {
			ml = &mlist_shell;
		} else if (*line == '"') {
			if (ml != NULL)
				cmd_addhist(ml, line+1);
		}
	}
	(void) fclose(f);
}

/*
 *
 */
static void
save_mlist(struct mlist *ml, FILE *f)
{
	int histsize = 0;
	int n;
	char *s;

	s = lgetenv("LESSHISTSIZE");
	if (s != NULL)
		histsize = atoi(s);
	if (histsize == 0)
		histsize = 100;

	ml = ml->prev;
	for (n = 0; n < histsize; n++) {
		if (ml->string == NULL)
			break;
		ml = ml->prev;
	}
	for (ml = ml->next; ml->string != NULL; ml = ml->next)
		(void) fprintf(f, "\"%s\n", ml->string);
}

/*
 *
 */
void
save_cmdhist(void)
{
	char *filename;
	FILE *f;
	int modified = 0;
	int do_chmod = 1;
	struct stat statbuf;
	int r;

	if (mlist_search.modified)
		modified = 1;
	if (mlist_shell.modified)
		modified = 1;
	if (!modified)
		return;
	filename = histfile_name();
	if (filename == NULL)
		return;
	f = fopen(filename, "w");
	free(filename);
	if (f == NULL)
		return;

	/* Make history file readable only by owner. */
	r = fstat(fileno(f), &statbuf);
	if (r < 0 || !S_ISREG(statbuf.st_mode))
		/* Don't chmod if not a regular file. */
		do_chmod = 0;
	if (do_chmod)
		(void) fchmod(fileno(f), 0600);

	(void) fprintf(f, "%s\n", HISTFILE_FIRST_LINE);

	(void) fprintf(f, "%s\n", HISTFILE_SEARCH_SECTION);
	save_mlist(&mlist_search, f);

	(void) fprintf(f, "%s\n", HISTFILE_SHELL_SECTION);
	save_mlist(&mlist_shell, f);

	(void) fclose(f);
}
@


1.15
log
@style(9) includes

ok nicm@@
@
text
@d439 1
a439 1
	for (s = &cmdbuf[strlen(cmdbuf)];  s >= cp;  s--)
d444 1
a444 1
	for (s = cp;  s < cp + clen;  s++)
d886 1
a886 1
	for (word = cmdbuf;  word < cp;  word++)
d891 1
a891 1
	for (p = cmdbuf;  p < cp;  p++) {
d1158 1
a1158 1
	for (p = cmdbuf;  *p >= '0' && *p <= '9';  p++)
d1242 1
a1242 1
		for (p = line;  *p != '\0';  p++) {
d1277 1
a1277 1
	for (n = 0;  n < histsize;  n++) {
d1282 1
a1282 1
	for (ml = ml->next;  ml->string != NULL;  ml = ml->next)
@


1.14
log
@Remove LINUNUM, a needless alias for off_t. Also, remove a redundant
condition.

ok nicm@@
@
text
@d17 4
a21 3
#include "cmd.h"
#include "charset.h"
#include <sys/stat.h>
@


1.13
log
@Don't shadow a function argument.
@
text
@d1150 1
a1150 1
LINENUM
d1154 1
a1154 1
	LINENUM n = 0;
@


1.12
log
@Remove NULL-checks before free(), a needless comment, and a needless
void* cast.

ok nicm@@
@
text
@d173 1
a173 1
			int len = strlen(pr);
d175 1
a175 1
				*pwidth = len;
d177 1
a177 1
				*bswidth = len;
d188 1
a188 1
				int len = strlen(pr);
d190 1
a190 1
					*pwidth = len;
d192 1
a192 1
					*bswidth = len;
@


1.11
log
@cleanup struct definitions
@
text
@d921 2
a922 7
	/*
	 * Get rid of any previous tk_text.
	 */
	if (tk_text != NULL) {
		free(tk_text);
		tk_text = NULL;
	}
d937 1
a937 2
	if (tk_original != NULL)
		free(tk_original);
d951 1
a951 1
		if (qword == NULL) {
d953 1
a953 1
		} else {
d955 1
a955 2
			free(qword);
		}
@


1.10
log
@replace save() with estrdup() and make estrdup() exit like all the other
ecalloc, etc. functions do.
ok mmcc nicm
@
text
@d58 1
a58 2
struct mlist
{
@


1.9
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d691 1
a691 1
		ml->string = save(cmd);
d1210 1
a1210 1
		return (save(name));
@


1.8
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.7
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

a21 1
#if HAVE_STAT
a22 1
#endif
d35 1
a35 2
#if TAB_COMPLETE_FILENAME
static int cmd_complete();
a44 4
#endif

static int cmd_left();
static int cmd_right();
d46 2
a47 4
#if SPACES_IN_FILENAMES
public char openquote = '"';
public char closequote = '"';
#endif
d49 2
a50 1
#if CMD_HISTORY
d53 3
a55 3
#define HISTFILE_FIRST_LINE      ".less-history-file:"
#define HISTFILE_SEARCH_SECTION  ".search"
#define HISTFILE_SHELL_SECTION   ".shell"
d72 1
a72 1
struct mlist mlist_search =  
d74 1
a74 1
public void * constant ml_search = (void *) &mlist_search;
d76 1
a76 1
struct mlist mlist_examine = 
d78 1
a78 1
public void * constant ml_examine = (void *) &mlist_examine;
d80 1
a80 2
#if SHELL_ESCAPE || PIPEC
struct mlist mlist_shell =   
d82 1
a82 13
public void * constant ml_shell = (void *) &mlist_shell;
#endif

#else /* CMD_HISTORY */

/* If CMD_HISTORY is off, these are just flags. */
public void * constant ml_search = (void *)1;
public void * constant ml_examine = (void *)2;
#if SHELL_ESCAPE || PIPEC
public void * constant ml_shell = (void *)3;
#endif

#endif /* CMD_HISTORY */
d98 2
a99 2
	public void
cmd_reset()
d113 2
a114 2
	public void
clear_cmd()
d124 2
a125 3
	public void
cmd_putstr(s)
	char *s;
d130 1
a130 2
	while (*s != '\0')
	{
d135 1
a135 2
		if (!utf_mode)
		{
d138 2
a139 5
		}
#if !SMALL
		else if (!is_composing_char(ch) &&
		           !is_combining_char(prev_ch, ch))
		{
a143 1
#endif /* !SMALL */
d151 2
a152 2
	public int
len_cmdbuf()
d158 1
a158 2
	while (*s != '\0')
	{
d168 2
a169 7
	static char *
cmd_step_common(p, ch, len, pwidth, bswidth)
	char *p;
	LWCHAR ch;
	int len;
	int *pwidth;
	int *bswidth;
d173 3
a175 5
	if (len == 1)
	{
		pr = prchar((int) ch);
		if (pwidth != NULL || bswidth != NULL)
		{
d182 1
a182 4
	}
#if !SMALL
	else
	{
d184 2
a185 4
		if (pwidth != NULL || bswidth != NULL)
		{
			if (is_composing_char(ch))
			{
d190 1
a190 2
			} else if (is_ubin_char(ch))
			{
d196 1
a196 2
			} else
			{
d198 1
a198 2
				if (is_combining_char(prev_ch, ch))
				{
d203 1
a203 2
				} else
				{
d206 1
a206 2
							?	2
							:	1;
a212 1
#endif /* !SMALL */
d220 2
a221 5
	static char *
cmd_step_right(pp, pwidth, bswidth)
	char **pp;
	int *pwidth;
	int *bswidth;
d226 1
a226 1
	return cmd_step_common(p, ch, *pp - p, pwidth, bswidth);
d232 2
a233 5
	static char *
cmd_step_left(pp, pwidth, bswidth)
	char **pp;
	int *pwidth;
	int *bswidth;
d238 1
a238 1
	return cmd_step_common(*pp, ch, p - *pp, pwidth, bswidth);
d245 2
a246 3
	static void
cmd_repaint(old_cp)
	char *old_cp;
d252 1
a252 2
	while (*cp != '\0')
	{
d262 1
a262 2
	while (*cp != '\0')
	{
d283 2
a284 2
	static void
cmd_home()
d286 1
a286 2
	while (cmd_col > prompt_col)
	{
d301 2
a302 2
	static void
cmd_lshift()
d314 1
a314 2
	while (cols < (sc_width - prompt_col) / 2 && *s != '\0')
	{
d319 1
a319 2
	while (*s != '\0')
	{
d337 2
a338 2
	static void
cmd_rshift()
d351 1
a351 2
	while (cols < (sc_width - prompt_col) / 2 && s > cmdbuf)
	{
d366 2
a367 2
	static int
cmd_right()
d372 2
a373 3
	
	if (*cp == '\0')
	{
d386 1
a386 2
	while (*cp != '\0')
	{
d399 2
a400 2
	static int
cmd_left()
d404 2
a405 3
	
	if (cp <= cmdbuf)
	{
d410 1
a410 2
	while (ncp > cmdbuf)
	{
d427 2
a428 4
	static int
cmd_ichar(cs, clen)
	char *cs;
	int clen;
d431 2
a432 3
	
	if (strlen(cmdbuf) + clen >= sizeof(cmdbuf)-1)
	{
d434 1
a434 1
		bell();
d437 1
a437 1
		
d461 2
a462 2
	static int
cmd_erase()
d464 1
a464 1
	register char *s;
d467 1
a467 2
	if (cp == cmdbuf)
	{
d484 1
a484 2
	for (s = cp;  ;  s++)
	{
d495 1
a495 1
	
d508 2
a509 2
	static int
cmd_delete()
d511 1
a511 2
	if (*cp == '\0')
	{
d526 2
a527 2
	static int
cmd_werase()
d529 1
a529 2
	if (cp > cmdbuf && cp[-1] == ' ')
	{
d536 1
a536 2
	} else
	{
d550 2
a551 2
	static int
cmd_wdelete()
d553 1
a553 2
	if (*cp == ' ')
	{
d560 1
a560 2
	} else
	{
d574 2
a575 2
	static int
cmd_kill()
d577 1
a577 2
	if (cmdbuf[0] == '\0')
	{
d599 2
a600 4
	public void
set_mlist(mlist, cmdflags)
	void *mlist;
	int cmdflags;
d602 1
a602 2
#if CMD_HISTORY
	curr_mlist = (struct mlist *) mlist;
a607 1
#endif
a609 1
#if CMD_HISTORY
d615 2
a616 3
	static int
cmd_updown(action)
	int action;
d620 2
a621 3
	
	if (curr_mlist == NULL)
	{
d625 1
a625 1
		bell();
d629 1
a629 2
	if (updown_match < 0)
	{
d636 1
a636 2
	for (ml = curr_mlist->curr_mp;;)
	{
d638 1
a638 2
		if (ml == curr_mlist)
		{
d644 1
a644 2
		if (strncmp(cmdbuf, ml->string, updown_match) == 0)
		{
d655 2
a656 2
			strlcpy(cmdbuf, s, sizeof(cmdbuf));
			for (cp = cmdbuf;  *cp != '\0';  )
d664 1
a664 1
	bell();
a666 1
#endif
d671 2
a672 4
	public void
cmd_addhist(mlist, cmd)
	struct mlist *mlist;
	char *cmd;
a673 1
#if CMD_HISTORY
d675 1
a675 1
	
d687 1
a687 2
	if (ml == mlist || strcmp(ml->string, cmd) != 0)
	{
d692 1
a692 1
		ml = (struct mlist *) ecalloc(1, sizeof(struct mlist));
a703 1
#endif
d710 2
a711 2
	public void
cmd_accept()
a712 1
#if CMD_HISTORY
a719 1
#endif
d730 2
a731 3
	static int
cmd_edit(c)
	int c;
a735 1
#if TAB_COMPLETE_FILENAME
d737 1
a737 4
#else
#define	not_in_completion()
#endif
	
a741 1
#if CMD_HISTORY
a746 2
#endif
#if TAB_COMPLETE_FILENAME
a751 1
#endif
d755 1
a755 2
	switch (action)
	{
a811 1
#if CMD_HISTORY
a815 2
#endif
#if TAB_COMPLETE_FILENAME
a819 1
#endif
a827 1
#if TAB_COMPLETE_FILENAME
d831 2
a832 3
	static int
cmd_istr(str)
	char *str;
d837 2
a838 3
	
	for (s = str;  *s != '\0';  )
	{
d842 2
a843 3
		if (action != CC_OK)
		{
			bell();
d856 2
a857 2
	static char *
delimit_word()
a859 1
#if SPACES_IN_FILENAMES
d865 1
a865 2
#endif
	
d869 1
a869 2
	if (*cp != ' ' && *cp != '\0')
	{
a875 16
	} else if (cp > cmdbuf && cp[-1] != ' ')
	{
		/*
		 * Cursor is on a space, and char to the left is a nonspace.
		 * We're already at the end of the word.
		 */
		;
#if 0
	} else
	{
		/*
		 * Cursor is on a space and char to the left is a space.
		 * Huh? There's no word here.
		 */
		return (NULL);
#endif
d877 1
a882 1
#if SPACES_IN_FILENAMES
d893 2
a894 4
	for (p = cmdbuf;  p < cp;  p++)
	{
		if (meta_quoted)
		{
d897 1
a897 2
		           strncmp(p, esc, esclen) == 0)
		{
d900 1
a900 2
		} else if (delim_quoted)
		{
d903 1
a903 2
		} else /* (!delim_quoted) */
		{
a909 1
#endif
d915 1
a915 1
 * Expand the word under the cursor into a list of filenames 
d918 2
a919 2
	static void
init_compl()
d923 1
a923 1
	
d927 1
a927 2
	if (tk_text != NULL)
	{
d947 2
a948 2
	tk_original = (char *) ecalloc(cp-word+1, sizeof(char));
	strncpy(tk_original, word, cp-word);
d956 1
a956 2
	if (*word != openquote)
	{
d958 1
a958 5
	} else
	{
#if MSDOS_COMPILER
		char *qword = NULL;
#else
d960 1
a960 2
#endif
		if (qword == NULL)
d962 1
a962 2
		else
		{
d973 2
a974 4
	static char *
next_compl(action, prev)
	int action;
	char *prev;
d976 1
a976 2
	switch (action)
	{
d992 2
a993 3
	static int
cmd_complete(action)
	int action;
d997 1
a997 2
	if (!in_completion || action == EC_EXPAND)
	{
d999 2
a1000 2
		 * Expand the word under the cursor and 
		 * use the first word in the expansion 
d1004 2
a1005 3
		if (tk_text == NULL)
		{
			bell();
d1008 1
a1008 2
		if (action == EC_EXPAND)
		{
d1013 1
a1013 2
		} else
		{
d1019 1
a1019 1
			tk_trial = next_compl(action, (char*)NULL);
d1021 1
a1021 2
	} else
	{
d1028 4
a1031 4
	
  	/*
  	 * Remove the original word, or the previous trial completion.
  	 */
d1034 2
a1035 3
	
	if (tk_trial == NULL)
	{
d1043 1
a1043 2
	} else
	{
d1052 1
a1052 2
		if (is_dir(tk_trial))
		{
d1057 1
a1057 1
				s = PATHNAME_SEP;
d1062 1
a1062 1
	
d1064 1
a1064 1
	
d1067 1
a1067 1
	bell();
a1070 2
#endif /* TAB_COMPLETE_FILENAME */

d1079 2
a1080 3
	public int
cmd_char(c)
	int c;
d1085 2
a1086 3
	if (!utf_mode)
	{
		cmd_mbc_buf[0] = c;
d1088 1
a1088 4
	}
#if !SMALL
	else
	{
d1090 2
a1091 3
		if (cmd_mbc_buf_len == 0)
		{
		 retry:
d1093 1
a1093 1
			*cmd_mbc_buf = c;
d1096 1
a1096 2
			else if (IS_UTF8_LEAD(c))
			{
d1099 1
a1099 2
			} else
			{
d1101 1
a1101 1
				bell();
d1104 2
a1105 3
		} else if (IS_UTF8_TRAIL(c))
		{
			cmd_mbc_buf[cmd_mbc_buf_index++] = c;
d1108 5
a1112 3
			if (!is_utf8_well_formed(cmd_mbc_buf))
			{
				/* complete, but not well formed (non-shortest form), sequence */
d1114 1
a1114 1
				bell();
d1117 1
a1117 2
		} else
		{
d1120 1
a1120 1
			bell();
a1127 1
#endif /* !SMALL */
d1129 1
a1129 2
	if (literal)
	{
d1136 1
a1136 1
		
d1140 1
a1140 2
	if (in_mca() && len == 1)
	{
d1142 1
a1142 2
		switch (action)
		{
d1150 1
a1150 1
	
d1160 2
a1161 3
	public LINENUM
cmd_int(frac)
	long *frac;
d1170 1
a1170 2
	if (*p++ == '.')
	{
d1180 2
a1181 2
	public char *
get_cmdbuf()
a1185 1
#if CMD_HISTORY
d1189 2
a1190 2
	public char *
cmd_lastpattern()
a1195 1
#endif
a1196 1
#if CMD_HISTORY
d1200 2
a1201 2
	static char *
histfile_name()
d1205 1
a1205 2
	int len;
	
d1208 1
a1208 2
	if (name != NULL && *name != '\0')
	{
d1210 1
a1210 1
			/* $LESSHISTFILE == "-" means don't use a history file. */
d1216 1
a1216 1
	if (strcmp (LESSHISTFILE, "-") == 0)
d1219 2
a1220 7
	if (home == NULL || *home == '\0')
	{
#if OS2
		home = lgetenv("INIT");
		if (home == NULL || *home == '\0')
#endif
			return (NULL);
d1222 1
a1222 4
	len = strlen(home) + strlen(LESSHISTFILE) + 2;
	name = (char *) ecalloc(len, sizeof(char));
	SNPRINTF2(name, len, "%s/%s", home, LESSHISTFILE);
	return (name);
a1223 1
#endif /* CMD_HISTORY */
d1228 2
a1229 2
	public void
init_cmdhist()
a1230 1
#if CMD_HISTORY
d1244 4
a1247 4
	if (fgets(line, sizeof(line), f) == NULL ||
	    strncmp(line, HISTFILE_FIRST_LINE, strlen(HISTFILE_FIRST_LINE)) != 0)
	{
		fclose(f);
d1250 3
a1252 6
	while (fgets(line, sizeof(line), f) != NULL)
	{
		for (p = line;  *p != '\0';  p++)
		{
			if (*p == '\n' || *p == '\r')
			{
d1259 1
a1259 3
		else if (strcmp(line, HISTFILE_SHELL_SECTION) == 0)
		{
#if SHELL_ESCAPE || PIPEC
d1261 1
a1261 5
#else
			ml = NULL;
#endif
		} else if (*line == '"')
		{
d1266 1
a1266 2
	fclose(f);
#endif /* CMD_HISTORY */
d1272 2
a1273 5
#if CMD_HISTORY
	static void
save_mlist(ml, f)
	struct mlist *ml;
	FILE *f;
d1286 1
a1286 2
	for (n = 0;  n < histsize;  n++)
	{
d1292 1
a1292 1
		fprintf(f, "\"%s\n", ml->string);
a1293 1
#endif /* CMD_HISTORY */
d1298 2
a1299 2
	public void
save_cmdhist()
a1300 1
#if CMD_HISTORY
d1304 3
a1309 1
#if SHELL_ESCAPE || PIPEC
a1311 1
#endif
d1321 1
a1321 2
#if HAVE_FCHMOD
{
d1323 1
a1323 4
	int do_chmod = 1;
#if HAVE_STAT
	struct stat statbuf;
	int r = fstat(fileno(f), &statbuf);
a1326 1
#endif
d1328 1
a1328 3
		fchmod(fileno(f), 0600);
}
#endif
d1330 1
a1330 1
	fprintf(f, "%s\n", HISTFILE_FIRST_LINE);
d1332 1
a1332 1
	fprintf(f, "%s\n", HISTFILE_SEARCH_SECTION);
d1335 1
a1335 2
#if SHELL_ESCAPE || PIPEC
	fprintf(f, "%s\n", HISTFILE_SHELL_SECTION);
a1336 1
#endif
d1338 1
a1338 2
	fclose(f);
#endif /* CMD_HISTORY */
@


1.6
log
@Don't create a history file called -... doh. Pointed out by jmc.
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d32 1
d125 1
d136 1
d515 1
d559 1
d656 1
d689 2
d697 1
d707 6
a712 2
	cmd_home();
	clear_eol();
d714 1
a714 1
	 * Move curr_mp to the next/prev entry.
d716 28
a743 4
	if (action == EC_UP)
		curr_mlist->curr_mp = curr_mlist->curr_mp->prev;
	else
		curr_mlist->curr_mp = curr_mlist->curr_mp->next;
d745 1
a745 1
	 * Copy the entry into cmdbuf and echo it on the screen.
d747 1
a747 6
	s = curr_mlist->curr_mp->string;
	if (s == NULL)
		s = "";
	strlcpy(cmdbuf, s, sizeof(cmdbuf));
	for (cp = cmdbuf;  *cp != '\0';  )
		cmd_right();
d1096 3
d1100 1
a1505 3
	filename = histfile_name();
	if (filename == NULL)
		return;
d1513 3
@


1.5
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d1355 3
a1357 1
	/* Otherwise, file is in $HOME. */
@


1.4
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d19 4
d25 1
d56 6
d71 1
d78 1
a78 1
	{ &mlist_search,  &mlist_search,  &mlist_search,  NULL };
d82 1
a82 1
	{ &mlist_examine, &mlist_examine, &mlist_examine, NULL };
d87 1
a87 1
	{ &mlist_shell,   &mlist_shell,   &mlist_shell,   NULL };
d108 4
d124 1
d128 1
a128 1
 * Clear command line on display.
a132 1
	clear_bot();
d134 1
d144 25
a168 3
	putstr(s);
	cmd_col += strlen(s);
	prompt_col += strlen(s);
d177 110
a286 1
	return (strlen(cmdbuf));
a296 2
	char *p;

d301 1
a301 1
	for ( ;  *cp != '\0';  cp++)
d303 4
a306 2
		p = prchar(*cp);
		if (cmd_col + (int)strlen(p) >= sc_width)
d308 13
a320 2
		putstr(p);
		cmd_col += strlen(p);
d339 6
a344 2
		putbs();
		cmd_col--;
d367 14
a380 1
		cols += strlen(prchar(*s++));
a394 1
	char *p;
d407 3
a409 2
		p = prchar(*--s);
		cols += strlen(p);
d424 3
a426 1
	char *p;
d430 1
a430 3
		/* 
		 * Already at the end of the line.
		 */
d433 3
a435 2
	p = prchar(*cp);
	if (cmd_col + (int)strlen(p) >= sc_width)
d437 1
a437 1
	else if (cmd_col + (int)strlen(p) == sc_width - 1 && cp[1] != '\0')
d439 11
a449 3
	cp++;
	putstr(p);
	cmd_col += strlen(p);
d459 2
a460 1
	char *p;
d467 8
a474 2
	p = prchar(cp[-1]);
	if (cmd_col < prompt_col + (int)strlen(p))
d476 3
a478 3
	cp--;
	cmd_col -= strlen(p);
	while (*p++ != '\0')
d487 3
a489 2
cmd_ichar(c)
	int c;
d493 1
a493 1
	if (strlen(cmdbuf) >= sizeof(cmdbuf)-2)
d495 1
a495 3
		/*
		 * No room in the command buffer for another char.
		 */
d501 5
d508 2
a509 3
	for (s = &cmdbuf[strlen(cmdbuf)];  s >= cp;  s--)
		s[1] = s[0];
	*cp = c;
d526 1
d539 1
d541 2
d546 7
a552 2
	for (s = cp;  *s != '\0';  s++)
		s[0] = s[1];
d575 1
a575 3
		/*
		 * At end of string; there is no char under the cursor.
		 */
d646 1
a646 3
		/*
		 * Buffer is already empty; abort the current command.
		 */
d671 1
d674 5
d714 2
a715 3
	for (cp = cmdbuf;  *s != '\0';  s++)
	{
		*cp = *s;
a716 2
	}
	*cp = '\0';
d737 1
d739 2
a740 3
	 * Don't save if a duplicate of a command which is already 
	 * in the history.
	 * But select the one already in the history to be current.
d742 2
a743 6
	for (ml = mlist->next;  ml != mlist;  ml = ml->next)
	{
		if (strcmp(ml->string, cmd) == 0)
			break;
	}
	if (ml == mlist)
d778 1
d866 4
d912 1
d914 1
a914 1
	for (s = str;  *s != '\0';  s++)
d916 3
a918 1
		action = cmd_ichar(*s);
d1205 53
d1265 1
a1265 1
		return (cmd_ichar(c));
d1269 1
a1269 1
	 * See if it is a special line-editing character.
d1271 1
a1271 1
	if (in_mca())
d1287 1
a1287 1
	return (cmd_ichar(c));
d1294 2
a1295 1
cmd_int()
d1297 1
a1297 1
	register char *p;
d1299 1
d1301 8
a1308 2
	for (p = cmdbuf;  *p != '\0';  p++)
		n = (10 * n) + (*p - '0');
d1319 193
@


1.3
log
@kill more registers

millert@@ ok
@
text
@a0 2
/*	$OpenBSD: cmdbuf.c,v 1.2 2001/01/29 01:58:00 niklas Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d22 3
a24 2
static char cmdbuf[120];	/* Buffer for holding a multi-char command */
static int cmd_col;		/* Current column of the multi-char command */
d26 2
a27 1
static int literal;
d42 8
d67 2
a68 1
public void *ml_search = (void *) &mlist_search;
d71 2
a72 1
public void *ml_examine = (void *) &mlist_examine;
d76 13
a88 2
public void *ml_shell = (void *) &mlist_shell;
#endif /* SHELL_ESCAPE || PIPEC */
d94 1
a95 1
#endif /* CMD_HISTORY */
d106 1
d111 22
d142 182
d330 1
a330 3
	char *s;
	char *p;
	int col;
d341 1
a341 1
	 * Back up the pointer.
d343 1
a343 8
	--cp;
	/*
	 * Remember the current cursor column and 
	 * set it back the width of the char being erased.
	 */
	col = cmd_col;
	p = prchar(*cp);
	cmd_col -= strlen(p);
d345 1
a345 1
	 * Shift left the buffer after the erased char.
d350 1
a350 18
	 * Back up the cursor to the position of the erased char,
	 * clear the tail of the line,
	 * and reprint the line after the erased char.
	 */
	while (col > cmd_col)
	{
		putbs();
		col--;
	}
	clear_eol();
	for (s = cp;  *s != '\0';  s++)
	{
		p = prchar(*s);
		putstr(p);
		col += strlen(p);
	}
	/*
	 * Back up the cursor again.
d352 1
a352 5
	while (col > cmd_col)
	{
		putbs();
		col--;
	}
a354 1
	 * This is rather weird.
d356 1
a356 5
	 * to abort the current command, BUT ONLY IF there is no history
	 * for this type of command.  This causes commands like search (/)
	 * and edit (:e) to stay active even if we erase the entire string,
	 * but commands like <digit> and - go away when we erase the string.
	 * (See same thing in cmd_kill.)
d358 1
a358 1
	if (curr_mlist == NULL && cp == cmdbuf && *cp == '\0')
a368 2
	char *p;
	
d379 1
a379 4
	p = prchar(*cp);
	cp++;
	putstr(p);
	cmd_col += strlen(p);
a436 22
 * Move cursor to start of command buffer.
 */
	static int
cmd_home()
{
	char *p;
	
	/*
	 * Back up until we hit start of buffer.
	 */
	while (cp > cmdbuf)
	{
		cp--;
		p = prchar(*cp);
		cmd_col -= strlen(p);
		while (*p++ != '\0')
			putbs();
	}
	return (CC_OK);
}

/*
d449 2
a450 1
	(void) cmd_home();
d452 2
a453 1
	clear_eol();
d455 2
a456 2
	 * Same weirdness as in cmd_erase.
	 * If the current command has no history, abort the current command.
d458 1
a458 1
	if (curr_mlist == NULL)
a463 44
 * Move cursor right one character.
 */
	static int
cmd_right()
{
	char *p;
	
	if (*cp == '\0')
	{
		/* 
		 * Already at the end of the line.
		 */
		return (CC_OK);
	}
	p = prchar(*cp);
	cp++;
	putstr(p);
	cmd_col += strlen(p);
	return (CC_OK);
}

/*
 * Move cursor left one character.
 */
	static int
cmd_left()
{
	char *p;
	
	if (cp <= cmdbuf)
	{
		/* Already at the beginning of the line */
		return (CC_OK);
	}
	cp--;
	p = prchar(*cp);
	cmd_col -= strlen(p);
	while (*p++ != '\0')
		putbs();
	return (CC_OK);
}

#if CMD_HISTORY
/*
d467 1
a467 1
set_mlist(mlist)
d469 1
d472 1
d475 1
a482 1
	char *p;
d508 1
a508 1
	for (cp = cmdbuf;  *s != '\0';  s++, cp++)
d511 1
a511 3
		p = prchar(*cp);
		cmd_col += strlen(p);
		putstr(p);
d516 1
d519 1
a519 2
 * Accept the command in the command buffer.
 * Add it to the currently selected history list.
d522 3
a524 1
cmd_accept()
d526 1
a529 5
	 * Nothing to do if there is no currently selected history list.
	 */
	if (curr_mlist == NULL)
		return;
	/*
d532 1
a532 1
	if (strlen(cmdbuf) == 0)
d535 2
a536 1
	 * Don't save if a duplicate of a command which is already in the history.
d539 1
a539 1
	for (ml = curr_mlist->next;  ml != curr_mlist;  ml = ml->next)
d541 1
a541 1
		if (strcmp(ml->string, cmdbuf) == 0)
d544 1
a544 1
	if (ml == curr_mlist)
d551 5
a555 5
		ml->string = save(cmdbuf);
		ml->next = curr_mlist;
		ml->prev = curr_mlist->prev;
		curr_mlist->prev->next = ml;
		curr_mlist->prev = ml;
d561 2
a562 1
	curr_mlist->curr_mp = ml->next;
d564 15
d580 1
d607 1
d613 3
a615 1
	if (curr_mlist == &mlist_search)
d620 1
d648 4
a651 1
		return (cmd_home());
d690 2
a697 78
/*
 * Insert a char into the command buffer, at the current position.
 */
	static int
cmd_ichar(c)
	int c;
{
	int col;
	char *p;
	char *s;
	
	if (strlen(cmdbuf) >= sizeof(cmdbuf)-2)
	{
		/*
		 * No room in the command buffer for another char.
		 */
		bell();
		return (CC_ERROR);
	}
		
	/*
	 * Remember the current cursor column and 
	 * move it forward the width of the char being inserted.
	 */
	col = cmd_col;
	p = prchar(c);
	cmd_col += strlen(p);
	if (cmd_col >= sc_width-1)
	{
		cmd_col -= strlen(p);
		bell();
		return (CC_ERROR);
	}
	/*
	 * Insert the character in the string.
	 * First, make room for the new char.
	 */
	for (s = &cmdbuf[strlen(cmdbuf)];  s >= cp;  s--)
		s[1] = s[0];
	*cp++ = c;
	/*
	 * Reprint the tail of the line after the inserted char.
	 */
	clear_eol();
	for (s = cp-1;  *s != '\0';  s++)
	{
		p = prchar(*s);
		col += strlen(p);
		if (col >= sc_width-1)
		{
			/*
			 * Oops.  There is no room on the screen
			 * for the new char.  Back up the cursor to
			 * just after the inserted char and erase it.
			 */
			col -= strlen(p);
			while (col > cmd_col)
			{
				putbs();
				col--;
			}
			(void) cmd_erase();
			bell();
			return (CC_ERROR);
		}
		putstr(p);
	}
	/*
	 * Back up the cursor to just after the inserted char.
	 */
	while (col > cmd_col)
	{
		putbs();
		col--;
	}
	return (CC_OK);
}

d731 7
d757 1
d765 1
d768 1
a768 1
	 * Search backwards for beginning of the word.
d772 8
a779 2
	for (word = cp-1;  word > cmdbuf;  word--)
		if (word[-1] == ' ')
d781 25
d853 14
a866 1
	tk_text = fcomplete(word);
d875 1
a875 1
     	int action;
a883 3
	default:
		/* Cannot happen */
		return ("?");
d885 2
d899 1
d960 13
d1027 1
a1027 4
	action = cmd_ichar(c);
	if (action != CC_OK)
		return (action);
	return (CC_OK);
d1033 1
a1033 1
	public int
d1036 2
a1037 2
	return (atoi(cmdbuf));
}
d1039 3
a1041 9
/*
 * Display a string, usually as a prompt for input into the command buffer.
 */
	public void
cmd_putstr(s)
	char *s;
{
	putstr(s);
	cmd_col += strlen(s);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d120 1
a120 1
	register char *s;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d38 2
a39 3
static char cmdbuf[CMDBUF_SIZE]; /* Buffer for holding a multi-char command */
static int cmd_col;		/* Current column of the cursor */
static int prompt_col;		/* Column of cursor just after prompt */
d41 1
a41 2
static int cmd_offset;		/* Index into cmdbuf of first displayed char */
static int literal;		/* Next input char should not be interpreted */
a55 8
static int cmd_left();
static int cmd_right();

#if SPACES_IN_FILENAMES
public char openquote = '"';
public char closequote = '"';
#endif

d73 1
a73 2
public void * constant ml_search = (void *) &mlist_search;

d76 1
a76 2
public void * constant ml_examine = (void *) &mlist_examine;

d80 2
a81 13
public void * constant ml_shell = (void *) &mlist_shell;
#endif

#else /* CMD_HISTORY */

/* If CMD_HISTORY is off, these are just flags. */
public void * constant ml_search = (void *)1;
public void * constant ml_examine = (void *)2;
#if SHELL_ESCAPE || PIPEC
public void * constant ml_shell = (void *)3;
#endif

#endif /* CMD_HISTORY */
a86 1
static int curr_cmdflags;
d88 1
a98 1
	cmd_offset = 0;
a102 22
 * Clear command line on display.
 */
	public void
clear_cmd()
{
	clear_bot();
	cmd_col = prompt_col = 0;
}

/*
 * Display a string, usually as a prompt for input into the command buffer.
 */
	public void
cmd_putstr(s)
	char *s;
{
	putstr(s);
	cmd_col += strlen(s);
	prompt_col += strlen(s);
}

/*
a111 182
 * Repaint the line from cp onwards.
 * Then position the cursor just after the char old_cp (a pointer into cmdbuf).
 */
	static void
cmd_repaint(old_cp)
	char *old_cp;
{
	char *p;

	/*
	 * Repaint the line from the current position.
	 */
	clear_eol();
	for ( ;  *cp != '\0';  cp++)
	{
		p = prchar(*cp);
		if (cmd_col + (int)strlen(p) >= sc_width)
			break;
		putstr(p);
		cmd_col += strlen(p);
	}

	/*
	 * Back up the cursor to the correct position.
	 */
	while (cp > old_cp)
		cmd_left();
}

/*
 * Put the cursor at "home" (just after the prompt),
 * and set cp to the corresponding char in cmdbuf.
 */
	static void
cmd_home()
{
	while (cmd_col > prompt_col)
	{
		putbs();
		cmd_col--;
	}

	cp = &cmdbuf[cmd_offset];
}

/*
 * Shift the cmdbuf display left a half-screen.
 */
	static void
cmd_lshift()
{
	char *s;
	char *save_cp;
	int cols;

	/*
	 * Start at the first displayed char, count how far to the
	 * right we'd have to move to reach the center of the screen.
	 */
	s = cmdbuf + cmd_offset;
	cols = 0;
	while (cols < (sc_width - prompt_col) / 2 && *s != '\0')
		cols += strlen(prchar(*s++));

	cmd_offset = s - cmdbuf;
	save_cp = cp;
	cmd_home();
	cmd_repaint(save_cp);
}

/*
 * Shift the cmdbuf display right a half-screen.
 */
	static void
cmd_rshift()
{
	char *s;
	char *p;
	char *save_cp;
	int cols;

	/*
	 * Start at the first displayed char, count how far to the
	 * left we'd have to move to traverse a half-screen width
	 * of displayed characters.
	 */
	s = cmdbuf + cmd_offset;
	cols = 0;
	while (cols < (sc_width - prompt_col) / 2 && s > cmdbuf)
	{
		p = prchar(*--s);
		cols += strlen(p);
	}

	cmd_offset = s - cmdbuf;
	save_cp = cp;
	cmd_home();
	cmd_repaint(save_cp);
}

/*
 * Move cursor right one character.
 */
	static int
cmd_right()
{
	char *p;
	
	if (*cp == '\0')
	{
		/* 
		 * Already at the end of the line.
		 */
		return (CC_OK);
	}
	p = prchar(*cp);
	if (cmd_col + (int)strlen(p) >= sc_width)
		cmd_lshift();
	else if (cmd_col + (int)strlen(p) == sc_width - 1 && cp[1] != '\0')
		cmd_lshift();
	cp++;
	putstr(p);
	cmd_col += strlen(p);
	return (CC_OK);
}

/*
 * Move cursor left one character.
 */
	static int
cmd_left()
{
	char *p;
	
	if (cp <= cmdbuf)
	{
		/* Already at the beginning of the line */
		return (CC_OK);
	}
	p = prchar(cp[-1]);
	if (cmd_col < prompt_col + (int)strlen(p))
		cmd_rshift();
	cp--;
	cmd_col -= strlen(p);
	while (*p++ != '\0')
		putbs();
	return (CC_OK);
}

/*
 * Insert a char into the command buffer, at the current position.
 */
	static int
cmd_ichar(c)
	int c;
{
	char *s;
	
	if (strlen(cmdbuf) >= sizeof(cmdbuf)-2)
	{
		/*
		 * No room in the command buffer for another char.
		 */
		bell();
		return (CC_ERROR);
	}
		
	/*
	 * Insert the character into the buffer.
	 */
	for (s = &cmdbuf[strlen(cmdbuf)];  s >= cp;  s--)
		s[1] = s[0];
	*cp = c;
	/*
	 * Reprint the tail of the line from the inserted char.
	 */
	cmd_repaint(cp);
	cmd_right();
	return (CC_OK);
}

/*
d119 2
d131 6
a136 1
	 * Move cursor left (to the char being erased).
d138 3
a140 1
	cmd_left();
d142 1
a142 1
	 * Remove the char from the buffer (shift the buffer left).
d147 3
a149 1
	 * Repaint the buffer after the erased char.
d151 20
a170 1
	cmd_repaint(cp);
d173 1
d175 5
a179 1
	 * to abort the current command, if CF_QUIT_ON_ERASE is set.
d181 1
a181 1
	if ((curr_cmdflags & CF_QUIT_ON_ERASE) && cp == cmdbuf && *cp == '\0')
d192 2
d204 4
a207 1
	cmd_right();
d265 22
d299 1
a299 2
	cmd_offset = 0;
	cmd_home();
d301 1
a301 2
	cmd_repaint(cp);

d303 2
a304 2
	 * We say that erasing the entire command string causes us
	 * to abort the current command, if CF_QUIT_ON_ERASE is set.
d306 1
a306 1
	if (curr_cmdflags & CF_QUIT_ON_ERASE)
d312 44
d359 1
a359 1
set_mlist(mlist, cmdflags)
a360 1
	int cmdflags;
a362 1
	curr_cmdflags = cmdflags;
a364 1
#if CMD_HISTORY
d372 1
d398 1
a398 1
	for (cp = cmdbuf;  *s != '\0';  s++)
d401 3
a403 1
		cmd_right();
a407 1
#endif
d410 2
a411 1
 * Add a string to a history list.
d414 1
a414 3
cmd_addhist(mlist, cmd)
	struct mlist *mlist;
	char *cmd;
a415 1
#if CMD_HISTORY
d419 5
d426 1
a426 1
	if (strlen(cmd) == 0)
d429 1
a429 2
	 * Don't save if a duplicate of a command which is already 
	 * in the history.
d432 1
a432 1
	for (ml = mlist->next;  ml != mlist;  ml = ml->next)
d434 1
a434 1
		if (strcmp(ml->string, cmd) == 0)
d437 1
a437 1
	if (ml == mlist)
d444 5
a448 5
		ml->string = save(cmd);
		ml->next = mlist;
		ml->prev = mlist->prev;
		mlist->prev->next = ml;
		mlist->prev = ml;
d454 1
a454 2
	mlist->curr_mp = ml->next;
#endif
a455 15

/*
 * Accept the command in the command buffer.
 * Add it to the currently selected history list.
 */
	public void
cmd_accept()
{
#if CMD_HISTORY
	/*
	 * Nothing to do if there is no currently selected history list.
	 */
	if (curr_mlist == NULL)
		return;
	cmd_addhist(curr_mlist, cmdbuf);
a456 1
}
a482 1
#if CMD_HISTORY
d488 1
a488 3
#endif
#if TAB_COMPLETE_FILENAME
	if (curr_mlist == ml_search)
a492 1
#endif
d520 1
a520 4
		cmd_offset = 0;
		cmd_home();
		cmd_repaint(cp);
		return (CC_OK);
a558 2
	case EC_NOACTION:
		return (CC_OK);
d565 78
a675 7
#if SPACES_IN_FILENAMES
	char *p;
	int delim_quoted = 0;
	int meta_quoted = 0;
	char *esc = get_meta_escape();
	int esclen = strlen(esc);
#endif
a694 1
#if 0
a701 1
#endif
d704 1
a704 1
	 * Find the beginning of the word which the cursor is in.
d708 2
a709 8
#if SPACES_IN_FILENAMES
	/*
	 * If we have an unbalanced quote (that is, an open quote
	 * without a corresponding close quote), we return everything
	 * from the open quote, including spaces.
	 */
	for (word = cmdbuf;  word < cp;  word++)
		if (*word != ' ')
a710 25
	if (word >= cp)
		return (cp);
	for (p = cmdbuf;  p < cp;  p++)
	{
		if (meta_quoted)
		{
			meta_quoted = 0;
		} else if (esclen > 0 && p + esclen < cp &&
		           strncmp(p, esc, esclen) == 0)
		{
			meta_quoted = 1;
			p += esclen - 1;
		} else if (delim_quoted)
		{
			if (*p == closequote)
				delim_quoted = 0;
		} else /* (!delim_quoted) */
		{
			if (*p == openquote)
				delim_quoted = 1;
			else if (*p == ' ')
				word = p+1;
		}
	}
#endif
d758 1
a758 14
	if (*word != openquote)
	{
		tk_text = fcomplete(word);
	} else
	{
		char *qword = shell_quote(word+1);
		if (qword == NULL)
			tk_text = fcomplete(word+1);
		else
		{
			tk_text = fcomplete(qword);
			free(qword);
		}
	}
d767 1
a767 1
	int action;
d776 3
a779 2
	/* Cannot happen */
	return ("?");
a791 1
	char *s;
a851 13
		/*
		 * If it is a directory, append a slash.
		 */
		if (is_dir(tk_trial))
		{
			if (cp > cmdbuf && cp[-1] == closequote)
				(void) cmd_erase();
			s = lgetenv("LESSSEPARATOR");
			if (s == NULL)
				s = PATHNAME_SEP;
			if (cmd_istr(s) != CC_OK)
				goto fail;
		}
d906 4
a909 1
	return (cmd_ichar(c));
d915 1
a915 1
	public LINENUM
d918 2
a919 2
	register char *p;
	LINENUM n = 0;
d921 9
a929 3
	for (p = cmdbuf;  *p != '\0';  p++)
		n = (10 * n) + (*p - '0');
	return (n);
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
a18 4
#include "charset.h"
#if HAVE_STAT
#include <sys/stat.h>
#endif
a20 1
extern int utf_mode;
a50 6

/* History file */
#define HISTFILE_FIRST_LINE      ".less-history-file:"
#define HISTFILE_SEARCH_SECTION  ".search"
#define HISTFILE_SHELL_SECTION   ".shell"

a59 1
	int modified;
d66 1
a66 1
	{ &mlist_search,  &mlist_search,  &mlist_search,  NULL, 0 };
d70 1
a70 1
	{ &mlist_examine, &mlist_examine, &mlist_examine, NULL, 0 };
d75 1
a75 1
	{ &mlist_shell,   &mlist_shell,   &mlist_shell,   NULL, 0 };
a95 4
static char cmd_mbc_buf[MAX_UTF_CHAR_LEN];
static int cmd_mbc_buf_len;
static int cmd_mbc_buf_index;

a107 1
	cmd_mbc_buf_len = 0;
d111 1
a111 1
 * Clear command line.
d116 1
a117 1
	cmd_mbc_buf_len = 0;
d127 3
a129 22
	LWCHAR prev_ch = 0;
	LWCHAR ch;
	char *endline = s + strlen(s);
	while (*s != '\0')
	{
		char *ns = s;
		ch = step_char(&ns, +1, endline);
		while (s < ns)
			putchr(*s++);
		if (!utf_mode)
		{
			cmd_col++;
			prompt_col++;
		} else if (!is_composing_char(ch) &&
		           !is_combining_char(prev_ch, ch))
		{
			int width = is_wide_char(ch) ? 2 : 1;
			cmd_col += width;
			prompt_col += width;
		}
		prev_ch = ch;
	}
d138 1
a138 107
	char *s = cmdbuf;
	char *endline = s + strlen(s);
	int len = 0;

	while (*s != '\0')
	{
		step_char(&s, +1, endline);
		len++;
	}
	return (len);
}

/*
 * Common part of cmd_step_right() and cmd_step_left().
 */
	static char *
cmd_step_common(p, ch, len, pwidth, bswidth)
	char *p;
	LWCHAR ch;
	int len;
	int *pwidth;
	int *bswidth;
{
	char *pr;

	if (len == 1)
	{
		pr = prchar((int) ch);
		if (pwidth != NULL || bswidth != NULL)
		{
			int len = strlen(pr);
			if (pwidth != NULL)
				*pwidth = len;
			if (bswidth != NULL)
				*bswidth = len;
		}
	} else
	{
		pr = prutfchar(ch);
		if (pwidth != NULL || bswidth != NULL)
		{
			if (is_composing_char(ch))
			{
				if (pwidth != NULL)
					*pwidth = 0;
				if (bswidth != NULL)
					*bswidth = 0;
			} else if (is_ubin_char(ch))
			{
				int len = strlen(pr);
				if (pwidth != NULL)
					*pwidth = len;
				if (bswidth != NULL)
					*bswidth = len;
			} else
			{
				LWCHAR prev_ch = step_char(&p, -1, cmdbuf);
				if (is_combining_char(prev_ch, ch))
				{
					if (pwidth != NULL)
						*pwidth = 0;
					if (bswidth != NULL)
						*bswidth = 0;
				} else
				{
					if (pwidth != NULL)
						*pwidth	= is_wide_char(ch)
							?	2
							:	1;
					if (bswidth != NULL)
						*bswidth = 1;
				}
			}
		}
	}

	return (pr);
}

/*
 * Step a pointer one character right in the command buffer.
 */
	static char *
cmd_step_right(pp, pwidth, bswidth)
	char **pp;
	int *pwidth;
	int *bswidth;
{
	char *p = *pp;
	LWCHAR ch = step_char(pp, +1, p + strlen(p));

	return cmd_step_common(p, ch, *pp - p, pwidth, bswidth);
}

/*
 * Step a pointer one character left in the command buffer.
 */
	static char *
cmd_step_left(pp, pwidth, bswidth)
	char **pp;
	int *pwidth;
	int *bswidth;
{
	char *p = *pp;
	LWCHAR ch = step_char(pp, -1, cmdbuf);

	return cmd_step_common(*pp, ch, p - *pp, pwidth, bswidth);
d149 2
d155 1
a155 1
	while (*cp != '\0')
d157 2
a158 15
		char *np = cp;
		int width;
		char *pr = cmd_step_right(&np, &width, NULL);
		if (cmd_col + width >= sc_width)
			break;
		cp = np;
		putstr(pr);
		cmd_col += width;
	}
	while (*cp != '\0')
	{
		char *np = cp;
		int width;
		char *pr = cmd_step_right(&np, &width, NULL);
		if (width > 0)
d160 2
a161 2
		cp = np;
		putstr(pr);
d180 2
a181 6
		int width, bswidth;

		cmd_step_left(&cp, &width, &bswidth);
		while (bswidth-- > 0)
			putbs();
		cmd_col -= width;
d204 1
a204 14
	{
		int width;
		cmd_step_right(&s, &width, NULL);
		cols += width;
	}
	while (*s != '\0')
	{
		int width;
		char *ns = s;
		cmd_step_right(&ns, &width, NULL);
		if (width > 0)
			break;
		s = ns;
	}
d219 1
d232 2
a233 3
		int width;
		cmd_step_left(&s, &width, NULL);
		cols += width;
d248 1
a248 3
	char *pr;
	char *ncp;
	int width;
d252 3
a254 1
		/* Already at the end of the line. */
d257 2
a258 3
	ncp = cp;
	pr = cmd_step_right(&ncp, &width, NULL);
	if (cmd_col + width >= sc_width)
d260 1
a260 1
	else if (cmd_col + width == sc_width - 1 && cp[1] != '\0')
d262 3
a264 11
	cp = ncp;
	cmd_col += width;
	putstr(pr);
	while (*cp != '\0')
	{
		pr = cmd_step_right(&ncp, &width, NULL);
		if (width > 0)
			break;
		putstr(pr);
		cp = ncp;
	}
d274 1
a274 2
	char *ncp;
	int width, bswidth;
d281 2
a282 8
	ncp = cp;
	while (ncp > cmdbuf)
	{
		cmd_step_left(&ncp, &width, &bswidth);
		if (width > 0)
			break;
	}
	if (cmd_col < prompt_col + width)
d284 3
a286 3
	cp = ncp;
	cmd_col -= width;
	while (bswidth-- > 0)
d295 2
a296 3
cmd_ichar(cs, clen)
	char *cs;
	int clen;
d300 1
a300 1
	if (strlen(cmdbuf) + clen >= sizeof(cmdbuf)-1)
d302 3
a304 1
		/* No room in the command buffer for another char. */
d310 1
a310 1
	 * Make room for the new character (shift the tail of the buffer right).
d313 2
a314 6
		s[clen] = s[0];
	/*
	 * Insert the character into the buffer.
	 */
	for (s = cp;  s < cp + clen;  s++)
		*s = *cs++;
a330 1
	int clen;
a342 1
	s = cp;
a343 2
	clen = s - cp;

d347 2
a348 7
	for (s = cp;  ;  s++)
	{
		s[0] = s[clen];
		if (s[0] == '\0')
			break;
	}

d371 3
a373 1
		/* At end of string; there is no char under the cursor. */
d444 3
a446 1
		/* Buffer is already empty; abort the current command. */
a470 1
#if CMD_HISTORY
a472 5

	/* Make sure the next up-arrow moves to the last string in the mlist. */
	if (curr_mlist != NULL)
		curr_mlist->curr_mp = curr_mlist;
#endif
d508 3
a510 2
	strcpy(cmdbuf, s);
	for (cp = cmdbuf;  *cp != '\0';  )
d512 2
a533 1

d535 3
a537 2
	 * Save the command unless it's a duplicate of the
	 * last command in the history.
d539 6
a544 2
	ml = mlist->prev;
	if (ml == mlist || strcmp(ml->string, cmd) != 0)
a578 1
	curr_mlist->modified = 1;
a665 4
	case EC_ABORT:
		not_in_completion();
		(void) cmd_kill();
		return (CC_QUIT);
a707 1
	char *endline = str + strlen(str);
d709 1
a709 1
	for (s = str;  *s != '\0';  )
d711 1
a711 3
		char *os = s;
		step_char(&s, +1, endline);
		action = cmd_ichar(os, s - os);
a997 50
	int len;

	if (!utf_mode)
	{
		cmd_mbc_buf[0] = c;
		len = 1;
	} else
	{
		/* Perform strict validation in all possible cases.  */
		if (cmd_mbc_buf_len == 0)
		{
		 retry:
			cmd_mbc_buf_index = 1;
			*cmd_mbc_buf = c;
			if (IS_ASCII_OCTET(c))
				cmd_mbc_buf_len = 1;
			else if (IS_UTF8_LEAD(c))
			{
				cmd_mbc_buf_len = utf_len(c);
				return (CC_OK);
			} else
			{
				/* UTF8_INVALID or stray UTF8_TRAIL */
				bell();
				return (CC_ERROR);
			}
		} else if (IS_UTF8_TRAIL(c))
		{
			cmd_mbc_buf[cmd_mbc_buf_index++] = c;
			if (cmd_mbc_buf_index < cmd_mbc_buf_len)
				return (CC_OK);
			if (!is_utf8_well_formed(cmd_mbc_buf))
			{
				/* complete, but not well formed (non-shortest form), sequence */
				cmd_mbc_buf_len = 0;
				bell();
				return (CC_ERROR);
			}
		} else
		{
			/* Flush incomplete (truncated) sequence.  */
			cmd_mbc_buf_len = 0;
			bell();
			/* Handle new char.  */
			goto retry;
		}

		len = cmd_mbc_buf_len;
		cmd_mbc_buf_len = 0;
	}
d1005 1
a1005 1
		return (cmd_ichar(cmd_mbc_buf, len));
d1009 1
a1009 1
	 * See if it is a line-editing character.
d1011 1
a1011 1
	if (in_mca() && len == 1)
d1027 1
a1027 1
	return (cmd_ichar(cmd_mbc_buf, len));
d1034 1
a1034 2
cmd_int(frac)
	long *frac;
d1036 1
a1036 1
	char *p;
a1037 1
	int err;
d1039 2
a1040 8
	for (p = cmdbuf;  *p >= '0' && *p <= '9';  p++)
		n = (n * 10) + (*p - '0');
	*frac = 0;
	if (*p++ == '.')
	{
		*frac = getfraction(&p, NULL, &err);
		/* {{ do something if err is set? }} */
	}
a1050 193
}

#if CMD_HISTORY
/*
 * Return the last (most recent) string in the current command history.
 */
	public char *
cmd_lastpattern()
{
	if (curr_mlist == NULL)
		return (NULL);
	return (curr_mlist->curr_mp->prev->string);
}
#endif

#if CMD_HISTORY
/*
 * Get the name of the history file.
 */
	static char *
histfile_name()
{
	char *home;
	char *name;
	int len;
	
	/* See if filename is explicitly specified by $LESSHISTFILE. */
	name = lgetenv("LESSHISTFILE");
	if (name != NULL && *name != '\0')
	{
		if (strcmp(name, "-") == 0 || strcmp(name, "/dev/null") == 0)
			/* $LESSHISTFILE == "-" means don't use a history file. */
			return (NULL);
		return (save(name));
	}

	/* Otherwise, file is in $HOME. */
	home = lgetenv("HOME");
	if (home == NULL || *home == '\0')
	{
#if OS2
		home = lgetenv("INIT");
		if (home == NULL || *home == '\0')
#endif
			return (NULL);
	}
	len = strlen(home) + strlen(LESSHISTFILE) + 2;
	name = (char *) ecalloc(len, sizeof(char));
	SNPRINTF2(name, len, "%s/%s", home, LESSHISTFILE);
	return (name);
}
#endif /* CMD_HISTORY */

/*
 * Initialize history from a .lesshist file.
 */
	public void
init_cmdhist()
{
#if CMD_HISTORY
	struct mlist *ml = NULL;
	char line[CMDBUF_SIZE];
	char *filename;
	FILE *f;
	char *p;

	filename = histfile_name();
	if (filename == NULL)
		return;
	f = fopen(filename, "r");
	free(filename);
	if (f == NULL)
		return;
	if (fgets(line, sizeof(line), f) == NULL ||
	    strncmp(line, HISTFILE_FIRST_LINE, strlen(HISTFILE_FIRST_LINE)) != 0)
	{
		fclose(f);
		return;
	}
	while (fgets(line, sizeof(line), f) != NULL)
	{
		for (p = line;  *p != '\0';  p++)
		{
			if (*p == '\n' || *p == '\r')
			{
				*p = '\0';
				break;
			}
		}
		if (strcmp(line, HISTFILE_SEARCH_SECTION) == 0)
			ml = &mlist_search;
		else if (strcmp(line, HISTFILE_SHELL_SECTION) == 0)
		{
#if SHELL_ESCAPE || PIPEC
			ml = &mlist_shell;
#else
			ml = NULL;
#endif
		} else if (*line == '"')
		{
			if (ml != NULL)
				cmd_addhist(ml, line+1);
		}
	}
	fclose(f);
#endif /* CMD_HISTORY */
}

/*
 *
 */
#if CMD_HISTORY
	static void
save_mlist(ml, f)
	struct mlist *ml;
	FILE *f;
{
	int histsize = 0;
	int n;
	char *s;

	s = lgetenv("LESSHISTSIZE");
	if (s != NULL)
		histsize = atoi(s);
	if (histsize == 0)
		histsize = 100;

	ml = ml->prev;
	for (n = 0;  n < histsize;  n++)
	{
		if (ml->string == NULL)
			break;
		ml = ml->prev;
	}
	for (ml = ml->next;  ml->string != NULL;  ml = ml->next)
		fprintf(f, "\"%s\n", ml->string);
}
#endif /* CMD_HISTORY */

/*
 *
 */
	public void
save_cmdhist()
{
#if CMD_HISTORY
	char *filename;
	FILE *f;
	int modified = 0;

	filename = histfile_name();
	if (filename == NULL)
		return;
	if (mlist_search.modified)
		modified = 1;
#if SHELL_ESCAPE || PIPEC
	if (mlist_shell.modified)
		modified = 1;
#endif
	if (!modified)
		return;
	f = fopen(filename, "w");
	free(filename);
	if (f == NULL)
		return;
#if HAVE_FCHMOD
{
	/* Make history file readable only by owner. */
	int do_chmod = 1;
#if HAVE_STAT
	struct stat statbuf;
	int r = fstat(fileno(f), &statbuf);
	if (r < 0 || !S_ISREG(statbuf.st_mode))
		/* Don't chmod if not a regular file. */
		do_chmod = 0;
#endif
	if (do_chmod)
		fchmod(fileno(f), 0600);
}
#endif

	fprintf(f, "%s\n", HISTFILE_FIRST_LINE);

	fprintf(f, "%s\n", HISTFILE_SEARCH_SECTION);
	save_mlist(&mlist_search, f);

#if SHELL_ESCAPE || PIPEC
	fprintf(f, "%s\n", HISTFILE_SHELL_SECTION);
	save_mlist(&mlist_shell, f);
#endif

	fclose(f);
#endif /* CMD_HISTORY */
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
a32 1
static int updown_match = -1;	/* Prefix length in up/down movement */
a124 1
	updown_match = -1;
a134 1
	updown_match = -1;
d157 1
a157 3
		}
#if !SMALL
		else if (!is_composing_char(ch) &&
a163 1
#endif /* !SMALL */
d210 1
a210 3
	}
#if !SMALL
	else
a248 1
#endif /* !SMALL */
a506 1
	updown_match = -1;
a549 1
	updown_match = -1;
a645 1
	updown_match = -1;
a677 2
 * Only consider entries whose first updown_match chars are equal to
 * cmdbuf's corresponding chars.
a683 1
	struct mlist *ml;
d693 2
a694 6

	if (updown_match < 0)
	{
		updown_match = cp - cmdbuf;
	}

d696 1
a696 1
	 * Find the next history entry which matches.
d698 4
a701 28
	for (ml = curr_mlist->curr_mp;;)
	{
		ml = (action == EC_UP) ? ml->prev : ml->next;
		if (ml == curr_mlist)
		{
			/*
			 * We reached the end (or beginning) of the list.
			 */
			break;
		}
		if (strncmp(cmdbuf, ml->string, updown_match) == 0)
		{
			/*
			 * This entry matches; stop here.
			 * Copy the entry into cmdbuf and echo it on the screen.
			 */
			curr_mlist->curr_mp = ml;
			s = ml->string;
			if (s == NULL)
				s = "";
			cmd_home();
			clear_eol();
			strlcpy(cmdbuf, s, sizeof(cmdbuf));
			for (cp = cmdbuf;  *cp != '\0';  )
				cmd_right();
			return (CC_OK);
		}
	}
d703 1
a703 1
	 * We didn't find a history entry that matches.
d705 6
a710 1
	bell();
a1058 3
#if MSDOS_COMPILER
		char *qword = NULL;
#else
a1059 1
#endif
d1205 1
a1205 3
	}
#if !SMALL
	else
a1248 1
#endif /* !SMALL */
d1346 1
a1346 3
	/* Otherwise, file is in $HOME if enabled. */
	if (strcmp (LESSHISTFILE, "-") == 0)
		return (NULL);
d1460 3
a1469 3
		return;
	filename = histfile_name();
	if (filename == NULL)
@


