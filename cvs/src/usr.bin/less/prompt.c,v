head	1.23;
access;
symbols
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.12.0.12
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.8
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.6
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.4
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.28
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.24
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.22
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.8
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	OpenBSD_1_2:1.2
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	W32EN7Zp77efb8wW;

1.22
date	2016.01.26.01.51.06;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	srJYJwfAmHQyrX7w;

1.21
date	2016.01.17.00.59.09;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	goeWNQtcopYj0Lyk;

1.20
date	2016.01.13.22.47.45;	author mmcc;	state Exp;
branches;
next	1.19;
commitid	Uz3YEYZCcKwdp847;

1.19
date	2016.01.12.23.01.23;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	5Pl94glX7ncfN0bb;

1.18
date	2016.01.12.17.48.04;	author mmcc;	state Exp;
branches;
next	1.17;
commitid	O36S2Tb0ReI34f9s;

1.17
date	2015.11.09.16.46.43;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	rJ6tmXbM6ZZSV1zd;

1.16
date	2015.11.07.18.07.44;	author tedu;	state Exp;
branches;
next	1.15;
commitid	DJUwzdj0cG1bCfEw;

1.15
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.14;
commitid	QKrr6AuGzNx9nehL;

1.14
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.13;
commitid	yKv9Ck9ZDgwWTRTo;

1.13
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.12;

1.12
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.09.20.40.08;	author ray;	state Exp;
branches;
next	1.10;

1.10
date	2010.02.28.19.30.32;	author jasper;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.04.04.45.01;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.14.14.33.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.06.23.38.07;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.03;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	99.02.20.19.00.39;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.09.21.06.06.42;	author etheisen;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.07;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.50;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.23
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Prompting and other messages.
 * There are three flavors of prompts, SHORT, MEDIUM and LONG,
 * selected by the -m/-M options.
 * There is also the "equals message", printed by the = command.
 * A prompt is a message composed of various pieces, such as the
 * name of the file being viewed, the percentage into the file, etc.
 */

#include "less.h"
#include "position.h"

extern int pr_type;
extern int new_file;
extern int sc_width;
extern int so_s_width, so_e_width;
extern int linenums;
extern int hshift;
extern int sc_height;
extern int jump_sline;
extern int less_is_more;
extern IFILE curr_ifile;
extern char *editor;
extern char *editproto;

/*
 * Prototypes for the three flavors of prompts.
 * These strings are expanded by pr_expand().
 */
static const char s_proto[] =
	"?n?f%f .?m(%T %i of %m) ..?e(END) ?x- Next\\: %x..%t";
static const char m_proto[] =
	"?n?f%f .?m(%T %i of %m) ..?e(END) "
	"?x- Next\\: %x.:?pB%pB\\%:byte %bB?s/%s...%t";
static const char M_proto[] =
	"?f%f .?n?m(%T %i of %m) ..?"
	"ltlines %lt-%lb?L/%L. :byte %bB?s/%s. .?e(END)"
	" ?x- Next\\: %x.:?pB%pB\\%..%t";
static const char e_proto[] =
	"?f%f .?m(%T %i of %m) .?ltlines "
	"%lt-%lb?L/%L. .byte %bB?s/%s. ?e(END) :?pB%pB\\%..%t";
static const char h_proto[] =
	"HELP -- ?eEND -- Press g to see it again:"
	"Press RETURN for more., or q when done";
static const char w_proto[] =
	"Waiting for data";
static const char more_proto[] =
	"%f (?eEND ?x- Next\\: %x.:?pB%pB\\%:byte %bB?s/%s...%t)";
static const char more_M_proto[] =
	"%f (?eEND ?x- Next\\: %x.:?pB%pB\\%:byte %bB?s/%s...%t)"
	"[Press space to continue, q to quit, h for help]";

char *prproto[3];
char const *eqproto = e_proto;
char const *hproto = h_proto;
char const *wproto = w_proto;

static char message[PROMPT_SIZE];
static char *mp;

/*
 * Initialize the prompt prototype strings.
 */
void
init_prompt(void)
{
	prproto[0] = estrdup(s_proto);
	prproto[1] = estrdup(less_is_more ? more_proto : m_proto);
	prproto[2] = estrdup(less_is_more ? more_M_proto : M_proto);
	eqproto = estrdup(e_proto);
	hproto = estrdup(h_proto);
	wproto = estrdup(w_proto);
}

/*
 * Append a string to the end of the message.
 */
static void
ap_str(char *s)
{
	int len;

	len = strlen(s);
	if (mp + len >= message + PROMPT_SIZE)
		len = message + PROMPT_SIZE - mp - 1;
	(void) strncpy(mp, s, len);
	mp += len;
	*mp = '\0';
}

/*
 * Append a character to the end of the message.
 */
static void
ap_char(char c)
{
	char buf[2];

	buf[0] = c;
	buf[1] = '\0';
	ap_str(buf);
}

/*
 * Append a off_t (as a decimal integer) to the end of the message.
 */
static void
ap_pos(off_t pos)
{
	char buf[23];

	postoa(pos, buf, sizeof(buf));
	ap_str(buf);
}

/*
 * Append an integer to the end of the message.
 */
static void
ap_int(int num)
{
	char buf[13];

	inttoa(num, buf, sizeof buf);
	ap_str(buf);
}

/*
 * Append a question mark to the end of the message.
 */
static void
ap_quest(void)
{
	ap_str("?");
}

/*
 * Return the "current" byte offset in the file.
 */
static off_t
curr_byte(int where)
{
	off_t pos;

	pos = position(where);
	while (pos == -1 && where >= 0 && where < sc_height-1)
		pos = position(++where);
	if (pos == -1)
		pos = ch_length();
	return (pos);
}

/*
 * Return the value of a prototype conditional.
 * A prototype string may include conditionals which consist of a
 * question mark followed by a single letter.
 * Here we decode that letter and return the appropriate boolean value.
 */
static int
cond(char c, int where)
{
	off_t len;

	switch (c) {
	case 'a':	/* Anything in the message yet? */
		return (*message != '\0');
	case 'b':	/* Current byte offset known? */
		return (curr_byte(where) != -1);
	case 'c':
		return (hshift != 0);
	case 'e':	/* At end of file? */
		return (eof_displayed());
	case 'f':	/* Filename known? */
		return (strcmp(get_filename(curr_ifile), "-") != 0);
	case 'l':	/* Line number known? */
	case 'd':	/* Same as l */
		return (linenums);
	case 'L':	/* Final line number known? */
	case 'D':	/* Final page number known? */
		return (linenums && ch_length() != -1);
	case 'm':	/* More than one file? */
		return (ntags() ? (ntags() > 1) : (nifile() > 1));
	case 'n':	/* First prompt in a new file? */
		return (ntags() ? 1 : new_file);
	case 'p':	/* Percent into file (bytes) known? */
		return (curr_byte(where) != -1 && ch_length() > 0);
	case 'P':	/* Percent into file (lines) known? */
		return (currline(where) != 0 &&
		    (len = ch_length()) > 0 && find_linenum(len) != 0);
	case 's':	/* Size of file known? */
	case 'B':
		return (ch_length() != -1);
	case 'x':	/* Is there a "next" file? */
		if (ntags())
			return (0);
		return (next_ifile(curr_ifile) != NULL);
	}
	return (0);
}

/*
 * Decode a "percent" prototype character.
 * A prototype string may include various "percent" escapes;
 * that is, a percent sign followed by a single letter.
 * Here we decode that letter and take the appropriate action,
 * usually by appending something to the message being built.
 */
static void
protochar(int c, int where)
{
	off_t pos;
	off_t len;
	int n;
	off_t linenum;
	off_t last_linenum;
	IFILE h;

#undef	PAGE_NUM
#define	PAGE_NUM(linenum)  ((((linenum) - 1) / (sc_height - 1)) + 1)

	switch (c) {
	case 'b':	/* Current byte offset */
		pos = curr_byte(where);
		if (pos != -1)
			ap_pos(pos);
		else
			ap_quest();
		break;
	case 'c':
		ap_int(hshift);
		break;
	case 'd':	/* Current page number */
		linenum = currline(where);
		if (linenum > 0 && sc_height > 1)
			ap_pos(PAGE_NUM(linenum));
		else
			ap_quest();
		break;
	case 'D':	/* Final page number */
		/* Find the page number of the last byte in the file (len-1). */
		len = ch_length();
		if (len == -1) {
			ap_quest();
		} else if (len == 0) {
			/* An empty file has no pages. */
			ap_pos(0);
		} else {
			linenum = find_linenum(len - 1);
			if (linenum <= 0)
				ap_quest();
			else
				ap_pos(PAGE_NUM(linenum));
		}
		break;
	case 'E':	/* Editor name */
		ap_str(editor);
		break;
	case 'f':	/* File name */
		ap_str(get_filename(curr_ifile));
		break;
	case 'F':	/* Last component of file name */
		ap_str(last_component(get_filename(curr_ifile)));
		break;
	case 'i':	/* Index into list of files */
		if (ntags())
			ap_int(curr_tag());
		else
			ap_int(get_index(curr_ifile));
		break;
	case 'l':	/* Current line number */
		linenum = currline(where);
		if (linenum != 0)
			ap_pos(linenum);
		else
			ap_quest();
		break;
	case 'L':	/* Final line number */
		len = ch_length();
		if (len == -1 || len == ch_zero() ||
		    (linenum = find_linenum(len)) <= 0)
			ap_quest();
		else
			ap_pos(linenum-1);
		break;
	case 'm':	/* Number of files */
		n = ntags();
		if (n)
			ap_int(n);
		else
			ap_int(nifile());
		break;
	case 'p':	/* Percent into file (bytes) */
		pos = curr_byte(where);
		len = ch_length();
		if (pos != -1 && len > 0)
			ap_int(percentage(pos, len));
		else
			ap_quest();
		break;
	case 'P':	/* Percent into file (lines) */
		linenum = currline(where);
		if (linenum == 0 ||
		    (len = ch_length()) == -1 || len == ch_zero() ||
		    (last_linenum = find_linenum(len)) <= 0)
			ap_quest();
		else
			ap_int(percentage(linenum, last_linenum));
		break;
	case 's':	/* Size of file */
	case 'B':
		len = ch_length();
		if (len != -1)
			ap_pos(len);
		else
			ap_quest();
		break;
	case 't':	/* Truncate trailing spaces in the message */
		while (mp > message && mp[-1] == ' ')
			mp--;
		*mp = '\0';
		break;
	case 'T':	/* Type of list */
		if (ntags())
			ap_str("tag");
		else
			ap_str("file");
		break;
	case 'x':	/* Name of next file */
		h = next_ifile(curr_ifile);
		if (h != NULL)
			ap_str(get_filename(h));
		else
			ap_quest();
		break;
	}
}

/*
 * Skip a false conditional.
 * When a false condition is found (either a false IF or the ELSE part
 * of a true IF), this routine scans the prototype string to decide
 * where to resume parsing the string.
 * We must keep track of nested IFs and skip them properly.
 */
static const char *
skipcond(const char *p)
{
	int iflevel;

	/*
	 * We came in here after processing a ? or :,
	 * so we start nested one level deep.
	 */
	iflevel = 1;

	for (;;) {
		switch (*++p) {
		case '?':
			/*
			 * Start of a nested IF.
			 */
			iflevel++;
			break;
		case ':':
			/*
			 * Else.
			 * If this matches the IF we came in here with,
			 * then we're done.
			 */
			if (iflevel == 1)
				return (p);
			break;
		case '.':
			/*
			 * Endif.
			 * If this matches the IF we came in here with,
			 * then we're done.
			 */
			if (--iflevel == 0)
				return (p);
			break;
		case '\\':
			/*
			 * Backslash escapes the next character.
			 */
			++p;
			break;
		case '\0':
			/*
			 * Whoops.  Hit end of string.
			 * This is a malformed conditional, but just treat it
			 * as if all active conditionals ends here.
			 */
			return (p-1);
		}
	}
}

/*
 * Decode a char that represents a position on the screen.
 */
static const char *
wherechar(const char *p, int *wp)
{
	switch (*p) {
	case 'b': case 'd': case 'l': case 'p': case 'P':
		switch (*++p) {
		case 't':   *wp = TOP;			break;
		case 'm':   *wp = MIDDLE;		break;
		case 'b':   *wp = BOTTOM;		break;
		case 'B':   *wp = BOTTOM_PLUS_ONE;	break;
		case 'j':   *wp = adjsline(jump_sline);	break;
		default:    *wp = TOP; p--;		break;
		}
	}
	return (p);
}

/*
 * Construct a message based on a prototype string.
 */
char *
pr_expand(const char *proto, int maxwidth)
{
	const char *p;
	int c;
	int where;

	mp = message;

	if (*proto == '\0')
		return ("");

	for (p = proto; *p != '\0'; p++) {
		switch (*p) {
		default:	/* Just put the character in the message */
			ap_char(*p);
			break;
		case '\\':	/* Backslash escapes the next character */
			p++;
			ap_char(*p);
			break;
		case '?':	/* Conditional (IF) */
			if ((c = *++p) == '\0') {
				--p;
			} else {
				where = 0;
				p = wherechar(p, &where);
				if (!cond(c, where))
					p = skipcond(p);
			}
			break;
		case ':':	/* ELSE */
			p = skipcond(p);
			break;
		case '.':	/* ENDIF */
			break;
		case '%':	/* Percent escape */
			if ((c = *++p) == '\0') {
				--p;
			} else {
				where = 0;
				p = wherechar(p, &where);
				protochar(c, where);
			}
			break;
		}
	}

	if (*message == '\0')
		return ("");
	if (maxwidth > 0 && mp >= message + maxwidth) {
		/*
		 * Message is too long.
		 * Return just the final portion of it.
		 */
		return (mp - maxwidth);
	}
	return (message);
}

/*
 * Return a message suitable for printing by the "=" command.
 */
char *
eq_message(void)
{
	return (pr_expand(eqproto, 0));
}

/*
 * Return a prompt.
 * This depends on the prompt type (SHORT, MEDIUM, LONG), etc.
 * If we can't come up with an appropriate prompt, return NULL
 * and the caller will prompt with a colon.
 */
char *
prompt_string(void)
{
	char *prompt;
	int type;

	type = pr_type;
	prompt = pr_expand((ch_getflags() & CH_HELPFILE) ?
	    hproto : prproto[type], sc_width-so_s_width-so_e_width-2);
	new_file = 0;
	return (prompt);
}

/*
 * Return a message suitable for printing while waiting in the F command.
 */
char *
wait_message(void)
{
	return (pr_expand(wproto, sc_width-so_s_width-so_e_width-2));
}
@


1.22
log
@Remove a fancy macro that calculates the necessary buffer size for
int-to-str conversions and just use constants instead. The only binary
change is caused by using an unnecessarily large buffer for an int. This
is a consequence of simplifying some code that will be gone soon.

ok nicm@@
@
text
@d424 1
a424 1
		default:    *wp = TOP;  p--;		break;
@


1.21
log
@start removing mp, the pointer to message's nul byte

ok deraadt@@
@
text
@d121 1
a121 1
	char buf[INT_STRLEN_BOUND(pos) + 2];
d133 1
a133 1
	char buf[INT_STRLEN_BOUND(num) + 2];
@


1.20
log
@unify two identical function pairs now that we've removed less's off_t
aliases

ok nicm@@
@
text
@d177 1
a177 1
		return (mp > message);
d481 1
a481 1
	if (mp == message)
@


1.19
log
@remove lint annotations

ok nicm@@
@
text
@d123 1
a123 13
	postoa(pos, buf, sizeof buf);
	ap_str(buf);
}

/*
 * Append a line number to the end of the message.
 */
static void
ap_linenum(off_t linenum)
{
	char buf[INT_STRLEN_BOUND(linenum) + 2];

	linenumtoa(linenum, buf, sizeof buf);
d246 1
a246 1
			ap_linenum(PAGE_NUM(linenum));
d257 1
a257 1
			ap_linenum(0);
d263 1
a263 1
				ap_linenum(PAGE_NUM(linenum));
d284 1
a284 1
			ap_linenum(linenum);
d294 1
a294 1
			ap_linenum(linenum-1);
@


1.18
log
@Remove LINUNUM, a needless alias for off_t. Also, remove a redundant
condition.

ok nicm@@
@
text
@a419 1
	/*NOTREACHED*/
@


1.17
log
@NULL_IFILE has no weird use patterns.  NULL is sufficient.
@
text
@d131 1
a131 1
ap_linenum(LINENUM linenum)
d237 2
a238 2
	LINENUM linenum;
	LINENUM last_linenum;
@


1.16
log
@replace save() with estrdup() and make estrdup() exit like all the other
ecalloc, etc. functions do.
ok mmcc nicm
@
text
@d219 1
a219 1
		return (next_ifile(curr_ifile) != NULL_IFILE);
d353 1
a353 1
		if (h != NULL_IFILE)
@


1.15
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d78 6
a83 6
	prproto[0] = save(s_proto);
	prproto[1] = save(less_is_more ? more_proto : m_proto);
	prproto[2] = save(less_is_more ? more_M_proto : M_proto);
	eqproto = save(e_proto);
	hproto = save(h_proto);
	wproto = save(w_proto);
@


1.14
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.13
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

d19 1
a19 1
 * A prompt is a message composed of various pieces, such as the 
a35 1
#if EDITOR
a37 1
#endif
d43 27
a69 17
static constant char s_proto[] =
  "?n?f%f .?m(%T %i of %m) ..?e(END) ?x- Next\\: %x..%t";
static constant char m_proto[] =
  "?f%f .?m(%T %i of %m) .?e(END) ?x- Next\\: %x.:?pB%pB\\%:byte %bB?s/%s...%t";
static constant char M_proto[] =
  "?f%f .?n?m(%T %i of %m) ..?ltlines %lt-%lb?L/%L. :byte %bB?s/%s. .?e(END) ?x- Next\\: %x.:?pB%pB\\%..%t";
static constant char e_proto[] =
  "?f%f .?m(%T %i of %m) .?ltlines %lt-%lb?L/%L. .byte %bB?s/%s. ?e(END) :?pB%pB\\%..%t";
static constant char h_proto[] =
  "HELP -- ?eEND -- Press g to see it again:Press RETURN for more., or q when done";
static constant char w_proto[] =
  "Waiting for data";

public char *prproto[3];
public char constant *eqproto = e_proto;
public char constant *hproto = h_proto;
public char constant *wproto = w_proto;
d77 2
a78 2
	public void
init_prompt()
d81 2
a82 2
	prproto[1] = save(m_proto);
	prproto[2] = save(M_proto);
d91 2
a92 3
	static void
ap_str(s)
	char *s;
d99 1
a99 1
	strncpy(mp, s, len);
d107 2
a108 3
	static void
ap_char(c)
	char c;
d118 1
a118 1
 * Append a POSITION (as a decimal integer) to the end of the message.
d120 2
a121 3
	static void
ap_pos(pos)
	POSITION pos;
d125 1
a125 1
	postoa(pos, buf, sizeof(buf));
d132 2
a133 3
 	static void
ap_linenum(linenum)
	LINENUM linenum;
d137 1
a137 1
	linenumtoa(linenum, buf, sizeof(buf));
d144 2
a145 3
	static void
ap_int(num)
	int num;
d149 1
a149 1
	inttoa(num, buf, sizeof(buf));
d156 2
a157 2
	static void
ap_quest()
d165 2
a166 3
	static POSITION
curr_byte(where)
	int where;
d168 1
a168 1
	POSITION pos;
d171 1
a171 1
	while (pos == NULL_POSITION && where >= 0 && where < sc_height-1)
d173 1
a173 1
	if (pos == NULL_POSITION)
d180 1
a180 1
 * A prototype string may include conditionals which consist of a 
d184 2
a185 4
	static int
cond(c, where)
	char c;
	int where;
d187 1
a187 1
	POSITION len;
d189 1
a189 2
	switch (c)
	{
d193 1
a193 1
		return (curr_byte(where) != NULL_POSITION);
d205 1
a205 1
		return (linenums && ch_length() != NULL_POSITION);
a206 1
#if TAGS
a207 3
#else
		return (nifile() > 1);
#endif
a208 1
#if TAGS
a209 3
#else
		return (new_file);
#endif
d211 1
a211 2
		return (curr_byte(where) != NULL_POSITION && 
				ch_length() > 0);
d214 1
a214 2
				(len = ch_length()) > 0 &&
				find_linenum(len) != 0);
d217 1
a217 1
		return (ch_length() != NULL_POSITION);
a218 1
#if TAGS
a220 1
#endif
d233 2
a234 5
	static void
protochar(c, where, iseditproto)
	int c;
	int where;
	int iseditproto;
d236 2
a237 2
	POSITION pos;
	POSITION len;
d243 2
a244 2
#undef  PAGE_NUM
#define PAGE_NUM(linenum)  ((((linenum) - 1) / (sc_height - 1)) + 1)
d246 1
a246 2
	switch (c)
	{
d249 1
a249 1
		if (pos != NULL_POSITION)
d267 1
a267 1
		if (len == NULL_POSITION)
d269 1
a269 1
		else if (len == 0)
d272 1
a272 2
		else
		{
d276 1
a276 1
			else 
a279 1
#if EDITOR
a282 1
#endif
a289 1
#if TAGS
a292 1
#endif
d304 1
a304 1
		if (len == NULL_POSITION || len == ch_zero() ||
a310 1
#if TAGS
a314 1
#endif
d320 2
a321 2
		if (pos != NULL_POSITION && len > 0)
			ap_int(percentage(pos,len));
d328 1
a328 1
		    (len = ch_length()) == NULL_POSITION || len == ch_zero() ||
d337 1
a337 1
		if (len != NULL_POSITION)
a347 1
#if TAGS
a350 1
#endif
d365 1
a365 1
 * When a false condition is found (either a false IF or the ELSE part 
d370 2
a371 3
	static constant char *
skipcond(p)
	register constant char *p;
d373 1
a373 1
	register int iflevel;
d381 40
a420 39
	for (;;) switch (*++p)
	{
	case '?':
		/*
		 * Start of a nested IF.
		 */
		iflevel++;
		break;
	case ':':
		/*
		 * Else.
		 * If this matches the IF we came in here with,
		 * then we're done.
		 */
		if (iflevel == 1)
			return (p);
		break;
	case '.':
		/*
		 * Endif.
		 * If this matches the IF we came in here with,
		 * then we're done.
		 */
		if (--iflevel == 0)
			return (p);
		break;
	case '\\':
		/*
		 * Backslash escapes the next character.
		 */
		++p;
		break;
	case '\0':
		/*
		 * Whoops.  Hit end of string.
		 * This is a malformed conditional, but just treat it
		 * as if all active conditionals ends here.
		 */
		return (p-1);
d428 2
a429 4
	static constant char *
wherechar(p, wp)
	char constant *p;
	int *wp;
d431 1
a431 2
	switch (*p)
	{
d433 1
a433 2
		switch (*++p)
		{
d448 2
a449 4
	public char *
pr_expand(proto, maxwidth)
	constant char *proto;
	int maxwidth;
d451 2
a452 2
	register constant char *p;
	register int c;
d460 2
a461 4
	for (p = proto;  *p != '\0';  p++)
	{
		switch (*p)
		{
d470 1
a470 1
			if ((c = *++p) == '\0')
d472 1
a472 2
			else
			{
d485 1
a485 1
			if ((c = *++p) == '\0')
d487 1
a487 2
			else
			{
d490 1
a490 7
				protochar(c, where,
#if EDITOR
					(proto == editproto));
#else
					0);
#endif

d498 1
a498 2
	if (maxwidth > 0 && mp >= message + maxwidth)
	{
d511 2
a512 2
	public char *
eq_message()
d523 2
a524 2
	public char *
pr_string()
d529 1
a529 1
	type = (!less_is_more) ? pr_type : pr_type ? 0 : 1;
d531 1
a531 2
				hproto : prproto[type],
			sc_width-so_s_width-so_e_width-2);
d539 2
a540 2
	public char *
wait_message()
@


1.12
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d393 1
a393 1
	static char *
d395 1
a395 1
	register char *p;
d451 1
a451 1
	static char *
d453 1
a453 1
	char *p;
d477 1
a477 1
	char *proto;
d480 1
a480 1
	register char *p;
@


1.11
log
@Remove extra `.' from -m prompt string. From Daniel Malament danielm
at bluetiger dot net, PR 6234.

OK millert
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
a24 1
extern int hit_eof;
d32 1
d167 1
a167 1
	while (pos == NULL_POSITION && where >= 0 && where < sc_height)
d196 1
a196 1
		return (hit_eof);
d203 1
a203 1
	case 'D':	/* Same as L */
d257 3
d275 1
a275 1
			ap_linenum(((linenum - 1) / (sc_height - 1)) + 1);
d279 2
a280 1
	case 'D':	/* Last page number */
d282 1
a282 2
		if (len == NULL_POSITION || len == ch_zero() ||
		    (linenum = find_linenum(len)) <= 0)
d284 3
d288 7
a294 1
			ap_linenum(((linenum - 1) / (sc_height - 1)) + 1);
d304 3
d537 1
a537 1
		return (NULL);
d568 1
d570 4
a573 1
	prompt = pr_expand(prproto[pr_type], sc_width-so_s_width-so_e_width-2);
@


1.10
log
@%t didn't properly remove trailing spaces from the end of the prompt.

patch from daniel malament in pr 6235

ok millert@@
@
text
@d46 1
a46 1
  "?f%f .?m(%T %i of %m) ..?e(END) ?x- Next\\: %x.:?pB%pB\\%:byte %bB?s/%s...%t";
@


1.9
log
@It turns out that POSIX specifies more should prompt with the file name,
not --More-- like the old UCB more did.  Back out a hack I did to
make the prompt look like the old UCB more.
@
text
@d352 1
@


1.8
log
@o go back to using a help file instead of embedding it in the binary
o deal with HELPFILE not being defined
o add a SMALL definition to make a smaller less for the boot floppies
This still needs to be pared down a bit for the SMALL case
@
text
@a30 1
extern int ismore;
a48 2
static constant char more_proto[] =
  "--More--.?e(END) ?x- Next\\: %x.:(?pB%pB\\%:byte %bB?s/%s..).%t";
d70 1
a70 1
	prproto[0] = save(ismore ? more_proto : s_proto);
@


1.7
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d556 1
a556 3
	prompt = pr_expand((ch_getflags() & CH_HELPFILE) ?
				hproto : prproto[pr_type],
			sc_width-so_s_width-so_e_width-2);
@


1.6
log
@more strlcpy/strlcat/snprintf, less strcpy/strcat/sprintf
reviewed by tdeval, millert, dhartmei and others.  more bits coming here
from some of them i think
@
text
@a0 2
/*	$OpenBSD: prompt.c,v 1.5 2001/11/19 19:02:14 mpech Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d30 2
d37 1
d44 14
a57 8
static char s_proto[] =
  "?n?f%f .?m(file %i of %m) ..?e(END) ?x- Next\\: %x..%t";
static char m_proto[] =
  "?f%f .?m(file %i of %m) .?e(END) ?x- Next\\: %x.:(?pB%pB\\%:byte %bB?s/%s..).%t";
static char M_proto[] =
  "?f%f .?n?m(file %i of %m) ..?ltline %lt?L/%L. :byte %bB?s/%s. .?e(END) ?x- Next\\: %x.:?pB%pB\\%..%t";
static char e_proto[] =
  "?f%f .?m(file %i of %m) .?ltline %lt?L/%L. .byte %bB?s/%s. ?e(END) :?pB%pB\\%..%t";
d60 3
a62 1
public char *eqproto = e_proto;
d64 1
a64 1
static char message[250];
d73 1
a73 1
	prproto[0] = save(s_proto);
d77 2
d82 1
a82 1
 * Set the message pointer to the end of the message string.
d85 2
a86 1
setmp()
d88 22
a109 2
	while (*mp != '\0')
		mp++;
d119 4
a122 2
	snprintf(mp, message + sizeof message - mp, "%qd", pos);
	setmp();
d126 1
a126 1
 * Append an integer to the end of the message.
d128 3
a130 3
	static void
ap_int(n)
	int n;
d132 4
a135 2
	snprintf(mp, message + sizeof message - mp, "%d", n);
	setmp();
d139 1
a139 1
 * Append a string to the end of the message.
d142 2
a143 2
ap_str(s)
	char *s;
d145 4
a148 2
	strtcpy(mp, s, (unsigned int)(&message[sizeof(message)] - mp));
	setmp();
d157 1
a157 2
	if (mp < message + sizeof message - 1)
		*mp++ = '?';
d188 2
d196 2
d203 1
d206 1
d209 3
d213 1
d215 3
d219 2
a220 1
	case 'p':	/* Percent into file known? */
d223 4
d231 4
d248 1
a248 1
protochar(c, where)
d251 1
d256 2
d269 18
d296 6
a301 1
		ap_int(get_index(curr_ifile));
d304 3
a306 3
		n = currline(where);
		if (n != 0)
			ap_int(n);
d313 1
a313 1
		    (n = find_linenum(len)) <= 0)
d316 1
a316 1
			ap_int(n-1);
d319 7
a325 1
		ap_int(nifile());
d327 1
a327 1
	case 'p':	/* Percent into file */
d335 9
d356 8
d383 1
a383 1
	char *p;
d385 1
a385 1
	int iflevel;
d436 3
d446 1
a446 1
	case 'b': case 'l': case 'p':
d468 2
a469 2
	char *p;
	int c;
d482 1
a482 1
			*mp++ = *p;
d486 1
a486 1
			*mp++ = *p;
d493 1
d509 1
d511 7
a517 1
				protochar(c, where);
a522 1
	new_file = 0;
a524 1
	*mp = '\0';
d554 16
a569 1
	return (pr_expand(prproto[pr_type], sc_width-so_s_width-so_e_width-2));
@


1.5
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: prompt.c,v 1.4 2001/01/29 01:58:03 niklas Exp $	*/
d103 1
a103 1
	sprintf(mp, "%qd", pos);
d114 1
a114 1
	sprintf(mp, "%d", n);
d135 2
a136 1
	*mp++ = '?';
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d290 1
a290 1
	register char *p;
d292 1
a292 1
	register int iflevel;
d372 2
a373 2
	register char *p;
	register int c;
@


1.3
log
@First step at supporting files > 2gig.  Use off_t as POSITION
and replace get_maxlong() with a get_maxpos() and modify percentage()
appropriately.  There are still problems seeking to the end of a large
file and line numbers should probably be 64bit (or at the very least
unsigned).  This has been sitting in my tree for quite some time now
so I am committing what I have now since I don't know when I'll have
a chance to really finish it.
@
text
@d1 2
@


1.2
log
@Incorporate less modifications for more and our bug fixes from previous
version.
@
text
@d101 1
a101 1
	sprintf(mp, "%ld", (long)pos);
@


1.1
log
@Initial revision
@
text
@d60 1
a60 1
  "?n?f%f .?m(file %i of %m) ..?e(END) ?x- Next\\: %x.:?pB%pB\\%:byte %bB?s/%s...%t";
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
a45 1
extern int hshift;
a50 1
extern char *editproto;
d57 8
a64 12
static constant char s_proto[] =
  "?n?f%f .?m(%T %i of %m) ..?e(END) ?x- Next\\: %x..%t";
static constant char m_proto[] =
  "?n?f%f .?m(%T %i of %m) ..?e(END) ?x- Next\\: %x.:?pB%pB\\%:byte %bB?s/%s...%t";
static constant char M_proto[] =
  "?f%f .?n?m(%T %i of %m) ..?ltlines %lt-%lb?L/%L. :byte %bB?s/%s. .?e(END) ?x- Next\\: %x.:?pB%pB\\%..%t";
static constant char e_proto[] =
  "?f%f .?m(%T %i of %m) .?ltlines %lt-%lb?L/%L. .byte %bB?s/%s. ?e(END) :?pB%pB\\%..%t";
static constant char h_proto[] =
  "HELP -- ?eEND -- Press g to see it again:Press RETURN for more., or q when done";
static constant char w_proto[] =
  "Waiting for data";
d67 1
a67 3
public char constant *eqproto = e_proto;
public char constant *hproto = h_proto;
public char constant *wproto = w_proto;
d69 1
a69 1
static char message[PROMPT_SIZE];
a81 2
	hproto = save(h_proto);
	wproto = save(w_proto);
d85 1
a85 18
 * Append a string to the end of the message.
 */
	static void
ap_str(s)
	char *s;
{
	int len;

	len = strlen(s);
	if (mp + len >= message + PROMPT_SIZE)
		len = message + PROMPT_SIZE - mp - 1;
	strncpy(mp, s, len);
	mp += len;
	*mp = '\0';
}

/*
 * Append a character to the end of the message.
d88 1
a88 2
ap_char(c)
	char c;
d90 2
a91 5
	char buf[2];

	buf[0] = c;
	buf[1] = '\0';
	ap_str(buf);
d101 2
a102 4
	char buf[INT_STRLEN_BOUND(pos) + 2];

	postoa(pos, buf);
	ap_str(buf);
d106 1
a106 1
 * Append a line number to the end of the message.
d108 3
a110 3
 	static void
ap_linenum(linenum)
	LINENUM linenum;
d112 2
a113 4
	char buf[INT_STRLEN_BOUND(linenum) + 2];

	linenumtoa(linenum, buf);
	ap_str(buf);
d117 1
a117 1
 * Append an integer to the end of the message.
d120 2
a121 2
ap_int(num)
	int num;
d123 2
a124 4
	char buf[INT_STRLEN_BOUND(num) + 2];

	inttoa(num, buf);
	ap_str(buf);
d133 1
a133 1
	ap_str("?");
a163 2
	POSITION len;

a169 2
	case 'c':
		return (hshift != 0);
a174 1
	case 'd':	/* Same as l */
a176 1
	case 'D':	/* Same as L */
a178 3
#if TAGS
		return (ntags() ? (ntags() > 1) : (nifile() > 1));
#else
a179 1
#endif
a180 3
#if TAGS
		return (ntags() ? 1 : new_file);
#else
d182 1
a182 2
#endif
	case 'p':	/* Percent into file (bytes) known? */
a184 4
	case 'P':	/* Percent into file (lines) known? */
		return (currline(where) != 0 &&
				(len = ch_length()) > 0 &&
				find_linenum(len) != 0);
a188 4
#if TAGS
		if (ntags())
			return (0);
#endif
d202 1
a202 1
protochar(c, where, iseditproto)
a204 1
	int iseditproto;
a208 2
	LINENUM linenum;
	LINENUM last_linenum;
a219 18
	case 'c':
		ap_int(hshift);
		break;
	case 'd':	/* Current page number */
		linenum = currline(where);
		if (linenum > 0 && sc_height > 1)
			ap_linenum(((linenum - 1) / (sc_height - 1)) + 1);
		else
			ap_quest();
		break;
	case 'D':	/* Last page number */
		len = ch_length();
		if (len == NULL_POSITION || len == ch_zero() ||
		    (linenum = find_linenum(len)) <= 0)
			ap_quest();
		else
			ap_linenum(((linenum - 1) / (sc_height - 1)) + 1);
		break;
d229 1
a229 6
#if TAGS
		if (ntags())
			ap_int(curr_tag());
		else
#endif
			ap_int(get_index(curr_ifile));
d232 3
a234 3
		linenum = currline(where);
		if (linenum != 0)
			ap_linenum(linenum);
d241 1
a241 1
		    (linenum = find_linenum(len)) <= 0)
d244 1
a244 1
			ap_linenum(linenum-1);
d247 1
a247 7
#if TAGS
		n = ntags();
		if (n)
			ap_int(n);
		else
#endif
			ap_int(nifile());
d249 1
a249 1
	case 'p':	/* Percent into file (bytes) */
a256 9
	case 'P':	/* Percent into file (lines) */
		linenum = currline(where);
		if (linenum == 0 ||
		    (len = ch_length()) == NULL_POSITION || len == ch_zero() ||
		    (last_linenum = find_linenum(len)) <= 0)
			ap_quest();
		else
			ap_int(percentage(linenum, last_linenum));
		break;
a268 8
	case 'T':	/* Type of list */
#if TAGS
		if (ntags())
			ap_str("tag");
		else
#endif
			ap_str("file");
		break;
a340 3
/*
 * Decode a char that represents a position on the screen.
 */
d348 1
a348 1
	case 'b': case 'd': case 'l': case 'p': case 'P':
d384 1
a384 1
			ap_char(*p);
d388 1
a388 1
			ap_char(*p);
a394 1
				where = 0;
a409 1
				where = 0;
d411 1
a411 7
				protochar(c, where,
#if EDITOR
					(proto == editproto));
#else
					0);
#endif

d417 1
d420 1
d450 1
a450 16
	char *prompt;

	prompt = pr_expand((ch_getflags() & CH_HELPFILE) ?
				hproto : prproto[pr_type],
			sc_width-so_s_width-so_e_width-2);
	new_file = 0;
	return (prompt);
}

/*
 * Return a message suitable for printing while waiting in the F command.
 */
	public char *
wait_message()
{
	return (pr_expand(wproto, sc_width-so_s_width-so_e_width-2));
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d25 1
a32 1
extern int less_is_more;
a54 2
static constant char more_proto[] =
  "--More--(?eEND ?x- Next\\: %x.:?pB%pB\\%:byte %bB?s/%s...%t)";
d71 1
a71 1
	prproto[1] = save(less_is_more ? more_proto : m_proto);
d167 1
a167 1
	while (pos == NULL_POSITION && where >= 0 && where < sc_height-1)
d196 1
a196 1
		return (eof_displayed());
d203 1
a203 1
	case 'D':	/* Final page number known? */
a256 3
#undef  PAGE_NUM
#define PAGE_NUM(linenum)  ((((linenum) - 1) / (sc_height - 1)) + 1)

d272 1
a272 1
			ap_linenum(PAGE_NUM(linenum));
d276 1
a276 2
	case 'D':	/* Final page number */
		/* Find the page number of the last byte in the file (len-1). */
d278 2
a279 1
		if (len == NULL_POSITION)
a280 3
		else if (len == 0)
			/* An empty file has no pages. */
			ap_linenum(0);
d282 1
a282 7
		{
			linenum = find_linenum(len - 1);
			if (linenum <= 0)
				ap_quest();
			else 
				ap_linenum(PAGE_NUM(linenum));
		}
a291 3
	case 'F':	/* Last component of file name */
		ap_str(last_component(get_filename(curr_ifile)));
		break;
a351 1
		*mp = '\0';
d521 1
a521 1
		return ("");
a551 1
	int type;
a552 1
	type = (!less_is_more) ? pr_type : pr_type ? 0 : 1;
d554 1
a554 1
				hproto : prproto[type],
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d46 1
a46 1
  "?f%f .?m(%T %i of %m) .?e(END) ?x- Next\\: %x.:?pB%pB\\%:byte %bB?s/%s...%t";
d55 2
d73 1
a73 1
	prproto[1] = save(m_proto);
d120 1
a120 1
	postoa(pos, buf, sizeof(buf));
d133 1
a133 1
	linenumtoa(linenum, buf, sizeof(buf));
d146 1
a146 1
	inttoa(num, buf, sizeof(buf));
d396 1
a396 1
	static constant char *
d398 1
a398 1
	register constant char *p;
d454 1
a454 1
	static constant char *
d456 1
a456 1
	char constant *p;
d480 1
a480 1
	constant char *proto;
d483 1
a483 1
	register constant char *p;
@


