head	1.16;
access;
symbols
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.6.0.12
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.8
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.4.0.34
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.32
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.30
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.26
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.28
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.24
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.12.30.19.52.43;	author tedu;	state Exp;
branches;
next	1.15;
commitid	fZTva288eSsawxfF;

1.15
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	W32EN7Zp77efb8wW;

1.14
date	2016.01.12.17.48.04;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	O36S2Tb0ReI34f9s;

1.13
date	2015.12.25.14.29.22;	author mmcc;	state Exp;
branches;
next	1.12;
commitid	NRTgXV6ghJCKRBdW;

1.12
date	2015.11.09.16.39.13;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	ZtGimechwgSRYqRW;

1.11
date	2015.11.09.04.10.57;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	E4Lg0tTt0vh4nd97;

1.10
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.9;
commitid	QKrr6AuGzNx9nehL;

1.9
date	2015.11.06.15.09.07;	author tedu;	state Exp;
branches;
next	1.8;
commitid	z4qVin3ZEtVsatp2;

1.8
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.7;
commitid	yKv9Ck9ZDgwWTRTo;

1.7
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2011.09.21.19.01.49;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.01.58.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.42;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.06;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.49;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.16
log
@restore a not so redundant test. loopcount = -1 is a significant indicator
to prevent printing the calculating message over and over.
from Hugo Villeneuve
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * Code to handle displaying line numbers.
 *
 * Finding the line number of a given file position is rather tricky.
 * We don't want to just start at the beginning of the file and
 * count newlines, because that is slow for large files (and also
 * wouldn't work if we couldn't get to the start of the file; e.g.
 * if input is a long pipe).
 *
 * So we use the function add_lnum to cache line numbers.
 * We try to be very clever and keep only the more interesting
 * line numbers when we run out of space in our table.  A line
 * number is more interesting than another when it is far from
 * other line numbers.   For example, we'd rather keep lines
 * 100,200,300 than 100,101,300.  200 is more interesting than
 * 101 because 101 can be derived very cheaply from 100, while
 * 200 is more expensive to derive from 100.
 *
 * The function currline() returns the line number of a given
 * position in the file.  As a side effect, it calls add_lnum
 * to cache the line number.  Therefore currline is occasionally
 * called to make sure we cache line numbers often enough.
 */

#include "less.h"

/*
 * Structure to keep track of a line number and the associated file position.
 * A doubly-linked circular list of line numbers is kept ordered by line number.
 */
struct linenum_info {
	struct linenum_info *next;	/* Link to next in the list */
	struct linenum_info *prev;	/* Line to previous in the list */
	off_t pos;			/* File position */
	off_t gap;			/* Gap between prev and next */
	off_t line;			/* Line number */
};
/*
 * "gap" needs some explanation: the gap of any particular line number
 * is the distance between the previous one and the next one in the list.
 * ("Distance" means difference in file position.)  In other words, the
 * gap of a line number is the gap which would be introduced if this
 * line number were deleted.  It is used to decide which one to replace
 * when we have a new one to insert and the table is full.
 */

#define	NPOOL	200			/* Size of line number pool */

#define	LONGTIME	(2)		/* In seconds */

static struct linenum_info anchor;	/* Anchor of the list */
static struct linenum_info *freelist;	/* Anchor of the unused entries */
static struct linenum_info pool[NPOOL];	/* The pool itself */
static struct linenum_info *spare;	/* We always keep one spare entry */

extern int linenums;
extern volatile sig_atomic_t sigs;
extern int sc_height;
extern int screen_trashed;

/*
 * Initialize the line number structures.
 */
void
clr_linenum(void)
{
	struct linenum_info *p;

	/*
	 * Put all the entries on the free list.
	 * Leave one for the "spare".
	 */
	for (p = pool; p < &pool[NPOOL-2]; p++)
		p->next = p+1;
	pool[NPOOL-2].next = NULL;
	freelist = pool;

	spare = &pool[NPOOL-1];

	/*
	 * Initialize the anchor.
	 */
	anchor.next = anchor.prev = &anchor;
	anchor.gap = 0;
	anchor.pos = 0;
	anchor.line = 1;
}

/*
 * Calculate the gap for an entry.
 */
static void
calcgap(struct linenum_info *p)
{
	/*
	 * Don't bother to compute a gap for the anchor.
	 * Also don't compute a gap for the last one in the list.
	 * The gap for that last one should be considered infinite,
	 * but we never look at it anyway.
	 */
	if (p == &anchor || p->next == &anchor)
		return;
	p->gap = p->next->pos - p->prev->pos;
}

/*
 * Add a new line number to the cache.
 * The specified position (pos) should be the file position of the
 * FIRST character in the specified line.
 */
void
add_lnum(off_t linenum, off_t pos)
{
	struct linenum_info *p;
	struct linenum_info *new;
	struct linenum_info *nextp;
	struct linenum_info *prevp;
	off_t mingap;

	/*
	 * Find the proper place in the list for the new one.
	 * The entries are sorted by position.
	 */
	for (p = anchor.next; p != &anchor && p->pos < pos; p = p->next)
		if (p->line == linenum)
			/* We already have this one. */
			return;
	nextp = p;
	prevp = p->prev;

	if (freelist != NULL) {
		/*
		 * We still have free (unused) entries.
		 * Use one of them.
		 */
		new = freelist;
		freelist = freelist->next;
	} else {
		/*
		 * No free entries.
		 * Use the "spare" entry.
		 */
		new = spare;
		spare = NULL;
	}

	/*
	 * Fill in the fields of the new entry,
	 * and insert it into the proper place in the list.
	 */
	new->next = nextp;
	new->prev = prevp;
	new->pos = pos;
	new->line = linenum;

	nextp->prev = new;
	prevp->next = new;

	/*
	 * Recalculate gaps for the new entry and the neighboring entries.
	 */
	calcgap(new);
	calcgap(nextp);
	calcgap(prevp);

	if (spare == NULL) {
		/*
		 * We have used the spare entry.
		 * Scan the list to find the one with the smallest
		 * gap, take it out and make it the spare.
		 * We should never remove the last one, so stop when
		 * we get to p->next == &anchor.  This also avoids
		 * looking at the gap of the last one, which is
		 * not computed by calcgap.
		 */
		mingap = anchor.next->gap;
		for (p = anchor.next; p->next != &anchor; p = p->next) {
			if (p->gap <= mingap) {
				spare = p;
				mingap = p->gap;
			}
		}
		spare->next->prev = spare->prev;
		spare->prev->next = spare->next;
	}
}

static int loopcount;
static time_t startime;

static void
longish(void)
{
	if (loopcount >= 0 && ++loopcount > 100) {
		loopcount = 0;
		if (time(NULL) >= startime + LONGTIME) {
			ierror("Calculating line numbers", NULL);
			loopcount = -1;
		}
	}
}

/*
 * Turn off line numbers because the user has interrupted
 * a lengthy line number calculation.
 */
static void
abort_long(void)
{
	if (linenums == OPT_ONPLUS)
		/*
		 * We were displaying line numbers, so need to repaint.
		 */
		screen_trashed = 1;
	linenums = 0;
	error("Line numbers turned off", NULL);
}

/*
 * Find the line number associated with a given position.
 * Return 0 if we can't figure it out.
 */
off_t
find_linenum(off_t pos)
{
	struct linenum_info *p;
	off_t linenum;
	off_t cpos;

	if (!linenums)
		/*
		 * We're not using line numbers.
		 */
		return (0);
	if (pos == -1)
		/*
		 * Caller doesn't know what he's talking about.
		 */
		return (0);
	if (pos <= ch_zero())
		/*
		 * Beginning of file is always line number 1.
		 */
		return (1);

	/*
	 * Find the entry nearest to the position we want.
	 */
	for (p = anchor.next; p != &anchor && p->pos < pos; p = p->next)
		continue;
	if (p->pos == pos)
		/* Found it exactly. */
		return (p->line);

	/*
	 * This is the (possibly) time-consuming part.
	 * We start at the line we just found and start
	 * reading the file forward or backward till we
	 * get to the place we want.
	 *
	 * First decide whether we should go forward from the
	 * previous one or backwards from the next one.
	 * The decision is based on which way involves
	 * traversing fewer bytes in the file.
	 */
	startime = time(NULL);
	if (p == &anchor || pos - p->prev->pos < p->pos - pos) {
		/*
		 * Go forward.
		 */
		p = p->prev;
		if (ch_seek(p->pos))
			return (0);
		loopcount = 0;
		for (linenum = p->line, cpos = p->pos; cpos < pos; linenum++) {
			/*
			 * Allow a signal to abort this loop.
			 */
			cpos = forw_raw_line(cpos, NULL, NULL);
			if (ABORT_SIGS()) {
				abort_long();
				return (0);
			}
			if (cpos == -1)
				return (0);
			longish();
		}
		/*
		 * We might as well cache it.
		 */
		add_lnum(linenum, cpos);
		/*
		 * If the given position is not at the start of a line,
		 * make sure we return the correct line number.
		 */
		if (cpos > pos)
			linenum--;
	} else {
		/*
		 * Go backward.
		 */
		if (ch_seek(p->pos))
			return (0);
		loopcount = 0;
		for (linenum = p->line, cpos = p->pos; cpos > pos; linenum--) {
			/*
			 * Allow a signal to abort this loop.
			 */
			cpos = back_raw_line(cpos, NULL, NULL);
			if (ABORT_SIGS()) {
				abort_long();
				return (0);
			}
			if (cpos == -1)
				return (0);
			longish();
		}
		/*
		 * We might as well cache it.
		 */
		add_lnum(linenum, cpos);
	}

	return (linenum);
}

/*
 * Find the position of a given line number.
 * Return -1 if we can't figure it out.
 */
off_t
find_pos(off_t linenum)
{
	struct linenum_info *p;
	off_t cpos;
	off_t clinenum;

	if (linenum <= 1)
		/*
		 * Line number 1 is beginning of file.
		 */
		return (ch_zero());

	/*
	 * Find the entry nearest to the line number we want.
	 */
	for (p = anchor.next; p != &anchor && p->line < linenum; p = p->next)
		continue;
	if (p->line == linenum)
		/* Found it exactly. */
		return (p->pos);

	if (p == &anchor || linenum - p->prev->line < p->line - linenum) {
		/*
		 * Go forward.
		 */
		p = p->prev;
		if (ch_seek(p->pos))
			return (-1);
		for (clinenum = p->line, cpos = p->pos;
		    clinenum < linenum;
		    clinenum++) {
			/*
			 * Allow a signal to abort this loop.
			 */
			cpos = forw_raw_line(cpos, NULL, NULL);
			if (ABORT_SIGS())
				return (-1);
			if (cpos == -1)
				return (-1);
		}
	} else {
		/*
		 * Go backward.
		 */
		if (ch_seek(p->pos))
			return (-1);
		for (clinenum = p->line, cpos = p->pos;
		    clinenum > linenum;
		    clinenum--) {
			/*
			 * Allow a signal to abort this loop.
			 */
			cpos = back_raw_line(cpos, (char **)NULL, (int *)NULL);
			if (ABORT_SIGS())
				return (-1);
			if (cpos == -1)
				return (-1);
		}
	}
	/*
	 * We might as well cache it.
	 */
	add_lnum(clinenum, cpos);
	return (cpos);
}

/*
 * Return the line number of the "current" line.
 * The argument "where" tells which line is to be considered
 * the "current" line (e.g. TOP, BOTTOM, MIDDLE, etc).
 */
off_t
currline(int where)
{
	off_t pos;
	off_t len;
	off_t linenum;

	pos = position(where);
	len = ch_length();
	while (pos == -1 && where >= 0 && where < sc_height)
		pos = position(++where);
	if (pos == -1)
		pos = len;
	linenum = find_linenum(pos);
	if (pos == len)
		linenum--;
	return (linenum);
}
@


1.15
log
@little bit more KNF
@
text
@d205 1
a205 1
	if (++loopcount > 100) {
@


1.14
log
@Remove LINUNUM, a needless alias for off_t. Also, remove a redundant
condition.

ok nicm@@
@
text
@d84 1
a84 1
	for (p = pool;  p < &pool[NPOOL-2];  p++)
d135 1
a135 1
	for (p = anchor.next;  p != &anchor && p->pos < pos;  p = p->next)
d188 1
a188 1
		for (p = anchor.next;  p->next != &anchor;  p = p->next) {
d260 1
a260 1
	for (p = anchor.next;  p != &anchor && p->pos < pos;  p = p->next)
d358 1
a358 1
	for (p = anchor.next;  p != &anchor && p->line < linenum;  p = p->next)
@


1.13
log
@inline a once-used function that just prints a warning

ok benno@@
@
text
@d47 1
a47 1
	LINENUM line;			/* Line number */
d123 1
a123 1
add_lnum(LINENUM linenum, off_t pos)
d205 1
a205 1
	if (loopcount >= 0 && ++loopcount > 100) {
d234 1
a234 1
LINENUM
d238 1
a238 1
	LINENUM linenum;
d343 1
a343 1
find_pos(LINENUM linenum)
d347 1
a347 1
	LINENUM clinenum;
d414 1
a414 1
LINENUM
d419 1
a419 1
	LINENUM linenum;
@


1.12
log
@error() is not a stdarg function, so there is no reason for NULL_PARG
to be special.  Simply use NULL.
@
text
@a198 10
/*
 * If we get stuck in a long loop trying to figure out the
 * line number, print a message to tell the user what we're doing.
 */
static void
longloopmessage(void)
{
	ierror("Calculating line numbers", NULL);
}

d208 1
a208 1
			longloopmessage();
@


1.11
log
@cleanup struct definitions
@
text
@d206 1
a206 1
	ierror("Calculating line numbers", NULL_PARG);
d237 1
a237 1
	error("Line numbers turned off", NULL_PARG);
@


1.10
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d42 1
a42 2
struct linenum_info
{
@


1.9
log
@time_t is not a long. remove incorrect abstraction around time().
ok nicm
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.8
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d213 1
a213 1
static long startime;
d220 1
a220 1
		if (get_time() >= startime + LONGTIME) {
d290 1
a290 1
	startime = get_time();
@


1.7
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@d9 4
a12 1

d48 2
a49 2
	POSITION pos;			/* File position */
	POSITION gap;			/* Gap between prev and next */
d68 1
a68 1
static struct linenum_info *spare;		/* We always keep one spare entry */
d78 2
a79 2
	public void
clr_linenum()
d81 1
a81 1
	register struct linenum_info *p;
d99 1
a99 1
	anchor.pos = (POSITION)0;
d106 2
a107 3
	static void
calcgap(p)
	register struct linenum_info *p;
d125 2
a126 4
	public void
add_lnum(linenum, pos)
	LINENUM linenum;
	POSITION pos;
d128 5
a132 5
	register struct linenum_info *p;
	register struct linenum_info *new;
	register struct linenum_info *nextp;
	register struct linenum_info *prevp;
	register POSITION mingap;
d145 1
a145 2
	if (freelist != NULL)
	{
d152 1
a152 2
	} else
	{
d180 1
a180 2
	if (spare == NULL)
	{
d191 2
a192 4
		for (p = anchor.next;  p->next != &anchor;  p = p->next)
		{
			if (p->gap <= mingap)
			{
d206 2
a207 2
	static void
longloopmessage()
a212 1
#if HAVE_TIME
a213 1
#endif
d215 2
a216 2
	static void
longish()
d218 1
a218 3
#if HAVE_TIME
	if (loopcount >= 0 && ++loopcount > 100)
	{
d220 1
a220 2
		if (get_time() >= startime + LONGTIME)
		{
a224 7
#else
	if (loopcount >= 0 && ++loopcount > LONGLOOP)
	{
		longloopmessage();
		loopcount = -1;
	}
#endif
d231 2
a232 2
	static void
abort_long()
d247 2
a248 3
	public LINENUM
find_linenum(pos)
	POSITION pos;
d250 3
a252 3
	register struct linenum_info *p;
	register LINENUM linenum;
	POSITION cpos;
d259 1
a259 1
	if (pos == NULL_POSITION)
d285 1
a285 1
	 * First decide whether we should go forward from the 
d287 1
a287 1
	 * The decision is based on which way involves 
a289 1
#if HAVE_TIME
d291 1
a291 3
#endif
	if (p == &anchor || pos - p->prev->pos < p->pos - pos)
	{
d299 1
a299 2
		for (linenum = p->line, cpos = p->pos;  cpos < pos;  linenum++)
		{
d303 1
a303 1
			cpos = forw_raw_line(cpos, (char **)NULL, (int *)NULL);
d308 1
a308 1
			if (cpos == NULL_POSITION)
d322 1
a322 2
	} else
	{
d329 1
a329 2
		for (linenum = p->line, cpos = p->pos;  cpos > pos;  linenum--)
		{
d333 1
a333 1
			cpos = back_raw_line(cpos, (char **)NULL, (int *)NULL);
d338 1
a338 1
			if (cpos == NULL_POSITION)
d353 1
a353 1
 * Return NULL_POSITION if we can't figure it out.
d355 2
a356 3
	public POSITION
find_pos(linenum)
	LINENUM linenum;
d358 2
a359 2
	register struct linenum_info *p;
	POSITION cpos;
d377 1
a377 2
	if (p == &anchor || linenum - p->prev->line < p->line - linenum)
	{
d383 4
a386 3
			return (NULL_POSITION);
		for (clinenum = p->line, cpos = p->pos;  clinenum < linenum;  clinenum++)
		{
d390 1
a390 1
			cpos = forw_raw_line(cpos, (char **)NULL, (int *)NULL);
d392 3
a394 3
				return (NULL_POSITION);
			if (cpos == NULL_POSITION)
				return (NULL_POSITION);
d396 1
a396 2
	} else
	{
d401 4
a404 3
			return (NULL_POSITION);
		for (clinenum = p->line, cpos = p->pos;  clinenum > linenum;  clinenum--)
		{
d410 3
a412 3
				return (NULL_POSITION);
			if (cpos == NULL_POSITION)
				return (NULL_POSITION);
d427 2
a428 3
	public LINENUM
currline(where)
	int where;
d430 2
a431 2
	POSITION pos;
	POSITION len;
d436 1
a436 1
	while (pos == NULL_POSITION && where >= 0 && where < sc_height)
d438 1
a438 1
	if (pos == NULL_POSITION)
@


1.6
log
@Use volatile sig_atomic_t, not int, for the sigs variable.  Also
move the call to bell() out of u_interrupt() (a signal handler).
OK and with help from deraadt@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
@


1.5
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d69 1
a69 1
extern int sigs;
@


1.4
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
d59 1
a59 1
#define	NPOOL	50			/* Size of line number pool */
a62 2
public int lnloop = 0;			/* Are we in the line num loop? */

d71 1
a215 6
	/*
	 * Set the lnloop flag here, so if the user interrupts while
	 * we are calculating line numbers, the signal handler will 
	 * turn off line numbers (linenums=0).
	 */
	lnloop = 1;
d246 16
d326 6
a331 2
			cpos = forw_raw_line(cpos, (char **)NULL);
			if (ABORT_SIGS() || cpos == NULL_POSITION)
a334 1
		lnloop = 0;
d358 6
a363 2
			cpos = back_raw_line(cpos, (char **)NULL);
			if (ABORT_SIGS() || cpos == NULL_POSITION)
a366 1
		lnloop = 0;
d416 4
a419 2
			cpos = forw_raw_line(cpos, (char **)NULL);
			if (ABORT_SIGS() || cpos == NULL_POSITION)
d434 4
a437 2
			cpos = back_raw_line(cpos, (char **)NULL);
			if (ABORT_SIGS() || cpos == NULL_POSITION)
@


1.3
log
@kill more registers

millert@@ ok
@
text
@a0 2
/*	$OpenBSD: linenum.c,v 1.2 2001/01/29 01:58:02 niklas Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a36 1
#include "position.h"
d42 1
a42 1
struct linenum
d44 2
a45 2
	struct linenum *next;		/* Link to next in the list */
	struct linenum *prev;		/* Line to previous in the list */
d48 1
a48 1
	int line;			/* Line number */
d65 4
a68 4
static struct linenum anchor;		/* Anchor of the list */
static struct linenum *freelist;	/* Anchor of the unused entries */
static struct linenum pool[NPOOL];	/* The pool itself */
static struct linenum *spare;		/* We always keep one spare entry */
d80 1
a80 1
	struct linenum *p;
d107 1
a107 1
	struct linenum *p;
d126 2
a127 2
add_lnum(lno, pos)
	int lno;
d130 5
a134 5
	struct linenum *p;
	struct linenum *new;
	struct linenum *nextp;
	struct linenum *prevp;
	POSITION mingap;
d141 1
a141 1
		if (p->line == lno)
d172 1
a172 1
	new->line = lno;
d256 1
a256 1
	public int
d260 2
a261 2
	struct linenum *p;
	int lno;
a299 1
	flush();
d312 1
a312 1
		for (lno = p->line, cpos = p->pos;  cpos < pos;  lno++)
d326 1
a326 1
		add_lnum(lno, cpos);
d332 1
a332 1
			lno--;
d341 1
a341 1
		for (lno = p->line, cpos = p->pos;  cpos > pos;  lno--)
d355 1
a355 1
		add_lnum(lno, cpos);
d358 1
a358 1
	return (lno);
d366 2
a367 2
find_pos(lno)
	int lno;
d369 1
a369 1
	struct linenum *p;
d371 1
a371 1
	int clno;
d373 1
a373 1
	if (lno <= 1)
d382 1
a382 1
	for (p = anchor.next;  p != &anchor && p->line < lno;  p = p->next)
d384 1
a384 1
	if (p->line == lno)
d388 1
a388 2
	flush();
	if (p == &anchor || lno - p->prev->line < p->line - lno)
d396 1
a396 1
		for (clno = p->line, cpos = p->pos;  clno < lno;  clno++)
d412 1
a412 1
		for (clno = p->line, cpos = p->pos;  clno > lno;  clno--)
d425 1
a425 1
	add_lnum(clno, cpos);
d434 1
a434 1
	public int
d440 1
a440 1
	int lnum;
d448 1
a448 1
	lnum = find_linenum(pos);
d450 2
a451 2
		lnum--;
	return (lnum);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d99 1
a99 1
	register struct linenum *p;
d126 1
a126 1
	register struct linenum *p;
d149 5
a153 5
	register struct linenum *p;
	register struct linenum *new;
	register struct linenum *nextp;
	register struct linenum *prevp;
	register POSITION mingap;
d279 2
a280 2
	register struct linenum *p;
	register int lno;
d389 1
a389 1
	register struct linenum *p;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d53 1
d59 1
a59 1
struct linenum_info
d61 2
a62 2
	struct linenum_info *next;	/* Link to next in the list */
	struct linenum_info *prev;	/* Line to previous in the list */
d65 1
a65 1
	LINENUM line;			/* Line number */
d82 4
a85 4
static struct linenum_info anchor;	/* Anchor of the list */
static struct linenum_info *freelist;	/* Anchor of the unused entries */
static struct linenum_info pool[NPOOL];	/* The pool itself */
static struct linenum_info *spare;		/* We always keep one spare entry */
d97 1
a97 1
	register struct linenum_info *p;
d124 1
a124 1
	register struct linenum_info *p;
d143 2
a144 2
add_lnum(linenum, pos)
	LINENUM linenum;
d147 4
a150 4
	register struct linenum_info *p;
	register struct linenum_info *new;
	register struct linenum_info *nextp;
	register struct linenum_info *prevp;
d158 1
a158 1
		if (p->line == linenum)
d189 1
a189 1
	new->line = linenum;
d273 1
a273 1
	public LINENUM
d277 2
a278 2
	register struct linenum_info *p;
	register LINENUM linenum;
d317 1
d330 1
a330 1
		for (linenum = p->line, cpos = p->pos;  cpos < pos;  linenum++)
d344 1
a344 1
		add_lnum(linenum, cpos);
d350 1
a350 1
			linenum--;
d359 1
a359 1
		for (linenum = p->line, cpos = p->pos;  cpos > pos;  linenum--)
d373 1
a373 1
		add_lnum(linenum, cpos);
d376 1
a376 1
	return (linenum);
d384 2
a385 2
find_pos(linenum)
	LINENUM linenum;
d387 1
a387 1
	register struct linenum_info *p;
d389 1
a389 1
	LINENUM clinenum;
d391 1
a391 1
	if (linenum <= 1)
d400 1
a400 1
	for (p = anchor.next;  p != &anchor && p->line < linenum;  p = p->next)
d402 1
a402 1
	if (p->line == linenum)
d406 2
a407 1
	if (p == &anchor || linenum - p->prev->line < p->line - linenum)
d415 1
a415 1
		for (clinenum = p->line, cpos = p->pos;  clinenum < linenum;  clinenum++)
d431 1
a431 1
		for (clinenum = p->line, cpos = p->pos;  clinenum > linenum;  clinenum--)
d444 1
a444 1
	add_lnum(clinenum, cpos);
d453 1
a453 1
	public LINENUM
d459 1
a459 1
	LINENUM linenum;
d467 1
a467 1
	linenum = find_linenum(pos);
d469 2
a470 2
		linenum--;
	return (linenum);
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d59 1
a59 1
#define	NPOOL	200			/* Size of line number pool */
d63 2
a72 1
extern int screen_trashed;
d217 6
a252 16
 * Turn off line numbers because the user has interrupted
 * a lengthy line number calculation.
 */
	static void
abort_long()
{
	if (linenums == OPT_ONPLUS)
		/*
		 * We were displaying line numbers, so need to repaint.
		 */
		screen_trashed = 1;
	linenums = 0;
	error("Line numbers turned off", NULL_PARG);
}

/*
d317 2
a318 6
			cpos = forw_raw_line(cpos, (char **)NULL, (int *)NULL);
			if (ABORT_SIGS()) {
				abort_long();
				return (0);
			}
			if (cpos == NULL_POSITION)
d322 1
d346 2
a347 6
			cpos = back_raw_line(cpos, (char **)NULL, (int *)NULL);
			if (ABORT_SIGS()) {
				abort_long();
				return (0);
			}
			if (cpos == NULL_POSITION)
d351 1
d401 2
a402 4
			cpos = forw_raw_line(cpos, (char **)NULL, (int *)NULL);
			if (ABORT_SIGS())
				return (NULL_POSITION);
			if (cpos == NULL_POSITION)
d417 2
a418 4
			cpos = back_raw_line(cpos, (char **)NULL, (int *)NULL);
			if (ABORT_SIGS())
				return (NULL_POSITION);
			if (cpos == NULL_POSITION)
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
d69 1
a69 1
extern volatile sig_atomic_t sigs;
@


