head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.2
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	LESS_458:1.1.1.4
	OPENBSD_5_5:1.11.0.10
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.6
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	LESS_444:1.1.1.3
	OPENBSD_5_0:1.9.0.6
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.4
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.26
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.28
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.24
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.22
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.20
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.18
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	LESS_381:1.1.1.2
	MARK_NUDELMAN:1.1.1
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.10
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.8
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	OpenBSD_1_2:1.2
	less_290:1.1.1.1
	markn:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2016.09.17.15.06.41;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	W32EN7Zp77efb8wW;

1.18
date	2015.11.12.18.46.50;	author mmcc;	state Exp;
branches;
next	1.17;
commitid	gnso6vidZCgR92hy;

1.17
date	2015.11.12.17.09.57;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	5yWnusxM5e2SAPyQ;

1.16
date	2015.11.12.03.13.37;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	Xm4V0evFRfgaW1aJ;

1.15
date	2015.11.06.15.50.33;	author nicm;	state Exp;
branches;
next	1.14;
commitid	QKrr6AuGzNx9nehL;

1.14
date	2015.11.05.22.08.44;	author nicm;	state Exp;
branches;
next	1.13;
commitid	yKv9Ck9ZDgwWTRTo;

1.13
date	2014.04.29.12.11.25;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.25.13.38.21;	author shadchin;	state Exp;
branches;
next	1.11;

1.11
date	2012.03.27.06.22.45;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2011.09.16.18.12.09;	author shadchin;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.03.16.29.46;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.14.15.09.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.14.14.33.57;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.13.18.26.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.03;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.05.13.21.11.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.09.21.06.06.41;	author etheisen;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.05.39.43;	author etheisen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.18.21.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.09.16.17.47.07;	author shadchin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.25.13.33.49;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.19
log
@little bit more KNF
@
text
@/*
 * Copyright (C) 1984-2012  Mark Nudelman
 * Modified for use with illumos by Garrett D'Amore.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
 *
 * For more information, see the README file.
 */

/*
 * The option table.
 */

#include "less.h"
#include "option.h"

/*
 * Variables controlled by command line options.
 */
int quiet;		/* Should we suppress the audible bell? */
int how_search;		/* Where should forward searches start? */
int top_scroll;		/* Repaint screen from top? (vs scroll from bottom) */
int pr_type;		/* Type of prompt (short, medium, long) */
int bs_mode;		/* How to process backspaces */
int know_dumb;		/* Don't complain about dumb terminals */
int quit_at_eof;	/* Quit after hitting end of file twice */
int quit_if_one_screen;	/* Quit if EOF on first screen */
int squeeze;		/* Squeeze multiple blank lines into one */
int back_scroll;	/* Repaint screen on backwards movement */
int forw_scroll;	/* Repaint screen on forward movement */
int caseless;		/* Do "caseless" searches */
int linenums;		/* Use line numbers */
int autobuf;		/* Automatically allocate buffers as needed */
int bufspace;		/* Max buffer space per file (K) */
int ctldisp;		/* Send control chars to screen untranslated */
int force_open;		/* Open the file even if not regular file */
int swindow;		/* Size of scrolling window */
int jump_sline;		/* Screen line of "jump target" */
long jump_sline_fraction = -1;
int chopline;		/* Truncate displayed lines at screen width */
int no_init;		/* Disable sending ti/te termcap strings */
int no_keypad;		/* Disable sending ks/ke termcap strings */
int twiddle;		/* Show tildes after EOF */
int show_attn;		/* Hilite first unread line */
int status_col;		/* Display a status column */
int use_lessopen;	/* Use the LESSOPEN filter */
int quit_on_intr;	/* Quit on interrupt */
int follow_mode;	/* F cmd Follows file desc or file name? */
int oldbot;		/* Old bottom of screen behavior {{REMOVE}} */
int opt_use_backslash;	/* Use backslash escaping in option parsing */
int hilite_search;	/* Highlight matched search patterns? */

int less_is_more = 0;	/* Make compatible with POSIX more */

/*
 * Long option names.
 */
static struct optname a_optname		= { "search-skip-screen",	NULL };
static struct optname b_optname		= { "buffers",			NULL };
static struct optname B__optname	= { "auto-buffers",		NULL };
static struct optname c_optname		= { "clear-screen",		NULL };
static struct optname d_optname		= { "dumb",			NULL };
static struct optname e_optname		= { "quit-at-eof",		NULL };
static struct optname f_optname		= { "force",			NULL };
static struct optname F__optname	= { "quit-if-one-screen",	NULL };
static struct optname g_optname		= { "hilite-search",		NULL };
static struct optname h_optname		= { "max-back-scroll",		NULL };
static struct optname i_optname		= { "ignore-case",		NULL };
static struct optname j_optname		= { "jump-target",		NULL };
static struct optname J__optname	= { "status-column",		NULL };
static struct optname k_optname		= { "lesskey-file",		NULL };
static struct optname K__optname	= { "quit-on-intr",		NULL };
static struct optname L__optname	= { "no-lessopen",		NULL };
static struct optname m_optname		= { "long-prompt",		NULL };
static struct optname n_optname		= { "line-numbers",		NULL };
static struct optname o_optname		= { "log-file",			NULL };
static struct optname O__optname	= { "LOG-FILE",			NULL };
static struct optname p_optname		= { "pattern",			NULL };
static struct optname P__optname	= { "prompt",			NULL };
static struct optname q2_optname	= { "silent",			NULL };
static struct optname q_optname		= { "quiet",		&q2_optname };
static struct optname r_optname		= { "raw-control-chars",	NULL };
static struct optname s_optname		= { "squeeze-blank-lines",	NULL };
static struct optname S__optname	= { "chop-long-lines",		NULL };
static struct optname t_optname		= { "tag",			NULL };
static struct optname T__optname	= { "tag-file",			NULL };
static struct optname u_optname		= { "underline-special",	NULL };
static struct optname V__optname	= { "version",			NULL };
static struct optname w_optname		= { "hilite-unread",		NULL };
static struct optname x_optname		= { "tabs",			NULL };
static struct optname X__optname	= { "no-init",			NULL };
static struct optname y_optname		= { "max-forw-scroll",		NULL };
static struct optname z_optname		= { "window",			NULL };
static struct optname quote_optname	= { "quotes",			NULL };
static struct optname tilde_optname	= { "tilde",			NULL };
static struct optname query_optname	= { "help",			NULL };
static struct optname pound_optname	= { "shift",			NULL };
static struct optname keypad_optname	= { "no-keypad",		NULL };
static struct optname oldbot_optname	= { "old-bot",			NULL };
static struct optname follow_optname	= { "follow-name",		NULL };
static struct optname use_backslash_optname = { "use-backslash",	NULL };


/*
 * Table of all options and their semantics.
 *
 * For BOOL and TRIPLE options, odesc[0], odesc[1], odesc[2] are
 * the description of the option when set to 0, 1 or 2, respectively.
 * For NUMBER options, odesc[0] is the prompt to use when entering
 * a new value, and odesc[1] is the description, which should contain
 * one %d which is replaced by the value of the number.
 * For STRING options, odesc[0] is the prompt to use when entering
 * a new value, and odesc[1], if not NULL, is the set of characters
 * that are valid in the string.
 */
static struct loption option[] = {
	{ 'a', &a_optname,
		TRIPLE, OPT_ONPLUS, &how_search, NULL,
		{
			"Search includes displayed screen",
			"Search skips displayed screen",
			"Search includes all of displayed screen"
		}
	},

	{ 'b', &b_optname,
		NUMBER|INIT_HANDLER, 64, &bufspace, opt_b,
		{
			"Max buffer space per file (K): ",
			"Max buffer space per file: %dK",
			NULL
		}
	},
	{ 'B', &B__optname,
		BOOL, OPT_ON, &autobuf, NULL,
		{
			"Don't automatically allocate buffers",
			"Automatically allocate buffers when needed",
			NULL
		}
	},
	{ 'c', &c_optname,
		TRIPLE|MORE_OK, OPT_ON, &top_scroll, NULL,
		{
			"Repaint by scrolling from bottom of screen",
			"Repaint by painting from top of screen",
			"Repaint by painting from top of screen"
		}
	},
	{ 'd', &d_optname,
		BOOL|MORE_OK|NO_TOGGLE, OPT_OFF, &know_dumb, NULL,
		{
			"Assume intelligent terminal",
			"Assume dumb terminal",
			NULL
		}
	},
	{ 'e', &e_optname,
		TRIPLE, OPT_OFF, &quit_at_eof, NULL,
		{
			"Don't quit at end-of-file",
			"Quit at end-of-file",
			"Quit immediately at end-of-file"
		}
	},
	{ 'f', &f_optname,
		BOOL, OPT_OFF, &force_open, NULL,
		{
			"Open only regular files",
			"Open even non-regular files",
			NULL
		}
	},
	{ 'F', &F__optname,
		BOOL, OPT_OFF, &quit_if_one_screen, NULL,
		{
			"Don't quit if end-of-file on first screen",
			"Quit if end-of-file on first screen",
			NULL
		}
	},
	{ 'g', &g_optname,
		TRIPLE|HL_REPAINT, OPT_ONPLUS, &hilite_search, NULL,
		{
			"Don't highlight search matches",
			"Highlight matches for previous search only",
			"Highlight all matches for previous search pattern",
		}
	},
	{ 'h', &h_optname,
		NUMBER, -1, &back_scroll, NULL,
		{
			"Backwards scroll limit: ",
			"Backwards scroll limit is %d lines",
			NULL
		}
	},
	{ 'i', &i_optname,
		TRIPLE|HL_REPAINT, OPT_OFF, &caseless, opt_i,
		{
			"Case is significant in searches",
			"Ignore case in searches",
			"Ignore case in searches and in patterns"
		}
	},
	{ 'j', &j_optname,
		STRING, 0, NULL, opt_j,
		{
			"Target line: ",
			"0123456789.-",
			NULL
		}
	},
	{ 'J', &J__optname,
		BOOL|REPAINT, OPT_OFF, &status_col, NULL,
		{
			"Don't display a status column",
			"Display a status column",
			NULL
		}
	},
	{ 'k', &k_optname,
		STRING|NO_TOGGLE|NO_QUERY, 0, NULL, opt_k,
		{ NULL, NULL, NULL }
	},
	{ 'K', &K__optname,
		BOOL, OPT_OFF, &quit_on_intr, NULL,
		{
			"Interrupt (ctrl-C) returns to prompt",
			"Interrupt (ctrl-C) exits less",
			NULL
		}
	},
	{ 'L', &L__optname,
		BOOL, OPT_ON, &use_lessopen, NULL,
		{
			"Don't use the LESSOPEN filter",
			"Use the LESSOPEN filter",
			NULL
		}
	},
	{ 'm', &m_optname,
		TRIPLE, OPT_OFF, &pr_type, NULL,
		{
			"Short prompt",
			"Medium prompt",
			"Long prompt"
		}
	},
	{ 'n', &n_optname,
		TRIPLE|REPAINT, OPT_ON, &linenums, NULL,
		{
			"Don't use line numbers",
			"Use line numbers",
			"Constantly display line numbers"
		}
	},
	{ 'o', &o_optname,
		STRING, 0, NULL, opt_o,
		{ "log file: ", NULL, NULL }
	},
	{ 'O', &O__optname,
		STRING, 0, NULL, opt__O,
		{ "Log file: ", NULL, NULL }
	},
	{ 'p', &p_optname,
		STRING|NO_TOGGLE|NO_QUERY|MORE_OK, 0, NULL, opt_p,
		{ NULL, NULL, NULL }
	},
	{ 'P', &P__optname,
		STRING, 0, NULL, opt__P,
		{ "prompt: ", NULL, NULL }
	},
	{ 'q', &q_optname,
		TRIPLE, OPT_OFF, &quiet, NULL,
		{
			"Ring the bell for errors AND at eof/bof",
			"Ring the bell for errors but not at eof/bof",
			"Never ring the bell"
		}
	},
	{ 'r', &r_optname,
		TRIPLE|REPAINT, OPT_OFF, &ctldisp, NULL,
		{
			"Display control characters as ^X",
			"Display control characters directly",
			"Display control characters directly, "
			"processing ANSI sequences"
		}
	},
	{ 's', &s_optname,
		BOOL|REPAINT|MORE_OK, OPT_OFF, &squeeze, NULL,
		{
			"Display all blank lines",
			"Squeeze multiple blank lines",
			NULL
		}
	},
	{ 'S', &S__optname,
		BOOL|REPAINT, OPT_OFF, &chopline, NULL,
		{
			"Fold long lines",
			"Chop long lines",
			NULL
		}
	},
	{ 't', &t_optname,
		STRING|NO_QUERY|MORE_OK, 0, NULL, opt_t,
		{ "tag: ", NULL, NULL }
	},
	{ 'T', &T__optname,
		STRING|MORE_OK, 0, NULL, opt__T,
		{ "tags file: ", NULL, NULL }
	},
	{ 'u', &u_optname,
		TRIPLE|REPAINT, OPT_OFF, &bs_mode, NULL,
		{
			"Display underlined text in underline mode",
			"Backspaces cause overstrike",
			"Print backspace as ^H"
		}
	},
	{ 'V', &V__optname,
		NOVAR, 0, NULL, opt__V,
		{ NULL, NULL, NULL }
	},
	{ 'w', &w_optname,
		TRIPLE|REPAINT, OPT_OFF, &show_attn, NULL,
		{
			"Don't highlight first unread line",
			"Highlight first unread line after forward-screen",
			"Highlight first unread line after any "
			"forward movement",
		}
	},
	{ 'x', &x_optname,
		STRING|REPAINT, 0, NULL, opt_x,
		{
			"Tab stops: ",
			"0123456789,",
			NULL
		}
	},
	{ 'X', &X__optname,
		BOOL|NO_TOGGLE, OPT_OFF, &no_init, NULL,
		{
			"Send init/deinit strings to terminal",
			"Don't use init/deinit strings",
			NULL
		}
	},
	{ 'y', &y_optname,
		NUMBER, -1, &forw_scroll, NULL,
		{
			"Forward scroll limit: ",
			"Forward scroll limit is %d lines",
			NULL
		}
	},
	{ 'z', &z_optname,
		NUMBER, -1, &swindow, NULL,
		{
			"Scroll window size: ",
			"Scroll window size is %d lines",
			NULL
		}
	},
	{ '"', &quote_optname,
		STRING, 0, NULL, opt_quote,
		{ "quotes: ", NULL, NULL }
	},
	{ '~', &tilde_optname,
		BOOL|REPAINT, OPT_ON, &twiddle, NULL,
		{
			"Don't show tildes after end of file",
			"Show tildes after end of file",
			NULL
		}
	},
	{ '?', &query_optname,
		NOVAR, 0, NULL, opt_query,
		{ NULL, NULL, NULL }
	},
	{ '#', &pound_optname,
		STRING, 0, NULL, opt_shift,
		{
			"Horizontal shift: ",
			"0123456789.",
			NULL
		}
	},
	{ OLETTER_NONE, &keypad_optname,
		BOOL|NO_TOGGLE, OPT_OFF, &no_keypad, NULL,
		{
			"Use keypad mode",
			"Don't use keypad mode",
			NULL
		}
	},
	{ OLETTER_NONE, &oldbot_optname,
		BOOL, OPT_OFF, &oldbot, NULL,
		{
			"Use new bottom of screen behavior",
			"Use old bottom of screen behavior",
			NULL
		}
	},
	{ OLETTER_NONE, &follow_optname,
		BOOL, FOLLOW_DESC, &follow_mode, NULL,
		{
			"F command follows file descriptor",
			"F command follows file name",
			NULL
		}
	},
	{ OLETTER_NONE, &use_backslash_optname,
		BOOL, OPT_OFF, &opt_use_backslash, NULL,
		{
			"Use backslash escaping in command line parameters",
			"Don't use backslash escaping in command line "
			"parameters",
			NULL
		}
	},
	{ '\0', NULL, NOVAR, 0, NULL, NULL, { NULL, NULL, NULL } }
};


/*
 * Initialize each option to its default value.
 */
void
init_option(void)
{
	struct loption *o;

	for (o = option; o->oletter != '\0'; o++) {
		/*
		 * Set each variable to its default.
		 */
		if (o->ovar != NULL)
			*(o->ovar) = o->odefault;
		if (o->otype & INIT_HANDLER)
			(*(o->ofunc))(INIT, NULL);
	}
}

/*
 * Find an option in the option table, given its option letter.
 */
struct loption *
findopt(int c)
{
	struct loption *o;

	for (o = option; o->oletter != '\0'; o++) {
		if (o->oletter == c)
			return (o);
		if ((o->otype & TRIPLE) &&
		    (toupper((unsigned char)o->oletter) == c))
			return (o);
	}
	return (NULL);
}

/*
 *
 */
static int
is_optchar(unsigned char c)
{
	if (isupper(c) || islower(c) || c == '-')
		return (1);
	else
		return (0);
}

/*
 * Find an option in the option table, given its option name.
 * p_optname is the (possibly partial) name to look for, and
 * is updated to point after the matched name.
 * p_oname if non-NULL is set to point to the full option name.
 */
struct loption *
findopt_name(char **p_optname, char **p_oname, int *p_err)
{
	char *optname = *p_optname;
	struct loption *o;
	struct optname *oname;
	int len;
	int uppercase;
	struct loption *maxo = NULL;
	struct optname *maxoname = NULL;
	int maxlen = 0;
	int ambig = 0;
	int exact = 0;

	/*
	 * Check all options.
	 */
	for (o = option; o->oletter != '\0'; o++) {
		/*
		 * Check all names for this option.
		 */
		for (oname = o->onames; oname != NULL; oname = oname->onext) {
			/*
			 * Try normal match first (uppercase == 0),
			 * then, then if it's a TRIPLE option,
			 * try uppercase match (uppercase == 1).
			 */
			for (uppercase = 0; uppercase <= 1; uppercase++) {
				len = sprefix(optname, oname->oname, uppercase);
				if (len <= 0 || is_optchar(optname[len])) {
					/*
					 * We didn't use all of the option name.
					 */
					continue;
				}
				if (!exact && len == maxlen) {
					/*
					 * Already had a partial match,
					 * and now there's another one that
					 * matches the same length.
					 */
					ambig = 1;
				} else if (len > maxlen) {
					/*
					 * Found a better match than
					 * the one we had.
					 */
					maxo = o;
					maxoname = oname;
					maxlen = len;
					ambig = 0;
					exact = (len == strlen(oname->oname));
				}
				if (!(o->otype & TRIPLE))
					break;
			}
		}
	}
	if (ambig) {
		/*
		 * Name matched more than one option.
		 */
		if (p_err != NULL)
			*p_err = OPT_AMBIG;
		return (NULL);
	}
	*p_optname = optname + maxlen;
	if (p_oname != NULL)
		*p_oname = maxoname == NULL ? NULL : maxoname->oname;
	return (maxo);
}
@


1.18
log
@Back out of is_optchar() removal. daniel@@ was not a fan.
@
text
@d439 1
a439 1
	for (o = option;  o->oletter != '\0';  o++) {
d458 1
a458 1
	for (o = option;  o->oletter != '\0';  o++) {
d503 1
a503 1
	for (o = option;  o->oletter != '\0';  o++) {
d507 1
a507 1
		for (oname = o->onames;  oname != NULL;  oname = oname->onext) {
d513 1
a513 1
			for (uppercase = 0;  uppercase <= 1;  uppercase++) {
@


1.17
log
@Inline is_optchar(), a helper function with only one usage.

ok nicm@@, stsp@@
@
text
@d469 12
d515 1
a515 4
				if (len <= 0 ||
				    isupper((unsigned char)optname[len]) ||
				    islower((unsigned char)optname[len]) ||
				    optname[len] == '-') {
@


1.16
log
@Cast three ctype functions' arguments to unsigned char and simplify a
helper function in the process.

ok tedu@@
@
text
@a468 12
 *
 */
static int
is_optchar(unsigned char c)
{
	if (isupper(c) || islower(c) || c == '-')
		return (1);
	else
		return (0);
}

/*
d503 4
a506 1
				if (len <= 0 || is_optchar(optname[len])) {
@


1.15
log
@Garrett D'Amore has agreed to moving his copyright line up above the
terms with the existing copyright, so it is clear it applies the same
terms.
@
text
@d461 2
a462 1
		if ((o->otype & TRIPLE) && (toupper(o->oletter) == c))
d472 1
a472 1
is_optchar(char c)
d474 1
a474 1
	if (isupper(c))
d476 2
a477 5
	if (islower(c))
		return (1);
	if (c == '-')
		return (1);
	return (0);
@


1.14
log
@Replace less with the cleaned-up fork of less 458 maintained by Garrett
D'Amore at https://github.com/gdamore/less-fork. This has significantly
less portability goop, has a tidied up code style, uses terminfo instead
of termcap, and is has stricter POSIX compliance.

Many of our local changes have been accepted upstream: substantial
remaining local changes are code to read help files from /usr/share
rather than compiling them in, man page and help improvements, and some
tweaks to the default options.

Review and testing by millert, ok deraadt
@
text
@d3 2
a9 4
 */
/*
 * Modified for use with illumos.
 * Copyright 2014 Garrett D'Amore <garrett@@damore.org>
@


1.13
log
@Remove support for the obsolete (non-POSIX) "more -d" prompt.
This was a local change that was only enabled when the LESS_IS_MORE
environment variable was set and not when invoked as "more".
OK shadchin@@ jmc@@
@
text
@d9 4
a12 1

d24 32
a55 38
public int quiet;		/* Should we suppress the audible bell? */
public int how_search;		/* Where should forward searches start? */
public int top_scroll;		/* Repaint screen from top?
				   (alternative is scroll from bottom) */
public int pr_type;		/* Type of prompt (short, medium, long) */
public int bs_mode;		/* How to process backspaces */
public int know_dumb;		/* Don't complain about dumb terminals */
public int quit_at_eof;		/* Quit after hitting end of file twice */
public int quit_if_one_screen;	/* Quit if EOF on first screen */
public int squeeze;		/* Squeeze multiple blank lines into one */
public int tabstop;		/* Tab settings */
public int back_scroll;		/* Repaint screen on backwards movement */
public int forw_scroll;		/* Repaint screen on forward movement */
public int caseless;		/* Do "caseless" searches */
public int linenums;		/* Use line numbers */
public int autobuf;		/* Automatically allocate buffers as needed */
public int bufspace;		/* Max buffer space per file (K) */
public int ctldisp;		/* Send control chars to screen untranslated */
public int force_open;		/* Open the file even if not regular file */
public int swindow;		/* Size of scrolling window */
public int jump_sline;		/* Screen line of "jump target" */
public long jump_sline_fraction = -1;
public long shift_count_fraction = -1;
public int chopline;		/* Truncate displayed lines at screen width */
public int no_init;		/* Disable sending ti/te termcap strings */
public int no_keypad;		/* Disable sending ks/ke termcap strings */
public int twiddle;             /* Show tildes after EOF */
public int show_attn;		/* Hilite first unread line */
public int shift_count;		/* Number of positions to shift horizontally */
public int status_col;		/* Display a status column */
public int use_lessopen;	/* Use the LESSOPEN filter */
public int quit_on_intr;	/* Quit on interrupt */
public int follow_mode;		/* F cmd Follows file desc or file name? */
public int oldbot;		/* Old bottom of screen behavior {{REMOVE}} */
public int opt_use_backslash;	/* Use backslash escaping in option parsing */
#if HILITE_SEARCH
public int hilite_search;	/* Highlight matched search patterns? */
#endif
d57 1
a57 1
public int less_is_more = 0;	/* Make compatible with POSIX more */
d62 44
a105 114
#if GNU_OPTIONS
static struct optname a_optname      = { "search-skip-screen",   NULL };
static struct optname b_optname      = { "buffers",              NULL };
static struct optname B__optname     = { "auto-buffers",         NULL };
static struct optname c_optname      = { "clear-screen",         NULL };
static struct optname d_optname      = { "dumb",                 NULL };
#if MSDOS_COMPILER
static struct optname D__optname     = { "color",                NULL };
#endif
static struct optname e_optname      = { "quit-at-eof",          NULL };
static struct optname f_optname      = { "force",                NULL };
static struct optname F__optname     = { "quit-if-one-screen",   NULL };
#if HILITE_SEARCH
static struct optname g_optname      = { "hilite-search",        NULL };
#endif
static struct optname h_optname      = { "max-back-scroll",      NULL };
static struct optname i_optname      = { "ignore-case",          NULL };
static struct optname j_optname      = { "jump-target",          NULL };
static struct optname J__optname     = { "status-column",        NULL };
#if USERFILE
static struct optname k_optname      = { "lesskey-file",         NULL };
#endif
static struct optname K__optname     = { "quit-on-intr",         NULL };
static struct optname L__optname     = { "no-lessopen",          NULL };
static struct optname m_optname      = { "long-prompt",          NULL };
static struct optname n_optname      = { "line-numbers",         NULL };
#if LOGFILE
static struct optname o_optname      = { "log-file",             NULL };
static struct optname O__optname     = { "LOG-FILE",             NULL };
#endif
static struct optname p_optname      = { "pattern",              NULL };
static struct optname P__optname     = { "prompt",               NULL };
static struct optname q2_optname     = { "silent",               NULL };
static struct optname q_optname      = { "quiet",                &q2_optname };
static struct optname r_optname      = { "raw-control-chars",    NULL };
static struct optname s_optname      = { "squeeze-blank-lines",  NULL };
static struct optname S__optname     = { "chop-long-lines",      NULL };
#if TAGS
static struct optname t_optname      = { "tag",                  NULL };
static struct optname T__optname     = { "tag-file",             NULL };
#endif
static struct optname u_optname      = { "underline-special",    NULL };
static struct optname V__optname     = { "version",              NULL };
static struct optname w_optname      = { "hilite-unread",        NULL };
static struct optname x_optname      = { "tabs",                 NULL };
static struct optname X__optname     = { "no-init",              NULL };
static struct optname y_optname      = { "max-forw-scroll",      NULL };
static struct optname z_optname      = { "window",               NULL };
static struct optname quote_optname  = { "quotes",               NULL };
static struct optname tilde_optname  = { "tilde",                NULL };
static struct optname query_optname  = { "help",                 NULL };
static struct optname pound_optname  = { "shift",                NULL };
static struct optname keypad_optname = { "no-keypad",            NULL };
static struct optname oldbot_optname = { "old-bot",              NULL };
static struct optname follow_optname = { "follow-name",          NULL };
static struct optname use_backslash_optname = { "use-backslash", NULL };
#else
static struct optname fake_optname   = { "fake",                 NULL };
#define a_optname	fake_optname
#define b_optname	fake_optname
#define B__optname	fake_optname
#define c_optname	fake_optname
#define d_optname	fake_optname
#if MSDOS_COMPILER
#define D__optname	fake_optname
#endif
#define e_optname	fake_optname
#define f_optname	fake_optname
#define F__optname	fake_optname
#if HILITE_SEARCH
#define g_optname	fake_optname
#endif
#define h_optname	fake_optname
#define i_optname	fake_optname
#define j_optname	fake_optname
#define J__optname	fake_optname
#if USERFILE
#define k_optname	fake_optname
#endif
#define K__optname	fake_optname
#define L__optname	fake_optname
#define m_optname	fake_optname
#define n_optname	fake_optname
#if LOGFILE
#define o_optname	fake_optname
#define O__optname	fake_optname
#endif
#define p_optname	fake_optname
#define P__optname	fake_optname
#define q2_optname	fake_optname
#define q_optname	fake_optname
#define r_optname	fake_optname
#define s_optname	fake_optname
#define S__optname	fake_optname
#if TAGS
#define t_optname	fake_optname
#define T__optname	fake_optname
#endif
#define u_optname	fake_optname
#define V__optname	fake_optname
#define w_optname	fake_optname
#define x_optname	fake_optname
#define X__optname	fake_optname
#define y_optname	fake_optname
#define z_optname	fake_optname
#define quote_optname	fake_optname
#define tilde_optname	fake_optname
#define query_optname	fake_optname
#define pound_optname	fake_optname
#define keypad_optname	fake_optname
#define oldbot_optname	fake_optname
#define follow_optname	fake_optname
#define use_backslash_optname	fake_optname
#endif
d114 1
a114 1
 * a new value, and odesc[1] is the description, which should contain 
d120 1
a120 2
static struct loption option[] =
{
d131 1
a131 1
		NUMBER|INIT_HANDLER, 64, &bufspace, opt_b, 
d147 1
a147 1
		TRIPLE, OPT_ON, &top_scroll, NULL,
d155 1
a155 1
		BOOL|NO_TOGGLE, OPT_OFF, &know_dumb, NULL,
a161 10
#if MSDOS_COMPILER
	{ 'D', &D__optname,
		STRING|REPAINT|NO_QUERY, 0, NULL, opt_D,
		{
			"color desc: ", 
			"Ddknsu0123456789.",
			NULL
		}
	},
#endif
a185 1
#if HILITE_SEARCH
a193 1
#endif
a225 1
#if USERFILE
a229 1
#endif
a261 1
#if LOGFILE
a269 1
#endif
d271 1
a271 1
		STRING|NO_TOGGLE|NO_QUERY, 0, NULL, opt_p,
d291 2
a292 1
			"Display control characters directly, processing ANSI sequences"
d296 1
a296 1
		BOOL|REPAINT, OPT_OFF, &squeeze, NULL,
a310 1
#if TAGS
d312 1
a312 1
		STRING|NO_QUERY, 0, NULL, opt_t,
d316 1
a316 1
		STRING, 0, NULL, opt__T,
a318 1
#endif
d336 2
a337 1
			"Highlight first unread line after any forward movement",
d424 2
a425 1
			"Don't use backslash escaping in command line parameters",
d436 2
a437 2
	public void
init_option()
d439 1
a439 2
	register struct loption *o;
	char *p;
d441 1
a441 6
	p = lgetenv("LESS_IS_MORE");
	if (p != NULL && *p != '\0')
		less_is_more = 1;

	for (o = option;  o->oletter != '\0';  o++)
	{
d448 1
a448 1
			(*(o->ofunc))(INIT, (char *) NULL);
d455 2
a456 3
	public struct loption *
findopt(c)
	int c;
d458 1
a458 1
	register struct loption *o;
d460 1
a460 2
	for (o = option;  o->oletter != '\0';  o++)
	{
d463 1
a463 1
		if ((o->otype & TRIPLE) && ASCII_TO_UPPER(o->oletter) == c)
d472 2
a473 3
	static int
is_optchar(c)
	char c;
d475 4
a478 4
	if (ASCII_IS_UPPER(c))
		return 1;
	if (ASCII_IS_LOWER(c))
		return 1;
d480 2
a481 2
		return 1;
	return 0;
a483 1
#if GNU_OPTIONS
d490 2
a491 5
	public struct loption *
findopt_name(p_optname, p_oname, p_err)
	char **p_optname;
	char **p_oname;
	int *p_err;
d494 3
a496 3
	register struct loption *o;
	register struct optname *oname;
	register int len;
d507 1
a507 2
	for (o = option;  o->oletter != '\0';  o++)
	{
d511 2
a512 3
		for (oname = o->onames;  oname != NULL;  oname = oname->onext)
		{
			/* 
d517 1
a517 2
			for (uppercase = 0;  uppercase <= 1;  uppercase++)
			{
d519 1
a519 2
				if (len <= 0 || is_optchar(optname[len]))
				{
d525 1
a525 1
				if (!exact && len == maxlen)
d532 1
a532 2
				else if (len > maxlen)
				{
d541 1
a541 1
					exact = (len == (int)strlen(oname->oname));
d548 1
a548 2
	if (ambig)
	{
a560 1
#endif
@


1.12
log
@Merge Less 458 plus local patches

ok guenther@@, ok jmc@@ for man bits
@
text
@a30 1
public int be_helpful;		/* more(1) style -d */
a536 15
		/*
		 * Replace less's -d option if invoked as more
		 */
		if (less_is_more && o->oletter == 'd')
		{
			o->onames = NULL;
			o->otype = BOOL;
			o->odefault = OPT_OFF;
			o->ovar = &be_helpful;
			o->ofunc = NULL;
			o->odesc[0] = "Be less helpful in prompts";
			o->odesc[1] = "Be helpful in prompts";
			o->odesc[2] = NULL;
		}

@


1.11
log
@Reverse the default of the -c flag from off to on to prevent the text
being displayed in the wrong place initially and then jumping when first
redrawn (such as when searching).

ok deraadt sthen
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
d7 1
a7 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
d56 1
d121 1
d178 1
d508 8
@


1.10
log
@Merge in less 444 plus local changes

ok nicm@@
@
text
@d220 1
a220 1
		TRIPLE, OPT_OFF, &top_scroll, NULL,
@


1.9
log
@use SMALL_PROGRAM to knock out some code
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2002  Mark Nudelman
a32 1
#ifndef SMALL_PROGRAM
a33 1
#endif
a38 1
public int nohelp;		/* Disable the HELP command */
d44 2
d54 3
d61 2
d88 1
d119 2
d144 1
d175 2
d195 1
a195 1
		BOOL, OPT_OFF, &how_search, NULL,
d199 1
a199 1
			NULL
d223 1
a223 1
			"Repaint by clearing each line",
a286 8
	{ 'H',  NULL,
		BOOL|NO_TOGGLE, OPT_OFF, &nohelp, NULL,
		{
			"Allow help command",
			"Don't allow help command",
			NULL
		}
	},
d296 1
a296 1
		NUMBER, 1, &jump_sline, NULL,
d299 1
a299 1
			"Position target at screen line %d",
d317 7
a323 3
	{ 'l', NULL,
		STRING|NO_TOGGLE|NO_QUERY, 0, NULL, opt_l,
		{ NULL, NULL, NULL }
d478 1
a478 1
		NUMBER, 0, &shift_count, NULL,
d481 1
a481 1
			"Horizontal shift %d positions",
d485 1
a485 1
	{ '.', &keypad_optname,
d493 16
d520 5
a524 1
	extern int ismore;
d531 1
a531 1
		if (ismore && o->oletter == 'd')
d566 1
a566 1
		if ((o->otype & TRIPLE) && toupper(o->oletter) == c)
d579 1
a579 1
	if (SIMPLE_IS_UPPER(c))
d581 1
a581 1
	if (SIMPLE_IS_LOWER(c))
@


1.8
log
@Make the GNU_OPTIONS define actually do something (was a no-op)
@
text
@d33 1
d35 1
@


1.7
log
@o go back to using a help file instead of embedding it in the binary
o deal with HELPFILE not being defined
o add a SMALL definition to make a smaller less for the boot floppies
This still needs to be pared down a bit for the SMALL case
@
text
@d60 1
d112 54
d560 1
d647 1
@


1.6
log
@Merge in less-381 w/ local changes and remove obsolete files.
@
text
@d39 1
d217 8
@


1.5
log
@kill more registers

millert@@ ok
@
text
@a0 2
/*	$OpenBSD: opttbl.c,v 1.4 2001/01/29 01:58:03 niklas Exp $	*/

d2 1
a2 2
 * Copyright (c) 1984,1985,1989,1994,1995  Mark Nudelman
 * All rights reserved.
d4 2
a5 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice in the documentation and/or other materials provided with 
 *    the distribution.
d7 2
a8 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN 
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d30 2
a32 1
public int squeeze;		/* Squeeze multiple blank lines into one */
a35 1
public int twiddle;		/* Display "~" for lines after EOF */
a37 1
public int cbufs;		/* Current number of buffers */
d39 1
a39 1
public int nohelp;		/* Disable the HELP command */
d46 6
d57 56
d114 9
d124 1
a124 1
static struct option option[] =
d126 74
a199 47
	{ 'a', BOOL, OPT_OFF, &how_search, NULL,
		"Search includes displayed screen",
		"Search skips displayed screen",
		NULL
	},
	{ 'b', NUMBER, 10, &cbufs, opt_b, 
		"Buffers: ",
		"%d buffers",
		NULL
	},
	{ 'B', BOOL, OPT_ON, &autobuf, NULL,
		"Don't automatically allocate buffers",
		"Automatically allocate buffers when needed",
		NULL
	},
	{ 'c', TRIPLE, OPT_OFF, &top_scroll, NULL,
		"Repaint by scrolling from bottom of screen",
		"Repaint by clearing each line",
		"Repaint by painting from top of screen"
	},
#if 0
	{ 'd', BOOL|NO_TOGGLE, OPT_OFF, &know_dumb, NULL,
		"Assume intelligent terminal",
		"Assume dumb terminal",
		NULL
	},
#else
	{ 'd', BOOL, OPT_OFF, &be_helpful, NULL,
		"Be less helpful in prompts",
		"Be helpful in prompts",
		NULL,
	},
#endif
#if MSOFTC
	{ 'D', STRING|REPAINT, 0, NULL, opt_D,
		"color desc: ", NULL, NULL
	},
#endif
	{ 'e', TRIPLE, OPT_OFF, &quit_at_eof, NULL,
		"Don't quit at end-of-file",
		"Quit at end-of-file",
		"Quit immediately at end-of-file"
	},
	{ 'f', BOOL, OPT_OFF, &force_open, NULL,
		"Open only regular files",
		"Open even non-regular files",
		NULL
d202 40
a241 25
	{ 'g', TRIPLE|HL_REPAINT, OPT_ONPLUS, &hilite_search, NULL,
		"Don't highlight search matches",
		"Highlight matches for previous search only",
		"Highlight all matches for previous search pattern",
	},
#endif
	{ 'h', NUMBER, -1, &back_scroll, NULL,
		"Backwards scroll limit: ",
		"Backwards scroll limit is %d lines",
		NULL
	},
	{ 'H', BOOL|NO_TOGGLE, OPT_OFF, &nohelp, NULL,
		"Allow help command",
		"Don't allow help command",
		NULL
	},
	{ 'i', TRIPLE|HL_REPAINT, OPT_OFF, &caseless, opt_i,
		"Case is significant in searches",
		"Ignore case in searches",
		"Ignore case in searches and in patterns"
	},
	{ 'j', NUMBER, 1, &jump_sline, NULL,
		"Target line: ",
		"Position target at screen line %d",
		NULL
d244 3
a246 2
	{ 'k', STRING|NO_TOGGLE|NO_QUERY, 0, NULL, opt_k,
		NULL, NULL, NULL
d249 27
a275 12
	{ 'l', STRING|NO_TOGGLE|NO_QUERY, 0, NULL, opt_l,
		NULL, NULL, NULL
	},
	{ 'm', TRIPLE, OPT_OFF, &pr_type, NULL,
		"Short prompt",
		"Medium prompt",
		"Long prompt"
	},
	{ 'n', TRIPLE|REPAINT, OPT_ON, &linenums, NULL,
		"Don't use line numbers",
		"Use line numbers",
		"Constantly display line numbers"
d278 7
a284 5
	{ 'o', STRING, 0, NULL, opt_o,
		"log file: ", NULL, NULL
	},
	{ 'O', STRING, 0, NULL, opt__O,
		"Log file: ", NULL, NULL
d287 39
a325 25
	{ 'p', STRING|NO_TOGGLE|NO_QUERY, 0, NULL, opt_p,
		NULL, NULL, NULL
	},
	{ 'P', STRING, 0, NULL, opt__P,
		"prompt: ", NULL, NULL
	},
	{ 'q', TRIPLE, OPT_OFF, &quiet, NULL,
		"Ring the bell for errors AND at eof/bof",
		"Ring the bell for errors but not at eof/bof",
		"Never ring the bell"
	},
	{ 'r', BOOL|REPAINT, OPT_ON, &ctldisp, NULL,
		"Display control characters directly",
		"Display control characters as ^X",
		NULL
	},
	{ 's', BOOL|REPAINT, OPT_OFF, &squeeze, NULL,
		"Display all blank lines",
		"Squeeze multiple blank lines",
		NULL
	},
	{ 'S', BOOL|REPAINT, OPT_OFF, &chopline, NULL,
		"Fold long lines",
		"Chop long lines",
		NULL
d328 7
a334 5
	{ 't', STRING|NO_QUERY, 0, NULL, opt_t,
		"tag: ", NULL, NULL
	},
	{ 'T', STRING, 0, NULL, opt__T,
		"tags file: ", NULL, NULL
d337 83
a419 32
	{ 'u', TRIPLE|REPAINT, OPT_OFF, &bs_mode, NULL,
		"Display underlined text in underline mode",
		"Backspaces cause overstrike",
		"Print backspace as ^H"
	},
	{ 'V', NOVAR, 0, NULL, opt__V,
		NULL, NULL, NULL
	},
	{ 'w', BOOL|REPAINT, OPT_ON, &twiddle, NULL,
		"Display nothing for lines after end-of-file",
		"Display ~ for lines after end-of-file",
		NULL
	},
	{ 'x', NUMBER|REPAINT, 8, &tabstop, NULL,
		"Tab stops: ",
		"Tab stops every %d spaces", 
		NULL
	},
	{ 'X', BOOL|NO_TOGGLE, OPT_OFF, &no_init, NULL,
		"Send init/deinit strings to terminal",
		"Don't use init/deinit strings",
		NULL
	},
	{ 'y', NUMBER, -1, &forw_scroll, NULL,
		"Forward scroll limit: ",
		"Forward scroll limit is %d lines",
		NULL
	},
	{ 'z', NUMBER, -1, &swindow, NULL,
		"Scroll window size: ",
		"Scroll window size is %d lines",
		NULL
d421 1
a421 4
	{ '?', NOVAR, 0, NULL, opt_query,
		NULL, NULL, NULL
	},
	{ '\0' }
d431 2
a432 1
	struct option *o;
d437 15
d456 2
d462 1
a462 1
 * Find an option in the option table.
d464 1
a464 1
	public struct option *
d468 1
a468 1
	struct option *o;
d478 103
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d255 1
a255 1
	register struct option *o;
d274 1
a274 1
	register struct option *o;
@


1.3
log
@less "-d" descriptions swapped; mouse@@Rodents.Montreal.QC.CA
@
text
@d1 2
@


1.2
log
@Incorporate less modifications for more and our bug fixes from previous
version.
@
text
@d100 1
a101 1
		"Be less helpful in prompts",
@


1.1
log
@Initial revision
@
text
@d46 1
d92 1
d98 7
@


1.1.1.1
log
@Import of unmolested less-290.
@
text
@@


1.1.1.2
log
@Stock less-390 with some unneeded DOS/Windoze files removed
@
text
@d2 2
a3 1
 * Copyright (C) 1984-2002  Mark Nudelman
d5 8
a12 2
 * You may distribute under the terms of either the GNU General Public
 * License or the Less License, as specified in the README file.
d14 11
a24 2
 * For more information about less, or for information on how to 
 * contact the author, see the README file.
a45 1
public int quit_if_one_screen;	/* Quit if EOF on first screen */
d50 1
d53 1
d55 1
a55 1
public int bufspace;		/* Max buffer space per file (K) */
a61 6
public int no_keypad;		/* Disable sending ks/ke termcap strings */
public int twiddle;             /* Show tildes after EOF */
public int show_attn;		/* Hilite first unread line */
public int shift_count;		/* Number of positions to shift horizontally */
public int status_col;		/* Display a status column */
public int use_lessopen;	/* Use the LESSOPEN filter */
a66 56
 * Long option names.
 */
static struct optname a_optname      = { "search-skip-screen",   NULL };
static struct optname b_optname      = { "buffers",              NULL };
static struct optname B__optname     = { "auto-buffers",         NULL };
static struct optname c_optname      = { "clear-screen",         NULL };
static struct optname d_optname      = { "dumb",                 NULL };
#if MSDOS_COMPILER
static struct optname D__optname     = { "color",                NULL };
#endif
static struct optname e_optname      = { "quit-at-eof",          NULL };
static struct optname f_optname      = { "force",                NULL };
static struct optname F__optname     = { "quit-if-one-screen",   NULL };
#if HILITE_SEARCH
static struct optname g_optname      = { "hilite-search",        NULL };
#endif
static struct optname h_optname      = { "max-back-scroll",      NULL };
static struct optname i_optname      = { "ignore-case",          NULL };
static struct optname j_optname      = { "jump-target",          NULL };
static struct optname J__optname     = { "status-column",        NULL };
#if USERFILE
static struct optname k_optname      = { "lesskey-file",         NULL };
#endif
static struct optname L__optname     = { "no-lessopen",          NULL };
static struct optname m_optname      = { "long-prompt",          NULL };
static struct optname n_optname      = { "line-numbers",         NULL };
#if LOGFILE
static struct optname o_optname      = { "log-file",             NULL };
static struct optname O__optname     = { "LOG-FILE",             NULL };
#endif
static struct optname p_optname      = { "pattern",              NULL };
static struct optname P__optname     = { "prompt",               NULL };
static struct optname q2_optname     = { "silent",               NULL };
static struct optname q_optname      = { "quiet",                &q2_optname };
static struct optname r_optname      = { "raw-control-chars",    NULL };
static struct optname s_optname      = { "squeeze-blank-lines",  NULL };
static struct optname S__optname     = { "chop-long-lines",      NULL };
#if TAGS
static struct optname t_optname      = { "tag",                  NULL };
static struct optname T__optname     = { "tag-file",             NULL };
#endif
static struct optname u_optname      = { "underline-special",    NULL };
static struct optname V__optname     = { "version",              NULL };
static struct optname w_optname      = { "hilite-unread",        NULL };
static struct optname x_optname      = { "tabs",                 NULL };
static struct optname X__optname     = { "no-init",              NULL };
static struct optname y_optname      = { "max-forw-scroll",      NULL };
static struct optname z_optname      = { "window",               NULL };
static struct optname quote_optname  = { "quotes",               NULL };
static struct optname tilde_optname  = { "tilde",                NULL };
static struct optname query_optname  = { "help",                 NULL };
static struct optname pound_optname  = { "shift",                NULL };
static struct optname keypad_optname = { "no-keypad",            NULL };


/*
a67 9
 *
 * For BOOL and TRIPLE options, odesc[0], odesc[1], odesc[2] are
 * the description of the option when set to 0, 1 or 2, respectively.
 * For NUMBER options, odesc[0] is the prompt to use when entering
 * a new value, and odesc[1] is the description, which should contain 
 * one %d which is replaced by the value of the number.
 * For STRING options, odesc[0] is the prompt to use when entering
 * a new value, and odesc[1], if not NULL, is the set of characters
 * that are valid in the string.
d69 1
a69 1
static struct loption option[] =
d71 39
a109 74
	{ 'a', &a_optname,
		BOOL, OPT_OFF, &how_search, NULL,
		{
			"Search includes displayed screen",
			"Search skips displayed screen",
			NULL
		}
	},

	{ 'b', &b_optname,
		NUMBER|INIT_HANDLER, 64, &bufspace, opt_b, 
		{
			"Max buffer space per file (K): ",
			"Max buffer space per file: %dK",
			NULL
		}
	},
	{ 'B', &B__optname,
		BOOL, OPT_ON, &autobuf, NULL,
		{
			"Don't automatically allocate buffers",
			"Automatically allocate buffers when needed",
			NULL
		}
	},
	{ 'c', &c_optname,
		TRIPLE, OPT_OFF, &top_scroll, NULL,
		{
			"Repaint by scrolling from bottom of screen",
			"Repaint by clearing each line",
			"Repaint by painting from top of screen"
		}
	},
	{ 'd', &d_optname,
		BOOL|NO_TOGGLE, OPT_OFF, &know_dumb, NULL,
		{
			"Assume intelligent terminal",
			"Assume dumb terminal",
			NULL
		}
	},
#if MSDOS_COMPILER
	{ 'D', &D__optname,
		STRING|REPAINT|NO_QUERY, 0, NULL, opt_D,
		{
			"color desc: ", 
			"Ddknsu0123456789.",
			NULL
		}
	},
#endif
	{ 'e', &e_optname,
		TRIPLE, OPT_OFF, &quit_at_eof, NULL,
		{
			"Don't quit at end-of-file",
			"Quit at end-of-file",
			"Quit immediately at end-of-file"
		}
	},
	{ 'f', &f_optname,
		BOOL, OPT_OFF, &force_open, NULL,
		{
			"Open only regular files",
			"Open even non-regular files",
			NULL
		}
	},
	{ 'F', &F__optname,
		BOOL, OPT_OFF, &quit_if_one_screen, NULL,
		{
			"Don't quit if end-of-file on first screen",
			"Quit if end-of-file on first screen",
			NULL
		}
d112 25
a136 40
	{ 'g', &g_optname,
		TRIPLE|HL_REPAINT, OPT_ONPLUS, &hilite_search, NULL,
		{
			"Don't highlight search matches",
			"Highlight matches for previous search only",
			"Highlight all matches for previous search pattern",
		}
	},
#endif
	{ 'h', &h_optname,
		NUMBER, -1, &back_scroll, NULL,
		{
			"Backwards scroll limit: ",
			"Backwards scroll limit is %d lines",
			NULL
		}
	},
	{ 'i', &i_optname,
		TRIPLE|HL_REPAINT, OPT_OFF, &caseless, opt_i,
		{
			"Case is significant in searches",
			"Ignore case in searches",
			"Ignore case in searches and in patterns"
		}
	},
	{ 'j', &j_optname,
		NUMBER, 1, &jump_sline, NULL,
		{
			"Target line: ",
			"Position target at screen line %d",
			NULL
		}
	},
	{ 'J', &J__optname,
		BOOL|REPAINT, OPT_OFF, &status_col, NULL,
		{
			"Don't display a status column",
			"Display a status column",
			NULL
		}
d139 2
a140 3
	{ 'k', &k_optname,
		STRING|NO_TOGGLE|NO_QUERY, 0, NULL, opt_k,
		{ NULL, NULL, NULL }
d143 12
a154 27
	{ 'l', NULL,
		STRING|NO_TOGGLE|NO_QUERY, 0, NULL, opt_l,
		{ NULL, NULL, NULL }
	},
	{ 'L', &L__optname,
		BOOL, OPT_ON, &use_lessopen, NULL,
		{
			"Don't use the LESSOPEN filter",
			"Use the LESSOPEN filter",
			NULL
		}
	},
	{ 'm', &m_optname,
		TRIPLE, OPT_OFF, &pr_type, NULL,
		{
			"Short prompt",
			"Medium prompt",
			"Long prompt"
		}
	},
	{ 'n', &n_optname,
		TRIPLE|REPAINT, OPT_ON, &linenums, NULL,
		{
			"Don't use line numbers",
			"Use line numbers",
			"Constantly display line numbers"
		}
d157 5
a161 7
	{ 'o', &o_optname,
		STRING, 0, NULL, opt_o,
		{ "log file: ", NULL, NULL }
	},
	{ 'O', &O__optname,
		STRING, 0, NULL, opt__O,
		{ "Log file: ", NULL, NULL }
d164 25
a188 39
	{ 'p', &p_optname,
		STRING|NO_TOGGLE|NO_QUERY, 0, NULL, opt_p,
		{ NULL, NULL, NULL }
	},
	{ 'P', &P__optname,
		STRING, 0, NULL, opt__P,
		{ "prompt: ", NULL, NULL }
	},
	{ 'q', &q_optname,
		TRIPLE, OPT_OFF, &quiet, NULL,
		{
			"Ring the bell for errors AND at eof/bof",
			"Ring the bell for errors but not at eof/bof",
			"Never ring the bell"
		}
	},
	{ 'r', &r_optname,
		TRIPLE|REPAINT, OPT_OFF, &ctldisp, NULL,
		{
			"Display control characters as ^X",
			"Display control characters directly",
			"Display control characters directly, processing ANSI sequences"
		}
	},
	{ 's', &s_optname,
		BOOL|REPAINT, OPT_OFF, &squeeze, NULL,
		{
			"Display all blank lines",
			"Squeeze multiple blank lines",
			NULL
		}
	},
	{ 'S', &S__optname,
		BOOL|REPAINT, OPT_OFF, &chopline, NULL,
		{
			"Fold long lines",
			"Chop long lines",
			NULL
		}
d191 5
a195 7
	{ 't', &t_optname,
		STRING|NO_QUERY, 0, NULL, opt_t,
		{ "tag: ", NULL, NULL }
	},
	{ 'T', &T__optname,
		STRING, 0, NULL, opt__T,
		{ "tags file: ", NULL, NULL }
d198 32
a229 83
	{ 'u', &u_optname,
		TRIPLE|REPAINT, OPT_OFF, &bs_mode, NULL,
		{
			"Display underlined text in underline mode",
			"Backspaces cause overstrike",
			"Print backspace as ^H"
		}
	},
	{ 'V', &V__optname,
		NOVAR, 0, NULL, opt__V,
		{ NULL, NULL, NULL }
	},
	{ 'w', &w_optname,
		TRIPLE|REPAINT, OPT_OFF, &show_attn, NULL,
		{
			"Don't highlight first unread line",
			"Highlight first unread line after forward-screen",
			"Highlight first unread line after any forward movement",
		}
	},
	{ 'x', &x_optname,
		STRING|REPAINT, 0, NULL, opt_x,
		{
			"Tab stops: ",
			"0123456789,",
			NULL
		}
	},
	{ 'X', &X__optname,
		BOOL|NO_TOGGLE, OPT_OFF, &no_init, NULL,
		{
			"Send init/deinit strings to terminal",
			"Don't use init/deinit strings",
			NULL
		}
	},
	{ 'y', &y_optname,
		NUMBER, -1, &forw_scroll, NULL,
		{
			"Forward scroll limit: ",
			"Forward scroll limit is %d lines",
			NULL
		}
	},
	{ 'z', &z_optname,
		NUMBER, -1, &swindow, NULL,
		{
			"Scroll window size: ",
			"Scroll window size is %d lines",
			NULL
		}
	},
	{ '"', &quote_optname,
		STRING, 0, NULL, opt_quote,
		{ "quotes: ", NULL, NULL }
	},
	{ '~', &tilde_optname,
		BOOL|REPAINT, OPT_ON, &twiddle, NULL,
		{
			"Don't show tildes after end of file",
			"Show tildes after end of file",
			NULL
		}
	},
	{ '?', &query_optname,
		NOVAR, 0, NULL, opt_query,
		{ NULL, NULL, NULL }
	},
	{ '#', &pound_optname,
		NUMBER, 0, &shift_count, NULL,
		{
			"Horizontal shift: ",
			"Horizontal shift %d positions",
			NULL
		}
	},
	{ '.', &keypad_optname,
		BOOL|NO_TOGGLE, OPT_OFF, &no_keypad, NULL,
		{
			"Use keypad mode",
			"Don't use keypad mode",
			NULL
		}
d231 4
a234 1
	{ '\0', NULL, NOVAR, 0, NULL, NULL, { NULL, NULL, NULL } }
d244 1
a244 1
	register struct loption *o;
a252 2
		if (o->otype & INIT_HANDLER)
			(*(o->ofunc))(INIT, (char *) NULL);
d257 1
a257 1
 * Find an option in the option table, given its option letter.
d259 1
a259 1
	public struct loption *
d263 1
a263 1
	register struct loption *o;
a272 104
}

/*
 *
 */
	static int
is_optchar(c)
	char c;
{
	if (SIMPLE_IS_UPPER(c))
		return 1;
	if (SIMPLE_IS_LOWER(c))
		return 1;
	if (c == '-')
		return 1;
	return 0;
}

/*
 * Find an option in the option table, given its option name.
 * p_optname is the (possibly partial) name to look for, and
 * is updated to point after the matched name.
 * p_oname if non-NULL is set to point to the full option name.
 */
	public struct loption *
findopt_name(p_optname, p_oname, p_err)
	char **p_optname;
	char **p_oname;
	int *p_err;
{
	char *optname = *p_optname;
	register struct loption *o;
	register struct optname *oname;
	register int len;
	int uppercase;
	struct loption *maxo = NULL;
	struct optname *maxoname = NULL;
	int maxlen = 0;
	int ambig = 0;
	int exact = 0;
	char *eq;

	/*
	 * Check all options.
	 */
	for (o = option;  o->oletter != '\0';  o++)
	{
		/*
		 * Check all names for this option.
		 */
		for (oname = o->onames;  oname != NULL;  oname = oname->onext)
		{
			/* 
			 * Try normal match first (uppercase == 0),
			 * then, then if it's a TRIPLE option,
			 * try uppercase match (uppercase == 1).
			 */
			for (uppercase = 0;  uppercase <= 1;  uppercase++)
			{
				len = sprefix(optname, oname->oname, uppercase);
				if (len <= 0 || is_optchar(optname[len]))
				{
					/*
					 * We didn't use all of the option name.
					 */
					continue;
				}
				if (!exact && len == maxlen)
					/*
					 * Already had a partial match,
					 * and now there's another one that
					 * matches the same length.
					 */
					ambig = 1;
				else if (len > maxlen)
				{
					/*
					 * Found a better match than
					 * the one we had.
					 */
					maxo = o;
					maxoname = oname;
					maxlen = len;
					ambig = 0;
					exact = (len == (int)strlen(oname->oname));
				}
				if (!(o->otype & TRIPLE))
					break;
			}
		}
	}
	if (ambig)
	{
		/*
		 * Name matched more than one option.
		 */
		if (p_err != NULL)
			*p_err = OPT_AMBIG;
		return (NULL);
	}
	*p_optname = optname + maxlen;
	if (p_oname != NULL)
		*p_oname = maxoname == NULL ? NULL : maxoname->oname;
	return (maxo);
@


1.1.1.3
log
@Import of Less 444

ok nicm@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2011  Mark Nudelman
a42 2
public long jump_sline_fraction = -1;
public long shift_count_fraction = -1;
a50 3
public int quit_on_intr;	/* Quit on interrupt */
public int follow_mode;		/* F cmd Follows file desc or file name? */
public int oldbot;		/* Old bottom of screen behavior {{REMOVE}} */
a54 2
public int less_is_more = 0;	/* Make compatible with POSIX more */

a78 1
static struct optname K__optname     = { "quit-on-intr",         NULL };
a108 2
static struct optname oldbot_optname = { "old-bot",              NULL };
static struct optname follow_optname = { "follow-name",          NULL };
d126 1
a126 1
		TRIPLE, OPT_ONPLUS, &how_search, NULL,
d130 1
a130 1
			"Search includes all of displayed screen"
d154 1
a154 1
			"Repaint by painting from top of screen",
d227 1
a227 1
		STRING, 0, NULL, opt_j,
d230 1
a230 1
			"0123456789.-",
d248 3
a250 7
	{ 'K', &K__optname,
		BOOL, OPT_OFF, &quit_on_intr, NULL,
		{
			"Interrupt (ctrl-C) returns to prompt",
			"Interrupt (ctrl-C) exits less",
			NULL
		}
d405 1
a405 1
		STRING, 0, NULL, opt_shift,
d408 1
a408 1
			"0123456789.",
d412 1
a412 1
	{ OLETTER_NONE, &keypad_optname,
a419 16
	{ OLETTER_NONE, &oldbot_optname,
		BOOL, OPT_OFF, &oldbot, NULL,
		{
			"Use new bottom of screen behavior",
			"Use old bottom of screen behavior",
			NULL
		}
	},
	{ OLETTER_NONE, &follow_optname,
		BOOL, FOLLOW_DESC, &follow_mode, NULL,
		{
			"F command follows file descriptor",
			"F command follows file name",
			NULL
		}
	},
a430 5
	char *p;

	p = lgetenv("LESS_IS_MORE");
	if (p != NULL && *p != '\0')
		less_is_more = 1;
d457 1
a457 1
		if ((o->otype & TRIPLE) && ASCII_TO_UPPER(o->oletter) == c)
d470 1
a470 1
	if (ASCII_IS_UPPER(c))
d472 1
a472 1
	if (ASCII_IS_LOWER(c))
d501 1
@


1.1.1.4
log
@Import of Less 458

ok guenther@@
@
text
@d2 1
a2 1
 * Copyright (C) 1984-2012  Mark Nudelman
d7 2
a8 1
 * For more information, see the README file.
a31 1
public int be_helpful;		/* more(1) style -d */
a55 1
public int opt_use_backslash;	/* Use backslash escaping in option parsing */
a64 1
#if GNU_OPTIONS
a118 59
static struct optname use_backslash_optname = { "use-backslash", NULL };
#else
static struct optname fake_optname   = { "fake",                 NULL };
#define a_optname	fake_optname
#define b_optname	fake_optname
#define B__optname	fake_optname
#define c_optname	fake_optname
#define d_optname	fake_optname
#if MSDOS_COMPILER
#define D__optname	fake_optname
#endif
#define e_optname	fake_optname
#define f_optname	fake_optname
#define F__optname	fake_optname
#if HILITE_SEARCH
#define g_optname	fake_optname
#endif
#define h_optname	fake_optname
#define i_optname	fake_optname
#define j_optname	fake_optname
#define J__optname	fake_optname
#if USERFILE
#define k_optname	fake_optname
#endif
#define K__optname	fake_optname
#define L__optname	fake_optname
#define m_optname	fake_optname
#define n_optname	fake_optname
#if LOGFILE
#define o_optname	fake_optname
#define O__optname	fake_optname
#endif
#define p_optname	fake_optname
#define P__optname	fake_optname
#define q2_optname	fake_optname
#define q_optname	fake_optname
#define r_optname	fake_optname
#define s_optname	fake_optname
#define S__optname	fake_optname
#if TAGS
#define t_optname	fake_optname
#define T__optname	fake_optname
#endif
#define u_optname	fake_optname
#define V__optname	fake_optname
#define w_optname	fake_optname
#define x_optname	fake_optname
#define X__optname	fake_optname
#define y_optname	fake_optname
#define z_optname	fake_optname
#define quote_optname	fake_optname
#define tilde_optname	fake_optname
#define query_optname	fake_optname
#define pound_optname	fake_optname
#define keypad_optname	fake_optname
#define oldbot_optname	fake_optname
#define follow_optname	fake_optname
#define use_backslash_optname	fake_optname
#endif
d161 1
a161 1
		TRIPLE, OPT_ON, &top_scroll, NULL,
a449 8
	{ OLETTER_NONE, &use_backslash_optname,
		BOOL, OPT_OFF, &opt_use_backslash, NULL,
		{
			"Use backslash escaping in command line parameters",
			"Don't use backslash escaping in command line parameters",
			NULL
		}
	},
a469 15
		 * Replace less's -d option if invoked as more
		 */
		if (less_is_more && o->oletter == 'd')
		{
			o->onames = NULL;
			o->otype = BOOL;
			o->odefault = OPT_OFF;
			o->ovar = &be_helpful;
			o->ofunc = NULL;
			o->odesc[0] = "Be less helpful in prompts";
			o->odesc[1] = "Be helpful in prompts";
			o->odesc[2] = NULL;
		}

		/*
a513 1
#if GNU_OPTIONS
a599 1
#endif
@


