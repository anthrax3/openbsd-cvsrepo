head	1.31;
access;
symbols
	OPENBSD_5_3:1.29.0.12
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.10
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.8
	OPENBSD_5_0:1.29.0.6
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.4
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.24.0.6
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.4
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.23.0.12
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.10
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.8
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.6
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.4
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2013.07.05.21.38.37;	author miod;	state dead;
branches;
next	1.30;

1.30
date	2013.03.21.19.53.32;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2010.06.01.21.44.39;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2010.05.24.23.42.39;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2010.05.24.20.07.07;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.27.23.59.44;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.19.09.40.43;	author sobrado;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.02.15.19.34;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.10.09.20.36.05;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.12.10.44.11;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.31.21.22.06;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.10.22.20.52;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.03.02.56.17;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.21.15.53.12;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.21.15.51.08;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.16.21.27.53;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.18.17.17.39;	author pvalchev;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.12.10.15.38;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.30.16.00.20;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.05.10.16.14.07;	author espie;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	98.05.11.07.41.25;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.09.11.11.21.54;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.04.03.19.33.50;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.02.09.16.37.13;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.43.15;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.01.14.10.33.00;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.09.03.11.08.00;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.09.03.06.54.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.39.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.09;	author deraadt;	state Exp;
branches;
next	;

1.11.4.1
date	2000.10.06.21.16.16;	author jason;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Remove usr.bin/strip and usr.bin/strings, no longer built.
@
text
@/*	$OpenBSD: strip.c,v 1.30 2013/03/21 19:53:32 deraadt Exp $	*/

/*
 * Copyright (c) 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <errno.h>
#include <a.out.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <err.h>
#include <ranlib.h>
#include "byte.c"

#ifdef MID_MACHINE_OVERRIDE
#undef MID_MACHINE
#define MID_MACHINE MID_MACHINE_OVERRIDE
#if MID_MACHINE_OVERRIDE == MID_M68K
#undef __LDPGSZ
#undef ELF_TARG_DATA
#undef ELF_TARG_MACH
#include "m68k/exec.h"
#elif MID_MACHINE_OVERRIDE == MID_M88K
#undef __LDPGSZ
#undef ELF_TARG_DATA
#undef ELF_TARG_MACH
#include "m88k/exec.h"
#endif
#endif

typedef struct exec EXEC;
typedef struct nlist NLIST;

#define	strx	n_un.n_strx

int s_stab(const char *, int, EXEC *, struct stat *, off_t *);
int s_sym(const char *, int, EXEC *, struct stat *, off_t *);
void usage(void);

int xflag = 0;

int
main(int argc, char *argv[])
{
	int fd;
	EXEC *ep;
	struct stat sb;
	int (*sfcn)(const char *, int, EXEC *, struct stat *, off_t *);
	int ch, errors;
	char *fn, *ofile = NULL;
	off_t newsize;

	sfcn = s_sym;
	while ((ch = getopt(argc, argv, "dgsxo:")) != -1)
		switch(ch) {
		case 'x':
			xflag = 1;
			/*FALLTHROUGH*/
		case 'g':
		case 'd':
			sfcn = s_stab;
			break;
		case 's':
			/* reset back to the defaults */
			xflag = 0;
			sfcn = s_sym;
			break;
		case 'o':
			ofile = optarg;
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (ofile != NULL && argc > 1)
		usage();
	errors = 0;
#define	ERROR(x) errors |= 1; warnx("%s: %s", fn, strerror(x)); continue;
	while ((fn = *argv++)) {
		if (ofile) {
			char buf[8192];
			ssize_t wn;
			size_t rn;
			off_t off;
			int wfd;

			if ((fd = open(fn, O_RDONLY)) < 0) {
				ERROR(errno);
				break;
			}
			if ((wfd = open(ofile, O_RDWR|O_CREAT)) < 0) {
				ERROR(errno);
				break;
			}
			do {
				rn = read(fd, buf, sizeof buf);
				if (rn == (ssize_t)-1) {
					int save_errno = errno;

					unlink(ofile);
					ERROR(save_errno);
					exit(errors);
				}
				if (rn == 0)
					break;

				off = 0;
				while (rn - off > 0) {
					wn = write(wfd, buf + off, rn - off);
					if (wn == (ssize_t)-1) {
						int save_errno = errno;

						unlink(ofile);
						ERROR(save_errno);
						exit(errors);
					}
					off += wn;
				}
			} while (rn > 0);

			fn = ofile;
			close(fd);
			fd = wfd;
		} else if ((fd = open(fn, O_RDWR)) < 0) {
			ERROR(errno);
		}
		if (fstat(fd, &sb)) {
			(void)close(fd);
			ERROR(errno);
		}
		if (sb.st_size < sizeof(EXEC)) {
			(void)close(fd);
			ERROR(EFTYPE);
		}
		if ((ep = (EXEC *)mmap(NULL, sb.st_size, PROT_READ|PROT_WRITE,
		    MAP_SHARED, fd, (off_t)0)) == MAP_FAILED) {
			(void)close(fd);
			ERROR(errno);
		}
		if (BAD_OBJECT(*ep)) {
			munmap((caddr_t)ep, sb.st_size);
			(void)close(fd);
			ERROR(EFTYPE);
		}
		/*
		 * Since we're dealing with an mmap there, we have to convert
		 * once for dealing with data in memory, and a second time
		 * for out.
		 */
		fix_header_order(ep);
		newsize = 0;
		errors |= sfcn(fn, fd, ep, &sb, &newsize);
		fix_header_order(ep);
		munmap((caddr_t)ep, sb.st_size);
		if (newsize  && ftruncate(fd, newsize)) {
			warn("%s", fn);
			errors = 1;
		}
		if (close(fd)) {
			ERROR(errno);
		}
	}
#undef ERROR
	exit(errors);
}

int
s_sym(const char *fn, int fd, EXEC *ep, struct stat *sp, off_t *sz)
{
	char *neweof;
#if	0
	char *mineof;
#endif
	int zmagic;

	zmagic = ep->a_data &&
		 (N_GETMAGIC(*ep) == ZMAGIC || N_GETMAGIC(*ep) == QMAGIC);

	/*
	 * If no symbols or data/text relocation info and
	 * the file data segment size is already minimized, quit.
	 */
	if (!ep->a_syms && !ep->a_trsize && !ep->a_drsize) {
#if 0
		if (!zmagic)
			return 0;
		if (sp->st_size < N_TRELOFF(*ep))
#endif
			return 0;
	}

	/*
	 * New file size is the header plus text and data segments; OMAGIC
	 * and NMAGIC formats have the text/data immediately following the
	 * header.  ZMAGIC format wastes the rest of of header page.
	 */
	neweof = (char *)ep + N_TRELOFF(*ep);

#if 0
	/*
	 * Unfortunately, this can't work correctly without changing the way
	 * the loader works.  We could cap it at one page, or even fiddle with
	 * a_data and a_bss, but this only works for CLBYTES == PAGE_SIZE.  If
	 * we are on a system where, e.g., CLBYTES is 8k and PAGE_SIZE is 4k,
	 * and we happen to remove 4.5k, we will lose.  And we really don't want
	 * to fiddle with pages, because that breaks binary compatibility.  Lose.
	 */

	if (zmagic) {
		/*
		 * Get rid of unneeded zeroes at the end of the data segment
		 * to reduce the file size even more.
		 */
		mineof = (char *)ep + N_DATOFF(*ep);
		while (neweof > mineof && neweof[-1] == '\0')
			neweof--;
	}
#endif

	/* Set symbol size and relocation info values to 0. */
	ep->a_syms = ep->a_trsize = ep->a_drsize = 0;

	/* Truncate the file. */
	*sz = neweof - (char *)ep;

	return 0;
}

int
s_stab(const char *fn, int fd, EXEC *ep, struct stat *sp, off_t *sz)
{
	int cnt, len;
	char *nstr, *nstrbase=0, *used=0, *p, *strbase;
	NLIST *sym, *nsym;
	u_long allocsize;
	int mid;
	NLIST *symbase;
	unsigned int *mapping=0;
	int error=1;
	unsigned int nsyms;
	struct relocation_info *reloc_base;
	unsigned int i, j;

	/* Quit if no symbols. */
	if (ep->a_syms == 0)
		return 0;

	if (N_SYMOFF(*ep) >= sp->st_size) {
		warnx("%s: bad symbol table", fn);
		return 1;
	}

	mid = N_GETMID(*ep);

	/*
	 * Initialize old and new symbol pointers.  They both point to the
	 * beginning of the symbol table in memory, since we're deleting
	 * entries.
	 */
	sym = nsym = symbase = (NLIST *)((char *)ep + N_SYMOFF(*ep));

	/*
	 * Allocate space for the new string table, initialize old and
	 * new string pointers.  Handle the extra long at the beginning
	 * of the string table.
	 */
	strbase = (char *)ep + N_STROFF(*ep);
	allocsize = fix_32_order(*(u_long *)strbase, mid);
	if ((nstrbase = malloc((u_int) allocsize)) == NULL) {
		warnx("%s", strerror(ENOMEM));
		goto end;
	}
	nstr = nstrbase + sizeof(u_long);

	/* okay, so we also need to keep symbol numbers for relocations. */
	nsyms = ep->a_syms/ sizeof(NLIST);
	used = calloc(nsyms, 1);
	if (!used) {
		warnx("%s", strerror(ENOMEM));
		goto end;
	}
	mapping = calloc(nsyms, sizeof(unsigned int));
	if (!mapping) {
		warnx("%s", strerror(ENOMEM));
		goto end;
	}

	if ((ep->a_trsize || ep->a_drsize) && byte_sex(mid) != BYTE_ORDER) {
		warnx("%s: cross-stripping not supported", fn);
		goto end;
	}

	/* first check the relocations for used symbols, and mark them */
	/* text */
	reloc_base = (struct relocation_info *) ((char *)ep + N_TRELOFF(*ep));
	if (N_TRELOFF(*ep) + ep->a_trsize > sp->st_size) {
		warnx("%s: bad text relocation", fn);
		goto end;
	}
	for (i = 0; i < ep->a_trsize / sizeof(struct relocation_info); i++) {
		if (!reloc_base[i].r_extern)
			continue;
		if (reloc_base[i].r_symbolnum > nsyms) {
			warnx("%s: bad symbol number in text relocation", fn);
			goto end;
		}
		used[reloc_base[i].r_symbolnum] = 1;
	}
	/* data */
	reloc_base = (struct relocation_info *) ((char *)ep + N_DRELOFF(*ep));
	if (N_DRELOFF(*ep) + ep->a_drsize > sp->st_size) {
		warnx("%s: bad data relocation", fn);
		goto end;
	}
	for (i = 0; i < ep->a_drsize / sizeof(struct relocation_info); i++) {
		if (!reloc_base[i].r_extern)
			continue;
		if (reloc_base[i].r_symbolnum > nsyms) {
			warnx("%s: bad symbol number in data relocation", fn);
			goto end;
		}
		used[reloc_base[i].r_symbolnum] = 1;
	}

	/*
	 * Read through the symbol table.  For each non-debugging symbol,
	 * copy it and save its string in the new string table.  Keep
	 * track of the number of symbols.
	 */
	for (cnt = nsyms, i = 0, j = 0; cnt--; ++sym, ++i) {
		fix_nlist_order(sym, mid);
		if (!(sym->n_type & N_STAB) && sym->strx) {
			*nsym = *sym;
			nsym->strx = nstr - nstrbase;
			p = strbase + sym->strx;
			if (xflag && !used[i] &&
			    (!(sym->n_type & N_EXT) ||
			     (sym->n_type & ~N_EXT) == N_FN ||
			     strcmp(p, "gcc_compiled.") == 0 ||
			     strcmp(p, "gcc2_compiled.") == 0 ||
			     strncmp(p, "___gnu_compiled_", 16) == 0)) {
				continue;
			}
			len = strlen(p) + 1;
			mapping[i] = j++;
			if (N_STROFF(*ep) + sym->strx + len > sp->st_size) {
				warnx("%s: bad symbol table", fn);
				goto end;
			}
			bcopy(p, nstr, len);
			nstr += len;
			fix_nlist_order(nsym++, mid);
		}
	}

	/* renumber symbol relocations */
	/* text */
	reloc_base = (struct relocation_info *) ((char *)ep + N_TRELOFF(*ep));
	for (i = 0; i < ep->a_trsize / sizeof(struct relocation_info); i++) {
		if (!reloc_base[i].r_extern)
			continue;
		reloc_base[i].r_symbolnum = mapping[reloc_base[i].r_symbolnum];
	}
	/* data */
	reloc_base = (struct relocation_info *) ((char *)ep + N_DRELOFF(*ep));
	for (i = 0; i < ep->a_drsize / sizeof(struct relocation_info); i++) {
		if (!reloc_base[i].r_extern)
			continue;
		reloc_base[i].r_symbolnum = mapping[reloc_base[i].r_symbolnum];
	}

	/* Fill in new symbol table size. */
	ep->a_syms = (nsym - symbase) * sizeof(NLIST);

	/* Fill in the new size of the string table. */
	len = nstr - nstrbase;
	*(u_long *)nstrbase = fix_32_order(len, mid);

	/*
	 * Copy the new string table into place.  Nsym should be pointing
	 * at the address past the last symbol entry.
	 */
	bcopy(nstrbase, (void *)nsym, len);
	error = 0;
end:
	free(nstrbase);
	free(used);
	free(mapping);

	/* Truncate to the current length. */
	*sz = (char *)nsym + len - (char *)ep;

	return error;
}

void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-dgsx] [-o outfile] file ...\n",
	    __progname);
	exit(1);
}

@


1.30
log
@In a comment, talk about PAGE_SIZE instead of NBPG
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.29 2010/06/01 21:44:39 deraadt Exp $	*/
@


1.29
log
@Add compatibility interfaces for new names binutils-based strip(1) prefers
for some of it's options
ok miod kettenis drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.28 2010/05/24 23:42:39 jmc Exp $	*/
d238 4
a241 4
	 * a_data and a_bss, but this only works for CLBYTES == NBPG.  If we
	 * are on a system where, e.g., CLBYTES is 8k and NBPG is 4k, and we
	 * happen to remove 4.5k, we will lose.  And we really don't want to
	 * fiddle with pages, because that breaks binary compatibility.  Lose.
@


1.28
log
@- note -o as an extension
- sync usage() and synopsis
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.27 2010/05/24 20:07:07 deraadt Exp $	*/
d86 1
a86 1
	while ((ch = getopt(argc, argv, "dxo:")) != -1)
d91 1
d95 5
d436 2
a437 1
	fprintf(stderr, "usage: %s [-dx] [-o outfile] file ...\n", __progname);
@


1.27
log
@Support the -o operation in the non-binutils version, since some
architectures still use this (debug kernel builds want to have it).
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.26 2009/10/27 23:59:44 deraadt Exp $	*/
d430 1
a430 1
	fprintf(stderr, "usage: %s [-dx] [-o ofile] file ...\n", __progname);
@


1.26
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.25 2009/06/19 09:40:43 sobrado Exp $	*/
d73 1
a73 1
        
d82 1
a82 1
	char *fn;
d86 1
a86 1
	while ((ch = getopt(argc, argv, "dx")) != -1)
d88 3
a90 3
                case 'x':
                        xflag = 1;
                        /*FALLTHROUGH*/
d94 3
d104 2
d109 45
a153 1
		if ((fd = open(fn, O_RDWR)) < 0) {
d156 1
a156 1
        	if (fstat(fd, &sb)) {
d365 8
a372 8
                        if (xflag && !used[i] &&
                            (!(sym->n_type & N_EXT) ||
                             (sym->n_type & ~N_EXT) == N_FN ||
                             strcmp(p, "gcc_compiled.") == 0 ||
                             strcmp(p, "gcc2_compiled.") == 0 ||
                             strncmp(p, "___gnu_compiled_", 16) == 0)) {
                                continue;
                        }
d430 1
a430 1
	fprintf(stderr, "usage: %s [-dx] file ...\n", __progname);
@


1.25
log
@format comment so source code fits on a 80-column display.
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.24 2007/09/02 15:19:34 deraadt Exp $	*/
a30 11

#ifndef lint
char copyright[] =
"@@(#) Copyright (c) 1988 Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "from: @@(#)strip.c	5.8 (Berkeley) 11/6/91";*/
static char rcsid[] = "$OpenBSD: strip.c,v 1.24 2007/09/02 15:19:34 deraadt Exp $";
#endif /* not lint */
@


1.24
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.23 2004/10/09 20:36:05 mickey Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.23 2004/10/09 20:36:05 mickey Exp $";
d136 4
a139 2
		/* since we're dealing with an mmap there, we have to convert once
		   for dealing with data in memory, and a second time for out
@


1.23
log
@s/fix_long_order/fix_32_order
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.22 2004/07/12 10:44:11 miod Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.22 2004/07/12 10:44:11 miod Exp $";
d271 1
a271 1
	mapping = malloc(nsyms * sizeof(unsigned int));
@


1.22
log
@m88k cross-compile goo.
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.21 2004/03/31 21:22:06 mickey Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.21 2004/03/31 21:22:06 mickey Exp $";
d257 1
a257 1
	allocsize = fix_long_order(*(u_long *)strbase, mid);
d366 1
a366 1
	*(u_long *)nstrbase = fix_long_order(len, mid);
@


1.21
log
@allow cross-compiling for m68k and better usage(); miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.20 2003/06/10 22:20:52 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.20 2003/06/10 22:20:52 deraadt Exp $";
d66 5
@


1.20
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.19 2003/06/03 02:56:17 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.19 2003/06/03 02:56:17 millert Exp $";
d61 6
d383 3
a385 1
	(void)fprintf(stderr, "usage: strip [-dx] file ...\n");
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.18 2002/08/21 15:53:12 espie Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.18 2002/08/21 15:53:12 espie Exp $";
d75 1
a75 3
main(argc, argv)
	int argc;
	char *argv[];
d146 1
a146 6
s_sym(fn, fd, ep, sp, sz)
	const char *fn;
	int fd;
	EXEC *ep;
	struct stat *sp;
	off_t *sz;
d208 1
a208 6
s_stab(fn, fd, ep, sp, sz)
	const char *fn;
	int fd;
	EXEC *ep;
	struct stat *sp;
	off_t *sz;
d375 1
a375 1
usage()
@


1.18
log
@Working strip -x support.

Since we keep relocations, we need to ensure that:
1/ symbols used by relocations are actually kept,
2/ refs to ext symbols in relocations are correctly renumbered after
killing some symbols.

okay art@@ (can't break things further than they were broken anyways).

Thanks to Laurent Bercot (ska@@quatramaran.ens.fr) for pointing out that
strip -x was broken.
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.16 2002/02/16 21:27:53 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.16 2002/02/16 21:27:53 millert Exp $";
@


1.17
log
@Postpone ftruncate after unmap. Works around a bug in non-ubc memory
handling.
Also, avoids dumping core on badly formed object.

ok millert@@, miod@@, art@@
@
text
@d227 1
a227 1
	char *nstr, *nstrbase, *p, *strbase;
d232 5
d265 1
a265 1
		return 1;
d269 50
d324 1
a324 1
	for (cnt = ep->a_syms / sizeof(NLIST); cnt--; ++sym) {
d330 1
a330 1
                        if (xflag && 
d339 1
d342 1
a342 1
				return 1;
d350 16
d378 2
d381 2
d387 1
a387 1
	return 0;
@


1.16
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.15 2001/11/19 19:02:16 mpech Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.15 2001/11/19 19:02:16 mpech Exp $";
d72 2
a73 2
int s_stab(const char *, int, EXEC *, struct stat *);
int s_sym(const char *, int, EXEC *, struct stat *);
d86 1
a86 1
	int (*sfcn)(const char *, int, EXEC *, struct stat *);
d89 1
d135 2
a136 1
		errors |= sfcn(fn, fd, ep, &sb);
d139 4
d152 1
a152 1
s_sym(fn, fd, ep, sp)
d157 1
d213 1
a213 4
	if (ftruncate(fd, neweof - (char *)ep)) {
		warn("%s", fn);
		return 1;
	}
d219 1
a219 1
s_stab(fn, fd, ep, sp)
d224 1
d284 4
d309 1
a309 4
	if (ftruncate(fd, (char *)nsym + len - (char *)ep)) {
		warn("%s", fn);
		return 1;
	}
@


1.15
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.14 2001/07/18 17:17:39 pvalchev Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.14 2001/07/18 17:17:39 pvalchev Exp $";
d72 3
a74 3
int s_stab __P((const char *, int, EXEC *, struct stat *));
int s_sym __P((const char *, int, EXEC *, struct stat *));
void usage __P((void));
d86 1
a86 1
	int (*sfcn)__P((const char *, int, EXEC *, struct stat *));
@


1.14
log
@-Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.13 2000/10/12 10:15:38 art Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.13 2000/10/12 10:15:38 art Exp $";
d83 1
a83 1
	register int fd;
d149 1
a149 1
	register EXEC *ep;
d152 1
a152 1
	register char *neweof;
d154 1
a154 1
	register char *mineof;
d221 3
a223 3
	register int cnt, len;
	register char *nstr, *nstrbase, *p, *strbase;
	register NLIST *sym, *nsym;
@


1.13
log
@Check for MAP_FAILED in mmap return value, not -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.12 2000/06/30 16:00:20 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.12 2000/06/30 16:00:20 millert Exp $";
d152 4
a155 1
	register char *neweof, *mineof;
d221 1
a221 1
	register int cnt, len, nsymcnt;
@


1.12
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.11 1999/05/10 16:14:07 espie Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.11 1999/05/10 16:14:07 espie Exp $";
d121 1
a121 1
		    MAP_SHARED, fd, (off_t)0)) == (EXEC *)-1) {
@


1.11
log
@Fixes endianess problems with old a.out tools. This makes building
some cross toolchains possible.

This also changes some utilities's behavior slightly:
- nm, strip, size now handle any a.out format they know about.
- ranlib complains if it detects mixed archives (several object
formats for different boxes).

In the presence of mixed objects, you still have file, ranlib or ld
to prevent you from getting too confused...
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.10 1998/05/11 07:41:25 niklas Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.10 1998/05/11 07:41:25 niklas Exp $";
d204 1
a204 1
		warn(fn);
d298 1
a298 1
		warn(fn);
@


1.11.4.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.12 2000/06/30 16:00:20 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.12 2000/06/30 16:00:20 millert Exp $";
d204 1
a204 1
		warn("%s", fn);
d298 1
a298 1
		warn("%s", fn);
@


1.10
log
@Support building for cross purposes
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.9 1997/09/11 11:21:54 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.9 1997/09/11 11:21:54 deraadt Exp $";
d59 2
d125 1
a125 6
#if (MID_MACHINE == MID_M68K)
		if (N_BADMAG(*ep) || ((N_GETMID(*ep) != MID_MACHINE) &&
		    (N_GETMID(*ep) != MID_M68K4K))) {
#else
		if (N_BADMAG(*ep) || N_GETMID(*ep) != MID_MACHINE) {
#endif
d130 4
d135 1
d221 2
d234 2
d249 2
a250 1
	if ((nstrbase = malloc((u_int)*(u_long *)strbase)) == NULL) {
d261 2
a262 1
	for (cnt = ep->a_syms / sizeof(NLIST); cnt--; ++sym)
d278 1
a278 1
			++nsym;
d280 1
d286 2
a287 1
	*(u_long *)nstrbase = len = nstr - nstrbase;
@


1.9
log
@cleanup -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.8 1997/04/03 19:33:50 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.8 1997/04/03 19:33:50 mickey Exp $";
d59 5
@


1.8
log
@fix my last fix. warnx, not warn!
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.7 1997/02/09 16:37:13 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.7 1997/02/09 16:37:13 mickey Exp $";
d71 1
d76 1
a76 1
	register int fd, nb;
d101 1
a101 1
	while (fn = *argv++) {
@


1.7
log
@use library err/warn
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.6 1997/01/15 23:43:15 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.6 1997/01/15 23:43:15 millert Exp $";
d99 1
a99 1
#define	ERROR(x) errors |= 1; warn(fn); continue;
@


1.6
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.5 1997/01/14 10:33:00 downsj Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.5 1997/01/14 10:33:00 downsj Exp $";
d58 1
a64 1
void err __P((const char *fmt, ...));
d99 1
a99 1
#define	ERROR(x) errors |= 1; err("%s: %s", fn, strerror(x)); continue;
d196 1
a196 1
		err("%s: %s", fn, strerror(errno));
d220 1
a220 1
		err("%s: bad symbol table", fn);
d238 1
a238 1
		err("%s", strerror(ENOMEM));
d282 1
a282 1
		err("%s: %s", fn, strerror(errno));
a295 26
#if __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

void
#if __STDC__
err(const char *fmt, ...)
#else
err(fmt, va_alist)
	char *fmt;
        va_dcl
#endif
{
	va_list ap;
#if __STDC__
	va_start(ap, fmt);
#else
	va_start(ap);
#endif
	(void)fprintf(stderr, "strip: ");
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
}
@


1.5
log
@hack: if we're M68K, also allow us to strip M68K4K.  Works for me.
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.4 1996/09/03 11:08:00 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.4 1996/09/03 11:08:00 deraadt Exp $";
d83 1
a83 1
	while ((ch = getopt(argc, argv, "dx")) != EOF)
@


1.4
log
@need param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.3 1996/09/03 06:54:43 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.3 1996/09/03 06:54:43 deraadt Exp $";
d117 4
d122 1
@


1.3
log
@check mid of exec too
@
text
@d1 1
a1 1
/*	$OpenBSD: strip.c,v 1.2 1996/06/26 05:39:32 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.2 1996/06/26 05:39:32 deraadt Exp $";
d47 1
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: strip.c,v 1.1.1.1 1995/10/18 08:46:09 deraadt Exp $";
d116 1
a116 1
		if (N_BADMAG(*ep)) {
@


1.1
log
@Initial revision
@
text
@d1 2
d44 1
a44 1
static char rcsid[] = "$Id: strip.c,v 1.13 1994/03/28 02:17:50 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
