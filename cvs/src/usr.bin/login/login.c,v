head	1.68;
access;
symbols
	OPENBSD_6_0:1.67.0.4
	OPENBSD_6_0_BASE:1.67
	OPENBSD_5_9:1.67.0.2
	OPENBSD_5_9_BASE:1.67
	OPENBSD_5_8:1.64.0.4
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.61.0.20
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.61.0.16
	OPENBSD_5_4_BASE:1.61
	OPENBSD_5_3:1.61.0.14
	OPENBSD_5_3_BASE:1.61
	OPENBSD_5_2:1.61.0.12
	OPENBSD_5_2_BASE:1.61
	OPENBSD_5_1_BASE:1.61
	OPENBSD_5_1:1.61.0.10
	OPENBSD_5_0:1.61.0.8
	OPENBSD_5_0_BASE:1.61
	OPENBSD_4_9:1.61.0.6
	OPENBSD_4_9_BASE:1.61
	OPENBSD_4_8:1.61.0.4
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.61.0.2
	OPENBSD_4_7_BASE:1.61
	OPENBSD_4_6:1.57.0.12
	OPENBSD_4_6_BASE:1.57
	OPENBSD_4_5:1.57.0.8
	OPENBSD_4_5_BASE:1.57
	OPENBSD_4_4:1.57.0.6
	OPENBSD_4_4_BASE:1.57
	OPENBSD_4_3:1.57.0.4
	OPENBSD_4_3_BASE:1.57
	OPENBSD_4_2:1.57.0.2
	OPENBSD_4_2_BASE:1.57
	OPENBSD_4_1:1.55.0.12
	OPENBSD_4_1_BASE:1.55
	OPENBSD_4_0:1.55.0.10
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.55.0.8
	OPENBSD_3_9_BASE:1.55
	OPENBSD_3_8:1.55.0.6
	OPENBSD_3_8_BASE:1.55
	OPENBSD_3_7:1.55.0.4
	OPENBSD_3_7_BASE:1.55
	OPENBSD_3_6:1.55.0.2
	OPENBSD_3_6_BASE:1.55
	OPENBSD_3_5:1.54.0.2
	OPENBSD_3_5_BASE:1.54
	OPENBSD_3_4:1.51.0.2
	OPENBSD_3_4_BASE:1.51
	OPENBSD_3_3:1.49.0.2
	OPENBSD_3_3_BASE:1.49
	OPENBSD_3_2:1.48.0.2
	OPENBSD_3_2_BASE:1.48
	OPENBSD_3_1:1.46.0.2
	OPENBSD_3_1_BASE:1.46
	OPENBSD_3_0:1.43.0.2
	OPENBSD_3_0_BASE:1.43
	OPENBSD_2_9_BASE:1.35
	OPENBSD_2_9:1.35.0.4
	OPENBSD_2_8:1.35.0.2
	OPENBSD_2_8_BASE:1.35
	OPENBSD_2_7:1.28.0.2
	OPENBSD_2_7_BASE:1.28
	OPENBSD_2_6:1.27.0.2
	OPENBSD_2_6_BASE:1.27
	OPENBSD_2_5:1.26.0.4
	OPENBSD_2_5_BASE:1.26
	OPENBSD_2_4:1.26.0.2
	OPENBSD_2_4_BASE:1.26
	OPENBSD_2_3:1.24.0.2
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.22.0.2
	OPENBSD_2_2_BASE:1.22
	OPENBSD_2_1:1.20.0.2
	OPENBSD_2_1_BASE:1.20
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.68
date	2016.08.21.03.26.04;	author beck;	state Exp;
branches;
next	1.67;
commitid	ltGypVslryn275YV;

1.67
date	2015.12.26.20.51.35;	author guenther;	state Exp;
branches;
next	1.66;
commitid	ixyMcIFPirO2EXOW;

1.66
date	2015.12.09.19.26.26;	author mmcc;	state Exp;
branches;
next	1.65;
commitid	cT4Qz48kNT6iwjpi;

1.65
date	2015.10.26.15.29.17;	author zhuk;	state Exp;
branches;
next	1.64;
commitid	7mpuowCaX2hK6tDx;

1.64
date	2015.03.15.00.41.28;	author millert;	state Exp;
branches;
next	1.63;
commitid	IbVxlqGw2UipKdDr;

1.63
date	2015.01.16.06.40.09;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	Uu5nFG3wCl0LACBb;

1.62
date	2014.05.20.01.25.23;	author guenther;	state Exp;
branches;
next	1.61;

1.61
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2009.09.05.14.04.38;	author tobias;	state Exp;
branches;
next	1.59;

1.59
date	2009.08.31.22.25.43;	author martynas;	state Exp;
branches;
next	1.58;

1.58
date	2009.08.03.21.43.07;	author martynas;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.02.07.01.33;	author jmc;	state Exp;
branches;
next	1.56;

1.56
date	2007.03.26.14.29.37;	author jmc;	state Exp;
branches;
next	1.55;

1.55
date	2004.08.30.23.00.22;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.23.04.36.37;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.23.03.48.43;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2003.11.09.20.13.57;	author otto;	state Exp;
branches;
next	1.51;

1.51
date	2003.08.12.13.14.58;	author hin;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.03.02.56.10;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2002.10.16.01.08.56;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2002.07.02.01.36.19;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2002.07.02.01.15.08;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2002.03.30.18.16.05;	author vincent;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.16.21.27.48;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2002.01.06.21.59.15;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2001.08.12.02.45.33;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2001.07.09.07.04.49;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2001.07.06.18.12.06;	author pvalchev;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.28.22.49.42;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.25.16.18.37;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.24.17.12.52;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.19.16.21.49;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.29.21.39.26;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2000.10.14.20.33.13;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.15.07.13.48;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.04.19.15.27;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.24.20.08.06;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.24.20.05.07;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.20.18.42.39;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.17.16.43.14;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	99.12.30.01.07.23;	author ericj;	state Exp;
branches;
next	1.27;

1.27
date	99.08.17.09.13.15;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	98.07.13.02.11.36;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	98.07.05.20.30.46;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	98.03.26.20.28.11;	author art;	state Exp;
branches;
next	1.23;

1.23
date	97.11.04.19.01.05;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	97.06.20.04.55.00;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.06.02.03.08.55;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.04.19.21.01.12;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.02.16.04.39.07;	author downsj;	state Exp;
branches;
next	1.18;

1.18
date	97.02.04.03.39.11;	author flipk;	state Exp;
branches;
next	1.17;

1.17
date	97.01.27.20.44.14;	author dm;	state Exp;
branches;
next	1.16;

1.16
date	97.01.15.23.43.03;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	96.12.22.03.25.55;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	96.12.04.04.04.41;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	96.11.09.20.17.17;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	96.11.09.07.43.22;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	96.11.09.06.39.41;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	96.11.05.18.23.49;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.10.31.03.22.10;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.10.23.01.28.56;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.09.18.20.39.06;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.31.12.21.43;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.20.09.10.59;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.36.01;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.11.35.24;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.15.06.27.30;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.34;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.68
log
@Change sleep from crazy backoff to one second of sleep between retries
ok deraadt@@
@
text
@/*	$OpenBSD: login.c,v 1.67 2015/12/26 20:51:35 guenther Exp $	*/
/*	$NetBSD: login.c,v 1.13 1996/05/15 23:50:16 jtc Exp $	*/

/*-
 * Copyright (c) 1980, 1987, 1988, 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1995 Berkeley Software Design, Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Berkeley Software Design,
 *      Inc.
 * 4. The name of Berkeley Software Design, Inc.  may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BERKELEY SOFTWARE DESIGN, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL BERKELEY SOFTWARE DESIGN, INC. BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	BSDI $From: login.c,v 2.28 1999/09/08 22:35:36 prb Exp $
 */

/*
 * login [ name ]
 * login -h hostname	(for telnetd, etc.)
 * login -f name	(for pre-authenticated login: datakit, xterm, etc.)
 * login -p		(preserve existing environment; for getty)
 */

#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/wait.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <grp.h>
#include <login_cap.h>
#include <netdb.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <ttyent.h>
#include <unistd.h>
#include <limits.h>
#include <utmp.h>
#include <util.h>
#include <bsd_auth.h>

#include "pathnames.h"

void	 badlogin(char *);
void	 dolastlog(int);
void	 getloginname(void);
void	 motd(void);
void	 quickexit(int);
int	 rootterm(char *);
void	 sigint(int);
void	 sighup(int);
void	 sleepexit(int);
char	*stypeof(char *);
void	 timedout(int);
int	 main(int, char **);

extern int check_failedlogin(uid_t);
extern void log_failedlogin(uid_t, char *, char *, char *);

#define	TTYGRPNAME	"tty"		/* name of group to own ttys */

#define	SECSPERDAY	(24 * 60 * 60)
#define	TWOWEEKS	(2 * 7 * SECSPERDAY)

/*
 * This bounds the time given to login; may be overridden by /etc/login.conf.
 */
u_int		timeout = 300;

struct passwd	*pwd;
login_cap_t	*lc = NULL;
auth_session_t	*as = NULL;
int		failures;
int		needbanner = 1;
char		term[64], *hostname, *tty;
char		*style;
char		*username = NULL, *rusername = NULL;

extern char **environ;

int
main(int argc, char *argv[])
{
	char *domain, *p, *ttyn, *shell, *fullname, *instance;
	char *lipaddr, *script, *ripaddr, *style, *type, *fqdn;
	char tbuf[PATH_MAX + 2], tname[sizeof(_PATH_TTY) + 10];
	char localhost[HOST_NAME_MAX+1], *copyright;
	char mail[sizeof(_PATH_MAILDIR) + 1 + NAME_MAX];
	int ask, ch, cnt, fflag, pflag, quietlog, rootlogin, lastchance;
	int error, homeless, needto, authok, tries, backoff;
	struct addrinfo *ai, hints;
	struct rlimit cds, scds;
	quad_t expire, warning;
	struct utmp utmp;
	struct group *gr;
	struct stat st;
	uid_t uid;

	openlog("login", LOG_ODELAY, LOG_AUTH);

	fqdn = lipaddr = ripaddr = fullname = type = NULL;
	authok = 0;
	tries = 10;
	backoff = 3;

	domain = NULL;
	if (gethostname(localhost, sizeof(localhost)) < 0) {
		syslog(LOG_ERR, "couldn't get local hostname: %m");
		strlcpy(localhost, "localhost", sizeof(localhost));
	} else if ((domain = strchr(localhost, '.'))) {
		domain++;
		if (*domain && strchr(domain, '.') == NULL)
			domain = localhost;
	}

	if ((as = auth_open()) == NULL) {
		syslog(LOG_ERR, "auth_open: %m");
		err(1, "unable to initialize BSD authentication");
	}
	auth_setoption(as, "login", "yes");

	/*
	 * -p is used by getty to tell login not to destroy the environment
	 * -f is used to skip a second login authentication
	 * -h is used by other servers to pass the name of the remote
	 *    host to login so that it may be placed in utmp and wtmp
	 */
	fflag = pflag = 0;
	uid = getuid();
	while ((ch = getopt(argc, argv, "fh:pu:L:R:")) != -1)
		switch (ch) {
		case 'f':
			fflag = 1;
			break;
		case 'h':
			if (uid) {
				warnc(EPERM, "-h option");
				quickexit(1);
			}
			free(fqdn);
			if ((fqdn = strdup(optarg)) == NULL) {
				warn(NULL);
				quickexit(1);
			}
			auth_setoption(as, "fqdn", fqdn);
			if (domain && (p = strchr(optarg, '.')) &&
			    strcasecmp(p+1, domain) == 0)
				*p = 0;
			hostname = optarg;
			auth_setoption(as, "hostname", hostname);
			break;
		case 'L':
			if (uid) {
				warnc(EPERM, "-L option");
				quickexit(1);
			}
			if (lipaddr) {
				warnx("duplicate -L option");
				quickexit(1);
			}
			lipaddr = optarg;
			memset(&hints, 0, sizeof(hints));
			hints.ai_family = PF_UNSPEC;
			hints.ai_flags = AI_CANONNAME;
			error = getaddrinfo(lipaddr, NULL, &hints, &ai);
			if (!error) {
				strlcpy(localhost, ai->ai_canonname,
				    sizeof(localhost));
				freeaddrinfo(ai);
			} else
				strlcpy(localhost, lipaddr, sizeof(localhost));
			auth_setoption(as, "local_addr", lipaddr);
			break;
		case 'p':
			pflag = 1;
			break;
		case 'R':
			if (uid) {
				warnc(EPERM, "-R option");
				quickexit(1);
			}
			if (ripaddr) {
				warnx("duplicate -R option");
				quickexit(1);
			}
			ripaddr = optarg;
			auth_setoption(as, "remote_addr", ripaddr);
			break;
		case 'u':
			if (uid) {
				warnc(EPERM, "-u option");
				quickexit(1);
			}
			rusername = optarg;
			break;
		default:
			if (!uid)
				syslog(LOG_ERR, "invalid flag %c", ch);
			(void)fprintf(stderr,
			    "usage: login [-fp] [-h hostname] [-L local-addr] "
			    "[-R remote-addr] [-u username]\n\t[user]\n");
			quickexit(1);
		}
	argc -= optind;
	argv += optind;

	if (*argv) {
		username = *argv;
		ask = 0;
	} else
		ask = 1;

	/*
	 * If effective user is not root, just run su(1) to emulate login(1).
	 */
	if (geteuid() != 0) {
		char *av[5], **ap;

		auth_close(as);
		closelog();
		closefrom(STDERR_FILENO + 1);

		ap = av;
		*ap++ = _PATH_SU;
		*ap++ = "-L";
		if (!pflag)
			*ap++ = "-l";
		if (!ask)
			*ap++ = username;
		*ap = NULL;
		execv(_PATH_SU, av);
		warn("unable to exec %s", _PATH_SU);
		_exit(1);
	}

	ttyn = ttyname(STDIN_FILENO);
	if (ttyn == NULL || *ttyn == '\0') {
		(void)snprintf(tname, sizeof(tname), "%s??", _PATH_TTY);
		ttyn = tname;
	}
	if ((tty = strrchr(ttyn, '/')))
		++tty;
	else
		tty = ttyn;

	/*
	 * Since login deals with sensitive information, turn off coredumps.
	 */
	if (getrlimit(RLIMIT_CORE, &scds) < 0) {
		syslog(LOG_ERR, "couldn't get core dump size: %m");
		scds.rlim_cur = scds.rlim_max = QUAD_MIN;
	}
	cds.rlim_cur = cds.rlim_max = 0;
	if (setrlimit(RLIMIT_CORE, &cds) < 0) {
		syslog(LOG_ERR, "couldn't set core dump size to 0: %m");
		scds.rlim_cur = scds.rlim_max = QUAD_MIN;
	}

	(void)signal(SIGALRM, timedout);
	if (argc > 1) {
		needto = 0;
		(void)alarm(timeout);
	} else
		needto = 1;
	(void)signal(SIGQUIT, SIG_IGN);
	(void)signal(SIGINT, SIG_IGN);
	(void)signal(SIGHUP, SIG_IGN);
	(void)setpriority(PRIO_PROCESS, 0, 0);

	/* get the default login class */
	if ((lc = login_getclass(0)) == NULL) { /* get the default class */
		warnx("Failure to retrieve default class");
		quickexit(1);
	}
	timeout = (u_int)login_getcapnum(lc, "login-timeout", 300, 300);
	if ((script = login_getcapstr(lc, "classify", NULL, NULL)) != NULL) {
		unsetenv("AUTH_TYPE");
		unsetenv("REMOTE_NAME");
		if (script[0] != '/') {
			syslog(LOG_ERR, "Invalid classify script: %s", script);
			warnx("Classification failure");
			quickexit(1);
		}
		shell = strrchr(script, '/') + 1;
		auth_setstate(as, AUTH_OKAY);
		auth_call(as, script, shell,
		    fflag ? "-f" : username, fflag ? username : 0, (char *)0);
		if (!(auth_getstate(as) & AUTH_ALLOW))
			quickexit(1);
		auth_setenv(as);
		if ((p = getenv("AUTH_TYPE")) != NULL &&
		    strncmp(p, "auth-", 5) == 0)
			type = p;
		if ((p = getenv("REMOTE_NAME")) != NULL)
			hostname = p;
		/*
		 * we may have changed some values, reset them
		 */
		auth_clroptions(as);
		if (type)
			auth_setoption(as, "auth_type", type);
		if (fqdn)
			auth_setoption(as, "fqdn", fqdn);
		if (hostname)
			auth_setoption(as, "hostname", hostname);
		if (lipaddr)
			auth_setoption(as, "local_addr", lipaddr);
		if (ripaddr)
			auth_setoption(as, "remote_addr", ripaddr);
	}

	/*
	 * Request the things like the approval script print things
	 * to stdout (in particular, the nologins files)
	 */
	auth_setitem(as, AUTHV_INTERACTIVE, "True");

	for (cnt = 0;; ask = 1) {
		/*
		 * Clean up our current authentication session.
		 * Options are not cleared so we need to clear any
		 * we might set below.
		 */
		auth_clean(as);
		auth_clroption(as, "style");
		auth_clroption(as, "lastchance");

		lastchance = 0;

		if (ask) {
			fflag = 0;
			getloginname();
		}
		if (needto) {
			needto = 0;
			alarm(timeout);
		}
		if ((style = strchr(username, ':')) != NULL)
			*style++ = '\0';
		free(fullname);
		if (auth_setitem(as, AUTHV_NAME, username) < 0 ||
		    (fullname = strdup(username)) == NULL) {
			syslog(LOG_ERR, "%m");
			warn(NULL);
			quickexit(1);
		}
		rootlogin = 0;
		if ((instance = strchr(username, '/')) != NULL) {
			if (strncmp(instance + 1, "root", 4) == 0)
				rootlogin = 1;
			*instance++ = '\0';
		} else
			instance = "";

		if (strlen(username) > UT_NAMESIZE)
			username[UT_NAMESIZE] = '\0';

		/*
		 * Note if trying multiple user names; log failures for
		 * previous user name, but don't bother logging one failure
		 * for nonexistent name (mistyped username).
		 */
		if (failures && strcmp(tbuf, username)) {
			if (failures > (pwd ? 0 : 1))
				badlogin(tbuf);
			failures = 0;
		}
		(void)strlcpy(tbuf, username, sizeof(tbuf));

		if ((pwd = getpwnam(username)) != NULL &&
		    auth_setpwd(as, pwd) < 0) {
			syslog(LOG_ERR, "%m");
			warn(NULL);
			quickexit(1);
		}

		lc = login_getclass(pwd ? pwd->pw_class : NULL);
		if (!lc)
			goto failed;

		style = login_getstyle(lc, style, type);
		if (!style)
			goto failed;

		/*
		 * We allow "login-tries" attempts to login but start
		 * slowing down after "login-backoff" attempts.
		 */
		tries = (int)login_getcapnum(lc, "login-tries", 10, 10);
		backoff = (int)login_getcapnum(lc, "login-backoff", 3, 3);

		/*
		 * Turn off the fflag if we have an invalid user
		 * or we are not root and we are trying to change uids.
		 */
		if (!pwd || (uid && uid != pwd->pw_uid))
			fflag = 0;

		if (pwd && pwd->pw_uid == 0)
			rootlogin = 1;

		/*
		 * If we do not have the force flag authenticate the user
		 */
		if (!fflag) {
			lastchance =
			    login_getcaptime(lc, "password-dead", 0, 0) != 0;
			if (lastchance)
				auth_setoption(as, "lastchance", "yes");
			/*
			 * Once we start asking for a password
			 *  we want to log a failure on a hup.
			 */
			signal(SIGHUP, sighup);
			auth_verify(as, style, NULL, lc->lc_class, NULL);
			authok = auth_getstate(as);
			/*
			 * If their password expired and it has not been
			 * too long since then, give the user one last
			 * chance to change their password
			 */
			if ((authok & AUTH_PWEXPIRED) && lastchance) {
				authok = AUTH_OKAY;
			} else
				lastchance = 0;
			if ((authok & AUTH_ALLOW) == 0)
				goto failed;
			if (auth_setoption(as, "style", style) < 0) {
				syslog(LOG_ERR, "%m");
				warn(NULL);
				quickexit(1);
			}
		}
		/*
		 * explicitly reject users without password file entries
		 */
		if (pwd == NULL)
			goto failed;

		/*
		 * If trying to log in as root on an insecure terminal,
		 * refuse the login attempt unless the authentication
		 * style explicitly says a root login is okay.
		 */
		if (pwd && rootlogin && !rootterm(tty))
			goto failed;

		if (fflag) {
			type = 0;
			style = "forced";
		}
		break;

failed:
		if (authok & AUTH_SILENT)
			quickexit(0);
		if (rootlogin && !rootterm(tty)) {
			warnx("%s login refused on this terminal.",
			    fullname);
			if (hostname)
				syslog(LOG_NOTICE,
				    "LOGIN %s REFUSED FROM %s%s%s ON TTY %s",
				    fullname, rusername ? rusername : "",
				    rusername ? "@@" : "", hostname, tty);
			else
				syslog(LOG_NOTICE,
				    "LOGIN %s REFUSED ON TTY %s",
				    fullname, tty);
		} else {
			if (!as || (p = auth_getvalue(as, "errormsg")) == NULL)
				p = "Login incorrect";
			(void)printf("%s\n", p);
		}
		failures++;
		if (pwd)
			log_failedlogin(pwd->pw_uid, hostname, rusername, tty);
		/*
		 * By default, we allow 10 tries, but after 3 we start
		 * backing off to slow down password guessers.
		 */
		if (++cnt > backoff) {
			if (cnt >= tries) {
				badlogin(username);
				sleepexit(1);
			}
			sleep(1);
		}
	}

	/* committed to login -- turn off timeout */
	(void)alarm(0);

	endpwent();

	shell = login_getcapstr(lc, "shell", pwd->pw_shell, pwd->pw_shell);
	if (*shell == '\0')
		shell = _PATH_BSHELL;
	else if (strlen(shell) >= PATH_MAX) {
		syslog(LOG_ERR, "shell path too long: %s", shell);
		warnx("invalid shell");
		quickexit(1);
	}

	/* Destroy environment unless user has requested its preservation. */
	if (!pflag) {
		if ((environ = calloc(1, sizeof (char *))) == NULL)
			err(1, "calloc");
	} else {
		char **cpp, **cpp2;

		for (cpp2 = cpp = environ; *cpp; cpp++) {
			if (strncmp(*cpp, "LD_", 3) &&
			    strncmp(*cpp, "ENV=", 4) &&
			    strncmp(*cpp, "BASH_ENV=", 9) &&
			    strncmp(*cpp, "IFS=", 4))
				*cpp2++ = *cpp;
		}
		*cpp2 = 0;
	}
	/* Note: setusercontext(3) will set PATH */
	if (setenv("HOME", pwd->pw_dir, 1) == -1 ||
	    setenv("SHELL", pwd->pw_shell, 1) == -1) {
		warn("unable to setenv()");
		quickexit(1);
	}
	if (term[0] == '\0')
		(void)strlcpy(term, stypeof(tty), sizeof(term));
	(void)snprintf(mail, sizeof(mail), "%s/%s", _PATH_MAILDIR,
		pwd->pw_name);
	if (setenv("TERM", term, 0) == -1 ||
	    setenv("LOGNAME", pwd->pw_name, 1) == -1 ||
	    setenv("USER", pwd->pw_name, 1) == -1 ||
	    setenv("MAIL", mail, 1) == -1) {
		warn("unable to setenv()");
		quickexit(1);
	}
	if (hostname) {
		if (setenv("REMOTEHOST", hostname, 1) == -1) {
			warn("unable to setenv()");
			quickexit(1);
		}
	}
	if (rusername) {
		if (setenv("REMOTEUSER", rusername, 1) == -1) {
			warn("unable to setenv()");
			quickexit(1);
		}
	}

	if (setusercontext(lc, pwd, pwd->pw_uid, LOGIN_SETPATH)) {
		warn("unable to set user context");
		quickexit(1);
	}
	auth_setenv(as);

	/* if user not super-user, check for disabled logins */
	if (!rootlogin)
		auth_checknologin(lc);

	setegid(pwd->pw_gid);
	seteuid(pwd->pw_uid);

	homeless = chdir(pwd->pw_dir);
	if (homeless) {
		if (login_getcapbool(lc, "requirehome", 0)) {
			(void)printf("No home directory %s!\n", pwd->pw_dir);
			quickexit(1);
		}
		if (chdir("/"))
			quickexit(0);
	}

	quietlog = ((strcmp(pwd->pw_shell, "/sbin/nologin") == 0) ||
	    login_getcapbool(lc, "hushlogin", 0) ||
	    (access(_PATH_HUSHLOGIN, F_OK) == 0));

	seteuid(0);
	setegid(0);	/* XXX use a saved gid instead? */

	if ((p = auth_getvalue(as, "warnmsg")) != NULL)
		(void)printf("WARNING: %s\n\n", p);

	expire = auth_check_expire(as);
	if (expire < 0) {
		(void)printf("Sorry -- your account has expired.\n");
		quickexit(1);
	} else if (expire > 0 && !quietlog) {
		warning = login_getcaptime(lc, "expire-warn",
		    TWOWEEKS, TWOWEEKS);
		if (expire < warning)
			(void)printf("Warning: your account expires on %s",
			    ctime(&pwd->pw_expire));
	}

	/* Nothing else left to fail -- really log in. */
	(void)signal(SIGHUP, SIG_DFL);
	memset(&utmp, 0, sizeof(utmp));
	(void)time(&utmp.ut_time);
	(void)strncpy(utmp.ut_name, username, sizeof(utmp.ut_name));
	if (hostname)
		(void)strncpy(utmp.ut_host, hostname, sizeof(utmp.ut_host));
	(void)strncpy(utmp.ut_line, tty, sizeof(utmp.ut_line));
	login(&utmp);

	if (!quietlog)
		(void)check_failedlogin(pwd->pw_uid);
	dolastlog(quietlog);

	login_fbtab(tty, pwd->pw_uid, pwd->pw_gid);

	(void)chown(ttyn, pwd->pw_uid,
	    (gr = getgrnam(TTYGRPNAME)) ? gr->gr_gid : pwd->pw_gid);

	/* If fflag is on, assume caller/authenticator has logged root login. */
	if (rootlogin && fflag == 0) {
		if (hostname)
			syslog(LOG_NOTICE, "ROOT LOGIN (%s) ON %s FROM %s%s%s",
			    username, tty, rusername ? rusername : "",
			    rusername ? "@@" : "", hostname);
		else
			syslog(LOG_NOTICE, "ROOT LOGIN (%s) ON %s", username, tty);
	}

	if (!quietlog) {
		if ((copyright =
		    login_getcapstr(lc, "copyright", NULL, NULL)) != NULL)
			auth_cat(copyright);
		motd();
		if (stat(mail, &st) == 0 && st.st_size != 0)
			(void)printf("You have %smail.\n",
			    (st.st_mtime > st.st_atime) ? "new " : "");
	}

	(void)signal(SIGALRM, SIG_DFL);
	(void)signal(SIGQUIT, SIG_DFL);
	(void)signal(SIGHUP, SIG_DFL);
	(void)signal(SIGINT, SIG_DFL);
	(void)signal(SIGTSTP, SIG_IGN);

	tbuf[0] = '-';
	(void)strlcpy(tbuf + 1, (p = strrchr(shell, '/')) ?
	    p + 1 : shell, sizeof(tbuf) - 1);

	if ((scds.rlim_cur != QUAD_MIN || scds.rlim_max != QUAD_MIN) &&
	    setrlimit(RLIMIT_CORE, &scds) < 0)
		syslog(LOG_ERR, "couldn't reset core dump size: %m");

	if (lastchance)
		(void)printf("WARNING: Your password has expired."
		    "  You must change your password, now!\n");

	if (setusercontext(lc, pwd, rootlogin ? 0 : pwd->pw_uid,
	    LOGIN_SETALL & ~LOGIN_SETPATH) < 0) {
		warn("unable to set user context");
		quickexit(1);
	}

	if (homeless) {
		(void)printf("No home directory %s!\n", pwd->pw_dir);
		(void)printf("Logging in with home = \"/\".\n");
		(void)setenv("HOME", "/", 1);
	}

	if (auth_approval(as, lc, NULL, "login") == 0) {
		if (auth_getstate(as) & AUTH_EXPIRED)
			(void)printf("Sorry -- your account has expired.\n");
		else
			(void)printf("approval failure\n");
		quickexit(1);
	}

	/*
	 * The last thing we do is discard all of the open file descriptors.
	 * Last because the C library may have some open.
	 */
	closefrom(STDERR_FILENO + 1);

	/*
	 * Close the authentication session, make sure it is marked
	 * as okay so no files are removed.
	 */
	auth_setstate(as, AUTH_OKAY);
	auth_close(as);

	execlp(shell, tbuf, (char *)NULL);
	err(1, "%s", shell);
}

/*
 * Allow for a '.' and 16 characters for any instance as well as
 * space for a ':' and 16 characters defining the authentication type.
 */
#define NBUFSIZ		(UT_NAMESIZE + 1 + 16 + 1 + 16)

void
getloginname(void)
{
	static char nbuf[NBUFSIZ], *p;
	int ch;

	for (;;) {
		(void)printf("login: ");
		for (p = nbuf; (ch = getchar()) != '\n'; ) {
			if (ch == EOF) {
				badlogin(username);
				quickexit(0);
			}
			if (p < nbuf + (NBUFSIZ - 1))
				*p++ = ch;
		}
		if (p > nbuf) {
			if (nbuf[0] == '-')
				(void)fprintf(stderr,
				    "login names may not start with '-'.\n");
			else {
				*p = '\0';
				username = nbuf;
				break;
			}
		}
	}
}

int
rootterm(char *ttyn)
{
	struct ttyent *t;

	/* XXX - stash output of getttynam() elsewhere */
	return ((t = getttynam(ttyn)) && t->ty_status & TTY_SECURE);
}

void
motd(void)
{
	char tbuf[8192], *motd;
	int fd, nchars;
	struct sigaction sa, osa;

	motd = login_getcapstr(lc, "welcome", _PATH_MOTDFILE, _PATH_MOTDFILE);

	if ((fd = open(motd, O_RDONLY, 0)) < 0)
		return;

	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = sigint;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;		/* don't set SA_RESTART */
	(void)sigaction(SIGINT, &sa, &osa);

	/* read and spew motd until EOF, error, or SIGINT */
	while ((nchars = read(fd, tbuf, sizeof(tbuf))) > 0 &&
	    write(STDOUT_FILENO, tbuf, nchars) == nchars)
		;

	(void)sigaction(SIGINT, &osa, NULL);
	(void)close(fd);
}

/* ARGSUSED */
void
sigint(int signo)
{
	return;			/* just interrupt syscall */
}

/* ARGSUSED */
void
timedout(int signo)
{
	char warn[1024];

	snprintf(warn, sizeof warn,
	    "Login timed out after %d seconds\n", timeout);
	write(STDERR_FILENO, warn, strlen(warn));
	if (username)
		badlogin(username);
	_exit(0);
}

void
dolastlog(int quiet)
{
	struct lastlog ll;
	off_t pos;
	int fd;

	if ((fd = open(_PATH_LASTLOG, O_RDWR, 0)) >= 0) {
		pos = (off_t)pwd->pw_uid * sizeof(ll);
		if (!quiet) {
			if (pread(fd, &ll, sizeof(ll), pos) == sizeof(ll) &&
			    ll.ll_time != 0) {
				(void)printf("Last login: %.*s ",
				    24-5, (char *)ctime(&ll.ll_time));
				(void)printf("on %.*s",
				    (int)sizeof(ll.ll_line),
				    ll.ll_line);
				if (*ll.ll_host != '\0')
					(void)printf(" from %.*s",
					    (int)sizeof(ll.ll_host),
					    ll.ll_host);
				(void)putchar('\n');
			}
		}
		memset(&ll, 0, sizeof(ll));
		(void)time(&ll.ll_time);
		(void)strncpy(ll.ll_line, tty, sizeof(ll.ll_line));
		if (hostname)
			(void)strncpy(ll.ll_host, hostname, sizeof(ll.ll_host));
		(void)pwrite(fd, &ll, sizeof(ll), pos);
		(void)close(fd);
	}
}

void
badlogin(char *name)
{
	struct syslog_data sdata = SYSLOG_DATA_INIT;

	if (failures == 0)
		return;
	if (hostname) {
		syslog_r(LOG_NOTICE, &sdata,
		    "%d LOGIN FAILURE%s FROM %s%s%s",
		    failures, failures > 1 ? "S" : "",
		    rusername ? rusername : "", rusername ? "@@" : "", hostname);
		syslog_r(LOG_AUTHPRIV|LOG_NOTICE, &sdata,
		    "%d LOGIN FAILURE%s FROM %s%s%s, %s",
		    failures, failures > 1 ? "S" : "",
		    rusername ? rusername : "", rusername ? "@@" : "",
		    hostname, name);
	} else {
		syslog_r(LOG_NOTICE, &sdata,
		    "%d LOGIN FAILURE%s ON %s",
		    failures, failures > 1 ? "S" : "", tty);
		syslog_r(LOG_AUTHPRIV|LOG_NOTICE, &sdata,
		    "%d LOGIN FAILURE%s ON %s, %s",
		    failures, failures > 1 ? "S" : "", tty, name);
	}
}

#undef	UNKNOWN
#define	UNKNOWN	"su"

char *
stypeof(char *ttyid)
{
	struct ttyent *t;

	return (ttyid && (t = getttynam(ttyid)) ? t->ty_type :
	    login_getcapstr(lc, "term", UNKNOWN, UNKNOWN));
}

void
sleepexit(int eval)
{
	auth_close(as);
	(void)sleep(5);
	exit(eval);
}

void
quickexit(int eval)
{
	if (as)
		auth_close(as);
	exit(eval);
}


void
sighup(int signum)
{
	if (username)
		badlogin(username);
	_exit(0);
}
@


1.67
log
@Use pread/pwrite instead separate lseek+read/write for lastlog.
Cast to off_t before multiplication to avoid truncation on ILP32

ok kettenis@@ mmcc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.66 2015/12/09 19:26:26 mmcc Exp $	*/
d543 1
a543 1
			sleep((u_int)((cnt - backoff) * tries / 2));
@


1.66
log
@Remove NULL-check before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.65 2015/10/26 15:29:17 zhuk Exp $	*/
d842 1
d846 1
a846 1
		(void)lseek(fd, (off_t)pwd->pw_uid * sizeof(ll), SEEK_SET);
d848 1
a848 1
			if (read(fd, (char *)&ll, sizeof(ll)) == sizeof(ll) &&
a860 2
			(void)lseek(fd, (off_t)pwd->pw_uid * sizeof(ll),
			    SEEK_SET);
d862 1
a862 1
		memset((void *)&ll, 0, sizeof(ll));
d867 1
a867 1
		(void)write(fd, (char *)&ll, sizeof(ll));
@


1.65
log
@Put off some "notyet" dust from login.c.

okay millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.64 2015/03/15 00:41:28 millert Exp $	*/
d397 1
a397 2
		if (fullname)
			free(fullname);
@


1.64
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.63 2015/01/16 06:40:09 deraadt Exp $	*/
a325 14

#ifdef notyet
	/* XXX - we don't (yet) support per-tty auth stuff */
	/* BSDi uses a ttys.conf file but we could just overload /etc/ttys */
	/*
	 * Classify the attempt.
	 * By default we use the value in the ttys file.
	 * If there is a classify script we run that as
	 *
	 *	classify [-f] [username]
	 */
	if (type = getttyauth(tty))
		auth_setoption(as, "auth_type", type);
#endif
@


1.63
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.62 2014/05/20 01:25:23 guenther Exp $	*/
a92 1
#include <tzfile.h>
d119 3
d661 1
a661 1
		    2 * DAYSPERWEEK * SECSPERDAY, 2 * DAYSPERWEEK * SECSPERDAY);
@


1.62
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.61 2009/10/27 23:59:40 deraadt Exp $	*/
a72 1
#include <sys/param.h>
d95 1
d141 2
a142 2
	char tbuf[MAXPATHLEN + 2], tname[sizeof(_PATH_TTY) + 10];
	char localhost[MAXHOSTNAMELEN], *copyright;
d568 1
a568 1
	else if (strlen(shell) >= MAXPATHLEN) {
@


1.61
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.60 2009/09/05 14:04:38 tobias Exp $	*/
d192 1
a192 1
				warnx("-h option: %s", strerror(EPERM));
d209 1
a209 1
				warnx("-L option: %s", strerror(EPERM));
d234 1
a234 1
				warnx("-R option: %s", strerror(EPERM));
d246 1
a246 1
				warnx("-u option: %s", strerror(EPERM));
@


1.60
log
@- properly free fqdn if it gets reassigned due to multiple -h options
- fixed comment typos

with input by and ok millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.59 2009/08/31 22:25:43 martynas Exp $	*/
a64 13

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1980, 1987, 1988, 1991, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)login.c	8.4 (Berkeley) 4/2/94";
#endif
static const char rcsid[] = "$OpenBSD: login.c,v 1.59 2009/08/31 22:25:43 martynas Exp $";
#endif /* not lint */
@


1.59
log
@also, like ssh, set up MAIL to the location we've just checked
so that ksh could take advantage of it.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.58 2009/08/03 21:43:07 martynas Exp $	*/
d76 1
a76 1
static const char rcsid[] = "$OpenBSD: login.c,v 1.58 2009/08/03 21:43:07 martynas Exp $";
d208 1
d476 1
a476 1
		 * Turn off the fflag if we have an an invalid user
d774 1
a774 1
 * space for a ':' and 16 charcters defining the authentication type.
@


1.58
log
@properly pass SHELL from password file;  not a login configuration
variable (restores behavior pre-rev. 1.30).
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.57 2007/04/02 07:01:33 jmc Exp $	*/
d76 1
a76 1
static const char rcsid[] = "$OpenBSD: login.c,v 1.57 2007/04/02 07:01:33 jmc Exp $";
d156 1
d610 2
d614 2
a615 1
	    setenv("USER", pwd->pw_name, 1) == -1) {
d711 1
a711 3
		(void)snprintf(tbuf,
		    sizeof(tbuf), "%s/%s", _PATH_MAILDIR, pwd->pw_name);
		if (stat(tbuf, &st) == 0 && st.st_size != 0)
@


1.57
log
@tweak the -LR options, after similar changes to tcpdrop(8); ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.56 2007/03/26 14:29:37 jmc Exp $	*/
d76 1
a76 1
static const char rcsid[] = "$OpenBSD: login.c,v 1.56 2007/03/26 14:29:37 jmc Exp $";
d603 1
a603 1
	    setenv("SHELL", shell, 1) == -1) {
@


1.56
log
@tidy up SYNOPSIS, options description, FILES, and usage();
from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.55 2004/08/30 23:00:22 millert Exp $	*/
d76 1
a76 1
static const char rcsid[] = "$OpenBSD: login.c,v 1.55 2004/08/30 23:00:22 millert Exp $";
d266 2
a267 2
			    "usage: login [-fp] [-h hostname] [-L local-ip] "
			    "[-R remote-ip] [-u username]\n\t[user]\n");
@


1.55
log
@For username foo.bar, don't treat "bar" as a kerberos instance,
that was a kerb4'ism.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.54 2004/01/23 04:36:37 millert Exp $	*/
d76 1
a76 1
static const char rcsid[] = "$OpenBSD: login.c,v 1.54 2004/01/23 04:36:37 millert Exp $";
d266 2
a267 2
			    "usage: login [-fp] [-h hostname] [-L lipaddr] "
			    "[-R ripaddr] [-u username] [user]\n");
@


1.54
log
@Move a closefrom(2) into the block that execs su(1) where it can do the
most good.  There is already another closefrom(2) for the normal code path.
Also remove a bogus comment.  Discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.53 2004/01/23 03:48:43 deraadt Exp $	*/
d76 1
a76 1
static const char rcsid[] = "$OpenBSD: login.c,v 1.53 2004/01/23 03:48:43 deraadt Exp $";
d429 1
a429 1
		if ((instance = strpbrk(username, "./")) != NULL) {
@


1.53
log
@Use closefrom(); ok millert tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.52 2003/11/09 20:13:57 otto Exp $	*/
d76 1
a76 1
static const char rcsid[] = "$OpenBSD: login.c,v 1.52 2003/11/09 20:13:57 otto Exp $";
a278 2
	closefrom(3);

d287 1
a754 4
	 *
	 * XXX
	 * Assume that stdin, stdout and stderr are 0, 1 and 2, and that
	 * STDERR_FILENO is 2.
@


1.52
log
@Typos in comments from Jared Yanovich <jjy2+ at pitt dot edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.51 2003/08/12 13:14:58 hin Exp $	*/
d76 1
a76 1
static const char rcsid[] = "$OpenBSD: login.c,v 1.51 2003/08/12 13:14:58 hin Exp $";
d279 1
a279 2
	for (cnt = getdtablesize(); cnt > 2; cnt--)
		(void)close(cnt);
d761 1
a761 2
	for (cnt = getdtablesize(); cnt > STDERR_FILENO; cnt--)
		(void)close(cnt);
@


1.51
log
@Clean up obsolete kerberos 4 stuff

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.50 2003/06/03 02:56:10 millert Exp $	*/
d76 1
a76 1
static const char rcsid[] = "$OpenBSD: login.c,v 1.50 2003/06/03 02:56:10 millert Exp $";
d851 1
a851 1
	return;			/* just interupt syscall */
@


1.50
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.49 2002/10/16 01:08:56 millert Exp $	*/
d76 1
a76 1
static const char rcsid[] = "$OpenBSD: login.c,v 1.49 2002/10/16 01:08:56 millert Exp $";
a112 4
#ifdef KERBEROS
#include <kerberosIV/kafs.h>
#endif

a771 4
#ifdef KERBEROS
	kgettokens(pwd->pw_dir);
#endif

a965 17

#ifdef KERBEROS
void
kgettokens(char *homedir)
{

	/* buy AFS-tokens for homedir */
	if (k_hasafs()) {
		char cell[128];

		k_setpag();
		if (k_afs_cell_of_file(homedir, cell, sizeof(cell)) == 0)
			krb_afslog(cell, 0);
		krb_afslog(0, 0);
	}
}
#endif
@


1.49
log
@Remove the setuid bit from /usr/bin/login.  If login is run by a user
with a non-zero euid, it will now exec "su -L -l".  The only things
that need to do this are shells with a "login" builtin and the emulation
that su(1) now does is good enough for this purpose.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.48 2002/07/02 01:36:19 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d76 1
a76 1
static const char rcsid[] = "$OpenBSD: login.c,v 1.48 2002/07/02 01:36:19 millert Exp $";
@


1.48
log
@Kill setjmp/longjmp from a signal handler.  All we really need is
to use sigaction() w/o SA_RESTART to allow ^C to interrupt motd().
deraadt@@ OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.47 2002/07/02 01:15:08 deraadt Exp $	*/
d71 1
a71 1
static char copyright[] =
d78 1
a78 1
static char sccsid[] = "@@(#)login.c	8.4 (Berkeley) 4/2/94";
d80 1
a80 1
static char rcsid[] = "$OpenBSD: login.c,v 1.47 2002/07/02 01:15:08 deraadt Exp $";
d87 1
a173 11
	(void)signal(SIGALRM, timedout);
	if (argc > 1) {
		needto = 0;
		(void)alarm(timeout);
	} else
		needto = 1;
	(void)signal(SIGQUIT, SIG_IGN);
	(void)signal(SIGINT, SIG_IGN);
	(void)signal(SIGHUP, SIG_IGN);
	(void)setpriority(PRIO_PROCESS, 0, 0);

a180 19
	/*
	 * Since login deals with sensitive information, turn off coredumps.
	 */
	if (getrlimit(RLIMIT_CORE, &scds) < 0) {
		syslog(LOG_ERR, "couldn't get core dump size: %m");
		scds.rlim_cur = scds.rlim_max = QUAD_MIN;
	}
	cds.rlim_cur = cds.rlim_max = 0;
	if (setrlimit(RLIMIT_CORE, &cds) < 0) {
		syslog(LOG_ERR, "couldn't set core dump size to 0: %m");
		scds.rlim_cur = scds.rlim_max = QUAD_MIN;
	}

	/*
	 * -p is used by getty to tell login not to destroy the environment
	 * -f is used to skip a second login authentication
	 * -h is used by other servers to pass the name of the remote
	 *    host to login so that it may be placed in utmp and wtmp
	 */
d182 1
a182 1
	if (gethostname(localhost, sizeof(localhost)) < 0)
d184 2
a185 3
	else
		domain = strchr(localhost, '.');
	if (domain) {
d197 6
d290 22
d322 24
d377 1
a377 1
		    fflag ? "-f" : username, fflag ? username : 0, 0);
@


1.47
log
@KNF and signal race fixes; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.46 2002/03/30 18:16:05 vincent Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: login.c,v 1.46 2002/03/30 18:16:05 vincent Exp $";
a102 1
#include <setjmp.h>
a809 2
jmp_buf motdinterrupt;

d815 1
a815 1
	sig_t oldint;
d821 13
a833 5
	oldint = signal(SIGINT, sigint);
	if (setjmp(motdinterrupt) == 0)
		while ((nchars = read(fd, tbuf, sizeof(tbuf))) > 0)
			(void)write(fileno(stdout), tbuf, nchars);
	(void)signal(SIGINT, oldint);
d841 1
a841 1
	longjmp(motdinterrupt, 1);
@


1.46
log
@ warn -> warnx, because we put the strerror() manually.

 ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.45 2002/02/16 21:27:48 millert Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: login.c,v 1.45 2002/02/16 21:27:48 millert Exp $";
d155 2
d158 1
a158 3
main(argc, argv)
	int argc;
	char *argv[];
d160 6
a165 1
	extern char **environ;
d167 3
a170 1
	struct rlimit cds, scds;
a171 2
	struct utmp utmp;
	quad_t expire, warning;
a172 6
	int ask, ch, cnt, fflag, pflag, quietlog, rootlogin, lastchance;
	int error, homeless, needto, authok, tries, backoff;
	char *domain, *p, *ttyn, *shell, *fullname, *instance;
	char *lipaddr, *script, *ripaddr, *style, *type, *fqdn, *copyright;
	char tbuf[MAXPATHLEN + 2], tname[sizeof(_PATH_TTY) + 10];
	char localhost[MAXHOSTNAMELEN];
d299 2
a300 1
			    "usage: login [-fp] [-h hostname] [-L lipaddr] [-R ripaddr] [-u username] [user]\n");
d340 1
a340 1
	if ((lc = login_getclass(0)) == NULL) { /* get the default class */ 
d355 1
a355 1
		auth_call(as, script, shell, 
d407 1
a407 1
    	    	if ((style = strchr(username, ':')) != NULL)
d507 1
a507 1
		if (pwd == 0)
d538 1
a538 1
				     fullname, tty);
d658 1
a658 1
			(void)printf("Warning: your account expires on %s",  
a691 6
#if 0
		(void)printf("%s\n\t%s  %s\n\n",
	    "Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994",
		    "The Regents of the University of California. ",
		    "All rights reserved.");
#endif
d718 2
a719 1
		(void)printf("WARNING: Your password has expired.  You must change your password, now!\n");
d760 1
a760 1
        kgettokens(pwd->pw_dir);
d774 1
a774 1
getloginname()
d776 1
a777 2
	char *p;
	static char nbuf[NBUFSIZ];
d803 1
a803 2
rootterm(ttyn)
	char *ttyn;
d814 1
a814 1
motd()
d816 1
a818 2
	char tbuf[8192];
	char *motd;
d834 1
a834 2
sigint(signo)
	int signo;
d841 1
a841 2
timedout(signo)
	int signo;
d843 5
a847 1
	(void)fprintf(stderr, "Login timed out after %d seconds\n", timeout);
d850 1
a850 1
	exit(0);
d854 1
a854 2
dolastlog(quiet)
	int quiet;
d889 1
a889 2
badlogin(name)
	char *name;
d891 2
d896 2
a897 1
		syslog(LOG_NOTICE, "%d LOGIN FAILURE%s FROM %s%s%s",
d900 1
a900 1
		syslog(LOG_AUTHPRIV|LOG_NOTICE,
d906 2
a907 1
		syslog(LOG_NOTICE, "%d LOGIN FAILURE%s ON %s",
d909 1
a909 1
		syslog(LOG_AUTHPRIV|LOG_NOTICE,
d919 1
a919 2
stypeof(ttyid)
	char *ttyid;
d928 1
a928 2
sleepexit(eval)
	int eval;
d936 1
a936 2
quickexit(eval)
	int eval;
d945 1
a945 2
sighup(signum)
	int signum;
d949 1
a949 1
	exit(0);
d954 1
a954 2
kgettokens(homedir)
	char *homedir;
d956 1
a956 1
  
d958 1
a958 1
	if (k_hasafs()) {  
d960 1
d962 1
a962 2
		if (k_afs_cell_of_file(homedir,  
				       cell, sizeof(cell)) == 0)
@


1.45
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.44 2002/01/06 21:59:15 millert Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: login.c,v 1.44 2002/01/06 21:59:15 millert Exp $";
d238 1
a238 1
				warn("-h option: %s", strerror(EPERM));
@


1.44
log
@Do not allow root to login via an insecure tty even if the auth method
does not use plaintext passwords due to the possibility of connection
hijacking.  This restores the pre-3.0 behavior and closes PR 2299.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.43 2001/08/12 02:45:33 millert Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: login.c,v 1.43 2001/08/12 02:45:33 millert Exp $";
d123 12
a134 12
void	 badlogin __P((char *));
void	 dolastlog __P((int));
void	 getloginname __P((void));
void	 motd __P((void));
void	 quickexit __P((int));
int	 rootterm __P((char *));
void	 sigint __P((int));
void	 sighup __P((int));
void	 sleepexit __P((int));
char	*stypeof __P((char *));
void	 timedout __P((int));
int	 main __P((int, char **));
d136 2
a137 2
extern int check_failedlogin __P((uid_t));
extern void log_failedlogin __P((uid_t, char *, char *, char *));
@


1.43
log
@Sync usage message to man page
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.42 2001/07/09 07:04:49 deraadt Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: login.c,v 1.42 2001/07/09 07:04:49 deraadt Exp $";
d475 1
a475 3
		if (fflag)
			authok = AUTH_SECURE;
		else {
a509 2
		authok &= AUTH_SECURE;

d515 1
a515 1
		if (authok == 0 && pwd && rootlogin && !rootterm(tty))
@


1.42
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.41 2001/07/06 18:12:06 pvalchev Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: login.c,v 1.41 2001/07/06 18:12:06 pvalchev Exp $";
d300 1
a300 1
			    "usage: login [-fp] [-h hostname] [-L lipaddr] [-R ripaddr] [username]\n");
@


1.41
log
@missing prototypes; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.40 2001/06/28 22:49:42 millert Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: login.c,v 1.40 2001/06/28 22:49:42 millert Exp $";
d772 1
a772 1
	execlp(shell, tbuf, 0);
@


1.40
log
@'/' can also be an instance separator (e.g. kerb5)
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.39 2001/06/25 16:18:37 millert Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: login.c,v 1.39 2001/06/25 16:18:37 millert Exp $";
d134 1
@


1.39
log
@Add a "login" option to allow differentiation between authentication
that creates a login session vs. a simple identity check.  Gets
passed as a -v option to the login scripts.  To be used by kerberos
to know when to create new tickets.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.38 2001/06/24 17:12:52 millert Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: login.c,v 1.38 2001/06/24 17:12:52 millert Exp $";
d417 2
a418 2
		if ((instance = strchr(username, '.')) != NULL) {
			if (strncmp(instance, ".root", 5) == 0)
@


1.38
log
@When setting uid, set to 0 if rootlogin flag is set, regardless of
pw_uid.  Fixes problem with user.root instances not haveing uid 0
in kerberos.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.37 2001/06/19 16:21:49 millert Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: login.c,v 1.37 2001/06/19 16:21:49 millert Exp $";
d223 2
a224 2
		syslog(LOG_ERR, "%m");
		err(1, NULL);
d226 1
@


1.37
log
@If we timeout during login and the user tried to login call badlogin()
before exit.  SUggested by <vii@@users.sourceforge.net>

Add some new login.conf variables:
o login-timeout - login prompt timeout
o login-tries - max login tries
o login-backoff - number of attempts before backing off (and sleeping)
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.36 2001/05/29 21:39:26 millert Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: login.c,v 1.36 2001/05/29 21:39:26 millert Exp $";
a415 1
		/* XXX - kerb5 uses a '/' not a '.' ??? */
d728 1
a728 1
	if (setusercontext(lc, pwd, pwd->pw_uid,
@


1.36
log
@BSD auth support.  k5login.c and klogin.c are no longer used but will
remain for the time being until Kerberos support is up to snuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.34 2000/09/15 07:13:48 deraadt Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: login.c,v 1.34 2000/09/15 07:13:48 deraadt Exp $";
d141 1
a141 3
 * This bounds the time given to login.  Not a define so it can
 * be patched on machines where it's too small.
 * XXX - should be a login.conf variable!
d168 1
a168 1
	int error, homeless, needto, authok;
d187 4
a190 1
	fqdn = lipaddr = ripaddr = fullname = NULL;
d342 1
a446 1

a450 1

d455 7
d550 6
a555 4
		/* we allow 10 tries, but after 3 we start backing off */
		/* XXX - should be configurable */
		if (++cnt > 3) {
			if (cnt >= 10) {
d559 1
a559 1
			sleep((u_int)((cnt - 3) * 5));
d857 2
@


1.35
log
@Make empty passwords work again when login is compiled with kerberos support.
@
text
@d36 33
d90 1
d101 1
d105 1
d115 5
a119 1
#include <skey.h>
a123 1
void	 checknologin __P((void));
d127 1
a133 7
int	 pwcheck __P((char *, char *, char *, char *));
#if defined(KERBEROS) || defined(KERBEROS5)
int	 klogin __P((struct passwd *, char *, char *, char *));
void	 kdestroy __P((void));
void	 dofork __P((void));
void	 kgettokens __P((char *));
#endif
d147 1
a147 8
#if defined(KERBEROS) || defined(KERBEROS5)
int		notickets = 1;
char		*instance;
char		*krbtkfile_env;
int		authok;
#endif

struct	passwd	*pwd;
d149 1
d151 1
d153 1
d162 1
d164 1
a165 1
	struct timeval tp;
d167 1
a167 1
	int ask, ch, cnt, fflag, hflag, pflag, uflag, quietlog, rootlogin, rval;
d169 4
a172 1
	char *domain, *p, *salt, *ttyn, *shell;
d177 5
a181 1
	(void)alarm(timeout);
d184 1
a184 1
	(void)signal(SIGHUP, sighup);
d189 15
d221 6
a226 1
	fflag = hflag = pflag = 0;
d228 1
a228 1
	while ((ch = getopt(argc, argv, "fh:u:p")) != -1)
d234 9
a242 3
			if (uid)
				errx(1, "-h option: %s", strerror(EPERM));
			hflag = 1;
d247 23
d274 12
d287 4
a290 3
			if (uid)
				errx(1, "-u option: %s", strerror(EPERM));
			uflag = 1;
a292 1
		case '?':
d297 2
a298 2
			    "usage: login [-fp] [-h hostname] [username]\n");
			exit(1);
d322 61
d384 11
a394 4
#if defined(KERBEROS) || defined(KERBEROS5)
	        kdestroy();
		authok = 0;
#endif
d399 14
d414 1
a414 9

#if defined(KERBEROS) || defined(KERBEROS5)
		/*
		 * Why should anyone with a root instance be able
		 * to be root here?
		 */
		instance = "";
#endif
#ifdef	KERBEROS
d421 1
a421 9
#endif
#ifdef KERBEROS5
		if ((instance = strchr(username, '/')) != NULL) {
			if (strncmp(instance, "/root", 5) == 0)
				rootlogin = 1;
			*instance++ = '\0';
		} else
			instance = "";
#endif
d435 1
a435 1
		(void)strlcpy(tbuf, username, sizeof tbuf);
d437 6
a442 7
		if ((pwd = getpwnam(username)))
			salt = pwd->pw_passwd;
		else
			salt = "xx";
		lc = login_getclass(pwd ? pwd->pw_class : LOGIN_DEFCLASS);
		if (!lc)
		    err(1, "unable to get login class");
d444 1
a444 9
		/*
		 * If we have a valid account name, and it doesn't have a
		 * password, or the -f option was specified and the caller
		 * is root or the caller isn't changing their uid, don't
		 * authenticate.
		 */
		if (pwd) {
			if (pwd->pw_uid == 0)
				rootlogin = 1;
d446 2
a447 12
			if (fflag && (uid == 0 || uid == pwd->pw_uid)) {
				/* already authenticated */
				break;
			} else if (pwd->pw_passwd[0] == '\0') {
				/* pretend password okay */
				rval = 0;
#if defined(KERBEROS) || defined(KERBEROS5)
				authok = 1;
#endif
				goto ttycheck;
			}
		}
d449 1
a449 1
		fflag = 0;
d451 2
a452 1
		(void)setpriority(PRIO_PROCESS, 0, -4);
d454 6
a459 1
		p = getpass("Password:");
d461 2
a462 24
		if (pwd) {
#if defined(KERBEROS) || defined(KERBEROS5)
			rval = klogin(pwd, instance, localhost, p);
			if (rval != 0 && rootlogin && pwd->pw_uid != 0)
				rootlogin = 0;
			if (rval == 1) {
				/* Fall back on password file. */
				if (pwd->pw_uid != 0)
					rootlogin = 0;
				rval = pwcheck(username, p, salt, pwd->pw_passwd);
			}
			if (rval == 0)
				authok = 1;
#else
			rval = pwcheck(username, p, salt, pwd->pw_passwd);
#endif
		} else {
#ifdef SKEY
			if (strcasecmp(p, "s/key") == 0)
				(void)skey_authenticate(username);
			else
#endif
			{
				useconds_t us;
d464 32
a495 6
				/*
				 * Sleep between 1 and 3 seconds
				 * to emulate a crypt.
				 */
				us = arc4random() % 3000000;
				usleep(us);
a496 1
			rval = 1;
d498 5
a502 1
		memset(p, 0, strlen(p));
d504 1
a504 1
		(void)setpriority(PRIO_PROCESS, 0, 0);
a505 1
	ttycheck:
d507 3
a509 2
		 * If trying to log in as root without Kerberos,
		 * but with insecure terminal, refuse the login attempt.
d511 2
a512 6
#if defined(KERBEROS) || defined(KERBEROS5)
		if (authok == 1)
#endif
		/* if logging in as root, user must be on a secure tty */
		if (pwd && rval == 0 && (!rootlogin || rootterm(tty)))
			break;
d514 9
a522 5
		/*
		 * We don't want to give out info to an attacker trying
		 * to guess root's password so we always say "login refused"
		 * in that case, not "Login incorrect".
		 */
d524 2
a525 3
			(void)fprintf(stderr,
			    "%s login refused on this terminal.\n",
			    pwd ? pwd->pw_name : "root");
d529 1
a529 2
				    pwd ? pwd->pw_name : "root",
				    rusername ? rusername : "",
d534 6
a539 3
				     pwd ? pwd->pw_name : "root", tty);
		} else
			(void)printf("Login incorrect\n");
d544 1
d555 1
a555 1
	(void)alarm((u_int)0);
a558 17
	/* if user not super-user, check for disabled logins */
	if (!rootlogin)
		checknologin();

	setegid(pwd->pw_gid);
	seteuid(pwd->pw_uid);

	if (chdir(pwd->pw_dir) < 0) {
		(void)printf("No home directory %s!\n", pwd->pw_dir);
		if (login_getcapbool(lc, "requirehome", 0))
			exit(1);
		if (chdir("/"))
			exit(0);
		pwd->pw_dir = "/";
		(void)printf("Logging in with home = \"/\".\n");
	}

d565 1
a565 31
		sleepexit(1);
	}

	quietlog = ((strcmp(pwd->pw_shell, "/sbin/nologin") == 0) ||
	    login_getcapbool(lc, "hushlogin", 0) ||
	    (access(_PATH_HUSHLOGIN, F_OK) == 0));

	seteuid(0);
	setegid(0);	/* XXX use a saved gid instead? */

	if (pwd->pw_change || pwd->pw_expire)
		(void)gettimeofday(&tp, (struct timezone *)NULL);
	if (pwd->pw_expire) {
		if (tp.tv_sec >= pwd->pw_expire) {
			(void)printf("Sorry -- your account has expired.\n");
			sleepexit(1);
		} else if (!quietlog &&pwd->pw_expire - tp.tv_sec <
		    login_getcaptime(lc, "expire-warn", 
		    2 * DAYSPERWEEK * SECSPERDAY, 2 * DAYSPERWEEK * SECSPERDAY))
			(void)printf("Warning: your account expires on %s",
			    ctime(&pwd->pw_expire));
	}
	if (pwd->pw_change) {
		if (tp.tv_sec >= pwd->pw_change) {
			(void)printf("Sorry -- your password has expired.\n");
			sleepexit(1);
		} else if (!quietlog && pwd->pw_change - tp.tv_sec <
		    login_getcaptime(lc, "password-warn", 
		    2 * DAYSPERWEEK * SECSPERDAY, 2 * DAYSPERWEEK * SECSPERDAY))
			(void)printf("Warning: your password expires on %s",
			    ctime(&pwd->pw_change));
a567 24
	/* Nothing else left to fail -- really log in. */
	(void)signal(SIGHUP, SIG_DFL);
	memset((void *)&utmp, 0, sizeof(utmp));
	(void)time(&utmp.ut_time);
	(void)strncpy(utmp.ut_name, username, sizeof(utmp.ut_name));
	if (hostname)
		(void)strncpy(utmp.ut_host, hostname, sizeof(utmp.ut_host));
	(void)strncpy(utmp.ut_line, tty, sizeof(utmp.ut_line));
	login(&utmp);

	if (!quietlog)
		(void)check_failedlogin(pwd->pw_uid);
	dolastlog(quietlog);

	login_fbtab(tty, pwd->pw_uid, pwd->pw_gid);

	(void)chown(ttyn, pwd->pw_uid,
	    (gr = getgrnam(TTYGRPNAME)) ? gr->gr_gid : pwd->pw_gid);
#if defined(KERBEROS) || defined(KERBEROS5)
	/* Fork so that we can call kdestroy */
	if (krbtkfile_env)
	    dofork();
#endif

d588 1
a588 1
		exit(1);
d596 1
a596 1
		exit(1);
d601 1
a601 1
			exit(1);
d607 1
a607 1
			exit(1);
d610 19
a628 5
#ifdef KERBEROS
	if (krbtkfile_env) {
		if (setenv("KRBTKFILE", krbtkfile_env, 1) == -1) {
			warn("unable to setenv()");
			exit(1);
d630 2
d633 21
a653 7
#endif
#ifdef KERBEROS5
	if (krbtkfile_env) {
		if (setenv("KRB5CCNAME", krbtkfile_env, 1) == -1) {
			warn("unable to setenv()");
			exit(1);
		}
d655 20
a674 1
#endif
a684 5
#if defined(KERBEROS) || defined(KERBEROS5)
	if (!quietlog && notickets == 1)
		(void)printf("Warning: no Kerberos tickets issued.\n");
#endif

d692 3
d705 1
d711 8
a718 1
	    p + 1 : shell, sizeof tbuf - 1);
d720 2
a721 2
	/* Discard permissions last so can't get killed and drop core. */
	if (setusercontext(lc, pwd, pwd->pw_uid, LOGIN_SETALL)) {
d723 7
a729 1
		exit(1);
d732 26
d759 1
a759 1
	kgettokens(pwd->pw_dir);
a765 18
int
pwcheck(user, p, salt, passwd)
	char *user, *p, *salt, *passwd;
{
#ifdef SKEY
	if (strcasecmp(p, "s/key") == 0)
		return skey_authenticate(user);
#endif
	return strcmp(crypt(p, salt), passwd);
}

#if defined(KERBEROS) || defined(KERBEROS5)
#define	NBUFSIZ		(UT_NAMESIZE + 1 + 5)	/* .root suffix */
#else
#define	NBUFSIZ		(UT_NAMESIZE + 1)
#endif

#if defined(KERBEROS) || defined(KERBEROS5)
d767 2
a768 2
 * This routine handles cleanup stuff, and the like.
 * It exists only in the child process.
d770 1
a770 24
#include <sys/wait.h>
void
dofork()
{
    int child;

    if (!(child = fork()))
	    return; /* Child process */

    /* Setup stuff?  This would be things we could do in parallel with login */
    (void) chdir("/");	/* Let's not keep the fs busy... */
    
    /* If we're the parent, watch the child until it dies */
    while (wait(0) != child)
	    ;

    /* Cleanup stuff */
    /* Run kdestroy to destroy tickets */
    kdestroy();

    /* Leave */
    exit(0);
}
#endif
d784 1
a784 1
				exit(0);
d808 1
a851 18
checknologin()
{
	int fd, nchars;
	char *nologin;
	char tbuf[8192];

	if (!login_getcapbool(lc, "ignorenologin", 0)) {
		nologin = login_getcapstr(lc, "nologin", _PATH_NOLOGIN,
		    _PATH_NOLOGIN);
		if ((fd = open(nologin, O_RDONLY, 0)) >= 0) {
			while ((nchars = read(fd, tbuf, sizeof(tbuf))) > 0)
				(void)write(fileno(stdout), tbuf, nchars);
			sleepexit(0);
		}
	}
}

void
d928 1
d934 10
d951 18
@


1.34
log
@check return value for setenv(3) for failure, and deal appropriately
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.33 2000/09/04 19:15:27 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.33 2000/09/04 19:15:27 millert Exp $";
d227 1
d297 3
@


1.33
log
@Check for account expiration before password expiration;
sigh@@kuzirabekon.econ.nagasaki-u.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.32 2000/08/24 20:08:06 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.32 2000/08/24 20:08:06 millert Exp $";
d492 5
a496 2
	(void)setenv("HOME", pwd->pw_dir, 1);
	(void)setenv("SHELL", shell, 1);
d499 18
a516 7
	(void)setenv("TERM", term, 0);
	(void)setenv("LOGNAME", pwd->pw_name, 1);
	(void)setenv("USER", pwd->pw_name, 1);
	if (hostname)
		(void)setenv("REMOTEHOST", hostname, 1);
	if (rusername)
		(void)setenv("REMOTEUSER", rusername, 1);
d518 6
a523 2
	if (krbtkfile_env)
		(void)setenv("KRBTKFILE", krbtkfile_env, 1);
d526 6
a531 2
	if (krbtkfile_env)
		(void)setenv("KRB5CCNAME", krbtkfile_env, 1);
@


1.32
log
@Last change inadvertantly broke non-kerberos logins.  It's not clear
that the authok flag is really meaningful but keep it for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.31 2000/08/24 20:05:07 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.31 2000/08/24 20:05:07 millert Exp $";
d430 10
a448 10
	}
	if (pwd->pw_expire) {
		if (tp.tv_sec >= pwd->pw_expire) {
			(void)printf("Sorry -- your account has expired.\n");
			sleepexit(1);
		} else if (!quietlog &&pwd->pw_expire - tp.tv_sec <
		    login_getcaptime(lc, "expire-warn", 
		    2 * DAYSPERWEEK * SECSPERDAY, 2 * DAYSPERWEEK * SECSPERDAY))
			(void)printf("Warning: your account expires on %s",
			    ctime(&pwd->pw_expire));
@


1.31
log
@Fix non-root kerberos logins broken after rev 1.29.  That change was
correct but it uncovered a bug that had thusfar stayed hidden due more
to serendipity than anything else.  Problem found by danh@@openbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.30 2000/08/20 18:42:39 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.30 2000/08/20 18:42:39 millert Exp $";
d311 2
a312 3
			if (rval == 0)
				authok = 1;
			else if (rval == 1) {
d317 2
@


1.30
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.29 2000/07/17 16:43:14 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.29 2000/07/17 16:43:14 millert Exp $";
d349 1
a349 1
		if (authok == 0)
d352 1
a352 1
		if (pwd && !rval && (!rootlogin || rootterm(tty)))
@


1.29
log
@ o use strlcpy() where sensible
 o when trying to login as root on a non-secure tty always say
   "login refused" regardless of whether the password is correct or not
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.28 1999/12/30 01:07:23 ericj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.28 1999/12/30 01:07:23 ericj Exp $";
d66 1
d110 1
d112 1
a112 1
u_int	timeout = 300;
d115 4
a118 4
int	notickets = 1;
char	*instance;
char	*krbtkfile_env;
int	authok;
d121 5
a125 4
struct	passwd *pwd;
int	failures;
char	term[64], *hostname, *tty;
char	*username = NULL, *rusername = NULL;
d139 1
a139 1
	char *domain, *p, *salt, *ttyn;
d276 3
d403 2
d411 9
d421 2
a422 1
			(access(_PATH_HUSHLOGIN, F_OK) == 0));
d433 3
a435 2
		} else if (pwd->pw_change - tp.tv_sec <
		    2 * DAYSPERWEEK * SECSPERDAY && !quietlog)
d443 3
a445 2
		} else if (pwd->pw_expire - tp.tv_sec <
		    2 * DAYSPERWEEK * SECSPERDAY && !quietlog)
a472 7
	(void)setegid(pwd->pw_gid);
	(void)setgid(pwd->pw_gid);

	initgroups(username, pwd->pw_gid);

	if (*pwd->pw_shell == '\0')
		pwd->pw_shell = _PATH_BSHELL;
d490 1
d492 1
a492 1
	(void)setenv("SHELL", pwd->pw_shell, 1);
a497 1
	(void)setenv("PATH", _PATH_DEFPATH, 0);
a509 1

d546 2
a547 5
	(void)strlcpy(tbuf + 1, (p = strrchr(pwd->pw_shell, '/')) ?
	    p + 1 : pwd->pw_shell, sizeof tbuf - 1);

	if (setlogin(pwd->pw_name) < 0)
		syslog(LOG_ERR, "setlogin() failure: %m");
d550 3
a552 5
	if (rootlogin)
		(void) setuid(0);
	else {
		(void) seteuid(pwd->pw_uid);
		(void) setuid(pwd->pw_uid);
d554 1
d559 2
a560 2
	execlp(pwd->pw_shell, tbuf, 0);
	err(1, "%s", pwd->pw_shell);
d657 3
d661 1
a661 1
	if ((fd = open(_PATH_MOTDFILE, O_RDONLY, 0)) < 0)
d692 1
d695 8
a702 4
	if ((fd = open(_PATH_NOLOGIN, O_RDONLY, 0)) >= 0) {
		while ((nchars = read(fd, tbuf, sizeof(tbuf))) > 0)
			(void)write(fileno(stdout), tbuf, nchars);
		sleepexit(0);
d775 2
a776 1
	return (ttyid && (t = getttynam(ttyid)) ? t->ty_type : UNKNOWN);
d793 1
a793 2

	exit(W_EXITCODE(0, signum));
@


1.28
log
@login already decleared in util.h
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.27 1999/08/17 09:13:15 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.27 1999/08/17 09:13:15 millert Exp $";
d267 1
a267 2
		(void)strncpy(tbuf, username, sizeof tbuf-1);
		tbuf[sizeof tbuf-1] = '\0';
d275 1
a275 1
		 * if we have a valid account name, and it doesn't have a
d345 10
a354 1
		if (pwd && !rval && rootlogin && !rootterm(tty)) {
d357 1
a357 1
			    pwd->pw_name);
d361 2
a362 1
				    pwd->pw_name, rusername ? rusername : "",
d367 3
a369 8
				     pwd->pw_name, tty);
			continue;
		}

		if (pwd && !rval)
			break;

		(void)printf("Login incorrect\n");
d470 2
d480 1
a480 1
		(void)strncpy(term, stypeof(tty), sizeof(term));
d534 2
a535 3
	(void)strncpy(tbuf + 1, (p = strrchr(pwd->pw_shell, '/')) ?
	    p + 1 : pwd->pw_shell, sizeof tbuf - 1 - 1);
	tbuf[sizeof tbuf - 1] = '\0';
@


1.27
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.26 1998/07/13 02:11:36 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.26 1998/07/13 02:11:36 millert Exp $";
a100 1
extern void login __P((struct utmp *));
@


1.26
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.25 1998/07/05 20:30:46 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.25 1998/07/05 20:30:46 millert Exp $";
a59 1
#include <sys/file.h>
d64 1
@


1.25
log
@No need to call pwcheck() (and hence crypt()) if the user does not
exist.  The only reason I did that in the first place was to get a
fake s/key challenge.  Now if the use does not exist we just get
the challenge if password was 's/key' else sleep for a bit to make
it look like we are doing a crypt().
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.24 1998/03/26 20:28:11 art Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.24 1998/03/26 20:28:11 art Exp $";
d694 1
a694 1
		(void)lseek(fd, (off_t)pwd->pw_uid * sizeof(ll), L_SET);
d709 2
a710 1
			(void)lseek(fd, (off_t)pwd->pw_uid * sizeof(ll), L_SET);
@


1.24
log
@fix cleaning up of bad environment variables (LD_* and IFS),
-Wall cleanup and add ability to fetch AFS-tokens for those who
happen to have AFS.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.23 1997/11/04 19:01:05 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.23 1997/11/04 19:01:05 millert Exp $";
d318 16
a333 1
			rval = pwcheck(username, p, salt, "*");
@


1.23
log
@Do pwcheck() even if the user does not exist.  This means that if
there is an alternate authentication scheme it will get run
even when the username does not exist, preventing an info gathering
attack.  Short story: for user "imbogus" and pass "s/key" you
will get a faked up s/key prompt.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.22 1997/06/20 04:55:00 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.22 1997/06/20 04:55:00 deraadt Exp $";
d78 1
d98 1
d393 1
a393 1
	if (pwd->pw_change)
d401 2
a402 1
	if (pwd->pw_expire)
d410 1
d444 1
a444 1
	if (!pflag)
d447 1
a447 1
	else {
d479 1
a479 1
	if (rootlogin && fflag == 0)
d486 1
d528 3
d600 1
a600 1
		if (p > nbuf)
d609 1
@


1.22
log
@do not screw up setenv()
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.21 1997/06/02 03:08:55 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.21 1997/06/02 03:08:55 deraadt Exp $";
d315 2
@


1.21
log
@if hostname==domainname and has only one dot, trim less severely for -h option; based on code from wisner@@gryphon.com
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.20 1997/04/19 21:01:12 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.20 1997/04/19 21:01:12 deraadt Exp $";
d120 1
a120 1
char	term[64], *envinit[1], *hostname, *tty;
d439 2
a440 1
		environ = envinit;
@


1.20
log
@strncpy paranoia, how much do you trust getpwent?
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.19 1997/02/16 04:39:07 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.19 1997/02/16 04:39:07 downsj Exp $";
d159 5
d177 1
a177 1
			    strcasecmp(p, domain) == 0)
@


1.19
log
@/sbin/nologin implies hushlogin.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.18 1997/02/04 03:39:11 flipk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.18 1997/02/04 03:39:11 flipk Exp $";
d261 2
a262 1
		(void)strcpy(tbuf, username);
d501 3
a503 2
	(void)strcpy(tbuf + 1, (p = strrchr(pwd->pw_shell, '/')) ?
	    p + 1 : pwd->pw_shell);
@


1.18
log
@make it compile if KERBEROS{,5} not defined
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.17 1997/01/27 20:44:14 dm Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.17 1997/01/27 20:44:14 dm Exp $";
d375 2
a376 1
	quietlog = access(_PATH_HUSHLOGIN, F_OK) == 0;
@


1.17
log
@security
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.16 1997/01/15 23:43:03 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.16 1997/01/15 23:43:03 millert Exp $";
d224 6
a229 1
#if 1 /* Why should anyone with a root instance be able to be root here? */
d231 1
a231 1
#else
a246 1
#endif
@


1.16
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.15 1996/12/22 03:25:55 tholo Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.15 1996/12/22 03:25:55 tholo Exp $";
d224 3
d242 1
@


1.15
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.14 1996/12/04 04:04:41 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.14 1996/12/04 04:04:41 millert Exp $";
d162 1
a162 1
	while ((ch = getopt(argc, argv, "fh:u:p")) != EOF)
@


1.14
log
@Implement -u (remote user) option for login (only root may use it).
We now store remote user in failedlogin struct too.
Also add REMOTEHOST and REMOTEUSER environmental vars.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.13 1996/11/09 20:17:17 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.13 1996/11/09 20:17:17 millert Exp $";
d414 1
d500 2
a501 1
	else
d503 1
@


1.13
log
@Adds support for logging and reporting on failed login attempts
via sparse file /var/log/failedlogin.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.12 1996/11/09 07:43:22 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.12 1996/11/09 07:43:22 millert Exp $";
d101 1
a101 1
extern void log_failedlogin __P((uid_t, char *, char *));
d120 2
a121 1
char	term[64], *envinit[1], *hostname, *tty, *username = NULL;
d133 1
a133 1
	int ask, ch, cnt, fflag, hflag, pflag, quietlog, rootlogin, rval;
d162 1
a162 1
	while ((ch = getopt(argc, argv, "fh:p")) != EOF)
d179 6
d320 3
a322 2
				    "LOGIN %s REFUSED FROM %s ON TTY %s",
				    pwd->pw_name, hostname, tty);
d336 1
a336 1
			log_failedlogin(pwd->pw_uid, hostname, tty);
d442 4
d458 3
a460 2
			syslog(LOG_NOTICE, "ROOT LOGIN (%s) ON %s FROM %s",
			    username, tty, hostname);
d654 3
d658 1
a658 1
					(void)printf("from %.*s\n",
d661 1
a661 4
				else
					(void)printf("on %.*s\n",
					    (int)sizeof(ll.ll_line),
					    ll.ll_line);
d682 3
a684 2
		syslog(LOG_NOTICE, "%d LOGIN FAILURE%s FROM %s",
		    failures, failures > 1 ? "S" : "", hostname);
d686 4
a689 2
		    "%d LOGIN FAILURE%s FROM %s, %s",
		    failures, failures > 1 ? "S" : "", hostname, name);
@


1.12
log
@Ensure that username is initialized to NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.11 1996/11/09 06:39:41 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.11 1996/11/09 06:39:41 millert Exp $";
d100 2
d327 2
d393 2
@


1.11
log
@Log failures if user closes network session while in username/password
prompt phase.  Previously the SIGHUP was not catched and so failures
were not logged.  Noticed by bitblt.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.10 1996/11/05 18:23:49 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.10 1996/11/05 18:23:49 deraadt Exp $";
d118 1
a118 1
char	term[64], *envinit[1], *hostname, *username, *tty;
d201 1
a201 1
	if (tty = strrchr(ttyn, '/'))
d246 1
a246 1
		if (pwd = getpwnam(username))
@


1.10
log
@dialup stuff is garbage
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.9 1996/10/31 03:22:10 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.9 1996/10/31 03:22:10 millert Exp $";
d61 1
d88 1
d140 1
d380 1
d695 10
@


1.9
log
@Strip out $LD_* and $IFS if given -p.  Code taken from telnetd.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.8 1996/10/23 01:28:56 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.8 1996/10/23 01:28:56 millert Exp $";
a431 3

	if (tty[sizeof("tty")-1] == 'd')
		syslog(LOG_INFO, "DIALUP %s, %s", tty, pwd->pw_name);
@


1.8
log
@skey_authenticate() now fakes up a challenge if user does not
have an entry in the keys file.  Don't want to give info to
information gathering attack.
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.7 1996/09/18 20:39:06 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.7 1996/09/18 20:39:06 deraadt Exp $";
d406 10
@


1.7
log
@block info gathering attack; netbsd pr#2768; daw@@panix.com
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.6 1996/07/31 12:21:43 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.6 1996/07/31 12:21:43 deraadt Exp $";
d481 1
a481 3
	if (strcasecmp(p, "s/key") == 0) {
		if (skey_haskey(user))
			return 1;
a482 1
	}
@


1.6
log
@fbtab support from wietse
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.5 1996/07/20 09:10:59 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.5 1996/07/20 09:10:59 deraadt Exp $";
d482 1
a482 2
		if (skey_haskey(user)) {
			fprintf(stderr, "You have no s/key. ");
d484 1
a484 3
		} else {
			return skey_authenticate(user);
		}
@


1.5
log
@use euid/egid to get into homedir; from dean@@fsa.ca
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.4 1996/06/26 05:36:01 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.4 1996/06/26 05:36:01 deraadt Exp $";
d386 2
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: login.c,v 1.13 1996/05/15 23:50:16 jtc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: login.c,v 1.13 1996/05/15 23:50:16 jtc Exp $";
d341 3
d353 3
@


1.3
log
@libutil
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: login.c,v 1.13 1996/05/15 23:50:16 jtc Exp $";
@


1.2
log
@do not credit UCB if we are not prepared to credit everyone
@
text
@d1 1
a1 1
/*	$NetBSD: login.c,v 1.12 1994/12/23 06:53:01 jtc Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: login.c,v 1.12 1994/12/23 06:53:01 jtc Exp $";
d75 1
@


1.1
log
@Initial revision
@
text
@d430 1
d435 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
