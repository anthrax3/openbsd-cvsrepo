head	1.12;
access;
symbols
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2001.06.28.22.45.35;	author millert;	state dead;
branches;
next	1.11;

1.11
date	2000.12.02.22.44.36;	author hin;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.17.16.43.14;	author millert;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	99.11.24.16.08.18;	author art;	state Exp;
branches;
next	1.8;

1.8
date	99.11.11.15.28.15;	author art;	state Exp;
branches;
next	1.7;

1.7
date	98.07.10.08.06.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.03.26.20.28.09;	author art;	state Exp;
branches;
next	1.5;

1.5
date	97.06.29.11.10.33;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.01.27.20.44.16;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.36.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.30.09.22.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.34;	author deraadt;	state Exp;
branches;
next	;

1.10.2.1
date	2000.12.08.09.05.26;	author hin;	state Exp;
branches;
next	;


desc
@@


1.12
log
@No longer used now that we do BSD auth
@
text
@/*	$OpenBSD: klogin.c,v 1.11 2000/12/02 22:44:36 hin Exp $	*/
/*	$NetBSD: klogin.c,v 1.7 1996/05/21 22:07:04 mrg Exp $	*/

/*-
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)klogin.c	8.3 (Berkeley) 4/2/94";
#endif
static char rcsid[] = "$OpenBSD: klogin.c,v 1.11 2000/12/02 22:44:36 hin Exp $";
#endif /* not lint */

#ifdef KERBEROS
#include <sys/param.h>
#include <sys/syslog.h>
#include <des.h>
#include <kerberosIV/krb.h>
#include <kerberosIV/kafs.h>

#include <err.h>
#include <netdb.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#define	INITIAL_TICKET	"krbtgt"
#define	VERIFY_SERVICE	"rcmd"

extern int notickets;
extern char *krbtkfile_env;
extern char *tty;

static char tkt_location[MAXPATHLEN];  /* a pointer to this is returned... */

/*
 * Attempt to log the user in using Kerberos authentication
 *
 * return 0 on success (will be logged in)
 *	  1 if Kerberos failed (try local password in login)
 */
int
klogin(pw, instance, localhost, password)
	struct passwd *pw;
	char *instance, *localhost, *password;
{
	int kerror, fd;
	AUTH_DAT authdata;
	KTEXT_ST ticket;
	struct hostent *hp;
	unsigned long faddr;
	char realm[REALM_SZ], savehost[MAXHOSTNAMELEN];
	char *krb_get_phost();

#ifdef SKEY
	/*
	 * We don't do s/key challenge and Kerberos at the same time
	 */
	if (strcasecmp(password, "s/key") == 0) {
	    return (1);
	}
#endif

	/* If no srvtab file exists, fail immediatly. This will make
	 * login _much_ quicker on systems with sporadical contact with
	 * the outside world.
	 * We should really change the semantics for enabling kerberos.
	 */
	if((fd = open(KEYFILE, O_RDONLY, 0)) < 0)
		return 1;
	close(fd);

	/*
	 * Root logins don't use Kerberos (or at least shouldn't be
	 * sending kerberos passwords around in cleartext), so don't
	 * allow any root logins here (keeping in mind that we only
	 * get here with a password).
	 *
	 * If we have a realm, try getting a ticket-granting ticket
	 * and using it to authenticate.  Otherwise, return
	 * failure so that we can try the normal passwd file
	 * for a password.  If that's ok, log the user in
	 * without issuing any tickets.
	 */
	if (pw->pw_uid == 0 || krb_get_lrealm(realm, 0) != KSUCCESS)
		return (1);

	/*
	 * get TGT for local realm
	 * tickets are stored in a file named TKT_ROOT plus uid plus tty
	 * except for user.root tickets.
	 */

	if (strcmp(instance, "root") != 0)
		snprintf(tkt_location, sizeof(tkt_location), "%s%d",
			TKT_ROOT, pw->pw_uid);
	else
		snprintf(tkt_location, sizeof(tkt_location), "%s_root_%d.%s",
			TKT_ROOT, pw->pw_uid, tty);
	krbtkfile_env = tkt_location;
	(void)krb_set_tkt_string(tkt_location);

	/*
	 * Set real as well as effective ID to 0 for the moment,
	 * to make the kerberos library do the right thing.
	 */
	if (setuid(0) < 0) {
		warnx("setuid");
		return (1);
	}
	kerror = krb_get_pw_in_tkt(pw->pw_name, instance,
		    realm, INITIAL_TICKET, realm, DEFAULT_TKT_LIFE, password);
	/*
	 * If we got a TGT, get a local "rcmd" ticket and check it so as to
	 * ensure that we are not talking to a bogus Kerberos server.
	 *
	 * There are 2 cases where we still allow a login:
	 *	1: the VERIFY_SERVICE doesn't exist in the KDC
	 *	2: local host has no srvtab, as (hopefully) indicated by a
	 *	   return value of RD_AP_UNDEC from krb_rd_req().
	 */
	if (kerror != INTK_OK) {
		if (kerror != INTK_BADPW && kerror != KDC_PR_UNKNOWN) {
			syslog(LOG_ERR, "Kerberos intkt error: %s",
			    krb_err_txt[kerror]);
			dest_tkt();
		}
		return (1);
	}

	/*
	 * Set the owner of the ticket file to root but bail if someone
	 * has nefariously swapped a link in place of the file.
	 */
	fd = open(TKT_FILE, O_RDWR|O_NOFOLLOW, 0);
	if (fd == -1) {
		syslog(LOG_ERR, "unable to open ticket file: %m");
		dest_tkt();
		return (1);
	}
	if (fchown(fd, pw->pw_uid, pw->pw_gid) < 0)
		syslog(LOG_ERR, "fchown tkfile (%s): %m", TKT_FILE);
	close(fd);

	(void)strlcpy(savehost, krb_get_phost(localhost), sizeof(savehost));

	/*
	 * if the "VERIFY_SERVICE" doesn't exist in the KDC for this host,
	 * still allow login with tickets, but log the error condition.
	 */

	kerror = krb_mk_req(&ticket, VERIFY_SERVICE, savehost, realm, 33);
	if (kerror == KDC_PR_UNKNOWN) {
		syslog(LOG_NOTICE,
    		    "warning: TGT not verified (%s); %s.%s not registered, or srvtab is wrong?",
		    krb_err_txt[kerror], VERIFY_SERVICE, savehost);
		notickets = 0;
		/*
		 * but for security, don't allow root instances in under
		 * this condition!
		 */
		if (strcmp(instance, "root") == 0) {
		  syslog(LOG_ERR, "Kerberos %s root instance login refused",
			 pw->pw_name);
		  dest_tkt();
		  return (1);
		}
		/* Otherwise, leave ticket around, but make sure
		 * password matches the Unix password. */
		return (1);
	}

	if (kerror != KSUCCESS) {
		warnx("unable to use TGT: (%s)", krb_err_txt[kerror]);
		syslog(LOG_NOTICE, "unable to use TGT: (%s)",
		    krb_err_txt[kerror]);
		dest_tkt();
		return (1);
	}

	if (!(hp = gethostbyname(localhost))) {
		syslog(LOG_ERR, "couldn't get local host address");
		dest_tkt();
		return (1);
	}

	memmove((void *)&faddr, (void *)hp->h_addr, sizeof(faddr));

	kerror = krb_rd_req(&ticket, VERIFY_SERVICE, savehost, faddr,
	    &authdata, "");

	if (kerror == KSUCCESS) {
		notickets = 0;
		return (0);
	}

	/* undecipherable: probably didn't have a srvtab on the local host */
	if (kerror == RD_AP_UNDEC) {
		syslog(LOG_NOTICE, "krb_rd_req: (%s)", krb_err_txt[kerror]);
		dest_tkt();
		return (1);
	}
	/* failed for some other reason */
	warnx("unable to verify %s ticket: (%s)", VERIFY_SERVICE,
	    krb_err_txt[kerror]);
	syslog(LOG_NOTICE, "couldn't verify %s ticket: %s", VERIFY_SERVICE,
	    krb_err_txt[kerror]);
	dest_tkt();
	return (1);
}

void
kgettokens(homedir)
	char *homedir;
{
	/* buy AFS-tokens for homedir */
	if (k_hasafs()) { 
		char cell[128];
		k_setpag();
		if (k_afs_cell_of_file(homedir, 
				       cell, sizeof(cell)) == 0)
			krb_afslog(cell, 0);
		krb_afslog(0, 0);
	}
}

void
kdestroy()
{
        char *file = krbtkfile_env;
	int i, fd;
	extern int errno;
	struct stat statb;
	char buf[BUFSIZ];

	if (k_hasafs())
	    k_unlog();

	if (krbtkfile_env == NULL)
	    return;

	errno = 0;
	if (lstat(file, &statb) < 0)
	    goto out;

	if (!(statb.st_mode & S_IFREG)
#ifdef notdef
	    || statb.st_mode & 077
#endif
	    )
		goto out;

	if ((fd = open(file, O_RDWR, 0)) < 0)
	    goto out;

	bzero(buf, sizeof(buf));

	for (i = 0; i < statb.st_size; i += BUFSIZ)
	    if (write(fd, buf, BUFSIZ) != BUFSIZ) {
		(void) fsync(fd);
		(void) close(fd);
		goto out;
	    }

	(void) fsync(fd);
	(void) close(fd);

	(void) unlink(file);

out:
	if (errno != 0) return;

	return;
}
#endif
@


1.11
log
@Check for symlinks before overwriting kerberos ticket files.
While i'm at it, make sure not to use Kerberos at all if there is no
local srvtab.
Based on patch from Todd Miller.  Reported by <jouko@@solutions.fi>.
@
text
@d1 1
a1 1
/*	$OpenBSD: klogin.c,v 1.10 2000/07/17 16:43:14 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: klogin.c,v 1.10 2000/07/17 16:43:14 millert Exp $";
@


1.10
log
@ o use strlcpy() where sensible
 o when trying to login as root on a non-secure tty always say
   "login refused" regardless of whether the password is correct or not
@
text
@d1 1
a1 1
/*	$OpenBSD: klogin.c,v 1.9 1999/11/24 16:08:18 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: klogin.c,v 1.9 1999/11/24 16:08:18 art Exp $";
d83 1
a83 1
	int kerror;
d100 9
d131 2
a132 2
		snprintf(tkt_location, sizeof(tkt_location), "%s%d.%s",
			TKT_ROOT, pw->pw_uid, tty);
d167 13
a179 2
	if (chown(TKT_FILE, pw->pw_uid, pw->pw_gid) < 0)
		syslog(LOG_ERR, "chown tkfile (%s): %m", TKT_FILE);
@


1.10.2.1
log
@Bring recent kerberos fix into -stable.
@
text
@d1 1
a1 1
/*	$OpenBSD: klogin.c,v 1.11 2000/12/02 22:44:36 hin Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: klogin.c,v 1.11 2000/12/02 22:44:36 hin Exp $";
d83 1
a83 1
	int kerror, fd;
a99 9
	/* If no srvtab file exists, fail immediatly. This will make
	 * login _much_ quicker on systems with sporadical contact with
	 * the outside world.
	 * We should really change the semantics for enabling kerberos.
	 */
	if((fd = open(KEYFILE, O_RDONLY, 0)) < 0)
		return 1;
	close(fd);

d122 2
a123 2
		snprintf(tkt_location, sizeof(tkt_location), "%s%d",
			TKT_ROOT, pw->pw_uid);
d158 2
a159 13
	/*
	 * Set the owner of the ticket file to root but bail if someone
	 * has nefariously swapped a link in place of the file.
	 */
	fd = open(TKT_FILE, O_RDWR|O_NOFOLLOW, 0);
	if (fd == -1) {
		syslog(LOG_ERR, "unable to open ticket file: %m");
		dest_tkt();
		return (1);
	}
	if (fchown(fd, pw->pw_uid, pw->pw_gid) < 0)
		syslog(LOG_ERR, "fchown tkfile (%s): %m", TKT_FILE);
	close(fd);
@


1.9
log
@We won't have the tickets in shared memory, remove dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: klogin.c,v 1.8 1999/11/11 15:28:15 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: klogin.c,v 1.8 1999/11/11 15:28:15 art Exp $";
d161 1
a161 2
	(void)strncpy(savehost, krb_get_phost(localhost), sizeof(savehost));
	savehost[sizeof(savehost)-1] = NULL;
@


1.8
log
@Use snprintf instead of sprintf and sizeof(foo) instead of hardcoded sizes.
@
text
@d1 1
a1 1
/*	$OpenBSD: klogin.c,v 1.7 1998/07/10 08:06:28 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: klogin.c,v 1.7 1998/07/10 08:06:28 deraadt Exp $";
a251 3
#ifdef TKT_SHMEM
	char shmidname[MAXPATHLEN];
#endif /* TKT_SHMEM */
d289 1
a289 9
#ifdef TKT_SHMEM
	/* 
	 * handle the shared memory case 
	 */
	(void) strcpy(shmidname, file);
	(void) strcat(shmidname, ".shm");
	if (krb_shm_dest(shmidname) != KSUCCESS)
	    return;
#endif /* TKT_SHMEM */
@


1.7
log
@do not syslog() with "\n"; skipped smtpd/named/ipmon; 12 minutes of dabbling
@
text
@d1 1
a1 1
/*	$OpenBSD: klogin.c,v 1.6 1998/03/26 20:28:09 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: klogin.c,v 1.6 1998/03/26 20:28:09 art Exp $";
d122 2
a123 2
		(void)sprintf(tkt_location, "%s%d.%s",
			      TKT_ROOT, pw->pw_uid, tty);
d125 2
a126 2
		(void)sprintf(tkt_location, "%s_root_%d.%s",
			      TKT_ROOT, pw->pw_uid, tty);
d276 1
a276 1
	bzero(buf, BUFSIZ);
@


1.6
log
@fix cleaning up of bad environment variables (LD_* and IFS),
-Wall cleanup and add ability to fetch AFS-tokens for those who
happen to have AFS.
@
text
@d1 1
a1 1
/*	$OpenBSD: klogin.c,v 1.5 1997/06/29 11:10:33 provos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: klogin.c,v 1.5 1997/06/29 11:10:33 provos Exp $";
d180 1
a180 1
		  syslog(LOG_ERR, "Kerberos %s root instance login refused\n",
d216 1
a216 1
		syslog(LOG_NOTICE, "krb_rd_req: (%s)\n", krb_err_txt[kerror]);
@


1.5
log
@new location of des.h
@
text
@d1 1
a1 1
/*	$OpenBSD: klogin.c,v 1.4 1997/01/27 20:44:16 dm Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: klogin.c,v 1.4 1997/01/27 20:44:16 dm Exp $";
d49 1
d230 15
d255 3
@


1.4
log
@security
@
text
@d1 1
a1 1
/*	$OpenBSD: klogin.c,v 1.3 1996/06/26 05:36:00 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: klogin.c,v 1.3 1996/06/26 05:36:00 deraadt Exp $";
d47 1
a47 1
#include <kerberosIV/des.h>
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: klogin.c,v 1.7 1996/05/21 22:07:04 mrg Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: klogin.c,v 1.7 1996/05/21 22:07:04 mrg Exp $";
d100 5
a104 1
	 * Root logins don't use Kerberos.
d111 1
a111 2
	if (strcmp(pw->pw_name, "root") == 0 ||
	    krb_get_lrealm(realm, 0) != KSUCCESS)
d184 3
a186 1
		return (0);
@


1.2
log
@= -> ==
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: klogin.c,v 1.7 1996/05/21 22:07:04 mrg Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: klogin.c,v 1.6 1995/03/08 19:41:36 brezak Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: klogin.c,v 1.6 1995/03/08 19:41:36 brezak Exp $";
d208 1
a208 1
	if (kerror = RD_AP_UNDEC) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
