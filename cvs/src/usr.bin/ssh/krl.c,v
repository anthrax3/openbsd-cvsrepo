head	1.39;
access;
symbols
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.37.0.6
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.33.0.2
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10;
locks; strict;
comment	@ * @;


1.39
date	2017.03.10.07.18.32;	author dtucker;	state Exp;
branches;
next	1.38;
commitid	xxUKK3dxeafjPrQM;

1.38
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	ZllbGwdb0fOmLhjK;

1.37
date	2015.12.31.00.33.52;	author djm;	state Exp;
branches;
next	1.36;
commitid	hwGj3C9aHCUCCXob;

1.36
date	2015.12.11.04.21.12;	author mmcc;	state Exp;
branches;
next	1.35;
commitid	frWDG3VpknGQboCf;

1.35
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.34;
commitid	K3glY441IowbrjDE;

1.34
date	2015.09.02.07.51.12;	author jsg;	state Exp;
branches;
next	1.33;
commitid	Q6Vkxj42ZGWgteg8;

1.33
date	2015.07.03.03.43.18;	author djm;	state Exp;
branches;
next	1.32;
commitid	cnvu1kGgoFFYv6D3;

1.32
date	2015.06.24.23.47.23;	author djm;	state Exp;
branches;
next	1.31;
commitid	uJs2WB1G075ka5no;

1.31
date	2015.01.30.01.10.33;	author djm;	state Exp;
branches;
next	1.30;
commitid	TRmit1x08XMcp7vb;

1.30
date	2015.01.26.02.59.11;	author djm;	state Exp;
branches;
next	1.29;
commitid	IWERLH63u2Z5LhgY;

1.29
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	cBx23BaCk6gYBpRj;

1.28
date	2015.01.19.17.35.48;	author djm;	state Exp;
branches;
next	1.27;
commitid	dfgGpnTb5szVs42x;

1.27
date	2015.01.18.14.01.00;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	4J3yEcjaeBConvdP;

1.26
date	2015.01.14.15.02.39;	author djm;	state Exp;
branches;
next	1.25;
commitid	2uJ80mLmhI8Cczcv;

1.25
date	2015.01.13.19.04.35;	author djm;	state Exp;
branches;
next	1.24;
commitid	n8eGVvA42XsH8sHc;

1.24
date	2015.01.12.19.22.46;	author markus;	state Exp;
branches;
next	1.23;
commitid	1HbP9wOnQxAJE8D5;

1.23
date	2015.01.12.14.05.19;	author markus;	state Exp;
branches;
next	1.22;
commitid	unH9oEs9qucSUo2c;

1.22
date	2015.01.08.10.14.08;	author djm;	state Exp;
branches;
next	1.21;
commitid	397Wklb10N5bP6VW;

1.21
date	2014.12.21.22.27.56;	author djm;	state Exp;
branches;
next	1.20;
commitid	EbtriidyZdsmXksl;

1.20
date	2014.12.04.01.49.59;	author djm;	state Exp;
branches;
next	1.19;
commitid	9wjPHRbt4KgyR5np;

1.19
date	2014.11.21.01.00.38;	author djm;	state Exp;
branches;
next	1.18;
commitid	LW6V2n5XzdSaGqpK;

1.18
date	2014.11.17.00.21.40;	author djm;	state Exp;
branches;
next	1.17;
commitid	YGuoa9IGlYtTu30p;

1.17
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.16;
commitid	1h9UxAQmwdaqUzyX;

1.16
date	2014.06.24.00.52.02;	author djm;	state Exp;
branches;
next	1.15;
commitid	rSzlCYO933VRgr8t;

1.15
date	2014.04.28.03.09.18;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2013.07.20.22.20.42;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.20.19.15.06;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2013.04.05.00.14.00;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2013.02.19.02.12.47;	author dtucker;	state Exp;
branches;
next	1.9;

1.9
date	2013.01.27.10.06.12;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2013.01.25.10.22.19;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2013.01.25.05.00.27;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2013.01.24.22.08.56;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2013.01.24.21.45.37;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2013.01.19.12.34.55;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2013.01.18.03.00.32;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2013.01.18.00.24.58;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2013.01.17.23.00.01;	author djm;	state Exp;
branches;
next	;


desc
@@


1.39
log
@krl.c
@
text
@/*
 * Copyright (c) 2012 Damien Miller <djm@@mindrot.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* $OpenBSD: krl.c,v 1.38 2016/09/12 01:22:38 deraadt Exp $ */

#include <sys/types.h>
#include <sys/tree.h>
#include <sys/queue.h>

#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "sshbuf.h"
#include "ssherr.h"
#include "sshkey.h"
#include "authfile.h"
#include "misc.h"
#include "log.h"
#include "digest.h"
#include "bitmap.h"

#include "krl.h"

/* #define DEBUG_KRL */
#ifdef DEBUG_KRL
# define KRL_DBG(x) debug3 x
#else
# define KRL_DBG(x)
#endif

/*
 * Trees of revoked serial numbers, key IDs and keys. This allows
 * quick searching, querying and producing lists in canonical order.
 */

/* Tree of serial numbers. XXX make smarter: really need a real sparse bitmap */
struct revoked_serial {
	u_int64_t lo, hi;
	RB_ENTRY(revoked_serial) tree_entry;
};
static int serial_cmp(struct revoked_serial *a, struct revoked_serial *b);
RB_HEAD(revoked_serial_tree, revoked_serial);
RB_GENERATE_STATIC(revoked_serial_tree, revoked_serial, tree_entry, serial_cmp);

/* Tree of key IDs */
struct revoked_key_id {
	char *key_id;
	RB_ENTRY(revoked_key_id) tree_entry;
};
static int key_id_cmp(struct revoked_key_id *a, struct revoked_key_id *b);
RB_HEAD(revoked_key_id_tree, revoked_key_id);
RB_GENERATE_STATIC(revoked_key_id_tree, revoked_key_id, tree_entry, key_id_cmp);

/* Tree of blobs (used for keys and fingerprints) */
struct revoked_blob {
	u_char *blob;
	size_t len;
	RB_ENTRY(revoked_blob) tree_entry;
};
static int blob_cmp(struct revoked_blob *a, struct revoked_blob *b);
RB_HEAD(revoked_blob_tree, revoked_blob);
RB_GENERATE_STATIC(revoked_blob_tree, revoked_blob, tree_entry, blob_cmp);

/* Tracks revoked certs for a single CA */
struct revoked_certs {
	struct sshkey *ca_key;
	struct revoked_serial_tree revoked_serials;
	struct revoked_key_id_tree revoked_key_ids;
	TAILQ_ENTRY(revoked_certs) entry;
};
TAILQ_HEAD(revoked_certs_list, revoked_certs);

struct ssh_krl {
	u_int64_t krl_version;
	u_int64_t generated_date;
	u_int64_t flags;
	char *comment;
	struct revoked_blob_tree revoked_keys;
	struct revoked_blob_tree revoked_sha1s;
	struct revoked_certs_list revoked_certs;
};

/* Return equal if a and b overlap */
static int
serial_cmp(struct revoked_serial *a, struct revoked_serial *b)
{
	if (a->hi >= b->lo && a->lo <= b->hi)
		return 0;
	return a->lo < b->lo ? -1 : 1;
}

static int
key_id_cmp(struct revoked_key_id *a, struct revoked_key_id *b)
{
	return strcmp(a->key_id, b->key_id);
}

static int
blob_cmp(struct revoked_blob *a, struct revoked_blob *b)
{
	int r;

	if (a->len != b->len) {
		if ((r = memcmp(a->blob, b->blob, MINIMUM(a->len, b->len))) != 0)
			return r;
		return a->len > b->len ? 1 : -1;
	} else
		return memcmp(a->blob, b->blob, a->len);
}

struct ssh_krl *
ssh_krl_init(void)
{
	struct ssh_krl *krl;

	if ((krl = calloc(1, sizeof(*krl))) == NULL)
		return NULL;
	RB_INIT(&krl->revoked_keys);
	RB_INIT(&krl->revoked_sha1s);
	TAILQ_INIT(&krl->revoked_certs);
	return krl;
}

static void
revoked_certs_free(struct revoked_certs *rc)
{
	struct revoked_serial *rs, *trs;
	struct revoked_key_id *rki, *trki;

	RB_FOREACH_SAFE(rs, revoked_serial_tree, &rc->revoked_serials, trs) {
		RB_REMOVE(revoked_serial_tree, &rc->revoked_serials, rs);
		free(rs);
	}
	RB_FOREACH_SAFE(rki, revoked_key_id_tree, &rc->revoked_key_ids, trki) {
		RB_REMOVE(revoked_key_id_tree, &rc->revoked_key_ids, rki);
		free(rki->key_id);
		free(rki);
	}
	sshkey_free(rc->ca_key);
}

void
ssh_krl_free(struct ssh_krl *krl)
{
	struct revoked_blob *rb, *trb;
	struct revoked_certs *rc, *trc;

	if (krl == NULL)
		return;

	free(krl->comment);
	RB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {
		RB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);
		free(rb->blob);
		free(rb);
	}
	RB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {
		RB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);
		free(rb->blob);
		free(rb);
	}
	TAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {
		TAILQ_REMOVE(&krl->revoked_certs, rc, entry);
		revoked_certs_free(rc);
	}
}

void
ssh_krl_set_version(struct ssh_krl *krl, u_int64_t version)
{
	krl->krl_version = version;
}

int
ssh_krl_set_comment(struct ssh_krl *krl, const char *comment)
{
	free(krl->comment);
	if ((krl->comment = strdup(comment)) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	return 0;
}

/*
 * Find the revoked_certs struct for a CA key. If allow_create is set then
 * create a new one in the tree if one did not exist already.
 */
static int
revoked_certs_for_ca_key(struct ssh_krl *krl, const struct sshkey *ca_key,
    struct revoked_certs **rcp, int allow_create)
{
	struct revoked_certs *rc;
	int r;

	*rcp = NULL;
	TAILQ_FOREACH(rc, &krl->revoked_certs, entry) {
		if ((ca_key == NULL && rc->ca_key == NULL) ||
		    sshkey_equal(rc->ca_key, ca_key)) {
			*rcp = rc;
			return 0;
		}
	}
	if (!allow_create)
		return 0;
	/* If this CA doesn't exist in the list then add it now */
	if ((rc = calloc(1, sizeof(*rc))) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if (ca_key == NULL)
		rc->ca_key = NULL;
	else if ((r = sshkey_from_private(ca_key, &rc->ca_key)) != 0) {
		free(rc);
		return r;
	}
	RB_INIT(&rc->revoked_serials);
	RB_INIT(&rc->revoked_key_ids);
	TAILQ_INSERT_TAIL(&krl->revoked_certs, rc, entry);
	KRL_DBG(("%s: new CA %s", __func__,
	    ca_key == NULL ? "*" : sshkey_type(ca_key)));
	*rcp = rc;
	return 0;
}

static int
insert_serial_range(struct revoked_serial_tree *rt, u_int64_t lo, u_int64_t hi)
{
	struct revoked_serial rs, *ers, *crs, *irs;

	KRL_DBG(("%s: insert %llu:%llu", __func__, lo, hi));
	memset(&rs, 0, sizeof(rs));
	rs.lo = lo;
	rs.hi = hi;
	ers = RB_NFIND(revoked_serial_tree, rt, &rs);
	if (ers == NULL || serial_cmp(ers, &rs) != 0) {
		/* No entry matches. Just insert */
		if ((irs = malloc(sizeof(rs))) == NULL)
			return SSH_ERR_ALLOC_FAIL;
		memcpy(irs, &rs, sizeof(*irs));
		ers = RB_INSERT(revoked_serial_tree, rt, irs);
		if (ers != NULL) {
			KRL_DBG(("%s: bad: ers != NULL", __func__));
			/* Shouldn't happen */
			free(irs);
			return SSH_ERR_INTERNAL_ERROR;
		}
		ers = irs;
	} else {
		KRL_DBG(("%s: overlap found %llu:%llu", __func__,
		    ers->lo, ers->hi));
		/*
		 * The inserted entry overlaps an existing one. Grow the
		 * existing entry.
		 */
		if (ers->lo > lo)
			ers->lo = lo;
		if (ers->hi < hi)
			ers->hi = hi;
	}

	/*
	 * The inserted or revised range might overlap or abut adjacent ones;
	 * coalesce as necessary.
	 */

	/* Check predecessors */
	while ((crs = RB_PREV(revoked_serial_tree, rt, ers)) != NULL) {
		KRL_DBG(("%s: pred %llu:%llu", __func__, crs->lo, crs->hi));
		if (ers->lo != 0 && crs->hi < ers->lo - 1)
			break;
		/* This entry overlaps. */
		if (crs->lo < ers->lo) {
			ers->lo = crs->lo;
			KRL_DBG(("%s: pred extend %llu:%llu", __func__,
			    ers->lo, ers->hi));
		}
		RB_REMOVE(revoked_serial_tree, rt, crs);
		free(crs);
	}
	/* Check successors */
	while ((crs = RB_NEXT(revoked_serial_tree, rt, ers)) != NULL) {
		KRL_DBG(("%s: succ %llu:%llu", __func__, crs->lo, crs->hi));
		if (ers->hi != (u_int64_t)-1 && crs->lo > ers->hi + 1)
			break;
		/* This entry overlaps. */
		if (crs->hi > ers->hi) {
			ers->hi = crs->hi;
			KRL_DBG(("%s: succ extend %llu:%llu", __func__,
			    ers->lo, ers->hi));
		}
		RB_REMOVE(revoked_serial_tree, rt, crs);
		free(crs);
	}
	KRL_DBG(("%s: done, final %llu:%llu", __func__, ers->lo, ers->hi));
	return 0;
}

int
ssh_krl_revoke_cert_by_serial(struct ssh_krl *krl, const struct sshkey *ca_key,
    u_int64_t serial)
{
	return ssh_krl_revoke_cert_by_serial_range(krl, ca_key, serial, serial);
}

int
ssh_krl_revoke_cert_by_serial_range(struct ssh_krl *krl,
    const struct sshkey *ca_key, u_int64_t lo, u_int64_t hi)
{
	struct revoked_certs *rc;
	int r;

	if (lo > hi || lo == 0)
		return SSH_ERR_INVALID_ARGUMENT;
	if ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)
		return r;
	return insert_serial_range(&rc->revoked_serials, lo, hi);
}

int
ssh_krl_revoke_cert_by_key_id(struct ssh_krl *krl, const struct sshkey *ca_key,
    const char *key_id)
{
	struct revoked_key_id *rki, *erki;
	struct revoked_certs *rc;
	int r;

	if ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)
		return r;

	KRL_DBG(("%s: revoke %s", __func__, key_id));
	if ((rki = calloc(1, sizeof(*rki))) == NULL ||
	    (rki->key_id = strdup(key_id)) == NULL) {
		free(rki);
		return SSH_ERR_ALLOC_FAIL;
	}
	erki = RB_INSERT(revoked_key_id_tree, &rc->revoked_key_ids, rki);
	if (erki != NULL) {
		free(rki->key_id);
		free(rki);
	}
	return 0;
}

/* Convert "key" to a public key blob without any certificate information */
static int
plain_key_blob(const struct sshkey *key, u_char **blob, size_t *blen)
{
	struct sshkey *kcopy;
	int r;

	if ((r = sshkey_from_private(key, &kcopy)) != 0)
		return r;
	if (sshkey_is_cert(kcopy)) {
		if ((r = sshkey_drop_cert(kcopy)) != 0) {
			sshkey_free(kcopy);
			return r;
		}
	}
	r = sshkey_to_blob(kcopy, blob, blen);
	sshkey_free(kcopy);
	return r;
}

/* Revoke a key blob. Ownership of blob is transferred to the tree */
static int
revoke_blob(struct revoked_blob_tree *rbt, u_char *blob, size_t len)
{
	struct revoked_blob *rb, *erb;

	if ((rb = calloc(1, sizeof(*rb))) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	rb->blob = blob;
	rb->len = len;
	erb = RB_INSERT(revoked_blob_tree, rbt, rb);
	if (erb != NULL) {
		free(rb->blob);
		free(rb);
	}
	return 0;
}

int
ssh_krl_revoke_key_explicit(struct ssh_krl *krl, const struct sshkey *key)
{
	u_char *blob;
	size_t len;
	int r;

	debug3("%s: revoke type %s", __func__, sshkey_type(key));
	if ((r = plain_key_blob(key, &blob, &len)) != 0)
		return r;
	return revoke_blob(&krl->revoked_keys, blob, len);
}

int
ssh_krl_revoke_key_sha1(struct ssh_krl *krl, const struct sshkey *key)
{
	u_char *blob;
	size_t len;
	int r;

	debug3("%s: revoke type %s by sha1", __func__, sshkey_type(key));
	if ((r = sshkey_fingerprint_raw(key, SSH_DIGEST_SHA1,
	    &blob, &len)) != 0)
		return r;
	return revoke_blob(&krl->revoked_sha1s, blob, len);
}

int
ssh_krl_revoke_key(struct ssh_krl *krl, const struct sshkey *key)
{
	if (!sshkey_is_cert(key))
		return ssh_krl_revoke_key_sha1(krl, key);

	if (key->cert->serial == 0) {
		return ssh_krl_revoke_cert_by_key_id(krl,
		    key->cert->signature_key,
		    key->cert->key_id);
	} else {
		return ssh_krl_revoke_cert_by_serial(krl,
		    key->cert->signature_key,
		    key->cert->serial);
	}
}

/*
 * Select the most compact section type to emit next in a KRL based on
 * the current section type, the run length of contiguous revoked serial
 * numbers and the gaps from the last and to the next revoked serial.
 * Applies a mostly-accurate bit cost model to select the section type
 * that will minimise the size of the resultant KRL.
 */
static int
choose_next_state(int current_state, u_int64_t contig, int final,
    u_int64_t last_gap, u_int64_t next_gap, int *force_new_section)
{
	int new_state;
	u_int64_t cost, cost_list, cost_range, cost_bitmap, cost_bitmap_restart;

	/*
	 * Avoid unsigned overflows.
	 * The limits are high enough to avoid confusing the calculations.
	 */
	contig = MINIMUM(contig, 1ULL<<31);
	last_gap = MINIMUM(last_gap, 1ULL<<31);
	next_gap = MINIMUM(next_gap, 1ULL<<31);

	/*
	 * Calculate the cost to switch from the current state to candidates.
	 * NB. range sections only ever contain a single range, so their
	 * switching cost is independent of the current_state.
	 */
	cost_list = cost_bitmap = cost_bitmap_restart = 0;
	cost_range = 8;
	switch (current_state) {
	case KRL_SECTION_CERT_SERIAL_LIST:
		cost_bitmap_restart = cost_bitmap = 8 + 64;
		break;
	case KRL_SECTION_CERT_SERIAL_BITMAP:
		cost_list = 8;
		cost_bitmap_restart = 8 + 64;
		break;
	case KRL_SECTION_CERT_SERIAL_RANGE:
	case 0:
		cost_bitmap_restart = cost_bitmap = 8 + 64;
		cost_list = 8;
	}

	/* Estimate base cost in bits of each section type */
	cost_list += 64 * contig + (final ? 0 : 8+64);
	cost_range += (2 * 64) + (final ? 0 : 8+64);
	cost_bitmap += last_gap + contig + (final ? 0 : MINIMUM(next_gap, 8+64));
	cost_bitmap_restart += contig + (final ? 0 : MINIMUM(next_gap, 8+64));

	/* Convert to byte costs for actual comparison */
	cost_list = (cost_list + 7) / 8;
	cost_bitmap = (cost_bitmap + 7) / 8;
	cost_bitmap_restart = (cost_bitmap_restart + 7) / 8;
	cost_range = (cost_range + 7) / 8;

	/* Now pick the best choice */
	*force_new_section = 0;
	new_state = KRL_SECTION_CERT_SERIAL_BITMAP;
	cost = cost_bitmap;
	if (cost_range < cost) {
		new_state = KRL_SECTION_CERT_SERIAL_RANGE;
		cost = cost_range;
	}
	if (cost_list < cost) {
		new_state = KRL_SECTION_CERT_SERIAL_LIST;
		cost = cost_list;
	}
	if (cost_bitmap_restart < cost) {
		new_state = KRL_SECTION_CERT_SERIAL_BITMAP;
		*force_new_section = 1;
		cost = cost_bitmap_restart;
	}
	KRL_DBG(("%s: contig %llu last_gap %llu next_gap %llu final %d, costs:"
	    "list %llu range %llu bitmap %llu new bitmap %llu, "
	    "selected 0x%02x%s", __func__, (long long unsigned)contig,
	    (long long unsigned)last_gap, (long long unsigned)next_gap, final,
	    (long long unsigned)cost_list, (long long unsigned)cost_range,
	    (long long unsigned)cost_bitmap,
	    (long long unsigned)cost_bitmap_restart, new_state,
	    *force_new_section ? " restart" : ""));
	return new_state;
}

static int
put_bitmap(struct sshbuf *buf, struct bitmap *bitmap)
{
	size_t len;
	u_char *blob;
	int r;

	len = bitmap_nbytes(bitmap);
	if ((blob = malloc(len)) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if (bitmap_to_string(bitmap, blob, len) != 0) {
		free(blob);
		return SSH_ERR_INTERNAL_ERROR;
	}
	r = sshbuf_put_bignum2_bytes(buf, blob, len);
	free(blob);
	return r;
}

/* Generate a KRL_SECTION_CERTIFICATES KRL section */
static int
revoked_certs_generate(struct revoked_certs *rc, struct sshbuf *buf)
{
	int final, force_new_sect, r = SSH_ERR_INTERNAL_ERROR;
	u_int64_t i, contig, gap, last = 0, bitmap_start = 0;
	struct revoked_serial *rs, *nrs;
	struct revoked_key_id *rki;
	int next_state, state = 0;
	struct sshbuf *sect;
	struct bitmap *bitmap = NULL;

	if ((sect = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;

	/* Store the header: optional CA scope key, reserved */
	if (rc->ca_key == NULL) {
		if ((r = sshbuf_put_string(buf, NULL, 0)) != 0)
			goto out;
	} else {
		if ((r = sshkey_puts(rc->ca_key, buf)) != 0)
			goto out;
	}
	if ((r = sshbuf_put_string(buf, NULL, 0)) != 0)
		goto out;

	/* Store the revoked serials.  */
	for (rs = RB_MIN(revoked_serial_tree, &rc->revoked_serials);
	     rs != NULL;
	     rs = RB_NEXT(revoked_serial_tree, &rc->revoked_serials, rs)) {
		KRL_DBG(("%s: serial %llu:%llu state 0x%02x", __func__,
		    (long long unsigned)rs->lo, (long long unsigned)rs->hi,
		    state));

		/* Check contiguous length and gap to next section (if any) */
		nrs = RB_NEXT(revoked_serial_tree, &rc->revoked_serials, rs);
		final = nrs == NULL;
		gap = nrs == NULL ? 0 : nrs->lo - rs->hi;
		contig = 1 + (rs->hi - rs->lo);

		/* Choose next state based on these */
		next_state = choose_next_state(state, contig, final,
		    state == 0 ? 0 : rs->lo - last, gap, &force_new_sect);

		/*
		 * If the current section is a range section or has a different
		 * type to the next section, then finish it off now.
		 */
		if (state != 0 && (force_new_sect || next_state != state ||
		    state == KRL_SECTION_CERT_SERIAL_RANGE)) {
			KRL_DBG(("%s: finish state 0x%02x", __func__, state));
			switch (state) {
			case KRL_SECTION_CERT_SERIAL_LIST:
			case KRL_SECTION_CERT_SERIAL_RANGE:
				break;
			case KRL_SECTION_CERT_SERIAL_BITMAP:
				if ((r = put_bitmap(sect, bitmap)) != 0)
					goto out;
				bitmap_free(bitmap);
				bitmap = NULL;
				break;
			}
			if ((r = sshbuf_put_u8(buf, state)) != 0 ||
			    (r = sshbuf_put_stringb(buf, sect)) != 0)
				goto out;
			sshbuf_reset(sect);
		}

		/* If we are starting a new section then prepare it now */
		if (next_state != state || force_new_sect) {
			KRL_DBG(("%s: start state 0x%02x", __func__,
			    next_state));
			state = next_state;
			sshbuf_reset(sect);
			switch (state) {
			case KRL_SECTION_CERT_SERIAL_LIST:
			case KRL_SECTION_CERT_SERIAL_RANGE:
				break;
			case KRL_SECTION_CERT_SERIAL_BITMAP:
				if ((bitmap = bitmap_new()) == NULL) {
					r = SSH_ERR_ALLOC_FAIL;
					goto out;
				}
				bitmap_start = rs->lo;
				if ((r = sshbuf_put_u64(sect,
				    bitmap_start)) != 0)
					goto out;
				break;
			}
		}

		/* Perform section-specific processing */
		switch (state) {
		case KRL_SECTION_CERT_SERIAL_LIST:
			for (i = 0; i < contig; i++) {
				if ((r = sshbuf_put_u64(sect, rs->lo + i)) != 0)
					goto out;
			}
			break;
		case KRL_SECTION_CERT_SERIAL_RANGE:
			if ((r = sshbuf_put_u64(sect, rs->lo)) != 0 ||
			    (r = sshbuf_put_u64(sect, rs->hi)) != 0)
				goto out;
			break;
		case KRL_SECTION_CERT_SERIAL_BITMAP:
			if (rs->lo - bitmap_start > INT_MAX) {
				error("%s: insane bitmap gap", __func__);
				goto out;
			}
			for (i = 0; i < contig; i++) {
				if (bitmap_set_bit(bitmap,
				    rs->lo + i - bitmap_start) != 0) {
					r = SSH_ERR_ALLOC_FAIL;
					goto out;
				}
			}
			break;
		}
		last = rs->hi;
	}
	/* Flush the remaining section, if any */
	if (state != 0) {
		KRL_DBG(("%s: serial final flush for state 0x%02x",
		    __func__, state));
		switch (state) {
		case KRL_SECTION_CERT_SERIAL_LIST:
		case KRL_SECTION_CERT_SERIAL_RANGE:
			break;
		case KRL_SECTION_CERT_SERIAL_BITMAP:
			if ((r = put_bitmap(sect, bitmap)) != 0)
				goto out;
			bitmap_free(bitmap);
			bitmap = NULL;
			break;
		}
		if ((r = sshbuf_put_u8(buf, state)) != 0 ||
		    (r = sshbuf_put_stringb(buf, sect)) != 0)
			goto out;
	}
	KRL_DBG(("%s: serial done ", __func__));

	/* Now output a section for any revocations by key ID */
	sshbuf_reset(sect);
	RB_FOREACH(rki, revoked_key_id_tree, &rc->revoked_key_ids) {
		KRL_DBG(("%s: key ID %s", __func__, rki->key_id));
		if ((r = sshbuf_put_cstring(sect, rki->key_id)) != 0)
			goto out;
	}
	if (sshbuf_len(sect) != 0) {
		if ((r = sshbuf_put_u8(buf, KRL_SECTION_CERT_KEY_ID)) != 0 ||
		    (r = sshbuf_put_stringb(buf, sect)) != 0)
			goto out;
	}
	r = 0;
 out:
	bitmap_free(bitmap);
	sshbuf_free(sect);
	return r;
}

int
ssh_krl_to_blob(struct ssh_krl *krl, struct sshbuf *buf,
    const struct sshkey **sign_keys, u_int nsign_keys)
{
	int r = SSH_ERR_INTERNAL_ERROR;
	struct revoked_certs *rc;
	struct revoked_blob *rb;
	struct sshbuf *sect;
	u_char *sblob = NULL;
	size_t slen, i;

	if (krl->generated_date == 0)
		krl->generated_date = time(NULL);

	if ((sect = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;

	/* Store the header */
	if ((r = sshbuf_put(buf, KRL_MAGIC, sizeof(KRL_MAGIC) - 1)) != 0 ||
	    (r = sshbuf_put_u32(buf, KRL_FORMAT_VERSION)) != 0 ||
	    (r = sshbuf_put_u64(buf, krl->krl_version)) != 0 ||
	    (r = sshbuf_put_u64(buf, krl->generated_date)) != 0 ||
	    (r = sshbuf_put_u64(buf, krl->flags)) != 0 ||
	    (r = sshbuf_put_string(buf, NULL, 0)) != 0 ||
	    (r = sshbuf_put_cstring(buf, krl->comment)) != 0)
		goto out;

	/* Store sections for revoked certificates */
	TAILQ_FOREACH(rc, &krl->revoked_certs, entry) {
		sshbuf_reset(sect);
		if ((r = revoked_certs_generate(rc, sect)) != 0)
			goto out;
		if ((r = sshbuf_put_u8(buf, KRL_SECTION_CERTIFICATES)) != 0 ||
		    (r = sshbuf_put_stringb(buf, sect)) != 0)
			goto out;
	}

	/* Finally, output sections for revocations by public key/hash */
	sshbuf_reset(sect);
	RB_FOREACH(rb, revoked_blob_tree, &krl->revoked_keys) {
		KRL_DBG(("%s: key len %zu ", __func__, rb->len));
		if ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)
			goto out;
	}
	if (sshbuf_len(sect) != 0) {
		if ((r = sshbuf_put_u8(buf, KRL_SECTION_EXPLICIT_KEY)) != 0 ||
		    (r = sshbuf_put_stringb(buf, sect)) != 0)
			goto out;
	}
	sshbuf_reset(sect);
	RB_FOREACH(rb, revoked_blob_tree, &krl->revoked_sha1s) {
		KRL_DBG(("%s: hash len %zu ", __func__, rb->len));
		if ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)
			goto out;
	}
	if (sshbuf_len(sect) != 0) {
		if ((r = sshbuf_put_u8(buf,
		    KRL_SECTION_FINGERPRINT_SHA1)) != 0 ||
		    (r = sshbuf_put_stringb(buf, sect)) != 0)
			goto out;
	}

	for (i = 0; i < nsign_keys; i++) {
		KRL_DBG(("%s: signature key %s", __func__,
		    sshkey_ssh_name(sign_keys[i])));
		if ((r = sshbuf_put_u8(buf, KRL_SECTION_SIGNATURE)) != 0 ||
		    (r = sshkey_puts(sign_keys[i], buf)) != 0)
			goto out;

		if ((r = sshkey_sign(sign_keys[i], &sblob, &slen,
		    sshbuf_ptr(buf), sshbuf_len(buf), NULL, 0)) != 0)
			goto out;
		KRL_DBG(("%s: signature sig len %zu", __func__, slen));
		if ((r = sshbuf_put_string(buf, sblob, slen)) != 0)
			goto out;
	}

	r = 0;
 out:
	free(sblob);
	sshbuf_free(sect);
	return r;
}

static void
format_timestamp(u_int64_t timestamp, char *ts, size_t nts)
{
	time_t t;
	struct tm *tm;

	t = timestamp;
	tm = localtime(&t);
	if (tm == NULL)
		strlcpy(ts, "<INVALID>", nts);
	else {
		*ts = '\0';
		strftime(ts, nts, "%Y%m%dT%H%M%S", tm);
	}
}

static int
parse_revoked_certs(struct sshbuf *buf, struct ssh_krl *krl)
{
	int r = SSH_ERR_INTERNAL_ERROR;
	u_char type;
	const u_char *blob;
	size_t blen, nbits;
	struct sshbuf *subsect = NULL;
	u_int64_t serial, serial_lo, serial_hi;
	struct bitmap *bitmap = NULL;
	char *key_id = NULL;
	struct sshkey *ca_key = NULL;

	if ((subsect = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;

	/* Header: key, reserved */
	if ((r = sshbuf_get_string_direct(buf, &blob, &blen)) != 0 ||
	    (r = sshbuf_skip_string(buf)) != 0)
		goto out;
	if (blen != 0 && (r = sshkey_from_blob(blob, blen, &ca_key)) != 0)
		goto out;

	while (sshbuf_len(buf) > 0) {
		sshbuf_free(subsect);
		subsect = NULL;
		if ((r = sshbuf_get_u8(buf, &type)) != 0 ||
		    (r = sshbuf_froms(buf, &subsect)) != 0)
			goto out;
		KRL_DBG(("%s: subsection type 0x%02x", __func__, type));
		/* sshbuf_dump(subsect, stderr); */

		switch (type) {
		case KRL_SECTION_CERT_SERIAL_LIST:
			while (sshbuf_len(subsect) > 0) {
				if ((r = sshbuf_get_u64(subsect, &serial)) != 0)
					goto out;
				if ((r = ssh_krl_revoke_cert_by_serial(krl,
				    ca_key, serial)) != 0)
					goto out;
			}
			break;
		case KRL_SECTION_CERT_SERIAL_RANGE:
			if ((r = sshbuf_get_u64(subsect, &serial_lo)) != 0 ||
			    (r = sshbuf_get_u64(subsect, &serial_hi)) != 0)
				goto out;
			if ((r = ssh_krl_revoke_cert_by_serial_range(krl,
			    ca_key, serial_lo, serial_hi)) != 0)
				goto out;
			break;
		case KRL_SECTION_CERT_SERIAL_BITMAP:
			if ((bitmap = bitmap_new()) == NULL) {
				r = SSH_ERR_ALLOC_FAIL;
				goto out;
			}
			if ((r = sshbuf_get_u64(subsect, &serial_lo)) != 0 ||
			    (r = sshbuf_get_bignum2_bytes_direct(subsect,
			    &blob, &blen)) != 0)
				goto out;
			if (bitmap_from_string(bitmap, blob, blen) != 0) {
				r = SSH_ERR_INVALID_FORMAT;
				goto out;
			}
			nbits = bitmap_nbits(bitmap);
			for (serial = 0; serial < (u_int64_t)nbits; serial++) {
				if (serial > 0 && serial_lo + serial == 0) {
					error("%s: bitmap wraps u64", __func__);
					r = SSH_ERR_INVALID_FORMAT;
					goto out;
				}
				if (!bitmap_test_bit(bitmap, serial))
					continue;
				if ((r = ssh_krl_revoke_cert_by_serial(krl,
				    ca_key, serial_lo + serial)) != 0)
					goto out;
			}
			bitmap_free(bitmap);
			bitmap = NULL;
			break;
		case KRL_SECTION_CERT_KEY_ID:
			while (sshbuf_len(subsect) > 0) {
				if ((r = sshbuf_get_cstring(subsect,
				    &key_id, NULL)) != 0)
					goto out;
				if ((r = ssh_krl_revoke_cert_by_key_id(krl,
				    ca_key, key_id)) != 0)
					goto out;
				free(key_id);
				key_id = NULL;
			}
			break;
		default:
			error("Unsupported KRL certificate section %u", type);
			r = SSH_ERR_INVALID_FORMAT;
			goto out;
		}
		if (sshbuf_len(subsect) > 0) {
			error("KRL certificate section contains unparsed data");
			r = SSH_ERR_INVALID_FORMAT;
			goto out;
		}
	}

	r = 0;
 out:
	if (bitmap != NULL)
		bitmap_free(bitmap);
	free(key_id);
	sshkey_free(ca_key);
	sshbuf_free(subsect);
	return r;
}


/* Attempt to parse a KRL, checking its signature (if any) with sign_ca_keys. */
int
ssh_krl_from_blob(struct sshbuf *buf, struct ssh_krl **krlp,
    const struct sshkey **sign_ca_keys, size_t nsign_ca_keys)
{
	struct sshbuf *copy = NULL, *sect = NULL;
	struct ssh_krl *krl = NULL;
	char timestamp[64];
	int r = SSH_ERR_INTERNAL_ERROR, sig_seen;
	struct sshkey *key = NULL, **ca_used = NULL, **tmp_ca_used;
	u_char type, *rdata = NULL;
	const u_char *blob;
	size_t i, j, sig_off, sects_off, rlen, blen, nca_used;
	u_int format_version;

	nca_used = 0;
	*krlp = NULL;
	if (sshbuf_len(buf) < sizeof(KRL_MAGIC) - 1 ||
	    memcmp(sshbuf_ptr(buf), KRL_MAGIC, sizeof(KRL_MAGIC) - 1) != 0) {
		debug3("%s: not a KRL", __func__);
		return SSH_ERR_KRL_BAD_MAGIC;
	}

	/* Take a copy of the KRL buffer so we can verify its signature later */
	if ((copy = sshbuf_fromb(buf)) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((r = sshbuf_consume(copy, sizeof(KRL_MAGIC) - 1)) != 0)
		goto out;

	if ((krl = ssh_krl_init()) == NULL) {
		error("%s: alloc failed", __func__);
		goto out;
	}

	if ((r = sshbuf_get_u32(copy, &format_version)) != 0)
		goto out;
	if (format_version != KRL_FORMAT_VERSION) {
		r = SSH_ERR_INVALID_FORMAT;
		goto out;
	}
	if ((r = sshbuf_get_u64(copy, &krl->krl_version)) != 0 ||
	    (r = sshbuf_get_u64(copy, &krl->generated_date)) != 0 ||
	    (r = sshbuf_get_u64(copy, &krl->flags)) != 0 ||
	    (r = sshbuf_skip_string(copy)) != 0 ||
	    (r = sshbuf_get_cstring(copy, &krl->comment, NULL)) != 0)
		goto out;

	format_timestamp(krl->generated_date, timestamp, sizeof(timestamp));
	debug("KRL version %llu generated at %s%s%s",
	    (long long unsigned)krl->krl_version, timestamp,
	    *krl->comment ? ": " : "", krl->comment);

	/*
	 * 1st pass: verify signatures, if any. This is done to avoid
	 * detailed parsing of data whose provenance is unverified.
	 */
	sig_seen = 0;
	if (sshbuf_len(buf) < sshbuf_len(copy)) {
		/* Shouldn't happen */
		r = SSH_ERR_INTERNAL_ERROR;
		goto out;
	}
	sects_off = sshbuf_len(buf) - sshbuf_len(copy);
	while (sshbuf_len(copy) > 0) {
		if ((r = sshbuf_get_u8(copy, &type)) != 0 ||
		    (r = sshbuf_get_string_direct(copy, &blob, &blen)) != 0)
			goto out;
		KRL_DBG(("%s: first pass, section 0x%02x", __func__, type));
		if (type != KRL_SECTION_SIGNATURE) {
			if (sig_seen) {
				error("KRL contains non-signature section "
				    "after signature");
				r = SSH_ERR_INVALID_FORMAT;
				goto out;
			}
			/* Not interested for now. */
			continue;
		}
		sig_seen = 1;
		/* First string component is the signing key */
		if ((r = sshkey_from_blob(blob, blen, &key)) != 0) {
			r = SSH_ERR_INVALID_FORMAT;
			goto out;
		}
		if (sshbuf_len(buf) < sshbuf_len(copy)) {
			/* Shouldn't happen */
			r = SSH_ERR_INTERNAL_ERROR;
			goto out;
		}
		sig_off = sshbuf_len(buf) - sshbuf_len(copy);
		/* Second string component is the signature itself */
		if ((r = sshbuf_get_string_direct(copy, &blob, &blen)) != 0) {
			r = SSH_ERR_INVALID_FORMAT;
			goto out;
		}
		/* Check signature over entire KRL up to this point */
		if ((r = sshkey_verify(key, blob, blen,
		    sshbuf_ptr(buf), sig_off, 0)) != 0)
			goto out;
		/* Check if this key has already signed this KRL */
		for (i = 0; i < nca_used; i++) {
			if (sshkey_equal(ca_used[i], key)) {
				error("KRL signed more than once with "
				    "the same key");
				r = SSH_ERR_INVALID_FORMAT;
				goto out;
			}
		}
		/* Record keys used to sign the KRL */
		tmp_ca_used = reallocarray(ca_used, nca_used + 1,
		    sizeof(*ca_used));
		if (tmp_ca_used == NULL) {
			r = SSH_ERR_ALLOC_FAIL;
			goto out;
		}
		ca_used = tmp_ca_used;
		ca_used[nca_used++] = key;
		key = NULL;
	}

	if (sshbuf_len(copy) != 0) {
		/* Shouldn't happen */
		r = SSH_ERR_INTERNAL_ERROR;
		goto out;
	}

	/*
	 * 2nd pass: parse and load the KRL, skipping the header to the point
	 * where the section start.
	 */
	sshbuf_free(copy);
	if ((copy = sshbuf_fromb(buf)) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((r = sshbuf_consume(copy, sects_off)) != 0)
		goto out;
	while (sshbuf_len(copy) > 0) {
		sshbuf_free(sect);
		sect = NULL;
		if ((r = sshbuf_get_u8(copy, &type)) != 0 ||
		    (r = sshbuf_froms(copy, &sect)) != 0)
			goto out;
		KRL_DBG(("%s: second pass, section 0x%02x", __func__, type));

		switch (type) {
		case KRL_SECTION_CERTIFICATES:
			if ((r = parse_revoked_certs(sect, krl)) != 0)
				goto out;
			break;
		case KRL_SECTION_EXPLICIT_KEY:
		case KRL_SECTION_FINGERPRINT_SHA1:
			while (sshbuf_len(sect) > 0) {
				if ((r = sshbuf_get_string(sect,
				    &rdata, &rlen)) != 0)
					goto out;
				if (type == KRL_SECTION_FINGERPRINT_SHA1 &&
				    rlen != 20) {
					error("%s: bad SHA1 length", __func__);
					r = SSH_ERR_INVALID_FORMAT;
					goto out;
				}
				if ((r = revoke_blob(
				    type == KRL_SECTION_EXPLICIT_KEY ?
				    &krl->revoked_keys : &krl->revoked_sha1s,
				    rdata, rlen)) != 0)
					goto out;
				rdata = NULL; /* revoke_blob frees rdata */
			}
			break;
		case KRL_SECTION_SIGNATURE:
			/* Handled above, but still need to stay in synch */
			sshbuf_free(sect);
			sect = NULL;
			if ((r = sshbuf_skip_string(copy)) != 0)
				goto out;
			break;
		default:
			error("Unsupported KRL section %u", type);
			r = SSH_ERR_INVALID_FORMAT;
			goto out;
		}
		if (sect != NULL && sshbuf_len(sect) > 0) {
			error("KRL section contains unparsed data");
			r = SSH_ERR_INVALID_FORMAT;
			goto out;
		}
	}

	/* Check that the key(s) used to sign the KRL weren't revoked */
	sig_seen = 0;
	for (i = 0; i < nca_used; i++) {
		if (ssh_krl_check_key(krl, ca_used[i]) == 0)
			sig_seen = 1;
		else {
			sshkey_free(ca_used[i]);
			ca_used[i] = NULL;
		}
	}
	if (nca_used && !sig_seen) {
		error("All keys used to sign KRL were revoked");
		r = SSH_ERR_KEY_REVOKED;
		goto out;
	}

	/* If we have CA keys, then verify that one was used to sign the KRL */
	if (sig_seen && nsign_ca_keys != 0) {
		sig_seen = 0;
		for (i = 0; !sig_seen && i < nsign_ca_keys; i++) {
			for (j = 0; j < nca_used; j++) {
				if (ca_used[j] == NULL)
					continue;
				if (sshkey_equal(ca_used[j], sign_ca_keys[i])) {
					sig_seen = 1;
					break;
				}
			}
		}
		if (!sig_seen) {
			r = SSH_ERR_SIGNATURE_INVALID;
			error("KRL not signed with any trusted key");
			goto out;
		}
	}

	*krlp = krl;
	r = 0;
 out:
	if (r != 0)
		ssh_krl_free(krl);
	for (i = 0; i < nca_used; i++)
		sshkey_free(ca_used[i]);
	free(ca_used);
	free(rdata);
	sshkey_free(key);
	sshbuf_free(copy);
	sshbuf_free(sect);
	return r;
}

/* Checks certificate serial number and key ID revocation */
static int
is_cert_revoked(const struct sshkey *key, struct revoked_certs *rc)
{
	struct revoked_serial rs, *ers;
	struct revoked_key_id rki, *erki;

	/* Check revocation by cert key ID */
	memset(&rki, 0, sizeof(rki));
	rki.key_id = key->cert->key_id;
	erki = RB_FIND(revoked_key_id_tree, &rc->revoked_key_ids, &rki);
	if (erki != NULL) {
		KRL_DBG(("%s: revoked by key ID", __func__));
		return SSH_ERR_KEY_REVOKED;
	}

	/*
	 * Zero serials numbers are ignored (it's the default when the
	 * CA doesn't specify one).
	 */
	if (key->cert->serial == 0)
		return 0;

	memset(&rs, 0, sizeof(rs));
	rs.lo = rs.hi = key->cert->serial;
	ers = RB_FIND(revoked_serial_tree, &rc->revoked_serials, &rs);
	if (ers != NULL) {
		KRL_DBG(("%s: revoked serial %llu matched %llu:%llu", __func__,
		    key->cert->serial, ers->lo, ers->hi));
		return SSH_ERR_KEY_REVOKED;
	}
	return 0;
}

/* Checks whether a given key/cert is revoked. Does not check its CA */
static int
is_key_revoked(struct ssh_krl *krl, const struct sshkey *key)
{
	struct revoked_blob rb, *erb;
	struct revoked_certs *rc;
	int r;

	/* Check explicitly revoked hashes first */
	memset(&rb, 0, sizeof(rb));
	if ((r = sshkey_fingerprint_raw(key, SSH_DIGEST_SHA1,
	    &rb.blob, &rb.len)) != 0)
		return r;
	erb = RB_FIND(revoked_blob_tree, &krl->revoked_sha1s, &rb);
	free(rb.blob);
	if (erb != NULL) {
		KRL_DBG(("%s: revoked by key SHA1", __func__));
		return SSH_ERR_KEY_REVOKED;
	}

	/* Next, explicit keys */
	memset(&rb, 0, sizeof(rb));
	if ((r = plain_key_blob(key, &rb.blob, &rb.len)) != 0)
		return r;
	erb = RB_FIND(revoked_blob_tree, &krl->revoked_keys, &rb);
	free(rb.blob);
	if (erb != NULL) {
		KRL_DBG(("%s: revoked by explicit key", __func__));
		return SSH_ERR_KEY_REVOKED;
	}

	if (!sshkey_is_cert(key))
		return 0;

	/* Check cert revocation for the specified CA */
	if ((r = revoked_certs_for_ca_key(krl, key->cert->signature_key,
	    &rc, 0)) != 0)
		return r;
	if (rc != NULL) {
		if ((r = is_cert_revoked(key, rc)) != 0)
			return r;
	}
	/* Check cert revocation for the wildcard CA */
	if ((r = revoked_certs_for_ca_key(krl, NULL, &rc, 0)) != 0)
		return r;
	if (rc != NULL) {
		if ((r = is_cert_revoked(key, rc)) != 0)
			return r;
	}

	KRL_DBG(("%s: %llu no match", __func__, key->cert->serial));
	return 0;
}

int
ssh_krl_check_key(struct ssh_krl *krl, const struct sshkey *key)
{
	int r;

	KRL_DBG(("%s: checking key", __func__));
	if ((r = is_key_revoked(krl, key)) != 0)
		return r;
	if (sshkey_is_cert(key)) {
		debug2("%s: checking CA key", __func__);
		if ((r = is_key_revoked(krl, key->cert->signature_key)) != 0)
			return r;
	}
	KRL_DBG(("%s: key okay", __func__));
	return 0;
}

int
ssh_krl_file_contains_key(const char *path, const struct sshkey *key)
{
	struct sshbuf *krlbuf = NULL;
	struct ssh_krl *krl = NULL;
	int oerrno = 0, r, fd;

	if (path == NULL)
		return 0;

	if ((krlbuf = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((fd = open(path, O_RDONLY)) == -1) {
		r = SSH_ERR_SYSTEM_ERROR;
		oerrno = errno;
		goto out;
	}
	if ((r = sshkey_load_file(fd, krlbuf)) != 0) {
		oerrno = errno;
		goto out;
	}
	if ((r = ssh_krl_from_blob(krlbuf, &krl, NULL, 0)) != 0)
		goto out;
	debug2("%s: checking KRL %s", __func__, path);
	r = ssh_krl_check_key(krl, key);
 out:
	if (fd != -1)
		close(fd);
	sshbuf_free(krlbuf);
	ssh_krl_free(krl);
	if (r != 0)
		errno = oerrno;
	return r;
}
@


1.38
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.37 2015/12/31 00:33:52 djm Exp $ */
d1090 1
a1090 1
			sshbuf_reset(sect);
d1289 2
a1290 1
	close(fd);
@


1.37
log
@fix three bugs in KRL code related to (unused) signature support:
verification length was being incorrectly calculated, multiple
signatures were being incorrectly processed and a NULL dereference
that occurred when signatures were verified.
Reported by Carl Jackson
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.36 2015/12/11 04:21:12 mmcc Exp $ */
a18 1
#include <sys/param.h>	/* MIN */
d121 1
a121 1
		if ((r = memcmp(a->blob, b->blob, MIN(a->len, b->len))) != 0)
d458 3
a460 3
	contig = MIN(contig, 1ULL<<31);
	last_gap = MIN(last_gap, 1ULL<<31);
	next_gap = MIN(next_gap, 1ULL<<31);
d486 2
a487 2
	cost_bitmap += last_gap + contig + (final ? 0 : MIN(next_gap, 8+64));
	cost_bitmap_restart += contig + (final ? 0 : MIN(next_gap, 8+64));
@


1.36
log
@Remove NULL-checks before sshbuf_free().

ok djm@@
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.35 2015/12/04 16:41:28 markus Exp $ */
d1016 1
a1016 1
		    sshbuf_ptr(buf), sshbuf_len(buf) - sig_off, 0)) != 0)
a1036 1
		break;
d1101 1
a1101 1
		if (sshbuf_len(sect) > 0) {
@


1.35
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.34 2015/09/02 07:51:12 jsg Exp $ */
d827 2
a828 4
		if (subsect != NULL) {
			sshbuf_free(subsect);
			subsect = NULL;
		}
d1058 2
a1059 4
		if (sect != NULL) {
			sshbuf_free(sect);
			sect = NULL;
		}
@


1.34
log
@Fix occurrences of "r = func() != 0" which result in the wrong error
codes being returned due to != having higher precedence than =.

ok deraadt@@ markus@@
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.33 2015/07/03 03:43:18 djm Exp $ */
d773 1
a773 1
		    sshbuf_ptr(buf), sshbuf_len(buf), 0)) != 0)
@


1.33
log
@delete support for legacy v00 certificates; "sure" markus@@ dtucker@@
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.32 2015/06/24 23:47:23 djm Exp $ */
d724 1
a724 1
	    (r = sshbuf_put_u64(buf, krl->generated_date) != 0) ||
@


1.32
log
@correct test to sshkey_sign(); spotted by Albert S.
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.31 2015/01/30 01:10:33 djm Exp $ */
d430 1
a430 1
	if (sshkey_cert_is_legacy(key) || key->cert->serial == 0) {
d1181 2
a1182 2
	 * Legacy cert formats lack serial numbers. Zero serials numbers
	 * are ignored (it's the default when the CA doesn't specify one).
d1184 1
a1184 1
	if (sshkey_cert_is_legacy(key) || key->cert->serial == 0)
@


1.31
log
@permit KRLs that revoke certificates by serial number or key ID
without scoping to a particular CA; ok markus@@
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.30 2015/01/26 02:59:11 djm Exp $ */
d773 1
a773 1
		    sshbuf_ptr(buf), sshbuf_len(buf), 0)) == -1)
@


1.30
log
@small refactor and add some convenience functions;
ok markus
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.29 2015/01/20 23:14:00 deraadt Exp $ */
d157 1
a157 2
	if (rc->ca_key != NULL)
		sshkey_free(rc->ca_key);
d214 2
a215 1
		if (sshkey_equal(rc->ca_key, ca_key)) {
d225 3
a227 1
	if ((r = sshkey_from_private(ca_key, &rc->ca_key)) != 0) {
d234 2
a235 1
	KRL_DBG(("%s: new CA %s", __func__, sshkey_type(ca_key)));
d558 9
a566 3
	/* Store the header: CA scope key, reserved */
	if ((r = sshkey_puts(rc->ca_key, buf)) != 0 ||
	    (r = sshbuf_put_string(buf, NULL, 0)) != 0)
d823 1
a823 1
	if ((r = sshkey_from_blob(blob, blen, &ca_key)) != 0)
d1164 34
a1202 2
	struct revoked_serial rs, *ers;
	struct revoked_key_id rki, *erki;
d1232 1
a1232 1
	/* Check cert revocation */
d1236 10
a1245 10
	if (rc == NULL)
		return 0; /* No entry for this CA */

	/* Check revocation by cert key ID */
	memset(&rki, 0, sizeof(rki));
	rki.key_id = key->cert->key_id;
	erki = RB_FIND(revoked_key_id_tree, &rc->revoked_key_ids, &rki);
	if (erki != NULL) {
		KRL_DBG(("%s: revoked by key ID", __func__));
		return SSH_ERR_KEY_REVOKED;
a1247 15
	/*
	 * Legacy cert formats lack serial numbers. Zero serials numbers
	 * are ignored (it's the default when the CA doesn't specify one).
	 */
	if (sshkey_cert_is_legacy(key) || key->cert->serial == 0)
		return 0;

	memset(&rs, 0, sizeof(rs));
	rs.lo = rs.hi = key->cert->serial;
	ers = RB_FIND(revoked_serial_tree, &rc->revoked_serials, &rs);
	if (ers != NULL) {
		KRL_DBG(("%s: revoked serial %llu matched %llu:%llu", __func__,
		    key->cert->serial, ers->lo, ers->hi));
		return SSH_ERR_KEY_REVOKED;
	}
@


1.29
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.28 2015/01/19 17:35:48 djm Exp $ */
d556 1
a556 2
	if ((r = sshkey_to_blob_buf(rc->ca_key, sect)) != 0 ||
	    (r = sshbuf_put_stringb(buf, sect)) != 0 ||
a559 2
	sshbuf_reset(sect);

d757 2
a758 6
		sshbuf_reset(sect);
		if ((r = sshkey_to_blob_buf(sign_keys[i], sect)) != 0)
			goto out;

		KRL_DBG(("%s: signature key len %zu", __func__,
		    sshbuf_len(sect)));
d760 1
a760 1
		    (r = sshbuf_put_stringb(buf, sect)) != 0)
@


1.28
log
@fix format strings in (disabled) debugging
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.27 2015/01/18 14:01:00 deraadt Exp $ */
d19 1
a20 1
#include <sys/param.h>
@


1.27
log
@string truncation due to sizeof(size)
ok djm markus
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.26 2015/01/14 15:02:39 djm Exp $ */
d737 1
a737 1
		KRL_DBG(("%s: key len %u ", __func__, rb->len));
d748 1
a748 1
		KRL_DBG(("%s: hash len %u ", __func__, rb->len));
d773 1
a773 1
		KRL_DBG(("%s: signature sig len %u", __func__, slen));
@


1.26
log
@avoid BIGNUM in KRL code by using a simple bitmap;
feedback and ok markus
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.25 2015/01/13 19:04:35 djm Exp $ */
d794 1
a794 1
		strlcpy(ts, "<INVALID>", sizeof(nts));
@


1.25
log
@sync changes from libopenssh; prepared by markus@@
mostly debug output tweaks, a couple of error return value changes
and some other minor stuff
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.24 2015/01/12 19:22:46 markus Exp $ */
d38 1
d521 19
d550 1
a550 1
	BIGNUM *bitmap = NULL;
d593 1
a593 1
				if ((r = sshbuf_put_bignum2(sect, bitmap)) != 0)
d595 1
a595 1
				BN_free(bitmap);
d616 1
a616 1
				if ((bitmap = BN_new()) == NULL) {
d647 2
a648 2
				if (BN_set_bit(bitmap,
				    rs->lo + i - bitmap_start) != 1) {
d666 1
a666 1
			if ((r = sshbuf_put_bignum2(sect, bitmap)) != 0)
d668 1
a668 1
			BN_free(bitmap);
d692 1
a692 2
	if (bitmap != NULL)
		BN_free(bitmap);
d804 1
a804 1
	int r = SSH_ERR_INTERNAL_ERROR, nbits;
d807 1
a807 1
	size_t blen;
d810 1
a810 1
	BIGNUM *bitmap = NULL;
d854 1
a854 1
			if ((bitmap = BN_new()) == NULL) {
d859 2
a860 1
			    (r = sshbuf_get_bignum2(subsect, bitmap)) != 0)
d862 1
a862 2
			if ((nbits = BN_num_bits(bitmap)) < 0) {
				error("%s: bitmap bits < 0", __func__);
d866 1
d873 1
a873 1
				if (!BN_is_bit_set(bitmap, serial))
d879 1
a879 1
			BN_free(bitmap);
d909 1
a909 1
		BN_free(bitmap);
@


1.24
log
@missing error assigment on sshbuf_put_string()
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.23 2015/01/12 14:05:19 markus Exp $ */
d32 1
a36 1
#include "ssherr.h"
d231 1
a231 1
	debug3("%s: new CA %s", __func__, sshkey_type(ca_key));
d256 1
a256 1
			return SSH_ERR_ALLOC_FAIL;
d271 1
d317 2
a318 2
ssh_krl_revoke_cert_by_serial_range(struct ssh_krl *krl, const struct sshkey *ca_key,
    u_int64_t lo, u_int64_t hi)
d324 1
a324 1
		return -1;
d341 1
a341 1
	debug3("%s: revoke %s", __func__, key_id);
d377 1
a377 1
revoke_blob(struct revoked_blob_tree *rbt, u_char *blob, u_int len)
d509 1
a509 1
	debug3("%s: contig %llu last_gap %llu next_gap %llu final %d, costs:"
d516 1
a516 1
	    *force_new_section ? " restart" : "");
d524 1
a524 1
	int final, force_new_sect, r = -1;
d547 1
a547 1
		debug3("%s: serial %llu:%llu state 0x%02x", __func__,
d549 1
a549 1
		    state);
d567 1
a567 1
			debug3("%s: finish state 0x%02x", __func__, state);
d587 2
a588 1
			debug3("%s: start state 0x%02x", __func__, next_state);
d639 2
a640 2
		debug3("%s: serial final flush for state 0x%02x",
		    __func__, state);
d656 1
a656 1
	debug3("%s: serial done ", __func__);
d661 1
a661 1
		debug3("%s: key ID %s", __func__, rki->key_id);
d682 1
a682 1
	int r = -1;
d718 1
a718 1
		debug3("%s: key len %zu ", __func__, rb->len);
d729 1
a729 1
		debug3("%s: hash len %zu ", __func__, rb->len);
d745 2
a746 1
		debug3("%s: signature key len %zu", __func__, sshbuf_len(sect));
d754 1
a754 1
		debug3("%s: signature sig len %zu", __func__, slen);
d785 1
a785 1
	int r = -1, nbits;
d813 2
a814 1
		debug3("%s: subsection type 0x%02x", __func__, type);
d847 1
a847 1
			for (serial = 0; serial < (u_int)nbits; serial++) {
d900 1
a900 1
    const struct sshkey **sign_ca_keys, u_int nsign_ca_keys)
d905 1
a905 1
	int r = -1, sig_seen;
d966 1
a966 1
		debug3("%s: first pass, section 0x%02x", __func__, type);
a968 1
				r = SSH_ERR_INVALID_FORMAT;
d971 1
a980 1
			error("%s: invalid signature key", __func__);
d996 1
a996 2
		    sshbuf_ptr(buf), sshbuf_len(buf) - sig_off, 0)) != 0) {
			error("bad signaure on KRL");
a997 1
		}
d1003 1
a1003 1
				r = SSH_ERR_SIGNATURE_INVALID;
d1043 1
a1043 1
		    (r = sshbuf_froms(copy, &sect)) != 0) {
d1045 1
a1045 2
		}
		debug3("%s: second pass, section 0x%02x", __func__, type);
d1069 1
a1069 1
				rdata = NULL; /* revoke_blob frees blob */
a1101 1
		r = SSH_ERR_SIGNATURE_INVALID;
d1103 1
d1160 1
a1160 1
		debug("%s: revoked by key SHA1", __func__);
d1171 1
a1171 1
		debug("%s: revoked by explicit key", __func__);
d1190 1
a1190 1
		debug("%s: revoked by key ID", __func__);
d1205 1
a1205 1
		KRL_DBG(("%s: %llu matched %llu:%llu", __func__,
a1206 1
		debug("%s: revoked by serial", __func__);
a1209 1

d1218 1
a1218 1
	debug2("%s: checking key", __func__);
d1226 1
a1226 1
	debug3("%s: key okay", __func__);
@


1.23
log
@free->sshkey_free; ok djm@@
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.22 2015/01/08 10:14:08 djm Exp $ */
d717 1
a717 1
		if ((sshbuf_put_string(sect, rb->blob, rb->len)) != 0)
d728 1
a728 1
		if ((sshbuf_put_string(sect, rb->blob, rb->len)) != 0)
@


1.22
log
@deprecate key_load_private_pem() and sshkey_load_private_pem()
interfaces. Refactor the generic key loading API to not require
pathnames to be specified (they weren't really used).

Fixes a few other things en passant:

Makes ed25519 keys work for hostbased authentication (ssh-keysign
previously used the PEM-only routines).

Fixes key comment regression bz#2306: key pathnames were being lost as
comment fields.

ok markus@@
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.21 2014/12/21 22:27:56 djm Exp $ */
d370 1
a370 1
	free(kcopy);
@


1.21
log
@Add FingerprintHash option to control algorithm used for key
fingerprints. Default changes from MD5 to SHA256 and format
from hex to base64.

Feedback and ok naddy@@ markus@@
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.20 2014/12/04 01:49:59 djm Exp $ */
d1249 1
a1249 1
	if ((r = sshkey_load_file(fd, path, krlbuf)) != 0) {
@


1.20
log
@convert KRL code to new buffer API

ok markus@@
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.19 2014/11/21 01:00:38 djm Exp $ */
d37 1
d413 2
a414 1
	if ((r = sshkey_fingerprint_raw(key, SSH_FP_SHA1, &blob, &len)) != 0)
d1154 1
a1154 1
	if ((r = sshkey_fingerprint_raw(key, SSH_FP_SHA1,
@


1.19
log
@fix NULL pointer dereference crash on invalid timestamp

found using Michal Zalewski's afl fuzzer
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.18 2014/11/17 00:21:40 djm Exp $ */
d31 2
a32 2
#include "buffer.h"
#include "key.h"
d36 1
a36 1
#include "xmalloc.h"
d73 1
a73 1
	u_int len;
d82 1
a82 1
	Key *ca_key;
d156 1
a156 1
		key_free(rc->ca_key);
d191 1
a191 1
void
d196 2
a197 1
		fatal("%s: strdup", __func__);
d205 1
a205 1
revoked_certs_for_ca_key(struct ssh_krl *krl, const Key *ca_key,
d209 1
d213 1
a213 1
		if (key_equal(rc->ca_key, ca_key)) {
d222 2
a223 2
		return -1;
	if ((rc->ca_key = key_from_private(ca_key)) == NULL) {
d225 1
a225 1
		return -1;
d230 1
a230 1
	debug3("%s: new CA %s", __func__, key_type(ca_key));
d248 1
a248 1
			return -1;
d255 1
a255 1
			return -1;
d308 1
a308 1
ssh_krl_revoke_cert_by_serial(struct ssh_krl *krl, const Key *ca_key,
d315 1
a315 1
ssh_krl_revoke_cert_by_serial_range(struct ssh_krl *krl, const Key *ca_key,
d319 1
d323 2
a324 2
	if (revoked_certs_for_ca_key(krl, ca_key, &rc, 1) != 0)
		return -1;
d329 1
a329 1
ssh_krl_revoke_cert_by_key_id(struct ssh_krl *krl, const Key *ca_key,
d334 1
d336 2
a337 2
	if (revoked_certs_for_ca_key(krl, ca_key, &rc, 1) != 0)
		return -1;
d343 1
a343 1
		fatal("%s: strdup", __func__);
d355 1
a355 1
plain_key_blob(const Key *key, u_char **blob, u_int *blen)
d357 1
a357 1
	Key *kcopy;
d360 6
a365 7
	if ((kcopy = key_from_private(key)) == NULL)
		return -1;
	if (key_is_cert(kcopy)) {
		if (key_drop_cert(kcopy) != 0) {
			error("%s: key_drop_cert", __func__);
			key_free(kcopy);
			return -1;
d368 1
a368 1
	r = key_to_blob(kcopy, blob, blen);
d380 1
a380 1
		return -1;
d392 1
a392 1
ssh_krl_revoke_key_explicit(struct ssh_krl *krl, const Key *key)
d395 2
a396 1
	u_int len;
d398 3
a400 3
	debug3("%s: revoke type %s", __func__, key_type(key));
	if (plain_key_blob(key, &blob, &len) < 0)
		return -1;
d405 1
a405 1
ssh_krl_revoke_key_sha1(struct ssh_krl *krl, const Key *key)
d408 2
a409 1
	u_int len;
d411 3
a413 3
	debug3("%s: revoke type %s by sha1", __func__, key_type(key));
	if ((blob = key_fingerprint_raw(key, SSH_FP_SHA1, &len)) == NULL)
		return -1;
d418 1
a418 1
ssh_krl_revoke_key(struct ssh_krl *krl, const Key *key)
d420 1
a420 1
	if (!key_is_cert(key))
d423 1
a423 1
	if (key_cert_is_legacy(key) || key->cert->serial == 0) {
d435 2
a436 2
 * Select a copact next section type to emit in a KRL based on the
 * current section type, the run length of contiguous revoked serial
d519 1
a519 1
revoked_certs_generate(struct revoked_certs *rc, Buffer *buf)
d526 1
a526 3
	Buffer sect;
	u_char *kblob = NULL;
	u_int klen;
d529 2
a530 3
	/* Prepare CA scope key blob if we have one supplied */
	if (key_to_blob(rc->ca_key, &kblob, &klen) == 0)
		return -1;
d532 5
a536 1
	buffer_init(&sect);
d538 1
a538 5
	/* Store the header */
	buffer_put_string(buf, kblob, klen);
	buffer_put_string(buf, NULL, 0); /* Reserved */

	free(kblob);
d570 2
a571 1
				buffer_put_bignum2(&sect, bitmap);
d576 4
a579 4
			buffer_put_char(buf, state);
			buffer_put_string(buf,
			    buffer_ptr(&sect), buffer_len(&sect));
			buffer_clear(&sect);
d586 1
a586 1
			buffer_clear(&sect);
d592 2
a593 1
				if ((bitmap = BN_new()) == NULL)
d595 1
d597 3
a599 1
				buffer_put_int64(&sect, bitmap_start);
d607 4
a610 2
			for (i = 0; i < contig; i++)
				buffer_put_int64(&sect, rs->lo + i);
d613 3
a615 2
			buffer_put_int64(&sect, rs->lo);
			buffer_put_int64(&sect, rs->hi);
d624 2
a625 1
				    rs->lo + i - bitmap_start) != 1)
d627 1
d642 2
a643 1
			buffer_put_bignum2(&sect, bitmap);
d648 3
a650 3
		buffer_put_char(buf, state);
		buffer_put_string(buf,
		    buffer_ptr(&sect), buffer_len(&sect));
d655 1
a655 1
	buffer_clear(&sect);
d658 2
a659 1
		buffer_put_cstring(&sect, rki->key_id);
d661 4
a664 4
	if (buffer_len(&sect) != 0) {
		buffer_put_char(buf, KRL_SECTION_CERT_KEY_ID);
		buffer_put_string(buf, buffer_ptr(&sect),
		    buffer_len(&sect));
d670 1
a670 1
	buffer_free(&sect);
d675 2
a676 2
ssh_krl_to_blob(struct ssh_krl *krl, Buffer *buf, const Key **sign_keys,
    u_int nsign_keys)
d681 3
a683 3
	Buffer sect;
	u_char *kblob = NULL, *sblob = NULL;
	u_int klen, slen, i;
d688 2
a689 1
	buffer_init(&sect);
d692 8
a699 7
	buffer_append(buf, KRL_MAGIC, sizeof(KRL_MAGIC) - 1);
	buffer_put_int(buf, KRL_FORMAT_VERSION);
	buffer_put_int64(buf, krl->krl_version);
	buffer_put_int64(buf, krl->generated_date);
	buffer_put_int64(buf, krl->flags);
	buffer_put_string(buf, NULL, 0);
	buffer_put_cstring(buf, krl->comment ? krl->comment : "");
d703 5
a707 2
		buffer_clear(&sect);
		if (revoked_certs_generate(rc, &sect) != 0)
a708 3
		buffer_put_char(buf, KRL_SECTION_CERTIFICATES);
		buffer_put_string(buf, buffer_ptr(&sect),
		    buffer_len(&sect));
d712 1
a712 1
	buffer_clear(&sect);
d714 3
a716 2
		debug3("%s: key len %u ", __func__, rb->len);
		buffer_put_string(&sect, rb->blob, rb->len);
d718 4
a721 4
	if (buffer_len(&sect) != 0) {
		buffer_put_char(buf, KRL_SECTION_EXPLICIT_KEY);
		buffer_put_string(buf, buffer_ptr(&sect),
		    buffer_len(&sect));
d723 1
a723 1
	buffer_clear(&sect);
d725 3
a727 2
		debug3("%s: hash len %u ", __func__, rb->len);
		buffer_put_string(&sect, rb->blob, rb->len);
d729 5
a733 4
	if (buffer_len(&sect) != 0) {
		buffer_put_char(buf, KRL_SECTION_FINGERPRINT_SHA1);
		buffer_put_string(buf, buffer_ptr(&sect),
		    buffer_len(&sect));
d737 2
a738 1
		if (key_to_blob(sign_keys[i], &kblob, &klen) == 0)
d741 4
a744 3
		debug3("%s: signature key len %u", __func__, klen);
		buffer_put_char(buf, KRL_SECTION_SIGNATURE);
		buffer_put_string(buf, kblob, klen);
d746 5
a750 2
		if (key_sign(sign_keys[i], &sblob, &slen,
		    buffer_ptr(buf), buffer_len(buf)) == -1)
a751 2
		debug3("%s: signature sig len %u", __func__, slen);
		buffer_put_string(buf, sblob, slen);
a755 1
	free(kblob);
d757 1
a757 1
	buffer_free(&sect);
d778 1
a778 1
parse_revoked_certs(Buffer *buf, struct ssh_krl *krl)
d780 1
a780 1
	int ret = -1, nbits;
d783 2
a784 2
	u_int blen;
	Buffer subsect;
d788 1
a788 1
	Key *ca_key = NULL;
d790 2
a791 1
	buffer_init(&subsect);
d793 3
a795 3
	if ((blob = buffer_get_string_ptr_ret(buf, &blen)) == NULL ||
	    buffer_get_string_ptr_ret(buf, NULL) == NULL) { /* reserved */
		error("%s: buffer error", __func__);
d797 1
a797 2
	}
	if ((ca_key = key_from_blob(blob, blen)) == NULL)
d800 7
a806 4
	while (buffer_len(buf) > 0) {
		if (buffer_get_char_ret(&type, buf) != 0 ||
		    (blob = buffer_get_string_ptr_ret(buf, &blen)) == NULL) {
			error("%s: buffer error", __func__);
a807 3
		}
		buffer_clear(&subsect);
		buffer_append(&subsect, blob, blen);
a808 1
		/* buffer_dump(&subsect); */
d812 2
a813 4
			while (buffer_len(&subsect) > 0) {
				if (buffer_get_int64_ret(&serial,
				    &subsect) != 0) {
					error("%s: buffer error", __func__);
d815 2
a816 4
				}
				if (ssh_krl_revoke_cert_by_serial(krl, ca_key,
				    serial) != 0) {
					error("%s: update failed", __func__);
a817 1
				}
d821 2
a822 3
			if (buffer_get_int64_ret(&serial_lo, &subsect) != 0 ||
			    buffer_get_int64_ret(&serial_hi, &subsect) != 0) {
				error("%s: buffer error", __func__);
d824 2
a825 4
			}
			if (ssh_krl_revoke_cert_by_serial_range(krl, ca_key,
			    serial_lo, serial_hi) != 0) {
				error("%s: update failed", __func__);
a826 1
			}
d830 1
a830 1
				error("%s: BN_new", __func__);
d833 2
a834 3
			if (buffer_get_int64_ret(&serial_lo, &subsect) != 0 ||
			    buffer_get_bignum2_ret(&subsect, bitmap) != 0) {
				error("%s: buffer error", __func__);
a835 1
			}
d838 1
d844 1
d849 2
a850 3
				if (ssh_krl_revoke_cert_by_serial(krl, ca_key,
				    serial_lo + serial) != 0) {
					error("%s: update failed", __func__);
a851 1
				}
d857 3
a859 4
			while (buffer_len(&subsect) > 0) {
				if ((key_id = buffer_get_cstring_ret(&subsect,
				    NULL)) == NULL) {
					error("%s: buffer error", __func__);
d861 2
a862 4
				}
				if (ssh_krl_revoke_cert_by_key_id(krl, ca_key,
				    key_id) != 0) {
					error("%s: update failed", __func__);
a863 1
				}
d870 1
d873 1
a873 1
		if (buffer_len(&subsect) > 0) {
d875 1
d880 1
a880 1
	ret = 0;
a881 2
	if (ca_key != NULL)
		key_free(ca_key);
d885 3
a887 2
	buffer_free(&subsect);
	return ret;
d893 2
a894 2
ssh_krl_from_blob(Buffer *buf, struct ssh_krl **krlp,
    const Key **sign_ca_keys, u_int nsign_ca_keys)
d896 2
a897 2
	Buffer copy, sect;
	struct ssh_krl *krl;
d899 2
a900 2
	int ret = -1, r, sig_seen;
	Key *key = NULL, **ca_used = NULL;
d903 2
a904 1
	u_int i, j, sig_off, sects_off, rlen, blen, format_version, nca_used;
d908 2
a909 2
	if (buffer_len(buf) < sizeof(KRL_MAGIC) - 1 ||
	    memcmp(buffer_ptr(buf), KRL_MAGIC, sizeof(KRL_MAGIC) - 1) != 0) {
d911 1
a911 5
		/*
		 * Return success but a NULL *krlp here to signal that the
		 * file might be a simple list of keys.
		 */
		return 0;
d915 6
a920 5
	buffer_init(&copy);
	buffer_append(&copy, buffer_ptr(buf), buffer_len(buf));

	buffer_init(&sect);
	buffer_consume(&copy, sizeof(KRL_MAGIC) - 1);
d927 1
a927 2
	if (buffer_get_int_ret(&format_version, &copy) != 0) {
		error("%s: KRL truncated", __func__);
a928 1
	}
d930 1
a930 2
		error("%s: KRL unsupported format version %u",
		    __func__, format_version);
d933 5
a937 6
	if (buffer_get_int64_ret(&krl->krl_version, &copy) != 0 ||
	    buffer_get_int64_ret(&krl->generated_date, &copy) != 0 ||
	    buffer_get_int64_ret(&krl->flags, &copy) != 0 ||
	    buffer_get_string_ptr_ret(&copy, NULL) == NULL || /* reserved */
	    (krl->comment = buffer_get_cstring_ret(&copy, NULL)) == NULL) {
		error("%s: buffer error", __func__);
a938 1
	}
d950 9
a958 5
	sects_off = buffer_len(buf) - buffer_len(&copy);
	while (buffer_len(&copy) > 0) {
		if (buffer_get_char_ret(&type, &copy) != 0 ||
		    (blob = buffer_get_string_ptr_ret(&copy, &blen)) == NULL) {
			error("%s: buffer error", __func__);
a959 1
		}
d963 1
d973 2
a974 1
		if ((key = key_from_blob(blob, blen)) == NULL) {
d978 6
a983 1
		sig_off = buffer_len(buf) - buffer_len(&copy);
d985 2
a986 2
		if ((blob = buffer_get_string_ptr_ret(&copy, &blen)) == NULL) {
			error("%s: buffer error", __func__);
d990 2
a991 2
		if (key_verify(key, blob, blen,
		    buffer_ptr(buf), buffer_len(buf) - sig_off) != 1) {
d997 1
a997 1
			if (key_equal(ca_used[i], key)) {
d1000 1
d1005 7
a1011 1
		ca_used = xrealloc(ca_used, nca_used + 1, sizeof(*ca_used));
d1017 6
d1027 14
a1040 6
	buffer_append(&copy, (u_char*)buffer_ptr(buf) + sects_off,
	    buffer_len(buf) - sects_off);
	while (buffer_len(&copy) > 0) {
		if (buffer_get_char_ret(&type, &copy) != 0 ||
		    (blob = buffer_get_string_ptr_ret(&copy, &blen)) == NULL) {
			error("%s: buffer error", __func__);
a1043 2
		buffer_clear(&sect);
		buffer_append(&sect, blob, blen);
d1047 1
a1047 1
			if ((r = parse_revoked_certs(&sect, krl)) != 0)
d1052 3
a1054 4
			while (buffer_len(&sect) > 0) {
				if ((rdata = buffer_get_string_ret(&sect,
				    &rlen)) == NULL) {
					error("%s: buffer error", __func__);
a1055 1
				}
d1059 1
d1062 1
a1062 1
				if (revoke_blob(
d1065 1
a1065 1
				    rdata, rlen) != 0)
d1072 3
a1074 4
			buffer_clear(&sect);
			if ((blob = buffer_get_string_ptr_ret(&copy,
			    &blen)) == NULL) {
				error("%s: buffer error", __func__);
a1075 1
			}
d1079 1
d1082 1
a1082 1
		if (buffer_len(&sect) > 0) {
d1084 1
d1095 1
a1095 1
			key_free(ca_used[i]);
d1100 1
d1112 1
a1112 1
				if (key_equal(ca_used[j], sign_ca_keys[i])) {
d1119 1
d1126 1
a1126 1
	ret = 0;
d1128 1
a1128 1
	if (ret != 0)
d1130 2
a1131 4
	for (i = 0; i < nca_used; i++) {
		if (ca_used[i] != NULL)
			key_free(ca_used[i]);
	}
d1134 4
a1137 5
	if (key != NULL)
		key_free(key);
	buffer_free(&copy);
	buffer_free(&sect);
	return ret;
d1142 1
a1142 1
is_key_revoked(struct ssh_krl *krl, const Key *key)
d1148 1
d1152 3
a1154 2
	if ((rb.blob = key_fingerprint_raw(key, SSH_FP_SHA1, &rb.len)) == NULL)
		return -1;
d1159 1
a1159 1
		return -1;
d1164 2
a1165 2
	if (plain_key_blob(key, &rb.blob, &rb.len) < 0)
		return -1;
d1170 1
a1170 1
		return -1;
d1173 1
a1173 1
	if (!key_is_cert(key))
d1177 3
a1179 3
	if (revoked_certs_for_ca_key(krl, key->cert->signature_key,
	    &rc, 0) != 0)
		return -1;
d1189 1
a1189 1
		return -1;
d1196 1
a1196 1
	if (key_cert_is_legacy(key) || key->cert->serial == 0)
d1206 1
a1206 1
		return -1;
d1214 1
a1214 1
ssh_krl_check_key(struct ssh_krl *krl, const Key *key)
d1221 1
a1221 1
	if (key_is_cert(key)) {
a1229 1
/* Returns 0 on success, -1 on error or key revoked, -2 if path is not a KRL */
d1231 1
a1231 1
ssh_krl_file_contains_key(const char *path, const Key *key)
d1233 3
a1235 3
	Buffer krlbuf;
	struct ssh_krl *krl;
	int revoked, fd;
d1240 2
d1243 3
a1245 4
		error("open %s: %s", path, strerror(errno));
		error("Revoked keys file not accessible - refusing public key "
		    "authentication");
		return -1;
d1247 3
a1249 7
	buffer_init(&krlbuf);
	if (!key_load_file(fd, path, &krlbuf)) {
		close(fd);
		buffer_free(&krlbuf);
		error("Revoked keys file not readable - refusing public key "
		    "authentication");
		return -1;
d1251 5
d1257 1
a1257 13
	if (ssh_krl_from_blob(&krlbuf, &krl, NULL, 0) != 0) {
		buffer_free(&krlbuf);
		error("Invalid KRL, refusing public key "
		    "authentication");
		return -1;
	}
	buffer_free(&krlbuf);
	if (krl == NULL) {
		debug3("%s: %s is not a KRL file", __func__, path);
		return -2;
	}
	debug2("%s: checking KRL %s", __func__, path);
	revoked = ssh_krl_check_key(krl, key) != 0;
d1259 3
a1261 1
	return revoked ? -1 : 0;
@


1.18
log
@fix KRL generation when multiple CAs are in use

We would generate an invalid KRL when revoking certs by serial
number for multiple CA keys due to a section being written out
twice.

Also extend the regress test to catch this case by having it
produce a multi-CA KRL.

Reported by peter AT pean.org
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.17 2014/06/24 01:13:21 djm Exp $ */
d748 6
a753 2
	*ts = '\0';
	strftime(ts, nts, "%Y%m%dT%H%M%S", tm);
@


1.17
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.16 2014/06/24 00:52:02 djm Exp $ */
d687 1
@


1.16
log
@fix bug in KRL generation: multiple consecutive revoked certificate
serial number ranges could be serialised to an invalid format.

Readers of a broken KRL caused by this bug will fail closed, so no
should-have-been-revoked key will be accepted.
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.15 2014/04/28 03:09:18 djm Exp $ */
d367 1
a367 1
	return r == 0 ? -1 : 0;
d395 1
a395 1
	if (plain_key_blob(key, &blob, &len) != 0)
d1131 1
a1131 1
	if (plain_key_blob(key, &rb.blob, &rb.len) != 0)
@


1.15
log
@buffer_get_string_ptr's return should be const to remind
callers that futzing with it will futz with the actual buffer
contents
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.14 2014/01/31 16:39:19 tedu Exp $ */
d576 1
@


1.14
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.13 2013/07/20 22:20:42 djm Exp $ */
d754 2
a755 1
	u_char type, *blob;
d889 2
a890 1
	u_char type, *blob, *rdata = NULL;
@


1.13
log
@fix verification error in (as-yet usused) KRL signature checking path
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.12 2013/06/20 19:15:06 markus Exp $ */
d239 1
a239 1
	bzero(&rs, sizeof(rs));
d1116 1
a1116 1
	bzero(&rb, sizeof(rb));
d1127 1
a1127 1
	bzero(&rb, sizeof(rb));
d1148 1
a1148 1
	bzero(&rki, sizeof(rki));
d1163 1
a1163 1
	bzero(&rs, sizeof(rs));
@


1.12
log
@don't leak the rdata blob on errors; ok djm@@
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.11 2013/04/05 00:14:00 djm Exp $ */
d974 1
a974 1
		    buffer_ptr(buf), buffer_len(buf) - sig_off) == -1) {
@


1.11
log
@hush some {unused, printf type} warnings
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.10 2013/02/19 02:12:47 dtucker Exp $ */
d888 2
a889 2
	u_char type, *blob;
	u_int i, j, sig_off, sects_off, blen, format_version, nca_used = 0;
d891 1
d1017 2
a1018 2
				if ((blob = buffer_get_string_ret(&sect,
				    &blen)) == NULL) {
d1023 1
a1023 1
				    blen != 20) {
d1030 3
a1032 2
				    blob, blen) != 0)
					goto out; /* revoke_blob frees blob */
d1098 1
@


1.10
log
@Remove bogus include.  ok djm
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.9 2013/01/27 10:06:12 djm Exp $ */
d503 5
a507 2
	    "selected 0x%02x%s", __func__, contig, last_gap, next_gap, final,
	    cost_list, cost_range, cost_bitmap, cost_bitmap_restart, new_state,
d543 2
a544 1
		    rs->lo, rs->hi, state);
d933 3
a935 2
	debug("KRL version %llu generated at %s%s%s", krl->krl_version,
	    timestamp, *krl->comment ? ": " : "", krl->comment);
@


1.9
log
@actually use the xrealloc() return value; spotted by xi.wang AT gmail.com
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.8 2013/01/25 10:22:19 djm Exp $ */
a33 1
#include "err.h"
@


1.8
log
@redo last commit without the vi-vomit that snuck in:

skip serial lookup when cert's serial number is zero

(now with 100% better comment)
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.7 2013/01/25 05:00:27 krw Exp $ */
d982 1
a982 1
		xrealloc(ca_used, nca_used + 1, sizeof(*ca_used));
@


1.7
log
@Revert last. Breaks due to likely typo. Let djm@@ fix later.

ok djm@@ via dlg@@
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.6 2013/01/24 22:08:56 djm Exp $ */
d1149 5
a1153 2
	/* Legacy cert formats lack serial numbers */
	if (key_cert_is_legacy(key))
@


1.6
log
@skip serial lookup when cert's serial number is zero
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.5 2013/01/24 21:45:37 djm Exp $ */
d1150 1
a1150 1
	if (key_cert_is_legacy(key) || key->cert->serial == buf0)
@


1.5
log
@fix handling of (unused) KRL signatures; skip string in correct buffer
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.4 2013/01/19 12:34:55 markus Exp $ */
d1150 1
a1150 1
	if (key_cert_is_legacy(key))
@


1.4
log
@RB_INSERT does not remove existing elments; ok djm@@
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.3 2013/01/18 03:00:32 djm Exp $ */
d1032 1
a1032 1
			if ((blob = buffer_get_string_ptr_ret(&sect,
@


1.3
log
@fix KRL generation bug for list sections
@
text
@d17 1
a17 1
/* $OpenBSD: krl.c,v 1.2 2013/01/18 00:24:58 djm Exp $ */
d253 1
a253 1
			free(ers);
@


1.2
log
@RCD IDs help us keep portable in synch
@
text
@d17 1
a17 1
/* $OpenBSD$ */
d596 1
a596 1
			for (i = rs->lo; i < contig; i++)
@


1.1
log
@add support for Key Revocation Lists (KRLs). These are a compact way to
represent lists of revoked keys and certificates, taking as little as
a single bit of incremental cost to revoke a certificate by serial number.
KRLs are loaded via the existing RevokedKeys sshd_config option.

feedback and ok markus@@
@
text
@d17 2
@

