head	1.222;
access;
symbols
	OPENBSD_6_1:1.218.0.4
	OPENBSD_6_1_BASE:1.218
	OPENBSD_6_0:1.213.0.4
	OPENBSD_6_0_BASE:1.213
	OPENBSD_5_9:1.212.0.2
	OPENBSD_5_9_BASE:1.212
	OPENBSD_5_8:1.204.0.2
	OPENBSD_5_8_BASE:1.204
	OPENBSD_5_7:1.199.0.2
	OPENBSD_5_7_BASE:1.199
	OPENBSD_5_6:1.190.0.4
	OPENBSD_5_6_BASE:1.190
	OPENBSD_5_5:1.183.0.4
	OPENBSD_5_5_BASE:1.183
	OPENBSD_5_4:1.177.0.2
	OPENBSD_5_4_BASE:1.177
	OPENBSD_5_3:1.172.0.8
	OPENBSD_5_3_BASE:1.172
	OPENBSD_5_2:1.172.0.6
	OPENBSD_5_2_BASE:1.172
	OPENBSD_5_1_BASE:1.172
	OPENBSD_5_1:1.172.0.4
	OPENBSD_5_0:1.172.0.2
	OPENBSD_5_0_BASE:1.172
	OPENBSD_4_9:1.171.0.2
	OPENBSD_4_9_BASE:1.171
	OPENBSD_4_8:1.166.0.2
	OPENBSD_4_8_BASE:1.166
	OPENBSD_4_7:1.165.0.2
	OPENBSD_4_7_BASE:1.165
	OPENBSD_4_6:1.161.0.4
	OPENBSD_4_6_BASE:1.161
	OPENBSD_4_5:1.159.0.4
	OPENBSD_4_5_BASE:1.159
	OPENBSD_4_4:1.159.0.2
	OPENBSD_4_4_BASE:1.159
	OPENBSD_4_3:1.157.0.2
	OPENBSD_4_3_BASE:1.157
	OPENBSD_4_2:1.155.0.2
	OPENBSD_4_2_BASE:1.155
	OPENBSD_4_1:1.154.0.2
	OPENBSD_4_1_BASE:1.154
	OPENBSD_4_0:1.152.0.4
	OPENBSD_4_0_BASE:1.152
	OPENBSD_3_9:1.129.0.2
	OPENBSD_3_9_BASE:1.129
	OPENBSD_3_8:1.122.0.4
	OPENBSD_3_8_BASE:1.122
	OPENBSD_3_7:1.122.0.2
	OPENBSD_3_7_BASE:1.122
	OPENBSD_3_6:1.120.0.2
	OPENBSD_3_6_BASE:1.120
	OPENBSD_3_5:1.117.0.2
	OPENBSD_3_5_BASE:1.117
	OPENBSD_3_4:1.111.0.2
	OPENBSD_3_4_BASE:1.111
	OPENBSD_3_3:1.108.0.2
	OPENBSD_3_3_BASE:1.108
	OPENBSD_3_2:1.105.0.2
	OPENBSD_3_2_BASE:1.105
	OPENBSD_3_1:1.85.0.2
	OPENBSD_3_1_BASE:1.85
	OPENBSD_3_0:1.72.0.2
	OPENBSD_3_0_BASE:1.72
	OPENBSD_2_9_BASE:1.54
	OPENBSD_2_9:1.54.0.2
	OPENBSD_2_8:1.37.0.2
	OPENBSD_2_8_BASE:1.37
	OPENBSD_2_7:1.31.0.2
	OPENBSD_2_7_BASE:1.31
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12;
locks; strict;
comment	@ * @;


1.222
date	2017.07.01.13.50.45;	author djm;	state Exp;
branches;
next	1.221;
commitid	jGKycoTTk52hb7Q7;

1.221
date	2017.04.30.23.29.10;	author djm;	state Exp;
branches;
next	1.220;
commitid	rciB7vMOEFsiXwQn;

1.220
date	2017.04.30.23.18.44;	author djm;	state Exp;
branches;
next	1.219;
commitid	NPnVhZTcf5ddO7Ys;

1.219
date	2017.04.30.23.10.43;	author djm;	state Exp;
branches;
next	1.218;
commitid	I15vriCkYNtbTkea;

1.218
date	2017.03.15.03.52.30;	author deraadt;	state Exp;
branches;
next	1.217;
commitid	qRmm94EhoSW3aSxU;

1.217
date	2017.03.15.02.25.09;	author djm;	state Exp;
branches;
next	1.216;
commitid	Sf0PbhgKYSI91Fst;

1.216
date	2017.01.04.02.21.43;	author djm;	state Exp;
branches;
next	1.215;
commitid	iX4zbgFPsdFnIBFG;

1.215
date	2016.11.30.03.07.37;	author djm;	state Exp;
branches;
next	1.214;
commitid	VAcQ8Lcp3jZIPYug;

1.214
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.213;
commitid	ZllbGwdb0fOmLhjK;

1.213
date	2016.05.02.08.49.03;	author djm;	state Exp;
branches;
next	1.212;
commitid	RYYIr1bk0phq4fXa;

1.212
date	2016.02.15.09.47.49;	author dtucker;	state Exp;
branches;
next	1.211;
commitid	ut5A0buLh4mhCTFu;

1.211
date	2015.12.11.17.41.37;	author doug;	state Exp;
branches;
next	1.210;
commitid	4ibl2hTc8d8N91aN;

1.210
date	2015.12.11.02.29.03;	author dtucker;	state Exp;
branches;
next	1.209;
commitid	qMjwVcn8AwY7AQX9;

1.209
date	2015.12.11.02.20.28;	author djm;	state Exp;
branches;
next	1.208;
commitid	NUwbaO6bOxtvjc7f;

1.208
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.207;
commitid	K3glY441IowbrjDE;

1.207
date	2015.12.02.08.30.50;	author doug;	state Exp;
branches;
next	1.206;
commitid	NTpi3BbjpjHwOy5H;

1.206
date	2015.12.02.08.00.58;	author djm;	state Exp;
branches;
next	1.205;
commitid	ris2dY9wdU5hKflz;

1.205
date	2015.12.01.23.29.24;	author djm;	state Exp;
branches;
next	1.204;
commitid	d47q9txn3osl9U3Z;

1.204
date	2015.07.08.20.24.02;	author markus;	state Exp;
branches;
next	1.203;
commitid	mKLQG5SNiHQRsgHX;

1.203
date	2015.05.15.05.44.21;	author dtucker;	state Exp;
branches;
next	1.202;
commitid	h8qbFCSGF6M1csST;

1.202
date	2015.04.24.06.26.49;	author jmc;	state Exp;
branches;
next	1.201;
commitid	2XhbQZadvmW3msbS;

1.201
date	2015.04.24.05.26.44;	author djm;	state Exp;
branches;
next	1.200;
commitid	N4vqpShIXxgj42tK;

1.200
date	2015.04.24.01.36.01;	author deraadt;	state Exp;
branches;
next	1.199;
commitid	LHkUmZjv49ojnnuH;

1.199
date	2015.03.04.21.12.59;	author djm;	state Exp;
branches;
next	1.198;
commitid	OG0uS1jmI76qUAa4;

1.198
date	2015.03.03.21.21.13;	author djm;	state Exp;
branches;
next	1.197;
commitid	fcvr9LotYI8aCFuc;

1.197
date	2015.01.28.22.36.00;	author djm;	state Exp;
branches;
next	1.196;
commitid	P7KG9D8zB61mMUPV;

1.196
date	2015.01.16.06.40.12;	author deraadt;	state Exp;
branches;
next	1.195;
commitid	Uu5nFG3wCl0LACBb;

1.195
date	2015.01.14.19.33.41;	author djm;	state Exp;
branches;
next	1.194;
commitid	955Vm6zTYxdB0Nps;

1.194
date	2015.01.14.13.09.09;	author markus;	state Exp;
branches;
next	1.193;
commitid	LRpjx7B7FgiJTEln;

1.193
date	2014.12.21.23.35.14;	author jmc;	state Exp;
branches;
next	1.192;
commitid	X5Oj8Q22f6kzmo94;

1.192
date	2014.12.21.22.27.56;	author djm;	state Exp;
branches;
next	1.191;
commitid	EbtriidyZdsmXksl;

1.191
date	2014.11.18.20.54.28;	author krw;	state Exp;
branches;
next	1.190;
commitid	yCis8OrOsfixbKpI;

1.190
date	2014.07.25.21.22.03;	author dtucker;	state Exp;
branches;
next	1.189;
commitid	itzZO2FbnSpUXevd;

1.189
date	2014.07.18.02.46.01;	author djm;	state Exp;
branches;
next	1.188;
commitid	CxKOY4A8ynlyRRxg;

1.188
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.187;
commitid	z7plx8Gkj6l2sxem;

1.187
date	2014.07.03.03.11.03;	author djm;	state Exp;
branches;
next	1.186;
commitid	ZnZUpJed6SR6vw6R;

1.186
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.185;
commitid	1h9UxAQmwdaqUzyX;

1.185
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.184;

1.184
date	2014.03.15.17.28.26;	author deraadt;	state Exp;
branches;
next	1.183;

1.183
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.182;

1.182
date	2014.01.27.19.18.54;	author markus;	state Exp;
branches;
next	1.181;

1.181
date	2013.12.19.01.19.41;	author djm;	state Exp;
branches;
next	1.180;

1.180
date	2013.12.06.13.39.49;	author markus;	state Exp;
branches;
next	1.179;

1.179
date	2013.12.06.13.34.54;	author markus;	state Exp;
branches;
next	1.178;

1.178
date	2013.12.06.13.30.08;	author markus;	state Exp;
branches;
next	1.177;

1.177
date	2013.07.20.01.50.20;	author djm;	state Exp;
branches;
next	1.176;

1.176
date	2013.06.02.13.35.58;	author dtucker;	state Exp;
branches;
next	1.175;

1.175
date	2013.06.01.13.15.52;	author dtucker;	state Exp;
branches;
next	1.174;

1.174
date	2013.05.31.12.28.10;	author dtucker;	state Exp;
branches;
next	1.173;

1.173
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.172;

1.172
date	2011.06.03.01.37.40;	author dtucker;	state Exp;
branches;
next	1.171;

1.171
date	2010.11.21.01.01.13;	author djm;	state Exp;
branches;
next	1.170;

1.170
date	2010.08.31.12.33.38;	author djm;	state Exp;
branches;
next	1.169;

1.169
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.168;

1.168
date	2010.08.16.04.06.06;	author djm;	state Exp;
branches;
next	1.167;

1.167
date	2010.08.12.23.34.38;	author tedu;	state Exp;
branches;
next	1.166;

1.166
date	2010.04.16.01.47.26;	author djm;	state Exp;
branches;
next	1.165;

1.165
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.164;

1.164
date	2010.02.09.00.50.36;	author djm;	state Exp;
branches;
next	1.163;

1.163
date	2010.02.08.10.50.20;	author markus;	state Exp;
branches;
next	1.162;

1.162
date	2009.09.01.14.43.17;	author djm;	state Exp;
branches;
next	1.161;

1.161
date	2009.03.23.19.38.04;	author tobias;	state Exp;
branches;
next	1.160;

1.160
date	2009.03.23.08.31.19;	author tobias;	state Exp;
branches;
next	1.159;

1.159
date	2008.06.28.14.05.15;	author djm;	state Exp;
branches;
next	1.158;

1.158
date	2008.06.28.13.58.23;	author djm;	state Exp;
branches;
next	1.157;

1.157
date	2007.09.25.23.48.57;	author canacar;	state Exp;
branches;
next	1.156;

1.156
date	2007.09.09.11.38.01;	author sobrado;	state Exp;
branches;
next	1.155;

1.155
date	2007.03.19.12.16.42;	author dtucker;	state Exp;
branches;
next	1.154;

1.154
date	2007.02.28.00.55.30;	author dtucker;	state Exp;
branches;
next	1.153;

1.153
date	2006.10.06.02.29.19;	author djm;	state Exp;
branches;
next	1.152;

1.152
date	2006.08.04.20.46.05;	author stevesk;	state Exp;
branches
	1.152.4.1;
next	1.151;

1.151
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.150;

1.150
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.149;

1.149
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.148;

1.148
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.147;

1.147
date	2006.07.25.02.59.21;	author stevesk;	state Exp;
branches;
next	1.146;

1.146
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.145;

1.145
date	2006.07.22.19.08.54;	author stevesk;	state Exp;
branches;
next	1.144;

1.144
date	2006.07.17.01.31.10;	author stevesk;	state Exp;
branches;
next	1.143;

1.143
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.142;

1.142
date	2006.07.09.15.15.11;	author stevesk;	state Exp;
branches;
next	1.141;

1.141
date	2006.07.08.21.47.12;	author stevesk;	state Exp;
branches;
next	1.140;

1.140
date	2006.06.13.02.17.07;	author djm;	state Exp;
branches;
next	1.139;

1.139
date	2006.06.13.01.18.36;	author djm;	state Exp;
branches;
next	1.138;

1.138
date	2006.05.17.12.43.34;	author markus;	state Exp;
branches;
next	1.137;

1.137
date	2006.03.30.09.58.16;	author djm;	state Exp;
branches;
next	1.136;

1.136
date	2006.03.28.01.53.43;	author deraadt;	state Exp;
branches;
next	1.135;

1.135
date	2006.03.25.18.41.45;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.133;

1.133
date	2006.03.25.01.13.23;	author djm;	state Exp;
branches;
next	1.132;

1.132
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.131;

1.131
date	2006.03.20.18.26.55;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2006.02.20.17.02.44;	author stevesk;	state Exp;
branches
	1.129.2.1;
next	1.128;

1.128
date	2006.02.20.16.36.14;	author stevesk;	state Exp;
branches;
next	1.127;

1.127
date	2006.02.08.14.31.30;	author stevesk;	state Exp;
branches;
next	1.126;

1.126
date	2006.02.08.12.15.27;	author stevesk;	state Exp;
branches;
next	1.125;

1.125
date	2006.02.07.01.18.09;	author stevesk;	state Exp;
branches;
next	1.124;

1.124
date	2005.10.30.08.52.18;	author djm;	state Exp;
branches;
next	1.123;

1.123
date	2005.09.13.23.40.07;	author djm;	state Exp;
branches;
next	1.122;

1.122
date	2004.10.29.22.53.56;	author djm;	state Exp;
branches
	1.122.2.1
	1.122.4.1;
next	1.121;

1.121
date	2004.10.07.10.12.36;	author djm;	state Exp;
branches;
next	1.120;

1.120
date	2004.08.11.21.43.05;	author avsm;	state Exp;
branches
	1.120.2.1;
next	1.119;

1.119
date	2004.06.14.01.44.39;	author djm;	state Exp;
branches;
next	1.118;

1.118
date	2004.05.08.00.21.31;	author djm;	state Exp;
branches;
next	1.117;

1.117
date	2003.12.02.17.01.15;	author markus;	state Exp;
branches
	1.117.2.1;
next	1.116;

1.116
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches;
next	1.115;

1.115
date	2003.10.14.19.54.39;	author markus;	state Exp;
branches;
next	1.114;

1.114
date	2003.09.23.20.17.11;	author markus;	state Exp;
branches;
next	1.113;

1.113
date	2003.09.19.11.29.40;	author markus;	state Exp;
branches;
next	1.112;

1.112
date	2003.09.18.08.49.45;	author markus;	state Exp;
branches;
next	1.111;

1.111
date	2003.06.12.19.12.03;	author markus;	state Exp;
branches
	1.111.2.1;
next	1.110;

1.110
date	2003.06.11.11.18.38;	author djm;	state Exp;
branches;
next	1.109;

1.109
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches;
next	1.108;

1.108
date	2003.03.13.11.44.50;	author markus;	state Exp;
branches
	1.108.2.1;
next	1.107;

1.107
date	2003.01.23.13.50.27;	author markus;	state Exp;
branches;
next	1.106;

1.106
date	2003.01.21.18.14.36;	author marc;	state Exp;
branches;
next	1.105;

1.105
date	2002.10.01.20.34.12;	author markus;	state Exp;
branches
	1.105.2.1;
next	1.104;

1.104
date	2002.09.12.19.11.52;	author stevesk;	state Exp;
branches;
next	1.103;

1.103
date	2002.09.10.20.24.47;	author markus;	state Exp;
branches;
next	1.102;

1.102
date	2002.08.22.20.57.19;	author stevesk;	state Exp;
branches;
next	1.101;

1.101
date	2002.08.22.19.27.53;	author stevesk;	state Exp;
branches;
next	1.100;

1.100
date	2002.08.21.20.10.28;	author stevesk;	state Exp;
branches;
next	1.99;

1.99
date	2002.08.12.10.46.35;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2002.07.21.18.07.45;	author stevesk;	state Exp;
branches;
next	1.97;

1.97
date	2002.06.24.14.55.38;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2002.06.23.10.29.52;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2002.06.15.01.27.48;	author markus;	state Exp;
branches;
next	1.93;

1.93
date	2002.06.15.00.07.38;	author markus;	state Exp;
branches;
next	1.92;

1.92
date	2002.06.15.00.01.36;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2002.06.11.05.46.20;	author mpech;	state Exp;
branches;
next	1.90;

1.90
date	2002.06.09.13.32.01;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2002.06.05.21.55.44;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2002.06.05.19.57.12;	author markus;	state Exp;
branches;
next	1.87;

1.87
date	2002.06.05.16.48.54;	author markus;	state Exp;
branches;
next	1.86;

1.86
date	2002.06.05.16.08.07;	author markus;	state Exp;
branches;
next	1.85;

1.85
date	2002.04.02.11.49.39;	author markus;	state Exp;
branches
	1.85.2.1;
next	1.84;

1.84
date	2002.03.25.17.34.27;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2002.03.21.22.44.05;	author rees;	state Exp;
branches;
next	1.82;

1.82
date	2002.03.04.17.27.39;	author stevesk;	state Exp;
branches;
next	1.81;

1.81
date	2002.02.05.15.50.12;	author stevesk;	state Exp;
branches;
next	1.80;

1.80
date	2002.02.04.00.53.39;	author stevesk;	state Exp;
branches;
next	1.79;

1.79
date	2002.01.18.18.14.17;	author stevesk;	state Exp;
branches;
next	1.78;

1.78
date	2002.01.13.17.27.07;	author provos;	state Exp;
branches;
next	1.77;

1.77
date	2001.12.29.21.56.01;	author stevesk;	state Exp;
branches;
next	1.76;

1.76
date	2001.12.27.18.22.16;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2001.12.05.10.06.12;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2001.11.17.19.14.34;	author stevesk;	state Exp;
branches;
next	1.72;

1.72
date	2001.08.03.10.31.30;	author jakob;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2001.08.02.16.14.05;	author jakob;	state Exp;
branches;
next	1.70;

1.70
date	2001.08.02.15.43.57;	author jakob;	state Exp;
branches;
next	1.69;

1.69
date	2001.08.01.22.03.33;	author markus;	state Exp;
branches;
next	1.68;

1.68
date	2001.07.20.14.46.11;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2001.07.18.21.40.40;	author stevesk;	state Exp;
branches;
next	1.66;

1.66
date	2001.07.17.20.48.42;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2001.07.15.16.58.29;	author stevesk;	state Exp;
branches;
next	1.64;

1.64
date	2001.07.04.23.49.27;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2001.07.04.23.39.07;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2001.07.04.23.13.10;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2001.07.04.22.47.19;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2001.06.27.05.42.25;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2001.06.26.05.33.34;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2001.06.26.05.07.43;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2001.06.26.04.07.06;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2001.06.25.08.25.40;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2001.06.23.15.12.20;	author itojun;	state Exp;
branches;
next	1.54;

1.54
date	2001.04.03.13.56.11;	author stevesk;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2001.03.26.23.23.24;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2001.03.06.00.33.04;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2001.03.02.18.54.31;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2001.02.08.19.30.52;	author itojun;	state Exp;
branches;
next	1.49;

1.49
date	2001.01.29.19.47.31;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2001.01.25.08.06.33;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2001.01.21.19.05.56;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2001.01.11.21.37.30;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2000.12.19.23.17.58;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2000.12.19.22.43.45;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2000.12.13.23.25.44;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2000.12.09.14.06.54;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2000.11.30.18.33.05;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2000.11.14.23.48.55;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2000.11.12.19.50.38;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2000.11.12.19.03.28;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2000.09.21.11.07.51;	author markus;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2000.09.15.07.13.49;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.07.20.27.54;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2000.08.31.22.09.34;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2000.08.19.21.34.43;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2000.07.16.08.27.21;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2000.04.29.18.11.52;	author markus;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2000.04.21.00.27.11;	author djm;	state Exp;
branches;
next	1.29;

1.29
date	2000.04.19.07.05.49;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.14.10.30.33;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.12.09.39.10;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.16.20.56.14;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2000.01.02.21.51.03;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	99.12.15.19.43.10;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	99.11.24.19.53.51;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	99.11.24.00.26.03;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	99.11.23.22.25.55;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	99.11.19.10.20.51;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	99.11.18.14.00.49;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	99.11.15.20.53.24;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	99.11.02.19.42.36;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	99.10.28.20.41.23;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	99.10.28.08.43.10;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	99.10.27.23.34.53;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	99.10.27.16.37.45;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.10.14.18.17.42;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	99.10.07.22.46.32;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	99.10.05.22.18.52;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.10.04.20.45.01;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	99.10.03.19.22.38;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.09.30.17.08.52;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.09.30.08.34.25;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.09.30.05.11.29;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.21.14.16;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.06.15.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.04.45.37;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.37;	author deraadt;	state Exp;
branches;
next	;

1.31.2.1
date	2000.09.01.18.23.23;	author jason;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2000.11.08.21.31.21;	author jason;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2001.03.12.15.44.15;	author jason;	state Exp;
branches;
next	1.31.2.4;

1.31.2.4
date	2001.03.21.18.53.08;	author jason;	state Exp;
branches;
next	;

1.37.2.1
date	2001.02.16.20.13.17;	author jason;	state Exp;
branches;
next	1.37.2.2;

1.37.2.2
date	2001.02.19.17.19.27;	author jason;	state Exp;
branches;
next	1.37.2.3;

1.37.2.3
date	2001.03.21.19.46.29;	author jason;	state Exp;
branches;
next	1.37.2.4;

1.37.2.4
date	2001.05.07.21.09.35;	author jason;	state Exp;
branches;
next	1.37.2.5;

1.37.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.37.2.6;

1.37.2.6
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.54.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	1.54.2.3;

1.54.2.3
date	2002.06.02.22.56.11;	author miod;	state Exp;
branches;
next	;

1.72.2.1
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.72.2.2;

1.72.2.2
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.72.2.3;

1.72.2.3
date	2002.06.22.07.23.18;	author miod;	state Exp;
branches;
next	1.72.2.4;

1.72.2.4
date	2002.06.26.18.22.36;	author miod;	state Exp;
branches;
next	1.72.2.5;

1.72.2.5
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.85.2.1
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	1.85.2.2;

1.85.2.2
date	2002.10.11.14.51.53;	author miod;	state Exp;
branches;
next	1.85.2.3;

1.85.2.3
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.105.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.105.2.2;

1.105.2.2
date	2003.09.16.21.20.27;	author brad;	state Exp;
branches;
next	;

1.108.2.1
date	2003.09.16.20.50.44;	author brad;	state Exp;
branches;
next	1.108.2.2;

1.108.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.111.2.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	1.111.2.2;

1.111.2.2
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.117.2.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	1.117.2.2;

1.117.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.120.2.1
date	2005.03.10.16.28.28;	author brad;	state Exp;
branches;
next	;

1.122.2.1
date	2006.02.03.02.53.45;	author brad;	state Exp;
branches;
next	;

1.122.4.1
date	2006.02.03.03.01.57;	author brad;	state Exp;
branches;
next	1.122.4.2;

1.122.4.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	1.122.4.3;

1.122.4.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.129.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	1.129.2.2;

1.129.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.152.4.1
date	2006.11.08.00.42.11;	author brad;	state Exp;
branches;
next	;


desc
@@


1.222
log
@remove post-SSHv1 removal dead code from rsa.c and merge the
remaining bit that it still used into ssh-rsa.c; ok markus
@
text
@/* $OpenBSD: ssh-agent.c,v 1.221 2017/04/30 23:29:10 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * The authentication agent program.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/queue.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/un.h>

#ifdef WITH_OPENSSL
#include <openssl/evp.h>
#endif

#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <time.h>
#include <unistd.h>
#include <util.h>

#include "xmalloc.h"
#include "ssh.h"
#include "sshbuf.h"
#include "sshkey.h"
#include "authfd.h"
#include "compat.h"
#include "log.h"
#include "misc.h"
#include "digest.h"
#include "ssherr.h"
#include "match.h"

#ifdef ENABLE_PKCS11
#include "ssh-pkcs11.h"
#endif

#ifndef DEFAULT_PKCS11_WHITELIST
# define DEFAULT_PKCS11_WHITELIST "/usr/lib*/*,/usr/local/lib*/*"
#endif

typedef enum {
	AUTH_UNUSED,
	AUTH_SOCKET,
	AUTH_CONNECTION
} sock_type;

typedef struct {
	int fd;
	sock_type type;
	struct sshbuf *input;
	struct sshbuf *output;
	struct sshbuf *request;
} SocketEntry;

u_int sockets_alloc = 0;
SocketEntry *sockets = NULL;

typedef struct identity {
	TAILQ_ENTRY(identity) next;
	struct sshkey *key;
	char *comment;
	char *provider;
	time_t death;
	u_int confirm;
} Identity;

struct idtable {
	int nentries;
	TAILQ_HEAD(idqueue, identity) idlist;
};

/* private key table */
struct idtable *idtab;

int max_fd = 0;

/* pid of shell == parent of agent */
pid_t parent_pid = -1;
time_t parent_alive_interval = 0;

/* pid of process for which cleanup_socket is applicable */
pid_t cleanup_pid = 0;

/* pathname and directory for AUTH_SOCKET */
char socket_name[PATH_MAX];
char socket_dir[PATH_MAX];

/* PKCS#11 path whitelist */
static char *pkcs11_whitelist;

/* locking */
#define LOCK_SIZE	32
#define LOCK_SALT_SIZE	16
#define LOCK_ROUNDS	1
int locked = 0;
u_char lock_pwhash[LOCK_SIZE];
u_char lock_salt[LOCK_SALT_SIZE];

extern char *__progname;

/* Default lifetime in seconds (0 == forever) */
static long lifetime = 0;

static int fingerprint_hash = SSH_FP_HASH_DEFAULT;

static void
close_socket(SocketEntry *e)
{
	close(e->fd);
	e->fd = -1;
	e->type = AUTH_UNUSED;
	sshbuf_free(e->input);
	sshbuf_free(e->output);
	sshbuf_free(e->request);
}

static void
idtab_init(void)
{
	idtab = xcalloc(1, sizeof(*idtab));
	TAILQ_INIT(&idtab->idlist);
	idtab->nentries = 0;
}

static void
free_identity(Identity *id)
{
	sshkey_free(id->key);
	free(id->provider);
	free(id->comment);
	free(id);
}

/* return matching private key for given public key */
static Identity *
lookup_identity(struct sshkey *key)
{
	Identity *id;

	TAILQ_FOREACH(id, &idtab->idlist, next) {
		if (sshkey_equal(key, id->key))
			return (id);
	}
	return (NULL);
}

/* Check confirmation of keysign request */
static int
confirm_key(Identity *id)
{
	char *p;
	int ret = -1;

	p = sshkey_fingerprint(id->key, fingerprint_hash, SSH_FP_DEFAULT);
	if (p != NULL &&
	    ask_permission("Allow use of key %s?\nKey fingerprint %s.",
	    id->comment, p))
		ret = 0;
	free(p);

	return (ret);
}

static void
send_status(SocketEntry *e, int success)
{
	int r;

	if ((r = sshbuf_put_u32(e->output, 1)) != 0 ||
	    (r = sshbuf_put_u8(e->output, success ?
	    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
}

/* send list of supported public keys to 'client' */
static void
process_request_identities(SocketEntry *e)
{
	Identity *id;
	struct sshbuf *msg;
	int r;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||
	    (r = sshbuf_put_u32(msg, idtab->nentries)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	TAILQ_FOREACH(id, &idtab->idlist, next) {
		if ((r = sshkey_puts(id->key, msg)) != 0 ||
		    (r = sshbuf_put_cstring(msg, id->comment)) != 0) {
			error("%s: put key/comment: %s", __func__,
			    ssh_err(r));
			continue;
		}
	}
	if ((r = sshbuf_put_stringb(e->output, msg)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	sshbuf_free(msg);
}


static char *
agent_decode_alg(struct sshkey *key, u_int flags)
{
	if (key->type == KEY_RSA) {
		if (flags & SSH_AGENT_RSA_SHA2_256)
			return "rsa-sha2-256";
		else if (flags & SSH_AGENT_RSA_SHA2_512)
			return "rsa-sha2-512";
	}
	return NULL;
}

/* ssh2 only */
static void
process_sign_request2(SocketEntry *e)
{
	const u_char *data;
	u_char *signature = NULL;
	size_t dlen, slen = 0;
	u_int compat = 0, flags;
	int r, ok = -1;
	struct sshbuf *msg;
	struct sshkey *key = NULL;
	struct identity *id;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshkey_froms(e->request, &key)) != 0 ||
	    (r = sshbuf_get_string_direct(e->request, &data, &dlen)) != 0 ||
	    (r = sshbuf_get_u32(e->request, &flags)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (flags & SSH_AGENT_OLD_SIGNATURE)
		compat = SSH_BUG_SIGBLOB;
	if ((id = lookup_identity(key)) == NULL) {
		verbose("%s: %s key not found", __func__, sshkey_type(key));
		goto send;
	}
	if (id->confirm && confirm_key(id) != 0) {
		verbose("%s: user refused key", __func__);
		goto send;
	}
	if ((r = sshkey_sign(id->key, &signature, &slen,
	    data, dlen, agent_decode_alg(key, flags), compat)) != 0) {
		error("%s: sshkey_sign: %s", __func__, ssh_err(r));
		goto send;
	}
	/* Success */
	ok = 0;
 send:
	sshkey_free(key);
	if (ok == 0) {
		if ((r = sshbuf_put_u8(msg, SSH2_AGENT_SIGN_RESPONSE)) != 0 ||
		    (r = sshbuf_put_string(msg, signature, slen)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
	} else if ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	if ((r = sshbuf_put_stringb(e->output, msg)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	sshbuf_free(msg);
	free(signature);
}

/* shared */
static void
process_remove_identity(SocketEntry *e)
{
	int r, success = 0;
	struct sshkey *key = NULL;
	Identity *id;

	if ((r = sshkey_froms(e->request, &key)) != 0) {
		error("%s: get key: %s", __func__, ssh_err(r));
		goto done;
	}
	if ((id = lookup_identity(key)) == NULL) {
		debug("%s: key not found", __func__);
		goto done;
	}
	/* We have this key, free it. */
	if (idtab->nentries < 1)
		fatal("%s: internal error: nentries %d",
		    __func__, idtab->nentries);
	TAILQ_REMOVE(&idtab->idlist, id, next);
	free_identity(id);
	idtab->nentries--;
	sshkey_free(key);
	success = 1;
 done:
	send_status(e, success);
}

static void
process_remove_all_identities(SocketEntry *e)
{
	Identity *id;

	/* Loop over all identities and clear the keys. */
	for (id = TAILQ_FIRST(&idtab->idlist); id;
	    id = TAILQ_FIRST(&idtab->idlist)) {
		TAILQ_REMOVE(&idtab->idlist, id, next);
		free_identity(id);
	}

	/* Mark that there are no identities. */
	idtab->nentries = 0;

	/* Send success. */
	send_status(e, 1);
}

/* removes expired keys and returns number of seconds until the next expiry */
static time_t
reaper(void)
{
	time_t deadline = 0, now = monotime();
	Identity *id, *nxt;

	for (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {
		nxt = TAILQ_NEXT(id, next);
		if (id->death == 0)
			continue;
		if (now >= id->death) {
			debug("expiring key '%s'", id->comment);
			TAILQ_REMOVE(&idtab->idlist, id, next);
			free_identity(id);
			idtab->nentries--;
		} else
			deadline = (deadline == 0) ? id->death :
			    MINIMUM(deadline, id->death);
	}
	if (deadline == 0 || deadline <= now)
		return 0;
	else
		return (deadline - now);
}

static void
process_add_identity(SocketEntry *e)
{
	Identity *id;
	int success = 0, confirm = 0;
	u_int seconds;
	char *comment = NULL;
	time_t death = 0;
	struct sshkey *k = NULL;
	u_char ctype;
	int r = SSH_ERR_INTERNAL_ERROR;

	if ((r = sshkey_private_deserialize(e->request, &k)) != 0 ||
	    k == NULL ||
	    (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {
		error("%s: decode private key: %s", __func__, ssh_err(r));
		goto err;
	}

	while (sshbuf_len(e->request)) {
		if ((r = sshbuf_get_u8(e->request, &ctype)) != 0) {
			error("%s: buffer error: %s", __func__, ssh_err(r));
			goto err;
		}
		switch (ctype) {
		case SSH_AGENT_CONSTRAIN_LIFETIME:
			if ((r = sshbuf_get_u32(e->request, &seconds)) != 0) {
				error("%s: bad lifetime constraint: %s",
				    __func__, ssh_err(r));
				goto err;
			}
			death = monotime() + seconds;
			break;
		case SSH_AGENT_CONSTRAIN_CONFIRM:
			confirm = 1;
			break;
		default:
			error("%s: Unknown constraint %d", __func__, ctype);
 err:
			sshbuf_reset(e->request);
			free(comment);
			sshkey_free(k);
			goto send;
		}
	}

	success = 1;
	if (lifetime && !death)
		death = monotime() + lifetime;
	if ((id = lookup_identity(k)) == NULL) {
		id = xcalloc(1, sizeof(Identity));
		id->key = k;
		TAILQ_INSERT_TAIL(&idtab->idlist, id, next);
		/* Increment the number of identities. */
		idtab->nentries++;
	} else {
		sshkey_free(k);
		free(id->comment);
	}
	id->comment = comment;
	id->death = death;
	id->confirm = confirm;
send:
	send_status(e, success);
}

/* XXX todo: encrypt sensitive data with passphrase */
static void
process_lock_agent(SocketEntry *e, int lock)
{
	int r, success = 0, delay;
	char *passwd;
	u_char passwdhash[LOCK_SIZE];
	static u_int fail_count = 0;
	size_t pwlen;

	if ((r = sshbuf_get_cstring(e->request, &passwd, &pwlen)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (pwlen == 0) {
		debug("empty password not supported");
	} else if (locked && !lock) {
		if (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),
		    passwdhash, sizeof(passwdhash), LOCK_ROUNDS) < 0)
			fatal("bcrypt_pbkdf");
		if (timingsafe_bcmp(passwdhash, lock_pwhash, LOCK_SIZE) == 0) {
			debug("agent unlocked");
			locked = 0;
			fail_count = 0;
			explicit_bzero(lock_pwhash, sizeof(lock_pwhash));
			success = 1;
		} else {
			/* delay in 0.1s increments up to 10s */
			if (fail_count < 100)
				fail_count++;
			delay = 100000 * fail_count;
			debug("unlock failed, delaying %0.1lf seconds",
			    (double)delay/1000000);
			usleep(delay);
		}
		explicit_bzero(passwdhash, sizeof(passwdhash));
	} else if (!locked && lock) {
		debug("agent locked");
		locked = 1;
		arc4random_buf(lock_salt, sizeof(lock_salt));
		if (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),
		    lock_pwhash, sizeof(lock_pwhash), LOCK_ROUNDS) < 0)
			fatal("bcrypt_pbkdf");
		success = 1;
	}
	explicit_bzero(passwd, pwlen);
	free(passwd);
	send_status(e, success);
}

static void
no_identities(SocketEntry *e)
{
	struct sshbuf *msg;
	int r;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||
	    (r = sshbuf_put_u32(msg, 0)) != 0 ||
	    (r = sshbuf_put_stringb(e->output, msg)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	sshbuf_free(msg);
}

#ifdef ENABLE_PKCS11
static void
process_add_smartcard_key(SocketEntry *e)
{
	char *provider = NULL, *pin, canonical_provider[PATH_MAX];
	int r, i, count = 0, success = 0, confirm = 0;
	u_int seconds;
	time_t death = 0;
	u_char type;
	struct sshkey **keys = NULL, *k;
	Identity *id;

	if ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||
	    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	while (sshbuf_len(e->request)) {
		if ((r = sshbuf_get_u8(e->request, &type)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		switch (type) {
		case SSH_AGENT_CONSTRAIN_LIFETIME:
			if ((r = sshbuf_get_u32(e->request, &seconds)) != 0)
				fatal("%s: buffer error: %s",
				    __func__, ssh_err(r));
			death = monotime() + seconds;
			break;
		case SSH_AGENT_CONSTRAIN_CONFIRM:
			confirm = 1;
			break;
		default:
			error("%s: Unknown constraint type %d", __func__, type);
			goto send;
		}
	}
	if (realpath(provider, canonical_provider) == NULL) {
		verbose("failed PKCS#11 add of \"%.100s\": realpath: %s",
		    provider, strerror(errno));
		goto send;
	}
	if (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {
		verbose("refusing PKCS#11 add of \"%.100s\": "
		    "provider not whitelisted", canonical_provider);
		goto send;
	}
	debug("%s: add %.100s", __func__, canonical_provider);
	if (lifetime && !death)
		death = monotime() + lifetime;

	count = pkcs11_add_provider(canonical_provider, pin, &keys);
	for (i = 0; i < count; i++) {
		k = keys[i];
		if (lookup_identity(k) == NULL) {
			id = xcalloc(1, sizeof(Identity));
			id->key = k;
			id->provider = xstrdup(canonical_provider);
			id->comment = xstrdup(canonical_provider); /* XXX */
			id->death = death;
			id->confirm = confirm;
			TAILQ_INSERT_TAIL(&idtab->idlist, id, next);
			idtab->nentries++;
			success = 1;
		} else {
			sshkey_free(k);
		}
		keys[i] = NULL;
	}
send:
	free(pin);
	free(provider);
	free(keys);
	send_status(e, success);
}

static void
process_remove_smartcard_key(SocketEntry *e)
{
	char *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];
	int r, success = 0;
	Identity *id, *nxt;

	if ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||
	    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	free(pin);

	if (realpath(provider, canonical_provider) == NULL) {
		verbose("failed PKCS#11 add of \"%.100s\": realpath: %s",
		    provider, strerror(errno));
		goto send;
	}

	debug("%s: remove %.100s", __func__, canonical_provider);
	for (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {
		nxt = TAILQ_NEXT(id, next);
		/* Skip file--based keys */
		if (id->provider == NULL)
			continue;
		if (!strcmp(canonical_provider, id->provider)) {
			TAILQ_REMOVE(&idtab->idlist, id, next);
			free_identity(id);
			idtab->nentries--;
		}
	}
	if (pkcs11_del_provider(canonical_provider) == 0)
		success = 1;
	else
		error("%s: pkcs11_del_provider failed", __func__);
send:
	free(provider);
	send_status(e, success);
}
#endif /* ENABLE_PKCS11 */

/* dispatch incoming messages */

static void
process_message(SocketEntry *e)
{
	u_int msg_len;
	u_char type;
	const u_char *cp;
	int r;

	if (sshbuf_len(e->input) < 5)
		return;		/* Incomplete message. */
	cp = sshbuf_ptr(e->input);
	msg_len = PEEK_U32(cp);
	if (msg_len > 256 * 1024) {
		close_socket(e);
		return;
	}
	if (sshbuf_len(e->input) < msg_len + 4)
		return;

	/* move the current input to e->request */
	sshbuf_reset(e->request);
	if ((r = sshbuf_get_stringb(e->input, e->request)) != 0 ||
	    (r = sshbuf_get_u8(e->request, &type)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	/* check wheter agent is locked */
	if (locked && type != SSH_AGENTC_UNLOCK) {
		sshbuf_reset(e->request);
		switch (type) {
		case SSH2_AGENTC_REQUEST_IDENTITIES:
			/* send empty lists */
			no_identities(e);
			break;
		default:
			/* send a fail message for all other request types */
			send_status(e, 0);
		}
		return;
	}

	debug("type %d", type);
	switch (type) {
	case SSH_AGENTC_LOCK:
	case SSH_AGENTC_UNLOCK:
		process_lock_agent(e, type == SSH_AGENTC_LOCK);
		break;
	case SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES:
		process_remove_all_identities(e); /* safe for !WITH_SSH1 */
		break;
	/* ssh2 */
	case SSH2_AGENTC_SIGN_REQUEST:
		process_sign_request2(e);
		break;
	case SSH2_AGENTC_REQUEST_IDENTITIES:
		process_request_identities(e);
		break;
	case SSH2_AGENTC_ADD_IDENTITY:
	case SSH2_AGENTC_ADD_ID_CONSTRAINED:
		process_add_identity(e);
		break;
	case SSH2_AGENTC_REMOVE_IDENTITY:
		process_remove_identity(e);
		break;
	case SSH2_AGENTC_REMOVE_ALL_IDENTITIES:
		process_remove_all_identities(e);
		break;
#ifdef ENABLE_PKCS11
	case SSH_AGENTC_ADD_SMARTCARD_KEY:
	case SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:
		process_add_smartcard_key(e);
		break;
	case SSH_AGENTC_REMOVE_SMARTCARD_KEY:
		process_remove_smartcard_key(e);
		break;
#endif /* ENABLE_PKCS11 */
	default:
		/* Unknown message.  Respond with failure. */
		error("Unknown message %d", type);
		sshbuf_reset(e->request);
		send_status(e, 0);
		break;
	}
}

static void
new_socket(sock_type type, int fd)
{
	u_int i, old_alloc, new_alloc;

	set_nonblock(fd);

	if (fd > max_fd)
		max_fd = fd;

	for (i = 0; i < sockets_alloc; i++)
		if (sockets[i].type == AUTH_UNUSED) {
			sockets[i].fd = fd;
			if ((sockets[i].input = sshbuf_new()) == NULL)
				fatal("%s: sshbuf_new failed", __func__);
			if ((sockets[i].output = sshbuf_new()) == NULL)
				fatal("%s: sshbuf_new failed", __func__);
			if ((sockets[i].request = sshbuf_new()) == NULL)
				fatal("%s: sshbuf_new failed", __func__);
			sockets[i].type = type;
			return;
		}
	old_alloc = sockets_alloc;
	new_alloc = sockets_alloc + 10;
	sockets = xreallocarray(sockets, new_alloc, sizeof(sockets[0]));
	for (i = old_alloc; i < new_alloc; i++)
		sockets[i].type = AUTH_UNUSED;
	sockets_alloc = new_alloc;
	sockets[old_alloc].fd = fd;
	if ((sockets[old_alloc].input = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((sockets[old_alloc].output = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((sockets[old_alloc].request = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	sockets[old_alloc].type = type;
}

static int
prepare_select(fd_set **fdrp, fd_set **fdwp, int *fdl, u_int *nallocp,
    struct timeval **tvpp)
{
	u_int i, sz;
	int n = 0;
	static struct timeval tv;
	time_t deadline;

	for (i = 0; i < sockets_alloc; i++) {
		switch (sockets[i].type) {
		case AUTH_SOCKET:
		case AUTH_CONNECTION:
			n = MAXIMUM(n, sockets[i].fd);
			break;
		case AUTH_UNUSED:
			break;
		default:
			fatal("Unknown socket type %d", sockets[i].type);
			break;
		}
	}

	sz = howmany(n+1, NFDBITS) * sizeof(fd_mask);
	if (*fdrp == NULL || sz > *nallocp) {
		free(*fdrp);
		free(*fdwp);
		*fdrp = xmalloc(sz);
		*fdwp = xmalloc(sz);
		*nallocp = sz;
	}
	if (n < *fdl)
		debug("XXX shrink: %d < %d", n, *fdl);
	*fdl = n;
	memset(*fdrp, 0, sz);
	memset(*fdwp, 0, sz);

	for (i = 0; i < sockets_alloc; i++) {
		switch (sockets[i].type) {
		case AUTH_SOCKET:
		case AUTH_CONNECTION:
			FD_SET(sockets[i].fd, *fdrp);
			if (sshbuf_len(sockets[i].output) > 0)
				FD_SET(sockets[i].fd, *fdwp);
			break;
		default:
			break;
		}
	}
	deadline = reaper();
	if (parent_alive_interval != 0)
		deadline = (deadline == 0) ? parent_alive_interval :
		    MINIMUM(deadline, parent_alive_interval);
	if (deadline == 0) {
		*tvpp = NULL;
	} else {
		tv.tv_sec = deadline;
		tv.tv_usec = 0;
		*tvpp = &tv;
	}
	return (1);
}

static void
after_select(fd_set *readset, fd_set *writeset)
{
	struct sockaddr_un sunaddr;
	socklen_t slen;
	char buf[1024];
	int len, sock, r;
	u_int i, orig_alloc;
	uid_t euid;
	gid_t egid;

	for (i = 0, orig_alloc = sockets_alloc; i < orig_alloc; i++)
		switch (sockets[i].type) {
		case AUTH_UNUSED:
			break;
		case AUTH_SOCKET:
			if (FD_ISSET(sockets[i].fd, readset)) {
				slen = sizeof(sunaddr);
				sock = accept(sockets[i].fd,
				    (struct sockaddr *)&sunaddr, &slen);
				if (sock < 0) {
					error("accept from AUTH_SOCKET: %s",
					    strerror(errno));
					break;
				}
				if (getpeereid(sock, &euid, &egid) < 0) {
					error("getpeereid %d failed: %s",
					    sock, strerror(errno));
					close(sock);
					break;
				}
				if ((euid != 0) && (getuid() != euid)) {
					error("uid mismatch: "
					    "peer euid %u != uid %u",
					    (u_int) euid, (u_int) getuid());
					close(sock);
					break;
				}
				new_socket(AUTH_CONNECTION, sock);
			}
			break;
		case AUTH_CONNECTION:
			if (sshbuf_len(sockets[i].output) > 0 &&
			    FD_ISSET(sockets[i].fd, writeset)) {
				len = write(sockets[i].fd,
				    sshbuf_ptr(sockets[i].output),
				    sshbuf_len(sockets[i].output));
				if (len == -1 && (errno == EAGAIN ||
				    errno == EINTR))
					continue;
				if (len <= 0) {
					close_socket(&sockets[i]);
					break;
				}
				if ((r = sshbuf_consume(sockets[i].output,
				    len)) != 0)
					fatal("%s: buffer error: %s",
					    __func__, ssh_err(r));
			}
			if (FD_ISSET(sockets[i].fd, readset)) {
				len = read(sockets[i].fd, buf, sizeof(buf));
				if (len == -1 && (errno == EAGAIN ||
				    errno == EINTR))
					continue;
				if (len <= 0) {
					close_socket(&sockets[i]);
					break;
				}
				if ((r = sshbuf_put(sockets[i].input,
				    buf, len)) != 0)
					fatal("%s: buffer error: %s",
					    __func__, ssh_err(r));
				explicit_bzero(buf, sizeof(buf));
				process_message(&sockets[i]);
			}
			break;
		default:
			fatal("Unknown type %d", sockets[i].type);
		}
}

static void
cleanup_socket(void)
{
	if (cleanup_pid != 0 && getpid() != cleanup_pid)
		return;
	debug("%s: cleanup", __func__);
	if (socket_name[0])
		unlink(socket_name);
	if (socket_dir[0])
		rmdir(socket_dir);
}

void
cleanup_exit(int i)
{
	cleanup_socket();
	_exit(i);
}

/*ARGSUSED*/
static void
cleanup_handler(int sig)
{
	cleanup_socket();
#ifdef ENABLE_PKCS11
	pkcs11_terminate();
#endif
	_exit(2);
}

static void
check_parent_exists(void)
{
	/*
	 * If our parent has exited then getppid() will return (pid_t)1,
	 * so testing for that should be safe.
	 */
	if (parent_pid != -1 && getppid() != parent_pid) {
		/* printf("Parent has died - Authentication agent exiting.\n"); */
		cleanup_socket();
		_exit(2);
	}
}

static void
usage(void)
{
	fprintf(stderr,
	    "usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\n"
	    "                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\n"
	    "       ssh-agent [-c | -s] -k\n");
	exit(1);
}

int
main(int ac, char **av)
{
	int c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;
	int sock, fd, ch, result, saved_errno;
	u_int nalloc;
	char *shell, *format, *pidstr, *agentsocket = NULL;
	fd_set *readsetp = NULL, *writesetp = NULL;
	struct rlimit rlim;
	extern int optind;
	extern char *optarg;
	pid_t pid;
	char pidstrbuf[1 + 3 * sizeof pid];
	struct timeval *tvp = NULL;
	size_t len;
	mode_t prev_mask;

	ssh_malloc_init();	/* must be called before any mallocs */
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	/* drop */
	setegid(getgid());
	setgid(getgid());

#ifdef WITH_OPENSSL
	OpenSSL_add_all_algorithms();
#endif

	while ((ch = getopt(ac, av, "cDdksE:a:P:t:")) != -1) {
		switch (ch) {
		case 'E':
			fingerprint_hash = ssh_digest_alg_by_name(optarg);
			if (fingerprint_hash == -1)
				fatal("Invalid hash algorithm \"%s\"", optarg);
			break;
		case 'c':
			if (s_flag)
				usage();
			c_flag++;
			break;
		case 'k':
			k_flag++;
			break;
		case 'P':
			if (pkcs11_whitelist != NULL)
				fatal("-P option already specified");
			pkcs11_whitelist = xstrdup(optarg);
			break;
		case 's':
			if (c_flag)
				usage();
			s_flag++;
			break;
		case 'd':
			if (d_flag || D_flag)
				usage();
			d_flag++;
			break;
		case 'D':
			if (d_flag || D_flag)
				usage();
			D_flag++;
			break;
		case 'a':
			agentsocket = optarg;
			break;
		case 't':
			if ((lifetime = convtime(optarg)) == -1) {
				fprintf(stderr, "Invalid lifetime\n");
				usage();
			}
			break;
		default:
			usage();
		}
	}
	ac -= optind;
	av += optind;

	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))
		usage();

	if (pkcs11_whitelist == NULL)
		pkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);

	if (ac == 0 && !c_flag && !s_flag) {
		shell = getenv("SHELL");
		if (shell != NULL && (len = strlen(shell)) > 2 &&
		    strncmp(shell + len - 3, "csh", 3) == 0)
			c_flag = 1;
	}
	if (k_flag) {
		const char *errstr = NULL;

		pidstr = getenv(SSH_AGENTPID_ENV_NAME);
		if (pidstr == NULL) {
			fprintf(stderr, "%s not set, cannot kill agent\n",
			    SSH_AGENTPID_ENV_NAME);
			exit(1);
		}
		pid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);
		if (errstr) {
			fprintf(stderr,
			    "%s=\"%s\", which is not a good PID: %s\n",
			    SSH_AGENTPID_ENV_NAME, pidstr, errstr);
			exit(1);
		}
		if (kill(pid, SIGTERM) == -1) {
			perror("kill");
			exit(1);
		}
		format = c_flag ? "unsetenv %s;\n" : "unset %s;\n";
		printf(format, SSH_AUTHSOCKET_ENV_NAME);
		printf(format, SSH_AGENTPID_ENV_NAME);
		printf("echo Agent pid %ld killed;\n", (long)pid);
		exit(0);
	}
	parent_pid = getpid();

	if (agentsocket == NULL) {
		/* Create private directory for agent socket */
		mktemp_proto(socket_dir, sizeof(socket_dir));
		if (mkdtemp(socket_dir) == NULL) {
			perror("mkdtemp: private socket dir");
			exit(1);
		}
		snprintf(socket_name, sizeof socket_name, "%s/agent.%ld", socket_dir,
		    (long)parent_pid);
	} else {
		/* Try to use specified agent socket */
		socket_dir[0] = '\0';
		strlcpy(socket_name, agentsocket, sizeof socket_name);
	}

	/*
	 * Create socket early so it will exist before command gets run from
	 * the parent.
	 */
	prev_mask = umask(0177);
	sock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);
	if (sock < 0) {
		/* XXX - unix_listener() calls error() not perror() */
		*socket_name = '\0'; /* Don't unlink any existing file */
		cleanup_exit(1);
	}
	umask(prev_mask);

	/*
	 * Fork, and have the parent execute the command, if any, or present
	 * the socket data.  The child continues as the authentication agent.
	 */
	if (D_flag || d_flag) {
		log_init(__progname,
		    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,
		    SYSLOG_FACILITY_AUTH, 1);
		format = c_flag ? "setenv %s %s;\n" : "%s=%s; export %s;\n";
		printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
		    SSH_AUTHSOCKET_ENV_NAME);
		printf("echo Agent pid %ld;\n", (long)parent_pid);
		fflush(stdout);
		goto skip;
	}
	pid = fork();
	if (pid == -1) {
		perror("fork");
		cleanup_exit(1);
	}
	if (pid != 0) {		/* Parent - execute the given command. */
		close(sock);
		snprintf(pidstrbuf, sizeof pidstrbuf, "%ld", (long)pid);
		if (ac == 0) {
			format = c_flag ? "setenv %s %s;\n" : "%s=%s; export %s;\n";
			printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
			    SSH_AUTHSOCKET_ENV_NAME);
			printf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,
			    SSH_AGENTPID_ENV_NAME);
			printf("echo Agent pid %ld;\n", (long)pid);
			exit(0);
		}
		if (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||
		    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {
			perror("setenv");
			exit(1);
		}
		execvp(av[0], av);
		perror(av[0]);
		exit(1);
	}
	/* child */
	log_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);

	if (setsid() == -1) {
		error("setsid: %s", strerror(errno));
		cleanup_exit(1);
	}

	(void)chdir("/");
	if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
		/* XXX might close listen socket */
		(void)dup2(fd, STDIN_FILENO);
		(void)dup2(fd, STDOUT_FILENO);
		(void)dup2(fd, STDERR_FILENO);
		if (fd > 2)
			close(fd);
	}

	/* deny core dumps, since memory contains unencrypted private keys */
	rlim.rlim_cur = rlim.rlim_max = 0;
	if (setrlimit(RLIMIT_CORE, &rlim) < 0) {
		error("setrlimit RLIMIT_CORE: %s", strerror(errno));
		cleanup_exit(1);
	}

skip:

	cleanup_pid = getpid();

#ifdef ENABLE_PKCS11
	pkcs11_init(0);
#endif
	new_socket(AUTH_SOCKET, sock);
	if (ac > 0)
		parent_alive_interval = 10;
	idtab_init();
	signal(SIGPIPE, SIG_IGN);
	signal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);
	signal(SIGHUP, cleanup_handler);
	signal(SIGTERM, cleanup_handler);
	nalloc = 0;

	if (pledge("stdio rpath cpath unix id proc exec", NULL) == -1)
		fatal("%s: pledge: %s", __progname, strerror(errno));

	while (1) {
		prepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp);
		result = select(max_fd + 1, readsetp, writesetp, NULL, tvp);
		saved_errno = errno;
		if (parent_alive_interval != 0)
			check_parent_exists();
		(void) reaper();	/* remove expired keys */
		if (result < 0) {
			if (saved_errno == EINTR)
				continue;
			fatal("select: %s", strerror(saved_errno));
		} else if (result > 0)
			after_select(readsetp, writesetp);
	}
	/* NOTREACHED */
}
@


1.221
log
@flense SSHv1 support from ssh-agent, considerably simplifying it

ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.220 2017/04/30 23:18:44 djm Exp $ */
a62 1
#include "rsa.h"
@


1.220
log
@remove KEY_RSA1

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.219 2017/04/30 23:10:43 djm Exp $ */
d108 1
a108 1
typedef struct {
d111 1
a111 1
} Idtab;
d113 2
a114 2
/* private key table, one per protocol version */
Idtab idtable[3];
d161 3
a163 15
	int i;

	for (i = 0; i <=2; i++) {
		TAILQ_INIT(&idtable[i].idlist);
		idtable[i].nentries = 0;
	}
}

/* return private key table for requested protocol version */
static Idtab *
idtab_lookup(int version)
{
	if (version < 1 || version > 2)
		fatal("internal error, bad protocol version %d", version);
	return &idtable[version];
d177 1
a177 1
lookup_identity(struct sshkey *key, int version)
d181 1
a181 2
	Idtab *tab = idtab_lookup(version);
	TAILQ_FOREACH(id, &tab->idlist, next) {
d218 1
a218 1
process_request_identities(SocketEntry *e, int version)
a219 1
	Idtab *tab = idtab_lookup(version);
a222 2
	u_char *blob;
	size_t blen;
d226 7
a232 8
	if ((r = sshbuf_put_u8(msg, (version == 1) ?
	    SSH_AGENT_RSA_IDENTITIES_ANSWER :
	    SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||
	    (r = sshbuf_put_u32(msg, tab->nentries)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	TAILQ_FOREACH(id, &tab->idlist, next) {
		if ((r = sshkey_to_blob(id->key, &blob, &blen)) != 0) {
			error("%s: sshkey_to_blob: %s", __func__,
a235 6
		if ((r = sshbuf_put_string(msg, blob, blen)) != 0)
			fatal("%s: buffer error: %s",
			    __func__, ssh_err(r));
		free(blob);
		if ((r = sshbuf_put_cstring(msg, id->comment)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
d259 3
a261 2
	u_char *blob, *data, *signature = NULL;
	size_t blen, dlen, slen = 0;
d265 1
a265 1
	struct sshkey *key;
d270 2
a271 2
	if ((r = sshbuf_get_string(e->request, &blob, &blen)) != 0 ||
	    (r = sshbuf_get_string(e->request, &data, &dlen)) != 0 ||
d276 1
a276 5
	if ((r = sshkey_from_blob(blob, blen, &key)) != 0) {
		error("%s: cannot parse key blob: %s", __func__, ssh_err(r));
		goto send;
	}
	if ((id = lookup_identity(key, 2)) == NULL) {
a303 2
	free(data);
	free(blob);
d309 1
a309 1
process_remove_identity(SocketEntry *e, int version)
a310 1
	size_t blen;
d313 1
a313 1
	u_char *blob;
d315 18
a332 32
	switch (version) {
	case 2:
		if ((r = sshbuf_get_string(e->request, &blob, &blen)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		if ((r = sshkey_from_blob(blob, blen, &key)) != 0)
			error("%s: sshkey_from_blob failed: %s",
			    __func__, ssh_err(r));
		free(blob);
		break;
	}
	if (key != NULL) {
		Identity *id = lookup_identity(key, version);
		if (id != NULL) {
			/*
			 * We have this key.  Free the old key.  Since we
			 * don't want to leave empty slots in the middle of
			 * the array, we actually free the key there and move
			 * all the entries between the empty slot and the end
			 * of the array.
			 */
			Idtab *tab = idtab_lookup(version);
			if (tab->nentries < 1)
				fatal("process_remove_identity: "
				    "internal error: tab->nentries %d",
				    tab->nentries);
			TAILQ_REMOVE(&tab->idlist, id, next);
			free_identity(id);
			tab->nentries--;
			success = 1;
		}
		sshkey_free(key);
	}
d337 1
a337 1
process_remove_all_identities(SocketEntry *e, int version)
a338 1
	Idtab *tab = idtab_lookup(version);
d342 3
a344 3
	for (id = TAILQ_FIRST(&tab->idlist); id;
	    id = TAILQ_FIRST(&tab->idlist)) {
		TAILQ_REMOVE(&tab->idlist, id, next);
d349 1
a349 1
	tab->nentries = 0;
a360 2
	int version;
	Idtab *tab;
d362 12
a373 15
	for (version = 1; version < 3; version++) {
		tab = idtab_lookup(version);
		for (id = TAILQ_FIRST(&tab->idlist); id; id = nxt) {
			nxt = TAILQ_NEXT(id, next);
			if (id->death == 0)
				continue;
			if (now >= id->death) {
				debug("expiring key '%s'", id->comment);
				TAILQ_REMOVE(&tab->idlist, id, next);
				free_identity(id);
				tab->nentries--;
			} else
				deadline = (deadline == 0) ? id->death :
				    MINIMUM(deadline, id->death);
		}
a380 5
/*
 * XXX this and the corresponding serialisation function probably belongs
 * in key.c
 */

d382 1
a382 1
process_add_identity(SocketEntry *e, int version)
a383 1
	Idtab *tab = idtab_lookup(version);
d393 2
a394 6
	switch (version) {
	case 2:
		r = sshkey_private_deserialize(e->request, &k);
		break;
	}
	if (r != 0 || k == NULL ||
d430 1
a430 1
	if ((id = lookup_identity(k, version)) == NULL) {
d433 1
a433 1
		TAILQ_INSERT_TAIL(&tab->idlist, id, next);
d435 1
a435 1
		tab->nentries++;
d496 1
a496 1
no_identities(SocketEntry *e, u_int type)
d503 1
a503 4
	if ((r = sshbuf_put_u8(msg,
	    (type == SSH_AGENTC_REQUEST_RSA_IDENTITIES) ?
	    SSH_AGENT_RSA_IDENTITIES_ANSWER :
	    SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||
d515 1
a515 1
	int r, i, version, count = 0, success = 0, confirm = 0;
a520 1
	Idtab *tab;
d540 1
a540 2
			error("process_add_smartcard_key: "
			    "Unknown constraint type %d", type);
d561 1
a561 3
		version = 2;
		tab = idtab_lookup(version);
		if (lookup_identity(k, version) == NULL) {
d568 2
a569 2
			TAILQ_INSERT_TAIL(&tab->idlist, id, next);
			tab->nentries++;
d587 1
a587 1
	int r, version, success = 0;
a588 1
	Idtab *tab;
d602 9
a610 12
	for (version = 1; version < 3; version++) {
		tab = idtab_lookup(version);
		for (id = TAILQ_FIRST(&tab->idlist); id; id = nxt) {
			nxt = TAILQ_NEXT(id, next);
			/* Skip file--based keys */
			if (id->provider == NULL)
				continue;
			if (!strcmp(canonical_provider, id->provider)) {
				TAILQ_REMOVE(&tab->idlist, id, next);
				free_identity(id);
				tab->nentries--;
			}
d616 1
a616 2
		error("process_remove_smartcard_key:"
		    " pkcs11_del_provider failed");
a653 1
		case SSH_AGENTC_REQUEST_RSA_IDENTITIES:
d656 1
a656 1
			no_identities(e, type);
d672 1
a672 1
		process_remove_all_identities(e, 1); /* safe for !WITH_SSH1 */
d679 1
a679 1
		process_request_identities(e, 2);
d683 1
a683 1
		process_add_identity(e, 2);
d686 1
a686 1
		process_remove_identity(e, 2);
d689 1
a689 1
		process_remove_all_identities(e, 2);
@


1.219
log
@unifdef WITH_SSH1
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.218 2017/03/15 03:52:30 deraadt Exp $ */
d237 2
d248 4
a251 14
		if (id->key->type == KEY_RSA1) {
		} else {
			u_char *blob;
			size_t blen;

			if ((r = sshkey_to_blob(id->key, &blob, &blen)) != 0) {
				error("%s: sshkey_to_blob: %s", __func__,
				    ssh_err(r));
				continue;
			}
			if ((r = sshbuf_put_string(msg, blob, blen)) != 0)
				fatal("%s: buffer error: %s",
				    __func__, ssh_err(r));
			free(blob);
d253 4
d625 1
a625 1
		version = k->type == KEY_RSA1 ? 1 : 2;
@


1.218
log
@accidents happen to the best of us; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.217 2017/03/15 02:25:09 djm Exp $ */
a246 10
#ifdef WITH_SSH1
			if ((r = sshbuf_put_u32(msg,
			    BN_num_bits(id->key->rsa->n))) != 0 ||
			    (r = sshbuf_put_bignum1(msg,
			    id->key->rsa->e)) != 0 ||
			    (r = sshbuf_put_bignum1(msg,
			    id->key->rsa->n)) != 0)
				fatal("%s: buffer error: %s",
				    __func__, ssh_err(r));
#endif
a268 81
#ifdef WITH_SSH1
/* ssh1 only */
static void
process_authentication_challenge1(SocketEntry *e)
{
	u_char buf[32], mdbuf[16], session_id[16];
	u_int response_type;
	BIGNUM *challenge;
	Identity *id;
	int r, len;
	struct sshbuf *msg;
	struct ssh_digest_ctx *md;
	struct sshkey *key;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((key = sshkey_new(KEY_RSA1)) == NULL)
		fatal("%s: sshkey_new failed", __func__);
	if ((challenge = BN_new()) == NULL)
		fatal("%s: BN_new failed", __func__);

	if ((r = sshbuf_get_u32(e->request, NULL)) != 0 || /* ignored */
	    (r = sshbuf_get_bignum1(e->request, key->rsa->e)) != 0 ||
	    (r = sshbuf_get_bignum1(e->request, key->rsa->n)) != 0 ||
	    (r = sshbuf_get_bignum1(e->request, challenge)))
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	/* Only protocol 1.1 is supported */
	if (sshbuf_len(e->request) == 0)
		goto failure;
	if ((r = sshbuf_get(e->request, session_id, sizeof(session_id))) != 0 ||
	    (r = sshbuf_get_u32(e->request, &response_type)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (response_type != 1)
		goto failure;

	id = lookup_identity(key, 1);
	if (id != NULL && (!id->confirm || confirm_key(id) == 0)) {
		struct sshkey *private = id->key;
		/* Decrypt the challenge using the private key. */
		if ((r = rsa_private_decrypt(challenge, challenge,
		    private->rsa) != 0)) {
			fatal("%s: rsa_public_encrypt: %s", __func__,
			    ssh_err(r));
			goto failure;	/* XXX ? */
		}

		/* The response is MD5 of decrypted challenge plus session id */
		len = BN_num_bytes(challenge);
		if (len <= 0 || len > 32) {
			logit("%s: bad challenge length %d", __func__, len);
			goto failure;
		}
		memset(buf, 0, 32);
		BN_bn2bin(challenge, buf + 32 - len);
		if ((md = ssh_digest_start(SSH_DIGEST_MD5)) == NULL ||
		    ssh_digest_update(md, buf, 32) < 0 ||
		    ssh_digest_update(md, session_id, 16) < 0 ||
		    ssh_digest_final(md, mdbuf, sizeof(mdbuf)) < 0)
			fatal("%s: md5 failed", __func__);
		ssh_digest_free(md);

		/* Send the response. */
		if ((r = sshbuf_put_u8(msg, SSH_AGENT_RSA_RESPONSE)) != 0 ||
		    (r = sshbuf_put(msg, mdbuf, sizeof(mdbuf))) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		goto send;
	}

 failure:
	/* Unknown identity or protocol error.  Send failure. */
	if ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
 send:
	if ((r = sshbuf_put_stringb(e->output, msg)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	sshkey_free(key);
	BN_clear_free(challenge);
	sshbuf_free(msg);
}
#endif
a346 3
#ifdef WITH_SSH1
	u_int bits;
#endif /* WITH_SSH1 */
a348 17
#ifdef WITH_SSH1
	case 1:
		if ((key = sshkey_new(KEY_RSA1)) == NULL) {
			error("%s: sshkey_new failed", __func__);
			return;
		}
		if ((r = sshbuf_get_u32(e->request, &bits)) != 0 ||
		    (r = sshbuf_get_bignum1(e->request, key->rsa->e)) != 0 ||
		    (r = sshbuf_get_bignum1(e->request, key->rsa->n)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));

		if (bits != sshkey_size(key))
			logit("Warning: identity keysize mismatch: "
			    "actual %u, announced %u",
			    sshkey_size(key), bits);
		break;
#endif /* WITH_SSH1 */
a437 39
#ifdef WITH_SSH1
static int
agent_decode_rsa1(struct sshbuf *m, struct sshkey **kp)
{
	struct sshkey *k = NULL;
	int r = SSH_ERR_INTERNAL_ERROR;

	*kp = NULL;
	if ((k = sshkey_new_private(KEY_RSA1)) == NULL)
		return SSH_ERR_ALLOC_FAIL;

	if ((r = sshbuf_get_u32(m, NULL)) != 0 ||		/* ignored */
	    (r = sshbuf_get_bignum1(m, k->rsa->n)) != 0 ||
	    (r = sshbuf_get_bignum1(m, k->rsa->e)) != 0 ||
	    (r = sshbuf_get_bignum1(m, k->rsa->d)) != 0 ||
	    (r = sshbuf_get_bignum1(m, k->rsa->iqmp)) != 0 ||
	    /* SSH1 and SSL have p and q swapped */
	    (r = sshbuf_get_bignum1(m, k->rsa->q)) != 0 ||	/* p */
	    (r = sshbuf_get_bignum1(m, k->rsa->p)) != 0) 	/* q */
		goto out;

	/* Generate additional parameters */
	if ((r = rsa_generate_additional_parameters(k->rsa)) != 0)
		goto out;
	/* enable blinding */
	if (RSA_blinding_on(k->rsa, NULL) != 1) {
		r = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}

	r = 0; /* success */
 out:
	if (r == 0)
		*kp = k;
	else
		sshkey_free(k);
	return r;
}
#endif /* WITH_SSH1 */
a452 5
#ifdef WITH_SSH1
	case 1:
		r = agent_decode_rsa1(e->request, &k);
		break;
#endif /* WITH_SSH1 */
a746 16
#ifdef WITH_SSH1
	/* ssh1 */
	case SSH_AGENTC_RSA_CHALLENGE:
		process_authentication_challenge1(e);
		break;
	case SSH_AGENTC_REQUEST_RSA_IDENTITIES:
		process_request_identities(e, 1);
		break;
	case SSH_AGENTC_ADD_RSA_IDENTITY:
	case SSH_AGENTC_ADD_RSA_ID_CONSTRAINED:
		process_add_identity(e, 1);
		break;
	case SSH_AGENTC_REMOVE_RSA_IDENTITY:
		process_remove_identity(e, 1);
		break;
#endif
@


1.217
log
@fix regression in 7.4: deletion of PKCS#11-hosted keys would fail
unless they were specified by full physical pathname.
Report and fix from Jakub Jelen via bz#2682; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.216 2017/01/04 02:21:43 djm Exp $ */
d847 1
@


1.216
log
@relax PKCS#11 whitelist a bit to allow libexec as well as lib
directories.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.215 2016/11/30 03:07:37 djm Exp $ */
d811 1
a811 1
	char *provider = NULL, *pin = NULL;
d821 7
d835 1
a835 1
			if (!strcmp(provider, id->provider)) {
d842 1
a842 1
	if (pkcs11_del_provider(provider) == 0)
@


1.215
log
@add a whitelist of paths from which ssh-agent will load (via
ssh-pkcs11-helper) a PKCS#11 module; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.214 2016/09/12 01:22:38 deraadt Exp $ */
d79 1
a79 1
# define DEFAULT_PKCS11_WHITELIST "/usr/lib/*,/usr/local/lib/*"
@


1.214
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.213 2016/05/02 08:49:03 djm Exp $ */
d72 1
d78 4
d129 3
d735 1
a735 1
	char *provider = NULL, *pin;
d767 11
d781 1
a781 1
	count = pkcs11_add_provider(provider, pin, &keys);
d789 2
a790 2
			id->provider = xstrdup(provider);
			id->comment = xstrdup(provider); /* XXX */
d1179 1
a1179 1
	    "                 [-t life] [command [arg ...]]\n"
d1213 1
a1213 1
	while ((ch = getopt(ac, av, "cDdksE:a:t:")) != -1) {
d1228 5
d1267 3
d1415 1
a1415 1
	if (pledge("stdio cpath unix id proc exec", NULL) == -1)
@


1.213
log
@fix signed/unsigned errors reported by clang-3.7; add
sshbuf_dup_string() to replace a common idiom of
strdup(sshbuf_ptr()) with better safety checking;
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.212 2016/02/15 09:47:49 dtucker Exp $ */
a36 1
#include <sys/param.h>	/* MIN MAX */
d528 1
a528 1
				    MIN(deadline, id->death);
d980 1
a980 1
			n = MAX(n, sockets[i].fd);
d1019 1
a1019 1
		    MIN(deadline, parent_alive_interval);
@


1.212
log
@Add a function to enable security-related malloc_options.  With and ok
deraadt@@, something similar has been in the snaps for a while.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.211 2015/12/11 17:41:37 doug Exp $ */
d130 2
a131 2
char lock_passwd[LOCK_SIZE];
char lock_salt[LOCK_SALT_SIZE];
d663 2
a664 1
	char *passwd, passwdhash[LOCK_SIZE];
d676 1
a676 1
		if (timingsafe_bcmp(passwdhash, lock_passwd, LOCK_SIZE) == 0) {
d680 1
a680 1
			explicit_bzero(lock_passwd, sizeof(lock_passwd));
d697 1
a697 1
		    lock_passwd, sizeof(lock_passwd), LOCK_ROUNDS) < 0)
@


1.211
log
@Add "id" to ssh-agent pledge for subprocess support.

Found the hard way by Jan Johansson when using ssh-agent with X.  Also,
rearranged proc/exec and retval to match other pledge calls in the tree.

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.210 2015/12/11 02:29:03 dtucker Exp $ */
d1182 1
@


1.210
log
@fflush stdout so that output is seen even when running in debug mode when
output may otherwise not be flushed.  Patch from dustin at null-ptr.net.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.209 2015/12/11 02:20:28 djm Exp $ */
d1387 1
a1387 1
	if (pledge("stdio cpath unix exec proc", NULL) != 0)
@


1.209
log
@correct error messages; from Tomas Kuthan bz#2507
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.208 2015/12/04 16:41:28 markus Exp $ */
d1316 1
@


1.208
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.207 2015/12/02 08:30:50 doug Exp $ */
d387 1
a387 1
		error("%s: cannot parse key blob: %s", __func__, ssh_err(ok));
d400 1
a400 1
		error("%s: sshkey_sign: %s", __func__, ssh_err(ok));
@


1.207
log
@Add "cpath" to the ssh-agent pledge so the cleanup handler can unlink().

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.206 2015/12/02 08:00:58 djm Exp $ */
d354 12
d399 1
a399 1
	    data, dlen, compat)) != 0) {
@


1.206
log
@ssh-agent pledge needs proc for askpass; spotted by todd@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.205 2015/12/01 23:29:24 djm Exp $ */
d1374 1
a1374 1
	if (pledge("stdio unix exec proc", NULL) != 0)
@


1.205
log
@basic pledge() for ssh-agent, more refinement needed
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.204 2015/07/08 20:24:02 markus Exp $ */
d1374 1
a1374 1
	if (pledge("stdio unix exec", NULL) != 0)
@


1.204
log
@no need to include the old buffer/key API
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.203 2015/05/15 05:44:21 dtucker Exp $ */
d1373 3
@


1.203
log
@Use a salted hash of the lock passphrase instead of plain text and do
constant-time comparisons of it. Should prevent leaking any information about
it via timing, pointed out by Ryan Castellucci.  Add a 0.1s incrementing delay
for each failed unlock attempt up to 10s.  ok markus@@ (earlier version), djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.202 2015/04/24 06:26:49 jmc Exp $ */
a60 3

#include "key.h"	/* XXX for typedef */
#include "buffer.h"	/* XXX for typedef */
@


1.202
log
@combine -Dd onto one line and update usage();
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.201 2015/04/24 05:26:44 djm Exp $ */
d60 1
d129 3
d133 2
a134 1
char *lock_passwd = NULL;
d653 29
a681 11
	int r, success = 0;
	char *passwd;

	if ((r = sshbuf_get_cstring(e->request, &passwd, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (locked && !lock && strcmp(passwd, lock_passwd) == 0) {
		locked = 0;
		explicit_bzero(lock_passwd, strlen(lock_passwd));
		free(lock_passwd);
		lock_passwd = NULL;
		success = 1;
d683 1
d685 4
a688 1
		lock_passwd = xstrdup(passwd);
d691 1
a691 1
	explicit_bzero(passwd, strlen(passwd));
@


1.201
log
@add ssh-agent -D to leave ssh-agent in foreground without enabling
debug mode; bz#2381 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.200 2015/04/24 01:36:01 deraadt Exp $ */
d1123 1
a1123 1
	    "usage: ssh-agent [-c | -s] [-d] [-a bind_address] [-E fingerprint_hash]\n"
@


1.200
log
@rename xrealloc() to xreallocarray() since it follows that form.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.199 2015/03/04 21:12:59 djm Exp $ */
d1132 1
a1132 1
	int c_flag = 0, d_flag = 0, k_flag = 0, s_flag = 0;
d1157 1
a1157 1
	while ((ch = getopt(ac, av, "cdksE:a:t:")) != -1) {
d1178 1
a1178 1
			if (d_flag)
d1182 5
d1203 1
a1203 1
	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag))
d1272 4
a1275 2
	if (d_flag) {
		log_init(__progname, SYSLOG_LEVEL_DEBUG1, SYSLOG_FACILITY_AUTH, 1);
d1345 1
a1345 1
	signal(SIGINT, d_flag ? cleanup_handler : SIG_IGN);
@


1.199
log
@make ssh-add -D work with !SSH1 agent
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.198 2015/03/03 21:21:13 djm Exp $ */
d917 1
a917 1
	sockets = xrealloc(sockets, new_alloc, sizeof(sockets[0]));
@


1.198
log
@add SSH1 Makefile knob to make it easier to build without SSH1 support;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.197 2015/01/28 22:36:00 djm Exp $ */
d854 1
d856 1
a856 1
		process_remove_all_identities(e, 1);
a857 1
#endif
@


1.197
log
@update to new API (key_fingerprint => sshkey_fingerprint)
check sshkey_fingerprint return values;
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.196 2015/01/16 06:40:12 deraadt Exp $ */
d528 1
d566 1
@


1.196
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.195 2015/01/14 19:33:41 djm Exp $ */
d200 2
a201 1
	if (ask_permission("Allow use of key %s?\nKey fingerprint %s.",
@


1.195
log
@fix small regression: ssh-agent would return a success message
but an empty signature if asked to sign using an unknown key;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.194 2015/01/14 13:09:09 markus Exp $ */
d37 1
a44 1
#include <sys/param.h>
d57 1
d124 2
a125 2
char socket_name[MAXPATHLEN];
char socket_dir[MAXPATHLEN];
@


1.194
log
@switch to sshbuf/sshkey; with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.193 2014/12/21 23:35:14 jmc Exp $ */
d360 1
d362 2
d370 1
a370 2

	if ((ok = sshkey_from_blob(blob, blen, &key)) != 0)
d372 14
a385 9
	else {
		Identity *id = lookup_identity(key, 2);
		if (id != NULL && (!id->confirm || confirm_key(id) == 0)) {
			if ((ok = sshkey_sign(id->key, &signature, &slen,
			    data, dlen, compat)) != 0)
				error("%s: sshkey_sign: %s",
				    __func__, ssh_err(ok));
		}
		sshkey_free(key);
d387 4
a390 2
	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
@


1.193
log
@tweak previous;
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.192 2014/12/21 22:27:56 djm Exp $ */
d60 3
d66 2
a67 2
#include "buffer.h"
#include "key.h"
d73 1
d88 3
a90 3
	Buffer input;
	Buffer output;
	Buffer request;
d98 1
a98 1
	Key *key;
d143 3
a145 3
	buffer_free(&e->input);
	buffer_free(&e->output);
	buffer_free(&e->request);
d171 1
a171 1
	key_free(id->key);
d179 1
a179 1
lookup_identity(Key *key, int version)
d185 1
a185 1
		if (key_equal(key, id->key))
d198 1
a198 1
	p = key_fingerprint(id->key, fingerprint_hash, SSH_FP_DEFAULT);
d207 11
d224 2
a225 1
	Buffer msg;
d227 7
a233 4
	buffer_init(&msg);
	buffer_put_char(&msg, (version == 1) ?
	    SSH_AGENT_RSA_IDENTITIES_ANSWER : SSH2_AGENT_IDENTITIES_ANSWER);
	buffer_put_int(&msg, tab->nentries);
d237 8
a244 3
			buffer_put_int(&msg, BN_num_bits(id->key->rsa->n));
			buffer_put_bignum(&msg, id->key->rsa->e);
			buffer_put_bignum(&msg, id->key->rsa->n);
d248 10
a257 3
			u_int blen;
			key_to_blob(id->key, &blob, &blen);
			buffer_put_string(&msg, blob, blen);
d260 2
a261 1
		buffer_put_cstring(&msg, id->comment);
d263 3
a265 3
	buffer_put_int(&e->output, buffer_len(&msg));
	buffer_append(&e->output, buffer_ptr(&msg), buffer_len(&msg));
	buffer_free(&msg);
d277 2
a278 2
	int i, len;
	Buffer msg;
d280 1
a280 1
	Key *key;
d282 4
a285 2
	buffer_init(&msg);
	key = key_new(KEY_RSA1);
d287 1
a287 1
		fatal("process_authentication_challenge1: BN_new failed");
d289 5
a293 4
	(void) buffer_get_int(&e->request);			/* ignored */
	buffer_get_bignum(&e->request, key->rsa->e);
	buffer_get_bignum(&e->request, key->rsa->n);
	buffer_get_bignum(&e->request, challenge);
d296 1
a296 1
	if (buffer_len(&e->request) == 0)
d298 3
a300 2
	buffer_get(&e->request, session_id, 16);
	response_type = buffer_get_int(&e->request);
d306 1
a306 1
		Key *private = id->key;
d308 6
a313 2
		if (rsa_private_decrypt(challenge, challenge, private->rsa) != 0)
			goto failure;
d315 1
a315 1
		/* The response is MD5 of decrypted challenge plus session id. */
d318 1
a318 1
			logit("process_authentication_challenge: bad challenge length %d", len);
d331 3
a333 3
		buffer_put_char(&msg, SSH_AGENT_RSA_RESPONSE);
		for (i = 0; i < 16; i++)
			buffer_put_char(&msg, mdbuf[i]);
d337 1
a337 1
failure:
d339 6
a344 5
	buffer_put_char(&msg, SSH_AGENT_FAILURE);
send:
	buffer_put_int(&e->output, buffer_len(&msg));
	buffer_append(&e->output, buffer_ptr(&msg), buffer_len(&msg));
	key_free(key);
d346 1
a346 1
	buffer_free(&msg);
d355 10
a364 14
	u_int blen, dlen, slen = 0;
	extern int datafellows;
	int odatafellows;
	int ok = -1, flags;
	Buffer msg;
	Key *key;

	datafellows = 0;

	blob = buffer_get_string(&e->request, &blen);
	data = buffer_get_string(&e->request, &dlen);

	flags = buffer_get_int(&e->request);
	odatafellows = datafellows;
d366 1
a366 1
		datafellows = SSH_BUG_SIGBLOB;
d368 3
a370 2
	key = key_from_blob(blob, blen);
	if (key != NULL) {
d372 7
a378 3
		if (id != NULL && (!id->confirm || confirm_key(id) == 0))
			ok = key_sign(id->key, &signature, &slen, data, dlen);
		key_free(key);
d380 2
a381 1
	buffer_init(&msg);
d383 10
a392 9
		buffer_put_char(&msg, SSH2_AGENT_SIGN_RESPONSE);
		buffer_put_string(&msg, signature, slen);
	} else {
		buffer_put_char(&msg, SSH_AGENT_FAILURE);
	}
	buffer_put_int(&e->output, buffer_len(&msg));
	buffer_append(&e->output, buffer_ptr(&msg),
	    buffer_len(&msg));
	buffer_free(&msg);
a395 1
	datafellows = odatafellows;
d402 3
a404 3
	u_int blen;
	int success = 0;
	Key *key = NULL;
d413 13
a425 8
		key = key_new(KEY_RSA1);
		bits = buffer_get_int(&e->request);
		buffer_get_bignum(&e->request, key->rsa->e);
		buffer_get_bignum(&e->request, key->rsa->n);

		if (bits != key_size(key))
			logit("Warning: identity keysize mismatch: actual %u, announced %u",
			    key_size(key), bits);
d429 5
a433 2
		blob = buffer_get_string(&e->request, &blen);
		key = key_from_blob(blob, blen);
d457 1
a457 1
		key_free(key);
d459 1
a459 3
	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
d479 1
a479 2
	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output, SSH_AGENT_SUCCESS);
d513 42
d560 3
a562 2
	int type, success = 0, confirm = 0;
	char *comment;
d564 3
a566 1
	Key *k = NULL;
d571 1
a571 22
		k = key_new_private(KEY_RSA1);
		(void) buffer_get_int(&e->request);		/* ignored */
		buffer_get_bignum(&e->request, k->rsa->n);
		buffer_get_bignum(&e->request, k->rsa->e);
		buffer_get_bignum(&e->request, k->rsa->d);
		buffer_get_bignum(&e->request, k->rsa->iqmp);

		/* SSH and SSL have p and q swapped */
		buffer_get_bignum(&e->request, k->rsa->q);	/* p */
		buffer_get_bignum(&e->request, k->rsa->p);	/* q */

		/* Generate additional parameters */
		if (rsa_generate_additional_parameters(k->rsa) != 0)
			fatal("%s: rsa_generate_additional_parameters "
			    "error", __func__);

		/* enable blinding */
		if (RSA_blinding_on(k->rsa, NULL) != 1) {
			error("process_add_identity: RSA_blinding_on failed");
			key_free(k);
			goto send;
		}
d575 1
a575 5
		k = key_private_deserialize(&e->request);
		if (k == NULL) {
			buffer_clear(&e->request);
			goto send;
		}
d578 5
a582 3
	if (k == NULL)
		goto send;
	comment = buffer_get_string(&e->request, NULL);
d584 6
a589 2
	while (buffer_len(&e->request)) {
		switch ((type = buffer_get_char(&e->request))) {
d591 6
a596 1
			death = monotime() + buffer_get_int(&e->request);
d602 3
a604 2
			error("process_add_identity: "
			    "Unknown constraint type %d", type);
d606 1
a606 1
			key_free(k);
d610 1
d621 1
a621 1
		key_free(k);
d628 1
a628 3
	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
d635 1
a635 1
	int success = 0;
d638 2
a639 1
	passwd = buffer_get_string(&e->request, NULL);
d653 1
a653 4

	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
d659 2
a660 1
	Buffer msg;
d662 3
a664 2
	buffer_init(&msg);
	buffer_put_char(&msg,
d666 6
a671 5
	    SSH_AGENT_RSA_IDENTITIES_ANSWER : SSH2_AGENT_IDENTITIES_ANSWER);
	buffer_put_int(&msg, 0);
	buffer_put_int(&e->output, buffer_len(&msg));
	buffer_append(&e->output, buffer_ptr(&msg), buffer_len(&msg));
	buffer_free(&msg);
d679 2
a680 1
	int i, type, version, count = 0, success = 0, confirm = 0;
d682 2
a683 1
	Key **keys = NULL, *k;
d687 8
a694 5
	provider = buffer_get_string(&e->request, NULL);
	pin = buffer_get_string(&e->request, NULL);

	while (buffer_len(&e->request)) {
		switch ((type = buffer_get_char(&e->request))) {
d696 4
a699 1
			death = monotime() + buffer_get_int(&e->request);
d729 1
a729 1
			key_free(k);
d737 1
a737 3
	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
d744 1
a744 1
	int version, success = 0;
d748 3
a750 2
	provider = buffer_get_string(&e->request, NULL);
	pin = buffer_get_string(&e->request, NULL);
d773 1
a773 3
	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
d782 4
a785 2
	u_int msg_len, type;
	u_char *cp;
d787 1
a787 1
	if (buffer_len(&e->input) < 5)
d789 2
a790 2
	cp = buffer_ptr(&e->input);
	msg_len = get_u32(cp);
d795 1
a795 1
	if (buffer_len(&e->input) < msg_len + 4)
d799 4
a802 5
	buffer_consume(&e->input, 4);
	buffer_clear(&e->request);
	buffer_append(&e->request, buffer_ptr(&e->input), msg_len);
	buffer_consume(&e->input, msg_len);
	type = buffer_get_char(&e->request);
d806 1
a806 1
		buffer_clear(&e->request);
d815 1
a815 2
			buffer_put_int(&e->output, 1);
			buffer_put_char(&e->output, SSH_AGENT_FAILURE);
d874 2
a875 3
		buffer_clear(&e->request);
		buffer_put_int(&e->output, 1);
		buffer_put_char(&e->output, SSH_AGENT_FAILURE);
d893 6
a898 3
			buffer_init(&sockets[i].input);
			buffer_init(&sockets[i].output);
			buffer_init(&sockets[i].request);
d909 6
a914 3
	buffer_init(&sockets[old_alloc].input);
	buffer_init(&sockets[old_alloc].output);
	buffer_init(&sockets[old_alloc].request);
d960 1
a960 1
			if (buffer_len(&sockets[i].output) > 0)
d987 1
a987 1
	int len, sock;
d1023 1
a1023 1
			if (buffer_len(&sockets[i].output) > 0 &&
d1026 2
a1027 2
				    buffer_ptr(&sockets[i].output),
				    buffer_len(&sockets[i].output));
d1035 4
a1038 1
				buffer_consume(&sockets[i].output, len);
d1049 4
a1052 1
				buffer_append(&sockets[i].input, buf, len);
@


1.192
log
@Add FingerprintHash option to control algorithm used for key
fingerprints. Default changes from MD5 to SHA256 and format
from hex to base64.

Feedback and ok naddy@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.191 2014/11/18 20:54:28 krw Exp $ */
d1014 2
a1015 2
	    "usage: ssh-agent [-c | -s] [-d] [-a bind_address] [-t life]\n"
	    "                 [-E fingerprint_hash] [command [arg ...]]\n"
@


1.191
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.190 2014/07/25 21:22:03 dtucker Exp $ */
d131 2
d194 1
a194 1
	p = key_fingerprint(id->key, SSH_FP_MD5, SSH_FP_HEX);
d1015 1
a1015 1
	    "                 [command [arg ...]]\n"
d1048 1
a1048 1
	while ((ch = getopt(ac, av, "cdksa:t:")) != -1) {
d1050 5
@


1.190
log
@Clear buffer used for handling messages.  This prevents keys being
left in memory after they have been expired or deleted in some cases
(but note that ssh-agent is setgid so you would still need root to
access them).  Pointed out by Kevin Burns, ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.189 2014/07/18 02:46:01 djm Exp $ */
a40 1
#include <sys/types.h>
@


1.189
log
@restore umask around listener socket creation (dropped in streamlocal patch
merge)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.188 2014/07/15 15:54:14 millert Exp $ */
d956 1
@


1.188
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.187 2014/07/03 03:11:03 djm Exp $ */
d43 1
d1033 1
d1138 1
d1145 1
@


1.187
log
@Only cleanup agent socket in the main agent process and not in any
subprocesses it may have started (e.g. forked askpass). Fixes
agent sockets being zapped when askpass processes fatal();
bz#2236 patch from Dmitry V. Levin
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.186 2014/06/24 01:13:21 djm Exp $ */
a1024 1
	struct sockaddr_un sunaddr;
d1136 1
a1136 1
	sock = socket(AF_UNIX, SOCK_STREAM, 0);
d1138 1
a1138 9
		perror("socket");
		*socket_name = '\0'; /* Don't unlink any existing file */
		cleanup_exit(1);
	}
	memset(&sunaddr, 0, sizeof(sunaddr));
	sunaddr.sun_family = AF_UNIX;
	strlcpy(sunaddr.sun_path, socket_name, sizeof(sunaddr.sun_path));
	if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {
		perror("bind");
a1139 4
		cleanup_exit(1);
	}
	if (listen(sock, SSH_LISTEN_BACKLOG) < 0) {
		perror("listen");
@


1.186
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.185 2014/04/29 18:01:49 markus Exp $ */
d115 3
d966 3
d1220 2
@


1.185
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.184 2014/03/15 17:28:26 deraadt Exp $ */
d267 1
a267 1
		if (rsa_private_decrypt(challenge, challenge, private->rsa) <= 0)
d354 1
a354 1
	u_int blen, bits;
d358 3
d363 1
d374 1
d471 1
d485 3
a487 1
		rsa_generate_additional_parameters(k->rsa);
d496 1
d505 2
d508 1
a508 4
	if (k == NULL) {
		free(comment);
		goto send;
	}
@


1.184
log
@Improve usage() and documentation towards the standard form.  In particular,
this line saves a lot of man page reading time.
    usage: ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa | rsa1]
                      [-N new_passphrase] [-C comment] [-f output_keyfile]
ok schwarze jmc
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.183 2014/02/02 03:44:31 djm Exp $ */
d46 1
d48 1
d212 1
d216 1
d231 1
d302 1
d728 1
d746 1
d1027 1
d1029 1
@


1.183
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.182 2014/01/27 19:18:54 markus Exp $ */
d988 4
a991 9
	fprintf(stderr, "usage: %s [options] [command [arg ...]]\n",
	    __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -c          Generate C-shell commands on stdout.\n");
	fprintf(stderr, "  -s          Generate Bourne shell commands on stdout.\n");
	fprintf(stderr, "  -k          Kill the current agent.\n");
	fprintf(stderr, "  -d          Debug mode.\n");
	fprintf(stderr, "  -a socket   Bind agent socket to given name.\n");
	fprintf(stderr, "  -t life     Default identity lifetime (seconds).\n");
@


1.182
log
@replace openssl MD5 with our ssh_digest_*; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.181 2013/12/19 01:19:41 djm Exp $ */
d543 1
a543 1
		memset(lock_passwd, 0, strlen(lock_passwd));
d552 1
a552 1
	memset(passwd, 0, strlen(passwd));
@


1.181
log
@bz#2186: don't crash (NULL deref) when deleting PKCS#11 keys from an agent
that has a mix of normal and PKCS#11 keys; fix from jay AT slushpupie.com;
ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.180 2013/12/06 13:39:49 markus Exp $ */
a46 1
#include <openssl/md5.h>
d67 1
d237 1
a237 1
	MD5_CTX md;
d273 6
a278 4
		MD5_Init(&md);
		MD5_Update(&md, buf, 32);
		MD5_Update(&md, session_id, 16);
		MD5_Final(mdbuf, &md);
@


1.180
log
@support ed25519 keys (hostkeys and user identities) using the public domain
ed25519 reference code from SUPERCOP, see http://ed25519.cr.yp.to/software.html
feedback, help & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.179 2013/12/06 13:34:54 markus Exp $ */
d649 3
@


1.179
log
@new private key format, bcrypt as KDF by default; details in PROTOCOL.key;
feedback and lots help from djm; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.178 2013/12/06 13:30:08 markus Exp $ */
d473 1
@


1.178
log
@move private key (de)serialization to key.c; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.177 2013/07/20 01:50:20 djm Exp $ */
a472 1
		/* enable blinding */
@


1.177
log
@call cleanup_handler on SIGINT when in debug mode to ensure sockets
are cleaned up on manual exit; bz#2120
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.176 2013/06/02 13:35:58 dtucker Exp $ */
d453 1
a453 1
	char *type_name, *comment, *curve;
a455 4
	BIGNUM *exponent;
	EC_POINT *q;
	u_char *cert;
	u_int len;
d472 7
d481 2
a482 97
		type_name = buffer_get_string(&e->request, NULL);
		type = key_type_from_name(type_name);
		switch (type) {
		case KEY_DSA:
			k = key_new_private(type);
			buffer_get_bignum2(&e->request, k->dsa->p);
			buffer_get_bignum2(&e->request, k->dsa->q);
			buffer_get_bignum2(&e->request, k->dsa->g);
			buffer_get_bignum2(&e->request, k->dsa->pub_key);
			buffer_get_bignum2(&e->request, k->dsa->priv_key);
			break;
		case KEY_DSA_CERT_V00:
		case KEY_DSA_CERT:
			cert = buffer_get_string(&e->request, &len);
			if ((k = key_from_blob(cert, len)) == NULL)
				fatal("Certificate parse failed");
			free(cert);
			key_add_private(k);
			buffer_get_bignum2(&e->request, k->dsa->priv_key);
			break;
		case KEY_ECDSA:
			k = key_new_private(type);
			k->ecdsa_nid = key_ecdsa_nid_from_name(type_name);
			curve = buffer_get_string(&e->request, NULL);
			if (k->ecdsa_nid != key_curve_name_to_nid(curve))
				fatal("%s: curve names mismatch", __func__);
			free(curve);
			k->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);
			if (k->ecdsa == NULL)
				fatal("%s: EC_KEY_new_by_curve_name failed",
				    __func__);
			q = EC_POINT_new(EC_KEY_get0_group(k->ecdsa));
			if (q == NULL)
				fatal("%s: BN_new failed", __func__);
			if ((exponent = BN_new()) == NULL)
				fatal("%s: BN_new failed", __func__);
			buffer_get_ecpoint(&e->request,
				EC_KEY_get0_group(k->ecdsa), q);
			buffer_get_bignum2(&e->request, exponent);
			if (EC_KEY_set_public_key(k->ecdsa, q) != 1)
				fatal("%s: EC_KEY_set_public_key failed",
				    __func__);
			if (EC_KEY_set_private_key(k->ecdsa, exponent) != 1)
				fatal("%s: EC_KEY_set_private_key failed",
				    __func__);
			if (key_ec_validate_public(EC_KEY_get0_group(k->ecdsa),
			    EC_KEY_get0_public_key(k->ecdsa)) != 0)
				fatal("%s: bad ECDSA public key", __func__);
			if (key_ec_validate_private(k->ecdsa) != 0)
				fatal("%s: bad ECDSA private key", __func__);
			BN_clear_free(exponent);
			EC_POINT_free(q);
			break;
		case KEY_ECDSA_CERT:
			cert = buffer_get_string(&e->request, &len);
			if ((k = key_from_blob(cert, len)) == NULL)
				fatal("Certificate parse failed");
			free(cert);
			key_add_private(k);
			if ((exponent = BN_new()) == NULL)
				fatal("%s: BN_new failed", __func__);
			buffer_get_bignum2(&e->request, exponent);
			if (EC_KEY_set_private_key(k->ecdsa, exponent) != 1)
				fatal("%s: EC_KEY_set_private_key failed",
				    __func__);
			if (key_ec_validate_public(EC_KEY_get0_group(k->ecdsa),
			    EC_KEY_get0_public_key(k->ecdsa)) != 0 ||
			    key_ec_validate_private(k->ecdsa) != 0)
				fatal("%s: bad ECDSA key", __func__);
			BN_clear_free(exponent);
			break;
		case KEY_RSA:
			k = key_new_private(type);
			buffer_get_bignum2(&e->request, k->rsa->n);
			buffer_get_bignum2(&e->request, k->rsa->e);
			buffer_get_bignum2(&e->request, k->rsa->d);
			buffer_get_bignum2(&e->request, k->rsa->iqmp);
			buffer_get_bignum2(&e->request, k->rsa->p);
			buffer_get_bignum2(&e->request, k->rsa->q);

			/* Generate additional parameters */
			rsa_generate_additional_parameters(k->rsa);
			break;
		case KEY_RSA_CERT_V00:
		case KEY_RSA_CERT:
			cert = buffer_get_string(&e->request, &len);
			if ((k = key_from_blob(cert, len)) == NULL)
				fatal("Certificate parse failed");
			free(cert);
			key_add_private(k);
			buffer_get_bignum2(&e->request, k->rsa->d);
			buffer_get_bignum2(&e->request, k->rsa->iqmp);
			buffer_get_bignum2(&e->request, k->rsa->p);
			buffer_get_bignum2(&e->request, k->rsa->q);
			break;
		default:
			free(type_name);
a483 14
			goto send;
		}
		free(type_name);
		break;
	}
	/* enable blinding */
	switch (k->type) {
	case KEY_RSA:
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
	case KEY_RSA1:
		if (RSA_blinding_on(k->rsa, NULL) != 1) {
			error("process_add_identity: RSA_blinding_on failed");
			key_free(k);
@


1.176
log
@Make parent_alive_interval time_t to avoid signed/unsigned comparison
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.175 2013/06/01 13:15:52 dtucker Exp $ */
a1309 2
	if (!d_flag)
		signal(SIGINT, SIG_IGN);
d1311 1
@


1.175
log
@Use clock_gettime(CLOCK_MONOTONIC ...) for ssh timers so that things like
keepalives and rekeying will work properly over clock steps.  Suggested by
markus@@, "looks good" djm@@.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.174 2013/05/31 12:28:10 dtucker Exp $ */
d111 1
a111 1
u_int parent_alive_interval = 0;
@


1.174
log
@Use time_t where appropriate.  ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.173 2013/05/17 00:13:14 djm Exp $ */
d420 1
a420 1
	time_t deadline = 0, now = time(NULL);
d602 1
a602 1
			death = time(NULL) + buffer_get_int(&e->request);
d617 1
a617 1
		death = time(NULL) + lifetime;
d696 1
a696 1
			death = time(NULL) + buffer_get_int(&e->request);
d708 1
a708 1
		death = time(NULL) + lifetime;
@


1.173
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.172 2011/06/03 01:37:40 dtucker Exp $ */
d95 1
a95 1
	u_int death;
d123 2
a124 2
/* Default lifetime (0 == forever) */
static int lifetime = 0;
d417 1
a417 1
static u_int
d420 1
a420 1
	u_int deadline = 0, now = time(NULL);
d452 1
a452 1
	int type, success = 0, death = 0, confirm = 0;
d454 1
d684 2
a685 1
	int i, type, version, count = 0, success = 0, death = 0, confirm = 0;
d912 1
a912 1
	u_int i, sz, deadline;
d915 1
@


1.172
log
@Check current parent process ID against saved one to determine if the parent
has exited, rather than attempting to send a zero signal, since the latter
won't work if the parent has changed privs.  bz#1905, patch from Daniel Kahn
Gillmor, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.171 2010/11/21 01:01:13 djm Exp $ */
d161 3
a163 4
	if (id->provider != NULL)
		xfree(id->provider);
	xfree(id->comment);
	xfree(id);
d191 1
a191 1
	xfree(p);
d218 1
a218 1
			xfree(blob);
d336 3
a338 4
	xfree(data);
	xfree(blob);
	if (signature != NULL)
		xfree(signature);
d365 1
a365 1
		xfree(blob);
d493 1
a493 1
			xfree(cert);
d503 1
a503 1
			xfree(curve);
d534 1
a534 1
			xfree(cert);
d565 1
a565 1
			xfree(cert);
d573 1
a573 1
			xfree(type_name);
d577 1
a577 1
		xfree(type_name);
d595 1
a595 1
		xfree(comment);
d609 1
a609 1
			xfree(comment);
d625 1
a625 1
		xfree(id->comment);
d647 1
a647 1
		xfree(lock_passwd);
d656 1
a656 1
	xfree(passwd);
d729 3
a731 6
	if (pin)
		xfree(pin);
	if (provider)
		xfree(provider);
	if (keys)
		xfree(keys);
d747 1
a747 1
	xfree(pin);
d765 1
a765 1
	xfree(provider);
d930 2
a931 4
		if (*fdrp)
			xfree(*fdrp);
		if (*fdwp)
			xfree(*fdwp);
@


1.171
log
@honour $TMPDIR for client xauth and ssh-agent temporary directories;
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.170 2010/08/31 12:33:38 djm Exp $ */
d1079 5
a1083 1
	if (parent_pid != -1 && kill(parent_pid, 0) < 0) {
@


1.170
log
@reintroduce commit from tedu@@, which I pulled out for release engineering:

  OpenSSL_add_all_algorithms is the name of the function we have a man page
  for, so use that.  ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.167 2010/08/12 23:34:38 tedu Exp $ */
d1202 1
a1202 1
		strlcpy(socket_dir, "/tmp/ssh-XXXXXXXXXX", sizeof socket_dir);
@


1.169
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.168 2010/08/16 04:06:06 djm Exp $ */
d1125 1
a1125 1
	SSLeay_add_all_algorithms();
@


1.168
log
@backout previous temporarily; discussed with deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.166 2010/04/16 01:47:26 djm Exp $ */
d455 1
a455 1
	char *type_name, *comment;
d457 2
a480 1
		xfree(type_name);
d499 51
d575 1
d579 1
@


1.167
log
@OpenSSL_add_all_algorithms is the name of the function we have a man page
for, so use that.  ok djm
@
text
@d1071 1
a1071 1
	OpenSSL_add_all_algorithms();
@


1.166
log
@revised certificate format ssh-{dss,rsa}-cert-v01@@openssh.com with the
following changes:

move the nonce field to the beginning of the certificate where it can
better protect against chosen-prefix attacks on the signature hash

Rename "constraints" field to "critical options"

Add a new non-critical "extensions" field

Add a serial number

The older format is still support for authentication and cert generation
(use "ssh-keygen -t v00 -s ca_key ..." to generate a v00 certificate)

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.165 2010/02/26 20:29:54 djm Exp $ */
d1071 1
a1071 1
	SSLeay_add_all_algorithms();
@


1.165
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.164 2010/02/09 00:50:36 djm Exp $ */
d489 1
d510 1
d531 1
@


1.164
log
@fallout from PKCS#11: unbreak -D
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.163 2010/02/08 10:50:20 markus Exp $ */
d457 2
d489 8
d509 11
d529 1
@


1.163
log
@replace our obsolete smartcard code with PKCS#11.
	ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-11/v2-20/pkcs-11v2-20.pdf
ssh(1) and ssh-keygen(1) use dlopen(3) directly to talk to a PKCS#11
provider (shared library) while ssh-agent(1) delegates PKCS#11 to
a forked a ssh-pkcs11-helper process.
PKCS#11 is currently a compile time option.
feedback and ok djm@@; inspired by patches from Alon Bar-Lev
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.162 2009/09/01 14:43:17 djm Exp $ */
d161 2
a162 1
	xfree(id->provider);
@


1.162
log
@fix a race condition in ssh-agent that could result in a wedged or
spinning agent: don't read off the end of the allocated fd_sets, and
don't issue blocking read/write on agent sockets - just fall back to
select() on retriable read/write errors. bz#1633 reported and tested
by "noodle10000 AT googlemail.com"; ok dtucker@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.161 2009/03/23 19:38:04 tobias Exp $ */
d69 2
a70 2
#ifdef SMARTCARD
#include "scard.h"
d94 1
d161 1
d540 1
a540 1
		id = xmalloc(sizeof(Identity));
d600 1
a600 1
#ifdef SMARTCARD
d604 3
a606 3
	char *sc_reader_id = NULL, *pin;
	int i, type, version, success = 0, death = 0, confirm = 0;
	Key **keys, *k;
d610 1
a610 1
	sc_reader_id = buffer_get_string(&e->request, NULL);
a623 2
			xfree(sc_reader_id);
			xfree(pin);
d630 2
a631 9
	keys = sc_get_keys(sc_reader_id, pin);
	xfree(sc_reader_id);
	xfree(pin);

	if (keys == NULL || keys[0] == NULL) {
		error("sc_get_keys failed");
		goto send;
	}
	for (i = 0; keys[i] != NULL; i++) {
d636 1
a636 1
			id = xmalloc(sizeof(Identity));
d638 2
a639 1
			id->comment = sc_get_key_label(k);
a649 1
	xfree(keys);
d651 6
d665 3
a667 4
	char *sc_reader_id = NULL, *pin;
	int i, version, success = 0;
	Key **keys, *k = NULL;
	Identity *id;
d670 1
a670 1
	sc_reader_id = buffer_get_string(&e->request, NULL);
a671 2
	keys = sc_get_keys(sc_reader_id, pin);
	xfree(sc_reader_id);
d674 9
a682 13
	if (keys == NULL || keys[0] == NULL) {
		error("sc_get_keys failed");
		goto send;
	}
	for (i = 0; keys[i] != NULL; i++) {
		k = keys[i];
		version = k->type == KEY_RSA1 ? 1 : 2;
		if ((id = lookup_identity(k, version)) != NULL) {
			tab = idtab_lookup(version);
			TAILQ_REMOVE(&tab->idlist, id, next);
			tab->nentries--;
			free_identity(id);
			success = 1;
a683 2
		key_free(k);
		keys[i] = NULL;
d685 6
a690 2
	xfree(keys);
send:
d695 1
a695 1
#endif /* SMARTCARD */
d780 1
a780 1
#ifdef SMARTCARD
d788 1
a788 1
#endif /* SMARTCARD */
d990 3
d1222 4
@


1.161
log
@My previous commit didn't fix the problem at all, so stick at my first
version of the fix presented to dtucker.

Issue notified by Matthias Barkhoff (matthias dot barkhoff at gmx dot de).

ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.160 2009/03/23 08:31:19 tobias Exp $ */
d908 1
a908 1
	u_int i;
d912 1
a912 1
	for (i = 0; i < sockets_alloc; i++)
d945 6
a950 9
				do {
					len = write(sockets[i].fd,
					    buffer_ptr(&sockets[i].output),
					    buffer_len(&sockets[i].output));
					if (len == -1 && (errno == EAGAIN ||
					    errno == EINTR))
						continue;
					break;
				} while (1);
d958 4
a961 7
				do {
					len = read(sockets[i].fd, buf, sizeof(buf));
					if (len == -1 && (errno == EAGAIN ||
					    errno == EINTR))
						continue;
					break;
				} while (1);
@


1.160
log
@Fixed a possible out-of-bounds memory access if the environment variable
SHELL is shorter than 3 characters.

with input by and ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.159 2008/06/28 14:05:15 djm Exp $ */
d1045 1
d1097 2
a1098 2
		if (shell != NULL &&
		    strncmp(shell + MAX(strlen(shell) - 3, 0), "csh", 3) == 0)
@


1.159
log
@reset global compat flag after processing a protocol 2 signature
request with the legacy DSA encoding flag set; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.158 2008/06/28 13:58:23 djm Exp $ */
d1097 1
a1097 1
		    strncmp(shell + strlen(shell) - 3, "csh", 3) == 0)
@


1.158
log
@refuse to add a key that has unknown constraints specified;
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.157 2007/09/25 23:48:57 canacar Exp $ */
d301 1
d312 1
d338 1
@


1.157
log
@When adding a key that already exists, update the properties
(time, confirm, comment) instead of discarding them. ok djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.156 2007/09/09 11:38:01 sobrado Exp $ */
a514 1
	success = 1;
d516 1
a516 1
		switch (buffer_get_char(&e->request)) {
d524 5
a528 1
			break;
d531 1
d597 1
a597 1
process_add_smartcard_key (SocketEntry *e)
d600 1
a600 1
	int i, version, success = 0, death = 0, confirm = 0;
d609 1
a609 1
		switch (buffer_get_char(&e->request)) {
d617 5
a621 1
			break;
@


1.156
log
@sort synopsis and options in ssh-agent(1); usage is lowercase

ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.155 2007/03/19 12:16:42 dtucker Exp $ */
d447 1
d530 2
a531 2
	if (lookup_identity(k, version) == NULL) {
		Identity *id = xmalloc(sizeof(Identity));
a532 3
		id->comment = comment;
		id->death = death;
		id->confirm = confirm;
d538 1
a538 1
		xfree(comment);
d540 3
@


1.155
log
@Remove the signal handler that checks if the agent's parent process
has gone away, instead check when the select loop returns.  Record when
the next key will expire when scanning for expired keys.  Set the select
timeout to whichever of these two things happens next.  With djm@@, with &
ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.154 2007/02/28 00:55:30 dtucker Exp $ */
d1006 1
a1006 1
	fprintf(stderr, "Usage: %s [options] [command [args ...]]\n",
@


1.154
log
@Remove expired keys periodically so they don't remain in memory when
the agent is entirely idle, as noted by David R. Piegdon.  This is the
simple fix, a more efficient one will be done later.  With markus,
deraadt, with & ok djm.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.153 2006/10/06 02:29:19 djm Exp $ */
d110 1
d412 2
a413 1
static void
d416 1
a416 1
	u_int now = time(NULL);
d425 3
a427 1
			if (id->death != 0 && now >= id->death) {
d432 3
a434 1
			}
d437 4
d826 2
a827 1
prepare_select(fd_set **fdrp, fd_set **fdwp, int *fdl, u_int *nallocp)
d829 1
a829 1
	u_int i, sz;
d831 1
d875 11
a992 1
/*ARGSUSED*/
d994 1
a994 1
check_parent_exists(int sig)
a995 2
	int save_errno = errno;

d998 2
a999 1
		cleanup_handler(sig); /* safe */
a1000 3
	signal(SIGALRM, check_parent_exists);
	alarm(10);
	errno = save_errno;
d1032 1
a1032 1
	struct timeval tv;
d1219 2
a1220 4
	if (ac > 0) {
		signal(SIGALRM, check_parent_exists);
		alarm(10);
	}
d1230 2
a1231 4
		tv.tv_sec = 10;
		tv.tv_usec = 0;
		prepare_select(&readsetp, &writesetp, &max_fd, &nalloc);
		result = select(max_fd + 1, readsetp, writesetp, NULL, &tv);
d1233 3
a1235 1
		reaper();	/* remove expired keys */
@


1.153
log
@sys/resource.h needs sys/time.h; prompted by brad@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.152 2006/08/04 20:46:05 stevesk Exp $ */
d424 1
a688 3
	/* kill dead keys */
	reaper();

d1004 1
a1004 1
	int sock, fd, ch;
d1014 1
d1214 2
d1217 5
a1221 2
		if (select(max_fd + 1, readsetp, writesetp, NULL, NULL) < 0) {
			if (errno == EINTR)
d1223 3
a1225 3
			fatal("select: %s", strerror(errno));
		}
		after_select(readsetp, writesetp);
@


1.152
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.151 2006/08/03 03:34:42 deraadt Exp $ */
d38 1
a43 1
#include <sys/time.h>
@


1.152.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.153 2006/10/06 02:29:19 djm Exp $ */
a37 1
#include <sys/time.h>
d43 1
@


1.151
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.150 2006/08/01 23:22:47 stevesk Exp $ */
d1006 1
a1006 1
	int sock, fd,  ch;
@


1.150
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.149 2006/07/26 13:57:17 stevesk Exp $ */
d37 1
a37 2
#include "includes.h"

d59 1
a62 2
#include "bufaux.h"
#include "xmalloc.h"
@


1.149
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.148 2006/07/26 02:35:17 stevesk Exp $ */
d55 1
@


1.148
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.147 2006/07/25 02:59:21 stevesk Exp $ */
d54 1
@


1.147
log
@move #include <sys/time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.146 2006/07/22 20:48:23 stevesk Exp $ */
d45 1
@


1.146
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.145 2006/07/22 19:08:54 stevesk Exp $ */
d44 1
@


1.145
log
@move #include <time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.144 2006/07/17 01:31:10 stevesk Exp $ */
d45 3
d52 1
a54 3

#include <openssl/evp.h>
#include <openssl/md5.h>
@


1.144
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.143 2006/07/11 20:07:25 stevesk Exp $ */
d49 1
@


1.143
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.142 2006/07/09 15:15:11 stevesk Exp $ */
d49 1
@


1.142
log
@move #include <fcntl.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.141 2006/07/08 21:47:12 stevesk Exp $ */
d45 1
@


1.141
log
@move #include <sys/socket.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.140 2006/06/13 02:17:07 djm Exp $ */
d45 1
@


1.140
log
@revert; i am on drugs. spotted by alexander AT beard.se
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.138 2006/05/17 12:43:34 markus Exp $ */
d42 1
@


1.139
log
@always use a format string, even when printing a constant
@
text
@d1084 2
a1085 2
		printf(format, "%s", SSH_AUTHSOCKET_ENV_NAME);
		printf(format, "%s", SSH_AGENTPID_ENV_NAME);
@


1.138
log
@fix leak; coverity via Kylene Jo Hall
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.137 2006/03/30 09:58:16 djm Exp $ */
d1084 2
a1085 2
		printf(format, SSH_AUTHSOCKET_ENV_NAME);
		printf(format, SSH_AGENTPID_ENV_NAME);
@


1.137
log
@replace {GET,PUT}_XXBIT macros with functionally similar functions,
silencing a heap of lint warnings. also allows them to use
__bounded__ checking which can't be applied to macros; requested
by and feedback from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.136 2006/03/28 01:53:43 deraadt Exp $ */
d310 1
a311 1
	key_free(key);
@


1.136
log
@use strtonum() to parse the pid from the file, and range check it
better; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.135 2006/03/25 18:41:45 deraadt Exp $ */
a54 1
#include "getput.h"
d686 1
a686 1
	msg_len = GET_32BIT(cp);
@


1.135
log
@mark two more signal handlers ARGSUSED
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.134 2006/03/25 13:17:02 djm Exp $ */
d1060 2
a1061 1
		if (shell != NULL && strncmp(shell + strlen(shell) - 3, "csh", 3) == 0)
d1065 2
d1073 5
a1077 4
		pid = atoi(pidstr);
		if (pid < 1) {
			fprintf(stderr, "%s=\"%s\", which is not a good PID\n",
			    SSH_AGENTPID_ENV_NAME, pidstr);
@


1.134
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d957 1
d965 1
@


1.133
log
@change OpenSSH's xrealloc() function from being xrealloc(p, new_size) to
xrealloc(p, new_nmemb, new_itemsize).

realloc is particularly prone to integer overflows because it is almost
always allocating "n * size" bytes, so this is a far safer API;
ok deraadt@@
@
text
@d1 1
@


1.132
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d798 1
a798 1
	sockets = xrealloc(sockets, new_alloc * sizeof(sockets[0]));
@


1.131
log
@annoying spacing fixes getting in the way of real diffs
@
text
@d104 2
a105 2
char socket_name[1024];
char socket_dir[1024];
d798 1
a798 4
	if (sockets)
		sockets = xrealloc(sockets, new_alloc * sizeof(sockets[0]));
	else
		sockets = xmalloc(new_alloc * sizeof(sockets[0]));
@


1.130
log
@RCSID() can die
@
text
@d882 1
a882 1
				    (struct sockaddr *) &sunaddr, &slen);
d1116 1
a1116 1
	if (bind(sock, (struct sockaddr *) & sunaddr, sizeof(sunaddr)) < 0) {
@


1.129
log
@move #include <signal.h> out of includes.h; ok markus@@
@
text
@a36 1
RCSID("$OpenBSD: ssh-agent.c,v 1.128 2006/02/20 16:36:14 stevesk Exp $");
@


1.129.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh-agent.c,v 1.152 2006/08/04 20:46:05 stevesk Exp $ */
d36 3
a38 1
#include <sys/types.h>
a41 1
#include <sys/socket.h>
d43 3
a45 2
#include <sys/time.h>
#include <sys/param.h>
a49 11
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "xmalloc.h"
d53 3
d105 2
a106 2
char socket_name[MAXPATHLEN];
char socket_dir[MAXPATHLEN];
a310 1
		key_free(key);
d312 1
d687 1
a687 1
	msg_len = get_u32(cp);
d799 4
a802 1
	sockets = xrealloc(sockets, new_alloc, sizeof(sockets[0]));
d883 1
a883 1
				    (struct sockaddr *)&sunaddr, &slen);
a959 1
/*ARGSUSED*/
a966 1
/*ARGSUSED*/
d1000 1
a1000 1
	int sock, fd, ch;
d1061 1
a1061 2
		if (shell != NULL &&
		    strncmp(shell + strlen(shell) - 3, "csh", 3) == 0)
a1064 2
		const char *errstr = NULL;

d1071 4
a1074 5
		pid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);
		if (errstr) {
			fprintf(stderr,
			    "%s=\"%s\", which is not a good PID: %s\n",
			    SSH_AGENTPID_ENV_NAME, pidstr, errstr);
d1117 1
a1117 1
	if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {
@


1.129.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.153 2006/10/06 02:29:19 djm Exp $ */
a37 1
#include <sys/time.h>
d43 1
@


1.128
log
@move #include <sys/un.h> out of includes.h; ok djm@@
@
text
@d37 1
a37 1
RCSID("$OpenBSD: ssh-agent.c,v 1.127 2006/02/08 14:31:30 stevesk Exp $");
d45 1
@


1.127
log
@move #include <sys/resource.h> out of includes.h; ok markus@@
@
text
@d37 1
a37 1
RCSID("$OpenBSD: ssh-agent.c,v 1.126 2006/02/08 12:15:27 stevesk Exp $");
d41 2
@


1.126
log
@move #include <paths.h> out of includes.h; ok markus@@
@
text
@d37 1
a37 1
RCSID("$OpenBSD: ssh-agent.c,v 1.125 2006/02/07 01:18:09 stevesk Exp $");
d40 1
@


1.125
log
@move #include <sys/queue.h> out of includes.h; ok markus@@
@
text
@d37 1
a37 1
RCSID("$OpenBSD: ssh-agent.c,v 1.124 2005/10/30 08:52:18 djm Exp $");
d40 2
@


1.124
log
@no need to escape single quotes in comments, no binary change
@
text
@d37 2
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.123 2005/09/13 23:40:07 djm Exp $");
@


1.123
log
@ensure that stdio fds are attached; ok deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.122 2004/10/29 22:53:56 djm Exp $");
d354 1
a354 1
			 * don\'t want to leave empty slots in the middle of
@


1.122
log
@factor out common permission-asking code to separate function; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.121 2004/10/07 10:12:36 djm Exp $");
d1003 3
@


1.122.4.1
log
@upgrade to OpenSSH 4.3
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.124 2005/10/30 08:52:18 djm Exp $");
d354 1
a354 1
			 * don't want to leave empty slots in the middle of
a1002 3

	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();
@


1.122.4.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh-agent.c,v 1.152 2006/08/04 20:46:05 stevesk Exp $ */
d36 1
a36 2
#include <sys/types.h>
#include <sys/time.h>
d38 1
a38 5
#include <sys/resource.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/param.h>
a42 11
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "xmalloc.h"
d46 3
d98 2
a99 2
char socket_name[MAXPATHLEN];
char socket_dir[MAXPATHLEN];
a303 1
		key_free(key);
d305 1
d680 1
a680 1
	msg_len = get_u32(cp);
d792 4
a795 1
	sockets = xrealloc(sockets, new_alloc, sizeof(sockets[0]));
d876 1
a876 1
				    (struct sockaddr *)&sunaddr, &slen);
a952 1
/*ARGSUSED*/
a959 1
/*ARGSUSED*/
d993 1
a993 1
	int sock, fd, ch;
d1054 1
a1054 2
		if (shell != NULL &&
		    strncmp(shell + strlen(shell) - 3, "csh", 3) == 0)
a1057 2
		const char *errstr = NULL;

d1064 4
a1067 5
		pid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);
		if (errstr) {
			fprintf(stderr,
			    "%s=\"%s\", which is not a good PID: %s\n",
			    SSH_AGENTPID_ENV_NAME, pidstr, errstr);
d1110 1
a1110 1
	if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {
@


1.122.4.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.153 2006/10/06 02:29:19 djm Exp $ */
@


1.122.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.124 2005/10/30 08:52:18 djm Exp $");
d354 1
a354 1
			 * don't want to leave empty slots in the middle of
a1002 3

	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();
@


1.121
log
@don't unlink agent socket when bind() fails, spotted by rich AT rich-paul.net
ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.120 2004/08/11 21:43:05 avsm Exp $");
d167 1
a167 1
	char *p, prompt[1024];
d171 3
a173 2
	snprintf(prompt, sizeof(prompt), "Allow use of key %s?\n"
	    "Key fingerprint %s.", id->comment, p);
d175 1
a175 10
	p = read_passphrase(prompt, RP_ALLOW_EOF);
	if (p != NULL) {
		/*
		 * Accept empty responses and responses consisting
		 * of the word "yes" as affirmative.
		 */
		if (*p == '\0' || *p == '\n' || strcasecmp(p, "yes") == 0)
			ret = 0;
		xfree(p);
	}
@


1.120
log
@some signed/unsigned int comparison cleanups; markus@@ ok
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.119 2004/06/14 01:44:39 djm Exp $");
d1109 1
d1117 1
@


1.120.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.122 2004/10/29 22:53:56 djm Exp $");
d167 1
a167 1
	char *p;
d171 2
a172 3
	if (ask_permission("Allow use of key %s?\nKey fingerprint %s.",
	    id->comment, p))
		ret = 0;
d174 10
a183 1

a1108 1
		*socket_name = '\0'; /* Don't unlink any existing file */
a1115 1
		*socket_name = '\0'; /* Don't unlink any existing file */
@


1.119
log
@set_nonblock() instead of fnctl(...,O_NONBLOCK); "looks sane" deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.118 2004/05/08 00:21:31 djm Exp $");
d815 1
a815 1
prepare_select(fd_set **fdrp, fd_set **fdwp, int *fdl, int *nallocp)
d1001 2
a1002 1
	int sock, fd,  ch, nalloc;
@


1.118
log
@kill a tiny header; ok deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.117 2003/12/02 17:01:15 markus Exp $");
d784 1
a784 2
	if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0)
		error("fcntl O_NONBLOCK: %s", strerror(errno));
@


1.117
log
@use SSH_LISTEN_BACKLOG (=128) in listen(2).
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.116 2003/11/21 11:57:03 djm Exp $");
a52 1
#include "readpass.h"
@


1.117.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.120 2004/08/11 21:43:05 avsm Exp $");
d53 1
d785 2
a786 1
	set_nonblock(fd);
d817 1
a817 1
prepare_select(fd_set **fdrp, fd_set **fdwp, int *fdl, u_int *nallocp)
d1003 1
a1003 2
	int sock, fd,  ch;
	u_int nalloc;
@


1.117.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.122 2004/10/29 22:53:56 djm Exp $");
d167 1
a167 1
	char *p;
d171 2
a172 3
	if (ask_permission("Allow use of key %s?\nKey fingerprint %s.",
	    id->comment, p))
		ret = 0;
d174 10
a183 1

a1108 1
		*socket_name = '\0'; /* Don't unlink any existing file */
a1115 1
		*socket_name = '\0'; /* Don't unlink any existing file */
@


1.116
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.115 2003/10/14 19:54:39 markus Exp $");
d1119 1
a1119 1
	if (listen(sock, 128) < 0) {
@


1.115
log
@10X for mkdtemp; djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.114 2003/09/23 20:17:11 markus Exp $");
d178 1
a178 1
		 * Accept empty responses and responses consisting 
@


1.114
log
@replace fatal_cleanup() and linked list of fatal callbacks with static
cleanup_exit() function.  re-refine cleanup_exit() where appropriate,
allocate sshd's authctxt eary to allow simpler cleanup in sshd.
tested by many, ok deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.113 2003/09/19 11:29:40 markus Exp $");
d1090 1
a1090 1
		strlcpy(socket_dir, "/tmp/ssh-XXXXXXXX", sizeof socket_dir);
@


1.113
log
@provide a ssh-agent specific fatal() function; ok deraadt
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.112 2003/09/18 08:49:45 markus Exp $");
d956 1
a956 1
static void
a967 11
}

void
fatal(const char *fmt,...)
{
	va_list args;
	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_FATAL, fmt, args);
	va_end(args);
	cleanup_socket();
	_exit(255);
@


1.112
log
@more buffer allocation fixes; from Solar Designer; CAN-2003-0682; ok millert@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.111 2003/06/12 19:12:03 markus Exp $");
d948 1
a948 1
cleanup_socket(void *p)
d959 2
a960 2
	cleanup_socket(NULL);
	exit(i);
d966 1
a966 1
	cleanup_socket(NULL);
d970 11
a1198 1
	fatal_add_cleanup(cleanup_socket, NULL);
@


1.111
log
@add sc_get_key_label; larsch at trustcenter.de; bugzilla#591
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.110 2003/06/11 11:18:38 djm Exp $");
d783 1
a783 1
	u_int i, old_alloc;
a793 1
			sockets[i].type = type;
d797 1
d801 1
a801 1
	sockets_alloc += 10;
d803 1
a803 1
		sockets = xrealloc(sockets, sockets_alloc * sizeof(sockets[0]));
d805 2
a806 2
		sockets = xmalloc(sockets_alloc * sizeof(sockets[0]));
	for (i = old_alloc; i < sockets_alloc; i++)
d808 1
a808 1
	sockets[old_alloc].type = type;
d813 1
@


1.111.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.117 2003/12/02 17:01:15 markus Exp $");
d178 1
a178 1
		 * Accept empty responses and responses consisting
d783 1
a783 1
	u_int i, old_alloc, new_alloc;
d794 1
a797 1
			sockets[i].type = type;
d801 1
a801 1
	new_alloc = sockets_alloc + 10;
d803 1
a803 1
		sockets = xrealloc(sockets, new_alloc * sizeof(sockets[0]));
d805 2
a806 2
		sockets = xmalloc(new_alloc * sizeof(sockets[0]));
	for (i = old_alloc; i < new_alloc; i++)
d808 1
a808 1
	sockets_alloc = new_alloc;
a812 1
	sockets[old_alloc].type = type;
d947 1
a947 1
cleanup_socket(void)
d955 1
a955 1
void
d958 2
a959 2
	cleanup_socket();
	_exit(i);
d965 1
a965 1
	cleanup_socket();
d1089 1
a1089 1
		strlcpy(socket_dir, "/tmp/ssh-XXXXXXXXXX", sizeof socket_dir);
d1118 1
a1118 1
	if (listen(sock, SSH_LISTEN_BACKLOG) < 0) {
d1187 1
@


1.111.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.120 2004/08/11 21:43:05 avsm Exp $");
d53 1
d785 2
a786 1
	set_nonblock(fd);
d817 1
a817 1
prepare_select(fd_set **fdrp, fd_set **fdwp, int *fdl, u_int *nallocp)
d1003 1
a1003 2
	int sock, fd,  ch;
	u_int nalloc;
@


1.110
log
@make agent constraints (lifetime, confirm) work with smartcard keys; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.109 2003/04/08 20:21:29 itojun Exp $");
d617 1
a617 1
			id->comment = xstrdup("smartcard key");
@


1.109
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.108 2003/03/13 11:44:50 markus Exp $");
d579 1
a579 1
	int i, version, success = 0;
d586 16
d618 2
a619 2
			id->death = 0;
			id->confirm = 0;
d763 1
@


1.108
log
@ssh-agent is similar to ssh-keysign (allows other processes to use
private rsa keys). however, it gets key over socket and not from
a file, so we have to do blinding here as well.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.107 2003/01/23 13:50:27 markus Exp $");
d260 1
a260 1
			log("process_authentication_challenge: bad challenge length %d", len);
d349 1
a349 1
			log("Warning: identity keysize mismatch: actual %u, announced %u",
@


1.108.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.111 2003/06/12 19:12:03 markus Exp $");
d260 1
a260 1
			logit("process_authentication_challenge: bad challenge length %d", len);
d349 1
a349 1
			logit("Warning: identity keysize mismatch: actual %u, announced %u",
d579 1
a579 1
	int i, version, success = 0, death = 0, confirm = 0;
a585 16

	while (buffer_len(&e->request)) {
		switch (buffer_get_char(&e->request)) {
		case SSH_AGENT_CONSTRAIN_LIFETIME:
			death = time(NULL) + buffer_get_int(&e->request);
			break;
		case SSH_AGENT_CONSTRAIN_CONFIRM:
			confirm = 1;
			break;
		default:
			break;
		}
	}
	if (lifetime && !death)
		death = time(NULL) + lifetime;

d601 3
a603 3
			id->comment = sc_get_key_label(k);
			id->death = death;
			id->confirm = confirm;
a746 1
	case SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:
@


1.108.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.117 2003/12/02 17:01:15 markus Exp $");
d178 1
a178 1
		 * Accept empty responses and responses consisting
d783 1
a783 1
	u_int i, old_alloc, new_alloc;
d794 1
a797 1
			sockets[i].type = type;
d801 1
a801 1
	new_alloc = sockets_alloc + 10;
d803 1
a803 1
		sockets = xrealloc(sockets, new_alloc * sizeof(sockets[0]));
d805 2
a806 2
		sockets = xmalloc(new_alloc * sizeof(sockets[0]));
	for (i = old_alloc; i < new_alloc; i++)
d808 1
a808 1
	sockets_alloc = new_alloc;
a812 1
	sockets[old_alloc].type = type;
d947 1
a947 1
cleanup_socket(void)
d955 1
a955 1
void
d958 2
a959 2
	cleanup_socket();
	_exit(i);
d965 1
a965 1
	cleanup_socket();
d1089 1
a1089 1
		strlcpy(socket_dir, "/tmp/ssh-XXXXXXXXXX", sizeof socket_dir);
d1118 1
a1118 1
	if (listen(sock, SSH_LISTEN_BACKLOG) < 0) {
d1187 1
@


1.107
log
@ssh-add -c, prompt user for confirmation (using ssh-askpass) when
private agent key is used; with djm@@; test by dugsong@@, djm@@; ok deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.106 2003/01/21 18:14:36 marc Exp $");
d478 11
@


1.106
log
@
Add a -t life option to ssh-agent that set the default lifetime.
The default can still be overriden by using -t in ssh-add.
OK markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.105 2002/10/01 20:34:12 markus Exp $");
d53 2
d82 1
d164 24
d251 1
a251 1
	if (id != NULL) {
d311 1
a311 1
		if (id != NULL)
d431 1
a431 1
	int type, success = 0, death = 0;
d493 3
d507 1
d592 1
d973 2
a974 1
	int sock, c_flag = 0, d_flag = 0, k_flag = 0, s_flag = 0, ch, nalloc;
d1142 8
a1149 3
	close(0);
	close(1);
	close(2);
@


1.105
log
@allow root to access the agent, since there is no protection from root.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.104 2002/09/12 19:11:52 stevesk Exp $");
d105 3
d470 2
d934 1
d957 1
a957 1
	while ((ch = getopt(ac, av, "cdksa:")) != -1) {
d979 6
@


1.105.2.1
log
@Update to OpenSSH 3.6
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.108 2003/03/13 11:44:50 markus Exp $");
a52 2
#include "readpass.h"
#include "misc.h"
a79 1
	u_int confirm;
a104 3
/* Default lifetime (0 == forever) */
static int lifetime = 0;

a157 24
/* Check confirmation of keysign request */
static int
confirm_key(Identity *id)
{
	char *p, prompt[1024];
	int ret = -1;

	p = key_fingerprint(id->key, SSH_FP_MD5, SSH_FP_HEX);
	snprintf(prompt, sizeof(prompt), "Allow use of key %s?\n"
	    "Key fingerprint %s.", id->comment, p);
	xfree(p);
	p = read_passphrase(prompt, RP_ALLOW_EOF);
	if (p != NULL) {
		/*
		 * Accept empty responses and responses consisting 
		 * of the word "yes" as affirmative.
		 */
		if (*p == '\0' || *p == '\n' || strcasecmp(p, "yes") == 0)
			ret = 0;
		xfree(p);
	}
	return (ret);
}

d221 1
a221 1
	if (id != NULL && (!id->confirm || confirm_key(id) == 0)) {
d281 1
a281 1
		if (id != NULL && (!id->confirm || confirm_key(id) == 0))
d401 1
a401 1
	int type, success = 0, death = 0, confirm = 0;
a451 11
	/* enable blinding */
	switch (k->type) {
	case KEY_RSA:
	case KEY_RSA1:
		if (RSA_blinding_on(k->rsa, NULL) != 1) {
			error("process_add_identity: RSA_blinding_on failed");
			key_free(k);
			goto send;
		}
		break;
	}
a462 3
		case SSH_AGENT_CONSTRAIN_CONFIRM:
			confirm = 1;
			break;
a466 2
	if (lifetime && !death)
		death = time(NULL) + lifetime;
a471 1
		id->confirm = confirm;
a555 1
			id->confirm = 0;
a928 1
	fprintf(stderr, "  -t life     Default identity lifetime (seconds).\n");
d935 1
a935 2
	int c_flag = 0, d_flag = 0, k_flag = 0, s_flag = 0;
	int sock, fd,  ch, nalloc;
d951 1
a951 1
	while ((ch = getopt(ac, av, "cdksa:t:")) != -1) {
a973 6
		case 't':
			if ((lifetime = convtime(optarg)) == -1) {
				fprintf(stderr, "Invalid lifetime\n");
				usage();
			}
			break;
d1097 3
a1099 8
	if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
		/* XXX might close listen socket */
		(void)dup2(fd, STDIN_FILENO);
		(void)dup2(fd, STDOUT_FILENO);
		(void)dup2(fd, STDERR_FILENO);
		if (fd > 2)
			close(fd);
	}
@


1.105.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.111 2003/06/12 19:12:03 markus Exp $");
d260 1
a260 1
			logit("process_authentication_challenge: bad challenge length %d", len);
d349 1
a349 1
			logit("Warning: identity keysize mismatch: actual %u, announced %u",
d579 1
a579 1
	int i, version, success = 0, death = 0, confirm = 0;
a585 16

	while (buffer_len(&e->request)) {
		switch (buffer_get_char(&e->request)) {
		case SSH_AGENT_CONSTRAIN_LIFETIME:
			death = time(NULL) + buffer_get_int(&e->request);
			break;
		case SSH_AGENT_CONSTRAIN_CONFIRM:
			confirm = 1;
			break;
		default:
			break;
		}
	}
	if (lifetime && !death)
		death = time(NULL) + lifetime;

d601 3
a603 3
			id->comment = sc_get_key_label(k);
			id->death = death;
			id->confirm = confirm;
a746 1
	case SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:
@


1.104
log
@%u for uid print; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.103 2002/09/10 20:24:47 markus Exp $");
d832 1
a832 1
				if (getuid() != euid) {
@


1.103
log
@check the euid of the connecting process with getpeereid(2); ok provos deraadt stevesk
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.102 2002/08/22 20:57:19 stevesk Exp $");
d834 2
a835 2
					    "peer euid %d != uid %d",
					    (int) euid, (int) getuid());
@


1.102
log
@shutdown(SHUT_RDWR) not needed before close here; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.101 2002/08/22 19:27:53 stevesk Exp $");
d809 2
d824 13
@


1.101
log
@use common close function; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.100 2002/08/21 20:10:28 stevesk Exp $");
a107 1
	shutdown(e->fd, SHUT_RDWR);
@


1.100
log
@raise listen backlog; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.99 2002/08/12 10:46:35 markus Exp $");
d106 12
d628 1
a628 7
		shutdown(e->fd, SHUT_RDWR);
		close(e->fd);
		e->fd = -1;
		e->type = AUTH_UNUSED;
		buffer_free(&e->input);
		buffer_free(&e->output);
		buffer_free(&e->request);
d841 1
a841 7
					shutdown(sockets[i].fd, SHUT_RDWR);
					close(sockets[i].fd);
					sockets[i].fd = -1;
					sockets[i].type = AUTH_UNUSED;
					buffer_free(&sockets[i].input);
					buffer_free(&sockets[i].output);
					buffer_free(&sockets[i].request);
d855 1
a855 7
					shutdown(sockets[i].fd, SHUT_RDWR);
					close(sockets[i].fd);
					sockets[i].fd = -1;
					sockets[i].type = AUTH_UNUSED;
					buffer_free(&sockets[i].input);
					buffer_free(&sockets[i].output);
					buffer_free(&sockets[i].request);
@


1.99
log
@make ssh-agent setgid, disallow ptrace.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.98 2002/07/21 18:07:45 stevesk Exp $");
d1037 1
a1037 1
	if (listen(sock, 5) < 0) {
@


1.98
log
@extern char *optarg; for portable
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.97 2002/06/24 14:55:38 markus Exp $");
d936 4
@


1.97
log
@cat to (void) when output from buffer_get_X is ignored
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.96 2002/06/23 10:29:52 deraadt Exp $");
d933 1
@


1.96
log
@some minor KNF and %u
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.95 2002/06/19 00:27:55 deraadt Exp $");
d196 1
a196 1
	buffer_get_int(&e->request);				/* ignored */
d397 1
a397 1
		buffer_get_int(&e->request);			/* ignored */
@


1.95
log
@KNF done automatically while reading....
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.94 2002/06/15 01:27:48 markus Exp $");
d109 1
d152 1
a153 1
	Identity *id;
d182 3
a185 2
	Key *key;
	BIGNUM *challenge;
d189 1
a189 2
	u_char buf[32], mdbuf[16], session_id[16];
	u_int response_type;
a250 2
	extern int datafellows;
	Key *key;
d253 2
a254 1
	int flags;
d256 1
a256 1
	int ok = -1;
d295 2
a298 3
	u_int blen;
	u_int bits;
	int success = 0;
d308 1
a308 1
			log("Warning: identity keysize mismatch: actual %d, announced %d",
d368 1
a368 1
	Idtab *tab;
d371 1
a371 1
	u_int now = time(NULL);
d389 3
a392 4
	char *type_name;
	char *comment;
	int type, success = 0, death = 0;
	Idtab *tab = idtab_lookup(version);
d478 1
a479 1
	int success = 0;
d520 3
a524 3
	Key **keys, *k;
	char *sc_reader_id = NULL, *pin;
	int i, version, success = 0;
d563 3
a567 3
	Key **keys, *k = NULL;
	char *sc_reader_id = NULL, *pin;
	int i, version, success = 0;
d605 1
a605 2
	u_int msg_len;
	u_int type;
d618 1
d714 1
d799 1
a799 2
	u_int i;
	int len, sock;
d802 2
a803 1
	struct sockaddr_un sunaddr;
d837 1
d857 1
d928 2
d932 1
d934 1
a934 4
	char *shell, *format, *pidstr, pidstrbuf[1 + 3 * sizeof pid];
	char *agentsocket = NULL;
	extern int optind;
	fd_set *readsetp = NULL, *writesetp = NULL;
@


1.94
log
@remove the CONSTRAIN_IDENTITY messages and introduce a new
ADD_ID message with contraints instead. contraints can be
only added together with the private key.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.93 2002/06/15 00:07:38 markus Exp $");
a363 1
	return;
d497 1
a497 1
 
a500 1
	return;
@


1.93
log
@fix stupid typo
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.92 2002/06/15 00:01:36 markus Exp $");
d394 1
a394 1
	int type, success = 0;
d450 9
d463 1
a463 1
		id->death = 0;
a476 44
static void
process_constrain_identity(SocketEntry *e, int version)
{
	Key *key = NULL;
	u_char *blob;
	u_int blen, bits, death = 0;
	int success = 0;

	switch (version) {
	case 1:
		key = key_new(KEY_RSA1);
		bits = buffer_get_int(&e->request);
		buffer_get_bignum(&e->request, key->rsa->e);
		buffer_get_bignum(&e->request, key->rsa->n);

		break;
	case 2:
		blob = buffer_get_string(&e->request, &blen);
		key = key_from_blob(blob, blen);
		xfree(blob);
		break;
	}
	while (buffer_len(&e->request)) {
		switch (buffer_get_char(&e->request)) {
		case SSH_AGENT_CONSTRAIN_LIFETIME:
			death = time(NULL) + buffer_get_int(&e->request);
			break;
		default:
			break;
		}
	}
	if (key != NULL) {
		Identity *id = lookup_identity(key, version);
		if (id != NULL && id->death == 0 && death != 0) {
			id->death = death;
			success = 1;
		}
		key_free(key);
	}
	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
}

d670 1
a678 3
	case SSH_AGENTC_CONSTRAIN_IDENTITY1:
		process_constrain_identity(e, 1);
		break;
d687 1
a694 3
		break;
	case SSH_AGENTC_CONSTRAIN_IDENTITY:
		process_constrain_identity(e, 2);
@


1.92
log
@break agent key lifetime protocol and allow other contraints for key usage.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.91 2002/06/11 05:46:20 mpech Exp $");
d469 1
a469 1
process_contrain_identity(SocketEntry *e, int version)
d492 1
a492 1
		case SSH_AGENT_CONTRAIN_LIFETIME:
d713 2
a714 2
	case SSH_AGENTC_CONTRAIN_IDENTITY1:
		process_contrain_identity(e, 1);
d732 2
a733 2
	case SSH_AGENTC_CONTRAIN_IDENTITY:
		process_contrain_identity(e, 2);
@


1.91
log
@pid_t cleanup. Markus need this now to keep hacking.
markus@@, millert@@ ok

Note: big usr.bin/ cleanup is comming. Now I'm waiting Ok from espie@@ for
make/.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.90 2002/06/09 13:32:01 markus Exp $");
d469 1
a469 1
process_lifetime_identity(SocketEntry *e, int version)
d473 1
a473 1
	u_int blen, bits, death;
a475 2
	death = time(NULL) + buffer_get_int(&e->request);

d490 9
d501 1
a501 1
		if (id != NULL && id->death == 0) {
d713 2
a714 2
	case SSH_AGENTC_LIFETIME_IDENTITY1:
		process_lifetime_identity(e, 1);
d732 2
a733 2
	case SSH_AGENTC_LIFETIME_IDENTITY:
		process_lifetime_identity(e, 2);
@


1.90
log
@use tab not spaces (|unexpand)
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.89 2002/06/05 21:55:44 markus Exp $");
d1029 1
a1029 1
		printf("echo Agent pid %d killed;\n", pid);
d1041 2
a1042 2
		snprintf(socket_name, sizeof socket_name, "%s/agent.%d", socket_dir,
		    parent_pid);
d1079 1
a1079 1
		printf("echo Agent pid %d;\n", parent_pid);
d1089 1
a1089 1
		snprintf(pidstrbuf, sizeof pidstrbuf, "%d", pid);
d1096 1
a1096 1
			printf("echo Agent pid %d;\n", pid);
@


1.89
log
@ssh-add -t life,  Set lifetime (in seconds) when adding identities; ok provos@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.88 2002/06/05 19:57:12 markus Exp $");
d616 1
a616 1
                        TAILQ_REMOVE(&tab->idlist, id, next);
@


1.88
log
@ssh-add -x for lock and -X for unlocking the agent.
todo: encrypt private keys with locked...
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.87 2002/06/05 16:48:54 markus Exp $");
d79 1
d124 8
a145 8
static void
free_identity(Identity *id)
{
	key_free(id->key);
	xfree(id->comment);
	xfree(id);
}

d368 21
d454 1
d468 37
d576 1
d640 4
d706 3
d724 3
@


1.87
log
@copy current request into an extra buffer and just flush this
request on errors, ok provos@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.86 2002/06/05 16:08:07 markus Exp $");
d98 4
d445 42
d602 17
d621 4
@


1.86
log
@'-a bind_address' binds the agent to user-specified unix-domain
socket instead of /tmp/ssh-XXXXXXXX/agent.<pid>; ok djm@@ (some time ago).
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.85 2002/04/02 11:49:39 markus Exp $");
d69 1
d190 4
a193 4
	buffer_get_int(&e->input);				/* ignored */
	buffer_get_bignum(&e->input, key->rsa->e);
	buffer_get_bignum(&e->input, key->rsa->n);
	buffer_get_bignum(&e->input, challenge);
d196 1
a196 1
	if (buffer_len(&e->input) == 0)
d198 2
a199 2
	buffer_get(&e->input, session_id, 16);
	response_type = buffer_get_int(&e->input);
d255 2
a256 2
	blob = buffer_get_string(&e->input, &blen);
	data = buffer_get_string(&e->input, &dlen);
d258 1
a258 1
	flags = buffer_get_int(&e->input);
d299 3
a301 3
		bits = buffer_get_int(&e->input);
		buffer_get_bignum(&e->input, key->rsa->e);
		buffer_get_bignum(&e->input, key->rsa->n);
d308 1
a308 1
		blob = buffer_get_string(&e->input, &blen);
d374 5
a378 5
		buffer_get_int(&e->input);			/* ignored */
		buffer_get_bignum(&e->input, k->rsa->n);
		buffer_get_bignum(&e->input, k->rsa->e);
		buffer_get_bignum(&e->input, k->rsa->d);
		buffer_get_bignum(&e->input, k->rsa->iqmp);
d381 2
a382 2
		buffer_get_bignum(&e->input, k->rsa->q);	/* p */
		buffer_get_bignum(&e->input, k->rsa->p);	/* q */
d388 1
a388 1
		type_name = buffer_get_string(&e->input, NULL);
d394 5
a398 5
			buffer_get_bignum2(&e->input, k->dsa->p);
			buffer_get_bignum2(&e->input, k->dsa->q);
			buffer_get_bignum2(&e->input, k->dsa->g);
			buffer_get_bignum2(&e->input, k->dsa->pub_key);
			buffer_get_bignum2(&e->input, k->dsa->priv_key);
d402 6
a407 6
			buffer_get_bignum2(&e->input, k->rsa->n);
			buffer_get_bignum2(&e->input, k->rsa->e);
			buffer_get_bignum2(&e->input, k->rsa->d);
			buffer_get_bignum2(&e->input, k->rsa->iqmp);
			buffer_get_bignum2(&e->input, k->rsa->p);
			buffer_get_bignum2(&e->input, k->rsa->q);
d413 1
a413 1
			buffer_clear(&e->input);
d418 1
a418 1
	comment = buffer_get_string(&e->input, NULL);
d452 2
a453 2
	sc_reader_id = buffer_get_string(&e->input, NULL);
	pin = buffer_get_string(&e->input, NULL);
d494 2
a495 2
	sc_reader_id = buffer_get_string(&e->input, NULL);
	pin = buffer_get_string(&e->input, NULL);
d541 3
d548 2
d551 4
a554 1
	type = buffer_get_char(&e->input);
d601 1
a601 1
		buffer_clear(&e->input);
d624 1
d639 1
d737 1
d756 1
@


1.85
log
@check $SHELL for -k and -d, too; http://bugzilla.mindrot.org/show_bug.cgi?id=199
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.84 2002/03/25 17:34:27 markus Exp $");
d802 1
d814 1
d820 1
a820 1
	while ((ch = getopt(ac, av, "cdks")) != -1) {
d840 3
d883 13
a895 5
	/* Create private directory for agent socket */
	strlcpy(socket_dir, "/tmp/ssh-XXXXXXXX", sizeof socket_dir);
	if (mkdtemp(socket_dir) == NULL) {
		perror("mkdtemp: private socket dir");
		exit(1);
a896 2
	snprintf(socket_name, sizeof socket_name, "%s/agent.%d", socket_dir,
	    parent_pid);
@


1.85.2.1
log
@Pull in OpenSSH-3.4
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.97 2002/06/24 14:55:38 markus Exp $");
a68 1
	Buffer request;
a77 1
	u_int death;
a96 4
/* locking */
int locked = 0;
char *lock_passwd = NULL;

a102 1

a117 8
static void
free_identity(Identity *id)
{
	key_free(id->key);
	xfree(id->comment);
	xfree(id);
}

d132 8
d145 1
a146 1
	Buffer msg;
d175 2
a176 2
	u_char buf[32], mdbuf[16], session_id[16];
	u_int response_type;
a177 1
	Identity *id;
d181 2
a182 1
	Key *key;
d189 4
a192 4
	(void) buffer_get_int(&e->request);			/* ignored */
	buffer_get_bignum(&e->request, key->rsa->e);
	buffer_get_bignum(&e->request, key->rsa->n);
	buffer_get_bignum(&e->request, challenge);
d195 1
a195 1
	if (buffer_len(&e->request) == 0)
d197 2
a198 2
	buffer_get(&e->request, session_id, 16);
	response_type = buffer_get_int(&e->request);
d244 2
d248 1
a248 2
	extern int datafellows;
	int ok = -1, flags;
d250 1
a250 1
	Key *key;
d254 2
a255 2
	blob = buffer_get_string(&e->request, &blen);
	data = buffer_get_string(&e->request, &dlen);
d257 1
a257 1
	flags = buffer_get_int(&e->request);
a288 2
	u_int blen, bits;
	int success = 0;
d291 3
d298 3
a300 3
		bits = buffer_get_int(&e->request);
		buffer_get_bignum(&e->request, key->rsa->e);
		buffer_get_bignum(&e->request, key->rsa->n);
d303 1
a303 1
			log("Warning: identity keysize mismatch: actual %u, announced %u",
d307 1
a307 1
		blob = buffer_get_string(&e->request, &blen);
d358 1
a358 21
}

static void
reaper(void)
{
	u_int now = time(NULL);
	Identity *id, *nxt;
	int version;
	Idtab *tab;

	for (version = 1; version < 3; version++) {
		tab = idtab_lookup(version);
		for (id = TAILQ_FIRST(&tab->idlist); id; id = nxt) {
			nxt = TAILQ_NEXT(id, next);
			if (id->death != 0 && now >= id->death) {
				TAILQ_REMOVE(&tab->idlist, id, next);
				free_identity(id);
				tab->nentries--;
			}
		}
	}
d364 4
a368 3
	int type, success = 0, death = 0;
	char *type_name, *comment;
	Key *k = NULL;
d373 5
a377 5
		(void) buffer_get_int(&e->request);		/* ignored */
		buffer_get_bignum(&e->request, k->rsa->n);
		buffer_get_bignum(&e->request, k->rsa->e);
		buffer_get_bignum(&e->request, k->rsa->d);
		buffer_get_bignum(&e->request, k->rsa->iqmp);
d380 2
a381 2
		buffer_get_bignum(&e->request, k->rsa->q);	/* p */
		buffer_get_bignum(&e->request, k->rsa->p);	/* q */
d387 1
a387 1
		type_name = buffer_get_string(&e->request, NULL);
d393 5
a397 5
			buffer_get_bignum2(&e->request, k->dsa->p);
			buffer_get_bignum2(&e->request, k->dsa->q);
			buffer_get_bignum2(&e->request, k->dsa->g);
			buffer_get_bignum2(&e->request, k->dsa->pub_key);
			buffer_get_bignum2(&e->request, k->dsa->priv_key);
d401 6
a406 6
			buffer_get_bignum2(&e->request, k->rsa->n);
			buffer_get_bignum2(&e->request, k->rsa->e);
			buffer_get_bignum2(&e->request, k->rsa->d);
			buffer_get_bignum2(&e->request, k->rsa->iqmp);
			buffer_get_bignum2(&e->request, k->rsa->p);
			buffer_get_bignum2(&e->request, k->rsa->q);
d412 1
a412 1
			buffer_clear(&e->request);
d417 1
a417 1
	comment = buffer_get_string(&e->request, NULL);
a422 9
	while (buffer_len(&e->request)) {
		switch (buffer_get_char(&e->request)) {
		case SSH_AGENT_CONSTRAIN_LIFETIME:
			death = time(NULL) + buffer_get_int(&e->request);
			break;
		default:
			break;
		}
	}
a426 1
		id->death = death;
a439 41
/* XXX todo: encrypt sensitive data with passphrase */
static void
process_lock_agent(SocketEntry *e, int lock)
{
	int success = 0;
	char *passwd;

	passwd = buffer_get_string(&e->request, NULL);
	if (locked && !lock && strcmp(passwd, lock_passwd) == 0) {
		locked = 0;
		memset(lock_passwd, 0, strlen(lock_passwd));
		xfree(lock_passwd);
		lock_passwd = NULL;
		success = 1;
	} else if (!locked && lock) {
		locked = 1;
		lock_passwd = xstrdup(passwd);
		success = 1;
	}
	memset(passwd, 0, strlen(passwd));
	xfree(passwd);

	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
}

static void
no_identities(SocketEntry *e, u_int type)
{
	Buffer msg;

	buffer_init(&msg);
	buffer_put_char(&msg,
	    (type == SSH_AGENTC_REQUEST_RSA_IDENTITIES) ?
	    SSH_AGENT_RSA_IDENTITIES_ANSWER : SSH2_AGENT_IDENTITIES_ANSWER);
	buffer_put_int(&msg, 0);
	buffer_put_int(&e->output, buffer_len(&msg));
	buffer_append(&e->output, buffer_ptr(&msg), buffer_len(&msg));
	buffer_free(&msg);
}
d445 3
a449 3
	Key **keys, *k;
	Identity *id;
	Idtab *tab;
d451 2
a452 2
	sc_reader_id = buffer_get_string(&e->request, NULL);
	pin = buffer_get_string(&e->request, NULL);
a468 1
			id->death = 0;
d487 3
a491 3
	Key **keys, *k = NULL;
	Identity *id;
	Idtab *tab;
d493 2
a494 2
	sc_reader_id = buffer_get_string(&e->request, NULL);
	pin = buffer_get_string(&e->request, NULL);
d508 1
a508 1
			TAILQ_REMOVE(&tab->idlist, id, next);
d529 2
a530 1
	u_int msg_len, type;
a531 4

	/* kill dead keys */
	reaper();

a538 1
		e->fd = -1;
a539 3
		buffer_free(&e->input);
		buffer_free(&e->output);
		buffer_free(&e->request);
a543 2

	/* move the current input to e->request */
d545 1
a545 21
	buffer_clear(&e->request);
	buffer_append(&e->request, buffer_ptr(&e->input), msg_len);
	buffer_consume(&e->input, msg_len);
	type = buffer_get_char(&e->request);

	/* check wheter agent is locked */
	if (locked && type != SSH_AGENTC_UNLOCK) {
		buffer_clear(&e->request);
		switch (type) {
		case SSH_AGENTC_REQUEST_RSA_IDENTITIES:
		case SSH2_AGENTC_REQUEST_IDENTITIES:
			/* send empty lists */
			no_identities(e, type);
			break;
		default:
			/* send a fail message for all other request types */
			buffer_put_int(&e->output, 1);
			buffer_put_char(&e->output, SSH_AGENT_FAILURE);
		}
		return;
	}
a548 4
	case SSH_AGENTC_LOCK:
	case SSH_AGENTC_UNLOCK:
		process_lock_agent(e, type == SSH_AGENTC_LOCK);
		break;
a556 1
	case SSH_AGENTC_ADD_RSA_ID_CONSTRAINED:
a572 1
	case SSH2_AGENTC_ADD_ID_CONSTRAINED:
d592 1
a592 1
		buffer_clear(&e->request);
a602 1

a614 1
			buffer_init(&sockets[i].request);
a628 1
	buffer_init(&sockets[old_alloc].request);
d685 2
a686 1
	struct sockaddr_un sunaddr;
d689 1
a689 2
	int len, sock;
	u_int i;
a722 1
					sockets[i].fd = -1;
a725 1
					buffer_free(&sockets[i].request);
a740 1
					sockets[i].fd = -1;
a743 1
					buffer_free(&sockets[i].request);
a801 1
	fprintf(stderr, "  -a socket   Bind agent socket to given name.\n");
a808 2
	char *shell, *format, *pidstr, *agentsocket = NULL;
	fd_set *readsetp = NULL, *writesetp = NULL;
d811 2
d814 1
a814 2
	pid_t pid;
	char pidstrbuf[1 + 3 * sizeof pid];
d818 1
a818 1
	while ((ch = getopt(ac, av, "cdksa:")) != -1) {
a837 3
		case 'a':
			agentsocket = optarg;
			break;
d873 1
a873 1
		printf("echo Agent pid %ld killed;\n", (long)pid);
d878 5
a882 13
	if (agentsocket == NULL) {
		/* Create private directory for agent socket */
		strlcpy(socket_dir, "/tmp/ssh-XXXXXXXX", sizeof socket_dir);
		if (mkdtemp(socket_dir) == NULL) {
			perror("mkdtemp: private socket dir");
			exit(1);
		}
		snprintf(socket_name, sizeof socket_name, "%s/agent.%ld", socket_dir,
		    (long)parent_pid);
	} else {
		/* Try to use specified agent socket */
		socket_dir[0] = '\0';
		strlcpy(socket_name, agentsocket, sizeof socket_name);
d884 2
d917 1
a917 1
		printf("echo Agent pid %ld;\n", (long)parent_pid);
d927 1
a927 1
		snprintf(pidstrbuf, sizeof pidstrbuf, "%ld", (long)pid);
d934 1
a934 1
			printf("echo Agent pid %ld;\n", (long)pid);
@


1.85.2.2
log
@Update to OpenSSH 3.5
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.105 2002/10/01 20:34:12 markus Exp $");
a105 11
close_socket(SocketEntry *e)
{
	close(e->fd);
	e->fd = -1;
	e->type = AUTH_UNUSED;
	buffer_free(&e->input);
	buffer_free(&e->output);
	buffer_free(&e->request);
}

static void
d616 7
a622 1
		close_socket(e);
a803 2
	uid_t euid;
	gid_t egid;
a818 13
				if (getpeereid(sock, &euid, &egid) < 0) {
					error("getpeereid %d failed: %s",
					    sock, strerror(errno));
					close(sock);
					break;
				}
				if ((euid != 0) && (getuid() != euid)) {
					error("uid mismatch: "
					    "peer euid %u != uid %u",
					    (u_int) euid, (u_int) getuid());
					close(sock);
					break;
				}
d835 7
a841 1
					close_socket(&sockets[i]);
d855 7
a861 1
					close_socket(&sockets[i]);
a932 1
	extern char *optarg;
a935 4
	/* drop */
	setegid(getgid());
	setgid(getgid());

d1032 1
a1032 1
	if (listen(sock, 128) < 0) {
@


1.85.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.108 2003/03/13 11:44:50 markus Exp $");
a52 2
#include "readpass.h"
#include "misc.h"
a79 1
	u_int confirm;
a104 3
/* Default lifetime (0 == forever) */
static int lifetime = 0;

a157 24
/* Check confirmation of keysign request */
static int
confirm_key(Identity *id)
{
	char *p, prompt[1024];
	int ret = -1;

	p = key_fingerprint(id->key, SSH_FP_MD5, SSH_FP_HEX);
	snprintf(prompt, sizeof(prompt), "Allow use of key %s?\n"
	    "Key fingerprint %s.", id->comment, p);
	xfree(p);
	p = read_passphrase(prompt, RP_ALLOW_EOF);
	if (p != NULL) {
		/*
		 * Accept empty responses and responses consisting 
		 * of the word "yes" as affirmative.
		 */
		if (*p == '\0' || *p == '\n' || strcasecmp(p, "yes") == 0)
			ret = 0;
		xfree(p);
	}
	return (ret);
}

d221 1
a221 1
	if (id != NULL && (!id->confirm || confirm_key(id) == 0)) {
d281 1
a281 1
		if (id != NULL && (!id->confirm || confirm_key(id) == 0))
d401 1
a401 1
	int type, success = 0, death = 0, confirm = 0;
a451 11
	/* enable blinding */
	switch (k->type) {
	case KEY_RSA:
	case KEY_RSA1:
		if (RSA_blinding_on(k->rsa, NULL) != 1) {
			error("process_add_identity: RSA_blinding_on failed");
			key_free(k);
			goto send;
		}
		break;
	}
a462 3
		case SSH_AGENT_CONSTRAIN_CONFIRM:
			confirm = 1;
			break;
a466 2
	if (lifetime && !death)
		death = time(NULL) + lifetime;
a471 1
		id->confirm = confirm;
a555 1
			id->confirm = 0;
a928 1
	fprintf(stderr, "  -t life     Default identity lifetime (seconds).\n");
d935 1
a935 2
	int c_flag = 0, d_flag = 0, k_flag = 0, s_flag = 0;
	int sock, fd,  ch, nalloc;
d951 1
a951 1
	while ((ch = getopt(ac, av, "cdksa:t:")) != -1) {
a973 6
		case 't':
			if ((lifetime = convtime(optarg)) == -1) {
				fprintf(stderr, "Invalid lifetime\n");
				usage();
			}
			break;
d1097 3
a1099 8
	if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
		/* XXX might close listen socket */
		(void)dup2(fd, STDIN_FILENO);
		(void)dup2(fd, STDOUT_FILENO);
		(void)dup2(fd, STDERR_FILENO);
		if (fd > 2)
			close(fd);
	}
@


1.84
log
@change sc_get_key to sc_get_keys and hide smartcard details in scard.c
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.83 2002/03/21 22:44:05 rees Exp $");
d848 1
a848 1
	if (ac == 0 && !c_flag && !k_flag && !s_flag && !d_flag) {
@


1.83
log
@Add PIN-protection for secret key.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.82 2002/03/04 17:27:39 stevesk Exp $");
a54 1
#include <openssl/engine.h>
d445 1
d447 1
a447 1
	Key *n = NULL, *k = NULL;
d449 1
a449 1
	int success = 0;
d453 1
a453 1
	k = sc_get_key(sc_reader_id, pin);
d457 2
a458 2
	if (k == NULL) {
		error("sc_get_pubkey failed");
d461 15
a475 27
	success = 1;

	tab = idtab_lookup(1);
	k->type = KEY_RSA1;
	if (lookup_identity(k, 1) == NULL) {
		Identity *id = xmalloc(sizeof(Identity));
		n = key_new(KEY_RSA1);
		BN_copy(n->rsa->n, k->rsa->n);
		BN_copy(n->rsa->e, k->rsa->e);
		RSA_set_method(n->rsa, sc_get_engine());
		id->key = n;
		id->comment = xstrdup("rsa1 smartcard");
		TAILQ_INSERT_TAIL(&tab->idlist, id, next);
		tab->nentries++;
	}
	k->type = KEY_RSA;
	tab = idtab_lookup(2);
	if (lookup_identity(k, 2) == NULL) {
		Identity *id = xmalloc(sizeof(Identity));
		n = key_new(KEY_RSA);
		BN_copy(n->rsa->n, k->rsa->n);
		BN_copy(n->rsa->e, k->rsa->e);
		RSA_set_method(n->rsa, sc_get_engine());
		id->key = n;
		id->comment = xstrdup("rsa smartcard");
		TAILQ_INSERT_TAIL(&tab->idlist, id, next);
		tab->nentries++;
d477 1
a477 1
	key_free(k);
d487 3
a489 2
	Key *k = NULL;
	int success = 0;
d491 1
d495 1
a495 1
	k = sc_get_key(sc_reader_id, pin);
d499 10
a508 10
	if (k == NULL) {
		error("sc_get_pubkey failed");
	} else {
		Identity *id;
		k->type = KEY_RSA1;
		id = lookup_identity(k, 1);
		if (id != NULL) {
			Idtab *tab = idtab_lookup(1);
			TAILQ_REMOVE(&tab->idlist, id, next);
			free_identity(id);
a509 7
			success = 1;
		}
		k->type = KEY_RSA;
		id = lookup_identity(k, 2);
		if (id != NULL) {
			Idtab *tab = idtab_lookup(2);
			TAILQ_REMOVE(&tab->idlist, id, next);
a510 1
			tab->nentries--;
d514 1
d516 2
a517 1

@


1.82
log
@$OpenBSD$ and RCSID() cleanup: don't use RCSID() in .h files; add
missing RCSID() to .c files and remove dup /*$OpenBSD$*/ from .c
files.  ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.81 2002/02/05 15:50:12 stevesk Exp $");
d448 1
a448 1
	char *sc_reader_id = NULL;
d452 2
a453 1
	k = sc_get_key(sc_reader_id);
d455 1
d501 1
a501 1
	char *sc_reader_id = NULL;
d504 2
a505 1
	k = sc_get_key(sc_reader_id);
d507 1
@


1.81
log
@use log interface and remove perror() in child.  use
fatal_add_cleanup() vs. atexit().  ok mouring@@ markus@@
@
text
@a0 2
/*	$OpenBSD: ssh-agent.c,v 1.80 2002/02/04 00:53:39 stevesk Exp $	*/

d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.80 2002/02/04 00:53:39 stevesk Exp $");
@


1.80
log
@unneeded includes
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.79 2002/01/18 18:14:17 stevesk Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.79 2002/01/18 18:14:17 stevesk Exp $");
d715 2
a716 1
					perror("accept from AUTH_SOCKET");
d770 1
a770 1
cleanup_socket(void)
d781 1
a781 1
	cleanup_socket();
d788 1
a788 1
	cleanup_socket();
d937 1
a937 1
		exit(1);
d960 2
d964 1
a964 1
		perror("setsid");
d976 1
a976 1
		perror("setrlimit rlimit_core failed");
d981 1
a981 4
	if (atexit(cleanup_socket) < 0) {
		perror("atexit");
		cleanup_exit(1);
	}
d1000 1
a1000 1
			exit(1);
@


1.79
log
@unneeded cast cleanup; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.78 2002/01/13 17:27:07 provos Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.78 2002/01/13 17:27:07 provos Exp $");
a49 1
#include "packet.h"
a50 1
#include "mpaux.h"
a52 2
#include "cipher.h"
#include "kex.h"
@


1.78
log
@change to use queue.h macros; okay markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.77 2001/12/29 21:56:01 stevesk Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.77 2001/12/29 21:56:01 stevesk Exp $");
d204 1
a204 1
	buffer_get(&e->input, (char *) session_id, 16);
@


1.77
log
@remove unneeded casts and some char->u_char cleanup; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.76 2001/12/27 18:22:16 markus Exp $	*/
d39 2
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.76 2001/12/27 18:22:16 markus Exp $");
d81 2
a82 1
typedef struct {
d89 1
a89 1
	Identity *identities;
d111 1
a111 1
		idtable[i].identities = NULL;
d126 2
a127 2
static Key *
lookup_private_key(Key *key, int *idx, int version)
d129 2
a130 1
	int i;
d132 3
a134 6
	for (i = 0; i < tab->nentries; i++) {
		if (key_equal(key, tab->identities[i].key)) {
			if (idx != NULL)
				*idx = i;
			return tab->identities[i].key;
		}
d136 9
a144 1
	return NULL;
d153 1
a153 1
	int i;
d159 1
a159 2
	for (i = 0; i < tab->nentries; i++) {
		Identity *id = &tab->identities[i];
d182 2
a183 1
	Key *key, *private;
d209 3
a211 2
	private = lookup_private_key(key, NULL, 1);
	if (private != NULL) {
d252 1
a252 1
	Key *key, *private;
d270 3
a272 3
		private = lookup_private_key(key, NULL, 2);
		if (private != NULL)
			ok = key_sign(private, &signature, &slen, data, dlen);
d296 1
a296 1
	Key *key = NULL, *private;
d320 2
a321 3
		int idx;
		private = lookup_private_key(key, &idx, version);
		if (private != NULL) {
a329 2
			key_free(tab->identities[idx].key);
			xfree(tab->identities[idx].comment);
d334 2
a335 7
			if (idx != tab->nentries - 1) {
				int i;
				for (i = idx; i < tab->nentries - 1; i++)
					tab->identities[i] = tab->identities[i+1];
			}
			tab->identities[tab->nentries - 1].key = NULL;
			tab->identities[tab->nentries - 1].comment = NULL;
a348 1
	u_int i;
d350 1
d353 4
a356 3
	for (i = 0; i < tab->nentries; i++) {
		key_free(tab->identities[i].key);
		xfree(tab->identities[i].comment);
d430 5
a434 8
	if (lookup_private_key(k, NULL, version) == NULL) {
		if (tab->nentries == 0)
			tab->identities = xmalloc(sizeof(Identity));
		else
			tab->identities = xrealloc(tab->identities,
			    (tab->nentries + 1) * sizeof(Identity));
		tab->identities[tab->nentries].key = k;
		tab->identities[tab->nentries].comment = comment;
d469 2
a470 6
	if (lookup_private_key(k, NULL, 1) == NULL) {
		if (tab->nentries == 0)
			tab->identities = xmalloc(sizeof(Identity));
		else
			tab->identities = xrealloc(tab->identities,
			    (tab->nentries + 1) * sizeof(Identity));
d475 3
a477 3
		tab->identities[tab->nentries].key = n;
		tab->identities[tab->nentries].comment =
		    xstrdup("rsa1 smartcard");
d482 2
a483 6
	if (lookup_private_key(k, NULL, 2) == NULL) {
		if (tab->nentries == 0)
			tab->identities = xmalloc(sizeof(Identity));
		else
			tab->identities = xrealloc(tab->identities,
			    (tab->nentries + 1) * sizeof(Identity));
d488 3
a490 3
		tab->identities[tab->nentries].key = n;
		tab->identities[tab->nentries].comment =
		    xstrdup("rsa smartcard");
d503 1
a503 2
	Key *k = NULL, *private;
	int idx;
d514 1
d516 2
a517 2
		private = lookup_private_key(k, &idx, 1);
		if (private != NULL) {
d519 2
a520 4
			key_free(tab->identities[idx].key);
			xfree(tab->identities[idx].comment);
			if (idx != tab->nentries)
				tab->identities[idx] = tab->identities[tab->nentries];
d525 2
a526 2
		private = lookup_private_key(k, &idx, 2);
		if (private != NULL) {
d528 2
a529 4
			key_free(tab->identities[idx].key);
			xfree(tab->identities[idx].comment);
			if (idx != tab->nentries)
				tab->identities[idx] = tab->identities[tab->nentries];
@


1.76
log
@call fatal() for openssl allocation failures
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.75 2001/12/19 07:18:56 deraadt Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.75 2001/12/19 07:18:56 deraadt Exp $");
d565 1
a565 1
	cp = (u_char *) buffer_ptr(&e->input);
@


1.75
log
@basic KNF done while i was looking for something else
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.74 2001/12/05 10:06:12 deraadt Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.74 2001/12/05 10:06:12 deraadt Exp $");
d185 2
a186 1
	challenge = BN_new();
@


1.74
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.73 2001/11/17 19:14:34 stevesk Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.73 2001/11/17 19:14:34 stevesk Exp $");
d456 1
a456 1
	
d614 1
a614 1
		break; 
d617 1
a617 1
		break; 
@


1.73
log
@enum/int type cleanup where it made sense to do so; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.72 2001/08/03 10:31:30 jakob Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.72 2001/08/03 10:31:30 jakob Exp $");
d108 1
a108 1
	for (i = 0; i <=2; i++){
d292 1
a292 1
	switch(version){
d394 1
a394 1
		switch(type) {
@


1.72
log
@improve usage(). ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.71 2001/08/02 16:14:05 jakob Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.71 2001/08/02 16:14:05 jakob Exp $");
d64 6
d72 1
a72 3
	enum {
		AUTH_UNUSED, AUTH_SOCKET, AUTH_CONNECTION
	} type;
d630 1
a630 1
new_socket(int type, int fd)
@


1.72.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d1 2
d39 1
a39 2
#include <sys/queue.h>
RCSID("$OpenBSD: ssh-agent.c,v 1.82 2002/03/04 17:27:39 stevesk Exp $");
d49 1
d51 1
d54 2
a63 6
typedef enum {
	AUTH_UNUSED,
	AUTH_SOCKET,
	AUTH_CONNECTION
} sock_type;

d66 3
a68 1
	sock_type type;
d76 1
a76 2
typedef struct identity {
	TAILQ_ENTRY(identity) next;
d83 1
a83 1
	TAILQ_HEAD(idqueue, identity) idlist;
d104 2
a105 2
	for (i = 0; i <=2; i++) {
		TAILQ_INIT(&idtable[i].idlist);
d120 2
a121 2
static Identity *
lookup_identity(Key *key, int version)
d123 1
a123 2
	Identity *id;

d125 6
a130 3
	TAILQ_FOREACH(id, &tab->idlist, next) {
		if (key_equal(key, id->key))
			return (id);
d132 1
a132 9
	return (NULL);
}

static void
free_identity(Identity *id)
{
	key_free(id->key);
	xfree(id->comment);
	xfree(id);
d141 1
a141 1
	Identity *id;
d147 2
a148 1
	TAILQ_FOREACH(id, &tab->idlist, next) {
d171 1
a171 2
	Identity *id;
	Key *key;
d181 1
a181 2
	if ((challenge = BN_new()) == NULL)
		fatal("process_authentication_challenge1: BN_new failed");
d191 1
a191 1
	buffer_get(&e->input, session_id, 16);
d196 2
a197 3
	id = lookup_identity(key, 1);
	if (id != NULL) {
		Key *private = id->key;
d238 1
a238 1
	Key *key;
d256 3
a258 3
		Identity *id = lookup_identity(key, 2);
		if (id != NULL)
			ok = key_sign(id->key, &signature, &slen, data, dlen);
d282 1
a282 1
	Key *key = NULL;
d288 1
a288 1
	switch (version) {
d306 3
a308 2
		Identity *id = lookup_identity(key, version);
		if (id != NULL) {
d317 2
d323 7
a329 2
			TAILQ_REMOVE(&tab->idlist, id, next);
			free_identity(id);
d343 1
a344 1
	Identity *id;
d347 3
a349 4
	for (id = TAILQ_FIRST(&tab->idlist); id;
	    id = TAILQ_FIRST(&tab->idlist)) {
		TAILQ_REMOVE(&tab->idlist, id, next);
		free_identity(id);
d390 1
a390 1
		switch (type) {
d423 8
a430 5
	if (lookup_identity(k, version) == NULL) {
		Identity *id = xmalloc(sizeof(Identity));
		id->key = k;
		id->comment = comment;
		TAILQ_INSERT_TAIL(&tab->idlist, id, next);
d452 1
a452 1

d465 6
a470 2
	if (lookup_identity(k, 1) == NULL) {
		Identity *id = xmalloc(sizeof(Identity));
d475 3
a477 3
		id->key = n;
		id->comment = xstrdup("rsa1 smartcard");
		TAILQ_INSERT_TAIL(&tab->idlist, id, next);
d482 6
a487 2
	if (lookup_identity(k, 2) == NULL) {
		Identity *id = xmalloc(sizeof(Identity));
d492 3
a494 3
		id->key = n;
		id->comment = xstrdup("rsa smartcard");
		TAILQ_INSERT_TAIL(&tab->idlist, id, next);
d507 2
a508 1
	Key *k = NULL;
a518 1
		Identity *id;
d520 2
a521 2
		id = lookup_identity(k, 1);
		if (id != NULL) {
d523 4
a526 2
			TAILQ_REMOVE(&tab->idlist, id, next);
			free_identity(id);
d531 2
a532 2
		id = lookup_identity(k, 2);
		if (id != NULL) {
d534 4
a537 2
			TAILQ_REMOVE(&tab->idlist, id, next);
			free_identity(id);
d560 1
a560 1
	cp = buffer_ptr(&e->input);
d610 1
a610 1
		break;
d613 1
a613 1
		break;
d626 1
a626 1
new_socket(sock_type type, int fd)
d727 1
a727 2
					error("accept from AUTH_SOCKET: %s",
					    strerror(errno));
d781 1
a781 1
cleanup_socket(void *p)
d792 1
a792 1
	cleanup_socket(NULL);
d799 1
a799 1
	cleanup_socket(NULL);
d948 1
a948 1
		cleanup_exit(1);
a970 2
	/* child */
	log_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);
d973 1
a973 1
		error("setsid: %s", strerror(errno));
d985 1
a985 1
		error("setrlimit RLIMIT_CORE: %s", strerror(errno));
d990 4
a993 1
	fatal_add_cleanup(cleanup_socket, NULL);
d1012 1
a1012 1
			fatal("select: %s", strerror(errno));
@


1.72.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.85 2002/04/02 11:49:39 markus Exp $");
d55 1
a445 1
	Identity *id;
d447 3
a449 3
	Key **keys, *k;
	char *sc_reader_id = NULL, *pin;
	int i, version, success = 0;
d452 1
a452 2
	pin = buffer_get_string(&e->input, NULL);
	keys = sc_get_keys(sc_reader_id, pin);
a453 1
	xfree(pin);
d455 2
a456 2
	if (keys == NULL || keys[0] == NULL) {
		error("sc_get_keys failed");
d459 27
a485 15
	for (i = 0; keys[i] != NULL; i++) {
		k = keys[i];
		version = k->type == KEY_RSA1 ? 1 : 2;
		tab = idtab_lookup(version);
		if (lookup_identity(k, version) == NULL) {
			id = xmalloc(sizeof(Identity));
			id->key = k;
			id->comment = xstrdup("smartcard key");
			TAILQ_INSERT_TAIL(&tab->idlist, id, next);
			tab->nentries++;
			success = 1;
		} else {
			key_free(k);
		}
		keys[i] = NULL;
d487 1
a487 1
	xfree(keys);
d497 3
a499 5
	Identity *id;
	Idtab *tab;
	Key **keys, *k = NULL;
	char *sc_reader_id = NULL, *pin;
	int i, version, success = 0;
d502 1
a502 2
	pin = buffer_get_string(&e->input, NULL);
	keys = sc_get_keys(sc_reader_id, pin);
a503 1
	xfree(pin);
d505 10
a514 10
	if (keys == NULL || keys[0] == NULL) {
		error("sc_get_keys failed");
		goto send;
	}
	for (i = 0; keys[i] != NULL; i++) {
		k = keys[i];
		version = k->type == KEY_RSA1 ? 1 : 2;
		if ((id = lookup_identity(k, version)) != NULL) {
			tab = idtab_lookup(version);
                        TAILQ_REMOVE(&tab->idlist, id, next);
d516 7
d524 1
a527 1
		keys[i] = NULL;
d529 1
a529 2
	xfree(keys);
send:
d860 1
a860 1
	if (ac == 0 && !c_flag && !s_flag) {
@


1.72.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.72.2.2 2002/05/17 00:03:24 miod Exp $");
a68 1
	Buffer request;
a77 1
	u_int death;
a96 4
/* locking */
int locked = 0;
char *lock_passwd = NULL;

a117 8
static void
free_identity(Identity *id)
{
	key_free(id->key);
	xfree(id->comment);
	xfree(id);
}

d132 8
d189 4
a192 4
	buffer_get_int(&e->request);				/* ignored */
	buffer_get_bignum(&e->request, key->rsa->e);
	buffer_get_bignum(&e->request, key->rsa->n);
	buffer_get_bignum(&e->request, challenge);
d195 1
a195 1
	if (buffer_len(&e->request) == 0)
d197 2
a198 2
	buffer_get(&e->request, session_id, 16);
	response_type = buffer_get_int(&e->request);
d254 2
a255 2
	blob = buffer_get_string(&e->request, &blen);
	data = buffer_get_string(&e->request, &dlen);
d257 1
a257 1
	flags = buffer_get_int(&e->request);
d298 3
a300 3
		bits = buffer_get_int(&e->request);
		buffer_get_bignum(&e->request, key->rsa->e);
		buffer_get_bignum(&e->request, key->rsa->n);
d307 1
a307 1
		blob = buffer_get_string(&e->request, &blen);
d358 1
a358 21
}

static void
reaper(void)
{
	Idtab *tab;
	Identity *id, *nxt;
	int version;
	u_int now = time(NULL);

	for (version = 1; version < 3; version++) {
		tab = idtab_lookup(version);
		for (id = TAILQ_FIRST(&tab->idlist); id; id = nxt) {
			nxt = TAILQ_NEXT(id, next);
			if (id->death != 0 && now >= id->death) {
				TAILQ_REMOVE(&tab->idlist, id, next);
				free_identity(id);
				tab->nentries--;
			}
		}
	}
d367 1
a367 1
	int type, success = 0, death = 0;
d373 5
a377 5
		buffer_get_int(&e->request);			/* ignored */
		buffer_get_bignum(&e->request, k->rsa->n);
		buffer_get_bignum(&e->request, k->rsa->e);
		buffer_get_bignum(&e->request, k->rsa->d);
		buffer_get_bignum(&e->request, k->rsa->iqmp);
d380 2
a381 2
		buffer_get_bignum(&e->request, k->rsa->q);	/* p */
		buffer_get_bignum(&e->request, k->rsa->p);	/* q */
d387 1
a387 1
		type_name = buffer_get_string(&e->request, NULL);
d393 5
a397 5
			buffer_get_bignum2(&e->request, k->dsa->p);
			buffer_get_bignum2(&e->request, k->dsa->q);
			buffer_get_bignum2(&e->request, k->dsa->g);
			buffer_get_bignum2(&e->request, k->dsa->pub_key);
			buffer_get_bignum2(&e->request, k->dsa->priv_key);
d401 6
a406 6
			buffer_get_bignum2(&e->request, k->rsa->n);
			buffer_get_bignum2(&e->request, k->rsa->e);
			buffer_get_bignum2(&e->request, k->rsa->d);
			buffer_get_bignum2(&e->request, k->rsa->iqmp);
			buffer_get_bignum2(&e->request, k->rsa->p);
			buffer_get_bignum2(&e->request, k->rsa->q);
d412 1
a412 1
			buffer_clear(&e->request);
d417 1
a417 1
	comment = buffer_get_string(&e->request, NULL);
a422 9
	while (buffer_len(&e->request)) {
		switch (buffer_get_char(&e->request)) {
		case SSH_AGENT_CONSTRAIN_LIFETIME:
			death = time(NULL) + buffer_get_int(&e->request);
			break;
		default:
			break;
		}
	}
a426 1
		id->death = death;
a439 41
/* XXX todo: encrypt sensitive data with passphrase */
static void
process_lock_agent(SocketEntry *e, int lock)
{
	char *passwd;
	int success = 0;

	passwd = buffer_get_string(&e->request, NULL);
	if (locked && !lock && strcmp(passwd, lock_passwd) == 0) {
		locked = 0;
		memset(lock_passwd, 0, strlen(lock_passwd));
		xfree(lock_passwd);
		lock_passwd = NULL;
		success = 1;
	} else if (!locked && lock) {
		locked = 1;
		lock_passwd = xstrdup(passwd);
		success = 1;
	}
	memset(passwd, 0, strlen(passwd));
	xfree(passwd);

	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
}

static void
no_identities(SocketEntry *e, u_int type)
{
	Buffer msg;

	buffer_init(&msg);
	buffer_put_char(&msg,
	    (type == SSH_AGENTC_REQUEST_RSA_IDENTITIES) ?
	    SSH_AGENT_RSA_IDENTITIES_ANSWER : SSH2_AGENT_IDENTITIES_ANSWER);
	buffer_put_int(&msg, 0);
	buffer_put_int(&e->output, buffer_len(&msg));
	buffer_append(&e->output, buffer_ptr(&msg), buffer_len(&msg));
	buffer_free(&msg);
}
d451 2
a452 2
	sc_reader_id = buffer_get_string(&e->request, NULL);
	pin = buffer_get_string(&e->request, NULL);
a468 1
			id->death = 0;
d493 2
a494 2
	sc_reader_id = buffer_get_string(&e->request, NULL);
	pin = buffer_get_string(&e->request, NULL);
d508 1
a508 1
			TAILQ_REMOVE(&tab->idlist, id, next);
a531 4

	/* kill dead keys */
	reaper();

a539 3
		buffer_free(&e->input);
		buffer_free(&e->output);
		buffer_free(&e->request);
a543 2

	/* move the current input to e->request */
d545 1
a545 21
	buffer_clear(&e->request);
	buffer_append(&e->request, buffer_ptr(&e->input), msg_len);
	buffer_consume(&e->input, msg_len);
	type = buffer_get_char(&e->request);

	/* check wheter agent is locked */
	if (locked && type != SSH_AGENTC_UNLOCK) {
		buffer_clear(&e->request);
		switch (type) {
		case SSH_AGENTC_REQUEST_RSA_IDENTITIES:
		case SSH2_AGENTC_REQUEST_IDENTITIES:
			/* send empty lists */
			no_identities(e, type);
			break;
		default:
			/* send a fail message for all other request types */
			buffer_put_int(&e->output, 1);
			buffer_put_char(&e->output, SSH_AGENT_FAILURE);
		}
		return;
	}
a548 4
	case SSH_AGENTC_LOCK:
	case SSH_AGENTC_UNLOCK:
		process_lock_agent(e, type == SSH_AGENTC_LOCK);
		break;
a556 1
	case SSH_AGENTC_ADD_RSA_ID_CONSTRAINED:
a572 1
	case SSH2_AGENTC_ADD_ID_CONSTRAINED:
d592 1
a592 1
		buffer_clear(&e->request);
a614 1
			buffer_init(&sockets[i].request);
a628 1
	buffer_init(&sockets[old_alloc].request);
a725 1
					buffer_free(&sockets[i].request);
a743 1
					buffer_free(&sockets[i].request);
a801 1
	fprintf(stderr, "  -a socket   Bind agent socket to given name.\n");
a812 1
	char *agentsocket = NULL;
d818 1
a818 1
	while ((ch = getopt(ac, av, "cdksa:")) != -1) {
a837 3
		case 'a':
			agentsocket = optarg;
			break;
d873 1
a873 1
		printf("echo Agent pid %ld killed;\n", (long)pid);
d878 5
a882 13
	if (agentsocket == NULL) {
		/* Create private directory for agent socket */
		strlcpy(socket_dir, "/tmp/ssh-XXXXXXXX", sizeof socket_dir);
		if (mkdtemp(socket_dir) == NULL) {
			perror("mkdtemp: private socket dir");
			exit(1);
		}
		snprintf(socket_name, sizeof socket_name, "%s/agent.%ld", socket_dir,
		    (long)parent_pid);
	} else {
		/* Try to use specified agent socket */
		socket_dir[0] = '\0';
		strlcpy(socket_name, agentsocket, sizeof socket_name);
d884 2
d917 1
a917 1
		printf("echo Agent pid %ld;\n", (long)parent_pid);
d927 1
a927 1
		snprintf(pidstrbuf, sizeof pidstrbuf, "%ld", (long)pid);
d934 1
a934 1
			printf("echo Agent pid %ld;\n", (long)pid);
@


1.72.2.4
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.72.2.3 2002/06/22 07:23:18 miod Exp $");
a108 1

d151 1
a152 1
	Buffer msg;
d181 2
a182 2
	u_char buf[32], mdbuf[16], session_id[16];
	u_int response_type;
a183 1
	Identity *id;
d187 2
a188 1
	Key *key;
d195 1
a195 1
	(void) buffer_get_int(&e->request);			/* ignored */
d250 2
d254 1
a254 2
	extern int datafellows;
	int ok = -1, flags;
d256 1
a256 1
	Key *key;
a294 2
	u_int blen, bits;
	int success = 0;
d297 3
d309 1
a309 1
			log("Warning: identity keysize mismatch: actual %u, announced %u",
d369 1
a369 1
	u_int now = time(NULL);
d372 1
a372 1
	Idtab *tab;
d390 4
a394 3
	int type, success = 0, death = 0;
	char *type_name, *comment;
	Key *k = NULL;
d399 1
a399 1
		(void) buffer_get_int(&e->request);		/* ignored */
d480 1
a481 1
	char *passwd;
d522 3
a526 3
	Key **keys, *k;
	Identity *id;
	Idtab *tab;
d565 3
a569 3
	Key **keys, *k = NULL;
	Identity *id;
	Idtab *tab;
d607 2
a608 1
	u_int msg_len, type;
a620 1
		e->fd = -1;
a715 1

d800 2
a801 1
	struct sockaddr_un sunaddr;
d804 1
a804 2
	int len, sock;
	u_int i;
a837 1
					sockets[i].fd = -1;
a856 1
					sockets[i].fd = -1;
a926 2
	char *shell, *format, *pidstr, *agentsocket = NULL;
	fd_set *readsetp = NULL, *writesetp = NULL;
d929 3
d933 1
a933 2
	pid_t pid;
	char pidstrbuf[1 + 3 * sizeof pid];
@


1.72.2.5
log
@Update to OpenSSH 3.5
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.105 2002/10/01 20:34:12 markus Exp $");
a105 11
close_socket(SocketEntry *e)
{
	close(e->fd);
	e->fd = -1;
	e->type = AUTH_UNUSED;
	buffer_free(&e->input);
	buffer_free(&e->output);
	buffer_free(&e->request);
}

static void
d616 7
a622 1
		close_socket(e);
a803 2
	uid_t euid;
	gid_t egid;
a818 13
				if (getpeereid(sock, &euid, &egid) < 0) {
					error("getpeereid %d failed: %s",
					    sock, strerror(errno));
					close(sock);
					break;
				}
				if ((euid != 0) && (getuid() != euid)) {
					error("uid mismatch: "
					    "peer euid %u != uid %u",
					    (u_int) euid, (u_int) getuid());
					close(sock);
					break;
				}
d835 7
a841 1
					close_socket(&sockets[i]);
d855 7
a861 1
					close_socket(&sockets[i]);
a932 1
	extern char *optarg;
a935 4
	/* drop */
	setegid(getgid());
	setgid(getgid());

d1032 1
a1032 1
	if (listen(sock, 128) < 0) {
@


1.71
log
@clean up some /* SMARTCARD */. ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.70 2001/08/02 15:43:57 jakob Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.70 2001/08/02 15:43:57 jakob Exp $");
d820 1
a820 2
	fprintf(stderr, "ssh-agent version %s\n", SSH_VERSION);
	fprintf(stderr, "Usage: %s [-c | -s] [-k] [-d] [command [args...]]\n",
d822 5
@


1.70
log
@add /* SMARTCARD */ to #else/#endif. ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.69 2001/08/01 22:03:33 markus Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.69 2001/08/01 22:03:33 markus Exp $");
d62 1
a62 1
#endif /* SMARTCARD */
@


1.69
log
@use strings instead of ints for smartcard reader ids
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.68 2001/07/20 14:46:11 markus Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.68 2001/07/20 14:46:11 markus Exp $");
d62 1
a62 1
#endif
d548 1
a548 1
#endif
d614 1
a614 1
#endif
@


1.68
log
@do not exit() from signal handlers; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.67 2001/07/18 21:40:40 stevesk Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.67 2001/07/18 21:40:40 stevesk Exp $");
d450 1
a451 1
	int sc_reader_num = 0;
d453 3
a455 1
	sc_reader_num = buffer_get_int(&e->input);
a456 1
	k = sc_get_key(sc_reader_num);
d510 1
a510 1
	int sc_reader_num = 0;
d512 3
a514 1
	sc_reader_num = buffer_get_int(&e->input);
d516 1
a516 1
	if ((k = sc_get_key(sc_reader_num)) == NULL) {
@


1.67
log
@chdir("/") from bbraun@@synack.net; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.66 2001/07/17 20:48:42 markus Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.66 2001/07/17 20:48:42 markus Exp $");
a777 14
check_parent_exists(int sig)
{
	int save_errno = errno;

	if (parent_pid != -1 && kill(parent_pid, 0) < 0) {
		/* printf("Parent has died - Authentication agent exiting.\n"); */
		exit(1);
	}
	signal(SIGALRM, check_parent_exists);
	alarm(10);
	errno = save_errno;
}

static void
d798 14
@


1.66
log
@update maxfd if maxfd is closed; report from jmcelroy@@dtgnet.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.65 2001/07/15 16:58:29 stevesk Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.65 2001/07/15 16:58:29 stevesk Exp $");
d964 7
a978 4
		cleanup_exit(1);
	}
	if (setsid() == -1) {
		perror("setsid");
@


1.65
log
@typo in usage; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.64 2001/07/04 23:49:27 markus Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.64 2001/07/04 23:49:27 markus Exp $");
d655 1
a655 1
prepare_select(fd_set **fdrp, fd_set **fdwp, int *fdl)
d675 1
a675 1
	if (*fdrp == NULL || n > *fdl) {
d682 1
a682 1
		*fdl = n;
d684 3
d826 1
a826 1
	int sock, c_flag = 0, d_flag = 0, k_flag = 0, s_flag = 0, ch;
d995 2
d998 1
a998 1
		prepare_select(&readsetp, &writesetp, &max_fd);
@


1.64
log
@handle mutiple adds of the same smartcard key
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.63 2001/07/04 23:39:07 markus Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.63 2001/07/04 23:39:07 markus Exp $");
d815 1
a815 1
	fprintf(stderr, "Usage: %s [-c | -s] [-k] [-d] [command {args...]]\n",
@


1.63
log
@for smartcards remove both RSA1/2 keys
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.62 2001/07/04 23:13:10 markus Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.62 2001/07/04 23:13:10 markus Exp $");
d463 1
d479 1
@


1.62
log
@handle card removal more gracefully, add sc_close() to scard.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.61 2001/07/04 22:47:19 markus Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.61 2001/07/04 22:47:19 markus Exp $");
d514 1
d525 1
a536 1
		sc_close();
@


1.61
log
@ignore SIGPIPE when debugging, too
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.60 2001/06/27 05:42:25 markus Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.60 2001/06/27 05:42:25 markus Exp $");
d535 1
@


1.60
log
@s/generate_additional_parameters/rsa_generate_additional_parameters/
http://www.humppa.com/
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.59 2001/06/26 05:33:34 markus Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.59 2001/06/26 05:33:34 markus Exp $");
d983 1
a983 1
	if (!d_flag) {
d985 1
a985 2
		signal(SIGPIPE, SIG_IGN);
	}
@


1.59
log
@more smartcard support.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.58 2001/06/26 05:07:43 markus Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.58 2001/06/26 05:07:43 markus Exp $");
d384 1
a384 1
		generate_additional_parameters(k->rsa);
d409 1
a409 1
			generate_additional_parameters(k->rsa);
@


1.58
log
@update usage
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.57 2001/06/26 04:07:06 markus Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.57 2001/06/26 04:07:06 markus Exp $");
d59 5
d443 100
d566 1
d600 8
@


1.57
log
@add debug flag
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.56 2001/06/25 08:25:40 markus Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.56 2001/06/25 08:25:40 markus Exp $");
d697 1
a697 1
	fprintf(stderr, "Usage: %s [-c | -s] [-k] [command {args...]]\n",
@


1.56
log
@update copyright for 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.55 2001/06/23 15:12:20 itojun Exp $	*/
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.55 2001/06/23 15:12:20 itojun Exp $");
d705 1
a705 1
	int sock, c_flag = 0, k_flag = 0, s_flag = 0, ch;
d715 1
a715 1
	while ((ch = getopt(ac, av, "cks")) != -1) {
d730 5
d742 1
a742 1
	if (ac > 0 && (c_flag || k_flag || s_flag))
d745 1
a745 1
	if (ac == 0 && !c_flag && !k_flag && !s_flag) {
d809 8
d857 2
d869 4
a872 2
	signal(SIGINT, SIG_IGN);
	signal(SIGPIPE, SIG_IGN);
@


1.55
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.54 2001/04/03 13:56:11 stevesk Exp $	*/
d15 1
a15 2
 * SSH2 implementation,
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d39 1
a39 1
RCSID("$OpenBSD: ssh-agent.c,v 1.54 2001/04/03 13:56:11 stevesk Exp $");
@


1.54
log
@free() -> xfree()
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.53 2001/03/26 23:23:24 markus Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.53 2001/03/26 23:23:24 markus Exp $");
d96 1
a96 3
int	prepare_select(fd_set **, fd_set **, int *);

void
d107 1
a107 1
Idtab *
d116 1
a116 1
Key *
d132 1
a132 1
void
d164 1
a164 1
void
d230 1
a230 1
void
d275 1
a275 1
void
d336 1
a336 1
void
d357 1
a357 1
void
d441 1
a441 1
void
d505 1
a505 1
void
d537 1
a537 1
int
d585 1
a585 1
void
d657 1
a657 1
void
d671 1
a671 1
void
d680 1
a680 1
void
d687 1
a687 1
void
d694 1
a694 1
void
@


1.54.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.72 2001/08/03 10:31:30 jakob Exp $	*/
d15 2
a16 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.72 2001/08/03 10:31:30 jakob Exp $");
a59 5
#ifdef SMARTCARD
#include <openssl/engine.h>
#include "scard.h"
#endif

d96 3
a98 1
static void
d109 1
a109 1
static Idtab *
d118 1
a118 1
static Key *
d134 1
a134 1
static void
d166 1
a166 1
static void
d232 1
a232 1
static void
d277 1
a277 1
static void
d338 1
a338 1
static void
d359 1
a359 1
static void
d382 1
a382 1
		rsa_generate_additional_parameters(k->rsa);
d407 1
a407 1
			rsa_generate_additional_parameters(k->rsa);
a440 107

#ifdef SMARTCARD
static void
process_add_smartcard_key (SocketEntry *e)
{
	Idtab *tab;
	Key *n = NULL, *k = NULL;
	char *sc_reader_id = NULL;
	int success = 0;
	
	sc_reader_id = buffer_get_string(&e->input, NULL);
	k = sc_get_key(sc_reader_id);
	xfree(sc_reader_id);

	if (k == NULL) {
		error("sc_get_pubkey failed");
		goto send;
	}
	success = 1;

	tab = idtab_lookup(1);
	k->type = KEY_RSA1;
	if (lookup_private_key(k, NULL, 1) == NULL) {
		if (tab->nentries == 0)
			tab->identities = xmalloc(sizeof(Identity));
		else
			tab->identities = xrealloc(tab->identities,
			    (tab->nentries + 1) * sizeof(Identity));
		n = key_new(KEY_RSA1);
		BN_copy(n->rsa->n, k->rsa->n);
		BN_copy(n->rsa->e, k->rsa->e);
		RSA_set_method(n->rsa, sc_get_engine());
		tab->identities[tab->nentries].key = n;
		tab->identities[tab->nentries].comment =
		    xstrdup("rsa1 smartcard");
		tab->nentries++;
	}
	k->type = KEY_RSA;
	tab = idtab_lookup(2);
	if (lookup_private_key(k, NULL, 2) == NULL) {
		if (tab->nentries == 0)
			tab->identities = xmalloc(sizeof(Identity));
		else
			tab->identities = xrealloc(tab->identities,
			    (tab->nentries + 1) * sizeof(Identity));
		n = key_new(KEY_RSA);
		BN_copy(n->rsa->n, k->rsa->n);
		BN_copy(n->rsa->e, k->rsa->e);
		RSA_set_method(n->rsa, sc_get_engine());
		tab->identities[tab->nentries].key = n;
		tab->identities[tab->nentries].comment =
		    xstrdup("rsa smartcard");
		tab->nentries++;
	}
	key_free(k);
send:
	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
}

static void
process_remove_smartcard_key(SocketEntry *e)
{
	Key *k = NULL, *private;
	int idx;
	int success = 0;
	char *sc_reader_id = NULL;

	sc_reader_id = buffer_get_string(&e->input, NULL);
	k = sc_get_key(sc_reader_id);
	xfree(sc_reader_id);

	if (k == NULL) {
		error("sc_get_pubkey failed");
	} else {
		k->type = KEY_RSA1;
		private = lookup_private_key(k, &idx, 1);
		if (private != NULL) {
			Idtab *tab = idtab_lookup(1);
			key_free(tab->identities[idx].key);
			xfree(tab->identities[idx].comment);
			if (idx != tab->nentries)
				tab->identities[idx] = tab->identities[tab->nentries];
			tab->nentries--;
			success = 1;
		}
		k->type = KEY_RSA;
		private = lookup_private_key(k, &idx, 2);
		if (private != NULL) {
			Idtab *tab = idtab_lookup(2);
			key_free(tab->identities[idx].key);
			xfree(tab->identities[idx].comment);
			if (idx != tab->nentries)
				tab->identities[idx] = tab->identities[tab->nentries];
			tab->nentries--;
			success = 1;
		}
		key_free(k);
	}

	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
}
#endif /* SMARTCARD */

d443 1
a443 1
static void
a463 1
	debug("type %d", type);
a496 8
#ifdef SMARTCARD
	case SSH_AGENTC_ADD_SMARTCARD_KEY:
		process_add_smartcard_key(e);
		break; 
	case SSH_AGENTC_REMOVE_SMARTCARD_KEY:
		process_remove_smartcard_key(e);
		break; 
#endif /* SMARTCARD */
d507 1
a507 1
static void
d539 2
a540 2
static int
prepare_select(fd_set **fdrp, fd_set **fdwp, int *fdl, int *nallocp)
d560 1
a560 1
	if (*fdrp == NULL || sz > *nallocp) {
d567 1
a567 1
		*nallocp = sz;
a568 3
	if (n < *fdl)
		debug("XXX shrink: %d < %d", n, *fdl);
	*fdl = n;
d587 1
a587 1
static void
d659 15
a673 1
static void
d682 1
a682 1
static void
d689 1
a689 1
static void
d696 1
a696 15
static void
check_parent_exists(int sig)
{
	int save_errno = errno;

	if (parent_pid != -1 && kill(parent_pid, 0) < 0) {
		/* printf("Parent has died - Authentication agent exiting.\n"); */
		cleanup_handler(sig); /* safe */
	}
	signal(SIGALRM, check_parent_exists);
	alarm(10);
	errno = save_errno;
}

static void
d699 2
a700 1
	fprintf(stderr, "Usage: %s [options] [command [args ...]]\n",
a701 5
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -c          Generate C-shell commands on stdout.\n");
	fprintf(stderr, "  -s          Generate Bourne shell commands on stdout.\n");
	fprintf(stderr, "  -k          Kill the current agent.\n");
	fprintf(stderr, "  -d          Debug mode.\n");
d708 1
a708 1
	int sock, c_flag = 0, d_flag = 0, k_flag = 0, s_flag = 0, ch, nalloc;
d718 1
a718 1
	while ((ch = getopt(ac, av, "cdks")) != -1) {
a732 5
		case 'd':
			if (d_flag)
				usage();
			d_flag++;
			break;
d740 1
a740 1
	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag))
d743 1
a743 1
	if (ac == 0 && !c_flag && !k_flag && !s_flag && !d_flag) {
a806 8
	if (d_flag) {
		log_init(__progname, SYSLOG_LEVEL_DEBUG1, SYSLOG_FACILITY_AUTH, 1);
		format = c_flag ? "setenv %s %s;\n" : "%s=%s; export %s;\n";
		printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
		    SSH_AUTHSOCKET_ENV_NAME);
		printf("echo Agent pid %d;\n", parent_pid);
		goto skip;
	}
a832 7

	if (setsid() == -1) {
		perror("setsid");
		cleanup_exit(1);
	}

	(void)chdir("/");
d843 4
a846 2

skip:
d857 1
a857 2
	if (!d_flag)
		signal(SIGINT, SIG_IGN);
a860 2
	nalloc = 0;

d862 1
a862 1
		prepare_select(&readsetp, &writesetp, &max_fd, &nalloc);
@


1.54.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d1 2
d39 1
a39 2
#include <sys/queue.h>
RCSID("$OpenBSD: ssh-agent.c,v 1.82 2002/03/04 17:27:39 stevesk Exp $");
d49 1
d51 1
d54 2
a63 6
typedef enum {
	AUTH_UNUSED,
	AUTH_SOCKET,
	AUTH_CONNECTION
} sock_type;

d66 3
a68 1
	sock_type type;
d76 1
a76 2
typedef struct identity {
	TAILQ_ENTRY(identity) next;
d83 1
a83 1
	TAILQ_HEAD(idqueue, identity) idlist;
d104 2
a105 2
	for (i = 0; i <=2; i++) {
		TAILQ_INIT(&idtable[i].idlist);
d120 2
a121 2
static Identity *
lookup_identity(Key *key, int version)
d123 1
a123 2
	Identity *id;

d125 6
a130 3
	TAILQ_FOREACH(id, &tab->idlist, next) {
		if (key_equal(key, id->key))
			return (id);
d132 1
a132 9
	return (NULL);
}

static void
free_identity(Identity *id)
{
	key_free(id->key);
	xfree(id->comment);
	xfree(id);
d141 1
a141 1
	Identity *id;
d147 2
a148 1
	TAILQ_FOREACH(id, &tab->idlist, next) {
d171 1
a171 2
	Identity *id;
	Key *key;
d181 1
a181 2
	if ((challenge = BN_new()) == NULL)
		fatal("process_authentication_challenge1: BN_new failed");
d191 1
a191 1
	buffer_get(&e->input, session_id, 16);
d196 2
a197 3
	id = lookup_identity(key, 1);
	if (id != NULL) {
		Key *private = id->key;
d238 1
a238 1
	Key *key;
d256 3
a258 3
		Identity *id = lookup_identity(key, 2);
		if (id != NULL)
			ok = key_sign(id->key, &signature, &slen, data, dlen);
d282 1
a282 1
	Key *key = NULL;
d288 1
a288 1
	switch (version) {
d306 3
a308 2
		Identity *id = lookup_identity(key, version);
		if (id != NULL) {
d317 2
d323 7
a329 2
			TAILQ_REMOVE(&tab->idlist, id, next);
			free_identity(id);
d343 1
a344 1
	Identity *id;
d347 3
a349 4
	for (id = TAILQ_FIRST(&tab->idlist); id;
	    id = TAILQ_FIRST(&tab->idlist)) {
		TAILQ_REMOVE(&tab->idlist, id, next);
		free_identity(id);
d390 1
a390 1
		switch (type) {
d423 8
a430 5
	if (lookup_identity(k, version) == NULL) {
		Identity *id = xmalloc(sizeof(Identity));
		id->key = k;
		id->comment = comment;
		TAILQ_INSERT_TAIL(&tab->idlist, id, next);
d452 1
a452 1

d465 6
a470 2
	if (lookup_identity(k, 1) == NULL) {
		Identity *id = xmalloc(sizeof(Identity));
d475 3
a477 3
		id->key = n;
		id->comment = xstrdup("rsa1 smartcard");
		TAILQ_INSERT_TAIL(&tab->idlist, id, next);
d482 6
a487 2
	if (lookup_identity(k, 2) == NULL) {
		Identity *id = xmalloc(sizeof(Identity));
d492 3
a494 3
		id->key = n;
		id->comment = xstrdup("rsa smartcard");
		TAILQ_INSERT_TAIL(&tab->idlist, id, next);
d507 2
a508 1
	Key *k = NULL;
a518 1
		Identity *id;
d520 2
a521 2
		id = lookup_identity(k, 1);
		if (id != NULL) {
d523 4
a526 2
			TAILQ_REMOVE(&tab->idlist, id, next);
			free_identity(id);
d531 2
a532 2
		id = lookup_identity(k, 2);
		if (id != NULL) {
d534 4
a537 2
			TAILQ_REMOVE(&tab->idlist, id, next);
			free_identity(id);
d560 1
a560 1
	cp = buffer_ptr(&e->input);
d610 1
a610 1
		break;
d613 1
a613 1
		break;
d626 1
a626 1
new_socket(sock_type type, int fd)
d727 1
a727 2
					error("accept from AUTH_SOCKET: %s",
					    strerror(errno));
d781 1
a781 1
cleanup_socket(void *p)
d792 1
a792 1
	cleanup_socket(NULL);
d799 1
a799 1
	cleanup_socket(NULL);
d948 1
a948 1
		cleanup_exit(1);
a970 2
	/* child */
	log_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);
d973 1
a973 1
		error("setsid: %s", strerror(errno));
d985 1
a985 1
		error("setrlimit RLIMIT_CORE: %s", strerror(errno));
d990 4
a993 1
	fatal_add_cleanup(cleanup_socket, NULL);
d1012 1
a1012 1
			fatal("select: %s", strerror(errno));
@


1.54.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.85 2002/04/02 11:49:39 markus Exp $");
d55 1
a445 1
	Identity *id;
d447 3
a449 3
	Key **keys, *k;
	char *sc_reader_id = NULL, *pin;
	int i, version, success = 0;
d452 1
a452 2
	pin = buffer_get_string(&e->input, NULL);
	keys = sc_get_keys(sc_reader_id, pin);
a453 1
	xfree(pin);
d455 2
a456 2
	if (keys == NULL || keys[0] == NULL) {
		error("sc_get_keys failed");
d459 27
a485 15
	for (i = 0; keys[i] != NULL; i++) {
		k = keys[i];
		version = k->type == KEY_RSA1 ? 1 : 2;
		tab = idtab_lookup(version);
		if (lookup_identity(k, version) == NULL) {
			id = xmalloc(sizeof(Identity));
			id->key = k;
			id->comment = xstrdup("smartcard key");
			TAILQ_INSERT_TAIL(&tab->idlist, id, next);
			tab->nentries++;
			success = 1;
		} else {
			key_free(k);
		}
		keys[i] = NULL;
d487 1
a487 1
	xfree(keys);
d497 3
a499 5
	Identity *id;
	Idtab *tab;
	Key **keys, *k = NULL;
	char *sc_reader_id = NULL, *pin;
	int i, version, success = 0;
d502 1
a502 2
	pin = buffer_get_string(&e->input, NULL);
	keys = sc_get_keys(sc_reader_id, pin);
a503 1
	xfree(pin);
d505 10
a514 10
	if (keys == NULL || keys[0] == NULL) {
		error("sc_get_keys failed");
		goto send;
	}
	for (i = 0; keys[i] != NULL; i++) {
		k = keys[i];
		version = k->type == KEY_RSA1 ? 1 : 2;
		if ((id = lookup_identity(k, version)) != NULL) {
			tab = idtab_lookup(version);
                        TAILQ_REMOVE(&tab->idlist, id, next);
d516 7
d524 1
a527 1
		keys[i] = NULL;
d529 1
a529 2
	xfree(keys);
send:
d860 1
a860 1
	if (ac == 0 && !c_flag && !s_flag) {
@


1.53
log
@try to read private f-secure ssh v2 rsa keys.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.52 2001/03/06 00:33:04 deraadt Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.52 2001/03/06 00:33:04 deraadt Exp $");
d562 1
a562 1
			free(*fdrp);
d564 1
a564 1
			free(*fdwp);
@


1.52
log
@EINTR/EAGAIN handling is required in more cases
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.51 2001/03/02 18:54:31 deraadt Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.51 2001/03/02 18:54:31 deraadt Exp $");
a359 19
generate_additional_parameters(RSA *rsa)
{
	BIGNUM *aux;
	BN_CTX *ctx;
	/* Generate additional parameters */
	aux = BN_new();
	ctx = BN_CTX_new();

	BN_sub(aux, rsa->q, BN_value_one());
	BN_mod(rsa->dmq1, rsa->d, aux, ctx);

	BN_sub(aux, rsa->p, BN_value_one());
	BN_mod(rsa->dmp1, rsa->d, aux, ctx);

	BN_clear_free(aux);
	BN_CTX_free(ctx);
}

void
d715 2
@


1.51
log
@make copyright lines the same format
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.50 2001/02/08 19:30:52 itojun Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.50 2001/02/08 19:30:52 itojun Exp $");
d634 9
a642 3
				len = write(sockets[i].fd,
				    buffer_ptr(&sockets[i].output),
				    buffer_len(&sockets[i].output));
d654 7
a660 1
				len = read(sockets[i].fd, buf, sizeof(buf));
@


1.50
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.49 2001/01/29 19:47:31 markus Exp $	*/
d16 1
a16 1
 * Copyright (c) 2000 Markus Friedl. All rights reserved.
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.49 2001/01/29 19:47:31 markus Exp $");
@


1.49
log
@handle rsa_private_decrypt failures; helps against the Bleichenbacher pkcs#1 attack
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.48 2001/01/25 08:06:33 deraadt Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.48 2001/01/25 08:06:33 deraadt Exp $");
d704 1
a704 1
usage()
@


1.48
log
@call _exit() in signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.47 2001/01/21 19:05:56 markus Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.47 2001/01/21 19:05:56 markus Exp $");
d197 2
a198 1
		rsa_private_decrypt(challenge, challenge, private->rsa);
@


1.47
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.46 2001/01/11 21:37:30 markus Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.46 2001/01/11 21:37:30 markus Exp $");
d682 4
a685 2
	unlink(socket_name);
	rmdir(socket_dir);
d696 7
d863 2
a864 2
	signal(SIGHUP, cleanup_exit);
	signal(SIGTERM, cleanup_exit);
@


1.46
log
@fix select overflow, work by deraadt and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.45 2000/12/19 23:17:58 markus Exp $	*/
d40 4
a43 1
RCSID("$OpenBSD: ssh-agent.c,v 1.45 2000/12/19 23:17:58 markus Exp $");
a52 6
#include "includes.h"

#include <openssl/evp.h>
#include <openssl/md5.h>
#include <openssl/dsa.h>
#include <openssl/rsa.h>
d55 1
d58 1
@


1.45
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.44 2000/12/19 22:43:45 markus Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.44 2000/12/19 22:43:45 markus Exp $");
d50 1
d97 2
d295 1
a295 1
			      key_size(key), bits);
d390 1
a390 1
		buffer_get_int(&e->input);		 	/* ignored */
d405 1
a405 1
                type = key_type_from_name(type_name);
d558 2
a559 2
void
prepare_select(fd_set *readset, fd_set *writeset)
d561 4
a564 2
	u_int i;
	for (i = 0; i < sockets_alloc; i++)
d568 1
a568 3
			FD_SET(sockets[i].fd, readset);
			if (buffer_len(&sockets[i].output) > 0)
				FD_SET(sockets[i].fd, writeset);
d576 28
d622 2
a623 1
				sock = accept(sockets[i].fd, (struct sockaddr *) & sunaddr, &slen);
d634 3
a636 2
				len = write(sockets[i].fd, buffer_ptr(&sockets[i].output),
					 buffer_len(&sockets[i].output));
d669 2
d677 1
d699 1
a699 1
		__progname);
a705 1
	fd_set readset, writeset;
d712 1
d748 1
a748 1
				SSH_AGENTPID_ENV_NAME);
d752 1
a752 2
		if (pid < 1) {	/* XXX PID_MAX check too */
		/* Yes, PID_MAX check please */
d754 1
a754 1
				SSH_AGENTPID_ENV_NAME, pidstr);
d776 1
a776 1
		 parent_pid);
d798 1
d814 1
a814 1
			       SSH_AUTHSOCKET_ENV_NAME);
d816 1
a816 1
			       SSH_AGENTPID_ENV_NAME);
d858 2
a859 4
		FD_ZERO(&readset);
		FD_ZERO(&writeset);
		prepare_select(&readset, &writeset);
		if (select(max_fd + 1, &readset, &writeset, NULL, NULL) < 0) {
d864 1
a864 1
		after_select(&readset, &writeset);
@


1.44
log
@remove() -> unlink() for consistency
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.43 2000/12/13 23:25:44 markus Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.43 2000/12/13 23:25:44 markus Exp $");
d69 1
a69 1
unsigned int sockets_alloc = 0;
d150 2
a151 2
			unsigned char *blob;
			unsigned int blen;
d172 2
a173 2
	unsigned char buf[32], mdbuf[16], session_id[16];
	unsigned int response_type;
d234 2
a235 2
	unsigned char *blob, *data, *signature = NULL;
	unsigned int blen, dlen, slen = 0;
d278 3
a280 3
	unsigned char *blob;
	unsigned int blen;
	unsigned int bits;
d338 1
a338 1
	unsigned int i;
d462 3
a464 3
	unsigned int msg_len;
	unsigned int type;
	unsigned char *cp;
d467 1
a467 1
	cp = (unsigned char *) buffer_ptr(&e->input);
d526 1
a526 1
	unsigned int i, old_alloc;
d558 1
a558 1
	unsigned int i;
d578 1
a578 1
	unsigned int i;
@


1.43
log
@remove redundant spaces; from stevesk@@pobox.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.42 2000/12/09 14:06:54 markus Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.42 2000/12/09 14:06:54 markus Exp $");
d647 1
a647 1
	remove(socket_name);
@


1.42
log
@extern int optind; from stevesk@@sweden.hp.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.41 2000/11/30 18:33:05 markus Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.41 2000/11/30 18:33:05 markus Exp $");
d241 1
a241 1
	
d676 1
a676 1
	extern int optind;                                                          
@


1.41
log
@agents must not dump core, ok niels@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.40 2000/11/14 23:48:55 markus Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.40 2000/11/14 23:48:55 markus Exp $");
d676 1
@


1.40
log
@do not reorder keys if a key is removed
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.39 2000/11/12 19:50:38 markus Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.39 2000/11/12 19:50:38 markus Exp $");
d673 1
d796 6
@


1.39
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.38 2000/11/12 19:03:28 markus Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.38 2000/11/12 19:03:28 markus Exp $");
d307 3
a309 2
			 * the array, we actually free the key there and copy
			 * data from the last entry.
d318 7
a324 2
			if (idx != tab->nentries - 1)
				tab->identities[idx] = tab->identities[tab->nentries - 1];
@


1.38
log
@off-by-one when removing a key from the agent
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.37 2000/09/21 11:07:51 markus Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.37 2000/09/21 11:07:51 markus Exp $");
a56 1
#include "dsa.h"
d145 1
a145 1
		if (id->key->type == KEY_RSA) {
d152 1
a152 1
			dsa_make_key_blob(id->key, &blob, &blen);
d176 1
a176 1
	key = key_new(KEY_RSA);
d249 1
a249 1
	key = dsa_key_from_blob(blob, blen);
d253 1
a253 1
			ok = dsa_sign(private, &signature, &slen, data, dlen);
d285 1
a285 1
		key = key_new(KEY_RSA);
d296 1
a296 1
		key = dsa_key_from_blob(blob, blen);
d351 19
d373 1
a373 4
	RSA *rsa;
	BIGNUM *aux;
	BN_CTX *ctx;
	char *type;
d375 1
a375 1
	int success = 0;
d380 6
a385 18
		k = key_new(KEY_RSA);
		rsa = k->rsa;

		/* allocate mem for private key */
		/* XXX rsa->n and rsa->e are already allocated */
		rsa->d = BN_new();
		rsa->iqmp = BN_new();
		rsa->q = BN_new();
		rsa->p = BN_new();
		rsa->dmq1 = BN_new();
		rsa->dmp1 = BN_new();

		buffer_get_int(&e->input);		 /* ignored */

		buffer_get_bignum(&e->input, rsa->n);
		buffer_get_bignum(&e->input, rsa->e);
		buffer_get_bignum(&e->input, rsa->d);
		buffer_get_bignum(&e->input, rsa->iqmp);
d388 2
a389 2
		buffer_get_bignum(&e->input, rsa->q);	/* p */
		buffer_get_bignum(&e->input, rsa->p);	/* q */
d392 1
a392 12
		aux = BN_new();
		ctx = BN_CTX_new();

		BN_sub(aux, rsa->q, BN_value_one());
		BN_mod(rsa->dmq1, rsa->d, aux, ctx);

		BN_sub(aux, rsa->p, BN_value_one());
		BN_mod(rsa->dmp1, rsa->d, aux, ctx);

		BN_clear_free(aux);
		BN_CTX_free(ctx);

d395 25
a419 2
		type = buffer_get_string(&e->input, NULL);
		if (strcmp(type, KEX_DSS)) {
a420 1
			xfree(type);
a422 13
		xfree(type);

		k = key_new(KEY_DSA);

		/* allocate mem for private key */
		k->dsa->priv_key = BN_new();

		buffer_get_bignum2(&e->input, k->dsa->p);
		buffer_get_bignum2(&e->input, k->dsa->q);
		buffer_get_bignum2(&e->input, k->dsa->g);
		buffer_get_bignum2(&e->input, k->dsa->pub_key);
		buffer_get_bignum2(&e->input, k->dsa->priv_key);

a424 1

a669 7
	/* check if RSA support exists */
	if (rsa_alive() == 0) {
		fprintf(stderr,
			"%s: no RSA support in libssl and libcrypto.  See ssl(8).\n",
			__progname);
		exit(1);
	}
@


1.37
log
@bug compat for old ssh.com software
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.36 2000/09/15 07:13:49 deraadt Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.36 2000/09/15 07:13:49 deraadt Exp $");
d314 6
a319 2
			if (idx != tab->nentries)
				tab->identities[idx] = tab->identities[tab->nentries];
@


1.37.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.50 2001/02/08 19:30:52 itojun Exp $	*/
d40 1
a40 4
RCSID("$OpenBSD: ssh-agent.c,v 1.50 2001/02/08 19:30:52 itojun Exp $");

#include <openssl/evp.h>
#include <openssl/md5.h>
d50 5
d57 1
a57 1
#include "cipher.h"
a59 1
#include "log.h"
d70 1
a70 1
u_int sockets_alloc = 0;
a96 2
int	prepare_select(fd_set **, fd_set **, int *);

d146 1
a146 1
		if (id->key->type == KEY_RSA1) {
d151 3
a153 3
			u_char *blob;
			u_int blen;
			key_to_blob(id->key, &blob, &blen);
d173 2
a174 2
	u_char buf[32], mdbuf[16], session_id[16];
	u_int response_type;
d177 1
a177 1
	key = key_new(KEY_RSA1);
d196 1
a196 2
		if (rsa_private_decrypt(challenge, challenge, private->rsa) <= 0)
			goto failure;
d235 2
a236 2
	u_char *blob, *data, *signature = NULL;
	u_int blen, dlen, slen = 0;
d242 1
a242 1

d250 1
a250 1
	key = key_from_blob(blob, blen);
d254 1
a254 1
			ok = key_sign(private, &signature, &slen, data, dlen);
d279 3
a281 3
	u_char *blob;
	u_int blen;
	u_int bits;
d286 1
a286 1
		key = key_new(KEY_RSA1);
d293 1
a293 1
			    key_size(key), bits);
d297 1
a297 1
		key = key_from_blob(blob, blen);
d308 2
a309 3
			 * the array, we actually free the key there and move
			 * all the entries between the empty slot and the end
			 * of the array.
d314 2
a315 11
			if (tab->nentries < 1)
				fatal("process_remove_identity: "
				    "internal error: tab->nentries %d",
				    tab->nentries);
			if (idx != tab->nentries - 1) {
				int i;
				for (i = idx; i < tab->nentries - 1; i++)
					tab->identities[i] = tab->identities[i+1];
			}
			tab->identities[tab->nentries - 1].key = NULL;
			tab->identities[tab->nentries - 1].comment = NULL;
d329 1
a329 1
	u_int i;
d348 1
a348 1
generate_additional_parameters(RSA *rsa)
d350 2
d354 1
a354 19
	/* Generate additional parameters */
	aux = BN_new();
	ctx = BN_CTX_new();

	BN_sub(aux, rsa->q, BN_value_one());
	BN_mod(rsa->dmq1, rsa->d, aux, ctx);

	BN_sub(aux, rsa->p, BN_value_one());
	BN_mod(rsa->dmp1, rsa->d, aux, ctx);

	BN_clear_free(aux);
	BN_CTX_free(ctx);
}

void
process_add_identity(SocketEntry *e, int version)
{
	Key *k = NULL;
	char *type_name;
d356 1
a356 1
	int type, success = 0;
d361 18
a378 6
		k = key_new_private(KEY_RSA1);
		buffer_get_int(&e->input);			/* ignored */
		buffer_get_bignum(&e->input, k->rsa->n);
		buffer_get_bignum(&e->input, k->rsa->e);
		buffer_get_bignum(&e->input, k->rsa->d);
		buffer_get_bignum(&e->input, k->rsa->iqmp);
d381 2
a382 2
		buffer_get_bignum(&e->input, k->rsa->q);	/* p */
		buffer_get_bignum(&e->input, k->rsa->p);	/* q */
d385 12
a396 1
		generate_additional_parameters(k->rsa);
d399 2
a400 25
		type_name = buffer_get_string(&e->input, NULL);
		type = key_type_from_name(type_name);
		xfree(type_name);
		switch(type) {
		case KEY_DSA:
			k = key_new_private(type);
			buffer_get_bignum2(&e->input, k->dsa->p);
			buffer_get_bignum2(&e->input, k->dsa->q);
			buffer_get_bignum2(&e->input, k->dsa->g);
			buffer_get_bignum2(&e->input, k->dsa->pub_key);
			buffer_get_bignum2(&e->input, k->dsa->priv_key);
			break;
		case KEY_RSA:
			k = key_new_private(type);
			buffer_get_bignum2(&e->input, k->rsa->n);
			buffer_get_bignum2(&e->input, k->rsa->e);
			buffer_get_bignum2(&e->input, k->rsa->d);
			buffer_get_bignum2(&e->input, k->rsa->iqmp);
			buffer_get_bignum2(&e->input, k->rsa->p);
			buffer_get_bignum2(&e->input, k->rsa->q);

			/* Generate additional parameters */
			generate_additional_parameters(k->rsa);
			break;
		default:
d402 1
d405 13
d420 1
d452 3
a454 3
	u_int msg_len;
	u_int type;
	u_char *cp;
d457 1
a457 1
	cp = (u_char *) buffer_ptr(&e->input);
d516 1
a516 1
	u_int i, old_alloc;
d545 2
a546 2
int
prepare_select(fd_set **fdrp, fd_set **fdwp, int *fdl)
d548 2
a549 4
	u_int i, sz;
	int n = 0;

	for (i = 0; i < sockets_alloc; i++) {
d553 3
a555 1
			n = MAX(n, sockets[i].fd);
a562 28
	}

	sz = howmany(n+1, NFDBITS) * sizeof(fd_mask);
	if (*fdrp == NULL || n > *fdl) {
		if (*fdrp)
			free(*fdrp);
		if (*fdwp)
			free(*fdwp);
		*fdrp = xmalloc(sz);
		*fdwp = xmalloc(sz);
		*fdl = n;
	}
	memset(*fdrp, 0, sz);
	memset(*fdwp, 0, sz);

	for (i = 0; i < sockets_alloc; i++) {
		switch (sockets[i].type) {
		case AUTH_SOCKET:
		case AUTH_CONNECTION:
			FD_SET(sockets[i].fd, *fdrp);
			if (buffer_len(&sockets[i].output) > 0)
				FD_SET(sockets[i].fd, *fdwp);
			break;
		default:
			break;
		}
	}
	return (1);
d568 1
a568 1
	u_int i;
d581 1
a581 2
				sock = accept(sockets[i].fd,
				    (struct sockaddr *) &sunaddr, &slen);
d592 2
a593 3
				len = write(sockets[i].fd,
				    buffer_ptr(&sockets[i].output),
				    buffer_len(&sockets[i].output));
a625 2
	int save_errno = errno;

a631 1
	errno = save_errno;
d637 2
a638 4
	if (socket_name[0])
		unlink(socket_name);
	if (socket_dir[0])
		rmdir(socket_dir);
d649 1
a649 8
cleanup_handler(int sig)
{
	cleanup_socket();
	_exit(2);
}

void
usage(void)
d653 1
a653 1
	    __progname);
d660 1
a662 1
	struct rlimit rlim;
a664 2
	extern int optind;
	fd_set *readsetp = NULL, *writesetp = NULL;
d666 7
d707 1
a707 1
			    SSH_AGENTPID_ENV_NAME);
d711 2
a712 1
		if (pid < 1) {
d714 1
a714 1
			    SSH_AGENTPID_ENV_NAME, pidstr);
d736 1
a736 1
	    parent_pid);
a757 1

d773 1
a773 1
			    SSH_AUTHSOCKET_ENV_NAME);
d775 1
a775 1
			    SSH_AGENTPID_ENV_NAME);
a791 6
	/* deny core dumps, since memory contains unencrypted private keys */
	rlim.rlim_cur = rlim.rlim_max = 0;
	if (setrlimit(RLIMIT_CORE, &rlim) < 0) {
		perror("setrlimit rlimit_core failed");
		cleanup_exit(1);
	}
d808 2
a809 2
	signal(SIGHUP, cleanup_handler);
	signal(SIGTERM, cleanup_handler);
d811 4
a814 2
		prepare_select(&readsetp, &writesetp, &max_fd);
		if (select(max_fd + 1, readsetp, writesetp, NULL, NULL) < 0) {
d819 1
a819 1
		after_select(readsetp, writesetp);
@


1.37.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.37.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.52 2001/03/06 00:33:04 deraadt Exp $	*/
d16 1
a16 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.52 2001/03/06 00:33:04 deraadt Exp $");
d634 3
a636 9
				do {
					len = write(sockets[i].fd,
					    buffer_ptr(&sockets[i].output),
					    buffer_len(&sockets[i].output));
					if (len == -1 && (errno == EAGAIN ||
					    errno == EINTR))
						continue;
					break;
				} while (1);
d648 1
a648 7
				do {
					len = read(sockets[i].fd, buf, sizeof(buf));
					if (len == -1 && (errno == EAGAIN ||
					    errno == EINTR))
						continue;
					break;
				} while (1);
@


1.37.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.54 2001/04/03 13:56:11 stevesk Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.54 2001/04/03 13:56:11 stevesk Exp $");
d360 19
d581 1
a581 1
			xfree(*fdrp);
d583 1
a583 1
			xfree(*fdwp);
a733 2

	SSLeay_add_all_algorithms();
@


1.37.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.72 2001/08/03 10:31:30 jakob Exp $	*/
d15 2
a16 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.72 2001/08/03 10:31:30 jakob Exp $");
a59 5
#ifdef SMARTCARD
#include <openssl/engine.h>
#include "scard.h"
#endif

d96 3
a98 1
static void
d109 1
a109 1
static Idtab *
d118 1
a118 1
static Key *
d134 1
a134 1
static void
d166 1
a166 1
static void
d232 1
a232 1
static void
d277 1
a277 1
static void
d338 1
a338 1
static void
d359 1
a359 1
static void
d382 1
a382 1
		rsa_generate_additional_parameters(k->rsa);
d407 1
a407 1
			rsa_generate_additional_parameters(k->rsa);
a440 107

#ifdef SMARTCARD
static void
process_add_smartcard_key (SocketEntry *e)
{
	Idtab *tab;
	Key *n = NULL, *k = NULL;
	char *sc_reader_id = NULL;
	int success = 0;
	
	sc_reader_id = buffer_get_string(&e->input, NULL);
	k = sc_get_key(sc_reader_id);
	xfree(sc_reader_id);

	if (k == NULL) {
		error("sc_get_pubkey failed");
		goto send;
	}
	success = 1;

	tab = idtab_lookup(1);
	k->type = KEY_RSA1;
	if (lookup_private_key(k, NULL, 1) == NULL) {
		if (tab->nentries == 0)
			tab->identities = xmalloc(sizeof(Identity));
		else
			tab->identities = xrealloc(tab->identities,
			    (tab->nentries + 1) * sizeof(Identity));
		n = key_new(KEY_RSA1);
		BN_copy(n->rsa->n, k->rsa->n);
		BN_copy(n->rsa->e, k->rsa->e);
		RSA_set_method(n->rsa, sc_get_engine());
		tab->identities[tab->nentries].key = n;
		tab->identities[tab->nentries].comment =
		    xstrdup("rsa1 smartcard");
		tab->nentries++;
	}
	k->type = KEY_RSA;
	tab = idtab_lookup(2);
	if (lookup_private_key(k, NULL, 2) == NULL) {
		if (tab->nentries == 0)
			tab->identities = xmalloc(sizeof(Identity));
		else
			tab->identities = xrealloc(tab->identities,
			    (tab->nentries + 1) * sizeof(Identity));
		n = key_new(KEY_RSA);
		BN_copy(n->rsa->n, k->rsa->n);
		BN_copy(n->rsa->e, k->rsa->e);
		RSA_set_method(n->rsa, sc_get_engine());
		tab->identities[tab->nentries].key = n;
		tab->identities[tab->nentries].comment =
		    xstrdup("rsa smartcard");
		tab->nentries++;
	}
	key_free(k);
send:
	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
}

static void
process_remove_smartcard_key(SocketEntry *e)
{
	Key *k = NULL, *private;
	int idx;
	int success = 0;
	char *sc_reader_id = NULL;

	sc_reader_id = buffer_get_string(&e->input, NULL);
	k = sc_get_key(sc_reader_id);
	xfree(sc_reader_id);

	if (k == NULL) {
		error("sc_get_pubkey failed");
	} else {
		k->type = KEY_RSA1;
		private = lookup_private_key(k, &idx, 1);
		if (private != NULL) {
			Idtab *tab = idtab_lookup(1);
			key_free(tab->identities[idx].key);
			xfree(tab->identities[idx].comment);
			if (idx != tab->nentries)
				tab->identities[idx] = tab->identities[tab->nentries];
			tab->nentries--;
			success = 1;
		}
		k->type = KEY_RSA;
		private = lookup_private_key(k, &idx, 2);
		if (private != NULL) {
			Idtab *tab = idtab_lookup(2);
			key_free(tab->identities[idx].key);
			xfree(tab->identities[idx].comment);
			if (idx != tab->nentries)
				tab->identities[idx] = tab->identities[tab->nentries];
			tab->nentries--;
			success = 1;
		}
		key_free(k);
	}

	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
}
#endif /* SMARTCARD */

d443 1
a443 1
static void
a463 1
	debug("type %d", type);
a496 8
#ifdef SMARTCARD
	case SSH_AGENTC_ADD_SMARTCARD_KEY:
		process_add_smartcard_key(e);
		break; 
	case SSH_AGENTC_REMOVE_SMARTCARD_KEY:
		process_remove_smartcard_key(e);
		break; 
#endif /* SMARTCARD */
d507 1
a507 1
static void
d539 2
a540 2
static int
prepare_select(fd_set **fdrp, fd_set **fdwp, int *fdl, int *nallocp)
d560 1
a560 1
	if (*fdrp == NULL || sz > *nallocp) {
d567 1
a567 1
		*nallocp = sz;
a568 3
	if (n < *fdl)
		debug("XXX shrink: %d < %d", n, *fdl);
	*fdl = n;
d587 1
a587 1
static void
d659 15
a673 1
static void
d682 1
a682 1
static void
d689 1
a689 1
static void
d696 1
a696 15
static void
check_parent_exists(int sig)
{
	int save_errno = errno;

	if (parent_pid != -1 && kill(parent_pid, 0) < 0) {
		/* printf("Parent has died - Authentication agent exiting.\n"); */
		cleanup_handler(sig); /* safe */
	}
	signal(SIGALRM, check_parent_exists);
	alarm(10);
	errno = save_errno;
}

static void
d699 2
a700 1
	fprintf(stderr, "Usage: %s [options] [command [args ...]]\n",
a701 5
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -c          Generate C-shell commands on stdout.\n");
	fprintf(stderr, "  -s          Generate Bourne shell commands on stdout.\n");
	fprintf(stderr, "  -k          Kill the current agent.\n");
	fprintf(stderr, "  -d          Debug mode.\n");
d708 1
a708 1
	int sock, c_flag = 0, d_flag = 0, k_flag = 0, s_flag = 0, ch, nalloc;
d718 1
a718 1
	while ((ch = getopt(ac, av, "cdks")) != -1) {
a732 5
		case 'd':
			if (d_flag)
				usage();
			d_flag++;
			break;
d740 1
a740 1
	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag))
d743 1
a743 1
	if (ac == 0 && !c_flag && !k_flag && !s_flag && !d_flag) {
a806 8
	if (d_flag) {
		log_init(__progname, SYSLOG_LEVEL_DEBUG1, SYSLOG_FACILITY_AUTH, 1);
		format = c_flag ? "setenv %s %s;\n" : "%s=%s; export %s;\n";
		printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
		    SSH_AUTHSOCKET_ENV_NAME);
		printf("echo Agent pid %d;\n", parent_pid);
		goto skip;
	}
a832 7

	if (setsid() == -1) {
		perror("setsid");
		cleanup_exit(1);
	}

	(void)chdir("/");
d843 4
a846 2

skip:
d857 1
a857 2
	if (!d_flag)
		signal(SIGINT, SIG_IGN);
a860 2
	nalloc = 0;

d862 1
a862 1
		prepare_select(&readsetp, &writesetp, &max_fd, &nalloc);
@


1.37.2.6
log
@Merge OpenSSH 3.1.
@
text
@d1 2
d39 1
a39 2
#include <sys/queue.h>
RCSID("$OpenBSD: ssh-agent.c,v 1.82 2002/03/04 17:27:39 stevesk Exp $");
d49 1
d51 1
d54 2
a63 6
typedef enum {
	AUTH_UNUSED,
	AUTH_SOCKET,
	AUTH_CONNECTION
} sock_type;

d66 3
a68 1
	sock_type type;
d76 1
a76 2
typedef struct identity {
	TAILQ_ENTRY(identity) next;
d83 1
a83 1
	TAILQ_HEAD(idqueue, identity) idlist;
d104 2
a105 2
	for (i = 0; i <=2; i++) {
		TAILQ_INIT(&idtable[i].idlist);
d120 2
a121 2
static Identity *
lookup_identity(Key *key, int version)
d123 1
a123 2
	Identity *id;

d125 6
a130 3
	TAILQ_FOREACH(id, &tab->idlist, next) {
		if (key_equal(key, id->key))
			return (id);
d132 1
a132 9
	return (NULL);
}

static void
free_identity(Identity *id)
{
	key_free(id->key);
	xfree(id->comment);
	xfree(id);
d141 1
a141 1
	Identity *id;
d147 2
a148 1
	TAILQ_FOREACH(id, &tab->idlist, next) {
d171 1
a171 2
	Identity *id;
	Key *key;
d181 1
a181 2
	if ((challenge = BN_new()) == NULL)
		fatal("process_authentication_challenge1: BN_new failed");
d191 1
a191 1
	buffer_get(&e->input, session_id, 16);
d196 2
a197 3
	id = lookup_identity(key, 1);
	if (id != NULL) {
		Key *private = id->key;
d238 1
a238 1
	Key *key;
d256 3
a258 3
		Identity *id = lookup_identity(key, 2);
		if (id != NULL)
			ok = key_sign(id->key, &signature, &slen, data, dlen);
d282 1
a282 1
	Key *key = NULL;
d288 1
a288 1
	switch (version) {
d306 3
a308 2
		Identity *id = lookup_identity(key, version);
		if (id != NULL) {
d317 2
d323 7
a329 2
			TAILQ_REMOVE(&tab->idlist, id, next);
			free_identity(id);
d343 1
a344 1
	Identity *id;
d347 3
a349 4
	for (id = TAILQ_FIRST(&tab->idlist); id;
	    id = TAILQ_FIRST(&tab->idlist)) {
		TAILQ_REMOVE(&tab->idlist, id, next);
		free_identity(id);
d390 1
a390 1
		switch (type) {
d423 8
a430 5
	if (lookup_identity(k, version) == NULL) {
		Identity *id = xmalloc(sizeof(Identity));
		id->key = k;
		id->comment = comment;
		TAILQ_INSERT_TAIL(&tab->idlist, id, next);
d452 1
a452 1

d465 6
a470 2
	if (lookup_identity(k, 1) == NULL) {
		Identity *id = xmalloc(sizeof(Identity));
d475 3
a477 3
		id->key = n;
		id->comment = xstrdup("rsa1 smartcard");
		TAILQ_INSERT_TAIL(&tab->idlist, id, next);
d482 6
a487 2
	if (lookup_identity(k, 2) == NULL) {
		Identity *id = xmalloc(sizeof(Identity));
d492 3
a494 3
		id->key = n;
		id->comment = xstrdup("rsa smartcard");
		TAILQ_INSERT_TAIL(&tab->idlist, id, next);
d507 2
a508 1
	Key *k = NULL;
a518 1
		Identity *id;
d520 2
a521 2
		id = lookup_identity(k, 1);
		if (id != NULL) {
d523 4
a526 2
			TAILQ_REMOVE(&tab->idlist, id, next);
			free_identity(id);
d531 2
a532 2
		id = lookup_identity(k, 2);
		if (id != NULL) {
d534 4
a537 2
			TAILQ_REMOVE(&tab->idlist, id, next);
			free_identity(id);
d560 1
a560 1
	cp = buffer_ptr(&e->input);
d610 1
a610 1
		break;
d613 1
a613 1
		break;
d626 1
a626 1
new_socket(sock_type type, int fd)
d727 1
a727 2
					error("accept from AUTH_SOCKET: %s",
					    strerror(errno));
d781 1
a781 1
cleanup_socket(void *p)
d792 1
a792 1
	cleanup_socket(NULL);
d799 1
a799 1
	cleanup_socket(NULL);
d948 1
a948 1
		cleanup_exit(1);
a970 2
	/* child */
	log_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);
d973 1
a973 1
		error("setsid: %s", strerror(errno));
d985 1
a985 1
		error("setrlimit RLIMIT_CORE: %s", strerror(errno));
d990 4
a993 1
	fatal_add_cleanup(cleanup_socket, NULL);
d1012 1
a1012 1
			fatal("select: %s", strerror(errno));
@


1.36
log
@check return value for setenv(3) for failure, and deal appropriately
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.35 2000/09/07 20:27:54 deraadt Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.35 2000/09/07 20:27:54 deraadt Exp $");
d59 1
d237 1
d245 4
a248 1
	buffer_get_int(&e->input);			/* flags, unused */
@


1.35
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.34 2000/08/31 22:09:34 markus Exp $	*/
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.34 2000/08/31 22:09:34 markus Exp $");
d774 5
a778 2
		setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1);
		setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1);
@


1.34
log
@add a flag to SSH2_AGENTC_SIGN_REQUEST for future extensions
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.33 2000/08/19 21:34:43 markus Exp $	*/
a6 1
 * Created: Wed Mar 29 03:46:59 1995 ylo
d9 6
d17 20
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.33 2000/08/19 21:34:43 markus Exp $");
@


1.33
log
@add SSH2/DSA support to the agent and some other DSA related cleanups.
(note that we cannot talk to ssh.com's ssh2 agents)
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.32 2000/07/16 08:27:21 markus Exp $	*/
d15 1
a15 1
RCSID("$OpenBSD: ssh-agent.c,v 1.32 2000/07/16 08:27:21 markus Exp $");
d218 1
@


1.32
log
@make ssh-add accept dsa keys (the agent does not)
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.31 2000/04/29 18:11:52 markus Exp $	*/
d9 3
d15 1
a15 1
RCSID("$OpenBSD: ssh-agent.c,v 1.31 2000/04/29 18:11:52 markus Exp $");
d26 1
d32 2
d48 1
a48 1
	RSA *key;
d52 7
a58 2
unsigned int num_identities = 0;
Identity *identities = NULL;
d72 1
a72 1
process_request_identity(SocketEntry *e)
d74 37
d115 17
a131 8
	buffer_put_char(&msg, SSH_AGENT_RSA_IDENTITIES_ANSWER);
	buffer_put_int(&msg, num_identities);
	for (i = 0; i < num_identities; i++) {
		buffer_put_int(&msg, BN_num_bits(identities[i].key->n));
		buffer_put_bignum(&msg, identities[i].key->e);
		buffer_put_bignum(&msg, identities[i].key->n);
		buffer_put_string(&msg, identities[i].comment,
				  strlen(identities[i].comment));
d138 1
d140 1
a140 1
process_authentication_challenge(SocketEntry *e)
d142 3
a144 2
	int i, pub_bits, len;
	BIGNUM *pub_e, *pub_n, *challenge;
d151 1
a151 2
	pub_e = BN_new();
	pub_n = BN_new();
d153 4
a156 3
	pub_bits = buffer_get_int(&e->input);
	buffer_get_bignum(&e->input, pub_e);
	buffer_get_bignum(&e->input, pub_n);
a157 45
	if (buffer_len(&e->input) == 0) {
		/* Compatibility code for old servers. */
		memset(session_id, 0, 16);
		response_type = 0;
	} else {
		/* New code. */
		buffer_get(&e->input, (char *) session_id, 16);
		response_type = buffer_get_int(&e->input);
	}
	for (i = 0; i < num_identities; i++)
		if (pub_bits == BN_num_bits(identities[i].key->n) &&
		    BN_cmp(pub_e, identities[i].key->e) == 0 &&
		    BN_cmp(pub_n, identities[i].key->n) == 0) {
			/* Decrypt the challenge using the private key. */
			rsa_private_decrypt(challenge, challenge, identities[i].key);

			/* Compute the desired response. */
			switch (response_type) {
			case 0:/* As of protocol 1.0 */
				/* This response type is no longer supported. */
				log("Compatibility with ssh protocol 1.0 no longer supported.");
				buffer_put_char(&msg, SSH_AGENT_FAILURE);
				goto send;

			case 1:/* As of protocol 1.1 */
				/* The response is MD5 of decrypted challenge plus session id. */
				len = BN_num_bytes(challenge);

				if (len <= 0 || len > 32) {
					fatal("process_authentication_challenge: "
					 "bad challenge length %d", len);
				}
				memset(buf, 0, 32);
				BN_bn2bin(challenge, buf + 32 - len);
				MD5_Init(&md);
				MD5_Update(&md, buf, 32);
				MD5_Update(&md, session_id, 16);
				MD5_Final(mdbuf, &md);
				break;

			default:
				fatal("process_authentication_challenge: bad response_type %d",
				      response_type);
				break;
			}
d159 32
a190 4
			/* Send the response. */
			buffer_put_char(&msg, SSH_AGENT_RSA_RESPONSE);
			for (i = 0; i < 16; i++)
				buffer_put_char(&msg, mdbuf[i]);
d192 2
a193 3
			goto send;
		}
	/* Unknown identity.  Send failure. */
d197 37
d235 1
a235 1
		      buffer_len(&msg));
d237 4
a240 3
	BN_clear_free(pub_e);
	BN_clear_free(pub_n);
	BN_clear_free(challenge);
d243 1
d245 1
a245 1
process_remove_identity(SocketEntry *e)
d247 3
d251 1
a251 2
	unsigned int i;
	BIGNUM *dummy, *n;
d253 21
a273 15
	dummy = BN_new();
	n = BN_new();

	/* Get the key from the packet. */
	bits = buffer_get_int(&e->input);
	buffer_get_bignum(&e->input, dummy);
	buffer_get_bignum(&e->input, n);

	if (bits != BN_num_bits(n))
		log("Warning: identity keysize mismatch: actual %d, announced %d",
		      BN_num_bits(n), bits);

	/* Check if we have the key. */
	for (i = 0; i < num_identities; i++)
		if (BN_cmp(identities[i].key->n, n) == 0) {
d280 7
a286 12
			RSA_free(identities[i].key);
			xfree(identities[i].comment);
			if (i < num_identities - 1)
				identities[i] = identities[num_identities - 1];
			num_identities--;
			BN_clear_free(dummy);
			BN_clear_free(n);

			/* Send success. */
			buffer_put_int(&e->output, 1);
			buffer_put_char(&e->output, SSH_AGENT_SUCCESS);
			return;
d288 2
a289 5
	/* We did not have the key. */
	BN_clear(dummy);
	BN_clear(n);

	/* Send failure. */
d291 2
a292 1
	buffer_put_char(&e->output, SSH_AGENT_FAILURE);
a294 3
/*
 * Removes all identities from the agent.
 */
d296 1
a296 1
process_remove_all_identities(SocketEntry *e)
d299 1
d302 3
a304 3
	for (i = 0; i < num_identities; i++) {
		RSA_free(identities[i].key);
		xfree(identities[i].comment);
d308 1
a308 1
	num_identities = 0;
a315 3
/*
 * Adds an identity to the agent.
 */
d317 1
a317 1
process_add_identity(SocketEntry *e)
d319 2
a320 2
	RSA *k;
	int i;
d323 33
d357 5
a361 4
	if (num_identities == 0)
		identities = xmalloc(sizeof(Identity));
	else
		identities = xrealloc(identities, (num_identities + 1) * sizeof(Identity));
d363 2
a364 43
	identities[num_identities].key = RSA_new();
	k = identities[num_identities].key;
	buffer_get_int(&e->input);	/* bits */
	k->n = BN_new();
	buffer_get_bignum(&e->input, k->n);
	k->e = BN_new();
	buffer_get_bignum(&e->input, k->e);
	k->d = BN_new();
	buffer_get_bignum(&e->input, k->d);
	k->iqmp = BN_new();
	buffer_get_bignum(&e->input, k->iqmp);
	/* SSH and SSL have p and q swapped */
	k->q = BN_new();
	buffer_get_bignum(&e->input, k->q);	/* p */
	k->p = BN_new();
	buffer_get_bignum(&e->input, k->p);	/* q */

	/* Generate additional parameters */
	aux = BN_new();
	ctx = BN_CTX_new();

	BN_sub(aux, k->q, BN_value_one());
	k->dmq1 = BN_new();
	BN_mod(k->dmq1, k->d, aux, ctx);

	BN_sub(aux, k->p, BN_value_one());
	k->dmp1 = BN_new();
	BN_mod(k->dmp1, k->d, aux, ctx);

	BN_clear_free(aux);
	BN_CTX_free(ctx);

	identities[num_identities].comment = buffer_get_string(&e->input, NULL);

	/* Check if we already have the key. */
	for (i = 0; i < num_identities; i++)
		if (BN_cmp(identities[i].key->n, k->n) == 0) {
			/*
			 * We already have this key.  Clear and free the new
			 * data and return success.
			 */
			RSA_free(k);
			xfree(identities[num_identities].comment);
d366 7
a372 4
			/* Send success. */
			buffer_put_int(&e->output, 1);
			buffer_put_char(&e->output, SSH_AGENT_SUCCESS);
			return;
d374 1
a374 2
	/* Increment the number of identities. */
	num_identities++;
d376 35
a410 1
	/* Send a success message. */
d412 2
a413 1
	buffer_put_char(&e->output, SSH_AGENT_SUCCESS);
d416 2
d440 4
d445 1
a445 4
		process_request_identity(e);
		break;
	case SSH_AGENTC_RSA_CHALLENGE:
		process_authentication_challenge(e);
d448 1
a448 1
		process_add_identity(e);
d451 1
a451 1
		process_remove_identity(e);
d454 17
a470 1
		process_remove_all_identities(e);
d771 1
@


1.31
log
@keysize warnings error() -> log()
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.30 2000/04/21 00:27:11 djm Exp $	*/
d12 1
a12 1
RCSID("$OpenBSD: ssh-agent.c,v 1.30 2000/04/21 00:27:11 djm Exp $");
a15 1
#include "authfd.h"
d24 4
@


1.31.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.33 2000/08/19 21:34:43 markus Exp $	*/
a8 3
 *
 * SSH2 implementation,
 * Copyright (c) 2000 Markus Friedl. All rights reserved.
d12 1
a12 1
RCSID("$OpenBSD: ssh-agent.c,v 1.33 2000/08/19 21:34:43 markus Exp $");
d16 1
a23 1
#include <openssl/evp.h>
a24 6
#include <openssl/dsa.h>
#include <openssl/rsa.h>
#include "key.h"
#include "authfd.h"
#include "dsa.h"
#include "kex.h"
d39 1
a39 1
	Key *key;
d43 2
a44 7
typedef struct {
	int nentries;
	Identity *identities;
} Idtab;

/* private key table, one per protocol version */
Idtab idtable[3];
d58 1
a58 1
idtab_init(void)
a59 37
	int i;
	for (i = 0; i <=2; i++){
		idtable[i].identities = NULL;
		idtable[i].nentries = 0;
	}
}

/* return private key table for requested protocol version */
Idtab *
idtab_lookup(int version)
{
	if (version < 1 || version > 2)
		fatal("internal error, bad protocol version %d", version);
	return &idtable[version];
}

/* return matching private key for given public key */
Key *
lookup_private_key(Key *key, int *idx, int version)
{
	int i;
	Idtab *tab = idtab_lookup(version);
	for (i = 0; i < tab->nentries; i++) {
		if (key_equal(key, tab->identities[i].key)) {
			if (idx != NULL)
				*idx = i;
			return tab->identities[i].key;
		}
	}
	return NULL;
}

/* send list of supported public keys to 'client' */
void
process_request_identities(SocketEntry *e, int version)
{
	Idtab *tab = idtab_lookup(version);
d64 8
a71 17
	buffer_put_char(&msg, (version == 1) ?
	    SSH_AGENT_RSA_IDENTITIES_ANSWER : SSH2_AGENT_IDENTITIES_ANSWER);
	buffer_put_int(&msg, tab->nentries);
	for (i = 0; i < tab->nentries; i++) {
		Identity *id = &tab->identities[i];
		if (id->key->type == KEY_RSA) {
			buffer_put_int(&msg, BN_num_bits(id->key->rsa->n));
			buffer_put_bignum(&msg, id->key->rsa->e);
			buffer_put_bignum(&msg, id->key->rsa->n);
		} else {
			unsigned char *blob;
			unsigned int blen;
			dsa_make_key_blob(id->key, &blob, &blen);
			buffer_put_string(&msg, blob, blen);
			xfree(blob);
		}
		buffer_put_cstring(&msg, id->comment);
a77 1
/* ssh1 only */
d79 1
a79 1
process_authentication_challenge1(SocketEntry *e)
d81 2
a82 3
	Key *key, *private;
	BIGNUM *challenge;
	int i, len;
d89 2
a90 1
	key = key_new(KEY_RSA);
d92 3
a94 4

	buffer_get_int(&e->input);				/* ignored */
	buffer_get_bignum(&e->input, key->rsa->e);
	buffer_get_bignum(&e->input, key->rsa->n);
d96 45
d142 4
a145 32
	/* Only protocol 1.1 is supported */
	if (buffer_len(&e->input) == 0)
		goto failure;
	buffer_get(&e->input, (char *) session_id, 16);
	response_type = buffer_get_int(&e->input);
	if (response_type != 1)
		goto failure;

	private = lookup_private_key(key, NULL, 1);
	if (private != NULL) {
		/* Decrypt the challenge using the private key. */
		rsa_private_decrypt(challenge, challenge, private->rsa);

		/* The response is MD5 of decrypted challenge plus session id. */
		len = BN_num_bytes(challenge);
		if (len <= 0 || len > 32) {
			log("process_authentication_challenge: bad challenge length %d", len);
			goto failure;
		}
		memset(buf, 0, 32);
		BN_bn2bin(challenge, buf + 32 - len);
		MD5_Init(&md);
		MD5_Update(&md, buf, 32);
		MD5_Update(&md, session_id, 16);
		MD5_Final(mdbuf, &md);

		/* Send the response. */
		buffer_put_char(&msg, SSH_AGENT_RSA_RESPONSE);
		for (i = 0; i < 16; i++)
			buffer_put_char(&msg, mdbuf[i]);
		goto send;
	}
d147 3
a149 2
failure:
	/* Unknown identity or protocol error.  Send failure. */
a152 37
	buffer_append(&e->output, buffer_ptr(&msg), buffer_len(&msg));
	key_free(key);
	BN_clear_free(challenge);
	buffer_free(&msg);
}

/* ssh2 only */
void
process_sign_request2(SocketEntry *e)
{
	extern int datafellows;
	Key *key, *private;
	unsigned char *blob, *data, *signature = NULL;
	unsigned int blen, dlen, slen = 0;
	Buffer msg;
	int ok = -1;

	datafellows = 0;
	
	blob = buffer_get_string(&e->input, &blen);
	data = buffer_get_string(&e->input, &dlen);

	key = dsa_key_from_blob(blob, blen);
	if (key != NULL) {
		private = lookup_private_key(key, NULL, 2);
		if (private != NULL)
			ok = dsa_sign(private, &signature, &slen, data, dlen);
	}
	key_free(key);
	buffer_init(&msg);
	if (ok == 0) {
		buffer_put_char(&msg, SSH2_AGENT_SIGN_RESPONSE);
		buffer_put_string(&msg, signature, slen);
	} else {
		buffer_put_char(&msg, SSH_AGENT_FAILURE);
	}
	buffer_put_int(&e->output, buffer_len(&msg));
d154 1
a154 1
	    buffer_len(&msg));
d156 3
a158 4
	xfree(data);
	xfree(blob);
	if (signature != NULL)
		xfree(signature);
a160 1
/* shared */
d162 1
a162 1
process_remove_identity(SocketEntry *e, int version)
a163 3
	Key *key = NULL, *private;
	unsigned char *blob;
	unsigned int blen;
d165 5
a169 1
	int success = 0;
d171 12
a182 21
	switch(version){
	case 1:
		key = key_new(KEY_RSA);
		bits = buffer_get_int(&e->input);
		buffer_get_bignum(&e->input, key->rsa->e);
		buffer_get_bignum(&e->input, key->rsa->n);

		if (bits != key_size(key))
			log("Warning: identity keysize mismatch: actual %d, announced %d",
			      key_size(key), bits);
		break;
	case 2:
		blob = buffer_get_string(&e->input, &blen);
		key = dsa_key_from_blob(blob, blen);
		xfree(blob);
		break;
	}
	if (key != NULL) {
		int idx;
		private = lookup_private_key(key, &idx, version);
		if (private != NULL) {
d189 12
a200 7
			Idtab *tab = idtab_lookup(version);
			key_free(tab->identities[idx].key);
			xfree(tab->identities[idx].comment);
			if (idx != tab->nentries)
				tab->identities[idx] = tab->identities[tab->nentries];
			tab->nentries--;
			success = 1;
d202 5
a206 2
		key_free(key);
	}
d208 1
a208 2
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
d211 3
d215 1
a215 1
process_remove_all_identities(SocketEntry *e, int version)
a217 1
	Idtab *tab = idtab_lookup(version);
d220 3
a222 3
	for (i = 0; i < tab->nentries; i++) {
		key_free(tab->identities[i].key);
		xfree(tab->identities[i].comment);
d226 1
a226 1
	tab->nentries = 0;
d234 3
d238 1
a238 1
process_add_identity(SocketEntry *e, int version)
d240 2
a241 2
	Key *k = NULL;
	RSA *rsa;
a243 4
	char *type;
	char *comment;
	int success = 0;
	Idtab *tab = idtab_lookup(version);
d245 4
a248 28
	switch (version) {
	case 1:
		k = key_new(KEY_RSA);
		rsa = k->rsa;

		/* allocate mem for private key */
		/* XXX rsa->n and rsa->e are already allocated */
		rsa->d = BN_new();
		rsa->iqmp = BN_new();
		rsa->q = BN_new();
		rsa->p = BN_new();
		rsa->dmq1 = BN_new();
		rsa->dmp1 = BN_new();

		buffer_get_int(&e->input);		 /* ignored */

		buffer_get_bignum(&e->input, rsa->n);
		buffer_get_bignum(&e->input, rsa->e);
		buffer_get_bignum(&e->input, rsa->d);
		buffer_get_bignum(&e->input, rsa->iqmp);

		/* SSH and SSL have p and q swapped */
		buffer_get_bignum(&e->input, rsa->q);	/* p */
		buffer_get_bignum(&e->input, rsa->p);	/* q */

		/* Generate additional parameters */
		aux = BN_new();
		ctx = BN_CTX_new();
d250 43
a292 2
		BN_sub(aux, rsa->q, BN_value_one());
		BN_mod(rsa->dmq1, rsa->d, aux, ctx);
d294 4
a297 13
		BN_sub(aux, rsa->p, BN_value_one());
		BN_mod(rsa->dmp1, rsa->d, aux, ctx);

		BN_clear_free(aux);
		BN_CTX_free(ctx);

		break;
	case 2:
		type = buffer_get_string(&e->input, NULL);
		if (strcmp(type, KEX_DSS)) {
			buffer_clear(&e->input);
			xfree(type);
			goto send;
d299 2
a300 6
		xfree(type);

		k = key_new(KEY_DSA);

		/* allocate mem for private key */
		k->dsa->priv_key = BN_new();
d302 1
a302 30
		buffer_get_bignum2(&e->input, k->dsa->p);
		buffer_get_bignum2(&e->input, k->dsa->q);
		buffer_get_bignum2(&e->input, k->dsa->g);
		buffer_get_bignum2(&e->input, k->dsa->pub_key);
		buffer_get_bignum2(&e->input, k->dsa->priv_key);

		break;
	}

	comment = buffer_get_string(&e->input, NULL);
	if (k == NULL) {
		xfree(comment);
		goto send;
	}
	success = 1;
	if (lookup_private_key(k, NULL, version) == NULL) {
		if (tab->nentries == 0)
			tab->identities = xmalloc(sizeof(Identity));
		else
			tab->identities = xrealloc(tab->identities,
			    (tab->nentries + 1) * sizeof(Identity));
		tab->identities[tab->nentries].key = k;
		tab->identities[tab->nentries].comment = comment;
		/* Increment the number of identities. */
		tab->nentries++;
	} else {
		key_free(k);
		xfree(comment);
	}
send:
d304 1
a304 2
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
a306 2
/* dispatch incoming messages */

d329 3
a331 1
	/* ssh1 */
d333 1
a333 4
		process_authentication_challenge1(e);
		break;
	case SSH_AGENTC_REQUEST_RSA_IDENTITIES:
		process_request_identities(e, 1);
d336 1
a336 1
		process_add_identity(e, 1);
d339 1
a339 1
		process_remove_identity(e, 1);
d342 1
a342 17
		process_remove_all_identities(e, 1);
		break;
	/* ssh2 */
	case SSH2_AGENTC_SIGN_REQUEST:
		process_sign_request2(e);
		break;
	case SSH2_AGENTC_REQUEST_IDENTITIES:
		process_request_identities(e, 2);
		break;
	case SSH2_AGENTC_ADD_IDENTITY:
		process_add_identity(e, 2);
		break;
	case SSH2_AGENTC_REMOVE_IDENTITY:
		process_remove_identity(e, 2);
		break;
	case SSH2_AGENTC_REMOVE_ALL_IDENTITIES:
		process_remove_all_identities(e, 2);
a642 1
	idtab_init();
@


1.31.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.37 2000/09/21 11:07:51 markus Exp $	*/
d7 1
a9 6
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
a11 20
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d15 1
a15 1
RCSID("$OpenBSD: ssh-agent.c,v 1.37 2000/09/21 11:07:51 markus Exp $");
a33 1
#include "compat.h"
a210 1
	int flags;
a218 4
	flags = buffer_get_int(&e->input);
	if (flags & SSH_AGENT_OLD_SIGNATURE)
		datafellows = SSH_BUG_SIGBLOB;

d748 2
a749 5
		if (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||
		    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {
			perror("setenv");
			exit(1);
		}
@


1.31.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.50 2001/02/08 19:30:52 itojun Exp $	*/
d40 1
a40 4
RCSID("$OpenBSD: ssh-agent.c,v 1.50 2001/02/08 19:30:52 itojun Exp $");

#include <openssl/evp.h>
#include <openssl/md5.h>
d50 5
d57 1
a57 1
#include "cipher.h"
a59 1
#include "log.h"
d70 1
a70 1
u_int sockets_alloc = 0;
a96 2
int	prepare_select(fd_set **, fd_set **, int *);

d146 1
a146 1
		if (id->key->type == KEY_RSA1) {
d151 3
a153 3
			u_char *blob;
			u_int blen;
			key_to_blob(id->key, &blob, &blen);
d173 2
a174 2
	u_char buf[32], mdbuf[16], session_id[16];
	u_int response_type;
d177 1
a177 1
	key = key_new(KEY_RSA1);
d196 1
a196 2
		if (rsa_private_decrypt(challenge, challenge, private->rsa) <= 0)
			goto failure;
d235 2
a236 2
	u_char *blob, *data, *signature = NULL;
	u_int blen, dlen, slen = 0;
d242 1
a242 1

d250 1
a250 1
	key = key_from_blob(blob, blen);
d254 1
a254 1
			ok = key_sign(private, &signature, &slen, data, dlen);
d279 3
a281 3
	u_char *blob;
	u_int blen;
	u_int bits;
d286 1
a286 1
		key = key_new(KEY_RSA1);
d293 1
a293 1
			    key_size(key), bits);
d297 1
a297 1
		key = key_from_blob(blob, blen);
d308 2
a309 3
			 * the array, we actually free the key there and move
			 * all the entries between the empty slot and the end
			 * of the array.
d314 2
a315 11
			if (tab->nentries < 1)
				fatal("process_remove_identity: "
				    "internal error: tab->nentries %d",
				    tab->nentries);
			if (idx != tab->nentries - 1) {
				int i;
				for (i = idx; i < tab->nentries - 1; i++)
					tab->identities[i] = tab->identities[i+1];
			}
			tab->identities[tab->nentries - 1].key = NULL;
			tab->identities[tab->nentries - 1].comment = NULL;
d329 1
a329 1
	u_int i;
d348 1
a348 1
generate_additional_parameters(RSA *rsa)
d350 2
d354 1
a354 19
	/* Generate additional parameters */
	aux = BN_new();
	ctx = BN_CTX_new();

	BN_sub(aux, rsa->q, BN_value_one());
	BN_mod(rsa->dmq1, rsa->d, aux, ctx);

	BN_sub(aux, rsa->p, BN_value_one());
	BN_mod(rsa->dmp1, rsa->d, aux, ctx);

	BN_clear_free(aux);
	BN_CTX_free(ctx);
}

void
process_add_identity(SocketEntry *e, int version)
{
	Key *k = NULL;
	char *type_name;
d356 1
a356 1
	int type, success = 0;
d361 18
a378 6
		k = key_new_private(KEY_RSA1);
		buffer_get_int(&e->input);			/* ignored */
		buffer_get_bignum(&e->input, k->rsa->n);
		buffer_get_bignum(&e->input, k->rsa->e);
		buffer_get_bignum(&e->input, k->rsa->d);
		buffer_get_bignum(&e->input, k->rsa->iqmp);
d381 2
a382 2
		buffer_get_bignum(&e->input, k->rsa->q);	/* p */
		buffer_get_bignum(&e->input, k->rsa->p);	/* q */
d385 12
a396 1
		generate_additional_parameters(k->rsa);
d399 2
a400 25
		type_name = buffer_get_string(&e->input, NULL);
		type = key_type_from_name(type_name);
		xfree(type_name);
		switch(type) {
		case KEY_DSA:
			k = key_new_private(type);
			buffer_get_bignum2(&e->input, k->dsa->p);
			buffer_get_bignum2(&e->input, k->dsa->q);
			buffer_get_bignum2(&e->input, k->dsa->g);
			buffer_get_bignum2(&e->input, k->dsa->pub_key);
			buffer_get_bignum2(&e->input, k->dsa->priv_key);
			break;
		case KEY_RSA:
			k = key_new_private(type);
			buffer_get_bignum2(&e->input, k->rsa->n);
			buffer_get_bignum2(&e->input, k->rsa->e);
			buffer_get_bignum2(&e->input, k->rsa->d);
			buffer_get_bignum2(&e->input, k->rsa->iqmp);
			buffer_get_bignum2(&e->input, k->rsa->p);
			buffer_get_bignum2(&e->input, k->rsa->q);

			/* Generate additional parameters */
			generate_additional_parameters(k->rsa);
			break;
		default:
d402 1
d405 13
d420 1
d452 3
a454 3
	u_int msg_len;
	u_int type;
	u_char *cp;
d457 1
a457 1
	cp = (u_char *) buffer_ptr(&e->input);
d516 1
a516 1
	u_int i, old_alloc;
d545 2
a546 2
int
prepare_select(fd_set **fdrp, fd_set **fdwp, int *fdl)
d548 2
a549 4
	u_int i, sz;
	int n = 0;

	for (i = 0; i < sockets_alloc; i++) {
d553 3
a555 1
			n = MAX(n, sockets[i].fd);
a562 28
	}

	sz = howmany(n+1, NFDBITS) * sizeof(fd_mask);
	if (*fdrp == NULL || n > *fdl) {
		if (*fdrp)
			free(*fdrp);
		if (*fdwp)
			free(*fdwp);
		*fdrp = xmalloc(sz);
		*fdwp = xmalloc(sz);
		*fdl = n;
	}
	memset(*fdrp, 0, sz);
	memset(*fdwp, 0, sz);

	for (i = 0; i < sockets_alloc; i++) {
		switch (sockets[i].type) {
		case AUTH_SOCKET:
		case AUTH_CONNECTION:
			FD_SET(sockets[i].fd, *fdrp);
			if (buffer_len(&sockets[i].output) > 0)
				FD_SET(sockets[i].fd, *fdwp);
			break;
		default:
			break;
		}
	}
	return (1);
d568 1
a568 1
	u_int i;
d581 1
a581 2
				sock = accept(sockets[i].fd,
				    (struct sockaddr *) &sunaddr, &slen);
d592 2
a593 3
				len = write(sockets[i].fd,
				    buffer_ptr(&sockets[i].output),
				    buffer_len(&sockets[i].output));
a625 2
	int save_errno = errno;

a631 1
	errno = save_errno;
d637 2
a638 4
	if (socket_name[0])
		unlink(socket_name);
	if (socket_dir[0])
		rmdir(socket_dir);
d649 1
a649 8
cleanup_handler(int sig)
{
	cleanup_socket();
	_exit(2);
}

void
usage(void)
d653 1
a653 1
	    __progname);
d660 1
a662 1
	struct rlimit rlim;
a664 2
	extern int optind;
	fd_set *readsetp = NULL, *writesetp = NULL;
d666 7
d707 1
a707 1
			    SSH_AGENTPID_ENV_NAME);
d711 2
a712 1
		if (pid < 1) {
d714 1
a714 1
			    SSH_AGENTPID_ENV_NAME, pidstr);
d736 1
a736 1
	    parent_pid);
a757 1

d773 1
a773 1
			    SSH_AUTHSOCKET_ENV_NAME);
d775 1
a775 1
			    SSH_AGENTPID_ENV_NAME);
a791 6
	/* deny core dumps, since memory contains unencrypted private keys */
	rlim.rlim_cur = rlim.rlim_max = 0;
	if (setrlimit(RLIMIT_CORE, &rlim) < 0) {
		perror("setrlimit rlimit_core failed");
		cleanup_exit(1);
	}
d808 2
a809 2
	signal(SIGHUP, cleanup_handler);
	signal(SIGTERM, cleanup_handler);
d811 4
a814 2
		prepare_select(&readsetp, &writesetp, &max_fd);
		if (select(max_fd + 1, readsetp, writesetp, NULL, NULL) < 0) {
d819 1
a819 1
		after_select(readsetp, writesetp);
@


1.31.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.52 2001/03/06 00:33:04 deraadt Exp $	*/
d16 1
a16 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d40 1
a40 1
RCSID("$OpenBSD: ssh-agent.c,v 1.52 2001/03/06 00:33:04 deraadt Exp $");
d634 3
a636 9
				do {
					len = write(sockets[i].fd,
					    buffer_ptr(&sockets[i].output),
					    buffer_len(&sockets[i].output));
					if (len == -1 && (errno == EAGAIN ||
					    errno == EINTR))
						continue;
					break;
				} while (1);
d648 1
a648 7
				do {
					len = read(sockets[i].fd, buf, sizeof(buf));
					if (len == -1 && (errno == EAGAIN ||
					    errno == EINTR))
						continue;
					break;
				} while (1);
@


1.30
log
@Fix memory leak per connection. Report from Andy Spiegl <Andy@@Spiegl.de>
via Debian bug #59926
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.29 2000/04/19 07:05:49 deraadt Exp $	*/
d12 1
a12 1
RCSID("$OpenBSD: ssh-agent.c,v 1.29 2000/04/19 07:05:49 deraadt Exp $");
d177 1
a177 1
		error("Warning: identity keysize mismatch: actual %d, announced %d",
@


1.29
log
@pid_t
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.28 2000/04/14 10:30:33 markus Exp $	*/
d12 1
a12 1
RCSID("$OpenBSD: ssh-agent.c,v 1.28 2000/04/14 10:30:33 markus Exp $");
d439 2
d451 2
@


1.28
log
@whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.27 2000/04/12 09:39:10 markus Exp $	*/
d12 1
a12 1
RCSID("$OpenBSD: ssh-agent.c,v 1.27 2000/04/12 09:39:10 markus Exp $");
d49 1
a49 1
int parent_pid = -1;
d463 1
a463 1
	if (kill(parent_pid, 0) < 0) {
d549 1
@


1.27
log
@#include <ssl/foo.h> -> <openssh/foo.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.26 2000/03/16 20:56:14 markus Exp $	*/
d12 1
a12 1
RCSID("$OpenBSD: ssh-agent.c,v 1.26 2000/03/16 20:56:14 markus Exp $");
d406 1
a406 1
void 
d640 2
a641 2
	signal(SIGHUP, cleanup_exit);                                          
	signal(SIGTERM, cleanup_exit);                                          
@


1.26
log
@-pedantic: signed vs. unsigned, void*-arithm, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.25 2000/01/02 21:51:03 markus Exp $	*/
d12 1
a12 1
RCSID("$OpenBSD: ssh-agent.c,v 1.25 2000/01/02 21:51:03 markus Exp $");
d24 1
a24 1
#include <ssl/md5.h>
@


1.25
log
@cleanup_exit() for SIGTERM/SIGHUP, too. from fgsch@@ and dgaudet@@arctic.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.24 1999/12/15 19:43:10 markus Exp $	*/
d12 1
a12 1
RCSID("$OpenBSD: ssh-agent.c,v 1.24 1999/12/15 19:43:10 markus Exp $");
d411 1
d421 2
a422 2
				len = sizeof(sunaddr);
				sock = accept(sockets[i].fd, (struct sockaddr *) & sunaddr, &len);
@


1.24
log
@keysize warnings talk about identity files
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.23 1999/11/24 19:53:51 markus Exp $	*/
d12 1
a12 1
RCSID("$OpenBSD: ssh-agent.c,v 1.23 1999/11/24 19:53:51 markus Exp $");
d639 2
@


1.23
log
@KNF, final part 3
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.22 1999/11/24 00:26:03 deraadt Exp $	*/
d12 1
a12 1
RCSID("$OpenBSD: ssh-agent.c,v 1.22 1999/11/24 00:26:03 deraadt Exp $");
d177 1
a177 1
		error("Warning: keysize mismatch: actual %d, announced %d",
@


1.22
log
@much more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.21 1999/11/23 22:25:55 markus Exp $	*/
d12 1
a12 1
RCSID("$OpenBSD: ssh-agent.c,v 1.21 1999/11/23 22:25:55 markus Exp $");
d183 6
a188 4
			/* We have this key.  Free the old key.  Since we
			   don\'t want to leave empty slots in the middle
			   of the array, we actually free the key there
			   and copy data from the last entry. */
d287 4
a290 2
			/* We already have this key.  Clear and free the
			   new data and return success. */
d573 4
a576 2
	/* Create socket early so it will exist before command gets run
	   from the parent.  */
d593 4
a596 3
	/* Fork, and have the parent execute the command, if any, or
	   present the socket data.  The child continues as the
	   authentication agent. */
@


1.21
log
@KNF part 1
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.20 1999/11/19 10:20:51 markus Exp $	*/
d4 6
a9 13

ssh-agent.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Wed Mar 29 03:46:59 1995 ylo

The authentication agent program.

*/
d12 1
a12 1
RCSID("$OpenBSD: ssh-agent.c,v 1.20 1999/11/19 10:20:51 markus Exp $");
d209 3
a211 2
/* Removes all identities from the agent. */

d232 3
a234 2
/* Adds an identity to the agent. */

@


1.20
log
@only one 'extern char *__progname'
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.19 1999/11/18 14:00:49 markus Exp $	*/
d19 1
a19 1
RCSID("$OpenBSD: ssh-agent.c,v 1.19 1999/11/18 14:00:49 markus Exp $");
d33 7
a39 6
typedef struct
{
  int fd;
  enum { AUTH_UNUSED, AUTH_SOCKET, AUTH_CONNECTION } type;
  Buffer input;
  Buffer output;
d45 3
a47 4
typedef struct
{
  RSA *key;
  char *comment;
d67 2
a68 2
  Buffer msg;
  int i;
d70 13
a82 14
  buffer_init(&msg);
  buffer_put_char(&msg, SSH_AGENT_RSA_IDENTITIES_ANSWER);
  buffer_put_int(&msg, num_identities);
  for (i = 0; i < num_identities; i++)
    {
      buffer_put_int(&msg, BN_num_bits(identities[i].key->n));
      buffer_put_bignum(&msg, identities[i].key->e);
      buffer_put_bignum(&msg, identities[i].key->n);
      buffer_put_string(&msg, identities[i].comment, 
			strlen(identities[i].comment));
    }
  buffer_put_int(&e->output, buffer_len(&msg));
  buffer_append(&e->output, buffer_ptr(&msg), buffer_len(&msg));
  buffer_free(&msg);
d88 78
a165 84
  int i, pub_bits, len;
  BIGNUM *pub_e, *pub_n, *challenge;
  Buffer msg;
  MD5_CTX md;
  unsigned char buf[32], mdbuf[16], session_id[16];
  unsigned int response_type;

  buffer_init(&msg);
  pub_e = BN_new();
  pub_n = BN_new();
  challenge = BN_new();
  pub_bits = buffer_get_int(&e->input);
  buffer_get_bignum(&e->input, pub_e);
  buffer_get_bignum(&e->input, pub_n);
  buffer_get_bignum(&e->input, challenge);
  if (buffer_len(&e->input) == 0)
    {
      /* Compatibility code for old servers. */
      memset(session_id, 0, 16);
      response_type = 0;
    }
  else
    {
      /* New code. */
      buffer_get(&e->input, (char *)session_id, 16);
      response_type = buffer_get_int(&e->input);
    }
  for (i = 0; i < num_identities; i++)
    if (pub_bits == BN_num_bits(identities[i].key->n) &&
	BN_cmp(pub_e, identities[i].key->e) == 0 &&
	BN_cmp(pub_n, identities[i].key->n) == 0)
      {
	/* Decrypt the challenge using the private key. */
	rsa_private_decrypt(challenge, challenge, identities[i].key);

	/* Compute the desired response. */
	switch (response_type)
	  {
	  case 0: /* As of protocol 1.0 */
	    /* This response type is no longer supported. */
	    log("Compatibility with ssh protocol 1.0 no longer supported.");
	    buffer_put_char(&msg, SSH_AGENT_FAILURE);
	    goto send;

	  case 1: /* As of protocol 1.1 */
	    /* The response is MD5 of decrypted challenge plus session id. */
	    len = BN_num_bytes(challenge);

	    if (len <= 0 || len > 32) {
	      fatal("process_authentication_challenge: "
		    "bad challenge length %d", len);
	    }

	    memset(buf, 0, 32);
	    BN_bn2bin(challenge, buf + 32 - len);
	    MD5_Init(&md);
	    MD5_Update(&md, buf, 32);
	    MD5_Update(&md, session_id, 16);
	    MD5_Final(mdbuf, &md);
	    break;

	  default:
	    fatal("process_authentication_challenge: bad response_type %d", 
		  response_type);
	    break;
	  }

	/* Send the response. */
	buffer_put_char(&msg, SSH_AGENT_RSA_RESPONSE);
	for (i = 0; i < 16; i++)
	  buffer_put_char(&msg, mdbuf[i]);

	goto send;
      }
  /* Unknown identity.  Send failure. */
  buffer_put_char(&msg, SSH_AGENT_FAILURE);
 send:
  buffer_put_int(&e->output, buffer_len(&msg));
  buffer_append(&e->output, buffer_ptr(&msg),
		buffer_len(&msg));
  buffer_free(&msg);
  BN_clear_free(pub_e);
  BN_clear_free(pub_n);
  BN_clear_free(challenge);
d171 39
a209 30
  unsigned int bits;
  unsigned int i;
  BIGNUM *dummy, *n;
  
  dummy = BN_new();
  n = BN_new();
  
  /* Get the key from the packet. */
  bits = buffer_get_int(&e->input);
  buffer_get_bignum(&e->input, dummy);
  buffer_get_bignum(&e->input, n);

  if (bits != BN_num_bits(n))
    error("Warning: keysize mismatch: actual %d, announced %d",
	  BN_num_bits(n), bits);
  
  /* Check if we have the key. */
  for (i = 0; i < num_identities; i++)
    if (BN_cmp(identities[i].key->n, n) == 0)
      {
	/* We have this key.  Free the old key.  Since we don\'t want to leave
	   empty slots in the middle of the array, we actually free the
	   key there and copy data from the last entry. */
	RSA_free(identities[i].key);
	xfree(identities[i].comment);
	if (i < num_identities - 1)
	  identities[i] = identities[num_identities - 1];
	num_identities--;
	BN_clear_free(dummy);
	BN_clear_free(n);
d211 1
a211 1
	/* Send success. */
d213 1
a213 10
	buffer_put_char(&e->output, SSH_AGENT_SUCCESS);
	return;
      }
  /* We did not have the key. */
  BN_clear(dummy);
  BN_clear(n);

  /* Send failure. */
  buffer_put_int(&e->output, 1);
  buffer_put_char(&e->output, SSH_AGENT_FAILURE);
d221 15
a235 16
  unsigned int i;
  
  /* Loop over all identities and clear the keys. */
  for (i = 0; i < num_identities; i++)
    {
      RSA_free(identities[i].key);
      xfree(identities[i].comment);
    }

  /* Mark that there are no identities. */
  num_identities = 0;

  /* Send success. */
  buffer_put_int(&e->output, 1);
  buffer_put_char(&e->output, SSH_AGENT_SUCCESS);
  return;
d243 59
a301 52
  RSA *k;
  int i;
  BIGNUM *aux;
  BN_CTX *ctx;
  
  if (num_identities == 0)
    identities = xmalloc(sizeof(Identity));
  else
    identities = xrealloc(identities, (num_identities + 1) * sizeof(Identity));

  identities[num_identities].key = RSA_new();
  k = identities[num_identities].key;
  buffer_get_int(&e->input); /* bits */
  k->n = BN_new();
  buffer_get_bignum(&e->input, k->n);
  k->e = BN_new();
  buffer_get_bignum(&e->input, k->e);
  k->d = BN_new();
  buffer_get_bignum(&e->input, k->d);
  k->iqmp = BN_new();
  buffer_get_bignum(&e->input, k->iqmp);
  /* SSH and SSL have p and q swapped */
  k->q = BN_new();
  buffer_get_bignum(&e->input, k->q); /* p */
  k->p = BN_new();
  buffer_get_bignum(&e->input, k->p); /* q */

  /* Generate additional parameters */
  aux = BN_new();
  ctx = BN_CTX_new();

  BN_sub(aux, k->q, BN_value_one());
  k->dmq1 = BN_new();
  BN_mod(k->dmq1, k->d, aux, ctx);

  BN_sub(aux, k->p, BN_value_one());
  k->dmp1 = BN_new();
  BN_mod(k->dmp1, k->d, aux, ctx);

  BN_clear_free(aux);
  BN_CTX_free(ctx);
  
  identities[num_identities].comment = buffer_get_string(&e->input, NULL);

  /* Check if we already have the key. */
  for (i = 0; i < num_identities; i++)
    if (BN_cmp(identities[i].key->n, k->n) == 0)
      {
	/* We already have this key.  Clear and free the new data and
	   return success. */
	RSA_free(k);
	xfree(identities[num_identities].comment);
d303 1
a303 1
	/* Send success. */
a305 9
	return;
      }

  /* Increment the number of identities. */
  num_identities++;
  
  /* Send a success message. */
  buffer_put_int(&e->output, 1);
  buffer_put_char(&e->output, SSH_AGENT_SUCCESS);
d311 42
a352 44
  unsigned int msg_len;
  unsigned int type;
  unsigned char *cp;
  if (buffer_len(&e->input) < 5)
    return; /* Incomplete message. */
  cp = (unsigned char *)buffer_ptr(&e->input);
  msg_len = GET_32BIT(cp);
  if (msg_len > 256 * 1024)
    {
      shutdown(e->fd, SHUT_RDWR);
      close(e->fd);
      e->type = AUTH_UNUSED;
      return;
    }
  if (buffer_len(&e->input) < msg_len + 4)
    return;
  buffer_consume(&e->input, 4);
  type = buffer_get_char(&e->input);

  switch (type)
    {
    case SSH_AGENTC_REQUEST_RSA_IDENTITIES:
      process_request_identity(e);
      break;
    case SSH_AGENTC_RSA_CHALLENGE:
      process_authentication_challenge(e);
      break;
    case SSH_AGENTC_ADD_RSA_IDENTITY:
      process_add_identity(e);
      break;
    case SSH_AGENTC_REMOVE_RSA_IDENTITY:
      process_remove_identity(e);
      break;
    case SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES:
      process_remove_all_identities(e);
      break;
    default:
      /* Unknown message.  Respond with failure. */
      error("Unknown message %d", type);
      buffer_clear(&e->input);
      buffer_put_int(&e->output, 1);
      buffer_put_char(&e->output, SSH_AGENT_FAILURE);
      break;
    }
d358 27
a384 28
  unsigned int i, old_alloc;
  if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0)
    error("fcntl O_NONBLOCK: %s", strerror(errno));

  if (fd > max_fd)
    max_fd = fd;

  for (i = 0; i < sockets_alloc; i++)
    if (sockets[i].type == AUTH_UNUSED)
      {
	sockets[i].fd = fd;
	sockets[i].type = type;
	buffer_init(&sockets[i].input);
	buffer_init(&sockets[i].output);
	return;
      }
  old_alloc = sockets_alloc;
  sockets_alloc += 10;
  if (sockets)
    sockets = xrealloc(sockets, sockets_alloc * sizeof(sockets[0]));
  else
    sockets = xmalloc(sockets_alloc * sizeof(sockets[0]));
  for (i = old_alloc; i < sockets_alloc; i++)
    sockets[i].type = AUTH_UNUSED;
  sockets[old_alloc].type = type;
  sockets[old_alloc].fd = fd;
  buffer_init(&sockets[old_alloc].input);
  buffer_init(&sockets[old_alloc].output);
d390 68
a457 75
  unsigned int i;
  for (i = 0; i < sockets_alloc; i++)
    switch (sockets[i].type)
      {
      case AUTH_SOCKET:
      case AUTH_CONNECTION:
	FD_SET(sockets[i].fd, readset);
	if (buffer_len(&sockets[i].output) > 0)
	  FD_SET(sockets[i].fd, writeset);
	break;
      case AUTH_UNUSED:
	break;
      default:
	fatal("Unknown socket type %d", sockets[i].type);
	break;
      }
}

void after_select(fd_set *readset, fd_set *writeset)
{
  unsigned int i;
  int len, sock;
  char buf[1024];
  struct sockaddr_un sunaddr;

  for (i = 0; i < sockets_alloc; i++)
    switch (sockets[i].type)
      {
      case AUTH_UNUSED:
	break;
      case AUTH_SOCKET:
	if (FD_ISSET(sockets[i].fd, readset))
	  {
	    len = sizeof(sunaddr);
	    sock = accept(sockets[i].fd, (struct sockaddr *)&sunaddr, &len);
	    if (sock < 0)
	      {
		perror("accept from AUTH_SOCKET");
		break;
	      }
	    new_socket(AUTH_CONNECTION, sock);
	  }
	break;
      case AUTH_CONNECTION:
	if (buffer_len(&sockets[i].output) > 0 &&
	    FD_ISSET(sockets[i].fd, writeset))
	  {
	    len = write(sockets[i].fd, buffer_ptr(&sockets[i].output),
			buffer_len(&sockets[i].output));
	    if (len <= 0)
	      {
		shutdown(sockets[i].fd, SHUT_RDWR);
		close(sockets[i].fd);
		sockets[i].type = AUTH_UNUSED;
		break;
	      }
	    buffer_consume(&sockets[i].output, len);
	  }
	if (FD_ISSET(sockets[i].fd, readset))
	  {
	    len = read(sockets[i].fd, buf, sizeof(buf));
	    if (len <= 0)
	      {
		shutdown(sockets[i].fd, SHUT_RDWR);
		close(sockets[i].fd);
		sockets[i].type = AUTH_UNUSED;
		break;
	      }
	    buffer_append(&sockets[i].input, buf, len);
	    process_message(&sockets[i]);
	  }
	break;
      default:
	fatal("Unknown type %d", sockets[i].type);
      }
d463 6
a468 7
  if (kill(parent_pid, 0) < 0)
    {
      /* printf("Parent has died - Authentication agent exiting.\n"); */
      exit(1);
    }
  signal(SIGALRM, check_parent_exists);
  alarm(10);
d474 2
a475 2
  remove(socket_name);
  rmdir(socket_dir);
d481 2
a482 2
  cleanup_socket();
  exit(i);
d488 4
a491 4
  fprintf(stderr, "ssh-agent version %s\n", SSH_VERSION);
  fprintf(stderr, "Usage: %s [-c | -s] [-k] [command {args...]]\n",
	  __progname);
  exit(1);
d497 150
a646 33
  fd_set readset, writeset;
  int sock, c_flag = 0, k_flag = 0, s_flag = 0, ch;
  struct sockaddr_un sunaddr;
  pid_t pid;
  char *shell, *format, *pidstr, pidstrbuf[1 + 3 * sizeof pid];

  /* check if RSA support exists */
  if (rsa_alive() == 0) {
    fprintf(stderr,
      "%s: no RSA support in libssl and libcrypto.  See ssl(8).\n",
      __progname);
    exit(1);
  }

  while ((ch = getopt(ac, av, "cks")) != -1)
    {
      switch (ch)
	{
	case 'c':
	  if (s_flag)
	    usage();
	  c_flag++;
	  break;
	case 'k':
	  k_flag++;
	  break;
	case 's':
	  if (c_flag)
	    usage();
	  s_flag++;
	  break;
	default:
	  usage();
d648 1
a648 144
    }
  ac -= optind;
  av += optind;

  if (ac > 0 && (c_flag || k_flag || s_flag))
    usage();

  if (ac == 0 && !c_flag && !k_flag && !s_flag)
    {
      shell = getenv("SHELL");
      if (shell != NULL && strncmp(shell + strlen(shell) - 3, "csh", 3) == 0)
	c_flag = 1;
    }

  if (k_flag)
    {
      pidstr = getenv(SSH_AGENTPID_ENV_NAME);
      if (pidstr == NULL)
	{
	  fprintf(stderr, "%s not set, cannot kill agent\n",
		  SSH_AGENTPID_ENV_NAME);
	  exit(1);
	}
      pid = atoi(pidstr);
      if (pid < 1)		/* XXX PID_MAX check too */
	{
	  fprintf(stderr, "%s=\"%s\", which is not a good PID\n",
		  SSH_AGENTPID_ENV_NAME, pidstr);
	  exit(1);
	}
      if (kill(pid, SIGTERM) == -1)
	{
	  perror("kill");
	  exit(1);
	}
      format = c_flag ? "unsetenv %s;\n" : "unset %s;\n";
      printf(format, SSH_AUTHSOCKET_ENV_NAME);
      printf(format, SSH_AGENTPID_ENV_NAME);
      printf("echo Agent pid %d killed;\n", pid);
      exit(0);
    }

  parent_pid = getpid();

  /* Create private directory for agent socket */
  strlcpy(socket_dir, "/tmp/ssh-XXXXXXXX", sizeof socket_dir);
  if (mkdtemp(socket_dir) == NULL) {
      perror("mkdtemp: private socket dir");
      exit(1);
  }
  snprintf(socket_name, sizeof socket_name, "%s/agent.%d", socket_dir,
	   parent_pid);

  /* Create socket early so it will exist before command gets run from
     the parent.  */
  sock = socket(AF_UNIX, SOCK_STREAM, 0);
  if (sock < 0)
    {
      perror("socket");
      cleanup_exit(1);
    }
  memset(&sunaddr, 0, sizeof(sunaddr));
  sunaddr.sun_family = AF_UNIX;
  strlcpy(sunaddr.sun_path, socket_name, sizeof(sunaddr.sun_path));
  if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0)
    {
      perror("bind");
      cleanup_exit(1);
    }
  if (listen(sock, 5) < 0)
    {
      perror("listen");
      cleanup_exit(1);
    }

  /* Fork, and have the parent execute the command, if any, or present the
     socket data.  The child continues as the authentication agent. */
  pid = fork();
  if (pid == -1)
    {
      perror("fork");
      exit(1);
    }
  if (pid != 0)
    { /* Parent - execute the given command. */
      close(sock);
      snprintf(pidstrbuf, sizeof pidstrbuf, "%d", pid);
      if (ac == 0)
	{
	  format = c_flag ? "setenv %s %s;\n" : "%s=%s; export %s;\n";
	  printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
		 SSH_AUTHSOCKET_ENV_NAME);
	  printf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,
		 SSH_AGENTPID_ENV_NAME);
	  printf("echo Agent pid %d;\n", pid);
	  exit(0);
	}

      setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1);
      setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1);
      execvp(av[0], av);
      perror(av[0]);
      exit(1);
    }

  close(0);
  close(1);
  close(2);

  if (setsid() == -1)
    {
      perror("setsid");
      cleanup_exit(1);
    }

  if (atexit(cleanup_socket) < 0)
    {
      perror("atexit");
      cleanup_exit(1);
    }

  new_socket(AUTH_SOCKET, sock);
  if (ac > 0)
    {
      signal(SIGALRM, check_parent_exists);
      alarm(10);
    }

  signal(SIGINT, SIG_IGN);
  signal(SIGPIPE, SIG_IGN);
  while (1)
    {
      FD_ZERO(&readset);
      FD_ZERO(&writeset);
      prepare_select(&readset, &writeset);
      if (select(max_fd + 1, &readset, &writeset, NULL, NULL) < 0)
	{
	  if (errno == EINTR)
	    continue;
	  exit(1);
	}
      after_select(&readset, &writeset);
    }
  /*NOTREACHED*/
@


1.19
log
@more %d vs. %s in fmt-strings
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.18 1999/11/15 20:53:24 markus Exp $	*/
d19 1
a19 1
RCSID("$OpenBSD: ssh-agent.c,v 1.18 1999/11/15 20:53:24 markus Exp $");
d62 2
a508 2
  extern char *__progname;

a525 1
    extern char *__progname;
@


1.18
log
@the keysize of rsa-parameter 'n' is passed implizit,
a few more checks and warnings about 'pretended' keysizes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.17 1999/11/02 19:42:36 markus Exp $	*/
d19 1
a19 1
RCSID("$OpenBSD: ssh-agent.c,v 1.17 1999/11/02 19:42:36 markus Exp $");
d189 1
a189 1
    error("Warning: keysize mismatch: actual %d, announced %s",
@


1.17
log
@replace assert() with error, fatal or packet_disconnect
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.16 1999/10/28 20:41:23 markus Exp $	*/
d19 1
a19 1
RCSID("$OpenBSD: ssh-agent.c,v 1.16 1999/10/28 20:41:23 markus Exp $");
d187 4
@


1.16
log
@call setsid() regardless of argv[]
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh-agent.c,v 1.15 1999/10/28 08:43:10 markus Exp $	*/
d19 1
a19 1
RCSID("$OpenBSD: ssh-agent.c,v 1.15 1999/10/28 08:43:10 markus Exp $");
d134 6
a139 1
	    assert(len <= 32 && len);
@


1.15
log
@from niklas: Add -c -s and -k support, Create socket early to avoid race,
Don't let child access std{in,out,err}
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d19 1
a19 1
RCSID("$OpenBSD: ssh-agent.c,v 1.13 1999/10/27 16:37:45 deraadt Exp $");
d653 5
a657 2
  if (ac == 0 && setsid() == -1)
    cleanup_exit(1);
d660 4
a663 1
    cleanup_exit(1);
@


1.14
log
@ignore sigpipe, do not die if the client (ssh-add, ssh) dies, ok: niklas@@
@
text
@d1 2
d19 1
a19 1
RCSID("$Id: ssh-agent.c,v 1.13 1999/10/27 16:37:45 deraadt Exp $");
d481 3
a483 1
void cleanup_socket(void) {
d488 18
d510 1
a510 1
  int sock;
d512 2
d524 35
a558 1
  if (ac < 2)
d560 24
a583 3
      fprintf(stderr, "ssh-agent version %s\n", SSH_VERSION);
      fprintf(stderr, "Usage: %s command\n", av[0]);
      exit(1);
d594 2
a595 26
  snprintf(socket_name, sizeof socket_name, "%s/agent.%d", socket_dir, parent_pid);
  
  /* Fork, and have the parent execute the command.  The child continues as
     the authentication agent. */
  if (fork() != 0)
    { /* Parent - execute the given command. */
      setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1);
      execvp(av[1], av + 1);
      perror(av[1]);
      exit(1);
    }

  if (atexit(cleanup_socket) < 0) {
	perror("atexit");
	cleanup_socket();
	exit(1);
  }

  /* Create a new session and process group  */
  if (setsid() < 0) {
      perror("setsid failed");
      exit(1);
  }

  /* Ignore if a client dies while we are sending a reply */
  signal(SIGPIPE, SIG_IGN);
d597 2
d603 1
a603 1
      exit(1);
d611 1
a611 1
      exit(1);
d616 30
d648 11
d660 5
a664 2
  signal(SIGALRM, check_parent_exists);
  alarm(10);
d667 1
a676 1
	  perror("select");
@


1.13
log
@use libssl md5 routines
@
text
@d17 1
a17 1
RCSID("$Id: ssh-agent.c,v 1.12 1999/10/14 18:17:42 markus Exp $");
d532 9
@


1.12
log
@fix old connect() race security-bug for ssh-agent and agent-forwarding
by removing the connect() junk, with the following restrictions:
1) change the version to "OpenSSH-1.1":
   agent-forwarding will work only between OpenSSH-1.1 client and
   OpenSSH-1.1 server
2) renamed the environment variable of OpenSSH-1.1 to
   "SSH_AUTH_SOCKET", since useing OpenSSH-1.0 ssh-add against the new
   ssh-agent does not work
@
text
@d17 1
a17 1
RCSID("$Id: ssh-agent.c,v 1.11 1999/10/07 22:46:32 markus Exp $");
d29 1
a29 1
#include <md5.h>
d135 4
a138 4
	    MD5Init(&md);
	    MD5Update(&md, buf, 32);
	    MD5Update(&md, session_id, 16);
	    MD5Final(mdbuf, &md);
@


1.11
log
@You have Mail. Email fuer Dich. Karsten Patzwaldt <kpa@@gmx.net> default=no
@
text
@d17 1
a17 1
RCSID("$Id: ssh-agent.c,v 1.10 1999/10/05 22:18:52 markus Exp $");
d34 1
a34 2
  enum { AUTH_UNUSED, AUTH_FD, AUTH_SOCKET, AUTH_SOCKET_FD, 
    AUTH_CONNECTION } type;
d326 1
d394 1
a394 1
      case AUTH_FD:
a395 2
      case AUTH_SOCKET:
      case AUTH_SOCKET_FD:
d411 1
a411 1
  int len, sock, port;
a412 1
  struct sockaddr_in sin;
a419 33
      case AUTH_FD:
	if (FD_ISSET(sockets[i].fd, readset))
	  {
	    len = recv(sockets[i].fd, buf, sizeof(buf), 0);
	    if (len <= 0)
	      { /* All instances of the other side have been closed. */
		log("Authentication agent exiting.");
		exit(0);
	      }
	  process_auth_fd_input:
	    if (len != 3 || (unsigned char)buf[0] != SSH_AUTHFD_CONNECT)
	      break; /* Incorrect message; ignore it. */
	    /* It is a connection request message. */
	    port = (unsigned char)buf[1] * 256 + (unsigned char)buf[2];
	    memset(&sin, 0, sizeof(sin));
	    sin.sin_family = AF_INET;
	    sin.sin_addr.s_addr = htonl(0x7f000001); /* localhost */
	    sin.sin_port = htons(port);
	    sock = socket(AF_INET, SOCK_STREAM, 0);
	    if (sock < 0)
	      {
		perror("socket");
		break;
	      }
	    if (connect(sock, (struct sockaddr *)&sin, sizeof(sin)) < 0)
	      {
		perror("connecting to port requested in authfd message");
		close(sock);
		break;
	      }
	    new_socket(AUTH_CONNECTION, sock);
	  }
	break;
d430 1
a430 15
	    new_socket(AUTH_SOCKET_FD, sock);
	  }
	break;
      case AUTH_SOCKET_FD:
	if (FD_ISSET(sockets[i].fd, readset))
	  {
	    len = recv(sockets[i].fd, buf, sizeof(buf), 0);
	    if (len <= 0)
	      { /* The other side has closed the socket. */
		shutdown(sockets[i].fd, SHUT_RDWR);
		close(sockets[i].fd);
		sockets[i].type = AUTH_UNUSED;
		break;
	      }
	    goto process_auth_fd_input;
d521 1
a521 1
      setenv("SSH_AUTHENTICATION_SOCKET", socket_name, 1);
@


1.10
log
@move auth-sockets to private dir
delete minfd residua
@
text
@d17 1
a17 1
RCSID("$Id: ssh-agent.c,v 1.9 1999/10/04 20:45:01 markus Exp $");
d54 1
a54 1
/* pid of agent == parent of shell */
@


1.9
log
@nuke genminfd/AUTH_FD
@
text
@d17 1
a17 1
RCSID("$Id: ssh-agent.c,v 1.8 1999/10/03 19:22:38 deraadt Exp $");
d54 7
a516 3
int parent_pid = -1;
char socket_name[1024];

a521 1
      remove(socket_name);
d529 5
a537 2
  char buf[1024];
  int pfd;
a540 3
  int sockets[2], i;
  int *dups;

a543 1

a556 2
  /* The agent uses SSH_AUTHENTICATION_SOCKET. */
  
d558 8
a565 2
  
  snprintf(socket_name, sizeof socket_name, SSH_AGENT_SOCKET, parent_pid);
d571 1
a571 2
      snprintf(buf, sizeof buf, "SSH_AUTHENTICATION_SOCKET=%s", socket_name);
      putenv(buf);
d576 7
a582 1
  
a594 5
      exit(1);
    }
  if (chmod(socket_name, 0700) < 0)
    {
      perror("chmod");
@


1.8
log
@use SHUT_* symbols
@
text
@d17 1
a17 1
RCSID("$Id: ssh-agent.c,v 1.7 1999/09/30 17:08:52 deraadt Exp $");
d555 19
a573 2
  pfd = get_permanent_fd(NULL);
  if (pfd < 0) 
d575 20
a594 92
      /* The agent uses SSH_AUTHENTICATION_SOCKET. */
      
      parent_pid = getpid();
      
      snprintf(socket_name, sizeof socket_name, SSH_AGENT_SOCKET, parent_pid);
      
      /* Fork, and have the parent execute the command.  The child continues as
	 the authentication agent. */
      if (fork() != 0)
	{ /* Parent - execute the given command. */
	  snprintf(buf, sizeof buf, "SSH_AUTHENTICATION_SOCKET=%s", socket_name);
	  putenv(buf);
	  execvp(av[1], av + 1);
	  perror(av[1]);
	  exit(1);
	}
      
      sock = socket(AF_UNIX, SOCK_STREAM, 0);
      if (sock < 0)
	{
	  perror("socket");
	  exit(1);
	}
      memset(&sunaddr, 0, sizeof(sunaddr));
      sunaddr.sun_family = AF_UNIX;
      strlcpy(sunaddr.sun_path, socket_name, sizeof(sunaddr.sun_path));
      if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0)
	{
	  perror("bind");
	  exit(1);
	}
      if (chmod(socket_name, 0700) < 0)
	{
	  perror("chmod");
	  exit(1);
	}
      if (listen(sock, 5) < 0)
	{
	  perror("listen");
	  exit(1);
	}
      new_socket(AUTH_SOCKET, sock);
      signal(SIGALRM, check_parent_exists);
      alarm(10);
    }
  else 
    {
      /* The agent uses SSH_AUTHENTICATION_FD. */
      int cnt, newfd;
      
      dups = xmalloc(sizeof (int) * (1 + pfd));
      
      if (socketpair(AF_UNIX, SOCK_STREAM, 0, sockets) < 0)
	{
	  perror("socketpair");
	  exit(1);
	}

      /* Dup some descriptors to get the authentication fd to pfd,
	 because some shells arbitrarily close descriptors below that.
	 Don't use dup2 because maybe some systems don't have it?? */
      for (cnt = 0;; cnt++) {
	if ((dups[cnt] = dup(0)) < 0)
	  fatal("auth_input_request_forwarding: dup failed");
	if (dups[cnt] == pfd)
	  break;
      }
      close(dups[cnt]);
      
      /* Move the file descriptor we pass to children up high where
	 the shell won't close it. */
      newfd = dup(sockets[1]);
      if (newfd != pfd)
	fatal("auth_input_request_forwarding: dup didn't return %d.", pfd);
      close(sockets[1]);
      sockets[1] = newfd;
      /* Close duped descriptors. */
      for (i = 0; i < cnt; i++)
	close(dups[i]);
      free(dups);
      
      if (fork() != 0)
	{ /* Parent - execute the given command. */
	  close(sockets[0]);
	  snprintf(buf, sizeof buf, "SSH_AUTHENTICATION_FD=%d", sockets[1]);
	  putenv(buf);
	  execvp(av[1], av + 1);
	  perror(av[1]);
	  exit(1);
	}
      close(sockets[1]);
      new_socket(AUTH_FD, sockets[0]);
d596 3
@


1.7
log
@use libc md5
@
text
@d17 1
a17 1
RCSID("$Id: ssh-agent.c,v 1.6 1999/09/30 08:34:25 deraadt Exp $");
d311 1
a311 1
      shutdown(e->fd, 2);
d468 1
a468 1
		shutdown(sockets[i].fd, 2);
d484 1
a484 1
		shutdown(sockets[i].fd, 2);
d496 1
a496 1
		shutdown(sockets[i].fd, 2);
@


1.6
log
@even smaller
@
text
@d17 1
a17 1
RCSID("$Id: ssh-agent.c,v 1.5 1999/09/30 05:11:29 deraadt Exp $");
a25 1
#include "ssh_md5.h"
d29 2
d82 1
a82 1
  struct MD5Context md;
@


1.5
log
@do not bother with dinosaur pacification
@
text
@d17 1
a17 1
RCSID("$Id: ssh-agent.c,v 1.4 1999/09/29 21:14:16 deraadt Exp $");
d512 1
a512 1
RETSIGTYPE
d583 1
a583 1
      if (bind(sock, (struct sockaddr *)&sunaddr, AF_UNIX_SIZE(sunaddr)) < 0)
@


1.4
log
@numerous sprintf, strncpy, strcpy cleanups
@
text
@d17 1
a17 1
RCSID("$Id: ssh-agent.c,v 1.3 1999/09/29 06:15:00 deraadt Exp $");
a349 1
#if defined(O_NONBLOCK) && !defined(O_NONBLOCK_BROKEN)
a351 4
#else /* O_NONBLOCK && !O_NONBLOCK_BROKEN */
  if (fcntl(fd, F_SETFL, O_NDELAY) < 0)
    error("fcntl O_NDELAY: %s", strerror(errno));
#endif /* O_NONBLOCK && !O_NONBLOCK_BROKEN */
@


1.3
log
@test for RSA in the ssl library, real early on
@
text
@d17 1
a17 1
RCSID("$Id: ssh-agent.c,v 1.2 1999/09/28 04:45:37 provos Exp $");
d566 1
a566 1
      sprintf(socket_name, SSH_AGENT_SOCKET, parent_pid);
d572 1
a572 1
	  sprintf(buf, "SSH_AUTHENTICATION_SOCKET=%s", socket_name);
d587 1
a587 1
      strncpy(sunaddr.sun_path, socket_name, sizeof(sunaddr.sun_path));
d646 1
a646 1
	  sprintf(buf, "SSH_AUTHENTICATION_FD=%d", sockets[1]);
@


1.2
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d17 1
a17 1
RCSID("$Id: ssh-agent.c,v 1.3 1999/05/04 11:59:14 bg Exp $");
d541 10
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@a20 1
#include "randoms.h"
d44 1
a44 1
  RSAPrivateKey key;
d53 2
a54 1
void process_request_identity(SocketEntry *e)
d64 3
a66 3
      buffer_put_int(&msg, identities[i].key.bits);
      buffer_put_mp_int(&msg, &identities[i].key.e);
      buffer_put_mp_int(&msg, &identities[i].key.n);
d75 2
a76 1
void process_authentication_challenge(SocketEntry *e)
d78 2
a79 2
  int i, pub_bits;
  MP_INT pub_e, pub_n, challenge;
d86 3
a88 3
  mpz_init(&pub_e);
  mpz_init(&pub_n);
  mpz_init(&challenge);
d90 3
a92 3
  buffer_get_mp_int(&e->input, &pub_e);
  buffer_get_mp_int(&e->input, &pub_n);
  buffer_get_mp_int(&e->input, &challenge);
d106 3
a108 3
    if (pub_bits == identities[i].key.bits &&
	mpz_cmp(&pub_e, &identities[i].key.e) == 0 &&
	mpz_cmp(&pub_n, &identities[i].key.n) == 0)
d111 1
a111 1
	rsa_private_decrypt(&challenge, &challenge, &identities[i].key);
d124 4
a127 1
	    mp_linearize_msb_first(buf, 32, &challenge);
d154 3
a156 3
  mpz_clear(&pub_e);
  mpz_clear(&pub_n);
  mpz_clear(&challenge);
d159 2
a160 1
void process_remove_identity(SocketEntry *e)
a162 1
  MP_INT dummy, n;
d164 1
d166 2
a167 2
  mpz_init(&dummy);
  mpz_init(&n);
d171 2
a172 2
  buffer_get_mp_int(&e->input, &dummy);
  buffer_get_mp_int(&e->input, &n);
d176 1
a176 1
    if (mpz_cmp(&identities[i].key.n, &n) == 0)
d181 1
a181 1
	rsa_clear_private_key(&identities[i].key);
d186 2
a187 2
	mpz_clear(&dummy);
	mpz_clear(&n);
d195 2
a196 2
  mpz_clear(&dummy);
  mpz_clear(&n);
d205 2
a206 1
void process_remove_all_identities(SocketEntry *e)
d213 1
a213 1
      rsa_clear_private_key(&identities[i].key);
d228 2
a229 1
void process_add_identity(SocketEntry *e)
d231 1
a231 1
  RSAPrivateKey *k;
d233 3
a235 1

d240 33
a272 14
  k = &identities[num_identities].key;
  k->bits = buffer_get_int(&e->input);
  mpz_init(&k->n);
  buffer_get_mp_int(&e->input, &k->n);
  mpz_init(&k->e);
  buffer_get_mp_int(&e->input, &k->e);
  mpz_init(&k->d);
  buffer_get_mp_int(&e->input, &k->d);
  mpz_init(&k->u);
  buffer_get_mp_int(&e->input, &k->u);
  mpz_init(&k->p);
  buffer_get_mp_int(&e->input, &k->p);
  mpz_init(&k->q);
  buffer_get_mp_int(&e->input, &k->q);
d277 1
a277 1
    if (mpz_cmp(&identities[i].key.n, &k->n) == 0)
d281 1
a281 1
	rsa_clear_private_key(k);
d298 2
a299 1
void process_message(SocketEntry *e)
d346 2
a347 1
void new_socket(int type, int fd)
d384 2
a385 1
void prepare_select(fd_set *readset, fd_set *writeset)
d517 2
a518 1
RETSIGTYPE check_parent_exists(int sig)
d530 2
a531 1
int main(int ac, char **av)
@

