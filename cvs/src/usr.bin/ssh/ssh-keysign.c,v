head	1.52;
access;
symbols
	OPENBSD_6_0:1.52.0.6
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.49.0.2
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.36.0.10
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.8
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.6
	OPENBSD_5_0:1.36.0.4
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.16
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.12
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.10
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.8
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.6
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.4
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.18.0.6
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_0:1.4.0.2;
locks; strict;
comment	@ * @;


1.52
date	2016.02.15.09.47.49;	author dtucker;	state Exp;
branches;
next	1.51;
commitid	ut5A0buLh4mhCTFu;

1.51
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.50;
commitid	K3glY441IowbrjDE;

1.50
date	2015.11.29.22.18.37;	author djm;	state Exp;
branches;
next	1.49;
commitid	8pLnILak21kFcR9O;

1.49
date	2015.07.03.03.56.25;	author djm;	state Exp;
branches;
next	1.48;
commitid	QHqIB0DOET8XueE7;

1.48
date	2015.03.24.20.09.11;	author markus;	state Exp;
branches;
next	1.47;
commitid	ZHICYD2srrA8TFJS;

1.47
date	2015.01.28.22.36.00;	author djm;	state Exp;
branches;
next	1.46;
commitid	P7KG9D8zB61mMUPV;

1.46
date	2015.01.15.09.40.00;	author djm;	state Exp;
branches;
next	1.45;
commitid	akRUKeZEbb3ylbKG;

1.45
date	2015.01.08.10.14.08;	author djm;	state Exp;
branches;
next	1.44;
commitid	397Wklb10N5bP6VW;

1.44
date	2014.12.21.22.27.56;	author djm;	state Exp;
branches;
next	1.43;
commitid	EbtriidyZdsmXksl;

1.43
date	2014.10.08.22.20.25;	author djm;	state Exp;
branches;
next	1.42;
commitid	FjkSE9L51UbRANmo;

1.42
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2014.04.19.14.53.48;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2014.04.01.02.05.27;	author djm;	state Exp;
branches;
next	1.39;

1.39
date	2013.12.06.13.39.49;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2013.10.14.22.22.04;	author djm;	state Exp;
branches;
next	1.37;

1.37
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.36;

1.36
date	2011.02.16.00.31.14;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2010.08.31.12.33.38;	author djm;	state Exp;
branches;
next	1.34;

1.34
date	2010.08.16.04.06.06;	author djm;	state Exp;
branches;
next	1.33;

1.33
date	2010.08.12.23.34.39;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2010.08.04.06.08.40;	author djm;	state Exp;
branches;
next	1.31;

1.31
date	2010.08.04.05.42.47;	author djm;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.13.01.20.20;	author dtucker;	state Exp;
branches;
next	1.29;

1.29
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.27;

1.27
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.26;

1.26
date	2006.07.17.01.31.10;	author stevesk;	state Exp;
branches;
next	1.25;

1.25
date	2006.07.09.15.15.11;	author stevesk;	state Exp;
branches;
next	1.24;

1.24
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.02.08.34.52;	author dtucker;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2006.02.08.12.15.27;	author stevesk;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2005.09.13.23.40.07;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.23.14.29.23;	author dtucker;	state Exp;
branches
	1.18.4.1
	1.18.6.1;
next	1.17;

1.17
date	2004.08.23.14.26.38;	author dtucker;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.18.23.10.26;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.19.21.25.15;	author markus;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2003.11.17.09.45.39;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.03.08.09.06;	author djm;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2003.05.16.03.27.12;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.02.14.36.26;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.13.11.42.19;	author markus;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2002.12.19.00.07.02;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.07.22.08.07;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.03.14.21.05;	author markus;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2002.07.03.09.55.38;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.26.22.27.32;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches
	1.4.2.1
	1.4.4.1;
next	1.3;

1.3
date	2002.06.08.05.07.09;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.31.10.30.33;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.23.19.24.30;	author markus;	state Exp;
branches;
next	;

1.4.2.1
date	2002.06.22.07.23.18;	author miod;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2002.10.11.14.51.53;	author miod;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2003.04.03.22.35.18;	author miod;	state Exp;
branches;
next	;

1.7.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2003.09.16.21.20.28;	author brad;	state Exp;
branches;
next	;

1.10.2.1
date	2003.09.16.20.50.44;	author brad;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.13.2.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.15.2.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	;

1.18.4.1
date	2006.02.03.02.53.45;	author brad;	state Exp;
branches;
next	;

1.18.6.1
date	2006.02.03.03.01.57;	author brad;	state Exp;
branches;
next	1.18.6.2;

1.18.6.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	;

1.20.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	;


desc
@@


1.52
log
@Add a function to enable security-related malloc_options.  With and ok
deraadt@@, something similar has been in the snaps for a while.
@
text
@/* $OpenBSD: ssh-keysign.c,v 1.51 2015/12/04 16:41:28 markus Exp $ */
/*
 * Copyright (c) 2002 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>

#include <openssl/evp.h>
#include <openssl/rsa.h>

#include <fcntl.h>
#include <paths.h>
#include <pwd.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include "xmalloc.h"
#include "log.h"
#include "sshkey.h"
#include "ssh.h"
#include "ssh2.h"
#include "misc.h"
#include "sshbuf.h"
#include "authfile.h"
#include "msg.h"
#include "canohost.h"
#include "pathnames.h"
#include "readconf.h"
#include "uidswap.h"
#include "sshkey.h"
#include "ssherr.h"

extern char *__progname;

/* XXX readconf.c needs these */
uid_t original_real_uid;

static int
valid_request(struct passwd *pw, char *host, struct sshkey **ret,
    u_char *data, size_t datalen)
{
	struct sshbuf *b;
	struct sshkey *key = NULL;
	u_char type, *pkblob;
	char *p;
	size_t blen, len;
	char *pkalg, *luser;
	int r, pktype, fail;

	if (ret != NULL)
		*ret = NULL;
	fail = 0;

	if ((b = sshbuf_from(data, datalen)) == NULL)
		fatal("%s: sshbuf_from failed", __func__);

	/* session id, currently limited to SHA1 (20 bytes) or SHA256 (32) */
	if ((r = sshbuf_get_string(b, NULL, &len)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (len != 20 && len != 32)
		fail++;

	if ((r = sshbuf_get_u8(b, &type)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (type != SSH2_MSG_USERAUTH_REQUEST)
		fail++;

	/* server user */
	if ((r = sshbuf_skip_string(b)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	/* service */
	if ((r = sshbuf_get_cstring(b, &p, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (strcmp("ssh-connection", p) != 0)
		fail++;
	free(p);

	/* method */
	if ((r = sshbuf_get_cstring(b, &p, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (strcmp("hostbased", p) != 0)
		fail++;
	free(p);

	/* pubkey */
	if ((r = sshbuf_get_cstring(b, &pkalg, NULL)) != 0 ||
	    (r = sshbuf_get_string(b, &pkblob, &blen)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	pktype = sshkey_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC)
		fail++;
	else if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
		error("%s: bad key blob: %s", __func__, ssh_err(r));
		fail++;
	} else if (key->type != pktype)
		fail++;
	free(pkalg);
	free(pkblob);

	/* client host name, handle trailing dot */
	if ((r = sshbuf_get_cstring(b, &p, &len)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	debug2("%s: check expect chost %s got %s", __func__, host, p);
	if (strlen(host) != len - 1)
		fail++;
	else if (p[len - 1] != '.')
		fail++;
	else if (strncasecmp(host, p, len - 1) != 0)
		fail++;
	free(p);

	/* local user */
	if ((r = sshbuf_get_cstring(b, &luser, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	if (strcmp(pw->pw_name, luser) != 0)
		fail++;
	free(luser);

	/* end of message */
	if (sshbuf_len(b) != 0)
		fail++;
	sshbuf_free(b);

	debug3("%s: fail %d", __func__, fail);

	if (fail && key != NULL)
		sshkey_free(key);
	else if (ret != NULL)
		*ret = key;

	return (fail ? -1 : 0);
}

int
main(int argc, char **argv)
{
	struct sshbuf *b;
	Options options;
#define NUM_KEYTYPES 4
	struct sshkey *keys[NUM_KEYTYPES], *key = NULL;
	struct passwd *pw;
	int r, key_fd[NUM_KEYTYPES], i, found, version = 2, fd;
	u_char *signature, *data, rver;
	char *host, *fp;
	size_t slen, dlen;

	ssh_malloc_init();	/* must be called before any mallocs */
	if (pledge("stdio rpath getpw dns id", NULL) != 0)
		fatal("%s: pledge: %s", __progname, strerror(errno));

	/* Ensure that stdin and stdout are connected */
	if ((fd = open(_PATH_DEVNULL, O_RDWR)) < 2)
		exit(1);
	/* Leave /dev/null fd iff it is attached to stderr */
	if (fd > 2)
		close(fd);

	i = 0;
	/* XXX This really needs to read sshd_config for the paths */
	key_fd[i++] = open(_PATH_HOST_DSA_KEY_FILE, O_RDONLY);
	key_fd[i++] = open(_PATH_HOST_ECDSA_KEY_FILE, O_RDONLY);
	key_fd[i++] = open(_PATH_HOST_ED25519_KEY_FILE, O_RDONLY);
	key_fd[i++] = open(_PATH_HOST_RSA_KEY_FILE, O_RDONLY);

	original_real_uid = getuid();	/* XXX readconf.c needs this */
	if ((pw = getpwuid(original_real_uid)) == NULL)
		fatal("getpwuid failed");
	pw = pwcopy(pw);

	permanently_set_uid(pw);

#ifdef DEBUG_SSH_KEYSIGN
	log_init("ssh-keysign", SYSLOG_LEVEL_DEBUG3, SYSLOG_FACILITY_AUTH, 0);
#endif

	/* verify that ssh-keysign is enabled by the admin */
	initialize_options(&options);
	(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw, "", "", &options, 0);
	fill_default_options(&options);
	if (options.enable_ssh_keysign != 1)
		fatal("ssh-keysign not enabled in %s",
		    _PATH_HOST_CONFIG_FILE);

	for (i = found = 0; i < NUM_KEYTYPES; i++) {
		if (key_fd[i] != -1)
			found = 1;
	}
	if (found == 0)
		fatal("could not open any host key");

	OpenSSL_add_all_algorithms();

	found = 0;
	for (i = 0; i < NUM_KEYTYPES; i++) {
		keys[i] = NULL;
		if (key_fd[i] == -1)
			continue;
		r = sshkey_load_private_type_fd(key_fd[i], KEY_UNSPEC,
		    NULL, &key, NULL);
		close(key_fd[i]);
		if (r != 0)
			debug("parse key %d: %s", i, ssh_err(r));
		else if (key != NULL) {
			keys[i] = key;
			found = 1;
		}
	}
	if (!found)
		fatal("no hostkey found");

	if (pledge("stdio dns", NULL) != 0)
		fatal("%s: pledge: %s", __progname, strerror(errno));

	if ((b = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __progname);
	if (ssh_msg_recv(STDIN_FILENO, b) < 0)
		fatal("ssh_msg_recv failed");
	if ((r = sshbuf_get_u8(b, &rver)) != 0)
		fatal("%s: buffer error: %s", __progname, ssh_err(r));
	if (rver != version)
		fatal("bad version: received %d, expected %d", rver, version);
	if ((r = sshbuf_get_u32(b, (u_int *)&fd)) != 0)
		fatal("%s: buffer error: %s", __progname, ssh_err(r));
	if (fd < 0 || fd == STDIN_FILENO || fd == STDOUT_FILENO)
		fatal("bad fd");
	if ((host = get_local_name(fd)) == NULL)
		fatal("cannot get local name for fd");

	if ((r = sshbuf_get_string(b, &data, &dlen)) != 0)
		fatal("%s: buffer error: %s", __progname, ssh_err(r));
	if (valid_request(pw, host, &key, data, dlen) < 0)
		fatal("not a valid request");
	free(host);

	found = 0;
	for (i = 0; i < NUM_KEYTYPES; i++) {
		if (keys[i] != NULL &&
		    sshkey_equal_public(key, keys[i])) {
			found = 1;
			break;
		}
	}
	if (!found) {
		if ((fp = sshkey_fingerprint(key, options.fingerprint_hash,
		    SSH_FP_DEFAULT)) == NULL)
			fatal("%s: sshkey_fingerprint failed", __progname);
		fatal("no matching hostkey found for key %s %s",
		    sshkey_type(key), fp ? fp : "");
	}

	if ((r = sshkey_sign(keys[i], &signature, &slen, data, dlen, NULL, 0))
	    != 0)
		fatal("sshkey_sign failed: %s", ssh_err(r));
	free(data);

	/* send reply */
	sshbuf_reset(b);
	if ((r = sshbuf_put_string(b, signature, slen)) != 0)
		fatal("%s: buffer error: %s", __progname, ssh_err(r));
	if (ssh_msg_send(STDOUT_FILENO, version, b) == -1)
		fatal("ssh_msg_send failed");

	return (0);
}
@


1.51
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.50 2015/11/29 22:18:37 djm Exp $ */
d172 1
@


1.50
log
@pledge, better fatal() messages; feedback deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.49 2015/07/03 03:56:25 djm Exp $ */
d275 2
a276 1
	if ((r = sshkey_sign(keys[i], &signature, &slen, data, dlen, 0)) != 0)
@


1.49
log
@add an XXX reminder for getting correct key paths from sshd_config
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.48 2015/03/24 20:09:11 markus Exp $ */
d37 1
d55 2
d172 3
d235 3
d239 1
a239 1
		fatal("%s: sshbuf_new failed", __func__);
d243 1
a243 1
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
d247 1
a247 1
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
d254 1
a254 1
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
d270 1
a270 1
			fatal("%s: sshkey_fingerprint failed", __func__);
d282 1
a282 1
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
@


1.48
log
@consistent check for NULL as noted by Nicholas Lemonias; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.47 2015/01/28 22:36:00 djm Exp $ */
d177 1
@


1.47
log
@update to new API (key_fingerprint => sshkey_fingerprint)
check sshkey_fingerprint return values;
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.46 2015/01/15 09:40:00 djm Exp $ */
d150 1
a150 1
	else
@


1.46
log
@sync ssh-keysign, ssh-keygen and some dependencies to the new
buffer/key API; mostly mechanical, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.45 2015/01/08 10:14:08 djm Exp $ */
d258 3
a260 2
		fp = sshkey_fingerprint(key, options.fingerprint_hash,
		    SSH_FP_DEFAULT);
@


1.45
log
@deprecate key_load_private_pem() and sshkey_load_private_pem()
interfaces. Refactor the generic key loading API to not require
pathnames to be specified (they weren't really used).

Fixes a few other things en passant:

Makes ed25519 keys work for hostbased authentication (ssh-keysign
previously used the PEM-only routines).

Fixes key comment regression bz#2306: key pathnames were being lost as
comment fields.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.44 2014/12/21 22:27:56 djm Exp $ */
d40 1
a40 1
#include "key.h"
d44 1
a44 1
#include "buffer.h"
d58 2
a59 2
valid_request(struct passwd *pw, char *host, Key **ret, u_char *data,
    u_int datalen)
d61 7
a67 6
	Buffer b;
	Key *key = NULL;
	u_char *pkblob;
	u_int blen, len;
	char *pkalg, *p;
	int pktype, fail;
d73 2
a74 2
	buffer_init(&b);
	buffer_append(&b, data, datalen);
d77 2
a78 1
	p = buffer_get_string(&b, &len);
a80 1
	free(p);
d82 3
a84 1
	if (buffer_get_char(&b) != SSH2_MSG_USERAUTH_REQUEST)
d88 2
a89 1
	buffer_skip_string(&b);
d92 2
a93 1
	p = buffer_get_string(&b, NULL);
d99 2
a100 1
	p = buffer_get_string(&b, NULL);
d106 3
a108 2
	pkalg = buffer_get_string(&b, NULL);
	pkblob = buffer_get_string(&b, &blen);
d110 1
a110 1
	pktype = key_type_from_name(pkalg);
d113 2
a114 1
	else if ((key = key_from_blob(pkblob, blen)) == NULL)
d116 1
a116 1
	else if (key->type != pktype)
d122 3
a124 2
	p = buffer_get_string(&b, &len);
	debug2("valid_request: check expect chost %s got %s", host, p);
d134 2
a135 1
	p = buffer_get_string(&b, NULL);
d137 1
a137 1
	if (strcmp(pw->pw_name, p) != 0)
d139 1
a139 1
	free(p);
d142 1
a142 1
	if (buffer_len(&b) != 0)
d144 1
a144 1
	buffer_free(&b);
d146 1
a146 1
	debug3("valid_request: fail %d", fail);
d149 1
a149 1
		key_free(key);
d159 1
a159 1
	Buffer b;
d162 1
a162 1
	Key *keys[NUM_KEYTYPES], *key = NULL;
d165 1
a165 1
	u_char *signature, *data;
d167 1
a167 1
	u_int slen, dlen;
d228 3
a230 2
	buffer_init(&b);
	if (ssh_msg_recv(STDIN_FILENO, &b) < 0)
d232 7
a238 4
	if (buffer_get_char(&b) != version)
		fatal("bad version");
	fd = buffer_get_int(&b);
	if ((fd == STDIN_FILENO) || (fd == STDOUT_FILENO))
d243 2
a244 1
	data = buffer_get_string(&b, &dlen);
d252 1
a252 1
		    key_equal_public(key, keys[i])) {
d258 1
a258 1
		fp = key_fingerprint(key, options.fingerprint_hash,
d261 1
a261 1
		    key_type(key), fp);
d264 2
a265 2
	if (key_sign(keys[i], &signature, &slen, data, dlen) != 0)
		fatal("key_sign failed");
d269 4
a272 3
	buffer_clear(&b);
	buffer_put_string(&b, signature, slen);
	if (ssh_msg_send(STDOUT_FILENO, version, &b) == -1)
@


1.44
log
@Add FingerprintHash option to control algorithm used for key
fingerprints. Default changes from MD5 to SHA256 and format
from hex to base64.

Feedback and ok naddy@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.43 2014/10/08 22:20:25 djm Exp $ */
d51 2
d68 2
d154 1
a154 1
	int key_fd[NUM_KEYTYPES], i, found, version = 2, fd;
d205 2
a206 5
#ifdef WITH_OPENSSL
/* XXX wrong api */
		keys[i] = key_load_private_pem(key_fd[i], KEY_UNSPEC,
		    NULL, NULL);
#endif
d208 4
a211 1
		if (keys[i] != NULL)
d213 1
@


1.43
log
@Tweak config reparsing with host canonicalisation

Make the second pass through the config files always run when
hostname canonicalisation is enabled.

Add a "Match canonical" criteria that allows ssh_config Match
blocks to trigger only in the second config pass.

Add a -G option to ssh that causes it to parse its configuration
and dump the result to stdout, similar to "sshd -T"

Allow ssh_config Port options set in the second config parse
phase to be applied (they were being ignored).

bz#2267 bz#2286; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.42 2014/04/29 18:01:49 markus Exp $ */
d238 2
a239 1
		fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
@


1.42
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.41 2014/04/19 14:53:48 tedu Exp $ */
d181 1
a181 1
	(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw, "", &options, 0);
@


1.41
log
@Delete futile calls to RAND_seed. ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.40 2014/04/01 02:05:27 djm Exp $ */
d201 2
d205 1
@


1.40
log
@include fingerprint of key not found
use arc4random_buf() instead of loop+arc4random()
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.39 2013/12/06 13:39:49 markus Exp $ */
a28 1
#include <openssl/rand.h>
a153 1
	u_int32_t rnd[256];
a194 2
	arc4random_buf(rnd, sizeof(rnd));
	RAND_seed(rnd, sizeof(rnd));
@


1.39
log
@support ed25519 keys (hostkeys and user identities) using the public domain
ed25519 reference code from SUPERCOP, see http://ed25519.cr.yp.to/software.html
feedback, help & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.38 2013/10/14 22:22:04 djm Exp $ */
d153 1
a153 1
	char *host;
d197 1
a197 2
	for (i = 0; i < 256; i++)
		rnd[i] = arc4random();
d238 5
a242 2
	if (!found)
		fatal("no matching hostkey found");
@


1.38
log
@add a "Match" keyword to ssh_config that allows matching on hostname,
user and result of arbitrary commands. "nice work" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.37 2013/05/17 00:13:14 djm Exp $ */
d148 1
a148 1
#define NUM_KEYTYPES 3
d167 1
@


1.37
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.36 2011/02/16 00:31:14 djm Exp $ */
d182 1
a182 1
	(void)read_config_file(_PATH_HOST_CONFIG_FILE, "", &options, 0);
@


1.36
log
@make hostbased auth with ECDSA keys work correctly. Based on patch
by harvey.eneman AT oracle.com in bz#1858; ok markus@@ (pre-lock)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.35 2010/08/31 12:33:38 djm Exp $ */
d76 1
a76 1
	xfree(p);
d88 1
a88 1
	xfree(p);
d94 1
a94 1
	xfree(p);
d107 2
a108 2
	xfree(pkalg);
	xfree(pkblob);
d119 1
a119 1
	xfree(p);
d126 1
a126 1
	xfree(p);
d228 1
a228 1
	xfree(host);
d243 1
a243 1
	xfree(data);
@


1.35
log
@reintroduce commit from tedu@@, which I pulled out for release engineering:

  OpenSSL_add_all_algorithms is the name of the function we have a man page
  for, so use that.  ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.33 2010/08/12 23:34:39 tedu Exp $ */
d148 2
a149 1
	Key *keys[2], *key = NULL;
d151 1
a151 1
	int key_fd[2], i, found, version = 2, fd;
d164 4
a167 2
	key_fd[0] = open(_PATH_HOST_RSA_KEY_FILE, O_RDONLY);
	key_fd[1] = open(_PATH_HOST_DSA_KEY_FILE, O_RDONLY);
d188 5
a192 1
	if (key_fd[0] == -1 && key_fd[1] == -1)
d201 1
a201 1
	for (i = 0; i < 2; i++) {
d231 1
a231 1
	for (i = 0; i < 2; i++) {
@


1.34
log
@backout previous temporarily; discussed with deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.32 2010/08/04 06:08:40 djm Exp $ */
d188 1
a188 1
	SSLeay_add_all_algorithms();
@


1.33
log
@OpenSSL_add_all_algorithms is the name of the function we have a man page
for, so use that.  ok djm
@
text
@d188 1
a188 1
	OpenSSL_add_all_algorithms();
@


1.32
log
@clean for -Wuninitialized
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.31 2010/08/04 05:42:47 djm Exp $ */
d188 1
a188 1
	SSLeay_add_all_algorithms();
@


1.31
log
@enable certificates for hostbased authentication, from Iain Morgan;
"looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.30 2010/01/13 01:20:20 dtucker Exp $ */
d148 1
a148 1
	Key *keys[2], *key;
@


1.30
log
@Make HostBased authentication work with a ProxyCommand.  bz #1569, patch
from imorgan at nas nasa gov, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.29 2006/08/03 03:34:42 deraadt Exp $ */
d226 1
a226 1
		    key_equal(key, keys[i])) {
@


1.29
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.28 2006/07/26 13:57:17 stevesk Exp $ */
d216 1
a216 1
		fatal("cannot get sockname for fd");
@


1.28
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.27 2006/07/22 20:48:23 stevesk Exp $ */
a24 1
#include "includes.h"
d39 1
a44 1
#include "xmalloc.h"
a45 1
#include "bufaux.h"
@


1.27
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.26 2006/07/17 01:31:10 stevesk Exp $ */
d36 1
@


1.26
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.25 2006/07/09 15:15:11 stevesk Exp $ */
d36 1
@


1.25
log
@move #include <fcntl.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.24 2006/07/06 16:03:53 stevesk Exp $ */
d36 1
@


1.24
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.23 2006/04/02 08:34:52 dtucker Exp $ */
d33 1
@


1.23
log
@sessionid can be 32 bytes now too when sha256 kex is used; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keysign.c,v 1.22 2006/03/25 13:17:02 djm Exp $ */
d27 1
a27 1
#include <paths.h>
d32 3
@


1.22
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d67 1
a67 1
	/* session id, currently limited to SHA1 (20 bytes) */
d69 1
a69 1
	if (len != 20)
@


1.21
log
@RCSID() can die
@
text
@d1 1
@


1.20
log
@move #include <paths.h> out of includes.h; ok markus@@
@
text
@a24 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.19 2005/09/13 23:40:07 djm Exp $");
@


1.20.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh-keysign.c,v 1.29 2006/08/03 03:34:42 deraadt Exp $ */
d24 2
d27 1
a27 1
#include <sys/types.h>
a32 8
#include <fcntl.h>
#include <paths.h>
#include <pwd.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
d38 1
d40 1
d67 1
a67 1
	/* session id, currently limited to SHA1 (20 bytes) or SHA256 (32) */
d69 1
a69 1
	if (len != 20 && len != 32)
@


1.19
log
@ensure that stdio fds are attached; ok deraadt@@
@
text
@d25 3
a27 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.18 2004/08/23 14:29:23 dtucker Exp $");
@


1.18
log
@Remove duplicate getuid(), suggested by & ok markus@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.17 2004/08/23 14:26:38 dtucker Exp $");
d148 7
@


1.18.6.1
log
@upgrade to OpenSSH 4.3
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.19 2005/09/13 23:40:07 djm Exp $");
a147 7

	/* Ensure that stdin and stdout are connected */
	if ((fd = open(_PATH_DEVNULL, O_RDWR)) < 2)
		exit(1);
	/* Leave /dev/null fd iff it is attached to stderr */
	if (fd > 2)
		close(fd);
@


1.18.6.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh-keysign.c,v 1.29 2006/08/03 03:34:42 deraadt Exp $ */
d24 2
a25 2

#include <sys/types.h>
a30 8
#include <fcntl.h>
#include <paths.h>
#include <pwd.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
d36 1
d38 1
d65 1
a65 1
	/* session id, currently limited to SHA1 (20 bytes) or SHA256 (32) */
d67 1
a67 1
	if (len != 20 && len != 32)
@


1.18.4.1
log
@upgrade to OpenSSH 4.3
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.19 2005/09/13 23:40:07 djm Exp $");
a147 7

	/* Ensure that stdin and stdout are connected */
	if ((fd = open(_PATH_DEVNULL, O_RDWR)) < 2)
		exit(1);
	/* Leave /dev/null fd iff it is attached to stderr */
	if (fd > 2)
		close(fd);
@


1.17
log
@Use permanently_set_uid() in ssh and ssh-keysign for consistency, matches
change in Portable; ok markus@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.16 2004/04/18 23:10:26 djm Exp $");
d152 2
a153 1
	if ((pw = getpwuid(getuid())) == NULL)
a163 1
	original_real_uid = getuid();	/* XXX readconf.c needs this */
@


1.16
log
@perform strict ownership and modes checks for ~/.ssh/config files, as these
can be used to execute arbitrary programs; ok markus@@

NB. ssh will now exit when it detects a config with poor permissions
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.15 2004/01/19 21:25:15 markus Exp $");
d44 1
d152 5
a156 2
	seteuid(getuid());
	setuid(getuid());
a172 4

	if ((pw = getpwuid(getuid())) == NULL)
		fatal("getpwuid failed");
	pw = pwcopy(pw);
@


1.15
log
@fix mem leaks; some fixes from Pete Flugstad; tested dtucker@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.14 2003/11/17 09:45:39 djm Exp $");
d161 1
a161 1
	(void)read_config_file(_PATH_HOST_CONFIG_FILE, "", &options);
@


1.15.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.16 2004/04/18 23:10:26 djm Exp $");
d161 1
a161 1
	(void)read_config_file(_PATH_HOST_CONFIG_FILE, "", &options, 0);
@


1.14
log
@return error on msg send/receive failure (rather than fatal); ok markus@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.13 2003/07/03 08:09:06 djm Exp $");
d123 1
@


1.13
log
@fix AddressFamily option in config file, from brent@@graveland.net; ok markus@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.12 2003/05/16 03:27:12 djm Exp $");
d226 2
a227 1
	ssh_msg_send(STDOUT_FILENO, version, &b);
@


1.13.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.15 2004/01/19 21:25:15 markus Exp $");
a122 1
	buffer_free(&b);
d226 1
a226 2
	if (ssh_msg_send(STDOUT_FILENO, version, &b) == -1)
		fatal("ssh_msg_send failed");
@


1.13.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.16 2004/04/18 23:10:26 djm Exp $");
d161 1
a161 1
	(void)read_config_file(_PATH_HOST_CONFIG_FILE, "", &options, 0);
@


1.12
log
@add AddressFamily option to ssh_config (like -4, -6 on commandline).
Portable bug #534; ok markus@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.11 2003/04/02 14:36:26 markus Exp $");
a46 1
int IPv4or6;
@


1.11
log
@potential segfault if KEY_UNSPEC; cjwatson@@debian.org; bug #526
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.10 2003/03/13 11:42:19 markus Exp $");
d45 3
a47 1
uid_t original_real_uid;	/* XXX readconf.c needs this */
@


1.10
log
@move RSA_blinding_on to generic key load method
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.9 2002/12/19 00:07:02 djm Exp $");
d52 1
a52 1
	Key *key;
@


1.10.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.13 2003/07/03 08:09:06 djm Exp $");
d45 1
a45 2
/* XXX readconf.c needs these */
uid_t original_real_uid;
d52 1
a52 1
	Key *key = NULL;
@


1.10.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.15 2004/01/19 21:25:15 markus Exp $");
a122 1
	buffer_free(&b);
d226 1
a226 2
	if (ssh_msg_send(STDOUT_FILENO, version, &b) == -1)
		fatal("ssh_msg_send failed");
@


1.9
log
@s/msg_send/ssh_msg_send/ to avoid namespace clashes in portable; ok markus@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.8 2002/11/07 22:08:07 markus Exp $");
a184 7
		if (keys[i] != NULL && keys[i]->type == KEY_RSA) {
			if (RSA_blinding_on(keys[i]->rsa, NULL) != 1) {
				error("RSA_blinding_on failed");
				key_free(keys[i]);
				keys[i] = NULL;
			}
		}
@


1.8
log
@we cannot use HostbasedAuthentication for enabling ssh-keysign(8),
because HostbasedAuthentication might be enabled based on the
target host and ssh-keysign(8) does not know the remote hostname
and not trust ssh(1) about the hostname, so we add a new option
EnableSSHKeysign; ok djm@@, report from zierke@@informatik.uni-hamburg.de
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.7 2002/07/03 14:21:05 markus Exp $");
d199 2
a200 2
	if (msg_recv(STDIN_FILENO, &b) < 0)
		fatal("msg_recv failed");
d232 1
a232 1
	msg_send(STDOUT_FILENO, version, &b);
@


1.7
log
@re-enable ssh-keysign's sbit, but make ssh-keysign read /etc/ssh/ssh_config
and exit if HostbasedAuthentication is disabled globally. based on discussions
with deraadt, itojun and sommerfeld; ok itojun@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.6 2002/07/03 09:55:38 markus Exp $");
d161 2
a162 2
	if (options.hostbased_authentication != 1)
		fatal("Hostbased authentication not enabled in %s",
@


1.7.2.1
log
@Update to OpenSSH 3.6
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.10 2003/03/13 11:42:19 markus Exp $");
d161 2
a162 2
	if (options.enable_ssh_keysign != 1)
		fatal("ssh-keysign not enabled in %s",
d185 7
d199 2
a200 2
	if (ssh_msg_recv(STDIN_FILENO, &b) < 0)
		fatal("ssh_msg_recv failed");
d232 1
a232 1
	ssh_msg_send(STDOUT_FILENO, version, &b);
@


1.7.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.13 2003/07/03 08:09:06 djm Exp $");
d45 1
a45 2
/* XXX readconf.c needs these */
uid_t original_real_uid;
d52 1
a52 1
	Key *key = NULL;
@


1.6
log
@use RSA_blinding_on() for rsa hostkeys (suggested by Bill Sommerfeld)
in order to avoid a possible Kocher timing attack pointed out by Charles
Hannum; ok provos@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.5 2002/06/26 22:27:32 markus Exp $");
d33 1
d43 3
d137 1
d155 9
@


1.5
log
@bug #304, xfree(data) called to early; openssh@@sigint.cs.purdue.edu
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.4 2002/06/19 00:27:55 deraadt Exp $");
d28 2
d139 1
d159 3
d171 7
@


1.4
log
@KNF done automatically while reading....
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.3 2002/06/08 05:07:09 markus Exp $");
a184 1
	xfree(data);
d200 1
@


1.4.4.1
log
@Pull in OpenSSH-3.4
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.4 2002/06/19 00:27:55 deraadt Exp $");
@


1.4.4.2
log
@Update to OpenSSH 3.5
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.7 2002/07/03 14:21:05 markus Exp $");
a27 2
#include <openssl/rand.h>
#include <openssl/rsa.h>
a30 1
#include "ssh.h"
a39 3
#include "readconf.h"

uid_t original_real_uid;	/* XXX readconf.c needs this */
a130 1
	Options options;
a136 1
	u_int32_t rnd[256];
a147 9
	/* verify that ssh-keysign is enabled by the admin */
	original_real_uid = getuid();	/* XXX readconf.c needs this */
	initialize_options(&options);
	(void)read_config_file(_PATH_HOST_CONFIG_FILE, "", &options);
	fill_default_options(&options);
	if (options.hostbased_authentication != 1)
		fatal("Hostbased authentication not enabled in %s",
		    _PATH_HOST_CONFIG_FILE);

a155 3
	for (i = 0; i < 256; i++)
		rnd[i] = arc4random();
	RAND_seed(rnd, sizeof(rnd));
a164 7
		if (keys[i] != NULL && keys[i]->type == KEY_RSA) {
			if (RSA_blinding_on(keys[i]->rsa, NULL) != 1) {
				error("RSA_blinding_on failed");
				key_free(keys[i]);
				keys[i] = NULL;
			}
		}
d185 1
a200 1
	xfree(data);
@


1.4.4.3
log
@Merge OpenSSH 3.6.1
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.10 2003/03/13 11:42:19 markus Exp $");
d161 2
a162 2
	if (options.enable_ssh_keysign != 1)
		fatal("ssh-keysign not enabled in %s",
d185 7
d199 2
a200 2
	if (ssh_msg_recv(STDIN_FILENO, &b) < 0)
		fatal("ssh_msg_recv failed");
d232 1
a232 1
	ssh_msg_send(STDOUT_FILENO, version, &b);
@


1.4.2.1
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.4 2002/06/19 00:27:55 deraadt Exp $");
@


1.4.2.2
log
@Update to OpenSSH 3.5
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.7 2002/07/03 14:21:05 markus Exp $");
a27 2
#include <openssl/rand.h>
#include <openssl/rsa.h>
a30 1
#include "ssh.h"
a39 3
#include "readconf.h"

uid_t original_real_uid;	/* XXX readconf.c needs this */
a130 1
	Options options;
a136 1
	u_int32_t rnd[256];
a147 9
	/* verify that ssh-keysign is enabled by the admin */
	original_real_uid = getuid();	/* XXX readconf.c needs this */
	initialize_options(&options);
	(void)read_config_file(_PATH_HOST_CONFIG_FILE, "", &options);
	fill_default_options(&options);
	if (options.hostbased_authentication != 1)
		fatal("Hostbased authentication not enabled in %s",
		    _PATH_HOST_CONFIG_FILE);

a155 3
	for (i = 0; i < 256; i++)
		rnd[i] = arc4random();
	RAND_seed(rnd, sizeof(rnd));
a164 7
		if (keys[i] != NULL && keys[i]->type == KEY_RSA) {
			if (RSA_blinding_on(keys[i]->rsa, NULL) != 1) {
				error("RSA_blinding_on failed");
				key_free(keys[i]);
				keys[i] = NULL;
			}
		}
d185 1
a200 1
	xfree(data);
@


1.3
log
@only accept 20 byte session ids
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.2 2002/05/31 10:30:33 markus Exp $");
d56 1
a56 1
 
d101 1
a101 1
	      fail++;
d103 1
a103 1
	      fail++;
d146 1
a146 1
#endif  
d153 1
a153 1
	pw = pwcopy(pw); 
d181 1
a181 1
	
d201 1
a201 1
	
@


1.2
log
@extent ssh-keysign protocol:
pass # of socket-fd to ssh-keysign, keysign verfies locally used
ip-address using this socket-fd, restricts fake local hostnames
to actual local hostnames; ok stevesk@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: ssh-keysign.c,v 1.1 2002/05/23 19:24:30 markus Exp $");
d57 6
a62 2
	/* session id */
	buffer_skip_string(&b);
@


1.1
log
@add /usr/libexec/ssh-keysign: a setuid helper program for hostbased authentication
in protocol v2 (needs to access the hostkeys).
@
text
@d25 1
a25 1
RCSID("$OpenBSD: $");
d38 1
d42 2
a43 1
valid_request(struct passwd *pw, Key **ret, u_char *data, u_int datalen)
d47 3
a49 3
	u_char *p, *pkblob;
	u_int blen;
	char *pkalg;
d91 10
a100 2
	/* chost */
	buffer_skip_string(&b);
d104 1
d129 1
a129 1
	int key_fd[2], i, found, version = 1;
d131 1
d172 6
d179 1
a179 1
	if (valid_request(pw, &key, data, dlen) < 0)
d182 1
@

