head	1.48;
access;
symbols
	OPENBSD_6_1:1.48.0.2
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.47.0.4
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.46.0.6
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.44.0.20
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.44.0.16
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.44.0.14
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.12
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.10
	OPENBSD_5_0:1.44.0.8
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.44.0.6
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.44.0.4
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.43.0.8
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.4
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.43.0.2
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.41.0.8
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.41.0.6
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.41.0.2
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.41.0.4
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.32.0.6
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.32.0.4
	OPENBSD_3_6_BASE:1.32
	OPENBSD_3_5:1.32.0.2
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	OPENBSD_3_3:1.28.0.4
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.48
date	2016.08.13.17.47.41;	author markus;	state Exp;
branches;
next	1.47;
commitid	dl4RDERdJITM8DKC;

1.47
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.46;
commitid	kr9hjdmg99uVnhW2;

1.46
date	2014.12.23.22.42.48;	author djm;	state Exp;
branches;
next	1.45;
commitid	tkRozQaasbezrwHY;

1.45
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.44;
commitid	z7plx8Gkj6l2sxem;

1.44
date	2010.03.07.11.57.13;	author dtucker;	state Exp;
branches;
next	1.43;

1.43
date	2008.06.13.14.18.51;	author dtucker;	state Exp;
branches;
next	1.42;

1.42
date	2008.06.13.04.40.22;	author djm;	state Exp;
branches;
next	1.41;

1.41
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.39;

1.39
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2006.02.20.17.19.53;	author stevesk;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2006.02.07.01.08.04;	author stevesk;	state Exp;
branches;
next	1.33;

1.33
date	2005.07.17.07.17.54;	author djm;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2003.11.04.08.54.09;	author djm;	state Exp;
branches
	1.32.4.1
	1.32.6.1;
next	1.31;

1.31
date	2003.06.02.09.17.34;	author markus;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2003.05.17.03.25.58;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.13.21.26.49;	author markus;	state Exp;
branches
	1.28.2.1
	1.28.4.1;
next	1.27;

1.27
date	2002.03.04.12.43.06;	author markus;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2002.01.29.14.32.03;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.23.15.12.17;	author itojun;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2001.04.12.19.15.24;	author markus;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2001.04.06.21.00.06;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.08.19.30.51;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.03.10.08.36;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.21.19.05.42;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.19.15.55.10;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.19.23.17.55;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.03.18.03.03;	author markus;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2000.09.07.20.27.49;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.20.01.39.38;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.14.10.30.29;	author markus;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	99.12.27.10.46.11;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	99.11.24.19.53.43;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	99.11.24.00.26.00;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.11.23.22.25.52;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	99.11.18.14.00.47;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	99.11.14.23.20.09;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.11.11.23.36.52;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	99.10.03.20.09.18;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.09.30.05.43.33;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.21.14.15;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.04.45.35;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.33;	author deraadt;	state Exp;
branches;
next	;

1.13.2.1
date	2000.09.01.18.23.16;	author jason;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2000.11.08.21.30.21;	author jason;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2001.03.12.15.44.07;	author jason;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2001.03.21.18.52.33;	author jason;	state Exp;
branches;
next	;

1.16.2.1
date	2001.02.16.20.12.52;	author jason;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2001.02.19.17.18.36;	author jason;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2001.03.21.19.46.22;	author jason;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2001.05.07.21.09.25;	author jason;	state Exp;
branches;
next	1.16.2.5;

1.16.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.16.2.6;

1.16.2.6
date	2002.03.08.17.04.41;	author brad;	state Exp;
branches;
next	;

1.23.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2002.03.09.00.20.43;	author miod;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2002.06.02.22.56.09;	author miod;	state Exp;
branches;
next	;

1.24.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	;

1.27.2.1
date	2002.05.18.04.12.10;	author jason;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2002.05.18.04.50.37;	author jason;	state Exp;
branches;
next	1.27.2.3;

1.27.2.3
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	;

1.28.2.1
date	2003.09.16.21.20.24;	author brad;	state Exp;
branches;
next	;

1.28.4.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.28.4.2;

1.28.4.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.31.2.1
date	2004.02.28.03.51.32;	author brad;	state Exp;
branches;
next	;

1.32.4.1
date	2005.09.02.03.44.59;	author brad;	state Exp;
branches;
next	;

1.32.6.1
date	2005.09.04.18.39.52;	author brad;	state Exp;
branches;
next	;

1.33.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.35.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.48
log
@remove ssh1 server code; ok djm@@
@
text
@/* $OpenBSD: auth-rhosts.c,v 1.47 2016/03/07 19:02:43 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Rhosts authentication.  This file contains code to check whether to admit
 * the login based on rhosts authentication.  This file also processes
 * /etc/hosts.equiv.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <fcntl.h>
#include <netgroup.h>
#include <pwd.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>

#include "packet.h"
#include "uidswap.h"
#include "pathnames.h"
#include "log.h"
#include "misc.h"
#include "buffer.h" /* XXX */
#include "key.h" /* XXX */
#include "servconf.h"
#include "canohost.h"
#include "sshkey.h"
#include "hostfile.h"
#include "auth.h"

/* import */
extern ServerOptions options;
extern int use_privsep;

/*
 * This function processes an rhosts-style file (.rhosts, .shosts, or
 * /etc/hosts.equiv).  This returns true if authentication can be granted
 * based on the file, and returns zero otherwise.
 */

static int
check_rhosts_file(const char *filename, const char *hostname,
		  const char *ipaddr, const char *client_user,
		  const char *server_user)
{
	FILE *f;
#define RBUFLN 1024
	char buf[RBUFLN];/* Must not be larger than host, user, dummy below. */
	int fd;
	struct stat st;

	/* Open the .rhosts file, deny if unreadable */
	if ((fd = open(filename, O_RDONLY|O_NONBLOCK)) == -1)
		return 0;
	if (fstat(fd, &st) == -1) {
		close(fd);
		return 0;
	}
	if (!S_ISREG(st.st_mode)) {
		logit("User %s hosts file %s is not a regular file",
		    server_user, filename);
		close(fd);
		return 0;
	}
	unset_nonblock(fd);
	if ((f = fdopen(fd, "r")) == NULL) {
		close(fd);
		return 0;
	}
	while (fgets(buf, sizeof(buf), f)) {
		/* All three must have length >= buf to avoid overflows. */
		char hostbuf[RBUFLN], userbuf[RBUFLN], dummy[RBUFLN];
		char *host, *user, *cp;
		int negated;

		for (cp = buf; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (*cp == '#' || *cp == '\n' || !*cp)
			continue;

		/*
		 * NO_PLUS is supported at least on OSF/1.  We skip it (we
		 * don't ever support the plus syntax).
		 */
		if (strncmp(cp, "NO_PLUS", 7) == 0)
			continue;

		/*
		 * This should be safe because each buffer is as big as the
		 * whole string, and thus cannot be overwritten.
		 */
		switch (sscanf(buf, "%1023s %1023s %1023s", hostbuf, userbuf,
		    dummy)) {
		case 0:
			auth_debug_add("Found empty line in %.100s.", filename);
			continue;
		case 1:
			/* Host name only. */
			strlcpy(userbuf, server_user, sizeof(userbuf));
			break;
		case 2:
			/* Got both host and user name. */
			break;
		case 3:
			auth_debug_add("Found garbage in %.100s.", filename);
			continue;
		default:
			/* Weird... */
			continue;
		}

		host = hostbuf;
		user = userbuf;
		negated = 0;

		/* Process negated host names, or positive netgroups. */
		if (host[0] == '-') {
			negated = 1;
			host++;
		} else if (host[0] == '+')
			host++;

		if (user[0] == '-') {
			negated = 1;
			user++;
		} else if (user[0] == '+')
			user++;

		/* Check for empty host/user names (particularly '+'). */
		if (!host[0] || !user[0]) {
			/* We come here if either was '+' or '-'. */
			auth_debug_add("Ignoring wild host/user names "
			    "in %.100s.", filename);
			continue;
		}
		/* Verify that host name matches. */
		if (host[0] == '@@') {
			if (!innetgr(host + 1, hostname, NULL, NULL) &&
			    !innetgr(host + 1, ipaddr, NULL, NULL))
				continue;
		} else if (strcasecmp(host, hostname) &&
		    strcmp(host, ipaddr) != 0)
			continue;	/* Different hostname. */

		/* Verify that user name matches. */
		if (user[0] == '@@') {
			if (!innetgr(user + 1, NULL, client_user, NULL))
				continue;
		} else if (strcmp(user, client_user) != 0)
			continue;	/* Different username. */

		/* Found the user and host. */
		fclose(f);

		/* If the entry was negated, deny access. */
		if (negated) {
			auth_debug_add("Matched negative entry in %.100s.",
			    filename);
			return 0;
		}
		/* Accept authentication. */
		return 1;
	}

	/* Authentication using this file denied. */
	fclose(f);
	return 0;
}

/*
 * Tries to authenticate the user using the .shosts or .rhosts file. Returns
 * true if authentication succeeds.  If ignore_rhosts is true, only
 * /etc/hosts.equiv will be considered (.rhosts and .shosts are ignored).
 */
int
auth_rhosts2(struct passwd *pw, const char *client_user, const char *hostname,
    const char *ipaddr)
{
	char buf[1024];
	struct stat st;
	static const char *rhosts_files[] = {".shosts", ".rhosts", NULL};
	u_int rhosts_file_index;

	debug2("auth_rhosts2: clientuser %s hostname %s ipaddr %s",
	    client_user, hostname, ipaddr);

	/* Switch to the user's uid. */
	temporarily_use_uid(pw);
	/*
	 * Quick check: if the user has no .shosts or .rhosts files and
	 * no system hosts.equiv/shosts.equiv files exist then return
	 * failure immediately without doing costly lookups from name
	 * servers.
	 */
	for (rhosts_file_index = 0; rhosts_files[rhosts_file_index];
	    rhosts_file_index++) {
		/* Check users .rhosts or .shosts. */
		snprintf(buf, sizeof buf, "%.500s/%.100s",
			 pw->pw_dir, rhosts_files[rhosts_file_index]);
		if (stat(buf, &st) >= 0)
			break;
	}
	/* Switch back to privileged uid. */
	restore_uid();

	/*
	 * Deny if The user has no .shosts or .rhosts file and there
	 * are no system-wide files.
	 */
	if (!rhosts_files[rhosts_file_index] &&
	    stat(_PATH_RHOSTS_EQUIV, &st) < 0 &&
	    stat(_PATH_SSH_HOSTS_EQUIV, &st) < 0) {
		debug3("%s: no hosts access files exist", __func__);
		return 0;
	}

	/*
	 * If not logging in as superuser, try /etc/hosts.equiv and
	 * shosts.equiv.
	 */
	if (pw->pw_uid == 0)
		debug3("%s: root user, ignoring system hosts files", __func__);
	else {
		if (check_rhosts_file(_PATH_RHOSTS_EQUIV, hostname, ipaddr,
		    client_user, pw->pw_name)) {
			auth_debug_add("Accepted for %.100s [%.100s] by "
			    "/etc/hosts.equiv.", hostname, ipaddr);
			return 1;
		}
		if (check_rhosts_file(_PATH_SSH_HOSTS_EQUIV, hostname, ipaddr,
		    client_user, pw->pw_name)) {
			auth_debug_add("Accepted for %.100s [%.100s] by "
			    "%.100s.", hostname, ipaddr, _PATH_SSH_HOSTS_EQUIV);
			return 1;
		}
	}

	/*
	 * Check that the home directory is owned by root or the user, and is
	 * not group or world writable.
	 */
	if (stat(pw->pw_dir, &st) < 0) {
		logit("Rhosts authentication refused for %.100s: "
		    "no home directory %.200s", pw->pw_name, pw->pw_dir);
		auth_debug_add("Rhosts authentication refused for %.100s: "
		    "no home directory %.200s", pw->pw_name, pw->pw_dir);
		return 0;
	}
	if (options.strict_modes &&
	    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
	    (st.st_mode & 022) != 0)) {
		logit("Rhosts authentication refused for %.100s: "
		    "bad ownership or modes for home directory.", pw->pw_name);
		auth_debug_add("Rhosts authentication refused for %.100s: "
		    "bad ownership or modes for home directory.", pw->pw_name);
		return 0;
	}
	/* Temporarily use the user's uid. */
	temporarily_use_uid(pw);

	/* Check all .rhosts files (currently .shosts and .rhosts). */
	for (rhosts_file_index = 0; rhosts_files[rhosts_file_index];
	    rhosts_file_index++) {
		/* Check users .rhosts or .shosts. */
		snprintf(buf, sizeof buf, "%.500s/%.100s",
			 pw->pw_dir, rhosts_files[rhosts_file_index]);
		if (stat(buf, &st) < 0)
			continue;

		/*
		 * Make sure that the file is either owned by the user or by
		 * root, and make sure it is not writable by anyone but the
		 * owner.  This is to help avoid novices accidentally
		 * allowing access to their account by anyone.
		 */
		if (options.strict_modes &&
		    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
		    (st.st_mode & 022) != 0)) {
			logit("Rhosts authentication refused for %.100s: bad modes for %.200s",
			    pw->pw_name, buf);
			auth_debug_add("Bad file modes for %.200s", buf);
			continue;
		}
		/*
		 * Check if we have been configured to ignore .rhosts
		 * and .shosts files.
		 */
		if (options.ignore_rhosts) {
			auth_debug_add("Server has been configured to "
			    "ignore %.100s.", rhosts_files[rhosts_file_index]);
			continue;
		}
		/* Check if authentication is permitted by the file. */
		if (check_rhosts_file(buf, hostname, ipaddr,
		    client_user, pw->pw_name)) {
			auth_debug_add("Accepted by %.100s.",
			    rhosts_files[rhosts_file_index]);
			/* Restore the privileged uid. */
			restore_uid();
			auth_debug_add("Accepted host %s ip %s client_user "
			    "%s server_user %s", hostname, ipaddr,
			    client_user, pw->pw_name);
			return 1;
		}
	}

	/* Restore the privileged uid. */
	restore_uid();
	return 0;
}
@


1.47
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rhosts.c,v 1.46 2014/12/23 22:42:48 djm Exp $ */
a184 1

d186 1
a186 12
auth_rhosts(struct passwd *pw, const char *client_user)
{
	struct ssh *ssh = active_state;	/* XXX */
	const char *hostname, *ipaddr;

	hostname = auth_get_canonical_hostname(ssh, options.use_dns);
	ipaddr = ssh_remote_ipaddr(ssh);
	return auth_rhosts2(pw, client_user, hostname, ipaddr);
}

static int
auth_rhosts2_raw(struct passwd *pw, const char *client_user, const char *hostname,
a319 7
}

int
auth_rhosts2(struct passwd *pw, const char *client_user, const char *hostname,
    const char *ipaddr)
{
       return auth_rhosts2_raw(pw, client_user, hostname, ipaddr);
@


1.46
log
@KNF and add a little more debug()
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rhosts.c,v 1.45 2014/07/15 15:54:14 millert Exp $ */
a28 1
#include "buffer.h"
d33 2
d37 1
a37 1
#include "key.h"
d189 1
d192 2
a193 2
	hostname = get_canonical_hostname(options.use_dns);
	ipaddr = get_remote_ipaddr();
@


1.45
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rhosts.c,v 1.44 2010/03/07 11:57:13 dtucker Exp $ */
d56 2
a57 1
	char buf[1024];	/* Must not be larger than host, user, dummy below. */
d80 3
a82 2
		/* All three must be at least as big as buf to avoid overflows. */
		char hostbuf[1024], userbuf[1024], dummy[1024], *host, *user, *cp;
d141 2
a142 2
			auth_debug_add("Ignoring wild host/user names in %.100s.",
			    filename);
d150 2
a151 1
		} else if (strcasecmp(host, hostname) && strcmp(host, ipaddr) != 0)
d210 2
a211 1
	 * Quick check: if the user has no .shosts or .rhosts files, return
d226 4
a229 1
	/* Deny if The user has no .shosts or .rhosts file and there are no system-wide files. */
d232 2
a233 1
	    stat(_PATH_SSH_HOSTS_EQUIV, &st) < 0)
d235 1
d237 7
a243 2
	/* If not logging in as superuser, try /etc/hosts.equiv and shosts.equiv. */
	if (pw->pw_uid != 0) {
d246 2
a247 2
			auth_debug_add("Accepted for %.100s [%.100s] by /etc/hosts.equiv.",
			    hostname, ipaddr);
d252 2
a253 2
			auth_debug_add("Accepted for %.100s [%.100s] by %.100s.",
			    hostname, ipaddr, _PATH_SSH_HOSTS_EQUIV);
d257 1
d304 4
a307 1
		/* Check if we have been configured to ignore .rhosts and .shosts files. */
d309 2
a310 2
			auth_debug_add("Server has been configured to ignore %.100s.",
			    rhosts_files[rhosts_file_index]);
d314 2
a315 1
		if (check_rhosts_file(buf, hostname, ipaddr, client_user, pw->pw_name)) {
d320 3
a322 2
			auth_debug_add("Accepted host %s ip %s client_user %s server_user %s",
				hostname, ipaddr, client_user, pw->pw_name);
@


1.44
log
@Hold authentication debug messages until after successful authentication.
Fixes an info leak of environment variables specified in authorized_keys,
reported by Jacob Appelbaum.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rhosts.c,v 1.43 2008/06/13 14:18:51 dtucker Exp $ */
d33 1
a38 1
#include "misc.h"
@


1.43
log
@Include unistd.h for close(), prevents warnings in -portable
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rhosts.c,v 1.42 2008/06/13 04:40:22 djm Exp $ */
d316 1
a316 7
	int ret;

	auth_debug_reset();
	ret = auth_rhosts2_raw(pw, client_user, hostname, ipaddr);
	if (!use_privsep)
		auth_debug_send();
	return ret;
@


1.42
log
@refuse to read ~/.shosts or ~/.ssh/authorized_keys that are not
regular files; report from Solar Designer via Colin Watson in bz#1471
ok dtucker@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rhosts.c,v 1.41 2006/08/03 03:34:41 deraadt Exp $ */
d26 1
@


1.41
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rhosts.c,v 1.40 2006/08/01 23:22:47 stevesk Exp $ */
d20 1
d37 1
d56 2
d60 1
a60 2
	f = fopen(filename, "r");
	if (!f)
d62 15
a76 1

@


1.40
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rhosts.c,v 1.39 2006/07/22 20:48:22 stevesk Exp $ */
a16 2
#include "includes.h"

d24 1
d27 1
d33 2
@


1.39
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rhosts.c,v 1.38 2006/07/06 16:03:53 stevesk Exp $ */
d24 1
@


1.38
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rhosts.c,v 1.37 2006/03/25 13:17:01 djm Exp $ */
d24 1
@


1.37
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d23 1
@


1.36
log
@RCSID() can die
@
text
@d1 1
@


1.35
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@a16 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.34 2006/02/07 01:08:04 stevesk Exp $");
@


1.35.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth-rhosts.c,v 1.41 2006/08/03 03:34:41 deraadt Exp $ */
d16 3
a22 4
#include <pwd.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
a24 1
#include "buffer.h"
a29 2
#include "key.h"
#include "hostfile.h"
@


1.34
log
@move #include <netgroup.h> out of includes.h; ok markus@@
@
text
@d17 4
a20 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.33 2005/07/17 07:17:54 djm Exp $");
@


1.33
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@d17 3
a19 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.32 2003/11/04 08:54:09 djm Exp $");
@


1.33.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth-rhosts.c,v 1.41 2006/08/03 03:34:41 deraadt Exp $ */
d16 2
a17 8
#include <sys/types.h>
#include <sys/stat.h>

#include <netgroup.h>
#include <pwd.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
a19 1
#include "buffer.h"
a24 2
#include "key.h"
#include "hostfile.h"
@


1.32
log
@standardise arguments to auth methods - they should all take authctxt.
check authctxt->valid rather then pw != NULL; ok markus@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.31 2003/06/02 09:17:34 markus Exp $");
d136 1
a136 1
			     filename);
@


1.32.6.1
log
@upgrade to OpenSSH 4.2
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.33 2005/07/17 07:17:54 djm Exp $");
d136 1
a136 1
			    filename);
@


1.32.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.33 2005/07/17 07:17:54 djm Exp $");
d136 1
a136 1
			    filename);
@


1.31
log
@deprecate VerifyReverseMapping since it's dangerous if combined
with IP based access control as noted by Mike Harding; replace with
a UseDNS option, UseDNS is on by default and includes the
VerifyReverseMapping check; with itojun@@, provos@@, jakob@@ and deraadt@@
ok deraadt@@, djm@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.30 2003/05/17 03:25:58 itojun Exp $");
a174 4

	/* no user given */
	if (pw == NULL)
		return 0;
@


1.31.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.32 2003/11/04 08:54:09 djm Exp $");
d175 4
@


1.30
log
@just in case, put numbers to sscanf %s arg.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.29 2003/04/08 20:21:28 itojun Exp $");
d159 1
a159 1
	hostname = get_canonical_hostname(options.verify_reverse_mapping);
@


1.29
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.28 2002/05/13 21:26:49 markus Exp $");
d71 2
a72 1
		switch (sscanf(buf, "%s %s %s", hostbuf, userbuf, dummy)) {
@


1.28
log
@handle debug messages during rhosts-rsa and hostbased authentication; ok provos@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.27 2002/03/04 12:43:06 markus Exp $");
d223 1
a223 1
		log("Rhosts authentication refused for %.100s: "
d232 1
a232 1
		log("Rhosts authentication refused for %.100s: "
d259 1
a259 1
			log("Rhosts authentication refused for %.100s: bad modes for %.200s",
@


1.28.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.31 2003/06/02 09:17:34 markus Exp $");
d71 1
a71 2
		switch (sscanf(buf, "%1023s %1023s %1023s", hostbuf, userbuf,
		    dummy)) {
d158 1
a158 1
	hostname = get_canonical_hostname(options.use_dns);
d223 1
a223 1
		logit("Rhosts authentication refused for %.100s: "
d232 1
a232 1
		logit("Rhosts authentication refused for %.100s: "
d259 1
a259 1
			logit("Rhosts authentication refused for %.100s: bad modes for %.200s",
@


1.28.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.31 2003/06/02 09:17:34 markus Exp $");
d71 1
a71 2
		switch (sscanf(buf, "%1023s %1023s %1023s", hostbuf, userbuf,
		    dummy)) {
d158 1
a158 1
	hostname = get_canonical_hostname(options.use_dns);
d223 1
a223 1
		logit("Rhosts authentication refused for %.100s: "
d232 1
a232 1
		logit("Rhosts authentication refused for %.100s: "
d259 1
a259 1
			logit("Rhosts authentication refused for %.100s: bad modes for %.200s",
@


1.28.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.32 2003/11/04 08:54:09 djm Exp $");
d175 4
@


1.27
log
@unused include
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.26 2002/01/29 14:32:03 markus Exp $");
d29 1
d73 1
a73 1
			packet_send_debug("Found empty line in %.100s.", filename);
d83 1
a83 1
			packet_send_debug("Found garbage in %.100s.", filename);
d110 2
a111 2
			packet_send_debug("Ignoring wild host/user names in %.100s.",
					  filename);
d134 2
a135 2
			packet_send_debug("Matched negative entry in %.100s.",
					  filename);
a156 1
	int ret;
d160 1
a160 2
	ret = auth_rhosts2(pw, client_user, hostname, ipaddr);
	return ret;
d163 2
a164 2
int
auth_rhosts2(struct passwd *pw, const char *client_user, const char *hostname,
d207 1
a207 1
			packet_send_debug("Accepted for %.100s [%.100s] by /etc/hosts.equiv.",
d213 1
a213 1
			packet_send_debug("Accepted for %.100s [%.100s] by %.100s.",
d223 4
a226 4
		log("Rhosts authentication refused for %.100s: no home directory %.200s",
		    pw->pw_name, pw->pw_dir);
		packet_send_debug("Rhosts authentication refused for %.100s: no home directory %.200s",
				  pw->pw_name, pw->pw_dir);
d232 4
a235 4
		log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
		    pw->pw_name);
		packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
				  pw->pw_name);
d261 1
a261 1
			packet_send_debug("Bad file modes for %.200s", buf);
d266 2
a267 2
			packet_send_debug("Server has been configured to ignore %.100s.",
					  rhosts_files[rhosts_file_index]);
d272 2
a273 2
			packet_send_debug("Accepted by %.100s.",
					  rhosts_files[rhosts_file_index]);
d276 2
d285 13
@


1.27.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.28 2002/05/13 21:26:49 markus Exp $");
a28 1
extern int use_privsep;
d72 1
a72 1
			auth_debug_add("Found empty line in %.100s.", filename);
d82 1
a82 1
			auth_debug_add("Found garbage in %.100s.", filename);
d109 2
a110 2
			auth_debug_add("Ignoring wild host/user names in %.100s.",
			    filename);
d133 2
a134 2
			auth_debug_add("Matched negative entry in %.100s.",
			     filename);
d156 1
d160 2
a161 1
	return auth_rhosts2(pw, client_user, hostname, ipaddr);
d164 2
a165 2
static int
auth_rhosts2_raw(struct passwd *pw, const char *client_user, const char *hostname,
d208 1
a208 1
			auth_debug_add("Accepted for %.100s [%.100s] by /etc/hosts.equiv.",
d214 1
a214 1
			auth_debug_add("Accepted for %.100s [%.100s] by %.100s.",
d224 4
a227 4
		log("Rhosts authentication refused for %.100s: "
		    "no home directory %.200s", pw->pw_name, pw->pw_dir);
		auth_debug_add("Rhosts authentication refused for %.100s: "
		    "no home directory %.200s", pw->pw_name, pw->pw_dir);
d233 4
a236 4
		log("Rhosts authentication refused for %.100s: "
		    "bad ownership or modes for home directory.", pw->pw_name);
		auth_debug_add("Rhosts authentication refused for %.100s: "
		    "bad ownership or modes for home directory.", pw->pw_name);
d262 1
a262 1
			auth_debug_add("Bad file modes for %.200s", buf);
d267 2
a268 2
			auth_debug_add("Server has been configured to ignore %.100s.",
			    rhosts_files[rhosts_file_index]);
d273 2
a274 2
			auth_debug_add("Accepted by %.100s.",
			    rhosts_files[rhosts_file_index]);
a276 2
			auth_debug_add("Accepted host %s ip %s client_user %s server_user %s",
				hostname, ipaddr, client_user, pw->pw_name);
a283 13
}

int
auth_rhosts2(struct passwd *pw, const char *client_user, const char *hostname,
    const char *ipaddr)
{
	int ret;

	auth_debug_reset();
	ret = auth_rhosts2_raw(pw, client_user, hostname, ipaddr);
	if (!use_privsep)
		auth_debug_send();
	return ret;
@


1.27.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.27.2.3
log
@Pull in OpenSSH-3.4
@
text
@@


1.26
log
@s/ReverseMappingCheck/VerifyReverseMapping/ and avoid confusion; ok stevesk@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.25 2001/12/19 07:18:56 deraadt Exp $");
a19 1
#include "xmalloc.h"
@


1.25
log
@basic KNF done while i was looking for something else
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.24 2001/06/23 15:12:17 itojun Exp $");
d159 1
a159 1
	hostname = get_canonical_hostname(options.reverse_mapping_check);
@


1.24
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.23 2001/04/12 19:15:24 markus Exp $");
d189 1
a189 1
	     rhosts_file_index++) {
d207 2
a208 2
		if (check_rhosts_file(_PATH_RHOSTS_EQUIV, hostname, ipaddr, client_user,
				      pw->pw_name)) {
d210 1
a210 1
					  hostname, ipaddr);
d213 2
a214 2
		if (check_rhosts_file(_PATH_SSH_HOSTS_EQUIV, hostname, ipaddr, client_user,
				      pw->pw_name)) {
d216 1
a216 1
				      hostname, ipaddr, _PATH_SSH_HOSTS_EQUIV);
d233 1
a233 1
	     (st.st_mode & 022) != 0)) {
d245 1
a245 1
	     rhosts_file_index++) {
d260 1
a260 1
		     (st.st_mode & 022) != 0)) {
@


1.24.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.27 2002/03/04 12:43:06 markus Exp $");
d20 1
d159 1
a159 1
	hostname = get_canonical_hostname(options.verify_reverse_mapping);
d189 1
a189 1
	    rhosts_file_index++) {
d207 2
a208 2
		if (check_rhosts_file(_PATH_RHOSTS_EQUIV, hostname, ipaddr,
		    client_user, pw->pw_name)) {
d210 1
a210 1
			    hostname, ipaddr);
d213 2
a214 2
		if (check_rhosts_file(_PATH_SSH_HOSTS_EQUIV, hostname, ipaddr,
		    client_user, pw->pw_name)) {
d216 1
a216 1
			    hostname, ipaddr, _PATH_SSH_HOSTS_EQUIV);
d233 1
a233 1
	    (st.st_mode & 022) != 0)) {
d245 1
a245 1
	    rhosts_file_index++) {
d260 1
a260 1
		    (st.st_mode & 022) != 0)) {
@


1.24.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.28 2002/05/13 21:26:49 markus Exp $");
a28 1
extern int use_privsep;
d72 1
a72 1
			auth_debug_add("Found empty line in %.100s.", filename);
d82 1
a82 1
			auth_debug_add("Found garbage in %.100s.", filename);
d109 2
a110 2
			auth_debug_add("Ignoring wild host/user names in %.100s.",
			    filename);
d133 2
a134 2
			auth_debug_add("Matched negative entry in %.100s.",
			     filename);
d156 1
d160 2
a161 1
	return auth_rhosts2(pw, client_user, hostname, ipaddr);
d164 2
a165 2
static int
auth_rhosts2_raw(struct passwd *pw, const char *client_user, const char *hostname,
d208 1
a208 1
			auth_debug_add("Accepted for %.100s [%.100s] by /etc/hosts.equiv.",
d214 1
a214 1
			auth_debug_add("Accepted for %.100s [%.100s] by %.100s.",
d224 4
a227 4
		log("Rhosts authentication refused for %.100s: "
		    "no home directory %.200s", pw->pw_name, pw->pw_dir);
		auth_debug_add("Rhosts authentication refused for %.100s: "
		    "no home directory %.200s", pw->pw_name, pw->pw_dir);
d233 4
a236 4
		log("Rhosts authentication refused for %.100s: "
		    "bad ownership or modes for home directory.", pw->pw_name);
		auth_debug_add("Rhosts authentication refused for %.100s: "
		    "bad ownership or modes for home directory.", pw->pw_name);
d262 1
a262 1
			auth_debug_add("Bad file modes for %.200s", buf);
d267 2
a268 2
			auth_debug_add("Server has been configured to ignore %.100s.",
			    rhosts_files[rhosts_file_index]);
d273 2
a274 2
			auth_debug_add("Accepted by %.100s.",
			    rhosts_files[rhosts_file_index]);
a276 2
			auth_debug_add("Accepted host %s ip %s client_user %s server_user %s",
				hostname, ipaddr, client_user, pw->pw_name);
a283 13
}

int
auth_rhosts2(struct passwd *pw, const char *client_user, const char *hostname,
    const char *ipaddr)
{
	int ret;

	auth_debug_reset();
	ret = auth_rhosts2_raw(pw, client_user, hostname, ipaddr);
	if (!use_privsep)
		auth_debug_send();
	return ret;
@


1.23
log
@implement HostbasedAuthentication (= RhostRSAAuthentication for ssh v2)
similar to RhostRSAAuthentication unless you enable (the experimental)
HostbasedUsesNameFromPacketOnly option.  please test. :)
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.22 2001/04/06 21:00:06 markus Exp $");
d37 1
a37 1
int
@


1.23.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.24 2001/06/23 15:12:17 itojun Exp $");
d37 1
a37 1
static int
@


1.23.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.27 2002/03/04 12:43:06 markus Exp $");
d20 1
d159 1
a159 1
	hostname = get_canonical_hostname(options.verify_reverse_mapping);
d189 1
a189 1
	    rhosts_file_index++) {
d207 2
a208 2
		if (check_rhosts_file(_PATH_RHOSTS_EQUIV, hostname, ipaddr,
		    client_user, pw->pw_name)) {
d210 1
a210 1
			    hostname, ipaddr);
d213 2
a214 2
		if (check_rhosts_file(_PATH_SSH_HOSTS_EQUIV, hostname, ipaddr,
		    client_user, pw->pw_name)) {
d216 1
a216 1
			    hostname, ipaddr, _PATH_SSH_HOSTS_EQUIV);
d233 1
a233 1
	    (st.st_mode & 022) != 0)) {
d245 1
a245 1
	    rhosts_file_index++) {
d260 1
a260 1
		    (st.st_mode & 022) != 0)) {
@


1.23.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.28 2002/05/13 21:26:49 markus Exp $");
a28 1
extern int use_privsep;
d72 1
a72 1
			auth_debug_add("Found empty line in %.100s.", filename);
d82 1
a82 1
			auth_debug_add("Found garbage in %.100s.", filename);
d109 2
a110 2
			auth_debug_add("Ignoring wild host/user names in %.100s.",
			    filename);
d133 2
a134 2
			auth_debug_add("Matched negative entry in %.100s.",
			     filename);
d156 1
d160 2
a161 1
	return auth_rhosts2(pw, client_user, hostname, ipaddr);
d164 2
a165 2
static int
auth_rhosts2_raw(struct passwd *pw, const char *client_user, const char *hostname,
d208 1
a208 1
			auth_debug_add("Accepted for %.100s [%.100s] by /etc/hosts.equiv.",
d214 1
a214 1
			auth_debug_add("Accepted for %.100s [%.100s] by %.100s.",
d224 4
a227 4
		log("Rhosts authentication refused for %.100s: "
		    "no home directory %.200s", pw->pw_name, pw->pw_dir);
		auth_debug_add("Rhosts authentication refused for %.100s: "
		    "no home directory %.200s", pw->pw_name, pw->pw_dir);
d233 4
a236 4
		log("Rhosts authentication refused for %.100s: "
		    "bad ownership or modes for home directory.", pw->pw_name);
		auth_debug_add("Rhosts authentication refused for %.100s: "
		    "bad ownership or modes for home directory.", pw->pw_name);
d262 1
a262 1
			auth_debug_add("Bad file modes for %.200s", buf);
d267 2
a268 2
			auth_debug_add("Server has been configured to ignore %.100s.",
			    rhosts_files[rhosts_file_index]);
d273 2
a274 2
			auth_debug_add("Accepted by %.100s.",
			    rhosts_files[rhosts_file_index]);
a276 2
			auth_debug_add("Accepted host %s ip %s client_user %s server_user %s",
				hostname, ipaddr, client_user, pw->pw_name);
a283 13
}

int
auth_rhosts2(struct passwd *pw, const char *client_user, const char *hostname,
    const char *ipaddr)
{
	int ret;

	auth_debug_reset();
	ret = auth_rhosts2_raw(pw, client_user, hostname, ipaddr);
	if (!use_privsep)
		auth_debug_send();
	return ret;
@


1.22
log
@do gid/groups-swap in addition to uid-swap, should help if /home/group
is chmod 750 + chgrp grp /home/group/, work be deraadt and me, thanks
to olar@@openwall.com is comments.  we had many requests for this.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.21 2001/02/08 19:30:51 itojun Exp $");
d28 3
d156 13
a168 1
	extern ServerOptions options;
a169 1
	const char *hostname, *ipaddr;
d174 3
d180 1
a203 3

	hostname = get_canonical_hostname(options.reverse_mapping_check);
	ipaddr = get_remote_ipaddr();
@


1.21
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.20 2001/02/03 10:08:36 markus Exp $");
d164 1
a164 1
	temporarily_use_uid(pw->pw_uid);
d226 1
a226 1
	temporarily_use_uid(pw->pw_uid);
@


1.20
log
@make ReverseMappingCheck optional in sshd_config; ok djm@@,dugsong@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.19 2001/01/21 19:05:42 markus Exp $");
d26 1
d192 1
a192 1
		if (check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
@


1.19
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.18 2001/01/19 15:55:10 markus Exp $");
d186 1
a186 1
	hostname = get_canonical_hostname();
@


1.18
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.17 2000/12/19 23:17:55 markus Exp $");
a19 1
#include "ssh.h"
d22 2
d25 1
a25 1
#include "pathnames.h"
@


1.17
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.16 2000/10/03 18:03:03 markus Exp $");
d24 1
d181 2
a182 2
	    stat("/etc/hosts.equiv", &st) < 0 &&
	    stat(SSH_HOSTS_EQUIV, &st) < 0)
d196 1
a196 1
		if (check_rhosts_file(SSH_HOSTS_EQUIV, hostname, ipaddr, client_user,
d199 1
a199 1
				      hostname, ipaddr, SSH_HOSTS_EQUIV);
@


1.16
log
@move fake-auth from auth1.c to individual auth methods, disables s/key in debug-msg
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.15 2000/09/07 20:27:49 deraadt Exp $");
d155 1
a155 1
	unsigned int rhosts_file_index;
@


1.16.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.21 2001/02/08 19:30:51 itojun Exp $");
d20 1
a22 2
#include "pathnames.h"
#include "log.h"
a23 2
#include "canohost.h"
#include "auth.h"
d155 1
a155 1
	u_int rhosts_file_index;
d180 2
a181 2
	    stat(_PATH_RHOSTS_EQUIV, &st) < 0 &&
	    stat(_PATH_SSH_HOSTS_EQUIV, &st) < 0)
d184 1
a184 1
	hostname = get_canonical_hostname(options.reverse_mapping_check);
d189 1
a189 1
		if (check_rhosts_file(_PATH_RHOSTS_EQUIV, hostname, ipaddr, client_user,
d195 1
a195 1
		if (check_rhosts_file(_PATH_SSH_HOSTS_EQUIV, hostname, ipaddr, client_user,
d198 1
a198 1
				      hostname, ipaddr, _PATH_SSH_HOSTS_EQUIV);
@


1.16.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.16.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.16.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.23 2001/04/12 19:15:24 markus Exp $");
a27 3
/* import */
extern ServerOptions options;

d153 2
a155 13
	int ret;

	hostname = get_canonical_hostname(options.reverse_mapping_check);
	ipaddr = get_remote_ipaddr();
	ret = auth_rhosts2(pw, client_user, hostname, ipaddr);
	return ret;
}

int
auth_rhosts2(struct passwd *pw, const char *client_user, const char *hostname,
    const char *ipaddr)
{
	char buf[1024];
a159 3
	debug2("auth_rhosts2: clientuser %s hostname %s ipaddr %s",
	    client_user, hostname, ipaddr);

a162 1

d164 1
a164 1
	temporarily_use_uid(pw);
d187 3
d226 1
a226 1
	temporarily_use_uid(pw);
@


1.16.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.24 2001/06/23 15:12:17 itojun Exp $");
d37 1
a37 1
static int
@


1.16.2.6
log
@Merge OpenSSH 3.1.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.27 2002/03/04 12:43:06 markus Exp $");
d20 1
d159 1
a159 1
	hostname = get_canonical_hostname(options.verify_reverse_mapping);
d189 1
a189 1
	    rhosts_file_index++) {
d207 2
a208 2
		if (check_rhosts_file(_PATH_RHOSTS_EQUIV, hostname, ipaddr,
		    client_user, pw->pw_name)) {
d210 1
a210 1
			    hostname, ipaddr);
d213 2
a214 2
		if (check_rhosts_file(_PATH_SSH_HOSTS_EQUIV, hostname, ipaddr,
		    client_user, pw->pw_name)) {
d216 1
a216 1
			    hostname, ipaddr, _PATH_SSH_HOSTS_EQUIV);
d233 1
a233 1
	    (st.st_mode & 022) != 0)) {
d245 1
a245 1
	    rhosts_file_index++) {
d260 1
a260 1
		    (st.st_mode & 022) != 0)) {
@


1.15
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.14 2000/06/20 01:39:38 markus Exp $");
d157 3
@


1.14
log
@OpenBSD tag
@
text
@a1 3
 *
 * auth-rhosts.c
 *
a2 1
 *
a4 3
 *
 * Created: Fri Mar 17 05:12:18 1995 ylo
 *
d9 5
d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.13 2000/04/14 10:30:29 markus Exp $");
@


1.13
log
@whitespace cleanup
@
text
@d19 1
a19 1
RCSID("$Id: auth-rhosts.c,v 1.12 1999/12/27 10:46:11 markus Exp $");
@


1.13.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d19 1
a19 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.14 2000/06/20 01:39:38 markus Exp $");
@


1.13.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a15 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d19 1
a19 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.16 2000/10/03 18:03:03 markus Exp $");
a158 3
	/* no user given */
	if (pw == NULL)
		return 0;
@


1.13.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rhosts.c,v 1.21 2001/02/08 19:30:51 itojun Exp $");
d20 1
a22 2
#include "pathnames.h"
#include "log.h"
a23 2
#include "canohost.h"
#include "auth.h"
d155 1
a155 1
	u_int rhosts_file_index;
d180 2
a181 2
	    stat(_PATH_RHOSTS_EQUIV, &st) < 0 &&
	    stat(_PATH_SSH_HOSTS_EQUIV, &st) < 0)
d184 1
a184 1
	hostname = get_canonical_hostname(options.reverse_mapping_check);
d189 1
a189 1
		if (check_rhosts_file(_PATH_RHOSTS_EQUIV, hostname, ipaddr, client_user,
d195 1
a195 1
		if (check_rhosts_file(_PATH_SSH_HOSTS_EQUIV, hostname, ipaddr, client_user,
d198 1
a198 1
				      hostname, ipaddr, _PATH_SSH_HOSTS_EQUIV);
@


1.13.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.12
log
@check format string for packet_disconnect and packet_send_debug, too
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d15 1
a15 1
 * 
d19 1
a19 1
RCSID("$Id: auth-rhosts.c,v 1.11 1999/11/24 19:53:43 markus Exp $");
d33 1
a33 1
int 
d149 1
a149 1
int 
@


1.11
log
@KNF, final part 3
@
text
@d19 1
a19 1
RCSID("$Id: auth-rhosts.c,v 1.10 1999/11/24 00:26:00 deraadt Exp $");
d208 1
a208 1
		packet_send_debug("Rhosts authentication refused for %.100: no home directory %.200s",
@


1.10
log
@much more KNF
@
text
@d19 1
a19 1
RCSID("$Id: auth-rhosts.c,v 1.9 1999/11/23 22:25:52 markus Exp $");
d27 5
a31 3
/* This function processes an rhosts-style file (.rhosts, .shosts, or
   /etc/hosts.equiv).  This returns true if authentication can be granted
   based on the file, and returns zero otherwise. */
a45 1
	/* Go through the file, checking every entry. */
d56 4
a59 2
		/* NO_PLUS is supported at least on OSF/1.  We skip it (we
		   don't ever support the plus syntax). */
d63 4
a66 2
		/* This should be safe because each buffer is as big as
		   the whole string, and thus cannot be overwritten. */
d143 5
a147 4
/* Tries to authenticate the user using the .shosts or .rhosts file.
   Returns true if authentication succeeds.  If ignore_rhosts is
   true, only /etc/hosts.equiv will be considered (.rhosts and .shosts
   are ignored). */
a158 3
	/* Quick check: if the user has no .shosts or .rhosts files,
	   return failure immediately without doing costly lookups from
	   name servers. */
d161 5
a182 1
	/* Get the name, address, and port of the remote host.  */
d201 4
a204 2
	/* Check that the home directory is owned by root or the user, and
	   is not group or world writable. */
d233 6
a238 4
		/* Make sure that the file is either owned by the user or
		   by root, and make sure it is not writable by anyone but
		   the owner.  This is to help avoid novices accidentally
		   allowing access to their account by anyone. */
@


1.9
log
@KNF part 1
@
text
@d2 15
a16 15

auth-rhosts.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Fri Mar 17 05:12:18 1995 ylo

Rhosts authentication.  This file contains code to check whether to admit
the login based on rhosts authentication.  This file also processes
/etc/hosts.equiv.

*/
d19 1
a19 1
RCSID("$Id: auth-rhosts.c,v 1.8 1999/11/18 14:00:47 markus Exp $");
@


1.8
log
@more %d vs. %s in fmt-strings
@
text
@d19 1
a19 1
RCSID("$Id: auth-rhosts.c,v 1.7 1999/11/14 23:20:09 markus Exp $");
d31 4
a34 3
int check_rhosts_file(const char *filename, const char *hostname,
		      const char *ipaddr, const char *client_user,
		      const char *server_user)
d36 2
a37 45
  FILE *f;
  char buf[1024]; /* Must not be larger than host, user, dummy below. */
  
  /* Open the .rhosts file. */
  f = fopen(filename, "r");
  if (!f)
    return 0; /* Cannot read the .rhosts - deny access. */

  /* Go through the file, checking every entry. */
  while (fgets(buf, sizeof(buf), f))
    {
      /* All three must be at least as big as buf to avoid overflows. */
      char hostbuf[1024], userbuf[1024], dummy[1024], *host, *user, *cp;
      int negated;
      
      for (cp = buf; *cp == ' ' || *cp == '\t'; cp++)
	;
      if (*cp == '#' || *cp == '\n' || !*cp)
	continue;

      /* NO_PLUS is supported at least on OSF/1.  We skip it (we don't ever
	 support the plus syntax). */
      if (strncmp(cp, "NO_PLUS", 7) == 0)
	continue;

      /* This should be safe because each buffer is as big as the whole
	 string, and thus cannot be overwritten. */
      switch (sscanf(buf, "%s %s %s", hostbuf, userbuf, dummy))
	{
	case 0:
	  packet_send_debug("Found empty line in %.100s.", filename);
	  continue; /* Empty line? */
	case 1:
	  /* Host name only. */
	  strlcpy(userbuf, server_user, sizeof(userbuf));
	  break;
	case 2:
	  /* Got both host and user name. */
	  break;
	case 3:
	  packet_send_debug("Found garbage in %.100s.", filename);
	  continue; /* Extra garbage */
	default:
	  continue; /* Weird... */
	}
d39 97
a135 71
      host = hostbuf;
      user = userbuf;
      negated = 0;

      /* Process negated host names, or positive netgroups. */
      if (host[0] == '-')
	{
	  negated = 1;
	  host++;
	}
      else
	if (host[0] == '+')
	  host++;

      if (user[0] == '-')
	{
	  negated = 1;
	  user++;
	}
      else
	if (user[0] == '+')
	  user++;

      /* Check for empty host/user names (particularly '+'). */
      if (!host[0] || !user[0])
	{ 
	  /* We come here if either was '+' or '-'. */
	  packet_send_debug("Ignoring wild host/user names in %.100s.",
			    filename);
	  continue;
	}
	  
      /* Verify that host name matches. */
      if (host[0] == '@@')
	{
	  if (!innetgr(host + 1, hostname, NULL, NULL) &&
	      !innetgr(host + 1, ipaddr, NULL, NULL))
	    continue;
	}
      else
	if (strcasecmp(host, hostname) && strcmp(host, ipaddr) != 0)
	  continue; /* Different hostname. */

      /* Verify that user name matches. */
      if (user[0] == '@@')
	{
	  if (!innetgr(user + 1, NULL, client_user, NULL))
	    continue;
	}
      else
	if (strcmp(user, client_user) != 0)
	  continue; /* Different username. */

      /* Found the user and host. */
      fclose(f);

      /* If the entry was negated, deny access. */
      if (negated)
	{
	  packet_send_debug("Matched negative entry in %.100s.",
			    filename);
	  return 0;
	}

      /* Accept authentication. */
      return 1;
    }
     
  /* Authentication using this file denied. */
  fclose(f);
  return 0;
d138 1
a138 1
/* Tries to authenticate the user using the .shosts or .rhosts file.  
d143 2
a144 1
int auth_rhosts(struct passwd *pw, const char *client_user)
d146 109
a254 122
  extern ServerOptions options;
  char buf[1024];
  const char *hostname, *ipaddr;
  struct stat st;
  static const char *rhosts_files[] = { ".shosts", ".rhosts", NULL };
  unsigned int rhosts_file_index;

  /* Quick check: if the user has no .shosts or .rhosts files, return failure
     immediately without doing costly lookups from name servers. */
  /* Switch to the user's uid. */
  temporarily_use_uid(pw->pw_uid);
  for (rhosts_file_index = 0; rhosts_files[rhosts_file_index];
       rhosts_file_index++)
    {
      /* Check users .rhosts or .shosts. */
      snprintf(buf, sizeof buf, "%.500s/%.100s", 
	      pw->pw_dir, rhosts_files[rhosts_file_index]);
      if (stat(buf, &st) >= 0)
	break;
    }
  /* Switch back to privileged uid. */
  restore_uid();

  if (!rhosts_files[rhosts_file_index] && stat("/etc/hosts.equiv", &st) < 0 &&
      stat(SSH_HOSTS_EQUIV, &st) < 0)
    return 0; /* The user has no .shosts or .rhosts file and there are no
		 system-wide files. */

  /* Get the name, address, and port of the remote host.  */
  hostname = get_canonical_hostname();
  ipaddr = get_remote_ipaddr();

  /* If not logging in as superuser, try /etc/hosts.equiv and shosts.equiv. */
  if (pw->pw_uid != 0)
    {
      if (check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
			    pw->pw_name))
	{
	  packet_send_debug("Accepted for %.100s [%.100s] by /etc/hosts.equiv.",
			    hostname, ipaddr);
	  return 1;
	}
      if (check_rhosts_file(SSH_HOSTS_EQUIV, hostname, ipaddr, client_user,
			    pw->pw_name))
	{
	  packet_send_debug("Accepted for %.100s [%.100s] by %.100s.", 
			    hostname, ipaddr, SSH_HOSTS_EQUIV);
	  return 1;
	}
    }

  /* Check that the home directory is owned by root or the user, and is not 
     group or world writable. */
  if (stat(pw->pw_dir, &st) < 0)
    {
      log("Rhosts authentication refused for %.100s: no home directory %.200s",
	  pw->pw_name, pw->pw_dir);
      packet_send_debug("Rhosts authentication refused for %.100: no home directory %.200s",
			pw->pw_name, pw->pw_dir);
      return 0;
    }
  if (options.strict_modes && 
      ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
       (st.st_mode & 022) != 0))
    {
      log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
	  pw->pw_name);
      packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
			pw->pw_name);
      return 0;
    }
  
  /* Check all .rhosts files (currently .shosts and .rhosts). */
  /* Temporarily use the user's uid. */
  temporarily_use_uid(pw->pw_uid);
  for (rhosts_file_index = 0; rhosts_files[rhosts_file_index];
       rhosts_file_index++)
    {
      /* Check users .rhosts or .shosts. */
      snprintf(buf, sizeof buf, "%.500s/%.100s", 
	      pw->pw_dir, rhosts_files[rhosts_file_index]);
      if (stat(buf, &st) < 0)
	continue; /* No such file. */

      /* Make sure that the file is either owned by the user or by root,
	 and make sure it is not writable by anyone but the owner.  This is
	 to help avoid novices accidentally allowing access to their account
	 by anyone. */
      if (options.strict_modes &&
	  ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
	   (st.st_mode & 022) != 0))
	{
	  log("Rhosts authentication refused for %.100s: bad modes for %.200s",
	      pw->pw_name, buf);
	  packet_send_debug("Bad file modes for %.200s", buf);
	  continue;
	}

      /* Check if we have been configured to ignore .rhosts and .shosts 
	 files. */
      if (options.ignore_rhosts)
	{
	  packet_send_debug("Server has been configured to ignore %.100s.",
			    rhosts_files[rhosts_file_index]);
	  continue;
	}

      /* Check if authentication is permitted by the file. */
      if (check_rhosts_file(buf, hostname, ipaddr, client_user, pw->pw_name))
	{
	  packet_send_debug("Accepted by %.100s.",
			    rhosts_files[rhosts_file_index]);
	  /* Restore the privileged uid. */
	  restore_uid();
	  return 1;
	}
    }

  /* Rhosts authentication denied. */
  /* Restore the privileged uid. */
  restore_uid();
  return 0;
@


1.7
log
@split do_authentication() in subroutines
move checking of remote port to central place
@
text
@d19 1
a19 1
RCSID("$Id: auth-rhosts.c,v 1.6 1999/11/11 23:36:52 markus Exp $");
d216 1
a216 1
      log("Rhosts authentication refused for %.100: no home directory %.200s",
@


1.6
log
@make all access to options via 'extern Options options'
and 'extern ServerOptions options' respectively;
options are no longer passed as arguments:
 * make options handling more consistent
 * remove #include "readconf.h" from ssh.h
 * readconf.h is only included if necessary
@
text
@d19 1
a19 1
RCSID("$Id: auth-rhosts.c,v 1.5 1999/10/03 20:09:18 deraadt Exp $");
a163 1
  int port;
a191 15
  port = get_remote_port();

  /* Check that the connection comes from a privileged port.
     Rhosts authentication only makes sense for priviledged programs.
     Of course, if the intruder has root access on his local machine,
     he can connect from any port.  So do not use .rhosts
     authentication from machines that you do not trust. */
  if (port >= IPPORT_RESERVED ||
      port < IPPORT_RESERVED / 2)
    {
      log("Connection from %.100s from nonpriviledged port %d",
	  hostname, port);
      packet_send_debug("Your ssh client is not running as root.");
      return 0;
    }
@


1.5
log
@use strcasecmp()
@
text
@d19 1
a19 1
RCSID("$Id: auth-rhosts.c,v 1.4 1999/09/30 05:43:33 deraadt Exp $");
d25 1
d159 1
a159 2
int auth_rhosts(struct passwd *pw, const char *client_user,
		int ignore_rhosts, int strict_modes)
d161 1
d238 1
a238 1
  if (strict_modes && 
d265 1
a265 1
      if (strict_modes &&
d277 1
a277 1
      if (ignore_rhosts)
@


1.4
log
@wringing out all the water
@
text
@d19 1
a19 1
RCSID("$Id: auth-rhosts.c,v 1.3 1999/09/29 21:14:15 deraadt Exp $");
a25 21
/* Returns true if the strings are equal, ignoring case (a-z only). */

static int casefold_equal(const char *a, const char *b)
{
  unsigned char cha, chb;
  for (; *a; a++, b++)
    {
      cha = *a;
      chb = *b;
      if (!chb)
	return 0;
      if (cha >= 'a' && cha <= 'z')
	cha -= 32;
      if (chb >= 'a' && chb <= 'z')
	chb -= 32;
      if (cha != chb)
	return 0;
    }
  return !*b;
}

d120 1
a120 1
	if (!casefold_equal(host, hostname) && strcmp(host, ipaddr) != 0)
@


1.3
log
@numerous sprintf, strncpy, strcpy cleanups
@
text
@d19 1
a19 1
RCSID("$Id: auth-rhosts.c,v 1.2 1999/09/28 04:45:35 provos Exp $");
a132 2
#ifdef HAVE_INNETGR

a152 10

#else /* HAVE_INNETGR */

      if (!casefold_equal(host, hostname) && strcmp(host, ipaddr) != 0)
	continue; /* Different hostname. */

      if (strcmp(user, client_user) != 0)
	continue; /* Different username. */

#endif /* HAVE_INNETGR */
@


1.2
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d19 1
a19 1
RCSID("$Id: auth-rhosts.c,v 1.2 1999/05/04 11:58:24 bg Exp $");
d89 1
a89 2
	  strncpy(userbuf, server_user, sizeof(userbuf));
	  userbuf[sizeof(userbuf) - 1] = 0;
d209 1
a209 1
      sprintf(buf, "%.500s/%.100s", 
d288 1
a288 1
      sprintf(buf, "%.500s/%.100s", 
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@@

