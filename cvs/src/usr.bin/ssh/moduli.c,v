head	1.31;
access;
symbols
	OPENBSD_6_0:1.30.0.10
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.6
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.4
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.2
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.10
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.6
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.8
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.6
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.4
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_2:1.1.0.6
	OPENBSD_3_3:1.1.0.4
	OPENBSD_3_4:1.1.0.2
	OPENBSD_3_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	ZllbGwdb0fOmLhjK;

1.30
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	cBx23BaCk6gYBpRj;

1.29
date	2014.08.21.01.08.52;	author doug;	state Exp;
branches;
next	1.28;
commitid	ti47Ets7tAnpzZsc;

1.28
date	2013.10.24.00.49.49;	author dtucker;	state Exp;
branches;
next	1.27;

1.27
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2012.07.06.00.41.59;	author dtucker;	state Exp;
branches;
next	1.25;

1.25
date	2011.10.19.00.06.10;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2011.10.16.15.51.39;	author stsp;	state Exp;
branches;
next	1.23;

1.23
date	2011.10.16.11.02.46;	author dtucker;	state Exp;
branches;
next	1.22;

1.22
date	2010.11.10.01.33.07;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.26.09.19.40;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.24.03.30.11;	author ray;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.06.21.25.28;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.18.4.1;
next	1.17;

1.17
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.22.19.08.54;	author stevesk;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.17.07.17.55;	author djm;	state Exp;
branches
	1.12.2.1
	1.12.4.1;
next	1.11;

1.11
date	2005.05.23.22.44.01;	author avsm;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.17.03.25.46;	author dtucker;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2004.07.11.17.48.47;	author deraadt;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2004.05.21.08.43.03;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.09.00.06.47;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.22.11.56.57;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.22.09.16.57;	author djm;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2003.12.09.13.52.55;	author dtucker;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.07.06.34.18;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.28.09.49.56;	author djm;	state Exp;
branches
	1.1.2.1
	1.1.4.1
	1.1.6.1;
next	;

1.1.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.1.4.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.1.6.1
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.5.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.9.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.10.2.1
date	2005.09.04.18.40.02;	author brad;	state Exp;
branches;
next	;

1.12.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.12.4.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.18.4.1
date	2006.11.08.00.42.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@/* $OpenBSD: moduli.c,v 1.30 2015/01/20 23:14:00 deraadt Exp $ */
/*
 * Copyright 1994 Phil Karn <karn@@qualcomm.com>
 * Copyright 1996-1998, 2003 William Allen Simpson <wsimpson@@greendragon.com>
 * Copyright 2000 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Two-step process to generate safe primes for DHGEX
 *
 *  Sieve candidates for "safe" primes,
 *  suitable for use as Diffie-Hellman moduli;
 *  that is, where q = (p-1)/2 is also prime.
 *
 * First step: generate candidate primes (memory intensive)
 * Second step: test primes' safety (processor intensive)
 */

#include <sys/types.h>

#include <openssl/bn.h>
#include <openssl/dh.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>

#include "xmalloc.h"
#include "dh.h"
#include "log.h"
#include "misc.h"

/*
 * File output defines
 */

/* need line long enough for largest moduli plus headers */
#define QLINESIZE		(100+8192)

/*
 * Size: decimal.
 * Specifies the number of the most significant bit (0 to M).
 * WARNING: internally, usually 1 to N.
 */
#define QSIZE_MINIMUM		(511)

/*
 * Prime sieving defines
 */

/* Constant: assuming 8 bit bytes and 32 bit words */
#define SHIFT_BIT	(3)
#define SHIFT_BYTE	(2)
#define SHIFT_WORD	(SHIFT_BIT+SHIFT_BYTE)
#define SHIFT_MEGABYTE	(20)
#define SHIFT_MEGAWORD	(SHIFT_MEGABYTE-SHIFT_BYTE)

/*
 * Using virtual memory can cause thrashing.  This should be the largest
 * number that is supported without a large amount of disk activity --
 * that would increase the run time from hours to days or weeks!
 */
#define LARGE_MINIMUM	(8UL)	/* megabytes */

/*
 * Do not increase this number beyond the unsigned integer bit size.
 * Due to a multiple of 4, it must be LESS than 128 (yielding 2**30 bits).
 */
#define LARGE_MAXIMUM	(127UL)	/* megabytes */

/*
 * Constant: when used with 32-bit integers, the largest sieve prime
 * has to be less than 2**32.
 */
#define SMALL_MAXIMUM	(0xffffffffUL)

/* Constant: can sieve all primes less than 2**32, as 65537**2 > 2**32-1. */
#define TINY_NUMBER	(1UL<<16)

/* Ensure enough bit space for testing 2*q. */
#define TEST_MAXIMUM	(1UL<<16)
#define TEST_MINIMUM	(QSIZE_MINIMUM + 1)
/* real TEST_MINIMUM	(1UL << (SHIFT_WORD - TEST_POWER)) */
#define TEST_POWER	(3)	/* 2**n, n < SHIFT_WORD */

/* bit operations on 32-bit words */
#define BIT_CLEAR(a,n)	((a)[(n)>>SHIFT_WORD] &= ~(1L << ((n) & 31)))
#define BIT_SET(a,n)	((a)[(n)>>SHIFT_WORD] |= (1L << ((n) & 31)))
#define BIT_TEST(a,n)	((a)[(n)>>SHIFT_WORD] & (1L << ((n) & 31)))

/*
 * Prime testing defines
 */

/* Minimum number of primality tests to perform */
#define TRIAL_MINIMUM	(4)

/*
 * Sieving data (XXX - move to struct)
 */

/* sieve 2**16 */
static u_int32_t *TinySieve, tinybits;

/* sieve 2**30 in 2**16 parts */
static u_int32_t *SmallSieve, smallbits, smallbase;

/* sieve relative to the initial value */
static u_int32_t *LargeSieve, largewords, largetries, largenumbers;
static u_int32_t largebits, largememory;	/* megabytes */
static BIGNUM *largebase;

int gen_candidates(FILE *, u_int32_t, u_int32_t, BIGNUM *);
int prime_test(FILE *, FILE *, u_int32_t, u_int32_t, char *, unsigned long,
    unsigned long);

/*
 * print moduli out in consistent form,
 */
static int
qfileout(FILE * ofile, u_int32_t otype, u_int32_t otests, u_int32_t otries,
    u_int32_t osize, u_int32_t ogenerator, BIGNUM * omodulus)
{
	struct tm *gtm;
	time_t time_now;
	int res;

	time(&time_now);
	gtm = gmtime(&time_now);

	res = fprintf(ofile, "%04d%02d%02d%02d%02d%02d %u %u %u %u %x ",
	    gtm->tm_year + 1900, gtm->tm_mon + 1, gtm->tm_mday,
	    gtm->tm_hour, gtm->tm_min, gtm->tm_sec,
	    otype, otests, otries, osize, ogenerator);

	if (res < 0)
		return (-1);

	if (BN_print_fp(ofile, omodulus) < 1)
		return (-1);

	res = fprintf(ofile, "\n");
	fflush(ofile);

	return (res > 0 ? 0 : -1);
}


/*
 ** Sieve p's and q's with small factors
 */
static void
sieve_large(u_int32_t s)
{
	u_int32_t r, u;

	debug3("sieve_large %u", s);
	largetries++;
	/* r = largebase mod s */
	r = BN_mod_word(largebase, s);
	if (r == 0)
		u = 0; /* s divides into largebase exactly */
	else
		u = s - r; /* largebase+u is first entry divisible by s */

	if (u < largebits * 2) {
		/*
		 * The sieve omits p's and q's divisible by 2, so ensure that
		 * largebase+u is odd. Then, step through the sieve in
		 * increments of 2*s
		 */
		if (u & 0x1)
			u += s; /* Make largebase+u odd, and u even */

		/* Mark all multiples of 2*s */
		for (u /= 2; u < largebits; u += s)
			BIT_SET(LargeSieve, u);
	}

	/* r = p mod s */
	r = (2 * r + 1) % s;
	if (r == 0)
		u = 0; /* s divides p exactly */
	else
		u = s - r; /* p+u is first entry divisible by s */

	if (u < largebits * 4) {
		/*
		 * The sieve omits p's divisible by 4, so ensure that
		 * largebase+u is not. Then, step through the sieve in
		 * increments of 4*s
		 */
		while (u & 0x3) {
			if (SMALL_MAXIMUM - u < s)
				return;
			u += s;
		}

		/* Mark all multiples of 4*s */
		for (u /= 4; u < largebits; u += s)
			BIT_SET(LargeSieve, u);
	}
}

/*
 * list candidates for Sophie-Germain primes (where q = (p-1)/2)
 * to standard output.
 * The list is checked against small known primes (less than 2**30).
 */
int
gen_candidates(FILE *out, u_int32_t memory, u_int32_t power, BIGNUM *start)
{
	BIGNUM *q;
	u_int32_t j, r, s, t;
	u_int32_t smallwords = TINY_NUMBER >> 6;
	u_int32_t tinywords = TINY_NUMBER >> 6;
	time_t time_start, time_stop;
	u_int32_t i;
	int ret = 0;

	largememory = memory;

	if (memory != 0 &&
	    (memory < LARGE_MINIMUM || memory > LARGE_MAXIMUM)) {
		error("Invalid memory amount (min %ld, max %ld)",
		    LARGE_MINIMUM, LARGE_MAXIMUM);
		return (-1);
	}

	/*
	 * Set power to the length in bits of the prime to be generated.
	 * This is changed to 1 less than the desired safe prime moduli p.
	 */
	if (power > TEST_MAXIMUM) {
		error("Too many bits: %u > %lu", power, TEST_MAXIMUM);
		return (-1);
	} else if (power < TEST_MINIMUM) {
		error("Too few bits: %u < %u", power, TEST_MINIMUM);
		return (-1);
	}
	power--; /* decrement before squaring */

	/*
	 * The density of ordinary primes is on the order of 1/bits, so the
	 * density of safe primes should be about (1/bits)**2. Set test range
	 * to something well above bits**2 to be reasonably sure (but not
	 * guaranteed) of catching at least one safe prime.
	 */
	largewords = ((power * power) >> (SHIFT_WORD - TEST_POWER));

	/*
	 * Need idea of how much memory is available. We don't have to use all
	 * of it.
	 */
	if (largememory > LARGE_MAXIMUM) {
		logit("Limited memory: %u MB; limit %lu MB",
		    largememory, LARGE_MAXIMUM);
		largememory = LARGE_MAXIMUM;
	}

	if (largewords <= (largememory << SHIFT_MEGAWORD)) {
		logit("Increased memory: %u MB; need %u bytes",
		    largememory, (largewords << SHIFT_BYTE));
		largewords = (largememory << SHIFT_MEGAWORD);
	} else if (largememory > 0) {
		logit("Decreased memory: %u MB; want %u bytes",
		    largememory, (largewords << SHIFT_BYTE));
		largewords = (largememory << SHIFT_MEGAWORD);
	}

	TinySieve = xcalloc(tinywords, sizeof(u_int32_t));
	tinybits = tinywords << SHIFT_WORD;

	SmallSieve = xcalloc(smallwords, sizeof(u_int32_t));
	smallbits = smallwords << SHIFT_WORD;

	/*
	 * dynamically determine available memory
	 */
	while ((LargeSieve = calloc(largewords, sizeof(u_int32_t))) == NULL)
		largewords -= (1L << (SHIFT_MEGAWORD - 2)); /* 1/4 MB chunks */

	largebits = largewords << SHIFT_WORD;
	largenumbers = largebits * 2;	/* even numbers excluded */

	/* validation check: count the number of primes tried */
	largetries = 0;
	if ((q = BN_new()) == NULL)
		fatal("BN_new failed");

	/*
	 * Generate random starting point for subprime search, or use
	 * specified parameter.
	 */
	if ((largebase = BN_new()) == NULL)
		fatal("BN_new failed");
	if (start == NULL) {
		if (BN_rand(largebase, power, 1, 1) == 0)
			fatal("BN_rand failed");
	} else {
		if (BN_copy(largebase, start) == NULL)
			fatal("BN_copy: failed");
	}

	/* ensure odd */
	if (BN_set_bit(largebase, 0) == 0)
		fatal("BN_set_bit: failed");

	time(&time_start);

	logit("%.24s Sieve next %u plus %u-bit", ctime(&time_start),
	    largenumbers, power);
	debug2("start point: 0x%s", BN_bn2hex(largebase));

	/*
	 * TinySieve
	 */
	for (i = 0; i < tinybits; i++) {
		if (BIT_TEST(TinySieve, i))
			continue; /* 2*i+3 is composite */

		/* The next tiny prime */
		t = 2 * i + 3;

		/* Mark all multiples of t */
		for (j = i + t; j < tinybits; j += t)
			BIT_SET(TinySieve, j);

		sieve_large(t);
	}

	/*
	 * Start the small block search at the next possible prime. To avoid
	 * fencepost errors, the last pass is skipped.
	 */
	for (smallbase = TINY_NUMBER + 3;
	    smallbase < (SMALL_MAXIMUM - TINY_NUMBER);
	    smallbase += TINY_NUMBER) {
		for (i = 0; i < tinybits; i++) {
			if (BIT_TEST(TinySieve, i))
				continue; /* 2*i+3 is composite */

			/* The next tiny prime */
			t = 2 * i + 3;
			r = smallbase % t;

			if (r == 0) {
				s = 0; /* t divides into smallbase exactly */
			} else {
				/* smallbase+s is first entry divisible by t */
				s = t - r;
			}

			/*
			 * The sieve omits even numbers, so ensure that
			 * smallbase+s is odd. Then, step through the sieve
			 * in increments of 2*t
			 */
			if (s & 1)
				s += t; /* Make smallbase+s odd, and s even */

			/* Mark all multiples of 2*t */
			for (s /= 2; s < smallbits; s += t)
				BIT_SET(SmallSieve, s);
		}

		/*
		 * SmallSieve
		 */
		for (i = 0; i < smallbits; i++) {
			if (BIT_TEST(SmallSieve, i))
				continue; /* 2*i+smallbase is composite */

			/* The next small prime */
			sieve_large((2 * i) + smallbase);
		}

		memset(SmallSieve, 0, smallwords << SHIFT_BYTE);
	}

	time(&time_stop);

	logit("%.24s Sieved with %u small primes in %ld seconds",
	    ctime(&time_stop), largetries, (long) (time_stop - time_start));

	for (j = r = 0; j < largebits; j++) {
		if (BIT_TEST(LargeSieve, j))
			continue; /* Definitely composite, skip */

		debug2("test q = largebase+%u", 2 * j);
		if (BN_set_word(q, 2 * j) == 0)
			fatal("BN_set_word failed");
		if (BN_add(q, q, largebase) == 0)
			fatal("BN_add failed");
		if (qfileout(out, MODULI_TYPE_SOPHIE_GERMAIN,
		    MODULI_TESTS_SIEVE, largetries,
		    (power - 1) /* MSB */, (0), q) == -1) {
			ret = -1;
			break;
		}

		r++; /* count q */
	}

	time(&time_stop);

	free(LargeSieve);
	free(SmallSieve);
	free(TinySieve);

	logit("%.24s Found %u candidates", ctime(&time_stop), r);

	return (ret);
}

static void
write_checkpoint(char *cpfile, u_int32_t lineno)
{
	FILE *fp;
	char tmp[PATH_MAX];
	int r;

	r = snprintf(tmp, sizeof(tmp), "%s.XXXXXXXXXX", cpfile);
	if (r == -1 || r >= PATH_MAX) {
		logit("write_checkpoint: temp pathname too long");
		return;
	}
	if ((r = mkstemp(tmp)) == -1) {
		logit("mkstemp(%s): %s", tmp, strerror(errno));
		return;
	}
	if ((fp = fdopen(r, "w")) == NULL) {
		logit("write_checkpoint: fdopen: %s", strerror(errno));
		unlink(tmp);
		close(r);
		return;
	}
	if (fprintf(fp, "%lu\n", (unsigned long)lineno) > 0 && fclose(fp) == 0
	    && rename(tmp, cpfile) == 0)
		debug3("wrote checkpoint line %lu to '%s'",
		    (unsigned long)lineno, cpfile);
	else
		logit("failed to write to checkpoint file '%s': %s", cpfile,
		    strerror(errno));
}

static unsigned long
read_checkpoint(char *cpfile)
{
	FILE *fp;
	unsigned long lineno = 0;

	if ((fp = fopen(cpfile, "r")) == NULL)
		return 0;
	if (fscanf(fp, "%lu\n", &lineno) < 1)
		logit("Failed to load checkpoint from '%s'", cpfile);
	else
		logit("Loaded checkpoint from '%s' line %lu", cpfile, lineno);
	fclose(fp);
	return lineno;
}

static unsigned long
count_lines(FILE *f)
{
	unsigned long count = 0;
	char lp[QLINESIZE + 1];

	if (fseek(f, 0, SEEK_SET) != 0) {
		debug("input file is not seekable");
		return ULONG_MAX;
	}
	while (fgets(lp, QLINESIZE + 1, f) != NULL)
		count++;
	rewind(f);
	debug("input file has %lu lines", count);
	return count;
}

static char *
fmt_time(time_t seconds)
{
	int day, hr, min;
	static char buf[128];

	min = (seconds / 60) % 60;
	hr = (seconds / 60 / 60) % 24;
	day = seconds / 60 / 60 / 24;
	if (day > 0)
		snprintf(buf, sizeof buf, "%dd %d:%02d", day, hr, min);
	else
		snprintf(buf, sizeof buf, "%d:%02d", hr, min);
	return buf;
}

static void
print_progress(unsigned long start_lineno, unsigned long current_lineno,
    unsigned long end_lineno)
{
	static time_t time_start, time_prev;
	time_t time_now, elapsed;
	unsigned long num_to_process, processed, remaining, percent, eta;
	double time_per_line;
	char *eta_str;

	time_now = monotime();
	if (time_start == 0) {
		time_start = time_prev = time_now;
		return;
	}
	/* print progress after 1m then once per 5m */
	if (time_now - time_prev < 5 * 60)
		return;
	time_prev = time_now;
	elapsed = time_now - time_start;
	processed = current_lineno - start_lineno;
	remaining = end_lineno - current_lineno;
	num_to_process = end_lineno - start_lineno;
	time_per_line = (double)elapsed / processed;
	/* if we don't know how many we're processing just report count+time */
	time(&time_now);
	if (end_lineno == ULONG_MAX) {
		logit("%.24s processed %lu in %s", ctime(&time_now),
		    processed, fmt_time(elapsed));
		return;
	}
	percent = 100 * processed / num_to_process;
	eta = time_per_line * remaining;
	eta_str = xstrdup(fmt_time(eta));
	logit("%.24s processed %lu of %lu (%lu%%) in %s, ETA %s",
	    ctime(&time_now), processed, num_to_process, percent,
	    fmt_time(elapsed), eta_str);
	free(eta_str);
}

/*
 * perform a Miller-Rabin primality test
 * on the list of candidates
 * (checking both q and p)
 * The result is a list of so-call "safe" primes
 */
int
prime_test(FILE *in, FILE *out, u_int32_t trials, u_int32_t generator_wanted,
    char *checkpoint_file, unsigned long start_lineno, unsigned long num_lines)
{
	BIGNUM *q, *p, *a;
	BN_CTX *ctx;
	char *cp, *lp;
	u_int32_t count_in = 0, count_out = 0, count_possible = 0;
	u_int32_t generator_known, in_tests, in_tries, in_type, in_size;
	unsigned long last_processed = 0, end_lineno;
	time_t time_start, time_stop;
	int res;

	if (trials < TRIAL_MINIMUM) {
		error("Minimum primality trials is %d", TRIAL_MINIMUM);
		return (-1);
	}

	if (num_lines == 0)
		end_lineno = count_lines(in);
	else
		end_lineno = start_lineno + num_lines;

	time(&time_start);

	if ((p = BN_new()) == NULL)
		fatal("BN_new failed");
	if ((q = BN_new()) == NULL)
		fatal("BN_new failed");
	if ((ctx = BN_CTX_new()) == NULL)
		fatal("BN_CTX_new failed");

	debug2("%.24s Final %u Miller-Rabin trials (%x generator)",
	    ctime(&time_start), trials, generator_wanted);

	if (checkpoint_file != NULL)
		last_processed = read_checkpoint(checkpoint_file);
	last_processed = start_lineno = MAXIMUM(last_processed, start_lineno);
	if (end_lineno == ULONG_MAX)
		debug("process from line %lu from pipe", last_processed);
	else
		debug("process from line %lu to line %lu", last_processed,
		    end_lineno);

	res = 0;
	lp = xmalloc(QLINESIZE + 1);
	while (fgets(lp, QLINESIZE + 1, in) != NULL && count_in < end_lineno) {
		count_in++;
		if (count_in <= last_processed) {
			debug3("skipping line %u, before checkpoint or "
			    "specified start line", count_in);
			continue;
		}
		if (checkpoint_file != NULL)
			write_checkpoint(checkpoint_file, count_in);
		print_progress(start_lineno, count_in, end_lineno);
		if (strlen(lp) < 14 || *lp == '!' || *lp == '#') {
			debug2("%10u: comment or short line", count_in);
			continue;
		}

		/* XXX - fragile parser */
		/* time */
		cp = &lp[14];	/* (skip) */

		/* type */
		in_type = strtoul(cp, &cp, 10);

		/* tests */
		in_tests = strtoul(cp, &cp, 10);

		if (in_tests & MODULI_TESTS_COMPOSITE) {
			debug2("%10u: known composite", count_in);
			continue;
		}

		/* tries */
		in_tries = strtoul(cp, &cp, 10);

		/* size (most significant bit) */
		in_size = strtoul(cp, &cp, 10);

		/* generator (hex) */
		generator_known = strtoul(cp, &cp, 16);

		/* Skip white space */
		cp += strspn(cp, " ");

		/* modulus (hex) */
		switch (in_type) {
		case MODULI_TYPE_SOPHIE_GERMAIN:
			debug2("%10u: (%u) Sophie-Germain", count_in, in_type);
			a = q;
			if (BN_hex2bn(&a, cp) == 0)
				fatal("BN_hex2bn failed");
			/* p = 2*q + 1 */
			if (BN_lshift(p, q, 1) == 0)
				fatal("BN_lshift failed");
			if (BN_add_word(p, 1) == 0)
				fatal("BN_add_word failed");
			in_size += 1;
			generator_known = 0;
			break;
		case MODULI_TYPE_UNSTRUCTURED:
		case MODULI_TYPE_SAFE:
		case MODULI_TYPE_SCHNORR:
		case MODULI_TYPE_STRONG:
		case MODULI_TYPE_UNKNOWN:
			debug2("%10u: (%u)", count_in, in_type);
			a = p;
			if (BN_hex2bn(&a, cp) == 0)
				fatal("BN_hex2bn failed");
			/* q = (p-1) / 2 */
			if (BN_rshift(q, p, 1) == 0)
				fatal("BN_rshift failed");
			break;
		default:
			debug2("Unknown prime type");
			break;
		}

		/*
		 * due to earlier inconsistencies in interpretation, check
		 * the proposed bit size.
		 */
		if ((u_int32_t)BN_num_bits(p) != (in_size + 1)) {
			debug2("%10u: bit size %u mismatch", count_in, in_size);
			continue;
		}
		if (in_size < QSIZE_MINIMUM) {
			debug2("%10u: bit size %u too short", count_in, in_size);
			continue;
		}

		if (in_tests & MODULI_TESTS_MILLER_RABIN)
			in_tries += trials;
		else
			in_tries = trials;

		/*
		 * guess unknown generator
		 */
		if (generator_known == 0) {
			if (BN_mod_word(p, 24) == 11)
				generator_known = 2;
			else if (BN_mod_word(p, 12) == 5)
				generator_known = 3;
			else {
				u_int32_t r = BN_mod_word(p, 10);

				if (r == 3 || r == 7)
					generator_known = 5;
			}
		}
		/*
		 * skip tests when desired generator doesn't match
		 */
		if (generator_wanted > 0 &&
		    generator_wanted != generator_known) {
			debug2("%10u: generator %d != %d",
			    count_in, generator_known, generator_wanted);
			continue;
		}

		/*
		 * Primes with no known generator are useless for DH, so
		 * skip those.
		 */
		if (generator_known == 0) {
			debug2("%10u: no known generator", count_in);
			continue;
		}

		count_possible++;

		/*
		 * The (1/4)^N performance bound on Miller-Rabin is
		 * extremely pessimistic, so don't spend a lot of time
		 * really verifying that q is prime until after we know
		 * that p is also prime. A single pass will weed out the
		 * vast majority of composite q's.
		 */
		if (BN_is_prime_ex(q, 1, ctx, NULL) <= 0) {
			debug("%10u: q failed first possible prime test",
			    count_in);
			continue;
		}

		/*
		 * q is possibly prime, so go ahead and really make sure
		 * that p is prime. If it is, then we can go back and do
		 * the same for q. If p is composite, chances are that
		 * will show up on the first Rabin-Miller iteration so it
		 * doesn't hurt to specify a high iteration count.
		 */
		if (!BN_is_prime_ex(p, trials, ctx, NULL)) {
			debug("%10u: p is not prime", count_in);
			continue;
		}
		debug("%10u: p is almost certainly prime", count_in);

		/* recheck q more rigorously */
		if (!BN_is_prime_ex(q, trials - 1, ctx, NULL)) {
			debug("%10u: q is not prime", count_in);
			continue;
		}
		debug("%10u: q is almost certainly prime", count_in);

		if (qfileout(out, MODULI_TYPE_SAFE,
		    in_tests | MODULI_TESTS_MILLER_RABIN,
		    in_tries, in_size, generator_known, p)) {
			res = -1;
			break;
		}

		count_out++;
	}

	time(&time_stop);
	free(lp);
	BN_free(p);
	BN_free(q);
	BN_CTX_free(ctx);

	if (checkpoint_file != NULL)
		unlink(checkpoint_file);

	logit("%.24s Found %u safe primes of %u candidates in %ld seconds",
	    ctime(&time_stop), count_out, count_possible,
	    (long) (time_stop - time_start));

	return (res);
}
@


1.30
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.29 2014/08/21 01:08:52 doug Exp $ */
a39 1
#include <sys/param.h>	/* MAX */
d605 1
a605 1
	last_processed = start_lineno = MAX(last_processed, start_lineno);
@


1.29
log
@Free resources on error in mkstemp and fdopen

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.28 2013/10/24 00:49:49 dtucker Exp $ */
d40 1
a40 1
#include <sys/param.h>
d53 1
d447 1
a447 1
	char tmp[MAXPATHLEN];
d451 1
a451 1
	if (r == -1 || r >= MAXPATHLEN) {
@


1.28
log
@Periodically print progress and, if possible, expected time to completion
when screening moduli for DH groups.  ok deraadt djm
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.27 2013/05/17 00:13:13 djm Exp $ */
d460 1
@


1.27
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.26 2012/07/06 00:41:59 dtucker Exp $ */
d57 1
d488 73
d585 5
d604 3
a606 4
	if (start_lineno > last_processed)
		last_processed = start_lineno;
	if (num_lines == 0)
		end_lineno = ULONG_MAX;
d608 2
a609 2
		end_lineno = last_processed + num_lines;
	debug2("process line %lu to line %lu", last_processed, end_lineno);
d615 6
a620 6
		if (checkpoint_file != NULL) {
			if (count_in <= last_processed) {
				debug3("skipping line %u, before checkpoint",
				    count_in);
				continue;
			}
d622 1
a622 1
		}
@


1.26
log
@Add options to specify starting line number and number of lines to process
when screening moduli candidates.  This allows processing of different
parts of a candidate moduli file in parallel.  man page help jmc@@, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.25 2011/10/19 00:06:10 djm Exp $ */
d432 3
a434 3
	xfree(LargeSieve);
	xfree(SmallSieve);
	xfree(TinySieve);
d708 1
a708 1
	xfree(lp);
@


1.25
log
@s/tmpfile/tmp/ to make this -Wshadow clean
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.24 2011/10/16 15:51:39 stsp Exp $ */
d139 2
a140 1
int prime_test(FILE *, FILE *, u_int32_t, u_int32_t, char *);
d495 1
a495 1
    char *checkpoint_file)
d502 1
a502 1
	unsigned long last_processed = 0;
d525 7
d535 1
a535 1
	while (fgets(lp, QLINESIZE + 1, in) != NULL) {
@


1.24
log
@add missing includes to unbreak tree; fix from rpointel
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.23 2011/10/16 11:02:46 dtucker Exp $ */
d444 1
a444 1
	char tmpfile[MAXPATHLEN];
d447 1
a447 1
	r = snprintf(tmpfile, sizeof(tmpfile), "%s.XXXXXXXXXX", cpfile);
d452 2
a453 2
	if ((r = mkstemp(tmpfile)) == -1) {
		logit("mkstemp(%s): %s", tmpfile, strerror(errno));
d462 1
a462 1
	    && rename(tmpfile, cpfile) == 0)
@


1.23
log
@Add optional checkpoints for moduli screening.  feedback & ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.22 2010/11/10 01:33:07 djm Exp $ */
d40 1
d46 1
@


1.22
log
@use only libcrypto APIs that are retained with OPENSSL_NO_DEPRECATED.
these have been around for years by this time. ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.21 2008/06/26 09:19:40 djm Exp $ */
d50 1
d137 1
a137 1
int prime_test(FILE *, FILE *, u_int32_t, u_int32_t);
d438 46
d491 2
a492 1
prime_test(FILE *in, FILE *out, u_int32_t trials, u_int32_t generator_wanted)
d499 1
d520 3
d527 8
d702 3
@


1.21
log
@when loading moduli from /etc/moduli in sshd(8), check that they
are of the expected "safe prime" structure and have had
appropriate primality tests performed;
feedback and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.20 2007/02/24 03:30:11 ray Exp $ */
d601 1
a601 1
		if (BN_is_prime(q, 1, NULL, ctx, NULL) <= 0) {
d614 1
a614 1
		if (!BN_is_prime(p, trials, NULL, ctx, NULL)) {
d621 1
a621 1
		if (!BN_is_prime(q, trials - 1, NULL, ctx, NULL)) {
@


1.20
log
@- strlen returns size_t, not int.
- Pass full buffer size to fgets.

OK djm@@, millert@@, and moritz@@.
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.19 2006/11/06 21:25:28 markus Exp $ */
d43 1
d52 1
a61 21
/* Type: decimal.
 * Specifies the internal structure of the prime modulus.
 */
#define QTYPE_UNKNOWN		(0)
#define QTYPE_UNSTRUCTURED	(1)
#define QTYPE_SAFE		(2)
#define QTYPE_SCHNORR		(3)
#define QTYPE_SOPHIE_GERMAIN	(4)
#define QTYPE_STRONG		(5)

/* Tests: decimal (bit field).
 * Specifies the methods used in checking for primality.
 * Usually, more than one test is used.
 */
#define QTEST_UNTESTED		(0x00)
#define QTEST_COMPOSITE		(0x01)
#define QTEST_SIEVE		(0x02)
#define QTEST_MILLER_RABIN	(0x04)
#define QTEST_JACOBI		(0x08)
#define QTEST_ELLIPTIC		(0x10)

d416 3
a418 2
		if (qfileout(out, QTYPE_SOPHIE_GERMAIN, QTEST_SIEVE,
		    largetries, (power - 1) /* MSB */, (0), q) == -1) {
d490 1
a490 1
		if (in_tests & QTEST_COMPOSITE) {
d509 1
a509 1
		case QTYPE_SOPHIE_GERMAIN:
d522 5
a526 5
		case QTYPE_UNSTRUCTURED:
		case QTYPE_SAFE:
		case QTYPE_SCHNORR:
		case QTYPE_STRONG:
		case QTYPE_UNKNOWN:
d553 1
a553 1
		if (in_tests & QTEST_MILLER_RABIN)
d627 2
a628 1
		if (qfileout(out, QTYPE_SAFE, (in_tests | QTEST_MILLER_RABIN),
@


1.19
log
@add missing checks for openssl return codes; with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.18 2006/08/03 03:34:42 deraadt Exp $ */
d491 1
a491 3
	while (fgets(lp, QLINESIZE, in) != NULL) {
		int ll = strlen(lp);

d493 1
a493 1
		if (ll < 14 || *lp == '!' || *lp == '#') {
@


1.18
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.17 2006/08/01 23:22:47 stevesk Exp $ */
d328 2
a329 1
	q = BN_new();
d335 9
a343 5
	largebase = BN_new();
	if (start == NULL)
		BN_rand(largebase, power, 1, 1);
	else
		BN_copy(largebase, start);
d346 2
a347 1
	BN_set_bit(largebase, 0);
d431 4
a434 2
		BN_set_word(q, 2 * j);
		BN_add(q, q, largebase);
d479 6
a484 3
	p = BN_new();
	q = BN_new();
	ctx = BN_CTX_new();
d532 2
a533 1
			BN_hex2bn(&a, cp);
d535 4
a538 2
			BN_lshift(p, q, 1);
			BN_add_word(p, 1);
d549 2
a550 1
			BN_hex2bn(&a, cp);
d552 2
a553 1
			BN_rshift(q, p, 1);
@


1.18.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.19 2006/11/06 21:25:28 markus Exp $ */
d328 1
a328 2
	if ((q = BN_new()) == NULL)
		fatal("BN_new failed");
d334 5
a338 9
	if ((largebase = BN_new()) == NULL)
		fatal("BN_new failed");
	if (start == NULL) {
		if (BN_rand(largebase, power, 1, 1) == 0)
			fatal("BN_rand failed");
	} else {
		if (BN_copy(largebase, start) == NULL)
			fatal("BN_copy: failed");
	}
d341 1
a341 2
	if (BN_set_bit(largebase, 0) == 0)
		fatal("BN_set_bit: failed");
d425 2
a426 4
		if (BN_set_word(q, 2 * j) == 0)
			fatal("BN_set_word failed");
		if (BN_add(q, q, largebase) == 0)
			fatal("BN_add failed");
d471 3
a473 6
	if ((p = BN_new()) == NULL)
		fatal("BN_new failed");
	if ((q = BN_new()) == NULL)
		fatal("BN_new failed");
	if ((ctx = BN_CTX_new()) == NULL)
		fatal("BN_CTX_new failed");
d521 1
a521 2
			if (BN_hex2bn(&a, cp) == 0)
				fatal("BN_hex2bn failed");
d523 2
a524 4
			if (BN_lshift(p, q, 1) == 0)
				fatal("BN_lshift failed");
			if (BN_add_word(p, 1) == 0)
				fatal("BN_add_word failed");
d535 1
a535 2
			if (BN_hex2bn(&a, cp) == 0)
				fatal("BN_hex2bn failed");
d537 1
a537 2
			if (BN_rshift(q, p, 1) == 0)
				fatal("BN_rshift failed");
@


1.17
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.16 2006/07/26 13:57:17 stevesk Exp $ */
a39 2
#include "includes.h"

d47 1
@


1.16
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.15 2006/07/22 20:48:23 stevesk Exp $ */
d46 1
@


1.15
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.14 2006/07/22 19:08:54 stevesk Exp $ */
d46 1
@


1.14
log
@move #include <time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.13 2006/03/25 00:05:41 djm Exp $ */
d46 1
@


1.13
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.12 2005/07/17 07:17:55 djm Exp $ */
d41 7
a49 2

#include <openssl/bn.h>
@


1.12
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.11 2005/05/23 22:44:01 avsm Exp $ */
d304 1
a304 6
	TinySieve = calloc(tinywords, sizeof(u_int32_t));
	if (TinySieve == NULL) {
		error("Insufficient memory for tiny sieve: need %u bytes",
		    tinywords << SHIFT_BYTE);
		exit(1);
	}
d307 1
a307 7
	SmallSieve = calloc(smallwords, sizeof(u_int32_t));
	if (SmallSieve == NULL) {
		error("Insufficient memory for small sieve: need %u bytes",
		    smallwords << SHIFT_BYTE);
		xfree(TinySieve);
		exit(1);
	}
@


1.12.2.1
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.18 2006/08/03 03:34:42 deraadt Exp $ */
d40 3
a42 1
#include <sys/types.h>
a45 9
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <time.h>

#include "xmalloc.h"
#include "log.h"

d304 6
a309 1
	TinySieve = xcalloc(tinywords, sizeof(u_int32_t));
d312 7
a318 1
	SmallSieve = xcalloc(smallwords, sizeof(u_int32_t));
@


1.12.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.19 2006/11/06 21:25:28 markus Exp $ */
d328 1
a328 2
	if ((q = BN_new()) == NULL)
		fatal("BN_new failed");
d334 5
a338 9
	if ((largebase = BN_new()) == NULL)
		fatal("BN_new failed");
	if (start == NULL) {
		if (BN_rand(largebase, power, 1, 1) == 0)
			fatal("BN_rand failed");
	} else {
		if (BN_copy(largebase, start) == NULL)
			fatal("BN_copy: failed");
	}
d341 1
a341 2
	if (BN_set_bit(largebase, 0) == 0)
		fatal("BN_set_bit: failed");
d425 2
a426 4
		if (BN_set_word(q, 2 * j) == 0)
			fatal("BN_set_word failed");
		if (BN_add(q, q, largebase) == 0)
			fatal("BN_add failed");
d471 3
a473 6
	if ((p = BN_new()) == NULL)
		fatal("BN_new failed");
	if ((q = BN_new()) == NULL)
		fatal("BN_new failed");
	if ((ctx = BN_CTX_new()) == NULL)
		fatal("BN_CTX_new failed");
d521 1
a521 2
			if (BN_hex2bn(&a, cp) == 0)
				fatal("BN_hex2bn failed");
d523 2
a524 4
			if (BN_lshift(p, q, 1) == 0)
				fatal("BN_lshift failed");
			if (BN_add_word(p, 1) == 0)
				fatal("BN_add_word failed");
d535 1
a535 2
			if (BN_hex2bn(&a, cp) == 0)
				fatal("BN_hex2bn failed");
d537 1
a537 2
			if (BN_rshift(q, p, 1) == 0)
				fatal("BN_rshift failed");
@


1.12.4.1
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.18 2006/08/03 03:34:42 deraadt Exp $ */
d40 3
a42 1
#include <sys/types.h>
a45 9
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <time.h>

#include "xmalloc.h"
#include "log.h"

d304 6
a309 1
	TinySieve = xcalloc(tinywords, sizeof(u_int32_t));
d312 7
a318 1
	SmallSieve = xcalloc(smallwords, sizeof(u_int32_t));
@


1.12.4.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.19 2006/11/06 21:25:28 markus Exp $ */
d328 1
a328 2
	if ((q = BN_new()) == NULL)
		fatal("BN_new failed");
d334 5
a338 9
	if ((largebase = BN_new()) == NULL)
		fatal("BN_new failed");
	if (start == NULL) {
		if (BN_rand(largebase, power, 1, 1) == 0)
			fatal("BN_rand failed");
	} else {
		if (BN_copy(largebase, start) == NULL)
			fatal("BN_copy: failed");
	}
d341 1
a341 2
	if (BN_set_bit(largebase, 0) == 0)
		fatal("BN_set_bit: failed");
d425 2
a426 4
		if (BN_set_word(q, 2 * j) == 0)
			fatal("BN_set_word failed");
		if (BN_add(q, q, largebase) == 0)
			fatal("BN_add failed");
d471 3
a473 6
	if ((p = BN_new()) == NULL)
		fatal("BN_new failed");
	if ((q = BN_new()) == NULL)
		fatal("BN_new failed");
	if ((ctx = BN_CTX_new()) == NULL)
		fatal("BN_CTX_new failed");
d521 1
a521 2
			if (BN_hex2bn(&a, cp) == 0)
				fatal("BN_hex2bn failed");
d523 2
a524 4
			if (BN_lshift(p, q, 1) == 0)
				fatal("BN_lshift failed");
			if (BN_add_word(p, 1) == 0)
				fatal("BN_add_word failed");
d535 1
a535 2
			if (BN_hex2bn(&a, cp) == 0)
				fatal("BN_hex2bn failed");
d537 1
a537 2
			if (BN_rshift(q, p, 1) == 0)
				fatal("BN_rshift failed");
@


1.11
log
@- removes signed/unsigned comparisons in moduli generation
- use strtonum instead of atoi where its easier
- check some strlcpy overflow and fatal instead of truncate
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.10 2005/01/17 03:25:46 dtucker Exp $ */
d115 4
a118 4
#define TEST_MAXIMUM    (1UL<<16)
#define TEST_MINIMUM    (QSIZE_MINIMUM + 1)
/* real TEST_MINIMUM    (1UL << (SHIFT_WORD - TEST_POWER)) */
#define TEST_POWER      (3)	/* 2**n, n < SHIFT_WORD */
d121 3
a123 3
#define BIT_CLEAR(a,n)  ((a)[(n)>>SHIFT_WORD] &= ~(1L << ((n) & 31)))
#define BIT_SET(a,n)    ((a)[(n)>>SHIFT_WORD] |= (1L << ((n) & 31)))
#define BIT_TEST(a,n)   ((a)[(n)>>SHIFT_WORD] & (1L << ((n) & 31)))
d130 1
a130 1
#define TRIAL_MINIMUM           (4)
d257 1
a257 1
	   (memory < LARGE_MINIMUM || memory > LARGE_MAXIMUM)) {
d375 2
a376 2
	     smallbase < (SMALL_MAXIMUM - TINY_NUMBER);
	     smallbase += TINY_NUMBER) {
@


1.10
log
@Correct spelling: SCHNOOR->SCHNORR; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.9 2004/07/11 17:48:47 deraadt Exp $ */
d147 1
a147 1
int gen_candidates(FILE *, int, int, BIGNUM *);
d244 1
a244 1
gen_candidates(FILE *out, int memory, int power, BIGNUM *start)
d251 2
a252 1
	int i, ret = 0;
d552 1
a552 1
		if (BN_num_bits(p) != (in_size + 1)) {
@


1.10.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.12 2005/07/17 07:17:55 djm Exp $ */
d115 4
a118 4
#define TEST_MAXIMUM	(1UL<<16)
#define TEST_MINIMUM	(QSIZE_MINIMUM + 1)
/* real TEST_MINIMUM	(1UL << (SHIFT_WORD - TEST_POWER)) */
#define TEST_POWER	(3)	/* 2**n, n < SHIFT_WORD */
d121 3
a123 3
#define BIT_CLEAR(a,n)	((a)[(n)>>SHIFT_WORD] &= ~(1L << ((n) & 31)))
#define BIT_SET(a,n)	((a)[(n)>>SHIFT_WORD] |= (1L << ((n) & 31)))
#define BIT_TEST(a,n)	((a)[(n)>>SHIFT_WORD] & (1L << ((n) & 31)))
d130 1
a130 1
#define TRIAL_MINIMUM	(4)
d147 1
a147 1
int gen_candidates(FILE *, u_int32_t, u_int32_t, BIGNUM *);
d244 1
a244 1
gen_candidates(FILE *out, u_int32_t memory, u_int32_t power, BIGNUM *start)
d251 1
a251 2
	u_int32_t i;
	int ret = 0;
d256 1
a256 1
	    (memory < LARGE_MINIMUM || memory > LARGE_MAXIMUM)) {
d374 2
a375 2
	    smallbase < (SMALL_MAXIMUM - TINY_NUMBER);
	    smallbase += TINY_NUMBER) {
d551 1
a551 1
		if ((u_int32_t)BN_num_bits(p) != (in_size + 1)) {
@


1.9
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.8 2004/05/21 08:43:03 markus Exp $ */
d59 1
a59 1
#define QTYPE_SCHNOOR		(3)
d533 1
a533 1
		case QTYPE_SCHNOOR:
@


1.9.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.10 2005/01/17 03:25:46 dtucker Exp $ */
d59 1
a59 1
#define QTYPE_SCHNORR		(3)
d533 1
a533 1
		case QTYPE_SCHNORR:
@


1.9.2.2
log
@upgrade to OpenSSH 4.2
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.12 2005/07/17 07:17:55 djm Exp $ */
d115 4
a118 4
#define TEST_MAXIMUM	(1UL<<16)
#define TEST_MINIMUM	(QSIZE_MINIMUM + 1)
/* real TEST_MINIMUM	(1UL << (SHIFT_WORD - TEST_POWER)) */
#define TEST_POWER	(3)	/* 2**n, n < SHIFT_WORD */
d121 3
a123 3
#define BIT_CLEAR(a,n)	((a)[(n)>>SHIFT_WORD] &= ~(1L << ((n) & 31)))
#define BIT_SET(a,n)	((a)[(n)>>SHIFT_WORD] |= (1L << ((n) & 31)))
#define BIT_TEST(a,n)	((a)[(n)>>SHIFT_WORD] & (1L << ((n) & 31)))
d130 1
a130 1
#define TRIAL_MINIMUM	(4)
d147 1
a147 1
int gen_candidates(FILE *, u_int32_t, u_int32_t, BIGNUM *);
d244 1
a244 1
gen_candidates(FILE *out, u_int32_t memory, u_int32_t power, BIGNUM *start)
d251 1
a251 2
	u_int32_t i;
	int ret = 0;
d256 1
a256 1
	    (memory < LARGE_MINIMUM || memory > LARGE_MAXIMUM)) {
d374 2
a375 2
	    smallbase < (SMALL_MAXIMUM - TINY_NUMBER);
	    smallbase += TINY_NUMBER) {
d551 1
a551 1
		if ((u_int32_t)BN_num_bits(p) != (in_size + 1)) {
@


1.8
log
@add prototypes for -Wall; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.7 2004/05/09 00:06:47 djm Exp $ */
d51 1
a51 1
#define QLINESIZE               (100+8192)
d56 6
a61 6
#define QTYPE_UNKNOWN           (0)
#define QTYPE_UNSTRUCTURED      (1)
#define QTYPE_SAFE              (2)
#define QTYPE_SCHNOOR           (3)
#define QTYPE_SOPHIE_GERMAIN    (4)
#define QTYPE_STRONG            (5)
d67 6
a72 6
#define QTEST_UNTESTED          (0x00)
#define QTEST_COMPOSITE         (0x01)
#define QTEST_SIEVE             (0x02)
#define QTEST_MILLER_RABIN      (0x04)
#define QTEST_JACOBI            (0x08)
#define QTEST_ELLIPTIC          (0x10)
d79 1
a79 1
#define QSIZE_MINIMUM           (511)
d86 5
a90 5
#define SHIFT_BIT       (3)
#define SHIFT_BYTE      (2)
#define SHIFT_WORD      (SHIFT_BIT+SHIFT_BYTE)
#define SHIFT_MEGABYTE  (20)
#define SHIFT_MEGAWORD  (SHIFT_MEGABYTE-SHIFT_BYTE)
d97 1
a97 1
#define LARGE_MINIMUM   (8UL)	/* megabytes */
d103 1
a103 1
#define LARGE_MAXIMUM   (127UL)	/* megabytes */
d109 1
a109 1
#define SMALL_MAXIMUM   (0xffffffffUL)
d112 1
a112 1
#define TINY_NUMBER     (1UL<<16)
@


1.7
log
@zap another tiny header; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.6 2004/04/22 11:56:57 djm Exp $ */
d147 2
@


1.6
log
@Bugzilla #850: Sophie Germain is the correct name of the French mathematician,
"Sophie Germaine" isn't; from Luc.Maisonobe@@c-s.fr
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.5 2003/12/22 09:16:57 djm Exp $ */
a40 1
#include "moduli.h"
d93 13
d129 3
d253 7
d455 1
a455 2
prime_test(FILE *in, FILE *out, u_int32_t trials,
    u_int32_t generator_wanted)
d464 5
@


1.5
log
@tidy up moduli generation debugging, add -v (verbose/debug) option to
ssh-keygen; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.4 2003/12/09 13:52:55 dtucker Exp $ */
d61 1
a61 1
#define QTYPE_SOPHIE_GERMAINE   (4)
d222 1
a222 1
 * list candidates for Sophie-Germaine primes (where q = (p-1)/2)
d406 1
a406 1
		if (qfileout(out, QTYPE_SOPHIE_GERMAINE, QTEST_SIEVE,
d493 2
a494 2
		case QTYPE_SOPHIE_GERMAINE:
			debug2("%10u: (%u) Sophie-Germaine", count_in, in_type);
@


1.5.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.9 2004/07/11 17:48:47 deraadt Exp $ */
d41 1
d52 1
a52 1
#define QLINESIZE		(100+8192)
d57 6
a62 6
#define QTYPE_UNKNOWN		(0)
#define QTYPE_UNSTRUCTURED	(1)
#define QTYPE_SAFE		(2)
#define QTYPE_SCHNOOR		(3)
#define QTYPE_SOPHIE_GERMAIN	(4)
#define QTYPE_STRONG		(5)
d68 6
a73 6
#define QTEST_UNTESTED		(0x00)
#define QTEST_COMPOSITE		(0x01)
#define QTEST_SIEVE		(0x02)
#define QTEST_MILLER_RABIN	(0x04)
#define QTEST_JACOBI		(0x08)
#define QTEST_ELLIPTIC		(0x10)
d80 1
a80 1
#define QSIZE_MINIMUM		(511)
d87 5
a91 18
#define SHIFT_BIT	(3)
#define SHIFT_BYTE	(2)
#define SHIFT_WORD	(SHIFT_BIT+SHIFT_BYTE)
#define SHIFT_MEGABYTE	(20)
#define SHIFT_MEGAWORD	(SHIFT_MEGABYTE-SHIFT_BYTE)

/*
 * Using virtual memory can cause thrashing.  This should be the largest
 * number that is supported without a large amount of disk activity --
 * that would increase the run time from hours to days or weeks!
 */
#define LARGE_MINIMUM	(8UL)	/* megabytes */

/*
 * Do not increase this number beyond the unsigned integer bit size.
 * Due to a multiple of 4, it must be LESS than 128 (yielding 2**30 bits).
 */
#define LARGE_MAXIMUM	(127UL)	/* megabytes */
d97 1
a97 1
#define SMALL_MAXIMUM	(0xffffffffUL)
d100 1
a100 1
#define TINY_NUMBER	(1UL<<16)
a116 3
/* Minimum number of primality tests to perform */
#define TRIAL_MINIMUM           (4)

a131 2
int gen_candidates(FILE *, int, int, BIGNUM *);
int prime_test(FILE *, FILE *, u_int32_t, u_int32_t);
d222 1
a222 1
 * list candidates for Sophie-Germain primes (where q = (p-1)/2)
a237 7
	if (memory != 0 &&
	   (memory < LARGE_MINIMUM || memory > LARGE_MAXIMUM)) {
		error("Invalid memory amount (min %ld, max %ld)",
		    LARGE_MINIMUM, LARGE_MAXIMUM);
		return (-1);
	}

d406 1
a406 1
		if (qfileout(out, QTYPE_SOPHIE_GERMAIN, QTEST_SIEVE,
d433 2
a434 1
prime_test(FILE *in, FILE *out, u_int32_t trials, u_int32_t generator_wanted)
a443 5
	if (trials < TRIAL_MINIMUM) {
		error("Minimum primality trials is %d", TRIAL_MINIMUM);
		return (-1);
	}

d493 2
a494 2
		case QTYPE_SOPHIE_GERMAIN:
			debug2("%10u: (%u) Sophie-Germain", count_in, in_type);
@


1.5.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.10 2005/01/17 03:25:46 dtucker Exp $ */
d59 1
a59 1
#define QTYPE_SCHNORR		(3)
d533 1
a533 1
		case QTYPE_SCHNORR:
@


1.4
log
@Prevent ssh-keygen -T from outputting moduli with a generator of 0, since
they can't be used for Diffie-Hellman.  Assistance and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.3 2003/12/07 06:34:18 djm Exp $ */
d75 2
a76 1
/* Size: decimal.
d78 1
a78 1
 ** WARNING: internally, usually 1 to N.
d173 1
a173 1
	debug2("sieve_large %u", s);
d478 1
d503 5
a507 1
		default:
d514 3
d536 1
d548 1
a548 1
				if (r == 3 || r == 7) {
a549 1
				}
d581 1
a581 1
			debug2("%10u: q failed first possible prime test",
d594 1
a594 1
			debug2("%10u: p is not prime", count_in);
@


1.3
log
@remove unused debugging #define templates
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.2 2003/11/21 11:57:03 djm Exp $ */
d550 9
@


1.2
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.1 2003/07/28 09:49:56 djm Exp $ */
a45 9


/*
 * Debugging defines
 */

/* define DEBUG_LARGE 1 */
/* define DEBUG_SMALL 1 */
/* define DEBUG_TEST  1 */
@


1.1
log
@Support for generating Diffie-Hellman groups (/etc/moduli) from ssh-keygen.
Based on code from Phil Karn, William Allen Simpson and Niels Provos.
ok markus@@, thanks jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d49 1
a49 1
 * Debugging defines 
d154 1
a154 1
	
d247 3
a249 3
         * Set power to the length in bits of the prime to be generated.
         * This is changed to 1 less than the desired safe prime moduli p.
         */
d260 4
a263 4
         * The density of ordinary primes is on the order of 1/bits, so the
         * density of safe primes should be about (1/bits)**2. Set test range
         * to something well above bits**2 to be reasonably sure (but not
         * guaranteed) of catching at least one safe prime.
d268 2
a269 2
         * Need idea of how much memory is available. We don't have to use all
         * of it.
d318 2
a319 2
         * Generate random starting point for subprime search, or use
         * specified parameter.
d332 1
a332 1
	logit("%.24s Sieve next %u plus %u-bit", ctime(&time_start), 
d337 2
a338 2
         * TinySieve
         */
d354 3
a356 3
         * Start the small block search at the next possible prime. To avoid
         * fencepost errors, the last pass is skipped.
         */
d389 2
a390 2
                 * SmallSieve
                 */
d441 1
a441 1
prime_test(FILE *in, FILE *out, u_int32_t trials, 
d565 4
a568 4
		 * The (1/4)^N performance bound on Miller-Rabin is 
		 * extremely pessimistic, so don't spend a lot of time 
		 * really verifying that q is prime until after we know 
		 * that p is also prime. A single pass will weed out the 
d576 1
a576 1
	
d578 3
a580 3
		 * q is possibly prime, so go ahead and really make sure 
		 * that p is prime. If it is, then we can go back and do 
		 * the same for q. If p is composite, chances are that 
d597 1
a597 1
		if (qfileout(out, QTYPE_SAFE, (in_tests | QTEST_MILLER_RABIN), 
d613 1
a613 1
	    ctime(&time_stop), count_out, count_possible, 
@


1.1.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.5 2003/12/22 09:16:57 djm Exp $ */
d47 9
d84 1
a84 2
/*
 * Size: decimal.
d86 1
a86 1
 * WARNING: internally, usually 1 to N.
d154 1
a154 1

d181 1
a181 1
	debug3("sieve_large %u", s);
d247 3
a249 3
	 * Set power to the length in bits of the prime to be generated.
	 * This is changed to 1 less than the desired safe prime moduli p.
	 */
d260 4
a263 4
	 * The density of ordinary primes is on the order of 1/bits, so the
	 * density of safe primes should be about (1/bits)**2. Set test range
	 * to something well above bits**2 to be reasonably sure (but not
	 * guaranteed) of catching at least one safe prime.
d268 2
a269 2
	 * Need idea of how much memory is available. We don't have to use all
	 * of it.
d318 2
a319 2
	 * Generate random starting point for subprime search, or use
	 * specified parameter.
d332 1
a332 1
	logit("%.24s Sieve next %u plus %u-bit", ctime(&time_start),
d337 2
a338 2
	 * TinySieve
	 */
d354 3
a356 3
	 * Start the small block search at the next possible prime. To avoid
	 * fencepost errors, the last pass is skipped.
	 */
d389 2
a390 2
		 * SmallSieve
		 */
d441 1
a441 1
prime_test(FILE *in, FILE *out, u_int32_t trials,
a485 1

d510 1
a510 5
		case QTYPE_UNSTRUCTURED:
		case QTYPE_SAFE:
		case QTYPE_SCHNOOR:
		case QTYPE_STRONG:
		case QTYPE_UNKNOWN:
a516 3
		default:
			debug2("Unknown prime type");
			break;
a535 1

d547 1
a547 1
				if (r == 3 || r == 7)
d549 1
a561 9
		/*
		 * Primes with no known generator are useless for DH, so
		 * skip those.
		 */
		if (generator_known == 0) {
			debug2("%10u: no known generator", count_in);
			continue;
		}

d565 4
a568 4
		 * The (1/4)^N performance bound on Miller-Rabin is
		 * extremely pessimistic, so don't spend a lot of time
		 * really verifying that q is prime until after we know
		 * that p is also prime. A single pass will weed out the
d572 1
a572 1
			debug("%10u: q failed first possible prime test",
d576 1
a576 1

d578 3
a580 3
		 * q is possibly prime, so go ahead and really make sure
		 * that p is prime. If it is, then we can go back and do
		 * the same for q. If p is composite, chances are that
d585 1
a585 1
			debug("%10u: p is not prime", count_in);
d597 1
a597 1
		if (qfileout(out, QTYPE_SAFE, (in_tests | QTEST_MILLER_RABIN),
d613 1
a613 1
	    ctime(&time_stop), count_out, count_possible,
@


1.1.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.9 2004/07/11 17:48:47 deraadt Exp $ */
d41 1
d52 1
a52 1
#define QLINESIZE		(100+8192)
d57 6
a62 6
#define QTYPE_UNKNOWN		(0)
#define QTYPE_UNSTRUCTURED	(1)
#define QTYPE_SAFE		(2)
#define QTYPE_SCHNOOR		(3)
#define QTYPE_SOPHIE_GERMAIN	(4)
#define QTYPE_STRONG		(5)
d68 6
a73 6
#define QTEST_UNTESTED		(0x00)
#define QTEST_COMPOSITE		(0x01)
#define QTEST_SIEVE		(0x02)
#define QTEST_MILLER_RABIN	(0x04)
#define QTEST_JACOBI		(0x08)
#define QTEST_ELLIPTIC		(0x10)
d80 1
a80 1
#define QSIZE_MINIMUM		(511)
d87 5
a91 18
#define SHIFT_BIT	(3)
#define SHIFT_BYTE	(2)
#define SHIFT_WORD	(SHIFT_BIT+SHIFT_BYTE)
#define SHIFT_MEGABYTE	(20)
#define SHIFT_MEGAWORD	(SHIFT_MEGABYTE-SHIFT_BYTE)

/*
 * Using virtual memory can cause thrashing.  This should be the largest
 * number that is supported without a large amount of disk activity --
 * that would increase the run time from hours to days or weeks!
 */
#define LARGE_MINIMUM	(8UL)	/* megabytes */

/*
 * Do not increase this number beyond the unsigned integer bit size.
 * Due to a multiple of 4, it must be LESS than 128 (yielding 2**30 bits).
 */
#define LARGE_MAXIMUM	(127UL)	/* megabytes */
d97 1
a97 1
#define SMALL_MAXIMUM	(0xffffffffUL)
d100 1
a100 1
#define TINY_NUMBER	(1UL<<16)
a116 3
/* Minimum number of primality tests to perform */
#define TRIAL_MINIMUM           (4)

a131 2
int gen_candidates(FILE *, int, int, BIGNUM *);
int prime_test(FILE *, FILE *, u_int32_t, u_int32_t);
d222 1
a222 1
 * list candidates for Sophie-Germain primes (where q = (p-1)/2)
a237 7
	if (memory != 0 &&
	   (memory < LARGE_MINIMUM || memory > LARGE_MAXIMUM)) {
		error("Invalid memory amount (min %ld, max %ld)",
		    LARGE_MINIMUM, LARGE_MAXIMUM);
		return (-1);
	}

d406 1
a406 1
		if (qfileout(out, QTYPE_SOPHIE_GERMAIN, QTEST_SIEVE,
d433 2
a434 1
prime_test(FILE *in, FILE *out, u_int32_t trials, u_int32_t generator_wanted)
a443 5
	if (trials < TRIAL_MINIMUM) {
		error("Minimum primality trials is %d", TRIAL_MINIMUM);
		return (-1);
	}

d493 2
a494 2
		case QTYPE_SOPHIE_GERMAIN:
			debug2("%10u: (%u) Sophie-Germain", count_in, in_type);
@


1.1.6.1
log
@upgrade to OpenSSH 3.7
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.1 2003/07/28 09:49:56 djm Exp $ */
@


1.1.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.1 2003/07/28 09:49:56 djm Exp $ */
@


1.1.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d1 1
a1 1
/* $OpenBSD: moduli.c,v 1.5 2003/12/22 09:16:57 djm Exp $ */
d47 9
d84 1
a84 2
/*
 * Size: decimal.
d86 1
a86 1
 * WARNING: internally, usually 1 to N.
d154 1
a154 1

d181 1
a181 1
	debug3("sieve_large %u", s);
d247 3
a249 3
	 * Set power to the length in bits of the prime to be generated.
	 * This is changed to 1 less than the desired safe prime moduli p.
	 */
d260 4
a263 4
	 * The density of ordinary primes is on the order of 1/bits, so the
	 * density of safe primes should be about (1/bits)**2. Set test range
	 * to something well above bits**2 to be reasonably sure (but not
	 * guaranteed) of catching at least one safe prime.
d268 2
a269 2
	 * Need idea of how much memory is available. We don't have to use all
	 * of it.
d318 2
a319 2
	 * Generate random starting point for subprime search, or use
	 * specified parameter.
d332 1
a332 1
	logit("%.24s Sieve next %u plus %u-bit", ctime(&time_start),
d337 2
a338 2
	 * TinySieve
	 */
d354 3
a356 3
	 * Start the small block search at the next possible prime. To avoid
	 * fencepost errors, the last pass is skipped.
	 */
d389 2
a390 2
		 * SmallSieve
		 */
d441 1
a441 1
prime_test(FILE *in, FILE *out, u_int32_t trials,
a485 1

d510 1
a510 5
		case QTYPE_UNSTRUCTURED:
		case QTYPE_SAFE:
		case QTYPE_SCHNOOR:
		case QTYPE_STRONG:
		case QTYPE_UNKNOWN:
a516 3
		default:
			debug2("Unknown prime type");
			break;
a535 1

d547 1
a547 1
				if (r == 3 || r == 7)
d549 1
a561 9
		/*
		 * Primes with no known generator are useless for DH, so
		 * skip those.
		 */
		if (generator_known == 0) {
			debug2("%10u: no known generator", count_in);
			continue;
		}

d565 4
a568 4
		 * The (1/4)^N performance bound on Miller-Rabin is
		 * extremely pessimistic, so don't spend a lot of time
		 * really verifying that q is prime until after we know
		 * that p is also prime. A single pass will weed out the
d572 1
a572 1
			debug("%10u: q failed first possible prime test",
d576 1
a576 1

d578 3
a580 3
		 * q is possibly prime, so go ahead and really make sure
		 * that p is prime. If it is, then we can go back and do
		 * the same for q. If p is composite, chances are that
d585 1
a585 1
			debug("%10u: p is not prime", count_in);
d597 1
a597 1
		if (qfileout(out, QTYPE_SAFE, (in_tests | QTEST_MILLER_RABIN),
d613 1
a613 1
	    ctime(&time_stop), count_out, count_possible,
@


