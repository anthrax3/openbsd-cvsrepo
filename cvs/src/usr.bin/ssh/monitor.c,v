head	1.170;
access;
symbols
	OPENBSD_6_1:1.167.0.4
	OPENBSD_6_1_BASE:1.167
	OPENBSD_6_0:1.161.0.4
	OPENBSD_6_0_BASE:1.161
	OPENBSD_5_9:1.157.0.2
	OPENBSD_5_9_BASE:1.157
	OPENBSD_5_8:1.150.0.2
	OPENBSD_5_8_BASE:1.150
	OPENBSD_5_7:1.145.0.2
	OPENBSD_5_7_BASE:1.145
	OPENBSD_5_6:1.135.0.4
	OPENBSD_5_6_BASE:1.135
	OPENBSD_5_5:1.131.0.4
	OPENBSD_5_5_BASE:1.131
	OPENBSD_5_4:1.127.0.2
	OPENBSD_5_4_BASE:1.127
	OPENBSD_5_3:1.120.0.2
	OPENBSD_5_3_BASE:1.120
	OPENBSD_5_2:1.117.0.2
	OPENBSD_5_2_BASE:1.117
	OPENBSD_5_1_BASE:1.116
	OPENBSD_5_1:1.116.0.2
	OPENBSD_5_0:1.115.0.2
	OPENBSD_5_0_BASE:1.115
	OPENBSD_4_9:1.110.0.2
	OPENBSD_4_9_BASE:1.110
	OPENBSD_4_8:1.108.0.2
	OPENBSD_4_8_BASE:1.108
	OPENBSD_4_7:1.106.0.2
	OPENBSD_4_7_BASE:1.106
	OPENBSD_4_6:1.104.0.4
	OPENBSD_4_6_BASE:1.104
	OPENBSD_4_5:1.101.0.2
	OPENBSD_4_5_BASE:1.101
	OPENBSD_4_4:1.99.0.2
	OPENBSD_4_4_BASE:1.99
	OPENBSD_4_3:1.94.0.2
	OPENBSD_4_3_BASE:1.94
	OPENBSD_4_2:1.91.0.2
	OPENBSD_4_2_BASE:1.91
	OPENBSD_4_1:1.90.0.2
	OPENBSD_4_1_BASE:1.90
	OPENBSD_4_0:1.88.0.4
	OPENBSD_4_0_BASE:1.88
	OPENBSD_3_9:1.68.0.2
	OPENBSD_3_9_BASE:1.68
	OPENBSD_3_8:1.63.0.4
	OPENBSD_3_8_BASE:1.63
	OPENBSD_3_7:1.63.0.2
	OPENBSD_3_7_BASE:1.63
	OPENBSD_3_6:1.61.0.2
	OPENBSD_3_6_BASE:1.61
	OPENBSD_3_5:1.55.0.2
	OPENBSD_3_5_BASE:1.55
	OPENBSD_3_4:1.49.0.2
	OPENBSD_3_4_BASE:1.49
	OPENBSD_3_3:1.34.0.2
	OPENBSD_3_3_BASE:1.34
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_2_9:1.11.0.4
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9;
locks; strict;
comment	@ * @;


1.170
date	2017.05.31.08.09.45;	author markus;	state Exp;
branches;
next	1.169;
commitid	U3YdddehbFcy84WY;

1.169
date	2017.05.30.14.10.53;	author markus;	state Exp;
branches;
next	1.168;
commitid	YtVAQPzV4sHWCSyk;

1.168
date	2017.05.30.08.52.19;	author markus;	state Exp;
branches;
next	1.167;
commitid	AQD3o1zTZEMIcuBx;

1.167
date	2017.02.03.23.05.57;	author djm;	state Exp;
branches;
next	1.166;
commitid	qKya5c8dDE67faev;

1.166
date	2016.09.28.16.33.06;	author djm;	state Exp;
branches;
next	1.165;
commitid	e2NJzal9PUi2o22D;

1.165
date	2016.09.05.13.57.31;	author djm;	state Exp;
branches;
next	1.164;
commitid	0GxeppKqnRURSXnb;

1.164
date	2016.08.30.07.50.21;	author djm;	state Exp;
branches;
next	1.163;
commitid	l2zMBtJYVYMHNhF5;

1.163
date	2016.08.19.03.18.06;	author djm;	state Exp;
branches;
next	1.162;
commitid	o9ZQ52UJzA8fd7BT;

1.162
date	2016.08.13.17.47.41;	author markus;	state Exp;
branches;
next	1.161;
commitid	dl4RDERdJITM8DKC;

1.161
date	2016.07.22.03.39.13;	author djm;	state Exp;
branches;
next	1.160;
commitid	7RjqAHm2BIxo6cSA;

1.160
date	2016.05.02.10.26.04;	author djm;	state Exp;
branches;
next	1.159;
commitid	rVUG0L3JBpFl5b0k;

1.159
date	2016.05.02.08.49.03;	author djm;	state Exp;
branches;
next	1.158;
commitid	RYYIr1bk0phq4fXa;

1.158
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.157;
commitid	kr9hjdmg99uVnhW2;

1.157
date	2016.02.15.23.32.37;	author djm;	state Exp;
branches;
next	1.156;
commitid	VP4kndeTjGCaMae3;

1.156
date	2016.01.14.16.17.39;	author markus;	state Exp;
branches;
next	1.155;
commitid	W9ye0gltieEl87AJ;

1.155
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.154;
commitid	K3glY441IowbrjDE;

1.154
date	2015.10.20.23.24.25;	author mmcc;	state Exp;
branches;
next	1.153;
commitid	KVrcISpunUJIXb7B;

1.153
date	2015.09.04.04.44.08;	author djm;	state Exp;
branches;
next	1.152;
commitid	fjkZernNsfIlBQUO;

1.152
date	2015.09.02.07.51.12;	author jsg;	state Exp;
branches;
next	1.151;
commitid	Q6Vkxj42ZGWgteg8;

1.151
date	2015.08.21.23.29.31;	author deraadt;	state Exp;
branches;
next	1.150;
commitid	x26OBpDitBEcRKWz;

1.150
date	2015.06.22.23.42.16;	author djm;	state Exp;
branches;
next	1.149;
commitid	IvNXC25bjjZPA9rB;

1.149
date	2015.05.04.06.10.48;	author djm;	state Exp;
branches;
next	1.148;
commitid	KfZDG8r2EByk0YBR;

1.148
date	2015.05.01.03.23.51;	author djm;	state Exp;
branches;
next	1.147;
commitid	weFq4BCuIOdeuIhV;

1.147
date	2015.04.27.01.52.30;	author djm;	state Exp;
branches;
next	1.146;
commitid	YUkhAUcfWvVRd3vD;

1.146
date	2015.04.17.04.32.31;	author djm;	state Exp;
branches;
next	1.145;
commitid	3WMnUccK6nE5zMqb;

1.145
date	2015.02.20.22.17.21;	author djm;	state Exp;
branches;
next	1.144;
commitid	9L88tCQWzQkTa0uX;

1.144
date	2015.02.16.22.13.32;	author djm;	state Exp;
branches;
next	1.143;
commitid	vWL0dluw4oITNbM8;

1.143
date	2015.02.13.18.57.00;	author markus;	state Exp;
branches;
next	1.142;
commitid	FXpQflsh1UdymeRb;

1.142
date	2015.02.06.23.21.59;	author millert;	state Exp;
branches;
next	1.141;
commitid	STdsVrA5MGLlnbLm;

1.141
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.140;
commitid	cBx23BaCk6gYBpRj;

1.140
date	2015.01.19.20.16.15;	author markus;	state Exp;
branches;
next	1.139;
commitid	U9l75XYAjMKaQ8Jp;

1.139
date	2015.01.19.19.52.16;	author markus;	state Exp;
branches;
next	1.138;
commitid	UHlhoIB5NMb8eAPm;

1.138
date	2015.01.14.20.05.27;	author djm;	state Exp;
branches;
next	1.137;
commitid	YqNUZu0ifI7Q95nk;

1.137
date	2015.01.13.07.39.19;	author djm;	state Exp;
branches;
next	1.136;
commitid	oriBpre3xTnTQZ4b;

1.136
date	2014.12.22.07.51.30;	author djm;	state Exp;
branches;
next	1.135;
commitid	CoaZC6mJ1akW0s9F;

1.135
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.134;
commitid	z7plx8Gkj6l2sxem;

1.134
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.133;
commitid	1h9UxAQmwdaqUzyX;

1.133
date	2014.05.03.17.20.34;	author markus;	state Exp;
branches;
next	1.132;

1.132
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.131;

1.131
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.130;

1.130
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.129;

1.129
date	2014.01.29.06.18.35;	author djm;	state Exp;
branches;
next	1.128;

1.128
date	2013.11.04.11.51.16;	author markus;	state Exp;
branches;
next	1.127;

1.127
date	2013.07.19.07.37.48;	author markus;	state Exp;
branches;
next	1.126;

1.126
date	2013.06.21.00.34.49;	author djm;	state Exp;
branches;
next	1.125;

1.125
date	2013.05.19.02.42.42;	author djm;	state Exp;
branches;
next	1.124;

1.124
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.123;

1.123
date	2013.05.16.04.09.13;	author dtucker;	state Exp;
branches;
next	1.122;

1.122
date	2013.03.07.19.27.25;	author markus;	state Exp;
branches;
next	1.121;

1.121
date	2013.03.07.00.19.59;	author djm;	state Exp;
branches;
next	1.120;

1.120
date	2012.12.11.22.16.21;	author markus;	state Exp;
branches;
next	1.119;

1.119
date	2012.12.02.20.34.10;	author djm;	state Exp;
branches;
next	1.118;

1.118
date	2012.11.04.11.09.15;	author djm;	state Exp;
branches;
next	1.117;

1.117
date	2012.06.22.12.30.26;	author dtucker;	state Exp;
branches;
next	1.116;

1.116
date	2012.01.05.00.16.56;	author djm;	state Exp;
branches;
next	1.115;

1.115
date	2011.06.23.23.35.42;	author djm;	state Exp;
branches;
next	1.114;

1.114
date	2011.06.17.21.44.30;	author djm;	state Exp;
branches;
next	1.113;

1.113
date	2011.05.23.03.30.07;	author djm;	state Exp;
branches;
next	1.112;

1.112
date	2011.05.20.03.25.45;	author djm;	state Exp;
branches;
next	1.111;

1.111
date	2011.05.15.08.09.01;	author djm;	state Exp;
branches;
next	1.110;

1.110
date	2010.09.09.10.45.45;	author djm;	state Exp;
branches;
next	1.109;

1.109
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.108;

1.108
date	2010.07.13.23.13.16;	author djm;	state Exp;
branches;
next	1.107;

1.107
date	2010.07.13.11.52.06;	author djm;	state Exp;
branches;
next	1.106;

1.106
date	2010.03.07.11.57.13;	author dtucker;	state Exp;
branches;
next	1.105;

1.105
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.104;

1.104
date	2009.06.12.20.43.22;	author andreas;	state Exp;
branches;
next	1.103;

1.103
date	2009.05.28.16.50.16;	author andreas;	state Exp;
branches;
next	1.102;

1.102
date	2009.05.25.06.48.01;	author andreas;	state Exp;
branches;
next	1.101;

1.101
date	2009.02.12.03.26.22;	author djm;	state Exp;
branches;
next	1.100;

1.100
date	2008.11.04.08.22.13;	author djm;	state Exp;
branches;
next	1.99;

1.99
date	2008.07.10.18.08.11;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2008.07.04.03.47.02;	author dtucker;	state Exp;
branches;
next	1.97;

1.97
date	2008.06.13.13.56.59;	author dtucker;	state Exp;
branches;
next	1.96;

1.96
date	2008.05.08.12.21.16;	author djm;	state Exp;
branches;
next	1.95;

1.95
date	2008.05.08.12.02.23;	author djm;	state Exp;
branches;
next	1.94;

1.94
date	2007.10.29.04.08.08;	author dtucker;	state Exp;
branches;
next	1.93;

1.93
date	2007.09.21.08.15.29;	author djm;	state Exp;
branches;
next	1.92;

1.92
date	2007.09.04.03.21.03;	author djm;	state Exp;
branches;
next	1.91;

1.91
date	2007.05.17.20.52.13;	author djm;	state Exp;
branches;
next	1.90;

1.90
date	2007.02.19.10.45.58;	author dtucker;	state Exp;
branches;
next	1.89;

1.89
date	2006.11.07.10.31.31;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2006.08.12.20.46.46;	author miod;	state Exp;
branches
	1.88.4.1;
next	1.87;

1.87
date	2006.08.06.01.13.32;	author stevesk;	state Exp;
branches;
next	1.86;

1.86
date	2006.08.04.20.46.05;	author stevesk;	state Exp;
branches;
next	1.85;

1.85
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.83;

1.83
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.82;

1.82
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.81;

1.81
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.80;

1.80
date	2006.07.09.15.15.10;	author stevesk;	state Exp;
branches;
next	1.79;

1.79
date	2006.07.08.21.48.53;	author stevesk;	state Exp;
branches;
next	1.78;

1.78
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.77;

1.77
date	2006.03.30.11.40.21;	author dtucker;	state Exp;
branches;
next	1.76;

1.76
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.75;

1.75
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.74;

1.74
date	2006.03.20.18.27.50;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2006.03.20.18.26.55;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2006.03.20.04.09.44;	author djm;	state Exp;
branches;
next	1.71;

1.71
date	2006.03.19.18.53.12;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2006.03.07.09.07.40;	author djm;	state Exp;
branches;
next	1.68;

1.68
date	2006.02.20.17.02.44;	author stevesk;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2006.02.10.01.44.26;	author stevesk;	state Exp;
branches;
next	1.66;

1.66
date	2006.02.08.13.15.44;	author stevesk;	state Exp;
branches;
next	1.65;

1.65
date	2006.02.08.12.15.27;	author stevesk;	state Exp;
branches;
next	1.64;

1.64
date	2005.10.13.22.24.31;	author stevesk;	state Exp;
branches;
next	1.63;

1.63
date	2005.03.10.22.01.05;	author deraadt;	state Exp;
branches
	1.63.2.1
	1.63.4.1;
next	1.62;

1.62
date	2005.01.30.11.18.08;	author dtucker;	state Exp;
branches;
next	1.61;

1.61
date	2004.07.17.05.31.41;	author dtucker;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2004.06.22.05.05.45;	author dtucker;	state Exp;
branches;
next	1.59;

1.59
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches;
next	1.58;

1.58
date	2004.06.13.12.53.24;	author djm;	state Exp;
branches;
next	1.57;

1.57
date	2004.05.11.19.01.43;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2004.05.09.01.19.27;	author djm;	state Exp;
branches;
next	1.55;

1.55
date	2004.02.05.05.37.17;	author dtucker;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches;
next	1.53;

1.53
date	2003.11.18.10.53.07;	author djm;	state Exp;
branches;
next	1.52;

1.52
date	2003.11.17.11.06.07;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2003.11.04.08.54.09;	author djm;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.23.20.17.11;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2003.08.28.12.54.34;	author markus;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2003.08.26.09.58.43;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2003.08.24.17.36.52;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2003.08.22.10.56.09;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2003.07.22.13.35.22;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.24.08.23.46;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.12.07.57.38;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.02.09.17.34;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2003.05.24.09.30.40;	author djm;	state Exp;
branches;
next	1.40;

1.40
date	2003.05.14.08.57.49;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2003.05.14.02.15.47;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2003.04.02.09.48.07;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2003.04.01.10.22.21;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2003.04.01.10.10.23;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2003.03.23.19.02.00;	author markus;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2003.03.05.22.33.43;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2003.02.16.17.30.33;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2003.02.04.09.33.22;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.05.19.45.20;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.26.11.38.43;	author markus;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2002.09.24.08.46.04;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2002.09.23.22.11.05;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2002.09.09.14.54.15;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.09.06.48.06;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.29.15.57.25;	author stevesk;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.02.14.43.15;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.22.17.32.56;	author stevesk;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.27.10.35.47;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.27.09.08.00;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.26.14.49.36;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.26.13.20.57;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.22.23.09.51;	author stevesk;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.21.05.50.51;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.19.18.01.00;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.04.23.05.49;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.04.19.53.40;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.04.19.42.35;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.15.15.47.49;	author mouring;	state Exp;
branches
	1.11.2.1
	1.11.4.1;
next	1.10;

1.10
date	2002.05.12.23.53.45;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.30.18.51.15;	author markus;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2002.03.27.17.45.42;	author mouring;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.24.23.20.00;	author stevesk;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.21.18.38.33;	author stevesk;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.19.21.12.48;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.19.14.27.39;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.19.10.41.32;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.19.10.35.39;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.03.18.17.28.37;	author provos;	state Exp;
branches;
next	;

1.9.2.1
date	2002.05.18.04.12.10;	author jason;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.05.18.04.50.38;	author jason;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.11.2.1
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2002.06.26.18.22.35;	author miod;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.29.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2003.04.03.23.27.12;	author margarida;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.34.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.49.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.55.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	1.55.2.2;

1.55.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.61.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	;

1.63.2.1
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.63.4.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.63.4.2;

1.63.4.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	1.63.4.3;

1.63.4.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.68.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	1.68.2.2;

1.68.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.88.4.1
date	2006.11.08.00.42.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.170
log
@clear session keys from memory; ok djm@@
@
text
@/* $OpenBSD: monitor.c,v 1.169 2017/05/30 14:10:53 markus Exp $ */
/*
 * Copyright 2002 Niels Provos <provos@@citi.umich.edu>
 * Copyright 2002 Markus Friedl <markus@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/tree.h>
#include <sys/queue.h>

#ifdef WITH_OPENSSL
#include <openssl/dh.h>
#endif

#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <paths.h>
#include <poll.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "atomicio.h"
#include "xmalloc.h"
#include "ssh.h"
#include "key.h"
#include "buffer.h"
#include "hostfile.h"
#include "auth.h"
#include "cipher.h"
#include "kex.h"
#include "dh.h"
#include <zlib.h>
#include "packet.h"
#include "auth-options.h"
#include "sshpty.h"
#include "channels.h"
#include "session.h"
#include "sshlogin.h"
#include "canohost.h"
#include "log.h"
#include "misc.h"
#include "servconf.h"
#include "monitor.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"
#include "monitor_fdpass.h"
#include "compat.h"
#include "ssh2.h"
#include "authfd.h"
#include "match.h"
#include "ssherr.h"

#ifdef GSSAPI
static Gssctxt *gsscontext = NULL;
#endif

/* Imports */
extern ServerOptions options;
extern u_int utmp_len;
extern u_char session_id[];
extern Buffer auth_debug;
extern int auth_debug_init;
extern Buffer loginmsg;

/* State exported from the child */
static struct sshbuf *child_state;

/* Functions on the monitor that answer unprivileged requests */

int mm_answer_moduli(int, Buffer *);
int mm_answer_sign(int, Buffer *);
int mm_answer_pwnamallow(int, Buffer *);
int mm_answer_auth2_read_banner(int, Buffer *);
int mm_answer_authserv(int, Buffer *);
int mm_answer_authpassword(int, Buffer *);
int mm_answer_bsdauthquery(int, Buffer *);
int mm_answer_bsdauthrespond(int, Buffer *);
int mm_answer_skeyquery(int, Buffer *);
int mm_answer_skeyrespond(int, Buffer *);
int mm_answer_keyallowed(int, Buffer *);
int mm_answer_keyverify(int, Buffer *);
int mm_answer_pty(int, Buffer *);
int mm_answer_pty_cleanup(int, Buffer *);
int mm_answer_term(int, Buffer *);
int mm_answer_rsa_keyallowed(int, Buffer *);
int mm_answer_rsa_challenge(int, Buffer *);
int mm_answer_rsa_response(int, Buffer *);
int mm_answer_sesskey(int, Buffer *);
int mm_answer_sessid(int, Buffer *);

#ifdef GSSAPI
int mm_answer_gss_setup_ctx(int, Buffer *);
int mm_answer_gss_accept_ctx(int, Buffer *);
int mm_answer_gss_userok(int, Buffer *);
int mm_answer_gss_checkmic(int, Buffer *);
#endif

static int monitor_read_log(struct monitor *);

static Authctxt *authctxt;

/* local state for key verify */
static u_char *key_blob = NULL;
static u_int key_bloblen = 0;
static int key_blobtype = MM_NOKEY;
static char *hostbased_cuser = NULL;
static char *hostbased_chost = NULL;
static char *auth_method = "unknown";
static char *auth_submethod = NULL;
static u_int session_id2_len = 0;
static u_char *session_id2 = NULL;
static pid_t monitor_child_pid;

struct mon_table {
	enum monitor_reqtype type;
	int flags;
	int (*f)(int, Buffer *);
};

#define MON_ISAUTH	0x0004	/* Required for Authentication */
#define MON_AUTHDECIDE	0x0008	/* Decides Authentication */
#define MON_ONCE	0x0010	/* Disable after calling */
#define MON_ALOG	0x0020	/* Log auth attempt without authenticating */

#define MON_AUTH	(MON_ISAUTH|MON_AUTHDECIDE)

#define MON_PERMIT	0x1000	/* Request is permitted */

struct mon_table mon_dispatch_proto20[] = {
#ifdef WITH_OPENSSL
    {MONITOR_REQ_MODULI, MON_ONCE, mm_answer_moduli},
#endif
    {MONITOR_REQ_SIGN, MON_ONCE, mm_answer_sign},
    {MONITOR_REQ_PWNAM, MON_ONCE, mm_answer_pwnamallow},
    {MONITOR_REQ_AUTHSERV, MON_ONCE, mm_answer_authserv},
    {MONITOR_REQ_AUTH2_READ_BANNER, MON_ONCE, mm_answer_auth2_read_banner},
    {MONITOR_REQ_AUTHPASSWORD, MON_AUTH, mm_answer_authpassword},
    {MONITOR_REQ_BSDAUTHQUERY, MON_ISAUTH, mm_answer_bsdauthquery},
    {MONITOR_REQ_BSDAUTHRESPOND, MON_AUTH, mm_answer_bsdauthrespond},
    {MONITOR_REQ_KEYALLOWED, MON_ISAUTH, mm_answer_keyallowed},
    {MONITOR_REQ_KEYVERIFY, MON_AUTH, mm_answer_keyverify},
#ifdef GSSAPI
    {MONITOR_REQ_GSSSETUP, MON_ISAUTH, mm_answer_gss_setup_ctx},
    {MONITOR_REQ_GSSSTEP, 0, mm_answer_gss_accept_ctx},
    {MONITOR_REQ_GSSUSEROK, MON_ONCE|MON_AUTHDECIDE, mm_answer_gss_userok},
    {MONITOR_REQ_GSSCHECKMIC, MON_ONCE, mm_answer_gss_checkmic},
#endif
    {0, 0, NULL}
};

struct mon_table mon_dispatch_postauth20[] = {
#ifdef WITH_OPENSSL
    {MONITOR_REQ_MODULI, 0, mm_answer_moduli},
#endif
    {MONITOR_REQ_SIGN, 0, mm_answer_sign},
    {MONITOR_REQ_PTY, 0, mm_answer_pty},
    {MONITOR_REQ_PTYCLEANUP, 0, mm_answer_pty_cleanup},
    {MONITOR_REQ_TERM, 0, mm_answer_term},
    {0, 0, NULL}
};

struct mon_table *mon_dispatch;

/* Specifies if a certain message is allowed at the moment */

static void
monitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)
{
	while (ent->f != NULL) {
		if (ent->type == type) {
			ent->flags &= ~MON_PERMIT;
			ent->flags |= permit ? MON_PERMIT : 0;
			return;
		}
		ent++;
	}
}

static void
monitor_permit_authentications(int permit)
{
	struct mon_table *ent = mon_dispatch;

	while (ent->f != NULL) {
		if (ent->flags & MON_AUTH) {
			ent->flags &= ~MON_PERMIT;
			ent->flags |= permit ? MON_PERMIT : 0;
		}
		ent++;
	}
}

void
monitor_child_preauth(Authctxt *_authctxt, struct monitor *pmonitor)
{
	struct ssh *ssh = active_state;	/* XXX */
	struct mon_table *ent;
	int authenticated = 0, partial = 0;

	debug3("preauth child monitor started");

	close(pmonitor->m_recvfd);
	close(pmonitor->m_log_sendfd);
	pmonitor->m_log_sendfd = pmonitor->m_recvfd = -1;

	authctxt = _authctxt;
	memset(authctxt, 0, sizeof(*authctxt));

	mon_dispatch = mon_dispatch_proto20;
	/* Permit requests for moduli and signatures */
	monitor_permit(mon_dispatch, MONITOR_REQ_MODULI, 1);
	monitor_permit(mon_dispatch, MONITOR_REQ_SIGN, 1);

	/* The first few requests do not require asynchronous access */
	while (!authenticated) {
		partial = 0;
		auth_method = "unknown";
		auth_submethod = NULL;
		authenticated = (monitor_read(pmonitor, mon_dispatch, &ent) == 1);

		/* Special handling for multiple required authentications */
		if (options.num_auth_methods != 0) {
			if (authenticated &&
			    !auth2_update_methods_lists(authctxt,
			    auth_method, auth_submethod)) {
				debug3("%s: method %s: partial", __func__,
				    auth_method);
				authenticated = 0;
				partial = 1;
			}
		}

		if (authenticated) {
			if (!(ent->flags & MON_AUTHDECIDE))
				fatal("%s: unexpected authentication from %d",
				    __func__, ent->type);
			if (authctxt->pw->pw_uid == 0 &&
			    !auth_root_allowed(auth_method))
				authenticated = 0;
		}
		if (ent->flags & (MON_AUTHDECIDE|MON_ALOG)) {
			auth_log(authctxt, authenticated, partial,
			    auth_method, auth_submethod);
			if (!partial && !authenticated)
				authctxt->failures++;
		}
	}

	if (!authctxt->valid)
		fatal("%s: authenticated invalid user", __func__);
	if (strcmp(auth_method, "unknown") == 0)
		fatal("%s: authentication method name unknown", __func__);

	debug("%s: %s has been authenticated by privileged process",
	    __func__, authctxt->user);
	ssh_packet_set_log_preamble(ssh, "user %s", authctxt->user);

	mm_get_keystate(pmonitor);

	/* Drain any buffered messages from the child */
	while (pmonitor->m_log_recvfd != -1 && monitor_read_log(pmonitor) == 0)
		;

	close(pmonitor->m_sendfd);
	close(pmonitor->m_log_recvfd);
	pmonitor->m_sendfd = pmonitor->m_log_recvfd = -1;
}

static void
monitor_set_child_handler(pid_t pid)
{
	monitor_child_pid = pid;
}

static void
monitor_child_handler(int sig)
{
	kill(monitor_child_pid, sig);
}

void
monitor_child_postauth(struct monitor *pmonitor)
{
	close(pmonitor->m_recvfd);
	pmonitor->m_recvfd = -1;

	monitor_set_child_handler(pmonitor->m_pid);
	signal(SIGHUP, &monitor_child_handler);
	signal(SIGTERM, &monitor_child_handler);
	signal(SIGINT, &monitor_child_handler);

	mon_dispatch = mon_dispatch_postauth20;

	/* Permit requests for moduli and signatures */
	monitor_permit(mon_dispatch, MONITOR_REQ_MODULI, 1);
	monitor_permit(mon_dispatch, MONITOR_REQ_SIGN, 1);
	monitor_permit(mon_dispatch, MONITOR_REQ_TERM, 1);

	if (!no_pty_flag) {
		monitor_permit(mon_dispatch, MONITOR_REQ_PTY, 1);
		monitor_permit(mon_dispatch, MONITOR_REQ_PTYCLEANUP, 1);
	}

	for (;;)
		monitor_read(pmonitor, mon_dispatch, NULL);
}

static int
monitor_read_log(struct monitor *pmonitor)
{
	Buffer logmsg;
	u_int len, level;
	char *msg;

	buffer_init(&logmsg);

	/* Read length */
	buffer_append_space(&logmsg, 4);
	if (atomicio(read, pmonitor->m_log_recvfd,
	    buffer_ptr(&logmsg), buffer_len(&logmsg)) != buffer_len(&logmsg)) {
		if (errno == EPIPE) {
			buffer_free(&logmsg);
			debug("%s: child log fd closed", __func__);
			close(pmonitor->m_log_recvfd);
			pmonitor->m_log_recvfd = -1;
			return -1;
		}
		fatal("%s: log fd read: %s", __func__, strerror(errno));
	}
	len = buffer_get_int(&logmsg);
	if (len <= 4 || len > 8192)
		fatal("%s: invalid log message length %u", __func__, len);

	/* Read severity, message */
	buffer_clear(&logmsg);
	buffer_append_space(&logmsg, len);
	if (atomicio(read, pmonitor->m_log_recvfd,
	    buffer_ptr(&logmsg), buffer_len(&logmsg)) != buffer_len(&logmsg))
		fatal("%s: log fd read: %s", __func__, strerror(errno));

	/* Log it */
	level = buffer_get_int(&logmsg);
	msg = buffer_get_string(&logmsg, NULL);
	if (log_level_name(level) == NULL)
		fatal("%s: invalid log level %u (corrupted message?)",
		    __func__, level);
	do_log2(level, "%s [preauth]", msg);

	buffer_free(&logmsg);
	free(msg);

	return 0;
}

int
monitor_read(struct monitor *pmonitor, struct mon_table *ent,
    struct mon_table **pent)
{
	Buffer m;
	int ret;
	u_char type;
	struct pollfd pfd[2];

	for (;;) {
		memset(&pfd, 0, sizeof(pfd));
		pfd[0].fd = pmonitor->m_sendfd;
		pfd[0].events = POLLIN;
		pfd[1].fd = pmonitor->m_log_recvfd;
		pfd[1].events = pfd[1].fd == -1 ? 0 : POLLIN;
		if (poll(pfd, pfd[1].fd == -1 ? 1 : 2, -1) == -1) {
			if (errno == EINTR || errno == EAGAIN)
				continue;
			fatal("%s: poll: %s", __func__, strerror(errno));
		}
		if (pfd[1].revents) {
			/*
			 * Drain all log messages before processing next
			 * monitor request.
			 */
			monitor_read_log(pmonitor);
			continue;
		}
		if (pfd[0].revents)
			break;  /* Continues below */
	}

	buffer_init(&m);

	mm_request_receive(pmonitor->m_sendfd, &m);
	type = buffer_get_char(&m);

	debug3("%s: checking request %d", __func__, type);

	while (ent->f != NULL) {
		if (ent->type == type)
			break;
		ent++;
	}

	if (ent->f != NULL) {
		if (!(ent->flags & MON_PERMIT))
			fatal("%s: unpermitted request %d", __func__,
			    type);
		ret = (*ent->f)(pmonitor->m_sendfd, &m);
		buffer_free(&m);

		/* The child may use this request only once, disable it */
		if (ent->flags & MON_ONCE) {
			debug2("%s: %d used once, disabling now", __func__,
			    type);
			ent->flags &= ~MON_PERMIT;
		}

		if (pent != NULL)
			*pent = ent;

		return ret;
	}

	fatal("%s: unsupported request: %d", __func__, type);

	/* NOTREACHED */
	return (-1);
}

/* allowed key state */
static int
monitor_allowed_key(u_char *blob, u_int bloblen)
{
	/* make sure key is allowed */
	if (key_blob == NULL || key_bloblen != bloblen ||
	    timingsafe_bcmp(key_blob, blob, key_bloblen))
		return (0);
	return (1);
}

static void
monitor_reset_key_state(void)
{
	/* reset state */
	free(key_blob);
	free(hostbased_cuser);
	free(hostbased_chost);
	key_blob = NULL;
	key_bloblen = 0;
	key_blobtype = MM_NOKEY;
	hostbased_cuser = NULL;
	hostbased_chost = NULL;
}

#ifdef WITH_OPENSSL
int
mm_answer_moduli(int sock, Buffer *m)
{
	DH *dh;
	int min, want, max;

	min = buffer_get_int(m);
	want = buffer_get_int(m);
	max = buffer_get_int(m);

	debug3("%s: got parameters: %d %d %d",
	    __func__, min, want, max);
	/* We need to check here, too, in case the child got corrupted */
	if (max < min || want < min || max < want)
		fatal("%s: bad parameters: %d %d %d",
		    __func__, min, want, max);

	buffer_clear(m);

	dh = choose_dh(min, want, max);
	if (dh == NULL) {
		buffer_put_char(m, 0);
		return (0);
	} else {
		/* Send first bignum */
		buffer_put_char(m, 1);
		buffer_put_bignum2(m, dh->p);
		buffer_put_bignum2(m, dh->g);

		DH_free(dh);
	}
	mm_request_send(sock, MONITOR_ANS_MODULI, m);
	return (0);
}
#endif

int
mm_answer_sign(int sock, Buffer *m)
{
	struct ssh *ssh = active_state; 	/* XXX */
	extern int auth_sock;			/* XXX move to state struct? */
	struct sshkey *key;
	struct sshbuf *sigbuf = NULL;
	u_char *p = NULL, *signature = NULL;
	char *alg = NULL;
	size_t datlen, siglen, alglen;
	int r, is_proof = 0;
	u_int keyid;
	const char proof_req[] = "hostkeys-prove-00@@openssh.com";

	debug3("%s", __func__);

	if ((r = sshbuf_get_u32(m, &keyid)) != 0 ||
	    (r = sshbuf_get_string(m, &p, &datlen)) != 0 ||
	    (r = sshbuf_get_cstring(m, &alg, &alglen)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (keyid > INT_MAX)
		fatal("%s: invalid key ID", __func__);

	/*
	 * Supported KEX types use SHA1 (20 bytes), SHA256 (32 bytes),
	 * SHA384 (48 bytes) and SHA512 (64 bytes).
	 *
	 * Otherwise, verify the signature request is for a hostkey
	 * proof.
	 *
	 * XXX perform similar check for KEX signature requests too?
	 * it's not trivial, since what is signed is the hash, rather
	 * than the full kex structure...
	 */
	if (datlen != 20 && datlen != 32 && datlen != 48 && datlen != 64) {
		/*
		 * Construct expected hostkey proof and compare it to what
		 * the client sent us.
		 */
		if (session_id2_len == 0) /* hostkeys is never first */
			fatal("%s: bad data length: %zu", __func__, datlen);
		if ((key = get_hostkey_public_by_index(keyid, ssh)) == NULL)
			fatal("%s: no hostkey for index %d", __func__, keyid);
		if ((sigbuf = sshbuf_new()) == NULL)
			fatal("%s: sshbuf_new", __func__);
		if ((r = sshbuf_put_cstring(sigbuf, proof_req)) != 0 ||
		    (r = sshbuf_put_string(sigbuf, session_id2,
		    session_id2_len)) != 0 ||
		    (r = sshkey_puts(key, sigbuf)) != 0)
			fatal("%s: couldn't prepare private key "
			    "proof buffer: %s", __func__, ssh_err(r));
		if (datlen != sshbuf_len(sigbuf) ||
		    memcmp(p, sshbuf_ptr(sigbuf), sshbuf_len(sigbuf)) != 0)
			fatal("%s: bad data length: %zu, hostkey proof len %zu",
			    __func__, datlen, sshbuf_len(sigbuf));
		sshbuf_free(sigbuf);
		is_proof = 1;
	}

	/* save session id, it will be passed on the first call */
	if (session_id2_len == 0) {
		session_id2_len = datlen;
		session_id2 = xmalloc(session_id2_len);
		memcpy(session_id2, p, session_id2_len);
	}

	if ((key = get_hostkey_by_index(keyid)) != NULL) {
		if ((r = sshkey_sign(key, &signature, &siglen, p, datlen, alg,
		    datafellows)) != 0)
			fatal("%s: sshkey_sign failed: %s",
			    __func__, ssh_err(r));
	} else if ((key = get_hostkey_public_by_index(keyid, ssh)) != NULL &&
	    auth_sock > 0) {
		if ((r = ssh_agent_sign(auth_sock, key, &signature, &siglen,
		    p, datlen, alg, datafellows)) != 0) {
			fatal("%s: ssh_agent_sign failed: %s",
			    __func__, ssh_err(r));
		}
	} else
		fatal("%s: no hostkey from index %d", __func__, keyid);

	debug3("%s: %s signature %p(%zu)", __func__,
	    is_proof ? "KEX" : "hostkey proof", signature, siglen);

	sshbuf_reset(m);
	if ((r = sshbuf_put_string(m, signature, siglen)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	free(alg);
	free(p);
	free(signature);

	mm_request_send(sock, MONITOR_ANS_SIGN, m);

	/* Turn on permissions for getpwnam */
	monitor_permit(mon_dispatch, MONITOR_REQ_PWNAM, 1);

	return (0);
}

/* Retrieves the password entry and also checks if the user is permitted */

int
mm_answer_pwnamallow(int sock, Buffer *m)
{
	struct ssh *ssh = active_state;	/* XXX */
	char *username;
	struct passwd *pwent;
	int allowed = 0;
	u_int i;

	debug3("%s", __func__);

	if (authctxt->attempt++ != 0)
		fatal("%s: multiple attempts for getpwnam", __func__);

	username = buffer_get_string(m, NULL);

	pwent = getpwnamallow(username);

	authctxt->user = xstrdup(username);
	setproctitle("%s [priv]", pwent ? username : "unknown");
	free(username);

	buffer_clear(m);

	if (pwent == NULL) {
		buffer_put_char(m, 0);
		authctxt->pw = fakepw();
		goto out;
	}

	allowed = 1;
	authctxt->pw = pwent;
	authctxt->valid = 1;

	buffer_put_char(m, 1);
	buffer_put_string(m, pwent, sizeof(struct passwd));
	buffer_put_cstring(m, pwent->pw_name);
	buffer_put_cstring(m, "*");
	buffer_put_cstring(m, pwent->pw_gecos);
	buffer_put_cstring(m, pwent->pw_class);
	buffer_put_cstring(m, pwent->pw_dir);
	buffer_put_cstring(m, pwent->pw_shell);

 out:
	ssh_packet_set_log_preamble(ssh, "%suser %s",
	    authctxt->valid ? "authenticating" : "invalid ", authctxt->user);
	buffer_put_string(m, &options, sizeof(options));

#define M_CP_STROPT(x) do { \
		if (options.x != NULL) \
			buffer_put_cstring(m, options.x); \
	} while (0)
#define M_CP_STRARRAYOPT(x, nx) do { \
		for (i = 0; i < options.nx; i++) \
			buffer_put_cstring(m, options.x[i]); \
	} while (0)
	/* See comment in servconf.h */
	COPY_MATCH_STRING_OPTS();
#undef M_CP_STROPT
#undef M_CP_STRARRAYOPT

	/* Create valid auth method lists */
	if (auth2_setup_methods_lists(authctxt) != 0) {
		/*
		 * The monitor will continue long enough to let the child
		 * run to it's packet_disconnect(), but it must not allow any
		 * authentication to succeed.
		 */
		debug("%s: no valid authentication method lists", __func__);
	}

	debug3("%s: sending MONITOR_ANS_PWNAM: %d", __func__, allowed);
	mm_request_send(sock, MONITOR_ANS_PWNAM, m);

	/* Allow service/style information on the auth context */
	monitor_permit(mon_dispatch, MONITOR_REQ_AUTHSERV, 1);
	monitor_permit(mon_dispatch, MONITOR_REQ_AUTH2_READ_BANNER, 1);

	return (0);
}

int mm_answer_auth2_read_banner(int sock, Buffer *m)
{
	char *banner;

	buffer_clear(m);
	banner = auth2_read_banner();
	buffer_put_cstring(m, banner != NULL ? banner : "");
	mm_request_send(sock, MONITOR_ANS_AUTH2_READ_BANNER, m);
	free(banner);

	return (0);
}

int
mm_answer_authserv(int sock, Buffer *m)
{
	monitor_permit_authentications(1);

	authctxt->service = buffer_get_string(m, NULL);
	authctxt->style = buffer_get_string(m, NULL);
	debug3("%s: service=%s, style=%s",
	    __func__, authctxt->service, authctxt->style);

	if (strlen(authctxt->style) == 0) {
		free(authctxt->style);
		authctxt->style = NULL;
	}

	return (0);
}

int
mm_answer_authpassword(int sock, Buffer *m)
{
	static int call_count;
	char *passwd;
	int authenticated;
	u_int plen;

	if (!options.password_authentication)
		fatal("%s: password authentication not enabled", __func__);
	passwd = buffer_get_string(m, &plen);
	/* Only authenticate if the context is valid */
	authenticated = options.password_authentication &&
	    auth_password(authctxt, passwd);
	explicit_bzero(passwd, strlen(passwd));
	free(passwd);

	buffer_clear(m);
	buffer_put_int(m, authenticated);

	debug3("%s: sending result %d", __func__, authenticated);
	mm_request_send(sock, MONITOR_ANS_AUTHPASSWORD, m);

	call_count++;
	if (plen == 0 && call_count == 1)
		auth_method = "none";
	else
		auth_method = "password";

	/* Causes monitor loop to terminate if authenticated */
	return (authenticated);
}

int
mm_answer_bsdauthquery(int sock, Buffer *m)
{
	char *name, *infotxt;
	u_int numprompts;
	u_int *echo_on;
	char **prompts;
	u_int success;

	if (!options.kbd_interactive_authentication)
		fatal("%s: kbd-int authentication not enabled", __func__);
	success = bsdauth_query(authctxt, &name, &infotxt, &numprompts,
	    &prompts, &echo_on) < 0 ? 0 : 1;

	buffer_clear(m);
	buffer_put_int(m, success);
	if (success)
		buffer_put_cstring(m, prompts[0]);

	debug3("%s: sending challenge success: %u", __func__, success);
	mm_request_send(sock, MONITOR_ANS_BSDAUTHQUERY, m);

	if (success) {
		free(name);
		free(infotxt);
		free(prompts);
		free(echo_on);
	}

	return (0);
}

int
mm_answer_bsdauthrespond(int sock, Buffer *m)
{
	char *response;
	int authok;

	if (!options.kbd_interactive_authentication)
		fatal("%s: kbd-int authentication not enabled", __func__);
	if (authctxt->as == NULL)
		fatal("%s: no bsd auth session", __func__);

	response = buffer_get_string(m, NULL);
	authok = options.challenge_response_authentication &&
	    auth_userresponse(authctxt->as, response, 0);
	authctxt->as = NULL;
	debug3("%s: <%s> = <%d>", __func__, response, authok);
	free(response);

	buffer_clear(m);
	buffer_put_int(m, authok);

	debug3("%s: sending authenticated: %d", __func__, authok);
	mm_request_send(sock, MONITOR_ANS_BSDAUTHRESPOND, m);

	auth_method = "keyboard-interactive";
	auth_submethod = "bsdauth";

	return (authok != 0);
}

int
mm_answer_keyallowed(int sock, Buffer *m)
{
	struct sshkey *key;
	char *cuser, *chost;
	u_char *blob;
	u_int bloblen, pubkey_auth_attempt;
	enum mm_keytype type = 0;
	int allowed = 0;

	debug3("%s entering", __func__);

	type = buffer_get_int(m);
	cuser = buffer_get_string(m, NULL);
	chost = buffer_get_string(m, NULL);
	blob = buffer_get_string(m, &bloblen);
	pubkey_auth_attempt = buffer_get_int(m);

	key = key_from_blob(blob, bloblen);

	debug3("%s: key_from_blob: %p", __func__, key);

	if (key != NULL && authctxt->valid) {
		/* These should not make it past the privsep child */
		if (key_type_plain(key->type) == KEY_RSA &&
		    (datafellows & SSH_BUG_RSASIGMD5) != 0)
			fatal("%s: passed a SSH_BUG_RSASIGMD5 key", __func__);

		switch (type) {
		case MM_USERKEY:
			allowed = options.pubkey_authentication &&
			    !auth2_userkey_already_used(authctxt, key) &&
			    match_pattern_list(sshkey_ssh_name(key),
			    options.pubkey_key_types, 0) == 1 &&
			    user_key_allowed(authctxt->pw, key,
			    pubkey_auth_attempt);
			pubkey_auth_info(authctxt, key, NULL);
			auth_method = "publickey";
			if (options.pubkey_authentication &&
			    (!pubkey_auth_attempt || allowed != 1))
				auth_clear_options();
			break;
		case MM_HOSTKEY:
			allowed = options.hostbased_authentication &&
			    match_pattern_list(sshkey_ssh_name(key),
			    options.hostbased_key_types, 0) == 1 &&
			    hostbased_key_allowed(authctxt->pw,
			    cuser, chost, key);
			pubkey_auth_info(authctxt, key,
			    "client user \"%.100s\", client host \"%.100s\"",
			    cuser, chost);
			auth_method = "hostbased";
			break;
		default:
			fatal("%s: unknown key type %d", __func__, type);
			break;
		}
	}

	debug3("%s: key %p is %s",
	    __func__, key, allowed ? "allowed" : "not allowed");

	if (key != NULL)
		key_free(key);

	/* clear temporarily storage (used by verify) */
	monitor_reset_key_state();

	if (allowed) {
		/* Save temporarily for comparison in verify */
		key_blob = blob;
		key_bloblen = bloblen;
		key_blobtype = type;
		hostbased_cuser = cuser;
		hostbased_chost = chost;
	} else {
		/* Log failed attempt */
		auth_log(authctxt, 0, 0, auth_method, NULL);
		free(blob);
		free(cuser);
		free(chost);
	}

	buffer_clear(m);
	buffer_put_int(m, allowed);
	buffer_put_int(m, forced_command != NULL);

	mm_request_send(sock, MONITOR_ANS_KEYALLOWED, m);

	return (0);
}

static int
monitor_valid_userblob(u_char *data, u_int datalen)
{
	Buffer b;
	u_char *p;
	char *userstyle, *cp;
	u_int len;
	int fail = 0;

	buffer_init(&b);
	buffer_append(&b, data, datalen);

	if (datafellows & SSH_OLD_SESSIONID) {
		p = buffer_ptr(&b);
		len = buffer_len(&b);
		if ((session_id2 == NULL) ||
		    (len < session_id2_len) ||
		    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))
			fail++;
		buffer_consume(&b, session_id2_len);
	} else {
		p = buffer_get_string(&b, &len);
		if ((session_id2 == NULL) ||
		    (len != session_id2_len) ||
		    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))
			fail++;
		free(p);
	}
	if (buffer_get_char(&b) != SSH2_MSG_USERAUTH_REQUEST)
		fail++;
	cp = buffer_get_cstring(&b, NULL);
	xasprintf(&userstyle, "%s%s%s", authctxt->user,
	    authctxt->style ? ":" : "",
	    authctxt->style ? authctxt->style : "");
	if (strcmp(userstyle, cp) != 0) {
		logit("wrong user name passed to monitor: "
		    "expected %s != %.100s", userstyle, cp);
		fail++;
	}
	free(userstyle);
	free(cp);
	buffer_skip_string(&b);
	if (datafellows & SSH_BUG_PKAUTH) {
		if (!buffer_get_char(&b))
			fail++;
	} else {
		cp = buffer_get_cstring(&b, NULL);
		if (strcmp("publickey", cp) != 0)
			fail++;
		free(cp);
		if (!buffer_get_char(&b))
			fail++;
		buffer_skip_string(&b);
	}
	buffer_skip_string(&b);
	if (buffer_len(&b) != 0)
		fail++;
	buffer_free(&b);
	return (fail == 0);
}

static int
monitor_valid_hostbasedblob(u_char *data, u_int datalen, char *cuser,
    char *chost)
{
	Buffer b;
	char *p, *userstyle;
	u_int len;
	int fail = 0;

	buffer_init(&b);
	buffer_append(&b, data, datalen);

	p = buffer_get_string(&b, &len);
	if ((session_id2 == NULL) ||
	    (len != session_id2_len) ||
	    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))
		fail++;
	free(p);

	if (buffer_get_char(&b) != SSH2_MSG_USERAUTH_REQUEST)
		fail++;
	p = buffer_get_cstring(&b, NULL);
	xasprintf(&userstyle, "%s%s%s", authctxt->user,
	    authctxt->style ? ":" : "",
	    authctxt->style ? authctxt->style : "");
	if (strcmp(userstyle, p) != 0) {
		logit("wrong user name passed to monitor: expected %s != %.100s",
		    userstyle, p);
		fail++;
	}
	free(userstyle);
	free(p);
	buffer_skip_string(&b);	/* service */
	p = buffer_get_cstring(&b, NULL);
	if (strcmp(p, "hostbased") != 0)
		fail++;
	free(p);
	buffer_skip_string(&b);	/* pkalg */
	buffer_skip_string(&b);	/* pkblob */

	/* verify client host, strip trailing dot if necessary */
	p = buffer_get_string(&b, NULL);
	if (((len = strlen(p)) > 0) && p[len - 1] == '.')
		p[len - 1] = '\0';
	if (strcmp(p, chost) != 0)
		fail++;
	free(p);

	/* verify client user */
	p = buffer_get_string(&b, NULL);
	if (strcmp(p, cuser) != 0)
		fail++;
	free(p);

	if (buffer_len(&b) != 0)
		fail++;
	buffer_free(&b);
	return (fail == 0);
}

int
mm_answer_keyverify(int sock, struct sshbuf *m)
{
	struct sshkey *key;
	u_char *signature, *data, *blob;
	size_t signaturelen, datalen, bloblen;
	int r, ret, valid_data = 0, encoded_ret;

	if ((r = sshbuf_get_string(m, &blob, &bloblen)) != 0 ||
	    (r = sshbuf_get_string(m, &signature, &signaturelen)) != 0 ||
	    (r = sshbuf_get_string(m, &data, &datalen)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	if (hostbased_cuser == NULL || hostbased_chost == NULL ||
	  !monitor_allowed_key(blob, bloblen))
		fatal("%s: bad key, not previously allowed", __func__);

	/* XXX use sshkey_froms here; need to change key_blob, etc. */
	if ((r = sshkey_from_blob(blob, bloblen, &key)) != 0)
		fatal("%s: bad public key blob: %s", __func__, ssh_err(r));

	switch (key_blobtype) {
	case MM_USERKEY:
		valid_data = monitor_valid_userblob(data, datalen);
		break;
	case MM_HOSTKEY:
		valid_data = monitor_valid_hostbasedblob(data, datalen,
		    hostbased_cuser, hostbased_chost);
		break;
	default:
		valid_data = 0;
		break;
	}
	if (!valid_data)
		fatal("%s: bad signature data blob", __func__);

	ret = sshkey_verify(key, signature, signaturelen, data, datalen,
	    active_state->compat);
	debug3("%s: key %p signature %s",
	    __func__, key, (ret == 0) ? "verified" : "unverified");

	/* If auth was successful then record key to ensure it isn't reused */
	if (ret == 0 && key_blobtype == MM_USERKEY)
		auth2_record_userkey(authctxt, key);
	else
		sshkey_free(key);

	free(blob);
	free(signature);
	free(data);

	auth_method = key_blobtype == MM_USERKEY ? "publickey" : "hostbased";

	monitor_reset_key_state();

	sshbuf_reset(m);

	/* encode ret != 0 as positive integer, since we're sending u32 */
	encoded_ret = (ret != 0);
	if ((r = sshbuf_put_u32(m, encoded_ret)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	mm_request_send(sock, MONITOR_ANS_KEYVERIFY, m);

	return ret == 0;
}

static void
mm_record_login(Session *s, struct passwd *pw)
{
	struct ssh *ssh = active_state;	/* XXX */
	socklen_t fromlen;
	struct sockaddr_storage from;

	/*
	 * Get IP address of client. If the connection is not a socket, let
	 * the address be 0.0.0.0.
	 */
	memset(&from, 0, sizeof(from));
	fromlen = sizeof(from);
	if (packet_connection_is_on_socket()) {
		if (getpeername(packet_get_connection_in(),
		    (struct sockaddr *)&from, &fromlen) < 0) {
			debug("getpeername: %.100s", strerror(errno));
			cleanup_exit(255);
		}
	}
	/* Record that there was a login on that tty from the remote host. */
	record_login(s->pid, s->tty, pw->pw_name, pw->pw_uid,
	    session_get_remote_name_or_ip(ssh, utmp_len, options.use_dns),
	    (struct sockaddr *)&from, fromlen);
}

static void
mm_session_close(Session *s)
{
	debug3("%s: session %d pid %ld", __func__, s->self, (long)s->pid);
	if (s->ttyfd != -1) {
		debug3("%s: tty %s ptyfd %d", __func__, s->tty, s->ptyfd);
		session_pty_cleanup2(s);
	}
	session_unused(s->self);
}

int
mm_answer_pty(int sock, Buffer *m)
{
	extern struct monitor *pmonitor;
	Session *s;
	int res, fd0;

	debug3("%s entering", __func__);

	buffer_clear(m);
	s = session_new();
	if (s == NULL)
		goto error;
	s->authctxt = authctxt;
	s->pw = authctxt->pw;
	s->pid = pmonitor->m_pid;
	res = pty_allocate(&s->ptyfd, &s->ttyfd, s->tty, sizeof(s->tty));
	if (res == 0)
		goto error;
	pty_setowner(authctxt->pw, s->tty);

	buffer_put_int(m, 1);
	buffer_put_cstring(m, s->tty);

	/* We need to trick ttyslot */
	if (dup2(s->ttyfd, 0) == -1)
		fatal("%s: dup2", __func__);

	mm_record_login(s, authctxt->pw);

	/* Now we can close the file descriptor again */
	close(0);

	/* send messages generated by record_login */
	buffer_put_string(m, buffer_ptr(&loginmsg), buffer_len(&loginmsg));
	buffer_clear(&loginmsg);

	mm_request_send(sock, MONITOR_ANS_PTY, m);

	if (mm_send_fd(sock, s->ptyfd) == -1 ||
	    mm_send_fd(sock, s->ttyfd) == -1)
		fatal("%s: send fds failed", __func__);

	/* make sure nothing uses fd 0 */
	if ((fd0 = open(_PATH_DEVNULL, O_RDONLY)) < 0)
		fatal("%s: open(/dev/null): %s", __func__, strerror(errno));
	if (fd0 != 0)
		error("%s: fd0 %d != 0", __func__, fd0);

	/* slave is not needed */
	close(s->ttyfd);
	s->ttyfd = s->ptyfd;
	/* no need to dup() because nobody closes ptyfd */
	s->ptymaster = s->ptyfd;

	debug3("%s: tty %s ptyfd %d", __func__, s->tty, s->ttyfd);

	return (0);

 error:
	if (s != NULL)
		mm_session_close(s);
	buffer_put_int(m, 0);
	mm_request_send(sock, MONITOR_ANS_PTY, m);
	return (0);
}

int
mm_answer_pty_cleanup(int sock, Buffer *m)
{
	Session *s;
	char *tty;

	debug3("%s entering", __func__);

	tty = buffer_get_string(m, NULL);
	if ((s = session_by_tty(tty)) != NULL)
		mm_session_close(s);
	buffer_clear(m);
	free(tty);
	return (0);
}

int
mm_answer_term(int sock, Buffer *req)
{
	extern struct monitor *pmonitor;
	int res, status;

	debug3("%s: tearing down sessions", __func__);

	/* The child is terminating */
	session_destroy_all(&mm_session_close);

	while (waitpid(pmonitor->m_pid, &status, 0) == -1)
		if (errno != EINTR)
			exit(1);

	res = WIFEXITED(status) ? WEXITSTATUS(status) : 1;

	/* Terminate process */
	exit(res);
}

void
monitor_clear_keystate(struct monitor *pmonitor)
{
	struct ssh *ssh = active_state;	/* XXX */

	ssh_clear_newkeys(ssh, MODE_IN);
	ssh_clear_newkeys(ssh, MODE_OUT);
	sshbuf_free(child_state);
	child_state = NULL;
}

void
monitor_apply_keystate(struct monitor *pmonitor)
{
	struct ssh *ssh = active_state;	/* XXX */
	struct kex *kex;
	int r;

	debug3("%s: packet_set_state", __func__);
	if ((r = ssh_packet_set_state(ssh, child_state)) != 0)
                fatal("%s: packet_set_state: %s", __func__, ssh_err(r));
	sshbuf_free(child_state);
	child_state = NULL;

	if ((kex = ssh->kex) != NULL) {
		/* XXX set callbacks */
#ifdef WITH_OPENSSL
		kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;
		kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;
		kex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;
		kex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;
		kex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;
		kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;
		kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;
		kex->kex[KEX_ECDH_SHA2] = kexecdh_server;
#endif
		kex->kex[KEX_C25519_SHA256] = kexc25519_server;
		kex->load_host_public_key=&get_hostkey_public_by_type;
		kex->load_host_private_key=&get_hostkey_private_by_type;
		kex->host_key_index=&get_hostkey_index;
		kex->sign = sshd_hostkey_sign;
	}
}

/* This function requries careful sanity checking */

void
mm_get_keystate(struct monitor *pmonitor)
{
	debug3("%s: Waiting for new keys", __func__);

	if ((child_state = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	mm_request_receive_expect(pmonitor->m_sendfd, MONITOR_REQ_KEYEXPORT,
	    child_state);
	debug3("%s: GOT new keys", __func__);
}


/* XXX */

#define FD_CLOSEONEXEC(x) do { \
	if (fcntl(x, F_SETFD, FD_CLOEXEC) == -1) \
		fatal("fcntl(%d, F_SETFD)", x); \
} while (0)

static void
monitor_openfds(struct monitor *mon, int do_logfds)
{
	int pair[2];

	if (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1)
		fatal("%s: socketpair: %s", __func__, strerror(errno));
	FD_CLOSEONEXEC(pair[0]);
	FD_CLOSEONEXEC(pair[1]);
	mon->m_recvfd = pair[0];
	mon->m_sendfd = pair[1];

	if (do_logfds) {
		if (pipe(pair) == -1)
			fatal("%s: pipe: %s", __func__, strerror(errno));
		FD_CLOSEONEXEC(pair[0]);
		FD_CLOSEONEXEC(pair[1]);
		mon->m_log_recvfd = pair[0];
		mon->m_log_sendfd = pair[1];
	} else
		mon->m_log_recvfd = mon->m_log_sendfd = -1;
}

#define MM_MEMSIZE	65536

struct monitor *
monitor_init(void)
{
	struct monitor *mon;

	mon = xcalloc(1, sizeof(*mon));
	monitor_openfds(mon, 1);

	return mon;
}

void
monitor_reinit(struct monitor *mon)
{
	monitor_openfds(mon, 0);
}

#ifdef GSSAPI
int
mm_answer_gss_setup_ctx(int sock, Buffer *m)
{
	gss_OID_desc goid;
	OM_uint32 major;
	u_int len;

	if (!options.gss_authentication)
		fatal("%s: GSSAPI authentication not enabled", __func__);

	goid.elements = buffer_get_string(m, &len);
	goid.length = len;

	major = ssh_gssapi_server_ctx(&gsscontext, &goid);

	free(goid.elements);

	buffer_clear(m);
	buffer_put_int(m, major);

	mm_request_send(sock, MONITOR_ANS_GSSSETUP, m);

	/* Now we have a context, enable the step */
	monitor_permit(mon_dispatch, MONITOR_REQ_GSSSTEP, 1);

	return (0);
}

int
mm_answer_gss_accept_ctx(int sock, Buffer *m)
{
	gss_buffer_desc in;
	gss_buffer_desc out = GSS_C_EMPTY_BUFFER;
	OM_uint32 major, minor;
	OM_uint32 flags = 0; /* GSI needs this */
	u_int len;

	if (!options.gss_authentication)
		fatal("%s: GSSAPI authentication not enabled", __func__);

	in.value = buffer_get_string(m, &len);
	in.length = len;
	major = ssh_gssapi_accept_ctx(gsscontext, &in, &out, &flags);
	free(in.value);

	buffer_clear(m);
	buffer_put_int(m, major);
	buffer_put_string(m, out.value, out.length);
	buffer_put_int(m, flags);
	mm_request_send(sock, MONITOR_ANS_GSSSTEP, m);

	gss_release_buffer(&minor, &out);

	if (major == GSS_S_COMPLETE) {
		monitor_permit(mon_dispatch, MONITOR_REQ_GSSSTEP, 0);
		monitor_permit(mon_dispatch, MONITOR_REQ_GSSUSEROK, 1);
		monitor_permit(mon_dispatch, MONITOR_REQ_GSSCHECKMIC, 1);
	}
	return (0);
}

int
mm_answer_gss_checkmic(int sock, Buffer *m)
{
	gss_buffer_desc gssbuf, mic;
	OM_uint32 ret;
	u_int len;

	if (!options.gss_authentication)
		fatal("%s: GSSAPI authentication not enabled", __func__);

	gssbuf.value = buffer_get_string(m, &len);
	gssbuf.length = len;
	mic.value = buffer_get_string(m, &len);
	mic.length = len;

	ret = ssh_gssapi_checkmic(gsscontext, &gssbuf, &mic);

	free(gssbuf.value);
	free(mic.value);

	buffer_clear(m);
	buffer_put_int(m, ret);

	mm_request_send(sock, MONITOR_ANS_GSSCHECKMIC, m);

	if (!GSS_ERROR(ret))
		monitor_permit(mon_dispatch, MONITOR_REQ_GSSUSEROK, 1);

	return (0);
}

int
mm_answer_gss_userok(int sock, Buffer *m)
{
	int authenticated;

	if (!options.gss_authentication)
		fatal("%s: GSSAPI authentication not enabled", __func__);

	authenticated = authctxt->valid && ssh_gssapi_userok(authctxt->user);

	buffer_clear(m);
	buffer_put_int(m, authenticated);

	debug3("%s: sending result %d", __func__, authenticated);
	mm_request_send(sock, MONITOR_ANS_GSSUSEROK, m);

	auth_method = "gssapi-with-mic";

	/* Monitor loop will terminate if authenticated */
	return (authenticated);
}
#endif /* GSSAPI */

@


1.169
log
@switch auth2-pubkey.c to modern APIs; with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.168 2017/05/30 08:52:19 markus Exp $ */
d1246 11
@


1.168
log
@switch from Key typedef with struct sshkey; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.167 2017/02/03 23:05:57 djm Exp $ */
d1042 1
a1042 1
mm_answer_keyverify(int sock, Buffer *m)
d1046 2
a1047 3
	u_int signaturelen, datalen, bloblen;
	int verified = 0;
	int valid_data = 0;
d1049 4
a1052 3
	blob = buffer_get_string(m, &bloblen);
	signature = buffer_get_string(m, &signaturelen);
	data = buffer_get_string(m, &datalen);
d1058 3
a1060 3
	key = key_from_blob(blob, bloblen);
	if (key == NULL)
		fatal("%s: bad public key blob", __func__);
d1077 2
a1078 1
	verified = key_verify(key, signature, signaturelen, data, datalen);
d1080 1
a1080 1
	    __func__, key, (verified == 1) ? "verified" : "unverified");
d1083 1
a1083 1
	if (verified == 1 && key_blobtype == MM_USERKEY)
d1086 1
a1086 1
		key_free(key);
d1096 6
a1101 2
	buffer_clear(m);
	buffer_put_int(m, verified);
d1104 1
a1104 1
	return (verified == 1);
@


1.167
log
@use ssh_packet_set_log_preamble() to include connection username
in packet log messages, e.g.

Connection closed by invalid user foo 10.1.1.1 port 44056 [preauth]

ok markus@@ bz#113
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.166 2016/09/28 16:33:06 djm Exp $ */
d831 1
a831 1
	Key *key;
d1044 1
a1044 1
	Key *key;
@


1.166
log
@Remove support for pre-authentication compression. Doing compression
early in the protocol probably seemed reasonable in the 1990s, but
today it's clearly a bad idea in terms of both cryptography (cf.
multiple compression oracle attacks in TLS) and attack surface.

Moreover, to support it across privilege-separation zlib needed
the assistance of a complex shared-memory manager that made the
required attack surface considerably larger.

Prompted by Guido Vranken pointing out a compiler-elided security
check in the shared memory manager found by Stack
(http://css.csail.mit.edu/stack/); ok deraadt@@ markus@@

NB. pre-auth authentication has been disabled by default in sshd
for >10 years.
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.165 2016/09/05 13:57:31 djm Exp $ */
d227 1
d287 1
d624 1
d665 2
@


1.165
log
@enforce expected request flow for GSSAPI calls; thanks to Jakub Jelen
for testing; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.164 2016/08/30 07:50:21 djm Exp $ */
a72 1
#include "monitor_mm.h"
a336 25
void
monitor_sync(struct monitor *pmonitor)
{
	if (options.compression) {
		/* The member allocation is not visible, so sync it */
		mm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);
	}
}

/* Allocation functions for zlib */
static void *
mm_zalloc(struct mm_master *mm, u_int ncount, u_int size)
{
	if (size == 0 || ncount == 0 || ncount > SIZE_MAX / size)
		fatal("%s: mm_zalloc(%u, %u)", __func__, ncount, size);

	return mm_malloc(mm, size * ncount);
}

static void
mm_zfree(struct mm_master *mm, void *address)
{
	mm_free(mm, address);
}

a1268 7

	/* Update with new address */
	if (options.compression) {
		ssh_packet_set_compress_hooks(ssh, pmonitor->m_zlib,
		    (ssh_packet_comp_alloc_func *)mm_zalloc,
		    (ssh_packet_comp_free_func *)mm_zfree);
	}
a1320 1
	struct ssh *ssh = active_state;			/* XXX */
a1323 1

a1324 11

	/* Used to share zlib space across processes */
	if (options.compression) {
		mon->m_zback = mm_create(NULL, MM_MEMSIZE);
		mon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);

		/* Compression needs to share state across borders */
		ssh_packet_set_compress_hooks(ssh, mon->m_zlib,
		    (ssh_packet_comp_alloc_func *)mm_zalloc,
		    (ssh_packet_comp_free_func *)mm_zfree);
	}
@


1.164
log
@restrict monitor auth calls to be allowed only when their
respective authentication methods are enabled in the configuration.

prompted by Solar Designer; ok markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.163 2016/08/19 03:18:06 djm Exp $ */
d176 3
a178 3
    {MONITOR_REQ_GSSSTEP, MON_ISAUTH, mm_answer_gss_accept_ctx},
    {MONITOR_REQ_GSSUSEROK, MON_AUTH, mm_answer_gss_userok},
    {MONITOR_REQ_GSSCHECKMIC, MON_ISAUTH, mm_answer_gss_checkmic},
@


1.163
log
@remove UseLogin option and support for having /bin/login manage
login sessions; ok deraadt markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.162 2016/08/13 17:47:41 markus Exp $ */
d762 2
d796 2
d825 2
d1389 3
d1419 3
d1450 3
d1478 3
@


1.162
log
@remove ssh1 server code; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.161 2016/07/22 03:39:13 djm Exp $ */
a1122 3

	if (options.use_login)
		return;
@


1.161
log
@move debug("%p", key) to before key is free'd; probable undefined
behaviour on strict compilers; reported by Jakub Jelen bz#2581
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.160 2016/05/02 10:26:04 djm Exp $ */
a133 4
#ifdef WITH_SSH1
static BIGNUM *ssh1_challenge = NULL;	/* used for ssh1 rsa auth */
#endif

a193 25
struct mon_table mon_dispatch_proto15[] = {
#ifdef WITH_SSH1
    {MONITOR_REQ_PWNAM, MON_ONCE, mm_answer_pwnamallow},
    {MONITOR_REQ_SESSKEY, MON_ONCE, mm_answer_sesskey},
    {MONITOR_REQ_SESSID, MON_ONCE, mm_answer_sessid},
    {MONITOR_REQ_AUTHPASSWORD, MON_AUTH, mm_answer_authpassword},
    {MONITOR_REQ_RSAKEYALLOWED, MON_ISAUTH|MON_ALOG, mm_answer_rsa_keyallowed},
    {MONITOR_REQ_KEYALLOWED, MON_ISAUTH|MON_ALOG, mm_answer_keyallowed},
    {MONITOR_REQ_RSACHALLENGE, MON_ONCE, mm_answer_rsa_challenge},
    {MONITOR_REQ_RSARESPONSE, MON_ONCE|MON_AUTHDECIDE, mm_answer_rsa_response},
    {MONITOR_REQ_BSDAUTHQUERY, MON_ISAUTH, mm_answer_bsdauthquery},
    {MONITOR_REQ_BSDAUTHRESPOND, MON_AUTH, mm_answer_bsdauthrespond},
#endif
    {0, 0, NULL}
};

struct mon_table mon_dispatch_postauth15[] = {
#ifdef WITH_SSH1
    {MONITOR_REQ_PTY, MON_ONCE, mm_answer_pty},
    {MONITOR_REQ_PTYCLEANUP, MON_ONCE, mm_answer_pty_cleanup},
    {MONITOR_REQ_TERM, 0, mm_answer_term},
#endif
    {0, 0, NULL}
};

d240 4
a243 11
	if (compat20) {
		mon_dispatch = mon_dispatch_proto20;

		/* Permit requests for moduli and signatures */
		monitor_permit(mon_dispatch, MONITOR_REQ_MODULI, 1);
		monitor_permit(mon_dispatch, MONITOR_REQ_SIGN, 1);
	} else {
		mon_dispatch = mon_dispatch_proto15;

		monitor_permit(mon_dispatch, MONITOR_REQ_SESSKEY, 1);
	}
a253 3
			if (!compat20)
				fatal("AuthenticationMethods is not supported"
				    "with SSH protocol 1");
d322 6
a327 2
	if (compat20) {
		mon_dispatch = mon_dispatch_postauth20;
a328 8
		/* Permit requests for moduli and signatures */
		monitor_permit(mon_dispatch, MONITOR_REQ_MODULI, 1);
		monitor_permit(mon_dispatch, MONITOR_REQ_SIGN, 1);
		monitor_permit(mon_dispatch, MONITOR_REQ_TERM, 1);
	} else {
		mon_dispatch = mon_dispatch_postauth15;
		monitor_permit(mon_dispatch, MONITOR_REQ_TERM, 1);
	}
d704 1
a704 1
	if (compat20 && auth2_setup_methods_lists(authctxt) != 0) {
d716 3
a718 8
	/* For SSHv1 allow authentication now */
	if (!compat20)
		monitor_permit_authentications(1);
	else {
		/* Allow service/style information on the auth context */
		monitor_permit(mon_dispatch, MONITOR_REQ_AUTHSERV, 1);
		monitor_permit(mon_dispatch, MONITOR_REQ_AUTH2_READ_BANNER, 1);
	}
d837 2
a838 5
	if (compat20) {
		auth_method = "keyboard-interactive";
		auth_submethod = "bsdauth";
	} else
		auth_method = "bsdauth";
a862 4
	if ((compat20 && type == MM_RSAHOSTKEY) ||
	    (!compat20 && type != MM_RSAHOSTKEY))
		fatal("%s: key type and protocol mismatch", __func__);

a895 11
#ifdef WITH_SSH1
		case MM_RSAHOSTKEY:
			key->type = KEY_RSA1; /* XXX */
			allowed = options.rhosts_rsa_authentication &&
			    auth_rhosts_rsa_key_allowed(authctxt->pw,
			    cuser, chost, key);
			if (options.rhosts_rsa_authentication && allowed != 1)
				auth_clear_options();
			auth_method = "rsa";
			break;
#endif
a931 3
	if (type == MM_RSAHOSTKEY)
		monitor_permit(mon_dispatch, MONITOR_REQ_RSACHALLENGE, allowed);

a1238 180

#ifdef WITH_SSH1
int
mm_answer_sesskey(int sock, Buffer *m)
{
	BIGNUM *p;
	int rsafail;

	/* Turn off permissions */
	monitor_permit(mon_dispatch, MONITOR_REQ_SESSKEY, 0);

	if ((p = BN_new()) == NULL)
		fatal("%s: BN_new", __func__);

	buffer_get_bignum2(m, p);

	rsafail = ssh1_session_key(p);

	buffer_clear(m);
	buffer_put_int(m, rsafail);
	buffer_put_bignum2(m, p);

	BN_clear_free(p);

	mm_request_send(sock, MONITOR_ANS_SESSKEY, m);

	/* Turn on permissions for sessid passing */
	monitor_permit(mon_dispatch, MONITOR_REQ_SESSID, 1);

	return (0);
}

int
mm_answer_sessid(int sock, Buffer *m)
{
	int i;

	debug3("%s entering", __func__);

	if (buffer_len(m) != 16)
		fatal("%s: bad ssh1 session id", __func__);
	for (i = 0; i < 16; i++)
		session_id[i] = buffer_get_char(m);

	/* Turn on permissions for getpwnam */
	monitor_permit(mon_dispatch, MONITOR_REQ_PWNAM, 1);

	return (0);
}

int
mm_answer_rsa_keyallowed(int sock, Buffer *m)
{
	BIGNUM *client_n;
	Key *key = NULL;
	u_char *blob = NULL;
	u_int blen = 0;
	int allowed = 0;

	debug3("%s entering", __func__);

	auth_method = "rsa";
	if (options.rsa_authentication && authctxt->valid) {
		if ((client_n = BN_new()) == NULL)
			fatal("%s: BN_new", __func__);
		buffer_get_bignum2(m, client_n);
		allowed = auth_rsa_key_allowed(authctxt->pw, client_n, &key);
		BN_clear_free(client_n);
	}
	buffer_clear(m);
	buffer_put_int(m, allowed);
	buffer_put_int(m, forced_command != NULL);

	/* clear temporarily storage (used by generate challenge) */
	monitor_reset_key_state();

	if (allowed && key != NULL) {
		key->type = KEY_RSA;	/* cheat for key_to_blob */
		if (key_to_blob(key, &blob, &blen) == 0)
			fatal("%s: key_to_blob failed", __func__);
		buffer_put_string(m, blob, blen);

		/* Save temporarily for comparison in verify */
		key_blob = blob;
		key_bloblen = blen;
		key_blobtype = MM_RSAUSERKEY;
	}
	if (key != NULL)
		key_free(key);

	mm_request_send(sock, MONITOR_ANS_RSAKEYALLOWED, m);

	monitor_permit(mon_dispatch, MONITOR_REQ_RSACHALLENGE, allowed);
	monitor_permit(mon_dispatch, MONITOR_REQ_RSARESPONSE, 0);
	return (0);
}

int
mm_answer_rsa_challenge(int sock, Buffer *m)
{
	Key *key = NULL;
	u_char *blob;
	u_int blen;

	debug3("%s entering", __func__);

	if (!authctxt->valid)
		fatal("%s: authctxt not valid", __func__);
	blob = buffer_get_string(m, &blen);
	if (!monitor_allowed_key(blob, blen))
		fatal("%s: bad key, not previously allowed", __func__);
	if (key_blobtype != MM_RSAUSERKEY && key_blobtype != MM_RSAHOSTKEY)
		fatal("%s: key type mismatch", __func__);
	if ((key = key_from_blob(blob, blen)) == NULL)
		fatal("%s: received bad key", __func__);
	if (key->type != KEY_RSA)
		fatal("%s: received bad key type %d", __func__, key->type);
	key->type = KEY_RSA1;
	if (ssh1_challenge)
		BN_clear_free(ssh1_challenge);
	ssh1_challenge = auth_rsa_generate_challenge(key);

	buffer_clear(m);
	buffer_put_bignum2(m, ssh1_challenge);

	debug3("%s sending reply", __func__);
	mm_request_send(sock, MONITOR_ANS_RSACHALLENGE, m);

	monitor_permit(mon_dispatch, MONITOR_REQ_RSARESPONSE, 1);

	free(blob);
	key_free(key);
	return (0);
}

int
mm_answer_rsa_response(int sock, Buffer *m)
{
	Key *key = NULL;
	u_char *blob, *response;
	u_int blen, len;
	int success;

	debug3("%s entering", __func__);

	if (!authctxt->valid)
		fatal("%s: authctxt not valid", __func__);
	if (ssh1_challenge == NULL)
		fatal("%s: no ssh1_challenge", __func__);

	blob = buffer_get_string(m, &blen);
	if (!monitor_allowed_key(blob, blen))
		fatal("%s: bad key, not previously allowed", __func__);
	if (key_blobtype != MM_RSAUSERKEY && key_blobtype != MM_RSAHOSTKEY)
		fatal("%s: key type mismatch: %d", __func__, key_blobtype);
	if ((key = key_from_blob(blob, blen)) == NULL)
		fatal("%s: received bad key", __func__);
	response = buffer_get_string(m, &len);
	if (len != 16)
		fatal("%s: received bad response to challenge", __func__);
	success = auth_rsa_verify_response(key, ssh1_challenge, response);

	free(blob);
	key_free(key);
	free(response);

	auth_method = key_blobtype == MM_RSAUSERKEY ? "rsa" : "rhosts-rsa";

	/* reset state */
	BN_clear_free(ssh1_challenge);
	ssh1_challenge = NULL;
	monitor_reset_key_state();

	buffer_clear(m);
	buffer_put_int(m, success);
	mm_request_send(sock, MONITOR_ANS_RSARESPONSE, m);

	return (success);
}
#endif
@


1.160
log
@add support for additional fixed DH groups from
draft-ietf-curdle-ssh-kex-sha2-03

diffie-hellman-group14-sha256 (2K group)
diffie-hellman-group16-sha512 (4K group)
diffie-hellman-group18-sha512 (8K group)

based on patch from Mark D. Baushke and Darren Tucker
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.159 2016/05/02 08:49:03 djm Exp $ */
d967 4
a990 3

	debug3("%s: key %p is %s",
	    __func__, key, allowed ? "allowed" : "not allowed");
@


1.159
log
@fix signed/unsigned errors reported by clang-3.7; add
sshbuf_dup_string() to replace a common idiom of
strdup(sshbuf_ptr()) with better safety checking;
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.158 2016/03/07 19:02:43 djm Exp $ */
d1527 3
@


1.158
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.157 2016/02/15 23:32:37 djm Exp $ */
d40 1
d596 2
a597 1
	int r, keyid, is_proof = 0;
d606 2
d1007 2
a1008 1
	char *p, *userstyle;
d1033 1
a1033 1
	p = buffer_get_cstring(&b, NULL);
d1037 3
a1039 3
	if (strcmp(userstyle, p) != 0) {
		logit("wrong user name passed to monitor: expected %s != %.100s",
		    userstyle, p);
d1043 1
a1043 1
	free(p);
d1049 2
a1050 2
		p = buffer_get_cstring(&b, NULL);
		if (strcmp("publickey", p) != 0)
d1052 1
a1052 1
		free(p);
@


1.157
log
@memleak of algorithm name in mm_answer_sign; reported by Jakub Jelen
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.156 2016/01/14 16:17:39 markus Exp $ */
d1183 1
d1205 1
a1205 1
	    get_remote_name_or_ip(utmp_len, options.use_dns),
@


1.156
log
@remove roaming support; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.155 2015/12/04 16:41:28 markus Exp $ */
d591 3
a593 4
	struct sshbuf *sigbuf;
	u_char *p;
	u_char *signature;
	char *alg;
d670 1
@


1.155
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.154 2015/10/20 23:24:25 mmcc Exp $ */
a79 1
#include "roaming.h"
@


1.154
log
@Compare pointers to NULL rather than 0.

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.153 2015/09/04 04:44:08 djm Exp $ */
d595 2
a596 1
	size_t datlen, siglen;
d603 2
a604 1
	    (r = sshbuf_get_string(m, &p, &datlen)) != 0)
d651 1
a651 1
		if ((r = sshkey_sign(key, &signature, &siglen, p, datlen,
d658 1
a658 1
		    p, datlen, datafellows)) != 0) {
@


1.153
log
@don't record hostbased authentication hostkeys as user keys
in test for multiple authentication with the same key
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.152 2015/09/02 07:51:12 jsg Exp $ */
d864 1
a864 1
	if (authctxt->as == 0)
d1515 1
a1515 1
	if ((kex = ssh->kex) != 0) {
@


1.152
log
@Fix occurrences of "r = func() != 0" which result in the wrong error
codes being returned due to != having higher precedence than =.

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.151 2015/08/21 23:29:31 deraadt Exp $ */
d1159 1
a1159 1
	if (verified == 1)
@


1.151
log
@Improve size == 0, count == 0 checking in mm_zalloc, which is "array" like.
Discussed with tedu, millert, otto.... and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.150 2015/06/22 23:42:16 djm Exp $ */
d629 1
a629 1
		    session_id2_len) != 0) ||
@


1.150
log
@Don't count successful partial authentication as failures in monitor;
this may have caused the monitor to refuse multiple authentications
that would otherwise have successfully completed; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.149 2015/05/04 06:10:48 djm Exp $ */
d394 1
a394 4
	size_t len = (size_t) size * ncount;
	void *address;

	if (len == 0 || ncount > SIZE_MAX / size)
d397 1
a397 3
	address = mm_malloc(mm, len);

	return (address);
@


1.149
log
@Remove pattern length argument from match_pattern_list(),
we only ever use it for strlen(pattern).

Prompted by hanno AT hboeck.de pointing an out-of-bound read
error caused by an incorrect pattern length found using AFL
and his own tools.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.148 2015/05/01 03:23:51 djm Exp $ */
d314 1
a314 1
			if (!authenticated)
@


1.148
log
@prevent authorized_keys options picked up on public key tests without
a corresponding private key authentication being applied to other
authentication methods. Reported by halex@@, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.147 2015/04/27 01:52:30 djm Exp $ */
d931 1
a931 2
			    options.pubkey_key_types,
			    strlen(options.pubkey_key_types), 0) == 1 &&
d943 1
a943 2
			    options.hostbased_key_types,
			    strlen(options.hostbased_key_types), 0) == 1 &&
@


1.147
log
@fix compilation with OPENSSL=no; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.146 2015/04/17 04:32:31 djm Exp $ */
d900 1
a900 1
	u_int bloblen;
d910 1
d933 2
a934 1
			    user_key_allowed(authctxt->pw, key);
d937 2
a938 1
			if (options.pubkey_authentication && allowed != 1)
@


1.146
log
@don't call record_login() in monitor when UseLogin is enabled;
bz#278 reported by drk AT sgi.com; ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.145 2015/02/20 22:17:21 djm Exp $ */
d1521 1
d1527 1
@


1.145
log
@UpdateHostKeys fixes:

I accidentally changed the format of the hostkeys@@openssh.com messages
last week without changing the extension name, and this has been causing
connection failures for people who are running -current. First reported
by sthen@@

s/hostkeys@@openssh.com/hostkeys-00@@openssh.com/
Change the name of the proof message too, and reorder it a little.

Also, UpdateHostKeys=ask is incompatible with ControlPersist (no TTY
available to read the response) so disable UpdateHostKeys if it is in
ask mode and ControlPersist is active (and document this)
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.144 2015/02/16 22:13:32 djm Exp $ */
d1188 3
@


1.144
log
@Revise hostkeys@@openssh.com hostkey learning extension.

The client will not ask the server to prove ownership of the private
halves of any hitherto-unseen hostkeys it offers to the client.

Allow UpdateHostKeys option to take an 'ask' argument to let the
user manually review keys offered.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.143 2015/02/13 18:57:00 markus Exp $ */
d602 1
a602 1
	const char proof_req[] = "hostkeys-prove@@openssh.com";
d632 2
a633 1
		if ((r = sshbuf_put_string(sigbuf, session_id2,
a634 1
		    (r = sshbuf_put_cstring(sigbuf, proof_req)) != 0 ||
@


1.143
log
@make rekey_limit for sshd w/privsep work; ok djm@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.142 2015/02/06 23:21:59 millert Exp $ */
d594 1
d597 1
d601 2
a602 1
	int r, keyid;
d613 7
d621 24
a644 2
	if (datlen != 20 && datlen != 32 && datlen != 48 && datlen != 64)
		fatal("%s: data length incorrect: %zu", __func__, datlen);
d658 1
a658 1
	} else if ((key = get_hostkey_public_by_index(keyid, active_state)) != NULL &&
d668 2
a669 1
	debug3("%s: signature %p(%zu)", __func__, signature, siglen);
@


1.142
log
@SIZE_MAX is standard, we should be using it in preference to the
obsolete SIZE_T_MAX.  OK miod@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.141 2015/01/20 23:14:00 deraadt Exp $ */
a1502 5

	if (options.rekey_limit || options.rekey_interval)
		ssh_packet_set_rekey_limits(ssh,
		    (u_int32_t)options.rekey_limit,
		    (time_t)options.rekey_interval);
@


1.141
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.140 2015/01/19 20:16:15 markus Exp $ */
d45 1
a48 1
#include <limits.h>
d397 1
a397 1
	if (len == 0 || ncount > SIZE_T_MAX / size)
@


1.140
log
@adapt kex to sshbuf and struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.139 2015/01/19 19:52:16 markus Exp $ */
a31 1
#include <sys/param.h>
d48 1
@


1.139
log
@update packet.c & isolate, introduce struct ssh
a) switch packet.c to buffer api and isolate per-connection info into struct ssh
b) (de)serialization of the state is moved from monitor to packet.c
c) the old packet.c API is implemented in opacket.[ch]
d) compress.c/h is removed and integrated into packet.c
with and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.138 2015/01/14 20:05:27 djm Exp $ */
d626 1
a626 1
	} else if ((key = get_hostkey_public_by_index(keyid)) != NULL &&
@


1.138
log
@move authfd.c and its tentacles to the new buffer/key API;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.137 2015/01/13 07:39:19 djm Exp $ */
a91 3
extern Newkeys *current_keys[];
extern z_stream incoming_stream;
extern z_stream outgoing_stream;
d98 1
a98 23

struct {
	z_stream incoming;
	z_stream outgoing;
	u_char *keyin;
	u_int keyinlen;
	u_char *keyout;
	u_int keyoutlen;
	u_char *ivin;
	u_int ivinlen;
	u_char *ivout;
	u_int ivoutlen;
	u_char *ssh1key;
	u_int ssh1keylen;
	int ssh1cipher;
	int ssh1protoflags;
	u_char *input;
	u_int ilen;
	u_char *output;
	u_int olen;
	u_int64_t sent_bytes;
	u_int64_t recv_bytes;
} child_state;
d390 21
d1473 23
a1495 27
	if (compat20) {
		set_newkeys(MODE_IN);
		set_newkeys(MODE_OUT);
	} else {
		packet_set_protocol_flags(child_state.ssh1protoflags);
		packet_set_encryption_key(child_state.ssh1key,
		    child_state.ssh1keylen, child_state.ssh1cipher);
		free(child_state.ssh1key);
	}

	/* for rc4 and other stateful ciphers */
	packet_set_keycontext(MODE_OUT, child_state.keyout);
	free(child_state.keyout);
	packet_set_keycontext(MODE_IN, child_state.keyin);
	free(child_state.keyin);

	if (!compat20) {
		packet_set_iv(MODE_OUT, child_state.ivout);
		free(child_state.ivout);
		packet_set_iv(MODE_IN, child_state.ivin);
		free(child_state.ivin);
	}

	memcpy(&incoming_stream, &child_state.incoming,
	    sizeof(incoming_stream));
	memcpy(&outgoing_stream, &child_state.outgoing,
	    sizeof(outgoing_stream));
d1498 5
a1502 4
	if (options.compression)
		mm_init_compression(pmonitor->m_zlib);

	packet_set_postauth();
d1505 2
a1506 1
		packet_set_rekey_limits((u_int32_t)options.rekey_limit,
a1507 62

	/* Network I/O buffers */
	/* XXX inefficient for large buffers, need: buffer_init_from_string */
	buffer_clear(packet_get_input());
	buffer_append(packet_get_input(), child_state.input, child_state.ilen);
	explicit_bzero(child_state.input, child_state.ilen);
	free(child_state.input);

	buffer_clear(packet_get_output());
	buffer_append(packet_get_output(), child_state.output,
		      child_state.olen);
	explicit_bzero(child_state.output, child_state.olen);
	free(child_state.output);

	/* Roaming */
	if (compat20)
		roam_set_bytes(child_state.sent_bytes, child_state.recv_bytes);
}

static Kex *
mm_get_kex(Buffer *m)
{
	Kex *kex;
	void *blob;
	u_int bloblen;

	kex = xcalloc(1, sizeof(*kex));
	kex->session_id = buffer_get_string(m, &kex->session_id_len);
	if (session_id2 == NULL ||
	    kex->session_id_len != session_id2_len ||
	    timingsafe_bcmp(kex->session_id, session_id2, session_id2_len) != 0)
		fatal("mm_get_get: internal error: bad session id");
	kex->we_need = buffer_get_int(m);
#ifdef WITH_OPENSSL
	kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;
	kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;
	kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;
	kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;
	kex->kex[KEX_ECDH_SHA2] = kexecdh_server;
#endif
	kex->kex[KEX_C25519_SHA256] = kexc25519_server;
	kex->server = 1;
	kex->hostkey_type = buffer_get_int(m);
	kex->kex_type = buffer_get_int(m);
	blob = buffer_get_string(m, &bloblen);
	buffer_init(&kex->my);
	buffer_append(&kex->my, blob, bloblen);
	free(blob);
	blob = buffer_get_string(m, &bloblen);
	buffer_init(&kex->peer);
	buffer_append(&kex->peer, blob, bloblen);
	free(blob);
	kex->done = 1;
	kex->flags = buffer_get_int(m);
	kex->client_version_string = buffer_get_string(m, NULL);
	kex->server_version_string = buffer_get_string(m, NULL);
	kex->load_host_public_key=&get_hostkey_public_by_type;
	kex->load_host_private_key=&get_hostkey_private_by_type;
	kex->host_key_index=&get_hostkey_index;
	kex->sign = sshd_hostkey_sign;

	return (kex);
a1514 6
	Buffer m;
	u_char *blob, *p;
	u_int bloblen, plen;
	u_int32_t seqnr, packets;
	u_int64_t blocks, bytes;

d1517 5
a1521 68
	buffer_init(&m);
	mm_request_receive_expect(pmonitor->m_sendfd, MONITOR_REQ_KEYEXPORT, &m);
	if (!compat20) {
		child_state.ssh1protoflags = buffer_get_int(&m);
		child_state.ssh1cipher = buffer_get_int(&m);
		child_state.ssh1key = buffer_get_string(&m,
		    &child_state.ssh1keylen);
		child_state.ivout = buffer_get_string(&m,
		    &child_state.ivoutlen);
		child_state.ivin = buffer_get_string(&m, &child_state.ivinlen);
		goto skip;
	} else {
		/* Get the Kex for rekeying */
		*pmonitor->m_pkex = mm_get_kex(&m);
	}

	blob = buffer_get_string(&m, &bloblen);
	current_keys[MODE_OUT] = mm_newkeys_from_blob(blob, bloblen);
	free(blob);

	debug3("%s: Waiting for second key", __func__);
	blob = buffer_get_string(&m, &bloblen);
	current_keys[MODE_IN] = mm_newkeys_from_blob(blob, bloblen);
	free(blob);

	/* Now get sequence numbers for the packets */
	seqnr = buffer_get_int(&m);
	blocks = buffer_get_int64(&m);
	packets = buffer_get_int(&m);
	bytes = buffer_get_int64(&m);
	packet_set_state(MODE_OUT, seqnr, blocks, packets, bytes);
	seqnr = buffer_get_int(&m);
	blocks = buffer_get_int64(&m);
	packets = buffer_get_int(&m);
	bytes = buffer_get_int64(&m);
	packet_set_state(MODE_IN, seqnr, blocks, packets, bytes);

 skip:
	/* Get the key context */
	child_state.keyout = buffer_get_string(&m, &child_state.keyoutlen);
	child_state.keyin  = buffer_get_string(&m, &child_state.keyinlen);

	debug3("%s: Getting compression state", __func__);
	/* Get compression state */
	p = buffer_get_string(&m, &plen);
	if (plen != sizeof(child_state.outgoing))
		fatal("%s: bad request size", __func__);
	memcpy(&child_state.outgoing, p, sizeof(child_state.outgoing));
	free(p);

	p = buffer_get_string(&m, &plen);
	if (plen != sizeof(child_state.incoming))
		fatal("%s: bad request size", __func__);
	memcpy(&child_state.incoming, p, sizeof(child_state.incoming));
	free(p);

	/* Network I/O buffers */
	debug3("%s: Getting Network I/O buffers", __func__);
	child_state.input = buffer_get_string(&m, &child_state.ilen);
	child_state.output = buffer_get_string(&m, &child_state.olen);

	/* Roaming */
	if (compat20) {
		child_state.sent_bytes = buffer_get_int64(&m);
		child_state.recv_bytes = buffer_get_int64(&m);
	}

	buffer_free(&m);
a1524 33
/* Allocation functions for zlib */
void *
mm_zalloc(struct mm_master *mm, u_int ncount, u_int size)
{
	size_t len = (size_t) size * ncount;
	void *address;

	if (len == 0 || ncount > SIZE_T_MAX / size)
		fatal("%s: mm_zalloc(%u, %u)", __func__, ncount, size);

	address = mm_malloc(mm, len);

	return (address);
}

void
mm_zfree(struct mm_master *mm, void *address)
{
	mm_free(mm, address);
}

void
mm_init_compression(struct mm_master *mm)
{
	outgoing_stream.zalloc = (alloc_func)mm_zalloc;
	outgoing_stream.zfree = (free_func)mm_zfree;
	outgoing_stream.opaque = mm;

	incoming_stream.zalloc = (alloc_func)mm_zalloc;
	incoming_stream.zfree = (free_func)mm_zfree;
	incoming_stream.opaque = mm;
}

d1560 1
d1573 3
a1575 1
		mm_init_compression(mon->m_zlib);
@


1.137
log
@add sshd_config HostbasedAcceptedKeyTypes and PubkeyAcceptedKeyTypes
options to allow sshd to control what public key types will be
accepted. Currently defaults to all. Feedback & ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.136 2014/12/22 07:51:30 djm Exp $ */
d83 1
a594 2
extern AuthenticationConnection *auth_conn;

d598 2
a599 1
	Key *key;
d602 2
a603 2
	u_int siglen, datlen;
	int keyid;
d607 3
a609 2
	keyid = buffer_get_int(m);
	p = buffer_get_string(m, &datlen);
d616 1
a616 1
		fatal("%s: data length incorrect: %u", __func__, datlen);
d626 4
a629 2
		if (key_sign(key, &signature, &siglen, p, datlen) < 0)
			fatal("%s: key_sign failed", __func__);
d631 6
a636 4
	    auth_conn != NULL) {
		if (ssh_agent_sign(auth_conn, key, &signature, &siglen, p,
		    datlen) < 0)
			fatal("%s: ssh_agent_sign failed", __func__);
d640 1
a640 1
	debug3("%s: signature %p(%u)", __func__, signature, siglen);
d642 3
a644 2
	buffer_clear(m);
	buffer_put_string(m, signature, siglen);
@


1.136
log
@remember which public keys have been used for authentication and
refuse to accept previously-used keys.

This allows AuthenticationMethods=publickey,publickey to require
that users authenticate using two _different_ pubkeys.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.135 2014/07/15 15:54:14 millert Exp $ */
d82 1
d885 5
d894 3
d905 3
@


1.135
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.134 2014/06/24 01:13:21 djm Exp $ */
d887 1
d1115 6
a1120 1
	key_free(key);
@


1.134
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.133 2014/05/03 17:20:34 markus Exp $ */
d69 1
a77 1
#include "misc.h"
@


1.133
log
@unbreak compression, by re-init-ing the compression code in the
post-auth child. the new buffer code is more strict, and requires
buffer_init() while the old code was happy after a bzero();
originally from djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.132 2014/04/29 18:01:49 markus Exp $ */
d45 2
@


1.132
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.131 2014/02/02 03:44:31 djm Exp $ */
d1482 2
@


1.131
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.130 2014/01/31 16:39:19 tedu Exp $ */
d35 1
d37 1
d154 2
d157 1
d187 1
d189 1
d209 1
d211 1
d220 1
d231 1
d236 1
d240 1
d554 1
d589 1
d900 1
d910 1
d1247 1
d1425 1
d1519 1
d1525 1
@


1.130
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.129 2014/01/29 06:18:35 djm Exp $ */
d761 1
a761 1
	memset(passwd, 0, strlen(passwd));
d1472 1
a1472 1
	memset(child_state.input, 0, child_state.ilen);
d1478 1
a1478 1
	memset(child_state.output, 0, child_state.olen);
@


1.129
log
@remove experimental, never-enabled JPAKE code; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.128 2013/11/04 11:51:16 markus Exp $ */
d455 1
a455 1
		bzero(&pfd, sizeof(pfd));
@


1.128
log
@fix rekeying for KEX_C25519_SHA256; noted by dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.127 2013/07/19 07:37:48 markus Exp $ */
a75 1
#include "jpake.h"
a140 5
int mm_answer_jpake_get_pwdata(int, Buffer *);
int mm_answer_jpake_step1(int, Buffer *);
int mm_answer_jpake_step2(int, Buffer *);
int mm_answer_jpake_key_confirm(int, Buffer *);
int mm_answer_jpake_check_confirm(int, Buffer *);
a197 7
#ifdef JPAKE
    {MONITOR_REQ_JPAKE_GET_PWDATA, MON_ONCE, mm_answer_jpake_get_pwdata},
    {MONITOR_REQ_JPAKE_STEP1, MON_ISAUTH, mm_answer_jpake_step1},
    {MONITOR_REQ_JPAKE_STEP2, MON_ONCE, mm_answer_jpake_step2},
    {MONITOR_REQ_JPAKE_KEY_CONFIRM, MON_ONCE, mm_answer_jpake_key_confirm},
    {MONITOR_REQ_JPAKE_CHECK_CONFIRM, MON_AUTH, mm_answer_jpake_check_confirm},
#endif
a324 9
#ifdef JPAKE
		/* Cleanup JPAKE context after authentication */
		if (ent->flags & MON_AUTHDECIDE) {
			if (authctxt->jpake_ctx != NULL) {
				jpake_free(authctxt->jpake_ctx);
				authctxt->jpake_ctx = NULL;
			}
		}
#endif
a1808 202
#ifdef JPAKE
int
mm_answer_jpake_step1(int sock, Buffer *m)
{
	struct jpake_ctx *pctx;
	u_char *x3_proof, *x4_proof;
	u_int x3_proof_len, x4_proof_len;

	if (!options.zero_knowledge_password_authentication)
		fatal("zero_knowledge_password_authentication disabled");

	if (authctxt->jpake_ctx != NULL)
		fatal("%s: authctxt->jpake_ctx already set (%p)",
		    __func__, authctxt->jpake_ctx);
	authctxt->jpake_ctx = pctx = jpake_new();

	jpake_step1(pctx->grp,
	    &pctx->server_id, &pctx->server_id_len,
	    &pctx->x3, &pctx->x4, &pctx->g_x3, &pctx->g_x4,
	    &x3_proof, &x3_proof_len,
	    &x4_proof, &x4_proof_len);

	JPAKE_DEBUG_CTX((pctx, "step1 done in %s", __func__));

	buffer_clear(m);

	buffer_put_string(m, pctx->server_id, pctx->server_id_len);
	buffer_put_bignum2(m, pctx->g_x3);
	buffer_put_bignum2(m, pctx->g_x4);
	buffer_put_string(m, x3_proof, x3_proof_len);
	buffer_put_string(m, x4_proof, x4_proof_len);

	debug3("%s: sending step1", __func__);
	mm_request_send(sock, MONITOR_ANS_JPAKE_STEP1, m);

	bzero(x3_proof, x3_proof_len);
	bzero(x4_proof, x4_proof_len);
	free(x3_proof);
	free(x4_proof);

	monitor_permit(mon_dispatch, MONITOR_REQ_JPAKE_GET_PWDATA, 1);
	monitor_permit(mon_dispatch, MONITOR_REQ_JPAKE_STEP1, 0);

	return 0;
}

int
mm_answer_jpake_get_pwdata(int sock, Buffer *m)
{
	struct jpake_ctx *pctx = authctxt->jpake_ctx;
	char *hash_scheme, *salt;

	if (pctx == NULL)
		fatal("%s: pctx == NULL", __func__);

	auth2_jpake_get_pwdata(authctxt, &pctx->s, &hash_scheme, &salt);

	buffer_clear(m);
	/* pctx->s is sensitive, not returned to slave */
	buffer_put_cstring(m, hash_scheme);
	buffer_put_cstring(m, salt);

	debug3("%s: sending pwdata", __func__);
	mm_request_send(sock, MONITOR_ANS_JPAKE_GET_PWDATA, m);

	bzero(hash_scheme, strlen(hash_scheme));
	bzero(salt, strlen(salt));
	free(hash_scheme);
	free(salt);

	monitor_permit(mon_dispatch, MONITOR_REQ_JPAKE_STEP2, 1);

	return 0;
}

int
mm_answer_jpake_step2(int sock, Buffer *m)
{
	struct jpake_ctx *pctx = authctxt->jpake_ctx;
	u_char *x1_proof, *x2_proof, *x4_s_proof;
	u_int x1_proof_len, x2_proof_len, x4_s_proof_len;

	if (pctx == NULL)
		fatal("%s: pctx == NULL", __func__);

	if ((pctx->g_x1 = BN_new()) == NULL ||
	    (pctx->g_x2 = BN_new()) == NULL)
		fatal("%s: BN_new", __func__);
	buffer_get_bignum2(m, pctx->g_x1);
	buffer_get_bignum2(m, pctx->g_x2);
	pctx->client_id = buffer_get_string(m, &pctx->client_id_len);
	x1_proof = buffer_get_string(m, &x1_proof_len);
	x2_proof = buffer_get_string(m, &x2_proof_len);

	jpake_step2(pctx->grp, pctx->s, pctx->g_x3,
	    pctx->g_x1, pctx->g_x2, pctx->x4,
	    pctx->client_id, pctx->client_id_len,
	    pctx->server_id, pctx->server_id_len,
	    x1_proof, x1_proof_len,
	    x2_proof, x2_proof_len,
	    &pctx->b,
	    &x4_s_proof, &x4_s_proof_len);

	JPAKE_DEBUG_CTX((pctx, "step2 done in %s", __func__));

	bzero(x1_proof, x1_proof_len);
	bzero(x2_proof, x2_proof_len);
	free(x1_proof);
	free(x2_proof);

	buffer_clear(m);

	buffer_put_bignum2(m, pctx->b);
	buffer_put_string(m, x4_s_proof, x4_s_proof_len);

	debug3("%s: sending step2", __func__);
	mm_request_send(sock, MONITOR_ANS_JPAKE_STEP2, m);

	bzero(x4_s_proof, x4_s_proof_len);
	free(x4_s_proof);

	monitor_permit(mon_dispatch, MONITOR_REQ_JPAKE_KEY_CONFIRM, 1);

	return 0;
}

int
mm_answer_jpake_key_confirm(int sock, Buffer *m)
{
	struct jpake_ctx *pctx = authctxt->jpake_ctx;
	u_char *x2_s_proof;
	u_int x2_s_proof_len;

	if (pctx == NULL)
		fatal("%s: pctx == NULL", __func__);

	if ((pctx->a = BN_new()) == NULL)
		fatal("%s: BN_new", __func__);
	buffer_get_bignum2(m, pctx->a);
	x2_s_proof = buffer_get_string(m, &x2_s_proof_len);

	jpake_key_confirm(pctx->grp, pctx->s, pctx->a,
	    pctx->x4, pctx->g_x3, pctx->g_x4, pctx->g_x1, pctx->g_x2,
	    pctx->server_id, pctx->server_id_len,
	    pctx->client_id, pctx->client_id_len,
	    session_id2, session_id2_len,
	    x2_s_proof, x2_s_proof_len,
	    &pctx->k,
	    &pctx->h_k_sid_sessid, &pctx->h_k_sid_sessid_len);

	JPAKE_DEBUG_CTX((pctx, "key_confirm done in %s", __func__));

	bzero(x2_s_proof, x2_s_proof_len);
	buffer_clear(m);

	/* pctx->k is sensitive, not sent */
	buffer_put_string(m, pctx->h_k_sid_sessid, pctx->h_k_sid_sessid_len);

	debug3("%s: sending confirmation hash", __func__);
	mm_request_send(sock, MONITOR_ANS_JPAKE_KEY_CONFIRM, m);

	monitor_permit(mon_dispatch, MONITOR_REQ_JPAKE_CHECK_CONFIRM, 1);

	return 0;
}

int
mm_answer_jpake_check_confirm(int sock, Buffer *m)
{
	int authenticated = 0;
	u_char *peer_confirm_hash;
	u_int peer_confirm_hash_len;
	struct jpake_ctx *pctx = authctxt->jpake_ctx;

	if (pctx == NULL)
		fatal("%s: pctx == NULL", __func__);

	peer_confirm_hash = buffer_get_string(m, &peer_confirm_hash_len);

	authenticated = jpake_check_confirm(pctx->k,
	    pctx->client_id, pctx->client_id_len,
	    session_id2, session_id2_len,
	    peer_confirm_hash, peer_confirm_hash_len) && authctxt->valid;

	JPAKE_DEBUG_CTX((pctx, "check_confirm done in %s", __func__));

	bzero(peer_confirm_hash, peer_confirm_hash_len);
	free(peer_confirm_hash);

	buffer_clear(m);
	buffer_put_int(m, authenticated);

	debug3("%s: sending result %d", __func__, authenticated);
	mm_request_send(sock, MONITOR_ANS_JPAKE_CHECK_CONFIRM, m);

	monitor_permit(mon_dispatch, MONITOR_REQ_JPAKE_STEP1, 1);

	auth_method = "jpake-01@@openssh.com";
	return authenticated;
}

#endif /* JPAKE */
@


1.127
log
@add ssh-agent(1) support to sshd(8); allows encrypted hostkeys,
or hostkeys on smartcards; most of the work by Zev Weiss; bz #1974
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.126 2013/06/21 00:34:49 djm Exp $ */
d1527 1
@


1.126
log
@for hostbased authentication, print the client host and user on
the auth success/failure line; bz#2064, ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.125 2013/05/19 02:42:42 djm Exp $ */
d78 1
d598 2
d628 9
a636 1
	if ((key = get_hostkey_by_index(keyid)) == NULL)
a637 2
	if (key_sign(key, &signature, &siglen, p, datlen) < 0)
		fatal("%s: key_sign failed", __func__);
d1545 1
@


1.125
log
@Standardise logging of supplemental information during userauth. Keys
and ruser is now logged in the auth success/failure message alongside
the local username, remote host/port and protocol in use. Certificates
contents and CA are logged too.

Pushing all logging onto a single line simplifies log analysis as it is
no longer necessary to relate information scattered across multiple log
entries. "I like it" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.124 2013/05/17 00:13:13 djm Exp $ */
d884 1
a884 1
			pubkey_auth_info(authctxt, key);
d893 3
@


1.124
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.123 2013/05/16 04:09:13 dtucker Exp $ */
d333 1
a333 2
			    auth_method, auth_submethod,
			    compat20 ? " ssh2" : "");
d884 1
d924 1
a924 2
		auth_log(authctxt, 0, 0, auth_method, NULL,
		    compat20 ? " ssh2" : "");
@


1.123
log
@Add RekeyLimit to sshd with the same syntax as the client allowing rekeying
based on traffic volume or time.  ok djm@@, help & ok jmc@@ for the man page.
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.122 2013/03/07 19:27:25 markus Exp $ */
d462 1
a462 1
	xfree(msg);
d553 3
a555 6
	if (key_blob != NULL)
		xfree(key_blob);
	if (hostbased_cuser != NULL)
		xfree(hostbased_cuser);
	if (hostbased_chost != NULL)
		xfree(hostbased_chost);
d636 2
a637 2
	xfree(p);
	xfree(signature);
d668 1
a668 1
	xfree(username);
d740 1
a740 3

	if (banner != NULL)
		xfree(banner);
d756 1
a756 1
		xfree(authctxt->style);
d776 1
a776 1
	xfree(passwd);
d815 4
a818 4
		xfree(name);
		xfree(infotxt);
		xfree(prompts);
		xfree(echo_on);
d838 1
a838 1
	xfree(response);
d926 3
a928 3
		xfree(blob);
		xfree(cuser);
		xfree(chost);
d971 1
a971 1
		xfree(p);
d984 2
a985 2
	xfree(userstyle);
	xfree(p);
d994 1
a994 1
		xfree(p);
d1023 1
a1023 1
	xfree(p);
d1037 1
a1037 1
	xfree(p);
d1042 1
a1042 1
	xfree(p);
d1052 1
a1052 1
	xfree(p);
d1058 1
a1058 1
	xfree(p);
d1107 3
a1109 3
	xfree(blob);
	xfree(signature);
	xfree(data);
d1237 1
a1237 1
	xfree(tty);
d1369 1
a1369 1
	xfree(blob);
d1401 1
a1401 1
	xfree(blob);
d1403 1
a1403 1
	xfree(response);
d1450 1
a1450 1
		xfree(child_state.ssh1key);
d1455 1
a1455 1
	xfree(child_state.keyout);
d1457 1
a1457 1
	xfree(child_state.keyin);
d1461 1
a1461 1
		xfree(child_state.ivout);
d1463 1
a1463 1
		xfree(child_state.ivin);
d1484 1
a1484 1
	xfree(child_state.input);
d1490 1
a1490 1
	xfree(child_state.output);
d1522 1
a1522 1
	xfree(blob);
d1526 1
a1526 1
	xfree(blob);
d1569 1
a1569 1
	xfree(blob);
d1574 1
a1574 1
	xfree(blob);
d1599 1
a1599 1
	xfree(p);
d1605 1
a1605 1
	xfree(p);
d1727 1
a1727 1
	xfree(goid.elements);
d1752 1
a1752 1
	xfree(in.value);
d1784 2
a1785 2
	xfree(gssbuf.value);
	xfree(mic.value);
d1855 2
a1856 2
	xfree(x3_proof);
	xfree(x4_proof);
d1885 2
a1886 2
	xfree(hash_scheme);
	xfree(salt);
d1925 2
a1926 2
	xfree(x1_proof);
	xfree(x2_proof);
d1937 1
a1937 1
	xfree(x4_s_proof);
d2005 1
a2005 1
	xfree(peer_confirm_hash);
@


1.122
log
@add submethod support to AuthenticationMethods; ok and freedback djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.121 2013/03/07 00:19:59 djm Exp $ */
d1479 4
@


1.121
log
@reconstruct the original username that was sent by the client, which may
have included a style (e.g. "root:skey") when checking public key
signatures. Fixes public key and hostbased auth when the client specified
a style; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.120 2012/12/11 22:16:21 markus Exp $ */
d315 1
a315 1
			    auth_method)) {
d851 4
a854 3
	if (compat20)
		auth_method = "keyboard-interactive"; /* XXX auth_submethod */
	else
@


1.120
log
@drain the log messages after receiving the keystate from the unpriv
child. otherwise it might block while sending. ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.119 2012/12/02 20:34:10 djm Exp $ */
d954 1
a954 1
	char *p;
d979 5
a983 2
	p = buffer_get_string(&b, NULL);
	if (strcmp(authctxt->user, p) != 0) {
d985 1
a985 1
		    authctxt->user, p);
d988 1
d995 1
a995 1
		p = buffer_get_string(&b, NULL);
d1015 1
a1015 1
	char *p;
d1031 5
a1035 2
	p = buffer_get_string(&b, NULL);
	if (strcmp(authctxt->user, p) != 0) {
d1037 1
a1037 1
		    authctxt->user, p);
d1040 1
d1043 1
a1043 1
	p = buffer_get_string(&b, NULL);
@


1.119
log
@Fixes logging of partial authentication when privsep is enabled
Previously, we recorded "Failed xxx" since we reset authenticated before
calling auth_log() in auth2.c. This adds an explcit "Partial" state.

Add a "submethod" to auth_log() to report which submethod is used
for keyboard-interactive.

Fix multiple authentication when one of the methods is
keyboard-interactive.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.118 2012/11/04 11:09:15 djm Exp $ */
a348 4
	/* Drain any buffered messages from the child */
	while (pmonitor->m_log_recvfd != -1 && monitor_read_log(pmonitor) == 0)
		;

d358 4
@


1.118
log
@Support multiple required authentication via an AuthenticationMethods
option. This option lists one or more comma-separated lists of
authentication method names. Successful completion of all the methods in
any list is required for authentication to complete;
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.117 2012/06/22 12:30:26 dtucker Exp $ */
d166 1
d278 1
a278 1
	int authenticated = 0;
d303 1
d305 1
d319 1
d332 2
a333 1
			auth_log(authctxt, authenticated, auth_method,
d852 1
a852 1
		auth_method = "keyboard-interactive";
d928 2
a929 1
		auth_log(authctxt, 0, auth_method, compat20 ? " ssh2" : "");
@


1.117
log
@remove dead code following 'for (;;)' loops.
From Steve.McClellan at radisys com, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.116 2012/01/05 00:16:56 djm Exp $ */
d304 15
a326 1

d704 11
a714 1
	
d846 4
a849 1
	auth_method = "bsdauth";
@


1.116
log
@memleak on error path
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.115 2011/06/23 23:35:42 djm Exp $ */
a389 3

	close(pmonitor->m_sendfd);
	pmonitor->m_sendfd = -1;
@


1.115
log
@ignore EINTR errors from poll()
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.114 2011/06/17 21:44:30 djm Exp $ */
d418 1
@


1.114
log
@make the pre-auth privsep slave log via a socketpair shared with the
monitor rather than /var/empty/dev/log; ok dtucker@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.113 2011/05/23 03:30:07 djm Exp $ */
d465 3
a467 1
		if (poll(pfd, pfd[1].fd == -1 ? 1 : 2, -1) == -1)
d469 1
@


1.113
log
@allow AuthorizedKeysFile to specify multiple files, separated by spaces.
Bring back authorized_keys2 as a default search path (to avoid breaking
existing users of this file), but override this in sshd_config so it will
be no longer used on fresh installs. Maybe in 2015 we can remove it
entierly :)

feedback and ok markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.112 2011/05/20 03:25:45 djm Exp $ */
d40 1
d46 1
a46 1

d154 2
d281 4
d330 4
d343 4
d364 3
d390 3
d404 46
d457 21
d1621 1
a1621 1
monitor_socketpair(int *pair)
d1623 2
d1626 1
a1626 1
		fatal("%s: socketpair", __func__);
d1629 12
a1648 1
	int pair[2];
d1652 1
a1652 4
	monitor_socketpair(pair);

	mon->m_recvfd = pair[0];
	mon->m_sendfd = pair[1];
d1669 1
a1669 6
	int pair[2];

	monitor_socketpair(pair);

	mon->m_recvfd = pair[0];
	mon->m_sendfd = pair[1];
@


1.112
log
@use a macro to define which string options to copy between configs
for Match. This avoids problems caused by forgetting to keep three
code locations in perfect sync and ordering

"this is at once beautiful and horrible" + ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.111 2011/05/15 08:09:01 djm Exp $ */
d550 1
d593 4
d600 1
a612 1

@


1.111
log
@use FD_CLOEXEC consistently; patch from zion AT x96.org
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.110 2010/09/09 10:45:45 djm Exp $ */
d587 9
a595 2
	if (options.banner != NULL)
		buffer_put_cstring(m, options.banner);
@


1.110
log
@ECDH/ECDSA compliance fix: these methods vary the hash function they use
(SHA256/384/512) depending on the length of the curve in use. The previous
code incorrectly used SHA256 in all cases.

This fix will cause authentication failure when using 384 or 521-bit curve
keys if one peer hasn't been upgraded and the other has. (256-bit curve
keys work ok). In particular you may need to specify HostkeyAlgorithms
when connecting to a server that has not been upgraded from an upgraded
client.

ok naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.109 2010/08/31 11:54:45 djm Exp $ */
d1516 1
a1516 1
	if (fcntl(x, F_SETFD, 1) == -1) \
@


1.109
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.108 2010/07/13 23:13:16 djm Exp $ */
d508 2
a509 2
	 * Supported KEX types will only return SHA1 (20 byte) or
	 * SHA256 (32 byte) hashes
d511 1
a511 1
	if (datlen != 20 && datlen != 32)
@


1.108
log
@s/timing_safe_cmp/timingsafe_bcmp/g
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.107 2010/07/13 11:52:06 djm Exp $ */
d1373 1
@


1.107
log
@implement a timing_safe_cmp() function to compare memory without leaking
timing information by short-circuiting like memcmp() and use it for
some of the more sensitive comparisons (though nothing high-value was
readily attackable anyway); "looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.106 2010/03/07 11:57:13 dtucker Exp $ */
d436 1
a436 1
	    timing_safe_cmp(key_blob, blob, key_bloblen))
d832 1
a832 1
		    (timing_safe_cmp(p, session_id2, session_id2_len) != 0))
d839 1
a839 1
		    (timing_safe_cmp(p, session_id2, session_id2_len) != 0))
d887 1
a887 1
	    (timing_safe_cmp(p, session_id2, session_id2_len) != 0))
d1366 1
a1366 1
	    timing_safe_cmp(kex->session_id, session_id2, session_id2_len) != 0)
@


1.106
log
@Hold authentication debug messages until after successful authentication.
Fixes an info leak of environment variables specified in authorized_keys,
reported by Jacob Appelbaum.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.105 2010/02/26 20:29:54 djm Exp $ */
d436 1
a436 1
	    memcmp(key_blob, blob, key_bloblen))
d832 1
a832 1
		    (memcmp(p, session_id2, session_id2_len) != 0))
d839 1
a839 1
		    (memcmp(p, session_id2, session_id2_len) != 0))
d887 1
a887 1
	    (memcmp(p, session_id2, session_id2_len) != 0))
d1364 3
a1366 3
	if ((session_id2 == NULL) ||
	    (kex->session_id_len != session_id2_len) ||
	    (memcmp(kex->session_id, session_id2, session_id2_len) != 0))
@


1.105
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.104 2009/06/12 20:43:22 andreas Exp $ */
a725 12

static void
mm_append_debug(Buffer *m)
{
	if (auth_debug_init && buffer_len(&auth_debug)) {
		debug3("%s: Appending debug messages for child", __func__);
		buffer_append(m, buffer_ptr(&auth_debug),
		    buffer_len(&auth_debug));
		buffer_clear(&auth_debug);
	}
}

a807 2
	mm_append_debug(m);

a1189 2

	mm_append_debug(m);
@


1.104
log
@Fix warnings found by chl@@ and djm@@ and change roaming_atomicio's
return type to match atomicio's
Diff from djm@@, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.103 2009/05/28 16:50:16 andreas Exp $ */
d1404 2
a1405 1
	kex->load_host_key=&get_hostkey_by_type;
@


1.103
log
@Keep track of number of bytes read and written. Needed for upcoming
changes. Most code from Martin Forssen, maf at appgate dot com.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.102 2009/05/25 06:48:01 andreas Exp $ */
d76 1
@


1.102
log
@Put the globals in packet.c into a struct and don't access it directly
from other files. No functional changes.
ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.101 2009/02/12 03:26:22 djm Exp $ */
d113 2
d1364 4
d1482 6
@


1.101
log
@some paranoia: check that the serialised key is really KEY_RSA before
diddling its internals
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.100 2008/11/04 08:22:13 djm Exp $ */
a87 1
extern Buffer input, output;
d1352 2
a1353 2
	buffer_clear(&input);
	buffer_append(&input, child_state.input, child_state.ilen);
d1357 3
a1359 2
	buffer_clear(&output);
	buffer_append(&output, child_state.output, child_state.olen);
@


1.100
log
@Add support for an experimental zero-knowledge password authentication
method using the J-PAKE protocol described in F. Hao, P. Ryan,
"Password Authenticated Key Exchange by Juggling", 16th Workshop on
Security Protocols, Cambridge, April 2008.

This method allows password-based authentication without exposing
the password to the server. Instead, the client and server exchange
cryptographic proofs to demonstrate of knowledge of the password while
revealing nothing useful to an attacker or compromised endpoint.

This is experimental, work-in-progress code and is presently
compiled-time disabled (turn on -DJPAKE in Makefile.inc).

"just commit it.  It isn't too intrusive." deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.99 2008/07/10 18:08:11 markus Exp $ */
d1230 3
a1232 1

@


1.99
log
@sync v1 and v2 traffic accounting; add it to sshd, too; ok djm@@, dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.98 2008/07/04 03:47:02 dtucker Exp $ */
d75 1
d138 5
d197 7
d310 9
d1669 203
@


1.98
log
@Make debug a little clearer.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.97 2008/06/13 13:56:59 dtucker Exp $ */
d1388 1
a1388 1
	u_int64_t blocks;
d1421 2
a1422 1
	packet_set_state(MODE_OUT, seqnr, blocks, packets);
d1426 2
a1427 1
	packet_set_state(MODE_IN, seqnr, blocks, packets);
@


1.97
log
@Clear key options in the monitor on failed authentication, prevents
applying additional restrictions to non-pubkey authentications in
the case where pubkey fails but another method subsequently succeeds.
bz #1472, found by Colin Watson, ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.96 2008/05/08 12:21:16 djm Exp $ */
d790 1
a790 1
	    __func__, key, allowed ? "allowed" : "disallowed");
@


1.96
log
@Make the maximum number of sessions run-time controllable via
a sshd_config MaxSessions knob. This is useful for disabling
login/shell/subsystem access while leaving port-forwarding working
(MaxSessions 0), disabling connection multiplexing (MaxSessions 1) or
simply increasing the number of allows multiplexed sessions.

Because some bozos are sure to configure MaxSessions in excess of the
number of available file descriptors in sshd (which, at peak, might be
as many as 9*MaxSessions), audit sshd to ensure that it doesn't leak fds
on error paths, and make it fail gracefully on out-of-fd conditions -
sending channel errors instead of than exiting with fatal().

bz#1090; MaxSessions config bits and manpage from junyer AT gmail.com

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.95 2008/05/08 12:02:23 djm Exp $ */
d745 2
d759 2
@


1.95
log
@Implement a channel success/failure status confirmation callback
mechanism. Each channel maintains a queue of callbacks, which will
be drained in order (RFC4253 guarantees confirm messages are not
reordered within an channel).

Also includes a abandonment callback to clean up if a channel is
closed without sending confirmation messages. This probably
shouldn't happen in compliant implementations, but it could be
abused to leak memory.

ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.94 2007/10/29 04:08:08 dtucker Exp $ */
d1003 1
a1003 1
	s->used = 0;
@


1.94
log
@Send config block back to slave for invalid users too so options
set by a Match block (eg Banner) behave the same for non-existent
users.  Found by and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.93 2007/09/21 08:15:29 djm Exp $ */
d33 1
@


1.93
log
@unifdef -DBSD_AUTH
unifdef -USKEY

These options have been in use for some years;
ok markus@@ "no objection" millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.92 2007/09/04 03:21:03 djm Exp $ */
d559 2
a563 2

 out:
@


1.92
log
@make file descriptor passing code return an error rather than call fatal()
when it encounters problems, and use this to make session multiplexing
masters survive slaves failing to pass all stdio FDs; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.91 2007/05/17 20:52:13 djm Exp $ */
a43 3
#ifdef SKEY
#include <skey.h>
#endif
a179 1
#ifdef BSD_AUTH
a181 5
#endif
#ifdef SKEY
    {MONITOR_REQ_SKEYQUERY, MON_ISAUTH, mm_answer_skeyquery},
    {MONITOR_REQ_SKEYRESPOND, MON_AUTH, mm_answer_skeyrespond},
#endif
a210 1
#ifdef BSD_AUTH
a212 5
#endif
#ifdef SKEY
    {MONITOR_REQ_SKEYQUERY, MON_ISAUTH, mm_answer_skeyquery},
    {MONITOR_REQ_SKEYRESPOND, MON_AUTH, mm_answer_skeyrespond},
#endif
a643 1
#ifdef BSD_AUTH
a699 22
#endif

#ifdef SKEY
int
mm_answer_skeyquery(int sock, Buffer *m)
{
	struct skey skey;
	char challenge[1024];
	u_int success;

	success = skeychallenge(&skey, authctxt->user, challenge) < 0 ? 0 : 1;

	buffer_clear(m);
	buffer_put_int(m, success);
	if (success)
		buffer_put_cstring(m, challenge);

	debug3("%s: sending challenge success: %u", __func__, success);
	mm_request_send(sock, MONITOR_ANS_SKEYQUERY, m);

	return (0);
}
a700 26
int
mm_answer_skeyrespond(int sock, Buffer *m)
{
	char *response;
	int authok;

	response = buffer_get_string(m, NULL);

	authok = (options.challenge_response_authentication &&
	    authctxt->valid &&
	    skey_haskey(authctxt->pw->pw_name) == 0 &&
	    skey_passcheck(authctxt->pw->pw_name, response) != -1);

	xfree(response);

	buffer_clear(m);
	buffer_put_int(m, authok);

	debug3("%s: sending authenticated: %d", __func__, authok);
	mm_request_send(sock, MONITOR_ANS_SKEYRESPOND, m);

	auth_method = "skey";

	return (authok != 0);
}
#endif
@


1.91
log
@pass received SIGINT from monitor to postauth child so it can clean
up properly. bz#1196, patch from senthilkumar_sen AT hotpop.com;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.90 2007/02/19 10:45:58 dtucker Exp $ */
d1108 3
a1110 2
	mm_send_fd(sock, s->ptyfd);
	mm_send_fd(sock, s->ttyfd);
@


1.90
log
@Teach Match how handle config directives that are used before authentication.
This allows configurations such as permitting password authentication from
the local net only while requiring pubkey from offsite.  ok djm@@, man page
bits ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.89 2006/11/07 10:31:31 markus Exp $ */
d342 1
@


1.89
log
@correctly check for bad signatures in the monitor, otherwise the monitor and
the unpriv process can get out of sync. with dtucker@@, ok djm@@, dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.88 2006/08/12 20:46:46 miod Exp $ */
d573 3
@


1.88
log
@Revert previous include file ordering change, for ssh to compile under gcc2
(or until openssl include files are cleaned of parameter names in function
prototypes)
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.87 2006/08/06 01:13:32 stevesk Exp $ */
d295 1
a295 1
		authenticated = monitor_read(pmonitor, mon_dispatch, &ent);
d1011 1
a1011 1
	    __func__, key, verified ? "verified" : "unverified");
d1026 1
a1026 1
	return (verified);
@


1.88.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.89 2006/11/07 10:31:31 markus Exp $ */
d295 1
a295 1
		authenticated = (monitor_read(pmonitor, mon_dispatch, &ent) == 1);
d1011 1
a1011 1
	    __func__, key, (verified == 1) ? "verified" : "unverified");
d1026 1
a1026 1
	return (verified == 1);
@


1.87
log
@"zlib.h" can be <zlib.h>; ok djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.86 2006/08/04 20:46:05 stevesk Exp $ */
a42 1
#include <zlib.h>
d57 1
@


1.86
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.85 2006/08/03 03:34:42 deraadt Exp $ */
d43 1
a57 1
#include "zlib.h"
@


1.85
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.84 2006/07/26 13:57:17 stevesk Exp $ */
d1059 1
a1059 1
		debug3("%s: tty %s ptyfd %d",  __func__, s->tty, s->ptyfd);
d1119 1
a1119 1
	debug3("%s: tty %s ptyfd %d",  __func__, s->tty, s->ttyfd);
@


1.84
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.83 2006/07/26 02:35:17 stevesk Exp $ */
a27 2
#include "includes.h"

d31 1
d48 1
d50 3
d54 1
d69 3
a73 1
#include "xmalloc.h"
a74 2
#include "buffer.h"
#include "bufaux.h"
a78 1
#include "ssh-gss.h"
@


1.83
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.82 2006/07/22 20:48:23 stevesk Exp $ */
d42 1
@


1.82
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.81 2006/07/11 20:07:25 stevesk Exp $ */
d33 1
@


1.81
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.80 2006/07/09 15:15:10 stevesk Exp $ */
d41 1
@


1.80
log
@move #include <fcntl.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.79 2006/07/08 21:48:53 stevesk Exp $ */
d36 1
@


1.79
log
@missed these from last commit:
move #include <sys/socket.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.78 2006/07/06 16:03:53 stevesk Exp $ */
d36 1
@


1.78
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.77 2006/03/30 11:40:21 dtucker Exp $ */
d32 1
@


1.77
log
@Prevent duplicate log messages when privsep=yes; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.76 2006/03/25 13:17:02 djm Exp $ */
d33 2
d36 1
a41 2

#include <openssl/dh.h>
@


1.76
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d160 1
d206 2
a207 2
    {MONITOR_REQ_RSAKEYALLOWED, MON_ISAUTH, mm_answer_rsa_keyallowed},
    {MONITOR_REQ_KEYALLOWED, MON_ISAUTH, mm_answer_keyallowed},
d284 1
d295 1
a295 1
		if (ent->flags & MON_AUTHDECIDE) {
d305 2
d793 1
d799 1
d806 1
d827 2
d1196 1
@


1.75
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.74
log
@spacing
@
text
@d1380 1
a1380 2
	kex = xmalloc(sizeof(*kex));
	memset(kex, 0, sizeof(*kex));
d1545 1
a1545 1
	mon = xmalloc(sizeof(*mon));
a1546 1
	mon->m_pid = 0;
@


1.73
log
@annoying spacing fixes getting in the way of real diffs
@
text
@d1023 1
a1023 1
			(struct sockaddr *)&from, &fromlen) < 0) {
@


1.72
log
@memory leaks detected by Coverity via elad AT netbsd.org;
deraadt@@ ok

that should be all of them now
@
text
@d1023 1
a1023 1
			(struct sockaddr *) & from, &fromlen) < 0) {
@


1.71
log
@spacing
@
text
@d818 4
@


1.70
log
@RCSID() can die
@
text
@d482 1
a482 1
	 * Supported KEX types will only return SHA1 (20 byte) or 
@


1.69
log
@Implement the diffie-hellman-group-exchange-sha256 key exchange method
using the SHA256 code in libc (and wrapper to make it into an OpenSSL
EVP), interop tested against CVS PuTTY
@
text
@a27 1
RCSID("$OpenBSD: monitor.c,v 1.68 2006/02/20 17:02:44 stevesk Exp $");
@


1.68
log
@move #include <signal.h> out of includes.h; ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.67 2006/02/10 01:44:26 stevesk Exp $");
d482 5
a486 1
	if (datlen != 20)
d1388 1
@


1.68.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: monitor.c,v 1.88 2006/08/12 20:46:46 miod Exp $ */
d27 3
a31 5
#include <sys/socket.h>
#include <sys/tree.h>
#include <sys/param.h>

#include <openssl/dh.h>
a32 2
#include <errno.h>
#include <fcntl.h>
a33 1
#include <pwd.h>
a34 2
#include <stdlib.h>
#include <string.h>
d40 2
a41 1
#include "xmalloc.h"
a42 3
#include "key.h"
#include "buffer.h"
#include "hostfile.h"
a43 1
#include "cipher.h"
d46 1
a46 1
#include <zlib.h>
a57 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
d60 1
d62 2
d68 1
a159 1
#define MON_ALOG	0x0020	/* Log auth attempt without authenticating */
d205 2
a206 2
    {MONITOR_REQ_RSAKEYALLOWED, MON_ISAUTH|MON_ALOG, mm_answer_rsa_keyallowed},
    {MONITOR_REQ_KEYALLOWED, MON_ISAUTH|MON_ALOG, mm_answer_keyallowed},
a282 1
		auth_method = "unknown";
d293 1
a293 1
		if (ent->flags & (MON_AUTHDECIDE|MON_ALOG)) {
a302 2
	if (strcmp(auth_method, "unknown") == 0)
		fatal("%s: authentication method name unknown", __func__);
d482 1
a482 5
	/*
	 * Supported KEX types will only return SHA1 (20 byte) or
	 * SHA256 (32 byte) hashes
	 */
	if (datlen != 20 && datlen != 32)
a784 1
			auth_method = "publickey";
a789 1
			auth_method = "hostbased";
a795 1
			auth_method = "rsa";
a814 6
	} else {
		/* Log failed attempt */
		auth_log(authctxt, 0, auth_method, compat20 ? " ssh2" : "");
		xfree(blob);
		xfree(cuser);
		xfree(chost);
d1016 1
a1016 1
		    (struct sockaddr *)&from, &fromlen) < 0) {
d1032 1
a1032 1
		debug3("%s: tty %s ptyfd %d", __func__, s->tty, s->ptyfd);
d1092 1
a1092 1
	debug3("%s: tty %s ptyfd %d", __func__, s->tty, s->ttyfd);
a1178 1
	auth_method = "rsa";
d1373 2
a1374 1
	kex = xcalloc(1, sizeof(*kex));
a1383 1
	kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;
d1538 1
a1538 1
	mon = xcalloc(1, sizeof(*mon));
d1540 1
@


1.68.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.89 2006/11/07 10:31:31 markus Exp $ */
d295 1
a295 1
		authenticated = (monitor_read(pmonitor, mon_dispatch, &ent) == 1);
d1011 1
a1011 1
	    __func__, key, (verified == 1) ? "verified" : "unverified");
d1026 1
a1026 1
	return (verified == 1);
@


1.67
log
@move #include <sys/wait.h> out of includes.h; ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.66 2006/02/08 13:15:44 stevesk Exp $");
d34 1
@


1.66
log
@small KNF
@
text
@d28 4
a31 1
RCSID("$OpenBSD: monitor.c,v 1.65 2006/02/08 12:15:27 stevesk Exp $");
@


1.65
log
@move #include <paths.h> out of includes.h; ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.64 2005/10/13 22:24:31 stevesk Exp $");
d170 1
a170 1
    {MONITOR_REQ_BSDAUTHRESPOND, MON_AUTH,mm_answer_bsdauthrespond},
d207 1
a207 1
    {MONITOR_REQ_BSDAUTHRESPOND, MON_AUTH,mm_answer_bsdauthrespond},
@


1.64
log
@KNF; ok djm@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.63 2005/03/10 22:01:05 deraadt Exp $");
d30 1
a30 1
#include <openssl/dh.h>
d35 2
@


1.63
log
@spacing
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.62 2005/01/30 11:18:08 dtucker Exp $");
d1581 1
a1581 1
	mm_request_send(sock,MONITOR_ANS_GSSSETUP, m);
d1594 1
a1594 1
	OM_uint32 major,minor;
d1611 1
a1611 1
	if (major==GSS_S_COMPLETE) {
d1660 1
a1660 1
	auth_method="gssapi-with-mic";
@


1.63.4.1
log
@upgrade to OpenSSH 4.3
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.64 2005/10/13 22:24:31 stevesk Exp $");
d1581 1
a1581 1
	mm_request_send(sock, MONITOR_ANS_GSSSETUP, m);
d1594 1
a1594 1
	OM_uint32 major, minor;
d1611 1
a1611 1
	if (major == GSS_S_COMPLETE) {
d1660 1
a1660 1
	auth_method = "gssapi-with-mic";
@


1.63.4.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: monitor.c,v 1.88 2006/08/12 20:46:46 miod Exp $ */
d27 2
a28 5
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/tree.h>
#include <sys/param.h>
a31 8
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>

a35 1
#include "xmalloc.h"
a36 3
#include "key.h"
#include "buffer.h"
#include "hostfile.h"
a37 1
#include "cipher.h"
d40 1
a40 1
#include <zlib.h>
a51 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
d54 1
d56 2
d62 1
a153 1
#define MON_ALOG	0x0020	/* Log auth attempt without authenticating */
d168 1
a168 1
    {MONITOR_REQ_BSDAUTHRESPOND, MON_AUTH, mm_answer_bsdauthrespond},
d199 2
a200 2
    {MONITOR_REQ_RSAKEYALLOWED, MON_ISAUTH|MON_ALOG, mm_answer_rsa_keyallowed},
    {MONITOR_REQ_KEYALLOWED, MON_ISAUTH|MON_ALOG, mm_answer_keyallowed},
d205 1
a205 1
    {MONITOR_REQ_BSDAUTHRESPOND, MON_AUTH, mm_answer_bsdauthrespond},
a276 1
		auth_method = "unknown";
d287 1
a287 1
		if (ent->flags & (MON_AUTHDECIDE|MON_ALOG)) {
a296 2
	if (strcmp(auth_method, "unknown") == 0)
		fatal("%s: authentication method name unknown", __func__);
d476 1
a476 5
	/*
	 * Supported KEX types will only return SHA1 (20 byte) or
	 * SHA256 (32 byte) hashes
	 */
	if (datlen != 20 && datlen != 32)
a778 1
			auth_method = "publickey";
a783 1
			auth_method = "hostbased";
a789 1
			auth_method = "rsa";
a808 6
	} else {
		/* Log failed attempt */
		auth_log(authctxt, 0, auth_method, compat20 ? " ssh2" : "");
		xfree(blob);
		xfree(cuser);
		xfree(chost);
d1010 1
a1010 1
		    (struct sockaddr *)&from, &fromlen) < 0) {
d1026 1
a1026 1
		debug3("%s: tty %s ptyfd %d", __func__, s->tty, s->ptyfd);
d1086 1
a1086 1
	debug3("%s: tty %s ptyfd %d", __func__, s->tty, s->ttyfd);
a1172 1
	auth_method = "rsa";
d1367 2
a1368 1
	kex = xcalloc(1, sizeof(*kex));
a1377 1
	kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;
d1532 1
a1532 1
	mon = xcalloc(1, sizeof(*mon));
d1534 1
@


1.63.4.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.89 2006/11/07 10:31:31 markus Exp $ */
d295 1
a295 1
		authenticated = (monitor_read(pmonitor, mon_dispatch, &ent) == 1);
d1011 1
a1011 1
	    __func__, key, (verified == 1) ? "verified" : "unverified");
d1026 1
a1026 1
	return (verified == 1);
@


1.63.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.64 2005/10/13 22:24:31 stevesk Exp $");
d1581 1
a1581 1
	mm_request_send(sock, MONITOR_ANS_GSSSETUP, m);
d1594 1
a1594 1
	OM_uint32 major, minor;
d1611 1
a1611 1
	if (major == GSS_S_COMPLETE) {
d1660 1
a1660 1
	auth_method = "gssapi-with-mic";
@


1.62
log
@Make code match intent; ok djm@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.61 2004/07/17 05:31:41 dtucker Exp $");
d775 1
a775 1
		switch(type) {
@


1.61
log
@Move "Last logged in at.." message generation to the monitor, right
before recording the new login.  Fixes missing lastlog message when
/var/log/lastlog is not world-readable and incorrect datestamp when
multiple sessions are used (bz #463);  much assistance & ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.60 2004/06/22 05:05:45 dtucker Exp $");
d1121 1
a1121 1
	monitor_permit(mon_dispatch, MONITOR_REQ_SESSKEY, 1);
@


1.61.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.62 2005/01/30 11:18:08 dtucker Exp $");
d1121 1
a1121 1
	monitor_permit(mon_dispatch, MONITOR_REQ_SESSKEY, 0);
@


1.61.2.2
log
@upgrade to OpenSSH 4.1
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.63 2005/03/10 22:01:05 deraadt Exp $");
d775 1
a775 1
		switch (type) {
@


1.60
log
@Change login->username, will prevent -Wshadow errors in Portable; ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.59 2004/06/21 17:36:31 avsm Exp $");
d76 1
a1054 4
	mm_request_send(sock, MONITOR_ANS_PTY, m);

	mm_send_fd(sock, s->ptyfd);
	mm_send_fd(sock, s->ttyfd);
d1064 9
@


1.59
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.58 2004/06/13 12:53:24 djm Exp $");
d511 1
a511 1
	char *login;
d520 1
a520 1
	login = buffer_get_string(m, NULL);
d522 1
a522 1
	pwent = getpwnamallow(login);
d524 3
a526 3
	authctxt->user = xstrdup(login);
	setproctitle("%s [priv]", pwent ? login : "unknown");
	xfree(login);
@


1.58
log
@implement diffie-hellman-group14-sha1 kex method (trivial extension to
existing diffie-hellman-group1-sha1); ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.57 2004/05/11 19:01:43 deraadt Exp $");
d310 1
a310 1
monitor_child_handler(int signal)
d312 1
a312 1
	kill(monitor_child_pid, signal);
d427 1
a427 1
mm_answer_moduli(int socket, Buffer *m)
d457 1
a457 1
	mm_request_send(socket, MONITOR_ANS_MODULI, m);
d462 1
a462 1
mm_answer_sign(int socket, Buffer *m)
d498 1
a498 1
	mm_request_send(socket, MONITOR_ANS_SIGN, m);
d509 1
a509 1
mm_answer_pwnamallow(int socket, Buffer *m)
d551 1
a551 1
	mm_request_send(socket, MONITOR_ANS_PWNAM, m);
d566 1
a566 1
int mm_answer_auth2_read_banner(int socket, Buffer *m)
d573 1
a573 1
	mm_request_send(socket, MONITOR_ANS_AUTH2_READ_BANNER, m);
d582 1
a582 1
mm_answer_authserv(int socket, Buffer *m)
d600 1
a600 1
mm_answer_authpassword(int socket, Buffer *m)
d618 1
a618 1
	mm_request_send(socket, MONITOR_ANS_AUTHPASSWORD, m);
d632 1
a632 1
mm_answer_bsdauthquery(int socket, Buffer *m)
d649 1
a649 1
	mm_request_send(socket, MONITOR_ANS_BSDAUTHQUERY, m);
d662 1
a662 1
mm_answer_bsdauthrespond(int socket, Buffer *m)
d681 1
a681 1
	mm_request_send(socket, MONITOR_ANS_BSDAUTHRESPOND, m);
d691 1
a691 1
mm_answer_skeyquery(int socket, Buffer *m)
d705 1
a705 1
	mm_request_send(socket, MONITOR_ANS_SKEYQUERY, m);
d711 1
a711 1
mm_answer_skeyrespond(int socket, Buffer *m)
d729 1
a729 1
	mm_request_send(socket, MONITOR_ANS_SKEYRESPOND, m);
d749 1
a749 1
mm_answer_keyallowed(int socket, Buffer *m)
d819 1
a819 1
	mm_request_send(socket, MONITOR_ANS_KEYALLOWED, m);
d940 1
a940 1
mm_answer_keyverify(int socket, Buffer *m)
d990 1
a990 1
	mm_request_send(socket, MONITOR_ANS_KEYVERIFY, m);
d1032 1
a1032 1
mm_answer_pty(int socket, Buffer *m)
d1054 1
a1054 1
	mm_request_send(socket, MONITOR_ANS_PTY, m);
d1056 2
a1057 2
	mm_send_fd(socket, s->ptyfd);
	mm_send_fd(socket, s->ttyfd);
d1088 1
a1088 1
	mm_request_send(socket, MONITOR_ANS_PTY, m);
d1093 1
a1093 1
mm_answer_pty_cleanup(int socket, Buffer *m)
d1109 1
a1109 1
mm_answer_sesskey(int socket, Buffer *m)
d1130 1
a1130 1
	mm_request_send(socket, MONITOR_ANS_SESSKEY, m);
d1139 1
a1139 1
mm_answer_sessid(int socket, Buffer *m)
d1157 1
a1157 1
mm_answer_rsa_keyallowed(int socket, Buffer *m)
d1197 1
a1197 1
	mm_request_send(socket, MONITOR_ANS_RSAKEYALLOWED, m);
d1205 1
a1205 1
mm_answer_rsa_challenge(int socket, Buffer *m)
d1231 1
a1231 1
	mm_request_send(socket, MONITOR_ANS_RSACHALLENGE, m);
d1241 1
a1241 1
mm_answer_rsa_response(int socket, Buffer *m)
d1280 1
a1280 1
	mm_request_send(socket, MONITOR_ANS_RSARESPONSE, m);
d1286 1
a1286 1
mm_answer_term(int socket, Buffer *req)
d1559 1
a1559 1
mm_answer_gss_setup_ctx(int socket, Buffer *m)
d1561 1
a1561 1
	gss_OID_desc oid;
d1565 2
a1566 2
	oid.elements = buffer_get_string(m, &len);
	oid.length = len;
d1568 1
a1568 1
	major = ssh_gssapi_server_ctx(&gsscontext, &oid);
d1570 1
a1570 1
	xfree(oid.elements);
d1575 1
a1575 1
	mm_request_send(socket,MONITOR_ANS_GSSSETUP, m);
d1584 1
a1584 1
mm_answer_gss_accept_ctx(int socket, Buffer *m)
d1601 1
a1601 1
	mm_request_send(socket, MONITOR_ANS_GSSSTEP, m);
d1614 1
a1614 1
mm_answer_gss_checkmic(int socket, Buffer *m)
d1633 1
a1633 1
	mm_request_send(socket, MONITOR_ANS_GSSCHECKMIC, m);
d1642 1
a1642 1
mm_answer_gss_userok(int socket, Buffer *m)
d1652 1
a1652 1
	mm_request_send(socket, MONITOR_ANS_GSSUSEROK, m);
@


1.57
log
@improve some code lint did not like; djm millert ok
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.56 2004/05/09 01:19:27 djm Exp $");
d1370 1
@


1.56
log
@kill some more tiny files; ok deraadt@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.55 2004/02/05 05:37:17 dtucker Exp $");
d1303 1
a1303 1
	exit (res);
@


1.55
log
@Pass SIGALRM through to privsep child if LoginGraceTime expires.  ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.54 2003/11/21 11:57:03 djm Exp $");
a59 1
#include "mpaux.h"
@


1.55.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.61 2004/07/17 05:31:41 dtucker Exp $");
d60 1
a76 1
extern Buffer loginmsg;
d311 1
a311 1
monitor_child_handler(int sig)
d313 1
a313 1
	kill(monitor_child_pid, sig);
d428 1
a428 1
mm_answer_moduli(int sock, Buffer *m)
d458 1
a458 1
	mm_request_send(sock, MONITOR_ANS_MODULI, m);
d463 1
a463 1
mm_answer_sign(int sock, Buffer *m)
d499 1
a499 1
	mm_request_send(sock, MONITOR_ANS_SIGN, m);
d510 1
a510 1
mm_answer_pwnamallow(int sock, Buffer *m)
d512 1
a512 1
	char *username;
d521 1
a521 1
	username = buffer_get_string(m, NULL);
d523 1
a523 1
	pwent = getpwnamallow(username);
d525 3
a527 3
	authctxt->user = xstrdup(username);
	setproctitle("%s [priv]", pwent ? username : "unknown");
	xfree(username);
d552 1
a552 1
	mm_request_send(sock, MONITOR_ANS_PWNAM, m);
d567 1
a567 1
int mm_answer_auth2_read_banner(int sock, Buffer *m)
d574 1
a574 1
	mm_request_send(sock, MONITOR_ANS_AUTH2_READ_BANNER, m);
d583 1
a583 1
mm_answer_authserv(int sock, Buffer *m)
d601 1
a601 1
mm_answer_authpassword(int sock, Buffer *m)
d619 1
a619 1
	mm_request_send(sock, MONITOR_ANS_AUTHPASSWORD, m);
d633 1
a633 1
mm_answer_bsdauthquery(int sock, Buffer *m)
d650 1
a650 1
	mm_request_send(sock, MONITOR_ANS_BSDAUTHQUERY, m);
d663 1
a663 1
mm_answer_bsdauthrespond(int sock, Buffer *m)
d682 1
a682 1
	mm_request_send(sock, MONITOR_ANS_BSDAUTHRESPOND, m);
d692 1
a692 1
mm_answer_skeyquery(int sock, Buffer *m)
d706 1
a706 1
	mm_request_send(sock, MONITOR_ANS_SKEYQUERY, m);
d712 1
a712 1
mm_answer_skeyrespond(int sock, Buffer *m)
d730 1
a730 1
	mm_request_send(sock, MONITOR_ANS_SKEYRESPOND, m);
d750 1
a750 1
mm_answer_keyallowed(int sock, Buffer *m)
d820 1
a820 1
	mm_request_send(sock, MONITOR_ANS_KEYALLOWED, m);
d941 1
a941 1
mm_answer_keyverify(int sock, Buffer *m)
d991 1
a991 1
	mm_request_send(sock, MONITOR_ANS_KEYVERIFY, m);
d1033 1
a1033 1
mm_answer_pty(int sock, Buffer *m)
d1055 4
a1068 9
	/* send messages generated by record_login */
	buffer_put_string(m, buffer_ptr(&loginmsg), buffer_len(&loginmsg));
	buffer_clear(&loginmsg);

	mm_request_send(sock, MONITOR_ANS_PTY, m);

	mm_send_fd(sock, s->ptyfd);
	mm_send_fd(sock, s->ttyfd);

d1089 1
a1089 1
	mm_request_send(sock, MONITOR_ANS_PTY, m);
d1094 1
a1094 1
mm_answer_pty_cleanup(int sock, Buffer *m)
d1110 1
a1110 1
mm_answer_sesskey(int sock, Buffer *m)
d1131 1
a1131 1
	mm_request_send(sock, MONITOR_ANS_SESSKEY, m);
d1140 1
a1140 1
mm_answer_sessid(int sock, Buffer *m)
d1158 1
a1158 1
mm_answer_rsa_keyallowed(int sock, Buffer *m)
d1198 1
a1198 1
	mm_request_send(sock, MONITOR_ANS_RSAKEYALLOWED, m);
d1206 1
a1206 1
mm_answer_rsa_challenge(int sock, Buffer *m)
d1232 1
a1232 1
	mm_request_send(sock, MONITOR_ANS_RSACHALLENGE, m);
d1242 1
a1242 1
mm_answer_rsa_response(int sock, Buffer *m)
d1281 1
a1281 1
	mm_request_send(sock, MONITOR_ANS_RSARESPONSE, m);
d1287 1
a1287 1
mm_answer_term(int sock, Buffer *req)
d1304 1
a1304 1
	exit(res);
a1370 1
	kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;
d1559 1
a1559 1
mm_answer_gss_setup_ctx(int sock, Buffer *m)
d1561 1
a1561 1
	gss_OID_desc goid;
d1565 2
a1566 2
	goid.elements = buffer_get_string(m, &len);
	goid.length = len;
d1568 1
a1568 1
	major = ssh_gssapi_server_ctx(&gsscontext, &goid);
d1570 1
a1570 1
	xfree(goid.elements);
d1575 1
a1575 1
	mm_request_send(sock,MONITOR_ANS_GSSSETUP, m);
d1584 1
a1584 1
mm_answer_gss_accept_ctx(int sock, Buffer *m)
d1601 1
a1601 1
	mm_request_send(sock, MONITOR_ANS_GSSSTEP, m);
d1614 1
a1614 1
mm_answer_gss_checkmic(int sock, Buffer *m)
d1633 1
a1633 1
	mm_request_send(sock, MONITOR_ANS_GSSCHECKMIC, m);
d1642 1
a1642 1
mm_answer_gss_userok(int sock, Buffer *m)
d1652 1
a1652 1
	mm_request_send(sock, MONITOR_ANS_GSSUSEROK, m);
@


1.55.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.62 2005/01/30 11:18:08 dtucker Exp $");
d1121 1
a1121 1
	monitor_permit(mon_dispatch, MONITOR_REQ_SESSKEY, 0);
@


1.54
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.53 2003/11/18 10:53:07 djm Exp $");
d1528 1
@


1.53
log
@unbreak fake authloop for non-existent users (my screwup). Spotted and
tested by dtucker@@; ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.52 2003/11/17 11:06:07 markus Exp $");
d1618 1
a1618 1
	
d1623 1
a1623 1
	
d1625 1
a1625 1
	
d1628 1
a1628 1
	
d1631 1
a1631 1
	
d1633 1
a1633 1
	
d1636 1
a1636 1
	
@


1.52
log
@replace "gssapi" with "gssapi-with-mic"; from Simon Wilkinson; test + ok jakob.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.51 2003/11/04 08:54:09 djm Exp $");
d533 1
@


1.51
log
@standardise arguments to auth methods - they should all take authctxt.
check authctxt->valid rather then pw != NULL; ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.50 2003/09/23 20:17:11 markus Exp $");
d128 1
d180 1
a1602 1
	/* Complete - now we can do signing */
d1606 1
d1612 28
d1652 1
a1652 1
	auth_method="gssapi";
@


1.50
log
@replace fatal_cleanup() and linked list of fatal callbacks with static
cleanup_exit() function.  re-refine cleanup_exit() where appropriate,
allocate sshd's authctxt eary to allow simpler cleanup in sshd.
tested by many, ok deraadt@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.49 2003/08/28 12:54:34 markus Exp $");
d771 1
a771 1
	if (key != NULL && authctxt->pw != NULL) {
@


1.49
log
@remove kerberos support from ssh1, since it has been replaced with GSSAPI;
but keep kerberos passwd auth for ssh1 and 2; ok djm, hin, henning, ...
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.48 2003/08/26 09:58:43 markus Exp $");
d250 2
a251 2
Authctxt *
monitor_child_preauth(struct monitor *pmonitor)
d258 3
a272 2
	authctxt = authctxt_new();

a299 2

	return (authctxt);
d1009 1
a1009 1
			fatal_cleanup();
a1023 1
		fatal_remove_cleanup(session_pty_cleanup2, (void *)s);
a1047 1
	fatal_add_cleanup(session_pty_cleanup2, (void *)s);
@


1.49.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.55 2004/02/05 05:37:17 dtucker Exp $");
a127 1
int mm_answer_gss_checkmic(int, Buffer *);
a178 1
    {MONITOR_REQ_GSSCHECKMIC, MON_ISAUTH, mm_answer_gss_checkmic},
d250 2
a251 2
void
monitor_child_preauth(Authctxt *_authctxt, struct monitor *pmonitor)
a257 3
	authctxt = _authctxt;
	memset(authctxt, 0, sizeof(*authctxt));

d270 2
d299 2
a531 1
		authctxt->pw = fakepw();
d772 1
a772 1
	if (key != NULL && authctxt->valid) {
d1010 1
a1010 1
			cleanup_exit(255);
d1025 1
d1050 1
a1527 1
	mon->m_pid = 0;
d1604 1
a1607 1
		monitor_permit(mon_dispatch, MONITOR_REQ_GSSCHECKMIC, 1);
a1612 28
mm_answer_gss_checkmic(int socket, Buffer *m)
{
	gss_buffer_desc gssbuf, mic;
	OM_uint32 ret;
	u_int len;

	gssbuf.value = buffer_get_string(m, &len);
	gssbuf.length = len;
	mic.value = buffer_get_string(m, &len);
	mic.length = len;

	ret = ssh_gssapi_checkmic(gsscontext, &gssbuf, &mic);

	xfree(gssbuf.value);
	xfree(mic.value);

	buffer_clear(m);
	buffer_put_int(m, ret);

	mm_request_send(socket, MONITOR_ANS_GSSCHECKMIC, m);

	if (!GSS_ERROR(ret))
		monitor_permit(mon_dispatch, MONITOR_REQ_GSSUSEROK, 1);

	return (0);
}

int
d1625 1
a1625 1
	auth_method="gssapi-with-mic";
@


1.49.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.61 2004/07/17 05:31:41 dtucker Exp $");
d60 1
a76 1
extern Buffer loginmsg;
d311 1
a311 1
monitor_child_handler(int sig)
d313 1
a313 1
	kill(monitor_child_pid, sig);
d428 1
a428 1
mm_answer_moduli(int sock, Buffer *m)
d458 1
a458 1
	mm_request_send(sock, MONITOR_ANS_MODULI, m);
d463 1
a463 1
mm_answer_sign(int sock, Buffer *m)
d499 1
a499 1
	mm_request_send(sock, MONITOR_ANS_SIGN, m);
d510 1
a510 1
mm_answer_pwnamallow(int sock, Buffer *m)
d512 1
a512 1
	char *username;
d521 1
a521 1
	username = buffer_get_string(m, NULL);
d523 1
a523 1
	pwent = getpwnamallow(username);
d525 3
a527 3
	authctxt->user = xstrdup(username);
	setproctitle("%s [priv]", pwent ? username : "unknown");
	xfree(username);
d552 1
a552 1
	mm_request_send(sock, MONITOR_ANS_PWNAM, m);
d567 1
a567 1
int mm_answer_auth2_read_banner(int sock, Buffer *m)
d574 1
a574 1
	mm_request_send(sock, MONITOR_ANS_AUTH2_READ_BANNER, m);
d583 1
a583 1
mm_answer_authserv(int sock, Buffer *m)
d601 1
a601 1
mm_answer_authpassword(int sock, Buffer *m)
d619 1
a619 1
	mm_request_send(sock, MONITOR_ANS_AUTHPASSWORD, m);
d633 1
a633 1
mm_answer_bsdauthquery(int sock, Buffer *m)
d650 1
a650 1
	mm_request_send(sock, MONITOR_ANS_BSDAUTHQUERY, m);
d663 1
a663 1
mm_answer_bsdauthrespond(int sock, Buffer *m)
d682 1
a682 1
	mm_request_send(sock, MONITOR_ANS_BSDAUTHRESPOND, m);
d692 1
a692 1
mm_answer_skeyquery(int sock, Buffer *m)
d706 1
a706 1
	mm_request_send(sock, MONITOR_ANS_SKEYQUERY, m);
d712 1
a712 1
mm_answer_skeyrespond(int sock, Buffer *m)
d730 1
a730 1
	mm_request_send(sock, MONITOR_ANS_SKEYRESPOND, m);
d750 1
a750 1
mm_answer_keyallowed(int sock, Buffer *m)
d820 1
a820 1
	mm_request_send(sock, MONITOR_ANS_KEYALLOWED, m);
d941 1
a941 1
mm_answer_keyverify(int sock, Buffer *m)
d991 1
a991 1
	mm_request_send(sock, MONITOR_ANS_KEYVERIFY, m);
d1033 1
a1033 1
mm_answer_pty(int sock, Buffer *m)
d1055 4
a1068 9
	/* send messages generated by record_login */
	buffer_put_string(m, buffer_ptr(&loginmsg), buffer_len(&loginmsg));
	buffer_clear(&loginmsg);

	mm_request_send(sock, MONITOR_ANS_PTY, m);

	mm_send_fd(sock, s->ptyfd);
	mm_send_fd(sock, s->ttyfd);

d1089 1
a1089 1
	mm_request_send(sock, MONITOR_ANS_PTY, m);
d1094 1
a1094 1
mm_answer_pty_cleanup(int sock, Buffer *m)
d1110 1
a1110 1
mm_answer_sesskey(int sock, Buffer *m)
d1131 1
a1131 1
	mm_request_send(sock, MONITOR_ANS_SESSKEY, m);
d1140 1
a1140 1
mm_answer_sessid(int sock, Buffer *m)
d1158 1
a1158 1
mm_answer_rsa_keyallowed(int sock, Buffer *m)
d1198 1
a1198 1
	mm_request_send(sock, MONITOR_ANS_RSAKEYALLOWED, m);
d1206 1
a1206 1
mm_answer_rsa_challenge(int sock, Buffer *m)
d1232 1
a1232 1
	mm_request_send(sock, MONITOR_ANS_RSACHALLENGE, m);
d1242 1
a1242 1
mm_answer_rsa_response(int sock, Buffer *m)
d1281 1
a1281 1
	mm_request_send(sock, MONITOR_ANS_RSARESPONSE, m);
d1287 1
a1287 1
mm_answer_term(int sock, Buffer *req)
d1304 1
a1304 1
	exit(res);
a1370 1
	kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;
d1559 1
a1559 1
mm_answer_gss_setup_ctx(int sock, Buffer *m)
d1561 1
a1561 1
	gss_OID_desc goid;
d1565 2
a1566 2
	goid.elements = buffer_get_string(m, &len);
	goid.length = len;
d1568 1
a1568 1
	major = ssh_gssapi_server_ctx(&gsscontext, &goid);
d1570 1
a1570 1
	xfree(goid.elements);
d1575 1
a1575 1
	mm_request_send(sock,MONITOR_ANS_GSSSETUP, m);
d1584 1
a1584 1
mm_answer_gss_accept_ctx(int sock, Buffer *m)
d1601 1
a1601 1
	mm_request_send(sock, MONITOR_ANS_GSSSTEP, m);
d1614 1
a1614 1
mm_answer_gss_checkmic(int sock, Buffer *m)
d1633 1
a1633 1
	mm_request_send(sock, MONITOR_ANS_GSSCHECKMIC, m);
d1642 1
a1642 1
mm_answer_gss_userok(int sock, Buffer *m)
d1652 1
a1652 1
	mm_request_send(sock, MONITOR_ANS_GSSUSEROK, m);
@


1.48
log
@fix passwd auth for 'username leaks via timing'; with djm@@, original patches from solar
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.47 2003/08/24 17:36:52 deraadt Exp $");
a123 3
#ifdef KRB5
int mm_answer_krb5(int, Buffer *);
#endif
a174 3
#ifdef KRB5
    {MONITOR_REQ_KRB5, MON_ONCE|MON_AUTH, mm_answer_krb5},
#endif
a208 3
#ifdef KRB5
    {MONITOR_REQ_KRB5, MON_ONCE|MON_AUTH, mm_answer_krb5},
#endif
a1284 39

#ifdef KRB5
int
mm_answer_krb5(int socket, Buffer *m)
{
	krb5_data tkt, reply;
	char *client_user;
	u_int len;
	int success;

	/* use temporary var to avoid size issues on 64bit arch */
	tkt.data = buffer_get_string(m, &len);
	tkt.length = len;

	success = options.kerberos_authentication &&
	    authctxt->valid &&
	    auth_krb5(authctxt, &tkt, &client_user, &reply);

	if (tkt.length)
		xfree(tkt.data);

	buffer_clear(m);
	buffer_put_int(m, success);

	if (success) {
		buffer_put_cstring(m, client_user);
		buffer_put_string(m, reply.data, reply.length);
		if (client_user)
			xfree(client_user);
		if (reply.length)
			xfree(reply.data);
	}
	mm_request_send(socket, MONITOR_ANS_KRB5, m);

	auth_method = "kerberos";

	return success;
}
#endif
@


1.47
log
@64 bit cleanups; markus ok
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.46 2003/08/22 10:56:09 markus Exp $");
d618 1
a618 1
	    authctxt->valid && auth_password(authctxt, passwd);
@


1.46
log
@support GSS API user authentication; patches from Simon Wilkinson,
stripped down and tested by Jakob and myself.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.45 2003/07/22 13:35:22 markus Exp $");
d1637 1
d1639 2
a1640 1
	in.value = buffer_get_string(m, &in.length);
@


1.45
log
@remove (already disabled) KRB4/AFS support, re-enable -k in ssh(1);
test+ok henning@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.44 2003/06/24 08:23:46 markus Exp $");
d62 5
d127 5
d181 5
a337 1

d1603 74
@


1.44
log
@int -> u_int; ok djm@@, deraadt@@, mouring@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.43 2003/06/12 07:57:38 markus Exp $");
a118 3
#ifdef KRB4
int mm_answer_krb4(int, Buffer *);
#endif
a199 3
#ifdef KRB4
    {MONITOR_REQ_KRB4, MON_ONCE|MON_AUTH, mm_answer_krb4},
#endif
a1279 46

#ifdef KRB4
int
mm_answer_krb4(int socket, Buffer *m)
{
	KTEXT_ST auth, reply;
	char  *client, *p;
	int success;
	u_int alen;

	reply.length = auth.length = 0;
 
	p = buffer_get_string(m, &alen);
	if (alen >=  MAX_KTXT_LEN)
		 fatal("%s: auth too large", __func__);
	memcpy(auth.dat, p, alen);
	auth.length = alen;
	memset(p, 0, alen);
	xfree(p);

	success = options.kerberos_authentication &&
	    authctxt->valid &&
	    auth_krb4(authctxt, &auth, &client, &reply);

	memset(auth.dat, 0, alen);
	buffer_clear(m);
	buffer_put_int(m, success);

	if (success) {
		buffer_put_cstring(m, client);
		buffer_put_string(m, reply.dat, reply.length);
		if (client)
			xfree(client);
		if (reply.length)
			memset(reply.dat, 0, reply.length);
	}

	debug3("%s: sending result %d", __func__, success);
	mm_request_send(socket, MONITOR_ANS_KRB4, m);

	auth_method = "kerberos";

	/* Causes monitor loop to terminate if authenticated */
	return (success);
}
#endif
@


1.43
log
@typos; dtucker at zip.com.au
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.42 2003/06/02 09:17:34 markus Exp $");
d136 1
a136 1
static int session_id2_len = 0;
@


1.42
log
@deprecate VerifyReverseMapping since it's dangerous if combined
with IP based access control as noted by Mike Harding; replace with
a UseDNS option, UseDNS is on by default and includes the
VerifyReverseMapping check; with itojun@@, provos@@, jakob@@ and deraadt@@
ok deraadt@@, djm@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.41 2003/05/24 09:30:40 djm Exp $");
d96 1
a96 1
/* Functions on the montior that answer unprivileged requests */
@


1.41
log
@cast some types for printing; ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.40 2003/05/14 08:57:49 markus Exp $");
d1016 1
a1016 1
	    get_remote_name_or_ip(utmp_len, options.verify_reverse_mapping),
@


1.40
log
@http://bugzilla.mindrot.org/show_bug.cgi?id=560
Privsep child continues to run after monitor killed.
Pass monitor signals through to child; Darren Tucker
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.39 2003/05/14 02:15:47 markus Exp $");
d1023 1
a1023 1
	debug3("%s: session %d pid %d", __func__, s->self, s->pid);
@


1.39
log
@implement kerberos over ssh2 ("kerberos-2@@ssh.com"); tested with jakob@@
server interops with commercial client; ok jakob@@ djm@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.38 2003/04/08 20:21:28 itojun Exp $");
d138 1
d303 12
d318 4
@


1.38
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.37 2003/04/02 09:48:07 markus Exp $");
d170 3
d1348 2
@


1.37
log
@reapply rekeying chage, tested by henning@@, ok djm@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.36 2003/04/01 10:22:21 markus Exp $");
d838 1
a838 1
		log("wrong user name passed to monitor: expected %s != %.100s",
d886 1
a886 1
		log("wrong user name passed to monitor: expected %s != %.100s",
@


1.36
log
@backout rekeying changes (for 3.6.1)
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.35 2003/04/01 10:10:23 markus Exp $");
d1465 2
d1496 8
a1503 2
	packet_set_seqnr(MODE_OUT, buffer_get_int(&m));
	packet_set_seqnr(MODE_IN, buffer_get_int(&m));
@


1.35
log
@rekeying bugfixes and automatic rekeying:

* both client and server rekey _automatically_
      (a) after 2^31 packets, because after 2^32 packets
          the sequence number for packets wraps
      (b) after 2^(blocksize_in_bits/4) blocks
  (see: http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-00.txt)
  (a) and (b) are _enabled_ by default, and only disabled for known
  openssh versions, that don't support rekeying properly.
* client option 'RekeyLimit'
* do not reply to requests during rekeying
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.34 2003/03/23 19:02:00 markus Exp $");
a1464 2
	u_int32_t seqnr, packets;
	u_int64_t blocks;
d1494 2
a1495 8
	seqnr = buffer_get_int(&m);
	blocks = buffer_get_int64(&m);
	packets = buffer_get_int(&m);
	packet_set_state(MODE_OUT, seqnr, blocks, packets);
	seqnr = buffer_get_int(&m);
	blocks = buffer_get_int64(&m);
	packets = buffer_get_int(&m);
	packet_set_state(MODE_IN, seqnr, blocks, packets);
@


1.34
log
@unbreak rekeying for privsep; ok millert@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.33 2003/03/05 22:33:43 markus Exp $");
d1465 2
d1496 8
a1503 2
	packet_set_seqnr(MODE_OUT, buffer_get_int(&m));
	packet_set_seqnr(MODE_IN, buffer_get_int(&m));
@


1.34.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.49 2003/08/28 12:54:34 markus Exp $");
a61 5
#ifdef GSSAPI
#include "ssh-gss.h"
static Gssctxt *gsscontext = NULL;
#endif

d96 1
a96 1
/* Functions on the monitor that answer unprivileged requests */
d119 5
a123 4
#ifdef GSSAPI
int mm_answer_gss_setup_ctx(int, Buffer *);
int mm_answer_gss_accept_ctx(int, Buffer *);
int mm_answer_gss_userok(int, Buffer *);
d136 1
a136 1
static u_int session_id2_len = 0;
a137 1
static pid_t monitor_child_pid;
a169 5
#ifdef GSSAPI
    {MONITOR_REQ_GSSSETUP, MON_ISAUTH, mm_answer_gss_setup_ctx},
    {MONITOR_REQ_GSSSTEP, MON_ISAUTH, mm_answer_gss_accept_ctx},
    {MONITOR_REQ_GSSUSEROK, MON_AUTH, mm_answer_gss_userok},
#endif
d199 6
a298 12
static void
monitor_set_child_handler(pid_t pid)
{
	monitor_child_pid = pid;
}

static void
monitor_child_handler(int signal)
{
	kill(monitor_child_pid, signal);
}

a301 4
	monitor_set_child_handler(pmonitor->m_pid);
	signal(SIGHUP, &monitor_child_handler);
	signal(SIGTERM, &monitor_child_handler);

d309 1
d590 1
a590 1
	    auth_password(authctxt, passwd);
d838 1
a838 1
		logit("wrong user name passed to monitor: expected %s != %.100s",
d886 1
a886 1
		logit("wrong user name passed to monitor: expected %s != %.100s",
d996 1
a996 1
	    get_remote_name_or_ip(utmp_len, options.use_dns),
d1003 1
a1003 1
	debug3("%s: session %d pid %ld", __func__, s->self, (long)s->pid);
d1267 83
a1464 2
	u_int32_t seqnr, packets;
	u_int64_t blocks;
d1494 2
a1495 8
	seqnr = buffer_get_int(&m);
	blocks = buffer_get_int64(&m);
	packets = buffer_get_int(&m);
	packet_set_state(MODE_OUT, seqnr, blocks, packets);
	seqnr = buffer_get_int(&m);
	blocks = buffer_get_int64(&m);
	packets = buffer_get_int(&m);
	packet_set_state(MODE_IN, seqnr, blocks, packets);
a1610 76

#ifdef GSSAPI
int
mm_answer_gss_setup_ctx(int socket, Buffer *m)
{
	gss_OID_desc oid;
	OM_uint32 major;
	u_int len;

	oid.elements = buffer_get_string(m, &len);
	oid.length = len;

	major = ssh_gssapi_server_ctx(&gsscontext, &oid);

	xfree(oid.elements);

	buffer_clear(m);
	buffer_put_int(m, major);

	mm_request_send(socket,MONITOR_ANS_GSSSETUP, m);

	/* Now we have a context, enable the step */
	monitor_permit(mon_dispatch, MONITOR_REQ_GSSSTEP, 1);

	return (0);
}

int
mm_answer_gss_accept_ctx(int socket, Buffer *m)
{
	gss_buffer_desc in;
	gss_buffer_desc out = GSS_C_EMPTY_BUFFER;
	OM_uint32 major,minor;
	OM_uint32 flags = 0; /* GSI needs this */
	u_int len;

	in.value = buffer_get_string(m, &len);
	in.length = len;
	major = ssh_gssapi_accept_ctx(gsscontext, &in, &out, &flags);
	xfree(in.value);

	buffer_clear(m);
	buffer_put_int(m, major);
	buffer_put_string(m, out.value, out.length);
	buffer_put_int(m, flags);
	mm_request_send(socket, MONITOR_ANS_GSSSTEP, m);

	gss_release_buffer(&minor, &out);

	/* Complete - now we can do signing */
	if (major==GSS_S_COMPLETE) {
		monitor_permit(mon_dispatch, MONITOR_REQ_GSSSTEP, 0);
		monitor_permit(mon_dispatch, MONITOR_REQ_GSSUSEROK, 1);
	}
	return (0);
}

int
mm_answer_gss_userok(int socket, Buffer *m)
{
	int authenticated;

	authenticated = authctxt->valid && ssh_gssapi_userok(authctxt->user);

	buffer_clear(m);
	buffer_put_int(m, authenticated);

	debug3("%s: sending result %d", __func__, authenticated);
	mm_request_send(socket, MONITOR_ANS_GSSUSEROK, m);

	auth_method="gssapi";

	/* Monitor loop will terminate if authenticated */
	return (authenticated);
}
#endif /* GSSAPI */
@


1.34.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.55 2004/02/05 05:37:17 dtucker Exp $");
a127 1
int mm_answer_gss_checkmic(int, Buffer *);
a178 1
    {MONITOR_REQ_GSSCHECKMIC, MON_ISAUTH, mm_answer_gss_checkmic},
d250 2
a251 2
void
monitor_child_preauth(Authctxt *_authctxt, struct monitor *pmonitor)
a257 3
	authctxt = _authctxt;
	memset(authctxt, 0, sizeof(*authctxt));

d270 2
d299 2
a531 1
		authctxt->pw = fakepw();
d772 1
a772 1
	if (key != NULL && authctxt->valid) {
d1010 1
a1010 1
			cleanup_exit(255);
d1025 1
d1050 1
a1527 1
	mon->m_pid = 0;
d1604 1
a1607 1
		monitor_permit(mon_dispatch, MONITOR_REQ_GSSCHECKMIC, 1);
a1612 28
mm_answer_gss_checkmic(int socket, Buffer *m)
{
	gss_buffer_desc gssbuf, mic;
	OM_uint32 ret;
	u_int len;

	gssbuf.value = buffer_get_string(m, &len);
	gssbuf.length = len;
	mic.value = buffer_get_string(m, &len);
	mic.length = len;

	ret = ssh_gssapi_checkmic(gsscontext, &gssbuf, &mic);

	xfree(gssbuf.value);
	xfree(mic.value);

	buffer_clear(m);
	buffer_put_int(m, ret);

	mm_request_send(socket, MONITOR_ANS_GSSCHECKMIC, m);

	if (!GSS_ERROR(ret))
		monitor_permit(mon_dispatch, MONITOR_REQ_GSSUSEROK, 1);

	return (0);
}

int
d1625 1
a1625 1
	auth_method="gssapi-with-mic";
@


1.33
log
@fix memory leaks; from dlheine@@suif.Stanford.EDU/CLOUSEAU; ok djm@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.32 2003/02/16 17:30:33 markus Exp $");
d1434 2
@


1.32
log
@fix permitrootlogin forced-commands-only for privsep; bux #387; ok provos@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.31 2003/02/04 09:33:22 markus Exp $");
d774 2
a776 1
	}
d1173 2
a1175 1
	}
d1216 3
d1249 1
@


1.31
log
@skey/bsdauth: use 0 to indicate failure instead of -1, because
the buffer API only supports unsigned ints.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.30 2002/11/05 19:45:20 markus Exp $");
d794 1
d1157 1
@


1.30
log
@handle overflows for size_t larger than u_int; siw@@goneko.de, bug #425
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.29 2002/09/26 11:38:43 markus Exp $");
d618 1
a618 1
	int res;
d620 2
a621 2
	res = bsdauth_query(authctxt, &name, &infotxt, &numprompts,
	    &prompts, &echo_on);
d624 2
a625 2
	buffer_put_int(m, res);
	if (res != -1)
d628 1
a628 1
	debug3("%s: sending challenge res: %d", __func__, res);
d631 1
a631 1
	if (res != -1) {
d675 1
a675 1
	int res;
d677 1
a677 1
	res = skeychallenge(&skey, authctxt->user, challenge);
d680 2
a681 2
	buffer_put_int(m, res);
	if (res != -1)
d684 1
a684 1
	debug3("%s: sending challenge res: %d", __func__, res);
@


1.29
log
@krb4 + privsep; ok dugsong@@, deraadt@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.28 2002/09/24 08:46:04 markus Exp $");
d1519 1
a1519 1
	size_t len = size * ncount;
@


1.29.2.1
log
@Update to OpenSSH 3.6
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.33 2003/03/05 22:33:43 markus Exp $");
d618 1
a618 1
	u_int success;
d620 2
a621 2
	success = bsdauth_query(authctxt, &name, &infotxt, &numprompts,
	    &prompts, &echo_on) < 0 ? 0 : 1;
d624 2
a625 2
	buffer_put_int(m, success);
	if (success)
d628 1
a628 1
	debug3("%s: sending challenge success: %u", __func__, success);
d631 1
a631 1
	if (success) {
d675 1
a675 1
	u_int success;
d677 1
a677 1
	success = skeychallenge(&skey, authctxt->user, challenge) < 0 ? 0 : 1;
d680 2
a681 2
	buffer_put_int(m, success);
	if (success)
d684 1
a684 1
	debug3("%s: sending challenge success: %u", __func__, success);
d774 1
a775 2
	if (key != NULL)
		key_free(key);
a793 1
	buffer_put_int(m, forced_command != NULL);
a1155 1
	buffer_put_int(m, forced_command != NULL);
d1170 1
a1171 2
	if (key != NULL)
		key_free(key);
a1211 3

	xfree(blob);
	key_free(key);
a1241 1
	xfree(blob);
d1519 1
a1519 1
	size_t len = (size_t) size * ncount;
@


1.29.2.2
log
@Update to OpenSSH 3.6.1
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.36 2003/04/01 10:22:21 markus Exp $");
a1433 2
	kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;
	kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;
@


1.29.2.3
log
@upgrade to OpenSSH 3.7
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.49 2003/08/28 12:54:34 markus Exp $");
a61 5
#ifdef GSSAPI
#include "ssh-gss.h"
static Gssctxt *gsscontext = NULL;
#endif

d96 1
a96 1
/* Functions on the monitor that answer unprivileged requests */
d119 5
a123 4
#ifdef GSSAPI
int mm_answer_gss_setup_ctx(int, Buffer *);
int mm_answer_gss_accept_ctx(int, Buffer *);
int mm_answer_gss_userok(int, Buffer *);
d136 1
a136 1
static u_int session_id2_len = 0;
a137 1
static pid_t monitor_child_pid;
a169 5
#ifdef GSSAPI
    {MONITOR_REQ_GSSSETUP, MON_ISAUTH, mm_answer_gss_setup_ctx},
    {MONITOR_REQ_GSSSTEP, MON_ISAUTH, mm_answer_gss_accept_ctx},
    {MONITOR_REQ_GSSUSEROK, MON_AUTH, mm_answer_gss_userok},
#endif
d199 6
a298 12
static void
monitor_set_child_handler(pid_t pid)
{
	monitor_child_pid = pid;
}

static void
monitor_child_handler(int signal)
{
	kill(monitor_child_pid, signal);
}

a301 4
	monitor_set_child_handler(pmonitor->m_pid);
	signal(SIGHUP, &monitor_child_handler);
	signal(SIGTERM, &monitor_child_handler);

d309 1
d590 1
a590 1
	    auth_password(authctxt, passwd);
d838 1
a838 1
		logit("wrong user name passed to monitor: expected %s != %.100s",
d886 1
a886 1
		logit("wrong user name passed to monitor: expected %s != %.100s",
d996 1
a996 1
	    get_remote_name_or_ip(utmp_len, options.use_dns),
d1003 1
a1003 1
	debug3("%s: session %d pid %ld", __func__, s->self, (long)s->pid);
d1267 83
a1464 2
	u_int32_t seqnr, packets;
	u_int64_t blocks;
d1494 2
a1495 8
	seqnr = buffer_get_int(&m);
	blocks = buffer_get_int64(&m);
	packets = buffer_get_int(&m);
	packet_set_state(MODE_OUT, seqnr, blocks, packets);
	seqnr = buffer_get_int(&m);
	blocks = buffer_get_int64(&m);
	packets = buffer_get_int(&m);
	packet_set_state(MODE_IN, seqnr, blocks, packets);
a1610 76

#ifdef GSSAPI
int
mm_answer_gss_setup_ctx(int socket, Buffer *m)
{
	gss_OID_desc oid;
	OM_uint32 major;
	u_int len;

	oid.elements = buffer_get_string(m, &len);
	oid.length = len;

	major = ssh_gssapi_server_ctx(&gsscontext, &oid);

	xfree(oid.elements);

	buffer_clear(m);
	buffer_put_int(m, major);

	mm_request_send(socket,MONITOR_ANS_GSSSETUP, m);

	/* Now we have a context, enable the step */
	monitor_permit(mon_dispatch, MONITOR_REQ_GSSSTEP, 1);

	return (0);
}

int
mm_answer_gss_accept_ctx(int socket, Buffer *m)
{
	gss_buffer_desc in;
	gss_buffer_desc out = GSS_C_EMPTY_BUFFER;
	OM_uint32 major,minor;
	OM_uint32 flags = 0; /* GSI needs this */
	u_int len;

	in.value = buffer_get_string(m, &len);
	in.length = len;
	major = ssh_gssapi_accept_ctx(gsscontext, &in, &out, &flags);
	xfree(in.value);

	buffer_clear(m);
	buffer_put_int(m, major);
	buffer_put_string(m, out.value, out.length);
	buffer_put_int(m, flags);
	mm_request_send(socket, MONITOR_ANS_GSSSTEP, m);

	gss_release_buffer(&minor, &out);

	/* Complete - now we can do signing */
	if (major==GSS_S_COMPLETE) {
		monitor_permit(mon_dispatch, MONITOR_REQ_GSSSTEP, 0);
		monitor_permit(mon_dispatch, MONITOR_REQ_GSSUSEROK, 1);
	}
	return (0);
}

int
mm_answer_gss_userok(int socket, Buffer *m)
{
	int authenticated;

	authenticated = authctxt->valid && ssh_gssapi_userok(authctxt->user);

	buffer_clear(m);
	buffer_put_int(m, authenticated);

	debug3("%s: sending result %d", __func__, authenticated);
	mm_request_send(socket, MONITOR_ANS_GSSUSEROK, m);

	auth_method="gssapi";

	/* Monitor loop will terminate if authenticated */
	return (authenticated);
}
#endif /* GSSAPI */
@


1.28
log
@only call kerberos code for authctxt->valid
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.27 2002/09/23 22:11:05 markus Exp $");
d119 3
d199 3
d1259 45
@


1.27
log
@only call auth_krb5 if kerberos is enabled; ok deraadt@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.26 2002/09/09 14:54:15 markus Exp $");
d1267 2
a1268 1
	success = (options.kerberos_authentication == 1) &&
@


1.26
log
@signed vs unsigned from -pedantic; ok henning@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.25 2002/09/09 06:48:06 itojun Exp $");
d1267 2
a1268 1
	success = auth_krb5(authctxt, &tkt, &client_user, &reply);
@


1.25
log
@kerberos support for privsep.  confirmed to work by lha@@stacken.kth.se
patch from markus
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.24 2002/08/29 15:57:25 stevesk Exp $");
d130 2
a131 2
static u_char *hostbased_cuser = NULL;
static u_char *hostbased_chost = NULL;
d726 2
a727 1
	u_char *cuser, *chost, *blob;
d803 1
a803 1
	u_char *p;
d856 2
a857 2
monitor_valid_hostbasedblob(u_char *data, u_int datalen, u_char *cuser,
    u_char *chost)
d860 1
a860 1
	u_char *p;
@


1.24
log
@pass addrlen with sockaddr *; from Hajimu UMEMOTO <ume@@FreeBSD.org>
NOTE: there are also p-specific parts to this patch. ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.23 2002/08/02 14:43:15 millert Exp $");
d119 4
d196 3
d1251 36
@


1.23
log
@Change mm_zalloc() sanity checks to be more in line with what
we do in calloc() and add a check to monitor_mm.c.
OK provos@@ and markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.22 2002/07/22 17:32:56 stevesk Exp $");
d970 1
a971 1
		fromlen = sizeof(from);
d981 1
a981 1
	    (struct sockaddr *)&from);
@


1.22
log
@u_int here; ok provos@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.21 2002/06/27 10:35:47 deraadt Exp $");
d1422 1
a1422 1
	int len = size * ncount;
d1425 1
a1425 1
	if (len <= 0 || size > 65535 || ncount > 65535)
@


1.21
log
@use xfree()
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.20 2002/06/27 09:08:00 deraadt Exp $");
d571 2
a572 1
	int authenticated, plen;
@


1.20
log
@improve mm_zalloc check; markus ok
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.19 2002/06/26 14:49:36 deraadt Exp $");
d543 1
a543 1
		free(banner);
@


1.19
log
@correct %u
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.18 2002/06/26 13:20:57 deraadt Exp $");
d1424 1
a1424 1
	if (len <= 0)
@


1.18
log
@be careful in mm_zalloc
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.17 2002/06/22 23:09:51 stevesk Exp $");
d444 1
a444 1
		fatal("%s: data length incorrect: %d", __func__, datlen);
d458 1
a458 1
	debug3("%s: signature %p(%d)", __func__, signature, siglen);
@


1.17
log
@save auth method before monitor_reset_key_state(); bugzilla bug #284;
ok provos@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.16 2002/06/21 05:50:51 djm Exp $");
d1421 1
d1424 4
a1427 1
	address = mm_malloc(mm, size * ncount);
@


1.16
log
@Don't initialise compression buffers when compression=no in sshd_config;
ok Niels@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.15 2002/06/19 18:01:00 markus Exp $");
d947 2
a953 2

	auth_method = key_blobtype == MM_USERKEY ? "publickey" : "hostbased";
@


1.15
log
@make the monitor sync the transfer ssh1 session key;
transfer keycontext only for RC4 (this is still depends on EVP
implementation details and is broken).
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.14 2002/06/04 23:05:49 markus Exp $");
d313 4
a316 2
	/* The member allocation is not visible, so sync it */
	mm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);
d1297 2
a1298 1
	mm_init_compression(pmonitor->m_zlib);
d1478 3
a1480 2
	mon->m_zback = mm_create(NULL, MM_MEMSIZE);
	mon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);
d1482 3
a1484 2
	/* Compression needs to share state across borders */
	mm_init_compression(mon->m_zlib);
@


1.14
log
@__FUNCTION__ -> __func__
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.13 2002/06/04 19:53:40 markus Exp $");
d86 2
a1269 3
		u_char key[SSH_SESSION_KEY_LENGTH];

		memset(key, 'a', sizeof(key));
d1271 3
a1273 2
		packet_set_encryption_key(key, SSH_SESSION_KEY_LENGTH,
		    child_state.ssh1cipher);
d1276 1
d1362 2
@


1.13
log
@save the session id (hash) for ssh2 (it will be passed with the initial sign request)
and verify that this value is used during authentication; ok provos@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.12 2002/06/04 19:42:35 markus Exp $");
d259 1
a259 1
				    __FUNCTION__, ent->type);
d274 1
a274 1
		fatal("%s: authenticated invalid user", __FUNCTION__);
d277 1
a277 1
	    __FUNCTION__, authctxt->user);
d328 1
a328 1
	debug3("%s: checking request %d", __FUNCTION__, type);
d338 1
a338 1
			fatal("%s: unpermitted request %d", __FUNCTION__,
d345 1
a345 1
			debug2("%s: %d used once, disabling now", __FUNCTION__,
d356 1
a356 1
	fatal("%s: unsupported request: %d", __FUNCTION__, type);
d401 1
a401 1
	    __FUNCTION__, min, want, max);
d405 1
a405 1
		    __FUNCTION__, min, want, max);
d434 1
a434 1
	debug3("%s", __FUNCTION__);
d440 1
a440 1
		fatal("%s: data length incorrect: %d", __FUNCTION__, datlen);
d450 1
a450 1
		fatal("%s: no hostkey from index %d", __FUNCTION__, keyid);
d452 1
a452 1
		fatal("%s: key_sign failed", __FUNCTION__);
d454 1
a454 1
	debug3("%s: signature %p(%d)", __FUNCTION__, signature, siglen);
d479 1
a479 1
	debug3("%s", __FUNCTION__);
d482 1
a482 1
		fatal("%s: multiple attempts for getpwnam", __FUNCTION__);
d513 1
a513 1
	debug3("%s: sending MONITOR_ANS_PWNAM: %d", __FUNCTION__, allowed);
d552 1
a552 1
	    __FUNCTION__, authctxt->service, authctxt->style);
d579 1
a579 1
	debug3("%s: sending result %d", __FUNCTION__, authenticated);
d610 1
a610 1
	debug3("%s: sending challenge res: %d", __FUNCTION__, res);
d630 1
a630 1
		fatal("%s: no bsd auth session", __FUNCTION__);
d636 1
a636 1
	debug3("%s: <%s> = <%d>", __FUNCTION__, response, authok);
d642 1
a642 1
	debug3("%s: sending authenticated: %d", __FUNCTION__, authok);
d666 1
a666 1
	debug3("%s: sending challenge res: %d", __FUNCTION__, res);
d690 1
a690 1
	debug3("%s: sending authenticated: %d", __FUNCTION__, authok);
d703 1
a703 1
		debug3("%s: Appending debug messages for child", __FUNCTION__);
d719 1
a719 1
	debug3("%s entering", __FUNCTION__);
d730 1
a730 1
		fatal("%s: key type and protocol mismatch", __FUNCTION__);
d732 1
a732 1
	debug3("%s: key_from_blob: %p", __FUNCTION__, key);
d752 1
a752 1
			fatal("%s: unknown key type %d", __FUNCTION__, type);
d771 1
a771 1
	    __FUNCTION__, key, allowed ? "allowed" : "disallowed");
d913 1
a913 1
		fatal("%s: bad key, not previously allowed", __FUNCTION__);
d917 1
a917 1
		fatal("%s: bad public key blob", __FUNCTION__);
d932 1
a932 1
		fatal("%s: bad signature data blob", __FUNCTION__);
d936 1
a936 1
	    __FUNCTION__, key, verified ? "verified" : "unverified");
d982 1
a982 1
	debug3("%s: session %d pid %d", __FUNCTION__, s->self, s->pid);
d984 1
a984 1
		debug3("%s: tty %s ptyfd %d",  __FUNCTION__, s->tty, s->ptyfd);
d998 1
a998 1
	debug3("%s entering", __FUNCTION__);
d1022 1
a1022 1
		fatal("%s: dup2", __FUNCTION__);
d1031 1
a1031 1
		fatal("%s: open(/dev/null): %s", __FUNCTION__, strerror(errno));
d1033 1
a1033 1
		error("%s: fd0 %d != 0", __FUNCTION__, fd0);
d1041 1
a1041 1
	debug3("%s: tty %s ptyfd %d",  __FUNCTION__, s->tty, s->ttyfd);
d1059 1
a1059 1
	debug3("%s entering", __FUNCTION__);
d1079 1
a1079 1
		fatal("%s: BN_new", __FUNCTION__);
d1104 1
a1104 1
	debug3("%s entering", __FUNCTION__);
d1107 1
a1107 1
		fatal("%s: bad ssh1 session id", __FUNCTION__);
d1126 1
a1126 1
	debug3("%s entering", __FUNCTION__);
d1130 1
a1130 1
			fatal("%s: BN_new", __FUNCTION__);
d1144 1
a1144 1
			fatal("%s: key_to_blob failed", __FUNCTION__);
d1170 1
a1170 1
	debug3("%s entering", __FUNCTION__);
d1173 1
a1173 1
		fatal("%s: authctxt not valid", __FUNCTION__);
d1176 1
a1176 1
		fatal("%s: bad key, not previously allowed", __FUNCTION__);
d1178 1
a1178 1
		fatal("%s: key type mismatch", __FUNCTION__);
d1180 1
a1180 1
		fatal("%s: received bad key", __FUNCTION__);
d1189 1
a1189 1
	debug3("%s sending reply", __FUNCTION__);
d1204 1
a1204 1
	debug3("%s entering", __FUNCTION__);
d1207 1
a1207 1
		fatal("%s: authctxt not valid", __FUNCTION__);
d1209 1
a1209 1
		fatal("%s: no ssh1_challenge", __FUNCTION__);
d1213 1
a1213 1
		fatal("%s: bad key, not previously allowed", __FUNCTION__);
d1215 1
a1215 1
		fatal("%s: key type mismatch: %d", __FUNCTION__, key_blobtype);
d1217 1
a1217 1
		fatal("%s: received bad key", __FUNCTION__);
d1220 1
a1220 1
		fatal("%s: received bad response to challenge", __FUNCTION__);
d1246 1
a1246 1
	debug3("%s: tearing down sessions", __FUNCTION__);
d1354 1
a1354 1
	debug3("%s: Waiting for new keys", __FUNCTION__);
d1374 1
a1374 1
	debug3("%s: Waiting for second key", __FUNCTION__);
d1388 1
a1388 1
	debug3("%s: Getting compression state", __FUNCTION__);
d1392 1
a1392 1
		fatal("%s: bad request size", __FUNCTION__);
d1398 1
a1398 1
		fatal("%s: bad request size", __FUNCTION__);
d1403 1
a1403 1
	debug3("%s: Getting Network I/O buffers", __FUNCTION__);
d1451 1
a1451 1
		fatal("%s: socketpair", __FUNCTION__);
@


1.12
log
@only allow enabled authentication methods; ok provos@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.11 2002/05/15 15:47:49 mouring Exp $");
d127 2
d442 7
a792 1
	int session_id2_len = 20 /*XXX should get from [net] */;
d798 6
d806 4
a809 2
		xfree(buffer_get_string(&b, &len));
		if (len != session_id2_len)
d811 1
a849 1
	int session_id2_len = 20 /*XXX should get from [net] */;
d854 4
a857 2
	xfree(buffer_get_string(&b, &len));
	if (len != session_id2_len)
d859 2
d1319 4
@


1.11
log
@'monitor' variable clashes with at least one lame platform (NeXT).  Renamed
to 'pmonitor'.  provos@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.10 2002/05/12 23:53:45 djm Exp $");
d562 2
a563 1
	authenticated = authctxt->valid && auth_password(authctxt, passwd);
d624 2
a625 1
	authok = auth_userresponse(authctxt->as, response, 0);
d671 2
a672 1
	authok = (authctxt->valid &&
d728 2
a729 1
			allowed = user_key_allowed(authctxt->pw, key);
d732 2
a733 1
			allowed = hostbased_key_allowed(authctxt->pw,
d738 2
a739 1
			allowed = auth_rhosts_rsa_key_allowed(authctxt->pw,
d929 1
a929 1
	auth_method = "publickey";
d1108 1
a1108 1
	if (authctxt->valid) {
@


1.11.4.1
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.11 2002/05/15 15:47:49 mouring Exp $");
@


1.11.2.1
log
@Update OpenSSH to version 3.2.2.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.11 2002/05/15 15:47:49 mouring Exp $");
@


1.11.2.2
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.11.2.1 2002/05/17 00:03:23 miod Exp $");
a85 2
	u_char *ssh1key;
	u_int ssh1keylen;
a126 2
static int session_id2_len = 0;
static u_char *session_id2 = NULL;
d257 1
a257 1
				    __func__, ent->type);
d272 1
a272 1
		fatal("%s: authenticated invalid user", __func__);
d275 1
a275 1
	    __func__, authctxt->user);
d309 2
a310 4
	if (options.compression) {
		/* The member allocation is not visible, so sync it */
		mm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);
	}
d326 1
a326 1
	debug3("%s: checking request %d", __func__, type);
d336 1
a336 1
			fatal("%s: unpermitted request %d", __func__,
d343 1
a343 1
			debug2("%s: %d used once, disabling now", __func__,
d354 1
a354 1
	fatal("%s: unsupported request: %d", __func__, type);
d399 1
a399 1
	    __func__, min, want, max);
d403 1
a403 1
		    __func__, min, want, max);
d432 1
a432 1
	debug3("%s", __func__);
d438 1
a438 8
		fatal("%s: data length incorrect: %d", __func__, datlen);

	/* save session id, it will be passed on the first call */
	if (session_id2_len == 0) {
		session_id2_len = datlen;
		session_id2 = xmalloc(session_id2_len);
		memcpy(session_id2, p, session_id2_len);
	}
d441 1
a441 1
		fatal("%s: no hostkey from index %d", __func__, keyid);
d443 1
a443 1
		fatal("%s: key_sign failed", __func__);
d445 1
a445 1
	debug3("%s: signature %p(%d)", __func__, signature, siglen);
d470 1
a470 1
	debug3("%s", __func__);
d473 1
a473 1
		fatal("%s: multiple attempts for getpwnam", __func__);
d504 1
a504 1
	debug3("%s: sending MONITOR_ANS_PWNAM: %d", __func__, allowed);
d543 1
a543 1
	    __func__, authctxt->service, authctxt->style);
d562 1
a562 2
	authenticated = options.password_authentication &&
	    authctxt->valid && auth_password(authctxt, passwd);
d569 1
a569 1
	debug3("%s: sending result %d", __func__, authenticated);
d600 1
a600 1
	debug3("%s: sending challenge res: %d", __func__, res);
d620 1
a620 1
		fatal("%s: no bsd auth session", __func__);
d623 1
a623 2
	authok = options.challenge_response_authentication &&
	    auth_userresponse(authctxt->as, response, 0);
d625 1
a625 1
	debug3("%s: <%s> = <%d>", __func__, response, authok);
d631 1
a631 1
	debug3("%s: sending authenticated: %d", __func__, authok);
d655 1
a655 1
	debug3("%s: sending challenge res: %d", __func__, res);
d669 1
a669 2
	authok = (options.challenge_response_authentication &&
	    authctxt->valid &&
d678 1
a678 1
	debug3("%s: sending authenticated: %d", __func__, authok);
d691 1
a691 1
		debug3("%s: Appending debug messages for child", __func__);
d707 1
a707 1
	debug3("%s entering", __func__);
d718 1
a718 1
		fatal("%s: key type and protocol mismatch", __func__);
d720 1
a720 1
	debug3("%s: key_from_blob: %p", __func__, key);
d725 1
a725 2
			allowed = options.pubkey_authentication &&
			    user_key_allowed(authctxt->pw, key);
d728 1
a728 2
			allowed = options.hostbased_authentication &&
			    hostbased_key_allowed(authctxt->pw,
d733 1
a733 2
			allowed = options.rhosts_rsa_authentication &&
			    auth_rhosts_rsa_key_allowed(authctxt->pw,
d737 1
a737 1
			fatal("%s: unknown key type %d", __func__, type);
d756 1
a756 1
	    __func__, key, allowed ? "allowed" : "disallowed");
d778 1
a783 6
		p = buffer_ptr(&b);
		len = buffer_len(&b);
		if ((session_id2 == NULL) ||
		    (len < session_id2_len) ||
		    (memcmp(p, session_id2, session_id2_len) != 0))
			fail++;
d786 2
a787 4
		p = buffer_get_string(&b, &len);
		if ((session_id2 == NULL) ||
		    (len != session_id2_len) ||
		    (memcmp(p, session_id2, session_id2_len) != 0))
a788 1
		xfree(p);
d827 1
d832 2
a833 4
	p = buffer_get_string(&b, &len);
	if ((session_id2 == NULL) ||
	    (len != session_id2_len) ||
	    (memcmp(p, session_id2, session_id2_len) != 0))
a834 2
	xfree(p);

d887 1
a887 1
		fatal("%s: bad key, not previously allowed", __func__);
d891 1
a891 1
		fatal("%s: bad public key blob", __func__);
d906 1
a906 1
		fatal("%s: bad signature data blob", __func__);
d910 1
a910 1
	    __func__, key, verified ? "verified" : "unverified");
d923 1
a923 1
	auth_method = key_blobtype == MM_USERKEY ? "publickey" : "hostbased";
d956 1
a956 1
	debug3("%s: session %d pid %d", __func__, s->self, s->pid);
d958 1
a958 1
		debug3("%s: tty %s ptyfd %d",  __func__, s->tty, s->ptyfd);
d972 1
a972 1
	debug3("%s entering", __func__);
d996 1
a996 1
		fatal("%s: dup2", __func__);
d1005 1
a1005 1
		fatal("%s: open(/dev/null): %s", __func__, strerror(errno));
d1007 1
a1007 1
		error("%s: fd0 %d != 0", __func__, fd0);
d1015 1
a1015 1
	debug3("%s: tty %s ptyfd %d",  __func__, s->tty, s->ttyfd);
d1033 1
a1033 1
	debug3("%s entering", __func__);
d1053 1
a1053 1
		fatal("%s: BN_new", __func__);
d1078 1
a1078 1
	debug3("%s entering", __func__);
d1081 1
a1081 1
		fatal("%s: bad ssh1 session id", __func__);
d1100 1
a1100 1
	debug3("%s entering", __func__);
d1102 1
a1102 1
	if (options.rsa_authentication && authctxt->valid) {
d1104 1
a1104 1
			fatal("%s: BN_new", __func__);
d1118 1
a1118 1
			fatal("%s: key_to_blob failed", __func__);
d1144 1
a1144 1
	debug3("%s entering", __func__);
d1147 1
a1147 1
		fatal("%s: authctxt not valid", __func__);
d1150 1
a1150 1
		fatal("%s: bad key, not previously allowed", __func__);
d1152 1
a1152 1
		fatal("%s: key type mismatch", __func__);
d1154 1
a1154 1
		fatal("%s: received bad key", __func__);
d1163 1
a1163 1
	debug3("%s sending reply", __func__);
d1178 1
a1178 1
	debug3("%s entering", __func__);
d1181 1
a1181 1
		fatal("%s: authctxt not valid", __func__);
d1183 1
a1183 1
		fatal("%s: no ssh1_challenge", __func__);
d1187 1
a1187 1
		fatal("%s: bad key, not previously allowed", __func__);
d1189 1
a1189 1
		fatal("%s: key type mismatch: %d", __func__, key_blobtype);
d1191 1
a1191 1
		fatal("%s: received bad key", __func__);
d1194 1
a1194 1
		fatal("%s: received bad response to challenge", __func__);
d1220 1
a1220 1
	debug3("%s: tearing down sessions", __func__);
d1242 3
d1246 2
a1247 3
		packet_set_encryption_key(child_state.ssh1key,
		    child_state.ssh1keylen, child_state.ssh1cipher);
		xfree(child_state.ssh1key);
a1249 1
	/* for rc4 and other stateful ciphers */
d1268 1
a1268 2
	if (options.compression)
		mm_init_compression(pmonitor->m_zlib);
a1292 4
	if ((session_id2 == NULL) ||
	    (kex->session_id_len != session_id2_len) ||
	    (memcmp(kex->session_id, session_id2, session_id2_len) != 0))
		fatal("mm_get_get: internal error: bad session id");
d1324 1
a1324 1
	debug3("%s: Waiting for new keys", __func__);
a1330 2
		child_state.ssh1key = buffer_get_string(&m,
		    &child_state.ssh1keylen);
d1344 1
a1344 1
	debug3("%s: Waiting for second key", __func__);
d1358 1
a1358 1
	debug3("%s: Getting compression state", __func__);
d1362 1
a1362 1
		fatal("%s: bad request size", __func__);
d1368 1
a1368 1
		fatal("%s: bad request size", __func__);
d1373 1
a1373 1
	debug3("%s: Getting Network I/O buffers", __func__);
d1421 1
a1421 1
		fatal("%s: socketpair", __func__);
d1442 2
a1443 3
	if (options.compression) {
		mon->m_zback = mm_create(NULL, MM_MEMSIZE);
		mon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);
d1445 2
a1446 3
		/* Compression needs to share state across borders */
		mm_init_compression(mon->m_zlib);
	}
@


1.11.2.3
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.11.2.2 2002/06/22 07:23:17 miod Exp $");
a946 2
	auth_method = key_blobtype == MM_USERKEY ? "publickey" : "hostbased";

d953 2
a1420 1
	int len = size * ncount;
d1423 1
a1423 4
	if (len <= 0)
		fatal("%s: mm_zalloc(%u, %u)", __func__, ncount, size);

	address = mm_malloc(mm, len);
@


1.11.2.4
log
@Update to OpenSSH 3.5
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.29 2002/09/26 11:38:43 markus Exp $");
a118 7
#ifdef KRB4
int mm_answer_krb4(int, Buffer *);
#endif
#ifdef KRB5
int mm_answer_krb5(int, Buffer *);
#endif

d126 2
a127 2
static char *hostbased_cuser = NULL;
static char *hostbased_chost = NULL;
a191 6
#ifdef KRB4
    {MONITOR_REQ_KRB4, MON_ONCE|MON_AUTH, mm_answer_krb4},
#endif
#ifdef KRB5
    {MONITOR_REQ_KRB5, MON_ONCE|MON_AUTH, mm_answer_krb5},
#endif
d444 1
a444 1
		fatal("%s: data length incorrect: %u", __func__, datlen);
d458 1
a458 1
	debug3("%s: signature %p(%u)", __func__, signature, siglen);
d543 1
a543 1
		xfree(banner);
d571 1
a571 2
	int authenticated;
	u_int plen;
d718 1
a718 2
	char *cuser, *chost;
	u_char *blob;
d794 1
a794 1
	char *p;
d847 2
a848 2
monitor_valid_hostbasedblob(u_char *data, u_int datalen, char *cuser,
    char *chost)
d851 1
a851 1
	char *p;
a968 1
	fromlen = sizeof(from);
d970 1
d980 1
a980 1
	    (struct sockaddr *)&from, fromlen);
a1243 83
#ifdef KRB4
int
mm_answer_krb4(int socket, Buffer *m)
{
	KTEXT_ST auth, reply;
	char  *client, *p;
	int success;
	u_int alen;

	reply.length = auth.length = 0;
 
	p = buffer_get_string(m, &alen);
	if (alen >=  MAX_KTXT_LEN)
		 fatal("%s: auth too large", __func__);
	memcpy(auth.dat, p, alen);
	auth.length = alen;
	memset(p, 0, alen);
	xfree(p);

	success = options.kerberos_authentication &&
	    authctxt->valid &&
	    auth_krb4(authctxt, &auth, &client, &reply);

	memset(auth.dat, 0, alen);
	buffer_clear(m);
	buffer_put_int(m, success);

	if (success) {
		buffer_put_cstring(m, client);
		buffer_put_string(m, reply.dat, reply.length);
		if (client)
			xfree(client);
		if (reply.length)
			memset(reply.dat, 0, reply.length);
	}

	debug3("%s: sending result %d", __func__, success);
	mm_request_send(socket, MONITOR_ANS_KRB4, m);

	auth_method = "kerberos";

	/* Causes monitor loop to terminate if authenticated */
	return (success);
}
#endif

#ifdef KRB5
int
mm_answer_krb5(int socket, Buffer *m)
{
	krb5_data tkt, reply;
	char *client_user;
	u_int len;
	int success;

	/* use temporary var to avoid size issues on 64bit arch */
	tkt.data = buffer_get_string(m, &len);
	tkt.length = len;

	success = options.kerberos_authentication &&
	    authctxt->valid &&
	    auth_krb5(authctxt, &tkt, &client_user, &reply);

	if (tkt.length)
		xfree(tkt.data);

	buffer_clear(m);
	buffer_put_int(m, success);

	if (success) {
		buffer_put_cstring(m, client_user);
		buffer_put_string(m, reply.data, reply.length);
		if (client_user)
			xfree(client_user);
		if (reply.length)
			xfree(reply.data);
	}
	mm_request_send(socket, MONITOR_ANS_KRB5, m);

	return success;
}
#endif

d1421 1
a1421 1
	size_t len = size * ncount;
d1424 1
a1424 1
	if (len == 0 || ncount > SIZE_T_MAX / size)
@


1.10
log
@Fix sshd Banner option for privsep; ok markus@@ provos@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.9 2002/03/30 18:51:15 markus Exp $");
d230 1
a230 1
monitor_child_preauth(struct monitor *monitor)
d253 1
a253 1
		authenticated = monitor_read(monitor, mon_dispatch, &ent);
d277 1
a277 1
	mm_get_keystate(monitor);
d283 1
a283 1
monitor_child_postauth(struct monitor *monitor)
d303 1
a303 1
		monitor_read(monitor, mon_dispatch, NULL);
d307 1
a307 1
monitor_sync(struct monitor *monitor)
d310 1
a310 1
	mm_share_sync(&monitor->m_zlib, &monitor->m_zback);
d314 1
a314 1
monitor_read(struct monitor *monitor, struct mon_table *ent,
d323 1
a323 1
	mm_request_receive(monitor->m_sendfd, &m);
d338 1
a338 1
		ret = (*ent->f)(monitor->m_sendfd, &m);
d968 1
a968 1
	extern struct monitor *monitor;
d980 1
a980 1
	s->pid = monitor->m_pid;
d1217 1
a1217 1
	extern struct monitor *monitor;
d1225 1
a1225 1
	while (waitpid(monitor->m_pid, &status, 0) == -1)
d1236 1
a1236 1
monitor_apply_keystate(struct monitor *monitor)
d1268 1
a1268 1
	mm_init_compression(monitor->m_zlib);
d1318 1
a1318 1
mm_get_keystate(struct monitor *monitor)
d1327 1
a1327 1
	mm_request_receive_expect(monitor->m_sendfd, MONITOR_REQ_KEYEXPORT, &m);
d1337 1
a1337 1
		*monitor->m_pkex = mm_get_kex(&m);
@


1.9
log
@check waitpid for EINTR; based on patch from peter@@ifm.liu.se
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.8 2002/03/27 17:45:42 mouring Exp $");
d99 1
d147 1
d510 1
a510 1
	else
d513 15
d529 2
@


1.9.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.11 2002/05/15 15:47:49 mouring Exp $");
a98 1
int mm_answer_auth2_read_banner(int, Buffer *);
a145 1
    {MONITOR_REQ_AUTH2_READ_BANNER, MON_ONCE, mm_answer_auth2_read_banner},
d228 1
a228 1
monitor_child_preauth(struct monitor *pmonitor)
d251 1
a251 1
		authenticated = monitor_read(pmonitor, mon_dispatch, &ent);
d275 1
a275 1
	mm_get_keystate(pmonitor);
d281 1
a281 1
monitor_child_postauth(struct monitor *pmonitor)
d301 1
a301 1
		monitor_read(pmonitor, mon_dispatch, NULL);
d305 1
a305 1
monitor_sync(struct monitor *pmonitor)
d308 1
a308 1
	mm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);
d312 1
a312 1
monitor_read(struct monitor *pmonitor, struct mon_table *ent,
d321 1
a321 1
	mm_request_receive(pmonitor->m_sendfd, &m);
d336 1
a336 1
		ret = (*ent->f)(pmonitor->m_sendfd, &m);
d508 1
a508 1
	else {
a510 15
		monitor_permit(mon_dispatch, MONITOR_REQ_AUTH2_READ_BANNER, 1);
	}


	return (0);
}

int mm_answer_auth2_read_banner(int socket, Buffer *m)
{
	char *banner;

	buffer_clear(m);
	banner = auth2_read_banner();
	buffer_put_cstring(m, banner != NULL ? banner : "");
	mm_request_send(socket, MONITOR_ANS_AUTH2_READ_BANNER, m);
a511 2
	if (banner != NULL)
		free(banner);
d949 1
a949 1
	extern struct monitor *pmonitor;
d961 1
a961 1
	s->pid = pmonitor->m_pid;
d1198 1
a1198 1
	extern struct monitor *pmonitor;
d1206 1
a1206 1
	while (waitpid(pmonitor->m_pid, &status, 0) == -1)
d1217 1
a1217 1
monitor_apply_keystate(struct monitor *pmonitor)
d1249 1
a1249 1
	mm_init_compression(pmonitor->m_zlib);
d1299 1
a1299 1
mm_get_keystate(struct monitor *pmonitor)
d1308 1
a1308 1
	mm_request_receive_expect(pmonitor->m_sendfd, MONITOR_REQ_KEYEXPORT, &m);
d1318 1
a1318 1
		*pmonitor->m_pkex = mm_get_kex(&m);
@


1.9.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.9.2.3
log
@Pull in OpenSSH-3.4
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.18 2002/06/26 13:20:57 deraadt Exp $");
a85 2
	u_char *ssh1key;
	u_int ssh1keylen;
a126 2
static int session_id2_len = 0;
static u_char *session_id2 = NULL;
d257 1
a257 1
				    __func__, ent->type);
d272 1
a272 1
		fatal("%s: authenticated invalid user", __func__);
d275 1
a275 1
	    __func__, authctxt->user);
d309 2
a310 4
	if (options.compression) {
		/* The member allocation is not visible, so sync it */
		mm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);
	}
d326 1
a326 1
	debug3("%s: checking request %d", __func__, type);
d336 1
a336 1
			fatal("%s: unpermitted request %d", __func__,
d343 1
a343 1
			debug2("%s: %d used once, disabling now", __func__,
d354 1
a354 1
	fatal("%s: unsupported request: %d", __func__, type);
d399 1
a399 1
	    __func__, min, want, max);
d403 1
a403 1
		    __func__, min, want, max);
d432 1
a432 1
	debug3("%s", __func__);
d438 1
a438 8
		fatal("%s: data length incorrect: %d", __func__, datlen);

	/* save session id, it will be passed on the first call */
	if (session_id2_len == 0) {
		session_id2_len = datlen;
		session_id2 = xmalloc(session_id2_len);
		memcpy(session_id2, p, session_id2_len);
	}
d441 1
a441 1
		fatal("%s: no hostkey from index %d", __func__, keyid);
d443 1
a443 1
		fatal("%s: key_sign failed", __func__);
d445 1
a445 1
	debug3("%s: signature %p(%d)", __func__, signature, siglen);
d470 1
a470 1
	debug3("%s", __func__);
d473 1
a473 1
		fatal("%s: multiple attempts for getpwnam", __func__);
d504 1
a504 1
	debug3("%s: sending MONITOR_ANS_PWNAM: %d", __func__, allowed);
d543 1
a543 1
	    __func__, authctxt->service, authctxt->style);
d562 1
a562 2
	authenticated = options.password_authentication &&
	    authctxt->valid && auth_password(authctxt, passwd);
d569 1
a569 1
	debug3("%s: sending result %d", __func__, authenticated);
d600 1
a600 1
	debug3("%s: sending challenge res: %d", __func__, res);
d620 1
a620 1
		fatal("%s: no bsd auth session", __func__);
d623 1
a623 2
	authok = options.challenge_response_authentication &&
	    auth_userresponse(authctxt->as, response, 0);
d625 1
a625 1
	debug3("%s: <%s> = <%d>", __func__, response, authok);
d631 1
a631 1
	debug3("%s: sending authenticated: %d", __func__, authok);
d655 1
a655 1
	debug3("%s: sending challenge res: %d", __func__, res);
d669 1
a669 2
	authok = (options.challenge_response_authentication &&
	    authctxt->valid &&
d678 1
a678 1
	debug3("%s: sending authenticated: %d", __func__, authok);
d691 1
a691 1
		debug3("%s: Appending debug messages for child", __func__);
d707 1
a707 1
	debug3("%s entering", __func__);
d718 1
a718 1
		fatal("%s: key type and protocol mismatch", __func__);
d720 1
a720 1
	debug3("%s: key_from_blob: %p", __func__, key);
d725 1
a725 2
			allowed = options.pubkey_authentication &&
			    user_key_allowed(authctxt->pw, key);
d728 1
a728 2
			allowed = options.hostbased_authentication &&
			    hostbased_key_allowed(authctxt->pw,
d733 1
a733 2
			allowed = options.rhosts_rsa_authentication &&
			    auth_rhosts_rsa_key_allowed(authctxt->pw,
d737 1
a737 1
			fatal("%s: unknown key type %d", __func__, type);
d756 1
a756 1
	    __func__, key, allowed ? "allowed" : "disallowed");
d778 1
a783 6
		p = buffer_ptr(&b);
		len = buffer_len(&b);
		if ((session_id2 == NULL) ||
		    (len < session_id2_len) ||
		    (memcmp(p, session_id2, session_id2_len) != 0))
			fail++;
d786 2
a787 4
		p = buffer_get_string(&b, &len);
		if ((session_id2 == NULL) ||
		    (len != session_id2_len) ||
		    (memcmp(p, session_id2, session_id2_len) != 0))
a788 1
		xfree(p);
d827 1
d832 2
a833 4
	p = buffer_get_string(&b, &len);
	if ((session_id2 == NULL) ||
	    (len != session_id2_len) ||
	    (memcmp(p, session_id2, session_id2_len) != 0))
a834 2
	xfree(p);

d887 1
a887 1
		fatal("%s: bad key, not previously allowed", __func__);
d891 1
a891 1
		fatal("%s: bad public key blob", __func__);
d906 1
a906 1
		fatal("%s: bad signature data blob", __func__);
d910 1
a910 1
	    __func__, key, verified ? "verified" : "unverified");
a916 2
	auth_method = key_blobtype == MM_USERKEY ? "publickey" : "hostbased";

d923 2
d956 1
a956 1
	debug3("%s: session %d pid %d", __func__, s->self, s->pid);
d958 1
a958 1
		debug3("%s: tty %s ptyfd %d",  __func__, s->tty, s->ptyfd);
d972 1
a972 1
	debug3("%s entering", __func__);
d996 1
a996 1
		fatal("%s: dup2", __func__);
d1005 1
a1005 1
		fatal("%s: open(/dev/null): %s", __func__, strerror(errno));
d1007 1
a1007 1
		error("%s: fd0 %d != 0", __func__, fd0);
d1015 1
a1015 1
	debug3("%s: tty %s ptyfd %d",  __func__, s->tty, s->ttyfd);
d1033 1
a1033 1
	debug3("%s entering", __func__);
d1053 1
a1053 1
		fatal("%s: BN_new", __func__);
d1078 1
a1078 1
	debug3("%s entering", __func__);
d1081 1
a1081 1
		fatal("%s: bad ssh1 session id", __func__);
d1100 1
a1100 1
	debug3("%s entering", __func__);
d1102 1
a1102 1
	if (options.rsa_authentication && authctxt->valid) {
d1104 1
a1104 1
			fatal("%s: BN_new", __func__);
d1118 1
a1118 1
			fatal("%s: key_to_blob failed", __func__);
d1144 1
a1144 1
	debug3("%s entering", __func__);
d1147 1
a1147 1
		fatal("%s: authctxt not valid", __func__);
d1150 1
a1150 1
		fatal("%s: bad key, not previously allowed", __func__);
d1152 1
a1152 1
		fatal("%s: key type mismatch", __func__);
d1154 1
a1154 1
		fatal("%s: received bad key", __func__);
d1163 1
a1163 1
	debug3("%s sending reply", __func__);
d1178 1
a1178 1
	debug3("%s entering", __func__);
d1181 1
a1181 1
		fatal("%s: authctxt not valid", __func__);
d1183 1
a1183 1
		fatal("%s: no ssh1_challenge", __func__);
d1187 1
a1187 1
		fatal("%s: bad key, not previously allowed", __func__);
d1189 1
a1189 1
		fatal("%s: key type mismatch: %d", __func__, key_blobtype);
d1191 1
a1191 1
		fatal("%s: received bad key", __func__);
d1194 1
a1194 1
		fatal("%s: received bad response to challenge", __func__);
d1220 1
a1220 1
	debug3("%s: tearing down sessions", __func__);
d1242 3
d1246 2
a1247 3
		packet_set_encryption_key(child_state.ssh1key,
		    child_state.ssh1keylen, child_state.ssh1cipher);
		xfree(child_state.ssh1key);
a1249 1
	/* for rc4 and other stateful ciphers */
d1268 1
a1268 2
	if (options.compression)
		mm_init_compression(pmonitor->m_zlib);
a1292 4
	if ((session_id2 == NULL) ||
	    (kex->session_id_len != session_id2_len) ||
	    (memcmp(kex->session_id, session_id2, session_id2_len) != 0))
		fatal("mm_get_get: internal error: bad session id");
d1324 1
a1324 1
	debug3("%s: Waiting for new keys", __func__);
a1330 2
		child_state.ssh1key = buffer_get_string(&m,
		    &child_state.ssh1keylen);
d1344 1
a1344 1
	debug3("%s: Waiting for second key", __func__);
d1358 1
a1358 1
	debug3("%s: Getting compression state", __func__);
d1362 1
a1362 1
		fatal("%s: bad request size", __func__);
d1368 1
a1368 1
		fatal("%s: bad request size", __func__);
d1373 1
a1373 1
	debug3("%s: Getting Network I/O buffers", __func__);
a1384 1
	int len = size * ncount;
d1387 1
a1387 4
	if (len <= 0)
		fatal("%s: mm_zalloc(%u, %u)", __func__, ncount, size);

	address = mm_malloc(mm, len);
d1421 1
a1421 1
		fatal("%s: socketpair", __func__);
d1442 2
a1443 3
	if (options.compression) {
		mon->m_zback = mm_create(NULL, MM_MEMSIZE);
		mon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);
d1445 2
a1446 3
		/* Compression needs to share state across borders */
		mm_init_compression(mon->m_zlib);
	}
@


1.9.2.4
log
@Update to OpenSSH 3.5
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.29 2002/09/26 11:38:43 markus Exp $");
a118 7
#ifdef KRB4
int mm_answer_krb4(int, Buffer *);
#endif
#ifdef KRB5
int mm_answer_krb5(int, Buffer *);
#endif

d126 2
a127 2
static char *hostbased_cuser = NULL;
static char *hostbased_chost = NULL;
a191 6
#ifdef KRB4
    {MONITOR_REQ_KRB4, MON_ONCE|MON_AUTH, mm_answer_krb4},
#endif
#ifdef KRB5
    {MONITOR_REQ_KRB5, MON_ONCE|MON_AUTH, mm_answer_krb5},
#endif
d444 1
a444 1
		fatal("%s: data length incorrect: %u", __func__, datlen);
d458 1
a458 1
	debug3("%s: signature %p(%u)", __func__, signature, siglen);
d543 1
a543 1
		xfree(banner);
d571 1
a571 2
	int authenticated;
	u_int plen;
d718 1
a718 2
	char *cuser, *chost;
	u_char *blob;
d794 1
a794 1
	char *p;
d847 2
a848 2
monitor_valid_hostbasedblob(u_char *data, u_int datalen, char *cuser,
    char *chost)
d851 1
a851 1
	char *p;
a968 1
	fromlen = sizeof(from);
d970 1
d980 1
a980 1
	    (struct sockaddr *)&from, fromlen);
a1243 83
#ifdef KRB4
int
mm_answer_krb4(int socket, Buffer *m)
{
	KTEXT_ST auth, reply;
	char  *client, *p;
	int success;
	u_int alen;

	reply.length = auth.length = 0;
 
	p = buffer_get_string(m, &alen);
	if (alen >=  MAX_KTXT_LEN)
		 fatal("%s: auth too large", __func__);
	memcpy(auth.dat, p, alen);
	auth.length = alen;
	memset(p, 0, alen);
	xfree(p);

	success = options.kerberos_authentication &&
	    authctxt->valid &&
	    auth_krb4(authctxt, &auth, &client, &reply);

	memset(auth.dat, 0, alen);
	buffer_clear(m);
	buffer_put_int(m, success);

	if (success) {
		buffer_put_cstring(m, client);
		buffer_put_string(m, reply.dat, reply.length);
		if (client)
			xfree(client);
		if (reply.length)
			memset(reply.dat, 0, reply.length);
	}

	debug3("%s: sending result %d", __func__, success);
	mm_request_send(socket, MONITOR_ANS_KRB4, m);

	auth_method = "kerberos";

	/* Causes monitor loop to terminate if authenticated */
	return (success);
}
#endif

#ifdef KRB5
int
mm_answer_krb5(int socket, Buffer *m)
{
	krb5_data tkt, reply;
	char *client_user;
	u_int len;
	int success;

	/* use temporary var to avoid size issues on 64bit arch */
	tkt.data = buffer_get_string(m, &len);
	tkt.length = len;

	success = options.kerberos_authentication &&
	    authctxt->valid &&
	    auth_krb5(authctxt, &tkt, &client_user, &reply);

	if (tkt.length)
		xfree(tkt.data);

	buffer_clear(m);
	buffer_put_int(m, success);

	if (success) {
		buffer_put_cstring(m, client_user);
		buffer_put_string(m, reply.data, reply.length);
		if (client_user)
			xfree(client_user);
		if (reply.length)
			xfree(reply.data);
	}
	mm_request_send(socket, MONITOR_ANS_KRB5, m);

	return success;
}
#endif

d1421 1
a1421 1
	size_t len = size * ncount;
d1424 1
a1424 1
	if (len == 0 || ncount > SIZE_T_MAX / size)
@


1.9.2.5
log
@Merge OpenSSH 3.6.1
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.36 2003/04/01 10:22:21 markus Exp $");
d618 1
a618 1
	u_int success;
d620 2
a621 2
	success = bsdauth_query(authctxt, &name, &infotxt, &numprompts,
	    &prompts, &echo_on) < 0 ? 0 : 1;
d624 2
a625 2
	buffer_put_int(m, success);
	if (success)
d628 1
a628 1
	debug3("%s: sending challenge success: %u", __func__, success);
d631 1
a631 1
	if (success) {
d675 1
a675 1
	u_int success;
d677 1
a677 1
	success = skeychallenge(&skey, authctxt->user, challenge) < 0 ? 0 : 1;
d680 2
a681 2
	buffer_put_int(m, success);
	if (success)
d684 1
a684 1
	debug3("%s: sending challenge success: %u", __func__, success);
d774 1
a775 2
	if (key != NULL)
		key_free(key);
a793 1
	buffer_put_int(m, forced_command != NULL);
a1155 1
	buffer_put_int(m, forced_command != NULL);
d1170 1
a1171 2
	if (key != NULL)
		key_free(key);
a1211 3

	xfree(blob);
	key_free(key);
a1241 1
	xfree(blob);
a1425 2
	kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;
	kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;
d1519 1
a1519 1
	size_t len = (size_t) size * ncount;
@


1.8
log
@monitor_allowed_key() returns int instead of pointer.  ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.7 2002/03/24 23:20:00 stevesk Exp $");
d1206 3
a1208 2
	if (waitpid(monitor->m_pid, &status, 0) == -1)
		exit(1);
@


1.7
log
@remove "\n" from fatal()
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.6 2002/03/21 18:38:33 stevesk Exp $");
d867 1
a867 1
	   monitor_allowed_key(blob, bloblen) == NULL)
@


1.6
log
@fix NULL %s on debug3(); ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.5 2002/03/19 21:12:48 markus Exp $");
d352 1
a352 1
	fatal("%s: unsupported request: %d\n", __FUNCTION__, type);
@


1.5
log
@use SSH_SESSION_KEY_LENGTH for key length
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.4 2002/03/19 14:27:39 markus Exp $");
d523 3
a529 3

	debug3("%s: service=%s, style=%s",
	    __FUNCTION__, authctxt->service, authctxt->style);
@


1.4
log
@make getpwnamallow() allways call pwcopy()
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.3 2002/03/19 10:41:32 markus Exp $");
a1146 1

d1222 3
a1224 1
		u_char key[256];
@


1.3
log
@whitespace KNF
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.2 2002/03/19 10:35:39 markus Exp $");
d489 1
a489 1
	authctxt->pw = pwcopy(pwent);
@


1.2
log
@clean up prototypes
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor.c,v 1.1 2002/03/18 17:28:37 provos Exp $");
d348 1
a348 1
		
d352 1
a352 1
	fatal("%s: unsupported request: %d\n", __FUNCTION__, type); 
d414 1
a414 1
		
d429 1
a429 1
	
d432 2
a433 2
	keyid = buffer_get_int(m);	
	p = buffer_get_string(m, &datlen);	
d467 1
a467 1
	
d689 1
a689 1
	
d763 1
a763 1
	
d812 1
a812 1
	
d899 1
a899 1
		
d1077 2
a1078 2
        u_char *blob = NULL;
        u_int blen = 0;
d1122 2
a1123 2
        u_char *blob;
        u_int blen;
d1156 3
a1158 3
        u_char *blob, *response;
        u_int blen, len;
        int success;
d1245 1
a1245 1
	
d1327 1
a1327 1
	
d1398 1
a1398 1
{   
@


1.1
log
@implementation of the interface between privileged and unprivileged process
for ssh-privsep
@
text
@d28 1
a28 1
RCSID("$OpenBSD$");
a93 25
/* Prototypes for request sending and receiving */
void mm_request_send(int, enum monitor_reqtype, Buffer *);
void mm_request_receive(int, Buffer *);
void mm_request_receive_expect(int, enum monitor_reqtype, Buffer *);

/* Prototypes for authentication functions */
int bsdauth_query(void *, char **, char **, u_int *, char ***, u_int **);
int bsdauth_respond(void *, u_int, char **);
int skey_query(void *, char **, char **, u_int *, char ***, u_int **);
int skey_respond(void *, u_int, char **);

int auth_rhosts_rsa_key_allowed(struct passwd *, char *, char *, Key *);
int hostbased_key_allowed(struct passwd *, const char *, char *, Key *);
int user_key_allowed(struct passwd *, Key *);
Key *get_hostkey_by_index(int);
Key *get_hostkey_by_type(int);
int get_hostkey_index(Key *);
int ssh1_session_key(BIGNUM *);
int auth_rsa_key_allowed(struct passwd *, BIGNUM *, Key **);
int auth_rsa_verify_response(Key *, BIGNUM *, u_char *);
BIGNUM *auth_rsa_generate_challenge(Key *);

void	session_pty_cleanup2(void *);
Session	*session_by_tty(char *);

d668 1
a668 1
void
d909 1
a909 1
void
d1262 1
a1262 1
Kex *
d1396 1
a1396 1
void
@

