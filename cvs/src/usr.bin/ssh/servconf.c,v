head	1.307;
access;
symbols
	OPENBSD_6_1:1.306.0.4
	OPENBSD_6_1_BASE:1.306
	OPENBSD_6_0:1.292.0.4
	OPENBSD_6_0_BASE:1.292
	OPENBSD_5_9:1.285.0.2
	OPENBSD_5_9_BASE:1.285
	OPENBSD_5_8:1.280.0.4
	OPENBSD_5_8_BASE:1.280
	OPENBSD_5_7:1.260.0.2
	OPENBSD_5_7_BASE:1.260
	OPENBSD_5_6:1.251.0.4
	OPENBSD_5_6_BASE:1.251
	OPENBSD_5_5:1.249.0.4
	OPENBSD_5_5_BASE:1.249
	OPENBSD_5_4:1.240.0.2
	OPENBSD_5_4_BASE:1.240
	OPENBSD_5_3:1.234.0.2
	OPENBSD_5_3_BASE:1.234
	OPENBSD_5_2:1.229.0.2
	OPENBSD_5_2_BASE:1.229
	OPENBSD_5_1_BASE:1.223
	OPENBSD_5_1:1.223.0.2
	OPENBSD_5_0:1.222.0.2
	OPENBSD_5_0_BASE:1.222
	OPENBSD_4_9:1.213.0.2
	OPENBSD_4_9_BASE:1.213
	OPENBSD_4_8:1.209.0.2
	OPENBSD_4_8_BASE:1.209
	OPENBSD_4_7:1.206.0.2
	OPENBSD_4_7_BASE:1.206
	OPENBSD_4_6:1.195.0.4
	OPENBSD_4_6_BASE:1.195
	OPENBSD_4_5:1.194.0.2
	OPENBSD_4_5_BASE:1.194
	OPENBSD_4_4:1.187.0.2
	OPENBSD_4_4_BASE:1.187
	OPENBSD_4_3:1.177.0.2
	OPENBSD_4_3_BASE:1.177
	OPENBSD_4_2:1.172.0.2
	OPENBSD_4_2_BASE:1.172
	OPENBSD_4_1:1.171.0.2
	OPENBSD_4_1_BASE:1.171
	OPENBSD_4_0:1.165.0.4
	OPENBSD_4_0_BASE:1.165
	OPENBSD_3_9:1.146.0.2
	OPENBSD_3_9_BASE:1.146
	OPENBSD_3_8:1.144.0.2
	OPENBSD_3_8_BASE:1.144
	OPENBSD_3_7:1.140.0.2
	OPENBSD_3_7_BASE:1.140
	OPENBSD_3_6:1.137.0.2
	OPENBSD_3_6_BASE:1.137
	OPENBSD_3_5:1.130.0.2
	OPENBSD_3_5_BASE:1.130
	OPENBSD_3_4:1.127.0.2
	OPENBSD_3_4_BASE:1.127
	OPENBSD_3_3:1.116.0.2
	OPENBSD_3_3_BASE:1.116
	OPENBSD_3_2:1.115.0.2
	OPENBSD_3_2_BASE:1.115
	OPENBSD_3_1:1.105.0.2
	OPENBSD_3_1_BASE:1.105
	OPENBSD_3_0:1.89.0.2
	OPENBSD_3_0_BASE:1.89
	OPENBSD_2_9_BASE:1.78
	OPENBSD_2_9:1.78.0.2
	OPENBSD_2_8:1.53.0.2
	OPENBSD_2_8_BASE:1.53
	OPENBSD_2_7:1.40.0.2
	OPENBSD_2_7_BASE:1.40
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18;
locks; strict;
comment	@ * @;


1.307
date	2017.04.27.13.40.05;	author jsg;	state Exp;
branches;
next	1.306;
commitid	Y7fr5fVEL7Q5vCNc;

1.306
date	2017.03.14.07.19.07;	author djm;	state Exp;
branches;
next	1.305;
commitid	8voftiXioCcRXNLn;

1.305
date	2017.03.10.04.11.00;	author dtucker;	state Exp;
branches;
next	1.304;
commitid	TBVigsZM1I0u2r6k;

1.304
date	2017.02.03.23.01.19;	author djm;	state Exp;
branches;
next	1.303;
commitid	0GOZFYpYrdIWnKZ0;

1.303
date	2017.02.03.05.05.56;	author djm;	state Exp;
branches;
next	1.302;
commitid	qxeDJqCIRUEP0iRm;

1.302
date	2017.01.06.03.45.41;	author djm;	state Exp;
branches;
next	1.301;
commitid	XfW9B88cCwDb4WFK;

1.301
date	2016.11.30.03.00.05;	author djm;	state Exp;
branches;
next	1.300;
commitid	JiLWdRxWiRohf4cK;

1.300
date	2016.11.23.23.14.15;	author markus;	state Exp;
branches;
next	1.299;
commitid	oBjoddV5KGDr8Ojg;

1.299
date	2016.11.06.05.46.37;	author djm;	state Exp;
branches;
next	1.298;
commitid	poSnZnjhu4JbUKhm;

1.298
date	2016.10.24.01.09.17;	author dtucker;	state Exp;
branches;
next	1.297;
commitid	MJFfHa9b7vv0jkV8;

1.297
date	2016.09.28.20.32.42;	author djm;	state Exp;
branches;
next	1.296;
commitid	TvNoQIkfkdH4jhbD;

1.296
date	2016.09.28.16.33.07;	author djm;	state Exp;
branches;
next	1.295;
commitid	e2NJzal9PUi2o22D;

1.295
date	2016.08.25.23.57.54;	author djm;	state Exp;
branches;
next	1.294;
commitid	7h5sBtJtsQeYWYfF;

1.294
date	2016.08.19.03.18.06;	author djm;	state Exp;
branches;
next	1.293;
commitid	o9ZQ52UJzA8fd7BT;

1.293
date	2016.08.15.12.27.56;	author naddy;	state Exp;
branches;
next	1.292;
commitid	Xx3KKNu5BoFBkpj3;

1.292
date	2016.06.23.05.17.51;	author djm;	state Exp;
branches;
next	1.291;
commitid	cJr7keQphCP6j1P0;

1.291
date	2016.06.17.05.03.40;	author djm;	state Exp;
branches;
next	1.290;
commitid	Hgqc707nYXAjPP1S;

1.290
date	2016.05.04.14.00.09;	author dtucker;	state Exp;
branches;
next	1.289;
commitid	sdgDjd3YM32hkELQ;

1.289
date	2016.05.03.15.57.39;	author djm;	state Exp;
branches;
next	1.288;
commitid	yYkBhlo1LWN7eGMA;

1.288
date	2016.05.03.15.25.06;	author djm;	state Exp;
branches;
next	1.287;
commitid	cP8YJMKHqQGdXh64;

1.287
date	2016.05.02.08.49.03;	author djm;	state Exp;
branches;
next	1.286;
commitid	RYYIr1bk0phq4fXa;

1.286
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.285;
commitid	kr9hjdmg99uVnhW2;

1.285
date	2016.02.17.05.29.04;	author djm;	state Exp;
branches;
next	1.284;
commitid	IBHjXOGc95SREt0K;

1.284
date	2016.01.29.02.54.45;	author dtucker;	state Exp;
branches;
next	1.283;
commitid	PeK9nimTzIqJuIOX;

1.283
date	2015.11.13.04.38.06;	author djm;	state Exp;
branches;
next	1.282;
commitid	b3QitcgFmOdfJbLp;

1.282
date	2015.10.29.08.05.01;	author djm;	state Exp;
branches;
next	1.281;
commitid	AzwW8SzUyP9rSsr5;

1.281
date	2015.08.21.23.52.30;	author djm;	state Exp;
branches;
next	1.280;
commitid	zb4WFI2fubazHrZC;

1.280
date	2015.08.06.14.53.21;	author deraadt;	state Exp;
branches;
next	1.279;
commitid	Mw9TxvBajPRImAX3;

1.279
date	2015.07.31.15.38.09;	author chris;	state Exp;
branches;
next	1.278;
commitid	6FanXloZeKDfZAK9;

1.278
date	2015.07.30.19.23.02;	author deraadt;	state Exp;
branches;
next	1.277;
commitid	nDkcBheb37MVyV72;

1.277
date	2015.07.30.00.01.34;	author djm;	state Exp;
branches;
next	1.276;
commitid	YReS3Mui4FCZvL7z;

1.276
date	2015.07.10.06.21.53;	author markus;	state Exp;
branches;
next	1.275;
commitid	iQTtbsbSVdO9zivU;

1.275
date	2015.07.01.02.39.06;	author djm;	state Exp;
branches;
next	1.274;
commitid	RUtG2z9Sz9o6TWGV;

1.274
date	2015.07.01.02.32.17;	author djm;	state Exp;
branches;
next	1.273;
commitid	x7gV75FEYkBuBIXr;

1.273
date	2015.07.01.01.56.13;	author djm;	state Exp;
branches;
next	1.272;
commitid	dQm0QGz3v5OpYbF2;

1.272
date	2015.07.01.01.55.00;	author djm;	state Exp;
branches;
next	1.271;
commitid	1Xvmu7HKLfIkivVO;

1.271
date	2015.05.22.03.50.02;	author djm;	state Exp;
branches;
next	1.270;
commitid	FvDetWtDGSVa4xnt;

1.270
date	2015.05.21.06.43.30;	author djm;	state Exp;
branches;
next	1.269;
commitid	0jtBXwojTXMGT6Vz;

1.269
date	2015.05.04.06.10.48;	author djm;	state Exp;
branches;
next	1.268;
commitid	KfZDG8r2EByk0YBR;

1.268
date	2015.05.01.07.08.08;	author djm;	state Exp;
branches;
next	1.267;
commitid	5fozl3QaZtcIvPSh;

1.267
date	2015.05.01.04.17.51;	author djm;	state Exp;
branches;
next	1.266;
commitid	3a9gRigFyICUTZQy;

1.266
date	2015.04.29.03.48.56;	author dtucker;	state Exp;
branches;
next	1.265;
commitid	8c7S03ez3xfusEB2;

1.265
date	2015.04.27.21.42.48;	author djm;	state Exp;
branches;
next	1.264;
commitid	l1H7sxJoWUTQsdIC;

1.264
date	2015.04.24.01.36.00;	author deraadt;	state Exp;
branches;
next	1.263;
commitid	LHkUmZjv49ojnnuH;

1.263
date	2015.04.23.04.59.10;	author dtucker;	state Exp;
branches;
next	1.262;
commitid	4Rj1EQ0uCNqDMZ2V;

1.262
date	2015.04.23.04.53.53;	author dtucker;	state Exp;
branches;
next	1.261;
commitid	ESPQGtveinK2Fm22;

1.261
date	2015.04.17.04.12.35;	author dtucker;	state Exp;
branches;
next	1.260;
commitid	WYc1g9FkaE8yKQse;

1.260
date	2015.02.02.01.57.44;	author deraadt;	state Exp;
branches;
next	1.259;
commitid	6iy2nlrHaRwvSwhx;

1.259
date	2015.01.16.06.40.12;	author deraadt;	state Exp;
branches;
next	1.258;
commitid	Uu5nFG3wCl0LACBb;

1.258
date	2015.01.13.07.39.19;	author djm;	state Exp;
branches;
next	1.257;
commitid	oriBpre3xTnTQZ4b;

1.257
date	2014.12.22.07.55.51;	author djm;	state Exp;
branches;
next	1.256;
commitid	Obssn4758PtR7Red;

1.256
date	2014.12.21.22.27.56;	author djm;	state Exp;
branches;
next	1.255;
commitid	EbtriidyZdsmXksl;

1.255
date	2014.11.24.03.39.22;	author jsg;	state Exp;
branches;
next	1.254;
commitid	mfFwSJsY9yDCsbNf;

1.254
date	2014.10.24.02.01.20;	author lteo;	state Exp;
branches;
next	1.253;
commitid	K0sGF4uE2LYJ8DMA;

1.253
date	2014.10.13.00.38.35;	author djm;	state Exp;
branches;
next	1.252;
commitid	eLlsdloocuZfuQ0f;

1.252
date	2014.08.19.23.58.28;	author djm;	state Exp;
branches;
next	1.251;
commitid	7LBVdO2XWr0NXWK4;

1.251
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.250;
commitid	z7plx8Gkj6l2sxem;

1.250
date	2014.07.03.22.40.43;	author djm;	state Exp;
branches;
next	1.249;
commitid	cw6lnAok4n9rxQzD;

1.249
date	2014.01.29.06.18.35;	author djm;	state Exp;
branches;
next	1.248;

1.248
date	2013.12.06.13.39.49;	author markus;	state Exp;
branches;
next	1.247;

1.247
date	2013.12.05.01.16.41;	author djm;	state Exp;
branches;
next	1.246;

1.246
date	2013.11.21.00.45.44;	author djm;	state Exp;
branches;
next	1.245;

1.245
date	2013.11.07.11.58.27;	author dtucker;	state Exp;
branches;
next	1.244;

1.244
date	2013.10.29.09.48.02;	author djm;	state Exp;
branches;
next	1.243;

1.243
date	2013.10.24.00.51.48;	author dtucker;	state Exp;
branches;
next	1.242;

1.242
date	2013.10.23.05.40.58;	author dtucker;	state Exp;
branches;
next	1.241;

1.241
date	2013.08.06.23.06.01;	author djm;	state Exp;
branches;
next	1.240;

1.240
date	2013.07.19.07.37.48;	author markus;	state Exp;
branches;
next	1.239;

1.239
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.238;

1.238
date	2013.05.16.10.44.06;	author dtucker;	state Exp;
branches;
next	1.237;

1.237
date	2013.05.16.10.43.34;	author dtucker;	state Exp;
branches;
next	1.236;

1.236
date	2013.05.16.09.12.31;	author dtucker;	state Exp;
branches;
next	1.235;

1.235
date	2013.05.16.04.09.14;	author dtucker;	state Exp;
branches;
next	1.234;

1.234
date	2013.02.06.00.20.42;	author dtucker;	state Exp;
branches;
next	1.233;

1.233
date	2012.12.02.20.46.11;	author djm;	state Exp;
branches;
next	1.232;

1.232
date	2012.11.04.11.09.15;	author djm;	state Exp;
branches;
next	1.231;

1.231
date	2012.10.30.21.29.54;	author djm;	state Exp;
branches;
next	1.230;

1.230
date	2012.09.13.23.37.36;	author dtucker;	state Exp;
branches;
next	1.229;

1.229
date	2012.07.13.01.35.21;	author dtucker;	state Exp;
branches;
next	1.228;

1.228
date	2012.07.10.02.19.15;	author djm;	state Exp;
branches;
next	1.227;

1.227
date	2012.06.19.18.25.27;	author markus;	state Exp;
branches;
next	1.226;

1.226
date	2012.05.13.01.42.32;	author dtucker;	state Exp;
branches;
next	1.225;

1.225
date	2012.04.12.02.42.32;	author djm;	state Exp;
branches;
next	1.224;

1.224
date	2012.03.29.23.54.36;	author dtucker;	state Exp;
branches;
next	1.223;

1.223
date	2011.09.23.00.22.04;	author dtucker;	state Exp;
branches;
next	1.222;

1.222
date	2011.06.22.21.57.01;	author djm;	state Exp;
branches;
next	1.221;

1.221
date	2011.06.22.21.47.28;	author djm;	state Exp;
branches;
next	1.220;

1.220
date	2011.06.17.21.47.35;	author djm;	state Exp;
branches;
next	1.219;

1.219
date	2011.05.23.03.30.07;	author djm;	state Exp;
branches;
next	1.218;

1.218
date	2011.05.20.03.25.45;	author djm;	state Exp;
branches;
next	1.217;

1.217
date	2011.05.20.02.00.19;	author dtucker;	state Exp;
branches;
next	1.216;

1.216
date	2011.05.20.00.55.02;	author djm;	state Exp;
branches;
next	1.215;

1.215
date	2011.05.11.04.47.06;	author djm;	state Exp;
branches;
next	1.214;

1.214
date	2011.03.29.18.54.17;	author stevesk;	state Exp;
branches;
next	1.213;

1.213
date	2010.11.13.23.27.50;	author djm;	state Exp;
branches;
next	1.212;

1.212
date	2010.09.30.11.04.51;	author djm;	state Exp;
branches;
next	1.211;

1.211
date	2010.09.22.05.01.29;	author djm;	state Exp;
branches;
next	1.210;

1.210
date	2010.09.01.15.21.35;	author naddy;	state Exp;
branches;
next	1.209;

1.209
date	2010.06.22.04.22.59;	author djm;	state Exp;
branches;
next	1.208;

1.208
date	2010.05.07.11.30.29;	author djm;	state Exp;
branches;
next	1.207;

1.207
date	2010.03.25.23.38.28;	author djm;	state Exp;
branches;
next	1.206;

1.206
date	2010.03.12.11.37.40;	author markus;	state Exp;
branches;
next	1.205;

1.205
date	2010.03.12.01.06.25;	author djm;	state Exp;
branches;
next	1.204;

1.204
date	2010.03.04.10.36.03;	author djm;	state Exp;
branches;
next	1.203;

1.203
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.202;

1.202
date	2010.01.13.03.48.12;	author djm;	state Exp;
branches;
next	1.201;

1.201
date	2010.01.10.03.51.17;	author dtucker;	state Exp;
branches;
next	1.200;

1.200
date	2010.01.09.23.04.13;	author dtucker;	state Exp;
branches;
next	1.199;

1.199
date	2009.12.29.16.38.41;	author stevesk;	state Exp;
branches;
next	1.198;

1.198
date	2009.12.25.19.40.21;	author stevesk;	state Exp;
branches;
next	1.197;

1.197
date	2009.10.28.16.38.18;	author reyk;	state Exp;
branches;
next	1.196;

1.196
date	2009.10.08.14.03.41;	author markus;	state Exp;
branches;
next	1.195;

1.195
date	2009.04.14.21.10.54;	author jj;	state Exp;
branches;
next	1.194;

1.194
date	2009.01.22.10.02.34;	author djm;	state Exp;
branches;
next	1.193;

1.193
date	2008.12.09.03.20.42;	author stevesk;	state Exp;
branches;
next	1.192;

1.192
date	2008.11.11.02.58.09;	author stevesk;	state Exp;
branches;
next	1.191;

1.191
date	2008.11.05.11.22.54;	author jmc;	state Exp;
branches;
next	1.190;

1.190
date	2008.11.04.08.22.13;	author djm;	state Exp;
branches;
next	1.189;

1.189
date	2008.11.03.08.59.41;	author djm;	state Exp;
branches;
next	1.188;

1.188
date	2008.10.09.03.50.54;	author djm;	state Exp;
branches;
next	1.187;

1.187
date	2008.07.23.07.36.55;	author djm;	state Exp;
branches;
next	1.186;

1.186
date	2008.07.04.03.44.59;	author djm;	state Exp;
branches;
next	1.185;

1.185
date	2008.07.02.02.24.18;	author djm;	state Exp;
branches;
next	1.184;

1.184
date	2008.06.15.16.58.40;	author dtucker;	state Exp;
branches;
next	1.183;

1.183
date	2008.06.10.23.06.19;	author djm;	state Exp;
branches;
next	1.182;

1.182
date	2008.06.10.04.50.25;	author dtucker;	state Exp;
branches;
next	1.181;

1.181
date	2008.06.10.03.57.27;	author djm;	state Exp;
branches;
next	1.180;

1.180
date	2008.05.08.12.21.16;	author djm;	state Exp;
branches;
next	1.179;

1.179
date	2008.05.08.12.02.23;	author djm;	state Exp;
branches;
next	1.178;

1.178
date	2008.05.07.05.49.37;	author pyr;	state Exp;
branches;
next	1.177;

1.177
date	2008.02.10.10.54.28;	author djm;	state Exp;
branches;
next	1.176;

1.176
date	2008.02.08.23.24.08;	author djm;	state Exp;
branches;
next	1.175;

1.175
date	2008.01.01.09.27.33;	author dtucker;	state Exp;
branches;
next	1.174;

1.174
date	2007.12.31.10.41.31;	author dtucker;	state Exp;
branches;
next	1.173;

1.173
date	2007.12.27.14.22.08;	author dtucker;	state Exp;
branches;
next	1.172;

1.172
date	2007.04.23.10.15.39;	author dtucker;	state Exp;
branches;
next	1.171;

1.171
date	2007.03.09.05.20.06;	author dtucker;	state Exp;
branches;
next	1.170;

1.170
date	2007.03.01.10.28.02;	author dtucker;	state Exp;
branches;
next	1.169;

1.169
date	2007.02.22.12.58.40;	author dtucker;	state Exp;
branches;
next	1.168;

1.168
date	2007.02.19.10.45.58;	author dtucker;	state Exp;
branches;
next	1.167;

1.167
date	2006.12.14.10.01.14;	author dtucker;	state Exp;
branches;
next	1.166;

1.166
date	2006.12.13.08.34.39;	author dtucker;	state Exp;
branches;
next	1.165;

1.165
date	2006.08.14.12.40.25;	author dtucker;	state Exp;
branches;
next	1.164;

1.164
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.163;

1.163
date	2006.08.01.23.36.12;	author stevesk;	state Exp;
branches;
next	1.162;

1.162
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.161;

1.161
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.160;

1.160
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.159;

1.159
date	2006.07.21.12.43.36;	author dtucker;	state Exp;
branches;
next	1.158;

1.158
date	2006.07.19.13.07.10;	author dtucker;	state Exp;
branches;
next	1.157;

1.157
date	2006.07.19.08.56.41;	author dtucker;	state Exp;
branches;
next	1.156;

1.156
date	2006.07.17.12.06.00;	author dtucker;	state Exp;
branches;
next	1.155;

1.155
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.154;

1.154
date	2006.07.12.22.28.52;	author stevesk;	state Exp;
branches;
next	1.153;

1.153
date	2006.07.12.11.34.58;	author dtucker;	state Exp;
branches;
next	1.152;

1.152
date	2006.07.08.21.47.12;	author stevesk;	state Exp;
branches;
next	1.151;

1.151
date	2006.07.06.10.47.05;	author djm;	state Exp;
branches;
next	1.150;

1.150
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.149;

1.149
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.148;

1.148
date	2006.03.19.11.51.52;	author dtucker;	state Exp;
branches;
next	1.147;

1.147
date	2006.03.19.02.24.05;	author djm;	state Exp;
branches;
next	1.146;

1.146
date	2005.12.08.18.34.11;	author reyk;	state Exp;
branches
	1.146.2.1;
next	1.145;

1.145
date	2005.12.06.22.38.27;	author reyk;	state Exp;
branches;
next	1.144;

1.144
date	2005.08.06.10.03.12;	author dtucker;	state Exp;
branches
	1.144.2.1;
next	1.143;

1.143
date	2005.07.25.11.59.40;	author markus;	state Exp;
branches;
next	1.142;

1.142
date	2005.06.17.02.44.33;	author djm;	state Exp;
branches;
next	1.141;

1.141
date	2005.05.16.15.30.51;	author markus;	state Exp;
branches;
next	1.140;

1.140
date	2005.03.10.22.01.05;	author deraadt;	state Exp;
branches
	1.140.2.1;
next	1.139;

1.139
date	2005.03.01.10.09.52;	author djm;	state Exp;
branches;
next	1.138;

1.138
date	2004.12.23.23.11.00;	author djm;	state Exp;
branches;
next	1.137;

1.137
date	2004.08.13.11.09.24;	author dtucker;	state Exp;
branches
	1.137.2.1;
next	1.136;

1.136
date	2004.08.11.11.09.54;	author dtucker;	state Exp;
branches;
next	1.135;

1.135
date	2004.07.11.17.48.47;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	2004.06.24.19.30.54;	author djm;	state Exp;
branches;
next	1.133;

1.133
date	2004.05.23.23.59.53;	author dtucker;	state Exp;
branches;
next	1.132;

1.132
date	2004.05.08.00.01.37;	author deraadt;	state Exp;
branches;
next	1.131;

1.131
date	2004.04.27.09.46.37;	author djm;	state Exp;
branches;
next	1.130;

1.130
date	2003.12.23.16.12.10;	author jakob;	state Exp;
branches
	1.130.2.1;
next	1.129;

1.129
date	2003.12.09.21.53.36;	author markus;	state Exp;
branches;
next	1.128;

1.128
date	2003.09.29.20.19.57;	author markus;	state Exp;
branches;
next	1.127;

1.127
date	2003.09.01.18.15.50;	author markus;	state Exp;
branches
	1.127.2.1;
next	1.126;

1.126
date	2003.08.28.12.54.34;	author markus;	state Exp;
branches;
next	1.125;

1.125
date	2003.08.22.10.56.09;	author markus;	state Exp;
branches;
next	1.124;

1.124
date	2003.08.13.08.46.30;	author markus;	state Exp;
branches;
next	1.123;

1.123
date	2003.07.22.13.35.22;	author markus;	state Exp;
branches;
next	1.122;

1.122
date	2003.06.02.09.17.34;	author markus;	state Exp;
branches;
next	1.121;

1.121
date	2003.05.15.14.02.47;	author jakob;	state Exp;
branches;
next	1.120;

1.120
date	2003.05.15.04.08.44;	author jakob;	state Exp;
branches;
next	1.119;

1.119
date	2003.05.15.01.48.10;	author jakob;	state Exp;
branches;
next	1.118;

1.118
date	2003.04.09.08.23.52;	author hin;	state Exp;
branches;
next	1.117;

1.117
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches;
next	1.116;

1.116
date	2003.02.21.09.05.53;	author markus;	state Exp;
branches
	1.116.2.1;
next	1.115;

1.115
date	2002.09.04.18.52.42;	author stevesk;	state Exp;
branches
	1.115.2.1;
next	1.114;

1.114
date	2002.08.21.19.38.06;	author stevesk;	state Exp;
branches;
next	1.113;

1.113
date	2002.07.30.17.03.55;	author markus;	state Exp;
branches;
next	1.112;

1.112
date	2002.06.23.09.46.51;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2002.06.20.23.05.55;	author markus;	state Exp;
branches;
next	1.110;

1.110
date	2002.05.15.21.56.38;	author markus;	state Exp;
branches;
next	1.109;

1.109
date	2002.05.15.21.02.52;	author markus;	state Exp;
branches;
next	1.108;

1.108
date	2002.05.04.02.39.35;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2002.04.22.16.16.53;	author markus;	state Exp;
branches;
next	1.106;

1.106
date	2002.04.20.09.02.03;	author deraadt;	state Exp;
branches;
next	1.105;

1.105
date	2002.03.20.19.12.24;	author stevesk;	state Exp;
branches
	1.105.2.1;
next	1.104;

1.104
date	2002.03.19.03.03.43;	author stevesk;	state Exp;
branches;
next	1.103;

1.103
date	2002.03.18.23.52.51;	author stevesk;	state Exp;
branches;
next	1.102;

1.102
date	2002.03.18.17.50.31;	author provos;	state Exp;
branches;
next	1.101;

1.101
date	2002.02.04.12.15.25;	author markus;	state Exp;
branches;
next	1.100;

1.100
date	2002.01.29.14.32.03;	author markus;	state Exp;
branches;
next	1.99;

1.99
date	2002.01.27.14.57.46;	author stevesk;	state Exp;
branches;
next	1.98;

1.98
date	2002.01.22.02.52.41;	author stevesk;	state Exp;
branches;
next	1.97;

1.97
date	2002.01.04.18.14.16;	author stevesk;	state Exp;
branches;
next	1.96;

1.96
date	2002.01.04.17.59.17;	author stevesk;	state Exp;
branches;
next	1.95;

1.95
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2001.12.06.13.30.05;	author markus;	state Exp;
branches;
next	1.93;

1.93
date	2001.12.05.10.06.12;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2001.11.17.19.14.34;	author stevesk;	state Exp;
branches;
next	1.91;

1.91
date	2001.11.12.18.17.07;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2001.11.11.13.02.31;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2001.08.16.19.18.34;	author jakob;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2001.07.11.00.24.53;	author itojun;	state Exp;
branches;
next	1.87;

1.87
date	2001.07.08.15.23.38;	author stevesk;	state Exp;
branches;
next	1.86;

1.86
date	2001.06.26.17.41.49;	author dugsong;	state Exp;
branches;
next	1.85;

1.85
date	2001.06.26.16.15.24;	author dugsong;	state Exp;
branches;
next	1.84;

1.84
date	2001.06.23.15.12.19;	author itojun;	state Exp;
branches;
next	1.83;

1.83
date	2001.06.08.15.25.40;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2001.05.20.17.20.35;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2001.05.19.19.43.57;	author stevesk;	state Exp;
branches;
next	1.80;

1.80
date	2001.05.18.14.13.29;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2001.05.03.21.43.01;	author stevesk;	state Exp;
branches;
next	1.78;

1.78
date	2001.04.15.21.28.35;	author stevesk;	state Exp;
branches
	1.78.2.1;
next	1.77;

1.77
date	2001.04.13.22.46.53;	author beck;	state Exp;
branches;
next	1.76;

1.76
date	2001.04.12.20.09.37;	author stevesk;	state Exp;
branches;
next	1.75;

1.75
date	2001.04.12.19.15.25;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2001.04.06.22.25.25;	author stevesk;	state Exp;
branches;
next	1.73;

1.73
date	2001.04.02.14.20.23;	author stevesk;	state Exp;
branches;
next	1.72;

1.72
date	2001.03.25.13.16.10;	author stevesk;	state Exp;
branches;
next	1.71;

1.71
date	2001.03.05.15.44.51;	author stevesk;	state Exp;
branches;
next	1.70;

1.70
date	2001.03.04.17.42.28;	author millert;	state Exp;
branches;
next	1.69;

1.69
date	2001.03.04.11.16.06;	author stevesk;	state Exp;
branches;
next	1.68;

1.68
date	2001.02.22.04.29.37;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2001.02.12.16.16.23;	author markus;	state Exp;
branches;
next	1.66;

1.66
date	2001.02.11.12.59.25;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2001.02.04.15.32.24;	author stevesk;	state Exp;
branches;
next	1.64;

1.64
date	2001.02.03.10.08.37;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2001.01.22.23.06.39;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2001.01.21.19.05.55;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2001.01.20.23.00.56;	author djm;	state Exp;
branches;
next	1.60;

1.60
date	2001.01.19.15.55.11;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2001.01.19.12.45.26;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2001.01.18.16.20.22;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2001.01.08.22.29.05;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2001.01.07.11.28.06;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2000.12.19.23.17.57;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2000.11.12.19.50.38;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2000.10.14.12.12.09;	author markus;	state Exp;
branches
	1.53.2.1;
next	1.52;

1.52
date	2000.10.11.20.14.39;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2000.09.07.20.27.53;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2000.07.22.09.14.36;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2000.07.14.22.59.46;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2000.07.13.22.53.21;	author provos;	state Exp;
branches;
next	1.47;

1.47
date	2000.07.10.16.30.25;	author ho;	state Exp;
branches;
next	1.46;

1.46
date	2000.06.26.21.59.18;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2000.06.20.01.39.44;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2000.06.18.00.57.48;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2000.06.17.22.52.33;	author jakob;	state Exp;
branches;
next	1.42;

1.42
date	2000.05.31.06.36.40;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2000.05.22.18.42.01;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2000.05.08.17.12.15;	author markus;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2000.05.06.17.45.36;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2000.05.03.18.03.06;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2000.05.03.10.21.47;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2000.05.01.18.50.58;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2000.04.26.22.43.15;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2000.04.14.10.30.33;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2000.04.12.07.45.44;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2000.04.06.08.55.22;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2000.03.07.20.40.41;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.24.18.22.16;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2000.01.04.00.07.59;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	99.11.24.20.19.37;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	99.11.24.19.53.50;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	99.11.24.00.26.03;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	99.11.23.22.25.54;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	99.11.19.20.03.35;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	99.11.19.16.04.17;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	99.11.11.23.26.53;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	99.11.11.22.58.38;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	99.11.10.23.36.44;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	99.10.25.21.35.25;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	99.10.17.23.09.16;	author dugsong;	state Exp;
branches;
next	1.17;

1.17
date	99.10.17.20.48.07;	author dugsong;	state Exp;
branches;
next	1.16;

1.16
date	99.10.14.20.17.24;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	99.10.14.19.56.02;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	99.10.12.18.11.54;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	99.10.11.21.48.29;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	99.10.11.21.07.37;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	99.10.07.22.46.32;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	99.10.07.21.45.02;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.10.02.19.18.22;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.10.01.22.23.48;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.10.01.02.38.09;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	99.09.30.05.11.29;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.09.29.22.08.13;	author dugsong;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.18.16.20;	author dugsong;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.00.10.16;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.07.56.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.37;	author deraadt;	state Exp;
branches;
next	;

1.40.2.1
date	2000.06.12.02.37.35;	author jason;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2000.09.01.18.23.22;	author jason;	state Exp;
branches;
next	1.40.2.3;

1.40.2.3
date	2000.11.08.21.31.12;	author jason;	state Exp;
branches;
next	1.40.2.4;

1.40.2.4
date	2001.03.12.15.44.14;	author jason;	state Exp;
branches;
next	1.40.2.5;

1.40.2.5
date	2001.03.21.18.53.00;	author jason;	state Exp;
branches;
next	;

1.53.2.1
date	2001.02.16.20.13.12;	author jason;	state Exp;
branches;
next	1.53.2.2;

1.53.2.2
date	2001.02.19.17.19.18;	author jason;	state Exp;
branches;
next	1.53.2.3;

1.53.2.3
date	2001.03.21.19.46.28;	author jason;	state Exp;
branches;
next	1.53.2.4;

1.53.2.4
date	2001.05.07.21.09.33;	author jason;	state Exp;
branches;
next	1.53.2.5;

1.53.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.53.2.6;

1.53.2.6
date	2001.11.15.22.50.30;	author miod;	state Exp;
branches;
next	1.53.2.7;

1.53.2.7
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.78.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.78.2.2;

1.78.2.2
date	2001.11.15.22.51.15;	author miod;	state Exp;
branches;
next	1.78.2.3;

1.78.2.3
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.78.2.4;

1.78.2.4
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.89.2.1
date	2001.11.14.03.24.39;	author jason;	state Exp;
branches;
next	1.89.2.2;

1.89.2.2
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.89.2.3;

1.89.2.3
date	2002.03.08.15.17.18;	author brad;	state Exp;
branches;
next	1.89.2.4;

1.89.2.4
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.89.2.5;

1.89.2.5
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.89.2.6;

1.89.2.6
date	2002.06.26.18.22.35;	author miod;	state Exp;
branches;
next	1.89.2.7;

1.89.2.7
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.105.2.1
date	2002.05.18.04.12.11;	author jason;	state Exp;
branches;
next	1.105.2.2;

1.105.2.2
date	2002.05.18.04.50.38;	author jason;	state Exp;
branches;
next	1.105.2.3;

1.105.2.3
date	2002.06.22.04.33.15;	author jason;	state Exp;
branches;
next	1.105.2.4;

1.105.2.4
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.105.2.5;

1.105.2.5
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.105.2.6;

1.105.2.6
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.115.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.115.2.2;

1.115.2.2
date	2003.09.16.21.20.27;	author brad;	state Exp;
branches;
next	;

1.116.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.116.2.2;

1.116.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.127.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.127.2.2;

1.127.2.2
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.130.2.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	1.130.2.2;

1.130.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.137.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.137.2.2;

1.137.2.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	1.137.2.3;

1.137.2.3
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.140.2.1
date	2005.09.04.18.40.03;	author brad;	state Exp;
branches;
next	1.140.2.2;

1.140.2.2
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.144.2.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.144.2.2;

1.144.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	;

1.146.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	;


desc
@@


1.307
log
@remove a static array unused since rev 1.306 spotted by clang
ok djm@@
@
text
@
/* $OpenBSD: servconf.c,v 1.306 2017/03/14 07:19:07 djm Exp $ */
/*
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>

#include <netinet/in.h>
#include <netinet/ip.h>

#include <ctype.h>
#include <netdb.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <limits.h>
#include <stdarg.h>
#include <errno.h>
#include <util.h>

#include "xmalloc.h"
#include "ssh.h"
#include "log.h"
#include "buffer.h"
#include "misc.h"
#include "servconf.h"
#include "compat.h"
#include "pathnames.h"
#include "cipher.h"
#include "key.h"
#include "kex.h"
#include "mac.h"
#include "match.h"
#include "channels.h"
#include "groupaccess.h"
#include "canohost.h"
#include "packet.h"
#include "hostfile.h"
#include "auth.h"
#include "myproposal.h"
#include "digest.h"

static void add_listen_addr(ServerOptions *, char *, int);
static void add_one_listen_addr(ServerOptions *, char *, int);

/* Use of privilege separation or not */
extern int use_privsep;
extern Buffer cfg;

/* Initializes the server options to their default values. */

void
initialize_server_options(ServerOptions *options)
{
	memset(options, 0, sizeof(*options));
	options->num_ports = 0;
	options->ports_from_cmdline = 0;
	options->queued_listen_addrs = NULL;
	options->num_queued_listens = 0;
	options->listen_addrs = NULL;
	options->address_family = -1;
	options->num_host_key_files = 0;
	options->num_host_cert_files = 0;
	options->host_key_agent = NULL;
	options->pid_file = NULL;
	options->login_grace_time = -1;
	options->permit_root_login = PERMIT_NOT_SET;
	options->ignore_rhosts = -1;
	options->ignore_user_known_hosts = -1;
	options->print_motd = -1;
	options->print_lastlog = -1;
	options->x11_forwarding = -1;
	options->x11_display_offset = -1;
	options->x11_use_localhost = -1;
	options->permit_tty = -1;
	options->permit_user_rc = -1;
	options->xauth_location = NULL;
	options->strict_modes = -1;
	options->tcp_keep_alive = -1;
	options->log_facility = SYSLOG_FACILITY_NOT_SET;
	options->log_level = SYSLOG_LEVEL_NOT_SET;
	options->hostbased_authentication = -1;
	options->hostbased_uses_name_from_packet_only = -1;
	options->hostbased_key_types = NULL;
	options->hostkeyalgorithms = NULL;
	options->pubkey_authentication = -1;
	options->pubkey_key_types = NULL;
	options->kerberos_authentication = -1;
	options->kerberos_or_local_passwd = -1;
	options->kerberos_ticket_cleanup = -1;
	options->kerberos_get_afs_token = -1;
	options->gss_authentication=-1;
	options->gss_cleanup_creds = -1;
	options->gss_strict_acceptor = -1;
	options->password_authentication = -1;
	options->kbd_interactive_authentication = -1;
	options->challenge_response_authentication = -1;
	options->permit_empty_passwd = -1;
	options->permit_user_env = -1;
	options->compression = -1;
	options->rekey_limit = -1;
	options->rekey_interval = -1;
	options->allow_tcp_forwarding = -1;
	options->allow_streamlocal_forwarding = -1;
	options->allow_agent_forwarding = -1;
	options->num_allow_users = 0;
	options->num_deny_users = 0;
	options->num_allow_groups = 0;
	options->num_deny_groups = 0;
	options->ciphers = NULL;
	options->macs = NULL;
	options->kex_algorithms = NULL;
	options->fwd_opts.gateway_ports = -1;
	options->fwd_opts.streamlocal_bind_mask = (mode_t)-1;
	options->fwd_opts.streamlocal_bind_unlink = -1;
	options->num_subsystems = 0;
	options->max_startups_begin = -1;
	options->max_startups_rate = -1;
	options->max_startups = -1;
	options->max_authtries = -1;
	options->max_sessions = -1;
	options->banner = NULL;
	options->use_dns = -1;
	options->client_alive_interval = -1;
	options->client_alive_count_max = -1;
	options->num_authkeys_files = 0;
	options->num_accept_env = 0;
	options->permit_tun = -1;
	options->num_permitted_opens = -1;
	options->adm_forced_command = NULL;
	options->chroot_directory = NULL;
	options->authorized_keys_command = NULL;
	options->authorized_keys_command_user = NULL;
	options->revoked_keys_file = NULL;
	options->trusted_user_ca_keys = NULL;
	options->authorized_principals_file = NULL;
	options->authorized_principals_command = NULL;
	options->authorized_principals_command_user = NULL;
	options->ip_qos_interactive = -1;
	options->ip_qos_bulk = -1;
	options->version_addendum = NULL;
	options->fingerprint_hash = -1;
	options->disable_forwarding = -1;
}

/* Returns 1 if a string option is unset or set to "none" or 0 otherwise. */
static int
option_clear_or_none(const char *o)
{
	return o == NULL || strcasecmp(o, "none") == 0;
}

static void
assemble_algorithms(ServerOptions *o)
{
	if (kex_assemble_names(KEX_SERVER_ENCRYPT, &o->ciphers) != 0 ||
	    kex_assemble_names(KEX_SERVER_MAC, &o->macs) != 0 ||
	    kex_assemble_names(KEX_SERVER_KEX, &o->kex_algorithms) != 0 ||
	    kex_assemble_names(KEX_DEFAULT_PK_ALG,
	    &o->hostkeyalgorithms) != 0 ||
	    kex_assemble_names(KEX_DEFAULT_PK_ALG,
	    &o->hostbased_key_types) != 0 ||
	    kex_assemble_names(KEX_DEFAULT_PK_ALG, &o->pubkey_key_types) != 0)
		fatal("kex_assemble_names failed");
}

void
fill_default_server_options(ServerOptions *options)
{
	int i;

	if (options->num_host_key_files == 0) {
		/* fill default hostkeys */
		options->host_key_files[options->num_host_key_files++] =
		    _PATH_HOST_RSA_KEY_FILE;
		options->host_key_files[options->num_host_key_files++] =
		    _PATH_HOST_DSA_KEY_FILE;
		options->host_key_files[options->num_host_key_files++] =
		    _PATH_HOST_ECDSA_KEY_FILE;
		options->host_key_files[options->num_host_key_files++] =
		    _PATH_HOST_ED25519_KEY_FILE;
	}
	/* No certificates by default */
	if (options->num_ports == 0)
		options->ports[options->num_ports++] = SSH_DEFAULT_PORT;
	if (options->address_family == -1)
		options->address_family = AF_UNSPEC;
	if (options->listen_addrs == NULL)
		add_listen_addr(options, NULL, 0);
	if (options->pid_file == NULL)
		options->pid_file = xstrdup(_PATH_SSH_DAEMON_PID_FILE);
	if (options->login_grace_time == -1)
		options->login_grace_time = 120;
	if (options->permit_root_login == PERMIT_NOT_SET)
		options->permit_root_login = PERMIT_NO_PASSWD;
	if (options->ignore_rhosts == -1)
		options->ignore_rhosts = 1;
	if (options->ignore_user_known_hosts == -1)
		options->ignore_user_known_hosts = 0;
	if (options->print_motd == -1)
		options->print_motd = 1;
	if (options->print_lastlog == -1)
		options->print_lastlog = 1;
	if (options->x11_forwarding == -1)
		options->x11_forwarding = 0;
	if (options->x11_display_offset == -1)
		options->x11_display_offset = 10;
	if (options->x11_use_localhost == -1)
		options->x11_use_localhost = 1;
	if (options->xauth_location == NULL)
		options->xauth_location = xstrdup(_PATH_XAUTH);
	if (options->permit_tty == -1)
		options->permit_tty = 1;
	if (options->permit_user_rc == -1)
		options->permit_user_rc = 1;
	if (options->strict_modes == -1)
		options->strict_modes = 1;
	if (options->tcp_keep_alive == -1)
		options->tcp_keep_alive = 1;
	if (options->log_facility == SYSLOG_FACILITY_NOT_SET)
		options->log_facility = SYSLOG_FACILITY_AUTH;
	if (options->log_level == SYSLOG_LEVEL_NOT_SET)
		options->log_level = SYSLOG_LEVEL_INFO;
	if (options->hostbased_authentication == -1)
		options->hostbased_authentication = 0;
	if (options->hostbased_uses_name_from_packet_only == -1)
		options->hostbased_uses_name_from_packet_only = 0;
	if (options->pubkey_authentication == -1)
		options->pubkey_authentication = 1;
	if (options->kerberos_authentication == -1)
		options->kerberos_authentication = 0;
	if (options->kerberos_or_local_passwd == -1)
		options->kerberos_or_local_passwd = 1;
	if (options->kerberos_ticket_cleanup == -1)
		options->kerberos_ticket_cleanup = 1;
	if (options->kerberos_get_afs_token == -1)
		options->kerberos_get_afs_token = 0;
	if (options->gss_authentication == -1)
		options->gss_authentication = 0;
	if (options->gss_cleanup_creds == -1)
		options->gss_cleanup_creds = 1;
	if (options->gss_strict_acceptor == -1)
		options->gss_strict_acceptor = 1;
	if (options->password_authentication == -1)
		options->password_authentication = 1;
	if (options->kbd_interactive_authentication == -1)
		options->kbd_interactive_authentication = 0;
	if (options->challenge_response_authentication == -1)
		options->challenge_response_authentication = 1;
	if (options->permit_empty_passwd == -1)
		options->permit_empty_passwd = 0;
	if (options->permit_user_env == -1)
		options->permit_user_env = 0;
	if (options->compression == -1)
		options->compression = COMP_DELAYED;
	if (options->rekey_limit == -1)
		options->rekey_limit = 0;
	if (options->rekey_interval == -1)
		options->rekey_interval = 0;
	if (options->allow_tcp_forwarding == -1)
		options->allow_tcp_forwarding = FORWARD_ALLOW;
	if (options->allow_streamlocal_forwarding == -1)
		options->allow_streamlocal_forwarding = FORWARD_ALLOW;
	if (options->allow_agent_forwarding == -1)
		options->allow_agent_forwarding = 1;
	if (options->fwd_opts.gateway_ports == -1)
		options->fwd_opts.gateway_ports = 0;
	if (options->max_startups == -1)
		options->max_startups = 100;
	if (options->max_startups_rate == -1)
		options->max_startups_rate = 30;		/* 30% */
	if (options->max_startups_begin == -1)
		options->max_startups_begin = 10;
	if (options->max_authtries == -1)
		options->max_authtries = DEFAULT_AUTH_FAIL_MAX;
	if (options->max_sessions == -1)
		options->max_sessions = DEFAULT_SESSIONS_MAX;
	if (options->use_dns == -1)
		options->use_dns = 0;
	if (options->client_alive_interval == -1)
		options->client_alive_interval = 0;
	if (options->client_alive_count_max == -1)
		options->client_alive_count_max = 3;
	if (options->num_authkeys_files == 0) {
		options->authorized_keys_files[options->num_authkeys_files++] =
		    xstrdup(_PATH_SSH_USER_PERMITTED_KEYS);
		options->authorized_keys_files[options->num_authkeys_files++] =
		    xstrdup(_PATH_SSH_USER_PERMITTED_KEYS2);
	}
	if (options->permit_tun == -1)
		options->permit_tun = SSH_TUNMODE_NO;
	if (options->ip_qos_interactive == -1)
		options->ip_qos_interactive = IPTOS_LOWDELAY;
	if (options->ip_qos_bulk == -1)
		options->ip_qos_bulk = IPTOS_THROUGHPUT;
	if (options->version_addendum == NULL)
		options->version_addendum = xstrdup("");
	if (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)
		options->fwd_opts.streamlocal_bind_mask = 0177;
	if (options->fwd_opts.streamlocal_bind_unlink == -1)
		options->fwd_opts.streamlocal_bind_unlink = 0;
	if (options->fingerprint_hash == -1)
		options->fingerprint_hash = SSH_FP_HASH_DEFAULT;
	if (options->disable_forwarding == -1)
		options->disable_forwarding = 0;

	assemble_algorithms(options);

	/* Turn privilege separation and sandboxing on by default */
	if (use_privsep == -1)
		use_privsep = PRIVSEP_ON;

#define CLEAR_ON_NONE(v) \
	do { \
		if (option_clear_or_none(v)) { \
			free(v); \
			v = NULL; \
		} \
	} while(0)
	CLEAR_ON_NONE(options->pid_file);
	CLEAR_ON_NONE(options->xauth_location);
	CLEAR_ON_NONE(options->banner);
	CLEAR_ON_NONE(options->trusted_user_ca_keys);
	CLEAR_ON_NONE(options->revoked_keys_file);
	CLEAR_ON_NONE(options->authorized_principals_file);
	CLEAR_ON_NONE(options->adm_forced_command);
	CLEAR_ON_NONE(options->chroot_directory);
	for (i = 0; i < options->num_host_key_files; i++)
		CLEAR_ON_NONE(options->host_key_files[i]);
	for (i = 0; i < options->num_host_cert_files; i++)
		CLEAR_ON_NONE(options->host_cert_files[i]);
#undef CLEAR_ON_NONE

	/* Similar handling for AuthenticationMethods=any */
	if (options->num_auth_methods == 1 &&
	    strcmp(options->auth_methods[0], "any") == 0) {
		free(options->auth_methods[0]);
		options->auth_methods[0] = NULL;
		options->num_auth_methods = 0;
	}

}

/* Keyword tokens. */
typedef enum {
	sBadOption,		/* == unknown option */
	sPort, sHostKeyFile, sLoginGraceTime,
	sPermitRootLogin, sLogFacility, sLogLevel,
	sKerberosAuthentication, sKerberosOrLocalPasswd, sKerberosTicketCleanup,
	sKerberosGetAFSToken,
	sKerberosTgtPassing, sChallengeResponseAuthentication,
	sPasswordAuthentication, sKbdInteractiveAuthentication,
	sListenAddress, sAddressFamily,
	sPrintMotd, sPrintLastLog, sIgnoreRhosts,
	sX11Forwarding, sX11DisplayOffset, sX11UseLocalhost,
	sPermitTTY, sStrictModes, sEmptyPasswd, sTCPKeepAlive,
	sPermitUserEnvironment, sAllowTcpForwarding, sCompression,
	sRekeyLimit, sAllowUsers, sDenyUsers, sAllowGroups, sDenyGroups,
	sIgnoreUserKnownHosts, sCiphers, sMacs, sPidFile,
	sGatewayPorts, sPubkeyAuthentication, sPubkeyAcceptedKeyTypes,
	sXAuthLocation, sSubsystem, sMaxStartups, sMaxAuthTries, sMaxSessions,
	sBanner, sUseDNS, sHostbasedAuthentication,
	sHostbasedUsesNameFromPacketOnly, sHostbasedAcceptedKeyTypes,
	sHostKeyAlgorithms,
	sClientAliveInterval, sClientAliveCountMax, sAuthorizedKeysFile,
	sGssAuthentication, sGssCleanupCreds, sGssStrictAcceptor,
	sAcceptEnv, sPermitTunnel,
	sMatch, sPermitOpen, sForceCommand, sChrootDirectory,
	sUsePrivilegeSeparation, sAllowAgentForwarding,
	sHostCertificate,
	sRevokedKeys, sTrustedUserCAKeys, sAuthorizedPrincipalsFile,
	sAuthorizedPrincipalsCommand, sAuthorizedPrincipalsCommandUser,
	sKexAlgorithms, sIPQoS, sVersionAddendum,
	sAuthorizedKeysCommand, sAuthorizedKeysCommandUser,
	sAuthenticationMethods, sHostKeyAgent, sPermitUserRC,
	sStreamLocalBindMask, sStreamLocalBindUnlink,
	sAllowStreamLocalForwarding, sFingerprintHash, sDisableForwarding,
	sDeprecated, sIgnore, sUnsupported
} ServerOpCodes;

#define SSHCFG_GLOBAL	0x01	/* allowed in main section of sshd_config */
#define SSHCFG_MATCH	0x02	/* allowed inside a Match section */
#define SSHCFG_ALL	(SSHCFG_GLOBAL|SSHCFG_MATCH)

/* Textual representation of the tokens. */
static struct {
	const char *name;
	ServerOpCodes opcode;
	u_int flags;
} keywords[] = {
	{ "port", sPort, SSHCFG_GLOBAL },
	{ "hostkey", sHostKeyFile, SSHCFG_GLOBAL },
	{ "hostdsakey", sHostKeyFile, SSHCFG_GLOBAL },		/* alias */
	{ "hostkeyagent", sHostKeyAgent, SSHCFG_GLOBAL },
	{ "pidfile", sPidFile, SSHCFG_GLOBAL },
	{ "serverkeybits", sDeprecated, SSHCFG_GLOBAL },
	{ "logingracetime", sLoginGraceTime, SSHCFG_GLOBAL },
	{ "keyregenerationinterval", sDeprecated, SSHCFG_GLOBAL },
	{ "permitrootlogin", sPermitRootLogin, SSHCFG_ALL },
	{ "syslogfacility", sLogFacility, SSHCFG_GLOBAL },
	{ "loglevel", sLogLevel, SSHCFG_GLOBAL },
	{ "rhostsauthentication", sDeprecated, SSHCFG_GLOBAL },
	{ "rhostsrsaauthentication", sDeprecated, SSHCFG_ALL },
	{ "hostbasedauthentication", sHostbasedAuthentication, SSHCFG_ALL },
	{ "hostbasedusesnamefrompacketonly", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },
	{ "hostbasedacceptedkeytypes", sHostbasedAcceptedKeyTypes, SSHCFG_ALL },
	{ "hostkeyalgorithms", sHostKeyAlgorithms, SSHCFG_GLOBAL },
	{ "rsaauthentication", sDeprecated, SSHCFG_ALL },
	{ "pubkeyauthentication", sPubkeyAuthentication, SSHCFG_ALL },
	{ "pubkeyacceptedkeytypes", sPubkeyAcceptedKeyTypes, SSHCFG_ALL },
	{ "dsaauthentication", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */
#ifdef KRB5
	{ "kerberosauthentication", sKerberosAuthentication, SSHCFG_ALL },
	{ "kerberosorlocalpasswd", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },
	{ "kerberosticketcleanup", sKerberosTicketCleanup, SSHCFG_GLOBAL },
	{ "kerberosgetafstoken", sKerberosGetAFSToken, SSHCFG_GLOBAL },
#else
	{ "kerberosauthentication", sUnsupported, SSHCFG_ALL },
	{ "kerberosorlocalpasswd", sUnsupported, SSHCFG_GLOBAL },
	{ "kerberosticketcleanup", sUnsupported, SSHCFG_GLOBAL },
	{ "kerberosgetafstoken", sUnsupported, SSHCFG_GLOBAL },
#endif
	{ "kerberostgtpassing", sUnsupported, SSHCFG_GLOBAL },
	{ "afstokenpassing", sUnsupported, SSHCFG_GLOBAL },
#ifdef GSSAPI
	{ "gssapiauthentication", sGssAuthentication, SSHCFG_ALL },
	{ "gssapicleanupcredentials", sGssCleanupCreds, SSHCFG_GLOBAL },
	{ "gssapistrictacceptorcheck", sGssStrictAcceptor, SSHCFG_GLOBAL },
#else
	{ "gssapiauthentication", sUnsupported, SSHCFG_ALL },
	{ "gssapicleanupcredentials", sUnsupported, SSHCFG_GLOBAL },
	{ "gssapistrictacceptorcheck", sUnsupported, SSHCFG_GLOBAL },
#endif
	{ "passwordauthentication", sPasswordAuthentication, SSHCFG_ALL },
	{ "kbdinteractiveauthentication", sKbdInteractiveAuthentication, SSHCFG_ALL },
	{ "challengeresponseauthentication", sChallengeResponseAuthentication, SSHCFG_GLOBAL },
	{ "skeyauthentication", sChallengeResponseAuthentication, SSHCFG_GLOBAL }, /* alias */
	{ "checkmail", sDeprecated, SSHCFG_GLOBAL },
	{ "listenaddress", sListenAddress, SSHCFG_GLOBAL },
	{ "addressfamily", sAddressFamily, SSHCFG_GLOBAL },
	{ "printmotd", sPrintMotd, SSHCFG_GLOBAL },
	{ "printlastlog", sPrintLastLog, SSHCFG_GLOBAL },
	{ "ignorerhosts", sIgnoreRhosts, SSHCFG_GLOBAL },
	{ "ignoreuserknownhosts", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },
	{ "x11forwarding", sX11Forwarding, SSHCFG_ALL },
	{ "x11displayoffset", sX11DisplayOffset, SSHCFG_ALL },
	{ "x11uselocalhost", sX11UseLocalhost, SSHCFG_ALL },
	{ "xauthlocation", sXAuthLocation, SSHCFG_GLOBAL },
	{ "strictmodes", sStrictModes, SSHCFG_GLOBAL },
	{ "permitemptypasswords", sEmptyPasswd, SSHCFG_ALL },
	{ "permituserenvironment", sPermitUserEnvironment, SSHCFG_GLOBAL },
	{ "uselogin", sDeprecated, SSHCFG_GLOBAL },
	{ "compression", sCompression, SSHCFG_GLOBAL },
	{ "rekeylimit", sRekeyLimit, SSHCFG_ALL },
	{ "tcpkeepalive", sTCPKeepAlive, SSHCFG_GLOBAL },
	{ "keepalive", sTCPKeepAlive, SSHCFG_GLOBAL },	/* obsolete alias */
	{ "allowtcpforwarding", sAllowTcpForwarding, SSHCFG_ALL },
	{ "allowagentforwarding", sAllowAgentForwarding, SSHCFG_ALL },
	{ "allowusers", sAllowUsers, SSHCFG_ALL },
	{ "denyusers", sDenyUsers, SSHCFG_ALL },
	{ "allowgroups", sAllowGroups, SSHCFG_ALL },
	{ "denygroups", sDenyGroups, SSHCFG_ALL },
	{ "ciphers", sCiphers, SSHCFG_GLOBAL },
	{ "macs", sMacs, SSHCFG_GLOBAL },
	{ "protocol", sIgnore, SSHCFG_GLOBAL },
	{ "gatewayports", sGatewayPorts, SSHCFG_ALL },
	{ "subsystem", sSubsystem, SSHCFG_GLOBAL },
	{ "maxstartups", sMaxStartups, SSHCFG_GLOBAL },
	{ "maxauthtries", sMaxAuthTries, SSHCFG_ALL },
	{ "maxsessions", sMaxSessions, SSHCFG_ALL },
	{ "banner", sBanner, SSHCFG_ALL },
	{ "usedns", sUseDNS, SSHCFG_GLOBAL },
	{ "verifyreversemapping", sDeprecated, SSHCFG_GLOBAL },
	{ "reversemappingcheck", sDeprecated, SSHCFG_GLOBAL },
	{ "clientaliveinterval", sClientAliveInterval, SSHCFG_ALL },
	{ "clientalivecountmax", sClientAliveCountMax, SSHCFG_ALL },
	{ "authorizedkeysfile", sAuthorizedKeysFile, SSHCFG_ALL },
	{ "authorizedkeysfile2", sDeprecated, SSHCFG_ALL },
	{ "useprivilegeseparation", sDeprecated, SSHCFG_GLOBAL},
	{ "acceptenv", sAcceptEnv, SSHCFG_ALL },
	{ "permittunnel", sPermitTunnel, SSHCFG_ALL },
	{ "permittty", sPermitTTY, SSHCFG_ALL },
	{ "permituserrc", sPermitUserRC, SSHCFG_ALL },
	{ "match", sMatch, SSHCFG_ALL },
	{ "permitopen", sPermitOpen, SSHCFG_ALL },
	{ "forcecommand", sForceCommand, SSHCFG_ALL },
	{ "chrootdirectory", sChrootDirectory, SSHCFG_ALL },
	{ "hostcertificate", sHostCertificate, SSHCFG_GLOBAL },
	{ "revokedkeys", sRevokedKeys, SSHCFG_ALL },
	{ "trustedusercakeys", sTrustedUserCAKeys, SSHCFG_ALL },
	{ "authorizedprincipalsfile", sAuthorizedPrincipalsFile, SSHCFG_ALL },
	{ "kexalgorithms", sKexAlgorithms, SSHCFG_GLOBAL },
	{ "ipqos", sIPQoS, SSHCFG_ALL },
	{ "authorizedkeyscommand", sAuthorizedKeysCommand, SSHCFG_ALL },
	{ "authorizedkeyscommanduser", sAuthorizedKeysCommandUser, SSHCFG_ALL },
	{ "authorizedprincipalscommand", sAuthorizedPrincipalsCommand, SSHCFG_ALL },
	{ "authorizedprincipalscommanduser", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },
	{ "versionaddendum", sVersionAddendum, SSHCFG_GLOBAL },
	{ "authenticationmethods", sAuthenticationMethods, SSHCFG_ALL },
	{ "streamlocalbindmask", sStreamLocalBindMask, SSHCFG_ALL },
	{ "streamlocalbindunlink", sStreamLocalBindUnlink, SSHCFG_ALL },
	{ "allowstreamlocalforwarding", sAllowStreamLocalForwarding, SSHCFG_ALL },
	{ "fingerprinthash", sFingerprintHash, SSHCFG_GLOBAL },
	{ "disableforwarding", sDisableForwarding, SSHCFG_ALL },
	{ NULL, sBadOption, 0 }
};

static struct {
	int val;
	char *text;
} tunmode_desc[] = {
	{ SSH_TUNMODE_NO, "no" },
	{ SSH_TUNMODE_POINTOPOINT, "point-to-point" },
	{ SSH_TUNMODE_ETHERNET, "ethernet" },
	{ SSH_TUNMODE_YES, "yes" },
	{ -1, NULL }
};

/*
 * Returns the number of the token pointed to by cp or sBadOption.
 */

static ServerOpCodes
parse_token(const char *cp, const char *filename,
	    int linenum, u_int *flags)
{
	u_int i;

	for (i = 0; keywords[i].name; i++)
		if (strcasecmp(cp, keywords[i].name) == 0) {
			*flags = keywords[i].flags;
			return keywords[i].opcode;
		}

	error("%s: line %d: Bad configuration option: %s",
	    filename, linenum, cp);
	return sBadOption;
}

char *
derelativise_path(const char *path)
{
	char *expanded, *ret, cwd[PATH_MAX];

	if (strcasecmp(path, "none") == 0)
		return xstrdup("none");
	expanded = tilde_expand_filename(path, getuid());
	if (*expanded == '/')
		return expanded;
	if (getcwd(cwd, sizeof(cwd)) == NULL)
		fatal("%s: getcwd: %s", __func__, strerror(errno));
	xasprintf(&ret, "%s/%s", cwd, expanded);
	free(expanded);
	return ret;
}

static void
add_listen_addr(ServerOptions *options, char *addr, int port)
{
	u_int i;

	if (port == 0)
		for (i = 0; i < options->num_ports; i++)
			add_one_listen_addr(options, addr, options->ports[i]);
	else
		add_one_listen_addr(options, addr, port);
}

static void
add_one_listen_addr(ServerOptions *options, char *addr, int port)
{
	struct addrinfo hints, *ai, *aitop;
	char strport[NI_MAXSERV];
	int gaierr;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = options->address_family;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = (addr == NULL) ? AI_PASSIVE : 0;
	snprintf(strport, sizeof strport, "%d", port);
	if ((gaierr = getaddrinfo(addr, strport, &hints, &aitop)) != 0)
		fatal("bad addr or host: %s (%s)",
		    addr ? addr : "<NULL>",
		    ssh_gai_strerror(gaierr));
	for (ai = aitop; ai->ai_next; ai = ai->ai_next)
		;
	ai->ai_next = options->listen_addrs;
	options->listen_addrs = aitop;
}

/*
 * Queue a ListenAddress to be processed once we have all of the Ports
 * and AddressFamily options.
 */
static void
queue_listen_addr(ServerOptions *options, char *addr, int port)
{
	options->queued_listen_addrs = xreallocarray(
	    options->queued_listen_addrs, options->num_queued_listens + 1,
	    sizeof(addr));
	options->queued_listen_ports = xreallocarray(
	    options->queued_listen_ports, options->num_queued_listens + 1,
	    sizeof(port));
	options->queued_listen_addrs[options->num_queued_listens] =
	    xstrdup(addr);
	options->queued_listen_ports[options->num_queued_listens] = port;
	options->num_queued_listens++;
}

/*
 * Process queued (text) ListenAddress entries.
 */
static void
process_queued_listen_addrs(ServerOptions *options)
{
	u_int i;

	if (options->num_ports == 0)
		options->ports[options->num_ports++] = SSH_DEFAULT_PORT;
	if (options->address_family == -1)
		options->address_family = AF_UNSPEC;

	for (i = 0; i < options->num_queued_listens; i++) {
		add_listen_addr(options, options->queued_listen_addrs[i],
		    options->queued_listen_ports[i]);
		free(options->queued_listen_addrs[i]);
		options->queued_listen_addrs[i] = NULL;
	}
	free(options->queued_listen_addrs);
	options->queued_listen_addrs = NULL;
	free(options->queued_listen_ports);
	options->queued_listen_ports = NULL;
	options->num_queued_listens = 0;
}

struct connection_info *
get_connection_info(int populate, int use_dns)
{
	struct ssh *ssh = active_state; /* XXX */
	static struct connection_info ci;

	if (!populate)
		return &ci;
	ci.host = auth_get_canonical_hostname(ssh, use_dns);
	ci.address = ssh_remote_ipaddr(ssh);
	ci.laddress = ssh_local_ipaddr(ssh);
	ci.lport = ssh_local_port(ssh);
	return &ci;
}

/*
 * The strategy for the Match blocks is that the config file is parsed twice.
 *
 * The first time is at startup.  activep is initialized to 1 and the
 * directives in the global context are processed and acted on.  Hitting a
 * Match directive unsets activep and the directives inside the block are
 * checked for syntax only.
 *
 * The second time is after a connection has been established but before
 * authentication.  activep is initialized to 2 and global config directives
 * are ignored since they have already been processed.  If the criteria in a
 * Match block is met, activep is set and the subsequent directives
 * processed and actioned until EOF or another Match block unsets it.  Any
 * options set are copied into the main server config.
 *
 * Potential additions/improvements:
 *  - Add Match support for pre-kex directives, eg. Ciphers.
 *
 *  - Add a Tag directive (idea from David Leonard) ala pf, eg:
 *	Match Address 192.168.0.*
 *		Tag trusted
 *	Match Group wheel
 *		Tag trusted
 *	Match Tag trusted
 *		AllowTcpForwarding yes
 *		GatewayPorts clientspecified
 *		[...]
 *
 *  - Add a PermittedChannelRequests directive
 *	Match Group shell
 *		PermittedChannelRequests session,forwarded-tcpip
 */

static int
match_cfg_line_group(const char *grps, int line, const char *user)
{
	int result = 0;
	struct passwd *pw;

	if (user == NULL)
		goto out;

	if ((pw = getpwnam(user)) == NULL) {
		debug("Can't match group at line %d because user %.100s does "
		    "not exist", line, user);
	} else if (ga_init(pw->pw_name, pw->pw_gid) == 0) {
		debug("Can't Match group because user %.100s not in any group "
		    "at line %d", user, line);
	} else if (ga_match_pattern_list(grps) != 1) {
		debug("user %.100s does not match group list %.100s at line %d",
		    user, grps, line);
	} else {
		debug("user %.100s matched group list %.100s at line %d", user,
		    grps, line);
		result = 1;
	}
out:
	ga_free();
	return result;
}

/*
 * All of the attributes on a single Match line are ANDed together, so we need
 * to check every attribute and set the result to zero if any attribute does
 * not match.
 */
static int
match_cfg_line(char **condition, int line, struct connection_info *ci)
{
	int result = 1, attributes = 0, port;
	char *arg, *attrib, *cp = *condition;

	if (ci == NULL)
		debug3("checking syntax for 'Match %s'", cp);
	else
		debug3("checking match for '%s' user %s host %s addr %s "
		    "laddr %s lport %d", cp, ci->user ? ci->user : "(null)",
		    ci->host ? ci->host : "(null)",
		    ci->address ? ci->address : "(null)",
		    ci->laddress ? ci->laddress : "(null)", ci->lport);

	while ((attrib = strdelim(&cp)) && *attrib != '\0') {
		attributes++;
		if (strcasecmp(attrib, "all") == 0) {
			if (attributes != 1 ||
			    ((arg = strdelim(&cp)) != NULL && *arg != '\0')) {
				error("'all' cannot be combined with other "
				    "Match attributes");
				return -1;
			}
			*condition = cp;
			return 1;
		}
		if ((arg = strdelim(&cp)) == NULL || *arg == '\0') {
			error("Missing Match criteria for %s", attrib);
			return -1;
		}
		if (strcasecmp(attrib, "user") == 0) {
			if (ci == NULL || ci->user == NULL) {
				result = 0;
				continue;
			}
			if (match_pattern_list(ci->user, arg, 0) != 1)
				result = 0;
			else
				debug("user %.100s matched 'User %.100s' at "
				    "line %d", ci->user, arg, line);
		} else if (strcasecmp(attrib, "group") == 0) {
			if (ci == NULL || ci->user == NULL) {
				result = 0;
				continue;
			}
			switch (match_cfg_line_group(arg, line, ci->user)) {
			case -1:
				return -1;
			case 0:
				result = 0;
			}
		} else if (strcasecmp(attrib, "host") == 0) {
			if (ci == NULL || ci->host == NULL) {
				result = 0;
				continue;
			}
			if (match_hostname(ci->host, arg) != 1)
				result = 0;
			else
				debug("connection from %.100s matched 'Host "
				    "%.100s' at line %d", ci->host, arg, line);
		} else if (strcasecmp(attrib, "address") == 0) {
			if (ci == NULL || ci->address == NULL) {
				result = 0;
				continue;
			}
			switch (addr_match_list(ci->address, arg)) {
			case 1:
				debug("connection from %.100s matched 'Address "
				    "%.100s' at line %d", ci->address, arg, line);
				break;
			case 0:
			case -1:
				result = 0;
				break;
			case -2:
				return -1;
			}
		} else if (strcasecmp(attrib, "localaddress") == 0){
			if (ci == NULL || ci->laddress == NULL) {
				result = 0;
				continue;
			}
			switch (addr_match_list(ci->laddress, arg)) {
			case 1:
				debug("connection from %.100s matched "
				    "'LocalAddress %.100s' at line %d",
				    ci->laddress, arg, line);
				break;
			case 0:
			case -1:
				result = 0;
				break;
			case -2:
				return -1;
			}
		} else if (strcasecmp(attrib, "localport") == 0) {
			if ((port = a2port(arg)) == -1) {
				error("Invalid LocalPort '%s' on Match line",
				    arg);
				return -1;
			}
			if (ci == NULL || ci->lport == 0) {
				result = 0;
				continue;
			}
			/* TODO support port lists */
			if (port == ci->lport)
				debug("connection from %.100s matched "
				    "'LocalPort %d' at line %d",
				    ci->laddress, port, line);
			else
				result = 0;
		} else {
			error("Unsupported Match attribute %s", attrib);
			return -1;
		}
	}
	if (attributes == 0) {
		error("One or more attributes required for Match");
		return -1;
	}
	if (ci != NULL)
		debug3("match %sfound", result ? "" : "not ");
	*condition = cp;
	return result;
}

#define WHITESPACE " \t\r\n"

/* Multistate option parsing */
struct multistate {
	char *key;
	int value;
};
static const struct multistate multistate_addressfamily[] = {
	{ "inet",			AF_INET },
	{ "inet6",			AF_INET6 },
	{ "any",			AF_UNSPEC },
	{ NULL, -1 }
};
static const struct multistate multistate_permitrootlogin[] = {
	{ "without-password",		PERMIT_NO_PASSWD },
	{ "prohibit-password",		PERMIT_NO_PASSWD },
	{ "forced-commands-only",	PERMIT_FORCED_ONLY },
	{ "yes",			PERMIT_YES },
	{ "no",				PERMIT_NO },
	{ NULL, -1 }
};
static const struct multistate multistate_compression[] = {
	{ "yes",			COMP_DELAYED },
	{ "delayed",			COMP_DELAYED },
	{ "no",				COMP_NONE },
	{ NULL, -1 }
};
static const struct multistate multistate_gatewayports[] = {
	{ "clientspecified",		2 },
	{ "yes",			1 },
	{ "no",				0 },
	{ NULL, -1 }
};
static const struct multistate multistate_tcpfwd[] = {
	{ "yes",			FORWARD_ALLOW },
	{ "all",			FORWARD_ALLOW },
	{ "no",				FORWARD_DENY },
	{ "remote",			FORWARD_REMOTE },
	{ "local",			FORWARD_LOCAL },
	{ NULL, -1 }
};

int
process_server_config_line(ServerOptions *options, char *line,
    const char *filename, int linenum, int *activep,
    struct connection_info *connectinfo)
{
	char *cp, **charptr, *arg, *p;
	int cmdline = 0, *intptr, value, value2, n, port;
	SyslogFacility *log_facility_ptr;
	LogLevel *log_level_ptr;
	ServerOpCodes opcode;
	u_int i, flags = 0;
	size_t len;
	long long val64;
	const struct multistate *multistate_ptr;

	/* Strip trailing whitespace. Allow \f (form feed) at EOL only */
	if ((len = strlen(line)) == 0)
		return 0;
	for (len--; len > 0; len--) {
		if (strchr(WHITESPACE "\f", line[len]) == NULL)
			break;
		line[len] = '\0';
	}

	cp = line;
	if ((arg = strdelim(&cp)) == NULL)
		return 0;
	/* Ignore leading whitespace */
	if (*arg == '\0')
		arg = strdelim(&cp);
	if (!arg || !*arg || *arg == '#')
		return 0;
	intptr = NULL;
	charptr = NULL;
	opcode = parse_token(arg, filename, linenum, &flags);

	if (activep == NULL) { /* We are processing a command line directive */
		cmdline = 1;
		activep = &cmdline;
	}
	if (*activep && opcode != sMatch)
		debug3("%s:%d setting %s %s", filename, linenum, arg, cp);
	if (*activep == 0 && !(flags & SSHCFG_MATCH)) {
		if (connectinfo == NULL) {
			fatal("%s line %d: Directive '%s' is not allowed "
			    "within a Match block", filename, linenum, arg);
		} else { /* this is a directive we have already processed */
			while (arg)
				arg = strdelim(&cp);
			return 0;
		}
	}

	switch (opcode) {
	case sBadOption:
		return -1;
	case sPort:
		/* ignore ports from configfile if cmdline specifies ports */
		if (options->ports_from_cmdline)
			return 0;
		if (options->num_ports >= MAX_PORTS)
			fatal("%s line %d: too many ports.",
			    filename, linenum);
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing port number.",
			    filename, linenum);
		options->ports[options->num_ports++] = a2port(arg);
		if (options->ports[options->num_ports-1] <= 0)
			fatal("%s line %d: Badly formatted port number.",
			    filename, linenum);
		break;

	case sLoginGraceTime:
		intptr = &options->login_grace_time;
 parse_time:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing time value.",
			    filename, linenum);
		if ((value = convtime(arg)) == -1)
			fatal("%s line %d: invalid time value.",
			    filename, linenum);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case sListenAddress:
		arg = strdelim(&cp);
		if (arg == NULL || *arg == '\0')
			fatal("%s line %d: missing address",
			    filename, linenum);
		/* check for bare IPv6 address: no "[]" and 2 or more ":" */
		if (strchr(arg, '[') == NULL && (p = strchr(arg, ':')) != NULL
		    && strchr(p+1, ':') != NULL) {
			queue_listen_addr(options, arg, 0);
			break;
		}
		p = hpdelim(&arg);
		if (p == NULL)
			fatal("%s line %d: bad address:port usage",
			    filename, linenum);
		p = cleanhostname(p);
		if (arg == NULL)
			port = 0;
		else if ((port = a2port(arg)) <= 0)
			fatal("%s line %d: bad port number", filename, linenum);

		queue_listen_addr(options, p, port);

		break;

	case sAddressFamily:
		intptr = &options->address_family;
		multistate_ptr = multistate_addressfamily;
 parse_multistate:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing argument.",
			    filename, linenum);
		value = -1;
		for (i = 0; multistate_ptr[i].key != NULL; i++) {
			if (strcasecmp(arg, multistate_ptr[i].key) == 0) {
				value = multistate_ptr[i].value;
				break;
			}
		}
		if (value == -1)
			fatal("%s line %d: unsupported option \"%s\".",
			    filename, linenum, arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case sHostKeyFile:
		intptr = &options->num_host_key_files;
		if (*intptr >= MAX_HOSTKEYS)
			fatal("%s line %d: too many host keys specified (max %d).",
			    filename, linenum, MAX_HOSTKEYS);
		charptr = &options->host_key_files[*intptr];
 parse_filename:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing file name.",
			    filename, linenum);
		if (*activep && *charptr == NULL) {
			*charptr = derelativise_path(arg);
			/* increase optional counter */
			if (intptr != NULL)
				*intptr = *intptr + 1;
		}
		break;

	case sHostKeyAgent:
		charptr = &options->host_key_agent;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing socket name.",
			    filename, linenum);
		if (*activep && *charptr == NULL)
			*charptr = !strcmp(arg, SSH_AUTHSOCKET_ENV_NAME) ?
			    xstrdup(arg) : derelativise_path(arg);
		break;

	case sHostCertificate:
		intptr = &options->num_host_cert_files;
		if (*intptr >= MAX_HOSTKEYS)
			fatal("%s line %d: too many host certificates "
			    "specified (max %d).", filename, linenum,
			    MAX_HOSTCERTS);
		charptr = &options->host_cert_files[*intptr];
		goto parse_filename;

	case sPidFile:
		charptr = &options->pid_file;
		goto parse_filename;

	case sPermitRootLogin:
		intptr = &options->permit_root_login;
		multistate_ptr = multistate_permitrootlogin;
		goto parse_multistate;

	case sIgnoreRhosts:
		intptr = &options->ignore_rhosts;
 parse_flag:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/no argument.",
			    filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "yes") == 0)
			value = 1;
		else if (strcmp(arg, "no") == 0)
			value = 0;
		else
			fatal("%s line %d: Bad yes/no argument: %s",
				filename, linenum, arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case sIgnoreUserKnownHosts:
		intptr = &options->ignore_user_known_hosts;
		goto parse_flag;

	case sHostbasedAuthentication:
		intptr = &options->hostbased_authentication;
		goto parse_flag;

	case sHostbasedUsesNameFromPacketOnly:
		intptr = &options->hostbased_uses_name_from_packet_only;
		goto parse_flag;

	case sHostbasedAcceptedKeyTypes:
		charptr = &options->hostbased_key_types;
 parse_keytypes:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.",
			    filename, linenum);
		if (*arg != '-' &&
		    !sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))
			fatal("%s line %d: Bad key types '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && *charptr == NULL)
			*charptr = xstrdup(arg);
		break;

	case sHostKeyAlgorithms:
		charptr = &options->hostkeyalgorithms;
		goto parse_keytypes;

	case sPubkeyAuthentication:
		intptr = &options->pubkey_authentication;
		goto parse_flag;

	case sPubkeyAcceptedKeyTypes:
		charptr = &options->pubkey_key_types;
		goto parse_keytypes;

	case sKerberosAuthentication:
		intptr = &options->kerberos_authentication;
		goto parse_flag;

	case sKerberosOrLocalPasswd:
		intptr = &options->kerberos_or_local_passwd;
		goto parse_flag;

	case sKerberosTicketCleanup:
		intptr = &options->kerberos_ticket_cleanup;
		goto parse_flag;

	case sKerberosGetAFSToken:
		intptr = &options->kerberos_get_afs_token;
		goto parse_flag;

	case sGssAuthentication:
		intptr = &options->gss_authentication;
		goto parse_flag;

	case sGssCleanupCreds:
		intptr = &options->gss_cleanup_creds;
		goto parse_flag;

	case sGssStrictAcceptor:
		intptr = &options->gss_strict_acceptor;
		goto parse_flag;

	case sPasswordAuthentication:
		intptr = &options->password_authentication;
		goto parse_flag;

	case sKbdInteractiveAuthentication:
		intptr = &options->kbd_interactive_authentication;
		goto parse_flag;

	case sChallengeResponseAuthentication:
		intptr = &options->challenge_response_authentication;
		goto parse_flag;

	case sPrintMotd:
		intptr = &options->print_motd;
		goto parse_flag;

	case sPrintLastLog:
		intptr = &options->print_lastlog;
		goto parse_flag;

	case sX11Forwarding:
		intptr = &options->x11_forwarding;
		goto parse_flag;

	case sX11DisplayOffset:
		intptr = &options->x11_display_offset;
 parse_int:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing integer value.",
			    filename, linenum);
		value = atoi(arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case sX11UseLocalhost:
		intptr = &options->x11_use_localhost;
		goto parse_flag;

	case sXAuthLocation:
		charptr = &options->xauth_location;
		goto parse_filename;

	case sPermitTTY:
		intptr = &options->permit_tty;
		goto parse_flag;

	case sPermitUserRC:
		intptr = &options->permit_user_rc;
		goto parse_flag;

	case sStrictModes:
		intptr = &options->strict_modes;
		goto parse_flag;

	case sTCPKeepAlive:
		intptr = &options->tcp_keep_alive;
		goto parse_flag;

	case sEmptyPasswd:
		intptr = &options->permit_empty_passwd;
		goto parse_flag;

	case sPermitUserEnvironment:
		intptr = &options->permit_user_env;
		goto parse_flag;

	case sCompression:
		intptr = &options->compression;
		multistate_ptr = multistate_compression;
		goto parse_multistate;

	case sRekeyLimit:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename,
			    linenum);
		if (strcmp(arg, "default") == 0) {
			val64 = 0;
		} else {
			if (scan_scaled(arg, &val64) == -1)
				fatal("%.200s line %d: Bad number '%s': %s",
				    filename, linenum, arg, strerror(errno));
			if (val64 != 0 && val64 < 16)
				fatal("%.200s line %d: RekeyLimit too small",
				    filename, linenum);
		}
		if (*activep && options->rekey_limit == -1)
			options->rekey_limit = val64;
		if (cp != NULL) { /* optional rekey interval present */
			if (strcmp(cp, "none") == 0) {
				(void)strdelim(&cp);	/* discard */
				break;
			}
			intptr = &options->rekey_interval;
			goto parse_time;
		}
		break;

	case sGatewayPorts:
		intptr = &options->fwd_opts.gateway_ports;
		multistate_ptr = multistate_gatewayports;
		goto parse_multistate;

	case sUseDNS:
		intptr = &options->use_dns;
		goto parse_flag;

	case sLogFacility:
		log_facility_ptr = &options->log_facility;
		arg = strdelim(&cp);
		value = log_facility_number(arg);
		if (value == SYSLOG_FACILITY_NOT_SET)
			fatal("%.200s line %d: unsupported log facility '%s'",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*log_facility_ptr == -1)
			*log_facility_ptr = (SyslogFacility) value;
		break;

	case sLogLevel:
		log_level_ptr = &options->log_level;
		arg = strdelim(&cp);
		value = log_level_number(arg);
		if (value == SYSLOG_LEVEL_NOT_SET)
			fatal("%.200s line %d: unsupported log level '%s'",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*log_level_ptr == -1)
			*log_level_ptr = (LogLevel) value;
		break;

	case sAllowTcpForwarding:
		intptr = &options->allow_tcp_forwarding;
		multistate_ptr = multistate_tcpfwd;
		goto parse_multistate;

	case sAllowStreamLocalForwarding:
		intptr = &options->allow_streamlocal_forwarding;
		multistate_ptr = multistate_tcpfwd;
		goto parse_multistate;

	case sAllowAgentForwarding:
		intptr = &options->allow_agent_forwarding;
		goto parse_flag;

	case sDisableForwarding:
		intptr = &options->disable_forwarding;
		goto parse_flag;

	case sAllowUsers:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_allow_users >= MAX_ALLOW_USERS)
				fatal("%s line %d: too many allow users.",
				    filename, linenum);
			if (match_user(NULL, NULL, NULL, arg) == -1)
				fatal("%s line %d: invalid AllowUsers pattern: "
				    "\"%.100s\"", filename, linenum, arg);
			if (!*activep)
				continue;
			options->allow_users[options->num_allow_users++] =
			    xstrdup(arg);
		}
		break;

	case sDenyUsers:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_deny_users >= MAX_DENY_USERS)
				fatal("%s line %d: too many deny users.",
				    filename, linenum);
			if (match_user(NULL, NULL, NULL, arg) == -1)
				fatal("%s line %d: invalid DenyUsers pattern: "
				    "\"%.100s\"", filename, linenum, arg);
			if (!*activep)
				continue;
			options->deny_users[options->num_deny_users++] =
			    xstrdup(arg);
		}
		break;

	case sAllowGroups:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_allow_groups >= MAX_ALLOW_GROUPS)
				fatal("%s line %d: too many allow groups.",
				    filename, linenum);
			if (!*activep)
				continue;
			options->allow_groups[options->num_allow_groups++] =
			    xstrdup(arg);
		}
		break;

	case sDenyGroups:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_deny_groups >= MAX_DENY_GROUPS)
				fatal("%s line %d: too many deny groups.",
				    filename, linenum);
			if (!*activep)
				continue;
			options->deny_groups[options->num_deny_groups++] =
			    xstrdup(arg);
		}
		break;

	case sCiphers:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.", filename, linenum);
		if (*arg != '-' && !ciphers_valid(*arg == '+' ? arg + 1 : arg))
			fatal("%s line %d: Bad SSH2 cipher spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (options->ciphers == NULL)
			options->ciphers = xstrdup(arg);
		break;

	case sMacs:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.", filename, linenum);
		if (*arg != '-' && !mac_valid(*arg == '+' ? arg + 1 : arg))
			fatal("%s line %d: Bad SSH2 mac spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (options->macs == NULL)
			options->macs = xstrdup(arg);
		break;

	case sKexAlgorithms:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.",
			    filename, linenum);
		if (*arg != '-' &&
		    !kex_names_valid(*arg == '+' ? arg + 1 : arg))
			fatal("%s line %d: Bad SSH2 KexAlgorithms '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (options->kex_algorithms == NULL)
			options->kex_algorithms = xstrdup(arg);
		break;

	case sSubsystem:
		if (options->num_subsystems >= MAX_SUBSYSTEMS) {
			fatal("%s line %d: too many subsystems defined.",
			    filename, linenum);
		}
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing subsystem name.",
			    filename, linenum);
		if (!*activep) {
			arg = strdelim(&cp);
			break;
		}
		for (i = 0; i < options->num_subsystems; i++)
			if (strcmp(arg, options->subsystem_name[i]) == 0)
				fatal("%s line %d: Subsystem '%s' already defined.",
				    filename, linenum, arg);
		options->subsystem_name[options->num_subsystems] = xstrdup(arg);
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing subsystem command.",
			    filename, linenum);
		options->subsystem_command[options->num_subsystems] = xstrdup(arg);

		/* Collect arguments (separate to executable) */
		p = xstrdup(arg);
		len = strlen(p) + 1;
		while ((arg = strdelim(&cp)) != NULL && *arg != '\0') {
			len += 1 + strlen(arg);
			p = xreallocarray(p, 1, len);
			strlcat(p, " ", len);
			strlcat(p, arg, len);
		}
		options->subsystem_args[options->num_subsystems] = p;
		options->num_subsystems++;
		break;

	case sMaxStartups:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing MaxStartups spec.",
			    filename, linenum);
		if ((n = sscanf(arg, "%d:%d:%d",
		    &options->max_startups_begin,
		    &options->max_startups_rate,
		    &options->max_startups)) == 3) {
			if (options->max_startups_begin >
			    options->max_startups ||
			    options->max_startups_rate > 100 ||
			    options->max_startups_rate < 1)
				fatal("%s line %d: Illegal MaxStartups spec.",
				    filename, linenum);
		} else if (n != 1)
			fatal("%s line %d: Illegal MaxStartups spec.",
			    filename, linenum);
		else
			options->max_startups = options->max_startups_begin;
		break;

	case sMaxAuthTries:
		intptr = &options->max_authtries;
		goto parse_int;

	case sMaxSessions:
		intptr = &options->max_sessions;
		goto parse_int;

	case sBanner:
		charptr = &options->banner;
		goto parse_filename;

	/*
	 * These options can contain %X options expanded at
	 * connect time, so that you can specify paths like:
	 *
	 * AuthorizedKeysFile	/etc/ssh_keys/%u
	 */
	case sAuthorizedKeysFile:
		if (*activep && options->num_authkeys_files == 0) {
			while ((arg = strdelim(&cp)) && *arg != '\0') {
				if (options->num_authkeys_files >=
				    MAX_AUTHKEYS_FILES)
					fatal("%s line %d: "
					    "too many authorized keys files.",
					    filename, linenum);
				options->authorized_keys_files[
				    options->num_authkeys_files++] =
				    tilde_expand_filename(arg, getuid());
			}
		}
		return 0;

	case sAuthorizedPrincipalsFile:
		charptr = &options->authorized_principals_file;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing file name.",
			    filename, linenum);
		if (*activep && *charptr == NULL) {
			*charptr = tilde_expand_filename(arg, getuid());
			/* increase optional counter */
			if (intptr != NULL)
				*intptr = *intptr + 1;
		}
		break;

	case sClientAliveInterval:
		intptr = &options->client_alive_interval;
		goto parse_time;

	case sClientAliveCountMax:
		intptr = &options->client_alive_count_max;
		goto parse_int;

	case sAcceptEnv:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (strchr(arg, '=') != NULL)
				fatal("%s line %d: Invalid environment name.",
				    filename, linenum);
			if (options->num_accept_env >= MAX_ACCEPT_ENV)
				fatal("%s line %d: too many allow env.",
				    filename, linenum);
			if (!*activep)
				continue;
			options->accept_env[options->num_accept_env++] =
			    xstrdup(arg);
		}
		break;

	case sPermitTunnel:
		intptr = &options->permit_tun;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing yes/point-to-point/"
			    "ethernet/no argument.", filename, linenum);
		value = -1;
		for (i = 0; tunmode_desc[i].val != -1; i++)
			if (strcmp(tunmode_desc[i].text, arg) == 0) {
				value = tunmode_desc[i].val;
				break;
			}
		if (value == -1)
			fatal("%s line %d: Bad yes/point-to-point/ethernet/"
			    "no argument: %s", filename, linenum, arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case sMatch:
		if (cmdline)
			fatal("Match directive not supported as a command-line "
			   "option");
		value = match_cfg_line(&cp, linenum, connectinfo);
		if (value < 0)
			fatal("%s line %d: Bad Match condition", filename,
			    linenum);
		*activep = value;
		break;

	case sPermitOpen:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing PermitOpen specification",
			    filename, linenum);
		n = options->num_permitted_opens;	/* modified later */
		if (strcmp(arg, "any") == 0) {
			if (*activep && n == -1) {
				channel_clear_adm_permitted_opens();
				options->num_permitted_opens = 0;
			}
			break;
		}
		if (strcmp(arg, "none") == 0) {
			if (*activep && n == -1) {
				options->num_permitted_opens = 1;
				channel_disable_adm_local_opens();
			}
			break;
		}
		if (*activep && n == -1)
			channel_clear_adm_permitted_opens();
		for (; arg != NULL && *arg != '\0'; arg = strdelim(&cp)) {
			p = hpdelim(&arg);
			if (p == NULL)
				fatal("%s line %d: missing host in PermitOpen",
				    filename, linenum);
			p = cleanhostname(p);
			if (arg == NULL || ((port = permitopen_port(arg)) < 0))
				fatal("%s line %d: bad port number in "
				    "PermitOpen", filename, linenum);
			if (*activep && n == -1)
				options->num_permitted_opens =
				    channel_add_adm_permitted_opens(p, port);
		}
		break;

	case sForceCommand:
		if (cp == NULL || *cp == '\0')
			fatal("%.200s line %d: Missing argument.", filename,
			    linenum);
		len = strspn(cp, WHITESPACE);
		if (*activep && options->adm_forced_command == NULL)
			options->adm_forced_command = xstrdup(cp + len);
		return 0;

	case sChrootDirectory:
		charptr = &options->chroot_directory;

		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing file name.",
			    filename, linenum);
		if (*activep && *charptr == NULL)
			*charptr = xstrdup(arg);
		break;

	case sTrustedUserCAKeys:
		charptr = &options->trusted_user_ca_keys;
		goto parse_filename;

	case sRevokedKeys:
		charptr = &options->revoked_keys_file;
		goto parse_filename;

	case sIPQoS:
		arg = strdelim(&cp);
		if ((value = parse_ipqos(arg)) == -1)
			fatal("%s line %d: Bad IPQoS value: %s",
			    filename, linenum, arg);
		arg = strdelim(&cp);
		if (arg == NULL)
			value2 = value;
		else if ((value2 = parse_ipqos(arg)) == -1)
			fatal("%s line %d: Bad IPQoS value: %s",
			    filename, linenum, arg);
		if (*activep) {
			options->ip_qos_interactive = value;
			options->ip_qos_bulk = value2;
		}
		break;

	case sVersionAddendum:
		if (cp == NULL || *cp == '\0')
			fatal("%.200s line %d: Missing argument.", filename,
			    linenum);
		len = strspn(cp, WHITESPACE);
		if (*activep && options->version_addendum == NULL) {
			if (strcasecmp(cp + len, "none") == 0)
				options->version_addendum = xstrdup("");
			else if (strchr(cp + len, '\r') != NULL)
				fatal("%.200s line %d: Invalid argument",
				    filename, linenum);
			else
				options->version_addendum = xstrdup(cp + len);
		}
		return 0;

	case sAuthorizedKeysCommand:
		if (cp == NULL)
			fatal("%.200s line %d: Missing argument.", filename,
			    linenum);
		len = strspn(cp, WHITESPACE);
		if (*activep && options->authorized_keys_command == NULL) {
			if (cp[len] != '/' && strcasecmp(cp + len, "none") != 0)
				fatal("%.200s line %d: AuthorizedKeysCommand "
				    "must be an absolute path",
				    filename, linenum);
			options->authorized_keys_command = xstrdup(cp + len);
		}
		return 0;

	case sAuthorizedKeysCommandUser:
		charptr = &options->authorized_keys_command_user;

		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing AuthorizedKeysCommandUser "
			    "argument.", filename, linenum);
		if (*activep && *charptr == NULL)
			*charptr = xstrdup(arg);
		break;

	case sAuthorizedPrincipalsCommand:
		if (cp == NULL)
			fatal("%.200s line %d: Missing argument.", filename,
			    linenum);
		len = strspn(cp, WHITESPACE);
		if (*activep &&
		    options->authorized_principals_command == NULL) {
			if (cp[len] != '/' && strcasecmp(cp + len, "none") != 0)
				fatal("%.200s line %d: "
				    "AuthorizedPrincipalsCommand must be "
				    "an absolute path", filename, linenum);
			options->authorized_principals_command =
			    xstrdup(cp + len);
		}
		return 0;

	case sAuthorizedPrincipalsCommandUser:
		charptr = &options->authorized_principals_command_user;

		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing "
			    "AuthorizedPrincipalsCommandUser argument.",
			    filename, linenum);
		if (*activep && *charptr == NULL)
			*charptr = xstrdup(arg);
		break;

	case sAuthenticationMethods:
		if (options->num_auth_methods == 0) {
			value = 0; /* seen "any" pseudo-method */
			value2 = 0; /* sucessfully parsed any method */
			while ((arg = strdelim(&cp)) && *arg != '\0') {
				if (options->num_auth_methods >=
				    MAX_AUTH_METHODS)
					fatal("%s line %d: "
					    "too many authentication methods.",
					    filename, linenum);
				if (strcmp(arg, "any") == 0) {
					if (options->num_auth_methods > 0) {
						fatal("%s line %d: \"any\" "
						    "must appear alone in "
						    "AuthenticationMethods",
						    filename, linenum);
					}
					value = 1;
				} else if (value) {
					fatal("%s line %d: \"any\" must appear "
					    "alone in AuthenticationMethods",
					    filename, linenum);
				} else if (auth2_methods_valid(arg, 0) != 0) {
					fatal("%s line %d: invalid "
					    "authentication method list.",
					    filename, linenum);
				}
				value2 = 1;
				if (!*activep)
					continue;
				options->auth_methods[
				    options->num_auth_methods++] = xstrdup(arg);
			}
			if (value2 == 0) {
				fatal("%s line %d: no AuthenticationMethods "
				    "specified", filename, linenum);
			}
		}
		return 0;

	case sStreamLocalBindMask:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing StreamLocalBindMask "
			    "argument.", filename, linenum);
		/* Parse mode in octal format */
		value = strtol(arg, &p, 8);
		if (arg == p || value < 0 || value > 0777)
			fatal("%s line %d: Bad mask.", filename, linenum);
		if (*activep)
			options->fwd_opts.streamlocal_bind_mask = (mode_t)value;
		break;

	case sStreamLocalBindUnlink:
		intptr = &options->fwd_opts.streamlocal_bind_unlink;
		goto parse_flag;

	case sFingerprintHash:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.",
			    filename, linenum);
		if ((value = ssh_digest_alg_by_name(arg)) == -1)
			fatal("%.200s line %d: Invalid hash algorithm \"%s\".",
			    filename, linenum, arg);
		if (*activep)
			options->fingerprint_hash = value;
		break;

	case sDeprecated:
	case sIgnore:
	case sUnsupported:
		do_log2(opcode == sIgnore ?
		    SYSLOG_LEVEL_DEBUG2 : SYSLOG_LEVEL_INFO,
		    "%s line %d: %s option %s", filename, linenum,
		    opcode == sUnsupported ? "Unsupported" : "Deprecated", arg);
		while (arg)
		    arg = strdelim(&cp);
		break;

	default:
		fatal("%s line %d: Missing handler for opcode %s (%d)",
		    filename, linenum, arg, opcode);
	}
	if ((arg = strdelim(&cp)) != NULL && *arg != '\0')
		fatal("%s line %d: garbage at end of line; \"%.200s\".",
		    filename, linenum, arg);
	return 0;
}

/* Reads the server configuration file. */

void
load_server_config(const char *filename, Buffer *conf)
{
	char line[4096], *cp;
	FILE *f;
	int lineno = 0;

	debug2("%s: filename %s", __func__, filename);
	if ((f = fopen(filename, "r")) == NULL) {
		perror(filename);
		exit(1);
	}
	buffer_clear(conf);
	while (fgets(line, sizeof(line), f)) {
		lineno++;
		if (strlen(line) == sizeof(line) - 1)
			fatal("%s line %d too long", filename, lineno);
		/*
		 * Trim out comments and strip whitespace
		 * NB - preserve newlines, they are needed to reproduce
		 * line numbers later for error messages
		 */
		if ((cp = strchr(line, '#')) != NULL)
			memcpy(cp, "\n", 2);
		cp = line + strspn(line, " \t\r");

		buffer_append(conf, cp, strlen(cp));
	}
	buffer_append(conf, "\0", 1);
	fclose(f);
	debug2("%s: done config len = %d", __func__, buffer_len(conf));
}

void
parse_server_match_config(ServerOptions *options,
   struct connection_info *connectinfo)
{
	ServerOptions mo;

	initialize_server_options(&mo);
	parse_server_config(&mo, "reprocess config", &cfg, connectinfo);
	copy_set_server_options(options, &mo, 0);
}

int parse_server_match_testspec(struct connection_info *ci, char *spec)
{
	char *p;

	while ((p = strsep(&spec, ",")) && *p != '\0') {
		if (strncmp(p, "addr=", 5) == 0) {
			ci->address = xstrdup(p + 5);
		} else if (strncmp(p, "host=", 5) == 0) {
			ci->host = xstrdup(p + 5);
		} else if (strncmp(p, "user=", 5) == 0) {
			ci->user = xstrdup(p + 5);
		} else if (strncmp(p, "laddr=", 6) == 0) {
			ci->laddress = xstrdup(p + 6);
		} else if (strncmp(p, "lport=", 6) == 0) {
			ci->lport = a2port(p + 6);
			if (ci->lport == -1) {
				fprintf(stderr, "Invalid port '%s' in test mode"
				   " specification %s\n", p+6, p);
				return -1;
			}
		} else {
			fprintf(stderr, "Invalid test mode specification %s\n",
			   p);
			return -1;
		}
	}
	return 0;
}

/*
 * returns 1 for a complete spec, 0 for partial spec and -1 for an
 * empty spec.
 */
int server_match_spec_complete(struct connection_info *ci)
{
	if (ci->user && ci->host && ci->address)
		return 1;	/* complete */
	if (!ci->user && !ci->host && !ci->address)
		return -1;	/* empty */
	return 0;	/* partial */
}

/*
 * Copy any supported values that are set.
 *
 * If the preauth flag is set, we do not bother copying the string or
 * array values that are not used pre-authentication, because any that we
 * do use must be explictly sent in mm_getpwnamallow().
 */
void
copy_set_server_options(ServerOptions *dst, ServerOptions *src, int preauth)
{
#define M_CP_INTOPT(n) do {\
	if (src->n != -1) \
		dst->n = src->n; \
} while (0)

	M_CP_INTOPT(password_authentication);
	M_CP_INTOPT(gss_authentication);
	M_CP_INTOPT(pubkey_authentication);
	M_CP_INTOPT(kerberos_authentication);
	M_CP_INTOPT(hostbased_authentication);
	M_CP_INTOPT(hostbased_uses_name_from_packet_only);
	M_CP_INTOPT(kbd_interactive_authentication);
	M_CP_INTOPT(permit_root_login);
	M_CP_INTOPT(permit_empty_passwd);

	M_CP_INTOPT(allow_tcp_forwarding);
	M_CP_INTOPT(allow_streamlocal_forwarding);
	M_CP_INTOPT(allow_agent_forwarding);
	M_CP_INTOPT(disable_forwarding);
	M_CP_INTOPT(permit_tun);
	M_CP_INTOPT(fwd_opts.gateway_ports);
	M_CP_INTOPT(fwd_opts.streamlocal_bind_unlink);
	M_CP_INTOPT(x11_display_offset);
	M_CP_INTOPT(x11_forwarding);
	M_CP_INTOPT(x11_use_localhost);
	M_CP_INTOPT(permit_tty);
	M_CP_INTOPT(permit_user_rc);
	M_CP_INTOPT(max_sessions);
	M_CP_INTOPT(max_authtries);
	M_CP_INTOPT(client_alive_count_max);
	M_CP_INTOPT(client_alive_interval);
	M_CP_INTOPT(ip_qos_interactive);
	M_CP_INTOPT(ip_qos_bulk);
	M_CP_INTOPT(rekey_limit);
	M_CP_INTOPT(rekey_interval);

	/*
	 * The bind_mask is a mode_t that may be unsigned, so we can't use
	 * M_CP_INTOPT - it does a signed comparison that causes compiler
	 * warnings.
	 */
	if (src->fwd_opts.streamlocal_bind_mask != (mode_t)-1) {
		dst->fwd_opts.streamlocal_bind_mask =
		    src->fwd_opts.streamlocal_bind_mask;
	}

	/* M_CP_STROPT and M_CP_STRARRAYOPT should not appear before here */
#define M_CP_STROPT(n) do {\
	if (src->n != NULL && dst->n != src->n) { \
		free(dst->n); \
		dst->n = src->n; \
	} \
} while(0)
#define M_CP_STRARRAYOPT(n, num_n) do {\
	if (src->num_n != 0) { \
		for (dst->num_n = 0; dst->num_n < src->num_n; dst->num_n++) \
			dst->n[dst->num_n] = xstrdup(src->n[dst->num_n]); \
	} \
} while(0)

	/* See comment in servconf.h */
	COPY_MATCH_STRING_OPTS();

	/* Arguments that accept '+...' need to be expanded */
	assemble_algorithms(dst);

	/*
	 * The only things that should be below this point are string options
	 * which are only used after authentication.
	 */
	if (preauth)
		return;

	/* These options may be "none" to clear a global setting */
	M_CP_STROPT(adm_forced_command);
	if (option_clear_or_none(dst->adm_forced_command)) {
		free(dst->adm_forced_command);
		dst->adm_forced_command = NULL;
	}
	M_CP_STROPT(chroot_directory);
	if (option_clear_or_none(dst->chroot_directory)) {
		free(dst->chroot_directory);
		dst->chroot_directory = NULL;
	}
}

#undef M_CP_INTOPT
#undef M_CP_STROPT
#undef M_CP_STRARRAYOPT

void
parse_server_config(ServerOptions *options, const char *filename, Buffer *conf,
    struct connection_info *connectinfo)
{
	int active, linenum, bad_options = 0;
	char *cp, *obuf, *cbuf;

	debug2("%s: config %s len %d", __func__, filename, buffer_len(conf));

	if ((obuf = cbuf = sshbuf_dup_string(conf)) == NULL)
		fatal("%s: sshbuf_dup_string failed", __func__);
	active = connectinfo ? 0 : 1;
	linenum = 1;
	while ((cp = strsep(&cbuf, "\n")) != NULL) {
		if (process_server_config_line(options, cp, filename,
		    linenum++, &active, connectinfo) != 0)
			bad_options++;
	}
	free(obuf);
	if (bad_options > 0)
		fatal("%s: terminating, %d bad configuration options",
		    filename, bad_options);
	process_queued_listen_addrs(options);
}

static const char *
fmt_multistate_int(int val, const struct multistate *m)
{
	u_int i;

	for (i = 0; m[i].key != NULL; i++) {
		if (m[i].value == val)
			return m[i].key;
	}
	return "UNKNOWN";
}

static const char *
fmt_intarg(ServerOpCodes code, int val)
{
	if (val == -1)
		return "unset";
	switch (code) {
	case sAddressFamily:
		return fmt_multistate_int(val, multistate_addressfamily);
	case sPermitRootLogin:
		return fmt_multistate_int(val, multistate_permitrootlogin);
	case sGatewayPorts:
		return fmt_multistate_int(val, multistate_gatewayports);
	case sCompression:
		return fmt_multistate_int(val, multistate_compression);
	case sAllowTcpForwarding:
		return fmt_multistate_int(val, multistate_tcpfwd);
	case sAllowStreamLocalForwarding:
		return fmt_multistate_int(val, multistate_tcpfwd);
	case sFingerprintHash:
		return ssh_digest_alg_name(val);
	default:
		switch (val) {
		case 0:
			return "no";
		case 1:
			return "yes";
		default:
			return "UNKNOWN";
		}
	}
}

static const char *
lookup_opcode_name(ServerOpCodes code)
{
	u_int i;

	for (i = 0; keywords[i].name != NULL; i++)
		if (keywords[i].opcode == code)
			return(keywords[i].name);
	return "UNKNOWN";
}

static void
dump_cfg_int(ServerOpCodes code, int val)
{
	printf("%s %d\n", lookup_opcode_name(code), val);
}

static void
dump_cfg_oct(ServerOpCodes code, int val)
{
	printf("%s 0%o\n", lookup_opcode_name(code), val);
}

static void
dump_cfg_fmtint(ServerOpCodes code, int val)
{
	printf("%s %s\n", lookup_opcode_name(code), fmt_intarg(code, val));
}

static void
dump_cfg_string(ServerOpCodes code, const char *val)
{
	printf("%s %s\n", lookup_opcode_name(code),
	    val == NULL ? "none" : val);
}

static void
dump_cfg_strarray(ServerOpCodes code, u_int count, char **vals)
{
	u_int i;

	for (i = 0; i < count; i++)
		printf("%s %s\n", lookup_opcode_name(code), vals[i]);
}

static void
dump_cfg_strarray_oneline(ServerOpCodes code, u_int count, char **vals)
{
	u_int i;

	if (count <= 0 && code != sAuthenticationMethods)
		return;
	printf("%s", lookup_opcode_name(code));
	for (i = 0; i < count; i++)
		printf(" %s",  vals[i]);
	if (code == sAuthenticationMethods && count == 0)
		printf(" any");
	printf("\n");
}

void
dump_config(ServerOptions *o)
{
	u_int i;
	int ret;
	struct addrinfo *ai;
	char addr[NI_MAXHOST], port[NI_MAXSERV], *s = NULL;
	char *laddr1 = xstrdup(""), *laddr2 = NULL;

	/* these are usually at the top of the config */
	for (i = 0; i < o->num_ports; i++)
		printf("port %d\n", o->ports[i]);
	dump_cfg_fmtint(sAddressFamily, o->address_family);

	/*
	 * ListenAddress must be after Port.  add_one_listen_addr pushes
	 * addresses onto a stack, so to maintain ordering we need to
	 * print these in reverse order.
	 */
	for (ai = o->listen_addrs; ai; ai = ai->ai_next) {
		if ((ret = getnameinfo(ai->ai_addr, ai->ai_addrlen, addr,
		    sizeof(addr), port, sizeof(port),
		    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {
			error("getnameinfo failed: %.100s",
			    (ret != EAI_SYSTEM) ? gai_strerror(ret) :
			    strerror(errno));
		} else {
			laddr2 = laddr1;
			if (ai->ai_family == AF_INET6)
				xasprintf(&laddr1, "listenaddress [%s]:%s\n%s",
				    addr, port, laddr2);
			else
				xasprintf(&laddr1, "listenaddress %s:%s\n%s",
				    addr, port, laddr2);
			free(laddr2);
		}
	}
	printf("%s", laddr1);
	free(laddr1);

	/* integer arguments */
	dump_cfg_int(sLoginGraceTime, o->login_grace_time);
	dump_cfg_int(sX11DisplayOffset, o->x11_display_offset);
	dump_cfg_int(sMaxAuthTries, o->max_authtries);
	dump_cfg_int(sMaxSessions, o->max_sessions);
	dump_cfg_int(sClientAliveInterval, o->client_alive_interval);
	dump_cfg_int(sClientAliveCountMax, o->client_alive_count_max);
	dump_cfg_oct(sStreamLocalBindMask, o->fwd_opts.streamlocal_bind_mask);

	/* formatted integer arguments */
	dump_cfg_fmtint(sPermitRootLogin, o->permit_root_login);
	dump_cfg_fmtint(sIgnoreRhosts, o->ignore_rhosts);
	dump_cfg_fmtint(sIgnoreUserKnownHosts, o->ignore_user_known_hosts);
	dump_cfg_fmtint(sHostbasedAuthentication, o->hostbased_authentication);
	dump_cfg_fmtint(sHostbasedUsesNameFromPacketOnly,
	    o->hostbased_uses_name_from_packet_only);
	dump_cfg_fmtint(sPubkeyAuthentication, o->pubkey_authentication);
#ifdef KRB5
	dump_cfg_fmtint(sKerberosAuthentication, o->kerberos_authentication);
	dump_cfg_fmtint(sKerberosOrLocalPasswd, o->kerberos_or_local_passwd);
	dump_cfg_fmtint(sKerberosTicketCleanup, o->kerberos_ticket_cleanup);
	dump_cfg_fmtint(sKerberosGetAFSToken, o->kerberos_get_afs_token);
#endif
#ifdef GSSAPI
	dump_cfg_fmtint(sGssAuthentication, o->gss_authentication);
	dump_cfg_fmtint(sGssCleanupCreds, o->gss_cleanup_creds);
#endif
	dump_cfg_fmtint(sPasswordAuthentication, o->password_authentication);
	dump_cfg_fmtint(sKbdInteractiveAuthentication,
	    o->kbd_interactive_authentication);
	dump_cfg_fmtint(sChallengeResponseAuthentication,
	    o->challenge_response_authentication);
	dump_cfg_fmtint(sPrintMotd, o->print_motd);
	dump_cfg_fmtint(sPrintLastLog, o->print_lastlog);
	dump_cfg_fmtint(sX11Forwarding, o->x11_forwarding);
	dump_cfg_fmtint(sX11UseLocalhost, o->x11_use_localhost);
	dump_cfg_fmtint(sPermitTTY, o->permit_tty);
	dump_cfg_fmtint(sPermitUserRC, o->permit_user_rc);
	dump_cfg_fmtint(sStrictModes, o->strict_modes);
	dump_cfg_fmtint(sTCPKeepAlive, o->tcp_keep_alive);
	dump_cfg_fmtint(sEmptyPasswd, o->permit_empty_passwd);
	dump_cfg_fmtint(sPermitUserEnvironment, o->permit_user_env);
	dump_cfg_fmtint(sCompression, o->compression);
	dump_cfg_fmtint(sGatewayPorts, o->fwd_opts.gateway_ports);
	dump_cfg_fmtint(sUseDNS, o->use_dns);
	dump_cfg_fmtint(sAllowTcpForwarding, o->allow_tcp_forwarding);
	dump_cfg_fmtint(sAllowAgentForwarding, o->allow_agent_forwarding);
	dump_cfg_fmtint(sDisableForwarding, o->disable_forwarding);
	dump_cfg_fmtint(sAllowStreamLocalForwarding, o->allow_streamlocal_forwarding);
	dump_cfg_fmtint(sStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);
	dump_cfg_fmtint(sFingerprintHash, o->fingerprint_hash);

	/* string arguments */
	dump_cfg_string(sPidFile, o->pid_file);
	dump_cfg_string(sXAuthLocation, o->xauth_location);
	dump_cfg_string(sCiphers, o->ciphers ? o->ciphers : KEX_SERVER_ENCRYPT);
	dump_cfg_string(sMacs, o->macs ? o->macs : KEX_SERVER_MAC);
	dump_cfg_string(sBanner, o->banner);
	dump_cfg_string(sForceCommand, o->adm_forced_command);
	dump_cfg_string(sChrootDirectory, o->chroot_directory);
	dump_cfg_string(sTrustedUserCAKeys, o->trusted_user_ca_keys);
	dump_cfg_string(sRevokedKeys, o->revoked_keys_file);
	dump_cfg_string(sAuthorizedPrincipalsFile,
	    o->authorized_principals_file);
	dump_cfg_string(sVersionAddendum, *o->version_addendum == '\0'
	    ? "none" : o->version_addendum);
	dump_cfg_string(sAuthorizedKeysCommand, o->authorized_keys_command);
	dump_cfg_string(sAuthorizedKeysCommandUser, o->authorized_keys_command_user);
	dump_cfg_string(sAuthorizedPrincipalsCommand, o->authorized_principals_command);
	dump_cfg_string(sAuthorizedPrincipalsCommandUser, o->authorized_principals_command_user);
	dump_cfg_string(sHostKeyAgent, o->host_key_agent);
	dump_cfg_string(sKexAlgorithms,
	    o->kex_algorithms ? o->kex_algorithms : KEX_SERVER_KEX);
	dump_cfg_string(sHostbasedAcceptedKeyTypes, o->hostbased_key_types ?
	    o->hostbased_key_types : KEX_DEFAULT_PK_ALG);
	dump_cfg_string(sHostKeyAlgorithms, o->hostkeyalgorithms ?
	    o->hostkeyalgorithms : KEX_DEFAULT_PK_ALG);
	dump_cfg_string(sPubkeyAcceptedKeyTypes, o->pubkey_key_types ?
	    o->pubkey_key_types : KEX_DEFAULT_PK_ALG);

	/* string arguments requiring a lookup */
	dump_cfg_string(sLogLevel, log_level_name(o->log_level));
	dump_cfg_string(sLogFacility, log_facility_name(o->log_facility));

	/* string array arguments */
	dump_cfg_strarray_oneline(sAuthorizedKeysFile, o->num_authkeys_files,
	    o->authorized_keys_files);
	dump_cfg_strarray(sHostKeyFile, o->num_host_key_files,
	     o->host_key_files);
	dump_cfg_strarray(sHostCertificate, o->num_host_cert_files,
	     o->host_cert_files);
	dump_cfg_strarray(sAllowUsers, o->num_allow_users, o->allow_users);
	dump_cfg_strarray(sDenyUsers, o->num_deny_users, o->deny_users);
	dump_cfg_strarray(sAllowGroups, o->num_allow_groups, o->allow_groups);
	dump_cfg_strarray(sDenyGroups, o->num_deny_groups, o->deny_groups);
	dump_cfg_strarray(sAcceptEnv, o->num_accept_env, o->accept_env);
	dump_cfg_strarray_oneline(sAuthenticationMethods,
	    o->num_auth_methods, o->auth_methods);

	/* other arguments */
	for (i = 0; i < o->num_subsystems; i++)
		printf("subsystem %s %s\n", o->subsystem_name[i],
		    o->subsystem_args[i]);

	printf("maxstartups %d:%d:%d\n", o->max_startups_begin,
	    o->max_startups_rate, o->max_startups);

	for (i = 0; tunmode_desc[i].val != -1; i++)
		if (tunmode_desc[i].val == o->permit_tun) {
			s = tunmode_desc[i].text;
			break;
		}
	dump_cfg_string(sPermitTunnel, s);

	printf("ipqos %s ", iptos2str(o->ip_qos_interactive));
	printf("%s\n", iptos2str(o->ip_qos_bulk));

	printf("rekeylimit %llu %d\n", (unsigned long long)o->rekey_limit,
	    o->rekey_interval);

	channel_print_adm_permitted_opens();
}
@


1.306
log
@Mark the sshd_config UsePrivilegeSeparation option as deprecated,
effectively making privsep mandatory in sandboxing mode.
ok markus@@ deraadt@@

(note: this doesn't remove the !privsep code paths, though that will
happen eventually).
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.305 2017/03/10 04:11:00 dtucker Exp $ */
a889 7
	{ NULL, -1 }
};
static const struct multistate multistate_privsep[] = {
	{ "yes",			PRIVSEP_NOSANDBOX },
	{ "sandbox",			PRIVSEP_ON },
	{ "nosandbox",			PRIVSEP_NOSANDBOX },
	{ "no",				PRIVSEP_OFF },
@


1.305
log
@Remove old null check from config dumper.  Patch from jjelen at redhat.com
vi bz#2687, ok djm@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.304 2017/02/03 23:01:19 djm Exp $ */
d492 1
a492 1
	{ "useprivilegeseparation", sUsePrivilegeSeparation, SSHCFG_GLOBAL},
a1324 5
	case sUsePrivilegeSeparation:
		intptr = &use_privsep;
		multistate_ptr = multistate_privsep;
		goto parse_multistate;

a2052 2
	case sUsePrivilegeSeparation:
		return fmt_multistate_int(val, multistate_privsep);
a2220 1
	dump_cfg_fmtint(sUsePrivilegeSeparation, use_privsep);
@


1.304
log
@support =- for removing methods from algorithms lists, e.g.
Ciphers=-*cbc; suggested by Cristian Ionescu-Idbohrn in bz#2671
"I like it" markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.303 2017/02/03 05:05:56 djm Exp $ */
a2109 2
	if (val == NULL)
		return;
@


1.303
log
@allow form-feed characters at EOL; bz#2431 ok dtucker@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.302 2017/01/06 03:45:41 djm Exp $ */
d1128 2
a1129 1
		if (!sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))
d1388 1
a1388 1
		if (!ciphers_valid(*arg == '+' ? arg + 1 : arg))
d1399 1
a1399 1
		if (!mac_valid(*arg == '+' ? arg + 1 : arg))
d1411 2
a1412 1
		if (!kex_names_valid(*arg == '+' ? arg + 1 : arg))
@


1.302
log
@sshd_config is documented to set GSSAPIStrictAcceptorCheck=yes by
default, so actually make it do this. bz#2637 ok dtucker
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.301 2016/11/30 03:00:05 djm Exp $ */
d922 9
@


1.301
log
@Add a sshd_config DisableForwaring option that disables X11, agent,
TCP, tunnel and Unix domain socket forwarding, as well as anything
else we might implement in the future.

This, like the 'restrict' authorized_keys flag, is intended to be a
simple and future-proof way of restricting an account. Suggested as
a complement to 'restrict' by Jann Horn; ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.300 2016/11/23 23:14:15 markus Exp $ */
d256 1
a256 1
		options->gss_strict_acceptor = 0;
@


1.300
log
@allow ClientAlive{Interval,CountMax} in Match; ok dtucker, djm
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.299 2016/11/06 05:46:37 djm Exp $ */
d156 1
d317 2
d390 1
a390 1
	sAllowStreamLocalForwarding, sFingerprintHash,
d517 1
d1311 4
d1924 1
d2216 1
@


1.299
log
@Validate address ranges for AllowUser/DenyUsers at configuration load
time and refuse to accept bad ones. It was previously possible to
specify invalid CIDR address ranges (e.g. djm@@127.1.2.3/55) and these
would always match.

Thanks to Laurence Parry for a detailed bug report. ok markus (for
a previous diff version)
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.298 2016/10/24 01:09:17 dtucker Exp $ */
d485 2
a486 2
	{ "clientaliveinterval", sClientAliveInterval, SSHCFG_GLOBAL },
	{ "clientalivecountmax", sClientAliveCountMax, SSHCFG_GLOBAL },
d1926 2
@


1.298
log
@Remove dead breaks, found via opencoverage.net.  ok deraadt@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.297 2016/09/28 20:32:42 djm Exp $ */
d1317 3
d1332 3
@


1.297
log
@restore pre-auth compression support in the client -- the previous
commit was intended to remove it from the server only.

remove a few server-side pre-auth compression bits that escaped

adjust wording of Compression directive in sshd_config(5)

pointed out by naddy@@ ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.296 2016/09/28 16:33:07 djm Exp $ */
a1066 1
		break;
@


1.296
log
@Remove support for pre-authentication compression. Doing compression
early in the protocol probably seemed reasonable in the 1990s, but
today it's clearly a bad idea in terms of both cryptography (cf.
multiple compression oracle attacks in TLS) and attack surface.

Moreover, to support it across privilege-separation zlib needed
the assistance of a complex shared-memory manager that made the
required attack surface considerably larger.

Prompted by Guido Vranken pointing out a compiler-elided security
check in the shared memory manager found by Stack
(http://css.csail.mit.edu/stack/); ok deraadt@@ markus@@

NB. pre-auth authentication has been disabled by default in sshd
for >10 years.
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.295 2016/08/25 23:57:54 djm Exp $ */
d877 1
a878 1
	{ "yes",			COMP_DELAYED },
@


1.295
log
@add a sIgnore opcode that silently ignores options and use it to
suppress noisy deprecation warnings for the Protocol directive.

req henning, ok markus
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.294 2016/08/19 03:18:06 djm Exp $ */
d878 1
a878 1
	{ "yes",			COMP_ZLIB },
@


1.294
log
@remove UseLogin option and support for having /bin/login manage
login sessions; ok deraadt markus dtucker
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.293 2016/08/15 12:27:56 naddy Exp $ */
d388 1
a388 1
	sDeprecated, sUnsupported
d475 1
a475 1
	{ "protocol", sDeprecated, SSHCFG_GLOBAL },
d676 1
a676 1
 *  - Add Match support for pre-kex directives, eg Protocol, Ciphers.
d1775 1
a1775 6
		logit("%s line %d: Deprecated option %s",
		    filename, linenum, arg);
		while (arg)
		    arg = strdelim(&cp);
		break;

d1777 4
a1780 2
		logit("%s line %d: Unsupported option %s",
		    filename, linenum, arg);
@


1.293
log
@Remove more SSH1 server code:
* Drop sshd's -k option.
* Retire configuration keywords that only apply to protocol 1, as well as
  the "protocol" keyword.
* Remove some related vestiges of protocol 1 support.

ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.292 2016/06/23 05:17:51 djm Exp $ */
a112 1
	options->use_login = -1;
a265 2
	if (options->use_login == -1)
		options->use_login = 0;
d367 1
a367 1
	sPermitUserEnvironment, sUseLogin, sAllowTcpForwarding, sCompression,
d462 1
a462 1
	{ "uselogin", sUseLogin, SSHCFG_GLOBAL },
a1230 4
	case sUseLogin:
		intptr = &options->use_login;
		goto parse_flag;

a2197 1
	dump_cfg_fmtint(sUseLogin, o->use_login);
@


1.292
log
@fix AuthenticationMethods during configuration re-parse;
reported by Juan Francisco Cantero Hurtado
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.291 2016/06/17 05:03:40 djm Exp $ */
a78 1
	options->server_key_bits = -1;
a79 1
	options->key_regeneration_time = -1;
a94 1
	options->rhosts_rsa_authentication = -1;
a98 1
	options->rsa_authentication = -1;
a126 1
	options->protocol = SSH_PROTO_UNKNOWN;
a184 2
	if (options->protocol == SSH_PROTO_UNKNOWN)
		options->protocol = SSH_PROTO_2;
d186 9
a194 14
		/* fill default hostkeys for protocols */
		if (options->protocol & SSH_PROTO_1)
			options->host_key_files[options->num_host_key_files++] =
			    _PATH_HOST_KEY_FILE;
		if (options->protocol & SSH_PROTO_2) {
			options->host_key_files[options->num_host_key_files++] =
			    _PATH_HOST_RSA_KEY_FILE;
			options->host_key_files[options->num_host_key_files++] =
			    _PATH_HOST_DSA_KEY_FILE;
			options->host_key_files[options->num_host_key_files++] =
			    _PATH_HOST_ECDSA_KEY_FILE;
			options->host_key_files[options->num_host_key_files++] =
			    _PATH_HOST_ED25519_KEY_FILE;
		}
a204 2
	if (options->server_key_bits == -1)
		options->server_key_bits = 1024;
a206 2
	if (options->key_regeneration_time == -1)
		options->key_regeneration_time = 3600;
a236 2
	if (options->rhosts_rsa_authentication == -1)
		options->rhosts_rsa_authentication = 0;
a240 2
	if (options->rsa_authentication == -1)
		options->rsa_authentication = 1;
d360 2
a361 3
	sPort, sHostKeyFile, sServerKeyBits, sLoginGraceTime,
	sKeyRegenerationTime, sPermitRootLogin, sLogFacility, sLogLevel,
	sRhostsRSAAuthentication, sRSAAuthentication,
d372 1
a372 1
	sIgnoreUserKnownHosts, sCiphers, sMacs, sProtocol, sPidFile,
d409 1
a409 1
	{ "serverkeybits", sServerKeyBits, SSHCFG_GLOBAL },
d411 1
a411 1
	{ "keyregenerationinterval", sKeyRegenerationTime, SSHCFG_GLOBAL },
d416 1
a416 1
	{ "rhostsrsaauthentication", sRhostsRSAAuthentication, SSHCFG_ALL },
d421 1
a421 1
	{ "rsaauthentication", sRSAAuthentication, SSHCFG_ALL },
d478 1
a478 1
	{ "protocol", sProtocol, SSHCFG_GLOBAL },
a970 12
	case sServerKeyBits:
		intptr = &options->server_key_bits;
 parse_int:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing integer value.",
			    filename, linenum);
		value = atoi(arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

a984 4
	case sKeyRegenerationTime:
		intptr = &options->key_regeneration_time;
		goto parse_time;

a1103 4
	case sRhostsRSAAuthentication:
		intptr = &options->rhosts_rsa_authentication;
		goto parse_flag;

a1129 4
	case sRSAAuthentication:
		intptr = &options->rsa_authentication;
		goto parse_flag;

d1192 9
a1200 1
		goto parse_int;
a1401 13
	case sProtocol:
		intptr = &options->protocol;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.", filename, linenum);
		value = proto_spec(arg);
		if (value == SSH_PROTO_UNKNOWN)
			fatal("%s line %d: Bad protocol spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*intptr == SSH_PROTO_UNKNOWN)
			*intptr = value;
		break;

a1909 1
	M_CP_INTOPT(rsa_authentication);
a2048 11
	case sProtocol:
		switch (val) {
		case SSH_PROTO_1:
			return "1";
		case SSH_PROTO_2:
			return "2";
		case (SSH_PROTO_1|SSH_PROTO_2):
			return "2,1";
		default:
			return "UNKNOWN";
		}
a2134 1
	dump_cfg_fmtint(sProtocol, o->protocol);
a2163 1
	dump_cfg_int(sServerKeyBits, o->server_key_bits);
a2164 1
	dump_cfg_int(sKeyRegenerationTime, o->key_regeneration_time);
a2175 1
	dump_cfg_fmtint(sRhostsRSAAuthentication, o->rhosts_rsa_authentication);
a2178 1
	dump_cfg_fmtint(sRSAAuthentication, o->rsa_authentication);
@


1.291
log
@ban AuthenticationMethods="" and accept AuthenticationMethods=any
for the default behaviour of not requiring multiple authentication

bz#2398 from Jakub Jelen; ok dtucker@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.290 2016/05/04 14:00:09 dtucker Exp $ */
d1765 1
d1789 1
d1795 1
a1795 1
			if (options->num_auth_methods == 0) {
@


1.290
log
@Fix inverted logic for updating StreamLocalBindMask which would cause the
server to set an invalid mask. ok djm@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.289 2016/05/03 15:57:39 djm Exp $ */
d366 9
d1764 1
d1771 13
a1783 1
				if (auth2_methods_valid(arg, 0) != 0)
d1787 1
d1793 4
d2173 1
a2173 1
	if (count <= 0)
d2178 2
@


1.289
log
@fix overriding of StreamLocalBindMask and StreamLocalBindUnlink in
Match blocks; found the hard way Rogan Dawes
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.288 2016/05/03 15:25:06 djm Exp $ */
d1963 1
a1963 1
	if (src->fwd_opts.streamlocal_bind_mask == (mode_t)-1) {
@


1.288
log
@don't forget to include StreamLocalBindUnlink in the config
dump output
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.287 2016/05/02 08:49:03 djm Exp $ */
d1945 1
d1957 10
@


1.287
log
@fix signed/unsigned errors reported by clang-3.7; add
sshbuf_dup_string() to replace a common idiom of
strdup(sshbuf_ptr()) with better safety checking;
feedback and ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.286 2016/03/07 19:02:43 djm Exp $ */
d2237 1
@


1.286
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.285 2016/02/17 05:29:04 djm Exp $ */
d2010 2
a2011 1
	obuf = cbuf = xstrdup(buffer_ptr(conf));
@


1.285
log
@make sandboxed privilege separation the default, not just for new
installs; "absolutely" deraadt@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.284 2016/01/29 02:54:45 dtucker Exp $ */
d663 1
d668 4
a671 4
	ci.host = get_canonical_hostname(use_dns);
	ci.address = get_remote_ipaddr();
	ci.laddress = get_local_ipaddr(packet_get_connection_in());
	ci.lport = get_local_port();
@


1.284
log
@Allow RekeyLimits in excess of 4G up to 2**63 bits (limited by the return
type of scan_scaled).  Part of bz#2521, ok djm.
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.283 2015/11/13 04:38:06 djm Exp $ */
d342 1
a342 1
	/* Turn privilege separation on by default */
d344 1
a344 1
		use_privsep = PRIVSEP_NOSANDBOX;
@


1.283
log
@Support "none" as an argument for sshd_config ForceCommand and
ChrootDirectory. Useful inside Match blocks to override a global
default. bz#2486 ok dtucker@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.282 2015/10/29 08:05:01 djm Exp $ */
a1280 4
			/* check for too-large or too-small limits */
			if (val64 > UINT_MAX)
				fatal("%.200s line %d: RekeyLimit too large",
				    filename, linenum);
d1286 1
a1286 1
			options->rekey_limit = (u_int32_t)val64;
d2303 1
a2303 1
	printf("rekeylimit %lld %d\n", (long long)o->rekey_limit,
@


1.282
log
@Fix "PubkeyAcceptedKeyTypes +..." inside a Match block; ok dtucker@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.281 2015/08/21 23:52:30 djm Exp $ */
d359 2
d1987 1
d1989 4
d1994 4
@


1.281
log
@Fix expansion of HostkeyAlgorithms=+...

Reported by Bryan Drewery
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.280 2015/08/06 14:53:21 deraadt Exp $ */
d171 14
d340 1
a340 10
	if (kex_assemble_names(KEX_SERVER_ENCRYPT, &options->ciphers) != 0 ||
	    kex_assemble_names(KEX_SERVER_MAC, &options->macs) != 0 ||
	    kex_assemble_names(KEX_SERVER_KEX, &options->kex_algorithms) != 0 ||
	    kex_assemble_names(KEX_DEFAULT_PK_ALG,
	    &options->hostkeyalgorithms) != 0 ||
	    kex_assemble_names(KEX_DEFAULT_PK_ALG,
	    &options->hostbased_key_types) != 0 ||
	    kex_assemble_names(KEX_DEFAULT_PK_ALG,
	    &options->pubkey_key_types) != 0)
		fatal("%s: kex_assemble_names failed", __func__);
d1974 3
@


1.280
log
@add prohibit-password as a synonymn for without-password, since the
without-password is causing too many questions.  Harden it to ban all
but pubkey, hostbased, and GSSAPI auth (when the latter is enabled)
from djm, ok markus
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.279 2015/07/31 15:38:09 chris Exp $ */
a244 2
	if (options->hostkeyalgorithms == NULL)
		options->hostkeyalgorithms = xstrdup(KEX_DEFAULT_PK_ALG);
d329 2
@


1.279
log
@Allow PermitRootLogin to be overridden by config

ok markus@@ deeradt@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.278 2015/07/30 19:23:02 deraadt Exp $ */
d877 1
@


1.278
log
@change default: PermitRootLogin without-password
matching install script changes coming as well
ok djm markus
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.277 2015/07/30 00:01:34 djm Exp $ */
d82 1
a82 1
	options->permit_root_login = PERMIT_NO_PASSWD;
d210 1
a210 1
		options->permit_root_login = PERMIT_NO;
@


1.277
log
@Allow ssh_config and sshd_config kex parameters options be prefixed
by a '+' to indicate that the specified items be appended to the
default rather than replacing it.

approach suggested by dtucker@@, feedback dlg@@, ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.276 2015/07/10 06:21:53 markus Exp $ */
d82 1
a82 1
	options->permit_root_login = PERMIT_NOT_SET;
@


1.276
log
@Turn off DSA by default; add HostKeyAlgorithms to the server and
PubkeyAcceptedKeyTypes to the client side, so it still can be
tested or turned back on; feedback and ok djm@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.275 2015/07/01 02:39:06 djm Exp $ */
a244 2
	if (options->hostbased_key_types == NULL)
		options->hostbased_key_types = xstrdup(KEX_DEFAULT_PK_ALG);
a250 2
	if (options->pubkey_key_types == NULL)
		options->pubkey_key_types = xstrdup(KEX_DEFAULT_PK_ALG);
d327 10
d1142 1
a1142 1
		if (!sshkey_names_valid2(arg, 1))
d1395 1
a1395 1
		if (!ciphers_valid(arg))
d1406 1
a1406 1
		if (!mac_valid(arg))
d1418 1
a1418 1
		if (!kex_names_valid(arg))
@


1.275
log
@twiddle PermitRootLogin back
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.274 2015/07/01 02:32:17 djm Exp $ */
d101 1
d246 3
a248 1
		options->hostbased_key_types = xstrdup("*");
d254 1
a254 1
		options->pubkey_key_types = xstrdup("*");
d376 1
d419 1
d1143 4
d2239 2
@


1.274
log
@twiddle; (this commit marks the openssh-6.9 release)
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.273 2015/07/01 01:56:13 djm Exp $ */
d209 1
a209 1
		options->permit_root_login = PERMIT_YES;
@


1.273
log
@put back default PermitRootLogin=no
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.272 2015/07/01 01:55:00 djm Exp $ */
d209 1
a209 1
		options->permit_root_login = PERMIT_NO;
@


1.272
log
@reset default PermitRootLogin to 'yes' (momentarily, for release)
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.271 2015/05/22 03:50:02 djm Exp $ */
d209 1
a209 1
		options->permit_root_login = PERMIT_YES;
@


1.271
log
@add knob to relax GSSAPI host credential check for multihomed hosts
bz#928, patch by Simon Wilkinson; ok dtucker
(kerberos/GSSAPI is not compiled by default on OpenBSD)
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.270 2015/05/21 06:43:30 djm Exp $ */
d209 1
a209 1
		options->permit_root_login = PERMIT_NO;
@


1.270
log
@add AuthorizedPrincipalsCommand that allows getting authorized_principals
from a subprocess rather than a file, which is quite useful in
deployments with large userbases

feedback and ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.269 2015/05/04 06:10:48 djm Exp $ */
d110 1
d264 2
d374 2
a375 1
	sGssAuthentication, sGssCleanupCreds, sAcceptEnv, sPermitTunnel,
d435 1
d439 1
d1172 4
@


1.269
log
@Remove pattern length argument from match_pattern_list(),
we only ever use it for strlen(pattern).

Prompted by hanno AT hboeck.de pointing an out-of-bound read
error caused by an incorrect pattern length found using AFL
and his own tools.

ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.268 2015/05/01 07:08:08 djm Exp $ */
d154 2
d376 1
d497 2
d1695 28
d2213 2
@


1.268
log
@a couple of parse targets were missing activep checks, causing them
to be misapplied in match context;
bz#2272 diagnosis and original patch from Sami Hartikainen
ok dtucker@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.267 2015/05/01 04:17:51 djm Exp $ */
a715 1
	size_t len;
a741 1
		len = strlen(arg);
d747 1
a747 1
			if (match_pattern_list(ci->user, arg, len, 0) != 1)
d768 1
a768 1
			if (match_hostname(ci->host, arg, len) != 1)
@


1.267
log
@make handling of AuthorizedPrincipalsFile=none more consistent
with other =none options; bz#2288 from Jakub Jelen; ok dtucker@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.266 2015/04/29 03:48:56 dtucker Exp $ */
d976 1
a976 1
		if (*intptr == -1)
d1554 1
a1554 1
		if (*intptr == -1)
d1693 1
a1693 1
		if (*activep && options->num_auth_methods == 0) {
d1704 2
d1715 2
a1716 2
			fatal("%s line %d: missing StreamLocalBindMask argument.",
			    filename, linenum);
d1721 2
a1722 1
		options->fwd_opts.streamlocal_bind_mask = (mode_t)value;
@


1.266
log
@Allow ListenAddress, Port and AddressFamily in any order.  bz#68,
ok djm@@, jmc@@ (for the man page bit).
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.265 2015/04/27 21:42:48 djm Exp $ */
d339 1
@


1.265
log
@Make sshd default to PermitRootLogin=no;
ok deraadt@@ rpe@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.264 2015/04/24 01:36:00 deraadt Exp $ */
d71 2
d193 2
a555 4
	if (options->num_ports == 0)
		options->ports[options->num_ports++] = SSH_DEFAULT_PORT;
	if (options->address_family == -1)
		options->address_family = AF_UNSPEC;
d585 45
a939 3
		if (options->listen_addrs != NULL)
			fatal("%s line %d: ports must be specified before "
			    "ListenAddress.", filename, linenum);
d991 1
a991 1
			add_listen_addr(options, arg, 0);
d1004 1
a1004 1
		add_listen_addr(options, p, port);
a1010 3
		if (options->listen_addrs != NULL)
			fatal("%s line %d: address family must be specified "
			    "before ListenAddress.", filename, linenum);
d1945 1
@


1.264
log
@rename xrealloc() to xreallocarray() since it follows that form.
ok djm
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.263 2015/04/23 04:59:10 dtucker Exp $ */
d202 1
a202 1
		options->permit_root_login = PERMIT_YES;
@


1.263
log
@Two small fixes for sshd -T: ListenAddress'es are added to a list head so
reverse the order when printing them to ensure the behaviour remains the same,
and print StreamLocalBindMask as octal with leading zero.  ok deraadt@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.262 2015/04/23 04:53:53 dtucker Exp $ */
d1399 1
a1399 1
			p = xrealloc(p, 1, len);
@


1.262
log
@Check for and reject missing arguments for VersionAddendum and ForceCommand.
bz#2281, patch from plautrba at redhat com, ok djm@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.261 2015/04/17 04:12:35 dtucker Exp $ */
d1983 6
d2032 1
d2040 5
a2044 1
	/* ListenAddress must be after Port */
d2053 1
d2055 2
a2056 1
				printf("listenaddress [%s]:%s\n", addr, port);
d2058 3
a2060 1
				printf("listenaddress %s:%s\n", addr, port);
d2063 2
d2075 1
a2075 1
	dump_cfg_int(sStreamLocalBindMask, o->fwd_opts.streamlocal_bind_mask);
@


1.261
log
@Add some missing options to sshd -T and fix the output of VersionAddendum
HostCertificate.  bz#2346, patch from jjelen at redhat com, ok djm.
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.260 2015/02/02 01:57:44 deraadt Exp $ */
d1567 1
a1567 1
		if (cp == NULL)
d1612 1
a1612 1
		if (cp == NULL)
@


1.260
log
@increasing encounters with difficult DNS setups in darknets has
convinced me UseDNS off by default is better
ok djm
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.259 2015/01/16 06:40:12 deraadt Exp $ */
d2011 2
d2058 1
d2100 1
d2117 2
a2118 1
	dump_cfg_string(sVersionAddendum, o->version_addendum);
d2138 1
a2138 1
	dump_cfg_strarray(sHostKeyFile, o->num_host_cert_files,
@


1.259
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.258 2015/01/13 07:39:19 djm Exp $ */
d294 1
a294 1
		options->use_dns = 1;
@


1.258
log
@add sshd_config HostbasedAcceptedKeyTypes and PubkeyAcceptedKeyTypes
options to allow sshd to control what public key types will be
accepted. Currently defaults to all. Feedback & ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.257 2014/12/22 07:55:51 djm Exp $ */
d29 1
d533 1
a533 1
	char *expanded, *ret, cwd[MAXPATHLEN];
@


1.257
log
@make internal handling of filename arguments of "none" more consistent
with ssh. "none" arguments are now replaced with NULL when the
configuration is finalised.

Simplifies checking later on (just need to test not-NULL rather than
that + strcmp) and cleans up some inconsistencies. ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.256 2014/12/21 22:27:56 djm Exp $ */
d97 1
d100 1
d236 2
d242 2
d344 2
a345 2
	sPort, sHostKeyFile, sServerKeyBits, sLoginGraceTime, sKeyRegenerationTime,
	sPermitRootLogin, sLogFacility, sLogLevel,
d358 2
a359 2
	sGatewayPorts, sPubkeyAuthentication, sXAuthLocation, sSubsystem,
	sMaxStartups, sMaxAuthTries, sMaxSessions,
d361 2
a362 2
	sHostbasedUsesNameFromPacketOnly, sClientAliveInterval,
	sClientAliveCountMax, sAuthorizedKeysFile,
d401 1
d404 1
d1074 14
d1096 4
d2118 4
@


1.256
log
@Add FingerprintHash option to control algorithm used for key
fingerprints. Default changes from MD5 to SHA256 and format
from hex to base64.

Feedback and ok naddy@@ markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.255 2014/11/24 03:39:22 jsg Exp $ */
d155 7
d165 2
d191 1
a191 1
		options->pid_file = _PATH_SSH_DAEMON_PID_FILE;
d215 1
a215 1
		options->xauth_location = _PATH_XAUTH;
d315 18
d526 2
d1966 2
a1967 1
	printf("%s %s\n", lookup_opcode_name(code), val);
@


1.255
log
@Fix crashes in the handling of the sshd config file found with the afl
fuzzer.

ok deraadt@@ djm@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.254 2014/10/24 02:01:20 lteo Exp $ */
d53 1
d152 1
d301 2
d339 1
a339 1
	sAllowStreamLocalForwarding,
d458 1
d1630 12
d1884 2
d2042 1
@


1.254
log
@Remove unnecessary include: netinet/in_systm.h is not needed by these
programs.

ok deraadt@@ millert@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.253 2014/10/13 00:38:35 djm Exp $ */
d1567 3
d1584 3
@


1.253
log
@whitespace
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.252 2014/08/19 23:58:28 djm Exp $ */
a18 1
#include <netinet/in_systm.h>
@


1.252
log
@When dumping the server configuration (sshd -T), print correct KEX,
MAC and cipher defaults. Spotted by Iain Morgan
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.251 2014/07/15 15:54:14 millert Exp $ */
d2036 1
a2036 1
  	    o->kex_algorithms ? o->kex_algorithms : KEX_SERVER_KEX);
@


1.251
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.250 2014/07/03 22:40:43 djm Exp $ */
d53 1
d2022 2
a2023 3
	dump_cfg_string(sCiphers, o->ciphers ? o->ciphers :
	    cipher_alg_list(',', 0));
	dump_cfg_string(sMacs, o->macs ? o->macs : mac_alg_list(','));
d2035 2
a2036 2
	dump_cfg_string(sKexAlgorithms, o->kex_algorithms ? o->kex_algorithms :
	    kex_alg_list(','));
@


1.250
log
@Add a sshd_config PermitUserRC option to control whether ~/.ssh/rc is
executed, mirroring the no-user-rc authorized_keys option;
bz#2160; ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.249 2014/01/29 06:18:35 djm Exp $ */
d38 1
a41 1
#include "misc.h"
d114 1
d124 3
a126 1
	options->gateway_ports = -1;
d259 2
d263 2
a264 2
	if (options->gateway_ports == -1)
		options->gateway_ports = 0;
d295 4
d334 2
d451 3
d1165 1
a1165 1
		intptr = &options->gateway_ports;
d1200 5
d1603 16
d1758 1
d1761 1
a1761 1
	M_CP_INTOPT(gateway_ports);
d1859 2
d2012 1
a2012 1
	dump_cfg_fmtint(sGatewayPorts, o->gateway_ports);
d2015 1
@


1.249
log
@remove experimental, never-enabled JPAKE code; ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.248 2013/12/06 13:39:49 markus Exp $ */
d87 1
d204 2
d324 1
a324 1
	sAuthenticationMethods, sHostKeyAgent,
d425 1
d1090 4
d1730 1
d1967 1
@


1.248
log
@support ed25519 keys (hostkeys and user identities) using the public domain
ed25519 reference code from SUPERCOP, see http://ed25519.cr.yp.to/software.html
feedback, help & ok djm@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.247 2013/12/05 01:16:41 djm Exp $ */
a140 1
	options->zero_knowledge_password_authentication = -1;
a280 2
	if (options->zero_knowledge_password_authentication == -1)
		options->zero_knowledge_password_authentication = 0;
d317 1
a317 1
	sZeroKnowledgePasswordAuthentication, sHostCertificate,
a376 5
#ifdef JPAKE
	{ "zeroknowledgepasswordauthentication", sZeroKnowledgePasswordAuthentication, SSHCFG_ALL },
#else
	{ "zeroknowledgepasswordauthentication", sUnsupported, SSHCFG_ALL },
#endif
a1049 4
	case sZeroKnowledgePasswordAuthentication:
		intptr = &options->zero_knowledge_password_authentication;
		goto parse_flag;

a1710 1
	M_CP_INTOPT(zero_knowledge_password_authentication);
a1946 4
#endif
#ifdef JPAKE
	dump_cfg_fmtint(sZeroKnowledgePasswordAuthentication,
	    o->zero_knowledge_password_authentication);
@


1.247
log
@bz#2161 - fix AuthorizedKeysCommand inside a Match block and
rearrange things so the same error is harder to make next time;
with and ok dtucker@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.246 2013/11/21 00:45:44 djm Exp $ */
d167 2
@


1.246
log
@Add a new protocol 2 transport cipher "chacha20-poly1305@@openssh.com"
that combines Daniel Bernstein's ChaCha20 stream cipher and Poly1305 MAC
to build an authenticated encryption mode.

Inspired by and similar to Adam Langley's proposal for TLS:
http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03
but differs in layout used for the MAC calculation and the use of a
second ChaCha20 instance to separately encrypt packet lengths.
Details are in the PROTOCOL.chacha20poly1305 file.

Feedback markus@@, naddy@@; manpage bits Loganden Velvindron @@ AfriNIC
ok markus@@ naddy@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.245 2013/11/07 11:58:27 dtucker Exp $ */
a1697 18
/* Helper macros */
#define M_CP_INTOPT(n) do {\
	if (src->n != -1) \
		dst->n = src->n; \
} while (0)
#define M_CP_STROPT(n) do {\
	if (src->n != NULL) { \
		free(dst->n); \
		dst->n = src->n; \
	} \
} while(0)
#define M_CP_STRARRAYOPT(n, num_n) do {\
	if (src->num_n != 0) { \
		for (dst->num_n = 0; dst->num_n < src->num_n; dst->num_n++) \
			dst->n[dst->num_n] = xstrdup(src->n[dst->num_n]); \
	} \
} while(0)

d1708 5
a1721 2
	M_CP_STROPT(authorized_keys_command);
	M_CP_STROPT(authorized_keys_command_user);
d1739 14
@


1.245
log
@Output the effective values of Ciphers, MACs and KexAlgorithms when
the default has not been overridden.  ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.244 2013/10/29 09:48:02 djm Exp $ */
d1989 1
a1989 1
	    cipher_alg_list(','));
@


1.244
log
@shd_config PermitTTY to disallow TTY allocation, mirroring the
longstanding no-pty authorized_keys option;
bz#2070, patch from Teran McKinney; ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.243 2013/10/24 00:51:48 dtucker Exp $ */
d1988 3
a1990 2
	dump_cfg_string(sCiphers, o->ciphers);
	dump_cfg_string(sMacs, o->macs);
d2002 2
@


1.243
log
@Disallow empty Match statements and add "Match all" which matches everything.
ok djm, man page help jmc@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.242 2013/10/23 05:40:58 dtucker Exp $ */
d86 1
d200 2
d306 1
a306 1
	sStrictModes, sEmptyPasswd, sTCPKeepAlive,
d427 1
d1092 4
d1747 1
d1973 1
@


1.242
log
@fix comment
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.241 2013/08/06 23:06:01 djm Exp $ */
d609 1
a609 1
	int result = 1, port;
d623 11
d726 4
@


1.241
log
@add cast to avoid format warning; from portable
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.240 2013/07/19 07:37:48 markus Exp $ */
d603 1
a603 1
 * to check every * attribute and set the result to zero if any attribute does
@


1.240
log
@add ssh-agent(1) support to sshd(8); allows encrypted hostkeys,
or hostkeys on smartcards; most of the work by Zev Weiss; bz #1974
ok djm@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.239 2013/05/17 00:13:14 djm Exp $ */
d2014 2
a2015 1
	printf("rekeylimit %lld %d\n", o->rekey_limit, o->rekey_interval);
@


1.239
log
@bye, bye xfree(); ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.238 2013/05/16 10:44:06 dtucker Exp $ */
d73 1
d319 1
a319 1
	sAuthenticationMethods,
d336 1
d936 11
d1975 1
@


1.238
log
@remove another now-unused variable
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.237 2013/05/16 10:43:34 dtucker Exp $ */
d482 1
a482 1
	xfree(expanded);
d1669 1
a1669 2
		if (dst->n != NULL) \
			xfree(dst->n); \
d1753 1
a1753 1
	xfree(obuf);
@


1.237
log
@remove now-unused variables
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.236 2013/05/16 09:12:31 dtucker Exp $ */
d773 1
a773 1
	char *cp, **charptr, *arg, *p, *endofnumber;
@


1.236
log
@switch RekeyLimit traffic volume parsing to scan_scaled.  ok djm@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.235 2013/05/16 04:09:14 dtucker Exp $ */
d774 1
a774 1
	int cmdline = 0, *intptr, value, value2, n, port, scale;
d780 1
a780 1
	long long orig, val64;
@


1.235
log
@Add RekeyLimit to sshd with the same syntax as the client allowing rekeying
based on traffic volume or time.  ok djm@@, help & ok jmc@@ for the man page.
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.234 2013/02/06 00:20:42 dtucker Exp $ */
d32 1
d1093 5
a1097 27
			if (arg[0] < '0' || arg[0] > '9')
				fatal("%.200s line %d: Bad number.", filename,
				    linenum);
			orig = val64 = strtoll(arg, &endofnumber, 10);
			if (arg == endofnumber)
				fatal("%.200s line %d: Bad number.", filename,
			 linenum);
	 		switch (toupper(*endofnumber)) {
			case '\0':
				scale = 1;
				break;
			case 'K':
				scale = 1<<10;
				break;
			case 'M':
				scale = 1<<20;
				break;
			case 'G':
				scale = 1<<30;
				break;
			default:
				fatal("%.200s line %d: Invalid RekeyLimit "
				    "suffix", filename, linenum);
			}
			val64 *= scale;
			/* detect integer wrap and too-large limits */
			if ((val64 / scale) != orig || val64 > UINT_MAX)
@


1.234
log
@Change default of MaxStartups to 10:30:100 to start doing random early
drop at 10 connections up to 100 connections.  This will make it harder
to DoS as CPUs have come a long way since the original value was set
back in 2000.  Prompted by nion at debian org, ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.233 2012/12/02 20:46:11 djm Exp $ */
d22 1
d107 2
d241 4
d303 1
a303 1
	sAllowUsers, sDenyUsers, sAllowGroups, sDenyGroups,
d393 1
d772 2
a773 2
	char *cp, **charptr, *arg, *p;
	int cmdline = 0, *intptr, value, value2, n;
a776 1
	int port;
d779 1
d1084 53
d1737 2
d2021 2
@


1.233
log
@make AllowTcpForwarding accept "local" and "remote" in addition to its
current "yes"/"no" to allow the server to specify whether just local or
remote TCP forwarding is enabled. ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.232 2012/11/04 11:09:15 djm Exp $ */
d245 1
a245 1
		options->max_startups = 10;
d247 1
a247 1
		options->max_startups_rate = 100;		/* 100% */
d249 1
a249 1
		options->max_startups_begin = options->max_startups;
@


1.232
log
@Support multiple required authentication via an AuthenticationMethods
option. This option lists one or more comma-separated lists of
authentication method names. Successful completion of all the methods in
any list is required for authentication to complete;
feedback and ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.231 2012/10/30 21:29:54 djm Exp $ */
d239 1
a239 1
		options->allow_tcp_forwarding = 1;
d750 8
d1109 2
a1110 1
		goto parse_flag;
a1389 1
				channel_clear_adm_permitted_opens();
d1746 2
@


1.231
log
@new sshd_config option AuthorizedKeysCommand to support fetching
authorized_keys from a command in addition to (or instead of) from
the filesystem. The command is run as the target server user unless
another specified via a new AuthorizedKeysCommandUser option.

patch originally by jchadima AT redhat.com, reworked by me; feedback
and ok markus@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.230 2012/09/13 23:37:36 dtucker Exp $ */
d49 2
d310 1
d426 1
d1484 18
d1928 2
@


1.230
log
@Fix comment line length
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.229 2012/07/13 01:35:21 dtucker Exp $ */
d131 2
d307 1
d420 2
d1461 19
d1630 2
d1887 2
@


1.229
log
@handle long comments in config files better.  bz#2025, ok markus
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.228 2012/07/10 02:19:15 djm Exp $ */
d582 3
a584 2
 * All of the attributes on a single Match line are ANDed together, so we need to check every
 * attribute and set the result to zero if any attribute does not match.
@


1.228
log
@Turn on systrace sandboxing of pre-auth sshd by default for new installs
by shipping a config that overrides the current UsePrivilegeSeparation=yes
default. Make it easier to flip the default in the future by adding too.
prodded markus@@ feedback dtucker@@ "get it in" deraadt@@
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.227 2012/06/19 18:25:27 markus Exp $ */
d1484 1
a1484 1
	char line[1024], *cp;
d1486 1
d1495 3
@


1.227
log
@sshd_config: extend Match to allow AcceptEnv and {Allow,Deny}{Users,Groups}
this allows 'Match LocalPort 1022' combined with 'AllowUser bauer'
ok djm@@ (back in March)
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.226 2012/05/13 01:42:32 dtucker Exp $ */
d274 1
a274 1
		use_privsep = PRIVSEP_ON;
d734 3
a736 2
	{ "sandbox",			PRIVSEP_SANDBOX },
	{ "yes",			PRIVSEP_ON },
@


1.226
log
@Add "Match LocalAddress" and "Match LocalPort" to sshd and adjust tests
to match.  Feedback and ok djm@@ markus@@.
@
text
@d2 1
a2 1
/* $OpenBSD: servconf.c,v 1.225 2012/04/12 02:42:32 djm Exp $ */
d384 4
a387 4
	{ "allowusers", sAllowUsers, SSHCFG_GLOBAL },
	{ "denyusers", sDenyUsers, SSHCFG_GLOBAL },
	{ "allowgroups", sAllowGroups, SSHCFG_GLOBAL },
	{ "denygroups", sDenyGroups, SSHCFG_GLOBAL },
d405 1
a405 1
	{ "acceptenv", sAcceptEnv, SSHCFG_GLOBAL },
d1106 2
d1118 2
d1130 2
d1142 4
a1145 1
			options->deny_groups[options->num_deny_groups++] = xstrdup(arg);
d1319 1
a1319 1
				break;
@


1.225
log
@VersionAddendum option to allow server operators to append some arbitrary
text to the SSH-... banner; ok deraadt@@ "don't care" markus@@
@
text
@d1 2
a2 1
/* $OpenBSD: servconf.c,v 1.224 2012/03/29 23:54:36 dtucker Exp $ */
d47 2
d506 14
d581 4
d586 1
a586 2
match_cfg_line(char **condition, int line, const char *user, const char *host,
    const char *address)
d588 1
a588 1
	int result = 1;
d592 1
a592 1
	if (user == NULL)
d595 5
a599 3
		debug3("checking match for '%s' user %s host %s addr %s", cp,
		    user ? user : "(null)", host ? host : "(null)",
		    address ? address : "(null)");
d608 1
a608 1
			if (!user) {
d612 1
a612 1
			if (match_pattern_list(user, arg, len, 0) != 1)
d616 1
a616 1
				    "line %d", user, arg, line);
d618 5
a622 1
			switch (match_cfg_line_group(arg, line, user)) {
d629 1
a629 1
			if (!host) {
d633 1
a633 1
			if (match_hostname(host, arg, len) != 1)
d637 1
a637 1
				    "%.100s' at line %d", host, arg, line);
d639 5
a643 1
			switch (addr_match_list(address, arg)) {
d646 1
a646 1
				    "%.100s' at line %d", address, arg, line);
d655 35
d695 1
a695 1
	if (user != NULL)
d742 2
a743 2
    const char *filename, int linenum, int *activep, const char *user,
    const char *host, const char *address)
d774 1
a774 1
		if (user == NULL) {
d1339 1
a1339 1
		value = match_cfg_line(&cp, linenum, user, host, address);
d1501 2
a1502 2
parse_server_match_config(ServerOptions *options, const char *user,
    const char *host, const char *address)
d1507 1
a1507 1
	parse_server_config(&mo, "reprocess config", &cfg, user, host, address);
d1511 42
d1626 1
a1626 1
    const char *user, const char *host, const char *address)
d1634 1
a1634 1
	active = user ? 0 : 1;
d1638 1
a1638 1
		    linenum++, &active, user, host, address) != 0)
@


1.224
log
@Add PermitOpen none option based on patch from Loganaden Velvindron
(bz #1949).  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.223 2011/09/23 00:22:04 dtucker Exp $ */
d134 1
d267 2
a268 1

d301 1
a301 1
	sKexAlgorithms, sIPQoS,
d414 1
d1364 16
d1738 1
@


1.223
log
@Add wildcard support to PermitOpen, allowing things like "PermitOpen
localhost:*".  bz #1857, ok djm markus.
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.222 2011/06/22 21:57:01 djm Exp $ */
d1288 8
@


1.222
log
@introduce sandboxing of the pre-auth privsep child using systrace(4).

This introduces a new "UsePrivilegeSeparation=sandbox" option for
sshd_config that applies mandatory restrictions on the syscalls the
privsep child can perform. This prevents a compromised privsep child
from being used to attack other hosts (by opening sockets and proxying)
or probing local kernel attack surface.

The sandbox is implemented using systrace(4) in unsupervised "fast-path"
mode, where a list of permitted syscalls is supplied. Any syscall not
on the list results in SIGKILL being sent to the privsep child. Note
that this requires a kernel with the new SYSTR_POLICY_KILL option.

UsePrivilegeSeparation=sandbox will become the default in the future
so please start testing it now.

feedback dtucker@@; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.221 2011/06/22 21:47:28 djm Exp $ */
d1299 1
a1299 1
			if (arg == NULL || (port = a2port(arg)) <= 0)
@


1.221
log
@reuse the multistate option arrays to pretty-print options for "sshd -T"
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.220 2011/06/17 21:47:35 djm Exp $ */
d269 1
a269 1
		use_privsep = 1;
d665 6
d1030 2
a1031 1
		goto parse_flag;
d1539 2
@


1.220
log
@factor out multi-choice option parsing into a parse_multistate label
and some support structures; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.219 2011/05/23 03:30:07 djm Exp $ */
d1507 12
d1521 12
a1532 23
	if (code == sAddressFamily) {
		switch (val) {
		case AF_INET:
			return "inet";
		case AF_INET6:
			return "inet6";
		case AF_UNSPEC:
			return "any";
		default:
			return "UNKNOWN";
		}
	}
	if (code == sPermitRootLogin) {
		switch (val) {
		case PERMIT_NO_PASSWD:
			return "without-password";
		case PERMIT_FORCED_ONLY:
			return "forced-commands-only";
		case PERMIT_YES:
			return "yes";
		}
	}
	if (code == sProtocol) {
d1543 9
a1552 13
	if (code == sGatewayPorts && val == 2)
		return "clientspecified";
	if (code == sCompression && val == COMP_DELAYED)
		return "delayed";
	switch (val) {
	case -1:
		return "unset";
	case 0:
		return "no";
	case 1:
		return "yes";
	}
	return "UNKNOWN";
@


1.219
log
@allow AuthorizedKeysFile to specify multiple files, separated by spaces.
Bring back authorized_keys2 as a default search path (to avoid breaking
existing users of this file), but override this in sshd_config so it will
be no longer used on fresh installs. Maybe in 2015 we can remove it
entierly :)

feedback and ok markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.218 2011/05/20 03:25:45 djm Exp $ */
d635 31
d679 1
d789 6
d797 1
a797 1
			fatal("%s line %d: missing address family.",
d799 9
a807 12
		intptr = &options->address_family;
		if (options->listen_addrs != NULL)
			fatal("%s line %d: address family must be specified before "
			    "ListenAddress.", filename, linenum);
		if (strcasecmp(arg, "inet") == 0)
			value = AF_INET;
		else if (strcasecmp(arg, "inet6") == 0)
			value = AF_INET6;
		else if (strcasecmp(arg, "any") == 0)
			value = AF_UNSPEC;
		else
			fatal("%s line %d: unsupported address family \"%s\".",
d809 1
a809 1
		if (*intptr == -1)
d848 2
a849 21
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/"
			    "without-password/forced-commands-only/no "
			    "argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "without-password") == 0)
			value = PERMIT_NO_PASSWD;
		else if (strcmp(arg, "forced-commands-only") == 0)
			value = PERMIT_FORCED_ONLY;
		else if (strcmp(arg, "yes") == 0)
			value = PERMIT_YES;
		else if (strcmp(arg, "no") == 0)
			value = PERMIT_NO;
		else
			fatal("%s line %d: Bad yes/"
			    "without-password/forced-commands-only/no "
			    "argument: %s", filename, linenum, arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;
d980 2
a981 17
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/no/delayed "
			    "argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "delayed") == 0)
			value = COMP_DELAYED;
		else if (strcmp(arg, "yes") == 0)
			value = COMP_ZLIB;
		else if (strcmp(arg, "no") == 0)
			value = COMP_NONE;
		else
			fatal("%s line %d: Bad yes/no/delayed "
			    "argument: %s", filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;
d985 2
a986 17
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/no/clientspecified "
			    "argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "clientspecified") == 0)
			value = 2;
		else if (strcmp(arg, "yes") == 0)
			value = 1;
		else if (strcmp(arg, "no") == 0)
			value = 0;
		else
			fatal("%s line %d: Bad yes/no/clientspecified "
			    "argument: %s", filename, linenum, arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;
@


1.218
log
@use a macro to define which string options to copy between configs
for Match. This avoids problems caused by forgetting to keep three
code locations in perfect sync and ordering

"this is at once beautiful and horrible" + ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.217 2011/05/20 02:00:19 dtucker Exp $ */
d122 1
a122 1
	options->authorized_keys_file = NULL;
d252 6
a257 2
	if (options->authorized_keys_file == NULL)
		options->authorized_keys_file = xstrdup(_PATH_SSH_USER_PERMITTED_KEYS);
d293 1
a293 1
	sClientAliveCountMax, sAuthorizedKeysFile, sAuthorizedKeysFile2,
d398 1
a398 1
	{ "authorizedkeysfile2", sAuthorizedKeysFile2, SSHCFG_ALL },
d1204 14
a1217 2
		charptr = &options->authorized_keys_file;
		goto parse_tilde_filename;
a1219 1
 parse_tilde_filename:
d1438 6
d1488 1
d1495 1
d1609 12
a1620 1
		printf("%s %s\n", lookup_opcode_name(code),  vals[i]);
a1712 1
	dump_cfg_string(sAuthorizedKeysFile, o->authorized_keys_file);
d1725 2
@


1.217
log
@Add comment documenting what should be after the preauth check.  ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.216 2011/05/20 00:55:02 djm Exp $ */
d1458 2
a1459 5
	M_CP_STROPT(banner);
	M_CP_STROPT(trusted_user_ca_keys);
	M_CP_STROPT(revoked_keys_file);
	M_CP_STROPT(authorized_keys_file);
	M_CP_STROPT(authorized_principals_file);
@


1.216
log
@the options TrustedUserCAKeys, RevokedKeysFile, AuthorizedKeysFile
and AuthorizedPrincipalsFile were not being correctly applied in
Match blocks, despite being overridable there; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.215 2011/05/11 04:47:06 djm Exp $ */
d1464 4
@


1.215
log
@remove support for authorized_keys2; it is a relic from the early days
of protocol v.2 support and has been undocumented for many years;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.214 2011/03/29 18:54:17 stevesk Exp $ */
d1459 5
a1467 4
	M_CP_STROPT(trusted_user_ca_keys);
	M_CP_STROPT(revoked_keys_file);
	M_CP_STROPT(authorized_keys_file);
	M_CP_STROPT(authorized_principals_file);
@


1.214
log
@print ipqos friendly string for sshd -T; ok markus

# sshd -Tf sshd_config|grep ipqos
ipqos lowdelay throughput
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.213 2010/11/13 23:27:50 djm Exp $ */
a122 1
	options->authorized_keys_file2 = NULL;
a251 7
	if (options->authorized_keys_file2 == NULL) {
		/* authorized_keys_file2 falls back to authorized_keys_file */
		if (options->authorized_keys_file != NULL)
			options->authorized_keys_file2 = xstrdup(options->authorized_keys_file);
		else
			options->authorized_keys_file2 = xstrdup(_PATH_SSH_USER_PERMITTED_KEYS2);
	}
a1201 3
	case sAuthorizedKeysFile2:
		charptr = &options->authorized_keys_file2;
		goto parse_tilde_filename;
a1465 1
	M_CP_STROPT(authorized_keys_file2);
a1677 1
	dump_cfg_string(sAuthorizedKeysFile2, o->authorized_keys_file2);
@


1.213
log
@allow ssh and sshd to set arbitrary TOS/DSCP/QoS values instead of
hardcoding lowdelay/throughput.

bz#1733 patch from philipp AT redfish-solutions.com; ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.212 2010/09/30 11:04:51 djm Exp $ */
d1728 2
a1729 1
	printf("ipqos 0x%02x 0x%02x\n", o->ip_qos_interactive, o->ip_qos_bulk);
@


1.212
log
@prevent free() of string in .rodata when overriding AuthorizedKeys in
a Match block; patch from rein AT basefarm.no
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.211 2010/09/22 05:01:29 djm Exp $ */
d17 4
d133 2
d266 4
d303 1
a303 1
	sKexAlgorithms,
d415 1
d645 1
a645 1
	int cmdline = 0, *intptr, value, n;
d1339 17
d1466 2
d1727 2
@


1.211
log
@add a KexAlgorithms knob to the client and server configuration to allow
selection of which key exchange methods are used by ssh(1) and sshd(8)
and their order of preference.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.210 2010/09/01 15:21:35 naddy Exp $ */
d250 1
a250 1
			options->authorized_keys_file2 = options->authorized_keys_file;
d252 1
a252 1
			options->authorized_keys_file2 = _PATH_SSH_USER_PERMITTED_KEYS2;
d255 1
a255 1
		options->authorized_keys_file = _PATH_SSH_USER_PERMITTED_KEYS;
@


1.210
log
@pick up ECDSA host key by default; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.209 2010/06/22 04:22:59 djm Exp $ */
d105 1
d293 1
d404 1
d1092 12
@


1.209
log
@expose some more sshd_config options inside Match blocks:
  AuthorizedKeysFile AuthorizedPrincipalsFile
  HostbasedUsesNameFromPacketOnly PermitTunnel
bz#1764; feedback from imorgan AT nas.nasa.gov; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.208 2010/05/07 11:30:29 djm Exp $ */
d145 2
@


1.208
log
@add some optional indirection to matching of principal names listed
in certificates. Currently, a certificate must include the a user's name
to be accepted for authentication. This change adds the ability to
specify a list of certificate principal names that are acceptable.

When authenticating using a CA trusted through ~/.ssh/authorized_keys,
this adds a new principals="name1[,name2,...]" key option.

For CAs listed through sshd_config's TrustedCAKeys option, a new config
option "AuthorizedPrincipalsFile" specifies a per-user file containing
the list of acceptable names.

If either option is absent, the current behaviour of requiring the
username to appear in principals continues to apply.

These options are useful for role accounts, disjoint account namespaces
and "user@@realm"-style naming policies in certificates.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.207 2010/03/25 23:38:28 djm Exp $ */
d316 1
a316 1
	{ "hostbasedusesnamefrompacketonly", sHostbasedUsesNameFromPacketOnly, SSHCFG_GLOBAL },
d387 2
a388 2
	{ "authorizedkeysfile", sAuthorizedKeysFile, SSHCFG_GLOBAL },
	{ "authorizedkeysfile2", sAuthorizedKeysFile2, SSHCFG_GLOBAL },
d391 1
a391 1
	{ "permittunnel", sPermitTunnel, SSHCFG_GLOBAL },
d399 1
a399 1
	{ "authorizedprincipalsfile", sAuthorizedPrincipalsFile, SSHCFG_GLOBAL },
d1406 1
d1414 1
d1429 3
@


1.207
log
@from portable: getcwd(NULL, 0) doesn't work on all platforms, so
use a stack buffer; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.206 2010/03/12 11:37:40 markus Exp $ */
d127 1
d289 1
a289 1
	sRevokedKeys, sTrustedUserCAKeys,
d399 1
d1180 2
d1183 5
a1187 3
		charptr = (opcode == sAuthorizedKeysFile) ?
		    &options->authorized_keys_file :
		    &options->authorized_keys_file2;
d1643 2
@


1.206
log
@do not prepend AuthorizedKeysFile with getcwd(), unbreaks relative paths
free() (not xfree()) the buffer returned by getcwd()
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.205 2010/03/12 01:06:25 djm Exp $ */
d436 1
a436 1
	char *expanded, *ret, *cwd;
d441 1
a441 1
	if ((cwd = getcwd(NULL, 0)) == NULL)
a443 1
	free(cwd);
@


1.205
log
@unbreak AuthorizedKeys option with a $HOME-relative path; reported by
vinschen AT redhat.com, ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.204 2010/03/04 10:36:03 djm Exp $ */
d444 1
a444 1
	xfree(cwd);
d1188 1
a1188 1
			*charptr = derelativise_path(arg);
@


1.204
log
@Add a TrustedUserCAKeys option to sshd_config to specify CA keys that
are trusted to authenticate users (in addition than doing it per-user
in authorized_keys).

Add a RevokedKeys option to sshd_config and a @@revoked marker to
known_hosts to allow keys to me revoked and banned for user or host
authentication.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.203 2010/02/26 20:29:54 djm Exp $ */
d1183 11
a1193 1
		goto parse_filename;
@


1.203
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.202 2010/01/13 03:48:12 djm Exp $ */
d125 2
d288 1
d396 2
d1288 8
d1410 2
d1626 2
@


1.202
log
@avoid run-time failures when specifying hostkeys via a relative
path by prepending the cwd in these cases; bz#1290; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.201 2010/01/10 03:51:17 dtucker Exp $ */
d61 1
d144 1
d285 1
a285 1
	sZeroKnowledgePasswordAuthentication,
d392 1
d779 10
d1619 2
@


1.201
log
@Add ChrootDirectory to sshd.c test-mode output
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.200 2010/01/09 23:04:13 dtucker Exp $ */
d425 16
d769 1
a769 1
			*charptr = tilde_expand_filename(arg, getuid());
@


1.200
log
@Remove RoutingDomain from ssh since it's now not needed.  It can be replaced
with "route exec" or "nc -V" as a proxycommand.  "route exec" also ensures
that trafic such as DNS lookups stays withing the specified routingdomain.

For example (from reyk):
# route -T 2 exec /usr/sbin/sshd
or inherited from the parent process
$ route -T 2 exec sh
$ ssh 10.1.2.3

ok deraadt@@ markus@@ stevesk@@ reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.196 2009/10/08 14:03:41 markus Exp $ */
d1581 1
@


1.199
log
@Rename RDomain config option to RoutingDomain to be more clear and
consistent with other options.

NOTE: if you currently use RDomain in the ssh client or server config,
or ssh/sshd -o, you must update to use RoutingDomain.

ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.198 2009/12/25 19:40:21 stevesk Exp $ */
a123 1
	options->rdomain = -1;
d282 1
a282 1
	sUsePrivilegeSeparation, sAllowAgentForwarding, sRDomain,
a388 1
	{ "routingdomain", sRDomain, SSHCFG_GLOBAL },
a1253 13
	case sRDomain:
		intptr = &options->rdomain;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing rdomain value.",
			    filename, linenum);
		if ((value = a2rdomain(arg)) == -1)
			fatal("%s line %d: invalid rdomain value.",
			    filename, linenum);
		if (*intptr == -1)
			*intptr = value;
		break;

a1526 1
	dump_cfg_int(sRDomain, o->rdomain);
@


1.198
log
@validate routing domain is in range 0-RT_TABLEID_MAX.
'Looks right' deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.197 2009/10/28 16:38:18 reyk Exp $ */
d390 1
a390 1
	{ "rdomain", sRDomain, SSHCFG_GLOBAL },
@


1.197
log
@Allow to set the rdomain in ssh/sftp/scp/sshd and ssh-keyscan.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.196 2009/10/08 14:03:41 markus Exp $ */
d1258 10
a1267 1
		goto parse_int;
@


1.196
log
@disable protocol 1 by default (after a transition period of about 10 years)
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.195 2009/04/14 21:10:54 jj Exp $ */
d124 1
d283 1
a283 1
	sUsePrivilegeSeparation, sAllowAgentForwarding,
d390 1
d1256 4
d1533 1
@


1.195
log
@Fixed a few the-the misspellings in comments. Skipped a bunch in binutils,gcc and so on. ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.194 2009/01/22 10:02:34 djm Exp $ */
d130 1
a130 1
		options->protocol = SSH_PROTO_1|SSH_PROTO_2;
@


1.194
log
@make a2port() return -1 when it encounters an invalid port number
rather than 0, which it will now treat as valid (needed for future work)

adjust current consumers of a2port() to check its return value is <= 0,
which in turn required some things to be converted from u_short => int

make use of int vs. u_short consistent in some other places too

feedback & ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.193 2008/12/09 03:20:42 stevesk Exp $ */
d1336 1
a1336 1
 * If the preauth flag is set, we do not bother copying the the string or
@


1.193
log
@channel_print_adm_permitted_opens() should deal with all the printing
for that config option.  suggested by markus@@; ok markus@@ djm@@
dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.192 2008/11/11 02:58:09 stevesk Exp $ */
d43 2
a44 2
static void add_listen_addr(ServerOptions *, char *, u_short);
static void add_one_listen_addr(ServerOptions *, char *, u_short);
d426 1
a426 1
add_listen_addr(ServerOptions *options, char *addr, u_short port)
d442 1
a442 1
add_one_listen_addr(ServerOptions *options, char *addr, u_short port)
d452 1
a452 1
	snprintf(strport, sizeof strport, "%u", port);
d608 1
a608 1
	u_short port;
d659 1
a659 1
		if (options->ports[options->num_ports-1] == 0)
d712 1
a712 1
		else if ((port = a2port(arg)) == 0)
d1225 1
a1225 1
			if (arg == NULL || (port = a2port(arg)) == 0)
@


1.192
log
@USE_AFS not referenced so remove #ifdef.  fixes sshd -T not printing
kerberosgetafstoken. ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.191 2008/11/05 11:22:54 jmc Exp $ */
a1609 1
	printf("permitopen");
a1610 1
	printf("\n");
@


1.191
log
@passord -> password;
fixes user/5975 from Rene Maroufi
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.190 2008/11/04 08:22:13 djm Exp $ */
a1541 1
# ifdef USE_AFS
a1542 1
# endif
@


1.190
log
@Add support for an experimental zero-knowledge password authentication
method using the J-PAKE protocol described in F. Hao, P. Ryan,
"Password Authenticated Key Exchange by Juggling", 16th Workshop on
Security Protocols, Cambridge, April 2008.

This method allows password-based authentication without exposing
the password to the server. Instead, the client and server exchange
cryptographic proofs to demonstrate of knowledge of the password while
revealing nothing useful to an attacker or compromised endpoint.

This is experimental, work-in-progress code and is presently
compiled-time disabled (turn on -DJPAKE in Makefile.inc).

"just commit it.  It isn't too intrusive." deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.189 2008/11/03 08:59:41 djm Exp $ */
d1414 1
a1414 1
			return "without-passord";
@


1.189
log
@include MaxSessions in sshd -T output; patch from imorgan AT nas.nasa.gov
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.188 2008/10/09 03:50:54 djm Exp $ */
d123 1
d250 2
d283 1
d338 5
d859 4
d1350 1
d1549 4
@


1.188
log
@support setting PermitEmptyPasswords in a Match block
requested in PR3891; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.187 2008/07/23 07:36:55 djm Exp $ */
d1510 1
@


1.187
log
@do not try to print options that have been compile-time disabled
in config test mode (sshd -T); report from nix-corp AT esperi.org.uk
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.186 2008/07/04 03:44:59 djm Exp $ */
d346 1
a346 1
	{ "permitemptypasswords", sEmptyPasswd, SSHCFG_GLOBAL },
d1338 1
@


1.186
log
@support negation of groups in "Match group" block (bz#1315); ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.185 2008/07/02 02:24:18 djm Exp $ */
d1522 1
d1526 1
d1528 3
d1533 1
@


1.185
log
@increase default size of ssh protocol 1 ephemeral key from 768 to 1024
bits; prodded by & ok dtucker@@ ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.184 2008/06/15 16:58:40 dtucker Exp $ */
a490 2
	u_int ngrps = 0;
	char *arg, *p, *cp, *grplist[MAX_MATCH_GROUPS];
a492 14
	/*
	 * Even if we do not have a user yet, we still need to check for
	 * valid syntax.
	 */
	arg = cp = xstrdup(grps);
	while ((p = strsep(&cp, ",")) != NULL && *p != '\0') {
		if (ngrps >= MAX_MATCH_GROUPS) {
			error("line %d: too many groups in Match Group", line);
			result = -1;
			goto out;
		}
		grplist[ngrps++] = p;
	}

d502 3
a504 3
	} else if (ga_match(grplist, ngrps) != 1) {
		debug("user %.100s does not match group %.100s at line %d",
		    user, arg, line);
d506 2
a507 2
		debug("user %.100s matched group %.100s at line %d", user,
		    arg, line);
a511 1
	xfree(arg);
@


1.184
log
@Allow MaxAuthTries within a Match block.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.183 2008/06/10 23:06:19 djm Exp $ */
d149 1
a149 1
		options->server_key_bits = 768;
@


1.183
log
@support CIDR address matching in .ssh/authorized_keys from="..." stanzas

ok and extensive testing dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.182 2008/06/10 04:50:25 dtucker Exp $ */
d364 1
a364 1
	{ "maxauthtries", sMaxAuthTries, SSHCFG_GLOBAL },
d1363 1
@


1.182
log
@Add extended test mode (-T) and connection parameters for test mode (-C).
-T causes sshd to write its effective configuration to stdout and exit.
-C causes any relevant Match rules to be applied before output.  The
combination allows tesing of the parser and config files.  ok deraadt djm
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.181 2008/06/10 03:57:27 djm Exp $ */
d587 1
d590 1
a590 1
			case -1:
@


1.181
log
@support CIDR address matching in sshd_config "Match address" blocks, with
full support for negation and fall-back to classic wildcard matching.
For example:

Match address 192.0.2.0/24,3ffe:ffff::/32,!10.*
    PasswordAuthentication yes

addrmatch.c code mostly lifted from flowd's addr.c

feedback and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.180 2008/05/08 12:21:16 djm Exp $ */
d25 1
d384 11
d1183 7
a1189 10
		value = 0;	/* silence compiler */
		if (strcasecmp(arg, "ethernet") == 0)
			value = SSH_TUNMODE_ETHERNET;
		else if (strcasecmp(arg, "point-to-point") == 0)
			value = SSH_TUNMODE_POINTOPOINT;
		else if (strcasecmp(arg, "yes") == 0)
			value = SSH_TUNMODE_YES;
		else if (strcasecmp(arg, "no") == 0)
			value = SSH_TUNMODE_NO;
		else
d1394 210
@


1.180
log
@Make the maximum number of sessions run-time controllable via
a sshd_config MaxSessions knob. This is useful for disabling
login/shell/subsystem access while leaving port-forwarding working
(MaxSessions 0), disabling connection multiplexing (MaxSessions 1) or
simply increasing the number of allows multiplexed sessions.

Because some bozos are sure to configure MaxSessions in excess of the
number of available file descriptors in sshd (which, at peak, might be
as many as 9*MaxSessions), audit sshd to ensure that it doesn't leak fds
on error paths, and make it fail gracefully on out-of-fd conditions -
sending channel errors instead of than exiting with fatal().

bz#1090; MaxSessions config bits and manpage from junyer AT gmail.com

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.179 2008/05/08 12:02:23 djm Exp $ */
d569 6
a574 1
			if (!address) {
d576 3
a578 1
				continue;
a579 5
			if (match_hostname(address, arg, len) != 1)
				result = 0;
			else
				debug("connection from %.100s matched 'Address "
				    "%.100s' at line %d", address, arg, line);
@


1.179
log
@Implement a channel success/failure status confirmation callback
mechanism. Each channel maintains a queue of callbacks, which will
be drained in order (RFC4253 guarantees confirm messages are not
reordered within an channel).

Also includes a abandonment callback to clean up if a channel is
closed without sending confirmation messages. This probably
shouldn't happen in compliant implementations, but it could be
abused to leak memory.

ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.178 2008/05/07 05:49:37 pyr Exp $ */
d110 1
d229 2
d272 1
a272 1
	sMaxStartups, sMaxAuthTries,
d364 1
d659 1
a659 1
parse_int:
d671 1
a671 1
parse_time:
d740 1
a740 1
parse_filename:
d783 1
a783 1
parse_flag:
d1119 4
d1350 1
@


1.178
log
@Enable the AllowAgentForwarding option in sshd_config (global and match
context), to specify if agents should be permitted on the server.
As the man page states:

``Note that disabling Agent forwarding does not improve security
unless users are also denied shell access, as they can always install
their own forwarders.''

ok djm@@, ok and a mild frown markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.177 2008/02/10 10:54:28 djm Exp $ */
d15 1
@


1.177
log
@delay ~ expansion for ChrootDirectory so it expands to the logged-in user's
home, rather than the user who starts sshd (probably root)
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.176 2008/02/08 23:24:08 djm Exp $ */
d95 1
d215 2
d274 1
a274 1
	sUsePrivilegeSeparation,
d348 1
d969 4
d1336 1
@


1.176
log
@add sshd_config ChrootDirectory option to chroot(2) users to a directory and
tweak internal sftp server to work with it (no special files in chroot
required). ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.175 2008/01/01 09:27:33 dtucker Exp $ */
d1220 8
a1227 1
		goto parse_filename;
@


1.175
log
@Allow PermitRootLogin in a Match block.  Allows for, eg, permitting root
only from the local network.  ok markus@@, man page bit ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.174 2007/12/31 10:41:31 dtucker Exp $ */
d118 1
d270 1
a270 1
	sMatch, sPermitOpen, sForceCommand,
d370 1
d1109 1
d1218 4
d1330 1
@


1.174
log
@Prevent strict-aliasing warnings on newer gcc versions.  bz #1355, patch
from Dmitry V. Levin, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.173 2007/12/27 14:22:08 dtucker Exp $ */
d291 1
a291 1
	{ "permitrootlogin", sPermitRootLogin, SSHCFG_GLOBAL },
d766 1
a766 1
		if (*intptr == -1)
d1311 1
@


1.173
log
@Add a small helper function to consistently handle the EAI_SYSTEM error
code of getaddrinfo.  Prompted by vgiffin at apple com via bz #1417.
ok markus@@ stevesk@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.172 2007/04/23 10:15:39 dtucker Exp $ */
d587 2
d938 1
a938 1
		intptr = (int *) &options->log_facility;
d944 2
a945 2
		if (*intptr == -1)
			*intptr = (SyslogFacility) value;
d949 1
a949 1
		intptr = (int *) &options->log_level;
d955 2
a956 2
		if (*intptr == -1)
			*intptr = (LogLevel) value;
@


1.172
log
@Remove debug() left over from development.  ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.171 2007/03/09 05:20:06 dtucker Exp $ */
d424 1
a424 1
		    gai_strerror(gaierr));
@


1.171
log
@Move C/R -> kbdint special case to after the defaults have been
loaded, which makes ChallengeResponse default to yes again.  This
was broken by the Match changes and not fixed properly subsequently.
Found by okan at demirmen.com, ok djm@@ "please do it" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.170 2007/03/01 10:28:02 dtucker Exp $ */
a557 1
			debug("address '%s' arg '%s'", address, arg);
@


1.170
log
@Remove ChallengeResponseAuthentication support inside a Match
block as its interaction with KbdInteractive makes it difficult to
support.  Also, relocate the CR/kbdint option special-case code into
servconf.  "please commit" djm@@, ok markus@@ for the relocation.
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.169 2007/02/22 12:58:40 dtucker Exp $ */
a1346 4

	/* challenge-response is implemented via keyboard interactive */
	if (options->challenge_response_authentication == 1)
		options->kbd_interactive_authentication = 1;
@


1.169
log
@Check activep so Match and GatewayPorts work together; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.168 2007/02/19 10:45:58 dtucker Exp $ */
d323 1
a323 1
	{ "challengeresponseauthentication", sChallengeResponseAuthentication, SSHCFG_ALL },
a1309 1
	M_CP_INTOPT(challenge_response_authentication);
d1347 4
@


1.168
log
@Teach Match how handle config directives that are used before authentication.
This allows configurations such as permitting password authentication from
the local net only while requiring pubkey from offsite.  ok djm@@, man page
bits ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.167 2006/12/14 10:01:14 dtucker Exp $ */
d928 1
a928 1
		if (*intptr == -1)
@


1.167
log
@Make "PermitOpen all" first-match within a block to match the way other
options work.  ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.166 2006/12/13 08:34:39 dtucker Exp $ */
d295 2
a296 2
	{ "rhostsrsaauthentication", sRhostsRSAAuthentication, SSHCFG_GLOBAL },
	{ "hostbasedauthentication", sHostbasedAuthentication, SSHCFG_GLOBAL },
d298 2
a299 2
	{ "rsaauthentication", sRSAAuthentication, SSHCFG_GLOBAL },
	{ "pubkeyauthentication", sPubkeyAuthentication, SSHCFG_GLOBAL },
d302 1
a302 1
	{ "kerberosauthentication", sKerberosAuthentication, SSHCFG_GLOBAL },
d307 1
a307 1
	{ "kerberosauthentication", sUnsupported, SSHCFG_GLOBAL },
d315 1
a315 1
	{ "gssapiauthentication", sGssAuthentication, SSHCFG_GLOBAL },
d318 1
a318 1
	{ "gssapiauthentication", sUnsupported, SSHCFG_GLOBAL },
d321 3
a323 3
	{ "passwordauthentication", sPasswordAuthentication, SSHCFG_GLOBAL },
	{ "kbdinteractiveauthentication", sKbdInteractiveAuthentication, SSHCFG_GLOBAL },
	{ "challengeresponseauthentication", sChallengeResponseAuthentication, SSHCFG_GLOBAL },
d355 1
a355 1
	{ "banner", sBanner, SSHCFG_GLOBAL },
d1277 1
a1277 1
	copy_set_server_options(options, &mo);
d1280 20
a1299 1
/* Copy any (supported) values that are set */
d1301 1
a1301 1
copy_set_server_options(ServerOptions *dst, ServerOptions *src)
d1303 19
a1321 15
	if (src->allow_tcp_forwarding != -1)
		dst->allow_tcp_forwarding = src->allow_tcp_forwarding;
	if (src->gateway_ports != -1)
		dst->gateway_ports = src->gateway_ports;
	if (src->adm_forced_command != NULL) {
		if (dst->adm_forced_command != NULL)
			xfree(dst->adm_forced_command);
		dst->adm_forced_command = src->adm_forced_command;
	}
	if (src->x11_display_offset != -1)
		dst->x11_display_offset = src->x11_display_offset;
	if (src->x11_forwarding != -1)
		dst->x11_forwarding = src->x11_forwarding;
	if (src->x11_use_localhost != -1)
		dst->x11_use_localhost = src->x11_use_localhost;
d1323 3
@


1.166
log
@Make PermitOpen work with multiple values like the man pages says.  bz #1267
with details from peter at dmtz.com, with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.165 2006/08/14 12:40:25 dtucker Exp $ */
d1180 1
d1182 1
a1182 1
			if (*activep) {
a1187 1
		n = options->num_permitted_opens;	/* modified later */
@


1.165
log
@Add ability to match groups to Match keyword in sshd_config.  Feedback djm@@,
stevesk@@, ok stevesk@@.
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.164 2006/08/03 03:34:42 deraadt Exp $ */
d1187 3
d1199 1
a1199 2
			if (*activep && options->num_permitted_opens == -1) {
				channel_clear_adm_permitted_opens();
a1201 1
			}
@


1.164
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.163 2006/08/01 23:36:12 stevesk Exp $ */
d17 1
d39 1
d465 45
d540 7
@


1.163
log
@clean extra spaces
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.162 2006/08/01 23:22:47 stevesk Exp $ */
a12 2
#include "includes.h"

d20 1
d22 1
d24 1
d27 1
a28 1
#include "xmalloc.h"
d33 1
@


1.162
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.161 2006/07/26 13:57:17 stevesk Exp $ */
d923 1
a923 1
				fatal( "%s line %d: too many deny users.",
d1058 1
a1058 1
		charptr = (opcode == sAuthorizedKeysFile ) ?
@


1.161
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.160 2006/07/22 20:48:23 stevesk Exp $ */
d19 1
@


1.160
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.159 2006/07/21 12:43:36 dtucker Exp $ */
d19 1
@


1.159
log
@Make PermitOpen take a list of permitted ports and act more like most other
keywords (ie the first match is the effective setting).  This also makes it
easier to override a previously set PermitOpen.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.158 2006/07/19 13:07:10 dtucker Exp $ */
d19 1
@


1.158
log
@Add ForceCommand keyword to sshd_config, equivalent to the "command="
key option, man page entry and example in sshd_config.  Feedback & ok djm@@,
man page corrections & ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.157 2006/07/19 08:56:41 dtucker Exp $ */
d109 1
d1122 1
a1122 1
			if (*activep)
d1124 2
d1128 15
a1142 10
		p = hpdelim(&arg);
		if (p == NULL)
			fatal("%s line %d: missing host in PermitOpen",
			    filename, linenum);
		p = cleanhostname(p);
		if (arg == NULL || (port = a2port(arg)) == 0)
			fatal("%s line %d: bad port number in PermitOpen",
			    filename, linenum);
		if (*activep)
			channel_add_adm_permitted_opens(p, port);
@


1.157
log
@Add support for X11Forwaring, X11DisplayOffset and X11UseLocalhost to
Match.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.156 2006/07/17 12:06:00 dtucker Exp $ */
d109 1
d261 1
a261 1
	sMatch, sPermitOpen,
d360 1
d519 2
d1137 9
d1220 5
@


1.156
log
@Add PermitOpen directive to sshd_config which is equivalent to the
"permitopen" key option.  Allows server admin to allow TCP port forwarding
only two specific host/port pairs.  Useful when combined with Match.

If permitopen is used in both sshd_config and a key option, both must allow
a given connection before it will be permitted.

Note that users can still use external forwarders such as netcat, so to be
those must be controlled too for the limits to be effective.

Feedback & ok djm@@, man page corrections & ok jmc@@.
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.155 2006/07/17 01:31:09 stevesk Exp $ */
d323 3
a325 3
	{ "x11forwarding", sX11Forwarding, SSHCFG_GLOBAL },
	{ "x11displayoffset", sX11DisplayOffset, SSHCFG_GLOBAL },
	{ "x11uselocalhost", sX11UseLocalhost, SSHCFG_GLOBAL },
d1207 6
@


1.155
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.154 2006/07/12 22:28:52 stevesk Exp $ */
d32 1
d260 1
a260 1
	sMatch,
d358 1
d1109 22
@


1.154
log
@move #include <netdb.h> out of includes.h; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.153 2006/07/12 11:34:58 dtucker Exp $ */
d19 1
@


1.153
log
@Add support for conditional directives to sshd_config via a "Match" keyword,
which works similarly to the "Host" directive in ssh_config.

Lines after a Match line override the default set in the main section
if the condition on the Match line is true, eg

AllowTcpForwarding yes
Match User anoncvs
        AllowTcpForwarding no

will allow port forwarding by all users except "anoncvs".

Currently only a very small subset of directives are supported.

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.152 2006/07/08 21:47:12 stevesk Exp $ */
d17 2
@


1.152
log
@move #include <sys/socket.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.151 2006/07/06 10:47:05 djm Exp $ */
d28 1
d35 1
a104 3

	/* Needs to be accessable in many places */
	use_privsep = -1;
d256 1
d261 4
d269 1
d271 17
a287 17
	{ "port", sPort },
	{ "hostkey", sHostKeyFile },
	{ "hostdsakey", sHostKeyFile },					/* alias */
	{ "pidfile", sPidFile },
	{ "serverkeybits", sServerKeyBits },
	{ "logingracetime", sLoginGraceTime },
	{ "keyregenerationinterval", sKeyRegenerationTime },
	{ "permitrootlogin", sPermitRootLogin },
	{ "syslogfacility", sLogFacility },
	{ "loglevel", sLogLevel },
	{ "rhostsauthentication", sDeprecated },
	{ "rhostsrsaauthentication", sRhostsRSAAuthentication },
	{ "hostbasedauthentication", sHostbasedAuthentication },
	{ "hostbasedusesnamefrompacketonly", sHostbasedUsesNameFromPacketOnly },
	{ "rsaauthentication", sRSAAuthentication },
	{ "pubkeyauthentication", sPubkeyAuthentication },
	{ "dsaauthentication", sPubkeyAuthentication },			/* alias */
d289 4
a292 4
	{ "kerberosauthentication", sKerberosAuthentication },
	{ "kerberosorlocalpasswd", sKerberosOrLocalPasswd },
	{ "kerberosticketcleanup", sKerberosTicketCleanup },
	{ "kerberosgetafstoken", sKerberosGetAFSToken },
d294 4
a297 4
	{ "kerberosauthentication", sUnsupported },
	{ "kerberosorlocalpasswd", sUnsupported },
	{ "kerberosticketcleanup", sUnsupported },
	{ "kerberosgetafstoken", sUnsupported },
d299 2
a300 2
	{ "kerberostgtpassing", sUnsupported },
	{ "afstokenpassing", sUnsupported },
d302 2
a303 2
	{ "gssapiauthentication", sGssAuthentication },
	{ "gssapicleanupcredentials", sGssCleanupCreds },
d305 2
a306 2
	{ "gssapiauthentication", sUnsupported },
	{ "gssapicleanupcredentials", sUnsupported },
d308 47
a354 46
	{ "passwordauthentication", sPasswordAuthentication },
	{ "kbdinteractiveauthentication", sKbdInteractiveAuthentication },
	{ "challengeresponseauthentication", sChallengeResponseAuthentication },
	{ "skeyauthentication", sChallengeResponseAuthentication }, /* alias */
	{ "checkmail", sDeprecated },
	{ "listenaddress", sListenAddress },
	{ "addressfamily", sAddressFamily },
	{ "printmotd", sPrintMotd },
	{ "printlastlog", sPrintLastLog },
	{ "ignorerhosts", sIgnoreRhosts },
	{ "ignoreuserknownhosts", sIgnoreUserKnownHosts },
	{ "x11forwarding", sX11Forwarding },
	{ "x11displayoffset", sX11DisplayOffset },
	{ "x11uselocalhost", sX11UseLocalhost },
	{ "xauthlocation", sXAuthLocation },
	{ "strictmodes", sStrictModes },
	{ "permitemptypasswords", sEmptyPasswd },
	{ "permituserenvironment", sPermitUserEnvironment },
	{ "uselogin", sUseLogin },
	{ "compression", sCompression },
	{ "tcpkeepalive", sTCPKeepAlive },
	{ "keepalive", sTCPKeepAlive },				/* obsolete alias */
	{ "allowtcpforwarding", sAllowTcpForwarding },
	{ "allowusers", sAllowUsers },
	{ "denyusers", sDenyUsers },
	{ "allowgroups", sAllowGroups },
	{ "denygroups", sDenyGroups },
	{ "ciphers", sCiphers },
	{ "macs", sMacs },
	{ "protocol", sProtocol },
	{ "gatewayports", sGatewayPorts },
	{ "subsystem", sSubsystem },
	{ "maxstartups", sMaxStartups },
	{ "maxauthtries", sMaxAuthTries },
	{ "banner", sBanner },
	{ "usedns", sUseDNS },
	{ "verifyreversemapping", sDeprecated },
	{ "reversemappingcheck", sDeprecated },
	{ "clientaliveinterval", sClientAliveInterval },
	{ "clientalivecountmax", sClientAliveCountMax },
	{ "authorizedkeysfile", sAuthorizedKeysFile },
	{ "authorizedkeysfile2", sAuthorizedKeysFile2 },
	{ "useprivilegeseparation", sUsePrivilegeSeparation},
	{ "acceptenv", sAcceptEnv },
	{ "permittunnel", sPermitTunnel },
	{ NULL, sBadOption }
d363 1
a363 1
	    int linenum)
d368 2
a369 1
		if (strcasecmp(cp, keywords[i].name) == 0)
d371 1
d416 96
d514 2
a515 1
    const char *filename, int linenum)
d518 1
a518 1
	int *intptr, value, n;
d521 1
a521 1
	u_int i;
d534 19
a552 1
	opcode = parse_token(arg, filename, linenum);
d584 1
a584 1
		if (*intptr == -1)
d664 1
a664 1
		if (*charptr == NULL) {
d715 1
a715 1
		if (*intptr == -1)
d980 4
d1066 2
d1095 11
d1162 23
a1184 1
parse_server_config(ServerOptions *options, const char *filename, Buffer *conf)
d1186 1
a1186 1
	int linenum, bad_options = 0;
d1192 1
d1196 1
a1196 1
		    linenum++) != 0)
@


1.151
log
@support arguments to Subsystem commands; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.150 2006/03/25 13:17:02 djm Exp $ */
d14 3
@


1.150
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d414 1
d864 11
@


1.149
log
@RCSID() can die
@
text
@d1 1
@


1.148
log
@Correct strdelim null test; ok djm@@
@
text
@a12 1
RCSID("$OpenBSD: servconf.c,v 1.147 2006/03/19 02:24:05 djm Exp $");
@


1.147
log
@potential NULL pointer dereferences detected by Coverity
via elad AT netbsd.org; ok deraadt@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.146 2005/12/08 18:34:11 reyk Exp $");
d416 1
a416 1
	if ((arg = strdelim(&cp)) != NULL)
@


1.146
log
@two changes to the new ssh tunnel support. this breaks compatibility
with the initial commit but is required for a portable approach.
- make the tunnel id u_int and platform friendly, use predefined types.
- support configuration of layer 2 (ethernet) or layer 3
(point-to-point, default) modes. configuration is done using the
Tunnel (yes|point-to-point|ethernet|no) option is ssh_config(5) and
restricted by the PermitTunnel (yes|point-to-point|ethernet|no) option
in sshd_config(5).

ok djm@@, man page bits by jmc@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.145 2005/12/06 22:38:27 reyk Exp $");
d416 2
a417 1
	arg = strdelim(&cp);
@


1.146.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: servconf.c,v 1.165 2006/08/14 12:40:25 dtucker Exp $ */
d12 2
a13 2
#include <sys/types.h>
#include <sys/socket.h>
a14 10
#include <netdb.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <stdarg.h>

#include "xmalloc.h"
a16 1
#include "buffer.h"
d18 1
a22 1
#include "key.h"
a24 3
#include "match.h"
#include "channels.h"
#include "groupaccess.h"
a30 1
extern Buffer cfg;
d100 3
a102 2
	options->num_permitted_opens = -1;
	options->adm_forced_command = NULL;
a253 1
	sMatch, sPermitOpen, sForceCommand,
a257 4
#define SSHCFG_GLOBAL	0x01	/* allowed in main section of sshd_config */
#define SSHCFG_MATCH	0x02	/* allowed inside a Match section */
#define SSHCFG_ALL	(SSHCFG_GLOBAL|SSHCFG_MATCH)

a261 1
	u_int flags;
d263 17
a279 17
	{ "port", sPort, SSHCFG_GLOBAL },
	{ "hostkey", sHostKeyFile, SSHCFG_GLOBAL },
	{ "hostdsakey", sHostKeyFile, SSHCFG_GLOBAL },		/* alias */
	{ "pidfile", sPidFile, SSHCFG_GLOBAL },
	{ "serverkeybits", sServerKeyBits, SSHCFG_GLOBAL },
	{ "logingracetime", sLoginGraceTime, SSHCFG_GLOBAL },
	{ "keyregenerationinterval", sKeyRegenerationTime, SSHCFG_GLOBAL },
	{ "permitrootlogin", sPermitRootLogin, SSHCFG_GLOBAL },
	{ "syslogfacility", sLogFacility, SSHCFG_GLOBAL },
	{ "loglevel", sLogLevel, SSHCFG_GLOBAL },
	{ "rhostsauthentication", sDeprecated, SSHCFG_GLOBAL },
	{ "rhostsrsaauthentication", sRhostsRSAAuthentication, SSHCFG_GLOBAL },
	{ "hostbasedauthentication", sHostbasedAuthentication, SSHCFG_GLOBAL },
	{ "hostbasedusesnamefrompacketonly", sHostbasedUsesNameFromPacketOnly, SSHCFG_GLOBAL },
	{ "rsaauthentication", sRSAAuthentication, SSHCFG_GLOBAL },
	{ "pubkeyauthentication", sPubkeyAuthentication, SSHCFG_GLOBAL },
	{ "dsaauthentication", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */
d281 4
a284 4
	{ "kerberosauthentication", sKerberosAuthentication, SSHCFG_GLOBAL },
	{ "kerberosorlocalpasswd", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },
	{ "kerberosticketcleanup", sKerberosTicketCleanup, SSHCFG_GLOBAL },
	{ "kerberosgetafstoken", sKerberosGetAFSToken, SSHCFG_GLOBAL },
d286 4
a289 4
	{ "kerberosauthentication", sUnsupported, SSHCFG_GLOBAL },
	{ "kerberosorlocalpasswd", sUnsupported, SSHCFG_GLOBAL },
	{ "kerberosticketcleanup", sUnsupported, SSHCFG_GLOBAL },
	{ "kerberosgetafstoken", sUnsupported, SSHCFG_GLOBAL },
d291 2
a292 2
	{ "kerberostgtpassing", sUnsupported, SSHCFG_GLOBAL },
	{ "afstokenpassing", sUnsupported, SSHCFG_GLOBAL },
d294 2
a295 2
	{ "gssapiauthentication", sGssAuthentication, SSHCFG_GLOBAL },
	{ "gssapicleanupcredentials", sGssCleanupCreds, SSHCFG_GLOBAL },
d297 2
a298 2
	{ "gssapiauthentication", sUnsupported, SSHCFG_GLOBAL },
	{ "gssapicleanupcredentials", sUnsupported, SSHCFG_GLOBAL },
d300 46
a345 49
	{ "passwordauthentication", sPasswordAuthentication, SSHCFG_GLOBAL },
	{ "kbdinteractiveauthentication", sKbdInteractiveAuthentication, SSHCFG_GLOBAL },
	{ "challengeresponseauthentication", sChallengeResponseAuthentication, SSHCFG_GLOBAL },
	{ "skeyauthentication", sChallengeResponseAuthentication, SSHCFG_GLOBAL }, /* alias */
	{ "checkmail", sDeprecated, SSHCFG_GLOBAL },
	{ "listenaddress", sListenAddress, SSHCFG_GLOBAL },
	{ "addressfamily", sAddressFamily, SSHCFG_GLOBAL },
	{ "printmotd", sPrintMotd, SSHCFG_GLOBAL },
	{ "printlastlog", sPrintLastLog, SSHCFG_GLOBAL },
	{ "ignorerhosts", sIgnoreRhosts, SSHCFG_GLOBAL },
	{ "ignoreuserknownhosts", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },
	{ "x11forwarding", sX11Forwarding, SSHCFG_ALL },
	{ "x11displayoffset", sX11DisplayOffset, SSHCFG_ALL },
	{ "x11uselocalhost", sX11UseLocalhost, SSHCFG_ALL },
	{ "xauthlocation", sXAuthLocation, SSHCFG_GLOBAL },
	{ "strictmodes", sStrictModes, SSHCFG_GLOBAL },
	{ "permitemptypasswords", sEmptyPasswd, SSHCFG_GLOBAL },
	{ "permituserenvironment", sPermitUserEnvironment, SSHCFG_GLOBAL },
	{ "uselogin", sUseLogin, SSHCFG_GLOBAL },
	{ "compression", sCompression, SSHCFG_GLOBAL },
	{ "tcpkeepalive", sTCPKeepAlive, SSHCFG_GLOBAL },
	{ "keepalive", sTCPKeepAlive, SSHCFG_GLOBAL },	/* obsolete alias */
	{ "allowtcpforwarding", sAllowTcpForwarding, SSHCFG_ALL },
	{ "allowusers", sAllowUsers, SSHCFG_GLOBAL },
	{ "denyusers", sDenyUsers, SSHCFG_GLOBAL },
	{ "allowgroups", sAllowGroups, SSHCFG_GLOBAL },
	{ "denygroups", sDenyGroups, SSHCFG_GLOBAL },
	{ "ciphers", sCiphers, SSHCFG_GLOBAL },
	{ "macs", sMacs, SSHCFG_GLOBAL },
	{ "protocol", sProtocol, SSHCFG_GLOBAL },
	{ "gatewayports", sGatewayPorts, SSHCFG_ALL },
	{ "subsystem", sSubsystem, SSHCFG_GLOBAL },
	{ "maxstartups", sMaxStartups, SSHCFG_GLOBAL },
	{ "maxauthtries", sMaxAuthTries, SSHCFG_GLOBAL },
	{ "banner", sBanner, SSHCFG_GLOBAL },
	{ "usedns", sUseDNS, SSHCFG_GLOBAL },
	{ "verifyreversemapping", sDeprecated, SSHCFG_GLOBAL },
	{ "reversemappingcheck", sDeprecated, SSHCFG_GLOBAL },
	{ "clientaliveinterval", sClientAliveInterval, SSHCFG_GLOBAL },
	{ "clientalivecountmax", sClientAliveCountMax, SSHCFG_GLOBAL },
	{ "authorizedkeysfile", sAuthorizedKeysFile, SSHCFG_GLOBAL },
	{ "authorizedkeysfile2", sAuthorizedKeysFile2, SSHCFG_GLOBAL },
	{ "useprivilegeseparation", sUsePrivilegeSeparation, SSHCFG_GLOBAL},
	{ "acceptenv", sAcceptEnv, SSHCFG_GLOBAL },
	{ "permittunnel", sPermitTunnel, SSHCFG_GLOBAL },
	{ "match", sMatch, SSHCFG_ALL },
	{ "permitopen", sPermitOpen, SSHCFG_ALL },
	{ "forcecommand", sForceCommand, SSHCFG_ALL },
	{ NULL, sBadOption, 0 }
d354 1
a354 1
	    int linenum, u_int *flags)
d359 1
a359 2
		if (strcasecmp(cp, keywords[i].name) == 0) {
			*flags = keywords[i].flags;
a360 1
		}
a404 150
/*
 * The strategy for the Match blocks is that the config file is parsed twice.
 *
 * The first time is at startup.  activep is initialized to 1 and the
 * directives in the global context are processed and acted on.  Hitting a
 * Match directive unsets activep and the directives inside the block are
 * checked for syntax only.
 *
 * The second time is after a connection has been established but before
 * authentication.  activep is initialized to 2 and global config directives
 * are ignored since they have already been processed.  If the criteria in a
 * Match block is met, activep is set and the subsequent directives
 * processed and actioned until EOF or another Match block unsets it.  Any
 * options set are copied into the main server config.
 *
 * Potential additions/improvements:
 *  - Add Match support for pre-kex directives, eg Protocol, Ciphers.
 *
 *  - Add a Tag directive (idea from David Leonard) ala pf, eg:
 *	Match Address 192.168.0.*
 *		Tag trusted
 *	Match Group wheel
 *		Tag trusted
 *	Match Tag trusted
 *		AllowTcpForwarding yes
 *		GatewayPorts clientspecified
 *		[...]
 *
 *  - Add a PermittedChannelRequests directive
 *	Match Group shell
 *		PermittedChannelRequests session,forwarded-tcpip
 */

static int
match_cfg_line_group(const char *grps, int line, const char *user)
{
	int result = 0;
	u_int ngrps = 0;
	char *arg, *p, *cp, *grplist[MAX_MATCH_GROUPS];
	struct passwd *pw;

	/*
	 * Even if we do not have a user yet, we still need to check for
	 * valid syntax.
	 */
	arg = cp = xstrdup(grps);
	while ((p = strsep(&cp, ",")) != NULL && *p != '\0') {
		if (ngrps >= MAX_MATCH_GROUPS) {
			error("line %d: too many groups in Match Group", line);
			result = -1;
			goto out;
		}
		grplist[ngrps++] = p;
	}

	if (user == NULL)
		goto out;

	if ((pw = getpwnam(user)) == NULL) {
		debug("Can't match group at line %d because user %.100s does "
		    "not exist", line, user);
	} else if (ga_init(pw->pw_name, pw->pw_gid) == 0) {
		debug("Can't Match group because user %.100s not in any group "
		    "at line %d", user, line);
	} else if (ga_match(grplist, ngrps) != 1) {
		debug("user %.100s does not match group %.100s at line %d",
		    user, arg, line);
	} else {
		debug("user %.100s matched group %.100s at line %d", user,
		    arg, line);
		result = 1;
	}
out:
	ga_free();
	xfree(arg);
	return result;
}

static int
match_cfg_line(char **condition, int line, const char *user, const char *host,
    const char *address)
{
	int result = 1;
	char *arg, *attrib, *cp = *condition;
	size_t len;

	if (user == NULL)
		debug3("checking syntax for 'Match %s'", cp);
	else
		debug3("checking match for '%s' user %s host %s addr %s", cp,
		    user ? user : "(null)", host ? host : "(null)",
		    address ? address : "(null)");

	while ((attrib = strdelim(&cp)) && *attrib != '\0') {
		if ((arg = strdelim(&cp)) == NULL || *arg == '\0') {
			error("Missing Match criteria for %s", attrib);
			return -1;
		}
		len = strlen(arg);
		if (strcasecmp(attrib, "user") == 0) {
			if (!user) {
				result = 0;
				continue;
			}
			if (match_pattern_list(user, arg, len, 0) != 1)
				result = 0;
			else
				debug("user %.100s matched 'User %.100s' at "
				    "line %d", user, arg, line);
		} else if (strcasecmp(attrib, "group") == 0) {
			switch (match_cfg_line_group(arg, line, user)) {
			case -1:
				return -1;
			case 0:
				result = 0;
			}
		} else if (strcasecmp(attrib, "host") == 0) {
			if (!host) {
				result = 0;
				continue;
			}
			if (match_hostname(host, arg, len) != 1)
				result = 0;
			else
				debug("connection from %.100s matched 'Host "
				    "%.100s' at line %d", host, arg, line);
		} else if (strcasecmp(attrib, "address") == 0) {
			debug("address '%s' arg '%s'", address, arg);
			if (!address) {
				result = 0;
				continue;
			}
			if (match_hostname(address, arg, len) != 1)
				result = 0;
			else
				debug("connection from %.100s matched 'Address "
				    "%.100s' at line %d", address, arg, line);
		} else {
			error("Unsupported Match attribute %s", attrib);
			return -1;
		}
	}
	if (user != NULL)
		debug3("match %sfound", result ? "" : "not ");
	*condition = cp;
	return result;
}

#define WHITESPACE " \t\r\n"

d407 1
a407 2
    const char *filename, int linenum, int *activep, const char *user,
    const char *host, const char *address)
d410 1
a410 1
	int cmdline = 0, *intptr, value, n;
d413 1
a413 2
	u_int i, flags = 0;
	size_t len;
d416 1
a416 2
	if ((arg = strdelim(&cp)) == NULL)
		return 0;
d424 1
a424 19
	opcode = parse_token(arg, filename, linenum, &flags);

	if (activep == NULL) { /* We are processing a command line directive */
		cmdline = 1;
		activep = &cmdline;
	}
	if (*activep && opcode != sMatch)
		debug3("%s:%d setting %s %s", filename, linenum, arg, cp);
	if (*activep == 0 && !(flags & SSHCFG_MATCH)) {
		if (user == NULL) {
			fatal("%s line %d: Directive '%s' is not allowed "
			    "within a Match block", filename, linenum, arg);
		} else { /* this is a directive we have already processed */
			while (arg)
				arg = strdelim(&cp);
			return 0;
		}
	}

d456 1
a456 1
		if (*activep && *intptr == -1)
d536 1
a536 1
		if (*activep && *charptr == NULL) {
d587 1
a587 1
		if (*activep && *intptr == -1)
d782 1
a782 1
				fatal("%s line %d: too many deny users.",
a851 4
		if (!*activep) {
			arg = strdelim(&cp);
			break;
		}
a861 11

		/* Collect arguments (separate to executable) */
		p = xstrdup(arg);
		len = strlen(p) + 1;
		while ((arg = strdelim(&cp)) != NULL && *arg != '\0') {
			len += 1 + strlen(arg);
			p = xrealloc(p, 1, len);
			strlcat(p, " ", len);
			strlcat(p, arg, len);
		}
		options->subsystem_args[options->num_subsystems] = p;
d902 1
a902 1
		charptr = (opcode == sAuthorizedKeysFile) ?
a922 2
			if (!*activep)
				break;
a949 49
	case sMatch:
		if (cmdline)
			fatal("Match directive not supported as a command-line "
			   "option");
		value = match_cfg_line(&cp, linenum, user, host, address);
		if (value < 0)
			fatal("%s line %d: Bad Match condition", filename,
			    linenum);
		*activep = value;
		break;

	case sPermitOpen:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing PermitOpen specification",
			    filename, linenum);
		if (strcmp(arg, "any") == 0) {
			if (*activep) {
				channel_clear_adm_permitted_opens();
				options->num_permitted_opens = 0;
			}
			break;
		}
		for (; arg != NULL && *arg != '\0'; arg = strdelim(&cp)) {
			p = hpdelim(&arg);
			if (p == NULL)
				fatal("%s line %d: missing host in PermitOpen",
				    filename, linenum);
			p = cleanhostname(p);
			if (arg == NULL || (port = a2port(arg)) == 0)
				fatal("%s line %d: bad port number in "
				    "PermitOpen", filename, linenum);
			if (*activep && options->num_permitted_opens == -1) {
				channel_clear_adm_permitted_opens();
				options->num_permitted_opens =
				    channel_add_adm_permitted_opens(p, port);
			}
		}
		break;

	case sForceCommand:
		if (cp == NULL)
			fatal("%.200s line %d: Missing argument.", filename,
			    linenum);
		len = strspn(cp, WHITESPACE);
		if (*activep && options->adm_forced_command == NULL)
			options->adm_forced_command = xstrdup(cp + len);
		return 0;

d1006 1
a1006 34
parse_server_match_config(ServerOptions *options, const char *user,
    const char *host, const char *address)
{
	ServerOptions mo;

	initialize_server_options(&mo);
	parse_server_config(&mo, "reprocess config", &cfg, user, host, address);
	copy_set_server_options(options, &mo);
}

/* Copy any (supported) values that are set */
void
copy_set_server_options(ServerOptions *dst, ServerOptions *src)
{
	if (src->allow_tcp_forwarding != -1)
		dst->allow_tcp_forwarding = src->allow_tcp_forwarding;
	if (src->gateway_ports != -1)
		dst->gateway_ports = src->gateway_ports;
	if (src->adm_forced_command != NULL) {
		if (dst->adm_forced_command != NULL)
			xfree(dst->adm_forced_command);
		dst->adm_forced_command = src->adm_forced_command;
	}
	if (src->x11_display_offset != -1)
		dst->x11_display_offset = src->x11_display_offset;
	if (src->x11_forwarding != -1)
		dst->x11_forwarding = src->x11_forwarding;
	if (src->x11_use_localhost != -1)
		dst->x11_use_localhost = src->x11_use_localhost;
}

void
parse_server_config(ServerOptions *options, const char *filename, Buffer *conf,
    const char *user, const char *host, const char *address)
d1008 1
a1008 1
	int active, linenum, bad_options = 0;
a1013 1
	active = user ? 0 : 1;
d1017 1
a1017 1
		    linenum++, &active, user, host, address) != 0)
@


1.145
log
@Add support for tun(4) forwarding over OpenSSH, based on an idea and
initial channel code bits by markus@@. This is a simple and easy way to
use OpenSSH for ad hoc virtual private network connections, e.g.
administrative tunnels or secure wireless access. It's based on a new
ssh channel and works similar to the existing TCP forwarding support,
except that it depends on the tun(4) network interface on both ends of
the connection for layer 2 or layer 3 tunneling. This diff also adds
support for LocalCommand in the ssh(1) client.

ok djm@@, markus@@, jmc@@ (manpages), tested and discussed with others
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.144 2005/08/06 10:03:12 dtucker Exp $");
d224 1
a224 1
		options->permit_tun = 0;
d930 19
a948 1
		goto parse_flag;
@


1.144
log
@Unbreak sshd ListenAddress for bare IPv6 addresses.
Report from Janusz Mucka; ok djm@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.143 2005/07/25 11:59:40 markus Exp $");
d99 1
d223 2
d253 1
a253 1
	sGssAuthentication, sGssCleanupCreds, sAcceptEnv,
d344 1
d927 4
@


1.144.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.146 2005/12/08 18:34:11 reyk Exp $");
a98 1
	options->permit_tun = -1;
a221 2
	if (options->permit_tun == -1)
		options->permit_tun = SSH_TUNMODE_NO;
d250 1
a250 1
	sGssAuthentication, sGssCleanupCreds, sAcceptEnv, sPermitTunnel,
a340 1
	{ "permittunnel", sPermitTunnel },
a921 22
		break;

	case sPermitTunnel:
		intptr = &options->permit_tun;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing yes/point-to-point/"
			    "ethernet/no argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcasecmp(arg, "ethernet") == 0)
			value = SSH_TUNMODE_ETHERNET;
		else if (strcasecmp(arg, "point-to-point") == 0)
			value = SSH_TUNMODE_POINTOPOINT;
		else if (strcasecmp(arg, "yes") == 0)
			value = SSH_TUNMODE_YES;
		else if (strcasecmp(arg, "no") == 0)
			value = SSH_TUNMODE_NO;
		else
			fatal("%s line %d: Bad yes/point-to-point/ethernet/"
			    "no argument: %s", filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
@


1.144.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: servconf.c,v 1.165 2006/08/14 12:40:25 dtucker Exp $ */
d12 2
a13 2
#include <sys/types.h>
#include <sys/socket.h>
a14 10
#include <netdb.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <stdarg.h>

#include "xmalloc.h"
a16 1
#include "buffer.h"
d18 1
a22 1
#include "key.h"
a24 3
#include "match.h"
#include "channels.h"
#include "groupaccess.h"
a30 1
extern Buffer cfg;
d100 3
a102 2
	options->num_permitted_opens = -1;
	options->adm_forced_command = NULL;
a253 1
	sMatch, sPermitOpen, sForceCommand,
a257 4
#define SSHCFG_GLOBAL	0x01	/* allowed in main section of sshd_config */
#define SSHCFG_MATCH	0x02	/* allowed inside a Match section */
#define SSHCFG_ALL	(SSHCFG_GLOBAL|SSHCFG_MATCH)

a261 1
	u_int flags;
d263 17
a279 17
	{ "port", sPort, SSHCFG_GLOBAL },
	{ "hostkey", sHostKeyFile, SSHCFG_GLOBAL },
	{ "hostdsakey", sHostKeyFile, SSHCFG_GLOBAL },		/* alias */
	{ "pidfile", sPidFile, SSHCFG_GLOBAL },
	{ "serverkeybits", sServerKeyBits, SSHCFG_GLOBAL },
	{ "logingracetime", sLoginGraceTime, SSHCFG_GLOBAL },
	{ "keyregenerationinterval", sKeyRegenerationTime, SSHCFG_GLOBAL },
	{ "permitrootlogin", sPermitRootLogin, SSHCFG_GLOBAL },
	{ "syslogfacility", sLogFacility, SSHCFG_GLOBAL },
	{ "loglevel", sLogLevel, SSHCFG_GLOBAL },
	{ "rhostsauthentication", sDeprecated, SSHCFG_GLOBAL },
	{ "rhostsrsaauthentication", sRhostsRSAAuthentication, SSHCFG_GLOBAL },
	{ "hostbasedauthentication", sHostbasedAuthentication, SSHCFG_GLOBAL },
	{ "hostbasedusesnamefrompacketonly", sHostbasedUsesNameFromPacketOnly, SSHCFG_GLOBAL },
	{ "rsaauthentication", sRSAAuthentication, SSHCFG_GLOBAL },
	{ "pubkeyauthentication", sPubkeyAuthentication, SSHCFG_GLOBAL },
	{ "dsaauthentication", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */
d281 4
a284 4
	{ "kerberosauthentication", sKerberosAuthentication, SSHCFG_GLOBAL },
	{ "kerberosorlocalpasswd", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },
	{ "kerberosticketcleanup", sKerberosTicketCleanup, SSHCFG_GLOBAL },
	{ "kerberosgetafstoken", sKerberosGetAFSToken, SSHCFG_GLOBAL },
d286 4
a289 4
	{ "kerberosauthentication", sUnsupported, SSHCFG_GLOBAL },
	{ "kerberosorlocalpasswd", sUnsupported, SSHCFG_GLOBAL },
	{ "kerberosticketcleanup", sUnsupported, SSHCFG_GLOBAL },
	{ "kerberosgetafstoken", sUnsupported, SSHCFG_GLOBAL },
d291 2
a292 2
	{ "kerberostgtpassing", sUnsupported, SSHCFG_GLOBAL },
	{ "afstokenpassing", sUnsupported, SSHCFG_GLOBAL },
d294 2
a295 2
	{ "gssapiauthentication", sGssAuthentication, SSHCFG_GLOBAL },
	{ "gssapicleanupcredentials", sGssCleanupCreds, SSHCFG_GLOBAL },
d297 2
a298 2
	{ "gssapiauthentication", sUnsupported, SSHCFG_GLOBAL },
	{ "gssapicleanupcredentials", sUnsupported, SSHCFG_GLOBAL },
d300 46
a345 49
	{ "passwordauthentication", sPasswordAuthentication, SSHCFG_GLOBAL },
	{ "kbdinteractiveauthentication", sKbdInteractiveAuthentication, SSHCFG_GLOBAL },
	{ "challengeresponseauthentication", sChallengeResponseAuthentication, SSHCFG_GLOBAL },
	{ "skeyauthentication", sChallengeResponseAuthentication, SSHCFG_GLOBAL }, /* alias */
	{ "checkmail", sDeprecated, SSHCFG_GLOBAL },
	{ "listenaddress", sListenAddress, SSHCFG_GLOBAL },
	{ "addressfamily", sAddressFamily, SSHCFG_GLOBAL },
	{ "printmotd", sPrintMotd, SSHCFG_GLOBAL },
	{ "printlastlog", sPrintLastLog, SSHCFG_GLOBAL },
	{ "ignorerhosts", sIgnoreRhosts, SSHCFG_GLOBAL },
	{ "ignoreuserknownhosts", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },
	{ "x11forwarding", sX11Forwarding, SSHCFG_ALL },
	{ "x11displayoffset", sX11DisplayOffset, SSHCFG_ALL },
	{ "x11uselocalhost", sX11UseLocalhost, SSHCFG_ALL },
	{ "xauthlocation", sXAuthLocation, SSHCFG_GLOBAL },
	{ "strictmodes", sStrictModes, SSHCFG_GLOBAL },
	{ "permitemptypasswords", sEmptyPasswd, SSHCFG_GLOBAL },
	{ "permituserenvironment", sPermitUserEnvironment, SSHCFG_GLOBAL },
	{ "uselogin", sUseLogin, SSHCFG_GLOBAL },
	{ "compression", sCompression, SSHCFG_GLOBAL },
	{ "tcpkeepalive", sTCPKeepAlive, SSHCFG_GLOBAL },
	{ "keepalive", sTCPKeepAlive, SSHCFG_GLOBAL },	/* obsolete alias */
	{ "allowtcpforwarding", sAllowTcpForwarding, SSHCFG_ALL },
	{ "allowusers", sAllowUsers, SSHCFG_GLOBAL },
	{ "denyusers", sDenyUsers, SSHCFG_GLOBAL },
	{ "allowgroups", sAllowGroups, SSHCFG_GLOBAL },
	{ "denygroups", sDenyGroups, SSHCFG_GLOBAL },
	{ "ciphers", sCiphers, SSHCFG_GLOBAL },
	{ "macs", sMacs, SSHCFG_GLOBAL },
	{ "protocol", sProtocol, SSHCFG_GLOBAL },
	{ "gatewayports", sGatewayPorts, SSHCFG_ALL },
	{ "subsystem", sSubsystem, SSHCFG_GLOBAL },
	{ "maxstartups", sMaxStartups, SSHCFG_GLOBAL },
	{ "maxauthtries", sMaxAuthTries, SSHCFG_GLOBAL },
	{ "banner", sBanner, SSHCFG_GLOBAL },
	{ "usedns", sUseDNS, SSHCFG_GLOBAL },
	{ "verifyreversemapping", sDeprecated, SSHCFG_GLOBAL },
	{ "reversemappingcheck", sDeprecated, SSHCFG_GLOBAL },
	{ "clientaliveinterval", sClientAliveInterval, SSHCFG_GLOBAL },
	{ "clientalivecountmax", sClientAliveCountMax, SSHCFG_GLOBAL },
	{ "authorizedkeysfile", sAuthorizedKeysFile, SSHCFG_GLOBAL },
	{ "authorizedkeysfile2", sAuthorizedKeysFile2, SSHCFG_GLOBAL },
	{ "useprivilegeseparation", sUsePrivilegeSeparation, SSHCFG_GLOBAL},
	{ "acceptenv", sAcceptEnv, SSHCFG_GLOBAL },
	{ "permittunnel", sPermitTunnel, SSHCFG_GLOBAL },
	{ "match", sMatch, SSHCFG_ALL },
	{ "permitopen", sPermitOpen, SSHCFG_ALL },
	{ "forcecommand", sForceCommand, SSHCFG_ALL },
	{ NULL, sBadOption, 0 }
d354 1
a354 1
	    int linenum, u_int *flags)
d359 1
a359 2
		if (strcasecmp(cp, keywords[i].name) == 0) {
			*flags = keywords[i].flags;
a360 1
		}
a404 150
/*
 * The strategy for the Match blocks is that the config file is parsed twice.
 *
 * The first time is at startup.  activep is initialized to 1 and the
 * directives in the global context are processed and acted on.  Hitting a
 * Match directive unsets activep and the directives inside the block are
 * checked for syntax only.
 *
 * The second time is after a connection has been established but before
 * authentication.  activep is initialized to 2 and global config directives
 * are ignored since they have already been processed.  If the criteria in a
 * Match block is met, activep is set and the subsequent directives
 * processed and actioned until EOF or another Match block unsets it.  Any
 * options set are copied into the main server config.
 *
 * Potential additions/improvements:
 *  - Add Match support for pre-kex directives, eg Protocol, Ciphers.
 *
 *  - Add a Tag directive (idea from David Leonard) ala pf, eg:
 *	Match Address 192.168.0.*
 *		Tag trusted
 *	Match Group wheel
 *		Tag trusted
 *	Match Tag trusted
 *		AllowTcpForwarding yes
 *		GatewayPorts clientspecified
 *		[...]
 *
 *  - Add a PermittedChannelRequests directive
 *	Match Group shell
 *		PermittedChannelRequests session,forwarded-tcpip
 */

static int
match_cfg_line_group(const char *grps, int line, const char *user)
{
	int result = 0;
	u_int ngrps = 0;
	char *arg, *p, *cp, *grplist[MAX_MATCH_GROUPS];
	struct passwd *pw;

	/*
	 * Even if we do not have a user yet, we still need to check for
	 * valid syntax.
	 */
	arg = cp = xstrdup(grps);
	while ((p = strsep(&cp, ",")) != NULL && *p != '\0') {
		if (ngrps >= MAX_MATCH_GROUPS) {
			error("line %d: too many groups in Match Group", line);
			result = -1;
			goto out;
		}
		grplist[ngrps++] = p;
	}

	if (user == NULL)
		goto out;

	if ((pw = getpwnam(user)) == NULL) {
		debug("Can't match group at line %d because user %.100s does "
		    "not exist", line, user);
	} else if (ga_init(pw->pw_name, pw->pw_gid) == 0) {
		debug("Can't Match group because user %.100s not in any group "
		    "at line %d", user, line);
	} else if (ga_match(grplist, ngrps) != 1) {
		debug("user %.100s does not match group %.100s at line %d",
		    user, arg, line);
	} else {
		debug("user %.100s matched group %.100s at line %d", user,
		    arg, line);
		result = 1;
	}
out:
	ga_free();
	xfree(arg);
	return result;
}

static int
match_cfg_line(char **condition, int line, const char *user, const char *host,
    const char *address)
{
	int result = 1;
	char *arg, *attrib, *cp = *condition;
	size_t len;

	if (user == NULL)
		debug3("checking syntax for 'Match %s'", cp);
	else
		debug3("checking match for '%s' user %s host %s addr %s", cp,
		    user ? user : "(null)", host ? host : "(null)",
		    address ? address : "(null)");

	while ((attrib = strdelim(&cp)) && *attrib != '\0') {
		if ((arg = strdelim(&cp)) == NULL || *arg == '\0') {
			error("Missing Match criteria for %s", attrib);
			return -1;
		}
		len = strlen(arg);
		if (strcasecmp(attrib, "user") == 0) {
			if (!user) {
				result = 0;
				continue;
			}
			if (match_pattern_list(user, arg, len, 0) != 1)
				result = 0;
			else
				debug("user %.100s matched 'User %.100s' at "
				    "line %d", user, arg, line);
		} else if (strcasecmp(attrib, "group") == 0) {
			switch (match_cfg_line_group(arg, line, user)) {
			case -1:
				return -1;
			case 0:
				result = 0;
			}
		} else if (strcasecmp(attrib, "host") == 0) {
			if (!host) {
				result = 0;
				continue;
			}
			if (match_hostname(host, arg, len) != 1)
				result = 0;
			else
				debug("connection from %.100s matched 'Host "
				    "%.100s' at line %d", host, arg, line);
		} else if (strcasecmp(attrib, "address") == 0) {
			debug("address '%s' arg '%s'", address, arg);
			if (!address) {
				result = 0;
				continue;
			}
			if (match_hostname(address, arg, len) != 1)
				result = 0;
			else
				debug("connection from %.100s matched 'Address "
				    "%.100s' at line %d", address, arg, line);
		} else {
			error("Unsupported Match attribute %s", attrib);
			return -1;
		}
	}
	if (user != NULL)
		debug3("match %sfound", result ? "" : "not ");
	*condition = cp;
	return result;
}

#define WHITESPACE " \t\r\n"

d407 1
a407 2
    const char *filename, int linenum, int *activep, const char *user,
    const char *host, const char *address)
d410 1
a410 1
	int cmdline = 0, *intptr, value, n;
d413 1
a413 2
	u_int i, flags = 0;
	size_t len;
d416 1
a416 2
	if ((arg = strdelim(&cp)) == NULL)
		return 0;
d424 1
a424 19
	opcode = parse_token(arg, filename, linenum, &flags);

	if (activep == NULL) { /* We are processing a command line directive */
		cmdline = 1;
		activep = &cmdline;
	}
	if (*activep && opcode != sMatch)
		debug3("%s:%d setting %s %s", filename, linenum, arg, cp);
	if (*activep == 0 && !(flags & SSHCFG_MATCH)) {
		if (user == NULL) {
			fatal("%s line %d: Directive '%s' is not allowed "
			    "within a Match block", filename, linenum, arg);
		} else { /* this is a directive we have already processed */
			while (arg)
				arg = strdelim(&cp);
			return 0;
		}
	}

d456 1
a456 1
		if (*activep && *intptr == -1)
d536 1
a536 1
		if (*activep && *charptr == NULL) {
d587 1
a587 1
		if (*activep && *intptr == -1)
d782 1
a782 1
				fatal("%s line %d: too many deny users.",
a851 4
		if (!*activep) {
			arg = strdelim(&cp);
			break;
		}
a861 11

		/* Collect arguments (separate to executable) */
		p = xstrdup(arg);
		len = strlen(p) + 1;
		while ((arg = strdelim(&cp)) != NULL && *arg != '\0') {
			len += 1 + strlen(arg);
			p = xrealloc(p, 1, len);
			strlcat(p, " ", len);
			strlcat(p, arg, len);
		}
		options->subsystem_args[options->num_subsystems] = p;
d902 1
a902 1
		charptr = (opcode == sAuthorizedKeysFile) ?
a922 2
			if (!*activep)
				break;
a949 49
	case sMatch:
		if (cmdline)
			fatal("Match directive not supported as a command-line "
			   "option");
		value = match_cfg_line(&cp, linenum, user, host, address);
		if (value < 0)
			fatal("%s line %d: Bad Match condition", filename,
			    linenum);
		*activep = value;
		break;

	case sPermitOpen:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing PermitOpen specification",
			    filename, linenum);
		if (strcmp(arg, "any") == 0) {
			if (*activep) {
				channel_clear_adm_permitted_opens();
				options->num_permitted_opens = 0;
			}
			break;
		}
		for (; arg != NULL && *arg != '\0'; arg = strdelim(&cp)) {
			p = hpdelim(&arg);
			if (p == NULL)
				fatal("%s line %d: missing host in PermitOpen",
				    filename, linenum);
			p = cleanhostname(p);
			if (arg == NULL || (port = a2port(arg)) == 0)
				fatal("%s line %d: bad port number in "
				    "PermitOpen", filename, linenum);
			if (*activep && options->num_permitted_opens == -1) {
				channel_clear_adm_permitted_opens();
				options->num_permitted_opens =
				    channel_add_adm_permitted_opens(p, port);
			}
		}
		break;

	case sForceCommand:
		if (cp == NULL)
			fatal("%.200s line %d: Missing argument.", filename,
			    linenum);
		len = strspn(cp, WHITESPACE);
		if (*activep && options->adm_forced_command == NULL)
			options->adm_forced_command = xstrdup(cp + len);
		return 0;

d1006 1
a1006 34
parse_server_match_config(ServerOptions *options, const char *user,
    const char *host, const char *address)
{
	ServerOptions mo;

	initialize_server_options(&mo);
	parse_server_config(&mo, "reprocess config", &cfg, user, host, address);
	copy_set_server_options(options, &mo);
}

/* Copy any (supported) values that are set */
void
copy_set_server_options(ServerOptions *dst, ServerOptions *src)
{
	if (src->allow_tcp_forwarding != -1)
		dst->allow_tcp_forwarding = src->allow_tcp_forwarding;
	if (src->gateway_ports != -1)
		dst->gateway_ports = src->gateway_ports;
	if (src->adm_forced_command != NULL) {
		if (dst->adm_forced_command != NULL)
			xfree(dst->adm_forced_command);
		dst->adm_forced_command = src->adm_forced_command;
	}
	if (src->x11_display_offset != -1)
		dst->x11_display_offset = src->x11_display_offset;
	if (src->x11_forwarding != -1)
		dst->x11_forwarding = src->x11_forwarding;
	if (src->x11_use_localhost != -1)
		dst->x11_use_localhost = src->x11_use_localhost;
}

void
parse_server_config(ServerOptions *options, const char *filename, Buffer *conf,
    const char *user, const char *host, const char *address)
d1008 1
a1008 1
	int active, linenum, bad_options = 0;
a1013 1
	active = user ? 0 : 1;
d1017 1
a1017 1
		    linenum++, &active, user, host, address) != 0)
@


1.143
log
@add a new compression method that delays compression until the user
has been authenticated successfully and set compression to 'delayed'
for sshd.

this breaks older openssh clients (< 3.5) if they insist on
compression, so you have to re-enable compression in sshd_config.
ok djm@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.142 2005/06/17 02:44:33 djm Exp $");
d479 6
@


1.142
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.141 2005/05/16 15:30:51 markus Exp $");
d194 1
a194 1
		options->compression = 1;
d687 17
a703 1
		goto parse_flag;
@


1.141
log
@check return value from strdelim() for NULL (AddressFamily); mpech
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.140 2005/03/10 22:01:05 deraadt Exp $");
d366 1
a366 1
	int i;
d406 1
a406 1
	int *intptr, value, i, n;
d409 1
@


1.140
log
@spacing
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.139 2005/03/01 10:09:52 djm Exp $");
d494 3
@


1.140.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.144 2005/08/06 10:03:12 dtucker Exp $");
d194 1
a194 1
		options->compression = COMP_DELAYED;
d366 1
a366 1
	u_int i;
d406 1
a406 1
	int *intptr, value, n;
a408 1
	u_int i;
a477 6
		/* check for bare IPv6 address: no "[]" and 2 or more ":" */
		if (strchr(arg, '[') == NULL && (p = strchr(arg, ':')) != NULL
		    && strchr(p+1, ':') != NULL) {
			add_listen_addr(options, arg, 0);
			break;
		}
a493 3
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing address family.",
			    filename, linenum);
d683 1
a683 17
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/no/delayed "
			    "argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "delayed") == 0)
			value = COMP_DELAYED;
		else if (strcmp(arg, "yes") == 0)
			value = COMP_ZLIB;
		else if (strcmp(arg, "no") == 0)
			value = COMP_NONE;
		else
			fatal("%s line %d: Bad yes/no/delayed "
			    "argument: %s", filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;
@


1.140.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.146 2005/12/08 18:34:11 reyk Exp $");
a98 1
	options->permit_tun = -1;
a221 2
	if (options->permit_tun == -1)
		options->permit_tun = SSH_TUNMODE_NO;
d250 1
a250 1
	sGssAuthentication, sGssCleanupCreds, sAcceptEnv, sPermitTunnel,
a340 1
	{ "permittunnel", sPermitTunnel },
a921 22
		break;

	case sPermitTunnel:
		intptr = &options->permit_tun;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing yes/point-to-point/"
			    "ethernet/no argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcasecmp(arg, "ethernet") == 0)
			value = SSH_TUNMODE_ETHERNET;
		else if (strcasecmp(arg, "point-to-point") == 0)
			value = SSH_TUNMODE_POINTOPOINT;
		else if (strcasecmp(arg, "yes") == 0)
			value = SSH_TUNMODE_YES;
		else if (strcasecmp(arg, "no") == 0)
			value = SSH_TUNMODE_NO;
		else
			fatal("%s line %d: Bad yes/point-to-point/ethernet/"
			    "no argument: %s", filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
@


1.139
log
@bz#413: allow optional specification of bind address for port forwardings.
Patch originally by Dan Astorian, but worked on by several people
Adds GatewayPorts=clientspecified option on server to allow remote forwards
to bind to client-specified ports.

ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.138 2004/12/23 23:11:00 djm Exp $");
d963 1
a963 1
	while((cp = strsep(&cbuf, "\n")) != NULL) {
@


1.138
log
@bz #898: support AddressFamily in sshd_config. from peak@@argo.troja.mff.cuni.cz
ok deraadt@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.137 2004/08/13 11:09:24 dtucker Exp $");
d408 1
d475 2
a476 2
		if (!arg || *arg == '\0' || strncmp(arg, "[]", 2) == 0)
			fatal("%s line %d: missing inet addr.",
d478 11
a488 13
		if (*arg == '[') {
			if ((p = strchr(arg, ']')) == NULL)
				fatal("%s line %d: bad ipv6 inet addr usage.",
				    filename, linenum);
			arg++;
			memmove(p, p+1, strlen(p+1)+1);
		} else if (((p = strchr(arg, ':')) == NULL) ||
			    (strchr(p+1, ':') != NULL)) {
			add_listen_addr(options, arg, 0);
			break;
		}
		if (*p == ':') {
			u_short port;
a489 16
			p++;
			if (*p == '\0')
				fatal("%s line %d: bad inet addr:port usage.",
				    filename, linenum);
			else {
				*(p-1) = '\0';
				if ((port = a2port(p)) == 0)
					fatal("%s line %d: bad port number.",
					    filename, linenum);
				add_listen_addr(options, arg, port);
			}
		} else if (*p == '\0')
			add_listen_addr(options, arg, 0);
		else
			fatal("%s line %d: bad inet addr usage.",
			    filename, linenum);
d687 17
a703 1
		goto parse_flag;
@


1.137
log
@Fix line numbers off-by-one in error messages, from tortay at cc.in2p3.fr
ok markus@@, djm@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.136 2004/08/11 11:09:54 dtucker Exp $");
a28 2
/* AF_UNSPEC or AF_INET or AF_INET6 */
extern int IPv4or6;
d41 1
d237 2
a238 1
	sPasswordAuthentication, sKbdInteractiveAuthentication, sListenAddress,
d303 1
d370 2
d387 1
a387 1
	hints.ai_family = IPv4or6;
d507 19
@


1.137.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.139 2005/03/01 10:09:52 djm Exp $");
d29 2
a42 1
	options->address_family = -1;
d238 1
a238 2
	sPasswordAuthentication, sKbdInteractiveAuthentication,
	sListenAddress, sAddressFamily,
a302 1
	{ "addressfamily", sAddressFamily },
a368 2
	if (options->address_family == -1)
		options->address_family = AF_UNSPEC;
d384 1
a384 1
	hints.ai_family = options->address_family;
a404 1
	u_short port;
d471 2
a472 2
		if (arg == NULL || *arg == '\0')
			fatal("%s line %d: missing address",
d474 13
a486 9
		p = hpdelim(&arg);
		if (p == NULL)
			fatal("%s line %d: bad address:port usage",
			    filename, linenum);
		p = cleanhostname(p);
		if (arg == NULL)
			port = 0;
		else if ((port = a2port(arg)) == 0)
			fatal("%s line %d: bad port number", filename, linenum);
d488 13
a500 16
		add_listen_addr(options, p, port);

		break;

	case sAddressFamily:
		arg = strdelim(&cp);
		intptr = &options->address_family;
		if (options->listen_addrs != NULL)
			fatal("%s line %d: address family must be specified before "
			    "ListenAddress.", filename, linenum);
		if (strcasecmp(arg, "inet") == 0)
			value = AF_INET;
		else if (strcasecmp(arg, "inet6") == 0)
			value = AF_INET6;
		else if (strcasecmp(arg, "any") == 0)
			value = AF_UNSPEC;
d502 2
a503 4
			fatal("%s line %d: unsupported address family \"%s\".",
			    filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
d682 1
a682 17
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/no/clientspecified "
			    "argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "clientspecified") == 0)
			value = 2;
		else if (strcmp(arg, "yes") == 0)
			value = 1;
		else if (strcmp(arg, "no") == 0)
			value = 0;
		else
			fatal("%s line %d: Bad yes/no/clientspecified "
			    "argument: %s", filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;
@


1.137.2.2
log
@upgrade to OpenSSH 4.1
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.140 2005/03/10 22:01:05 deraadt Exp $");
d963 1
a963 1
	while ((cp = strsep(&cbuf, "\n")) != NULL) {
@


1.137.2.3
log
@upgrade to OpenSSH 4.2
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.144 2005/08/06 10:03:12 dtucker Exp $");
d194 1
a194 1
		options->compression = COMP_DELAYED;
d366 1
a366 1
	u_int i;
d406 1
a406 1
	int *intptr, value, n;
a408 1
	u_int i;
a477 6
		/* check for bare IPv6 address: no "[]" and 2 or more ":" */
		if (strchr(arg, '[') == NULL && (p = strchr(arg, ':')) != NULL
		    && strchr(p+1, ':') != NULL) {
			add_listen_addr(options, arg, 0);
			break;
		}
a493 3
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing address family.",
			    filename, linenum);
d683 1
a683 17
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/no/delayed "
			    "argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "delayed") == 0)
			value = COMP_DELAYED;
		else if (strcmp(arg, "yes") == 0)
			value = COMP_ZLIB;
		else if (strcmp(arg, "no") == 0)
			value = COMP_NONE;
		else
			fatal("%s line %d: Bad yes/no/delayed "
			    "argument: %s", filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;
@


1.136
log
@Fix minor leak; "looks right" deraadt@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.135 2004/07/11 17:48:47 deraadt Exp $");
d941 1
a941 1
	linenum = 0;
@


1.135
log
@spaces
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.134 2004/06/24 19:30:54 djm Exp $");
d936 1
a936 1
	char *cp, *cbuf;
d940 1
a940 1
	cbuf = xstrdup(buffer_ptr(conf));
d947 1
a947 1
	free(cbuf);
@


1.134
log
@re-exec sshd on accept(); initial work, final debugging and ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.133 2004/05/23 23:59:53 dtucker Exp $");
d918 1
a918 1
		 * NB - preserve newlines, they are needed to reproduce 
@


1.133
log
@Add MaxAuthTries sshd config option; ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.132 2004/05/08 00:01:37 deraadt Exp $");
d904 1
a904 1
read_server_config(ServerOptions *options, const char *filename)
d906 1
a906 2
	int linenum, bad_options = 0;
	char line[1024];
d909 2
a910 3
	debug2("read_server_config: filename %s", filename);
	f = fopen(filename, "r");
	if (!f) {
d914 27
d942 3
a944 4
	while (fgets(line, sizeof(line), f)) {
		/* Update line number counter. */
		linenum++;
		if (process_server_config_line(options, line, filename, linenum) != 0)
d947 1
a947 1
	fclose(f);
@


1.132
log
@make two tiny header files go away; djm ok
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.131 2004/04/27 09:46:37 djm Exp $");
d92 1
d206 2
d245 2
a246 1
	sGatewayPorts, sPubkeyAuthentication, sXAuthLocation, sSubsystem, sMaxStartups,
d329 1
d835 4
@


1.131
log
@bz #815: implement ability to pass specified environment variables from the
client to the server; ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.130 2003/12/23 16:12:10 jakob Exp $");
a20 1
#include "tildexpand.h"
@


1.130
log
@implement KerberosGetAFSToken server option. ok markus@@, beck@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.129 2003/12/09 21:53:36 markus Exp $");
d99 1
d247 1
a247 1
	sGssAuthentication, sGssCleanupCreds,
d335 1
d855 13
@


1.130.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.137 2004/08/13 11:09:24 dtucker Exp $");
d21 1
a92 1
	options->max_authtries = -1;
a98 1
	options->num_accept_env = 0;
a204 2
	if (options->max_authtries == -1)
		options->max_authtries = DEFAULT_AUTH_FAIL_MAX;
d242 1
a242 2
	sGatewayPorts, sPubkeyAuthentication, sXAuthLocation, sSubsystem,
	sMaxStartups, sMaxAuthTries,
d246 1
a246 1
	sGssAuthentication, sGssCleanupCreds, sAcceptEnv,
a324 1
	{ "maxauthtries", sMaxAuthTries },
a333 1
	{ "acceptenv", sAcceptEnv },
a829 4
	case sMaxAuthTries:
		intptr = &options->max_authtries;
		goto parse_int;

a853 13
	case sAcceptEnv:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (strchr(arg, '=') != NULL)
				fatal("%s line %d: Invalid environment name.",
				    filename, linenum);
			if (options->num_accept_env >= MAX_ACCEPT_ENV)
				fatal("%s line %d: too many allow env.",
				    filename, linenum);
			options->accept_env[options->num_accept_env++] =
			    xstrdup(arg);
		}
		break;

d881 1
a881 1
load_server_config(const char *filename, Buffer *conf)
d883 2
a884 1
	char line[1024], *cp;
d887 3
a889 2
	debug2("%s: filename %s", __func__, filename);
	if ((f = fopen(filename, "r")) == NULL) {
d893 1
a893 1
	buffer_clear(conf);
d895 4
a898 10
		/*
		 * Trim out comments and strip whitespace
		 * NB - preserve newlines, they are needed to reproduce
		 * line numbers later for error messages
		 */
		if ((cp = strchr(line, '#')) != NULL)
			memcpy(cp, "\n", 2);
		cp = line + strspn(line, " \t\r");

		buffer_append(conf, cp, strlen(cp));
a899 1
	buffer_append(conf, "\0", 1);
a900 19
	debug2("%s: done config len = %d", __func__, buffer_len(conf));
}

void
parse_server_config(ServerOptions *options, const char *filename, Buffer *conf)
{
	int linenum, bad_options = 0;
	char *cp, *obuf, *cbuf;

	debug2("%s: config %s len %d", __func__, filename, buffer_len(conf));

	obuf = cbuf = xstrdup(buffer_ptr(conf));
	linenum = 1;
	while((cp = strsep(&cbuf, "\n")) != NULL) {
		if (process_server_config_line(options, cp, filename,
		    linenum++) != 0)
			bad_options++;
	}
	xfree(obuf);
@


1.130.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.139 2005/03/01 10:09:52 djm Exp $");
d29 2
a42 1
	options->address_family = -1;
d238 1
a238 2
	sPasswordAuthentication, sKbdInteractiveAuthentication,
	sListenAddress, sAddressFamily,
a302 1
	{ "addressfamily", sAddressFamily },
a368 2
	if (options->address_family == -1)
		options->address_family = AF_UNSPEC;
d384 1
a384 1
	hints.ai_family = options->address_family;
a404 1
	u_short port;
d471 2
a472 2
		if (arg == NULL || *arg == '\0')
			fatal("%s line %d: missing address",
d474 13
a486 9
		p = hpdelim(&arg);
		if (p == NULL)
			fatal("%s line %d: bad address:port usage",
			    filename, linenum);
		p = cleanhostname(p);
		if (arg == NULL)
			port = 0;
		else if ((port = a2port(arg)) == 0)
			fatal("%s line %d: bad port number", filename, linenum);
d488 13
a500 16
		add_listen_addr(options, p, port);

		break;

	case sAddressFamily:
		arg = strdelim(&cp);
		intptr = &options->address_family;
		if (options->listen_addrs != NULL)
			fatal("%s line %d: address family must be specified before "
			    "ListenAddress.", filename, linenum);
		if (strcasecmp(arg, "inet") == 0)
			value = AF_INET;
		else if (strcasecmp(arg, "inet6") == 0)
			value = AF_INET6;
		else if (strcasecmp(arg, "any") == 0)
			value = AF_UNSPEC;
d502 2
a503 4
			fatal("%s line %d: unsupported address family \"%s\".",
			    filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
d682 1
a682 17
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/no/clientspecified "
			    "argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "clientspecified") == 0)
			value = 2;
		else if (strcmp(arg, "yes") == 0)
			value = 1;
		else if (strcmp(arg, "no") == 0)
			value = 0;
		else
			fatal("%s line %d: Bad yes/no/clientspecified "
			    "argument: %s", filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;
@


1.129
log
@rename keepalive to tcpkeepalive; the old name causes too much
confusion; ok djm, dtucker; with help from jmc@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.128 2003/09/29 20:19:57 markus Exp $");
d70 1
d175 2
d233 1
d277 1
d282 1
d600 4
@


1.128
log
@GSSAPICleanupCreds -> GSSAPICleanupCredentials
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.127 2003/09/01 18:15:50 markus Exp $");
d59 1
a59 1
	options->keepalives = -1;
d152 2
a153 2
	if (options->keepalives == -1)
		options->keepalives = 1;
d234 1
a234 1
	sStrictModes, sEmptyPasswd, sKeepAlives,
d306 2
a307 1
	{ "keepalive", sKeepAlives },
d644 2
a645 2
	case sKeepAlives:
		intptr = &options->keepalives;
@


1.127
log
@remove unused kerberos code; ok henning@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.126 2003/08/28 12:54:34 markus Exp $");
d282 1
a282 1
	{ "gssapicleanupcreds", sGssCleanupCreds },
d285 1
a285 1
	{ "gssapicleanupcreds", sUnsupported },
@


1.127.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.130 2003/12/23 16:12:10 jakob Exp $");
d59 1
a59 1
	options->tcp_keep_alive = -1;
a69 1
	options->kerberos_get_afs_token = -1;
d152 2
a153 2
	if (options->tcp_keep_alive == -1)
		options->tcp_keep_alive = 1;
a173 2
	if (options->kerberos_get_afs_token == -1)
		options->kerberos_get_afs_token = 0;
a229 1
	sKerberosGetAFSToken,
d234 1
a234 1
	sStrictModes, sEmptyPasswd, sTCPKeepAlive,
a272 1
	{ "kerberosgetafstoken", sKerberosGetAFSToken },
a276 1
	{ "kerberosgetafstoken", sUnsupported },
d282 1
a282 1
	{ "gssapicleanupcredentials", sGssCleanupCreds },
d285 1
a285 1
	{ "gssapicleanupcredentials", sUnsupported },
d306 1
a306 2
	{ "tcpkeepalive", sTCPKeepAlive },
	{ "keepalive", sTCPKeepAlive },				/* obsolete alias */
a594 4
	case sKerberosGetAFSToken:
		intptr = &options->kerberos_get_afs_token;
		goto parse_flag;

d643 2
a644 2
	case sTCPKeepAlive:
		intptr = &options->tcp_keep_alive;
@


1.127.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.137 2004/08/13 11:09:24 dtucker Exp $");
d21 1
a92 1
	options->max_authtries = -1;
a98 1
	options->num_accept_env = 0;
a204 2
	if (options->max_authtries == -1)
		options->max_authtries = DEFAULT_AUTH_FAIL_MAX;
d242 1
a242 2
	sGatewayPorts, sPubkeyAuthentication, sXAuthLocation, sSubsystem,
	sMaxStartups, sMaxAuthTries,
d246 1
a246 1
	sGssAuthentication, sGssCleanupCreds, sAcceptEnv,
a324 1
	{ "maxauthtries", sMaxAuthTries },
a333 1
	{ "acceptenv", sAcceptEnv },
a829 4
	case sMaxAuthTries:
		intptr = &options->max_authtries;
		goto parse_int;

a853 13
	case sAcceptEnv:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (strchr(arg, '=') != NULL)
				fatal("%s line %d: Invalid environment name.",
				    filename, linenum);
			if (options->num_accept_env >= MAX_ACCEPT_ENV)
				fatal("%s line %d: too many allow env.",
				    filename, linenum);
			options->accept_env[options->num_accept_env++] =
			    xstrdup(arg);
		}
		break;

d881 1
a881 1
load_server_config(const char *filename, Buffer *conf)
d883 2
a884 1
	char line[1024], *cp;
d887 3
a889 2
	debug2("%s: filename %s", __func__, filename);
	if ((f = fopen(filename, "r")) == NULL) {
d893 1
a893 1
	buffer_clear(conf);
d895 4
a898 10
		/*
		 * Trim out comments and strip whitespace
		 * NB - preserve newlines, they are needed to reproduce
		 * line numbers later for error messages
		 */
		if ((cp = strchr(line, '#')) != NULL)
			memcpy(cp, "\n", 2);
		cp = line + strspn(line, " \t\r");

		buffer_append(conf, cp, strlen(cp));
a899 1
	buffer_append(conf, "\0", 1);
a900 19
	debug2("%s: done config len = %d", __func__, buffer_len(conf));
}

void
parse_server_config(ServerOptions *options, const char *filename, Buffer *conf)
{
	int linenum, bad_options = 0;
	char *cp, *obuf, *cbuf;

	debug2("%s: config %s len %d", __func__, filename, buffer_len(conf));

	obuf = cbuf = xstrdup(buffer_ptr(conf));
	linenum = 1;
	while((cp = strsep(&cbuf, "\n")) != NULL) {
		if (process_server_config_line(options, cp, filename,
		    linenum++) != 0)
			bad_options++;
	}
	xfree(obuf);
@


1.126
log
@remove kerberos support from ssh1, since it has been replaced with GSSAPI;
but keep kerberos passwd auth for ssh1 and 2; ok djm, hin, henning, ...
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.125 2003/08/22 10:56:09 markus Exp $");
a69 1
	options->kerberos_tgt_passing = -1;
a173 2
	if (options->kerberos_tgt_passing == -1)
		options->kerberos_tgt_passing = 0;
a592 4
		goto parse_flag;

	case sKerberosTgtPassing:
		intptr = &options->kerberos_tgt_passing;
@


1.125
log
@support GSS API user authentication; patches from Simon Wilkinson,
stripped down and tested by Jakob and myself.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.124 2003/08/13 08:46:30 markus Exp $");
a275 1
	{ "kerberostgtpassing", sKerberosTgtPassing },
d280 1
a281 1
#endif
@


1.124
log
@remove RhostsAuthentication; suggested by djm@@ before; ok djm@@, deraadt@@,
fgsch@@, miod@@, henning@@, jakob@@ and others
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.123 2003/07/22 13:35:22 markus Exp $");
d71 2
d177 4
d245 1
d284 7
d601 8
@


1.123
log
@remove (already disabled) KRB4/AFS support, re-enable -k in ssh(1);
test+ok henning@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.122 2003/06/02 09:17:34 markus Exp $");
a61 1
	options->rhosts_authentication = -1;
a156 2
	if (options->rhosts_authentication == -1)
		options->rhosts_authentication = 0;
d225 1
a225 1
	sRhostsAuthentication, sRhostsRSAAuthentication, sRSAAuthentication,
d258 1
a258 1
	{ "rhostsauthentication", sRhostsAuthentication },
a550 4
		goto parse_flag;

	case sRhostsAuthentication:
		intptr = &options->rhosts_authentication;
@


1.122
log
@deprecate VerifyReverseMapping since it's dangerous if combined
with IP based access control as noted by Mike Harding; replace with
a UseDNS option, UseDNS is on by default and includes the
VerifyReverseMapping check; with itojun@@, provos@@, jakob@@ and deraadt@@
ok deraadt@@, djm@@
@
text
@d13 1
a13 8
RCSID("$OpenBSD: servconf.c,v 1.121 2003/05/15 14:02:47 jakob Exp $");

#if defined(KRB4)
#include <krb.h>
#endif
#ifdef AFS
#include <kafs.h>
#endif
a71 1
	options->afs_token_passing = -1;
a177 2
	if (options->afs_token_passing == -1)
		options->afs_token_passing = 0;
d230 1
a230 1
	sKerberosTgtPassing, sAFSTokenPassing, sChallengeResponseAuthentication,
d268 1
a268 1
#if defined(KRB4) || defined(KRB5)
a278 3
#if defined(AFS)
	{ "afstokenpassing", sAFSTokenPassing },
#else
a279 1
#endif
a593 4
		goto parse_flag;

	case sAFSTokenPassing:
		intptr = &options->afs_token_passing;
@


1.121
log
@warn for unsupported config option. ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.120 2003/05/15 04:08:44 jakob Exp $");
d101 1
a101 1
	options->verify_reverse_mapping = -1;
d212 2
a213 2
	if (options->verify_reverse_mapping == -1)
		options->verify_reverse_mapping = 0;
d249 1
a249 1
	sBanner, sVerifyReverseMapping, sHostbasedAuthentication,
d326 3
a328 2
	{ "verifyreversemapping", sVerifyReverseMapping },
	{ "reversemappingcheck", sVerifyReverseMapping },
d678 2
a679 2
	case sVerifyReverseMapping:
		intptr = &options->verify_reverse_mapping;
@


1.120
log
@disable kerberos when not supported. ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.119 2003/05/15 01:48:10 jakob Exp $");
a182 1
#if defined(KRB4) || defined(KRB5)
a183 3
#else
		options->kerberos_ticket_cleanup = 0;
#endif
d253 1
a253 1
	sDeprecated
d278 1
d283 7
d291 3
d855 7
@


1.119
log
@always parse kerberos options. ok djm@@ markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.118 2003/04/09 08:23:52 hin Exp $");
d183 1
d185 3
@


1.118
log
@Don't include <krb.h> when compiling with Kerberos 5 support
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.117 2003/04/08 20:21:29 itojun Exp $");
a74 1
#if defined(KRB4) || defined(KRB5)
a77 2
#endif
#if defined(AFS) || defined(KRB5)
a78 2
#endif
#ifdef AFS
a79 1
#endif
a177 1
#if defined(KRB4) || defined(KRB5)
a183 2
#endif
#if defined(AFS) || defined(KRB5)
a185 2
#endif
#ifdef AFS
a187 1
#endif
a238 1
#if defined(KRB4) || defined(KRB5)
d240 1
a240 8
#endif
#if defined(AFS) || defined(KRB5)
	sKerberosTgtPassing,
#endif
#ifdef AFS
	sAFSTokenPassing,
#endif
	sChallengeResponseAuthentication,
a277 1
#if defined(KRB4) || defined(KRB5)
a280 2
#endif
#if defined(AFS) || defined(KRB5)
a281 2
#endif
#ifdef AFS
a282 1
#endif
d581 1
a581 1
#if defined(KRB4) || defined(KRB5)
d593 1
a593 2
#endif
#if defined(AFS) || defined(KRB5)
d597 1
a597 2
#endif
#ifdef AFS
a600 1
#endif
@


1.117
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.116 2003/02/21 09:05:53 markus Exp $");
d15 1
a15 1
#if defined(KRB4) || defined(KRB5)
@


1.116
log
@print sshd_config filename in debug2 mode.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.115 2002/09/04 18:52:42 stevesk Exp $");
d872 1
a872 1
		log("%s line %d: Deprecated option %s",
@


1.116.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d13 8
a20 1
RCSID("$OpenBSD: servconf.c,v 1.127 2003/09/01 18:15:50 markus Exp $");
d69 1
d75 1
d79 7
a85 2
	options->gss_authentication=-1;
	options->gss_cleanup_creds = -1;
d107 1
a107 1
	options->use_dns = -1;
d172 2
d184 1
d191 9
a199 4
	if (options->gss_authentication == -1)
		options->gss_authentication = 0;
	if (options->gss_cleanup_creds == -1)
		options->gss_cleanup_creds = 1;
d224 2
a225 2
	if (options->use_dns == -1)
		options->use_dns = 1;
d250 2
a251 1
	sRhostsRSAAuthentication, sRSAAuthentication,
d253 8
a260 1
	sKerberosTgtPassing, sChallengeResponseAuthentication,
d269 1
a269 1
	sBanner, sUseDNS, sHostbasedAuthentication,
a271 1
	sGssAuthentication, sGssCleanupCreds,
d273 1
a273 1
	sDeprecated, sUnsupported
d291 1
a291 1
	{ "rhostsauthentication", sDeprecated },
d298 1
a298 1
#ifdef KRB5
d302 6
a307 13
#else
	{ "kerberosauthentication", sUnsupported },
	{ "kerberosorlocalpasswd", sUnsupported },
	{ "kerberosticketcleanup", sUnsupported },
#endif
	{ "kerberostgtpassing", sUnsupported },
	{ "afstokenpassing", sUnsupported },
#ifdef GSSAPI
	{ "gssapiauthentication", sGssAuthentication },
	{ "gssapicleanupcreds", sGssCleanupCreds },
#else
	{ "gssapiauthentication", sUnsupported },
	{ "gssapicleanupcreds", sUnsupported },
d341 2
a342 3
	{ "usedns", sUseDNS },
	{ "verifyreversemapping", sDeprecated },
	{ "reversemappingcheck", sDeprecated },
d584 4
d607 1
a607 1

d619 4
a622 3

	case sGssAuthentication:
		intptr = &options->gss_authentication;
d624 4
a627 3

	case sGssCleanupCreds:
		intptr = &options->gss_cleanup_creds;
d629 1
d695 2
a696 2
	case sUseDNS:
		intptr = &options->use_dns;
d872 1
a872 8
		logit("%s line %d: Deprecated option %s",
		    filename, linenum, arg);
		while (arg)
		    arg = strdelim(&cp);
		break;

	case sUnsupported:
		logit("%s line %d: Unsupported option %s",
@


1.116.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.130 2003/12/23 16:12:10 jakob Exp $");
d59 1
a59 1
	options->tcp_keep_alive = -1;
a69 1
	options->kerberos_get_afs_token = -1;
d152 2
a153 2
	if (options->tcp_keep_alive == -1)
		options->tcp_keep_alive = 1;
a173 2
	if (options->kerberos_get_afs_token == -1)
		options->kerberos_get_afs_token = 0;
a229 1
	sKerberosGetAFSToken,
d234 1
a234 1
	sStrictModes, sEmptyPasswd, sTCPKeepAlive,
a272 1
	{ "kerberosgetafstoken", sKerberosGetAFSToken },
a276 1
	{ "kerberosgetafstoken", sUnsupported },
d282 1
a282 1
	{ "gssapicleanupcredentials", sGssCleanupCreds },
d285 1
a285 1
	{ "gssapicleanupcredentials", sUnsupported },
d306 1
a306 2
	{ "tcpkeepalive", sTCPKeepAlive },
	{ "keepalive", sTCPKeepAlive },				/* obsolete alias */
a594 4
	case sKerberosGetAFSToken:
		intptr = &options->kerberos_get_afs_token;
		goto parse_flag;

d643 2
a644 2
	case sTCPKeepAlive:
		intptr = &options->tcp_keep_alive;
@


1.115
log
@default LoginGraceTime to 2m; 1m may be too short for slow systems.
ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.114 2002/08/21 19:38:06 stevesk Exp $");
d897 1
@


1.115.2.1
log
@Update to OpenSSH 3.6
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.116 2003/02/21 09:05:53 markus Exp $");
a896 1
	debug2("read_server_config: filename %s", filename);
@


1.115.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d13 8
a20 1
RCSID("$OpenBSD: servconf.c,v 1.127 2003/09/01 18:15:50 markus Exp $");
d69 1
d75 1
d79 7
a85 2
	options->gss_authentication=-1;
	options->gss_cleanup_creds = -1;
d107 1
a107 1
	options->use_dns = -1;
d172 2
d184 1
d191 9
a199 4
	if (options->gss_authentication == -1)
		options->gss_authentication = 0;
	if (options->gss_cleanup_creds == -1)
		options->gss_cleanup_creds = 1;
d224 2
a225 2
	if (options->use_dns == -1)
		options->use_dns = 1;
d250 2
a251 1
	sRhostsRSAAuthentication, sRSAAuthentication,
d253 8
a260 1
	sKerberosTgtPassing, sChallengeResponseAuthentication,
d269 1
a269 1
	sBanner, sUseDNS, sHostbasedAuthentication,
a271 1
	sGssAuthentication, sGssCleanupCreds,
d273 1
a273 1
	sDeprecated, sUnsupported
d291 1
a291 1
	{ "rhostsauthentication", sDeprecated },
d298 1
a298 1
#ifdef KRB5
d302 6
a307 13
#else
	{ "kerberosauthentication", sUnsupported },
	{ "kerberosorlocalpasswd", sUnsupported },
	{ "kerberosticketcleanup", sUnsupported },
#endif
	{ "kerberostgtpassing", sUnsupported },
	{ "afstokenpassing", sUnsupported },
#ifdef GSSAPI
	{ "gssapiauthentication", sGssAuthentication },
	{ "gssapicleanupcreds", sGssCleanupCreds },
#else
	{ "gssapiauthentication", sUnsupported },
	{ "gssapicleanupcreds", sUnsupported },
d341 2
a342 3
	{ "usedns", sUseDNS },
	{ "verifyreversemapping", sDeprecated },
	{ "reversemappingcheck", sDeprecated },
d584 4
d607 1
a607 1

d619 4
a622 3

	case sGssAuthentication:
		intptr = &options->gss_authentication;
d624 4
a627 3

	case sGssCleanupCreds:
		intptr = &options->gss_cleanup_creds;
d629 1
d695 2
a696 2
	case sUseDNS:
		intptr = &options->use_dns;
d872 1
a872 8
		logit("%s line %d: Deprecated option %s",
		    filename, linenum, arg);
		while (arg)
		    arg = strdelim(&cp);
		break;

	case sUnsupported:
		logit("%s line %d: Unsupported option %s",
@


1.114
log
@change LoginGraceTime default to 1 minute; ok mouring@@ markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.113 2002/07/30 17:03:55 markus Exp $");
d143 1
a143 1
		options->login_grace_time = 60;
@


1.113
log
@add PermitUserEnvironment (off by default!); from dot@@dotat.at; ok provos, deraadt
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.112 2002/06/23 09:46:51 deraadt Exp $");
d143 1
a143 1
		options->login_grace_time = 600;
@


1.112
log
@minor KNF.  things the fingers do while you read
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.111 2002/06/20 23:05:55 markus Exp $");
d90 1
d208 2
d265 1
a265 1
	sUseLogin, sAllowTcpForwarding, sCompression,
d325 1
d677 4
@


1.111
log
@allow Compression=yes/no in sshd_config
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.110 2002/05/15 21:56:38 markus Exp $");
d391 1
a391 1
	snprintf(strport, sizeof strport, "%d", port);
d407 1
a407 1
	int *intptr, value;
a408 1
	int i, n;
d726 2
a727 1
			options->allow_users[options->num_allow_users++] = xstrdup(arg);
d736 2
a737 1
			options->deny_users[options->num_deny_users++] = xstrdup(arg);
d746 2
a747 1
			options->allow_groups[options->num_allow_groups++] = xstrdup(arg);
d885 2
a887 3
	char line[1024];
	int linenum;
	int bad_options = 0;
@


1.110
log
@re-enable privsep and disable setuid for post-3.2.2
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.109 2002/05/15 21:02:52 markus Exp $");
d91 1
d209 2
d262 1
a262 1
	sUseLogin, sAllowTcpForwarding,
d323 1
d678 4
@


1.109
log
@disable privsep and enable setuid for the 3.2.2 release
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.108 2002/05/04 02:39:35 deraadt Exp $");
d234 1
a234 1
	/* Turn privilege separation _off_ by default */
d236 1
a236 1
		use_privsep = 0;
@


1.108
log
@enable privsep by default; provos ok
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.107 2002/04/22 16:16:53 markus Exp $");
d234 1
a234 1
	/* Turn privilege separation on by default */
d236 1
a236 1
		use_privsep = 1;
@


1.107
log
@do not auto-enable KerberosAuthentication; ok djm@@, provos@@, deraadt@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.106 2002/04/20 09:02:03 deraadt Exp $");
d234 1
a234 1
	/* Turn privilege separation _off_ by default */
d236 1
a236 1
		use_privsep = 0;
@


1.106
log
@No, afs requires explicit enabling
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.105 2002/03/20 19:12:24 stevesk Exp $");
d184 1
a184 1
		options->kerberos_authentication = (access(KEYFILE, R_OK) == 0);
@


1.105
log
@for unprivileged user, group do:
pw=getpwnam(SSH_PRIVSEP_USER); do_setusercontext(pw).  ok provos@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.104 2002/03/19 03:03:43 stevesk Exp $");
d196 1
a196 1
		options->afs_token_passing = k_hasafs();
@


1.105.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.109 2002/05/15 21:02:52 markus Exp $");
d184 1
a184 1
		options->kerberos_authentication = 0;
d196 1
a196 1
		options->afs_token_passing = 0;
@


1.105.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.105.2.3
log
@- create /var/empty directory before install
- enable privsep by default
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.105.2.2 2002/05/18 04:50:38 jason Exp $");
d234 1
a234 1
	/* Turn privilege separation on by default */
d236 1
a236 1
		use_privsep = 1;
@


1.105.2.4
log
@Pull in OpenSSH-3.4
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.112 2002/06/23 09:46:51 deraadt Exp $");
a90 1
	options->compression = -1;
a207 2
	if (options->compression == -1)
		options->compression = 1;
d259 1
a259 1
	sUseLogin, sAllowTcpForwarding, sCompression,
a319 1
	{ "compression", sCompression },
d387 1
a387 1
	snprintf(strport, sizeof strport, "%u", port);
d403 1
a403 1
	int *intptr, value, i, n;
d405 1
a675 4
	case sCompression:
		intptr = &options->compression;
		goto parse_flag;

d719 1
a719 2
			options->allow_users[options->num_allow_users++] =
			    xstrdup(arg);
d728 1
a728 2
			options->deny_users[options->num_deny_users++] =
			    xstrdup(arg);
d737 1
a737 2
			options->allow_groups[options->num_allow_groups++] =
			    xstrdup(arg);
d875 1
a875 1
	int linenum, bad_options = 0;
d877 2
a878 1
	FILE *f;
@


1.105.2.5
log
@Update to OpenSSH 3.5
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.115 2002/09/04 18:52:42 stevesk Exp $");
a89 1
	options->permit_user_env = -1;
d142 1
a142 1
		options->login_grace_time = 120;
a206 2
	if (options->permit_user_env == -1)
		options->permit_user_env = 0;
d262 1
a262 1
	sPermitUserEnvironment, sUseLogin, sAllowTcpForwarding, sCompression,
a321 1
	{ "permituserenvironment", sPermitUserEnvironment },
a672 4
		goto parse_flag;

	case sPermitUserEnvironment:
		intptr = &options->permit_user_env;
@


1.105.2.6
log
@Merge OpenSSH 3.6.1
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.116 2003/02/21 09:05:53 markus Exp $");
a896 1
	debug2("read_server_config: filename %s", filename);
@


1.104
log
@_PATH_PRIVSEP_CHROOT_DIR; ok provos@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.103 2002/03/18 23:52:51 stevesk Exp $");
a110 3
	options->unprivileged_user = -1;
	options->unprivileged_group = -1;

a236 4
	if (options->unprivileged_user == -1)
		options->unprivileged_user = 32767;
	if (options->unprivileged_group == -1)
		options->unprivileged_group = 32767;
d266 1
a266 1
	sUsePrivilegeSeparation, sUnprivUser, sUnprivGroup,
a339 2
	{ "unprivuser", sUnprivUser},
	{ "unprivgroup", sUnprivGroup},
a712 8

	case sUnprivUser:
		intptr = &options->unprivileged_user;
		goto parse_int;

	case sUnprivGroup:
		intptr = &options->unprivileged_group;
		goto parse_int;
@


1.103
log
@UnprivUser/UnprivGroup usable now--specify numeric user/group; ok
provos@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.102 2002/03/18 17:50:31 provos Exp $");
a112 1
	options->unprivileged_dir = NULL;
a243 2
	if (options->unprivileged_dir == NULL)
		options->unprivileged_dir = "/var/empty";
d273 1
a273 1
	sUsePrivilegeSeparation, sUnprivUser, sUnprivGroup, sUnprivDir,
a348 1
	{ "unprivdir", sUnprivDir},
a729 4

	case sUnprivDir:
		charptr = &options->unprivileged_dir;
		goto parse_filename;
@


1.102
log
@integrate privilege separated openssh; its turned off by default for now.
work done by me and markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.101 2002/02/04 12:15:25 markus Exp $");
d729 1
a729 1
		goto parse_flag;
d733 1
a733 1
		goto parse_flag;
@


1.101
log
@add SYSLOG_FACILITY_NOT_SET = -1, SYSLOG_LEVEL_NOT_SET = -1,
fixes arm/netbsd; based on patch from bjh21@@netbsd.org; ok djm@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.100 2002/01/29 14:32:03 markus Exp $");
d39 2
d110 7
d237 10
d276 1
d349 4
d722 16
@


1.100
log
@s/ReverseMappingCheck/VerifyReverseMapping/ and avoid confusion; ok stevesk@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.99 2002/01/27 14:57:46 stevesk Exp $");
d65 2
a66 2
	options->log_facility = (SyslogFacility) - 1;
	options->log_level = (LogLevel) - 1;
d161 1
a161 1
	if (options->log_facility == (SyslogFacility) (-1))
d163 1
a163 1
	if (options->log_level == (LogLevel) (-1))
d677 1
a677 1
		if (value == (SyslogFacility) - 1)
d688 1
a688 1
		if (value == (LogLevel) - 1)
@


1.99
log
@add X11UseLocalhost; ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.98 2002/01/22 02:52:41 stevesk Exp $");
d103 1
a103 1
	options->reverse_mapping_check = -1;
d213 2
a214 2
	if (options->reverse_mapping_check == -1)
		options->reverse_mapping_check = 0;
d254 1
a254 1
	sBanner, sReverseMappingCheck, sHostbasedAuthentication,
d323 2
a324 1
	{ "reversemappingcheck", sReverseMappingCheck },
d669 2
a670 2
	case sReverseMappingCheck:
		intptr = &options->reverse_mapping_check;
@


1.98
log
@typo in error message; from djast@@cs.toronto.edu
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.97 2002/01/04 18:14:16 stevesk Exp $");
d61 1
d153 2
d248 1
a248 1
	sX11Forwarding, sX11DisplayOffset,
d305 1
d639 4
@


1.97
log
@protocol 2 HostKey code default is now /etc/ssh_host_rsa_key and
/etc/ssh_host_dsa_key like we have in sshd_config.  ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.96 2002/01/04 17:59:17 stevesk Exp $");
d410 1
a410 1
			    "ListenAdress.", filename, linenum);
@


1.96
log
@remove #ifdef _PATH_XAUTH/#endif; ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.95 2001/12/19 07:18:56 deraadt Exp $");
d117 8
a124 3
			options->host_key_files[options->num_host_key_files++] = _PATH_HOST_KEY_FILE;
		if (options->protocol & SSH_PROTO_2)
			options->host_key_files[options->num_host_key_files++] = _PATH_HOST_DSA_KEY_FILE;
@


1.95
log
@basic KNF done while i was looking for something else
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.94 2001/12/06 13:30:05 markus Exp $");
a146 1
#ifdef _PATH_XAUTH
a148 1
#endif
@


1.94
log
@add -o to sshd, too. ok deraadt@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.93 2001/12/05 10:06:12 deraadt Exp $");
d183 1
a183 1
#ifdef AFS	
d210 1
a210 1
		options->client_alive_interval = 0;  
d249 1
a249 1
	sHostbasedUsesNameFromPacketOnly, sClientAliveInterval, 
d753 1
a753 1
			      filename, linenum, arg ? arg : "<NONE>");
d761 1
a761 1
			      filename, linenum);
d766 1
a766 1
			      filename, linenum);
d770 1
a770 1
				      filename, linenum, arg);
d775 1
a775 1
			      filename, linenum);
d784 1
a784 1
			      filename, linenum);
@


1.93
log
@minor KNF
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.92 2001/11/17 19:14:34 stevesk Exp $");
d379 3
a381 4
/* Reads the server configuration file. */

void
read_server_config(ServerOptions *options, const char *filename)
a382 2
	FILE *f;
	char line[1024];
d384 1
a384 2
	int linenum, *intptr, value;
	int bad_options = 0;
d388 23
a410 9
	f = fopen(filename, "r");
	if (!f) {
		perror(filename);
		exit(1);
	}
	linenum = 0;
	while (fgets(line, sizeof(line), f)) {
		linenum++;
		cp = line;
d412 8
a419 31
		/* Ignore leading whitespace */
		if (*arg == '\0')
			arg = strdelim(&cp);
		if (!arg || !*arg || *arg == '#')
			continue;
		intptr = NULL;
		charptr = NULL;
		opcode = parse_token(arg, filename, linenum);
		switch (opcode) {
		case sBadOption:
			bad_options++;
			continue;
		case sPort:
			/* ignore ports from configfile if cmdline specifies ports */
			if (options->ports_from_cmdline)
				continue;
			if (options->listen_addrs != NULL)
				fatal("%s line %d: ports must be specified before "
				    "ListenAdress.", filename, linenum);
			if (options->num_ports >= MAX_PORTS)
				fatal("%s line %d: too many ports.",
				    filename, linenum);
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: missing port number.",
				    filename, linenum);
			options->ports[options->num_ports++] = a2port(arg);
			if (options->ports[options->num_ports-1] == 0)
				fatal("%s line %d: Badly formatted port number.",
				    filename, linenum);
			break;
d421 2
a422 2
		case sServerKeyBits:
			intptr = &options->server_key_bits;
d424 8
a431 8
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: missing integer value.",
				    filename, linenum);
			value = atoi(arg);
			if (*intptr == -1)
				*intptr = value;
			break;
d433 2
a434 2
		case sLoginGraceTime:
			intptr = &options->login_grace_time;
d436 29
a464 9
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: missing time value.",
				    filename, linenum);
			if ((value = convtime(arg)) == -1)
				fatal("%s line %d: invalid time value.",
				    filename, linenum);
			if (*intptr == -1)
				*intptr = value;
d466 3
d470 8
a477 12
		case sKeyRegenerationTime:
			intptr = &options->key_regeneration_time;
			goto parse_time;

		case sListenAddress:
			arg = strdelim(&cp);
			if (!arg || *arg == '\0' || strncmp(arg, "[]", 2) == 0)
				fatal("%s line %d: missing inet addr.",
				    filename, linenum);
			if (*arg == '[') {
				if ((p = strchr(arg, ']')) == NULL)
					fatal("%s line %d: bad ipv6 inet addr usage.",
d479 1
a479 6
				arg++;
				memmove(p, p+1, strlen(p+1)+1);
			} else if (((p = strchr(arg, ':')) == NULL) ||
				    (strchr(p+1, ':') != NULL)) {
				add_listen_addr(options, arg, 0);
				break;
d481 25
a505 2
			if (*p == ':') {
				u_short port;
d507 3
a509 17
				p++;
				if (*p == '\0')
					fatal("%s line %d: bad inet addr:port usage.",
					    filename, linenum);
				else {
					*(p-1) = '\0';
					if ((port = a2port(p)) == 0)
						fatal("%s line %d: bad port number.",
						    filename, linenum);
					add_listen_addr(options, arg, port);
				}
			} else if (*p == '\0')
				add_listen_addr(options, arg, 0);
			else
				fatal("%s line %d: bad inet addr usage.",
				    filename, linenum);
			break;
d511 23
a533 18
		case sHostKeyFile:
			intptr = &options->num_host_key_files;
			if (*intptr >= MAX_HOSTKEYS)
				fatal("%s line %d: too many host keys specified (max %d).",
				    filename, linenum, MAX_HOSTKEYS);
			charptr = &options->host_key_files[*intptr];
parse_filename:
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: missing file name.",
				    filename, linenum);
			if (*charptr == NULL) {
				*charptr = tilde_expand_filename(arg, getuid());
				/* increase optional counter */
				if (intptr != NULL)
					*intptr = *intptr + 1;
			}
			break;
d535 2
a536 30
		case sPidFile:
			charptr = &options->pid_file;
			goto parse_filename;

		case sPermitRootLogin:
			intptr = &options->permit_root_login;
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: missing yes/"
				    "without-password/forced-commands-only/no "
				    "argument.", filename, linenum);
			value = 0;	/* silence compiler */
			if (strcmp(arg, "without-password") == 0)
				value = PERMIT_NO_PASSWD;
			else if (strcmp(arg, "forced-commands-only") == 0)
				value = PERMIT_FORCED_ONLY;
			else if (strcmp(arg, "yes") == 0)
				value = PERMIT_YES;
			else if (strcmp(arg, "no") == 0)
				value = PERMIT_NO;
			else
				fatal("%s line %d: Bad yes/"
				    "without-password/forced-commands-only/no "
				    "argument: %s", filename, linenum, arg);
			if (*intptr == -1)
				*intptr = value;
			break;

		case sIgnoreRhosts:
			intptr = &options->ignore_rhosts;
d538 43
a580 43
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: missing yes/no argument.",
				    filename, linenum);
			value = 0;	/* silence compiler */
			if (strcmp(arg, "yes") == 0)
				value = 1;
			else if (strcmp(arg, "no") == 0)
				value = 0;
			else
				fatal("%s line %d: Bad yes/no argument: %s",
					filename, linenum, arg);
			if (*intptr == -1)
				*intptr = value;
			break;

		case sIgnoreUserKnownHosts:
			intptr = &options->ignore_user_known_hosts;
			goto parse_flag;

		case sRhostsAuthentication:
			intptr = &options->rhosts_authentication;
			goto parse_flag;

		case sRhostsRSAAuthentication:
			intptr = &options->rhosts_rsa_authentication;
			goto parse_flag;

		case sHostbasedAuthentication:
			intptr = &options->hostbased_authentication;
			goto parse_flag;

		case sHostbasedUsesNameFromPacketOnly:
			intptr = &options->hostbased_uses_name_from_packet_only;
			goto parse_flag;

		case sRSAAuthentication:
			intptr = &options->rsa_authentication;
			goto parse_flag;

		case sPubkeyAuthentication:
			intptr = &options->pubkey_authentication;
			goto parse_flag;
d582 11
a592 11
		case sKerberosAuthentication:
			intptr = &options->kerberos_authentication;
			goto parse_flag;

		case sKerberosOrLocalPasswd:
			intptr = &options->kerberos_or_local_passwd;
			goto parse_flag;

		case sKerberosTicketCleanup:
			intptr = &options->kerberos_ticket_cleanup;
			goto parse_flag;
d595 3
a597 3
		case sKerberosTgtPassing:
			intptr = &options->kerberos_tgt_passing;
			goto parse_flag;
d600 56
a655 71
		case sAFSTokenPassing:
			intptr = &options->afs_token_passing;
			goto parse_flag;
#endif

		case sPasswordAuthentication:
			intptr = &options->password_authentication;
			goto parse_flag;

		case sKbdInteractiveAuthentication:
			intptr = &options->kbd_interactive_authentication;
			goto parse_flag;

		case sChallengeResponseAuthentication:
			intptr = &options->challenge_response_authentication;
			goto parse_flag;

		case sPrintMotd:
			intptr = &options->print_motd;
			goto parse_flag;

		case sPrintLastLog:
			intptr = &options->print_lastlog;
			goto parse_flag;

		case sX11Forwarding:
			intptr = &options->x11_forwarding;
			goto parse_flag;

		case sX11DisplayOffset:
			intptr = &options->x11_display_offset;
			goto parse_int;

		case sXAuthLocation:
			charptr = &options->xauth_location;
			goto parse_filename;

		case sStrictModes:
			intptr = &options->strict_modes;
			goto parse_flag;

		case sKeepAlives:
			intptr = &options->keepalives;
			goto parse_flag;

		case sEmptyPasswd:
			intptr = &options->permit_empty_passwd;
			goto parse_flag;

		case sUseLogin:
			intptr = &options->use_login;
			goto parse_flag;

		case sGatewayPorts:
			intptr = &options->gateway_ports;
			goto parse_flag;

		case sReverseMappingCheck:
			intptr = &options->reverse_mapping_check;
			goto parse_flag;

		case sLogFacility:
			intptr = (int *) &options->log_facility;
			arg = strdelim(&cp);
			value = log_facility_number(arg);
			if (value == (SyslogFacility) - 1)
				fatal("%.200s line %d: unsupported log facility '%s'",
				    filename, linenum, arg ? arg : "<NONE>");
			if (*intptr == -1)
				*intptr = (SyslogFacility) value;
			break;
d657 3
a659 10
		case sLogLevel:
			intptr = (int *) &options->log_level;
			arg = strdelim(&cp);
			value = log_level_number(arg);
			if (value == (LogLevel) - 1)
				fatal("%.200s line %d: unsupported log level '%s'",
				    filename, linenum, arg ? arg : "<NONE>");
			if (*intptr == -1)
				*intptr = (LogLevel) value;
			break;
d661 10
a670 12
		case sAllowTcpForwarding:
			intptr = &options->allow_tcp_forwarding;
			goto parse_flag;

		case sAllowUsers:
			while ((arg = strdelim(&cp)) && *arg != '\0') {
				if (options->num_allow_users >= MAX_ALLOW_USERS)
					fatal("%s line %d: too many allow users.",
					    filename, linenum);
				options->allow_users[options->num_allow_users++] = xstrdup(arg);
			}
			break;
d672 23
a694 8
		case sDenyUsers:
			while ((arg = strdelim(&cp)) && *arg != '\0') {
				if (options->num_deny_users >= MAX_DENY_USERS)
					fatal( "%s line %d: too many deny users.",
					    filename, linenum);
				options->deny_users[options->num_deny_users++] = xstrdup(arg);
			}
			break;
d696 8
a703 8
		case sAllowGroups:
			while ((arg = strdelim(&cp)) && *arg != '\0') {
				if (options->num_allow_groups >= MAX_ALLOW_GROUPS)
					fatal("%s line %d: too many allow groups.",
					    filename, linenum);
				options->allow_groups[options->num_allow_groups++] = xstrdup(arg);
			}
			break;
d705 8
a712 8
		case sDenyGroups:
			while ((arg = strdelim(&cp)) && *arg != '\0') {
				if (options->num_deny_groups >= MAX_DENY_GROUPS)
					fatal("%s line %d: too many deny groups.",
					    filename, linenum);
				options->deny_groups[options->num_deny_groups++] = xstrdup(arg);
			}
			break;
d714 8
a721 10
		case sCiphers:
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: Missing argument.", filename, linenum);
			if (!ciphers_valid(arg))
				fatal("%s line %d: Bad SSH2 cipher spec '%s'.",
				    filename, linenum, arg ? arg : "<NONE>");
			if (options->ciphers == NULL)
				options->ciphers = xstrdup(arg);
			break;
d723 10
a732 10
		case sMacs:
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: Missing argument.", filename, linenum);
			if (!mac_valid(arg))
				fatal("%s line %d: Bad SSH2 mac spec '%s'.",
				    filename, linenum, arg ? arg : "<NONE>");
			if (options->macs == NULL)
				options->macs = xstrdup(arg);
			break;
d734 10
a743 12
		case sProtocol:
			intptr = &options->protocol;
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: Missing argument.", filename, linenum);
			value = proto_spec(arg);
			if (value == SSH_PROTO_UNKNOWN)
				fatal("%s line %d: Bad protocol spec '%s'.",
				      filename, linenum, arg ? arg : "<NONE>");
			if (*intptr == SSH_PROTO_UNKNOWN)
				*intptr = value;
			break;
d745 34
a778 21
		case sSubsystem:
			if (options->num_subsystems >= MAX_SUBSYSTEMS) {
				fatal("%s line %d: too many subsystems defined.",
				      filename, linenum);
			}
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: Missing subsystem name.",
				      filename, linenum);
			for (i = 0; i < options->num_subsystems; i++)
				if (strcmp(arg, options->subsystem_name[i]) == 0)
					fatal("%s line %d: Subsystem '%s' already defined.",
					      filename, linenum, arg);
			options->subsystem_name[options->num_subsystems] = xstrdup(arg);
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: Missing subsystem command.",
				      filename, linenum);
			options->subsystem_command[options->num_subsystems] = xstrdup(arg);
			options->num_subsystems++;
			break;
d780 13
a792 16
		case sMaxStartups:
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: Missing MaxStartups spec.",
				      filename, linenum);
			if ((n = sscanf(arg, "%d:%d:%d",
			    &options->max_startups_begin,
			    &options->max_startups_rate,
			    &options->max_startups)) == 3) {
				if (options->max_startups_begin >
				    options->max_startups ||
				    options->max_startups_rate > 100 ||
				    options->max_startups_rate < 1)
					fatal("%s line %d: Illegal MaxStartups spec.",
					    filename, linenum);
			} else if (n != 1)
d795 49
a843 3
			else
				options->max_startups = options->max_startups_begin;
			break;
d845 7
a851 30
		case sBanner:
			charptr = &options->banner;
			goto parse_filename;
		/*
		 * These options can contain %X options expanded at
		 * connect time, so that you can specify paths like:
		 *
		 * AuthorizedKeysFile	/etc/ssh_keys/%u
		 */
		case sAuthorizedKeysFile:
		case sAuthorizedKeysFile2:
			charptr = (opcode == sAuthorizedKeysFile ) ?
			    &options->authorized_keys_file :
			    &options->authorized_keys_file2;
			goto parse_filename;

		case sClientAliveInterval:
			intptr = &options->client_alive_interval;
			goto parse_time;

		case sClientAliveCountMax:
			intptr = &options->client_alive_count_max;
			goto parse_int;

		case sDeprecated:
			log("%s line %d: Deprecated option %s",
			    filename, linenum, arg);
			while (arg)
			    arg = strdelim(&cp);
			break;
d853 11
a863 7
		default:
			fatal("%s line %d: Missing handler for opcode %s (%d)",
			    filename, linenum, arg, opcode);
		}
		if ((arg = strdelim(&cp)) != NULL && *arg != '\0')
			fatal("%s line %d: garbage at end of line; \"%.200s\".",
			    filename, linenum, arg);
@


1.92
log
@enum/int type cleanup where it made sense to do so; ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.91 2001/11/12 18:17:07 markus Exp $");
d772 1
a772 1
			if(options->num_subsystems >= MAX_SUBSYSTEMS) {
d781 1
a781 1
				if(strcmp(arg, options->subsystem_name[i]) == 0)
d842 1
a842 1
			while(arg)
@


1.91
log
@enable authorized_keys2 again. tested by fries@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.90 2001/11/11 13:02:31 markus Exp $");
d321 1
a321 1
	{ NULL, 0 }
@


1.90
log
@make AuthorizedKeysFile2 fallback to AuthorizedKeysFile if AuthorizedKeysFile is specified.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.89 2001/08/16 19:18:34 jakob Exp $");
a212 2
	if (options->authorized_keys_file == NULL)
		options->authorized_keys_file = _PATH_SSH_USER_PERMITTED_KEYS;
@


1.89
log
@deprecate CheckMail. ok markus@@
----------------------------------------------------------------------
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.88 2001/07/11 00:24:53 itojun Exp $");
d215 9
a223 2
	if (options->authorized_keys_file2 == NULL)
		options->authorized_keys_file2 = _PATH_SSH_USER_PERMITTED_KEYS2;
@


1.89.2.1
log
@Pull in patches from current (Errata 002):
Update to OpenSSH-3.0.1 via errata patch (Instead of using release tarball)
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.91 2001/11/12 18:17:07 markus Exp $");
a212 7
	if (options->authorized_keys_file2 == NULL) {
		/* authorized_keys_file2 falls back to authorized_keys_file */
		if (options->authorized_keys_file != NULL)
			options->authorized_keys_file2 = options->authorized_keys_file;
		else
			options->authorized_keys_file2 = _PATH_SSH_USER_PERMITTED_KEYS2;
	}
d215 2
@


1.89.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.101 2002/02/04 12:15:25 markus Exp $");
a60 1
	options->x11_use_localhost = -1;
d64 2
a65 2
	options->log_facility = SYSLOG_FACILITY_NOT_SET;
	options->log_level = SYSLOG_LEVEL_NOT_SET;
d102 1
a102 1
	options->verify_reverse_mapping = -1;
d117 3
a119 8
			options->host_key_files[options->num_host_key_files++] =
			    _PATH_HOST_KEY_FILE;
		if (options->protocol & SSH_PROTO_2) {
			options->host_key_files[options->num_host_key_files++] =
			    _PATH_HOST_RSA_KEY_FILE;
			options->host_key_files[options->num_host_key_files++] =
			    _PATH_HOST_DSA_KEY_FILE;
		}
d147 1
a147 2
	if (options->x11_use_localhost == -1)
		options->x11_use_localhost = 1;
d150 1
d155 1
a155 1
	if (options->log_facility == SYSLOG_FACILITY_NOT_SET)
d157 1
a157 1
	if (options->log_level == SYSLOG_LEVEL_NOT_SET)
d183 1
a183 1
#ifdef AFS
d207 2
a208 2
	if (options->verify_reverse_mapping == -1)
		options->verify_reverse_mapping = 0;
d210 1
a210 1
		options->client_alive_interval = 0;
d242 1
a242 1
	sX11Forwarding, sX11DisplayOffset, sX11UseLocalhost,
d248 2
a249 2
	sBanner, sVerifyReverseMapping, sHostbasedAuthentication,
	sHostbasedUsesNameFromPacketOnly, sClientAliveInterval,
a298 1
	{ "x11uselocalhost", sX11UseLocalhost },
d316 1
a316 2
	{ "verifyreversemapping", sVerifyReverseMapping },
	{ "reversemappingcheck", sVerifyReverseMapping },
d321 1
a321 1
	{ NULL, sBadOption }
d379 4
a382 3
int
process_server_config_line(ServerOptions *options, char *line,
    const char *filename, int linenum)
d384 2
d387 2
a388 1
	int *intptr, value;
d392 9
a400 4
	cp = line;
	arg = strdelim(&cp);
	/* Ignore leading whitespace */
	if (*arg == '\0')
d402 31
a432 27
	if (!arg || !*arg || *arg == '#')
		return 0;
	intptr = NULL;
	charptr = NULL;
	opcode = parse_token(arg, filename, linenum);
	switch (opcode) {
	case sBadOption:
		return -1;
	case sPort:
		/* ignore ports from configfile if cmdline specifies ports */
		if (options->ports_from_cmdline)
			return 0;
		if (options->listen_addrs != NULL)
			fatal("%s line %d: ports must be specified before "
			    "ListenAddress.", filename, linenum);
		if (options->num_ports >= MAX_PORTS)
			fatal("%s line %d: too many ports.",
			    filename, linenum);
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing port number.",
			    filename, linenum);
		options->ports[options->num_ports++] = a2port(arg);
		if (options->ports[options->num_ports-1] == 0)
			fatal("%s line %d: Badly formatted port number.",
			    filename, linenum);
		break;
d434 2
a435 2
	case sServerKeyBits:
		intptr = &options->server_key_bits;
d437 8
a444 8
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing integer value.",
			    filename, linenum);
		value = atoi(arg);
		if (*intptr == -1)
			*intptr = value;
		break;
d446 2
a447 2
	case sLoginGraceTime:
		intptr = &options->login_grace_time;
d449 9
a457 29
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing time value.",
			    filename, linenum);
		if ((value = convtime(arg)) == -1)
			fatal("%s line %d: invalid time value.",
			    filename, linenum);
		if (*intptr == -1)
			*intptr = value;
		break;

	case sKeyRegenerationTime:
		intptr = &options->key_regeneration_time;
		goto parse_time;

	case sListenAddress:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0' || strncmp(arg, "[]", 2) == 0)
			fatal("%s line %d: missing inet addr.",
			    filename, linenum);
		if (*arg == '[') {
			if ((p = strchr(arg, ']')) == NULL)
				fatal("%s line %d: bad ipv6 inet addr usage.",
				    filename, linenum);
			arg++;
			memmove(p, p+1, strlen(p+1)+1);
		} else if (((p = strchr(arg, ':')) == NULL) ||
			    (strchr(p+1, ':') != NULL)) {
			add_listen_addr(options, arg, 0);
a458 3
		}
		if (*p == ':') {
			u_short port;
d460 12
a471 8
			p++;
			if (*p == '\0')
				fatal("%s line %d: bad inet addr:port usage.",
				    filename, linenum);
			else {
				*(p-1) = '\0';
				if ((port = a2port(p)) == 0)
					fatal("%s line %d: bad port number.",
d473 6
a478 1
				add_listen_addr(options, arg, port);
d480 27
a506 13
		} else if (*p == '\0')
			add_listen_addr(options, arg, 0);
		else
			fatal("%s line %d: bad inet addr usage.",
			    filename, linenum);
		break;

	case sHostKeyFile:
		intptr = &options->num_host_key_files;
		if (*intptr >= MAX_HOSTKEYS)
			fatal("%s line %d: too many host keys specified (max %d).",
			    filename, linenum, MAX_HOSTKEYS);
		charptr = &options->host_key_files[*intptr];
d508 11
a518 11
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing file name.",
			    filename, linenum);
		if (*charptr == NULL) {
			*charptr = tilde_expand_filename(arg, getuid());
			/* increase optional counter */
			if (intptr != NULL)
				*intptr = *intptr + 1;
		}
		break;
d520 27
a546 3
	case sPidFile:
		charptr = &options->pid_file;
		goto parse_filename;
d548 18
a565 23
	case sPermitRootLogin:
		intptr = &options->permit_root_login;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/"
			    "without-password/forced-commands-only/no "
			    "argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "without-password") == 0)
			value = PERMIT_NO_PASSWD;
		else if (strcmp(arg, "forced-commands-only") == 0)
			value = PERMIT_FORCED_ONLY;
		else if (strcmp(arg, "yes") == 0)
			value = PERMIT_YES;
		else if (strcmp(arg, "no") == 0)
			value = PERMIT_NO;
		else
			fatal("%s line %d: Bad yes/"
			    "without-password/forced-commands-only/no "
			    "argument: %s", filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;
d567 27
a593 46
	case sIgnoreRhosts:
		intptr = &options->ignore_rhosts;
parse_flag:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/no argument.",
			    filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "yes") == 0)
			value = 1;
		else if (strcmp(arg, "no") == 0)
			value = 0;
		else
			fatal("%s line %d: Bad yes/no argument: %s",
				filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;

	case sIgnoreUserKnownHosts:
		intptr = &options->ignore_user_known_hosts;
		goto parse_flag;

	case sRhostsAuthentication:
		intptr = &options->rhosts_authentication;
		goto parse_flag;

	case sRhostsRSAAuthentication:
		intptr = &options->rhosts_rsa_authentication;
		goto parse_flag;

	case sHostbasedAuthentication:
		intptr = &options->hostbased_authentication;
		goto parse_flag;

	case sHostbasedUsesNameFromPacketOnly:
		intptr = &options->hostbased_uses_name_from_packet_only;
		goto parse_flag;

	case sRSAAuthentication:
		intptr = &options->rsa_authentication;
		goto parse_flag;

	case sPubkeyAuthentication:
		intptr = &options->pubkey_authentication;
		goto parse_flag;
d595 11
a605 11
	case sKerberosAuthentication:
		intptr = &options->kerberos_authentication;
		goto parse_flag;

	case sKerberosOrLocalPasswd:
		intptr = &options->kerberos_or_local_passwd;
		goto parse_flag;

	case sKerberosTicketCleanup:
		intptr = &options->kerberos_ticket_cleanup;
		goto parse_flag;
d608 3
a610 3
	case sKerberosTgtPassing:
		intptr = &options->kerberos_tgt_passing;
		goto parse_flag;
d613 71
a683 4
	case sAFSTokenPassing:
		intptr = &options->afs_token_passing;
		goto parse_flag;
#endif
d685 10
a694 3
	case sPasswordAuthentication:
		intptr = &options->password_authentication;
		goto parse_flag;
d696 12
a707 3
	case sKbdInteractiveAuthentication:
		intptr = &options->kbd_interactive_authentication;
		goto parse_flag;
d709 8
a716 3
	case sChallengeResponseAuthentication:
		intptr = &options->challenge_response_authentication;
		goto parse_flag;
d718 8
a725 3
	case sPrintMotd:
		intptr = &options->print_motd;
		goto parse_flag;
d727 8
a734 3
	case sPrintLastLog:
		intptr = &options->print_lastlog;
		goto parse_flag;
d736 10
a745 3
	case sX11Forwarding:
		intptr = &options->x11_forwarding;
		goto parse_flag;
d747 10
a756 3
	case sX11DisplayOffset:
		intptr = &options->x11_display_offset;
		goto parse_int;
d758 12
a769 3
	case sX11UseLocalhost:
		intptr = &options->x11_use_localhost;
		goto parse_flag;
d771 21
a791 3
	case sXAuthLocation:
		charptr = &options->xauth_location;
		goto parse_filename;
d793 17
a809 54
	case sStrictModes:
		intptr = &options->strict_modes;
		goto parse_flag;

	case sKeepAlives:
		intptr = &options->keepalives;
		goto parse_flag;

	case sEmptyPasswd:
		intptr = &options->permit_empty_passwd;
		goto parse_flag;

	case sUseLogin:
		intptr = &options->use_login;
		goto parse_flag;

	case sGatewayPorts:
		intptr = &options->gateway_ports;
		goto parse_flag;

	case sVerifyReverseMapping:
		intptr = &options->verify_reverse_mapping;
		goto parse_flag;

	case sLogFacility:
		intptr = (int *) &options->log_facility;
		arg = strdelim(&cp);
		value = log_facility_number(arg);
		if (value == SYSLOG_FACILITY_NOT_SET)
			fatal("%.200s line %d: unsupported log facility '%s'",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*intptr == -1)
			*intptr = (SyslogFacility) value;
		break;

	case sLogLevel:
		intptr = (int *) &options->log_level;
		arg = strdelim(&cp);
		value = log_level_number(arg);
		if (value == SYSLOG_LEVEL_NOT_SET)
			fatal("%.200s line %d: unsupported log level '%s'",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*intptr == -1)
			*intptr = (LogLevel) value;
		break;

	case sAllowTcpForwarding:
		intptr = &options->allow_tcp_forwarding;
		goto parse_flag;

	case sAllowUsers:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_allow_users >= MAX_ALLOW_USERS)
				fatal("%s line %d: too many allow users.",
d811 3
a813 3
			options->allow_users[options->num_allow_users++] = xstrdup(arg);
		}
		break;
d815 30
a844 8
	case sDenyUsers:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_deny_users >= MAX_DENY_USERS)
				fatal( "%s line %d: too many deny users.",
				    filename, linenum);
			options->deny_users[options->num_deny_users++] = xstrdup(arg);
		}
		break;
d846 3
a848 15
	case sAllowGroups:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_allow_groups >= MAX_ALLOW_GROUPS)
				fatal("%s line %d: too many allow groups.",
				    filename, linenum);
			options->allow_groups[options->num_allow_groups++] = xstrdup(arg);
		}
		break;

	case sDenyGroups:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_deny_groups >= MAX_DENY_GROUPS)
				fatal("%s line %d: too many deny groups.",
				    filename, linenum);
			options->deny_groups[options->num_deny_groups++] = xstrdup(arg);
d850 3
a852 143
		break;

	case sCiphers:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.", filename, linenum);
		if (!ciphers_valid(arg))
			fatal("%s line %d: Bad SSH2 cipher spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (options->ciphers == NULL)
			options->ciphers = xstrdup(arg);
		break;

	case sMacs:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.", filename, linenum);
		if (!mac_valid(arg))
			fatal("%s line %d: Bad SSH2 mac spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (options->macs == NULL)
			options->macs = xstrdup(arg);
		break;

	case sProtocol:
		intptr = &options->protocol;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.", filename, linenum);
		value = proto_spec(arg);
		if (value == SSH_PROTO_UNKNOWN)
			fatal("%s line %d: Bad protocol spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*intptr == SSH_PROTO_UNKNOWN)
			*intptr = value;
		break;

	case sSubsystem:
		if (options->num_subsystems >= MAX_SUBSYSTEMS) {
			fatal("%s line %d: too many subsystems defined.",
			    filename, linenum);
		}
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing subsystem name.",
			    filename, linenum);
		for (i = 0; i < options->num_subsystems; i++)
			if (strcmp(arg, options->subsystem_name[i]) == 0)
				fatal("%s line %d: Subsystem '%s' already defined.",
				    filename, linenum, arg);
		options->subsystem_name[options->num_subsystems] = xstrdup(arg);
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing subsystem command.",
			    filename, linenum);
		options->subsystem_command[options->num_subsystems] = xstrdup(arg);
		options->num_subsystems++;
		break;

	case sMaxStartups:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing MaxStartups spec.",
			    filename, linenum);
		if ((n = sscanf(arg, "%d:%d:%d",
		    &options->max_startups_begin,
		    &options->max_startups_rate,
		    &options->max_startups)) == 3) {
			if (options->max_startups_begin >
			    options->max_startups ||
			    options->max_startups_rate > 100 ||
			    options->max_startups_rate < 1)
				fatal("%s line %d: Illegal MaxStartups spec.",
				    filename, linenum);
		} else if (n != 1)
			fatal("%s line %d: Illegal MaxStartups spec.",
			    filename, linenum);
		else
			options->max_startups = options->max_startups_begin;
		break;

	case sBanner:
		charptr = &options->banner;
		goto parse_filename;
	/*
	 * These options can contain %X options expanded at
	 * connect time, so that you can specify paths like:
	 *
	 * AuthorizedKeysFile	/etc/ssh_keys/%u
	 */
	case sAuthorizedKeysFile:
	case sAuthorizedKeysFile2:
		charptr = (opcode == sAuthorizedKeysFile ) ?
		    &options->authorized_keys_file :
		    &options->authorized_keys_file2;
		goto parse_filename;

	case sClientAliveInterval:
		intptr = &options->client_alive_interval;
		goto parse_time;

	case sClientAliveCountMax:
		intptr = &options->client_alive_count_max;
		goto parse_int;

	case sDeprecated:
		log("%s line %d: Deprecated option %s",
		    filename, linenum, arg);
		while (arg)
		    arg = strdelim(&cp);
		break;

	default:
		fatal("%s line %d: Missing handler for opcode %s (%d)",
		    filename, linenum, arg, opcode);
	}
	if ((arg = strdelim(&cp)) != NULL && *arg != '\0')
		fatal("%s line %d: garbage at end of line; \"%.200s\".",
		    filename, linenum, arg);
	return 0;
}

/* Reads the server configuration file. */

void
read_server_config(ServerOptions *options, const char *filename)
{
	FILE *f;
	char line[1024];
	int linenum;
	int bad_options = 0;

	f = fopen(filename, "r");
	if (!f) {
		perror(filename);
		exit(1);
	}
	linenum = 0;
	while (fgets(line, sizeof(line), f)) {
		/* Update line number counter. */
		linenum++;
		if (process_server_config_line(options, line, filename, linenum) != 0)
			bad_options++;
@


1.89.2.3
log
@apply the necessary openbsd30_3.1.patch patch.
--
Ok'd by markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.89.2.2 2002/03/07 17:37:47 jason Exp $");
d821 1
a821 1
	 * AuthorizedKeysFile	/etc_keys/%u
@


1.89.2.4
log
@Update OpenSSH to version 3.2.2.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.109 2002/05/15 21:02:52 markus Exp $");
a38 2
/* Use of privilege separation or not */
extern int use_privsep;
a107 3

	/* Needs to be accessable in many places */
	use_privsep = -1;
d179 1
a179 1
		options->kerberos_authentication = 0;
d191 1
a191 1
		options->afs_token_passing = 0;
a227 4

	/* Turn privilege separation _off_ by default */
	if (use_privsep == -1)
		use_privsep = 0;
a256 1
	sUsePrivilegeSeparation,
a328 1
	{ "useprivilegeseparation", sUsePrivilegeSeparation},
a696 4
		goto parse_flag;

	case sUsePrivilegeSeparation:
		intptr = &use_privsep;
@


1.89.2.5
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.89.2.4 2002/05/17 00:03:24 miod Exp $");
a90 1
	options->compression = -1;
a207 2
	if (options->compression == -1)
		options->compression = 1;
d234 1
a234 1
	/* Turn privilege separation on by default */
d236 1
a236 1
		use_privsep = 1;
d259 1
a259 1
	sUseLogin, sAllowTcpForwarding, sCompression,
a319 1
	{ "compression", sCompression },
a673 4
		goto parse_flag;

	case sCompression:
		intptr = &options->compression;
@


1.89.2.6
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.89.2.5 2002/06/22 07:23:17 miod Exp $");
d391 1
a391 1
	snprintf(strport, sizeof strport, "%u", port);
d407 1
a407 1
	int *intptr, value, i, n;
d409 1
d727 1
a727 2
			options->allow_users[options->num_allow_users++] =
			    xstrdup(arg);
d736 1
a736 2
			options->deny_users[options->num_deny_users++] =
			    xstrdup(arg);
d745 1
a745 2
			options->allow_groups[options->num_allow_groups++] =
			    xstrdup(arg);
d883 1
a883 1
	int linenum, bad_options = 0;
d885 2
a886 1
	FILE *f;
@


1.89.2.7
log
@Update to OpenSSH 3.5
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.115 2002/09/04 18:52:42 stevesk Exp $");
a89 1
	options->permit_user_env = -1;
d142 1
a142 1
		options->login_grace_time = 120;
a206 2
	if (options->permit_user_env == -1)
		options->permit_user_env = 0;
d262 1
a262 1
	sPermitUserEnvironment, sUseLogin, sAllowTcpForwarding, sCompression,
a321 1
	{ "permituserenvironment", sPermitUserEnvironment },
a672 4
		goto parse_flag;

	case sPermitUserEnvironment:
		intptr = &options->permit_user_env;
@


1.88
log
@make it compilable in all 4 combination of KRB4/KRB5 settings.  dugsong ok

XXX isn't it sensitive to the order of -I/usr/include/kerberosIV and
-I/usr/include/kerberosV?
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.87 2001/07/08 15:23:38 stevesk Exp $");
a58 1
	options->check_mail = -1;
a138 2
	if (options->check_mail == -1)
		options->check_mail = 0;
d238 1
a238 1
	sStrictModes, sEmptyPasswd, sKeepAlives, sCheckMail,
d245 2
a246 1
	sClientAliveCountMax, sAuthorizedKeysFile, sAuthorizedKeysFile2
d286 1
a286 1
	{ "checkmail", sCheckMail },
a620 4
		case sCheckMail:
			intptr = &options->check_mail;
			goto parse_flag;

d833 7
@


1.87
log
@fix ``MaxStartups max''; ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.86 2001/06/26 17:41:49 dugsong Exp $");
d15 1
a15 1
#ifdef KRB4
@


1.86
log
@#include <kafs.h>
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.85 2001/06/26 16:15:24 dugsong Exp $");
d387 1
a387 1
	int i;
d799 1
a799 1
			if (sscanf(arg, "%d:%d:%d",
d802 1
a802 1
			    &options->max_startups) == 3) {
d807 3
d811 4
a814 5
				      filename, linenum);
				break;
			}
			intptr = &options->max_startups;
			goto parse_int;
@


1.85
log
@Kerberos v5 support for SSH1, mostly from Assar Westerlund <assar@@freebsd.org> and Bjorn Gronvall <bg@@sics.se>. markus@@ ok
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.84 2001/06/23 15:12:19 itojun Exp $");
d17 3
@


1.84
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.83 2001/06/08 15:25:40 markus Exp $");
a17 3
#ifdef AFS
#include <kafs.h>
#endif
d70 1
a70 1
#ifdef KRB4
d75 3
a78 1
	options->kerberos_tgt_passing = -1;
d171 1
a171 1
#ifdef KRB4
d178 2
a179 2
#endif /* KRB4 */
#ifdef AFS
d182 2
d186 1
a186 1
#endif /* AFS */
d225 1
a225 1
#ifdef KRB4
d228 3
d232 1
a232 1
	sKerberosTgtPassing, sAFSTokenPassing,
d270 1
a270 1
#ifdef KRB4
d275 3
a278 1
	{ "kerberostgtpassing", sKerberosTgtPassing },
d588 1
a588 2

#ifdef KRB4
d601 1
a601 2

#ifdef AFS
d605 2
a606 1

@


1.83
log
@move the path for xauth to pathnames.h
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.82 2001/05/20 17:20:35 markus Exp $");
d34 2
a35 2
void add_listen_addr(ServerOptions *options, char *addr, u_short port);
void add_one_listen_addr(ServerOptions *options, char *addr, u_short port);
d331 1
a331 1
void
d345 1
a345 1
void
@


1.82
log
@configurable authorized_keys{,2} location; originally from peter@@; ok djm@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.81 2001/05/19 19:43:57 stevesk Exp $");
d148 1
a148 1
#ifdef XAUTH_PATH
d150 2
a151 2
		options->xauth_location = XAUTH_PATH;
#endif /* XAUTH_PATH */
@


1.81
log
@sshd command-line arguments and configuration file options that
specify time may be expressed using a sequence of the form:
time[qualifier], where time is a positive integer value and qualifier
is one of the following:
    <none>,s,m,h,d,w
Examples:
    600     600 seconds (10 minutes)
    10m     10 minutes
    1h30m   1 hour 30 minutes (90 minutes)
ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.80 2001/05/18 14:13:29 markus Exp $");
d104 2
d212 4
d241 1
a241 1
	sClientAliveCountMax
d307 2
d808 12
@


1.80
log
@improved kbd-interactive support. work by per@@appgate.com and me
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.79 2001/05/03 21:43:01 stevesk Exp $");
d428 11
a438 1
			goto parse_int;
d442 1
a442 1
			goto parse_int;
d801 1
d804 2
a805 1
			goto parse_int;
d809 1
@


1.79
log
@remove "\n" from fatal()
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.78 2001/04/15 21:28:35 stevesk Exp $");
d84 1
a84 1
	options->challenge_reponse_authentication = -1;
d188 2
a189 2
	if (options->challenge_reponse_authentication == -1)
		options->challenge_reponse_authentication = 1;
d602 1
a602 1
			intptr = &options->challenge_reponse_authentication;
@


1.78
log
@use fatal() or error() vs. fprintf(); ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.77 2001/04/13 22:46:53 beck Exp $");
d400 1
a400 1
				    "ListenAdress.\n", filename, linenum);
@


1.78.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.89 2001/08/16 19:18:34 jakob Exp $");
d15 1
a15 1
#if defined(KRB4) || defined(KRB5)
d34 2
a35 2
static void add_listen_addr(ServerOptions *, char *, u_short);
static void add_one_listen_addr(ServerOptions *, char *, u_short);
d59 1
d73 1
a73 1
#if defined(KRB4) || defined(KRB5)
d78 1
a78 1
#if defined(AFS) || defined(KRB5)
a79 2
#endif
#ifdef AFS
d84 1
a84 1
	options->challenge_response_authentication = -1;
a103 2
	options->authorized_keys_file = NULL;
	options->authorized_keys_file2 = NULL;
d136 2
d146 1
a146 1
#ifdef _PATH_XAUTH
d148 2
a149 2
		options->xauth_location = _PATH_XAUTH;
#endif
d170 1
a170 1
#if defined(KRB4) || defined(KRB5)
d177 2
a178 2
#endif
#if defined(AFS) || defined(KRB5)
a180 2
#endif
#ifdef AFS	
d183 1
a183 1
#endif
d188 2
a189 2
	if (options->challenge_response_authentication == -1)
		options->challenge_response_authentication = 1;
a209 4
	if (options->authorized_keys_file == NULL)
		options->authorized_keys_file = _PATH_SSH_USER_PERMITTED_KEYS;
	if (options->authorized_keys_file2 == NULL)
		options->authorized_keys_file2 = _PATH_SSH_USER_PERMITTED_KEYS2;
d218 1
a218 1
#if defined(KRB4) || defined(KRB5)
a220 3
#if defined(AFS) || defined(KRB5)
	sKerberosTgtPassing,
#endif
d222 1
a222 1
	sAFSTokenPassing,
d228 1
a228 1
	sStrictModes, sEmptyPasswd, sKeepAlives,
d235 1
a235 2
	sClientAliveCountMax, sAuthorizedKeysFile, sAuthorizedKeysFile2,
	sDeprecated
d260 1
a260 1
#if defined(KRB4) || defined(KRB5)
d265 1
a265 1
#if defined(AFS) || defined(KRB5)
a266 2
#endif
#ifdef AFS
d273 1
a273 1
	{ "checkmail", sDeprecated },
a300 2
	{ "authorizedkeysfile", sAuthorizedKeysFile },
	{ "authorizedkeysfile2", sAuthorizedKeysFile2 },
d323 1
a323 1
static void
d337 1
a337 1
static void
d370 1
a370 1
	int i, n;
d400 1
a400 1
				    "ListenAdress.", filename, linenum);
d428 1
a428 11
parse_time:
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: missing time value.",
				    filename, linenum);
			if ((value = convtime(arg)) == -1)
				fatal("%s line %d: invalid time value.",
				    filename, linenum);
			if (*intptr == -1)
				*intptr = value;
			break;
d432 1
a432 1
			goto parse_time;
d564 2
a565 1
#if defined(KRB4) || defined(KRB5)
d578 2
a579 1
#if defined(AFS) || defined(KRB5)
d583 1
a583 2
#endif
#ifdef AFS
d597 4
d602 1
a602 1
			intptr = &options->challenge_response_authentication;
d773 1
a773 1
			if ((n = sscanf(arg, "%d:%d:%d",
d776 1
a776 1
			    &options->max_startups)) == 3) {
a780 3
					fatal("%s line %d: Illegal MaxStartups spec.",
					    filename, linenum);
			} else if (n != 1)
d782 5
a786 4
				    filename, linenum);
			else
				options->max_startups = options->max_startups_begin;
			break;
a790 13
		/*
		 * These options can contain %X options expanded at
		 * connect time, so that you can specify paths like:
		 *
		 * AuthorizedKeysFile	/etc/ssh_keys/%u
		 */
		case sAuthorizedKeysFile:
		case sAuthorizedKeysFile2:
			charptr = (opcode == sAuthorizedKeysFile ) ?
			    &options->authorized_keys_file :
			    &options->authorized_keys_file2;
			goto parse_filename;

d793 1
a793 2
			goto parse_time;

a796 8

		case sDeprecated:
			log("%s line %d: Deprecated option %s",
			    filename, linenum, arg);
			while(arg)
			    arg = strdelim(&cp);
			break;

@


1.78.2.2
log
@Merge OpenSSH 3.0.1.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.78.2.1 2001/09/27 19:03:55 jason Exp $");
a212 7
	if (options->authorized_keys_file2 == NULL) {
		/* authorized_keys_file2 falls back to authorized_keys_file */
		if (options->authorized_keys_file != NULL)
			options->authorized_keys_file2 = options->authorized_keys_file;
		else
			options->authorized_keys_file2 = _PATH_SSH_USER_PERMITTED_KEYS2;
	}
d215 2
@


1.78.2.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.101 2002/02/04 12:15:25 markus Exp $");
a60 1
	options->x11_use_localhost = -1;
d64 2
a65 2
	options->log_facility = SYSLOG_FACILITY_NOT_SET;
	options->log_level = SYSLOG_LEVEL_NOT_SET;
d102 1
a102 1
	options->verify_reverse_mapping = -1;
d117 3
a119 8
			options->host_key_files[options->num_host_key_files++] =
			    _PATH_HOST_KEY_FILE;
		if (options->protocol & SSH_PROTO_2) {
			options->host_key_files[options->num_host_key_files++] =
			    _PATH_HOST_RSA_KEY_FILE;
			options->host_key_files[options->num_host_key_files++] =
			    _PATH_HOST_DSA_KEY_FILE;
		}
d147 1
a147 2
	if (options->x11_use_localhost == -1)
		options->x11_use_localhost = 1;
d150 1
d155 1
a155 1
	if (options->log_facility == SYSLOG_FACILITY_NOT_SET)
d157 1
a157 1
	if (options->log_level == SYSLOG_LEVEL_NOT_SET)
d183 1
a183 1
#ifdef AFS
d207 2
a208 2
	if (options->verify_reverse_mapping == -1)
		options->verify_reverse_mapping = 0;
d210 1
a210 1
		options->client_alive_interval = 0;
d242 1
a242 1
	sX11Forwarding, sX11DisplayOffset, sX11UseLocalhost,
d248 2
a249 2
	sBanner, sVerifyReverseMapping, sHostbasedAuthentication,
	sHostbasedUsesNameFromPacketOnly, sClientAliveInterval,
a298 1
	{ "x11uselocalhost", sX11UseLocalhost },
d316 1
a316 2
	{ "verifyreversemapping", sVerifyReverseMapping },
	{ "reversemappingcheck", sVerifyReverseMapping },
d321 1
a321 1
	{ NULL, sBadOption }
d379 4
a382 3
int
process_server_config_line(ServerOptions *options, char *line,
    const char *filename, int linenum)
d384 2
d387 2
a388 1
	int *intptr, value;
d392 9
a400 4
	cp = line;
	arg = strdelim(&cp);
	/* Ignore leading whitespace */
	if (*arg == '\0')
d402 31
a432 27
	if (!arg || !*arg || *arg == '#')
		return 0;
	intptr = NULL;
	charptr = NULL;
	opcode = parse_token(arg, filename, linenum);
	switch (opcode) {
	case sBadOption:
		return -1;
	case sPort:
		/* ignore ports from configfile if cmdline specifies ports */
		if (options->ports_from_cmdline)
			return 0;
		if (options->listen_addrs != NULL)
			fatal("%s line %d: ports must be specified before "
			    "ListenAddress.", filename, linenum);
		if (options->num_ports >= MAX_PORTS)
			fatal("%s line %d: too many ports.",
			    filename, linenum);
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing port number.",
			    filename, linenum);
		options->ports[options->num_ports++] = a2port(arg);
		if (options->ports[options->num_ports-1] == 0)
			fatal("%s line %d: Badly formatted port number.",
			    filename, linenum);
		break;
d434 2
a435 2
	case sServerKeyBits:
		intptr = &options->server_key_bits;
d437 8
a444 8
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing integer value.",
			    filename, linenum);
		value = atoi(arg);
		if (*intptr == -1)
			*intptr = value;
		break;
d446 2
a447 2
	case sLoginGraceTime:
		intptr = &options->login_grace_time;
d449 9
a457 29
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing time value.",
			    filename, linenum);
		if ((value = convtime(arg)) == -1)
			fatal("%s line %d: invalid time value.",
			    filename, linenum);
		if (*intptr == -1)
			*intptr = value;
		break;

	case sKeyRegenerationTime:
		intptr = &options->key_regeneration_time;
		goto parse_time;

	case sListenAddress:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0' || strncmp(arg, "[]", 2) == 0)
			fatal("%s line %d: missing inet addr.",
			    filename, linenum);
		if (*arg == '[') {
			if ((p = strchr(arg, ']')) == NULL)
				fatal("%s line %d: bad ipv6 inet addr usage.",
				    filename, linenum);
			arg++;
			memmove(p, p+1, strlen(p+1)+1);
		} else if (((p = strchr(arg, ':')) == NULL) ||
			    (strchr(p+1, ':') != NULL)) {
			add_listen_addr(options, arg, 0);
a458 3
		}
		if (*p == ':') {
			u_short port;
d460 12
a471 8
			p++;
			if (*p == '\0')
				fatal("%s line %d: bad inet addr:port usage.",
				    filename, linenum);
			else {
				*(p-1) = '\0';
				if ((port = a2port(p)) == 0)
					fatal("%s line %d: bad port number.",
d473 6
a478 1
				add_listen_addr(options, arg, port);
d480 27
a506 13
		} else if (*p == '\0')
			add_listen_addr(options, arg, 0);
		else
			fatal("%s line %d: bad inet addr usage.",
			    filename, linenum);
		break;

	case sHostKeyFile:
		intptr = &options->num_host_key_files;
		if (*intptr >= MAX_HOSTKEYS)
			fatal("%s line %d: too many host keys specified (max %d).",
			    filename, linenum, MAX_HOSTKEYS);
		charptr = &options->host_key_files[*intptr];
d508 11
a518 11
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing file name.",
			    filename, linenum);
		if (*charptr == NULL) {
			*charptr = tilde_expand_filename(arg, getuid());
			/* increase optional counter */
			if (intptr != NULL)
				*intptr = *intptr + 1;
		}
		break;
d520 27
a546 3
	case sPidFile:
		charptr = &options->pid_file;
		goto parse_filename;
d548 18
a565 23
	case sPermitRootLogin:
		intptr = &options->permit_root_login;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/"
			    "without-password/forced-commands-only/no "
			    "argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "without-password") == 0)
			value = PERMIT_NO_PASSWD;
		else if (strcmp(arg, "forced-commands-only") == 0)
			value = PERMIT_FORCED_ONLY;
		else if (strcmp(arg, "yes") == 0)
			value = PERMIT_YES;
		else if (strcmp(arg, "no") == 0)
			value = PERMIT_NO;
		else
			fatal("%s line %d: Bad yes/"
			    "without-password/forced-commands-only/no "
			    "argument: %s", filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;
d567 27
a593 46
	case sIgnoreRhosts:
		intptr = &options->ignore_rhosts;
parse_flag:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/no argument.",
			    filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "yes") == 0)
			value = 1;
		else if (strcmp(arg, "no") == 0)
			value = 0;
		else
			fatal("%s line %d: Bad yes/no argument: %s",
				filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;

	case sIgnoreUserKnownHosts:
		intptr = &options->ignore_user_known_hosts;
		goto parse_flag;

	case sRhostsAuthentication:
		intptr = &options->rhosts_authentication;
		goto parse_flag;

	case sRhostsRSAAuthentication:
		intptr = &options->rhosts_rsa_authentication;
		goto parse_flag;

	case sHostbasedAuthentication:
		intptr = &options->hostbased_authentication;
		goto parse_flag;

	case sHostbasedUsesNameFromPacketOnly:
		intptr = &options->hostbased_uses_name_from_packet_only;
		goto parse_flag;

	case sRSAAuthentication:
		intptr = &options->rsa_authentication;
		goto parse_flag;

	case sPubkeyAuthentication:
		intptr = &options->pubkey_authentication;
		goto parse_flag;
d595 11
a605 11
	case sKerberosAuthentication:
		intptr = &options->kerberos_authentication;
		goto parse_flag;

	case sKerberosOrLocalPasswd:
		intptr = &options->kerberos_or_local_passwd;
		goto parse_flag;

	case sKerberosTicketCleanup:
		intptr = &options->kerberos_ticket_cleanup;
		goto parse_flag;
d608 3
a610 3
	case sKerberosTgtPassing:
		intptr = &options->kerberos_tgt_passing;
		goto parse_flag;
d613 71
a683 4
	case sAFSTokenPassing:
		intptr = &options->afs_token_passing;
		goto parse_flag;
#endif
d685 10
a694 3
	case sPasswordAuthentication:
		intptr = &options->password_authentication;
		goto parse_flag;
d696 12
a707 3
	case sKbdInteractiveAuthentication:
		intptr = &options->kbd_interactive_authentication;
		goto parse_flag;
d709 8
a716 3
	case sChallengeResponseAuthentication:
		intptr = &options->challenge_response_authentication;
		goto parse_flag;
d718 8
a725 3
	case sPrintMotd:
		intptr = &options->print_motd;
		goto parse_flag;
d727 8
a734 3
	case sPrintLastLog:
		intptr = &options->print_lastlog;
		goto parse_flag;
d736 10
a745 3
	case sX11Forwarding:
		intptr = &options->x11_forwarding;
		goto parse_flag;
d747 10
a756 3
	case sX11DisplayOffset:
		intptr = &options->x11_display_offset;
		goto parse_int;
d758 12
a769 3
	case sX11UseLocalhost:
		intptr = &options->x11_use_localhost;
		goto parse_flag;
d771 21
a791 3
	case sXAuthLocation:
		charptr = &options->xauth_location;
		goto parse_filename;
d793 17
a809 54
	case sStrictModes:
		intptr = &options->strict_modes;
		goto parse_flag;

	case sKeepAlives:
		intptr = &options->keepalives;
		goto parse_flag;

	case sEmptyPasswd:
		intptr = &options->permit_empty_passwd;
		goto parse_flag;

	case sUseLogin:
		intptr = &options->use_login;
		goto parse_flag;

	case sGatewayPorts:
		intptr = &options->gateway_ports;
		goto parse_flag;

	case sVerifyReverseMapping:
		intptr = &options->verify_reverse_mapping;
		goto parse_flag;

	case sLogFacility:
		intptr = (int *) &options->log_facility;
		arg = strdelim(&cp);
		value = log_facility_number(arg);
		if (value == SYSLOG_FACILITY_NOT_SET)
			fatal("%.200s line %d: unsupported log facility '%s'",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*intptr == -1)
			*intptr = (SyslogFacility) value;
		break;

	case sLogLevel:
		intptr = (int *) &options->log_level;
		arg = strdelim(&cp);
		value = log_level_number(arg);
		if (value == SYSLOG_LEVEL_NOT_SET)
			fatal("%.200s line %d: unsupported log level '%s'",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*intptr == -1)
			*intptr = (LogLevel) value;
		break;

	case sAllowTcpForwarding:
		intptr = &options->allow_tcp_forwarding;
		goto parse_flag;

	case sAllowUsers:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_allow_users >= MAX_ALLOW_USERS)
				fatal("%s line %d: too many allow users.",
d811 3
a813 3
			options->allow_users[options->num_allow_users++] = xstrdup(arg);
		}
		break;
d815 30
a844 8
	case sDenyUsers:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_deny_users >= MAX_DENY_USERS)
				fatal( "%s line %d: too many deny users.",
				    filename, linenum);
			options->deny_users[options->num_deny_users++] = xstrdup(arg);
		}
		break;
d846 3
a848 15
	case sAllowGroups:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_allow_groups >= MAX_ALLOW_GROUPS)
				fatal("%s line %d: too many allow groups.",
				    filename, linenum);
			options->allow_groups[options->num_allow_groups++] = xstrdup(arg);
		}
		break;

	case sDenyGroups:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_deny_groups >= MAX_DENY_GROUPS)
				fatal("%s line %d: too many deny groups.",
				    filename, linenum);
			options->deny_groups[options->num_deny_groups++] = xstrdup(arg);
d850 3
a852 143
		break;

	case sCiphers:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.", filename, linenum);
		if (!ciphers_valid(arg))
			fatal("%s line %d: Bad SSH2 cipher spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (options->ciphers == NULL)
			options->ciphers = xstrdup(arg);
		break;

	case sMacs:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.", filename, linenum);
		if (!mac_valid(arg))
			fatal("%s line %d: Bad SSH2 mac spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (options->macs == NULL)
			options->macs = xstrdup(arg);
		break;

	case sProtocol:
		intptr = &options->protocol;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.", filename, linenum);
		value = proto_spec(arg);
		if (value == SSH_PROTO_UNKNOWN)
			fatal("%s line %d: Bad protocol spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*intptr == SSH_PROTO_UNKNOWN)
			*intptr = value;
		break;

	case sSubsystem:
		if (options->num_subsystems >= MAX_SUBSYSTEMS) {
			fatal("%s line %d: too many subsystems defined.",
			    filename, linenum);
		}
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing subsystem name.",
			    filename, linenum);
		for (i = 0; i < options->num_subsystems; i++)
			if (strcmp(arg, options->subsystem_name[i]) == 0)
				fatal("%s line %d: Subsystem '%s' already defined.",
				    filename, linenum, arg);
		options->subsystem_name[options->num_subsystems] = xstrdup(arg);
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing subsystem command.",
			    filename, linenum);
		options->subsystem_command[options->num_subsystems] = xstrdup(arg);
		options->num_subsystems++;
		break;

	case sMaxStartups:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing MaxStartups spec.",
			    filename, linenum);
		if ((n = sscanf(arg, "%d:%d:%d",
		    &options->max_startups_begin,
		    &options->max_startups_rate,
		    &options->max_startups)) == 3) {
			if (options->max_startups_begin >
			    options->max_startups ||
			    options->max_startups_rate > 100 ||
			    options->max_startups_rate < 1)
				fatal("%s line %d: Illegal MaxStartups spec.",
				    filename, linenum);
		} else if (n != 1)
			fatal("%s line %d: Illegal MaxStartups spec.",
			    filename, linenum);
		else
			options->max_startups = options->max_startups_begin;
		break;

	case sBanner:
		charptr = &options->banner;
		goto parse_filename;
	/*
	 * These options can contain %X options expanded at
	 * connect time, so that you can specify paths like:
	 *
	 * AuthorizedKeysFile	/etc_keys/%u
	 */
	case sAuthorizedKeysFile:
	case sAuthorizedKeysFile2:
		charptr = (opcode == sAuthorizedKeysFile ) ?
		    &options->authorized_keys_file :
		    &options->authorized_keys_file2;
		goto parse_filename;

	case sClientAliveInterval:
		intptr = &options->client_alive_interval;
		goto parse_time;

	case sClientAliveCountMax:
		intptr = &options->client_alive_count_max;
		goto parse_int;

	case sDeprecated:
		log("%s line %d: Deprecated option %s",
		    filename, linenum, arg);
		while (arg)
		    arg = strdelim(&cp);
		break;

	default:
		fatal("%s line %d: Missing handler for opcode %s (%d)",
		    filename, linenum, arg, opcode);
	}
	if ((arg = strdelim(&cp)) != NULL && *arg != '\0')
		fatal("%s line %d: garbage at end of line; \"%.200s\".",
		    filename, linenum, arg);
	return 0;
}

/* Reads the server configuration file. */

void
read_server_config(ServerOptions *options, const char *filename)
{
	FILE *f;
	char line[1024];
	int linenum;
	int bad_options = 0;

	f = fopen(filename, "r");
	if (!f) {
		perror(filename);
		exit(1);
	}
	linenum = 0;
	while (fgets(line, sizeof(line), f)) {
		/* Update line number counter. */
		linenum++;
		if (process_server_config_line(options, line, filename, linenum) != 0)
			bad_options++;
@


1.78.2.4
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.109 2002/05/15 21:02:52 markus Exp $");
a38 2
/* Use of privilege separation or not */
extern int use_privsep;
a107 3

	/* Needs to be accessable in many places */
	use_privsep = -1;
d179 1
a179 1
		options->kerberos_authentication = 0;
d191 1
a191 1
		options->afs_token_passing = 0;
a227 4

	/* Turn privilege separation _off_ by default */
	if (use_privsep == -1)
		use_privsep = 0;
a256 1
	sUsePrivilegeSeparation,
a328 1
	{ "useprivilegeseparation", sUsePrivilegeSeparation},
a696 4
		goto parse_flag;

	case sUsePrivilegeSeparation:
		intptr = &use_privsep;
@


1.77
log
@Add options ClientAliveInterval and ClientAliveCountMax to sshd.
This gives the ability to do a "keepalive" via the encrypted channel
which can't be spoofed (unlike TCP keepalives). Useful for when you want
to use ssh connections to authenticate people for something, and know
relatively quickly when they are no longer authenticated. Disabled
by default (of course). ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.76 2001/04/12 20:09:37 stevesk Exp $");
d318 2
a319 2
	fprintf(stderr, "%s: line %d: Bad configuration option: %s\n",
		filename, linenum, cp);
d418 3
a420 5
			if (!arg || *arg == '\0') {
				fprintf(stderr, "%s line %d: missing integer value.\n",
					filename, linenum);
				exit(1);
			}
d473 2
a474 3
			if (*intptr >= MAX_HOSTKEYS) {
				fprintf(stderr,
				    "%s line %d: too many host keys specified (max %d).\n",
a475 2
				exit(1);
			}
d479 2
a480 2
			if (!arg || *arg == '\0') {
				fprintf(stderr, "%s line %d: missing file name.\n",
a481 2
				exit(1);
			}
d497 2
a498 2
			if (!arg || *arg == '\0') {
				fprintf(stderr, "%s line %d: missing yes/"
d500 2
a501 3
				    "argument.\n", filename, linenum);
				exit(1);
			}
d510 2
a511 2
			else {
				fprintf(stderr, "%s line %d: Bad yes/"
d513 1
a513 3
				    "argument: %s\n", filename, linenum, arg);
				exit(1);
			}
d522 4
a525 5
			if (!arg || *arg == '\0') {
				fprintf(stderr, "%s line %d: missing yes/no argument.\n",
					filename, linenum);
				exit(1);
			}
d530 2
a531 2
			else {
				fprintf(stderr, "%s line %d: Bad yes/no argument: %s\n",
a532 2
				exit(1);
			}
d798 2
a799 9
			fprintf(stderr, "%s line %d: Missing handler for opcode %s (%d)\n",
				filename, linenum, arg, opcode);
			exit(1);
		}
		if ((arg = strdelim(&cp)) != NULL && *arg != '\0') {
			fprintf(stderr,
				"%s line %d: garbage at end of line; \"%.200s\".\n",
				filename, linenum, arg);
			exit(1);
d801 3
d806 3
a808 5
	if (bad_options > 0) {
		fprintf(stderr, "%s: terminating, %d bad configuration options\n",
			filename, bad_options);
		exit(1);
	}
@


1.76
log
@robust port validation; ok markus@@ jakob@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.75 2001/04/12 19:15:25 markus Exp $");
d102 2
d206 4
d234 2
a235 1
	sHostbasedUsesNameFromPacketOnly
d299 2
d804 6
a809 1

@


1.75
log
@implement HostbasedAuthentication (= RhostRSAAuthentication for ssh v2)
similar to RhostRSAAuthentication unless you enable (the experimental)
HostbasedUsesNameFromPacketOnly option.  please test. :)
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.74 2001/04/06 22:25:25 stevesk Exp $");
d34 1
a34 2
/* add listen address */
void add_listen_addr(ServerOptions *options, char *addr, char *port);
d119 1
a119 1
		add_listen_addr(options, NULL, NULL);
a313 3
/*
 * add listen address
 */
d315 1
a315 1
add_listen_addr(ServerOptions *options, char *addr, char *port)
d321 1
a321 1
	if (port == NULL)
d325 1
a325 1
		add_one_listen_addr(options, addr, atoi(port));
d399 4
a402 1
			options->ports[options->num_ports++] = atoi(arg);
d440 1
a440 1
				add_listen_addr(options, arg, NULL);
d444 2
d452 4
a455 1
					add_listen_addr(options, arg, p);
d458 1
a458 1
				add_listen_addr(options, arg, NULL);
@


1.74
log
@in addition to:
ListenAddress host|ipv4_addr|ipv6_addr
permit:
ListenAddress [host|ipv4_addr|ipv6_addr]:port
ListenAddress host|ipv4_addr:port
sshd.8 updates coming.  ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.73 2001/04/02 14:20:23 stevesk Exp $");
d70 2
d161 4
d228 2
a229 1
	sBanner, sReverseMappingCheck
d249 2
d547 8
@


1.73
log
@correct comment; ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.72 2001/03/25 13:16:10 stevesk Exp $");
d35 2
a36 1
void add_listen_addr(ServerOptions *options, char *addr);
d118 1
a118 1
		add_listen_addr(options, NULL);
d310 15
a324 1
add_listen_addr(ServerOptions *options, char *addr)
a328 1
	int i;
d330 13
a342 17
	if (options->num_ports == 0)
		options->ports[options->num_ports++] = SSH_DEFAULT_PORT;
	for (i = 0; i < options->num_ports; i++) {
		memset(&hints, 0, sizeof(hints));
		hints.ai_family = IPv4or6;
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_flags = (addr == NULL) ? AI_PASSIVE : 0;
		snprintf(strport, sizeof strport, "%d", options->ports[i]);
		if ((gaierr = getaddrinfo(addr, strport, &hints, &aitop)) != 0)
			fatal("bad addr or host: %s (%s)",
			    addr ? addr : "<NULL>",
			    gai_strerror(gaierr));
		for (ai = aitop; ai->ai_next; ai = ai->ai_next)
			;
		ai->ai_next = options->listen_addrs;
		options->listen_addrs = aitop;
	}
d352 1
a352 1
	char *cp, **charptr, *arg;
d421 1
a421 1
			if (!arg || *arg == '\0')
d424 25
a448 1
			add_listen_addr(options, arg);
@


1.72
log
@PrintLastLog option; from chip@@valinux.com with some minor
changes by me.  ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.71 2001/03/05 15:44:51 stevesk Exp $");
d287 1
a287 2
 * Returns the number of the token pointed to by cp of length len. Never
 * returns if the token is not known.
@


1.71
log
@sync error message; ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.70 2001/03/04 17:42:28 millert Exp $");
d58 1
d136 2
d214 2
a215 1
	sPrintMotd, sIgnoreRhosts, sX11Forwarding, sX11DisplayOffset,
d260 1
d557 4
@


1.70
log
@log functions should not be passed strings that end in newline as they
get passed on to syslog() and when logging to stderr, do_log() appends
its own newline.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.69 2001/03/04 11:16:06 stevesk Exp $");
d445 3
a447 2
				fprintf(stderr, "%s line %d: missing yes/without-password/no argument.\n",
					filename, linenum);
@


1.69
log
@kill obsolete RandomSeed; ok markus@@ deraadt@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.68 2001/02/22 04:29:37 deraadt Exp $");
d321 1
a321 1
			fatal("bad addr or host: %s (%s)\n",
d374 1
a374 1
				fatal("%s line %d: too many ports.\n",
d378 1
a378 1
				fatal("%s line %d: missing port number.\n",
d408 1
a408 1
				fatal("%s line %d: missing inet addr.\n",
d594 1
a594 1
				fatal("%.200s line %d: unsupported log facility '%s'\n",
d605 1
a605 1
				fatal("%.200s line %d: unsupported log level '%s'\n",
d618 1
a618 1
					fatal("%s line %d: too many allow users.\n",
d627 1
a627 1
					fatal( "%s line %d: too many deny users.\n",
d636 1
a636 1
					fatal("%s line %d: too many allow groups.\n",
d645 1
a645 1
					fatal("%s line %d: too many deny groups.\n",
@


1.68
log
@grammar; slade@@shore.net
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.67 2001/02/12 16:16:23 markus Exp $");
d212 1
a212 1
	sStrictModes, sEmptyPasswd, sRandomSeedFile, sKeepAlives, sCheckMail,
a263 1
	{ "randomseed", sRandomSeedFile },
a439 6

		case sRandomSeedFile:
			fprintf(stderr, "%s line %d: \"randomseed\" option is obsolete.\n",
				filename, linenum);
			arg = strdelim(&cp);
			break;
@


1.67
log
@PermitRootLogin={yes,without-password,forced-commands-only,no}
(before this change, root could login even if PermitRootLogin==no)
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.66 2001/02/11 12:59:25 markus Exp $");
d417 2
a418 1
				fprintf(stderr, "%s line %d: to many host keys specified (max %d).\n",
@


1.66
log
@1) clean up the MAC support for SSH-2
2) allow you to specify the MAC with 'ssh -m'
3) or the 'MACs' keyword in ssh(d)_config
4) add hmac-{md5,sha1}-96
	ok stevesk@@, provos@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.65 2001/02/04 15:32:24 stevesk Exp $");
d54 1
a54 1
	options->permit_root_login = -1;
d125 2
a126 2
	if (options->permit_root_login == -1)
		options->permit_root_login = 1;			/* yes */
d456 3
a458 1
				value = 2;
d460 1
a460 1
				value = 1;
d462 1
a462 1
				value = 0;
d464 3
a466 2
				fprintf(stderr, "%s line %d: Bad yes/without-password/no argument: %s\n",
					filename, linenum, arg);
@


1.65
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.64 2001/02/03 10:08:37 markus Exp $");
d31 2
d90 1
d215 1
a215 1
	sIgnoreUserKnownHosts, sCiphers, sProtocol, sPidFile,
d272 1
d663 11
@


1.64
log
@make ReverseMappingCheck optional in sshd_config; ok djm@@,dugsong@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.63 2001/01/22 23:06:39 markus Exp $");
d225 1
a225 1
 	{ "pidfile", sPidFile },
d563 1
a563 1
			
d719 1
a719 1
			
d726 1
a726 1
			fprintf(stderr, 
@


1.63
log
@rename skey -> challenge response.
auto-enable kbd-interactive for ssh2 if challenge-reponse is enabled.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.62 2001/01/21 19:05:55 markus Exp $");
d95 1
d190 2
d214 1
a214 1
	sBanner
d274 1
d582 4
@


1.62
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.61 2001/01/20 23:00:56 djm Exp $");
d79 1
a79 1
	options->skey_authentication = -1;
d173 2
a174 2
	if (options->skey_authentication == -1)
		options->skey_authentication = 1;
d203 1
a203 1
	sSkeyAuthentication,
d245 2
a246 1
	{ "skeyauthentication", sSkeyAuthentication },
d540 2
a541 2
		case sSkeyAuthentication:
			intptr = &options->skey_authentication;
@


1.61
log
@Check for NULL return from strdelim; ok markus
@
text
@d13 8
a20 1
RCSID("$OpenBSD: servconf.c,v 1.60 2001/01/19 15:55:11 markus Exp $");
d23 1
d28 3
d35 3
a298 1
	extern int IPv4or6;
@


1.60
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.59 2001/01/19 12:45:26 markus Exp $");
d336 1
a336 1
		if (!*arg || *arg == '#')
@


1.59
log
@only auth-chall.c needs #ifdef SKEY
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.58 2001/01/18 16:20:22 markus Exp $");
d19 1
d91 1
a91 1
			options->host_key_files[options->num_host_key_files++] = HOST_KEY_FILE;
d93 1
a93 1
			options->host_key_files[options->num_host_key_files++] = HOST_DSA_KEY_FILE;
d100 1
a100 1
		options->pid_file = SSH_DAEMON_PID_FILE;
@


1.58
log
@log() is at pri=LOG_INFO, since LOG_NOTICE goes to /dev/console on many systems
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.57 2001/01/08 22:29:05 markus Exp $");
a63 1
#ifdef SKEY
a64 1
#endif
a157 1
#ifdef SKEY
a159 1
#endif
a187 1
#ifdef SKEY
a188 1
#endif
a229 1
#ifdef SKEY
a230 1
#endif
a524 1
#ifdef SKEY
a527 1
#endif
@


1.57
log
@implement option 'Banner /etc/issue.net' for ssh2, move version to
2.3.1 (needed for bugcompat detection, 2.3.0 would fail if Banner
is enabled).
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.56 2001/01/07 11:28:06 markus Exp $");
d133 1
a133 1
		options->log_level = SYSLOG_LEVEL_NOTICE;
@


1.56
log
@rename SYSLOG_LEVEL_INFO->SYSLOG_LEVEL_NOTICE
syslog priority changes:
	fatal() LOG_ERR  -> LOG_CRIT
	log()   LOG_INFO -> LOG_NOTICE
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.55 2000/12/19 23:17:57 markus Exp $");
d81 1
d202 1
d262 1
d703 4
@


1.55
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.54 2000/11/12 19:50:38 markus Exp $");
d132 1
a132 1
		options->log_level = SYSLOG_LEVEL_INFO;
@


1.54
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.53 2000/10/14 12:12:09 markus Exp $");
d272 1
a272 1
	unsigned int i;
@


1.53
log
@AllowTcpForwarding; from naddy@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.52 2000/10/11 20:14:39 markus Exp $");
d32 1
a32 2
	options->host_key_file = NULL;
	options->host_dsa_key_file = NULL;
d52 1
a52 1
	options->dsa_authentication = -1;
d86 9
a98 4
	if (options->host_key_file == NULL)
		options->host_key_file = HOST_KEY_FILE;
	if (options->host_dsa_key_file == NULL)
		options->host_dsa_key_file = HOST_DSA_KEY_FILE;
d139 2
a140 2
	if (options->dsa_authentication == -1)
		options->dsa_authentication = 1;
a168 2
	if (options->protocol == SSH_PROTO_UNKNOWN)
		options->protocol = SSH_PROTO_1|SSH_PROTO_2;
d199 2
a200 2
	sIgnoreUserKnownHosts, sHostDSAKeyFile, sCiphers, sProtocol, sPidFile,
	sGatewayPorts, sDSAAuthentication, sXAuthLocation, sSubsystem, sMaxStartups
d210 1
a210 1
	{ "hostdsakey", sHostDSAKeyFile },
d221 2
a222 1
	{ "dsaauthentication", sDSAAuthentication },
d342 2
d397 7
a403 3
		case sHostDSAKeyFile:
			charptr = (opcode == sHostKeyFile ) ?
			    &options->host_key_file : &options->host_dsa_key_file;
d411 1
a411 1
			if (*charptr == NULL)
d413 4
d490 2
a491 2
		case sDSAAuthentication:
			intptr = &options->dsa_authentication;
@


1.53.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d13 1
a13 8
RCSID("$OpenBSD: servconf.c,v 1.67 2001/02/12 16:16:23 markus Exp $");

#ifdef KRB4
#include <krb.h>
#endif
#ifdef AFS
#include <kafs.h>
#endif
a15 1
#include "log.h"
a18 6
#include "pathnames.h"
#include "tildexpand.h"
#include "misc.h"
#include "cipher.h"
#include "kex.h"
#include "mac.h"
a22 3
/* AF_UNSPEC or AF_INET or AF_INET6 */
extern int IPv4or6;

d32 2
a33 1
	options->num_host_key_files = 0;
d38 1
a38 1
	options->permit_root_login = PERMIT_NOT_SET;
d53 1
a53 1
	options->pubkey_authentication = -1;
d65 3
a67 1
	options->challenge_reponse_authentication = -1;
a75 1
	options->macs = NULL;
a81 2
	options->banner = NULL;
	options->reverse_mapping_check = -1;
a86 9
	if (options->protocol == SSH_PROTO_UNKNOWN)
		options->protocol = SSH_PROTO_1|SSH_PROTO_2;
	if (options->num_host_key_files == 0) {
		/* fill default hostkeys for protocols */
		if (options->protocol & SSH_PROTO_1)
			options->host_key_files[options->num_host_key_files++] = _PATH_HOST_KEY_FILE;
		if (options->protocol & SSH_PROTO_2)
			options->host_key_files[options->num_host_key_files++] = _PATH_HOST_DSA_KEY_FILE;
	}
d91 4
d96 1
a96 1
		options->pid_file = _PATH_SSH_DAEMON_PID_FILE;
d103 2
a104 2
	if (options->permit_root_login == PERMIT_NOT_SET)
		options->permit_root_login = PERMIT_YES;
d135 2
a136 2
	if (options->pubkey_authentication == -1)
		options->pubkey_authentication = 1;
d155 4
a158 2
	if (options->challenge_reponse_authentication == -1)
		options->challenge_reponse_authentication = 1;
d165 2
a174 2
	if (options->reverse_mapping_check == -1)
		options->reverse_mapping_check = 0;
d189 3
a191 1
	sChallengeResponseAuthentication,
d197 2
a198 3
	sIgnoreUserKnownHosts, sCiphers, sMacs, sProtocol, sPidFile,
	sGatewayPorts, sPubkeyAuthentication, sXAuthLocation, sSubsystem, sMaxStartups,
	sBanner, sReverseMappingCheck
d208 2
a209 2
	{ "hostdsakey", sHostKeyFile },					/* alias */
	{ "pidfile", sPidFile },
d219 1
a219 2
	{ "pubkeyauthentication", sPubkeyAuthentication },
	{ "dsaauthentication", sPubkeyAuthentication },			/* alias */
d231 3
a233 2
	{ "challengeresponseauthentication", sChallengeResponseAuthentication },
	{ "skeyauthentication", sChallengeResponseAuthentication }, /* alias */
a252 1
	{ "macs", sMacs },
a256 2
	{ "banner", sBanner },
	{ "reversemappingcheck", sReverseMappingCheck },
d269 1
a269 1
	u_int i;
d286 1
d337 1
a337 1
		if (!arg || !*arg || *arg == '#')
a338 2
		intptr = NULL;
		charptr = NULL;
d392 3
a394 7
			intptr = &options->num_host_key_files;
			if (*intptr >= MAX_HOSTKEYS) {
				fprintf(stderr, "%s line %d: to many host keys specified (max %d).\n",
				    filename, linenum, MAX_HOSTKEYS);
				exit(1);
			}
			charptr = &options->host_key_files[*intptr];
d402 1
a402 1
			if (*charptr == NULL) {
a403 4
				/* increase optional counter */
				if (intptr != NULL)
					*intptr = *intptr + 1;
			}
d425 1
a425 3
				value = PERMIT_NO_PASSWD;
			else if (strcmp(arg, "forced-commands-only") == 0)
				value = PERMIT_FORCED_ONLY;
d427 1
a427 1
				value = PERMIT_YES;
d429 1
a429 1
				value = PERMIT_NO;
d431 2
a432 3
				fprintf(stderr, "%s line %d: Bad yes/"
				    "without-password/forced-commands-only/no "
				    "argument: %s\n", filename, linenum, arg);
d477 2
a478 2
		case sPubkeyAuthentication:
			intptr = &options->pubkey_authentication;
d517 3
a519 2
		case sChallengeResponseAuthentication:
			intptr = &options->challenge_reponse_authentication;
d521 1
d538 1
a538 1

a558 4
		case sReverseMappingCheck:
			intptr = &options->reverse_mapping_check;
			goto parse_flag;

a631 11
		case sMacs:
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: Missing argument.", filename, linenum);
			if (!mac_valid(arg))
				fatal("%s line %d: Bad SSH2 mac spec '%s'.",
				    filename, linenum, arg ? arg : "<NONE>");
			if (options->macs == NULL)
				options->macs = xstrdup(arg);
			break;

a686 4
		case sBanner:
			charptr = &options->banner;
			goto parse_filename;

d693 1
a693 1
			fprintf(stderr,
@


1.53.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.53.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.71 2001/03/05 15:44:51 stevesk Exp $");
d212 1
a212 1
	sStrictModes, sEmptyPasswd, sKeepAlives, sCheckMail,
d264 1
d322 1
a322 1
			fatal("bad addr or host: %s (%s)",
d375 1
a375 1
				fatal("%s line %d: too many ports.",
d379 1
a379 1
				fatal("%s line %d: missing port number.",
d409 1
a409 1
				fatal("%s line %d: missing inet addr.",
d417 1
a417 2
				fprintf(stderr,
				    "%s line %d: too many host keys specified (max %d).\n",
d441 6
d451 2
a452 3
				fprintf(stderr, "%s line %d: missing yes/"
				    "without-password/forced-commands-only/no "
				    "argument.\n", filename, linenum);
d600 1
a600 1
				fatal("%.200s line %d: unsupported log facility '%s'",
d611 1
a611 1
				fatal("%.200s line %d: unsupported log level '%s'",
d624 1
a624 1
					fatal("%s line %d: too many allow users.",
d633 1
a633 1
					fatal( "%s line %d: too many deny users.",
d642 1
a642 1
					fatal("%s line %d: too many allow groups.",
d651 1
a651 1
					fatal("%s line %d: too many deny groups.",
@


1.53.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.78 2001/04/15 21:28:35 stevesk Exp $");
d34 2
a35 2
void add_listen_addr(ServerOptions *options, char *addr, u_short port);
void add_one_listen_addr(ServerOptions *options, char *addr, u_short port);
a57 1
	options->print_lastlog = -1;
a67 2
	options->hostbased_authentication = -1;
	options->hostbased_uses_name_from_packet_only = -1;
a98 2
	options->client_alive_interval = -1;
	options->client_alive_count_max = -1;
d116 1
a116 1
		add_listen_addr(options, NULL, 0);
a134 2
	if (options->print_lastlog == -1)
		options->print_lastlog = 1;
a154 4
	if (options->hostbased_authentication == -1)
		options->hostbased_authentication = 0;
	if (options->hostbased_uses_name_from_packet_only == -1)
		options->hostbased_uses_name_from_packet_only = 0;
a194 4
	if (options->client_alive_interval == -1)
		options->client_alive_interval = 0;  
	if (options->client_alive_count_max == -1)
		options->client_alive_count_max = 3;
d211 1
a211 2
	sPrintMotd, sPrintLastLog, sIgnoreRhosts,
	sX11Forwarding, sX11DisplayOffset,
d217 1
a217 3
	sBanner, sReverseMappingCheck, sHostbasedAuthentication,
	sHostbasedUsesNameFromPacketOnly, sClientAliveInterval, 
	sClientAliveCountMax
a236 2
	{ "hostbasedauthentication", sHostbasedAuthentication },
	{ "hostbasedusesnamefrompacketonly", sHostbasedUsesNameFromPacketOnly },
a255 1
	{ "printlastlog", sPrintLastLog },
a277 2
	{ "clientaliveinterval", sClientAliveInterval },
	{ "clientalivecountmax", sClientAliveCountMax },
d282 2
a283 1
 * Returns the number of the token pointed to by cp or sBadOption.
d296 2
a297 2
	error("%s: line %d: Bad configuration option: %s",
	    filename, linenum, cp);
d301 3
d305 1
a305 1
add_listen_addr(ServerOptions *options, char *addr, u_short port)
d307 3
d314 15
a328 27
	if (port == 0)
		for (i = 0; i < options->num_ports; i++)
			add_one_listen_addr(options, addr, options->ports[i]);
	else
		add_one_listen_addr(options, addr, port);
}

void
add_one_listen_addr(ServerOptions *options, char *addr, u_short port)
{
	struct addrinfo hints, *ai, *aitop;
	char strport[NI_MAXSERV];
	int gaierr;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = IPv4or6;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = (addr == NULL) ? AI_PASSIVE : 0;
	snprintf(strport, sizeof strport, "%d", port);
	if ((gaierr = getaddrinfo(addr, strport, &hints, &aitop)) != 0)
		fatal("bad addr or host: %s (%s)",
		    addr ? addr : "<NULL>",
		    gai_strerror(gaierr));
	for (ai = aitop; ai->ai_next; ai = ai->ai_next)
		;
	ai->ai_next = options->listen_addrs;
	options->listen_addrs = aitop;
d338 1
a338 1
	char *cp, **charptr, *arg, *p;
d380 1
a380 4
			options->ports[options->num_ports++] = a2port(arg);
			if (options->ports[options->num_ports-1] == 0)
				fatal("%s line %d: Badly formatted port number.",
				    filename, linenum);
d387 5
a391 3
			if (!arg || *arg == '\0')
				fatal("%s line %d: missing integer value.",
				    filename, linenum);
d407 1
a407 1
			if (!arg || *arg == '\0' || strncmp(arg, "[]", 2) == 0)
d410 1
a410 30
			if (*arg == '[') {
				if ((p = strchr(arg, ']')) == NULL)
					fatal("%s line %d: bad ipv6 inet addr usage.",
					    filename, linenum);
				arg++;
				memmove(p, p+1, strlen(p+1)+1);
			} else if (((p = strchr(arg, ':')) == NULL) ||
				    (strchr(p+1, ':') != NULL)) {
				add_listen_addr(options, arg, 0);
				break;
			}
			if (*p == ':') {
				u_short port;

				p++;
				if (*p == '\0')
					fatal("%s line %d: bad inet addr:port usage.",
					    filename, linenum);
				else {
					*(p-1) = '\0';
					if ((port = a2port(p)) == 0)
						fatal("%s line %d: bad port number.",
						    filename, linenum);
					add_listen_addr(options, arg, port);
				}
			} else if (*p == '\0')
				add_listen_addr(options, arg, 0);
			else
				fatal("%s line %d: bad inet addr usage.",
				    filename, linenum);
d415 3
a417 2
			if (*intptr >= MAX_HOSTKEYS)
				fatal("%s line %d: too many host keys specified (max %d).",
d419 2
d424 2
a425 2
			if (!arg || *arg == '\0')
				fatal("%s line %d: missing file name.",
d427 2
d444 2
a445 2
			if (!arg || *arg == '\0')
				fatal("%s line %d: missing yes/"
d447 3
a449 2
				    "argument.", filename, linenum);
			value = 0;	/* silence compiler */
d458 2
a459 2
			else
				fatal("%s line %d: Bad yes/"
d461 3
a463 1
				    "argument: %s", filename, linenum, arg);
d472 5
a476 4
			if (!arg || *arg == '\0')
				fatal("%s line %d: missing yes/no argument.",
				    filename, linenum);
			value = 0;	/* silence compiler */
d481 2
a482 2
			else
				fatal("%s line %d: Bad yes/no argument: %s",
d484 2
a501 8
		case sHostbasedAuthentication:
			intptr = &options->hostbased_authentication;
			goto parse_flag;

		case sHostbasedUsesNameFromPacketOnly:
			intptr = &options->hostbased_uses_name_from_packet_only;
			goto parse_flag;

a553 4
		case sPrintLastLog:
			intptr = &options->print_lastlog;
			goto parse_flag;

d732 1
a732 6
		case sClientAliveInterval:
			intptr = &options->client_alive_interval;
			goto parse_int;
		case sClientAliveCountMax:
			intptr = &options->client_alive_count_max;
			goto parse_int;
d734 9
a742 2
			fatal("%s line %d: Missing handler for opcode %s (%d)",
			    filename, linenum, arg, opcode);
a743 3
		if ((arg = strdelim(&cp)) != NULL && *arg != '\0')
			fatal("%s line %d: garbage at end of line; \"%.200s\".",
			    filename, linenum, arg);
d746 5
a750 3
	if (bad_options > 0)
		fatal("%s: terminating, %d bad configuration options",
		    filename, bad_options);
@


1.53.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.89 2001/08/16 19:18:34 jakob Exp $");
d15 1
a15 1
#if defined(KRB4) || defined(KRB5)
d34 2
a35 2
static void add_listen_addr(ServerOptions *, char *, u_short);
static void add_one_listen_addr(ServerOptions *, char *, u_short);
d59 1
d73 1
a73 1
#if defined(KRB4) || defined(KRB5)
d78 1
a78 1
#if defined(AFS) || defined(KRB5)
a79 2
#endif
#ifdef AFS
d84 1
a84 1
	options->challenge_response_authentication = -1;
a103 2
	options->authorized_keys_file = NULL;
	options->authorized_keys_file2 = NULL;
d136 2
d146 1
a146 1
#ifdef _PATH_XAUTH
d148 2
a149 2
		options->xauth_location = _PATH_XAUTH;
#endif
d170 1
a170 1
#if defined(KRB4) || defined(KRB5)
d177 2
a178 2
#endif
#if defined(AFS) || defined(KRB5)
a180 2
#endif
#ifdef AFS	
d183 1
a183 1
#endif
d188 2
a189 2
	if (options->challenge_response_authentication == -1)
		options->challenge_response_authentication = 1;
a209 4
	if (options->authorized_keys_file == NULL)
		options->authorized_keys_file = _PATH_SSH_USER_PERMITTED_KEYS;
	if (options->authorized_keys_file2 == NULL)
		options->authorized_keys_file2 = _PATH_SSH_USER_PERMITTED_KEYS2;
d218 1
a218 1
#if defined(KRB4) || defined(KRB5)
a220 3
#if defined(AFS) || defined(KRB5)
	sKerberosTgtPassing,
#endif
d222 1
a222 1
	sAFSTokenPassing,
d228 1
a228 1
	sStrictModes, sEmptyPasswd, sKeepAlives,
d235 1
a235 2
	sClientAliveCountMax, sAuthorizedKeysFile, sAuthorizedKeysFile2,
	sDeprecated
d260 1
a260 1
#if defined(KRB4) || defined(KRB5)
d265 1
a265 1
#if defined(AFS) || defined(KRB5)
a266 2
#endif
#ifdef AFS
d273 1
a273 1
	{ "checkmail", sDeprecated },
a300 2
	{ "authorizedkeysfile", sAuthorizedKeysFile },
	{ "authorizedkeysfile2", sAuthorizedKeysFile2 },
d323 1
a323 1
static void
d337 1
a337 1
static void
d370 1
a370 1
	int i, n;
d400 1
a400 1
				    "ListenAdress.", filename, linenum);
d428 1
a428 11
parse_time:
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: missing time value.",
				    filename, linenum);
			if ((value = convtime(arg)) == -1)
				fatal("%s line %d: invalid time value.",
				    filename, linenum);
			if (*intptr == -1)
				*intptr = value;
			break;
d432 1
a432 1
			goto parse_time;
d564 2
a565 1
#if defined(KRB4) || defined(KRB5)
d578 2
a579 1
#if defined(AFS) || defined(KRB5)
d583 1
a583 2
#endif
#ifdef AFS
d597 4
d602 1
a602 1
			intptr = &options->challenge_response_authentication;
d773 1
a773 1
			if ((n = sscanf(arg, "%d:%d:%d",
d776 1
a776 1
			    &options->max_startups)) == 3) {
a780 3
					fatal("%s line %d: Illegal MaxStartups spec.",
					    filename, linenum);
			} else if (n != 1)
d782 5
a786 4
				    filename, linenum);
			else
				options->max_startups = options->max_startups_begin;
			break;
a790 13
		/*
		 * These options can contain %X options expanded at
		 * connect time, so that you can specify paths like:
		 *
		 * AuthorizedKeysFile	/etc/ssh_keys/%u
		 */
		case sAuthorizedKeysFile:
		case sAuthorizedKeysFile2:
			charptr = (opcode == sAuthorizedKeysFile ) ?
			    &options->authorized_keys_file :
			    &options->authorized_keys_file2;
			goto parse_filename;

d793 1
a793 2
			goto parse_time;

a796 8

		case sDeprecated:
			log("%s line %d: Deprecated option %s",
			    filename, linenum, arg);
			while(arg)
			    arg = strdelim(&cp);
			break;

@


1.53.2.6
log
@Merge OpenSSH 3.0.1.

This is likely to be the last commit to the 2.8-STABLE branch.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.53.2.5 2001/09/27 00:15:42 miod Exp $");
a212 7
	if (options->authorized_keys_file2 == NULL) {
		/* authorized_keys_file2 falls back to authorized_keys_file */
		if (options->authorized_keys_file != NULL)
			options->authorized_keys_file2 = options->authorized_keys_file;
		else
			options->authorized_keys_file2 = _PATH_SSH_USER_PERMITTED_KEYS2;
	}
d215 2
@


1.53.2.7
log
@Merge OpenSSH 3.1.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.101 2002/02/04 12:15:25 markus Exp $");
a60 1
	options->x11_use_localhost = -1;
d64 2
a65 2
	options->log_facility = SYSLOG_FACILITY_NOT_SET;
	options->log_level = SYSLOG_LEVEL_NOT_SET;
d102 1
a102 1
	options->verify_reverse_mapping = -1;
d117 3
a119 8
			options->host_key_files[options->num_host_key_files++] =
			    _PATH_HOST_KEY_FILE;
		if (options->protocol & SSH_PROTO_2) {
			options->host_key_files[options->num_host_key_files++] =
			    _PATH_HOST_RSA_KEY_FILE;
			options->host_key_files[options->num_host_key_files++] =
			    _PATH_HOST_DSA_KEY_FILE;
		}
d147 1
a147 2
	if (options->x11_use_localhost == -1)
		options->x11_use_localhost = 1;
d150 1
d155 1
a155 1
	if (options->log_facility == SYSLOG_FACILITY_NOT_SET)
d157 1
a157 1
	if (options->log_level == SYSLOG_LEVEL_NOT_SET)
d183 1
a183 1
#ifdef AFS
d207 2
a208 2
	if (options->verify_reverse_mapping == -1)
		options->verify_reverse_mapping = 0;
d210 1
a210 1
		options->client_alive_interval = 0;
d242 1
a242 1
	sX11Forwarding, sX11DisplayOffset, sX11UseLocalhost,
d248 2
a249 2
	sBanner, sVerifyReverseMapping, sHostbasedAuthentication,
	sHostbasedUsesNameFromPacketOnly, sClientAliveInterval,
a298 1
	{ "x11uselocalhost", sX11UseLocalhost },
d316 1
a316 2
	{ "verifyreversemapping", sVerifyReverseMapping },
	{ "reversemappingcheck", sVerifyReverseMapping },
d321 1
a321 1
	{ NULL, sBadOption }
d379 4
a382 3
int
process_server_config_line(ServerOptions *options, char *line,
    const char *filename, int linenum)
d384 2
d387 2
a388 1
	int *intptr, value;
d392 9
a400 4
	cp = line;
	arg = strdelim(&cp);
	/* Ignore leading whitespace */
	if (*arg == '\0')
d402 31
a432 27
	if (!arg || !*arg || *arg == '#')
		return 0;
	intptr = NULL;
	charptr = NULL;
	opcode = parse_token(arg, filename, linenum);
	switch (opcode) {
	case sBadOption:
		return -1;
	case sPort:
		/* ignore ports from configfile if cmdline specifies ports */
		if (options->ports_from_cmdline)
			return 0;
		if (options->listen_addrs != NULL)
			fatal("%s line %d: ports must be specified before "
			    "ListenAddress.", filename, linenum);
		if (options->num_ports >= MAX_PORTS)
			fatal("%s line %d: too many ports.",
			    filename, linenum);
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing port number.",
			    filename, linenum);
		options->ports[options->num_ports++] = a2port(arg);
		if (options->ports[options->num_ports-1] == 0)
			fatal("%s line %d: Badly formatted port number.",
			    filename, linenum);
		break;
d434 2
a435 2
	case sServerKeyBits:
		intptr = &options->server_key_bits;
d437 8
a444 8
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing integer value.",
			    filename, linenum);
		value = atoi(arg);
		if (*intptr == -1)
			*intptr = value;
		break;
d446 2
a447 2
	case sLoginGraceTime:
		intptr = &options->login_grace_time;
d449 9
a457 29
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing time value.",
			    filename, linenum);
		if ((value = convtime(arg)) == -1)
			fatal("%s line %d: invalid time value.",
			    filename, linenum);
		if (*intptr == -1)
			*intptr = value;
		break;

	case sKeyRegenerationTime:
		intptr = &options->key_regeneration_time;
		goto parse_time;

	case sListenAddress:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0' || strncmp(arg, "[]", 2) == 0)
			fatal("%s line %d: missing inet addr.",
			    filename, linenum);
		if (*arg == '[') {
			if ((p = strchr(arg, ']')) == NULL)
				fatal("%s line %d: bad ipv6 inet addr usage.",
				    filename, linenum);
			arg++;
			memmove(p, p+1, strlen(p+1)+1);
		} else if (((p = strchr(arg, ':')) == NULL) ||
			    (strchr(p+1, ':') != NULL)) {
			add_listen_addr(options, arg, 0);
a458 3
		}
		if (*p == ':') {
			u_short port;
d460 12
a471 8
			p++;
			if (*p == '\0')
				fatal("%s line %d: bad inet addr:port usage.",
				    filename, linenum);
			else {
				*(p-1) = '\0';
				if ((port = a2port(p)) == 0)
					fatal("%s line %d: bad port number.",
d473 6
a478 1
				add_listen_addr(options, arg, port);
d480 27
a506 13
		} else if (*p == '\0')
			add_listen_addr(options, arg, 0);
		else
			fatal("%s line %d: bad inet addr usage.",
			    filename, linenum);
		break;

	case sHostKeyFile:
		intptr = &options->num_host_key_files;
		if (*intptr >= MAX_HOSTKEYS)
			fatal("%s line %d: too many host keys specified (max %d).",
			    filename, linenum, MAX_HOSTKEYS);
		charptr = &options->host_key_files[*intptr];
d508 11
a518 11
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing file name.",
			    filename, linenum);
		if (*charptr == NULL) {
			*charptr = tilde_expand_filename(arg, getuid());
			/* increase optional counter */
			if (intptr != NULL)
				*intptr = *intptr + 1;
		}
		break;
d520 27
a546 3
	case sPidFile:
		charptr = &options->pid_file;
		goto parse_filename;
d548 18
a565 23
	case sPermitRootLogin:
		intptr = &options->permit_root_login;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/"
			    "without-password/forced-commands-only/no "
			    "argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "without-password") == 0)
			value = PERMIT_NO_PASSWD;
		else if (strcmp(arg, "forced-commands-only") == 0)
			value = PERMIT_FORCED_ONLY;
		else if (strcmp(arg, "yes") == 0)
			value = PERMIT_YES;
		else if (strcmp(arg, "no") == 0)
			value = PERMIT_NO;
		else
			fatal("%s line %d: Bad yes/"
			    "without-password/forced-commands-only/no "
			    "argument: %s", filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;
d567 27
a593 46
	case sIgnoreRhosts:
		intptr = &options->ignore_rhosts;
parse_flag:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/no argument.",
			    filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "yes") == 0)
			value = 1;
		else if (strcmp(arg, "no") == 0)
			value = 0;
		else
			fatal("%s line %d: Bad yes/no argument: %s",
				filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;

	case sIgnoreUserKnownHosts:
		intptr = &options->ignore_user_known_hosts;
		goto parse_flag;

	case sRhostsAuthentication:
		intptr = &options->rhosts_authentication;
		goto parse_flag;

	case sRhostsRSAAuthentication:
		intptr = &options->rhosts_rsa_authentication;
		goto parse_flag;

	case sHostbasedAuthentication:
		intptr = &options->hostbased_authentication;
		goto parse_flag;

	case sHostbasedUsesNameFromPacketOnly:
		intptr = &options->hostbased_uses_name_from_packet_only;
		goto parse_flag;

	case sRSAAuthentication:
		intptr = &options->rsa_authentication;
		goto parse_flag;

	case sPubkeyAuthentication:
		intptr = &options->pubkey_authentication;
		goto parse_flag;
d595 11
a605 11
	case sKerberosAuthentication:
		intptr = &options->kerberos_authentication;
		goto parse_flag;

	case sKerberosOrLocalPasswd:
		intptr = &options->kerberos_or_local_passwd;
		goto parse_flag;

	case sKerberosTicketCleanup:
		intptr = &options->kerberos_ticket_cleanup;
		goto parse_flag;
d608 3
a610 3
	case sKerberosTgtPassing:
		intptr = &options->kerberos_tgt_passing;
		goto parse_flag;
d613 71
a683 4
	case sAFSTokenPassing:
		intptr = &options->afs_token_passing;
		goto parse_flag;
#endif
d685 10
a694 3
	case sPasswordAuthentication:
		intptr = &options->password_authentication;
		goto parse_flag;
d696 12
a707 3
	case sKbdInteractiveAuthentication:
		intptr = &options->kbd_interactive_authentication;
		goto parse_flag;
d709 8
a716 3
	case sChallengeResponseAuthentication:
		intptr = &options->challenge_response_authentication;
		goto parse_flag;
d718 8
a725 3
	case sPrintMotd:
		intptr = &options->print_motd;
		goto parse_flag;
d727 8
a734 3
	case sPrintLastLog:
		intptr = &options->print_lastlog;
		goto parse_flag;
d736 10
a745 3
	case sX11Forwarding:
		intptr = &options->x11_forwarding;
		goto parse_flag;
d747 10
a756 3
	case sX11DisplayOffset:
		intptr = &options->x11_display_offset;
		goto parse_int;
d758 12
a769 3
	case sX11UseLocalhost:
		intptr = &options->x11_use_localhost;
		goto parse_flag;
d771 21
a791 3
	case sXAuthLocation:
		charptr = &options->xauth_location;
		goto parse_filename;
d793 17
a809 54
	case sStrictModes:
		intptr = &options->strict_modes;
		goto parse_flag;

	case sKeepAlives:
		intptr = &options->keepalives;
		goto parse_flag;

	case sEmptyPasswd:
		intptr = &options->permit_empty_passwd;
		goto parse_flag;

	case sUseLogin:
		intptr = &options->use_login;
		goto parse_flag;

	case sGatewayPorts:
		intptr = &options->gateway_ports;
		goto parse_flag;

	case sVerifyReverseMapping:
		intptr = &options->verify_reverse_mapping;
		goto parse_flag;

	case sLogFacility:
		intptr = (int *) &options->log_facility;
		arg = strdelim(&cp);
		value = log_facility_number(arg);
		if (value == SYSLOG_FACILITY_NOT_SET)
			fatal("%.200s line %d: unsupported log facility '%s'",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*intptr == -1)
			*intptr = (SyslogFacility) value;
		break;

	case sLogLevel:
		intptr = (int *) &options->log_level;
		arg = strdelim(&cp);
		value = log_level_number(arg);
		if (value == SYSLOG_LEVEL_NOT_SET)
			fatal("%.200s line %d: unsupported log level '%s'",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*intptr == -1)
			*intptr = (LogLevel) value;
		break;

	case sAllowTcpForwarding:
		intptr = &options->allow_tcp_forwarding;
		goto parse_flag;

	case sAllowUsers:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_allow_users >= MAX_ALLOW_USERS)
				fatal("%s line %d: too many allow users.",
d811 3
a813 3
			options->allow_users[options->num_allow_users++] = xstrdup(arg);
		}
		break;
d815 30
a844 8
	case sDenyUsers:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_deny_users >= MAX_DENY_USERS)
				fatal( "%s line %d: too many deny users.",
				    filename, linenum);
			options->deny_users[options->num_deny_users++] = xstrdup(arg);
		}
		break;
d846 3
a848 15
	case sAllowGroups:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_allow_groups >= MAX_ALLOW_GROUPS)
				fatal("%s line %d: too many allow groups.",
				    filename, linenum);
			options->allow_groups[options->num_allow_groups++] = xstrdup(arg);
		}
		break;

	case sDenyGroups:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_deny_groups >= MAX_DENY_GROUPS)
				fatal("%s line %d: too many deny groups.",
				    filename, linenum);
			options->deny_groups[options->num_deny_groups++] = xstrdup(arg);
d850 3
a852 143
		break;

	case sCiphers:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.", filename, linenum);
		if (!ciphers_valid(arg))
			fatal("%s line %d: Bad SSH2 cipher spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (options->ciphers == NULL)
			options->ciphers = xstrdup(arg);
		break;

	case sMacs:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.", filename, linenum);
		if (!mac_valid(arg))
			fatal("%s line %d: Bad SSH2 mac spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (options->macs == NULL)
			options->macs = xstrdup(arg);
		break;

	case sProtocol:
		intptr = &options->protocol;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.", filename, linenum);
		value = proto_spec(arg);
		if (value == SSH_PROTO_UNKNOWN)
			fatal("%s line %d: Bad protocol spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*intptr == SSH_PROTO_UNKNOWN)
			*intptr = value;
		break;

	case sSubsystem:
		if (options->num_subsystems >= MAX_SUBSYSTEMS) {
			fatal("%s line %d: too many subsystems defined.",
			    filename, linenum);
		}
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing subsystem name.",
			    filename, linenum);
		for (i = 0; i < options->num_subsystems; i++)
			if (strcmp(arg, options->subsystem_name[i]) == 0)
				fatal("%s line %d: Subsystem '%s' already defined.",
				    filename, linenum, arg);
		options->subsystem_name[options->num_subsystems] = xstrdup(arg);
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing subsystem command.",
			    filename, linenum);
		options->subsystem_command[options->num_subsystems] = xstrdup(arg);
		options->num_subsystems++;
		break;

	case sMaxStartups:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing MaxStartups spec.",
			    filename, linenum);
		if ((n = sscanf(arg, "%d:%d:%d",
		    &options->max_startups_begin,
		    &options->max_startups_rate,
		    &options->max_startups)) == 3) {
			if (options->max_startups_begin >
			    options->max_startups ||
			    options->max_startups_rate > 100 ||
			    options->max_startups_rate < 1)
				fatal("%s line %d: Illegal MaxStartups spec.",
				    filename, linenum);
		} else if (n != 1)
			fatal("%s line %d: Illegal MaxStartups spec.",
			    filename, linenum);
		else
			options->max_startups = options->max_startups_begin;
		break;

	case sBanner:
		charptr = &options->banner;
		goto parse_filename;
	/*
	 * These options can contain %X options expanded at
	 * connect time, so that you can specify paths like:
	 *
	 * AuthorizedKeysFile	/etc_keys/%u
	 */
	case sAuthorizedKeysFile:
	case sAuthorizedKeysFile2:
		charptr = (opcode == sAuthorizedKeysFile ) ?
		    &options->authorized_keys_file :
		    &options->authorized_keys_file2;
		goto parse_filename;

	case sClientAliveInterval:
		intptr = &options->client_alive_interval;
		goto parse_time;

	case sClientAliveCountMax:
		intptr = &options->client_alive_count_max;
		goto parse_int;

	case sDeprecated:
		log("%s line %d: Deprecated option %s",
		    filename, linenum, arg);
		while (arg)
		    arg = strdelim(&cp);
		break;

	default:
		fatal("%s line %d: Missing handler for opcode %s (%d)",
		    filename, linenum, arg, opcode);
	}
	if ((arg = strdelim(&cp)) != NULL && *arg != '\0')
		fatal("%s line %d: garbage at end of line; \"%.200s\".",
		    filename, linenum, arg);
	return 0;
}

/* Reads the server configuration file. */

void
read_server_config(ServerOptions *options, const char *filename)
{
	FILE *f;
	char line[1024];
	int linenum;
	int bad_options = 0;

	f = fopen(filename, "r");
	if (!f) {
		perror(filename);
		exit(1);
	}
	linenum = 0;
	while (fgets(line, sizeof(line), f)) {
		/* Update line number counter. */
		linenum++;
		if (process_server_config_line(options, line, filename, linenum) != 0)
			bad_options++;
@


1.52
log
@add support for s/key (kbd-interactive) to ssh2, based on work by mkiernan@@avantgo.com and me
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.51 2000/09/07 20:27:53 deraadt Exp $");
d70 1
d163 2
d195 2
a196 1
	sUseLogin, sAllowUsers, sDenyUsers, sAllowGroups, sDenyGroups,
d247 1
d580 4
@


1.51
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.50 2000/07/22 09:14:36 markus Exp $");
d64 1
d152 2
d189 1
a189 1
	sPasswordAuthentication, sListenAddress,
d226 1
d502 4
@


1.50
log
@random early drop; ok theo, niels
@
text
@a1 5
 *
 * servconf.c
 *
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 *
d5 5
a9 2
 * Created: Mon Aug 21 15:48:58 1995 ylo
 *
d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.49 2000/07/14 22:59:46 markus Exp $");
@


1.49
log
@ allow leading whitespace. ok niels
@
text
@d15 1
a15 1
RCSID("$OpenBSD: servconf.c,v 1.48 2000/07/13 22:53:21 provos Exp $");
d79 2
d167 4
d653 16
@


1.48
log
@allow multiple whitespace but only one '=' between tokens, bug report from
Ralf S. Engelschall <rse@@engelschall.com> but different fix. okay deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: servconf.c,v 1.47 2000/07/10 16:30:25 ho Exp $");
d323 1
a323 1
			arg = cp;
@


1.47
log
@strtok() --> strsep(). (niels@@ ok)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: servconf.c,v 1.46 2000/06/26 21:59:18 markus Exp $");
a166 2
#define WHITESPACE " \t\r\n="

d319 6
a324 2
		cp = line + strspn(line, WHITESPACE);
		if (!*cp || *cp == '#')
a325 1
		arg = strsep(&cp, WHITESPACE);
d341 1
a341 1
			arg = strsep(&cp, WHITESPACE);
d351 1
a351 1
			arg = strsep(&cp, WHITESPACE);
d371 1
a371 1
			arg = strsep(&cp, WHITESPACE);
d383 1
a383 1
			arg = strsep(&cp, WHITESPACE);
d400 1
a400 1
			arg = strsep(&cp, WHITESPACE);
d405 1
a405 1
			arg = strsep(&cp, WHITESPACE);
d429 1
a429 1
			arg = strsep(&cp, WHITESPACE);
d544 1
a544 1
			arg = strsep(&cp, WHITESPACE);
d555 1
a555 1
			arg = strsep(&cp, WHITESPACE);
d565 1
a565 1
			while ((arg = strsep(&cp, WHITESPACE)) && *arg != '\0') {
d574 1
a574 1
			while ((arg = strsep(&cp, WHITESPACE)) && *arg != '\0') {
d583 1
a583 1
			while ((arg = strsep(&cp, WHITESPACE)) && *arg != '\0') {
d592 1
a592 1
			while ((arg = strsep(&cp, WHITESPACE)) && *arg != '\0') {
d601 1
a601 1
			arg = strsep(&cp, WHITESPACE);
d613 1
a613 1
			arg = strsep(&cp, WHITESPACE);
d629 1
a629 1
			arg = strsep(&cp, WHITESPACE);
d638 1
a638 1
			arg = strsep(&cp, WHITESPACE);
d655 1
a655 1
		if ((arg = strsep(&cp, WHITESPACE)) != NULL && *arg != '\0') {
@


1.46
log
@MaxStartups: limit number of unauthenticated connections, work by theo and me
@
text
@d15 1
a15 1
RCSID("$OpenBSD: servconf.c,v 1.45 2000/06/20 01:39:44 markus Exp $");
d307 1
a307 1
	char *cp, **charptr;
d324 2
a325 2
		cp = strtok(cp, WHITESPACE);
		opcode = parse_token(cp, filename, linenum);
d340 2
a341 2
			cp = strtok(NULL, WHITESPACE);
			if (!cp)
d344 1
a344 1
			options->ports[options->num_ports++] = atoi(cp);
d350 2
a351 2
			cp = strtok(NULL, WHITESPACE);
			if (!cp) {
d356 1
a356 1
			value = atoi(cp);
d370 2
a371 2
			cp = strtok(NULL, WHITESPACE);
			if (!cp)
d374 1
a374 1
			add_listen_addr(options, cp);
d382 2
a383 2
			cp = strtok(NULL, WHITESPACE);
			if (!cp) {
d389 1
a389 1
				*charptr = tilde_expand_filename(cp, getuid());
d399 1
a399 1
			cp = strtok(NULL, WHITESPACE);
d404 2
a405 2
			cp = strtok(NULL, WHITESPACE);
			if (!cp) {
d410 1
a410 1
			if (strcmp(cp, "without-password") == 0)
d412 1
a412 1
			else if (strcmp(cp, "yes") == 0)
d414 1
a414 1
			else if (strcmp(cp, "no") == 0)
d418 1
a418 1
					filename, linenum, cp);
d428 2
a429 2
			cp = strtok(NULL, WHITESPACE);
			if (!cp) {
d434 1
a434 1
			if (strcmp(cp, "yes") == 0)
d436 1
a436 1
			else if (strcmp(cp, "no") == 0)
d440 1
a440 1
					filename, linenum, cp);
d543 2
a544 2
			cp = strtok(NULL, WHITESPACE);
			value = log_facility_number(cp);
d547 1
a547 1
				    filename, linenum, cp ? cp : "<NONE>");
d554 2
a555 2
			cp = strtok(NULL, WHITESPACE);
			value = log_level_number(cp);
d558 1
a558 1
				    filename, linenum, cp ? cp : "<NONE>");
d564 1
a564 1
			while ((cp = strtok(NULL, WHITESPACE))) {
d568 1
a568 1
				options->allow_users[options->num_allow_users++] = xstrdup(cp);
d573 1
a573 1
			while ((cp = strtok(NULL, WHITESPACE))) {
d577 1
a577 1
				options->deny_users[options->num_deny_users++] = xstrdup(cp);
d582 1
a582 1
			while ((cp = strtok(NULL, WHITESPACE))) {
d586 1
a586 1
				options->allow_groups[options->num_allow_groups++] = xstrdup(cp);
d591 1
a591 1
			while ((cp = strtok(NULL, WHITESPACE))) {
d595 1
a595 1
				options->deny_groups[options->num_deny_groups++] = xstrdup(cp);
d600 2
a601 2
			cp = strtok(NULL, WHITESPACE);
			if (!cp)
d603 1
a603 1
			if (!ciphers_valid(cp))
d605 1
a605 1
				    filename, linenum, cp ? cp : "<NONE>");
d607 1
a607 1
				options->ciphers = xstrdup(cp);
d612 2
a613 2
			cp = strtok(NULL, WHITESPACE);
			if (!cp)
d615 1
a615 1
			value = proto_spec(cp);
d618 1
a618 1
				      filename, linenum, cp ? cp : "<NONE>");
d628 2
a629 2
			cp = strtok(NULL, WHITESPACE);
			if (!cp)
d633 1
a633 1
				if(strcmp(cp, options->subsystem_name[i]) == 0)
d635 4
a638 4
					      filename, linenum, cp);
			options->subsystem_name[options->num_subsystems] = xstrdup(cp);
			cp = strtok(NULL, WHITESPACE);
			if (!cp)
d641 1
a641 1
			options->subsystem_command[options->num_subsystems] = xstrdup(cp);
d651 1
a651 1
				filename, linenum, cp, opcode);
d654 4
a657 3
		if (strtok(NULL, WHITESPACE) != NULL) {
			fprintf(stderr, "%s line %d: garbage at end of line.\n",
				filename, linenum);
@


1.45
log
@OpenBSD tag
@
text
@d15 1
a15 1
RCSID("$OpenBSD: servconf.c,v 1.44 2000/06/18 00:57:48 deraadt Exp $");
d79 1
d163 2
d189 1
a189 1
	sGatewayPorts, sDSAAuthentication, sXAuthLocation, sSubsystem
d245 1
d644 4
@


1.44
log
@include = in WHITESPACE; markus ok
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.43 2000/06/17 22:52:33 jakob Exp $");
@


1.43
log
@add support for ssh v2 subsystems. ok markus@@.
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.42 2000/05/31 06:36:40 markus Exp $");
d164 1
a164 1
#define WHITESPACE " \t\r\n"
@


1.42
log
@xauth_location support; pr 1234
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.41 2000/05/22 18:42:01 markus Exp $");
d78 1
d186 1
a186 1
	sGatewayPorts, sDSAAuthentication, sXAuthLocation
d241 1
d307 1
d617 22
@


1.41
log
@check strtok() != NULL; ok niels@@
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.40 2000/05/08 17:12:15 markus Exp $");
d47 1
d113 4
d185 1
a185 1
	sGatewayPorts, sDSAAuthentication
d227 1
d374 1
d387 1
a387 9
			cp = strtok(NULL, WHITESPACE);
			if (!cp) {
				fprintf(stderr, "%s line %d: missing file name.\n",
				    filename, linenum);
				exit(1);
			}
			if (*charptr == NULL)
				*charptr = tilde_expand_filename(cp, getuid());
			break;
d510 4
@


1.40
log
@complain about invalid ciphers in SSH1 (e.g. arcfour is SSH2 only)
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.39 2000/05/06 17:45:36 markus Exp $");
d591 2
d603 2
@


1.40.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.42 2000/05/31 06:36:40 markus Exp $");
a46 1
	options->xauth_location = NULL;
a111 4
#ifdef XAUTH_PATH
	if (options->xauth_location == NULL)
		options->xauth_location = XAUTH_PATH;
#endif /* XAUTH_PATH */
d180 1
a180 1
	sGatewayPorts, sDSAAuthentication, sXAuthLocation
a221 1
	{ "xauthlocation", sXAuthLocation },
a367 1
parse_filename:
d380 9
a388 1
			goto parse_filename;
a510 4
		case sXAuthLocation:
			charptr = &options->xauth_location;
			goto parse_filename;
			
a590 2
			if (!cp)
				fatal("%s line %d: Missing argument.", filename, linenum);
a600 2
			if (!cp)
				fatal("%s line %d: Missing argument.", filename, linenum);
@


1.40.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: servconf.c,v 1.50 2000/07/22 09:14:36 markus Exp $");
a77 4
	options->num_subsystems = 0;
	options->max_startups_begin = -1;
	options->max_startups_rate = -1;
	options->max_startups = -1;
a160 6
	if (options->max_startups == -1)
		options->max_startups = 10;
	if (options->max_startups_rate == -1)
		options->max_startups_rate = 100;		/* 100% */
	if (options->max_startups_begin == -1)
		options->max_startups_begin = options->max_startups;
d163 2
d185 1
a185 1
	sGatewayPorts, sDSAAuthentication, sXAuthLocation, sSubsystem, sMaxStartups
a239 2
	{ "subsystem", sSubsystem },
	{ "maxstartups", sMaxStartups },
d301 1
a301 1
	char *cp, **charptr, *arg;
a304 1
	int i;
d314 2
a315 6
		cp = line;
		arg = strdelim(&cp);
		/* Ignore leading whitespace */
		if (*arg == '\0')
			arg = strdelim(&cp);
		if (!*arg || *arg == '#')
d317 2
a318 1
		opcode = parse_token(arg, filename, linenum);
d333 2
a334 2
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
d337 1
a337 1
			options->ports[options->num_ports++] = atoi(arg);
d343 2
a344 2
			arg = strdelim(&cp);
			if (!arg || *arg == '\0') {
d349 1
a349 1
			value = atoi(arg);
d363 2
a364 2
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
d367 1
a367 1
			add_listen_addr(options, arg);
d375 2
a376 2
			arg = strdelim(&cp);
			if (!arg || *arg == '\0') {
d382 1
a382 1
				*charptr = tilde_expand_filename(arg, getuid());
d392 1
a392 1
			arg = strdelim(&cp);
d397 2
a398 2
			arg = strdelim(&cp);
			if (!arg || *arg == '\0') {
d403 1
a403 1
			if (strcmp(arg, "without-password") == 0)
d405 1
a405 1
			else if (strcmp(arg, "yes") == 0)
d407 1
a407 1
			else if (strcmp(arg, "no") == 0)
d411 1
a411 1
					filename, linenum, arg);
d421 2
a422 2
			arg = strdelim(&cp);
			if (!arg || *arg == '\0') {
d427 1
a427 1
			if (strcmp(arg, "yes") == 0)
d429 1
a429 1
			else if (strcmp(arg, "no") == 0)
d433 1
a433 1
					filename, linenum, arg);
d536 2
a537 2
			arg = strdelim(&cp);
			value = log_facility_number(arg);
d540 1
a540 1
				    filename, linenum, arg ? arg : "<NONE>");
d547 2
a548 2
			arg = strdelim(&cp);
			value = log_level_number(arg);
d551 1
a551 1
				    filename, linenum, arg ? arg : "<NONE>");
d557 1
a557 1
			while ((arg = strdelim(&cp)) && *arg != '\0') {
d561 1
a561 1
				options->allow_users[options->num_allow_users++] = xstrdup(arg);
d566 1
a566 1
			while ((arg = strdelim(&cp)) && *arg != '\0') {
d570 1
a570 1
				options->deny_users[options->num_deny_users++] = xstrdup(arg);
d575 1
a575 1
			while ((arg = strdelim(&cp)) && *arg != '\0') {
d579 1
a579 1
				options->allow_groups[options->num_allow_groups++] = xstrdup(arg);
d584 1
a584 1
			while ((arg = strdelim(&cp)) && *arg != '\0') {
d588 1
a588 1
				options->deny_groups[options->num_deny_groups++] = xstrdup(arg);
d593 2
a594 2
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
d596 1
a596 1
			if (!ciphers_valid(arg))
d598 1
a598 1
				    filename, linenum, arg ? arg : "<NONE>");
d600 1
a600 1
				options->ciphers = xstrdup(arg);
d605 2
a606 2
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
d608 1
a608 1
			value = proto_spec(arg);
d611 1
a611 1
				      filename, linenum, arg ? arg : "<NONE>");
a615 42
		case sSubsystem:
			if(options->num_subsystems >= MAX_SUBSYSTEMS) {
				fatal("%s line %d: too many subsystems defined.",
				      filename, linenum);
			}
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: Missing subsystem name.",
				      filename, linenum);
			for (i = 0; i < options->num_subsystems; i++)
				if(strcmp(arg, options->subsystem_name[i]) == 0)
					fatal("%s line %d: Subsystem '%s' already defined.",
					      filename, linenum, arg);
			options->subsystem_name[options->num_subsystems] = xstrdup(arg);
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: Missing subsystem command.",
				      filename, linenum);
			options->subsystem_command[options->num_subsystems] = xstrdup(arg);
			options->num_subsystems++;
			break;

		case sMaxStartups:
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: Missing MaxStartups spec.",
				      filename, linenum);
			if (sscanf(arg, "%d:%d:%d",
			    &options->max_startups_begin,
			    &options->max_startups_rate,
			    &options->max_startups) == 3) {
				if (options->max_startups_begin >
				    options->max_startups ||
				    options->max_startups_rate > 100 ||
				    options->max_startups_rate < 1)
				fatal("%s line %d: Illegal MaxStartups spec.",
				      filename, linenum);
				break;
			}
			intptr = &options->max_startups;
			goto parse_int;

d618 1
a618 1
				filename, linenum, arg, opcode);
d621 3
a623 4
		if ((arg = strdelim(&cp)) != NULL && *arg != '\0') {
			fprintf(stderr, 
				"%s line %d: garbage at end of line; \"%.200s\".\n",
				filename, linenum, arg);
@


1.40.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 5
d10 2
a11 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d15 1
a15 1
RCSID("$OpenBSD: servconf.c,v 1.53 2000/10/14 12:12:09 markus Exp $");
a65 1
	options->kbd_interactive_authentication = -1;
a70 1
	options->allow_tcp_forwarding = -1;
a152 2
	if (options->kbd_interactive_authentication == -1)
		options->kbd_interactive_authentication = 0;
a160 2
	if (options->allow_tcp_forwarding == -1)
		options->allow_tcp_forwarding = 1;
d188 1
a188 1
	sPasswordAuthentication, sKbdInteractiveAuthentication, sListenAddress,
d191 1
a191 2
	sUseLogin, sAllowTcpForwarding,
	sAllowUsers, sDenyUsers, sAllowGroups, sDenyGroups,
a224 1
	{ "kbdinteractiveauthentication", sKbdInteractiveAuthentication },
a240 1
	{ "allowtcpforwarding", sAllowTcpForwarding },
a501 4
		case sKbdInteractiveAuthentication:
			intptr = &options->kbd_interactive_authentication;
			goto parse_flag;

a568 4

		case sAllowTcpForwarding:
			intptr = &options->allow_tcp_forwarding;
			goto parse_flag;
@


1.40.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d13 1
a13 8
RCSID("$OpenBSD: servconf.c,v 1.67 2001/02/12 16:16:23 markus Exp $");

#ifdef KRB4
#include <krb.h>
#endif
#ifdef AFS
#include <kafs.h>
#endif
a15 1
#include "log.h"
a18 6
#include "pathnames.h"
#include "tildexpand.h"
#include "misc.h"
#include "cipher.h"
#include "kex.h"
#include "mac.h"
a22 3
/* AF_UNSPEC or AF_INET or AF_INET6 */
extern int IPv4or6;

d32 2
a33 1
	options->num_host_key_files = 0;
d38 1
a38 1
	options->permit_root_login = PERMIT_NOT_SET;
d53 1
a53 1
	options->pubkey_authentication = -1;
d65 3
a67 1
	options->challenge_reponse_authentication = -1;
a75 1
	options->macs = NULL;
a81 2
	options->banner = NULL;
	options->reverse_mapping_check = -1;
a86 9
	if (options->protocol == SSH_PROTO_UNKNOWN)
		options->protocol = SSH_PROTO_1|SSH_PROTO_2;
	if (options->num_host_key_files == 0) {
		/* fill default hostkeys for protocols */
		if (options->protocol & SSH_PROTO_1)
			options->host_key_files[options->num_host_key_files++] = _PATH_HOST_KEY_FILE;
		if (options->protocol & SSH_PROTO_2)
			options->host_key_files[options->num_host_key_files++] = _PATH_HOST_DSA_KEY_FILE;
	}
d91 4
d96 1
a96 1
		options->pid_file = _PATH_SSH_DAEMON_PID_FILE;
d103 2
a104 2
	if (options->permit_root_login == PERMIT_NOT_SET)
		options->permit_root_login = PERMIT_YES;
d135 2
a136 2
	if (options->pubkey_authentication == -1)
		options->pubkey_authentication = 1;
d155 4
a158 2
	if (options->challenge_reponse_authentication == -1)
		options->challenge_reponse_authentication = 1;
d165 2
a174 2
	if (options->reverse_mapping_check == -1)
		options->reverse_mapping_check = 0;
d189 3
a191 1
	sChallengeResponseAuthentication,
d197 2
a198 3
	sIgnoreUserKnownHosts, sCiphers, sMacs, sProtocol, sPidFile,
	sGatewayPorts, sPubkeyAuthentication, sXAuthLocation, sSubsystem, sMaxStartups,
	sBanner, sReverseMappingCheck
d208 2
a209 2
	{ "hostdsakey", sHostKeyFile },					/* alias */
	{ "pidfile", sPidFile },
d219 1
a219 2
	{ "pubkeyauthentication", sPubkeyAuthentication },
	{ "dsaauthentication", sPubkeyAuthentication },			/* alias */
d231 3
a233 2
	{ "challengeresponseauthentication", sChallengeResponseAuthentication },
	{ "skeyauthentication", sChallengeResponseAuthentication }, /* alias */
a252 1
	{ "macs", sMacs },
a256 2
	{ "banner", sBanner },
	{ "reversemappingcheck", sReverseMappingCheck },
d269 1
a269 1
	u_int i;
d286 1
d337 1
a337 1
		if (!arg || !*arg || *arg == '#')
a338 2
		intptr = NULL;
		charptr = NULL;
d392 3
a394 7
			intptr = &options->num_host_key_files;
			if (*intptr >= MAX_HOSTKEYS) {
				fprintf(stderr, "%s line %d: to many host keys specified (max %d).\n",
				    filename, linenum, MAX_HOSTKEYS);
				exit(1);
			}
			charptr = &options->host_key_files[*intptr];
d402 1
a402 1
			if (*charptr == NULL) {
a403 4
				/* increase optional counter */
				if (intptr != NULL)
					*intptr = *intptr + 1;
			}
d425 1
a425 3
				value = PERMIT_NO_PASSWD;
			else if (strcmp(arg, "forced-commands-only") == 0)
				value = PERMIT_FORCED_ONLY;
d427 1
a427 1
				value = PERMIT_YES;
d429 1
a429 1
				value = PERMIT_NO;
d431 2
a432 3
				fprintf(stderr, "%s line %d: Bad yes/"
				    "without-password/forced-commands-only/no "
				    "argument: %s\n", filename, linenum, arg);
d477 2
a478 2
		case sPubkeyAuthentication:
			intptr = &options->pubkey_authentication;
d517 3
a519 2
		case sChallengeResponseAuthentication:
			intptr = &options->challenge_reponse_authentication;
d521 1
d538 1
a538 1

a558 4
		case sReverseMappingCheck:
			intptr = &options->reverse_mapping_check;
			goto parse_flag;

a631 11
		case sMacs:
			arg = strdelim(&cp);
			if (!arg || *arg == '\0')
				fatal("%s line %d: Missing argument.", filename, linenum);
			if (!mac_valid(arg))
				fatal("%s line %d: Bad SSH2 mac spec '%s'.",
				    filename, linenum, arg ? arg : "<NONE>");
			if (options->macs == NULL)
				options->macs = xstrdup(arg);
			break;

a686 4
		case sBanner:
			charptr = &options->banner;
			goto parse_filename;

d693 1
a693 1
			fprintf(stderr,
@


1.40.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.71 2001/03/05 15:44:51 stevesk Exp $");
d212 1
a212 1
	sStrictModes, sEmptyPasswd, sKeepAlives, sCheckMail,
d264 1
d322 1
a322 1
			fatal("bad addr or host: %s (%s)",
d375 1
a375 1
				fatal("%s line %d: too many ports.",
d379 1
a379 1
				fatal("%s line %d: missing port number.",
d409 1
a409 1
				fatal("%s line %d: missing inet addr.",
d417 1
a417 2
				fprintf(stderr,
				    "%s line %d: too many host keys specified (max %d).\n",
d441 6
d451 2
a452 3
				fprintf(stderr, "%s line %d: missing yes/"
				    "without-password/forced-commands-only/no "
				    "argument.\n", filename, linenum);
d600 1
a600 1
				fatal("%.200s line %d: unsupported log facility '%s'",
d611 1
a611 1
				fatal("%.200s line %d: unsupported log level '%s'",
d624 1
a624 1
					fatal("%s line %d: too many allow users.",
d633 1
a633 1
					fatal( "%s line %d: too many deny users.",
d642 1
a642 1
					fatal("%s line %d: too many allow groups.",
d651 1
a651 1
					fatal("%s line %d: too many deny groups.",
@


1.39
log
@add DSAAuthetication option to ssh/sshd, document SSH2 in sshd.8
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.38 2000/05/03 18:03:06 markus Exp $");
d592 1
a592 1
				fatal("%s line %d: Bad cipher spec '%s'.",
@


1.38
log
@GatewayPorts for sshd, ok deraadt@@
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.37 2000/05/03 10:21:47 markus Exp $");
d54 1
d126 2
d180 1
a180 1
	sGatewayPorts
d201 1
d455 4
@


1.37
log
@s/DsaKey/HostDSAKey/, document option
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.36 2000/05/01 18:50:58 markus Exp $");
d75 1
d151 2
d176 2
a177 1
	sIgnoreUserKnownHosts, sHostDSAKeyFile, sCiphers, sProtocol, sPidFile
d229 1
d517 4
@


1.36
log
@PidFile, pr 1210
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.35 2000/04/26 22:43:15 markus Exp $");
d35 1
a35 1
	options->dsa_key_file = NULL;
d86 2
a87 2
	if (options->dsa_key_file == NULL)
		options->dsa_key_file = DSA_KEY_FILE;
d173 1
a173 1
	sIgnoreUserKnownHosts, sDSAKeyFile, sCiphers, sProtocol, sPidFile
d183 1
a183 1
	{ "dsakey", sDSAKeyFile },
d356 1
a356 1
		case sDSAKeyFile:
d358 1
a358 1
			    &options->host_key_file : &options->dsa_key_file;
@


1.35
log
@ssh/sshd default to proto 1 and 2
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.34 2000/04/14 10:30:33 markus Exp $");
d36 1
d88 2
d173 1
a173 1
	sIgnoreUserKnownHosts, sDSAKeyFile, sCiphers, sProtocol
d184 1
d362 13
a374 1
					filename, linenum);
@


1.34
log
@whitespace cleanup
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.33 2000/04/12 07:45:44 markus Exp $");
d146 1
a146 1
		options->protocol = SSH_PROTO_1;
@


1.33
log
@add Cipher and Protocol options to ssh/sshd, e.g.:
ssh -o 'Protocol 1,2' if you prefer proto 1, ssh -o 'Ciphers arcfour,3des-cbc'
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d15 1
a15 1
RCSID("$Id: servconf.c,v 1.32 2000/04/06 08:55:22 markus Exp $");
d27 1
a27 1
void 
d76 1
a76 1
void 
d229 1
a229 1
static ServerOpCodes 
d247 1
a247 1
void 
d277 1
a277 1
void 
d313 1
a313 1
			            filename, linenum);
@


1.32
log
@ssh2 server side, see README.openssh2; enable with 'sshd -2'
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.31 2000/03/07 20:40:41 markus Exp $");
d20 1
d72 2
d145 2
d170 1
a170 1
	sIgnoreUserKnownHosts, sDSAKeyFile
d219 2
d504 1
a504 1
				  filename, linenum, cp ? cp : "<NONE>");
d515 1
a515 1
				  filename, linenum, cp ? cp : "<NONE>");
d522 3
a524 5
				if (options->num_allow_users >= MAX_ALLOW_USERS) {
					fprintf(stderr, "%s line %d: too many allow users.\n",
						filename, linenum);
					exit(1);
				}
d531 3
a533 5
				if (options->num_deny_users >= MAX_DENY_USERS) {
					fprintf(stderr, "%s line %d: too many deny users.\n",
						filename, linenum);
					exit(1);
				}
d540 3
a542 5
				if (options->num_allow_groups >= MAX_ALLOW_GROUPS) {
					fprintf(stderr, "%s line %d: too many allow groups.\n",
						filename, linenum);
					exit(1);
				}
d549 3
a551 5
				if (options->num_deny_groups >= MAX_DENY_GROUPS) {
					fprintf(stderr, "%s line %d: too many deny groups.\n",
						filename, linenum);
					exit(1);
				}
d554 20
@


1.31
log
@typo: ignore_user_known_hosts int->flag; naddy@@mips.rhein-neckar.de
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.30 2000/02/24 18:22:16 markus Exp $");
d34 1
d82 2
d165 1
a165 1
	sIgnoreUserKnownHosts
d175 1
d345 3
a347 1
			charptr = &options->host_key_file;
@


1.30
log
@sync with sshd_config
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.29 2000/01/04 00:07:59 markus Exp $");
d405 1
a405 1
			goto parse_int;
@


1.29
log
@ipv6 support: mostly gethostbyname->getaddrinfo/getnameinfo, new features:
sshd allows multiple ListenAddress and Port options.  note that libwrap is
not IPv6-ready. (based on patches from <kick@@kyoto.wide.ad.jp> and
fujiwara@@rcac.tdi.co.jp)
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.28 1999/11/24 20:19:37 markus Exp $");
d90 1
a90 1
		options->ignore_rhosts = 0;
d98 1
a98 1
		options->x11_forwarding = 1;
d100 1
a100 1
		options->x11_display_offset = 1;
d112 1
a112 1
		options->rhosts_rsa_authentication = 1;
d136 1
a136 1
		options->permit_empty_passwd = 1;
@


1.28
log
@strcasecmp instead of tolower
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.27 1999/11/24 19:53:50 markus Exp $");
d21 3
d30 3
a32 2
	options->port = -1;
	options->listen_addr.s_addr = htonl(INADDR_ANY);
d75 4
a78 10
	if (options->port == -1) {
		struct servent *sp;

		sp = getservbyname(SSH_SERVICE_NAME, "tcp");
		if (sp)
			options->port = ntohs(sp->s_port);
		else
			options->port = SSH_DEFAULT_PORT;
		endservent();
	}
d233 31
d294 18
a311 1
			intptr = &options->port;
a323 4
		case sServerKeyBits:
			intptr = &options->server_key_bits;
			goto parse_int;

d334 4
a337 6
			if (!cp) {
				fprintf(stderr, "%s line %d: missing inet addr.\n",
					filename, linenum);
				exit(1);
			}
			options->listen_addr.s_addr = inet_addr(cp);
@


1.27
log
@KNF, final part 3
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.26 1999/11/24 00:26:03 deraadt Exp $");
d227 1
a227 1
		if (strcmp(cp, keywords[i].name) == 0)
a258 7
		{
			char *t = cp;
			for (; *t != 0; t++)
				if ('A' <= *t && *t <= 'Z')
					*t = *t - 'A' + 'a';	/* tolower */

		}
@


1.26
log
@much more KNF
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.25 1999/11/23 22:25:54 markus Exp $");
d215 4
a218 2
/* Returns the number of the token pointed to by cp of length len.
   Never returns if the token is not known. */
@


1.25
log
@KNF part 1
@
text
@d2 11
a12 11

servconf.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Mon Aug 21 15:48:58 1995 ylo

*/
d15 1
a15 1
RCSID("$Id: servconf.c,v 1.24 1999/11/19 20:03:35 markus Exp $");
@


1.24
log
@remove unused index (-Wall)
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.23 1999/11/19 16:04:17 markus Exp $");
d23 2
a24 1
void initialize_server_options(ServerOptions *options)
d26 21
a46 21
  memset(options, 0, sizeof(*options));
  options->port = -1;
  options->listen_addr.s_addr = htonl(INADDR_ANY);
  options->host_key_file = NULL;
  options->server_key_bits = -1;
  options->login_grace_time = -1;
  options->key_regeneration_time = -1;
  options->permit_root_login = -1;
  options->ignore_rhosts = -1;
  options->ignore_user_known_hosts = -1;
  options->print_motd = -1;
  options->check_mail = -1;
  options->x11_forwarding = -1;
  options->x11_display_offset = -1;
  options->strict_modes = -1;
  options->keepalives = -1;
  options->log_facility = (SyslogFacility)-1;
  options->log_level = (LogLevel)-1;
  options->rhosts_authentication = -1;
  options->rhosts_rsa_authentication = -1;
  options->rsa_authentication = -1;
d48 3
a50 3
  options->kerberos_authentication = -1;
  options->kerberos_or_local_passwd = -1;
  options->kerberos_ticket_cleanup = -1;
d53 2
a54 2
  options->kerberos_tgt_passing = -1;
  options->afs_token_passing = -1;
d56 1
a56 1
  options->password_authentication = -1;
d58 1
a58 1
  options->skey_authentication = -1;
d60 6
a65 6
  options->permit_empty_passwd = -1;
  options->use_login = -1;
  options->num_allow_users = 0;
  options->num_deny_users = 0;
  options->num_allow_groups = 0;
  options->num_deny_groups = 0;
d68 2
a69 1
void fill_default_server_options(ServerOptions *options)
d71 46
a116 47
  if (options->port == -1)
    {
      struct servent *sp;

      sp = getservbyname(SSH_SERVICE_NAME, "tcp");
      if (sp)
	options->port = ntohs(sp->s_port);
      else
	options->port = SSH_DEFAULT_PORT;
      endservent();
    }
  if (options->host_key_file == NULL)
    options->host_key_file = HOST_KEY_FILE;
  if (options->server_key_bits == -1)
    options->server_key_bits = 768;
  if (options->login_grace_time == -1)
    options->login_grace_time = 600;
  if (options->key_regeneration_time == -1)
    options->key_regeneration_time = 3600;
  if (options->permit_root_login == -1)
    options->permit_root_login = 1;		 /* yes */
  if (options->ignore_rhosts == -1)
    options->ignore_rhosts = 0;
  if (options->ignore_user_known_hosts == -1)
    options->ignore_user_known_hosts = 0;
  if (options->check_mail == -1)
    options->check_mail = 0;
  if (options->print_motd == -1)
    options->print_motd = 1;
  if (options->x11_forwarding == -1)
    options->x11_forwarding = 1;
  if (options->x11_display_offset == -1)
    options->x11_display_offset = 1;
  if (options->strict_modes == -1)
    options->strict_modes = 1;
  if (options->keepalives == -1)
    options->keepalives = 1;
  if (options->log_facility == (SyslogFacility)(-1))
    options->log_facility = SYSLOG_FACILITY_AUTH;
  if (options->log_level == (LogLevel)(-1))
    options->log_level = SYSLOG_LEVEL_INFO;
  if (options->rhosts_authentication == -1)
    options->rhosts_authentication = 0;
  if (options->rhosts_rsa_authentication == -1)
    options->rhosts_rsa_authentication = 1;
  if (options->rsa_authentication == -1)
    options->rsa_authentication = 1;
d118 6
a123 6
  if (options->kerberos_authentication == -1)
    options->kerberos_authentication = (access(KEYFILE, R_OK) == 0);
  if (options->kerberos_or_local_passwd == -1)
    options->kerberos_or_local_passwd = 1;
  if (options->kerberos_ticket_cleanup == -1)
    options->kerberos_ticket_cleanup = 1;
d126 4
a129 4
  if (options->kerberos_tgt_passing == -1)
    options->kerberos_tgt_passing = 0;
  if (options->afs_token_passing == -1)
    options->afs_token_passing = k_hasafs();
d131 2
a132 2
  if (options->password_authentication == -1)
    options->password_authentication = 1;
d134 2
a135 2
  if (options->skey_authentication == -1)
    options->skey_authentication = 1;
d137 4
a140 4
  if (options->permit_empty_passwd == -1)
    options->permit_empty_passwd = 1;
  if (options->use_login == -1)
    options->use_login = 0;
d146 5
a150 6
typedef enum 
{
  sBadOption, /* == unknown option */
  sPort, sHostKeyFile, sServerKeyBits, sLoginGraceTime, sKeyRegenerationTime,
  sPermitRootLogin, sLogFacility, sLogLevel,
  sRhostsAuthentication, sRhostsRSAAuthentication, sRSAAuthentication,
d152 1
a152 1
  sKerberosAuthentication, sKerberosOrLocalPasswd, sKerberosTicketCleanup,
d155 1
a155 1
  sKerberosTgtPassing, sAFSTokenPassing,
d158 1
a158 1
  sSkeyAuthentication,
d160 5
a164 5
  sPasswordAuthentication, sListenAddress,
  sPrintMotd, sIgnoreRhosts, sX11Forwarding, sX11DisplayOffset,
  sStrictModes, sEmptyPasswd, sRandomSeedFile, sKeepAlives, sCheckMail,
  sUseLogin, sAllowUsers, sDenyUsers, sAllowGroups, sDenyGroups,
  sIgnoreUserKnownHosts
d168 15
a182 17
static struct
{
  const char *name;
  ServerOpCodes opcode;
} keywords[] =
{
  { "port", sPort },
  { "hostkey", sHostKeyFile },
  { "serverkeybits", sServerKeyBits },
  { "logingracetime", sLoginGraceTime },
  { "keyregenerationinterval", sKeyRegenerationTime },
  { "permitrootlogin", sPermitRootLogin },
  { "syslogfacility", sLogFacility },
  { "loglevel", sLogLevel },
  { "rhostsauthentication", sRhostsAuthentication },
  { "rhostsrsaauthentication", sRhostsRSAAuthentication },
  { "rsaauthentication", sRSAAuthentication },
d184 3
a186 3
  { "kerberosauthentication", sKerberosAuthentication },
  { "kerberosorlocalpasswd", sKerberosOrLocalPasswd },
  { "kerberosticketcleanup", sKerberosTicketCleanup },
d189 2
a190 2
  { "kerberostgtpassing", sKerberosTgtPassing },
  { "afstokenpassing", sAFSTokenPassing },
d192 1
a192 1
  { "passwordauthentication", sPasswordAuthentication },
d194 1
a194 1
  { "skeyauthentication", sSkeyAuthentication },
d196 17
a212 17
  { "checkmail", sCheckMail },
  { "listenaddress", sListenAddress },
  { "printmotd", sPrintMotd },
  { "ignorerhosts", sIgnoreRhosts },
  { "ignoreuserknownhosts", sIgnoreUserKnownHosts },
  { "x11forwarding", sX11Forwarding },
  { "x11displayoffset", sX11DisplayOffset },
  { "strictmodes", sStrictModes },
  { "permitemptypasswords", sEmptyPasswd },
  { "uselogin", sUseLogin },
  { "randomseed", sRandomSeedFile },
  { "keepalive", sKeepAlives },
  { "allowusers", sAllowUsers },
  { "denyusers", sDenyUsers },
  { "allowgroups", sAllowGroups },
  { "denygroups", sDenyGroups },
  { NULL, 0 }
d218 3
a220 2
static ServerOpCodes parse_token(const char *cp, const char *filename,
				 int linenum)
d222 1
a222 1
  unsigned int i;
d224 7
a230 7
  for (i = 0; keywords[i].name; i++)
    if (strcmp(cp, keywords[i].name) == 0)
      return keywords[i].opcode;

  fprintf(stderr, "%s: line %d: Bad configuration option: %s\n", 
	  filename, linenum, cp);
  return sBadOption;
d235 2
a236 1
void read_server_config(ServerOptions *options, const char *filename)
d238 10
a247 136
  FILE *f;
  char line[1024];
  char *cp, **charptr;
  int linenum, *intptr, value;
  int bad_options = 0;
  ServerOpCodes opcode;

  f = fopen(filename, "r");
  if (!f)
    {
      perror(filename);
      exit(1);
    }

  linenum = 0;
  while (fgets(line, sizeof(line), f))
    {
      linenum++;
      cp = line + strspn(line, WHITESPACE);
      if (!*cp || *cp == '#')
	continue;
      cp = strtok(cp, WHITESPACE);
      {
	char *t = cp;
	for (; *t != 0; t++)
	  if ('A' <= *t && *t <= 'Z')
	    *t = *t - 'A' + 'a';	/* tolower */
      
      }
      opcode = parse_token(cp, filename, linenum);
      switch (opcode)
	{
	case sBadOption:
	  bad_options++;
          continue;
	case sPort:
	  intptr = &options->port;
	parse_int:
	  cp = strtok(NULL, WHITESPACE);
	  if (!cp)
	    {
	      fprintf(stderr, "%s line %d: missing integer value.\n", 
		      filename, linenum);
	      exit(1);
	    }
	  value = atoi(cp);
	  if (*intptr == -1)
	    *intptr = value;
	  break;

	case sServerKeyBits:
	  intptr = &options->server_key_bits;
	  goto parse_int;

	case sLoginGraceTime:
	  intptr = &options->login_grace_time;
	  goto parse_int;
	  
	case sKeyRegenerationTime:
	  intptr = &options->key_regeneration_time;
	  goto parse_int;

	case sListenAddress:
	  cp = strtok(NULL, WHITESPACE);
	  if (!cp)
	    {
	      fprintf(stderr, "%s line %d: missing inet addr.\n",
		      filename, linenum);
	      exit(1);
	    }
	  options->listen_addr.s_addr = inet_addr(cp);
	  break;

	case sHostKeyFile:
	  charptr = &options->host_key_file;
	  cp = strtok(NULL, WHITESPACE);
	  if (!cp)
	    {
	      fprintf(stderr, "%s line %d: missing file name.\n",
		      filename, linenum);
	      exit(1);
	    }
	  if (*charptr == NULL)
	    *charptr = tilde_expand_filename(cp, getuid());
	  break;

	case sRandomSeedFile:
	  fprintf(stderr, "%s line %d: \"randomseed\" option is obsolete.\n",
		  filename, linenum);
	  cp = strtok(NULL, WHITESPACE);
	  break;

	case sPermitRootLogin:
	  intptr = &options->permit_root_login;
	  cp = strtok(NULL, WHITESPACE);
	  if (!cp)
	    {
	      fprintf(stderr, "%s line %d: missing yes/without-password/no argument.\n",
		      filename, linenum);
	      exit(1);
	    }
	  if (strcmp(cp, "without-password") == 0)
	    value = 2;
	  else if (strcmp(cp, "yes") == 0)
	    value = 1;
	  else if (strcmp(cp, "no") == 0)
	    value = 0;
	  else
	    {
	      fprintf(stderr, "%s line %d: Bad yes/without-password/no argument: %s\n", 
	      	filename, linenum, cp);
	      exit(1);
	    }
	  if (*intptr == -1)
	    *intptr = value;
	  break;

	case sIgnoreRhosts:
	  intptr = &options->ignore_rhosts;
	parse_flag:
	  cp = strtok(NULL, WHITESPACE);
	  if (!cp)
	    {
	      fprintf(stderr, "%s line %d: missing yes/no argument.\n",
		      filename, linenum);
	      exit(1);
	    }
	  if (strcmp(cp, "yes") == 0)
	    value = 1;
	  else
	    if (strcmp(cp, "no") == 0)
	      value = 0;
	    else
	      {
		fprintf(stderr, "%s line %d: Bad yes/no argument: %s\n", 
			filename, linenum, cp);
d249 135
a383 21
	      }
	  if (*intptr == -1)
	    *intptr = value;
	  break;

	case sIgnoreUserKnownHosts:
	  intptr = &options->ignore_user_known_hosts;
	  goto parse_int;

	case sRhostsAuthentication:
	  intptr = &options->rhosts_authentication;
	  goto parse_flag;

	case sRhostsRSAAuthentication:
	  intptr = &options->rhosts_rsa_authentication;
	  goto parse_flag;
	  
	case sRSAAuthentication:
	  intptr = &options->rsa_authentication;
	  goto parse_flag;
	  
d385 11
a395 11
	case sKerberosAuthentication:
	  intptr = &options->kerberos_authentication;
	  goto parse_flag;
	  
 	case sKerberosOrLocalPasswd:
 	  intptr = &options->kerberos_or_local_passwd;
 	  goto parse_flag;

	case sKerberosTicketCleanup:
	  intptr = &options->kerberos_ticket_cleanup;
	  goto parse_flag;
d397 1
a397 1
	  
d399 16
a414 16
	case sKerberosTgtPassing:
	  intptr = &options->kerberos_tgt_passing;
	  goto parse_flag;

	case sAFSTokenPassing:
	  intptr = &options->afs_token_passing;
	  goto parse_flag;
#endif

	case sPasswordAuthentication:
	  intptr = &options->password_authentication;
	  goto parse_flag;

        case sCheckMail:
          intptr = &options->check_mail;
          goto parse_flag;
d417 103
a519 63
	case sSkeyAuthentication:
	  intptr = &options->skey_authentication;
	  goto parse_flag;
#endif

	case sPrintMotd:
	  intptr = &options->print_motd;
	  goto parse_flag;

	case sX11Forwarding:
	  intptr = &options->x11_forwarding;
	  goto parse_flag;

	case sX11DisplayOffset:
	  intptr = &options->x11_display_offset;
	  goto parse_int;

	case sStrictModes:
	  intptr = &options->strict_modes;
	  goto parse_flag;

	case sKeepAlives:
	  intptr = &options->keepalives;
	  goto parse_flag;
	  
	case sEmptyPasswd:
	  intptr = &options->permit_empty_passwd;
	  goto parse_flag;

        case sUseLogin:
          intptr = &options->use_login;
          goto parse_flag;

	case sLogFacility:
	  intptr = (int *)&options->log_facility;
	  cp = strtok(NULL, WHITESPACE);
	  value = log_facility_number(cp);
	  if (value == (SyslogFacility)-1)
	    fatal("%.200s line %d: unsupported log facility '%s'\n",
      	      filename, linenum, cp ? cp : "<NONE>");
	  if (*intptr == -1)
	    *intptr = (SyslogFacility)value;
	  break;

	case sLogLevel:
	  intptr = (int *)&options->log_level;
	  cp = strtok(NULL, WHITESPACE);
	  value = log_level_number(cp);
	  if (value == (LogLevel)-1)
	    fatal("%.200s line %d: unsupported log level '%s'\n",
      	      filename, linenum, cp ? cp : "<NONE>");
	  if (*intptr == -1)
	    *intptr = (LogLevel)value;
	  break;
	  
	case sAllowUsers:
	  while ((cp = strtok(NULL, WHITESPACE)))
	    {
	      if (options->num_allow_users >= MAX_ALLOW_USERS)
		{
		  fprintf(stderr, "%s line %d: too many allow users.\n",
			  filename, linenum);
		  exit(1);
d521 4
a524 12
	      options->allow_users[options->num_allow_users++] = xstrdup(cp);
	    }
	  break;

	case sDenyUsers:
	  while ((cp = strtok(NULL, WHITESPACE)))
	    {
	      if (options->num_deny_users >= MAX_DENY_USERS)
		{
		  fprintf(stderr, "%s line %d: too many deny users.\n",
			  filename, linenum);
		  exit(1);
a525 34
	      options->deny_users[options->num_deny_users++] = xstrdup(cp);
	    }
	  break;

	case sAllowGroups:
	  while ((cp = strtok(NULL, WHITESPACE)))
	    {
	      if (options->num_allow_groups >= MAX_ALLOW_GROUPS)
		{
		  fprintf(stderr, "%s line %d: too many allow groups.\n",
			  filename, linenum);
		  exit(1);
		}
	      options->allow_groups[options->num_allow_groups++] = xstrdup(cp);
	    }
	  break;

	case sDenyGroups:
	  while ((cp = strtok(NULL, WHITESPACE)))
	    {
	      if (options->num_deny_groups >= MAX_DENY_GROUPS)
		{
		  fprintf(stderr, "%s line %d: too many deny groups.\n",
			  filename, linenum);
		  exit(1);
		}
	      options->deny_groups[options->num_deny_groups++] = xstrdup(cp);
	    }
	  break;

	default:
	  fprintf(stderr, "%s line %d: Missing handler for opcode %s (%d)\n",
		  filename, linenum, cp, opcode);
	  exit(1);
d527 5
a531 5
      if (strtok(NULL, WHITESPACE) != NULL)
	{
	  fprintf(stderr, "%s line %d: garbage at end of line.\n",
		  filename, linenum);
	  exit(1);
a532 7
    }
  fclose(f);
  if (bad_options > 0) {
    fprintf(stderr, "%s: terminating, %d bad configuration options\n", 
	    filename, bad_options);
    exit(1);
  }
@


1.23
log
@bugfix: loglevels are per host in clientconfig,
factor out common log-level parsing code.
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.22 1999/11/11 23:26:53 markus Exp $");
d241 1
a241 1
  int linenum, *intptr, i, value;
@


1.22
log
@print _all_ bad options found in configfile
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.21 1999/11/11 22:58:38 markus Exp $");
a216 35
static struct 
{
  const char *name;
  SyslogFacility facility;
} log_facilities[] =
{
  { "DAEMON", SYSLOG_FACILITY_DAEMON },
  { "USER", SYSLOG_FACILITY_USER },
  { "AUTH", SYSLOG_FACILITY_AUTH },
  { "LOCAL0", SYSLOG_FACILITY_LOCAL0 },
  { "LOCAL1", SYSLOG_FACILITY_LOCAL1 },
  { "LOCAL2", SYSLOG_FACILITY_LOCAL2 },
  { "LOCAL3", SYSLOG_FACILITY_LOCAL3 },
  { "LOCAL4", SYSLOG_FACILITY_LOCAL4 },
  { "LOCAL5", SYSLOG_FACILITY_LOCAL5 },
  { "LOCAL6", SYSLOG_FACILITY_LOCAL6 },
  { "LOCAL7", SYSLOG_FACILITY_LOCAL7 },
  { NULL, 0 }
};

static struct 
{
  const char *name;
  LogLevel level;
} log_levels[] =
{
  { "QUIET", SYSLOG_LEVEL_QUIET },
  { "FATAL", SYSLOG_LEVEL_FATAL },
  { "ERROR", SYSLOG_LEVEL_ERROR },
  { "INFO",  SYSLOG_LEVEL_INFO },
  { "CHAT",  SYSLOG_LEVEL_CHAT },
  { "DEBUG", SYSLOG_LEVEL_DEBUG },
  { NULL, 0 }
};

d463 1
d465 6
a470 17
	  if (!cp)
	    {
	      fprintf(stderr, "%s line %d: missing facility name.\n",
		      filename, linenum);
	      exit(1);
	    }
	  for (i = 0; log_facilities[i].name; i++)
	    if (strcasecmp(log_facilities[i].name, cp) == 0)
	      break;
	  if (!log_facilities[i].name)
	    {
	      fprintf(stderr, "%s line %d: unsupported log facility %s\n",
		      filename, linenum, cp);
	      exit(1);
	    }
	  if (options->log_facility == (SyslogFacility)(-1))
	    options->log_facility = log_facilities[i].facility;
d474 1
d476 6
a481 17
	  if (!cp)
	    {
	      fprintf(stderr, "%s line %d: missing level name.\n",
		      filename, linenum);
	      exit(1);
	    }
	  for (i = 0; log_levels[i].name; i++)
	    if (strcasecmp(log_levels[i].name, cp) == 0)
	      break;
	  if (!log_levels[i].name)
	    {
	      fprintf(stderr, "%s line %d: unsupported log level %s\n",
		      filename, linenum, cp);
	      exit(1);
	    }
	  if (options->log_level == (LogLevel)(-1))
	    options->log_level = log_levels[i].level;
@


1.21
log
@IgnoreUserKnownHosts(default=no), used for RhostRSAAuth, ok deraadt,millert
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.20 1999/11/10 23:36:44 markus Exp $");
d147 1
d264 1
a264 1
  fprintf(stderr, "%s line %d: Bad configuration option: %s\n", 
d266 1
a266 1
  exit(1);
d277 1
d305 3
d604 5
@


1.20
log
@add LogLevel {QUIET, FATAL, ERROR, INFO, CHAT, DEBUG} to ssh/sshd,
obsoletes QuietMode and FascistLogging in sshd.
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.19 1999/10/25 21:35:25 markus Exp $");
d34 1
d92 2
d162 2
a163 2
  sUseLogin, sAllowUsers, sDenyUsers, sAllowGroups, sDenyGroups

d201 1
d409 5
a413 1
	  
@


1.19
log
@server-logs default to AUTH (consistence with sample sshd_config)
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.18 1999/10/17 23:09:16 dugsong Exp $");
a33 2
  options->quiet_mode = -1;
  options->fascist_logging = -1;
d41 1
a90 2
  if (options->quiet_mode == -1)
    options->quiet_mode = 0;
a92 2
  if (options->fascist_logging == -1)
    options->fascist_logging = 1;
d105 2
d145 1
a145 1
  sPermitRootLogin, sQuietMode, sFascistLogging, sLogFacility,
a175 2
  { "quietmode", sQuietMode },
  { "fascistlogging", sFascistLogging },
d177 1
d232 15
a405 8
	case sQuietMode:
	  intptr = &options->quiet_mode;
	  goto parse_flag;

	case sFascistLogging:
	  intptr = &options->fascist_logging;
	  goto parse_flag;

d493 1
a493 1
	    if (strcmp(log_facilities[i].name, cp) == 0)
d503 21
@


1.18
log
@default KerberosOrLocalPassword to 'yes'
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.17 1999/10/17 20:48:07 dugsong Exp $");
d109 1
a109 1
    options->log_facility = SYSLOG_FACILITY_DAEMON;
@


1.17
log
@remove AllowHosts, DenyHosts, SilentDeny server access control cruft - replace with LIBWRAP moved to child. ok markus@@ deraat@@
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.16 1999/10/14 20:17:24 markus Exp $");
d120 1
a120 1
    options->kerberos_or_local_passwd = 0;
@


1.16
log
@refuse to start if there is no configuration file for sshd. ok: deraadt
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.15 1999/10/14 19:56:02 markus Exp $");
a60 3
  options->silent_deny = -1;
  options->num_allow_hosts = 0;
  options->num_deny_hosts = 0;
a139 2
  if (options->silent_deny == -1)
    options->silent_deny = 0;
d159 1
a159 1
  sPasswordAuthentication, sAllowHosts, sDenyHosts, sListenAddress,
d162 1
a162 1
  sUseLogin, sSilentDeny, sAllowUsers, sDenyUsers, sAllowGroups, sDenyGroups
a197 1
  { "allowhosts", sAllowHosts },
a198 1
  { "denyhosts", sDenyHosts },
a206 1
  { "silentdeny", sSilentDeny },
a480 4
        case sSilentDeny:
          intptr = &options->silent_deny;
          goto parse_flag;

a501 26
	case sAllowHosts:
	  while ((cp = strtok(NULL, WHITESPACE)))
	    {
	      if (options->num_allow_hosts >= MAX_ALLOW_HOSTS)
		{
		  fprintf(stderr, "%s line %d: too many allow hosts.\n",
			  filename, linenum);
		  exit(1);
		}
	      options->allow_hosts[options->num_allow_hosts++] = xstrdup(cp);
	    }
	  break;

	case sDenyHosts:
	  while ((cp = strtok(NULL, WHITESPACE)))
	    {
	      if (options->num_deny_hosts >= MAX_DENY_HOSTS)
		{
		  fprintf(stderr, "%s line %d: too many deny hosts.\n",
			  filename, linenum);
		  exit(1);
		}
	      options->deny_hosts[options->num_deny_hosts++] = xstrdup(cp);
	    }
	  break;

@


1.15
log
@PermitRootLogin={yes,no,without-password}, default=yes, ok deraadt,niels
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.14 1999/10/12 18:11:54 markus Exp $");
d275 1
a275 1
      return;
@


1.14
log
@SilentDeny, don't log/answer refused connections, deraadt@@
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.13 1999/10/11 21:48:29 markus Exp $");
d92 1
a92 1
    options->permit_root_login = 1;
d355 25
a401 4

	case sIgnoreRhosts:
	  intptr = &options->ignore_rhosts;
	  goto parse_flag;
@


1.13
log
@Allow/Deny Users/Groups, from zzlevo@@dd.chalmers.se, ok deraadt@@
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.12 1999/10/11 21:07:37 markus Exp $");
d61 1
d143 2
d167 1
a167 1
  sUseLogin, sAllowUsers, sDenyUsers, sAllowGroups, sDenyGroups
d214 1
d466 4
@


1.12
log
@UseLogin, default=no, from kpa@@gmx.net, ok deraadt@@
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.11 1999/10/07 22:46:32 markus Exp $");
d63 4
d164 2
a165 1
  sUseLogin
d213 4
d508 52
@


1.11
log
@You have Mail. Email fuer Dich. Karsten Patzwaldt <kpa@@gmx.net> default=no
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.10 1999/10/07 21:45:02 markus Exp $");
d60 1
d136 2
d159 2
a160 1
  sStrictModes, sEmptyPasswd, sRandomSeedFile, sKeepAlives, sCheckMail
d205 1
d450 4
@


1.10
log
@add skey to sshd:

1) pass *pw to auth_password() not user_name, do_authentication already
   keeps private copy of struct passwd for current user.
2) limit authentication attemps to 5, otherwise
        ssh -o 'NumberOfPasswordPrompts 100000' host
   lets you enter 100000 passwds
3) make s/key a run-time option in /etc/sshd_config
4) generate fake skeys,
   for s/key for nonexisting users, too
   limit auth-tries for nonexisting users, too.
Note that
% ssh -l nonexisting-user -o 'NumberOfPasswordPrompts 100000' host
has NO limits in ssh-1.2.27
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.9 1999/10/02 19:18:22 deraadt Exp $");
d37 1
d91 2
d156 1
a156 1
  sStrictModes, sEmptyPasswd, sRandomSeedFile, sKeepAlives
d192 1
d411 4
@


1.9
log
@Wall
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.8 1999/10/01 22:23:48 deraadt Exp $");
d55 3
d126 4
d131 1
a131 1
      options->permit_empty_passwd = 1;
d148 3
d185 3
d407 6
@


1.8
log
@randomseed is really gone now
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.7 1999/10/01 02:38:09 provos Exp $");
a300 1
	parse_pathname:
@


1.7
log
@get rid of references to randomseedfile we dont need it.  for sshd
just spit out a warning that the configuration option is obsolete.
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.6 1999/09/30 05:11:29 deraadt Exp $");
d314 1
a314 1
	  fprintf(stderr, "%s line %d: option is obsolete.\n",
@


1.6
log
@do not bother with dinosaur pacification
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.5 1999/09/29 22:08:13 dugsong Exp $");
a28 1
  options->random_seed_file = NULL;
a74 2
  if (options->random_seed_file == NULL)
    options->random_seed_file = SSH_DAEMON_SEED_FILE;
d314 4
a317 2
	  charptr = &options->random_seed_file;
	  goto parse_pathname;
@


1.5
log
@fix server krb4 option initialization
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.4 1999/09/29 18:16:20 dugsong Exp $");
a298 3
#ifdef BROKEN_INET_ADDR
	  options->listen_addr.s_addr = inet_network(cp);
#else /* BROKEN_INET_ADDR */
a299 1
#endif /* BROKEN_INET_ADDR */
@


1.4
log
@update krb4/AFS support to ssh-1.2.27-afs-kerberos-pl1 level, clean up unused variables, update manpages
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.3 1999/09/29 00:10:16 deraadt Exp $");
d112 1
a112 1
    options->kerberos_authentication = 1;
d122 1
a122 1
    options->afs_token_passing = 1;
@


1.3
log
@GatewayPorts and ssh -g; markus.friedl@@informatik.uni-erlangen.de
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.2 1999/09/28 07:56:47 deraadt Exp $");
a48 2
#endif
#if defined(KRB4) || defined(AFS)
d51 1
a51 1
#ifdef KERBEROS_TGT_PASSING
a52 2
#endif
#ifdef AFS
a114 2
#endif
#if defined(KRB4) || defined(AFS)
d117 2
a118 2
#endif
#ifdef KERBEROS_TGT_PASSING
a120 2
#endif
#ifdef AFS
d123 1
a123 1
#endif
d139 1
a139 7
  sKerberosAuthentication, sKerberosOrLocalPasswd,
#endif
#if defined(KRB4) || defined(AFS)
  sKerberosTicketCleanup,
#endif
#ifdef KERBEROS_TGT_PASSING
  sKerberosTgtPassing,
d142 1
a142 1
  sAFSTokenPassing,
a170 2
#endif
#if defined(KRB4) || defined(AFS)
d173 1
a173 1
#ifdef KERBEROS_TGT_PASSING
a174 2
#endif
#ifdef AFS
a380 1
#endif
a381 1
#if defined(KRB4) || defined(AFS)
d387 1
a387 1
#ifdef KERBEROS_TGT_PASSING
a390 1
#endif
a391 1
#ifdef AFS
@


1.2
log
@X11DisplayOffset; aaron
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.1 1999/09/26 20:53:37 deraadt Exp $");
d27 1
a27 1
  options->listen_addr.s_addr = INADDR_ANY;
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d15 1
a15 1
RCSID("$Id: servconf.c,v 1.8 1999/06/12 09:22:04 bg Exp $");
d39 1
d100 2
d159 1
a159 1
  sPrintMotd, sIgnoreRhosts, sX11Forwarding,
d202 1
d430 4
@

