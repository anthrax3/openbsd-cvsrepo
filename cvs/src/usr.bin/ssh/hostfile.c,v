head	1.71;
access;
symbols
	OPENBSD_6_2_BASE:1.71
	OPENBSD_6_1:1.68.0.4
	OPENBSD_6_1_BASE:1.68
	OPENBSD_6_0:1.66.0.8
	OPENBSD_6_0_BASE:1.66
	OPENBSD_5_9:1.66.0.4
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.66.0.2
	OPENBSD_5_8_BASE:1.66
	OPENBSD_5_7:1.64.0.2
	OPENBSD_5_7_BASE:1.64
	OPENBSD_5_6:1.57.0.4
	OPENBSD_5_6_BASE:1.57
	OPENBSD_5_5:1.55.0.4
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.52.0.2
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.50.0.10
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.50.0.8
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.6
	OPENBSD_5_0:1.50.0.4
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.48.0.4
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.48.0.2
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.45.0.16
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.12
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.45.0.10
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.45.0.8
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.45.0.6
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.45.0.4
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.34.0.2
	OPENBSD_3_7_BASE:1.34
	OPENBSD_3_6:1.32.0.4
	OPENBSD_3_6_BASE:1.32
	OPENBSD_3_5:1.32.0.2
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	OPENBSD_3_3:1.30.0.4
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	OPENBSD_3_0:1.28.0.2
	OPENBSD_3_0_BASE:1.28
	OPENBSD_2_9_BASE:1.26
	OPENBSD_2_9:1.26.0.2
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.18.0.2
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.71
date	2017.05.31.09.15.42;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	zCd5GrUCVAe14Y6J;

1.70
date	2017.04.30.23.18.44;	author djm;	state Exp;
branches;
next	1.69;
commitid	NPnVhZTcf5ddO7Ys;

1.69
date	2017.04.30.23.10.43;	author djm;	state Exp;
branches;
next	1.68;
commitid	I15vriCkYNtbTkea;

1.68
date	2017.03.10.04.26.06;	author djm;	state Exp;
branches;
next	1.67;
commitid	OsKbkEZNWapKjTtj;

1.67
date	2016.09.17.18.00.27;	author tedu;	state Exp;
branches;
next	1.66;
commitid	1NFGN0hoIUPAnf1P;

1.66
date	2015.05.04.06.10.48;	author djm;	state Exp;
branches;
next	1.65;
commitid	KfZDG8r2EByk0YBR;

1.65
date	2015.03.31.22.57.06;	author djm;	state Exp;
branches;
next	1.64;
commitid	e163ZHzkNucRoTmS;

1.64
date	2015.02.16.22.08.57;	author djm;	state Exp;
branches;
next	1.63;
commitid	iBG3mh48h4UsmNe0;

1.63
date	2015.01.26.13.36.53;	author djm;	state Exp;
branches;
next	1.62;
commitid	9hm2IFRDHJmDUqje;

1.62
date	2015.01.26.03.04.45;	author djm;	state Exp;
branches;
next	1.61;
commitid	Xp9DfQmHQHbZ815k;

1.61
date	2015.01.18.21.48.09;	author djm;	state Exp;
branches;
next	1.60;
commitid	nj0ZFaBiGEjcA3Ru;

1.60
date	2015.01.18.21.40.23;	author djm;	state Exp;
branches;
next	1.59;
commitid	kf1j4R9wpxfflwLe;

1.59
date	2015.01.15.09.40.00;	author djm;	state Exp;
branches;
next	1.58;
commitid	akRUKeZEbb3ylbKG;

1.58
date	2014.10.20.03.43.01;	author djm;	state Exp;
branches;
next	1.57;
commitid	3KkHJHsT9el8t9AQ;

1.57
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.56;
commitid	1h9UxAQmwdaqUzyX;

1.56
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2014.01.27.18.58.14;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2014.01.09.23.20.00;	author djm;	state Exp;
branches;
next	1.52;

1.52
date	2013.07.12.00.19.58;	author djm;	state Exp;
branches;
next	1.51;

1.51
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.50;

1.50
date	2010.12.04.13.31.37;	author djm;	state Exp;
branches;
next	1.49;

1.49
date	2010.11.29.23.45.51;	author djm;	state Exp;
branches;
next	1.48;

1.48
date	2010.03.04.10.36.03;	author djm;	state Exp;
branches;
next	1.47;

1.47
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.11.23.03.15;	author djm;	state Exp;
branches;
next	1.45;

1.45
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.43;

1.43
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.42;

1.42
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.05.02.42.09;	author stevesk;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.19.02.23.26;	author djm;	state Exp;
branches;
next	1.37;

1.37
date	2006.02.07.03.47.05;	author stevesk;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2005.11.22.03.36.03;	author dtucker;	state Exp;
branches;
next	1.35;

1.35
date	2005.07.27.10.39.03;	author dtucker;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2005.03.10.22.01.05;	author deraadt;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2005.03.01.10.40.26;	author djm;	state Exp;
branches;
next	1.32;

1.32
date	2003.11.10.16.23.41;	author jakob;	state Exp;
branches
	1.32.2.1
	1.32.4.1;
next	1.31;

1.31
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2002.07.24.16.11.18;	author markus;	state Exp;
branches
	1.30.2.1
	1.30.4.1;
next	1.29;

1.29
date	2001.12.18.10.04.21;	author jakob;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2001.06.25.08.25.37;	author markus;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2001.06.23.15.12.18;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.12.19.15.24;	author markus;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2001.04.06.22.12.47;	author stevesk;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.21.19.05.49;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2000.12.21.15.10.16;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2000.12.19.23.17.56;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.12.19.50.37;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.07.20.27.51;	author deraadt;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2000.06.06.19.32.13;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.29.18.11.52;	author markus;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2000.04.26.20.56.29;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.14.10.30.31;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.12.09.39.10;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.23.22.15.33;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.18.10.20.20;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.16.13.18.51;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.04.00.07.59;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	99.12.02.20.18.59;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.11.24.19.53.47;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	99.11.24.00.26.02;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.11.23.22.25.53;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.11.16.15.44.41;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	99.11.15.20.53.24;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	99.11.02.19.42.36;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	99.10.03.21.50.03;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.04.45.36;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.36;	author deraadt;	state Exp;
branches;
next	;

1.18.2.1
date	2000.06.12.02.37.33;	author jason;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2000.09.01.18.23.20;	author jason;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2000.11.08.21.30.49;	author jason;	state Exp;
branches;
next	1.18.2.4;

1.18.2.4
date	2001.03.12.15.44.10;	author jason;	state Exp;
branches;
next	1.18.2.5;

1.18.2.5
date	2001.03.21.18.52.46;	author jason;	state Exp;
branches;
next	;

1.20.2.1
date	2001.02.16.20.13.03;	author jason;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2001.02.19.17.18.57;	author jason;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2001.03.21.19.46.25;	author jason;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2001.05.07.21.09.29;	author jason;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.26.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	;

1.28.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.29.2.1
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	;

1.30.2.1
date	2003.09.16.21.20.25;	author brad;	state Exp;
branches;
next	;

1.30.4.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.30.4.2;

1.30.4.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.31.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	;

1.32.2.1
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.32.4.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.32.4.2;

1.32.4.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	1.32.4.3;

1.32.4.3
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.34.2.1
date	2005.09.04.18.40.02;	author brad;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.35.2.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.37.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.71
log
@Switch to recallocarray() for a few operations.  Both growth and shrinkage
are handled safely, and there also is no need for preallocation dances.
Future changes in this area will be less error prone.
Review and one bug found by markus
@
text
@/* $OpenBSD: hostfile.c,v 1.70 2017/04/30 23:18:44 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Functions for manipulating the known hosts files.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
 * Copyright (c) 1999, 2000 Markus Friedl.  All rights reserved.
 * Copyright (c) 1999 Niels Provos.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <netinet/in.h>

#include <errno.h>
#include <resolv.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>

#include "xmalloc.h"
#include "match.h"
#include "sshkey.h"
#include "hostfile.h"
#include "log.h"
#include "misc.h"
#include "ssherr.h"
#include "digest.h"
#include "hmac.h"

struct hostkeys {
	struct hostkey_entry *entries;
	u_int num_entries;
};

/* XXX hmac is too easy to dictionary attack; use bcrypt? */

static int
extract_salt(const char *s, u_int l, u_char *salt, size_t salt_len)
{
	char *p, *b64salt;
	u_int b64len;
	int ret;

	if (l < sizeof(HASH_MAGIC) - 1) {
		debug2("extract_salt: string too short");
		return (-1);
	}
	if (strncmp(s, HASH_MAGIC, sizeof(HASH_MAGIC) - 1) != 0) {
		debug2("extract_salt: invalid magic identifier");
		return (-1);
	}
	s += sizeof(HASH_MAGIC) - 1;
	l -= sizeof(HASH_MAGIC) - 1;
	if ((p = memchr(s, HASH_DELIM, l)) == NULL) {
		debug2("extract_salt: missing salt termination character");
		return (-1);
	}

	b64len = p - s;
	/* Sanity check */
	if (b64len == 0 || b64len > 1024) {
		debug2("extract_salt: bad encoded salt length %u", b64len);
		return (-1);
	}
	b64salt = xmalloc(1 + b64len);
	memcpy(b64salt, s, b64len);
	b64salt[b64len] = '\0';

	ret = __b64_pton(b64salt, salt, salt_len);
	free(b64salt);
	if (ret == -1) {
		debug2("extract_salt: salt decode error");
		return (-1);
	}
	if (ret != (int)ssh_hmac_bytes(SSH_DIGEST_SHA1)) {
		debug2("extract_salt: expected salt len %zd, got %d",
		    ssh_hmac_bytes(SSH_DIGEST_SHA1), ret);
		return (-1);
	}

	return (0);
}

char *
host_hash(const char *host, const char *name_from_hostfile, u_int src_len)
{
	struct ssh_hmac_ctx *ctx;
	u_char salt[256], result[256];
	char uu_salt[512], uu_result[512];
	static char encoded[1024];
	u_int len;

	len = ssh_digest_bytes(SSH_DIGEST_SHA1);

	if (name_from_hostfile == NULL) {
		/* Create new salt */
		arc4random_buf(salt, len);
	} else {
		/* Extract salt from known host entry */
		if (extract_salt(name_from_hostfile, src_len, salt,
		    sizeof(salt)) == -1)
			return (NULL);
	}

	if ((ctx = ssh_hmac_start(SSH_DIGEST_SHA1)) == NULL ||
	    ssh_hmac_init(ctx, salt, len) < 0 ||
	    ssh_hmac_update(ctx, host, strlen(host)) < 0 ||
	    ssh_hmac_final(ctx, result, sizeof(result)))
		fatal("%s: ssh_hmac failed", __func__);
	ssh_hmac_free(ctx);

	if (__b64_ntop(salt, len, uu_salt, sizeof(uu_salt)) == -1 ||
	    __b64_ntop(result, len, uu_result, sizeof(uu_result)) == -1)
		fatal("%s: __b64_ntop failed", __func__);

	snprintf(encoded, sizeof(encoded), "%s%s%c%s", HASH_MAGIC, uu_salt,
	    HASH_DELIM, uu_result);

	return (encoded);
}

/*
 * Parses an RSA (number of bits, e, n) or DSA key from a string.  Moves the
 * pointer over the key.  Skips any whitespace at the beginning and at end.
 */

int
hostfile_read_key(char **cpp, u_int *bitsp, struct sshkey *ret)
{
	char *cp;
	int r;

	/* Skip leading whitespace. */
	for (cp = *cpp; *cp == ' ' || *cp == '\t'; cp++)
		;

	if ((r = sshkey_read(ret, &cp)) != 0)
		return 0;

	/* Skip trailing whitespace. */
	for (; *cp == ' ' || *cp == '\t'; cp++)
		;

	/* Return results. */
	*cpp = cp;
	if (bitsp != NULL)
		*bitsp = sshkey_size(ret);
	return 1;
}

static HostkeyMarker
check_markers(char **cpp)
{
	char marker[32], *sp, *cp = *cpp;
	int ret = MRK_NONE;

	while (*cp == '@@') {
		/* Only one marker is allowed */
		if (ret != MRK_NONE)
			return MRK_ERROR;
		/* Markers are terminated by whitespace */
		if ((sp = strchr(cp, ' ')) == NULL &&
		    (sp = strchr(cp, '\t')) == NULL)
			return MRK_ERROR;
		/* Extract marker for comparison */
		if (sp <= cp + 1 || sp >= cp + sizeof(marker))
			return MRK_ERROR;
		memcpy(marker, cp, sp - cp);
		marker[sp - cp] = '\0';
		if (strcmp(marker, CA_MARKER) == 0)
			ret = MRK_CA;
		else if (strcmp(marker, REVOKE_MARKER) == 0)
			ret = MRK_REVOKE;
		else
			return MRK_ERROR;

		/* Skip past marker and any whitespace that follows it */
		cp = sp;
		for (; *cp == ' ' || *cp == '\t'; cp++)
			;
	}
	*cpp = cp;
	return ret;
}

struct hostkeys *
init_hostkeys(void)
{
	struct hostkeys *ret = xcalloc(1, sizeof(*ret));

	ret->entries = NULL;
	return ret;
}

struct load_callback_ctx {
	const char *host;
	u_long num_loaded;
	struct hostkeys *hostkeys;
};

static int
record_hostkey(struct hostkey_foreach_line *l, void *_ctx)
{
	struct load_callback_ctx *ctx = (struct load_callback_ctx *)_ctx;
	struct hostkeys *hostkeys = ctx->hostkeys;
	struct hostkey_entry *tmp;

	if (l->status == HKF_STATUS_INVALID) {
		/* XXX make this verbose() in the future */
		debug("%s:%ld: parse error in hostkeys file",
		    l->path, l->linenum);
		return 0;
	}

	debug3("%s: found %skey type %s in file %s:%lu", __func__,
	    l->marker == MRK_NONE ? "" :
	    (l->marker == MRK_CA ? "ca " : "revoked "),
	    sshkey_type(l->key), l->path, l->linenum);
	if ((tmp = recallocarray(hostkeys->entries, hostkeys->num_entries,
	    hostkeys->num_entries + 1, sizeof(*hostkeys->entries))) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	hostkeys->entries = tmp;
	hostkeys->entries[hostkeys->num_entries].host = xstrdup(ctx->host);
	hostkeys->entries[hostkeys->num_entries].file = xstrdup(l->path);
	hostkeys->entries[hostkeys->num_entries].line = l->linenum;
	hostkeys->entries[hostkeys->num_entries].key = l->key;
	l->key = NULL; /* steal it */
	hostkeys->entries[hostkeys->num_entries].marker = l->marker;
	hostkeys->num_entries++;
	ctx->num_loaded++;

	return 0;
}

void
load_hostkeys(struct hostkeys *hostkeys, const char *host, const char *path)
{
	int r;
	struct load_callback_ctx ctx;

	ctx.host = host;
	ctx.num_loaded = 0;
	ctx.hostkeys = hostkeys;

	if ((r = hostkeys_foreach(path, record_hostkey, &ctx, host, NULL,
	    HKF_WANT_MATCH|HKF_WANT_PARSE_KEY)) != 0) {
		if (r != SSH_ERR_SYSTEM_ERROR && errno != ENOENT)
			debug("%s: hostkeys_foreach failed for %s: %s",
			    __func__, path, ssh_err(r));
	}
	if (ctx.num_loaded != 0)
		debug3("%s: loaded %lu keys from %s", __func__,
		    ctx.num_loaded, host);
}

void
free_hostkeys(struct hostkeys *hostkeys)
{
	u_int i;

	for (i = 0; i < hostkeys->num_entries; i++) {
		free(hostkeys->entries[i].host);
		free(hostkeys->entries[i].file);
		sshkey_free(hostkeys->entries[i].key);
		explicit_bzero(hostkeys->entries + i, sizeof(*hostkeys->entries));
	}
	free(hostkeys->entries);
	explicit_bzero(hostkeys, sizeof(*hostkeys));
	free(hostkeys);
}

static int
check_key_not_revoked(struct hostkeys *hostkeys, struct sshkey *k)
{
	int is_cert = sshkey_is_cert(k);
	u_int i;

	for (i = 0; i < hostkeys->num_entries; i++) {
		if (hostkeys->entries[i].marker != MRK_REVOKE)
			continue;
		if (sshkey_equal_public(k, hostkeys->entries[i].key))
			return -1;
		if (is_cert &&
		    sshkey_equal_public(k->cert->signature_key,
		    hostkeys->entries[i].key))
			return -1;
	}
	return 0;
}

/*
 * Match keys against a specified key, or look one up by key type.
 *
 * If looking for a keytype (key == NULL) and one is found then return
 * HOST_FOUND, otherwise HOST_NEW.
 *
 * If looking for a key (key != NULL):
 *  1. If the key is a cert and a matching CA is found, return HOST_OK
 *  2. If the key is not a cert and a matching key is found, return HOST_OK
 *  3. If no key matches but a key with a different type is found, then
 *     return HOST_CHANGED
 *  4. If no matching keys are found, then return HOST_NEW.
 *
 * Finally, check any found key is not revoked.
 */
static HostStatus
check_hostkeys_by_key_or_type(struct hostkeys *hostkeys,
    struct sshkey *k, int keytype, const struct hostkey_entry **found)
{
	u_int i;
	HostStatus end_return = HOST_NEW;
	int want_cert = sshkey_is_cert(k);
	HostkeyMarker want_marker = want_cert ? MRK_CA : MRK_NONE;

	if (found != NULL)
		*found = NULL;

	for (i = 0; i < hostkeys->num_entries; i++) {
		if (hostkeys->entries[i].marker != want_marker)
			continue;
		if (k == NULL) {
			if (hostkeys->entries[i].key->type != keytype)
				continue;
			end_return = HOST_FOUND;
			if (found != NULL)
				*found = hostkeys->entries + i;
			k = hostkeys->entries[i].key;
			break;
		}
		if (want_cert) {
			if (sshkey_equal_public(k->cert->signature_key,
			    hostkeys->entries[i].key)) {
				/* A matching CA exists */
				end_return = HOST_OK;
				if (found != NULL)
					*found = hostkeys->entries + i;
				break;
			}
		} else {
			if (sshkey_equal(k, hostkeys->entries[i].key)) {
				end_return = HOST_OK;
				if (found != NULL)
					*found = hostkeys->entries + i;
				break;
			}
			/* A non-maching key exists */
			end_return = HOST_CHANGED;
			if (found != NULL)
				*found = hostkeys->entries + i;
		}
	}
	if (check_key_not_revoked(hostkeys, k) != 0) {
		end_return = HOST_REVOKED;
		if (found != NULL)
			*found = NULL;
	}
	return end_return;
}

HostStatus
check_key_in_hostkeys(struct hostkeys *hostkeys, struct sshkey *key,
    const struct hostkey_entry **found)
{
	if (key == NULL)
		fatal("no key to look up");
	return check_hostkeys_by_key_or_type(hostkeys, key, 0, found);
}

int
lookup_key_in_hostkeys_by_type(struct hostkeys *hostkeys, int keytype,
    const struct hostkey_entry **found)
{
	return (check_hostkeys_by_key_or_type(hostkeys, NULL, keytype,
	    found) == HOST_FOUND);
}

static int
write_host_entry(FILE *f, const char *host, const char *ip,
    const struct sshkey *key, int store_hash)
{
	int r, success = 0;
	char *hashed_host = NULL, *lhost;

	lhost = xstrdup(host);
	lowercase(lhost);

	if (store_hash) {
		if ((hashed_host = host_hash(lhost, NULL, 0)) == NULL) {
			error("%s: host_hash failed", __func__);
			free(lhost);
			return 0;
		}
		fprintf(f, "%s ", hashed_host);
	} else if (ip != NULL)
		fprintf(f, "%s,%s ", lhost, ip);
	else {
		fprintf(f, "%s ", lhost);
	}
	free(lhost);
	if ((r = sshkey_write(key, f)) == 0)
		success = 1;
	else
		error("%s: sshkey_write failed: %s", __func__, ssh_err(r));
	fputc('\n', f);
	return success;
}

/*
 * Appends an entry to the host file.  Returns false if the entry could not
 * be appended.
 */
int
add_host_to_hostfile(const char *filename, const char *host,
    const struct sshkey *key, int store_hash)
{
	FILE *f;
	int success;

	if (key == NULL)
		return 1;	/* XXX ? */
	f = fopen(filename, "a");
	if (!f)
		return 0;
	success = write_host_entry(f, host, NULL, key, store_hash);
	fclose(f);
	return success;
}

struct host_delete_ctx {
	FILE *out;
	int quiet;
	const char *host;
	int *skip_keys; /* XXX split for host/ip? might want to ensure both */
	struct sshkey * const *keys;
	size_t nkeys;
	int modified;
};

static int
host_delete(struct hostkey_foreach_line *l, void *_ctx)
{
	struct host_delete_ctx *ctx = (struct host_delete_ctx *)_ctx;
	int loglevel = ctx->quiet ? SYSLOG_LEVEL_DEBUG1 : SYSLOG_LEVEL_VERBOSE;
	size_t i;

	if (l->status == HKF_STATUS_MATCHED) {
		if (l->marker != MRK_NONE) {
			/* Don't remove CA and revocation lines */
			fprintf(ctx->out, "%s\n", l->line);
			return 0;
		}

		/*
		 * If this line contains one of the keys that we will be
		 * adding later, then don't change it and mark the key for
		 * skipping.
		 */
		for (i = 0; i < ctx->nkeys; i++) {
			if (sshkey_equal(ctx->keys[i], l->key)) {
				ctx->skip_keys[i] = 1;
				fprintf(ctx->out, "%s\n", l->line);
				debug3("%s: %s key already at %s:%ld", __func__,
				    sshkey_type(l->key), l->path, l->linenum);
				return 0;
			}
		}

		/*
		 * Hostname matches and has no CA/revoke marker, delete it
		 * by *not* writing the line to ctx->out.
		 */
		do_log2(loglevel, "%s%s%s:%ld: Removed %s key for host %s",
		    ctx->quiet ? __func__ : "", ctx->quiet ? ": " : "",
		    l->path, l->linenum, sshkey_type(l->key), ctx->host);
		ctx->modified = 1;
		return 0;
	}
	/* Retain non-matching hosts and invalid lines when deleting */
	if (l->status == HKF_STATUS_INVALID) {
		do_log2(loglevel, "%s%s%s:%ld: invalid known_hosts entry",
		    ctx->quiet ? __func__ : "", ctx->quiet ? ": " : "",
		    l->path, l->linenum);
	}
	fprintf(ctx->out, "%s\n", l->line);
	return 0;
}

int
hostfile_replace_entries(const char *filename, const char *host, const char *ip,
    struct sshkey **keys, size_t nkeys, int store_hash, int quiet, int hash_alg)
{
	int r, fd, oerrno = 0;
	int loglevel = quiet ? SYSLOG_LEVEL_DEBUG1 : SYSLOG_LEVEL_VERBOSE;
	struct host_delete_ctx ctx;
	char *fp, *temp = NULL, *back = NULL;
	mode_t omask;
	size_t i;

	omask = umask(077);

	memset(&ctx, 0, sizeof(ctx));
	ctx.host = host;
	ctx.quiet = quiet;
	if ((ctx.skip_keys = calloc(nkeys, sizeof(*ctx.skip_keys))) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	ctx.keys = keys;
	ctx.nkeys = nkeys;
	ctx.modified = 0;

	/*
	 * Prepare temporary file for in-place deletion.
	 */
	if ((r = asprintf(&temp, "%s.XXXXXXXXXXX", filename)) < 0 ||
	    (r = asprintf(&back, "%s.old", filename)) < 0) {
		r = SSH_ERR_ALLOC_FAIL;
		goto fail;
	}

	if ((fd = mkstemp(temp)) == -1) {
		oerrno = errno;
		error("%s: mkstemp: %s", __func__, strerror(oerrno));
		r = SSH_ERR_SYSTEM_ERROR;
		goto fail;
	}
	if ((ctx.out = fdopen(fd, "w")) == NULL) {
		oerrno = errno;
		close(fd);
		error("%s: fdopen: %s", __func__, strerror(oerrno));
		r = SSH_ERR_SYSTEM_ERROR;
		goto fail;
	}

	/* Remove all entries for the specified host from the file */
	if ((r = hostkeys_foreach(filename, host_delete, &ctx, host, ip,
	    HKF_WANT_PARSE_KEY)) != 0) {
		error("%s: hostkeys_foreach failed: %s", __func__, ssh_err(r));
		goto fail;
	}

	/* Add the requested keys */
	for (i = 0; i < nkeys; i++) {
		if (ctx.skip_keys[i])
			continue;
		if ((fp = sshkey_fingerprint(keys[i], hash_alg,
		    SSH_FP_DEFAULT)) == NULL) {
			r = SSH_ERR_ALLOC_FAIL;
			goto fail;
		}
		do_log2(loglevel, "%s%sAdding new key for %s to %s: %s %s",
		    quiet ? __func__ : "", quiet ? ": " : "", host, filename,
		    sshkey_ssh_name(keys[i]), fp);
		free(fp);
		if (!write_host_entry(ctx.out, host, ip, keys[i], store_hash)) {
			r = SSH_ERR_INTERNAL_ERROR;
			goto fail;
		}
		ctx.modified = 1;
	}
	fclose(ctx.out);
	ctx.out = NULL;

	if (ctx.modified) {
		/* Backup the original file and replace it with the temporary */
		if (unlink(back) == -1 && errno != ENOENT) {
			oerrno = errno;
			error("%s: unlink %.100s: %s", __func__,
			    back, strerror(errno));
			r = SSH_ERR_SYSTEM_ERROR;
			goto fail;
		}
		if (link(filename, back) == -1) {
			oerrno = errno;
			error("%s: link %.100s to %.100s: %s", __func__,
			    filename, back, strerror(errno));
			r = SSH_ERR_SYSTEM_ERROR;
			goto fail;
		}
		if (rename(temp, filename) == -1) {
			oerrno = errno;
			error("%s: rename \"%s\" to \"%s\": %s", __func__,
			    temp, filename, strerror(errno));
			r = SSH_ERR_SYSTEM_ERROR;
			goto fail;
		}
	} else {
		/* No changes made; just delete the temporary file */
		if (unlink(temp) != 0)
			error("%s: unlink \"%s\": %s", __func__,
			    temp, strerror(errno));
	}

	/* success */
	r = 0;
 fail:
	if (temp != NULL && r != 0)
		unlink(temp);
	free(temp);
	free(back);
	if (ctx.out != NULL)
		fclose(ctx.out);
	free(ctx.skip_keys);
	umask(omask);
	if (r == SSH_ERR_SYSTEM_ERROR)
		errno = oerrno;
	return r;
}

static int
match_maybe_hashed(const char *host, const char *names, int *was_hashed)
{
	int hashed = *names == HASH_DELIM;
	const char *hashed_host;
	size_t nlen = strlen(names);

	if (was_hashed != NULL)
		*was_hashed = hashed;
	if (hashed) {
		if ((hashed_host = host_hash(host, names, nlen)) == NULL)
			return -1;
		return nlen == strlen(hashed_host) &&
		    strncmp(hashed_host, names, nlen) == 0;
	}
	return match_hostname(host, names) == 1;
}

int
hostkeys_foreach(const char *path, hostkeys_foreach_fn *callback, void *ctx,
    const char *host, const char *ip, u_int options)
{
	FILE *f;
	char line[8192], oline[8192], ktype[128];
	u_long linenum = 0;
	char *cp, *cp2;
	u_int kbits;
	int hashed;
	int s, r = 0;
	struct hostkey_foreach_line lineinfo;
	size_t l;

	memset(&lineinfo, 0, sizeof(lineinfo));
	if (host == NULL && (options & HKF_WANT_MATCH) != 0)
		return SSH_ERR_INVALID_ARGUMENT;
	if ((f = fopen(path, "r")) == NULL)
		return SSH_ERR_SYSTEM_ERROR;

	debug3("%s: reading file \"%s\"", __func__, path);
	while (read_keyfile_line(f, path, line, sizeof(line), &linenum) == 0) {
		line[strcspn(line, "\n")] = '\0';
		strlcpy(oline, line, sizeof(oline));

		sshkey_free(lineinfo.key);
		memset(&lineinfo, 0, sizeof(lineinfo));
		lineinfo.path = path;
		lineinfo.linenum = linenum;
		lineinfo.line = oline;
		lineinfo.marker = MRK_NONE;
		lineinfo.status = HKF_STATUS_OK;
		lineinfo.keytype = KEY_UNSPEC;

		/* Skip any leading whitespace, comments and empty lines. */
		for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (!*cp || *cp == '#' || *cp == '\n') {
			if ((options & HKF_WANT_MATCH) == 0) {
				lineinfo.status = HKF_STATUS_COMMENT;
				if ((r = callback(&lineinfo, ctx)) != 0)
					break;
			}
			continue;
		}

		if ((lineinfo.marker = check_markers(&cp)) == MRK_ERROR) {
			verbose("%s: invalid marker at %s:%lu",
			    __func__, path, linenum);
			if ((options & HKF_WANT_MATCH) == 0)
				goto bad;
			continue;
		}

		/* Find the end of the host name portion. */
		for (cp2 = cp; *cp2 && *cp2 != ' ' && *cp2 != '\t'; cp2++)
			;
		lineinfo.hosts = cp;
		*cp2++ = '\0';

		/* Check if the host name matches. */
		if (host != NULL) {
			if ((s = match_maybe_hashed(host, lineinfo.hosts,
			    &hashed)) == -1) {
				debug2("%s: %s:%ld: bad host hash \"%.32s\"",
				    __func__, path, linenum, lineinfo.hosts);
				goto bad;
			}
			if (s == 1) {
				lineinfo.status = HKF_STATUS_MATCHED;
				lineinfo.match |= HKF_MATCH_HOST |
				    (hashed ? HKF_MATCH_HOST_HASHED : 0);
			}
			/* Try matching IP address if supplied */
			if (ip != NULL) {
				if ((s = match_maybe_hashed(ip, lineinfo.hosts,
				    &hashed)) == -1) {
					debug2("%s: %s:%ld: bad ip hash "
					    "\"%.32s\"", __func__, path,
					    linenum, lineinfo.hosts);
					goto bad;
				}
				if (s == 1) {
					lineinfo.status = HKF_STATUS_MATCHED;
					lineinfo.match |= HKF_MATCH_IP |
					    (hashed ? HKF_MATCH_IP_HASHED : 0);
				}
			}
			/*
			 * Skip this line if host matching requested and
			 * neither host nor address matched.
			 */
			if ((options & HKF_WANT_MATCH) != 0 &&
			    lineinfo.status != HKF_STATUS_MATCHED)
				continue;
		}

		/* Got a match.  Skip host name and any following whitespace */
		for (; *cp2 == ' ' || *cp2 == '\t'; cp2++)
			;
		if (*cp2 == '\0' || *cp2 == '#') {
			debug2("%s:%ld: truncated before key type",
			    path, linenum);
			goto bad;
		}
		lineinfo.rawkey = cp = cp2;

		if ((options & HKF_WANT_PARSE_KEY) != 0) {
			/*
			 * Extract the key from the line.  This will skip
			 * any leading whitespace.  Ignore badly formatted
			 * lines.
			 */
			if ((lineinfo.key = sshkey_new(KEY_UNSPEC)) == NULL) {
				error("%s: sshkey_new failed", __func__);
				r = SSH_ERR_ALLOC_FAIL;
				break;
			}
			if (!hostfile_read_key(&cp, &kbits, lineinfo.key)) {
				goto bad;
			}
			lineinfo.keytype = lineinfo.key->type;
			lineinfo.comment = cp;
		} else {
			/* Extract and parse key type */
			l = strcspn(lineinfo.rawkey, " \t");
			if (l <= 1 || l >= sizeof(ktype) ||
			    lineinfo.rawkey[l] == '\0')
				goto bad;
			memcpy(ktype, lineinfo.rawkey, l);
			ktype[l] = '\0';
			lineinfo.keytype = sshkey_type_from_name(ktype);

			/*
			 * Assume legacy RSA1 if the first component is a short
			 * decimal number.
			 */
			if (lineinfo.keytype == KEY_UNSPEC && l < 8 &&
			    strspn(ktype, "0123456789") == l)
				goto bad;

			/*
			 * Check that something other than whitespace follows
			 * the key type. This won't catch all corruption, but
			 * it does catch trivial truncation.
			 */
			cp2 += l; /* Skip past key type */
			for (; *cp2 == ' ' || *cp2 == '\t'; cp2++)
				;
			if (*cp2 == '\0' || *cp2 == '#') {
				debug2("%s:%ld: truncated after key type",
				    path, linenum);
				lineinfo.keytype = KEY_UNSPEC;
			}
			if (lineinfo.keytype == KEY_UNSPEC) {
 bad:
				sshkey_free(lineinfo.key);
				lineinfo.key = NULL;
				lineinfo.status = HKF_STATUS_INVALID;
				if ((r = callback(&lineinfo, ctx)) != 0)
					break;
				continue;
			}
		}
		if ((r = callback(&lineinfo, ctx)) != 0)
			break;
	}
	sshkey_free(lineinfo.key);
	fclose(f);
	return r;
}
@


1.70
log
@remove KEY_RSA1

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.69 2017/04/30 23:10:43 djm Exp $ */
d251 1
a251 1
	if ((tmp = reallocarray(hostkeys->entries,
@


1.69
log
@unifdef WITH_SSH1
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.68 2017/03/10 04:26:06 djm Exp $ */
a345 1
	int proto = (k ? k->type : keytype) == KEY_RSA1 ? 1 : 2;
a350 4
		if (proto == 1 && hostkeys->entries[i].key->type != KEY_RSA1)
			continue;
		if (proto == 2 && hostkeys->entries[i].key->type == KEY_RSA1)
			continue;
a484 7
		/* XXX might need a knob for this later */
		/* Don't remove RSA1 keys */
		if (l->key->type == KEY_RSA1) {
			fprintf(ctx->out, "%s\n", l->line);
			return 0;
		}

d792 1
a792 1
			 * Assume RSA1 if the first component is a short
d797 1
a797 1
				lineinfo.keytype = KEY_RSA1;
@


1.68
log
@ensure hostname is lower-case before hashing it; bz#2591 reported by
Griff Miller II; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.67 2016/09/17 18:00:27 tedu Exp $ */
a788 12
#ifdef WITH_SSH1
				sshkey_free(lineinfo.key);
				lineinfo.key = sshkey_new(KEY_RSA1);
				if (lineinfo.key  == NULL) {
					error("%s: sshkey_new fail", __func__);
					r = SSH_ERR_ALLOC_FAIL;
					break;
				}
				if (!hostfile_read_key(&cp, &kbits,
				    lineinfo.key))
					goto bad;
#else
a789 1
#endif
@


1.67
log
@replace two arc4random loops with arc4random_buf
ok deraadt natano
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.66 2015/05/04 06:10:48 djm Exp $ */
d419 4
a422 1
	char *hashed_host = NULL;
d425 1
a425 1
		if ((hashed_host = host_hash(host, NULL, 0)) == NULL) {
d427 1
d432 5
a436 4
		fprintf(f, "%s,%s ", host, ip);
	else
		fprintf(f, "%s ", host);

@


1.66
log
@Remove pattern length argument from match_pattern_list(),
we only ever use it for strlen(pattern).

Prompted by hanno AT hboeck.de pointing an out-of-bound read
error caused by an incorrect pattern length found using AFL
and his own tools.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.65 2015/03/31 22:57:06 djm Exp $ */
d123 1
a123 1
	u_int i, len;
d129 1
a129 2
		for (i = 0; i < len; i++)
			salt[i] = arc4random();
@


1.65
log
@downgrade error() for known_hosts parse errors to debug() to quiet
warnings from ssh1 keys present when compiled !ssh1.

also identify ssh1 keys when scanning, even when compiled !ssh1

ok markus@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.64 2015/02/16 22:08:57 djm Exp $ */
d663 1
a663 1
	return match_hostname(host, names, nlen) == 1;
@


1.64
log
@Refactor hostkeys_foreach() and dependent code
Deal with IP addresses (i.e. CheckHostIP)
Don't clobber known_hosts when nothing changed
ok markus@@ as part of larger commit
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.63 2015/01/26 13:36:53 djm Exp $ */
d242 2
a243 1
		error("%s:%ld: parse error in hostkeys file",
d811 1
a811 1
#ifdef WITH_SSH1
d819 1
a819 1
#endif
@


1.63
log
@properly restore umask
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.62 2015/01/26 03:04:45 djm Exp $ */
a183 18
static int
hostfile_check_key(int bits, const struct sshkey *key, const char *host,
    const char *filename, u_long linenum)
{
#ifdef WITH_SSH1
	if (key == NULL || key->type != KEY_RSA1 || key->rsa == NULL)
		return 1;
	if (bits != BN_num_bits(key->rsa->n)) {
		logit("Warning: %s, line %lu: keysize mismatch for host %s: "
		    "actual %d vs. announced %d.",
		    filename, linenum, host, BN_num_bits(key->rsa->n), bits);
		logit("Warning: replace %d with %d in %s, line %lu.",
		    bits, BN_num_bits(key->rsa->n), filename, linenum);
	}
#endif
	return 1;
}

d277 2
a278 2
	if ((r = hostkeys_foreach(path, record_hostkey, &ctx, host,
	    HKF_WANT_MATCH_HOST|HKF_WANT_PARSE_KEY)) != 0) {
d415 1
a415 1
write_host_entry(FILE *f, const char *host,
d426 5
a430 2
	}
	fprintf(f, "%s ", store_hash ? hashed_host : host);
d456 1
a456 1
	success = write_host_entry(f, host, key, store_hash);
d465 1
a465 1
	int *skip_keys;
d468 1
d475 1
a475 1
	int loglevel = ctx->quiet ? SYSLOG_LEVEL_DEBUG1 : SYSLOG_LEVEL_INFO;
d478 1
a478 1
	if (l->status == HKF_STATUS_HOST_MATCHED) {
d511 1
a511 1
		do_log2(loglevel, "%s%s%s:%ld: Host %s removed",
d513 2
a514 1
		    l->path, l->linenum, ctx->host);
d528 2
a529 2
hostfile_replace_entries(const char *filename, const char *host,
    struct sshkey **keys, size_t nkeys, int store_hash, int quiet)
d532 1
a532 1
	int loglevel = quiet ? SYSLOG_LEVEL_DEBUG1 : SYSLOG_LEVEL_INFO;
d534 1
a534 1
	char *temp = NULL, *back = NULL;
d547 1
d573 1
a573 1
	if ((r = hostkeys_foreach(filename, host_delete, &ctx, host,
d583 10
a592 4
		do_log2(loglevel, "%s%sadd %s key to %s",
		    quiet ? __func__ : "", quiet ? ": " : NULL,
		    sshkey_type(keys[i]), filename);
		if (!write_host_entry(ctx.out, host, keys[i], store_hash)) {
d596 1
d601 28
a628 20
	/* Backup the original file and replace it with the temporary */
	if (unlink(back) == -1 && errno != ENOENT) {
		oerrno = errno;
		error("%s: unlink %.100s: %s", __func__, back, strerror(errno));
		r = SSH_ERR_SYSTEM_ERROR;
		goto fail;
	}
	if (link(filename, back) == -1) {
		oerrno = errno;
		error("%s: link %.100s to %.100s: %s", __func__, filename, back,
		    strerror(errno));
		r = SSH_ERR_SYSTEM_ERROR;
		goto fail;
	}
	if (rename(temp, filename) == -1) {
		oerrno = errno;
		error("%s: rename \"%s\" to \"%s\": %s", __func__,
		    temp, filename, strerror(errno));
		r = SSH_ERR_SYSTEM_ERROR;
		goto fail;
d630 1
d667 1
a667 1
    const char *host, u_int options)
d670 1
a670 1
	char line[8192], oline[8192];
d674 1
d677 1
d680 1
a680 1
	if (host == NULL && (options & HKF_WANT_MATCH_HOST) != 0)
d695 1
d697 1
d703 1
a703 1
			if ((options & HKF_WANT_MATCH_HOST) == 0) {
d714 1
a714 1
			if ((options & HKF_WANT_MATCH_HOST) == 0)
d727 2
a728 7
			s = match_maybe_hashed(host, lineinfo.hosts,
			    &lineinfo.was_hashed);
			if (s == 1)
				lineinfo.status = HKF_STATUS_HOST_MATCHED;
			else if ((options & HKF_WANT_MATCH_HOST) != 0)
				continue;
			else if (s == -1) {
d733 27
d766 2
a767 1
			debug2("%s:%ld: truncated before key", path, linenum);
d780 2
a781 1
				return SSH_ERR_ALLOC_FAIL;
d789 2
a790 1
					return SSH_ERR_ALLOC_FAIL;
d799 34
a832 2
			if (!hostfile_check_key(kbits, lineinfo.key, host,
			    path, linenum)) {
d834 2
@


1.62
log
@Host key rotation support.

Add a hostkeys@@openssh.com protocol extension (global request) for
a server to inform a client of all its available host key after
authentication has completed. The client may record the keys in
known_hosts, allowing it to upgrade to better host key algorithms
and a server to gracefully rotate its keys.

The client side of this is controlled by a UpdateHostkeys config
option (default on).

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.61 2015/01/18 21:48:09 djm Exp $ */
d551 2
a569 1
	omask = umask(077);
d637 1
@


1.61
log
@convert load_hostkeys() (hostkey ordering and known_host
matching) to use the new hostkey_foreach() iterator;
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.60 2015/01/18 21:40:23 djm Exp $ */
d40 1
d50 1
d432 23
d464 1
a464 2
	int r, success = 0;
	char *hashed_host = NULL;
d471 27
d499 4
a502 4
	if (store_hash) {
		if ((hashed_host = host_hash(host, NULL, 0)) == NULL) {
			error("%s: host_hash failed", __func__);
			fclose(f);
d505 96
d602 2
a603 1
	fprintf(f, "%s ", store_hash ? hashed_host : host);
d605 34
a638 8
	if ((r = sshkey_write(key, f)) != 0) {
		error("%s: saving key in %s failed: %s",
		    __func__, filename, ssh_err(r));
	} else
		success = 1;
	fputc('\n', f);
	fclose(f);
	return success;
@


1.60
log
@introduce hostkeys_foreach() to allow iteration over a
known_hosts file or controlled subset thereof. This will
allow us to pull out some ugly and duplicated code, and
will be used to implement hostkey rotation later.

feedback and ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.59 2015/01/15 09:40:00 djm Exp $ */
d244 8
a251 2
void
load_hostkeys(struct hostkeys *hostkeys, const char *host, const char *path)
d253 9
a261 14
	FILE *f;
	char line[8192];
	u_long linenum = 0, num_loaded = 0;
	char *cp, *cp2, *hashed_host;
	HostkeyMarker marker;
	struct sshkey *key;
	u_int kbits;

	if ((f = fopen(path, "r")) == NULL)
		return;
	debug3("%s: loading entries for host \"%.100s\" from file \"%s\"",
	    __func__, host, path);
	while (read_keyfile_line(f, path, line, sizeof(line), &linenum) == 0) {
		cp = line;
d263 16
a278 5
		/* Skip any leading whitespace, comments and empty lines. */
		for (; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (!*cp || *cp == '#' || *cp == '\n')
			continue;
d280 2
a281 5
		if ((marker = check_markers(&cp)) == MRK_ERROR) {
			verbose("%s: invalid marker at %s:%lu",
			    __func__, path, linenum);
			continue;
		}
d283 5
a287 3
		/* Find the end of the host name portion. */
		for (cp2 = cp; *cp2 && *cp2 != ' ' && *cp2 != '\t'; cp2++)
			;
d289 13
a301 60
		/* Check if the host name matches. */
		if (match_hostname(host, cp, (u_int) (cp2 - cp)) != 1) {
			if (*cp != HASH_DELIM)
				continue;
			hashed_host = host_hash(host, cp, (u_int) (cp2 - cp));
			if (hashed_host == NULL) {
				debug("Invalid hashed host line %lu of %s",
				    linenum, path);
				continue;
			}
			if (strncmp(hashed_host, cp, (u_int) (cp2 - cp)) != 0)
				continue;
		}

		/* Got a match.  Skip host name. */
		cp = cp2;

		/*
		 * Extract the key from the line.  This will skip any leading
		 * whitespace.  Ignore badly formatted lines.
		 */
		if ((key = sshkey_new(KEY_UNSPEC)) == NULL) {
			error("%s: sshkey_new failed", __func__);
			break;
		}
		if (!hostfile_read_key(&cp, &kbits, key)) {
			sshkey_free(key);
#ifdef WITH_SSH1
			if ((key = sshkey_new(KEY_RSA1)) == NULL) {
				error("%s: sshkey_new failed", __func__);
				break;
			}
			if (!hostfile_read_key(&cp, &kbits, key)) {
				sshkey_free(key);
				continue;
			}
#else
			continue;
#endif
		}
		if (!hostfile_check_key(kbits, key, host, path, linenum))
			continue;

		debug3("%s: found %skey type %s in file %s:%lu", __func__,
		    marker == MRK_NONE ? "" :
		    (marker == MRK_CA ? "ca " : "revoked "),
		    sshkey_type(key), path, linenum);
		hostkeys->entries = xrealloc(hostkeys->entries,
		    hostkeys->num_entries + 1, sizeof(*hostkeys->entries));
		hostkeys->entries[hostkeys->num_entries].host = xstrdup(host);
		hostkeys->entries[hostkeys->num_entries].file = xstrdup(path);
		hostkeys->entries[hostkeys->num_entries].line = linenum;
		hostkeys->entries[hostkeys->num_entries].key = key;
		hostkeys->entries[hostkeys->num_entries].marker = marker;
		hostkeys->num_entries++;
		num_loaded++;
	}
	debug3("%s: loaded %lu keys", __func__, num_loaded);
	fclose(f);
	return;
a433 1

d450 1
a450 1
			error("add_host_to_hostfile: host_hash failed");
@


1.59
log
@sync ssh-keysign, ssh-keygen and some dependencies to the new
buffer/key API; mostly mechanical, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.58 2014/10/20 03:43:01 djm Exp $ */
d43 1
d65 2
d499 1
a499 1
	fputs("\n", f);
d502 140
@


1.58
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.57 2014/06/24 01:13:21 djm Exp $ */
d51 1
a51 1
#include "key.h"
d55 1
d156 1
a156 1
hostfile_read_key(char **cpp, int *bitsp, Key *ret)
d159 1
d165 1
a165 1
	if (key_read(ret, &cp) != 1)
d174 2
a175 4
	if (bitsp != NULL) {
		if ((*bitsp = key_size(ret)) <= 0)
			return 0;
	}
d180 1
a180 1
hostfile_check_key(int bits, const Key *key, const char *host,
d249 2
a250 2
	Key *key;
	int kbits;
d296 4
a299 1
		key = key_new(KEY_UNSPEC);
d301 1
a301 1
			key_free(key);
d303 4
a306 1
			key = key_new(KEY_RSA1);
d308 1
a308 1
				key_free(key);
d321 1
a321 1
		    key_type(key), path, linenum);
d345 1
a345 1
		key_free(hostkeys->entries[i].key);
d354 1
a354 1
check_key_not_revoked(struct hostkeys *hostkeys, Key *k)
d356 1
a356 1
	int is_cert = key_is_cert(k);
d362 1
a362 1
		if (key_equal_public(k, hostkeys->entries[i].key))
d365 1
a365 1
		    key_equal_public(k->cert->signature_key,
d389 1
a389 1
    Key *k, int keytype, const struct hostkey_entry **found)
d393 1
a393 1
	int want_cert = key_is_cert(k);
d417 1
a417 1
			if (key_equal_public(k->cert->signature_key,
d426 1
a426 1
			if (key_equal(k, hostkeys->entries[i].key)) {
d447 1
a447 1
check_key_in_hostkeys(struct hostkeys *hostkeys, Key *key,
d469 2
a470 2
add_host_to_hostfile(const char *filename, const char *host, const Key *key,
    int store_hash)
d473 1
a473 1
	int success = 0;
d491 4
a494 1
	if (key_write(key, f)) {
d496 1
a496 4
	} else {
		error("add_host_to_hostfile: saving key in %s failed", filename);
	}
	fprintf(f, "\n");
@


1.57
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.56 2014/04/29 18:01:49 markus Exp $ */
d329 1
a329 1
}	
d439 1
a439 1
	
@


1.56
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.55 2014/01/31 16:39:19 tedu Exp $ */
d47 1
@


1.55
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.54 2014/01/27 18:58:14 markus Exp $ */
d182 1
d192 1
d298 1
d304 3
@


1.54
log
@replace openssl HMAC with an implementation based on our ssh_digest_*
ok and feedback djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.53 2014/01/09 23:20:00 djm Exp $ */
d333 1
a333 1
		bzero(hostkeys->entries + i, sizeof(*hostkeys->entries));
d336 1
a336 1
	bzero(hostkeys, sizeof(*hostkeys));
@


1.53
log
@Introduce digest API and use it to perform all hashing operations
rather than calling OpenSSL EVP_Digest* directly. Will make it easier
to build a reduced-feature OpenSSH without OpenSSL in future;
feedback, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.52 2013/07/12 00:19:58 djm Exp $ */
a42 3
#include <openssl/hmac.h>
#include <openssl/sha.h>

d55 1
d100 3
a102 3
	if (ret != SHA_DIGEST_LENGTH) {
		debug2("extract_salt: expected salt len %d, got %d",
		    SHA_DIGEST_LENGTH, ret);
d112 1
a112 2
	const EVP_MD *md = EVP_sha1();
	HMAC_CTX mac_ctx;
d118 1
a118 1
	len = EVP_MD_size(md);
d131 6
a136 4
	HMAC_Init(&mac_ctx, salt, len, md);
	HMAC_Update(&mac_ctx, (u_char *)host, strlen(host));
	HMAC_Final(&mac_ctx, result, NULL);
	HMAC_cleanup(&mac_ctx);
d140 1
a140 1
		fatal("host_hash: __b64_ntop failed");
@


1.52
log
@fix pointer-signedness warnings from clang/llvm-3.3; "seems nice" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.51 2013/05/17 00:13:13 djm Exp $ */
d57 1
@


1.51
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.50 2010/12/04 13:31:37 djm Exp $ */
d64 1
a64 1
extract_salt(const char *s, u_int l, char *salt, size_t salt_len)
d115 2
a116 1
	char salt[256], result[256], uu_salt[512], uu_result[512];
d134 1
a134 1
	HMAC_Update(&mac_ctx, host, strlen(host));
d154 1
a154 1
hostfile_read_key(char **cpp, u_int *bitsp, Key *ret)
d171 4
a174 2
	if (bitsp != NULL)
		*bitsp = key_size(ret);
@


1.50
log
@fix fd leak; spotted and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.49 2010/11/29 23:45:51 djm Exp $ */
d96 1
a96 1
	xfree(b64salt);
d327 2
a328 2
		xfree(hostkeys->entries[i].host);
		xfree(hostkeys->entries[i].file);
d332 3
a334 5
	if (hostkeys->entries != NULL)
		xfree(hostkeys->entries);
	hostkeys->entries = NULL;
	hostkeys->num_entries = 0;
	xfree(hostkeys);
@


1.49
log
@automatically order the hostkeys requested by the client based on
which hostkeys are already recorded in known_hosts. This avoids
hostkey warnings when connecting to servers with new ECDSA keys
that are preferred by default; with markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.48 2010/03/04 10:36:03 djm Exp $ */
d317 1
@


1.48
log
@Add a TrustedUserCAKeys option to sshd_config to specify CA keys that
are trusted to authenticate users (in addition than doing it per-user
in authorized_keys).

Add a RevokedKeys option to sshd_config and a @@revoked marker to
known_hosts to allow keys to me revoked and banned for user or host
authentication.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.47 2010/02/26 20:29:54 djm Exp $ */
d56 6
d170 2
a171 1
	*bitsp = key_size(ret);
d176 2
a177 1
hostfile_check_key(int bits, const Key *key, const char *host, const char *filename, int linenum)
d182 1
a182 1
		logit("Warning: %s, line %d: keysize mismatch for host %s: "
d185 1
a185 1
		logit("Warning: replace %d with %d in %s, line %d.",
d191 1
a191 1
static enum { MRK_ERROR, MRK_NONE, MRK_REVOKE, MRK_CA }
d226 8
a233 9
/*
 * Checks whether the given host (which must be in all lowercase) is already
 * in the list of our known hosts. Returns HOST_OK if the host is known and
 * has the specified key, HOST_NEW if the host is not known, and HOST_CHANGED
 * if the host is known but used to have a different host key.
 *
 * If no 'key' has been specified and a key of type 'keytype' is known
 * for the specified host, then HOST_FOUND is returned.
 */
d235 2
a236 4
static HostStatus
check_host_in_hostfile_by_key_or_type(const char *filename,
    const char *host, const Key *key, int keytype, Key *found,
    int want_revocation, int *numret)
d240 1
a240 2
	int want, have, linenum = 0, want_cert = key_is_cert(key);
	u_int kbits;
d242 9
a250 21
	HostStatus end_return;

	debug3("check_host_in_hostfile: host %s filename %s", host, filename);

	if (want_revocation && (key == NULL || keytype != 0 || found != NULL))
		fatal("%s: invalid arguments", __func__);

	/* Open the file containing the list of known hosts. */
	f = fopen(filename, "r");
	if (!f)
		return HOST_NEW;

	/*
	 * Return value when the loop terminates.  This is set to
	 * HOST_CHANGED if we have seen a different key for the host and have
	 * not found the proper one.
	 */
	end_return = HOST_NEW;

	/* Go through the file. */
	while (fgets(line, sizeof(line), f)) {
a251 1
		linenum++;
d259 3
a261 12
		if (want_revocation)
			want = MRK_REVOKE;
		else if (want_cert)
			want = MRK_CA;
		else
			want = MRK_NONE;

		if ((have = check_markers(&cp)) == MRK_ERROR) {
			verbose("%s: invalid marker at %s:%d",
			    __func__, filename, linenum);
			continue;
		} else if (want != have)
d263 1
d275 2
a276 2
				debug("Invalid hashed host line %d of %s",
				    linenum, filename);
a285 3
		if (want_revocation)
			found = key_new(KEY_UNSPEC);

d290 10
a299 1
		if (!hostfile_read_key(&cp, &kbits, found))
d302 41
a342 2
		if (numret != NULL)
			*numret = linenum;
d344 2
a345 6
		if (key == NULL) {
			/* we found a key of the requested type */
			if (found->type == keytype) {
				fclose(f);
				return HOST_FOUND;
			}
d347 37
a383 1
		}
d385 4
a388 1
		if (!hostfile_check_key(kbits, found, host, filename, linenum))
d390 19
a408 8

		if (want_revocation) {
			if (key_is_cert(key) &&
			    key_equal_public(key->cert->signature_key, found)) {
				verbose("check_host_in_hostfile: revoked CA "
				    "line %d", linenum);
				key_free(found);
				return HOST_REVOKED;
d410 6
a415 5
			if (key_equal_public(key, found)) {
				verbose("check_host_in_hostfile: revoked key "
				    "line %d", linenum);
				key_free(found);
				return HOST_REVOKED;
d417 4
a420 2
			key_free(found);
			continue;
a421 20

		/* Check if the current key is the same as the given key. */
		if (want_cert && key_equal(key->cert->signature_key, found)) {
			/* Found CA cert for key */
			debug3("check_host_in_hostfile: CA match line %d",
			    linenum);
			fclose(f);
			return HOST_OK;
		} else if (!want_cert && key_equal(key, found)) {
			/* Found identical key */
			debug3("check_host_in_hostfile: match line %d", linenum);
			fclose(f);
			return HOST_OK;
		}
		/*
		 * They do not match.  We will continue to go through the
		 * file; however, we note that we will not return that it is
		 * new.
		 */
		end_return = HOST_CHANGED;
d423 5
a427 7
	/* Clear variables and close the file. */
	fclose(f);

	/*
	 * Return either HOST_NEW or HOST_CHANGED, depending on whether we
	 * saw a different key for the host.
	 */
d430 1
a430 1

d432 2
a433 2
check_host_in_hostfile(const char *filename, const char *host, const Key *key,
    Key *found, int *numret)
d437 1
a437 5
	if (check_host_in_hostfile_by_key_or_type(filename, host,
	    key, 0, NULL, 1, NULL) == HOST_REVOKED)
		return HOST_REVOKED;
	return check_host_in_hostfile_by_key_or_type(filename, host, key, 0,
	    found, 0, numret);
d441 2
a442 2
lookup_key_in_hostfile_by_type(const char *filename, const char *host,
    int keytype, Key *found, int *numret)
d444 2
a445 2
	return (check_host_in_hostfile_by_key_or_type(filename, host, NULL,
	    keytype, found, 0, numret) == HOST_FOUND);
@


1.47
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.46 2009/10/11 23:03:15 djm Exp $ */
d183 35
d230 2
a231 1
    const char *host, const Key *key, int keytype, Key *found, int *numret)
d235 1
a235 1
	int linenum = 0, want_cert = key_is_cert(key);
d242 3
d268 12
a279 15
		/*
		 * Ignore CA keys when looking for raw keys.
		 * Ignore raw keys when looking for CA keys.
		 */
		if (strncasecmp(cp, CA_MARKER, sizeof(CA_MARKER) - 1) == 0 &&
		    (cp[sizeof(CA_MARKER) - 1] == ' ' ||
		    cp[sizeof(CA_MARKER) - 1] == '\t')) {
			if (want_cert) {
				/* Skip the marker and following whitespace */
				cp += sizeof(CA_MARKER);
				for (; *cp == ' ' || *cp == '\t'; cp++)
					;
			} else
				continue;
		} else if (want_cert)
d303 3
d328 18
d382 5
a386 2
	return (check_host_in_hostfile_by_key_or_type(filename, host, key, 0,
	    found, numret));
d394 1
a394 1
	    keytype, found, numret) == HOST_FOUND);
@


1.46
log
@mention the host name that we are looking for in check_host_in_hostfile()
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.45 2006/08/03 03:34:42 deraadt Exp $ */
d199 1
a199 1
	int linenum = 0;
d229 17
d290 8
a297 2
		if (key_equal(key, found)) {
			/* Ok, they match. */
@


1.45
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.44 2006/08/01 23:22:47 stevesk Exp $ */
d204 1
a204 1
	debug3("check_host_in_hostfile: filename %s", filename);
@


1.44
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.43 2006/07/26 13:57:17 stevesk Exp $ */
a38 2
#include "includes.h"

d51 1
a55 1
#include "xmalloc.h"
@


1.43
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.42 2006/07/22 20:48:23 stevesk Exp $ */
d49 1
@


1.42
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.41 2006/07/05 02:42:09 stevesk Exp $ */
d45 3
d49 1
a50 3

#include <openssl/hmac.h>
#include <openssl/sha.h>
@


1.41
log
@move #include <netinet/in.h> out of includes.h; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: hostfile.c,v 1.40 2006/03/25 13:17:02 djm Exp $ */
d46 1
@


1.40
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d40 4
@


1.39
log
@RCSID() can die
@
text
@d1 1
@


1.38
log
@FILE* leak detected by Coverity via elad AT netbsd.org;
ok deraadt@@
@
text
@a38 1
RCSID("$OpenBSD: hostfile.c,v 1.37 2006/02/07 03:47:05 stevesk Exp $");
@


1.37
log
@"packet.h" not needed
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.36 2005/11/22 03:36:03 dtucker Exp $");
d257 2
a258 1
			if (found->type == keytype)
d260 1
@


1.37.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: hostfile.c,v 1.45 2006/08/03 03:34:42 deraadt Exp $ */
d38 2
a39 1
#include <sys/types.h>
d41 1
a41 1
#include <netinet/in.h>
a45 6
#include <resolv.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "xmalloc.h"
d50 1
d257 1
a257 2
			if (found->type == keytype) {
				fclose(f);
a258 1
			}
@


1.36
log
@Correct format/arguments to debug call; spotted by shaw at vranix.com ok djm@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.35 2005/07/27 10:39:03 dtucker Exp $");
d42 1
a45 1
#include "packet.h"
@


1.35
log
@Silence bogus -Wuninitialized warnings; ok djm@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.34 2005/03/10 22:01:05 deraadt Exp $");
d91 2
a92 2
		debug2("extract_salt: expected salt len %u, got %u",
		    salt_len, ret);
@


1.35.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.36 2005/11/22 03:36:03 dtucker Exp $");
d91 2
a92 2
		debug2("extract_salt: expected salt len %d, got %d",
		    SHA_DIGEST_LENGTH, ret);
@


1.35.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: hostfile.c,v 1.45 2006/08/03 03:34:42 deraadt Exp $ */
d38 2
a39 3
#include <sys/types.h>

#include <netinet/in.h>
d41 1
d45 1
a45 6
#include <resolv.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "xmalloc.h"
d50 1
d257 1
a257 2
			if (found->type == keytype) {
				fclose(f);
a258 1
			}
@


1.34
log
@spacing
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.33 2005/03/01 10:40:26 djm Exp $");
d318 1
a318 1
	char *hashed_host;
@


1.34.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.35 2005/07/27 10:39:03 dtucker Exp $");
d318 1
a318 1
	char *hashed_host = NULL;
@


1.34.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.36 2005/11/22 03:36:03 dtucker Exp $");
d91 2
a92 2
		debug2("extract_salt: expected salt len %d, got %d",
		    SHA_DIGEST_LENGTH, ret);
@


1.33
log
@add support for hashing host names and addresses added to known_hosts files,
to improve privacy of which hosts user have been visiting; ok markus@@ deraadt@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.32 2003/11/10 16:23:41 jakob Exp $");
d95 1
a95 1
	
d126 1
a126 1
	if (__b64_ntop(salt, len, uu_salt, sizeof(uu_salt)) == -1 || 
d313 1
a313 1
add_host_to_hostfile(const char *filename, const char *host, const Key *key, 
@


1.32
log
@constify. ok markus@@ & djm@@
@
text
@d39 5
a43 1
RCSID("$OpenBSD: hostfile.c,v 1.31 2003/04/08 20:21:28 itojun Exp $");
d50 85
d196 1
a196 1
	char *cp, *cp2;
d229 12
a240 2
		if (match_hostname(host, cp, (u_int) (cp2 - cp)) != 1)
			continue;
d313 2
a314 1
add_host_to_hostfile(const char *filename, const char *host, const Key *key)
d318 2
d325 10
a334 1
	fprintf(f, "%s ", host);
@


1.32.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d39 1
a39 5
RCSID("$OpenBSD: hostfile.c,v 1.33 2005/03/01 10:40:26 djm Exp $");

#include <resolv.h>
#include <openssl/hmac.h>
#include <openssl/sha.h>
a45 85
#include "xmalloc.h"

static int
extract_salt(const char *s, u_int l, char *salt, size_t salt_len)
{
	char *p, *b64salt;
	u_int b64len;
	int ret;

	if (l < sizeof(HASH_MAGIC) - 1) {
		debug2("extract_salt: string too short");
		return (-1);
	}
	if (strncmp(s, HASH_MAGIC, sizeof(HASH_MAGIC) - 1) != 0) {
		debug2("extract_salt: invalid magic identifier");
		return (-1);
	}
	s += sizeof(HASH_MAGIC) - 1;
	l -= sizeof(HASH_MAGIC) - 1;
	if ((p = memchr(s, HASH_DELIM, l)) == NULL) {
		debug2("extract_salt: missing salt termination character");
		return (-1);
	}

	b64len = p - s;
	/* Sanity check */
	if (b64len == 0 || b64len > 1024) {
		debug2("extract_salt: bad encoded salt length %u", b64len);
		return (-1);
	}
	b64salt = xmalloc(1 + b64len);
	memcpy(b64salt, s, b64len);
	b64salt[b64len] = '\0';

	ret = __b64_pton(b64salt, salt, salt_len);
	xfree(b64salt);
	if (ret == -1) {
		debug2("extract_salt: salt decode error");
		return (-1);
	}
	if (ret != SHA_DIGEST_LENGTH) {
		debug2("extract_salt: expected salt len %u, got %u",
		    salt_len, ret);
		return (-1);
	}
	
	return (0);
}

char *
host_hash(const char *host, const char *name_from_hostfile, u_int src_len)
{
	const EVP_MD *md = EVP_sha1();
	HMAC_CTX mac_ctx;
	char salt[256], result[256], uu_salt[512], uu_result[512];
	static char encoded[1024];
	u_int i, len;

	len = EVP_MD_size(md);

	if (name_from_hostfile == NULL) {
		/* Create new salt */
		for (i = 0; i < len; i++)
			salt[i] = arc4random();
	} else {
		/* Extract salt from known host entry */
		if (extract_salt(name_from_hostfile, src_len, salt,
		    sizeof(salt)) == -1)
			return (NULL);
	}

	HMAC_Init(&mac_ctx, salt, len, md);
	HMAC_Update(&mac_ctx, host, strlen(host));
	HMAC_Final(&mac_ctx, result, NULL);
	HMAC_cleanup(&mac_ctx);

	if (__b64_ntop(salt, len, uu_salt, sizeof(uu_salt)) == -1 || 
	    __b64_ntop(result, len, uu_result, sizeof(uu_result)) == -1)
		fatal("host_hash: __b64_ntop failed");

	snprintf(encoded, sizeof(encoded), "%s%s%c%s", HASH_MAGIC, uu_salt,
	    HASH_DELIM, uu_result);

	return (encoded);
}
d107 1
a107 1
	char *cp, *cp2, *hashed_host;
d140 2
a141 12
		if (match_hostname(host, cp, (u_int) (cp2 - cp)) != 1) {
			if (*cp != HASH_DELIM)
				continue;
			hashed_host = host_hash(host, cp, (u_int) (cp2 - cp));
			if (hashed_host == NULL) {
				debug("Invalid hashed host line %d of %s",
				    linenum, filename);
				continue;
			}
			if (strncmp(hashed_host, cp, (u_int) (cp2 - cp)) != 0)
				continue;
		}
d214 1
a214 2
add_host_to_hostfile(const char *filename, const char *host, const Key *key, 
    int store_hash)
a217 2
	char *hashed_host;

d223 1
a223 10

	if (store_hash) {
		if ((hashed_host = host_hash(host, NULL, 0)) == NULL) {
			error("add_host_to_hostfile: host_hash failed");
			fclose(f);
			return 0;
		}
	}
	fprintf(f, "%s ", store_hash ? hashed_host : host);

@


1.32.4.1
log
@upgrade to OpenSSH 4.0
@
text
@d39 1
a39 5
RCSID("$OpenBSD: hostfile.c,v 1.33 2005/03/01 10:40:26 djm Exp $");

#include <resolv.h>
#include <openssl/hmac.h>
#include <openssl/sha.h>
a45 85
#include "xmalloc.h"

static int
extract_salt(const char *s, u_int l, char *salt, size_t salt_len)
{
	char *p, *b64salt;
	u_int b64len;
	int ret;

	if (l < sizeof(HASH_MAGIC) - 1) {
		debug2("extract_salt: string too short");
		return (-1);
	}
	if (strncmp(s, HASH_MAGIC, sizeof(HASH_MAGIC) - 1) != 0) {
		debug2("extract_salt: invalid magic identifier");
		return (-1);
	}
	s += sizeof(HASH_MAGIC) - 1;
	l -= sizeof(HASH_MAGIC) - 1;
	if ((p = memchr(s, HASH_DELIM, l)) == NULL) {
		debug2("extract_salt: missing salt termination character");
		return (-1);
	}

	b64len = p - s;
	/* Sanity check */
	if (b64len == 0 || b64len > 1024) {
		debug2("extract_salt: bad encoded salt length %u", b64len);
		return (-1);
	}
	b64salt = xmalloc(1 + b64len);
	memcpy(b64salt, s, b64len);
	b64salt[b64len] = '\0';

	ret = __b64_pton(b64salt, salt, salt_len);
	xfree(b64salt);
	if (ret == -1) {
		debug2("extract_salt: salt decode error");
		return (-1);
	}
	if (ret != SHA_DIGEST_LENGTH) {
		debug2("extract_salt: expected salt len %u, got %u",
		    salt_len, ret);
		return (-1);
	}
	
	return (0);
}

char *
host_hash(const char *host, const char *name_from_hostfile, u_int src_len)
{
	const EVP_MD *md = EVP_sha1();
	HMAC_CTX mac_ctx;
	char salt[256], result[256], uu_salt[512], uu_result[512];
	static char encoded[1024];
	u_int i, len;

	len = EVP_MD_size(md);

	if (name_from_hostfile == NULL) {
		/* Create new salt */
		for (i = 0; i < len; i++)
			salt[i] = arc4random();
	} else {
		/* Extract salt from known host entry */
		if (extract_salt(name_from_hostfile, src_len, salt,
		    sizeof(salt)) == -1)
			return (NULL);
	}

	HMAC_Init(&mac_ctx, salt, len, md);
	HMAC_Update(&mac_ctx, host, strlen(host));
	HMAC_Final(&mac_ctx, result, NULL);
	HMAC_cleanup(&mac_ctx);

	if (__b64_ntop(salt, len, uu_salt, sizeof(uu_salt)) == -1 || 
	    __b64_ntop(result, len, uu_result, sizeof(uu_result)) == -1)
		fatal("host_hash: __b64_ntop failed");

	snprintf(encoded, sizeof(encoded), "%s%s%c%s", HASH_MAGIC, uu_salt,
	    HASH_DELIM, uu_result);

	return (encoded);
}
d107 1
a107 1
	char *cp, *cp2, *hashed_host;
d140 2
a141 12
		if (match_hostname(host, cp, (u_int) (cp2 - cp)) != 1) {
			if (*cp != HASH_DELIM)
				continue;
			hashed_host = host_hash(host, cp, (u_int) (cp2 - cp));
			if (hashed_host == NULL) {
				debug("Invalid hashed host line %d of %s",
				    linenum, filename);
				continue;
			}
			if (strncmp(hashed_host, cp, (u_int) (cp2 - cp)) != 0)
				continue;
		}
d214 1
a214 2
add_host_to_hostfile(const char *filename, const char *host, const Key *key, 
    int store_hash)
a217 2
	char *hashed_host;

d223 1
a223 10

	if (store_hash) {
		if ((hashed_host = host_hash(host, NULL, 0)) == NULL) {
			error("add_host_to_hostfile: host_hash failed");
			fclose(f);
			return 0;
		}
	}
	fprintf(f, "%s ", store_hash ? hashed_host : host);

@


1.32.4.2
log
@upgrade to OpenSSH 4.1
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.34 2005/03/10 22:01:05 deraadt Exp $");
d95 1
a95 1

d126 1
a126 1
	if (__b64_ntop(salt, len, uu_salt, sizeof(uu_salt)) == -1 ||
d313 1
a313 1
add_host_to_hostfile(const char *filename, const char *host, const Key *key,
@


1.32.4.3
log
@upgrade to OpenSSH 4.2
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.35 2005/07/27 10:39:03 dtucker Exp $");
d318 1
a318 1
	char *hashed_host = NULL;
@


1.31
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.30 2002/07/24 16:11:18 markus Exp $");
d75 1
a75 1
hostfile_check_key(int bits, Key *key, const char *host, const char *filename, int linenum)
d101 1
a101 1
    const char *host, Key *key, int keytype, Key *found, int *numret)
d191 1
a191 1
check_host_in_hostfile(const char *filename, const char *host, Key *key,
d214 1
a214 1
add_host_to_hostfile(const char *filename, const char *host, Key *key)
@


1.31.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.32 2003/11/10 16:23:41 jakob Exp $");
d75 1
a75 1
hostfile_check_key(int bits, const Key *key, const char *host, const char *filename, int linenum)
d101 1
a101 1
    const char *host, const Key *key, int keytype, Key *found, int *numret)
d191 1
a191 1
check_host_in_hostfile(const char *filename, const char *host, const Key *key,
d214 1
a214 1
add_host_to_hostfile(const char *filename, const char *host, const Key *key)
@


1.30
log
@print out all known keys for a host if we get a unknown host key,
see discussion at http://marc.theaimsgroup.com/?t=101069210100016&r=1&w=4

the ssharp mitm tool attacks users in a similar way, so i'd like to
pointed out again:
	A MITM attack is always possible if the ssh client prints:
	The authenticity of host 'bla' can't be established.
(protocol version 2 with pubkey authentication allows you to detect
MITM attacks)
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.29 2001/12/18 10:04:21 jakob Exp $");
d80 1
a80 1
		log("Warning: %s, line %d: keysize mismatch for host %s: "
d83 1
a83 1
		log("Warning: replace %d with %d in %s, line %d.",
@


1.30.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.31 2003/04/08 20:21:28 itojun Exp $");
d80 1
a80 1
		logit("Warning: %s, line %d: keysize mismatch for host %s: "
d83 1
a83 1
		logit("Warning: replace %d with %d in %s, line %d.",
@


1.30.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.31 2003/04/08 20:21:28 itojun Exp $");
d80 1
a80 1
		logit("Warning: %s, line %d: keysize mismatch for host %s: "
d83 1
a83 1
		logit("Warning: replace %d with %d in %s, line %d.",
@


1.30.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.32 2003/11/10 16:23:41 jakob Exp $");
d75 1
a75 1
hostfile_check_key(int bits, const Key *key, const char *host, const char *filename, int linenum)
d101 1
a101 1
    const char *host, const Key *key, int keytype, Key *found, int *numret)
d191 1
a191 1
check_host_in_hostfile(const char *filename, const char *host, const Key *key,
d214 1
a214 1
add_host_to_hostfile(const char *filename, const char *host, const Key *key)
@


1.29
log
@remove auth_rsa_read_key, make hostfile_ready_key non static; ok markus@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.28 2001/06/25 08:25:37 markus Exp $");
d94 3
d99 3
a101 3
HostStatus
check_host_in_hostfile(const char *filename, const char *host, Key *key,
    Key *found, int *numret)
d111 1
a111 2
	if (key == NULL)
		fatal("no key to look up");
a151 2
		if (!hostfile_check_key(kbits, found, host, filename, linenum))
			continue;
d156 10
d188 18
@


1.29.2.1
log
@Update to OpenSSH 3.5
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.30 2002/07/24 16:11:18 markus Exp $");
a93 3
 *
 * If no 'key' has been specified and a key of type 'keytype' is known
 * for the specified host, then HOST_FOUND is returned.
d96 3
a98 3
static HostStatus
check_host_in_hostfile_by_key_or_type(const char *filename,
    const char *host, Key *key, int keytype, Key *found, int *numret)
d108 2
a109 1

d150 2
a155 10
		if (key == NULL) {
			/* we found a key of the requested type */
			if (found->type == keytype)
				return HOST_FOUND;
			continue;
		}

		if (!hostfile_check_key(kbits, found, host, filename, linenum))
			continue;

a177 18
}

HostStatus
check_host_in_hostfile(const char *filename, const char *host, Key *key,
    Key *found, int *numret)
{
	if (key == NULL)
		fatal("no key to look up");
	return (check_host_in_hostfile_by_key_or_type(filename, host, key, 0,
	    found, numret));
}

int
lookup_key_in_hostfile_by_type(const char *filename, const char *host,
    int keytype, Key *found, int *numret)
{
	return (check_host_in_hostfile_by_key_or_type(filename, host, NULL,
	    keytype, found, numret) == HOST_FOUND);
@


1.28
log
@update copyright for 2001
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.27 2001/06/23 15:12:18 itojun Exp $");
d52 1
a52 1
static int
a71 11
}

int
auth_rsa_read_key(char **cpp, u_int *bitsp, BIGNUM * e, BIGNUM * n)
{
	Key *k = key_new(KEY_RSA1);
	int ret = hostfile_read_key(cpp, bitsp, k);
	BN_copy(e, k->rsa->e);
	BN_copy(n, k->rsa->n);
	key_free(k);
	return ret;
@


1.28.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.29 2001/12/18 10:04:21 jakob Exp $");
d52 1
a52 1
int
d72 11
@


1.28.2.2
log
@Update to OpenSSH 3.5
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.30 2002/07/24 16:11:18 markus Exp $");
a93 3
 *
 * If no 'key' has been specified and a key of type 'keytype' is known
 * for the specified host, then HOST_FOUND is returned.
d96 3
a98 3
static HostStatus
check_host_in_hostfile_by_key_or_type(const char *filename,
    const char *host, Key *key, int keytype, Key *found, int *numret)
d108 2
a109 1

d150 2
a155 10
		if (key == NULL) {
			/* we found a key of the requested type */
			if (found->type == keytype)
				return HOST_FOUND;
			continue;
		}

		if (!hostfile_check_key(kbits, found, host, filename, linenum))
			continue;

a177 18
}

HostStatus
check_host_in_hostfile(const char *filename, const char *host, Key *key,
    Key *found, int *numret)
{
	if (key == NULL)
		fatal("no key to look up");
	return (check_host_in_hostfile_by_key_or_type(filename, host, key, 0,
	    found, numret));
}

int
lookup_key_in_hostfile_by_type(const char *filename, const char *host,
    int keytype, Key *found, int *numret)
{
	return (check_host_in_hostfile_by_key_or_type(filename, host, NULL,
	    keytype, found, numret) == HOST_FOUND);
@


1.27
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d14 1
a14 1
 * Copyright (c) 1999,2000 Markus Friedl.  All rights reserved.
d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.26 2001/04/12 19:15:24 markus Exp $");
@


1.26
log
@implement HostbasedAuthentication (= RhostRSAAuthentication for ssh v2)
similar to RhostRSAAuthentication unless you enable (the experimental)
HostbasedUsesNameFromPacketOnly option.  please test. :)
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.25 2001/04/06 22:12:47 stevesk Exp $");
d52 1
a52 1
int
d85 1
a85 1
int
@


1.26.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d14 1
a14 1
 * Copyright (c) 1999, 2000 Markus Friedl.  All rights reserved.
d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.28 2001/06/25 08:25:37 markus Exp $");
d52 1
a52 1
static int
d85 1
a85 1
static int
@


1.26.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.29 2001/12/18 10:04:21 jakob Exp $");
d52 1
a52 1
int
d72 11
@


1.25
log
@unused; typo in comment
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.24 2001/01/21 19:05:49 markus Exp $");
d118 1
d170 1
@


1.24
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.23 2000/12/21 15:10:16 markus Exp $");
d114 1
a114 1
	u_int kbits, hostlen;
a124 3
	/* Cache the length of the host name. */
	hostlen = strlen(host);

d132 1
a132 1
	/* Go trough the file. */
@


1.23
log
@print keyfile:line for changed hostkeys, for deraadt@@; ok deraadt@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.22 2000/12/19 23:17:56 markus Exp $");
a42 3
#include "ssh.h"
#include <openssl/rsa.h>
#include <openssl/dsa.h>
d45 1
@


1.22
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.21 2000/11/12 19:50:37 markus Exp $");
d110 2
a111 1
check_host_in_hostfile(const char *filename, const char *host, Key *key, Key *found)
d167 3
@


1.21
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.20 2000/09/07 20:27:51 deraadt Exp $");
d55 1
a55 1
hostfile_read_key(char **cpp, unsigned int *bitsp, Key *ret)
d77 1
a77 1
auth_rsa_read_key(char **cpp, unsigned int *bitsp, BIGNUM * e, BIGNUM * n)
d115 1
a115 1
	unsigned int kbits, hostlen;
d152 1
a152 1
		if (match_hostname(host, cp, (unsigned int) (cp2 - cp)) != 1)
@


1.20
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.19 2000/06/06 19:32:13 markus Exp $");
a56 1
	unsigned int bits;
d63 1
a63 2
	bits = key_read(ret, &cp);
	if (bits == 0)
d72 1
a72 1
	*bitsp = bits;
d79 1
a79 1
	Key *k = key_new(KEY_RSA);
d90 1
a90 1
	if (key == NULL || key->type != KEY_RSA || key->rsa == NULL)
@


1.20.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.24 2001/01/21 19:05:49 markus Exp $");
d43 3
a47 1
#include "log.h"
d55 1
a55 1
hostfile_read_key(char **cpp, u_int *bitsp, Key *ret)
d57 1
d64 2
a65 1
	if (key_read(ret, &cp) != 1)
d74 1
a74 1
	*bitsp = key_size(ret);
d79 1
a79 1
auth_rsa_read_key(char **cpp, u_int *bitsp, BIGNUM * e, BIGNUM * n)
d81 1
a81 1
	Key *k = key_new(KEY_RSA1);
d92 1
a92 1
	if (key == NULL || key->type != KEY_RSA1 || key->rsa == NULL)
d112 1
a112 2
check_host_in_hostfile(const char *filename, const char *host, Key *key,
    Key *found, int *numret)
d117 1
a117 1
	u_int kbits, hostlen;
d154 1
a154 1
		if (match_hostname(host, cp, (u_int) (cp2 - cp)) != 1)
a167 3

		if (numret != NULL)
			*numret = linenum;
@


1.20.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.20.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.20.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.26 2001/04/12 19:15:24 markus Exp $");
d114 1
a114 1
	u_int kbits;
a117 1
	debug3("check_host_in_hostfile: filename %s", filename);
d125 3
d135 1
a135 1
	/* Go through the file. */
a171 1
			debug3("check_host_in_hostfile: match line %d", linenum);
@


1.20.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d14 1
a14 1
 * Copyright (c) 1999, 2000 Markus Friedl.  All rights reserved.
d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.28 2001/06/25 08:25:37 markus Exp $");
d52 1
a52 1
static int
d85 1
a85 1
static int
@


1.20.2.6
log
@Merge OpenSSH 3.1.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.29 2001/12/18 10:04:21 jakob Exp $");
d52 1
a52 1
int
d72 11
@


1.19
log
@fix match_hostname() logic for auth-rsa: deny access if we have a negative match or no match at all
@
text
@a1 3
 *
 * hostfile.c
 *
a2 1
 *
a4 3
 *
 * Created: Thu Jun 29 07:10:56 1995 ylo
 *
d7 29
d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.18 2000/04/29 18:11:52 markus Exp $");
@


1.18
log
@keysize warnings error() -> log()
@
text
@d17 1
a17 1
RCSID("$OpenBSD: hostfile.c,v 1.17 2000/04/26 20:56:29 markus Exp $");
d132 1
a132 1
		if (!match_hostname(host, cp, (unsigned int) (cp2 - cp)))
@


1.18.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d17 1
a17 1
RCSID("$OpenBSD: hostfile.c,v 1.19 2000/06/06 19:32:13 markus Exp $");
d132 1
a132 1
		if (match_hostname(host, cp, (unsigned int) (cp2 - cp)) != 1)
@


1.18.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@@


1.18.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a13 29
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
 * Copyright (c) 1999,2000 Markus Friedl.  All rights reserved.
 * Copyright (c) 1999 Niels Provos.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d17 1
a17 1
RCSID("$OpenBSD: hostfile.c,v 1.20 2000/09/07 20:27:51 deraadt Exp $");
@


1.18.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d39 1
a39 1
RCSID("$OpenBSD: hostfile.c,v 1.24 2001/01/21 19:05:49 markus Exp $");
d43 3
a47 1
#include "log.h"
d55 1
a55 1
hostfile_read_key(char **cpp, u_int *bitsp, Key *ret)
d57 1
d64 2
a65 1
	if (key_read(ret, &cp) != 1)
d74 1
a74 1
	*bitsp = key_size(ret);
d79 1
a79 1
auth_rsa_read_key(char **cpp, u_int *bitsp, BIGNUM * e, BIGNUM * n)
d81 1
a81 1
	Key *k = key_new(KEY_RSA1);
d92 1
a92 1
	if (key == NULL || key->type != KEY_RSA1 || key->rsa == NULL)
d112 1
a112 2
check_host_in_hostfile(const char *filename, const char *host, Key *key,
    Key *found, int *numret)
d117 1
a117 1
	u_int kbits, hostlen;
d154 1
a154 1
		if (match_hostname(host, cp, (u_int) (cp2 - cp)) != 1)
a167 3

		if (numret != NULL)
			*numret = linenum;
@


1.18.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.17
log
@add DSA pubkey auth and other SSH2 fixes.  use ssh-keygen -[xX]
for trading keys with the real and the original SSH, directly from the
people who invented the SSH protocol.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: hostfile.c,v 1.16 2000/04/14 10:30:31 markus Exp $");
d73 1
a73 1
		error("Warning: %s, line %d: keysize mismatch for host %s: "
d76 1
a76 1
		error("Warning: replace %d with %d in %s, line %d.",
@


1.16
log
@whitespace cleanup
@
text
@d17 1
a17 1
RCSID("$OpenBSD: hostfile.c,v 1.15 2000/04/12 09:39:10 markus Exp $");
d42 2
a43 7
	/* Get number of bits. */
	if (*cp < '0' || *cp > '9')
		return 0;	/* Bad bit count... */
	for (bits = 0; *cp >= '0' && *cp <= '9'; cp++)
		bits = 10 * bits + *cp - '0';

	if (!key_read(ret, bits, &cp))
a179 1

d181 1
a181 3
		return 1;

	/* Open the file for appending. */
a184 1

a186 1
		fprintf(f, "\n");
d189 1
a189 1
		error("add_host_to_hostfile: saving key failed");
d191 1
a191 2

	/* Close the file. */
@


1.15
log
@#include <ssl/foo.h> -> <openssh/foo.h>
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
RCSID("$OpenBSD: hostfile.c,v 1.14 2000/03/23 22:15:33 markus Exp $");
@


1.14
log
@initial support for DSA keys. ok deraadt@@, niels@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: hostfile.c,v 1.5 2000/02/17 18:41:57 markus Exp $");
d22 2
a23 2
#include <ssl/rsa.h>
#include <ssl/dsa.h>
@


1.13
log
@remove unused variable 'len'. fix comments.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: hostfile.c,v 1.12 2000/02/16 13:18:51 markus Exp $");
d20 1
d22 4
d28 2
a29 5
 * Reads a multiple-precision integer in decimal from the buffer, and advances
 * the pointer.  The integer must already be initialized.  This function is
 * permitted to modify the buffer.  This leaves *cpp to point just beyond the
 * last processed (and maybe modified) character.  Note that this may modify
 * the buffer containing the number.
d33 1
a33 43
auth_rsa_read_bignum(char **cpp, BIGNUM * value)
{
	char *cp = *cpp;
	int old;

	/* Skip any leading whitespace. */
	for (; *cp == ' ' || *cp == '\t'; cp++)
		;

	/* Check that it begins with a decimal digit. */
	if (*cp < '0' || *cp > '9')
		return 0;

	/* Save starting position. */
	*cpp = cp;

	/* Move forward until all decimal digits skipped. */
	for (; *cp >= '0' && *cp <= '9'; cp++)
		;

	/* Save the old terminating character, and replace it by \0. */
	old = *cp;
	*cp = 0;

	/* Parse the number. */
	if (BN_dec2bn(&value, *cpp) == 0)
		return 0;

	/* Restore old terminating character. */
	*cp = old;

	/* Move beyond the number and return success. */
	*cpp = cp;
	return 1;
}

/*
 * Parses an RSA key (number of bits, e, n) from a string.  Moves the pointer
 * over the key.  Skips any whitespace at the beginning and at end.
 */

int
auth_rsa_read_key(char **cpp, unsigned int *bitsp, BIGNUM * e, BIGNUM * n)
d48 1
a48 6
	/* Get public exponent. */
	if (!auth_rsa_read_bignum(&cp, e))
		return 0;

	/* Get public modulus. */
	if (!auth_rsa_read_bignum(&cp, n))
d61 10
a70 6
/*
 * Tries to match the host name (which must be in all lowercase) against the
 * comma-separated sequence of subpatterns (each possibly preceded by ! to
 * indicate negation).  Returns true if there is a positive match; zero
 * otherwise.
 */
d73 1
a73 1
match_hostname(const char *host, const char *pattern, unsigned int len)
d75 8
a82 40
	char sub[1024];
	int negated;
	int got_positive;
	unsigned int i, subi;

	got_positive = 0;
	for (i = 0; i < len;) {
		/* Check if the subpattern is negated. */
		if (pattern[i] == '!') {
			negated = 1;
			i++;
		} else
			negated = 0;

		/*
		 * Extract the subpattern up to a comma or end.  Convert the
		 * subpattern to lowercase.
		 */
		for (subi = 0;
		     i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';
		     subi++, i++)
			sub[subi] = isupper(pattern[i]) ? tolower(pattern[i]) : pattern[i];
		/* If subpattern too long, return failure (no match). */
		if (subi >= sizeof(sub) - 1)
			return 0;

		/* If the subpattern was terminated by a comma, skip the comma. */
		if (i < len && pattern[i] == ',')
			i++;

		/* Null-terminate the subpattern. */
		sub[subi] = '\0';

		/* Try to match the subpattern against the host name. */
		if (match_pattern(host, sub)) {
			if (negated)
				return 0;	/* Fail */
			else
				got_positive = 1;
		}
d84 1
a84 6

	/*
	 * Return success if got a positive match.  If there was a negative
	 * match, we have already returned zero and never get here.
	 */
	return got_positive;
d95 1
a95 2
check_host_in_hostfile(const char *filename, const char *host,
		       BIGNUM * e, BIGNUM * n, BIGNUM * ke, BIGNUM * kn)
d104 2
d147 3
a149 1
		if (!auth_rsa_read_key(&cp, &kbits, ke, kn))
a151 7
		if (kbits != BN_num_bits(kn)) {
			error("Warning: %s, line %d: keysize mismatch for host %s: "
			      "actual %d vs. announced %d.",
			      filename, linenum, host, BN_num_bits(kn), kbits);
			error("Warning: replace %d with %d in %s, line %d.",
			      kbits, BN_num_bits(kn), filename, linenum);
		}
d153 1
a153 1
		if (BN_cmp(ke, e) == 0 && BN_cmp(kn, n) == 0) {
d181 1
a181 2
add_host_to_hostfile(const char *filename, const char *host,
		     BIGNUM * e, BIGNUM * n)
d184 4
a187 2
	char *buf;
	unsigned int bits;
d194 6
a199 10
	/* size of modulus 'n' */
	bits = BN_num_bits(n);

	/* Print the host name and key to the file. */
	fprintf(f, "%s %u ", host, bits);
	buf = BN_bn2dec(e);
	if (buf == NULL) {
		error("add_host_to_hostfile: BN_bn2dec(e) failed");
		fclose(f);
		return 0;
a200 10
	fprintf(f, "%s ", buf);
	free(buf);
	buf = BN_bn2dec(n);
	if (buf == NULL) {
		error("add_host_to_hostfile: BN_bn2dec(n) failed");
		fclose(f);
		return 0;
	}
	fprintf(f, "%s\n", buf);
	free(buf);
d204 1
a204 1
	return 1;
@


1.12
log
@remove unused variable
@
text
@d17 1
a17 1
RCSID("$OpenBSD: hostfile.c,v 1.11 2000/01/04 00:07:59 markus Exp $");
d23 1
a23 1
 * Reads a multiple-precision integer in hex from the buffer, and advances
d34 1
a34 1
	int len, old;
d40 1
a40 1
	/* Check that it begins with a hex digit. */
d47 1
a47 1
	/* Move forward until all hex digits skipped. */
a49 3

	/* Compute the length of the hex number. */
	len = cp - *cpp;
@


1.11
log
@ipv6 support: mostly gethostbyname->getaddrinfo/getnameinfo, new features:
sshd allows multiple ListenAddress and Port options.  note that libwrap is
not IPv6-ready. (based on patches from <kick@@kyoto.wide.ad.jp> and
fujiwara@@rcac.tdi.co.jp)
@
text
@d17 1
a17 1
RCSID("$OpenBSD: hostfile.c,v 1.9 1999/11/24 19:53:47 markus Exp $");
d182 1
a182 1
	unsigned int bits, kbits, hostlen;
a199 3

	/* size of modulus 'n' */
	bits = BN_num_bits(n);
@


1.10
log
@indent, shorter warning
@
text
@@


1.9
log
@KNF, final part 3
@
text
@d17 1
a17 1
RCSID("$Id: hostfile.c,v 1.8 1999/11/24 00:26:02 deraadt Exp $");
d234 3
a236 3
			error("Warning: error in %s, line %d: keysize mismatch for host %s: "
			      "actual size %d vs. announced %d.",
			filename, linenum, host, BN_num_bits(kn), kbits);
@


1.8
log
@much more KNF
@
text
@d17 1
a17 1
RCSID("$Id: hostfile.c,v 1.7 1999/11/23 22:25:53 markus Exp $");
d22 7
a28 5
/* Reads a multiple-precision integer in hex from the buffer, and advances the
   pointer.  The integer must already be initialized.  This function is
   permitted to modify the buffer.  This leaves *cpp to point just beyond
   the last processed (and maybe modified) character.  Note that this may
   modify the buffer containing the number. */
d37 2
a38 1
	for (; *cp == ' ' || *cp == '\t'; cp++);
d48 2
a49 1
	for (; *cp >= '0' && *cp <= '9'; cp++);
a57 1

d70 4
a73 2
/* Parses an RSA key (number of bits, e, n) from a string.  Moves the pointer
   over the key.  Skips any whitespace at the beginning and at end. */
d82 2
a83 1
	for (cp = *cpp; *cp == ' ' || *cp == '\t'; cp++);
d100 2
a101 1
	for (; *cp == ' ' || *cp == '\t'; cp++);
d109 6
a114 4
/* Tries to match the host name (which must be in all lowercase) against the
   comma-separated sequence of subpatterns (each possibly preceded by ! to
   indicate negation).  Returns true if there is a positive match; zero
   otherwise. */
d133 4
a136 2
		/* Extract the subpattern up to a comma or end.  Convert
		   the subpattern to lowercase. */
d138 1
a138 1
		  i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';
d145 1
a145 2
		/* If the subpattern was terminated by a comma, skip the
		   comma. */
d155 1
a155 2
				return 0;	/* Fail if host matches
						   any negated subpattern. */
d161 4
a164 3
	/* Return success if got a positive match.  If there was a
	   negative match, we have already returned zero and never get
	   here. */
d168 6
a173 5
/* Checks whether the given host (which must be in all lowercase) is
   already in the list of our known hosts.
   Returns HOST_OK if the host is known and has the specified key,
   HOST_NEW if the host is not known, and HOST_CHANGED if the host is known
   but used to have a different host key. */
d194 5
a198 3
	/* Return value when the loop terminates.  This is set to
	   HOST_CHANGED if we have seen a different key for the host and
	   have not found the proper one. */
d209 3
a211 4
		/* Skip any leading whitespace. */
		for (; *cp == ' ' || *cp == '\t'; cp++);

		/* Ignore comment lines and empty lines. */
d216 2
a217 1
		for (cp2 = cp; *cp2 && *cp2 != ' ' && *cp2 != '\t'; cp2++);
d226 4
a229 2
		/* Extract the key from the line.  This will skip any
		   leading whitespace.  Ignore badly formatted lines. */
d246 5
a250 3
		/* They do not match.  We will continue to go through the
		   file; however, we note that we will not return that it
		   is new. */
d256 4
a259 2
	/* Return either HOST_NEW or HOST_CHANGED, depending on whether we
	   saw a different key for the host. */
d263 4
a266 2
/* Appends an entry to the host file.  Returns false if the entry
   could not be appended. */
@


1.7
log
@KNF part 1
@
text
@d2 13
a14 13

hostfile.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Thu Jun 29 07:10:56 1995 ylo

Functions for manipulating the known hosts files.

*/
d17 1
a17 1
RCSID("$Id: hostfile.c,v 1.6 1999/11/16 15:44:41 provos Exp $");
@


1.6
log
@in known_hosts key lookup the entry for the bits does not need to match, all
the information is contained in n and e.  This solves the problem with buggy
servers announcing the wrong modulus length.  markus and me.
@
text
@d17 1
a17 1
RCSID("$Id: hostfile.c,v 1.5 1999/11/15 20:53:24 markus Exp $");
d29 1
a29 1
auth_rsa_read_bignum(char **cpp, BIGNUM *value)
d31 2
a32 2
  char *cp = *cpp;
  int len, old;
d34 31
a64 33
  /* Skip any leading whitespace. */
  for (; *cp == ' ' || *cp == '\t'; cp++)
    ;

  /* Check that it begins with a hex digit. */
  if (*cp < '0' || *cp > '9')
    return 0;

  /* Save starting position. */
  *cpp = cp;

  /* Move forward until all hex digits skipped. */
  for (; *cp >= '0' && *cp <= '9'; cp++)
    ;

  /* Compute the length of the hex number. */
  len = cp - *cpp;

  /* Save the old terminating character, and replace it by \0. */
  old = *cp;
  *cp = 0;

  
  /* Parse the number. */
  if (BN_dec2bn(&value, *cpp) == 0)
    return 0;

  /* Restore old terminating character. */
  *cp = old;

  /* Move beyond the number and return success. */
  *cpp = cp;
  return 1;
d71 1
a71 1
auth_rsa_read_key(char **cpp, unsigned int *bitsp, BIGNUM *e, BIGNUM *n)
d73 5
a77 2
  unsigned int bits;
  char *cp;
d79 21
a99 26
  /* Skip leading whitespace. */
  for (cp = *cpp; *cp == ' ' || *cp == '\t'; cp++)
    ;

  /* Get number of bits. */
  if (*cp < '0' || *cp > '9')
    return 0; /* Bad bit count... */
  for (bits = 0; *cp >= '0' && *cp <= '9'; cp++)
    bits = 10 * bits + *cp - '0';

  /* Get public exponent. */
  if (!auth_rsa_read_bignum(&cp, e))
    return 0;

  /* Get public modulus. */
  if (!auth_rsa_read_bignum(&cp, n))
    return 0;

  /* Skip trailing whitespace. */
  for (; *cp == ' ' || *cp == '\t'; cp++)
    ;
  
  /* Return results. */
  *cpp = cp;
  *bitsp = bits;
  return 1;
d103 1
a103 1
   comma-separated sequence of subpatterns (each possibly preceded by ! to 
d110 40
a149 13
  char sub[1024];
  int negated;
  int got_positive;
  unsigned int i, subi;

  got_positive = 0;
  for (i = 0; i < len;)
    {
      /* Check if the subpattern is negated. */
      if (pattern[i] == '!')
	{
	  negated = 1;
	  i++;
d151 5
a155 32
      else
	negated = 0;
      
      /* Extract the subpattern up to a comma or end.  Convert the subpattern
         to lowercase. */
      for (subi = 0; 
	   i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';
	   subi++, i++)
	sub[subi] = isupper(pattern[i]) ? tolower(pattern[i]) : pattern[i];
      /* If subpattern too long, return failure (no match). */
      if (subi >= sizeof(sub) - 1)
	return 0;

      /* If the subpattern was terminated by a comma, skip the comma. */
      if (i < len && pattern[i] == ',')
	i++;
      
      /* Null-terminate the subpattern. */
      sub[subi] = '\0';

      /* Try to match the subpattern against the host name. */
      if (match_pattern(host, sub)) {
	if (negated)
	  return 0;  /* Fail if host matches any negated subpattern. */
        else
	  got_positive = 1;
      }
    }

  /* Return success if got a positive match.  If there was a negative match,
     we have already returned zero and never get here. */
  return got_positive;
d158 1
a158 1
/* Checks whether the given host (which must be in all lowercase) is 
d166 1
a166 1
		       BIGNUM *e, BIGNUM *n, BIGNUM *ke, BIGNUM *kn)
d168 67
a234 67
  FILE *f;
  char line[8192];
  int linenum = 0;
  unsigned int bits, kbits, hostlen;
  char *cp, *cp2;
  HostStatus end_return;

  /* Open the file containing the list of known hosts. */
  f = fopen(filename, "r");
  if (!f)
    return HOST_NEW;

  /* Cache the length of the host name. */
  hostlen = strlen(host);
  
  /* Return value when the loop terminates.  This is set to HOST_CHANGED if
     we have seen a different key for the host and have not found the proper
     one. */
  end_return = HOST_NEW;

  /* size of modulus 'n' */
  bits = BN_num_bits(n);

  /* Go trough the file. */
  while (fgets(line, sizeof(line), f))
    {
      cp = line;
      linenum++;

      /* Skip any leading whitespace. */
      for (; *cp == ' ' || *cp == '\t'; cp++)
	;

      /* Ignore comment lines and empty lines. */
      if (!*cp || *cp == '#' || *cp == '\n')
	continue;
      
      /* Find the end of the host name portion. */
      for (cp2 = cp; *cp2 && *cp2 != ' ' && *cp2 != '\t'; cp2++)
	;

      /* Check if the host name matches. */
      if (!match_hostname(host, cp, (unsigned int)(cp2 - cp)))
	continue;
      
      /* Got a match.  Skip host name. */
      cp = cp2;
      
      /* Extract the key from the line.  This will skip any leading 
	 whitespace.  Ignore badly formatted lines. */
      if (!auth_rsa_read_key(&cp, &kbits, ke, kn))
	continue;

      if (kbits != BN_num_bits(kn)) {
        error("Warning: error in %s, line %d: keysize mismatch for host %s: "
	      "actual size %d vs. announced %d.",
	      filename, linenum, host, BN_num_bits(kn), kbits);
        error("Warning: replace %d with %d in %s, line %d.",
	      kbits, BN_num_bits(kn), filename, linenum);
      }

      /* Check if the current key is the same as the given key. */
      if (BN_cmp(ke, e) == 0 && BN_cmp(kn, n) == 0)
	{
	  /* Ok, they match. */
	  fclose(f);
	  return HOST_OK;
d236 6
a241 11
      
      /* They do not match.  We will continue to go through the file; however,
	 we note that we will not return that it is new. */
      end_return = HOST_CHANGED;
    }
  /* Clear variables and close the file. */
  fclose(f);

  /* Return either HOST_NEW or HOST_CHANGED, depending on whether we saw a
     different key for the host. */
  return end_return;
d249 1
a249 1
		     BIGNUM *e, BIGNUM *n)
d251 34
a284 34
  FILE *f;
  char *buf;
  unsigned int bits;
 
  /* Open the file for appending. */
  f = fopen(filename, "a");
  if (!f)
    return 0;

  /* size of modulus 'n' */
  bits = BN_num_bits(n);

  /* Print the host name and key to the file. */
  fprintf(f, "%s %u ", host, bits);
  buf = BN_bn2dec(e);
  if (buf == NULL) {
    error("add_host_to_hostfile: BN_bn2dec(e) failed");
    fclose(f);
    return 0;
  }
  fprintf(f, "%s ", buf);
  free (buf);
  buf = BN_bn2dec(n);
  if (buf == NULL) {
    error("add_host_to_hostfile: BN_bn2dec(n) failed");
    fclose(f);
    return 0;
  }
  fprintf(f, "%s\n", buf);
  free (buf);

  /* Close the file. */
  fclose(f);
  return 1;
@


1.5
log
@the keysize of rsa-parameter 'n' is passed implizit,
a few more checks and warnings about 'pretended' keysizes.
@
text
@d17 1
a17 1
RCSID("$Id: hostfile.c,v 1.4 1999/11/02 19:42:36 markus Exp $");
d234 1
a234 1
      if (kbits == bits && BN_cmp(ke, e) == 0 && BN_cmp(kn, n) == 0)
@


1.4
log
@replace assert() with error, fatal or packet_disconnect
@
text
@d17 1
a17 1
RCSID("$Id: hostfile.c,v 1.3 1999/10/03 21:50:03 provos Exp $");
d169 2
a170 4
check_host_in_hostfile(const char *filename, 
		       const char *host, unsigned int bits,
		       BIGNUM *e, BIGNUM *n,
		       BIGNUM *ke, BIGNUM *kn)
d174 2
a175 1
  unsigned int kbits, hostlen;
a177 1
  struct stat st;
d182 1
a182 8
    {
      if (stat(filename, &st) >= 0)
	{
	  packet_send_debug("Could not open %.900s for reading.", filename);
	  packet_send_debug("If your home directory is on an NFS volume, it may need to be world-readable.");
	}
      return HOST_NEW;
    }
d192 3
d199 1
d225 9
a233 1
      /* Check if the current key is the same as the previous one. */
d258 1
a258 1
		     unsigned int bits, BIGNUM *e, BIGNUM *n)
d262 1
d269 3
d276 1
a276 1
    error("add_host_to_hostfile: BN_bn2dec #1 failed");
d284 1
a284 1
    error("add_host_to_hostfile: BN_bn2dec #2 failed");
@


1.3
log
@add code to detect DNS spoofing:

the main idea is to not only store the host key for the hostname but
also for the according IP address.  When we check the host key in the
known_hosts file, we also check the key against the according IP address.
When the server key changes, host_status = HOST_CHANGED.  If
check_host_in_hostfile() returns differing status for the IP address
that means that either DNS was spoofed or that the IP address
for the host and the host key changed at the same time.
@
text
@d17 1
a17 1
RCSID("$Id: hostfile.c,v 1.2 1999/09/28 04:45:36 provos Exp $");
d268 5
a272 1
  assert(buf != NULL);
d276 5
a280 1
  assert(buf != NULL);
@


1.2
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d17 1
a17 1
RCSID("$Id: hostfile.c,v 1.2 1999/05/04 11:58:44 bg Exp $");
d171 2
a172 1
		       BIGNUM *e, BIGNUM *n)
a179 1
  BIGNUM *ke, *kn;
a192 4
  /* Initialize mp-int variables. */
  ke = BN_new();
  kn = BN_new();
  
a233 2
	  BN_clear_free(ke);
	  BN_clear_free(kn);
a242 2
  BN_clear_free(ke);
  BN_clear_free(kn);
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d28 2
a29 1
int auth_rsa_read_mp_int(char **cpp, MP_INT *value)
d56 1
d58 1
a58 1
  if (mpz_set_str(value, *cpp, 10) != 0)
d72 2
a73 1
int auth_rsa_read_key(char **cpp, unsigned int *bitsp, MP_INT *e, MP_INT *n)
d89 1
a89 1
  if (!auth_rsa_read_mp_int(&cp, e))
d93 1
a93 1
  if (!auth_rsa_read_mp_int(&cp, n))
d111 2
a112 1
int match_hostname(const char *host, const char *pattern, unsigned int len)
d149 1
a149 1
      if (match_pattern(host, sub))
d154 1
d168 4
a171 3
HostStatus check_host_in_hostfile(const char *filename, 
				  const char *host, unsigned int bits,
				  MP_INT *e, MP_INT *n)
a174 1
  MP_INT ke, kn;
d179 1
d194 2
a195 2
  mpz_init(&ke);
  mpz_init(&kn);
d231 1
a231 1
      if (!auth_rsa_read_key(&cp, &kbits, &ke, &kn))
d235 1
a235 1
      if (kbits == bits && mpz_cmp(&ke, e) == 0 && mpz_cmp(&kn, n) == 0)
d238 2
a239 2
	  mpz_clear(&ke);
	  mpz_clear(&kn);
d249 2
a250 2
  mpz_clear(&ke);
  mpz_clear(&kn);
d261 3
a263 2
int add_host_to_hostfile(const char *filename, const char *host,
			 unsigned int bits, MP_INT *e, MP_INT *n)
d266 1
d275 8
a282 4
  mpz_out_str(f, 10, e);
  fprintf(f, " ");
  mpz_out_str(f, 10, n);
  fprintf(f, "\n");
@

