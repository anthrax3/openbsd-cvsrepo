head	1.129;
access;
symbols
	OPENBSD_6_1:1.121.0.4
	OPENBSD_6_1_BASE:1.121
	OPENBSD_6_0:1.118.0.8
	OPENBSD_6_0_BASE:1.118
	OPENBSD_5_9:1.118.0.4
	OPENBSD_5_9_BASE:1.118
	OPENBSD_5_8:1.118.0.2
	OPENBSD_5_8_BASE:1.118
	OPENBSD_5_7:1.116.0.2
	OPENBSD_5_7_BASE:1.116
	OPENBSD_5_6:1.115.0.4
	OPENBSD_5_6_BASE:1.115
	OPENBSD_5_5:1.113.0.6
	OPENBSD_5_5_BASE:1.113
	OPENBSD_5_4:1.113.0.2
	OPENBSD_5_4_BASE:1.113
	OPENBSD_5_3:1.111.0.4
	OPENBSD_5_3_BASE:1.111
	OPENBSD_5_2:1.111.0.2
	OPENBSD_5_2_BASE:1.111
	OPENBSD_5_1_BASE:1.109
	OPENBSD_5_1:1.109.0.2
	OPENBSD_5_0:1.105.0.2
	OPENBSD_5_0_BASE:1.105
	OPENBSD_4_9:1.104.0.4
	OPENBSD_4_9_BASE:1.104
	OPENBSD_4_8:1.104.0.2
	OPENBSD_4_8_BASE:1.104
	OPENBSD_4_7:1.103.0.2
	OPENBSD_4_7_BASE:1.103
	OPENBSD_4_6:1.98.0.6
	OPENBSD_4_6_BASE:1.98
	OPENBSD_4_5:1.98.0.2
	OPENBSD_4_5_BASE:1.98
	OPENBSD_4_4:1.96.0.2
	OPENBSD_4_4_BASE:1.96
	OPENBSD_4_3:1.89.0.4
	OPENBSD_4_3_BASE:1.89
	OPENBSD_4_2:1.89.0.2
	OPENBSD_4_2_BASE:1.89
	OPENBSD_4_1:1.88.0.2
	OPENBSD_4_1_BASE:1.88
	OPENBSD_4_0:1.88.0.4
	OPENBSD_4_0_BASE:1.88
	OPENBSD_3_9:1.83.0.2
	OPENBSD_3_9_BASE:1.83
	OPENBSD_3_8:1.79.0.2
	OPENBSD_3_8_BASE:1.79
	OPENBSD_3_7:1.76.0.2
	OPENBSD_3_7_BASE:1.76
	OPENBSD_3_6:1.74.0.2
	OPENBSD_3_6_BASE:1.74
	OPENBSD_3_5:1.71.0.2
	OPENBSD_3_5_BASE:1.71
	OPENBSD_3_4:1.70.0.6
	OPENBSD_3_4_BASE:1.70
	OPENBSD_3_3:1.70.0.4
	OPENBSD_3_3_BASE:1.70
	OPENBSD_3_2:1.70.0.2
	OPENBSD_3_2_BASE:1.70
	OPENBSD_3_1:1.67.0.2
	OPENBSD_3_1_BASE:1.67
	OPENBSD_3_0:1.50.0.2
	OPENBSD_3_0_BASE:1.50
	OPENBSD_2_9_BASE:1.31
	OPENBSD_2_9:1.31.0.2
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.129
date	2017.09.12.06.35.32;	author djm;	state Exp;
branches;
next	1.128;
commitid	dCi8XAU8Wl0yr6jz;

1.128
date	2017.09.12.06.32.07;	author djm;	state Exp;
branches;
next	1.127;
commitid	Amj5uk8F1JrQpmI5;

1.127
date	2017.08.30.03.59.08;	author djm;	state Exp;
branches;
next	1.126;
commitid	y3aRFk7WWt6orSgY;

1.126
date	2017.05.30.14.23.52;	author markus;	state Exp;
branches;
next	1.125;
commitid	tEOGxoM4kvBMLD6J;

1.125
date	2017.05.26.19.35.50;	author markus;	state Exp;
branches;
next	1.124;
commitid	FJuDC2xBxXzmleXf;

1.124
date	2017.05.26.19.34.12;	author markus;	state Exp;
branches;
next	1.123;
commitid	f3BVDuNkonQJrWkO;

1.123
date	2017.04.30.23.28.41;	author djm;	state Exp;
branches;
next	1.122;
commitid	mCEJ1LTymp03ZrA9;

1.122
date	2017.04.30.23.13.25;	author djm;	state Exp;
branches;
next	1.121;
commitid	Ss7V57MvgEZubdtr;

1.121
date	2017.02.01.02.59.09;	author dtucker;	state Exp;
branches;
next	1.120;
commitid	e2JoLM95qcfyR1rz;

1.120
date	2016.10.18.17.32.54;	author dtucker;	state Exp;
branches;
next	1.119;
commitid	JggzBelUQQppwx9c;

1.119
date	2016.09.30.09.19.13;	author markus;	state Exp;
branches;
next	1.118;
commitid	VHQRRel9yTEUINVH;

1.118
date	2015.07.01.02.26.31;	author djm;	state Exp;
branches;
next	1.117;
commitid	qLSneKZZQQvEyM5i;

1.117
date	2015.05.08.06.45.13;	author djm;	state Exp;
branches;
next	1.116;
commitid	7qzGw6zdRwtS8emI;

1.116
date	2015.01.19.20.07.45;	author markus;	state Exp;
branches;
next	1.115;
commitid	GrtSC5ve2VERgUln;

1.115
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.114;
commitid	z7plx8Gkj6l2sxem;

1.114
date	2014.06.27.16.41.56;	author markus;	state Exp;
branches;
next	1.113;
commitid	npS0wYoZKjQDRx0P;

1.113
date	2013.06.07.15.37.52;	author dtucker;	state Exp;
branches;
next	1.112;

1.112
date	2013.06.02.21.01.51;	author dtucker;	state Exp;
branches;
next	1.111;

1.111
date	2012.04.11.13.16.19;	author djm;	state Exp;
branches;
next	1.110;

1.110
date	2012.03.29.23.54.36;	author dtucker;	state Exp;
branches;
next	1.109;

1.109
date	2011.09.23.07.45.05;	author markus;	state Exp;
branches;
next	1.108;

1.108
date	2011.09.23.00.22.04;	author dtucker;	state Exp;
branches;
next	1.107;

1.107
date	2011.09.10.22.26.34;	author markus;	state Exp;
branches;
next	1.106;

1.106
date	2011.09.09.22.46.44;	author djm;	state Exp;
branches;
next	1.105;

1.105
date	2011.06.22.22.08.42;	author djm;	state Exp;
branches;
next	1.104;

1.104
date	2010.05.14.23.29.23;	author djm;	state Exp;
branches;
next	1.103;

1.103
date	2010.01.26.01.28.35;	author djm;	state Exp;
branches;
next	1.102;

1.102
date	2010.01.11.01.39.46;	author dtucker;	state Exp;
branches;
next	1.101;

1.101
date	2010.01.09.23.04.13;	author dtucker;	state Exp;
branches;
next	1.100;

1.100
date	2009.11.11.21.37.03;	author markus;	state Exp;
branches;
next	1.99;

1.99
date	2009.10.28.16.38.18;	author reyk;	state Exp;
branches;
next	1.98;

1.98
date	2009.02.12.03.00.56;	author djm;	state Exp;
branches;
next	1.97;

1.97
date	2009.01.22.09.46.01;	author djm;	state Exp;
branches;
next	1.96;

1.96
date	2008.06.15.20.06.26;	author djm;	state Exp;
branches;
next	1.95;

1.95
date	2008.06.12.15.19.17;	author djm;	state Exp;
branches;
next	1.94;

1.94
date	2008.06.12.03.40.52;	author djm;	state Exp;
branches;
next	1.93;

1.93
date	2008.06.10.04.50.25;	author dtucker;	state Exp;
branches;
next	1.92;

1.92
date	2008.05.09.16.21.13;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2008.05.09.04.55.56;	author djm;	state Exp;
branches;
next	1.90;

1.90
date	2008.05.08.12.02.23;	author djm;	state Exp;
branches;
next	1.89;

1.89
date	2007.06.11.09.14.00;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2006.07.21.12.43.36;	author dtucker;	state Exp;
branches;
next	1.86;

1.86
date	2006.07.17.12.06.00;	author dtucker;	state Exp;
branches;
next	1.85;

1.85
date	2006.07.11.18.50.47;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2006.03.25.22.22.42;	author djm;	state Exp;
branches;
next	1.83;

1.83
date	2005.12.30.15.56.37;	author reyk;	state Exp;
branches
	1.83.2.1;
next	1.82;

1.82
date	2005.12.12.13.46.18;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2005.12.06.22.38.27;	author reyk;	state Exp;
branches;
next	1.80;

1.80
date	2005.10.10.10.23.08;	author djm;	state Exp;
branches;
next	1.79;

1.79
date	2005.07.17.06.49.04;	author djm;	state Exp;
branches
	1.79.2.1;
next	1.78;

1.78
date	2005.07.08.09.41.33;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2005.06.16.03.38.36;	author djm;	state Exp;
branches;
next	1.76;

1.76
date	2005.03.01.10.09.52;	author djm;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2004.10.29.21.47.15;	author djm;	state Exp;
branches;
next	1.74;

1.74
date	2004.08.11.21.43.04;	author avsm;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2004.06.13.15.03.02;	author djm;	state Exp;
branches;
next	1.72;

1.72
date	2004.05.21.11.33.11;	author djm;	state Exp;
branches;
next	1.71;

1.71
date	2003.09.23.20.41.11;	author markus;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2002.06.24.14.33.27;	author markus;	state Exp;
branches
	1.70.4.1
	1.70.6.1;
next	1.69;

1.69
date	2002.06.23.21.06.41;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2002.06.10.22.28.41;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2002.03.26.22.50.39;	author markus;	state Exp;
branches
	1.67.2.1;
next	1.66;

1.66
date	2002.03.25.21.13.51;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2002.03.04.17.27.39;	author stevesk;	state Exp;
branches;
next	1.64;

1.64
date	2002.02.14.23.28.00;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2002.02.05.14.32.55;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2002.02.03.17.58.21;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2002.02.03.17.55.55;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2002.01.16.13.17.51;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2002.01.14.13.57.03;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2002.01.14.13.55.55;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2002.01.13.21.31.20;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2001.12.28.15.06.00;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2001.12.20.22.50.24;	author djm;	state Exp;
branches;
next	1.54;

1.54
date	2001.12.20.16.37.29;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2001.11.29.21.10.51;	author stevesk;	state Exp;
branches;
next	1.52;

1.52
date	2001.11.29.19.06.39;	author stevesk;	state Exp;
branches;
next	1.51;

1.51
date	2001.11.07.22.53.21;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2001.10.10.22.18.47;	author markus;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2001.10.09.21.59.41;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2001.10.07.17.49.40;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2001.10.01.21.38.53;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2001.09.17.20.52.47;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2001.07.17.21.04.57;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2001.07.02.22.52.57;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.30.18.08.40;	author stevesk;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.26.17.27.23;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.26.06.32.49;	author itojun;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.25.08.25.36;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.20.13.56.39;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.16.08.50.39;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.04.21.59.42;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.03.14.55.39;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.31.10.30.15;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.30.12.55.10;	author markus;	state dead;
branches;
next	1.33;

1.33
date	2001.05.28.23.14.49;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.04.23.47.33;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.13.22.46.53;	author beck;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2001.04.07.08.55.17;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.04.20.25.36;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.16.19.06.29;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2001.02.15.23.19.59;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.31.20.37.23;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.29.16.55.36;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2000.12.05.20.34.10;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.06.23.04.56;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.27.07.48.22;	author markus;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2000.10.27.07.32.18;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.21.11.25.33;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.07.21.13.37;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.07.20.40.29;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.07.20.27.50;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.19.21.55.51;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.19.18.48.11;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.20.01.39.40;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.30.17.23.37;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.03.18.03.06;	author markus;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.05.02.12.44.38;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.28.08.10.20;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.14.10.30.30;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.03.07.07.15;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.28.20.31.26;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.11.24.19.53.45;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	99.11.24.00.26.01;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.10.28.21.26.09;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	99.10.17.16.56.09;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	99.10.16.22.29.00;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	99.10.16.20.47.13;	author markus;	state Exp;
branches;
next	;

1.12.2.1
date	2000.06.12.02.37.32;	author jason;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2000.09.01.18.23.18;	author jason;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2000.11.08.21.30.34;	author jason;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2001.03.12.15.44.09;	author jason;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2001.03.21.18.52.40;	author jason;	state Exp;
branches;
next	;

1.22.2.1
date	2001.02.16.20.12.57;	author jason;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2001.02.19.17.18.46;	author jason;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2001.03.21.19.46.23;	author jason;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2001.05.07.21.09.27;	author jason;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2001.06.12.22.47.35;	author miod;	state Exp;
branches;
next	1.22.2.6;

1.22.2.6
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.22.2.7;

1.22.2.7
date	2001.11.15.00.14.59;	author miod;	state Exp;
branches;
next	1.22.2.8;

1.22.2.8
date	2001.11.15.22.50.30;	author miod;	state Exp;
branches;
next	1.22.2.9;

1.22.2.9
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.31.2.1
date	2001.06.12.22.31.48;	author jason;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.31.2.4;

1.31.2.4
date	2001.11.15.22.51.15;	author miod;	state Exp;
branches;
next	1.31.2.5;

1.31.2.5
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.31.2.6;

1.31.2.6
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.50.2.1
date	2001.11.14.03.24.38;	author jason;	state Exp;
branches;
next	1.50.2.2;

1.50.2.2
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.50.2.3;

1.50.2.3
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.50.2.4;

1.50.2.4
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.50.2.5;

1.50.2.5
date	2002.06.26.18.22.34;	author miod;	state Exp;
branches;
next	;

1.67.2.1
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	;

1.70.4.1
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.70.6.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.70.6.2;

1.70.6.2
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.71.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	1.71.2.2;

1.71.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.74.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.74.2.2;

1.74.2.2
date	2005.09.02.03.44.59;	author brad;	state Exp;
branches;
next	;

1.76.2.1
date	2005.09.04.18.40.01;	author brad;	state Exp;
branches;
next	1.76.2.2;

1.76.2.2
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.79.2.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.79.2.2;

1.79.2.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.83.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.129
log
@Make remote channel ID a u_int

Previously we tracked the remote channel IDs in an int, but this is
strictly incorrect: the wire protocol uses uint32 and there is nothing
in-principle stopping a SSH implementation from sending, say, 0xffff0000.

In practice everyone numbers their channels sequentially, so this has
never been a problem.

ok markus@@
@
text
@/* $OpenBSD: channels.h,v 1.128 2017/09/12 06:32:07 djm Exp $ */

/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */
/*
 * Copyright (c) 1999, 2000, 2001, 2002 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef CHANNEL_H
#define CHANNEL_H

/* Definitions for channel types. */
#define SSH_CHANNEL_X11_LISTENER	1	/* Listening for inet X11 conn. */
#define SSH_CHANNEL_PORT_LISTENER	2	/* Listening on a port. */
#define SSH_CHANNEL_OPENING		3	/* waiting for confirmation */
#define SSH_CHANNEL_OPEN		4	/* normal open two-way channel */
#define SSH_CHANNEL_CLOSED		5	/* waiting for close confirmation */
#define SSH_CHANNEL_AUTH_SOCKET		6	/* authentication socket */
#define SSH_CHANNEL_X11_OPEN		7	/* reading first X11 packet */
#define SSH_CHANNEL_LARVAL		10	/* larval session */
#define SSH_CHANNEL_RPORT_LISTENER	11	/* Listening to a R-style port  */
#define SSH_CHANNEL_CONNECTING		12
#define SSH_CHANNEL_DYNAMIC		13
#define SSH_CHANNEL_ZOMBIE		14	/* Almost dead. */
#define SSH_CHANNEL_MUX_LISTENER	15	/* Listener for mux conn. */
#define SSH_CHANNEL_MUX_CLIENT		16	/* Conn. to mux slave */
#define SSH_CHANNEL_ABANDONED		17	/* Abandoned session, eg mux */
#define SSH_CHANNEL_UNIX_LISTENER	18	/* Listening on a domain socket. */
#define SSH_CHANNEL_RUNIX_LISTENER	19	/* Listening to a R-style domain socket. */
#define SSH_CHANNEL_MUX_PROXY		20	/* proxy channel for mux-slave */
#define SSH_CHANNEL_MAX_TYPE		21

#define CHANNEL_CANCEL_PORT_STATIC	-1

struct ssh;
struct Channel;
typedef struct Channel Channel;
struct fwd_perm_list;

typedef void channel_open_fn(struct ssh *, int, int, void *);
typedef void channel_callback_fn(struct ssh *, int, void *);
typedef int channel_infilter_fn(struct ssh *, struct Channel *, char *, int);
typedef void channel_filter_cleanup_fn(struct ssh *, int, void *);
typedef u_char *channel_outfilter_fn(struct ssh *, struct Channel *,
    u_char **, size_t *);

/* Channel success/failure callbacks */
typedef void channel_confirm_cb(struct ssh *, int, struct Channel *, void *);
typedef void channel_confirm_abandon_cb(struct ssh *, struct Channel *, void *);
struct channel_confirm {
	TAILQ_ENTRY(channel_confirm) entry;
	channel_confirm_cb *cb;
	channel_confirm_abandon_cb *abandon_cb;
	void *ctx;
};
TAILQ_HEAD(channel_confirms, channel_confirm);

/* Context for non-blocking connects */
struct channel_connect {
	char *host;
	int port;
	struct addrinfo *ai, *aitop;
};

/* Callbacks for mux channels back into client-specific code */
typedef int mux_callback_fn(struct ssh *, struct Channel *);

struct Channel {
	int     type;		/* channel type/state */
	int     self;		/* my own channel identifier */
	uint32_t remote_id;	/* channel identifier for remote peer */
	int	have_remote_id;	/* non-zero if remote_id is valid */

	u_int   istate;		/* input from channel (state of receive half) */
	u_int   ostate;		/* output to channel  (state of transmit half) */
	int     flags;		/* close sent/rcvd */
	int     rfd;		/* read fd */
	int     wfd;		/* write fd */
	int     efd;		/* extended fd */
	int     sock;		/* sock fd */
	int     ctl_chan;	/* control channel (multiplexed connections) */
	int     isatty;		/* rfd is a tty */
	int	client_tty;	/* (client) TTY has been requested */
	int     force_drain;	/* force close on iEOF */
	time_t	notbefore;	/* Pause IO until deadline (time_t) */
	int     delayed;	/* post-select handlers for newly created
				 * channels are delayed until the first call
				 * to a matching pre-select handler.
				 * this way post-select handlers are not
				 * accidentally called if a FD gets reused */
	struct sshbuf *input;	/* data read from socket, to be sent over
				 * encrypted connection */
	struct sshbuf *output;	/* data received over encrypted connection for
				 * send on socket */
	struct sshbuf *extended;

	char    *path;
		/* path for unix domain sockets, or host name for forwards */
	int     listening_port;	/* port being listened for forwards */
	char   *listening_addr;	/* addr being listened for forwards */
	int     host_port;	/* remote port to connect for forwards */
	char   *remote_name;	/* remote hostname */

	u_int	remote_window;
	u_int	remote_maxpacket;
	u_int	local_window;
	u_int	local_window_max;
	u_int	local_consumed;
	u_int	local_maxpacket;
	int     extended_usage;
	int	single_connection;

	char   *ctype;		/* type */

	/* callback */
	channel_open_fn		*open_confirm;
	void			*open_confirm_ctx;
	channel_callback_fn	*detach_user;
	int			detach_close;
	struct channel_confirms	status_confirms;

	/* filter */
	channel_infilter_fn	*input_filter;
	channel_outfilter_fn	*output_filter;
	void			*filter_ctx;
	channel_filter_cleanup_fn *filter_cleanup;

	/* keep boundaries */
	int     		datagram;

	/* non-blocking connect */
	/* XXX make this a pointer so the structure can be opaque */
	struct channel_connect	connect_ctx;

	/* multiplexing protocol hook, called for each packet received */
	mux_callback_fn		*mux_rcb;
	void			*mux_ctx;
	int			mux_pause;
	int     		mux_downstream_id;
};

#define CHAN_EXTENDED_IGNORE		0
#define CHAN_EXTENDED_READ		1
#define CHAN_EXTENDED_WRITE		2

/* default window/packet sizes for tcp/x11-fwd-channel */
#define CHAN_SES_PACKET_DEFAULT	(32*1024)
#define CHAN_SES_WINDOW_DEFAULT	(64*CHAN_SES_PACKET_DEFAULT)
#define CHAN_TCP_PACKET_DEFAULT	(32*1024)
#define CHAN_TCP_WINDOW_DEFAULT	(64*CHAN_TCP_PACKET_DEFAULT)
#define CHAN_X11_PACKET_DEFAULT	(16*1024)
#define CHAN_X11_WINDOW_DEFAULT	(4*CHAN_X11_PACKET_DEFAULT)

/* possible input states */
#define CHAN_INPUT_OPEN			0
#define CHAN_INPUT_WAIT_DRAIN		1
#define CHAN_INPUT_WAIT_OCLOSE		2
#define CHAN_INPUT_CLOSED		3

/* possible output states */
#define CHAN_OUTPUT_OPEN		0
#define CHAN_OUTPUT_WAIT_DRAIN		1
#define CHAN_OUTPUT_WAIT_IEOF		2
#define CHAN_OUTPUT_CLOSED		3

#define CHAN_CLOSE_SENT			0x01
#define CHAN_CLOSE_RCVD			0x02
#define CHAN_EOF_SENT			0x04
#define CHAN_EOF_RCVD			0x08
#define CHAN_LOCAL			0x10

/* Read buffer size */
#define CHAN_RBUF	(16*1024)

/* Hard limit on number of channels */
#define CHANNELS_MAX_CHANNELS	(16*1024)

/* check whether 'efd' is still in use */
#define CHANNEL_EFD_INPUT_ACTIVE(c) \
	(c->extended_usage == CHAN_EXTENDED_READ && \
	(c->efd != -1 || \
	sshbuf_len(c->extended) > 0))
#define CHANNEL_EFD_OUTPUT_ACTIVE(c) \
	(c->extended_usage == CHAN_EXTENDED_WRITE && \
	c->efd != -1 && (!(c->flags & (CHAN_EOF_RCVD|CHAN_CLOSE_RCVD)) || \
	sshbuf_len(c->extended) > 0))

/* Add channel management structures to SSH transport instance */
void channel_init_channels(struct ssh *ssh);

/* channel management */

Channel	*channel_by_id(struct ssh *, int);
Channel	*channel_by_remote_id(struct ssh *, u_int);
Channel	*channel_lookup(struct ssh *, int);
Channel *channel_new(struct ssh *, char *, int, int, int, int,
	    u_int, u_int, int, char *, int);
void	 channel_set_fds(struct ssh *, int, int, int, int, int,
	    int, int, u_int);
void	 channel_free(struct ssh *, Channel *);
void	 channel_free_all(struct ssh *);
void	 channel_stop_listening(struct ssh *);

void	 channel_send_open(struct ssh *, int);
void	 channel_request_start(struct ssh *, int, char *, int);
void	 channel_register_cleanup(struct ssh *, int,
	    channel_callback_fn *, int);
void	 channel_register_open_confirm(struct ssh *, int,
	    channel_open_fn *, void *);
void	 channel_register_filter(struct ssh *, int, channel_infilter_fn *,
	    channel_outfilter_fn *, channel_filter_cleanup_fn *, void *);
void	 channel_register_status_confirm(struct ssh *, int,
	    channel_confirm_cb *, channel_confirm_abandon_cb *, void *);
void	 channel_cancel_cleanup(struct ssh *, int);
int	 channel_close_fd(struct ssh *, int *);
void	 channel_send_window_changes(struct ssh *);

/* mux proxy support */

int	 channel_proxy_downstream(struct ssh *, Channel *mc);
int	 channel_proxy_upstream(Channel *, int, u_int32_t, struct ssh *);

/* protocol handler */

int	 channel_input_data(int, u_int32_t, struct ssh *);
int	 channel_input_extended_data(int, u_int32_t, struct ssh *);
int	 channel_input_ieof(int, u_int32_t, struct ssh *);
int	 channel_input_oclose(int, u_int32_t, struct ssh *);
int	 channel_input_open_confirmation(int, u_int32_t, struct ssh *);
int	 channel_input_open_failure(int, u_int32_t, struct ssh *);
int	 channel_input_port_open(int, u_int32_t, struct ssh *);
int	 channel_input_window_adjust(int, u_int32_t, struct ssh *);
int	 channel_input_status_confirm(int, u_int32_t, struct ssh *);

/* file descriptor handling (read/write) */

void	 channel_prepare_select(struct ssh *, fd_set **, fd_set **, int *,
	     u_int*, time_t*);
void     channel_after_select(struct ssh *, fd_set *, fd_set *);
void     channel_output_poll(struct ssh *);

int      channel_not_very_much_buffered_data(struct ssh *);
void     channel_close_all(struct ssh *);
int      channel_still_open(struct ssh *);
char	*channel_open_message(struct ssh *);
int	 channel_find_open(struct ssh *);

/* tcp forwarding */
struct Forward;
struct ForwardOptions;
void	 channel_set_af(struct ssh *, int af);
void     channel_permit_all_opens(struct ssh *);
void	 channel_add_permitted_opens(struct ssh *, char *, int);
int	 channel_add_adm_permitted_opens(struct ssh *, char *, int);
void	 channel_copy_adm_permitted_opens(struct ssh *,
	    const struct fwd_perm_list *);
void	 channel_disable_adm_local_opens(struct ssh *);
void	 channel_update_permitted_opens(struct ssh *, int, int);
void	 channel_clear_permitted_opens(struct ssh *);
void	 channel_clear_adm_permitted_opens(struct ssh *);
void 	 channel_print_adm_permitted_opens(struct ssh *);
Channel	*channel_connect_to_port(struct ssh *, const char *, u_short,
	    char *, char *, int *, const char **);
Channel *channel_connect_to_path(struct ssh *, const char *, char *, char *);
Channel	*channel_connect_stdio_fwd(struct ssh *, const char*,
	    u_short, int, int);
Channel	*channel_connect_by_listen_address(struct ssh *, const char *,
	    u_short, char *, char *);
Channel	*channel_connect_by_listen_path(struct ssh *, const char *,
	    char *, char *);
int	 channel_request_remote_forwarding(struct ssh *, struct Forward *);
int	 channel_setup_local_fwd_listener(struct ssh *, struct Forward *,
	    struct ForwardOptions *);
int	 channel_request_rforward_cancel(struct ssh *, struct Forward *);
int	 channel_setup_remote_fwd_listener(struct ssh *, struct Forward *,
	    int *, struct ForwardOptions *);
int	 channel_cancel_rport_listener(struct ssh *, struct Forward *);
int	 channel_cancel_lport_listener(struct ssh *, struct Forward *,
	    int, struct ForwardOptions *);
int	 permitopen_port(const char *);

/* x11 forwarding */

void	 channel_set_x11_refuse_time(struct ssh *, u_int);
int	 x11_connect_display(struct ssh *);
int	 x11_create_display_inet(struct ssh *, int, int, int, u_int *, int **);
void	 x11_request_forwarding_with_spoofing(struct ssh *, int,
	    const char *, const char *, const char *, int);

/* channel close */

int	 chan_is_dead(struct ssh *, Channel *, int);
void	 chan_mark_dead(struct ssh *, Channel *);

/* channel events */

void	 chan_rcvd_oclose(struct ssh *, Channel *);
void	 chan_rcvd_eow(struct ssh *, Channel *);
void	 chan_read_failed(struct ssh *, Channel *);
void	 chan_ibuf_empty(struct ssh *, Channel *);
void	 chan_rcvd_ieof(struct ssh *, Channel *);
void	 chan_write_failed(struct ssh *, Channel *);
void	 chan_obuf_empty(struct ssh *, Channel *);

#endif
@


1.128
log
@refactor channels.c

Move static state to a "struct ssh_channels" that is allocated at
runtime and tracked as a member of struct ssh.

Explicitly pass "struct ssh" to all channels functions.

Replace use of the legacy packet APIs in channels.c.

Rework sshd_config PermitOpen handling: previously the configuration
parser would call directly into the channels layer. After the refactor
this is not possible, as the channels structures are allocated at
connection time and aren't available when the configuration is parsed.
The server config parser now tracks PermitOpen itself and explicitly
configures the channels code later.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.127 2017/08/30 03:59:08 djm Exp $ */
d100 3
a102 2
	int     remote_id;	/* channel identifier for remote peer */
				/* XXX should be uint32_t */
d223 1
a223 1
Channel	*channel_by_remote_id(struct ssh *, int);
@


1.127
log
@pass packet state down to some of the channels function (more
to come...); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.126 2017/05/30 14:23:52 markus Exp $ */
d67 1
d69 6
a74 5
typedef void channel_open_fn(int, int, void *);
typedef void channel_callback_fn(int, void *);
typedef int channel_infilter_fn(struct Channel *, char *, int);
typedef void channel_filter_cleanup_fn(int, void *);
typedef u_char *channel_outfilter_fn(struct Channel *, u_char **, u_int *);
d77 2
a78 2
typedef void channel_confirm_cb(int, struct Channel *, void *);
typedef void channel_confirm_abandon_cb(struct Channel *, void *);
d95 1
a95 1
typedef int mux_callback_fn(struct Channel *);
d101 1
d119 1
a119 1
	Buffer  input;		/* data read from socket, to be sent over
d121 1
a121 1
	Buffer  output;		/* data received over encrypted connection for
d123 2
a124 1
	Buffer  extended;
d160 1
d200 5
a204 1
#define CHAN_RBUF	16*1024
d210 1
a210 1
	buffer_len(&c->extended) > 0))
d214 4
a217 1
	buffer_len(&c->extended) > 0))
d221 24
a244 20
Channel	*channel_by_id(int);
Channel	*channel_by_remote_id(int);
Channel	*channel_lookup(int);
Channel *channel_new(char *, int, int, int, int, u_int, u_int, int, char *, int);
void	 channel_set_fds(int, int, int, int, int, int, int, u_int);
void	 channel_free(Channel *);
void	 channel_free_all(void);
void	 channel_stop_listening(void);

void	 channel_send_open(int);
void	 channel_request_start(int, char *, int);
void	 channel_register_cleanup(int, channel_callback_fn *, int);
void	 channel_register_open_confirm(int, channel_open_fn *, void *);
void	 channel_register_filter(int, channel_infilter_fn *,
    channel_outfilter_fn *, channel_filter_cleanup_fn *, void *);
void	 channel_register_status_confirm(int, channel_confirm_cb *,
    channel_confirm_abandon_cb *, void *);
void	 channel_cancel_cleanup(int);
int	 channel_close_fd(int *);
void	 channel_send_window_changes(void);
d248 1
a248 1
int	 channel_proxy_downstream(Channel *mc);
d268 1
a268 1
void     channel_output_poll(void);
d270 5
a274 5
int      channel_not_very_much_buffered_data(void);
void     channel_close_all(void);
int      channel_still_open(void);
char	*channel_open_message(void);
int	 channel_find_open(void);
d279 29
a307 22
void	 channel_set_af(int af);
void     channel_permit_all_opens(void);
void	 channel_add_permitted_opens(char *, int);
int	 channel_add_adm_permitted_opens(char *, int);
void	 channel_disable_adm_local_opens(void);
void	 channel_update_permitted_opens(int, int);
void	 channel_clear_permitted_opens(void);
void	 channel_clear_adm_permitted_opens(void);
void 	 channel_print_adm_permitted_opens(void);
Channel	*channel_connect_to_port(const char *, u_short, char *, char *, int *,
	     const char **);
Channel *channel_connect_to_path(const char *, char *, char *);
Channel	*channel_connect_stdio_fwd(const char*, u_short, int, int);
Channel	*channel_connect_by_listen_address(const char *, u_short,
	     char *, char *);
Channel	*channel_connect_by_listen_path(const char *, char *, char *);
int	 channel_request_remote_forwarding(struct Forward *);
int	 channel_setup_local_fwd_listener(struct Forward *, struct ForwardOptions *);
int	 channel_request_rforward_cancel(struct Forward *);
int	 channel_setup_remote_fwd_listener(struct Forward *, int *, struct ForwardOptions *);
int	 channel_cancel_rport_listener(struct Forward *);
int	 channel_cancel_lport_listener(struct Forward *, int, struct ForwardOptions *);
d312 5
a316 5
void	 channel_set_x11_refuse_time(u_int);
int	 x11_connect_display(void);
int	 x11_create_display_inet(int, int, int, u_int *, int **);
void	 x11_request_forwarding_with_spoofing(int, const char *, const char *,
	     const char *, int);
d320 2
a321 2
int	 chan_is_dead(Channel *, int);
void	 chan_mark_dead(Channel *);
d325 7
a331 8
void	 chan_rcvd_oclose(Channel *);
void	 chan_rcvd_eow(Channel *);	/* SSH2-only */
void	 chan_read_failed(Channel *);
void	 chan_ibuf_empty(Channel *);

void	 chan_rcvd_ieof(Channel *);
void	 chan_write_failed(Channel *);
void	 chan_obuf_empty(Channel *);
@


1.126
log
@protocol handlers all get struct ssh passed; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.125 2017/05/26 19:35:50 markus Exp $ */
d249 3
a251 3
void	 channel_prepare_select(fd_set **, fd_set **, int *, u_int*,
	     time_t*, int);
void     channel_after_select(fd_set *, fd_set *);
@


1.125
log
@remove SSH_CHANNEL_XXX_DRAINING (ssh1 only); ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.124 2017/05/26 19:34:12 markus Exp $ */
d64 1
d233 1
a233 1
int	 channel_proxy_upstream(Channel *, int, u_int32_t, void *);
d237 9
a245 8
int	 channel_input_data(int, u_int32_t, void *);
int	 channel_input_extended_data(int, u_int32_t, void *);
int	 channel_input_ieof(int, u_int32_t, void *);
int	 channel_input_oclose(int, u_int32_t, void *);
int	 channel_input_open_confirmation(int, u_int32_t, void *);
int	 channel_input_open_failure(int, u_int32_t, void *);
int	 channel_input_window_adjust(int, u_int32_t, void *);
int	 channel_input_status_confirm(int, u_int32_t, void *);
@


1.124
log
@remove channel_input_close_confirmation (ssh1 only); ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.123 2017/04/30 23:28:41 djm Exp $ */
a48 2
#define SSH_CHANNEL_INPUT_DRAINING	8	/* sending remaining data to conn */
#define SSH_CHANNEL_OUTPUT_DRAINING	9	/* sending remaining data to app */
@


1.123
log
@obliterate ssh1.h and some dead code that used it

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.122 2017/04/30 23:13:25 djm Exp $ */
a237 1
int	 channel_input_close_confirmation(int, u_int32_t, void *);
@


1.122
log
@remove compat20/compat13/compat15 variables

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.121 2017/02/01 02:59:09 dtucker Exp $ */
a237 1
int	 channel_input_close(int, u_int32_t, void *);
a244 1
int	 channel_input_port_open(int, u_int32_t, void *);
a292 1
int      x11_input_open(int, u_int32_t, void *);
a294 5
int	 deny_input_open(int, u_int32_t, void *);

/* agent forwarding */

void	 auth_request_forwarding(void);
@


1.121
log
@Return true reason for port forwarding failures where feasible rather
than always "administratively prohibited".  bz#2674, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.120 2016/10/18 17:32:54 dtucker Exp $ */
d200 1
a200 1
	(compat20 && c->extended_usage == CHAN_EXTENDED_READ && \
d204 1
a204 1
	(compat20 && c->extended_usage == CHAN_EXTENDED_WRITE && \
@


1.120
log
@Remove channel_input_port_forward_request(); the only caller was the
recently-removed SSH1 server code so it's now dead code.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.119 2016/09/30 09:19:13 markus Exp $ */
d275 2
a276 1
Channel	*channel_connect_to_port(const char *, u_short, char *, char *);
@


1.119
log
@ssh proxy mux mode (-O proxy; idea from Simon Tatham):
- mux client speaks the ssh-packet protocol directly over unix-domain socket.
- mux server acts as a proxy, translates channel IDs and relays to the server.
- no filedescriptor passing necessary.
- combined with unix-domain forwarding it's even possible to run mux client
  and server on different machines.
feedback & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.118 2015/07/01 02:26:31 djm Exp $ */
a274 1
int      channel_input_port_forward_request(int, struct ForwardOptions *);
@


1.118
log
@better refuse ForwardX11Trusted=no connections attempted after
ForwardX11Timeout expires; reported by Jann Horn
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.117 2015/05/08 06:45:13 djm Exp $ */
d61 2
a62 1
#define SSH_CHANNEL_MAX_TYPE		20
d163 1
d211 1
d230 5
@


1.117
log
@moar whitespace at eol
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.116 2015/01/19 20:07:45 markus Exp $ */
d284 1
@


1.116
log
@move dispatch to struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.115 2014/07/15 15:54:14 millert Exp $ */
d113 1
a113 1
				 * to a matching pre-select handler. 
@


1.115
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.114 2014/06/27 16:41:56 markus Exp $ */
d230 11
a240 11
void	 channel_input_close(int, u_int32_t, void *);
void	 channel_input_close_confirmation(int, u_int32_t, void *);
void	 channel_input_data(int, u_int32_t, void *);
void	 channel_input_extended_data(int, u_int32_t, void *);
void	 channel_input_ieof(int, u_int32_t, void *);
void	 channel_input_oclose(int, u_int32_t, void *);
void	 channel_input_open_confirmation(int, u_int32_t, void *);
void	 channel_input_open_failure(int, u_int32_t, void *);
void	 channel_input_port_open(int, u_int32_t, void *);
void	 channel_input_window_adjust(int, u_int32_t, void *);
void	 channel_input_status_confirm(int, u_int32_t, void *);
d286 1
a286 1
void     x11_input_open(int, u_int32_t, void *);
d289 1
a289 1
void	 deny_input_open(int, u_int32_t, void *);
@


1.114
log
@fix remote fwding with same listen port but different listen address
with gerhard@@, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.113 2013/06/07 15:37:52 dtucker Exp $ */
d59 3
a61 1
#define SSH_CHANNEL_MAX_TYPE		18
d256 2
d267 3
a269 2
int      channel_input_port_forward_request(int, int);
Channel	*channel_connect_to(const char *, u_short, char *, char *);
d273 7
a279 8
int	 channel_request_remote_forwarding(const char *, u_short,
	     const char *, u_short);
int	 channel_setup_local_fwd_listener(const char *, u_short,
	     const char *, u_short, int);
int	 channel_request_rforward_cancel(const char *host, u_short port);
int	 channel_setup_remote_fwd_listener(const char *, u_short, int *, int);
int	 channel_cancel_rport_listener(const char *, u_short);
int	 channel_cancel_lport_listener(const char *, u_short, int, int);
@


1.113
log
@Add an "ABANDONED" channel state and use for mux sessions that are
disconnected via the ~. escape sequence.  Channels in this state will
be able to close if the server responds, but do not count as active channels.
This means that if you ~. all of the mux clients when using ControlPersist
on a broken network, the backgrounded mux master will exit when the
Control Persist time expires rather than hanging around indefinitely.
bz#1917, also reported and tested by tedu@@.  ok djm@@ markus@@.
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.112 2013/06/02 21:01:51 dtucker Exp $ */
d266 2
a267 1
Channel	*channel_connect_by_listen_address(u_short, char *, char *);
@


1.112
log
@typo in comment
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.111 2012/04/11 13:16:19 djm Exp $ */
d58 2
a59 1
#define SSH_CHANNEL_MAX_TYPE		17
@


1.111
log
@don't spin in accept() when out of fds (ENFILE/ENFILE) - back off for a
while; ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.110 2012/03/29 23:54:36 dtucker Exp $ */
d112 1
a112 1
				 * accidenly called if a FD gets reused */
@


1.110
log
@Add PermitOpen none option based on patch from Loganaden Velvindron
(bz #1949).  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.109 2011/09/23 07:45:05 markus Exp $ */
d107 1
d241 2
a242 1
void	 channel_prepare_select(fd_set **, fd_set **, int *, u_int*, int);
@


1.109
log
@unbreak remote portforwarding with dynamic allocated listen ports:
1) send the actual listen port in the open message (instead of 0).
   this allows multiple forwardings with a dynamic listen port
2) update the matching permit-open entry, so we can identify where
   to connect to
report: den at skbkontur.ru and P. Szczygielski
feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.108 2011/09/23 00:22:04 dtucker Exp $ */
d255 1
@


1.108
log
@Add wildcard support to PermitOpen, allowing things like "PermitOpen
localhost:*".  bz #1857, ok djm markus.
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.107 2011/09/10 22:26:34 markus Exp $ */
d255 1
@


1.107
log
@support cancellation of local/dynamic forwardings from ~C commandline;
ok & feedback djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.106 2011/09/09 22:46:44 djm Exp $ */
d270 1
@


1.106
log
@support for cancelling local and remote port forwards via the multiplex
socket. Use ssh -O cancel -L xx:xx:xx -R yy:yy:yy user@@host" to request
the cancellation of the specified forwardings; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.105 2011/06/22 22:08:42 djm Exp $ */
d60 2
d269 1
a269 1
int	 channel_cancel_lport_listener(const char *, u_short, u_short, int);
@


1.105
log
@hook up a channel confirm callback to warn the user then requested X11
forwarding was refused by the server; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.104 2010/05/14 23:29:23 djm Exp $ */
d118 1
d264 1
a264 1
void	 channel_request_rforward_cancel(const char *host, u_short port);
d267 1
@


1.104
log
@Pause the mux channel while waiting for reply from aynch callbacks.
Prevents misordering of replies if new requests arrive while waiting.

Extend channel open confirm callback to allow signalling failure
conditions as well as success. Use this to 1) fix a memory leak, 2)
start using the above pause mechanism and 3) delay sending a success/
failure message on mux slave session open until we receive a reply from
the server.

motivated by and with feedback from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.103 2010/01/26 01:28:35 djm Exp $ */
d273 1
a273 1
	     const char *);
@


1.103
log
@rewrite ssh(1) multiplexing code to a more sensible protocol.

The new multiplexing code uses channels for the listener and
accepted control sockets to make the mux master non-blocking, so
no stalls when processing messages from a slave.

avoid use of fatal() in mux master protocol parsing so an errant slave
process cannot take down a running master.

implement requesting of port-forwards over multiplexed sessions. Any
port forwards requested by the slave are added to those the master has
established.

add support for stdio forwarding ("ssh -W host:port ...") in mux slaves.

document master/slave mux protocol so that other tools can use it to
control a running ssh(1). Note: there are no guarantees that this
protocol won't be incompatibly changed (though it is versioned).

feedback Salvador Fandino, dtucker@@
channel changes ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.102 2010/01/11 01:39:46 dtucker Exp $ */
d63 1
d133 1
a133 1
	channel_callback_fn	*open_confirm;
d154 1
d212 1
a212 1
void	 channel_register_open_confirm(int, channel_callback_fn *, void *);
@


1.102
log
@Add a 'netcat mode' (ssh -W).  This connects stdio on the client to a single
port forward on the server.  This allows, for example, using ssh as
a ProxyCommand to route connections via intermediate servers.
bz #1618, man page help from jmc@@, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.101 2010/01/09 23:04:13 dtucker Exp $ */
d56 3
a58 1
#define SSH_CHANNEL_MAX_TYPE		15
d86 3
d100 1
a100 1
	int     ctl_fd;		/* control fd (client sharing) */
d149 4
d183 1
d255 1
a255 1
Channel	*channel_connect_stdio_fwd(const char*, u_short);
@


1.101
log
@Remove RoutingDomain from ssh since it's now not needed.  It can be replaced
with "route exec" or "nc -V" as a proxycommand.  "route exec" also ensures
that trafic such as DNS lookups stays withing the specified routingdomain.

For example (from reyk):
# route -T 2 exec /usr/sbin/sshd
or inherited from the parent process
$ route -T 2 exec sh
$ ssh 10.1.2.3

ok deraadt@@ markus@@ stevesk@@ reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.98 2009/02/12 03:00:56 djm Exp $ */
d245 1
@


1.100
log
@fix race condition in x11/agent channel allocation: don't read after
the end of the select read/write fdset and make sure a reused FD
is not touched before the pre-handlers are called.
with and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.99 2009/10/28 16:38:18 reyk Exp $ */
a236 1
void	 channel_set_rdomain(int);
@


1.99
log
@Allow to set the rdomain in ssh/sftp/scp/sshd and ssh-keyscan.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.98 2009/02/12 03:00:56 djm Exp $ */
d99 5
a103 1
	int     delayed;		/* fdset hack */
@


1.98
log
@support remote port forwarding with a zero listen port (-R0:...) to
dyamically allocate a listen port at runtime (this is actually
specified in rfc4254); bz#1003 ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.97 2009/01/22 09:46:01 djm Exp $ */
d233 1
@


1.97
log
@make Channel->path an allocated string, saving a few bytes here and
there and fixing bz#1380 in the process; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.96 2008/06/15 20:06:26 djm Exp $ */
d247 1
a247 1
int	 channel_setup_remote_fwd_listener(const char *, u_short, int);
@


1.96
log
@don't call isatty() on a pty master, instead pass a flag down to
channel_set_fds() indicating that te fds refer to a tty. Fixes a
hang on exit on Solaris (bz#1463) in portable but is actually
a generic bug; ok dtucker deraadt markus
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.95 2008/06/12 15:19:17 djm Exp $ */
a57 2
#define SSH_CHANNEL_PATH_LEN		256

d105 1
a105 1
	char    path[SSH_CHANNEL_PATH_LEN];
@


1.95
log
@The multiplexing escape char handler commit last night introduced a
small memory leak per session; plug it.
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.94 2008/06/12 03:40:52 djm Exp $ */
d190 1
a190 1
void	 channel_set_fds(int, int, int, int, int, int, u_int);
@


1.94
log
@Enable ~ escapes for multiplex slave sessions; give each channel
its own escape state and hook the escape filters up to muxed
channels. bz #1331

Mux slaves do not currently support the ~^Z and ~& escapes.

NB. this change cranks the mux protocol version, so a new ssh
mux client will not be able to connect to a running old ssh
mux master.

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.93 2008/06/10 04:50:25 dtucker Exp $ */
d65 1
d135 1
d200 1
a200 1
    channel_outfilter_fn *, void *);
@


1.93
log
@Add extended test mode (-T) and connection parameters for test mode (-C).
-T causes sshd to write its effective configuration to stdout and exit.
-C causes any relevant Match rules to be applied before output.  The
combination allows tesing of the parser and config files.  ok deraadt djm
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.92 2008/05/09 16:21:13 markus Exp $ */
d133 1
d198 1
a198 1
    channel_outfilter_fn *);
@


1.92
log
@unbreak
	ssh -2 localhost od /bin/ls | true
ignoring SIGPIPE by adding a new channel message (EOW) that signals
the peer that we're not interested in any data it might send.
fixes bz #85; discussion, debugging and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.91 2008/05/09 04:55:56 djm Exp $ */
d237 1
@


1.91
log
@Try additional addresses when connecting to a port forward destination
whose DNS name resolves to more than one address. The previous behaviour
was to try the first address and give up.

Reported by stig AT venaas.com in bz#343

great feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.90 2008/05/08 12:02:23 djm Exp $ */
d269 1
@


1.90
log
@Implement a channel success/failure status confirmation callback
mechanism. Each channel maintains a queue of callbacks, which will
be drained in order (RFC4253 guarantees confirm messages are not
reordered within an channel).

Also includes a abandonment callback to clean up if a channel is
closed without sending confirmation messages. This probably
shouldn't happen in compliant implementations, but it could be
abused to leak memory.

ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.89 2007/06/11 09:14:00 markus Exp $ */
d78 7
d134 5
a138 1
	int     datagram;	/* keep boundaries */
d238 2
a239 2
int	 channel_connect_to(const char *, u_short);
int	 channel_connect_by_listen_address(u_short);
d254 1
a254 1
	    const char *);
@


1.89
log
@increase default channel windows; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.88 2006/08/03 03:34:42 deraadt Exp $ */
d67 11
d117 2
a118 2
	channel_callback_fn	*confirm;
	void			*confirm_ctx;
d121 1
d184 5
a188 2
void	 channel_register_confirm(int, channel_callback_fn *, void *);
void	 channel_register_filter(int, channel_infilter_fn *, channel_outfilter_fn *);
d205 1
@


1.88
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.87 2006/07/21 12:43:36 dtucker Exp $ */
d124 1
a124 1
#define CHAN_SES_WINDOW_DEFAULT	(4*CHAN_SES_PACKET_DEFAULT)
d126 1
a126 1
#define CHAN_TCP_WINDOW_DEFAULT	(4*CHAN_TCP_PACKET_DEFAULT)
@


1.87
log
@Make PermitOpen take a list of permitted ports and act more like most other
keywords (ie the first match is the effective setting).  This also makes it
easier to override a previously set PermitOpen.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.86 2006/07/17 12:06:00 dtucker Exp $ */
a39 2

#include "buffer.h"
@


1.86
log
@Add PermitOpen directive to sshd_config which is equivalent to the
"permitopen" key option.  Allows server admin to allow TCP port forwarding
only two specific host/port pairs.  Useful when combined with Match.

If permitopen is used in both sshd_config and a key option, both must allow
a given connection before it will be permitted.

Note that users can still use external forwarders such as netcat, so to be
those must be controlled too for the limits to be effective.

Feedback & ok djm@@, man page corrections & ok jmc@@.
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.85 2006/07/11 18:50:47 markus Exp $ */
d209 1
a209 1
void	 channel_add_adm_permitted_opens(char *, int);
@


1.85
log
@add ExitOnForwardFailure: terminate the connection if ssh(1)
cannot set up all requested dynamic, local, and remote port
forwardings. ok djm, dtucker, stevesk, jmc
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.84 2006/03/25 22:22:42 djm Exp $ */
d209 1
d211 1
@


1.84
log
@standardise spacing in $OpenBSD$ tags; requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.83 2005/12/30 15:56:37 reyk Exp $ */
d210 1
a210 1
void     channel_input_port_forward_request(int, int);
d213 1
a213 1
void	 channel_request_remote_forwarding(const char *, u_short,
@


1.83
log
@add channel output filter interface.

ok djm@@, suggested by markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.82 2005/12/12 13:46:18 markus Exp $	*/
@


1.83.2.1
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.88 2006/08/03 03:34:42 deraadt Exp $ */
d41 2
a208 1
int	 channel_add_adm_permitted_opens(char *, int);
d210 1
a210 2
void	 channel_clear_adm_permitted_opens(void);
int      channel_input_port_forward_request(int, int);
d213 1
a213 1
int	 channel_request_remote_forwarding(const char *, u_short,
@


1.82
log
@make sure protocol messages for internal channels are ignored.
allow adjust messages for non-open channels; with and ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.81 2005/12/06 22:38:27 reyk Exp $	*/
d66 2
a67 1
typedef int channel_filter_fn(struct Channel *, char *, int);
d114 2
a115 1
	channel_filter_fn	*input_filter;
d149 2
d175 1
a175 1
void	 channel_register_filter(int, channel_filter_fn *);
@


1.81
log
@Add support for tun(4) forwarding over OpenSSH, based on an idea and
initial channel code bits by markus@@. This is a simple and easy way to
use OpenSSH for ad hoc virtual private network connections, e.g.
administrative tunnels or secure wireless access. It's based on a new
ssh channel and works similar to the existing TCP forwarding support,
except that it depends on the tun(4) network interface on both ends of
the connection for layer 2 or layer 3 tunneling. This diff also adds
support for LocalCommand in the ssh(1) client.

ok djm@@, markus@@, jmc@@ (manpages), tested and discussed with others
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.80 2005/10/10 10:23:08 djm Exp $	*/
d159 1
@


1.80
log
@fix regression I introduced in 4.2: X11 forwardings initiated after
a session has exited (e.g. "(sleep 5; xterm) &") would not start.
bz #1086 reported by t8m AT centrum.cz; ok markus@@ dtucker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.79 2005/07/17 06:49:04 djm Exp $	*/
d114 2
@


1.79
log
@Fix a number of X11 forwarding channel leaks:
1. Refuse multiple X11 forwarding requests on the same session
2. Clean up all listeners after a single_connection X11 forward, not just
   the one that made the single connection
3. Destroy X11 listeners when the session owning them goes away
testing and ok dtucker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.78 2005/07/08 09:41:33 markus Exp $	*/
d108 1
d110 1
a110 1
	void			*confirm_ctx;
d166 1
a166 1
void	 channel_register_cleanup(int, channel_callback_fn *);
@


1.79.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.83 2005/12/30 15:56:37 reyk Exp $	*/
d66 1
a66 2
typedef int channel_infilter_fn(struct Channel *, char *, int);
typedef u_char *channel_outfilter_fn(struct Channel *, u_char **, u_int *);
d108 1
a109 2
	channel_callback_fn	*detach_user;
	int			detach_close;
d112 1
a112 4
	channel_infilter_fn	*input_filter;
	channel_outfilter_fn	*output_filter;

	int     datagram;	/* keep boundaries */
a143 2
#define CHAN_RBUF	16*1024

a155 1
Channel	*channel_by_id(int);
d165 1
a165 1
void	 channel_register_cleanup(int, channel_callback_fn *, int);
d167 1
a167 1
void	 channel_register_filter(int, channel_infilter_fn *, channel_outfilter_fn *);
@


1.79.2.2
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.88 2006/08/03 03:34:42 deraadt Exp $ */
d41 2
a208 1
int	 channel_add_adm_permitted_opens(char *, int);
d210 1
a210 2
void	 channel_clear_adm_permitted_opens(void);
int      channel_input_port_forward_request(int, int);
d213 1
a213 1
int	 channel_request_remote_forwarding(const char *, u_short,
@


1.78
log
@race when efd gets closed while there is still buffered data:
change CHANNEL_EFD_OUTPUT_ACTIVE()
	1) c->efd must always be valid AND
	2a) no EOF has been seen OR
	2b) there is buffered data
report, initial fix and testing Chuck Cranor
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.77 2005/06/16 03:38:36 djm Exp $	*/
d216 1
a216 1
int	 x11_create_display_inet(int, int, int, u_int *);
@


1.77
log
@move x11_get_proto from ssh.c to clientloop.c, to make muliplexed xfwd easier
later; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.76 2005/03/01 10:09:52 djm Exp $	*/
d151 1
a151 1
	((c->efd != -1 && !(c->flags & (CHAN_EOF_RCVD|CHAN_CLOSE_RCVD))) || \
@


1.76
log
@bz#413: allow optional specification of bind address for port forwardings.
Patch originally by Dan Astorian, but worked on by several people
Adds GatewayPorts=clientspecified option on server to allow remote forwards
to bind to client-specified ports.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.75 2004/10/29 21:47:15 djm Exp $	*/
d218 2
a219 1
void	 x11_request_forwarding_with_spoofing(int, const char *, const char *);
@


1.76.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.79 2005/07/17 06:49:04 djm Exp $	*/
d151 1
a151 1
	c->efd != -1 && (!(c->flags & (CHAN_EOF_RCVD|CHAN_CLOSE_RCVD)) || \
d216 1
a216 1
int	 x11_create_display_inet(int, int, int, u_int *, int **);
d218 1
a218 2
void	 x11_request_forwarding_with_spoofing(int, const char *, const char *,
	    const char *);
@


1.76.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.83 2005/12/30 15:56:37 reyk Exp $	*/
d66 1
a66 2
typedef int channel_infilter_fn(struct Channel *, char *, int);
typedef u_char *channel_outfilter_fn(struct Channel *, u_char **, u_int *);
d108 1
a109 2
	channel_callback_fn	*detach_user;
	int			detach_close;
d112 1
a112 4
	channel_infilter_fn	*input_filter;
	channel_outfilter_fn	*output_filter;

	int     datagram;	/* keep boundaries */
a143 2
#define CHAN_RBUF	16*1024

a155 1
Channel	*channel_by_id(int);
d165 1
a165 1
void	 channel_register_cleanup(int, channel_callback_fn *, int);
d167 1
a167 1
void	 channel_register_filter(int, channel_infilter_fn *, channel_outfilter_fn *);
@


1.75
log
@fix some window size change bugs for multiplexed connections: windows sizes
were not being updated if they had changed after ~^Z suspends and SIGWINCH
was not being processed unless the first connection had requested a tty;
ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.74 2004/08/11 21:43:04 avsm Exp $	*/
d205 5
a209 3
void	 channel_request_remote_forwarding(u_short, const char *, u_short);
void	 channel_request_rforward_cancel(u_short port);
int	 channel_setup_local_fwd_listener(u_short, const char *, u_short, int);
@


1.74
log
@some signed/unsigned int comparison cleanups; markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.73 2004/06/13 15:03:02 djm Exp $	*/
d81 1
@


1.74.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.76 2005/03/01 10:09:52 djm Exp $	*/
a80 1
	int	client_tty;	/* (client) TTY has been requested */
d204 3
a206 5
void	 channel_request_remote_forwarding(const char *, u_short,
	     const char *, u_short);
int	 channel_setup_local_fwd_listener(const char *, u_short,
	     const char *, u_short, int);
void	 channel_request_rforward_cancel(const char *host, u_short port);
@


1.74.2.2
log
@upgrade to OpenSSH 4.2
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.79 2005/07/17 06:49:04 djm Exp $	*/
d151 1
a151 1
	c->efd != -1 && (!(c->flags & (CHAN_EOF_RCVD|CHAN_CLOSE_RCVD)) || \
d216 1
a216 1
int	 x11_create_display_inet(int, int, int, u_int *, int **);
d218 1
a218 2
void	 x11_request_forwarding_with_spoofing(int, const char *, const char *,
	    const char *);
@


1.73
log
@implement session multiplexing in the client (the server has supported this
since 2.0); ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.72 2004/05/21 11:33:11 djm Exp $	*/
d186 1
a186 1
void	 channel_prepare_select(fd_set **, fd_set **, int *, int*, int);
@


1.72
log
@bz #756: add support for the cancel-tcpip-forward request for the server and
the client (through the ~C commandline). reported by z3p AT twistedmatrix.com;
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.71 2003/09/23 20:41:11 markus Exp $	*/
d79 1
d108 1
d165 1
a165 1
void	 channel_register_confirm(int, channel_callback_fn *);
d169 1
@


1.71
log
@move client only agent code to clientloop.c
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.70 2002/06/24 14:33:27 markus Exp $	*/
d202 1
d205 1
@


1.71.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.74 2004/08/11 21:43:04 avsm Exp $	*/
a78 1
	int     ctl_fd;		/* control fd (client sharing) */
a106 1
	void			*confirm_ctx;
d163 1
a163 1
void	 channel_register_confirm(int, channel_callback_fn *, void *);
a166 1
void	 channel_send_window_changes(void);
d183 1
a183 1
void	 channel_prepare_select(fd_set **, fd_set **, int *, u_int*, int);
a201 1
void	 channel_request_rforward_cancel(u_short port);
a203 1
int	 channel_cancel_rport_listener(const char *, u_short);
@


1.71.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.76 2005/03/01 10:09:52 djm Exp $	*/
a80 1
	int	client_tty;	/* (client) TTY has been requested */
d204 3
a206 5
void	 channel_request_remote_forwarding(const char *, u_short,
	     const char *, u_short);
int	 channel_setup_local_fwd_listener(const char *, u_short,
	     const char *, u_short, int);
void	 channel_request_rforward_cancel(const char *host, u_short port);
@


1.70
log
@move channel counter to u_int
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.69 2002/06/23 21:06:41 deraadt Exp $	*/
a215 1
void	 auth_input_open_request(int, u_int32_t, void *);
@


1.70.4.1
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.71 2003/09/23 20:41:11 markus Exp $	*/
d216 1
@


1.70.6.1
log
@upgrade to OpenSSH 3.8
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.71 2003/09/23 20:41:11 markus Exp $	*/
d216 1
@


1.70.6.2
log
@upgrade to OpenSSH 3.9
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.74 2004/08/11 21:43:04 avsm Exp $	*/
a78 1
	int     ctl_fd;		/* control fd (client sharing) */
a106 1
	void			*confirm_ctx;
d163 1
a163 1
void	 channel_register_confirm(int, channel_callback_fn *, void *);
a166 1
void	 channel_send_window_changes(void);
d183 1
a183 1
void	 channel_prepare_select(fd_set **, fd_set **, int *, u_int*, int);
a201 1
void	 channel_request_rforward_cancel(u_short port);
a203 1
int	 channel_cancel_rport_listener(const char *, u_short);
@


1.69
log
@display, screen, row, col, xpixel, ypixel are u_int; markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.68 2002/06/10 22:28:41 markus Exp $	*/
d93 6
a98 6
	int	remote_window;
	int	remote_maxpacket;
	int	local_window;
	int	local_window_max;
	int	local_consumed;
	int	local_maxpacket;
d154 1
a154 1
Channel *channel_new(char *, int, int, int, int, int, int, int, char *, int);
@


1.68
log
@move creation of agent socket to session.c; no need for uidswapping
in channel.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.67 2002/03/26 22:50:39 markus Exp $	*/
d208 1
a208 1
int	 x11_create_display_inet(int, int, int);
@


1.67
log
@CHANNEL_EFD_OUTPUT_ACTIVE is false for CHAN_CLOSE_RCVD, too
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.66 2002/03/25 21:13:51 markus Exp $	*/
a215 3
char	*auth_get_socket_name(void);
void	 auth_sock_cleanup_proc(void *);
int	 auth_input_request_forwarding(struct passwd *);
@


1.67.2.1
log
@Pull in OpenSSH-3.4
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.70 2002/06/24 14:33:27 markus Exp $	*/
d93 6
a98 6
	u_int	remote_window;
	u_int	remote_maxpacket;
	u_int	local_window;
	u_int	local_window_max;
	u_int	local_consumed;
	u_int	local_maxpacket;
d154 1
a154 1
Channel *channel_new(char *, int, int, int, int, u_int, u_int, int, char *, int);
d208 1
a208 1
int	 x11_create_display_inet(int, int, int, u_int *);
d216 3
@


1.66
log
@don't send stderr data after EOF, accept this from older known (broken)
sshd servers only, fixes http://bugzilla.mindrot.org/show_bug.cgi?id=179
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.65 2002/03/04 17:27:39 stevesk Exp $	*/
d148 1
a148 1
	((c->efd != -1 && !(c->flags & CHAN_EOF_RCVD)) || \
@


1.65
log
@$OpenBSD$ and RCSID() cleanup: don't use RCSID() in .h files; add
missing RCSID() to .c files and remove dup /*$OpenBSD$*/ from .c
files.  ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.64 2002/02/14 23:28:00 markus Exp $	*/
d138 12
@


1.64
log
@increase the SSH v2 window size to 4 packets. comsumes a little
bit more memory for slow receivers but increases througput.
@
text
@d1 2
a36 1
/* RCSID("$OpenBSD: channels.h,v 1.63 2002/02/05 14:32:55 markus Exp $"); */
@


1.63
log
@merge channel_request() into channel_request_start()
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.62 2002/02/03 17:58:21 markus Exp $"); */
d116 6
a121 6
#define CHAN_SES_WINDOW_DEFAULT	(32*1024)
#define CHAN_SES_PACKET_DEFAULT	(CHAN_SES_WINDOW_DEFAULT/2)
#define CHAN_TCP_WINDOW_DEFAULT	(32*1024)
#define CHAN_TCP_PACKET_DEFAULT	(CHAN_TCP_WINDOW_DEFAULT/2)
#define CHAN_X11_WINDOW_DEFAULT	(4*1024)
#define CHAN_X11_PACKET_DEFAULT	(CHAN_X11_WINDOW_DEFAULT/2)
d142 1
a142 1
void	 channel_set_fds(int, int, int, int, int, int);
@


1.62
log
@generic callbacks are not really used, remove and
add a callback for msg of type SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
ok djm@@
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.61 2002/02/03 17:55:55 markus Exp $"); */
a147 1
void	 channel_request(int, char *, int);
@


1.61
log
@remove unused channel_input_channel_request
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.60 2002/01/16 13:17:51 markus Exp $"); */
d104 1
a104 3
	channel_callback_fn	*cb_fn;
	void	*cb_arg;
	int	cb_event;
a149 1
void	 channel_register_callback(int, int mtype, channel_callback_fn *, void *);
d151 1
@


1.60
log
@wrapper for channel_setup_fwd_listener
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.59 2002/01/14 13:57:03 markus Exp $"); */
a159 1
void	 channel_input_channel_request(int, u_int32_t, void *);
@


1.59
log
@(c) 2002
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.58 2002/01/14 13:55:55 markus Exp $"); */
d193 2
a194 4
int	 channel_request_local_forwarding(u_short, const char *, u_short, int);
int
channel_request_forwarding(const char *, u_short, const char *, u_short, int,
    int);
@


1.58
log
@remove function pointers for events, remove chan_init*; ok provos@@
@
text
@d13 1
a13 1
 * Copyright (c) 1999, 2000, 2001 Markus Friedl.  All rights reserved.
d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.57 2002/01/13 21:31:20 markus Exp $"); */
@


1.57
log
@add chan_set_[io]state(), order states, state is now an u_int,
simplifies debugging messages; ok provos@@
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.56 2001/12/28 15:06:00 markus Exp $"); */
a217 2
void 	 chan_init_iostates(Channel *);
void	 chan_init(void);
d219 1
a219 1
typedef void    chan_event_fn(Channel *);
d221 7
a227 9
/* for the input state */
extern chan_event_fn	*chan_rcvd_oclose;
extern chan_event_fn	*chan_read_failed;
extern chan_event_fn	*chan_ibuf_empty;

/* for the output state */
extern chan_event_fn	*chan_rcvd_ieof;
extern chan_event_fn	*chan_write_failed;
extern chan_event_fn	*chan_obuf_empty;
@


1.56
log
@remove plen from the dispatch fn. it's no longer used.
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.55 2001/12/20 22:50:24 djm Exp $"); */
d71 2
a72 2
	int     istate;		/* input from channel (state of receive half) */
	int     ostate;		/* output to channel  (state of transmit half) */
d126 4
a129 4
#define CHAN_INPUT_OPEN			0x01
#define CHAN_INPUT_WAIT_DRAIN		0x02
#define CHAN_INPUT_WAIT_OCLOSE		0x04
#define CHAN_INPUT_CLOSED		0x08
d132 4
a135 4
#define CHAN_OUTPUT_OPEN		0x10
#define CHAN_OUTPUT_WAIT_DRAIN		0x20
#define CHAN_OUTPUT_WAIT_IEOF		0x40
#define CHAN_OUTPUT_CLOSED		0x80
@


1.55
log
@Conformance fix: we should send failing packet sequence number when
responding with a SSH_MSG_UNIMPLEMENTED message. Spotted by
yakk@@yakk.dot.net; ok markus@@
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.54 2001/12/20 16:37:29 markus Exp $"); */
d160 11
a170 11
void	 channel_input_channel_request(int, int, u_int32_t, void *);
void	 channel_input_close(int, int, u_int32_t, void *);
void	 channel_input_close_confirmation(int, int, u_int32_t, void *);
void	 channel_input_data(int, int, u_int32_t, void *);
void	 channel_input_extended_data(int, int, u_int32_t, void *);
void	 channel_input_ieof(int, int, u_int32_t, void *);
void	 channel_input_oclose(int, int, u_int32_t, void *);
void	 channel_input_open_confirmation(int, int, u_int32_t, void *);
void	 channel_input_open_failure(int, int, u_int32_t, void *);
void	 channel_input_port_open(int, int, u_int32_t, void *);
void	 channel_input_window_adjust(int, int, u_int32_t, void *);
d202 1
a202 1
void     x11_input_open(int, int, u_int32_t, void *);
d204 1
a204 1
void	 deny_input_open(int, int, u_int32_t, void *);
d212 1
a212 1
void	 auth_input_open_request(int, int, u_int32_t, void *);
@


1.54
log
@setup x11 listen socket for just one connect if the client requests so.
(v2 only, but the openssh client does not support this feature).
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.53 2001/11/29 21:10:51 stevesk Exp $"); */
d160 11
a170 11
void	 channel_input_channel_request(int, int, void *);
void	 channel_input_close(int, int, void *);
void	 channel_input_close_confirmation(int, int, void *);
void	 channel_input_data(int, int, void *);
void	 channel_input_extended_data(int, int, void *);
void	 channel_input_ieof(int, int, void *);
void	 channel_input_oclose(int, int, void *);
void	 channel_input_open_confirmation(int, int, void *);
void	 channel_input_open_failure(int, int, void *);
void	 channel_input_port_open(int, int, void *);
void	 channel_input_window_adjust(int, int, void *);
d202 1
a202 1
void     x11_input_open(int, int, void *);
d204 1
a204 1
void	 deny_input_open(int, int, void *);
d212 1
a212 1
void	 auth_input_open_request(int, int, void *);
@


1.53
log
@sshd X11 fake server will now listen on localhost by default:
$ echo $DISPLAY
localhost:12.0
$ netstat -an|grep 6012
tcp        0      0  127.0.0.1.6012         *.*                    LISTEN
tcp6       0      0  ::1.6012               *.*                    LISTEN
sshd_config gatewayports=yes can be used to revert back to the old
behavior.  will control this with another option later.  ok markus@@
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.52 2001/11/29 19:06:39 stevesk Exp $"); */
d99 1
d201 1
a201 1
int	 x11_create_display_inet(int, int);
a202 1
void     x11_request_forwarding(void);
@


1.52
log
@remove dead function prototype; ok markus@@
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.51 2001/11/07 22:53:21 markus Exp $"); */
d200 1
a200 1
char	*x11_create_display_inet(int, int);
@


1.51
log
@crank c->path to 256 so they can hold a full hostname; dwd@@bell-labs.com
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.50 2001/10/10 22:18:47 markus Exp $"); */
a199 1
char	*x11_create_display(int);
@


1.50
log
@try to keep channels open until an exit-status message is sent.
don't kill the login shells if the shells stdin/out/err is closed.
this should now work:
ssh -2n localhost 'exec > /dev/null 2>&1; sleep 10; exit 5'; echo ?
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.49 2001/10/09 21:59:41 markus Exp $"); */
d59 1
a59 1
#define SSH_CHANNEL_PATH_LEN		30
@


1.50.2.1
log
@Pull in patches from current (Errata 002):
Update to OpenSSH-3.0.1 via errata patch (Instead of using release tarball)
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.51 2001/11/07 22:53:21 markus Exp $"); */
d59 1
a59 1
#define SSH_CHANNEL_PATH_LEN		256
@


1.50.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@a0 2
/*	$OpenBSD: channels.h,v 1.65 2002/03/04 17:27:39 stevesk Exp $	*/

d13 1
a13 1
 * Copyright (c) 1999, 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d35 1
d71 2
a72 2
	u_int   istate;		/* input from channel (state of receive half) */
	u_int   ostate;		/* output to channel  (state of transmit half) */
a98 1
	int	single_connection;
d103 3
a105 1
	channel_callback_fn	*confirm;
d117 6
a122 6
#define CHAN_SES_PACKET_DEFAULT	(32*1024)
#define CHAN_SES_WINDOW_DEFAULT	(4*CHAN_SES_PACKET_DEFAULT)
#define CHAN_TCP_PACKET_DEFAULT	(32*1024)
#define CHAN_TCP_WINDOW_DEFAULT	(4*CHAN_TCP_PACKET_DEFAULT)
#define CHAN_X11_PACKET_DEFAULT	(16*1024)
#define CHAN_X11_WINDOW_DEFAULT	(4*CHAN_X11_PACKET_DEFAULT)
d125 4
a128 4
#define CHAN_INPUT_OPEN			0
#define CHAN_INPUT_WAIT_DRAIN		1
#define CHAN_INPUT_WAIT_OCLOSE		2
#define CHAN_INPUT_CLOSED		3
d131 4
a134 4
#define CHAN_OUTPUT_OPEN		0
#define CHAN_OUTPUT_WAIT_DRAIN		1
#define CHAN_OUTPUT_WAIT_IEOF		2
#define CHAN_OUTPUT_CLOSED		3
d143 1
a143 1
void	 channel_set_fds(int, int, int, int, int, int, u_int);
d149 1
d151 1
a152 1
void	 channel_register_confirm(int, channel_callback_fn *);
d159 11
a169 10
void	 channel_input_close(int, u_int32_t, void *);
void	 channel_input_close_confirmation(int, u_int32_t, void *);
void	 channel_input_data(int, u_int32_t, void *);
void	 channel_input_extended_data(int, u_int32_t, void *);
void	 channel_input_ieof(int, u_int32_t, void *);
void	 channel_input_oclose(int, u_int32_t, void *);
void	 channel_input_open_confirmation(int, u_int32_t, void *);
void	 channel_input_open_failure(int, u_int32_t, void *);
void	 channel_input_port_open(int, u_int32_t, void *);
void	 channel_input_window_adjust(int, u_int32_t, void *);
d192 4
a195 2
int	 channel_setup_local_fwd_listener(u_short, const char *, u_short, int);
int	 channel_setup_remote_fwd_listener(const char *, u_short, int);
d200 4
a203 2
int	 x11_create_display_inet(int, int, int);
void     x11_input_open(int, u_int32_t, void *);
d205 1
a205 1
void	 deny_input_open(int, u_int32_t, void *);
d213 1
a213 1
void	 auth_input_open_request(int, u_int32_t, void *);
d219 2
d222 1
a222 1
/* channel events */
d224 9
a232 7
void	 chan_rcvd_oclose(Channel *);
void	 chan_read_failed(Channel *);
void	 chan_ibuf_empty(Channel *);

void	 chan_rcvd_ieof(Channel *);
void	 chan_write_failed(Channel *);
void	 chan_obuf_empty(Channel *);
@


1.50.2.3
log
@Update OpenSSH to version 3.2.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.67 2002/03/26 22:50:39 markus Exp $	*/
a137 12
#define CHAN_EOF_SENT			0x04
#define CHAN_EOF_RCVD			0x08

/* check whether 'efd' is still in use */
#define CHANNEL_EFD_INPUT_ACTIVE(c) \
	(compat20 && c->extended_usage == CHAN_EXTENDED_READ && \
	(c->efd != -1 || \
	buffer_len(&c->extended) > 0))
#define CHANNEL_EFD_OUTPUT_ACTIVE(c) \
	(compat20 && c->extended_usage == CHAN_EXTENDED_WRITE && \
	((c->efd != -1 && !(c->flags & (CHAN_EOF_RCVD|CHAN_CLOSE_RCVD))) || \
	buffer_len(&c->extended) > 0))
@


1.50.2.4
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.50.2.3 2002/05/17 00:03:23 miod Exp $	*/
d216 3
@


1.50.2.5
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.50.2.4 2002/06/22 07:23:17 miod Exp $	*/
d93 6
a98 6
	u_int	remote_window;
	u_int	remote_maxpacket;
	u_int	local_window;
	u_int	local_window_max;
	u_int	local_consumed;
	u_int	local_maxpacket;
d154 1
a154 1
Channel *channel_new(char *, int, int, int, int, u_int, u_int, int, char *, int);
d208 1
a208 1
int	 x11_create_display_inet(int, int, int, u_int *);
@


1.49
log
@simplify session close: no more delayed session_close, no more blocking wait() calls.
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.48 2001/10/07 17:49:40 markus Exp $"); */
d217 1
a217 1
int	 chan_is_dead(Channel *);
@


1.48
log
@avoid possible FD_ISSET overflow for channels established
during channnel_after_select() (used for dynamic channels).
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.47 2001/10/01 21:38:53 markus Exp $"); */
a145 1
void	 channel_detach_all(void);
a178 1
void     channel_free_all(void);
@


1.47
log
@remove ugliness; vp@@drexel.edu via angelos
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.46 2001/09/17 20:52:47 markus Exp $"); */
a70 1
	/* peer can be reached over encrypted connection, via packet-sent */
d79 2
a80 1
	int     force_drain;		/* force close on iEOF */
@


1.46
log
@try to fix agent-forwarding-backconnection-bug, as seen on HPUX, for example;
with Lutz.Jaenicke@@aet.TU-Cottbus.DE,
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.45 2001/07/17 21:04:57 markus Exp $"); */
d185 2
a186 1
/* channel_tcpfwd.c */
@


1.45
log
@keep track of both maxfd and the size of the malloc'ed fdsets.
update maxfd if maxfd gets closed.
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.44 2001/07/02 22:52:57 markus Exp $"); */
d80 1
@


1.44
log
@improve cleanup/exit logic in ssh2:
stop listening to channels, detach channel users (e.g. sessions).
wait for children (i.e. dying sessions), send exit messages,
cleanup all channels.
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.43 2001/06/30 18:08:40 stevesk Exp $"); */
d155 1
d173 1
a173 1
void	 channel_prepare_select(fd_set **, fd_set **, int *, int);
@


1.43
log
@adress -> address; ok markus@@
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.42 2001/06/26 17:27:23 markus Exp $"); */
d105 1
a105 1
	channel_callback_fn	*dettach_user;
d143 4
a146 2
void     channel_free(Channel *);
void     channel_free_all(void);
@


1.42
log
@remove comments from .h, since they are cut&paste from the .c files
and out of sync
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.41 2001/06/26 06:32:49 itojun Exp $"); */
d187 1
a187 1
int	 channel_connect_by_listen_adress(u_short);
@


1.41
log
@prototype pedant.  not very creative...
- () -> (void)
- no variable names
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.40 2001/06/25 08:25:36 markus Exp $"); */
a60 4
/*
 * Data structure for channel data.  This is initialized in channel_new
 * and cleared in channel_free.
 */
a137 1

d142 11
a152 11
void	channel_set_fds(int, int, int, int, int, int);
void    channel_free(Channel *);
void    channel_free_all(void);

void	channel_send_open(int);
void	channel_request(int, char *, int);
void	channel_request_start(int, char *, int);
void	channel_register_callback(int, int mtype, channel_callback_fn *, void *);
void	channel_register_cleanup(int, channel_callback_fn *);
void	channel_register_filter(int, channel_filter_fn *);
void	channel_cancel_cleanup(int);
d156 11
a166 11
void	channel_input_channel_request(int, int, void *);
void	channel_input_close(int, int, void *);
void	channel_input_close_confirmation(int, int, void *);
void	channel_input_data(int, int, void *);
void	channel_input_extended_data(int, int, void *);
void	channel_input_ieof(int, int, void *);
void	channel_input_oclose(int, int, void *);
void	channel_input_open_confirmation(int, int, void *);
void	channel_input_open_failure(int, int, void *);
void	channel_input_port_open(int, int, void *);
void	channel_input_window_adjust(int, int, void *);
d170 10
a179 11
void
channel_prepare_select(fd_set **, fd_set **, int *, int);
void    channel_after_select(fd_set *, fd_set *);
void    channel_output_poll(void);

int     channel_not_very_much_buffered_data(void);
void    channel_close_all(void);
void    channel_free_all(void);
int     channel_still_open(void);
char   *channel_open_message(void);
int	channel_find_open(void);
d182 8
a189 2
int
channel_request_local_forwarding(u_short, const char *, u_short, int);
a192 8
void
channel_request_remote_forwarding(u_short, const char *, u_short);
void    channel_permit_all_opens(void);
void	channel_add_permitted_opens(char *, int);
void	channel_clear_permitted_opens(void);
void    channel_input_port_forward_request(int, int);
int	channel_connect_to(const char *, u_short);
int	channel_connect_by_listen_adress(u_short);
d196 7
a202 8
int	x11_connect_display(void);
char   *x11_create_display(int);
char   *x11_create_display_inet(int, int);
void    x11_input_open(int, int, void *);
void    x11_request_forwarding(void);
void
x11_request_forwarding_with_spoofing(int, const char *, const char *);
void	deny_input_open(int, int, void *);
d206 5
a210 5
void    auth_request_forwarding(void);
char   *auth_get_socket_name(void);
void	auth_sock_cleanup_proc(void *);
int     auth_input_request_forwarding(struct passwd *);
void    auth_input_open_request(int, int, void *);
d214 5
a229 5

int	chan_is_dead(Channel *);
void	chan_mark_dead(Channel *);
void    chan_init_iostates(Channel *);
void	chan_init(void);
@


1.40
log
@update copyright for 2001
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.39 2001/06/20 13:56:39 markus Exp $"); */
d68 2
a69 2
typedef void channel_callback_fn(int id, void *arg);
typedef int channel_filter_fn(struct Channel *c, char *buf, int len);
d145 4
a148 8
Channel	*channel_lookup(int id);
Channel *
channel_new(char *ctype, int type, int rfd, int wfd, int efd,
    int window, int maxpack, int extusage, char *remote_name, int nonblock);
void
channel_set_fds(int id, int rfd, int wfd, int efd,
    int extusage, int nonblock);
void    channel_free(Channel *c);
d151 7
a157 7
void	channel_send_open(int id);
void	channel_request(int id, char *service, int wantconfirm);
void	channel_request_start(int id, char *service, int wantconfirm);
void	channel_register_callback(int id, int mtype, channel_callback_fn *fn, void *arg);
void	channel_register_cleanup(int id, channel_callback_fn *fn);
void	channel_register_filter(int id, channel_filter_fn *fn);
void	channel_cancel_cleanup(int id);
d161 11
a171 11
void	channel_input_channel_request(int type, int plen, void *ctxt);
void	channel_input_close(int type, int plen, void *ctxt);
void	channel_input_close_confirmation(int type, int plen, void *ctxt);
void	channel_input_data(int type, int plen, void *ctxt);
void	channel_input_extended_data(int type, int plen, void *ctxt);
void	channel_input_ieof(int type, int plen, void *ctxt);
void	channel_input_oclose(int type, int plen, void *ctxt);
void	channel_input_open_confirmation(int type, int plen, void *ctxt);
void	channel_input_open_failure(int type, int plen, void *ctxt);
void	channel_input_port_open(int type, int plen, void *ctxt);
void	channel_input_window_adjust(int type, int plen, void *ctxt);
d176 2
a177 3
channel_prepare_select(fd_set **readsetp, fd_set **writesetp, int *maxfdp,
    int rekeying);
void    channel_after_select(fd_set * readset, fd_set * writeset);
d189 1
a189 2
channel_request_local_forwarding(u_short listen_port,
    const char *host_to_connect, u_short port_to_connect, int gateway_ports);
d191 2
a192 3
channel_request_forwarding(const char *listen_address, u_short listen_port,
    const char *host_to_connect, u_short port_to_connect, int gateway_ports,
    int remote_fwd);
d194 1
a194 2
channel_request_remote_forwarding(u_short port, const char *host,
    u_short remote_port);
d196 1
a196 1
void	channel_add_permitted_opens(char *host, int port);
d198 3
a200 3
void    channel_input_port_forward_request(int is_root, int gateway_ports);
int	channel_connect_to(const char *host, u_short host_port);
int	channel_connect_by_listen_adress(u_short listen_port);
d205 3
a207 3
char   *x11_create_display(int screen);
char   *x11_create_display_inet(int screen, int x11_display_offset);
void    x11_input_open(int type, int plen, void *ctxt);
d210 2
a211 3
x11_request_forwarding_with_spoofing(int client_session_id,
    const char *proto, const char *data);
void	deny_input_open(int type, int plen, void *ctxt);
d217 3
a219 3
void	auth_sock_cleanup_proc(void *pw);
int     auth_input_request_forwarding(struct passwd * pw);
void    auth_input_open_request(int type, int plen, void *ctxt);
d223 1
a223 1
typedef void    chan_event_fn(Channel * c);
d235 3
a237 3
int	chan_is_dead(Channel * c);
void	chan_mark_dead(Channel * c);
void    chan_init_iostates(Channel * c);
@


1.39
log
@move from channel_stop_listening to channel_free_all,
call channel_free_all before calling waitpid() in serverloop.
fixes the utmp handling; report from Lutz.Jaenicke@@aet.TU-Cottbus.DE
@
text
@d13 1
a13 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.38 2001/06/16 08:50:39 markus Exp $"); */
@


1.38
log
@bad //-style comment; thx to stevev@@darkwing.uoregon.edu
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.37 2001/06/04 21:59:42 markus Exp $"); */
d153 1
a185 1
void    channel_stop_listening(void);
d187 1
@


1.37
log
@switch uid when cleaning up tmp files and sockets; reported by zen-parse@@gmx.net on bugtraq
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.36 2001/06/03 14:55:39 markus Exp $"); */
a211 1
//int	x11_check_cookie(Buffer *b);
@


1.36
log
@use fatal_register_cleanup instead of atexit, sync with x11 authdir handling
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.35 2001/05/31 10:30:15 markus Exp $"); */
d226 1
a226 1
void	auth_sock_cleanup_proc(void *ignored);
@


1.35
log
@undo the .c file split, just merge the header and keep the cvs history
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channel.h,v 1.2 2001/05/30 15:20:10 markus Exp $"); */
d226 1
@


1.34
log
@channel layer cleanup: merge header files and split .c files
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.33 2001/05/28 23:14:49 markus Exp $"); */
d37 2
a38 2
#ifndef CHANNELS_H
#define CHANNELS_H
d127 11
d139 16
a154 1
void	channel_open(int id);
a160 5
Channel	*channel_lookup(int id);

void
channel_set_fds(int id, int rfd, int wfd, int efd,
    int extusage, int nonblock);
d162 1
a162 1
void	deny_input_open(int type, int plen, void *ctxt);
d176 1
a176 15
/* Sets specific protocol options. */
void    channel_set_options(int hostname_in_open);

/*
 * Allocate a new channel object and set its type and socket.  Remote_name
 * must have been allocated with xmalloc; this will free it when the channel
 * is freed.
 */
Channel *
channel_new(char *ctype, int type, int rfd, int wfd, int efd,
    int window, int maxpack, int extended_usage, char *remote_name,
    int nonblock);

/* Free the channel and close its socket. */
void    channel_free(Channel *c);
a177 4
/*
 * Allocate/update select bitmasks and add any bits relevant to channels in
 * select bitmasks.
 */
a180 5

/*
 * After select, perform any appropriate operations for channels which have
 * events pending.
 */
a181 2

/* If there is data to send to the connection, send some of it now. */
a183 1
/* Returns true if no channel has too much buffered data. */
a184 3

/* This closes any sockets that are listening for connections; this removes
   any unix domain sockets. */
a185 5

/*
 * Closes the sockets of all channels.  This is used to close extra file
 * descriptors after a fork.
 */
a186 2

/* Returns true if there is still an open channel over the connection. */
a187 6

/*
 * Returns a string containing a list of all open channels.  The list is
 * suitable for displaying to the user.  It uses crlf instead of newlines.
 * The caller should free the string with xfree.
 */
d189 1
d191 1
a191 4
/*
 * Initiate forwarding of connections to local port "port" through the secure
 * channel to host:port from remote side.
 */
a198 7

/*
 * Initiate forwarding of connections to port "port" on remote host through
 * the secure channel to host:port from local side.  This never returns if
 * there was an error.  This registers that open requests for that port are
 * permitted.
 */
a201 6

/*
 * Permits opening to any host/port if permitted_opens[] is empty.  This is
 * usually called by the server, because the user could connect to any port
 * anyway, and the server has no way to know but to trust the client anyway.
 */
a202 2

/* Add host/port to list of allowed targets for port forwarding */
a203 2

/* Flush list */
d205 3
d209 1
a209 6
/*
 * This is called after receiving CHANNEL_FORWARDING_REQUEST.  This initates
 * listening for the port, and sends back a success reply (or disconnect
 * message if there was an error).  This never returns if there was an error.
 */
void    channel_input_port_forward_request(int is_root, int gateway_ports);
d211 2
a212 4
/*
 * Creates a port for X11 connections, and starts listening for it. Returns
 * the display name, or NULL if an error was encountered.
 */
a213 6

/*
 * Creates an internet domain socket for listening for X11 connections.
 * Returns a suitable value for the DISPLAY variable, or NULL if an error
 * occurs.
 */
a214 6

/*
 * This is called when SSH_SMSG_X11_OPEN is received.  The packet contains
 * the remote channel number.  We should do whatever we want, and respond
 * with either SSH_MSG_OPEN_CONFIRMATION or SSH_MSG_OPEN_FAILURE.
 */
a215 5

/*
 * Requests forwarding of X11 connections.  This should be called on the
 * client only.
 */
a216 5

/*
 * Requests forwarding for X11 connections, with authentication spoofing.
 * This should be called in the client only.
 */
d220 3
a223 1
/* Sends a message to the server to request authentication fd forwarding. */
a224 6

/*
 * Returns the name of the forwarded authentication socket.  Returns NULL if
 * there is no forwarded authentication socket.  The returned value points to
 * a static buffer.
 */
a225 5

/*
 * This is called to process SSH_CMSG_AGENT_REQUEST_FORWARDING on the server.
 * This starts forwarding authentication requests.
 */
d227 1
d229 1
a229 2
/* This is called to process an SSH_SMSG_AGENT_OPEN message. */
void    auth_input_open_request(int type, int plen, void *ctxt);
d231 1
a231 4
/* XXX */
int	channel_connect_to(const char *host, u_short host_port);
int	channel_connect_by_listen_adress(u_short listen_port);
int	x11_connect_display(void);
d233 14
a246 1
int	channel_find_open(void);
@


1.33
log
@undo broken channel fix and try a different one. there
should be still some select errors...
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.32 2001/05/04 23:47:33 markus Exp $"); */
@


1.32
log
@move to Channel **channels (instead of Channel *channels), fixes realloc problems.
channel_new now returns a Channel *, favour Channel * over channel id.
remove old channel_allocate interface.
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.31 2001/04/13 22:46:53 beck Exp $"); */
d56 2
a57 1
#define SSH_CHANNEL_MAX_TYPE		14
@


1.31
log
@Add options ClientAliveInterval and ClientAliveCountMax to sshd.
This gives the ability to do a "keepalive" via the encrypted channel
which can't be spoofed (unlike TCP keepalives). Useful for when you want
to use ssh connections to authenticate people for something, and know
relatively quickly when they are no longer authenticated. Disabled
by default (of course). ok markus@@
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.30 2001/04/07 08:55:17 markus Exp $"); */
a42 1
#define SSH_CHANNEL_FREE		0	/* This channel is free (unused). */
d58 2
d61 1
a61 1
 * Data structure for channel data.  This is iniailized in channel_allocate
d88 2
a89 2
	char    path[200];	/* path for unix domain sockets, or host name
				 * for forwards */
a135 4
int
channel_new(char *ctype, int type, int rfd, int wfd, int efd,
    int window, int maxpack, int extended_usage, char *remote_name,
    int nonblock);
d162 4
a165 1
int     channel_allocate(int type, int sock, char *remote_name);
d168 1
a168 1
void    channel_free(int channel);
@


1.31.2.1
log
@Pull in patch from current:
Fix (markus):
- use fatal_register_cleanup instead of atexit, sync with x11 authdir handling
- switch uid when cleaning up tmp files and sockets; reported by zen-parse@@gmx.net on bugtraq
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.31 2001/04/13 22:46:53 beck Exp $"); */
a294 2

void	auth_sock_cleanup_proc(void *_pw);
@


1.31.2.2
log
@Pull in OpenSSH-2.9.9
@
text
@d13 1
a13 1
 * Copyright (c) 1999, 2000, 2001 Markus Friedl.  All rights reserved.
d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.46 2001/09/17 20:52:47 markus Exp $"); */
d37 2
a38 2
#ifndef CHANNEL_H
#define CHANNEL_H
d43 1
d57 1
a57 4
#define SSH_CHANNEL_ZOMBIE		14	/* Almost dead. */
#define SSH_CHANNEL_MAX_TYPE		15

#define SSH_CHANNEL_PATH_LEN		30
d59 4
d66 2
a67 2
typedef void channel_callback_fn(int, void *);
typedef int channel_filter_fn(struct Channel *, char *, int);
a81 1
	int     force_drain;		/* force close on iEOF */
d87 2
a88 2
	char    path[SSH_CHANNEL_PATH_LEN];
		/* path for unix domain sockets, or host name for forwards */
d107 1
a107 1
	channel_callback_fn	*detach_user;
d125 92
a216 70
/* possible input states */
#define CHAN_INPUT_OPEN			0x01
#define CHAN_INPUT_WAIT_DRAIN		0x02
#define CHAN_INPUT_WAIT_OCLOSE		0x04
#define CHAN_INPUT_CLOSED		0x08

/* possible output states */
#define CHAN_OUTPUT_OPEN		0x10
#define CHAN_OUTPUT_WAIT_DRAIN		0x20
#define CHAN_OUTPUT_WAIT_IEOF		0x40
#define CHAN_OUTPUT_CLOSED		0x80

#define CHAN_CLOSE_SENT			0x01
#define CHAN_CLOSE_RCVD			0x02

/* channel management */

Channel	*channel_lookup(int);
Channel *channel_new(char *, int, int, int, int, int, int, int, char *, int);
void	 channel_set_fds(int, int, int, int, int, int);
void	 channel_free(Channel *);
void	 channel_free_all(void);
void	 channel_detach_all(void);
void	 channel_stop_listening(void);

void	 channel_send_open(int);
void	 channel_request(int, char *, int);
void	 channel_request_start(int, char *, int);
void	 channel_register_callback(int, int mtype, channel_callback_fn *, void *);
void	 channel_register_cleanup(int, channel_callback_fn *);
void	 channel_register_filter(int, channel_filter_fn *);
void	 channel_cancel_cleanup(int);
int	 channel_close_fd(int *);

/* protocol handler */

void	 channel_input_channel_request(int, int, void *);
void	 channel_input_close(int, int, void *);
void	 channel_input_close_confirmation(int, int, void *);
void	 channel_input_data(int, int, void *);
void	 channel_input_extended_data(int, int, void *);
void	 channel_input_ieof(int, int, void *);
void	 channel_input_oclose(int, int, void *);
void	 channel_input_open_confirmation(int, int, void *);
void	 channel_input_open_failure(int, int, void *);
void	 channel_input_port_open(int, int, void *);
void	 channel_input_window_adjust(int, int, void *);

/* file descriptor handling (read/write) */

void	 channel_prepare_select(fd_set **, fd_set **, int *, int*, int);
void     channel_after_select(fd_set *, fd_set *);
void     channel_output_poll(void);

int      channel_not_very_much_buffered_data(void);
void     channel_close_all(void);
void     channel_free_all(void);
int      channel_still_open(void);
char	*channel_open_message(void);
int	 channel_find_open(void);

/* channel_tcpfwd.c */
void     channel_permit_all_opens(void);
void	 channel_add_permitted_opens(char *, int);
void	 channel_clear_permitted_opens(void);
void     channel_input_port_forward_request(int, int);
int	 channel_connect_to(const char *, u_short);
int	 channel_connect_by_listen_address(u_short);
void	 channel_request_remote_forwarding(u_short, const char *, u_short);
int	 channel_request_local_forwarding(u_short, const char *, u_short, int);
d218 88
a305 2
channel_request_forwarding(const char *, u_short, const char *, u_short, int,
    int);
d307 4
a310 1
/* x11 forwarding */
d312 1
a312 34
int	 x11_connect_display(void);
char	*x11_create_display(int);
char	*x11_create_display_inet(int, int);
void     x11_input_open(int, int, void *);
void     x11_request_forwarding(void);
void	 x11_request_forwarding_with_spoofing(int, const char *, const char *);
void	 deny_input_open(int, int, void *);

/* agent forwarding */

void	 auth_request_forwarding(void);
char	*auth_get_socket_name(void);
void	 auth_sock_cleanup_proc(void *);
int	 auth_input_request_forwarding(struct passwd *);
void	 auth_input_open_request(int, int, void *);

/* channel close */

int	 chan_is_dead(Channel *);
void	 chan_mark_dead(Channel *);
void 	 chan_init_iostates(Channel *);
void	 chan_init(void);

typedef void    chan_event_fn(Channel *);

/* for the input state */
extern chan_event_fn	*chan_rcvd_oclose;
extern chan_event_fn	*chan_read_failed;
extern chan_event_fn	*chan_ibuf_empty;

/* for the output state */
extern chan_event_fn	*chan_rcvd_ieof;
extern chan_event_fn	*chan_write_failed;
extern chan_event_fn	*chan_obuf_empty;
@


1.31.2.3
log
@Merge OpenSSH 3.0
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.31.2.2 2001/09/27 19:03:54 jason Exp $"); */
d71 1
d80 1
a80 2
	int     force_drain;	/* force close on iEOF */
	int     delayed;		/* fdset hack */
d146 1
d180 1
d185 1
a185 2
/* tcp forwarding */
void	 channel_set_af(int af);
d218 1
a218 1
int	 chan_is_dead(Channel *, int);
@


1.31.2.4
log
@Merge OpenSSH 3.0.1.
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.31.2.3 2001/11/15 00:15:19 miod Exp $"); */
d59 1
a59 1
#define SSH_CHANNEL_PATH_LEN		256
@


1.31.2.5
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@a0 2
/*	$OpenBSD: channels.h,v 1.65 2002/03/04 17:27:39 stevesk Exp $	*/

d13 1
a13 1
 * Copyright (c) 1999, 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d35 1
d71 2
a72 2
	u_int   istate;		/* input from channel (state of receive half) */
	u_int   ostate;		/* output to channel  (state of transmit half) */
a98 1
	int	single_connection;
d103 3
a105 1
	channel_callback_fn	*confirm;
d117 6
a122 6
#define CHAN_SES_PACKET_DEFAULT	(32*1024)
#define CHAN_SES_WINDOW_DEFAULT	(4*CHAN_SES_PACKET_DEFAULT)
#define CHAN_TCP_PACKET_DEFAULT	(32*1024)
#define CHAN_TCP_WINDOW_DEFAULT	(4*CHAN_TCP_PACKET_DEFAULT)
#define CHAN_X11_PACKET_DEFAULT	(16*1024)
#define CHAN_X11_WINDOW_DEFAULT	(4*CHAN_X11_PACKET_DEFAULT)
d125 4
a128 4
#define CHAN_INPUT_OPEN			0
#define CHAN_INPUT_WAIT_DRAIN		1
#define CHAN_INPUT_WAIT_OCLOSE		2
#define CHAN_INPUT_CLOSED		3
d131 4
a134 4
#define CHAN_OUTPUT_OPEN		0
#define CHAN_OUTPUT_WAIT_DRAIN		1
#define CHAN_OUTPUT_WAIT_IEOF		2
#define CHAN_OUTPUT_CLOSED		3
d143 1
a143 1
void	 channel_set_fds(int, int, int, int, int, int, u_int);
d149 1
d151 1
a152 1
void	 channel_register_confirm(int, channel_callback_fn *);
d159 11
a169 10
void	 channel_input_close(int, u_int32_t, void *);
void	 channel_input_close_confirmation(int, u_int32_t, void *);
void	 channel_input_data(int, u_int32_t, void *);
void	 channel_input_extended_data(int, u_int32_t, void *);
void	 channel_input_ieof(int, u_int32_t, void *);
void	 channel_input_oclose(int, u_int32_t, void *);
void	 channel_input_open_confirmation(int, u_int32_t, void *);
void	 channel_input_open_failure(int, u_int32_t, void *);
void	 channel_input_port_open(int, u_int32_t, void *);
void	 channel_input_window_adjust(int, u_int32_t, void *);
d192 4
a195 2
int	 channel_setup_local_fwd_listener(u_short, const char *, u_short, int);
int	 channel_setup_remote_fwd_listener(const char *, u_short, int);
d200 4
a203 2
int	 x11_create_display_inet(int, int, int);
void     x11_input_open(int, u_int32_t, void *);
d205 1
a205 1
void	 deny_input_open(int, u_int32_t, void *);
d213 1
a213 1
void	 auth_input_open_request(int, u_int32_t, void *);
d219 2
d222 1
a222 1
/* channel events */
d224 9
a232 7
void	 chan_rcvd_oclose(Channel *);
void	 chan_read_failed(Channel *);
void	 chan_ibuf_empty(Channel *);

void	 chan_rcvd_ieof(Channel *);
void	 chan_write_failed(Channel *);
void	 chan_obuf_empty(Channel *);
@


1.31.2.6
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.67 2002/03/26 22:50:39 markus Exp $	*/
a137 12
#define CHAN_EOF_SENT			0x04
#define CHAN_EOF_RCVD			0x08

/* check whether 'efd' is still in use */
#define CHANNEL_EFD_INPUT_ACTIVE(c) \
	(compat20 && c->extended_usage == CHAN_EXTENDED_READ && \
	(c->efd != -1 || \
	buffer_len(&c->extended) > 0))
#define CHANNEL_EFD_OUTPUT_ACTIVE(c) \
	(compat20 && c->extended_usage == CHAN_EXTENDED_WRITE && \
	((c->efd != -1 && !(c->flags & (CHAN_EOF_RCVD|CHAN_CLOSE_RCVD))) || \
	buffer_len(&c->extended) > 0))
@


1.30
log
@allow the ssh client act as a SOCKS4 proxy (dynamic local portforwarding).
work by Dan Kaminsky <dankamin@@cisco.com> and me. thanks to Dan for this
great patch: use 'ssh -D 1080 host' and make netscape use localhost:1080 as
a socks proxy.
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.29 2001/04/04 20:25:36 markus Exp $"); */
d309 2
@


1.29
log
@more robust rekeying
don't send channel data after rekeying is started.
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.28 2001/03/16 19:06:29 markus Exp $"); */
d56 2
a57 1
#define SSH_CHANNEL_MAX_TYPE		13
@


1.28
log
@implement "permitopen" key option, restricts -L style forwarding to
to specified host:port pairs. based on work by harlan@@genua.de
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.27 2001/02/15 23:19:59 markus Exp $"); */
d174 2
a175 1
channel_prepare_select(fd_set **readsetp, fd_set **writesetp, int *maxfdp);
@


1.27
log
@genericize password padding function for SSH1 and SSH2.
add stylized echo to 2, too.
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.26 2001/01/31 20:37:23 markus Exp $"); */
d40 2
d231 3
a233 3
 * Permits opening to any host/port in SSH_MSG_PORT_OPEN.  This is usually
 * called by the server, because the user could connect to any port anyway,
 * and the server has no way to know but to trust the client anyway.
d236 6
@


1.26
log
@do not disconnect if local port forwarding fails, e.g. if port is already in use
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.25 2001/01/29 16:55:36 markus Exp $"); */
d78 1
@


1.25
log
@fix select overflow; ok deraadt@@ and stevesk@@
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.24 2000/12/05 20:34:10 markus Exp $"); */
d209 1
a209 1
void
d212 1
a212 1
void
@


1.24
log
@async connects for -R/-L; ok deraadt@@
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.23 2000/11/06 23:04:56 markus Exp $"); */
d166 6
a171 2
/* Add any bits relevant to channels in select bitmasks. */
void    channel_prepare_select(fd_set * readset, fd_set * writeset);
a193 3

/* Returns the maximum file descriptor number used by the channels. */
int     channel_max_fd(void);
@


1.23
log
@agent forwarding and -R for ssh2, based on work from jhuuskon@@messi.uku.fi
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.22 2000/10/27 07:48:22 markus Exp $"); */
d53 2
a54 1
#define SSH_CHANNEL_MAX_TYPE		12
@


1.22
log
@deny agent/x11 forwarding unless requested; thanks to jwl@@pobox.com
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.21 2000/10/27 07:32:18 markus Exp $"); */
d52 2
a53 1
#define SSH_CHANNEL_MAX_TYPE		11
a150 1
void	channel_input_open(int type, int plen, void *ctxt);
d205 1
a205 2
 * channel to host:port from remote side.  This never returns if there was an
 * error.
d208 6
a213 2
channel_request_local_forwarding(u_short port, const char *host,
    u_short remote_port, int gateway_ports);
d294 1
@


1.22.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.27 2001/02/15 23:19:59 markus Exp $"); */
d52 1
a52 3
#define SSH_CHANNEL_RPORT_LISTENER	11	/* Listening to a R-style port  */
#define SSH_CHANNEL_CONNECTING		12
#define SSH_CHANNEL_MAX_TYPE		13
a75 1
	int     isatty;		/* rfd is a tty */
d150 1
d165 2
a166 6
/*
 * Allocate/update select bitmasks and add any bits relevant to channels in
 * select bitmasks.
 */
void
channel_prepare_select(fd_set **readsetp, fd_set **writesetp, int *maxfdp);
d190 3
d205 2
a206 1
 * channel to host:port from remote side.
d208 3
a210 7
int
channel_request_local_forwarding(u_short listen_port,
    const char *host_to_connect, u_short port_to_connect, int gateway_ports);
int
channel_request_forwarding(const char *listen_address, u_short listen_port,
    const char *host_to_connect, u_short port_to_connect, int gateway_ports,
    int remote_fwd);
a290 1
int	channel_connect_by_listen_adress(u_short listen_port);
@


1.22.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.22.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.28 2001/03/16 19:06:29 markus Exp $"); */
a39 2
#include "buffer.h"

d229 3
a231 3
 * Permits opening to any host/port if permitted_opens[] is empty.  This is
 * usually called by the server, because the user could connect to any port
 * anyway, and the server has no way to know but to trust the client anyway.
a233 6

/* Add host/port to list of allowed targets for port forwarding */
void	channel_add_permitted_opens(char *host, int port);

/* Flush list */
void	channel_clear_permitted_opens(void);
@


1.22.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.31 2001/04/13 22:46:53 beck Exp $"); */
d56 1
a56 2
#define SSH_CHANNEL_DYNAMIC		13
#define SSH_CHANNEL_MAX_TYPE		14
d174 1
a174 2
channel_prepare_select(fd_set **readsetp, fd_set **writesetp, int *maxfdp,
    int rekeying);
a306 2

int	channel_find_open(void);
@


1.22.2.5
log
@Pull in patch from current:
Errata:
sshd(8) allows users to delete arbitrary files named "cookies" if
X11 forwarding is enabled. X11 forwarding is disabled by default.
Fix (markus):
- use fatal_register_cleanup instead of atexit, sync with x11 authdir
  handling
- switch uid when cleaning up tmp files and sockets; reported by
  zen-parse@@gmx.net on bugtraq
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.22.2.4 2001/05/07 21:09:27 jason Exp $"); */
a294 2

void	auth_sock_cleanup_proc(void *_pw);
@


1.22.2.6
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d13 1
a13 1
 * Copyright (c) 1999, 2000, 2001 Markus Friedl.  All rights reserved.
d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.46 2001/09/17 20:52:47 markus Exp $"); */
d37 2
a38 2
#ifndef CHANNEL_H
#define CHANNEL_H
d43 1
d57 1
a57 4
#define SSH_CHANNEL_ZOMBIE		14	/* Almost dead. */
#define SSH_CHANNEL_MAX_TYPE		15

#define SSH_CHANNEL_PATH_LEN		30
d59 4
d66 2
a67 2
typedef void channel_callback_fn(int, void *);
typedef int channel_filter_fn(struct Channel *, char *, int);
a81 1
	int     force_drain;		/* force close on iEOF */
d87 2
a88 2
	char    path[SSH_CHANNEL_PATH_LEN];
		/* path for unix domain sockets, or host name for forwards */
d107 1
a107 1
	channel_callback_fn	*detach_user;
d125 92
a216 70
/* possible input states */
#define CHAN_INPUT_OPEN			0x01
#define CHAN_INPUT_WAIT_DRAIN		0x02
#define CHAN_INPUT_WAIT_OCLOSE		0x04
#define CHAN_INPUT_CLOSED		0x08

/* possible output states */
#define CHAN_OUTPUT_OPEN		0x10
#define CHAN_OUTPUT_WAIT_DRAIN		0x20
#define CHAN_OUTPUT_WAIT_IEOF		0x40
#define CHAN_OUTPUT_CLOSED		0x80

#define CHAN_CLOSE_SENT			0x01
#define CHAN_CLOSE_RCVD			0x02

/* channel management */

Channel	*channel_lookup(int);
Channel *channel_new(char *, int, int, int, int, int, int, int, char *, int);
void	 channel_set_fds(int, int, int, int, int, int);
void	 channel_free(Channel *);
void	 channel_free_all(void);
void	 channel_detach_all(void);
void	 channel_stop_listening(void);

void	 channel_send_open(int);
void	 channel_request(int, char *, int);
void	 channel_request_start(int, char *, int);
void	 channel_register_callback(int, int mtype, channel_callback_fn *, void *);
void	 channel_register_cleanup(int, channel_callback_fn *);
void	 channel_register_filter(int, channel_filter_fn *);
void	 channel_cancel_cleanup(int);
int	 channel_close_fd(int *);

/* protocol handler */

void	 channel_input_channel_request(int, int, void *);
void	 channel_input_close(int, int, void *);
void	 channel_input_close_confirmation(int, int, void *);
void	 channel_input_data(int, int, void *);
void	 channel_input_extended_data(int, int, void *);
void	 channel_input_ieof(int, int, void *);
void	 channel_input_oclose(int, int, void *);
void	 channel_input_open_confirmation(int, int, void *);
void	 channel_input_open_failure(int, int, void *);
void	 channel_input_port_open(int, int, void *);
void	 channel_input_window_adjust(int, int, void *);

/* file descriptor handling (read/write) */

void	 channel_prepare_select(fd_set **, fd_set **, int *, int*, int);
void     channel_after_select(fd_set *, fd_set *);
void     channel_output_poll(void);

int      channel_not_very_much_buffered_data(void);
void     channel_close_all(void);
void     channel_free_all(void);
int      channel_still_open(void);
char	*channel_open_message(void);
int	 channel_find_open(void);

/* channel_tcpfwd.c */
void     channel_permit_all_opens(void);
void	 channel_add_permitted_opens(char *, int);
void	 channel_clear_permitted_opens(void);
void     channel_input_port_forward_request(int, int);
int	 channel_connect_to(const char *, u_short);
int	 channel_connect_by_listen_address(u_short);
void	 channel_request_remote_forwarding(u_short, const char *, u_short);
int	 channel_request_local_forwarding(u_short, const char *, u_short, int);
d218 88
a305 2
channel_request_forwarding(const char *, u_short, const char *, u_short, int,
    int);
d307 4
a310 1
/* x11 forwarding */
d312 1
a312 34
int	 x11_connect_display(void);
char	*x11_create_display(int);
char	*x11_create_display_inet(int, int);
void     x11_input_open(int, int, void *);
void     x11_request_forwarding(void);
void	 x11_request_forwarding_with_spoofing(int, const char *, const char *);
void	 deny_input_open(int, int, void *);

/* agent forwarding */

void	 auth_request_forwarding(void);
char	*auth_get_socket_name(void);
void	 auth_sock_cleanup_proc(void *);
int	 auth_input_request_forwarding(struct passwd *);
void	 auth_input_open_request(int, int, void *);

/* channel close */

int	 chan_is_dead(Channel *);
void	 chan_mark_dead(Channel *);
void 	 chan_init_iostates(Channel *);
void	 chan_init(void);

typedef void    chan_event_fn(Channel *);

/* for the input state */
extern chan_event_fn	*chan_rcvd_oclose;
extern chan_event_fn	*chan_read_failed;
extern chan_event_fn	*chan_ibuf_empty;

/* for the output state */
extern chan_event_fn	*chan_rcvd_ieof;
extern chan_event_fn	*chan_write_failed;
extern chan_event_fn	*chan_obuf_empty;
@


1.22.2.7
log
@Merge OpenSSH 3.0
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.22.2.6 2001/09/27 00:15:41 miod Exp $"); */
d71 1
d80 1
a80 2
	int     force_drain;	/* force close on iEOF */
	int     delayed;		/* fdset hack */
d146 1
d180 1
d185 1
a185 2
/* tcp forwarding */
void	 channel_set_af(int af);
d218 1
a218 1
int	 chan_is_dead(Channel *, int);
@


1.22.2.8
log
@Merge OpenSSH 3.0.1.

This is likely to be the last commit to the 2.8-STABLE branch.
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.22.2.7 2001/11/15 00:14:59 miod Exp $"); */
d59 1
a59 1
#define SSH_CHANNEL_PATH_LEN		256
@


1.22.2.9
log
@Merge OpenSSH 3.1.
@
text
@a0 2
/*	$OpenBSD: channels.h,v 1.65 2002/03/04 17:27:39 stevesk Exp $	*/

d13 1
a13 1
 * Copyright (c) 1999, 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d35 1
d71 2
a72 2
	u_int   istate;		/* input from channel (state of receive half) */
	u_int   ostate;		/* output to channel  (state of transmit half) */
a98 1
	int	single_connection;
d103 3
a105 1
	channel_callback_fn	*confirm;
d117 6
a122 6
#define CHAN_SES_PACKET_DEFAULT	(32*1024)
#define CHAN_SES_WINDOW_DEFAULT	(4*CHAN_SES_PACKET_DEFAULT)
#define CHAN_TCP_PACKET_DEFAULT	(32*1024)
#define CHAN_TCP_WINDOW_DEFAULT	(4*CHAN_TCP_PACKET_DEFAULT)
#define CHAN_X11_PACKET_DEFAULT	(16*1024)
#define CHAN_X11_WINDOW_DEFAULT	(4*CHAN_X11_PACKET_DEFAULT)
d125 4
a128 4
#define CHAN_INPUT_OPEN			0
#define CHAN_INPUT_WAIT_DRAIN		1
#define CHAN_INPUT_WAIT_OCLOSE		2
#define CHAN_INPUT_CLOSED		3
d131 4
a134 4
#define CHAN_OUTPUT_OPEN		0
#define CHAN_OUTPUT_WAIT_DRAIN		1
#define CHAN_OUTPUT_WAIT_IEOF		2
#define CHAN_OUTPUT_CLOSED		3
d143 1
a143 1
void	 channel_set_fds(int, int, int, int, int, int, u_int);
d149 1
d151 1
a152 1
void	 channel_register_confirm(int, channel_callback_fn *);
d159 11
a169 10
void	 channel_input_close(int, u_int32_t, void *);
void	 channel_input_close_confirmation(int, u_int32_t, void *);
void	 channel_input_data(int, u_int32_t, void *);
void	 channel_input_extended_data(int, u_int32_t, void *);
void	 channel_input_ieof(int, u_int32_t, void *);
void	 channel_input_oclose(int, u_int32_t, void *);
void	 channel_input_open_confirmation(int, u_int32_t, void *);
void	 channel_input_open_failure(int, u_int32_t, void *);
void	 channel_input_port_open(int, u_int32_t, void *);
void	 channel_input_window_adjust(int, u_int32_t, void *);
d192 4
a195 2
int	 channel_setup_local_fwd_listener(u_short, const char *, u_short, int);
int	 channel_setup_remote_fwd_listener(const char *, u_short, int);
d200 4
a203 2
int	 x11_create_display_inet(int, int, int);
void     x11_input_open(int, u_int32_t, void *);
d205 1
a205 1
void	 deny_input_open(int, u_int32_t, void *);
d213 1
a213 1
void	 auth_input_open_request(int, u_int32_t, void *);
d219 2
d222 1
a222 1
/* channel events */
d224 9
a232 7
void	 chan_rcvd_oclose(Channel *);
void	 chan_read_failed(Channel *);
void	 chan_ibuf_empty(Channel *);

void	 chan_rcvd_ieof(Channel *);
void	 chan_write_failed(Channel *);
void	 chan_obuf_empty(Channel *);
@


1.21
log
@enable non-blocking IO on channels, and tty's (except for the client ttys).
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.20 2000/09/21 11:25:33 markus Exp $"); */
d136 2
@


1.20
log
@add context to dispatch_run
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.19 2000/09/07 21:13:37 markus Exp $"); */
a119 1
void	channel_set_fds(int id, int rfd, int wfd, int efd, int extusage);
d131 5
a135 1
    int window, int maxpack, int extended_usage, char *remote_name);
@


1.19
log
@some more Copyright fixes
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.18 2000/09/07 20:40:29 markus Exp $"); */
d134 12
a145 12
void	channel_input_channel_request(int type, int plen);
void	channel_input_close(int type, int plen);
void	channel_input_close_confirmation(int type, int plen);
void	channel_input_data(int type, int plen);
void	channel_input_extended_data(int type, int plen);
void	channel_input_ieof(int type, int plen);
void	channel_input_oclose(int type, int plen);
void	channel_input_open_confirmation(int type, int plen);
void	channel_input_open_failure(int type, int plen);
void	channel_input_port_open(int type, int plen);
void	channel_input_window_adjust(int type, int plen);
void	channel_input_open(int type, int plen);
d249 1
a249 1
void    x11_input_open(int type, int plen);
d282 1
a282 1
void    auth_input_open_request(int type, int plen);
@


1.18
log
@cleanup window and packet sizes for ssh2 flow control; ok niels
@
text
@d2 11
d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.17 2000/09/07 20:27:50 deraadt Exp $"); */
@


1.17
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d24 1
a24 1
/* RCSID("$OpenBSD: channels.h,v 1.16 2000/08/19 21:55:51 markus Exp $"); */
d99 9
@


1.16
log
@more ~ support for ssh2
@
text
@d1 24
a24 1
/* RCSID("$OpenBSD: channels.h,v 1.15 2000/08/19 18:48:11 markus Exp $"); */
@


1.15
log
@support for ~. in ssh2
@
text
@d1 1
a1 1
/* RCSID("$OpenBSD: channels.h,v 1.14 2000/06/20 01:39:40 markus Exp $"); */
d24 3
d28 1
a28 1
typedef int channel_filter_fn(Buffer *b, char *buf, int len);
d30 1
a30 1
typedef struct Channel {
d71 1
a71 1
}       Channel;
@


1.14
log
@OpenBSD tag
@
text
@d1 1
a1 1
/* RCSID("$OpenBSD: channels.h,v 1.13 2000/05/30 17:23:37 markus Exp $"); */
d25 1
d65 3
d80 1
@


1.13
log
@don't panic if mkdtemp fails for authfwd; jkb@@yahoo-inc.com via kris@@FreeBSD.org
@
text
@d1 1
a1 1
/* RCSID("$Id: channels.h,v 1.12 2000/05/03 18:03:06 markus Exp $"); */
@


1.12
log
@GatewayPorts for sshd, ok deraadt@@
@
text
@d1 1
a1 1
/* RCSID("$Id: channels.h,v 1.11 2000/05/02 12:44:38 markus Exp $"); */
d225 1
a225 1
 * This if called to process SSH_CMSG_AGENT_REQUEST_FORWARDING on the server.
d228 1
a228 1
void    auth_input_request_forwarding(struct passwd * pw);
@


1.12.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d1 1
a1 1
/* RCSID("$Id: channels.h,v 1.13 2000/05/30 17:23:37 markus Exp $"); */
d225 1
a225 1
 * This is called to process SSH_CMSG_AGENT_REQUEST_FORWARDING on the server.
d228 1
a228 1
int     auth_input_request_forwarding(struct passwd * pw);
@


1.12.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d1 1
a1 1
/* RCSID("$OpenBSD: channels.h,v 1.16 2000/08/19 21:55:51 markus Exp $"); */
a23 3
struct Channel;
typedef struct Channel Channel;

a24 1
typedef int channel_filter_fn(struct Channel *c, char *buf, int len);
d26 1
a26 1
struct Channel {
d64 1
a64 4

	/* filter */
	channel_filter_fn	*input_filter;
};
a75 1
void	channel_register_filter(int id, channel_filter_fn *fn);
@


1.12.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d1 1
a1 35
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */
/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/* RCSID("$OpenBSD: channels.h,v 1.22 2000/10/27 07:48:22 markus Exp $"); */
d77 1
a77 9
/* default window/packet sizes for tcp/x11-fwd-channel */
#define CHAN_SES_WINDOW_DEFAULT	(32*1024)
#define CHAN_SES_PACKET_DEFAULT	(CHAN_SES_WINDOW_DEFAULT/2)
#define CHAN_TCP_WINDOW_DEFAULT	(32*1024)
#define CHAN_TCP_PACKET_DEFAULT	(CHAN_TCP_WINDOW_DEFAULT/2)
#define CHAN_X11_WINDOW_DEFAULT	(4*1024)
#define CHAN_X11_PACKET_DEFAULT	(CHAN_X11_WINDOW_DEFAULT/2)


d89 1
a89 7
    int window, int maxpack, int extended_usage, char *remote_name,
    int nonblock);
void
channel_set_fds(int id, int rfd, int wfd, int efd,
    int extusage, int nonblock);

void	deny_input_open(int type, int plen, void *ctxt);
d91 12
a102 12
void	channel_input_channel_request(int type, int plen, void *ctxt);
void	channel_input_close(int type, int plen, void *ctxt);
void	channel_input_close_confirmation(int type, int plen, void *ctxt);
void	channel_input_data(int type, int plen, void *ctxt);
void	channel_input_extended_data(int type, int plen, void *ctxt);
void	channel_input_ieof(int type, int plen, void *ctxt);
void	channel_input_oclose(int type, int plen, void *ctxt);
void	channel_input_open_confirmation(int type, int plen, void *ctxt);
void	channel_input_open_failure(int type, int plen, void *ctxt);
void	channel_input_port_open(int type, int plen, void *ctxt);
void	channel_input_window_adjust(int type, int plen, void *ctxt);
void	channel_input_open(int type, int plen, void *ctxt);
d206 1
a206 1
void    x11_input_open(int type, int plen, void *ctxt);
d239 1
a239 1
void    auth_input_open_request(int type, int plen, void *ctxt);
@


1.12.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.27 2001/02/15 23:19:59 markus Exp $"); */
d52 1
a52 3
#define SSH_CHANNEL_RPORT_LISTENER	11	/* Listening to a R-style port  */
#define SSH_CHANNEL_CONNECTING		12
#define SSH_CHANNEL_MAX_TYPE		13
a75 1
	int     isatty;		/* rfd is a tty */
d150 1
d165 2
a166 6
/*
 * Allocate/update select bitmasks and add any bits relevant to channels in
 * select bitmasks.
 */
void
channel_prepare_select(fd_set **readsetp, fd_set **writesetp, int *maxfdp);
d190 3
d205 2
a206 1
 * channel to host:port from remote side.
d208 3
a210 7
int
channel_request_local_forwarding(u_short listen_port,
    const char *host_to_connect, u_short port_to_connect, int gateway_ports);
int
channel_request_forwarding(const char *listen_address, u_short listen_port,
    const char *host_to_connect, u_short port_to_connect, int gateway_ports,
    int remote_fwd);
a290 1
int	channel_connect_by_listen_adress(u_short listen_port);
@


1.12.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d35 1
a35 1
/* RCSID("$OpenBSD: channels.h,v 1.28 2001/03/16 19:06:29 markus Exp $"); */
a39 2
#include "buffer.h"

d229 3
a231 3
 * Permits opening to any host/port if permitted_opens[] is empty.  This is
 * usually called by the server, because the user could connect to any port
 * anyway, and the server has no way to know but to trust the client anyway.
a233 6

/* Add host/port to list of allowed targets for port forwarding */
void	channel_add_permitted_opens(char *host, int port);

/* Flush list */
void	channel_clear_permitted_opens(void);
@


1.11
log
@use c-style comments
@
text
@d1 1
a1 1
/* RCSID("$Id: channels.h,v 1.10 2000/04/28 08:10:20 markus Exp $"); */
d178 1
a178 1
void    channel_input_port_forward_request(int is_root);
@


1.10
log
@support for x11-fwding, client+server
@
text
@d1 1
a1 1
/* RCSID("$Id: channels.h,v 1.9 2000/04/14 10:30:30 markus Exp $"); */
d59 1
a59 1
	// callback
@


1.9
log
@whitespace cleanup
@
text
@d1 1
a1 1
/* RCSID("$Id: channels.h,v 1.8 2000/04/03 07:07:15 markus Exp $"); */
d210 3
a212 1
void    x11_request_forwarding_with_spoofing(const char *proto, const char *data);
d235 1
@


1.8
log
@channel layer support for ssh2
@
text
@d1 1
a1 1
/* RCSID("$Id: channels.h,v 1.7 2000/03/28 20:31:26 markus Exp $"); */
d152 1
a152 1
void 
d162 1
a162 1
void 
@


1.7
log
@replace big switch() with function tables (prepare for ssh2)
@
text
@d1 1
a1 1
/* RCSID("$Id: channels.h,v 1.7 2000/03/21 22:41:02 markus Exp $"); */
d33 1
d70 1
d72 5
d83 1
d87 1
d93 1
d230 3
@


1.6
log
@KNF, final part 3
@
text
@d1 1
a1 1
/* RCSID("$Id: channels.h,v 1.5 1999/11/24 00:26:01 deraadt Exp $"); */
d13 6
a18 6
/*	SSH_CHANNEL_AUTH_FD		6    	   authentication fd */
#define SSH_CHANNEL_AUTH_SOCKET		7	/* authentication socket */
/*	SSH_CHANNEL_AUTH_SOCKET_FD	8    	   connection to auth socket */
#define SSH_CHANNEL_X11_OPEN		9	/* reading first X11 packet */
#define SSH_CHANNEL_INPUT_DRAINING	10	/* sending remaining data to conn */
#define SSH_CHANNEL_OUTPUT_DRAINING	11	/* sending remaining data to app */
d24 1
d33 4
a36 1
	int     sock;		/* data socket, linked to this channel */
d41 1
d47 16
d64 157
@


1.5
log
@much more KNF
@
text
@d1 1
a1 1
/* RCSID("$Id: channels.h,v 1.4 1999/10/28 21:26:09 markus Exp $"); */
d7 2
a8 4
#define SSH_CHANNEL_FREE		0	/* This channel is free
						 * (unused). */
#define SSH_CHANNEL_X11_LISTENER	1	/* Listening for inet X11
						 * conn. */
d12 2
a13 3
#define SSH_CHANNEL_CLOSED		5	/* waiting for close
						 * confirmation */
/*	SSH_CHANNEL_AUTH_FD		6    authentication fd */
d15 1
a15 1
/*	SSH_CHANNEL_AUTH_SOCKET_FD	8    connection to auth socket */
d17 2
a18 4
#define SSH_CHANNEL_INPUT_DRAINING	10	/* sending remaining data to
						 * conn */
#define SSH_CHANNEL_OUTPUT_DRAINING	11	/* sending remaining data to
						 * app */
d20 4
a23 2
/* Data structure for channel data.  This is iniailized in channel_allocate
   and cleared in channel_free. */
@


1.4
log
@remove broken x11 fix and document istate/ostate
@
text
@d1 1
a1 1
/* RCSID("$Id: channels.h,v 1.3 1999/10/17 16:56:09 markus Exp $"); */
d7 9
a15 6
#define SSH_CHANNEL_FREE		0 /* This channel is free (unused). */
#define SSH_CHANNEL_X11_LISTENER	1 /* Listening for inet X11 conn. */
#define SSH_CHANNEL_PORT_LISTENER	2 /* Listening on a port. */
#define SSH_CHANNEL_OPENING		3 /* waiting for confirmation */
#define SSH_CHANNEL_OPEN		4 /* normal open two-way channel */
#define SSH_CHANNEL_CLOSED		5 /* waiting for close confirmation */
d17 1
a17 1
#define SSH_CHANNEL_AUTH_SOCKET		7 /* authentication socket */
d19 5
a23 3
#define SSH_CHANNEL_X11_OPEN		9 /* reading first X11 packet */
#define SSH_CHANNEL_INPUT_DRAINING	10 /* sending remaining data to conn */
#define SSH_CHANNEL_OUTPUT_DRAINING	11 /* sending remaining data to app */
d28 18
a45 17
typedef struct Channel
{
  int type;		/* channel type/state */
  int self;		/* my own channel identifier */
  int remote_id;	/* channel identifier for remote peer */
			/* peer can be reached over encrypted connection, via packet-sent */
  int istate;		/* input from channel (state of receive half) */
  int ostate;		/* output to channel  (state of transmit half) */
  int sock;		/* data socket, linked to this channel */
  Buffer input;		/* data read from socket, to be sent over encrypted connection */
  Buffer output;	/* data received over encrypted connection for send on socket */
  char path[200];	/* path for unix domain sockets, or host name for forwards */
  int listening_port;	/* port being listened for forwards */
  int host_port;	/* remote port to connect for forwards */
  char *remote_name;	/* remote hostname */
} Channel;

@


1.3
log
@re-implement the proto-1.5 channel close protocol, see nchan.ms.
@
text
@d1 1
a1 1
/* RCSID("$Id: channels.h,v 1.2 1999/10/16 22:29:00 markus Exp $"); */
d29 2
a30 3
  int istate;
  int ostate;
  int x11;
@


1.2
log
@add CVS tags, fix comments and whitespace
@
text
@d1 1
a1 1
/* RCSID("$Id: servconf.h,v 1.9 1999/10/12 18:11:54 markus Exp $"); */
a19 1

d23 1
a23 1
typedef struct
d29 3
a31 1
  int flags;		/* flags for close in proto 1.5 */
@


1.1
log
@support for SSH protocol 1.5 which is poorly documented, the RFC.troff lies.
interops (x11,agent,etc) with 1.2.27 and protocol 1.3
@
text
@d1 2
@

