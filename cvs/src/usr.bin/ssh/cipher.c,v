head	1.102;
access;
symbols
	OPENBSD_6_0:1.101.0.6
	OPENBSD_6_0_BASE:1.101
	OPENBSD_5_9:1.101.0.2
	OPENBSD_5_9_BASE:1.101
	OPENBSD_5_8:1.100.0.4
	OPENBSD_5_8_BASE:1.100
	OPENBSD_5_7:1.100.0.2
	OPENBSD_5_7_BASE:1.100
	OPENBSD_5_6:1.99.0.4
	OPENBSD_5_6_BASE:1.99
	OPENBSD_5_5:1.97.0.4
	OPENBSD_5_5_BASE:1.97
	OPENBSD_5_4:1.89.0.2
	OPENBSD_5_4_BASE:1.89
	OPENBSD_5_3:1.87.0.2
	OPENBSD_5_3_BASE:1.87
	OPENBSD_5_2:1.82.0.16
	OPENBSD_5_2_BASE:1.82
	OPENBSD_5_1_BASE:1.82
	OPENBSD_5_1:1.82.0.14
	OPENBSD_5_0:1.82.0.12
	OPENBSD_5_0_BASE:1.82
	OPENBSD_4_9:1.82.0.10
	OPENBSD_4_9_BASE:1.82
	OPENBSD_4_8:1.82.0.8
	OPENBSD_4_8_BASE:1.82
	OPENBSD_4_7:1.82.0.4
	OPENBSD_4_7_BASE:1.82
	OPENBSD_4_6:1.82.0.6
	OPENBSD_4_6_BASE:1.82
	OPENBSD_4_5:1.82.0.2
	OPENBSD_4_5_BASE:1.82
	OPENBSD_4_4:1.81.0.10
	OPENBSD_4_4_BASE:1.81
	OPENBSD_4_3:1.81.0.8
	OPENBSD_4_3_BASE:1.81
	OPENBSD_4_2:1.81.0.6
	OPENBSD_4_2_BASE:1.81
	OPENBSD_4_1:1.81.0.2
	OPENBSD_4_1_BASE:1.81
	OPENBSD_4_0:1.81.0.4
	OPENBSD_4_0_BASE:1.81
	OPENBSD_3_9:1.77.0.4
	OPENBSD_3_9_BASE:1.77
	OPENBSD_3_8:1.77.0.2
	OPENBSD_3_8_BASE:1.77
	OPENBSD_3_7:1.73.0.2
	OPENBSD_3_7_BASE:1.73
	OPENBSD_3_6:1.71.0.2
	OPENBSD_3_6_BASE:1.71
	OPENBSD_3_5:1.68.0.2
	OPENBSD_3_5_BASE:1.68
	OPENBSD_3_4:1.65.0.2
	OPENBSD_3_4_BASE:1.65
	OPENBSD_3_3:1.62.0.2
	OPENBSD_3_3_BASE:1.62
	OPENBSD_3_2:1.61.0.2
	OPENBSD_3_2_BASE:1.61
	OPENBSD_3_1:1.55.0.2
	OPENBSD_3_1_BASE:1.55
	OPENBSD_3_0:1.47.0.2
	OPENBSD_3_0_BASE:1.47
	OPENBSD_2_9_BASE:1.43
	OPENBSD_2_9:1.43.0.2
	OPENBSD_2_8:1.37.0.2
	OPENBSD_2_8_BASE:1.37
	OPENBSD_2_7:1.26.0.2
	OPENBSD_2_7_BASE:1.26
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11;
locks; strict;
comment	@ * @;


1.102
date	2016.08.03.05.41.57;	author djm;	state Exp;
branches;
next	1.101;
commitid	otf59Ccl8VGeZugs;

1.101
date	2015.12.10.17.08.40;	author mmcc;	state Exp;
branches;
next	1.100;
commitid	qST12VGCwbX5zIfM;

1.100
date	2015.01.14.10.29.45;	author djm;	state Exp;
branches;
next	1.99;
commitid	hRm7eMZsmVi6HHfv;

1.99
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.98;
commitid	1h9UxAQmwdaqUzyX;

1.98
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.97;

1.97
date	2014.02.07.06.55.54;	author djm;	state Exp;
branches;
next	1.96;

1.96
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.95;

1.95
date	2014.01.27.19.18.54;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2014.01.25.10.12.50;	author dtucker;	state Exp;
branches;
next	1.93;

1.93
date	2013.12.06.13.34.54;	author markus;	state Exp;
branches;
next	1.92;

1.92
date	2013.12.02.03.13.14;	author djm;	state Exp;
branches;
next	1.91;

1.91
date	2013.11.21.00.45.44;	author djm;	state Exp;
branches;
next	1.90;

1.90
date	2013.11.07.11.58.27;	author dtucker;	state Exp;
branches;
next	1.89;

1.89
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.88;

1.88
date	2013.04.19.01.06.50;	author djm;	state Exp;
branches;
next	1.87;

1.87
date	2013.01.26.06.11.05;	author djm;	state Exp;
branches;
next	1.86;

1.86
date	2013.01.12.11.22.04;	author djm;	state Exp;
branches;
next	1.85;

1.85
date	2013.01.08.18.49.04;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2012.12.12.16.46.10;	author naddy;	state Exp;
branches;
next	1.83;

1.83
date	2012.12.11.22.31.18;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2009.01.26.09.58.15;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.79;

1.79
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2005.07.16.01.35.24;	author djm;	state Exp;
branches
	1.77.2.1
	1.77.4.1;
next	1.76;

1.76
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches;
next	1.75;

1.75
date	2005.06.09.13.43.49;	author dtucker;	state Exp;
branches;
next	1.74;

1.74
date	2005.05.23.23.32.46;	author djm;	state Exp;
branches;
next	1.73;

1.73
date	2005.01.23.10.18.12;	author djm;	state Exp;
branches
	1.73.2.1;
next	1.72;

1.72
date	2004.12.22.02.13.19;	author djm;	state Exp;
branches;
next	1.71;

1.71
date	2004.07.28.09.40.29;	author markus;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2004.07.11.17.48.47;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches;
next	1.68;

1.68
date	2004.01.23.19.26.33;	author hshoexer;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2004.01.23.17.06.03;	author hshoexer;	state Exp;
branches;
next	1.66;

1.66
date	2003.11.10.16.23.41;	author jakob;	state Exp;
branches;
next	1.65;

1.65
date	2003.05.17.04.27.52;	author markus;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2003.05.15.03.08.29;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2003.04.12.10.13.57;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2002.11.21.22.45.31;	author markus;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2002.07.12.15.50.17;	author markus;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2002.06.23.03.26.52;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2002.06.19.18.01.00;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2002.06.04.23.05.49;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2002.05.30.08.07.31;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2002.05.16.22.02.50;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2002.04.03.09.26.11;	author markus;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2002.03.19.10.49.35;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2002.03.18.17.13.15;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.18.13.05.32;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2002.02.14.23.41.01;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2002.01.21.22.30.12;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2002.01.18.18.14.17;	author stevesk;	state Exp;
branches;
next	1.48;

1.48
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2001.08.23.11.31.59;	author markus;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2001.06.25.08.25.36;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.23.15.12.18;	author itojun;	state Exp;
branches;
next	1.44;

1.44
date	2001.05.28.22.51.10;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2001.02.04.15.32.23;	author stevesk;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2001.01.21.19.05.46;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2000.12.19.23.17.56;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2000.12.09.13.41.52;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2000.12.06.23.05.42;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2000.11.29.20.39.17;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2000.10.23.19.31.54;	author markus;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2000.10.14.10.01.15;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2000.10.13.18.59.13;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.12.09.59.18;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2000.10.11.20.45.21;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.11.20.27.23;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.12.00.38.32;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2000.09.07.20.27.50;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.10.16.30.25;	author ho;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.20.01.39.40;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2000.05.22.18.42.00;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.14.10.30.30;	author markus;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2000.04.12.09.39.10;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2000.04.12.07.45.43;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.12.00.18.20;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2000.04.04.21.37.27;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.28.20.24.49;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.22.09.55.10;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.22.15.19.29;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	99.11.24.19.53.45;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	99.11.24.00.26.01;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.11.23.22.25.53;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	99.11.22.21.02.38;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	99.11.15.21.38.53;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	99.11.02.19.42.35;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	99.10.27.16.37.45;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.09.30.22.12.16;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	99.09.30.18.41.24;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	99.09.30.18.37.45;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	99.09.30.17.08.52;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.09.30.14.05.41;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	99.09.30.05.53.04;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.09.30.05.19.57;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.09.28.04.45.36;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	99.09.26.22.53.25;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.26.21.02.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.34;	author deraadt;	state Exp;
branches;
next	;

1.26.2.1
date	2000.06.12.02.37.33;	author jason;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2000.09.01.18.23.18;	author jason;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2000.11.08.21.30.34;	author jason;	state Exp;
branches;
next	1.26.2.4;

1.26.2.4
date	2001.03.12.15.44.09;	author jason;	state Exp;
branches;
next	1.26.2.5;

1.26.2.5
date	2001.03.21.18.52.40;	author jason;	state Exp;
branches;
next	;

1.37.2.1
date	2001.02.16.20.12.57;	author jason;	state Exp;
branches;
next	1.37.2.2;

1.37.2.2
date	2001.02.19.17.18.46;	author jason;	state Exp;
branches;
next	1.37.2.3;

1.37.2.3
date	2001.03.21.19.46.24;	author jason;	state Exp;
branches;
next	1.37.2.4;

1.37.2.4
date	2001.05.07.21.09.28;	author jason;	state Exp;
branches;
next	1.37.2.5;

1.37.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.37.2.6;

1.37.2.6
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.43.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.43.2.3;

1.43.2.3
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.47.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.47.2.3;

1.47.2.3
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.47.2.4;

1.47.2.4
date	2002.06.26.18.22.34;	author miod;	state Exp;
branches;
next	1.47.2.5;

1.47.2.5
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.55.2.1
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.55.2.2;

1.55.2.2
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.55.2.3;

1.55.2.3
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.61.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	2003.09.16.21.20.25;	author brad;	state Exp;
branches;
next	;

1.62.2.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.62.2.2;

1.62.2.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.65.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.65.2.2;

1.65.2.2
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.68.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	1.68.2.2;

1.68.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.71.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.71.2.2;

1.71.2.2
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.73.2.1
date	2005.09.04.18.40.01;	author brad;	state Exp;
branches;
next	;

1.77.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.77.4.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.102
log
@small refactor of cipher.c: make ciphercontext opaque to callers
feedback and ok markus@@
@
text
@/* $OpenBSD: cipher.c,v 1.101 2015/12/10 17:08:40 mmcc Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
 * Copyright (c) 1999 Niels Provos.  All rights reserved.
 * Copyright (c) 1999, 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>

#include <string.h>
#include <stdarg.h>
#include <stdio.h>

#include "cipher.h"
#include "misc.h"
#include "sshbuf.h"
#include "ssherr.h"
#include "digest.h"

#ifdef WITH_SSH1
extern const EVP_CIPHER *evp_ssh1_bf(void);
extern const EVP_CIPHER *evp_ssh1_3des(void);
extern int ssh1_3des_iv(EVP_CIPHER_CTX *, int, u_char *, int);
#endif

struct sshcipher_ctx {
	int	plaintext;
	int	encrypt;
	EVP_CIPHER_CTX *evp;
	struct chachapoly_ctx cp_ctx; /* XXX union with evp? */
	struct aesctr_ctx ac_ctx; /* XXX union with evp? */
	const struct sshcipher *cipher;
};

struct sshcipher {
	char	*name;
	int	number;		/* for ssh1 only */
	u_int	block_size;
	u_int	key_len;
	u_int	iv_len;		/* defaults to block_size */
	u_int	auth_len;
	u_int	discard_len;
	u_int	flags;
#define CFLAG_CBC		(1<<0)
#define CFLAG_CHACHAPOLY	(1<<1)
#define CFLAG_AESCTR		(1<<2)
#define CFLAG_NONE		(1<<3)
#ifdef WITH_OPENSSL
	const EVP_CIPHER	*(*evptype)(void);
#else
	void	*ignored;
#endif
};

static const struct sshcipher ciphers[] = {
#ifdef WITH_SSH1
	{ "des",	SSH_CIPHER_DES, 8, 8, 0, 0, 0, 1, EVP_des_cbc },
	{ "3des",	SSH_CIPHER_3DES, 8, 16, 0, 0, 0, 1, evp_ssh1_3des },
	{ "blowfish",	SSH_CIPHER_BLOWFISH, 8, 32, 0, 0, 0, 1, evp_ssh1_bf },
#endif
#ifdef WITH_OPENSSL
	{ "none",	SSH_CIPHER_NONE, 8, 0, 0, 0, 0, 0, EVP_enc_null },
	{ "3des-cbc",	SSH_CIPHER_SSH2, 8, 24, 0, 0, 0, 1, EVP_des_ede3_cbc },
	{ "blowfish-cbc",
			SSH_CIPHER_SSH2, 8, 16, 0, 0, 0, 1, EVP_bf_cbc },
	{ "cast128-cbc",
			SSH_CIPHER_SSH2, 8, 16, 0, 0, 0, 1, EVP_cast5_cbc },
	{ "arcfour",	SSH_CIPHER_SSH2, 8, 16, 0, 0, 0, 0, EVP_rc4 },
	{ "arcfour128",	SSH_CIPHER_SSH2, 8, 16, 0, 0, 1536, 0, EVP_rc4 },
	{ "arcfour256",	SSH_CIPHER_SSH2, 8, 32, 0, 0, 1536, 0, EVP_rc4 },
	{ "aes128-cbc",	SSH_CIPHER_SSH2, 16, 16, 0, 0, 0, 1, EVP_aes_128_cbc },
	{ "aes192-cbc",	SSH_CIPHER_SSH2, 16, 24, 0, 0, 0, 1, EVP_aes_192_cbc },
	{ "aes256-cbc",	SSH_CIPHER_SSH2, 16, 32, 0, 0, 0, 1, EVP_aes_256_cbc },
	{ "rijndael-cbc@@lysator.liu.se",
			SSH_CIPHER_SSH2, 16, 32, 0, 0, 0, 1, EVP_aes_256_cbc },
	{ "aes128-ctr",	SSH_CIPHER_SSH2, 16, 16, 0, 0, 0, 0, EVP_aes_128_ctr },
	{ "aes192-ctr",	SSH_CIPHER_SSH2, 16, 24, 0, 0, 0, 0, EVP_aes_192_ctr },
	{ "aes256-ctr",	SSH_CIPHER_SSH2, 16, 32, 0, 0, 0, 0, EVP_aes_256_ctr },
	{ "aes128-gcm@@openssh.com",
			SSH_CIPHER_SSH2, 16, 16, 12, 16, 0, 0, EVP_aes_128_gcm },
	{ "aes256-gcm@@openssh.com",
			SSH_CIPHER_SSH2, 16, 32, 12, 16, 0, 0, EVP_aes_256_gcm },
#else
	{ "aes128-ctr",	SSH_CIPHER_SSH2, 16, 16, 0, 0, 0, CFLAG_AESCTR, NULL },
	{ "aes192-ctr",	SSH_CIPHER_SSH2, 16, 24, 0, 0, 0, CFLAG_AESCTR, NULL },
	{ "aes256-ctr",	SSH_CIPHER_SSH2, 16, 32, 0, 0, 0, CFLAG_AESCTR, NULL },
	{ "none",	SSH_CIPHER_NONE, 8, 0, 0, 0, 0, CFLAG_NONE, NULL },
#endif
	{ "chacha20-poly1305@@openssh.com",
			SSH_CIPHER_SSH2, 8, 64, 0, 16, 0, CFLAG_CHACHAPOLY, NULL },

	{ NULL,		SSH_CIPHER_INVALID, 0, 0, 0, 0, 0, 0, NULL }
};

/*--*/

/* Returns a comma-separated list of supported ciphers. */
char *
cipher_alg_list(char sep, int auth_only)
{
	char *tmp, *ret = NULL;
	size_t nlen, rlen = 0;
	const struct sshcipher *c;

	for (c = ciphers; c->name != NULL; c++) {
		if (c->number != SSH_CIPHER_SSH2)
			continue;
		if (auth_only && c->auth_len == 0)
			continue;
		if (ret != NULL)
			ret[rlen++] = sep;
		nlen = strlen(c->name);
		if ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {
			free(ret);
			return NULL;
		}
		ret = tmp;
		memcpy(ret + rlen, c->name, nlen + 1);
		rlen += nlen;
	}
	return ret;
}

u_int
cipher_blocksize(const struct sshcipher *c)
{
	return (c->block_size);
}

u_int
cipher_keylen(const struct sshcipher *c)
{
	return (c->key_len);
}

u_int
cipher_seclen(const struct sshcipher *c)
{
	if (strcmp("3des-cbc", c->name) == 0)
		return 14;
	return cipher_keylen(c);
}

u_int
cipher_authlen(const struct sshcipher *c)
{
	return (c->auth_len);
}

u_int
cipher_ivlen(const struct sshcipher *c)
{
	/*
	 * Default is cipher block size, except for chacha20+poly1305 that
	 * needs no IV. XXX make iv_len == -1 default?
	 */
	return (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?
	    c->iv_len : c->block_size;
}

u_int
cipher_get_number(const struct sshcipher *c)
{
	return (c->number);
}

u_int
cipher_is_cbc(const struct sshcipher *c)
{
	return (c->flags & CFLAG_CBC) != 0;
}

u_int
cipher_ctx_is_plaintext(struct sshcipher_ctx *cc)
{
	return cc->plaintext;
}

u_int
cipher_ctx_get_number(struct sshcipher_ctx *cc)
{
	return cc->cipher->number;
}

u_int
cipher_mask_ssh1(int client)
{
	u_int mask = 0;
	mask |= 1 << SSH_CIPHER_3DES;		/* Mandatory */
	mask |= 1 << SSH_CIPHER_BLOWFISH;
	if (client) {
		mask |= 1 << SSH_CIPHER_DES;
	}
	return mask;
}

const struct sshcipher *
cipher_by_name(const char *name)
{
	const struct sshcipher *c;
	for (c = ciphers; c->name != NULL; c++)
		if (strcmp(c->name, name) == 0)
			return c;
	return NULL;
}

const struct sshcipher *
cipher_by_number(int id)
{
	const struct sshcipher *c;
	for (c = ciphers; c->name != NULL; c++)
		if (c->number == id)
			return c;
	return NULL;
}

#define	CIPHER_SEP	","
int
ciphers_valid(const char *names)
{
	const struct sshcipher *c;
	char *cipher_list, *cp;
	char *p;

	if (names == NULL || strcmp(names, "") == 0)
		return 0;
	if ((cipher_list = cp = strdup(names)) == NULL)
		return 0;
	for ((p = strsep(&cp, CIPHER_SEP)); p && *p != '\0';
	    (p = strsep(&cp, CIPHER_SEP))) {
		c = cipher_by_name(p);
		if (c == NULL || c->number != SSH_CIPHER_SSH2) {
			free(cipher_list);
			return 0;
		}
	}
	free(cipher_list);
	return 1;
}

/*
 * Parses the name of the cipher.  Returns the number of the corresponding
 * cipher, or -1 on error.
 */

int
cipher_number(const char *name)
{
	const struct sshcipher *c;
	if (name == NULL)
		return -1;
	for (c = ciphers; c->name != NULL; c++)
		if (strcasecmp(c->name, name) == 0)
			return c->number;
	return -1;
}

char *
cipher_name(int id)
{
	const struct sshcipher *c = cipher_by_number(id);
	return (c==NULL) ? "<unknown>" : c->name;
}

const char *
cipher_warning_message(const struct sshcipher_ctx *cc)
{
	if (cc == NULL || cc->cipher == NULL)
		return NULL;
	if (cc->cipher->number == SSH_CIPHER_DES)
		return "use of DES is strongly discouraged due to "
		    "cryptographic weaknesses";
	return NULL;
}

int
cipher_init(struct sshcipher_ctx **ccp, const struct sshcipher *cipher,
    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen,
    int do_encrypt)
{
	struct sshcipher_ctx *cc = NULL;
	int ret = SSH_ERR_INTERNAL_ERROR;
#ifdef WITH_OPENSSL
	const EVP_CIPHER *type;
	int klen;
	u_char *junk, *discard;
#endif

	*ccp = NULL;
	if ((cc = calloc(sizeof(*cc), 1)) == NULL)
		return SSH_ERR_ALLOC_FAIL;

	if (cipher->number == SSH_CIPHER_DES) {
		if (keylen > 8)
			keylen = 8;
	}

	cc->plaintext = (cipher->number == SSH_CIPHER_NONE);
	cc->encrypt = do_encrypt;

	if (keylen < cipher->key_len ||
	    (iv != NULL && ivlen < cipher_ivlen(cipher))) {
		ret = SSH_ERR_INVALID_ARGUMENT;
		goto out;
	}

	cc->cipher = cipher;
	if ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {
		ret = chachapoly_init(&cc->cp_ctx, key, keylen);
		goto out;
	}
#ifndef WITH_OPENSSL
	if ((cc->cipher->flags & CFLAG_AESCTR) != 0) {
		aesctr_keysetup(&cc->ac_ctx, key, 8 * keylen, 8 * ivlen);
		aesctr_ivsetup(&cc->ac_ctx, iv);
		ret = 0;
		goto out;
	}
	if ((cc->cipher->flags & CFLAG_NONE) != 0) {
		ret = 0;
		goto out;
	}
	ret = SSH_ERR_INVALID_ARGUMENT;
	goto out;
#else /* WITH_OPENSSL */
	type = (*cipher->evptype)();
	if ((cc->evp = EVP_CIPHER_CTX_new()) == NULL) {
		ret = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if (EVP_CipherInit(cc->evp, type, NULL, (u_char *)iv,
	    (do_encrypt == CIPHER_ENCRYPT)) == 0) {
		ret = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}
	if (cipher_authlen(cipher) &&
	    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_IV_FIXED,
	    -1, (u_char *)iv)) {
		ret = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}
	klen = EVP_CIPHER_CTX_key_length(cc->evp);
	if (klen > 0 && keylen != (u_int)klen) {
		if (EVP_CIPHER_CTX_set_key_length(cc->evp, keylen) == 0) {
			ret = SSH_ERR_LIBCRYPTO_ERROR;
			goto out;
		}
	}
	if (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {
		ret = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}

	if (cipher->discard_len > 0) {
		if ((junk = malloc(cipher->discard_len)) == NULL ||
		    (discard = malloc(cipher->discard_len)) == NULL) {
			free(junk);
			ret = SSH_ERR_ALLOC_FAIL;
			goto out;
		}
		ret = EVP_Cipher(cc->evp, discard, junk, cipher->discard_len);
		explicit_bzero(discard, cipher->discard_len);
		free(junk);
		free(discard);
		if (ret != 1) {
			ret = SSH_ERR_LIBCRYPTO_ERROR;
			goto out;
		}
	}
	ret = 0;
#endif /* WITH_OPENSSL */
 out:
	if (ret == 0) {
		/* success */
		*ccp = cc;
	} else {
		if (cc != NULL) {
#ifdef WITH_OPENSSL
			if (cc->evp != NULL)
				EVP_CIPHER_CTX_free(cc->evp);
#endif /* WITH_OPENSSL */
			explicit_bzero(cc, sizeof(*cc));
			free(cc);
		}
	}
	return ret;
}

/*
 * cipher_crypt() operates as following:
 * Copy 'aadlen' bytes (without en/decryption) from 'src' to 'dest'.
 * Theses bytes are treated as additional authenticated data for
 * authenticated encryption modes.
 * En/Decrypt 'len' bytes at offset 'aadlen' from 'src' to 'dest'.
 * Use 'authlen' bytes at offset 'len'+'aadlen' as the authentication tag.
 * This tag is written on encryption and verified on decryption.
 * Both 'aadlen' and 'authlen' can be set to 0.
 */
int
cipher_crypt(struct sshcipher_ctx *cc, u_int seqnr, u_char *dest,
   const u_char *src, u_int len, u_int aadlen, u_int authlen)
{
	if ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {
		return chachapoly_crypt(&cc->cp_ctx, seqnr, dest, src,
		    len, aadlen, authlen, cc->encrypt);
	}
#ifndef WITH_OPENSSL
	if ((cc->cipher->flags & CFLAG_AESCTR) != 0) {
		if (aadlen)
			memcpy(dest, src, aadlen);
		aesctr_encrypt_bytes(&cc->ac_ctx, src + aadlen,
		    dest + aadlen, len);
		return 0;
	}
	if ((cc->cipher->flags & CFLAG_NONE) != 0) {
		memcpy(dest, src, aadlen + len);
		return 0;
	}
	return SSH_ERR_INVALID_ARGUMENT;
#else
	if (authlen) {
		u_char lastiv[1];

		if (authlen != cipher_authlen(cc->cipher))
			return SSH_ERR_INVALID_ARGUMENT;
		/* increment IV */
		if (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,
		    1, lastiv))
			return SSH_ERR_LIBCRYPTO_ERROR;
		/* set tag on decyption */
		if (!cc->encrypt &&
		    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_TAG,
		    authlen, (u_char *)src + aadlen + len))
			return SSH_ERR_LIBCRYPTO_ERROR;
	}
	if (aadlen) {
		if (authlen &&
		    EVP_Cipher(cc->evp, NULL, (u_char *)src, aadlen) < 0)
			return SSH_ERR_LIBCRYPTO_ERROR;
		memcpy(dest, src, aadlen);
	}
	if (len % cc->cipher->block_size)
		return SSH_ERR_INVALID_ARGUMENT;
	if (EVP_Cipher(cc->evp, dest + aadlen, (u_char *)src + aadlen,
	    len) < 0)
		return SSH_ERR_LIBCRYPTO_ERROR;
	if (authlen) {
		/* compute tag (on encrypt) or verify tag (on decrypt) */
		if (EVP_Cipher(cc->evp, NULL, NULL, 0) < 0)
			return cc->encrypt ?
			    SSH_ERR_LIBCRYPTO_ERROR : SSH_ERR_MAC_INVALID;
		if (cc->encrypt &&
		    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_GET_TAG,
		    authlen, dest + aadlen + len))
			return SSH_ERR_LIBCRYPTO_ERROR;
	}
	return 0;
#endif
}

/* Extract the packet length, including any decryption necessary beforehand */
int
cipher_get_length(struct sshcipher_ctx *cc, u_int *plenp, u_int seqnr,
    const u_char *cp, u_int len)
{
	if ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)
		return chachapoly_get_length(&cc->cp_ctx, plenp, seqnr,
		    cp, len);
	if (len < 4)
		return SSH_ERR_MESSAGE_INCOMPLETE;
	*plenp = get_u32(cp);
	return 0;
}

void
cipher_free(struct sshcipher_ctx *cc)
{
	if (cc == NULL)
		return;
	if ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)
		explicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));
	else if ((cc->cipher->flags & CFLAG_AESCTR) != 0)
		explicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));
#ifdef WITH_OPENSSL
	if (cc->evp != NULL) {
		EVP_CIPHER_CTX_free(cc->evp);
		cc->evp = NULL;
	}
#endif
	explicit_bzero(cc, sizeof(*cc));
	free(cc);
}

/*
 * Selects the cipher, and keys if by computing the MD5 checksum of the
 * passphrase and using the resulting 16 bytes as the key.
 */
int
cipher_set_key_string(struct sshcipher_ctx **ccp,
    const struct sshcipher *cipher, const char *passphrase, int do_encrypt)
{
	u_char digest[16];
	int r = SSH_ERR_INTERNAL_ERROR;

	if ((r = ssh_digest_memory(SSH_DIGEST_MD5,
	    passphrase, strlen(passphrase),
	    digest, sizeof(digest))) != 0)
		goto out;

	r = cipher_init(ccp, cipher, digest, 16, NULL, 0, do_encrypt);
 out:
	explicit_bzero(digest, sizeof(digest));
	return r;
}

/*
 * Exports an IV from the sshcipher_ctx required to export the key
 * state back from the unprivileged child to the privileged parent
 * process.
 */
int
cipher_get_keyiv_len(const struct sshcipher_ctx *cc)
{
	const struct sshcipher *c = cc->cipher;
	int ivlen = 0;

	if (c->number == SSH_CIPHER_3DES)
		ivlen = 24;
	else if ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)
		ivlen = 0;
	else if ((cc->cipher->flags & CFLAG_AESCTR) != 0)
		ivlen = sizeof(cc->ac_ctx.ctr);
#ifdef WITH_OPENSSL
	else
		ivlen = EVP_CIPHER_CTX_iv_length(cc->evp);
#endif /* WITH_OPENSSL */
	return (ivlen);
}

int
cipher_get_keyiv(struct sshcipher_ctx *cc, u_char *iv, u_int len)
{
	const struct sshcipher *c = cc->cipher;
#ifdef WITH_OPENSSL
 	int evplen;
#endif

	if ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {
		if (len != 0)
			return SSH_ERR_INVALID_ARGUMENT;
		return 0;
	}
	if ((cc->cipher->flags & CFLAG_AESCTR) != 0) {
		if (len != sizeof(cc->ac_ctx.ctr))
			return SSH_ERR_INVALID_ARGUMENT;
		memcpy(iv, cc->ac_ctx.ctr, len);
		return 0;
	}
	if ((cc->cipher->flags & CFLAG_NONE) != 0)
		return 0;

	switch (c->number) {
#ifdef WITH_OPENSSL
	case SSH_CIPHER_SSH2:
	case SSH_CIPHER_DES:
	case SSH_CIPHER_BLOWFISH:
		evplen = EVP_CIPHER_CTX_iv_length(cc->evp);
		if (evplen == 0)
			return 0;
		else if (evplen < 0)
			return SSH_ERR_LIBCRYPTO_ERROR;
		if ((u_int)evplen != len)
			return SSH_ERR_INVALID_ARGUMENT;
		if (cipher_authlen(c)) {
			if (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,
			   len, iv))
			       return SSH_ERR_LIBCRYPTO_ERROR;
		} else
			memcpy(iv, cc->evp->iv, len);
		break;
#endif
#ifdef WITH_SSH1
	case SSH_CIPHER_3DES:
		return ssh1_3des_iv(cc->evp, 0, iv, 24);
#endif
	default:
		return SSH_ERR_INVALID_ARGUMENT;
	}
	return 0;
}

int
cipher_set_keyiv(struct sshcipher_ctx *cc, const u_char *iv)
{
	const struct sshcipher *c = cc->cipher;
#ifdef WITH_OPENSSL
 	int evplen = 0;
#endif

	if ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)
		return 0;
	if ((cc->cipher->flags & CFLAG_NONE) != 0)
		return 0;

	switch (c->number) {
#ifdef WITH_OPENSSL
	case SSH_CIPHER_SSH2:
	case SSH_CIPHER_DES:
	case SSH_CIPHER_BLOWFISH:
		evplen = EVP_CIPHER_CTX_iv_length(cc->evp);
		if (evplen <= 0)
			return SSH_ERR_LIBCRYPTO_ERROR;
		if (cipher_authlen(c)) {
			/* XXX iv arg is const, but EVP_CIPHER_CTX_ctrl isn't */
			if (!EVP_CIPHER_CTX_ctrl(cc->evp,
			    EVP_CTRL_GCM_SET_IV_FIXED, -1, (void *)iv))
				return SSH_ERR_LIBCRYPTO_ERROR;
		} else
			memcpy(cc->evp->iv, iv, evplen);
		break;
#endif
#ifdef WITH_SSH1
	case SSH_CIPHER_3DES:
		return ssh1_3des_iv(cc->evp, 1, (u_char *)iv, 24);
#endif
	default:
		return SSH_ERR_INVALID_ARGUMENT;
	}
	return 0;
}

#ifdef WITH_OPENSSL
#define EVP_X_STATE(evp)	(evp)->cipher_data
#define EVP_X_STATE_LEN(evp)	(evp)->cipher->ctx_size
#endif

int
cipher_get_keycontext(const struct sshcipher_ctx *cc, u_char *dat)
{
#ifdef WITH_OPENSSL
	const struct sshcipher *c = cc->cipher;
	int plen = 0;

	if (c->evptype == EVP_rc4) {
		plen = EVP_X_STATE_LEN(cc->evp);
		if (dat == NULL)
			return (plen);
		memcpy(dat, EVP_X_STATE(cc->evp), plen);
	}
	return (plen);
#else
	return 0;
#endif
}

void
cipher_set_keycontext(struct sshcipher_ctx *cc, const u_char *dat)
{
#ifdef WITH_OPENSSL
	const struct sshcipher *c = cc->cipher;
	int plen;

	if (c->evptype == EVP_rc4) {
		plen = EVP_X_STATE_LEN(cc->evp);
		memcpy(EVP_X_STATE(cc->evp), dat, plen);
	}
#endif
}
@


1.101
log
@Remove NULL-checks before free().

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.100 2015/01/14 10:29:45 djm Exp $ */
d56 9
d204 12
d307 1
a307 1
cipher_init(struct sshcipher_ctx *cc, const struct sshcipher *cipher,
d311 2
a313 1
	int ret = SSH_ERR_INTERNAL_ERROR;
d317 5
d327 1
a327 1
#endif
d332 4
a335 2
	    (iv != NULL && ivlen < cipher_ivlen(cipher)))
		return SSH_ERR_INVALID_ARGUMENT;
d339 2
a340 1
		return chachapoly_init(&cc->cp_ctx, key, keylen);
d346 6
a351 1
		return 0;
d353 3
a355 4
	if ((cc->cipher->flags & CFLAG_NONE) != 0)
		return 0;
	return SSH_ERR_INVALID_ARGUMENT;
#else
d357 5
a361 2
	EVP_CIPHER_CTX_init(&cc->evp);
	if (EVP_CipherInit(&cc->evp, type, NULL, (u_char *)iv,
d364 1
a364 1
		goto bad;
d367 1
a367 1
	    !EVP_CIPHER_CTX_ctrl(&cc->evp, EVP_CTRL_GCM_SET_IV_FIXED,
d370 1
a370 1
		goto bad;
d372 1
a372 1
	klen = EVP_CIPHER_CTX_key_length(&cc->evp);
d374 1
a374 1
		if (EVP_CIPHER_CTX_set_key_length(&cc->evp, keylen) == 0) {
d376 1
a376 1
			goto bad;
d379 1
a379 1
	if (EVP_CipherInit(&cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {
d381 1
a381 1
		goto bad;
d389 1
a389 1
			goto bad;
d391 1
a391 1
		ret = EVP_Cipher(&cc->evp, discard, junk, cipher->discard_len);
d397 17
a413 3
 bad:
			EVP_CIPHER_CTX_cleanup(&cc->evp);
			return ret;
d416 1
a416 2
#endif
	return 0;
d457 1
a457 1
		if (!EVP_CIPHER_CTX_ctrl(&cc->evp, EVP_CTRL_GCM_IV_GEN,
d462 1
a462 1
		    !EVP_CIPHER_CTX_ctrl(&cc->evp, EVP_CTRL_GCM_SET_TAG,
d468 1
a468 1
		    EVP_Cipher(&cc->evp, NULL, (u_char *)src, aadlen) < 0)
d474 1
a474 1
	if (EVP_Cipher(&cc->evp, dest + aadlen, (u_char *)src + aadlen,
d479 1
a479 1
		if (EVP_Cipher(&cc->evp, NULL, NULL, 0) < 0)
d483 1
a483 1
		    !EVP_CIPHER_CTX_ctrl(&cc->evp, EVP_CTRL_GCM_GET_TAG,
d505 2
a506 2
int
cipher_cleanup(struct sshcipher_ctx *cc)
d508 2
a509 2
	if (cc == NULL || cc->cipher == NULL)
		return 0;
d515 4
a518 2
	else if (EVP_CIPHER_CTX_cleanup(&cc->evp) == 0)
		return SSH_ERR_LIBCRYPTO_ERROR;
d520 2
a521 1
	return 0;
d529 2
a530 2
cipher_set_key_string(struct sshcipher_ctx *cc, const struct sshcipher *cipher,
    const char *passphrase, int do_encrypt)
d540 1
a540 1
	r = cipher_init(cc, cipher, digest, 16, NULL, 0, do_encrypt);
d565 1
a565 1
		ivlen = EVP_CIPHER_CTX_iv_length(&cc->evp);
d597 1
a597 1
		evplen = EVP_CIPHER_CTX_iv_length(&cc->evp);
d605 1
a605 1
			if (!EVP_CIPHER_CTX_ctrl(&cc->evp, EVP_CTRL_GCM_IV_GEN,
d609 1
a609 1
			memcpy(iv, cc->evp.iv, len);
d614 1
a614 1
		return ssh1_3des_iv(&cc->evp, 0, iv, 24);
d640 1
a640 1
		evplen = EVP_CIPHER_CTX_iv_length(&cc->evp);
d645 1
a645 1
			if (!EVP_CIPHER_CTX_ctrl(&cc->evp,
d649 1
a649 1
			memcpy(cc->evp.iv, iv, evplen);
d654 1
a654 1
		return ssh1_3des_iv(&cc->evp, 1, (u_char *)iv, 24);
d663 2
a664 2
#define EVP_X_STATE(evp)	(evp).cipher_data
#define EVP_X_STATE_LEN(evp)	(evp).cipher->ctx_size
@


1.100
log
@make non-OpenSSL aes-ctr work on sshd w/ privsep; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.99 2014/06/24 01:13:21 djm Exp $ */
d350 1
a350 2
			if (junk != NULL)
				free(junk);
@


1.99
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.98 2014/04/29 18:01:49 markus Exp $ */
d509 2
d529 6
@


1.98
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.97 2014/02/07 06:55:54 djm Exp $ */
d44 1
a44 2
#include "xmalloc.h"
#include "log.h"
d46 2
a47 2
#include "cipher.h"
#include "buffer.h"
d53 1
a53 1
extern void ssh1_3des_iv(EVP_CIPHER_CTX *, int, u_char *, int);
d56 1
a56 1
struct Cipher {
d76 1
a76 1
static const struct Cipher ciphers[] = {
d118 1
a118 1
/* Returns a list of supported ciphers separated by the specified char. */
d122 1
a122 1
	char *ret = NULL;
d124 1
a124 1
	const Cipher *c;
d134 5
a138 1
		ret = xrealloc(ret, 1, rlen + nlen + 2);
d146 1
a146 1
cipher_blocksize(const Cipher *c)
d152 1
a152 1
cipher_keylen(const Cipher *c)
d158 1
a158 1
cipher_seclen(const Cipher *c)
d166 1
a166 1
cipher_authlen(const Cipher *c)
d172 1
a172 1
cipher_ivlen(const Cipher *c)
d183 1
a183 1
cipher_get_number(const Cipher *c)
d189 1
a189 1
cipher_is_cbc(const Cipher *c)
d206 1
a206 1
const Cipher *
d209 1
a209 1
	const Cipher *c;
d216 1
a216 1
const Cipher *
d219 1
a219 1
	const Cipher *c;
d230 1
a230 1
	const Cipher *c;
d236 2
a237 1
	cipher_list = cp = xstrdup(names);
a241 1
			debug("bad cipher %s [%s]", p, names);
a245 1
	debug3("ciphers ok: [%s]", names);
d258 1
a258 1
	const Cipher *c;
d270 1
a270 1
	const Cipher *c = cipher_by_number(id);
d274 13
a286 2
void
cipher_init(CipherContext *cc, const Cipher *cipher,
d291 1
a291 1
	static int dowarn = 1;
a296 5
		if (dowarn) {
			error("Warning: use of DES is strongly discouraged "
			    "due to cryptographic weaknesses");
			dowarn = 0;
		}
d304 4
a307 6
	if (keylen < cipher->key_len)
		fatal("cipher_init: key length %d is insufficient for %s.",
		    keylen, cipher->name);
	if (iv != NULL && ivlen < cipher_ivlen(cipher))
		fatal("cipher_init: iv length %d is insufficient for %s.",
		    ivlen, cipher->name);
a308 1

d310 1
a310 2
		chachapoly_init(&cc->cp_ctx, key, keylen);
		return;
d316 1
a316 1
		return;
d319 2
a320 2
		return;
	fatal("unsupported cipher");
d325 4
a328 3
	    (do_encrypt == CIPHER_ENCRYPT)) == 0)
		fatal("cipher_init: EVP_CipherInit failed for %s",
		    cipher->name);
d331 4
a334 3
	    -1, (u_char *)iv))
		fatal("cipher_init: EVP_CTRL_GCM_SET_IV_FIXED failed for %s",
		    cipher->name);
d337 9
a345 8
		debug2("cipher_init: set keylen (%d -> %d)", klen, keylen);
		if (EVP_CIPHER_CTX_set_key_length(&cc->evp, keylen) == 0)
			fatal("cipher_init: set keylen failed (%d -> %d)",
			    klen, keylen);
	}
	if (EVP_CipherInit(&cc->evp, NULL, (u_char *)key, NULL, -1) == 0)
		fatal("cipher_init: EVP_CipherInit: set key failed for %s",
		    cipher->name);
d348 8
a355 5
		junk = xmalloc(cipher->discard_len);
		discard = xmalloc(cipher->discard_len);
		if (EVP_Cipher(&cc->evp, discard, junk,
		    cipher->discard_len) == 0)
			fatal("evp_crypt: EVP_Cipher failed during discard");
d359 6
d367 1
a378 2
 * cipher_crypt() returns 0 on success and -1 if the decryption integrity
 * check fails.
d381 2
a382 2
cipher_crypt(CipherContext *cc, u_int seqnr, u_char *dest, const u_char *src,
    u_int len, u_int aadlen, u_int authlen)
d384 4
a387 3
	if ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)
		return chachapoly_crypt(&cc->cp_ctx, seqnr, dest, src, len,
		    aadlen, authlen, cc->encrypt);
d400 1
a400 1
	fatal("unsupported cipher");
d406 1
a406 1
			fatal("%s: authlen mismatch %d", __func__, authlen);
d410 1
a410 1
			fatal("%s: EVP_CTRL_GCM_IV_GEN", __func__);
d415 1
a415 1
			fatal("%s: EVP_CTRL_GCM_SET_TAG", __func__);
d420 1
a420 1
			fatal("%s: EVP_Cipher(aad) failed", __func__);
d424 1
a424 1
		fatal("%s: bad plaintext length %d", __func__, len);
d427 1
a427 1
		fatal("%s: EVP_Cipher failed", __func__);
d430 3
a432 6
		if (EVP_Cipher(&cc->evp, NULL, NULL, 0) < 0) {
			if (cc->encrypt)
				fatal("%s: EVP_Cipher(final) failed", __func__);
			else
				return -1;
		}
d436 1
a436 1
			fatal("%s: EVP_CTRL_GCM_GET_TAG", __func__);
d444 1
a444 1
cipher_get_length(CipherContext *cc, u_int *plenp, u_int seqnr,
d451 1
a451 1
		return -1;
d456 2
a457 2
void
cipher_cleanup(CipherContext *cc)
d459 2
d467 1
a467 1
		error("cipher_cleanup: EVP_CIPHER_CTX_cleanup failed");
d469 1
d476 2
a477 3

void
cipher_set_key_string(CipherContext *cc, const Cipher *cipher,
d481 1
d483 4
a486 5
	if (ssh_digest_memory(SSH_DIGEST_MD5, passphrase, strlen(passphrase),
	    digest, sizeof(digest)) < 0)
		fatal("%s: md5 failed", __func__);

	cipher_init(cc, cipher, digest, 16, NULL, 0, do_encrypt);
d488 2
d491 1
d495 1
a495 1
 * Exports an IV from the CipherContext required to export the key
a498 1

d500 1
a500 1
cipher_get_keyiv_len(const CipherContext *cc)
d502 1
a502 1
	const Cipher *c = cc->cipher;
d512 1
a512 1
#endif
d516 2
a517 2
void
cipher_get_keyiv(CipherContext *cc, u_char *iv, u_int len)
d519 1
a519 1
	const Cipher *c = cc->cipher;
d521 1
a521 1
	int evplen;
d526 2
a527 2
			fatal("%s: wrong iv length %d != %d", __func__, len, 0);
		return;
d530 1
a530 1
		return;
d538 4
a541 2
		if (evplen <= 0)
			return;
d543 1
a543 2
			fatal("%s: wrong iv length %d != %d", __func__,
			    evplen, len);
d547 1
a547 1
			       fatal("%s: EVP_CTRL_GCM_IV_GEN", __func__);
d554 1
a554 2
		ssh1_3des_iv(&cc->evp, 0, iv, 24);
		break;
d557 1
a557 1
		fatal("%s: bad cipher %d", __func__, c->number);
d559 1
d562 2
a563 2
void
cipher_set_keyiv(CipherContext *cc, u_char *iv)
d565 1
a565 1
	const Cipher *c = cc->cipher;
d567 1
a567 1
	int evplen = 0;
d571 1
a571 1
		return;
d573 1
a573 1
		return;
d581 2
a582 2
		if (evplen == 0)
			return;
d584 1
d586 2
a587 3
			    EVP_CTRL_GCM_SET_IV_FIXED, -1, iv))
				fatal("%s: EVP_CTRL_GCM_SET_IV_FIXED failed",
				    __func__);
d594 1
a594 2
		ssh1_3des_iv(&cc->evp, 1, iv, 24);
		break;
d597 1
a597 1
		fatal("%s: bad cipher %d", __func__, c->number);
d599 1
d608 1
a608 1
cipher_get_keycontext(const CipherContext *cc, u_char *dat)
d611 1
a611 1
	const Cipher *c = cc->cipher;
d622 1
a622 1
	return (0);
d627 1
a627 1
cipher_set_keycontext(CipherContext *cc, u_char *dat)
d630 1
a630 1
	const Cipher *c = cc->cipher;
@


1.97
log
@remove some logging that makes ssh debugging output very verbose;
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.96 2014/02/02 03:44:31 djm Exp $ */
d51 1
d55 1
d68 3
d72 3
d78 1
a78 1
	{ "none",	SSH_CIPHER_NONE, 8, 0, 0, 0, 0, 0, EVP_enc_null },
d82 3
a84 1

d105 6
d277 1
d292 1
d308 10
d350 1
d372 14
d426 1
d448 3
d453 1
d486 1
a486 1
	int ivlen;
d492 1
d495 1
d503 1
d505 1
d512 2
d516 1
d533 2
d538 1
d548 1
d550 1
d554 2
d558 1
d573 2
d578 1
d584 1
d587 1
d592 1
d603 3
d611 1
d619 1
@


1.96
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.95 2014/01/27 19:18:54 markus Exp $ */
a224 2
		} else {
			debug3("cipher ok: %s [%s]", p, names);
@


1.95
log
@replace openssl MD5 with our ssh_digest_*; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.94 2014/01/25 10:12:50 dtucker Exp $ */
d320 1
a320 1
		memset(discard, 0, cipher->discard_len);
d405 1
a405 1
		memset(&cc->cp_ctx, 0, sizeof(cc->cp_ctx));
d427 1
a427 1
	memset(digest, 0, sizeof(digest));
@


1.94
log
@Add a special case for the DH group size for 3des-cbc, which has an
effective strength much lower than the key size.  This causes problems
with some cryptlib implementations, which don't support group sizes larger
than 4k but also don't use the largest group size it does support as
specified in the RFC.  Based on a patch from Petr Lautrbach at Redhat,
reduced by me with input from Markus.  ok djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.93 2013/12/06 13:34:54 markus Exp $ */
a39 2
#include <openssl/md5.h>

d48 2
a418 1
	MD5_CTX md;
d421 3
a423 3
	MD5_Init(&md);
	MD5_Update(&md, (const u_char *)passphrase, strlen(passphrase));
	MD5_Final(digest, &md);
a427 1
	memset(&md, 0, sizeof(md));
@


1.93
log
@new private key format, bcrypt as KDF by default; details in PROTOCOL.key;
feedback and lots help from djm; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.92 2013/12/02 03:13:14 djm Exp $ */
d136 8
@


1.92
log
@correct bzero of chacha20+poly1305 key context. bz#2177 from
Loganaden Velvindron @@ AfriNIC

Also make it a memset for consistency with the rest of cipher.c
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.91 2013/11/21 00:45:44 djm Exp $ */
d327 2
d330 1
a330 1
void
d334 3
a336 6
	if ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {
		if (chachapoly_crypt(&cc->cp_ctx, seqnr, dest, src, len, aadlen,
		    authlen, cc->encrypt) != 0)
			fatal("Decryption integrity check failed");
		return;
	}
d369 1
a369 1
				fatal("Decryption integrity check failed");
d376 1
@


1.91
log
@Add a new protocol 2 transport cipher "chacha20-poly1305@@openssh.com"
that combines Daniel Bernstein's ChaCha20 stream cipher and Poly1305 MAC
to build an authenticated encryption mode.

Inspired by and similar to Adam Langley's proposal for TLS:
http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03
but differs in layout used for the MAC calculation and the use of a
second ChaCha20 instance to separately encrypt packet lengths.
Details are in the PROTOCOL.chacha20poly1305 file.

Feedback markus@@, naddy@@; manpage bits Loganden Velvindron @@ AfriNIC
ok markus@@ naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.90 2013/11/07 11:58:27 dtucker Exp $ */
d397 1
a397 1
		bzero(&cc->cp_ctx, sizeof(&cc->cp_ctx));
@


1.90
log
@Output the effective values of Ciphers, MACs and KexAlgorithms when
the default has not been overridden.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.89 2013/05/17 00:13:13 djm Exp $ */
d44 1
d48 1
d63 3
a65 1
	u_int	cbc_mode;
d95 2
d105 1
a105 1
cipher_alg_list(char sep)
d114 2
d147 6
a152 1
	return (c->iv_len ? c->iv_len : c->block_size);
d164 1
a164 1
	return (c->cbc_mode);
d280 4
a284 1

d329 1
a329 1
cipher_crypt(CipherContext *cc, u_char *dest, const u_char *src,
d332 6
d379 14
d396 3
a398 1
	if (EVP_CIPHER_CTX_cleanup(&cc->evp) == 0)
d438 2
d451 6
d487 3
@


1.89
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.88 2013/04/19 01:06:50 djm Exp $ */
d97 1
a97 1
/* Returns a comma-separated list of supported ciphers. */
d99 1
a99 1
cipher_alg_list(void)
d109 1
a109 1
			ret[rlen++] = '\n';
@


1.88
log
@add the ability to query supported ciphers, MACs, key type and KEX
algorithms to ssh. Includes some refactoring of KEX and key type handling
to be table-driven; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.87 2013/01/26 06:11:05 djm Exp $ */
d202 1
a202 1
			xfree(cipher_list);
d209 1
a209 1
	xfree(cipher_list);
d297 2
a298 2
		xfree(junk);
		xfree(discard);
@


1.87
log
@remove ACSS, now that it is gone from libcrypto too
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.86 2013/01/12 11:22:04 djm Exp $ */
d63 3
a65 1
} ciphers[] = {
d97 21
d166 1
a166 1
Cipher *
d169 1
a169 1
	Cipher *c;
d176 1
a176 1
Cipher *
d179 1
a179 1
	Cipher *c;
d190 1
a190 1
	Cipher *c;
d221 1
a221 1
	Cipher *c;
d233 1
a233 1
	Cipher *c = cipher_by_number(id);
d238 1
a238 1
cipher_init(CipherContext *cc, Cipher *cipher,
d370 1
a370 1
cipher_set_key_string(CipherContext *cc, Cipher *cipher,
d395 1
a395 1
	Cipher *c = cc->cipher;
d408 1
a408 1
	Cipher *c = cc->cipher;
d439 1
a439 1
	Cipher *c = cc->cipher;
d471 1
a471 1
	Cipher *c = cc->cipher;
d486 1
a486 1
	Cipher *c = cc->cipher;
@


1.86
log
@improve error message for integrity failure in AES-GCM modes; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.85 2013/01/08 18:49:04 markus Exp $ */
a84 2
	{ "acss@@openssh.org",
			SSH_CIPHER_SSH2, 16, 5, 0, 0, 0, 0, EVP_acss },
d451 1
a451 1
	if (c->evptype == EVP_rc4 || c->evptype == EVP_acss) {
d466 1
a466 1
	if (c->evptype == EVP_rc4 || c->evptype == EVP_acss) {
@


1.85
log
@support AES-GCM as defined in RFC 5647 (but with simpler KEX handling)
ok and feedback djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.84 2012/12/12 16:46:10 naddy Exp $ */
d323 6
a328 2
		if (EVP_Cipher(&cc->evp, NULL, NULL, 0) < 0)
			fatal("%s: EVP_Cipher(finish) failed", __func__);
@


1.84
log
@use OpenSSL's EVP_aes_{128,192,256}_ctr() API and remove our hand-rolled
counter mode code; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.83 2012/12/11 22:31:18 markus Exp $ */
d58 2
d64 16
a79 14
	{ "none",		SSH_CIPHER_NONE, 8, 0, 0, 0, EVP_enc_null },
	{ "des",		SSH_CIPHER_DES, 8, 8, 0, 1, EVP_des_cbc },
	{ "3des",		SSH_CIPHER_3DES, 8, 16, 0, 1, evp_ssh1_3des },
	{ "blowfish",		SSH_CIPHER_BLOWFISH, 8, 32, 0, 1, evp_ssh1_bf },

	{ "3des-cbc",		SSH_CIPHER_SSH2, 8, 24, 0, 1, EVP_des_ede3_cbc },
	{ "blowfish-cbc",	SSH_CIPHER_SSH2, 8, 16, 0, 1, EVP_bf_cbc },
	{ "cast128-cbc",	SSH_CIPHER_SSH2, 8, 16, 0, 1, EVP_cast5_cbc },
	{ "arcfour",		SSH_CIPHER_SSH2, 8, 16, 0, 0, EVP_rc4 },
	{ "arcfour128",		SSH_CIPHER_SSH2, 8, 16, 1536, 0, EVP_rc4 },
	{ "arcfour256",		SSH_CIPHER_SSH2, 8, 32, 1536, 0, EVP_rc4 },
	{ "aes128-cbc",		SSH_CIPHER_SSH2, 16, 16, 0, 1, EVP_aes_128_cbc },
	{ "aes192-cbc",		SSH_CIPHER_SSH2, 16, 24, 0, 1, EVP_aes_192_cbc },
	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, 0, 1, EVP_aes_256_cbc },
d81 10
a90 5
				SSH_CIPHER_SSH2, 16, 32, 0, 1, EVP_aes_256_cbc },
	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, 0, 0, EVP_aes_128_ctr },
	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, 0, 0, EVP_aes_192_ctr },
	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, 0, 0, EVP_aes_256_ctr },
	{ "acss@@openssh.org",	SSH_CIPHER_SSH2, 16, 5, 0, 0, EVP_acss },
d92 1
a92 1
	{ NULL,			SSH_CIPHER_INVALID, 0, 0, 0, 0, NULL }
d110 12
d236 1
d241 1
a241 1
	if (iv != NULL && ivlen < cipher->block_size)
d253 5
d287 2
d293 1
a293 1
    u_int len, u_int aadlen)
d295 19
a313 1
	if (aadlen)
d315 1
d321 9
d396 6
a401 1
		memcpy(iv, cc->evp.iv, len);
d424 7
a430 1
		memcpy(cc->evp.iv, iv, evplen);
@


1.83
log
@add encrypt-then-mac (EtM) modes to openssh by defining new mac algorithms
that change the packet format and compute the MAC over the encrypted
message (including the packet size) instead of the plaintext data;
these EtM modes are considered more secure and used by default.
feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.82 2009/01/26 09:58:15 markus Exp $ */
a51 2
extern const EVP_CIPHER *evp_aes_128_ctr(void);
extern void ssh_aes_ctr_iv(EVP_CIPHER_CTX *, int, u_char *, u_int);
d78 3
a80 3
	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, 0, 0, evp_aes_128_ctr },
	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, 0, 0, evp_aes_128_ctr },
	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, 0, 0, evp_aes_128_ctr },
d339 1
a339 4
		if (c->evptype == evp_aes_128_ctr)
			ssh_aes_ctr_iv(&cc->evp, 0, iv, len);
		else
			memcpy(iv, cc->evp.iv, len);
d362 1
a362 4
		if (c->evptype == evp_aes_128_ctr)
			ssh_aes_ctr_iv(&cc->evp, 1, iv, evplen);
		else
			memcpy(cc->evp.iv, iv, evplen);
@


1.82
log
@Work around the CPNI-957037 Plaintext Recovery Attack by always
reading 256K of data on packet size or HMAC errors (in CBC mode only).
Help, feedback and ok djm@@
Feedback from Martin Albrecht and Paterson Kenny
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.81 2006/08/03 03:34:42 deraadt Exp $ */
d256 8
d265 2
a266 1
cipher_crypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
d268 2
d271 4
a274 3
		fatal("cipher_encrypt: bad plaintext length %d", len);
	if (EVP_Cipher(&cc->evp, dest, (u_char *)src, len) == 0)
		fatal("evp_crypt: EVP_Cipher failed");
@


1.81
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.80 2006/07/22 20:48:22 stevesk Exp $ */
d61 1
d64 14
a77 14
	{ "none",		SSH_CIPHER_NONE, 8, 0, 0, EVP_enc_null },
	{ "des",		SSH_CIPHER_DES, 8, 8, 0, EVP_des_cbc },
	{ "3des",		SSH_CIPHER_3DES, 8, 16, 0, evp_ssh1_3des },
	{ "blowfish",		SSH_CIPHER_BLOWFISH, 8, 32, 0, evp_ssh1_bf },

	{ "3des-cbc",		SSH_CIPHER_SSH2, 8, 24, 0, EVP_des_ede3_cbc },
	{ "blowfish-cbc",	SSH_CIPHER_SSH2, 8, 16, 0, EVP_bf_cbc },
	{ "cast128-cbc",	SSH_CIPHER_SSH2, 8, 16, 0, EVP_cast5_cbc },
	{ "arcfour",		SSH_CIPHER_SSH2, 8, 16, 0, EVP_rc4 },
	{ "arcfour128",		SSH_CIPHER_SSH2, 8, 16, 1536, EVP_rc4 },
	{ "arcfour256",		SSH_CIPHER_SSH2, 8, 32, 1536, EVP_rc4 },
	{ "aes128-cbc",		SSH_CIPHER_SSH2, 16, 16, 0, EVP_aes_128_cbc },
	{ "aes192-cbc",		SSH_CIPHER_SSH2, 16, 24, 0, EVP_aes_192_cbc },
	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, 0, EVP_aes_256_cbc },
d79 5
a83 5
				SSH_CIPHER_SSH2, 16, 32, 0, EVP_aes_256_cbc },
	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, 0, evp_aes_128_ctr },
	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, 0, evp_aes_128_ctr },
	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, 0, evp_aes_128_ctr },
	{ "acss@@openssh.org",	SSH_CIPHER_SSH2, 16, 5, 0, EVP_acss },
d85 1
a85 1
	{ NULL,			SSH_CIPHER_INVALID, 0, 0, 0, NULL }
d106 6
@


1.80
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: cipher.c,v 1.79 2006/03/25 13:17:01 djm Exp $ */
d38 1
a38 1
#include "includes.h"
d43 1
@


1.79
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d40 4
a46 2

#include <openssl/md5.h>
@


1.78
log
@RCSID() can die
@
text
@d1 1
@


1.77
log
@spacing
@
text
@a37 1
RCSID("$OpenBSD: cipher.c,v 1.76 2005/06/17 02:44:32 djm Exp $");
@


1.77.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: cipher.c,v 1.81 2006/08/03 03:34:42 deraadt Exp $ */
d37 2
a38 6
#include <sys/types.h>

#include <openssl/md5.h>

#include <string.h>
#include <stdarg.h>
d43 2
@


1.77.4.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: cipher.c,v 1.81 2006/08/03 03:34:42 deraadt Exp $ */
d37 2
a38 6
#include <sys/types.h>

#include <openssl/md5.h>

#include <string.h>
#include <stdarg.h>
d43 2
@


1.76
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.75 2005/06/09 13:43:49 dtucker Exp $");
d234 1
a234 1
	if (cipher->discard_len > 0) {		
@


1.75
log
@Correctly initialize end of array sentinel; ok djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.74 2005/05/23 23:32:46 djm Exp $");
d224 1
a224 1
	if (klen > 0 && keylen != klen) {
d314 1
a314 1
		if (evplen == 0)
d316 1
a316 1
		if (evplen != len)
@


1.74
log
@add support for draft-harris-ssh-arcfour-fixes-02 improved arcfour modes;
ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.73 2005/01/23 10:18:12 djm Exp $");
d81 1
a81 1
	{ NULL,			SSH_CIPHER_INVALID, 0, 0, NULL }
@


1.73
log
@config option "Ciphers" should be case-sensitive; ok dtucker@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.72 2004/12/22 02:13:19 djm Exp $");
d57 1
d60 14
a73 12
	{ "none",		SSH_CIPHER_NONE, 8, 0, EVP_enc_null },
	{ "des",		SSH_CIPHER_DES, 8, 8, EVP_des_cbc },
	{ "3des",		SSH_CIPHER_3DES, 8, 16, evp_ssh1_3des },
	{ "blowfish",		SSH_CIPHER_BLOWFISH, 8, 32, evp_ssh1_bf },

	{ "3des-cbc",		SSH_CIPHER_SSH2, 8, 24, EVP_des_ede3_cbc },
	{ "blowfish-cbc",	SSH_CIPHER_SSH2, 8, 16, EVP_bf_cbc },
	{ "cast128-cbc",	SSH_CIPHER_SSH2, 8, 16, EVP_cast5_cbc },
	{ "arcfour",		SSH_CIPHER_SSH2, 8, 16, EVP_rc4 },
	{ "aes128-cbc",		SSH_CIPHER_SSH2, 16, 16, EVP_aes_128_cbc },
	{ "aes192-cbc",		SSH_CIPHER_SSH2, 16, 24, EVP_aes_192_cbc },
	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, EVP_aes_256_cbc },
d75 5
a79 5
				SSH_CIPHER_SSH2, 16, 32, EVP_aes_256_cbc },
	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, evp_aes_128_ctr },
	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, evp_aes_128_ctr },
	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, evp_aes_128_ctr },
	{ "acss@@openssh.org",	SSH_CIPHER_SSH2, 16, 5, EVP_acss },
d195 1
d233 11
@


1.73.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.77 2005/07/16 01:35:24 djm Exp $");
a56 1
	u_int	discard_len;
d59 12
a70 14
	{ "none",		SSH_CIPHER_NONE, 8, 0, 0, EVP_enc_null },
	{ "des",		SSH_CIPHER_DES, 8, 8, 0, EVP_des_cbc },
	{ "3des",		SSH_CIPHER_3DES, 8, 16, 0, evp_ssh1_3des },
	{ "blowfish",		SSH_CIPHER_BLOWFISH, 8, 32, 0, evp_ssh1_bf },

	{ "3des-cbc",		SSH_CIPHER_SSH2, 8, 24, 0, EVP_des_ede3_cbc },
	{ "blowfish-cbc",	SSH_CIPHER_SSH2, 8, 16, 0, EVP_bf_cbc },
	{ "cast128-cbc",	SSH_CIPHER_SSH2, 8, 16, 0, EVP_cast5_cbc },
	{ "arcfour",		SSH_CIPHER_SSH2, 8, 16, 0, EVP_rc4 },
	{ "arcfour128",		SSH_CIPHER_SSH2, 8, 16, 1536, EVP_rc4 },
	{ "arcfour256",		SSH_CIPHER_SSH2, 8, 32, 1536, EVP_rc4 },
	{ "aes128-cbc",		SSH_CIPHER_SSH2, 16, 16, 0, EVP_aes_128_cbc },
	{ "aes192-cbc",		SSH_CIPHER_SSH2, 16, 24, 0, EVP_aes_192_cbc },
	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, 0, EVP_aes_256_cbc },
d72 5
a76 5
				SSH_CIPHER_SSH2, 16, 32, 0, EVP_aes_256_cbc },
	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, 0, evp_aes_128_ctr },
	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, 0, evp_aes_128_ctr },
	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, 0, evp_aes_128_ctr },
	{ "acss@@openssh.org",	SSH_CIPHER_SSH2, 16, 5, 0, EVP_acss },
d78 1
a78 1
	{ NULL,			SSH_CIPHER_INVALID, 0, 0, 0, NULL }
a191 1
	u_char *junk, *discard;
d220 1
a220 1
	if (klen > 0 && keylen != (u_int)klen) {
a228 11

	if (cipher->discard_len > 0) {
		junk = xmalloc(cipher->discard_len);
		discard = xmalloc(cipher->discard_len);
		if (EVP_Cipher(&cc->evp, discard, junk,
		    cipher->discard_len) == 0)
			fatal("evp_crypt: EVP_Cipher failed during discard");
		memset(discard, 0, cipher->discard_len);
		xfree(junk);
		xfree(discard);
	}
d299 1
a299 1
		if (evplen <= 0)
d301 1
a301 1
		if ((u_int)evplen != len)
@


1.72
log
@remove fallback AES support for old OpenSSL, as OpenBSD has had it for many
years now; ok deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.71 2004/07/28 09:40:29 markus Exp $");
d118 1
a118 1
		if (strcasecmp(c->name, name) == 0)
d171 4
a174 2
	c = cipher_by_name(name);
	return (c==NULL) ? -1 : c->number;
@


1.71
log
@more s/illegal/invalid/
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.70 2004/07/11 17:48:47 deraadt Exp $");
a45 4
#if OPENSSL_VERSION_NUMBER < 0x00907000L
extern const EVP_CIPHER *evp_rijndael(void);
extern void ssh_rijndael_iv(EVP_CIPHER_CTX *, int, u_char *, u_int);
#endif
a67 7
#if OPENSSL_VERSION_NUMBER < 0x00907000L
	{ "aes128-cbc",		SSH_CIPHER_SSH2, 16, 16, evp_rijndael },
	{ "aes192-cbc",		SSH_CIPHER_SSH2, 16, 24, evp_rijndael },
	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, evp_rijndael },
	{ "rijndael-cbc@@lysator.liu.se",
				SSH_CIPHER_SSH2, 16, 32, evp_rijndael },
#else
a72 1
#endif
a301 5
#if OPENSSL_VERSION_NUMBER < 0x00907000L
		if (c->evptype == evp_rijndael)
			ssh_rijndael_iv(&cc->evp, 0, iv, len);
		else
#endif
a327 5
#if OPENSSL_VERSION_NUMBER < 0x00907000L
		if (c->evptype == evp_rijndael)
			ssh_rijndael_iv(&cc->evp, 1, iv, evplen);
		else
#endif
a340 4
#if OPENSSL_VERSION_NUMBER < 0x00907000L
#define EVP_X_STATE(evp)	&(evp).c
#define EVP_X_STATE_LEN(evp)	sizeof((evp).c)
#else
a342 1
#endif
@


1.71.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.73 2005/01/23 10:18:12 djm Exp $");
d46 4
d72 7
d84 1
d130 1
a130 1
		if (strcmp(c->name, name) == 0)
d183 2
a184 4
	for (c = ciphers; c->name != NULL; c++)
		if (strcasecmp(c->name, name) == 0)
			return c->number;
	return -1;
d314 5
d345 5
d363 4
d369 1
@


1.71.2.2
log
@upgrade to OpenSSH 4.2
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.77 2005/07/16 01:35:24 djm Exp $");
a56 1
	u_int	discard_len;
d59 12
a70 14
	{ "none",		SSH_CIPHER_NONE, 8, 0, 0, EVP_enc_null },
	{ "des",		SSH_CIPHER_DES, 8, 8, 0, EVP_des_cbc },
	{ "3des",		SSH_CIPHER_3DES, 8, 16, 0, evp_ssh1_3des },
	{ "blowfish",		SSH_CIPHER_BLOWFISH, 8, 32, 0, evp_ssh1_bf },

	{ "3des-cbc",		SSH_CIPHER_SSH2, 8, 24, 0, EVP_des_ede3_cbc },
	{ "blowfish-cbc",	SSH_CIPHER_SSH2, 8, 16, 0, EVP_bf_cbc },
	{ "cast128-cbc",	SSH_CIPHER_SSH2, 8, 16, 0, EVP_cast5_cbc },
	{ "arcfour",		SSH_CIPHER_SSH2, 8, 16, 0, EVP_rc4 },
	{ "arcfour128",		SSH_CIPHER_SSH2, 8, 16, 1536, EVP_rc4 },
	{ "arcfour256",		SSH_CIPHER_SSH2, 8, 32, 1536, EVP_rc4 },
	{ "aes128-cbc",		SSH_CIPHER_SSH2, 16, 16, 0, EVP_aes_128_cbc },
	{ "aes192-cbc",		SSH_CIPHER_SSH2, 16, 24, 0, EVP_aes_192_cbc },
	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, 0, EVP_aes_256_cbc },
d72 5
a76 5
				SSH_CIPHER_SSH2, 16, 32, 0, EVP_aes_256_cbc },
	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, 0, evp_aes_128_ctr },
	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, 0, evp_aes_128_ctr },
	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, 0, evp_aes_128_ctr },
	{ "acss@@openssh.org",	SSH_CIPHER_SSH2, 16, 5, 0, EVP_acss },
d78 1
a78 1
	{ NULL,			SSH_CIPHER_INVALID, 0, 0, 0, NULL }
a191 1
	u_char *junk, *discard;
d220 1
a220 1
	if (klen > 0 && keylen != (u_int)klen) {
a228 11

	if (cipher->discard_len > 0) {
		junk = xmalloc(cipher->discard_len);
		discard = xmalloc(cipher->discard_len);
		if (EVP_Cipher(&cc->evp, discard, junk,
		    cipher->discard_len) == 0)
			fatal("evp_crypt: EVP_Cipher failed during discard");
		memset(discard, 0, cipher->discard_len);
		xfree(junk);
		xfree(discard);
	}
d299 1
a299 1
		if (evplen <= 0)
d301 1
a301 1
		if ((u_int)evplen != len)
@


1.70
log
@spaces
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.69 2004/06/21 17:36:31 avsm Exp $");
d90 1
a90 1
	{ NULL,			SSH_CIPHER_ILLEGAL, 0, 0, NULL }
@


1.69
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.68 2004/01/23 19:26:33 hshoexer Exp $");
d63 4
a66 4
	{ "none", 		SSH_CIPHER_NONE, 8, 0, EVP_enc_null },
	{ "des", 		SSH_CIPHER_DES, 8, 8, EVP_des_cbc },
	{ "3des", 		SSH_CIPHER_3DES, 8, 16, evp_ssh1_3des },
	{ "blowfish", 		SSH_CIPHER_BLOWFISH, 8, 32, evp_ssh1_bf },
d68 4
a71 4
	{ "3des-cbc", 		SSH_CIPHER_SSH2, 8, 24, EVP_des_ede3_cbc },
	{ "blowfish-cbc", 	SSH_CIPHER_SSH2, 8, 16, EVP_bf_cbc },
	{ "cast128-cbc", 	SSH_CIPHER_SSH2, 8, 16, EVP_cast5_cbc },
	{ "arcfour", 		SSH_CIPHER_SSH2, 8, 16, EVP_rc4 },
d73 3
a75 3
	{ "aes128-cbc", 	SSH_CIPHER_SSH2, 16, 16, evp_rijndael },
	{ "aes192-cbc", 	SSH_CIPHER_SSH2, 16, 24, evp_rijndael },
	{ "aes256-cbc", 	SSH_CIPHER_SSH2, 16, 32, evp_rijndael },
d85 3
a87 3
	{ "aes128-ctr", 	SSH_CIPHER_SSH2, 16, 16, evp_aes_128_ctr },
	{ "aes192-ctr", 	SSH_CIPHER_SSH2, 16, 24, evp_aes_128_ctr },
	{ "aes256-ctr", 	SSH_CIPHER_SSH2, 16, 32, evp_aes_128_ctr },
@


1.68
log
@rename acss@@opebsd.org to acss@@openssh.org
ok deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.67 2004/01/23 17:06:03 hshoexer Exp $");
d150 1
a150 1
	char *ciphers, *cp;
d155 1
a155 1
	ciphers = cp = xstrdup(names);
d161 1
a161 1
			xfree(ciphers);
d168 1
a168 1
	xfree(ciphers);
d197 1
a197 1
    int encrypt)
d226 1
a226 1
	    (encrypt == CIPHER_ENCRYPT)) == 0)
d264 1
a264 1
    const char *passphrase, int encrypt)
d273 1
a273 1
	cipher_init(cc, cipher, digest, 16, NULL, 0, encrypt);
@


1.68.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.71 2004/07/28 09:40:29 markus Exp $");
d63 9
a71 9
	{ "none",		SSH_CIPHER_NONE, 8, 0, EVP_enc_null },
	{ "des",		SSH_CIPHER_DES, 8, 8, EVP_des_cbc },
	{ "3des",		SSH_CIPHER_3DES, 8, 16, evp_ssh1_3des },
	{ "blowfish",		SSH_CIPHER_BLOWFISH, 8, 32, evp_ssh1_bf },

	{ "3des-cbc",		SSH_CIPHER_SSH2, 8, 24, EVP_des_ede3_cbc },
	{ "blowfish-cbc",	SSH_CIPHER_SSH2, 8, 16, EVP_bf_cbc },
	{ "cast128-cbc",	SSH_CIPHER_SSH2, 8, 16, EVP_cast5_cbc },
	{ "arcfour",		SSH_CIPHER_SSH2, 8, 16, EVP_rc4 },
d73 3
a75 3
	{ "aes128-cbc",		SSH_CIPHER_SSH2, 16, 16, evp_rijndael },
	{ "aes192-cbc",		SSH_CIPHER_SSH2, 16, 24, evp_rijndael },
	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, evp_rijndael },
d85 3
a87 3
	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, evp_aes_128_ctr },
	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, evp_aes_128_ctr },
	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, evp_aes_128_ctr },
d90 1
a90 1
	{ NULL,			SSH_CIPHER_INVALID, 0, 0, NULL }
d150 1
a150 1
	char *cipher_list, *cp;
d155 1
a155 1
	cipher_list = cp = xstrdup(names);
d161 1
a161 1
			xfree(cipher_list);
d168 1
a168 1
	xfree(cipher_list);
d197 1
a197 1
    int do_encrypt)
d226 1
a226 1
	    (do_encrypt == CIPHER_ENCRYPT)) == 0)
d264 1
a264 1
    const char *passphrase, int do_encrypt)
d273 1
a273 1
	cipher_init(cc, cipher, digest, 16, NULL, 0, do_encrypt);
@


1.68.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.73 2005/01/23 10:18:12 djm Exp $");
d46 4
d72 7
d84 1
d130 1
a130 1
		if (strcmp(c->name, name) == 0)
d183 2
a184 4
	for (c = ciphers; c->name != NULL; c++)
		if (strcasecmp(c->name, name) == 0)
			return c->number;
	return -1;
d314 5
d345 5
d363 4
d369 1
@


1.67
log
@enable acss for ssh
ok deraadt@@ markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.66 2003/11/10 16:23:41 jakob Exp $");
d88 1
a88 1
	{ "acss@@openbsd.org",	SSH_CIPHER_SSH2, 16, 5, EVP_acss },
@


1.66
log
@constify. ok markus@@ & djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.65 2003/05/17 04:27:52 markus Exp $");
d88 1
d377 1
a377 1
	if (c->evptype == EVP_rc4) {
d392 1
a392 1
	if (c->evptype == EVP_rc4) {
@


1.65
log
@experimental support for aes-ctr modes from
http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-00.txt
ok djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.64 2003/05/15 03:08:29 markus Exp $");
d95 1
a95 1
cipher_blocksize(Cipher *c)
d101 1
a101 1
cipher_keylen(Cipher *c)
d107 1
a107 1
cipher_get_number(Cipher *c)
d285 1
a285 1
cipher_get_keyiv_len(CipherContext *cc)
d371 1
a371 1
cipher_get_keycontext(CipherContext *cc, u_char *dat)
@


1.65.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.68 2004/01/23 19:26:33 hshoexer Exp $");
a54 1
#define EVP_acss NULL
a87 1
	{ "acss@@openssh.org",	SSH_CIPHER_SSH2, 16, 5, EVP_acss },
d95 1
a95 1
cipher_blocksize(const Cipher *c)
d101 1
a101 1
cipher_keylen(const Cipher *c)
d107 1
a107 1
cipher_get_number(const Cipher *c)
d285 1
a285 1
cipher_get_keyiv_len(const CipherContext *cc)
d371 1
a371 1
cipher_get_keycontext(const CipherContext *cc, u_char *dat)
d376 1
a376 1
	if (c->evptype == EVP_rc4 || c->evptype == EVP_acss) {
d391 1
a391 1
	if (c->evptype == EVP_rc4 || c->evptype == EVP_acss) {
@


1.65.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.71 2004/07/28 09:40:29 markus Exp $");
d64 9
a72 9
	{ "none",		SSH_CIPHER_NONE, 8, 0, EVP_enc_null },
	{ "des",		SSH_CIPHER_DES, 8, 8, EVP_des_cbc },
	{ "3des",		SSH_CIPHER_3DES, 8, 16, evp_ssh1_3des },
	{ "blowfish",		SSH_CIPHER_BLOWFISH, 8, 32, evp_ssh1_bf },

	{ "3des-cbc",		SSH_CIPHER_SSH2, 8, 24, EVP_des_ede3_cbc },
	{ "blowfish-cbc",	SSH_CIPHER_SSH2, 8, 16, EVP_bf_cbc },
	{ "cast128-cbc",	SSH_CIPHER_SSH2, 8, 16, EVP_cast5_cbc },
	{ "arcfour",		SSH_CIPHER_SSH2, 8, 16, EVP_rc4 },
d74 3
a76 3
	{ "aes128-cbc",		SSH_CIPHER_SSH2, 16, 16, evp_rijndael },
	{ "aes192-cbc",		SSH_CIPHER_SSH2, 16, 24, evp_rijndael },
	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, evp_rijndael },
d86 3
a88 3
	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, evp_aes_128_ctr },
	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, evp_aes_128_ctr },
	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, evp_aes_128_ctr },
d91 1
a91 1
	{ NULL,			SSH_CIPHER_INVALID, 0, 0, NULL }
d151 1
a151 1
	char *cipher_list, *cp;
d156 1
a156 1
	cipher_list = cp = xstrdup(names);
d162 1
a162 1
			xfree(cipher_list);
d169 1
a169 1
	xfree(cipher_list);
d198 1
a198 1
    int do_encrypt)
d227 1
a227 1
	    (do_encrypt == CIPHER_ENCRYPT)) == 0)
d265 1
a265 1
    const char *passphrase, int do_encrypt)
d274 1
a274 1
	cipher_init(cc, cipher, digest, 16, NULL, 0, do_encrypt);
@


1.64
log
@split out custom EVP ciphers
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.62 2002/11/21 22:45:31 markus Exp $");
d53 2
d85 3
d318 3
d349 3
@


1.63
log
@hide cipher details; ok djm@@
@
text
@d47 2
a48 2
#include "rijndael.h"
static const EVP_CIPHER *evp_rijndael(void);
d50 3
a52 2
static const EVP_CIPHER *evp_ssh1_3des(void);
static const EVP_CIPHER *evp_ssh1_bf(void);
a271 296

/* Implementations for other non-EVP ciphers */

/*
 * This is used by SSH1:
 *
 * What kind of triple DES are these 2 routines?
 *
 * Why is there a redundant initialization vector?
 *
 * If only iv3 was used, then, this would till effect have been
 * outer-cbc. However, there is also a private iv1 == iv2 which
 * perhaps makes differential analysis easier. On the other hand, the
 * private iv1 probably makes the CRC-32 attack ineffective. This is a
 * result of that there is no longer any known iv1 to use when
 * choosing the X block.
 */
struct ssh1_3des_ctx
{
	EVP_CIPHER_CTX	k1, k2, k3;
};

static int
ssh1_3des_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,
    int enc)
{
	struct ssh1_3des_ctx *c;
	u_char *k1, *k2, *k3;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		c = xmalloc(sizeof(*c));
		EVP_CIPHER_CTX_set_app_data(ctx, c);
	}
	if (key == NULL)
		return (1);
	if (enc == -1)
		enc = ctx->encrypt;
	k1 = k2 = k3 = (u_char *) key;
	k2 += 8;
	if (EVP_CIPHER_CTX_key_length(ctx) >= 16+8) {
		if (enc)
			k3 += 16;
		else
			k1 += 16;
	}
	EVP_CIPHER_CTX_init(&c->k1);
	EVP_CIPHER_CTX_init(&c->k2);
	EVP_CIPHER_CTX_init(&c->k3);
	if (EVP_CipherInit(&c->k1, EVP_des_cbc(), k1, NULL, enc) == 0 ||
	    EVP_CipherInit(&c->k2, EVP_des_cbc(), k2, NULL, !enc) == 0 ||
	    EVP_CipherInit(&c->k3, EVP_des_cbc(), k3, NULL, enc) == 0) {
		memset(c, 0, sizeof(*c));
		xfree(c);
		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
		return (0);
	}
	return (1);
}

static int
ssh1_3des_cbc(EVP_CIPHER_CTX *ctx, u_char *dest, const u_char *src, u_int len)
{
	struct ssh1_3des_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		error("ssh1_3des_cbc: no context");
		return (0);
	}
	if (EVP_Cipher(&c->k1, dest, (u_char *)src, len) == 0 ||
	    EVP_Cipher(&c->k2, dest, dest, len) == 0 ||
	    EVP_Cipher(&c->k3, dest, dest, len) == 0)
		return (0);
	return (1);
}

static int
ssh1_3des_cleanup(EVP_CIPHER_CTX *ctx)
{
	struct ssh1_3des_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) != NULL) {
		memset(c, 0, sizeof(*c));
		xfree(c);
		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
	}
	return (1);
}

static void
ssh1_3des_iv(EVP_CIPHER_CTX *evp, int doset, u_char *iv, int len)
{
	struct ssh1_3des_ctx *c;

	if (len != 24)
		fatal("%s: bad 3des iv length: %d", __func__, len);
	if ((c = EVP_CIPHER_CTX_get_app_data(evp)) == NULL)
		fatal("%s: no 3des context", __func__);
	if (doset) {
		debug3("%s: Installed 3DES IV", __func__);
		memcpy(c->k1.iv, iv, 8);
		memcpy(c->k2.iv, iv + 8, 8);
		memcpy(c->k3.iv, iv + 16, 8);
	} else {
		debug3("%s: Copying 3DES IV", __func__);
		memcpy(iv, c->k1.iv, 8);
		memcpy(iv + 8, c->k2.iv, 8);
		memcpy(iv + 16, c->k3.iv, 8);
	}
}

static const EVP_CIPHER *
evp_ssh1_3des(void)
{
	static EVP_CIPHER ssh1_3des;

	memset(&ssh1_3des, 0, sizeof(EVP_CIPHER));
	ssh1_3des.nid = NID_undef;
	ssh1_3des.block_size = 8;
	ssh1_3des.iv_len = 0;
	ssh1_3des.key_len = 16;
	ssh1_3des.init = ssh1_3des_init;
	ssh1_3des.cleanup = ssh1_3des_cleanup;
	ssh1_3des.do_cipher = ssh1_3des_cbc;
	ssh1_3des.flags = EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH;
	return (&ssh1_3des);
}

/*
 * SSH1 uses a variation on Blowfish, all bytes must be swapped before
 * and after encryption/decryption. Thus the swap_bytes stuff (yuk).
 */
static void
swap_bytes(const u_char *src, u_char *dst, int n)
{
	u_char c[4];

	/* Process 4 bytes every lap. */
	for (n = n / 4; n > 0; n--) {
		c[3] = *src++;
		c[2] = *src++;
		c[1] = *src++;
		c[0] = *src++;

		*dst++ = c[0];
		*dst++ = c[1];
		*dst++ = c[2];
		*dst++ = c[3];
	}
}

static int (*orig_bf)(EVP_CIPHER_CTX *, u_char *, const u_char *, u_int) = NULL;

static int
bf_ssh1_cipher(EVP_CIPHER_CTX *ctx, u_char *out, const u_char *in, u_int len)
{
	int ret;

	swap_bytes(in, out, len);
	ret = (*orig_bf)(ctx, out, out, len);
	swap_bytes(out, out, len);
	return (ret);
}

static const EVP_CIPHER *
evp_ssh1_bf(void)
{
	static EVP_CIPHER ssh1_bf;

	memcpy(&ssh1_bf, EVP_bf_cbc(), sizeof(EVP_CIPHER));
	orig_bf = ssh1_bf.do_cipher;
	ssh1_bf.nid = NID_undef;
	ssh1_bf.do_cipher = bf_ssh1_cipher;
	ssh1_bf.key_len = 32;
	return (&ssh1_bf);
}

#if OPENSSL_VERSION_NUMBER < 0x00907000L
/* RIJNDAEL */
#define RIJNDAEL_BLOCKSIZE 16
struct ssh_rijndael_ctx
{
	rijndael_ctx	r_ctx;
	u_char		r_iv[RIJNDAEL_BLOCKSIZE];
};

static int
ssh_rijndael_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,
    int enc)
{
	struct ssh_rijndael_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		c = xmalloc(sizeof(*c));
		EVP_CIPHER_CTX_set_app_data(ctx, c);
	}
	if (key != NULL) {
		if (enc == -1)
			enc = ctx->encrypt;
		rijndael_set_key(&c->r_ctx, (u_char *)key,
		    8*EVP_CIPHER_CTX_key_length(ctx), enc);
	}
	if (iv != NULL)
		memcpy(c->r_iv, iv, RIJNDAEL_BLOCKSIZE);
	return (1);
}

static int
ssh_rijndael_cbc(EVP_CIPHER_CTX *ctx, u_char *dest, const u_char *src,
    u_int len)
{
	struct ssh_rijndael_ctx *c;
	u_char buf[RIJNDAEL_BLOCKSIZE];
	u_char *cprev, *cnow, *plain, *ivp;
	int i, j, blocks = len / RIJNDAEL_BLOCKSIZE;

	if (len == 0)
		return (1);
	if (len % RIJNDAEL_BLOCKSIZE)
		fatal("ssh_rijndael_cbc: bad len %d", len);
	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		error("ssh_rijndael_cbc: no context");
		return (0);
	}
	if (ctx->encrypt) {
		cnow  = dest;
		plain = (u_char *)src;
		cprev = c->r_iv;
		for (i = 0; i < blocks; i++, plain+=RIJNDAEL_BLOCKSIZE,
		    cnow+=RIJNDAEL_BLOCKSIZE) {
			for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
				buf[j] = plain[j] ^ cprev[j];
			rijndael_encrypt(&c->r_ctx, buf, cnow);
			cprev = cnow;
		}
		memcpy(c->r_iv, cprev, RIJNDAEL_BLOCKSIZE);
	} else {
		cnow  = (u_char *) (src+len-RIJNDAEL_BLOCKSIZE);
		plain = dest+len-RIJNDAEL_BLOCKSIZE;

		memcpy(buf, cnow, RIJNDAEL_BLOCKSIZE);
		for (i = blocks; i > 0; i--, cnow-=RIJNDAEL_BLOCKSIZE,
		    plain-=RIJNDAEL_BLOCKSIZE) {
			rijndael_decrypt(&c->r_ctx, cnow, plain);
			ivp = (i == 1) ? c->r_iv : cnow-RIJNDAEL_BLOCKSIZE;
			for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
				plain[j] ^= ivp[j];
		}
		memcpy(c->r_iv, buf, RIJNDAEL_BLOCKSIZE);
	}
	return (1);
}

static int
ssh_rijndael_cleanup(EVP_CIPHER_CTX *ctx)
{
	struct ssh_rijndael_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) != NULL) {
		memset(c, 0, sizeof(*c));
		xfree(c);
		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
	}
	return (1);
}

static void
ssh_rijndael_iv(EVP_CIPHER_CTX *evp, int doset, u_char * iv, u_int len)
{
	struct ssh_rijndael_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(evp)) == NULL)
		fatal("ssh_rijndael_iv: no context");
	if (doset)
		memcpy(c->r_iv, iv, len);
	else
		memcpy(iv, c->r_iv, len);
}

static const EVP_CIPHER *
evp_rijndael(void)
{
	static EVP_CIPHER rijndal_cbc;

	memset(&rijndal_cbc, 0, sizeof(EVP_CIPHER));
	rijndal_cbc.nid = NID_undef;
	rijndal_cbc.block_size = RIJNDAEL_BLOCKSIZE;
	rijndal_cbc.iv_len = RIJNDAEL_BLOCKSIZE;
	rijndal_cbc.key_len = 16;
	rijndal_cbc.init = ssh_rijndael_init;
	rijndal_cbc.cleanup = ssh_rijndael_cleanup;
	rijndal_cbc.do_cipher = ssh_rijndael_cbc;
	rijndal_cbc.flags = EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH |
	    EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CUSTOM_IV;
	return (&rijndal_cbc);
}
#endif
@


1.62
log
@debug->debug2, unify debug messages
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.61 2002/07/12 15:50:17 markus Exp $");
d359 22
d536 13
a590 1
	u_char *civ = NULL;
a602 1

d604 3
a606 8
		if (c->evptype == evp_rijndael) {
			struct ssh_rijndael_ctx *aesc;

			aesc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
			if (aesc == NULL)
				fatal("%s: no rijndael context", __func__);
			civ = aesc->r_iv;
		} else
d608 4
a611 3
		{
			civ = cc->evp.iv;
		}
a612 13
	case SSH_CIPHER_3DES: {
		struct ssh1_3des_ctx *desc;
		if (len != 24)
			fatal("%s: bad 3des iv length: %d", __func__, len);
		desc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
		if (desc == NULL)
			fatal("%s: no 3des context", __func__);
		debug3("%s: Copying 3DES IV", __func__);
		memcpy(iv, desc->k1.iv, 8);
		memcpy(iv + 8, desc->k2.iv, 8);
		memcpy(iv + 16, desc->k3.iv, 8);
		return;
	}
a615 1
	memcpy(iv, civ, len);
a621 1
	u_char *div = NULL;
a630 1

d632 3
a634 8
		if (c->evptype == evp_rijndael) {
			struct ssh_rijndael_ctx *aesc;

			aesc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
			if (aesc == NULL)
				fatal("%s: no rijndael context", __func__);
			div = aesc->r_iv;
		} else
d636 4
a639 3
		{
			div = cc->evp.iv;
		}
a640 11
	case SSH_CIPHER_3DES: {
		struct ssh1_3des_ctx *desc;
		desc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
		if (desc == NULL)
			fatal("%s: no 3des context", __func__);
		debug3("%s: Installed 3DES IV", __func__);
		memcpy(desc->k1.iv, iv, 8);
		memcpy(desc->k2.iv, iv + 8, 8);
		memcpy(desc->k3.iv, iv + 16, 8);
		return;
	}
a643 1
	memcpy(div, iv, evplen);
@


1.62.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.65 2003/05/17 04:27:52 markus Exp $");
d47 2
a48 2
extern const EVP_CIPHER *evp_rijndael(void);
extern void ssh_rijndael_iv(EVP_CIPHER_CTX *, int, u_char *, u_int);
d50 2
a51 5
extern const EVP_CIPHER *evp_ssh1_bf(void);
extern const EVP_CIPHER *evp_ssh1_3des(void);
extern void ssh1_3des_iv(EVP_CIPHER_CTX *, int, u_char *, int);
extern const EVP_CIPHER *evp_aes_128_ctr(void);
extern void ssh_aes_ctr_iv(EVP_CIPHER_CTX *, int, u_char *, u_int);
a81 3
	{ "aes128-ctr", 	SSH_CIPHER_SSH2, 16, 16, evp_aes_128_ctr },
	{ "aes192-ctr", 	SSH_CIPHER_SSH2, 16, 24, evp_aes_128_ctr },
	{ "aes256-ctr", 	SSH_CIPHER_SSH2, 16, 32, evp_aes_128_ctr },
d272 261
d556 1
d569 1
d571 8
a578 3
		if (c->evptype == evp_rijndael)
			ssh_rijndael_iv(&cc->evp, 0, iv, len);
		else
d580 3
a582 7
		if (c->evptype == evp_aes_128_ctr)
			ssh_aes_ctr_iv(&cc->evp, 0, iv, len);
		else
			memcpy(iv, cc->evp.iv, len);
		break;
	case SSH_CIPHER_3DES:
		ssh1_3des_iv(&cc->evp, 0, iv, 24);
d584 13
d600 1
d607 1
d617 1
d619 8
a626 3
		if (c->evptype == evp_rijndael)
			ssh_rijndael_iv(&cc->evp, 1, iv, evplen);
		else
d628 3
a630 7
		if (c->evptype == evp_aes_128_ctr)
			ssh_aes_ctr_iv(&cc->evp, 1, iv, evplen);
		else
			memcpy(cc->evp.iv, iv, evplen);
		break;
	case SSH_CIPHER_3DES:
		ssh1_3des_iv(&cc->evp, 1, iv, 24);
d632 11
d646 1
@


1.62.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.68 2004/01/23 19:26:33 hshoexer Exp $");
a54 1
#define EVP_acss NULL
a87 1
	{ "acss@@openssh.org",	SSH_CIPHER_SSH2, 16, 5, EVP_acss },
d95 1
a95 1
cipher_blocksize(const Cipher *c)
d101 1
a101 1
cipher_keylen(const Cipher *c)
d107 1
a107 1
cipher_get_number(const Cipher *c)
d285 1
a285 1
cipher_get_keyiv_len(const CipherContext *cc)
d371 1
a371 1
cipher_get_keycontext(const CipherContext *cc, u_char *dat)
d376 1
a376 1
	if (c->evptype == EVP_rc4 || c->evptype == EVP_acss) {
d391 1
a391 1
	if (c->evptype == EVP_rc4 || c->evptype == EVP_acss) {
@


1.61
log
@EVP_CIPH_CUSTOM_IV for our own rijndael
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.60 2002/06/23 03:26:52 deraadt Exp $");
d224 1
a224 1
		debug("cipher_init: set keylen (%d -> %d)", klen, keylen);
@


1.61.2.1
log
@Update to OpenSSH 3.6
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.62 2002/11/21 22:45:31 markus Exp $");
d224 1
a224 1
		debug2("cipher_init: set keylen (%d -> %d)", klen, keylen);
@


1.61.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.65 2003/05/17 04:27:52 markus Exp $");
d47 2
a48 2
extern const EVP_CIPHER *evp_rijndael(void);
extern void ssh_rijndael_iv(EVP_CIPHER_CTX *, int, u_char *, u_int);
d50 2
a51 5
extern const EVP_CIPHER *evp_ssh1_bf(void);
extern const EVP_CIPHER *evp_ssh1_3des(void);
extern void ssh1_3des_iv(EVP_CIPHER_CTX *, int, u_char *, int);
extern const EVP_CIPHER *evp_aes_128_ctr(void);
extern void ssh_aes_ctr_iv(EVP_CIPHER_CTX *, int, u_char *, u_int);
a81 3
	{ "aes128-ctr", 	SSH_CIPHER_SSH2, 16, 16, evp_aes_128_ctr },
	{ "aes192-ctr", 	SSH_CIPHER_SSH2, 16, 24, evp_aes_128_ctr },
	{ "aes256-ctr", 	SSH_CIPHER_SSH2, 16, 32, evp_aes_128_ctr },
d272 261
d556 1
d569 1
d571 8
a578 3
		if (c->evptype == evp_rijndael)
			ssh_rijndael_iv(&cc->evp, 0, iv, len);
		else
d580 3
a582 7
		if (c->evptype == evp_aes_128_ctr)
			ssh_aes_ctr_iv(&cc->evp, 0, iv, len);
		else
			memcpy(iv, cc->evp.iv, len);
		break;
	case SSH_CIPHER_3DES:
		ssh1_3des_iv(&cc->evp, 0, iv, 24);
d584 13
d600 1
d607 1
d617 1
d619 8
a626 3
		if (c->evptype == evp_rijndael)
			ssh_rijndael_iv(&cc->evp, 1, iv, evplen);
		else
d628 3
a630 7
		if (c->evptype == evp_aes_128_ctr)
			ssh_aes_ctr_iv(&cc->evp, 1, iv, evplen);
		else
			memcpy(cc->evp.iv, iv, evplen);
		break;
	case SSH_CIPHER_3DES:
		ssh1_3des_iv(&cc->evp, 1, iv, 24);
d632 11
d646 1
@


1.60
log
@KNF
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.59 2002/06/19 18:01:00 markus Exp $");
d528 1
a528 1
	    EVP_CIPH_ALWAYS_CALL_INIT;
@


1.59
log
@make the monitor sync the transfer ssh1 session key;
transfer keycontext only for RC4 (this is still depends on EVP
implementation details and is broken).
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.58 2002/06/04 23:05:49 markus Exp $");
d93 1
d99 1
d292 1
d329 1
d345 1
d358 1
d398 1
d400 1
d411 1
d454 1
d500 1
d513 1
@


1.58
log
@__FUNCTION__ -> __func__
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.57 2002/05/30 08:07:31 markus Exp $");
d649 1
a649 1
	int plen;
d651 2
a652 6
	if (c->number == SSH_CIPHER_3DES) {
		struct ssh1_3des_ctx *desc;
		desc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
		if (desc == NULL)
			fatal("%s: no 3des context", __func__);
		plen = EVP_X_STATE_LEN(desc->k1);
d654 2
a655 5
			return (3*plen);
		memcpy(dat, EVP_X_STATE(desc->k1), plen);
		memcpy(dat + plen, EVP_X_STATE(desc->k2), plen);
		memcpy(dat + 2*plen, EVP_X_STATE(desc->k3), plen);
		return (3*plen);
a656 7

	/* Generic EVP */
	plen = EVP_X_STATE_LEN(cc->evp);
	if (dat == NULL)
		return (plen);

	memcpy(dat, EVP_X_STATE(cc->evp), plen);
d666 1
a666 10
	if (c->number == SSH_CIPHER_3DES) {
		struct ssh1_3des_ctx *desc;
		desc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
		if (desc == NULL)
			fatal("%s: no 3des context", __func__);
		plen = EVP_X_STATE_LEN(desc->k1);
		memcpy(EVP_X_STATE(desc->k1), dat, plen);
		memcpy(EVP_X_STATE(desc->k2), dat + plen, plen);
		memcpy(EVP_X_STATE(desc->k3), dat + 2*plen, plen);
	} else {
@


1.57
log
@use rijndael/aes from libcrypto (openssl >= 0.9.7) instead of
our own implementation. allow use of AES hardware via libcrypto, ok deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.56 2002/05/16 22:02:50 markus Exp $");
d555 1
a555 1
			fatal("%s: wrong iv length %d != %d", __FUNCTION__,
d564 1
a564 1
				fatal("%s: no rijndael context", __FUNCTION__);
d575 1
a575 1
			fatal("%s: bad 3des iv length: %d", __FUNCTION__, len);
d578 2
a579 2
			fatal("%s: no 3des context", __FUNCTION__);
		debug3("%s: Copying 3DES IV", __FUNCTION__);
d586 1
a586 1
		fatal("%s: bad cipher %d", __FUNCTION__, c->number);
d612 1
a612 1
				fatal("%s: no rijndael context", __FUNCTION__);
d624 2
a625 2
			fatal("%s: no 3des context", __FUNCTION__);
		debug3("%s: Installed 3DES IV", __FUNCTION__);
d632 1
a632 1
		fatal("%s: bad cipher %d", __FUNCTION__, c->number);
d655 1
a655 1
			fatal("%s: no 3des context", __FUNCTION__);
d684 1
a684 1
			fatal("%s: no 3des context", __FUNCTION__);
@


1.56
log
@fix warnings (openssl 0.9.7 requires const)
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.55 2002/04/03 09:26:11 markus Exp $");
d45 2
d48 2
a49 1

a51 1
static const EVP_CIPHER *evp_rijndael(void);
d69 1
d75 7
d416 1
d519 1
d558 1
d566 3
a568 1
		} else {
d606 1
d614 3
a616 1
		}else {
@


1.55
log
@re-add rijndael-cbc@@lysator.liu.se for MacSSH; ash@@lab.poc.net
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.54 2002/03/19 10:49:35 markus Exp $");
d47 3
a49 3
static EVP_CIPHER *evp_ssh1_3des(void);
static EVP_CIPHER *evp_ssh1_bf(void);
static EVP_CIPHER *evp_rijndael(void);
d56 1
a56 1
	EVP_CIPHER	*(*evptype)(void);
d343 1
a343 1
static EVP_CIPHER *
d393 1
a393 1
static EVP_CIPHER *
d491 1
a491 1
static EVP_CIPHER *
@


1.55.2.1
log
@Pull in OpenSSH-3.4
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.60 2002/06/23 03:26:52 deraadt Exp $");
d45 1
d47 3
a49 6
#if OPENSSL_VERSION_NUMBER < 0x00907000L
#include "rijndael.h"
static const EVP_CIPHER *evp_rijndael(void);
#endif
static const EVP_CIPHER *evp_ssh1_3des(void);
static const EVP_CIPHER *evp_ssh1_bf(void);
d56 1
a56 1
	const EVP_CIPHER	*(*evptype)(void);
a66 1
#if OPENSSL_VERSION_NUMBER < 0x00907000L
a71 7
#else
	{ "aes128-cbc",		SSH_CIPHER_SSH2, 16, 16, EVP_aes_128_cbc },
	{ "aes192-cbc",		SSH_CIPHER_SSH2, 16, 24, EVP_aes_192_cbc },
	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, EVP_aes_256_cbc },
	{ "rijndael-cbc@@lysator.liu.se",
				SSH_CIPHER_SSH2, 16, 32, EVP_aes_256_cbc },
#endif
a82 1

a87 1

a279 1

a315 1

a330 1

d343 1
a343 2

static const EVP_CIPHER *
a381 1

a382 1

d393 1
a393 2

static const EVP_CIPHER *
a405 1
#if OPENSSL_VERSION_NUMBER < 0x00907000L
a433 1

a478 1

d491 1
a491 2

static const EVP_CIPHER *
a507 1
#endif
d543 1
a543 1
			fatal("%s: wrong iv length %d != %d", __func__,
a545 1
#if OPENSSL_VERSION_NUMBER < 0x00907000L
d551 1
a551 1
				fatal("%s: no rijndael context", __func__);
d553 1
a553 3
		} else
#endif
		{
d560 1
a560 1
			fatal("%s: bad 3des iv length: %d", __func__, len);
d563 2
a564 2
			fatal("%s: no 3des context", __func__);
		debug3("%s: Copying 3DES IV", __func__);
d571 1
a571 1
		fatal("%s: bad cipher %d", __func__, c->number);
a590 1
#if OPENSSL_VERSION_NUMBER < 0x00907000L
d596 1
a596 1
				fatal("%s: no rijndael context", __func__);
d598 1
a598 3
		} else
#endif
		{
d606 2
a607 2
			fatal("%s: no 3des context", __func__);
		debug3("%s: Installed 3DES IV", __func__);
d614 1
a614 1
		fatal("%s: bad cipher %d", __func__, c->number);
d631 1
a631 1
	int plen = 0;
d633 6
a638 2
	if (c->evptype == EVP_rc4) {
		plen = EVP_X_STATE_LEN(cc->evp);
d640 5
a644 2
			return (plen);
		memcpy(dat, EVP_X_STATE(cc->evp), plen);
d646 7
d662 10
a671 1
	if (c->evptype == EVP_rc4) {
@


1.55.2.2
log
@Update to OpenSSH 3.5
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.61 2002/07/12 15:50:17 markus Exp $");
d528 1
a528 1
	    EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CUSTOM_IV;
@


1.55.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.62 2002/11/21 22:45:31 markus Exp $");
d224 1
a224 1
		debug2("cipher_init: set keylen (%d -> %d)", klen, keylen);
@


1.54
log
@KNF whitespace
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.53 2002/03/18 17:13:15 markus Exp $");
d70 2
d546 1
a546 1
		if (strncmp(c->name, "aes", 3) == 0) {
d591 1
a591 1
		if (strncmp(c->name, "aes", 3) == 0) {
@


1.53
log
@export/import cipher states; needed by ssh-privsep
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.52 2002/02/18 13:05:32 markus Exp $");
d76 1
a76 1
u_int	
d81 1
a81 1
u_int	
d86 1
a86 1
u_int	
d507 1
a507 1
/* 
d610 1
a610 1
	} 
@


1.52
log
@switch to EVP, ok djm@@ deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.51 2002/02/14 23:41:01 markus Exp $");
d86 5
d505 168
@


1.51
log
@hide some more implementation details of cipher.[ch] and prepares for move
to EVP, ok deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.50 2002/01/21 22:30:12 markus Exp $");
d45 5
d56 14
a69 293
	void	(*setkey)(CipherContext *, const u_char *, u_int);
	void	(*setiv)(CipherContext *, const u_char *, u_int);
	void	(*encrypt)(CipherContext *, u_char *, const u_char *, u_int);
	void	(*decrypt)(CipherContext *, u_char *, const u_char *, u_int);
};

/* no encryption */
static void
none_setkey(CipherContext *cc, const u_char *key, u_int keylen)
{
}
static void
none_setiv(CipherContext *cc, const u_char *iv, u_int ivlen)
{
}
static void
none_crypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	memcpy(dest, src, len);
}

/* DES */
static void
des_ssh1_setkey(CipherContext *cc, const u_char *key, u_int keylen)
{
	static int dowarn = 1;
	if (dowarn) {
		error("Warning: use of DES is strongly discouraged "
		    "due to cryptographic weaknesses");
		dowarn = 0;
	}
	des_set_key((void *)key, cc->u.des.key);
}
static void
des_ssh1_setiv(CipherContext *cc, const u_char *iv, u_int ivlen)
{
	memset(cc->u.des.iv, 0, sizeof(cc->u.des.iv));
}
static void
des_ssh1_encrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	des_ncbc_encrypt(src, dest, len, cc->u.des.key, &cc->u.des.iv,
	    DES_ENCRYPT);
}
static void
des_ssh1_decrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	des_ncbc_encrypt(src, dest, len, cc->u.des.key, &cc->u.des.iv,
	    DES_DECRYPT);
}

/* 3DES */
static void
des3_setkey(CipherContext *cc, const u_char *key, u_int keylen)
{
	des_set_key((void *) key, cc->u.des3.key1);
	des_set_key((void *) (key+8), cc->u.des3.key2);
	des_set_key((void *) (key+16), cc->u.des3.key3);
}
static void
des3_setiv(CipherContext *cc, const u_char *iv, u_int ivlen)
{
	memset(cc->u.des3.iv1, 0, sizeof(cc->u.des3.iv1));
	memset(cc->u.des3.iv2, 0, sizeof(cc->u.des3.iv2));
	memset(cc->u.des3.iv3, 0, sizeof(cc->u.des3.iv3));
	if (iv == NULL)
		return;
	memcpy(cc->u.des3.iv3, (char *)iv, 8);
}
static void
des3_cbc_encrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	des_ede3_cbc_encrypt(src, dest, len,
	    cc->u.des3.key1, cc->u.des3.key2, cc->u.des3.key3,
	    &cc->u.des3.iv3, DES_ENCRYPT);
}
static void
des3_cbc_decrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	des_ede3_cbc_encrypt(src, dest, len,
	    cc->u.des3.key1, cc->u.des3.key2, cc->u.des3.key3,
	    &cc->u.des3.iv3, DES_DECRYPT);
}

/*
 * This is used by SSH1:
 *
 * What kind of triple DES are these 2 routines?
 *
 * Why is there a redundant initialization vector?
 *
 * If only iv3 was used, then, this would till effect have been
 * outer-cbc. However, there is also a private iv1 == iv2 which
 * perhaps makes differential analysis easier. On the other hand, the
 * private iv1 probably makes the CRC-32 attack ineffective. This is a
 * result of that there is no longer any known iv1 to use when
 * choosing the X block.
 */
static void
des3_ssh1_setkey(CipherContext *cc, const u_char *key, u_int keylen)
{
	des_set_key((void *) key, cc->u.des3.key1);
	des_set_key((void *) (key+8), cc->u.des3.key2);
	if (keylen <= 16)
		des_set_key((void *) key, cc->u.des3.key3);
	else
		des_set_key((void *) (key+16), cc->u.des3.key3);
}
static void
des3_ssh1_encrypt(CipherContext *cc, u_char *dest, const u_char *src,
    u_int len)
{
	des_ncbc_encrypt(src,  dest, len, cc->u.des3.key1, &cc->u.des3.iv1,
	    DES_ENCRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key2, &cc->u.des3.iv2,
	    DES_DECRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key3, &cc->u.des3.iv3,
	    DES_ENCRYPT);
}
static void
des3_ssh1_decrypt(CipherContext *cc, u_char *dest, const u_char *src,
    u_int len)
{
	des_ncbc_encrypt(src,  dest, len, cc->u.des3.key3, &cc->u.des3.iv3,
	    DES_DECRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key2, &cc->u.des3.iv2,
	    DES_ENCRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key1, &cc->u.des3.iv1,
	    DES_DECRYPT);
}

/* Blowfish */
static void
blowfish_setkey(CipherContext *cc, const u_char *key, u_int keylen)
{
	BF_set_key(&cc->u.bf.key, keylen, (u_char *)key);
}
static void
blowfish_setiv(CipherContext *cc, const u_char *iv, u_int ivlen)
{
	if (iv == NULL)
		memset(cc->u.bf.iv, 0, 8);
	else
		memcpy(cc->u.bf.iv, (char *)iv, 8);
}
static void
blowfish_cbc_encrypt(CipherContext *cc, u_char *dest, const u_char *src,
    u_int len)
{
	BF_cbc_encrypt((void *)src, dest, len, &cc->u.bf.key, cc->u.bf.iv,
	    BF_ENCRYPT);
}
static void
blowfish_cbc_decrypt(CipherContext *cc, u_char *dest, const u_char *src,
    u_int len)
{
	BF_cbc_encrypt((void *)src, dest, len, &cc->u.bf.key, cc->u.bf.iv,
	    BF_DECRYPT);
}

/*
 * SSH1 uses a variation on Blowfish, all bytes must be swapped before
 * and after encryption/decryption. Thus the swap_bytes stuff (yuk).
 */
static void
swap_bytes(const u_char *src, u_char *dst, int n)
{
	char c[4];

	/* Process 4 bytes every lap. */
	for (n = n / 4; n > 0; n--) {
		c[3] = *src++;
		c[2] = *src++;
		c[1] = *src++;
		c[0] = *src++;

		*dst++ = c[0];
		*dst++ = c[1];
		*dst++ = c[2];
		*dst++ = c[3];
	}
}

static void
blowfish_ssh1_encrypt(CipherContext *cc, u_char *dest, const u_char *src,
    u_int len)
{
	swap_bytes(src, dest, len);
	BF_cbc_encrypt((void *)dest, dest, len, &cc->u.bf.key, cc->u.bf.iv,
	    BF_ENCRYPT);
	swap_bytes(dest, dest, len);
}
static void
blowfish_ssh1_decrypt(CipherContext *cc, u_char *dest, const u_char *src,
    u_int len)
{
	swap_bytes(src, dest, len);
	BF_cbc_encrypt((void *)dest, dest, len, &cc->u.bf.key, cc->u.bf.iv,
	    BF_DECRYPT);
	swap_bytes(dest, dest, len);
}

/* alleged rc4 */
static void
arcfour_setkey(CipherContext *cc, const u_char *key, u_int keylen)
{
	RC4_set_key(&cc->u.rc4, keylen, (u_char *)key);
}
static void
arcfour_crypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	RC4(&cc->u.rc4, len, (u_char *)src, dest);
}

/* CAST */
static void
cast_setkey(CipherContext *cc, const u_char *key, u_int keylen)
{
	CAST_set_key(&cc->u.cast.key, keylen, (u_char *) key);
}
static void
cast_setiv(CipherContext *cc, const u_char *iv, u_int ivlen)
{
	if (iv == NULL)
		fatal("no IV for %s.", cc->cipher->name);
	memcpy(cc->u.cast.iv, (char *)iv, 8);
}
static void
cast_cbc_encrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	CAST_cbc_encrypt(src, dest, len, &cc->u.cast.key, cc->u.cast.iv,
	    CAST_ENCRYPT);
}
static void
cast_cbc_decrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	CAST_cbc_encrypt(src, dest, len, &cc->u.cast.key, cc->u.cast.iv,
	    CAST_DECRYPT);
}

/* RIJNDAEL */

#define RIJNDAEL_BLOCKSIZE 16
static void
rijndael_setkey(CipherContext *cc, const u_char *key, u_int keylen)
{
	rijndael_set_key(&cc->u.rijndael.enc, (char *)key, 8*keylen, 1);
	rijndael_set_key(&cc->u.rijndael.dec, (char *)key, 8*keylen, 0);
}
static void
rijndael_setiv(CipherContext *cc, const u_char *iv, u_int ivlen)
{
	if (iv == NULL || ivlen != RIJNDAEL_BLOCKSIZE)
		fatal("bad/no IV for %s.", cc->cipher->name);
	memcpy(cc->u.rijndael.iv, iv, RIJNDAEL_BLOCKSIZE);
}
static void
rijndael_cbc_encrypt(CipherContext *cc, u_char *dest, const u_char *src,
    u_int len)
{
	rijndael_ctx *ctx = &cc->u.rijndael.enc;
	u_char *iv = cc->u.rijndael.iv;
	u_char in[RIJNDAEL_BLOCKSIZE];
	u_char *cprev, *cnow, *plain;
	int i, j, blocks = len / RIJNDAEL_BLOCKSIZE;

	if (len == 0)
		return;
	if (len % RIJNDAEL_BLOCKSIZE)
		fatal("rijndael_cbc_encrypt: bad len %d", len);
	cnow  = dest;
	plain = (u_char *)src;
	cprev = iv;
	for (i = 0; i < blocks; i++, plain+=RIJNDAEL_BLOCKSIZE,
	    cnow+=RIJNDAEL_BLOCKSIZE) {
		for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
			in[j] = plain[j] ^ cprev[j];
		rijndael_encrypt(ctx, in, cnow);
		cprev = cnow;
	}
	memcpy(iv, cprev, RIJNDAEL_BLOCKSIZE);
}
static void
rijndael_cbc_decrypt(CipherContext *cc, u_char *dest, const u_char *src,
    u_int len)
{
	rijndael_ctx *ctx = &cc->u.rijndael.dec;
	u_char *iv = cc->u.rijndael.iv;
	u_char ivsaved[RIJNDAEL_BLOCKSIZE];
	u_char *cnow  = (u_char *) (src+len-RIJNDAEL_BLOCKSIZE);
	u_char *plain = dest+len-RIJNDAEL_BLOCKSIZE;
	u_char *ivp;
	int i, j, blocks = len / RIJNDAEL_BLOCKSIZE;
d71 1
a71 62
	if (len == 0)
		return;
	if (len % RIJNDAEL_BLOCKSIZE)
		fatal("rijndael_cbc_decrypt: bad len %d", len);
	memcpy(ivsaved, cnow, RIJNDAEL_BLOCKSIZE);
	for (i = blocks; i > 0; i--, cnow-=RIJNDAEL_BLOCKSIZE,
	    plain-=RIJNDAEL_BLOCKSIZE) {
		rijndael_decrypt(ctx, cnow, plain);
		ivp = (i == 1) ? iv : cnow-RIJNDAEL_BLOCKSIZE;
		for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
			plain[j] ^= ivp[j];
	}
	memcpy(iv, ivsaved, RIJNDAEL_BLOCKSIZE);
}

Cipher ciphers[] = {
	{ "none",
		SSH_CIPHER_NONE, 8, 0,
		none_setkey, none_setiv,
		none_crypt, none_crypt },
	{ "des",
		SSH_CIPHER_DES, 8, 8,
		des_ssh1_setkey, des_ssh1_setiv,
		des_ssh1_encrypt, des_ssh1_decrypt },
	{ "3des",
		SSH_CIPHER_3DES, 8, 16,
		des3_ssh1_setkey, des3_setiv,
		des3_ssh1_encrypt, des3_ssh1_decrypt },
	{ "blowfish",
		SSH_CIPHER_BLOWFISH, 8, 16,
		blowfish_setkey, blowfish_setiv,
		blowfish_ssh1_encrypt, blowfish_ssh1_decrypt },

	{ "3des-cbc",
		SSH_CIPHER_SSH2, 8, 24,
		des3_setkey, des3_setiv,
		des3_cbc_encrypt, des3_cbc_decrypt },
	{ "blowfish-cbc",
		SSH_CIPHER_SSH2, 8, 16,
		blowfish_setkey, blowfish_setiv,
		blowfish_cbc_encrypt, blowfish_cbc_decrypt },
	{ "cast128-cbc",
		SSH_CIPHER_SSH2, 8, 16,
		cast_setkey, cast_setiv,
		cast_cbc_encrypt, cast_cbc_decrypt },
	{ "arcfour",
		SSH_CIPHER_SSH2, 8, 16,
		arcfour_setkey, none_setiv,
		arcfour_crypt, arcfour_crypt },
	{ "aes128-cbc",
		SSH_CIPHER_SSH2, 16, 16,
		rijndael_setkey, rijndael_setiv,
		rijndael_cbc_encrypt, rijndael_cbc_decrypt },
	{ "aes192-cbc",
		SSH_CIPHER_SSH2, 16, 24,
		rijndael_setkey, rijndael_setiv,
		rijndael_cbc_encrypt, rijndael_cbc_decrypt },
	{ "aes256-cbc",
		SSH_CIPHER_SSH2, 16, 32,
		rijndael_setkey, rijndael_setiv,
		rijndael_cbc_encrypt, rijndael_cbc_decrypt },
	{ NULL, SSH_CIPHER_ILLEGAL, 0, 0, NULL, NULL, NULL, NULL }
d76 1
a76 1
u_int   
d81 1
a81 2

u_int   
d169 3
a171 2
cipher_init(CipherContext *cc, Cipher *cipher, const u_char *key,
     u_int keylen, const u_char *iv, u_int ivlen, int encrypt)
d173 15
d195 18
a212 3
	cc->encrypt = (encrypt == CIPHER_ENCRYPT);
	cipher->setkey(cc, key, keylen);
	cipher->setiv(cc, iv, ivlen);
d220 2
a221 4
	if (cc->encrypt)
		cc->cipher->encrypt(cc, dest, src, len);
	else
		cc->cipher->decrypt(cc, dest, src, len);
d227 2
a228 1
	memset(cc, 0, sizeof(*cc));
d251 249
@


1.50
log
@remove "rijndael-*", just use "aes-" since this how rijndael is called
in the drafts; ok stevesk@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.49 2002/01/18 18:14:17 stevesk Exp $");
d46 11
d411 12
d505 2
a506 2
cipher_init(CipherContext *cc, Cipher *cipher,
    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen)
d515 1
d521 1
a521 1
cipher_encrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
d525 4
a528 1
	cc->cipher->encrypt(cc, dest, src, len);
d532 1
a532 1
cipher_decrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
d534 1
a534 3
	if (len % cc->cipher->block_size)
		fatal("cipher_decrypt: bad ciphertext length %d", len);
	cc->cipher->decrypt(cc, dest, src, len);
d544 1
a544 1
    const char *passphrase)
d553 1
a553 1
	cipher_init(cc, cipher, digest, 16, NULL, 0);
@


1.49
log
@unneeded cast cleanup; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.48 2001/12/19 07:18:56 deraadt Exp $");
a391 16
		SSH_CIPHER_SSH2, 16, 32,
		rijndael_setkey, rijndael_setiv,
		rijndael_cbc_encrypt, rijndael_cbc_decrypt },
	{ "rijndael128-cbc",
		SSH_CIPHER_SSH2, 16, 16,
		rijndael_setkey, rijndael_setiv,
		rijndael_cbc_encrypt, rijndael_cbc_decrypt },
	{ "rijndael192-cbc",
		SSH_CIPHER_SSH2, 16, 24,
		rijndael_setkey, rijndael_setiv,
		rijndael_cbc_encrypt, rijndael_cbc_decrypt },
	{ "rijndael256-cbc",
		SSH_CIPHER_SSH2, 16, 32,
		rijndael_setkey, rijndael_setiv,
		rijndael_cbc_encrypt, rijndael_cbc_decrypt },
	{ "rijndael-cbc@@lysator.liu.se",
@


1.48
log
@basic KNF done while i was looking for something else
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.47 2001/08/23 11:31:59 markus Exp $");
d311 1
a311 1
	plain = (u_char *) src;
@


1.47
log
@switch to the optimised AES reference code from
http://www.esat.kuleuven.ac.be/~rijmen/rijndael/rijndael-fst-3.0.zip
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.46 2001/06/25 08:25:36 markus Exp $");
d187 1
a187 1
     u_int len)
d194 1
a194 1
     u_int len)
d292 1
a292 1
	if (iv == NULL || ivlen != RIJNDAEL_BLOCKSIZE) 
d420 1
a420 1
	mask |= 1 << SSH_CIPHER_3DES;           /* Mandatory */
d460 1
a460 1
	     (p = strsep(&cp, CIPHER_SEP))) {
@


1.47.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.52 2002/02/18 13:05:32 markus Exp $");
a44 1
#include "rijndael.h"
d46 195
a240 23
static EVP_CIPHER *evp_ssh1_3des(void);
static EVP_CIPHER *evp_ssh1_bf(void);
static EVP_CIPHER *evp_rijndael(void);

struct Cipher {
	char	*name;
	int	number;		/* for ssh1 only */
	u_int	block_size;
	u_int	key_len;
	EVP_CIPHER	*(*evptype)(void);
} ciphers[] = {
	{ "none", 		SSH_CIPHER_NONE, 8, 0, EVP_enc_null },
	{ "des", 		SSH_CIPHER_DES, 8, 8, EVP_des_cbc },
	{ "3des", 		SSH_CIPHER_3DES, 8, 16, evp_ssh1_3des },
	{ "blowfish", 		SSH_CIPHER_BLOWFISH, 8, 32, evp_ssh1_bf },

	{ "3des-cbc", 		SSH_CIPHER_SSH2, 8, 24, EVP_des_ede3_cbc },
	{ "blowfish-cbc", 	SSH_CIPHER_SSH2, 8, 16, EVP_bf_cbc },
	{ "cast128-cbc", 	SSH_CIPHER_SSH2, 8, 16, EVP_cast5_cbc },
	{ "arcfour", 		SSH_CIPHER_SSH2, 8, 16, EVP_rc4 },
	{ "aes128-cbc", 	SSH_CIPHER_SSH2, 16, 16, evp_rijndael },
	{ "aes192-cbc", 	SSH_CIPHER_SSH2, 16, 24, evp_rijndael },
	{ "aes256-cbc", 	SSH_CIPHER_SSH2, 16, 32, evp_rijndael },
d242 37
a278 2
	{ NULL,			SSH_CIPHER_ILLEGAL, 0, 0, NULL }
};
d280 1
a280 1
/*--*/
d282 3
a284 2
u_int	
cipher_blocksize(Cipher *c)
d286 2
a287 1
	return (c->block_size);
d289 10
a298 2
u_int	
cipher_keylen(Cipher *c)
d300 21
a320 1
	return (c->key_len);
d322 93
d420 1
a420 1
	mask |= 1 << SSH_CIPHER_3DES;		/* Mandatory */
d460 1
a460 1
	    (p = strsep(&cp, CIPHER_SEP))) {
d499 1
a499 2
    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen,
    int encrypt)
a500 15
	static int dowarn = 1;
	const EVP_CIPHER *type;
	int klen;

	if (cipher->number == SSH_CIPHER_DES) {
		if (dowarn) {
			error("Warning: use of DES is strongly discouraged "
			    "due to cryptographic weaknesses");
			dowarn = 0;
		}
		if (keylen > 8)
			keylen = 8;
	}
	cc->plaintext = (cipher->number == SSH_CIPHER_NONE);

d508 2
a509 18

	type = (*cipher->evptype)();

	EVP_CIPHER_CTX_init(&cc->evp);
	if (EVP_CipherInit(&cc->evp, type, NULL, (u_char *)iv,
	    (encrypt == CIPHER_ENCRYPT)) == 0)
		fatal("cipher_init: EVP_CipherInit failed for %s",
		    cipher->name);
	klen = EVP_CIPHER_CTX_key_length(&cc->evp);
	if (klen > 0 && keylen != klen) {
		debug("cipher_init: set keylen (%d -> %d)", klen, keylen);
		if (EVP_CIPHER_CTX_set_key_length(&cc->evp, keylen) == 0)
			fatal("cipher_init: set keylen failed (%d -> %d)",
			    klen, keylen);
	}
	if (EVP_CipherInit(&cc->evp, NULL, (u_char *)key, NULL, -1) == 0)
		fatal("cipher_init: EVP_CipherInit: set key failed for %s",
		    cipher->name);
d513 1
a513 1
cipher_crypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
d517 1
a517 2
	if (EVP_Cipher(&cc->evp, dest, (u_char *)src, len) == 0)
		fatal("evp_crypt: EVP_Cipher failed");
d521 1
a521 1
cipher_cleanup(CipherContext *cc)
d523 3
a525 2
	if (EVP_CIPHER_CTX_cleanup(&cc->evp) == 0)
		error("cipher_cleanup: EVP_CIPHER_CTX_cleanup failed");
d535 1
a535 1
    const char *passphrase, int encrypt)
d544 1
a544 1
	cipher_init(cc, cipher, digest, 16, NULL, 0, encrypt);
a547 249
}

/* Implementations for other non-EVP ciphers */

/*
 * This is used by SSH1:
 *
 * What kind of triple DES are these 2 routines?
 *
 * Why is there a redundant initialization vector?
 *
 * If only iv3 was used, then, this would till effect have been
 * outer-cbc. However, there is also a private iv1 == iv2 which
 * perhaps makes differential analysis easier. On the other hand, the
 * private iv1 probably makes the CRC-32 attack ineffective. This is a
 * result of that there is no longer any known iv1 to use when
 * choosing the X block.
 */
struct ssh1_3des_ctx
{
	EVP_CIPHER_CTX	k1, k2, k3;
};
static int
ssh1_3des_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,
    int enc)
{
	struct ssh1_3des_ctx *c;
	u_char *k1, *k2, *k3;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		c = xmalloc(sizeof(*c));
		EVP_CIPHER_CTX_set_app_data(ctx, c);
	}
	if (key == NULL)
		return (1);
	if (enc == -1)
		enc = ctx->encrypt;
	k1 = k2 = k3 = (u_char *) key;
	k2 += 8;
	if (EVP_CIPHER_CTX_key_length(ctx) >= 16+8) {
		if (enc)
			k3 += 16;
		else
			k1 += 16;
	}
	EVP_CIPHER_CTX_init(&c->k1);
	EVP_CIPHER_CTX_init(&c->k2);
	EVP_CIPHER_CTX_init(&c->k3);
	if (EVP_CipherInit(&c->k1, EVP_des_cbc(), k1, NULL, enc) == 0 ||
	    EVP_CipherInit(&c->k2, EVP_des_cbc(), k2, NULL, !enc) == 0 ||
	    EVP_CipherInit(&c->k3, EVP_des_cbc(), k3, NULL, enc) == 0) {
		memset(c, 0, sizeof(*c));
		xfree(c);
		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
		return (0);
	}
	return (1);
}
static int
ssh1_3des_cbc(EVP_CIPHER_CTX *ctx, u_char *dest, const u_char *src, u_int len)
{
	struct ssh1_3des_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		error("ssh1_3des_cbc: no context");
		return (0);
	}
	if (EVP_Cipher(&c->k1, dest, (u_char *)src, len) == 0 ||
	    EVP_Cipher(&c->k2, dest, dest, len) == 0 ||
	    EVP_Cipher(&c->k3, dest, dest, len) == 0)
		return (0);
	return (1);
}
static int
ssh1_3des_cleanup(EVP_CIPHER_CTX *ctx)
{
	struct ssh1_3des_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) != NULL) {
		memset(c, 0, sizeof(*c));
		xfree(c);
		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
	}
	return (1);
}
static EVP_CIPHER *
evp_ssh1_3des(void)
{
	static EVP_CIPHER ssh1_3des;

	memset(&ssh1_3des, 0, sizeof(EVP_CIPHER));
	ssh1_3des.nid = NID_undef;
	ssh1_3des.block_size = 8;
	ssh1_3des.iv_len = 0;
	ssh1_3des.key_len = 16;
	ssh1_3des.init = ssh1_3des_init;
	ssh1_3des.cleanup = ssh1_3des_cleanup;
	ssh1_3des.do_cipher = ssh1_3des_cbc;
	ssh1_3des.flags = EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH;
	return (&ssh1_3des);
}

/*
 * SSH1 uses a variation on Blowfish, all bytes must be swapped before
 * and after encryption/decryption. Thus the swap_bytes stuff (yuk).
 */
static void
swap_bytes(const u_char *src, u_char *dst, int n)
{
	u_char c[4];

	/* Process 4 bytes every lap. */
	for (n = n / 4; n > 0; n--) {
		c[3] = *src++;
		c[2] = *src++;
		c[1] = *src++;
		c[0] = *src++;

		*dst++ = c[0];
		*dst++ = c[1];
		*dst++ = c[2];
		*dst++ = c[3];
	}
}
static int (*orig_bf)(EVP_CIPHER_CTX *, u_char *, const u_char *, u_int) = NULL;
static int
bf_ssh1_cipher(EVP_CIPHER_CTX *ctx, u_char *out, const u_char *in, u_int len)
{
	int ret;

	swap_bytes(in, out, len);
	ret = (*orig_bf)(ctx, out, out, len);
	swap_bytes(out, out, len);
	return (ret);
}
static EVP_CIPHER *
evp_ssh1_bf(void)
{
	static EVP_CIPHER ssh1_bf;

	memcpy(&ssh1_bf, EVP_bf_cbc(), sizeof(EVP_CIPHER));
	orig_bf = ssh1_bf.do_cipher;
	ssh1_bf.nid = NID_undef;
	ssh1_bf.do_cipher = bf_ssh1_cipher;
	ssh1_bf.key_len = 32;
	return (&ssh1_bf);
}

/* RIJNDAEL */
#define RIJNDAEL_BLOCKSIZE 16
struct ssh_rijndael_ctx
{
	rijndael_ctx	r_ctx;
	u_char		r_iv[RIJNDAEL_BLOCKSIZE];
};

static int
ssh_rijndael_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,
    int enc)
{
	struct ssh_rijndael_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		c = xmalloc(sizeof(*c));
		EVP_CIPHER_CTX_set_app_data(ctx, c);
	}
	if (key != NULL) {
		if (enc == -1)
			enc = ctx->encrypt;
		rijndael_set_key(&c->r_ctx, (u_char *)key,
		    8*EVP_CIPHER_CTX_key_length(ctx), enc);
	}
	if (iv != NULL)
		memcpy(c->r_iv, iv, RIJNDAEL_BLOCKSIZE);
	return (1);
}
static int
ssh_rijndael_cbc(EVP_CIPHER_CTX *ctx, u_char *dest, const u_char *src,
    u_int len)
{
	struct ssh_rijndael_ctx *c;
	u_char buf[RIJNDAEL_BLOCKSIZE];
	u_char *cprev, *cnow, *plain, *ivp;
	int i, j, blocks = len / RIJNDAEL_BLOCKSIZE;

	if (len == 0)
		return (1);
	if (len % RIJNDAEL_BLOCKSIZE)
		fatal("ssh_rijndael_cbc: bad len %d", len);
	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		error("ssh_rijndael_cbc: no context");
		return (0);
	}
	if (ctx->encrypt) {
		cnow  = dest;
		plain = (u_char *)src;
		cprev = c->r_iv;
		for (i = 0; i < blocks; i++, plain+=RIJNDAEL_BLOCKSIZE,
		    cnow+=RIJNDAEL_BLOCKSIZE) {
			for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
				buf[j] = plain[j] ^ cprev[j];
			rijndael_encrypt(&c->r_ctx, buf, cnow);
			cprev = cnow;
		}
		memcpy(c->r_iv, cprev, RIJNDAEL_BLOCKSIZE);
	} else {
		cnow  = (u_char *) (src+len-RIJNDAEL_BLOCKSIZE);
		plain = dest+len-RIJNDAEL_BLOCKSIZE;

		memcpy(buf, cnow, RIJNDAEL_BLOCKSIZE);
		for (i = blocks; i > 0; i--, cnow-=RIJNDAEL_BLOCKSIZE,
		    plain-=RIJNDAEL_BLOCKSIZE) {
			rijndael_decrypt(&c->r_ctx, cnow, plain);
			ivp = (i == 1) ? c->r_iv : cnow-RIJNDAEL_BLOCKSIZE;
			for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
				plain[j] ^= ivp[j];
		}
		memcpy(c->r_iv, buf, RIJNDAEL_BLOCKSIZE);
	}
	return (1);
}
static int
ssh_rijndael_cleanup(EVP_CIPHER_CTX *ctx)
{
	struct ssh_rijndael_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) != NULL) {
		memset(c, 0, sizeof(*c));
		xfree(c);
		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
	}
	return (1);
}
static EVP_CIPHER *
evp_rijndael(void)
{
	static EVP_CIPHER rijndal_cbc;

	memset(&rijndal_cbc, 0, sizeof(EVP_CIPHER));
	rijndal_cbc.nid = NID_undef;
	rijndal_cbc.block_size = RIJNDAEL_BLOCKSIZE;
	rijndal_cbc.iv_len = RIJNDAEL_BLOCKSIZE;
	rijndal_cbc.key_len = 16;
	rijndal_cbc.init = ssh_rijndael_init;
	rijndal_cbc.cleanup = ssh_rijndael_cleanup;
	rijndal_cbc.do_cipher = ssh_rijndael_cbc;
	rijndal_cbc.flags = EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH |
	    EVP_CIPH_ALWAYS_CALL_INIT;
	return (&rijndal_cbc);
@


1.47.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.55 2002/04/03 09:26:11 markus Exp $");
a69 2
	{ "rijndael-cbc@@lysator.liu.se",
				SSH_CIPHER_SSH2, 16, 32, evp_rijndael },
d76 1
a76 1
u_int
d81 1
a81 1
u_int
a85 5
u_int
cipher_get_number(Cipher *c)
{
	return (c->number);
}
a499 168
}

/*
 * Exports an IV from the CipherContext required to export the key
 * state back from the unprivileged child to the privileged parent
 * process.
 */

int
cipher_get_keyiv_len(CipherContext *cc)
{
	Cipher *c = cc->cipher;
	int ivlen;

	if (c->number == SSH_CIPHER_3DES)
		ivlen = 24;
	else
		ivlen = EVP_CIPHER_CTX_iv_length(&cc->evp);
	return (ivlen);
}

void
cipher_get_keyiv(CipherContext *cc, u_char *iv, u_int len)
{
	Cipher *c = cc->cipher;
	u_char *civ = NULL;
	int evplen;

	switch (c->number) {
	case SSH_CIPHER_SSH2:
	case SSH_CIPHER_DES:
	case SSH_CIPHER_BLOWFISH:
		evplen = EVP_CIPHER_CTX_iv_length(&cc->evp);
		if (evplen == 0)
			return;
		if (evplen != len)
			fatal("%s: wrong iv length %d != %d", __FUNCTION__,
			    evplen, len);

		if (c->evptype == evp_rijndael) {
			struct ssh_rijndael_ctx *aesc;

			aesc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
			if (aesc == NULL)
				fatal("%s: no rijndael context", __FUNCTION__);
			civ = aesc->r_iv;
		} else {
			civ = cc->evp.iv;
		}
		break;
	case SSH_CIPHER_3DES: {
		struct ssh1_3des_ctx *desc;
		if (len != 24)
			fatal("%s: bad 3des iv length: %d", __FUNCTION__, len);
		desc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
		if (desc == NULL)
			fatal("%s: no 3des context", __FUNCTION__);
		debug3("%s: Copying 3DES IV", __FUNCTION__);
		memcpy(iv, desc->k1.iv, 8);
		memcpy(iv + 8, desc->k2.iv, 8);
		memcpy(iv + 16, desc->k3.iv, 8);
		return;
	}
	default:
		fatal("%s: bad cipher %d", __FUNCTION__, c->number);
	}
	memcpy(iv, civ, len);
}

void
cipher_set_keyiv(CipherContext *cc, u_char *iv)
{
	Cipher *c = cc->cipher;
	u_char *div = NULL;
	int evplen = 0;

	switch (c->number) {
	case SSH_CIPHER_SSH2:
	case SSH_CIPHER_DES:
	case SSH_CIPHER_BLOWFISH:
		evplen = EVP_CIPHER_CTX_iv_length(&cc->evp);
		if (evplen == 0)
			return;

		if (c->evptype == evp_rijndael) {
			struct ssh_rijndael_ctx *aesc;

			aesc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
			if (aesc == NULL)
				fatal("%s: no rijndael context", __FUNCTION__);
			div = aesc->r_iv;
		}else {
			div = cc->evp.iv;
		}
		break;
	case SSH_CIPHER_3DES: {
		struct ssh1_3des_ctx *desc;
		desc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
		if (desc == NULL)
			fatal("%s: no 3des context", __FUNCTION__);
		debug3("%s: Installed 3DES IV", __FUNCTION__);
		memcpy(desc->k1.iv, iv, 8);
		memcpy(desc->k2.iv, iv + 8, 8);
		memcpy(desc->k3.iv, iv + 16, 8);
		return;
	}
	default:
		fatal("%s: bad cipher %d", __FUNCTION__, c->number);
	}
	memcpy(div, iv, evplen);
}

#if OPENSSL_VERSION_NUMBER < 0x00907000L
#define EVP_X_STATE(evp)	&(evp).c
#define EVP_X_STATE_LEN(evp)	sizeof((evp).c)
#else
#define EVP_X_STATE(evp)	(evp).cipher_data
#define EVP_X_STATE_LEN(evp)	(evp).cipher->ctx_size
#endif

int
cipher_get_keycontext(CipherContext *cc, u_char *dat)
{
	Cipher *c = cc->cipher;
	int plen;

	if (c->number == SSH_CIPHER_3DES) {
		struct ssh1_3des_ctx *desc;
		desc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
		if (desc == NULL)
			fatal("%s: no 3des context", __FUNCTION__);
		plen = EVP_X_STATE_LEN(desc->k1);
		if (dat == NULL)
			return (3*plen);
		memcpy(dat, EVP_X_STATE(desc->k1), plen);
		memcpy(dat + plen, EVP_X_STATE(desc->k2), plen);
		memcpy(dat + 2*plen, EVP_X_STATE(desc->k3), plen);
		return (3*plen);
	}

	/* Generic EVP */
	plen = EVP_X_STATE_LEN(cc->evp);
	if (dat == NULL)
		return (plen);

	memcpy(dat, EVP_X_STATE(cc->evp), plen);
	return (plen);
}

void
cipher_set_keycontext(CipherContext *cc, u_char *dat)
{
	Cipher *c = cc->cipher;
	int plen;

	if (c->number == SSH_CIPHER_3DES) {
		struct ssh1_3des_ctx *desc;
		desc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
		if (desc == NULL)
			fatal("%s: no 3des context", __FUNCTION__);
		plen = EVP_X_STATE_LEN(desc->k1);
		memcpy(EVP_X_STATE(desc->k1), dat, plen);
		memcpy(EVP_X_STATE(desc->k2), dat + plen, plen);
		memcpy(EVP_X_STATE(desc->k3), dat + 2*plen, plen);
	} else {
		plen = EVP_X_STATE_LEN(cc->evp);
		memcpy(EVP_X_STATE(cc->evp), dat, plen);
	}
@


1.47.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.59 2002/06/19 18:01:00 markus Exp $");
d45 1
d47 3
a49 6
#if OPENSSL_VERSION_NUMBER < 0x00907000L
#include "rijndael.h"
static const EVP_CIPHER *evp_rijndael(void);
#endif
static const EVP_CIPHER *evp_ssh1_3des(void);
static const EVP_CIPHER *evp_ssh1_bf(void);
d56 1
a56 1
	const EVP_CIPHER	*(*evptype)(void);
a66 1
#if OPENSSL_VERSION_NUMBER < 0x00907000L
a71 7
#else
	{ "aes128-cbc",		SSH_CIPHER_SSH2, 16, 16, EVP_aes_128_cbc },
	{ "aes192-cbc",		SSH_CIPHER_SSH2, 16, 24, EVP_aes_192_cbc },
	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, EVP_aes_256_cbc },
	{ "rijndael-cbc@@lysator.liu.se",
				SSH_CIPHER_SSH2, 16, 32, EVP_aes_256_cbc },
#endif
d343 1
a343 1
static const EVP_CIPHER *
d393 1
a393 1
static const EVP_CIPHER *
a405 1
#if OPENSSL_VERSION_NUMBER < 0x00907000L
d491 1
a491 1
static const EVP_CIPHER *
a507 1
#endif
d543 1
a543 1
			fatal("%s: wrong iv length %d != %d", __func__,
a545 1
#if OPENSSL_VERSION_NUMBER < 0x00907000L
d551 1
a551 1
				fatal("%s: no rijndael context", __func__);
d553 1
a553 3
		} else
#endif
		{
d560 1
a560 1
			fatal("%s: bad 3des iv length: %d", __func__, len);
d563 2
a564 2
			fatal("%s: no 3des context", __func__);
		debug3("%s: Copying 3DES IV", __func__);
d571 1
a571 1
		fatal("%s: bad cipher %d", __func__, c->number);
a590 1
#if OPENSSL_VERSION_NUMBER < 0x00907000L
d596 1
a596 1
				fatal("%s: no rijndael context", __func__);
d598 1
a598 3
		} else
#endif
		{
d606 2
a607 2
			fatal("%s: no 3des context", __func__);
		debug3("%s: Installed 3DES IV", __func__);
d614 1
a614 1
		fatal("%s: bad cipher %d", __func__, c->number);
d631 1
a631 1
	int plen = 0;
d633 6
a638 2
	if (c->evptype == EVP_rc4) {
		plen = EVP_X_STATE_LEN(cc->evp);
d640 5
a644 2
			return (plen);
		memcpy(dat, EVP_X_STATE(cc->evp), plen);
d646 7
d662 10
a671 1
	if (c->evptype == EVP_rc4) {
@


1.47.2.4
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.47.2.3 2002/06/22 07:23:17 miod Exp $");
a92 1

a97 1

a289 1

a325 1

a340 1

a352 1

a391 1

a392 1

a402 1

a444 1

a489 1

a501 1

@


1.47.2.5
log
@Update to OpenSSH 3.5
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.61 2002/07/12 15:50:17 markus Exp $");
d528 1
a528 1
	    EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CUSTOM_IV;
@


1.46
log
@update copyright for 2001
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.45 2001/06/23 15:12:18 itojun Exp $");
d286 2
a287 2
	rijndael_set_key(&cc->u.rijndael.enc, (u4byte *)key, 8*keylen, 1);
	rijndael_set_key(&cc->u.rijndael.dec, (u4byte *)key, 8*keylen, 0);
d292 3
a294 3
	if (iv == NULL)
		fatal("no IV for %s.", cc->cipher->name);
	memcpy((u_char *)cc->u.rijndael.iv, iv, RIJNDAEL_BLOCKSIZE);
d301 5
a305 4
	u4byte *iv = cc->u.rijndael.iv;
	u4byte in[4];
	u4byte *cprev, *cnow, *plain;
	int i, blocks = len / RIJNDAEL_BLOCKSIZE;
d310 2
a311 2
	cnow  = (u4byte*) dest;
	plain = (u4byte*) src;
d313 4
a316 5
	for(i = 0; i < blocks; i++, plain+=4, cnow+=4) {
		in[0] = plain[0] ^ cprev[0];
		in[1] = plain[1] ^ cprev[1];
		in[2] = plain[2] ^ cprev[2];
		in[3] = plain[3] ^ cprev[3];
a321 1

d327 7
a333 6
	u4byte *iv = cc->u.rijndael.iv;
	u4byte ivsaved[4];
	u4byte *cnow =  (u4byte*) (src+len-RIJNDAEL_BLOCKSIZE);
	u4byte *plain = (u4byte*) (dest+len-RIJNDAEL_BLOCKSIZE);
	u4byte *ivp;
	int i, blocks = len / RIJNDAEL_BLOCKSIZE;
d339 2
a340 1
	for(i = blocks; i > 0; i--, cnow-=4, plain-=4) {
d342 3
a344 5
		ivp =  (i == 1) ? iv : cnow-4;
		plain[0] ^= ivp[0];
		plain[1] ^= ivp[1];
		plain[2] ^= ivp[2];
		plain[3] ^= ivp[3];
@


1.45
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d14 1
a14 1
 * Copyright (c) 1999,2000 Markus Friedl.  All rights reserved.
d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.44 2001/05/28 22:51:10 markus Exp $");
@


1.44
log
@simpler 3des for ssh1
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.43 2001/02/04 15:32:23 stevesk Exp $");
a45 1

d47 1
a47 1
void
d51 1
a51 1
void
d55 1
a55 1
void
d62 1
a62 1
void
d73 1
a73 1
void
d78 1
a78 1
void
d84 1
a84 1
void
d92 1
a92 1
void
d99 1
a99 1
void
d109 1
a109 1
void
d116 1
a116 1
void
d138 1
a138 1
void
d148 1
a148 1
void
d159 1
a159 1
void
d172 1
a172 1
void
d177 1
a177 1
void
d185 1
a185 1
void
d192 1
a192 1
void
d223 1
a223 1
void
d232 1
a232 1
void
d243 1
a243 1
void
d248 1
a248 1
void
d255 1
a255 1
void
d260 1
a260 1
void
d267 1
a267 1
void
d273 1
a273 1
void
d283 1
a283 1
void
d289 1
a289 1
void
d296 1
a296 1
void
d323 1
a323 1
void
@


1.43
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.42 2001/01/21 19:05:46 markus Exp $");
d103 1
d153 6
a158 9
	des_cblock iv1;
	des_cblock *iv2 = &cc->u.des3.iv2;
	des_cblock *iv3 = &cc->u.des3.iv3;

	memcpy(&iv1, iv2, 8);

	des_ncbc_encrypt(src,  dest, len, cc->u.des3.key1, &iv1, DES_ENCRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key2, iv2, DES_DECRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key3, iv3, DES_ENCRYPT);
d164 6
a169 9
	des_cblock iv1;
	des_cblock *iv2 = &cc->u.des3.iv2;
	des_cblock *iv3 = &cc->u.des3.iv3;

	memcpy(&iv1, iv2, 8);

	des_ncbc_encrypt(src,  dest, len, cc->u.des3.key3, iv3, DES_DECRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key2, iv2, DES_ENCRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key1, &iv1, DES_DECRYPT);
@


1.43.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d14 1
a14 1
 * Copyright (c) 1999, 2000 Markus Friedl.  All rights reserved.
d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.47 2001/08/23 11:31:59 markus Exp $");
d46 1
d48 1
a48 1
static void
d52 1
a52 1
static void
d56 1
a56 1
static void
d63 1
a63 1
static void
d74 1
a74 1
static void
d79 1
a79 1
static void
d85 1
a85 1
static void
d93 1
a93 1
static void
d100 1
a100 1
static void
a102 1
	memset(cc->u.des3.iv1, 0, sizeof(cc->u.des3.iv1));
d109 1
a109 1
static void
d116 1
a116 1
static void
d138 1
a138 1
static void
d148 1
a148 1
static void
d152 9
a160 6
	des_ncbc_encrypt(src,  dest, len, cc->u.des3.key1, &cc->u.des3.iv1,
	    DES_ENCRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key2, &cc->u.des3.iv2,
	    DES_DECRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key3, &cc->u.des3.iv3,
	    DES_ENCRYPT);
d162 1
a162 1
static void
d166 9
a174 6
	des_ncbc_encrypt(src,  dest, len, cc->u.des3.key3, &cc->u.des3.iv3,
	    DES_DECRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key2, &cc->u.des3.iv2,
	    DES_ENCRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key1, &cc->u.des3.iv1,
	    DES_DECRYPT);
d178 1
a178 1
static void
d183 1
a183 1
static void
d191 1
a191 1
static void
d198 1
a198 1
static void
d229 1
a229 1
static void
d238 1
a238 1
static void
d249 1
a249 1
static void
d254 1
a254 1
static void
d261 1
a261 1
static void
d266 1
a266 1
static void
d273 1
a273 1
static void
d279 1
a279 1
static void
d289 1
a289 1
static void
d292 2
a293 2
	rijndael_set_key(&cc->u.rijndael.enc, (char *)key, 8*keylen, 1);
	rijndael_set_key(&cc->u.rijndael.dec, (char *)key, 8*keylen, 0);
d295 1
a295 1
static void
d298 3
a300 3
	if (iv == NULL || ivlen != RIJNDAEL_BLOCKSIZE) 
		fatal("bad/no IV for %s.", cc->cipher->name);
	memcpy(cc->u.rijndael.iv, iv, RIJNDAEL_BLOCKSIZE);
d302 1
a302 1
static void
d307 4
a310 5
	u_char *iv = cc->u.rijndael.iv;
	u_char in[RIJNDAEL_BLOCKSIZE];
	u_char *cprev, *cnow, *plain;
	int i, j, blocks = len / RIJNDAEL_BLOCKSIZE;

d315 2
a316 2
	cnow  = dest;
	plain = (u_char *) src;
d318 5
a322 4
	for (i = 0; i < blocks; i++, plain+=RIJNDAEL_BLOCKSIZE,
	    cnow+=RIJNDAEL_BLOCKSIZE) {
		for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
			in[j] = plain[j] ^ cprev[j];
d328 2
a329 1
static void
d334 6
a339 7
	u_char *iv = cc->u.rijndael.iv;
	u_char ivsaved[RIJNDAEL_BLOCKSIZE];
	u_char *cnow  = (u_char *) (src+len-RIJNDAEL_BLOCKSIZE);
	u_char *plain = dest+len-RIJNDAEL_BLOCKSIZE;
	u_char *ivp;
	int i, j, blocks = len / RIJNDAEL_BLOCKSIZE;

d345 1
a345 2
	for (i = blocks; i > 0; i--, cnow-=RIJNDAEL_BLOCKSIZE,
	    plain-=RIJNDAEL_BLOCKSIZE) {
d347 5
a351 3
		ivp = (i == 1) ? iv : cnow-RIJNDAEL_BLOCKSIZE;
		for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
			plain[j] ^= ivp[j];
@


1.43.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.52 2002/02/18 13:05:32 markus Exp $");
a44 1
#include "rijndael.h"
d46 195
a240 23
static EVP_CIPHER *evp_ssh1_3des(void);
static EVP_CIPHER *evp_ssh1_bf(void);
static EVP_CIPHER *evp_rijndael(void);

struct Cipher {
	char	*name;
	int	number;		/* for ssh1 only */
	u_int	block_size;
	u_int	key_len;
	EVP_CIPHER	*(*evptype)(void);
} ciphers[] = {
	{ "none", 		SSH_CIPHER_NONE, 8, 0, EVP_enc_null },
	{ "des", 		SSH_CIPHER_DES, 8, 8, EVP_des_cbc },
	{ "3des", 		SSH_CIPHER_3DES, 8, 16, evp_ssh1_3des },
	{ "blowfish", 		SSH_CIPHER_BLOWFISH, 8, 32, evp_ssh1_bf },

	{ "3des-cbc", 		SSH_CIPHER_SSH2, 8, 24, EVP_des_ede3_cbc },
	{ "blowfish-cbc", 	SSH_CIPHER_SSH2, 8, 16, EVP_bf_cbc },
	{ "cast128-cbc", 	SSH_CIPHER_SSH2, 8, 16, EVP_cast5_cbc },
	{ "arcfour", 		SSH_CIPHER_SSH2, 8, 16, EVP_rc4 },
	{ "aes128-cbc", 	SSH_CIPHER_SSH2, 16, 16, evp_rijndael },
	{ "aes192-cbc", 	SSH_CIPHER_SSH2, 16, 24, evp_rijndael },
	{ "aes256-cbc", 	SSH_CIPHER_SSH2, 16, 32, evp_rijndael },
d242 37
a278 2
	{ NULL,			SSH_CIPHER_ILLEGAL, 0, 0, NULL }
};
d280 1
a280 1
/*--*/
d282 3
a284 2
u_int	
cipher_blocksize(Cipher *c)
d286 2
a287 1
	return (c->block_size);
d289 10
a298 2
u_int	
cipher_keylen(Cipher *c)
d300 21
a320 1
	return (c->key_len);
d322 93
d420 1
a420 1
	mask |= 1 << SSH_CIPHER_3DES;		/* Mandatory */
d460 1
a460 1
	    (p = strsep(&cp, CIPHER_SEP))) {
d499 1
a499 2
    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen,
    int encrypt)
a500 15
	static int dowarn = 1;
	const EVP_CIPHER *type;
	int klen;

	if (cipher->number == SSH_CIPHER_DES) {
		if (dowarn) {
			error("Warning: use of DES is strongly discouraged "
			    "due to cryptographic weaknesses");
			dowarn = 0;
		}
		if (keylen > 8)
			keylen = 8;
	}
	cc->plaintext = (cipher->number == SSH_CIPHER_NONE);

d508 2
a509 18

	type = (*cipher->evptype)();

	EVP_CIPHER_CTX_init(&cc->evp);
	if (EVP_CipherInit(&cc->evp, type, NULL, (u_char *)iv,
	    (encrypt == CIPHER_ENCRYPT)) == 0)
		fatal("cipher_init: EVP_CipherInit failed for %s",
		    cipher->name);
	klen = EVP_CIPHER_CTX_key_length(&cc->evp);
	if (klen > 0 && keylen != klen) {
		debug("cipher_init: set keylen (%d -> %d)", klen, keylen);
		if (EVP_CIPHER_CTX_set_key_length(&cc->evp, keylen) == 0)
			fatal("cipher_init: set keylen failed (%d -> %d)",
			    klen, keylen);
	}
	if (EVP_CipherInit(&cc->evp, NULL, (u_char *)key, NULL, -1) == 0)
		fatal("cipher_init: EVP_CipherInit: set key failed for %s",
		    cipher->name);
d513 1
a513 1
cipher_crypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
d517 1
a517 2
	if (EVP_Cipher(&cc->evp, dest, (u_char *)src, len) == 0)
		fatal("evp_crypt: EVP_Cipher failed");
d521 1
a521 1
cipher_cleanup(CipherContext *cc)
d523 3
a525 2
	if (EVP_CIPHER_CTX_cleanup(&cc->evp) == 0)
		error("cipher_cleanup: EVP_CIPHER_CTX_cleanup failed");
d535 1
a535 1
    const char *passphrase, int encrypt)
d544 1
a544 1
	cipher_init(cc, cipher, digest, 16, NULL, 0, encrypt);
a547 249
}

/* Implementations for other non-EVP ciphers */

/*
 * This is used by SSH1:
 *
 * What kind of triple DES are these 2 routines?
 *
 * Why is there a redundant initialization vector?
 *
 * If only iv3 was used, then, this would till effect have been
 * outer-cbc. However, there is also a private iv1 == iv2 which
 * perhaps makes differential analysis easier. On the other hand, the
 * private iv1 probably makes the CRC-32 attack ineffective. This is a
 * result of that there is no longer any known iv1 to use when
 * choosing the X block.
 */
struct ssh1_3des_ctx
{
	EVP_CIPHER_CTX	k1, k2, k3;
};
static int
ssh1_3des_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,
    int enc)
{
	struct ssh1_3des_ctx *c;
	u_char *k1, *k2, *k3;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		c = xmalloc(sizeof(*c));
		EVP_CIPHER_CTX_set_app_data(ctx, c);
	}
	if (key == NULL)
		return (1);
	if (enc == -1)
		enc = ctx->encrypt;
	k1 = k2 = k3 = (u_char *) key;
	k2 += 8;
	if (EVP_CIPHER_CTX_key_length(ctx) >= 16+8) {
		if (enc)
			k3 += 16;
		else
			k1 += 16;
	}
	EVP_CIPHER_CTX_init(&c->k1);
	EVP_CIPHER_CTX_init(&c->k2);
	EVP_CIPHER_CTX_init(&c->k3);
	if (EVP_CipherInit(&c->k1, EVP_des_cbc(), k1, NULL, enc) == 0 ||
	    EVP_CipherInit(&c->k2, EVP_des_cbc(), k2, NULL, !enc) == 0 ||
	    EVP_CipherInit(&c->k3, EVP_des_cbc(), k3, NULL, enc) == 0) {
		memset(c, 0, sizeof(*c));
		xfree(c);
		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
		return (0);
	}
	return (1);
}
static int
ssh1_3des_cbc(EVP_CIPHER_CTX *ctx, u_char *dest, const u_char *src, u_int len)
{
	struct ssh1_3des_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		error("ssh1_3des_cbc: no context");
		return (0);
	}
	if (EVP_Cipher(&c->k1, dest, (u_char *)src, len) == 0 ||
	    EVP_Cipher(&c->k2, dest, dest, len) == 0 ||
	    EVP_Cipher(&c->k3, dest, dest, len) == 0)
		return (0);
	return (1);
}
static int
ssh1_3des_cleanup(EVP_CIPHER_CTX *ctx)
{
	struct ssh1_3des_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) != NULL) {
		memset(c, 0, sizeof(*c));
		xfree(c);
		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
	}
	return (1);
}
static EVP_CIPHER *
evp_ssh1_3des(void)
{
	static EVP_CIPHER ssh1_3des;

	memset(&ssh1_3des, 0, sizeof(EVP_CIPHER));
	ssh1_3des.nid = NID_undef;
	ssh1_3des.block_size = 8;
	ssh1_3des.iv_len = 0;
	ssh1_3des.key_len = 16;
	ssh1_3des.init = ssh1_3des_init;
	ssh1_3des.cleanup = ssh1_3des_cleanup;
	ssh1_3des.do_cipher = ssh1_3des_cbc;
	ssh1_3des.flags = EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH;
	return (&ssh1_3des);
}

/*
 * SSH1 uses a variation on Blowfish, all bytes must be swapped before
 * and after encryption/decryption. Thus the swap_bytes stuff (yuk).
 */
static void
swap_bytes(const u_char *src, u_char *dst, int n)
{
	u_char c[4];

	/* Process 4 bytes every lap. */
	for (n = n / 4; n > 0; n--) {
		c[3] = *src++;
		c[2] = *src++;
		c[1] = *src++;
		c[0] = *src++;

		*dst++ = c[0];
		*dst++ = c[1];
		*dst++ = c[2];
		*dst++ = c[3];
	}
}
static int (*orig_bf)(EVP_CIPHER_CTX *, u_char *, const u_char *, u_int) = NULL;
static int
bf_ssh1_cipher(EVP_CIPHER_CTX *ctx, u_char *out, const u_char *in, u_int len)
{
	int ret;

	swap_bytes(in, out, len);
	ret = (*orig_bf)(ctx, out, out, len);
	swap_bytes(out, out, len);
	return (ret);
}
static EVP_CIPHER *
evp_ssh1_bf(void)
{
	static EVP_CIPHER ssh1_bf;

	memcpy(&ssh1_bf, EVP_bf_cbc(), sizeof(EVP_CIPHER));
	orig_bf = ssh1_bf.do_cipher;
	ssh1_bf.nid = NID_undef;
	ssh1_bf.do_cipher = bf_ssh1_cipher;
	ssh1_bf.key_len = 32;
	return (&ssh1_bf);
}

/* RIJNDAEL */
#define RIJNDAEL_BLOCKSIZE 16
struct ssh_rijndael_ctx
{
	rijndael_ctx	r_ctx;
	u_char		r_iv[RIJNDAEL_BLOCKSIZE];
};

static int
ssh_rijndael_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,
    int enc)
{
	struct ssh_rijndael_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		c = xmalloc(sizeof(*c));
		EVP_CIPHER_CTX_set_app_data(ctx, c);
	}
	if (key != NULL) {
		if (enc == -1)
			enc = ctx->encrypt;
		rijndael_set_key(&c->r_ctx, (u_char *)key,
		    8*EVP_CIPHER_CTX_key_length(ctx), enc);
	}
	if (iv != NULL)
		memcpy(c->r_iv, iv, RIJNDAEL_BLOCKSIZE);
	return (1);
}
static int
ssh_rijndael_cbc(EVP_CIPHER_CTX *ctx, u_char *dest, const u_char *src,
    u_int len)
{
	struct ssh_rijndael_ctx *c;
	u_char buf[RIJNDAEL_BLOCKSIZE];
	u_char *cprev, *cnow, *plain, *ivp;
	int i, j, blocks = len / RIJNDAEL_BLOCKSIZE;

	if (len == 0)
		return (1);
	if (len % RIJNDAEL_BLOCKSIZE)
		fatal("ssh_rijndael_cbc: bad len %d", len);
	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		error("ssh_rijndael_cbc: no context");
		return (0);
	}
	if (ctx->encrypt) {
		cnow  = dest;
		plain = (u_char *)src;
		cprev = c->r_iv;
		for (i = 0; i < blocks; i++, plain+=RIJNDAEL_BLOCKSIZE,
		    cnow+=RIJNDAEL_BLOCKSIZE) {
			for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
				buf[j] = plain[j] ^ cprev[j];
			rijndael_encrypt(&c->r_ctx, buf, cnow);
			cprev = cnow;
		}
		memcpy(c->r_iv, cprev, RIJNDAEL_BLOCKSIZE);
	} else {
		cnow  = (u_char *) (src+len-RIJNDAEL_BLOCKSIZE);
		plain = dest+len-RIJNDAEL_BLOCKSIZE;

		memcpy(buf, cnow, RIJNDAEL_BLOCKSIZE);
		for (i = blocks; i > 0; i--, cnow-=RIJNDAEL_BLOCKSIZE,
		    plain-=RIJNDAEL_BLOCKSIZE) {
			rijndael_decrypt(&c->r_ctx, cnow, plain);
			ivp = (i == 1) ? c->r_iv : cnow-RIJNDAEL_BLOCKSIZE;
			for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
				plain[j] ^= ivp[j];
		}
		memcpy(c->r_iv, buf, RIJNDAEL_BLOCKSIZE);
	}
	return (1);
}
static int
ssh_rijndael_cleanup(EVP_CIPHER_CTX *ctx)
{
	struct ssh_rijndael_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) != NULL) {
		memset(c, 0, sizeof(*c));
		xfree(c);
		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
	}
	return (1);
}
static EVP_CIPHER *
evp_rijndael(void)
{
	static EVP_CIPHER rijndal_cbc;

	memset(&rijndal_cbc, 0, sizeof(EVP_CIPHER));
	rijndal_cbc.nid = NID_undef;
	rijndal_cbc.block_size = RIJNDAEL_BLOCKSIZE;
	rijndal_cbc.iv_len = RIJNDAEL_BLOCKSIZE;
	rijndal_cbc.key_len = 16;
	rijndal_cbc.init = ssh_rijndael_init;
	rijndal_cbc.cleanup = ssh_rijndael_cleanup;
	rijndal_cbc.do_cipher = ssh_rijndael_cbc;
	rijndal_cbc.flags = EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH |
	    EVP_CIPH_ALWAYS_CALL_INIT;
	return (&rijndal_cbc);
@


1.43.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.55 2002/04/03 09:26:11 markus Exp $");
a69 2
	{ "rijndael-cbc@@lysator.liu.se",
				SSH_CIPHER_SSH2, 16, 32, evp_rijndael },
d76 1
a76 1
u_int
d81 1
a81 1
u_int
a85 5
u_int
cipher_get_number(Cipher *c)
{
	return (c->number);
}
a499 168
}

/*
 * Exports an IV from the CipherContext required to export the key
 * state back from the unprivileged child to the privileged parent
 * process.
 */

int
cipher_get_keyiv_len(CipherContext *cc)
{
	Cipher *c = cc->cipher;
	int ivlen;

	if (c->number == SSH_CIPHER_3DES)
		ivlen = 24;
	else
		ivlen = EVP_CIPHER_CTX_iv_length(&cc->evp);
	return (ivlen);
}

void
cipher_get_keyiv(CipherContext *cc, u_char *iv, u_int len)
{
	Cipher *c = cc->cipher;
	u_char *civ = NULL;
	int evplen;

	switch (c->number) {
	case SSH_CIPHER_SSH2:
	case SSH_CIPHER_DES:
	case SSH_CIPHER_BLOWFISH:
		evplen = EVP_CIPHER_CTX_iv_length(&cc->evp);
		if (evplen == 0)
			return;
		if (evplen != len)
			fatal("%s: wrong iv length %d != %d", __FUNCTION__,
			    evplen, len);

		if (c->evptype == evp_rijndael) {
			struct ssh_rijndael_ctx *aesc;

			aesc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
			if (aesc == NULL)
				fatal("%s: no rijndael context", __FUNCTION__);
			civ = aesc->r_iv;
		} else {
			civ = cc->evp.iv;
		}
		break;
	case SSH_CIPHER_3DES: {
		struct ssh1_3des_ctx *desc;
		if (len != 24)
			fatal("%s: bad 3des iv length: %d", __FUNCTION__, len);
		desc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
		if (desc == NULL)
			fatal("%s: no 3des context", __FUNCTION__);
		debug3("%s: Copying 3DES IV", __FUNCTION__);
		memcpy(iv, desc->k1.iv, 8);
		memcpy(iv + 8, desc->k2.iv, 8);
		memcpy(iv + 16, desc->k3.iv, 8);
		return;
	}
	default:
		fatal("%s: bad cipher %d", __FUNCTION__, c->number);
	}
	memcpy(iv, civ, len);
}

void
cipher_set_keyiv(CipherContext *cc, u_char *iv)
{
	Cipher *c = cc->cipher;
	u_char *div = NULL;
	int evplen = 0;

	switch (c->number) {
	case SSH_CIPHER_SSH2:
	case SSH_CIPHER_DES:
	case SSH_CIPHER_BLOWFISH:
		evplen = EVP_CIPHER_CTX_iv_length(&cc->evp);
		if (evplen == 0)
			return;

		if (c->evptype == evp_rijndael) {
			struct ssh_rijndael_ctx *aesc;

			aesc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
			if (aesc == NULL)
				fatal("%s: no rijndael context", __FUNCTION__);
			div = aesc->r_iv;
		}else {
			div = cc->evp.iv;
		}
		break;
	case SSH_CIPHER_3DES: {
		struct ssh1_3des_ctx *desc;
		desc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
		if (desc == NULL)
			fatal("%s: no 3des context", __FUNCTION__);
		debug3("%s: Installed 3DES IV", __FUNCTION__);
		memcpy(desc->k1.iv, iv, 8);
		memcpy(desc->k2.iv, iv + 8, 8);
		memcpy(desc->k3.iv, iv + 16, 8);
		return;
	}
	default:
		fatal("%s: bad cipher %d", __FUNCTION__, c->number);
	}
	memcpy(div, iv, evplen);
}

#if OPENSSL_VERSION_NUMBER < 0x00907000L
#define EVP_X_STATE(evp)	&(evp).c
#define EVP_X_STATE_LEN(evp)	sizeof((evp).c)
#else
#define EVP_X_STATE(evp)	(evp).cipher_data
#define EVP_X_STATE_LEN(evp)	(evp).cipher->ctx_size
#endif

int
cipher_get_keycontext(CipherContext *cc, u_char *dat)
{
	Cipher *c = cc->cipher;
	int plen;

	if (c->number == SSH_CIPHER_3DES) {
		struct ssh1_3des_ctx *desc;
		desc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
		if (desc == NULL)
			fatal("%s: no 3des context", __FUNCTION__);
		plen = EVP_X_STATE_LEN(desc->k1);
		if (dat == NULL)
			return (3*plen);
		memcpy(dat, EVP_X_STATE(desc->k1), plen);
		memcpy(dat + plen, EVP_X_STATE(desc->k2), plen);
		memcpy(dat + 2*plen, EVP_X_STATE(desc->k3), plen);
		return (3*plen);
	}

	/* Generic EVP */
	plen = EVP_X_STATE_LEN(cc->evp);
	if (dat == NULL)
		return (plen);

	memcpy(dat, EVP_X_STATE(cc->evp), plen);
	return (plen);
}

void
cipher_set_keycontext(CipherContext *cc, u_char *dat)
{
	Cipher *c = cc->cipher;
	int plen;

	if (c->number == SSH_CIPHER_3DES) {
		struct ssh1_3des_ctx *desc;
		desc = EVP_CIPHER_CTX_get_app_data(&cc->evp);
		if (desc == NULL)
			fatal("%s: no 3des context", __FUNCTION__);
		plen = EVP_X_STATE_LEN(desc->k1);
		memcpy(EVP_X_STATE(desc->k1), dat, plen);
		memcpy(EVP_X_STATE(desc->k2), dat + plen, plen);
		memcpy(EVP_X_STATE(desc->k3), dat + 2*plen, plen);
	} else {
		plen = EVP_X_STATE_LEN(cc->evp);
		memcpy(EVP_X_STATE(cc->evp), dat, plen);
	}
@


1.42
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.41 2000/12/19 23:17:56 markus Exp $");
d269 1
a269 1
	if (iv == NULL) 
d298 1
a298 1
	if (iv == NULL) 
d418 1
a418 1
        { NULL, SSH_CIPHER_ILLEGAL, 0, 0, NULL, NULL, NULL, NULL }
@


1.41
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.40 2000/12/09 13:41:52 markus Exp $");
a39 1
#include "ssh.h"
d41 2
@


1.40
log
@undo rijndael changes
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.38 2000/11/29 20:39:17 markus Exp $");
d180 1
a180 1
	BF_set_key(&cc->u.bf.key, keylen, (unsigned char *)key);
d210 1
a210 1
swap_bytes(const unsigned char *src, unsigned char *dst, int n)
d263 1
a263 1
	CAST_set_key(&cc->u.cast.key, keylen, (unsigned char *) key);
d422 1
a422 1
unsigned int
d425 1
a425 1
	unsigned int mask = 0;
d544 1
a544 1
	unsigned char digest[16];
@


1.39
log
@new rijndael implementation. fixes endian bugs
@
text
@a287 1

d291 2
a292 6
	if (rijndael_makekey(&cc->u.rijndael.enc, RIJNDAEL_ENCRYPT,
		    8*keylen, (char *)key) == -1)
		fatal("rijndael_setkey: RIJNDAEL_ENCRYPT");
	if (rijndael_makekey(&cc->u.rijndael.dec, RIJNDAEL_DECRYPT,
		    8*keylen, (char *)key) == -1)
		fatal("rijndael_setkey: RIJNDAEL_DECRYPT");
d297 3
a299 3
	if (iv == NULL || ivlen != RIJNDAEL_BLOCKSIZE) 
		fatal("bad/no IV for %s.", cc->cipher->name);
	memcpy(cc->u.rijndael.iv, iv, RIJNDAEL_BLOCKSIZE);
a300 1

d305 5
a309 5
	rijndael_key *ctx = &cc->u.rijndael.enc;
	u_char *iv = cc->u.rijndael.iv;
	u_char in[RIJNDAEL_BLOCKSIZE];
	u_char *cprev, *cnow, *plain;
	int i, j, blocks = len / RIJNDAEL_BLOCKSIZE;
d314 2
a315 2
	cnow  = dest;
	plain = (u_char *) src;
d317 5
a321 4
	for(i = 0; i < blocks; i++, plain+=RIJNDAEL_BLOCKSIZE,
	    cnow+=RIJNDAEL_BLOCKSIZE) {
		for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
			in[j] = plain[j] ^ cprev[j];
d332 7
a338 7
	rijndael_key *ctx = &cc->u.rijndael.dec;
	u_char *iv = cc->u.rijndael.iv;
	u_char ivsaved[RIJNDAEL_BLOCKSIZE];
	u_char *cnow  = (u_char *) (src+len-RIJNDAEL_BLOCKSIZE);
	u_char *plain = dest+len-RIJNDAEL_BLOCKSIZE;
	u_char *ivp;
	int i, j, blocks = len / RIJNDAEL_BLOCKSIZE;
d344 1
a344 2
	for(i = blocks; i > 0; i--, cnow-=RIJNDAEL_BLOCKSIZE,
	    plain-=RIJNDAEL_BLOCKSIZE) {
d346 5
a350 4
		//rijndael_decrypt(cnow, plain, ctx->keySched, ctx->ROUNDS);
		ivp = (i == 1) ? iv : cnow-RIJNDAEL_BLOCKSIZE;
		for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
			plain[j] ^= ivp[j];
@


1.38
log
@des_cbc_encrypt -> des_ncbc_encrypt since it already updates the IV
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.37 2000/10/23 19:31:54 markus Exp $");
d288 1
d292 6
a297 2
	rijndael_set_key(&cc->u.rijndael.enc, (u4byte *)key, 8*keylen, 1);
	rijndael_set_key(&cc->u.rijndael.dec, (u4byte *)key, 8*keylen, 0);
d302 3
a304 3
	if (iv == NULL) 
		fatal("no IV for %s.", cc->cipher->name);
	memcpy((u_char *)cc->u.rijndael.iv, iv, RIJNDAEL_BLOCKSIZE);
d306 1
d311 5
a315 5
	rijndael_ctx *ctx = &cc->u.rijndael.enc;
	u4byte *iv = cc->u.rijndael.iv;
	u4byte in[4];
	u4byte *cprev, *cnow, *plain;
	int i, blocks = len / RIJNDAEL_BLOCKSIZE;
d320 2
a321 2
	cnow  = (u4byte*) dest;
	plain = (u4byte*) src;
d323 4
a326 5
	for(i = 0; i < blocks; i++, plain+=4, cnow+=4) {
		in[0] = plain[0] ^ cprev[0];
		in[1] = plain[1] ^ cprev[1];
		in[2] = plain[2] ^ cprev[2];
		in[3] = plain[3] ^ cprev[3];
d337 7
a343 7
	rijndael_ctx *ctx = &cc->u.rijndael.dec;
	u4byte *iv = cc->u.rijndael.iv;
	u4byte ivsaved[4];
	u4byte *cnow =  (u4byte*) (src+len-RIJNDAEL_BLOCKSIZE);
	u4byte *plain = (u4byte*) (dest+len-RIJNDAEL_BLOCKSIZE);
	u4byte *ivp;
	int i, blocks = len / RIJNDAEL_BLOCKSIZE;
d349 2
a350 1
	for(i = blocks; i > 0; i--, cnow-=4, plain-=4) {
d352 4
a355 5
		ivp =  (i == 1) ? iv : cnow-4;
		plain[0] ^= ivp[0];
		plain[1] ^= ivp[1];
		plain[2] ^= ivp[2];
		plain[3] ^= ivp[3];
@


1.37
log
@non-alignment dependent swap_bytes(); from simonb@@wasabisystems.com/netbsd
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.36 2000/10/14 10:01:15 markus Exp $");
d157 3
a159 8
	des_cbc_encrypt(src, dest, len, cc->u.des3.key1, &iv1, DES_ENCRYPT);
	memcpy(&iv1, dest + len - 8, 8);

	des_cbc_encrypt(dest, dest, len, cc->u.des3.key2, iv2, DES_DECRYPT);
	memcpy(iv2, &iv1, 8);	/* Note how iv1 == iv2 on entry and exit. */

	des_cbc_encrypt(dest, dest, len, cc->u.des3.key3, iv3, DES_ENCRYPT);
	memcpy(iv3, dest + len - 8, 8);
d171 3
a173 9
	des_cbc_encrypt(src, dest, len, cc->u.des3.key3, iv3, DES_DECRYPT);
	memcpy(iv3, src + len - 8, 8);

	des_cbc_encrypt(dest, dest, len, cc->u.des3.key2, iv2, DES_ENCRYPT);
	memcpy(iv2, dest + len - 8, 8);

	des_cbc_encrypt(dest, dest, len, cc->u.des3.key1, &iv1, DES_DECRYPT);
	/* memcpy(&iv1, iv2, 8); */
	/* Note how iv1 == iv2 on entry and exit. */
@


1.37.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.43 2001/02/04 15:32:23 stevesk Exp $");
d40 1
a41 2
#include "log.h"
#include "cipher.h"
d157 8
a164 3
	des_ncbc_encrypt(src,  dest, len, cc->u.des3.key1, &iv1, DES_ENCRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key2, iv2, DES_DECRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key3, iv3, DES_ENCRYPT);
d176 9
a184 3
	des_ncbc_encrypt(src,  dest, len, cc->u.des3.key3, iv3, DES_DECRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key2, iv2, DES_ENCRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key1, &iv1, DES_DECRYPT);
d191 1
a191 1
	BF_set_key(&cc->u.bf.key, keylen, (u_char *)key);
d221 1
a221 1
swap_bytes(const u_char *src, u_char *dst, int n)
d274 1
a274 1
	CAST_set_key(&cc->u.cast.key, keylen, (u_char *) key);
d279 1
a279 1
	if (iv == NULL)
d308 1
a308 1
	if (iv == NULL)
d428 1
a428 1
	{ NULL, SSH_CIPHER_ILLEGAL, 0, 0, NULL, NULL, NULL, NULL }
d433 1
a433 1
u_int
d436 1
a436 1
	u_int mask = 0;
d555 1
a555 1
	u_char digest[16];
@


1.37.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.37.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.37.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.37.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d14 1
a14 1
 * Copyright (c) 1999, 2000 Markus Friedl.  All rights reserved.
d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.47 2001/08/23 11:31:59 markus Exp $");
d46 1
d48 1
a48 1
static void
d52 1
a52 1
static void
d56 1
a56 1
static void
d63 1
a63 1
static void
d74 1
a74 1
static void
d79 1
a79 1
static void
d85 1
a85 1
static void
d93 1
a93 1
static void
d100 1
a100 1
static void
a102 1
	memset(cc->u.des3.iv1, 0, sizeof(cc->u.des3.iv1));
d109 1
a109 1
static void
d116 1
a116 1
static void
d138 1
a138 1
static void
d148 1
a148 1
static void
d152 9
a160 6
	des_ncbc_encrypt(src,  dest, len, cc->u.des3.key1, &cc->u.des3.iv1,
	    DES_ENCRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key2, &cc->u.des3.iv2,
	    DES_DECRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key3, &cc->u.des3.iv3,
	    DES_ENCRYPT);
d162 1
a162 1
static void
d166 9
a174 6
	des_ncbc_encrypt(src,  dest, len, cc->u.des3.key3, &cc->u.des3.iv3,
	    DES_DECRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key2, &cc->u.des3.iv2,
	    DES_ENCRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key1, &cc->u.des3.iv1,
	    DES_DECRYPT);
d178 1
a178 1
static void
d183 1
a183 1
static void
d191 1
a191 1
static void
d198 1
a198 1
static void
d229 1
a229 1
static void
d238 1
a238 1
static void
d249 1
a249 1
static void
d254 1
a254 1
static void
d261 1
a261 1
static void
d266 1
a266 1
static void
d273 1
a273 1
static void
d279 1
a279 1
static void
d289 1
a289 1
static void
d292 2
a293 2
	rijndael_set_key(&cc->u.rijndael.enc, (char *)key, 8*keylen, 1);
	rijndael_set_key(&cc->u.rijndael.dec, (char *)key, 8*keylen, 0);
d295 1
a295 1
static void
d298 3
a300 3
	if (iv == NULL || ivlen != RIJNDAEL_BLOCKSIZE) 
		fatal("bad/no IV for %s.", cc->cipher->name);
	memcpy(cc->u.rijndael.iv, iv, RIJNDAEL_BLOCKSIZE);
d302 1
a302 1
static void
d307 4
a310 5
	u_char *iv = cc->u.rijndael.iv;
	u_char in[RIJNDAEL_BLOCKSIZE];
	u_char *cprev, *cnow, *plain;
	int i, j, blocks = len / RIJNDAEL_BLOCKSIZE;

d315 2
a316 2
	cnow  = dest;
	plain = (u_char *) src;
d318 5
a322 4
	for (i = 0; i < blocks; i++, plain+=RIJNDAEL_BLOCKSIZE,
	    cnow+=RIJNDAEL_BLOCKSIZE) {
		for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
			in[j] = plain[j] ^ cprev[j];
d328 2
a329 1
static void
d334 6
a339 7
	u_char *iv = cc->u.rijndael.iv;
	u_char ivsaved[RIJNDAEL_BLOCKSIZE];
	u_char *cnow  = (u_char *) (src+len-RIJNDAEL_BLOCKSIZE);
	u_char *plain = dest+len-RIJNDAEL_BLOCKSIZE;
	u_char *ivp;
	int i, j, blocks = len / RIJNDAEL_BLOCKSIZE;

d345 1
a345 2
	for (i = blocks; i > 0; i--, cnow-=RIJNDAEL_BLOCKSIZE,
	    plain-=RIJNDAEL_BLOCKSIZE) {
d347 5
a351 3
		ivp = (i == 1) ? iv : cnow-RIJNDAEL_BLOCKSIZE;
		for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
			plain[j] ^= ivp[j];
@


1.37.2.6
log
@Merge OpenSSH 3.1.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.52 2002/02/18 13:05:32 markus Exp $");
a43 2
#define EVP_CIPHER_CTX_get_app_data(e)          ((e)->app_data)
 
a44 1
#include "rijndael.h"
d46 153
a198 23
static EVP_CIPHER *evp_ssh1_3des(void);
static EVP_CIPHER *evp_ssh1_bf(void);
static EVP_CIPHER *evp_rijndael(void);

struct Cipher {
	char	*name;
	int	number;		/* for ssh1 only */
	u_int	block_size;
	u_int	key_len;
	EVP_CIPHER	*(*evptype)(void);
} ciphers[] = {
	{ "none", 		SSH_CIPHER_NONE, 8, 0, EVP_enc_null },
	{ "des", 		SSH_CIPHER_DES, 8, 8, EVP_des_cbc },
	{ "3des", 		SSH_CIPHER_3DES, 8, 16, evp_ssh1_3des },
	{ "blowfish", 		SSH_CIPHER_BLOWFISH, 8, 32, evp_ssh1_bf },

	{ "3des-cbc", 		SSH_CIPHER_SSH2, 8, 24, EVP_des_ede3_cbc },
	{ "blowfish-cbc", 	SSH_CIPHER_SSH2, 8, 16, EVP_bf_cbc },
	{ "cast128-cbc", 	SSH_CIPHER_SSH2, 8, 16, EVP_cast5_cbc },
	{ "arcfour", 		SSH_CIPHER_SSH2, 8, 16, EVP_rc4 },
	{ "aes128-cbc", 	SSH_CIPHER_SSH2, 16, 16, evp_rijndael },
	{ "aes192-cbc", 	SSH_CIPHER_SSH2, 16, 24, evp_rijndael },
	{ "aes256-cbc", 	SSH_CIPHER_SSH2, 16, 32, evp_rijndael },
d200 79
a278 2
	{ NULL,			SSH_CIPHER_ILLEGAL, 0, 0, NULL }
};
d280 1
a280 1
/*--*/
d282 9
a290 2
u_int	
cipher_blocksize(Cipher *c)
d292 3
a294 1
	return (c->block_size);
d296 3
a298 2
u_int	
cipher_keylen(Cipher *c)
d300 21
a320 1
	return (c->key_len);
d322 93
d420 1
a420 1
	mask |= 1 << SSH_CIPHER_3DES;		/* Mandatory */
d460 1
a460 1
	    (p = strsep(&cp, CIPHER_SEP))) {
d499 1
a499 2
    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen,
    int encrypt)
a500 15
	static int dowarn = 1;
	const EVP_CIPHER *type;
	int klen;

	if (cipher->number == SSH_CIPHER_DES) {
		if (dowarn) {
			error("Warning: use of DES is strongly discouraged "
			    "due to cryptographic weaknesses");
			dowarn = 0;
		}
		if (keylen > 8)
			keylen = 8;
	}
	cc->plaintext = (cipher->number == SSH_CIPHER_NONE);

d508 2
a509 6

	type = (*cipher->evptype)();

	EVP_CIPHER_CTX_init(&cc->evp);
	EVP_CipherInit(&cc->evp, type, (u_char *)key, (u_char *)iv,
	    (encrypt == CIPHER_ENCRYPT));
d513 1
a513 1
cipher_crypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
d517 1
a517 1
	EVP_Cipher(&cc->evp, dest, (u_char *)src, len);
d521 1
a521 1
cipher_cleanup(CipherContext *cc)
d523 3
a525 1
	EVP_CIPHER_CTX_cleanup(&cc->evp);
d535 1
a535 1
    const char *passphrase, int encrypt)
d544 1
a544 1
	cipher_init(cc, cipher, digest, 16, NULL, 0, encrypt);
a547 240
}

/* Implementations for other non-EVP ciphers */

/*
 * This is used by SSH1:
 *
 * What kind of triple DES are these 2 routines?
 *
 * Why is there a redundant initialization vector?
 *
 * If only iv3 was used, then, this would till effect have been
 * outer-cbc. However, there is also a private iv1 == iv2 which
 * perhaps makes differential analysis easier. On the other hand, the
 * private iv1 probably makes the CRC-32 attack ineffective. This is a
 * result of that there is no longer any known iv1 to use when
 * choosing the X block.
 */
struct ssh1_3des_ctx
{
	EVP_CIPHER_CTX	k1, k2, k3;
};
static int
ssh1_3des_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,
    int enc)
{
	struct ssh1_3des_ctx *c;
	u_char *k1, *k2, *k3;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		c = xmalloc(sizeof(*c));
		EVP_CIPHER_CTX_set_app_data(ctx, c);
	}
	if (key == NULL)
		return (1);
	if (enc == -1)
		enc = ctx->encrypt;
	k1 = k2 = k3 = (u_char *) key;
	k2 += 8;
	if (EVP_CIPHER_CTX_key_length(ctx) >= 16+8) {
		if (enc)
			k3 += 16;
		else
			k1 += 16;
	}
	EVP_CIPHER_CTX_init(&c->k1);
	EVP_CIPHER_CTX_init(&c->k2);
	EVP_CIPHER_CTX_init(&c->k3);
	EVP_CipherInit(&c->k1, EVP_des_cbc(), k1, NULL, enc);
	EVP_CipherInit(&c->k2, EVP_des_cbc(), k2, NULL, !enc);
	EVP_CipherInit(&c->k3, EVP_des_cbc(), k3, NULL, enc);
	return (1);
}
static int
ssh1_3des_cbc(EVP_CIPHER_CTX *ctx, u_char *dest, const u_char *src, u_int len)
{
	struct ssh1_3des_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		error("ssh1_3des_cbc: no context");
		return (0);
	}
	EVP_Cipher(&c->k1, dest, (u_char *)src, len);
	EVP_Cipher(&c->k2, dest, dest, len);
	EVP_Cipher(&c->k3, dest, dest, len);
	return (1);
}
static int
ssh1_3des_cleanup(EVP_CIPHER_CTX *ctx)
{
	struct ssh1_3des_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) != NULL) {
		memset(c, 0, sizeof(*c));
		xfree(c);
		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
	}
	return (1);
}
static EVP_CIPHER *
evp_ssh1_3des(void)
{
	static EVP_CIPHER ssh1_3des;

	memset(&ssh1_3des, 0, sizeof(EVP_CIPHER));
	ssh1_3des.nid = NID_undef;
	ssh1_3des.block_size = 8;
	ssh1_3des.iv_len = 0;
	ssh1_3des.key_len = 16;
	ssh1_3des.init = ssh1_3des_init;
	ssh1_3des.cleanup = ssh1_3des_cleanup;
	ssh1_3des.do_cipher = ssh1_3des_cbc;
	return (&ssh1_3des);
}

/*
 * SSH1 uses a variation on Blowfish, all bytes must be swapped before
 * and after encryption/decryption. Thus the swap_bytes stuff (yuk).
 */
static void
swap_bytes(const u_char *src, u_char *dst, int n)
{
	u_char c[4];

	/* Process 4 bytes every lap. */
	for (n = n / 4; n > 0; n--) {
		c[3] = *src++;
		c[2] = *src++;
		c[1] = *src++;
		c[0] = *src++;

		*dst++ = c[0];
		*dst++ = c[1];
		*dst++ = c[2];
		*dst++ = c[3];
	}
}
static int (*orig_bf)(EVP_CIPHER_CTX *, u_char *, const u_char *, u_int) = NULL;
static int
bf_ssh1_cipher(EVP_CIPHER_CTX *ctx, u_char *out, const u_char *in, u_int len)
{
	int ret;

	swap_bytes(in, out, len);
	ret = (*orig_bf)(ctx, out, out, len);
	swap_bytes(out, out, len);
	return (ret);
}
static EVP_CIPHER *
evp_ssh1_bf(void)
{
	static EVP_CIPHER ssh1_bf;

	memcpy(&ssh1_bf, EVP_bf_cbc(), sizeof(EVP_CIPHER));
	orig_bf = ssh1_bf.do_cipher;
	ssh1_bf.nid = NID_undef;
	ssh1_bf.do_cipher = bf_ssh1_cipher;
	ssh1_bf.key_len = 32;
	return (&ssh1_bf);
}

/* RIJNDAEL */
#define RIJNDAEL_BLOCKSIZE 16
struct ssh_rijndael_ctx
{
	rijndael_ctx	r_ctx;
	u_char		r_iv[RIJNDAEL_BLOCKSIZE];
};

static int
ssh_rijndael_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,
    int enc)
{
	struct ssh_rijndael_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		c = xmalloc(sizeof(*c));
		EVP_CIPHER_CTX_set_app_data(ctx, c);
	}
	if (key != NULL) {
		if (enc == -1)
			enc = ctx->encrypt;
		rijndael_set_key(&c->r_ctx, (u_char *)key,
		    8*EVP_CIPHER_CTX_key_length(ctx), enc);
	}
	if (iv != NULL)
		memcpy(c->r_iv, iv, RIJNDAEL_BLOCKSIZE);
	return (1);
}
static int
ssh_rijndael_cbc(EVP_CIPHER_CTX *ctx, u_char *dest, const u_char *src,
    u_int len)
{
	struct ssh_rijndael_ctx *c;
	u_char buf[RIJNDAEL_BLOCKSIZE];
	u_char *cprev, *cnow, *plain, *ivp;
	int i, j, blocks = len / RIJNDAEL_BLOCKSIZE;

	if (len == 0)
		return (1);
	if (len % RIJNDAEL_BLOCKSIZE)
		fatal("ssh_rijndael_cbc: bad len %d", len);
	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
		error("ssh_rijndael_cbc: no context");
		return (0);
	}
	if (ctx->encrypt) {
		cnow  = dest;
		plain = (u_char *)src;
		cprev = c->r_iv;
		for (i = 0; i < blocks; i++, plain+=RIJNDAEL_BLOCKSIZE,
		    cnow+=RIJNDAEL_BLOCKSIZE) {
			for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
				buf[j] = plain[j] ^ cprev[j];
			rijndael_encrypt(&c->r_ctx, buf, cnow);
			cprev = cnow;
		}
		memcpy(c->r_iv, cprev, RIJNDAEL_BLOCKSIZE);
	} else {
		cnow  = (u_char *) (src+len-RIJNDAEL_BLOCKSIZE);
		plain = dest+len-RIJNDAEL_BLOCKSIZE;

		memcpy(buf, cnow, RIJNDAEL_BLOCKSIZE);
		for (i = blocks; i > 0; i--, cnow-=RIJNDAEL_BLOCKSIZE,
		    plain-=RIJNDAEL_BLOCKSIZE) {
			rijndael_decrypt(&c->r_ctx, cnow, plain);
			ivp = (i == 1) ? c->r_iv : cnow-RIJNDAEL_BLOCKSIZE;
			for (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)
				plain[j] ^= ivp[j];
		}
		memcpy(c->r_iv, buf, RIJNDAEL_BLOCKSIZE);
	}
	return (1);
}
static int
ssh_rijndael_cleanup(EVP_CIPHER_CTX *ctx)
{
	struct ssh_rijndael_ctx *c;

	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) != NULL) {
		memset(c, 0, sizeof(*c));
		xfree(c);
		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
	}
	return (1);
}
static EVP_CIPHER *
evp_rijndael(void)
{
	static EVP_CIPHER rijndal_cbc;

	memset(&rijndal_cbc, 0, sizeof(EVP_CIPHER));
	rijndal_cbc.nid = NID_undef;
	rijndal_cbc.block_size = RIJNDAEL_BLOCKSIZE;
	rijndal_cbc.iv_len = RIJNDAEL_BLOCKSIZE;
	rijndal_cbc.key_len = 16;
	rijndal_cbc.init = ssh_rijndael_init;
	rijndal_cbc.cleanup = ssh_rijndael_cleanup;
	rijndal_cbc.do_cipher = ssh_rijndael_cbc;
	return (&rijndal_cbc);
@


1.36
log
@debug3
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.35 2000/10/13 18:59:13 markus Exp $");
d221 1
a221 1
swap_bytes(const unsigned char *src, unsigned char *dst_, int n)
d223 13
a235 20
	/* dst must be properly aligned. */
	u_int32_t *dst = (u_int32_t *) dst_;
	union {
		u_int32_t i;
		char c[4];
	} t;

	/* Process 8 bytes every lap. */
	for (n = n / 8; n > 0; n--) {
		t.c[3] = *src++;
		t.c[2] = *src++;
		t.c[1] = *src++;
		t.c[0] = *src++;
		*dst++ = t.i;

		t.c[3] = *src++;
		t.c[2] = *src++;
		t.c[1] = *src++;
		t.c[0] = *src++;
		*dst++ = t.i;
@


1.35
log
@rijndael/aes support
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.34 2000/10/12 09:59:18 markus Exp $");
d491 1
a491 1
			debug("cipher ok: %s [%s]", p, names);
d494 1
a494 1
	debug("ciphers ok: [%s]", names);
@


1.34
log
@enable DES in SSH-1 clients only
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.32 2000/10/11 20:27:23 markus Exp $");
d303 69
a371 1
/*--*/
d407 28
@


1.33
log
@remove DES
@
text
@d65 6
d310 4
d345 1
a345 1
cipher_mask1()
d348 4
a351 4
	Cipher *c;
	for (c = ciphers; c->name != NULL; c++) {
		if (c->number > SSH_CIPHER_NONE)
			mask |= 1 << c->number;
a359 3
	if (strcmp(name, "des") == 0)
		error("Warning: use of DES is strongly discouraged "
		    "due to cryptographic weaknesses");
@


1.32
log
@new cipher framework
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.31 2000/09/12 00:38:32 deraadt Exp $");
a303 4
	{ "des",
		SSH_CIPHER_DES, 8, 8,
		des_ssh1_setkey, des_ssh1_setiv,
		des_ssh1_encrypt, des_ssh1_decrypt },
@


1.31
log
@a few more comments about it being ARC4 not RC4
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.30 2000/09/07 20:27:50 deraadt Exp $");
a40 1
#include "cipher.h"
d45 72
d132 12
a143 5
SSH_3CBC_ENCRYPT(des_key_schedule ks1,
		 des_key_schedule ks2, des_cblock * iv2,
		 des_key_schedule ks3, des_cblock * iv3,
		 unsigned char *dest, unsigned char *src,
		 unsigned int len)
d146 2
d151 1
a151 1
	des_cbc_encrypt(src, dest, len, ks1, &iv1, DES_ENCRYPT);
d154 1
a154 1
	des_cbc_encrypt(dest, dest, len, ks2, iv2, DES_DECRYPT);
d157 1
a157 1
	des_cbc_encrypt(dest, dest, len, ks3, iv3, DES_ENCRYPT);
a159 1

d161 2
a162 5
SSH_3CBC_DECRYPT(des_key_schedule ks1,
		 des_key_schedule ks2, des_cblock * iv2,
		 des_key_schedule ks3, des_cblock * iv3,
		 unsigned char *dest, unsigned char *src,
		 unsigned int len)
d165 2
d170 1
a170 1
	des_cbc_encrypt(src, dest, len, ks3, iv3, DES_DECRYPT);
d173 1
a173 1
	des_cbc_encrypt(dest, dest, len, ks2, iv2, DES_ENCRYPT);
d176 1
a176 1
	des_cbc_encrypt(dest, dest, len, ks1, &iv1, DES_DECRYPT);
d181 29
d240 12
a251 5
/*
 * Names of all encryption algorithms.
 * These must match the numbers defined in cipher.h.
 */
static char *cipher_names[] =
d253 5
a257 13
	"none",
	"idea",
	"des",
	"3des",
	"tss",
	"rc4",		/* Alleged RC4 */
	"blowfish",
	"reserved",
	"blowfish-cbc",
	"3des-cbc",
	"arcfour",
	"cast128-cbc"
};
d259 11
a269 5
/*
 * Returns a bit mask indicating which ciphers are supported by this
 * implementation.  The bit mask has the corresponding bit set of each
 * supported cipher.
 */
d271 8
a278 2
unsigned int
cipher_mask1()
d280 3
a282 4
	unsigned int mask = 0;
	mask |= 1 << SSH_CIPHER_3DES;		/* Mandatory */
	mask |= 1 << SSH_CIPHER_BLOWFISH;
	return mask;
d284 2
a285 2
unsigned int
cipher_mask2()
d287 2
a288 6
	unsigned int mask = 0;
	mask |= 1 << SSH_CIPHER_BLOWFISH_CBC;
	mask |= 1 << SSH_CIPHER_3DES_CBC;
	mask |= 1 << SSH_CIPHER_ARCFOUR;
	mask |= 1 << SSH_CIPHER_CAST128_CBC;
	return mask;
d290 2
a291 2
unsigned int
cipher_mask()
d293 2
a294 1
	return cipher_mask1() | cipher_mask2();
d297 40
a336 1
/* Returns the name of the cipher. */
d338 2
a339 2
const char *
cipher_name(int cipher)
d341 7
a347 4
	if (cipher < 0 || cipher >= sizeof(cipher_names) / sizeof(cipher_names[0]) ||
	    cipher_names[cipher] == NULL)
		fatal("cipher_name: bad cipher name: %d", cipher);
	return cipher_names[cipher];
d350 22
a371 1
/* Returns 1 if the name of the ciphers are valid. */
d377 1
a379 1
	int i;
d384 1
a384 1
	for ((p = strsep(&cp, CIPHER_SEP)); p && *p != '\0'; 
d386 3
a388 2
		i = cipher_number(p);
		if (i == -1 || !(cipher_mask2() & (1 << i))) {
d391 2
d395 1
d408 1
a408 1
	int i;
d411 2
a412 5
	for (i = 0; i < sizeof(cipher_names) / sizeof(cipher_names[0]); i++)
		if (strcmp(cipher_names[i], name) == 0 &&
		    (cipher_mask() & (1 << i)))
			return i;
	return -1;
d415 2
a416 7
/*
 * Selects the cipher, and keys if by computing the MD5 checksum of the
 * passphrase and using the resulting 16 bytes as the key.
 */

void
cipher_set_key_string(CipherContext *context, int cipher, const char *passphrase)
d418 2
a419 11
	MD5_CTX md;
	unsigned char digest[16];

	MD5_Init(&md);
	MD5_Update(&md, (const unsigned char *) passphrase, strlen(passphrase));
	MD5_Final(digest, &md);

	cipher_set_key(context, cipher, digest, 16);

	memset(digest, 0, sizeof(digest));
	memset(&md, 0, sizeof(md));
a421 2
/* Selects the cipher to use and sets the key. */

d423 2
a424 2
cipher_set_key(CipherContext *context, int cipher, const unsigned char *key,
    int keylen)
d426 9
a434 55
	unsigned char padded[32];

	/* Set cipher type. */
	context->type = cipher;

	/* Get 32 bytes of key data.  Pad if necessary.  (So that code
	   below does not need to worry about key size). */
	memset(padded, 0, sizeof(padded));
	memcpy(padded, key, keylen < sizeof(padded) ? keylen : sizeof(padded));

	/* Initialize the initialization vector. */
	switch (cipher) {
	case SSH_CIPHER_NONE:
		/*
		 * Has to stay for authfile saving of private key with no
		 * passphrase
		 */
		break;

	case SSH_CIPHER_3DES:
		/*
		 * Note: the least significant bit of each byte of key is
		 * parity, and must be ignored by the implementation.  16
		 * bytes of key are used (first and last keys are the same).
		 */
		if (keylen < 16)
			error("Key length %d is insufficient for 3DES.", keylen);
		des_set_key((void *) padded, context->u.des3.key1);
		des_set_key((void *) (padded + 8), context->u.des3.key2);
		if (keylen <= 16)
			des_set_key((void *) padded, context->u.des3.key3);
		else
			des_set_key((void *) (padded + 16), context->u.des3.key3);
		memset(context->u.des3.iv2, 0, sizeof(context->u.des3.iv2));
		memset(context->u.des3.iv3, 0, sizeof(context->u.des3.iv3));
		break;

	case SSH_CIPHER_BLOWFISH:
		if (keylen < 16)
			error("Key length %d is insufficient for blowfish.", keylen);
		BF_set_key(&context->u.bf.key, keylen, padded);
		memset(context->u.bf.iv, 0, 8);
		break;

	case SSH_CIPHER_3DES_CBC:
	case SSH_CIPHER_BLOWFISH_CBC:
	case SSH_CIPHER_ARCFOUR:
	case SSH_CIPHER_CAST128_CBC:
		fatal("cipher_set_key: illegal cipher: %s", cipher_name(cipher));
		break;

	default:
		fatal("cipher_set_key: unknown cipher: %s", cipher_name(cipher));
	}
	memset(padded, 0, sizeof(padded));
d438 5
a442 55
cipher_set_key_iv(CipherContext * context, int cipher,
    const unsigned char *key, int keylen,
    const unsigned char *iv, int ivlen)
{
	/* Set cipher type. */
	context->type = cipher;

	/* Initialize the initialization vector. */
	switch (cipher) {
	case SSH_CIPHER_NONE:
		break;

	case SSH_CIPHER_3DES:
	case SSH_CIPHER_BLOWFISH:
		fatal("cipher_set_key_iv: illegal cipher: %s", cipher_name(cipher));
		break;

	case SSH_CIPHER_3DES_CBC:
		if (keylen < 24)
			error("Key length %d is insufficient for 3des-cbc.", keylen);
		des_set_key((void *) key, context->u.des3.key1);
		des_set_key((void *) (key+8), context->u.des3.key2);
		des_set_key((void *) (key+16), context->u.des3.key3);
		if (ivlen < 8)
			error("IV length %d is insufficient for 3des-cbc.", ivlen);
		memcpy(context->u.des3.iv3, (char *)iv, 8);
		break;

	case SSH_CIPHER_BLOWFISH_CBC:
		if (keylen < 16)
			error("Key length %d is insufficient for blowfish.", keylen);
		if (ivlen < 8)
			error("IV length %d is insufficient for blowfish.", ivlen);
		BF_set_key(&context->u.bf.key, keylen, (unsigned char *)key);
		memcpy(context->u.bf.iv, (char *)iv, 8);
		break;

	case SSH_CIPHER_ARCFOUR:
		if (keylen < 16)
			error("Key length %d is insufficient for arcfour.", keylen);
		RC4_set_key(&context->u.rc4, keylen, (unsigned char *)key);
		break;

	case SSH_CIPHER_CAST128_CBC:
		if (keylen < 16)
			error("Key length %d is insufficient for cast128.", keylen);
		if (ivlen < 8)
			error("IV length %d is insufficient for cast128.", ivlen);
		CAST_set_key(&context->u.cast.key, keylen, (unsigned char *) key);
		memcpy(context->u.cast.iv, (char *)iv, 8);
		break;

	default:
		fatal("cipher_set_key: unknown cipher: %s", cipher_name(cipher));
	}
a444 2
/* Encrypts data using the cipher. */

d446 1
a446 2
cipher_encrypt(CipherContext *context, unsigned char *dest,
	       const unsigned char *src, unsigned int len)
d448 3
a450 47
	if ((len & 7) != 0)
		fatal("cipher_encrypt: bad plaintext length %d", len);

	switch (context->type) {
	case SSH_CIPHER_NONE:
		memcpy(dest, src, len);
		break;

	case SSH_CIPHER_3DES:
		SSH_3CBC_ENCRYPT(context->u.des3.key1,
				 context->u.des3.key2, &context->u.des3.iv2,
				 context->u.des3.key3, &context->u.des3.iv3,
				 dest, (unsigned char *) src, len);
		break;

	case SSH_CIPHER_BLOWFISH:
		swap_bytes(src, dest, len);
		BF_cbc_encrypt(dest, dest, len,
			       &context->u.bf.key, context->u.bf.iv,
			       BF_ENCRYPT);
		swap_bytes(dest, dest, len);
		break;

	case SSH_CIPHER_BLOWFISH_CBC:
		BF_cbc_encrypt((void *)src, dest, len,
			       &context->u.bf.key, context->u.bf.iv,
			       BF_ENCRYPT);
		break;

	case SSH_CIPHER_3DES_CBC:
		des_ede3_cbc_encrypt(src, dest, len,
		    context->u.des3.key1, context->u.des3.key2,
		    context->u.des3.key3, &context->u.des3.iv3, DES_ENCRYPT);
		break;

	case SSH_CIPHER_ARCFOUR:
		RC4(&context->u.rc4, len, (unsigned char *)src, dest);
		break;

	case SSH_CIPHER_CAST128_CBC:
		CAST_cbc_encrypt(src, dest, len,
		    &context->u.cast.key, context->u.cast.iv, CAST_ENCRYPT);
		break;

	default:
		fatal("cipher_encrypt: unknown cipher: %s", cipher_name(context->type));
	}
d453 4
a456 1
/* Decrypts data using the cipher. */
d459 2
a460 2
cipher_decrypt(CipherContext *context, unsigned char *dest,
	       const unsigned char *src, unsigned int len)
d462 6
a467 2
	if ((len & 7) != 0)
		fatal("cipher_decrypt: bad ciphertext length %d", len);
d469 1
a469 40
	switch (context->type) {
	case SSH_CIPHER_NONE:
		memcpy(dest, src, len);
		break;

	case SSH_CIPHER_3DES:
		SSH_3CBC_DECRYPT(context->u.des3.key1,
				 context->u.des3.key2, &context->u.des3.iv2,
				 context->u.des3.key3, &context->u.des3.iv3,
				 dest, (unsigned char *) src, len);
		break;

	case SSH_CIPHER_BLOWFISH:
		swap_bytes(src, dest, len);
		BF_cbc_encrypt((void *) dest, dest, len,
			       &context->u.bf.key, context->u.bf.iv,
			       BF_DECRYPT);
		swap_bytes(dest, dest, len);
		break;

	case SSH_CIPHER_BLOWFISH_CBC:
		BF_cbc_encrypt((void *) src, dest, len,
			       &context->u.bf.key, context->u.bf.iv,
			       BF_DECRYPT);
		break;

	case SSH_CIPHER_3DES_CBC:
		des_ede3_cbc_encrypt(src, dest, len,
		    context->u.des3.key1, context->u.des3.key2,
		    context->u.des3.key3, &context->u.des3.iv3, DES_DECRYPT);
		break;

	case SSH_CIPHER_ARCFOUR:
		RC4(&context->u.rc4, len, (unsigned char *)src, dest);
		break;

	case SSH_CIPHER_CAST128_CBC:
		CAST_cbc_encrypt(src, dest, len,
		    &context->u.cast.key, context->u.cast.iv, CAST_DECRYPT);
		break;
d471 2
a472 3
	default:
		fatal("cipher_decrypt: unknown cipher: %s", cipher_name(context->type));
	}
@


1.30
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.29 2000/07/10 16:30:25 ho Exp $");
d144 1
a144 1
	"rc4",
@


1.29
log
@strtok() --> strsep(). (niels@@ ok)
@
text
@d2 3
d6 5
a10 1
 * cipher.c
a11 1
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
d13 2
a14 2
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
d16 8
a23 1
 * Created: Wed Apr 19 17:41:39 1995 ylo
d25 10
d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.28 2000/06/20 01:39:40 markus Exp $");
@


1.28
log
@OpenBSD tag
@
text
@d15 1
a15 1
RCSID("$OpenBSD: cipher.c,v 1.27 2000/05/22 18:42:00 markus Exp $");
d177 1
a177 1
	char *ciphers;
d183 3
a185 2
	ciphers = xstrdup(names);
	for ((p = strtok(ciphers, CIPHER_SEP)); p; (p = strtok(NULL, CIPHER_SEP))) {
@


1.27
log
@check strtok() != NULL; ok niels@@
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.26 2000/04/14 10:30:30 markus Exp $");
@


1.26
log
@whitespace cleanup
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.25 2000/04/12 09:39:10 markus Exp $");
d181 1
a181 1
	if (strcmp(names, "") == 0)
d204 2
@


1.26.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.27 2000/05/22 18:42:00 markus Exp $");
d181 1
a181 1
	if (names == NULL || strcmp(names, "") == 0)
a203 2
	if (name == NULL)
		return -1;
@


1.26.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: cipher.c,v 1.29 2000/07/10 16:30:25 ho Exp $");
d177 1
a177 1
	char *ciphers, *cp;
d183 2
a184 3
	ciphers = cp = xstrdup(names);
	for ((p = strsep(&cp, CIPHER_SEP)); p && *p != '\0'; 
	     (p = strsep(&cp, CIPHER_SEP))) {
@


1.26.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d10 1
a10 9
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
 * Copyright (c) 1999 Niels Provos.  All rights reserved.
 * Copyright (c) 1999,2000 Markus Friedl.  All rights reserved.
a11 19
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d15 1
a15 1
RCSID("$OpenBSD: cipher.c,v 1.37 2000/10/23 19:31:54 markus Exp $");
d18 1
a22 78

/* no encryption */
void
none_setkey(CipherContext *cc, const u_char *key, u_int keylen)
{
}
void
none_setiv(CipherContext *cc, const u_char *iv, u_int ivlen)
{
}
void
none_crypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	memcpy(dest, src, len);
}

/* DES */
void
des_ssh1_setkey(CipherContext *cc, const u_char *key, u_int keylen)
{
	static int dowarn = 1;
	if (dowarn) {
		error("Warning: use of DES is strongly discouraged "
		    "due to cryptographic weaknesses");
		dowarn = 0;
	}
	des_set_key((void *)key, cc->u.des.key);
}
void
des_ssh1_setiv(CipherContext *cc, const u_char *iv, u_int ivlen)
{
	memset(cc->u.des.iv, 0, sizeof(cc->u.des.iv));
}
void
des_ssh1_encrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	des_ncbc_encrypt(src, dest, len, cc->u.des.key, &cc->u.des.iv,
	    DES_ENCRYPT);
}
void
des_ssh1_decrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	des_ncbc_encrypt(src, dest, len, cc->u.des.key, &cc->u.des.iv,
	    DES_DECRYPT);
}

/* 3DES */
void
des3_setkey(CipherContext *cc, const u_char *key, u_int keylen)
{
	des_set_key((void *) key, cc->u.des3.key1);
	des_set_key((void *) (key+8), cc->u.des3.key2);
	des_set_key((void *) (key+16), cc->u.des3.key3);
}
void
des3_setiv(CipherContext *cc, const u_char *iv, u_int ivlen)
{
	memset(cc->u.des3.iv2, 0, sizeof(cc->u.des3.iv2));
	memset(cc->u.des3.iv3, 0, sizeof(cc->u.des3.iv3));
	if (iv == NULL)
		return;
	memcpy(cc->u.des3.iv3, (char *)iv, 8);
}
void
des3_cbc_encrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	des_ede3_cbc_encrypt(src, dest, len,
	    cc->u.des3.key1, cc->u.des3.key2, cc->u.des3.key3,
	    &cc->u.des3.iv3, DES_ENCRYPT);
}
void
des3_cbc_decrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	des_ede3_cbc_encrypt(src, dest, len,
	    cc->u.des3.key1, cc->u.des3.key2, cc->u.des3.key3,
	    &cc->u.des3.iv3, DES_DECRYPT);
}

d38 5
a42 12
des3_ssh1_setkey(CipherContext *cc, const u_char *key, u_int keylen)
{
	des_set_key((void *) key, cc->u.des3.key1);
	des_set_key((void *) (key+8), cc->u.des3.key2);
	if (keylen <= 16)
		des_set_key((void *) key, cc->u.des3.key3);
	else
		des_set_key((void *) (key+16), cc->u.des3.key3);
}
void
des3_ssh1_encrypt(CipherContext *cc, u_char *dest, const u_char *src,
    u_int len)
a44 2
	des_cblock *iv2 = &cc->u.des3.iv2;
	des_cblock *iv3 = &cc->u.des3.iv3;
d48 1
a48 1
	des_cbc_encrypt(src, dest, len, cc->u.des3.key1, &iv1, DES_ENCRYPT);
d51 1
a51 1
	des_cbc_encrypt(dest, dest, len, cc->u.des3.key2, iv2, DES_DECRYPT);
d54 1
a54 1
	des_cbc_encrypt(dest, dest, len, cc->u.des3.key3, iv3, DES_ENCRYPT);
d57 1
d59 5
a63 2
des3_ssh1_decrypt(CipherContext *cc, u_char *dest, const u_char *src,
    u_int len)
a65 2
	des_cblock *iv2 = &cc->u.des3.iv2;
	des_cblock *iv3 = &cc->u.des3.iv3;
d69 1
a69 1
	des_cbc_encrypt(src, dest, len, cc->u.des3.key3, iv3, DES_DECRYPT);
d72 1
a72 1
	des_cbc_encrypt(dest, dest, len, cc->u.des3.key2, iv2, DES_ENCRYPT);
d75 1
a75 1
	des_cbc_encrypt(dest, dest, len, cc->u.des3.key1, &iv1, DES_DECRYPT);
a79 29
/* Blowfish */
void
blowfish_setkey(CipherContext *cc, const u_char *key, u_int keylen)
{
	BF_set_key(&cc->u.bf.key, keylen, (unsigned char *)key);
}
void
blowfish_setiv(CipherContext *cc, const u_char *iv, u_int ivlen)
{
	if (iv == NULL)
		memset(cc->u.bf.iv, 0, 8);
	else
		memcpy(cc->u.bf.iv, (char *)iv, 8);
}
void
blowfish_cbc_encrypt(CipherContext *cc, u_char *dest, const u_char *src,
     u_int len)
{
	BF_cbc_encrypt((void *)src, dest, len, &cc->u.bf.key, cc->u.bf.iv,
	    BF_ENCRYPT);
}
void
blowfish_cbc_decrypt(CipherContext *cc, u_char *dest, const u_char *src,
     u_int len)
{
	BF_cbc_encrypt((void *)src, dest, len, &cc->u.bf.key, cc->u.bf.iv,
	    BF_DECRYPT);
}

d85 1
a85 1
swap_bytes(const unsigned char *src, unsigned char *dst, int n)
d87 20
a106 13
	char c[4];

	/* Process 4 bytes every lap. */
	for (n = n / 4; n > 0; n--) {
		c[3] = *src++;
		c[2] = *src++;
		c[1] = *src++;
		c[0] = *src++;

		*dst++ = c[0];
		*dst++ = c[1];
		*dst++ = c[2];
		*dst++ = c[3];
d110 5
a114 3
void
blowfish_ssh1_encrypt(CipherContext *cc, u_char *dest, const u_char *src,
    u_int len)
d116 13
a128 14
	swap_bytes(src, dest, len);
	BF_cbc_encrypt((void *)dest, dest, len, &cc->u.bf.key, cc->u.bf.iv,
	    BF_ENCRYPT);
	swap_bytes(dest, dest, len);
}
void
blowfish_ssh1_decrypt(CipherContext *cc, u_char *dest, const u_char *src,
    u_int len)
{
	swap_bytes(src, dest, len);
	BF_cbc_encrypt((void *)dest, dest, len, &cc->u.bf.key, cc->u.bf.iv,
	    BF_DECRYPT);
	swap_bytes(dest, dest, len);
}
d130 5
a134 11
/* alleged rc4 */
void
arcfour_setkey(CipherContext *cc, const u_char *key, u_int keylen)
{
	RC4_set_key(&cc->u.rc4, keylen, (u_char *)key);
}
void
arcfour_crypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	RC4(&cc->u.rc4, len, (u_char *)src, dest);
}
d136 2
a137 3
/* CAST */
void
cast_setkey(CipherContext *cc, const u_char *key, u_int keylen)
d139 4
a142 1
	CAST_set_key(&cc->u.cast.key, keylen, (unsigned char *) key);
d144 2
a145 2
void
cast_setiv(CipherContext *cc, const u_char *iv, u_int ivlen)
d147 6
a152 3
	if (iv == NULL) 
		fatal("no IV for %s.", cc->cipher->name);
	memcpy(cc->u.cast.iv, (char *)iv, 8);
d154 2
a155 24
void
cast_cbc_encrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	CAST_cbc_encrypt(src, dest, len, &cc->u.cast.key, cc->u.cast.iv,
	    CAST_ENCRYPT);
}
void
cast_cbc_decrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	CAST_cbc_encrypt(src, dest, len, &cc->u.cast.key, cc->u.cast.iv,
	    CAST_DECRYPT);
}

/* RIJNDAEL */

#define RIJNDAEL_BLOCKSIZE 16
void
rijndael_setkey(CipherContext *cc, const u_char *key, u_int keylen)
{
	rijndael_set_key(&cc->u.rijndael.enc, (u4byte *)key, 8*keylen, 1);
	rijndael_set_key(&cc->u.rijndael.dec, (u4byte *)key, 8*keylen, 0);
}
void
rijndael_setiv(CipherContext *cc, const u_char *iv, u_int ivlen)
d157 1
a157 3
	if (iv == NULL) 
		fatal("no IV for %s.", cc->cipher->name);
	memcpy((u_char *)cc->u.rijndael.iv, iv, RIJNDAEL_BLOCKSIZE);
a158 118
void
rijndael_cbc_encrypt(CipherContext *cc, u_char *dest, const u_char *src,
    u_int len)
{
	rijndael_ctx *ctx = &cc->u.rijndael.enc;
	u4byte *iv = cc->u.rijndael.iv;
	u4byte in[4];
	u4byte *cprev, *cnow, *plain;
	int i, blocks = len / RIJNDAEL_BLOCKSIZE;
	if (len == 0)
		return;
	if (len % RIJNDAEL_BLOCKSIZE)
		fatal("rijndael_cbc_encrypt: bad len %d", len);
	cnow  = (u4byte*) dest;
	plain = (u4byte*) src;
	cprev = iv;
	for(i = 0; i < blocks; i++, plain+=4, cnow+=4) {
		in[0] = plain[0] ^ cprev[0];
		in[1] = plain[1] ^ cprev[1];
		in[2] = plain[2] ^ cprev[2];
		in[3] = plain[3] ^ cprev[3];
		rijndael_encrypt(ctx, in, cnow);
		cprev = cnow;
	}
	memcpy(iv, cprev, RIJNDAEL_BLOCKSIZE);
}

void
rijndael_cbc_decrypt(CipherContext *cc, u_char *dest, const u_char *src,
    u_int len)
{
	rijndael_ctx *ctx = &cc->u.rijndael.dec;
	u4byte *iv = cc->u.rijndael.iv;
	u4byte ivsaved[4];
	u4byte *cnow =  (u4byte*) (src+len-RIJNDAEL_BLOCKSIZE);
	u4byte *plain = (u4byte*) (dest+len-RIJNDAEL_BLOCKSIZE);
	u4byte *ivp;
	int i, blocks = len / RIJNDAEL_BLOCKSIZE;
	if (len == 0)
		return;
	if (len % RIJNDAEL_BLOCKSIZE)
		fatal("rijndael_cbc_decrypt: bad len %d", len);
	memcpy(ivsaved, cnow, RIJNDAEL_BLOCKSIZE);
	for(i = blocks; i > 0; i--, cnow-=4, plain-=4) {
		rijndael_decrypt(ctx, cnow, plain);
		ivp =  (i == 1) ? iv : cnow-4;
		plain[0] ^= ivp[0];
		plain[1] ^= ivp[1];
		plain[2] ^= ivp[2];
		plain[3] ^= ivp[3];
	}
	memcpy(iv, ivsaved, RIJNDAEL_BLOCKSIZE);
}

Cipher ciphers[] = {
	{ "none",
		SSH_CIPHER_NONE, 8, 0,
		none_setkey, none_setiv,
		none_crypt, none_crypt },
	{ "des",
		SSH_CIPHER_DES, 8, 8,
		des_ssh1_setkey, des_ssh1_setiv,
		des_ssh1_encrypt, des_ssh1_decrypt },
	{ "3des",
		SSH_CIPHER_3DES, 8, 16,
		des3_ssh1_setkey, des3_setiv,
		des3_ssh1_encrypt, des3_ssh1_decrypt },
	{ "blowfish",
		SSH_CIPHER_BLOWFISH, 8, 16,
		blowfish_setkey, blowfish_setiv,
		blowfish_ssh1_encrypt, blowfish_ssh1_decrypt },

	{ "3des-cbc",
		SSH_CIPHER_SSH2, 8, 24,
		des3_setkey, des3_setiv,
		des3_cbc_encrypt, des3_cbc_decrypt },
	{ "blowfish-cbc",
		SSH_CIPHER_SSH2, 8, 16,
		blowfish_setkey, blowfish_setiv,
		blowfish_cbc_encrypt, blowfish_cbc_decrypt },
	{ "cast128-cbc",
		SSH_CIPHER_SSH2, 8, 16,
		cast_setkey, cast_setiv,
		cast_cbc_encrypt, cast_cbc_decrypt },
	{ "arcfour",
		SSH_CIPHER_SSH2, 8, 16,
		arcfour_setkey, none_setiv,
		arcfour_crypt, arcfour_crypt },
	{ "aes128-cbc",
		SSH_CIPHER_SSH2, 16, 16,
		rijndael_setkey, rijndael_setiv,
		rijndael_cbc_encrypt, rijndael_cbc_decrypt },
	{ "aes192-cbc",
		SSH_CIPHER_SSH2, 16, 24,
		rijndael_setkey, rijndael_setiv,
		rijndael_cbc_encrypt, rijndael_cbc_decrypt },
	{ "aes256-cbc",
		SSH_CIPHER_SSH2, 16, 32,
		rijndael_setkey, rijndael_setiv,
		rijndael_cbc_encrypt, rijndael_cbc_decrypt },
	{ "rijndael128-cbc",
		SSH_CIPHER_SSH2, 16, 16,
		rijndael_setkey, rijndael_setiv,
		rijndael_cbc_encrypt, rijndael_cbc_decrypt },
	{ "rijndael192-cbc",
		SSH_CIPHER_SSH2, 16, 24,
		rijndael_setkey, rijndael_setiv,
		rijndael_cbc_encrypt, rijndael_cbc_decrypt },
	{ "rijndael256-cbc",
		SSH_CIPHER_SSH2, 16, 32,
		rijndael_setkey, rijndael_setiv,
		rijndael_cbc_encrypt, rijndael_cbc_decrypt },
	{ "rijndael-cbc@@lysator.liu.se",
		SSH_CIPHER_SSH2, 16, 32,
		rijndael_setkey, rijndael_setiv,
		rijndael_cbc_encrypt, rijndael_cbc_decrypt },
        { NULL, SSH_CIPHER_ILLEGAL, 0, 0, NULL, NULL, NULL, NULL }
};
d160 1
a160 1
/*--*/
d162 2
a163 2
unsigned int
cipher_mask_ssh1(int client)
d165 4
a168 7
	unsigned int mask = 0;
	mask |= 1 << SSH_CIPHER_3DES;           /* Mandatory */
	mask |= 1 << SSH_CIPHER_BLOWFISH;
	if (client) {
		mask |= 1 << SSH_CIPHER_DES;
	}
	return mask;
d171 1
a171 19
Cipher *
cipher_by_name(const char *name)
{
	Cipher *c;
	for (c = ciphers; c->name != NULL; c++)
		if (strcasecmp(c->name, name) == 0)
			return c;
	return NULL;
}

Cipher *
cipher_by_number(int id)
{
	Cipher *c;
	for (c = ciphers; c->name != NULL; c++)
		if (c->number == id)
			return c;
	return NULL;
}
a176 1
	Cipher *c;
d179 1
d184 1
a184 1
	for ((p = strsep(&cp, CIPHER_SEP)); p && *p != '\0';
d186 2
a187 3
		c = cipher_by_name(p);
		if (c == NULL || c->number != SSH_CIPHER_SSH2) {
			debug("bad cipher %s [%s]", p, names);
a189 2
		} else {
			debug3("cipher ok: %s [%s]", p, names);
a191 1
	debug3("ciphers ok: [%s]", names);
d204 1
a204 1
	Cipher *c;
d207 5
a211 2
	c = cipher_by_name(name);
	return (c==NULL) ? -1 : c->number;
d214 7
a220 2
char *
cipher_name(int id)
d222 11
a232 2
	Cipher *c = cipher_by_number(id);
	return (c==NULL) ? "<unknown>" : c->name;
d235 2
d238 2
a239 2
cipher_init(CipherContext *cc, Cipher *cipher,
    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen)
d241 55
a295 9
	if (keylen < cipher->key_len)
		fatal("cipher_init: key length %d is insufficient for %s.",
		    keylen, cipher->name);
	if (iv != NULL && ivlen < cipher->block_size)
		fatal("cipher_init: iv length %d is insufficient for %s.",
		    ivlen, cipher->name);
	cc->cipher = cipher;
	cipher->setkey(cc, key, keylen);
	cipher->setiv(cc, iv, ivlen);
d299 55
a353 5
cipher_encrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
{
	if (len % cc->cipher->block_size)
		fatal("cipher_encrypt: bad plaintext length %d", len);
	cc->cipher->encrypt(cc, dest, src, len);
d356 2
d359 2
a360 1
cipher_decrypt(CipherContext *cc, u_char *dest, const u_char *src, u_int len)
d362 47
a408 3
	if (len % cc->cipher->block_size)
		fatal("cipher_decrypt: bad ciphertext length %d", len);
	cc->cipher->decrypt(cc, dest, src, len);
d411 1
a411 4
/*
 * Selects the cipher, and keys if by computing the MD5 checksum of the
 * passphrase and using the resulting 16 bytes as the key.
 */
d414 2
a415 2
cipher_set_key_string(CipherContext *cc, Cipher *cipher,
    const char *passphrase)
d417 2
a418 6
	MD5_CTX md;
	unsigned char digest[16];

	MD5_Init(&md);
	MD5_Update(&md, (const u_char *)passphrase, strlen(passphrase));
	MD5_Final(digest, &md);
d420 40
a459 1
	cipher_init(cc, cipher, digest, 16, NULL, 0);
d461 3
a463 2
	memset(digest, 0, sizeof(digest));
	memset(&md, 0, sizeof(md));
@


1.26.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d38 1
a38 1
RCSID("$OpenBSD: cipher.c,v 1.43 2001/02/04 15:32:23 stevesk Exp $");
d40 1
a41 2
#include "log.h"
#include "cipher.h"
d157 8
a164 3
	des_ncbc_encrypt(src,  dest, len, cc->u.des3.key1, &iv1, DES_ENCRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key2, iv2, DES_DECRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key3, iv3, DES_ENCRYPT);
d176 9
a184 3
	des_ncbc_encrypt(src,  dest, len, cc->u.des3.key3, iv3, DES_DECRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key2, iv2, DES_ENCRYPT);
	des_ncbc_encrypt(dest, dest, len, cc->u.des3.key1, &iv1, DES_DECRYPT);
d191 1
a191 1
	BF_set_key(&cc->u.bf.key, keylen, (u_char *)key);
d221 1
a221 1
swap_bytes(const u_char *src, u_char *dst, int n)
d274 1
a274 1
	CAST_set_key(&cc->u.cast.key, keylen, (u_char *) key);
d279 1
a279 1
	if (iv == NULL)
d308 1
a308 1
	if (iv == NULL)
d428 1
a428 1
	{ NULL, SSH_CIPHER_ILLEGAL, 0, 0, NULL, NULL, NULL, NULL }
d433 1
a433 1
u_int
d436 1
a436 1
	u_int mask = 0;
d555 1
a555 1
	u_char digest[16];
@


1.26.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.25
log
@#include <ssl/foo.h> -> <openssh/foo.h>
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d15 1
a15 1
RCSID("$Id: cipher.c,v 1.24 2000/04/12 07:45:43 markus Exp $");
d136 1
a136 1
unsigned int 
d144 1
a144 1
unsigned int 
d154 1
a154 1
unsigned int 
d216 1
a216 1
void 
d234 1
a234 1
void 
d295 1
a295 1
void 
d297 1
a297 1
    const unsigned char *key, int keylen, 
d355 1
a355 1
void 
d377 1
a377 1
		               &context->u.bf.key, context->u.bf.iv,
d384 1
a384 1
		               &context->u.bf.key, context->u.bf.iv,
d410 1
a410 1
void 
@


1.24
log
@add Cipher and Protocol options to ssh/sshd, e.g.:
ssh -o 'Protocol 1,2' if you prefer proto 1, ssh -o 'Ciphers arcfour,3des-cbc'
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.23 2000/04/12 00:18:20 deraadt Exp $");
d21 1
a21 1
#include <ssl/md5.h>
@


1.23
log
@comment typo
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.22 2000/04/04 21:37:27 markus Exp $");
d19 1
d24 2
d81 1
a81 1
 * SSH uses a variation on Blowfish, all bytes must be swapped before
d167 1
a167 1
		fatal("cipher_name: bad cipher number: %d", cipher);
d171 24
a293 1

@


1.22
log
@remove unused argument, split cipher_mask()
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.21 2000/03/28 20:24:49 markus Exp $");
d23 1
a23 1
 * What kind of tripple DES are these 2 routines?
@


1.21
log
@support ssh2 ciphers
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.21 2000/03/22 13:40:45 markus Exp $");
d134 1
a134 1
cipher_mask()
d139 6
d151 5
d190 1
a190 2
cipher_set_key_string(CipherContext *context, int cipher,
		      const char *passphrase, int for_encryption)
d199 1
a199 1
	cipher_set_key(context, cipher, digest, 16, for_encryption);
d208 2
a209 2
cipher_set_key(CipherContext *context, int cipher,
	       const unsigned char *key, int keylen, int for_encryption)
@


1.20
log
@remove unused cipher_attack_detected code
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.19 2000/02/22 15:19:29 markus Exp $");
d119 6
a124 1
	"blowfish"
d139 4
d239 2
d245 7
d258 59
d346 21
d399 21
@


1.19
log
@void* -> unsigned char*, ok niels@@
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.18 1999/11/24 19:53:45 markus Exp $");
a106 12
void (*cipher_attack_detected) (const char *fmt,...) = fatal;

static inline void
detect_cbc_attack(const unsigned char *src,
		  unsigned int len)
{
	return;

	log("CRC-32 CBC insertion attack detected");
	cipher_attack_detected("CRC-32 CBC insertion attack detected");
}

a288 1
		/* CRC-32 attack? */
a295 1
		detect_cbc_attack(src, len);
@


1.18
log
@KNF, final part 3
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.17 1999/11/24 00:26:01 deraadt Exp $");
d38 1
a38 1
		 void *dest, void *src,
d59 1
a59 1
		 void *dest, void *src,
d270 1
a270 1
				 dest, (void *) src, len);
d305 1
a305 1
				 dest, (void *) src, len);
@


1.17
log
@much more KNF
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.16 1999/11/23 22:25:53 markus Exp $");
d119 4
a122 2
/* Names of all encryption algorithms.  These must match the numbers defined
   int cipher.h. */
d134 5
a138 3
/* Returns a bit mask indicating which ciphers are supported by this
   implementation.  The bit mask has the corresponding bit set of each
   supported cipher. */
d160 4
a163 2
/* Parses the name of the cipher.  Returns the number of the corresponding
   cipher, or -1 on error. */
d176 4
a179 2
/* Selects the cipher, and keys if by computing the MD5 checksum of the
   passphrase and using the resulting 16 bytes as the key. */
d217 4
a220 2
		/* Has to stay for authfile saving of private key with
		   no passphrase */
d224 5
a228 4
		/* Note: the least significant bit of each byte of key is
		   parity, and must be ignored by the implementation.  16
		   bytes of key are used (first and last keys are the
		   same). */
@


1.16
log
@KNF part 1
@
text
@d2 11
a12 11

cipher.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Wed Apr 19 17:41:39 1995 ylo

*/
d15 1
a15 1
RCSID("$Id: cipher.c,v 1.15 1999/11/22 21:02:38 markus Exp $");
@


1.15
log
@syslog changes:
* Unified Logmessage for all auth-types, for success and for failed
* Standard connections get only ONE line in the LOG when level==LOG:
  Auth-attempts are logged only, if authentication is:
        a) successfull or
        b) with passwd or
        c) we had more than AUTH_FAIL_LOG failues
* many log() became verbose()
* old behaviour with level=VERBOSE
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.14 1999/11/15 21:38:53 markus Exp $");
d36 2
a37 2
		 des_key_schedule ks2, des_cblock *iv2,
		 des_key_schedule ks3, des_cblock *iv3, 
d41 1
a41 1
  des_cblock iv1;
d43 1
a43 1
  memcpy(&iv1, iv2, 8);
d45 2
a46 2
  des_cbc_encrypt(src, dest, len, ks1, &iv1, DES_ENCRYPT);
  memcpy(&iv1, dest + len - 8, 8);
d48 2
a49 2
  des_cbc_encrypt(dest, dest, len, ks2, iv2, DES_DECRYPT);
  memcpy(iv2, &iv1, 8);		/* Note how iv1 == iv2 on entry and exit. */
d51 2
a52 2
  des_cbc_encrypt(dest, dest, len, ks3, iv3, DES_ENCRYPT);
  memcpy(iv3, dest + len - 8, 8);
d57 2
a58 2
		 des_key_schedule ks2, des_cblock *iv2,
		 des_key_schedule ks3, des_cblock *iv3,
d62 1
a62 1
  des_cblock iv1;
d64 1
a64 1
  memcpy(&iv1, iv2, 8);
d66 2
a67 2
  des_cbc_encrypt(src, dest, len, ks3, iv3, DES_DECRYPT);
  memcpy(iv3, src + len - 8, 8);
d69 2
a70 2
  des_cbc_encrypt(dest, dest, len, ks2, iv2, DES_ENCRYPT);
  memcpy(iv2, dest + len - 8, 8);
d72 3
a74 2
  des_cbc_encrypt(dest, dest, len, ks1, &iv1, DES_DECRYPT);
  /* memcpy(&iv1, iv2, 8); */	/* Note how iv1 == iv2 on entry and exit. */
d81 1
a81 2
static
void
d84 21
a104 21
  u_int32_t *dst = (u_int32_t *)dst_;	/* dst must be properly aligned. */
  union {
    u_int32_t i;
    char c[4];
  } t;

  /* Process 8 bytes every lap. */
  for (n = n / 8; n > 0; n--)
    {
      t.c[3] = *src++;
      t.c[2] = *src++;
      t.c[1] = *src++;
      t.c[0] = *src++;
      *dst++ = t.i;
      
      t.c[3] = *src++;
      t.c[2] = *src++;
      t.c[1] = *src++;
      t.c[0] = *src++;
      *dst++ = t.i;
    }
d107 1
a107 1
void (*cipher_attack_detected)(const char *fmt, ...) = fatal;
d109 1
a109 2
static inline
void
d113 4
a116 4
  return;
  
  log("CRC-32 CBC insertion attack detected");
  cipher_attack_detected("CRC-32 CBC insertion attack detected");
d123 7
a129 7
  "none",
  "idea",
  "des",
  "3des",
  "tss",
  "rc4",
  "blowfish"
d136 2
a137 1
unsigned int cipher_mask()
d139 4
a142 4
  unsigned int mask = 0;
  mask |= 1 << SSH_CIPHER_3DES;	/* Mandatory */
  mask |= 1 << SSH_CIPHER_BLOWFISH;
  return mask;
d147 2
a148 2
const
char *cipher_name(int cipher)
d150 4
a153 4
  if (cipher < 0 || cipher >= sizeof(cipher_names) / sizeof(cipher_names[0]) ||
	cipher_names[cipher] == NULL)
    fatal("cipher_name: bad cipher number: %d", cipher);
  return cipher_names[cipher];
d162 6
a167 6
  int i;
  for (i = 0; i < sizeof(cipher_names) / sizeof(cipher_names[0]); i++)
    if (strcmp(cipher_names[i], name) == 0 &&
	(cipher_mask() & (1 << i)))
      return i;
  return -1;
d173 3
a175 2
void cipher_set_key_string(CipherContext *context, int cipher,
			   const char *passphrase, int for_encryption)
d177 11
a187 11
  MD5_CTX md;
  unsigned char digest[16];
  
  MD5_Init(&md);
  MD5_Update(&md, (const unsigned char *)passphrase, strlen(passphrase));
  MD5_Final(digest, &md);

  cipher_set_key(context, cipher, digest, 16, for_encryption);
  
  memset(digest, 0, sizeof(digest));
  memset(&md, 0, sizeof(md));
d192 47
a238 45
void cipher_set_key(CipherContext *context, int cipher,
		    const unsigned char *key, int keylen, int for_encryption)
{
  unsigned char padded[32];

  /* Set cipher type. */
  context->type = cipher;

  /* Get 32 bytes of key data.  Pad if necessary.  (So that code below does
     not need to worry about key size). */
  memset(padded, 0, sizeof(padded));
  memcpy(padded, key, keylen < sizeof(padded) ? keylen : sizeof(padded));

  /* Initialize the initialization vector. */
  switch (cipher)
    {
    case SSH_CIPHER_NONE:
      /* Has to stay for authfile saving of private key with no passphrase */
      break;

    case SSH_CIPHER_3DES:
      /* Note: the least significant bit of each byte of key is parity, 
	 and must be ignored by the implementation.  16 bytes of key are
	 used (first and last keys are the same). */
      if (keylen < 16)
	error("Key length %d is insufficient for 3DES.", keylen);
      des_set_key((void*)padded, context->u.des3.key1);
      des_set_key((void*)(padded + 8), context->u.des3.key2);
      if (keylen <= 16)
	des_set_key((void*)padded, context->u.des3.key3);
      else
	des_set_key((void*)(padded + 16), context->u.des3.key3);
      memset(context->u.des3.iv2, 0, sizeof(context->u.des3.iv2));
      memset(context->u.des3.iv3, 0, sizeof(context->u.des3.iv3));
      break;

    case SSH_CIPHER_BLOWFISH:
      BF_set_key(&context->u.bf.key, keylen, padded);
      memset(context->u.bf.iv, 0, 8);
      break;

    default:
      fatal("cipher_set_key: unknown cipher: %s", cipher_name(cipher));
    }
  memset(padded, 0, sizeof(padded));
d243 31
a273 5
void cipher_encrypt(CipherContext *context, unsigned char *dest,
		    const unsigned char *src, unsigned int len)
{
  if ((len & 7) != 0)
    fatal("cipher_encrypt: bad plaintext length %d", len);
a274 25
  switch (context->type)
    {
    case SSH_CIPHER_NONE:
      memcpy(dest, src, len);
      break;

    case SSH_CIPHER_3DES:
      SSH_3CBC_ENCRYPT(context->u.des3.key1,
		       context->u.des3.key2, &context->u.des3.iv2,
		       context->u.des3.key3, &context->u.des3.iv3,
		       dest, (void*)src, len);
      break;

    case SSH_CIPHER_BLOWFISH:
      swap_bytes(src, dest, len);
      BF_cbc_encrypt(dest, dest, len,
		     &context->u.bf.key, context->u.bf.iv, BF_ENCRYPT);
      swap_bytes(dest, dest, len);
      break;

    default:
      fatal("cipher_encrypt: unknown cipher: %s", cipher_name(context->type));
    }
}
  
d277 32
a308 31
void cipher_decrypt(CipherContext *context, unsigned char *dest,
		    const unsigned char *src, unsigned int len)
{
  if ((len & 7) != 0)
    fatal("cipher_decrypt: bad ciphertext length %d", len);

  switch (context->type)
    {
    case SSH_CIPHER_NONE:
      memcpy(dest, src, len);
      break;

    case SSH_CIPHER_3DES:
      /* CRC-32 attack? */
      SSH_3CBC_DECRYPT(context->u.des3.key1,
		       context->u.des3.key2, &context->u.des3.iv2,
		       context->u.des3.key3, &context->u.des3.iv3,
		       dest, (void*)src, len);
      break;

    case SSH_CIPHER_BLOWFISH:
      detect_cbc_attack(src, len);
      swap_bytes(src, dest, len);
      BF_cbc_encrypt((void*)dest, dest, len,
		     &context->u.bf.key, context->u.bf.iv, BF_DECRYPT);
      swap_bytes(dest, dest, len);
      break;

    default:
      fatal("cipher_decrypt: unknown cipher: %s", cipher_name(context->type));
    }
@


1.14
log
@remove support for cipher RC4
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.13 1999/11/02 19:42:35 markus Exp $");
d267 1
a267 1
      fatal("cipher_encrypt: unknown cipher: %d", context->type);
d302 1
a302 1
      fatal("cipher_decrypt: unknown cipher: %d", context->type);
@


1.13
log
@replace assert() with error, fatal or packet_disconnect
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.12 1999/10/27 16:37:45 deraadt Exp $");
d233 1
a233 1
      fatal("cipher_set_key: unknown cipher: %d", cipher);
@


1.12
log
@use libssl md5 routines
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.11 1999/09/30 22:12:16 provos Exp $");
a89 2
  /* assert((n & 7) == 0); */

d243 2
a244 1
  assert((len & 7) == 0);
d276 2
a277 1
  assert((len & 7) == 0);
@


1.11
log
@better cipher name fix.
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.10 1999/09/30 18:41:24 provos Exp $");
d20 1
a20 1
#include <md5.h>
d181 3
a183 3
  MD5Init(&md);
  MD5Update(&md, (const unsigned char *)passphrase, strlen(passphrase));
  MD5Final(digest, &md);
@


1.10
log
@deal with NULL in ciphernames
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.9 1999/09/30 18:37:45 provos Exp $");
d126 3
a128 3
  NULL,		/* no none */
  NULL, 	/* no idea */
  NULL, 	/* no des */
d130 2
a131 2
  NULL, 	/* no tss */
  NULL,		/* no rc4 */
d166 2
a167 1
    if (cipher_names[i] != NULL && strcmp(cipher_names[i], name) == 0)
@


1.9
log
@less brain damage, get rid of 'no '
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.8 1999/09/30 17:08:52 deraadt Exp $");
d152 2
a153 1
  if (cipher < 0 || cipher >= sizeof(cipher_names) / sizeof(cipher_names[0]))
@


1.8
log
@use libc md5
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.7 1999/09/30 14:05:41 provos Exp $");
d126 3
a128 3
  "no none",
  "no idea",
  "no des",
d130 2
a131 2
  "no tss",
  "no rc4",
d165 1
a165 1
    if (strcmp(cipher_names[i], name) == 0)
@


1.7
log
@remove ``none''.
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.6 1999/09/30 05:53:04 deraadt Exp $");
d19 2
a20 1
#include "ssh_md5.h"
d176 1
a176 1
  struct MD5Context md;
@


1.6
log
@"ssh is a very large program" -- anonymous
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.5 1999/09/30 05:19:57 deraadt Exp $");
d125 1
a125 1
  "none",
a140 1
  mask |= 1 << SSH_CIPHER_NONE;
d207 1
@


1.5
log
@cull, cull, cull
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.4 1999/09/28 04:45:36 provos Exp $");
a126 3
#ifdef WITH_DES
  "des",
#else
a127 1
#endif
a141 3
#ifdef WITH_DES
  mask |= 1 << SSH_CIPHER_DES;
#endif
a209 12
#ifdef WITH_DES
    case SSH_CIPHER_DES:
      /* Note: the least significant bit of each byte of key is parity, 
	 and must be ignored by the implementation.  8 bytes of key are
	 used. */
      if (keylen < 8)
	error("Key length %d is insufficient for DES.", keylen);
      des_set_key((void*)padded, context->u.des.key);
      memset(context->u.des.iv, 0, sizeof(context->u.des.iv));
      break;
#endif /* WITH_DES */

a249 8
#ifdef WITH_DES
    case SSH_CIPHER_DES:
      des_cbc_encrypt((void*)src, (void*)dest, len,
		      context->u.des.key, &context->u.des.iv, DES_ENCRYPT);
      memcpy(context->u.des.iv, dest + len - 8, 8);
      break;
#endif /* WITH_DES */

a280 9

#ifdef WITH_DES
    case SSH_CIPHER_DES:
      detect_cbc_attack(src, len);
      des_cbc_encrypt((void*)src, (void*)dest, len,
		      context->u.des.key, &context->u.des.iv, DES_DECRYPT);
      memcpy(context->u.des.iv, src + len - 8, 8);
      break;
#endif /* WITH_DES */
@


1.4
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.12 1999/05/28 15:21:51 bg Exp $");
d83 1
a83 1
  uint32 *dst = (uint32 *)dst_;	/* dst must be properly aligned. */
d85 1
a85 1
    uint32 i;
@


1.3
log
@blowfish is always there
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.2 1999/09/26 21:02:15 deraadt Exp $");
d19 1
d124 2
a125 1
{ "none",
a133 3
#ifdef WITH_RC4
  "rc4",
#else
a134 1
#endif
a149 3
#ifdef WITH_RC4
  mask |= 1 << SSH_CIPHER_RC4;
#endif
d156 2
a157 1
const char *cipher_name(int cipher)
d167 2
a168 1
int cipher_number(const char *name)
a244 6
#ifdef WITH_RC4
    case SSH_CIPHER_RC4:
      rc4_init(&context->u.rc4, key, keylen);
      break;
#endif /* WITH_RC4 */

a283 6
#ifdef WITH_RC4
    case SSH_CIPHER_RC4:
      rc4_encrypt(&context->u.rc4, dest, src, len);
      break;
#endif /* WITH_RC4 */

a324 7

#ifdef WITH_RC4
    case SSH_CIPHER_RC4:
      /* CRC-32 attack? */
      rc4_decrypt(&context->u.rc4, dest, src, len);
      break;
#endif /* WITH_RC4 */
@


1.2
log
@all the idea code goes away
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.1 1999/09/26 20:53:34 deraadt Exp $");
a73 1
#ifdef WITH_BLOWFISH
a105 1
#endif /* WITH_BLOWFISH */
a136 1
#ifdef WITH_BLOWFISH
a137 3
#else
  "no blowfish"
#endif
a154 1
#ifdef WITH_BLOWFISH
a155 1
#endif
a253 1
#ifdef WITH_BLOWFISH
a257 1
#endif /* WITH_BLOWFISH */
a298 1
#ifdef WITH_BLOWFISH
a304 1
#endif /* WITH_BLOWFISH */
a347 1
#ifdef WITH_BLOWFISH
a354 1
#endif /* WITH_BLOWFISH */
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d15 1
a15 1
RCSID("$Id: cipher.c,v 1.12 1999/05/28 15:21:51 bg Exp $");
a121 14
#ifdef WITH_IDEA
static inline
void
detect_cfb_attack(const unsigned char *src,
		  unsigned int len,
		  const unsigned char iv[8])
{
  return;

  log("CRC-32 CFB insertion attack detected");
  cipher_attack_detected("CRC-32 CFB insertion attack detected");
}
#endif /* WITH_IDEA */

a125 3
#ifdef WITH_IDEA
  "idea",
#else
a126 1
#endif
a153 3
#ifdef WITH_IDEA
  mask |= 1 << SSH_CIPHER_IDEA;
#endif /* WITH_IDEA */
a227 9
#ifdef WITH_IDEA
    case SSH_CIPHER_IDEA:
      if (keylen < 16)
	error("Key length %d is insufficient for IDEA.", keylen);
      idea_set_key(&context->u.idea.key, padded);
      memset(context->u.idea.iv, 0, sizeof(context->u.idea.iv));
      break;
#endif /* WITH_IDEA */

a287 7
#ifdef WITH_IDEA
    case SSH_CIPHER_IDEA:
      idea_cfb_encrypt(&context->u.idea.key, context->u.idea.iv, 
		       dest, src, len);
      break;
#endif /* WITH_IDEA */

a334 8

#ifdef WITH_IDEA
    case SSH_CIPHER_IDEA:
      detect_cfb_attack(src, len, context->u.idea.iv);
      idea_cfb_decrypt(&context->u.idea.key, context->u.idea.iv, 
		       dest, src, len);
      break;
#endif /* WITH_IDEA */
@

