head	1.45;
access;
symbols
	OPENBSD_6_1:1.45.0.2
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.45.0.4
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.44.0.8
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.6
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.44.0.4
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.43.0.28
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.43.0.24
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.22
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.20
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.18
	OPENBSD_5_0:1.43.0.16
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.14
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.12
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.43.0.8
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.43.0.10
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.6
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.43.0.4
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.43.0.2
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.40.0.6
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.40.0.2
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.40.0.4
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.34.0.4
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.34.0.2
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.33.0.2
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.31.0.4
	OPENBSD_3_6_BASE:1.31
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.27.0.4
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8;
locks; strict;
comment	@ * @;


1.45
date	2016.07.21.01.39.35;	author dtucker;	state Exp;
branches;
next	1.44;
commitid	aA6nLtOBJMEkd0V3;

1.44
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.43;
commitid	z7plx8Gkj6l2sxem;

1.43
date	2007.09.21.08.15.29;	author djm;	state Exp;
branches;
next	1.42;

1.42
date	2007.08.23.02.55.51;	author djm;	state Exp;
branches;
next	1.41;

1.41
date	2007.08.23.02.49.43;	author djm;	state Exp;
branches;
next	1.40;

1.40
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.37;

1.37
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2005.07.19.15.32.26;	author otto;	state Exp;
branches
	1.34.2.1
	1.34.4.1;
next	1.33;

1.33
date	2005.01.24.11.47.13;	author dtucker;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2005.01.21.08.32.02;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.30.09.48.57;	author markus;	state Exp;
branches
	1.31.2.1
	1.31.4.1;
next	1.30;

1.30
date	2003.11.04.08.54.09;	author djm;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.26.09.58.43;	author markus;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2003.07.22.13.35.22;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.24.16.45.16;	author stevesk;	state Exp;
branches
	1.27.2.1
	1.27.4.1;
next	1.26;

1.26
date	2002.05.10.02.30.12;	author mouring;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.06.23.00.59;	author mouring;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.04.12.43.06;	author markus;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2001.06.26.16.15.23;	author dugsong;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2001.03.20.18.57.04;	author markus;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.02.12.16.16.23;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.21.19.05.42;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.18.16.59.59;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.03.18.03.03;	author markus;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2000.09.07.20.27.49;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.20.01.39.38;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.14.10.30.29;	author markus;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	99.12.29.12.47.46;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	99.12.01.16.54.35;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	99.11.24.19.53.43;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	99.11.24.00.26.00;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.11.23.22.25.52;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.11.10.22.24.01;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	99.10.19.15.56.41;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.10.14.19.56.02;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.10.07.21.45.02;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	99.09.30.04.30.03;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.22.22.16;	author dugsong;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.21.14.15;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.18.16.19;	author dugsong;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.33;	author deraadt;	state Exp;
branches;
next	;

1.15.2.1
date	2000.09.01.18.23.16;	author jason;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2000.11.08.21.30.19;	author jason;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2001.03.12.15.44.07;	author jason;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2001.03.21.18.52.33;	author jason;	state Exp;
branches;
next	;

1.18.2.1
date	2001.02.16.20.12.52;	author jason;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2001.02.19.17.18.34;	author jason;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2001.03.21.19.46.22;	author jason;	state Exp;
branches;
next	1.18.2.4;

1.18.2.4
date	2001.05.07.21.09.25;	author jason;	state Exp;
branches;
next	1.18.2.5;

1.18.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.18.2.6;

1.18.2.6
date	2002.03.08.17.04.41;	author brad;	state Exp;
branches;
next	;

1.22.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.03.09.00.20.43;	author miod;	state Exp;
branches;
next	;

1.23.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2002.06.22.07.23.16;	author miod;	state Exp;
branches;
next	;

1.24.2.1
date	2002.05.18.04.12.10;	author jason;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2002.05.18.04.50.37;	author jason;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	;

1.27.2.1
date	2003.09.16.21.20.24;	author brad;	state Exp;
branches;
next	;

1.27.4.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.29.2.1
date	2004.02.28.03.51.32;	author brad;	state Exp;
branches;
next	;

1.31.2.1
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.31.4.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.31.4.2;

1.31.4.2
date	2005.09.02.03.44.59;	author brad;	state Exp;
branches;
next	;

1.33.2.1
date	2005.09.04.18.39.52;	author brad;	state Exp;
branches;
next	;

1.34.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.34.4.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Skip passwords longer than 1k in length so clients can't easily DoS sshd
by sending very long passwords, causing it to spend CPU hashing them.
feedback djm@@, ok markus@@.

Brought to our attention by tomas.kuthan at oracle.com, shilei-c at
360.cn and coredump at autistici.org
@
text
@/* $OpenBSD: auth-passwd.c,v 1.44 2014/07/15 15:54:14 millert Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Password authentication.  This file contains the functions to check whether
 * the password is valid for the user.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 * Copyright (c) 1999 Dug Song.  All rights reserved.
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>

#include <login_cap.h>
#include <pwd.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#include "packet.h"
#include "buffer.h"
#include "log.h"
#include "misc.h"
#include "servconf.h"
#include "key.h"
#include "hostfile.h"
#include "auth.h"
#include "auth-options.h"

extern Buffer loginmsg;
extern ServerOptions options;
int sys_auth_passwd(Authctxt *, const char *);

extern login_cap_t *lc;

#define DAY		(24L * 60 * 60) /* 1 day in seconds */
#define TWO_WEEKS	(2L * 7 * DAY)	/* 2 weeks in seconds */

#define MAX_PASSWORD_LEN	1024

static void
disable_forwarding(void)
{
	no_port_forwarding_flag = 1;
	no_agent_forwarding_flag = 1;
	no_x11_forwarding_flag = 1;
}

/*
 * Tries to authenticate the user using password.  Returns true if
 * authentication succeeds.
 */
int
auth_password(Authctxt *authctxt, const char *password)
{
	struct passwd * pw = authctxt->pw;
	int ok = authctxt->valid;

	if (strlen(password) > MAX_PASSWORD_LEN)
		return 0;

	if (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)
		ok = 0;
	if (*password == '\0' && options.permit_empty_passwd == 0)
		return 0;
#ifdef KRB5
	if (options.kerberos_authentication == 1) {
		int ret = auth_krb5_password(authctxt, password);
		if (ret == 1 || ret == 0)
			return ret && ok;
		/* Fall back to ordinary passwd authentication. */
	}
#endif
	return (sys_auth_passwd(authctxt, password) && ok);
}

static void
warn_expiry(Authctxt *authctxt, auth_session_t *as)
{
	char buf[256];
	quad_t pwtimeleft, actimeleft, daysleft, pwwarntime, acwarntime;

	pwwarntime = acwarntime = TWO_WEEKS;

	pwtimeleft = auth_check_change(as);
	actimeleft = auth_check_expire(as);
	if (authctxt->valid) {
		pwwarntime = login_getcaptime(lc, "password-warn", TWO_WEEKS,
		    TWO_WEEKS);
		acwarntime = login_getcaptime(lc, "expire-warn", TWO_WEEKS,
		    TWO_WEEKS);
	}
	if (pwtimeleft != 0 && pwtimeleft < pwwarntime) {
		daysleft = pwtimeleft / DAY + 1;
		snprintf(buf, sizeof(buf),
		    "Your password will expire in %lld day%s.\n",
		    daysleft, daysleft == 1 ? "" : "s");
		buffer_append(&loginmsg, buf, strlen(buf));
	}
	if (actimeleft != 0 && actimeleft < acwarntime) {
		daysleft = actimeleft / DAY + 1;
		snprintf(buf, sizeof(buf),
		    "Your account will expire in %lld day%s.\n",
		    daysleft, daysleft == 1 ? "" : "s");
		buffer_append(&loginmsg, buf, strlen(buf));
	}
}

int
sys_auth_passwd(Authctxt *authctxt, const char *password)
{
	struct passwd *pw = authctxt->pw;
	auth_session_t *as;
	static int expire_checked = 0;

	as = auth_usercheck(pw->pw_name, authctxt->style, "auth-ssh",
	    (char *)password);
	if (as == NULL)
		return (0);
	if (auth_getstate(as) & AUTH_PWEXPIRED) {
		auth_close(as);
		disable_forwarding();
		authctxt->force_pwchange = 1;
		return (1);
	} else {
		if (!expire_checked) {
			expire_checked = 1;
			warn_expiry(authctxt, as);
		}
		return (auth_close(as));
	}
}
@


1.44
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-passwd.c,v 1.43 2007/09/21 08:15:29 djm Exp $ */
d66 2
d85 3
@


1.43
log
@unifdef -DBSD_AUTH
unifdef -USKEY

These options have been in use for some years;
ok markus@@ "no objection" millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-passwd.c,v 1.42 2007/08/23 02:55:51 djm Exp $ */
d50 1
@


1.42
log
@missed include bits from last commit
@
text
@d1 1
a1 1
/* $OpenBSD: auth-passwd.c,v 1.41 2007/08/23 02:49:43 djm Exp $ */
a97 1
#ifdef BSD_AUTH
a153 23
#else
int
sys_auth_passwd(Authctxt *authctxt, const char *password)
{
	struct passwd *pw = authctxt->pw;
	char *encrypted_password;

	/* Check for users with no password. */
	if (strcmp(password, "") == 0 && strcmp(pw->pw_passwd, "") == 0)
		return (1);

	/* Encrypt the candidate password using the proper salt. */
	encrypted_password = crypt(password,
	    (pw->pw_passwd[0] && pw->pw_passwd[1]) ?
	    pw->pw_passwd : "xx");

	/*
	 * Authentication is accepted if the encrypted passwords
	 * are identical.
	 */
	return (strcmp(encrypted_password, pw->pw_passwd) == 0);
}
#endif
@


1.41
log
@unifdef HAVE_LOGIN_CAP; ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-passwd.c,v 1.40 2006/08/03 03:34:41 deraadt Exp $ */
d41 1
a60 1

@


1.40
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: auth-passwd.c,v 1.39 2006/08/01 23:22:47 stevesk Exp $ */
a58 1
#ifdef HAVE_LOGIN_CAP
a59 1
#endif
a108 1
#ifdef HAVE_LOGIN_CAP
a114 1
#endif
@


1.39
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth-passwd.c,v 1.38 2006/07/22 20:48:22 stevesk Exp $ */
a38 2
#include "includes.h"

d44 1
d50 2
@


1.38
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth-passwd.c,v 1.37 2006/07/06 16:03:53 stevesk Exp $ */
d44 1
@


1.37
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-passwd.c,v 1.36 2006/03/25 13:17:01 djm Exp $ */
d44 1
@


1.36
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d40 4
@


1.35
log
@RCSID() can die
@
text
@d1 1
@


1.34
log
@auth_usercheck(3) can return NULL, so check for that. Report from
mpech@@. ok markus@@
@
text
@a38 1
RCSID("$OpenBSD: auth-passwd.c,v 1.33 2005/01/24 11:47:13 dtucker Exp $");
@


1.34.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth-passwd.c,v 1.40 2006/08/03 03:34:41 deraadt Exp $ */
d38 2
a39 6
#include <sys/types.h>

#include <pwd.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
a44 2
#include "key.h"
#include "hostfile.h"
@


1.34.4.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth-passwd.c,v 1.40 2006/08/03 03:34:41 deraadt Exp $ */
d38 2
a39 6
#include <sys/types.h>

#include <pwd.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
a44 2
#include "key.h"
#include "hostfile.h"
@


1.33
log
@#if -> #ifdef so builds without HAVE_LOGIN_CAP work too; ok djm@@ otto@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.32 2005/01/21 08:32:02 otto Exp $");
d137 2
@


1.33.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.34 2005/07/19 15:32:26 otto Exp $");
a136 2
	if (as == NULL)
		return (0);
@


1.32
log
@Warn in advance for password and account expiry; initialize loginmsg
buffer earlier and clear it after privsep fork. ok and help dtucker@@ markus@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.31 2004/01/30 09:48:57 markus Exp $");
d104 1
a104 1
#if HAVE_LOGIN_CAP
@


1.31
log
@support for password change; ok dtucker@@
(set password-dead=1w in login.conf to use this).
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.30 2003/11/04 08:54:09 djm Exp $");
d42 1
d48 1
d52 8
d94 34
d133 1
d143 4
@


1.31.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.33 2005/01/24 11:47:13 dtucker Exp $");
a41 1
#include "buffer.h"
a46 1
extern Buffer loginmsg;
a49 8
#ifdef HAVE_LOGIN_CAP
extern login_cap_t *lc;
#endif


#define DAY		(24L * 60 * 60) /* 1 day in seconds */
#define TWO_WEEKS	(2L * 7 * DAY)	/* 2 weeks in seconds */

a83 34
static void
warn_expiry(Authctxt *authctxt, auth_session_t *as)
{
	char buf[256];
	quad_t pwtimeleft, actimeleft, daysleft, pwwarntime, acwarntime;

	pwwarntime = acwarntime = TWO_WEEKS;

	pwtimeleft = auth_check_change(as);
	actimeleft = auth_check_expire(as);
#ifdef HAVE_LOGIN_CAP
	if (authctxt->valid) {
		pwwarntime = login_getcaptime(lc, "password-warn", TWO_WEEKS,
		    TWO_WEEKS);
		acwarntime = login_getcaptime(lc, "expire-warn", TWO_WEEKS,
		    TWO_WEEKS);
	}
#endif
	if (pwtimeleft != 0 && pwtimeleft < pwwarntime) {
		daysleft = pwtimeleft / DAY + 1;
		snprintf(buf, sizeof(buf),
		    "Your password will expire in %lld day%s.\n",
		    daysleft, daysleft == 1 ? "" : "s");
		buffer_append(&loginmsg, buf, strlen(buf));
	}
	if (actimeleft != 0 && actimeleft < acwarntime) {
		daysleft = actimeleft / DAY + 1;
		snprintf(buf, sizeof(buf),
		    "Your account will expire in %lld day%s.\n",
		    daysleft, daysleft == 1 ? "" : "s");
		buffer_append(&loginmsg, buf, strlen(buf));
	}
}

a88 1
	static int expire_checked = 0;
a97 4
		if (!expire_checked) {
			expire_checked = 1;
			warn_expiry(authctxt, as);
		}
@


1.31.4.1
log
@upgrade to OpenSSH 4.0
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.33 2005/01/24 11:47:13 dtucker Exp $");
a41 1
#include "buffer.h"
a46 1
extern Buffer loginmsg;
a49 8
#ifdef HAVE_LOGIN_CAP
extern login_cap_t *lc;
#endif


#define DAY		(24L * 60 * 60) /* 1 day in seconds */
#define TWO_WEEKS	(2L * 7 * DAY)	/* 2 weeks in seconds */

a83 34
static void
warn_expiry(Authctxt *authctxt, auth_session_t *as)
{
	char buf[256];
	quad_t pwtimeleft, actimeleft, daysleft, pwwarntime, acwarntime;

	pwwarntime = acwarntime = TWO_WEEKS;

	pwtimeleft = auth_check_change(as);
	actimeleft = auth_check_expire(as);
#ifdef HAVE_LOGIN_CAP
	if (authctxt->valid) {
		pwwarntime = login_getcaptime(lc, "password-warn", TWO_WEEKS,
		    TWO_WEEKS);
		acwarntime = login_getcaptime(lc, "expire-warn", TWO_WEEKS,
		    TWO_WEEKS);
	}
#endif
	if (pwtimeleft != 0 && pwtimeleft < pwwarntime) {
		daysleft = pwtimeleft / DAY + 1;
		snprintf(buf, sizeof(buf),
		    "Your password will expire in %lld day%s.\n",
		    daysleft, daysleft == 1 ? "" : "s");
		buffer_append(&loginmsg, buf, strlen(buf));
	}
	if (actimeleft != 0 && actimeleft < acwarntime) {
		daysleft = actimeleft / DAY + 1;
		snprintf(buf, sizeof(buf),
		    "Your account will expire in %lld day%s.\n",
		    daysleft, daysleft == 1 ? "" : "s");
		buffer_append(&loginmsg, buf, strlen(buf));
	}
}

a88 1
	static int expire_checked = 0;
a97 4
		if (!expire_checked) {
			expire_checked = 1;
			warn_expiry(authctxt, as);
		}
@


1.31.4.2
log
@upgrade to OpenSSH 4.2
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.34 2005/07/19 15:32:26 otto Exp $");
a136 2
	if (as == NULL)
		return (0);
@


1.30
log
@standardise arguments to auth methods - they should all take authctxt.
check authctxt->valid rather then pw != NULL; ok markus@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.29 2003/08/26 09:58:43 markus Exp $");
d45 1
d47 2
d50 7
a56 1
extern ServerOptions options;
d80 3
d84 17
a100 5
	if (auth_userokay(pw->pw_name, authctxt->style, "auth-ssh",
	    (char *)password) == 0)
		return 0;
	else
		return ok;
d102 6
d110 13
a122 12
		return ok;
	else {
		/* Encrypt the candidate password using the proper salt. */
		char *encrypted_password = crypt(password,
		    (pw->pw_passwd[0] && pw->pw_passwd[1]) ?
		    pw->pw_passwd : "xx");
		/*
		 * Authentication is accepted if the encrypted passwords
		 * are identical.
		 */
		return (strcmp(encrypted_password, pw->pw_passwd) == 0) && ok;
	}
a123 1
}
@


1.29
log
@fix passwd auth for 'username leaks via timing'; with djm@@, original patches from solar
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.28 2003/07/22 13:35:22 markus Exp $");
a58 3
	/* deny if no user. */
	if (pw == NULL)
		return 0;
@


1.29.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.31 2004/01/30 09:48:57 markus Exp $");
d45 1
a45 1
#include "auth-options.h"
a47 9
int sys_auth_passwd(Authctxt *, const char *);

static void
disable_forwarding(void)
{
	no_port_forwarding_flag = 1;
	no_agent_forwarding_flag = 1;
	no_x11_forwarding_flag = 1;
}
d59 3
a73 3
	return (sys_auth_passwd(authctxt, password) && ok);
}

d75 5
a79 17
int
sys_auth_passwd(Authctxt *authctxt, const char *password)
{
	struct passwd *pw = authctxt->pw;
	auth_session_t *as;

	as = auth_usercheck(pw->pw_name, authctxt->style, "auth-ssh",
	    (char *)password);
	if (auth_getstate(as) & AUTH_PWEXPIRED) {
		auth_close(as);
		disable_forwarding();
		authctxt->force_pwchange = 1;
		return (1);
	} else {
		return (auth_close(as));
	}
}
a80 6
int
sys_auth_passwd(Authctxt *authctxt, const char *password)
{
	struct passwd *pw = authctxt->pw;
	char *encrypted_password;

d83 13
a95 12
		return (1);

	/* Encrypt the candidate password using the proper salt. */
	encrypted_password = crypt(password,
	    (pw->pw_passwd[0] && pw->pw_passwd[1]) ?
	    pw->pw_passwd : "xx");

	/*
	 * Authentication is accepted if the encrypted passwords
	 * are identical.
	 */
	return (strcmp(encrypted_password, pw->pw_passwd) == 0);
a96 1
#endif
@


1.28
log
@remove (already disabled) KRB4/AFS support, re-enable -k in ssh(1);
test+ok henning@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.27 2002/05/24 16:45:16 stevesk Exp $");
d57 1
d63 1
a63 1
		return 0;
d70 1
a70 1
			return ret;
d79 1
a79 1
		return 1;
d83 1
a83 1
		return 1;
d93 1
a93 1
		return (strcmp(encrypted_password, pw->pw_passwd) == 0);
@


1.27
log
@don't include unused code in the #ifdef BSD_AUTH case; ok markus@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.26 2002/05/10 02:30:12 mouring Exp $");
a67 8
		if (ret == 1 || ret == 0)
			return ret;
		/* Fall back to ordinary passwd authentication. */
	}
#endif
#ifdef KRB4
	if (options.kerberos_authentication == 1) {
		int ret = auth_krb4_password(authctxt, password);
@


1.27.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.29 2003/08/26 09:58:43 markus Exp $");
a56 1
	int ok = authctxt->valid;
d62 1
a62 1
		ok = 0;
d69 9
a77 1
			return ret && ok;
d86 1
a86 1
		return ok;
d90 1
a90 1
		return ok;
d100 1
a100 1
		return (strcmp(encrypted_password, pw->pw_passwd) == 0) && ok;
@


1.27.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.29 2003/08/26 09:58:43 markus Exp $");
a56 1
	int ok = authctxt->valid;
d62 1
a62 1
		ok = 0;
d69 9
a77 1
			return ret && ok;
d86 1
a86 1
		return ok;
d90 1
a90 1
		return ok;
d100 1
a100 1
		return (strcmp(encrypted_password, pw->pw_passwd) == 0) && ok;
@


1.27.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.31 2004/01/30 09:48:57 markus Exp $");
d45 1
a45 1
#include "auth-options.h"
a47 9
int sys_auth_passwd(Authctxt *, const char *);

static void
disable_forwarding(void)
{
	no_port_forwarding_flag = 1;
	no_agent_forwarding_flag = 1;
	no_x11_forwarding_flag = 1;
}
d59 3
a73 3
	return (sys_auth_passwd(authctxt, password) && ok);
}

d75 5
a79 17
int
sys_auth_passwd(Authctxt *authctxt, const char *password)
{
	struct passwd *pw = authctxt->pw;
	auth_session_t *as;

	as = auth_usercheck(pw->pw_name, authctxt->style, "auth-ssh",
	    (char *)password);
	if (auth_getstate(as) & AUTH_PWEXPIRED) {
		auth_close(as);
		disable_forwarding();
		authctxt->force_pwchange = 1;
		return (1);
	} else {
		return (auth_close(as));
	}
}
a80 6
int
sys_auth_passwd(Authctxt *authctxt, const char *password)
{
	struct passwd *pw = authctxt->pw;
	char *encrypted_password;

d83 13
a95 12
		return (1);

	/* Encrypt the candidate password using the proper salt. */
	encrypted_password = crypt(password,
	    (pw->pw_passwd[0] && pw->pw_passwd[1]) ?
	    pw->pw_passwd : "xx");

	/*
	 * Authentication is accepted if the encrypted passwords
	 * are identical.
	 */
	return (strcmp(encrypted_password, pw->pw_passwd) == 0);
a96 1
#endif
@


1.26
log
@Reverted from last patch.  Breaks AFS/KRBx.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.25 2002/05/06 23:00:59 mouring Exp $");
a56 1
	char *encrypted_password;
d87 1
a87 1
#endif
d91 12
a102 6
	/* Encrypt the candidate password using the proper salt. */
	encrypted_password = crypt(password,
	    (pw->pw_passwd[0] && pw->pw_passwd[1]) ? pw->pw_passwd : "xx");

	/* Authentication is accepted if the encrypted passwords are identical. */
	return (strcmp(encrypted_password, pw->pw_passwd) == 0);
@


1.25
log
@When options.permit_empty_passwd == 0  ensure you are checking pw->passwd not
password.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.24 2002/03/04 12:43:06 markus Exp $");
d64 1
a64 1
	if (*pw->pw_passwd == '\0' && options.permit_empty_passwd == 0)
@


1.24
log
@unused include
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.23 2001/06/26 16:15:23 dugsong Exp $");
d64 1
a64 1
	if (*password == '\0' && options.permit_empty_passwd == 0)
@


1.24.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.26 2002/05/10 02:30:12 mouring Exp $");
@


1.24.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.24.2.3
log
@Pull in OpenSSH-3.4
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.27 2002/05/24 16:45:16 stevesk Exp $");
d57 1
d88 1
a88 1
#else
d92 6
a97 12
	else {
		/* Encrypt the candidate password using the proper salt. */
		char *encrypted_password = crypt(password,
		    (pw->pw_passwd[0] && pw->pw_passwd[1]) ?
		    pw->pw_passwd : "xx");
		/*
		 * Authentication is accepted if the encrypted passwords
		 * are identical.
		 */
		return (strcmp(encrypted_password, pw->pw_passwd) == 0);
	}
#endif
@


1.23
log
@Kerberos v5 support for SSH1, mostly from Assar Westerlund <assar@@freebsd.org> and Bjorn Gronvall <bg@@sics.se>. markus@@ ok
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.22 2001/03/20 18:57:04 markus Exp $");
a41 1
#include "xmalloc.h"
@


1.23.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.24 2002/03/04 12:43:06 markus Exp $");
d42 1
@


1.23.2.2
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.23.2.1 2002/03/07 17:37:46 jason Exp $");
d57 1
d88 1
a88 1
#else
d92 6
a97 12
	else {
		/* Encrypt the candidate password using the proper salt. */
		char *encrypted_password = crypt(password,
		    (pw->pw_passwd[0] && pw->pw_passwd[1]) ?
		    pw->pw_passwd : "xx");
		/*
		 * Authentication is accepted if the encrypted passwords
		 * are identical.
		 */
		return (strcmp(encrypted_password, pw->pw_passwd) == 0);
	}
#endif
@


1.22
log
@add changes need for BSD_AUTH plus disabled BSD_AUTH code
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.21 2001/02/12 16:16:23 markus Exp $");
d67 7
a73 6
#ifdef BSD_AUTH
	if (auth_userokay(pw->pw_name, authctxt->style, "auth-ssh",
	    (char *)password) == 0)
		return 0;
	else
		return 1;
a74 1

d77 1
a77 1
		int ret = auth_krb4_password(pw, password);
d83 7
a89 1

@


1.22.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.23 2001/06/26 16:15:23 dugsong Exp $");
d67 6
a72 7
#ifdef KRB5
	if (options.kerberos_authentication == 1) {
		int ret = auth_krb5_password(authctxt, password);
		if (ret == 1 || ret == 0)
			return ret;
		/* Fall back to ordinary passwd authentication. */
	}
d74 1
d77 1
a77 1
		int ret = auth_krb4_password(authctxt, password);
d83 1
a83 7
#ifdef BSD_AUTH
	if (auth_userokay(pw->pw_name, authctxt->style, "auth-ssh",
	    (char *)password) == 0)
		return 0;
	else
		return 1;
#endif
@


1.22.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.24 2002/03/04 12:43:06 markus Exp $");
d42 1
@


1.21
log
@PermitRootLogin={yes,without-password,forced-commands-only,no}
(before this change, root could login even if PermitRootLogin==no)
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.20 2001/01/21 19:05:42 markus Exp $");
d47 3
d55 1
a55 1
auth_password(struct passwd * pw, const char *password)
d57 1
a57 1
	extern ServerOptions options;
d67 7
@


1.20
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.19 2001/01/18 16:59:59 markus Exp $");
d60 1
a60 1
	if (pw->pw_uid == 0 && options.permit_root_login == 2)
@


1.19
log
@1) removes fake skey from sshd, since this will be much
   harder with /usr/libexec/auth/login_XXX
2) share/unify code used in ssh-1 and ssh-2 authentication (server side)
3) make addition of BSD_AUTH and other challenge reponse methods
   easier.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.18 2000/10/03 18:03:03 markus Exp $");
d42 2
a43 1
#include "ssh.h"
a44 2
#include "xmalloc.h"

@


1.18
log
@move fake-auth from auth1.c to individual auth methods, disables s/key in debug-msg
@
text
@a13 1
 *
a14 22
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.17 2000/09/07 20:27:49 deraadt Exp $");
d46 2
a65 8
#ifdef SKEY_VIA_PASSWD_IS_DISABLED
	if (options.skey_authentication == 1) {
		int ret = auth_skey_password(pw, password);
		if (ret == 1 || ret == 0)
			return ret;
		/* Fall back to ordinary passwd authentication. */
	}
#endif
@


1.18.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d14 1
d16 22
d62 1
a62 1
RCSID("$OpenBSD: auth-passwd.c,v 1.21 2001/02/12 16:16:23 markus Exp $");
d65 2
a67 3
#include "log.h"
#include "servconf.h"
#include "auth.h"
d82 1
a82 1
	if (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)
d87 8
@


1.18.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.18.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.18.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.22 2001/03/20 18:57:04 markus Exp $");
a46 3

extern ServerOptions options;

d52 1
a52 1
auth_password(Authctxt *authctxt, const char *password)
d54 1
a54 1
	struct passwd * pw = authctxt->pw;
a63 7
#ifdef BSD_AUTH
	if (auth_userokay(pw->pw_name, authctxt->style, "auth-ssh",
	    (char *)password) == 0)
		return 0;
	else
		return 1;
#endif
@


1.18.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.23 2001/06/26 16:15:23 dugsong Exp $");
d67 6
a72 7
#ifdef KRB5
	if (options.kerberos_authentication == 1) {
		int ret = auth_krb5_password(authctxt, password);
		if (ret == 1 || ret == 0)
			return ret;
		/* Fall back to ordinary passwd authentication. */
	}
d74 1
d77 1
a77 1
		int ret = auth_krb4_password(authctxt, password);
d83 1
a83 7
#ifdef BSD_AUTH
	if (auth_userokay(pw->pw_name, authctxt->style, "auth-ssh",
	    (char *)password) == 0)
		return 0;
	else
		return 1;
#endif
@


1.18.2.6
log
@Merge OpenSSH 3.1.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: auth-passwd.c,v 1.24 2002/03/04 12:43:06 markus Exp $");
d42 1
@


1.17
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: auth-passwd.c,v 1.16 2000/06/20 01:39:38 markus Exp $");
d87 1
a87 1
#ifdef SKEY
@


1.16
log
@OpenBSD tag
@
text
@a4 1
 * Created: Sat Mar 18 05:11:38 1995 ylo
d7 52
d62 1
a62 1
RCSID("$OpenBSD: auth-passwd.c,v 1.15 2000/04/14 10:30:29 markus Exp $");
@


1.15
log
@whitespace cleanup
@
text
@d11 1
a11 1
RCSID("$Id: auth-passwd.c,v 1.14 1999/12/29 12:47:46 markus Exp $");
@


1.15.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d11 1
a11 1
RCSID("$OpenBSD: auth-passwd.c,v 1.16 2000/06/20 01:39:38 markus Exp $");
@


1.15.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d5 1
a7 52
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
 * Copyright (c) 1999 Dug Song.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d11 1
a11 1
RCSID("$OpenBSD: auth-passwd.c,v 1.18 2000/10/03 18:03:03 markus Exp $");
d36 1
a36 1
#ifdef SKEY_VIA_PASSWD_IS_DISABLED
@


1.15.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d14 1
d16 22
d62 1
a62 1
RCSID("$OpenBSD: auth-passwd.c,v 1.21 2001/02/12 16:16:23 markus Exp $");
d65 2
a67 3
#include "log.h"
#include "servconf.h"
#include "auth.h"
d82 1
a82 1
	if (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)
d87 8
@


1.15.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.14
log
@check for NULL 1st
@
text
@d11 1
a11 1
RCSID("$Id: auth-passwd.c,v 1.13 1999/12/01 16:54:35 markus Exp $");
d22 1
a22 1
int 
@


1.13
log
@move skey-auth from auth-passwd.c to auth-skey.c, same for krb4
@
text
@d11 1
a11 1
RCSID("$Id: auth-passwd.c,v 1.12 1999/11/24 19:53:43 markus Exp $");
d28 3
a33 3
		return 0;
	/* deny if no user. */
	if (pw == NULL)
@


1.12
log
@KNF, final part 3
@
text
@d11 1
a11 1
RCSID("$Id: auth-passwd.c,v 1.11 1999/11/24 00:26:00 deraadt Exp $");
d38 3
a40 16
		if (strncasecmp(password, "s/key", 5) == 0) {
			char *skeyinfo = skey_keyinfo(pw->pw_name);
			if (skeyinfo == NULL) {
				debug("generating fake skeyinfo for %.100s.",
				    pw->pw_name);
				skeyinfo = skey_fake_keyinfo(pw->pw_name);
			}
			if (skeyinfo != NULL)
				packet_send_debug(skeyinfo);
			/* Try again. */
			return 0;
		} else if (skey_haskey(pw->pw_name) == 0 &&
			   skey_passcheck(pw->pw_name, (char *) password) != -1) {
			/* Authentication succeeded. */
			return 1;
		}
d44 5
a48 105

#if defined(KRB4)
	/*
	 * Support for Kerberos v4 authentication
	 * - Dug Song <dugsong@@UMICH.EDU>
	 */
	if (options.kerberos_authentication) {
		AUTH_DAT adata;
		KTEXT_ST tkt;
		struct hostent *hp;
		unsigned long faddr;
		char localhost[MAXHOSTNAMELEN];
		char phost[INST_SZ];
		char realm[REALM_SZ];
		int r;

		/*
		 * Try Kerberos password authentication only for non-root
		 * users and only if Kerberos is installed.
		 */
		if (pw->pw_uid != 0 && krb_get_lrealm(realm, 1) == KSUCCESS) {

			/* Set up our ticket file. */
			if (!krb4_init(pw->pw_uid)) {
				log("Couldn't initialize Kerberos ticket file for %s!",
				    pw->pw_name);
				goto kerberos_auth_failure;
			}
			/* Try to get TGT using our password. */
			r = krb_get_pw_in_tkt((char *) pw->pw_name, "",
			    realm, "krbtgt", realm,
			    DEFAULT_TKT_LIFE, (char *) password);
			if (r != INTK_OK) {
				packet_send_debug("Kerberos V4 password "
				    "authentication for %s failed: %s",
				    pw->pw_name, krb_err_txt[r]);
				goto kerberos_auth_failure;
			}
			/* Successful authentication. */
			chown(tkt_string(), pw->pw_uid, pw->pw_gid);

			/*
			 * Now that we have a TGT, try to get a local
			 * "rcmd" ticket to ensure that we are not talking
			 * to a bogus Kerberos server.
			 */
			(void) gethostname(localhost, sizeof(localhost));
			(void) strlcpy(phost, (char *) krb_get_phost(localhost),
			    INST_SZ);
			r = krb_mk_req(&tkt, KRB4_SERVICE_NAME, phost, realm, 33);

			if (r == KSUCCESS) {
				if (!(hp = gethostbyname(localhost))) {
					log("Couldn't get local host address!");
					goto kerberos_auth_failure;
				}
				memmove((void *) &faddr, (void *) hp->h_addr,
				    sizeof(faddr));

				/* Verify our "rcmd" ticket. */
				r = krb_rd_req(&tkt, KRB4_SERVICE_NAME, phost,
				    faddr, &adata, "");
				if (r == RD_AP_UNDEC) {
					/*
					 * Probably didn't have a srvtab on
					 * localhost. Allow login.
					 */
					log("Kerberos V4 TGT for %s unverifiable, "
					    "no srvtab installed? krb_rd_req: %s",
					    pw->pw_name, krb_err_txt[r]);
				} else if (r != KSUCCESS) {
					log("Kerberos V4 %s ticket unverifiable: %s",
					    KRB4_SERVICE_NAME, krb_err_txt[r]);
					goto kerberos_auth_failure;
				}
			} else if (r == KDC_PR_UNKNOWN) {
				/*
				 * Allow login if no rcmd service exists, but
				 * log the error.
				 */
				log("Kerberos V4 TGT for %s unverifiable: %s; %s.%s "
				    "not registered, or srvtab is wrong?", pw->pw_name,
				krb_err_txt[r], KRB4_SERVICE_NAME, phost);
			} else {
				/*
				 * TGT is bad, forget it. Possibly spoofed!
				 */
				packet_send_debug("WARNING: Kerberos V4 TGT "
				    "possibly spoofed for %s: %s",
				    pw->pw_name, krb_err_txt[r]);
				goto kerberos_auth_failure;
			}

			/* Authentication succeeded. */
			return 1;

	kerberos_auth_failure:
			krb4_cleanup_proc(NULL);

			if (!options.kerberos_or_local_passwd)
				return 0;
		} else {
			/* Logging in as root or no local Kerberos realm. */
			packet_send_debug("Unable to authenticate to Kerberos.");
		}
d51 1
a51 1
#endif				/* KRB4 */
@


1.11
log
@much more KNF
@
text
@d11 1
a11 1
RCSID("$Id: auth-passwd.c,v 1.10 1999/11/23 22:25:52 markus Exp $");
d28 1
a28 2
	if (pw->pw_uid == 0 && options.permit_root_login == 2) {
		/* Server does not permit root login with password */
d30 1
a30 3
	}
	if (*password == '\0' && options.permit_empty_passwd == 0) {
		/* Server does not permit empty password login */
a31 1
	}
d59 4
a62 2
	/* Support for Kerberos v4 authentication - Dug Song
	   <dugsong@@UMICH.EDU> */
d73 4
a76 2
		/* Try Kerberos password authentication only for non-root
		   users and only if Kerberos is installed. */
d133 4
a136 2
				/* Allow login if no rcmd service exists,
				   but log the error. */
d141 3
a143 2
				/* TGT is bad, forget it. Possibly
				   spoofed! */
d167 1
a167 3
	if (strcmp(password, "") == 0 && strcmp(pw->pw_passwd, "") == 0) {
		packet_send_debug("Login permitted without a password "
		    "because the account has no password.");
a168 1
	}
@


1.10
log
@KNF part 1
@
text
@d2 7
a8 14

auth-passwd.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Sat Mar 18 05:11:38 1995 ylo

Password authentication.  This file contains the functions to check whether
the password is valid for the user.

*/
d11 1
a11 1
RCSID("$Id: auth-passwd.c,v 1.9 1999/11/10 22:24:01 markus Exp $");
d18 4
a21 3
/* Tries to authenticate the user using password.  Returns true if
   authentication succeeds. */

d45 2
a46 1
				debug("generating fake skeyinfo for %.100s.", pw->pw_name);
d81 2
a82 1
				log("Couldn't initialize Kerberos ticket file for %s!", pw->pw_name);
d86 3
a88 2
			r = krb_get_pw_in_tkt((char *) pw->pw_name, "", realm, "krbtgt", realm,
				    	      DEFAULT_TKT_LIFE, (char *) password);
d90 3
a92 2
				packet_send_debug("Kerberos V4 password authentication for %s "
						  "failed: %s", pw->pw_name, krb_err_txt[r]);
d98 5
a102 3
			/* Now that we have a TGT, try to get a local
			   "rcmd" ticket to ensure that we are not talking
			   to a bogus Kerberos server. */
d104 2
a105 1
			(void) strlcpy(phost, (char *) krb_get_phost(localhost), INST_SZ);
d113 2
a114 1
				memmove((void *) &faddr, (void *) hp->h_addr, sizeof(faddr));
d117 2
a118 1
				r = krb_rd_req(&tkt, KRB4_SERVICE_NAME, phost, faddr, &adata, "");
d120 7
a126 3
					/* Probably didn't have a srvtab on localhost. Allow login. */
					log("Kerberos V4 TGT for %s unverifiable, no srvtab installed? "
					    "krb_rd_req: %s", pw->pw_name, krb_err_txt[r]);
d141 3
a143 2
				packet_send_debug("WARNING: Kerberos V4 TGT possibly spoofed for"
						  "%s: %s", pw->pw_name, krb_err_txt[r]);
d165 2
a166 1
		packet_send_debug("Login permitted without a password because the account has no password.");
d171 1
a171 1
				   (pw->pw_passwd[0] && pw->pw_passwd[1]) ? pw->pw_passwd : "xx");
@


1.9
log
@remove x11- and krb-cleanup from fatal() + krb-cleanup cleanup
@
text
@d18 1
a18 1
RCSID("$Id: auth-passwd.c,v 1.8 1999/10/19 15:56:41 deraadt Exp $");
d28 2
a29 1
int auth_password(struct passwd *pw, const char *password)
d31 2
a32 2
  extern ServerOptions options;
  char *encrypted_password;
d34 11
a44 15
  if (pw->pw_uid == 0 && options.permit_root_login == 2)
  {
      /*packet_send_debug("Server does not permit root login with password.");*/
      return 0;
  }

  if (*password == '\0' && options.permit_empty_passwd == 0)
  {
      /*packet_send_debug("Server does not permit empty password login.");*/
      return 0;
  }

  /* deny if no user. */
  if (pw == NULL)
    return 0;
d47 18
a64 19
  if (options.skey_authentication == 1) {
    if (strncasecmp(password, "s/key", 5) == 0) {
      char *skeyinfo = skey_keyinfo(pw->pw_name);
      if(skeyinfo == NULL){
	debug("generating fake skeyinfo for %.100s.", pw->pw_name);
        skeyinfo = skey_fake_keyinfo(pw->pw_name);
      }
      if(skeyinfo != NULL)
        packet_send_debug(skeyinfo);
      /* Try again. */
      return 0;
    }
    else if (skey_haskey(pw->pw_name) == 0 && 
	     skey_passcheck(pw->pw_name, (char *)password) != -1) {
      /* Authentication succeeded. */
      return 1;
    }
    /* Fall back to ordinary passwd authentication. */
  }
d68 84
a151 20
  /* Support for Kerberos v4 authentication - Dug Song <dugsong@@UMICH.EDU> */
  if (options.kerberos_authentication)
    {
      AUTH_DAT adata;
      KTEXT_ST tkt;
      struct hostent *hp;
      unsigned long faddr;
      char localhost[MAXHOSTNAMELEN];
      char phost[INST_SZ];
      char realm[REALM_SZ];
      int r;
      
      /* Try Kerberos password authentication only for non-root
	 users and only if Kerberos is installed. */
      if (pw->pw_uid != 0 && krb_get_lrealm(realm, 1) == KSUCCESS) {

	/* Set up our ticket file. */
	if (!krb4_init(pw->pw_uid)) {
	  log("Couldn't initialize Kerberos ticket file for %s!", pw->pw_name);
	  goto kerberos_auth_failure;
d153 6
a158 48
	/* Try to get TGT using our password. */
	r = krb_get_pw_in_tkt((char *)pw->pw_name, "", realm, "krbtgt", realm,
			      DEFAULT_TKT_LIFE, (char *)password);
	if (r != INTK_OK) {
	  packet_send_debug("Kerberos V4 password authentication for %s "
			    "failed: %s", pw->pw_name, krb_err_txt[r]);
	  goto kerberos_auth_failure;
	}
	/* Successful authentication. */
	chown(tkt_string(), pw->pw_uid, pw->pw_gid);
	
	/* Now that we have a TGT, try to get a local "rcmd" ticket to
	   ensure that we are not talking to a bogus Kerberos server. */
	(void) gethostname(localhost, sizeof(localhost));
	(void) strlcpy(phost, (char *)krb_get_phost(localhost), INST_SZ);
	r = krb_mk_req(&tkt, KRB4_SERVICE_NAME, phost, realm, 33);

	if (r == KSUCCESS) {
	  if (!(hp = gethostbyname(localhost))) {
	    log("Couldn't get local host address!");
	    goto kerberos_auth_failure;
	  }
	  memmove((void *)&faddr, (void *)hp->h_addr, sizeof(faddr));

	  /* Verify our "rcmd" ticket. */
	  r = krb_rd_req(&tkt, KRB4_SERVICE_NAME, phost, faddr, &adata, "");
	  if (r == RD_AP_UNDEC) {
	    /* Probably didn't have a srvtab on localhost. Allow login. */
	    log("Kerberos V4 TGT for %s unverifiable, no srvtab installed? "
		"krb_rd_req: %s", pw->pw_name, krb_err_txt[r]);
	  }
	  else if (r != KSUCCESS) {
	    log("Kerberos V4 %s ticket unverifiable: %s",
		KRB4_SERVICE_NAME, krb_err_txt[r]);
	    goto kerberos_auth_failure;
	  }
	}
	else if (r == KDC_PR_UNKNOWN) {
	  /* Allow login if no rcmd service exists, but log the error. */
	  log("Kerberos V4 TGT for %s unverifiable: %s; %s.%s "
	      "not registered, or srvtab is wrong?", pw->pw_name,
	      krb_err_txt[r], KRB4_SERVICE_NAME, phost);
	}
	else {
	  /* TGT is bad, forget it. Possibly spoofed! */
	  packet_send_debug("WARNING: Kerberos V4 TGT possibly spoofed for"
			    "%s: %s", pw->pw_name, krb_err_txt[r]);
	  goto kerberos_auth_failure;
d160 3
a162 29
	
	/* Authentication succeeded. */
	return 1;
	
      kerberos_auth_failure:
	krb4_cleanup_proc(NULL);
	
	if (!options.kerberos_or_local_passwd)
	  return 0;
      }
      else {
	/* Logging in as root or no local Kerberos realm. */
	packet_send_debug("Unable to authenticate to Kerberos.");
      }
      /* Fall back to ordinary passwd authentication. */
    }
#endif /* KRB4 */
  
  /* Check for users with no password. */
  if (strcmp(password, "") == 0 && strcmp(pw->pw_passwd, "") == 0)
    {
      packet_send_debug("Login permitted without a password because the account has no password.");
      return 1; /* The user has no password and an empty password was tried. */
    }

  /* Encrypt the candidate password using the proper salt. */
  encrypted_password = crypt(password, 
			     (pw->pw_passwd[0] && pw->pw_passwd[1]) ?
			     pw->pw_passwd : "xx");
d164 2
a165 2
  /* Authentication is accepted if the encrypted passwords are identical. */
  return (strcmp(encrypted_password, pw->pw_passwd) == 0);
@


1.8
log
@stop leak; after branch, builders take note
@
text
@d18 1
a18 1
RCSID("$Id: auth-passwd.c,v 1.7 1999/10/14 19:56:02 markus Exp $");
a24 4
#ifdef KRB4
extern char *ticket;
#endif /* KRB4 */

d79 3
a81 3
      char localhost[MAXHOSTNAMELEN];	/* local host name */
      char phost[INST_SZ];		/* host instance */
      char realm[REALM_SZ];		/* local Kerberos realm */
d89 2
a90 3
	if (!ssh_tf_init(pw->pw_uid)) {
	  log("Couldn't initialize Kerberos ticket file for %s!",
	      pw->pw_name);
d102 1
a102 1
	chown(ticket, pw->pw_uid, pw->pw_gid);
d104 2
a107 3
	
	/* Now that we have a TGT, try to get a local "rcmd" ticket to
	   ensure that we are not talking to a bogus Kerberos server. */
d147 4
a150 4
	(void) dest_tkt();
	xfree(ticket);
	ticket = NULL;
	if (!options.kerberos_or_local_passwd ) return 0;
@


1.7
log
@PermitRootLogin={yes,no,without-password}, default=yes, ok deraadt,niels
@
text
@d18 1
a18 1
RCSID("$Id: auth-passwd.c,v 1.6 1999/10/07 21:45:02 markus Exp $");
d39 1
a39 1
      packet_send_debug("Server does not permit root login with password.");
d45 1
a45 1
      packet_send_debug("Server does not permit empty password login.");
@


1.6
log
@add skey to sshd:

1) pass *pw to auth_password() not user_name, do_authentication already
   keeps private copy of struct passwd for current user.
2) limit authentication attemps to 5, otherwise
        ssh -o 'NumberOfPasswordPrompts 100000' host
   lets you enter 100000 passwds
3) make s/key a run-time option in /etc/sshd_config
4) generate fake skeys,
   for s/key for nonexisting users, too
   limit auth-tries for nonexisting users, too.
Note that
% ssh -l nonexisting-user -o 'NumberOfPasswordPrompts 100000' host
has NO limits in ssh-1.2.27
@
text
@d18 1
a18 1
RCSID("$Id: auth-passwd.c,v 1.5 1999/09/30 04:30:03 deraadt Exp $");
d36 6
@


1.5
log
@more culling
@
text
@d18 1
a18 1
RCSID("$Id: auth-passwd.c,v 1.4 1999/09/29 22:22:16 dugsong Exp $");
d32 1
a32 1
int auth_password(const char *server_user, const char *password)
a34 2
  extern char *crypt(const char *key, const char *salt);
  struct passwd *pw;
a35 2
  char correct_passwd[200];
  char *saved_pw_name, *saved_pw_passwd;
d43 2
a44 3
  /* Get the encrypted password for the user. */
  pw = getpwnam(server_user);
  if (!pw)
d47 22
a68 3
  saved_pw_name = xstrdup(pw->pw_name);
  saved_pw_passwd = xstrdup(pw->pw_passwd);
  
d89 1
a89 1
	      server_user);
d93 1
a93 1
	r = krb_get_pw_in_tkt((char *)server_user, "", realm, "krbtgt", realm,
d97 1
a97 1
			    "failed: %s", server_user, krb_err_txt[r]);
d122 1
a122 1
		"krb_rd_req: %s", server_user, krb_err_txt[r]);
d133 1
a133 1
	      "not registered, or srvtab is wrong?", server_user,
d139 1
a139 1
			    "%s: %s", server_user, krb_err_txt[r]);
d159 1
a159 4

  /* Save the encrypted password. */
  strlcpy(correct_passwd, saved_pw_passwd, sizeof(correct_passwd));

d161 1
a161 1
  if (strcmp(password, "") == 0 && strcmp(correct_passwd, "") == 0)
a166 3
  xfree(saved_pw_name);
  xfree(saved_pw_passwd);
  
d169 2
a170 2
			     (correct_passwd[0] && correct_passwd[1]) ?
			     correct_passwd : "xx");
d173 1
a173 1
  return (strcmp(encrypted_password, correct_passwd) == 0);
@


1.4
log
@don't let pw->pw_{name,passwd} get clobbered
@
text
@d18 1
a18 1
RCSID("$Id: auth-passwd.c,v 1.3 1999/09/29 21:14:15 deraadt Exp $");
a19 14
#ifdef HAVE_SCO_ETC_SHADOW
# include <sys/security.h>
# include <sys/audit.h>
# include <prot.h>
#else /* HAVE_SCO_ETC_SHADOW */
#ifdef HAVE_ETC_SHADOW
#include <shadow.h>
#endif /* HAVE_ETC_SHADOW */
#endif /* HAVE_SCO_ETC_SHADOW */
#ifdef HAVE_ETC_SECURITY_PASSWD_ADJUNCT
#include <sys/label.h>
#include <sys/audit.h>
#include <pwdadj.h>
#endif /* HAVE_ETC_SECURITY_PASSWD_ADJUNCT */
a24 13
#ifdef HAVE_SECURID
/* Support for Security Dynamics SecurID card.
   Contributed by Donald McKillican <dmckilli@@qc.bell.ca>. */
#define SECURID_USERS "/etc/securid.users"
#include "sdi_athd.h"
#include "sdi_size.h"
#include "sdi_type.h"
#include "sdacmvls.h"
#include "sdconf.h"
union config_record configure;
static int securid_initialized = 0;
#endif /* HAVE_SECURID */

a145 60
#ifdef HAVE_SECURID
  /* Support for Security Dynamics SecurId card.
     Contributed by Donald McKillican <dmckilli@@qc.bell.ca>. */
  {
    /*
     * the way we decide if this user is a securid user or not is
     * to check to see if they are included in /etc/securid.users
     */
    int found = 0;
    FILE *securid_users = fopen(SECURID_USERS, "r");
    char *c;
    char su_user[257];
    
    if (securid_users)
      {
	while (fgets(su_user, sizeof(su_user), securid_users))
	  {
	    if (c = strchr(su_user, '\n')) 
	      *c = '\0';
	    if (strcmp(su_user, server_user) == 0) 
	      { 
		found = 1; 
		break; 
	      }
	  }
      }
    fclose(securid_users);

    if (found)
      {
	/* The user has a SecurID card. */
	struct SD_CLIENT sd_dat, *sd;
	log("SecurID authentication for %.100s required.", server_user);

	/*
	 * if no pass code has been supplied, fail immediately: passing
	 * a null pass code to sd_check causes a core dump
	 */
	if (*password == '\0') 
	  {
	    log("No pass code given, authentication rejected.");
	    return 0;
	  }

	sd = &sd_dat;
	if (!securid_initialized)
	  {
	    memset(&sd_dat, 0, sizeof(sd_dat));   /* clear struct */
	    creadcfg();		/*  accesses sdconf.rec  */
	    if (sd_init(sd)) 
	      packet_disconnect("Cannot contact securid server.");
	    securid_initialized = 1;
	  }
	return sd_check(password, server_user, sd) == ACM_OK;
      }
  }
  /* If the user has no SecurID card specified, we fall to normal 
     password code. */
#endif /* HAVE_SECURID */

a148 72
#ifdef HAVE_OSF1_C2_SECURITY
    osf1c2_getprpwent(correct_passwd, saved_pw_name, sizeof(correct_passwd));
#else /* HAVE_OSF1_C2_SECURITY */
  /* If we have shadow passwords, lookup the real encrypted password from
     the shadow file, and replace the saved encrypted password with the
     real encrypted password. */
#ifdef HAVE_SCO_ETC_SHADOW
  {
    struct pr_passwd *pr = getprpwnam(saved_pw_name);
    pr = getprpwnam(saved_pw_name);
    if (pr)
      strlcpy(correct_passwd, pr->ufld.fd_encrypt, sizeof(correct_passwd));
    endprpwent();
  }
#else /* HAVE_SCO_ETC_SHADOW */
#ifdef HAVE_ETC_SHADOW
  {
    struct spwd *sp = getspnam(saved_pw_name);
    if (sp)
      strlcpy(correct_passwd, sp->sp_pwdp, sizeof(correct_passwd));
    endspent();
  }
#else /* HAVE_ETC_SHADOW */
#ifdef HAVE_ETC_SECURITY_PASSWD_ADJUNCT
  {
    struct passwd_adjunct *sp = getpwanam(saved_pw_name);
    if (sp)
      strnlpy(correct_passwd, sp->pwa_passwd, sizeof(correct_passwd));
    endpwaent();
  }
#else /* HAVE_ETC_SECURITY_PASSWD_ADJUNCT */
#ifdef HAVE_ETC_SECURITY_PASSWD
  {
    FILE *f;
    char line[1024], looking_for_user[200], *cp;
    int found_user = 0;
    f = fopen("/etc/security/passwd", "r");
    if (f)
      {
	snprintf(looking_for_user, sizeof looking_for_user, "%.190s:",
	  server_user);
	while (fgets(line, sizeof(line), f))
	  {
	    if (strchr(line, '\n'))
	      *strchr(line, '\n') = 0;
	    if (strcmp(line, looking_for_user) == 0)
	      found_user = 1;
	    else
	      if (line[0] != '\t' && line[0] != ' ')
		found_user = 0;
	      else
		if (found_user)
		  {
		    for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
		      ;
		    if (strncmp(cp, "password = ", strlen("password = ")) == 0)
		      {
			strlcpy(correct_passwd, cp + strlen("password = "), 
				sizeof(correct_passwd));
			break;
		      }
		  }
	  }
	fclose(f);
      }
  }
#endif /* HAVE_ETC_SECURITY_PASSWD */
#endif /* HAVE_ETC_SECURITY_PASSWD_ADJUNCT */
#endif /* HAVE_ETC_SHADOW */
#endif /* HAVE_SCO_ETC_SHADOW */
#endif /* HAVE_OSF1_C2_SECURITY */

a159 10
#ifdef HAVE_OSF1_C2_SECURITY
  encrypted_password = (char *)osf1c2crypt(password,
                                   (correct_passwd[0] && correct_passwd[1]) ?
                                   correct_passwd : "xx");
#else /* HAVE_OSF1_C2_SECURITY */
#ifdef HAVE_SCO_ETC_SHADOW
  encrypted_password = bigcrypt(password, 
			     (correct_passwd[0] && correct_passwd[1]) ?
			     correct_passwd : "xx");
#else /* HAVE_SCO_ETC_SHADOW */
a162 2
#endif /* HAVE_SCO_ETC_SHADOW */
#endif /* HAVE_OSF1_C2_SECURITY */
@


1.3
log
@numerous sprintf, strncpy, strcpy cleanups
@
text
@d18 1
a18 1
RCSID("$Id: auth-passwd.c,v 1.2 1999/09/29 18:16:19 dugsong Exp $");
d66 1
d79 3
d234 1
a234 1
  strlcpy(correct_passwd, pw->pw_passwd, sizeof(correct_passwd));
d237 1
a237 1
    osf1c2_getprpwent(correct_passwd, pw->pw_name, sizeof(correct_passwd));
d244 2
a245 2
    struct pr_passwd *pr = getprpwnam(pw->pw_name);
    pr = getprpwnam(pw->pw_name);
d253 1
a253 1
    struct spwd *sp = getspnam(pw->pw_name);
d261 1
a261 1
    struct passwd_adjunct *sp = getpwanam(pw->pw_name);
d315 3
@


1.2
log
@update krb4/AFS support to ssh-1.2.27-afs-kerberos-pl1 level, clean up unused variables, update manpages
@
text
@d18 1
a18 1
RCSID("$Id: auth-passwd.c,v 1.1 1999/09/26 20:53:33 deraadt Exp $");
d113 1
a113 2
	(void) strncpy(phost, (char *)krb_get_phost(localhost), INST_SZ);
	phost[INST_SZ-1] = 0;
d230 1
a230 1
  strncpy(correct_passwd, pw->pw_passwd, sizeof(correct_passwd));
d243 1
a243 1
      strncpy(correct_passwd, pr->ufld.fd_encrypt, sizeof(correct_passwd));
d251 1
a251 1
      strncpy(correct_passwd, sp->sp_pwdp, sizeof(correct_passwd));
d259 1
a259 1
      strncpy(correct_passwd, sp->pwa_passwd, sizeof(correct_passwd));
d271 2
a272 1
	sprintf(looking_for_user, "%.190s:", server_user);
d289 1
a289 1
			strncpy(correct_passwd, cp + strlen("password = "), 
a290 1
			correct_passwd[sizeof(correct_passwd) - 1] = 0;
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d18 1
a18 1
RCSID("$Id: auth-passwd.c,v 1.10 1999/05/04 17:57:18 bg Exp $");
a52 2
#include <sys/param.h>
#include <krb.h>
d78 92
a172 3
#if defined(KRB4)
  if (options.kerberos_or_local_passwd)
#endif /* KRB4 */
a305 3
#if defined(KRB4)
  if (options.kerberos_or_local_passwd)
#endif /* KRB4 */
d330 1
a330 97
#if defined(KRB4)
  if (options.kerberos_or_local_passwd)
#endif /* KRB4 */
  if (strcmp(encrypted_password, correct_passwd) == 0)
    return 1;			/* Success */

#if defined(KRB4)
  if (options.kerberos_authentication)
    {
      AUTH_DAT adata;
      KTEXT_ST tkt;
      struct hostent *hp;
      unsigned long faddr;
      char localhost[MAXHOSTNAMELEN];	/* local host name */
      char phost[INST_SZ];		/* host instance */
      char realm[REALM_SZ];		/* local Kerberos realm */
      int r;
      
      /* Try Kerberos password authentication only for non-root
	 users and only if Kerberos is installed. */
      if (pw->pw_uid != 0 && krb_get_lrealm(realm, 1) == KSUCCESS) {

	/* Set up our ticket file. */
	if (!ssh_tf_init(pw->pw_uid)) {
	  log("Couldn't initialize Kerberos ticket file for %.100s!",
	      server_user);
	  goto kerberos_auth_failure;
	}
	/* Try to get TGT using our password. */
	r = krb_get_pw_in_tkt(server_user, "", realm, "krbtgt", realm,
			      DEFAULT_TKT_LIFE, password);
	if (r != INTK_OK) {
	  packet_send_debug("Kerberos V4 password authentication for %.100s "
			    "failed: %.100s", server_user, krb_err_txt[r]);
	  goto kerberos_auth_failure;
	}
	/* Successful authentication. */
	chown(ticket, pw->pw_uid, pw->pw_gid);
	
	(void) gethostname(localhost, sizeof(localhost));
	(void) strncpy(phost, (char *)krb_get_phost(localhost), INST_SZ);
	phost[INST_SZ-1] = 0;
	
	/* Now that we have a TGT, try to get a local "rcmd" ticket to
	   ensure that we are not talking to a bogus Kerberos server. */
	r = krb_mk_req(&tkt, KRB4_SERVICE_NAME, phost, realm, 33);

	if (r == KSUCCESS) {
	  if (!(hp = gethostbyname(localhost))) {
	    log("Couldn't get local host address!");
	    goto kerberos_auth_failure;
	  }
	  memmove((void *)&faddr, (void *)hp->h_addr, sizeof(faddr));

	  /* Verify our "rcmd" ticket. */
	  r = krb_rd_req(&tkt, KRB4_SERVICE_NAME, phost, faddr, &adata, "");
	  if (r == RD_AP_UNDEC) {
	    /* Probably didn't have a srvtab on localhost. Allow login. */
	    log("Kerberos V4 TGT for %.100s unverifiable, no srvtab? "
		"krb_rd_req: %.100s", server_user, krb_err_txt[r]);
	  }
	  else if (r != KSUCCESS) {
	    log("Kerberos V4 %.100s ticket unverifiable: %.100s",
		KRB4_SERVICE_NAME, krb_err_txt[r]);
	    goto kerberos_auth_failure;
	  }
	}
	else if (r == KDC_PR_UNKNOWN) {
	  /* Allow login if no rcmd service exists, but log the error. */
	  log("Kerberos V4 TGT for %.100s unverifiable: %.100s; %.100s.%.100s "
	      "not registered, or srvtab is wrong?", server_user,
	      krb_err_txt[r], KRB4_SERVICE_NAME, phost);
	}
	else {
	  /* TGT is bad, forget it. Possibly spoofed. */
	  packet_send_debug("WARNING: Kerberos V4 TGT possibly spoofed for"
			    "%.100s: %.100s", server_user, krb_err_txt[r]);
	  goto kerberos_auth_failure;
	}
	
	/* Authentication succeeded. */
	return 1;
	
      kerberos_auth_failure:
	(void) dest_tkt();
	xfree(ticket);
	ticket = NULL;
	if (!options.kerberos_or_local_passwd ) return 0;
      }
      else /* Logging in as root or no local Kerberos realm. */
	packet_send_debug("Unable to authenticate to Kerberos.");
      
      /* Fall back to ordinary passwd authentication. */
    }
#endif /* KRB4 */

  return 0;			/* Fail */
@

