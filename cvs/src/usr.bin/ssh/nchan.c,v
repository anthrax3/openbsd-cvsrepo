head	1.63;
access;
symbols
	OPENBSD_6_1:1.63.0.32
	OPENBSD_6_1_BASE:1.63
	OPENBSD_6_0:1.63.0.30
	OPENBSD_6_0_BASE:1.63
	OPENBSD_5_9:1.63.0.26
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.63.0.24
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.63.0.18
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.63.0.22
	OPENBSD_5_6_BASE:1.63
	OPENBSD_5_5:1.63.0.20
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.63.0.16
	OPENBSD_5_4_BASE:1.63
	OPENBSD_5_3:1.63.0.14
	OPENBSD_5_3_BASE:1.63
	OPENBSD_5_2:1.63.0.12
	OPENBSD_5_2_BASE:1.63
	OPENBSD_5_1_BASE:1.63
	OPENBSD_5_1:1.63.0.10
	OPENBSD_5_0:1.63.0.8
	OPENBSD_5_0_BASE:1.63
	OPENBSD_4_9:1.63.0.6
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.63.0.4
	OPENBSD_4_8_BASE:1.63
	OPENBSD_4_7:1.63.0.2
	OPENBSD_4_7_BASE:1.63
	OPENBSD_4_6:1.62.0.6
	OPENBSD_4_6_BASE:1.62
	OPENBSD_4_5:1.62.0.2
	OPENBSD_4_5_BASE:1.62
	OPENBSD_4_4:1.60.0.2
	OPENBSD_4_4_BASE:1.60
	OPENBSD_4_3:1.57.0.8
	OPENBSD_4_3_BASE:1.57
	OPENBSD_4_2:1.57.0.6
	OPENBSD_4_2_BASE:1.57
	OPENBSD_4_1:1.57.0.2
	OPENBSD_4_1_BASE:1.57
	OPENBSD_4_0:1.57.0.4
	OPENBSD_4_0_BASE:1.57
	OPENBSD_3_9:1.51.0.8
	OPENBSD_3_9_BASE:1.51
	OPENBSD_3_8:1.51.0.6
	OPENBSD_3_8_BASE:1.51
	OPENBSD_3_7:1.51.0.4
	OPENBSD_3_7_BASE:1.51
	OPENBSD_3_6:1.51.0.2
	OPENBSD_3_6_BASE:1.51
	OPENBSD_3_5:1.49.0.4
	OPENBSD_3_5_BASE:1.49
	OPENBSD_3_4:1.49.0.2
	OPENBSD_3_4_BASE:1.49
	OPENBSD_3_3:1.47.0.4
	OPENBSD_3_3_BASE:1.47
	OPENBSD_3_2:1.47.0.2
	OPENBSD_3_2_BASE:1.47
	OPENBSD_3_1:1.45.0.2
	OPENBSD_3_1_BASE:1.45
	OPENBSD_3_0:1.32.0.2
	OPENBSD_3_0_BASE:1.32
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.63
date	2010.01.26.01.28.35;	author djm;	state Exp;
branches;
next	1.62;

1.62
date	2008.11.07.18.50.18;	author stevesk;	state Exp;
branches;
next	1.61;

1.61
date	2008.09.11.14.22.37;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2008.06.30.12.16.02;	author djm;	state Exp;
branches;
next	1.59;

1.59
date	2008.05.09.16.21.13;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2008.05.08.12.02.23;	author djm;	state Exp;
branches;
next	1.57;

1.57
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.55;

1.55
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.54;

1.54
date	2006.07.08.21.47.12;	author stevesk;	state Exp;
branches;
next	1.53;

1.53
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2004.07.11.17.48.47;	author deraadt;	state Exp;
branches
	1.51.6.1
	1.51.8.1;
next	1.50;

1.50
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches;
next	1.49;

1.49
date	2003.08.29.10.04.36;	author markus;	state Exp;
branches
	1.49.2.1
	1.49.4.1;
next	1.48;

1.48
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches
	1.47.2.1
	1.47.4.1;
next	1.46;

1.46
date	2002.06.09.13.32.01;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2002.03.25.21.13.51;	author markus;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2002.01.21.23.27.10;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2002.01.14.13.57.03;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2002.01.14.13.55.55;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2002.01.14.13.41.13;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2002.01.14.13.40.10;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2002.01.14.13.34.07;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2002.01.14.13.22.35;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2002.01.13.21.31.20;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.10.12.47.59;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2002.01.10.12.38.26;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2002.01.09.17.26.35;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2001.10.10.22.18.47;	author markus;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2001.07.17.21.04.57;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.25.08.25.38;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.23.15.12.19;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.31.10.30.16;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.30.12.55.11;	author markus;	state dead;
branches;
next	1.26;

1.26
date	2001.05.28.23.14.49;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.16.22.09.21;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.04.23.47.34;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.28.08.54.55;	author markus;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2001.01.21.19.05.52;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.19.15.55.11;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.06.23.04.56;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.07.20.27.52;	author deraadt;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2000.06.20.01.39.42;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.08.17.44.54;	author markus;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2000.05.03.10.19.18;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.02.12.44.38;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.14.10.30.32;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.03.07.07.15;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.28.20.34.14;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.28.20.31.27;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.10.10.15.28;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.12.02.20.10.05;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	99.11.24.20.21.48;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	99.11.24.16.15.25;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.11.23.22.25.54;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	99.10.25.21.04.28;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	99.10.25.21.03.17;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	99.10.17.16.56.09;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	99.10.16.22.29.01;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	99.10.16.20.47.14;	author markus;	state Exp;
branches;
next	;

1.17.2.1
date	2000.09.01.18.23.21;	author jason;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2000.11.08.21.30.59;	author jason;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2001.03.12.15.44.12;	author jason;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2001.03.21.18.52.53;	author jason;	state Exp;
branches;
next	;

1.19.2.1
date	2001.02.16.20.13.08;	author jason;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.02.19.17.19.08;	author jason;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2001.03.21.19.46.26;	author jason;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2001.05.07.21.09.31;	author jason;	state Exp;
branches;
next	1.19.2.5;

1.19.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.19.2.6;

1.19.2.6
date	2001.11.15.00.14.59;	author miod;	state Exp;
branches;
next	1.19.2.7;

1.19.2.7
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.23.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.23.2.4;

1.23.2.4
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.32.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	;

1.45.2.1
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	;

1.47.2.1
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.47.4.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.47.4.2;

1.47.4.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.49.2.1
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.49.4.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	;

1.51.6.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.51.8.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.63
log
@rewrite ssh(1) multiplexing code to a more sensible protocol.

The new multiplexing code uses channels for the listener and
accepted control sockets to make the mux master non-blocking, so
no stalls when processing messages from a slave.

avoid use of fatal() in mux master protocol parsing so an errant slave
process cannot take down a running master.

implement requesting of port-forwards over multiplexed sessions. Any
port forwards requested by the slave are added to those the master has
established.

add support for stdio forwarding ("ssh -W host:port ...") in mux slaves.

document master/slave mux protocol so that other tools can use it to
control a running ssh(1). Note: there are no guarantees that this
protocol won't be incompatibly changed (though it is versioned).

feedback Salvador Fandino, dtucker@@
channel changes ok markus@@
@
text
@/* $OpenBSD: nchan.c,v 1.62 2008/11/07 18:50:18 stevesk Exp $ */
/*
 * Copyright (c) 1999, 2000, 2001, 2002 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>

#include <errno.h>
#include <string.h>
#include <stdarg.h>

#include "ssh1.h"
#include "ssh2.h"
#include "buffer.h"
#include "packet.h"
#include "channels.h"
#include "compat.h"
#include "log.h"

/*
 * SSH Protocol 1.5 aka New Channel Protocol
 * Thanks to Martina, Axel and everyone who left Erlangen, leaving me bored.
 * Written by Markus Friedl in October 1999
 *
 * Protocol versions 1.3 and 1.5 differ in the handshake protocol used for the
 * tear down of channels:
 *
 * 1.3:	strict request-ack-protocol:
 *	CLOSE	->
 *		<-  CLOSE_CONFIRM
 *
 * 1.5:	uses variations of:
 *	IEOF	->
 *		<-  OCLOSE
 *		<-  IEOF
 *	OCLOSE	->
 *	i.e. both sides have to close the channel
 *
 * 2.0: the EOF messages are optional
 *
 * See the debugging output from 'ssh -v' and 'sshd -d' of
 * ssh-1.2.27 as an example.
 *
 */

/* functions manipulating channel states */
/*
 * EVENTS update channel input/output states execute ACTIONS
 */
/*
 * ACTIONS: should never update the channel states
 */
static void	chan_send_ieof1(Channel *);
static void	chan_send_oclose1(Channel *);
static void	chan_send_close2(Channel *);
static void	chan_send_eof2(Channel *);
static void	chan_send_eow2(Channel *);

/* helper */
static void	chan_shutdown_write(Channel *);
static void	chan_shutdown_read(Channel *);

static char *ostates[] = { "open", "drain", "wait_ieof", "closed" };
static char *istates[] = { "open", "drain", "wait_oclose", "closed" };

static void
chan_set_istate(Channel *c, u_int next)
{
	if (c->istate > CHAN_INPUT_CLOSED || next > CHAN_INPUT_CLOSED)
		fatal("chan_set_istate: bad state %d -> %d", c->istate, next);
	debug2("channel %d: input %s -> %s", c->self, istates[c->istate],
	    istates[next]);
	c->istate = next;
}
static void
chan_set_ostate(Channel *c, u_int next)
{
	if (c->ostate > CHAN_OUTPUT_CLOSED || next > CHAN_OUTPUT_CLOSED)
		fatal("chan_set_ostate: bad state %d -> %d", c->ostate, next);
	debug2("channel %d: output %s -> %s", c->self, ostates[c->ostate],
	    ostates[next]);
	c->ostate = next;
}

/*
 * SSH1 specific implementation of event functions
 */

static void
chan_rcvd_oclose1(Channel *c)
{
	debug2("channel %d: rcvd oclose", c->self);
	switch (c->istate) {
	case CHAN_INPUT_WAIT_OCLOSE:
		chan_set_istate(c, CHAN_INPUT_CLOSED);
		break;
	case CHAN_INPUT_OPEN:
		chan_shutdown_read(c);
		chan_send_ieof1(c);
		chan_set_istate(c, CHAN_INPUT_CLOSED);
		break;
	case CHAN_INPUT_WAIT_DRAIN:
		/* both local read_failed and remote write_failed  */
		chan_send_ieof1(c);
		chan_set_istate(c, CHAN_INPUT_CLOSED);
		break;
	default:
		error("channel %d: protocol error: rcvd_oclose for istate %d",
		    c->self, c->istate);
		return;
	}
}
void
chan_read_failed(Channel *c)
{
	debug2("channel %d: read failed", c->self);
	switch (c->istate) {
	case CHAN_INPUT_OPEN:
		chan_shutdown_read(c);
		chan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);
		break;
	default:
		error("channel %d: chan_read_failed for istate %d",
		    c->self, c->istate);
		break;
	}
}
void
chan_ibuf_empty(Channel *c)
{
	debug2("channel %d: ibuf empty", c->self);
	if (buffer_len(&c->input)) {
		error("channel %d: chan_ibuf_empty for non empty buffer",
		    c->self);
		return;
	}
	switch (c->istate) {
	case CHAN_INPUT_WAIT_DRAIN:
		if (compat20) {
			if (!(c->flags & (CHAN_CLOSE_SENT|CHAN_LOCAL)))
				chan_send_eof2(c);
			chan_set_istate(c, CHAN_INPUT_CLOSED);
		} else {
			chan_send_ieof1(c);
			chan_set_istate(c, CHAN_INPUT_WAIT_OCLOSE);
		}
		break;
	default:
		error("channel %d: chan_ibuf_empty for istate %d",
		    c->self, c->istate);
		break;
	}
}
static void
chan_rcvd_ieof1(Channel *c)
{
	debug2("channel %d: rcvd ieof", c->self);
	switch (c->ostate) {
	case CHAN_OUTPUT_OPEN:
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);
		break;
	case CHAN_OUTPUT_WAIT_IEOF:
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
		break;
	default:
		error("channel %d: protocol error: rcvd_ieof for ostate %d",
		    c->self, c->ostate);
		break;
	}
}
static void
chan_write_failed1(Channel *c)
{
	debug2("channel %d: write failed", c->self);
	switch (c->ostate) {
	case CHAN_OUTPUT_OPEN:
		chan_shutdown_write(c);
		chan_send_oclose1(c);
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_IEOF);
		break;
	case CHAN_OUTPUT_WAIT_DRAIN:
		chan_shutdown_write(c);
		chan_send_oclose1(c);
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
		break;
	default:
		error("channel %d: chan_write_failed for ostate %d",
		    c->self, c->ostate);
		break;
	}
}
void
chan_obuf_empty(Channel *c)
{
	debug2("channel %d: obuf empty", c->self);
	if (buffer_len(&c->output)) {
		error("channel %d: chan_obuf_empty for non empty buffer",
		    c->self);
		return;
	}
	switch (c->ostate) {
	case CHAN_OUTPUT_WAIT_DRAIN:
		chan_shutdown_write(c);
		if (!compat20)
			chan_send_oclose1(c);
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
		break;
	default:
		error("channel %d: internal error: obuf_empty for ostate %d",
		    c->self, c->ostate);
		break;
	}
}
static void
chan_send_ieof1(Channel *c)
{
	debug2("channel %d: send ieof", c->self);
	switch (c->istate) {
	case CHAN_INPUT_OPEN:
	case CHAN_INPUT_WAIT_DRAIN:
		packet_start(SSH_MSG_CHANNEL_INPUT_EOF);
		packet_put_int(c->remote_id);
		packet_send();
		break;
	default:
		error("channel %d: cannot send ieof for istate %d",
		    c->self, c->istate);
		break;
	}
}
static void
chan_send_oclose1(Channel *c)
{
	debug2("channel %d: send oclose", c->self);
	switch (c->ostate) {
	case CHAN_OUTPUT_OPEN:
	case CHAN_OUTPUT_WAIT_DRAIN:
		buffer_clear(&c->output);
		packet_start(SSH_MSG_CHANNEL_OUTPUT_CLOSE);
		packet_put_int(c->remote_id);
		packet_send();
		break;
	default:
		error("channel %d: cannot send oclose for ostate %d",
		    c->self, c->ostate);
		break;
	}
}

/*
 * the same for SSH2
 */
static void
chan_rcvd_close2(Channel *c)
{
	debug2("channel %d: rcvd close", c->self);
	if (!(c->flags & CHAN_LOCAL)) {
		if (c->flags & CHAN_CLOSE_RCVD)
			error("channel %d: protocol error: close rcvd twice",
			    c->self);
		c->flags |= CHAN_CLOSE_RCVD;
	}
	if (c->type == SSH_CHANNEL_LARVAL) {
		/* tear down larval channels immediately */
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
		chan_set_istate(c, CHAN_INPUT_CLOSED);
		return;
	}
	switch (c->ostate) {
	case CHAN_OUTPUT_OPEN:
		/*
		 * wait until a data from the channel is consumed if a CLOSE
		 * is received
		 */
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);
		break;
	}
	switch (c->istate) {
	case CHAN_INPUT_OPEN:
		chan_shutdown_read(c);
		chan_set_istate(c, CHAN_INPUT_CLOSED);
		break;
	case CHAN_INPUT_WAIT_DRAIN:
		if (!(c->flags & CHAN_LOCAL))
			chan_send_eof2(c);
		chan_set_istate(c, CHAN_INPUT_CLOSED);
		break;
	}
}

void
chan_rcvd_eow(Channel *c)
{
	debug2("channel %d: rcvd eow", c->self);
	switch (c->istate) {
	case CHAN_INPUT_OPEN:
		chan_shutdown_read(c);
		chan_set_istate(c, CHAN_INPUT_CLOSED);
		break;
	}
}
static void
chan_rcvd_eof2(Channel *c)
{
	debug2("channel %d: rcvd eof", c->self);
	c->flags |= CHAN_EOF_RCVD;
	if (c->ostate == CHAN_OUTPUT_OPEN)
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);
}
static void
chan_write_failed2(Channel *c)
{
	debug2("channel %d: write failed", c->self);
	switch (c->ostate) {
	case CHAN_OUTPUT_OPEN:
	case CHAN_OUTPUT_WAIT_DRAIN:
		chan_shutdown_write(c);
		if (strcmp(c->ctype, "session") == 0)
			chan_send_eow2(c);
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
		break;
	default:
		error("channel %d: chan_write_failed for ostate %d",
		    c->self, c->ostate);
		break;
	}
}
static void
chan_send_eof2(Channel *c)
{
	debug2("channel %d: send eof", c->self);
	switch (c->istate) {
	case CHAN_INPUT_WAIT_DRAIN:
		packet_start(SSH2_MSG_CHANNEL_EOF);
		packet_put_int(c->remote_id);
		packet_send();
		c->flags |= CHAN_EOF_SENT;
		break;
	default:
		error("channel %d: cannot send eof for istate %d",
		    c->self, c->istate);
		break;
	}
}
static void
chan_send_close2(Channel *c)
{
	debug2("channel %d: send close", c->self);
	if (c->ostate != CHAN_OUTPUT_CLOSED ||
	    c->istate != CHAN_INPUT_CLOSED) {
		error("channel %d: cannot send close for istate/ostate %d/%d",
		    c->self, c->istate, c->ostate);
	} else if (c->flags & CHAN_CLOSE_SENT) {
		error("channel %d: already sent close", c->self);
	} else {
		packet_start(SSH2_MSG_CHANNEL_CLOSE);
		packet_put_int(c->remote_id);
		packet_send();
		c->flags |= CHAN_CLOSE_SENT;
	}
}
static void
chan_send_eow2(Channel *c)
{
	debug2("channel %d: send eow", c->self);
	if (c->ostate == CHAN_OUTPUT_CLOSED) {
		error("channel %d: must not sent eow on closed output",
		    c->self);
		return;
	}
	if (!(datafellows & SSH_NEW_OPENSSH))
		return;
	packet_start(SSH2_MSG_CHANNEL_REQUEST);
	packet_put_int(c->remote_id);
	packet_put_cstring("eow@@openssh.com");
	packet_put_char(0);
	packet_send();
}

/* shared */

void
chan_rcvd_ieof(Channel *c)
{
	if (compat20)
		chan_rcvd_eof2(c);
	else
		chan_rcvd_ieof1(c);
	if (c->ostate == CHAN_OUTPUT_WAIT_DRAIN &&
	    buffer_len(&c->output) == 0 &&
	    !CHANNEL_EFD_OUTPUT_ACTIVE(c))
		chan_obuf_empty(c);
}
void
chan_rcvd_oclose(Channel *c)
{
	if (compat20)
		chan_rcvd_close2(c);
	else
		chan_rcvd_oclose1(c);
}
void
chan_write_failed(Channel *c)
{
	if (compat20)
		chan_write_failed2(c);
	else
		chan_write_failed1(c);
}

void
chan_mark_dead(Channel *c)
{
	c->type = SSH_CHANNEL_ZOMBIE;
}

int
chan_is_dead(Channel *c, int do_send)
{
	if (c->type == SSH_CHANNEL_ZOMBIE) {
		debug2("channel %d: zombie", c->self);
		return 1;
	}
	if (c->istate != CHAN_INPUT_CLOSED || c->ostate != CHAN_OUTPUT_CLOSED)
		return 0;
	if (!compat20) {
		debug2("channel %d: is dead", c->self);
		return 1;
	}
	if ((datafellows & SSH_BUG_EXTEOF) &&
	    c->extended_usage == CHAN_EXTENDED_WRITE &&
	    c->efd != -1 &&
	    buffer_len(&c->extended) > 0) {
		debug2("channel %d: active efd: %d len %d",
		    c->self, c->efd, buffer_len(&c->extended));
		return 0;
	}
	if (c->flags & CHAN_LOCAL) {
		debug2("channel %d: is dead (local)", c->self);
		return 1;
	}		
	if (!(c->flags & CHAN_CLOSE_SENT)) {
		if (do_send) {
			chan_send_close2(c);
		} else {
			/* channel would be dead if we sent a close */
			if (c->flags & CHAN_CLOSE_RCVD) {
				debug2("channel %d: almost dead",
				    c->self);
				return 1;
			}
		}
	}
	if ((c->flags & CHAN_CLOSE_SENT) &&
	    (c->flags & CHAN_CLOSE_RCVD)) {
		debug2("channel %d: is dead", c->self);
		return 1;
	}
	return 0;
}

/* helper */
static void
chan_shutdown_write(Channel *c)
{
	buffer_clear(&c->output);
	if (compat20 && c->type == SSH_CHANNEL_LARVAL)
		return;
	/* shutdown failure is allowed if write failed already */
	debug2("channel %d: close_write", c->self);
	if (c->sock != -1) {
		if (shutdown(c->sock, SHUT_WR) < 0)
			debug2("channel %d: chan_shutdown_write: "
			    "shutdown() failed for fd %d: %.100s",
			    c->self, c->sock, strerror(errno));
	} else {
		if (channel_close_fd(&c->wfd) < 0)
			logit("channel %d: chan_shutdown_write: "
			    "close() failed for fd %d: %.100s",
			    c->self, c->wfd, strerror(errno));
	}
}
static void
chan_shutdown_read(Channel *c)
{
	if (compat20 && c->type == SSH_CHANNEL_LARVAL)
		return;
	debug2("channel %d: close_read", c->self);
	if (c->sock != -1) {
		if (shutdown(c->sock, SHUT_RD) < 0)
			error("channel %d: chan_shutdown_read: "
			    "shutdown() failed for fd %d [i%d o%d]: %.100s",
			    c->self, c->sock, c->istate, c->ostate,
			    strerror(errno));
	} else {
		if (channel_close_fd(&c->rfd) < 0)
			logit("channel %d: chan_shutdown_read: "
			    "close() failed for fd %d: %.100s",
			    c->self, c->rfd, strerror(errno));
	}
}
@


1.62
log
@add space to some log/debug messages for readability; ok djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: nchan.c,v 1.61 2008/09/11 14:22:37 markus Exp $ */
d162 1
a162 1
			if (!(c->flags & CHAN_CLOSE_SENT))
d279 6
a284 3
	if (c->flags & CHAN_CLOSE_RCVD)
		error("channel %d: protocol error: close rcvd twice", c->self);
	c->flags |= CHAN_CLOSE_RCVD;
d306 2
a307 1
		chan_send_eof2(c);
d312 1
d460 4
@


1.61
log
@only send eow and no-more-sessions requests to openssh 5 and newer;
fixes interop problems with broken ssh v2 implementations; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: nchan.c,v 1.60 2008/06/30 12:16:02 djm Exp $ */
d487 1
a487 1
			    "shutdown() failed for fd%d: %.100s",
d492 1
a492 1
			    "close() failed for fd%d: %.100s",
d505 1
a505 1
			    "shutdown() failed for fd%d [i%d o%d]: %.100s",
d511 1
a511 1
			    "close() failed for fd%d: %.100s",
@


1.60
log
@only send eow@@openssh.com notifications for session channels; ok! markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: nchan.c,v 1.59 2008/05/09 16:21:13 markus Exp $ */
d388 2
@


1.59
log
@unbreak
	ssh -2 localhost od /bin/ls | true
ignoring SIGPIPE by adding a new channel message (EOW) that signals
the peer that we're not interested in any data it might send.
fixes bz #85; discussion, debugging and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: nchan.c,v 1.58 2008/05/08 12:02:23 djm Exp $ */
d335 2
a336 1
		chan_send_eow2(c);
@


1.58
log
@Implement a channel success/failure status confirmation callback
mechanism. Each channel maintains a queue of callbacks, which will
be drained in order (RFC4253 guarantees confirm messages are not
reordered within an channel).

Also includes a abandonment callback to clean up if a channel is
closed without sending confirmation messages. This probably
shouldn't happen in compliant implementations, but it could be
abused to leak memory.

ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: nchan.c,v 1.57 2006/08/03 03:34:42 deraadt Exp $ */
d79 1
d308 11
d335 1
d377 15
@


1.57
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: nchan.c,v 1.56 2006/07/22 20:48:23 stevesk Exp $ */
d28 1
@


1.56
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: nchan.c,v 1.55 2006/07/11 20:07:25 stevesk Exp $ */
a25 2
#include "includes.h"

d31 1
@


1.55
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: nchan.c,v 1.54 2006/07/08 21:47:12 stevesk Exp $ */
d32 1
@


1.54
log
@move #include <sys/socket.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: nchan.c,v 1.53 2006/03/25 13:17:02 djm Exp $ */
d30 2
@


1.53
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d27 3
@


1.52
log
@RCSID() can die
@
text
@d1 1
@


1.51
log
@spaces
@
text
@a25 1
RCSID("$OpenBSD: nchan.c,v 1.50 2004/06/21 17:36:31 avsm Exp $");
@


1.51.6.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: nchan.c,v 1.57 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 6
#include <sys/types.h>
#include <sys/socket.h>

#include <errno.h>
#include <string.h>
#include <stdarg.h>
@


1.51.8.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: nchan.c,v 1.57 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 6
#include <sys/types.h>
#include <sys/socket.h>

#include <errno.h>
#include <string.h>
#include <stdarg.h>
@


1.50
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.49 2003/08/29 10:04:36 markus Exp $");
d45 2
a46 2
 * 	CLOSE	->
 * 		<-  CLOSE_CONFIRM
d49 5
a53 5
 * 	IEOF	->
 * 		<-  OCLOSE
 * 		<-  IEOF
 * 	OCLOSE	->
 * 	i.e. both sides have to close the channel
@


1.49
log
@be less chatty; debug -> debug2, cleanup; ok henning@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.48 2003/04/08 20:21:29 itojun Exp $");
d398 1
a398 1
chan_is_dead(Channel *c, int send)
d419 1
a419 1
		if (send) {
@


1.49.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.51 2004/07/11 17:48:47 deraadt Exp $");
d45 2
a46 2
 *	CLOSE	->
 *		<-  CLOSE_CONFIRM
d49 5
a53 5
 *	IEOF	->
 *		<-  OCLOSE
 *		<-  IEOF
 *	OCLOSE	->
 *	i.e. both sides have to close the channel
d398 1
a398 1
chan_is_dead(Channel *c, int do_send)
d419 1
a419 1
		if (do_send) {
@


1.49.4.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.51 2004/07/11 17:48:47 deraadt Exp $");
d45 2
a46 2
 *	CLOSE	->
 *		<-  CLOSE_CONFIRM
d49 5
a53 5
 *	IEOF	->
 *		<-  OCLOSE
 *		<-  IEOF
 *	OCLOSE	->
 *	i.e. both sides have to close the channel
d398 1
a398 1
chan_is_dead(Channel *c, int do_send)
d419 1
a419 1
		if (do_send) {
@


1.48
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.47 2002/06/19 00:27:55 deraadt Exp $");
d86 1
a86 1
	debug("channel %d: input %s -> %s", c->self, istates[c->istate],
d95 1
a95 1
	debug("channel %d: output %s -> %s", c->self, ostates[c->ostate],
d107 1
a107 1
	debug("channel %d: rcvd oclose", c->self);
d131 1
a131 1
	debug("channel %d: read failed", c->self);
d146 1
a146 1
	debug("channel %d: ibuf empty", c->self);
d172 1
a172 1
	debug("channel %d: rcvd ieof", c->self);
d189 1
a189 1
	debug("channel %d: write failed", c->self);
d210 1
a210 1
	debug("channel %d: obuf empty", c->self);
d232 1
a232 1
	debug("channel %d: send ieof", c->self);
d249 1
a249 1
	debug("channel %d: send oclose", c->self);
d271 1
a271 1
	debug("channel %d: rcvd close", c->self);
d304 1
a304 1
	debug("channel %d: rcvd eof", c->self);
d312 1
a312 1
	debug("channel %d: write failed", c->self);
d328 1
a328 1
	debug("channel %d: send eof", c->self);
d345 1
a345 1
	debug("channel %d: send close", c->self);
d401 1
a401 1
		debug("channel %d: zombie", c->self);
d407 1
a407 1
		debug("channel %d: is dead", c->self);
d424 1
a424 1
				debug("channel %d: almost dead",
d432 1
a432 1
		debug("channel %d: is dead", c->self);
d446 1
a446 1
	debug("channel %d: close_write", c->self);
d449 1
a449 1
			debug("channel %d: chan_shutdown_write: "
d464 1
a464 1
	debug("channel %d: close_read", c->self);
@


1.47
log
@KNF done automatically while reading....
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.46 2002/06/09 13:32:01 markus Exp $");
d454 1
a454 1
			log("channel %d: chan_shutdown_write: "
d473 1
a473 1
			log("channel %d: chan_shutdown_read: "
@


1.47.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.49 2003/08/29 10:04:36 markus Exp $");
d86 1
a86 1
	debug2("channel %d: input %s -> %s", c->self, istates[c->istate],
d95 1
a95 1
	debug2("channel %d: output %s -> %s", c->self, ostates[c->ostate],
d107 1
a107 1
	debug2("channel %d: rcvd oclose", c->self);
d131 1
a131 1
	debug2("channel %d: read failed", c->self);
d146 1
a146 1
	debug2("channel %d: ibuf empty", c->self);
d172 1
a172 1
	debug2("channel %d: rcvd ieof", c->self);
d189 1
a189 1
	debug2("channel %d: write failed", c->self);
d210 1
a210 1
	debug2("channel %d: obuf empty", c->self);
d232 1
a232 1
	debug2("channel %d: send ieof", c->self);
d249 1
a249 1
	debug2("channel %d: send oclose", c->self);
d271 1
a271 1
	debug2("channel %d: rcvd close", c->self);
d304 1
a304 1
	debug2("channel %d: rcvd eof", c->self);
d312 1
a312 1
	debug2("channel %d: write failed", c->self);
d328 1
a328 1
	debug2("channel %d: send eof", c->self);
d345 1
a345 1
	debug2("channel %d: send close", c->self);
d401 1
a401 1
		debug2("channel %d: zombie", c->self);
d407 1
a407 1
		debug2("channel %d: is dead", c->self);
d424 1
a424 1
				debug2("channel %d: almost dead",
d432 1
a432 1
		debug2("channel %d: is dead", c->self);
d446 1
a446 1
	debug2("channel %d: close_write", c->self);
d449 1
a449 1
			debug2("channel %d: chan_shutdown_write: "
d454 1
a454 1
			logit("channel %d: chan_shutdown_write: "
d464 1
a464 1
	debug2("channel %d: close_read", c->self);
d473 1
a473 1
			logit("channel %d: chan_shutdown_read: "
@


1.47.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.49 2003/08/29 10:04:36 markus Exp $");
d86 1
a86 1
	debug2("channel %d: input %s -> %s", c->self, istates[c->istate],
d95 1
a95 1
	debug2("channel %d: output %s -> %s", c->self, ostates[c->ostate],
d107 1
a107 1
	debug2("channel %d: rcvd oclose", c->self);
d131 1
a131 1
	debug2("channel %d: read failed", c->self);
d146 1
a146 1
	debug2("channel %d: ibuf empty", c->self);
d172 1
a172 1
	debug2("channel %d: rcvd ieof", c->self);
d189 1
a189 1
	debug2("channel %d: write failed", c->self);
d210 1
a210 1
	debug2("channel %d: obuf empty", c->self);
d232 1
a232 1
	debug2("channel %d: send ieof", c->self);
d249 1
a249 1
	debug2("channel %d: send oclose", c->self);
d271 1
a271 1
	debug2("channel %d: rcvd close", c->self);
d304 1
a304 1
	debug2("channel %d: rcvd eof", c->self);
d312 1
a312 1
	debug2("channel %d: write failed", c->self);
d328 1
a328 1
	debug2("channel %d: send eof", c->self);
d345 1
a345 1
	debug2("channel %d: send close", c->self);
d401 1
a401 1
		debug2("channel %d: zombie", c->self);
d407 1
a407 1
		debug2("channel %d: is dead", c->self);
d424 1
a424 1
				debug2("channel %d: almost dead",
d432 1
a432 1
		debug2("channel %d: is dead", c->self);
d446 1
a446 1
	debug2("channel %d: close_write", c->self);
d449 1
a449 1
			debug2("channel %d: chan_shutdown_write: "
d454 1
a454 1
			logit("channel %d: chan_shutdown_write: "
d464 1
a464 1
	debug2("channel %d: close_read", c->self);
d473 1
a473 1
			logit("channel %d: chan_shutdown_read: "
@


1.47.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@@


1.46
log
@use tab not spaces (|unexpand)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.45 2002/03/25 21:13:51 markus Exp $");
d370 1
a370 1
	    buffer_len(&c->output) == 0 && 
@


1.45
log
@don't send stderr data after EOF, accept this from older known (broken)
sshd servers only, fixes http://bugzilla.mindrot.org/show_bug.cgi?id=179
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.44 2002/01/21 23:27:10 markus Exp $");
d414 2
a415 2
                debug2("channel %d: active efd: %d len %d",
                    c->self, c->efd, buffer_len(&c->extended));
@


1.45.2.1
log
@Pull in OpenSSH-3.4
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.47 2002/06/19 00:27:55 deraadt Exp $");
d370 1
a370 1
	    buffer_len(&c->output) == 0 &&
d414 2
a415 2
		debug2("channel %d: active efd: %d len %d",
		    c->self, c->efd, buffer_len(&c->extended));
@


1.44
log
@cleanup channels faster if the are empty and we are in drain-state; ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.43 2002/01/14 13:57:03 markus Exp $");
d305 1
d334 1
d370 2
a371 1
	    buffer_len(&c->output) == 0)
d410 17
a426 26
	/*
	 * we have to delay the close message if the efd (for stderr) is
	 * still active
	 */
	if (((c->extended_usage != CHAN_EXTENDED_IGNORE) &&
	    buffer_len(&c->extended) > 0)
#if 0
	    || ((c->extended_usage == CHAN_EXTENDED_READ) &&
	    c->efd != -1)
#endif
	    ) {
		debug2("channel %d: active efd: %d len %d type %s",
		    c->self, c->efd, buffer_len(&c->extended),
		    c->extended_usage==CHAN_EXTENDED_READ ?
		    "read": "write");
	} else {
		if (!(c->flags & CHAN_CLOSE_SENT)) {
			if (send) {
				chan_send_close2(c);
			} else {
				/* channel would be dead if we sent a close */
				if (c->flags & CHAN_CLOSE_RCVD) {
					debug("channel %d: almost dead",
					    c->self);
					return 1;
				}
d429 5
a433 5
		if ((c->flags & CHAN_CLOSE_SENT) &&
		    (c->flags & CHAN_CLOSE_RCVD)) {
			debug("channel %d: is dead", c->self);
			return 1;
		}
@


1.43
log
@(c) 2002
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.42 2002/01/14 13:55:55 markus Exp $");
d367 3
@


1.42
log
@remove function pointers for events, remove chan_init*; ok provos@@
@
text
@d2 1
a2 1
 * Copyright (c) 1999, 2000, 2001 Markus Friedl.  All rights reserved.
d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.41 2002/01/14 13:41:13 markus Exp $");
@


1.41
log
@remove duplicated code; ok provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.40 2002/01/14 13:40:10 markus Exp $");
a65 8
/* events concerning the INPUT from socket for channel (istate) */
chan_event_fn *chan_rcvd_oclose			= NULL;
chan_event_fn *chan_read_failed			= NULL;
chan_event_fn *chan_ibuf_empty			= NULL;
/* events concerning the OUTPUT from channel for socket (ostate) */
chan_event_fn *chan_rcvd_ieof			= NULL;
chan_event_fn *chan_write_failed		= NULL;
chan_event_fn *chan_obuf_empty			= NULL;
d128 2
a129 2
static void
chan_read_failed_12(Channel *c)
d143 2
a144 2
static void
chan_ibuf_empty1(Channel *c)
d207 2
a208 2
static void
chan_obuf_empty1(Channel *c)
a301 5
chan_ibuf_empty2(Channel *c)
{
	chan_ibuf_empty1(c);
}
static void
a324 5
chan_obuf_empty2(Channel *c)
{
	chan_obuf_empty1(c);
}
static void
d361 25
a438 31
}

void
chan_init_iostates(Channel *c)
{
	c->ostate = CHAN_OUTPUT_OPEN;
	c->istate = CHAN_INPUT_OPEN;
	c->flags = 0;
}

/* init */
void
chan_init(void)
{
	if (compat20) {
		chan_rcvd_oclose		= chan_rcvd_close2;
		chan_read_failed		= chan_read_failed_12;
		chan_ibuf_empty			= chan_ibuf_empty2;

		chan_rcvd_ieof			= chan_rcvd_eof2;
		chan_write_failed		= chan_write_failed2;
		chan_obuf_empty			= chan_obuf_empty2;
	} else {
		chan_rcvd_oclose		= chan_rcvd_oclose1;
		chan_read_failed		= chan_read_failed_12;
		chan_ibuf_empty			= chan_ibuf_empty1;

		chan_rcvd_ieof			= chan_rcvd_ieof1;
		chan_write_failed		= chan_write_failed1;
		chan_obuf_empty			= chan_obuf_empty1;
	}
@


1.40
log
@correct fn names for ssh2, do not switch from closed to closed; ok provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.39 2002/01/14 13:34:07 markus Exp $");
a326 3
		chan_shutdown_write(c); /* ?? */
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
		break;
@


1.39
log
@merge chan_[io]buf_empty[12]; ok provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.38 2002/01/14 13:22:35 markus Exp $");
d277 1
a277 1
chan_rcvd_oclose2(Channel *c)
d301 1
d305 1
a307 1
	chan_set_istate(c, CHAN_INPUT_CLOSED);
d315 1
a315 1
chan_rcvd_ieof2(Channel *c)
d450 1
a450 1
		chan_rcvd_oclose		= chan_rcvd_oclose2;
d454 1
a454 1
		chan_rcvd_ieof			= chan_rcvd_ieof2;
@


1.38
log
@chan_send_oclose1() no longer calls chan_shutdown_write(); ok provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.37 2002/01/13 21:31:20 markus Exp $");
d162 8
a169 2
		chan_send_ieof1(c);
		chan_set_istate(c, CHAN_INPUT_WAIT_OCLOSE);
d227 2
a228 1
		chan_send_oclose1(c);
d311 1
a311 17
	debug("channel %d: ibuf empty", c->self);
	if (buffer_len(&c->input)) {
		error("channel %d: chan_ibuf_empty for non empty buffer",
		    c->self);
		return;
	}
	switch (c->istate) {
	case CHAN_INPUT_WAIT_DRAIN:
		if (!(c->flags & CHAN_CLOSE_SENT))
			chan_send_eof2(c);
		chan_set_istate(c, CHAN_INPUT_CLOSED);
		break;
	default:
		error("channel %d: chan_ibuf_empty for istate %d",
		    c->self, c->istate);
		break;
	}
d342 1
a342 16
	debug("channel %d: obuf empty", c->self);
	if (buffer_len(&c->output)) {
		error("channel %d: chan_obuf_empty for non empty buffer",
		    c->self);
		return;
	}
	switch (c->ostate) {
	case CHAN_OUTPUT_WAIT_DRAIN:
		chan_shutdown_write(c);
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
		break;
	default:
		error("channel %d: chan_obuf_empty for ostate %d",
		    c->self, c->ostate);
		break;
	}
@


1.37
log
@add chan_set_[io]state(), order states, state is now an u_int,
simplifies debugging messages; ok provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.36 2002/01/10 12:47:59 markus Exp $");
d194 1
d199 1
d220 1
a253 1
		chan_shutdown_write(c);
@


1.36
log
@more unused code (with channels.c:1.156)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.35 2002/01/10 12:38:26 markus Exp $");
d86 22
d118 1
a118 2
		debug("channel %d: input wait_oclose -> closed", c->self);
		c->istate = CHAN_INPUT_CLOSED;
a120 1
		debug("channel %d: input open -> closed", c->self);
d123 1
a123 1
		c->istate = CHAN_INPUT_CLOSED;
a126 1
		log("channel %d: input drain -> closed", c->self);
d128 1
a128 1
		c->istate = CHAN_INPUT_CLOSED;
a141 1
		debug("channel %d: input open -> drain", c->self);
d143 1
a143 1
		c->istate = CHAN_INPUT_WAIT_DRAIN;
a161 1
		debug("channel %d: input drain -> wait_oclose", c->self);
d163 1
a163 1
		c->istate = CHAN_INPUT_WAIT_OCLOSE;
d177 1
a177 2
		debug("channel %d: output open -> drain", c->self);
		c->ostate = CHAN_OUTPUT_WAIT_DRAIN;
d180 1
a180 2
		debug("channel %d: output wait_ieof -> closed", c->self);
		c->ostate = CHAN_OUTPUT_CLOSED;
a193 1
		debug("channel %d: output open -> wait_ieof", c->self);
d195 1
a195 1
		c->ostate = CHAN_OUTPUT_WAIT_IEOF;
a197 1
		debug("channel %d: output wait_drain -> closed", c->self);
d199 1
a199 1
		c->ostate = CHAN_OUTPUT_CLOSED;
a217 1
		debug("channel %d: output drain -> closed", c->self);
d219 1
a219 1
		c->ostate = CHAN_OUTPUT_CLOSED;
d276 2
a277 2
		c->ostate = CHAN_OUTPUT_CLOSED;
		c->istate = CHAN_INPUT_CLOSED;
d286 1
a286 2
		debug("channel %d: output open -> drain", c->self);
		c->ostate = CHAN_OUTPUT_WAIT_DRAIN;
a290 1
		debug("channel %d: input open -> closed", c->self);
a293 1
		debug("channel %d: input drain -> closed", c->self);
d297 1
a297 1
	c->istate = CHAN_INPUT_CLOSED;
a309 1
		debug("channel %d: input drain -> closed", c->self);
d312 1
a312 1
		c->istate = CHAN_INPUT_CLOSED;
d324 2
a325 4
	if (c->ostate == CHAN_OUTPUT_OPEN) {
		debug("channel %d: output open -> drain", c->self);
		c->ostate = CHAN_OUTPUT_WAIT_DRAIN;
	}
a332 1
		debug("channel %d: output open -> closed", c->self);
d334 1
a334 1
		c->ostate = CHAN_OUTPUT_CLOSED;
a336 1
		debug("channel %d: output drain -> closed", c->self);
d338 1
a338 1
		c->ostate = CHAN_OUTPUT_CLOSED;
a356 1
		debug("channel %d: output drain -> closed", c->self);
d358 1
a358 1
		c->ostate = CHAN_OUTPUT_CLOSED;
@


1.35
log
@remove dead code (skip drain)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.34 2002/01/09 17:26:35 markus Exp $");
a157 23
	if (c->type != SSH_CHANNEL_OPEN) {
		debug("channel %d: non-open", c->self);
		if (c->istate == CHAN_INPUT_OPEN) {
			debug("channel %d: non-open: input open -> wait_oclose",
			    c->self);
			chan_shutdown_read(c);
			chan_send_ieof1(c);
			c->istate = CHAN_INPUT_WAIT_OCLOSE;
		} else {
			error("channel %d: non-open: istate %d != open",
			    c->self, c->istate);
		}
		if (c->ostate == CHAN_OUTPUT_OPEN) {
			debug("channel %d: non-open: output open -> closed",
			    c->self);
			chan_send_oclose1(c);
			c->ostate = CHAN_OUTPUT_CLOSED;
		} else {
			error("channel %d: non-open: ostate %d != open",
			    c->self, c->ostate);
		}
		return;
	}
@


1.34
log
@replace buffer_consume(b, buffer_len(b)) with buffer_clear(b); ok provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.33 2001/12/19 07:18:56 deraadt Exp $");
a125 6
#if 0
		if (buffer_len(&c->input) == 0) {
			debug("channel %d: input: no drain shortcut", c->self);
			chan_ibuf_empty(c);
		}
#endif
@


1.33
log
@basic KNF done while i was looking for something else
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.32 2001/10/10 22:18:47 markus Exp $");
d269 1
a269 1
		buffer_consume(&c->output, buffer_len(&c->output));
d519 1
a519 1
	buffer_consume(&c->output, buffer_len(&c->output));
@


1.32
log
@try to keep channels open until an exit-status message is sent.
don't kill the login shells if the shells stdin/out/err is closed.
this should now work:
ssh -2n localhost 'exec > /dev/null 2>&1; sleep 10; exit 5'; echo ?
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.31 2001/07/17 21:04:57 markus Exp $");
d276 1
a276 1
		     c->self, c->ostate);
d325 1
a325 1
		     c->self);
d337 1
a337 1
		     c->self, c->istate);
d461 1
a461 1
		       "read": "write");
@


1.32.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d2 1
a2 1
 * Copyright (c) 1999, 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.44 2002/01/21 23:27:10 markus Exp $");
d66 8
a85 22
static char *ostates[] = { "open", "drain", "wait_ieof", "closed" };
static char *istates[] = { "open", "drain", "wait_oclose", "closed" };

static void
chan_set_istate(Channel *c, u_int next)
{
	if (c->istate > CHAN_INPUT_CLOSED || next > CHAN_INPUT_CLOSED)
		fatal("chan_set_istate: bad state %d -> %d", c->istate, next);
	debug("channel %d: input %s -> %s", c->self, istates[c->istate],
	    istates[next]);
	c->istate = next;
}
static void
chan_set_ostate(Channel *c, u_int next)
{
	if (c->ostate > CHAN_OUTPUT_CLOSED || next > CHAN_OUTPUT_CLOSED)
		fatal("chan_set_ostate: bad state %d -> %d", c->ostate, next);
	debug("channel %d: output %s -> %s", c->self, ostates[c->ostate],
	    ostates[next]);
	c->ostate = next;
}

d96 2
a97 1
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d100 1
d103 1
a103 1
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d107 1
d109 1
a109 1
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d117 2
a118 2
void
chan_read_failed(Channel *c)
d123 1
d125 7
a131 1
		chan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);
d139 2
a140 2
void
chan_ibuf_empty(Channel *c)
d150 3
a152 8
		if (compat20) {
			if (!(c->flags & CHAN_CLOSE_SENT))
				chan_send_eof2(c);
			chan_set_istate(c, CHAN_INPUT_CLOSED);
		} else {
			chan_send_ieof1(c);
			chan_set_istate(c, CHAN_INPUT_WAIT_OCLOSE);
		}
d164 23
d189 2
a190 1
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);
d193 2
a194 1
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
d208 1
a208 1
		chan_shutdown_write(c);
d210 1
a210 1
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_IEOF);
d213 1
a213 1
		chan_shutdown_write(c);
d215 1
a215 1
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
d223 2
a224 2
void
chan_obuf_empty(Channel *c)
d234 3
a236 4
		chan_shutdown_write(c);
		if (!compat20)
			chan_send_oclose1(c);
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
d268 2
a269 1
		buffer_clear(&c->output);
d276 1
a276 1
		    c->self, c->ostate);
d285 1
a285 1
chan_rcvd_close2(Channel *c)
d293 2
a294 2
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d303 2
a304 1
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);
d309 1
a310 1
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d313 1
d315 23
a337 1
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d342 1
a342 1
chan_rcvd_eof2(Channel *c)
d345 4
a348 2
	if (c->ostate == CHAN_OUTPUT_OPEN)
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);
d356 4
d361 1
d363 1
a363 1
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
d372 21
a428 28
chan_rcvd_ieof(Channel *c)
{
	if (compat20)
		chan_rcvd_eof2(c);
	else
		chan_rcvd_ieof1(c);
	if (c->ostate == CHAN_OUTPUT_WAIT_DRAIN &&
	    buffer_len(&c->output) == 0)
		chan_obuf_empty(c);
}
void
chan_rcvd_oclose(Channel *c)
{
	if (compat20)
		chan_rcvd_close2(c);
	else
		chan_rcvd_oclose1(c);
}
void
chan_write_failed(Channel *c)
{
	if (compat20)
		chan_write_failed2(c);
	else
		chan_write_failed1(c);
}

void
d461 1
a461 1
		    "read": "write");
d484 31
d519 1
a519 1
	buffer_clear(&c->output);
@


1.32.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.45 2002/03/25 21:13:51 markus Exp $");
a304 1
	c->flags |= CHAN_EOF_RCVD;
a332 1
		c->flags |= CHAN_EOF_SENT;
d368 1
a368 2
	    buffer_len(&c->output) == 0 && 
	    !CHANNEL_EFD_OUTPUT_ACTIVE(c))
d407 26
a432 17
	if ((datafellows & SSH_BUG_EXTEOF) &&
	    c->extended_usage == CHAN_EXTENDED_WRITE &&
	    c->efd != -1 &&
	    buffer_len(&c->extended) > 0) {
                debug2("channel %d: active efd: %d len %d",
                    c->self, c->efd, buffer_len(&c->extended));
		return 0;
	}
	if (!(c->flags & CHAN_CLOSE_SENT)) {
		if (send) {
			chan_send_close2(c);
		} else {
			/* channel would be dead if we sent a close */
			if (c->flags & CHAN_CLOSE_RCVD) {
				debug("channel %d: almost dead",
				    c->self);
				return 1;
d435 5
a439 5
	}
	if ((c->flags & CHAN_CLOSE_SENT) &&
	    (c->flags & CHAN_CLOSE_RCVD)) {
		debug("channel %d: is dead", c->self);
		return 1;
@


1.32.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.32.2.2 2002/05/17 00:03:23 miod Exp $");
d370 1
a370 1
	    buffer_len(&c->output) == 0 &&
d414 2
a415 2
		debug2("channel %d: active efd: %d len %d",
		    c->self, c->efd, buffer_len(&c->extended));
@


1.31
log
@keep track of both maxfd and the size of the malloc'ed fdsets.
update maxfd if maxfd gets closed.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.30 2001/06/25 08:25:38 markus Exp $");
d435 1
a435 1
chan_is_dead(Channel *c)
d464 10
a473 1
			chan_send_close2(c);
@


1.30
log
@update copyright for 2001
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.29 2001/06/23 15:12:19 itojun Exp $");
d521 1
a521 1
		if (close(c->wfd) < 0)
a524 1
		c->wfd = -1;
d540 1
a540 1
		if (close(c->rfd) < 0)
a543 1
		c->rfd = -1;
@


1.29
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d2 1
a2 1
 * Copyright (c) 1999 Markus Friedl.  All rights reserved.
d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.28 2001/05/31 10:30:16 markus Exp $");
@


1.28
log
@undo the .c file split, just merge the header and keep the cvs history
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.28 2001/05/31 09:50:53 markus Exp $");
d77 4
a80 4
static void	chan_send_ieof1(Channel *c);
static void	chan_send_oclose1(Channel *c);
static void	chan_send_close2(Channel *c);
static void	chan_send_eof2(Channel *c);
d83 2
a84 2
static void	chan_shutdown_write(Channel *c);
static void	chan_shutdown_read(Channel *c);
@


1.27
log
@channel layer cleanup: merge header files and split .c files
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.26 2001/05/28 23:14:49 markus Exp $");
a32 1
#include "nchan.h"
d36 26
d112 1
a112 1
		error("channel %d: protocol error: chan_rcvd_oclose for istate %d",
d126 1
d131 1
d134 1
a134 1
		error("channel %d: internal error: we do not read, but chan_read_failed for istate %d",
d144 1
a144 1
		error("channel %d: internal error: chan_ibuf_empty for non empty buffer",
d155 1
a155 1
		error("channel %d: internal error: chan_ibuf_empty for istate %d",
d167 2
a168 1
			debug("channel %d: non-open: input open -> wait_oclose", c->self);
d173 2
a174 1
			error("channel %d: istate %d != open", c->self, c->istate);
d177 2
a178 1
			debug("channel %d: non-open: output open -> closed", c->self);
d182 2
a183 1
			error("channel %d: ostate %d != open", c->self, c->ostate);
d197 1
a197 1
		error("channel %d: protocol error: chan_rcvd_ieof for ostate %d",
d218 1
a218 1
		error("channel %d: internal error: chan_write_failed for ostate %d",
d228 1
a228 1
		error("channel %d: internal error: chan_obuf_empty for non empty buffer",
d239 1
a239 1
		error("channel %d: internal error: chan_obuf_empty for ostate %d",
d256 1
a256 1
		error("channel %d: internal error: cannot send ieof for istate %d",
d275 1
a275 1
		error("channel %d: internal error: cannot send oclose for ostate %d",
d299 4
a302 1
		/* wait until a data from the channel is consumed if a CLOSE is received */
d324 1
a324 1
		error("channel %d: internal error: chan_ibuf_empty for non empty buffer",
d336 1
a336 1
		error("channel %d: internal error: chan_ibuf_empty for istate %d",
d366 1
a366 1
		error("channel %d: internal error: chan_write_failed for ostate %d",
d376 1
a376 1
		error("internal error: chan_obuf_empty %d for non empty buffer",
d387 1
a387 1
		error("channel %d: internal error: chan_obuf_empty for ostate %d",
d403 1
a403 1
		error("channel %d: internal error: cannot send eof for istate %d",
d414 1
a414 1
		error("channel %d: internal error: cannot send close for istate/ostate %d/%d",
d417 1
a417 1
		error("channel %d: internal error: already sent close", c->self);
d517 2
a518 1
			debug("channel %d: chan_shutdown_write: shutdown() failed for fd%d: %.100s",
d522 2
a523 1
			log("channel %d: chan_shutdown_write: close() failed for fd%d: %.100s",
d536 4
a539 2
			error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
			    c->self, c->sock, c->istate, c->ostate, strerror(errno));
d542 2
a543 1
			log("channel %d: chan_shutdown_read: close() failed for fd%d: %.100s",
@


1.26
log
@undo broken channel fix and try a different one. there
should be still some select errors...
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.25 2001/05/16 22:09:21 markus Exp $");
@


1.25
log
@more select() error fixes (don't set rfd/wfd to -1).
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.24 2001/05/04 23:47:34 markus Exp $");
d397 1
a397 1
	c->flags |= CHAN_DEAD;
d403 2
a404 1
	if (c->flags & CHAN_DEAD)
d406 1
d489 1
d506 1
@


1.24
log
@move to Channel **channels (instead of Channel *channels), fixes realloc problems.
channel_new now returns a Channel *, favour Channel * over channel id.
remove old channel_allocate interface.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.23 2001/02/28 08:54:55 markus Exp $");
a486 1
		c->wfd = -1;
a502 1
		c->rfd = -1;
@


1.23
log
@make sure remote stderr does not get truncated.
remove closed fd's from the select mask.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.22 2001/01/21 19:05:52 markus Exp $");
d394 6
d403 2
@


1.23.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d2 1
a2 1
 * Copyright (c) 1999, 2000, 2001 Markus Friedl.  All rights reserved.
d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.31 2001/07/17 21:04:57 markus Exp $");
d33 1
a36 26
/*
 * SSH Protocol 1.5 aka New Channel Protocol
 * Thanks to Martina, Axel and everyone who left Erlangen, leaving me bored.
 * Written by Markus Friedl in October 1999
 *
 * Protocol versions 1.3 and 1.5 differ in the handshake protocol used for the
 * tear down of channels:
 *
 * 1.3:	strict request-ack-protocol:
 * 	CLOSE	->
 * 		<-  CLOSE_CONFIRM
 *
 * 1.5:	uses variations of:
 * 	IEOF	->
 * 		<-  OCLOSE
 * 		<-  IEOF
 * 	OCLOSE	->
 * 	i.e. both sides have to close the channel
 *
 * 2.0: the EOF messages are optional
 *
 * See the debugging output from 'ssh -v' and 'sshd -d' of
 * ssh-1.2.27 as an example.
 *
 */

d52 4
a55 4
static void	chan_send_ieof1(Channel *);
static void	chan_send_oclose1(Channel *);
static void	chan_send_close2(Channel *);
static void	chan_send_eof2(Channel *);
d58 2
a59 2
static void	chan_shutdown_write(Channel *);
static void	chan_shutdown_read(Channel *);
d87 1
a87 1
		error("channel %d: protocol error: rcvd_oclose for istate %d",
a100 1
#if 0
a104 1
#endif
d107 1
a107 1
		error("channel %d: chan_read_failed for istate %d",
d117 1
a117 1
		error("channel %d: chan_ibuf_empty for non empty buffer",
d128 1
a128 1
		error("channel %d: chan_ibuf_empty for istate %d",
d140 1
a140 2
			debug("channel %d: non-open: input open -> wait_oclose",
			    c->self);
d145 1
a145 2
			error("channel %d: non-open: istate %d != open",
			    c->self, c->istate);
d148 1
a148 2
			debug("channel %d: non-open: output open -> closed",
			    c->self);
d152 1
a152 2
			error("channel %d: non-open: ostate %d != open",
			    c->self, c->ostate);
d166 1
a166 1
		error("channel %d: protocol error: rcvd_ieof for ostate %d",
d187 1
a187 1
		error("channel %d: chan_write_failed for ostate %d",
d197 1
a197 1
		error("channel %d: chan_obuf_empty for non empty buffer",
d208 1
a208 1
		error("channel %d: internal error: obuf_empty for ostate %d",
d225 1
a225 1
		error("channel %d: cannot send ieof for istate %d",
d244 1
a244 1
		error("channel %d: cannot send oclose for ostate %d",
d268 1
a268 4
		/*
		 * wait until a data from the channel is consumed if a CLOSE
		 * is received
		 */
d290 1
a290 1
		error("channel %d: chan_ibuf_empty for non empty buffer",
d302 1
a302 1
		error("channel %d: chan_ibuf_empty for istate %d",
d332 1
a332 1
		error("channel %d: chan_write_failed for ostate %d",
d342 1
a342 1
		error("channel %d: chan_obuf_empty for non empty buffer",
d353 1
a353 1
		error("channel %d: chan_obuf_empty for ostate %d",
d369 1
a369 1
		error("channel %d: cannot send eof for istate %d",
d380 1
a380 1
		error("channel %d: cannot send close for istate/ostate %d/%d",
d383 1
a383 1
		error("channel %d: already sent close", c->self);
a393 6
void
chan_mark_dead(Channel *c)
{
	c->type = SSH_CHANNEL_ZOMBIE;
}

a396 4
	if (c->type == SSH_CHANNEL_ZOMBIE) {
		debug("channel %d: zombie", c->self);
		return 1;
	}
d473 1
a473 2
			debug("channel %d: chan_shutdown_write: "
			    "shutdown() failed for fd%d: %.100s",
d476 2
a477 3
		if (channel_close_fd(&c->wfd) < 0)
			log("channel %d: chan_shutdown_write: "
			    "close() failed for fd%d: %.100s",
d479 1
d490 2
a491 4
			error("channel %d: chan_shutdown_read: "
			    "shutdown() failed for fd%d [i%d o%d]: %.100s",
			    c->self, c->sock, c->istate, c->ostate,
			    strerror(errno));
d493 2
a494 3
		if (channel_close_fd(&c->rfd) < 0)
			log("channel %d: chan_shutdown_read: "
			    "close() failed for fd%d: %.100s",
d496 1
@


1.23.2.2
log
@Merge OpenSSH 3.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.23.2.1 2001/09/27 19:03:54 jason Exp $");
d435 1
a435 1
chan_is_dead(Channel *c, int send)
d464 1
a464 10
			if (send) {
				chan_send_close2(c);
			} else {
				/* channel would be dead if we sent a close */
				if (c->flags & CHAN_CLOSE_RCVD) {
					debug("channel %d: almost dead",
					    c->self);
					return 1;
				}
			}
@


1.23.2.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d2 1
a2 1
 * Copyright (c) 1999, 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.44 2002/01/21 23:27:10 markus Exp $");
d66 8
a85 22
static char *ostates[] = { "open", "drain", "wait_ieof", "closed" };
static char *istates[] = { "open", "drain", "wait_oclose", "closed" };

static void
chan_set_istate(Channel *c, u_int next)
{
	if (c->istate > CHAN_INPUT_CLOSED || next > CHAN_INPUT_CLOSED)
		fatal("chan_set_istate: bad state %d -> %d", c->istate, next);
	debug("channel %d: input %s -> %s", c->self, istates[c->istate],
	    istates[next]);
	c->istate = next;
}
static void
chan_set_ostate(Channel *c, u_int next)
{
	if (c->ostate > CHAN_OUTPUT_CLOSED || next > CHAN_OUTPUT_CLOSED)
		fatal("chan_set_ostate: bad state %d -> %d", c->ostate, next);
	debug("channel %d: output %s -> %s", c->self, ostates[c->ostate],
	    ostates[next]);
	c->ostate = next;
}

d96 2
a97 1
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d100 1
d103 1
a103 1
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d107 1
d109 1
a109 1
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d117 2
a118 2
void
chan_read_failed(Channel *c)
d123 1
d125 7
a131 1
		chan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);
d139 2
a140 2
void
chan_ibuf_empty(Channel *c)
d150 3
a152 8
		if (compat20) {
			if (!(c->flags & CHAN_CLOSE_SENT))
				chan_send_eof2(c);
			chan_set_istate(c, CHAN_INPUT_CLOSED);
		} else {
			chan_send_ieof1(c);
			chan_set_istate(c, CHAN_INPUT_WAIT_OCLOSE);
		}
d164 23
d189 2
a190 1
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);
d193 2
a194 1
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
d208 1
a208 1
		chan_shutdown_write(c);
d210 1
a210 1
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_IEOF);
d213 1
a213 1
		chan_shutdown_write(c);
d215 1
a215 1
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
d223 2
a224 2
void
chan_obuf_empty(Channel *c)
d234 3
a236 4
		chan_shutdown_write(c);
		if (!compat20)
			chan_send_oclose1(c);
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
d268 2
a269 1
		buffer_clear(&c->output);
d276 1
a276 1
		    c->self, c->ostate);
d285 1
a285 1
chan_rcvd_close2(Channel *c)
d293 2
a294 2
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d303 2
a304 1
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);
d309 1
a310 1
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d313 1
d315 23
a337 1
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d342 1
a342 1
chan_rcvd_eof2(Channel *c)
d345 4
a348 2
	if (c->ostate == CHAN_OUTPUT_OPEN)
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);
d356 4
d361 1
d363 1
a363 1
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
d372 21
a428 28
chan_rcvd_ieof(Channel *c)
{
	if (compat20)
		chan_rcvd_eof2(c);
	else
		chan_rcvd_ieof1(c);
	if (c->ostate == CHAN_OUTPUT_WAIT_DRAIN &&
	    buffer_len(&c->output) == 0)
		chan_obuf_empty(c);
}
void
chan_rcvd_oclose(Channel *c)
{
	if (compat20)
		chan_rcvd_close2(c);
	else
		chan_rcvd_oclose1(c);
}
void
chan_write_failed(Channel *c)
{
	if (compat20)
		chan_write_failed2(c);
	else
		chan_write_failed1(c);
}

void
d461 1
a461 1
		    "read": "write");
d484 31
d519 1
a519 1
	buffer_clear(&c->output);
@


1.23.2.4
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.45 2002/03/25 21:13:51 markus Exp $");
a304 1
	c->flags |= CHAN_EOF_RCVD;
a332 1
		c->flags |= CHAN_EOF_SENT;
d368 1
a368 2
	    buffer_len(&c->output) == 0 && 
	    !CHANNEL_EFD_OUTPUT_ACTIVE(c))
d407 26
a432 17
	if ((datafellows & SSH_BUG_EXTEOF) &&
	    c->extended_usage == CHAN_EXTENDED_WRITE &&
	    c->efd != -1 &&
	    buffer_len(&c->extended) > 0) {
                debug2("channel %d: active efd: %d len %d",
                    c->self, c->efd, buffer_len(&c->extended));
		return 0;
	}
	if (!(c->flags & CHAN_CLOSE_SENT)) {
		if (send) {
			chan_send_close2(c);
		} else {
			/* channel would be dead if we sent a close */
			if (c->flags & CHAN_CLOSE_RCVD) {
				debug("channel %d: almost dead",
				    c->self);
				return 1;
d435 5
a439 5
	}
	if ((c->flags & CHAN_CLOSE_SENT) &&
	    (c->flags & CHAN_CLOSE_RCVD)) {
		debug("channel %d: is dead", c->self);
		return 1;
@


1.22
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.21 2001/01/19 15:55:11 markus Exp $");
a56 3
/* channel cleanup */
chan_event_fn *chan_delete_if_full_closed	= NULL;

a248 10
static void
chan_delete_if_full_closed1(Channel *c)
{
	debug3("channel %d: chan_delete_if_full_closed1: istate %d ostate %d",
	    c->self, c->istate, c->ostate);
	if (c->istate == CHAN_INPUT_CLOSED && c->ostate == CHAN_OUTPUT_CLOSED) {
		debug("channel %d: full closed", c->self);
		channel_free(c->self);
	}
}
d391 5
a395 2
static void
chan_delete_if_full_closed2(Channel *c)
d397 22
a418 3
	debug3("channel %d: chan_delete_if_full_closed2: istate %d ostate %d",
	    c->self, c->istate, c->ostate);
	if (c->istate == CHAN_INPUT_CLOSED && c->ostate == CHAN_OUTPUT_CLOSED) {
d424 2
a425 2
			debug("channel %d: full closed2", c->self);
			channel_free(c->self);
d428 1
a430 1
/* shared */
a450 2

		chan_delete_if_full_closed	= chan_delete_if_full_closed2;
a458 2

		chan_delete_if_full_closed	= chan_delete_if_full_closed1;
@


1.21
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d26 1
a26 3
RCSID("$OpenBSD: nchan.c,v 1.20 2000/11/06 23:04:56 markus Exp $");

#include "ssh.h"
d28 2
a33 3

#include "ssh1.h"
#include "ssh2.h"
d35 1
@


1.20
log
@agent forwarding and -R for ssh2, based on work from jhuuskon@@messi.uku.fi
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.19 2000/09/07 20:27:52 deraadt Exp $");
d35 1
@


1.19
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.18 2000/06/20 01:39:42 markus Exp $");
d256 2
d408 2
@


1.19.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d26 3
a28 1
RCSID("$OpenBSD: nchan.c,v 1.22 2001/01/21 19:05:52 markus Exp $");
a29 2
#include "ssh1.h"
#include "ssh2.h"
d34 2
a36 1
#include "log.h"
a255 2
	debug3("channel %d: chan_delete_if_full_closed1: istate %d ostate %d",
	    c->self, c->istate, c->ostate);
a405 2
	debug3("channel %d: chan_delete_if_full_closed2: istate %d ostate %d",
	    c->self, c->istate, c->ostate);
@


1.19.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.19.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.23 2001/02/28 08:54:55 markus Exp $");
d57 3
d252 10
d404 2
a405 5

/* shared */

int
chan_is_dead(Channel *c)
d407 3
a409 22
	if (c->istate != CHAN_INPUT_CLOSED || c->ostate != CHAN_OUTPUT_CLOSED)
		return 0;
	if (!compat20) {
		debug("channel %d: is dead", c->self);
		return 1;
	}
	/*
	 * we have to delay the close message if the efd (for stderr) is
	 * still active
	 */
	if (((c->extended_usage != CHAN_EXTENDED_IGNORE) &&
	    buffer_len(&c->extended) > 0)
#if 0
	    || ((c->extended_usage == CHAN_EXTENDED_READ) &&
	    c->efd != -1)
#endif
	    ) {
		debug2("channel %d: active efd: %d len %d type %s",
		    c->self, c->efd, buffer_len(&c->extended),
		    c->extended_usage==CHAN_EXTENDED_READ ?
		       "read": "write");
	} else {
d415 2
a416 2
			debug("channel %d: is dead", c->self);
			return 1;
a418 1
	return 0;
d421 1
d442 2
d452 2
@


1.19.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.19.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d2 1
a2 1
 * Copyright (c) 1999, 2000, 2001 Markus Friedl.  All rights reserved.
d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.31 2001/07/17 21:04:57 markus Exp $");
d33 1
a36 26
/*
 * SSH Protocol 1.5 aka New Channel Protocol
 * Thanks to Martina, Axel and everyone who left Erlangen, leaving me bored.
 * Written by Markus Friedl in October 1999
 *
 * Protocol versions 1.3 and 1.5 differ in the handshake protocol used for the
 * tear down of channels:
 *
 * 1.3:	strict request-ack-protocol:
 * 	CLOSE	->
 * 		<-  CLOSE_CONFIRM
 *
 * 1.5:	uses variations of:
 * 	IEOF	->
 * 		<-  OCLOSE
 * 		<-  IEOF
 * 	OCLOSE	->
 * 	i.e. both sides have to close the channel
 *
 * 2.0: the EOF messages are optional
 *
 * See the debugging output from 'ssh -v' and 'sshd -d' of
 * ssh-1.2.27 as an example.
 *
 */

d52 4
a55 4
static void	chan_send_ieof1(Channel *);
static void	chan_send_oclose1(Channel *);
static void	chan_send_close2(Channel *);
static void	chan_send_eof2(Channel *);
d58 2
a59 2
static void	chan_shutdown_write(Channel *);
static void	chan_shutdown_read(Channel *);
d87 1
a87 1
		error("channel %d: protocol error: rcvd_oclose for istate %d",
a100 1
#if 0
a104 1
#endif
d107 1
a107 1
		error("channel %d: chan_read_failed for istate %d",
d117 1
a117 1
		error("channel %d: chan_ibuf_empty for non empty buffer",
d128 1
a128 1
		error("channel %d: chan_ibuf_empty for istate %d",
d140 1
a140 2
			debug("channel %d: non-open: input open -> wait_oclose",
			    c->self);
d145 1
a145 2
			error("channel %d: non-open: istate %d != open",
			    c->self, c->istate);
d148 1
a148 2
			debug("channel %d: non-open: output open -> closed",
			    c->self);
d152 1
a152 2
			error("channel %d: non-open: ostate %d != open",
			    c->self, c->ostate);
d166 1
a166 1
		error("channel %d: protocol error: rcvd_ieof for ostate %d",
d187 1
a187 1
		error("channel %d: chan_write_failed for ostate %d",
d197 1
a197 1
		error("channel %d: chan_obuf_empty for non empty buffer",
d208 1
a208 1
		error("channel %d: internal error: obuf_empty for ostate %d",
d225 1
a225 1
		error("channel %d: cannot send ieof for istate %d",
d244 1
a244 1
		error("channel %d: cannot send oclose for ostate %d",
d268 1
a268 4
		/*
		 * wait until a data from the channel is consumed if a CLOSE
		 * is received
		 */
d290 1
a290 1
		error("channel %d: chan_ibuf_empty for non empty buffer",
d302 1
a302 1
		error("channel %d: chan_ibuf_empty for istate %d",
d332 1
a332 1
		error("channel %d: chan_write_failed for ostate %d",
d342 1
a342 1
		error("channel %d: chan_obuf_empty for non empty buffer",
d353 1
a353 1
		error("channel %d: chan_obuf_empty for ostate %d",
d369 1
a369 1
		error("channel %d: cannot send eof for istate %d",
d380 1
a380 1
		error("channel %d: cannot send close for istate/ostate %d/%d",
d383 1
a383 1
		error("channel %d: already sent close", c->self);
a393 6
void
chan_mark_dead(Channel *c)
{
	c->type = SSH_CHANNEL_ZOMBIE;
}

a396 4
	if (c->type == SSH_CHANNEL_ZOMBIE) {
		debug("channel %d: zombie", c->self);
		return 1;
	}
d473 1
a473 2
			debug("channel %d: chan_shutdown_write: "
			    "shutdown() failed for fd%d: %.100s",
d476 2
a477 3
		if (channel_close_fd(&c->wfd) < 0)
			log("channel %d: chan_shutdown_write: "
			    "close() failed for fd%d: %.100s",
d479 1
d490 2
a491 4
			error("channel %d: chan_shutdown_read: "
			    "shutdown() failed for fd%d [i%d o%d]: %.100s",
			    c->self, c->sock, c->istate, c->ostate,
			    strerror(errno));
d493 2
a494 3
		if (channel_close_fd(&c->rfd) < 0)
			log("channel %d: chan_shutdown_read: "
			    "close() failed for fd%d: %.100s",
d496 1
@


1.19.2.6
log
@Merge OpenSSH 3.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.19.2.5 2001/09/27 00:15:42 miod Exp $");
d435 1
a435 1
chan_is_dead(Channel *c, int send)
d464 1
a464 10
			if (send) {
				chan_send_close2(c);
			} else {
				/* channel would be dead if we sent a close */
				if (c->flags & CHAN_CLOSE_RCVD) {
					debug("channel %d: almost dead",
					    c->self);
					return 1;
				}
			}
@


1.19.2.7
log
@Merge OpenSSH 3.1.
@
text
@d2 1
a2 1
 * Copyright (c) 1999, 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.44 2002/01/21 23:27:10 markus Exp $");
d66 8
a85 22
static char *ostates[] = { "open", "drain", "wait_ieof", "closed" };
static char *istates[] = { "open", "drain", "wait_oclose", "closed" };

static void
chan_set_istate(Channel *c, u_int next)
{
	if (c->istate > CHAN_INPUT_CLOSED || next > CHAN_INPUT_CLOSED)
		fatal("chan_set_istate: bad state %d -> %d", c->istate, next);
	debug("channel %d: input %s -> %s", c->self, istates[c->istate],
	    istates[next]);
	c->istate = next;
}
static void
chan_set_ostate(Channel *c, u_int next)
{
	if (c->ostate > CHAN_OUTPUT_CLOSED || next > CHAN_OUTPUT_CLOSED)
		fatal("chan_set_ostate: bad state %d -> %d", c->ostate, next);
	debug("channel %d: output %s -> %s", c->self, ostates[c->ostate],
	    ostates[next]);
	c->ostate = next;
}

d96 2
a97 1
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d100 1
d103 1
a103 1
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d107 1
d109 1
a109 1
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d117 2
a118 2
void
chan_read_failed(Channel *c)
d123 1
d125 7
a131 1
		chan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);
d139 2
a140 2
void
chan_ibuf_empty(Channel *c)
d150 3
a152 8
		if (compat20) {
			if (!(c->flags & CHAN_CLOSE_SENT))
				chan_send_eof2(c);
			chan_set_istate(c, CHAN_INPUT_CLOSED);
		} else {
			chan_send_ieof1(c);
			chan_set_istate(c, CHAN_INPUT_WAIT_OCLOSE);
		}
d164 23
d189 2
a190 1
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);
d193 2
a194 1
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
d208 1
a208 1
		chan_shutdown_write(c);
d210 1
a210 1
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_IEOF);
d213 1
a213 1
		chan_shutdown_write(c);
d215 1
a215 1
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
d223 2
a224 2
void
chan_obuf_empty(Channel *c)
d234 3
a236 4
		chan_shutdown_write(c);
		if (!compat20)
			chan_send_oclose1(c);
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
d268 2
a269 1
		buffer_clear(&c->output);
d276 1
a276 1
		    c->self, c->ostate);
d285 1
a285 1
chan_rcvd_close2(Channel *c)
d293 2
a294 2
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d303 2
a304 1
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);
d309 1
a310 1
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d313 1
d315 23
a337 1
		chan_set_istate(c, CHAN_INPUT_CLOSED);
d342 1
a342 1
chan_rcvd_eof2(Channel *c)
d345 4
a348 2
	if (c->ostate == CHAN_OUTPUT_OPEN)
		chan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);
d356 4
d361 1
d363 1
a363 1
		chan_set_ostate(c, CHAN_OUTPUT_CLOSED);
d372 21
a428 28
chan_rcvd_ieof(Channel *c)
{
	if (compat20)
		chan_rcvd_eof2(c);
	else
		chan_rcvd_ieof1(c);
	if (c->ostate == CHAN_OUTPUT_WAIT_DRAIN &&
	    buffer_len(&c->output) == 0)
		chan_obuf_empty(c);
}
void
chan_rcvd_oclose(Channel *c)
{
	if (compat20)
		chan_rcvd_close2(c);
	else
		chan_rcvd_oclose1(c);
}
void
chan_write_failed(Channel *c)
{
	if (compat20)
		chan_write_failed2(c);
	else
		chan_write_failed1(c);
}

void
d461 1
a461 1
		    "read": "write");
d484 31
d519 1
a519 1
	buffer_clear(&c->output);
@


1.18
log
@OpenBSD tag
@
text
@a11 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Markus Friedl.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.17 2000/05/08 17:44:54 markus Exp $");
@


1.17
log
@no drain if ibuf_empty, fixes x11fwd problems; tests by fries@@
@
text
@d31 1
a31 1
RCSID("$Id: nchan.c,v 1.17 2000/05/08 17:20:40 markus Exp $");
@


1.17.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d31 1
a31 1
RCSID("$OpenBSD: nchan.c,v 1.18 2000/06/20 01:39:42 markus Exp $");
@


1.17.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d12 5
d31 1
a31 1
RCSID("$OpenBSD: nchan.c,v 1.19 2000/09/07 20:27:52 deraadt Exp $");
@


1.17.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d26 3
a28 1
RCSID("$OpenBSD: nchan.c,v 1.22 2001/01/21 19:05:52 markus Exp $");
a29 2
#include "ssh1.h"
#include "ssh2.h"
d34 2
a36 1
#include "log.h"
a255 2
	debug3("channel %d: chan_delete_if_full_closed1: istate %d ostate %d",
	    c->self, c->istate, c->ostate);
a405 2
	debug3("channel %d: chan_delete_if_full_closed2: istate %d ostate %d",
	    c->self, c->istate, c->ostate);
@


1.17.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: nchan.c,v 1.23 2001/02/28 08:54:55 markus Exp $");
d57 3
d252 10
d404 2
a405 5

/* shared */

int
chan_is_dead(Channel *c)
d407 3
a409 22
	if (c->istate != CHAN_INPUT_CLOSED || c->ostate != CHAN_OUTPUT_CLOSED)
		return 0;
	if (!compat20) {
		debug("channel %d: is dead", c->self);
		return 1;
	}
	/*
	 * we have to delay the close message if the efd (for stderr) is
	 * still active
	 */
	if (((c->extended_usage != CHAN_EXTENDED_IGNORE) &&
	    buffer_len(&c->extended) > 0)
#if 0
	    || ((c->extended_usage == CHAN_EXTENDED_READ) &&
	    c->efd != -1)
#endif
	    ) {
		debug2("channel %d: active efd: %d len %d type %s",
		    c->self, c->efd, buffer_len(&c->extended),
		    c->extended_usage==CHAN_EXTENDED_READ ?
		       "read": "write");
	} else {
d415 2
a416 2
			debug("channel %d: is dead", c->self);
			return 1;
a418 1
	return 0;
d421 1
d442 2
d452 2
@


1.16
log
@fix close for non-open ssh1 channels
@
text
@d31 1
a31 1
RCSID("$Id: nchan.c,v 1.15 2000/05/02 12:44:38 markus Exp $");
d110 4
@


1.15
log
@use c-style comments
@
text
@d31 1
a31 1
RCSID("$Id: nchan.c,v 1.14 2000/04/14 10:30:32 markus Exp $");
d142 19
@


1.14
log
@whitespace cleanup
@
text
@d31 1
a31 1
RCSID("$Id: nchan.c,v 1.13 2000/04/03 07:07:15 markus Exp $");
d317 1
a317 1
		chan_shutdown_write(c); // ??
@


1.13
log
@channel layer support for ssh2
@
text
@d31 1
a31 1
RCSID("$Id: nchan.c,v 1.12 2000/03/28 20:34:14 markus Exp $");
d392 1
a392 1
		if ((c->flags & CHAN_CLOSE_SENT) && 
d396 1
a396 1
		} 
@


1.12
log
@sync w/ channels.c
@
text
@d31 1
a31 1
RCSID("$Id: nchan.c,v 1.11 2000/03/28 20:31:27 markus Exp $");
d40 2
a41 4
static void chan_send_ieof(Channel *c);
static void chan_send_oclose(Channel *c);
static void chan_shutdown_write(Channel *c);
static void chan_shutdown_read(Channel *c);
d43 1
d47 26
d74 2
a75 3
/* events concerning the INPUT from socket for channel (istate) */
void
chan_rcvd_oclose(Channel *c)
d77 1
d80 1
a80 1
		debug("channel %d: INPUT_WAIT_OCLOSE -> INPUT_CLOSED [rcvd OCLOSE]", c->self);
d84 1
a84 1
		debug("channel %d: INPUT_OPEN -> INPUT_CLOSED [rvcd OCLOSE, send IEOF]", c->self);
d86 1
a86 1
		chan_send_ieof(c);
d91 2
a92 3
		log("channel %d: INPUT_WAIT_DRAIN -> INPUT_CLOSED [rvcd OCLOSE, send IEOF]", c->self);
		debug("channel %d: INPUT_WAIT_DRAIN -> INPUT_CLOSED [rvcd OCLOSE, send IEOF]", c->self);
		chan_send_ieof(c);
d96 2
a97 1
		error("protocol error: chan_rcvd_oclose %d for istate %d", c->self, c->istate);
d101 2
a102 2
void
chan_read_failed(Channel *c)
d104 1
d107 1
a107 1
		debug("channel %d: INPUT_OPEN -> INPUT_WAIT_DRAIN [read failed]", c->self);
d112 2
a113 2
		error("internal error: we do not read, but chan_read_failed %d for istate %d",
		      c->self, c->istate);
d117 2
a118 2
void
chan_ibuf_empty(Channel *c)
d120 1
d122 2
a123 1
		error("internal error: chan_ibuf_empty %d for non empty buffer", c->self);
d128 2
a129 2
		debug("channel %d: INPUT_WAIT_DRAIN -> INPUT_WAIT_OCLOSE [inbuf empty, send IEOF]", c->self);
		chan_send_ieof(c);
d133 2
a134 1
		error("internal error: chan_ibuf_empty %d for istate %d", c->self, c->istate);
d138 2
a139 4

/* events concerning the OUTPUT from channel for socket (ostate) */
void
chan_rcvd_ieof(Channel *c)
d141 1
d144 1
a144 1
		debug("channel %d: OUTPUT_OPEN -> OUTPUT_WAIT_DRAIN [rvcd IEOF]", c->self);
d148 1
a148 1
		debug("channel %d: OUTPUT_WAIT_IEOF -> OUTPUT_CLOSED [rvcd IEOF]", c->self);
d152 2
a153 1
		error("protocol error: chan_rcvd_ieof %d for ostate %d", c->self, c->ostate);
d157 2
a158 2
void
chan_write_failed(Channel *c)
d160 1
d163 2
a164 2
		debug("channel %d: OUTPUT_OPEN -> OUTPUT_WAIT_IEOF [write failed]", c->self);
		chan_send_oclose(c);
d168 2
a169 2
		debug("channel %d: OUTPUT_WAIT_DRAIN -> OUTPUT_CLOSED [write failed]", c->self);
		chan_send_oclose(c);
d173 2
a174 1
		error("internal error: chan_write_failed %d for ostate %d", c->self, c->ostate);
d178 2
a179 2
void
chan_obuf_empty(Channel *c)
d181 1
d183 2
a184 1
		debug("internal error: chan_obuf_empty %d for non empty buffer", c->self);
d189 2
a190 2
		debug("channel %d: OUTPUT_WAIT_DRAIN -> OUTPUT_CLOSED [obuf empty, send OCLOSE]", c->self);
		chan_send_oclose(c);
d194 2
a195 1
		error("internal error: chan_obuf_empty %d for ostate %d", c->self, c->ostate);
a198 4

/*
 * ACTIONS: should never update the channel states: c->istate or c->ostate
 */
d200 1
a200 1
chan_send_ieof(Channel *c)
d202 1
d211 2
a212 1
		error("internal error: channel %d: cannot send IEOF for istate %d", c->self, c->istate);
d217 1
a217 1
chan_send_oclose(Channel *c)
d219 1
d230 2
a231 1
		error("internal error: channel %d: cannot send OCLOSE for ostate %d", c->self, c->istate);
d235 8
d244 108
a351 1
/* helper */
d353 1
a353 1
chan_shutdown_write(Channel *c)
d355 12
a366 5
	/* shutdown failure is allowed if write failed already */
	debug("channel %d: shutdown_write", c->self);
	if (shutdown(c->sock, SHUT_WR) < 0)
		debug("chan_shutdown_write failed for #%d/fd%d: %.100s",
		      c->self, c->sock, strerror(errno));
d369 1
a369 1
chan_shutdown_read(Channel *c)
d371 13
a383 4
	debug("channel %d: shutdown_read", c->self);
	if (shutdown(c->sock, SHUT_RD) < 0)
		error("chan_shutdown_read failed for #%d/fd%d [i%d o%d]: %.100s",
		      c->self, c->sock, c->istate, c->ostate, strerror(errno));
d385 2
a386 2
void
chan_delete_if_full_closed(Channel *c)
d389 8
a396 2
		debug("channel %d: full closed", c->self);
		channel_free(c->self);
d399 2
d406 66
@


1.11
log
@replace big switch() with function tables (prepare for ssh2)
@
text
@d31 1
a31 1
RCSID("$Id: nchan.c,v 1.10 2000/01/10 10:15:28 markus Exp $");
a74 1
	chan_delete_if_full_closed(c);
a121 1
		chan_delete_if_full_closed(c);
a140 1
		chan_delete_if_full_closed(c);
a158 1
		chan_delete_if_full_closed(c);
@


1.10
log
@handle OCLOSE for CHAN_INPUT_WAIT_DRAIN, i.e. do not drain buffer if
peer is not going to read the data.
@
text
@d31 1
a31 1
RCSID("$Id: nchan.c,v 1.9 1999/12/02 20:10:05 markus Exp $");
a43 1
static void chan_delete_if_full_closed(Channel *c);
d224 1
a224 1
static void
@


1.9
log
@use error() for internal errors
@
text
@d31 1
a31 1
RCSID("$Id: nchan.c,v 1.8 1999/11/24 20:21:48 markus Exp $");
d44 1
a44 1
static void chan_delele_if_full_closed(Channel *c);
a57 1
		chan_delele_if_full_closed(c);
d64 7
a70 1
		chan_delele_if_full_closed(c);
d74 1
a74 1
		break;
d76 1
d124 1
a124 1
		chan_delele_if_full_closed(c);
d144 1
a144 1
		chan_delele_if_full_closed(c);
d163 1
a163 1
		chan_delele_if_full_closed(c);
d222 2
a223 2
		error("chan_shutdown_read failed for #%d/fd%d: %.100s",
		      c->self, c->sock, strerror(errno));
d226 1
a226 1
chan_delele_if_full_closed(Channel *c)
d229 1
a229 1
		debug("channel %d: closing", c->self);
@


1.8
log
@it's not an error() if shutdown_write failes in nchan.
@
text
@d31 1
a31 1
RCSID("$Id: nchan.c,v 1.7 1999/11/24 16:15:25 markus Exp $");
d68 1
a68 1
		debug("protocol error: chan_rcvd_oclose %d for istate %d", c->self, c->istate);
d82 1
a82 1
		debug("internal error: we do not read, but chan_read_failed %d for istate %d",
d91 1
a91 1
		debug("internal error: chan_ibuf_empty %d for non empty buffer", c->self);
d101 1
a101 1
		debug("internal error: chan_ibuf_empty %d for istate %d", c->self, c->istate);
d121 1
a121 1
		debug("protocol error: chan_rcvd_ieof %d for ostate %d", c->self, c->ostate);
d141 1
a141 1
		debug("internal error: chan_write_failed %d for ostate %d", c->self, c->ostate);
d160 1
a160 1
		debug("internal error: chan_obuf_empty %d for ostate %d", c->self, c->ostate);
d179 1
a179 1
		debug("internal error: channel %d: cannot send IEOF for istate %d", c->self, c->istate);
d196 1
a196 1
		debug("internal error: channel %d: cannot send OCLOSE for ostate %d", c->self, c->istate);
@


1.7
log
@missing copyright
@
text
@d31 1
a31 1
RCSID("$Id: nchan.c,v 1.6 1999/11/23 22:25:54 markus Exp $");
d205 1
d208 1
a208 1
		error("chan_shutdown_write failed for #%d/fd%d: %.100s",
@


1.6
log
@KNF part 1
@
text
@d1 29
d31 1
a31 1
RCSID("$Id: nchan.c,v 1.5 1999/10/25 21:04:28 markus Exp $");
@


1.5
log
@remove buggy 'x11-fix'
@
text
@d2 1
a2 1
RCSID("$Id: nchan.c,v 1.4 1999/10/25 21:03:17 markus Exp $");
d18 1
a18 2
 * EVENTS: update channel input/output states
 *	   execute ACTIONS
d20 1
d23 3
a25 2
chan_rcvd_oclose(Channel *c){
	switch(c->istate){
d28 1
a28 1
		c->istate=CHAN_INPUT_CLOSED;
d35 1
a35 1
		c->istate=CHAN_INPUT_CLOSED;
d39 1
a39 1
		debug("protocol error: chan_rcvd_oclose %d for istate %d",c->self,c->istate);
d44 3
a46 2
chan_read_failed(Channel *c){
	switch(c->istate){
d50 1
a50 1
		c->istate=CHAN_INPUT_WAIT_DRAIN;
d54 1
a54 1
			c->self,c->istate);
d59 4
a62 3
chan_ibuf_empty(Channel *c){
	if(buffer_len(&c->input)){
		debug("internal error: chan_ibuf_empty %d for non empty buffer",c->self);
d65 1
a65 1
	switch(c->istate){
d69 1
a69 1
		c->istate=CHAN_INPUT_WAIT_OCLOSE;
d72 1
a72 1
		debug("internal error: chan_ibuf_empty %d for istate %d",c->self,c->istate);
d76 1
d79 3
a81 2
chan_rcvd_ieof(Channel *c){
	switch(c->ostate){
d84 1
a84 1
		c->ostate=CHAN_OUTPUT_WAIT_DRAIN;
d88 1
a88 1
		c->ostate=CHAN_OUTPUT_CLOSED;
d92 1
a92 1
		debug("protocol error: chan_rcvd_ieof %d for ostate %d", c->self,c->ostate);
d97 3
a99 2
chan_write_failed(Channel *c){
	switch(c->ostate){
d103 1
a103 1
		c->ostate=CHAN_OUTPUT_WAIT_IEOF;
d108 1
a108 1
		c->ostate=CHAN_OUTPUT_CLOSED;
d112 1
a112 1
		debug("internal error: chan_write_failed %d for ostate %d",c->self,c->ostate);
d117 4
a120 3
chan_obuf_empty(Channel *c){
	if(buffer_len(&c->output)){
		debug("internal error: chan_obuf_empty %d for non empty buffer",c->self);
d123 1
a123 1
	switch(c->ostate){
d127 1
a127 1
		c->ostate=CHAN_OUTPUT_CLOSED;
d131 1
a131 1
		debug("internal error: chan_obuf_empty %d for ostate %d",c->self,c->ostate);
d135 1
d137 1
a137 1
 * ACTIONS: should never update c->istate or c->ostate
d140 3
a142 2
chan_send_ieof(Channel *c){
	switch(c->istate){
d150 1
a150 1
		debug("internal error: channel %d: cannot send IEOF for istate %d",c->self,c->istate);
d155 3
a157 2
chan_send_oclose(Channel *c){
	switch(c->ostate){
d167 1
a167 1
		debug("internal error: channel %d: cannot send OCLOSE for ostate %d",c->self,c->istate);
d171 1
d174 2
a175 1
chan_shutdown_write(Channel *c){
d177 1
a177 1
	if(shutdown(c->sock, SHUT_WR)<0)
d179 1
a179 1
			c->self, c->sock, strerror(errno));
d182 2
a183 1
chan_shutdown_read(Channel *c){
d185 1
a185 1
	if(shutdown(c->sock, SHUT_RD)<0)
d187 1
a187 1
			c->self, c->sock, strerror(errno));
d190 3
a192 2
chan_delele_if_full_closed(Channel *c){
	if(c->istate==CHAN_INPUT_CLOSED && c->ostate==CHAN_OUTPUT_CLOSED){
d198 4
a201 3
chan_init_iostates(Channel *c){
	c->ostate=CHAN_OUTPUT_OPEN;
	c->istate=CHAN_INPUT_OPEN;
@


1.4
log
@typo in debug messages (input vs. ouput)
@
text
@d2 1
a2 1
RCSID("$Id: nchan.c,v 1.3 1999/10/17 16:56:09 markus Exp $");
a75 13

	/* X11: if we receive IEOF for X11, then we have to FORCE sending of IEOF,
	 * this is from ssh-1.2.27 debugging output.
	 */
	if(c->x11){
		debug("channel %d: OUTPUT_OPEN -> OUTPUT_CLOSED/INPUT_WAIT_OCLOSED [X11 FIX]", c->self);
		chan_send_ieof(c);
		c->istate=CHAN_INPUT_WAIT_OCLOSE;
		chan_send_oclose(c);
		c->ostate=CHAN_OUTPUT_CLOSED;
		chan_delele_if_full_closed(c);
		return;
	}
@


1.3
log
@re-implement the proto-1.5 channel close protocol, see nchan.ms.
@
text
@d2 1
a2 1
RCSID("$Id: nchan.c,v 1.2 1999/10/16 22:29:01 markus Exp $");
d18 1
a18 1
 * EVENTS: update channel input/ouput states
d26 1
a26 1
		debug("channel %d: INPUT_WAIT_CLOSE -> INPUT_CLOSED [rcvd OCLOSE]", c->self);
d64 1
a64 1
		debug("channel %d: INPUT_WAIT_DRAIN -> INPUT_WAIT_OCLOSE [inbuf empty, send OCLOSE]", c->self);
d170 1
a170 1
		debug("internal error: channel %d: cannot send IEOF for istate %d",c->self,c->istate);
d179 1
a179 1
		error("chan_shutdown_write failed for %d/%d %.100s",
d186 1
a186 1
		error("chan_shutdown_read failed for %d/%d %.100s",
@


1.2
log
@add CVS tags, fix comments and whitespace
@
text
@d2 1
a2 1
RCSID("$Id: ssh.c,v 1.24 1999/10/14 18:17:42 markus Exp $");
d7 1
a8 1
#include "packet.h"
d11 11
d23 18
a40 2
dump_chan(Channel *c){
	debug("chan %d type %d flags 0x%x", c->self, c->type, c->flags);
d43 11
a53 5
chan_rcvd_ieof(Channel *c){
	dump_chan(c);
	if(c->flags & CHAN_IEOF_RCVD){
		debug("chan_rcvd_ieof twice: %d",c->self);
		return;
a54 4
	debug("rcvd_CHAN_IEOF %d",c->self);
	c->flags |= CHAN_IEOF_RCVD;
	/* cannot clear input buffer. remaining data has to be sent to client */
	chan_del_if_dead(c);
d57 14
a70 5
chan_rcvd_oclose(Channel *c){
	dump_chan(c);
	if(c->flags & CHAN_OCLOSE_RCVD){
		debug("chan_rcvd_oclose twice: %d",c->self);
		return;
a71 7
	debug("rcvd_CHAN_OCLOSE %d",c->self);
	c->flags |= CHAN_OCLOSE_RCVD;
	/* our peer can no longer consume, so there is not need to read */
	chan_shutdown_read(c);
	buffer_consume(&c->output, buffer_len(&c->output));
	/* Note: for type==OPEN IEOF is sent by channel_output_poll() */
	chan_del_if_dead(c);
d73 1
d75 70
d146 10
a155 4
	if(c->flags & CHAN_IEOF_SENT){
		/* this is ok: it takes some time before we get OCLOSE */
		/* debug("send_chan_ieof twice %d", c->self); */
		return;
a156 6
	debug("send_CHAN_IEOF %d", c->self);
	packet_start(CHAN_IEOF);
	packet_put_int(c->remote_id);
	packet_send();
	c->flags |= CHAN_IEOF_SENT;
	dump_chan(c);
d158 1
a158 1
void
d160 12
a171 3
	if(c->flags & CHAN_OCLOSE_SENT){
		debug("send_chan_oclose twice %d", c->self);
		return;
a172 6
	debug("send_CHAN_OCLOSE %d", c->self);
	packet_start(CHAN_OCLOSE);
	packet_put_int(c->remote_id);
	packet_send();
	c->flags |= CHAN_OCLOSE_SENT;
	dump_chan(c);
d174 2
a175 1
void
d177 1
a177 5
	if(c->flags & CHAN_SHUT_WR){
		debug("chan_shutdown_write twice %d",c->self);
		return;
	}
	debug("chan_shutdown_write %d", c->self);
d179 2
a180 5
		error("chan_shutdown_write failed %.100s", strerror(errno));
	c->flags |= CHAN_SHUT_WR;
	/* clear output buffer, since there is noone going to read the data
	   we just closed the output-socket */
	/* buffer_consume(&c->output, buffer_len(&c->output)); */
d182 1
a182 1
void
d184 1
a184 6
	if(c->flags & CHAN_SHUT_RD){
		/* chan_shutdown_read is called for read-errors and OCLOSE */
		/* debug("chan_shutdown_read twice %d",c->self); */
		return;
	}
	debug("chan_shutdown_read %d", c->self);
d186 2
a187 2
		error("chan_shutdown_read failed %.100s", strerror(errno));
	c->flags |= CHAN_SHUT_RD;
d189 4
a192 4
void
chan_del_if_dead(Channel *c){
	if(c->flags == CHAN_CLOSED){
		debug("channel %d closing",c->self);
d195 5
@


1.1
log
@support for SSH protocol 1.5 which is poorly documented, the RFC.troff lies.
interops (x11,agent,etc) with 1.2.27 and protocol 1.3
@
text
@d2 2
a10 1

d45 2
a46 1
		debug("send_chan_ieof twice %d", c->self);
d81 1
a81 1
	// buffer_consume(&c->output, buffer_len(&c->output));
d86 2
a87 1
		debug("chan_shutdown_read twice %d",c->self);
@

