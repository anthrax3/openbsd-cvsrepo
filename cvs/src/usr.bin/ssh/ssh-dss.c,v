head	1.35;
access;
symbols
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.35.0.4
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.10
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.8
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.6
	OPENBSD_5_0:1.27.0.4
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.14
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.10
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.8
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.6
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.4
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.23.0.4
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.19.0.10
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.8
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.6
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.4
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_8:1.6.0.2;
locks; strict;
comment	@ * @;


1.35
date	2016.04.21.06.08.02;	author djm;	state Exp;
branches;
next	1.34;
commitid	TEz9L872jtCmA2c4;

1.34
date	2015.12.11.04.21.12;	author mmcc;	state Exp;
branches;
next	1.33;
commitid	frWDG3VpknGQboCf;

1.33
date	2015.12.10.17.08.40;	author mmcc;	state Exp;
branches;
next	1.32;
commitid	qST12VGCwbX5zIfM;

1.32
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.31;
commitid	1h9UxAQmwdaqUzyX;

1.31
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.30;

1.30
date	2014.01.09.23.20.00;	author djm;	state Exp;
branches;
next	1.29;

1.29
date	2013.12.27.22.30.17;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2010.08.31.09.58.37;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2010.04.16.01.47.26;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2006.11.06.21.25.28;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.10.16.23.41;	author jakob;	state Exp;
branches
	1.19.8.1
	1.19.10.1;
next	1.18;

1.18
date	2003.02.12.09.33.04;	author markus;	state Exp;
branches
	1.18.2.1
	1.18.4.1;
next	1.17;

1.17
date	2002.07.04.10.41.47;	author markus;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2002.07.04.04.15.33;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.23.03.30.17;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.28.15.46.33;	author markus;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2002.02.24.19.14.59;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.25.21.42.11;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.27.18.22.16;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.05.10.06.12;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.07.22.10.28;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.17.19.27.15;	author stevesk;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.06.06.23.13.54;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.08.19.30.52;	author itojun;	state Exp;
branches
	1.6.2.1
	1.6.4.1
	1.6.6.1;
next	1.5;

1.5
date	2001.02.04.15.32.25;	author stevesk;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.21.19.05.57;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.19.16.50.58;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.19.23.17.58;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.12.19.50.38;	author markus;	state Exp;
branches;
next	;

1.6.2.1
date	2001.02.16.20.13.17;	author jason;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.02.19.17.19.28;	author jason;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.03.21.19.46.29;	author jason;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.05.07.21.09.35;	author jason;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2001.11.15.22.50.30;	author miod;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.6.4.1
date	2001.03.12.15.44.16;	author jason;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.03.21.18.53.09;	author jason;	state Exp;
branches;
next	;

1.6.6.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.6.6.2;

1.6.6.2
date	2001.11.15.22.51.15;	author miod;	state Exp;
branches;
next	1.6.6.3;

1.6.6.3
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	;

1.8.2.1
date	2001.11.14.03.24.39;	author jason;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2002.06.26.18.22.36;	author miod;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.14.2.1
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.10.11.14.51.53;	author miod;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.17.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2003.09.16.21.20.28;	author brad;	state Exp;
branches;
next	;

1.18.2.1
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.18.4.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.19.8.1
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	1.19.8.2;

1.19.8.2
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.19.10.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	1.19.10.2;

1.19.10.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.23.4.1
date	2006.11.08.00.42.11;	author brad;	state Exp;
branches;
next	;


desc
@@


1.35
log
@make argument == NULL tests more consistent
@
text
@/* $OpenBSD: ssh-dss.c,v 1.34 2015/12/11 04:21:12 mmcc Exp $ */
/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>

#include <openssl/bn.h>
#include <openssl/evp.h>

#include <string.h>

#include "sshbuf.h"
#include "compat.h"
#include "ssherr.h"
#include "digest.h"
#define SSHKEY_INTERNAL
#include "sshkey.h"

#define INTBLOB_LEN	20
#define SIGBLOB_LEN	(2*INTBLOB_LEN)

int
ssh_dss_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
    const u_char *data, size_t datalen, u_int compat)
{
	DSA_SIG *sig = NULL;
	u_char digest[SSH_DIGEST_MAX_LENGTH], sigblob[SIGBLOB_LEN];
	size_t rlen, slen, len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);
	struct sshbuf *b = NULL;
	int ret = SSH_ERR_INVALID_ARGUMENT;

	if (lenp != NULL)
		*lenp = 0;
	if (sigp != NULL)
		*sigp = NULL;

	if (key == NULL || key->dsa == NULL ||
	    sshkey_type_plain(key->type) != KEY_DSA)
		return SSH_ERR_INVALID_ARGUMENT;
	if (dlen == 0)
		return SSH_ERR_INTERNAL_ERROR;

	if ((ret = ssh_digest_memory(SSH_DIGEST_SHA1, data, datalen,
	    digest, sizeof(digest))) != 0)
		goto out;

	if ((sig = DSA_do_sign(digest, dlen, key->dsa)) == NULL) {
		ret = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}

	rlen = BN_num_bytes(sig->r);
	slen = BN_num_bytes(sig->s);
	if (rlen > INTBLOB_LEN || slen > INTBLOB_LEN) {
		ret = SSH_ERR_INTERNAL_ERROR;
		goto out;
	}
	explicit_bzero(sigblob, SIGBLOB_LEN);
	BN_bn2bin(sig->r, sigblob + SIGBLOB_LEN - INTBLOB_LEN - rlen);
	BN_bn2bin(sig->s, sigblob + SIGBLOB_LEN - slen);

	if (compat & SSH_BUG_SIGBLOB) {
		if (sigp != NULL) {
			if ((*sigp = malloc(SIGBLOB_LEN)) == NULL) {
				ret = SSH_ERR_ALLOC_FAIL;
				goto out;
			}
			memcpy(*sigp, sigblob, SIGBLOB_LEN);
		}
		if (lenp != NULL)
			*lenp = SIGBLOB_LEN;
		ret = 0;
	} else {
		/* ietf-drafts */
		if ((b = sshbuf_new()) == NULL) {
			ret = SSH_ERR_ALLOC_FAIL;
			goto out;
		}
		if ((ret = sshbuf_put_cstring(b, "ssh-dss")) != 0 ||
		    (ret = sshbuf_put_string(b, sigblob, SIGBLOB_LEN)) != 0)
			goto out;
		len = sshbuf_len(b);
		if (sigp != NULL) {
			if ((*sigp = malloc(len)) == NULL) {
				ret = SSH_ERR_ALLOC_FAIL;
				goto out;
			}
			memcpy(*sigp, sshbuf_ptr(b), len);
		}
		if (lenp != NULL)
			*lenp = len;
		ret = 0;
	}
 out:
	explicit_bzero(digest, sizeof(digest));
	if (sig != NULL)
		DSA_SIG_free(sig);
	sshbuf_free(b);
	return ret;
}

int
ssh_dss_verify(const struct sshkey *key,
    const u_char *signature, size_t signaturelen,
    const u_char *data, size_t datalen, u_int compat)
{
	DSA_SIG *sig = NULL;
	u_char digest[SSH_DIGEST_MAX_LENGTH], *sigblob = NULL;
	size_t len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);
	int ret = SSH_ERR_INTERNAL_ERROR;
	struct sshbuf *b = NULL;
	char *ktype = NULL;

	if (key == NULL || key->dsa == NULL ||
	    sshkey_type_plain(key->type) != KEY_DSA ||
	    signature == NULL || signaturelen == 0)
		return SSH_ERR_INVALID_ARGUMENT;
	if (dlen == 0)
		return SSH_ERR_INTERNAL_ERROR;

	/* fetch signature */
	if (compat & SSH_BUG_SIGBLOB) {
		if ((sigblob = malloc(signaturelen)) == NULL)
			return SSH_ERR_ALLOC_FAIL;
		memcpy(sigblob, signature, signaturelen);
		len = signaturelen;
	} else {
		/* ietf-drafts */
		if ((b = sshbuf_from(signature, signaturelen)) == NULL)
			return SSH_ERR_ALLOC_FAIL;
		if (sshbuf_get_cstring(b, &ktype, NULL) != 0 ||
		    sshbuf_get_string(b, &sigblob, &len) != 0) {
			ret = SSH_ERR_INVALID_FORMAT;
			goto out;
		}
		if (strcmp("ssh-dss", ktype) != 0) {
			ret = SSH_ERR_KEY_TYPE_MISMATCH;
			goto out;
		}
		if (sshbuf_len(b) != 0) {
			ret = SSH_ERR_UNEXPECTED_TRAILING_DATA;
			goto out;
		}
	}

	if (len != SIGBLOB_LEN) {
		ret = SSH_ERR_INVALID_FORMAT;
		goto out;
	}

	/* parse signature */
	if ((sig = DSA_SIG_new()) == NULL ||
	    (sig->r = BN_new()) == NULL ||
	    (sig->s = BN_new()) == NULL) {
		ret = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((BN_bin2bn(sigblob, INTBLOB_LEN, sig->r) == NULL) ||
	    (BN_bin2bn(sigblob+ INTBLOB_LEN, INTBLOB_LEN, sig->s) == NULL)) {
		ret = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}

	/* sha1 the data */
	if ((ret = ssh_digest_memory(SSH_DIGEST_SHA1, data, datalen,
	    digest, sizeof(digest))) != 0)
		goto out;

	switch (DSA_do_verify(digest, dlen, sig, key->dsa)) {
	case 1:
		ret = 0;
		break;
	case 0:
		ret = SSH_ERR_SIGNATURE_INVALID;
		goto out;
	default:
		ret = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}

 out:
	explicit_bzero(digest, sizeof(digest));
	if (sig != NULL)
		DSA_SIG_free(sig);
	sshbuf_free(b);
	free(ktype);
	if (sigblob != NULL) {
		explicit_bzero(sigblob, len);
		free(sigblob);
	}
	return ret;
}
@


1.34
log
@Remove NULL-checks before sshbuf_free().

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.33 2015/12/10 17:08:40 mmcc Exp $ */
d136 2
a137 1
	    sshkey_type_plain(key->type) != KEY_DSA)
@


1.33
log
@Remove NULL-checks before free().

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.32 2014/06/24 01:13:21 djm Exp $ */
d119 1
a119 2
	if (b != NULL)
		sshbuf_free(b);
d205 1
a205 2
	if (b != NULL)
		sshbuf_free(b);
@


1.32
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.31 2014/02/02 03:44:31 djm Exp $ */
d208 1
a208 2
	if (ktype != NULL)
		free(ktype);
@


1.31
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.30 2014/01/09 23:20:00 djm Exp $ */
d33 1
a33 2
#include "xmalloc.h"
#include "buffer.h"
d35 1
a35 2
#include "log.h"
#include "key.h"
d37 2
d44 2
a45 2
ssh_dss_sign(const Key *key, u_char **sigp, u_int *lenp,
    const u_char *data, u_int datalen)
d47 1
a47 1
	DSA_SIG *sig;
d49 22
a70 21
	u_int rlen, slen, len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);
	Buffer b;

	if (key == NULL || key_type_plain(key->type) != KEY_DSA ||
	    key->dsa == NULL) {
		error("%s: no DSA key", __func__);
		return -1;
	}

	if (ssh_digest_memory(SSH_DIGEST_SHA1, data, datalen,
	    digest, sizeof(digest)) != 0) {
		error("%s: ssh_digest_memory failed", __func__);
		return -1;
	}

	sig = DSA_do_sign(digest, dlen, key->dsa);
	explicit_bzero(digest, sizeof(digest));

	if (sig == NULL) {
		error("ssh_dss_sign: sign failed");
		return -1;
d76 2
a77 3
		error("bad sig size %u %u", rlen, slen);
		DSA_SIG_free(sig);
		return -1;
d80 2
a81 3
	BN_bn2bin(sig->r, sigblob+ SIGBLOB_LEN - INTBLOB_LEN - rlen);
	BN_bn2bin(sig->s, sigblob+ SIGBLOB_LEN - slen);
	DSA_SIG_free(sig);
d83 1
a83 3
	if (datafellows & SSH_BUG_SIGBLOB) {
		if (lenp != NULL)
			*lenp = SIGBLOB_LEN;
d85 4
a88 1
			*sigp = xmalloc(SIGBLOB_LEN);
d91 3
d96 15
a110 4
		buffer_init(&b);
		buffer_put_cstring(&b, "ssh-dss");
		buffer_put_string(&b, sigblob, SIGBLOB_LEN);
		len = buffer_len(&b);
d113 1
a113 5
		if (sigp != NULL) {
			*sigp = xmalloc(len);
			memcpy(*sigp, buffer_ptr(&b), len);
		}
		buffer_free(&b);
d115 7
a121 1
	return 0;
d123 1
d125 3
a127 2
ssh_dss_verify(const Key *key, const u_char *signature, u_int signaturelen,
    const u_char *data, u_int datalen)
d129 12
a140 11
	DSA_SIG *sig;
	u_char digest[SSH_DIGEST_MAX_LENGTH], *sigblob;
	u_int len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);
	int rlen, ret;
	Buffer b;

	if (key == NULL || key_type_plain(key->type) != KEY_DSA ||
	    key->dsa == NULL) {
		error("%s: no DSA key", __func__);
		return -1;
	}
d143 3
a145 2
	if (datafellows & SSH_BUG_SIGBLOB) {
		sigblob = xmalloc(signaturelen);
d150 7
a156 4
		char *ktype;
		buffer_init(&b);
		buffer_append(&b, signature, signaturelen);
		ktype = buffer_get_cstring(&b, NULL);
d158 2
a159 4
			error("%s: cannot handle type %s", __func__, ktype);
			buffer_free(&b);
			free(ktype);
			return -1;
d161 3
a163 9
		free(ktype);
		sigblob = buffer_get_string(&b, &len);
		rlen = buffer_len(&b);
		buffer_free(&b);
		if (rlen != 0) {
			error("%s: remaining bytes in signature %d",
			    __func__, rlen);
			free(sigblob);
			return -1;
d168 2
a169 1
		fatal("bad sigbloblen %u != SIGBLOB_LEN", len);
d173 6
a178 6
	if ((sig = DSA_SIG_new()) == NULL)
		fatal("%s: DSA_SIG_new failed", __func__);
	if ((sig->r = BN_new()) == NULL)
		fatal("%s: BN_new failed", __func__);
	if ((sig->s = BN_new()) == NULL)
		fatal("ssh_dss_verify: BN_new failed");
d180 4
a183 6
	    (BN_bin2bn(sigblob+ INTBLOB_LEN, INTBLOB_LEN, sig->s) == NULL))
		fatal("%s: BN_bin2bn failed", __func__);

	/* clean up */
	explicit_bzero(sigblob, len);
	free(sigblob);
d186 14
a199 4
	if (ssh_digest_memory(SSH_DIGEST_SHA1, data, datalen,
	    digest, sizeof(digest)) != 0) {
		error("%s: digest_memory failed", __func__);
		return -1;
d202 1
a202 1
	ret = DSA_do_verify(digest, dlen, sig, key->dsa);
d204 10
a213 5

	DSA_SIG_free(sig);

	debug("%s: signature %s", __func__,
	    ret == 1 ? "correct" : ret == 0 ? "incorrect" : "error");
@


1.30
log
@Introduce digest API and use it to perform all hashing operations
rather than calling OpenSSL EVP_Digest* directly. Will make it easier
to build a reduced-feature OpenSSH without OpenSSL in future;
feedback, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.29 2013/12/27 22:30:17 djm Exp $ */
d65 1
a65 1
	memset(digest, 'd', sizeof(digest));
d79 1
a79 1
	memset(sigblob, 0, SIGBLOB_LEN);
d168 1
a168 1
	memset(sigblob, 0, len);
d179 1
a179 1
	memset(digest, 'd', sizeof(digest));
@


1.29
log
@make the original RSA and DSA signing/verification code look more like
the ECDSA/Ed25519 ones: use key_type_plain() when checking the key type
rather than tediously listing all variants, use __func__ for debug/
error messages
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.28 2013/05/17 00:13:14 djm Exp $ */
d38 1
d48 2
a49 4
	const EVP_MD *evp_md = EVP_sha1();
	EVP_MD_CTX md;
	u_char digest[EVP_MAX_MD_SIZE], sigblob[SIGBLOB_LEN];
	u_int rlen, slen, len, dlen;
d58 5
a62 3
	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, data, datalen);
	EVP_DigestFinal(&md, digest, &dlen);
d112 2
a113 4
	const EVP_MD *evp_md = EVP_sha1();
	EVP_MD_CTX md;
	u_char digest[EVP_MAX_MD_SIZE], *sigblob;
	u_int len, dlen;
d172 5
a176 3
	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, data, datalen);
	EVP_DigestFinal(&md, digest, &dlen);
@


1.28
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.27 2010/08/31 09:58:37 djm Exp $ */
d53 3
a55 3
	if (key == NULL || key->dsa == NULL || (key->type != KEY_DSA &&
	    key->type != KEY_DSA_CERT && key->type != KEY_DSA_CERT_V00)) {
		error("ssh_dss_sign: no DSA key");
d58 1
d118 3
a120 3
	if (key == NULL || key->dsa == NULL || (key->type != KEY_DSA &&
	    key->type != KEY_DSA_CERT && key->type != KEY_DSA_CERT_V00)) {
		error("ssh_dss_verify: no DSA key");
d136 1
a136 1
			error("ssh_dss_verify: cannot handle type %s", ktype);
d146 2
a147 2
			error("ssh_dss_verify: "
			    "remaining bytes in signature %d", rlen);
d159 1
a159 1
		fatal("ssh_dss_verify: DSA_SIG_new failed");
d161 1
a161 1
		fatal("ssh_dss_verify: BN_new failed");
d166 1
a166 1
		fatal("ssh_dss_verify: BN_bin2bn failed");
d182 1
a182 1
	debug("ssh_dss_verify: signature %s",
@


1.27
log
@Add buffer_get_cstring() and related functions that verify that the
string extracted from the buffer contains no embedded \0 characters*
This prevents random (possibly malicious) crap from being appended to
strings where it would not be noticed if the string is used with
a string(3) function.

Use the new API in a few sensitive places.

* actually, we allow a single one at the end of the string for now because
we don't know how many deployed implementations get this wrong, but don't
count on this to remain indefinitely.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.26 2010/04/16 01:47:26 djm Exp $ */
d137 1
a137 1
			xfree(ktype);
d140 1
a140 1
		xfree(ktype);
d147 1
a147 1
			xfree(sigblob);
d169 1
a169 1
	xfree(sigblob);
@


1.26
log
@revised certificate format ssh-{dss,rsa}-cert-v01@@openssh.com with the
following changes:

move the nonce field to the beginning of the certificate where it can
better protect against chosen-prefix attacks on the signature hash

Rename "constraints" field to "critical options"

Add a new non-critical "extensions" field

Add a serial number

The older format is still support for authentication and cert generation
(use "ssh-keygen -t v00 -s ca_key ..." to generate a v00 certificate)

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.25 2010/02/26 20:29:54 djm Exp $ */
d133 1
a133 1
		ktype = buffer_get_string(&b, NULL);
@


1.25
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.24 2006/11/06 21:25:28 markus Exp $ */
d53 2
a54 3
	if (key == NULL ||
	    (key->type != KEY_DSA && key->type != KEY_DSA_CERT) ||
	    key->dsa == NULL) {
d117 2
a118 3
	if (key == NULL ||
	    (key->type != KEY_DSA && key->type != KEY_DSA_CERT) ||
	    key->dsa == NULL) {
@


1.24
log
@add missing checks for openssl return codes; with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.23 2006/08/03 03:34:42 deraadt Exp $ */
d53 3
a55 1
	if (key == NULL || key->type != KEY_DSA || key->dsa == NULL) {
d118 3
a120 1
	if (key == NULL || key->type != KEY_DSA || key->dsa == NULL) {
@


1.23
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.22 2006/07/22 20:48:23 stevesk Exp $ */
d161 3
a163 2
	BN_bin2bn(sigblob, INTBLOB_LEN, sig->r);
	BN_bin2bn(sigblob+ INTBLOB_LEN, INTBLOB_LEN, sig->s);
@


1.23.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.24 2006/11/06 21:25:28 markus Exp $ */
d161 2
a162 3
	if ((BN_bin2bn(sigblob, INTBLOB_LEN, sig->r) == NULL) ||
	    (BN_bin2bn(sigblob+ INTBLOB_LEN, INTBLOB_LEN, sig->s) == NULL))
		fatal("ssh_dss_verify: BN_bin2bn failed");
@


1.22
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.21 2006/03/25 13:17:02 djm Exp $ */
d26 1
a26 1
#include "includes.h"
a34 1
#include "bufaux.h"
@


1.21
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d30 2
@


1.20
log
@RCSID() can die
@
text
@d1 1
@


1.19
log
@constify. ok markus@@ & djm@@
@
text
@a25 1
RCSID("$OpenBSD: ssh-dss.c,v 1.18 2003/02/12 09:33:04 markus Exp $");
@


1.19.8.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh-dss.c,v 1.23 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 1
#include <sys/types.h>
a30 2
#include <string.h>

d33 1
@


1.19.8.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.24 2006/11/06 21:25:28 markus Exp $ */
d161 2
a162 3
	if ((BN_bin2bn(sigblob, INTBLOB_LEN, sig->r) == NULL) ||
	    (BN_bin2bn(sigblob+ INTBLOB_LEN, INTBLOB_LEN, sig->s) == NULL))
		fatal("ssh_dss_verify: BN_bin2bn failed");
@


1.19.10.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh-dss.c,v 1.23 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 1
#include <sys/types.h>
a30 2
#include <string.h>

d33 1
@


1.19.10.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-dss.c,v 1.24 2006/11/06 21:25:28 markus Exp $ */
d161 2
a162 3
	if ((BN_bin2bn(sigblob, INTBLOB_LEN, sig->r) == NULL) ||
	    (BN_bin2bn(sigblob+ INTBLOB_LEN, INTBLOB_LEN, sig->s) == NULL))
		fatal("ssh_dss_verify: BN_bin2bn failed");
@


1.18
log
@merge ssh-dss.h ssh-rsa.h into key.h; ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.17 2002/07/04 10:41:47 markus Exp $");
d42 2
a43 2
ssh_dss_sign(Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d104 2
a105 2
ssh_dss_verify(Key *key, u_char *signature, u_int signaturelen,
    u_char *data, u_int datalen)
d122 2
a123 1
		sigblob = signature;
d163 3
a165 4
	if (!(datafellows & SSH_BUG_SIGBLOB)) {
		memset(sigblob, 0, len);
		xfree(sigblob);
	}
@


1.18.2.1
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.19 2003/11/10 16:23:41 jakob Exp $");
d42 2
a43 2
ssh_dss_sign(const Key *key, u_char **sigp, u_int *lenp,
    const u_char *data, u_int datalen)
d104 2
a105 2
ssh_dss_verify(const Key *key, const u_char *signature, u_int signaturelen,
    const u_char *data, u_int datalen)
d122 1
a122 2
		sigblob = xmalloc(signaturelen);
		memcpy(sigblob, signature, signaturelen);
d162 4
a165 3
	/* clean up */
	memset(sigblob, 0, len);
	xfree(sigblob);
@


1.18.4.1
log
@upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.19 2003/11/10 16:23:41 jakob Exp $");
d42 2
a43 2
ssh_dss_sign(const Key *key, u_char **sigp, u_int *lenp,
    const u_char *data, u_int datalen)
d104 2
a105 2
ssh_dss_verify(const Key *key, const u_char *signature, u_int signaturelen,
    const u_char *data, u_int datalen)
d122 1
a122 2
		sigblob = xmalloc(signaturelen);
		memcpy(sigblob, signature, signaturelen);
d162 4
a165 3
	/* clean up */
	memset(sigblob, 0, len);
	xfree(sigblob);
@


1.18.4.2
log
@upgrade to OpenSSH 3.9
@
text
@@


1.17
log
@don't allocate, copy, and discard if there is not interested in the data; ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.16 2002/07/04 04:15:33 deraadt Exp $");
a36 1
#include "ssh-dss.h"
@


1.17.2.1
log
@Update to OpenSSH 3.6
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.18 2003/02/12 09:33:04 markus Exp $");
d37 1
@


1.17.2.2
log
@upgrade to OpenSSH 3.7
@
text
@@


1.16
log
@patch memory leaks; grendel@@zeitbombe.org
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.15 2002/06/23 03:30:17 deraadt Exp $");
d49 1
a49 1
	u_char *ret, digest[EVP_MAX_MD_SIZE], sigblob[SIGBLOB_LEN];
a81 2
		ret = xmalloc(SIGBLOB_LEN);
		memcpy(ret, sigblob, SIGBLOB_LEN);
d84 4
a87 4
		if (sigp != NULL)
			*sigp = ret;
		else
			xfree(ret);
a93 3
		ret = xmalloc(len);
		memcpy(ret, buffer_ptr(&b), len);
		buffer_free(&b);
d96 5
a100 4
		if (sigp != NULL)
			*sigp = ret;
		else
			xfree(ret);
@


1.15
log
@various KNF and %d for unsigned
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.14 2002/02/28 15:46:33 markus Exp $");
d88 2
d103 2
@


1.14
log
@add some const EVP_MD for openssl-0.9.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.13 2002/02/24 19:14:59 markus Exp $");
d43 1
a43 3
ssh_dss_sign(
    Key *key,
    u_char **sigp, u_int *lenp,
d72 1
a72 1
		error("bad sig size %d %d", rlen, slen);
d105 1
a105 3
ssh_dss_verify(
    Key *key,
    u_char *signature, u_int signaturelen,
d150 1
a150 1
		fatal("bad sigbloblen %d != SIGBLOB_LEN", len);
@


1.14.2.1
log
@Pull in OpenSSH-3.4
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.15 2002/06/23 03:30:17 deraadt Exp $");
d43 3
a45 1
ssh_dss_sign(Key *key, u_char **sigp, u_int *lenp,
d74 1
a74 1
		error("bad sig size %u %u", rlen, slen);
d107 3
a109 1
ssh_dss_verify(Key *key, u_char *signature, u_int signaturelen,
d154 1
a154 1
		fatal("bad sigbloblen %u != SIGBLOB_LEN", len);
@


1.14.2.2
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.17 2002/07/04 10:41:47 markus Exp $");
d49 1
a49 1
	u_char digest[EVP_MAX_MD_SIZE], sigblob[SIGBLOB_LEN];
d82 2
d86 2
a87 4
		if (sigp != NULL) {
			*sigp = xmalloc(SIGBLOB_LEN);
			memcpy(*sigp, sigblob, SIGBLOB_LEN);
		}
d94 3
d99 2
a100 5
		if (sigp != NULL) {
			*sigp = xmalloc(len);
			memcpy(*sigp, buffer_ptr(&b), len);
		}
		buffer_free(&b);
@


1.14.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.18 2003/02/12 09:33:04 markus Exp $");
d37 1
@


1.13
log
@signed vs. unsigned: make size arguments u_int, ok stevesk@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.12 2002/01/25 21:42:11 markus Exp $");
d49 1
a49 1
	EVP_MD *evp_md = EVP_sha1();
d113 1
a113 1
	EVP_MD *evp_md = EVP_sha1();
@


1.12
log
@use static EVP_MAX_MD_SIZE buffers for EVP_DigestFinal; ok stevesk@@
don't use evp_md->md_size, it's not public.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.11 2001/12/27 18:22:16 markus Exp $");
d45 2
a46 2
    u_char **sigp, int *lenp,
    u_char *data, int datalen)
d109 2
a110 2
    u_char *signature, int signaturelen,
    u_char *data, int datalen)
@


1.11
log
@call fatal() for openssl allocation failures
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.10 2001/12/05 10:06:12 deraadt Exp $");
d51 1
a51 1
	u_char *digest, *ret, sigblob[SIGBLOB_LEN];
a58 2
	dlen = evp_md->md_size;
	digest = xmalloc(dlen);
d61 1
a61 1
	EVP_DigestFinal(&md, digest, NULL);
d64 1
a65 2
	memset(digest, 0, dlen);
	xfree(digest);
d115 1
a115 1
	u_char *digest, *sigblob;
a172 2
	dlen = evp_md->md_size;
	digest = xmalloc(dlen);
d175 1
a175 1
	EVP_DigestFinal(&md, digest, NULL);
d178 1
a179 2
	memset(digest, 0, dlen);
	xfree(digest);
@


1.10
log
@minor KNF
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.9 2001/11/07 22:10:28 markus Exp $");
d161 6
a166 3
	sig = DSA_SIG_new();
	sig->r = BN_new();
	sig->s = BN_new();
@


1.9
log
@missing free and sync dss/rsa code.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.8 2001/09/17 19:27:15 stevesk Exp $");
d148 1
a148 1
		if(rlen != 0) {
@


1.8
log
@u_char*/char* cleanup; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.7 2001/06/06 23:13:54 markus Exp $");
d141 1
d144 1
d147 1
d149 3
a151 2
			error("remaining bytes in signature %d", rlen);
			buffer_free(&b);
a153 2
		buffer_free(&b);
		xfree(ktype);
@


1.8.2.1
log
@Pull in patches from current (Errata 002):
Update to OpenSSH-3.0.1 via errata patch (Instead of using release tarball)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.9 2001/11/07 22:10:28 markus Exp $");
a140 1
			xfree(ktype);
a142 1
		xfree(ktype);
a144 1
		buffer_free(&b);
d146 2
a147 3
			error("ssh_dss_verify: "
			    "remaining bytes in signature %d", rlen);
			xfree(sigblob);
d150 2
@


1.8.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.14 2002/02/28 15:46:33 markus Exp $");
d45 2
a46 2
    u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d49 1
a49 1
	const EVP_MD *evp_md = EVP_sha1();
d51 1
a51 1
	u_char *ret, digest[EVP_MAX_MD_SIZE], sigblob[SIGBLOB_LEN];
d59 2
d63 1
a63 1
	EVP_DigestFinal(&md, digest, &dlen);
a65 1
	memset(digest, 'd', sizeof(digest));
d67 2
d112 2
a113 2
    u_char *signature, u_int signaturelen,
    u_char *data, u_int datalen)
d116 1
a116 1
	const EVP_MD *evp_md = EVP_sha1();
d118 1
a118 1
	u_char digest[EVP_MAX_MD_SIZE], *sigblob;
d148 1
a148 1
		if (rlen != 0) {
d161 3
a163 6
	if ((sig = DSA_SIG_new()) == NULL)
		fatal("ssh_dss_verify: DSA_SIG_new failed");
	if ((sig->r = BN_new()) == NULL)
		fatal("ssh_dss_verify: BN_new failed");
	if ((sig->s = BN_new()) == NULL)
		fatal("ssh_dss_verify: BN_new failed");
d173 2
d177 1
a177 1
	EVP_DigestFinal(&md, digest, &dlen);
a179 1
	memset(digest, 'd', sizeof(digest));
d181 2
@


1.8.2.3
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.8.2.2 2002/03/07 17:37:47 jason Exp $");
d43 3
a45 1
ssh_dss_sign(Key *key, u_char **sigp, u_int *lenp,
d74 1
a74 1
		error("bad sig size %u %u", rlen, slen);
d107 3
a109 1
ssh_dss_verify(Key *key, u_char *signature, u_int signaturelen,
d154 1
a154 1
		fatal("bad sigbloblen %u != SIGBLOB_LEN", len);
@


1.8.2.4
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.17 2002/07/04 10:41:47 markus Exp $");
d49 1
a49 1
	u_char digest[EVP_MAX_MD_SIZE], sigblob[SIGBLOB_LEN];
d82 2
d86 2
a87 4
		if (sigp != NULL) {
			*sigp = xmalloc(SIGBLOB_LEN);
			memcpy(*sigp, sigblob, SIGBLOB_LEN);
		}
d94 3
d99 2
a100 5
		if (sigp != NULL) {
			*sigp = xmalloc(len);
			memcpy(*sigp, buffer_ptr(&b), len);
		}
		buffer_free(&b);
@


1.7
log
@cleanup, remove old code
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.6 2001/02/08 19:30:52 itojun Exp $");
d136 1
a136 1
		buffer_append(&b, (char *) signature, signaturelen);
d143 1
a143 1
		sigblob = (u_char *)buffer_get_string(&b, &len);
@


1.6
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.5 2001/02/04 15:32:25 stevesk Exp $");
a47 2
	u_char *digest;
	u_char *ret;
d51 2
a52 4
	u_int rlen;
	u_int slen;
	u_int len, dlen;
	u_char sigblob[SIGBLOB_LEN];
d66 3
d70 2
a71 1
		fatal("ssh_dss_sign: cannot sign");
a72 2
	memset(digest, 0, dlen);
	xfree(digest);
a80 2
	debug("sig size %d %d", rlen, slen);

a86 1
		debug("datafellows");
a114 2
	Buffer b;
	u_char *digest;
d118 1
a118 2
	u_char *sigblob;
	char *txt;
d120 2
a121 2
	int rlen;
	int ret;
a127 12
	if (!(datafellows & SSH_BUG_SIGBLOB) &&
	    signaturelen == SIGBLOB_LEN) {
		datafellows |= ~SSH_BUG_SIGBLOB;
		log("autodetect SSH_BUG_SIGBLOB");
	} else if ((datafellows & SSH_BUG_SIGBLOB) &&
	    signaturelen != SIGBLOB_LEN) {
		log("autoremove SSH_BUG_SIGBLOB");
		datafellows &= ~SSH_BUG_SIGBLOB;
	}

	debug("len %d datafellows %d", signaturelen, datafellows);

d183 2
a184 13
	switch (ret) {
	case 1:
		txt = "correct";
		break;
	case 0:
		txt = "incorrect";
		break;
	case -1:
	default:
		txt = "error";
		break;
	}
	debug("ssh_dss_verify: signature %s", txt);
@


1.6.6.1
log
@Pull in OpenSSH-2.9.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.8 2001/09/17 19:27:15 stevesk Exp $");
d48 2
d53 4
a56 2
	u_char *digest, *ret, sigblob[SIGBLOB_LEN];
	u_int rlen, slen, len, dlen;
d70 3
a72 1

a74 4
	if (sig == NULL) {
		error("ssh_dss_sign: sign failed");
		return -1;
	}
d83 2
d91 1
d120 2
d125 2
a126 1
	u_char *digest, *sigblob;
d128 2
a129 2
	int rlen, ret;
	Buffer b;
d136 12
d156 1
a156 1
		buffer_append(&b, signature, signaturelen);
d163 1
a163 1
		sigblob = buffer_get_string(&b, &len);
d203 13
a215 2
	debug("ssh_dss_verify: signature %s",
	    ret == 1 ? "correct" : ret == 0 ? "incorrect" : "error");
@


1.6.6.2
log
@Merge OpenSSH 3.0.1.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.6.6.1 2001/09/27 19:03:55 jason Exp $");
a140 1
			xfree(ktype);
a142 1
		xfree(ktype);
a144 1
		buffer_free(&b);
d146 2
a147 3
			error("ssh_dss_verify: "
			    "remaining bytes in signature %d", rlen);
			xfree(sigblob);
d150 2
@


1.6.6.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.14 2002/02/28 15:46:33 markus Exp $");
d45 2
a46 2
    u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d49 1
a49 1
	const EVP_MD *evp_md = EVP_sha1();
d51 1
a51 1
	u_char *ret, digest[EVP_MAX_MD_SIZE], sigblob[SIGBLOB_LEN];
d59 2
d63 1
a63 1
	EVP_DigestFinal(&md, digest, &dlen);
a65 1
	memset(digest, 'd', sizeof(digest));
d67 2
d112 2
a113 2
    u_char *signature, u_int signaturelen,
    u_char *data, u_int datalen)
d116 1
a116 1
	const EVP_MD *evp_md = EVP_sha1();
d118 1
a118 1
	u_char digest[EVP_MAX_MD_SIZE], *sigblob;
d148 1
a148 1
		if (rlen != 0) {
d161 3
a163 6
	if ((sig = DSA_SIG_new()) == NULL)
		fatal("ssh_dss_verify: DSA_SIG_new failed");
	if ((sig->r = BN_new()) == NULL)
		fatal("ssh_dss_verify: BN_new failed");
	if ((sig->s = BN_new()) == NULL)
		fatal("ssh_dss_verify: BN_new failed");
d173 2
d177 1
a177 1
	EVP_DigestFinal(&md, digest, &dlen);
a179 1
	memset(digest, 'd', sizeof(digest));
d181 2
@


1.6.4.1
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.6 2001/02/08 19:30:52 itojun Exp $");
@


1.6.4.2
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.6.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.6 2001/02/08 19:30:52 itojun Exp $");
@


1.6.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.6.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.6.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.6.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.8 2001/09/17 19:27:15 stevesk Exp $");
d48 2
d53 4
a56 2
	u_char *digest, *ret, sigblob[SIGBLOB_LEN];
	u_int rlen, slen, len, dlen;
d70 3
a72 1

a74 4
	if (sig == NULL) {
		error("ssh_dss_sign: sign failed");
		return -1;
	}
d83 2
d91 1
d120 2
d125 2
a126 1
	u_char *digest, *sigblob;
d128 2
a129 2
	int rlen, ret;
	Buffer b;
d136 12
d156 1
a156 1
		buffer_append(&b, signature, signaturelen);
d163 1
a163 1
		sigblob = buffer_get_string(&b, &len);
d203 13
a215 2
	debug("ssh_dss_verify: signature %s",
	    ret == 1 ? "correct" : ret == 0 ? "incorrect" : "error");
@


1.6.2.6
log
@Merge OpenSSH 3.0.1.

This is likely to be the last commit to the 2.8-STABLE branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.6.2.5 2001/09/27 00:15:42 miod Exp $");
a140 1
			xfree(ktype);
a142 1
		xfree(ktype);
a144 1
		buffer_free(&b);
d146 2
a147 3
			error("ssh_dss_verify: "
			    "remaining bytes in signature %d", rlen);
			xfree(sigblob);
d150 2
@


1.6.2.7
log
@Merge OpenSSH 3.1.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.14 2002/02/28 15:46:33 markus Exp $");
d45 2
a46 2
    u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d49 1
a49 1
	const EVP_MD *evp_md = EVP_sha1();
d51 1
a51 1
	u_char *ret, digest[EVP_MAX_MD_SIZE], sigblob[SIGBLOB_LEN];
d59 2
d63 1
a63 1
	EVP_DigestFinal(&md, digest, &dlen);
a65 1
	memset(digest, 'd', sizeof(digest));
d67 2
d112 2
a113 2
    u_char *signature, u_int signaturelen,
    u_char *data, u_int datalen)
d116 1
a116 1
	const EVP_MD *evp_md = EVP_sha1();
d118 1
a118 1
	u_char digest[EVP_MAX_MD_SIZE], *sigblob;
d148 1
a148 1
		if (rlen != 0) {
d161 3
a163 6
	if ((sig = DSA_SIG_new()) == NULL)
		fatal("ssh_dss_verify: DSA_SIG_new failed");
	if ((sig->r = BN_new()) == NULL)
		fatal("ssh_dss_verify: BN_new failed");
	if ((sig->s = BN_new()) == NULL)
		fatal("ssh_dss_verify: BN_new failed");
d173 2
d177 1
a177 1
	EVP_DigestFinal(&md, digest, &dlen);
a179 1
	memset(digest, 'd', sizeof(digest));
d181 2
@


1.5
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.4 2001/01/21 19:05:57 markus Exp $");
d37 1
@


1.4
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.3 2001/01/19 16:50:58 markus Exp $");
d188 1
a188 1
	
@


1.3
log
@clear and free digest, make consistent with other code (use dlen); from stevesk@@
@
text
@d26 4
a29 1
RCSID("$OpenBSD: ssh-dss.c,v 1.2 2000/12/19 23:17:58 markus Exp $");
a30 1
#include "ssh.h"
d35 1
a35 6

#include <openssl/bn.h>
#include <openssl/rsa.h>
#include <openssl/dsa.h>
#include <openssl/evp.h>

@


1.2
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-dss.c,v 1.1 2000/11/12 19:50:38 markus Exp $");
d57 1
a57 1
	u_int len;
d65 2
a66 1
	digest = xmalloc(evp_md->md_size);
d71 1
a71 1
	sig = DSA_do_sign(digest, evp_md->md_size, key->dsa);
d75 2
@


1.1
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dsa.c,v 1.11 2000/09/07 20:27:51 deraadt Exp $");
d47 2
a48 2
    unsigned char **sigp, int *lenp,
    unsigned char *data, int datalen)
d50 2
a51 2
	unsigned char *digest;
	unsigned char *ret;
d55 4
a58 4
	unsigned int rlen;
	unsigned int slen;
	unsigned int len;
	unsigned char sigblob[SIGBLOB_LEN];
d116 2
a117 2
    unsigned char *signature, int signaturelen,
    unsigned char *data, int datalen)
d120 1
a120 1
	unsigned char *digest;
d124 1
a124 1
	unsigned char *sigblob;
d126 1
a126 1
	unsigned int len, dlen;
d162 1
a162 1
		sigblob = (unsigned char *)buffer_get_string(&b, &len);
@

