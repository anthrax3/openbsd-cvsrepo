head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.16
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.14
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.12
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.8
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.0.10
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.8
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.6
	OPENBSD_5_0:1.1.0.4
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.04.30.05.29.56;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	;


desc
@@


1.4
log
@New buffer API; the first installment of the conversion/replacement
of OpenSSH's internals to make them usable as a standalone library.

This includes a set of wrappers to make it compatible with the
existing buffer API so replacement can occur incrementally.

With and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review.
@
text
@/* $OpenBSD$ */

/*
 * Copyright (c) 2012 Damien Miller <djm@@mindrot.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Emulation wrappers for legacy OpenSSH buffer API atop sshbuf */

#include <sys/types.h>

#include "buffer.h"
#include "log.h"
#include "ssherr.h"

int
buffer_put_ecpoint_ret(Buffer *buffer, const EC_GROUP *curve,
    const EC_POINT *point)
{
	int ret;

	if ((ret = sshbuf_put_ec(buffer, point, curve)) != 0) {
		error("%s: %s", __func__, ssh_err(ret));
		return -1;
	}
	return 0;
}

void
buffer_put_ecpoint(Buffer *buffer, const EC_GROUP *curve,
    const EC_POINT *point)
{
	if (buffer_put_ecpoint_ret(buffer, curve, point) == -1)
		fatal("%s: buffer error", __func__);
}

int
buffer_get_ecpoint_ret(Buffer *buffer, const EC_GROUP *curve,
    EC_POINT *point)
{
	int ret;

	if ((ret = sshbuf_get_ec(buffer, point, curve)) != 0) {
		error("%s: %s", __func__, ssh_err(ret));
		return -1;
	}
	return 0;
}

void
buffer_get_ecpoint(Buffer *buffer, const EC_GROUP *curve,
    EC_POINT *point)
{
	if (buffer_get_ecpoint_ret(buffer, curve, point) == -1)
		fatal("%s: buffer error", __func__);
}


@


1.3
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d1 2
a2 1
/* $OpenBSD: bufec.c,v 1.2 2013/05/17 00:13:13 djm Exp $ */
d4 1
a4 1
 * Copyright (c) 2010 Damien Miller <djm@@mindrot.org>
a17 1
#include <sys/types.h>
d19 1
a19 2
#include <openssl/bn.h>
#include <openssl/ec.h>
d21 1
a21 2
#include <string.h>
#include <stdarg.h>
a22 1
#include "xmalloc.h"
d25 1
a25 1
#include "misc.h"
a26 14
/*
 * Maximum supported EC GFp field length is 528 bits. SEC1 uncompressed
 * encoding represents this as two bitstring points that should each
 * be no longer than the field length, SEC1 specifies a 1 byte
 * point type header.
 * Being paranoid here may insulate us to parsing problems in
 * EC_POINT_oct2point.
 */
#define BUFFER_MAX_ECPOINT_LEN ((528*2 / 8) + 1)

/*
 * Append an EC_POINT to the buffer as a string containing a SEC1 encoded
 * uncompressed point. Fortunately OpenSSL handles the gory details for us.
 */
d31 5
a35 21
	u_char *buf = NULL;
	size_t len;
	BN_CTX *bnctx;
	int ret = -1;

	/* Determine length */
	if ((bnctx = BN_CTX_new()) == NULL)
		fatal("%s: BN_CTX_new failed", __func__);
	len = EC_POINT_point2oct(curve, point, POINT_CONVERSION_UNCOMPRESSED,
	    NULL, 0, bnctx);
	if (len > BUFFER_MAX_ECPOINT_LEN) {
		error("%s: giant EC point: len = %lu (max %u)",
		    __func__, (u_long)len, BUFFER_MAX_ECPOINT_LEN);
		goto out;
	}
	/* Convert */
	buf = xmalloc(len);
	if (EC_POINT_point2oct(curve, point, POINT_CONVERSION_UNCOMPRESSED,
	    buf, len, bnctx) != len) {
		error("%s: EC_POINT_point2oct length mismatch", __func__);
		goto out;
d37 1
a37 10
	/* Append */
	buffer_put_string(buffer, buf, len);
	ret = 0;
 out:
	if (buf != NULL) {
		explicit_bzero(buf, len);
		free(buf);
	}
	BN_CTX_free(bnctx);
	return ret;
d52 1
a52 4
	u_char *buf;
	u_int len;
	BN_CTX *bnctx;
	int ret = -1;
d54 2
a55 2
	if ((buf = buffer_get_string_ret(buffer, &len)) == NULL) {
		error("%s: invalid point", __func__);
d58 1
a58 28
	if ((bnctx = BN_CTX_new()) == NULL)
		fatal("%s: BN_CTX_new failed", __func__);
	if (len > BUFFER_MAX_ECPOINT_LEN) {
		error("%s: EC_POINT too long: %u > max %u", __func__,
		    len, BUFFER_MAX_ECPOINT_LEN);
		goto out;
	}
	if (len == 0) {
		error("%s: EC_POINT buffer is empty", __func__);
		goto out;
	}
	if (buf[0] != POINT_CONVERSION_UNCOMPRESSED) {
		error("%s: EC_POINT is in an incorrect form: "
		    "0x%02x (want 0x%02x)", __func__, buf[0],
		    POINT_CONVERSION_UNCOMPRESSED);
		goto out;
	}
	if (EC_POINT_oct2point(curve, point, buf, len, bnctx) != 1) {
		error("buffer_get_bignum2_ret: BN_bin2bn failed");
		goto out;
	}
	/* EC_POINT_oct2point verifies that the point is on the curve for us */
	ret = 0;
 out:
	BN_CTX_free(bnctx);
	explicit_bzero(buf, len);
	free(buf);
	return ret;
d68 1
@


1.2
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: bufec.c,v 1.1 2010/08/31 11:54:45 djm Exp $ */
d75 1
a75 1
		bzero(buf, len);
d128 1
a128 1
	bzero(buf, len);
@


1.1
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d76 1
a76 1
		xfree(buf);
d129 1
a129 1
	xfree(buf);
@

