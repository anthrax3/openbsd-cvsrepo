head	1.89;
access;
symbols
	OPENBSD_6_1:1.89.0.4
	OPENBSD_6_1_BASE:1.89
	OPENBSD_6_0:1.88.0.4
	OPENBSD_6_0_BASE:1.88
	OPENBSD_5_9:1.86.0.2
	OPENBSD_5_9_BASE:1.86
	OPENBSD_5_8:1.84.0.2
	OPENBSD_5_8_BASE:1.84
	OPENBSD_5_7:1.82.0.2
	OPENBSD_5_7_BASE:1.82
	OPENBSD_5_6:1.78.0.4
	OPENBSD_5_6_BASE:1.78
	OPENBSD_5_5:1.77.0.4
	OPENBSD_5_5_BASE:1.77
	OPENBSD_5_4:1.76.0.2
	OPENBSD_5_4_BASE:1.76
	OPENBSD_5_3:1.72.0.2
	OPENBSD_5_3_BASE:1.72
	OPENBSD_5_2:1.69.0.6
	OPENBSD_5_2_BASE:1.69
	OPENBSD_5_1_BASE:1.69
	OPENBSD_5_1:1.69.0.4
	OPENBSD_5_0:1.69.0.2
	OPENBSD_5_0_BASE:1.69
	OPENBSD_4_9:1.66.0.4
	OPENBSD_4_9_BASE:1.66
	OPENBSD_4_8:1.66.0.2
	OPENBSD_4_8_BASE:1.66
	OPENBSD_4_7:1.65.0.2
	OPENBSD_4_7_BASE:1.65
	OPENBSD_4_6:1.62.0.6
	OPENBSD_4_6_BASE:1.62
	OPENBSD_4_5:1.62.0.2
	OPENBSD_4_5_BASE:1.62
	OPENBSD_4_4:1.61.0.2
	OPENBSD_4_4_BASE:1.61
	OPENBSD_4_3:1.60.0.2
	OPENBSD_4_3_BASE:1.60
	OPENBSD_4_2:1.58.0.6
	OPENBSD_4_2_BASE:1.58
	OPENBSD_4_1:1.58.0.2
	OPENBSD_4_1_BASE:1.58
	OPENBSD_4_0:1.58.0.4
	OPENBSD_4_0_BASE:1.58
	OPENBSD_3_9:1.51.0.4
	OPENBSD_3_9_BASE:1.51
	OPENBSD_3_8:1.51.0.2
	OPENBSD_3_8_BASE:1.51
	OPENBSD_3_7:1.50.0.4
	OPENBSD_3_7_BASE:1.50
	OPENBSD_3_6:1.50.0.2
	OPENBSD_3_6_BASE:1.50
	OPENBSD_3_5:1.49.0.2
	OPENBSD_3_5_BASE:1.49
	OPENBSD_3_4:1.46.0.2
	OPENBSD_3_4_BASE:1.46
	OPENBSD_3_3:1.41.0.4
	OPENBSD_3_3_BASE:1.41
	OPENBSD_3_2:1.41.0.2
	OPENBSD_3_2_BASE:1.41
	OPENBSD_3_1:1.35.0.2
	OPENBSD_3_1_BASE:1.35
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.89
date	2016.08.13.17.47.41;	author markus;	state Exp;
branches;
next	1.88;
commitid	dl4RDERdJITM8DKC;

1.88
date	2016.05.04.14.04.40;	author markus;	state Exp;
branches;
next	1.87;
commitid	RZszKgjmOEiBs9kV;

1.87
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.86;
commitid	kr9hjdmg99uVnhW2;

1.86
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.85;
commitid	K3glY441IowbrjDE;

1.85
date	2015.11.11.01.48.01;	author djm;	state Exp;
branches;
next	1.84;
commitid	4FA47ChE4xCQXTsd;

1.84
date	2015.05.08.06.41.56;	author djm;	state Exp;
branches;
next	1.83;
commitid	Ob3mgGRUPfNEjgKq;

1.83
date	2015.05.01.03.23.51;	author djm;	state Exp;
branches;
next	1.82;
commitid	weFq4BCuIOdeuIhV;

1.82
date	2015.02.16.22.13.32;	author djm;	state Exp;
branches;
next	1.81;
commitid	vWL0dluw4oITNbM8;

1.81
date	2015.01.26.06.10.03;	author djm;	state Exp;
branches;
next	1.80;
commitid	F603CYAZ9E536XCr;

1.80
date	2015.01.19.20.16.15;	author markus;	state Exp;
branches;
next	1.79;
commitid	U9l75XYAjMKaQ8Jp;

1.79
date	2014.12.22.07.51.30;	author djm;	state Exp;
branches;
next	1.78;
commitid	CoaZC6mJ1akW0s9F;

1.78
date	2014.07.03.11.16.55;	author djm;	state Exp;
branches;
next	1.77;
commitid	qUeYjXdfTNrKthSc;

1.77
date	2014.01.29.06.18.35;	author djm;	state Exp;
branches;
next	1.76;

1.76
date	2013.07.19.07.37.48;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2013.06.21.00.34.49;	author djm;	state Exp;
branches;
next	1.74;

1.74
date	2013.05.19.02.42.42;	author djm;	state Exp;
branches;
next	1.73;

1.73
date	2013.03.07.19.27.25;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2012.12.02.20.34.09;	author djm;	state Exp;
branches;
next	1.71;

1.71
date	2012.11.04.11.09.15;	author djm;	state Exp;
branches;
next	1.70;

1.70
date	2012.10.30.21.29.54;	author djm;	state Exp;
branches;
next	1.69;

1.69
date	2011.05.23.03.30.07;	author djm;	state Exp;
branches;
next	1.68;

1.68
date	2011.05.11.04.47.06;	author djm;	state Exp;
branches;
next	1.67;

1.67
date	2011.03.10.11.34.25;	author djm;	state Exp;
branches;
next	1.66;

1.66
date	2010.05.07.11.30.29;	author djm;	state Exp;
branches;
next	1.65;

1.65
date	2010.03.04.10.36.03;	author djm;	state Exp;
branches;
next	1.64;

1.64
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.63;

1.63
date	2009.08.15.18.56.34;	author fgsch;	state Exp;
branches;
next	1.62;

1.62
date	2008.11.04.08.22.12;	author djm;	state Exp;
branches;
next	1.61;

1.61
date	2008.07.02.12.03.51;	author dtucker;	state Exp;
branches;
next	1.60;

1.60
date	2007.09.21.08.15.29;	author djm;	state Exp;
branches;
next	1.59;

1.59
date	2007.08.23.03.06.10;	author djm;	state Exp;
branches;
next	1.58;

1.58
date	2006.08.18.09.15.20;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.55;

1.55
date	2006.07.23.01.11.05;	author stevesk;	state Exp;
branches;
next	1.54;

1.54
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.53;

1.53
date	2006.04.20.09.27.09;	author djm;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.25.22.22.42;	author djm;	state Exp;
branches;
next	1.51;

1.51
date	2005.06.06.11.20.36;	author djm;	state Exp;
branches
	1.51.2.1
	1.51.4.1;
next	1.50;

1.50
date	2004.05.23.23.59.53;	author dtucker;	state Exp;
branches
	1.50.2.1
	1.50.4.1;
next	1.49;

1.49
date	2004.01.30.09.48.57;	author markus;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2003.11.04.08.54.09;	author djm;	state Exp;
branches;
next	1.47;

1.47
date	2003.09.23.20.17.11;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2003.08.28.12.54.34;	author markus;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2003.08.26.09.58.43;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2003.08.22.10.56.08;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2003.07.22.13.35.22;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2003.04.16.14.35.27;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2002.09.26.11.38.43;	author markus;	state Exp;
branches
	1.41.2.1
	1.41.4.1;
next	1.40;

1.40
date	2002.09.09.06.48.06;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	2002.05.31.11.35.15;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2002.05.25.18.51.07;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2002.05.13.20.44.58;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.12.23.53.45;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.19.10.35.39;	author markus;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2002.03.18.17.50.31;	author provos;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.18.01.12.14;	author provos;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.17.20.25.56;	author provos;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.16.17.22.09;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.14.16.56.33;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.04.17.27.39;	author stevesk;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.17.19.42.32;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.16.21.27.53;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.27.19.54.53;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.18.10.04.21;	author jakob;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.09.18.45.56;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.26.17.27.22;	author markus;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.06.26.16.15.23;	author dugsong;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.26.06.32.47;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.25.17.54.49;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.23.00.20.58;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.20.17.20.35;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.18.14.13.28;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.12.19.15.24;	author markus;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.03.28.22.43.31;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.20.18.57.04;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.22.21.59.43;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.12.16.16.23;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.21.19.05.43;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.18.16.59.59;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.28.14.25.51;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.16.09.38.44;	author djm;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.10.11.20.14.38;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.07.20.27.49;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.09.01.21.15;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.26.21.28.32;	author markus;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.04.06.08.55.22;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.28.21.15.45;	author markus;	state Exp;
branches;
next	;

1.3.2.1
date	2000.09.01.18.23.17;	author jason;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2000.11.08.21.30.23;	author jason;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2001.03.12.15.44.07;	author jason;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2001.03.21.18.52.34;	author jason;	state Exp;
branches;
next	;

1.7.2.1
date	2001.02.16.20.12.53;	author jason;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.02.19.17.18.37;	author jason;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.03.21.19.46.22;	author jason;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2001.05.07.21.09.26;	author jason;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2002.03.08.17.04.41;	author brad;	state Exp;
branches;
next	;

1.15.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.03.09.00.20.43;	author miod;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.06.02.22.56.09;	author miod;	state Exp;
branches;
next	;

1.22.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2002.06.22.07.23.16;	author miod;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.35.2.1
date	2002.05.18.04.12.10;	author jason;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2002.05.18.04.50.37;	author jason;	state Exp;
branches;
next	1.35.2.3;

1.35.2.3
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	1.35.2.4;

1.35.2.4
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	;

1.41.2.1
date	2003.09.16.21.20.24;	author brad;	state Exp;
branches;
next	;

1.41.4.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.41.4.2;

1.41.4.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.46.2.1
date	2004.02.28.03.51.32;	author brad;	state Exp;
branches;
next	1.46.2.2;

1.46.2.2
date	2004.08.19.22.37.30;	author brad;	state Exp;
branches;
next	;

1.49.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	;

1.50.2.1
date	2005.09.02.03.44.59;	author brad;	state Exp;
branches;
next	;

1.50.4.1
date	2005.09.04.18.39.55;	author brad;	state Exp;
branches;
next	;

1.51.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.51.4.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.89
log
@remove ssh1 server code; ok djm@@
@
text
@/* $OpenBSD: auth.h,v 1.88 2016/05/04 14:04:40 markus Exp $ */

/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef AUTH_H
#define AUTH_H

#include <signal.h>

#include <openssl/rsa.h>

#include <bsd_auth.h>
#ifdef KRB5
#include <krb5.h>
#endif

struct ssh;
struct sshkey;

typedef struct Authctxt Authctxt;
typedef struct Authmethod Authmethod;
typedef struct KbdintDevice KbdintDevice;

struct Authctxt {
	sig_atomic_t	 success;
	int		 authenticated;	/* authenticated and alarms cancelled */
	int		 postponed;	/* authentication needs another step */
	int		 valid;		/* user exists and is allowed to login */
	int		 attempt;
	int		 failures;
	int		 server_caused_failure;
	int		 force_pwchange;
	char		*user;		/* username sent by the client */
	char		*service;
	struct passwd	*pw;		/* set if 'valid' */
	char		*style;
	void		*kbdintctxt;
	char		*info;		/* Extra info for next auth_log */
	auth_session_t	*as;
	char		**auth_methods;	/* modified from server config */
	u_int		 num_auth_methods;
#ifdef KRB5
	krb5_context	 krb5_ctx;
	krb5_ccache	 krb5_fwd_ccache;
	krb5_principal	 krb5_user;
	char		*krb5_ticket_file;
#endif
	void		*methoddata;

	struct sshkey	**prev_userkeys;
	u_int		 nprev_userkeys;
};
/*
 * Every authentication method has to handle authentication requests for
 * non-existing users, or for users that are not allowed to login. In this
 * case 'valid' is set to 0, but 'user' points to the username requested by
 * the client.
 */

struct Authmethod {
	char	*name;
	int	(*userauth)(Authctxt *authctxt);
	int	*enabled;
};

/*
 * Keyboard interactive device:
 * init_ctx	returns: non NULL upon success
 * query	returns: 0 - success, otherwise failure
 * respond	returns: 0 - success, 1 - need further interaction,
 *		otherwise - failure
 */
struct KbdintDevice
{
	const char *name;
	void*	(*init_ctx)(Authctxt*);
	int	(*query)(void *ctx, char **name, char **infotxt,
		    u_int *numprompts, char ***prompts, u_int **echo_on);
	int	(*respond)(void *ctx, u_int numresp, char **responses);
	void	(*free_ctx)(void *ctx);
};

int
auth_rhosts2(struct passwd *, const char *, const char *, const char *);

int      auth_password(Authctxt *, const char *);

int	 hostbased_key_allowed(struct passwd *, const char *, char *, Key *);
int	 user_key_allowed(struct passwd *, Key *, int);
void	 pubkey_auth_info(Authctxt *, const Key *, const char *, ...)
	    __attribute__((__format__ (printf, 3, 4)));
void	 auth2_record_userkey(Authctxt *, struct sshkey *);
int	 auth2_userkey_already_used(Authctxt *, struct sshkey *);

struct stat;
int	 auth_secure_path(const char *, struct stat *, const char *, uid_t,
    char *, size_t);

#ifdef KRB5
int	auth_krb5(Authctxt *authctxt, krb5_data *auth, char **client, krb5_data *);
int	auth_krb5_tgt(Authctxt *authctxt, krb5_data *tgt);
int	auth_krb5_password(Authctxt *authctxt, const char *password);
void	krb5_cleanup_proc(Authctxt *authctxt);
#endif /* KRB5 */

void	do_authentication2(Authctxt *);

void	auth_info(Authctxt *authctxt, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)))
	    __attribute__((__nonnull__ (2)));
void	auth_log(Authctxt *, int, int, const char *, const char *);
void	auth_maxtries_exceeded(Authctxt *) __attribute__((noreturn));
void	userauth_finish(Authctxt *, int, const char *, const char *);
int	auth_root_allowed(const char *);

char	*auth2_read_banner(void);
int	 auth2_methods_valid(const char *, int);
int	 auth2_update_methods_lists(Authctxt *, const char *, const char *);
int	 auth2_setup_methods_lists(Authctxt *);
int	 auth2_method_allowed(Authctxt *, const char *, const char *);

void	privsep_challenge_enable(void);

int	auth2_challenge(Authctxt *, char *);
void	auth2_challenge_stop(Authctxt *);
int	bsdauth_query(void *, char **, char **, u_int *, char ***, u_int **);
int	bsdauth_respond(void *, u_int, char **);

int	allowed_user(struct passwd *);
struct passwd * getpwnamallow(const char *user);

char	*expand_authorized_keys(const char *, struct passwd *pw);
char	*authorized_principals_file(struct passwd *);

FILE	*auth_openkeyfile(const char *, struct passwd *, int);
FILE	*auth_openprincipals(const char *, struct passwd *, int);
int	 auth_key_is_revoked(Key *);

const char	*auth_get_canonical_hostname(struct ssh *, int);

HostStatus
check_key_in_hostfiles(struct passwd *, Key *, const char *,
    const char *, const char *);

/* hostkey handling */
Key	*get_hostkey_by_index(int);
Key	*get_hostkey_public_by_index(int, struct ssh *);
Key	*get_hostkey_public_by_type(int, int, struct ssh *);
Key	*get_hostkey_private_by_type(int, int, struct ssh *);
int	 get_hostkey_index(Key *, int, struct ssh *);
int	 sshd_hostkey_sign(Key *, Key *, u_char **, size_t *,
	     const u_char *, size_t, const char *, u_int);

/* debug messages during authentication */
void	 auth_debug_add(const char *fmt,...) __attribute__((format(printf, 1, 2)));
void	 auth_debug_send(void);
void	 auth_debug_reset(void);

struct passwd *fakepw(void);

#endif
@


1.88
log
@missing const in prototypes (ssh1)
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.87 2016/03/07 19:02:43 djm Exp $ */
a105 1
int      auth_rhosts(struct passwd *, const char *);
a108 1
int	 auth_rhosts_rsa(Authctxt *, char *, Key *);
a109 5
int      auth_rsa(Authctxt *, BIGNUM *);
int      auth_rsa_challenge_dialog(Key *);
BIGNUM	*auth_rsa_generate_challenge(Key *);
int	 auth_rsa_verify_response(Key *, BIGNUM *, u_char[]);
int	 auth_rsa_key_allowed(struct passwd *, BIGNUM *, Key **);
a110 2
int	 auth_rhosts_rsa_key_allowed(struct passwd *, const char *,
    const char *, Key *);
a128 1
void	do_authentication(Authctxt *);
a154 3
char	*get_challenge(Authctxt *);
int	verify_response(Authctxt *, const char *);

a173 1
int	 ssh1_session_key(BIGNUM *);
@


1.87
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.86 2015/12/04 16:41:28 markus Exp $ */
d118 2
a119 1
int	 auth_rhosts_rsa_key_allowed(struct passwd *, char *, char *, Key *);
@


1.86
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.85 2015/11/11 01:48:01 djm Exp $ */
d173 2
@


1.85
log
@remove prototypes for long-gone s/key support; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.84 2015/05/08 06:41:56 djm Exp $ */
d186 1
a186 1
	     const u_char *, size_t, u_int);
@


1.84
log
@whitespace at EOL
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.83 2015/05/01 03:23:51 djm Exp $ */
a159 2
int	skey_query(void *, char **, char **, u_int *, char ***, u_int **);
int	skey_respond(void *, u_int, char **);
@


1.83
log
@prevent authorized_keys options picked up on public key tests without
a corresponding private key authentication being applied to other
authentication methods. Reported by halex@@, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.82 2015/02/16 22:13:32 djm Exp $ */
d54 1
a54 1
	int		 server_caused_failure; 
@


1.82
log
@Revise hostkeys@@openssh.com hostkey learning extension.

The client will not ask the server to prove ownership of the private
halves of any hitherto-unseen hostkeys it offers to the client.

Allow UpdateHostKeys option to take an 'ask' argument to let the
user manually review keys offered.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.81 2015/01/26 06:10:03 djm Exp $ */
d120 1
a120 1
int	 user_key_allowed(struct passwd *, Key *);
@


1.81
log
@correctly match ECDSA subtype (== curve) for offered/recevied
host keys. Fixes connection-killing host key mismatches when
a server offers multiple ECDSA keys with different curve type
(an extremely unlikely configuration).

ok markus, "looks mechanical" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.80 2015/01/19 20:16:15 markus Exp $ */
d185 1
a185 1
int	 get_hostkey_index(Key *, struct ssh *);
d187 2
a188 1
int	 sshd_hostkey_sign(Key *, Key *, u_char **, size_t *, u_char *, size_t, u_int);
@


1.80
log
@adapt kex to sshbuf and struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.79 2014/12/22 07:51:30 djm Exp $ */
d183 2
a184 2
Key	*get_hostkey_public_by_type(int, struct ssh *);
Key	*get_hostkey_private_by_type(int, struct ssh *);
@


1.79
log
@remember which public keys have been used for authentication and
refuse to accept previously-used keys.

This allows AuthenticationMethods=publickey,publickey to require
that users authenticate using two _different_ pubkeys.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.78 2014/07/03 11:16:55 djm Exp $ */
d40 1
d182 4
a185 4
Key	*get_hostkey_public_by_index(int);
Key	*get_hostkey_public_by_type(int);
Key	*get_hostkey_private_by_type(int);
int	 get_hostkey_index(Key *);
d187 1
a187 1
void	 sshd_hostkey_sign(Key *, Key *, u_char **, u_int *, u_char *, u_int);
@


1.78
log
@make the "Too many authentication failures" message include the
user, source address, port and protocol in a format similar to the
authentication success / failure messages; bz#2199, ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.77 2014/01/29 06:18:35 djm Exp $ */
d40 2
d71 3
d122 2
@


1.77
log
@remove experimental, never-enabled JPAKE code; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.76 2013/07/19 07:37:48 markus Exp $ */
d136 1
a186 2

#define AUTH_FAIL_MSG "Too many authentication failures for %.100s"
@


1.76
log
@add ssh-agent(1) support to sshd(8); allows encrypted hostkeys,
or hostkeys on smartcards; most of the work by Zev Weiss; bz #1974
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.75 2013/06/21 00:34:49 djm Exp $ */
a58 1
	void		*jpake_ctx;
a152 3

void	auth2_jpake_get_pwdata(Authctxt *, BIGNUM **, char **, char **);
void	auth2_jpake_stop(Authctxt *);
@


1.75
log
@for hostbased authentication, print the client host and user on
the auth success/failure line; bz#2064, ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.74 2013/05/19 02:42:42 djm Exp $ */
d177 1
d182 1
@


1.74
log
@Standardise logging of supplemental information during userauth. Keys
and ruser is now logged in the auth success/failure message alongside
the local username, remote host/port and protocol in use. Certificates
contents and CA are logged too.

Pushing all logging onto a single line simplifies log analysis as it is
no longer necessary to relate information scattered across multiple log
entries. "I like it" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.73 2013/03/07 19:27:25 markus Exp $ */
d116 2
a117 1
void	 pubkey_auth_info(Authctxt *, const Key *);
@


1.73
log
@add submethod support to AuthenticationMethods; ok and freedback djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.72 2012/12/02 20:34:09 djm Exp $ */
d58 1
d116 1
d132 4
a135 2
void	auth_log(Authctxt *, int, int, const char *, const char *,
    const char *);
@


1.72
log
@Fixes logging of partial authentication when privsep is enabled
Previously, we recorded "Failed xxx" since we reset authenticated before
calling auth_log() in auth2.c. This adds an explcit "Partial" state.

Add a "submethod" to auth_log() to report which submethod is used
for keyboard-interactive.

Fix multiple authentication when one of the methods is
keyboard-interactive.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.71 2012/11/04 11:09:15 djm Exp $ */
d137 1
a137 1
int	 auth2_update_methods_lists(Authctxt *, const char *);
d139 1
@


1.71
log
@Support multiple required authentication via an AuthenticationMethods
option. This option lists one or more comma-separated lists of
authentication method names. Successful completion of all the methods in
any list is required for authentication to complete;
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.70 2012/10/30 21:29:54 djm Exp $ */
d130 4
a133 3
void	auth_log(Authctxt *, int, char *, char *);
void	userauth_finish(Authctxt *, int, char *);
int	auth_root_allowed(char *);
@


1.70
log
@new sshd_config option AuthorizedKeysCommand to support fetching
authorized_keys from a command in addition to (or instead of) from
the filesystem. The command is run as the target server user unless
another specified via a new AuthorizedKeysCommandUser option.

patch originally by jchadima AT redhat.com, reworked by me; feedback
and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.69 2011/05/23 03:30:07 djm Exp $ */
d60 2
d135 3
@


1.69
log
@allow AuthorizedKeysFile to specify multiple files, separated by spaces.
Bring back authorized_keys2 as a default search path (to avoid breaking
existing users of this file), but override this in sshd_config so it will
be no longer used on fresh installs. Maybe in 2015 we can remove it
entierly :)

feedback and ok markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.68 2011/05/11 04:47:06 djm Exp $ */
d113 4
@


1.68
log
@remove support for authorized_keys2; it is a relic from the early days
of protocol v.2 support and has been undocumented for many years;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.67 2011/03/10 11:34:25 djm Exp $ */
d148 1
a148 1
char	*authorized_keys_file(struct passwd *);
@


1.67
log
@allow GSSAPI authentication to detect when a server-side failure causes
authentication failure and don't count such failures against MaxAuthTries;
bz#1244 from simon AT sxw.org.uk; ok markus@@ before lock
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.66 2010/05/07 11:30:29 djm Exp $ */
a148 1
char	*authorized_keys_file2(struct passwd *);
@


1.66
log
@add some optional indirection to matching of principal names listed
in certificates. Currently, a certificate must include the a user's name
to be accepted for authentication. This change adds the ability to
specify a list of certificate principal names that are acceptable.

When authenticating using a CA trusted through ~/.ssh/authorized_keys,
this adds a new principals="name1[,name2,...]" key option.

For CAs listed through sshd_config's TrustedCAKeys option, a new config
option "AuthorizedPrincipalsFile" specifies a per-user file containing
the list of acceptable names.

If either option is absent, the current behaviour of requiring the
username to appear in principals continues to apply.

These options are useful for role accounts, disjoint account namespaces
and "user@@realm"-style naming policies in certificates.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.65 2010/03/04 10:36:03 djm Exp $ */
d51 1
@


1.65
log
@Add a TrustedUserCAKeys option to sshd_config to specify CA keys that
are trusted to authenticate users (in addition than doing it per-user
in authorized_keys).

Add a RevokedKeys option to sshd_config and a @@revoked marker to
known_hosts to allow keys to me revoked and banned for user or host
authentication.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.64 2010/02/26 20:29:54 djm Exp $ */
d149 1
d152 1
@


1.64
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.63 2009/08/15 18:56:34 fgsch Exp $ */
d151 1
@


1.63
log
@remove unused define. markus@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.62 2008/11/04 08:22:12 djm Exp $ */
d158 2
a159 1
Key	*get_hostkey_by_type(int);
@


1.62
log
@Add support for an experimental zero-knowledge password authentication
method using the J-PAKE protocol described in F. Hao, P. Ryan,
"Password Authenticated Key Exchange by Juggling", 16th Workshop on
Security Protocols, Cambridge, April 2008.

This method allows password-based authentication without exposing
the password to the server. Instead, the client and server exchange
cryptographic proofs to demonstrate of knowledge of the password while
revealing nothing useful to an attacker or compromised endpoint.

This is experimental, work-in-progress code and is presently
compiled-time disabled (turn on -DJPAKE in Makefile.inc).

"just commit it.  It isn't too intrusive." deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.61 2008/07/02 12:03:51 dtucker Exp $ */
a170 1
#define SKEY_PROMPT "\nS/Key Password: "
@


1.61
log
@Merge duplicate host key file checks, based in part on a patch from Rob
Holland via bz #1348 .  Also checks for non-regular files during protocol
1 RSA auth.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.60 2007/09/21 08:15:29 djm Exp $ */
d57 1
d137 3
@


1.60
log
@unifdef -DBSD_AUTH
unifdef -USKEY

These options have been in use for some years;
ok markus@@ "no objection" millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.59 2007/08/23 03:06:10 djm Exp $ */
d146 1
a146 2
int
secure_filename(FILE *, const char *, struct passwd *, char *, size_t);
@


1.59
log
@login_cap.h doesn't belong here
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.58 2006/08/18 09:15:20 markus Exp $ */
a34 1
#ifdef BSD_AUTH
a35 1
#endif
a56 1
#ifdef BSD_AUTH
a57 1
#endif
@


1.58
log
@delay authentication related cleanups until we're authenticated and
all alarms have been cancelled; ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.57 2006/08/03 03:34:41 deraadt Exp $ */
a34 3
#ifdef HAVE_LOGIN_CAP
#include <login_cap.h>
#endif
@


1.57
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.56 2006/08/01 23:22:47 stevesk Exp $ */
d51 1
@


1.56
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.55 2006/07/23 01:11:05 stevesk Exp $ */
d31 1
a31 1
#include <sys/types.h>
a34 4
#include <pwd.h>
#include <signal.h>
#include <stdio.h>

a43 3

#include "key.h"
#include "hostfile.h"
@


1.55
log
@#include <signal.h> for sig_atomic_t; need this prior to <sys/param.h>
move
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.54 2006/07/06 16:03:53 stevesk Exp $ */
d37 1
@


1.54
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.53 2006/04/20 09:27:09 djm Exp $ */
d36 1
@


1.53
log
@replace the last non-sig_atomic_t flag used in a signal handler with a
sig_atomic_t, unfortunately with some knock-on effects in other (non-
signal) contexts in which it is used; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.52 2006/03/25 22:22:42 djm Exp $ */
d31 2
a32 2
#include "key.h"
#include "hostfile.h"
d35 2
d46 3
@


1.52
log
@standardise spacing in $OpenBSD$ tags; requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.51 2005/06/06 11:20:36 djm Exp $ */
d50 1
a50 1
	int		 success;
@


1.51
log
@introduce a generic %foo expansion function. replace existing % expansion and
add expansion to ControlPath; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.50 2004/05/23 23:59:53 dtucker Exp $	*/
@


1.51.2.1
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.58 2006/08/18 09:15:20 markus Exp $ */
d31 2
a32 2
#include <signal.h>

d50 1
a50 2
	sig_atomic_t	 success;
	int		 authenticated;	/* authenticated and alarms cancelled */
@


1.51.4.1
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: auth.h,v 1.58 2006/08/18 09:15:20 markus Exp $ */
d31 2
a32 2
#include <signal.h>

d50 1
a50 2
	sig_atomic_t	 success;
	int		 authenticated;	/* authenticated and alarms cancelled */
@


1.50
log
@Add MaxAuthTries sshd config option; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.49 2004/01/30 09:48:57 markus Exp $	*/
a148 1
char	*expand_filename(const char *, struct passwd *);
@


1.50.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.51 2005/06/06 11:20:36 djm Exp $	*/
d149 1
@


1.50.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.51 2005/06/06 11:20:36 djm Exp $	*/
d149 1
@


1.49
log
@support for password change; ok dtucker@@
(set password-dead=1w in login.conf to use this).
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.48 2003/11/04 08:54:09 djm Exp $	*/
a172 2
#define AUTH_FAIL_MAX 6
#define AUTH_FAIL_LOG (AUTH_FAIL_MAX/2)
@


1.49.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.50 2004/05/23 23:59:53 dtucker Exp $	*/
d173 2
@


1.48
log
@standardise arguments to auth methods - they should all take authctxt.
check authctxt->valid rather then pw != NULL; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.47 2003/09/23 20:17:11 markus Exp $	*/
d55 1
@


1.47
log
@replace fatal_cleanup() and linked list of fatal callbacks with static
cleanup_exit() function.  re-refine cleanup_exit() where appropriate,
allocate sshd's authctxt eary to allow simpler cleanup in sshd.
tested by many, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.46 2003/08/28 12:54:34 markus Exp $	*/
d105 1
a105 1
int	 auth_rhosts_rsa(struct passwd *, char *, Key *);
d107 1
a107 1
int      auth_rsa(struct passwd *, BIGNUM *);
@


1.46
log
@remove kerberos support from ssh1, since it has been replaced with GSSAPI;
but keep kerberos passwd auth for ssh1 and 2; ok djm, hin, henning, ...
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.45 2003/08/26 09:58:43 markus Exp $	*/
d121 1
a121 1
void	krb5_cleanup_proc(void *authctxt);
d124 2
a125 2
Authctxt *do_authentication(void);
Authctxt *do_authentication2(void);
a126 1
Authctxt *authctxt_new(void);
a146 2

struct passwd * auth_get_user(void);
@


1.46.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.49 2004/01/30 09:48:57 markus Exp $	*/
a54 1
	int		 force_pwchange;
d105 1
a105 1
int	 auth_rhosts_rsa(Authctxt *, char *, Key *);
d107 1
a107 1
int      auth_rsa(Authctxt *, BIGNUM *);
d121 1
a121 1
void	krb5_cleanup_proc(Authctxt *authctxt);
d124 2
a125 2
void	do_authentication(Authctxt *);
void	do_authentication2(Authctxt *);
d127 1
d148 2
@


1.46.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.50 2004/05/23 23:59:53 dtucker Exp $	*/
d173 2
@


1.45
log
@fix passwd auth for 'username leaks via timing'; with djm@@, original patches from solar
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.44 2003/08/22 10:56:08 markus Exp $	*/
a64 1
	krb5_auth_context krb5_auth_ctx;
@


1.44
log
@support GSS API user authentication; patches from Simon Wilkinson,
stripped down and tested by Jakob and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.43 2003/07/22 13:35:22 markus Exp $	*/
d173 2
@


1.43
log
@remove (already disabled) KRB4/AFS support, re-enable -k in ssh(1);
test+ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.42 2003/04/16 14:35:27 markus Exp $	*/
d70 1
@


1.42
log
@document struct Authctxt; with solar
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.41 2002/09/26 11:38:43 markus Exp $	*/
a62 3
#ifdef KRB4
	char		*krb4_ticket_file;
#endif
a115 14

#ifdef KRB4
#include <krb.h>
int     auth_krb4(Authctxt *, KTEXT, char **, KTEXT);
int	auth_krb4_password(Authctxt *, const char *);
void    krb4_cleanup_proc(void *);

#ifdef AFS
#include <kafs.h>
int     auth_krb4_tgt(Authctxt *, const char *);
int     auth_afs_token(Authctxt *, const char *);
#endif /* AFS */

#endif /* KRB4 */
@


1.41
log
@krb4 + privsep; ok dugsong@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.40 2002/09/09 06:48:06 itojun Exp $	*/
d51 2
a52 2
	int		 postponed;
	int		 valid;
d55 1
a55 1
	char		*user;
d57 1
a57 1
	struct passwd	*pw;
d74 6
@


1.41.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.46 2003/08/28 12:54:34 markus Exp $	*/
d51 2
a52 2
	int		 postponed;	/* authentication needs another step */
	int		 valid;		/* user exists and is allowed to login */
d55 1
a55 1
	char		*user;		/* username sent by the client */
d57 1
a57 1
	struct passwd	*pw;		/* set if 'valid' */
d63 3
d68 1
a72 1
	void		*methoddata;
a73 6
/*
 * Every authentication method has to handle authentication requests for
 * non-existing users, or for users that are not allowed to login. In this
 * case 'valid' is set to 0, but 'user' points to the username requested by
 * the client.
 */
d114 14
a182 2

struct passwd *fakepw(void);
@


1.41.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.46 2003/08/28 12:54:34 markus Exp $	*/
d51 2
a52 2
	int		 postponed;	/* authentication needs another step */
	int		 valid;		/* user exists and is allowed to login */
d55 1
a55 1
	char		*user;		/* username sent by the client */
d57 1
a57 1
	struct passwd	*pw;		/* set if 'valid' */
d63 3
d68 1
a72 1
	void		*methoddata;
a73 6
/*
 * Every authentication method has to handle authentication requests for
 * non-existing users, or for users that are not allowed to login. In this
 * case 'valid' is set to 0, but 'user' points to the username requested by
 * the client.
 */
d114 14
a182 2

struct passwd *fakepw(void);
@


1.41.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.49 2004/01/30 09:48:57 markus Exp $	*/
a54 1
	int		 force_pwchange;
d105 1
a105 1
int	 auth_rhosts_rsa(Authctxt *, char *, Key *);
d107 1
a107 1
int      auth_rsa(Authctxt *, BIGNUM *);
d121 1
a121 1
void	krb5_cleanup_proc(Authctxt *authctxt);
d124 2
a125 2
void	do_authentication(Authctxt *);
void	do_authentication2(Authctxt *);
d127 1
d148 2
@


1.40
log
@kerberos support for privsep.  confirmed to work by lha@@stacken.kth.se
patch from markus
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.39 2002/05/31 11:35:15 markus Exp $	*/
d116 1
a116 1
int     auth_krb4(Authctxt *, KTEXT, char **);
@


1.39
log
@move Authmethod definitons to per-method file.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.38 2002/05/25 18:51:07 markus Exp $	*/
d129 1
a129 1
int	auth_krb5(Authctxt *authctxt, krb5_data *auth, char **client);
@


1.38
log
@split auth2.c into one file per method; ok provos@@/deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.37 2002/05/13 20:44:58 markus Exp $	*/
d46 1
d75 6
a108 7

/* ssh2 methods */
int	 userauth_none(Authctxt *);
int	 userauth_passwd(Authctxt *);
int	 userauth_pubkey(Authctxt *);
int	 userauth_hostbased(Authctxt *);
int	 userauth_kbdint(Authctxt *);
@


1.37
log
@move the packet_send_debug handling from auth-options.c to auth.c; ok provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.36 2002/05/12 23:53:45 djm Exp $	*/
d102 7
@


1.36
log
@Fix sshd Banner option for privsep; ok markus@@ provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.35 2002/03/19 10:35:39 markus Exp $	*/
d171 5
@


1.35
log
@clean up prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.34 2002/03/18 17:50:31 provos Exp $	*/
d135 2
@


1.35.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.37 2002/05/13 20:44:58 markus Exp $	*/
a135 2
char	*auth2_read_banner(void);

a168 5

/* debug messages during authentication */
void	 auth_debug_add(const char *fmt,...) __attribute__((format(printf, 1, 2)));
void	 auth_debug_send(void);
void	 auth_debug_reset(void);
@


1.35.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.35.2.3
log
@Pull in OpenSSH-3.4
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.39 2002/05/31 11:35:15 markus Exp $	*/
a45 1
typedef struct Authmethod Authmethod;
a71 6
};

struct Authmethod {
	char	*name;
	int	(*userauth)(Authctxt *authctxt);
	int	*enabled;
@


1.35.2.4
log
@Update to OpenSSH 3.5
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.41 2002/09/26 11:38:43 markus Exp $	*/
d116 1
a116 1
int     auth_krb4(Authctxt *, KTEXT, char **, KTEXT);
d129 1
a129 1
int	auth_krb5(Authctxt *authctxt, krb5_data *auth, char **client, krb5_data *);
@


1.34
log
@integrate privilege separated openssh; its turned off by default for now.
work done by me and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.29 2002/03/04 17:27:39 stevesk Exp $	*/
d91 1
a91 1
int     auth_rhosts(struct passwd *, const char *);
d99 7
d140 4
d163 6
@


1.33
log
@have the authentication functions return the authentication context
and then do_authenticated; okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.32 2002/03/17 20:25:56 provos Exp $	*/
d129 2
d157 1
@


1.32
log
@getpwnamallow returns struct passwd * only if user valid; okay markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.31 2002/03/16 17:22:09 markus Exp $	*/
d121 2
a122 2
void	do_authentication(void);
void	do_authentication2(void);
@


1.31
log
@split auth_rhosts_rsa(), ok provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.30 2002/03/14 16:56:33 markus Exp $	*/
d133 1
@


1.30
log
@split auth_rsa() for better readability and privsep; ok provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.29 2002/03/04 17:27:39 stevesk Exp $	*/
d95 1
a95 1
int	 auth_rhosts_rsa(struct passwd *, const char *, Key *);
@


1.29
log
@$OpenBSD$ and RCSID() cleanup: don't use RCSID() in .h files; add
missing RCSID() to .c files and remove dup /*$OpenBSD$*/ from .c
files.  ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.28 2002/02/17 19:42:32 millert Exp $	*/
d98 1
a98 1
int      auth_rsa_challenge_dialog(RSA *);
@


1.28
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 2
a25 1
 * $OpenBSD: auth.h,v 1.27 2002/02/16 21:27:53 millert Exp $
d27 1
@


1.27
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.26 2001/12/27 19:54:53 markus Exp $
d83 2
a84 3
	int	(*query)	__P((void *ctx, char **name, char **infotxt,
				u_int *numprompts, char ***prompts,
				u_int **echo_on));
@


1.26
log
@auth_rhosts_rsa now accept generic keys.
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.25 2001/12/19 07:18:56 deraadt Exp $
d82 1
a82 1
	void*	(*init_ctx)	__P((Authctxt*));
d86 2
a87 2
	int	(*respond)	__P((void *ctx, u_int numresp, char **responses));
	void	(*free_ctx)	__P((void *ctx));
@


1.25
log
@basic KNF done while i was looking for something else
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.24 2001/12/18 10:04:21 jakob Exp $
d94 1
a94 1
int	 auth_rhosts_rsa(struct passwd *, const char *, RSA *);
@


1.24
log
@remove auth_rsa_read_key, make hostfile_ready_key non static; ok markus@@
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.23 2001/12/09 18:45:56 markus Exp $
d74 2
a75 2
 * init_ctx	returns: non NULL upon success 
 * query	returns: 0 - success, otherwise failure 
@


1.23
log
@add auth2_challenge_stop(), simplifies cleanup of kbd-int sessions,
fixes memleak.
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.22 2001/06/26 17:27:22 markus Exp $
a96 1
int      auth_rsa_read_key(char **, u_int *, BIGNUM *, BIGNUM *);
@


1.22
log
@remove comments from .h, since they are cut&paste from the .c files
and out of sync
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.21 2001/06/26 16:15:23 dugsong Exp $
d130 1
@


1.22.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@a0 2
/*	$OpenBSD: auth.h,v 1.29 2002/03/04 17:27:39 stevesk Exp $	*/

d24 1
a25 1

d74 2
a75 2
 * init_ctx	returns: non NULL upon success
 * query	returns: 0 - success, otherwise failure
d82 6
a87 5
	void*	(*init_ctx)(Authctxt*);
	int	(*query)(void *ctx, char **name, char **infotxt,
		    u_int *numprompts, char ***prompts, u_int **echo_on);
	int	(*respond)(void *ctx, u_int numresp, char **responses);
	void	(*free_ctx)(void *ctx);
d94 1
a94 1
int	 auth_rhosts_rsa(struct passwd *, const char *, Key *);
d97 1
a129 1
void	auth2_challenge_stop(Authctxt *);
@


1.22.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.37 2002/05/13 20:44:58 markus Exp $	*/
d91 1
a91 1
int      auth_rhosts(struct passwd *, const char *);
d95 1
a95 1
int	 auth_rhosts_rsa(struct passwd *, char *, Key *);
d98 1
a98 8
int      auth_rsa_challenge_dialog(Key *);
BIGNUM	*auth_rsa_generate_challenge(Key *);
int	 auth_rsa_verify_response(Key *, BIGNUM *, u_char[]);
int	 auth_rsa_key_allowed(struct passwd *, BIGNUM *, Key **);

int	 auth_rhosts_rsa_key_allowed(struct passwd *, char *, char *, Key *);
int	 hostbased_key_allowed(struct passwd *, const char *, char *, Key *);
int	 user_key_allowed(struct passwd *, Key *);
d121 2
a122 2
Authctxt *do_authentication(void);
Authctxt *do_authentication2(void);
a128 4
char	*auth2_read_banner(void);

void	privsep_challenge_enable(void);

a130 4
int	bsdauth_query(void *, char **, char **, u_int *, char ***, u_int **);
int	bsdauth_respond(void *, u_int, char **);
int	skey_query(void *, char **, char **, u_int *, char ***, u_int **);
int	skey_respond(void *, u_int, char **);
a132 1
struct passwd * getpwnamallow(const char *user);
a149 11
/* hostkey handling */
Key	*get_hostkey_by_index(int);
Key	*get_hostkey_by_type(int);
int	 get_hostkey_index(Key *);
int	 ssh1_session_key(BIGNUM *);

/* debug messages during authentication */
void	 auth_debug_add(const char *fmt,...) __attribute__((format(printf, 1, 2)));
void	 auth_debug_send(void);
void	 auth_debug_reset(void);

a153 1
#define SKEY_PROMPT "\nS/Key Password: "
@


1.22.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.22.2.2 2002/05/17 00:03:23 miod Exp $	*/
a45 1
typedef struct Authmethod Authmethod;
a71 6
};

struct Authmethod {
	char	*name;
	int	(*userauth)(Authctxt *authctxt);
	int	*enabled;
@


1.22.2.4
log
@Update to OpenSSH 3.5
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.41 2002/09/26 11:38:43 markus Exp $	*/
d116 1
a116 1
int     auth_krb4(Authctxt *, KTEXT, char **, KTEXT);
d129 1
a129 1
int	auth_krb5(Authctxt *authctxt, krb5_data *auth, char **client, krb5_data *);
@


1.21
log
@Kerberos v5 support for SSH1, mostly from Assar Westerlund <assar@@freebsd.org> and Bjorn Gronvall <bg@@sics.se>. markus@@ ok
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.20 2001/06/26 06:32:47 itojun Exp $
a89 5
/*
 * Tries to authenticate the user using the .rhosts file.  Returns true if
 * authentication succeeds.  If ignore_rhosts is non-zero, this will not
 * consider .rhosts and .shosts (/etc/hosts.equiv will still be used).
 */
a90 2

/* extended interface similar to auth_rhosts() */
d94 5
a98 32
/*
 * Tries to authenticate the user using the .rhosts file and the host using
 * its host key.  Returns true if authentication succeeds.
 */
int
auth_rhosts_rsa(struct passwd *, const char *, RSA *);

/*
 * Tries to authenticate the user using password.  Returns true if
 * authentication succeeds.
 */
int     auth_password(Authctxt *, const char *);

/*
 * Performs the RSA authentication dialog with the client.  This returns 0 if
 * the client could not be authenticated, and 1 if authentication was
 * successful.  This may exit if there is a serious protocol violation.
 */
int     auth_rsa(struct passwd *, BIGNUM *);

/*
 * Parses an RSA key (number of bits, e, n) from a string.  Moves the pointer
 * over the key.  Skips any whitespace at the beginning and at end.
 */
int     auth_rsa_read_key(char **, u_int *, BIGNUM *, BIGNUM *);

/*
 * Performs the RSA authentication challenge-response dialog with the client,
 * and returns true (non-zero) if the client gave the correct answer to our
 * challenge; returns zero if the client gives a wrong answer.
 */
int     auth_rsa_challenge_dialog(RSA *);
a101 5
/*
 * Performs Kerberos v4 mutual authentication with the client. This returns 0
 * if the client could not be authenticated, and 1 if authentication was
 * successful.  This may exit if there is a serious protocol violation.
 */
a107 2

/* Accept passed Kerberos v4 ticket-granting ticket and AFS tokens. */
d110 1
a110 1
#endif				/* AFS */
d112 1
a112 1
#endif				/* KRB4 */
a137 1
/* expand a filename - return buffer is allocated by xmalloc */
a141 1
/* check a file and the path to it */
a144 1
/* helper for hostbased auth */
@


1.20
log
@prototype pedant.  not very creative...
- () -> (void)
- no variable names
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.19 2001/06/25 17:54:49 provos Exp $
d39 3
d47 10
a56 10
	int success;
	int postponed;
	int valid;
	int attempt;
	int failures;
	char *user;
	char *service;
	struct passwd *pw;
	char *style;
	void *kbdintctxt;
d58 11
a68 1
	auth_session_t *as;
d141 2
a142 2
int     auth_krb4(const char *, KTEXT, char **);
int     krb4_init(uid_t);
a143 1
int	auth_krb4_password(struct passwd *, const char *);
d149 2
a150 2
int     auth_kerberos_tgt(struct passwd *, const char *);
int     auth_afs_token(struct passwd *, const char *);
d154 7
@


1.19
log
@terminate secure_filename checking after checking homedir.  that way it
works on AFS.  okay markus@@
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.18 2001/06/23 00:20:58 markus Exp $
d82 1
a82 1
int     auth_rhosts(struct passwd * pw, const char *client_user);
d86 1
a86 2
auth_rhosts2(struct passwd *pw, const char *client_user, const char *hostname,
    const char *ipaddr);
d93 1
a93 1
auth_rhosts_rsa(struct passwd * pw, const char *client_user, RSA* client_host_key);
d99 1
a99 1
int     auth_password(Authctxt *authctxt, const char *password);
d106 1
a106 1
int     auth_rsa(struct passwd * pw, BIGNUM * client_n);
d112 1
a112 1
int     auth_rsa_read_key(char **cpp, u_int *bitsp, BIGNUM * e, BIGNUM * n);
d119 1
a119 1
int     auth_rsa_challenge_dialog(RSA *pk);
d128 4
a131 4
int     auth_krb4(const char *server_user, KTEXT auth, char **client);
int     krb4_init(uid_t uid);
void    krb4_cleanup_proc(void *ignore);
int	auth_krb4_password(struct passwd * pw, const char *password);
d137 2
a138 2
int     auth_kerberos_tgt(struct passwd * pw, const char *string);
int     auth_afs_token(struct passwd * pw, const char *token_string);
d147 3
a149 3
void	auth_log(Authctxt *authctxt, int authenticated, char *method, char *info);
void	userauth_finish(Authctxt *authctxt, int authenticated, char *method);
int	auth_root_allowed(char *method);
d151 1
a151 1
int	auth2_challenge(Authctxt *authctxt, char *devs);
d153 1
a153 1
int	allowed_user(struct passwd * pw);
d155 2
a156 2
char	*get_challenge(Authctxt *authctxt);
int	verify_response(Authctxt *authctxt, const char *response);
d161 3
a163 3
char	*expand_filename(const char *template, struct passwd *pw);
char	*authorized_keys_file(struct passwd *pw);
char	*authorized_keys_file2(struct passwd *pw);
d167 1
a167 2
secure_filename(FILE *f, const char *file, struct passwd *pw,
    char *err, size_t errlen);
d171 2
a172 2
check_key_in_hostfiles(struct passwd *pw, Key *key, const char *host,
    const char *sysfile, const char *userfile);
@


1.18
log
@*known_hosts2 is obsolete for hostbased authentication and
only used for backward compat. merge ssh1/2 hostkey check
and move it to auth.c
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.17 2001/05/20 17:20:35 markus Exp $
d168 2
a169 1
secure_filename(FILE *f, const char *file, uid_t u, char *err, size_t errlen);
@


1.17
log
@configurable authorized_keys{,2} location; originally from peter@@; ok djm@@
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.16 2001/05/18 14:13:28 markus Exp $
d29 2
a160 1

d169 5
@


1.16
log
@improved kbd-interactive support. work by per@@appgate.com and me
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.15 2001/04/12 19:15:24 markus Exp $
d158 10
@


1.15
log
@implement HostbasedAuthentication (= RhostRSAAuthentication for ssh v2)
similar to RhostRSAAuthentication unless you enable (the experimental)
HostbasedUsesNameFromPacketOnly option.  please test. :)
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.14 2001/03/28 22:43:31 markus Exp $
d39 2
d51 1
d58 18
d154 2
a155 2
char	*get_challenge(Authctxt *authctxt, char *devs);
int	verify_response(Authctxt *authctxt, char *response);
@


1.15.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.22 2001/06/26 17:27:22 markus Exp $
a28 2
#include "key.h"
#include "hostfile.h"
a36 3
#ifdef KRB5
#include <krb5.h>
#endif
a38 2
typedef struct KbdintDevice KbdintDevice;

d40 9
a48 10
	int		 success;
	int		 postponed;
	int		 valid;
	int		 attempt;
	int		 failures;
	char		*user;
	char		*service;
	struct passwd	*pw;
	char		*style;
	void		*kbdintctxt;
d50 1
a50 11
	auth_session_t	*as;
#endif
#ifdef KRB4
	char		*krb4_ticket_file;
#endif
#ifdef KRB5
	krb5_context	 krb5_ctx;
	krb5_auth_context krb5_auth_ctx;
	krb5_ccache	 krb5_fwd_ccache;
	krb5_principal	 krb5_user;
	char		*krb5_ticket_file;
d55 10
a64 16
 * Keyboard interactive device:
 * init_ctx	returns: non NULL upon success 
 * query	returns: 0 - success, otherwise failure 
 * respond	returns: 0 - success, 1 - need further interaction,
 *		otherwise - failure
 */
struct KbdintDevice
{
	const char *name;
	void*	(*init_ctx)	__P((Authctxt*));
	int	(*query)	__P((void *ctx, char **name, char **infotxt,
				u_int *numprompts, char ***prompts,
				u_int **echo_on));
	int	(*respond)	__P((void *ctx, u_int numresp, char **responses));
	void	(*free_ctx)	__P((void *ctx));
};
d66 4
a69 1
int     auth_rhosts(struct passwd *, const char *);
d71 20
a90 1
auth_rhosts2(struct passwd *, const char *, const char *, const char *);
d92 6
a97 5
int	 auth_rhosts_rsa(struct passwd *, const char *, RSA *);
int      auth_password(Authctxt *, const char *);
int      auth_rsa(struct passwd *, BIGNUM *);
int      auth_rsa_read_key(char **, u_int *, BIGNUM *, BIGNUM *);
int      auth_rsa_challenge_dialog(RSA *);
d101 9
a109 3
int     auth_krb4(Authctxt *, KTEXT, char **);
int	auth_krb4_password(Authctxt *, const char *);
void    krb4_cleanup_proc(void *);
d113 7
a119 12
int     auth_krb4_tgt(Authctxt *, const char *);
int     auth_afs_token(Authctxt *, const char *);
#endif /* AFS */

#endif /* KRB4 */

#ifdef KRB5
int	auth_krb5(Authctxt *authctxt, krb5_data *auth, char **client);
int	auth_krb5_tgt(Authctxt *authctxt, krb5_data *tgt);
int	auth_krb5_password(Authctxt *authctxt, const char *password);
void	krb5_cleanup_proc(void *authctxt);
#endif /* KRB5 */
d125 3
a127 3
void	auth_log(Authctxt *, int, char *, char *);
void	userauth_finish(Authctxt *, int, char *);
int	auth_root_allowed(char *);
d129 1
a129 1
int	auth2_challenge(Authctxt *, char *);
d131 1
a131 1
int	allowed_user(struct passwd *);
d133 2
a134 2
char	*get_challenge(Authctxt *);
int	verify_response(Authctxt *, const char *);
a136 11

char	*expand_filename(const char *, struct passwd *);
char	*authorized_keys_file(struct passwd *);
char	*authorized_keys_file2(struct passwd *);

int
secure_filename(FILE *, const char *, struct passwd *, char *, size_t);

HostStatus
check_key_in_hostfiles(struct passwd *, Key *, const char *,
    const char *, const char *);
@


1.15.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@a0 2
/*	$OpenBSD: auth.h,v 1.29 2002/03/04 17:27:39 stevesk Exp $	*/

d24 1
a25 1

d74 2
a75 2
 * init_ctx	returns: non NULL upon success
 * query	returns: 0 - success, otherwise failure
d82 6
a87 5
	void*	(*init_ctx)(Authctxt*);
	int	(*query)(void *ctx, char **name, char **infotxt,
		    u_int *numprompts, char ***prompts, u_int **echo_on);
	int	(*respond)(void *ctx, u_int numresp, char **responses);
	void	(*free_ctx)(void *ctx);
d94 1
a94 1
int	 auth_rhosts_rsa(struct passwd *, const char *, Key *);
d97 1
a129 1
void	auth2_challenge_stop(Authctxt *);
@


1.15.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.h,v 1.37 2002/05/13 20:44:58 markus Exp $	*/
d91 1
a91 1
int      auth_rhosts(struct passwd *, const char *);
d95 1
a95 1
int	 auth_rhosts_rsa(struct passwd *, char *, Key *);
d98 1
a98 8
int      auth_rsa_challenge_dialog(Key *);
BIGNUM	*auth_rsa_generate_challenge(Key *);
int	 auth_rsa_verify_response(Key *, BIGNUM *, u_char[]);
int	 auth_rsa_key_allowed(struct passwd *, BIGNUM *, Key **);

int	 auth_rhosts_rsa_key_allowed(struct passwd *, char *, char *, Key *);
int	 hostbased_key_allowed(struct passwd *, const char *, char *, Key *);
int	 user_key_allowed(struct passwd *, Key *);
d121 2
a122 2
Authctxt *do_authentication(void);
Authctxt *do_authentication2(void);
a128 4
char	*auth2_read_banner(void);

void	privsep_challenge_enable(void);

a130 4
int	bsdauth_query(void *, char **, char **, u_int *, char ***, u_int **);
int	bsdauth_respond(void *, u_int, char **);
int	skey_query(void *, char **, char **, u_int *, char ***, u_int **);
int	skey_respond(void *, u_int, char **);
a132 1
struct passwd * getpwnamallow(const char *user);
a149 11
/* hostkey handling */
Key	*get_hostkey_by_index(int);
Key	*get_hostkey_by_type(int);
int	 get_hostkey_index(Key *);
int	 ssh1_session_key(BIGNUM *);

/* debug messages during authentication */
void	 auth_debug_add(const char *fmt,...) __attribute__((format(printf, 1, 2)));
void	 auth_debug_send(void);
void	 auth_debug_reset(void);

a153 1
#define SKEY_PROMPT "\nS/Key Password: "
@


1.14
log
@check auth_root_allowed for kbd-int auth, too.
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.13 2001/03/20 18:57:04 markus Exp $
d60 5
@


1.13
log
@add changes need for BSD_AUTH plus disabled BSD_AUTH code
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.12 2001/02/22 21:59:43 markus Exp $
d121 1
a121 1
void	userauth_reply(Authctxt *authctxt, int authenticated);
@


1.12
log
@use pwcopy in ssh.c, too
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.11 2001/02/12 16:16:23 markus Exp $
d31 7
d49 3
d72 1
a72 1
int     auth_password(struct passwd * pw, const char *password);
@


1.11
log
@PermitRootLogin={yes,without-password,forced-commands-only,no}
(before this change, root could login even if PermitRootLogin==no)
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.10 2001/01/21 19:05:43 markus Exp $
a121 1
struct passwd * pwcopy(struct passwd *pw);
@


1.10
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.9 2001/01/18 16:59:59 markus Exp $
d112 1
a112 1
int	auth_root_allowed(void);
@


1.9
log
@1) removes fake skey from sshd, since this will be much
   harder with /usr/libexec/auth/login_XXX
2) share/unify code used in ssh-1 and ssh-2 authentication (server side)
3) make addition of BSD_AUTH and other challenge reponse methods
   easier.
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.8 2000/12/28 14:25:51 markus Exp $
d29 2
d43 62
@


1.8
log
@count authentication failures only
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.7 2000/10/16 09:38:44 djm Exp $
d32 1
d39 1
d45 2
a46 1
void	userauth_log(Authctxt *authctxt, int authenticated, char *method);
d48 1
d50 1
a50 1
int	auth2_skey(Authctxt *authctxt);
d53 4
d58 1
@


1.7
log
@Add idents for files which lack them

Fix idents Id -> OpenBSD for the rest
@
text
@d24 1
a24 1
 * $OpenBSD$
d34 1
@


1.7.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.11 2001/02/12 16:16:23 markus Exp $
a28 2
#include <openssl/rsa.h>

a31 1
	int postponed;
a33 1
	int failures;
a36 1
	char *style;
a38 62
/*
 * Tries to authenticate the user using the .rhosts file.  Returns true if
 * authentication succeeds.  If ignore_rhosts is non-zero, this will not
 * consider .rhosts and .shosts (/etc/hosts.equiv will still be used).
 */
int     auth_rhosts(struct passwd * pw, const char *client_user);

/*
 * Tries to authenticate the user using the .rhosts file and the host using
 * its host key.  Returns true if authentication succeeds.
 */
int
auth_rhosts_rsa(struct passwd * pw, const char *client_user, RSA* client_host_key);

/*
 * Tries to authenticate the user using password.  Returns true if
 * authentication succeeds.
 */
int     auth_password(struct passwd * pw, const char *password);

/*
 * Performs the RSA authentication dialog with the client.  This returns 0 if
 * the client could not be authenticated, and 1 if authentication was
 * successful.  This may exit if there is a serious protocol violation.
 */
int     auth_rsa(struct passwd * pw, BIGNUM * client_n);

/*
 * Parses an RSA key (number of bits, e, n) from a string.  Moves the pointer
 * over the key.  Skips any whitespace at the beginning and at end.
 */
int     auth_rsa_read_key(char **cpp, u_int *bitsp, BIGNUM * e, BIGNUM * n);

/*
 * Performs the RSA authentication challenge-response dialog with the client,
 * and returns true (non-zero) if the client gave the correct answer to our
 * challenge; returns zero if the client gives a wrong answer.
 */
int     auth_rsa_challenge_dialog(RSA *pk);

#ifdef KRB4
#include <krb.h>
/*
 * Performs Kerberos v4 mutual authentication with the client. This returns 0
 * if the client could not be authenticated, and 1 if authentication was
 * successful.  This may exit if there is a serious protocol violation.
 */
int     auth_krb4(const char *server_user, KTEXT auth, char **client);
int     krb4_init(uid_t uid);
void    krb4_cleanup_proc(void *ignore);
int	auth_krb4_password(struct passwd * pw, const char *password);

#ifdef AFS
#include <kafs.h>

/* Accept passed Kerberos v4 ticket-granting ticket and AFS tokens. */
int     auth_kerberos_tgt(struct passwd * pw, const char *string);
int     auth_afs_token(struct passwd * pw, const char *token_string);
#endif				/* AFS */

#endif				/* KRB4 */

d42 1
a42 2
Authctxt *authctxt_new(void);
void	auth_log(Authctxt *authctxt, int authenticated, char *method, char *info);
a43 1
int	auth_root_allowed(char *method);
d45 1
a45 1
int	auth2_challenge(Authctxt *authctxt, char *devs);
a47 4

char	*get_challenge(Authctxt *authctxt, char *devs);
int	verify_response(Authctxt *authctxt, char *response);

a48 1
struct passwd * pwcopy(struct passwd *pw);
@


1.7.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.7.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.12 2001/02/22 21:59:43 markus Exp $
d122 1
@


1.7.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.15 2001/04/12 19:15:24 markus Exp $
a30 7
#ifdef HAVE_LOGIN_CAP
#include <login_cap.h>
#endif
#ifdef BSD_AUTH
#include <bsd_auth.h>
#endif

a41 3
#ifdef BSD_AUTH
	auth_session_t *as;
#endif
a50 5
/* extended interface similar to auth_rhosts() */
int
auth_rhosts2(struct passwd *pw, const char *client_user, const char *hostname,
    const char *ipaddr);

d62 1
a62 1
int     auth_password(Authctxt *authctxt, const char *password);
d111 1
a111 1
void	userauth_finish(Authctxt *authctxt, int authenticated, char *method);
@


1.7.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.22 2001/06/26 17:27:22 markus Exp $
a28 2
#include "key.h"
#include "hostfile.h"
a36 3
#ifdef KRB5
#include <krb5.h>
#endif
a38 2
typedef struct KbdintDevice KbdintDevice;

d40 9
a48 10
	int		 success;
	int		 postponed;
	int		 valid;
	int		 attempt;
	int		 failures;
	char		*user;
	char		*service;
	struct passwd	*pw;
	char		*style;
	void		*kbdintctxt;
d50 1
a50 11
	auth_session_t	*as;
#endif
#ifdef KRB4
	char		*krb4_ticket_file;
#endif
#ifdef KRB5
	krb5_context	 krb5_ctx;
	krb5_auth_context krb5_auth_ctx;
	krb5_ccache	 krb5_fwd_ccache;
	krb5_principal	 krb5_user;
	char		*krb5_ticket_file;
d55 10
a64 16
 * Keyboard interactive device:
 * init_ctx	returns: non NULL upon success 
 * query	returns: 0 - success, otherwise failure 
 * respond	returns: 0 - success, 1 - need further interaction,
 *		otherwise - failure
 */
struct KbdintDevice
{
	const char *name;
	void*	(*init_ctx)	__P((Authctxt*));
	int	(*query)	__P((void *ctx, char **name, char **infotxt,
				u_int *numprompts, char ***prompts,
				u_int **echo_on));
	int	(*respond)	__P((void *ctx, u_int numresp, char **responses));
	void	(*free_ctx)	__P((void *ctx));
};
d66 4
a69 1
int     auth_rhosts(struct passwd *, const char *);
d71 20
a90 1
auth_rhosts2(struct passwd *, const char *, const char *, const char *);
d92 6
a97 5
int	 auth_rhosts_rsa(struct passwd *, const char *, RSA *);
int      auth_password(Authctxt *, const char *);
int      auth_rsa(struct passwd *, BIGNUM *);
int      auth_rsa_read_key(char **, u_int *, BIGNUM *, BIGNUM *);
int      auth_rsa_challenge_dialog(RSA *);
d101 9
a109 3
int     auth_krb4(Authctxt *, KTEXT, char **);
int	auth_krb4_password(Authctxt *, const char *);
void    krb4_cleanup_proc(void *);
d113 7
a119 12
int     auth_krb4_tgt(Authctxt *, const char *);
int     auth_afs_token(Authctxt *, const char *);
#endif /* AFS */

#endif /* KRB4 */

#ifdef KRB5
int	auth_krb5(Authctxt *authctxt, krb5_data *auth, char **client);
int	auth_krb5_tgt(Authctxt *authctxt, krb5_data *tgt);
int	auth_krb5_password(Authctxt *authctxt, const char *password);
void	krb5_cleanup_proc(void *authctxt);
#endif /* KRB5 */
d125 3
a127 3
void	auth_log(Authctxt *, int, char *, char *);
void	userauth_finish(Authctxt *, int, char *);
int	auth_root_allowed(char *);
d129 1
a129 1
int	auth2_challenge(Authctxt *, char *);
d131 1
a131 1
int	allowed_user(struct passwd *);
d133 2
a134 2
char	*get_challenge(Authctxt *);
int	verify_response(Authctxt *, const char *);
a136 11

char	*expand_filename(const char *, struct passwd *);
char	*authorized_keys_file(struct passwd *);
char	*authorized_keys_file2(struct passwd *);

int
secure_filename(FILE *, const char *, struct passwd *, char *, size_t);

HostStatus
check_key_in_hostfiles(struct passwd *, Key *, const char *,
    const char *, const char *);
@


1.7.2.6
log
@Merge OpenSSH 3.1.
@
text
@a0 2
/*	$OpenBSD: auth.h,v 1.29 2002/03/04 17:27:39 stevesk Exp $	*/

d24 1
a25 1

d74 2
a75 2
 * init_ctx	returns: non NULL upon success
 * query	returns: 0 - success, otherwise failure
d82 6
a87 5
	void*	(*init_ctx)(Authctxt*);
	int	(*query)(void *ctx, char **name, char **infotxt,
		    u_int *numprompts, char ***prompts, u_int **echo_on);
	int	(*respond)(void *ctx, u_int numresp, char **responses);
	void	(*free_ctx)(void *ctx);
d94 1
a94 1
int	 auth_rhosts_rsa(struct passwd *, const char *, Key *);
d97 1
a129 1
void	auth2_challenge_stop(Authctxt *);
@


1.6
log
@add support for s/key (kbd-interactive) to ssh2, based on work by mkiernan@@avantgo.com and me
@
text
@d23 2
@


1.5
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d27 10
d40 4
a43 2
struct passwd *
auth_get_user(void);
d45 2
a46 1
int allowed_user(struct passwd * pw);
a52 1

@


1.4
log
@KNF
@
text
@d1 23
@


1.3
log
@split auth/sshconnect in one file per protocol version
@
text
@d10 1
a10 1
int allowed_user(struct passwd * pw);;
@


1.3.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d10 1
a10 1
int allowed_user(struct passwd * pw);
@


1.3.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@a0 25
/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $OpenBSD: auth.h,v 1.7 2000/10/16 09:38:44 djm Exp $
 */
a3 10
typedef struct Authctxt Authctxt;
struct Authctxt {
	int success;
	int valid;
	int attempt;
	char *user;
	char *service;
	struct passwd *pw;
};

d7 2
a8 4
void	userauth_log(Authctxt *authctxt, int authenticated, char *method);
void	userauth_reply(Authctxt *authctxt, int authenticated);

int	auth2_skey(Authctxt *authctxt);
d10 1
a10 2
int	allowed_user(struct passwd * pw);
struct passwd * auth_get_user(void);
d17 1
@


1.3.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.11 2001/02/12 16:16:23 markus Exp $
a28 2
#include <openssl/rsa.h>

a31 1
	int postponed;
a33 1
	int failures;
a36 1
	char *style;
a38 62
/*
 * Tries to authenticate the user using the .rhosts file.  Returns true if
 * authentication succeeds.  If ignore_rhosts is non-zero, this will not
 * consider .rhosts and .shosts (/etc/hosts.equiv will still be used).
 */
int     auth_rhosts(struct passwd * pw, const char *client_user);

/*
 * Tries to authenticate the user using the .rhosts file and the host using
 * its host key.  Returns true if authentication succeeds.
 */
int
auth_rhosts_rsa(struct passwd * pw, const char *client_user, RSA* client_host_key);

/*
 * Tries to authenticate the user using password.  Returns true if
 * authentication succeeds.
 */
int     auth_password(struct passwd * pw, const char *password);

/*
 * Performs the RSA authentication dialog with the client.  This returns 0 if
 * the client could not be authenticated, and 1 if authentication was
 * successful.  This may exit if there is a serious protocol violation.
 */
int     auth_rsa(struct passwd * pw, BIGNUM * client_n);

/*
 * Parses an RSA key (number of bits, e, n) from a string.  Moves the pointer
 * over the key.  Skips any whitespace at the beginning and at end.
 */
int     auth_rsa_read_key(char **cpp, u_int *bitsp, BIGNUM * e, BIGNUM * n);

/*
 * Performs the RSA authentication challenge-response dialog with the client,
 * and returns true (non-zero) if the client gave the correct answer to our
 * challenge; returns zero if the client gives a wrong answer.
 */
int     auth_rsa_challenge_dialog(RSA *pk);

#ifdef KRB4
#include <krb.h>
/*
 * Performs Kerberos v4 mutual authentication with the client. This returns 0
 * if the client could not be authenticated, and 1 if authentication was
 * successful.  This may exit if there is a serious protocol violation.
 */
int     auth_krb4(const char *server_user, KTEXT auth, char **client);
int     krb4_init(uid_t uid);
void    krb4_cleanup_proc(void *ignore);
int	auth_krb4_password(struct passwd * pw, const char *password);

#ifdef AFS
#include <kafs.h>

/* Accept passed Kerberos v4 ticket-granting ticket and AFS tokens. */
int     auth_kerberos_tgt(struct passwd * pw, const char *string);
int     auth_afs_token(struct passwd * pw, const char *token_string);
#endif				/* AFS */

#endif				/* KRB4 */

d42 1
a42 2
Authctxt *authctxt_new(void);
void	auth_log(Authctxt *authctxt, int authenticated, char *method, char *info);
a43 1
int	auth_root_allowed(char *method);
d45 1
a45 1
int	auth2_challenge(Authctxt *authctxt, char *devs);
a47 4

char	*get_challenge(Authctxt *authctxt, char *devs);
int	verify_response(Authctxt *authctxt, char *response);

a48 1
struct passwd * pwcopy(struct passwd *pw);
@


1.3.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d24 1
a24 1
 * $OpenBSD: auth.h,v 1.12 2001/02/22 21:59:43 markus Exp $
d122 1
@


1.2
log
@ssh2 server side, see README.openssh2; enable with 'sshd -2'
@
text
@d10 6
d17 1
@


1.1
log
@split sshd.c -> auth.c session.c sshd.c plus cleanup and goto-removal
@
text
@d5 4
@

