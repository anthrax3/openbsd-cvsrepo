head	1.31;
access;
symbols
	OPENBSD_6_2:1.31.0.2
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.25.0.2
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.10.0.8
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.6
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.4
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.2.0.2
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.1.0.16
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.14
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.12
	OPENBSD_3_6_BASE:1.1
	OPENBSD_3_5:1.1.0.10
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.8
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_1:1.1.0.6
	OPENBSD_3_2:1.1.0.4
	OPENBSD_3_3:1.1.0.2
	OPENBSD_3_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.31
date	2017.05.30.14.23.52;	author markus;	state Exp;
branches;
next	1.30;
commitid	tEOGxoM4kvBMLD6J;

1.30
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	ZllbGwdb0fOmLhjK;

1.29
date	2016.06.08.02.13.01;	author dtucker;	state Exp;
branches;
next	1.28;
commitid	kLE3wl5d7MrDq5Q7;

1.28
date	2016.06.01.04.19.49;	author dtucker;	state Exp;
branches;
next	1.27;
commitid	H7nQMlahTocwHINf;

1.27
date	2016.05.31.23.46.14;	author dtucker;	state Exp;
branches;
next	1.26;
commitid	J4q8xCNJ7CY5scDq;

1.26
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.25;
commitid	K3glY441IowbrjDE;

1.25
date	2015.04.13.02.04.08;	author djm;	state Exp;
branches;
next	1.24;
commitid	UnQkGQmy0WhvW7t3;

1.24
date	2015.01.26.06.10.03;	author djm;	state Exp;
branches;
next	1.23;
commitid	F603CYAZ9E536XCr;

1.23
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	cBx23BaCk6gYBpRj;

1.22
date	2015.01.20.07.55.33;	author djm;	state Exp;
branches;
next	1.21;
commitid	Setxb2a5y0nORr1C;

1.21
date	2015.01.19.20.16.15;	author markus;	state Exp;
branches;
next	1.20;
commitid	U9l75XYAjMKaQ8Jp;

1.20
date	2015.01.19.19.52.16;	author markus;	state Exp;
branches;
next	1.19;
commitid	UHlhoIB5NMb8eAPm;

1.19
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2014.01.12.08.13.13;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2014.01.09.23.20.00;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2013.07.19.07.37.48;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2010.11.10.01.33.07;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.21.07.37.15;	author dtucker;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.01.21.17.36;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.06.21.25.28;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2006.10.31.16.33.12;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.5;

1.5
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.04.05.15.59;	author djm;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.02.16.17.09.57;	author markus;	state Exp;
branches
	1.1.4.1
	1.1.6.1
	1.1.14.1
	1.1.16.1;
next	;

1.1.4.1
date	2003.04.01.10.38.57;	author margarida;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.1.6.1
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.1.14.1
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.1.16.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.1.16.2;

1.1.16.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	1.1.16.3;

1.1.16.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.2.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.8.4.1
date	2006.11.08.00.42.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.31
log
@protocol handlers all get struct ssh passed; ok djm@@
@
text
@/* $OpenBSD: kexgexs.c,v 1.30 2016/09/12 01:22:38 deraadt Exp $ */
/*
 * Copyright (c) 2000 Niels Provos.  All rights reserved.
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <stdio.h>
#include <string.h>
#include <signal.h>

#include <openssl/dh.h>

#include "sshkey.h"
#include "cipher.h"
#include "digest.h"
#include "kex.h"
#include "log.h"
#include "packet.h"
#include "dh.h"
#include "ssh2.h"
#include "compat.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"
#include "dispatch.h"
#include "ssherr.h"
#include "sshbuf.h"
#include "misc.h"

static int input_kex_dh_gex_request(int, u_int32_t, struct ssh *);
static int input_kex_dh_gex_init(int, u_int32_t, struct ssh *);

int
kexgex_server(struct ssh *ssh)
{
	ssh_dispatch_set(ssh, SSH2_MSG_KEX_DH_GEX_REQUEST,
	    &input_kex_dh_gex_request);
	debug("expecting SSH2_MSG_KEX_DH_GEX_REQUEST");
	return 0;
}

static int
input_kex_dh_gex_request(int type, u_int32_t seq, struct ssh *ssh)
{
	struct kex *kex = ssh->kex;
	int r;
	u_int min = 0, max = 0, nbits = 0;

	debug("SSH2_MSG_KEX_DH_GEX_REQUEST received");
	if ((r = sshpkt_get_u32(ssh, &min)) != 0 ||
	    (r = sshpkt_get_u32(ssh, &nbits)) != 0 ||
	    (r = sshpkt_get_u32(ssh, &max)) != 0 ||
	    (r = sshpkt_get_end(ssh)) != 0)
		goto out;
	kex->nbits = nbits;
	kex->min = min;
	kex->max = max;
	min = MAXIMUM(DH_GRP_MIN, min);
	max = MINIMUM(DH_GRP_MAX, max);
	nbits = MAXIMUM(DH_GRP_MIN, nbits);
	nbits = MINIMUM(DH_GRP_MAX, nbits);

	if (kex->max < kex->min || kex->nbits < kex->min ||
	    kex->max < kex->nbits || kex->max < DH_GRP_MIN) {
		r = SSH_ERR_DH_GEX_OUT_OF_RANGE;
		goto out;
	}

	/* Contact privileged parent */
	kex->dh = PRIVSEP(choose_dh(min, nbits, max));
	if (kex->dh == NULL) {
		sshpkt_disconnect(ssh, "no matching DH grp found");
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	debug("SSH2_MSG_KEX_DH_GEX_GROUP sent");
	if ((r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_GROUP)) != 0 ||
	    (r = sshpkt_put_bignum2(ssh, kex->dh->p)) != 0 ||
	    (r = sshpkt_put_bignum2(ssh, kex->dh->g)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		goto out;

	/* Compute our exchange value in parallel with the client */
	if ((r = dh_gen_key(kex->dh, kex->we_need * 8)) != 0)
		goto out;

	debug("expecting SSH2_MSG_KEX_DH_GEX_INIT");
	ssh_dispatch_set(ssh, SSH2_MSG_KEX_DH_GEX_INIT, &input_kex_dh_gex_init);
	r = 0;
 out:
	return r;
}

static int
input_kex_dh_gex_init(int type, u_int32_t seq, struct ssh *ssh)
{
	struct kex *kex = ssh->kex;
	BIGNUM *shared_secret = NULL, *dh_client_pub = NULL;
	struct sshkey *server_host_public, *server_host_private;
	u_char *kbuf = NULL, *signature = NULL, *server_host_key_blob = NULL;
	u_char hash[SSH_DIGEST_MAX_LENGTH];
	size_t sbloblen, slen;
	size_t klen = 0, hashlen;
	int kout, r;

	if (kex->load_host_public_key == NULL ||
	    kex->load_host_private_key == NULL) {
		r = SSH_ERR_INVALID_ARGUMENT;
		goto out;
	}
	server_host_public = kex->load_host_public_key(kex->hostkey_type,
	    kex->hostkey_nid, ssh);
	server_host_private = kex->load_host_private_key(kex->hostkey_type,
	    kex->hostkey_nid, ssh);
	if (server_host_public == NULL) {
		r = SSH_ERR_NO_HOSTKEY_LOADED;
		goto out;
	}

	/* key, cert */
	if ((dh_client_pub = BN_new()) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((r = sshpkt_get_bignum2(ssh, dh_client_pub)) != 0 ||
	    (r = sshpkt_get_end(ssh)) != 0)
		goto out;

#ifdef DEBUG_KEXDH
	fprintf(stderr, "dh_client_pub= ");
	BN_print_fp(stderr, dh_client_pub);
	fprintf(stderr, "\n");
	debug("bits %d", BN_num_bits(dh_client_pub));
#endif

#ifdef DEBUG_KEXDH
	DHparams_print_fp(stderr, kex->dh);
	fprintf(stderr, "pub= ");
	BN_print_fp(stderr, kex->dh->pub_key);
	fprintf(stderr, "\n");
#endif
	if (!dh_pub_is_valid(kex->dh, dh_client_pub)) {
		sshpkt_disconnect(ssh, "bad client public DH value");
		r = SSH_ERR_MESSAGE_INCOMPLETE;
		goto out;
	}

	klen = DH_size(kex->dh);
	if ((kbuf = malloc(klen)) == NULL ||
	    (shared_secret = BN_new()) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((kout = DH_compute_key(kbuf, dh_client_pub, kex->dh)) < 0 ||
	    BN_bin2bn(kbuf, kout, shared_secret) == NULL) {
		r = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}
#ifdef DEBUG_KEXDH
	dump_digest("shared secret", kbuf, kout);
#endif
	if ((r = sshkey_to_blob(server_host_public, &server_host_key_blob,
	    &sbloblen)) != 0)
		goto out;
	/* calc H */
	hashlen = sizeof(hash);
	if ((r = kexgex_hash(
	    kex->hash_alg,
	    kex->client_version_string,
	    kex->server_version_string,
	    sshbuf_ptr(kex->peer), sshbuf_len(kex->peer),
	    sshbuf_ptr(kex->my), sshbuf_len(kex->my),
	    server_host_key_blob, sbloblen,
	    kex->min, kex->nbits, kex->max,
	    kex->dh->p, kex->dh->g,
	    dh_client_pub,
	    kex->dh->pub_key,
	    shared_secret,
	    hash, &hashlen)) != 0)
		goto out;

	/* save session id := H */
	if (kex->session_id == NULL) {
		kex->session_id_len = hashlen;
		kex->session_id = malloc(kex->session_id_len);
		if (kex->session_id == NULL) {
			r = SSH_ERR_ALLOC_FAIL;
			goto out;
		}
		memcpy(kex->session_id, hash, kex->session_id_len);
	}

	/* sign H */
	if ((r = kex->sign(server_host_private, server_host_public, &signature,
	     &slen, hash, hashlen, kex->hostkey_alg, ssh->compat)) < 0)
		goto out;

	/* destroy_sensitive_data(); */

	/* send server hostkey, DH pubkey 'f' and singed H */
	if ((r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_REPLY)) != 0 ||
	    (r = sshpkt_put_string(ssh, server_host_key_blob, sbloblen)) != 0 ||
	    (r = sshpkt_put_bignum2(ssh, kex->dh->pub_key)) != 0 ||     /* f */
	    (r = sshpkt_put_string(ssh, signature, slen)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		goto out;

	if ((r = kex_derive_keys_bn(ssh, hash, hashlen, shared_secret)) == 0)
		r = kex_send_newkeys(ssh);
 out:
	DH_free(kex->dh);
	kex->dh = NULL;
	if (dh_client_pub)
		BN_clear_free(dh_client_pub);
	if (kbuf) {
		explicit_bzero(kbuf, klen);
		free(kbuf);
	}
	if (shared_secret)
		BN_clear_free(shared_secret);
	free(server_host_key_blob);
	free(signature);
	return r;
}
@


1.30
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.29 2016/06/08 02:13:01 dtucker Exp $ */
d52 2
a53 2
static int input_kex_dh_gex_request(int, u_int32_t, void *);
static int input_kex_dh_gex_init(int, u_int32_t, void *);
d65 1
a65 1
input_kex_dh_gex_request(int type, u_int32_t seq, void *ctxt)
a66 1
	struct ssh *ssh = ctxt;
d117 1
a117 1
input_kex_dh_gex_init(int type, u_int32_t seq, void *ctxt)
a118 1
	struct ssh *ssh = ctxt;
@


1.29
log
@Back out rev 1.28 "Check min and max sizes sent by the client" change.
It caused "key_verify failed for server_host_key" in clients that send a
DH-GEX min value less that DH_GRP_MIN, eg old OpenSSH and PuTTY.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.27 2016/05/31 23:46:14 dtucker Exp $ */
a26 1
#include <sys/param.h>	/* MIN MAX */
d50 1
d81 4
a84 4
	min = MAX(DH_GRP_MIN, min);
	max = MIN(DH_GRP_MAX, max);
	nbits = MAX(DH_GRP_MIN, nbits);
	nbits = MIN(DH_GRP_MAX, nbits);
@


1.28
log
@Check min and max sizes sent by the client against what we support before
passing them to the monitor.  ok djm@@
@
text
@d81 5
d87 1
a87 2
	    kex->max < kex->nbits || kex->max < DH_GRP_MIN ||
	    kex->min > DH_GRP_MAX) {
a90 4
	kex->min = MAX(DH_GRP_MIN, kex->min);
	kex->max = MIN(DH_GRP_MAX, kex->max);
	kex->nbits = MAX(DH_GRP_MIN, kex->nbits);
	kex->nbits = MIN(DH_GRP_MAX, kex->nbits);
d93 1
a93 1
	kex->dh = PRIVSEP(choose_dh(kex->min, kex->nbits, kex->max));
d95 1
a95 1
		sshpkt_disconnect(ssh, "no matching DH group found");
@


1.27
log
@Ensure that the client's proposed DH-GEX max value is at least as big
as the minimum the server will accept.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.26 2015/12/04 16:41:28 markus Exp $ */
a80 5
	min = MAX(DH_GRP_MIN, min);
	max = MIN(DH_GRP_MAX, max);
	nbits = MAX(DH_GRP_MIN, nbits);
	nbits = MIN(DH_GRP_MAX, nbits);

d82 2
a83 1
	    kex->max < kex->nbits || kex->max < DH_GRP_MIN) {
d87 4
d93 1
a93 1
	kex->dh = PRIVSEP(choose_dh(min, nbits, max));
d95 1
a95 1
		sshpkt_disconnect(ssh, "no matching DH grp found");
@


1.26
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.25 2015/04/13 02:04:08 djm Exp $ */
d87 1
a87 1
	    kex->max < kex->nbits) {
@


1.25
log
@deprecate ancient, pre-RFC4419 and undocumented
SSH2_MSG_KEX_DH_GEX_REQUEST_OLD message;
ok markus@@ deraadt@@ "seems reasonable" dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.24 2015/01/26 06:10:03 djm Exp $ */
d218 2
a219 2
	if ((r = kex->sign(server_host_private, server_host_public,
	    &signature, &slen, hash, hashlen, ssh->compat)) < 0)
@


1.24
log
@correctly match ECDSA subtype (== curve) for offered/recevied
host keys. Fixes connection-killing host key mismatches when
a server offers multiple ECDSA keys with different curve type
(an extremely unlikely configuration).

ok markus, "looks mechanical" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.23 2015/01/20 23:14:00 deraadt Exp $ */
a57 2
	ssh_dispatch_set(ssh, SSH2_MSG_KEX_DH_GEX_REQUEST_OLD,
	    &input_kex_dh_gex_request);
d72 5
a76 28
	switch (type) {
	case SSH2_MSG_KEX_DH_GEX_REQUEST:
		debug("SSH2_MSG_KEX_DH_GEX_REQUEST received");
		if ((r = sshpkt_get_u32(ssh, &min)) != 0 ||
		    (r = sshpkt_get_u32(ssh, &nbits)) != 0 ||
		    (r = sshpkt_get_u32(ssh, &max)) != 0 ||
		    (r = sshpkt_get_end(ssh)) != 0)
			goto out;
		kex->nbits = nbits;
		kex->min = min;
		kex->max = max;
		min = MAX(DH_GRP_MIN, min);
		max = MIN(DH_GRP_MAX, max);
		nbits = MAX(DH_GRP_MIN, nbits);
		nbits = MIN(DH_GRP_MAX, nbits);
		break;
	case SSH2_MSG_KEX_DH_GEX_REQUEST_OLD:
		debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD received");
		if ((r = sshpkt_get_u32(ssh, &nbits)) != 0 ||
		    (r = sshpkt_get_end(ssh)) != 0)
			goto out;
		kex->nbits = nbits;
		/* unused for old GEX */
		kex->min = min = DH_GRP_MIN;
		kex->max = max = DH_GRP_MAX;
		break;
	default:
		r = SSH_ERR_INVALID_ARGUMENT;
d78 7
a84 1
	}
a108 4

	/* old KEX does not use min/max in kexgex_hash() */
	if (type == SSH2_MSG_KEX_DH_GEX_REQUEST_OLD)
		kex->min = kex->max = -1;
@


1.23
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.22 2015/01/20 07:55:33 djm Exp $ */
d158 4
a161 2
	server_host_public = kex->load_host_public_key(kex->hostkey_type, ssh);
	server_host_private = kex->load_host_private_key(kex->hostkey_type, ssh);
@


1.22
log
@fix hostkeys in agent; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.21 2015/01/19 20:16:15 markus Exp $ */
d27 1
a27 1
#include <sys/param.h>
@


1.21
log
@adapt kex to sshbuf and struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.20 2015/01/19 19:52:16 markus Exp $ */
d158 3
a160 4
	if ((server_host_public = kex->load_host_public_key(kex->hostkey_type,
	    ssh)) == NULL ||
	    (server_host_private = kex->load_host_private_key(kex->hostkey_type,
	    ssh)) == NULL) {
@


1.20
log
@update packet.c & isolate, introduce struct ssh
a) switch packet.c to buffer api and isolate per-connection info into struct ssh
b) (de)serialization of the state is moved from monitor to packet.c
c) the old packet.c API is implemented in opacket.[ch]
d) compress.c/h is removed and integrated into packet.c
with and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.19 2014/02/02 03:44:31 djm Exp $ */
d35 1
a35 3
#include "xmalloc.h"
#include "buffer.h"
#include "key.h"
d37 1
d48 3
d52 5
a56 2
void
kexgex_server(Kex *kex)
d58 7
a64 7
	BIGNUM *shared_secret = NULL, *dh_client_pub = NULL;
	Key *server_host_public, *server_host_private;
	DH *dh;
	u_char *kbuf, *hash, *signature = NULL, *server_host_key_blob = NULL;
	u_int sbloblen, klen, slen, hashlen;
	int omin = -1, min = -1, omax = -1, max = -1, onbits = -1, nbits = -1;
	int type, kout;
d66 7
a72 7
	if (kex->load_host_public_key == NULL ||
	    kex->load_host_private_key == NULL)
		fatal("Cannot load hostkey");
	server_host_public = kex->load_host_public_key(kex->hostkey_type);
	if (server_host_public == NULL)
		fatal("Unsupported hostkey type %d", kex->hostkey_type);
	server_host_private = kex->load_host_private_key(kex->hostkey_type);
a73 1
	type = packet_read();
d77 8
a84 3
		omin = min = packet_get_int();
		onbits = nbits = packet_get_int();
		omax = max = packet_get_int();
d92 4
a95 1
		onbits = nbits = packet_get_int();
d97 2
a98 2
		omin = min = DH_GRP_MIN;
		omax = max = DH_GRP_MAX;
d101 2
a102 1
		fatal("protocol error during kex, no DH_GEX_REQUEST: %d", type);
a103 1
	packet_check_eom();
d105 5
a109 3
	if (omax < omin || onbits < omin || omax < onbits)
		fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d",
		    omin, onbits, omax);
d112 6
a117 4
	dh = PRIVSEP(choose_dh(min, nbits, max));
	if (dh == NULL)
		packet_disconnect("Protocol error: no matching DH grp found");

d119 5
a123 4
	packet_start(SSH2_MSG_KEX_DH_GEX_GROUP);
	packet_put_bignum2(dh->p);
	packet_put_bignum2(dh->g);
	packet_send();
d125 3
a127 2
	/* flush */
	packet_write_wait();
d129 3
a131 2
	/* Compute our exchange value in parallel with the client */
	dh_gen_key(dh, kex->we_need * 8);
d134 31
a164 1
	packet_read_expect(SSH2_MSG_KEX_DH_GEX_INIT);
d167 7
a173 4
	if ((dh_client_pub = BN_new()) == NULL)
		fatal("dh_client_pub == NULL");
	packet_get_bignum2(dh_client_pub);
	packet_check_eom();
d183 1
a183 1
	DHparams_print_fp(stderr, dh);
d185 1
a185 1
	BN_print_fp(stderr, dh->pub_key);
d188 5
a192 2
	if (!dh_pub_is_valid(dh, dh_client_pub))
		packet_disconnect("bad client public DH value");
d194 11
a204 4
	klen = DH_size(dh);
	kbuf = xmalloc(klen);
	if ((kout = DH_compute_key(kbuf, dh_client_pub, dh)) < 0)
		fatal("DH_compute_key: failed");
d208 3
a210 12
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexgex_server: BN_new failed");
	if (BN_bin2bn(kbuf, kout, shared_secret) == NULL)
		fatal("kexgex_server: BN_bin2bn failed");
	explicit_bzero(kbuf, klen);
	free(kbuf);

	key_to_blob(server_host_public, &server_host_key_blob, &sbloblen);

	if (type == SSH2_MSG_KEX_DH_GEX_REQUEST_OLD)
		omin = min = omax = max = -1;

d212 2
a213 1
	kexgex_hash(
d217 2
a218 2
	    buffer_ptr(kex->peer), buffer_len(kex->peer),
	    buffer_ptr(kex->my), buffer_len(kex->my),
d220 2
a221 2
	    omin, onbits, omax,
	    dh->p, dh->g,
d223 1
a223 1
	    dh->pub_key,
d225 2
a226 3
	    &hash, &hashlen
	);
	BN_clear_free(dh_client_pub);
d231 5
a235 1
		kex->session_id = xmalloc(kex->session_id_len);
d240 3
a242 2
	kex->sign(server_host_private, server_host_public, &signature, &slen,
	    hash, hashlen);
d247 21
a267 7
	debug("SSH2_MSG_KEX_DH_GEX_REPLY sent");
	packet_start(SSH2_MSG_KEX_DH_GEX_REPLY);
	packet_put_string(server_host_key_blob, sbloblen);
	packet_put_bignum2(dh->pub_key);	/* f */
	packet_put_string(signature, slen);
	packet_send();

d269 1
a269 8
	free(server_host_key_blob);
	/* have keys, free DH */
	DH_free(dh);

	kex_derive_keys_bn(kex, hash, hashlen, shared_secret);
	BN_clear_free(shared_secret);

	kex_finish(kex);
@


1.19
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.18 2014/01/12 08:13:13 djm Exp $ */
d163 2
a164 2
	    buffer_ptr(&kex->peer), buffer_len(&kex->peer),
	    buffer_ptr(&kex->my), buffer_len(&kex->my),
@


1.18
log
@avoid use of OpenSSL BIGNUM type and functions for KEX with
Curve25519 by adding a buffer_put_bignum2_from_string() that stores
a string using the bignum encoding rules. Will make it easier to
build a reduced-feature OpenSSH without OpenSSL in the future;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.17 2014/01/09 23:20:00 djm Exp $ */
d150 1
a150 1
	memset(kbuf, 0, klen);
@


1.17
log
@Introduce digest API and use it to perform all hashing operations
rather than calling OpenSSL EVP_Digest* directly. Will make it easier
to build a reduced-feature OpenSSH without OpenSSL in future;
feedback, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.16 2013/07/19 07:37:48 markus Exp $ */
d201 1
a201 1
	kex_derive_keys(kex, hash, hashlen, shared_secret);
@


1.16
log
@add ssh-agent(1) support to sshd(8); allows encrypted hostkeys,
or hostkeys on smartcards; most of the work by Zev Weiss; bz #1974
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.15 2013/05/17 00:13:13 djm Exp $ */
d160 1
a160 1
	    kex->evp_md,
@


1.15
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.14 2010/11/10 01:33:07 djm Exp $ */
a67 4
	if (server_host_private == NULL)
		fatal("Missing private key for hostkey type %d",
		    kex->hostkey_type);

d183 2
a184 3
	if (PRIVSEP(key_sign(server_host_private, &signature, &slen, hash,
	    hashlen)) < 0)
		fatal("kexgex_server: key_sign failed");
@


1.14
log
@use only libcrypto APIs that are retained with OPENSSL_NO_DEPRECATED.
these have been around for years by this time. ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.13 2010/02/26 20:29:54 djm Exp $ */
d155 1
a155 1
	xfree(kbuf);
d201 2
a202 2
	xfree(signature);
	xfree(server_host_key_blob);
@


1.13
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.12 2009/06/21 07:37:15 dtucker Exp $ */
d32 2
@


1.12
log
@abort if key_sign fails, preventing possible null deref.  Based on report
from Paolo Ganci, ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.11 2009/01/01 21:17:36 djm Exp $ */
d52 1
a52 1
	Key *server_host_key;
d59 2
a60 1
	if (kex->load_host_key == NULL)
d62 2
a63 2
	server_host_key = kex->load_host_key(kex->hostkey_type);
	if (server_host_key == NULL)
d65 5
d155 1
a155 1
	key_to_blob(server_host_key, &server_host_key_blob, &sbloblen);
d185 1
a185 1
	if (PRIVSEP(key_sign(server_host_key, &signature, &slen, hash,
@


1.11
log
@fix hash calculation for KEXGEX: hash over the original client-supplied
values and not the sanity checked versions that we acutally use;
bz#1540 reported by john.smith AT arrows.demon.co.uk
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.10 2006/11/06 21:25:28 markus Exp $ */
d179 3
a181 1
	PRIVSEP(key_sign(server_host_key, &signature, &slen, hash, hashlen));
@


1.10
log
@add missing checks for openssl return codes; with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.9 2006/10/31 16:33:12 markus Exp $ */
d56 2
a57 1
	int min = -1, max = -1, nbits = -1, type, kout;
d69 3
a71 3
		min = packet_get_int();
		nbits = packet_get_int();
		max = packet_get_int();
d74 2
d79 1
a79 3
		nbits = packet_get_int();
		min = DH_GRP_MIN;
		max = DH_GRP_MAX;
d81 2
d89 1
a89 1
	if (max < min || nbits < min || max < nbits)
d91 1
a91 1
		    min, nbits, max);
d152 1
a152 1
		min = max = -1;
d162 1
a162 1
	    min, nbits, max,
@


1.9
log
@check DH_compute_key() for -1 even if it should not happen because of
earlier calls to dh_pub_is_valid(); report krahmer at suse.de; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.8 2006/08/03 03:34:42 deraadt Exp $ */
d141 2
a142 1
	BN_bin2bn(kbuf, kout, shared_secret);
@


1.8
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.7 2006/08/01 23:22:47 stevesk Exp $ */
d55 2
a56 2
	u_int sbloblen, klen, kout, slen, hashlen;
	int min = -1, max = -1, nbits = -1, type;
d134 2
a135 1
	kout = DH_compute_key(kbuf, dh_client_pub, dh);
@


1.8.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.10 2006/11/06 21:25:28 markus Exp $ */
d55 2
a56 2
	u_int sbloblen, klen, slen, hashlen;
	int min = -1, max = -1, nbits = -1, type, kout;
d134 1
a134 2
	if ((kout = DH_compute_key(kbuf, dh_client_pub, dh)) < 0)
		fatal("DH_compute_key: failed");
d140 1
a140 2
	if (BN_bin2bn(kbuf, kout, shared_secret) == NULL)
		fatal("kexgex_server: BN_bin2bn failed");
@


1.7
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.6 2006/07/26 02:35:17 stevesk Exp $ */
a26 2
#include "includes.h"

d31 1
d34 1
d36 1
d43 3
@


1.6
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.5 2006/07/22 20:48:23 stevesk Exp $ */
d31 1
@


1.5
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.4 2006/03/25 13:17:02 djm Exp $ */
d28 2
@


1.4
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d28 2
@


1.3
log
@RCSID() can die
@
text
@d1 1
@


1.2
log
@remove hardcoded hash lengths in key exchange code, allowing
implementation of KEX methods with different hashes (e.g. SHA-256);
ok markus@@ dtucker@@ stevesk@@
@
text
@a26 1
RCSID("$OpenBSD: kexgexs.c,v 1.1 2003/02/16 17:09:57 markus Exp $");
@


1.2.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: kexgexs.c,v 1.8 2006/08/03 03:34:42 deraadt Exp $ */
d26 2
a27 5
#include <sys/param.h>

#include <stdio.h>
#include <string.h>
#include <signal.h>
a29 1
#include "buffer.h"
a30 1
#include "cipher.h"
a36 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
@


1.2.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.10 2006/11/06 21:25:28 markus Exp $ */
d55 2
a56 2
	u_int sbloblen, klen, slen, hashlen;
	int min = -1, max = -1, nbits = -1, type, kout;
d134 1
a134 2
	if ((kout = DH_compute_key(kbuf, dh_client_pub, dh)) < 0)
		fatal("DH_compute_key: failed");
d140 1
a140 2
	if (BN_bin2bn(kbuf, kout, shared_secret) == NULL)
		fatal("kexgex_server: BN_bin2bn failed");
@


1.1
log
@split kex into client and server code, no need to link
server code into the client; ok provos@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.22 2002/03/24 17:27:03 stevesk Exp $");
d46 1
a46 1
	u_int sbloblen, klen, kout, slen;
d140 3
a142 2
	/* calc H */			/* XXX depends on 'kex' */
	hash = kexgex_hash(
d152 2
a153 1
	    shared_secret
a157 1
	/* XXX hashlen depends on KEX */
d159 1
a159 1
		kex->session_id_len = 20;
d165 1
a165 2
	/* XXX hashlen depends on KEX */
	PRIVSEP(key_sign(server_host_key, &signature, &slen, hash, 20));
d182 1
a182 1
	kex_derive_keys(kex, hash, shared_secret);
@


1.1.16.1
log
@upgrade to OpenSSH 4.3
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgexs.c,v 1.2 2005/11/04 05:15:59 djm Exp $");
d46 1
a46 1
	u_int sbloblen, klen, kout, slen, hashlen;
d140 2
a141 3
	/* calc H */
	kexgex_hash(
	    kex->evp_md,
d151 1
a151 2
	    shared_secret,
	    &hash, &hashlen
d156 1
d158 1
a158 1
		kex->session_id_len = hashlen;
d164 2
a165 1
	PRIVSEP(key_sign(server_host_key, &signature, &slen, hash, hashlen));
d182 1
a182 1
	kex_derive_keys(kex, hash, hashlen, shared_secret);
@


1.1.16.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: kexgexs.c,v 1.8 2006/08/03 03:34:42 deraadt Exp $ */
d26 2
a27 5
#include <sys/param.h>

#include <stdio.h>
#include <string.h>
#include <signal.h>
a29 1
#include "buffer.h"
a30 1
#include "cipher.h"
a36 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
@


1.1.16.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexs.c,v 1.10 2006/11/06 21:25:28 markus Exp $ */
d55 2
a56 2
	u_int sbloblen, klen, slen, hashlen;
	int min = -1, max = -1, nbits = -1, type, kout;
d134 1
a134 2
	if ((kout = DH_compute_key(kbuf, dh_client_pub, dh)) < 0)
		fatal("DH_compute_key: failed");
d140 1
a140 2
	if (BN_bin2bn(kbuf, kout, shared_secret) == NULL)
		fatal("kexgex_server: BN_bin2bn failed");
@


1.1.14.1
log
@upgrade to OpenSSH 4.3
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgexs.c,v 1.2 2005/11/04 05:15:59 djm Exp $");
d46 1
a46 1
	u_int sbloblen, klen, kout, slen, hashlen;
d140 2
a141 3
	/* calc H */
	kexgex_hash(
	    kex->evp_md,
d151 1
a151 2
	    shared_secret,
	    &hash, &hashlen
d156 1
d158 1
a158 1
		kex->session_id_len = hashlen;
d164 2
a165 1
	PRIVSEP(key_sign(server_host_key, &signature, &slen, hash, hashlen));
d182 1
a182 1
	kex_derive_keys(kex, hash, hashlen, shared_secret);
@


1.1.6.1
log
@Merge OpenSSH 3.6.1
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgexs.c,v 1.1 2003/02/16 17:09:57 markus Exp $");
@


1.1.4.1
log
@These were missed on the update to the last openssh.

Thanks to all who pointed it out.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgexs.c,v 1.1 2003/02/16 17:09:57 markus Exp $");
@


1.1.4.2
log
@upgrade to OpenSSH 3.7
@
text
@@


