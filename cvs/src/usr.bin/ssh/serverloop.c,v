head	1.191;
access;
symbols
	OPENBSD_6_1_BASE:1.191
	OPENBSD_6_0:1.184.0.4
	OPENBSD_6_0_BASE:1.184
	OPENBSD_5_9:1.182.0.2
	OPENBSD_5_9_BASE:1.182
	OPENBSD_5_8:1.178.0.4
	OPENBSD_5_8_BASE:1.178
	OPENBSD_5_7:1.178.0.2
	OPENBSD_5_7_BASE:1.178
	OPENBSD_5_6:1.172.0.4
	OPENBSD_5_6_BASE:1.172
	OPENBSD_5_5:1.170.0.4
	OPENBSD_5_5_BASE:1.170
	OPENBSD_5_4:1.168.0.2
	OPENBSD_5_4_BASE:1.168
	OPENBSD_5_3:1.164.0.2
	OPENBSD_5_3_BASE:1.164
	OPENBSD_5_2:1.162.0.2
	OPENBSD_5_2_BASE:1.162
	OPENBSD_5_1_BASE:1.160
	OPENBSD_5_1:1.160.0.4
	OPENBSD_5_0:1.160.0.2
	OPENBSD_5_0_BASE:1.160
	OPENBSD_4_9:1.159.0.8
	OPENBSD_4_9_BASE:1.159
	OPENBSD_4_8:1.159.0.6
	OPENBSD_4_8_BASE:1.159
	OPENBSD_4_7:1.159.0.2
	OPENBSD_4_7_BASE:1.159
	OPENBSD_4_6:1.159.0.4
	OPENBSD_4_6_BASE:1.159
	OPENBSD_4_5:1.157.0.2
	OPENBSD_4_5_BASE:1.157
	OPENBSD_4_4:1.153.0.2
	OPENBSD_4_4_BASE:1.153
	OPENBSD_4_3:1.148.0.2
	OPENBSD_4_3_BASE:1.148
	OPENBSD_4_2:1.145.0.4
	OPENBSD_4_2_BASE:1.145
	OPENBSD_4_1:1.145.0.2
	OPENBSD_4_1_BASE:1.145
	OPENBSD_4_0:1.144.0.4
	OPENBSD_4_0_BASE:1.144
	OPENBSD_3_9:1.127.0.2
	OPENBSD_3_9_BASE:1.127
	OPENBSD_3_8:1.118.0.2
	OPENBSD_3_8_BASE:1.118
	OPENBSD_3_7:1.117.0.4
	OPENBSD_3_7_BASE:1.117
	OPENBSD_3_6:1.117.0.2
	OPENBSD_3_6_BASE:1.117
	OPENBSD_3_5:1.115.0.2
	OPENBSD_3_5_BASE:1.115
	OPENBSD_3_4:1.110.0.2
	OPENBSD_3_4_BASE:1.110
	OPENBSD_3_3:1.104.0.4
	OPENBSD_3_3_BASE:1.104
	OPENBSD_3_2:1.104.0.2
	OPENBSD_3_2_BASE:1.104
	OPENBSD_3_1:1.101.0.2
	OPENBSD_3_1_BASE:1.101
	OPENBSD_3_0:1.82.0.2
	OPENBSD_3_0_BASE:1.82
	OPENBSD_2_9_BASE:1.61
	OPENBSD_2_9:1.61.0.2
	OPENBSD_2_8:1.34.0.2
	OPENBSD_2_8_BASE:1.34
	OPENBSD_2_7:1.22.0.2
	OPENBSD_2_7_BASE:1.22
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.191
date	2017.02.01.02.59.09;	author dtucker;	state Exp;
branches;
next	1.190;
commitid	e2JoLM95qcfyR1rz;

1.190
date	2017.01.04.05.37.40;	author djm;	state Exp;
branches;
next	1.189;
commitid	HZ5sxmHv8gQoCktA;

1.189
date	2016.12.14.00.36.34;	author djm;	state Exp;
branches;
next	1.188;
commitid	ZA7wleT9y6t4Inez;

1.188
date	2016.11.30.03.00.05;	author djm;	state Exp;
branches;
next	1.187;
commitid	JiLWdRxWiRohf4cK;

1.187
date	2016.10.23.22.04.05;	author dtucker;	state Exp;
branches;
next	1.186;
commitid	v1YsIAvaioz9gRAs;

1.186
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.185;
commitid	ZllbGwdb0fOmLhjK;

1.185
date	2016.08.13.17.47.41;	author markus;	state Exp;
branches;
next	1.184;
commitid	dl4RDERdJITM8DKC;

1.184
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.183;
commitid	kr9hjdmg99uVnhW2;

1.183
date	2016.03.04.03.35.44;	author djm;	state Exp;
branches;
next	1.182;
commitid	3ZrAT9yINnMXfuU4;

1.182
date	2016.02.08.10.57.07;	author djm;	state Exp;
branches;
next	1.181;
commitid	eSwtzi7BWC7eBzrp;

1.181
date	2016.01.14.16.17.40;	author markus;	state Exp;
branches;
next	1.180;
commitid	W9ye0gltieEl87AJ;

1.180
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.179;
commitid	K3glY441IowbrjDE;

1.179
date	2015.11.28.06.41.03;	author djm;	state Exp;
branches;
next	1.178;
commitid	KtmHqrVMPrYnoEy9;

1.178
date	2015.02.20.22.17.21;	author djm;	state Exp;
branches;
next	1.177;
commitid	9L88tCQWzQkTa0uX;

1.177
date	2015.02.16.22.13.32;	author djm;	state Exp;
branches;
next	1.176;
commitid	vWL0dluw4oITNbM8;

1.176
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.175;
commitid	cBx23BaCk6gYBpRj;

1.175
date	2015.01.19.20.16.15;	author markus;	state Exp;
branches;
next	1.174;
commitid	U9l75XYAjMKaQ8Jp;

1.174
date	2015.01.19.20.07.45;	author markus;	state Exp;
branches;
next	1.173;
commitid	GrtSC5ve2VERgUln;

1.173
date	2015.01.19.19.52.16;	author markus;	state Exp;
branches;
next	1.172;
commitid	UHlhoIB5NMb8eAPm;

1.172
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.171;
commitid	z7plx8Gkj6l2sxem;

1.171
date	2014.04.29.13.10.30;	author djm;	state Exp;
branches;
next	1.170;

1.170
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.169;

1.169
date	2013.12.19.00.19.12;	author dtucker;	state Exp;
branches;
next	1.168;

1.168
date	2013.07.12.00.19.59;	author djm;	state Exp;
branches;
next	1.167;

1.167
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.166;

1.166
date	2013.05.16.09.08.41;	author dtucker;	state Exp;
branches;
next	1.165;

1.165
date	2013.05.16.04.09.14;	author dtucker;	state Exp;
branches;
next	1.164;

1.164
date	2012.12.07.01.51.35;	author dtucker;	state Exp;
branches;
next	1.163;

1.163
date	2012.12.02.20.46.11;	author djm;	state Exp;
branches;
next	1.162;

1.162
date	2012.06.20.04.42.58;	author djm;	state Exp;
branches;
next	1.161;

1.161
date	2012.04.11.13.16.19;	author djm;	state Exp;
branches;
next	1.160;

1.160
date	2011.05.15.08.09.01;	author djm;	state Exp;
branches;
next	1.159;

1.159
date	2009.05.28.16.50.16;	author andreas;	state Exp;
branches;
next	1.158;

1.158
date	2009.05.25.06.48.01;	author andreas;	state Exp;
branches;
next	1.157;

1.157
date	2009.02.12.03.16.01;	author djm;	state Exp;
branches;
next	1.156;

1.156
date	2009.02.12.03.00.56;	author djm;	state Exp;
branches;
next	1.155;

1.155
date	2009.01.22.10.02.34;	author djm;	state Exp;
branches;
next	1.154;

1.154
date	2008.12.02.19.08.59;	author markus;	state Exp;
branches;
next	1.153;

1.153
date	2008.06.30.12.15.39;	author djm;	state Exp;
branches;
next	1.152;

1.152
date	2008.06.10.22.15.23;	author djm;	state Exp;
branches;
next	1.151;

1.151
date	2008.05.09.16.21.13;	author markus;	state Exp;
branches;
next	1.150;

1.150
date	2008.05.09.04.55.56;	author djm;	state Exp;
branches;
next	1.149;

1.149
date	2008.05.08.12.02.23;	author djm;	state Exp;
branches;
next	1.148;

1.148
date	2008.02.22.20.44.02;	author dtucker;	state Exp;
branches;
next	1.147;

1.147
date	2008.01.23.01.56.54;	author dtucker;	state Exp;
branches;
next	1.146;

1.146
date	2007.12.28.15.32.24;	author dtucker;	state Exp;
branches;
next	1.145;

1.145
date	2006.10.11.12.38.03;	author markus;	state Exp;
branches;
next	1.144;

1.144
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.144.4.1;
next	1.143;

1.143
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.142;

1.142
date	2006.07.25.02.59.21;	author stevesk;	state Exp;
branches;
next	1.141;

1.141
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.140;

1.140
date	2006.07.20.15.26.15;	author stevesk;	state Exp;
branches;
next	1.139;

1.139
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.138;

1.138
date	2006.07.09.15.15.11;	author stevesk;	state Exp;
branches;
next	1.137;

1.137
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.136;

1.136
date	2006.07.05.02.42.09;	author stevesk;	state Exp;
branches;
next	1.135;

1.135
date	2006.03.25.18.30.55;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.133;

1.133
date	2006.03.20.18.48.34;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2006.03.20.18.14.02;	author deraadt;	state Exp;
branches;
next	1.131;

1.131
date	2006.03.19.18.56.42;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2006.03.19.02.22.32;	author djm;	state Exp;
branches;
next	1.128;

1.128
date	2006.03.04.04.12.58;	author djm;	state Exp;
branches;
next	1.127;

1.127
date	2006.02.20.17.02.44;	author stevesk;	state Exp;
branches
	1.127.2.1;
next	1.126;

1.126
date	2006.02.10.01.44.26;	author stevesk;	state Exp;
branches;
next	1.125;

1.125
date	2006.02.07.01.42.00;	author stevesk;	state Exp;
branches;
next	1.124;

1.124
date	2005.12.13.15.03.02;	author reyk;	state Exp;
branches;
next	1.123;

1.123
date	2005.12.08.18.34.11;	author reyk;	state Exp;
branches;
next	1.122;

1.122
date	2005.12.06.22.38.27;	author reyk;	state Exp;
branches;
next	1.121;

1.121
date	2005.10.31.11.48.29;	author djm;	state Exp;
branches;
next	1.120;

1.120
date	2005.10.30.08.52.17;	author djm;	state Exp;
branches;
next	1.119;

1.119
date	2005.10.10.10.23.08;	author djm;	state Exp;
branches;
next	1.118;

1.118
date	2005.07.17.07.17.55;	author djm;	state Exp;
branches
	1.118.2.1;
next	1.117;

1.117
date	2004.08.11.21.43.05;	author avsm;	state Exp;
branches
	1.117.2.1
	1.117.4.1;
next	1.116;

1.116
date	2004.05.21.11.33.11;	author djm;	state Exp;
branches;
next	1.115;

1.115
date	2004.01.19.21.25.15;	author markus;	state Exp;
branches
	1.115.2.1;
next	1.114;

1.114
date	2003.12.09.15.28.43;	author markus;	state Exp;
branches;
next	1.113;

1.113
date	2003.11.18.00.40.05;	author dtucker;	state Exp;
branches;
next	1.112;

1.112
date	2003.11.04.08.54.09;	author djm;	state Exp;
branches;
next	1.111;

1.111
date	2003.09.23.20.17.11;	author markus;	state Exp;
branches;
next	1.110;

1.110
date	2003.06.24.08.23.46;	author markus;	state Exp;
branches
	1.110.2.1;
next	1.109;

1.109
date	2003.06.04.12.03.59;	author djm;	state Exp;
branches;
next	1.108;

1.108
date	2003.05.11.20.30.24;	author markus;	state Exp;
branches;
next	1.107;

1.107
date	2003.04.02.09.48.07;	author markus;	state Exp;
branches;
next	1.106;

1.106
date	2003.04.01.10.22.21;	author markus;	state Exp;
branches;
next	1.105;

1.105
date	2003.04.01.10.10.23;	author markus;	state Exp;
branches;
next	1.104;

1.104
date	2002.09.19.16.03.15;	author stevesk;	state Exp;
branches
	1.104.2.1
	1.104.4.1;
next	1.103;

1.103
date	2002.06.24.14.33.27;	author markus;	state Exp;
branches;
next	1.102;

1.102
date	2002.06.11.05.46.20;	author mpech;	state Exp;
branches;
next	1.101;

1.101
date	2002.03.30.18.51.15;	author markus;	state Exp;
branches
	1.101.2.1;
next	1.100;

1.100
date	2002.03.24.16.00.27;	author markus;	state Exp;
branches;
next	1.99;

1.99
date	2002.03.18.17.50.31;	author provos;	state Exp;
branches;
next	1.98;

1.98
date	2002.02.06.14.55.16;	author markus;	state Exp;
branches;
next	1.97;

1.97
date	2002.02.03.17.53.25;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2002.01.31.15.00.05;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2002.01.16.13.17.51;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2002.01.10.11.13.29;	author markus;	state Exp;
branches;
next	1.93;

1.93
date	2001.12.28.15.06.00;	author markus;	state Exp;
branches;
next	1.92;

1.92
date	2001.12.28.14.50.54;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2001.12.27.20.39.58;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2001.12.21.12.17.33;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2001.12.20.22.50.24;	author djm;	state Exp;
branches;
next	1.87;

1.87
date	2001.12.19.16.09.39;	author markus;	state Exp;
branches;
next	1.86;

1.86
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2001.12.05.03.50.01;	author itojun;	state Exp;
branches;
next	1.84;

1.84
date	2001.11.22.12.34.22;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2001.11.09.18.59.23;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2001.10.10.22.18.47;	author markus;	state Exp;
branches
	1.82.2.1;
next	1.81;

1.81
date	2001.10.09.21.59.41;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2001.10.09.19.51.18;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2001.10.04.15.12.37;	author markus;	state Exp;
branches;
next	1.78;

1.78
date	2001.10.04.15.05.40;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2001.09.17.21.04.02;	author markus;	state Exp;
branches;
next	1.76;

1.76
date	2001.07.17.21.04.58;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2001.07.15.16.17.08;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2001.07.02.22.52.57;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	2001.07.02.13.59.14;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2001.06.27.02.12.52;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2001.06.25.08.25.39;	author markus;	state Exp;
branches;
next	1.70;

1.70
date	2001.06.23.15.12.19;	author itojun;	state Exp;
branches;
next	1.69;

1.69
date	2001.06.20.13.56.39;	author markus;	state Exp;
branches;
next	1.68;

1.68
date	2001.06.04.23.07.20;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2001.05.31.10.30.16;	author markus;	state Exp;
branches;
next	1.66;

1.66
date	2001.05.30.12.55.12;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2001.05.08.19.17.31;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2001.05.04.23.47.34;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2001.04.29.19.16.52;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2001.04.29.18.32.52;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2001.04.13.22.46.54;	author beck;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2001.04.05.23.39.20;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2001.04.05.10.42.51;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2001.04.04.22.04.35;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2001.04.04.20.25.37;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2001.04.04.14.34.58;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2001.03.16.19.06.29;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2001.03.04.01.46.30;	author djm;	state Exp;
branches;
next	1.53;

1.53
date	2001.03.02.18.54.31;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2001.02.28.21.27.48;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2001.02.23.15.34.53;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2001.02.19.09.53.32;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2001.02.15.23.19.59;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2001.02.15.08.38.04;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2001.02.08.23.11.42;	author dugsong;	state Exp;
branches;
next	1.46;

1.46
date	2001.02.08.19.30.52;	author itojun;	state Exp;
branches;
next	1.45;

1.45
date	2001.02.04.15.32.25;	author stevesk;	state Exp;
branches;
next	1.44;

1.44
date	2001.01.31.20.37.23;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2001.01.29.16.55.37;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2001.01.21.19.05.55;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2001.01.19.15.55.11;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2001.01.18.17.00.00;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2000.12.27.14.19.21;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2000.12.19.23.17.58;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2000.12.11.20.16.22;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2000.12.05.20.34.10;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2000.11.06.23.04.56;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.27.07.32.18;	author markus;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2000.10.16.09.38.44;	author djm;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.14.12.12.09;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.21.11.25.34;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2000.09.21.11.03.51;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2000.09.07.20.40.30;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2000.09.07.20.27.53;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2000.07.07.08.14.28;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.18.04.05.02;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2000.05.25.07.41.19;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2000.05.18.06.35.57;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2000.05.17.08.20.15;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2000.05.02.12.44.38;	author markus;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2000.04.27.15.23.02;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.19.07.05.49;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.14.10.30.33;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.14.10.09.15;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2000.04.06.08.55.22;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.28.20.31.28;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.28.20.22.49;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	99.12.06.20.15.28;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.12.02.20.13.28;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	99.11.24.19.53.51;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	99.11.24.00.26.03;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.11.23.22.25.55;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.11.22.21.02.38;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	99.11.19.19.58.18;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	99.11.16.23.04.18;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.10.04.21.54.40;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	99.10.03.21.02.12;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.10.03.19.22.38;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.10.03.19.17.40;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	99.09.30.08.34.25;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.37;	author deraadt;	state Exp;
branches;
next	;

1.22.2.1
date	2000.06.12.02.37.35;	author jason;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2000.09.01.18.23.22;	author jason;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2000.11.08.21.31.14;	author jason;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2001.03.12.15.44.14;	author jason;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2001.03.21.18.53.02;	author jason;	state Exp;
branches;
next	;

1.34.2.1
date	2001.02.16.20.13.13;	author jason;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2001.02.19.17.19.19;	author jason;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2001.03.21.19.46.28;	author jason;	state Exp;
branches;
next	1.34.2.4;

1.34.2.4
date	2001.05.07.21.09.33;	author jason;	state Exp;
branches;
next	1.34.2.5;

1.34.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.34.2.6;

1.34.2.6
date	2001.11.15.00.14.59;	author miod;	state Exp;
branches;
next	1.34.2.7;

1.34.2.7
date	2001.11.15.22.50.30;	author miod;	state Exp;
branches;
next	1.34.2.8;

1.34.2.8
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.61.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.61.2.3;

1.61.2.3
date	2001.11.15.22.51.15;	author miod;	state Exp;
branches;
next	1.61.2.4;

1.61.2.4
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.61.2.5;

1.61.2.5
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.82.2.1
date	2001.11.14.03.24.39;	author jason;	state Exp;
branches;
next	1.82.2.2;

1.82.2.2
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.82.2.3;

1.82.2.3
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.82.2.4;

1.82.2.4
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.82.2.5;

1.82.2.5
date	2002.06.26.18.22.35;	author miod;	state Exp;
branches;
next	1.82.2.6;

1.82.2.6
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.101.2.1
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.101.2.2;

1.101.2.2
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	;

1.104.2.1
date	2003.09.16.21.20.27;	author brad;	state Exp;
branches;
next	;

1.104.4.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.104.4.2;

1.104.4.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.110.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.110.2.2;

1.110.2.2
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.115.2.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	;

1.117.2.1
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.117.4.1
date	2005.09.04.18.40.03;	author brad;	state Exp;
branches;
next	1.117.4.2;

1.117.4.2
date	2006.02.03.02.53.45;	author brad;	state Exp;
branches;
next	;

1.118.2.1
date	2006.02.03.03.01.57;	author brad;	state Exp;
branches;
next	1.118.2.2;

1.118.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	1.118.2.3;

1.118.2.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.127.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	1.127.2.2;

1.127.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.144.4.1
date	2006.11.08.00.42.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.191
log
@Return true reason for port forwarding failures where feasible rather
than always "administratively prohibited".  bz#2674, ok djm@@
@
text
@/* $OpenBSD: serverloop.c,v 1.190 2017/01/04 05:37:40 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Server main loop for handling the interactive session.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 * SSH2 support by Markus Friedl.
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/queue.h>

#include <netinet/in.h>

#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <signal.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include <stdarg.h>

#include "xmalloc.h"
#include "packet.h"
#include "buffer.h"
#include "log.h"
#include "misc.h"
#include "servconf.h"
#include "canohost.h"
#include "sshpty.h"
#include "channels.h"
#include "compat.h"
#include "ssh2.h"
#include "key.h"
#include "cipher.h"
#include "kex.h"
#include "hostfile.h"
#include "auth.h"
#include "session.h"
#include "dispatch.h"
#include "auth-options.h"
#include "serverloop.h"
#include "ssherr.h"

extern ServerOptions options;

/* XXX */
extern Authctxt *the_authctxt;
extern int use_privsep;

static int no_more_sessions = 0; /* Disallow further sessions. */

/*
 * This SIGCHLD kludge is used to detect when the child exits.  The server
 * will exit after that, as soon as forwarded connections have terminated.
 */

static volatile sig_atomic_t child_terminated = 0;	/* The child has terminated. */

/* Cleanup on signals (!use_privsep case only) */
static volatile sig_atomic_t received_sigterm = 0;

/* prototypes */
static void server_init_dispatch(void);

/*
 * we write to this pipe if a SIGCHLD is caught in order to avoid
 * the race between select() and child_terminated
 */
static int notify_pipe[2];
static void
notify_setup(void)
{
	if (pipe(notify_pipe) < 0) {
		error("pipe(notify_pipe) failed %s", strerror(errno));
	} else if ((fcntl(notify_pipe[0], F_SETFD, FD_CLOEXEC) == -1) ||
	    (fcntl(notify_pipe[1], F_SETFD, FD_CLOEXEC) == -1)) {
		error("fcntl(notify_pipe, F_SETFD) failed %s", strerror(errno));
		close(notify_pipe[0]);
		close(notify_pipe[1]);
	} else {
		set_nonblock(notify_pipe[0]);
		set_nonblock(notify_pipe[1]);
		return;
	}
	notify_pipe[0] = -1;	/* read end */
	notify_pipe[1] = -1;	/* write end */
}
static void
notify_parent(void)
{
	if (notify_pipe[1] != -1)
		(void)write(notify_pipe[1], "", 1);
}
static void
notify_prepare(fd_set *readset)
{
	if (notify_pipe[0] != -1)
		FD_SET(notify_pipe[0], readset);
}
static void
notify_done(fd_set *readset)
{
	char c;

	if (notify_pipe[0] != -1 && FD_ISSET(notify_pipe[0], readset))
		while (read(notify_pipe[0], &c, 1) != -1)
			debug2("notify_done: reading");
}

/*ARGSUSED*/
static void
sigchld_handler(int sig)
{
	int save_errno = errno;
	child_terminated = 1;
	signal(SIGCHLD, sigchld_handler);
	notify_parent();
	errno = save_errno;
}

/*ARGSUSED*/
static void
sigterm_handler(int sig)
{
	received_sigterm = sig;
}

static void
client_alive_check(void)
{
	int channel_id;

	/* timeout, check to see how many we have had */
	if (packet_inc_alive_timeouts() > options.client_alive_count_max) {
		logit("Timeout, client not responding.");
		cleanup_exit(255);
	}

	/*
	 * send a bogus global/channel request with "wantreply",
	 * we should get back a failure
	 */
	if ((channel_id = channel_find_open()) == -1) {
		packet_start(SSH2_MSG_GLOBAL_REQUEST);
		packet_put_cstring("keepalive@@openssh.com");
		packet_put_char(1);	/* boolean: want reply */
	} else {
		channel_request_start(channel_id, "keepalive@@openssh.com", 1);
	}
	packet_send();
}

/*
 * Sleep in select() until we can do something.  This will initialize the
 * select masks.  Upon return, the masks will indicate which descriptors
 * have data or can accept data.  Optionally, a maximum time can be specified
 * for the duration of the wait (0 = infinite).
 */
static void
wait_until_can_do_something(int connection_in, int connection_out,
    fd_set **readsetp, fd_set **writesetp, int *maxfdp,
    u_int *nallocp, u_int64_t max_time_ms)
{
	struct timeval tv, *tvp;
	int ret;
	time_t minwait_secs = 0;
	int client_alive_scheduled = 0;

	/* Allocate and update select() masks for channel descriptors. */
	channel_prepare_select(readsetp, writesetp, maxfdp, nallocp,
	    &minwait_secs, 0);

	/* XXX need proper deadline system for rekey/client alive */
	if (minwait_secs != 0)
		max_time_ms = MINIMUM(max_time_ms, (u_int)minwait_secs * 1000);

	/*
	 * if using client_alive, set the max timeout accordingly,
	 * and indicate that this particular timeout was for client
	 * alive by setting the client_alive_scheduled flag.
	 *
	 * this could be randomized somewhat to make traffic
	 * analysis more difficult, but we're not doing it yet.
	 */
	if (options.client_alive_interval) {
		uint64_t keepalive_ms =
		    (uint64_t)options.client_alive_interval * 1000;

		client_alive_scheduled = 1;
		if (max_time_ms == 0 || max_time_ms > keepalive_ms)
			max_time_ms = keepalive_ms;
	}

#if 0
	/* wrong: bad condition XXX */
	if (channel_not_very_much_buffered_data())
#endif
	FD_SET(connection_in, *readsetp);
	notify_prepare(*readsetp);

	/*
	 * If we have buffered packet data going to the client, mark that
	 * descriptor.
	 */
	if (packet_have_data_to_write())
		FD_SET(connection_out, *writesetp);

	/*
	 * If child has terminated and there is enough buffer space to read
	 * from it, then read as much as is available and exit.
	 */
	if (child_terminated && packet_not_very_much_data_to_write())
		if (max_time_ms == 0 || client_alive_scheduled)
			max_time_ms = 100;

	if (max_time_ms == 0)
		tvp = NULL;
	else {
		tv.tv_sec = max_time_ms / 1000;
		tv.tv_usec = 1000 * (max_time_ms % 1000);
		tvp = &tv;
	}

	/* Wait for something to happen, or the timeout to expire. */
	ret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);

	if (ret == -1) {
		memset(*readsetp, 0, *nallocp);
		memset(*writesetp, 0, *nallocp);
		if (errno != EINTR)
			error("select: %.100s", strerror(errno));
	} else if (ret == 0 && client_alive_scheduled)
		client_alive_check();

	notify_done(*readsetp);
}

/*
 * Processes input from the client and the program.  Input data is stored
 * in buffers and processed later.
 */
static int
process_input(fd_set *readset, int connection_in)
{
	struct ssh *ssh = active_state; /* XXX */
	int len;
	char buf[16384];

	/* Read and buffer any input data from the client. */
	if (FD_ISSET(connection_in, readset)) {
		len = read(connection_in, buf, sizeof(buf));
		if (len == 0) {
			verbose("Connection closed by %.100s port %d",
			    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
			return -1;
		} else if (len < 0) {
			if (errno != EINTR && errno != EAGAIN) {
				verbose("Read error from remote host "
				    "%.100s port %d: %.100s",
				    ssh_remote_ipaddr(ssh),
				    ssh_remote_port(ssh), strerror(errno));
				cleanup_exit(255);
			}
		} else {
			/* Buffer any received data. */
			packet_process_incoming(buf, len);
		}
	}
	return 0;
}

/*
 * Sends data from internal buffers to client program stdin.
 */
static void
process_output(fd_set *writeset, int connection_out)
{
	/* Send any buffered packet data to the client. */
	if (FD_ISSET(connection_out, writeset))
		packet_write_poll();
}

static void
process_buffered_input_packets(void)
{
	dispatch_run(DISPATCH_NONBLOCK, NULL, active_state);
}

static void
collect_children(void)
{
	pid_t pid;
	sigset_t oset, nset;
	int status;

	/* block SIGCHLD while we check for dead children */
	sigemptyset(&nset);
	sigaddset(&nset, SIGCHLD);
	sigprocmask(SIG_BLOCK, &nset, &oset);
	if (child_terminated) {
		debug("Received SIGCHLD.");
		while ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||
		    (pid < 0 && errno == EINTR))
			if (pid > 0)
				session_close_by_pid(pid, status);
		child_terminated = 0;
	}
	sigprocmask(SIG_SETMASK, &oset, NULL);
}

void
server_loop2(Authctxt *authctxt)
{
	fd_set *readset = NULL, *writeset = NULL;
	int max_fd;
	u_int nalloc = 0, connection_in, connection_out;
	u_int64_t rekey_timeout_ms = 0;

	debug("Entering interactive session for SSH2.");

	signal(SIGCHLD, sigchld_handler);
	child_terminated = 0;
	connection_in = packet_get_connection_in();
	connection_out = packet_get_connection_out();

	if (!use_privsep) {
		signal(SIGTERM, sigterm_handler);
		signal(SIGINT, sigterm_handler);
		signal(SIGQUIT, sigterm_handler);
	}

	notify_setup();

	max_fd = MAXIMUM(connection_in, connection_out);
	max_fd = MAXIMUM(max_fd, notify_pipe[0]);

	server_init_dispatch();

	for (;;) {
		process_buffered_input_packets();

		if (!ssh_packet_is_rekeying(active_state) &&
		    packet_not_very_much_data_to_write())
			channel_output_poll();
		if (options.rekey_interval > 0 &&
		    !ssh_packet_is_rekeying(active_state))
			rekey_timeout_ms = packet_get_rekey_timeout() * 1000;
		else
			rekey_timeout_ms = 0;

		wait_until_can_do_something(connection_in, connection_out,
		    &readset, &writeset, &max_fd, &nalloc, rekey_timeout_ms);

		if (received_sigterm) {
			logit("Exiting on signal %d", (int)received_sigterm);
			/* Clean up sessions, utmp, etc. */
			cleanup_exit(255);
		}

		collect_children();
		if (!ssh_packet_is_rekeying(active_state))
			channel_after_select(readset, writeset);
		if (process_input(readset, connection_in) < 0)
			break;
		process_output(writeset, connection_out);
	}
	collect_children();

	free(readset);
	free(writeset);

	/* free all channels, no more reads and writes */
	channel_free_all();

	/* free remaining sessions, e.g. remove wtmp entries */
	session_destroy_all(NULL);
}

static int
server_input_keep_alive(int type, u_int32_t seq, void *ctxt)
{
	debug("Got %d/%u for keepalive", type, seq);
	/*
	 * reset timeout, since we got a sane answer from the client.
	 * even if this was generated by something other than
	 * the bogus CHANNEL_REQUEST we send for keepalives.
	 */
	packet_set_alive_timeouts(0);
	return 0;
}

static Channel *
server_request_direct_tcpip(int *reason, const char **errmsg)
{
	Channel *c = NULL;
	char *target, *originator;
	u_short target_port, originator_port;

	target = packet_get_string(NULL);
	target_port = packet_get_int();
	originator = packet_get_string(NULL);
	originator_port = packet_get_int();
	packet_check_eom();

	debug("server_request_direct_tcpip: originator %s port %d, target %s "
	    "port %d", originator, originator_port, target, target_port);

	/* XXX fine grained permissions */
	if ((options.allow_tcp_forwarding & FORWARD_LOCAL) != 0 &&
	    !no_port_forwarding_flag && !options.disable_forwarding) {
		c = channel_connect_to_port(target, target_port,
		    "direct-tcpip", "direct-tcpip", reason, errmsg);
	} else {
		logit("refused local port forward: "
		    "originator %s port %d, target %s port %d",
		    originator, originator_port, target, target_port);
		if (reason != NULL)
			*reason = SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED;
	}

	free(originator);
	free(target);

	return c;
}

static Channel *
server_request_direct_streamlocal(void)
{
	Channel *c = NULL;
	char *target, *originator;
	u_short originator_port;
	struct passwd *pw = the_authctxt->pw;

	if (pw == NULL || !the_authctxt->valid)
		fatal("server_input_global_request: no/invalid user");

	target = packet_get_string(NULL);
	originator = packet_get_string(NULL);
	originator_port = packet_get_int();
	packet_check_eom();

	debug("server_request_direct_streamlocal: originator %s port %d, target %s",
	    originator, originator_port, target);

	/* XXX fine grained permissions */
	if ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&
	    !no_port_forwarding_flag && !options.disable_forwarding &&
	    (pw->pw_uid == 0 || use_privsep)) {
		c = channel_connect_to_path(target,
		    "direct-streamlocal@@openssh.com", "direct-streamlocal");
	} else {
		logit("refused streamlocal port forward: "
		    "originator %s port %d, target %s",
		    originator, originator_port, target);
	}

	free(originator);
	free(target);

	return c;
}

static Channel *
server_request_tun(void)
{
	Channel *c = NULL;
	int mode, tun;
	int sock;

	mode = packet_get_int();
	switch (mode) {
	case SSH_TUNMODE_POINTOPOINT:
	case SSH_TUNMODE_ETHERNET:
		break;
	default:
		packet_send_debug("Unsupported tunnel device mode.");
		return NULL;
	}
	if ((options.permit_tun & mode) == 0) {
		packet_send_debug("Server has rejected tunnel device "
		    "forwarding");
		return NULL;
	}

	tun = packet_get_int();
	if (forced_tun_device != -1) {
		if (tun != SSH_TUNID_ANY && forced_tun_device != tun)
			goto done;
		tun = forced_tun_device;
	}
	sock = tun_open(tun, mode);
	if (sock < 0)
		goto done;
	c = channel_new("tun", SSH_CHANNEL_OPEN, sock, sock, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, "tun", 1);
	c->datagram = 1;

 done:
	if (c == NULL)
		packet_send_debug("Failed to open the tunnel device.");
	return c;
}

static Channel *
server_request_session(void)
{
	Channel *c;

	debug("input_session_request");
	packet_check_eom();

	if (no_more_sessions) {
		packet_disconnect("Possible attack: attempt to open a session "
		    "after additional sessions disabled");
	}

	/*
	 * A server session has no fd to read or write until a
	 * CHANNEL_REQUEST for a shell is made, so we set the type to
	 * SSH_CHANNEL_LARVAL.  Additionally, a callback for handling all
	 * CHANNEL_REQUEST messages is registered.
	 */
	c = channel_new("session", SSH_CHANNEL_LARVAL,
	    -1, -1, -1, /*window size*/0, CHAN_SES_PACKET_DEFAULT,
	    0, "server-session", 1);
	if (session_open(the_authctxt, c->self) != 1) {
		debug("session open failed, free channel %d", c->self);
		channel_free(c);
		return NULL;
	}
	channel_register_cleanup(c->self, session_close_by_channel, 0);
	return c;
}

static int
server_input_channel_open(int type, u_int32_t seq, void *ctxt)
{
	Channel *c = NULL;
	char *ctype;
	const char *errmsg = NULL;
	int rchan, reason = SSH2_OPEN_CONNECT_FAILED;
	u_int rmaxpack, rwindow, len;

	ctype = packet_get_string(&len);
	rchan = packet_get_int();
	rwindow = packet_get_int();
	rmaxpack = packet_get_int();

	debug("server_input_channel_open: ctype %s rchan %d win %d max %d",
	    ctype, rchan, rwindow, rmaxpack);

	if (strcmp(ctype, "session") == 0) {
		c = server_request_session();
	} else if (strcmp(ctype, "direct-tcpip") == 0) {
		c = server_request_direct_tcpip(&reason, &errmsg);
	} else if (strcmp(ctype, "direct-streamlocal@@openssh.com") == 0) {
		c = server_request_direct_streamlocal();
	} else if (strcmp(ctype, "tun@@openssh.com") == 0) {
		c = server_request_tun();
	}
	if (c != NULL) {
		debug("server_input_channel_open: confirm %s", ctype);
		c->remote_id = rchan;
		c->remote_window = rwindow;
		c->remote_maxpacket = rmaxpack;
		if (c->type != SSH_CHANNEL_CONNECTING) {
			packet_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);
			packet_put_int(c->remote_id);
			packet_put_int(c->self);
			packet_put_int(c->local_window);
			packet_put_int(c->local_maxpacket);
			packet_send();
		}
	} else {
		debug("server_input_channel_open: failure %s", ctype);
		packet_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(rchan);
		packet_put_int(reason);
		if (!(datafellows & SSH_BUG_OPENFAILURE)) {
			packet_put_cstring(errmsg ? errmsg : "open failed");
			packet_put_cstring("");
		}
		packet_send();
	}
	free(ctype);
	return 0;
}

static int
server_input_hostkeys_prove(struct sshbuf **respp)
{
	struct ssh *ssh = active_state; /* XXX */
	struct sshbuf *resp = NULL;
	struct sshbuf *sigbuf = NULL;
	struct sshkey *key = NULL, *key_pub = NULL, *key_prv = NULL;
	int r, ndx, success = 0;
	const u_char *blob;
	u_char *sig = 0;
	size_t blen, slen;

	if ((resp = sshbuf_new()) == NULL || (sigbuf = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new", __func__);

	while (ssh_packet_remaining(ssh) > 0) {
		sshkey_free(key);
		key = NULL;
		if ((r = sshpkt_get_string_direct(ssh, &blob, &blen)) != 0 ||
		    (r = sshkey_from_blob(blob, blen, &key)) != 0) {
			error("%s: couldn't parse key: %s",
			    __func__, ssh_err(r));
			goto out;
		}
		/*
		 * Better check that this is actually one of our hostkeys
		 * before attempting to sign anything with it.
		 */
		if ((ndx = ssh->kex->host_key_index(key, 1, ssh)) == -1) {
			error("%s: unknown host %s key",
			    __func__, sshkey_type(key));
			goto out;
		}
		/*
		 * XXX refactor: make kex->sign just use an index rather
		 * than passing in public and private keys
		 */
		if ((key_prv = get_hostkey_by_index(ndx)) == NULL &&
		    (key_pub = get_hostkey_public_by_index(ndx, ssh)) == NULL) {
			error("%s: can't retrieve hostkey %d", __func__, ndx);
			goto out;
		}
		sshbuf_reset(sigbuf);
		free(sig);
		sig = NULL;
		if ((r = sshbuf_put_cstring(sigbuf,
		    "hostkeys-prove-00@@openssh.com")) != 0 ||
		    (r = sshbuf_put_string(sigbuf,
		    ssh->kex->session_id, ssh->kex->session_id_len)) != 0 ||
		    (r = sshkey_puts(key, sigbuf)) != 0 ||
		    (r = ssh->kex->sign(key_prv, key_pub, &sig, &slen,
		    sshbuf_ptr(sigbuf), sshbuf_len(sigbuf), NULL, 0)) != 0 ||
		    (r = sshbuf_put_string(resp, sig, slen)) != 0) {
			error("%s: couldn't prepare signature: %s",
			    __func__, ssh_err(r));
			goto out;
		}
	}
	/* Success */
	*respp = resp;
	resp = NULL; /* don't free it */
	success = 1;
 out:
	free(sig);
	sshbuf_free(resp);
	sshbuf_free(sigbuf);
	sshkey_free(key);
	return success;
}

static int
server_input_global_request(int type, u_int32_t seq, void *ctxt)
{
	char *rtype;
	int want_reply;
	int r, success = 0, allocated_listen_port = 0;
	struct sshbuf *resp = NULL;
	struct passwd *pw = the_authctxt->pw;

	if (pw == NULL || !the_authctxt->valid)
		fatal("server_input_global_request: no/invalid user");

	rtype = packet_get_string(NULL);
	want_reply = packet_get_char();
	debug("server_input_global_request: rtype %s want_reply %d", rtype, want_reply);

	/* -R style forwarding */
	if (strcmp(rtype, "tcpip-forward") == 0) {
		struct Forward fwd;

		memset(&fwd, 0, sizeof(fwd));
		fwd.listen_host = packet_get_string(NULL);
		fwd.listen_port = (u_short)packet_get_int();
		debug("server_input_global_request: tcpip-forward listen %s port %d",
		    fwd.listen_host, fwd.listen_port);

		/* check permissions */
		if ((options.allow_tcp_forwarding & FORWARD_REMOTE) == 0 ||
		    no_port_forwarding_flag || options.disable_forwarding ||
		    (!want_reply && fwd.listen_port == 0) ||
		    (fwd.listen_port != 0 &&
		     !bind_permitted(fwd.listen_port, pw->pw_uid))) {
			success = 0;
			packet_send_debug("Server has disabled port forwarding.");
		} else {
			/* Start listening on the port */
			success = channel_setup_remote_fwd_listener(&fwd,
			    &allocated_listen_port, &options.fwd_opts);
		}
		free(fwd.listen_host);
		if ((resp = sshbuf_new()) == NULL)
			fatal("%s: sshbuf_new", __func__);
		if (allocated_listen_port != 0 &&
		    (r = sshbuf_put_u32(resp, allocated_listen_port)) != 0)
			fatal("%s: sshbuf_put_u32: %s", __func__, ssh_err(r));
	} else if (strcmp(rtype, "cancel-tcpip-forward") == 0) {
		struct Forward fwd;

		memset(&fwd, 0, sizeof(fwd));
		fwd.listen_host = packet_get_string(NULL);
		fwd.listen_port = (u_short)packet_get_int();
		debug("%s: cancel-tcpip-forward addr %s port %d", __func__,
		    fwd.listen_host, fwd.listen_port);

		success = channel_cancel_rport_listener(&fwd);
		free(fwd.listen_host);
	} else if (strcmp(rtype, "streamlocal-forward@@openssh.com") == 0) {
		struct Forward fwd;

		memset(&fwd, 0, sizeof(fwd));
		fwd.listen_path = packet_get_string(NULL);
		debug("server_input_global_request: streamlocal-forward listen path %s",
		    fwd.listen_path);

		/* check permissions */
		if ((options.allow_streamlocal_forwarding & FORWARD_REMOTE) == 0
		    || no_port_forwarding_flag || options.disable_forwarding ||
		    (pw->pw_uid != 0 && !use_privsep)) {
			success = 0;
			packet_send_debug("Server has disabled "
			    "streamlocal forwarding.");
		} else {
			/* Start listening on the socket */
			success = channel_setup_remote_fwd_listener(
			    &fwd, NULL, &options.fwd_opts);
		}
		free(fwd.listen_path);
	} else if (strcmp(rtype, "cancel-streamlocal-forward@@openssh.com") == 0) {
		struct Forward fwd;

		memset(&fwd, 0, sizeof(fwd));
		fwd.listen_path = packet_get_string(NULL);
		debug("%s: cancel-streamlocal-forward path %s", __func__,
		    fwd.listen_path);

		success = channel_cancel_rport_listener(&fwd);
		free(fwd.listen_path);
	} else if (strcmp(rtype, "no-more-sessions@@openssh.com") == 0) {
		no_more_sessions = 1;
		success = 1;
	} else if (strcmp(rtype, "hostkeys-prove-00@@openssh.com") == 0) {
		success = server_input_hostkeys_prove(&resp);
	}
	if (want_reply) {
		packet_start(success ?
		    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);
		if (success && resp != NULL)
			ssh_packet_put_raw(active_state, sshbuf_ptr(resp),
			    sshbuf_len(resp));
		packet_send();
		packet_write_wait();
	}
	free(rtype);
	sshbuf_free(resp);
	return 0;
}

static int
server_input_channel_req(int type, u_int32_t seq, void *ctxt)
{
	Channel *c;
	int id, reply, success = 0;
	char *rtype;

	id = packet_get_int();
	rtype = packet_get_string(NULL);
	reply = packet_get_char();

	debug("server_input_channel_req: channel %d request %s reply %d",
	    id, rtype, reply);

	if ((c = channel_lookup(id)) == NULL)
		packet_disconnect("server_input_channel_req: "
		    "unknown channel %d", id);
	if (!strcmp(rtype, "eow@@openssh.com")) {
		packet_check_eom();
		chan_rcvd_eow(c);
	} else if ((c->type == SSH_CHANNEL_LARVAL ||
	    c->type == SSH_CHANNEL_OPEN) && strcmp(c->ctype, "session") == 0)
		success = session_input_channel_req(c, rtype);
	if (reply && !(c->flags & CHAN_CLOSE_SENT)) {
		packet_start(success ?
		    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);
		packet_put_int(c->remote_id);
		packet_send();
	}
	free(rtype);
	return 0;
}

static void
server_init_dispatch(void)
{
	debug("server_init_dispatch");
	dispatch_init(&dispatch_protocol_error);
	dispatch_set(SSH2_MSG_CHANNEL_CLOSE, &channel_input_oclose);
	dispatch_set(SSH2_MSG_CHANNEL_DATA, &channel_input_data);
	dispatch_set(SSH2_MSG_CHANNEL_EOF, &channel_input_ieof);
	dispatch_set(SSH2_MSG_CHANNEL_EXTENDED_DATA, &channel_input_extended_data);
	dispatch_set(SSH2_MSG_CHANNEL_OPEN, &server_input_channel_open);
	dispatch_set(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);
	dispatch_set(SSH2_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);
	dispatch_set(SSH2_MSG_CHANNEL_REQUEST, &server_input_channel_req);
	dispatch_set(SSH2_MSG_CHANNEL_WINDOW_ADJUST, &channel_input_window_adjust);
	dispatch_set(SSH2_MSG_GLOBAL_REQUEST, &server_input_global_request);
	/* client_alive */
	dispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &server_input_keep_alive);
	dispatch_set(SSH2_MSG_CHANNEL_FAILURE, &server_input_keep_alive);
	dispatch_set(SSH2_MSG_REQUEST_SUCCESS, &server_input_keep_alive);
	dispatch_set(SSH2_MSG_REQUEST_FAILURE, &server_input_keep_alive);
	/* rekeying */
	dispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);
}
@


1.190
log
@unbreak Unix domain socket forwarding for root; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.189 2016/12/14 00:36:34 djm Exp $ */
d426 1
a426 1
server_request_direct_tcpip(void)
d445 1
a445 1
		    "direct-tcpip", "direct-tcpip");
d450 2
d574 2
a575 1
	int rchan;
d589 1
a589 1
		c = server_request_direct_tcpip();
d612 1
a612 1
		packet_put_int(SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED);
d614 1
a614 1
			packet_put_cstring("open failed");
@


1.189
log
@disable Unix-domain socket forwarding when privsep is disabled
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.188 2016/11/30 03:00:05 djm Exp $ */
d464 4
d480 1
a480 1
	    use_privsep) {
d697 4
a707 1
		struct passwd *pw;
a709 3
		pw = the_authctxt->pw;
		if (pw == NULL || !the_authctxt->valid)
			fatal("server_input_global_request: no/invalid user");
d757 1
a757 1
		    !use_privsep) {
d759 2
a760 1
			packet_send_debug("Server has disabled port forwarding.");
@


1.188
log
@Add a sshd_config DisableForwaring option that disables X11, agent,
TCP, tunnel and Unix domain socket forwarding, as well as anything
else we might implement in the future.

This, like the 'restrict' authorized_keys flag, is intended to be a
simple and future-proof way of restricting an account. Suggested as
a complement to 'restrict' by Jann Horn; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.187 2016/10/23 22:04:05 dtucker Exp $ */
d475 2
a476 1
	    !no_port_forwarding_flag && !options.disable_forwarding) {
d752 2
a753 1
		    || no_port_forwarding_flag || options.disable_forwarding) {
@


1.187
log
@Factor out "can bind to low ports" check into its own function.  This will make
it easier for Portable to support platforms with permissions models other than
uid==0 (eg bz#2625).  ok djm@@, "doesn't offend me too much" deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.186 2016/09/12 01:22:38 deraadt Exp $ */
d443 1
a443 1
	    !no_port_forwarding_flag) {
d475 1
a475 1
	    !no_port_forwarding_flag) {
d713 1
a713 1
		    no_port_forwarding_flag ||
d751 1
a751 1
		    || no_port_forwarding_flag) {
@


1.186
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.185 2016/08/13 17:47:41 markus Exp $ */
d715 2
a716 2
		    (fwd.listen_port != 0 && fwd.listen_port < IPPORT_RESERVED &&
		    pw->pw_uid != 0)) {
@


1.185
log
@remove ssh1 server code; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.184 2016/03/07 19:02:43 djm Exp $ */
a37 1
#include <sys/param.h>	/* MIN MAX */
d208 1
a208 1
		max_time_ms = MIN(max_time_ms, (u_int)minwait_secs * 1000);
d367 2
a368 2
	max_fd = MAX(connection_in, connection_out);
	max_fd = MAX(max_fd, notify_pipe[0]);
@


1.184
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.183 2016/03/04 03:35:44 djm Exp $ */
a65 1
#include "ssh1.h"
a83 19
static Buffer stdin_buffer;	/* Buffer for stdin data. */
static Buffer stdout_buffer;	/* Buffer for stdout data. */
static Buffer stderr_buffer;	/* Buffer for stderr data. */
static int fdin;		/* Descriptor for stdin (for writing) */
static int fdout;		/* Descriptor for stdout (for reading);
				   May be same number as fdin. */
static int fderr;		/* Descriptor for stderr.  May be -1. */
static long stdin_bytes = 0;	/* Number of bytes written to stdin. */
static long stdout_bytes = 0;	/* Number of stdout bytes sent to client. */
static long stderr_bytes = 0;	/* Number of stderr bytes sent to client. */
static long fdout_bytes = 0;	/* Number of stdout bytes read from program. */
static int stdin_eof = 0;	/* EOF message received from client. */
static int fdout_eof = 0;	/* EOF encountered reading from fdout. */
static int fderr_eof = 0;	/* EOF encountered readung from fderr. */
static int fdin_is_tty = 0;	/* fdin points to a tty. */
static int connection_in;	/* Connection to client (input). */
static int connection_out;	/* Connection to client (output). */
static int connection_closed = 0;	/* Connection to client closed. */
static u_int buffer_high;	/* "Soft" max buffer size. */
a161 58
/*
 * Make packets from buffered stderr data, and buffer it for sending
 * to the client.
 */
static void
make_packets_from_stderr_data(void)
{
	u_int len;

	/* Send buffered stderr data to the client. */
	while (buffer_len(&stderr_buffer) > 0 &&
	    packet_not_very_much_data_to_write()) {
		len = buffer_len(&stderr_buffer);
		if (packet_is_interactive()) {
			if (len > 512)
				len = 512;
		} else {
			/* Keep the packets at reasonable size. */
			if (len > packet_get_maxsize())
				len = packet_get_maxsize();
		}
		packet_start(SSH_SMSG_STDERR_DATA);
		packet_put_string(buffer_ptr(&stderr_buffer), len);
		packet_send();
		buffer_consume(&stderr_buffer, len);
		stderr_bytes += len;
	}
}

/*
 * Make packets from buffered stdout data, and buffer it for sending to the
 * client.
 */
static void
make_packets_from_stdout_data(void)
{
	u_int len;

	/* Send buffered stdout data to the client. */
	while (buffer_len(&stdout_buffer) > 0 &&
	    packet_not_very_much_data_to_write()) {
		len = buffer_len(&stdout_buffer);
		if (packet_is_interactive()) {
			if (len > 512)
				len = 512;
		} else {
			/* Keep the packets at reasonable size. */
			if (len > packet_get_maxsize())
				len = packet_get_maxsize();
		}
		packet_start(SSH_SMSG_STDOUT_DATA);
		packet_put_string(buffer_ptr(&stdout_buffer), len);
		packet_send();
		buffer_consume(&stdout_buffer, len);
		stdout_bytes += len;
	}
}

d194 2
a195 1
wait_until_can_do_something(fd_set **readsetp, fd_set **writesetp, int *maxfdp,
d219 1
a219 1
	if (compat20 && options.client_alive_interval) {
a227 1
	if (compat20) {
d229 2
a230 2
		/* wrong: bad condition XXX */
		if (channel_not_very_much_buffered_data())
d232 1
a232 26
		FD_SET(connection_in, *readsetp);
	} else {
		/*
		 * Read packets from the client unless we have too much
		 * buffered stdin or channel data.
		 */
		if (buffer_len(&stdin_buffer) < buffer_high &&
		    channel_not_very_much_buffered_data())
			FD_SET(connection_in, *readsetp);
		/*
		 * If there is not too much data already buffered going to
		 * the client, try to get some more data from the program.
		 */
		if (packet_not_very_much_data_to_write()) {
			if (!fdout_eof)
				FD_SET(fdout, *readsetp);
			if (!fderr_eof)
				FD_SET(fderr, *readsetp);
		}
		/*
		 * If we have buffered data, try to write some of that data
		 * to the program.
		 */
		if (fdin != -1 && buffer_len(&stdin_buffer) > 0)
			FD_SET(fdin, *writesetp);
	}
d276 2
a277 2
static void
process_input(fd_set *readset)
d289 1
a289 4
			connection_closed = 1;
			if (compat20)
				return;
			cleanup_exit(255);
d303 1
a303 26
	if (compat20)
		return;

	/* Read and buffer any available stdout data from the program. */
	if (!fdout_eof && FD_ISSET(fdout, readset)) {
		len = read(fdout, buf, sizeof(buf));
		if (len < 0 && (errno == EINTR || errno == EAGAIN)) {
			/* do nothing */
		} else if (len <= 0) {
			fdout_eof = 1;
		} else {
			buffer_append(&stdout_buffer, buf, len);
			fdout_bytes += len;
		}
	}
	/* Read and buffer any available stderr data from the program. */
	if (!fderr_eof && FD_ISSET(fderr, readset)) {
		len = read(fderr, buf, sizeof(buf));
		if (len < 0 && (errno == EINTR || errno == EAGAIN)) {
			/* do nothing */
		} else if (len <= 0) {
			fderr_eof = 1;
		} else {
			buffer_append(&stderr_buffer, buf, len);
		}
	}
d310 1
a310 1
process_output(fd_set *writeset)
a311 36
	struct termios tio;
	u_char *data;
	u_int dlen;
	int len;

	/* Write buffered data to program stdin. */
	if (!compat20 && fdin != -1 && FD_ISSET(fdin, writeset)) {
		data = buffer_ptr(&stdin_buffer);
		dlen = buffer_len(&stdin_buffer);
		len = write(fdin, data, dlen);
		if (len < 0 && (errno == EINTR || errno == EAGAIN)) {
			/* do nothing */
		} else if (len <= 0) {
			if (fdin != fdout)
				close(fdin);
			else
				shutdown(fdin, SHUT_WR); /* We will no longer send. */
			fdin = -1;
		} else {
			/* Successful write. */
			if (fdin_is_tty && dlen >= 1 && data[0] != '\r' &&
			    tcgetattr(fdin, &tio) == 0 &&
			    !(tio.c_lflag & ECHO) && (tio.c_lflag & ICANON)) {
				/*
				 * Simulate echo to reduce the impact of
				 * traffic analysis
				 */
				packet_send_ignore(len);
				packet_send();
			}
			/* Consume the data from the buffer. */
			buffer_consume(&stdin_buffer, len);
			/* Update the count of bytes written to the program. */
			stdin_bytes += len;
		}
	}
a316 29
/*
 * Wait until all buffered output has been sent to the client.
 * This is used when the program terminates.
 */
static void
drain_output(void)
{
	/* Send any buffered stdout data to the client. */
	if (buffer_len(&stdout_buffer) > 0) {
		packet_start(SSH_SMSG_STDOUT_DATA);
		packet_put_string(buffer_ptr(&stdout_buffer),
				  buffer_len(&stdout_buffer));
		packet_send();
		/* Update the count of sent bytes. */
		stdout_bytes += buffer_len(&stdout_buffer);
	}
	/* Send any buffered stderr data to the client. */
	if (buffer_len(&stderr_buffer) > 0) {
		packet_start(SSH_SMSG_STDERR_DATA);
		packet_put_string(buffer_ptr(&stderr_buffer),
				  buffer_len(&stderr_buffer));
		packet_send();
		/* Update the count of sent bytes. */
		stderr_bytes += buffer_len(&stderr_buffer);
	}
	/* Wait until all buffered data has been written to the client. */
	packet_write_wait();
}

a322 250
/*
 * Performs the interactive session.  This handles data transmission between
 * the client and the program.  Note that the notion of stdin, stdout, and
 * stderr in this function is sort of reversed: this function writes to
 * stdin (of the child program), and reads from stdout and stderr (of the
 * child program).
 */
void
server_loop(pid_t pid, int fdin_arg, int fdout_arg, int fderr_arg)
{
	fd_set *readset = NULL, *writeset = NULL;
	int max_fd = 0;
	u_int nalloc = 0;
	int wait_status;	/* Status returned by wait(). */
	pid_t wait_pid;		/* pid returned by wait(). */
	int waiting_termination = 0;	/* Have displayed waiting close message. */
	u_int64_t max_time_milliseconds;
	u_int previous_stdout_buffer_bytes;
	u_int stdout_buffer_bytes;
	int type;

	debug("Entering interactive session.");

	/* Initialize the SIGCHLD kludge. */
	child_terminated = 0;
	signal(SIGCHLD, sigchld_handler);

	if (!use_privsep) {
		signal(SIGTERM, sigterm_handler);
		signal(SIGINT, sigterm_handler);
		signal(SIGQUIT, sigterm_handler);
	}

	/* Initialize our global variables. */
	fdin = fdin_arg;
	fdout = fdout_arg;
	fderr = fderr_arg;

	/* nonblocking IO */
	set_nonblock(fdin);
	set_nonblock(fdout);
	/* we don't have stderr for interactive terminal sessions, see below */
	if (fderr != -1)
		set_nonblock(fderr);

	if (!(datafellows & SSH_BUG_IGNOREMSG) && isatty(fdin))
		fdin_is_tty = 1;

	connection_in = packet_get_connection_in();
	connection_out = packet_get_connection_out();

	notify_setup();

	previous_stdout_buffer_bytes = 0;

	/* Set approximate I/O buffer size. */
	if (packet_is_interactive())
		buffer_high = 4096;
	else
		buffer_high = 64 * 1024;

#if 0
	/* Initialize max_fd to the maximum of the known file descriptors. */
	max_fd = MAX(connection_in, connection_out);
	max_fd = MAX(max_fd, fdin);
	max_fd = MAX(max_fd, fdout);
	if (fderr != -1)
		max_fd = MAX(max_fd, fderr);
#endif

	/* Initialize Initialize buffers. */
	buffer_init(&stdin_buffer);
	buffer_init(&stdout_buffer);
	buffer_init(&stderr_buffer);

	/*
	 * If we have no separate fderr (which is the case when we have a pty
	 * - there we cannot make difference between data sent to stdout and
	 * stderr), indicate that we have seen an EOF from stderr.  This way
	 * we don't need to check the descriptor everywhere.
	 */
	if (fderr == -1)
		fderr_eof = 1;

	server_init_dispatch();

	/* Main loop of the server for the interactive session mode. */
	for (;;) {

		/* Process buffered packets from the client. */
		process_buffered_input_packets();

		/*
		 * If we have received eof, and there is no more pending
		 * input data, cause a real eof by closing fdin.
		 */
		if (stdin_eof && fdin != -1 && buffer_len(&stdin_buffer) == 0) {
			if (fdin != fdout)
				close(fdin);
			else
				shutdown(fdin, SHUT_WR); /* We will no longer send. */
			fdin = -1;
		}
		/* Make packets from buffered stderr data to send to the client. */
		make_packets_from_stderr_data();

		/*
		 * Make packets from buffered stdout data to send to the
		 * client. If there is very little to send, this arranges to
		 * not send them now, but to wait a short while to see if we
		 * are getting more data. This is necessary, as some systems
		 * wake up readers from a pty after each separate character.
		 */
		max_time_milliseconds = 0;
		stdout_buffer_bytes = buffer_len(&stdout_buffer);
		if (stdout_buffer_bytes != 0 && stdout_buffer_bytes < 256 &&
		    stdout_buffer_bytes != previous_stdout_buffer_bytes) {
			/* try again after a while */
			max_time_milliseconds = 10;
		} else {
			/* Send it now. */
			make_packets_from_stdout_data();
		}
		previous_stdout_buffer_bytes = buffer_len(&stdout_buffer);

		/* Send channel data to the client. */
		if (packet_not_very_much_data_to_write())
			channel_output_poll();

		/*
		 * Bail out of the loop if the program has closed its output
		 * descriptors, and we have no more data to send to the
		 * client, and there is no pending buffered data.
		 */
		if (fdout_eof && fderr_eof && !packet_have_data_to_write() &&
		    buffer_len(&stdout_buffer) == 0 && buffer_len(&stderr_buffer) == 0) {
			if (!channel_still_open())
				break;
			if (!waiting_termination) {
				const char *s = "Waiting for forwarded connections to terminate...\r\n";
				char *cp;
				waiting_termination = 1;
				buffer_append(&stderr_buffer, s, strlen(s));

				/* Display list of open channels. */
				cp = channel_open_message();
				buffer_append(&stderr_buffer, cp, strlen(cp));
				free(cp);
			}
		}
		max_fd = MAX(connection_in, connection_out);
		max_fd = MAX(max_fd, fdin);
		max_fd = MAX(max_fd, fdout);
		max_fd = MAX(max_fd, fderr);
		max_fd = MAX(max_fd, notify_pipe[0]);

		/* Sleep in select() until we can do something. */
		wait_until_can_do_something(&readset, &writeset, &max_fd,
		    &nalloc, max_time_milliseconds);

		if (received_sigterm) {
			logit("Exiting on signal %d", (int)received_sigterm);
			/* Clean up sessions, utmp, etc. */
			cleanup_exit(255);
		}

		/* Process any channel events. */
		channel_after_select(readset, writeset);

		/* Process input from the client and from program stdout/stderr. */
		process_input(readset);

		/* Process output to the client and to program stdin. */
		process_output(writeset);
	}
	free(readset);
	free(writeset);

	/* Cleanup and termination code. */

	/* Wait until all output has been sent to the client. */
	drain_output();

	debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
	    stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);

	/* Free and clear the buffers. */
	buffer_free(&stdin_buffer);
	buffer_free(&stdout_buffer);
	buffer_free(&stderr_buffer);

	/* Close the file descriptors. */
	if (fdout != -1)
		close(fdout);
	fdout = -1;
	fdout_eof = 1;
	if (fderr != -1)
		close(fderr);
	fderr = -1;
	fderr_eof = 1;
	if (fdin != -1)
		close(fdin);
	fdin = -1;

	channel_free_all();

	/* We no longer want our SIGCHLD handler to be called. */
	signal(SIGCHLD, SIG_DFL);

	while ((wait_pid = waitpid(-1, &wait_status, 0)) < 0)
		if (errno != EINTR)
			packet_disconnect("wait: %.100s", strerror(errno));
	if (wait_pid != pid)
		error("Strange, wait returned pid %ld, expected %ld",
		    (long)wait_pid, (long)pid);

	/* Check if it exited normally. */
	if (WIFEXITED(wait_status)) {
		/* Yes, normal exit.  Get exit status and send it to the client. */
		debug("Command exited with status %d.", WEXITSTATUS(wait_status));
		packet_start(SSH_SMSG_EXITSTATUS);
		packet_put_int(WEXITSTATUS(wait_status));
		packet_send();
		packet_write_wait();

		/*
		 * Wait for exit confirmation.  Note that there might be
		 * other packets coming before it; however, the program has
		 * already died so we just ignore them.  The client is
		 * supposed to respond with the confirmation when it receives
		 * the exit status.
		 */
		do {
			type = packet_read();
		}
		while (type != SSH_CMSG_EXIT_CONFIRMATION);

		debug("Received exit confirmation.");
		return;
	}
	/* Check if the program terminated due to a signal. */
	if (WIFSIGNALED(wait_status))
		packet_disconnect("Command terminated on signal %d.",
				  WTERMSIG(wait_status));

	/* Some weird exit cause.  Just exit. */
	packet_disconnect("wait returned status %04x.", wait_status);
	/* NOTREACHED */
}

d350 1
a350 1
	u_int nalloc = 0;
d379 1
a379 1
		if (options.rekey_interval > 0 && compat20 &&
d385 2
a386 2
		wait_until_can_do_something(&readset, &writeset, &max_fd,
		    &nalloc, rekey_timeout_ms);
d397 1
a397 2
		process_input(readset);
		if (connection_closed)
d399 1
a399 1
		process_output(writeset);
a425 47
static int
server_input_stdin_data(int type, u_int32_t seq, void *ctxt)
{
	char *data;
	u_int data_len;

	/* Stdin data from the client.  Append it to the buffer. */
	/* Ignore any data if the client has closed stdin. */
	if (fdin == -1)
		return 0;
	data = packet_get_string(&data_len);
	packet_check_eom();
	buffer_append(&stdin_buffer, data, data_len);
	explicit_bzero(data, data_len);
	free(data);
	return 0;
}

static int
server_input_eof(int type, u_int32_t seq, void *ctxt)
{
	/*
	 * Eof from the client.  The stdin descriptor to the
	 * program will be closed when all buffered data has
	 * drained.
	 */
	debug("EOF received for stdin.");
	packet_check_eom();
	stdin_eof = 1;
	return 0;
}

static int
server_input_window_size(int type, u_int32_t seq, void *ctxt)
{
	u_int row = packet_get_int();
	u_int col = packet_get_int();
	u_int xpixel = packet_get_int();
	u_int ypixel = packet_get_int();

	debug("Window change received.");
	packet_check_eom();
	if (fdin != -1)
		pty_change_window_size(fdin, row, col, xpixel, ypixel);
	return 0;
}

d825 1
a825 1
server_init_dispatch_20(void)
d827 1
a827 1
	debug("server_init_dispatch_20");
a845 33
}
static void
server_init_dispatch_13(void)
{
	debug("server_init_dispatch_13");
	dispatch_init(NULL);
	dispatch_set(SSH_CMSG_EOF, &server_input_eof);
	dispatch_set(SSH_CMSG_STDIN_DATA, &server_input_stdin_data);
	dispatch_set(SSH_CMSG_WINDOW_SIZE, &server_input_window_size);
	dispatch_set(SSH_MSG_CHANNEL_CLOSE, &channel_input_close);
	dispatch_set(SSH_MSG_CHANNEL_CLOSE_CONFIRMATION, &channel_input_close_confirmation);
	dispatch_set(SSH_MSG_CHANNEL_DATA, &channel_input_data);
	dispatch_set(SSH_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);
	dispatch_set(SSH_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);
	dispatch_set(SSH_MSG_PORT_OPEN, &channel_input_port_open);
}
static void
server_init_dispatch_15(void)
{
	server_init_dispatch_13();
	debug("server_init_dispatch_15");
	dispatch_set(SSH_MSG_CHANNEL_CLOSE, &channel_input_ieof);
	dispatch_set(SSH_MSG_CHANNEL_CLOSE_CONFIRMATION, &channel_input_oclose);
}
static void
server_init_dispatch(void)
{
	if (compat20)
		server_init_dispatch_20();
	else if (compat13)
		server_init_dispatch_13();
	else
		server_init_dispatch_15();
@


1.183
log
@fix ClientAliveInterval when a time-based RekeyLimit is set;
previously keepalive packets were not being sent.
bz#2252 report and analysis by Christian Wittenhorst and Garrett Lee
feedback and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.182 2016/02/08 10:57:07 djm Exp $ */
d382 1
d390 2
a391 2
			verbose("Connection closed by %.100s",
			    get_remote_ipaddr());
d399 3
a401 2
				    "%.100s: %.100s",
				    get_remote_ipaddr(), strerror(errno));
@


1.182
log
@refactor activation of rekeying

This makes automatic rekeying internal to the packet code (previously
the server and client loops needed to assist). In doing to it makes
application of rekey limits more accurate by accounting for packets
about to be sent as well as packets queued during rekeying events
themselves.

Based on a patch from dtucker@@ which was in turn based on a patch
Aleksander Adamowski in bz#2521; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.181 2016/01/14 16:17:40 markus Exp $ */
d273 1
a273 1
    u_int *nallocp, u_int64_t max_time_milliseconds)
d284 1
d286 1
a286 2
		max_time_milliseconds = MIN(max_time_milliseconds,
		    (u_int)minwait_secs * 1000);
d296 4
a299 2
	if (compat20 &&
	    max_time_milliseconds == 0 && options.client_alive_interval) {
d301 2
a302 2
		max_time_milliseconds =
		    (u_int64_t)options.client_alive_interval * 1000;
d350 2
a351 2
		if (max_time_milliseconds == 0 || client_alive_scheduled)
			max_time_milliseconds = 100;
d353 1
a353 1
	if (max_time_milliseconds == 0)
d356 2
a357 2
		tv.tv_sec = max_time_milliseconds / 1000;
		tv.tv_usec = 1000 * (max_time_milliseconds % 1000);
@


1.181
log
@remove roaming support; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.180 2015/12/04 16:41:28 markus Exp $ */
d791 1
a791 1
	int rekeying = 0, max_fd;
d818 2
a819 3
		rekeying = (active_state->kex != NULL && !active_state->kex->done);

		if (!rekeying && packet_not_very_much_data_to_write())
d821 2
a822 1
		if (options.rekey_interval > 0 && compat20 && !rekeying)
d837 1
a837 1
		if (!rekeying) {
a838 6
			if (packet_need_rekeying()) {
				debug("need rekeying");
				active_state->kex->done = 0;
				kex_send_kexinit(active_state);
			}
		}
@


1.180
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.179 2015/11/28 06:41:03 djm Exp $ */
a76 1
#include "roaming.h"
d385 1
a385 2
		int cont = 0;
		len = roaming_read(connection_in, buf, sizeof(buf), &cont);
a386 2
			if (cont)
				return;
@


1.179
log
@don't include port number in tcpip-forward replies for requests
that don't allocate a port; bz#2509 diagnosed by Ron Frederick
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.178 2015/02/20 22:17:21 djm Exp $ */
d1167 1
a1167 1
		    sshbuf_ptr(sigbuf), sshbuf_len(sigbuf), 0)) != 0 ||
@


1.178
log
@UpdateHostKeys fixes:

I accidentally changed the format of the hostkeys@@openssh.com messages
last week without changing the extension name, and this has been causing
connection failures for people who are running -current. First reported
by sthen@@

s/hostkeys@@openssh.com/hostkeys-00@@openssh.com/
Change the name of the proof message too, and reorder it a little.

Also, UpdateHostKeys=ask is incompatible with ControlPersist (no TTY
available to read the response) so disable UpdateHostKeys if it is in
ask mode and ControlPersist is active (and document this)
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.177 2015/02/16 22:13:32 djm Exp $ */
d1228 2
a1229 1
		if ((r = sshbuf_put_u32(resp, allocated_listen_port)) != 0)
@


1.177
log
@Revise hostkeys@@openssh.com hostkey learning extension.

The client will not ask the server to prove ownership of the private
halves of any hitherto-unseen hostkeys it offers to the client.

Allow UpdateHostKeys option to take an 'ask' argument to let the
user manually review keys offered.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.176 2015/01/20 23:14:00 deraadt Exp $ */
d1161 3
a1163 1
		if ((r = sshbuf_put_string(sigbuf,
a1164 2
		    (r = sshbuf_put_cstring(sigbuf,
		    "hostkeys-prove@@openssh.com")) != 0 ||
d1273 1
a1273 1
	} else if (strcmp(rtype, "hostkeys-prove@@openssh.com") == 0) {
@


1.176
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.175 2015/01/19 20:16:15 markus Exp $ */
d78 1
d1117 70
d1191 2
a1192 1
	int success = 0, allocated_listen_port = 0;
d1226 4
d1273 2
d1279 3
a1281 2
		if (success && allocated_listen_port > 0)
			packet_put_int(allocated_listen_port);
d1286 1
@


1.175
log
@adapt kex to sshbuf and struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.174 2015/01/19 20:07:45 markus Exp $ */
d38 1
a42 1
#include <sys/param.h>
@


1.174
log
@move dispatch to struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.173 2015/01/19 19:52:16 markus Exp $ */
d515 1
a515 1
	dispatch_run(DISPATCH_NONBLOCK, NULL, compat20 ? active_state->kex : NULL);
d845 1
a845 1
				kex_send_kexinit(active_state->kex);
@


1.173
log
@update packet.c & isolate, introduce struct ssh
a) switch packet.c to buffer api and isolate per-connection info into struct ssh
b) (de)serialization of the state is moved from monitor to packet.c
c) the old packet.c API is implemented in opacket.[ch]
d) compress.c/h is removed and integrated into packet.c
with and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.172 2014/07/15 15:54:14 millert Exp $ */
d865 1
a865 1
static void
d875 1
d878 1
a878 1
static void
d887 1
a887 1
		return;
d893 1
d896 1
a896 1
static void
d907 1
d910 1
a910 1
static void
d922 1
d1062 1
a1062 1
static void
d1112 1
d1115 1
a1115 1
static void
d1207 1
d1210 1
a1210 1
static void
d1240 1
@


1.172
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.171 2014/04/29 13:10:30 djm Exp $ */
a81 1
extern Kex *xxx_kex;
d515 1
a515 1
	dispatch_run(DISPATCH_NONBLOCK, NULL, compat20 ? xxx_kex : NULL);
d821 1
a821 1
		rekeying = (xxx_kex != NULL && !xxx_kex->done);
d844 2
a845 2
				xxx_kex->done = 0;
				kex_send_kexinit(xxx_kex);
@


1.171
log
@bz#1818 - don't send channel success/failre replies on channels that
have sent a close already; analysis and patch from Simon Tatham;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.170 2014/02/02 03:44:31 djm Exp $ */
d60 1
a76 1
#include "misc.h"
d941 1
a941 1
		c = channel_connect_to(target, target_port,
d956 32
d1079 2
d1125 1
a1125 2
		char *listen_address;
		u_short listen_port;
d1130 3
a1132 2
		listen_address = packet_get_string(NULL);
		listen_port = (u_short)packet_get_int();
d1134 1
a1134 1
		    listen_address, listen_port);
d1139 2
a1140 2
		    (!want_reply && listen_port == 0) ||
		    (listen_port != 0 && listen_port < IPPORT_RESERVED &&
d1146 2
a1147 3
			success = channel_setup_remote_fwd_listener(
			    listen_address, listen_port,
			    &allocated_listen_port, options.gateway_ports);
d1149 1
a1149 1
		free(listen_address);
d1151 1
a1151 2
		char *cancel_address;
		u_short cancel_port;
d1153 3
a1155 2
		cancel_address = packet_get_string(NULL);
		cancel_port = (u_short)packet_get_int();
d1157 30
a1186 1
		    cancel_address, cancel_port);
d1188 2
a1189 3
		success = channel_cancel_rport_listener(cancel_address,
		    cancel_port);
		free(cancel_address);
@


1.170
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.169 2013/12/19 00:19:12 dtucker Exp $ */
d1167 1
a1167 1
	if (reply) {
@


1.169
log
@Cast client_alive_interval to u_int64_t before assinging to
max_time_milliseconds to avoid potential integer overflow in the timeout.
bz#2170, patch from Loganaden Velvindron, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.168 2013/07/12 00:19:59 djm Exp $ */
d891 1
a891 1
	memset(data, 0, data_len);
@


1.168
log
@fix pointer-signedness warnings from clang/llvm-3.3; "seems nice" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.167 2013/05/17 00:13:14 djm Exp $ */
d300 2
a301 1
		max_time_milliseconds = options.client_alive_interval * 1000;
@


1.167
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.166 2013/05/16 09:08:41 dtucker Exp $ */
d794 2
a795 1
	int rekeying = 0, max_fd, nalloc = 0;
@


1.166
log
@Fix some "unused result" warnings found via clang and -portable.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.165 2013/05/16 04:09:14 dtucker Exp $ */
d665 1
a665 1
				xfree(cp);
d693 2
a694 4
	if (readset)
		xfree(readset);
	if (writeset)
		xfree(writeset);
d854 2
a855 4
	if (readset)
		xfree(readset);
	if (writeset)
		xfree(writeset);
d890 1
a890 1
	xfree(data);
d947 2
a948 2
	xfree(originator);
	xfree(target);
d1072 1
a1072 1
	xfree(ctype);
d1114 1
a1114 1
		xfree(listen_address);
d1126 1
a1126 1
		xfree(cancel_address);
d1139 1
a1139 1
	xfree(rtype);
d1171 1
a1171 1
	xfree(rtype);
@


1.165
log
@Add RekeyLimit to sshd with the same syntax as the client allowing rekeying
based on traffic volume or time.  ok djm@@, help & ok jmc@@ for the man page.
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.164 2012/12/07 01:51:35 dtucker Exp $ */
d147 1
a147 1
		write(notify_pipe[1], "", 1);
@


1.164
log
@Cast signal to int for logging.  A no-op on openbsd (they're always ints)
but will prevent warnings in portable.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.163 2012/12/02 20:46:11 djm Exp $ */
d274 1
a274 1
    u_int *nallocp, u_int max_time_milliseconds)
d534 1
a534 1
	u_int max_time_milliseconds;
d797 1
d826 5
d832 1
a832 1
		    &nalloc, 0);
@


1.163
log
@make AllowTcpForwarding accept "local" and "remote" in addition to its
current "yes"/"no" to allow the server to specify whether just local or
remote TCP forwarding is enabled. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.162 2012/06/20 04:42:58 djm Exp $ */
d679 1
a679 1
			logit("Exiting on signal %d", received_sigterm);
d829 1
a829 1
			logit("Exiting on signal %d", received_sigterm);
@


1.162
log
@initialise accept() backoff timer to avoid EINVAL from select(2) in
rekeying
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.161 2012/04/11 13:16:19 djm Exp $ */
d921 1
a921 1
	Channel *c;
d934 10
a943 3
	/* XXX check permission */
	c = channel_connect_to(target, target_port,
	    "direct-tcpip", "direct-tcpip");
d1099 1
a1099 1
		if (!options.allow_tcp_forwarding ||
@


1.161
log
@don't spin in accept() when out of fds (ENFILE/ENFILE) - back off for a
while; ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.160 2011/05/15 08:09:01 djm Exp $ */
d278 1
a278 1
	time_t minwait_secs;
@


1.160
log
@use FD_CLOEXEC consistently; patch from zion AT x96.org
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.159 2009/05/28 16:50:16 andreas Exp $ */
d278 1
d281 8
a301 3

	/* Allocate and update select() masks for channel descriptors. */
	channel_prepare_select(readsetp, writesetp, maxfdp, nallocp, 0);
@


1.159
log
@Keep track of number of bytes read and written. Needed for upcoming
changes. Most code from Martin Forssen, maf at appgate dot com.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.158 2009/05/25 06:48:01 andreas Exp $ */
d130 2
a131 2
	} else if ((fcntl(notify_pipe[0], F_SETFD, 1) == -1) ||
	    (fcntl(notify_pipe[1], F_SETFD, 1) == -1)) {
@


1.158
log
@Put the globals in packet.c into a struct and don't access it directly
from other files. No functional changes.
ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.157 2009/02/12 03:16:01 djm Exp $ */
d77 1
d379 2
a380 1
		len = read(connection_in, buf, sizeof(buf));
d382 2
@


1.157
log
@tighten check for -R0:... forwarding: only allow dynamic allocation if
want_reply is set in the packet
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.156 2009/02/12 03:00:56 djm Exp $ */
d246 1
a246 1
	if (++keep_alive_timeouts > options.client_alive_count_max) {
d861 1
a861 1
	keep_alive_timeouts = 0;
@


1.156
log
@support remote port forwarding with a zero listen port (-R0:...) to
dyamically allocate a listen port at runtime (this is actually
specified in rfc4254); bz#1003 ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.155 2009/01/22 10:02:34 djm Exp $ */
d1084 1
@


1.155
log
@make a2port() return -1 when it encounters an invalid port number
rather than 0, which it will now treat as valid (needed for future work)

adjust current consumers of a2port() to check its return value is <= 0,
which in turn required some things to be converted from u_short => int

make use of int vs. u_short consistent in some other places too

feedback & ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.154 2008/12/02 19:08:59 markus Exp $ */
d1061 1
a1061 1
	int success = 0;
d1084 2
a1085 1
		    (listen_port < IPPORT_RESERVED && pw->pw_uid != 0)) {
d1091 2
a1092 1
			    listen_address, listen_port, options.gateway_ports);
d1114 2
@


1.154
log
@backout 1.149, since it's not necessary and openssh clients send
broken CHANNEL_FAILURE/SUCCESS messages since about 2004; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.153 2008/06/30 12:15:39 djm Exp $ */
d913 1
a913 1
	int target_port, originator_port;
@


1.153
log
@only pass channel requests on session channels through to the session
channel handler, avoiding spurious log messages; ok! markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.152 2008/06/10 22:15:23 djm Exp $ */
a1164 2
	dispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &channel_input_status_confirm);
	dispatch_set(SSH2_MSG_CHANNEL_FAILURE, &channel_input_status_confirm);
d1166 2
@


1.152
log
@Add a no-more-sessions@@openssh.com global request extension that the
client sends when it knows that it will never request another session
(i.e. when session multiplexing is disabled). This allows a server to
disallow further session requests and terminate the session.

Why would a non-multiplexing client ever issue additional session
requests? It could have been attacked with something like SSH'jack:
http://www.storm.net.nz/projects/7

feedback & ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.151 2008/05/09 16:21:13 markus Exp $ */
d1138 2
a1139 1
	} else if (c->type == SSH_CHANNEL_LARVAL || c->type == SSH_CHANNEL_OPEN)
@


1.151
log
@unbreak
	ssh -2 localhost od /bin/ls | true
ignoring SIGPIPE by adding a new channel message (EOW) that signals
the peer that we're not interested in any data it might send.
fixes bz #85; discussion, debugging and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.150 2008/05/09 04:55:56 djm Exp $ */
d104 1
d982 6
d1105 3
@


1.150
log
@Try additional addresses when connecting to a port forward destination
whose DNS name resolves to more than one address. The previous behaviour
was to try the first address and give up.

Reported by stig AT venaas.com in bz#343

great feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.149 2008/05/08 12:02:23 djm Exp $ */
d1125 4
a1128 1
	if (c->type == SSH_CHANNEL_LARVAL || c->type == SSH_CHANNEL_OPEN)
@


1.149
log
@Implement a channel success/failure status confirmation callback
mechanism. Each channel maintains a queue of callbacks, which will
be drained in order (RFC4253 guarantees confirm messages are not
reordered within an channel).

Also includes a abandonment callback to clean up if a channel is
closed without sending confirmation messages. This probably
shouldn't happen in compliant implementations, but it could be
abused to leak memory.

ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.148 2008/02/22 20:44:02 dtucker Exp $ */
a910 1
	int sock;
d920 2
a921 2
	debug("server_request_direct_tcpip: originator %s port %d, target %s port %d",
	    originator, originator_port, target, target_port);
d924 4
a927 1
	sock = channel_connect_to(target, target_port);
d929 1
a929 6
	xfree(originator);
	if (sock < 0)
		return NULL;
	c = channel_new("direct-tcpip", SSH_CHANNEL_CONNECTING,
	    sock, sock, -1, CHAN_TCP_WINDOW_DEFAULT,
	    CHAN_TCP_PACKET_DEFAULT, 0, "direct-tcpip", 1);
@


1.148
log
@Allow all SSH2 packet types, including UNIMPLEMENTED to reset the
keepalive timer (bz #1307).  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.147 2008/01/23 01:56:54 dtucker Exp $ */
d43 1
d1154 2
a1156 1
	dispatch_set(SSH2_MSG_CHANNEL_FAILURE, &server_input_keep_alive);
@


1.147
log
@Revert the change for bz #1307 as it causes connection aborts if an IGNORE
packet arrives while we're waiting in packet_read_expect (and possibly
elsewhere).
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.145 2006/10/11 12:38:03 markus Exp $ */
a102 1
static int client_alive_timeouts = 0;
d244 1
a244 1
	if (++client_alive_timeouts > options.client_alive_count_max) {
d859 1
a859 1
	client_alive_timeouts = 0;
@


1.146
log
@Make SSH2_MSG_UNIMPLEMENTED and SSH2_MSG_IGNORE messages reset the
ServerAlive and ClientAlive timers.  Prevents dropping a connection
when these are enabled but the peer does not support our keepalives.
bz #1307, ok djm@@.
@
text
@a1157 2
	dispatch_set(SSH2_MSG_IGNORE, &server_input_keep_alive);
	dispatch_set(SSH2_MSG_UNIMPLEMENTED, &server_input_keep_alive);
@


1.145
log
@exit instead of doing a blocking tcp send if we detect a client/server timeout,
since the tcp sendqueue might be already full (of alive requests); ok dtucker, report mpf
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.144 2006/08/03 03:34:42 deraadt Exp $ */
d1158 2
@


1.144
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.143 2006/07/26 02:35:17 stevesk Exp $ */
d245 4
a248 2
	if (++client_alive_timeouts > options.client_alive_count_max)
		packet_disconnect("Timeout, your session not responding.");
@


1.144.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.145 2006/10/11 12:38:03 markus Exp $ */
d245 2
a246 4
	if (++client_alive_timeouts > options.client_alive_count_max) {
		logit("Timeout, client not responding.");
		cleanup_exit(255);
	}
@


1.143
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.142 2006/07/25 02:59:21 stevesk Exp $ */
a37 2
#include "includes.h"

d53 1
d66 4
a75 1
#include "kex.h"
@


1.142
log
@move #include <sys/time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.141 2006/07/22 20:48:23 stevesk Exp $ */
d44 1
@


1.141
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.140 2006/07/20 15:26:15 stevesk Exp $ */
d43 1
@


1.140
log
@missed some needed #include <unistd.h> when KERBEROS5=no; issue from
massimo@@cedoc.mo.it
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.139 2006/07/11 20:07:25 stevesk Exp $ */
d50 1
@


1.139
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.138 2006/07/09 15:15:11 stevesk Exp $ */
d51 1
@


1.138
log
@move #include <fcntl.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.137 2006/07/06 16:03:53 stevesk Exp $ */
d46 1
@


1.137
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.136 2006/07/05 02:42:09 stevesk Exp $ */
d46 1
@


1.136
log
@move #include <netinet/in.h> out of includes.h; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.135 2006/03/25 18:30:55 deraadt Exp $ */
d46 1
@


1.135
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.134 2006/03/25 13:17:02 djm Exp $ */
d42 3
@


1.134
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d356 1
a356 1
process_input(fd_set * readset)
d415 1
a415 1
process_output(fd_set * writeset)
@


1.133
log
@spacing
@
text
@d1 1
@


1.132
log
@sprinkle u_int throughout pty subsystem, ok markus
@
text
@d1095 1
@


1.131
log
@ARGSUSED for signal handlers
@
text
@d881 4
a884 4
	int row = packet_get_int();
	int col = packet_get_int();
	int xpixel = packet_get_int();
	int ypixel = packet_get_int();
@


1.130
log
@RCSID() can die
@
text
@d150 1
d161 1
d945 1
a945 1
	 	if (tun != SSH_TUNID_ANY && forced_tun_device != tun)
@


1.129
log
@memory leaks detected by Coverity via elad AT netbsd.org;
ok deraadt@@ dtucker@@
@
text
@a37 1
RCSID("$OpenBSD: serverloop.c,v 1.128 2006/03/04 04:12:58 djm Exp $");
@


1.128
log
@move a debug() outside of a signal handler; ok markus@@ a little while back
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.127 2006/02/20 17:02:44 stevesk Exp $");
d1084 1
@


1.127
log
@move #include <signal.h> out of includes.h; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.126 2006/02/10 01:44:26 stevesk Exp $");
a154 1
	debug("Received SIGCHLD.");
d755 1
@


1.127.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: serverloop.c,v 1.144 2006/08/03 03:34:42 deraadt Exp $ */
d37 3
d42 1
a42 9
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/param.h>

#include <netinet/in.h>

#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
a43 1
#include <string.h>
a44 2
#include <unistd.h>
#include <stdarg.h>
a56 4
#include "key.h"
#include "cipher.h"
#include "kex.h"
#include "hostfile.h"
d63 1
a150 1
/*ARGSUSED*/
d155 1
a161 1
/*ARGSUSED*/
d355 1
a355 1
process_input(fd_set *readset)
d414 1
a414 1
process_output(fd_set *writeset)
a755 1
		debug("Received SIGCHLD.");
d880 4
a883 4
	u_int row = packet_get_int();
	u_int col = packet_get_int();
	u_int xpixel = packet_get_int();
	u_int ypixel = packet_get_int();
d944 1
a944 1
		if (tun != SSH_TUNID_ANY && forced_tun_device != tun)
a1083 1
		xfree(cancel_address);
a1092 1

@


1.127.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.145 2006/10/11 12:38:03 markus Exp $ */
d245 2
a246 4
	if (++client_alive_timeouts > options.client_alive_count_max) {
		logit("Timeout, client not responding.");
		cleanup_exit(255);
	}
@


1.126
log
@move #include <sys/wait.h> out of includes.h; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.125 2006/02/07 01:42:00 stevesk Exp $");
d43 1
@


1.125
log
@move #include <termios.h> out of includes.h; ok markus@@
@
text
@d38 4
a41 1
RCSID("$OpenBSD: serverloop.c,v 1.124 2005/12/13 15:03:02 reyk Exp $");
@


1.124
log
@if forced_tun_device is not set, it is -1 and not SSH_TUNID_ANY
@
text
@d38 3
a40 1
RCSID("$OpenBSD: serverloop.c,v 1.123 2005/12/08 18:34:11 reyk Exp $");
@


1.123
log
@two changes to the new ssh tunnel support. this breaks compatibility
with the initial commit but is required for a portable approach.
- make the tunnel id u_int and platform friendly, use predefined types.
- support configuration of layer 2 (ethernet) or layer 3
(point-to-point, default) modes. configuration is done using the
Tunnel (yes|point-to-point|ethernet|no) option is ssh_config(5) and
restricted by the PermitTunnel (yes|point-to-point|ethernet|no) option
in sshd_config(5).

ok djm@@, man page bits by jmc@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.122 2005/12/06 22:38:27 reyk Exp $");
d937 1
a937 1
	if (forced_tun_device != SSH_TUNID_ANY) {
@


1.122
log
@Add support for tun(4) forwarding over OpenSSH, based on an idea and
initial channel code bits by markus@@. This is a simple and easy way to
use OpenSSH for ad hoc virtual private network connections, e.g.
administrative tunnels or secure wireless access. It's based on a new
ssh channel and works similar to the existing TCP forwarding support,
except that it depends on the tun(4) network interface on both ends of
the connection for layer 2 or layer 3 tunneling. This diff also adds
support for LocalCommand in the ssh(1) client.

ok djm@@, markus@@, jmc@@ (manpages), tested and discussed with others
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.121 2005/10/31 11:48:29 djm Exp $");
d918 2
a919 1
	int sock, tun;
d921 12
a932 2
	if (!options.permit_tun) {
		packet_send_debug("Server has disabled tunnel device forwarding.");
d937 2
a938 2
	if (forced_tun_device != -1) {
	 	if (tun != -1 && forced_tun_device != tun)
d942 1
a942 1
	sock = tun_open(tun);
@


1.121
log
@make sure we clean up wtmp, etc. file when we receive a SIGTERM,
SIGINT or SIGQUIT when running without privilege separation (the
normal privsep case is already OK). Patch mainly by dtucker@@ and
senthilkumar_sen AT hotpop.com; ok dtucker@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.120 2005/10/30 08:52:17 djm Exp $");
d915 30
d989 2
@


1.120
log
@no need to escape single quotes in comments, no binary change
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.119 2005/10/10 10:23:08 djm Exp $");
d64 1
d94 3
d156 6
d513 6
d646 6
d772 6
d794 6
@


1.119
log
@fix regression I introduced in 4.2: X11 forwardings initiated after
a session has exited (e.g. "(sleep 5; xterm) &") would not start.
bz #1086 reported by t8m AT centrum.cz; ok markus@@ dtucker@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.118 2005/07/17 07:17:55 djm Exp $");
d549 1
a549 1
	 * we don\'t need to check the descriptor everywhere.
@


1.118
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.117 2004/08/11 21:43:05 avsm Exp $");
d901 1
a901 1
	channel_register_cleanup(c->self, session_close_by_channel);
@


1.118.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.124 2005/12/13 15:03:02 reyk Exp $");
a63 1
extern int use_privsep;
a92 3
/* Cleanup on signals (!use_privsep case only) */
static volatile sig_atomic_t received_sigterm = 0;

a151 6
static void
sigterm_handler(int sig)
{
	received_sigterm = sig;
}

a502 6
	if (!use_privsep) {
		signal(SIGTERM, sigterm_handler);
		signal(SIGINT, sigterm_handler);
		signal(SIGQUIT, sigterm_handler);
	}

d549 1
a549 1
	 * we don't need to check the descriptor everywhere.
a629 6
		if (received_sigterm) {
			logit("Exiting on signal %d", received_sigterm);
			/* Clean up sessions, utmp, etc. */
			cleanup_exit(255);
		}

a749 6
	if (!use_privsep) {
		signal(SIGTERM, sigterm_handler);
		signal(SIGINT, sigterm_handler);
		signal(SIGQUIT, sigterm_handler);
	}

a766 6
		if (received_sigterm) {
			logit("Exiting on signal %d", received_sigterm);
			/* Clean up sessions, utmp, etc. */
			cleanup_exit(255);
		}

a880 41
server_request_tun(void)
{
	Channel *c = NULL;
	int mode, tun;
	int sock;

	mode = packet_get_int();
	switch (mode) {
	case SSH_TUNMODE_POINTOPOINT:
	case SSH_TUNMODE_ETHERNET:
		break;
	default:
		packet_send_debug("Unsupported tunnel device mode.");
		return NULL;
	}
	if ((options.permit_tun & mode) == 0) {
		packet_send_debug("Server has rejected tunnel device "
		    "forwarding");
		return NULL;
	}

	tun = packet_get_int();
	if (forced_tun_device != -1) {
	 	if (tun != SSH_TUNID_ANY && forced_tun_device != tun)
			goto done;
		tun = forced_tun_device;
	}
	sock = tun_open(tun, mode);
	if (sock < 0)
		goto done;
	c = channel_new("tun", SSH_CHANNEL_OPEN, sock, sock, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, "tun", 1);
	c->datagram = 1;

 done:
	if (c == NULL)
		packet_send_debug("Failed to open the tunnel device.");
	return c;
}

static Channel *
d901 1
a901 1
	channel_register_cleanup(c->self, session_close_by_channel, 0);
a924 2
	} else if (strcmp(ctype, "tun@@openssh.com") == 0) {
		c = server_request_tun();
@


1.118.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: serverloop.c,v 1.144 2006/08/03 03:34:42 deraadt Exp $ */
d37 2
a38 16
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/param.h>

#include <netinet/in.h>

#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <signal.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include <stdarg.h>
a50 4
#include "key.h"
#include "cipher.h"
#include "kex.h"
#include "hostfile.h"
d57 1
a144 1
/*ARGSUSED*/
d149 1
a155 1
/*ARGSUSED*/
d349 1
a349 1
process_input(fd_set *readset)
d408 1
a408 1
process_output(fd_set *writeset)
a749 1
		debug("Received SIGCHLD.");
d874 4
a877 4
	u_int row = packet_get_int();
	u_int col = packet_get_int();
	u_int xpixel = packet_get_int();
	u_int ypixel = packet_get_int();
d938 1
a938 1
		if (tun != SSH_TUNID_ANY && forced_tun_device != tun)
a1077 1
		xfree(cancel_address);
a1086 1

@


1.118.2.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: serverloop.c,v 1.145 2006/10/11 12:38:03 markus Exp $ */
d245 2
a246 4
	if (++client_alive_timeouts > options.client_alive_count_max) {
		logit("Timeout, client not responding.");
		cleanup_exit(255);
	}
@


1.117
log
@some signed/unsigned int comparison cleanups; markus@@ ok
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.116 2004/05/21 11:33:11 djm Exp $");
d866 1
a866 1
	   originator, originator_port, target, target_port);
@


1.117.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.118 2005/07/17 07:17:55 djm Exp $");
d866 1
a866 1
	    originator, originator_port, target, target_port);
@


1.117.4.2
log
@upgrade to OpenSSH 4.3
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.124 2005/12/13 15:03:02 reyk Exp $");
a63 1
extern int use_privsep;
a92 3
/* Cleanup on signals (!use_privsep case only) */
static volatile sig_atomic_t received_sigterm = 0;

a151 6
static void
sigterm_handler(int sig)
{
	received_sigterm = sig;
}

a502 6
	if (!use_privsep) {
		signal(SIGTERM, sigterm_handler);
		signal(SIGINT, sigterm_handler);
		signal(SIGQUIT, sigterm_handler);
	}

d549 1
a549 1
	 * we don't need to check the descriptor everywhere.
a629 6
		if (received_sigterm) {
			logit("Exiting on signal %d", received_sigterm);
			/* Clean up sessions, utmp, etc. */
			cleanup_exit(255);
		}

a749 6
	if (!use_privsep) {
		signal(SIGTERM, sigterm_handler);
		signal(SIGINT, sigterm_handler);
		signal(SIGQUIT, sigterm_handler);
	}

a766 6
		if (received_sigterm) {
			logit("Exiting on signal %d", received_sigterm);
			/* Clean up sessions, utmp, etc. */
			cleanup_exit(255);
		}

a880 41
server_request_tun(void)
{
	Channel *c = NULL;
	int mode, tun;
	int sock;

	mode = packet_get_int();
	switch (mode) {
	case SSH_TUNMODE_POINTOPOINT:
	case SSH_TUNMODE_ETHERNET:
		break;
	default:
		packet_send_debug("Unsupported tunnel device mode.");
		return NULL;
	}
	if ((options.permit_tun & mode) == 0) {
		packet_send_debug("Server has rejected tunnel device "
		    "forwarding");
		return NULL;
	}

	tun = packet_get_int();
	if (forced_tun_device != -1) {
	 	if (tun != SSH_TUNID_ANY && forced_tun_device != tun)
			goto done;
		tun = forced_tun_device;
	}
	sock = tun_open(tun, mode);
	if (sock < 0)
		goto done;
	c = channel_new("tun", SSH_CHANNEL_OPEN, sock, sock, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, "tun", 1);
	c->datagram = 1;

 done:
	if (c == NULL)
		packet_send_debug("Failed to open the tunnel device.");
	return c;
}

static Channel *
d901 1
a901 1
	channel_register_cleanup(c->self, session_close_by_channel, 0);
a924 2
	} else if (strcmp(ctype, "tun@@openssh.com") == 0) {
		c = server_request_tun();
@


1.117.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.118 2005/07/17 07:17:55 djm Exp $");
d866 1
a866 1
	    originator, originator_port, target, target_port);
@


1.116
log
@bz #756: add support for the cancel-tcpip-forward request for the server and
the client (through the ~C commandline). reported by z3p AT twistedmatrix.com;
ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.115 2004/01/19 21:25:15 markus Exp $");
d241 1
a241 1
    int *nallocp, u_int max_time_milliseconds)
d487 2
a488 1
	int max_fd = 0, nalloc = 0;
@


1.115
log
@fix mem leaks; some fixes from Pete Flugstad; tested dtucker@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.114 2003/12/09 15:28:43 markus Exp $");
d989 11
@


1.115.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.117 2004/08/11 21:43:05 avsm Exp $");
d241 1
a241 1
    u_int *nallocp, u_int max_time_milliseconds)
d487 1
a487 2
	int max_fd = 0;
	u_int nalloc = 0;
a988 11
	} else if (strcmp(rtype, "cancel-tcpip-forward") == 0) {
		char *cancel_address;
		u_short cancel_port;

		cancel_address = packet_get_string(NULL);
		cancel_port = (u_short)packet_get_int();
		debug("%s: cancel-tcpip-forward addr %s port %d", __func__,
		    cancel_address, cancel_port);

		success = channel_cancel_rport_listener(cancel_address,
		    cancel_port);
@


1.114
log
@make ClientKeepAlive work for ssh -N, too (no login shell requested).
1) send a bogus channel request if we find a channel
2) send a bogus global request if we don't have a channel
ok + test beck@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.113 2003/11/18 00:40:05 dtucker Exp $");
d851 1
a851 1
server_request_direct_tcpip(char *ctype)
d873 1
a873 1
	c = channel_new(ctype, SSH_CHANNEL_CONNECTING,
d880 1
a880 1
server_request_session(char *ctype)
d892 1
a892 1
	c = channel_new(ctype, SSH_CHANNEL_LARVAL,
d921 1
a921 1
		c = server_request_session(ctype);
d923 1
a923 1
		c = server_request_direct_tcpip(ctype);
@


1.113
log
@Correct check for authctxt->valid.  ok djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.112 2003/11/04 08:54:09 djm Exp $");
d213 1
a213 10
	static int had_channel = 0;
	int id;

	id = channel_find_open();
	if (id == -1) {
		if (!had_channel)
			return;
		packet_disconnect("No open channels after timeout!");
	}
	had_channel = 1;
d220 1
a220 1
	 * send a bogus channel request with "wantreply",
d223 7
a229 1
	channel_request_start(id, "keepalive@@openssh.com", 1);
d795 1
a795 1
server_input_channel_failure(int type, u_int32_t seq, void *ctxt)
d797 1
a797 1
	debug("Got CHANNEL_FAILURE for keepalive");
a805 1

d1042 3
a1044 1
	dispatch_set(SSH2_MSG_CHANNEL_FAILURE, &server_input_channel_failure);
@


1.112
log
@standardise arguments to auth methods - they should all take authctxt.
check authctxt->valid rather then pw != NULL; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.111 2003/09/23 20:17:11 markus Exp $");
d974 1
a974 1
		if (pw == NULL || !the_authctxt->pw)
@


1.111
log
@replace fatal_cleanup() and linked list of fatal callbacks with static
cleanup_exit() function.  re-refine cleanup_exit() where appropriate,
allocate sshd's authctxt eary to allow simpler cleanup in sshd.
tested by many, ok deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.110 2003/06/24 08:23:46 markus Exp $");
d974 2
a975 2
		if (pw == NULL)
			fatal("server_input_global_request: no user");
@


1.110
log
@int -> u_int; ok djm@@, deraadt@@, mouring@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.109 2003/06/04 12:03:59 djm Exp $");
d63 1
a63 1
static Authctxt *xxx_authctxt;
d356 1
a356 1
			fatal_cleanup();
d362 1
a362 1
				fatal_cleanup();
a756 2
	xxx_authctxt = authctxt;

d899 1
a899 1
	if (session_open(xxx_authctxt, c->self) != 1) {
d973 1
a973 1
		pw = auth_get_user();
@


1.110.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.115 2004/01/19 21:25:15 markus Exp $");
d63 1
a63 1
extern Authctxt *the_authctxt;
d213 10
a222 1
	int channel_id;
d229 1
a229 1
	 * send a bogus global/channel request with "wantreply",
d232 1
a232 7
	if ((channel_id = channel_find_open()) == -1) {
		packet_start(SSH2_MSG_GLOBAL_REQUEST);
		packet_put_cstring("keepalive@@openssh.com");
		packet_put_char(1);	/* boolean: want reply */
	} else {
		channel_request_start(channel_id, "keepalive@@openssh.com", 1);
	}
d356 1
a356 1
			cleanup_exit(255);
d362 1
a362 1
				cleanup_exit(255);
d757 2
d800 1
a800 1
server_input_keep_alive(int type, u_int32_t seq, void *ctxt)
d802 1
a802 1
	debug("Got %d/%u for keepalive", type, seq);
d811 1
d857 1
a857 1
server_request_direct_tcpip(void)
d879 1
a879 1
	c = channel_new("direct-tcpip", SSH_CHANNEL_CONNECTING,
d886 1
a886 1
server_request_session(void)
d898 1
a898 1
	c = channel_new("session", SSH_CHANNEL_LARVAL,
d901 1
a901 1
	if (session_open(the_authctxt, c->self) != 1) {
d927 1
a927 1
		c = server_request_session();
d929 1
a929 1
		c = server_request_direct_tcpip();
d975 3
a977 3
		pw = the_authctxt->pw;
		if (pw == NULL || !the_authctxt->valid)
			fatal("server_input_global_request: no/invalid user");
d1048 1
a1048 3
	dispatch_set(SSH2_MSG_CHANNEL_FAILURE, &server_input_keep_alive);
	dispatch_set(SSH2_MSG_REQUEST_SUCCESS, &server_input_keep_alive);
	dispatch_set(SSH2_MSG_REQUEST_FAILURE, &server_input_keep_alive);
@


1.110.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.117 2004/08/11 21:43:05 avsm Exp $");
d241 1
a241 1
    u_int *nallocp, u_int max_time_milliseconds)
d487 1
a487 2
	int max_fd = 0;
	u_int nalloc = 0;
a988 11
	} else if (strcmp(rtype, "cancel-tcpip-forward") == 0) {
		char *cancel_address;
		u_short cancel_port;

		cancel_address = packet_get_string(NULL);
		cancel_port = (u_short)packet_get_int();
		debug("%s: cancel-tcpip-forward addr %s port %d", __func__,
		    cancel_address, cancel_port);

		success = channel_cancel_rport_listener(cancel_address,
		    cancel_port);
@


1.109
log
@remove bitrotten commet; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.108 2003/05/11 20:30:24 markus Exp $");
d159 1
a159 1
	int len;
d188 1
a188 1
	int len;
@


1.108
log
@make channel_new() strdup the 'remote_name' (not the caller); ok theo
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.107 2003/04/02 09:48:07 markus Exp $");
d978 1
a978 1
		listen_address = packet_get_string(NULL); /* XXX currently ignored */
@


1.107
log
@reapply rekeying chage, tested by henning@@, ok djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.106 2003/04/01 10:22:21 markus Exp $");
d881 1
a881 1
	    CHAN_TCP_PACKET_DEFAULT, 0, xstrdup("direct-tcpip"), 1);
d900 1
a900 1
	    0, xstrdup("server-session"), 1);
@


1.106
log
@backout rekeying changes (for 3.6.1)
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.105 2003/04/01 10:10:23 markus Exp $");
d772 1
a772 1
		if (!rekeying)
d774 6
@


1.105
log
@rekeying bugfixes and automatic rekeying:

* both client and server rekey _automatically_
      (a) after 2^31 packets, because after 2^32 packets
          the sequence number for packets wraps
      (b) after 2^(blocksize_in_bits/4) blocks
  (see: http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-00.txt)
  (a) and (b) are _enabled_ by default, and only disabled for known
  openssh versions, that don't support rekeying properly.
* client option 'RekeyLimit'
* do not reply to requests during rekeying
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.104 2002/09/19 16:03:15 stevesk Exp $");
d772 1
a772 1
		if (!rekeying) {
a773 6
			if (packet_need_rekeying()) {
				debug("need rekeying");
				xxx_kex->done = 0;
				kex_send_kexinit(xxx_kex);
			}
		}
@


1.104
log
@log IP address also; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.103 2002/06/24 14:33:27 markus Exp $");
d772 1
a772 1
		if (!rekeying)
d774 6
@


1.104.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.110 2003/06/24 08:23:46 markus Exp $");
d159 1
a159 1
	u_int len;
d188 1
a188 1
	u_int len;
d772 1
a772 1
		if (!rekeying) {
a773 6
			if (packet_need_rekeying()) {
				debug("need rekeying");
				xxx_kex->done = 0;
				kex_send_kexinit(xxx_kex);
			}
		}
d875 1
a875 1
	    CHAN_TCP_PACKET_DEFAULT, 0, "direct-tcpip", 1);
d894 1
a894 1
	    0, "server-session", 1);
d972 1
a972 1
		listen_address = packet_get_string(NULL);
@


1.104.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.110 2003/06/24 08:23:46 markus Exp $");
d159 1
a159 1
	u_int len;
d188 1
a188 1
	u_int len;
d772 1
a772 1
		if (!rekeying) {
a773 6
			if (packet_need_rekeying()) {
				debug("need rekeying");
				xxx_kex->done = 0;
				kex_send_kexinit(xxx_kex);
			}
		}
d875 1
a875 1
	    CHAN_TCP_PACKET_DEFAULT, 0, "direct-tcpip", 1);
d894 1
a894 1
	    0, "server-session", 1);
d972 1
a972 1
		listen_address = packet_get_string(NULL);
@


1.104.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.115 2004/01/19 21:25:15 markus Exp $");
d63 1
a63 1
extern Authctxt *the_authctxt;
d213 10
a222 1
	int channel_id;
d229 1
a229 1
	 * send a bogus global/channel request with "wantreply",
d232 1
a232 7
	if ((channel_id = channel_find_open()) == -1) {
		packet_start(SSH2_MSG_GLOBAL_REQUEST);
		packet_put_cstring("keepalive@@openssh.com");
		packet_put_char(1);	/* boolean: want reply */
	} else {
		channel_request_start(channel_id, "keepalive@@openssh.com", 1);
	}
d356 1
a356 1
			cleanup_exit(255);
d362 1
a362 1
				cleanup_exit(255);
d757 2
d800 1
a800 1
server_input_keep_alive(int type, u_int32_t seq, void *ctxt)
d802 1
a802 1
	debug("Got %d/%u for keepalive", type, seq);
d811 1
d857 1
a857 1
server_request_direct_tcpip(void)
d879 1
a879 1
	c = channel_new("direct-tcpip", SSH_CHANNEL_CONNECTING,
d886 1
a886 1
server_request_session(void)
d898 1
a898 1
	c = channel_new("session", SSH_CHANNEL_LARVAL,
d901 1
a901 1
	if (session_open(the_authctxt, c->self) != 1) {
d927 1
a927 1
		c = server_request_session();
d929 1
a929 1
		c = server_request_direct_tcpip();
d975 3
a977 3
		pw = the_authctxt->pw;
		if (pw == NULL || !the_authctxt->valid)
			fatal("server_input_global_request: no/invalid user");
d1048 1
a1048 3
	dispatch_set(SSH2_MSG_CHANNEL_FAILURE, &server_input_keep_alive);
	dispatch_set(SSH2_MSG_REQUEST_SUCCESS, &server_input_keep_alive);
	dispatch_set(SSH2_MSG_REQUEST_FAILURE, &server_input_keep_alive);
@


1.103
log
@move channel counter to u_int
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.102 2002/06/11 05:46:20 mpech Exp $");
d45 1
d351 2
a352 1
			verbose("Connection closed by remote host.");
d359 3
a361 1
				verbose("Read error from remote host: %.100s", strerror(errno));
@


1.102
log
@pid_t cleanup. Markus need this now to keep hacking.
markus@@, millert@@ ok

Note: big usr.bin/ cleanup is comming. Now I'm waiting Ok from espie@@ for
make/.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.101 2002/03/30 18:51:15 markus Exp $");
a904 1
	u_int len;
d906 1
a906 2
	int rmaxpack;
	int rwindow;
@


1.101
log
@check waitpid for EINTR; based on patch from peter@@ifm.liu.se
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.100 2002/03/24 16:00:27 markus Exp $");
d677 2
a678 2
		error("Strange, wait returned pid %d, expected %d",
		    wait_pid, pid);
@


1.101.2.1
log
@Pull in OpenSSH-3.4
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.103 2002/06/24 14:33:27 markus Exp $");
d677 2
a678 2
		error("Strange, wait returned pid %ld, expected %ld",
		    (long)wait_pid, (long)pid);
d905 1
d907 2
a908 1
	u_int rmaxpack, rwindow, len;
@


1.101.2.2
log
@Update to OpenSSH 3.5
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.104 2002/09/19 16:03:15 stevesk Exp $");
a44 1
#include "canohost.h"
d350 1
a350 2
			verbose("Connection closed by %.100s",
			    get_remote_ipaddr());
d357 1
a357 3
				verbose("Read error from remote host "
				    "%.100s: %.100s",
				    get_remote_ipaddr(), strerror(errno));
@


1.100
log
@remove unused debug
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.99 2002/03/18 17:50:31 provos Exp $");
d673 4
a676 4
	wait_pid = waitpid(-1, &wait_status, 0);
	if (wait_pid == -1)
		packet_disconnect("wait: %.100s", strerror(errno));
	else if (wait_pid != pid)
d726 4
a729 2
		while ((pid = waitpid(-1, &status, WNOHANG)) > 0)
			session_close_by_pid(pid, status);
@


1.99
log
@integrate privilege separated openssh; its turned off by default for now.
work done by me and markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.98 2002/02/06 14:55:16 markus Exp $");
a320 3
	if (tvp!=NULL)
		debug3("tvp!=NULL kid %d mili %d", (int) child_terminated,
		    max_time_milliseconds);
@


1.98
log
@channel_new never returns NULL, mouring@@; ok djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.97 2002/02/03 17:53:25 markus Exp $");
d787 1
a787 1
	session_destroy_all();
@


1.97
log
@don't use channel_input_channel_request and callback
use new server_input_channel_req() instead:
	server_input_channel_req does generic request parsing on server side
	session_input_channel_req handles just session specific things now
ok djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.96 2002/01/31 15:00:05 markus Exp $");
a872 4
	if (c == NULL) {
		error("server_request_direct_tcpip: channel_new failed");
		close(sock);
	}
a891 4
	if (c == NULL) {
		error("server_request_session: channel_new failed");
		return NULL;
	}
@


1.96
log
@no need for WNOHANG; ok stevesk@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.95 2002/01/16 13:17:51 markus Exp $");
a904 2
	channel_register_callback(c->self, SSH2_MSG_CHANNEL_REQUEST,
	    session_input_channel_req, (void *)0);
d1005 27
d1045 1
a1045 1
	dispatch_set(SSH2_MSG_CHANNEL_REQUEST, &channel_input_channel_request);
@


1.95
log
@wrapper for channel_setup_fwd_listener
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.94 2002/01/10 11:13:29 markus Exp $");
d676 1
a676 1
	wait_pid = waitpid(-1, &wait_status, child_terminated ? WNOHANG : 0);
@


1.94
log
@skip client_alive_check until there are channels; ok beck@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.93 2001/12/28 15:06:00 markus Exp $");
d994 2
a995 5
			success = channel_request_forwarding(
			    listen_address, listen_port,
			    /*unspec host_to_connect*/ "<unspec host>",
			    /*unspec port_to_connect*/ 0,
			    options.gateway_ports, /*remote*/ 1);
@


1.93
log
@remove plen from the dispatch fn. it's no longer used.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.92 2001/12/28 14:50:54 markus Exp $");
d212 1
d215 8
a226 3
	id = channel_find_open();
	if (id == -1)
		packet_disconnect("No open channels after timeout!");
@


1.92
log
@packet_read* no longer return the packet length, since it's not used.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.91 2001/12/28 12:14:27 markus Exp $");
d785 1
a785 1
server_input_channel_failure(int type, int plen, u_int32_t seq, void *ctxt)
d798 1
a798 1
server_input_stdin_data(int type, int plen, u_int32_t seq, void *ctxt)
d815 1
a815 1
server_input_eof(int type, int plen, u_int32_t seq, void *ctxt)
d828 1
a828 1
server_input_window_size(int type, int plen, u_int32_t seq, void *ctxt)
d906 1
a906 1
server_input_channel_open(int type, int plen, u_int32_t seq, void *ctxt)
d956 1
a956 1
server_input_global_request(int type, int plen, u_int32_t seq, void *ctxt)
@


1.91
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.90 2001/12/27 20:39:58 markus Exp $");
d694 1
a694 2
			int plen;
			type = packet_read(&plen);
@


1.90
log
@get rid of packet_integrity_check, use packet_done() instead.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.89 2001/12/21 12:17:33 markus Exp $");
d809 1
a809 1
	packet_done();
d824 1
a824 1
	packet_done();
d837 1
a837 1
	packet_done();
d854 1
a854 1
	packet_done();
d881 1
a881 1
	packet_done();
@


1.89
log
@remove ifdef for USE_PIPES since fdin != fdout; ok djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.88 2001/12/20 22:50:24 djm Exp $");
d809 1
a809 1
	packet_integrity_check(plen, (4 + data_len), type);
d824 1
a824 1
	packet_integrity_check(plen, 0, type);
d837 1
a837 1
	packet_integrity_check(plen, 4 * 4, type);
@


1.88
log
@Conformance fix: we should send failing packet sequence number when
responding with a SSH_MSG_UNIMPLEMENTED message. Spotted by
yakk@@yakk.dot.net; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.87 2001/12/19 16:09:39 markus Exp $");
a408 3
#ifdef USE_PIPES
			close(fdin);
#else
a412 1
#endif
a561 3
#ifdef USE_PIPES
			close(fdin);
#else
a565 1
#endif
@


1.87
log
@fix race between SIGCHLD and select with an additional pipe.  writing
to the pipe on SIGCHLD wakes up select(). using pselect() is not
portable and siglongjmp() ugly. W. R. Stevens suggests similar solution.
initial idea by pmenage@@ensim.com; ok deraadt@@, djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.86 2001/12/19 07:18:56 deraadt Exp $");
d794 1
a794 1
server_input_channel_failure(int type, int plen, void *ctxt)
d807 1
a807 1
server_input_stdin_data(int type, int plen, void *ctxt)
d824 1
a824 1
server_input_eof(int type, int plen, void *ctxt)
d837 1
a837 1
server_input_window_size(int type, int plen, void *ctxt)
d915 1
a915 1
server_input_channel_open(int type, int plen, void *ctxt)
d965 1
a965 1
server_input_global_request(int type, int plen, void *ctxt)
@


1.86
log
@basic KNF done while i was looking for something else
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.85 2001/12/05 03:50:01 itojun Exp $");
d95 45
d147 1
d291 1
d329 2
d520 2
d627 1
d752 2
d755 2
@


1.85
log
@deal with LP64 printf issue with sig_atomic_t.  from thorpej
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.84 2001/11/22 12:34:22 markus Exp $");
d198 1
a198 1
	 * if using client_alive, set the max timeout accordingly, 
d203 1
a203 1
	 * analysis more difficult, but we're not doing it yet.  
d601 1
a601 1
	      stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
d741 1
a741 1
	/* 
d746 1
a746 1
	client_alive_timeouts = 0; 
@


1.84
log
@volatile sig_atomic_t
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.83 2001/11/09 18:59:23 markus Exp $");
d269 2
a270 1
		debug3("tvp!=NULL kid %d mili %d", child_terminated, max_time_milliseconds);
@


1.83
log
@don't memset too much memory, ok millert@@
original patch from jlk@@kamens.brookline.ma.us via nalin@@redhat.com
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.82 2001/10/10 22:18:47 markus Exp $");
d90 1
a90 1
static volatile int child_terminated;	/* The child has terminated. */
@


1.82
log
@try to keep channels open until an exit-status message is sent.
don't kill the login shells if the shells stdin/out/err is closed.
this should now work:
ssh -2n localhost 'exec > /dev/null 2>&1; sleep 10; exit 5'; echo ?
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.81 2001/10/09 21:59:41 markus Exp $");
d275 2
a276 2
		memset(*readsetp, 0, *maxfdp);
		memset(*writesetp, 0, *maxfdp);
@


1.82.2.1
log
@Pull in patches from current (Errata 002):
Update to OpenSSH-3.0.1 via errata patch (Instead of using release tarball)
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.83 2001/11/09 18:59:23 markus Exp $");
d275 2
a276 2
		memset(*readsetp, 0, *nallocp);
		memset(*writesetp, 0, *nallocp);
@


1.82.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.98 2002/02/06 14:55:16 markus Exp $");
d90 1
a90 1
static volatile sig_atomic_t child_terminated = 0;	/* The child has terminated. */
a94 45
/*
 * we write to this pipe if a SIGCHLD is caught in order to avoid
 * the race between select() and child_terminated
 */
static int notify_pipe[2];
static void
notify_setup(void)
{
	if (pipe(notify_pipe) < 0) {
		error("pipe(notify_pipe) failed %s", strerror(errno));
	} else if ((fcntl(notify_pipe[0], F_SETFD, 1) == -1) ||
	    (fcntl(notify_pipe[1], F_SETFD, 1) == -1)) {
		error("fcntl(notify_pipe, F_SETFD) failed %s", strerror(errno));
		close(notify_pipe[0]);
		close(notify_pipe[1]);
	} else {
		set_nonblock(notify_pipe[0]);
		set_nonblock(notify_pipe[1]);
		return;
	}
	notify_pipe[0] = -1;	/* read end */
	notify_pipe[1] = -1;	/* write end */
}
static void
notify_parent(void)
{
	if (notify_pipe[1] != -1)
		write(notify_pipe[1], "", 1);
}
static void
notify_prepare(fd_set *readset)
{
	if (notify_pipe[0] != -1)
		FD_SET(notify_pipe[0], readset);
}
static void
notify_done(fd_set *readset)
{
	char c;

	if (notify_pipe[0] != -1 && FD_ISSET(notify_pipe[0], readset))
		while (read(notify_pipe[0], &c, 1) != -1)
			debug2("notify_done: reading");
}

a101 1
	notify_parent();
a165 1
	static int had_channel = 0;
a167 8
	id = channel_find_open();
	if (id == -1) {
		if (!had_channel)
			return;
		packet_disconnect("No open channels after timeout!");
	}
	had_channel = 1;

d172 3
d198 1
a198 1
	 * if using client_alive, set the max timeout accordingly,
d203 1
a203 1
	 * analysis more difficult, but we're not doing it yet.
a244 1
	notify_prepare(*readsetp);
d269 1
a269 2
		debug3("tvp!=NULL kid %d mili %d", (int) child_terminated,
		    max_time_milliseconds);
a280 2

	notify_done(*readsetp);
d359 3
d366 1
a469 2
	notify_setup();

d514 3
d521 1
a574 1
		max_fd = MAX(max_fd, notify_pipe[0]);
d600 1
a600 1
	    stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
d625 1
a625 1
	wait_pid = waitpid(-1, &wait_status, 0);
d649 2
a650 1
			type = packet_read();
a698 2
	notify_setup();

a699 2
	max_fd = MAX(max_fd, notify_pipe[0]);

d737 1
a737 1
server_input_channel_failure(int type, u_int32_t seq, void *ctxt)
d740 1
a740 1
	/*
d745 1
a745 1
	client_alive_timeouts = 0;
d750 1
a750 1
server_input_stdin_data(int type, u_int32_t seq, void *ctxt)
d760 1
a760 1
	packet_check_eom();
d767 1
a767 1
server_input_eof(int type, u_int32_t seq, void *ctxt)
d775 1
a775 1
	packet_check_eom();
d780 1
a780 1
server_input_window_size(int type, u_int32_t seq, void *ctxt)
d788 1
a788 1
	packet_check_eom();
d805 1
a805 1
	packet_check_eom();
d819 4
d832 1
a832 1
	packet_check_eom();
d842 4
d851 2
d858 1
a858 1
server_input_channel_open(int type, u_int32_t seq, void *ctxt)
d908 1
a908 1
server_input_global_request(int type, u_int32_t seq, void *ctxt)
d940 5
a944 2
			success = channel_setup_remote_fwd_listener(
			    listen_address, listen_port, options.gateway_ports);
a955 27
static void
server_input_channel_req(int type, u_int32_t seq, void *ctxt)
{
	Channel *c;
	int id, reply, success = 0;
	char *rtype;

	id = packet_get_int();
	rtype = packet_get_string(NULL);
	reply = packet_get_char();

	debug("server_input_channel_req: channel %d request %s reply %d",
	    id, rtype, reply);

	if ((c = channel_lookup(id)) == NULL)
		packet_disconnect("server_input_channel_req: "
		    "unknown channel %d", id);
	if (c->type == SSH_CHANNEL_LARVAL || c->type == SSH_CHANNEL_OPEN)
		success = session_input_channel_req(c, rtype);
	if (reply) {
		packet_start(success ?
		    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);
		packet_put_int(c->remote_id);
		packet_send();
	}
	xfree(rtype);
}
d969 1
a969 1
	dispatch_set(SSH2_MSG_CHANNEL_REQUEST, &server_input_channel_req);
@


1.82.2.3
log
@Update OpenSSH to version 3.2.2.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.101 2002/03/30 18:51:15 markus Exp $");
d321 3
d676 4
a679 4
	while ((wait_pid = waitpid(-1, &wait_status, 0)) < 0)
		if (errno != EINTR)
			packet_disconnect("wait: %.100s", strerror(errno));
	if (wait_pid != pid)
d729 2
a730 4
		while ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||
		    (pid < 0 && errno == EINTR))
			if (pid > 0)
				session_close_by_pid(pid, status);
d787 1
a787 1
	session_destroy_all(NULL);
@


1.82.2.4
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.82.2.3 2002/05/17 00:03:24 miod Exp $");
d677 2
a678 2
		error("Strange, wait returned pid %ld, expected %ld",
		    (long)wait_pid, (long)pid);
@


1.82.2.5
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.82.2.4 2002/06/22 07:23:17 miod Exp $");
d905 1
d907 2
a908 1
	u_int rmaxpack, rwindow, len;
@


1.82.2.6
log
@Update to OpenSSH 3.5
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.104 2002/09/19 16:03:15 stevesk Exp $");
a44 1
#include "canohost.h"
d350 1
a350 2
			verbose("Connection closed by %.100s",
			    get_remote_ipaddr());
d357 1
a357 3
				verbose("Read error from remote host "
				    "%.100s: %.100s",
				    get_remote_ipaddr(), strerror(errno));
@


1.81
log
@simplify session close: no more delayed session_close, no more blocking wait() calls.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.80 2001/10/09 19:51:18 markus Exp $");
a210 3
	/* When select fails we restart from here. */
retry_select:

d275 2
d279 1
a279 4
		else
			goto retry_select;
	}
	if (ret == 0 && client_alive_scheduled)
d667 19
d690 1
a690 3
	int rekeying = 0, max_fd, status, nalloc = 0;
	pid_t pid;
	sigset_t oset, nset;
d714 1
a714 10
		/* block SIGCHLD while we check for dead children */
		sigemptyset(&nset);
		sigaddset(&nset, SIGCHLD);
		sigprocmask(SIG_BLOCK, &nset, &oset);
		if (child_terminated) {
			while ((pid = waitpid(-1, &status, WNOHANG)) > 0)
				session_close_by_pid(pid, status);
			child_terminated = 0;
		}
		sigprocmask(SIG_SETMASK, &oset, NULL);
d722 2
d732 2
a733 7
	/* collect remaining dead children, XXX not necessary? */
	signal(SIGCHLD, SIG_DFL);
	while ((pid = waitpid(-1, &status, WNOHANG)) > 0)
		session_close_by_pid(pid, status);

	/* close remaining sessions, e.g remove wtmp entries */
	session_close_all();
@


1.80
log
@close all channels if the connection to the remote host has been closed,
should fix sshd's hanging with WCHAN==wait
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.79 2001/10/04 15:12:37 markus Exp $");
d677 1
d700 5
a707 1
			/* XXX race */
d710 1
a717 3
	/* close all channels, no more reads and writes */
	channel_close_all();

d723 4
a727 2

	/* collect dead children */
a729 5
	/*
	 * there is a race between channel_detach_all() killing remaining
	 * children and children dying before kill()
	 */
	channel_detach_all();
d731 2
a732 10
	while (session_have_children()) {
		pid = waitpid(-1, &status, 0);
		if (pid > 0)
			session_close_by_pid(pid, status);
		else {
			error("waitpid returned %d: %s", pid, strerror(errno));
			break;
		}
	}
	channel_free_all();
@


1.79
log
@client_alive_check cleanup
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.78 2001/10/04 15:05:40 markus Exp $");
d702 1
d712 3
d722 1
d726 2
a727 2
	 * there is a race between channel_free_all() killing children and
	 * children dying before kill()
a729 1
	channel_stop_listening();
@


1.78
log
@comment out bogus conditions for selecting on connection_in
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.77 2001/09/17 21:04:02 markus Exp $");
d83 1
a94 2
int client_alive_timeouts = 0;

d163 20
d283 2
a284 24
	if (ret == 0 && client_alive_scheduled) {
		/* timeout, check to see how many we have had */
		client_alive_timeouts++;

		if (client_alive_timeouts > options.client_alive_count_max ) {
			packet_disconnect(
				"Timeout, your session not responding.");
		} else {
			/*
			 * send a bogus channel request with "wantreply" 
			 * we should get back a failure
			 */
			int id;
			
			id = channel_find_open();
			if (id != -1) {
				channel_request_start(id,
				  "keepalive@@openssh.com", 1);
				packet_send();
			} else 
				packet_disconnect(
					"No open channels after timeout!");
		}
	} 
@


1.77
log
@don't send fake dummy packets on CR (\r)
bugreport from yyua@@cs.sfu.ca via solar@@@@openwall.com
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.76 2001/07/17 21:04:58 markus Exp $");
d199 1
d202 2
a203 1
			FD_SET(connection_in, *readsetp);
@


1.76
log
@keep track of both maxfd and the size of the malloc'ed fdsets.
update maxfd if maxfd gets closed.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.75 2001/07/15 16:17:08 markus Exp $");
d352 2
d358 3
a360 2
		len = write(fdin, buffer_ptr(&stdin_buffer),
		    buffer_len(&stdin_buffer));
d375 2
a376 1
			if (fdin_is_tty && tcgetattr(fdin, &tio) == 0 &&
@


1.75
log
@schedule client alive for ssh2 only, greg@@cheers.bungi.com
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.74 2001/07/02 22:52:57 markus Exp $");
d172 1
a172 1
    u_int max_time_milliseconds)
d196 1
a196 1
	channel_prepare_select(readsetp, writesetp, maxfdp, 0);
d438 1
a438 1
	int max_fd;
d479 1
d481 3
a483 1
	max_fd = MAX(fdin, fdout);
d486 1
a486 2
	max_fd = MAX(max_fd, connection_in);
	max_fd = MAX(max_fd, connection_out);
d572 5
d579 1
a579 1
		    max_time_milliseconds);
d672 1
a672 1
	int rekeying = 0, max_fd, status;
d695 1
a695 1
		    rekeying);
@


1.74
log
@improve cleanup/exit logic in ssh2:
stop listening to channels, detach channel users (e.g. sessions).
wait for children (i.e. dying sessions), send exit messages,
cleanup all channels.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.73 2001/07/02 13:59:14 markus Exp $");
d186 2
a187 1
	if (max_time_milliseconds == 0 && options.client_alive_interval) {
d190 1
a190 2
	} else 
		client_alive_scheduled = 0;
a1002 1

@


1.73
log
@wait until !session_have_children(); bugreport from Lutz.Jaenicke@@aet.TU-Cottbus.DE
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.72 2001/06/27 02:12:52 markus Exp $");
d714 2
a715 1
	channel_free_all();
d726 1
@


1.72
log
@quick hack to make ssh2 work again.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.71 2001/06/25 08:25:39 markus Exp $");
d706 1
a706 1
	channel_free_all();
a707 1
	signal(SIGCHLD, SIG_DFL);
d710 15
@


1.71
log
@update copyright for 2001
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.70 2001/06/23 15:12:19 itojun Exp $");
d62 1
d662 1
a662 1
server_loop2(void)
d676 1
d823 1
a823 1
	if (session_open(c->self) != 1) {
@


1.70
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d14 1
a14 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.69 2001/06/20 13:56:39 markus Exp $");
@


1.69
log
@move from channel_stop_listening to channel_free_all,
call channel_free_all before calling waitpid() in serverloop.
fixes the utmp handling; report from Lutz.Jaenicke@@aet.TU-Cottbus.DE
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.68 2001/06/04 23:07:20 markus Exp $");
d87 1
d90 2
a91 1
void	server_init_dispatch(void);
d95 1
a95 1
void
d109 1
a109 1
void
d138 1
a138 1
void
d169 1
a169 1
void
d291 1
a291 1
void
d347 1
a347 1
void
d395 1
a395 1
void
d420 1
a420 1
void
d711 1
a711 1
void
d724 1
a724 1
void
d741 1
a741 1
void
d754 1
a754 1
void
d768 1
a768 1
Channel *
d801 1
a801 1
Channel *
d832 1
a832 1
void
d882 1
a882 1
void
d932 1
a932 1
void
d952 1
a952 1
void
d967 1
a967 1
void
d975 1
a975 1
void
@


1.68
log
@set flags in the signal handlers, do real work in the main loop, ok provos@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.67 2001/05/31 10:30:16 markus Exp $");
d611 1
a611 2
	/* Stop listening for channels; this removes unix domain sockets. */
	channel_stop_listening();
d702 2
a706 1
	channel_stop_listening();
@


1.67
log
@undo the .c file split, just merge the header and keep the cvs history
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.66 2001/05/30 12:55:12 markus Exp $");
a86 2

static pid_t child_pid;			/* Pid of the child. */
a87 1
static volatile int child_wait_status;	/* Status from wait(). */
a96 2
	pid_t wait_pid;

d98 1
a98 9
	wait_pid = wait((int *) &child_wait_status);
	if (wait_pid != -1) {
		if (wait_pid != child_pid)
			error("Strange, got SIGCHLD and wait returned pid %d but child is %d",
			      wait_pid, child_pid);
		if (WIFEXITED(child_wait_status) ||
		    WIFSIGNALED(child_wait_status))
			child_terminated = 1;
	}
a101 9
void
sigchld_handler2(int sig)
{
	int save_errno = errno;
	debug("Received SIGCHLD.");
	child_terminated = 1;
	signal(SIGCHLD, sigchld_handler2);
	errno = save_errno;
}
a446 1
	child_pid = pid;
a613 19
	/* Wait for the child to exit.  Get its exit status. */
	wait_pid = wait(&wait_status);
	if (wait_pid == -1) {
		/*
		 * It is possible that the wait was handled by SIGCHLD
		 * handler.  This may result in either: this call
		 * returning with EINTR, or: this call returning ECHILD.
		 */
		if (child_terminated)
			wait_status = child_wait_status;
		else
			packet_disconnect("wait: %.100s", strerror(errno));
	} else {
		/* Check if it matches the process we forked. */
		if (wait_pid != pid)
			error("Strange, wait returned pid %d, expected %d",
			       wait_pid, pid);
	}

d617 7
d668 1
a668 1
	signal(SIGCHLD, sigchld_handler2);
@


1.66
log
@channel layer cleanup: merge header files and split .c files
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.65 2001/05/08 19:17:31 markus Exp $");
d46 1
a46 1
#include "channel.h"
@


1.65
log
@adds correct error reporting to async connect()s
fixes the server-discards-data-before-connected-bug found by onoe@@sm.sony.co.jp
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.64 2001/05/04 23:47:34 markus Exp $");
d46 1
a46 1
#include "channels.h"
@


1.64
log
@move to Channel **channels (instead of Channel *channels), fixes realloc problems.
channel_new now returns a Channel *, favour Channel * over channel id.
remove old channel_allocate interface.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.63 2001/04/29 19:16:52 markus Exp $");
d893 8
a900 7

		packet_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);
		packet_put_int(c->remote_id);
		packet_put_int(c->self);
		packet_put_int(c->local_window);
		packet_put_int(c->local_maxpacket);
		packet_send();
d907 1
a907 1
			packet_put_cstring("bla bla");
@


1.63
log
@more ssh.com-2.0.x bug-compat; from per@@appgate.com
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.62 2001/04/29 18:32:52 markus Exp $");
d804 2
a805 1
	int sock, newch;
d824 1
a824 1
	newch = channel_new(ctype, SSH_CHANNEL_CONNECTING,
d827 5
a831 1
	return (newch >= 0) ? channel_lookup(newch) : NULL;
d837 1
a837 1
	int newch;
d847 2
a848 2
	newch = channel_new(ctype, SSH_CHANNEL_LARVAL,
	    -1, -1, -1, 0, CHAN_SES_PACKET_DEFAULT,
d850 8
a857 8
	if (session_open(newch) == 1) {
		channel_register_callback(newch, SSH2_MSG_CHANNEL_REQUEST,
		    session_input_channel_req, (void *)0);
		channel_register_cleanup(newch, session_close_by_channel);
		return channel_lookup(newch);
	} else {
		debug("session open failed, free channel %d", newch);
		channel_free(newch);
d859 4
a862 1
	return NULL;
@


1.62
log
@fix whitespace
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.61 2001/04/13 22:46:54 beck Exp $");
d897 4
a900 2
		packet_put_cstring("bla bla");
		packet_put_cstring("");
@


1.61
log
@Add options ClientAliveInterval and ClientAliveCountMax to sshd.
This gives the ability to do a "keepalive" via the encrypted channel
which can't be spoofed (unlike TCP keepalives). Useful for when you want
to use ssh connections to authenticate people for something, and know
relatively quickly when they are no longer authenticated. Disabled
by default (of course). ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.60 2001/04/05 23:39:20 markus Exp $");
d206 1
a206 1
	        client_alive_scheduled = 1;
d209 1
a209 1
	        client_alive_scheduled = 0;
d749 1
a749 1
         * reset timeout, since we got a sane answer from the client.
@


1.61.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d14 1
a14 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.77 2001/09/17 21:04:02 markus Exp $");
a61 1
static Authctxt *xxx_authctxt;
d88 1
d90 1
d92 1
a92 2
/* prototypes */
static void server_init_dispatch(void);
d96 1
a96 1
static void
d100 19
d121 1
a121 1
	signal(SIGCHLD, sigchld_handler);
d129 1
a129 1
static void
d158 1
a158 1
static void
d189 1
a189 1
static void
d191 1
a191 1
    int *nallocp, u_int max_time_milliseconds)
d205 2
a206 3
	if (compat20 &&
	    max_time_milliseconds == 0 && options.client_alive_interval) {
		client_alive_scheduled = 1;
d208 2
a209 1
	}
d215 1
a215 1
	channel_prepare_select(readsetp, writesetp, maxfdp, nallocp, 0);
d311 1
a311 1
static void
d367 1
a367 1
static void
a370 2
	u_char *data;
	u_int dlen;
d375 2
a376 3
		data = buffer_ptr(&stdin_buffer);
		dlen = buffer_len(&stdin_buffer);
		len = write(fdin, data, dlen);
d391 1
a391 2
			if (fdin_is_tty && dlen >= 1 && data[0] != '\r' &&
			    tcgetattr(fdin, &tio) == 0 &&
d415 1
a415 1
static void
d440 1
a440 1
static void
d457 1
a457 1
	int max_fd = 0, nalloc = 0;
d469 1
a498 1
#if 0
d500 1
a500 3
	max_fd = MAX(connection_in, connection_out);
	max_fd = MAX(max_fd, fdin);
	max_fd = MAX(max_fd, fdout);
d503 2
a504 1
#endif
a589 5
		max_fd = MAX(connection_in, connection_out);
		max_fd = MAX(max_fd, fdin);
		max_fd = MAX(max_fd, fdout);
		max_fd = MAX(max_fd, fderr);

d592 1
a592 1
		    &nalloc, max_time_milliseconds);
d634 21
a654 1
	channel_free_all();
a658 7
	wait_pid = waitpid(-1, &wait_status, child_terminated ? WNOHANG : 0);
	if (wait_pid == -1)
		packet_disconnect("wait: %.100s", strerror(errno));
	else if (wait_pid != pid)
		error("Strange, wait returned pid %d, expected %d",
		    wait_pid, pid);

d695 1
a695 1
server_loop2(Authctxt *authctxt)
d698 1
a698 1
	int rekeying = 0, max_fd, status, nalloc = 0;
d703 1
a703 1
	signal(SIGCHLD, sigchld_handler);
a708 1
	xxx_authctxt = authctxt;
d720 1
a720 1
		    &nalloc, 0);
a738 1

a740 5
	/*
	 * there is a race between channel_free_all() killing children and
	 * children dying before kill()
	 */
	channel_detach_all();
a741 11

	while (session_have_children()) {
		pid = waitpid(-1, &status, 0);
		if (pid > 0)
			session_close_by_pid(pid, status);
		else {
			error("waitpid returned %d: %s", pid, strerror(errno));
			break;
		}
	}
	channel_free_all();
d744 1
a744 1
static void
d749 1
a749 1
	 * reset timeout, since we got a sane answer from the client.
d757 1
a757 1
static void
d774 1
a774 1
static void
d787 1
a787 1
static void
d801 1
a801 1
static Channel *
d804 1
a804 2
	Channel *c;
	int sock;
d823 1
a823 1
	c = channel_new(ctype, SSH_CHANNEL_CONNECTING,
d826 1
a826 5
	if (c == NULL) {
		error("server_request_direct_tcpip: channel_new failed");
		close(sock);
	}
	return c;
d829 1
a829 1
static Channel *
d832 1
a832 1
	Channel *c;
d842 2
a843 2
	c = channel_new(ctype, SSH_CHANNEL_LARVAL,
	    -1, -1, -1, /*window size*/0, CHAN_SES_PACKET_DEFAULT,
d845 8
a852 8
	if (c == NULL) {
		error("server_request_session: channel_new failed");
		return NULL;
	}
	if (session_open(xxx_authctxt, c->self) != 1) {
		debug("session open failed, free channel %d", c->self);
		channel_free(c);
		return NULL;
d854 1
a854 4
	channel_register_callback(c->self, SSH2_MSG_CHANNEL_REQUEST,
	    session_input_channel_req, (void *)0);
	channel_register_cleanup(c->self, session_close_by_channel);
	return c;
d857 1
a857 1
static void
d885 7
a891 8
		if (c->type != SSH_CHANNEL_CONNECTING) {
			packet_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);
			packet_put_int(c->remote_id);
			packet_put_int(c->self);
			packet_put_int(c->local_window);
			packet_put_int(c->local_maxpacket);
			packet_send();
		}
d897 2
a898 4
		if (!(datafellows & SSH_BUG_OPENFAILURE)) {
			packet_put_cstring("open failed");
			packet_put_cstring("");
		}
d904 1
a904 1
static void
d954 1
a954 1
static void
d974 1
a974 1
static void
d989 1
a989 1
static void
d997 1
a997 1
static void
d1007 1
@


1.61.2.2
log
@Merge OpenSSH 3.0
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.61.2.1 2001/09/27 19:03:55 jason Exp $");
a82 1
static int client_alive_timeouts = 0;
d94 2
a163 20
static void
client_alive_check(void)
{
	int id;

	/* timeout, check to see how many we have had */
	if (++client_alive_timeouts > options.client_alive_count_max)
		packet_disconnect("Timeout, your session not responding.");

	id = channel_find_open();
	if (id == -1)
		packet_disconnect("No open channels after timeout!");
	/*
	 * send a bogus channel request with "wantreply",
	 * we should get back a failure
	 */
	channel_request_start(id, "keepalive@@openssh.com", 1);
	packet_send();
}

d192 3
a198 1
#if 0
d201 1
a201 2
#endif
		FD_SET(connection_in, *readsetp);
a256 2
		memset(*readsetp, 0, *maxfdp);
		memset(*writesetp, 0, *maxfdp);
d259 27
a285 2
	} else if (ret == 0 && client_alive_scheduled)
		client_alive_check();
a671 19
static void
collect_children(void)
{
	pid_t pid;
	sigset_t oset, nset;
	int status;

	/* block SIGCHLD while we check for dead children */
	sigemptyset(&nset);
	sigaddset(&nset, SIGCHLD);
	sigprocmask(SIG_BLOCK, &nset, &oset);
	if (child_terminated) {
		while ((pid = waitpid(-1, &status, WNOHANG)) > 0)
			session_close_by_pid(pid, status);
		child_terminated = 0;
	}
	sigprocmask(SIG_SETMASK, &oset, NULL);
}

d676 2
a677 1
	int rekeying = 0, max_fd, nalloc = 0;
d700 5
a704 2

		collect_children();
a711 2
	collect_children();

d717 20
a736 1
	/* free all channels, no more reads and writes */
a737 3

	/* free remaining sessions, e.g. remove wtmp entries */
	session_destroy_all();
@


1.61.2.3
log
@Merge OpenSSH 3.0.1.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.61.2.2 2001/11/15 00:15:19 miod Exp $");
d275 2
a276 2
		memset(*readsetp, 0, *nallocp);
		memset(*writesetp, 0, *nallocp);
@


1.61.2.4
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.98 2002/02/06 14:55:16 markus Exp $");
d90 1
a90 1
static volatile sig_atomic_t child_terminated = 0;	/* The child has terminated. */
a94 45
/*
 * we write to this pipe if a SIGCHLD is caught in order to avoid
 * the race between select() and child_terminated
 */
static int notify_pipe[2];
static void
notify_setup(void)
{
	if (pipe(notify_pipe) < 0) {
		error("pipe(notify_pipe) failed %s", strerror(errno));
	} else if ((fcntl(notify_pipe[0], F_SETFD, 1) == -1) ||
	    (fcntl(notify_pipe[1], F_SETFD, 1) == -1)) {
		error("fcntl(notify_pipe, F_SETFD) failed %s", strerror(errno));
		close(notify_pipe[0]);
		close(notify_pipe[1]);
	} else {
		set_nonblock(notify_pipe[0]);
		set_nonblock(notify_pipe[1]);
		return;
	}
	notify_pipe[0] = -1;	/* read end */
	notify_pipe[1] = -1;	/* write end */
}
static void
notify_parent(void)
{
	if (notify_pipe[1] != -1)
		write(notify_pipe[1], "", 1);
}
static void
notify_prepare(fd_set *readset)
{
	if (notify_pipe[0] != -1)
		FD_SET(notify_pipe[0], readset);
}
static void
notify_done(fd_set *readset)
{
	char c;

	if (notify_pipe[0] != -1 && FD_ISSET(notify_pipe[0], readset))
		while (read(notify_pipe[0], &c, 1) != -1)
			debug2("notify_done: reading");
}

a101 1
	notify_parent();
a165 1
	static int had_channel = 0;
a167 8
	id = channel_find_open();
	if (id == -1) {
		if (!had_channel)
			return;
		packet_disconnect("No open channels after timeout!");
	}
	had_channel = 1;

d172 3
d198 1
a198 1
	 * if using client_alive, set the max timeout accordingly,
d203 1
a203 1
	 * analysis more difficult, but we're not doing it yet.
a244 1
	notify_prepare(*readsetp);
d269 1
a269 2
		debug3("tvp!=NULL kid %d mili %d", (int) child_terminated,
		    max_time_milliseconds);
a280 2

	notify_done(*readsetp);
d359 3
d366 1
a469 2
	notify_setup();

d514 3
d521 1
a574 1
		max_fd = MAX(max_fd, notify_pipe[0]);
d600 1
a600 1
	    stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
d625 1
a625 1
	wait_pid = waitpid(-1, &wait_status, 0);
d649 2
a650 1
			type = packet_read();
a698 2
	notify_setup();

a699 2
	max_fd = MAX(max_fd, notify_pipe[0]);

d737 1
a737 1
server_input_channel_failure(int type, u_int32_t seq, void *ctxt)
d740 1
a740 1
	/*
d745 1
a745 1
	client_alive_timeouts = 0;
d750 1
a750 1
server_input_stdin_data(int type, u_int32_t seq, void *ctxt)
d760 1
a760 1
	packet_check_eom();
d767 1
a767 1
server_input_eof(int type, u_int32_t seq, void *ctxt)
d775 1
a775 1
	packet_check_eom();
d780 1
a780 1
server_input_window_size(int type, u_int32_t seq, void *ctxt)
d788 1
a788 1
	packet_check_eom();
d805 1
a805 1
	packet_check_eom();
d819 4
d832 1
a832 1
	packet_check_eom();
d842 4
d851 2
d858 1
a858 1
server_input_channel_open(int type, u_int32_t seq, void *ctxt)
d908 1
a908 1
server_input_global_request(int type, u_int32_t seq, void *ctxt)
d940 5
a944 2
			success = channel_setup_remote_fwd_listener(
			    listen_address, listen_port, options.gateway_ports);
a955 27
static void
server_input_channel_req(int type, u_int32_t seq, void *ctxt)
{
	Channel *c;
	int id, reply, success = 0;
	char *rtype;

	id = packet_get_int();
	rtype = packet_get_string(NULL);
	reply = packet_get_char();

	debug("server_input_channel_req: channel %d request %s reply %d",
	    id, rtype, reply);

	if ((c = channel_lookup(id)) == NULL)
		packet_disconnect("server_input_channel_req: "
		    "unknown channel %d", id);
	if (c->type == SSH_CHANNEL_LARVAL || c->type == SSH_CHANNEL_OPEN)
		success = session_input_channel_req(c, rtype);
	if (reply) {
		packet_start(success ?
		    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);
		packet_put_int(c->remote_id);
		packet_send();
	}
	xfree(rtype);
}
d969 1
a969 1
	dispatch_set(SSH2_MSG_CHANNEL_REQUEST, &server_input_channel_req);
@


1.61.2.5
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.101 2002/03/30 18:51:15 markus Exp $");
d321 3
d676 4
a679 4
	while ((wait_pid = waitpid(-1, &wait_status, 0)) < 0)
		if (errno != EINTR)
			packet_disconnect("wait: %.100s", strerror(errno));
	if (wait_pid != pid)
d729 2
a730 4
		while ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||
		    (pid < 0 && errno == EINTR))
			if (pid > 0)
				session_close_by_pid(pid, status);
d787 1
a787 1
	session_destroy_all(NULL);
@


1.60
log
@keep the ssh session even if there is no active channel.
this is more in line with the protocol spec and makes
	ssh -N -L 1234:server:110 host
more useful.
based on discussion with <mats@@mindbright.se> long time ago
and recent mail from <res@@shore.net>
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.59 2001/04/05 10:42:51 markus Exp $");
d94 2
d195 15
d259 1
a259 1
		if (max_time_milliseconds == 0)
d275 1
a275 1
	if (ret < 0) {
d281 24
d745 13
d969 2
a970 1

d1007 1
@


1.59
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.58 2001/04/04 22:04:35 markus Exp $");
d80 2
a81 1
static u_int buffer_high;/* "Soft" max buffer size. */
d281 3
d657 1
a657 1
	int had_channel = 0, rekeying = 0, max_fd, status;
a675 6
		if (!had_channel && channel_still_open())
			had_channel = 1;
		if (had_channel && !channel_still_open()) {
			debug("!channel_still_open.");
			break;
		}
d688 2
@


1.58
log
@parse full kexinit packet.
make server-side more robust, too.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.57 2001/04/04 20:25:37 markus Exp $");
d670 1
a670 1
                rekeying = (xxx_kex != NULL && !xxx_kex->done);
@


1.57
log
@more robust rekeying
don't send channel data after rekeying is started.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.56 2001/04/04 14:34:58 markus Exp $");
d653 1
a653 3
	int max_fd;
	int had_channel = 0;
	int status;
d669 3
d678 1
a678 1
		if (packet_not_very_much_data_to_write())
d680 2
a681 1
		wait_until_can_do_something(&readset, &writeset, &max_fd, 0);
d687 2
a688 1
		channel_after_select(readset, writeset);
@


1.56
log
@enable server side rekeying + some rekey related clientup.
todo: we should not send any non-KEX messages after we send KEXINIT
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.55 2001/03/16 19:06:29 markus Exp $");
d197 1
a197 1
	channel_prepare_select(readsetp, writesetp, maxfdp);
@


1.55
log
@implement "permitopen" key option, restricts -L style forwarding to
to specified host:port pairs. based on work by harlan@@genua.de
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.54 2001/03/04 01:46:30 djm Exp $");
d56 1
d60 3
d398 1
a398 1
	dispatch_run(DISPATCH_NONBLOCK, NULL, NULL);
d912 3
@


1.54
log
@Rename pty.[ch] -> sshpty.[ch] and login.[ch] to sshlogin.[ch] to avoid
header conflicts in portable; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.53 2001/03/02 18:54:31 deraadt Exp $");
a756 5
	if (no_port_forwarding_flag || !options.allow_tcp_forwarding) {
		xfree(target);
		xfree(originator);
		return NULL;
	}
d854 1
@


1.53
log
@make copyright lines the same format
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.52 2001/02/28 21:27:48 markus Exp $");
d45 1
a45 1
#include "pty.h"
@


1.52
log
@use ignore message to simulate a SSH2_MSG_CHANNEL_DATA message
use random content in ignore messages.
@
text
@d14 1
a14 1
 * Copyright (c) 2000 Markus Friedl. All rights reserved.
d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.51 2001/02/23 15:34:53 markus Exp $");
@


1.51
log
@debug2->3
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.50 2001/02/19 09:53:32 markus Exp $");
d348 1
a348 3
				packet_start(SSH_MSG_IGNORE);
				memset(buffer_ptr(&stdin_buffer), 0, len);
				packet_put_string(buffer_ptr(&stdin_buffer), len);
@


1.50
log
@ssh-1.2.{18-22} has broken handling of ignore messages; report from itojun@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.49 2001/02/15 23:19:59 markus Exp $");
d248 1
a248 1
		debug2("tvp!=NULL kid %d mili %d", child_terminated, max_time_milliseconds);
@


1.49
log
@genericize password padding function for SSH1 and SSH2.
add stylized echo to 2, too.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.48 2001/02/15 08:38:04 deraadt Exp $");
d73 1
d342 1
a342 1
			if (tcgetattr(fdin, &tio) == 0 &&
d437 3
@


1.48
log
@indent
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.47 2001/02/08 23:11:42 dugsong Exp $");
d342 1
a342 1
			    !(tio.c_lflag & ECHO)) {
@


1.47
log
@mitigate SSH1 traffic analysis - from Solar Designer <solar@@openwall.com>, ok provos@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.46 2001/02/08 19:30:52 itojun Exp $");
d343 4
a346 1
				/* Simulate echo to reduce the impact of traffic analysis. */
@


1.46
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.45 2001/02/04 15:32:25 stevesk Exp $");
d320 1
d340 10
a349 1
			/* Successful write.  Consume the data from the buffer. */
@


1.45
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.44 2001/01/31 20:37:23 markus Exp $");
d122 1
a122 1
make_packets_from_stderr_data()
d151 1
a151 1
make_packets_from_stdout_data()
d355 1
a355 1
drain_output()
d380 1
a380 1
process_buffered_input_packets()
d883 1
a883 1
server_init_dispatch_20()
d899 1
a899 1
server_init_dispatch_13()
d914 1
a914 1
server_init_dispatch_15()
d922 1
a922 1
server_init_dispatch()
@


1.44
log
@do not disconnect if local port forwarding fails, e.g. if port is already in use
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.43 2001/01/29 16:55:37 markus Exp $");
d165 1
a165 1
				len = packet_get_maxsize();	
d833 1
a833 1
void 
d843 1
a843 1
	
@


1.43
log
@fix select overflow; ok deraadt@@ and stevesk@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.42 2001/01/21 19:05:55 markus Exp $");
d865 1
a865 1
			channel_request_forwarding(
a869 1
			success = 1;
@


1.42
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.41 2001/01/19 15:55:11 markus Exp $");
a75 1
static int max_fd;		/* Max file descriptor number for select(). */
d182 2
a183 2
wait_until_can_do_something(fd_set * readset, fd_set * writeset,
			    u_int max_time_milliseconds)
d191 2
a192 3
	/* Initialize select() masks. */
	FD_ZERO(readset);
	FD_ZERO(writeset);
d197 1
a197 1
			FD_SET(connection_in, readset);
d205 1
a205 1
			FD_SET(connection_in, readset);
d212 1
a212 1
				FD_SET(fdout, readset);
d214 1
a214 1
				FD_SET(fderr, readset);
d221 1
a221 1
			FD_SET(fdin, writeset);
a222 2
	/* Set masks for channel descriptors. */
	channel_prepare_select(readset, writeset);
d229 1
a229 5
		FD_SET(connection_out, writeset);

	/* Update the maximum descriptor number if appropriate. */
	if (channel_max_fd() > max_fd)
		max_fd = channel_max_fd();
d250 1
a250 1
	ret = select(max_fd + 1, readset, writeset, NULL, tvp);
d395 2
a396 1
	fd_set readset, writeset;
d436 5
a440 9
	max_fd = fdin;
	if (fdout > max_fd)
		max_fd = fdout;
	if (fderr != -1 && fderr > max_fd)
		max_fd = fderr;
	if (connection_in > max_fd)
		max_fd = connection_in;
	if (connection_out > max_fd)
		max_fd = connection_out;
d527 2
a528 2
		wait_until_can_do_something(&readset, &writeset,
					    max_time_milliseconds);
d531 1
a531 1
		channel_after_select(&readset, &writeset);
d534 1
a534 1
		process_input(&readset);
d537 1
a537 1
		process_output(&writeset);
d539 4
d633 2
a634 1
	fd_set readset, writeset;
d645 3
a647 3
	max_fd = connection_in;
	if (connection_out > max_fd)
		max_fd = connection_out;
d660 1
a660 1
		wait_until_can_do_something(&readset, &writeset, 0);
d666 9
a674 4
		channel_after_select(&readset, &writeset);
		process_input(&readset);
		process_output(&writeset);
	}
@


1.41
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.40 2001/01/18 17:00:00 markus Exp $");
a40 1
#include "ssh.h"
d43 1
a46 1

d54 2
@


1.40
log
@1) removes fake skey from sshd, since this will be much
   harder with /usr/libexec/auth/login_XXX
2) share/unify code used in ssh-1 and ssh-2 authentication (server side)
3) make addition of BSD_AUTH and other challenge reponse methods
   easier.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.39 2000/12/27 14:19:21 markus Exp $");
d49 1
@


1.39
log
@less chatty
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.38 2000/12/19 23:17:58 markus Exp $");
d50 1
a53 1
#include "auth.h"
@


1.38
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.37 2000/12/11 20:16:22 deraadt Exp $");
d253 1
a253 1
		debug("tvp!=NULL kid %d mili %d", child_terminated, max_time_milliseconds);
@


1.37
log
@wait indicates failure by returning -1, not arbitrary values < 0
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.36 2000/12/05 20:34:10 markus Exp $");
d73 1
a73 1
static unsigned int buffer_high;/* "Soft" max buffer size. */
d182 1
a182 1
			    unsigned int max_time_milliseconds)
d405 3
a407 3
	unsigned int max_time_milliseconds;
	unsigned int previous_stdout_buffer_bytes;
	unsigned int stdout_buffer_bytes;
d684 1
a684 1
	unsigned int data_len;
d790 1
a790 1
	unsigned int len;
@


1.36
log
@async connects for -R/-L; ok deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.35 2000/11/06 23:04:56 markus Exp $");
d580 1
a580 1
	if (wait_pid < 0) {
@


1.35
log
@agent forwarding and -R for ssh2, based on work from jhuuskon@@messi.uku.fi
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.34 2000/10/27 07:32:18 markus Exp $");
d751 1
a751 1
	newch = channel_new(ctype, SSH_CHANNEL_OPEN,
@


1.34
log
@enable non-blocking IO on channels, and tty's (except for the client ttys).
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.33 2000/10/16 09:38:44 djm Exp $");
d53 1
d724 2
a725 2
int
input_direct_tcpip(void)
d727 1
a727 1
	int sock;
d737 1
a737 1
	debug("open direct-tcpip: from %s port %d to %s port %d",
d744 1
a744 1
		return -1;
d750 2
a751 2
		return -1;
	return channel_new("direct-tcpip", SSH_CHANNEL_OPEN,
d754 29
a789 1
	int id;
d804 1
a804 21
		debug("open session");
		packet_done();
		/*
		 * A server session has no fd to read or write
		 * until a CHANNEL_REQUEST for a shell is made,
		 * so we set the type to SSH_CHANNEL_LARVAL.
		 * Additionally, a callback for handling all
		 * CHANNEL_REQUEST messages is registered.
		 */
		id = channel_new(ctype, SSH_CHANNEL_LARVAL,
		    -1, -1, -1, 0, CHAN_SES_PACKET_DEFAULT,
		    0, xstrdup("server-session"), 1);
		if (session_open(id) == 1) {
			channel_register_callback(id, SSH2_MSG_CHANNEL_REQUEST,
			    session_input_channel_req, (void *)0);
			channel_register_cleanup(id, session_close_by_channel);
			c = channel_lookup(id);
		} else {
			debug("session open failed, free channel %d", id);
			channel_free(id);
		}
d806 1
a806 3
		id = input_direct_tcpip();
		if (id >= 0)
			c = channel_lookup(id);
d809 1
a809 1
		debug("confirm %s", ctype);
d821 1
a821 1
		debug("failure %s", ctype);
d832 50
d896 1
@


1.34.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.49 2001/02/15 23:19:59 markus Exp $");
d41 1
a43 1
#include "log.h"
d47 1
a48 1
#include "ssh1.h"
a49 1
#include "auth.h"
a52 2
#include "serverloop.h"
#include "misc.h"
d72 2
a73 1
static u_int buffer_high;/* "Soft" max buffer size. */
d120 1
a120 1
make_packets_from_stderr_data(void)
d149 1
a149 1
make_packets_from_stdout_data(void)
d163 1
a163 1
				len = packet_get_maxsize();
d180 2
a181 2
wait_until_can_do_something(fd_set **readsetp, fd_set **writesetp, int *maxfdp,
    u_int max_time_milliseconds)
d189 3
a191 2
	/* Allocate and update select() masks for channel descriptors. */
	channel_prepare_select(readsetp, writesetp, maxfdp);
d196 1
a196 1
			FD_SET(connection_in, *readsetp);
d204 1
a204 1
			FD_SET(connection_in, *readsetp);
d211 1
a211 1
				FD_SET(fdout, *readsetp);
d213 1
a213 1
				FD_SET(fderr, *readsetp);
d220 1
a220 1
			FD_SET(fdin, *writesetp);
d222 2
d230 5
a234 1
		FD_SET(connection_out, *writesetp);
d252 1
a252 1
		debug2("tvp!=NULL kid %d mili %d", child_terminated, max_time_milliseconds);
d255 1
a255 1
	ret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);
a324 1
	struct termios tio;
d344 1
a344 13
			/* Successful write. */
			if (tcgetattr(fdin, &tio) == 0 &&
			    !(tio.c_lflag & ECHO) && (tio.c_lflag & ICANON)) {
				/*
				 * Simulate echo to reduce the impact of
				 * traffic analysis
				 */
				packet_start(SSH_MSG_IGNORE);
				memset(buffer_ptr(&stdin_buffer), 0, len);
				packet_put_string(buffer_ptr(&stdin_buffer), len);
				packet_send();
			}
			/* Consume the data from the buffer. */
d360 1
a360 1
drain_output(void)
d385 1
a385 1
process_buffered_input_packets(void)
d400 1
a400 2
	fd_set *readset = NULL, *writeset = NULL;
	int max_fd;
d404 3
a406 3
	u_int max_time_milliseconds;
	u_int previous_stdout_buffer_bytes;
	u_int stdout_buffer_bytes;
d440 9
a448 5
	max_fd = MAX(fdin, fdout);
	if (fderr != -1)
		max_fd = MAX(max_fd, fderr);
	max_fd = MAX(max_fd, connection_in);
	max_fd = MAX(max_fd, connection_out);
d535 2
a536 2
		wait_until_can_do_something(&readset, &writeset, &max_fd,
		    max_time_milliseconds);
d539 1
a539 1
		channel_after_select(readset, writeset);
d542 1
a542 1
		process_input(readset);
d545 1
a545 1
		process_output(writeset);
a546 4
	if (readset)
		xfree(readset);
	if (writeset)
		xfree(writeset);
d579 1
a579 1
	if (wait_pid == -1) {
d637 1
a637 2
	fd_set *readset = NULL, *writeset = NULL;
	int max_fd;
d648 3
a650 3

	max_fd = MAX(connection_in, connection_out);

d663 1
a663 1
		wait_until_can_do_something(&readset, &writeset, &max_fd, 0);
d669 4
a672 9
		channel_after_select(readset, writeset);
		process_input(readset);
		process_output(writeset);
	}
	if (readset)
		xfree(readset);
	if (writeset)
		xfree(writeset);

d683 1
a683 1
	u_int data_len;
d723 2
a724 2
Channel *
server_request_direct_tcpip(char *ctype)
d726 1
a726 1
	int sock, newch;
d736 1
a736 1
	debug("server_request_direct_tcpip: originator %s port %d, target %s port %d",
d743 1
a743 1
		return NULL;
d749 2
a750 2
		return NULL;
	newch = channel_new(ctype, SSH_CHANNEL_CONNECTING,
a752 29
	return (newch >= 0) ? channel_lookup(newch) : NULL;
}

Channel *
server_request_session(char *ctype)
{
	int newch;

	debug("input_session_request");
	packet_done();
	/*
	 * A server session has no fd to read or write until a
	 * CHANNEL_REQUEST for a shell is made, so we set the type to
	 * SSH_CHANNEL_LARVAL.  Additionally, a callback for handling all
	 * CHANNEL_REQUEST messages is registered.
	 */
	newch = channel_new(ctype, SSH_CHANNEL_LARVAL,
	    -1, -1, -1, 0, CHAN_SES_PACKET_DEFAULT,
	    0, xstrdup("server-session"), 1);
	if (session_open(newch) == 1) {
		channel_register_callback(newch, SSH2_MSG_CHANNEL_REQUEST,
		    session_input_channel_req, (void *)0);
		channel_register_cleanup(newch, session_close_by_channel);
		return channel_lookup(newch);
	} else {
		debug("session open failed, free channel %d", newch);
		channel_free(newch);
	}
	return NULL;
d760 2
a761 1
	u_int len;
d775 21
a795 1
		c = server_request_session(ctype);
d797 3
a799 1
		c = server_request_direct_tcpip(ctype);
d802 1
a802 1
		debug("server_input_channel_open: confirm %s", ctype);
d814 1
a814 1
		debug("server_input_channel_open: failure %s", ctype);
d826 1
a826 50
server_input_global_request(int type, int plen, void *ctxt)
{
	char *rtype;
	int want_reply;
	int success = 0;

	rtype = packet_get_string(NULL);
	want_reply = packet_get_char();
	debug("server_input_global_request: rtype %s want_reply %d", rtype, want_reply);

	if (strcmp(rtype, "tcpip-forward") == 0) {
		struct passwd *pw;
		char *listen_address;
		u_short listen_port;

		pw = auth_get_user();
		if (pw == NULL)
			fatal("server_input_global_request: no user");
		listen_address = packet_get_string(NULL); /* XXX currently ignored */
		listen_port = (u_short)packet_get_int();
		debug("server_input_global_request: tcpip-forward listen %s port %d",
		    listen_address, listen_port);

		/* check permissions */
		if (!options.allow_tcp_forwarding ||
		    no_port_forwarding_flag ||
		    (listen_port < IPPORT_RESERVED && pw->pw_uid != 0)) {
			success = 0;
			packet_send_debug("Server has disabled port forwarding.");
		} else {
			/* Start listening on the port */
			success = channel_request_forwarding(
			    listen_address, listen_port,
			    /*unspec host_to_connect*/ "<unspec host>",
			    /*unspec port_to_connect*/ 0,
			    options.gateway_ports, /*remote*/ 1);
		}
		xfree(listen_address);
	}
	if (want_reply) {
		packet_start(success ?
		    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);
		packet_send();
		packet_write_wait();
	}
	xfree(rtype);
}

void
server_init_dispatch_20(void)
a838 1
	dispatch_set(SSH2_MSG_GLOBAL_REQUEST, &server_input_global_request);
d841 1
a841 1
server_init_dispatch_13(void)
d856 1
a856 1
server_init_dispatch_15(void)
d864 1
a864 1
server_init_dispatch(void)
@


1.34.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.50 2001/02/19 09:53:32 markus Exp $");
a72 1
static int fdin_is_tty = 0;	/* fdin points to a tty. */
d341 1
a341 1
			if (fdin_is_tty && tcgetattr(fdin, &tio) == 0 &&
a435 3

	if (!(datafellows & SSH_BUG_IGNOREMSG) && isatty(fdin))
		fdin_is_tty = 1;
@


1.34.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d14 1
a14 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.55 2001/03/16 19:06:29 markus Exp $");
d45 1
a45 1
#include "sshpty.h"
d248 1
a248 1
		debug3("tvp!=NULL kid %d mili %d", child_terminated, max_time_milliseconds);
d348 3
a350 1
				packet_send_ignore(len);
d759 5
a860 1
	/* -R style forwarding */
@


1.34.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.61 2001/04/13 22:46:54 beck Exp $");
a55 1
#include "kex.h"
a58 3
/* XXX */
extern Kex *xxx_kex;

d76 1
a76 2
static int connection_closed = 0;	/* Connection to client closed. */
static u_int buffer_high;	/* "Soft" max buffer size. */
a88 2
int client_alive_timeouts = 0;

a187 15
	int client_alive_scheduled = 0;

	/*
	 * if using client_alive, set the max timeout accordingly, 
	 * and indicate that this particular timeout was for client
	 * alive by setting the client_alive_scheduled flag.
	 *
	 * this could be randomized somewhat to make traffic
	 * analysis more difficult, but we're not doing it yet.  
	 */
	if (max_time_milliseconds == 0 && options.client_alive_interval) {
	        client_alive_scheduled = 1;
		max_time_milliseconds = options.client_alive_interval * 1000;
	} else 
	        client_alive_scheduled = 0;
d193 1
a193 1
	channel_prepare_select(readsetp, writesetp, maxfdp, 0);
d237 1
a237 1
		if (max_time_milliseconds == 0 || client_alive_scheduled)
d253 1
a253 1
	if (ret == -1) {
a258 24
	if (ret == 0 && client_alive_scheduled) {
		/* timeout, check to see how many we have had */
		client_alive_timeouts++;

		if (client_alive_timeouts > options.client_alive_count_max ) {
			packet_disconnect(
				"Timeout, your session not responding.");
		} else {
			/*
			 * send a bogus channel request with "wantreply" 
			 * we should get back a failure
			 */
			int id;
			
			id = channel_find_open();
			if (id != -1) {
				channel_request_start(id,
				  "keepalive@@openssh.com", 1);
				packet_send();
			} else 
				packet_disconnect(
					"No open channels after timeout!");
		}
	} 
a275 3
			connection_closed = 1;
			if (compat20)
				return;
d394 1
a394 1
	dispatch_run(DISPATCH_NONBLOCK, NULL, compat20 ? xxx_kex : NULL);
d649 3
a651 1
	int rekeying = 0, max_fd, status;
d667 7
a673 4

		rekeying = (xxx_kex != NULL && !xxx_kex->done);

		if (!rekeying && packet_not_very_much_data_to_write())
d675 1
a675 2
		wait_until_can_do_something(&readset, &writeset, &max_fd,
		    rekeying);
d681 1
a681 2
		if (!rekeying)
			channel_after_select(readset, writeset);
a682 2
		if (connection_closed)
			break;
a696 13
server_input_channel_failure(int type, int plen, void *ctxt)
{
	debug("Got CHANNEL_FAILURE for keepalive");
	/* 
         * reset timeout, since we got a sane answer from the client.
	 * even if this was generated by something other than
	 * the bogus CHANNEL_REQUEST we send for keepalives.
	 */
	client_alive_timeouts = 0; 
}


void
a907 4
	/* client_alive */
	dispatch_set(SSH2_MSG_CHANNEL_FAILURE, &server_input_channel_failure);
	/* rekeying */
	dispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);
a941 1

@


1.34.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d14 1
a14 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.77 2001/09/17 21:04:02 markus Exp $");
a61 1
static Authctxt *xxx_authctxt;
d88 1
d90 1
d92 1
a92 2
/* prototypes */
static void server_init_dispatch(void);
d96 1
a96 1
static void
d100 19
d121 1
a121 1
	signal(SIGCHLD, sigchld_handler);
d129 1
a129 1
static void
d158 1
a158 1
static void
d189 1
a189 1
static void
d191 1
a191 1
    int *nallocp, u_int max_time_milliseconds)
d205 2
a206 3
	if (compat20 &&
	    max_time_milliseconds == 0 && options.client_alive_interval) {
		client_alive_scheduled = 1;
d208 2
a209 1
	}
d215 1
a215 1
	channel_prepare_select(readsetp, writesetp, maxfdp, nallocp, 0);
d311 1
a311 1
static void
d367 1
a367 1
static void
a370 2
	u_char *data;
	u_int dlen;
d375 2
a376 3
		data = buffer_ptr(&stdin_buffer);
		dlen = buffer_len(&stdin_buffer);
		len = write(fdin, data, dlen);
d391 1
a391 2
			if (fdin_is_tty && dlen >= 1 && data[0] != '\r' &&
			    tcgetattr(fdin, &tio) == 0 &&
d415 1
a415 1
static void
d440 1
a440 1
static void
d457 1
a457 1
	int max_fd = 0, nalloc = 0;
d469 1
a498 1
#if 0
d500 1
a500 3
	max_fd = MAX(connection_in, connection_out);
	max_fd = MAX(max_fd, fdin);
	max_fd = MAX(max_fd, fdout);
d503 2
a504 1
#endif
a589 5
		max_fd = MAX(connection_in, connection_out);
		max_fd = MAX(max_fd, fdin);
		max_fd = MAX(max_fd, fdout);
		max_fd = MAX(max_fd, fderr);

d592 1
a592 1
		    &nalloc, max_time_milliseconds);
d634 21
a654 1
	channel_free_all();
a658 7
	wait_pid = waitpid(-1, &wait_status, child_terminated ? WNOHANG : 0);
	if (wait_pid == -1)
		packet_disconnect("wait: %.100s", strerror(errno));
	else if (wait_pid != pid)
		error("Strange, wait returned pid %d, expected %d",
		    wait_pid, pid);

d695 1
a695 1
server_loop2(Authctxt *authctxt)
d698 1
a698 1
	int rekeying = 0, max_fd, status, nalloc = 0;
d703 1
a703 1
	signal(SIGCHLD, sigchld_handler);
a708 1
	xxx_authctxt = authctxt;
d720 1
a720 1
		    &nalloc, 0);
a738 1

a740 5
	/*
	 * there is a race between channel_free_all() killing children and
	 * children dying before kill()
	 */
	channel_detach_all();
a741 11

	while (session_have_children()) {
		pid = waitpid(-1, &status, 0);
		if (pid > 0)
			session_close_by_pid(pid, status);
		else {
			error("waitpid returned %d: %s", pid, strerror(errno));
			break;
		}
	}
	channel_free_all();
d744 1
a744 1
static void
d749 1
a749 1
	 * reset timeout, since we got a sane answer from the client.
d757 1
a757 1
static void
d774 1
a774 1
static void
d787 1
a787 1
static void
d801 1
a801 1
static Channel *
d804 1
a804 2
	Channel *c;
	int sock;
d823 1
a823 1
	c = channel_new(ctype, SSH_CHANNEL_CONNECTING,
d826 1
a826 5
	if (c == NULL) {
		error("server_request_direct_tcpip: channel_new failed");
		close(sock);
	}
	return c;
d829 1
a829 1
static Channel *
d832 1
a832 1
	Channel *c;
d842 2
a843 2
	c = channel_new(ctype, SSH_CHANNEL_LARVAL,
	    -1, -1, -1, /*window size*/0, CHAN_SES_PACKET_DEFAULT,
d845 8
a852 8
	if (c == NULL) {
		error("server_request_session: channel_new failed");
		return NULL;
	}
	if (session_open(xxx_authctxt, c->self) != 1) {
		debug("session open failed, free channel %d", c->self);
		channel_free(c);
		return NULL;
d854 1
a854 4
	channel_register_callback(c->self, SSH2_MSG_CHANNEL_REQUEST,
	    session_input_channel_req, (void *)0);
	channel_register_cleanup(c->self, session_close_by_channel);
	return c;
d857 1
a857 1
static void
d885 7
a891 8
		if (c->type != SSH_CHANNEL_CONNECTING) {
			packet_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);
			packet_put_int(c->remote_id);
			packet_put_int(c->self);
			packet_put_int(c->local_window);
			packet_put_int(c->local_maxpacket);
			packet_send();
		}
d897 2
a898 4
		if (!(datafellows & SSH_BUG_OPENFAILURE)) {
			packet_put_cstring("open failed");
			packet_put_cstring("");
		}
d904 1
a904 1
static void
d954 1
a954 1
static void
d974 1
a974 1
static void
d989 1
a989 1
static void
d997 1
a997 1
static void
d1007 1
@


1.34.2.6
log
@Merge OpenSSH 3.0
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.34.2.5 2001/09/27 00:15:42 miod Exp $");
a82 1
static int client_alive_timeouts = 0;
d94 2
a163 20
static void
client_alive_check(void)
{
	int id;

	/* timeout, check to see how many we have had */
	if (++client_alive_timeouts > options.client_alive_count_max)
		packet_disconnect("Timeout, your session not responding.");

	id = channel_find_open();
	if (id == -1)
		packet_disconnect("No open channels after timeout!");
	/*
	 * send a bogus channel request with "wantreply",
	 * we should get back a failure
	 */
	channel_request_start(id, "keepalive@@openssh.com", 1);
	packet_send();
}

d192 3
a198 1
#if 0
d201 1
a201 2
#endif
		FD_SET(connection_in, *readsetp);
a256 2
		memset(*readsetp, 0, *maxfdp);
		memset(*writesetp, 0, *maxfdp);
d259 27
a285 2
	} else if (ret == 0 && client_alive_scheduled)
		client_alive_check();
a671 19
static void
collect_children(void)
{
	pid_t pid;
	sigset_t oset, nset;
	int status;

	/* block SIGCHLD while we check for dead children */
	sigemptyset(&nset);
	sigaddset(&nset, SIGCHLD);
	sigprocmask(SIG_BLOCK, &nset, &oset);
	if (child_terminated) {
		while ((pid = waitpid(-1, &status, WNOHANG)) > 0)
			session_close_by_pid(pid, status);
		child_terminated = 0;
	}
	sigprocmask(SIG_SETMASK, &oset, NULL);
}

d676 2
a677 1
	int rekeying = 0, max_fd, nalloc = 0;
d700 5
a704 2

		collect_children();
a711 2
	collect_children();

d717 20
a736 1
	/* free all channels, no more reads and writes */
a737 3

	/* free remaining sessions, e.g. remove wtmp entries */
	session_destroy_all();
@


1.34.2.7
log
@Merge OpenSSH 3.0.1.

This is likely to be the last commit to the 2.8-STABLE branch.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.34.2.6 2001/11/15 00:14:59 miod Exp $");
d275 2
a276 2
		memset(*readsetp, 0, *nallocp);
		memset(*writesetp, 0, *nallocp);
@


1.34.2.8
log
@Merge OpenSSH 3.1.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.98 2002/02/06 14:55:16 markus Exp $");
d90 1
a90 1
static volatile sig_atomic_t child_terminated = 0;	/* The child has terminated. */
a94 45
/*
 * we write to this pipe if a SIGCHLD is caught in order to avoid
 * the race between select() and child_terminated
 */
static int notify_pipe[2];
static void
notify_setup(void)
{
	if (pipe(notify_pipe) < 0) {
		error("pipe(notify_pipe) failed %s", strerror(errno));
	} else if ((fcntl(notify_pipe[0], F_SETFD, 1) == -1) ||
	    (fcntl(notify_pipe[1], F_SETFD, 1) == -1)) {
		error("fcntl(notify_pipe, F_SETFD) failed %s", strerror(errno));
		close(notify_pipe[0]);
		close(notify_pipe[1]);
	} else {
		set_nonblock(notify_pipe[0]);
		set_nonblock(notify_pipe[1]);
		return;
	}
	notify_pipe[0] = -1;	/* read end */
	notify_pipe[1] = -1;	/* write end */
}
static void
notify_parent(void)
{
	if (notify_pipe[1] != -1)
		write(notify_pipe[1], "", 1);
}
static void
notify_prepare(fd_set *readset)
{
	if (notify_pipe[0] != -1)
		FD_SET(notify_pipe[0], readset);
}
static void
notify_done(fd_set *readset)
{
	char c;

	if (notify_pipe[0] != -1 && FD_ISSET(notify_pipe[0], readset))
		while (read(notify_pipe[0], &c, 1) != -1)
			debug2("notify_done: reading");
}

a101 1
	notify_parent();
a165 1
	static int had_channel = 0;
a167 8
	id = channel_find_open();
	if (id == -1) {
		if (!had_channel)
			return;
		packet_disconnect("No open channels after timeout!");
	}
	had_channel = 1;

d172 3
d198 1
a198 1
	 * if using client_alive, set the max timeout accordingly,
d203 1
a203 1
	 * analysis more difficult, but we're not doing it yet.
a244 1
	notify_prepare(*readsetp);
d269 1
a269 2
		debug3("tvp!=NULL kid %d mili %d", (int) child_terminated,
		    max_time_milliseconds);
a280 2

	notify_done(*readsetp);
d359 3
d366 1
a469 2
	notify_setup();

d514 3
d521 1
a574 1
		max_fd = MAX(max_fd, notify_pipe[0]);
d600 1
a600 1
	    stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
d625 1
a625 1
	wait_pid = waitpid(-1, &wait_status, 0);
d649 2
a650 1
			type = packet_read();
a698 2
	notify_setup();

a699 2
	max_fd = MAX(max_fd, notify_pipe[0]);

d737 1
a737 1
server_input_channel_failure(int type, u_int32_t seq, void *ctxt)
d740 1
a740 1
	/*
d745 1
a745 1
	client_alive_timeouts = 0;
d750 1
a750 1
server_input_stdin_data(int type, u_int32_t seq, void *ctxt)
d760 1
a760 1
	packet_check_eom();
d767 1
a767 1
server_input_eof(int type, u_int32_t seq, void *ctxt)
d775 1
a775 1
	packet_check_eom();
d780 1
a780 1
server_input_window_size(int type, u_int32_t seq, void *ctxt)
d788 1
a788 1
	packet_check_eom();
d805 1
a805 1
	packet_check_eom();
d819 4
d832 1
a832 1
	packet_check_eom();
d842 4
d851 2
d858 1
a858 1
server_input_channel_open(int type, u_int32_t seq, void *ctxt)
d908 1
a908 1
server_input_global_request(int type, u_int32_t seq, void *ctxt)
d940 5
a944 2
			success = channel_setup_remote_fwd_listener(
			    listen_address, listen_port, options.gateway_ports);
a955 27
static void
server_input_channel_req(int type, u_int32_t seq, void *ctxt)
{
	Channel *c;
	int id, reply, success = 0;
	char *rtype;

	id = packet_get_int();
	rtype = packet_get_string(NULL);
	reply = packet_get_char();

	debug("server_input_channel_req: channel %d request %s reply %d",
	    id, rtype, reply);

	if ((c = channel_lookup(id)) == NULL)
		packet_disconnect("server_input_channel_req: "
		    "unknown channel %d", id);
	if (c->type == SSH_CHANNEL_LARVAL || c->type == SSH_CHANNEL_OPEN)
		success = session_input_channel_req(c, rtype);
	if (reply) {
		packet_start(success ?
		    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);
		packet_put_int(c->remote_id);
		packet_send();
	}
	xfree(rtype);
}
d969 1
a969 1
	dispatch_set(SSH2_MSG_CHANNEL_REQUEST, &server_input_channel_req);
@


1.33
log
@Add idents for files which lack them

Fix idents Id -> OpenBSD for the rest
@
text
@d38 1
a38 1
RCSID("$OpenBSD$");
d752 1
a752 1
	    CHAN_TCP_PACKET_DEFAULT, 0, xstrdup("direct-tcpip"));
d786 1
a786 1
		    0, xstrdup("server-session"));
@


1.32
log
@AllowTcpForwarding; from naddy@@
@
text
@d38 2
@


1.31
log
@add context to dispatch_run
@
text
@d52 2
d738 1
a738 1
	if (no_port_forwarding_flag) {
@


1.30
log
@typo
@
text
@d383 1
a383 1
	dispatch_run(DISPATCH_NONBLOCK, NULL);
d676 1
a676 1
server_input_stdin_data(int type, int plen)
d693 1
a693 1
server_input_eof(int type, int plen)
d706 1
a706 1
server_input_window_size(int type, int plen)
d752 1
a752 1
server_input_channel_open(int type, int plen)
@


1.29
log
@cleanup window and packet sizes for ssh2 flow control; ok niels
@
text
@d767 1
a767 1
	debug("channel_input_open: ctype %s rchan %d win %d max %d",
@


1.28
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d747 2
a748 1
	    sock, sock, -1, 4*1024, 32*1024, 0, xstrdup("direct-tcpip"));
d781 2
a782 1
		    -1, -1, -1, 0, 32*1024, 0, xstrdup("server-session"));
@


1.27
log
@sense of port forwarding flag test was backwards
@
text
@a4 1
 * Created: Sun Sep 10 00:30:37 1995 ylo
d6 7
a12 2
 */
/*
d15 20
@


1.26
log
@split auth-rsa option parsing into auth-options
add options support to authorized_keys2
@
text
@d712 1
a712 1
	if (! no_port_forwarding_flag) {
@


1.25
log
@group ssh1 vs. ssh2 in serverloop
@
text
@d26 1
d710 1
d712 5
@


1.24
log
@we don't have stderr for interactive terminal sessions (fcntl errors)
@
text
@d162 1
a163 4
	/*
	 * Read packets from the client unless we have too much buffered
	 * stdin or channel data.
	 */
d169 5
a173 1
		if (buffer_len(&stdin_buffer) < 4096 &&
d176 16
a192 13

	/*
	 * If there is not too much data already buffered going to the
	 * client, try to get some more data from the program.
	 */
	if (!compat20 && packet_not_very_much_data_to_write()) {
		if (!fdout_eof)
			FD_SET(fdout, readset);
		if (!fderr_eof)
			FD_SET(fderr, readset);
	}
	FD_ZERO(writeset);

a202 5
	/* If we have buffered data, try to write some of that data to the
	   program. */
	if (!compat20 && fdin != -1 && buffer_len(&stdin_buffer) > 0)
		FD_SET(fdin, writeset);

d371 1
a438 1
		fd_set readset, writeset;
d706 3
a759 1
		debug("open direct-tcpip");
@


1.23
log
@enable nonblocking IO for sshd w/ proto 1, too; split out common code
@
text
@d395 3
a397 1
	set_nonblock(fderr);
@


1.22
log
@use c-style comments
@
text
@d253 8
a261 13
		/*
		 * There is a kernel bug on Solaris that causes select to
		 * sometimes wake up even though there is no data available.
		 */
		if (len < 0 && errno == EAGAIN)
			len = 0;

		if (len < 0) {
			verbose("Read error from remote host: %.100s", strerror(errno));
			fatal_cleanup();
		}
		/* Buffer any received data. */
		packet_process_incoming(buf, len);
d269 3
a271 1
		if (len <= 0)
d273 1
a273 1
		else {
d281 3
a283 1
		if (len <= 0)
d285 1
a285 1
		else
d287 1
d303 3
a305 1
		if (len <= 0) {
d391 6
@


1.22.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@a161 1
	FD_ZERO(writeset);
d163 4
d172 1
a172 5
		/*
		 * Read packets from the client unless we have too much
		 * buffered stdin or channel data.
		 */
		if (buffer_len(&stdin_buffer) < buffer_high &&
a174 16
		/*
		 * If there is not too much data already buffered going to
		 * the client, try to get some more data from the program.
		 */
		if (packet_not_very_much_data_to_write()) {
			if (!fdout_eof)
				FD_SET(fdout, readset);
			if (!fderr_eof)
				FD_SET(fderr, readset);
		}
		/*
		 * If we have buffered data, try to write some of that data
		 * to the program.
		 */
		if (fdin != -1 && buffer_len(&stdin_buffer) > 0)
			FD_SET(fdin, writeset);
d176 13
d199 5
a252 8
		} else if (len < 0) {
			if (errno != EINTR && errno != EAGAIN) {
				verbose("Read error from remote host: %.100s", strerror(errno));
				fatal_cleanup();
			}
		} else {
			/* Buffer any received data. */
			packet_process_incoming(buf, len);
d254 13
d274 1
a274 3
		if (len < 0 && (errno == EINTR || errno == EAGAIN)) {
			/* do nothing */
		} else if (len <= 0) {
d276 1
a276 1
		} else {
d284 1
a284 3
		if (len < 0 && (errno == EINTR || errno == EAGAIN)) {
			/* do nothing */
		} else if (len <= 0) {
d286 1
a286 1
		} else {
a287 1
		}
d303 1
a303 3
		if (len < 0 && (errno == EINTR || errno == EAGAIN)) {
			/* do nothing */
		} else if (len <= 0) {
a369 1
	fd_set readset, writeset;
a388 8

	/* nonblocking IO */
	set_nonblock(fdin);
	set_nonblock(fdout);
	/* we don't have stderr for interactive terminal sessions, see below */
	if (fderr != -1)
		set_nonblock(fderr);

d429 1
a696 3

	debug("open direct-tcpip: from %s port %d to %s port %d",
	   originator, originator_port, target, target_port);
d748 1
@


1.22.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@a25 1
#include "auth-options.h"
a708 1

a709 5
	if (no_port_forwarding_flag) {
		xfree(target);
		xfree(originator);
		return -1;
	}
@


1.22.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d5 1
d7 2
a8 7
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
a10 20
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a13 2
RCSID("$OpenBSD: serverloop.c,v 1.34 2000/10/27 07:32:18 markus Exp $");

a27 2
extern ServerOptions options;

d359 1
a359 1
	dispatch_run(DISPATCH_NONBLOCK, NULL, NULL);
d652 1
a652 1
server_input_stdin_data(int type, int plen, void *ctxt)
d669 1
a669 1
server_input_eof(int type, int plen, void *ctxt)
d682 1
a682 1
server_input_window_size(int type, int plen, void *ctxt)
d712 1
a712 1
	if (no_port_forwarding_flag || !options.allow_tcp_forwarding) {
d723 1
a723 2
	    sock, sock, -1, CHAN_TCP_WINDOW_DEFAULT,
	    CHAN_TCP_PACKET_DEFAULT, 0, xstrdup("direct-tcpip"), 1);
d727 1
a727 1
server_input_channel_open(int type, int plen, void *ctxt)
d742 1
a742 1
	debug("server_input_channel_open: ctype %s rchan %d win %d max %d",
d756 1
a756 2
		    -1, -1, -1, 0, CHAN_SES_PACKET_DEFAULT,
		    0, xstrdup("server-session"), 1);
@


1.22.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.50 2001/02/19 09:53:32 markus Exp $");
d41 1
a43 1
#include "log.h"
d47 1
a48 1
#include "ssh1.h"
a49 1
#include "auth.h"
a52 2
#include "serverloop.h"
#include "misc.h"
a69 1
static int fdin_is_tty = 0;	/* fdin points to a tty. */
d72 2
a73 1
static u_int buffer_high;/* "Soft" max buffer size. */
d120 1
a120 1
make_packets_from_stderr_data(void)
d149 1
a149 1
make_packets_from_stdout_data(void)
d163 1
a163 1
				len = packet_get_maxsize();
d180 2
a181 2
wait_until_can_do_something(fd_set **readsetp, fd_set **writesetp, int *maxfdp,
    u_int max_time_milliseconds)
d189 3
a191 2
	/* Allocate and update select() masks for channel descriptors. */
	channel_prepare_select(readsetp, writesetp, maxfdp);
d196 1
a196 1
			FD_SET(connection_in, *readsetp);
d204 1
a204 1
			FD_SET(connection_in, *readsetp);
d211 1
a211 1
				FD_SET(fdout, *readsetp);
d213 1
a213 1
				FD_SET(fderr, *readsetp);
d220 1
a220 1
			FD_SET(fdin, *writesetp);
d222 2
d230 5
a234 1
		FD_SET(connection_out, *writesetp);
d252 1
a252 1
		debug2("tvp!=NULL kid %d mili %d", child_terminated, max_time_milliseconds);
d255 1
a255 1
	ret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);
a324 1
	struct termios tio;
d344 1
a344 13
			/* Successful write. */
			if (fdin_is_tty && tcgetattr(fdin, &tio) == 0 &&
			    !(tio.c_lflag & ECHO) && (tio.c_lflag & ICANON)) {
				/*
				 * Simulate echo to reduce the impact of
				 * traffic analysis
				 */
				packet_start(SSH_MSG_IGNORE);
				memset(buffer_ptr(&stdin_buffer), 0, len);
				packet_put_string(buffer_ptr(&stdin_buffer), len);
				packet_send();
			}
			/* Consume the data from the buffer. */
d360 1
a360 1
drain_output(void)
d385 1
a385 1
process_buffered_input_packets(void)
d400 1
a400 2
	fd_set *readset = NULL, *writeset = NULL;
	int max_fd;
d404 3
a406 3
	u_int max_time_milliseconds;
	u_int previous_stdout_buffer_bytes;
	u_int stdout_buffer_bytes;
a427 3
	if (!(datafellows & SSH_BUG_IGNOREMSG) && isatty(fdin))
		fdin_is_tty = 1;

d440 9
a448 5
	max_fd = MAX(fdin, fdout);
	if (fderr != -1)
		max_fd = MAX(max_fd, fderr);
	max_fd = MAX(max_fd, connection_in);
	max_fd = MAX(max_fd, connection_out);
d535 2
a536 2
		wait_until_can_do_something(&readset, &writeset, &max_fd,
		    max_time_milliseconds);
d539 1
a539 1
		channel_after_select(readset, writeset);
d542 1
a542 1
		process_input(readset);
d545 1
a545 1
		process_output(writeset);
a546 4
	if (readset)
		xfree(readset);
	if (writeset)
		xfree(writeset);
d579 1
a579 1
	if (wait_pid == -1) {
d637 1
a637 2
	fd_set *readset = NULL, *writeset = NULL;
	int max_fd;
d648 3
a650 3

	max_fd = MAX(connection_in, connection_out);

d663 1
a663 1
		wait_until_can_do_something(&readset, &writeset, &max_fd, 0);
d669 4
a672 9
		channel_after_select(readset, writeset);
		process_input(readset);
		process_output(writeset);
	}
	if (readset)
		xfree(readset);
	if (writeset)
		xfree(writeset);

d683 1
a683 1
	u_int data_len;
d723 2
a724 2
Channel *
server_request_direct_tcpip(char *ctype)
d726 1
a726 1
	int sock, newch;
d736 1
a736 1
	debug("server_request_direct_tcpip: originator %s port %d, target %s port %d",
d743 1
a743 1
		return NULL;
d749 2
a750 2
		return NULL;
	newch = channel_new(ctype, SSH_CHANNEL_CONNECTING,
a752 29
	return (newch >= 0) ? channel_lookup(newch) : NULL;
}

Channel *
server_request_session(char *ctype)
{
	int newch;

	debug("input_session_request");
	packet_done();
	/*
	 * A server session has no fd to read or write until a
	 * CHANNEL_REQUEST for a shell is made, so we set the type to
	 * SSH_CHANNEL_LARVAL.  Additionally, a callback for handling all
	 * CHANNEL_REQUEST messages is registered.
	 */
	newch = channel_new(ctype, SSH_CHANNEL_LARVAL,
	    -1, -1, -1, 0, CHAN_SES_PACKET_DEFAULT,
	    0, xstrdup("server-session"), 1);
	if (session_open(newch) == 1) {
		channel_register_callback(newch, SSH2_MSG_CHANNEL_REQUEST,
		    session_input_channel_req, (void *)0);
		channel_register_cleanup(newch, session_close_by_channel);
		return channel_lookup(newch);
	} else {
		debug("session open failed, free channel %d", newch);
		channel_free(newch);
	}
	return NULL;
d760 2
a761 1
	u_int len;
d775 21
a795 1
		c = server_request_session(ctype);
d797 3
a799 1
		c = server_request_direct_tcpip(ctype);
d802 1
a802 1
		debug("server_input_channel_open: confirm %s", ctype);
d814 1
a814 1
		debug("server_input_channel_open: failure %s", ctype);
d826 1
a826 50
server_input_global_request(int type, int plen, void *ctxt)
{
	char *rtype;
	int want_reply;
	int success = 0;

	rtype = packet_get_string(NULL);
	want_reply = packet_get_char();
	debug("server_input_global_request: rtype %s want_reply %d", rtype, want_reply);

	if (strcmp(rtype, "tcpip-forward") == 0) {
		struct passwd *pw;
		char *listen_address;
		u_short listen_port;

		pw = auth_get_user();
		if (pw == NULL)
			fatal("server_input_global_request: no user");
		listen_address = packet_get_string(NULL); /* XXX currently ignored */
		listen_port = (u_short)packet_get_int();
		debug("server_input_global_request: tcpip-forward listen %s port %d",
		    listen_address, listen_port);

		/* check permissions */
		if (!options.allow_tcp_forwarding ||
		    no_port_forwarding_flag ||
		    (listen_port < IPPORT_RESERVED && pw->pw_uid != 0)) {
			success = 0;
			packet_send_debug("Server has disabled port forwarding.");
		} else {
			/* Start listening on the port */
			success = channel_request_forwarding(
			    listen_address, listen_port,
			    /*unspec host_to_connect*/ "<unspec host>",
			    /*unspec port_to_connect*/ 0,
			    options.gateway_ports, /*remote*/ 1);
		}
		xfree(listen_address);
	}
	if (want_reply) {
		packet_start(success ?
		    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);
		packet_send();
		packet_write_wait();
	}
	xfree(rtype);
}

void
server_init_dispatch_20(void)
a838 1
	dispatch_set(SSH2_MSG_GLOBAL_REQUEST, &server_input_global_request);
d841 1
a841 1
server_init_dispatch_13(void)
d856 1
a856 1
server_init_dispatch_15(void)
d864 1
a864 1
server_init_dispatch(void)
@


1.22.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d14 1
a14 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d38 1
a38 1
RCSID("$OpenBSD: serverloop.c,v 1.55 2001/03/16 19:06:29 markus Exp $");
d45 1
a45 1
#include "sshpty.h"
d248 1
a248 1
		debug3("tvp!=NULL kid %d mili %d", child_terminated, max_time_milliseconds);
d348 3
a350 1
				packet_send_ignore(len);
d759 5
a860 1
	/* -R style forwarding */
@


1.21
log
@cleanup logging for sshd/2, respect PasswordAuth no
@
text
@d168 1
a168 1
		// wrong: bad conditionXXX
@


1.20
log
@pid_t
@
text
@d723 1
a723 1
	log("channel_input_open: ctype %s rchan %d win %d max %d",
@


1.19
log
@whitespace cleanup
@
text
@d51 1
a51 1
static int child_pid;			/* Pid of the child. */
d61 2
a62 1
	int wait_pid;
d368 1
a368 1
server_loop(int pid, int fdin_arg, int fdout_arg, int fderr_arg)
d370 2
a371 1
	int wait_status, wait_pid;	/* Status and pid returned by wait(). */
@


1.18
log
@check payload for (illegal) extra data
@
text
@d57 1
a57 1
void 
d75 1
a75 1
void 
d89 1
a89 1
void 
d118 1
a118 1
void 
d149 1
a149 1
void 
d240 1
a240 1
void 
d293 1
a293 1
void 
d328 1
a328 1
void 
d353 1
a353 1
void 
d366 1
a366 1
void 
d594 1
a594 1
void 
d705 1
a705 1
void 
d775 1
a775 1
void 
d790 1
a790 1
void 
d805 1
a805 1
void 
d813 1
a813 1
void 
@


1.17
log
@ssh2 server side, see README.openssh2; enable with 'sshd -2'
@
text
@d687 2
a688 2
	char *host, *originator;
	int host_port, originator_port;
d690 2
a691 2
	host = packet_get_string(NULL);
	host_port = packet_get_int();
d694 1
d696 2
a697 2
	sock = channel_connect_to(host, host_port);
	xfree(host);
d726 1
@


1.16
log
@replace big switch() with function tables (prepare for ssh2)
@
text
@d8 4
d23 2
d75 9
d166 9
a174 3
	if (buffer_len(&stdin_buffer) < 4096 &&
	    channel_not_very_much_buffered_data())
		FD_SET(connection_in, readset);
d180 1
a180 1
	if (packet_not_very_much_data_to_write()) {
d200 1
a200 1
	if (fdin != -1 && buffer_len(&stdin_buffer) > 0)
d222 2
d267 3
d299 1
a299 1
	if (fdin != -1 && FD_ISSET(fdin, writeset)) {
d594 45
d683 105
d814 3
a816 1
	if (compat13)
@


1.15
log
@close(fdin) if fdin != fdout, shutdown otherwise, ok theo@@
@
text
@d16 4
d49 2
a70 98
 * Process any buffered packets that have been received from the client.
 */
void 
process_buffered_input_packets()
{
	int type;
	char *data;
	unsigned int data_len;
	int row, col, xpixel, ypixel;
	int payload_len;

	/* Process buffered packets from the client. */
	while ((type = packet_read_poll(&payload_len)) != SSH_MSG_NONE) {
		switch (type) {
		case SSH_CMSG_STDIN_DATA:
			/* Stdin data from the client.  Append it to the buffer. */
			/* Ignore any data if the client has closed stdin. */
			if (fdin == -1)
				break;
			data = packet_get_string(&data_len);
			packet_integrity_check(payload_len, (4 + data_len), type);
			buffer_append(&stdin_buffer, data, data_len);
			memset(data, 0, data_len);
			xfree(data);
			break;

		case SSH_CMSG_EOF:
			/*
			 * Eof from the client.  The stdin descriptor to the
			 * program will be closed when all buffered data has
			 * drained.
			 */
			debug("EOF received for stdin.");
			packet_integrity_check(payload_len, 0, type);
			stdin_eof = 1;
			break;

		case SSH_CMSG_WINDOW_SIZE:
			debug("Window change received.");
			packet_integrity_check(payload_len, 4 * 4, type);
			row = packet_get_int();
			col = packet_get_int();
			xpixel = packet_get_int();
			ypixel = packet_get_int();
			if (fdin != -1)
				pty_change_window_size(fdin, row, col, xpixel, ypixel);
			break;

		case SSH_MSG_PORT_OPEN:
			debug("Received port open request.");
			channel_input_port_open(payload_len);
			break;

		case SSH_MSG_CHANNEL_OPEN_CONFIRMATION:
			debug("Received channel open confirmation.");
			packet_integrity_check(payload_len, 4 + 4, type);
			channel_input_open_confirmation();
			break;

		case SSH_MSG_CHANNEL_OPEN_FAILURE:
			debug("Received channel open failure.");
			packet_integrity_check(payload_len, 4, type);
			channel_input_open_failure();
			break;

		case SSH_MSG_CHANNEL_DATA:
			channel_input_data(payload_len);
			break;

		case SSH_MSG_CHANNEL_CLOSE:
			debug("Received channel close.");
			packet_integrity_check(payload_len, 4, type);
			channel_input_close();
			break;

		case SSH_MSG_CHANNEL_CLOSE_CONFIRMATION:
			debug("Received channel close confirmation.");
			packet_integrity_check(payload_len, 4, type);
			channel_input_close_confirmation();
			break;

		default:
			/*
			 * In this phase, any unexpected messages cause a
			 * protocol error.  This is to ease debugging; also,
			 * since no confirmations are sent messages,
			 * unprocessed unknown messages could cause strange
			 * problems.  Any compatible protocol extensions must
			 * be negotiated before entering the interactive
			 * session.
			 */
			packet_disconnect("Protocol error during session: type %d",
					  type);
		}
	}
}

/*
d327 6
d397 2
d455 1
a455 1
				goto quit;
a481 1
quit:
d566 76
@


1.14
log
@move atomicio into it's own file.  wrap all socket write()s which were doing
write(sock, buf, len) != len, with atomicio() calls.
@
text
@d372 1
a372 1
			if (fdout == -1)
d498 1
a498 1
			if (fdout == -1)
@


1.13
log
@indent
@
text
@d173 1
a173 1
	       packet_not_very_much_data_to_write()) {
d202 1
a202 1
	       packet_not_very_much_data_to_write()) {
d367 1
a367 1
			    buffer_len(&stdin_buffer));
@


1.12
log
@KNF, final part 3
@
text
@d612 1
a612 1
			    wait_pid, pid);
@


1.11
log
@much more KNF
@
text
@d36 4
a39 2
/* This SIGCHLD kludge is used to detect when the child exits.  The server
   will exit after that, as soon as forwarded connections have terminated. */
d92 5
a96 3
			/* Eof from the client.  The stdin descriptor to
			   the program will be closed when all buffered
			   data has drained. */
d147 9
a155 7
			/* In this phase, any unexpected messages cause a
			   protocol error.  This is to ease debugging;
			   also, since no confirmations are sent messages,
			   unprocessed unknown messages could cause
			   strange problems.  Any compatible protocol
			   extensions must be negotiated before entering
			   the interactive session. */
d239 4
a242 2
	/* Read packets from the client unless we have too much buffered
	   stdin or channel data. */
d247 4
a250 2
	/* If there is not too much data already buffered going to the
	   client, try to get some more data from the program. */
d262 4
a265 2
	/* If we have buffered packet data going to the client, mark that
	   descriptor. */
d278 4
a281 2
	/* If child has terminated and there is enough buffer space to
	   read from it, then read as much as is available and exit. */
d322 4
a325 3
		/* There is a kernel bug on Solaris that causes select to
		   sometimes wake up even though there is no data
		   available. */
d474 6
a479 5
	/* If we have no separate fderr (which is the case when we have a
	   pty - there we cannot make difference between data sent to
	   stdout and stderr), indicate that we have seen an EOF from
	   stderr.  This way we don\'t need to check the descriptor
	   everywhere. */
d490 4
a493 2
		/* If we have received eof, and there is no more pending
		   input data, cause a real eof by closing fdin. */
d505 1
a505 2
		/* Make packets from buffered stderr data to send to the
		   client. */
d508 7
a514 6
		/* Make packets from buffered stdout data to send to the
		   client. If there is very little to send, this arranges
		   to not send them now, but to wait a short while to see
		   if we are getting more data. This is necessary, as some
		   systems wake up readers from a pty after each separate
		   character. */
d531 5
a535 3
		/* Bail out of the loop if the program has closed its
		   output descriptors, and we have no more data to send to
		   the client, and there is no pending buffered data. */
d627 7
a633 5
		/* Wait for exit confirmation.  Note that there might be
		   other packets coming before it; however, the program
		   has already died so we just ignore them.  The client is
		   supposed to respond with the confirmation when it
		   receives the exit status. */
@


1.10
log
@KNF part 1
@
text
@d2 6
a7 13

serverloop.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Sun Sep 10 00:30:37 1995 ylo

Server main loop for handling the interactive session.

*/
d62 3
a64 2
/* Process any buffered packets that have been received from the client. */

d156 4
a159 3
/* Make packets from buffered stderr data, and buffer it for sending
   to the client. */

d185 4
a188 3
/* Make packets from buffered stdout data, and buffer it for sending to the
   client. */

d214 6
a219 5
/* Sleep in select() until we can do something.  This will initialize the
   select masks.  Upon return, the masks will indicate which descriptors
   have data or can accept data.  Optionally, a maximum time can be specified
   for the duration of the wait (0 = infinite). */

d291 4
a294 3
/* Processes input from the client and the program.  Input data is stored
   in buffers and processed later. */

d341 3
a343 2
/* Sends data from internal buffers to client program stdin. */

d375 4
a378 3
/* Wait until all buffered output has been sent to the client.
   This is used when the program terminates. */

d404 7
a410 6
/* Performs the interactive session.  This handles data transmission between
   the client and the program.  Note that the notion of stdin, stdout, and
   stderr in this function is sort of reversed: this function writes to
   stdin (of the child program), and reads from stdout and stderr (of the
   child program). */

d579 5
a583 3
		/* It is possible that the wait was handled by SIGCHLD
		   handler.  This may result in either: this call
		   returning with EINTR, or: this call returning ECHILD. */
d591 2
a592 1
			error("Strange, wait returned pid %d, expected %d", wait_pid, pid);
@


1.9
log
@syslog changes:
* Unified Logmessage for all auth-types, for success and for failed
* Standard connections get only ONE line in the LOG when level==LOG:
  Auth-attempts are logged only, if authentication is:
        a) successfull or
        b) with passwd or
        c) we had more than AUTH_FAIL_LOG failues
* many log() became verbose()
* old behaviour with level=VERBOSE
@
text
@d46 1
a46 1
static int child_pid;  			/* Pid of the child. */
d50 2
a51 1
void sigchld_handler(int sig)
d53 14
a66 15
  int save_errno = errno;
  int wait_pid;
  debug("Received SIGCHLD.");
  wait_pid = wait((int *)&child_wait_status);
  if (wait_pid != -1)
    {
      if (wait_pid != child_pid)
	error("Strange, got SIGCHLD and wait returned pid %d but child is %d",
	      wait_pid, child_pid);
      if (WIFEXITED(child_wait_status) ||
	  WIFSIGNALED(child_wait_status))
	child_terminated = 1;
    }
  signal(SIGCHLD, sigchld_handler);
  errno = save_errno;
d71 2
a72 1
void process_buffered_input_packets()
d74 85
a158 83
  int type;
  char *data;
  unsigned int data_len;
  int row, col, xpixel, ypixel;
  int payload_len;

  /* Process buffered packets from the client. */
  while ((type = packet_read_poll(&payload_len)) != SSH_MSG_NONE)
    {
      switch (type)
	{
	case SSH_CMSG_STDIN_DATA:
	  /* Stdin data from the client.  Append it to the buffer. */
	  if (fdin == -1)
	    break; /* Ignore any data if the client has closed stdin. */
	  data = packet_get_string(&data_len);
	  packet_integrity_check(payload_len, (4 + data_len), type);
	  buffer_append(&stdin_buffer, data, data_len);
	  memset(data, 0, data_len);
	  xfree(data);
	  break;
	  
	case SSH_CMSG_EOF:
	  /* Eof from the client.  The stdin descriptor to the program
	     will be closed when all buffered data has drained. */
	  debug("EOF received for stdin.");
	  packet_integrity_check(payload_len, 0, type);
	  stdin_eof = 1;
	  break;

	case SSH_CMSG_WINDOW_SIZE:
	  debug("Window change received.");
	  packet_integrity_check(payload_len, 4*4, type);
	  row = packet_get_int();
	  col = packet_get_int();
	  xpixel = packet_get_int();
	  ypixel = packet_get_int();
	  if (fdin != -1)
	    pty_change_window_size(fdin, row, col, xpixel, ypixel);
	  break;
	  
	case SSH_MSG_PORT_OPEN:
	  debug("Received port open request.");
	  channel_input_port_open(payload_len);
	  break;
	  
	case SSH_MSG_CHANNEL_OPEN_CONFIRMATION:
	  debug("Received channel open confirmation.");
	  packet_integrity_check(payload_len, 4 + 4, type);
	  channel_input_open_confirmation();
	  break;

	case SSH_MSG_CHANNEL_OPEN_FAILURE:
	  debug("Received channel open failure.");
	  packet_integrity_check(payload_len, 4, type);
	  channel_input_open_failure();
	  break;
	  
	case SSH_MSG_CHANNEL_DATA:
	  channel_input_data(payload_len);
	  break;
	  
	case SSH_MSG_CHANNEL_CLOSE:
	  debug("Received channel close.");
	  packet_integrity_check(payload_len, 4, type);
	  channel_input_close();
	  break;

	case SSH_MSG_CHANNEL_CLOSE_CONFIRMATION:
	  debug("Received channel close confirmation.");
	  packet_integrity_check(payload_len, 4, type);
	  channel_input_close_confirmation();
	  break;

	default:
	  /* In this phase, any unexpected messages cause a protocol
	     error.  This is to ease debugging; also, since no 
	     confirmations are sent messages, unprocessed unknown 
	     messages could cause strange problems.  Any compatible 
	     protocol extensions must be negotiated before entering the 
	     interactive session. */
	  packet_disconnect("Protocol error during session: type %d", 
			    type);
a159 1
    }
d165 2
a166 1
void make_packets_from_stderr_data()
d168 1
a168 1
  int len;
d170 18
a187 21
  /* Send buffered stderr data to the client. */
  while (buffer_len(&stderr_buffer) > 0 && 
	 packet_not_very_much_data_to_write())
    {
      len = buffer_len(&stderr_buffer);
      if (packet_is_interactive())
	{
	  if (len > 512)
	    len = 512;
	}
      else
	{
	  if (len > packet_get_maxsize())
	    len = packet_get_maxsize();  /* Keep the packets at reasonable size. */
	}
      packet_start(SSH_SMSG_STDERR_DATA);
      packet_put_string(buffer_ptr(&stderr_buffer), len);
      packet_send();
      buffer_consume(&stderr_buffer, len);
      stderr_bytes += len;
    }
d193 2
a194 1
void make_packets_from_stdout_data()
d196 1
a196 1
  int len;
d198 18
a215 21
  /* Send buffered stdout data to the client. */
  while (buffer_len(&stdout_buffer) > 0 && 
	 packet_not_very_much_data_to_write())
    {
      len = buffer_len(&stdout_buffer);
      if (packet_is_interactive())
	{
	  if (len > 512)
	    len = 512;
	}
      else
	{
	  if (len > packet_get_maxsize())
	    len = packet_get_maxsize();  /* Keep the packets at reasonable size. */
	}
      packet_start(SSH_SMSG_STDOUT_DATA);
      packet_put_string(buffer_ptr(&stdout_buffer), len);
      packet_send();
      buffer_consume(&stdout_buffer, len);
      stdout_bytes += len;
    }
d223 3
a225 2
void wait_until_can_do_something(fd_set *readset, fd_set *writeset,
				 unsigned int max_time_milliseconds)
d227 2
a228 2
  struct timeval tv, *tvp;
  int ret;
d230 1
a230 1
  /* When select fails we restart from here. */
d233 59
a291 63
  /* Initialize select() masks. */
  FD_ZERO(readset);
  
  /* Read packets from the client unless we have too much buffered stdin
     or channel data. */
  if (buffer_len(&stdin_buffer) < 4096 &&
      channel_not_very_much_buffered_data())
    FD_SET(connection_in, readset);
  
  /* If there is not too much data already buffered going to the client,
     try to get some more data from the program. */
  if (packet_not_very_much_data_to_write())
    {
      if (!fdout_eof)
	FD_SET(fdout, readset);
      if (!fderr_eof)
	FD_SET(fderr, readset);
    }
  
  FD_ZERO(writeset);
  
  /* Set masks for channel descriptors. */
  channel_prepare_select(readset, writeset);
  
  /* If we have buffered packet data going to the client, mark that
     descriptor. */
  if (packet_have_data_to_write())
    FD_SET(connection_out, writeset);
  
  /* If we have buffered data, try to write some of that data to the
     program. */
  if (fdin != -1 && buffer_len(&stdin_buffer) > 0)
    FD_SET(fdin, writeset);
  
  /* Update the maximum descriptor number if appropriate. */
  if (channel_max_fd() > max_fd)
    max_fd = channel_max_fd();
  
  /* If child has terminated and there is enough buffer space to read from
     it, then read as much as is available and exit. */
  if (child_terminated && packet_not_very_much_data_to_write())
    if (max_time_milliseconds == 0)
      max_time_milliseconds = 100;
  
  if (max_time_milliseconds == 0)
    tvp = NULL;
  else
    {
      tv.tv_sec = max_time_milliseconds / 1000;
      tv.tv_usec = 1000 * (max_time_milliseconds % 1000);
      tvp = &tv;
    }

  /* Wait for something to happen, or the timeout to expire. */
  ret = select(max_fd + 1, readset, writeset, NULL, tvp);
  
  if (ret < 0)
    {
      if (errno != EINTR)
	error("select: %.100s", strerror(errno));
      else
	goto retry_select;
    }
d297 2
a298 1
void process_input(fd_set *readset)
d300 2
a301 2
  int len;
  char buf[16384];
d303 38
a340 45
  /* Read and buffer any input data from the client. */
  if (FD_ISSET(connection_in, readset))
    {
      len = read(connection_in, buf, sizeof(buf));
      if (len == 0) {
	verbose("Connection closed by remote host.");
	fatal_cleanup();
      }

      /* There is a kernel bug on Solaris that causes select to sometimes
	 wake up even though there is no data available. */
      if (len < 0 && errno == EAGAIN)
	len = 0;

      if (len < 0) {
	verbose("Read error from remote host: %.100s", strerror(errno));
	fatal_cleanup();
      }

      /* Buffer any received data. */
      packet_process_incoming(buf, len);
    }
  
  /* Read and buffer any available stdout data from the program. */
  if (!fdout_eof && FD_ISSET(fdout, readset))
    {
      len = read(fdout, buf, sizeof(buf));
      if (len <= 0)
	fdout_eof = 1;
      else
	{
	  buffer_append(&stdout_buffer, buf, len);
	  fdout_bytes += len;
	}
    }
  
  /* Read and buffer any available stderr data from the program. */
  if (!fderr_eof && FD_ISSET(fderr, readset))
    {
      len = read(fderr, buf, sizeof(buf));
      if (len <= 0)
	fderr_eof = 1;
      else
	buffer_append(&stderr_buffer, buf, len);
    }
d345 2
a346 1
void process_output(fd_set *writeset)
d348 1
a348 1
  int len;
d350 5
a354 7
  /* Write buffered data to program stdin. */
  if (fdin != -1 && FD_ISSET(fdin, writeset))
    {
      len = write(fdin, buffer_ptr(&stdin_buffer),
		  buffer_len(&stdin_buffer));
      if (len <= 0)
	{
d356 1
a356 1
	  close(fdin); 
d358 4
a361 4
          if (fdout == -1)
            close(fdin);
	  else
	    shutdown(fdin, SHUT_WR); /* We will no longer send. */
d363 11
a373 14
	  fdin = -1;
	}
      else
	{
	  /* Successful write.  Consume the data from the buffer. */
	  buffer_consume(&stdin_buffer, len);
	  /* Update the count of bytes written to the program. */
	  stdin_bytes += len;
	}
    }
  
  /* Send any buffered packet data to the client. */
  if (FD_ISSET(connection_out, writeset))
    packet_write_poll();
d379 2
a380 1
void drain_output()
d382 20
a401 24
  /* Send any buffered stdout data to the client. */
  if (buffer_len(&stdout_buffer) > 0)
    {
      packet_start(SSH_SMSG_STDOUT_DATA);
      packet_put_string(buffer_ptr(&stdout_buffer), 
			buffer_len(&stdout_buffer));
      packet_send();
      /* Update the count of sent bytes. */
      stdout_bytes += buffer_len(&stdout_buffer);
    }
  
  /* Send any buffered stderr data to the client. */
  if (buffer_len(&stderr_buffer) > 0)
    {
      packet_start(SSH_SMSG_STDERR_DATA);
      packet_put_string(buffer_ptr(&stderr_buffer), 
			buffer_len(&stderr_buffer));
      packet_send();
      /* Update the count of sent bytes. */
      stderr_bytes += buffer_len(&stderr_buffer);
    }
  
  /* Wait until all buffered data has been written to the client. */
  packet_write_wait();
d410 2
a411 1
void server_loop(int pid, int fdin_arg, int fdout_arg, int fderr_arg)
d413 63
a475 64
  int wait_status, wait_pid;	/* Status and pid returned by wait(). */
  int waiting_termination = 0;  /* Have displayed waiting close message. */
  unsigned int max_time_milliseconds;
  unsigned int previous_stdout_buffer_bytes;
  unsigned int stdout_buffer_bytes;
  int type;

  debug("Entering interactive session.");

  /* Initialize the SIGCHLD kludge. */
  child_pid = pid;
  child_terminated = 0;
  signal(SIGCHLD, sigchld_handler);

  /* Initialize our global variables. */
  fdin = fdin_arg;
  fdout = fdout_arg;
  fderr = fderr_arg;
  connection_in = packet_get_connection_in();
  connection_out = packet_get_connection_out();
  
  previous_stdout_buffer_bytes = 0;

  /* Set approximate I/O buffer size. */
  if (packet_is_interactive())
    buffer_high = 4096;
  else
    buffer_high = 64 * 1024;

  /* Initialize max_fd to the maximum of the known file descriptors. */
  max_fd = fdin;
  if (fdout > max_fd)
    max_fd = fdout;
  if (fderr != -1 && fderr > max_fd)
    max_fd = fderr;
  if (connection_in > max_fd)
    max_fd = connection_in;
  if (connection_out > max_fd)
    max_fd = connection_out;

  /* Initialize Initialize buffers. */
  buffer_init(&stdin_buffer);
  buffer_init(&stdout_buffer);
  buffer_init(&stderr_buffer);

  /* If we have no separate fderr (which is the case when we have a pty - there
     we cannot make difference between data sent to stdout and stderr),
     indicate that we have seen an EOF from stderr.  This way we don\'t
     need to check the descriptor everywhere. */
  if (fderr == -1)
    fderr_eof = 1;

  /* Main loop of the server for the interactive session mode. */
  for (;;)
    {
      fd_set readset, writeset;

      /* Process buffered packets from the client. */
      process_buffered_input_packets();

      /* If we have received eof, and there is no more pending input data,
	 cause a real eof by closing fdin. */
      if (stdin_eof && fdin != -1 && buffer_len(&stdin_buffer) == 0)
	{
d477 1
a477 1
	  close(fdin);
d479 4
a482 4
          if (fdout == -1)
            close(fdin);
	  else
	    shutdown(fdin, SHUT_WR); /* We will no longer send. */
d484 141
a624 146
	  fdin = -1;
	}

      /* Make packets from buffered stderr data to send to the client. */
      make_packets_from_stderr_data();

      /* Make packets from buffered stdout data to send to the client.
	 If there is very little to send, this arranges to not send them
	 now, but to wait a short while to see if we are getting more data.
	 This is necessary, as some systems wake up readers from a pty after
	 each separate character. */
      max_time_milliseconds = 0;
      stdout_buffer_bytes = buffer_len(&stdout_buffer);
      if (stdout_buffer_bytes != 0 && stdout_buffer_bytes < 256 &&
	  stdout_buffer_bytes != previous_stdout_buffer_bytes)
	max_time_milliseconds = 10; /* try again after a while */
      else
	make_packets_from_stdout_data(); /* Send it now. */
      previous_stdout_buffer_bytes = buffer_len(&stdout_buffer);

      /* Send channel data to the client. */
      if (packet_not_very_much_data_to_write())
	channel_output_poll();

      /* Bail out of the loop if the program has closed its output descriptors,
	 and we have no more data to send to the client, and there is no
	 pending buffered data. */
      if (fdout_eof && fderr_eof && !packet_have_data_to_write() &&
	  buffer_len(&stdout_buffer) == 0 && buffer_len(&stderr_buffer) == 0)
	{
	  if (!channel_still_open())
	    goto quit;
	  if (!waiting_termination)
	    {
	      const char *s = 
		"Waiting for forwarded connections to terminate...\r\n";
	      char *cp;
	      waiting_termination = 1;
	      buffer_append(&stderr_buffer, s, strlen(s));

	      /* Display list of open channels. */
	      cp = channel_open_message();
	      buffer_append(&stderr_buffer, cp, strlen(cp));
	      xfree(cp);
	    }
	}

      /* Sleep in select() until we can do something. */
      wait_until_can_do_something(&readset, &writeset,
				  max_time_milliseconds);

      /* Process any channel events. */
      channel_after_select(&readset, &writeset);

      /* Process input from the client and from program stdout/stderr. */
      process_input(&readset);

      /* Process output to the client and to program stdin. */
      process_output(&writeset);
    }

 quit:
  /* Cleanup and termination code. */

  /* Wait until all output has been sent to the client. */
  drain_output();

  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
	stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);

  /* Free and clear the buffers. */
  buffer_free(&stdin_buffer);
  buffer_free(&stdout_buffer);
  buffer_free(&stderr_buffer);

  /* Close the file descriptors. */
  if (fdout != -1)
    close(fdout);
  fdout = -1;
  fdout_eof = 1;
  if (fderr != -1)
    close(fderr);
  fderr = -1;
  fderr_eof = 1;
  if (fdin != -1)
    close(fdin);
  fdin = -1;

  /* Stop listening for channels; this removes unix domain sockets. */
  channel_stop_listening();
  
  /* Wait for the child to exit.  Get its exit status. */
  wait_pid = wait(&wait_status);
  if (wait_pid < 0)
    {
      /* It is possible that the wait was handled by SIGCHLD handler.  This
	 may result in either: this call returning with EINTR, or: this
	 call returning ECHILD. */
      if (child_terminated)
	wait_status = child_wait_status;
      else
	packet_disconnect("wait: %.100s", strerror(errno));
    }
  else
    {
      /* Check if it matches the process we forked. */
      if (wait_pid != pid)
	error("Strange, wait returned pid %d, expected %d", wait_pid, pid);
    }

  /* We no longer want our SIGCHLD handler to be called. */
  signal(SIGCHLD, SIG_DFL);

  /* Check if it exited normally. */
  if (WIFEXITED(wait_status))
    {
      /* Yes, normal exit.  Get exit status and send it to the client. */
      debug("Command exited with status %d.", WEXITSTATUS(wait_status));
      packet_start(SSH_SMSG_EXITSTATUS);
      packet_put_int(WEXITSTATUS(wait_status));
      packet_send();
      packet_write_wait();

      /* Wait for exit confirmation.  Note that there might be other
         packets coming before it; however, the program has already died
	 so we just ignore them.  The client is supposed to respond with
	 the confirmation when it receives the exit status. */
      do
	{
	  int plen;
	  type = packet_read(&plen);
	}
      while (type != SSH_CMSG_EXIT_CONFIRMATION);

      debug("Received exit confirmation.");
      return;
    }

  /* Check if the program terminated due to a signal. */
  if (WIFSIGNALED(wait_status))
    packet_disconnect("Command terminated on signal %d.", 
		      WTERMSIG(wait_status));

  /* Some weird exit cause.  Just exit. */
  packet_disconnect("wait returned status %04x.", wait_status);
  /*NOTREACHED*/
a625 1

@


1.8
log
@SSH_CMSG_MAX_PACKET_SIZE, some clients use this, some need this, niels@@
[hope this time my ISP stays alive during commit]
@
text
@d311 4
a314 2
      if (len == 0)
	fatal("Connection closed by remote host.");
d321 4
a324 2
      if (len < 0)
	fatal("Read error from remote host: %.100s", strerror(errno));
@


1.7
log
@bugfix: check for space if child has terminated, from: iedowse@@maths.tcd.ie
@
text
@d179 2
a180 2
	  if (len > 32768)
	    len = 32768;  /* Keep the packets at reasonable size. */
d209 2
a210 2
	  if (len > 32768)
	    len = 32768;  /* Keep the packets at reasonable size. */
@


1.6
log
@fix shutdown() for sockets, the last one has to close the socket
@
text
@d272 3
a274 2
  /* If child has terminated, read as much as is available and then exit. */
  if (child_terminated)
@


1.5
log
@errno trashing in signal handlers
@
text
@d365 4
a368 1
	  shutdown(fdin, SHUT_WR); /* We will no longer send. */
d492 4
a495 1
	  shutdown(fdin, SHUT_WR); /* We will no longer send. */
a573 1
#ifdef USE_PIPES
a574 3
#else
    shutdown(fdout, SHUT_RD);
#endif
a577 1
#ifdef USE_PIPES
a578 3
#else
    shutdown(fderr, SHUT_RD);
#endif
a581 1
#ifdef USE_PIPES
a582 3
#else
    shutdown(fdin, SHUT_WR);
#endif
@


1.4
log
@use SHUT_* symbols
@
text
@d52 1
d66 1
@


1.3
log
@do not call shutdown() on pipes, ok: deraadt
@
text
@d363 1
a363 1
	  shutdown(fdin, 1); /* We will no longer send. */
d487 1
a487 1
	  shutdown(fdin, 1); /* We will no longer send. */
d569 1
a569 1
    shutdown(fdout, 0);
d577 1
a577 1
    shutdown(fderr, 0);
d585 1
a585 1
    shutdown(fdin, 1);
@


1.2
log
@even smaller
@
text
@d360 3
d364 1
d484 3
d488 1
d566 3
d570 1
d574 3
d578 1
d582 3
d586 1
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d50 1
a50 1
RETSIGTYPE sigchld_handler(int sig)
@

