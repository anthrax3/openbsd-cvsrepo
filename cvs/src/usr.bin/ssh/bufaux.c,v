head	1.60;
access;
symbols
	OPENBSD_6_1:1.60.0.10
	OPENBSD_6_1_BASE:1.60
	OPENBSD_6_0:1.60.0.12
	OPENBSD_6_0_BASE:1.60
	OPENBSD_5_9:1.60.0.8
	OPENBSD_5_9_BASE:1.60
	OPENBSD_5_8:1.60.0.6
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.60.0.2
	OPENBSD_5_7_BASE:1.60
	OPENBSD_5_6:1.60.0.4
	OPENBSD_5_6_BASE:1.60
	OPENBSD_5_5:1.56.0.4
	OPENBSD_5_5_BASE:1.56
	OPENBSD_5_4:1.52.0.2
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.50.0.10
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.50.0.8
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.6
	OPENBSD_5_0:1.50.0.4
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.48.0.2
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.46.0.8
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.46.0.4
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.46.0.2
	OPENBSD_4_4_BASE:1.46
	OPENBSD_4_3:1.44.0.8
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.44.0.6
	OPENBSD_4_2_BASE:1.44
	OPENBSD_4_1:1.44.0.2
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.44.0.4
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.36.0.2
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.35.0.2
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.32.0.4
	OPENBSD_3_6_BASE:1.32
	OPENBSD_3_5:1.32.0.2
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.28.0.2
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	OPENBSD_3_0:1.17.0.4
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.60
date	2014.04.30.05.29.56;	author djm;	state Exp;
branches;
next	1.59;

1.59
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2014.04.28.03.09.18;	author djm;	state Exp;
branches;
next	1.57;

1.57
date	2014.04.16.23.22.45;	author djm;	state Exp;
branches;
next	1.56;

1.56
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches
	1.56.4.1;
next	1.55;

1.55
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2014.01.12.08.13.13;	author djm;	state Exp;
branches;
next	1.53;

1.53
date	2013.11.08.11.15.19;	author dtucker;	state Exp;
branches;
next	1.52;

1.52
date	2013.07.12.00.19.58;	author djm;	state Exp;
branches;
next	1.51;

1.51
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.50;

1.50
date	2010.08.31.09.58.37;	author djm;	state Exp;
branches;
next	1.49;

1.49
date	2010.03.26.03.13.17;	author djm;	state Exp;
branches;
next	1.48;

1.48
date	2010.02.02.22.49.34;	author djm;	state Exp;
branches;
next	1.47;

1.47
date	2010.01.12.01.36.08;	author djm;	state Exp;
branches;
next	1.46;

1.46
date	2008.06.10.23.21.34;	author dtucker;	state Exp;
branches;
next	1.45;

1.45
date	2008.05.08.06.59.01;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.18.10.44.28;	author dtucker;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.30.09.58.15;	author djm;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.25.18.56.54;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.05.05.01.15;	author djm;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2005.03.10.22.01.05;	author deraadt;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2004.12.06.16.00.43;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2004.10.29.23.56.17;	author djm;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.23.15.12.46;	author markus;	state Exp;
branches
	1.32.2.1
	1.32.4.1;
next	1.31;

1.31
date	2003.11.10.16.23.41;	author jakob;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.18.13.02.21;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2002.10.23.10.40.16;	author markus;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2002.06.26.08.53.12;	author markus;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2002.06.23.09.46.51;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.20.09.14.58;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.26.15.23.40;	author markus;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2002.03.18.17.25.29;	author provos;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.18.18.14.17;	author stevesk;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.28.14.13.13;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.19.17.16.13;	author stevesk;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.05.10.06.12;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.21.19.05.45;	author markus;	state Exp;
branches
	1.17.2.1
	1.17.4.1;
next	1.16;

1.16
date	2001.01.16.23.58.08;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.10.22.56.22;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.19.23.17.55;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.07.20.27.50;	author deraadt;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2000.06.20.01.39.39;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.14.10.30.30;	author markus;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.04.12.09.39.10;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.28.20.24.18;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.16.20.56.14;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	99.11.24.19.53.44;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.11.24.00.26.01;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.11.23.22.25.52;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	99.11.12.17.28.35;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	99.11.02.19.42.35;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.04.45.36;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.33;	author deraadt;	state Exp;
branches;
next	;

1.11.2.1
date	2000.09.01.18.23.17;	author jason;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2000.11.08.21.30.28;	author jason;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.03.12.15.44.08;	author jason;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2001.03.21.18.52.36;	author jason;	state Exp;
branches;
next	;

1.13.2.1
date	2001.02.16.20.12.55;	author jason;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.02.19.17.18.41;	author jason;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2001.03.21.19.46.23;	author jason;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2001.05.07.21.09.27;	author jason;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.13.2.6;

1.13.2.6
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.17.2.1
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.04.22.19.56.41;	author miod;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2002.06.02.22.56.09;	author miod;	state Exp;
branches;
next	;

1.17.4.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2002.04.23.02.13.50;	author jason;	state Exp;
branches;
next	1.17.4.3;

1.17.4.3
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.17.4.4;

1.17.4.4
date	2002.06.26.18.22.34;	author miod;	state Exp;
branches;
next	;

1.24.2.1
date	2002.05.18.04.12.10;	author jason;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2002.05.18.04.50.37;	author jason;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	1.24.2.4;

1.24.2.4
date	2003.04.03.22.35.16;	author miod;	state Exp;
branches;
next	;

1.27.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2003.09.16.21.20.24;	author brad;	state Exp;
branches;
next	;

1.28.2.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.29.2.1
date	2004.02.28.03.51.32;	author brad;	state Exp;
branches;
next	;

1.32.2.1
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.32.4.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.32.4.2;

1.32.4.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	1.32.4.3;

1.32.4.3
date	2005.09.02.03.44.59;	author brad;	state Exp;
branches;
next	;

1.35.2.1
date	2005.09.04.18.40.01;	author brad;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.36.2.1
date	2006.02.03.03.01.55;	author brad;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.37.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;

1.56.4.1
date	2014.04.21.00.30.48;	author djm;	state Exp;
branches;
next	;


desc
@@


1.60
log
@New buffer API; the first installment of the conversion/replacement
of OpenSSH's internals to make them usable as a standalone library.

This includes a set of wrappers to make it compatible with the
existing buffer API so replacement can occur incrementally.

With and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review.
@
text
@/* $OpenBSD: bufaux.c,v 1.59 2014/04/29 18:01:49 markus Exp $ */
/*
 * Copyright (c) 2012 Damien Miller <djm@@mindrot.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Emulation wrappers for legacy OpenSSH buffer API atop sshbuf */

#include <sys/types.h>

#include "buffer.h"
#include "log.h"
#include "ssherr.h"

int
buffer_get_short_ret(u_short *v, Buffer *buffer)
{
	int ret;

	if ((ret = sshbuf_get_u16(buffer, v)) != 0) {
		error("%s: %s", __func__, ssh_err(ret));
		return -1;
	}
	return 0;
}

u_short
buffer_get_short(Buffer *buffer)
{
	u_short ret;

	if (buffer_get_short_ret(&ret, buffer) == -1)
		fatal("%s: buffer error", __func__);

	return (ret);
}

int
buffer_get_int_ret(u_int *v, Buffer *buffer)
{
	int ret;

	if ((ret = sshbuf_get_u32(buffer, v)) != 0) {
		error("%s: %s", __func__, ssh_err(ret));
		return -1;
	}
	return 0;
}

u_int
buffer_get_int(Buffer *buffer)
{
	u_int ret;

	if (buffer_get_int_ret(&ret, buffer) == -1)
		fatal("%s: buffer error", __func__);

	return (ret);
}

int
buffer_get_int64_ret(u_int64_t *v, Buffer *buffer)
{
	int ret;

	if ((ret = sshbuf_get_u64(buffer, v)) != 0) {
		error("%s: %s", __func__, ssh_err(ret));
		return -1;
	}
	return 0;
}

u_int64_t
buffer_get_int64(Buffer *buffer)
{
	u_int64_t ret;

	if (buffer_get_int64_ret(&ret, buffer) == -1)
		fatal("%s: buffer error", __func__);

	return (ret);
}

void
buffer_put_short(Buffer *buffer, u_short value)
{
	int ret;

	if ((ret = sshbuf_put_u16(buffer, value)) != 0)
		fatal("%s: %s", __func__, ssh_err(ret));
}

void
buffer_put_int(Buffer *buffer, u_int value)
{
	int ret;

	if ((ret = sshbuf_put_u32(buffer, value)) != 0)
		fatal("%s: %s", __func__, ssh_err(ret));
}

void
buffer_put_int64(Buffer *buffer, u_int64_t value)
{
	int ret;

	if ((ret = sshbuf_put_u64(buffer, value)) != 0)
		fatal("%s: %s", __func__, ssh_err(ret));
}

void *
buffer_get_string_ret(Buffer *buffer, u_int *length_ptr)
{
	size_t len;
	int ret;
	u_char *value;

	if ((ret = sshbuf_get_string(buffer, &value, &len)) != 0) {
		error("%s: %s", __func__, ssh_err(ret));
		return NULL;
	}
	if (length_ptr != NULL)
		*length_ptr = len;  /* Safe: sshbuf never stores len > 2^31 */
	return value;
}

void *
buffer_get_string(Buffer *buffer, u_int *length_ptr)
{
	void *ret;

	if ((ret = buffer_get_string_ret(buffer, length_ptr)) == NULL)
		fatal("%s: buffer error", __func__);
	return (ret);
}

char *
buffer_get_cstring_ret(Buffer *buffer, u_int *length_ptr)
{
	size_t len;
	int ret;
	char *value;

	if ((ret = sshbuf_get_cstring(buffer, &value, &len)) != 0) {
		error("%s: %s", __func__, ssh_err(ret));
		return NULL;
	}
	if (length_ptr != NULL)
		*length_ptr = len;  /* Safe: sshbuf never stores len > 2^31 */
	return value;
}

char *
buffer_get_cstring(Buffer *buffer, u_int *length_ptr)
{
	char *ret;

	if ((ret = buffer_get_cstring_ret(buffer, length_ptr)) == NULL)
		fatal("%s: buffer error", __func__);
	return ret;
}

const void *
buffer_get_string_ptr_ret(Buffer *buffer, u_int *length_ptr)
{
	size_t len;
	int ret;
	const u_char *value;

	if ((ret = sshbuf_get_string_direct(buffer, &value, &len)) != 0) {
		error("%s: %s", __func__, ssh_err(ret));
		return NULL;
	}
	if (length_ptr != NULL)
		*length_ptr = len;  /* Safe: sshbuf never stores len > 2^31 */
	return value;
}

const void *
buffer_get_string_ptr(Buffer *buffer, u_int *length_ptr)
{
	const void *ret;

	if ((ret = buffer_get_string_ptr_ret(buffer, length_ptr)) == NULL)
		fatal("%s: buffer error", __func__);
	return (ret);
}

void
buffer_put_string(Buffer *buffer, const void *buf, u_int len)
{
	int ret;

	if ((ret = sshbuf_put_string(buffer, buf, len)) != 0)
		fatal("%s: %s", __func__, ssh_err(ret));
}

void
buffer_put_cstring(Buffer *buffer, const char *s)
{
	int ret;

	if ((ret = sshbuf_put_cstring(buffer, s)) != 0)
		fatal("%s: %s", __func__, ssh_err(ret));
}

int
buffer_get_char_ret(char *v, Buffer *buffer)
{
	int ret;

	if ((ret = sshbuf_get_u8(buffer, (u_char *)v)) != 0) {
		error("%s: %s", __func__, ssh_err(ret));
		return -1;
	}
	return 0;
}

int
buffer_get_char(Buffer *buffer)
{
	char ch;

	if (buffer_get_char_ret(&ch, buffer) == -1)
		fatal("%s: buffer error", __func__);
	return (u_char) ch;
}

void
buffer_put_char(Buffer *buffer, int value)
{
	int ret;

	if ((ret = sshbuf_put_u8(buffer, value)) != 0)
		fatal("%s: %s", __func__, ssh_err(ret));
}

void
buffer_put_bignum2_from_string(Buffer *buffer, const u_char *s, u_int l)
{
	int ret;

	if ((ret = sshbuf_put_bignum2_bytes(buffer, s, l)) != 0)
		fatal("%s: %s", __func__, ssh_err(ret));
}

@


1.59
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.58 2014/04/28 03:09:18 djm Exp $ */
d3 1
a3 5
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Auxiliary functions for storing and retrieving various data types to/from
 * Buffers.
d5 3
a7 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d9 7
a15 23
 *
 * SSH2 packet format added by Markus Friedl
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d18 2
a21 5
#include <string.h>
#include <stdarg.h>
#include <stdlib.h>

#include "xmalloc.h"
d24 1
a24 5
#include "misc.h"

/*
 * Returns integers from the buffer (msb first).
 */
d27 1
a27 1
buffer_get_short_ret(u_short *ret, Buffer *buffer)
d29 1
a29 1
	u_char buf[2];
d31 5
a35 4
	if (buffer_get_ret(buffer, (char *) buf, 2) == -1)
		return (-1);
	*ret = get_u16(buf);
	return (0);
d44 1
a44 1
		fatal("buffer_get_short: buffer error");
d50 1
a50 1
buffer_get_int_ret(u_int *ret, Buffer *buffer)
d52 1
a52 1
	u_char buf[4];
d54 5
a58 5
	if (buffer_get_ret(buffer, (char *) buf, 4) == -1)
		return (-1);
	if (ret != NULL)
		*ret = get_u32(buf);
	return (0);
d67 1
a67 1
		fatal("buffer_get_int: buffer error");
d73 1
a73 1
buffer_get_int64_ret(u_int64_t *ret, Buffer *buffer)
d75 1
a75 1
	u_char buf[8];
d77 5
a81 5
	if (buffer_get_ret(buffer, (char *) buf, 8) == -1)
		return (-1);
	if (ret != NULL)
		*ret = get_u64(buf);
	return (0);
d90 1
a90 1
		fatal("buffer_get_int: buffer error");
a94 3
/*
 * Stores integers in the buffer, msb first.
 */
d98 1
a98 1
	char buf[2];
d100 2
a101 2
	put_u16(buf, value);
	buffer_append(buffer, buf, 2);
d107 1
a107 1
	char buf[4];
d109 2
a110 2
	put_u32(buf, value);
	buffer_append(buffer, buf, 4);
d116 1
a116 1
	char buf[8];
d118 2
a119 2
	put_u64(buf, value);
	buffer_append(buffer, buf, 8);
a121 8
/*
 * Returns an arbitrary binary string from the buffer.  The string cannot
 * be longer than 256k.  The returned value points to memory allocated
 * with xmalloc; it is the responsibility of the calling function to free
 * the data.  If length_ptr is non-NULL, the length of the returned data
 * will be stored there.  A null character will be automatically appended
 * to the returned string, and is not counted in length.
 */
d125 2
a127 1
	u_int len;
d129 3
a131 4
	/* Get the length. */
	if (buffer_get_int_ret(&len, buffer) != 0) {
		error("buffer_get_string_ret: cannot extract length");
		return (NULL);
d133 3
a135 18
	if (len > 256 * 1024) {
		error("buffer_get_string_ret: bad string length %u", len);
		return (NULL);
	}
	/* Allocate space for the string.  Add one byte for a null character. */
	value = xmalloc(len + 1);
	/* Get the string. */
	if (buffer_get_ret(buffer, value, len) == -1) {
		error("buffer_get_string_ret: buffer_get failed");
		free(value);
		return (NULL);
	}
	/* Append a null character to make processing easier. */
	value[len] = '\0';
	/* Optionally return the length of the string. */
	if (length_ptr)
		*length_ptr = len;
	return (value);
d144 1
a144 1
		fatal("buffer_get_string: buffer error");
d151 3
a153 2
	u_int length;
	char *cp, *ret = buffer_get_string_ret(buffer, &length);
d155 2
a156 1
	if (ret == NULL)
a157 9
	if ((cp = memchr(ret, '\0', length)) != NULL) {
		/* XXX allow \0 at end-of-string for a while, remove later */
		if (cp == ret + length - 1)
			error("buffer_get_cstring_ret: string contains \\0");
		else {
			explicit_bzero(ret, length);
			free(ret);
			return NULL;
		}
d160 2
a161 2
		*length_ptr = length;
	return ret;
d170 1
a170 1
		fatal("buffer_get_cstring: buffer error");
d177 3
a179 2
	void *ptr;
	u_int len;
d181 2
a182 4
	if (buffer_get_int_ret(&len, buffer) != 0)
		return NULL;
	if (len > 256 * 1024) {
		error("buffer_get_string_ptr: bad string length %u", len);
d185 3
a187 5
	ptr = buffer_ptr(buffer);
	buffer_consume(buffer, len);
	if (length_ptr)
		*length_ptr = len;
	return (ptr);
d196 1
a196 1
		fatal("buffer_get_string_ptr: buffer error");
a199 3
/*
 * Stores and arbitrary binary string in the buffer.
 */
d203 4
a206 2
	buffer_put_int(buffer, len);
	buffer_append(buffer, buf, len);
d208 1
d212 4
a215 3
	if (s == NULL)
		fatal("buffer_put_cstring: s == NULL");
	buffer_put_string(buffer, s, strlen(s));
a217 3
/*
 * Returns a character from the buffer (0 - 255).
 */
d219 1
a219 1
buffer_get_char_ret(u_char *ret, Buffer *buffer)
d221 5
a225 3
	if (buffer_get_ret(buffer, ret, 1) == -1) {
		error("buffer_get_char_ret: buffer_get_ret failed");
		return (-1);
d227 1
a227 1
	return (0);
d233 1
a233 1
	u_char ch;
d236 2
a237 2
		fatal("buffer_get_char: buffer error");
	return ch;
a239 3
/*
 * Stores a character in the buffer.
 */
d243 1
a243 44
	char ch = value;

	buffer_append(buffer, &ch, 1);
}

/* Pseudo bignum functions */

void *
buffer_get_bignum2_as_string_ret(Buffer *buffer, u_int *length_ptr)
{
	u_int len;
	u_char *bin, *p, *ret;

	if ((p = bin = buffer_get_string_ret(buffer, &len)) == NULL) {
		error("%s: invalid bignum", __func__);
		return NULL;
	}

	if (len > 0 && (bin[0] & 0x80)) {
		error("%s: negative numbers not supported", __func__);
		free(bin);
		return NULL;
	}
	if (len > 8 * 1024) {
		error("%s: cannot handle BN of size %d", __func__, len);
		free(bin);
		return NULL;
	}
	/* Skip zero prefix on numbers with the MSB set */
	if (len > 1 && bin[0] == 0x00 && (bin[1] & 0x80) != 0) {
		p++;
		len--;
	}
	ret = xmalloc(len);
	memcpy(ret, p, len);
	explicit_bzero(p, len);
	free(bin);
	return ret;
}

void *
buffer_get_bignum2_as_string(Buffer *buffer, u_int *l)
{
	void *ret = buffer_get_bignum2_as_string_ret(buffer, l);
d245 2
a246 3
	if (ret == NULL)
		fatal("%s: buffer error", __func__);
	return ret;
a248 3
/*
 * Stores a string using the bignum encoding rules (\0 pad if MSB set).
 */
d252 1
a252 2
	u_char *buf, *p;
	int pad = 0;
d254 2
a255 18
	if (l > 8 * 1024)
		fatal("%s: length %u too long", __func__, l);
	/* Skip leading zero bytes */
	for (; l > 0 && *s == 0; l--, s++)
		;
	p = buf = xmalloc(l + 1);
	/*
	 * If most significant bit is set then prepend a zero byte to
	 * avoid interpretation as a negative number.
	 */
	if (l > 0 && (s[0] & 0x80) != 0) {
		*p++ = '\0';
		pad = 1;
	}
	memcpy(p, s, l);
	buffer_put_string(buffer, buf, l + pad);
	explicit_bzero(buf, l + pad);
	free(buf);
a256 1

@


1.58
log
@buffer_get_string_ptr's return should be const to remind
callers that futzing with it will futz with the actual buffer
contents
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.57 2014/04/16 23:22:45 djm Exp $ */
a40 2

#include <openssl/bn.h>
@


1.57
log
@skip leading zero bytes in buffer_put_bignum2_from_string();
reported by jan AT mojzis.com; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.56 2014/02/02 03:44:31 djm Exp $ */
d237 1
a237 1
void *
d256 1
a256 1
void *
d259 1
a259 1
	void *ret;
@


1.56
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.55 2014/01/31 16:39:19 tedu Exp $ */
d373 3
@


1.56.4.1
log
@MFC:

reliability fix for OpenSSH using curve25519-sha256@@libssh.org key
exchange method.

revision 1.71
date: 2014/04/18 23:52:25;  author: djm;  state: Exp;  lines: +2 -2;
OpenSSH 6.5 and 6.6 have a bug that causes ~0.2% of connections
using the curve25519-sha256@@libssh.org KEX exchange method to fail
when connecting with something that implements the spec properly.

Disable this KEX method when speaking to one of the affected
versions.

revision 1.57
date: 2014/04/16 23:22:45;  author: djm;  state: Exp;  lines: +4 -1;
skip leading zero bytes in buffer_put_bignum2_from_string();
reported by jan AT mojzis.com; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.57 2014/04/16 23:22:45 djm Exp $ */
a372 3
	/* Skip leading zero bytes */
	for (; l > 0 && *s == 0; l--, s++)
		;
@


1.55
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.54 2014/01/12 08:13:13 djm Exp $ */
d347 1
a347 1
	memset(p, '\0', len);
d384 1
a384 1
	memset(buf, '\0', l + pad);
@


1.54
log
@avoid use of OpenSSL BIGNUM type and functions for KEX with
Curve25519 by adding a buffer_put_bignum2_from_string() that stores
a string using the bignum encoding rules. Will make it easier to
build a reduced-feature OpenSSH without OpenSSL in the future;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.53 2013/11/08 11:15:19 dtucker Exp $ */
d217 1
a217 1
			bzero(ret, length);
@


1.53
log
@Include stdlib.h for free() as per the man page.
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.52 2013/07/12 00:19:58 djm Exp $ */
d316 73
@


1.52
log
@fix pointer-signedness warnings from clang/llvm-3.3; "seems nice" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.51 2013/05/17 00:13:13 djm Exp $ */
d46 1
@


1.51
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.50 2010/08/31 09:58:37 djm Exp $ */
d286 1
a286 1
buffer_get_char_ret(char *ret, Buffer *buffer)
d298 1
a298 1
	char ch;
d302 1
a302 1
	return (u_char) ch;
@


1.50
log
@Add buffer_get_cstring() and related functions that verify that the
string extracted from the buffer contains no embedded \0 characters*
This prevents random (possibly malicious) crap from being appended to
strings where it would not be noticed if the string is used with
a string(3) function.

Use the new API in a few sensitive places.

* actually, we allow a single one at the end of the string for now because
we don't know how many deployed implementations get this wrong, but don't
count on this to remain indefinitely.
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.49 2010/03/26 03:13:17 djm Exp $ */
d182 1
a182 1
		xfree(value);
d217 1
a217 1
			xfree(ret);
@


1.49
log
@allow buffer_get_int_ret/buffer_get_int64_ret to take a NULL pointer
argument to allow skipping past values in a buffer
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.48 2010/02/02 22:49:34 djm Exp $ */
d201 33
@


1.48
log
@make buffer_get_string_ret() really non-fatal in all cases (it was
using buffer_get_int(), which could fatal() on buffer empty);
ok markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.47 2010/01/12 01:36:08 djm Exp $ */
d85 2
a86 1
	*ret = get_u32(buf);
d108 2
a109 1
	*ret = get_u64(buf);
@


1.47
log
@add a buffer_get_string_ptr_ret() that does the same as
buffer_get_string_ptr() but does not fatal() on error; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.46 2008/06/10 23:21:34 dtucker Exp $ */
d167 4
a170 1
	len = buffer_get_int(buffer);
@


1.46
log
@Use '\0' for a nul byte rather than unadorned 0.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.45 2008/05/08 06:59:01 markus Exp $ */
d199 1
a199 1
buffer_get_string_ptr(Buffer *buffer, u_int *length_ptr)
d204 6
a209 3
	len = buffer_get_int(buffer);
	if (len > 256 * 1024)
		fatal("buffer_get_string_ptr: bad string length %u", len);
d215 10
@


1.45
log
@avoid extra malloc/copy/free when receiving data over the net;
~10% speedup for localhost-scp; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.44 2006/08/03 03:34:41 deraadt Exp $ */
d181 1
a181 1
	value[len] = 0;
@


1.44
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.43 2006/07/22 20:48:22 stevesk Exp $ */
d196 16
@


1.43
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.42 2006/04/18 10:44:28 dtucker Exp $ */
d40 1
a40 1
#include "includes.h"
d45 1
a46 1
#include "bufaux.h"
d48 1
@


1.42
log
@Move Buffer bignum functions into their own file, bufbn.c.  This means that
sftp and sftp-server (which use the Buffer functions in bufaux.c but not the
bignum ones) no longer need to be linked with libcrypto.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.41 2006/03/30 09:58:15 djm Exp $ */
d43 3
@


1.41
log
@replace {GET,PUT}_XXBIT macros with functionally similar functions,
silencing a heap of lint warnings. also allows them to use
__bounded__ checking which can't be applied to macros; requested
by and feedback from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.40 2006/03/25 18:56:54 deraadt Exp $ */
a46 163

/*
 * Stores an BIGNUM in the buffer with a 2-byte msb first bit count, followed
 * by (bits+7)/8 bytes of binary data, msb first.
 */
int
buffer_put_bignum_ret(Buffer *buffer, const BIGNUM *value)
{
	int bits = BN_num_bits(value);
	int bin_size = (bits + 7) / 8;
	u_char *buf = xmalloc(bin_size);
	int oi;
	char msg[2];

	/* Get the value of in binary */
	oi = BN_bn2bin(value, buf);
	if (oi != bin_size) {
		error("buffer_put_bignum_ret: BN_bn2bin() failed: oi %d != bin_size %d",
		    oi, bin_size);
		xfree(buf);
		return (-1);
	}

	/* Store the number of bits in the buffer in two bytes, msb first. */
	put_u16(msg, bits);
	buffer_append(buffer, msg, 2);
	/* Store the binary data. */
	buffer_append(buffer, buf, oi);

	memset(buf, 0, bin_size);
	xfree(buf);

	return (0);
}

void
buffer_put_bignum(Buffer *buffer, const BIGNUM *value)
{
	if (buffer_put_bignum_ret(buffer, value) == -1)
		fatal("buffer_put_bignum: buffer error");
}

/*
 * Retrieves an BIGNUM from the buffer.
 */
int
buffer_get_bignum_ret(Buffer *buffer, BIGNUM *value)
{
	u_int bits, bytes;
	u_char buf[2], *bin;

	/* Get the number for bits. */
	if (buffer_get_ret(buffer, (char *) buf, 2) == -1) {
		error("buffer_get_bignum_ret: invalid length");
		return (-1);
	}
	bits = get_u16(buf);
	/* Compute the number of binary bytes that follow. */
	bytes = (bits + 7) / 8;
	if (bytes > 8 * 1024) {
		error("buffer_get_bignum_ret: cannot handle BN of size %d", bytes);
		return (-1);
	}
	if (buffer_len(buffer) < bytes) {
		error("buffer_get_bignum_ret: input buffer too small");
		return (-1);
	}
	bin = buffer_ptr(buffer);
	BN_bin2bn(bin, bytes, value);
	if (buffer_consume_ret(buffer, bytes) == -1) {
		error("buffer_get_bignum_ret: buffer_consume failed");
		return (-1);
	}
	return (0);
}

void
buffer_get_bignum(Buffer *buffer, BIGNUM *value)
{
	if (buffer_get_bignum_ret(buffer, value) == -1)
		fatal("buffer_get_bignum: buffer error");
}

/*
 * Stores an BIGNUM in the buffer in SSH2 format.
 */
int
buffer_put_bignum2_ret(Buffer *buffer, const BIGNUM *value)
{
	u_int bytes;
	u_char *buf;
	int oi;
	u_int hasnohigh = 0;

	if (BN_is_zero(value)) {
		buffer_put_int(buffer, 0);
		return 0;
	}
	if (value->neg) {
		error("buffer_put_bignum2_ret: negative numbers not supported");
		return (-1);
	}
	bytes = BN_num_bytes(value) + 1; /* extra padding byte */
	if (bytes < 2) {
		error("buffer_put_bignum2_ret: BN too small");
		return (-1);
	}
	buf = xmalloc(bytes);
	buf[0] = 0x00;
	/* Get the value of in binary */
	oi = BN_bn2bin(value, buf+1);
	if (oi < 0 || (u_int)oi != bytes - 1) {
		error("buffer_put_bignum2_ret: BN_bn2bin() failed: "
		    "oi %d != bin_size %d", oi, bytes);
		xfree(buf);
		return (-1);
	}
	hasnohigh = (buf[1] & 0x80) ? 0 : 1;
	buffer_put_string(buffer, buf+hasnohigh, bytes-hasnohigh);
	memset(buf, 0, bytes);
	xfree(buf);
	return (0);
}

void
buffer_put_bignum2(Buffer *buffer, const BIGNUM *value)
{
	if (buffer_put_bignum2_ret(buffer, value) == -1)
		fatal("buffer_put_bignum2: buffer error");
}

int
buffer_get_bignum2_ret(Buffer *buffer, BIGNUM *value)
{
	u_int len;
	u_char *bin;

	if ((bin = buffer_get_string_ret(buffer, &len)) == NULL) {
		error("buffer_get_bignum2_ret: invalid bignum");
		return (-1);
	}

	if (len > 0 && (bin[0] & 0x80)) {
		error("buffer_get_bignum2_ret: negative numbers not supported");
		xfree(bin);
		return (-1);
	}
	if (len > 8 * 1024) {
		error("buffer_get_bignum2_ret: cannot handle BN of size %d", len);
		xfree(bin);
		return (-1);
	}
	BN_bin2bn(bin, len, value);
	xfree(bin);
	return (0);
}

void
buffer_get_bignum2(Buffer *buffer, BIGNUM *value)
{
	if (buffer_get_bignum2_ret(buffer, value) == -1)
		fatal("buffer_get_bignum2: buffer error");
}
@


1.40
log
@remove (char *) casts to a function that accepts void * for the arg
@
text
@d1 1
a1 1
/* $OpenBSD: bufaux.c,v 1.39 2006/03/25 13:17:01 djm Exp $ */
a44 1
#include "getput.h"
d46 1
d71 1
a71 1
	PUT_16BIT(msg, bits);
d103 1
a103 1
	bits = GET_16BIT(buf);
d222 1
a222 1
	*ret = GET_16BIT(buf);
d244 1
a244 1
	*ret = GET_32BIT(buf);
d266 1
a266 1
	*ret = GET_64BIT(buf);
d289 1
a289 1
	PUT_16BIT(buf, value);
d298 1
a298 1
	PUT_32BIT(buf, value);
d307 1
a307 1
	PUT_64BIT(buf, value);
@


1.39
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d74 1
a74 1
	buffer_append(buffer, (char *)buf, oi);
@


1.38
log
@RCSID() can die
@
text
@d1 1
@


1.37
log
@Fix leaks in error paths, bz #1109 and #1110 reported by kremenek AT
cs.stanford.edu; ok dtucker@@
@
text
@a39 1
RCSID("$OpenBSD: bufaux.c,v 1.36 2005/06/17 02:44:32 djm Exp $");
@


1.37.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: bufaux.c,v 1.44 2006/08/03 03:34:41 deraadt Exp $ */
d39 2
a40 1
#include <sys/types.h>
d43 26
d70 18
a87 2
#include <string.h>
#include <stdarg.h>
d89 121
a209 4
#include "xmalloc.h"
#include "buffer.h"
#include "log.h"
#include "misc.h"
d222 1
a222 1
	*ret = get_u16(buf);
d244 1
a244 1
	*ret = get_u32(buf);
d266 1
a266 1
	*ret = get_u64(buf);
d289 1
a289 1
	put_u16(buf, value);
d298 1
a298 1
	put_u32(buf, value);
d307 1
a307 1
	put_u64(buf, value);
@


1.36
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.35 2005/03/10 22:01:05 deraadt Exp $");
d66 1
d191 1
d196 1
@


1.36.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.37 2005/11/05 05:01:15 djm Exp $");
a65 1
		xfree(buf);
a189 1
		xfree(bin);
a193 1
		xfree(bin);
@


1.36.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: bufaux.c,v 1.44 2006/08/03 03:34:41 deraadt Exp $ */
d39 2
a40 1
#include <sys/types.h>
d43 26
d70 18
a87 2
#include <string.h>
#include <stdarg.h>
d89 121
a209 4
#include "xmalloc.h"
#include "buffer.h"
#include "log.h"
#include "misc.h"
d222 1
a222 1
	*ret = get_u16(buf);
d244 1
a244 1
	*ret = get_u32(buf);
d266 1
a266 1
	*ret = get_u64(buf);
d289 1
a289 1
	put_u16(buf, value);
d298 1
a298 1
	put_u32(buf, value);
d307 1
a307 1
	put_u64(buf, value);
@


1.35
log
@spacing
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.34 2004/12/06 16:00:43 markus Exp $");
d157 1
a157 1
	if (oi != bytes-1) {
@


1.35.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.36 2005/06/17 02:44:32 djm Exp $");
d157 1
a157 1
	if (oi < 0 || (u_int)oi != bytes - 1) {
@


1.35.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.37 2005/11/05 05:01:15 djm Exp $");
a65 1
		xfree(buf);
a189 1
		xfree(bin);
a193 1
		xfree(bin);
@


1.34
log
@use 0x00 not \0 since buf[] is a bignum
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.33 2004/10/29 23:56:17 djm Exp $");
d182 1
a182 1
	
@


1.33
log
@introduce a new buffer API that returns an error rather than fatal()ing when
presented with bad data; ok markus@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.32 2004/02/23 15:12:46 markus Exp $");
d154 1
a154 1
	buf[0] = '\0';
@


1.32
log
@encode 0 correctly in buffer_put_bignum2; noted by Mikulas Patocka
and drop support for negative BNs; ok otto@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.31 2003/11/10 16:23:41 jakob Exp $");
d52 2
a53 2
void
buffer_put_bignum(Buffer *buffer, const BIGNUM *value)
d63 2
a64 2
	if (oi != bin_size)
		fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d",
d66 2
d77 9
d91 2
a92 2
void
buffer_get_bignum(Buffer *buffer, BIGNUM *value)
d98 4
a101 1
	buffer_get(buffer, (char *) buf, 2);
d105 8
a112 4
	if (bytes > 8 * 1024)
		fatal("buffer_get_bignum: cannot handle BN of size %d", bytes);
	if (buffer_len(buffer) < bytes)
		fatal("buffer_get_bignum: input buffer too small");
d115 12
a126 1
	buffer_consume(buffer, bytes);
d132 2
a133 2
void
buffer_put_bignum2(Buffer *buffer, const BIGNUM *value)
d142 5
a146 1
		return;
a147 2
	if (value->neg)
		fatal("buffer_put_bignum2: negative numbers not supported");
d149 4
a152 2
	if (bytes < 2)
		fatal("buffer_put_bignum2: BN too small");
d157 2
a158 2
	if (oi != bytes-1)
		fatal("buffer_put_bignum2: BN_bn2bin() failed: "
d160 3
d167 1
d171 8
a178 1
buffer_get_bignum2(Buffer *buffer, BIGNUM *value)
d181 6
a186 1
	u_char *bin = buffer_get_string(buffer, &len);
d188 8
a195 4
	if (len > 0 && (bin[0] & 0x80))
		fatal("buffer_get_bignum2: negative numbers not supported");
	if (len > 8 * 1024)
		fatal("buffer_get_bignum2: cannot handle BN of size %d", len);
d198 8
d212 11
d226 12
a237 1
	u_char buf[2];
d239 4
a242 2
	buffer_get(buffer, (char *) buf, 2);
	return GET_16BIT(buf);
d248 12
a259 1
	u_char buf[4];
d261 4
a264 2
	buffer_get(buffer, (char *) buf, 4);
	return GET_32BIT(buf);
d270 4
a273 1
	u_char buf[8];
d275 1
a275 2
	buffer_get(buffer, (char *) buf, 8);
	return GET_64BIT(buf);
d317 1
a317 1
buffer_get_string(Buffer *buffer, u_int *length_ptr)
d324 4
a327 2
	if (len > 256 * 1024)
		fatal("buffer_get_string: bad string length %u", len);
d331 5
a335 1
	buffer_get(buffer, value, len);
d341 11
a351 1
	return value;
d375 10
d389 2
a390 1
	buffer_get(buffer, &ch, 1);
@


1.32.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.34 2004/12/06 16:00:43 markus Exp $");
d52 2
a53 2
int
buffer_put_bignum_ret(Buffer *buffer, const BIGNUM *value)
d63 2
a64 2
	if (oi != bin_size) {
		error("buffer_put_bignum_ret: BN_bn2bin() failed: oi %d != bin_size %d",
a65 2
		return (-1);
	}
a74 9

	return (0);
}

void
buffer_put_bignum(Buffer *buffer, const BIGNUM *value)
{
	if (buffer_put_bignum_ret(buffer, value) == -1)
		fatal("buffer_put_bignum: buffer error");
d80 2
a81 2
int
buffer_get_bignum_ret(Buffer *buffer, BIGNUM *value)
d87 1
a87 4
	if (buffer_get_ret(buffer, (char *) buf, 2) == -1) {
		error("buffer_get_bignum_ret: invalid length");
		return (-1);
	}
d91 4
a94 8
	if (bytes > 8 * 1024) {
		error("buffer_get_bignum_ret: cannot handle BN of size %d", bytes);
		return (-1);
	}
	if (buffer_len(buffer) < bytes) {
		error("buffer_get_bignum_ret: input buffer too small");
		return (-1);
	}
d97 1
a97 12
	if (buffer_consume_ret(buffer, bytes) == -1) {
		error("buffer_get_bignum_ret: buffer_consume failed");
		return (-1);
	}
	return (0);
}

void
buffer_get_bignum(Buffer *buffer, BIGNUM *value)
{
	if (buffer_get_bignum_ret(buffer, value) == -1)
		fatal("buffer_get_bignum: buffer error");
d103 2
a104 2
int
buffer_put_bignum2_ret(Buffer *buffer, const BIGNUM *value)
d113 1
a113 5
		return 0;
	}
	if (value->neg) {
		error("buffer_put_bignum2_ret: negative numbers not supported");
		return (-1);
d115 2
d118 2
a119 4
	if (bytes < 2) {
		error("buffer_put_bignum2_ret: BN too small");
		return (-1);
	}
d121 1
a121 1
	buf[0] = 0x00;
d124 2
a125 2
	if (oi != bytes-1) {
		error("buffer_put_bignum2_ret: BN_bn2bin() failed: "
a126 3
		xfree(buf);
		return (-1);
	}
a130 1
	return (0);
d134 1
a134 8
buffer_put_bignum2(Buffer *buffer, const BIGNUM *value)
{
	if (buffer_put_bignum2_ret(buffer, value) == -1)
		fatal("buffer_put_bignum2: buffer error");
}

int
buffer_get_bignum2_ret(Buffer *buffer, BIGNUM *value)
d137 1
a137 6
	u_char *bin;
	
	if ((bin = buffer_get_string_ret(buffer, &len)) == NULL) {
		error("buffer_get_bignum2_ret: invalid bignum");
		return (-1);
	}
d139 4
a142 8
	if (len > 0 && (bin[0] & 0x80)) {
		error("buffer_get_bignum2_ret: negative numbers not supported");
		return (-1);
	}
	if (len > 8 * 1024) {
		error("buffer_get_bignum2_ret: cannot handle BN of size %d", len);
		return (-1);
	}
a144 8
	return (0);
}

void
buffer_get_bignum2(Buffer *buffer, BIGNUM *value)
{
	if (buffer_get_bignum2_ret(buffer, value) == -1)
		fatal("buffer_get_bignum2: buffer error");
a150 11
int
buffer_get_short_ret(u_short *ret, Buffer *buffer)
{
	u_char buf[2];

	if (buffer_get_ret(buffer, (char *) buf, 2) == -1)
		return (-1);
	*ret = GET_16BIT(buf);
	return (0);
}

d154 1
a154 4
	u_short ret;

	if (buffer_get_short_ret(&ret, buffer) == -1)
		fatal("buffer_get_short: buffer error");
d156 2
a157 12
	return (ret);
}

int
buffer_get_int_ret(u_int *ret, Buffer *buffer)
{
	u_char buf[4];

	if (buffer_get_ret(buffer, (char *) buf, 4) == -1)
		return (-1);
	*ret = GET_32BIT(buf);
	return (0);
d163 1
a163 7
	u_int ret;

	if (buffer_get_int_ret(&ret, buffer) == -1)
		fatal("buffer_get_int: buffer error");

	return (ret);
}
d165 2
a166 9
int
buffer_get_int64_ret(u_int64_t *ret, Buffer *buffer)
{
	u_char buf[8];

	if (buffer_get_ret(buffer, (char *) buf, 8) == -1)
		return (-1);
	*ret = GET_64BIT(buf);
	return (0);
d172 1
a172 1
	u_int64_t ret;
d174 2
a175 4
	if (buffer_get_int64_ret(&ret, buffer) == -1)
		fatal("buffer_get_int: buffer error");

	return (ret);
d217 1
a217 1
buffer_get_string_ret(Buffer *buffer, u_int *length_ptr)
d224 2
a225 4
	if (len > 256 * 1024) {
		error("buffer_get_string_ret: bad string length %u", len);
		return (NULL);
	}
d229 1
a229 5
	if (buffer_get_ret(buffer, value, len) == -1) {
		error("buffer_get_string_ret: buffer_get failed");
		xfree(value);
		return (NULL);
	}
d235 1
a235 11
	return (value);
}

void *
buffer_get_string(Buffer *buffer, u_int *length_ptr)
{
	void *ret;

	if ((ret = buffer_get_string_ret(buffer, length_ptr)) == NULL)
		fatal("buffer_get_string: buffer error");
	return (ret);
a258 10
buffer_get_char_ret(char *ret, Buffer *buffer)
{
	if (buffer_get_ret(buffer, ret, 1) == -1) {
		error("buffer_get_char_ret: buffer_get_ret failed");
		return (-1);
	}
	return (0);
}

int
d263 1
a263 2
	if (buffer_get_char_ret(&ch, buffer) == -1)
		fatal("buffer_get_char: buffer error");
@


1.32.4.1
log
@upgrade to OpenSSH 4.0
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.34 2004/12/06 16:00:43 markus Exp $");
d52 2
a53 2
int
buffer_put_bignum_ret(Buffer *buffer, const BIGNUM *value)
d63 2
a64 2
	if (oi != bin_size) {
		error("buffer_put_bignum_ret: BN_bn2bin() failed: oi %d != bin_size %d",
a65 2
		return (-1);
	}
a74 9

	return (0);
}

void
buffer_put_bignum(Buffer *buffer, const BIGNUM *value)
{
	if (buffer_put_bignum_ret(buffer, value) == -1)
		fatal("buffer_put_bignum: buffer error");
d80 2
a81 2
int
buffer_get_bignum_ret(Buffer *buffer, BIGNUM *value)
d87 1
a87 4
	if (buffer_get_ret(buffer, (char *) buf, 2) == -1) {
		error("buffer_get_bignum_ret: invalid length");
		return (-1);
	}
d91 4
a94 8
	if (bytes > 8 * 1024) {
		error("buffer_get_bignum_ret: cannot handle BN of size %d", bytes);
		return (-1);
	}
	if (buffer_len(buffer) < bytes) {
		error("buffer_get_bignum_ret: input buffer too small");
		return (-1);
	}
d97 1
a97 12
	if (buffer_consume_ret(buffer, bytes) == -1) {
		error("buffer_get_bignum_ret: buffer_consume failed");
		return (-1);
	}
	return (0);
}

void
buffer_get_bignum(Buffer *buffer, BIGNUM *value)
{
	if (buffer_get_bignum_ret(buffer, value) == -1)
		fatal("buffer_get_bignum: buffer error");
d103 2
a104 2
int
buffer_put_bignum2_ret(Buffer *buffer, const BIGNUM *value)
d113 1
a113 5
		return 0;
	}
	if (value->neg) {
		error("buffer_put_bignum2_ret: negative numbers not supported");
		return (-1);
d115 2
d118 2
a119 4
	if (bytes < 2) {
		error("buffer_put_bignum2_ret: BN too small");
		return (-1);
	}
d121 1
a121 1
	buf[0] = 0x00;
d124 2
a125 2
	if (oi != bytes-1) {
		error("buffer_put_bignum2_ret: BN_bn2bin() failed: "
a126 3
		xfree(buf);
		return (-1);
	}
a130 1
	return (0);
d134 1
a134 8
buffer_put_bignum2(Buffer *buffer, const BIGNUM *value)
{
	if (buffer_put_bignum2_ret(buffer, value) == -1)
		fatal("buffer_put_bignum2: buffer error");
}

int
buffer_get_bignum2_ret(Buffer *buffer, BIGNUM *value)
d137 1
a137 6
	u_char *bin;
	
	if ((bin = buffer_get_string_ret(buffer, &len)) == NULL) {
		error("buffer_get_bignum2_ret: invalid bignum");
		return (-1);
	}
d139 4
a142 8
	if (len > 0 && (bin[0] & 0x80)) {
		error("buffer_get_bignum2_ret: negative numbers not supported");
		return (-1);
	}
	if (len > 8 * 1024) {
		error("buffer_get_bignum2_ret: cannot handle BN of size %d", len);
		return (-1);
	}
a144 8
	return (0);
}

void
buffer_get_bignum2(Buffer *buffer, BIGNUM *value)
{
	if (buffer_get_bignum2_ret(buffer, value) == -1)
		fatal("buffer_get_bignum2: buffer error");
a150 11
int
buffer_get_short_ret(u_short *ret, Buffer *buffer)
{
	u_char buf[2];

	if (buffer_get_ret(buffer, (char *) buf, 2) == -1)
		return (-1);
	*ret = GET_16BIT(buf);
	return (0);
}

d154 1
a154 4
	u_short ret;

	if (buffer_get_short_ret(&ret, buffer) == -1)
		fatal("buffer_get_short: buffer error");
d156 2
a157 12
	return (ret);
}

int
buffer_get_int_ret(u_int *ret, Buffer *buffer)
{
	u_char buf[4];

	if (buffer_get_ret(buffer, (char *) buf, 4) == -1)
		return (-1);
	*ret = GET_32BIT(buf);
	return (0);
d163 1
a163 7
	u_int ret;

	if (buffer_get_int_ret(&ret, buffer) == -1)
		fatal("buffer_get_int: buffer error");

	return (ret);
}
d165 2
a166 9
int
buffer_get_int64_ret(u_int64_t *ret, Buffer *buffer)
{
	u_char buf[8];

	if (buffer_get_ret(buffer, (char *) buf, 8) == -1)
		return (-1);
	*ret = GET_64BIT(buf);
	return (0);
d172 1
a172 1
	u_int64_t ret;
d174 2
a175 4
	if (buffer_get_int64_ret(&ret, buffer) == -1)
		fatal("buffer_get_int: buffer error");

	return (ret);
d217 1
a217 1
buffer_get_string_ret(Buffer *buffer, u_int *length_ptr)
d224 2
a225 4
	if (len > 256 * 1024) {
		error("buffer_get_string_ret: bad string length %u", len);
		return (NULL);
	}
d229 1
a229 5
	if (buffer_get_ret(buffer, value, len) == -1) {
		error("buffer_get_string_ret: buffer_get failed");
		xfree(value);
		return (NULL);
	}
d235 1
a235 11
	return (value);
}

void *
buffer_get_string(Buffer *buffer, u_int *length_ptr)
{
	void *ret;

	if ((ret = buffer_get_string_ret(buffer, length_ptr)) == NULL)
		fatal("buffer_get_string: buffer error");
	return (ret);
a258 10
buffer_get_char_ret(char *ret, Buffer *buffer)
{
	if (buffer_get_ret(buffer, ret, 1) == -1) {
		error("buffer_get_char_ret: buffer_get_ret failed");
		return (-1);
	}
	return (0);
}

int
d263 1
a263 2
	if (buffer_get_char_ret(&ch, buffer) == -1)
		fatal("buffer_get_char: buffer error");
@


1.32.4.2
log
@upgrade to OpenSSH 4.1
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.35 2005/03/10 22:01:05 deraadt Exp $");
d182 1
a182 1

@


1.32.4.3
log
@upgrade to OpenSSH 4.2
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.36 2005/06/17 02:44:32 djm Exp $");
d157 1
a157 1
	if (oi < 0 || (u_int)oi != bytes - 1) {
@


1.31
log
@constify. ok markus@@ & djm@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.30 2003/09/18 13:02:21 miod Exp $");
d106 2
a107 2
	u_int bytes = BN_num_bytes(value) + 1;
	u_char *buf = xmalloc(bytes);
d111 10
d125 2
a126 2
		fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d",
		    oi, bytes);
a127 11
	if (value->neg) {
		/**XXX should be two's-complement */
		int i, carry;
		u_char *uc = buf;
		logit("negativ!");
		for (i = bytes-1, carry = 1; i>=0; i--) {
			uc[i] ^= 0xff;
			if (carry)
				carry = !++uc[i];
		}
	}
a132 1
/* XXX does not handle negative BNs */
d139 2
d146 1
@


1.30
log
@A few signedness fixes for harmless situations; markus@@ ok
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.29 2003/04/08 20:21:28 itojun Exp $");
d53 1
a53 1
buffer_put_bignum(Buffer *buffer, BIGNUM *value)
d104 1
a104 1
buffer_put_bignum2(Buffer *buffer, BIGNUM *value)
@


1.29
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.28 2002/10/23 10:40:16 markus Exp $");
d83 1
a83 1
	int bits, bytes;
d106 1
a106 1
	int bytes = BN_num_bytes(value) + 1;
d109 1
a109 1
	int hasnohigh = 0;
@


1.29.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.32 2004/02/23 15:12:46 markus Exp $");
d53 1
a53 1
buffer_put_bignum(Buffer *buffer, const BIGNUM *value)
d83 1
a83 1
	u_int bits, bytes;
d104 1
a104 1
buffer_put_bignum2(Buffer *buffer, const BIGNUM *value)
d106 2
a107 2
	u_int bytes;
	u_char *buf;
d109 1
a109 1
	u_int hasnohigh = 0;
a110 10
	if (BN_is_zero(value)) {
		buffer_put_int(buffer, 0);
		return;
	}
	if (value->neg)
		fatal("buffer_put_bignum2: negative numbers not supported");
	bytes = BN_num_bytes(value) + 1; /* extra padding byte */
	if (bytes < 2)
		fatal("buffer_put_bignum2: BN too small");
	buf = xmalloc(bytes);
d115 2
a116 2
		fatal("buffer_put_bignum2: BN_bn2bin() failed: "
		    "oi %d != bin_size %d", oi, bytes);
d118 11
d134 1
a140 2
	if (len > 0 && (bin[0] & 0x80))
		fatal("buffer_get_bignum2: negative numbers not supported");
a145 1

@


1.28
log
@%u for u_int
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.27 2002/06/26 08:53:12 markus Exp $");
d122 1
a122 1
		log("negativ!");
@


1.28.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.29 2003/04/08 20:21:28 itojun Exp $");
d122 1
a122 1
		logit("negativ!");
@


1.28.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.32 2004/02/23 15:12:46 markus Exp $");
d53 1
a53 1
buffer_put_bignum(Buffer *buffer, const BIGNUM *value)
d83 1
a83 1
	u_int bits, bytes;
d104 1
a104 1
buffer_put_bignum2(Buffer *buffer, const BIGNUM *value)
d106 2
a107 2
	u_int bytes;
	u_char *buf;
d109 1
a109 1
	u_int hasnohigh = 0;
a110 10
	if (BN_is_zero(value)) {
		buffer_put_int(buffer, 0);
		return;
	}
	if (value->neg)
		fatal("buffer_put_bignum2: negative numbers not supported");
	bytes = BN_num_bytes(value) + 1; /* extra padding byte */
	if (bytes < 2)
		fatal("buffer_put_bignum2: BN too small");
	buf = xmalloc(bytes);
d115 2
a116 2
		fatal("buffer_put_bignum2: BN_bn2bin() failed: "
		    "oi %d != bin_size %d", oi, bytes);
d118 11
d134 1
a140 2
	if (len > 0 && (bin[0] & 0x80))
		fatal("buffer_get_bignum2: negative numbers not supported");
a145 1

@


1.27
log
@limit size of BNs to 8KB; ok provos/deraadt
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.26 2002/06/23 09:46:51 deraadt Exp $");
d224 1
a224 1
		fatal("buffer_get_string: bad string length %d", len);
@


1.27.2.1
log
@Update to OpenSSH 3.6
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.28 2002/10/23 10:40:16 markus Exp $");
d224 1
a224 1
		fatal("buffer_get_string: bad string length %u", len);
@


1.27.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.29 2003/04/08 20:21:28 itojun Exp $");
d122 1
a122 1
		logit("negativ!");
@


1.26
log
@minor KNF.  things the fingers do while you read
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.25 2002/04/20 09:14:58 markus Exp $");
d91 2
d134 1
d138 2
a139 3
	/**XXX should be two's-complement */
	int len;
	u_char *bin = buffer_get_string(buffer, (u_int *)&len);
d141 2
@


1.25
log
@add buffer_{get,put}_short
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.24 2002/03/26 15:23:40 markus Exp $");
d108 1
d138 1
d150 1
d159 1
d168 1
d180 1
d189 1
d198 1
d214 1
d216 1
a216 1
	u_char *value;
d257 1
d269 1
@


1.24
log
@do not talk about packets in bufaux
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.23 2002/03/18 17:25:29 provos Exp $");
a139 1

d141 1
a141 1
 * Returns an integer from the buffer (4 bytes, msb first).
d143 9
d169 1
a169 1
 * Stores an integer in the buffer in 4 bytes, msb first.
d171 8
@


1.24.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.25 2002/04/20 09:14:58 markus Exp $");
d140 1
d142 1
a142 1
 * Returns integers from the buffer (msb first).
a143 9

u_short
buffer_get_short(Buffer *buffer)
{
	u_char buf[2];
	buffer_get(buffer, (char *) buf, 2);
	return GET_16BIT(buf);
}

d161 1
a161 1
 * Stores integers in the buffer, msb first.
a162 8
void
buffer_put_short(Buffer *buffer, u_short value)
{
	char buf[2];
	PUT_16BIT(buf, value);
	buffer_append(buffer, buf, 2);
}

@


1.24.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.24.2.3
log
@Pull in OpenSSH-3.4
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.27 2002/06/26 08:53:12 markus Exp $");
a90 2
	if (bytes > 8 * 1024)
		fatal("buffer_get_bignum: cannot handle BN of size %d", bytes);
a107 1

a130 1
/* XXX does not handle negative BNs */
d134 3
a136 5
	u_int len;
	u_char *bin = buffer_get_string(buffer, &len);

	if (len > 8 * 1024)
		fatal("buffer_get_bignum2: cannot handle BN of size %d", len);
a147 1

a155 1

a163 1

a174 1

a182 1

a190 1

d206 1
a207 2
	u_int len;

a247 1

a258 1

@


1.24.2.4
log
@Merge OpenSSH 3.6.1
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.28 2002/10/23 10:40:16 markus Exp $");
d224 1
a224 1
		fatal("buffer_get_string: bad string length %u", len);
@


1.23
log
@buffer_skip_string and extra sanity checking; needed by ssh-privsep
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.22 2002/01/18 18:14:17 stevesk Exp $");
d195 1
a195 1
		fatal("Received packet with bad string length %d", len);
@


1.22
log
@unneeded cast cleanup; ok markus@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.21 2001/12/28 14:13:13 markus Exp $");
d220 2
@


1.21
log
@buffer_get_bignum: int -> void
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.20 2001/12/19 17:16:13 stevesk Exp $");
d93 1
a93 1
	bin = (u_char *) buffer_ptr(buffer);
d136 1
a136 1
	u_char *bin = (u_char *)buffer_get_string(buffer, (u_int *)&len);
@


1.20
log
@change the buffer/packet interface to use void* vs. char*; ok markus@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.19 2001/12/19 07:18:56 deraadt Exp $");
d80 1
a80 1
int
a95 2

	return 2 + bytes;
d131 1
a131 1
int
a138 1
	return len;
@


1.19
log
@basic KNF done while i was looking for something else
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.18 2001/12/05 10:06:12 deraadt Exp $");
d190 1
a190 1
char *
d194 1
a194 1
	char *value;
@


1.18
log
@minor KNF
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.17 2001/01/21 19:05:45 markus Exp $");
d65 1
a65 1
		      oi, bin_size);
d115 1
a115 1
		      oi, bytes);
d122 1
a122 1
		for(i = bytes-1, carry = 1; i>=0; i--) {
@


1.17
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.16 2001/01/16 23:58:08 deraadt Exp $");
d124 1
a124 1
			if(carry)
@


1.17.2.1
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.22 2002/01/18 18:14:17 stevesk Exp $");
d65 1
a65 1
		    oi, bin_size);
d80 1
a80 1
void
d93 1
a93 1
	bin = buffer_ptr(buffer);
d96 2
d115 1
a115 1
		    oi, bytes);
d122 1
a122 1
		for (i = bytes-1, carry = 1; i>=0; i--) {
d124 1
a124 1
			if (carry)
d133 1
a133 1
void
d138 1
a138 1
	u_char *bin = buffer_get_string(buffer, (u_int *)&len);
d141 1
d190 1
a190 1
void *
d194 1
a194 1
	u_char *value;
@


1.17.2.2
log
@Errata #24 (markus@@)
Fix a buffer overflow in AFS/Kerberos token handling.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.17.2.1 2002/03/09 00:20:44 miod Exp $");
d140 1
d142 1
a142 1
 * Returns integers from the buffer (msb first).
a143 8
u_short
buffer_get_short(Buffer *buffer)
{
	u_char buf[2];
	buffer_get(buffer, (char *) buf, 2);
	return GET_16BIT(buf);
}

d161 1
a161 1
 * Stores integers in the buffer, msb first.
a162 8
void
buffer_put_short(Buffer *buffer, u_short value)
{
	char buf[2];
	PUT_16BIT(buf, value);
	buffer_append(buffer, buf, 2);
}

@


1.17.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.25 2002/04/20 09:14:58 markus Exp $");
a142 1

d210 1
a210 1
		fatal("buffer_get_string: bad string length %d", len);
a234 2
	if (s == NULL)
		fatal("buffer_put_cstring: s == NULL");
@


1.17.4.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.22 2002/01/18 18:14:17 stevesk Exp $");
d65 1
a65 1
		    oi, bin_size);
d80 1
a80 1
void
d93 1
a93 1
	bin = buffer_ptr(buffer);
d96 2
d115 1
a115 1
		    oi, bytes);
d122 1
a122 1
		for (i = bytes-1, carry = 1; i>=0; i--) {
d124 1
a124 1
			if (carry)
d133 1
a133 1
void
d138 1
a138 1
	u_char *bin = buffer_get_string(buffer, (u_int *)&len);
d141 1
d190 1
a190 1
void *
d194 1
a194 1
	u_char *value;
@


1.17.4.2
log
@Pull in patches from current:
Fix buffer overflow in AFS/Kerberos token handling.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.17.4.1 2002/03/07 17:37:46 jason Exp $");
d140 1
d142 1
a142 1
 * Returns integers from the buffer (msb first).
a143 9

u_short
buffer_get_short(Buffer *buffer)
{
	u_char buf[2];
	buffer_get(buffer, (char *) buf, 2);
	return GET_16BIT(buf);
}

d161 1
a161 1
 * Stores integers in the buffer, msb first.
a162 8
void
buffer_put_short(Buffer *buffer, u_short value)
{
	char buf[2];
	PUT_16BIT(buf, value);
	buffer_append(buffer, buf, 2);
}

@


1.17.4.3
log
@Update OpenSSH to version 3.2.2.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.25 2002/04/20 09:14:58 markus Exp $");
d211 1
a211 1
		fatal("buffer_get_string: bad string length %d", len);
a235 2
	if (s == NULL)
		fatal("buffer_put_cstring: s == NULL");
@


1.17.4.4
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.17.4.3 2002/05/17 00:03:23 miod Exp $");
a90 2
	if (bytes > 8 * 1024)
		fatal("buffer_get_bignum: cannot handle BN of size %d", bytes);
a107 1

a130 1
/* XXX does not handle negative BNs */
d134 3
a136 5
	u_int len;
	u_char *bin = buffer_get_string(buffer, &len);

	if (len > 8 * 1024)
		fatal("buffer_get_bignum2: cannot handle BN of size %d", len);
a147 1

a155 1

a163 1

a174 1

a182 1

a190 1

d206 1
a207 2
	u_int len;

a247 1

a258 1

@


1.16
log
@indent
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.15 2001/01/10 22:56:22 markus Exp $");
a41 1
#include "ssh.h"
d46 1
@


1.15
log
@cleanup sftp-server implementation:
	add buffer_get_int64, buffer_put_int64, GET_64BIT, PUT_64BIT
	parse SSH2_FILEXFER_ATTR_EXTENDED
	send SSH2_FX_EOF if readdir returns no more entries
	reply to SSH2_FXP_EXTENDED messages
	use #defines from the draft.
	move #definitions to sftp.h
more info:
http://www.ietf.org/internet-drafts/draft-ietf-secsh-filexfer-00.txt
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.14 2000/12/19 23:17:55 markus Exp $");
d93 1
a93 1
	bin = (u_char*) buffer_ptr(buffer);
@


1.14
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.13 2000/09/07 20:27:50 deraadt Exp $");
d155 8
d172 8
@


1.13
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.12 2000/06/20 01:39:39 markus Exp $");
d57 1
a57 1
	char unsigned *buf = xmalloc(bin_size);
d84 1
a84 1
	unsigned char buf[2], *bin;
d93 1
a93 1
	bin = (unsigned char*) buffer_ptr(buffer);
d107 1
a107 1
	unsigned char *buf = xmalloc(bytes);
d120 1
a120 1
		unsigned char *uc = buf;
d138 1
a138 1
	unsigned char *bin = (unsigned char *)buffer_get_string(buffer, (unsigned int *)&len);
d147 1
a147 1
unsigned int
d150 1
a150 1
	unsigned char buf[4];
d159 1
a159 1
buffer_put_int(Buffer *buffer, unsigned int value)
d175 1
a175 1
buffer_get_string(Buffer *buffer, unsigned int *length_ptr)
d177 1
a177 1
	unsigned int len;
d199 1
a199 1
buffer_put_string(Buffer *buffer, const void *buf, unsigned int len)
d218 1
a218 1
	return (unsigned char) ch;
@


1.13.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.17 2001/01/21 19:05:45 markus Exp $");
d42 1
a46 1
#include "log.h"
d57 1
a57 1
	u_char *buf = xmalloc(bin_size);
d84 1
a84 1
	u_char buf[2], *bin;
d93 1
a93 1
	bin = (u_char *) buffer_ptr(buffer);
d107 1
a107 1
	u_char *buf = xmalloc(bytes);
d120 1
a120 1
		u_char *uc = buf;
d138 1
a138 1
	u_char *bin = (u_char *)buffer_get_string(buffer, (u_int *)&len);
d147 1
a147 1
u_int
d150 1
a150 1
	u_char buf[4];
a154 8
u_int64_t
buffer_get_int64(Buffer *buffer)
{
	u_char buf[8];
	buffer_get(buffer, (char *) buf, 8);
	return GET_64BIT(buf);
}

d159 1
a159 1
buffer_put_int(Buffer *buffer, u_int value)
a165 8
void
buffer_put_int64(Buffer *buffer, u_int64_t value)
{
	char buf[8];
	PUT_64BIT(buf, value);
	buffer_append(buffer, buf, 8);
}

d175 1
a175 1
buffer_get_string(Buffer *buffer, u_int *length_ptr)
d177 1
a177 1
	u_int len;
d199 1
a199 1
buffer_put_string(Buffer *buffer, const void *buf, u_int len)
d218 1
a218 1
	return (u_char) ch;
@


1.13.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.13.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.13.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.13.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@@


1.13.2.6
log
@Merge OpenSSH 3.1.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.22 2002/01/18 18:14:17 stevesk Exp $");
d65 1
a65 1
		    oi, bin_size);
d80 1
a80 1
void
d93 1
a93 1
	bin = buffer_ptr(buffer);
d96 2
d115 1
a115 1
		    oi, bytes);
d122 1
a122 1
		for (i = bytes-1, carry = 1; i>=0; i--) {
d124 1
a124 1
			if (carry)
d133 1
a133 1
void
d138 1
a138 1
	u_char *bin = buffer_get_string(buffer, (u_int *)&len);
d141 1
d190 1
a190 1
void *
d194 1
a194 1
	u_char *value;
@


1.12
log
@OpenBSD tag
@
text
@a1 3
 *
 * bufaux.c
 *
a2 1
 *
d5 2
d8 5
a12 1
 * Created: Wed Mar 29 02:24:47 1995 ylo
a13 2
 * Auxiliary functions for storing and retrieving various data types to/from
 * Buffers.
d16 1
d18 19
d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.11 2000/04/14 10:30:30 markus Exp $");
@


1.11
log
@whitespace cleanup
@
text
@d20 1
a20 1
RCSID("$Id: bufaux.c,v 1.10 2000/04/12 09:39:10 markus Exp $");
@


1.11.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d20 1
a20 1
RCSID("$OpenBSD: bufaux.c,v 1.12 2000/06/20 01:39:39 markus Exp $");
@


1.11.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a14 7
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
a15 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
a16 19
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d20 1
a20 1
RCSID("$OpenBSD: bufaux.c,v 1.13 2000/09/07 20:27:50 deraadt Exp $");
@


1.11.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d40 1
a40 1
RCSID("$OpenBSD: bufaux.c,v 1.17 2001/01/21 19:05:45 markus Exp $");
d42 1
a46 1
#include "log.h"
d57 1
a57 1
	u_char *buf = xmalloc(bin_size);
d84 1
a84 1
	u_char buf[2], *bin;
d93 1
a93 1
	bin = (u_char *) buffer_ptr(buffer);
d107 1
a107 1
	u_char *buf = xmalloc(bytes);
d120 1
a120 1
		u_char *uc = buf;
d138 1
a138 1
	u_char *bin = (u_char *)buffer_get_string(buffer, (u_int *)&len);
d147 1
a147 1
u_int
d150 1
a150 1
	u_char buf[4];
a154 8
u_int64_t
buffer_get_int64(Buffer *buffer)
{
	u_char buf[8];
	buffer_get(buffer, (char *) buf, 8);
	return GET_64BIT(buf);
}

d159 1
a159 1
buffer_put_int(Buffer *buffer, u_int value)
a165 8
void
buffer_put_int64(Buffer *buffer, u_int64_t value)
{
	char buf[8];
	PUT_64BIT(buf, value);
	buffer_append(buffer, buf, 8);
}

d175 1
a175 1
buffer_get_string(Buffer *buffer, u_int *length_ptr)
d177 1
a177 1
	u_int len;
d199 1
a199 1
buffer_put_string(Buffer *buffer, const void *buf, u_int len)
d218 1
a218 1
	return (u_char) ch;
@


1.11.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.10
log
@#include <ssl/foo.h> -> <openssh/foo.h>
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d20 1
a20 1
RCSID("$Id: bufaux.c,v 1.9 2000/03/28 20:24:18 markus Exp $");
d127 1
a127 1
unsigned int 
d138 1
a138 1
void 
d178 1
a178 1
void 
d184 1
a184 1
void 
d193 1
a193 1
int 
d204 1
a204 1
void 
@


1.9
log
@support ssh2 bignums
@
text
@d20 1
a20 1
RCSID("$Id: bufaux.c,v 1.9 2000/03/22 13:40:45 markus Exp $");
d23 1
a23 1
#include <ssl/bn.h>
@


1.8
log
@-pedantic: signed vs. unsigned, void*-arithm, etc
@
text
@d15 2
d20 1
a20 1
RCSID("$Id: bufaux.c,v 1.7 1999/11/24 19:53:44 markus Exp $");
d81 44
d183 5
@


1.7
log
@KNF, final part 3
@
text
@d18 1
a18 1
RCSID("$Id: bufaux.c,v 1.6 1999/11/24 00:26:01 deraadt Exp $");
d35 1
a35 1
	char *buf = xmalloc(bin_size);
d49 1
a49 1
	buffer_append(buffer, buf, oi);
d71 1
a71 1
	bin = buffer_ptr(buffer);
@


1.6
log
@much more KNF
@
text
@d18 1
a18 1
RCSID("$Id: bufaux.c,v 1.5 1999/11/23 22:25:52 markus Exp $");
d50 1
a50 1
	/* Clear the temporary data. */
@


1.5
log
@KNF part 1
@
text
@d2 14
a15 14

bufaux.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Wed Mar 29 02:24:47 1995 ylo

Auxiliary functions for storing and retrieving various data types to/from
Buffers.

*/
d18 1
a18 1
RCSID("$Id: bufaux.c,v 1.4 1999/11/12 17:28:35 markus Exp $");
d26 4
a29 3
/* Stores an BIGNUM in the buffer with a 2-byte msb first bit count, followed
   by (bits+7)/8 bytes of binary data, msb first. */

d55 3
a57 2
/* Retrieves an BIGNUM from the buffer. */

d78 3
a80 2
/* Returns an integer from the buffer (4 bytes, msb first). */

d89 3
a91 2
/* Stores an integer in the buffer in 4 bytes, msb first. */

d100 8
a107 7
/* Returns an arbitrary binary string from the buffer.  The string cannot
   be longer than 256k.  The returned value points to memory allocated
   with xmalloc; it is the responsibility of the calling function to free
   the data.  If length_ptr is non-NULL, the length of the returned data
   will be stored there.  A null character will be automatically appended
   to the returned string, and is not counted in length. */

d129 3
a131 2
/* Stores and arbitrary binary string in the buffer. */

d139 3
a141 2
/* Returns a character from the buffer (0 - 255). */

d150 3
a152 2
/* Stores a character in the buffer. */

@


1.4
log
@save a view malloc/memcpy/memset/free's, ok niels
@
text
@d18 1
a18 1
RCSID("$Id: bufaux.c,v 1.3 1999/11/02 19:42:35 markus Exp $");
d32 20
a51 20
  int bits = BN_num_bits(value);
  int bin_size = (bits + 7) / 8;
  char *buf = xmalloc(bin_size);
  int oi;
  char msg[2];
  
  /* Get the value of in binary */
  oi = BN_bn2bin(value, buf);
  if (oi != bin_size)
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d",
	  oi, bin_size);

  /* Store the number of bits in the buffer in two bytes, msb first. */
  PUT_16BIT(msg, bits);
  buffer_append(buffer, msg, 2);
  /* Store the binary data. */
  buffer_append(buffer, buf, oi);
  /* Clear the temporary data. */
  memset(buf, 0, bin_size);
  xfree(buf);
d59 2
a60 2
  int bits, bytes;
  unsigned char buf[2], *bin;
d62 10
a71 10
  /* Get the number for bits. */
  buffer_get(buffer, (char *)buf, 2);
  bits = GET_16BIT(buf);
  /* Compute the number of binary bytes that follow. */
  bytes = (bits + 7) / 8;
  if (buffer_len(buffer) < bytes)
    fatal("buffer_get_bignum: input buffer too small");
  bin = buffer_ptr(buffer);
  BN_bin2bn(bin, bytes, value);
  buffer_consume(buffer, bytes);
d73 1
a73 1
  return 2 + bytes;
d78 2
a79 1
unsigned int buffer_get_int(Buffer *buffer)
d81 3
a83 3
  unsigned char buf[4];
  buffer_get(buffer, (char *)buf, 4);
  return GET_32BIT(buf);
d88 2
a89 1
void buffer_put_int(Buffer *buffer, unsigned int value)
d91 3
a93 3
  char buf[4];
  PUT_32BIT(buf, value);
  buffer_append(buffer, buf, 4);
d103 2
a104 1
char *buffer_get_string(Buffer *buffer, unsigned int *length_ptr)
d106 16
a121 16
  unsigned int len;
  char *value;
  /* Get the length. */
  len = buffer_get_int(buffer);
  if (len > 256*1024)
    fatal("Received packet with bad string length %d", len);
  /* Allocate space for the string.  Add one byte for a null character. */
  value = xmalloc(len + 1);
  /* Get the string. */
  buffer_get(buffer, value, len);
  /* Append a null character to make processing easier. */
  value[len] = 0;
  /* Optionally return the length of the string. */
  if (length_ptr)
    *length_ptr = len;
  return value;
d126 2
a127 1
void buffer_put_string(Buffer *buffer, const void *buf, unsigned int len)
d129 2
a130 2
  buffer_put_int(buffer, len);
  buffer_append(buffer, buf, len);
d135 2
a136 1
int buffer_get_char(Buffer *buffer)
d138 3
a140 3
  char ch;
  buffer_get(buffer, &ch, 1);
  return (unsigned char)ch;
d145 2
a146 1
void buffer_put_char(Buffer *buffer, int value)
d148 2
a149 2
  char ch = value;
  buffer_append(buffer, &ch, 1);
@


1.3
log
@replace assert() with error, fatal or packet_disconnect
@
text
@d18 1
a18 1
RCSID("$Id: bufaux.c,v 1.2 1999/09/28 04:45:36 provos Exp $");
d67 3
a69 2
  bin = xmalloc(bytes);
  buffer_get(buffer, bin, bytes);
d71 1
a71 1
  xfree(bin);
@


1.2
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d18 1
a18 1
RCSID("$Id: bufaux.c,v 1.3 1999/06/14 14:41:36 bg Exp $");
d40 3
a42 1
  assert(oi == bin_size);
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d21 1
a21 1
#include "gmp.h"
d26 1
a26 1
/* Stores an MP_INT in the buffer with a 2-byte msb first bit count, followed
d29 2
a30 1
void buffer_put_mp_int(Buffer *buffer, MP_INT *value)
d32 4
a35 4
  int bits = mpz_sizeinbase(value, 2);
  int hex_size = mpz_sizeinbase(value, 16);
  char *buf = xmalloc(hex_size + 2);
  int i, oi, byte;
d38 4
a41 25
  /* Get the value of the number in hex.  Too bad that gmp does not allow
     us to get it in binary. */
  mpz_get_str(buf, 16, value);

  /* i is "input index", oi is "output index".  Both point to the same array,
     and start from the beginning.  "input index" moves twice as fast. */
  i = 0;
  oi = 0;
  /* Check for an odd number of hex digits.  Process the odd digit 
     separately. */
  if (hex_size & 1)
    {
      sscanf(buf, "%1x", &byte);
      buf[oi++] = byte;
      i = 1;
    }

  /* Convert the hex number into binary representation. */
  for (; i < hex_size; i += 2)
    {
      sscanf(buf + i, "%2x", &byte);
      buf[oi++] = byte;
    }
  
  assert(oi == ((bits + 7) / 8));
d48 1
a48 1
  memset(buf, 0, hex_size);
d52 1
a52 1
/* Retrieves an MP_INT from the buffer. */
d54 2
a55 1
int buffer_get_mp_int(Buffer *buffer, MP_INT *value)
d57 2
a58 3
  int i, bits, bytes;
  char *hex;
  unsigned char buf[2];
d65 5
a69 14
  /* Allocate space for a corresponding hex string. */
  hex = xmalloc(2 * bytes + 1);
  
  /* Read and convert the binary bytes into a hex string. */
  for (i = 0; i < bytes; i++)
    {
      unsigned char byte;
      buffer_get(buffer, (char *)&byte, 1);
      sprintf(hex + 2 * i, "%02x", byte);
    }
  /* Read the hex string into a mp-int. */
  mpz_set_str(value, hex, 16);
  /* Free the string. */
  xfree(hex);
@

