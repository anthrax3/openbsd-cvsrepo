head	1.102;
access;
symbols
	OPENBSD_6_1:1.100.0.8
	OPENBSD_6_1_BASE:1.100
	OPENBSD_6_0:1.100.0.6
	OPENBSD_6_0_BASE:1.100
	OPENBSD_5_9:1.100.0.2
	OPENBSD_5_9_BASE:1.100
	OPENBSD_5_8:1.98.0.2
	OPENBSD_5_8_BASE:1.98
	OPENBSD_5_7:1.94.0.2
	OPENBSD_5_7_BASE:1.94
	OPENBSD_5_6:1.93.0.4
	OPENBSD_5_6_BASE:1.93
	OPENBSD_5_5:1.92.0.4
	OPENBSD_5_5_BASE:1.92
	OPENBSD_5_4:1.87.0.2
	OPENBSD_5_4_BASE:1.87
	OPENBSD_5_3:1.86.0.8
	OPENBSD_5_3_BASE:1.86
	OPENBSD_5_2:1.86.0.6
	OPENBSD_5_2_BASE:1.86
	OPENBSD_5_1_BASE:1.86
	OPENBSD_5_1:1.86.0.4
	OPENBSD_5_0:1.86.0.2
	OPENBSD_5_0_BASE:1.86
	OPENBSD_4_9:1.84.0.2
	OPENBSD_4_9_BASE:1.84
	OPENBSD_4_8:1.83.0.2
	OPENBSD_4_8_BASE:1.83
	OPENBSD_4_7:1.82.0.2
	OPENBSD_4_7_BASE:1.82
	OPENBSD_4_6:1.80.0.16
	OPENBSD_4_6_BASE:1.80
	OPENBSD_4_5:1.80.0.12
	OPENBSD_4_5_BASE:1.80
	OPENBSD_4_4:1.80.0.10
	OPENBSD_4_4_BASE:1.80
	OPENBSD_4_3:1.80.0.8
	OPENBSD_4_3_BASE:1.80
	OPENBSD_4_2:1.80.0.6
	OPENBSD_4_2_BASE:1.80
	OPENBSD_4_1:1.80.0.2
	OPENBSD_4_1_BASE:1.80
	OPENBSD_4_0:1.80.0.4
	OPENBSD_4_0_BASE:1.80
	OPENBSD_3_9:1.67.0.2
	OPENBSD_3_9_BASE:1.67
	OPENBSD_3_8:1.66.0.2
	OPENBSD_3_8_BASE:1.66
	OPENBSD_3_7:1.64.0.4
	OPENBSD_3_7_BASE:1.64
	OPENBSD_3_6:1.64.0.2
	OPENBSD_3_6_BASE:1.64
	OPENBSD_3_5:1.63.0.2
	OPENBSD_3_5_BASE:1.63
	OPENBSD_3_4:1.61.0.2
	OPENBSD_3_4_BASE:1.61
	OPENBSD_3_3:1.58.0.2
	OPENBSD_3_3_BASE:1.58
	OPENBSD_3_2:1.57.0.2
	OPENBSD_3_2_BASE:1.57
	OPENBSD_3_1:1.49.0.2
	OPENBSD_3_1_BASE:1.49
	OPENBSD_3_0:1.45.0.2
	OPENBSD_3_0_BASE:1.45
	OPENBSD_2_9_BASE:1.39
	OPENBSD_2_9:1.39.0.2
	OPENBSD_2_8:1.29.0.2
	OPENBSD_2_8_BASE:1.29
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8;
locks; strict;
comment	@ * @;


1.102
date	2017.05.04.06.10.57;	author djm;	state Exp;
branches;
next	1.101;
commitid	RaDUEKyANTovOFHd;

1.101
date	2017.04.30.23.10.43;	author djm;	state Exp;
branches;
next	1.100;
commitid	I15vriCkYNtbTkea;

1.100
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.99;
commitid	K3glY441IowbrjDE;

1.99
date	2015.09.02.07.51.12;	author jsg;	state Exp;
branches;
next	1.98;
commitid	Q6Vkxj42ZGWgteg8;

1.98
date	2015.07.03.03.43.18;	author djm;	state Exp;
branches;
next	1.97;
commitid	cnvu1kGgoFFYv6D3;

1.97
date	2015.03.26.19.32.19;	author markus;	state Exp;
branches;
next	1.96;
commitid	JGYJ8sVvIyk2CQvK;

1.96
date	2015.03.25.19.21.48;	author markus;	state Exp;
branches;
next	1.95;
commitid	R35c6qIVSRFAJTVf;

1.95
date	2015.03.24.20.09.11;	author markus;	state Exp;
branches;
next	1.94;
commitid	ZHICYD2srrA8TFJS;

1.94
date	2015.01.14.20.05.27;	author djm;	state Exp;
branches;
next	1.93;
commitid	YqNUZu0ifI7Q95nk;

1.93
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.92;

1.92
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.91;

1.91
date	2013.12.29.04.29.25;	author djm;	state Exp;
branches;
next	1.90;

1.90
date	2013.12.06.13.39.49;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2013.12.06.13.30.08;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2013.11.08.00.39.14;	author djm;	state Exp;
branches;
next	1.87;

1.87
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2011.07.06.18.09.21;	author tedu;	state Exp;
branches
	1.86.8.1;
next	1.85;

1.85
date	2011.05.15.08.09.01;	author djm;	state Exp;
branches;
next	1.84;

1.84
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.83;

1.83
date	2010.04.16.01.47.26;	author djm;	state Exp;
branches;
next	1.82;

1.82
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.81;

1.81
date	2009.08.27.17.44.52;	author djm;	state Exp;
branches;
next	1.80;

1.80
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.78;

1.78
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.77;

1.77
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.76;

1.76
date	2006.07.09.15.15.10;	author stevesk;	state Exp;
branches;
next	1.75;

1.75
date	2006.07.08.21.47.12;	author stevesk;	state Exp;
branches;
next	1.74;

1.74
date	2006.03.30.09.58.15;	author djm;	state Exp;
branches;
next	1.73;

1.73
date	2006.03.25.18.29.35;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.71;

1.71
date	2006.03.19.18.52.11;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2006.03.17.22.31.50;	author djm;	state Exp;
branches;
next	1.68;

1.68
date	2006.03.17.22.31.11;	author djm;	state Exp;
branches;
next	1.67;

1.67
date	2006.02.20.16.36.14;	author stevesk;	state Exp;
branches
	1.67.2.1;
next	1.66;

1.66
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches
	1.66.2.1;
next	1.65;

1.65
date	2005.05.24.17.32.43;	author avsm;	state Exp;
branches;
next	1.64;

1.64
date	2004.08.11.21.44.31;	author avsm;	state Exp;
branches
	1.64.2.1
	1.64.4.1;
next	1.63;

1.63
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2003.09.18.13.02.21;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.28.16.23.06;	author deraadt;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2003.06.11.11.18.38;	author djm;	state Exp;
branches;
next	1.59;

1.59
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches;
next	1.58;

1.58
date	2003.01.23.13.50.27;	author markus;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2002.09.11.18.27.26;	author stevesk;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2002.06.25.16.22.42;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2002.06.15.01.27.48;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2002.06.15.00.07.38;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2002.06.15.00.01.36;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2002.06.05.21.55.44;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.05.19.57.12;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2002.03.21.22.44.05;	author rees;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2002.02.24.19.14.59;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2002.01.18.18.14.17;	author stevesk;	state Exp;
branches;
next	1.46;

1.46
date	2001.12.05.10.06.12;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2001.09.19.19.35.30;	author stevesk;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2001.08.07.10.37.46;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2001.08.01.22.03.33;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.26.04.59.59;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.23.15.12.17;	author itojun;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.07.20.23.03;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2001.04.05.10.42.48;	author markus;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2001.03.06.00.33.03;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.04.17.42.27;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2001.03.01.02.11.25;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2001.02.04.15.32.22;	author stevesk;	state Exp;
branches;
next	1.34;

1.34
date	2001.02.04.13.30.11;	author stevesk;	state Exp;
branches;
next	1.33;

1.33
date	2001.01.21.19.05.44;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2000.12.20.19.37.21;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.19.23.17.55;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2000.11.12.19.50.37;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.09.21.51.00;	author markus;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2000.09.21.11.07.50;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2000.09.07.20.27.49;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.31.22.09.34;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.19.21.34.42;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2000.08.15.19.20.46;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2000.08.02.06.23.30;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.16.08.27.20;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.26.09.22.29;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.20.01.39.38;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.29.18.11.52;	author markus;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2000.04.14.10.30.29;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2000.04.12.09.39.09;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	99.12.15.19.43.10;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	99.12.06.20.15.26;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.11.24.19.53.44;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	99.11.24.00.26.00;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.11.23.22.25.52;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	99.11.18.11.09.39;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	99.11.16.22.52.55;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.11.15.20.53.24;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	99.10.14.18.17.41;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	99.10.05.22.18.52;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.10.04.20.45.01;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	99.10.03.19.22.38;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.09.30.08.34.24;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.21.14.15;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.04.45.35;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.33;	author deraadt;	state Exp;
branches;
next	;

1.19.2.1
date	2000.09.01.18.23.17;	author jason;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2000.11.08.21.30.25;	author jason;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2001.03.12.15.44.08;	author jason;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2001.03.21.18.52.35;	author jason;	state Exp;
branches;
next	;

1.29.2.1
date	2001.02.16.20.12.54;	author jason;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2001.02.19.17.18.39;	author jason;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2001.03.21.19.46.22;	author jason;	state Exp;
branches;
next	1.29.2.4;

1.29.2.4
date	2001.05.07.21.09.26;	author jason;	state Exp;
branches;
next	1.29.2.5;

1.29.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.29.2.6;

1.29.2.6
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.39.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.39.2.2;

1.39.2.2
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.39.2.3;

1.39.2.3
date	2002.06.02.22.56.09;	author miod;	state Exp;
branches;
next	;

1.45.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.45.2.2;

1.45.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.45.2.3;

1.45.2.3
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.45.2.4;

1.45.2.4
date	2002.06.26.18.22.34;	author miod;	state Exp;
branches;
next	1.45.2.5;

1.45.2.5
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.49.2.1
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.49.2.3;

1.49.2.3
date	2003.04.03.22.35.16;	author miod;	state Exp;
branches;
next	;

1.57.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.57.2.2;

1.57.2.2
date	2003.09.16.21.20.24;	author brad;	state Exp;
branches;
next	;

1.58.2.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.58.2.2;

1.58.2.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.61.2.1
date	2004.02.28.03.51.32;	author brad;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	2004.08.19.22.37.30;	author brad;	state Exp;
branches;
next	;

1.63.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	;

1.64.2.1
date	2005.09.02.03.44.59;	author brad;	state Exp;
branches;
next	;

1.64.4.1
date	2005.09.04.18.39.59;	author brad;	state Exp;
branches;
next	;

1.66.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.67.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;

1.86.8.1
date	2013.11.08.05.52.21;	author djm;	state Exp;
branches;
next	;

1.87.2.1
date	2013.11.08.01.33.56;	author djm;	state Exp;
branches;
next	;


desc
@@


1.102
log
@since a couple of people have asked, leave a comment explaining why we
retain SSH v.1 support in the "delete all keys from agent" path.
@
text
@/* $OpenBSD: authfd.c,v 1.101 2017/04/30 23:10:43 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Functions for connecting the local authentication agent.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 * SSH2 implementation,
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/types.h>
#include <sys/un.h>
#include <sys/socket.h>

#include <fcntl.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include "xmalloc.h"
#include "ssh.h"
#include "rsa.h"
#include "sshbuf.h"
#include "sshkey.h"
#include "authfd.h"
#include "cipher.h"
#include "compat.h"
#include "log.h"
#include "atomicio.h"
#include "misc.h"
#include "ssherr.h"

#define MAX_AGENT_IDENTITIES	2048		/* Max keys in agent reply */
#define MAX_AGENT_REPLY_LEN	(256 * 1024) 	/* Max bytes in agent reply */

/* macro to check for "agent failure" message */
#define agent_failed(x) \
    ((x == SSH_AGENT_FAILURE) || \
    (x == SSH_COM_AGENT2_FAILURE) || \
    (x == SSH2_AGENT_FAILURE))

/* Convert success/failure response from agent to a err.h status */
static int
decode_reply(u_char type)
{
	if (agent_failed(type))
		return SSH_ERR_AGENT_FAILURE;
	else if (type == SSH_AGENT_SUCCESS)
		return 0;
	else
		return SSH_ERR_INVALID_FORMAT;
}

/* Returns the number of the authentication fd, or -1 if there is none. */
int
ssh_get_authentication_socket(int *fdp)
{
	const char *authsocket;
	int sock, oerrno;
	struct sockaddr_un sunaddr;

	if (fdp != NULL)
		*fdp = -1;

	authsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);
	if (!authsocket)
		return SSH_ERR_AGENT_NOT_PRESENT;

	memset(&sunaddr, 0, sizeof(sunaddr));
	sunaddr.sun_family = AF_UNIX;
	strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));

	if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
		return SSH_ERR_SYSTEM_ERROR;

	/* close on exec */
	if (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||
	    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {
		oerrno = errno;
		close(sock);
		errno = oerrno;
		return SSH_ERR_SYSTEM_ERROR;
	}
	if (fdp != NULL)
		*fdp = sock;
	else
		close(sock);
	return 0;
}

/* Communicate with agent: send request and read reply */
static int
ssh_request_reply(int sock, struct sshbuf *request, struct sshbuf *reply)
{
	int r;
	size_t l, len;
	char buf[1024];

	/* Get the length of the message, and format it in the buffer. */
	len = sshbuf_len(request);
	put_u32(buf, len);

	/* Send the length and then the packet to the agent. */
	if (atomicio(vwrite, sock, buf, 4) != 4 ||
	    atomicio(vwrite, sock, (u_char *)sshbuf_ptr(request),
	    sshbuf_len(request)) != sshbuf_len(request))
		return SSH_ERR_AGENT_COMMUNICATION;
	/*
	 * Wait for response from the agent.  First read the length of the
	 * response packet.
	 */
	if (atomicio(read, sock, buf, 4) != 4)
	    return SSH_ERR_AGENT_COMMUNICATION;

	/* Extract the length, and check it for sanity. */
	len = get_u32(buf);
	if (len > MAX_AGENT_REPLY_LEN)
		return SSH_ERR_INVALID_FORMAT;

	/* Read the rest of the response in to the buffer. */
	sshbuf_reset(reply);
	while (len > 0) {
		l = len;
		if (l > sizeof(buf))
			l = sizeof(buf);
		if (atomicio(read, sock, buf, l) != l)
			return SSH_ERR_AGENT_COMMUNICATION;
		if ((r = sshbuf_put(reply, buf, l)) != 0)
			return r;
		len -= l;
	}
	return 0;
}

/*
 * Closes the agent socket if it should be closed (depends on how it was
 * obtained).  The argument must have been returned by
 * ssh_get_authentication_socket().
 */
void
ssh_close_authentication_socket(int sock)
{
	if (getenv(SSH_AUTHSOCKET_ENV_NAME))
		close(sock);
}

/* Lock/unlock agent */
int
ssh_lock_agent(int sock, int lock, const char *password)
{
	int r;
	u_char type = lock ? SSH_AGENTC_LOCK : SSH_AGENTC_UNLOCK;
	struct sshbuf *msg;

	if ((msg = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshbuf_put_u8(msg, type)) != 0 ||
	    (r = sshbuf_put_cstring(msg, password)) != 0)
		goto out;
	if ((r = ssh_request_reply(sock, msg, msg)) != 0)
		goto out;
	if ((r = sshbuf_get_u8(msg, &type)) != 0)
		goto out;
	r = decode_reply(type);
 out:
	sshbuf_free(msg);
	return r;
}


static int
deserialise_identity2(struct sshbuf *ids, struct sshkey **keyp, char **commentp)
{
	int r;
	char *comment = NULL;
	const u_char *blob;
	size_t blen;

	if ((r = sshbuf_get_string_direct(ids, &blob, &blen)) != 0 ||
	    (r = sshbuf_get_cstring(ids, &comment, NULL)) != 0)
		goto out;
	if ((r = sshkey_from_blob(blob, blen, keyp)) != 0)
		goto out;
	if (commentp != NULL) {
		*commentp = comment;
		comment = NULL;
	}
	r = 0;
 out:
	free(comment);
	return r;
}

/*
 * Fetch list of identities held by the agent.
 */
int
ssh_fetch_identitylist(int sock, int version, struct ssh_identitylist **idlp)
{
	u_char type, code1 = 0, code2 = 0;
	u_int32_t num, i;
	struct sshbuf *msg;
	struct ssh_identitylist *idl = NULL;
	int r;

	/* Determine request and expected response types */
	switch (version) {
	case 1:
		code1 = SSH_AGENTC_REQUEST_RSA_IDENTITIES;
		code2 = SSH_AGENT_RSA_IDENTITIES_ANSWER;
		break;
	case 2:
		code1 = SSH2_AGENTC_REQUEST_IDENTITIES;
		code2 = SSH2_AGENT_IDENTITIES_ANSWER;
		break;
	default:
		return SSH_ERR_INVALID_ARGUMENT;
	}

	/*
	 * Send a message to the agent requesting for a list of the
	 * identities it can represent.
	 */
	if ((msg = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshbuf_put_u8(msg, code1)) != 0)
		goto out;

	if ((r = ssh_request_reply(sock, msg, msg)) != 0)
		goto out;

	/* Get message type, and verify that we got a proper answer. */
	if ((r = sshbuf_get_u8(msg, &type)) != 0)
		goto out;
	if (agent_failed(type)) {
		r = SSH_ERR_AGENT_FAILURE;
		goto out;
	} else if (type != code2) {
		r = SSH_ERR_INVALID_FORMAT;
		goto out;
	}

	/* Get the number of entries in the response and check it for sanity. */
	if ((r = sshbuf_get_u32(msg, &num)) != 0)
		goto out;
	if (num > MAX_AGENT_IDENTITIES) {
		r = SSH_ERR_INVALID_FORMAT;
		goto out;
	}
	if (num == 0) {
		r = SSH_ERR_AGENT_NO_IDENTITIES;
		goto out;
	}

	/* Deserialise the response into a list of keys/comments */
	if ((idl = calloc(1, sizeof(*idl))) == NULL ||
	    (idl->keys = calloc(num, sizeof(*idl->keys))) == NULL ||
	    (idl->comments = calloc(num, sizeof(*idl->comments))) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	for (i = 0; i < num;) {
		switch (version) {
		case 1:
			break;
		case 2:
			if ((r = deserialise_identity2(msg,
			    &(idl->keys[i]), &(idl->comments[i]))) != 0) {
				if (r == SSH_ERR_KEY_TYPE_UNKNOWN) {
					/* Gracefully skip unknown key types */
					num--;
					continue;
				} else
					goto out;
			}
			break;
		}
		i++;
	}
	idl->nkeys = num;
	*idlp = idl;
	idl = NULL;
	r = 0;
 out:
	sshbuf_free(msg);
	if (idl != NULL)
		ssh_free_identitylist(idl);
	return r;
}

void
ssh_free_identitylist(struct ssh_identitylist *idl)
{
	size_t i;

	if (idl == NULL)
		return;
	for (i = 0; i < idl->nkeys; i++) {
		if (idl->keys != NULL)
			sshkey_free(idl->keys[i]);
		if (idl->comments != NULL)
			free(idl->comments[i]);
	}
	free(idl);
}

/*
 * Sends a challenge (typically from a server via ssh(1)) to the agent,
 * and waits for a response from the agent.
 * Returns true (non-zero) if the agent gave the correct answer, zero
 * otherwise.
 */


/* encode signature algoritm in flag bits, so we can keep the msg format */
static u_int
agent_encode_alg(struct sshkey *key, const char *alg)
{
	if (alg != NULL && key->type == KEY_RSA) {
		if (strcmp(alg, "rsa-sha2-256") == 0)
			return SSH_AGENT_RSA_SHA2_256;
		else if (strcmp(alg, "rsa-sha2-512") == 0)
			return SSH_AGENT_RSA_SHA2_512;
	}
	return 0;
}

/* ask agent to sign data, returns err.h code on error, 0 on success */
int
ssh_agent_sign(int sock, struct sshkey *key,
    u_char **sigp, size_t *lenp,
    const u_char *data, size_t datalen, const char *alg, u_int compat)
{
	struct sshbuf *msg;
	u_char *blob = NULL, type;
	size_t blen = 0, len = 0;
	u_int flags = 0;
	int r = SSH_ERR_INTERNAL_ERROR;

	*sigp = NULL;
	*lenp = 0;

	if (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)
		return SSH_ERR_INVALID_ARGUMENT;
	if (compat & SSH_BUG_SIGBLOB)
		flags |= SSH_AGENT_OLD_SIGNATURE;
	if ((msg = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshkey_to_blob(key, &blob, &blen)) != 0)
		goto out;
	flags |= agent_encode_alg(key, alg);
	if ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||
	    (r = sshbuf_put_string(msg, blob, blen)) != 0 ||
	    (r = sshbuf_put_string(msg, data, datalen)) != 0 ||
	    (r = sshbuf_put_u32(msg, flags)) != 0)
		goto out;
	if ((r = ssh_request_reply(sock, msg, msg)) != 0)
		goto out;
	if ((r = sshbuf_get_u8(msg, &type)) != 0)
		goto out;
	if (agent_failed(type)) {
		r = SSH_ERR_AGENT_FAILURE;
		goto out;
	} else if (type != SSH2_AGENT_SIGN_RESPONSE) {
		r = SSH_ERR_INVALID_FORMAT;
		goto out;
	}
	if ((r = sshbuf_get_string(msg, sigp, &len)) != 0)
		goto out;
	*lenp = len;
	r = 0;
 out:
	if (blob != NULL) {
		explicit_bzero(blob, blen);
		free(blob);
	}
	sshbuf_free(msg);
	return r;
}

/* Encode key for a message to the agent. */


static int
ssh_encode_identity_ssh2(struct sshbuf *b, struct sshkey *key,
    const char *comment)
{
	int r;

	if ((r = sshkey_private_serialize(key, b)) != 0 ||
	    (r = sshbuf_put_cstring(b, comment)) != 0)
		return r;
	return 0;
}

static int
encode_constraints(struct sshbuf *m, u_int life, u_int confirm)
{
	int r;

	if (life != 0) {
		if ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_LIFETIME)) != 0 ||
		    (r = sshbuf_put_u32(m, life)) != 0)
			goto out;
	}
	if (confirm != 0) {
		if ((r = sshbuf_put_u8(m, SSH_AGENT_CONSTRAIN_CONFIRM)) != 0)
			goto out;
	}
	r = 0;
 out:
	return r;
}

/*
 * Adds an identity to the authentication server.
 * This call is intended only for use by ssh-add(1) and like applications.
 */
int
ssh_add_identity_constrained(int sock, struct sshkey *key, const char *comment,
    u_int life, u_int confirm)
{
	struct sshbuf *msg;
	int r, constrained = (life || confirm);
	u_char type;

	if ((msg = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;

	switch (key->type) {
#ifdef WITH_OPENSSL
	case KEY_RSA:
	case KEY_RSA_CERT:
	case KEY_DSA:
	case KEY_DSA_CERT:
	case KEY_ECDSA:
	case KEY_ECDSA_CERT:
#endif
	case KEY_ED25519:
	case KEY_ED25519_CERT:
		type = constrained ?
		    SSH2_AGENTC_ADD_ID_CONSTRAINED :
		    SSH2_AGENTC_ADD_IDENTITY;
		if ((r = sshbuf_put_u8(msg, type)) != 0 ||
		    (r = ssh_encode_identity_ssh2(msg, key, comment)) != 0)
			goto out;
		break;
	default:
		r = SSH_ERR_INVALID_ARGUMENT;
		goto out;
	}
	if (constrained &&
	    (r = encode_constraints(msg, life, confirm)) != 0)
		goto out;
	if ((r = ssh_request_reply(sock, msg, msg)) != 0)
		goto out;
	if ((r = sshbuf_get_u8(msg, &type)) != 0)
		goto out;
	r = decode_reply(type);
 out:
	sshbuf_free(msg);
	return r;
}

/*
 * Removes an identity from the authentication server.
 * This call is intended only for use by ssh-add(1) and like applications.
 */
int
ssh_remove_identity(int sock, struct sshkey *key)
{
	struct sshbuf *msg;
	int r;
	u_char type, *blob = NULL;
	size_t blen;

	if ((msg = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;

	if (key->type != KEY_UNSPEC) {
		if ((r = sshkey_to_blob(key, &blob, &blen)) != 0)
			goto out;
		if ((r = sshbuf_put_u8(msg,
		    SSH2_AGENTC_REMOVE_IDENTITY)) != 0 ||
		    (r = sshbuf_put_string(msg, blob, blen)) != 0)
			goto out;
	} else {
		r = SSH_ERR_INVALID_ARGUMENT;
		goto out;
	}
	if ((r = ssh_request_reply(sock, msg, msg)) != 0)
		goto out;
	if ((r = sshbuf_get_u8(msg, &type)) != 0)
		goto out;
	r = decode_reply(type);
 out:
	if (blob != NULL) {
		explicit_bzero(blob, blen);
		free(blob);
	}
	sshbuf_free(msg);
	return r;
}

/*
 * Add/remove an token-based identity from the authentication server.
 * This call is intended only for use by ssh-add(1) and like applications.
 */
int
ssh_update_card(int sock, int add, const char *reader_id, const char *pin,
    u_int life, u_int confirm)
{
	struct sshbuf *msg;
	int r, constrained = (life || confirm);
	u_char type;

	if (add) {
		type = constrained ?
		    SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED :
		    SSH_AGENTC_ADD_SMARTCARD_KEY;
	} else
		type = SSH_AGENTC_REMOVE_SMARTCARD_KEY;

	if ((msg = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshbuf_put_u8(msg, type)) != 0 ||
	    (r = sshbuf_put_cstring(msg, reader_id)) != 0 ||
	    (r = sshbuf_put_cstring(msg, pin)) != 0)
		goto out;
	if (constrained &&
	    (r = encode_constraints(msg, life, confirm)) != 0)
		goto out;
	if ((r = ssh_request_reply(sock, msg, msg)) != 0)
		goto out;
	if ((r = sshbuf_get_u8(msg, &type)) != 0)
		goto out;
	r = decode_reply(type);
 out:
	sshbuf_free(msg);
	return r;
}

/*
 * Removes all identities from the agent.
 * This call is intended only for use by ssh-add(1) and like applications.
 *
 * This supports the SSH protocol 1 message to because, when clearing all
 * keys from an agent, we generally want to clear both protocol v1 and v2
 * keys.
 */
int
ssh_remove_all_identities(int sock, int version)
{
	struct sshbuf *msg;
	u_char type = (version == 1) ?
	    SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES :
	    SSH2_AGENTC_REMOVE_ALL_IDENTITIES;
	int r;

	if ((msg = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshbuf_put_u8(msg, type)) != 0)
		goto out;
	if ((r = ssh_request_reply(sock, msg, msg)) != 0)
		goto out;
	if ((r = sshbuf_get_u8(msg, &type)) != 0)
		goto out;
	r = decode_reply(type);
 out:
	sshbuf_free(msg);
	return r;
}
@


1.101
log
@unifdef WITH_SSH1
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.100 2015/12/04 16:41:28 markus Exp $ */
d576 4
@


1.100
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.99 2015/09/02 07:51:12 jsg Exp $ */
a199 37
#ifdef WITH_SSH1
static int
deserialise_identity1(struct sshbuf *ids, struct sshkey **keyp, char **commentp)
{
	struct sshkey *key;
	int r, keybits;
	u_int32_t bits;
	char *comment = NULL;

	if ((key = sshkey_new(KEY_RSA1)) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshbuf_get_u32(ids, &bits)) != 0 ||
	    (r = sshbuf_get_bignum1(ids, key->rsa->e)) != 0 ||
	    (r = sshbuf_get_bignum1(ids, key->rsa->n)) != 0 ||
	    (r = sshbuf_get_cstring(ids, &comment, NULL)) != 0)
		goto out;
	keybits = BN_num_bits(key->rsa->n);
	/* XXX previously we just warned here. I think we should be strict */
	if (keybits < 0 || bits != (u_int)keybits) {
		r = SSH_ERR_KEY_BITS_MISMATCH;
		goto out;
	}
	if (keyp != NULL) {
		*keyp = key;
		key = NULL;
	}
	if (commentp != NULL) {
		*commentp = comment;
		comment = NULL;
	}
	r = 0;
 out:
	sshkey_free(key);
	free(comment);
	return r;
}
#endif
a294 5
#ifdef WITH_SSH1
			if ((r = deserialise_identity1(msg,
			    &(idl->keys[i]), &(idl->comments[i]))) != 0)
				goto out;
#endif
a343 40
#ifdef WITH_SSH1
int
ssh_decrypt_challenge(int sock, struct sshkey* key, BIGNUM *challenge,
    u_char session_id[16], u_char response[16])
{
	struct sshbuf *msg;
	int r;
	u_char type;

	if (key->type != KEY_RSA1)
		return SSH_ERR_INVALID_ARGUMENT;
	if ((msg = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshbuf_put_u8(msg, SSH_AGENTC_RSA_CHALLENGE)) != 0 ||
	    (r = sshbuf_put_u32(msg, BN_num_bits(key->rsa->n))) != 0 ||
	    (r = sshbuf_put_bignum1(msg, key->rsa->e)) != 0 ||
	    (r = sshbuf_put_bignum1(msg, key->rsa->n)) != 0 ||
	    (r = sshbuf_put_bignum1(msg, challenge)) != 0 ||
	    (r = sshbuf_put(msg, session_id, 16)) != 0 ||
	    (r = sshbuf_put_u32(msg, 1)) != 0) /* Response type for proto 1.1 */
		goto out;
	if ((r = ssh_request_reply(sock, msg, msg)) != 0)
		goto out;
	if ((r = sshbuf_get_u8(msg, &type)) != 0)
		goto out;
	if (agent_failed(type)) {
		r = SSH_ERR_AGENT_FAILURE;
		goto out;
	} else if (type != SSH_AGENT_RSA_RESPONSE) {
		r = SSH_ERR_INVALID_FORMAT;
		goto out;
	}
	if ((r = sshbuf_get(msg, response, 16)) != 0)
		goto out;
	r = 0;
 out:
	sshbuf_free(msg);
	return r;
}
#endif
a412 19
#ifdef WITH_SSH1
static int
ssh_encode_identity_rsa1(struct sshbuf *b, RSA *key, const char *comment)
{
	int r;

	/* To keep within the protocol: p < q for ssh. in SSL p > q */
	if ((r = sshbuf_put_u32(b, BN_num_bits(key->n))) != 0 ||
	    (r = sshbuf_put_bignum1(b, key->n)) != 0 ||
	    (r = sshbuf_put_bignum1(b, key->e)) != 0 ||
	    (r = sshbuf_put_bignum1(b, key->d)) != 0 ||
	    (r = sshbuf_put_bignum1(b, key->iqmp)) != 0 ||
	    (r = sshbuf_put_bignum1(b, key->q)) != 0 ||
	    (r = sshbuf_put_bignum1(b, key->p)) != 0 ||
	    (r = sshbuf_put_cstring(b, comment)) != 0)
		return r;
	return 0;
}
#endif
a460 10
#ifdef WITH_SSH1
	case KEY_RSA1:
		type = constrained ?
		    SSH_AGENTC_ADD_RSA_ID_CONSTRAINED :
		    SSH_AGENTC_ADD_RSA_IDENTITY;
		if ((r = sshbuf_put_u8(msg, type)) != 0 ||
		    (r = ssh_encode_identity_rsa1(msg, key->rsa, comment)) != 0)
			goto out;
		break;
#endif
a509 10
#ifdef WITH_SSH1
	if (key->type == KEY_RSA1) {
		if ((r = sshbuf_put_u8(msg,
		    SSH_AGENTC_REMOVE_RSA_IDENTITY)) != 0 ||
		    (r = sshbuf_put_u32(msg, BN_num_bits(key->rsa->n))) != 0 ||
		    (r = sshbuf_put_bignum1(msg, key->rsa->e)) != 0 ||
		    (r = sshbuf_put_bignum1(msg, key->rsa->n)) != 0)
			goto out;
	} else
#endif
@


1.99
log
@Fix occurrences of "r = func() != 0" which result in the wrong error
codes being returned due to != having higher precedence than =.

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.98 2015/07/03 03:43:18 djm Exp $ */
d427 13
d444 1
a444 1
    const u_char *data, size_t datalen, u_int compat)
d463 1
@


1.98
log
@delete support for legacy v00 certificates; "sure" markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.97 2015/03/26 19:32:19 markus Exp $ */
d455 1
a455 1
	if ((r = ssh_request_reply(sock, msg, msg) != 0))
@


1.97
log
@sigp and lenp are not optional in ssh_agent_sign(); ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.96 2015/03/25 19:21:48 markus Exp $ */
a560 1
	case KEY_RSA_CERT_V00:
a562 1
	case KEY_DSA_CERT_V00:
@


1.96
log
@unbreak ssh_agent_sign (lenp vs *lenp)
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.95 2015/03/24 20:09:11 markus Exp $ */
d439 2
a440 4
	if (sigp != NULL)
		*sigp = NULL;
	if (lenp != NULL)
		*lenp = 0;
d468 1
a468 2
	if (lenp != NULL)
		*lenp = len;
@


1.95
log
@consistent check for NULL as noted by Nicholas Lemonias; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.94 2015/01/14 20:05:27 djm Exp $ */
d470 1
a470 1
	if (*lenp != NULL)
@


1.94
log
@move authfd.c and its tentacles to the new buffer/key API;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.93 2014/04/29 18:01:49 markus Exp $ */
d470 2
a471 1
	*lenp = len;
@


1.93
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.92 2014/01/31 16:39:19 tedu Exp $ */
d48 1
d53 2
a54 2
#include "buffer.h"
#include "key.h"
a56 1
#include "kex.h"
d61 1
d63 2
a64 4
static int agent_present = 0;

/* helper */
int	decode_reply(int type);
d68 2
a69 1
    ((x == SSH_AGENT_FAILURE) || (x == SSH_COM_AGENT2_FAILURE) || \
d72 3
a74 2
int
ssh_agent_present(void)
d76 3
a78 5
	int authfd;

	if (agent_present)
		return 1;
	if ((authfd = ssh_get_authentication_socket()) == -1)
d80 2
a81 4
	else {
		ssh_close_authentication_socket(authfd);
		return 1;
	}
a84 1

d86 1
a86 1
ssh_get_authentication_socket(void)
d89 1
a89 1
	int sock;
d92 3
d97 1
a97 1
		return -1;
d103 2
a104 3
	sock = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sock < 0)
		return -1;
d107 3
a109 1
	if (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1) {
d111 2
a112 1
		return -1;
d114 3
a116 1
	if (connect(sock, (struct sockaddr *)&sunaddr, sizeof sunaddr) < 0) {
d118 1
a118 4
		return -1;
	}
	agent_present = 1;
	return sock;
d121 1
d123 1
a123 1
ssh_request_reply(AuthenticationConnection *auth, Buffer *request, Buffer *reply)
d125 2
a126 1
	u_int l, len;
d130 1
a130 1
	len = buffer_len(request);
d134 4
a137 6
	if (atomicio(vwrite, auth->fd, buf, 4) != 4 ||
	    atomicio(vwrite, auth->fd, buffer_ptr(request),
	    buffer_len(request)) != buffer_len(request)) {
		error("Error writing to authentication socket.");
		return 0;
	}
d142 2
a143 4
	if (atomicio(read, auth->fd, buf, 4) != 4) {
	    error("Error reading response length from authentication socket.");
	    return 0;
	}
d147 2
a148 2
	if (len > 256 * 1024)
		fatal("Authentication response too long: %u", len);
d151 1
a151 1
	buffer_clear(reply);
d156 4
a159 5
		if (atomicio(read, auth->fd, buf, l) != l) {
			error("Error reading response from authentication socket.");
			return 0;
		}
		buffer_append(reply, buf, l);
d162 1
a162 1
	return 1;
a169 1

d177 3
a179 10
/*
 * Opens and connects a private socket for communication with the
 * authentication agent.  Returns the file descriptor (which must be
 * shut down and closed by the caller when no longer needed).
 * Returns NULL if an error occurred and the connection could not be
 * opened.
 */

AuthenticationConnection *
ssh_get_authentication_connection(void)
d181 17
a197 18
	AuthenticationConnection *auth;
	int sock;

	sock = ssh_get_authentication_socket();

	/*
	 * Fail if we couldn't obtain a connection.  This happens if we
	 * exited due to a timeout.
	 */
	if (sock < 0)
		return NULL;

	auth = xcalloc(1, sizeof(*auth));
	auth->fd = sock;
	buffer_init(&auth->identities);
	auth->howmany = 0;

	return auth;
d200 3
a202 7
/*
 * Closes the connection to the authentication agent and frees any associated
 * memory.
 */

void
ssh_close_authentication_connection(AuthenticationConnection *auth)
d204 31
a234 3
	buffer_free(&auth->identities);
	close(auth->fd);
	free(auth);
d236 1
d238 2
a239 3
/* Lock/unlock agent */
int
ssh_lock_agent(AuthenticationConnection *auth, int lock, const char *password)
d241 18
a258 14
	int type;
	Buffer msg;

	buffer_init(&msg);
	buffer_put_char(&msg, lock ? SSH_AGENTC_LOCK : SSH_AGENTC_UNLOCK);
	buffer_put_cstring(&msg, password);

	if (ssh_request_reply(auth, &msg, &msg) == 0) {
		buffer_free(&msg);
		return 0;
	}
	type = buffer_get_char(&msg);
	buffer_free(&msg);
	return decode_reply(type);
d262 1
a262 1
 * Returns the first authentication identity held by the agent.
a263 1

d265 1
a265 1
ssh_get_num_identities(AuthenticationConnection *auth, int version)
d267 5
a271 2
	int type, code1 = 0, code2 = 0;
	Buffer request;
d273 1
d284 1
a284 1
		return 0;
d291 4
a294 2
	buffer_init(&request);
	buffer_put_char(&request, code1);
d296 2
a297 6
	buffer_clear(&auth->identities);
	if (ssh_request_reply(auth, &request, &auth->identities) == 0) {
		buffer_free(&request);
		return 0;
	}
	buffer_free(&request);
d300 2
a301 1
	type = buffer_get_char(&auth->identities);
d303 2
a304 1
		return 0;
d306 2
a307 1
		fatal("Bad authentication reply message type: %d", type);
d311 50
a360 6
	auth->howmany = buffer_get_int(&auth->identities);
	if ((u_int)auth->howmany > 1024)
		fatal("Too many identities in authentication reply: %d",
		    auth->howmany);

	return auth->howmany;
d363 2
a364 2
Key *
ssh_get_first_identity(AuthenticationConnection *auth, char **comment, int version)
d366 1
a366 5
	/* get number of identities and return the first entry (if any). */
	if (ssh_get_num_identities(auth, version) > 0)
		return ssh_get_next_identity(auth, comment, version);
	return NULL;
}
d368 7
a374 41
Key *
ssh_get_next_identity(AuthenticationConnection *auth, char **comment, int version)
{
#ifdef WITH_SSH1
	int keybits;
	u_int bits;
#endif
	u_char *blob;
	u_int blen;
	Key *key = NULL;

	/* Return failure if no more entries. */
	if (auth->howmany <= 0)
		return NULL;

	/*
	 * Get the next entry from the packet.  These will abort with a fatal
	 * error if the packet is too short or contains corrupt data.
	 */
	switch (version) {
#ifdef WITH_SSH1
	case 1:
		key = key_new(KEY_RSA1);
		bits = buffer_get_int(&auth->identities);
		buffer_get_bignum(&auth->identities, key->rsa->e);
		buffer_get_bignum(&auth->identities, key->rsa->n);
		*comment = buffer_get_string(&auth->identities, NULL);
		keybits = BN_num_bits(key->rsa->n);
		if (keybits < 0 || bits != (u_int)keybits)
			logit("Warning: identity keysize mismatch: actual %d, announced %u",
			    BN_num_bits(key->rsa->n), bits);
		break;
#endif
	case 2:
		blob = buffer_get_string(&auth->identities, &blen);
		*comment = buffer_get_string(&auth->identities, NULL);
		key = key_from_blob(blob, blen);
		free(blob);
		break;
	default:
		return NULL;
d376 1
a376 3
	/* Decrement the number of remaining entries. */
	auth->howmany--;
	return key;
d380 4
a383 5
 * Generates a random challenge, sends it to the agent, and waits for
 * response from the agent.  Returns true (non-zero) if the agent gave the
 * correct answer, zero otherwise.  Response type selects the style of
 * response desired, with 0 corresponding to protocol version 1.0 (no longer
 * supported) and 1 corresponding to protocol version 1.1.
d388 6
a393 10
ssh_decrypt_challenge(AuthenticationConnection *auth,
    Key* key, BIGNUM *challenge,
    u_char session_id[16],
    u_int response_type,
    u_char response[16])
{
	Buffer buffer;
	int success = 0;
	int i;
	int type;
d396 15
a410 20
		return 0;
	if (response_type == 0) {
		logit("Compatibility with ssh protocol version 1.0 no longer supported.");
		return 0;
	}
	buffer_init(&buffer);
	buffer_put_char(&buffer, SSH_AGENTC_RSA_CHALLENGE);
	buffer_put_int(&buffer, BN_num_bits(key->rsa->n));
	buffer_put_bignum(&buffer, key->rsa->e);
	buffer_put_bignum(&buffer, key->rsa->n);
	buffer_put_bignum(&buffer, challenge);
	buffer_append(&buffer, session_id, 16);
	buffer_put_int(&buffer, response_type);

	if (ssh_request_reply(auth, &buffer, &buffer) == 0) {
		buffer_free(&buffer);
		return 0;
	}
	type = buffer_get_char(&buffer);

d412 2
a413 1
		logit("Agent admitted failure to authenticate using the key.");
d415 2
a416 9
		fatal("Bad authentication response: %d", type);
	} else {
		success = 1;
		/*
		 * Get the response from the packet.  This will abort with a
		 * fatal error if the packet is corrupt.
		 */
		for (i = 0; i < 16; i++)
			response[i] = (u_char)buffer_get_char(&buffer);
d418 6
a423 2
	buffer_free(&buffer);
	return success;
d427 1
a427 1
/* ask agent to sign data, returns -1 on error, 0 on success */
d429 32
a460 30
ssh_agent_sign(AuthenticationConnection *auth,
    Key *key,
    u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
{
	extern int datafellows;
	Buffer msg;
	u_char *blob;
	u_int blen;
	int type, flags = 0;
	int ret = -1;

	if (key_to_blob(key, &blob, &blen) == 0)
		return -1;

	if (datafellows & SSH_BUG_SIGBLOB)
		flags = SSH_AGENT_OLD_SIGNATURE;

	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_AGENTC_SIGN_REQUEST);
	buffer_put_string(&msg, blob, blen);
	buffer_put_string(&msg, data, datalen);
	buffer_put_int(&msg, flags);
	free(blob);

	if (ssh_request_reply(auth, &msg, &msg) == 0) {
		buffer_free(&msg);
		return -1;
	}
	type = buffer_get_char(&msg);
d462 2
a463 1
		logit("Agent admitted failure to sign using the key.");
d465 11
a475 4
		fatal("Bad authentication response: %d", type);
	} else {
		ret = 0;
		*sigp = buffer_get_string(&msg, lenp);
d477 2
a478 2
	buffer_free(&msg);
	return ret;
d484 2
a485 2
static void
ssh_encode_identity_rsa1(Buffer *b, RSA *key, const char *comment)
d487 2
a488 4
	buffer_put_int(b, BN_num_bits(key->n));
	buffer_put_bignum(b, key->n);
	buffer_put_bignum(b, key->e);
	buffer_put_bignum(b, key->d);
d490 10
a499 4
	buffer_put_bignum(b, key->iqmp);	/* ssh key->u */
	buffer_put_bignum(b, key->q);	/* ssh key->p, SSL key->q */
	buffer_put_bignum(b, key->p);	/* ssh key->q, SSL key->p */
	buffer_put_cstring(b, comment);
d503 3
a505 2
static void
ssh_encode_identity_ssh2(Buffer *b, Key *key, const char *comment)
d507 25
a531 2
	key_private_serialize(key, b);
	buffer_put_cstring(b, comment);
d535 2
a536 2
 * Adds an identity to the authentication server.  This call is not meant to
 * be used by normal applications.
a537 1

d539 2
a540 2
ssh_add_identity_constrained(AuthenticationConnection *auth, Key *key,
    const char *comment, u_int life, u_int confirm)
d542 3
a544 2
	Buffer msg;
	int type, constrained = (life || confirm);
d546 2
a547 1
	buffer_init(&msg);
d555 3
a557 2
		buffer_put_char(&msg, type);
		ssh_encode_identity_rsa1(&msg, key->rsa, comment);
d575 3
a577 2
		buffer_put_char(&msg, type);
		ssh_encode_identity_ssh2(&msg, key, comment);
d580 2
a581 14
		buffer_free(&msg);
		return 0;
	}
	if (constrained) {
		if (life != 0) {
			buffer_put_char(&msg, SSH_AGENT_CONSTRAIN_LIFETIME);
			buffer_put_int(&msg, life);
		}
		if (confirm != 0)
			buffer_put_char(&msg, SSH_AGENT_CONSTRAIN_CONFIRM);
	}
	if (ssh_request_reply(auth, &msg, &msg) == 0) {
		buffer_free(&msg);
		return 0;
d583 11
a593 3
	type = buffer_get_char(&msg);
	buffer_free(&msg);
	return decode_reply(type);
d597 2
a598 2
 * Removes an identity from the authentication server.  This call is not
 * meant to be used by normal applications.
a599 1

d601 1
a601 1
ssh_remove_identity(AuthenticationConnection *auth, Key *key)
d603 4
a606 4
	Buffer msg;
	int type;
	u_char *blob;
	u_int blen;
d608 2
a609 1
	buffer_init(&msg);
d613 6
a618 4
		buffer_put_char(&msg, SSH_AGENTC_REMOVE_RSA_IDENTITY);
		buffer_put_int(&msg, BN_num_bits(key->rsa->n));
		buffer_put_bignum(&msg, key->rsa->e);
		buffer_put_bignum(&msg, key->rsa->n);
d622 6
a627 4
		key_to_blob(key, &blob, &blen);
		buffer_put_char(&msg, SSH2_AGENTC_REMOVE_IDENTITY);
		buffer_put_string(&msg, blob, blen);
		free(blob);
d629 2
a630 2
		buffer_free(&msg);
		return 0;
d632 9
a640 3
	if (ssh_request_reply(auth, &msg, &msg) == 0) {
		buffer_free(&msg);
		return 0;
d642 2
a643 3
	type = buffer_get_char(&msg);
	buffer_free(&msg);
	return decode_reply(type);
d646 4
d651 2
a652 2
ssh_update_card(AuthenticationConnection *auth, int add,
    const char *reader_id, const char *pin, u_int life, u_int confirm)
d654 3
a656 2
	Buffer msg;
	int type, constrained = (life || confirm);
d665 17
a681 21
	buffer_init(&msg);
	buffer_put_char(&msg, type);
	buffer_put_cstring(&msg, reader_id);
	buffer_put_cstring(&msg, pin);

	if (constrained) {
		if (life != 0) {
			buffer_put_char(&msg, SSH_AGENT_CONSTRAIN_LIFETIME);
			buffer_put_int(&msg, life);
		}
		if (confirm != 0)
			buffer_put_char(&msg, SSH_AGENT_CONSTRAIN_CONFIRM);
	}

	if (ssh_request_reply(auth, &msg, &msg) == 0) {
		buffer_free(&msg);
		return 0;
	}
	type = buffer_get_char(&msg);
	buffer_free(&msg);
	return decode_reply(type);
d685 2
a686 2
 * Removes all identities from the agent.  This call is not meant to be used
 * by normal applications.
a687 1

d689 1
a689 1
ssh_remove_all_identities(AuthenticationConnection *auth, int version)
d691 18
a708 34
	Buffer msg;
	int type;
	int code = (version==1) ?
		SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES :
		SSH2_AGENTC_REMOVE_ALL_IDENTITIES;

	buffer_init(&msg);
	buffer_put_char(&msg, code);

	if (ssh_request_reply(auth, &msg, &msg) == 0) {
		buffer_free(&msg);
		return 0;
	}
	type = buffer_get_char(&msg);
	buffer_free(&msg);
	return decode_reply(type);
}

int
decode_reply(int type)
{
	switch (type) {
	case SSH_AGENT_FAILURE:
	case SSH_COM_AGENT2_FAILURE:
	case SSH2_AGENT_FAILURE:
		logit("SSH_AGENT_FAILURE");
		return 0;
	case SSH_AGENT_SUCCESS:
		return 1;
	default:
		fatal("Bad response from authentication agent: %d", type);
	}
	/* NOTREACHED */
	return 0;
@


1.92
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.91 2013/12/29 04:29:25 djm Exp $ */
a42 3
#include <openssl/evp.h>
#include <openssl/crypto.h>

d311 1
d314 1
d328 1
d340 1
d363 1
d413 1
d461 1
d475 1
d499 1
d507 2
d517 1
d562 1
d568 3
a570 1
	} else if (key->type != KEY_UNSPEC) {
@


1.91
log
@allow deletion of ed25519 keys from the agent
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.90 2013/12/06 13:39:49 markus Exp $ */
d103 1
a103 1
	bzero(&sunaddr, sizeof(sunaddr));
@


1.90
log
@support ed25519 keys (hostkeys and user identities) using the public domain
ed25519 reference code from SUPERCOP, see http://ed25519.cr.yp.to/software.html
feedback, help & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.89 2013/12/06 13:30:08 markus Exp $ */
d558 1
a558 3
	} else if (key_type_plain(key->type) == KEY_DSA ||
	    key_type_plain(key->type) == KEY_RSA ||
	    key_type_plain(key->type) == KEY_ECDSA) {
@


1.89
log
@move private key (de)serialization to key.c; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.88 2013/11/08 00:39:14 djm Exp $ */
d509 2
@


1.88
log
@use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.87 2013/05/17 00:13:13 djm Exp $ */
d44 1
a45 1
#include <openssl/crypto.h>
d475 1
a475 50
	buffer_put_cstring(b, key_ssh_name(key));
	switch (key->type) {
	case KEY_RSA:
		buffer_put_bignum2(b, key->rsa->n);
		buffer_put_bignum2(b, key->rsa->e);
		buffer_put_bignum2(b, key->rsa->d);
		buffer_put_bignum2(b, key->rsa->iqmp);
		buffer_put_bignum2(b, key->rsa->p);
		buffer_put_bignum2(b, key->rsa->q);
		break;
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
		if (key->cert == NULL || buffer_len(&key->cert->certblob) == 0)
			fatal("%s: no cert/certblob", __func__);
		buffer_put_string(b, buffer_ptr(&key->cert->certblob),
		    buffer_len(&key->cert->certblob));
		buffer_put_bignum2(b, key->rsa->d);
		buffer_put_bignum2(b, key->rsa->iqmp);
		buffer_put_bignum2(b, key->rsa->p);
		buffer_put_bignum2(b, key->rsa->q);
		break;
	case KEY_DSA:
		buffer_put_bignum2(b, key->dsa->p);
		buffer_put_bignum2(b, key->dsa->q);
		buffer_put_bignum2(b, key->dsa->g);
		buffer_put_bignum2(b, key->dsa->pub_key);
		buffer_put_bignum2(b, key->dsa->priv_key);
		break;
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
		if (key->cert == NULL || buffer_len(&key->cert->certblob) == 0)
			fatal("%s: no cert/certblob", __func__);
		buffer_put_string(b, buffer_ptr(&key->cert->certblob),
		    buffer_len(&key->cert->certblob));
		buffer_put_bignum2(b, key->dsa->priv_key);
		break;
	case KEY_ECDSA:
		buffer_put_cstring(b, key_curve_nid_to_name(key->ecdsa_nid));
		buffer_put_ecpoint(b, EC_KEY_get0_group(key->ecdsa),
		    EC_KEY_get0_public_key(key->ecdsa));
		buffer_put_bignum2(b, EC_KEY_get0_private_key(key->ecdsa));
		break;
	case KEY_ECDSA_CERT:
		if (key->cert == NULL || buffer_len(&key->cert->certblob) == 0)
			fatal("%s: no cert/certblob", __func__);
		buffer_put_string(b, buffer_ptr(&key->cert->certblob),
		    buffer_len(&key->cert->certblob));
		buffer_put_bignum2(b, EC_KEY_get0_private_key(key->ecdsa));
		break;
	}
@


1.87
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.86 2011/07/06 18:09:21 tedu Exp $ */
d207 1
a207 1
	auth = xmalloc(sizeof(*auth));
@


1.87.2.1
log
@cherrypick commit:

date: 2013/11/08 00:39:15;  author: djm;  state: Exp;  lines: +2 -2;
use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.87 2013/05/17 00:13:13 djm Exp $ */
d207 1
a207 1
	auth = xcalloc(1, sizeof(*auth));
@


1.86
log
@bzero the agent address.  the kernel was for a while very cranky about
these things.  evne though that's fixed, always good to initialize
memory.  ok deraadt djm
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.85 2011/05/15 08:09:01 djm Exp $ */
d225 1
a225 1
	xfree(auth);
d344 1
a344 1
		xfree(blob);
d437 1
a437 1
	xfree(blob);
d611 1
a611 1
		xfree(blob);
@


1.86.8.1
log
@openssh-6.4 for the 5.3 branch; reminded by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.87.2.1 2013/11/08 01:33:56 djm Exp $ */
d207 1
a207 1
	auth = xcalloc(1, sizeof(*auth));
@


1.85
log
@use FD_CLOEXEC consistently; patch from zion AT x96.org
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.84 2010/08/31 11:54:45 djm Exp $ */
d103 1
@


1.84
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.83 2010/04/16 01:47:26 djm Exp $ */
d111 1
a111 1
	if (fcntl(sock, F_SETFD, 1) == -1) {
@


1.83
log
@revised certificate format ssh-{dss,rsa}-cert-v01@@openssh.com with the
following changes:

move the nonce field to the beginning of the certificate where it can
better protect against chosen-prefix attacks on the signature hash

Rename "constraints" field to "critical options"

Add a new non-critical "extensions" field

Add a serial number

The older format is still support for authentication and cert generation
(use "ssh-keygen -t v00 -s ca_key ..." to generate a v00 certificate)

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.82 2010/02/26 20:29:54 djm Exp $ */
d510 13
d555 2
d605 2
a606 1
	    key_type_plain(key->type) == KEY_RSA) {
@


1.82
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.81 2009/08/27 17:44:52 djm Exp $ */
d484 1
d502 1
d538 1
d541 1
@


1.81
log
@Do not fall back to adding keys without contraints (ssh-add -c / -t ...)
when the agent refuses the constrained add request. This was a useful
migration measure back in 2002 when constraints were new, but just
adds risk now.

bz #1612, report and patch from dkg AT fifthhorseman.net; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.80 2006/08/03 03:34:41 deraadt Exp $ */
d484 10
d501 7
d535 1
d537 1
d585 2
a586 1
	} else if (key->type == KEY_DSA || key->type == KEY_RSA) {
@


1.80
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.79 2006/07/26 13:57:17 stevesk Exp $ */
a543 6
}

int
ssh_add_identity(AuthenticationConnection *auth, Key *key, const char *comment)
{
	return ssh_add_identity_constrained(auth, key, comment, 0, 0);
@


1.79
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.78 2006/07/22 20:48:22 stevesk Exp $ */
a37 1
#include "includes.h"
d45 1
d48 1
d52 1
a55 2
#include "bufaux.h"
#include "xmalloc.h"
@


1.78
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.77 2006/07/17 01:31:09 stevesk Exp $ */
d47 1
@


1.77
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.76 2006/07/09 15:15:10 stevesk Exp $ */
d47 1
@


1.76
log
@move #include <fcntl.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.75 2006/07/08 21:47:12 stevesk Exp $ */
d47 1
@


1.75
log
@move #include <sys/socket.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.74 2006/03/30 09:58:15 djm Exp $ */
d45 2
@


1.74
log
@replace {GET,PUT}_XXBIT macros with functionally similar functions,
silencing a heap of lint warnings. also allows them to use
__bounded__ checking which can't be applied to macros; requested
by and feedback from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.73 2006/03/25 18:29:35 deraadt Exp $ */
d42 1
@


1.73
log
@needed casts (always will be needed)
@
text
@d1 1
a1 1
/* $OpenBSD: authfd.c,v 1.72 2006/03/25 13:17:01 djm Exp $ */
a49 1
#include "getput.h"
d57 1
d125 1
a125 1
	PUT_32BIT(buf, len);
d144 1
a144 1
	len = GET_32BIT(buf);
@


1.72
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d399 1
a399 1
			response[i] = buffer_get_char(&buffer);
@


1.71
log
@spacing
@
text
@d1 1
@


1.70
log
@RCSID() can die
@
text
@d108 1
a108 1
	if (connect(sock, (struct sockaddr *) &sunaddr, sizeof sunaddr) < 0) {
@


1.69
log
@another unreachable found by lint
@
text
@a37 1
RCSID("$OpenBSD: authfd.c,v 1.68 2006/03/17 22:31:11 djm Exp $");
@


1.68
log
@unreachanble statement, found by lint
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.67 2006/02/20 16:36:14 stevesk Exp $");
a521 1
		break;
@


1.67
log
@move #include <sys/un.h> out of includes.h; ok djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.66 2005/06/17 02:44:32 djm Exp $");
a340 1
		break;
@


1.67.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: authfd.c,v 1.80 2006/08/03 03:34:41 deraadt Exp $ */
d37 2
a41 1
#include <sys/socket.h>
a44 8
#include <openssl/crypto.h>
#include <fcntl.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
d48 3
a57 1
#include "misc.h"
d109 1
a109 1
	if (connect(sock, (struct sockaddr *)&sunaddr, sizeof sunaddr) < 0) {
d125 1
a125 1
	put_u32(buf, len);
d144 1
a144 1
	len = get_u32(buf);
d341 1
d400 1
a400 1
			response[i] = (u_char)buffer_get_char(&buffer);
d523 1
@


1.66
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d38 4
a41 1
RCSID("$OpenBSD: authfd.c,v 1.65 2005/05/24 17:32:43 avsm Exp $");
@


1.66.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: authfd.c,v 1.80 2006/08/03 03:34:41 deraadt Exp $ */
d37 2
a38 4

#include <sys/types.h>
#include <sys/un.h>
#include <sys/socket.h>
a41 8
#include <openssl/crypto.h>
#include <fcntl.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
d45 3
a54 1
#include "misc.h"
d106 1
a106 1
	if (connect(sock, (struct sockaddr *)&sunaddr, sizeof sunaddr) < 0) {
d122 1
a122 1
	put_u32(buf, len);
d141 1
a141 1
	len = get_u32(buf);
d338 1
d397 1
a397 1
			response[i] = (u_char)buffer_get_char(&buffer);
d520 1
@


1.65
log
@Switch atomicio to use a simpler interface; it now returns a size_t
(containing number of bytes read/written), and indicates error by
returning 0.  EOF is signalled by errno==EPIPE.
Typical use now becomes:

if (atomicio(read, ..., len) != len)
        err(1,"read");

ok deraadt@@, cloder@@, djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.64 2004/08/11 21:44:31 avsm Exp $");
d117 1
a117 2
	int l;
	u_int len;
d304 1
d325 2
a326 1
		if (bits != BN_num_bits(key->rsa->n))
@


1.64
log
@use atomicio instead of homegrown equivalents or read/write.
markus@@ ok
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.63 2003/11/21 11:57:03 djm Exp $");
d152 1
a152 2
		l = atomicio(read, auth->fd, buf, l);
		if (l <= 0) {
@


1.64.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.66 2005/06/17 02:44:32 djm Exp $");
d117 2
a118 1
	u_int l, len;
d152 2
a153 1
		if (atomicio(read, auth->fd, buf, l) != l) {
a305 1
	int keybits;
d326 1
a326 2
		keybits = BN_num_bits(key->rsa->n);
		if (keybits < 0 || bits != (u_int)keybits)
@


1.64.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.66 2005/06/17 02:44:32 djm Exp $");
d117 2
a118 1
	u_int l, len;
d152 2
a153 1
		if (atomicio(read, auth->fd, buf, l) != l) {
a305 1
	int keybits;
d326 1
a326 2
		keybits = BN_num_bits(key->rsa->n);
		if (keybits < 0 || bits != (u_int)keybits)
@


1.63
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.62 2003/09/18 13:02:21 miod Exp $");
d136 3
a138 10
	len = 4;
	while (len > 0) {
		l = read(auth->fd, buf + 4 - len, len);
		if (l == -1 && (errno == EAGAIN || errno == EINTR))
			continue;
		if (l <= 0) {
			error("Error reading response length from authentication socket.");
			return 0;
		}
		len -= l;
d152 1
a152 3
		l = read(auth->fd, buf, l);
		if (l == -1 && (errno == EAGAIN || errno == EINTR))
			continue;
@


1.63.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.64 2004/08/11 21:44:31 avsm Exp $");
d136 10
a145 3
	if (atomicio(read, auth->fd, buf, 4) != 4) {
	    error("Error reading response length from authentication socket.");
	    return 0;
d159 3
a161 1
		l = atomicio(read, auth->fd, buf, l);
@


1.62
log
@A few signedness fixes for harmless situations; markus@@ ok
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.61 2003/06/28 16:23:06 deraadt Exp $");
d593 1
a593 1
ssh_update_card(AuthenticationConnection *auth, int add, 
d610 1
a610 1
	
@


1.61
log
@deal with typing of write vs read in atomicio
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.60 2003/06/11 11:18:38 djm Exp $");
d117 2
a118 1
	int l, len;
d151 1
a151 1
		fatal("Authentication response too long: %d", len);
d296 1
a296 1
	if (auth->howmany > 1024)
@


1.61.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.63 2003/11/21 11:57:03 djm Exp $");
d117 1
a117 2
	int l;
	u_int len;
d150 1
a150 1
		fatal("Authentication response too long: %u", len);
d295 1
a295 1
	if ((u_int)auth->howmany > 1024)
d592 1
a592 1
ssh_update_card(AuthenticationConnection *auth, int add,
d609 1
a609 1

@


1.61.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.64 2004/08/11 21:44:31 avsm Exp $");
d136 10
a145 3
	if (atomicio(read, auth->fd, buf, 4) != 4) {
	    error("Error reading response length from authentication socket.");
	    return 0;
d159 3
a161 1
		l = atomicio(read, auth->fd, buf, l);
@


1.60
log
@make agent constraints (lifetime, confirm) work with smartcard keys; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.59 2003/04/08 20:21:28 itojun Exp $");
d125 2
a126 2
	if (atomicio(write, auth->fd, buf, 4) != 4 ||
	    atomicio(write, auth->fd, buffer_ptr(request),
@


1.59
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.58 2003/01/23 13:50:27 markus Exp $");
d592 2
a593 1
ssh_update_card(AuthenticationConnection *auth, int add, const char *reader_id, const char *pin)
d596 8
a603 1
	int type;
d606 1
a606 2
	buffer_put_char(&msg, add ? SSH_AGENTC_ADD_SMARTCARD_KEY :
	    SSH_AGENTC_REMOVE_SMARTCARD_KEY);
d609 10
@


1.58
log
@ssh-add -c, prompt user for confirmation (using ssh-askpass) when
private agent key is used; with djm@@; test by dugsong@@, djm@@; ok deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.57 2002/09/11 18:27:26 stevesk Exp $");
d335 1
a335 1
			log("Warning: identity keysize mismatch: actual %d, announced %u",
d376 1
a376 1
		log("Compatibility with ssh protocol version 1.0 no longer supported.");
d395 1
a395 1
		log("Agent admitted failure to authenticate using the key.");
d444 1
a444 1
		log("Agent admitted failure to sign using the key.");
d644 1
a644 1
		log("SSH_AGENT_FAILURE");
@


1.58.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.61 2003/06/28 16:23:06 deraadt Exp $");
d125 2
a126 2
	if (atomicio(vwrite, auth->fd, buf, 4) != 4 ||
	    atomicio(vwrite, auth->fd, buffer_ptr(request),
d335 1
a335 1
			logit("Warning: identity keysize mismatch: actual %d, announced %u",
d376 1
a376 1
		logit("Compatibility with ssh protocol version 1.0 no longer supported.");
d395 1
a395 1
		logit("Agent admitted failure to authenticate using the key.");
d444 1
a444 1
		logit("Agent admitted failure to sign using the key.");
d592 1
a592 2
ssh_update_card(AuthenticationConnection *auth, int add, 
    const char *reader_id, const char *pin, u_int life, u_int confirm)
d595 1
a595 8
	int type, constrained = (life || confirm);

	if (add) {
		type = constrained ?
		    SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED :
		    SSH_AGENTC_ADD_SMARTCARD_KEY;
	} else
		type = SSH_AGENTC_REMOVE_SMARTCARD_KEY;
d598 2
a599 1
	buffer_put_char(&msg, type);
a601 10
	
	if (constrained) {
		if (life != 0) {
			buffer_put_char(&msg, SSH_AGENT_CONSTRAIN_LIFETIME);
			buffer_put_int(&msg, life);
		}
		if (confirm != 0)
			buffer_put_char(&msg, SSH_AGENT_CONSTRAIN_CONFIRM);
	}

d644 1
a644 1
		logit("SSH_AGENT_FAILURE");
@


1.58.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.63 2003/11/21 11:57:03 djm Exp $");
d117 1
a117 2
	int l;
	u_int len;
d150 1
a150 1
		fatal("Authentication response too long: %u", len);
d295 1
a295 1
	if ((u_int)auth->howmany > 1024)
d592 1
a592 1
ssh_update_card(AuthenticationConnection *auth, int add,
d609 1
a609 1

@


1.57
log
@don't connect to agent to test for presence if we've previously
connected; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.56 2002/06/25 16:22:42 markus Exp $");
d502 1
a502 1
    const char *comment, u_int life)
d505 1
a505 1
	int type, constrained = (life != 0);
d535 2
d550 1
a550 1
	return ssh_add_identity_constrained(auth, key, comment, 0);
@


1.57.2.1
log
@Update to OpenSSH 3.6
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.58 2003/01/23 13:50:27 markus Exp $");
d502 1
a502 1
    const char *comment, u_int life, u_int confirm)
d505 1
a505 1
	int type, constrained = (life || confirm);
a534 2
		if (confirm != 0)
			buffer_put_char(&msg, SSH_AGENT_CONSTRAIN_CONFIRM);
d548 1
a548 1
	return ssh_add_identity_constrained(auth, key, comment, 0, 0);
@


1.57.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.61 2003/06/28 16:23:06 deraadt Exp $");
d125 2
a126 2
	if (atomicio(vwrite, auth->fd, buf, 4) != 4 ||
	    atomicio(vwrite, auth->fd, buffer_ptr(request),
d335 1
a335 1
			logit("Warning: identity keysize mismatch: actual %d, announced %u",
d376 1
a376 1
		logit("Compatibility with ssh protocol version 1.0 no longer supported.");
d395 1
a395 1
		logit("Agent admitted failure to authenticate using the key.");
d444 1
a444 1
		logit("Agent admitted failure to sign using the key.");
d592 1
a592 2
ssh_update_card(AuthenticationConnection *auth, int add, 
    const char *reader_id, const char *pin, u_int life, u_int confirm)
d595 1
a595 8
	int type, constrained = (life || confirm);

	if (add) {
		type = constrained ?
		    SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED :
		    SSH_AGENTC_ADD_SMARTCARD_KEY;
	} else
		type = SSH_AGENTC_REMOVE_SMARTCARD_KEY;
d598 2
a599 1
	buffer_put_char(&msg, type);
a601 10
	
	if (constrained) {
		if (life != 0) {
			buffer_put_char(&msg, SSH_AGENT_CONSTRAIN_LIFETIME);
			buffer_put_int(&msg, life);
		}
		if (confirm != 0)
			buffer_put_char(&msg, SSH_AGENT_CONSTRAIN_CONFIRM);
	}

d644 1
a644 1
		logit("SSH_AGENT_FAILURE");
@


1.56
log
@unnecessary cast
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.55 2002/06/19 00:27:55 deraadt Exp $");
d56 2
d66 15
d110 1
@


1.55
log
@KNF done automatically while reading....
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.54 2002/06/15 01:27:48 markus Exp $");
d147 1
a147 1
		buffer_append(reply, (char *) buf, l);
@


1.54
log
@remove the CONSTRAIN_IDENTITY messages and introduce a new
ADD_ID message with contraints instead. contraints can be
only added together with the private key.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.53 2002/06/15 00:07:38 markus Exp $");
d62 1
a62 1
     (x == SSH2_AGENT_FAILURE))
@


1.53
log
@fix stupid typo
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.52 2002/06/15 00:01:36 markus Exp $");
a441 2
	buffer_clear(b);
	buffer_put_char(b, SSH_AGENTC_ADD_RSA_IDENTITY);
a455 2
	buffer_clear(b);
	buffer_put_char(b, SSH2_AGENTC_ADD_IDENTITY);
d483 2
a484 1
ssh_add_identity(AuthenticationConnection *auth, Key *key, const char *comment)
d487 1
a487 1
	int type;
d493 4
d501 4
d512 6
d527 6
a561 36
	if (ssh_request_reply(auth, &msg, &msg) == 0) {
		buffer_free(&msg);
		return 0;
	}
	type = buffer_get_char(&msg);
	buffer_free(&msg);
	return decode_reply(type);
}

int
ssh_constrain_identity(AuthenticationConnection *auth, Key *key, u_int life)
{
	Buffer msg;
	int type;
	u_char *blob;
	u_int blen;

	buffer_init(&msg);

	if (key->type == KEY_RSA1) {
		buffer_put_char(&msg, SSH_AGENTC_CONSTRAIN_IDENTITY1);
		buffer_put_int(&msg, BN_num_bits(key->rsa->n));
		buffer_put_bignum(&msg, key->rsa->e);
		buffer_put_bignum(&msg, key->rsa->n);
	} else if (key->type == KEY_DSA || key->type == KEY_RSA) {
		key_to_blob(key, &blob, &blen);
		buffer_put_char(&msg, SSH_AGENTC_CONSTRAIN_IDENTITY);
		buffer_put_string(&msg, blob, blen);
		xfree(blob);
	} else {
		buffer_free(&msg);
		return 0;
	}
	buffer_put_char(&msg, SSH_AGENT_CONSTRAIN_LIFETIME);
	buffer_put_int(&msg, life);

@


1.52
log
@break agent key lifetime protocol and allow other contraints for key usage.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.51 2002/06/05 21:55:44 markus Exp $");
d555 1
a555 1
ssh_contrain_identity(AuthenticationConnection *auth, Key *key, u_int life)
d565 1
a565 1
		buffer_put_char(&msg, SSH_AGENTC_CONTRAIN_IDENTITY1);
d571 1
a571 1
		buffer_put_char(&msg, SSH_AGENTC_CONTRAIN_IDENTITY);
d578 1
a578 1
	buffer_put_char(&msg, SSH_AGENT_CONTRAIN_LIFETIME);
@


1.51
log
@ssh-add -t life,  Set lifetime (in seconds) when adding identities; ok provos@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.50 2002/06/05 19:57:12 markus Exp $");
d555 1
a555 1
ssh_lifetime_identity(AuthenticationConnection *auth, Key *key, u_int life)
d565 1
a565 2
		buffer_put_char(&msg, SSH_AGENTC_LIFETIME_IDENTITY1);
		buffer_put_int(&msg, life);
d571 1
a571 2
		buffer_put_char(&msg, SSH_AGENTC_LIFETIME_IDENTITY);
		buffer_put_int(&msg, life);
d578 3
@


1.50
log
@ssh-add -x for lock and -X for unlocking the agent.
todo: encrypt private keys with locked...
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.49 2002/03/21 22:44:05 rees Exp $");
d539 35
@


1.49
log
@Add PIN-protection for secret key.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.48 2002/02/24 19:14:59 markus Exp $");
d208 20
@


1.49.2.1
log
@Pull in OpenSSH-3.4
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.56 2002/06/25 16:22:42 markus Exp $");
d62 1
a62 1
    (x == SSH2_AGENT_FAILURE))
d147 1
a147 1
		buffer_append(reply, buf, l);
a209 20
/* Lock/unlock agent */
int
ssh_lock_agent(AuthenticationConnection *auth, int lock, const char *password)
{
	int type;
	Buffer msg;

	buffer_init(&msg);
	buffer_put_char(&msg, lock ? SSH_AGENTC_LOCK : SSH_AGENTC_UNLOCK);
	buffer_put_cstring(&msg, password);

	if (ssh_request_reply(auth, &msg, &msg) == 0) {
		buffer_free(&msg);
		return 0;
	}
	type = buffer_get_char(&msg);
	buffer_free(&msg);
	return decode_reply(type);
}

d422 2
d438 2
d467 1
a467 2
ssh_add_identity_constrained(AuthenticationConnection *auth, Key *key,
    const char *comment, u_int life)
d470 1
a470 1
	int type, constrained = (life != 0);
a475 4
		type = constrained ?
		    SSH_AGENTC_ADD_RSA_ID_CONSTRAINED :
		    SSH_AGENTC_ADD_RSA_IDENTITY;
		buffer_put_char(&msg, type);
a479 4
		type = constrained ?
		    SSH2_AGENTC_ADD_ID_CONSTRAINED :
		    SSH2_AGENTC_ADD_IDENTITY;
		buffer_put_char(&msg, type);
a486 6
	if (constrained) {
		if (life != 0) {
			buffer_put_char(&msg, SSH_AGENT_CONSTRAIN_LIFETIME);
			buffer_put_int(&msg, life);
		}
	}
a493 6
}

int
ssh_add_identity(AuthenticationConnection *auth, Key *key, const char *comment)
{
	return ssh_add_identity_constrained(auth, key, comment, 0);
@


1.49.2.2
log
@Update to OpenSSH 3.5
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.57 2002/09/11 18:27:26 stevesk Exp $");
a55 2
static int agent_present = 0;

a63 15
int
ssh_agent_present(void)
{
	int authfd;

	if (agent_present)
		return 1;
	if ((authfd = ssh_get_authentication_socket()) == -1)
		return 0;
	else {
		ssh_close_authentication_socket(authfd);
		return 1;
	}
}

a92 1
	agent_present = 1;
@


1.49.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.58 2003/01/23 13:50:27 markus Exp $");
d502 1
a502 1
    const char *comment, u_int life, u_int confirm)
d505 1
a505 1
	int type, constrained = (life || confirm);
a534 2
		if (confirm != 0)
			buffer_put_char(&msg, SSH_AGENT_CONSTRAIN_CONFIRM);
d548 1
a548 1
	return ssh_add_identity_constrained(auth, key, comment, 0, 0);
@


1.48
log
@signed vs. unsigned: make size arguments u_int, ok stevesk@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.47 2002/01/18 18:14:17 stevesk Exp $");
d535 1
a535 1
ssh_update_card(AuthenticationConnection *auth, int add, const char *reader_id)
d544 1
@


1.47
log
@unneeded cast cleanup; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.46 2001/12/05 10:06:12 deraadt Exp $");
d377 2
a378 2
    u_char **sigp, int *lenp,
    u_char *data, int datalen)
@


1.46
log
@minor KNF
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.45 2001/09/19 19:35:30 stevesk Exp $");
d347 1
a347 1
	buffer_append(&buffer, (char *) session_id, 16);
@


1.45
log
@use sizeof addr vs. SUN_LEN(addr) for sockaddr_un.  Stevens blesses
this and we do it this way elsewhere.  this helps in portable because
not all systems have SUN_LEN() and sockaddr_un.sun_len.  ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.44 2001/08/07 10:37:46 markus Exp $");
d220 1
a220 1
	switch(version){
d289 1
a289 1
	switch(version){
d441 1
a441 1
	switch(key->type){
@


1.45.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.48 2002/02/24 19:14:59 markus Exp $");
d220 1
a220 1
	switch (version) {
d289 1
a289 1
	switch (version) {
d347 1
a347 1
	buffer_append(&buffer, session_id, 16);
d377 2
a378 2
    u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d441 1
a441 1
	switch (key->type) {
@


1.45.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.49 2002/03/21 22:44:05 rees Exp $");
d535 1
a535 1
ssh_update_card(AuthenticationConnection *auth, int add, const char *reader_id, const char *pin)
a543 1
	buffer_put_cstring(&msg, pin);
@


1.45.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.45.2.2 2002/05/17 00:03:23 miod Exp $");
d62 1
a62 1
    (x == SSH2_AGENT_FAILURE))
a209 20
/* Lock/unlock agent */
int
ssh_lock_agent(AuthenticationConnection *auth, int lock, const char *password)
{
	int type;
	Buffer msg;

	buffer_init(&msg);
	buffer_put_char(&msg, lock ? SSH_AGENTC_LOCK : SSH_AGENTC_UNLOCK);
	buffer_put_cstring(&msg, password);

	if (ssh_request_reply(auth, &msg, &msg) == 0) {
		buffer_free(&msg);
		return 0;
	}
	type = buffer_get_char(&msg);
	buffer_free(&msg);
	return decode_reply(type);
}

d422 2
d438 2
d467 1
a467 2
ssh_add_identity_constrained(AuthenticationConnection *auth, Key *key,
    const char *comment, u_int life)
d470 1
a470 1
	int type, constrained = (life != 0);
a475 4
		type = constrained ?
		    SSH_AGENTC_ADD_RSA_ID_CONSTRAINED :
		    SSH_AGENTC_ADD_RSA_IDENTITY;
		buffer_put_char(&msg, type);
a479 4
		type = constrained ?
		    SSH2_AGENTC_ADD_ID_CONSTRAINED :
		    SSH2_AGENTC_ADD_IDENTITY;
		buffer_put_char(&msg, type);
a486 6
	if (constrained) {
		if (life != 0) {
			buffer_put_char(&msg, SSH_AGENT_CONSTRAIN_LIFETIME);
			buffer_put_int(&msg, life);
		}
	}
a493 6
}

int
ssh_add_identity(AuthenticationConnection *auth, Key *key, const char *comment)
{
	return ssh_add_identity_constrained(auth, key, comment, 0);
@


1.45.2.4
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.45.2.3 2002/06/22 07:23:17 miod Exp $");
d147 1
a147 1
		buffer_append(reply, buf, l);
@


1.45.2.5
log
@Update to OpenSSH 3.5
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.57 2002/09/11 18:27:26 stevesk Exp $");
a55 2
static int agent_present = 0;

a63 15
int
ssh_agent_present(void)
{
	int authfd;

	if (agent_present)
		return 1;
	if ((authfd = ssh_get_authentication_socket()) == -1)
		return 0;
	else {
		ssh_close_authentication_socket(authfd);
		return 1;
	}
}

a92 1
	agent_present = 1;
@


1.44
log
@extended failure messages from galb@@vandyke.com
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.43 2001/08/01 22:03:33 markus Exp $");
d70 1
a70 1
	int sock, len;
a78 2
	len = SUN_LEN(&sunaddr)+1;
	sunaddr.sun_len = len;
d89 1
a89 1
	if (connect(sock, (struct sockaddr *) & sunaddr, len) < 0) {
@


1.43
log
@use strings instead of ints for smartcard reader ids
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.42 2001/06/26 04:59:59 markus Exp $");
d61 2
a62 1
    ((x == SSH_AGENT_FAILURE) || (x == SSH_COM_AGENT2_FAILURE))
d587 1
@


1.42
log
@initial support for smartcards in the agent
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.41 2001/06/23 15:12:17 itojun Exp $");
d536 1
a536 1
ssh_update_card(AuthenticationConnection *auth, int add, int reader_id)
d544 1
a544 1
	buffer_put_int(&msg, reader_id);
@


1.41
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.40 2001/06/07 20:23:03 markus Exp $");
d526 19
@


1.40
log
@use xxx_put_cstring()
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.39 2001/04/05 10:42:48 markus Exp $");
d97 1
a97 1
int
d420 1
a420 1
void
d436 1
a436 1
void
@


1.39
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.38 2001/03/06 00:33:03 deraadt Exp $");
d433 1
a433 1
	buffer_put_string(b, comment, strlen(comment));
@


1.39.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.45 2001/09/19 19:35:30 stevesk Exp $");
d61 1
a61 2
    ((x == SSH_AGENT_FAILURE) || (x == SSH_COM_AGENT2_FAILURE) || \
     (x == SSH2_AGENT_FAILURE))
d69 1
a69 1
	int sock;
d78 2
d90 1
a90 1
	if (connect(sock, (struct sockaddr *) &sunaddr, sizeof sunaddr) < 0) {
d97 1
a97 1
static int
d420 1
a420 1
static void
d433 1
a433 1
	buffer_put_cstring(b, comment);
d436 1
a436 1
static void
a534 19
int
ssh_update_card(AuthenticationConnection *auth, int add, const char *reader_id)
{
	Buffer msg;
	int type;

	buffer_init(&msg);
	buffer_put_char(&msg, add ? SSH_AGENTC_ADD_SMARTCARD_KEY :
	    SSH_AGENTC_REMOVE_SMARTCARD_KEY);
	buffer_put_cstring(&msg, reader_id);
	if (ssh_request_reply(auth, &msg, &msg) == 0) {
		buffer_free(&msg);
		return 0;
	}
	type = buffer_get_char(&msg);
	buffer_free(&msg);
	return decode_reply(type);
}

a566 1
	case SSH2_AGENT_FAILURE:
@


1.39.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.48 2002/02/24 19:14:59 markus Exp $");
d220 1
a220 1
	switch (version) {
d289 1
a289 1
	switch (version) {
d347 1
a347 1
	buffer_append(&buffer, session_id, 16);
d377 2
a378 2
    u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d441 1
a441 1
	switch (key->type) {
@


1.39.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.49 2002/03/21 22:44:05 rees Exp $");
d535 1
a535 1
ssh_update_card(AuthenticationConnection *auth, int add, const char *reader_id, const char *pin)
a543 1
	buffer_put_cstring(&msg, pin);
@


1.38
log
@EINTR/EAGAIN handling is required in more cases
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.37 2001/03/04 17:42:27 millert Exp $");
d122 1
a122 1
			continue; 
d143 1
a143 1
			continue; 
@


1.37
log
@log functions should not be passed strings that end in newline as they
get passed on to syslog() and when logging to stderr, do_log() appends
its own newline.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.36 2001/03/01 02:11:25 deraadt Exp $");
d121 2
d142 2
@


1.36
log
@split line so that p will have an easier time next time around
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.35 2001/02/04 15:32:22 stevesk Exp $");
d255 1
a255 1
		fatal("Too many identities in authentication reply: %d\n",
@


1.35
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.34 2001/02/04 13:30:11 stevesk Exp $");
d78 2
a79 1
	sunaddr.sun_len = len = SUN_LEN(&sunaddr)+1;
@


1.34
log
@remove duplicate #include's; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.33 2001/01/21 19:05:44 markus Exp $");
d556 1
a556 1
int 
@


1.33
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.32 2000/12/20 19:37:21 markus Exp $");
a54 1
#include "authfd.h"
@


1.32
log
@fix prototypes; from  stevesk@@pobox.com
@
text
@d38 3
a40 1
RCSID("$OpenBSD: authfd.c,v 1.31 2000/12/19 23:17:55 markus Exp $");
a47 4

#include <openssl/rsa.h>
#include <openssl/dsa.h>
#include <openssl/evp.h>
d50 1
d53 3
@


1.31
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.30 2000/11/12 19:50:37 markus Exp $");
d65 1
a65 1
ssh_get_authentication_socket()
d170 1
a170 1
ssh_get_authentication_connection()
@


1.30
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.29 2000/10/09 21:51:00 markus Exp $");
d271 3
a273 3
	unsigned int bits;
	unsigned char *blob;
	unsigned int blen;
d321 3
a323 3
    unsigned char session_id[16],
    unsigned int response_type,
    unsigned char response[16])
d372 2
a373 2
    unsigned char **sigp, int *lenp,
    unsigned char *data, int datalen)
d377 2
a378 2
	unsigned char *blob;
	unsigned int blen;
d501 2
a502 2
	unsigned char *blob;
	unsigned int blen;
@


1.29
log
@interop with ssh-agent2, from <res@@shore.net>
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.28 2000/09/21 11:07:50 markus Exp $");
a52 1
#include "dsa.h"
d209 2
a210 2
Key *
ssh_get_first_identity(AuthenticationConnection *auth, char **comment, int version)
d225 1
a225 1
		return NULL;
d238 1
a238 1
		return NULL;
d245 1
a245 1
		return NULL;
d256 10
a265 2
	/* Return the first entry (if any). */
	return ssh_get_next_identity(auth, comment, version);
d286 1
a286 1
		key = key_new(KEY_RSA);
d298 1
a298 1
		key = dsa_key_from_blob(blob, blen);
d330 1
a330 1
	if (key->type != KEY_RSA)
d382 1
a382 1
	if (dsa_make_key_blob(key, &blob, &blen) == 0)
d415 1
a415 1
ssh_encode_identity_rsa(Buffer *b, RSA *key, const char *comment)
d431 1
a431 1
ssh_encode_identity_dsa(Buffer *b, DSA *key, const char *comment)
d435 19
a453 7
	buffer_put_cstring(b, KEX_DSS);
	buffer_put_bignum2(b, key->p);
	buffer_put_bignum2(b, key->q);
	buffer_put_bignum2(b, key->g);
	buffer_put_bignum2(b, key->pub_key);
	buffer_put_bignum2(b, key->priv_key);
	buffer_put_string(b, comment, strlen(comment));
d470 3
a473 2
		ssh_encode_identity_rsa(&msg, key->rsa, comment);
		break;
d475 1
a475 1
		ssh_encode_identity_dsa(&msg, key->dsa, comment);
d506 1
a506 1
	if (key->type == KEY_RSA) {
d511 2
a512 2
	} else if (key->type == KEY_DSA) {
		dsa_make_key_blob(key, &blob, &blen);
@


1.29.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d38 1
a38 3
RCSID("$OpenBSD: authfd.c,v 1.35 2001/02/04 15:32:22 stevesk Exp $");

#include <openssl/evp.h>
d46 4
a51 1
#include "cipher.h"
d53 1
a54 2
#include "log.h"
#include "atomicio.h"
d66 1
a66 1
ssh_get_authentication_socket(void)
d171 1
a171 1
ssh_get_authentication_connection(void)
d210 2
a211 2
int
ssh_get_num_identities(AuthenticationConnection *auth, int version)
d226 1
a226 1
		return 0;
d239 1
a239 1
		return 0;
d246 1
a246 1
		return 0;
d257 2
a258 10
	return auth->howmany;
}

Key *
ssh_get_first_identity(AuthenticationConnection *auth, char **comment, int version)
{
	/* get number of identities and return the first entry (if any). */
	if (ssh_get_num_identities(auth, version) > 0)
		return ssh_get_next_identity(auth, comment, version);
	return NULL;
d264 3
a266 3
	u_int bits;
	u_char *blob;
	u_int blen;
d279 1
a279 1
		key = key_new(KEY_RSA1);
d291 1
a291 1
		key = key_from_blob(blob, blen);
d314 3
a316 3
    u_char session_id[16],
    u_int response_type,
    u_char response[16])
d323 1
a323 1
	if (key->type != KEY_RSA1)
d365 2
a366 2
    u_char **sigp, int *lenp,
    u_char *data, int datalen)
d370 2
a371 2
	u_char *blob;
	u_int blen;
d375 1
a375 1
	if (key_to_blob(key, &blob, &blen) == 0)
d408 1
a408 1
ssh_encode_identity_rsa1(Buffer *b, RSA *key, const char *comment)
d424 1
a424 1
ssh_encode_identity_ssh2(Buffer *b, Key *key, const char *comment)
d428 7
a434 19
	buffer_put_cstring(b, key_ssh_name(key));
	switch(key->type){
	case KEY_RSA:
		buffer_put_bignum2(b, key->rsa->n);
		buffer_put_bignum2(b, key->rsa->e);
		buffer_put_bignum2(b, key->rsa->d);
		buffer_put_bignum2(b, key->rsa->iqmp);
		buffer_put_bignum2(b, key->rsa->p);
		buffer_put_bignum2(b, key->rsa->q);
		break;
	case KEY_DSA:
		buffer_put_bignum2(b, key->dsa->p);
		buffer_put_bignum2(b, key->dsa->q);
		buffer_put_bignum2(b, key->dsa->g);
		buffer_put_bignum2(b, key->dsa->pub_key);
		buffer_put_bignum2(b, key->dsa->priv_key);
		break;
	}
	buffer_put_cstring(b, comment);
d451 2
a452 2
	case KEY_RSA1:
		ssh_encode_identity_rsa1(&msg, key->rsa, comment);
a453 1
	case KEY_RSA:
d455 1
a455 1
		ssh_encode_identity_ssh2(&msg, key, comment);
d481 2
a482 2
	u_char *blob;
	u_int blen;
d486 1
a486 1
	if (key->type == KEY_RSA1) {
d491 2
a492 2
	} else if (key->type == KEY_DSA || key->type == KEY_RSA) {
		key_to_blob(key, &blob, &blen);
d535 1
a535 1
int
@


1.29.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.29.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.38 2001/03/06 00:33:03 deraadt Exp $");
d78 1
a78 2
	len = SUN_LEN(&sunaddr)+1;
	sunaddr.sun_len = len;
a119 2
		if (l == -1 && (errno == EAGAIN || errno == EINTR))
			continue; 
a138 2
		if (l == -1 && (errno == EAGAIN || errno == EINTR))
			continue; 
d254 1
a254 1
		fatal("Too many identities in authentication reply: %d",
@


1.29.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.39 2001/04/05 10:42:48 markus Exp $");
d122 1
a122 1
			continue;
d143 1
a143 1
			continue;
@


1.29.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.45 2001/09/19 19:35:30 stevesk Exp $");
d61 1
a61 2
    ((x == SSH_AGENT_FAILURE) || (x == SSH_COM_AGENT2_FAILURE) || \
     (x == SSH2_AGENT_FAILURE))
d69 1
a69 1
	int sock;
d78 2
d90 1
a90 1
	if (connect(sock, (struct sockaddr *) &sunaddr, sizeof sunaddr) < 0) {
d97 1
a97 1
static int
d420 1
a420 1
static void
d433 1
a433 1
	buffer_put_cstring(b, comment);
d436 1
a436 1
static void
a534 19
int
ssh_update_card(AuthenticationConnection *auth, int add, const char *reader_id)
{
	Buffer msg;
	int type;

	buffer_init(&msg);
	buffer_put_char(&msg, add ? SSH_AGENTC_ADD_SMARTCARD_KEY :
	    SSH_AGENTC_REMOVE_SMARTCARD_KEY);
	buffer_put_cstring(&msg, reader_id);
	if (ssh_request_reply(auth, &msg, &msg) == 0) {
		buffer_free(&msg);
		return 0;
	}
	type = buffer_get_char(&msg);
	buffer_free(&msg);
	return decode_reply(type);
}

a566 1
	case SSH2_AGENT_FAILURE:
@


1.29.2.6
log
@Merge OpenSSH 3.1.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.48 2002/02/24 19:14:59 markus Exp $");
d220 1
a220 1
	switch (version) {
d289 1
a289 1
	switch (version) {
d347 1
a347 1
	buffer_append(&buffer, session_id, 16);
d377 2
a378 2
    u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d441 1
a441 1
	switch (key->type) {
@


1.28
log
@bug compat for old ssh.com software
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.27 2000/09/07 20:27:49 deraadt Exp $");
d59 4
d245 1
a245 1
	if (type == SSH_AGENT_FAILURE) {
d344 1
a344 1
	if (type == SSH_AGENT_FAILURE) {
d393 1
a393 1
	if (type == SSH_AGENT_FAILURE) {
d540 1
@


1.27
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.26 2000/08/31 22:09:34 markus Exp $");
d54 1
d364 1
d368 1
a368 1
	int type;
d374 3
d381 1
a381 1
	buffer_put_int(&msg, 0);				/* flags, unused */
@


1.26
log
@add a flag to SSH2_AGENTC_SIGN_REQUEST for future extensions
@
text
@a1 3
 *
 * authfd.c
 *
a2 1
 *
d5 1
d7 5
a11 3
 * Created: Wed Mar 29 01:30:28 1995 ylo
 *
 * Functions for connecting the local authentication agent.
d14 1
a14 1
 * Copyright (c) 2000 Markus Friedl. All rights reserved.
d16 19
d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.25 2000/08/19 21:34:42 markus Exp $");
@


1.25
log
@add SSH2/DSA support to the agent and some other DSA related cleanups.
(note that we cannot talk to ssh.com's ssh2 agents)
@
text
@d20 1
a20 1
RCSID("$OpenBSD: authfd.c,v 1.24 2000/08/15 19:20:46 markus Exp $");
d358 1
@


1.24
log
@cleanup; ok niels@@
@
text
@d14 3
d20 1
a20 1
RCSID("$OpenBSD: authfd.c,v 1.23 2000/08/02 06:23:30 deraadt Exp $");
d35 1
d74 1
a74 2
ssh_request_reply(AuthenticationConnection *auth,
    Buffer *request, Buffer *reply)
a163 1
	buffer_init(&auth->packet);
d176 1
a176 1
ssh_close_authentication_connection(AuthenticationConnection *ac)
d178 3
a180 4
	buffer_free(&ac->packet);
	buffer_free(&ac->identities);
	close(ac->fd);
	xfree(ac);
a184 3
 * Returns true if an identity is available, 0 otherwise.
 * The caller must initialize the integers before the call, and free the
 * comment after a successful call (before calling ssh_get_next_identity).
d187 2
a188 3
int
ssh_get_first_identity(AuthenticationConnection *auth,
    BIGNUM *e, BIGNUM *n, char **comment)
d190 1
d192 13
a204 1
	int type;
d211 1
a211 1
	buffer_put_char(&request, SSH_AGENTC_REQUEST_RSA_IDENTITIES);
d216 1
a216 1
		return 0;
d222 3
a224 1
	if (type != SSH_AGENT_RSA_IDENTITIES_ANSWER)
d226 1
d235 1
a235 1
	return ssh_get_next_identity(auth, e, n, comment);
d238 2
a239 10
/*
 * Returns the next authentication identity for the agent.  Other functions
 * can be called between this and ssh_get_first_identity or two calls of this
 * function.  This returns 0 if there are no more identities.  The caller
 * must free comment after a successful return.
 */

int
ssh_get_next_identity(AuthenticationConnection *auth,
    BIGNUM *e, BIGNUM *n, char **comment)
d242 3
d248 1
a248 1
		return 0;
d254 21
a274 9
	bits = buffer_get_int(&auth->identities);
	buffer_get_bignum(&auth->identities, e);
	buffer_get_bignum(&auth->identities, n);
	*comment = buffer_get_string(&auth->identities, NULL);

	if (bits != BN_num_bits(n))
		log("Warning: identity keysize mismatch: actual %d, announced %u",
		    BN_num_bits(n), bits);

d277 1
a277 2

	return 1;
d290 1
a290 1
    BIGNUM* e, BIGNUM *n, BIGNUM *challenge,
d300 6
a305 4
	if (response_type == 0)
		fatal("Compatibility with ssh protocol version "
		    "1.0 no longer supported.");

d308 3
a310 3
	buffer_put_int(&buffer, BN_num_bits(n));
	buffer_put_bignum(&buffer, e);
	buffer_put_bignum(&buffer, n);
d338 39
d417 1
a417 1
	Buffer buffer;
d420 1
a420 1
	buffer_init(&buffer);
d424 1
a424 1
		ssh_encode_identity_rsa(&buffer, key->rsa, comment);
d427 1
a427 1
		ssh_encode_identity_dsa(&buffer, key->dsa, comment);
d430 1
a430 1
		buffer_free(&buffer);
d434 2
a435 2
	if (ssh_request_reply(auth, &buffer, &buffer) == 0) {
		buffer_free(&buffer);
d438 2
a439 2
	type = buffer_get_char(&buffer);
	buffer_free(&buffer);
d449 1
a449 1
ssh_remove_identity(AuthenticationConnection *auth, RSA *key)
d451 1
a451 1
	Buffer buffer;
d453 2
d456 1
a456 5
	buffer_init(&buffer);
	buffer_put_char(&buffer, SSH_AGENTC_REMOVE_RSA_IDENTITY);
	buffer_put_int(&buffer, BN_num_bits(key->n));
	buffer_put_bignum(&buffer, key->e);
	buffer_put_bignum(&buffer, key->n);
d458 16
a473 2
	if (ssh_request_reply(auth, &buffer, &buffer) == 0) {
		buffer_free(&buffer);
d476 2
a477 2
	type = buffer_get_char(&buffer);
	buffer_free(&buffer);
d487 1
a487 1
ssh_remove_all_identities(AuthenticationConnection *auth)
d489 1
a489 1
	Buffer buffer;
d491 3
d495 2
a496 2
	buffer_init(&buffer);
	buffer_put_char(&buffer, SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES);
d498 2
a499 2
	if (ssh_request_reply(auth, &buffer, &buffer) == 0) {
		buffer_free(&buffer);
d502 2
a503 2
	type = buffer_get_char(&buffer);
	buffer_free(&buffer);
@


1.23
log
@correct sun_len; Alexander@@Leidinger.net
@
text
@d17 1
a17 1
RCSID("$OpenBSD: authfd.c,v 1.22 2000/07/16 08:27:20 markus Exp $");
d34 1
a34 1
int ssh_agent_get_reply(AuthenticationConnection *auth);
d69 54
d191 1
a191 1
		       BIGNUM *e, BIGNUM *n, char **comment)
d193 2
a194 2
	unsigned char msg[8192];
	int len, l;
d200 2
a201 16
	PUT_32BIT(msg, 1);
	msg[4] = SSH_AGENTC_REQUEST_RSA_IDENTITIES;
	if (atomicio(write, auth->fd, msg, 5) != 5) {
		error("write auth->fd: %.100s", strerror(errno));
		return 0;
	}
	/* Read the length of the response.  XXX implement timeouts here. */
	len = 4;
	while (len > 0) {
		l = read(auth->fd, msg + 4 - len, len);
		if (l <= 0) {
			error("read auth->fd: %.100s", strerror(errno));
			return 0;
		}
		len -= l;
	}
a202 9
	/*
	 * Extract the length, and check it for sanity.  (We cannot trust
	 * authentication agents).
	 */
	len = GET_32BIT(msg);
	if (len < 1 || len > 256 * 1024)
		fatal("Authentication reply message too long: %d\n", len);

	/* Read the packet itself. */
d204 3
a206 9
	while (len > 0) {
		l = len;
		if (l > sizeof(msg))
			l = sizeof(msg);
		l = read(auth->fd, msg, l);
		if (l <= 0)
			fatal("Incomplete authentication reply.");
		buffer_append(&auth->identities, (char *) msg, l);
		len -= l;
d208 1
d211 3
a213 3
	buffer_get(&auth->identities, (char *) msg, 1);
	if (msg[0] != SSH_AGENT_RSA_IDENTITIES_ANSWER)
		fatal("Bad authentication reply message type: %d", msg[0]);
d218 2
a219 1
		fatal("Too many identities in authentication reply: %d\n", auth->howmany);
d234 1
a234 1
		      BIGNUM *e, BIGNUM *n, char **comment)
d271 4
a274 4
		      BIGNUM* e, BIGNUM *n, BIGNUM *challenge,
		      unsigned char session_id[16],
		      unsigned int response_type,
		      unsigned char response[16])
d277 3
a279 2
	unsigned char buf[8192];
	int len, l, i;
a280 1
	/* Response type 0 is no longer supported. */
d282 2
a283 1
		fatal("Compatibility with ssh protocol version 1.0 no longer supported.");
a284 2
	/* Format a message to the agent. */
	buf[0] = SSH_AGENTC_RSA_CHALLENGE;
d286 1
a286 1
	buffer_append(&buffer, (char *) buf, 1);
d294 1
a294 10
	/* Get the length of the message, and format it in the buffer. */
	len = buffer_len(&buffer);
	PUT_32BIT(buf, len);

	/* Send the length and then the packet to the agent. */
	if (atomicio(write, auth->fd, buf, 4) != 4 ||
	    atomicio(write, auth->fd, buffer_ptr(&buffer),
	    buffer_len(&buffer)) != buffer_len(&buffer)) {
		error("Error writing to authentication socket.");
error_cleanup:
d298 1
a298 13
	/*
	 * Wait for response from the agent.  First read the length of the
	 * response packet.
	 */
	len = 4;
	while (len > 0) {
		l = read(auth->fd, buf + 4 - len, len);
		if (l <= 0) {
			error("Error reading response length from authentication socket.");
			goto error_cleanup;
		}
		len -= l;
	}
d300 1
a300 25
	/* Extract the length, and check it for sanity. */
	len = GET_32BIT(buf);
	if (len > 256 * 1024)
		fatal("Authentication response too long: %d", len);

	/* Read the rest of the response in tothe buffer. */
	buffer_clear(&buffer);
	while (len > 0) {
		l = len;
		if (l > sizeof(buf))
			l = sizeof(buf);
		l = read(auth->fd, buf, l);
		if (l <= 0) {
			error("Error reading response from authentication socket.");
			goto error_cleanup;
		}
		buffer_append(&buffer, (char *) buf, l);
		len -= l;
	}

	/* Get the type of the packet. */
	buffer_get(&buffer, (char *) buf, 1);

	/* Check for agent failure message. */
	if (buf[0] == SSH_AGENT_FAILURE) {
d302 10
a311 1
		goto error_cleanup;
a312 12
	/* Now it must be an authentication response packet. */
	if (buf[0] != SSH_AGENT_RSA_RESPONSE)
		fatal("Bad authentication response: %d", buf[0]);

	/*
	 * Get the response from the packet.  This will abort with a fatal
	 * error if the packet is corrupt.
	 */
	for (i = 0; i < 16; i++)
		response[i] = buffer_get_char(&buffer);

	/* The buffer containing the packet is no longer needed. */
d314 1
a314 3

	/* Correct answer. */
	return 1;
d358 1
a358 2
	unsigned char buf[8192];
	int len;
d374 1
a374 10

	/* Get the length of the message, and format it in the buffer. */
	len = buffer_len(&buffer);
	PUT_32BIT(buf, len);

	/* Send the length and then the packet to the agent. */
	if (atomicio(write, auth->fd, buf, 4) != 4 ||
	    atomicio(write, auth->fd, buffer_ptr(&buffer),
	    buffer_len(&buffer)) != buffer_len(&buffer)) {
		error("Error writing to authentication socket.");
d378 1
d380 1
a380 1
	return ssh_agent_get_reply(auth);
d392 1
a392 2
	unsigned char buf[5];
	int len;
a393 1
	/* Format a message to the agent. */
d400 1
a400 9
	/* Get the length of the message, and format it in the buffer. */
	len = buffer_len(&buffer);
	PUT_32BIT(buf, len);

	/* Send the length and then the packet to the agent. */
	if (atomicio(write, auth->fd, buf, 4) != 4 ||
	    atomicio(write, auth->fd, buffer_ptr(&buffer),
	    buffer_len(&buffer)) != buffer_len(&buffer)) {
		error("Error writing to authentication socket.");
d404 1
d406 1
a406 1
	return ssh_agent_get_reply(auth);
d417 2
a418 1
	unsigned char buf[5];
d420 2
a421 3
	/* Get the length of the message, and format it in the buffer. */
	PUT_32BIT(buf, 1);
	buf[4] = SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES;
d423 2
a424 3
	/* Send the length and then the packet to the agent. */
	if (atomicio(write, auth->fd, buf, 5) != 5) {
		error("Error writing to authentication socket.");
d427 3
a429 1
	return ssh_agent_get_reply(auth);
a431 4
/*
 * Read for reply from agent. returns 1 for success, 0 on error
 */

d433 1
a433 1
ssh_agent_get_reply(AuthenticationConnection *auth)
a434 43
	Buffer buffer;
	unsigned char buf[8192];
	int len, l, type;

	/*
	 * Wait for response from the agent.  First read the length of the
	 * response packet.
	 */
	len = 4;
	while (len > 0) {
		l = read(auth->fd, buf + 4 - len, len);
		if (l <= 0) {
			error("Error reading response length from authentication socket.");
			buffer_free(&buffer);
			return 0;
		}
		len -= l;
	}

	/* Extract the length, and check it for sanity. */
	len = GET_32BIT(buf);
	if (len > 256 * 1024)
		fatal("Response from agent too long: %d", len);

	/* Read the rest of the response in to the buffer. */
	buffer_init(&buffer);
	while (len > 0) {
		l = len;
		if (l > sizeof(buf))
			l = sizeof(buf);
		l = read(auth->fd, buf, l);
		if (l <= 0) {
			error("Error reading response from authentication socket.");
			buffer_free(&buffer);
			return 0;
		}
		buffer_append(&buffer, (char *) buf, l);
		len -= l;
	}

	/* Get the type of the packet. */
	type = buffer_get_char(&buffer);
	buffer_free(&buffer);
d437 1
a437 1
log("SSH_AGENT_FAILURE");
@


1.22
log
@make ssh-add accept dsa keys (the agent does not)
@
text
@d17 1
a17 1
RCSID("$OpenBSD: authfd.c,v 1.20 2000/06/20 01:39:38 markus Exp $");
d42 1
a42 1
	int sock;
d51 1
d62 1
a62 1
	if (connect(sock, (struct sockaddr *) & sunaddr, sizeof(sunaddr)) < 0) {
@


1.21
log
@cleanup, less cut&paste
@
text
@a20 1
#include "authfd.h"
d27 5
d145 1
a145 4
	msg[0] = 0;
	msg[1] = 0;
	msg[2] = 0;
	msg[3] = 1;
d340 32
d378 1
a378 2
ssh_add_identity(AuthenticationConnection *auth,
		 RSA * key, const char *comment)
a383 1
	/* Format a message to the agent. */
d385 13
a397 10
	buffer_put_char(&buffer, SSH_AGENTC_ADD_RSA_IDENTITY);
	buffer_put_int(&buffer, BN_num_bits(key->n));
	buffer_put_bignum(&buffer, key->n);
	buffer_put_bignum(&buffer, key->e);
	buffer_put_bignum(&buffer, key->d);
	/* To keep within the protocol: p < q for ssh. in SSL p > q */
	buffer_put_bignum(&buffer, key->iqmp);	/* ssh key->u */
	buffer_put_bignum(&buffer, key->q);	/* ssh key->p, SSL key->q */
	buffer_put_bignum(&buffer, key->p);	/* ssh key->q, SSL key->p */
	buffer_put_string(&buffer, comment, strlen(comment));
d524 1
@


1.20
log
@OpenBSD tag
@
text
@d17 1
a17 1
RCSID("$OpenBSD: authfd.c,v 1.19 2000/04/29 18:11:52 markus Exp $");
d29 3
d350 1
a350 1
	int len, l, type;
a373 1
error_cleanup:
d377 2
a378 47
	/* Wait for response from the agent.  First read the length of the
	   response packet. */
	len = 4;
	while (len > 0) {
		l = read(auth->fd, buf + 4 - len, len);
		if (l <= 0) {
			error("Error reading response length from authentication socket.");
			goto error_cleanup;
		}
		len -= l;
	}

	/* Extract the length, and check it for sanity. */
	len = GET_32BIT(buf);
	if (len > 256 * 1024)
		fatal("Add identity response too long: %d", len);

	/* Read the rest of the response in tothe buffer. */
	buffer_clear(&buffer);
	while (len > 0) {
		l = len;
		if (l > sizeof(buf))
			l = sizeof(buf);
		l = read(auth->fd, buf, l);
		if (l <= 0) {
			error("Error reading response from authentication socket.");
			goto error_cleanup;
		}
		buffer_append(&buffer, (char *) buf, l);
		len -= l;
	}

	/* Get the type of the packet. */
	type = buffer_get_char(&buffer);
	switch (type) {
	case SSH_AGENT_FAILURE:
		buffer_free(&buffer);
		return 0;
	case SSH_AGENT_SUCCESS:
		buffer_free(&buffer);
		return 1;
	default:
		fatal("Bad response to add identity from authentication agent: %d",
		      type);
	}
	/* NOTREACHED */
	return 0;
d390 2
a391 2
	unsigned char buf[8192];
	int len, l, type;
a408 1
error_cleanup:
d412 2
a413 49
	/*
	 * Wait for response from the agent.  First read the length of the
	 * response packet.
	 */
	len = 4;
	while (len > 0) {
		l = read(auth->fd, buf + 4 - len, len);
		if (l <= 0) {
			error("Error reading response length from authentication socket.");
			goto error_cleanup;
		}
		len -= l;
	}

	/* Extract the length, and check it for sanity. */
	len = GET_32BIT(buf);
	if (len > 256 * 1024)
		fatal("Remove identity response too long: %d", len);

	/* Read the rest of the response in tothe buffer. */
	buffer_clear(&buffer);
	while (len > 0) {
		l = len;
		if (l > sizeof(buf))
			l = sizeof(buf);
		l = read(auth->fd, buf, l);
		if (l <= 0) {
			error("Error reading response from authentication socket.");
			goto error_cleanup;
		}
		buffer_append(&buffer, (char *) buf, l);
		len -= l;
	}

	/* Get the type of the packet. */
	type = buffer_get_char(&buffer);
	switch (type) {
	case SSH_AGENT_FAILURE:
		buffer_free(&buffer);
		return 0;
	case SSH_AGENT_SUCCESS:
		buffer_free(&buffer);
		return 1;
	default:
		fatal("Bad response to remove identity from authentication agent: %d",
		      type);
	}
	/* NOTREACHED */
	return 0;
d424 1
a424 3
	Buffer buffer;
	unsigned char buf[8192];
	int len, l, type;
d435 14
d458 1
d467 1
a467 1
		fatal("Remove identity response too long: %d", len);
d469 1
a469 1
	/* Read the rest of the response into the buffer. */
d487 1
a489 1
		buffer_free(&buffer);
a491 1
		buffer_free(&buffer);
d494 1
a494 2
		fatal("Bad response to remove identity from authentication agent: %d",
		      type);
@


1.19
log
@keysize warnings error() -> log()
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.18 2000/04/14 10:30:29 markus Exp $");
@


1.19.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@a13 3
 * SSH2 implementation,
 * Copyright (c) 2000 Markus Friedl. All rights reserved.
 *
d17 1
a17 1
RCSID("$OpenBSD: authfd.c,v 1.25 2000/08/19 21:34:42 markus Exp $");
d21 1
a27 9
#include <openssl/dsa.h>
#include <openssl/evp.h>
#include "key.h"
#include "authfd.h"
#include "kex.h"
#include "dsa.h"

/* helper */
int	decode_reply(int type);
d35 1
a35 1
	int sock, len;
a43 1
	sunaddr.sun_len = len = SUN_LEN(&sunaddr)+1;
d54 1
a54 1
	if (connect(sock, (struct sockaddr *) & sunaddr, len) < 0) {
a60 53
int
ssh_request_reply(AuthenticationConnection *auth, Buffer *request, Buffer *reply)
{
	int l, len;
	char buf[1024];

	/* Get the length of the message, and format it in the buffer. */
	len = buffer_len(request);
	PUT_32BIT(buf, len);

	/* Send the length and then the packet to the agent. */
	if (atomicio(write, auth->fd, buf, 4) != 4 ||
	    atomicio(write, auth->fd, buffer_ptr(request),
	    buffer_len(request)) != buffer_len(request)) {
		error("Error writing to authentication socket.");
		return 0;
	}
	/*
	 * Wait for response from the agent.  First read the length of the
	 * response packet.
	 */
	len = 4;
	while (len > 0) {
		l = read(auth->fd, buf + 4 - len, len);
		if (l <= 0) {
			error("Error reading response length from authentication socket.");
			return 0;
		}
		len -= l;
	}

	/* Extract the length, and check it for sanity. */
	len = GET_32BIT(buf);
	if (len > 256 * 1024)
		fatal("Authentication response too long: %d", len);

	/* Read the rest of the response in to the buffer. */
	buffer_clear(reply);
	while (len > 0) {
		l = len;
		if (l > sizeof(buf))
			l = sizeof(buf);
		l = read(auth->fd, buf, l);
		if (l <= 0) {
			error("Error reading response from authentication socket.");
			return 0;
		}
		buffer_append(reply, (char *) buf, l);
		len -= l;
	}
	return 1;
}

d99 1
d112 1
a112 1
ssh_close_authentication_connection(AuthenticationConnection *auth)
d114 4
a117 3
	buffer_free(&auth->identities);
	close(auth->fd);
	xfree(auth);
d122 3
d127 3
a129 2
Key *
ssh_get_first_identity(AuthenticationConnection *auth, char **comment, int version)
d131 2
a132 2
	int type, code1 = 0, code2 = 0;
	Buffer request;
d134 22
a155 11
	switch(version){
	case 1:
		code1 = SSH_AGENTC_REQUEST_RSA_IDENTITIES;
		code2 = SSH_AGENT_RSA_IDENTITIES_ANSWER;
		break;
	case 2:
		code1 = SSH2_AGENTC_REQUEST_IDENTITIES;
		code2 = SSH2_AGENT_IDENTITIES_ANSWER;
		break;
	default:
		return NULL;
d159 2
a160 2
	 * Send a message to the agent requesting for a list of the
	 * identities it can represent.
d162 3
a164 2
	buffer_init(&request);
	buffer_put_char(&request, code1);
d166 1
d168 9
a176 3
	if (ssh_request_reply(auth, &request, &auth->identities) == 0) {
		buffer_free(&request);
		return NULL;
a177 1
	buffer_free(&request);
d180 3
a182 6
	type = buffer_get_char(&auth->identities);
	if (type == SSH_AGENT_FAILURE) {
		return NULL;
	} else if (type != code2) {
		fatal("Bad authentication reply message type: %d", type);
	}
d187 1
a187 2
		fatal("Too many identities in authentication reply: %d\n",
		    auth->howmany);
d190 1
a190 1
	return ssh_get_next_identity(auth, comment, version);
d193 10
a202 2
Key *
ssh_get_next_identity(AuthenticationConnection *auth, char **comment, int version)
a204 3
	unsigned char *blob;
	unsigned int blen;
	Key *key = NULL;
d208 1
a208 1
		return NULL;
d214 9
a222 21
	switch(version){
	case 1:
		key = key_new(KEY_RSA);
		bits = buffer_get_int(&auth->identities);
		buffer_get_bignum(&auth->identities, key->rsa->e);
		buffer_get_bignum(&auth->identities, key->rsa->n);
		*comment = buffer_get_string(&auth->identities, NULL);
		if (bits != BN_num_bits(key->rsa->n))
			log("Warning: identity keysize mismatch: actual %d, announced %u",
			    BN_num_bits(key->rsa->n), bits);
		break;
	case 2:
		blob = buffer_get_string(&auth->identities, &blen);
		*comment = buffer_get_string(&auth->identities, NULL);
		key = dsa_key_from_blob(blob, blen);
		xfree(blob);
		break;
	default:
		return NULL;
		break;
	}
d225 2
a226 1
	return key;
d239 4
a242 4
    Key* key, BIGNUM *challenge,
    unsigned char session_id[16],
    unsigned int response_type,
    unsigned char response[16])
d245 2
a246 3
	int success = 0;
	int i;
	int type;
d248 6
a253 6
	if (key->type != KEY_RSA)
		return 0;
	if (response_type == 0) {
		log("Compatibility with ssh protocol version 1.0 no longer supported.");
		return 0;
	}
d255 4
a258 4
	buffer_put_char(&buffer, SSH_AGENTC_RSA_CHALLENGE);
	buffer_put_int(&buffer, BN_num_bits(key->rsa->n));
	buffer_put_bignum(&buffer, key->rsa->e);
	buffer_put_bignum(&buffer, key->rsa->n);
d263 10
a272 1
	if (ssh_request_reply(auth, &buffer, &buffer) == 0) {
d276 12
a287 14
	type = buffer_get_char(&buffer);

	if (type == SSH_AGENT_FAILURE) {
		log("Agent admitted failure to authenticate using the key.");
	} else if (type != SSH_AGENT_RSA_RESPONSE) {
		fatal("Bad authentication response: %d", type);
	} else {
		success = 1;
		/*
		 * Get the response from the packet.  This will abort with a
		 * fatal error if the packet is corrupt.
		 */
		for (i = 0; i < 16; i++)
			response[i] = buffer_get_char(&buffer);
a288 3
	buffer_free(&buffer);
	return success;
}
d290 4
a293 12
/* ask agent to sign data, returns -1 on error, 0 on success */
int
ssh_agent_sign(AuthenticationConnection *auth,
    Key *key,
    unsigned char **sigp, int *lenp,
    unsigned char *data, int datalen)
{
	Buffer msg;
	unsigned char *blob;
	unsigned int blen;
	int type;
	int ret = -1;
d295 14
a308 2
	if (dsa_make_key_blob(key, &blob, &blen) == 0)
		return -1;
d310 2
a311 5
	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_AGENTC_SIGN_REQUEST);
	buffer_put_string(&msg, blob, blen);
	buffer_put_string(&msg, data, datalen);
	xfree(blob);
d313 4
a316 12
	if (ssh_request_reply(auth, &msg, &msg) == 0) {
		buffer_free(&msg);
		return -1;
	}
	type = buffer_get_char(&msg);
	if (type == SSH_AGENT_FAILURE) {
		log("Agent admitted failure to sign using the key.");
	} else if (type != SSH2_AGENT_SIGN_RESPONSE) {
		fatal("Bad authentication response: %d", type);
	} else {
		ret = 0;
		*sigp = buffer_get_string(&msg, lenp);
d318 3
a320 3
	buffer_free(&msg);
	return ret;
}
d322 6
a327 1
/* Encode key for a message to the agent. */
d329 2
a330 15
void
ssh_encode_identity_rsa(Buffer *b, RSA *key, const char *comment)
{
	buffer_clear(b);
	buffer_put_char(b, SSH_AGENTC_ADD_RSA_IDENTITY);
	buffer_put_int(b, BN_num_bits(key->n));
	buffer_put_bignum(b, key->n);
	buffer_put_bignum(b, key->e);
	buffer_put_bignum(b, key->d);
	/* To keep within the protocol: p < q for ssh. in SSL p > q */
	buffer_put_bignum(b, key->iqmp);	/* ssh key->u */
	buffer_put_bignum(b, key->q);	/* ssh key->p, SSL key->q */
	buffer_put_bignum(b, key->p);	/* ssh key->q, SSL key->p */
	buffer_put_string(b, comment, strlen(comment));
}
d332 2
a333 12
void
ssh_encode_identity_dsa(Buffer *b, DSA *key, const char *comment)
{
	buffer_clear(b);
	buffer_put_char(b, SSH2_AGENTC_ADD_IDENTITY);
	buffer_put_cstring(b, KEX_DSS);
	buffer_put_bignum2(b, key->p);
	buffer_put_bignum2(b, key->q);
	buffer_put_bignum2(b, key->g);
	buffer_put_bignum2(b, key->pub_key);
	buffer_put_bignum2(b, key->priv_key);
	buffer_put_string(b, comment, strlen(comment));
d342 2
a343 1
ssh_add_identity(AuthenticationConnection *auth, Key *key, const char *comment)
d345 3
a347 2
	Buffer msg;
	int type;
d349 12
a360 1
	buffer_init(&msg);
d362 11
a372 9
	switch (key->type) {
	case KEY_RSA:
		ssh_encode_identity_rsa(&msg, key->rsa, comment);
		break;
	case KEY_DSA:
		ssh_encode_identity_dsa(&msg, key->dsa, comment);
		break;
	default:
		buffer_free(&msg);
a373 1
		break;
d375 37
a411 2
	if (ssh_request_reply(auth, &msg, &msg) == 0) {
		buffer_free(&msg);
d413 6
d420 2
a421 3
	type = buffer_get_char(&msg);
	buffer_free(&msg);
	return decode_reply(type);
d430 1
a430 1
ssh_remove_identity(AuthenticationConnection *auth, Key *key)
d432 22
a453 19
	Buffer msg;
	int type;
	unsigned char *blob;
	unsigned int blen;

	buffer_init(&msg);

	if (key->type == KEY_RSA) {
		buffer_put_char(&msg, SSH_AGENTC_REMOVE_RSA_IDENTITY);
		buffer_put_int(&msg, BN_num_bits(key->rsa->n));
		buffer_put_bignum(&msg, key->rsa->e);
		buffer_put_bignum(&msg, key->rsa->n);
	} else if (key->type == KEY_DSA) {
		dsa_make_key_blob(key, &blob, &blen);
		buffer_put_char(&msg, SSH2_AGENTC_REMOVE_IDENTITY);
		buffer_put_string(&msg, blob, blen);
		xfree(blob);
	} else {
		buffer_free(&msg);
d456 39
a494 2
	if (ssh_request_reply(auth, &msg, &msg) == 0) {
		buffer_free(&msg);
d496 6
d503 2
a504 3
	type = buffer_get_char(&msg);
	buffer_free(&msg);
	return decode_reply(type);
d513 1
a513 1
ssh_remove_all_identities(AuthenticationConnection *auth, int version)
d515 3
a517 5
	Buffer msg;
	int type;
	int code = (version==1) ?
		SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES :
		SSH2_AGENTC_REMOVE_ALL_IDENTITIES;
d519 3
a521 2
	buffer_init(&msg);
	buffer_put_char(&msg, code);
d523 3
a525 2
	if (ssh_request_reply(auth, &msg, &msg) == 0) {
		buffer_free(&msg);
d528 34
a561 4
	type = buffer_get_char(&msg);
	buffer_free(&msg);
	return decode_reply(type);
}
d563 2
a564 3
int 
decode_reply(int type)
{
d567 1
a567 1
		log("SSH_AGENT_FAILURE");
d570 1
d573 2
a574 1
		fatal("Bad response from authentication agent: %d", type);
@


1.19.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a13 6
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
d15 1
a15 10
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
a16 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d20 1
a20 1
RCSID("$OpenBSD: authfd.c,v 1.29 2000/10/09 21:51:00 markus Exp $");
a35 1
#include "compat.h"
a39 4
/* macro to check for "agent failure" message */
#define agent_failed(x) \
    ((x == SSH_AGENT_FAILURE) || (x == SSH_COM_AGENT2_FAILURE))

d222 1
a222 1
	if (agent_failed(type)) {
d321 1
a321 1
	if (agent_failed(type)) {
a344 1
	extern int datafellows;
d348 1
a348 1
	int type, flags = 0;
a353 3
	if (datafellows & SSH_BUG_SIGBLOB)
		flags = SSH_AGENT_OLD_SIGNATURE;

a357 1
	buffer_put_int(&msg, flags);
d365 1
a365 1
	if (agent_failed(type)) {
a511 1
	case SSH_COM_AGENT2_FAILURE:
@


1.19.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d38 1
a38 3
RCSID("$OpenBSD: authfd.c,v 1.35 2001/02/04 15:32:22 stevesk Exp $");

#include <openssl/evp.h>
d46 4
a51 1
#include "cipher.h"
d53 1
a54 2
#include "log.h"
#include "atomicio.h"
d66 1
a66 1
ssh_get_authentication_socket(void)
d171 1
a171 1
ssh_get_authentication_connection(void)
d210 2
a211 2
int
ssh_get_num_identities(AuthenticationConnection *auth, int version)
d226 1
a226 1
		return 0;
d239 1
a239 1
		return 0;
d246 1
a246 1
		return 0;
d257 2
a258 10
	return auth->howmany;
}

Key *
ssh_get_first_identity(AuthenticationConnection *auth, char **comment, int version)
{
	/* get number of identities and return the first entry (if any). */
	if (ssh_get_num_identities(auth, version) > 0)
		return ssh_get_next_identity(auth, comment, version);
	return NULL;
d264 3
a266 3
	u_int bits;
	u_char *blob;
	u_int blen;
d279 1
a279 1
		key = key_new(KEY_RSA1);
d291 1
a291 1
		key = key_from_blob(blob, blen);
d314 3
a316 3
    u_char session_id[16],
    u_int response_type,
    u_char response[16])
d323 1
a323 1
	if (key->type != KEY_RSA1)
d365 2
a366 2
    u_char **sigp, int *lenp,
    u_char *data, int datalen)
d370 2
a371 2
	u_char *blob;
	u_int blen;
d375 1
a375 1
	if (key_to_blob(key, &blob, &blen) == 0)
d408 1
a408 1
ssh_encode_identity_rsa1(Buffer *b, RSA *key, const char *comment)
d424 1
a424 1
ssh_encode_identity_ssh2(Buffer *b, Key *key, const char *comment)
d428 7
a434 19
	buffer_put_cstring(b, key_ssh_name(key));
	switch(key->type){
	case KEY_RSA:
		buffer_put_bignum2(b, key->rsa->n);
		buffer_put_bignum2(b, key->rsa->e);
		buffer_put_bignum2(b, key->rsa->d);
		buffer_put_bignum2(b, key->rsa->iqmp);
		buffer_put_bignum2(b, key->rsa->p);
		buffer_put_bignum2(b, key->rsa->q);
		break;
	case KEY_DSA:
		buffer_put_bignum2(b, key->dsa->p);
		buffer_put_bignum2(b, key->dsa->q);
		buffer_put_bignum2(b, key->dsa->g);
		buffer_put_bignum2(b, key->dsa->pub_key);
		buffer_put_bignum2(b, key->dsa->priv_key);
		break;
	}
	buffer_put_cstring(b, comment);
d451 2
a452 2
	case KEY_RSA1:
		ssh_encode_identity_rsa1(&msg, key->rsa, comment);
a453 1
	case KEY_RSA:
d455 1
a455 1
		ssh_encode_identity_ssh2(&msg, key, comment);
d481 2
a482 2
	u_char *blob;
	u_int blen;
d486 1
a486 1
	if (key->type == KEY_RSA1) {
d491 2
a492 2
	} else if (key->type == KEY_DSA || key->type == KEY_RSA) {
		key_to_blob(key, &blob, &blen);
d535 1
a535 1
int
@


1.19.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: authfd.c,v 1.38 2001/03/06 00:33:03 deraadt Exp $");
d78 1
a78 2
	len = SUN_LEN(&sunaddr)+1;
	sunaddr.sun_len = len;
a119 2
		if (l == -1 && (errno == EAGAIN || errno == EINTR))
			continue; 
a138 2
		if (l == -1 && (errno == EAGAIN || errno == EINTR))
			continue; 
d254 1
a254 1
		fatal("Too many identities in authentication reply: %d",
@


1.18
log
@whitespace cleanup
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.17 2000/04/12 09:39:09 markus Exp $");
d220 2
a221 2
		error("Warning: identity keysize mismatch: actual %d, announced %u",
		      BN_num_bits(n), bits);
@


1.17
log
@#include <ssl/foo.h> -> <openssh/foo.h>
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
RCSID("$Id: authfd.c,v 1.16 1999/12/15 19:43:10 markus Exp $");
d67 1
a67 1
void 
d111 1
a111 1
void 
d341 1
a341 1
int 
d429 1
a429 1
int 
d512 1
a512 1
int 
@


1.16
log
@keysize warnings talk about identity files
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.15 1999/12/06 20:15:26 deraadt Exp $");
d27 1
a27 1
#include <ssl/rsa.h>
@


1.15
log
@move atomicio into it's own file.  wrap all socket write()s which were doing
write(sock, buf, len) != len, with atomicio() calls.
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.14 1999/11/24 19:53:44 markus Exp $");
d220 1
a220 1
		error("Warning: keysize mismatch: actual %d, announced %u",
@


1.14
log
@KNF, final part 3
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.13 1999/11/24 00:26:00 deraadt Exp $");
d143 1
a143 1
	if (write(auth->fd, msg, 5) != 5) {
d268 3
a270 3
	if (write(auth->fd, buf, 4) != 4 ||
	    write(auth->fd, buffer_ptr(&buffer), buffer_len(&buffer)) !=
	    buffer_len(&buffer)) {
d367 3
a369 3
	if (write(auth->fd, buf, 4) != 4 ||
	    write(auth->fd, buffer_ptr(&buffer), buffer_len(&buffer)) !=
	    buffer_len(&buffer)) {
d448 3
a450 3
	if (write(auth->fd, buf, 4) != 4 ||
	    write(auth->fd, buffer_ptr(&buffer), buffer_len(&buffer)) !=
	    buffer_len(&buffer)) {
d524 1
a524 1
	if (write(auth->fd, buf, 5) != 5) {
@


1.13
log
@much more KNF
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.12 1999/11/23 22:25:52 markus Exp $");
d61 5
a65 3
/* Closes the agent socket if it should be closed (depends on how it was
   obtained).  The argument must have been returned by
   ssh_get_authentication_socket(). */
d74 7
a80 5
/* Opens and connects a private socket for communication with the
   authentication agent.  Returns the file descriptor (which must be
   shut down and closed by the caller when no longer needed).
   Returns NULL if an error occurred and the connection could not be
   opened. */
d90 4
a93 2
	/* Fail if we couldn't obtain a connection.  This happens if we
	   exited due to a timeout. */
a96 1
	/* Applocate the connection structure and initialize it. */
d106 4
a109 2
/* Closes the connection to the authentication agent and frees any associated
   memory. */
d120 6
a125 4
/* Returns the first authentication identity held by the agent.
   Returns true if an identity is available, 0 otherwise.
   The caller must initialize the integers before the call, and free the
   comment after a successful call (before calling ssh_get_next_identity). */
d134 4
a137 2
	/* Send a message to the agent requesting for a list of the
	   identities it can represent. */
d158 4
a161 2
	/* Extract the length, and check it for sanity.  (We cannot trust
	   authentication agents). */
d193 6
a198 4
/* Returns the next authentication identity for the agent.  Other functions
   can be called between this and ssh_get_first_identity or two calls of this
   function.  This returns 0 if there are no more identities.  The caller
   must free comment after a successful return. */
d210 4
a213 2
	/* Get the next entry from the packet.  These will abort with a
	   fatal error if the packet is too short or contains corrupt data. */
d229 7
a235 5
/* Generates a random challenge, sends it to the agent, and waits for response
   from the agent.  Returns true (non-zero) if the agent gave the correct
   answer, zero otherwise.  Response type selects the style of response
   desired, with 0 corresponding to protocol version 1.0 (no longer supported)
   and 1 corresponding to protocol version 1.1. */
d276 4
a279 2
	/* Wait for response from the agent.  First read the length of the
	   response packet. */
d322 4
a325 2
	/* Get the response from the packet.  This will abort with a fatal
	   error if the packet is corrupt. */
d336 4
a339 2
/* Adds an identity to the authentication server.  This call is not meant to
   be used by normal applications. */
d424 4
a427 2
/* Removes an identity from the authentication server.  This call is not meant
   to be used by normal applications. */
d456 4
a459 2
	/* Wait for response from the agent.  First read the length of the
	   response packet. */
d507 4
a510 2
/* Removes all identities from the agent.  This call is not meant
   to be used by normal applications. */
d528 4
a531 2
	/* Wait for response from the agent.  First read the length of the
	   response packet. */
@


1.12
log
@KNF part 1
@
text
@d2 13
a14 13

authfd.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Wed Mar 29 01:30:28 1995 ylo

Functions for connecting the local authentication agent.

*/
d17 1
a17 1
RCSID("$Id: authfd.c,v 1.11 1999/11/18 11:09:39 ho Exp $");
@


1.11
log
@Integers should not be printed with %s
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.10 1999/11/16 22:52:55 markus Exp $");
d34 25
a58 29
  const char *authsocket;
  int sock;
  struct sockaddr_un sunaddr;

  authsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);
  if (!authsocket)
    return -1;

  sunaddr.sun_family = AF_UNIX;
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
  
  sock = socket(AF_UNIX, SOCK_STREAM, 0);
  if (sock < 0)
    return -1;

  /* close on exec */
  if (fcntl(sock, F_SETFD, 1) == -1)
    {
      close(sock);
      return -1;
    }
  
  if (connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0)
    {
      close(sock);
      return -1;
    }

  return sock;
d62 1
a62 1
   obtained).  The argument must have been returned by 
d65 2
a66 1
void ssh_close_authentication_socket(int sock)
d68 2
a69 2
  if (getenv(SSH_AUTHSOCKET_ENV_NAME))
    close(sock);
d78 2
a79 1
AuthenticationConnection *ssh_get_authentication_connection()
d81 2
a82 16
  AuthenticationConnection *auth;
  int sock;
  
  sock = ssh_get_authentication_socket();

  /* Fail if we couldn't obtain a connection.  This happens if we exited
     due to a timeout. */
  if (sock < 0)
    return NULL;

  /* Applocate the connection structure and initialize it. */
  auth = xmalloc(sizeof(*auth));
  auth->fd = sock;
  buffer_init(&auth->packet);
  buffer_init(&auth->identities);
  auth->howmany = 0;
d84 15
a98 1
  return auth;
d104 2
a105 1
void ssh_close_authentication_connection(AuthenticationConnection *ac)
d107 4
a110 5
  buffer_free(&ac->packet);
  buffer_free(&ac->identities);
  close(ac->fd);
  /* Free the connection data structure. */
  xfree(ac);
d122 2
a123 2
  unsigned char msg[8192];
  int len, l;
d125 40
a164 55
  /* Send a message to the agent requesting for a list of the identities
     it can represent. */
  msg[0] = 0;
  msg[1] = 0;
  msg[2] = 0;
  msg[3] = 1;
  msg[4] = SSH_AGENTC_REQUEST_RSA_IDENTITIES;
  if (write(auth->fd, msg, 5) != 5)
    {
      error("write auth->fd: %.100s", strerror(errno));
      return 0;
    }

  /* Read the length of the response.  XXX implement timeouts here. */
  len = 4;
  while (len > 0)
    {
      l = read(auth->fd, msg + 4 - len, len);
      if (l <= 0)
	{
	  error("read auth->fd: %.100s", strerror(errno));
	  return 0;
	}
      len -= l;
    }

  /* Extract the length, and check it for sanity.  (We cannot trust
     authentication agents). */
  len = GET_32BIT(msg);
  if (len < 1 || len > 256*1024)
    fatal("Authentication reply message too long: %d\n", len);

  /* Read the packet itself. */
  buffer_clear(&auth->identities);
  while (len > 0)
    {
      l = len;
      if (l > sizeof(msg))
	l = sizeof(msg);
      l = read(auth->fd, msg, l);
      if (l <= 0)
	fatal("Incomplete authentication reply.");
      buffer_append(&auth->identities, (char *)msg, l);
      len -= l;
    }
  
  /* Get message type, and verify that we got a proper answer. */
  buffer_get(&auth->identities, (char *)msg, 1);
  if (msg[0] != SSH_AGENT_RSA_IDENTITIES_ANSWER)
    fatal("Bad authentication reply message type: %d", msg[0]);
  
  /* Get the number of entries in the response and check it for sanity. */
  auth->howmany = buffer_get_int(&auth->identities);
  if (auth->howmany > 1024)
    fatal("Too many identities in authentication reply: %d\n", auth->howmany);
d166 12
a177 2
  /* Return the first entry (if any). */
  return ssh_get_next_identity(auth, e, n, comment);
d189 1
a189 1
  unsigned int bits;
d191 14
a204 14
  /* Return failure if no more entries. */
  if (auth->howmany <= 0)
    return 0;

  /* Get the next entry from the packet.  These will abort with a fatal
     error if the packet is too short or contains corrupt data. */
  bits = buffer_get_int(&auth->identities);
  buffer_get_bignum(&auth->identities, e);
  buffer_get_bignum(&auth->identities, n);
  *comment = buffer_get_string(&auth->identities, NULL);

  if (bits != BN_num_bits(n))
    error("Warning: keysize mismatch: actual %d, announced %u",
	  BN_num_bits(n), bits);
d206 2
a207 2
  /* Decrement the number of remaining entries. */
  auth->howmany--;
d209 1
a209 1
  return 1;
d220 1
a220 1
		      BIGNUM *e, BIGNUM *n, BIGNUM *challenge,
d225 87
a311 95
  Buffer buffer;
  unsigned char buf[8192];
  int len, l, i;

  /* Response type 0 is no longer supported. */
  if (response_type == 0)
    fatal("Compatibility with ssh protocol version 1.0 no longer supported.");

  /* Format a message to the agent. */
  buf[0] = SSH_AGENTC_RSA_CHALLENGE;
  buffer_init(&buffer);
  buffer_append(&buffer, (char *)buf, 1);
  buffer_put_int(&buffer, BN_num_bits(n));
  buffer_put_bignum(&buffer, e);
  buffer_put_bignum(&buffer, n);
  buffer_put_bignum(&buffer, challenge);
  buffer_append(&buffer, (char *)session_id, 16);
  buffer_put_int(&buffer, response_type);

  /* Get the length of the message, and format it in the buffer. */
  len = buffer_len(&buffer);
  PUT_32BIT(buf, len);

  /* Send the length and then the packet to the agent. */
  if (write(auth->fd, buf, 4) != 4 ||
      write(auth->fd, buffer_ptr(&buffer), buffer_len(&buffer)) !=
        buffer_len(&buffer))
    {
      error("Error writing to authentication socket.");
    error_cleanup:
      buffer_free(&buffer);
      return 0;
    }

  /* Wait for response from the agent.  First read the length of the
     response packet. */
  len = 4;
  while (len > 0)
    {
      l = read(auth->fd, buf + 4 - len, len);
      if (l <= 0)
	{
	  error("Error reading response length from authentication socket.");
	  goto error_cleanup;
	}
      len -= l;
    }

  /* Extract the length, and check it for sanity. */
  len = GET_32BIT(buf);
  if (len > 256*1024)
    fatal("Authentication response too long: %d", len);

  /* Read the rest of the response in tothe buffer. */
  buffer_clear(&buffer);
  while (len > 0)
    {
      l = len;
      if (l > sizeof(buf))
	l = sizeof(buf);
      l = read(auth->fd, buf, l);
      if (l <= 0)
	{
	  error("Error reading response from authentication socket.");
	  goto error_cleanup;
	}
      buffer_append(&buffer, (char *)buf, l);
      len -= l;
    }

  /* Get the type of the packet. */
  buffer_get(&buffer, (char *)buf, 1);

  /* Check for agent failure message. */
  if (buf[0] == SSH_AGENT_FAILURE)
    {
      log("Agent admitted failure to authenticate using the key.");
      goto error_cleanup;
    }
      
  /* Now it must be an authentication response packet. */
  if (buf[0] != SSH_AGENT_RSA_RESPONSE)
    fatal("Bad authentication response: %d", buf[0]);

  /* Get the response from the packet.  This will abort with a fatal error
     if the packet is corrupt. */
  for (i = 0; i < 16; i++)
    response[i] = buffer_get_char(&buffer);

  /* The buffer containing the packet is no longer needed. */
  buffer_free(&buffer);

  /* Correct answer. */
  return 1;
}  
d316 3
a318 2
int ssh_add_identity(AuthenticationConnection *auth,
		     RSA *key, const char *comment)
d320 78
a397 85
  Buffer buffer;
  unsigned char buf[8192];
  int len, l, type;

  /* Format a message to the agent. */
  buffer_init(&buffer);
  buffer_put_char(&buffer, SSH_AGENTC_ADD_RSA_IDENTITY);
  buffer_put_int(&buffer, BN_num_bits(key->n));
  buffer_put_bignum(&buffer, key->n);
  buffer_put_bignum(&buffer, key->e);
  buffer_put_bignum(&buffer, key->d);
  /* To keep within the protocol: p < q for ssh. in SSL p > q */
  buffer_put_bignum(&buffer, key->iqmp); /* ssh key->u */
  buffer_put_bignum(&buffer, key->q); /* ssh key->p, SSL key->q */
  buffer_put_bignum(&buffer, key->p); /* ssh key->q, SSL key->p */
  buffer_put_string(&buffer, comment, strlen(comment));

  /* Get the length of the message, and format it in the buffer. */
  len = buffer_len(&buffer);
  PUT_32BIT(buf, len);

  /* Send the length and then the packet to the agent. */
  if (write(auth->fd, buf, 4) != 4 ||
      write(auth->fd, buffer_ptr(&buffer), buffer_len(&buffer)) !=
        buffer_len(&buffer))
    {
      error("Error writing to authentication socket.");
    error_cleanup:
      buffer_free(&buffer);
      return 0;
    }

  /* Wait for response from the agent.  First read the length of the
     response packet. */
  len = 4;
  while (len > 0)
    {
      l = read(auth->fd, buf + 4 - len, len);
      if (l <= 0)
	{
	  error("Error reading response length from authentication socket.");
	  goto error_cleanup;
	}
      len -= l;
    }

  /* Extract the length, and check it for sanity. */
  len = GET_32BIT(buf);
  if (len > 256*1024)
    fatal("Add identity response too long: %d", len);

  /* Read the rest of the response in tothe buffer. */
  buffer_clear(&buffer);
  while (len > 0)
    {
      l = len;
      if (l > sizeof(buf))
	l = sizeof(buf);
      l = read(auth->fd, buf, l);
      if (l <= 0)
	{
	  error("Error reading response from authentication socket.");
	  goto error_cleanup;
	}
      buffer_append(&buffer, (char *)buf, l);
      len -= l;
    }

  /* Get the type of the packet. */
  type = buffer_get_char(&buffer);
  switch (type)
    {
    case SSH_AGENT_FAILURE:
      buffer_free(&buffer);
      return 0;
    case SSH_AGENT_SUCCESS:
      buffer_free(&buffer);
      return 1;
    default:
      fatal("Bad response to add identity from authentication agent: %d", 
	    type);
    }
  /*NOTREACHED*/
  return 0;
}  
d399 1
a399 1
/* Removes an identity from the authentication server.  This call is not meant 
d402 2
a403 1
int ssh_remove_identity(AuthenticationConnection *auth, RSA *key)
d405 55
a459 79
  Buffer buffer;
  unsigned char buf[8192];
  int len, l, type;

  /* Format a message to the agent. */
  buffer_init(&buffer);
  buffer_put_char(&buffer, SSH_AGENTC_REMOVE_RSA_IDENTITY);
  buffer_put_int(&buffer, BN_num_bits(key->n));
  buffer_put_bignum(&buffer, key->e);
  buffer_put_bignum(&buffer, key->n);

  /* Get the length of the message, and format it in the buffer. */
  len = buffer_len(&buffer);
  PUT_32BIT(buf, len);

  /* Send the length and then the packet to the agent. */
  if (write(auth->fd, buf, 4) != 4 ||
      write(auth->fd, buffer_ptr(&buffer), buffer_len(&buffer)) !=
        buffer_len(&buffer))
    {
      error("Error writing to authentication socket.");
    error_cleanup:
      buffer_free(&buffer);
      return 0;
    }

  /* Wait for response from the agent.  First read the length of the
     response packet. */
  len = 4;
  while (len > 0)
    {
      l = read(auth->fd, buf + 4 - len, len);
      if (l <= 0)
	{
	  error("Error reading response length from authentication socket.");
	  goto error_cleanup;
	}
      len -= l;
    }

  /* Extract the length, and check it for sanity. */
  len = GET_32BIT(buf);
  if (len > 256*1024)
    fatal("Remove identity response too long: %d", len);

  /* Read the rest of the response in tothe buffer. */
  buffer_clear(&buffer);
  while (len > 0)
    {
      l = len;
      if (l > sizeof(buf))
	l = sizeof(buf);
      l = read(auth->fd, buf, l);
      if (l <= 0)
	{
	  error("Error reading response from authentication socket.");
	  goto error_cleanup;
	}
      buffer_append(&buffer, (char *)buf, l);
      len -= l;
    }

  /* Get the type of the packet. */
  type = buffer_get_char(&buffer);
  switch (type)
    {
    case SSH_AGENT_FAILURE:
      buffer_free(&buffer);
      return 0;
    case SSH_AGENT_SUCCESS:
      buffer_free(&buffer);
      return 1;
    default:
      fatal("Bad response to remove identity from authentication agent: %d", 
	    type);
    }
  /*NOTREACHED*/
  return 0;
}  
d461 18
a478 1
/* Removes all identities from the agent.  This call is not meant 
d481 2
a482 1
int ssh_remove_all_identities(AuthenticationConnection *auth)
d484 62
a545 69
  Buffer buffer;
  unsigned char buf[8192];
  int len, l, type;

  /* Get the length of the message, and format it in the buffer. */
  PUT_32BIT(buf, 1);
  buf[4] = SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES;

  /* Send the length and then the packet to the agent. */
  if (write(auth->fd, buf, 5) != 5)
    {
      error("Error writing to authentication socket.");
      return 0;
    }

  /* Wait for response from the agent.  First read the length of the
     response packet. */
  len = 4;
  while (len > 0)
    {
      l = read(auth->fd, buf + 4 - len, len);
      if (l <= 0)
	{
	  error("Error reading response length from authentication socket.");
	  return 0;
	}
      len -= l;
    }

  /* Extract the length, and check it for sanity. */
  len = GET_32BIT(buf);
  if (len > 256*1024)
    fatal("Remove identity response too long: %d", len);

  /* Read the rest of the response into the buffer. */
  buffer_init(&buffer);
  while (len > 0)
    {
      l = len;
      if (l > sizeof(buf))
	l = sizeof(buf);
      l = read(auth->fd, buf, l);
      if (l <= 0)
	{
	  error("Error reading response from authentication socket.");
	  buffer_free(&buffer);
	  return 0;
	}
      buffer_append(&buffer, (char *)buf, l);
      len -= l;
    }

  /* Get the type of the packet. */
  type = buffer_get_char(&buffer);
  switch (type)
    {
    case SSH_AGENT_FAILURE:
      buffer_free(&buffer);
      return 0;
    case SSH_AGENT_SUCCESS:
      buffer_free(&buffer);
      return 1;
    default:
      fatal("Bad response to remove identity from authentication agent: %d", 
	    type);
    }
  /*NOTREACHED*/
  return 0;
}  
@


1.10
log
@close-on-exec for auth-socket, ok deraadt
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.9 1999/11/15 20:53:24 markus Exp $");
d210 1
a210 1
    error("Warning: keysize mismatch: actual %d, announced %s",
@


1.9
log
@the keysize of rsa-parameter 'n' is passed implizit,
a few more checks and warnings about 'pretended' keysizes.
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.8 1999/10/14 18:17:41 markus Exp $");
d48 7
@


1.8
log
@fix old connect() race security-bug for ssh-agent and agent-forwarding
by removing the connect() junk, with the following restrictions:
1) change the version to "OpenSSH-1.1":
   agent-forwarding will work only between OpenSSH-1.1 client and
   OpenSSH-1.1 server
2) renamed the environment variable of OpenSSH-1.1 to
   "SSH_AUTH_SOCKET", since useing OpenSSH-1.0 ssh-add against the new
   ssh-agent does not work
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.7 1999/10/05 22:18:52 markus Exp $");
d115 1
a115 1
		       int *bitsp, BIGNUM *e, BIGNUM *n, char **comment)
d177 1
a177 1
  return ssh_get_next_identity(auth, bitsp, e, n, comment);
d187 1
a187 1
		      int *bitsp, BIGNUM *e, BIGNUM *n, char **comment)
d189 2
d197 1
a197 1
  *bitsp = buffer_get_int(&auth->identities);
d202 4
d220 1
a220 1
		      int bits, BIGNUM *e, BIGNUM *n, BIGNUM *challenge,
d237 1
a237 1
  buffer_put_int(&buffer, bits);
@


1.7
log
@move auth-sockets to private dir
delete minfd residua
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.6 1999/10/04 20:45:01 markus Exp $");
d32 1
a32 1
ssh_get_authentication_fd()
d60 1
a60 1
   ssh_get_authentication_fd(). */
a67 89
/* Dummy alarm used to prevent waiting for connection from the
   authentication agent indefinitely. */

static void dummy_alarm_handler(int sig)
{
  /* Do nothing; a cought signal will just cause accept to return. */
}

/* Opens a socket to the authentication server.  Returns the number of
   that socket, or -1 if no connection could be made. */

int ssh_get_authentication_connection_fd()
{
  int authfd;
  int listen_sock, sock, port, addrlen;
  int old_timeout;
  void (*old_handler)();
  struct sockaddr_in sin;
  char msg[3];

  /* Get the the socket number from the environment.  This is the socket
     used to obtain the real authentication socket. */
  authfd = ssh_get_authentication_fd();
  if (authfd == -1)
    return -1;

  /* Create a local socket for listening. */
  listen_sock = socket(AF_INET, SOCK_STREAM, 0);
  if (listen_sock == -1)
    {
      ssh_close_authentication_socket(authfd);
      return -1;
    }

  /* Bind the socket to random unprivileged port. */
  memset(&sin, 0, sizeof(sin));
  sin.sin_family = AF_INET;
  do
    {
      port = 32768 + (rand() % 30000);
      sin.sin_port = htons(port);
    }
  while (bind(listen_sock, (struct sockaddr *)&sin, sizeof(sin)) < 0 &&
	 errno == EADDRINUSE);
  
  /* Start listening for connections on the socket. */
  if (listen(listen_sock, 1) < 0)
    {
      error("listen: %.100s", strerror(errno));
      close(listen_sock);
      ssh_close_authentication_socket(authfd);
      return -1;
    }

  /* Send a message to the authentication fd requesting the agent or its
     local representative to connect to the given socket.  Note that
     we use send() to get the packet sent atomically (there can be several
     clients trying to use the same authentication fd simultaneously). */
  msg[0] = (char)SSH_AUTHFD_CONNECT;
  PUT_16BIT(msg + 1, port);
  if (send(authfd, msg, 3, 0) < 0)
    {
      shutdown(listen_sock, SHUT_RDWR);
      close(listen_sock);
      ssh_close_authentication_socket(authfd);
      return -1;
    }

  /* Setup a timeout so we won't wait for the connection indefinitely. */
  old_timeout = alarm(120);
  old_handler = signal(SIGALRM, dummy_alarm_handler);
  
  /* Wait for the connection from the agent or its representative. */
  addrlen = sizeof(sin);
  sock = accept(listen_sock, (struct sockaddr *)&sin, &addrlen);

  /* Remove the alarm (restore its old values). */
  alarm(old_timeout);
  signal(SIGALRM, old_handler);

  /* Close the socket we used for listening.  It is no longer needed.
     (The authentication fd and the new connection still remain open.) */
  shutdown(listen_sock, SHUT_RDWR);
  close(listen_sock);
  ssh_close_authentication_socket(authfd);

  return sock;
}  

d79 1
a79 2
  /* Get a connection to the authentication agent. */
  sock = ssh_get_authentication_connection_fd();
d104 2
a565 16

/* Closes the connection to the authentication agent. */

void ssh_close_authentication(AuthenticationConnection *auth)
{
  /* Close the connection. */
  shutdown(auth->fd, SHUT_RDWR);
  close(auth->fd);

  /* Free the buffers. */
  buffer_free(&auth->packet);
  buffer_free(&auth->identities);

  /* Free the connection data structure. */
  xfree(auth);
}
@


1.6
log
@nuke genminfd/AUTH_FD
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.5 1999/10/03 19:22:38 deraadt Exp $");
d34 1
a34 1
  const char *authfd, *authsocket;
@


1.5
log
@use SHUT_* symbols
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.4 1999/09/30 08:34:24 deraadt Exp $");
a36 7

  /* Get the file descriptor number from environment. */
  authfd = getenv(SSH_AUTHFD_ENV_NAME);

  /* Convert the value to an integer and return it if we got a value. */
  if (authfd)
    return atoi(authfd);
@


1.4
log
@even smaller
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.3 1999/09/29 21:14:15 deraadt Exp $");
d137 1
a137 1
      shutdown(listen_sock, 2);
d157 1
a157 1
  shutdown(listen_sock, 2);
d667 1
a667 1
  shutdown(auth->fd, 2);
@


1.3
log
@numerous sprintf, strncpy, strcpy cleanups
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.2 1999/09/28 04:45:35 provos Exp $");
d56 1
a56 1
  if (connect(sock, (struct sockaddr *)&sunaddr, AF_UNIX_SIZE(sunaddr)) < 0)
d78 1
a78 1
static RETSIGTYPE dummy_alarm_handler(int sig)
d91 1
a91 1
  RETSIGTYPE (*old_handler)();
@


1.2
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d17 1
a17 1
RCSID("$Id: authfd.c,v 1.2 1999/05/04 11:58:26 bg Exp $");
d50 1
a50 1
  strncpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d27 2
d31 2
a32 1
int ssh_get_authentication_fd()
d208 3
a210 2
int ssh_get_first_identity(AuthenticationConnection *auth,
			   int *bitsp, MP_INT *e, MP_INT *n, char **comment)
d280 3
a282 2
int ssh_get_next_identity(AuthenticationConnection *auth,
			  int *bitsp, MP_INT *e, MP_INT *n, char **comment)
d291 2
a292 2
  buffer_get_mp_int(&auth->identities, e);
  buffer_get_mp_int(&auth->identities, n);
d307 6
a312 5
int ssh_decrypt_challenge(AuthenticationConnection *auth,
			  int bits, MP_INT *e, MP_INT *n, MP_INT *challenge,
			  unsigned char session_id[16],
			  unsigned int response_type,
			  unsigned char response[16])
d327 3
a329 3
  buffer_put_mp_int(&buffer, e);
  buffer_put_mp_int(&buffer, n);
  buffer_put_mp_int(&buffer, challenge);
d414 1
a414 1
		     RSAPrivateKey *key, const char *comment)
d423 8
a430 7
  buffer_put_int(&buffer, key->bits);
  buffer_put_mp_int(&buffer, &key->n);
  buffer_put_mp_int(&buffer, &key->e);
  buffer_put_mp_int(&buffer, &key->d);
  buffer_put_mp_int(&buffer, &key->u);
  buffer_put_mp_int(&buffer, &key->p);
  buffer_put_mp_int(&buffer, &key->q);
d505 1
a505 1
int ssh_remove_identity(AuthenticationConnection *auth, RSAPublicKey *key)
d514 3
a516 3
  buffer_put_int(&buffer, key->bits);
  buffer_put_mp_int(&buffer, &key->e);
  buffer_put_mp_int(&buffer, &key->n);
@

