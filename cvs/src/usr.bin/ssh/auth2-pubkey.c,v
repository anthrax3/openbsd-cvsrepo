head	1.71;
access;
symbols
	OPENBSD_6_2:1.71.0.4
	OPENBSD_6_2_BASE:1.71
	OPENBSD_6_1:1.62.0.4
	OPENBSD_6_1_BASE:1.62
	OPENBSD_6_0:1.55.0.6
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.53.0.2
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.41.0.4
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.30.0.4
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.2
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.4
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.2.0.8
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.6
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_0:1.2.0.2;
locks; strict;
comment	@ * @;


1.71
date	2017.09.07.23.48.09;	author djm;	state Exp;
branches;
next	1.70;
commitid	dD9BSudDf4XVyMLi;

1.70
date	2017.08.18.05.48.04;	author djm;	state Exp;
branches;
next	1.69;
commitid	OEyipntxYT5rK2fi;

1.69
date	2017.08.18.05.36.45;	author djm;	state Exp;
branches;
next	1.68;
commitid	VAPvuXREJeMOB6MT;

1.68
date	2017.06.24.06.34.38;	author djm;	state Exp;
branches;
next	1.67;
commitid	t1sqOvl7ysAY3CkV;

1.67
date	2017.05.31.10.54.00;	author markus;	state Exp;
branches;
next	1.66;
commitid	S8mXQQankLwOyhst;

1.66
date	2017.05.31.09.15.42;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	zCd5GrUCVAe14Y6J;

1.65
date	2017.05.30.14.29.59;	author markus;	state Exp;
branches;
next	1.64;
commitid	J58my16e4a8Rltt1;

1.64
date	2017.05.30.14.10.53;	author markus;	state Exp;
branches;
next	1.63;
commitid	YtVAQPzV4sHWCSyk;

1.63
date	2017.05.30.08.52.19;	author markus;	state Exp;
branches;
next	1.62;
commitid	AQD3o1zTZEMIcuBx;

1.62
date	2017.01.30.01.03.00;	author djm;	state Exp;
branches;
next	1.61;
commitid	tUNtXMS1k09co9Sp;

1.61
date	2016.12.30.22.08.02;	author djm;	state Exp;
branches;
next	1.60;
commitid	cjW7sOV0vIaEdthE;

1.60
date	2016.11.30.02.57.40;	author djm;	state Exp;
branches;
next	1.59;
commitid	RBXxsfvp5NR7LTy5;

1.59
date	2016.09.21.17.44.20;	author djm;	state Exp;
branches;
next	1.58;
commitid	tWJLVntmupX5qLRc;

1.58
date	2016.09.21.01.34.45;	author djm;	state Exp;
branches;
next	1.57;
commitid	VjrwAHvAyLA1IUg3;

1.57
date	2016.09.14.20.11.26;	author djm;	state Exp;
branches;
next	1.56;
commitid	IoFm7LjYRqOTzmsP;

1.56
date	2016.09.14.05.42.25;	author djm;	state Exp;
branches;
next	1.55;
commitid	TkKjivV9qAbf7Zj1;

1.55
date	2016.01.27.00.53.12;	author djm;	state Exp;
branches;
next	1.54;
commitid	6V6wPAHBdPrWyBTJ;

1.54
date	2015.10.27.01.44.45;	author djm;	state Exp;
branches;
next	1.53;
commitid	fOEEVuucmcPHlwYi;

1.53
date	2015.06.15.18.44.22;	author jsing;	state Exp;
branches;
next	1.52;
commitid	6SVOIB2GeGbhrNl6;

1.52
date	2015.06.15.18.42.19;	author jsing;	state Exp;
branches;
next	1.51;
commitid	IdeYO8dnsoR8Oh0E;

1.51
date	2015.05.21.06.43.30;	author djm;	state Exp;
branches;
next	1.50;
commitid	0jtBXwojTXMGT6Vz;

1.50
date	2015.05.21.06.38.35;	author djm;	state Exp;
branches;
next	1.49;
commitid	fwi980a5NURyJELN;

1.49
date	2015.05.04.06.10.48;	author djm;	state Exp;
branches;
next	1.48;
commitid	KfZDG8r2EByk0YBR;

1.48
date	2015.05.01.03.23.51;	author djm;	state Exp;
branches;
next	1.47;
commitid	weFq4BCuIOdeuIhV;

1.47
date	2015.02.17.00.14.05;	author djm;	state Exp;
branches;
next	1.46;
commitid	OQR4hZV5t1SuR5Zu;

1.46
date	2015.01.28.22.36.00;	author djm;	state Exp;
branches;
next	1.45;
commitid	P7KG9D8zB61mMUPV;

1.45
date	2015.01.13.07.39.19;	author djm;	state Exp;
branches;
next	1.44;
commitid	oriBpre3xTnTQZ4b;

1.44
date	2014.12.22.07.51.30;	author djm;	state Exp;
branches;
next	1.43;
commitid	CoaZC6mJ1akW0s9F;

1.43
date	2014.12.21.22.27.56;	author djm;	state Exp;
branches;
next	1.42;
commitid	EbtriidyZdsmXksl;

1.42
date	2014.12.04.02.24.32;	author djm;	state Exp;
branches;
next	1.41;
commitid	0YGyOuIh3H3xTolw;

1.41
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.40;
commitid	z7plx8Gkj6l2sxem;

1.40
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.39;
commitid	1h9UxAQmwdaqUzyX;

1.39
date	2013.12.30.23.52.27;	author djm;	state Exp;
branches;
next	1.38;

1.38
date	2013.06.21.00.34.49;	author djm;	state Exp;
branches;
next	1.37;

1.37
date	2013.05.19.02.38.28;	author djm;	state Exp;
branches;
next	1.36;

1.36
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2013.03.07.00.19.59;	author djm;	state Exp;
branches;
next	1.34;

1.34
date	2013.02.14.21.35.59;	author djm;	state Exp;
branches;
next	1.33;

1.33
date	2012.11.14.02.24.27;	author djm;	state Exp;
branches;
next	1.32;

1.32
date	2012.11.04.10.38.43;	author djm;	state Exp;
branches;
next	1.31;

1.31
date	2012.10.30.21.29.54;	author djm;	state Exp;
branches;
next	1.30;

1.30
date	2011.09.25.05.44.47;	author djm;	state Exp;
branches;
next	1.29;

1.29
date	2011.05.23.03.30.07;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2011.05.11.04.47.06;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2010.11.20.05.12.38;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.29.23.16.46;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2010.05.20.11.25.26;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2010.05.07.11.30.29;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2010.04.16.01.47.26;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2010.03.10.23.27.17;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2010.03.04.10.36.03;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.03.21.46.58;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2008.07.02.12.03.51;	author dtucker;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.13.14.18.51;	author dtucker;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.13.04.40.22;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.20.17.19.54;	author stevesk;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2004.12.11.01.48.56;	author dtucker;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2004.12.06.11.41.03;	author dtucker;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2004.01.19.21.25.15;	author markus;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2003.11.04.08.54.09;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.24.08.23.46;	author markus;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.31.11.35.15;	author markus;	state Exp;
branches
	1.2.2.1
	1.2.4.1
	1.2.6.1
	1.2.8.1;
next	1.1;

1.1
date	2002.05.25.18.51.07;	author markus;	state Exp;
branches;
next	;

1.2.2.1
date	2002.06.22.07.23.16;	author miod;	state Exp;
branches;
next	;

1.2.4.1
date	2002.06.26.15.52.13;	author jason;	state Exp;
branches;
next	;

1.2.6.1
date	2003.09.16.21.20.24;	author brad;	state Exp;
branches;
next	;

1.2.8.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.2.8.2;

1.2.8.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.4.2.1
date	2004.02.28.03.51.32;	author brad;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2004.08.19.22.37.30;	author brad;	state Exp;
branches;
next	;

1.6.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.7.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	;

1.9.4.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.10.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.71
log
@typo in comment
@
text
@/* $OpenBSD: auth2-pubkey.c,v 1.70 2017/08/18 05:48:04 djm Exp $ */
/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>

#include "xmalloc.h"
#include "ssh.h"
#include "ssh2.h"
#include "packet.h"
#include "buffer.h"
#include "log.h"
#include "misc.h"
#include "servconf.h"
#include "compat.h"
#include "sshkey.h"
#include "hostfile.h"
#include "auth.h"
#include "pathnames.h"
#include "uidswap.h"
#include "auth-options.h"
#include "canohost.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"
#include "authfile.h"
#include "match.h"
#include "ssherr.h"
#include "channels.h" /* XXX for session.h */
#include "session.h" /* XXX for child_set_env(); refactor? */

/* import */
extern ServerOptions options;
extern u_char *session_id2;
extern u_int session_id2_len;

static int
userauth_pubkey(struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	struct sshbuf *b;
	struct sshkey *key = NULL;
	char *pkalg, *userstyle = NULL, *fp = NULL;
	u_char *pkblob, *sig, have_sig;
	size_t blen, slen;
	int r, pktype;
	int authenticated = 0;

	if (!authctxt->valid) {
		debug2("%s: disabled because of invalid user", __func__);
		return 0;
	}
	if ((r = sshpkt_get_u8(ssh, &have_sig)) != 0)
		fatal("%s: sshpkt_get_u8 failed: %s", __func__, ssh_err(r));
	if (ssh->compat & SSH_BUG_PKAUTH) {
		debug2("%s: SSH_BUG_PKAUTH", __func__);
		if ((b = sshbuf_new()) == NULL)
			fatal("%s: sshbuf_new failed", __func__);
		/* no explicit pkalg given */
		/* so we have to extract the pkalg from the pkblob */
		/* XXX use sshbuf_from() */
		if ((r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||
		    (r = sshbuf_put(b, pkblob, blen)) != 0 ||
		    (r = sshbuf_get_cstring(b, &pkalg, NULL)) != 0)
			fatal("%s: failed: %s", __func__, ssh_err(r));
		sshbuf_free(b);
	} else {
		if ((r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||
		    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)
			fatal("%s: sshpkt_get_cstring failed: %s",
			    __func__, ssh_err(r));
	}
	pktype = sshkey_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		logit("%s: unsupported public key algorithm: %s",
		    __func__, pkalg);
		goto done;
	}
	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
		error("%s: could not parse key: %s", __func__, ssh_err(r));
		goto done;
	}
	if (key == NULL) {
		error("%s: cannot decode key: %s", __func__, pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error("%s: type mismatch for decoded key "
		    "(received %d, expected %d)", __func__, key->type, pktype);
		goto done;
	}
	if (sshkey_type_plain(key->type) == KEY_RSA &&
	    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {
		logit("Refusing RSA key because client uses unsafe "
		    "signature scheme");
		goto done;
	}
	fp = sshkey_fingerprint(key, options.fingerprint_hash, SSH_FP_DEFAULT);
	if (auth2_key_already_used(authctxt, key)) {
		logit("refusing previously-used %s key", sshkey_type(key));
		goto done;
	}
	if (match_pattern_list(sshkey_ssh_name(key),
	    options.pubkey_key_types, 0) != 1) {
		logit("%s: key type %s not in PubkeyAcceptedKeyTypes",
		    __func__, sshkey_ssh_name(key));
		goto done;
	}

	if (have_sig) {
		debug3("%s: have signature for %s %s",
		    __func__, sshkey_type(key), fp);
		if ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||
		    (r = sshpkt_get_end(ssh)) != 0)
			fatal("%s: %s", __func__, ssh_err(r));
		if ((b = sshbuf_new()) == NULL)
			fatal("%s: sshbuf_new failed", __func__);
		if (ssh->compat & SSH_OLD_SESSIONID) {
			if ((r = sshbuf_put(b, session_id2,
			    session_id2_len)) != 0)
				fatal("%s: sshbuf_put session id: %s",
				    __func__, ssh_err(r));
		} else {
			if ((r = sshbuf_put_string(b, session_id2,
			    session_id2_len)) != 0)
				fatal("%s: sshbuf_put_string session id: %s",
				    __func__, ssh_err(r));
		}
		/* reconstruct packet */
		xasprintf(&userstyle, "%s%s%s", authctxt->user,
		    authctxt->style ? ":" : "",
		    authctxt->style ? authctxt->style : "");
		if ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
		    (r = sshbuf_put_cstring(b, userstyle)) != 0 ||
		    (r = sshbuf_put_cstring(b, ssh->compat & SSH_BUG_PKSERVICE ?
		    "ssh-userauth" : authctxt->service)) != 0)
			fatal("%s: build packet failed: %s",
			    __func__, ssh_err(r));
		if (ssh->compat & SSH_BUG_PKAUTH) {
			if ((r = sshbuf_put_u8(b, have_sig)) != 0)
				fatal("%s: build packet failed: %s",
				    __func__, ssh_err(r));
		} else {
			if ((r = sshbuf_put_cstring(b, "publickey")) != 0 ||
			    (r = sshbuf_put_u8(b, have_sig)) != 0 ||
			    (r = sshbuf_put_cstring(b, pkalg) != 0))
				fatal("%s: build packet failed: %s",
				    __func__, ssh_err(r));
		}
		if ((r = sshbuf_put_string(b, pkblob, blen)) != 0)
			fatal("%s: build packet failed: %s",
			    __func__, ssh_err(r));
#ifdef DEBUG_PK
		sshbuf_dump(b, stderr);
#endif

		/* test for correct signature */
		authenticated = 0;
		if (PRIVSEP(user_key_allowed(authctxt->pw, key, 1)) &&
		    PRIVSEP(sshkey_verify(key, sig, slen, sshbuf_ptr(b),
		    sshbuf_len(b), ssh->compat)) == 0) {
			authenticated = 1;
		}
		sshbuf_free(b);
		free(sig);
		auth2_record_key(authctxt, authenticated, key);
	} else {
		debug("%s: test whether pkalg/pkblob are acceptable for %s %s",
		    __func__, sshkey_type(key), fp);
		if ((r = sshpkt_get_end(ssh)) != 0)
			fatal("%s: %s", __func__, ssh_err(r));

		/* XXX fake reply and always send PK_OK ? */
		/*
		 * XXX this allows testing whether a user is allowed
		 * to login: if you happen to have a valid pubkey this
		 * message is sent. the message is NEVER sent at all
		 * if a user is not allowed to login. is this an
		 * issue? -markus
		 */
		if (PRIVSEP(user_key_allowed(authctxt->pw, key, 0))) {
			if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))
			    != 0 ||
			    (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||
			    (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||
			    (r = sshpkt_send(ssh)) != 0)
				fatal("%s: %s", __func__, ssh_err(r));
			ssh_packet_write_wait(ssh);
			authctxt->postponed = 1;
		}
	}
	if (authenticated != 1)
		auth_clear_options();
done:
	debug2("%s: authenticated %d pkalg %s", __func__, authenticated, pkalg);
	sshkey_free(key);
	free(userstyle);
	free(pkalg);
	free(pkblob);
	free(fp);
	return authenticated;
}

static int
match_principals_option(const char *principal_list, struct sshkey_cert *cert)
{
	char *result;
	u_int i;

	/* XXX percent_expand() sequences for authorized_principals? */

	for (i = 0; i < cert->nprincipals; i++) {
		if ((result = match_list(cert->principals[i],
		    principal_list, NULL)) != NULL) {
			debug3("matched principal from key options \"%.100s\"",
			    result);
			free(result);
			return 1;
		}
	}
	return 0;
}

static int
process_principals(FILE *f, const char *file, struct passwd *pw,
    const struct sshkey_cert *cert)
{
	char line[SSH_MAX_PUBKEY_BYTES], *cp, *ep, *line_opts;
	u_long linenum = 0;
	u_int i, found_principal = 0;

	while (read_keyfile_line(f, file, line, sizeof(line), &linenum) != -1) {
		/* Always consume entire input */
		if (found_principal)
			continue;
		/* Skip leading whitespace. */
		for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
			;
		/* Skip blank and comment lines. */
		if ((ep = strchr(cp, '#')) != NULL)
			*ep = '\0';
		if (!*cp || *cp == '\n')
			continue;
		/* Trim trailing whitespace. */
		ep = cp + strlen(cp) - 1;
		while (ep > cp && (*ep == '\n' || *ep == ' ' || *ep == '\t'))
			*ep-- = '\0';
		/*
		 * If the line has internal whitespace then assume it has
		 * key options.
		 */
		line_opts = NULL;
		if ((ep = strrchr(cp, ' ')) != NULL ||
		    (ep = strrchr(cp, '\t')) != NULL) {
			for (; *ep == ' ' || *ep == '\t'; ep++)
				;
			line_opts = cp;
			cp = ep;
		}
		for (i = 0; i < cert->nprincipals; i++) {
			if (strcmp(cp, cert->principals[i]) == 0) {
				debug3("%s:%lu: matched principal \"%.100s\"",
				    file, linenum, cert->principals[i]);
				if (auth_parse_options(pw, line_opts,
				    file, linenum) != 1)
					continue;
				found_principal = 1;
				continue;
			}
		}
	}
	return found_principal;
}

static int
match_principals_file(char *file, struct passwd *pw, struct sshkey_cert *cert)
{
	FILE *f;
	int success;

	temporarily_use_uid(pw);
	debug("trying authorized principals file %s", file);
	if ((f = auth_openprincipals(file, pw, options.strict_modes)) == NULL) {
		restore_uid();
		return 0;
	}
	success = process_principals(f, file, pw, cert);
	fclose(f);
	restore_uid();
	return success;
}

/*
 * Checks whether principal is allowed in output of command.
 * returns 1 if the principal is allowed or 0 otherwise.
 */
static int
match_principals_command(struct passwd *user_pw, const struct sshkey *key)
{
	const struct sshkey_cert *cert = key->cert;
	FILE *f = NULL;
	int r, ok, found_principal = 0;
	struct passwd *pw;
	int i, ac = 0, uid_swapped = 0;
	pid_t pid;
	char *tmp, *username = NULL, *command = NULL, **av = NULL;
	char *ca_fp = NULL, *key_fp = NULL, *catext = NULL, *keytext = NULL;
	char serial_s[16];
	void (*osigchld)(int);

	if (options.authorized_principals_command == NULL)
		return 0;
	if (options.authorized_principals_command_user == NULL) {
		error("No user for AuthorizedPrincipalsCommand specified, "
		    "skipping");
		return 0;
	}

	/*
	 * NB. all returns later this function should go via "out" to
	 * ensure the original SIGCHLD handler is restored properly.
	 */
	osigchld = signal(SIGCHLD, SIG_DFL);

	/* Prepare and verify the user for the command */
	username = percent_expand(options.authorized_principals_command_user,
	    "u", user_pw->pw_name, (char *)NULL);
	pw = getpwnam(username);
	if (pw == NULL) {
		error("AuthorizedPrincipalsCommandUser \"%s\" not found: %s",
		    username, strerror(errno));
		goto out;
	}

	/* Turn the command into an argument vector */
	if (argv_split(options.authorized_principals_command, &ac, &av) != 0) {
		error("AuthorizedPrincipalsCommand \"%s\" contains "
		    "invalid quotes", command);
		goto out;
	}
	if (ac == 0) {
		error("AuthorizedPrincipalsCommand \"%s\" yielded no arguments",
		    command);
		goto out;
	}
	if ((ca_fp = sshkey_fingerprint(cert->signature_key,
	    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {
		error("%s: sshkey_fingerprint failed", __func__);
		goto out;
	}
	if ((key_fp = sshkey_fingerprint(key,
	    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {
		error("%s: sshkey_fingerprint failed", __func__);
		goto out;
	}
	if ((r = sshkey_to_base64(cert->signature_key, &catext)) != 0) {
		error("%s: sshkey_to_base64 failed: %s", __func__, ssh_err(r));
		goto out;
	}
	if ((r = sshkey_to_base64(key, &keytext)) != 0) {
		error("%s: sshkey_to_base64 failed: %s", __func__, ssh_err(r));
		goto out;
	}
	snprintf(serial_s, sizeof(serial_s), "%llu",
	    (unsigned long long)cert->serial);
	for (i = 1; i < ac; i++) {
		tmp = percent_expand(av[i],
		    "u", user_pw->pw_name,
		    "h", user_pw->pw_dir,
		    "t", sshkey_ssh_name(key),
		    "T", sshkey_ssh_name(cert->signature_key),
		    "f", key_fp,
		    "F", ca_fp,
		    "k", keytext,
		    "K", catext,
		    "i", cert->key_id,
		    "s", serial_s,
		    (char *)NULL);
		if (tmp == NULL)
			fatal("%s: percent_expand failed", __func__);
		free(av[i]);
		av[i] = tmp;
	}
	/* Prepare a printable command for logs, etc. */
	command = argv_assemble(ac, av);

	if ((pid = subprocess("AuthorizedPrincipalsCommand", pw, command,
	    ac, av, &f,
	    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD)) == 0)
		goto out;

	uid_swapped = 1;
	temporarily_use_uid(pw);

	ok = process_principals(f, "(command)", pw, cert);

	fclose(f);
	f = NULL;

	if (exited_cleanly(pid, "AuthorizedPrincipalsCommand", command, 0) != 0)
		goto out;

	/* Read completed successfully */
	found_principal = ok;
 out:
	if (f != NULL)
		fclose(f);
	signal(SIGCHLD, osigchld);
	for (i = 0; i < ac; i++)
		free(av[i]);
	free(av);
	if (uid_swapped)
		restore_uid();
	free(command);
	free(username);
	free(ca_fp);
	free(key_fp);
	free(catext);
	free(keytext);
	return found_principal;
}
/*
 * Checks whether key is allowed in authorized_keys-format file,
 * returns 1 if the key is allowed or 0 otherwise.
 */
static int
check_authkeys_file(FILE *f, char *file, struct sshkey *key, struct passwd *pw)
{
	char line[SSH_MAX_PUBKEY_BYTES];
	int found_key = 0;
	u_long linenum = 0;
	struct sshkey *found = NULL;

	while (read_keyfile_line(f, file, line, sizeof(line), &linenum) != -1) {
		char *cp, *key_options = NULL, *fp = NULL;
		const char *reason = NULL;

		/* Always consume entire file */
		if (found_key)
			continue;
		if (found != NULL)
			sshkey_free(found);
		found = sshkey_new(sshkey_is_cert(key) ? KEY_UNSPEC : key->type);
		if (found == NULL)
			goto done;
		auth_clear_options();

		/* Skip leading whitespace, empty and comment lines. */
		for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (!*cp || *cp == '\n' || *cp == '#')
			continue;

		if (sshkey_read(found, &cp) != 0) {
			/* no key?  check if there are options for this key */
			int quoted = 0;
			debug2("user_key_allowed: check options: '%s'", cp);
			key_options = cp;
			for (; *cp && (quoted || (*cp != ' ' && *cp != '\t')); cp++) {
				if (*cp == '\\' && cp[1] == '"')
					cp++;	/* Skip both */
				else if (*cp == '"')
					quoted = !quoted;
			}
			/* Skip remaining whitespace. */
			for (; *cp == ' ' || *cp == '\t'; cp++)
				;
			if (sshkey_read(found, &cp) != 0) {
				debug2("user_key_allowed: advance: '%s'", cp);
				/* still no key?  advance to next line*/
				continue;
			}
		}
		if (sshkey_is_cert(key)) {
			if (!sshkey_equal(found, key->cert->signature_key))
				continue;
			if (auth_parse_options(pw, key_options, file,
			    linenum) != 1)
				continue;
			if (!key_is_cert_authority)
				continue;
			if ((fp = sshkey_fingerprint(found,
			    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)
				continue;
			debug("matching CA found: file %s, line %lu, %s %s",
			    file, linenum, sshkey_type(found), fp);
			/*
			 * If the user has specified a list of principals as
			 * a key option, then prefer that list to matching
			 * their username in the certificate principals list.
			 */
			if (authorized_principals != NULL &&
			    !match_principals_option(authorized_principals,
			    key->cert)) {
				reason = "Certificate does not contain an "
				    "authorized principal";
 fail_reason:
				free(fp);
				error("%s", reason);
				auth_debug_add("%s", reason);
				continue;
			}
			if (sshkey_cert_check_authority(key, 0, 0,
			    authorized_principals == NULL ? pw->pw_name : NULL,
			    &reason) != 0)
				goto fail_reason;
			if (auth_cert_options(key, pw, &reason) != 0)
				goto fail_reason;
			verbose("Accepted certificate ID \"%s\" (serial %llu) "
			    "signed by %s CA %s via %s", key->cert->key_id,
			    (unsigned long long)key->cert->serial,
			    sshkey_type(found), fp, file);
			free(fp);
			found_key = 1;
			break;
		} else if (sshkey_equal(found, key)) {
			if (auth_parse_options(pw, key_options, file,
			    linenum) != 1)
				continue;
			if (key_is_cert_authority)
				continue;
			if ((fp = sshkey_fingerprint(found,
			    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)
				continue;
			debug("matching key found: file %s, line %lu %s %s",
			    file, linenum, sshkey_type(found), fp);
			free(fp);
			found_key = 1;
			continue;
		}
	}
 done:
	if (found != NULL)
		sshkey_free(found);
	if (!found_key)
		debug2("key not found");
	return found_key;
}

/* Authenticate a certificate key against TrustedUserCAKeys */
static int
user_cert_trusted_ca(struct passwd *pw, struct sshkey *key)
{
	char *ca_fp, *principals_file = NULL;
	const char *reason;
	int r, ret = 0, found_principal = 0, use_authorized_principals;

	if (!sshkey_is_cert(key) || options.trusted_user_ca_keys == NULL)
		return 0;

	if ((ca_fp = sshkey_fingerprint(key->cert->signature_key,
	    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)
		return 0;

	if ((r = sshkey_in_file(key->cert->signature_key,
	    options.trusted_user_ca_keys, 1, 0)) != 0) {
		debug2("%s: CA %s %s is not listed in %s: %s", __func__,
		    sshkey_type(key->cert->signature_key), ca_fp,
		    options.trusted_user_ca_keys, ssh_err(r));
		goto out;
	}
	/*
	 * If AuthorizedPrincipals is in use, then compare the certificate
	 * principals against the names in that file rather than matching
	 * against the username.
	 */
	if ((principals_file = authorized_principals_file(pw)) != NULL) {
		if (match_principals_file(principals_file, pw, key->cert))
			found_principal = 1;
	}
	/* Try querying command if specified */
	if (!found_principal && match_principals_command(pw, key))
		found_principal = 1;
	/* If principals file or command is specified, then require a match */
	use_authorized_principals = principals_file != NULL ||
            options.authorized_principals_command != NULL;
	if (!found_principal && use_authorized_principals) {
		reason = "Certificate does not contain an authorized principal";
 fail_reason:
		error("%s", reason);
		auth_debug_add("%s", reason);
		goto out;
	}
	if (sshkey_cert_check_authority(key, 0, 1,
	    use_authorized_principals ? NULL : pw->pw_name, &reason) != 0)
		goto fail_reason;
	if (auth_cert_options(key, pw, &reason) != 0)
		goto fail_reason;

	verbose("Accepted certificate ID \"%s\" (serial %llu) signed by "
	    "%s CA %s via %s", key->cert->key_id,
	    (unsigned long long)key->cert->serial,
	    sshkey_type(key->cert->signature_key), ca_fp,
	    options.trusted_user_ca_keys);
	ret = 1;

 out:
	free(principals_file);
	free(ca_fp);
	return ret;
}

/*
 * Checks whether key is allowed in file.
 * returns 1 if the key is allowed or 0 otherwise.
 */
static int
user_key_allowed2(struct passwd *pw, struct sshkey *key, char *file)
{
	FILE *f;
	int found_key = 0;

	/* Temporarily use the user's uid. */
	temporarily_use_uid(pw);

	debug("trying public key file %s", file);
	if ((f = auth_openkeyfile(file, pw, options.strict_modes)) != NULL) {
		found_key = check_authkeys_file(f, file, key, pw);
		fclose(f);
	}

	restore_uid();
	return found_key;
}

/*
 * Checks whether key is allowed in output of command.
 * returns 1 if the key is allowed or 0 otherwise.
 */
static int
user_key_command_allowed2(struct passwd *user_pw, struct sshkey *key)
{
	FILE *f = NULL;
	int r, ok, found_key = 0;
	struct passwd *pw;
	int i, uid_swapped = 0, ac = 0;
	pid_t pid;
	char *username = NULL, *key_fp = NULL, *keytext = NULL;
	char *tmp, *command = NULL, **av = NULL;
	void (*osigchld)(int);

	if (options.authorized_keys_command == NULL)
		return 0;
	if (options.authorized_keys_command_user == NULL) {
		error("No user for AuthorizedKeysCommand specified, skipping");
		return 0;
	}

	/*
	 * NB. all returns later this function should go via "out" to
	 * ensure the original SIGCHLD handler is restored properly.
	 */
	osigchld = signal(SIGCHLD, SIG_DFL);

	/* Prepare and verify the user for the command */
	username = percent_expand(options.authorized_keys_command_user,
	    "u", user_pw->pw_name, (char *)NULL);
	pw = getpwnam(username);
	if (pw == NULL) {
		error("AuthorizedKeysCommandUser \"%s\" not found: %s",
		    username, strerror(errno));
		goto out;
	}

	/* Prepare AuthorizedKeysCommand */
	if ((key_fp = sshkey_fingerprint(key, options.fingerprint_hash,
	    SSH_FP_DEFAULT)) == NULL) {
		error("%s: sshkey_fingerprint failed", __func__);
		goto out;
	}
	if ((r = sshkey_to_base64(key, &keytext)) != 0) {
		error("%s: sshkey_to_base64 failed: %s", __func__, ssh_err(r));
		goto out;
	}

	/* Turn the command into an argument vector */
	if (argv_split(options.authorized_keys_command, &ac, &av) != 0) {
		error("AuthorizedKeysCommand \"%s\" contains invalid quotes",
		    command);
		goto out;
	}
	if (ac == 0) {
		error("AuthorizedKeysCommand \"%s\" yielded no arguments",
		    command);
		goto out;
	}
	for (i = 1; i < ac; i++) {
		tmp = percent_expand(av[i],
		    "u", user_pw->pw_name,
		    "h", user_pw->pw_dir,
		    "t", sshkey_ssh_name(key),
		    "f", key_fp,
		    "k", keytext,
		    (char *)NULL);
		if (tmp == NULL)
			fatal("%s: percent_expand failed", __func__);
		free(av[i]);
		av[i] = tmp;
	}
	/* Prepare a printable command for logs, etc. */
	command = argv_assemble(ac, av);

	/*
	 * If AuthorizedKeysCommand was run without arguments
	 * then fall back to the old behaviour of passing the
	 * target username as a single argument.
	 */
	if (ac == 1) {
		av = xreallocarray(av, ac + 2, sizeof(*av));
		av[1] = xstrdup(user_pw->pw_name);
		av[2] = NULL;
		/* Fix up command too, since it is used in log messages */
		free(command);
		xasprintf(&command, "%s %s", av[0], av[1]);
	}

	if ((pid = subprocess("AuthorizedKeysCommand", pw, command,
	    ac, av, &f,
	    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD)) == 0)
		goto out;

	uid_swapped = 1;
	temporarily_use_uid(pw);

	ok = check_authkeys_file(f, options.authorized_keys_command, key, pw);

	fclose(f);
	f = NULL;

	if (exited_cleanly(pid, "AuthorizedKeysCommand", command, 0) != 0)
		goto out;

	/* Read completed successfully */
	found_key = ok;
 out:
	if (f != NULL)
		fclose(f);
	signal(SIGCHLD, osigchld);
	for (i = 0; i < ac; i++)
		free(av[i]);
	free(av);
	if (uid_swapped)
		restore_uid();
	free(command);
	free(username);
	free(key_fp);
	free(keytext);
	return found_key;
}

/*
 * Check whether key authenticates and authorises the user.
 */
int
user_key_allowed(struct passwd *pw, struct sshkey *key, int auth_attempt)
{
	u_int success, i;
	char *file;

	if (auth_key_is_revoked(key))
		return 0;
	if (sshkey_is_cert(key) &&
	    auth_key_is_revoked(key->cert->signature_key))
		return 0;

	success = user_cert_trusted_ca(pw, key);
	if (success)
		return success;

	success = user_key_command_allowed2(pw, key);
	if (success > 0)
		return success;

	for (i = 0; !success && i < options.num_authkeys_files; i++) {

		if (strcasecmp(options.authorized_keys_files[i], "none") == 0)
			continue;
		file = expand_authorized_keys(
		    options.authorized_keys_files[i], pw);

		success = user_key_allowed2(pw, key, file);
		free(file);
	}

	return success;
}

Authmethod method_pubkey = {
	"publickey",
	userauth_pubkey,
	&options.pubkey_authentication
};
@


1.70
log
@add a "quiet" flag to exited_cleanly() that supresses errors about
exit status (failure due to signal is still reported)
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.69 2017/08/18 05:36:45 djm Exp $ */
d475 1
a475 1
		/* Always consume entrire file */
@


1.69
log
@Move several subprocess-related functions from various locations to
misc.c. Extend subprocess() to offer a little more control over stdio
disposition.

feedback & ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.68 2017/06/24 06:34:38 djm Exp $ */
d437 1
a437 1
	if (exited_cleanly(pid, "AuthorizedPrincipalsCommand", command) != 0)
d767 1
a767 1
	if (exited_cleanly(pid, "AuthorizedKeysCommand", command) != 0)
@


1.68
log
@refactor authentication logging

optionally record successful auth methods and public credentials
used in a file accessible to user sessions

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.67 2017/05/31 10:54:00 markus Exp $ */
a28 1
#include <sys/wait.h>
a240 282
/*
 * Splits 's' into an argument vector. Handles quoted string and basic
 * escape characters (\\, \", \'). Caller must free the argument vector
 * and its members.
 */
static int
split_argv(const char *s, int *argcp, char ***argvp)
{
	int r = SSH_ERR_INTERNAL_ERROR;
	int argc = 0, quote, i, j;
	char *arg, **argv = xcalloc(1, sizeof(*argv));

	*argvp = NULL;
	*argcp = 0;

	for (i = 0; s[i] != '\0'; i++) {
		/* Skip leading whitespace */
		if (s[i] == ' ' || s[i] == '\t')
			continue;

		/* Start of a token */
		quote = 0;
		if (s[i] == '\\' &&
		    (s[i + 1] == '\'' || s[i + 1] == '\"' || s[i + 1] == '\\'))
			i++;
		else if (s[i] == '\'' || s[i] == '"')
			quote = s[i++];

		argv = xreallocarray(argv, (argc + 2), sizeof(*argv));
		arg = argv[argc++] = xcalloc(1, strlen(s + i) + 1);
		argv[argc] = NULL;

		/* Copy the token in, removing escapes */
		for (j = 0; s[i] != '\0'; i++) {
			if (s[i] == '\\') {
				if (s[i + 1] == '\'' ||
				    s[i + 1] == '\"' ||
				    s[i + 1] == '\\') {
					i++; /* Skip '\' */
					arg[j++] = s[i];
				} else {
					/* Unrecognised escape */
					arg[j++] = s[i];
				}
			} else if (quote == 0 && (s[i] == ' ' || s[i] == '\t'))
				break; /* done */
			else if (quote != 0 && s[i] == quote)
				break; /* done */
			else
				arg[j++] = s[i];
		}
		if (s[i] == '\0') {
			if (quote != 0) {
				/* Ran out of string looking for close quote */
				r = SSH_ERR_INVALID_FORMAT;
				goto out;
			}
			break;
		}
	}
	/* Success */
	*argcp = argc;
	*argvp = argv;
	argc = 0;
	argv = NULL;
	r = 0;
 out:
	if (argc != 0 && argv != NULL) {
		for (i = 0; i < argc; i++)
			free(argv[i]);
		free(argv);
	}
	return r;
}

/*
 * Reassemble an argument vector into a string, quoting and escaping as
 * necessary. Caller must free returned string.
 */
static char *
assemble_argv(int argc, char **argv)
{
	int i, j, ws, r;
	char c, *ret;
	struct sshbuf *buf, *arg;

	if ((buf = sshbuf_new()) == NULL || (arg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);

	for (i = 0; i < argc; i++) {
		ws = 0;
		sshbuf_reset(arg);
		for (j = 0; argv[i][j] != '\0'; j++) {
			r = 0;
			c = argv[i][j];
			switch (c) {
			case ' ':
			case '\t':
				ws = 1;
				r = sshbuf_put_u8(arg, c);
				break;
			case '\\':
			case '\'':
			case '"':
				if ((r = sshbuf_put_u8(arg, '\\')) != 0)
					break;
				/* FALLTHROUGH */
			default:
				r = sshbuf_put_u8(arg, c);
				break;
			}
			if (r != 0)
				fatal("%s: sshbuf_put_u8: %s",
				    __func__, ssh_err(r));
		}
		if ((i != 0 && (r = sshbuf_put_u8(buf, ' ')) != 0) ||
		    (ws != 0 && (r = sshbuf_put_u8(buf, '"')) != 0) ||
		    (r = sshbuf_putb(buf, arg)) != 0 ||
		    (ws != 0 && (r = sshbuf_put_u8(buf, '"')) != 0))
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
	}
	if ((ret = malloc(sshbuf_len(buf) + 1)) == NULL)
		fatal("%s: malloc failed", __func__);
	memcpy(ret, sshbuf_ptr(buf), sshbuf_len(buf));
	ret[sshbuf_len(buf)] = '\0';
	sshbuf_free(buf);
	sshbuf_free(arg);
	return ret;
}

/*
 * Runs command in a subprocess. Returns pid on success and a FILE* to the
 * subprocess' stdout or 0 on failure.
 * NB. "command" is only used for logging.
 */
static pid_t
subprocess(const char *tag, struct passwd *pw, const char *command,
    int ac, char **av, FILE **child)
{
	FILE *f;
	struct stat st;
	int devnull, p[2], i;
	pid_t pid;
	char *cp, errmsg[512];
	u_int envsize;
	char **child_env;

	*child = NULL;

	debug3("%s: %s command \"%s\" running as %s", __func__,
	    tag, command, pw->pw_name);

	/* Verify the path exists and is safe-ish to execute */
	if (*av[0] != '/') {
		error("%s path is not absolute", tag);
		return 0;
	}
	temporarily_use_uid(pw);
	if (stat(av[0], &st) < 0) {
		error("Could not stat %s \"%s\": %s", tag,
		    av[0], strerror(errno));
		restore_uid();
		return 0;
	}
	if (auth_secure_path(av[0], &st, NULL, 0,
	    errmsg, sizeof(errmsg)) != 0) {
		error("Unsafe %s \"%s\": %s", tag, av[0], errmsg);
		restore_uid();
		return 0;
	}

	/*
	 * Run the command; stderr is left in place, stdout is the
	 * authorized_keys output.
	 */
	if (pipe(p) != 0) {
		error("%s: pipe: %s", tag, strerror(errno));
		restore_uid();
		return 0;
	}

	/*
	 * Don't want to call this in the child, where it can fatal() and
	 * run cleanup_exit() code.
	 */
	restore_uid();

	switch ((pid = fork())) {
	case -1: /* error */
		error("%s: fork: %s", tag, strerror(errno));
		close(p[0]);
		close(p[1]);
		return 0;
	case 0: /* child */
		/* Prepare a minimal environment for the child. */
		envsize = 5;
		child_env = xcalloc(sizeof(*child_env), envsize);
		child_set_env(&child_env, &envsize, "PATH", _PATH_STDPATH);
		child_set_env(&child_env, &envsize, "USER", pw->pw_name);
		child_set_env(&child_env, &envsize, "LOGNAME", pw->pw_name);
		child_set_env(&child_env, &envsize, "HOME", pw->pw_dir);
		if ((cp = getenv("LANG")) != NULL)
			child_set_env(&child_env, &envsize, "LANG", cp);

		for (i = 0; i < NSIG; i++)
			signal(i, SIG_DFL);

		if ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {
			error("%s: open %s: %s", tag, _PATH_DEVNULL,
			    strerror(errno));
			_exit(1);
		}
		/* Keep stderr around a while longer to catch errors */
		if (dup2(devnull, STDIN_FILENO) == -1 ||
		    dup2(p[1], STDOUT_FILENO) == -1) {
			error("%s: dup2: %s", tag, strerror(errno));
			_exit(1);
		}
		closefrom(STDERR_FILENO + 1);

		/* Don't use permanently_set_uid() here to avoid fatal() */
		if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0) {
			error("%s: setresgid %u: %s", tag, (u_int)pw->pw_gid,
			    strerror(errno));
			_exit(1);
		}
		if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0) {
			error("%s: setresuid %u: %s", tag, (u_int)pw->pw_uid,
			    strerror(errno));
			_exit(1);
		}
		/* stdin is pointed to /dev/null at this point */
		if (dup2(STDIN_FILENO, STDERR_FILENO) == -1) {
			error("%s: dup2: %s", tag, strerror(errno));
			_exit(1);
		}

		execve(av[0], av, child_env);
		error("%s exec \"%s\": %s", tag, command, strerror(errno));
		_exit(127);
	default: /* parent */
		break;
	}

	close(p[1]);
	if ((f = fdopen(p[0], "r")) == NULL) {
		error("%s: fdopen: %s", tag, strerror(errno));
		close(p[0]);
		/* Don't leave zombie child */
		kill(pid, SIGTERM);
		while (waitpid(pid, NULL, 0) == -1 && errno == EINTR)
			;
		return 0;
	}
	/* Success */
	debug3("%s: %s pid %ld", __func__, tag, (long)pid);
	*child = f;
	return pid;
}

/* Returns 0 if pid exited cleanly, non-zero otherwise */
static int
exited_cleanly(pid_t pid, const char *tag, const char *cmd)
{
	int status;

	while (waitpid(pid, &status, 0) == -1) {
		if (errno != EINTR) {
			error("%s: waitpid: %s", tag, strerror(errno));
			return -1;
		}
	}
	if (WIFSIGNALED(status)) {
		error("%s %s exited on signal %d", tag, cmd, WTERMSIG(status));
		return -1;
	} else if (WEXITSTATUS(status) != 0) {
		error("%s %s failed, status %d", tag, cmd, WEXITSTATUS(status));
		return -1;
	}
	return 0;
}

d373 1
a373 1
	if (split_argv(options.authorized_principals_command, &ac, &av) != 0) {
d422 1
a422 1
	command = assemble_argv(ac, av);
d425 2
a426 1
	    ac, av, &f)) == 0)
d714 1
a714 1
	if (split_argv(options.authorized_keys_command, &ac, &av) != 0) {
d738 1
a738 1
	command = assemble_argv(ac, av);
d755 2
a756 1
	    ac, av, &f)) == 0)
@


1.67
log
@make sure we don't pass a NULL string to vfprintf (triggered by the
principals-command regress test); ok bluhm
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.66 2017/05/31 09:15:42 deraadt Exp $ */
d137 1
a137 1
	if (auth2_userkey_already_used(authctxt, key)) {
a193 1
		pubkey_auth_info(authctxt, key, NULL);
a200 3
			/* Record the successful key to prevent reuse */
			auth2_record_userkey(authctxt, key);
			key = NULL; /* Don't free below */
d204 1
d234 1
a234 2
	if (key != NULL)
		sshkey_free(key);
a241 38
void
pubkey_auth_info(Authctxt *authctxt, const struct sshkey *key,
    const char *fmt, ...)
{
	char *fp, *extra;
	va_list ap;
	int i;

	extra = NULL;
	if (fmt != NULL) {
		va_start(ap, fmt);
		i = vasprintf(&extra, fmt, ap);
		va_end(ap);
		if (i < 0 || extra == NULL)
			fatal("%s: vasprintf failed", __func__);
	}

	if (sshkey_is_cert(key)) {
		fp = sshkey_fingerprint(key->cert->signature_key,
		    options.fingerprint_hash, SSH_FP_DEFAULT);
		auth_info(authctxt, "%s ID %s (serial %llu) CA %s %s%s%s", 
		    sshkey_type(key), key->cert->key_id,
		    (unsigned long long)key->cert->serial,
		    sshkey_type(key->cert->signature_key),
		    fp == NULL ? "(null)" : fp,
		    extra == NULL ? "" : ", ", extra == NULL ? "" : extra);
		free(fp);
	} else {
		fp = sshkey_fingerprint(key, options.fingerprint_hash,
		    SSH_FP_DEFAULT);
		auth_info(authctxt, "%s %s%s%s", sshkey_type(key),
		    fp == NULL ? "(null)" : fp,
		    extra == NULL ? "" : ", ", extra == NULL ? "" : extra);
		free(fp);
	}
	free(extra);
}

a1103 30
}

/* Records a public key in the list of previously-successful keys */
void
auth2_record_userkey(Authctxt *authctxt, struct sshkey *key)
{
	struct sshkey **tmp;

	if (authctxt->nprev_userkeys >= INT_MAX ||
	    (tmp = recallocarray(authctxt->prev_userkeys,
	    authctxt->nprev_userkeys, authctxt->nprev_userkeys + 1,
	    sizeof(*tmp))) == NULL)
		fatal("%s: recallocarray failed", __func__);
	authctxt->prev_userkeys = tmp;
	authctxt->prev_userkeys[authctxt->nprev_userkeys] = key;
	authctxt->nprev_userkeys++;
}

/* Checks whether a key has already been used successfully for authentication */
int
auth2_userkey_already_used(Authctxt *authctxt, struct sshkey *key)
{
	u_int i;

	for (i = 0; i < authctxt->nprev_userkeys; i++) {
		if (sshkey_equal_public(key, authctxt->prev_userkeys[i])) {
			return 1;
		}
	}
	return 0;
@


1.66
log
@Switch to recallocarray() for a few operations.  Both growth and shrinkage
are handled safely, and there also is no need for preallocation dances.
Future changes in this area will be less error prone.
Review and one bug found by markus
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.65 2017/05/30 14:29:59 markus Exp $ */
d587 1
a587 1
process_principals(FILE *f, char *file, struct passwd *pw,
d625 1
a625 2
				    file == NULL ? "(command)" : file,
				    linenum, cert->principals[i]);
d756 1
a756 1
	ok = process_principals(f, NULL, pw, cert);
@


1.65
log
@switch auth2 to ssh_dispatch API; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.64 2017/05/30 14:10:53 markus Exp $ */
d1156 4
a1159 3
	    (tmp = reallocarray(authctxt->prev_userkeys,
	    authctxt->nprev_userkeys + 1, sizeof(*tmp))) == NULL)
		fatal("%s: reallocarray failed", __func__);
@


1.64
log
@switch auth2-pubkey.c to modern APIs; with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.63 2017/05/30 08:52:19 markus Exp $ */
d75 1
a75 1
userauth_pubkey(Authctxt *authctxt)
d77 1
a77 1
	struct ssh *ssh = active_state; /* XXX */
@


1.63
log
@switch from Key typedef with struct sshkey; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.62 2017/01/30 01:03:00 djm Exp $ */
d52 1
a52 1
#include "key.h"
d77 2
a78 1
	Buffer b;
d80 4
a83 4
	char *pkalg, *userstyle, *fp = NULL;
	u_char *pkblob, *sig;
	u_int alen, blen, slen;
	int have_sig, pktype;
d90 3
a92 2
	have_sig = packet_get_char();
	if (datafellows & SSH_BUG_PKAUTH) {
d94 2
a96 3
		pkblob = packet_get_string(&blen);
		buffer_init(&b);
		buffer_append(&b, pkblob, blen);
d98 6
a103 2
		pkalg = buffer_get_string(&b, &alen);
		buffer_free(&b);
d105 4
a108 2
		pkalg = packet_get_string(&alen);
		pkblob = packet_get_string(&blen);
d110 1
a110 1
	pktype = key_type_from_name(pkalg);
d117 4
a120 1
	key = key_from_blob(pkblob, blen);
d130 2
a131 2
	if (key_type_plain(key->type) == KEY_RSA &&
	    (datafellows & SSH_BUG_RSASIGMD5) != 0) {
d138 1
a138 1
		logit("refusing previously-used %s key", key_type(key));
d151 10
a160 5
		sig = packet_get_string(&slen);
		packet_check_eom();
		buffer_init(&b);
		if (datafellows & SSH_OLD_SESSIONID) {
			buffer_append(&b, session_id2, session_id2_len);
d162 4
a165 1
			buffer_put_string(&b, session_id2, session_id2_len);
a167 1
		buffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);
d171 10
a180 8
		buffer_put_cstring(&b, userstyle);
		free(userstyle);
		buffer_put_cstring(&b,
		    datafellows & SSH_BUG_PKSERVICE ?
		    "ssh-userauth" :
		    authctxt->service);
		if (datafellows & SSH_BUG_PKAUTH) {
			buffer_put_char(&b, have_sig);
d182 5
a186 3
			buffer_put_cstring(&b, "publickey");
			buffer_put_char(&b, have_sig);
			buffer_put_cstring(&b, pkalg);
d188 3
a190 1
		buffer_put_string(&b, pkblob, blen);
d192 1
a192 1
		buffer_dump(&b);
d199 2
a200 2
		    PRIVSEP(key_verify(key, sig, slen, buffer_ptr(&b),
		    buffer_len(&b))) == 1) {
d206 1
a206 1
		buffer_free(&b);
d211 2
a212 1
		packet_check_eom();
d223 7
a229 5
			packet_start(SSH2_MSG_USERAUTH_PK_OK);
			packet_put_string(pkalg, alen);
			packet_put_string(pkblob, blen);
			packet_send();
			packet_write_wait();
d238 2
a239 1
		key_free(key);
d260 1
a260 1
			fatal("%s: vasprintf failed", __func__);	
d263 1
a263 1
	if (key_is_cert(key)) {
d267 1
a267 1
		    key_type(key), key->cert->key_id,
d269 1
a269 1
		    key_type(key->cert->signature_key),
d276 1
a276 1
		auth_info(authctxt, "%s %s%s%s", key_type(key),
d789 1
a789 1
check_authkeys_file(FILE *f, char *file, struct sshkey* key, struct passwd *pw)
d794 1
a794 3
	struct sshkey *found;

	found_key = 0;
a795 1
	found = NULL;
d804 4
a807 2
			key_free(found);
		found = key_new(key_is_cert(key) ? KEY_UNSPEC : key->type);
d816 1
a816 1
		if (key_read(found, &cp) != 1) {
d830 1
a830 1
			if (key_read(found, &cp) != 1) {
d836 2
a837 2
		if (key_is_cert(key)) {
			if (!key_equal(found, key->cert->signature_key))
d848 1
a848 1
			    file, linenum, key_type(found), fp);
d865 1
a865 1
			if (key_cert_check_authority(key, 0, 0,
d874 1
a874 1
			    key_type(found), fp, file);
d878 1
a878 1
		} else if (key_equal(found, key)) {
d888 1
a888 1
			    file, linenum, key_type(found), fp);
d894 1
d896 1
a896 1
		key_free(found);
d908 1
a908 1
	int ret = 0, found_principal = 0, use_authorized_principals;
d910 1
a910 1
	if (!key_is_cert(key) || options.trusted_user_ca_keys == NULL)
d917 5
a921 5
	if (sshkey_in_file(key->cert->signature_key,
	    options.trusted_user_ca_keys, 1, 0) != 0) {
		debug2("%s: CA %s %s is not listed in %s", __func__,
		    key_type(key->cert->signature_key), ca_fp,
		    options.trusted_user_ca_keys);
d946 1
a946 1
	if (key_cert_check_authority(key, 0, 1,
d955 1
a955 1
	    key_type(key->cert->signature_key), ca_fp,
d1123 2
a1124 1
	if (key_is_cert(key) && auth_key_is_revoked(key->cert->signature_key))
@


1.62
log
@revise keys/principals command hang fix (bz#2655) to consume entire
output, avoiding sending SIGPIPE to subprocesses early; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.61 2016/12/30 22:08:02 djm Exp $ */
d78 1
a78 1
	Key *key = NULL;
d220 2
a221 1
pubkey_auth_info(Authctxt *authctxt, const Key *key, const char *fmt, ...)
d762 1
a762 1
check_authkeys_file(FILE *f, char *file, Key* key, struct passwd *pw)
d767 1
a767 1
	Key *found;
d877 1
a877 1
user_cert_trusted_ca(struct passwd *pw, Key *key)
d943 1
a943 1
user_key_allowed2(struct passwd *pw, Key *key, char *file)
d966 1
a966 1
user_key_command_allowed2(struct passwd *user_pw, Key *key)
d1089 1
a1089 1
user_key_allowed(struct passwd *pw, Key *key, int auth_attempt)
@


1.61
log
@fix deadlock when keys/principals command produces a lot of output
and a key is matched early; bz#2655, patch from jboning AT gmail.com
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.60 2016/11/30 02:57:40 djm Exp $ */
d564 1
a564 1
	u_int i;
d567 3
d602 2
a603 1
				return 1;
d607 1
a607 1
	return 0;
d775 3
d864 1
a864 1
			break;
@


1.60
log
@When a forced-command appears in both a certificate and an
authorized keys/principals command= restriction, refuse to accept
the certificate unless they are identical.

The previous (documented) behaviour of having the certificate forced-
command override the other could be a bit confused and more error-prone.

Pointed out by Jann Horn of Project Zero; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.59 2016/09/21 17:44:20 djm Exp $ */
d727 3
d1052 3
@


1.59
log
@cast uint64_t for printf
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.58 2016/09/21 01:34:45 djm Exp $ */
a756 1
	const char *reason;
a759 1
	char *fp;
d765 3
a767 1
		char *cp, *key_options = NULL;
d832 2
a833 4
			if (auth_cert_options(key, pw) != 0) {
				free(fp);
				continue;
			}
d911 2
a912 2
	if (auth_cert_options(key, pw) != 0)
		goto out;
@


1.58
log
@add a way for principals command to get see key ID and serial too
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.57 2016/09/14 20:11:26 djm Exp $ */
d695 2
a696 1
	snprintf(serial_s, sizeof(serial_s), "%llu", cert->serial);
@


1.57
log
@take fingerprint of correct key for AuthorizedPrincipalsCommand
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.56 2016/09/14 05:42:25 djm Exp $ */
d639 1
d695 1
d706 2
@


1.56
log
@add %-escapes to AuthorizedPrincipalsCommand to match those supported
for AuthorizedKeysCommand (key, key type, fingerprint, etc) and a
few more to provide access to the certificate's CA key;
'looks ok' dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.55 2016/01/27 00:53:12 djm Exp $ */
d681 1
a681 1
	if ((key_fp = sshkey_fingerprint(cert->signature_key,
@


1.55
log
@make the debug messages a bit more useful here
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.54 2015/10/27 01:44:45 djm Exp $ */
d560 1
a560 1
    struct sshkey_cert *cert)
d629 1
a629 1
match_principals_command(struct passwd *user_pw, struct sshkey_cert *cert)
d631 1
d633 1
a633 1
	int ok, found_principal = 0;
d638 1
d676 18
d698 6
d738 4
d893 1
a893 1
	if (!found_principal && match_principals_command(pw, key->cert))
@


1.54
log
@log certificate serial in verbose() messages to match the main
auth success/fail message; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.53 2015/06/15 18:44:22 jsing Exp $ */
d79 1
a79 1
	char *pkalg, *userstyle;
d86 1
a86 1
		debug2("userauth_pubkey: disabled because of invalid user");
d91 1
a91 1
		debug2("userauth_pubkey: SSH_BUG_PKAUTH");
d106 2
a107 2
		logit("userauth_pubkey: unsupported public key algorithm: %s",
		    pkalg);
d112 1
a112 1
		error("userauth_pubkey: cannot decode key: %s", pkalg);
d116 2
a117 2
		error("userauth_pubkey: type mismatch for decoded key "
		    "(received %d, expected %d)", key->type, pktype);
d126 1
d139 2
d186 2
a187 1
		debug("test whether pkalg/pkblob are acceptable");
d210 1
a210 1
	debug2("userauth_pubkey: authenticated %d pkalg %s", authenticated, pkalg);
d215 1
@


1.53
log
@If AuthorizedPrincipalsCommand is specified, however
AuthorizedPrincipalsFile is not (or is set to "none"), authentication will
potentially fail due to key_cert_check_authority() failing to locate a
principal that matches the username, even though an authorized principal
has already been matched in the output of the subprocess. Fix this by using
the same logic to determine if pw->pw_name should be passed, as is used to
determine if a authorized principal must be matched earlier on.

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.52 2015/06/15 18:42:19 jsing Exp $ */
d796 1
a796 1
			verbose("Accepted certificate ID \"%s\" "
d798 1
d876 4
a879 2
	verbose("Accepted certificate ID \"%s\" signed by %s CA %s via %s",
	    key->cert->key_id, key_type(key->cert->signature_key), ca_fp,
@


1.52
log
@Make the arguments to match_principals_command() similar to
match_principals_file(), by changing the last argument a
struct sshkey_cert * and dereferencing key->cert in the caller.

No functional change.

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.51 2015/05/21 06:43:30 djm Exp $ */
d831 1
a831 1
	int ret = 0, found_principal = 0;
d859 4
a862 3
	/* If principals file or command specify, then require a match here */
	if (!found_principal && (principals_file != NULL ||
	    options.authorized_principals_command != NULL)) {
d870 1
a870 1
	    principals_file == NULL ? pw->pw_name : NULL, &reason) != 0)
@


1.51
log
@add AuthorizedPrincipalsCommand that allows getting authorized_principals
from a subprocess rather than a file, which is quite useful in
deployments with large userbases

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.50 2015/05/21 06:38:35 djm Exp $ */
d624 1
a624 1
match_principals_command(struct passwd *user_pw, struct sshkey *key)
d689 1
a689 1
	ok = process_principals(f, NULL, pw, key->cert);
d857 1
a857 1
	if (!found_principal && match_principals_command(pw, key))
@


1.50
log
@support arguments to AuthorizedKeysCommand

bz#2081 loosely based on patch by Sami Hartikainen
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.49 2015/05/04 06:10:48 djm Exp $ */
d554 2
a555 1
match_principals_file(char *file, struct passwd *pw, struct sshkey_cert *cert)
a556 1
	FILE *f;
a560 6
	temporarily_use_uid(pw);
	debug("trying authorized principals file %s", file);
	if ((f = auth_openprincipals(file, pw, options.strict_modes)) == NULL) {
		restore_uid();
		return 0;
	}
d588 3
a590 3
				debug3("matched principal \"%.100s\" "
				    "from file \"%s\" on line %lu",
				    cert->principals[i], file, linenum);
a593 2
				fclose(f);
				restore_uid();
d598 16
d616 1
a616 1
	return 0;
d620 90
d831 1
a831 1
	int ret = 0;
d853 10
a862 3
		if (!match_principals_file(principals_file, pw, key->cert)) {
			reason = "Certificate does not contain an "
			    "authorized principal";
d864 3
a866 4
			error("%s", reason);
			auth_debug_add("%s", reason);
			goto out;
		}
@


1.49
log
@Remove pattern length argument from match_pattern_list(),
we only ever use it for strlen(pattern).

Prompted by hanno AT hboeck.de pointing an out-of-bound read
error caused by an incorrect pattern length found using AFL
and his own tools.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.48 2015/05/01 03:23:51 djm Exp $ */
d65 3
d251 282
d811 2
a812 2
	FILE *f;
	int ok, found_key = 0;
d814 1
a814 2
	struct stat st;
	int status, devnull, p[2], i;
d816 3
a818 1
	char *username, errmsg[512];
d820 1
a820 2
	if (options.authorized_keys_command == NULL ||
	    options.authorized_keys_command[0] != '/')
a821 1

d827 7
d840 1
a840 2
		free(username);
		return 0;
a841 3
	free(username);

	temporarily_use_uid(pw);
d843 4
a846 3
	if (stat(options.authorized_keys_command, &st) < 0) {
		error("Could not stat AuthorizedKeysCommand \"%s\": %s",
		    options.authorized_keys_command, strerror(errno));
d849 2
a850 3
	if (auth_secure_path(options.authorized_keys_command, &st, NULL, 0,
	    errmsg, sizeof(errmsg)) != 0) {
		error("Unsafe AuthorizedKeysCommand: %s", errmsg);
d854 9
a862 2
	if (pipe(p) != 0) {
		error("%s: pipe: %s", __func__, strerror(errno));
d865 15
a879 3

	debug3("Running AuthorizedKeysCommand: \"%s %s\" as \"%s\"",
	    options.authorized_keys_command, user_pw->pw_name, pw->pw_name);
d882 3
a884 2
	 * Don't want to call this in the child, where it can fatal() and
	 * run cleanup_exit() code.
d886 8
a893 1
	restore_uid();
d895 3
a897 49
	switch ((pid = fork())) {
	case -1: /* error */
		error("%s: fork: %s", __func__, strerror(errno));
		close(p[0]);
		close(p[1]);
		return 0;
	case 0: /* child */
		for (i = 0; i < NSIG; i++)
			signal(i, SIG_DFL);

		if ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {
			error("%s: open %s: %s", __func__, _PATH_DEVNULL,
			    strerror(errno));
			_exit(1);
		}
		/* Keep stderr around a while longer to catch errors */
		if (dup2(devnull, STDIN_FILENO) == -1 ||
		    dup2(p[1], STDOUT_FILENO) == -1) {
			error("%s: dup2: %s", __func__, strerror(errno));
			_exit(1);
		}
		closefrom(STDERR_FILENO + 1);

		/* Don't use permanently_set_uid() here to avoid fatal() */
		if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0) {
			error("setresgid %u: %s", (u_int)pw->pw_gid,
			    strerror(errno));
			_exit(1);
		}
		if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0) {
			error("setresuid %u: %s", (u_int)pw->pw_uid,
			    strerror(errno));
			_exit(1);
		}
		/* stdin is pointed to /dev/null at this point */
		if (dup2(STDIN_FILENO, STDERR_FILENO) == -1) {
			error("%s: dup2: %s", __func__, strerror(errno));
			_exit(1);
		}

		execl(options.authorized_keys_command,
		    options.authorized_keys_command, user_pw->pw_name, NULL);

		error("AuthorizedKeysCommand %s exec failed: %s",
		    options.authorized_keys_command, strerror(errno));
		_exit(127);
	default: /* parent */
		break;
	}
d899 1
a901 10
	close(p[1]);
	if ((f = fdopen(p[0], "r")) == NULL) {
		error("%s: fdopen: %s", __func__, strerror(errno));
		close(p[0]);
		/* Don't leave zombie child */
		kill(pid, SIGTERM);
		while (waitpid(pid, NULL, 0) == -1 && errno == EINTR)
			;
		goto out;
	}
a902 1
	fclose(f);
d904 1
a904 9
	while (waitpid(pid, &status, 0) == -1) {
		if (errno != EINTR) {
			error("%s: waitpid: %s", __func__, strerror(errno));
			goto out;
		}
	}
	if (WIFSIGNALED(status)) {
		error("AuthorizedKeysCommand %s exited on signal %d",
		    options.authorized_keys_command, WTERMSIG(status));
d906 2
a907 5
	} else if (WEXITSTATUS(status) != 0) {
		error("AuthorizedKeysCommand %s returned status %d",
		    options.authorized_keys_command, WEXITSTATUS(status));
		goto out;
	}
d910 12
a921 1
	restore_uid();
@


1.48
log
@prevent authorized_keys options picked up on public key tests without
a corresponding private key authentication being applied to other
authentication methods. Reported by halex@@, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.47 2015/02/17 00:14:05 djm Exp $ */
d127 2
a128 2
	if (match_pattern_list(sshkey_ssh_name(key), options.pubkey_key_types,
	    strlen(options.pubkey_key_types), 0) != 1) {
@


1.47
log
@Regression: I broke logging of public key fingerprints in 1.46.
Pointed out by Pontus Lundkvist
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.46 2015/01/28 22:36:00 djm Exp $ */
d169 1
a169 1
		if (PRIVSEP(user_key_allowed(authctxt->pw, key)) &&
d191 1
a191 1
		if (PRIVSEP(user_key_allowed(authctxt->pw, key))) {
d671 1
a671 1
user_key_allowed(struct passwd *pw, Key *key)
@


1.46
log
@update to new API (key_fingerprint => sshkey_fingerprint)
check sshkey_fingerprint return values;
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.45 2015/01/13 07:39:19 djm Exp $ */
d234 1
a234 1
		    fp == NULL ? "(null)" : "",
d241 1
a241 1
		    fp == NULL ? "(null)" : "",
@


1.45
log
@add sshd_config HostbasedAcceptedKeyTypes and PubkeyAcceptedKeyTypes
options to allow sshd to control what public key types will be
accepted. Currently defaults to all. Feedback & ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.44 2014/12/22 07:51:30 djm Exp $ */
d228 1
a228 1
		fp = key_fingerprint(key->cert->signature_key,
d233 2
a234 1
		    key_type(key->cert->signature_key), fp,
d238 1
a238 1
		fp = key_fingerprint(key, options.fingerprint_hash,
d240 2
a241 1
		auth_info(authctxt, "%s %s%s%s", key_type(key), fp,
d384 3
a386 2
			fp = key_fingerprint(found, options.fingerprint_hash,
			    SSH_FP_DEFAULT);
d425 3
a427 3
			found_key = 1;
			fp = key_fingerprint(found, options.fingerprint_hash,
			    SSH_FP_DEFAULT);
d431 1
d453 3
a455 2
	ca_fp = key_fingerprint(key->cert->signature_key,
	    options.fingerprint_hash, SSH_FP_DEFAULT);
@


1.44
log
@remember which public keys have been used for authentication and
refuse to accept previously-used keys.

This allows AuthenticationMethods=publickey,publickey to require
that users authenticate using two _different_ pubkeys.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.43 2014/12/21 22:27:56 djm Exp $ */
d127 7
@


1.43
log
@Add FingerprintHash option to control algorithm used for key
fingerprints. Default changes from MD5 to SHA256 and format
from hex to base64.

Feedback and ok naddy@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.42 2014/12/04 02:24:32 djm Exp $ */
d41 1
d123 4
d164 1
a164 1
		    buffer_len(&b))) == 1)
d166 4
d689 29
@


1.42
log
@add RevokedHostKeys option for the client

Allow textfile or KRL-based revocation of hostkeys.
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.41 2014/07/15 15:54:14 millert Exp $ */
d213 1
a213 1
		    SSH_FP_MD5, SSH_FP_HEX);
d221 2
a222 1
		fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
d366 2
a367 2
			fp = key_fingerprint(found, SSH_FP_MD5,
			    SSH_FP_HEX);
d407 2
a408 1
			fp = key_fingerprint(found, SSH_FP_MD5, SSH_FP_HEX);
d434 1
a434 1
	    SSH_FP_MD5, SSH_FP_HEX);
@


1.41
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.40 2014/06/24 01:13:21 djm Exp $ */
d434 2
a435 2
	if (key_in_file(key->cert->signature_key,
	    options.trusted_user_ca_keys, 1) != 1) {
@


1.40
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.39 2013/12/30 23:52:27 djm Exp $ */
d48 1
a61 1
#include "misc.h"
@


1.39
log
@refuse RSA keys from old proprietary clients/servers that use the
obsolete RSA+MD5 signature scheme. it will still be possible to connect
with these clients/servers but only DSA keys will be accepted, and we'll
deprecate them entirely in a future release. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.38 2013/06/21 00:34:49 djm Exp $ */
d230 1
a230 1
match_principals_option(const char *principal_list, struct KeyCert *cert)
d250 1
a250 1
match_principals_file(char *file, struct passwd *pw, struct KeyCert *cert)
@


1.38
log
@for hostbased authentication, print the client host and user on
the auth success/failure line; bz#2064, ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.37 2013/05/19 02:38:28 djm Exp $ */
d114 6
@


1.37
log
@fix failure to recognise cert-authority keys if a key of a different type
appeared in authorized_keys before it; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.36 2013/05/17 00:13:13 djm Exp $ */
d147 1
a147 1
		pubkey_auth_info(authctxt, key);
d190 1
a190 1
pubkey_auth_info(Authctxt *authctxt, const Key *key)
d192 12
a203 1
	char *fp;
d208 1
a208 1
		auth_info(authctxt, "%s ID %s (serial %llu) CA %s %s", 
d211 2
a212 1
		    key_type(key->cert->signature_key), fp);
d216 2
a217 1
		auth_info(authctxt, "%s %s", key_type(key), fp);
d220 1
@


1.36
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.35 2013/03/07 00:19:59 djm Exp $ */
d147 2
d189 20
a301 1
	found = key_new(key_is_cert(key) ? KEY_UNSPEC : key->type);
d303 1
d306 3
a308 1

a385 2
			debug("matching key found: file %s, line %lu",
			    file, linenum);
d387 2
a388 2
			verbose("Found matching %s key: %s",
			    key_type(found), fp);
d393 2
a394 1
	key_free(found);
@


1.35
log
@reconstruct the original username that was sent by the client, which may
have included a style (e.g. "root:skey") when checking public key
signatures. Fixes public key and hostbased auth when the client specified
a style; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.34 2013/02/14 21:35:59 djm Exp $ */
d154 1
a154 1
		xfree(sig);
d182 2
a183 2
	xfree(pkalg);
	xfree(pkblob);
d200 1
a200 1
			xfree(result);
d336 1
a336 1
				xfree(fp);
d346 1
a346 1
				xfree(fp);
d352 1
a352 1
			xfree(fp);
d367 1
a367 1
			xfree(fp);
d425 2
a426 4
	if (principals_file != NULL)
		xfree(principals_file);
	if (ca_fp != NULL)
		xfree(ca_fp);
d631 1
a631 1
		xfree(file);
@


1.34
log
@Correct error message that had a typo and was logging the wrong thing;
patch from Petr Lautrbach
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.33 2012/11/14 02:24:27 djm Exp $ */
d75 1
a75 1
	char *pkalg;
d127 5
a131 1
		buffer_put_cstring(&b, authctxt->user);
@


1.33
log
@fix username passed to helper program
prepare stdio fds before closefrom()

spotted by landry@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.32 2012/11/04 10:38:43 djm Exp $ */
d479 2
a480 2
		error("AuthorizedKeyCommandUser \"%s\" not found: %s",
		    options.authorized_keys_command, strerror(errno));
@


1.32
log
@Remove default of AuthorizedCommandUser. Administrators are now expected
to explicitly specify a user. feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.31 2012/10/30 21:29:54 djm Exp $ */
d504 2
a505 2
	debug3("Running AuthorizedKeysCommand: \"%s\" as \"%s\"",
	    options.authorized_keys_command, pw->pw_name);
d523 11
d535 1
d547 2
a548 10

		close(p[0]);
		if ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {
			error("%s: open %s: %s", __func__, _PATH_DEVNULL,
			    strerror(errno));
			_exit(1);
		}
		if (dup2(devnull, STDIN_FILENO) == -1 ||
		    dup2(p[1], STDOUT_FILENO) == -1 ||
		    dup2(devnull, STDERR_FILENO) == -1) {
d554 1
a554 1
		    options.authorized_keys_command, pw->pw_name, NULL);
@


1.31
log
@new sshd_config option AuthorizedKeysCommand to support fetching
authorized_keys from a command in addition to (or instead of) from
the filesystem. The command is run as the target server user unless
another specified via a new AuthorizedKeysCommandUser option.

patch originally by jchadima AT redhat.com, reworked by me; feedback
and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.30 2011/09/25 05:44:47 djm Exp $ */
d464 1
a464 1
	char errmsg[512];
d470 13
a482 10
	/* If no user specified to run commands the default to target user */
	if (options.authorized_keys_command_user == NULL)
		pw = user_pw;
	else {
		pw = getpwnam(options.authorized_keys_command_user);
		if (pw == NULL) {
			error("AuthorizedKeyCommandUser \"%s\" not found: %s",
			    options.authorized_keys_command, strerror(errno));
			return 0;
		}
d484 1
d523 1
a547 1
		closefrom(STDERR_FILENO + 1);
@


1.30
log
@improve the AuthorizedPrincipalsFile debug log message to include
file and line number
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.29 2011/05/23 03:30:07 djm Exp $ */
d29 1
d31 1
d33 1
d35 1
d246 1
a246 1
			    	    cert->principals[i], file, linenum);
d259 1
a259 1
}	
d261 4
a264 1
/* return 1 if user allows given key */
d266 1
a266 1
user_key_allowed2(struct passwd *pw, Key *key, char *file)
a270 1
	FILE *f;
a274 11
	/* Temporarily use the user's uid. */
	temporarily_use_uid(pw);

	debug("trying public key file %s", file);
	f = auth_openkeyfile(file, pw, options.strict_modes);

	if (!f) {
		restore_uid();
		return 0;
	}

a366 2
	restore_uid();
	fclose(f);
d428 166
a593 1
/* check whether given key is in .ssh/authorized_keys* */
d609 4
d614 3
d619 1
@


1.29
log
@allow AuthorizedKeysFile to specify multiple files, separated by spaces.
Bring back authorized_keys2 as a default search path (to avoid breaking
existing users of this file), but override this in sshd_config so it will
be no longer used on fresh installs. Maybe in 2015 we can remove it
entierly :)

feedback and ok markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.28 2011/05/11 04:47:06 djm Exp $ */
d240 3
a242 2
				debug3("matched principal from file \"%.100s\"",
			    	    cert->principals[i]);
@


1.28
log
@remove support for authorized_keys2; it is a relic from the early days
of protocol v.2 support and has been undocumented for many years;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.27 2010/11/20 05:12:38 deraadt Exp $ */
d438 1
a438 1
	int success;
d450 6
a455 3
	file = authorized_keys_file(pw);
	success = user_key_allowed2(pw, key, file);
	xfree(file);
@


1.27
log
@clean up cases of ;;
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.26 2010/06/29 23:16:46 djm Exp $ */
a452 2
	if (success)
		return success;
a453 4
	/* try suffix "2" for backward compat, too */
	file = authorized_keys_file2(pw);
	success = user_key_allowed2(pw, key, file);
	xfree(file);
@


1.26
log
@allow key options (command="..." and friends) in AuthorizedPrincipals;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.25 2010/05/20 11:25:26 djm Exp $ */
d234 1
a234 1
				;;
@


1.25
log
@fix logspam when key options (from="..." especially) deny non-matching keys;
reported by henning@@ also bz#1765; ok markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.24 2010/05/07 11:30:29 djm Exp $ */
d200 1
a200 1
match_principals_file(const char *file, struct passwd *pw, struct KeyCert *cert)
d203 1
a203 1
	char line[SSH_MAX_PUBKEY_BYTES], *cp;
d214 1
a214 1
		/* Skip leading whitespace, empty and comment lines. */
d217 4
a220 1
		if (!*cp || *cp == '\n' || *cp == '#')
d222 16
a237 2
		line[strcspn(line, "\n")] = '\0';

d242 3
@


1.24
log
@add some optional indirection to matching of principal names listed
in certificates. Currently, a certificate must include the a user's name
to be accepted for authentication. This change adds the ability to
specify a list of certificate principal names that are acceptable.

When authenticating using a CA trusted through ~/.ssh/authorized_keys,
this adds a new principals="name1[,name2,...]" key option.

For CAs listed through sshd_config's TrustedCAKeys option, a new config
option "AuthorizedPrincipalsFile" specifies a per-user file containing
the list of acceptable names.

If either option is absent, the current behaviour of requiring the
username to appear in principals continues to apply.

These options are useful for role accounts, disjoint account namespaces
and "user@@realm"-style naming policies in certificates.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.23 2010/04/16 01:47:26 djm Exp $ */
a292 2
		if (auth_parse_options(pw, key_options, file, linenum) != 1)
			continue;
d294 5
a300 2
			if (!key_equal(found, key->cert->signature_key))
				continue;
d335 6
a340 1
		} else if (!key_is_cert_authority && key_equal(found, key)) {
@


1.23
log
@revised certificate format ssh-{dss,rsa}-cert-v01@@openssh.com with the
following changes:

move the nonce field to the beginning of the certificate where it can
better protect against chosen-prefix attacks on the signature hash

Rename "constraints" field to "critical options"

Add a new non-critical "extensions" field

Add a serial number

The older format is still support for authentication and cert generation
(use "ssh-keygen -t v00 -s ca_key ..." to generate a v00 certificate)

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.22 2010/03/10 23:27:17 djm Exp $ */
d59 1
d179 57
d304 11
a314 2
			if (key_cert_check_authority(key, 0, 0, pw->pw_name,
			    &reason) != 0) {
d320 4
d357 1
a357 1
	char *ca_fp;
d374 14
a387 4
	if (key_cert_check_authority(key, 0, 1, pw->pw_name, &reason) != 0) {
		error("%s", reason);
		auth_debug_add("%s", reason);
		goto out;
d389 3
d401 2
@


1.22
log
@correct certificate logging and make it more consistent between
authorized_keys and TrustedCAKeys; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.21 2010/03/04 10:36:03 djm Exp $ */
d237 1
a237 1
		if (key->type == KEY_RSA_CERT || key->type == KEY_DSA_CERT) {
d253 1
a253 2
			if (auth_cert_constraints(&key->cert->constraints,
			    pw) != 0) {
d308 1
a308 1
	if (auth_cert_constraints(&key->cert->constraints, pw) != 0)
@


1.21
log
@Add a TrustedUserCAKeys option to sshd_config to specify CA keys that
are trusted to authenticate users (in addition than doing it per-user
in authorized_keys).

Add a RevokedKeys option to sshd_config and a @@revoked marker to
known_hosts to allow keys to me revoked and banned for user or host
authentication.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.20 2010/02/26 20:29:54 djm Exp $ */
a241 2
			debug("matching CA found: file %s, line %lu",
			    file, linenum);
d244 2
a245 3
			verbose("Found matching %s CA: %s",
			    key_type(found), fp);
			xfree(fp);
d248 1
d254 2
a255 1
			    pw) != 0)
d257 5
d287 1
a287 1
	char *key_fp, *ca_fp;
d294 2
a295 2
	key_fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
	ca_fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
d312 3
a314 2
	verbose("%s certificate %s allowed by trusted %s key %s",
	    key_type(key), key_fp, key_type(key->cert->signature_key), ca_fp);
a317 2
	if (key_fp != NULL)
		xfree(key_fp);
@


1.20
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.19 2008/07/03 21:46:58 otto Exp $ */
d58 1
d279 41
d326 9
@


1.19
log
@avoid nasty double free; ok dtucker@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.18 2008/07/02 12:03:51 dtucker Exp $ */
d34 2
d182 1
d201 1
a201 1
	found = key_new(key->type);
d206 2
d234 26
a259 2
		if (key_equal(found, key) &&
		    auth_parse_options(pw, key_options, file, linenum) == 1) {
@


1.18
log
@Merge duplicate host key file checks, based in part on a patch from Rob
Holland via bz #1348 .  Also checks for non-regular files during protocol
1 RSA auth.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.17 2008/06/13 14:18:51 dtucker Exp $ */
a192 1
		xfree(file);
@


1.17
log
@Include unistd.h for close(), prevents warnings in -portable
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.16 2008/06/13 04:40:22 djm Exp $ */
d180 1
a180 1
	int found_key = 0, fd;
a182 1
	struct stat st;
d190 1
d192 2
a193 30
	/*
	 * Open the file containing the authorized keys
	 * Fail quietly if file does not exist
	 */
	if ((fd = open(file, O_RDONLY|O_NONBLOCK)) == -1) {
		restore_uid();
		return 0;
	}
	if (fstat(fd, &st) < 0) {
		close(fd);
		restore_uid();
		return 0;
	}
	if (!S_ISREG(st.st_mode)) {
		logit("User %s authorized keys %s is not a regular file",
		    pw->pw_name, file);
		close(fd);
		restore_uid();
		return 0;
	}
	unset_nonblock(fd);
	if ((f = fdopen(fd, "r")) == NULL) {
		close(fd);
		restore_uid();
		return 0;
	}
	if (options.strict_modes &&
	    secure_filename(f, file, pw, line, sizeof(line)) != 0) {
		fclose(f);
		logit("Authentication refused: %s", line);
@


1.16
log
@refuse to read ~/.shosts or ~/.ssh/authorized_keys that are not
regular files; report from Solar Designer via Colin Watson in bz#1471
ok dtucker@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.15 2006/08/03 03:34:41 deraadt Exp $ */
d34 1
@


1.15
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.14 2006/08/01 23:22:47 stevesk Exp $ */
d30 1
d179 1
a179 1
	int found_key = 0;
d191 5
a195 3
	/* Fail quietly if file does not exist */
	if (stat(file, &st) < 0) {
		/* Restore the privileged uid. */
d199 15
a213 4
	/* Open the file containing the authorized keys. */
	f = fopen(file, "r");
	if (!f) {
		/* Restore the privileged uid. */
@


1.14
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.13 2006/07/06 16:03:53 stevesk Exp $ */
a25 1
#include "includes.h"
d32 1
d34 1
a36 1
#include "xmalloc.h"
d42 2
a43 1
#include "bufaux.h"
a44 1
#include "key.h"
d49 3
@


1.13
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-pubkey.c,v 1.12 2006/03/25 13:17:01 djm Exp $ */
d32 1
@


1.12
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d30 2
@


1.11
log
@RCSID() can die
@
text
@d1 1
@


1.10
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@a25 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.9 2004/12/11 01:48:56 dtucker Exp $");
@


1.10.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth2-pubkey.c,v 1.15 2006/08/03 03:34:41 deraadt Exp $ */
d25 2
a30 5
#include <pwd.h>
#include <stdio.h>
#include <stdarg.h>

#include "xmalloc.h"
d33 1
d39 2
a41 2
#include "hostfile.h"
#include "auth.h"
a45 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
@


1.9
log
@Fix debug call in error path of authorized_keys processing and fix related
warnings; ok djm@@
@
text
@d26 4
a29 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.8 2004/12/06 11:41:03 dtucker Exp $");
@


1.9.4.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth2-pubkey.c,v 1.15 2006/08/03 03:34:41 deraadt Exp $ */
d25 2
a27 8
#include <sys/types.h>
#include <sys/stat.h>

#include <pwd.h>
#include <stdio.h>
#include <stdarg.h>

#include "xmalloc.h"
d30 1
d36 2
a38 2
#include "hostfile.h"
#include "auth.h"
a42 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
@


1.8
log
@Discard over-length authorized_keys entries rather than complaining when
they don't decode.  bz #884, with & ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.7 2004/06/21 17:36:31 avsm Exp $");
d44 1
@


1.7
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.6 2004/01/19 21:25:15 markus Exp $");
d28 1
d167 1
a167 1
	char line[8192];
d204 1
a204 1
	while (fgets(line, sizeof(line), f)) {
d206 1
a206 1
		linenum++;
@


1.7.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.9 2004/12/11 01:48:56 dtucker Exp $");
a27 1
#include "ssh.h"
a42 1
#include "misc.h"
d166 1
a166 1
	char line[SSH_MAX_PUBKEY_BYTES];
d203 1
a203 1
	while (read_keyfile_line(f, file, line, sizeof(line), &linenum) != -1) {
d205 1
a205 1

@


1.6
log
@fix mem leaks; some fixes from Pete Flugstad; tested dtucker@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.5 2003/11/04 08:54:09 djm Exp $");
d204 1
a204 1
		char *cp, *options = NULL;
d216 1
a216 1
			options = cp;
d233 1
a233 1
		    auth_parse_options(pw, options, file, linenum) == 1) {
@


1.6.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.7 2004/06/21 17:36:31 avsm Exp $");
d204 1
a204 1
		char *cp, *key_options = NULL;
d216 1
a216 1
			key_options = cp;
d233 1
a233 1
		    auth_parse_options(pw, key_options, file, linenum) == 1) {
@


1.6.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.9 2004/12/11 01:48:56 dtucker Exp $");
a27 1
#include "ssh.h"
a42 1
#include "misc.h"
d166 1
a166 1
	char line[SSH_MAX_PUBKEY_BYTES];
d203 1
a203 1
	while (read_keyfile_line(f, file, line, sizeof(line), &linenum) != -1) {
d205 1
a205 1

@


1.5
log
@standardise arguments to auth methods - they should all take authctxt.
check authctxt->valid rather then pw != NULL; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.4 2003/06/24 08:23:46 markus Exp $");
d126 1
a126 1
				buffer_len(&b))) == 1)
d128 1
a128 1
		buffer_clear(&b);
@


1.4
log
@int -> u_int; ok djm@@, deraadt@@, mouring@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.3 2003/04/08 20:21:28 itojun Exp $");
a172 3

	if (pw == NULL)
		return 0;
@


1.4.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.6 2004/01/19 21:25:15 markus Exp $");
d126 1
a126 1
		    buffer_len(&b))) == 1)
d128 1
a128 1
		buffer_free(&b);
d173 3
@


1.4.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.7 2004/06/21 17:36:31 avsm Exp $");
d204 1
a204 1
		char *cp, *key_options = NULL;
d216 1
a216 1
			key_options = cp;
d233 1
a233 1
		    auth_parse_options(pw, key_options, file, linenum) == 1) {
@


1.3
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.2 2002/05/31 11:35:15 markus Exp $");
d47 1
a47 1
extern int session_id2_len;
@


1.2
log
@move Authmethod definitons to per-method file.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.1 2002/05/25 18:51:07 markus Exp $");
d81 1
a81 1
		log("userauth_pubkey: unsupported public key algorithm: %s",
d198 1
a198 1
		log("Authentication refused: %s", line);
@


1.2.6.1
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.4 2003/06/24 08:23:46 markus Exp $");
d47 1
a47 1
extern u_int session_id2_len;
d81 1
a81 1
		logit("userauth_pubkey: unsupported public key algorithm: %s",
d198 1
a198 1
		logit("Authentication refused: %s", line);
@


1.2.8.1
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.4 2003/06/24 08:23:46 markus Exp $");
d47 1
a47 1
extern u_int session_id2_len;
d81 1
a81 1
		logit("userauth_pubkey: unsupported public key algorithm: %s",
d198 1
a198 1
		logit("Authentication refused: %s", line);
@


1.2.8.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.6 2004/01/19 21:25:15 markus Exp $");
d126 1
a126 1
		    buffer_len(&b))) == 1)
d128 1
a128 1
		buffer_free(&b);
d173 3
@


1.2.4.1
log
@More missing files in 3.4 merge
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.2 2002/05/31 11:35:15 markus Exp $");
@


1.2.2.1
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-pubkey.c,v 1.2 2002/05/31 11:35:15 markus Exp $");
@


1.1
log
@split auth2.c into one file per method; ok provos@@/deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.91 2002/05/13 02:37:39 itojun Exp $");
d49 1
a49 1
int
d274 6
@

