head	1.115;
access;
symbols
	OPENBSD_6_1:1.109.0.4
	OPENBSD_6_1_BASE:1.109
	OPENBSD_6_0:1.106.0.4
	OPENBSD_6_0_BASE:1.106
	OPENBSD_5_9:1.105.0.2
	OPENBSD_5_9_BASE:1.105
	OPENBSD_5_8:1.101.0.2
	OPENBSD_5_8_BASE:1.101
	OPENBSD_5_7:1.99.0.2
	OPENBSD_5_7_BASE:1.99
	OPENBSD_5_6:1.92.0.4
	OPENBSD_5_6_BASE:1.92
	OPENBSD_5_5:1.89.0.4
	OPENBSD_5_5_BASE:1.89
	OPENBSD_5_4:1.87.0.2
	OPENBSD_5_4_BASE:1.87
	OPENBSD_5_3:1.86.0.4
	OPENBSD_5_3_BASE:1.86
	OPENBSD_5_2:1.86.0.2
	OPENBSD_5_2_BASE:1.86
	OPENBSD_5_1_BASE:1.85
	OPENBSD_5_1:1.85.0.4
	OPENBSD_5_0:1.85.0.2
	OPENBSD_5_0_BASE:1.85
	OPENBSD_4_9:1.84.0.2
	OPENBSD_4_9_BASE:1.84
	OPENBSD_4_8:1.82.0.2
	OPENBSD_4_8_BASE:1.82
	OPENBSD_4_7:1.81.0.2
	OPENBSD_4_7_BASE:1.81
	OPENBSD_4_6:1.78.0.6
	OPENBSD_4_6_BASE:1.78
	OPENBSD_4_5:1.78.0.2
	OPENBSD_4_5_BASE:1.78
	OPENBSD_4_4:1.76.0.2
	OPENBSD_4_4_BASE:1.76
	OPENBSD_4_3:1.75.0.2
	OPENBSD_4_3_BASE:1.75
	OPENBSD_4_2:1.74.0.4
	OPENBSD_4_2_BASE:1.74
	OPENBSD_4_1:1.74.0.2
	OPENBSD_4_1_BASE:1.74
	OPENBSD_4_0:1.73.0.4
	OPENBSD_4_0_BASE:1.73
	OPENBSD_3_9:1.59.0.2
	OPENBSD_3_9_BASE:1.59
	OPENBSD_3_8:1.55.0.2
	OPENBSD_3_8_BASE:1.55
	OPENBSD_3_7:1.52.0.2
	OPENBSD_3_7_BASE:1.52
	OPENBSD_3_6:1.50.0.2
	OPENBSD_3_6_BASE:1.50
	OPENBSD_3_5:1.47.0.2
	OPENBSD_3_5_BASE:1.47
	OPENBSD_3_4:1.44.0.2
	OPENBSD_3_4_BASE:1.44
	OPENBSD_3_3:1.41.0.2
	OPENBSD_3_3_BASE:1.41
	OPENBSD_3_2:1.40.0.2
	OPENBSD_3_2_BASE:1.40
	OPENBSD_3_1:1.35.0.2
	OPENBSD_3_1_BASE:1.35
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.4
	OPENBSD_2_7:1.22.0.2
	OPENBSD_2_8:1.16.0.2;
locks; strict;
comment	@ * @;


1.115
date	2017.06.30.04.17.23;	author dtucker;	state Exp;
branches;
next	1.114;
commitid	nRuKsWUgqCo1xdlW;

1.114
date	2017.05.31.07.00.13;	author markus;	state Exp;
branches;
next	1.113;
commitid	X93t1IqdA6G5YFwi;

1.113
date	2017.04.30.23.28.42;	author djm;	state Exp;
branches;
next	1.112;
commitid	mCEJ1LTymp03ZrA9;

1.112
date	2017.04.30.23.18.44;	author djm;	state Exp;
branches;
next	1.111;
commitid	NPnVhZTcf5ddO7Ys;

1.111
date	2017.04.30.23.13.25;	author djm;	state Exp;
branches;
next	1.110;
commitid	Ss7V57MvgEZubdtr;

1.110
date	2017.04.30.23.10.43;	author djm;	state Exp;
branches;
next	1.109;
commitid	I15vriCkYNtbTkea;

1.109
date	2017.03.10.04.26.06;	author djm;	state Exp;
branches;
next	1.108;
commitid	OsKbkEZNWapKjTtj;

1.108
date	2017.03.10.03.18.24;	author djm;	state Exp;
branches;
next	1.107;
commitid	4TtRjzAO9ELTLuUF;

1.107
date	2017.01.06.03.41.58;	author djm;	state Exp;
branches;
next	1.106;
commitid	4mqrE5wa7GaSi6zi;

1.106
date	2016.05.02.10.26.04;	author djm;	state Exp;
branches;
next	1.105;
commitid	rVUG0L3JBpFl5b0k;

1.105
date	2016.02.15.09.47.49;	author dtucker;	state Exp;
branches;
next	1.104;
commitid	ut5A0buLh4mhCTFu;

1.104
date	2015.11.08.23.24.03;	author jmc;	state Exp;
branches;
next	1.103;
commitid	USAq811G9ASwrPLr;

1.103
date	2015.11.08.22.30.20;	author djm;	state Exp;
branches;
next	1.102;
commitid	Q1s5wBkdLHqnbGco;

1.102
date	2015.10.24.22.56.19;	author djm;	state Exp;
branches;
next	1.101;
commitid	Dm62TY05PU8m2kN3;

1.101
date	2015.04.10.00.08.55;	author djm;	state Exp;
branches;
next	1.100;
commitid	Gh5FSlXXMjJeFjlp;

1.100
date	2015.04.05.15.43.43;	author miod;	state Exp;
branches;
next	1.99;
commitid	tJONQSQydEOw76vX;

1.99
date	2015.01.30.10.44.49;	author djm;	state Exp;
branches;
next	1.98;
commitid	uTzX1omt58w4NzEK;

1.98
date	2015.01.30.01.13.33;	author djm;	state Exp;
branches;
next	1.97;
commitid	BuE3vBiYMFEA1E3u;

1.97
date	2015.01.28.21.15.47;	author djm;	state Exp;
branches;
next	1.96;
commitid	Iqzpomw0YO4gLwGY;

1.96
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.95;
commitid	cBx23BaCk6gYBpRj;

1.95
date	2015.01.19.20.32.39;	author markus;	state Exp;
branches;
next	1.94;
commitid	IXocf6SgkUjuKSbg;

1.94
date	2015.01.19.20.16.15;	author markus;	state Exp;
branches;
next	1.93;
commitid	U9l75XYAjMKaQ8Jp;

1.93
date	2014.12.11.08.20.09;	author djm;	state Exp;
branches;
next	1.92;
commitid	UtK7Mx4xawqsfx0b;

1.92
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2014.03.27.23.01.27;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2014.03.12.04.44.58;	author djm;	state Exp;
branches;
next	1.89;

1.89
date	2013.12.06.13.39.49;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2013.11.02.21.59.15;	author markus;	state Exp;
branches;
next	1.87;

1.87
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.86;

1.86
date	2012.04.11.13.34.17;	author djm;	state Exp;
branches;
next	1.85;

1.85
date	2011.03.15.10.36.02;	author okan;	state Exp;
branches;
next	1.84;

1.84
date	2011.01.04.20.44.13;	author otto;	state Exp;
branches;
next	1.83;

1.83
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.82;

1.82
date	2010.06.22.04.54.30;	author djm;	state Exp;
branches;
next	1.81;

1.81
date	2010.01.09.23.04.13;	author dtucker;	state Exp;
branches;
next	1.80;

1.80
date	2009.12.25.19.40.21;	author stevesk;	state Exp;
branches;
next	1.79;

1.79
date	2009.10.28.16.38.18;	author reyk;	state Exp;
branches;
next	1.78;

1.78
date	2009.01.22.10.02.34;	author djm;	state Exp;
branches;
next	1.77;

1.77
date	2008.11.01.11.14.36;	author sobrado;	state Exp;
branches;
next	1.76;

1.76
date	2008.04.30.10.14.03;	author djm;	state Exp;
branches;
next	1.75;

1.75
date	2007.12.27.14.22.08;	author dtucker;	state Exp;
branches;
next	1.74;

1.74
date	2006.10.06.02.29.19;	author djm;	state Exp;
branches;
next	1.73;

1.73
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.73.4.1;
next	1.72;

1.72
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.71;

1.71
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.70;

1.70
date	2006.07.25.02.59.21;	author stevesk;	state Exp;
branches;
next	1.69;

1.69
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.68;

1.68
date	2006.07.17.01.31.10;	author stevesk;	state Exp;
branches;
next	1.67;

1.67
date	2006.07.12.22.28.52;	author stevesk;	state Exp;
branches;
next	1.66;

1.66
date	2006.07.10.16.37.36;	author stevesk;	state Exp;
branches;
next	1.65;

1.65
date	2006.07.08.21.47.12;	author stevesk;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.62;

1.62
date	2006.03.19.18.59.49;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2006.03.07.09.07.40;	author djm;	state Exp;
branches;
next	1.59;

1.59
date	2006.02.08.14.31.30;	author stevesk;	state Exp;
branches
	1.59.2.1;
next	1.58;

1.58
date	2006.02.07.01.18.09;	author stevesk;	state Exp;
branches;
next	1.57;

1.57
date	2005.10.30.04.01.03;	author djm;	state Exp;
branches;
next	1.56;

1.56
date	2005.09.13.23.40.07;	author djm;	state Exp;
branches;
next	1.55;

1.55
date	2005.06.17.02.44.33;	author djm;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2005.05.24.17.32.44;	author avsm;	state Exp;
branches;
next	1.53;

1.53
date	2005.04.28.10.17.56;	author moritz;	state Exp;
branches;
next	1.52;

1.52
date	2005.03.01.15.47.14;	author jmc;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2005.03.01.10.41.28;	author djm;	state Exp;
branches;
next	1.50;

1.50
date	2004.08.11.21.44.32;	author avsm;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2004.06.14.01.44.39;	author djm;	state Exp;
branches;
next	1.48;

1.48
date	2004.06.13.12.53.24;	author djm;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.08.09.38.05;	author djm;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2003.11.23.23.17.34;	author djm;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.19.11.30.39;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.28.16.23.06;	author deraadt;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2003.04.26.04.29.49;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2003.04.14.14.17.50;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2003.02.16.17.09.57;	author markus;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2002.07.06.17.47.58;	author stevesk;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2002.07.06.01.01.26;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2002.06.27.19.49.08;	author stevesk;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.27.08.49.44;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.16.21.30.58;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.04.18.30.23;	author stevesk;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2002.02.22.12.20.34;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2001.12.10.20.34.31;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.22.05.27.29;	author stevesk;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.16.12.46.13;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.08.19.05.05;	author markus;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2001.08.30.22.22.32;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.27.22.02.13;	author danh;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.05.23.29.58;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.05.23.18.20;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.03.10.31.30;	author jakob;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.23.15.12.20;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.05.05.05.39;	author pvalchev;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.06.06.11.18;	author deraadt;	state Exp;
branches
	1.22.2.1
	1.22.4.1;
next	1.21;

1.21
date	2001.03.06.01.06.03;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.05.15.37.27;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.03.21.19.41;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.03.06.53.12;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.21.07.37.04;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.12.22.56.10;	author deraadt;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.02.09.09.04.59;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.07.22.43.16;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.07.18.04.50;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.04.15.32.26;	author stevesk;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.21.19.05.57;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.19.15.55.11;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.13.18.12.47;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.13.18.06.54;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.08.22.03.23;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.19.23.17.58;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.19.22.48.08;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.13.23.26.53;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.12.22.30.01;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.06.19.57.48;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.04.19.24.02;	author markus;	state Exp;
branches;
next	;

1.16.2.1
date	2001.02.16.20.13.19;	author jason;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2001.02.19.17.19.31;	author jason;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2001.03.21.19.46.30;	author jason;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2001.05.07.21.09.36;	author jason;	state Exp;
branches;
next	1.16.2.5;

1.16.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.16.2.6;

1.16.2.6
date	2001.11.15.00.15.00;	author miod;	state Exp;
branches;
next	1.16.2.7;

1.16.2.7
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.22.2.1
date	2001.03.12.15.44.16;	author jason;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2001.03.21.18.53.10;	author jason;	state Exp;
branches;
next	;

1.22.4.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.22.4.2;

1.22.4.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.22.4.3;

1.22.4.3
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	;

1.30.2.1
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2002.06.22.07.23.18;	author miod;	state Exp;
branches;
next	1.30.2.3;

1.30.2.3
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.35.2.1
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2002.10.11.14.51.53;	author miod;	state Exp;
branches;
next	1.35.2.3;

1.35.2.3
date	2003.04.03.22.35.18;	author miod;	state Exp;
branches;
next	;

1.40.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2003.09.16.21.20.28;	author brad;	state Exp;
branches;
next	;

1.41.2.1
date	2003.09.16.20.50.44;	author brad;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.44.2.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.47.2.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2005.03.10.17.15.05;	author brad;	state Exp;
branches;
next	;

1.50.2.1
date	2005.03.10.16.28.28;	author brad;	state Exp;
branches;
next	1.50.2.2;

1.50.2.2
date	2005.09.02.03.45.01;	author brad;	state Exp;
branches;
next	;

1.52.2.1
date	2005.09.04.18.40.10;	author brad;	state Exp;
branches;
next	1.52.2.2;

1.52.2.2
date	2006.02.03.02.53.45;	author brad;	state Exp;
branches;
next	;

1.55.2.1
date	2006.02.03.03.01.57;	author brad;	state Exp;
branches;
next	1.55.2.2;

1.55.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	1.55.2.3;

1.55.2.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.59.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	1.59.2.2;

1.59.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.73.4.1
date	2006.11.08.00.42.11;	author brad;	state Exp;
branches;
next	;


desc
@@


1.115
log
@Only call close once in confree().  ssh_packet_close will close the FD
so only explicitly close non-SSH channels.  bz#2734, from
bagajjal at microsoft.com, ok djm@@
@
text
@/* $OpenBSD: ssh-keyscan.c,v 1.114 2017/05/31 07:00:13 markus Exp $ */
/*
 * Copyright 1995, 1996 by David Mazieres <dm@@lcs.mit.edu>.
 *
 * Modification and redistribution in source and binary forms is
 * permitted provided that due credit is given to the author and the
 * OpenBSD project by leaving this copyright notice intact.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/resource.h>

#include <openssl/bn.h>

#include <errno.h>
#include <netdb.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
#include "ssh.h"
#include "sshbuf.h"
#include "sshkey.h"
#include "cipher.h"
#include "kex.h"
#include "compat.h"
#include "myproposal.h"
#include "packet.h"
#include "dispatch.h"
#include "log.h"
#include "atomicio.h"
#include "misc.h"
#include "hostfile.h"
#include "ssherr.h"
#include "ssh_api.h"

/* Flag indicating whether IPv4 or IPv6.  This can be set on the command line.
   Default value is AF_UNSPEC means both IPv4 and IPv6. */
int IPv4or6 = AF_UNSPEC;

int ssh_port = SSH_DEFAULT_PORT;

#define KT_DSA		(1)
#define KT_RSA		(1<<1)
#define KT_ECDSA	(1<<2)
#define KT_ED25519	(1<<3)

#define KT_MIN		KT_DSA
#define KT_MAX		KT_ED25519

int get_cert = 0;
int get_keytypes = KT_RSA|KT_ECDSA|KT_ED25519;

int hash_hosts = 0;		/* Hash hostname on output */

#define MAXMAXFD 256

/* The number of seconds after which to give up on a TCP connection */
int timeout = 5;

int maxfd;
#define MAXCON (maxfd - 10)

extern char *__progname;
fd_set *read_wait;
size_t read_wait_nfdset;
int ncon;

/*
 * Keep a connection structure for each file descriptor.  The state
 * associated with file descriptor n is held in fdcon[n].
 */
typedef struct Connection {
	u_char c_status;	/* State of connection on this file desc. */
#define CS_UNUSED 0		/* File descriptor unused */
#define CS_CON 1		/* Waiting to connect/read greeting */
#define CS_SIZE 2		/* Waiting to read initial packet size */
#define CS_KEYS 3		/* Waiting to read public key packet */
	int c_fd;		/* Quick lookup: c->c_fd == c - fdcon */
	int c_plen;		/* Packet length field for ssh packet */
	int c_len;		/* Total bytes which must be read. */
	int c_off;		/* Length of data read so far. */
	int c_keytype;		/* Only one of KT_* */
	sig_atomic_t c_done;	/* SSH2 done */
	char *c_namebase;	/* Address to free for c_name and c_namelist */
	char *c_name;		/* Hostname of connection for errors */
	char *c_namelist;	/* Pointer to other possible addresses */
	char *c_output_name;	/* Hostname of connection for output */
	char *c_data;		/* Data read from this fd */
	struct ssh *c_ssh;	/* SSH-connection */
	struct timeval c_tv;	/* Time at which connection gets aborted */
	TAILQ_ENTRY(Connection) c_link;	/* List of connections in timeout order. */
} con;

TAILQ_HEAD(conlist, Connection) tq;	/* Timeout Queue */
con *fdcon;

static void keyprint(con *c, struct sshkey *key);

static int
fdlim_get(int hard)
{
	struct rlimit rlfd;

	if (getrlimit(RLIMIT_NOFILE, &rlfd) < 0)
		return (-1);
	if ((hard ? rlfd.rlim_max : rlfd.rlim_cur) == RLIM_INFINITY)
		return sysconf(_SC_OPEN_MAX);
	else
		return hard ? rlfd.rlim_max : rlfd.rlim_cur;
}

static int
fdlim_set(int lim)
{
	struct rlimit rlfd;

	if (lim <= 0)
		return (-1);
	if (getrlimit(RLIMIT_NOFILE, &rlfd) < 0)
		return (-1);
	rlfd.rlim_cur = lim;
	if (setrlimit(RLIMIT_NOFILE, &rlfd) < 0)
		return (-1);
	return (0);
}

/*
 * This is an strsep function that returns a null field for adjacent
 * separators.  This is the same as the 4.4BSD strsep, but different from the
 * one in the GNU libc.
 */
static char *
xstrsep(char **str, const char *delim)
{
	char *s, *e;

	if (!**str)
		return (NULL);

	s = *str;
	e = s + strcspn(s, delim);

	if (*e != '\0')
		*e++ = '\0';
	*str = e;

	return (s);
}

/*
 * Get the next non-null token (like GNU strsep).  Strsep() will return a
 * null token for two adjacent separators, so we may have to loop.
 */
static char *
strnnsep(char **stringp, char *delim)
{
	char *tok;

	do {
		tok = xstrsep(stringp, delim);
	} while (tok && *tok == '\0');
	return (tok);
}


static int
key_print_wrapper(struct sshkey *hostkey, struct ssh *ssh)
{
	con *c;

	if ((c = ssh_get_app_data(ssh)) != NULL)
		keyprint(c, hostkey);
	/* always abort key exchange */
	return -1;
}

static int
ssh2_capable(int remote_major, int remote_minor)
{
	switch (remote_major) {
	case 1:
		if (remote_minor == 99)
			return 1;
		break;
	case 2:
		return 1;
	default:
		break;
	}
	return 0;
}

static void
keygrab_ssh2(con *c)
{
	char *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };
	int r;

	switch (c->c_keytype) {
	case KT_DSA:
		myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = get_cert ?
		    "ssh-dss-cert-v01@@openssh.com" : "ssh-dss";
		break;
	case KT_RSA:
		myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = get_cert ?
		    "ssh-rsa-cert-v01@@openssh.com" : "ssh-rsa";
		break;
	case KT_ED25519:
		myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = get_cert ?
		    "ssh-ed25519-cert-v01@@openssh.com" : "ssh-ed25519";
		break;
	case KT_ECDSA:
		myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = get_cert ?
		    "ecdsa-sha2-nistp256-cert-v01@@openssh.com,"
		    "ecdsa-sha2-nistp384-cert-v01@@openssh.com,"
		    "ecdsa-sha2-nistp521-cert-v01@@openssh.com" :
		    "ecdsa-sha2-nistp256,"
		    "ecdsa-sha2-nistp384,"
		    "ecdsa-sha2-nistp521";
		break;
	default:
		fatal("unknown key type %d", c->c_keytype);
		break;
	}
	if ((r = kex_setup(c->c_ssh, myproposal)) != 0) {
		free(c->c_ssh);
		fprintf(stderr, "kex_setup: %s\n", ssh_err(r));
		exit(1);
	}
#ifdef WITH_OPENSSL
	c->c_ssh->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;
	c->c_ssh->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;
	c->c_ssh->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_client;
	c->c_ssh->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_client;
	c->c_ssh->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_client;
	c->c_ssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;
	c->c_ssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;
	c->c_ssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_client;
#endif
	c->c_ssh->kex->kex[KEX_C25519_SHA256] = kexc25519_client;
	ssh_set_verify_host_key_callback(c->c_ssh, key_print_wrapper);
	/*
	 * do the key-exchange until an error occurs or until
	 * the key_print_wrapper() callback sets c_done.
	 */
	ssh_dispatch_run(c->c_ssh, DISPATCH_BLOCK, &c->c_done);
}

static void
keyprint_one(const char *host, struct sshkey *key)
{
	char *hostport;
	const char *known_host, *hashed;

	hostport = put_host_port(host, ssh_port);
	lowercase(hostport);
	if (hash_hosts && (hashed = host_hash(host, NULL, 0)) == NULL)
		fatal("host_hash failed");
	known_host = hash_hosts ? hashed : hostport;
	if (!get_cert)
		fprintf(stdout, "%s ", known_host);
	sshkey_write(key, stdout);
	fputs("\n", stdout);
	free(hostport);
}

static void
keyprint(con *c, struct sshkey *key)
{
	char *hosts = c->c_output_name ? c->c_output_name : c->c_name;
	char *host, *ohosts;

	if (key == NULL)
		return;
	if (get_cert || (!hash_hosts && ssh_port == SSH_DEFAULT_PORT)) {
		keyprint_one(hosts, key);
		return;
	}
	ohosts = hosts = xstrdup(hosts);
	while ((host = strsep(&hosts, ",")) != NULL)
		keyprint_one(host, key);
	free(ohosts);
}

static int
tcpconnect(char *host)
{
	struct addrinfo hints, *ai, *aitop;
	char strport[NI_MAXSERV];
	int gaierr, s = -1;

	snprintf(strport, sizeof strport, "%d", ssh_port);
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = IPv4or6;
	hints.ai_socktype = SOCK_STREAM;
	if ((gaierr = getaddrinfo(host, strport, &hints, &aitop)) != 0) {
		error("getaddrinfo %s: %s", host, ssh_gai_strerror(gaierr));
		return -1;
	}
	for (ai = aitop; ai; ai = ai->ai_next) {
		s = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
		if (s < 0) {
			error("socket: %s", strerror(errno));
			continue;
		}
		if (set_nonblock(s) == -1)
			fatal("%s: set_nonblock(%d)", __func__, s);
		if (connect(s, ai->ai_addr, ai->ai_addrlen) < 0 &&
		    errno != EINPROGRESS)
			error("connect (`%s'): %s", host, strerror(errno));
		else
			break;
		close(s);
		s = -1;
	}
	freeaddrinfo(aitop);
	return s;
}

static int
conalloc(char *iname, char *oname, int keytype)
{
	char *namebase, *name, *namelist;
	int s;

	namebase = namelist = xstrdup(iname);

	do {
		name = xstrsep(&namelist, ",");
		if (!name) {
			free(namebase);
			return (-1);
		}
	} while ((s = tcpconnect(name)) < 0);

	if (s >= maxfd)
		fatal("conalloc: fdno %d too high", s);
	if (fdcon[s].c_status)
		fatal("conalloc: attempt to reuse fdno %d", s);

	debug3("%s: oname %s kt %d", __func__, oname, keytype);
	fdcon[s].c_fd = s;
	fdcon[s].c_status = CS_CON;
	fdcon[s].c_namebase = namebase;
	fdcon[s].c_name = name;
	fdcon[s].c_namelist = namelist;
	fdcon[s].c_output_name = xstrdup(oname);
	fdcon[s].c_data = (char *) &fdcon[s].c_plen;
	fdcon[s].c_len = 4;
	fdcon[s].c_off = 0;
	fdcon[s].c_keytype = keytype;
	gettimeofday(&fdcon[s].c_tv, NULL);
	fdcon[s].c_tv.tv_sec += timeout;
	TAILQ_INSERT_TAIL(&tq, &fdcon[s], c_link);
	FD_SET(s, read_wait);
	ncon++;
	return (s);
}

static void
confree(int s)
{
	if (s >= maxfd || fdcon[s].c_status == CS_UNUSED)
		fatal("confree: attempt to free bad fdno %d", s);
	free(fdcon[s].c_namebase);
	free(fdcon[s].c_output_name);
	if (fdcon[s].c_status == CS_KEYS)
		free(fdcon[s].c_data);
	fdcon[s].c_status = CS_UNUSED;
	fdcon[s].c_keytype = 0;
	if (fdcon[s].c_ssh) {
		ssh_packet_close(fdcon[s].c_ssh);
		free(fdcon[s].c_ssh);
		fdcon[s].c_ssh = NULL;
	} else
		close(s);
	TAILQ_REMOVE(&tq, &fdcon[s], c_link);
	FD_CLR(s, read_wait);
	ncon--;
}

static void
contouch(int s)
{
	TAILQ_REMOVE(&tq, &fdcon[s], c_link);
	gettimeofday(&fdcon[s].c_tv, NULL);
	fdcon[s].c_tv.tv_sec += timeout;
	TAILQ_INSERT_TAIL(&tq, &fdcon[s], c_link);
}

static int
conrecycle(int s)
{
	con *c = &fdcon[s];
	int ret;

	ret = conalloc(c->c_namelist, c->c_output_name, c->c_keytype);
	confree(s);
	return (ret);
}

static void
congreet(int s)
{
	int n = 0, remote_major = 0, remote_minor = 0;
	char buf[256], *cp;
	char remote_version[sizeof buf];
	size_t bufsiz;
	con *c = &fdcon[s];

	/* send client banner */
	n = snprintf(buf, sizeof buf, "SSH-%d.%d-OpenSSH-keyscan\r\n",
	    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2);
	if (n < 0 || (size_t)n >= sizeof(buf)) {
		error("snprintf: buffer too small");
		confree(s);
		return;
	}
	if (atomicio(vwrite, s, buf, n) != (size_t)n) {
		error("write (%s): %s", c->c_name, strerror(errno));
		confree(s);
		return;
	}

	for (;;) {
		memset(buf, '\0', sizeof(buf));
		bufsiz = sizeof(buf);
		cp = buf;
		while (bufsiz-- &&
		    (n = atomicio(read, s, cp, 1)) == 1 && *cp != '\n') {
			if (*cp == '\r')
				*cp = '\n';
			cp++;
		}
		if (n != 1 || strncmp(buf, "SSH-", 4) == 0)
			break;
	}
	if (n == 0) {
		switch (errno) {
		case EPIPE:
			error("%s: Connection closed by remote host", c->c_name);
			break;
		case ECONNREFUSED:
			break;
		default:
			error("read (%s): %s", c->c_name, strerror(errno));
			break;
		}
		conrecycle(s);
		return;
	}
	if (*cp != '\n' && *cp != '\r') {
		error("%s: bad greeting", c->c_name);
		confree(s);
		return;
	}
	*cp = '\0';
	if ((c->c_ssh = ssh_packet_set_connection(NULL, s, s)) == NULL)
		fatal("ssh_packet_set_connection failed");
	ssh_packet_set_timeout(c->c_ssh, timeout, 1);
	ssh_set_app_data(c->c_ssh, c);	/* back link */
	if (sscanf(buf, "SSH-%d.%d-%[^\n]\n",
	    &remote_major, &remote_minor, remote_version) == 3)
		c->c_ssh->compat = compat_datafellows(remote_version);
	else
		c->c_ssh->compat = 0;
	if (!ssh2_capable(remote_major, remote_minor)) {
		debug("%s doesn't support ssh2", c->c_name);
		confree(s);
		return;
	}
	fprintf(stderr, "# %s:%d %s\n", c->c_name, ssh_port, chop(buf));
	keygrab_ssh2(c);
	confree(s);
}

static void
conread(int s)
{
	con *c = &fdcon[s];
	size_t n;

	if (c->c_status == CS_CON) {
		congreet(s);
		return;
	}
	n = atomicio(read, s, c->c_data + c->c_off, c->c_len - c->c_off);
	if (n == 0) {
		error("read (%s): %s", c->c_name, strerror(errno));
		confree(s);
		return;
	}
	c->c_off += n;

	if (c->c_off == c->c_len)
		switch (c->c_status) {
		case CS_SIZE:
			c->c_plen = htonl(c->c_plen);
			c->c_len = c->c_plen + 8 - (c->c_plen & 7);
			c->c_off = 0;
			c->c_data = xmalloc(c->c_len);
			c->c_status = CS_KEYS;
			break;
		default:
			fatal("conread: invalid status %d", c->c_status);
			break;
		}

	contouch(s);
}

static void
conloop(void)
{
	struct timeval seltime, now;
	fd_set *r, *e;
	con *c;
	int i;

	gettimeofday(&now, NULL);
	c = TAILQ_FIRST(&tq);

	if (c && (c->c_tv.tv_sec > now.tv_sec ||
	    (c->c_tv.tv_sec == now.tv_sec && c->c_tv.tv_usec > now.tv_usec))) {
		seltime = c->c_tv;
		seltime.tv_sec -= now.tv_sec;
		seltime.tv_usec -= now.tv_usec;
		if (seltime.tv_usec < 0) {
			seltime.tv_usec += 1000000;
			seltime.tv_sec--;
		}
	} else
		timerclear(&seltime);

	r = xcalloc(read_wait_nfdset, sizeof(fd_mask));
	e = xcalloc(read_wait_nfdset, sizeof(fd_mask));
	memcpy(r, read_wait, read_wait_nfdset * sizeof(fd_mask));
	memcpy(e, read_wait, read_wait_nfdset * sizeof(fd_mask));

	while (select(maxfd, r, NULL, e, &seltime) == -1 &&
	    (errno == EAGAIN || errno == EINTR))
		;

	for (i = 0; i < maxfd; i++) {
		if (FD_ISSET(i, e)) {
			error("%s: exception!", fdcon[i].c_name);
			confree(i);
		} else if (FD_ISSET(i, r))
			conread(i);
	}
	free(r);
	free(e);

	c = TAILQ_FIRST(&tq);
	while (c && (c->c_tv.tv_sec < now.tv_sec ||
	    (c->c_tv.tv_sec == now.tv_sec && c->c_tv.tv_usec < now.tv_usec))) {
		int s = c->c_fd;

		c = TAILQ_NEXT(c, c_link);
		conrecycle(s);
	}
}

static void
do_host(char *host)
{
	char *name = strnnsep(&host, " \t\n");
	int j;

	if (name == NULL)
		return;
	for (j = KT_MIN; j <= KT_MAX; j *= 2) {
		if (get_keytypes & j) {
			while (ncon >= MAXCON)
				conloop();
			conalloc(name, *host ? host : name, j);
		}
	}
}

void
fatal(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_FATAL, fmt, args);
	va_end(args);
	exit(255);
}

static void
usage(void)
{
	fprintf(stderr,
	    "usage: %s [-46cHv] [-f file] [-p port] [-T timeout] [-t type]\n"
	    "\t\t   [host | addrlist namelist] ...\n",
	    __progname);
	exit(1);
}

int
main(int argc, char **argv)
{
	int debug_flag = 0, log_level = SYSLOG_LEVEL_INFO;
	int opt, fopt_count = 0, j;
	char *tname, *cp, line[NI_MAXHOST];
	FILE *fp;
	u_long linenum;

	extern int optind;
	extern char *optarg;

	ssh_malloc_init();	/* must be called before any mallocs */
	TAILQ_INIT(&tq);

	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	if (argc <= 1)
		usage();

	while ((opt = getopt(argc, argv, "cHv46p:T:t:f:")) != -1) {
		switch (opt) {
		case 'H':
			hash_hosts = 1;
			break;
		case 'c':
			get_cert = 1;
			break;
		case 'p':
			ssh_port = a2port(optarg);
			if (ssh_port <= 0) {
				fprintf(stderr, "Bad port '%s'\n", optarg);
				exit(1);
			}
			break;
		case 'T':
			timeout = convtime(optarg);
			if (timeout == -1 || timeout == 0) {
				fprintf(stderr, "Bad timeout '%s'\n", optarg);
				usage();
			}
			break;
		case 'v':
			if (!debug_flag) {
				debug_flag = 1;
				log_level = SYSLOG_LEVEL_DEBUG1;
			}
			else if (log_level < SYSLOG_LEVEL_DEBUG3)
				log_level++;
			else
				fatal("Too high debugging level.");
			break;
		case 'f':
			if (strcmp(optarg, "-") == 0)
				optarg = NULL;
			argv[fopt_count++] = optarg;
			break;
		case 't':
			get_keytypes = 0;
			tname = strtok(optarg, ",");
			while (tname) {
				int type = sshkey_type_from_name(tname);

				switch (type) {
				case KEY_DSA:
					get_keytypes |= KT_DSA;
					break;
				case KEY_ECDSA:
					get_keytypes |= KT_ECDSA;
					break;
				case KEY_RSA:
					get_keytypes |= KT_RSA;
					break;
				case KEY_ED25519:
					get_keytypes |= KT_ED25519;
					break;
				case KEY_UNSPEC:
				default:
					fatal("Unknown key type \"%s\"", tname);
				}
				tname = strtok(NULL, ",");
			}
			break;
		case '4':
			IPv4or6 = AF_INET;
			break;
		case '6':
			IPv4or6 = AF_INET6;
			break;
		case '?':
		default:
			usage();
		}
	}
	if (optind == argc && !fopt_count)
		usage();

	log_init("ssh-keyscan", log_level, SYSLOG_FACILITY_USER, 1);

	maxfd = fdlim_get(1);
	if (maxfd < 0)
		fatal("%s: fdlim_get: bad value", __progname);
	if (maxfd > MAXMAXFD)
		maxfd = MAXMAXFD;
	if (MAXCON <= 0)
		fatal("%s: not enough file descriptors", __progname);
	if (maxfd > fdlim_get(0))
		fdlim_set(maxfd);
	fdcon = xcalloc(maxfd, sizeof(con));

	read_wait_nfdset = howmany(maxfd, NFDBITS);
	read_wait = xcalloc(read_wait_nfdset, sizeof(fd_mask));

	for (j = 0; j < fopt_count; j++) {
		if (argv[j] == NULL)
			fp = stdin;
		else if ((fp = fopen(argv[j], "r")) == NULL)
			fatal("%s: %s: %s", __progname, argv[j],
			    strerror(errno));
		linenum = 0;

		while (read_keyfile_line(fp,
		    argv[j] == NULL ? "(stdin)" : argv[j], line, sizeof(line),
		    &linenum) != -1) {
			/* Chomp off trailing whitespace and comments */
			if ((cp = strchr(line, '#')) == NULL)
				cp = line + strlen(line) - 1;
			while (cp >= line) {
				if (*cp == ' ' || *cp == '\t' ||
				    *cp == '\n' || *cp == '#')
					*cp-- = '\0';
				else
					break;
			}

			/* Skip empty lines */
			if (*line == '\0')
				continue;

			do_host(line);
		}

		if (ferror(fp))
			fatal("%s: %s: %s", __progname, argv[j],
			    strerror(errno));

		fclose(fp);
	}

	while (optind < argc)
		do_host(argv[optind++]);

	while (ncon > 0)
		conloop();

	return (0);
}
@


1.114
log
@remove now obsolete ctx from ssh_dispatch_run; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.113 2017/04/30 23:28:42 djm Exp $ */
a372 1
	close(s);
d383 2
a384 1
	}
@


1.113
log
@obliterate ssh1.h and some dead code that used it

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.112 2017/04/30 23:18:44 djm Exp $ */
d254 1
a254 1
	ssh_dispatch_run(c->c_ssh, DISPATCH_BLOCK, &c->c_done, c->c_ssh);
@


1.112
log
@remove KEY_RSA1

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.111 2017/04/30 23:13:25 djm Exp $ */
a28 1
#include "ssh1.h"
@


1.111
log
@remove compat20/compat13/compat15 variables

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.110 2017/04/30 23:10:43 djm Exp $ */
d51 7
a57 5
#define KT_RSA1		1
#define KT_DSA		2
#define KT_RSA		4
#define KT_ECDSA	8
#define KT_ED25519	16
d91 1
a91 1
	int c_keytype;		/* Only one of KT_RSA1, KT_DSA, or KT_RSA */
d420 14
d476 2
a477 8
	if (c->c_keytype != KT_RSA1) {
		if (!ssh2_capable(remote_major, remote_minor)) {
			debug("%s doesn't support ssh2", c->c_name);
			confree(s);
			return;
		}
	} else if (remote_major != 1) {
		debug("%s doesn't support ssh1", c->c_name);
d482 2
a483 20
	n = snprintf(buf, sizeof buf, "SSH-%d.%d-OpenSSH-keyscan\r\n",
	    c->c_keytype == KT_RSA1? PROTOCOL_MAJOR_1 : PROTOCOL_MAJOR_2,
	    c->c_keytype == KT_RSA1? PROTOCOL_MINOR_1 : PROTOCOL_MINOR_2);
	if (n < 0 || (size_t)n >= sizeof(buf)) {
		error("snprintf: buffer too small");
		confree(s);
		return;
	}
	if (atomicio(vwrite, s, buf, n) != (size_t)n) {
		error("write (%s): %s", c->c_name, strerror(errno));
		confree(s);
		return;
	}
	if (c->c_keytype != KT_RSA1) {
		keygrab_ssh2(c);
		confree(s);
		return;
	}
	c->c_status = CS_SIZE;
	contouch(s);
d581 1
a581 1
	for (j = KT_RSA1; j <= KT_ED25519; j *= 2) {
@


1.110
log
@unifdef WITH_SSH1
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.109 2017/03/10 04:26:06 djm Exp $ */
a205 1
	enable_compat20();
@


1.109
log
@ensure hostname is lower-case before hashing it; bz#2591 reported by
Griff Miller II; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.108 2017/03/10 03:18:24 djm Exp $ */
a171 46
#ifdef WITH_SSH1
static struct sshkey *
keygrab_ssh1(con *c)
{
	static struct sshkey *rsa;
	static struct sshbuf *msg;
	int r;
	u_char type;

	if (rsa == NULL) {
		if ((rsa = sshkey_new(KEY_RSA1)) == NULL) {
			error("%s: sshkey_new failed", __func__);
			return NULL;
		}
		if ((msg = sshbuf_new()) == NULL)
			fatal("%s: sshbuf_new failed", __func__);
	}
	if ((r = sshbuf_put(msg, c->c_data, c->c_plen)) != 0 ||
	    (r = sshbuf_consume(msg, 8 - (c->c_plen & 7))) != 0 || /* padding */
	    (r = sshbuf_get_u8(msg, &type)) != 0)
		goto buf_err;
	if (type != (int) SSH_SMSG_PUBLIC_KEY) {
		error("%s: invalid packet type", c->c_name);
		sshbuf_reset(msg);
		return NULL;
	}
	if ((r = sshbuf_consume(msg, 8)) != 0 || /* cookie */
	    /* server key */
	    (r = sshbuf_get_u32(msg, NULL)) != 0 ||
	    (r = sshbuf_get_bignum1(msg, NULL)) != 0 ||
	    (r = sshbuf_get_bignum1(msg, NULL)) != 0 ||
	    /* host key */
	    (r = sshbuf_get_u32(msg, NULL)) != 0 ||
	    (r = sshbuf_get_bignum1(msg, rsa->rsa->e)) != 0 ||
	    (r = sshbuf_get_bignum1(msg, rsa->rsa->n)) != 0) {
 buf_err:
		error("%s: buffer error: %s", __func__, ssh_err(r));
		sshbuf_reset(msg);
		return NULL;
	}

	sshbuf_reset(msg);

	return (rsa);
}
#endif
a521 6
#ifdef WITH_SSH1
		case CS_KEYS:
			keyprint(c, keygrab_ssh1(c));
			confree(s);
			return;
#endif
a684 5
#ifdef WITH_SSH1
				case KEY_RSA1:
					get_keytypes |= KT_RSA1;
					break;
#endif
@


1.108
log
@correctly hash hosts with a port number. Reported by Josh Powers in
bz#2692; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.107 2017/01/06 03:41:58 djm Exp $ */
d310 1
@


1.107
log
@Avoid confusing error message when attempting to use ssh-keyscan built
without SSH protocol v.1 to scan for v.1 keys; bz#2583
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.106 2016/05/02 10:26:04 djm Exp $ */
d304 1
a304 1
keyprint_one(char *host, struct sshkey *key)
d307 1
d309 2
a310 1
	if (hash_hosts && (host = host_hash(host, NULL, 0)) == NULL)
d312 1
a312 2

	hostport = put_host_port(host, ssh_port);
d314 1
a314 1
		fprintf(stdout, "%s ", hostport);
@


1.106
log
@add support for additional fixed DH groups from
draft-ietf-curdle-ssh-kex-sha2-03

diffie-hellman-group14-sha256 (2K group)
diffie-hellman-group16-sha512 (4K group)
diffie-hellman-group18-sha512 (8K group)

based on patch from Mark D. Baushke and Darren Tucker
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.105 2016/02/15 09:47:49 dtucker Exp $ */
d733 1
d735 1
d739 1
d753 2
a754 1
					fatal("unknown key type %s", tname);
@


1.105
log
@Add a function to enable security-related malloc_options.  With and ok
deraadt@@, something similar has been in the snaps for a while.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.104 2015/11/08 23:24:03 jmc Exp $ */
d287 3
@


1.104
log
@-c before -H, in SYNOPSIS and usage();
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.103 2015/11/08 22:30:20 djm Exp $ */
d679 1
@


1.103
log
@Add "ssh-keyscan -c ..." flag to allow fetching certificates instead
of plain keys; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.102 2015/10/24 22:56:19 djm Exp $ */
d661 1
a661 1
	    "usage: %s [-46Hcv] [-f file] [-p port] [-T timeout] [-t type]\n"
@


1.102
log
@fix keyscan output for multiple hosts/addrs on one line when
host hashing or a non standard port is in use; bz#2479 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.101 2015/04/10 00:08:55 djm Exp $ */
d57 1
d253 26
a278 5
	myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =
	    c->c_keytype == KT_DSA ?  "ssh-dss" :
	    (c->c_keytype == KT_RSA ? "ssh-rsa" :
	    (c->c_keytype == KT_ED25519 ? "ssh-ed25519" :
	    "ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521"));
d309 2
a310 1
	fprintf(stdout, "%s ", hostport);
d324 1
a324 1
	if (!hash_hosts && ssh_port == SSH_DEFAULT_PORT) {
d390 1
d661 1
a661 1
	    "usage: %s [-46Hv] [-f file] [-p port] [-T timeout] [-t type]\n"
d687 1
a687 1
	while ((opt = getopt(argc, argv, "Hv46p:T:t:f:")) != -1) {
d691 3
@


1.101
log
@include port number if a non-default one has been specified;
based on patch from Michael Handler
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.100 2015/04/05 15:43:43 miod Exp $ */
d279 1
a279 1
keyprint(con *c, struct sshkey *key)
d281 1
a281 2
	char *host = c->c_output_name ? c->c_output_name : c->c_name;
	char *hostport = NULL;
a282 2
	if (!key)
		return;
d291 18
@


1.100
log
@Do not use int for sig_atomic_t; spotted by christos@@netbsd; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.99 2015/01/30 10:44:49 djm Exp $ */
d282 1
d289 2
a290 1
	fprintf(stdout, "%s ", host);
d293 1
d474 1
a474 1
	fprintf(stderr, "# %s %s\n", c->c_name, chop(buf));
@


1.99
log
@set a timeout to prevent hangs when talking to busted servers;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.98 2015/01/30 01:13:33 djm Exp $ */
d89 1
a89 1
	int c_done;		/* SSH2 done */
@


1.98
log
@avoid more fatal/exit in the packet.c paths that ssh-keyscan
uses; feedback and "looks good" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.97 2015/01/28 21:15:47 djm Exp $ */
d453 1
@


1.97
log
@avoid fatal() calls in packet code
makes ssh-keyscan more reliable against server failures
ok dtucker@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.96 2015/01/20 23:14:00 deraadt Exp $ */
d451 2
a452 1
	c->c_ssh = ssh_packet_set_connection(NULL, s, s);
@


1.96
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.95 2015/01/19 20:32:39 markus Exp $ */
d304 4
a307 2
	if ((gaierr = getaddrinfo(host, strport, &hints, &aitop)) != 0)
		fatal("getaddrinfo %s: %s", host, ssh_gai_strerror(gaierr));
@


1.95
log
@switch ssh-keyscan from setjmp to multiple ssh transport layer instances
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.94 2015/01/19 20:16:15 markus Exp $ */
a10 1
#include <sys/param.h>
@


1.94
log
@adapt kex to sshbuf and struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.93 2014/12/11 08:20:09 djm Exp $ */
a20 1
#include <setjmp.h>
d31 2
a32 2
#include "buffer.h"
#include "key.h"
d43 2
a73 3
int nonfatal_fatal = 0;
jmp_buf kexjmp;
Key *kexjmp_key;
d90 1
d96 1
a96 1
	struct kex *c_kex;	/* The key-exchange struct for ssh2 */
d104 2
d173 1
a173 1
static Key *
d176 4
a179 2
	static Key *rsa;
	static Buffer msg;
d182 6
a187 2
		buffer_init(&msg);
		rsa = key_new(KEY_RSA1);
d189 5
a193 3
	buffer_append(&msg, c->c_data, c->c_plen);
	buffer_consume(&msg, 8 - (c->c_plen & 7));	/* padding */
	if (buffer_get_char(&msg) != (int) SSH_SMSG_PUBLIC_KEY) {
d195 15
a209 1
		buffer_clear(&msg);
a211 1
	buffer_consume(&msg, 8);		/* cookie */
d213 1
a213 11
	/* server key */
	(void) buffer_get_int(&msg);
	buffer_get_bignum(&msg, rsa->rsa->e);
	buffer_get_bignum(&msg, rsa->rsa->n);

	/* host key */
	(void) buffer_get_int(&msg);
	buffer_get_bignum(&msg, rsa->rsa->e);
	buffer_get_bignum(&msg, rsa->rsa->n);

	buffer_clear(&msg);
d220 1
a220 1
hostjump(Key *hostkey, struct ssh *ssh)
d222 6
a227 2
	kexjmp_key = hostkey;
	longjmp(kexjmp, 1);
d246 1
a246 1
static Key *
d250 1
a250 1
	int r, j;
a251 1
	packet_set_connection(c->c_fd, c->c_fd);
d258 5
a262 3
	if ((r = kex_setup(active_state, myproposal)) < 0)
		fatal("%s: kex_setup: %s", __func__, ssh_err(r));
	c->c_kex = active_state->kex;
d264 5
a268 5
	c->c_kex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;
	c->c_kex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;
	c->c_kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;
	c->c_kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;
	c->c_kex->kex[KEX_ECDH_SHA2] = kexecdh_client;
d270 7
a276 15
	c->c_kex->kex[KEX_C25519_SHA256] = kexc25519_client;
	c->c_kex->verify_host_key = hostjump;

	if (!(j = setjmp(kexjmp))) {
		nonfatal_fatal = 1;
		dispatch_run(DISPATCH_BLOCK, &c->c_kex->done, active_state);
		fprintf(stderr, "Impossible! dispatch_run() returned!\n");
		exit(1);
	}
	nonfatal_fatal = 0;
	free(c->c_kex);
	c->c_kex = NULL;
	packet_close();

	return j < 0? NULL : kexjmp_key;
d280 1
a280 1
keyprint(con *c, Key *key)
d290 1
a290 1
	key_write(key, stdout);
d378 5
d450 2
d454 1
a454 1
		compat_datafellows(remote_version);
d456 1
a456 1
		datafellows = 0;
d483 1
a483 1
		keyprint(c, keygrab_ssh2(c));
d609 1
a609 4
	if (nonfatal_fatal)
		longjmp(kexjmp, -1);
	else
		exit(255);
d680 1
a680 1
				int type = key_type_from_name(tname);
@


1.93
log
@explicitly include sys/param.h in files that use the howmany() macro;
from portable
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.92 2014/04/29 18:01:49 markus Exp $ */
d97 1
a97 1
	Kex *c_kex;		/* The key-exchange struct for ssh2 */
d208 1
a208 1
hostjump(Key *hostkey)
d234 1
a234 1
	int j;
d243 3
a245 1
	c->c_kex = kex_setup(myproposal);
d258 1
a258 1
		dispatch_run(DISPATCH_BLOCK, &c->c_kex->done, c->c_kex);
@


1.92
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.91 2014/03/27 23:01:27 markus Exp $ */
d11 1
@


1.91
log
@disable weak proposals in sshd, but keep them in ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.90 2014/03/12 04:44:58 djm Exp $ */
d170 1
d204 1
d243 1
d249 1
d499 1
d504 1
@


1.90
log
@scan for Ed25519 keys by default too
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.89 2013/12/06 13:39:49 markus Exp $ */
d230 1
@


1.89
log
@support ed25519 keys (hostkeys and user identities) using the public domain
ed25519 reference code from SUPERCOP, see http://ed25519.cr.yp.to/software.html
feedback, help & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.88 2013/11/02 21:59:15 markus Exp $ */
d56 1
a56 1
int get_keytypes = KT_RSA|KT_ECDSA;/* Get RSA and ECDSA keys by default */
@


1.88
log
@use curve25519 for default key exchange (curve25519-sha256@@libssh.org);
initial patch from Aris Adamantiadis; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.87 2013/05/17 00:13:14 djm Exp $ */
d54 1
d234 5
a238 3
	myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = c->c_keytype == KT_DSA?
	    "ssh-dss" : (c->c_keytype == KT_RSA ? "ssh-rsa" :
	    "ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521");
d566 1
a566 1
	for (j = KT_RSA1; j <= KT_ECDSA; j *= 2) {
d670 3
@


1.87
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.86 2012/04/11 13:34:17 djm Exp $ */
d242 1
@


1.86
log
@now that sshd defaults to offering ECDSA keys, ssh-keyscan should also
look for them by default; bz#1971
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.85 2011/03/15 10:36:02 okan Exp $ */
d251 1
a251 1
	xfree(c->c_kex);
d317 1
a317 1
			xfree(namebase);
d351 2
a352 2
	xfree(fdcon[s].c_namebase);
	xfree(fdcon[s].c_output_name);
d354 1
a354 1
		xfree(fdcon[s].c_data);
d541 2
a542 2
	xfree(r);
	xfree(e);
@


1.85
log
@use timerclear macro

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.84 2011/01/04 20:44:13 otto Exp $ */
d55 1
a55 1
int get_keytypes = KT_RSA;	/* Get only RSA keys by default */
@


1.84
log
@handle ecdsa-sha2 with various key lengths; hint and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.83 2010/08/31 11:54:45 djm Exp $ */
d523 1
a523 1
		seltime.tv_sec = seltime.tv_usec = 0;
@


1.83
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.82 2010/06/22 04:54:30 djm Exp $ */
d234 2
a235 1
	    "ssh-dss": "ssh-rsa";
d562 1
a562 1
	for (j = KT_RSA1; j <= KT_RSA; j *= 2) {
@


1.82
log
@replace verbose and overflow-prone Linebuf code with read_keyfile_line()
based on patch from joachim AT joachimschipper.nl; bz#1565; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.81 2010/01/09 23:04:13 dtucker Exp $ */
d50 4
a53 3
#define KT_RSA1	1
#define KT_DSA	2
#define KT_RSA	4
d240 1
d659 3
@


1.81
log
@Remove RoutingDomain from ssh since it's now not needed.  It can be replaced
with "route exec" or "nc -V" as a proxycommand.  "route exec" also ensures
that trafic such as DNS lookups stays withing the specified routingdomain.

For example (from reyk):
# route -T 2 exec /usr/sbin/sshd
or inherited from the parent process
$ route -T 2 exec sh
$ ssh 10.1.2.3

ok deraadt@@ markus@@ stevesk@@ reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.78 2009/01/22 10:02:34 djm Exp $ */
a101 116
/*
 *  This is just a wrapper around fgets() to make it usable.
 */

/* Stress-test.  Increase this later. */
#define LINEBUF_SIZE 16

typedef struct {
	char *buf;
	u_int size;
	int lineno;
	const char *filename;
	FILE *stream;
	void (*errfun) (const char *,...);
} Linebuf;

static Linebuf *
Linebuf_alloc(const char *filename, void (*errfun) (const char *,...))
{
	Linebuf *lb;

	if (!(lb = malloc(sizeof(*lb)))) {
		if (errfun)
			(*errfun) ("linebuf (%s): malloc failed\n",
			    filename ? filename : "(stdin)");
		return (NULL);
	}
	if (filename) {
		lb->filename = filename;
		if (!(lb->stream = fopen(filename, "r"))) {
			xfree(lb);
			if (errfun)
				(*errfun) ("%s: %s\n", filename, strerror(errno));
			return (NULL);
		}
	} else {
		lb->filename = "(stdin)";
		lb->stream = stdin;
	}

	if (!(lb->buf = malloc((lb->size = LINEBUF_SIZE)))) {
		if (errfun)
			(*errfun) ("linebuf (%s): malloc failed\n", lb->filename);
		xfree(lb);
		return (NULL);
	}
	lb->errfun = errfun;
	lb->lineno = 0;
	return (lb);
}

static void
Linebuf_free(Linebuf * lb)
{
	fclose(lb->stream);
	xfree(lb->buf);
	xfree(lb);
}

#if 0
static void
Linebuf_restart(Linebuf * lb)
{
	clearerr(lb->stream);
	rewind(lb->stream);
	lb->lineno = 0;
}

static int
Linebuf_lineno(Linebuf * lb)
{
	return (lb->lineno);
}
#endif

static char *
Linebuf_getline(Linebuf * lb)
{
	size_t n = 0;
	void *p;

	lb->lineno++;
	for (;;) {
		/* Read a line */
		if (!fgets(&lb->buf[n], lb->size - n, lb->stream)) {
			if (ferror(lb->stream) && lb->errfun)
				(*lb->errfun)("%s: %s\n", lb->filename,
				    strerror(errno));
			return (NULL);
		}
		n = strlen(lb->buf);

		/* Return it or an error if it fits */
		if (n > 0 && lb->buf[n - 1] == '\n') {
			lb->buf[n - 1] = '\0';
			return (lb->buf);
		}
		if (n != lb->size - 1) {
			if (lb->errfun)
				(*lb->errfun)("%s: skipping incomplete last line\n",
				    lb->filename);
			return (NULL);
		}
		/* Double the buffer if we need more space */
		lb->size *= 2;
		if ((p = realloc(lb->buf, lb->size)) == NULL) {
			lb->size /= 2;
			if (lb->errfun)
				(*lb->errfun)("linebuf (%s): realloc failed\n",
				    lb->filename);
			return (NULL);
		}
		lb->buf = p;
	}
}

d596 4
a599 2
	int opt, fopt_count = 0;
	char *tname;
d697 24
a720 8
	if (fopt_count) {
		Linebuf *lb;
		char *line;
		int j;

		for (j = 0; j < fopt_count; j++) {
			lb = Linebuf_alloc(argv[j], error);
			if (!lb)
d722 2
a723 3
			while ((line = Linebuf_getline(lb)) != NULL)
				do_host(line);
			Linebuf_free(lb);
d725 6
@


1.80
log
@validate routing domain is in range 0-RT_TABLEID_MAX.
'Looks right' deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.79 2009/10/28 16:38:18 reyk Exp $ */
a65 3
/* The default routing domain */
int scan_rdomain = -1;

d400 1
a400 2
		s = socket_rdomain(ai->ai_family, ai->ai_socktype,
		    ai->ai_protocol, scan_rdomain);
d703 1
a703 1
	    "\t\t   [-V rdomain] [host | addrlist namelist] ...\n",
d726 1
a726 1
	while ((opt = getopt(argc, argv, "Hv46p:T:t:f:V:")) != -1) {
a785 7
			break;
		case 'V':
			scan_rdomain = a2rdomain(optarg);
			if (scan_rdomain == -1) {
				fprintf(stderr, "Bad rdomain '%s'\n", optarg);
				exit(1);
			}
@


1.79
log
@Allow to set the rdomain in ssh/sftp/scp/sshd and ssh-keyscan.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.78 2009/01/22 10:02:34 djm Exp $ */
d792 5
a796 3
			scan_rdomain = a2port(optarg);
			if (scan_rdomain < 0)
				scan_rdomain = -1;
@


1.78
log
@make a2port() return -1 when it encounters an invalid port number
rather than 0, which it will now treat as valid (needed for future work)

adjust current consumers of a2port() to check its return value is <= 0,
which in turn required some things to be converted from u_short => int

make use of int vs. u_short consistent in some other places too

feedback & ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.77 2008/11/01 11:14:36 sobrado Exp $ */
d66 3
d403 2
a404 1
		s = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
d707 1
a707 1
	    "\t\t   [host | addrlist namelist] ...\n",
d730 1
a730 1
	while ((opt = getopt(argc, argv, "Hv46p:T:t:f:")) != -1) {
d790 5
@


1.77
log
@the ellipsis is not an optional argument; while here, improve spacing.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.76 2008/04/30 10:14:03 djm Exp $ */
d733 1
a733 1
			if (ssh_port == 0) {
@


1.76
log
@default to rsa (protocol 2) keys, instead of rsa1 keys; spotted by
larsnooden AT openoffice.org
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.75 2007/12/27 14:22:08 dtucker Exp $ */
d701 3
a703 2
	fprintf(stderr, "usage: %s [-46Hv] [-f file] [-p port] [-T timeout] [-t type]\n"
	    "\t\t   [host | addrlist namelist] [...]\n",
@


1.75
log
@Add a small helper function to consistently handle the EAI_SYSTEM error
code of getaddrinfo.  Prompted by vgiffin at apple com via bz #1417.
ok markus@@ stevesk@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.74 2006/10/06 02:29:19 djm Exp $ */
d54 1
a54 1
int get_keytypes = KT_RSA1;	/* Get only RSA1 keys by default */
@


1.74
log
@sys/resource.h needs sys/time.h; prompted by brad@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.73 2006/08/03 03:34:42 deraadt Exp $ */
d398 1
a398 1
		fatal("getaddrinfo %s: %s", host, gai_strerror(gaierr));
@


1.73
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.72 2006/08/01 23:22:47 stevesk Exp $ */
d13 1
a14 1
#include <sys/time.h>
@


1.73.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.74 2006/10/06 02:29:19 djm Exp $ */
d13 1
a14 1
#include <sys/resource.h>
@


1.72
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.71 2006/07/26 13:57:17 stevesk Exp $ */
a9 2
#include "includes.h"

d24 1
d31 1
d33 1
a38 2
#include "buffer.h"
#include "bufaux.h"
@


1.71
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.70 2006/07/25 02:59:21 stevesk Exp $ */
d24 1
@


1.70
log
@move #include <sys/time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.69 2006/07/22 20:48:23 stevesk Exp $ */
d24 1
@


1.69
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.68 2006/07/17 01:31:10 stevesk Exp $ */
d16 1
@


1.68
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.67 2006/07/12 22:28:52 stevesk Exp $ */
d17 2
d23 1
a24 2

#include <openssl/bn.h>
@


1.67
log
@move #include <netdb.h> out of includes.h; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.66 2006/07/10 16:37:36 stevesk Exp $ */
d21 1
@


1.66
log
@move #include <stdarg.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.65 2006/07/08 21:47:12 stevesk Exp $ */
d18 1
@


1.65
log
@move #include <sys/socket.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.64 2006/03/25 13:17:02 djm Exp $ */
d19 1
@


1.64
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d12 2
@


1.63
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.62
log
@please lint
@
text
@d59 1
a59 1
size_t read_wait_size;
d629 4
a632 4
	r = xmalloc(read_wait_size);
	memcpy(r, read_wait, read_wait_size);
	e = xmalloc(read_wait_size);
	memcpy(e, read_wait, read_wait_size);
d796 1
a796 2
	fdcon = xmalloc(maxfd * sizeof(con));
	memset(fdcon, 0, maxfd * sizeof(con));
d798 2
a799 3
	read_wait_size = howmany(maxfd, NFDBITS) * sizeof(fd_mask);
	read_wait = xmalloc(read_wait_size);
	memset(read_wait, 0, read_wait_size);
@


1.61
log
@RCSID() can die
@
text
@d133 1
a133 1
	if (!(lb->buf = malloc(lb->size = LINEBUF_SIZE))) {
a597 1
			break;
@


1.60
log
@Implement the diffie-hellman-group-exchange-sha256 key exchange method
using the SHA256 code in libc (and wrapper to make it into an OpenSSL
EVP), interop tested against CVS PuTTY
@
text
@a9 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.59 2006/02/08 14:31:30 stevesk Exp $");
@


1.59
log
@move #include <sys/resource.h> out of includes.h; ok markus@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.58 2006/02/07 01:18:09 stevesk Exp $");
d346 1
@


1.59.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh-keyscan.c,v 1.73 2006/08/03 03:34:42 deraadt Exp $ */
d9 3
a11 2
#include <sys/types.h>
#include <sys/socket.h>
a13 3
#include <sys/time.h>

#include <openssl/bn.h>
a15 1
#include <netdb.h>
d17 2
a18 6
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
a22 1
#include "buffer.h"
a23 1
#include "cipher.h"
d29 2
d60 1
a60 1
size_t read_wait_nfdset;
d134 1
a134 1
	if (!(lb->buf = malloc((lb->size = LINEBUF_SIZE)))) {
a345 1
	c->c_kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;
d598 1
d630 4
a633 4
	r = xcalloc(read_wait_nfdset, sizeof(fd_mask));
	e = xcalloc(read_wait_nfdset, sizeof(fd_mask));
	memcpy(r, read_wait, read_wait_nfdset * sizeof(fd_mask));
	memcpy(e, read_wait, read_wait_nfdset * sizeof(fd_mask));
d797 2
a798 1
	fdcon = xcalloc(maxfd, sizeof(con));
d800 3
a802 2
	read_wait_nfdset = howmany(maxfd, NFDBITS);
	read_wait = xcalloc(read_wait_nfdset, sizeof(fd_mask));
@


1.59.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.74 2006/10/06 02:29:19 djm Exp $ */
d13 1
a14 1
#include <sys/resource.h>
@


1.58
log
@move #include <sys/queue.h> out of includes.h; ok markus@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.57 2005/10/30 04:01:03 djm Exp $");
d13 1
@


1.57
log
@make ssh-keygen discard junk from server before SSH- ident, spotted by
dave AT cirt.net; ok dtucker@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.56 2005/09/13 23:40:07 djm Exp $");
d13 1
d15 1
a18 1
#include <setjmp.h>
@


1.56
log
@ensure that stdio fds are attached; ok deraadt@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.55 2005/06/17 02:44:33 djm Exp $");
d493 12
a504 6
	bufsiz = sizeof(buf);
	cp = buf;
	while (bufsiz-- && (n = atomicio(read, s, cp, 1)) == 1 && *cp != '\n') {
		if (*cp == '\r')
			*cp = '\n';
		cp++;
@


1.55
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.54 2005/05/24 17:32:44 avsm Exp $");
d702 3
@


1.55.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.57 2005/10/30 04:01:03 djm Exp $");
d493 6
a498 12
	for (;;) {
		memset(buf, '\0', sizeof(buf));
		bufsiz = sizeof(buf);
		cp = buf;
		while (bufsiz-- &&
		    (n = atomicio(read, s, cp, 1)) == 1 && *cp != '\n') {
			if (*cp == '\r')
				*cp = '\n';
			cp++;
		}
		if (n != 1 || strncmp(buf, "SSH-", 4) == 0)
			break;
a701 3

	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();
@


1.55.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh-keyscan.c,v 1.73 2006/08/03 03:34:42 deraadt Exp $ */
d9 3
a11 2
#include <sys/types.h>
#include <sys/socket.h>
d13 1
a13 2
#include <sys/time.h>
#include <sys/resource.h>
a16 2
#include <errno.h>
#include <netdb.h>
a17 7
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

a20 1
#include "buffer.h"
a21 1
#include "cipher.h"
d27 2
d58 1
a58 1
size_t read_wait_nfdset;
d132 1
a132 1
	if (!(lb->buf = malloc((lb->size = LINEBUF_SIZE)))) {
a343 1
	c->c_kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;
d596 1
d628 4
a631 4
	r = xcalloc(read_wait_nfdset, sizeof(fd_mask));
	e = xcalloc(read_wait_nfdset, sizeof(fd_mask));
	memcpy(r, read_wait, read_wait_nfdset * sizeof(fd_mask));
	memcpy(e, read_wait, read_wait_nfdset * sizeof(fd_mask));
d795 2
a796 1
	fdcon = xcalloc(maxfd, sizeof(con));
d798 3
a800 2
	read_wait_nfdset = howmany(maxfd, NFDBITS);
	read_wait = xcalloc(read_wait_nfdset, sizeof(fd_mask));
@


1.55.2.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keyscan.c,v 1.74 2006/10/06 02:29:19 djm Exp $ */
@


1.54
log
@Switch atomicio to use a simpler interface; it now returns a size_t
(containing number of bytes read/written), and indicates error by
returning 0.  EOF is signalled by errno==EPIPE.
Typical use now becomes:

if (atomicio(read, ..., len) != len)
        err(1,"read");

ok deraadt@@, cloder@@, djm@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.53 2005/04/28 10:17:56 moritz Exp $");
d170 1
a170 1
	int n = 0;
d487 1
a487 1
	int remote_major = 0, remote_minor = 0;
d490 1
a490 1
	size_t bufsiz, n = 0;
d540 1
a540 1
	if (n == -1 || n >= sizeof buf) {
d545 1
a545 1
	if (atomicio(vwrite, s, buf, n) != n) {
@


1.53
log
@add snprintf checks. ok djm@@ markus@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.52 2005/03/01 15:47:14 jmc Exp $");
d487 1
a487 1
	int remote_major = 0, remote_minor = 0, n = 0;
d490 1
a490 1
	size_t bufsiz;
d500 8
a507 2
	if (n < 0) {
		if (errno != ECONNREFUSED)
d509 2
a510 5
		conrecycle(s);
		return;
	}
	if (n == 0) {
		error("%s: Connection closed by remote host", c->c_name);
d563 1
a563 1
	int n;
d570 1
a570 1
	if (n < 0) {
@


1.52
log
@sort options and sync usage();
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.51 2005/03/01 10:41:28 djm Exp $");
d537 5
@


1.52.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.55 2005/06/17 02:44:33 djm Exp $");
d170 1
a170 1
	size_t n = 0;
d487 1
a487 1
	int n = 0, remote_major = 0, remote_minor = 0;
d500 6
d507 1
a507 10
		switch (errno) {
		case EPIPE:
			error("%s: Connection closed by remote host", c->c_name);
			break;
		case ECONNREFUSED:
			break;
		default:
			error("read (%s): %s", c->c_name, strerror(errno));
			break;
		}
d537 1
a537 6
	if (n < 0 || (size_t)n >= sizeof(buf)) {
		error("snprintf: buffer too small");
		confree(s);
		return;
	}
	if (atomicio(vwrite, s, buf, n) != (size_t)n) {
d555 1
a555 1
	size_t n;
d562 1
a562 1
	if (n == 0) {
@


1.52.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.57 2005/10/30 04:01:03 djm Exp $");
d493 6
a498 12
	for (;;) {
		memset(buf, '\0', sizeof(buf));
		bufsiz = sizeof(buf);
		cp = buf;
		while (bufsiz-- &&
		    (n = atomicio(read, s, cp, 1)) == 1 && *cp != '\n') {
			if (*cp == '\r')
				*cp = '\n';
			cp++;
		}
		if (n != 1 || strncmp(buf, "SSH-", 4) == 0)
			break;
a701 3

	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();
@


1.51
log
@option to hash hostnames output by ssh-keyscan; ok markus@@ deraadt@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.50 2004/08/11 21:44:32 avsm Exp $");
d677 1
a677 1
	fprintf(stderr, "usage: %s [-Hv46] [-p port] [-T timeout] [-t type] [-f file]\n"
@


1.50
log
@use atomicio instead of homegrown equivalents or read/write.
markus@@ ok
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.49 2004/06/14 01:44:39 djm Exp $");
d32 1
d46 2
d363 2
d367 2
d370 1
a370 1
	fprintf(stdout, "%s ", c->c_output_name ? c->c_output_name : c->c_name);
d677 1
a677 1
	fprintf(stderr, "usage: %s [-v46] [-p port] [-T timeout] [-t type] [-f file]\n"
d698 1
a698 1
	while ((opt = getopt(argc, argv, "v46p:T:t:f:")) != -1) {
d700 3
@


1.50.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.52 2005/03/01 15:47:14 jmc Exp $");
a31 1
#include "hostfile.h"
a44 2
int hash_hosts = 0;		/* Hash hostname on output */

a359 2
	char *host = c->c_output_name ? c->c_output_name : c->c_name;

a361 2
	if (hash_hosts && (host = host_hash(host, NULL, 0)) == NULL)
		fatal("host_hash failed");
d363 1
a363 1
	fprintf(stdout, "%s ", host);
d670 1
a670 1
	fprintf(stderr, "usage: %s [-46Hv] [-f file] [-p port] [-T timeout] [-t type]\n"
d691 1
a691 1
	while ((opt = getopt(argc, argv, "Hv46p:T:t:f:")) != -1) {
a692 3
		case 'H':
			hash_hosts = 1;
			break;
@


1.50.2.2
log
@upgrade to OpenSSH 4.2
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.55 2005/06/17 02:44:33 djm Exp $");
d170 1
a170 1
	size_t n = 0;
d487 1
a487 1
	int n = 0, remote_major = 0, remote_minor = 0;
d500 6
d507 1
a507 10
		switch (errno) {
		case EPIPE:
			error("%s: Connection closed by remote host", c->c_name);
			break;
		case ECONNREFUSED:
			break;
		default:
			error("read (%s): %s", c->c_name, strerror(errno));
			break;
		}
d537 1
a537 6
	if (n < 0 || (size_t)n >= sizeof(buf)) {
		error("snprintf: buffer too small");
		confree(s);
		return;
	}
	if (atomicio(vwrite, s, buf, n) != (size_t)n) {
d555 1
a555 1
	size_t n;
d562 1
a562 1
	if (n == 0) {
@


1.49
log
@set_nonblock() instead of fnctl(...,O_NONBLOCK); "looks sane" deraadt@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.48 2004/06/13 12:53:24 djm Exp $");
d488 1
a488 1
	while (bufsiz-- && (n = read(s, cp, 1)) == 1 && *cp != '\n') {
d554 1
a554 1
	n = read(s, c->c_data + c->c_off, c->c_len - c->c_off);
@


1.48
log
@implement diffie-hellman-group14-sha1 kex method (trivial extension to
existing diffie-hellman-group1-sha1); ok markus@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.47 2004/03/08 09:38:05 djm Exp $");
d387 2
a388 2
		if (fcntl(s, F_SETFL, O_NONBLOCK) < 0)
			fatal("F_SETFL: %s", strerror(errno));
@


1.47
log
@explicitly initialise remote_major and remote_minor.
from cjwatson AT debian.org; ok markus@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.46 2003/11/23 23:17:34 djm Exp $");
d339 1
@


1.47.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.50 2004/08/11 21:44:32 avsm Exp $");
a338 1
	c->c_kex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;
d386 2
a387 2
		if (set_nonblock(s) == -1)
			fatal("%s: set_nonblock(%d)", __func__, s);
d487 1
a487 1
	while (bufsiz-- && (n = atomicio(read, s, cp, 1)) == 1 && *cp != '\n') {
d553 1
a553 1
	n = atomicio(read, s, c->c_data + c->c_off, c->c_len - c->c_off);
@


1.47.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.52 2005/03/01 15:47:14 jmc Exp $");
a31 1
#include "hostfile.h"
a44 2
int hash_hosts = 0;		/* Hash hostname on output */

a359 2
	char *host = c->c_output_name ? c->c_output_name : c->c_name;

a361 2
	if (hash_hosts && (host = host_hash(host, NULL, 0)) == NULL)
		fatal("host_hash failed");
d363 1
a363 1
	fprintf(stdout, "%s ", host);
d670 1
a670 1
	fprintf(stderr, "usage: %s [-46Hv] [-f file] [-p port] [-T timeout] [-t type]\n"
d691 1
a691 1
	while ((opt = getopt(argc, argv, "Hv46p:T:t:f:")) != -1) {
a692 3
		case 'H':
			hash_hosts = 1;
			break;
@


1.46
log
@from portable - use sysconf to detect fd limit; ok markus@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.45 2003/09/19 11:30:39 markus Exp $");
d479 1
a479 1
	int remote_major, remote_minor, n = 0;
@


1.45
log
@avoid fatal_cleanup, just call exit(); ok deraadt
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.44 2003/06/28 16:23:06 deraadt Exp $");
d213 1
a213 1
		return 10000;
@


1.44
log
@deal with typing of write vs read in atomicio
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.43 2003/04/26 04:29:49 deraadt Exp $");
d663 1
a663 1
		fatal_cleanup();
@


1.44.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.46 2003/11/23 23:17:34 djm Exp $");
d213 1
a213 1
		return sysconf(_SC_OPEN_MAX);
d663 1
a663 1
		exit(255);
@


1.44.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.50 2004/08/11 21:44:32 avsm Exp $");
a338 1
	c->c_kex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;
d386 2
a387 2
		if (set_nonblock(s) == -1)
			fatal("%s: set_nonblock(%d)", __func__, s);
d479 1
a479 1
	int remote_major = 0, remote_minor = 0, n = 0;
d487 1
a487 1
	while (bufsiz-- && (n = atomicio(read, s, cp, 1)) == 1 && *cp != '\n') {
d553 1
a553 1
	n = atomicio(read, s, c->c_data + c->c_off, c->c_len - c->c_off);
@


1.43
log
@-t in usage(); rogier@@quaak.org
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.42 2003/04/14 14:17:50 markus Exp $");
d529 1
a529 1
	if (atomicio(write, s, buf, n) != n) {
@


1.42
log
@avoid hardcoded SOCK_xx; with itojun@@; should allow ssh over SCTP
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.41 2003/02/16 17:09:57 markus Exp $");
d669 1
a669 1
	fprintf(stderr, "usage: %s [-v46] [-p port] [-T timeout] [-f file]\n"
@


1.41
log
@split kex into client and server code, no need to link
server code into the client; ok provos@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.40 2002/07/06 17:47:58 stevesk Exp $");
d381 1
a381 1
		s = socket(ai->ai_family, SOCK_STREAM, 0);
@


1.41.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.44 2003/06/28 16:23:06 deraadt Exp $");
d381 1
a381 1
		s = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
d529 1
a529 1
	if (atomicio(vwrite, s, buf, n) != n) {
d669 1
a669 1
	fprintf(stderr, "usage: %s [-v46] [-p port] [-T timeout] [-t type] [-f file]\n"
@


1.41.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.46 2003/11/23 23:17:34 djm Exp $");
d213 1
a213 1
		return sysconf(_SC_OPEN_MAX);
d663 1
a663 1
		exit(255);
@


1.40
log
@unused variable
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.39 2002/07/06 01:01:26 deraadt Exp $");
d338 2
@


1.40.2.1
log
@Update to OpenSSH 3.6
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.41 2003/02/16 17:09:57 markus Exp $");
a337 2
	c->c_kex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;
	c->c_kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;
@


1.40.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.44 2003/06/28 16:23:06 deraadt Exp $");
d381 1
a381 1
		s = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
d529 1
a529 1
	if (atomicio(vwrite, s, buf, n) != n) {
d669 1
a669 1
	fprintf(stderr, "usage: %s [-v46] [-p port] [-T timeout] [-t type] [-f file]\n"
@


1.39
log
@KNF, realloc fix, and clean usage
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.38 2002/06/27 19:49:08 stevesk Exp $");
a166 1
	u_int size;
@


1.38
log
@use convtime(); ok markus@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.37 2002/06/27 08:49:44 markus Exp $");
d167 1
d169 1
d176 1
a176 1
				(*lb->errfun) ("%s: %s\n", lb->filename,
d189 1
a189 1
				(*lb->errfun) ("%s: skipping incomplete last line\n",
d194 3
a196 1
		if (!(lb->buf = realloc(lb->buf, (lb->size *= 2)))) {
d198 1
a198 1
				(*lb->errfun) ("linebuf (%s): realloc failed\n",
d202 1
d223 1
d402 1
a403 1
	char *namebase, *name, *namelist;
d467 1
a468 1
	con *c = &fdcon[s];
d478 1
a481 1
	int remote_major, remote_minor, n = 0;
d545 1
a546 1
	con *c = &fdcon[s];
d585 1
d587 1
a587 1
	struct timeval seltime, now;
a588 1
	con *c;
d655 1
d668 2
a669 1
	fprintf(stderr, "Usage: %s [options] host ...\n",
a670 8
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -f file     Read hosts or addresses from file.\n");
	fprintf(stderr, "  -p port     Connect to the specified port.\n");
	fprintf(stderr, "  -t keytype  Specify the host key type.\n");
	fprintf(stderr, "  -T timeout  Set connection timeout.\n");
	fprintf(stderr, "  -v          Verbose; display verbose debugging messages.\n");
	fprintf(stderr, "  -4          Use IPv4 only.\n");
	fprintf(stderr, "  -6          Use IPv6 only.\n");
@


1.37
log
@more checks for NULL pointers; from grendel@@zeitbombe.org; ok deraadt@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.36 2002/06/16 21:30:58 itojun Exp $");
d699 3
a701 2
			timeout = atoi(optarg);
			if (timeout <= 0)
d703 1
@


1.36
log
@use TAILQ_xx macro.  from lukem@@netbsd.  markus ok
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.35 2002/03/04 18:30:23 stevesk Exp $");
d112 2
a113 1
			(*errfun) ("linebuf (%s): malloc failed\n", lb->filename);
@


1.35
log
@handle connection close during read of protocol version string.
fixes erroneous "bad greeting".  ok markus@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.34 2002/02/22 12:20:34 markus Exp $");
d584 1
a584 1
	c = tq.tqh_first;
d617 1
a617 1
	c = tq.tqh_first;
d622 1
a622 1
		c = c->c_link.tqe_next;
@


1.35.2.1
log
@Pull in OpenSSH-3.4
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.36 2002/06/16 21:30:58 itojun Exp $");
d584 1
a584 1
	c = TAILQ_FIRST(&tq);
d617 1
a617 1
	c = TAILQ_FIRST(&tq);
d622 1
a622 1
		c = TAILQ_NEXT(c, c_link);
@


1.35.2.2
log
@Update to OpenSSH 3.5
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.40 2002/07/06 17:47:58 stevesk Exp $");
d112 1
a112 2
			(*errfun) ("linebuf (%s): malloc failed\n",
			    filename ? filename : "(stdin)");
a166 1
	void *p;
d173 1
a173 1
				(*lb->errfun)("%s: %s\n", lb->filename,
d186 1
a186 1
				(*lb->errfun)("%s: skipping incomplete last line\n",
d191 1
a191 3
		lb->size *= 2;
		if ((p = realloc(lb->buf, lb->size)) == NULL) {
			lb->size /= 2;
d193 1
a193 1
				(*lb->errfun)("linebuf (%s): realloc failed\n",
a196 1
		lb->buf = p;
a216 1

d395 1
a396 1
	int s;
d460 1
a461 1
	int ret;
a470 1
	int remote_major, remote_minor, n = 0;
d474 1
d538 1
a539 1
	int n;
d578 1
d580 1
a580 1
	fd_set *r, *e;
a581 1
	int i;
a647 1

d660 1
a660 2
	fprintf(stderr, "usage: %s [-v46] [-p port] [-T timeout] [-f file]\n"
	    "\t\t   [host | addrlist namelist] [...]\n",
d662 8
d698 2
a699 3
			timeout = convtime(optarg);
			if (timeout == -1 || timeout == 0) {
				fprintf(stderr, "Bad timeout '%s'\n", optarg);
a700 1
			}
@


1.35.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.41 2003/02/16 17:09:57 markus Exp $");
a337 2
	c->c_kex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;
	c->c_kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;
@


1.34
log
@overwrite fatal() in ssh-keyscan.c; fixes pr 2354; ok provos@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.33 2001/12/10 20:34:31 markus Exp $");
d487 5
@


1.33
log
@check that server supports v1 for -t rsa1, report from wirth@@dfki.de
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.32 2001/11/22 05:27:29 stevesk Exp $");
d639 2
a640 2
static void
fatal_callback(void *arg)
d642 4
d648 2
d662 3
a664 3
        fprintf(stderr, "  -v          Verbose; display verbose debugging messages.\n");
        fprintf(stderr, "  -4          Use IPv4 only.\n");
        fprintf(stderr, "  -6          Use IPv6 only.\n");
a747 1
	fatal_add_cleanup(fatal_callback, NULL);
@


1.32
log
@don't use "\n" in fatal()
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.31 2001/11/16 12:46:13 markus Exp $");
d472 1
d474 1
a474 1
	int n = 0;
d496 5
a501 8
		int remote_major, remote_minor;
		char remote_version[sizeof buf];

		if (sscanf(buf, "SSH-%d.%d-%[^\n]\n",
		    &remote_major, &remote_minor, remote_version) == 3)
			compat_datafellows(remote_version);
		else
			datafellows = 0;
d507 4
@


1.31
log
@handle empty lines instead of dumping core; report from sha@@sha-1.net
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.30 2001/10/08 19:05:05 markus Exp $");
d720 1
a720 1
					fatal("unknown key type %s\n", tname);
@


1.30
log
@some more IPv4or6 cleanup
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.29 2001/08/30 22:22:32 markus Exp $");
d626 2
@


1.30.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.35 2002/03/04 18:30:23 stevesk Exp $");
a471 1
	char remote_version[sizeof buf];
d473 1
a473 1
	int remote_major, remote_minor, n = 0;
a488 5
	if (n == 0) {
		error("%s: Connection closed by remote host", c->c_name);
		conrecycle(s);
		return;
	}
a494 5
	if (sscanf(buf, "SSH-%d.%d-%[^\n]\n",
	    &remote_major, &remote_minor, remote_version) == 3)
		compat_datafellows(remote_version);
	else
		datafellows = 0;
d496 8
a508 4
	} else if (remote_major != 1) {
		debug("%s doesn't support ssh1", c->c_name);
		confree(s);
		return;
a625 2
	if (name == NULL)
		return;
d635 2
a636 2
void
fatal(const char *fmt,...)
a637 4
	va_list args;
	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_FATAL, fmt, args);
	va_end(args);
a639 2
	else
		fatal_cleanup();
d652 3
a654 3
	fprintf(stderr, "  -v          Verbose; display verbose debugging messages.\n");
	fprintf(stderr, "  -4          Use IPv4 only.\n");
	fprintf(stderr, "  -6          Use IPv6 only.\n");
d718 1
a718 1
					fatal("unknown key type %s", tname);
d738 1
@


1.30.2.2
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.30.2.1 2002/03/07 17:37:47 jason Exp $");
d584 1
a584 1
	c = TAILQ_FIRST(&tq);
d617 1
a617 1
	c = TAILQ_FIRST(&tq);
d622 1
a622 1
		c = TAILQ_NEXT(c, c_link);
@


1.30.2.3
log
@Update to OpenSSH 3.5
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.40 2002/07/06 17:47:58 stevesk Exp $");
d112 1
a112 2
			(*errfun) ("linebuf (%s): malloc failed\n",
			    filename ? filename : "(stdin)");
a166 1
	void *p;
d173 1
a173 1
				(*lb->errfun)("%s: %s\n", lb->filename,
d186 1
a186 1
				(*lb->errfun)("%s: skipping incomplete last line\n",
d191 1
a191 3
		lb->size *= 2;
		if ((p = realloc(lb->buf, lb->size)) == NULL) {
			lb->size /= 2;
d193 1
a193 1
				(*lb->errfun)("linebuf (%s): realloc failed\n",
a196 1
		lb->buf = p;
a216 1

d395 1
a396 1
	int s;
d460 1
a461 1
	int ret;
a470 1
	int remote_major, remote_minor, n = 0;
d474 1
d538 1
a539 1
	int n;
d578 1
d580 1
a580 1
	fd_set *r, *e;
a581 1
	int i;
a647 1

d660 1
a660 2
	fprintf(stderr, "usage: %s [-v46] [-p port] [-T timeout] [-f file]\n"
	    "\t\t   [host | addrlist namelist] [...]\n",
d662 8
d698 2
a699 3
			timeout = convtime(optarg);
			if (timeout == -1 || timeout == 0) {
				fprintf(stderr, "Bad timeout '%s'\n", optarg);
a700 1
			}
@


1.29
log
@do not pass pointers to longjmp; fix from wayne@@blorf.net
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.28 2001/08/27 22:02:13 danh Exp $");
a34 3
#ifdef IPV4_DEFAULT
int IPv4or6 = AF_INET;
#else
a35 1
#endif
@


1.28
log
@fix memory fault if non-existent filename is given to the -f option

ok markus@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.27 2001/08/05 23:29:58 markus Exp $");
d63 1
d306 2
a307 1
	longjmp(kexjmp, (int)hostkey);
a347 2
	if (j < 0)
		j = 0;
d349 1
a349 1
	return (Key*)(j);
@


1.27
log
@make -t dsa work with commercial servers, too
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.26 2001/08/05 23:18:20 markus Exp $");
d767 2
@


1.26
log
@ssh 2 support; from wayned@@users.sourceforge.net
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.25 2001/08/03 10:31:30 jakob Exp $");
d482 3
a484 1
	while (bufsiz-- && (n = read(s, cp, 1)) == 1 && *cp != '\n' && *cp != '\r')
d486 1
a498 1
	fprintf(stderr, "# %s %s\n", c->c_name, buf);
d514 1
@


1.25
log
@improve usage(). ok markus@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.24 2001/06/23 15:12:20 itojun Exp $");
d17 1
d22 5
d31 1
d33 9
a41 1
static int argno = 1;		/* Number of argument currently being parsed */
d43 5
a47 1
int family = AF_UNSPEC;		/* IPv4, IPv6 or both */
d61 2
d78 1
d84 1
d268 2
a269 2
static void
keyprint(char *host, char *output_name, char *kd, int len)
d278 2
a279 2
	buffer_append(&msg, kd, len);
	buffer_consume(&msg, 8 - (len & 7));	/* padding */
d281 1
a281 1
		error("%s: invalid packet type", host);
d283 1
a283 1
		return;
d296 1
d299 61
a359 2
	fprintf(stdout, "%s ", output_name ? output_name : host);
	key_write(rsa, stdout);
d370 1
a370 1
	snprintf(strport, sizeof strport, "%d", SSH_DEFAULT_PORT);
d372 1
a372 1
	hints.ai_family = family;
d397 1
a397 1
conalloc(char *iname, char *oname)
d426 1
d446 1
a465 1
	char *iname, *oname;
d467 1
a467 2
	iname = xstrdup(c->c_namelist);
	oname = xstrdup(c->c_output_name);
a468 3
	ret = conalloc(iname, oname);
	xfree(iname);
	xfree(oname);
d475 1
a475 1
	char buf[80], *cp;
d497 18
a514 1
	n = snprintf(buf, sizeof buf, "SSH-1.5-OpenSSH-keyscan\r\n");
d520 5
d557 1
a557 1
			keyprint(c->c_name, c->c_output_name, c->c_data, c->c_plen);
d621 2
a622 2
static char *
nexthost(int argc, char **argv)
d624 2
a625 1
	static Linebuf *lb;
d627 5
a631 34
	for (;;) {
		if (!lb) {
			if (argno >= argc)
				return (NULL);
			if (argv[argno][0] != '-')
				return (argv[argno++]);
			if (!strcmp(argv[argno], "--")) {
				if (++argno >= argc)
					return (NULL);
				return (argv[argno++]);
			} else if (!strncmp(argv[argno], "-f", 2)) {
				char *fname;

				if (argv[argno][2])
					fname = &argv[argno++][2];
				else if (++argno >= argc) {
					error("missing filename for `-f'");
					return (NULL);
				} else
					fname = argv[argno++];
				if (!strcmp(fname, "-"))
					fname = NULL;
				lb = Linebuf_alloc(fname, error);
			} else
				error("ignoring invalid/misplaced option `%s'",
				    argv[argno++]);
		} else {
			char *line;

			line = Linebuf_getline(lb);
			if (line)
				return (line);
			Linebuf_free(lb);
			lb = NULL;
d637 7
d646 1
a646 1
	fprintf(stderr, "Usage: %s [options] [ host | addrlist namelist ]\n",
a648 1
	fprintf(stderr, "  -t timeout  Set connection timeout.\n");
d650 6
d662 6
a667 1
	char *host = NULL;
d671 1
a671 1
	if (argc <= argno)
d674 12
a685 6
	if (argv[1][0] == '-' && argv[1][1] == 't') {
		argno++;
		if (argv[1][2])
			timeout = atoi(&argv[1][2]);
		else {
			if (argno >= argc)
d687 46
a732 1
			timeout = atoi(argv[argno++]);
a733 2
		if (timeout <= 0)
			usage();
d735 1
a735 1
	if (argc <= argno)
d738 3
d757 15
a771 3
	do {
		while (ncon < MAXCON) {
			char *name;
a772 8
			host = nexthost(argc, argv);
			if (host == NULL)
				break;
			name = strnnsep(&host, " \t\n");
			conalloc(name, *host ? host : name);
		}
		conloop();
	} while (host);
@


1.24
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.23 2001/06/05 05:05:39 pvalchev Exp $");
d565 6
a570 2
	fatal("usage: %s [-t timeout] { [--] host | -f file } ...", __progname);
	return;
@


1.23
log
@License clarification from David Mazieres, ok deraadt@@
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.22 2001/03/06 06:11:18 deraadt Exp $");
d85 1
a85 1
Linebuf *
d119 1
a119 1
void
d127 2
a128 1
void
d136 1
a136 1
int
d141 1
d143 1
a143 1
char *
d180 1
a180 1
int
d193 1
a193 1
int
d212 1
a212 1
char *
d234 1
a234 1
char *
d245 1
a245 1
void
d280 1
a280 1
int
d313 1
a313 1
int
d351 1
a351 1
void
d367 1
a367 1
void
d376 1
a376 1
int
d392 1
a392 1
void
d427 1
a427 1
void
d467 1
a467 1
void
d519 1
a519 1
char *
d562 1
a562 1
void
@


1.22
log
@appease gcc
@
text
@d6 1
a6 2
 * OpenBSD project (for instance by leaving this copyright notice
 * intact).
d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.21 2001/03/06 01:06:03 millert Exp $");
@


1.22.4.1
log
@Pull in OpenSSH-2.9.9
@
text
@d6 2
a7 1
 * OpenBSD project by leaving this copyright notice intact.
d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.29 2001/08/30 22:22:32 markus Exp $");
a17 1
#include <setjmp.h>
a21 5
#include "kex.h"
#include "compat.h"
#include "myproposal.h"
#include "packet.h"
#include "dispatch.h"
a25 1
#include "misc.h"
d27 1
a27 13
/* Flag indicating whether IPv4 or IPv6.  This can be set on the command line.
   Default value is AF_UNSPEC means both IPv4 and IPv6. */
#ifdef IPV4_DEFAULT
int IPv4or6 = AF_INET;
#else
int IPv4or6 = AF_UNSPEC;
#endif

int ssh_port = SSH_DEFAULT_PORT;

#define KT_RSA1	1
#define KT_DSA	2
#define KT_RSA	4
d29 1
a29 1
int get_keytypes = KT_RSA1;	/* Get only RSA1 keys by default */
a42 3
int nonfatal_fatal = 0;
jmp_buf kexjmp;
Key *kexjmp_key;
a57 1
	int c_keytype;		/* Only one of KT_RSA1, KT_DSA, or KT_RSA */
a62 1
	Kex *c_kex;		/* The key-exchange struct for ssh2 */
d86 1
a86 1
static Linebuf *
d120 1
a120 1
static void
d128 1
a128 2
#if 0
static void
d136 1
a136 1
static int
a140 1
#endif
d142 1
a142 1
static char *
d179 1
a179 1
static int
d192 1
a192 1
static int
d211 1
a211 1
static char *
d233 1
a233 1
static char *
d244 2
a245 2
static Key *
keygrab_ssh1(con *c)
d254 2
a255 2
	buffer_append(&msg, c->c_data, c->c_plen);
	buffer_consume(&msg, 8 - (c->c_plen & 7));	/* padding */
d257 1
a257 1
		error("%s: invalid packet type", c->c_name);
d259 1
a259 1
		return NULL;
a271 1

d274 2
a275 60
	return (rsa);
}

static int
hostjump(Key *hostkey)
{
	kexjmp_key = hostkey;
	longjmp(kexjmp, 1);
}

static int
ssh2_capable(int remote_major, int remote_minor)
{
	switch (remote_major) {
	case 1:
		if (remote_minor == 99)
			return 1;
		break;
	case 2:
		return 1;
	default:
		break;
	}
	return 0;
}

static Key *
keygrab_ssh2(con *c)
{
	int j;

	packet_set_connection(c->c_fd, c->c_fd);
	enable_compat20();
	myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = c->c_keytype == KT_DSA?
	    "ssh-dss": "ssh-rsa";
	c->c_kex = kex_setup(myproposal);
	c->c_kex->verify_host_key = hostjump;

	if (!(j = setjmp(kexjmp))) {
		nonfatal_fatal = 1;
		dispatch_run(DISPATCH_BLOCK, &c->c_kex->done, c->c_kex);
		fprintf(stderr, "Impossible! dispatch_run() returned!\n");
		exit(1);
	}
	nonfatal_fatal = 0;
	xfree(c->c_kex);
	c->c_kex = NULL;
	packet_close();

	return j < 0? NULL : kexjmp_key;
}

static void
keyprint(con *c, Key *key)
{
	if (!key)
		return;

	fprintf(stdout, "%s ", c->c_output_name ? c->c_output_name : c->c_name);
	key_write(key, stdout);
d279 1
a279 1
static int
d286 1
a286 1
	snprintf(strport, sizeof strport, "%d", ssh_port);
d288 1
a288 1
	hints.ai_family = IPv4or6;
d312 2
a313 2
static int
conalloc(char *iname, char *oname, int keytype)
a341 1
	fdcon[s].c_keytype = keytype;
d350 1
a350 1
static void
a360 1
	fdcon[s].c_keytype = 0;
d366 1
a366 1
static void
d375 1
a375 1
static int
d380 1
d382 2
a383 1
	ret = conalloc(c->c_namelist, c->c_output_name, c->c_keytype);
d385 3
d391 1
a391 1
static void
d394 1
a394 1
	char buf[256], *cp;
d401 1
a401 3
	while (bufsiz-- && (n = read(s, cp, 1)) == 1 && *cp != '\n') {
		if (*cp == '\r')
			*cp = '\n';
a402 1
	}
d415 2
a416 19
	if (c->c_keytype != KT_RSA1) {
		int remote_major, remote_minor;
		char remote_version[sizeof buf];

		if (sscanf(buf, "SSH-%d.%d-%[^\n]\n",
		    &remote_major, &remote_minor, remote_version) == 3)
			compat_datafellows(remote_version);
		else
			datafellows = 0;
		if (!ssh2_capable(remote_major, remote_minor)) {
			debug("%s doesn't support ssh2", c->c_name);
			confree(s);
			return;
		}
	}
	fprintf(stderr, "# %s %s\n", c->c_name, chop(buf));
	n = snprintf(buf, sizeof buf, "SSH-%d.%d-OpenSSH-keyscan\r\n",
	    c->c_keytype == KT_RSA1? PROTOCOL_MAJOR_1 : PROTOCOL_MAJOR_2,
	    c->c_keytype == KT_RSA1? PROTOCOL_MINOR_1 : PROTOCOL_MINOR_2);
a421 5
	if (c->c_keytype != KT_RSA1) {
		keyprint(c, keygrab_ssh2(c));
		confree(s);
		return;
	}
d426 1
a426 1
static void
d454 1
a454 1
			keyprint(c, keygrab_ssh1(c));
d466 1
a466 1
static void
d518 2
a519 2
static void
do_host(char *host)
d521 1
a521 2
	char *name = strnnsep(&host, " \t\n");
	int j;
d523 34
a556 5
	for (j = KT_RSA1; j <= KT_RSA; j *= 2) {
		if (get_keytypes & j) {
			while (ncon >= MAXCON)
				conloop();
			conalloc(name, *host ? host : name, j);
d561 1
a561 8
static void
fatal_callback(void *arg)
{
	if (nonfatal_fatal)
		longjmp(kexjmp, -1);
}

static void
d564 2
a565 11
	fprintf(stderr, "Usage: %s [options] host ...\n",
	    __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -f file     Read hosts or addresses from file.\n");
	fprintf(stderr, "  -p port     Connect to the specified port.\n");
	fprintf(stderr, "  -t keytype  Specify the host key type.\n");
	fprintf(stderr, "  -T timeout  Set connection timeout.\n");
        fprintf(stderr, "  -v          Verbose; display verbose debugging messages.\n");
        fprintf(stderr, "  -4          Use IPv4 only.\n");
        fprintf(stderr, "  -6          Use IPv6 only.\n");
	exit(1);
d571 1
a571 6
	int debug_flag = 0, log_level = SYSLOG_LEVEL_INFO;
	int opt, fopt_count = 0;
	char *tname;

	extern int optind;
	extern char *optarg;
d575 1
a575 1
	if (argc <= 1)
d578 6
a583 12
	while ((opt = getopt(argc, argv, "v46p:T:t:f:")) != -1) {
		switch (opt) {
		case 'p':
			ssh_port = a2port(optarg);
			if (ssh_port == 0) {
				fprintf(stderr, "Bad port '%s'\n", optarg);
				exit(1);
			}
			break;
		case 'T':
			timeout = atoi(optarg);
			if (timeout <= 0)
d585 3
a587 45
			break;
		case 'v':
			if (!debug_flag) {
				debug_flag = 1;
				log_level = SYSLOG_LEVEL_DEBUG1;
			}
			else if (log_level < SYSLOG_LEVEL_DEBUG3)
				log_level++;
			else
				fatal("Too high debugging level.");
			break;
		case 'f':
			if (strcmp(optarg, "-") == 0)
				optarg = NULL;
			argv[fopt_count++] = optarg;
			break;
		case 't':
			get_keytypes = 0;
			tname = strtok(optarg, ",");
			while (tname) {
				int type = key_type_from_name(tname);
				switch (type) {
				case KEY_RSA1:
					get_keytypes |= KT_RSA1;
					break;
				case KEY_DSA:
					get_keytypes |= KT_DSA;
					break;
				case KEY_RSA:
					get_keytypes |= KT_RSA;
					break;
				case KEY_UNSPEC:
					fatal("unknown key type %s\n", tname);
				}
				tname = strtok(NULL, ",");
			}
			break;
		case '4':
			IPv4or6 = AF_INET;
			break;
		case '6':
			IPv4or6 = AF_INET6;
			break;
		case '?':
		default:
a588 1
		}
d590 1
a590 1
	if (optind == argc && !fopt_count)
a592 3
	log_init("ssh-keyscan", log_level, SYSLOG_FACILITY_USER, 1);
	fatal_add_cleanup(fatal_callback, NULL);

d609 9
a617 12
	if (fopt_count) {
		Linebuf *lb;
		char *line;
		int j;

		for (j = 0; j < fopt_count; j++) {
			lb = Linebuf_alloc(argv[j], error);
			if (!lb)
				continue;
			while ((line = Linebuf_getline(lb)) != NULL)
				do_host(line);
			Linebuf_free(lb);
d619 2
a620 5
	}

	while (optind < argc)
		do_host(argv[optind++]);

@


1.22.4.2
log
@Merge OpenSSH 3.0
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.22.4.1 2001/09/27 19:03:55 jason Exp $");
d35 3
d39 1
@


1.22.4.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.35 2002/03/04 18:30:23 stevesk Exp $");
a471 1
	char remote_version[sizeof buf];
d473 1
a473 1
	int remote_major, remote_minor, n = 0;
a488 5
	if (n == 0) {
		error("%s: Connection closed by remote host", c->c_name);
		conrecycle(s);
		return;
	}
a494 5
	if (sscanf(buf, "SSH-%d.%d-%[^\n]\n",
	    &remote_major, &remote_minor, remote_version) == 3)
		compat_datafellows(remote_version);
	else
		datafellows = 0;
d496 8
a508 4
	} else if (remote_major != 1) {
		debug("%s doesn't support ssh1", c->c_name);
		confree(s);
		return;
a625 2
	if (name == NULL)
		return;
d635 2
a636 2
void
fatal(const char *fmt,...)
a637 4
	va_list args;
	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_FATAL, fmt, args);
	va_end(args);
a639 2
	else
		fatal_cleanup();
d652 3
a654 3
	fprintf(stderr, "  -v          Verbose; display verbose debugging messages.\n");
	fprintf(stderr, "  -4          Use IPv4 only.\n");
	fprintf(stderr, "  -6          Use IPv6 only.\n");
d718 1
a718 1
					fatal("unknown key type %s", tname);
d738 1
@


1.22.2.1
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.16 2001/02/12 22:56:10 deraadt Exp $");
d25 1
d37 1
a37 1
#define maxcon (maxfd - 10)
d40 2
a41 1
fd_set read_wait;
d86 1
a86 1
static inline Linebuf *
d120 1
a120 1
static inline void
d128 1
a128 1
static inline void
d136 1
a136 1
static inline int
d142 1
a142 1
static inline char *
d152 2
a153 1
				(*lb->errfun) ("%s: %s\n", lb->filename, strerror(errno));
d165 2
a166 1
				(*lb->errfun) ("%s: skipping incomplete last line\n", lb->filename);
d172 2
a173 1
				(*lb->errfun) ("linebuf (%s): realloc failed\n", lb->filename);
d179 1
a179 1
static int
d183 1
d192 1
a192 1
static int
d211 1
a211 1
inline char *
d345 1
a345 1
	FD_SET(s, &read_wait);
a352 1
	close(s);
d355 1
d362 1
a362 1
	FD_CLR(s, &read_wait);
d394 3
a396 2
	char buf[80];
	int n;
d399 4
a402 1
	n = read(s, buf, sizeof(buf));
d409 1
a409 1
	if (buf[n - 1] != '\n') {
d414 1
a414 1
	buf[n - 1] = '\0';
d417 1
a417 1
	if (write(s, buf, n) != n) {
d469 1
a469 1
	fd_set r, e;
d477 2
a478 3
	if (c &&
	    (c->c_tv.tv_sec > now.tv_sec ||
	     (c->c_tv.tv_sec == now.tv_sec && c->c_tv.tv_usec > now.tv_usec))) {
d489 6
a494 2
	r = e = read_wait;
	while (select(maxfd, &r, NULL, &e, &seltime) == -1 &&
d498 2
a499 2
	for (i = 0; i < maxfd; i++)
		if (FD_ISSET(i, &e)) {
d502 1
a502 1
		} else if (FD_ISSET(i, &r))
d504 3
d509 2
a510 3
	while (c &&
	       (c->c_tv.tv_sec < now.tv_sec ||
		(c->c_tv.tv_sec == now.tv_sec && c->c_tv.tv_usec < now.tv_usec))) {
d512 1
d535 1
d547 2
a548 1
				error("ignoring invalid/misplaced option `%s'", argv[argno++]);
d551 1
d561 1
a561 1
static void
d598 1
a598 1
	if (maxcon <= 0)
d605 4
d610 1
a610 1
		while (ncon < maxcon) {
@


1.22.2.2
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.22 2001/03/06 06:11:18 deraadt Exp $");
a24 1
#include "atomicio.h"
d36 1
a36 1
#define MAXCON (maxfd - 10)
d39 1
a39 2
fd_set *read_wait;
size_t read_wait_size;
d84 1
a84 1
Linebuf *
d118 1
a118 1
void
d126 1
a126 1
void
d134 1
a134 1
int
d140 1
a140 1
char *
d150 1
a150 2
				(*lb->errfun) ("%s: %s\n", lb->filename,
				    strerror(errno));
d162 1
a162 2
				(*lb->errfun) ("%s: skipping incomplete last line\n",
				    lb->filename);
d168 1
a168 2
				(*lb->errfun) ("linebuf (%s): realloc failed\n",
				    lb->filename);
d174 1
a174 1
int
a177 1

d186 1
a186 1
int
d205 1
a205 1
char *
d339 1
a339 1
	FD_SET(s, read_wait);
d347 1
a349 1
	close(s);
d356 1
a356 1
	FD_CLR(s, read_wait);
d388 2
a389 3
	char buf[80], *cp;
	size_t bufsiz;
	int n = 0;
d392 1
a392 4
	bufsiz = sizeof(buf);
	cp = buf;
	while (bufsiz-- && (n = read(s, cp, 1)) == 1 && *cp != '\n' && *cp != '\r')
		cp++;
d399 1
a399 1
	if (*cp != '\n' && *cp != '\r') {
d404 1
a404 1
	*cp = '\0';
d407 1
a407 1
	if (atomicio(write, s, buf, n) != n) {
d459 1
a459 1
	fd_set *r, *e;
d467 3
a469 2
	if (c && (c->c_tv.tv_sec > now.tv_sec ||
	    (c->c_tv.tv_sec == now.tv_sec && c->c_tv.tv_usec > now.tv_usec))) {
d480 2
a481 6
	r = xmalloc(read_wait_size);
	memcpy(r, read_wait, read_wait_size);
	e = xmalloc(read_wait_size);
	memcpy(e, read_wait, read_wait_size);

	while (select(maxfd, r, NULL, e, &seltime) == -1 &&
d485 2
a486 2
	for (i = 0; i < maxfd; i++) {
		if (FD_ISSET(i, e)) {
d489 1
a489 1
		} else if (FD_ISSET(i, r))
a490 3
	}
	xfree(r);
	xfree(e);
d493 3
a495 2
	while (c && (c->c_tv.tv_sec < now.tv_sec ||
	    (c->c_tv.tv_sec == now.tv_sec && c->c_tv.tv_usec < now.tv_usec))) {
a496 1

a518 1

d530 1
a530 2
				error("ignoring invalid/misplaced option `%s'",
				    argv[argno++]);
a532 1

d542 1
a542 1
void
d579 1
a579 1
	if (MAXCON <= 0)
a585 4
	read_wait_size = howmany(maxfd, NFDBITS) * sizeof(fd_mask);
	read_wait = xmalloc(read_wait_size);
	memset(read_wait, 0, read_wait_size);

d587 1
a587 1
		while (ncon < MAXCON) {
@


1.21
log
@Don't assume we wil get the version string all in one read().
deraadt@@ OK'd
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.20 2001/03/05 15:37:27 deraadt Exp $");
d396 1
a396 1
	int n;
@


1.20
log
@skip inlining, why bother
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.19 2001/03/03 21:19:41 millert Exp $");
d394 2
a395 1
	char buf[80];
d399 4
a402 1
	n = read(s, buf, sizeof(buf));
d409 1
a409 1
	if (buf[n - 1] != '\n') {
d414 1
a414 1
	buf[n - 1] = '\0';
@


1.19
log
@Dynamically allocate read_wait and its copies.  Since maxfd is
baed on resource limits it is often (usually?) larger than FD_SETSIZE.
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.18 2001/03/03 06:53:12 deraadt Exp $");
d86 1
a86 1
static __inline__ Linebuf *
d120 1
a120 1
static __inline__ void
d128 1
a128 1
static __inline__ void
d136 1
a136 1
static __inline__ int
d142 1
a142 1
static __inline__ char *
d179 1
a179 1
static int
d192 1
a192 1
static int
d211 1
a211 1
static __inline__ char *
d557 1
a557 1
static void
@


1.18
log
@standard theo sweep
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.17 2001/02/21 07:37:04 deraadt Exp $");
d40 2
a41 1
fd_set read_wait;
d345 1
a345 1
	FD_SET(s, &read_wait);
d362 1
a362 1
	FD_CLR(s, &read_wait);
d465 1
a465 1
	fd_set r, e;
d485 6
a490 2
	r = e = read_wait;
	while (select(maxfd, &r, NULL, &e, &seltime) == -1 &&
d495 1
a495 1
		if (FD_ISSET(i, &e)) {
d498 1
a498 1
		} else if (FD_ISSET(i, &r))
d501 2
d600 4
@


1.17
log
@inline -> __inline__, and some indent
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.16 2001/02/12 22:56:10 deraadt Exp $");
d25 1
d37 1
a37 1
#define maxcon (maxfd - 10)
a351 1
	close(s);
d354 1
d412 1
a412 1
	if (write(s, buf, n) != n) {
d472 2
a473 3
	if (c &&
	    (c->c_tv.tv_sec > now.tv_sec ||
	     (c->c_tv.tv_sec == now.tv_sec && c->c_tv.tv_usec > now.tv_usec))) {
d489 1
a489 1
	for (i = 0; i < maxfd; i++)
d495 1
d498 2
a499 3
	while (c &&
	       (c->c_tv.tv_sec < now.tv_sec ||
		(c->c_tv.tv_sec == now.tv_sec && c->c_tv.tv_usec < now.tv_usec))) {
d501 1
d524 1
d536 2
a537 1
				error("ignoring invalid/misplaced option `%s'", argv[argno++]);
d540 1
d587 1
a587 1
	if (maxcon <= 0)
d595 1
a595 1
		while (ncon < maxcon) {
@


1.16
log
@deal with EAGAIN/EINTR selects which were skipped
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.15 2001/02/09 09:04:59 itojun Exp $");
d84 1
a84 1
static inline Linebuf *
d118 1
a118 1
static inline void
d126 1
a126 1
static inline void
d134 1
a134 1
static inline int
d140 1
a140 1
static inline char *
d150 2
a151 1
				(*lb->errfun) ("%s: %s\n", lb->filename, strerror(errno));
d163 2
a164 1
				(*lb->errfun) ("%s: skipping incomplete last line\n", lb->filename);
d170 2
a171 1
				(*lb->errfun) ("linebuf (%s): realloc failed\n", lb->filename);
d181 1
d209 1
a209 1
inline char *
@


1.16.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.16 2001/02/12 22:56:10 deraadt Exp $");
@


1.16.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.16.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.22 2001/03/06 06:11:18 deraadt Exp $");
a24 1
#include "atomicio.h"
d36 1
a36 1
#define MAXCON (maxfd - 10)
d39 1
a39 2
fd_set *read_wait;
size_t read_wait_size;
d84 1
a84 1
Linebuf *
d118 1
a118 1
void
d126 1
a126 1
void
d134 1
a134 1
int
d140 1
a140 1
char *
d150 1
a150 2
				(*lb->errfun) ("%s: %s\n", lb->filename,
				    strerror(errno));
d162 1
a162 2
				(*lb->errfun) ("%s: skipping incomplete last line\n",
				    lb->filename);
d168 1
a168 2
				(*lb->errfun) ("linebuf (%s): realloc failed\n",
				    lb->filename);
d174 1
a174 1
int
a177 1

d186 1
a186 1
int
d205 1
a205 1
char *
d339 1
a339 1
	FD_SET(s, read_wait);
d347 1
a349 1
	close(s);
d356 1
a356 1
	FD_CLR(s, read_wait);
d388 2
a389 3
	char buf[80], *cp;
	size_t bufsiz;
	int n = 0;
d392 1
a392 4
	bufsiz = sizeof(buf);
	cp = buf;
	while (bufsiz-- && (n = read(s, cp, 1)) == 1 && *cp != '\n' && *cp != '\r')
		cp++;
d399 1
a399 1
	if (*cp != '\n' && *cp != '\r') {
d404 1
a404 1
	*cp = '\0';
d407 1
a407 1
	if (atomicio(write, s, buf, n) != n) {
d459 1
a459 1
	fd_set *r, *e;
d467 3
a469 2
	if (c && (c->c_tv.tv_sec > now.tv_sec ||
	    (c->c_tv.tv_sec == now.tv_sec && c->c_tv.tv_usec > now.tv_usec))) {
d480 2
a481 6
	r = xmalloc(read_wait_size);
	memcpy(r, read_wait, read_wait_size);
	e = xmalloc(read_wait_size);
	memcpy(e, read_wait, read_wait_size);

	while (select(maxfd, r, NULL, e, &seltime) == -1 &&
d485 2
a486 2
	for (i = 0; i < maxfd; i++) {
		if (FD_ISSET(i, e)) {
d489 1
a489 1
		} else if (FD_ISSET(i, r))
a490 3
	}
	xfree(r);
	xfree(e);
d493 3
a495 2
	while (c && (c->c_tv.tv_sec < now.tv_sec ||
	    (c->c_tv.tv_sec == now.tv_sec && c->c_tv.tv_usec < now.tv_usec))) {
a496 1

a518 1

d530 1
a530 2
				error("ignoring invalid/misplaced option `%s'",
				    argv[argno++]);
a532 1

d542 1
a542 1
void
d579 1
a579 1
	if (MAXCON <= 0)
a585 4
	read_wait_size = howmany(maxfd, NFDBITS) * sizeof(fd_mask);
	read_wait = xmalloc(read_wait_size);
	memset(read_wait, 0, read_wait_size);

d587 1
a587 1
		while (ncon < MAXCON) {
@


1.16.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.16.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d6 2
a7 1
 * OpenBSD project by leaving this copyright notice intact.
d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.29 2001/08/30 22:22:32 markus Exp $");
a17 1
#include <setjmp.h>
a21 5
#include "kex.h"
#include "compat.h"
#include "myproposal.h"
#include "packet.h"
#include "dispatch.h"
a25 1
#include "misc.h"
d27 1
a27 13
/* Flag indicating whether IPv4 or IPv6.  This can be set on the command line.
   Default value is AF_UNSPEC means both IPv4 and IPv6. */
#ifdef IPV4_DEFAULT
int IPv4or6 = AF_INET;
#else
int IPv4or6 = AF_UNSPEC;
#endif

int ssh_port = SSH_DEFAULT_PORT;

#define KT_RSA1	1
#define KT_DSA	2
#define KT_RSA	4
d29 1
a29 1
int get_keytypes = KT_RSA1;	/* Get only RSA1 keys by default */
a42 3
int nonfatal_fatal = 0;
jmp_buf kexjmp;
Key *kexjmp_key;
a57 1
	int c_keytype;		/* Only one of KT_RSA1, KT_DSA, or KT_RSA */
a62 1
	Kex *c_kex;		/* The key-exchange struct for ssh2 */
d86 1
a86 1
static Linebuf *
d120 1
a120 1
static void
d128 1
a128 2
#if 0
static void
d136 1
a136 1
static int
a140 1
#endif
d142 1
a142 1
static char *
d179 1
a179 1
static int
d192 1
a192 1
static int
d211 1
a211 1
static char *
d233 1
a233 1
static char *
d244 2
a245 2
static Key *
keygrab_ssh1(con *c)
d254 2
a255 2
	buffer_append(&msg, c->c_data, c->c_plen);
	buffer_consume(&msg, 8 - (c->c_plen & 7));	/* padding */
d257 1
a257 1
		error("%s: invalid packet type", c->c_name);
d259 1
a259 1
		return NULL;
a271 1

d274 2
a275 60
	return (rsa);
}

static int
hostjump(Key *hostkey)
{
	kexjmp_key = hostkey;
	longjmp(kexjmp, 1);
}

static int
ssh2_capable(int remote_major, int remote_minor)
{
	switch (remote_major) {
	case 1:
		if (remote_minor == 99)
			return 1;
		break;
	case 2:
		return 1;
	default:
		break;
	}
	return 0;
}

static Key *
keygrab_ssh2(con *c)
{
	int j;

	packet_set_connection(c->c_fd, c->c_fd);
	enable_compat20();
	myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = c->c_keytype == KT_DSA?
	    "ssh-dss": "ssh-rsa";
	c->c_kex = kex_setup(myproposal);
	c->c_kex->verify_host_key = hostjump;

	if (!(j = setjmp(kexjmp))) {
		nonfatal_fatal = 1;
		dispatch_run(DISPATCH_BLOCK, &c->c_kex->done, c->c_kex);
		fprintf(stderr, "Impossible! dispatch_run() returned!\n");
		exit(1);
	}
	nonfatal_fatal = 0;
	xfree(c->c_kex);
	c->c_kex = NULL;
	packet_close();

	return j < 0? NULL : kexjmp_key;
}

static void
keyprint(con *c, Key *key)
{
	if (!key)
		return;

	fprintf(stdout, "%s ", c->c_output_name ? c->c_output_name : c->c_name);
	key_write(key, stdout);
d279 1
a279 1
static int
d286 1
a286 1
	snprintf(strport, sizeof strport, "%d", ssh_port);
d288 1
a288 1
	hints.ai_family = IPv4or6;
d312 2
a313 2
static int
conalloc(char *iname, char *oname, int keytype)
a341 1
	fdcon[s].c_keytype = keytype;
d350 1
a350 1
static void
a360 1
	fdcon[s].c_keytype = 0;
d366 1
a366 1
static void
d375 1
a375 1
static int
d380 1
d382 2
a383 1
	ret = conalloc(c->c_namelist, c->c_output_name, c->c_keytype);
d385 3
d391 1
a391 1
static void
d394 1
a394 1
	char buf[256], *cp;
d401 1
a401 3
	while (bufsiz-- && (n = read(s, cp, 1)) == 1 && *cp != '\n') {
		if (*cp == '\r')
			*cp = '\n';
a402 1
	}
d415 2
a416 19
	if (c->c_keytype != KT_RSA1) {
		int remote_major, remote_minor;
		char remote_version[sizeof buf];

		if (sscanf(buf, "SSH-%d.%d-%[^\n]\n",
		    &remote_major, &remote_minor, remote_version) == 3)
			compat_datafellows(remote_version);
		else
			datafellows = 0;
		if (!ssh2_capable(remote_major, remote_minor)) {
			debug("%s doesn't support ssh2", c->c_name);
			confree(s);
			return;
		}
	}
	fprintf(stderr, "# %s %s\n", c->c_name, chop(buf));
	n = snprintf(buf, sizeof buf, "SSH-%d.%d-OpenSSH-keyscan\r\n",
	    c->c_keytype == KT_RSA1? PROTOCOL_MAJOR_1 : PROTOCOL_MAJOR_2,
	    c->c_keytype == KT_RSA1? PROTOCOL_MINOR_1 : PROTOCOL_MINOR_2);
a421 5
	if (c->c_keytype != KT_RSA1) {
		keyprint(c, keygrab_ssh2(c));
		confree(s);
		return;
	}
d426 1
a426 1
static void
d454 1
a454 1
			keyprint(c, keygrab_ssh1(c));
d466 1
a466 1
static void
d518 2
a519 2
static void
do_host(char *host)
d521 1
a521 2
	char *name = strnnsep(&host, " \t\n");
	int j;
d523 34
a556 5
	for (j = KT_RSA1; j <= KT_RSA; j *= 2) {
		if (get_keytypes & j) {
			while (ncon >= MAXCON)
				conloop();
			conalloc(name, *host ? host : name, j);
d561 1
a561 8
static void
fatal_callback(void *arg)
{
	if (nonfatal_fatal)
		longjmp(kexjmp, -1);
}

static void
d564 2
a565 11
	fprintf(stderr, "Usage: %s [options] host ...\n",
	    __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -f file     Read hosts or addresses from file.\n");
	fprintf(stderr, "  -p port     Connect to the specified port.\n");
	fprintf(stderr, "  -t keytype  Specify the host key type.\n");
	fprintf(stderr, "  -T timeout  Set connection timeout.\n");
        fprintf(stderr, "  -v          Verbose; display verbose debugging messages.\n");
        fprintf(stderr, "  -4          Use IPv4 only.\n");
        fprintf(stderr, "  -6          Use IPv6 only.\n");
	exit(1);
d571 1
a571 6
	int debug_flag = 0, log_level = SYSLOG_LEVEL_INFO;
	int opt, fopt_count = 0;
	char *tname;

	extern int optind;
	extern char *optarg;
d575 1
a575 1
	if (argc <= 1)
d578 6
a583 12
	while ((opt = getopt(argc, argv, "v46p:T:t:f:")) != -1) {
		switch (opt) {
		case 'p':
			ssh_port = a2port(optarg);
			if (ssh_port == 0) {
				fprintf(stderr, "Bad port '%s'\n", optarg);
				exit(1);
			}
			break;
		case 'T':
			timeout = atoi(optarg);
			if (timeout <= 0)
d585 3
a587 45
			break;
		case 'v':
			if (!debug_flag) {
				debug_flag = 1;
				log_level = SYSLOG_LEVEL_DEBUG1;
			}
			else if (log_level < SYSLOG_LEVEL_DEBUG3)
				log_level++;
			else
				fatal("Too high debugging level.");
			break;
		case 'f':
			if (strcmp(optarg, "-") == 0)
				optarg = NULL;
			argv[fopt_count++] = optarg;
			break;
		case 't':
			get_keytypes = 0;
			tname = strtok(optarg, ",");
			while (tname) {
				int type = key_type_from_name(tname);
				switch (type) {
				case KEY_RSA1:
					get_keytypes |= KT_RSA1;
					break;
				case KEY_DSA:
					get_keytypes |= KT_DSA;
					break;
				case KEY_RSA:
					get_keytypes |= KT_RSA;
					break;
				case KEY_UNSPEC:
					fatal("unknown key type %s\n", tname);
				}
				tname = strtok(NULL, ",");
			}
			break;
		case '4':
			IPv4or6 = AF_INET;
			break;
		case '6':
			IPv4or6 = AF_INET6;
			break;
		case '?':
		default:
a588 1
		}
d590 1
a590 1
	if (optind == argc && !fopt_count)
a592 3
	log_init("ssh-keyscan", log_level, SYSLOG_FACILITY_USER, 1);
	fatal_add_cleanup(fatal_callback, NULL);

d609 9
a617 12
	if (fopt_count) {
		Linebuf *lb;
		char *line;
		int j;

		for (j = 0; j < fopt_count; j++) {
			lb = Linebuf_alloc(argv[j], error);
			if (!lb)
				continue;
			while ((line = Linebuf_getline(lb)) != NULL)
				do_host(line);
			Linebuf_free(lb);
d619 2
a620 5
	}

	while (optind < argc)
		do_host(argv[optind++]);

@


1.16.2.6
log
@Merge OpenSSH 3.0
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.16.2.5 2001/09/27 00:15:42 miod Exp $");
d35 3
d39 1
@


1.16.2.7
log
@Merge OpenSSH 3.1.
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.35 2002/03/04 18:30:23 stevesk Exp $");
a471 1
	char remote_version[sizeof buf];
d473 1
a473 1
	int remote_major, remote_minor, n = 0;
a488 5
	if (n == 0) {
		error("%s: Connection closed by remote host", c->c_name);
		conrecycle(s);
		return;
	}
a494 5
	if (sscanf(buf, "SSH-%d.%d-%[^\n]\n",
	    &remote_major, &remote_minor, remote_version) == 3)
		compat_datafellows(remote_version);
	else
		datafellows = 0;
d496 8
a508 4
	} else if (remote_major != 1) {
		debug("%s doesn't support ssh1", c->c_name);
		confree(s);
		return;
a625 2
	if (name == NULL)
		return;
d635 2
a636 2
void
fatal(const char *fmt,...)
a637 4
	va_list args;
	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_FATAL, fmt, args);
	va_end(args);
a639 2
	else
		fatal_cleanup();
d652 3
a654 3
	fprintf(stderr, "  -v          Verbose; display verbose debugging messages.\n");
	fprintf(stderr, "  -4          Use IPv4 only.\n");
	fprintf(stderr, "  -6          Use IPv6 only.\n");
d718 1
a718 1
					fatal("unknown key type %s", tname);
d738 1
@


1.15
log
@do not assume malloc() returns zero-filled region.  found by malloc.conf=AJ.
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.14 2001/02/07 22:43:16 markus Exp $");
d481 4
a484 1
	select(maxfd, &r, NULL, &e, &seltime);
@


1.14
log
@s/getline/Linebuf_getline/; from roumen.petrov@@skalasoft.com
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.13 2001/02/07 18:04:50 itojun Exp $");
d581 1
@


1.13
log
@fix size_t -> int cast (use u_long).  markus ok
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.12 2001/02/04 15:32:26 stevesk Exp $");
d141 1
a141 1
getline(Linebuf * lb)
d530 1
a530 1
			line = getline(lb);
@


1.12
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.11 2001/01/21 19:05:57 markus Exp $");
d473 1
a473 1
		if ((int) seltime.tv_usec < 0) {
@


1.11
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.10 2001/01/19 15:55:11 markus Exp $");
d492 1
a492 1
	        (c->c_tv.tv_sec == now.tv_sec && c->c_tv.tv_usec < now.tv_usec))) {
@


1.10
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.9 2001/01/13 18:12:47 markus Exp $");
a16 2
#include <openssl/rsa.h>
#include <openssl/dsa.h>
d24 1
@


1.9
log
@free() -> xfree(); fix memory leak; from stevesk@@pobox.com
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.8 2001/01/13 18:06:54 markus Exp $");
d22 1
@


1.8
log
@use SSH_DEFAULT_PORT; from stevesk@@pobox.com
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.7 2001/01/08 22:03:23 markus Exp $");
d97 1
a97 1
			free(lb);
d110 1
a110 1
		free(lb);
d122 2
a123 2
	free(lb->buf);
	free(lb);
d317 1
a317 1
			free(namebase);
d350 2
a351 2
	free(fdcon[s].c_namebase);
	free(fdcon[s].c_output_name);
d353 1
a353 1
		free(fdcon[s].c_data);
d377 1
a377 2
	oname = c->c_output_name;
	c->c_output_name = NULL;/* prevent it from being freed */
d380 2
a381 1
	free(iname);
@


1.7
log
@O_NDELAY -> O_NONBLOCK; thanks stevesk@@pobox.com
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.6 2000/12/19 23:17:58 markus Exp $");
a29 1
#define PORT 22
d280 1
a280 1
	snprintf(strport, sizeof strport, "%d", PORT);
@


1.6
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.5 2000/12/19 22:48:08 markus Exp $");
d293 1
a293 1
		if (fcntl(s, F_SETFL, O_NDELAY) < 0)
@


1.5
log
@replace <ssl/x.h> with <openssl/x.h>
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.4 2000/12/13 23:26:53 markus Exp $");
d48 1
a48 1
	unsigned char c_status;	/* State of connection on this file desc. */
d78 1
a78 1
	unsigned int size;
@


1.4
log
@fatal already adds \n; from stevesk@@pobox.com
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.3 2000/12/12 22:30:01 markus Exp $");
d16 3
a18 3
#include <ssl/bn.h>
#include <ssl/rsa.h>
#include <ssl/dsa.h>
@


1.3
log
@consistently use __progname; from stevesk@@pobox.com
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.2 2000/12/06 19:57:48 markus Exp $");
d324 1
a324 1
		fatal("conalloc: fdno %d too high\n", s);
d326 1
a326 1
		fatal("conalloc: attempt to reuse fdno %d\n", s);
d350 1
a350 1
		fatal("confree: attempt to free bad fdno %d\n", s);
d450 1
a450 1
			fatal("conread: invalid status %d\n", c->c_status);
d543 1
a543 1
	fatal("usage: %s [-t timeout] { [--] host | -f file } ...\n", __progname);
d574 1
a574 1
		fatal("%s: fdlim_get: bad value\n", __progname);
d578 1
a578 1
		fatal("%s: not enough file descriptors\n", __progname);
@


1.2
log
@err(3) -> internal error(), from stevesk@@sweden.hp.com
@
text
@d11 1
a11 1
RCSID("$OpenBSD: ssh-keyscan.c,v 1.1 2000/12/04 19:24:02 markus Exp $");
d39 1
a39 1
char *prog;
d543 1
a543 1
	fatal("usage: %s [-t timeout] { [--] host | -f file } ...\n", prog);
a553 5
	if ((prog = strrchr(argv[0], '/')))
		prog++;
	else
		prog = argv[0];

d574 1
a574 1
		fatal("%s: fdlim_get: bad value\n", prog);
d578 1
a578 1
		fatal("%s: not enough file descriptors\n", prog);
@


1.1
log
@David Maziere's ssh-keyscan, ok niels@@
@
text
@d11 1
a11 1
RCSID("$OpenBSD:$");
a13 1
#include <err.h>
d526 1
a526 1
				lb = Linebuf_alloc(fname, warn);
@

