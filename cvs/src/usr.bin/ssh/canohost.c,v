head	1.73;
access;
symbols
	OPENBSD_6_1:1.73.0.2
	OPENBSD_6_1_BASE:1.73
	OPENBSD_6_0:1.73.0.4
	OPENBSD_6_0_BASE:1.73
	OPENBSD_5_9:1.72.0.6
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.72.0.4
	OPENBSD_5_8_BASE:1.72
	OPENBSD_5_7:1.72.0.2
	OPENBSD_5_7_BASE:1.72
	OPENBSD_5_6:1.71.0.4
	OPENBSD_5_6_BASE:1.71
	OPENBSD_5_5:1.70.0.4
	OPENBSD_5_5_BASE:1.70
	OPENBSD_5_4:1.67.0.2
	OPENBSD_5_4_BASE:1.67
	OPENBSD_5_3:1.66.0.14
	OPENBSD_5_3_BASE:1.66
	OPENBSD_5_2:1.66.0.12
	OPENBSD_5_2_BASE:1.66
	OPENBSD_5_1_BASE:1.66
	OPENBSD_5_1:1.66.0.10
	OPENBSD_5_0:1.66.0.8
	OPENBSD_5_0_BASE:1.66
	OPENBSD_4_9:1.66.0.6
	OPENBSD_4_9_BASE:1.66
	OPENBSD_4_8:1.66.0.4
	OPENBSD_4_8_BASE:1.66
	OPENBSD_4_7:1.66.0.2
	OPENBSD_4_7_BASE:1.66
	OPENBSD_4_6:1.65.0.4
	OPENBSD_4_6_BASE:1.65
	OPENBSD_4_5:1.64.0.2
	OPENBSD_4_5_BASE:1.64
	OPENBSD_4_4:1.63.0.2
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.62.0.2
	OPENBSD_4_3_BASE:1.62
	OPENBSD_4_2:1.61.0.6
	OPENBSD_4_2_BASE:1.61
	OPENBSD_4_1:1.61.0.2
	OPENBSD_4_1_BASE:1.61
	OPENBSD_4_0:1.61.0.4
	OPENBSD_4_0_BASE:1.61
	OPENBSD_3_9:1.49.0.2
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.44.0.2
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.42.0.2
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.41.0.2
	OPENBSD_3_6_BASE:1.41
	OPENBSD_3_5:1.38.0.2
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.37.0.2
	OPENBSD_3_4_BASE:1.37
	OPENBSD_3_3:1.35.0.2
	OPENBSD_3_3_BASE:1.35
	OPENBSD_3_2:1.34.0.2
	OPENBSD_3_2_BASE:1.34
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	OPENBSD_3_0:1.27.0.2
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9_BASE:1.26
	OPENBSD_2_9:1.26.0.2
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.73
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.72;
commitid	kr9hjdmg99uVnhW2;

1.72
date	2015.03.01.15.44.40;	author millert;	state Exp;
branches;
next	1.71;
commitid	ecE3mT5Zc9bqPVoW;

1.71
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.70;
commitid	z7plx8Gkj6l2sxem;

1.70
date	2014.01.19.04.17.29;	author dtucker;	state Exp;
branches;
next	1.69;

1.69
date	2013.11.20.20.54.10;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2013.10.14.23.28.22;	author djm;	state Exp;
branches;
next	1.67;

1.67
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.66;

1.66
date	2010.01.13.01.20.20;	author dtucker;	state Exp;
branches;
next	1.65;

1.65
date	2009.05.27.06.31.25;	author andreas;	state Exp;
branches;
next	1.64;

1.64
date	2009.02.12.03.00.56;	author djm;	state Exp;
branches;
next	1.63;

1.63
date	2008.06.12.00.03.49;	author dtucker;	state Exp;
branches;
next	1.62;

1.62
date	2007.12.27.14.22.08;	author dtucker;	state Exp;
branches;
next	1.61;

1.61
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.59;

1.59
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.58;

1.58
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.57;

1.57
date	2006.07.12.22.28.51;	author stevesk;	state Exp;
branches;
next	1.56;

1.56
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.55;

1.55
date	2006.07.08.21.47.12;	author stevesk;	state Exp;
branches;
next	1.54;

1.54
date	2006.07.05.02.42.09;	author stevesk;	state Exp;
branches;
next	1.53;

1.53
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.20.18.42.26;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.14.00.15.39;	author djm;	state Exp;
branches;
next	1.49;

1.49
date	2006.02.22.00.04.44;	author stevesk;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2005.12.28.22.46.06;	author stevesk;	state Exp;
branches;
next	1.47;

1.47
date	2005.11.03.13.38.29;	author dtucker;	state Exp;
branches;
next	1.46;

1.46
date	2005.10.30.08.29.29;	author dtucker;	state Exp;
branches;
next	1.45;

1.45
date	2005.10.03.07.44.42;	author dtucker;	state Exp;
branches;
next	1.44;

1.44
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2005.06.16.08.00.00;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2005.02.18.03.05.53;	author djm;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2004.07.21.11.51.29;	author djm;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.31.21.58.47;	author djm;	state Exp;
branches;
next	1.38;

1.38
date	2003.09.23.20.17.11;	author markus;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2003.06.02.09.17.34;	author markus;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.26.02.38.54;	author stevesk;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2002.09.23.20.46.27;	author stevesk;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2002.07.09.11.56.27;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.11.08.11.45;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.27.21.23.13;	author stevesk;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2002.01.29.14.32.03;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.05.03.56.39;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.23.15.12.17;	author itojun;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2001.04.18.14.15.00;	author markus;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2001.04.12.19.15.24;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2001.04.05.15.48.19;	author stevesk;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.10.01.33.32;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.08.22.37.10;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.08.19.30.51;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.03.10.08.37;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.29.19.42.33;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.21.19.05.45;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.19.23.17.55;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.21.17.04.22;	author markus;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2000.09.07.21.13.37;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.07.20.27.50;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.20.01.39.39;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.14.10.30.30;	author markus;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.01.04.13.41.32;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.04.00.07.58;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.12.09.00.00.52;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	99.11.24.19.53.44;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	99.11.24.00.26.01;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.11.23.22.25.53;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	99.11.15.00.42.01;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	99.11.14.22.30.58;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	99.09.30.05.53.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.21.14.16;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.34;	author deraadt;	state Exp;
branches;
next	;

1.12.2.1
date	2000.09.01.18.23.18;	author jason;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2000.11.08.21.30.31;	author jason;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2001.03.12.15.44.08;	author jason;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2001.03.21.18.52.37;	author jason;	state Exp;
branches;
next	;

1.16.2.1
date	2001.02.16.20.12.56;	author jason;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2001.02.19.17.18.43;	author jason;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2001.03.21.19.46.23;	author jason;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2001.05.07.21.09.27;	author jason;	state Exp;
branches;
next	1.16.2.5;

1.16.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.16.2.6;

1.16.2.6
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.26.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	;

1.27.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.27.2.3;

1.27.2.3
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.31.2.1
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2003.04.03.22.35.16;	author miod;	state Exp;
branches;
next	;

1.34.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2003.09.16.21.20.25;	author brad;	state Exp;
branches;
next	;

1.35.2.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.37.2.1
date	2004.02.28.03.51.32;	author brad;	state Exp;
branches;
next	1.37.2.2;

1.37.2.2
date	2004.08.19.22.37.30;	author brad;	state Exp;
branches;
next	;

1.38.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.41.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2005.09.02.03.44.59;	author brad;	state Exp;
branches;
next	;

1.42.2.1
date	2005.09.04.18.40.01;	author brad;	state Exp;
branches;
next	1.42.2.2;

1.42.2.2
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.44.2.1
date	2006.02.03.03.01.55;	author brad;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.49.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.73
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@/* $OpenBSD: canohost.c,v 1.72 2015/03/01 15:44:40 millert Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Functions for returning the canonical host name of the remote site.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <netinet/in.h>

#include <errno.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>

#include "xmalloc.h"
#include "packet.h"
#include "log.h"
#include "canohost.h"
#include "misc.h"

/*
 * Returns the local/remote IP-address/hostname of socket as a string.
 * The returned string must be freed.
 */
static char *
get_socket_address(int sock, int remote, int flags)
{
	struct sockaddr_storage addr;
	socklen_t addrlen;
	char ntop[NI_MAXHOST];
	int r;

	/* Get IP address of client. */
	addrlen = sizeof(addr);
	memset(&addr, 0, sizeof(addr));

	if (remote) {
		if (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)
			return NULL;
	} else {
		if (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)
			return NULL;
	}

	switch (addr.ss_family) {
	case AF_INET:
	case AF_INET6:
		/* Get the address in ascii. */
		if ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,
		    sizeof(ntop), NULL, 0, flags)) != 0) {
			error("%s: getnameinfo %d failed: %s", __func__,
			    flags, ssh_gai_strerror(r));
			return NULL;
		}
		return xstrdup(ntop);
	case AF_UNIX:
		/* Get the Unix domain socket path. */
		return xstrdup(((struct sockaddr_un *)&addr)->sun_path);
	default:
		/* We can't look up remote Unix domain sockets. */
		return NULL;
	}
}

char *
get_peer_ipaddr(int sock)
{
	char *p;

	if ((p = get_socket_address(sock, 1, NI_NUMERICHOST)) != NULL)
		return p;
	return xstrdup("UNKNOWN");
}

char *
get_local_ipaddr(int sock)
{
	char *p;

	if ((p = get_socket_address(sock, 0, NI_NUMERICHOST)) != NULL)
		return p;
	return xstrdup("UNKNOWN");
}

char *
get_local_name(int fd)
{
	char *host, myname[NI_MAXHOST];

	/* Assume we were passed a socket */
	if ((host = get_socket_address(fd, 0, NI_NAMEREQD)) != NULL)
		return host;

	/* Handle the case where we were passed a pipe */
	if (gethostname(myname, sizeof(myname)) == -1) {
		verbose("%s: gethostname: %s", __func__, strerror(errno));
		host = xstrdup("UNKNOWN");
	} else {
		host = xstrdup(myname);
	}

	return host;
}

/* Returns the local/remote port for the socket. */

static int
get_sock_port(int sock, int local)
{
	struct sockaddr_storage from;
	socklen_t fromlen;
	char strport[NI_MAXSERV];
	int r;

	/* Get IP address of client. */
	fromlen = sizeof(from);
	memset(&from, 0, sizeof(from));
	if (local) {
		if (getsockname(sock, (struct sockaddr *)&from, &fromlen) < 0) {
			error("getsockname failed: %.100s", strerror(errno));
			return 0;
		}
	} else {
		if (getpeername(sock, (struct sockaddr *)&from, &fromlen) < 0) {
			debug("getpeername failed: %.100s", strerror(errno));
			return -1;
		}
	}

	/* Non-inet sockets don't have a port number. */
	if (from.ss_family != AF_INET && from.ss_family != AF_INET6)
		return 0;

	/* Return port number. */
	if ((r = getnameinfo((struct sockaddr *)&from, fromlen, NULL, 0,
	    strport, sizeof(strport), NI_NUMERICSERV)) != 0)
		fatal("%s: getnameinfo NI_NUMERICSERV failed: %s", __func__,
		    ssh_gai_strerror(r));
	return atoi(strport);
}

int
get_peer_port(int sock)
{
	return get_sock_port(sock, 0);
}

int
get_local_port(int sock)
{
	return get_sock_port(sock, 1);
}
@


1.72
log
@Make sure we only call getnameinfo() for AF_INET or AF_INET6 sockets.
getpeername() of a Unix domain socket may return without error on
some systems without actually setting ss_family so getnameinfo()
was getting called with ss_family set to AF_UNSPEC.  OK djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.71 2014/07/15 15:54:14 millert Exp $ */
a34 166
static void check_ip_options(int, char *);
static char *canonical_host_ip = NULL;
static int cached_port = -1;

/*
 * Return the canonical name of the host at the other end of the socket. The
 * caller should free the returned string.
 */

static char *
get_remote_hostname(int sock, int use_dns)
{
	struct sockaddr_storage from;
	socklen_t fromlen;
	struct addrinfo hints, *ai, *aitop;
	char name[NI_MAXHOST], ntop[NI_MAXHOST], ntop2[NI_MAXHOST];

	/* Get IP address of client. */
	fromlen = sizeof(from);
	memset(&from, 0, sizeof(from));
	if (getpeername(sock, (struct sockaddr *)&from, &fromlen) < 0) {
		debug("getpeername failed: %.100s", strerror(errno));
		cleanup_exit(255);
	}

	if (getnameinfo((struct sockaddr *)&from, fromlen, ntop, sizeof(ntop),
	    NULL, 0, NI_NUMERICHOST) != 0)
		fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");

	if (from.ss_family == AF_INET)
		check_ip_options(sock, ntop);

	if (!use_dns)
		return xstrdup(ntop);

	debug3("Trying to reverse map address %.100s.", ntop);
	/* Map the IP address to a host name. */
	if (getnameinfo((struct sockaddr *)&from, fromlen, name, sizeof(name),
	    NULL, 0, NI_NAMEREQD) != 0) {
		/* Host name not found.  Use ip address. */
		return xstrdup(ntop);
	}

	/*
	 * if reverse lookup result looks like a numeric hostname,
	 * someone is trying to trick us by PTR record like following:
	 *	1.1.1.10.in-addr.arpa.	IN PTR	2.3.4.5
	 */
	memset(&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(name, NULL, &hints, &ai) == 0) {
		logit("Nasty PTR record \"%s\" is set up for %s, ignoring",
		    name, ntop);
		freeaddrinfo(ai);
		return xstrdup(ntop);
	}

	/* Names are stores in lowercase. */
	lowercase(name);

	/*
	 * Map it back to an IP address and check that the given
	 * address actually is an address of this host.  This is
	 * necessary because anyone with access to a name server can
	 * define arbitrary names for an IP address. Mapping from
	 * name to IP address can be trusted better (but can still be
	 * fooled if the intruder has access to the name server of
	 * the domain).
	 */
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = from.ss_family;
	hints.ai_socktype = SOCK_STREAM;
	if (getaddrinfo(name, NULL, &hints, &aitop) != 0) {
		logit("reverse mapping checking getaddrinfo for %.700s "
		    "[%s] failed - POSSIBLE BREAK-IN ATTEMPT!", name, ntop);
		return xstrdup(ntop);
	}
	/* Look for the address from the list of addresses. */
	for (ai = aitop; ai; ai = ai->ai_next) {
		if (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop2,
		    sizeof(ntop2), NULL, 0, NI_NUMERICHOST) == 0 &&
		    (strcmp(ntop, ntop2) == 0))
				break;
	}
	freeaddrinfo(aitop);
	/* If we reached the end of the list, the address was not there. */
	if (!ai) {
		/* Address not found for the host name. */
		logit("Address %.100s maps to %.600s, but this does not "
		    "map back to the address - POSSIBLE BREAK-IN ATTEMPT!",
		    ntop, name);
		return xstrdup(ntop);
	}
	return xstrdup(name);
}

/*
 * If IP options are supported, make sure there are none (log and
 * disconnect them if any are found).  Basically we are worried about
 * source routing; it can be used to pretend you are somebody
 * (ip-address) you are not. That itself may be "almost acceptable"
 * under certain circumstances, but rhosts autentication is useless
 * if source routing is accepted. Notice also that if we just dropped
 * source routing here, the other side could use IP spoofing to do
 * rest of the interaction and could still bypass security.  So we
 * exit here if we detect any IP options.
 */
/* IPv4 only */
static void
check_ip_options(int sock, char *ipaddr)
{
	u_char options[200];
	char text[sizeof(options) * 3 + 1];
	socklen_t option_size, i;
	int ipproto;
	struct protoent *ip;

	if ((ip = getprotobyname("ip")) != NULL)
		ipproto = ip->p_proto;
	else
		ipproto = IPPROTO_IP;
	option_size = sizeof(options);
	if (getsockopt(sock, ipproto, IP_OPTIONS, options,
	    &option_size) >= 0 && option_size != 0) {
		text[0] = '\0';
		for (i = 0; i < option_size; i++)
			snprintf(text + i*3, sizeof(text) - i*3,
			    " %2.2x", options[i]);
		fatal("Connection from %.100s with IP options:%.800s",
		    ipaddr, text);
	}
}

/*
 * Return the canonical name of the host in the other side of the current
 * connection.  The host name is cached, so it is efficient to call this
 * several times.
 */

const char *
get_canonical_hostname(int use_dns)
{
	char *host;
	static char *canonical_host_name = NULL;
	static char *remote_ip = NULL;

	/* Check if we have previously retrieved name with same option. */
	if (use_dns && canonical_host_name != NULL)
		return canonical_host_name;
	if (!use_dns && remote_ip != NULL)
		return remote_ip;

	/* Get the real hostname if socket; otherwise return UNKNOWN. */
	if (packet_connection_is_on_socket())
		host = get_remote_hostname(packet_get_connection_in(), use_dns);
	else
		host = "UNKNOWN";

	if (use_dns)
		canonical_host_name = host;
	else
		remote_ip = host;
	return host;
}

d52 1
a52 2
		if (getpeername(sock, (struct sockaddr *)&addr, &addrlen)
		    < 0)
d55 1
a55 2
		if (getsockname(sock, (struct sockaddr *)&addr, &addrlen)
		    < 0)
d65 1
a65 1
			error("get_socket_address: getnameinfo %d failed: %s",
d110 2
a111 1
		verbose("get_local_name: gethostname: %s", strerror(errno));
a118 42
void
clear_cached_addr(void)
{
	free(canonical_host_ip);
	canonical_host_ip = NULL;
	cached_port = -1;
}

/*
 * Returns the IP-address of the remote host as a string.  The returned
 * string must not be freed.
 */

const char *
get_remote_ipaddr(void)
{
	/* Check whether we have cached the ipaddr. */
	if (canonical_host_ip == NULL) {
		if (packet_connection_is_on_socket()) {
			canonical_host_ip =
			    get_peer_ipaddr(packet_get_connection_in());
			if (canonical_host_ip == NULL)
				cleanup_exit(255);
		} else {
			/* If not on socket, return UNKNOWN. */
			canonical_host_ip = xstrdup("UNKNOWN");
		}
	}
	return canonical_host_ip;
}

const char *
get_remote_name_or_ip(u_int utmp_len, int use_dns)
{
	static const char *remote = "";
	if (utmp_len > 0)
		remote = get_canonical_hostname(use_dns);
	if (utmp_len == 0 || strlen(remote) > utmp_len)
		remote = get_remote_ipaddr();
	return remote;
}

d121 1
a121 1
int
d151 1
a151 1
		fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed: %s",
a155 16
/* Returns remote/local port number for the current connection. */

static int
get_port(int local)
{
	/*
	 * If the connection is not a socket, return 65535.  This is
	 * intentionally chosen to be an unprivileged port number.
	 */
	if (!packet_connection_is_on_socket())
		return 65535;

	/* Get socket and return the port number. */
	return get_sock_port(packet_get_connection_in(), local);
}

d163 1
a163 11
get_remote_port(void)
{
	/* Cache to avoid getpeername() on a dead connection */
	if (cached_port == -1)
		cached_port = get_port(0);

	return cached_port;
}

int
get_local_port(void)
d165 1
a165 1
	return get_port(1);
@


1.71
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.70 2014/01/19 04:17:29 dtucker Exp $ */
d227 12
a238 1
	if (addr.ss_family == AF_UNIX) {
d241 2
a242 7
	}

	/* Get the address in ascii. */
	if ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,
	    sizeof(ntop), NULL, 0, flags)) != 0) {
		error("get_socket_address: getnameinfo %d failed: %s", flags,
		    ssh_gai_strerror(r));
a244 1
	return xstrdup(ntop);
d353 2
a354 2
	/* Unix domain sockets don't have a port number. */
	if (from.ss_family == AF_UNIX)
@


1.70
log
@Cast socklen_t when comparing to size_t and use socklen_t to iterate over
the ip options, both to prevent signed/unsigned comparison warnings.
Patch from vinschen at redhat via portable openssh, begrudging ok deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.69 2013/11/20 20:54:10 deraadt Exp $ */
d17 1
d226 6
d347 5
@


1.69
log
@unsigned casts for ctype macros where neccessary
ok guenther millert markus
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.68 2013/10/14 23:28:22 djm Exp $ */
d148 1
a148 2
	socklen_t option_size;
	u_int i;
@


1.68
log
@refactor client config code a little:

add multistate option partsing to readconf.c, similar to servconf.c's
existing code.

move checking of options that accept "none" as an argument to readconf.c

add a lowercase() function and use it instead of explicit tolower() in
loops

part of a larger diff that was ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.67 2013/05/17 00:13:13 djm Exp $ */
a19 1
#include <ctype.h>
@


1.67
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.66 2010/01/13 01:20:20 dtucker Exp $ */
a47 1
	int i;
d93 3
a95 7
	/*
	 * Convert it to all lowercase (which is expected by the rest
	 * of this software).
	 */
	for (i = 0; name[i]; i++)
		if (isupper(name[i]))
			name[i] = (char)tolower(name[i]);
@


1.66
log
@Make HostBased authentication work with a ProxyCommand.  bz #1569, patch
from imorgan at nas nasa gov, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.65 2009/05/27 06:31:25 andreas Exp $ */
d41 1
a41 1
 * caller should free the returned string with xfree.
d284 2
a285 4
	if (canonical_host_ip != NULL) {
		xfree(canonical_host_ip);
		canonical_host_ip = NULL;
	}
@


1.65
log
@Add clear_cached_addr(), needed for upcoming changes allowing the peer
address to change.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.64 2009/02/12 03:00:56 djm Exp $ */
d27 1
d263 1
a263 1
get_local_name(int sock)
d265 14
a278 1
	return get_socket_address(sock, 0, NI_NAMEREQD);
@


1.64
log
@support remote port forwarding with a zero listen port (-R0:...) to
dyamically allocate a listen port at runtime (this is actually
specified in rfc4254); bz#1003 ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.63 2008/06/12 00:03:49 dtucker Exp $ */
d35 2
d267 10
a284 2
	static char *canonical_host_ip = NULL;

a367 2
	static int port = -1;

d369 2
a370 2
	if (port == -1)
		port = get_port(0);
d372 1
a372 1
	return port;
@


1.63
log
@Do not pass "0" strings as ports to getaddrinfo because the lookups
can slow things down and we never use the service info anyway. bz
#859, patch from YOSHIFUJI Hideaki and John Devitofranceschi.  ok
deraadt@@ djm@@

djm belives that the reason for the "0" strings is to ensure that
it's not possible to call getaddrinfo with both host and port being
NULL.  In the case of canohost.c host is a local array.  In the
case of sshconnect.c, it's checked for null immediately before use.

In dns.c it ultimately comes from ssh.c:main() and is guaranteed to
be non-null but it's not obvious, so I added a warning message in
case it is ever passed a null.
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.62 2007/12/27 14:22:08 dtucker Exp $ */
d303 1
a303 1
static int
@


1.62
log
@Add a small helper function to consistently handle the EAI_SYSTEM error
code of getaddrinfo.  Prompted by vgiffin at apple com via bz #1417.
ok markus@@ stevesk@@
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.61 2006/08/03 03:34:41 deraadt Exp $ */
d84 1
a84 1
	if (getaddrinfo(name, "0", &hints, &ai) == 0) {
@


1.61
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.60 2006/08/01 23:22:47 stevesk Exp $ */
d32 1
d233 1
a233 1
		    r == EAI_SYSTEM ? strerror(errno) : gai_strerror(r));
d329 1
a329 1
		    r == EAI_SYSTEM ? strerror(errno) : gai_strerror(r));
@


1.60
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.59 2006/07/26 13:57:17 stevesk Exp $ */
a14 2
#include "includes.h"

d26 1
d28 1
a29 1
#include "xmalloc.h"
@


1.59
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.58 2006/07/22 20:48:22 stevesk Exp $ */
d25 1
@


1.58
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.57 2006/07/12 22:28:51 stevesk Exp $ */
d25 1
@


1.57
log
@move #include <netdb.h> out of includes.h; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.56 2006/07/11 20:07:25 stevesk Exp $ */
d25 1
@


1.56
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.55 2006/07/08 21:47:12 stevesk Exp $ */
d24 1
@


1.55
log
@move #include <sys/socket.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.54 2006/07/05 02:42:09 stevesk Exp $ */
d23 1
@


1.54
log
@move #include <netinet/in.h> out of includes.h; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: canohost.c,v 1.53 2006/03/25 13:17:01 djm Exp $ */
d17 1
@


1.53
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d16 4
@


1.52
log
@be strict with tolower() casting
@
text
@d1 1
@


1.51
log
@RCSID() can die
@
text
@d86 1
a86 1
			name[i] = tolower(name[i]);
@


1.50
log
@log the originating address and not just the name when a reverse
mapping check fails, requested by linux AT linuon.com
@
text
@a14 1
RCSID("$OpenBSD: canohost.c,v 1.49 2006/02/22 00:04:44 stevesk Exp $");
@


1.49
log
@move #include <ctype.h> out of includes.h; ok djm@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.48 2005/12/28 22:46:06 stevesk Exp $");
d102 1
a102 1
		    "failed - POSSIBLE BREAK-IN ATTEMPT!", name);
@


1.49.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: canohost.c,v 1.61 2006/08/03 03:34:41 deraadt Exp $ */
d14 2
a15 4
#include <sys/types.h>
#include <sys/socket.h>

#include <netinet/in.h>
a17 6
#include <errno.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
d19 1
a20 1
#include "packet.h"
d87 1
a87 1
			name[i] = (char)tolower(name[i]);
d102 1
a102 1
		    "[%s] failed - POSSIBLE BREAK-IN ATTEMPT!", name, ntop);
@


1.48
log
@use 'break-in' for consistency; ok deraadt@@ ok and input jmc@@
@
text
@d15 3
a17 1
RCSID("$OpenBSD: canohost.c,v 1.47 2005/11/03 13:38:29 dtucker Exp $");
@


1.47
log
@Cache reverse lookups with and without DNS separately; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.46 2005/10/30 08:29:29 dtucker Exp $");
d100 1
a100 1
		    "failed - POSSIBLE BREAKIN ATTEMPT!", name);
d115 1
a115 1
		    "map back to the address - POSSIBLE BREAKIN ATTEMPT!",
@


1.46
log
@Check for connections with IP options earlier and drop silently.  ok djm@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.45 2005/10/03 07:44:42 dtucker Exp $");
d169 1
d171 1
a171 1
	static int use_dns_done = 0;
d174 4
a177 6
	if (canonical_host_name != NULL) {
		if (use_dns_done != use_dns)
			xfree(canonical_host_name);
		else
			return canonical_host_name;
	}
d181 1
a181 2
		canonical_host_name = get_remote_hostname(
		    packet_get_connection_in(), use_dns);
d183 1
a183 1
		canonical_host_name = xstrdup("UNKNOWN");
d185 5
a189 2
	use_dns_done = use_dns;
	return canonical_host_name;
@


1.45
log
@Relocate check_ip_options call to prevent logging of garbage for connections
with IP options set.  bz#1092 from David Leonard, "looks good" deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.44 2005/06/17 02:44:32 djm Exp $");
d155 1
a155 3
		logit("Connection from %.100s with IP options:%.800s",
		    ipaddr, text);
		packet_disconnect("Connection from %.100s with IP options:%.800s",
@


1.44
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.43 2005/06/16 08:00:00 markus Exp $");
a45 3
	if (from.ss_family == AF_INET)
		check_ip_options(sock, ntop);

d49 3
@


1.44.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.48 2005/12/28 22:46:06 stevesk Exp $");
d46 3
a52 3
	if (from.ss_family == AF_INET)
		check_ip_options(sock, ntop);

d100 1
a100 1
		    "failed - POSSIBLE BREAK-IN ATTEMPT!", name);
d115 1
a115 1
		    "map back to the address - POSSIBLE BREAK-IN ATTEMPT!",
d155 3
a157 1
		fatal("Connection from %.100s with IP options:%.800s",
a170 1
	char *host;
d172 1
a172 1
	static char *remote_ip = NULL;
d175 6
a180 4
	if (use_dns && canonical_host_name != NULL)
		return canonical_host_name;
	if (!use_dns && remote_ip != NULL)
		return remote_ip;
d184 2
a185 1
		host = get_remote_hostname(packet_get_connection_in(), use_dns);
d187 1
a187 1
		host = "UNKNOWN";
d189 2
a190 5
	if (use_dns)
		canonical_host_name = host;
	else
		remote_ip = host;
	return host;
@


1.44.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: canohost.c,v 1.61 2006/08/03 03:34:41 deraadt Exp $ */
d14 2
a15 12
#include <sys/types.h>
#include <sys/socket.h>

#include <netinet/in.h>

#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
d17 1
a18 1
#include "packet.h"
d85 1
a85 1
			name[i] = (char)tolower(name[i]);
d100 1
a100 1
		    "[%s] failed - POSSIBLE BREAK-IN ATTEMPT!", name, ntop);
@


1.43
log
@don't exit if getpeername fails for forwarded ports; bugzilla #1054; ok djm
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.42 2005/02/18 03:05:53 djm Exp $");
d140 2
a141 1
	int i, ipproto;
@


1.42
log
@better error messages for getnameinfo failures; ok dtucker@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.41 2004/07/21 11:51:29 djm Exp $");
d310 1
a310 1
			cleanup_exit(255);
@


1.42.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.44 2005/06/17 02:44:32 djm Exp $");
d140 1
a140 2
	u_int i;
	int ipproto;
d310 1
a310 1
			return -1;
@


1.42.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.48 2005/12/28 22:46:06 stevesk Exp $");
d46 3
a52 3
	if (from.ss_family == AF_INET)
		check_ip_options(sock, ntop);

d100 1
a100 1
		    "failed - POSSIBLE BREAK-IN ATTEMPT!", name);
d115 1
a115 1
		    "map back to the address - POSSIBLE BREAK-IN ATTEMPT!",
d155 3
a157 1
		fatal("Connection from %.100s with IP options:%.800s",
a170 1
	char *host;
d172 1
a172 1
	static char *remote_ip = NULL;
d175 6
a180 4
	if (use_dns && canonical_host_name != NULL)
		return canonical_host_name;
	if (!use_dns && remote_ip != NULL)
		return remote_ip;
d184 2
a185 1
		host = get_remote_hostname(packet_get_connection_in(), use_dns);
d187 1
a187 1
		host = "UNKNOWN";
d189 2
a190 5
	if (use_dns)
		canonical_host_name = host;
	else
		remote_ip = host;
	return host;
@


1.41
log
@bz#902: cache remote port so we don't fatal() in auth_log when remote
connection goes away quickly. from peak AT argo.troja.mff.cuni.cz; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.40 2004/06/21 17:36:31 avsm Exp $");
d202 1
d218 4
a221 3
	if (getnameinfo((struct sockaddr *)&addr, addrlen, ntop, sizeof(ntop),
	    NULL, 0, flags) != 0) {
		error("get_socket_address: getnameinfo %d failed", flags);
d297 1
d314 4
a317 3
	if (getnameinfo((struct sockaddr *)&from, fromlen, NULL, 0,
	    strport, sizeof(strport), NI_NUMERICSERV) != 0)
		fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed");
@


1.41.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.42 2005/02/18 03:05:53 djm Exp $");
a201 1
	int r;
d217 3
a219 4
	if ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,
	    sizeof(ntop), NULL, 0, flags)) != 0) {
		error("get_socket_address: getnameinfo %d failed: %s", flags,
		    r == EAI_SYSTEM ? strerror(errno) : gai_strerror(r));
a294 1
	int r;
d311 3
a313 4
	if ((r = getnameinfo((struct sockaddr *)&from, fromlen, NULL, 0,
	    strport, sizeof(strport), NI_NUMERICSERV)) != 0)
		fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed: %s",
		    r == EAI_SYSTEM ? strerror(errno) : gai_strerror(r));
@


1.41.2.2
log
@upgrade to OpenSSH 4.2
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.44 2005/06/17 02:44:32 djm Exp $");
d140 1
a140 2
	u_int i;
	int ipproto;
d310 1
a310 1
			return -1;
@


1.40
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.39 2004/03/31 21:58:47 djm Exp $");
d342 7
a348 1
	return get_port(0);
@


1.39
log
@don't skip ip options check when UseDNS=no; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.38 2003/09/23 20:17:11 markus Exp $");
d30 1
a30 1
get_remote_hostname(int socket, int use_dns)
d41 1
a41 1
	if (getpeername(socket, (struct sockaddr *)&from, &fromlen) < 0) {
d47 1
a47 1
		check_ip_options(socket, ntop);
d135 1
a135 1
check_ip_options(int socket, char *ipaddr)
d148 1
a148 1
	if (getsockopt(socket, ipproto, IP_OPTIONS, options,
d197 1
a197 1
get_socket_address(int socket, int remote, int flags)
d208 1
a208 1
		if (getpeername(socket, (struct sockaddr *)&addr, &addrlen)
d212 1
a212 1
		if (getsockname(socket, (struct sockaddr *)&addr, &addrlen)
d226 1
a226 1
get_peer_ipaddr(int socket)
d230 1
a230 1
	if ((p = get_socket_address(socket, 1, NI_NUMERICHOST)) != NULL)
d236 1
a236 1
get_local_ipaddr(int socket)
d240 1
a240 1
	if ((p = get_socket_address(socket, 0, NI_NUMERICHOST)) != NULL)
d246 1
a246 1
get_local_name(int socket)
d248 1
a248 1
	return get_socket_address(socket, 0, NI_NAMEREQD);
@


1.38
log
@replace fatal_cleanup() and linked list of fatal callbacks with static
cleanup_exit() function.  re-refine cleanup_exit() where appropriate,
allocate sshd's authctxt eary to allow simpler cleanup in sshd.
tested by many, ok deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.37 2003/06/02 09:17:34 markus Exp $");
d46 3
a54 3

	if (from.ss_family == AF_INET)
		check_ip_options(socket, ntop);
@


1.38.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.41 2004/07/21 11:51:29 djm Exp $");
d30 1
a30 1
get_remote_hostname(int sock, int use_dns)
d41 1
a41 1
	if (getpeername(sock, (struct sockaddr *)&from, &fromlen) < 0) {
a45 3
	if (from.ss_family == AF_INET)
		check_ip_options(sock, ntop);

d53 3
d135 1
a135 1
check_ip_options(int sock, char *ipaddr)
d148 1
a148 1
	if (getsockopt(sock, ipproto, IP_OPTIONS, options,
d197 1
a197 1
get_socket_address(int sock, int remote, int flags)
d208 1
a208 1
		if (getpeername(sock, (struct sockaddr *)&addr, &addrlen)
d212 1
a212 1
		if (getsockname(sock, (struct sockaddr *)&addr, &addrlen)
d226 1
a226 1
get_peer_ipaddr(int sock)
d230 1
a230 1
	if ((p = get_socket_address(sock, 1, NI_NUMERICHOST)) != NULL)
d236 1
a236 1
get_local_ipaddr(int sock)
d240 1
a240 1
	if ((p = get_socket_address(sock, 0, NI_NUMERICHOST)) != NULL)
d246 1
a246 1
get_local_name(int sock)
d248 1
a248 1
	return get_socket_address(sock, 0, NI_NAMEREQD);
d342 1
a342 7
	static int port = -1;

	/* Cache to avoid getpeername() on a dead connection */
	if (port == -1)
		port = get_port(0);

	return port;
@


1.38.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.42 2005/02/18 03:05:53 djm Exp $");
a201 1
	int r;
d217 3
a219 4
	if ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,
	    sizeof(ntop), NULL, 0, flags)) != 0) {
		error("get_socket_address: getnameinfo %d failed: %s", flags,
		    r == EAI_SYSTEM ? strerror(errno) : gai_strerror(r));
a294 1
	int r;
d311 3
a313 4
	if ((r = getnameinfo((struct sockaddr *)&from, fromlen, NULL, 0,
	    strport, sizeof(strport), NI_NUMERICSERV)) != 0)
		fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed: %s",
		    r == EAI_SYSTEM ? strerror(errno) : gai_strerror(r));
@


1.37
log
@deprecate VerifyReverseMapping since it's dangerous if combined
with IP based access control as noted by Mike Harding; replace with
a UseDNS option, UseDNS is on by default and includes the
VerifyReverseMapping check; with itojun@@, provos@@, jakob@@ and deraadt@@
ok deraadt@@, djm@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.36 2003/04/08 20:21:28 itojun Exp $");
d43 1
a43 1
		fatal_cleanup();
d267 1
a267 1
				fatal_cleanup();
d307 1
a307 1
			fatal_cleanup();
@


1.37.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.38 2003/09/23 20:17:11 markus Exp $");
d43 1
a43 1
		cleanup_exit(255);
d267 1
a267 1
				cleanup_exit(255);
d307 1
a307 1
			cleanup_exit(255);
@


1.37.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.41 2004/07/21 11:51:29 djm Exp $");
d30 1
a30 1
get_remote_hostname(int sock, int use_dns)
d41 1
a41 1
	if (getpeername(sock, (struct sockaddr *)&from, &fromlen) < 0) {
a45 3
	if (from.ss_family == AF_INET)
		check_ip_options(sock, ntop);

d53 3
d135 1
a135 1
check_ip_options(int sock, char *ipaddr)
d148 1
a148 1
	if (getsockopt(sock, ipproto, IP_OPTIONS, options,
d197 1
a197 1
get_socket_address(int sock, int remote, int flags)
d208 1
a208 1
		if (getpeername(sock, (struct sockaddr *)&addr, &addrlen)
d212 1
a212 1
		if (getsockname(sock, (struct sockaddr *)&addr, &addrlen)
d226 1
a226 1
get_peer_ipaddr(int sock)
d230 1
a230 1
	if ((p = get_socket_address(sock, 1, NI_NUMERICHOST)) != NULL)
d236 1
a236 1
get_local_ipaddr(int sock)
d240 1
a240 1
	if ((p = get_socket_address(sock, 0, NI_NUMERICHOST)) != NULL)
d246 1
a246 1
get_local_name(int sock)
d248 1
a248 1
	return get_socket_address(sock, 0, NI_NAMEREQD);
d342 1
a342 7
	static int port = -1;

	/* Cache to avoid getpeername() on a dead connection */
	if (port == -1)
		port = get_port(0);

	return port;
@


1.36
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.35 2002/11/26 02:38:54 stevesk Exp $");
d30 1
a30 1
get_remote_hostname(int socket, int verify_reverse_mapping)
d50 3
a60 3
#if 0
		logit("Could not reverse map address %.100s.", ntop);
#endif
d64 15
a78 2
	/* Got host name. */
	name[sizeof(name) - 1] = '\0';
a85 3

	if (!verify_reverse_mapping)
		return xstrdup(name);
d168 1
a168 1
get_canonical_hostname(int verify_reverse_mapping)
d171 1
a171 1
	static int verify_reverse_mapping_done = 0;
d175 1
a175 1
		if (verify_reverse_mapping_done != verify_reverse_mapping)
d184 1
a184 1
		    packet_get_connection_in(), verify_reverse_mapping);
d188 1
a188 1
	verify_reverse_mapping_done = verify_reverse_mapping;
d277 1
a277 1
get_remote_name_or_ip(u_int utmp_len, int verify_reverse_mapping)
d281 1
a281 1
		remote = get_canonical_hostname(verify_reverse_mapping);
@


1.35
log
@KNF, comment and error message repair; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.34 2002/09/23 20:46:27 stevesk Exp $");
d59 1
a59 1
		log("Could not reverse map address %.100s.", ntop);
d89 1
a89 1
		log("reverse mapping checking getaddrinfo for %.700s "
d104 1
a104 1
		log("Address %.100s maps to %.600s, but this does not "
d144 1
a144 1
		log("Connection from %.100s with IP options:%.800s",
@


1.35.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.37 2003/06/02 09:17:34 markus Exp $");
d30 1
a30 1
get_remote_hostname(int socket, int use_dns)
a49 3
	if (!use_dns)
		return xstrdup(ntop);

d58 3
d64 2
a65 15
	/*
	 * if reverse lookup result looks like a numeric hostname,
	 * someone is trying to trick us by PTR record like following:
	 *	1.1.1.10.in-addr.arpa.	IN PTR	2.3.4.5
	 */
	memset(&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(name, "0", &hints, &ai) == 0) {
		logit("Nasty PTR record \"%s\" is set up for %s, ignoring",
		    name, ntop);
		freeaddrinfo(ai);
		return xstrdup(ntop);
	}

d73 3
d89 1
a89 1
		logit("reverse mapping checking getaddrinfo for %.700s "
d104 1
a104 1
		logit("Address %.100s maps to %.600s, but this does not "
d144 1
a144 1
		logit("Connection from %.100s with IP options:%.800s",
d158 1
a158 1
get_canonical_hostname(int use_dns)
d161 1
a161 1
	static int use_dns_done = 0;
d165 1
a165 1
		if (use_dns_done != use_dns)
d174 1
a174 1
		    packet_get_connection_in(), use_dns);
d178 1
a178 1
	use_dns_done = use_dns;
d267 1
a267 1
get_remote_name_or_ip(u_int utmp_len, int use_dns)
d271 1
a271 1
		remote = get_canonical_hostname(use_dns);
@


1.35.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.38 2003/09/23 20:17:11 markus Exp $");
d43 1
a43 1
		cleanup_exit(255);
d267 1
a267 1
				cleanup_exit(255);
d307 1
a307 1
			cleanup_exit(255);
@


1.34
log
@change get_peer_ipaddr() and get_local_ipaddr() to not return NULL for
non-sockets; fixes a problem passing NULL to snprintf(). ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.33 2002/07/09 11:56:27 itojun Exp $");
d41 1
a41 1
	if (getpeername(socket, (struct sockaddr *) &from, &fromlen) < 0) {
d183 2
a184 2
 * Returns the remote IP-address of socket as a string.  The returned
 * string must be freed.
d209 1
a209 1
		error("get_socket_ipaddr: getnameinfo %d failed", flags);
d295 1
a295 1
		if (getpeername(sock, (struct sockaddr *) & from, &fromlen) < 0) {
@


1.34.2.1
log
@Update to OpenSSH 3.6
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.35 2002/11/26 02:38:54 stevesk Exp $");
d41 1
a41 1
	if (getpeername(socket, (struct sockaddr *)&from, &fromlen) < 0) {
d183 2
a184 2
 * Returns the local/remote IP-address/hostname of socket as a string.
 * The returned string must be freed.
d209 1
a209 1
		error("get_socket_address: getnameinfo %d failed", flags);
d295 1
a295 1
		if (getpeername(sock, (struct sockaddr *)&from, &fromlen) < 0) {
@


1.34.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.37 2003/06/02 09:17:34 markus Exp $");
d30 1
a30 1
get_remote_hostname(int socket, int use_dns)
a49 3
	if (!use_dns)
		return xstrdup(ntop);

d58 3
d64 2
a65 15
	/*
	 * if reverse lookup result looks like a numeric hostname,
	 * someone is trying to trick us by PTR record like following:
	 *	1.1.1.10.in-addr.arpa.	IN PTR	2.3.4.5
	 */
	memset(&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(name, "0", &hints, &ai) == 0) {
		logit("Nasty PTR record \"%s\" is set up for %s, ignoring",
		    name, ntop);
		freeaddrinfo(ai);
		return xstrdup(ntop);
	}

d73 3
d89 1
a89 1
		logit("reverse mapping checking getaddrinfo for %.700s "
d104 1
a104 1
		logit("Address %.100s maps to %.600s, but this does not "
d144 1
a144 1
		logit("Connection from %.100s with IP options:%.800s",
d158 1
a158 1
get_canonical_hostname(int use_dns)
d161 1
a161 1
	static int use_dns_done = 0;
d165 1
a165 1
		if (use_dns_done != use_dns)
d174 1
a174 1
		    packet_get_connection_in(), use_dns);
d178 1
a178 1
	use_dns_done = use_dns;
d267 1
a267 1
get_remote_name_or_ip(u_int utmp_len, int use_dns)
d271 1
a271 1
		remote = get_canonical_hostname(use_dns);
@


1.33
log
@suppress log on reverse lookup failiure, as there's no real value in doing so.
markus ok
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.32 2002/06/11 08:11:45 itojun Exp $");
d199 1
a199 3
		    < 0) {
			debug("get_socket_ipaddr: getpeername failed: %.100s",
			    strerror(errno));
a200 1
		}
d203 1
a203 3
		    < 0) {
			debug("get_socket_ipaddr: getsockname failed: %.100s",
			    strerror(errno));
a204 1
		}
d218 5
a222 1
	return get_socket_address(socket, 1, NI_NUMERICHOST);
d228 5
a232 1
	return get_socket_address(socket, 0, NI_NUMERICHOST);
@


1.32
log
@use "ntop" only after initialized
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.31 2002/02/27 21:23:13 stevesk Exp $");
d58 1
d60 1
@


1.31
log
@remove unneeded casts in [gs]etsockopt(); ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.30 2002/01/29 14:32:03 markus Exp $");
a44 2
	if (from.ss_family == AF_INET)
		check_ip_options(socket, ntop);
d49 3
@


1.31.2.1
log
@Pull in OpenSSH-3.4
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.32 2002/06/11 08:11:45 itojun Exp $");
d45 2
a50 3

	if (from.ss_family == AF_INET)
		check_ip_options(socket, ntop);
@


1.31.2.2
log
@Update to OpenSSH 3.5
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.34 2002/09/23 20:46:27 stevesk Exp $");
a57 1
#if 0
a58 1
#endif
d197 3
a199 1
		    < 0)
d201 1
d204 3
a206 1
		    < 0)
d208 1
d222 1
a222 5
	char *p;

	if ((p = get_socket_address(socket, 1, NI_NUMERICHOST)) != NULL)
		return p;
	return xstrdup("UNKNOWN");
d228 1
a228 5
	char *p;

	if ((p = get_socket_address(socket, 0, NI_NUMERICHOST)) != NULL)
		return p;
	return xstrdup("UNKNOWN");
@


1.31.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.35 2002/11/26 02:38:54 stevesk Exp $");
d41 1
a41 1
	if (getpeername(socket, (struct sockaddr *)&from, &fromlen) < 0) {
d183 2
a184 2
 * Returns the local/remote IP-address/hostname of socket as a string.
 * The returned string must be freed.
d209 1
a209 1
		error("get_socket_address: getnameinfo %d failed", flags);
d295 1
a295 1
		if (getpeername(sock, (struct sockaddr *)&from, &fromlen) < 0) {
@


1.30
log
@s/ReverseMappingCheck/VerifyReverseMapping/ and avoid confusion; ok stevesk@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.29 2001/12/19 07:18:56 deraadt Exp $");
d135 1
a135 1
	if (getsockopt(socket, ipproto, IP_OPTIONS, (void *)options,
@


1.29
log
@basic KNF done while i was looking for something else
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.28 2001/12/05 03:56:39 itojun Exp $");
d30 1
a30 1
get_remote_hostname(int socket, int reverse_mapping_check)
d71 1
a71 1
	if (!reverse_mapping_check)
d155 1
a155 1
get_canonical_hostname(int reverse_mapping_check)
d158 1
a158 1
	static int reverse_mapping_checked = 0;
d162 1
a162 1
		if (reverse_mapping_checked != reverse_mapping_check)
d171 1
a171 1
		    packet_get_connection_in(), reverse_mapping_check);
d175 1
a175 1
	reverse_mapping_checked = reverse_mapping_check;
d262 1
a262 1
get_remote_name_or_ip(u_int utmp_len, int reverse_mapping_check)
d266 1
a266 1
		remote = get_canonical_hostname(reverse_mapping_check);
@


1.28
log
@make it compile with more strict prototype checking
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.27 2001/06/23 15:12:17 itojun Exp $");
d49 1
a49 1
	     NULL, 0, NI_NUMERICHOST) != 0)
d55 1
a55 1
	     NULL, 0, NI_NAMEREQD) != 0) {
d211 1
a211 1
	     NULL, 0, flags) != 0) {
d297 1
a297 1
	     strport, sizeof(strport), NI_NUMERICSERV) != 0)
@


1.27
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.26 2001/04/18 14:15:00 markus Exp $");
d242 1
a242 1
get_remote_ipaddr()
d325 1
a325 1
get_remote_port()
d331 1
a331 1
get_local_port()
@


1.27.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.31 2002/02/27 21:23:13 stevesk Exp $");
d30 1
a30 1
get_remote_hostname(int socket, int verify_reverse_mapping)
d49 1
a49 1
	    NULL, 0, NI_NUMERICHOST) != 0)
d55 1
a55 1
	    NULL, 0, NI_NAMEREQD) != 0) {
d71 1
a71 1
	if (!verify_reverse_mapping)
d135 1
a135 1
	if (getsockopt(socket, ipproto, IP_OPTIONS, options,
d155 1
a155 1
get_canonical_hostname(int verify_reverse_mapping)
d158 1
a158 1
	static int verify_reverse_mapping_done = 0;
d162 1
a162 1
		if (verify_reverse_mapping_done != verify_reverse_mapping)
d171 1
a171 1
		    packet_get_connection_in(), verify_reverse_mapping);
d175 1
a175 1
	verify_reverse_mapping_done = verify_reverse_mapping;
d211 1
a211 1
	    NULL, 0, flags) != 0) {
d242 1
a242 1
get_remote_ipaddr(void)
d262 1
a262 1
get_remote_name_or_ip(u_int utmp_len, int verify_reverse_mapping)
d266 1
a266 1
		remote = get_canonical_hostname(verify_reverse_mapping);
d297 1
a297 1
	    strport, sizeof(strport), NI_NUMERICSERV) != 0)
d325 1
a325 1
get_remote_port(void)
d331 1
a331 1
get_local_port(void)
@


1.27.2.2
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.27.2.1 2002/03/07 17:37:46 jason Exp $");
d45 2
a50 3

	if (from.ss_family == AF_INET)
		check_ip_options(socket, ntop);
@


1.27.2.3
log
@Update to OpenSSH 3.5
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.34 2002/09/23 20:46:27 stevesk Exp $");
a57 1
#if 0
a58 1
#endif
d197 3
a199 1
		    < 0)
d201 1
d204 3
a206 1
		    < 0)
d208 1
d222 1
a222 5
	char *p;

	if ((p = get_socket_address(socket, 1, NI_NUMERICHOST)) != NULL)
		return p;
	return xstrdup("UNKNOWN");
d228 1
a228 5
	char *p;

	if ((p = get_socket_address(socket, 0, NI_NUMERICHOST)) != NULL)
		return p;
	return xstrdup("UNKNOWN");
@


1.26
log
@debug->debug3
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.25 2001/04/12 19:15:24 markus Exp $");
d22 1
a22 1
void	check_ip_options(int socket, char *ipaddr);
d29 1
a29 1
char *
d121 1
a121 1
void
d183 1
a183 1
char *
d274 1
a274 1
int
d304 1
a304 1
int
@


1.26.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.27 2001/06/23 15:12:17 itojun Exp $");
d22 1
a22 1
static void check_ip_options(int, char *);
d29 1
a29 1
static char *
d121 1
a121 1
static void
d183 1
a183 1
static char *
d274 1
a274 1
static int
d304 1
a304 1
static int
@


1.26.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.31 2002/02/27 21:23:13 stevesk Exp $");
d30 1
a30 1
get_remote_hostname(int socket, int verify_reverse_mapping)
d49 1
a49 1
	    NULL, 0, NI_NUMERICHOST) != 0)
d55 1
a55 1
	    NULL, 0, NI_NAMEREQD) != 0) {
d71 1
a71 1
	if (!verify_reverse_mapping)
d135 1
a135 1
	if (getsockopt(socket, ipproto, IP_OPTIONS, options,
d155 1
a155 1
get_canonical_hostname(int verify_reverse_mapping)
d158 1
a158 1
	static int verify_reverse_mapping_done = 0;
d162 1
a162 1
		if (verify_reverse_mapping_done != verify_reverse_mapping)
d171 1
a171 1
		    packet_get_connection_in(), verify_reverse_mapping);
d175 1
a175 1
	verify_reverse_mapping_done = verify_reverse_mapping;
d211 1
a211 1
	    NULL, 0, flags) != 0) {
d242 1
a242 1
get_remote_ipaddr(void)
d262 1
a262 1
get_remote_name_or_ip(u_int utmp_len, int verify_reverse_mapping)
d266 1
a266 1
		remote = get_canonical_hostname(verify_reverse_mapping);
d297 1
a297 1
	    strport, sizeof(strport), NI_NUMERICSERV) != 0)
d325 1
a325 1
get_remote_port(void)
d331 1
a331 1
get_local_port(void)
@


1.25
log
@implement HostbasedAuthentication (= RhostRSAAuthentication for ssh v2)
similar to RhostRSAAuthentication unless you enable (the experimental)
HostbasedUsesNameFromPacketOnly option.  please test. :)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.24 2001/04/05 15:48:19 stevesk Exp $");
d52 1
a52 1
	debug("Trying to reverse map address %.100s.", ntop);
@


1.24
log
@move get_remote_name_or_ip() to canohost.[ch]; for portable.  ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.23 2001/02/10 01:33:32 markus Exp $");
a182 1

d184 1
a184 1
get_peer_ipaddr(int socket)
d186 2
a187 2
	struct sockaddr_storage from;
	socklen_t fromlen;
d191 22
a212 10
	fromlen = sizeof(from);
	memset(&from, 0, sizeof(from));
	if (getpeername(socket, (struct sockaddr *) & from, &fromlen) < 0) {
		debug("get_peer_ipaddr: getpeername failed: %.100s", strerror(errno));
		return NULL;
	}
	/* Get the IP address in ascii. */
	if (getnameinfo((struct sockaddr *)&from, fromlen, ntop, sizeof(ntop),
	     NULL, 0, NI_NUMERICHOST) != 0) {
		error("get_peer_ipaddr: getnameinfo NI_NUMERICHOST failed");
d216 18
@


1.23
log
@add debug message, since sshd blocks here if DNS is not available
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.22 2001/02/08 22:37:10 markus Exp $");
d230 11
@


1.22
log
@remove last call to sprintf; ok deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.21 2001/02/08 19:30:51 itojun Exp $");
d52 1
@


1.21
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.20 2001/02/03 10:08:37 markus Exp $");
d123 2
a124 2
	u_char options[200], *ucp;
	char text[1024], *cp;
d126 1
a126 1
	int ipproto;
d136 4
a139 4
		cp = text;
		/* Note: "text" buffer must be at least 3x as big as options. */
		for (ucp = options; option_size > 0; ucp++, option_size--, cp += 3)
			sprintf(cp, " %2.2x", *ucp);
@


1.20
log
@make ReverseMappingCheck optional in sshd_config; ok djm@@,dugsong@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.19 2001/01/29 19:42:33 markus Exp $");
d20 1
@


1.19
log
@add get_peer_ipaddr(socket), x11-fwd in ssh2 requires ipaddr, not DNS
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.18 2001/01/21 19:05:45 markus Exp $");
d21 2
d29 1
a29 1
get_remote_hostname(int socket)
d35 1
a35 2
	char name[MAXHOSTNAMELEN];
	char ntop[NI_MAXHOST], ntop2[NI_MAXHOST];
d40 1
a40 1
	if (getpeername(socket, (struct sockaddr *) & from, &fromlen) < 0) {
d44 3
d53 4
a56 49
	     NULL, 0, NI_NAMEREQD) == 0) {
		/* Got host name. */
		name[sizeof(name) - 1] = '\0';
		/*
		 * Convert it to all lowercase (which is expected by the rest
		 * of this software).
		 */
		for (i = 0; name[i]; i++)
			if (isupper(name[i]))
				name[i] = tolower(name[i]);

		/*
		 * Map it back to an IP address and check that the given
		 * address actually is an address of this host.  This is
		 * necessary because anyone with access to a name server can
		 * define arbitrary names for an IP address. Mapping from
		 * name to IP address can be trusted better (but can still be
		 * fooled if the intruder has access to the name server of
		 * the domain).
		 */
		memset(&hints, 0, sizeof(hints));
		hints.ai_family = from.ss_family;
		hints.ai_socktype = SOCK_STREAM;
		if (getaddrinfo(name, NULL, &hints, &aitop) != 0) {
			log("reverse mapping checking getaddrinfo for %.700s failed - POSSIBLE BREAKIN ATTEMPT!", name);
			strlcpy(name, ntop, sizeof name);
			goto check_ip_options;
		}
		/* Look for the address from the list of addresses. */
		for (ai = aitop; ai; ai = ai->ai_next) {
			if (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop2,
			    sizeof(ntop2), NULL, 0, NI_NUMERICHOST) == 0 &&
			    (strcmp(ntop, ntop2) == 0))
					break;
		}
		freeaddrinfo(aitop);
		/* If we reached the end of the list, the address was not there. */
		if (!ai) {
			/* Address not found for the host name. */
			log("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
			    ntop, name);
			strlcpy(name, ntop, sizeof name);
			goto check_ip_options;
		}
		/* Address was found for the host name.  We accept the host name. */
	} else {
		/* Host name not found.  Use ascii representation of the address. */
		strlcpy(name, ntop, sizeof name);
		log("Could not reverse map address %.100s.", name);
d59 9
a67 1
check_ip_options:
d69 2
d72 7
a78 9
	 * If IP options are supported, make sure there are none (log and
	 * disconnect them if any are found).  Basically we are worried about
	 * source routing; it can be used to pretend you are somebody
	 * (ip-address) you are not. That itself may be "almost acceptable"
	 * under certain circumstances, but rhosts autentication is useless
	 * if source routing is accepted. Notice also that if we just dropped
	 * source routing here, the other side could use IP spoofing to do
	 * rest of the interaction and could still bypass security.  So we
	 * exit here if we detect any IP options.
d80 26
a105 7
	/* IP options -- IPv4 only */
	if (from.ss_family == AF_INET) {
		u_char options[200], *ucp;
		char text[1024], *cp;
		socklen_t option_size;
		int ipproto;
		struct protoent *ip;
d107 36
a142 16
		if ((ip = getprotobyname("ip")) != NULL)
			ipproto = ip->p_proto;
		else
			ipproto = IPPROTO_IP;
		option_size = sizeof(options);
		if (getsockopt(socket, ipproto, IP_OPTIONS, (char *) options,
		    &option_size) >= 0 && option_size != 0) {
			cp = text;
			/* Note: "text" buffer must be at least 3x as big as options. */
			for (ucp = options; option_size > 0; ucp++, option_size--, cp += 3)
				sprintf(cp, " %2.2x", *ucp);
			log("Connection from %.100s with IP options:%.800s",
			    ntop, text);
			packet_disconnect("Connection from %.100s with IP options:%.800s",
					  ntop, text);
		}
a143 2

	return xstrdup(name);
d153 1
a153 1
get_canonical_hostname()
d156 1
d158 7
a164 3
	/* Check if we have previously retrieved this same name. */
	if (canonical_host_name != NULL)
		return canonical_host_name;
d168 2
a169 1
		canonical_host_name = get_remote_hostname(packet_get_connection_in());
d173 1
@


1.18
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.17 2000/12/19 23:17:55 markus Exp $");
d167 2
a168 2
 * Returns the IP-address of the remote host as a string.  The returned
 * string must not be freed.
d171 2
a172 2
const char *
get_remote_ipaddr()
a173 1
	static char *canonical_host_ip = NULL;
a175 1
	int socket;
a177 12
	/* Check whether we have chached the name. */
	if (canonical_host_ip != NULL)
		return canonical_host_ip;

	/* If not a socket, return UNKNOWN. */
	if (!packet_connection_is_on_socket()) {
		canonical_host_ip = xstrdup("UNKNOWN");
		return canonical_host_ip;
	}
	/* Get client socket. */
	socket = packet_get_connection_in();

d182 2
a183 2
		debug("getpeername failed: %.100s", strerror(errno));
		fatal_cleanup();
d187 11
a197 2
	     NULL, 0, NI_NUMERICHOST) != 0)
		fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
d199 4
a202 1
	canonical_host_ip = xstrdup(ntop);
d204 12
a215 1
	/* Return ip address string. */
@


1.17
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.16 2000/10/21 17:04:22 markus Exp $");
d19 1
a19 1
#include "ssh.h"
@


1.16
log
@typo, eramore@@era-t.ericsson.se; ok niels@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.15 2000/09/07 21:13:37 markus Exp $");
d115 1
a115 1
		unsigned char options[200], *ucp;
@


1.16.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.23 2001/02/10 01:33:32 markus Exp $");
d19 1
a19 4
#include "log.h"
#include "canohost.h"

void	check_ip_options(int socket, char *ipaddr);
d27 1
a27 1
get_remote_hostname(int socket, int reverse_mapping_check)
d33 2
a34 1
	char name[NI_MAXHOST], ntop[NI_MAXHOST], ntop2[NI_MAXHOST];
d39 1
a39 1
	if (getpeername(socket, (struct sockaddr *) &from, &fromlen) < 0) {
a42 3
	if (from.ss_family == AF_INET)
		check_ip_options(socket, ntop);

a46 1
	debug("Trying to reverse map address %.100s.", ntop);
d49 49
a97 4
	     NULL, 0, NI_NAMEREQD) != 0) {
		/* Host name not found.  Use ip address. */
		log("Could not reverse map address %.100s.", ntop);
		return xstrdup(ntop);
d100 2
a101 2
	/* Got host name. */
	name[sizeof(name) - 1] = '\0';
d103 9
a111 2
	 * Convert it to all lowercase (which is expected by the rest
	 * of this software).
d113 7
a119 3
	for (i = 0; name[i]; i++)
		if (isupper(name[i]))
			name[i] = tolower(name[i]);
d121 16
a136 34
	if (!reverse_mapping_check)
		return xstrdup(name);
	/*
	 * Map it back to an IP address and check that the given
	 * address actually is an address of this host.  This is
	 * necessary because anyone with access to a name server can
	 * define arbitrary names for an IP address. Mapping from
	 * name to IP address can be trusted better (but can still be
	 * fooled if the intruder has access to the name server of
	 * the domain).
	 */
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = from.ss_family;
	hints.ai_socktype = SOCK_STREAM;
	if (getaddrinfo(name, NULL, &hints, &aitop) != 0) {
		log("reverse mapping checking getaddrinfo for %.700s "
		    "failed - POSSIBLE BREAKIN ATTEMPT!", name);
		return xstrdup(ntop);
	}
	/* Look for the address from the list of addresses. */
	for (ai = aitop; ai; ai = ai->ai_next) {
		if (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop2,
		    sizeof(ntop2), NULL, 0, NI_NUMERICHOST) == 0 &&
		    (strcmp(ntop, ntop2) == 0))
				break;
	}
	freeaddrinfo(aitop);
	/* If we reached the end of the list, the address was not there. */
	if (!ai) {
		/* Address not found for the host name. */
		log("Address %.100s maps to %.600s, but this does not "
		    "map back to the address - POSSIBLE BREAKIN ATTEMPT!",
		    ntop, name);
		return xstrdup(ntop);
d138 1
a142 39
 * If IP options are supported, make sure there are none (log and
 * disconnect them if any are found).  Basically we are worried about
 * source routing; it can be used to pretend you are somebody
 * (ip-address) you are not. That itself may be "almost acceptable"
 * under certain circumstances, but rhosts autentication is useless
 * if source routing is accepted. Notice also that if we just dropped
 * source routing here, the other side could use IP spoofing to do
 * rest of the interaction and could still bypass security.  So we
 * exit here if we detect any IP options.
 */
/* IPv4 only */
void
check_ip_options(int socket, char *ipaddr)
{
	u_char options[200];
	char text[sizeof(options) * 3 + 1];
	socklen_t option_size;
	int i, ipproto;
	struct protoent *ip;

	if ((ip = getprotobyname("ip")) != NULL)
		ipproto = ip->p_proto;
	else
		ipproto = IPPROTO_IP;
	option_size = sizeof(options);
	if (getsockopt(socket, ipproto, IP_OPTIONS, (void *)options,
	    &option_size) >= 0 && option_size != 0) {
		text[0] = '\0';
		for (i = 0; i < option_size; i++)
			snprintf(text + i*3, sizeof(text) - i*3,
			    " %2.2x", options[i]);
		log("Connection from %.100s with IP options:%.800s",
		    ipaddr, text);
		packet_disconnect("Connection from %.100s with IP options:%.800s",
		    ipaddr, text);
	}
}

/*
d149 1
a149 1
get_canonical_hostname(int reverse_mapping_check)
a151 1
	static int reverse_mapping_checked = 0;
d153 3
a155 7
	/* Check if we have previously retrieved name with same option. */
	if (canonical_host_name != NULL) {
		if (reverse_mapping_checked != reverse_mapping_check)
			xfree(canonical_host_name);
		else
			return canonical_host_name;
	}
d159 1
a159 2
		canonical_host_name = get_remote_hostname(
		    packet_get_connection_in(), reverse_mapping_check);
a162 1
	reverse_mapping_checked = reverse_mapping_check;
d167 2
a168 2
 * Returns the remote IP-address of socket as a string.  The returned
 * string must be freed.
d171 2
a172 2
char *
get_peer_ipaddr(int socket)
d174 1
d177 1
d180 12
d196 2
a197 2
		debug("get_peer_ipaddr: getpeername failed: %.100s", strerror(errno));
		return NULL;
d201 2
a202 11
	     NULL, 0, NI_NUMERICHOST) != 0) {
		error("get_peer_ipaddr: getnameinfo NI_NUMERICHOST failed");
		return NULL;
	}
	return xstrdup(ntop);
}

/*
 * Returns the IP-address of the remote host as a string.  The returned
 * string must not be freed.
 */
d204 1
a204 4
const char *
get_remote_ipaddr()
{
	static char *canonical_host_ip = NULL;
d206 1
a206 12
	/* Check whether we have cached the ipaddr. */
	if (canonical_host_ip == NULL) {
		if (packet_connection_is_on_socket()) {
			canonical_host_ip =
			    get_peer_ipaddr(packet_get_connection_in());
			if (canonical_host_ip == NULL)
				fatal_cleanup();
		} else {
			/* If not on socket, return UNKNOWN. */
			canonical_host_ip = xstrdup("UNKNOWN");
		}
	}
@


1.16.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.16.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.16.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.26 2001/04/18 14:15:00 markus Exp $");
d52 1
a52 1
	debug3("Trying to reverse map address %.100s.", ntop);
d183 1
d185 1
a185 1
get_socket_address(int socket, int remote, int flags)
d187 2
a188 2
	struct sockaddr_storage addr;
	socklen_t addrlen;
d192 5
a196 17
	addrlen = sizeof(addr);
	memset(&addr, 0, sizeof(addr));

	if (remote) {
		if (getpeername(socket, (struct sockaddr *)&addr, &addrlen)
		    < 0) {
			debug("get_socket_ipaddr: getpeername failed: %.100s",
			    strerror(errno));
			return NULL;
		}
	} else {
		if (getsockname(socket, (struct sockaddr *)&addr, &addrlen)
		    < 0) {
			debug("get_socket_ipaddr: getsockname failed: %.100s",
			    strerror(errno));
			return NULL;
		}
d198 4
a201 4
	/* Get the address in ascii. */
	if (getnameinfo((struct sockaddr *)&addr, addrlen, ntop, sizeof(ntop),
	     NULL, 0, flags) != 0) {
		error("get_socket_ipaddr: getnameinfo %d failed", flags);
a206 18
char *
get_peer_ipaddr(int socket)
{
	return get_socket_address(socket, 1, NI_NUMERICHOST);
}

char *
get_local_ipaddr(int socket)
{
	return get_socket_address(socket, 0, NI_NUMERICHOST);
}

char *
get_local_name(int socket)
{
	return get_socket_address(socket, 0, NI_NAMEREQD);
}

a229 11
}

const char *
get_remote_name_or_ip(u_int utmp_len, int reverse_mapping_check)
{
	static const char *remote = "";
	if (utmp_len > 0)
		remote = get_canonical_hostname(reverse_mapping_check);
	if (utmp_len == 0 || strlen(remote) > utmp_len)
		remote = get_remote_ipaddr();
	return remote;
@


1.16.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.27 2001/06/23 15:12:17 itojun Exp $");
d22 1
a22 1
static void check_ip_options(int, char *);
d29 1
a29 1
static char *
d121 1
a121 1
static void
d183 1
a183 1
static char *
d274 1
a274 1
static int
d304 1
a304 1
static int
@


1.16.2.6
log
@Merge OpenSSH 3.1.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.31 2002/02/27 21:23:13 stevesk Exp $");
d30 1
a30 1
get_remote_hostname(int socket, int verify_reverse_mapping)
d49 1
a49 1
	    NULL, 0, NI_NUMERICHOST) != 0)
d55 1
a55 1
	    NULL, 0, NI_NAMEREQD) != 0) {
d71 1
a71 1
	if (!verify_reverse_mapping)
d135 1
a135 1
	if (getsockopt(socket, ipproto, IP_OPTIONS, options,
d155 1
a155 1
get_canonical_hostname(int verify_reverse_mapping)
d158 1
a158 1
	static int verify_reverse_mapping_done = 0;
d162 1
a162 1
		if (verify_reverse_mapping_done != verify_reverse_mapping)
d171 1
a171 1
		    packet_get_connection_in(), verify_reverse_mapping);
d175 1
a175 1
	verify_reverse_mapping_done = verify_reverse_mapping;
d211 1
a211 1
	    NULL, 0, flags) != 0) {
d242 1
a242 1
get_remote_ipaddr(void)
d262 1
a262 1
get_remote_name_or_ip(u_int utmp_len, int verify_reverse_mapping)
d266 1
a266 1
		remote = get_canonical_hostname(verify_reverse_mapping);
d297 1
a297 1
	    strport, sizeof(strport), NI_NUMERICSERV) != 0)
d325 1
a325 1
get_remote_port(void)
d331 1
a331 1
get_local_port(void)
@


1.15
log
@some more Copyright fixes
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.14 2000/09/07 20:27:50 deraadt Exp $");
d126 1
a126 1
		if (getsockopt(0, ipproto, IP_OPTIONS, (char *) options,
@


1.14
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@a11 23
 *
 *
 * Copyright (c) 1999,2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.13 2000/06/20 01:39:39 markus Exp $");
@


1.13
log
@OpenBSD tag
@
text
@a1 3
 *
 * canohost.c
 *
a2 1
 *
a4 3
 *
 * Created: Sun Jul  2 17:52:22 1995 ylo
 *
d7 28
d38 1
a38 1
RCSID("$OpenBSD: canohost.c,v 1.12 2000/04/14 10:30:30 markus Exp $");
@


1.12
log
@whitespace cleanup
@
text
@d17 1
a17 1
RCSID("$Id: canohost.c,v 1.11 2000/01/04 13:41:32 markus Exp $");
@


1.12.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d17 1
a17 1
RCSID("$OpenBSD: canohost.c,v 1.13 2000/06/20 01:39:39 markus Exp $");
@


1.12.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a13 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d17 1
a17 1
RCSID("$OpenBSD: canohost.c,v 1.16 2000/10/21 17:04:22 markus Exp $");
d128 1
a128 1
		if (getsockopt(socket, ipproto, IP_OPTIONS, (char *) options,
@


1.12.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d15 1
a15 1
RCSID("$OpenBSD: canohost.c,v 1.23 2001/02/10 01:33:32 markus Exp $");
d19 1
a19 4
#include "log.h"
#include "canohost.h"

void	check_ip_options(int socket, char *ipaddr);
d27 1
a27 1
get_remote_hostname(int socket, int reverse_mapping_check)
d33 2
a34 1
	char name[NI_MAXHOST], ntop[NI_MAXHOST], ntop2[NI_MAXHOST];
d39 1
a39 1
	if (getpeername(socket, (struct sockaddr *) &from, &fromlen) < 0) {
a42 3
	if (from.ss_family == AF_INET)
		check_ip_options(socket, ntop);

a46 1
	debug("Trying to reverse map address %.100s.", ntop);
d49 49
a97 4
	     NULL, 0, NI_NAMEREQD) != 0) {
		/* Host name not found.  Use ip address. */
		log("Could not reverse map address %.100s.", ntop);
		return xstrdup(ntop);
d100 2
a101 2
	/* Got host name. */
	name[sizeof(name) - 1] = '\0';
d103 9
a111 2
	 * Convert it to all lowercase (which is expected by the rest
	 * of this software).
d113 7
a119 3
	for (i = 0; name[i]; i++)
		if (isupper(name[i]))
			name[i] = tolower(name[i]);
d121 16
a136 34
	if (!reverse_mapping_check)
		return xstrdup(name);
	/*
	 * Map it back to an IP address and check that the given
	 * address actually is an address of this host.  This is
	 * necessary because anyone with access to a name server can
	 * define arbitrary names for an IP address. Mapping from
	 * name to IP address can be trusted better (but can still be
	 * fooled if the intruder has access to the name server of
	 * the domain).
	 */
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = from.ss_family;
	hints.ai_socktype = SOCK_STREAM;
	if (getaddrinfo(name, NULL, &hints, &aitop) != 0) {
		log("reverse mapping checking getaddrinfo for %.700s "
		    "failed - POSSIBLE BREAKIN ATTEMPT!", name);
		return xstrdup(ntop);
	}
	/* Look for the address from the list of addresses. */
	for (ai = aitop; ai; ai = ai->ai_next) {
		if (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop2,
		    sizeof(ntop2), NULL, 0, NI_NUMERICHOST) == 0 &&
		    (strcmp(ntop, ntop2) == 0))
				break;
	}
	freeaddrinfo(aitop);
	/* If we reached the end of the list, the address was not there. */
	if (!ai) {
		/* Address not found for the host name. */
		log("Address %.100s maps to %.600s, but this does not "
		    "map back to the address - POSSIBLE BREAKIN ATTEMPT!",
		    ntop, name);
		return xstrdup(ntop);
d138 1
a142 39
 * If IP options are supported, make sure there are none (log and
 * disconnect them if any are found).  Basically we are worried about
 * source routing; it can be used to pretend you are somebody
 * (ip-address) you are not. That itself may be "almost acceptable"
 * under certain circumstances, but rhosts autentication is useless
 * if source routing is accepted. Notice also that if we just dropped
 * source routing here, the other side could use IP spoofing to do
 * rest of the interaction and could still bypass security.  So we
 * exit here if we detect any IP options.
 */
/* IPv4 only */
void
check_ip_options(int socket, char *ipaddr)
{
	u_char options[200];
	char text[sizeof(options) * 3 + 1];
	socklen_t option_size;
	int i, ipproto;
	struct protoent *ip;

	if ((ip = getprotobyname("ip")) != NULL)
		ipproto = ip->p_proto;
	else
		ipproto = IPPROTO_IP;
	option_size = sizeof(options);
	if (getsockopt(socket, ipproto, IP_OPTIONS, (void *)options,
	    &option_size) >= 0 && option_size != 0) {
		text[0] = '\0';
		for (i = 0; i < option_size; i++)
			snprintf(text + i*3, sizeof(text) - i*3,
			    " %2.2x", options[i]);
		log("Connection from %.100s with IP options:%.800s",
		    ipaddr, text);
		packet_disconnect("Connection from %.100s with IP options:%.800s",
		    ipaddr, text);
	}
}

/*
d149 1
a149 1
get_canonical_hostname(int reverse_mapping_check)
a151 1
	static int reverse_mapping_checked = 0;
d153 3
a155 7
	/* Check if we have previously retrieved name with same option. */
	if (canonical_host_name != NULL) {
		if (reverse_mapping_checked != reverse_mapping_check)
			xfree(canonical_host_name);
		else
			return canonical_host_name;
	}
d159 1
a159 2
		canonical_host_name = get_remote_hostname(
		    packet_get_connection_in(), reverse_mapping_check);
a162 1
	reverse_mapping_checked = reverse_mapping_check;
d167 2
a168 2
 * Returns the remote IP-address of socket as a string.  The returned
 * string must be freed.
d171 2
a172 2
char *
get_peer_ipaddr(int socket)
d174 1
d177 1
d180 12
d196 2
a197 2
		debug("get_peer_ipaddr: getpeername failed: %.100s", strerror(errno));
		return NULL;
d201 2
a202 11
	     NULL, 0, NI_NUMERICHOST) != 0) {
		error("get_peer_ipaddr: getnameinfo NI_NUMERICHOST failed");
		return NULL;
	}
	return xstrdup(ntop);
}

/*
 * Returns the IP-address of the remote host as a string.  The returned
 * string must not be freed.
 */
d204 1
a204 4
const char *
get_remote_ipaddr()
{
	static char *canonical_host_ip = NULL;
d206 1
a206 12
	/* Check whether we have cached the ipaddr. */
	if (canonical_host_ip == NULL) {
		if (packet_connection_is_on_socket()) {
			canonical_host_ip =
			    get_peer_ipaddr(packet_get_connection_in());
			if (canonical_host_ip == NULL)
				fatal_cleanup();
		} else {
			/* If not on socket, return UNKNOWN. */
			canonical_host_ip = xstrdup("UNKNOWN");
		}
	}
@


1.12.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.11
log
@more hints (hints.ai_socktype=SOCK_STREAM) for getaddrinfo, from itojun@@
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
RCSID("$Id: canohost.c,v 1.10 2000/01/04 00:07:58 markus Exp $");
d244 1
a244 1
int 
d258 1
a258 1
int 
d264 1
a264 1
int 
@


1.10
log
@ipv6 support: mostly gethostbyname->getaddrinfo/getnameinfo, new features:
sshd allows multiple ListenAddress and Port options.  note that libwrap is
not IPv6-ready. (based on patches from <kick@@kyoto.wide.ad.jp> and
fujiwara@@rcac.tdi.co.jp)
@
text
@d17 1
a17 1
RCSID("$Id: canohost.c,v 1.9 1999/12/09 00:00:52 markus Exp $");
d73 1
@


1.9
log
@fix get_remote_port() and friends for sshd -i; Holger.Trapp@@Informatik.TU-Chemnitz.DE
@
text
@d17 1
a17 1
RCSID("$Id: canohost.c,v 1.8 1999/11/24 19:53:44 markus Exp $");
d31 4
a34 3
	struct sockaddr_in from;
	int fromlen, i;
	struct hostent *hp;
d36 1
d45 4
d50 4
a53 13
	hp = gethostbyaddr((char *) &from.sin_addr, sizeof(struct in_addr),
			   from.sin_family);
	if (hp) {
		/* Got host name, find canonic host name. */
		if (strchr(hp->h_name, '.') != 0)
			strlcpy(name, hp->h_name, sizeof(name));
		else if (hp->h_aliases != 0
			 && hp->h_aliases[0] != 0
			 && strchr(hp->h_aliases[0], '.') != 0)
			strlcpy(name, hp->h_aliases[0], sizeof(name));
		else
			strlcpy(name, hp->h_name, sizeof(name));

d71 5
a75 4
		hp = gethostbyname(name);
		if (!hp) {
			log("reverse mapping checking gethostbyname for %.700s failed - POSSIBLE BREAKIN ATTEMPT!", name);
			strlcpy(name, inet_ntoa(from.sin_addr), sizeof name);
d79 9
a87 9
		for (i = 0; hp->h_addr_list[i]; i++)
			if (memcmp(hp->h_addr_list[i], &from.sin_addr, sizeof(from.sin_addr))
			    == 0)
				break;
		/*
		 * If we reached the end of the list, the address was not
		 * there.
		 */
		if (!hp->h_addr_list[i]) {
d90 2
a91 2
			    inet_ntoa(from.sin_addr), name);
			strlcpy(name, inet_ntoa(from.sin_addr), sizeof name);
d97 1
a97 1
		strlcpy(name, inet_ntoa(from.sin_addr), sizeof name);
d114 2
a115 1
	{
d118 2
a119 1
		int option_size, ipproto;
d128 1
a128 1
			       &option_size) >= 0 && option_size != 0) {
d134 1
a134 1
			    inet_ntoa(from.sin_addr), text);
d136 1
a136 1
					  inet_ntoa(from.sin_addr), text);
a142 25
static char *canonical_host_name = NULL;
static char *canonical_host_ip = NULL;

/* Returns 1 if remote host is connected via socket, 0 if not. */

int
peer_connection_is_on_socket()
{
	struct sockaddr_in from;
	int fromlen;
	int in = packet_get_connection_in();
	int out = packet_get_connection_out();

	/* filedescriptors in and out are the same, so it's a socket */
	if (in == out)
		return 1;
	fromlen = sizeof(from);
	memset(&from, 0, sizeof(from));
	if (getpeername(in, (struct sockaddr *) & from, &fromlen) < 0)
		return 0;
	if (from.sin_family != AF_INET && from.sin_family != AF_INET6)
		return 0;
	return 1;
}

d152 2
d159 1
a159 1
	if (peer_connection_is_on_socket())
d169 1
a169 1
 * string need not be freed.
d175 5
a179 2
	struct sockaddr_in from;
	int fromlen, socket;
d186 1
a186 1
	if (!peer_connection_is_on_socket()) {
d201 5
a205 1
	canonical_host_ip = xstrdup(inet_ntoa(from.sin_addr));
d211 1
a211 1
/* Returns the port of the peer of the socket. */
d213 2
a214 2
int 
get_peer_port(int sock)
d216 3
a218 2
	struct sockaddr_in from;
	int fromlen;
d223 10
a232 3
	if (getpeername(sock, (struct sockaddr *) & from, &fromlen) < 0) {
		debug("getpeername failed: %.100s", strerror(errno));
		fatal_cleanup();
d235 4
a238 1
	return ntohs(from.sin_port);
d241 1
a241 1
/* Returns the port number of the remote host.  */
d244 1
a244 1
get_remote_port()
a245 2
	int socket;

d250 1
a250 1
	if (!peer_connection_is_on_socket())
d253 15
a267 2
	/* Get client socket. */
	socket = packet_get_connection_in();
d269 4
a272 2
	/* Get and return the peer port number. */
	return get_peer_port(socket);
@


1.8
log
@KNF, final part 3
@
text
@d17 1
a17 1
RCSID("$Id: canohost.c,v 1.7 1999/11/24 00:26:01 deraadt Exp $");
d146 22
d182 1
a182 1
	if (packet_get_connection_in() == packet_get_connection_out())
d206 1
a206 1
	if (packet_get_connection_in() != packet_get_connection_out()) {
d257 1
a257 1
	if (packet_get_connection_in() != packet_get_connection_out())
@


1.7
log
@much more KNF
@
text
@d17 1
a17 1
RCSID("$Id: canohost.c,v 1.6 1999/11/23 22:25:53 markus Exp $");
d23 4
a26 2
/* Return the canonical name of the host at the other end of the socket.
   The caller should free the returned string with xfree. */
d57 4
a60 2
		/* Convert it to all lowercase (which is expected by the
		   rest of this software). */
d65 9
a73 7
		/* Map it back to an IP address and check that the given
		   address actually is an address of this host.  This is
		   necessary because anyone with access to a name server
		   can define arbitrary names for an IP address. Mapping
		   from name to IP address can be trusted better (but can
		   still be fooled if the intruder has access to the name
		   server of the domain). */
d85 4
a88 2
		/* If we reached the end of the list, the address was not
		   there. */
d105 11
a115 10
	/* If IP options are supported, make sure there are none (log and
	   disconnect them if any are found).  Basically we are worried
	   about source routing; it can be used to pretend you are
	   somebody (ip-address) you are not. That itself may be "almost
	   acceptable" under certain circumstances, but rhosts
	   autentication is useless if source routing is accepted. Notice
	   also that if we just dropped source routing here, the other
	   side could use IP spoofing to do rest of the interaction and
	   could still bypass security.  So we exit here if we detect any
	   IP options. */
d146 5
a150 3
/* Return the canonical name of the host in the other side of the current
   connection.  The host name is cached, so it is efficient to call this
   several times. */
d168 4
a171 2
/* Returns the IP-address of the remote host as a string.  The returned
   string need not be freed. */
d179 1
a179 1
	/* Check if we have previously retrieved this same name. */
d231 4
a234 2
	/* If the connection is not a socket, return 65535.  This is
	   intentionally chosen to be an unprivileged port number. */
@


1.6
log
@KNF part 1
@
text
@d2 13
a14 13

canohost.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Sun Jul  2 17:52:22 1995 ylo

Functions for returning the canonical host name of the remote site.

*/
d17 1
a17 1
RCSID("$Id: canohost.c,v 1.5 1999/11/15 00:42:01 markus Exp $");
@


1.5
log
@disconnect if getpeername() fails
@
text
@d17 1
a17 1
RCSID("$Id: canohost.c,v 1.4 1999/11/14 22:30:58 markus Exp $");
d23 1
a23 1
/* Return the canonical name of the host at the other end of the socket. 
d26 2
a27 1
char *get_remote_hostname(int socket)
d29 78
a106 43
  struct sockaddr_in from;
  int fromlen, i;
  struct hostent *hp;
  char name[MAXHOSTNAMELEN];

  /* Get IP address of client. */
  fromlen = sizeof(from);
  memset(&from, 0, sizeof(from));
  if (getpeername(socket, (struct sockaddr *)&from, &fromlen) < 0)
    {
      debug("getpeername failed: %.100s", strerror(errno));
      fatal_cleanup();
    }
  
  /* Map the IP address to a host name. */
  hp = gethostbyaddr((char *)&from.sin_addr, sizeof(struct in_addr),
		     from.sin_family);
  if (hp)
    {
      /* Got host name, find canonic host name. */
      if (strchr(hp->h_name, '.') != 0)
	strlcpy(name, hp->h_name, sizeof(name));
      else if (hp->h_aliases != 0
	       && hp->h_aliases[0] != 0
	       && strchr(hp->h_aliases[0], '.') != 0)
	strlcpy(name, hp->h_aliases[0], sizeof(name));
      else
	strlcpy(name, hp->h_name, sizeof(name));
      
      /* Convert it to all lowercase (which is expected by the rest of this
	 software). */
      for (i = 0; name[i]; i++)
	if (isupper(name[i]))
	  name[i] = tolower(name[i]);

      /* Map it back to an IP address and check that the given address actually
	 is an address of this host.  This is necessary because anyone with
	 access to a name server can define arbitrary names for an IP address.
	 Mapping from name to IP address can be trusted better (but can still
	 be fooled if the intruder has access to the name server of the
	 domain). */
      hp = gethostbyname(name);
      if (!hp)
d108 22
a129 61
	  log("reverse mapping checking gethostbyname for %.700s failed - POSSIBLE BREAKIN ATTEMPT!", name);
	  strlcpy(name, inet_ntoa(from.sin_addr), sizeof name);
	  goto check_ip_options;
	}
      /* Look for the address from the list of addresses. */
      for (i = 0; hp->h_addr_list[i]; i++)
	if (memcmp(hp->h_addr_list[i], &from.sin_addr, sizeof(from.sin_addr))
	    == 0)
	  break;
      /* If we reached the end of the list, the address was not there. */
      if (!hp->h_addr_list[i])
	{
	  /* Address not found for the host name. */
	  log("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
	      inet_ntoa(from.sin_addr), name);
	  strlcpy(name, inet_ntoa(from.sin_addr), sizeof name);
	  goto check_ip_options;
	}
      /* Address was found for the host name.  We accept the host name. */
    }
  else
    {
      /* Host name not found.  Use ascii representation of the address. */
      strlcpy(name, inet_ntoa(from.sin_addr), sizeof name);
      log("Could not reverse map address %.100s.", name);
    }

 check_ip_options:
  
  /* If IP options are supported, make sure there are none (log and disconnect
     them if any are found).  Basically we are worried about source routing;
     it can be used to pretend you are somebody (ip-address) you are not.
     That itself may be "almost acceptable" under certain circumstances,
     but rhosts autentication is useless if source routing is accepted.
     Notice also that if we just dropped source routing here, the other
     side could use IP spoofing to do rest of the interaction and could still
     bypass security.  So we exit here if we detect any IP options. */
  {
    unsigned char options[200], *ucp;
    char text[1024], *cp;
    int option_size, ipproto;
    struct protoent *ip;
    
    if ((ip = getprotobyname("ip")) != NULL)
      ipproto = ip->p_proto;
    else
      ipproto = IPPROTO_IP;
    option_size = sizeof(options);
    if (getsockopt(0, ipproto, IP_OPTIONS, (char *)options,
		   &option_size) >= 0 && option_size != 0)
      {
	cp = text;
	/* Note: "text" buffer must be at least 3x as big as options. */
	for (ucp = options; option_size > 0; ucp++, option_size--, cp += 3)
	  sprintf(cp, " %2.2x", *ucp);
	log("Connection from %.100s with IP options:%.800s",
	    inet_ntoa(from.sin_addr), text);
	packet_disconnect("Connection from %.100s with IP options:%.800s", 
			  inet_ntoa(from.sin_addr), text);
      }
  }
d131 1
a131 1
  return xstrdup(name);
d138 1
a138 1
   connection.  The host name is cached, so it is efficient to call this 
d141 2
a142 1
const char *get_canonical_hostname()
d144 9
a152 9
  /* Check if we have previously retrieved this same name. */
  if (canonical_host_name != NULL)
    return canonical_host_name;

  /* Get the real hostname if socket; otherwise return UNKNOWN. */
  if (packet_get_connection_in() == packet_get_connection_out())
    canonical_host_name = get_remote_hostname(packet_get_connection_in());
  else
    canonical_host_name = xstrdup("UNKNOWN");
d154 1
a154 1
  return canonical_host_name;
d160 2
a161 1
const char *get_remote_ipaddr()
d163 2
a164 2
  struct sockaddr_in from;
  int fromlen, socket;
d166 11
a176 22
  /* Check if we have previously retrieved this same name. */
  if (canonical_host_ip != NULL)
    return canonical_host_ip;

  /* If not a socket, return UNKNOWN. */
  if (packet_get_connection_in() != packet_get_connection_out())
    {
      canonical_host_ip = xstrdup("UNKNOWN");
      return canonical_host_ip;
    }

  /* Get client socket. */
  socket = packet_get_connection_in();

  /* Get IP address of client. */
  fromlen = sizeof(from);
  memset(&from, 0, sizeof(from));
  if (getpeername(socket, (struct sockaddr *)&from, &fromlen) < 0)
    {
      debug("getpeername failed: %.100s", strerror(errno));
      fatal_cleanup();
    }
d178 9
a186 2
  /* Get the IP address in ascii. */
  canonical_host_ip = xstrdup(inet_ntoa(from.sin_addr));
d188 2
a189 2
  /* Return ip address string. */
  return canonical_host_ip;
d194 2
a195 1
int get_peer_port(int sock)
d197 2
a198 2
  struct sockaddr_in from;
  int fromlen;
d200 9
a208 11
  /* Get IP address of client. */
  fromlen = sizeof(from);
  memset(&from, 0, sizeof(from));
  if (getpeername(sock, (struct sockaddr *)&from, &fromlen) < 0)
    {
      debug("getpeername failed: %.100s", strerror(errno));
      fatal_cleanup();
    }

  /* Return port number. */
  return ntohs(from.sin_port);
d213 2
a214 1
int get_remote_port()
d216 1
a216 1
  int socket;
d218 4
a221 4
  /* If the connection is not a socket, return 65535.  This is intentionally
     chosen to be an unprivileged port number. */
  if (packet_get_connection_in() != packet_get_connection_out())
    return 65535;
d223 2
a224 2
  /* Get client socket. */
  socket = packet_get_connection_in();
d226 2
a227 2
  /* Get and return the peer port number. */
  return get_peer_port(socket);
@


1.4
log
@fix comment: we _do_ disconnect if ip-options are set
@
text
@d17 1
a17 1
RCSID("$Id: canohost.c,v 1.3 1999/09/30 05:53:04 deraadt Exp $");
d38 2
a39 3
      error("getpeername failed: %.100s", strerror(errno));
      strlcpy(name, "UNKNOWN", sizeof name);
      goto check_ip_options;
d186 2
a187 2
      error("getpeername failed: %.100s", strerror(errno));
      return NULL;
d209 2
a210 2
      error("getpeername failed: %.100s", strerror(errno));
      return 0;
@


1.3
log
@"ssh is a very large program" -- anonymous
@
text
@d17 1
a17 1
RCSID("$Id: canohost.c,v 1.2 1999/09/29 21:14:16 deraadt Exp $");
d102 1
a102 1
  /* If IP options are supported, make sure there are none (log and clear
@


1.2
log
@numerous sprintf, strncpy, strcpy cleanups
@
text
@d17 1
a17 1
RCSID("$Id: canohost.c,v 1.1 1999/09/26 20:53:34 deraadt Exp $");
a101 1
#ifdef IP_OPTIONS
a133 1
#endif
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d17 1
a17 1
RCSID("$Id: canohost.c,v 1.3 1999/05/11 19:27:15 bg Exp $");
d31 1
a31 1
  char name[512];
d39 1
a39 1
      strcpy(name, "UNKNOWN");
d50 1
a50 1
	strncpy(name, hp->h_name, sizeof(name));
d54 1
a54 1
	strncpy(name, hp->h_aliases[0], sizeof(name));
d56 1
a56 2
	strncpy(name, hp->h_name, sizeof(name));
      name[sizeof(name) - 1] = '\0';
d74 1
a74 1
	  strcpy(name, inet_ntoa(from.sin_addr));
d88 1
a88 1
	  strcpy(name, inet_ntoa(from.sin_addr));
d96 1
a96 1
      strcpy(name, inet_ntoa(from.sin_addr));
@

