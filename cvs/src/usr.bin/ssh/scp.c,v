head	1.192;
access;
symbols
	OPENBSD_6_1:1.187.0.4
	OPENBSD_6_1_BASE:1.187
	OPENBSD_6_0:1.186.0.4
	OPENBSD_6_0_BASE:1.186
	OPENBSD_5_9:1.184.0.2
	OPENBSD_5_9_BASE:1.184
	OPENBSD_5_8:1.182.0.2
	OPENBSD_5_8_BASE:1.182
	OPENBSD_5_7:1.181.0.2
	OPENBSD_5_7_BASE:1.181
	OPENBSD_5_6:1.180.0.4
	OPENBSD_5_6_BASE:1.180
	OPENBSD_5_5:1.179.0.4
	OPENBSD_5_5_BASE:1.179
	OPENBSD_5_4:1.178.0.2
	OPENBSD_5_4_BASE:1.178
	OPENBSD_5_3:1.171.0.6
	OPENBSD_5_3_BASE:1.171
	OPENBSD_5_2:1.171.0.4
	OPENBSD_5_2_BASE:1.171
	OPENBSD_5_1_BASE:1.171
	OPENBSD_5_1:1.171.0.2
	OPENBSD_5_0:1.170.0.4
	OPENBSD_5_0_BASE:1.170
	OPENBSD_4_9:1.170.0.2
	OPENBSD_4_9_BASE:1.170
	OPENBSD_4_8:1.166.0.2
	OPENBSD_4_8_BASE:1.166
	OPENBSD_4_7:1.165.0.2
	OPENBSD_4_7_BASE:1.165
	OPENBSD_4_6:1.164.0.6
	OPENBSD_4_6_BASE:1.164
	OPENBSD_4_5:1.164.0.2
	OPENBSD_4_5_BASE:1.164
	OPENBSD_4_4:1.163.0.2
	OPENBSD_4_4_BASE:1.163
	OPENBSD_4_3:1.162.0.2
	OPENBSD_4_3_BASE:1.162
	OPENBSD_4_2:1.160.0.2
	OPENBSD_4_2_BASE:1.160
	OPENBSD_4_1:1.156.0.2
	OPENBSD_4_1_BASE:1.156
	OPENBSD_4_0:1.155.0.4
	OPENBSD_4_0_BASE:1.155
	OPENBSD_3_9:1.135.0.2
	OPENBSD_3_9_BASE:1.135
	OPENBSD_3_8:1.125.0.2
	OPENBSD_3_8_BASE:1.125
	OPENBSD_3_7:1.119.0.2
	OPENBSD_3_7_BASE:1.119
	OPENBSD_3_6:1.117.0.2
	OPENBSD_3_6_BASE:1.117
	OPENBSD_3_5:1.113.0.2
	OPENBSD_3_5_BASE:1.113
	OPENBSD_3_4:1.108.0.2
	OPENBSD_3_4_BASE:1.108
	OPENBSD_3_3:1.102.0.2
	OPENBSD_3_3_BASE:1.102
	OPENBSD_3_2:1.91.0.2
	OPENBSD_3_2_BASE:1.91
	OPENBSD_3_1:1.88.0.2
	OPENBSD_3_1_BASE:1.88
	OPENBSD_3_0:1.85.0.2
	OPENBSD_3_0_BASE:1.85
	OPENBSD_2_9_BASE:1.68
	OPENBSD_2_9:1.68.0.2
	OPENBSD_2_8:1.43.0.2
	OPENBSD_2_8_BASE:1.43
	OPENBSD_2_7:1.30.0.2
	OPENBSD_2_7_BASE:1.30
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13;
locks; strict;
comment	@ * @;


1.192
date	2017.05.31.09.15.42;	author deraadt;	state Exp;
branches;
next	1.191;
commitid	zCd5GrUCVAe14Y6J;

1.191
date	2017.05.02.08.06.33;	author jmc;	state Exp;
branches;
next	1.190;
commitid	qURwlJu4au9KmbXC;

1.190
date	2017.04.30.23.28.12;	author djm;	state Exp;
branches;
next	1.189;
commitid	j8T9GfcAdHo0Finy;

1.189
date	2017.04.28.03.21.12;	author millert;	state Exp;
branches;
next	1.188;
commitid	2gyzOrxlxZsiHudR;

1.188
date	2017.04.27.11.53.12;	author millert;	state Exp;
branches;
next	1.187;
commitid	Ebg82NF7C47RVI9q;

1.187
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.186;
commitid	ZllbGwdb0fOmLhjK;

1.186
date	2016.05.25.23.48.45;	author schwarze;	state Exp;
branches;
next	1.185;
commitid	NPBJoBfuBDOIqIQi;

1.185
date	2016.03.02.22.43.52;	author dtucker;	state Exp;
branches;
next	1.184;
commitid	wqYf5zan6EQitBeU;

1.184
date	2015.11.27.00.49.31;	author deraadt;	state Exp;
branches;
next	1.183;
commitid	yl0kekbrT5lfTZ7n;

1.183
date	2015.10.16.17.07.24;	author mmcc;	state Exp;
branches;
next	1.182;
commitid	zMsPEJLku25wamrQ;

1.182
date	2015.04.24.01.36.00;	author deraadt;	state Exp;
branches;
next	1.181;
commitid	LHkUmZjv49ojnnuH;

1.181
date	2015.01.16.06.40.12;	author deraadt;	state Exp;
branches;
next	1.180;
commitid	Uu5nFG3wCl0LACBb;

1.180
date	2014.06.24.02.21.01;	author djm;	state Exp;
branches;
next	1.179;
commitid	nRXBVqLL864uvXM3;

1.179
date	2013.11.20.20.53.10;	author deraadt;	state Exp;
branches;
next	1.178;

1.178
date	2013.06.22.06.31.57;	author djm;	state Exp;
branches;
next	1.177;

1.177
date	2013.06.21.05.43.10;	author djm;	state Exp;
branches;
next	1.176;

1.176
date	2013.06.17.04.48.42;	author guenther;	state Exp;
branches;
next	1.175;

1.175
date	2013.06.04.19.12.23;	author dtucker;	state Exp;
branches;
next	1.174;

1.174
date	2013.06.01.20.59.25;	author dtucker;	state Exp;
branches;
next	1.173;

1.173
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.172;

1.172
date	2013.05.16.09.08.41;	author dtucker;	state Exp;
branches;
next	1.171;

1.171
date	2011.09.09.22.37.01;	author djm;	state Exp;
branches;
next	1.170;

1.170
date	2010.12.09.14.13.33;	author jmc;	state Exp;
branches;
next	1.169;

1.169
date	2010.12.08.22.46.03;	author markus;	state Exp;
branches;
next	1.168;

1.168
date	2010.11.26.05.52.49;	author djm;	state Exp;
branches;
next	1.167;

1.167
date	2010.09.22.22.58.51;	author djm;	state Exp;
branches;
next	1.166;

1.166
date	2010.07.01.13.06.59;	author millert;	state Exp;
branches;
next	1.165;

1.165
date	2009.12.20.07.28.36;	author guenther;	state Exp;
branches;
next	1.164;

1.164
date	2008.10.10.04.55.16;	author stevesk;	state Exp;
branches;
next	1.163;

1.163
date	2008.06.13.18.55.22;	author dtucker;	state Exp;
branches;
next	1.162;

1.162
date	2008.01.01.09.06.39;	author dtucker;	state Exp;
branches;
next	1.161;

1.161
date	2007.10.24.03.44.02;	author djm;	state Exp;
branches;
next	1.160;

1.160
date	2007.08.06.19.16.06;	author sobrado;	state Exp;
branches;
next	1.159;

1.159
date	2007.06.13.00.21.27;	author djm;	state Exp;
branches;
next	1.158;

1.158
date	2007.06.12.13.54.28;	author dtucker;	state Exp;
branches;
next	1.157;

1.157
date	2007.06.12.08.24.20;	author djm;	state Exp;
branches;
next	1.156;

1.156
date	2007.01.22.13.06.21;	author djm;	state Exp;
branches;
next	1.155;

1.155
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.154;

1.154
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.153;

1.153
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.152;

1.152
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.151;

1.151
date	2006.07.25.02.59.21;	author stevesk;	state Exp;
branches;
next	1.150;

1.150
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.149;

1.149
date	2006.07.22.19.08.54;	author stevesk;	state Exp;
branches;
next	1.148;

1.148
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.147;

1.147
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.146;

1.146
date	2006.07.10.16.37.36;	author stevesk;	state Exp;
branches;
next	1.145;

1.145
date	2006.07.10.12.03.20;	author djm;	state Exp;
branches;
next	1.144;

1.144
date	2006.07.09.15.15.10;	author stevesk;	state Exp;
branches;
next	1.143;

1.143
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.142;

1.142
date	2006.05.17.12.43.34;	author markus;	state Exp;
branches;
next	1.141;

1.141
date	2006.04.01.05.50.29;	author djm;	state Exp;
branches;
next	1.140;

1.140
date	2006.04.01.05.42.20;	author deraadt;	state Exp;
branches;
next	1.139;

1.139
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.138;

1.138
date	2006.03.25.01.13.23;	author djm;	state Exp;
branches;
next	1.137;

1.137
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.136;

1.136
date	2006.03.16.10.31.45;	author biorn;	state Exp;
branches;
next	1.135;

1.135
date	2006.02.22.00.04.44;	author stevesk;	state Exp;
branches
	1.135.2.1;
next	1.134;

1.134
date	2006.02.20.17.19.54;	author stevesk;	state Exp;
branches;
next	1.133;

1.133
date	2006.02.20.17.02.44;	author stevesk;	state Exp;
branches;
next	1.132;

1.132
date	2006.02.10.01.44.26;	author stevesk;	state Exp;
branches;
next	1.131;

1.131
date	2006.02.08.23.51.24;	author stevesk;	state Exp;
branches;
next	1.130;

1.130
date	2006.01.31.10.35.43;	author djm;	state Exp;
branches;
next	1.129;

1.129
date	2006.01.31.10.19.02;	author djm;	state Exp;
branches;
next	1.128;

1.128
date	2005.12.06.22.38.27;	author reyk;	state Exp;
branches;
next	1.127;

1.127
date	2005.11.12.18.38.15;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2005.09.13.23.40.07;	author djm;	state Exp;
branches;
next	1.125;

1.125
date	2005.07.27.10.39.03;	author dtucker;	state Exp;
branches
	1.125.2.1;
next	1.124;

1.124
date	2005.06.17.02.44.33;	author djm;	state Exp;
branches;
next	1.123;

1.123
date	2005.05.26.02.08.05;	author avsm;	state Exp;
branches;
next	1.122;

1.122
date	2005.05.24.17.32.43;	author avsm;	state Exp;
branches;
next	1.121;

1.121
date	2005.04.02.12.41.16;	author djm;	state Exp;
branches;
next	1.120;

1.120
date	2005.03.31.18.39.21;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2005.01.24.10.22.06;	author dtucker;	state Exp;
branches
	1.119.2.1;
next	1.118;

1.118
date	2004.09.15.18.46.04;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2004.08.11.21.44.32;	author avsm;	state Exp;
branches
	1.117.2.1;
next	1.116;

1.116
date	2004.07.08.12.47.21;	author dtucker;	state Exp;
branches;
next	1.115;

1.115
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches;
next	1.114;

1.114
date	2004.04.01.12.19.57;	author markus;	state Exp;
branches;
next	1.113;

1.113
date	2003.11.23.23.21.21;	author djm;	state Exp;
branches
	1.113.2.1;
next	1.112;

1.112
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches;
next	1.111;

1.111
date	2003.11.12.10.12.15;	author dtucker;	state Exp;
branches;
next	1.110;

1.110
date	2003.10.08.08.27.36;	author jmc;	state Exp;
branches;
next	1.109;

1.109
date	2003.09.19.17.40.20;	author markus;	state Exp;
branches;
next	1.108;

1.108
date	2003.07.18.01.54.25;	author deraadt;	state Exp;
branches
	1.108.2.1;
next	1.107;

1.107
date	2003.06.28.16.23.06;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2003.06.12.15.34.09;	author nino;	state Exp;
branches;
next	1.105;

1.105
date	2003.06.04.12.40.39;	author djm;	state Exp;
branches;
next	1.104;

1.104
date	2003.06.04.12.18.49;	author djm;	state Exp;
branches;
next	1.103;

1.103
date	2003.06.03.02.56.16;	author millert;	state Exp;
branches;
next	1.102;

1.102
date	2003.03.05.22.33.43;	author markus;	state Exp;
branches
	1.102.2.1;
next	1.101;

1.101
date	2003.02.02.10.51.13;	author markus;	state Exp;
branches;
next	1.100;

1.100
date	2003.01.23.14.06.15;	author markus;	state Exp;
branches;
next	1.99;

1.99
date	2003.01.23.14.01.53;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2003.01.10.10.29.35;	author djm;	state Exp;
branches;
next	1.97;

1.97
date	2003.01.10.08.19.07;	author fgsch;	state Exp;
branches;
next	1.96;

1.96
date	2002.12.13.15.20.52;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2002.12.05.11.08.35;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2002.11.27.17.53.35;	author markus;	state Exp;
branches;
next	1.93;

1.93
date	2002.11.26.00.45.03;	author wcobb;	state Exp;
branches;
next	1.92;

1.92
date	2002.11.07.22.35.38;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches
	1.91.2.1;
next	1.90;

1.90
date	2002.06.17.06.05.56;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2002.06.08.12.36.53;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2002.04.06.18.24.09;	author mouring;	state Exp;
branches
	1.88.2.1;
next	1.87;

1.87
date	2002.03.30.17.45.46;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2001.12.05.03.56.39;	author itojun;	state Exp;
branches;
next	1.85;

1.85
date	2001.10.01.08.06.28;	author markus;	state Exp;
branches
	1.85.2.1;
next	1.84;

1.84
date	2001.09.19.19.24.19;	author stevesk;	state Exp;
branches;
next	1.83;

1.83
date	2001.09.17.17.57.56;	author stevesk;	state Exp;
branches;
next	1.82;

1.82
date	2001.09.12.18.18.25;	author stevesk;	state Exp;
branches;
next	1.81;

1.81
date	2001.08.29.20.44.03;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2001.08.13.23.38.54;	author stevesk;	state Exp;
branches;
next	1.79;

1.79
date	2001.08.06.19.47.05;	author stevesk;	state Exp;
branches;
next	1.78;

1.78
date	2001.07.27.17.26.16;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2001.07.18.16.45.52;	author mouring;	state Exp;
branches;
next	1.76;

1.76
date	2001.06.23.15.12.19;	author itojun;	state Exp;
branches;
next	1.75;

1.75
date	2001.06.23.00.16.16;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2001.06.16.08.57.35;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	2001.06.10.11.33.02;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2001.06.03.19.38.42;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2001.05.19.16.05.41;	author markus;	state Exp;
branches;
next	1.70;

1.70
date	2001.05.08.19.45.24;	author mouring;	state Exp;
branches;
next	1.69;

1.69
date	2001.05.03.23.09.53;	author mouring;	state Exp;
branches;
next	1.68;

1.68
date	2001.04.22.12.34.05;	author markus;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2001.04.16.02.31.43;	author mouring;	state Exp;
branches;
next	1.66;

1.66
date	2001.04.14.17.04.42;	author stevesk;	state Exp;
branches;
next	1.65;

1.65
date	2001.04.06.16.46.59;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2001.03.28.20.04.38;	author stevesk;	state Exp;
branches;
next	1.63;

1.63
date	2001.03.28.19.56.23;	author stevesk;	state Exp;
branches;
next	1.62;

1.62
date	2001.03.21.12.33.33;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2001.03.15.15.05.59;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2001.03.02.18.54.31;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2001.02.19.10.36.25;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2001.02.10.15.14.11;	author danh;	state Exp;
branches;
next	1.57;

1.57
date	2001.02.10.00.12.43;	author danh;	state Exp;
branches;
next	1.56;

1.56
date	2001.02.08.19.30.52;	author itojun;	state Exp;
branches;
next	1.55;

1.55
date	2001.02.08.14.38.54;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2001.02.07.18.01.17;	author itojun;	state Exp;
branches;
next	1.53;

1.53
date	2001.02.04.23.56.22;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2001.02.04.15.32.24;	author stevesk;	state Exp;
branches;
next	1.51;

1.51
date	2001.01.21.19.05.55;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2001.01.19.15.55.11;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2001.01.13.18.03.07;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2001.01.01.14.52.49;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2000.12.19.23.17.57;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2000.12.16.09.53.57;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2000.12.16.09.39.57;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2000.12.11.17.27.33;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2000.10.18.18.23.02;	author markus;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2000.10.14.10.07.21;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2000.10.11.20.03.27;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2000.09.21.11.11.42;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2000.09.07.20.53.00;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2000.09.07.20.27.53;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2000.09.01.15.25.13;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2000.08.24.21.46.59;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2000.08.19.02.50.07;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2000.08.19.02.26.08;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2000.07.13.23.19.31;	author provos;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.20.01.39.44;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.18.03.16.09;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2000.05.02.18.21.48;	author deraadt;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2000.05.01.07.05.08;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.16.04.47.43;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.14.10.30.32;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.16.20.56.14;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2000.01.24.22.11.20;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2000.01.04.16.57.16;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2000.01.04.00.07.59;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	99.12.06.20.15.28;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	99.11.24.20.26.35;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	99.11.24.19.53.50;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	99.11.24.00.26.03;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	99.11.23.22.25.54;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	99.11.22.21.02.38;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	99.11.17.09.20.17;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.11.12.17.10.51;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	99.10.27.02.14.38;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	99.10.08.01.25.20;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	99.10.05.12.17.05;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	99.10.05.10.58.37;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	99.10.04.01.59.56;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.10.03.20.43.12;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.10.02.19.18.22;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.10.02.18.33.56;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.09.30.21.25.03;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	99.09.30.05.11.29;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.09.30.01.21.41;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.21.15.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.18.16.20;	author dugsong;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.37;	author deraadt;	state Exp;
branches;
next	;

1.30.2.1
date	2000.09.01.18.23.22;	author jason;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2000.11.08.21.31.12;	author jason;	state Exp;
branches;
next	1.30.2.3;

1.30.2.3
date	2001.03.12.15.44.13;	author jason;	state Exp;
branches;
next	1.30.2.4;

1.30.2.4
date	2001.03.21.18.53.00;	author jason;	state Exp;
branches;
next	;

1.43.2.1
date	2001.02.16.20.13.12;	author jason;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	2001.02.19.17.19.17;	author jason;	state Exp;
branches;
next	1.43.2.3;

1.43.2.3
date	2001.03.21.19.46.28;	author jason;	state Exp;
branches;
next	1.43.2.4;

1.43.2.4
date	2001.05.07.21.09.33;	author jason;	state Exp;
branches;
next	1.43.2.5;

1.43.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.43.2.6;

1.43.2.6
date	2001.11.15.00.14.59;	author miod;	state Exp;
branches;
next	1.43.2.7;

1.43.2.7
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.68.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.68.2.2;

1.68.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.68.2.3;

1.68.2.3
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.68.2.4;

1.68.2.4
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.85.2.1
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.85.2.2;

1.85.2.2
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.85.2.3;

1.85.2.3
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	;

1.88.2.1
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.88.2.2;

1.88.2.2
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.91.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.91.2.2;

1.91.2.2
date	2003.09.16.21.20.27;	author brad;	state Exp;
branches;
next	;

1.102.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.102.2.2;

1.102.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.108.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.108.2.2;

1.108.2.2
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.113.2.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	1.113.2.2;

1.113.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.117.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.117.2.2;

1.117.2.2
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.119.2.1
date	2005.09.04.18.40.03;	author brad;	state Exp;
branches;
next	1.119.2.2;

1.119.2.2
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.125.2.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.125.2.2;

1.125.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	;

1.135.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	;


desc
@@


1.192
log
@Switch to recallocarray() for a few operations.  Both growth and shrinkage
are handled safely, and there also is no need for preallocation dances.
Future changes in this area will be less error prone.
Review and one bug found by markus
@
text
@/* $OpenBSD: scp.c,v 1.191 2017/05/02 08:06:33 jmc Exp $ */
/*
 * scp - secure remote copy.  This is basically patched BSD rcp which
 * uses ssh to do the data transfer (instead of using rcmd).
 *
 * NOTE: This version should NOT be suid root.  (This uses ssh to
 * do the transfer and ssh has the necessary privileges.)
 *
 * 1995 Timo Rinne <tri@@iki.fi>, Tatu Ylonen <ylo@@cs.hut.fi>
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */
/*
 * Copyright (c) 1999 Theo de Raadt.  All rights reserved.
 * Copyright (c) 1999 Aaron Campbell.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Parts from:
 *
 * Copyright (c) 1983, 1990, 1992, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/poll.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/uio.h>

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <locale.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>
#include <vis.h>

#include "xmalloc.h"
#include "atomicio.h"
#include "pathnames.h"
#include "log.h"
#include "misc.h"
#include "progressmeter.h"
#include "utf8.h"

#define COPY_BUFLEN	16384

int do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout);
int do_cmd2(char *host, char *remuser, char *cmd, int fdin, int fdout);

/* Struct for addargs */
arglist args;
arglist remote_remote_args;

/* Bandwidth limit */
long long limit_kbps = 0;
struct bwlimit bwlimit;

/* Name of current file being transferred. */
char *curfile;

/* This is set to non-zero to enable verbose mode. */
int verbose_mode = 0;

/* This is set to zero if the progressmeter is not desired. */
int showprogress = 1;

/*
 * This is set to non-zero if remote-remote copy should be piped
 * through this process.
 */
int throughlocal = 0;

/* This is the program to execute for the secured connection. ("ssh" or -S) */
char *ssh_program = _PATH_SSH_PROGRAM;

/* This is used to store the pid of ssh_program */
pid_t do_cmd_pid = -1;

static void
killchild(int signo)
{
	if (do_cmd_pid > 1) {
		kill(do_cmd_pid, signo ? signo : SIGTERM);
		waitpid(do_cmd_pid, NULL, 0);
	}

	if (signo)
		_exit(1);
	exit(1);
}

static void
suspchild(int signo)
{
	int status;

	if (do_cmd_pid > 1) {
		kill(do_cmd_pid, signo);
		while (waitpid(do_cmd_pid, &status, WUNTRACED) == -1 &&
		    errno == EINTR)
			;
		kill(getpid(), SIGSTOP);
	}
}

static int
do_local_cmd(arglist *a)
{
	u_int i;
	int status;
	pid_t pid;

	if (a->num == 0)
		fatal("do_local_cmd: no arguments");

	if (verbose_mode) {
		fprintf(stderr, "Executing:");
		for (i = 0; i < a->num; i++)
			fmprintf(stderr, " %s", a->list[i]);
		fprintf(stderr, "\n");
	}
	if ((pid = fork()) == -1)
		fatal("do_local_cmd: fork: %s", strerror(errno));

	if (pid == 0) {
		execvp(a->list[0], a->list);
		perror(a->list[0]);
		exit(1);
	}

	do_cmd_pid = pid;
	signal(SIGTERM, killchild);
	signal(SIGINT, killchild);
	signal(SIGHUP, killchild);

	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("do_local_cmd: waitpid: %s", strerror(errno));

	do_cmd_pid = -1;

	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
		return (-1);

	return (0);
}

/*
 * This function executes the given command as the specified user on the
 * given host.  This returns < 0 if execution fails, and >= 0 otherwise. This
 * assigns the input and output file descriptors on success.
 */

int
do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout)
{
	int pin[2], pout[2], reserved[2];

	if (verbose_mode)
		fmprintf(stderr,
		    "Executing: program %s host %s, user %s, command %s\n",
		    ssh_program, host,
		    remuser ? remuser : "(unspecified)", cmd);

	/*
	 * Reserve two descriptors so that the real pipes won't get
	 * descriptors 0 and 1 because that will screw up dup2 below.
	 */
	if (pipe(reserved) < 0)
		fatal("pipe: %s", strerror(errno));

	/* Create a socket pair for communicating with ssh. */
	if (pipe(pin) < 0)
		fatal("pipe: %s", strerror(errno));
	if (pipe(pout) < 0)
		fatal("pipe: %s", strerror(errno));

	/* Free the reserved descriptors. */
	close(reserved[0]);
	close(reserved[1]);

	signal(SIGTSTP, suspchild);
	signal(SIGTTIN, suspchild);
	signal(SIGTTOU, suspchild);

	/* Fork a child to execute the command on the remote host using ssh. */
	do_cmd_pid = fork();
	if (do_cmd_pid == 0) {
		/* Child. */
		close(pin[1]);
		close(pout[0]);
		dup2(pin[0], 0);
		dup2(pout[1], 1);
		close(pin[0]);
		close(pout[1]);

		replacearg(&args, 0, "%s", ssh_program);
		if (remuser != NULL) {
			addargs(&args, "-l");
			addargs(&args, "%s", remuser);
		}
		addargs(&args, "--");
		addargs(&args, "%s", host);
		addargs(&args, "%s", cmd);

		execvp(ssh_program, args.list);
		perror(ssh_program);
		exit(1);
	} else if (do_cmd_pid == -1) {
		fatal("fork: %s", strerror(errno));
	}
	/* Parent.  Close the other side, and return the local side. */
	close(pin[0]);
	*fdout = pin[1];
	close(pout[1]);
	*fdin = pout[0];
	signal(SIGTERM, killchild);
	signal(SIGINT, killchild);
	signal(SIGHUP, killchild);
	return 0;
}

/*
 * This functions executes a command simlar to do_cmd(), but expects the
 * input and output descriptors to be setup by a previous call to do_cmd().
 * This way the input and output of two commands can be connected.
 */
int
do_cmd2(char *host, char *remuser, char *cmd, int fdin, int fdout)
{
	pid_t pid;
	int status;

	if (verbose_mode)
		fmprintf(stderr,
		    "Executing: 2nd program %s host %s, user %s, command %s\n",
		    ssh_program, host,
		    remuser ? remuser : "(unspecified)", cmd);

	/* Fork a child to execute the command on the remote host using ssh. */
	pid = fork();
	if (pid == 0) {
		dup2(fdin, 0);
		dup2(fdout, 1);

		replacearg(&args, 0, "%s", ssh_program);
		if (remuser != NULL) {
			addargs(&args, "-l");
			addargs(&args, "%s", remuser);
		}
		addargs(&args, "--");
		addargs(&args, "%s", host);
		addargs(&args, "%s", cmd);

		execvp(ssh_program, args.list);
		perror(ssh_program);
		exit(1);
	} else if (pid == -1) {
		fatal("fork: %s", strerror(errno));
	}
	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("do_cmd2: waitpid: %s", strerror(errno));
	return 0;
}

typedef struct {
	size_t cnt;
	char *buf;
} BUF;

BUF *allocbuf(BUF *, int, int);
void lostconn(int);
int okname(char *);
void run_err(const char *,...);
void verifydir(char *);

struct passwd *pwd;
uid_t userid;
int errs, remin, remout;
int pflag, iamremote, iamrecursive, targetshouldbedirectory;

#define	CMDNEEDS	64
char cmd[CMDNEEDS];		/* must hold "rcp -r -p -d\0" */

int response(void);
void rsource(char *, struct stat *);
void sink(int, char *[]);
void source(int, char *[]);
void tolocal(int, char *[]);
void toremote(char *, int, char *[]);
void usage(void);

int
main(int argc, char **argv)
{
	int ch, fflag, tflag, status, n;
	char *targ, **newargv;
	const char *errstr;
	extern char *optarg;
	extern int optind;

	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	setlocale(LC_CTYPE, "");

	/* Copy argv, because we modify it */
	newargv = xcalloc(MAXIMUM(argc + 1, 1), sizeof(*newargv));
	for (n = 0; n < argc; n++)
		newargv[n] = xstrdup(argv[n]);
	argv = newargv;

	memset(&args, '\0', sizeof(args));
	memset(&remote_remote_args, '\0', sizeof(remote_remote_args));
	args.list = remote_remote_args.list = NULL;
	addargs(&args, "%s", ssh_program);
	addargs(&args, "-x");
	addargs(&args, "-oForwardAgent=no");
	addargs(&args, "-oPermitLocalCommand=no");
	addargs(&args, "-oClearAllForwardings=yes");

	fflag = tflag = 0;
	while ((ch = getopt(argc, argv, "dfl:prtvBCc:i:P:q12346S:o:F:")) != -1)
		switch (ch) {
		/* User-visible flags. */
		case '1':
			fatal("SSH protocol v.1 is no longer supported");
			break;
		case '2':
			/* Ignored */
			break;
		case '4':
		case '6':
		case 'C':
			addargs(&args, "-%c", ch);
			addargs(&remote_remote_args, "-%c", ch);
			break;
		case '3':
			throughlocal = 1;
			break;
		case 'o':
		case 'c':
		case 'i':
		case 'F':
			addargs(&remote_remote_args, "-%c", ch);
			addargs(&remote_remote_args, "%s", optarg);
			addargs(&args, "-%c", ch);
			addargs(&args, "%s", optarg);
			break;
		case 'P':
			addargs(&remote_remote_args, "-p");
			addargs(&remote_remote_args, "%s", optarg);
			addargs(&args, "-p");
			addargs(&args, "%s", optarg);
			break;
		case 'B':
			addargs(&remote_remote_args, "-oBatchmode=yes");
			addargs(&args, "-oBatchmode=yes");
			break;
		case 'l':
			limit_kbps = strtonum(optarg, 1, 100 * 1024 * 1024,
			    &errstr);
			if (errstr != NULL)
				usage();
			limit_kbps *= 1024; /* kbps */
			bandwidth_limit_init(&bwlimit, limit_kbps, COPY_BUFLEN);
			break;
		case 'p':
			pflag = 1;
			break;
		case 'r':
			iamrecursive = 1;
			break;
		case 'S':
			ssh_program = xstrdup(optarg);
			break;
		case 'v':
			addargs(&args, "-v");
			addargs(&remote_remote_args, "-v");
			verbose_mode = 1;
			break;
		case 'q':
			addargs(&args, "-q");
			addargs(&remote_remote_args, "-q");
			showprogress = 0;
			break;

		/* Server options. */
		case 'd':
			targetshouldbedirectory = 1;
			break;
		case 'f':	/* "from" */
			iamremote = 1;
			fflag = 1;
			break;
		case 't':	/* "to" */
			iamremote = 1;
			tflag = 1;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if ((pwd = getpwuid(userid = getuid())) == NULL)
		fatal("unknown user %u", (u_int) userid);

	if (!isatty(STDOUT_FILENO))
		showprogress = 0;

	if (pflag) {
		/* Cannot pledge: -p allows setuid/setgid files... */
	} else {
		if (pledge("stdio rpath wpath cpath fattr tty proc exec",
		    NULL) == -1) {
			perror("pledge");
			exit(1);
		}
	}

	remin = STDIN_FILENO;
	remout = STDOUT_FILENO;

	if (fflag) {
		/* Follow "protocol", send data. */
		(void) response();
		source(argc, argv);
		exit(errs != 0);
	}
	if (tflag) {
		/* Receive data. */
		sink(argc, argv);
		exit(errs != 0);
	}
	if (argc < 2)
		usage();
	if (argc > 2)
		targetshouldbedirectory = 1;

	remin = remout = -1;
	do_cmd_pid = -1;
	/* Command to be executed on remote system using "ssh". */
	(void) snprintf(cmd, sizeof cmd, "scp%s%s%s%s",
	    verbose_mode ? " -v" : "",
	    iamrecursive ? " -r" : "", pflag ? " -p" : "",
	    targetshouldbedirectory ? " -d" : "");

	(void) signal(SIGPIPE, lostconn);

	if ((targ = colon(argv[argc - 1])))	/* Dest is remote host. */
		toremote(targ, argc, argv);
	else {
		if (targetshouldbedirectory)
			verifydir(argv[argc - 1]);
		tolocal(argc, argv);	/* Dest is local host. */
	}
	/*
	 * Finally check the exit status of the ssh process, if one was forked
	 * and no error has occurred yet
	 */
	if (do_cmd_pid != -1 && errs == 0) {
		if (remin != -1)
		    (void) close(remin);
		if (remout != -1)
		    (void) close(remout);
		if (waitpid(do_cmd_pid, &status, 0) == -1)
			errs = 1;
		else {
			if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
				errs = 1;
		}
	}
	exit(errs != 0);
}

/* Callback from atomicio6 to update progress meter and limit bandwidth */
static int
scpio(void *_cnt, size_t s)
{
	off_t *cnt = (off_t *)_cnt;

	*cnt += s;
	if (limit_kbps > 0)
		bandwidth_limit(&bwlimit, s);
	return 0;
}

static int
do_times(int fd, int verb, const struct stat *sb)
{
	/* strlen(2^64) == 20; strlen(10^6) == 7 */
	char buf[(20 + 7 + 2) * 2 + 2];

	(void)snprintf(buf, sizeof(buf), "T%llu 0 %llu 0\n",
	    (unsigned long long) (sb->st_mtime < 0 ? 0 : sb->st_mtime),
	    (unsigned long long) (sb->st_atime < 0 ? 0 : sb->st_atime));
	if (verb) {
		fprintf(stderr, "File mtime %lld atime %lld\n",
		    (long long)sb->st_mtime, (long long)sb->st_atime);
		fprintf(stderr, "Sending file timestamps: %s", buf);
	}
	(void) atomicio(vwrite, fd, buf, strlen(buf));
	return (response());
}

void
toremote(char *targ, int argc, char **argv)
{
	char *bp, *host, *src, *suser, *thost, *tuser, *arg;
	arglist alist;
	int i;
	u_int j;

	memset(&alist, '\0', sizeof(alist));
	alist.list = NULL;

	*targ++ = 0;
	if (*targ == 0)
		targ = ".";

	arg = xstrdup(argv[argc - 1]);
	if ((thost = strrchr(arg, '@@'))) {
		/* user@@host */
		*thost++ = 0;
		tuser = arg;
		if (*tuser == '\0')
			tuser = NULL;
	} else {
		thost = arg;
		tuser = NULL;
	}

	if (tuser != NULL && !okname(tuser)) {
		free(arg);
		return;
	}

	for (i = 0; i < argc - 1; i++) {
		src = colon(argv[i]);
		if (src && throughlocal) {	/* extended remote to remote */
			*src++ = 0;
			if (*src == 0)
				src = ".";
			host = strrchr(argv[i], '@@');
			if (host) {
				*host++ = 0;
				host = cleanhostname(host);
				suser = argv[i];
				if (*suser == '\0')
					suser = pwd->pw_name;
				else if (!okname(suser))
					continue;
			} else {
				host = cleanhostname(argv[i]);
				suser = NULL;
			}
			xasprintf(&bp, "%s -f %s%s", cmd,
			    *src == '-' ? "-- " : "", src);
			if (do_cmd(host, suser, bp, &remin, &remout) < 0)
				exit(1);
			free(bp);
			host = cleanhostname(thost);
			xasprintf(&bp, "%s -t %s%s", cmd,
			    *targ == '-' ? "-- " : "", targ);
			if (do_cmd2(host, tuser, bp, remin, remout) < 0)
				exit(1);
			free(bp);
			(void) close(remin);
			(void) close(remout);
			remin = remout = -1;
		} else if (src) {	/* standard remote to remote */
			freeargs(&alist);
			addargs(&alist, "%s", ssh_program);
			addargs(&alist, "-x");
			addargs(&alist, "-oClearAllForwardings=yes");
			addargs(&alist, "-n");
			for (j = 0; j < remote_remote_args.num; j++) {
				addargs(&alist, "%s",
				    remote_remote_args.list[j]);
			}
			*src++ = 0;
			if (*src == 0)
				src = ".";
			host = strrchr(argv[i], '@@');

			if (host) {
				*host++ = 0;
				host = cleanhostname(host);
				suser = argv[i];
				if (*suser == '\0')
					suser = pwd->pw_name;
				else if (!okname(suser))
					continue;
				addargs(&alist, "-l");
				addargs(&alist, "%s", suser);
			} else {
				host = cleanhostname(argv[i]);
			}
			addargs(&alist, "--");
			addargs(&alist, "%s", host);
			addargs(&alist, "%s", cmd);
			addargs(&alist, "%s", src);
			addargs(&alist, "%s%s%s:%s",
			    tuser ? tuser : "", tuser ? "@@" : "",
			    thost, targ);
			if (do_local_cmd(&alist) != 0)
				errs = 1;
		} else {	/* local to remote */
			if (remin == -1) {
				xasprintf(&bp, "%s -t %s%s", cmd,
				    *targ == '-' ? "-- " : "", targ);
				host = cleanhostname(thost);
				if (do_cmd(host, tuser, bp, &remin,
				    &remout) < 0)
					exit(1);
				if (response() < 0)
					exit(1);
				free(bp);
			}
			source(1, argv + i);
		}
	}
	free(arg);
}

void
tolocal(int argc, char **argv)
{
	char *bp, *host, *src, *suser;
	arglist alist;
	int i;

	memset(&alist, '\0', sizeof(alist));
	alist.list = NULL;

	for (i = 0; i < argc - 1; i++) {
		if (!(src = colon(argv[i]))) {	/* Local to local. */
			freeargs(&alist);
			addargs(&alist, "%s", _PATH_CP);
			if (iamrecursive)
				addargs(&alist, "-r");
			if (pflag)
				addargs(&alist, "-p");
			addargs(&alist, "--");
			addargs(&alist, "%s", argv[i]);
			addargs(&alist, "%s", argv[argc-1]);
			if (do_local_cmd(&alist))
				++errs;
			continue;
		}
		*src++ = 0;
		if (*src == 0)
			src = ".";
		if ((host = strrchr(argv[i], '@@')) == NULL) {
			host = argv[i];
			suser = NULL;
		} else {
			*host++ = 0;
			suser = argv[i];
			if (*suser == '\0')
				suser = pwd->pw_name;
		}
		host = cleanhostname(host);
		xasprintf(&bp, "%s -f %s%s",
		    cmd, *src == '-' ? "-- " : "", src);
		if (do_cmd(host, suser, bp, &remin, &remout) < 0) {
			free(bp);
			++errs;
			continue;
		}
		free(bp);
		sink(1, argv + argc - 1);
		(void) close(remin);
		remin = remout = -1;
	}
}

void
source(int argc, char **argv)
{
	struct stat stb;
	static BUF buffer;
	BUF *bp;
	off_t i, statbytes;
	size_t amt, nr;
	int fd = -1, haderr, indx;
	char *last, *name, buf[2048], encname[PATH_MAX];
	int len;

	for (indx = 0; indx < argc; ++indx) {
		name = argv[indx];
		statbytes = 0;
		len = strlen(name);
		while (len > 1 && name[len-1] == '/')
			name[--len] = '\0';
		if ((fd = open(name, O_RDONLY|O_NONBLOCK, 0)) < 0)
			goto syserr;
		if (strchr(name, '\n') != NULL) {
			strnvis(encname, name, sizeof(encname), VIS_NL);
			name = encname;
		}
		if (fstat(fd, &stb) < 0) {
syserr:			run_err("%s: %s", name, strerror(errno));
			goto next;
		}
		if (stb.st_size < 0) {
			run_err("%s: %s", name, "Negative file size");
			goto next;
		}
		unset_nonblock(fd);
		switch (stb.st_mode & S_IFMT) {
		case S_IFREG:
			break;
		case S_IFDIR:
			if (iamrecursive) {
				rsource(name, &stb);
				goto next;
			}
			/* FALLTHROUGH */
		default:
			run_err("%s: not a regular file", name);
			goto next;
		}
		if ((last = strrchr(name, '/')) == NULL)
			last = name;
		else
			++last;
		curfile = last;
		if (pflag) {
			if (do_times(remout, verbose_mode, &stb) < 0)
				goto next;
		}
#define	FILEMODEMASK	(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)
		snprintf(buf, sizeof buf, "C%04o %lld %s\n",
		    (u_int) (stb.st_mode & FILEMODEMASK),
		    (long long)stb.st_size, last);
		if (verbose_mode)
			fmprintf(stderr, "Sending file modes: %s", buf);
		(void) atomicio(vwrite, remout, buf, strlen(buf));
		if (response() < 0)
			goto next;
		if ((bp = allocbuf(&buffer, fd, COPY_BUFLEN)) == NULL) {
next:			if (fd != -1) {
				(void) close(fd);
				fd = -1;
			}
			continue;
		}
		if (showprogress)
			start_progress_meter(curfile, stb.st_size, &statbytes);
		set_nonblock(remout);
		for (haderr = i = 0; i < stb.st_size; i += bp->cnt) {
			amt = bp->cnt;
			if (i + (off_t)amt > stb.st_size)
				amt = stb.st_size - i;
			if (!haderr) {
				if ((nr = atomicio(read, fd,
				    bp->buf, amt)) != amt) {
					haderr = errno;
					memset(bp->buf + nr, 0, amt - nr);
				}
			}
			/* Keep writing after error to retain sync */
			if (haderr) {
				(void)atomicio(vwrite, remout, bp->buf, amt);
				memset(bp->buf, 0, amt);
				continue;
			}
			if (atomicio6(vwrite, remout, bp->buf, amt, scpio,
			    &statbytes) != amt)
				haderr = errno;
		}
		unset_nonblock(remout);

		if (fd != -1) {
			if (close(fd) < 0 && !haderr)
				haderr = errno;
			fd = -1;
		}
		if (!haderr)
			(void) atomicio(vwrite, remout, "", 1);
		else
			run_err("%s: %s", name, strerror(haderr));
		(void) response();
		if (showprogress)
			stop_progress_meter();
	}
}

void
rsource(char *name, struct stat *statp)
{
	DIR *dirp;
	struct dirent *dp;
	char *last, *vect[1], path[PATH_MAX];

	if (!(dirp = opendir(name))) {
		run_err("%s: %s", name, strerror(errno));
		return;
	}
	last = strrchr(name, '/');
	if (last == NULL)
		last = name;
	else
		last++;
	if (pflag) {
		if (do_times(remout, verbose_mode, statp) < 0) {
			closedir(dirp);
			return;
		}
	}
	(void) snprintf(path, sizeof path, "D%04o %d %.1024s\n",
	    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);
	if (verbose_mode)
		fmprintf(stderr, "Entering directory: %s", path);
	(void) atomicio(vwrite, remout, path, strlen(path));
	if (response() < 0) {
		closedir(dirp);
		return;
	}
	while ((dp = readdir(dirp)) != NULL) {
		if (dp->d_ino == 0)
			continue;
		if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, ".."))
			continue;
		if (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {
			run_err("%s/%s: name too long", name, dp->d_name);
			continue;
		}
		(void) snprintf(path, sizeof path, "%s/%s", name, dp->d_name);
		vect[0] = path;
		source(1, vect);
	}
	(void) closedir(dirp);
	(void) atomicio(vwrite, remout, "E\n", 2);
	(void) response();
}

#define TYPE_OVERFLOW(type, val) \
	((sizeof(type) == 4 && (val) > INT32_MAX) || \
	 (sizeof(type) == 8 && (val) > INT64_MAX) || \
	 (sizeof(type) != 4 && sizeof(type) != 8))

void
sink(int argc, char **argv)
{
	static BUF buffer;
	struct stat stb;
	enum {
		YES, NO, DISPLAYED
	} wrerr;
	BUF *bp;
	off_t i;
	size_t j, count;
	int amt, exists, first, ofd;
	mode_t mode, omode, mask;
	off_t size, statbytes;
	unsigned long long ull;
	int setimes, targisdir, wrerrno = 0;
	char ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];
	struct timeval tv[2];

#define	atime	tv[0]
#define	mtime	tv[1]
#define	SCREWUP(str)	{ why = str; goto screwup; }

	if (TYPE_OVERFLOW(time_t, 0) || TYPE_OVERFLOW(off_t, 0))
		SCREWUP("Unexpected off_t/time_t size");

	setimes = targisdir = 0;
	mask = umask(0);
	if (!pflag)
		(void) umask(mask);
	if (argc != 1) {
		run_err("ambiguous target");
		exit(1);
	}
	targ = *argv;
	if (targetshouldbedirectory)
		verifydir(targ);

	(void) atomicio(vwrite, remout, "", 1);
	if (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))
		targisdir = 1;
	for (first = 1;; first = 0) {
		cp = buf;
		if (atomicio(read, remin, cp, 1) != 1)
			return;
		if (*cp++ == '\n')
			SCREWUP("unexpected <newline>");
		do {
			if (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))
				SCREWUP("lost connection");
			*cp++ = ch;
		} while (cp < &buf[sizeof(buf) - 1] && ch != '\n');
		*cp = 0;
		if (verbose_mode)
			fmprintf(stderr, "Sink: %s", buf);

		if (buf[0] == '\01' || buf[0] == '\02') {
			if (iamremote == 0) {
				(void) snmprintf(visbuf, sizeof(visbuf),
				    NULL, "%s", buf + 1);
				(void) atomicio(vwrite, STDERR_FILENO,
				    visbuf, strlen(visbuf));
			}
			if (buf[0] == '\02')
				exit(1);
			++errs;
			continue;
		}
		if (buf[0] == 'E') {
			(void) atomicio(vwrite, remout, "", 1);
			return;
		}
		if (ch == '\n')
			*--cp = 0;

		cp = buf;
		if (*cp == 'T') {
			setimes++;
			cp++;
			if (!isdigit((unsigned char)*cp))
				SCREWUP("mtime.sec not present");
			ull = strtoull(cp, &cp, 10);
			if (!cp || *cp++ != ' ')
				SCREWUP("mtime.sec not delimited");
			if (TYPE_OVERFLOW(time_t, ull))
				setimes = 0;	/* out of range */
			mtime.tv_sec = ull;
			mtime.tv_usec = strtol(cp, &cp, 10);
			if (!cp || *cp++ != ' ' || mtime.tv_usec < 0 ||
			    mtime.tv_usec > 999999)
				SCREWUP("mtime.usec not delimited");
			if (!isdigit((unsigned char)*cp))
				SCREWUP("atime.sec not present");
			ull = strtoull(cp, &cp, 10);
			if (!cp || *cp++ != ' ')
				SCREWUP("atime.sec not delimited");
			if (TYPE_OVERFLOW(time_t, ull))
				setimes = 0;	/* out of range */
			atime.tv_sec = ull;
			atime.tv_usec = strtol(cp, &cp, 10);
			if (!cp || *cp++ != '\0' || atime.tv_usec < 0 ||
			    atime.tv_usec > 999999)
				SCREWUP("atime.usec not delimited");
			(void) atomicio(vwrite, remout, "", 1);
			continue;
		}
		if (*cp != 'C' && *cp != 'D') {
			/*
			 * Check for the case "rcp remote:foo\* local:bar".
			 * In this case, the line "No match." can be returned
			 * by the shell before the rcp command on the remote is
			 * executed so the ^Aerror_message convention isn't
			 * followed.
			 */
			if (first) {
				run_err("%s", cp);
				exit(1);
			}
			SCREWUP("expected control record");
		}
		mode = 0;
		for (++cp; cp < buf + 5; cp++) {
			if (*cp < '0' || *cp > '7')
				SCREWUP("bad mode");
			mode = (mode << 3) | (*cp - '0');
		}
		if (*cp++ != ' ')
			SCREWUP("mode not delimited");

		if (!isdigit((unsigned char)*cp))
			SCREWUP("size not present");
		ull = strtoull(cp, &cp, 10);
		if (!cp || *cp++ != ' ')
			SCREWUP("size not delimited");
		if (TYPE_OVERFLOW(off_t, ull))
			SCREWUP("size out of range");
		size = (off_t)ull;

		if ((strchr(cp, '/') != NULL) || (strcmp(cp, "..") == 0)) {
			run_err("error: unexpected filename: %s", cp);
			exit(1);
		}
		if (targisdir) {
			static char *namebuf;
			static size_t cursize;
			size_t need;

			need = strlen(targ) + strlen(cp) + 250;
			if (need > cursize) {
				free(namebuf);
				namebuf = xmalloc(need);
				cursize = need;
			}
			(void) snprintf(namebuf, need, "%s%s%s", targ,
			    strcmp(targ, "/") ? "/" : "", cp);
			np = namebuf;
		} else
			np = targ;
		curfile = cp;
		exists = stat(np, &stb) == 0;
		if (buf[0] == 'D') {
			int mod_flag = pflag;
			if (!iamrecursive)
				SCREWUP("received directory without -r");
			if (exists) {
				if (!S_ISDIR(stb.st_mode)) {
					errno = ENOTDIR;
					goto bad;
				}
				if (pflag)
					(void) chmod(np, mode);
			} else {
				/* Handle copying from a read-only
				   directory */
				mod_flag = 1;
				if (mkdir(np, mode | S_IRWXU) < 0)
					goto bad;
			}
			vect[0] = xstrdup(np);
			sink(1, vect);
			if (setimes) {
				setimes = 0;
				if (utimes(vect[0], tv) < 0)
					run_err("%s: set times: %s",
					    vect[0], strerror(errno));
			}
			if (mod_flag)
				(void) chmod(vect[0], mode);
			free(vect[0]);
			continue;
		}
		omode = mode;
		mode |= S_IWUSR;
		if ((ofd = open(np, O_WRONLY|O_CREAT, mode)) < 0) {
bad:			run_err("%s: %s", np, strerror(errno));
			continue;
		}
		(void) atomicio(vwrite, remout, "", 1);
		if ((bp = allocbuf(&buffer, ofd, COPY_BUFLEN)) == NULL) {
			(void) close(ofd);
			continue;
		}
		cp = bp->buf;
		wrerr = NO;

		statbytes = 0;
		if (showprogress)
			start_progress_meter(curfile, size, &statbytes);
		set_nonblock(remin);
		for (count = i = 0; i < size; i += bp->cnt) {
			amt = bp->cnt;
			if (i + amt > size)
				amt = size - i;
			count += amt;
			do {
				j = atomicio6(read, remin, cp, amt,
				    scpio, &statbytes);
				if (j == 0) {
					run_err("%s", j != EPIPE ?
					    strerror(errno) :
					    "dropped connection");
					exit(1);
				}
				amt -= j;
				cp += j;
			} while (amt > 0);

			if (count == bp->cnt) {
				/* Keep reading so we stay sync'd up. */
				if (wrerr == NO) {
					if (atomicio(vwrite, ofd, bp->buf,
					    count) != count) {
						wrerr = YES;
						wrerrno = errno;
					}
				}
				count = 0;
				cp = bp->buf;
			}
		}
		unset_nonblock(remin);
		if (count != 0 && wrerr == NO &&
		    atomicio(vwrite, ofd, bp->buf, count) != count) {
			wrerr = YES;
			wrerrno = errno;
		}
		if (wrerr == NO && (!exists || S_ISREG(stb.st_mode)) &&
		    ftruncate(ofd, size) != 0) {
			run_err("%s: truncate: %s", np, strerror(errno));
			wrerr = DISPLAYED;
		}
		if (pflag) {
			if (exists || omode != mode)
				if (fchmod(ofd, omode)) {
					run_err("%s: set mode: %s",
					    np, strerror(errno));
					wrerr = DISPLAYED;
				}
		} else {
			if (!exists && omode != mode)
				if (fchmod(ofd, omode & ~mask)) {
					run_err("%s: set mode: %s",
					    np, strerror(errno));
					wrerr = DISPLAYED;
				}
		}
		if (close(ofd) == -1) {
			wrerr = YES;
			wrerrno = errno;
		}
		(void) response();
		if (showprogress)
			stop_progress_meter();
		if (setimes && wrerr == NO) {
			setimes = 0;
			if (utimes(np, tv) < 0) {
				run_err("%s: set times: %s",
				    np, strerror(errno));
				wrerr = DISPLAYED;
			}
		}
		switch (wrerr) {
		case YES:
			run_err("%s: %s", np, strerror(wrerrno));
			break;
		case NO:
			(void) atomicio(vwrite, remout, "", 1);
			break;
		case DISPLAYED:
			break;
		}
	}
screwup:
	run_err("protocol error: %s", why);
	exit(1);
}

int
response(void)
{
	char ch, *cp, resp, rbuf[2048], visbuf[2048];

	if (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))
		lostconn(0);

	cp = rbuf;
	switch (resp) {
	case 0:		/* ok */
		return (0);
	default:
		*cp++ = resp;
		/* FALLTHROUGH */
	case 1:		/* error, followed by error msg */
	case 2:		/* fatal error, "" */
		do {
			if (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))
				lostconn(0);
			*cp++ = ch;
		} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\n');

		if (!iamremote) {
			cp[-1] = '\0';
			(void) snmprintf(visbuf, sizeof(visbuf),
			    NULL, "%s\n", rbuf);
			(void) atomicio(vwrite, STDERR_FILENO,
			    visbuf, strlen(visbuf));
		}
		++errs;
		if (resp == 1)
			return (-1);
		exit(1);
	}
	/* NOTREACHED */
}

void
usage(void)
{
	(void) fprintf(stderr,
	    "usage: scp [-346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\n"
	    "           [-l limit] [-o ssh_option] [-P port] [-S program]\n"
	    "           [[user@@]host1:]file1 ... [[user@@]host2:]file2\n");
	exit(1);
}

void
run_err(const char *fmt,...)
{
	static FILE *fp;
	va_list ap;

	++errs;
	if (fp != NULL || (remout != -1 && (fp = fdopen(remout, "w")))) {
		(void) fprintf(fp, "%c", 0x01);
		(void) fprintf(fp, "scp: ");
		va_start(ap, fmt);
		(void) vfprintf(fp, fmt, ap);
		va_end(ap);
		(void) fprintf(fp, "\n");
		(void) fflush(fp);
	}

	if (!iamremote) {
		va_start(ap, fmt);
		vfmprintf(stderr, fmt, ap);
		va_end(ap);
		fprintf(stderr, "\n");
	}
}

void
verifydir(char *cp)
{
	struct stat stb;

	if (!stat(cp, &stb)) {
		if (S_ISDIR(stb.st_mode))
			return;
		errno = ENOTDIR;
	}
	run_err("%s: %s", cp, strerror(errno));
	killchild(0);
}

int
okname(char *cp0)
{
	int c;
	char *cp;

	cp = cp0;
	do {
		c = (int)*cp;
		if (c & 0200)
			goto bad;
		if (!isalpha(c) && !isdigit((unsigned char)c)) {
			switch (c) {
			case '\'':
			case '"':
			case '`':
			case ' ':
			case '#':
				goto bad;
			default:
				break;
			}
		}
	} while (*++cp);
	return (1);

bad:	fmprintf(stderr, "%s: invalid user name\n", cp0);
	return (0);
}

BUF *
allocbuf(BUF *bp, int fd, int blksize)
{
	size_t size;
	struct stat stb;

	if (fstat(fd, &stb) < 0) {
		run_err("fstat: %s", strerror(errno));
		return (0);
	}
	size = ROUNDUP(stb.st_blksize, blksize);
	if (size == 0)
		size = blksize;
	if (bp->cnt >= size)
		return (bp);
	bp->buf = xrecallocarray(bp->buf, bp->cnt, size, 1);
	bp->cnt = size;
	return (bp);
}

void
lostconn(int signo)
{
	if (!iamremote)
		(void)write(STDERR_FILENO, "lost connection\n", 16);
	if (signo)
		_exit(1);
	else
		exit(1);
}
@


1.191
log
@remove options -12 from usage();
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.190 2017/04/30 23:28:12 djm Exp $ */
d1336 1
a1336 5
	if (bp->buf == NULL)
		bp->buf = xmalloc(size);
	else
		bp->buf = xreallocarray(bp->buf, 1, size);
	memset(bp->buf, 0, size);
@


1.190
log
@exterminate the -1 flag from scp

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.189 2017/04/28 03:21:12 millert Exp $ */
d1246 1
a1246 1
	    "usage: scp [-12346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\n"
@


1.189
log
@Avoid relying on implementation-specific behavior when detecting
whether the timestamp or file size overflowed.  If time_t and
off_t are not either 32-bit or 64-bit scp will exit with an error.
OK djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.188 2017/04/27 11:53:12 millert Exp $ */
d389 2
d392 2
@


1.188
log
@Avoid potential signed int overflow when parsing the file size.
Use strtoul() instead of parsing manually.  OK djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.187 2016/09/12 01:22:38 deraadt Exp $ */
d89 1
d898 5
d926 3
d987 1
a987 2
			if ((time_t)ull < 0 ||
			    (unsigned long long)(time_t)ull != ull)
d999 1
a999 2
			if ((time_t)ull < 0 ||
			    (unsigned long long)(time_t)ull != ull)
d1037 1
a1037 1
		if ((off_t)ull < 0 || (unsigned long long)(off_t)ull != ull)
@


1.187
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.186 2016/05/25 23:48:45 schwarze Exp $ */
d1025 4
a1028 3
		for (size = 0; isdigit((unsigned char)*cp);)
			size = size * 10 + (*cp++ - '0');
		if (*cp++ != ' ')
d1030 4
@


1.186
log
@To prevent screwing up terminal settings when printing to the
terminal, for ASCII and UTF-8, escape bytes not forming characters
and bytes forming non-printable characters with vis(3) VIS_OCTAL.
For other character sets, abort printing of the current string in
these cases.  In particular,
* let scp(1) respect the local user's LC_CTYPE locale(1);
* sanitize data received from the remote host;
* sanitize filenames, usernames, and similar data even locally;
* take character display widths into account for the progressmeter.

This is believed to be sufficient to keep the local terminal safe
on OpenBSD, but bad things can still happen on other systems with
state-dependent locales because many places in the code print
unencoded ASCII characters into the output stream.

Using feedback from djm@@ and martijn@@,
various aspects discussed with many others.

deraadt@@ says it should go in now, i probably already hesitated too long
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.185 2016/03/02 22:43:52 dtucker Exp $ */
a73 1
#include <sys/param.h>	/* roundup MAX */
d369 1
a369 1
	newargv = xcalloc(MAX(argc + 1, 1), sizeof(*newargv));
d1315 1
a1315 1
	size = roundup(stb.st_blksize, blksize);
@


1.185
log
@Improve accuracy of reported transfer speeds by waiting for the ack from
the other end.  Pointed out by mmcc@@, ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.184 2015/11/27 00:49:31 deraadt Exp $ */
d86 1
d104 1
d180 1
a180 1
			fprintf(stderr, " %s", a->list[i]);
d221 1
a221 1
		fprintf(stderr,
d296 1
a296 1
		fprintf(stderr,
d367 2
d796 2
a797 3
		if (verbose_mode) {
			fprintf(stderr, "Sending file modes: %s", buf);
		}
d874 1
a874 1
		fprintf(stderr, "Entering directory: %s", path);
d914 1
a914 1
	char ch, *cp, *np, *targ, *why, *vect[1], buf[2048];
d949 1
a949 1
			fprintf(stderr, "Sink: %s", buf);
d952 3
a954 1
			if (iamremote == 0)
d956 2
a957 1
				    buf + 1, strlen(buf + 1));
d1192 1
a1192 1
	char ch, *cp, resp, rbuf[2048];
d1212 7
a1218 2
		if (!iamremote)
			(void) atomicio(vwrite, STDERR_FILENO, rbuf, cp - rbuf);
d1256 1
a1256 1
		vfprintf(stderr, fmt, ap);
d1302 1
a1302 1
bad:	fprintf(stderr, "%s: invalid user name\n", cp0);
@


1.184
log
@pledge "stdio rpath wpath cpath fattr tty proc exec" except for the
-p option (which sadly has insane semantics...)
ok semarie dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.183 2015/10/16 17:07:24 mmcc Exp $ */
a829 2
		if (showprogress)
			stop_progress_meter();
d841 2
a1126 2
		if (showprogress)
			stop_progress_meter();
d1157 2
@


1.183
log
@0 -> NULL when comparing with a char*.

ok dtucker@@, djm@@.
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.182 2015/04/24 01:36:00 deraadt Exp $ */
d465 10
@


1.182
log
@rename xrealloc() to xreallocarray() since it follows that form.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.181 2015/01/16 06:40:12 deraadt Exp $ */
d848 1
a848 1
	if (last == 0)
@


1.181
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.180 2014/06/24 02:21:01 djm Exp $ */
d1303 1
a1303 1
		bp->buf = xrealloc(bp->buf, 1, size);
@


1.180
log
@when copying local->remote fails during read, don't send uninitialised
heap to the remote end. Reported by Jann Horn
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.179 2013/11/20 20:53:10 deraadt Exp $ */
d74 1
a74 1
#include <sys/param.h>
d94 1
d732 1
a732 1
	char *last, *name, buf[2048], encname[MAXPATHLEN];
d841 1
a841 1
	char *last, *vect[1], path[MAXPATHLEN];
@


1.179
log
@unsigned casts for ctype macros where neccessary
ok guenther millert markus
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.178 2013/06/22 06:31:57 djm Exp $ */
d729 1
a729 1
	size_t amt;
d802 2
a803 1
				if (atomicio(read, fd, bp->buf, amt) != amt)
d805 2
d811 1
@


1.178
log
@improved time_t overflow check suggested by guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.177 2013/06/21 05:43:10 djm Exp $ */
d1005 1
a1005 1
		for (size = 0; isdigit(*cp);)
d1261 1
a1261 1
		if (!isalpha(c) && !isdigit(c)) {
@


1.177
log
@make this -Wsign-compare clean after time_t conversion
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.176 2013/06/17 04:48:42 guenther Exp $ */
d958 2
a959 1
			if ((time_t)ull < 0 || ull > LLONG_MAX)
d971 2
a972 1
			if ((time_t)ull < 0 || ull > LLONG_MAX)
@


1.176
log
@Handle time_t values as long long's when formatting them and when
parsing them from remote servers.
Improve error checking in parsing of 'T' lines.

ok dtucker@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.175 2013/06/04 19:12:23 dtucker Exp $ */
d958 1
a958 1
			if ((time_t)ull < 0 || (time_t)ull != ull)
d970 1
a970 1
			if ((time_t)ull < 0 || (time_t)ull != ull)
@


1.175
log
@use MAXPATHLEN for buffer size instead of fixed value.  ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.174 2013/06/01 20:59:25 dtucker Exp $ */
d532 18
d774 1
a774 15
			/*
			 * Make it compatible with possible future
			 * versions expecting microseconds.
			 */
			(void) snprintf(buf, sizeof buf, "T%lu 0 %lu 0\n",
			    (u_long) (stb.st_mtime < 0 ? 0 : stb.st_mtime),
			    (u_long) (stb.st_atime < 0 ? 0 : stb.st_atime));
			if (verbose_mode) {
				fprintf(stderr, "File mtime %ld atime %ld\n",
				    (long)stb.st_mtime, (long)stb.st_atime);
				fprintf(stderr, "Sending file timestamps: %s",
				    buf);
			}
			(void) atomicio(vwrite, remout, buf, strlen(buf));
			if (response() < 0)
d848 1
a848 5
		(void) snprintf(path, sizeof(path), "T%lu 0 %lu 0\n",
		    (u_long) statp->st_mtime,
		    (u_long) statp->st_atime);
		(void) atomicio(vwrite, remout, path, strlen(path));
		if (response() < 0) {
d894 1
d953 3
a955 1
			mtime.tv_sec = strtol(cp, &cp, 10);
d958 3
d962 2
a963 1
			if (!cp || *cp++ != ' ')
d965 3
a967 1
			atime.tv_sec = strtol(cp, &cp, 10);
d970 3
d974 2
a975 1
			if (!cp || *cp++ != '\0')
@


1.174
log
@Replace S_IWRITE, which isn't standardized, with S_IWUSR, which is.  Patch
from Nathan Osman via bz#2085.  ok deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.173 2013/05/17 00:13:14 djm Exp $ */
d832 1
a832 1
	char *last, *vect[1], path[1100];
@


1.173
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.172 2013/05/16 09:08:41 dtucker Exp $ */
d1048 1
a1048 1
		mode |= S_IWRITE;
@


1.172
log
@Fix some "unused result" warnings found via clang and -portable.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.171 2011/09/09 22:37:01 djm Exp $ */
d560 1
a560 1
		xfree(arg);
d587 1
a587 1
			(void) xfree(bp);
d593 1
a593 1
			(void) xfree(bp);
d644 1
a644 1
				(void) xfree(bp);
d649 1
a649 1
	xfree(arg);
d693 1
a693 1
			(void) xfree(bp);
d697 1
a697 1
		xfree(bp);
d1005 1
a1005 2
				if (namebuf)
					xfree(namebuf);
d1044 1
a1044 2
			if (vect[0])
				xfree(vect[0]);
@


1.171
log
@suppress adding '--' to remote commandlines when the first argument
does not start with '-'. saves breakage on some difficult-to-upgrade
embedded/router platforms; feedback & ok dtucker ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.170 2010/12/09 14:13:33 jmc Exp $ */
d1295 1
a1295 1
		write(STDERR_FILENO, "lost connection\n", 16);
@


1.170
log
@scp.1: grammer fix
scp.c: add -3 to usage()
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.169 2010/12/08 22:46:03 markus Exp $ */
d583 2
a584 1
			xasprintf(&bp, "%s -f -- %s", cmd, src);
d589 2
a590 1
			xasprintf(&bp, "%s -t -- %s", cmd, targ);
d636 2
a637 1
				xasprintf(&bp, "%s -t -- %s", cmd, targ);
d690 2
a691 1
		xasprintf(&bp, "%s -f -- %s", cmd, src);
@


1.169
log
@add a new -3 option to scp: Copies between two remote hosts are
transferred through the local host.  Without this option the data
is copied directly between the two remote hosts. ok djm@@ (bugzilla #1837)
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.168 2010/11/26 05:52:49 djm Exp $ */
d1188 1
a1188 1
	    "usage: scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\n"
@


1.168
log
@Pass through ssh command-line flags and options when doing remote-remote
transfers, e.g. to enable agent forwarding which is particularly useful
in this case; bz#1837 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.167 2010/09/22 22:58:51 djm Exp $ */
d106 1
d125 6
d281 44
d380 1
a380 1
	while ((ch = getopt(argc, argv, "dfl:prtvBCc:i:P:q1246S:o:F:")) != -1)
d391 3
d566 30
a595 1
		if (src) {	/* remote to remote */
@


1.167
log
@add an option per-read/write callback to atomicio

factor out bandwidth limiting code from scp(1) into a generic bandwidth
limiter that can be attached using the atomicio callback mechanism

add a bandwidth limit option to sftp(1) using the above

"very nice" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.166 2010/07/01 13:06:59 millert Exp $ */
d109 1
d320 2
a321 1
	args.list = NULL;
d324 3
a326 3
	addargs(&args, "-oForwardAgent no");
	addargs(&args, "-oPermitLocalCommand no");
	addargs(&args, "-oClearAllForwardings yes");
d338 1
d344 2
d350 2
d356 2
a357 1
			addargs(&args, "-oBatchmode yes");
d378 1
d383 1
d484 1
a514 2
			if (verbose_mode)
				addargs(&alist, "-v");
d516 1
a516 1
			addargs(&alist, "-oClearAllForwardings yes");
d518 4
a521 1

@


1.166
log
@Fix a longstanding problem where if you suspend scp at the
password/passphrase prompt the terminal mode is not restored.
OK djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.165 2009/12/20 07:28:36 guenther Exp $ */
a106 2
void bwlimit(int);

d111 2
a112 1
off_t limit_rate = 0;
d304 2
a305 2
	double speed;
	char *targ, *endp, **newargv;
d352 3
a354 2
			speed = strtod(optarg, &endp);
			if (speed <= 0 || *endp != '\0')
d356 2
a357 1
			limit_rate = speed * 1024;
d456 3
a458 6
/*
 * atomicio-like wrapper that also applies bandwidth limits and updates
 * the progressmeter counter.
 */
static size_t
scpio(ssize_t (*f)(int, void *, size_t), int fd, void *_p, size_t l, off_t *c)
d460 6
a465 28
	u_char *p = (u_char *)_p;
	size_t offset;
	ssize_t r;
	struct pollfd pfd;

	pfd.fd = fd;
	pfd.events = f == read ? POLLIN : POLLOUT;
	for (offset = 0; offset < l;) {
		r = f(fd, p + offset, l - offset);
		if (r == 0) {
			errno = EPIPE;
			return offset;
		}
		if (r < 0) {
			if (errno == EINTR)
				continue;
			if (errno == EAGAIN) {
				(void)poll(&pfd, 1, -1); /* Ignore errors */
				continue;
			}
			return offset;
		}
		offset += (size_t)r;
		*c += (off_t)r;
		if (limit_rate)
			bwlimit(r);
	}
	return offset;
d707 1
a707 1
			if (scpio(vwrite, remout, bp->buf, amt,
a781 54
bwlimit(int amount)
{
	static struct timeval bwstart, bwend;
	static int lamt, thresh = 16384;
	u_int64_t waitlen;
	struct timespec ts, rm;

	if (!timerisset(&bwstart)) {
		gettimeofday(&bwstart, NULL);
		return;
	}

	lamt += amount;
	if (lamt < thresh)
		return;

	gettimeofday(&bwend, NULL);
	timersub(&bwend, &bwstart, &bwend);
	if (!timerisset(&bwend))
		return;

	lamt *= 8;
	waitlen = (double)1000000L * lamt / limit_rate;

	bwstart.tv_sec = waitlen / 1000000L;
	bwstart.tv_usec = waitlen % 1000000L;

	if (timercmp(&bwstart, &bwend, >)) {
		timersub(&bwstart, &bwend, &bwend);

		/* Adjust the wait time */
		if (bwend.tv_sec) {
			thresh /= 2;
			if (thresh < 2048)
				thresh = 2048;
		} else if (bwend.tv_usec < 10000) {
			thresh *= 2;
			if (thresh > COPY_BUFLEN * 4)
				thresh = COPY_BUFLEN * 4;
		}

		TIMEVAL_TO_TIMESPEC(&bwend, &ts);
		while (nanosleep(&ts, &rm) == -1) {
			if (errno != EINTR)
				break;
			ts = rm;
		}
	}

	lamt = 0;
	gettimeofday(&bwstart, NULL);
}

void
d974 2
a975 1
				j = scpio(read, remin, cp, amt, &statbytes);
@


1.165
log
@When passing user-controlled options with arguments to other programs,
pass the option and option argument as separate argv entries and
not smashed into one (e.g., as -l foo and not -lfoo).  Also, always
pass a "--" argument to stop option parsing, so that a positional
argument that starts with a '-' isn't treated as an option.  This
fixes some error cases as well as the handling of hostnames and
filenames that start with a '-'.

Based on a diff by halex@@
ok halex@@ djm@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.164 2008/10/10 04:55:16 stevesk Exp $ */
d143 14
d232 4
@


1.164
log
@spelling in comment; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.163 2008/06/13 18:55:22 dtucker Exp $ */
d231 5
a235 2
		if (remuser != NULL)
			addargs(&args, "-l%s", remuser);
d324 2
a325 1
			addargs(&args, "-%c%s", ch, optarg);
d328 2
a329 1
			addargs(&args, "-p%s", optarg);
d534 1
d545 1
a545 1
				xasprintf(&bp, "%s -t %s", cmd, targ);
d578 1
d598 1
a598 1
		xasprintf(&bp, "%s -f %s", cmd, src);
@


1.163
log
@Prevent -Wsign-compare warnings on LP64 systems.  bz #1192, ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.162 2008/01/01 09:06:39 dtucker Exp $ */
d415 1
a415 1
	 * and no error has occured yet
@


1.162
log
@If scp -p encounters a pre-epoch timestamp, use the epoch which is
as close as we can get given that it's used unsigned.  Add a little
debugging while there.  bz #828, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.161 2007/10/24 03:44:02 djm Exp $ */
d610 2
a611 1
	off_t i, amt, statbytes;
d632 4
d695 1
a695 1
			if (i + amt > stb.st_size)
@


1.161
log
@factor out network read/write into an atomicio()-like function, and use it
to handle short reads, apply bandwidth limits and update counters.
make network IO non-blocking, so a small trickle of reads/writes has a
chance of updating the progress meter; bz #799
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.160 2007/08/06 19:16:06 sobrado Exp $ */
d656 8
a663 2
			    (u_long) stb.st_mtime,
			    (u_long) stb.st_atime);
@


1.160
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.159 2007/06/13 00:21:27 djm Exp $ */
d76 1
d103 2
d432 37
a610 1
	size_t result;
d672 1
a672 1
		if ((bp = allocbuf(&buffer, fd, 2048)) == NULL) {
d681 1
a681 1
		/* Keep writing after an error so that we stay sync'd up. */
d687 1
a687 2
				result = atomicio(read, fd, bp->buf, amt);
				if (result != amt)
d690 4
a693 7
			if (haderr)
				(void) atomicio(vwrite, remout, bp->buf, amt);
			else {
				result = atomicio(vwrite, remout, bp->buf, amt);
				if (result != amt)
					haderr = errno;
				statbytes += result;
d695 3
a697 2
			if (limit_rate)
				bwlimit(amt);
d699 1
d805 1
a805 1
		} else if (bwend.tv_usec < 100) {
d807 2
a808 2
			if (thresh > 32768)
				thresh = 32768;
d999 1
a999 1
		if ((bp = allocbuf(&buffer, ofd, 4096)) == NULL) {
d1009 3
a1011 2
		for (count = i = 0; i < size; i += 4096) {
			amt = 4096;
d1016 1
a1016 1
				j = atomicio(read, remin, cp, amt);
d1018 2
a1019 1
					run_err("%s", j ? strerror(errno) :
a1024 1
				statbytes += j;
a1026 3
			if (limit_rate)
				bwlimit(4096);

d1040 1
@


1.159
log
@don't ftruncate() non-regular files; bz#1236 reported by wood AT xmission.com;
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.158 2007/06/12 13:54:28 dtucker Exp $ */
d1100 1
a1100 1
	    "           [[user@@]host1:]file1 [...] [[user@@]host2:]file2\n");
@


1.158
log
@Encode filename with strnvis if the name contains a newline (which can't
be represented in the scp protocol), from bz #891.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.157 2007/06/12 08:24:20 djm Exp $ */
d1012 2
a1013 1
		if (wrerr == NO && ftruncate(ofd, size) != 0) {
@


1.157
log
@make scp try to skip FIFOs rather than blocking when nothing is listening.
depends on the platform supporting sane O_NONBLOCK semantics for open
on FIFOs (apparently POSIX does not mandate this), which OpenBSD does.
bz #856; report by cjwatson AT debian.org; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.156 2007/01/22 13:06:21 djm Exp $ */
d93 1
d573 1
a573 1
	char *last, *name, buf[2048];
d582 2
d585 2
a586 3
			run_err("%s: skipping, filename contains a newline",
			    name);
			goto next;
a587 2
		if ((fd = open(name, O_RDONLY|O_NONBLOCK, 0)) < 0)
			goto syserr;
@


1.156
log
@fix detection of whether we should show progress meter or not: scp
tested isatty(stderr) but wrote the progress meter to stdout. This patch
makes it test stdout. bz#1265 reported by junkmail AT bitsculpture.com;
of dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.155 2006/08/03 03:34:42 deraadt Exp $ */
d586 1
a586 1
		if ((fd = open(name, O_RDONLY, 0)) < 0)
d592 1
@


1.155
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.154 2006/08/01 23:22:47 stevesk Exp $ */
d370 1
a370 1
	if (!isatty(STDERR_FILENO))
@


1.154
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.153 2006/07/26 13:57:17 stevesk Exp $ */
d74 1
a74 2
#include "includes.h"

d79 1
a79 1
#include <sys/param.h>
@


1.153
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.152 2006/07/26 02:35:17 stevesk Exp $ */
d89 1
@


1.152
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.151 2006/07/25 02:59:21 stevesk Exp $ */
d89 1
@


1.151
log
@move #include <sys/time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.150 2006/07/22 20:48:23 stevesk Exp $ */
d80 1
@


1.150
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.149 2006/07/22 19:08:54 stevesk Exp $ */
d79 1
@


1.149
log
@move #include <time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.148 2006/07/17 01:31:09 stevesk Exp $ */
d87 1
@


1.148
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.147 2006/07/11 20:07:25 stevesk Exp $ */
d87 1
@


1.147
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.146 2006/07/10 16:37:36 stevesk Exp $ */
d87 1
@


1.146
log
@move #include <stdarg.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.145 2006/07/10 12:03:20 djm Exp $ */
d82 1
@


1.145
log
@duplicate argv at the start of main() because it gets modified later;
pointed out by deraadt@@ ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.144 2006/07/09 15:15:10 stevesk Exp $ */
d85 1
@


1.144
log
@move #include <fcntl.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.143 2006/07/06 16:03:53 stevesk Exp $ */
d271 1
a271 1
	int ch, fflag, tflag, status;
d273 1
a273 1
	char *targ, *endp;
d279 6
@


1.143
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.142 2006/05/17 12:43:34 markus Exp $ */
d82 1
@


1.142
log
@fix leak; coverity via Kylene Jo Hall
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.141 2006/04/01 05:50:29 djm Exp $ */
d82 1
@


1.141
log
@xasprintification; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.140 2006/04/01 05:42:20 deraadt Exp $ */
d192 2
a193 1
	pipe(reserved);
d494 1
@


1.140
log
@minimal lint cleanup (unused crud, and some size_t); ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.139 2006/03/25 13:17:02 djm Exp $ */
a415 1
	size_t len;
d481 1
a481 3
				len = strlen(targ) + CMDNEEDS + 20;
				bp = xmalloc(len);
				(void) snprintf(bp, len, "%s -t %s", cmd, targ);
a499 1
	size_t len;
d532 1
a532 3
		len = strlen(src) + CMDNEEDS + 20;
		bp = xmalloc(len);
		(void) snprintf(bp, len, "%s -f %s", cmd, src);
@


1.139
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d91 1
a91 1
int do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout, int argc);
d178 1
a178 1
do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout, int argc)
a244 1
void nospace(void);
a413 1
	int i, len;
d416 2
d487 1
a487 1
				    &remout, argc) < 0)
a500 1
	int i, len;
d503 2
d539 1
a539 1
		if (do_cmd(host, suser, bp, &remin, &remout, argc) < 0) {
d784 2
a785 1
	int amt, exists, first, mask, mode, ofd, omode;
@


1.138
log
@change OpenSSH's xrealloc() function from being xrealloc(p, new_size) to
xrealloc(p, new_nmemb, new_itemsize).

realloc is particularly prone to integer overflows because it is almost
always allocating "n * size" bytes, so this is a far safer API;
ok deraadt@@
@
text
@d1 1
@


1.137
log
@RCSID() can die
@
text
@d1174 1
a1174 1
		bp->buf = xrealloc(bp->buf, size);
@


1.136
log
@Try to display errormessage even if remout == -1

ok djm@@, markus@@
@
text
@a73 1
RCSID("$OpenBSD: scp.c,v 1.135 2006/02/22 00:04:44 stevesk Exp $");
@


1.135
log
@move #include <ctype.h> out of includes.h; ok djm@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.134 2006/02/20 17:19:54 stevesk Exp $");
d1095 9
a1103 9
	if (fp == NULL && !(fp = fdopen(remout, "w")))
		return;
	(void) fprintf(fp, "%c", 0x01);
	(void) fprintf(fp, "scp: ");
	va_start(ap, fmt);
	(void) vfprintf(fp, fmt, ap);
	va_end(ap);
	(void) fprintf(fp, "\n");
	(void) fflush(fp);
@


1.135.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: scp.c,v 1.155 2006/08/03 03:34:42 deraadt Exp $ */
d73 3
a75 1
#include <sys/param.h>
a78 2
#include <sys/time.h>
#include <sys/uio.h>
a81 3
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
a82 6
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
d91 1
a91 1
int do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout);
d178 1
a178 1
do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout)
d192 1
a192 2
	if (pipe(reserved) < 0)
		fatal("pipe: %s", strerror(errno));
d245 1
d269 1
a269 1
	int ch, fflag, tflag, status, n;
d271 1
a271 1
	char *targ, *endp, **newargv;
a277 6
	/* Copy argv, because we modify it */
	newargv = xcalloc(MAX(argc + 1, 1), sizeof(*newargv));
	for (n = 0; n < argc; n++)
		newargv[n] = xstrdup(argv[n]);
	argv = newargv;

d415 1
a417 1
	int i;
d482 3
a484 1
				xasprintf(&bp, "%s -t %s", cmd, targ);
d487 1
a487 1
				    &remout) < 0)
a495 1
	xfree(arg);
d501 1
a503 1
	int i;
d535 4
a538 2
		xasprintf(&bp, "%s -f %s", cmd, src);
		if (do_cmd(host, suser, bp, &remin, &remout) < 0) {
d783 1
a783 2
	int amt, exists, first, ofd;
	mode_t mode, omode, mask;
d1095 9
a1103 9
	if (fp != NULL || (remout != -1 && (fp = fdopen(remout, "w")))) {
		(void) fprintf(fp, "%c", 0x01);
		(void) fprintf(fp, "scp: ");
		va_start(ap, fmt);
		(void) vfprintf(fp, fmt, ap);
		va_end(ap);
		(void) fprintf(fp, "\n");
		(void) fflush(fp);
	}
d1175 1
a1175 1
		bp->buf = xrealloc(bp->buf, 1, size);
@


1.134
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.133 2006/02/20 17:02:44 stevesk Exp $");
d80 1
@


1.133
log
@move #include <signal.h> out of includes.h; ok markus@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.132 2006/02/10 01:44:26 stevesk Exp $");
d78 1
@


1.132
log
@move #include <sys/wait.h> out of includes.h; ok markus@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.131 2006/02/08 23:51:24 stevesk Exp $");
d80 1
@


1.131
log
@move #include <dirent.h> out of includes.h; ok markus@@
@
text
@d74 4
a77 1
RCSID("$OpenBSD: scp.c,v 1.130 2006/01/31 10:35:43 djm Exp $");
@


1.130
log
@"scp a b c" shouldn't clobber "c" when it is not a directory, report and
fix from biorn@@; ok markus@@
@
text
@d74 3
a76 1
RCSID("$OpenBSD: scp.c,v 1.129 2006/01/31 10:19:02 djm Exp $");
@


1.129
log
@fix local arbitrary command execution vulnerability on local/local and
remote/remote copies (CVE-2006-0225, bz #1094), patch by
t8m AT centrum.cz, polished by dtucker@@ and myself; ok markus@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.128 2005/12/06 22:38:27 reyk Exp $");
a380 1
		tolocal(argc, argv);	/* Dest is local host. */
d383 1
@


1.128
log
@Add support for tun(4) forwarding over OpenSSH, based on an idea and
initial channel code bits by markus@@. This is a simple and easy way to
use OpenSSH for ad hoc virtual private network connections, e.g.
administrative tunnels or secure wireless access. It's based on a new
ssh channel and works similar to the existing TCP forwarding support,
except that it depends on the tun(4) network interface on both ends of
the connection for layer 2 or layer 3 tunneling. This diff also adds
support for LocalCommand in the ssh(1) client.

ok djm@@, markus@@, jmc@@ (manpages), tested and discussed with others
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.127 2005/11/12 18:38:15 deraadt Exp $");
d121 42
d207 1
a207 1
		args.list[0] = ssh_program;
d270 1
d272 1
a272 1
	addargs(&args, "ssh");		/* overwritten with ssh_program */
d409 4
d430 5
d438 8
a445 2
			static char *ssh_options =
			    "-x -o'ClearAllForwardings yes'";
d450 1
a450 5
			len = strlen(ssh_program) + strlen(argv[i]) +
			    strlen(src) + (tuser ? strlen(tuser) : 0) +
			    strlen(thost) + strlen(targ) +
			    strlen(ssh_options) + CMDNEEDS + 20;
			bp = xmalloc(len);
d457 1
a457 6
				else if (!okname(suser)) {
					xfree(bp);
					continue;
				}
				if (tuser && !okname(tuser)) {
					xfree(bp);
d459 2
a460 8
				}
				snprintf(bp, len,
				    "%s%s %s -n "
				    "-l %s %s %s %s '%s%s%s:%s'",
				    ssh_program, verbose_mode ? " -v" : "",
				    ssh_options, suser, host, cmd, src,
				    tuser ? tuser : "", tuser ? "@@" : "",
				    thost, targ);
a462 7
				snprintf(bp, len,
				    "exec %s%s %s -n %s "
				    "%s %s '%s%s%s:%s'",
				    ssh_program, verbose_mode ? " -v" : "",
				    ssh_options, host, cmd, src,
				    tuser ? tuser : "", tuser ? "@@" : "",
				    thost, targ);
d464 7
a470 3
			if (verbose_mode)
				fprintf(stderr, "Executing: %s\n", bp);
			if (system(bp) != 0)
a471 1
			(void) xfree(bp);
d495 4
d502 9
a510 9
			len = strlen(_PATH_CP) + strlen(argv[i]) +
			    strlen(argv[argc - 1]) + 20;
			bp = xmalloc(len);
			(void) snprintf(bp, len, "exec %s%s%s %s %s", _PATH_CP,
			    iamrecursive ? " -r" : "", pflag ? " -p" : "",
			    argv[i], argv[argc - 1]);
			if (verbose_mode)
				fprintf(stderr, "Executing: %s\n", bp);
			if (system(bp))
a511 1
			(void) xfree(bp);
@


1.127
log
@avoid close(-1), as in rcp; ok cloder
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.126 2005/09/13 23:40:07 djm Exp $");
d232 1
@


1.126
log
@ensure that stdio fds are attached; ok deraadt@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.125 2005/07/27 10:39:03 dtucker Exp $");
d569 4
a572 1
next:			(void) close(fd);
d601 5
a605 2
		if (close(fd) < 0 && !haderr)
			haderr = errno;
@


1.125
log
@Silence bogus -Wuninitialized warnings; ok djm@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.124 2005/06/17 02:44:33 djm Exp $");
d224 3
@


1.125.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.130 2006/01/31 10:35:43 djm Exp $");
a120 42
static int
do_local_cmd(arglist *a)
{
	u_int i;
	int status;
	pid_t pid;

	if (a->num == 0)
		fatal("do_local_cmd: no arguments");

	if (verbose_mode) {
		fprintf(stderr, "Executing:");
		for (i = 0; i < a->num; i++)
			fprintf(stderr, " %s", a->list[i]);
		fprintf(stderr, "\n");
	}
	if ((pid = fork()) == -1)
		fatal("do_local_cmd: fork: %s", strerror(errno));

	if (pid == 0) {
		execvp(a->list[0], a->list);
		perror(a->list[0]);
		exit(1);
	}

	do_cmd_pid = pid;
	signal(SIGTERM, killchild);
	signal(SIGINT, killchild);
	signal(SIGHUP, killchild);

	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("do_local_cmd: waitpid: %s", strerror(errno));

	do_cmd_pid = -1;

	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
		return (-1);

	return (0);
}

d165 1
a165 1
		replacearg(&args, 0, "%s", ssh_program);
a224 4
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	memset(&args, '\0', sizeof(args));
d226 1
a226 1
	addargs(&args, "%s", ssh_program);
a228 1
	addargs(&args, "-oPermitLocalCommand no");
d334 1
a336 1
		tolocal(argc, argv);	/* Dest is local host. */
a361 4
	arglist alist;

	memset(&alist, '\0', sizeof(alist));
	alist.list = NULL;
a378 5
	if (tuser != NULL && !okname(tuser)) {
		xfree(arg);
		return;
	}

d382 2
a383 8
			freeargs(&alist);
			addargs(&alist, "%s", ssh_program);
			if (verbose_mode)
				addargs(&alist, "-v");
			addargs(&alist, "-x");
			addargs(&alist, "-oClearAllForwardings yes");
			addargs(&alist, "-n");

d388 5
a392 1

d399 2
a400 1
				else if (!okname(suser))
d402 12
a413 2
				addargs(&alist, "-l");
				addargs(&alist, "%s", suser);
d416 7
d424 3
a426 7
			addargs(&alist, "%s", host);
			addargs(&alist, "%s", cmd);
			addargs(&alist, "%s", src);
			addargs(&alist, "%s%s%s:%s",
			    tuser ? tuser : "", tuser ? "@@" : "",
			    thost, targ);
			if (do_local_cmd(&alist) != 0)
d428 1
a451 4
	arglist alist;

	memset(&alist, '\0', sizeof(alist));
	alist.list = NULL;
d455 9
a463 9
			freeargs(&alist);
			addargs(&alist, "%s", _PATH_CP);
			if (iamrecursive)
				addargs(&alist, "-r");
			if (pflag)
				addargs(&alist, "-p");
			addargs(&alist, "%s", argv[i]);
			addargs(&alist, "%s", argv[argc-1]);
			if (do_local_cmd(&alist))
d465 1
d566 1
a566 4
next:			if (fd != -1) {
				(void) close(fd);
				fd = -1;
			}
d595 2
a596 5
		if (fd != -1) {
			if (close(fd) < 0 && !haderr)
				haderr = errno;
			fd = -1;
		}
@


1.125.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: scp.c,v 1.155 2006/08/03 03:34:42 deraadt Exp $ */
d73 2
a74 19
#include <sys/param.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/uio.h>

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
d83 1
a83 1
int do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout);
d170 1
a170 1
do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout)
d184 1
a184 2
	if (pipe(reserved) < 0)
		fatal("pipe: %s", strerror(errno));
d237 1
d261 1
a261 1
	int ch, fflag, tflag, status, n;
d263 1
a263 1
	char *targ, *endp, **newargv;
a269 6
	/* Copy argv, because we modify it */
	newargv = xcalloc(MAX(argc + 1, 1), sizeof(*newargv));
	for (n = 0; n < argc; n++)
		newargv[n] = xstrdup(argv[n]);
	argv = newargv;

d407 1
a409 1
	int i;
d474 3
a476 1
				xasprintf(&bp, "%s -t %s", cmd, targ);
d479 1
a479 1
				    &remout) < 0)
a487 1
	xfree(arg);
d493 1
a495 1
	int i;
d527 4
a530 2
		xasprintf(&bp, "%s -f %s", cmd, src);
		if (do_cmd(host, suser, bp, &remin, &remout) < 0) {
d775 1
a775 2
	int amt, exists, first, ofd;
	mode_t mode, omode, mask;
d1087 9
a1095 9
	if (fp != NULL || (remout != -1 && (fp = fdopen(remout, "w")))) {
		(void) fprintf(fp, "%c", 0x01);
		(void) fprintf(fp, "scp: ");
		va_start(ap, fmt);
		(void) vfprintf(fp, fmt, ap);
		va_end(ap);
		(void) fprintf(fp, "\n");
		(void) fflush(fp);
	}
d1167 1
a1167 1
		bp->buf = xrealloc(bp->buf, 1, size);
@


1.124
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.123 2005/05/26 02:08:05 avsm Exp $");
d504 1
a504 1
	int fd, haderr, indx;
@


1.123
log
@If copying multiple files to a target file (which normally fails, as it
must be a target directory), kill the spawned ssh child before exiting.
This stops it trying to authenticate and spewing lots of output.
deraadt@@ ok
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.122 2005/05/24 17:32:43 avsm Exp $");
d189 1
a189 1
	int cnt;
d722 2
a723 2
	size_t j;
	int amt, count, exists, first, mask, mode, ofd, omode;
d831 1
a831 1
			static int cursize;
@


1.122
log
@Switch atomicio to use a simpler interface; it now returns a size_t
(containing number of bytes read/written), and indicates error by
returning 0.  EOF is signalled by errno==EPIPE.
Typical use now becomes:

if (atomicio(read, ..., len) != len)
        err(1,"read");

ok deraadt@@, cloder@@, djm@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.121 2005/04/02 12:41:16 djm Exp $");
d112 1
a112 1
		kill(do_cmd_pid, signo);
d116 3
a118 1
	_exit(1);
d1064 1
a1064 1
	exit(1);
@


1.121
log
@since ssh has xstrdup, use it instead of strdup+test. unbreaks -Werror build
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.120 2005/03/31 18:39:21 deraadt Exp $");
d500 2
a501 1
	off_t i, amt, result, statbytes;
d577 1
a577 1
					haderr = result >= 0 ? EIO : errno;
d584 1
a584 1
					haderr = result >= 0 ? EIO : errno;
d719 2
a720 1
	off_t i, j;
d748 1
a748 1
		if (atomicio(read, remin, cp, 1) <= 0)
d902 1
a902 1
				if (j <= 0) {
d918 2
a919 2
					j = atomicio(vwrite, ofd, bp->buf, count);
					if (j != count) {
d921 1
a921 1
						wrerrno = j >= 0 ? EIO : errno;
d931 1
a931 1
		    (j = atomicio(vwrite, ofd, bp->buf, count)) != count) {
d933 1
a933 1
			wrerrno = j >= 0 ? EIO : errno;
@


1.120
log
@copy argv[] element instead of smashing the one that ps will see; ok otto
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.119 2005/01/24 10:22:06 dtucker Exp $");
d365 1
a365 3
	arg = strdup(argv[argc - 1]);
	if (!arg)
		err(1, "malloc");
@


1.119
log
@Have scp and sftp wait for the spawned ssh to exit before they exit
themselves.  This prevents ssh from being unable to restore terminal
modes (not normally a problem on OpenBSD but common with -Portable
on POSIX platforms).  From peak at argo.troja.mff.cuni.cz (bz#950);
ok djm@@ markus@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.118 2004/09/15 18:46:04 deraadt Exp $");
d359 1
a359 1
	char *bp, *host, *src, *suser, *thost, *tuser;
d365 4
a368 1
	if ((thost = strrchr(argv[argc - 1], '@@'))) {
d371 1
a371 1
		tuser = argv[argc - 1];
d375 1
a375 1
		thost = argv[argc - 1];
@


1.119.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.125 2005/07/27 10:39:03 dtucker Exp $");
d112 1
a112 1
		kill(do_cmd_pid, signo ? signo : SIGTERM);
d116 1
a116 3
	if (signo)
		_exit(1);
	exit(1);
d187 1
a187 1
	size_t cnt;
d359 1
a359 1
	char *bp, *host, *src, *suser, *thost, *tuser, *arg;
d365 1
a365 2
	arg = xstrdup(argv[argc - 1]);
	if ((thost = strrchr(arg, '@@'))) {
d368 1
a368 1
		tuser = arg;
d372 1
a372 1
		thost = arg;
d499 2
a500 3
	off_t i, amt, statbytes;
	size_t result;
	int fd = -1, haderr, indx;
d575 1
a575 1
					haderr = errno;
d582 1
a582 1
					haderr = errno;
d717 2
a718 3
	off_t i;
	size_t j, count;
	int amt, exists, first, mask, mode, ofd, omode;
d745 1
a745 1
		if (atomicio(read, remin, cp, 1) != 1)
d826 1
a826 1
			static size_t cursize;
d899 1
a899 1
				if (j == 0) {
d915 2
a916 2
					if (atomicio(vwrite, ofd, bp->buf,
					    count) != count) {
d918 1
a918 1
						wrerrno = errno;
d928 1
a928 1
		    atomicio(vwrite, ofd, bp->buf, count) != count) {
d930 1
a930 1
			wrerrno = errno;
d1059 1
a1059 1
	killchild(0);
@


1.119.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.130 2006/01/31 10:35:43 djm Exp $");
a120 42
static int
do_local_cmd(arglist *a)
{
	u_int i;
	int status;
	pid_t pid;

	if (a->num == 0)
		fatal("do_local_cmd: no arguments");

	if (verbose_mode) {
		fprintf(stderr, "Executing:");
		for (i = 0; i < a->num; i++)
			fprintf(stderr, " %s", a->list[i]);
		fprintf(stderr, "\n");
	}
	if ((pid = fork()) == -1)
		fatal("do_local_cmd: fork: %s", strerror(errno));

	if (pid == 0) {
		execvp(a->list[0], a->list);
		perror(a->list[0]);
		exit(1);
	}

	do_cmd_pid = pid;
	signal(SIGTERM, killchild);
	signal(SIGINT, killchild);
	signal(SIGHUP, killchild);

	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("do_local_cmd: waitpid: %s", strerror(errno));

	do_cmd_pid = -1;

	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
		return (-1);

	return (0);
}

d165 1
a165 1
		replacearg(&args, 0, "%s", ssh_program);
a224 4
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	memset(&args, '\0', sizeof(args));
d226 1
a226 1
	addargs(&args, "%s", ssh_program);
a228 1
	addargs(&args, "-oPermitLocalCommand no");
d334 1
a336 1
		tolocal(argc, argv);	/* Dest is local host. */
a361 4
	arglist alist;

	memset(&alist, '\0', sizeof(alist));
	alist.list = NULL;
a378 5
	if (tuser != NULL && !okname(tuser)) {
		xfree(arg);
		return;
	}

d382 2
a383 8
			freeargs(&alist);
			addargs(&alist, "%s", ssh_program);
			if (verbose_mode)
				addargs(&alist, "-v");
			addargs(&alist, "-x");
			addargs(&alist, "-oClearAllForwardings yes");
			addargs(&alist, "-n");

d388 5
a392 1

d399 2
a400 1
				else if (!okname(suser))
d402 12
a413 2
				addargs(&alist, "-l");
				addargs(&alist, "%s", suser);
d416 7
d424 3
a426 7
			addargs(&alist, "%s", host);
			addargs(&alist, "%s", cmd);
			addargs(&alist, "%s", src);
			addargs(&alist, "%s%s%s:%s",
			    tuser ? tuser : "", tuser ? "@@" : "",
			    thost, targ);
			if (do_local_cmd(&alist) != 0)
d428 1
a451 4
	arglist alist;

	memset(&alist, '\0', sizeof(alist));
	alist.list = NULL;
d455 9
a463 9
			freeargs(&alist);
			addargs(&alist, "%s", _PATH_CP);
			if (iamrecursive)
				addargs(&alist, "-r");
			if (pflag)
				addargs(&alist, "-p");
			addargs(&alist, "%s", argv[i]);
			addargs(&alist, "%s", argv[argc-1]);
			if (do_local_cmd(&alist))
d465 1
d566 1
a566 4
next:			if (fd != -1) {
				(void) close(fd);
				fd = -1;
			}
d595 2
a596 5
		if (fd != -1) {
			if (close(fd) < 0 && !haderr)
				haderr = errno;
			fd = -1;
		}
@


1.118
log
@scratch that do { } while (0) wrapper in this case
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.117 2004/08/11 21:44:32 avsm Exp $");
d111 1
a111 1
	if (do_cmd_pid > 1)
d113 2
@


1.117
log
@use atomicio instead of homegrown equivalents or read/write.
markus@@ ok
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.116 2004/07/08 12:47:21 dtucker Exp $");
d724 1
a724 1
#define	SCREWUP(str)	do { why = str; goto screwup; } while (0)
@


1.117.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.119 2005/01/24 10:22:06 dtucker Exp $");
d111 1
a111 1
	if (do_cmd_pid > 1) {
a112 2
		waitpid(do_cmd_pid, NULL, 0);
	}
d724 1
a724 1
#define	SCREWUP(str)	{ why = str; goto screwup; }
@


1.117.2.2
log
@upgrade to OpenSSH 4.2
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.125 2005/07/27 10:39:03 dtucker Exp $");
d112 1
a112 1
		kill(do_cmd_pid, signo ? signo : SIGTERM);
d116 1
a116 3
	if (signo)
		_exit(1);
	exit(1);
d187 1
a187 1
	size_t cnt;
d359 1
a359 1
	char *bp, *host, *src, *suser, *thost, *tuser, *arg;
d365 1
a365 2
	arg = xstrdup(argv[argc - 1]);
	if ((thost = strrchr(arg, '@@'))) {
d368 1
a368 1
		tuser = arg;
d372 1
a372 1
		thost = arg;
d499 2
a500 3
	off_t i, amt, statbytes;
	size_t result;
	int fd = -1, haderr, indx;
d575 1
a575 1
					haderr = errno;
d582 1
a582 1
					haderr = errno;
d717 2
a718 3
	off_t i;
	size_t j, count;
	int amt, exists, first, mask, mode, ofd, omode;
d745 1
a745 1
		if (atomicio(read, remin, cp, 1) != 1)
d826 1
a826 1
			static size_t cursize;
d899 1
a899 1
				if (j == 0) {
d915 2
a916 2
					if (atomicio(vwrite, ofd, bp->buf,
					    count) != count) {
d918 1
a918 1
						wrerrno = errno;
d928 1
a928 1
		    atomicio(vwrite, ofd, bp->buf, count) != count) {
d930 1
a930 1
			wrerrno = errno;
d1059 1
a1059 1
	killchild(0);
@


1.116
log
@Prevent scp from skipping the file following a double-error.
bz #863, ok markus@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.115 2004/06/21 17:36:31 avsm Exp $");
d896 2
a897 5
				j = read(remin, cp, amt);
				if (j == -1 && (errno == EINTR ||
				    errno == EAGAIN)) {
					continue;
				} else if (j <= 0) {
@


1.115
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.114 2004/04/01 12:19:57 markus Exp $");
d939 1
a939 1
				if (fchmod(ofd, omode))
d942 2
d946 1
a946 1
				if (fchmod(ofd, omode & ~mask))
d949 2
@


1.114
log
@limit trust between local and remote rcp/scp process,
noticed by lcamtuf; ok deraadt@@, djm@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.113 2003/11/23 23:21:21 djm Exp $");
d657 1
a657 1
	u_int64_t wait;
d675 1
a675 1
	wait = (double)1000000L * lamt / limit_rate;
d677 2
a678 2
	bwstart.tv_sec = wait / 1000000L;
	bwstart.tv_usec = wait % 1000000L;
@


1.113
log
@from portable: rename clashing variable limit-> limit_rate; ok markus@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.112 2003/11/21 11:57:03 djm Exp $");
d753 2
d818 4
d843 2
@


1.113.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.117 2004/08/11 21:44:32 avsm Exp $");
d657 1
a657 1
	u_int64_t waitlen;
d675 1
a675 1
	waitlen = (double)1000000L * lamt / limit_rate;
d677 2
a678 2
	bwstart.tv_sec = waitlen / 1000000L;
	bwstart.tv_usec = waitlen % 1000000L;
a752 2
		if (verbose_mode)
			fprintf(stderr, "Sink: %s", buf);
a815 4
		if ((strchr(cp, '/') != NULL) || (strcmp(cp, "..") == 0)) {
			run_err("error: unexpected filename: %s", cp);
			exit(1);
		}
a836 2
			if (!iamrecursive)
				SCREWUP("received directory without -r");
d888 5
a892 2
				j = atomicio(read, remin, cp, amt);
				if (j <= 0) {
d931 1
a931 1
				if (fchmod(ofd, omode)) {
a933 2
					wrerr = DISPLAYED;
				}
d936 1
a936 1
				if (fchmod(ofd, omode & ~mask)) {
a938 2
					wrerr = DISPLAYED;
				}
@


1.113.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.119 2005/01/24 10:22:06 dtucker Exp $");
d111 1
a111 1
	if (do_cmd_pid > 1) {
a112 2
		waitpid(do_cmd_pid, NULL, 0);
	}
d724 1
a724 1
#define	SCREWUP(str)	{ why = str; goto screwup; }
@


1.112
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.111 2003/11/12 10:12:15 dtucker Exp $");
d91 1
a91 1
off_t limit = 0;
d254 1
a254 1
			limit = speed * 1024;
d583 1
a583 1
			if (limit)
d675 1
a675 1
	wait = (double)1000000L * lamt / limit;
d902 1
a902 1
			if (limit)
@


1.111
log
@When called with -q, pass -q to ssh; suppresses SSH2 banner.  ok markus@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.110 2003/10/08 08:27:36 jmc Exp $");
d901 1
a901 1
		
@


1.110
log
@scp and sftp: add options list and sort options. options list requested
by deraadt@@
sshd: use same format as ssh
ssh: remove wrong option from list
sftp-server: Subsystem is documented in ssh_config(5), not sshd(8)

ok deraadt@@ markus@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.109 2003/09/19 17:40:20 markus Exp $");
d270 1
@


1.109
log
@error handling for remote-remote copy; #638; report Harald Koenig;
ok millert, fgs, henning, deraadt
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.108 2003/07/18 01:54:25 deraadt Exp $");
d1005 2
a1006 2
	    "usage: scp [-pqrvBC1246] [-F config] [-S program] [-P port]\n"
	    "           [-c cipher] [-i identity] [-l limit] [-o option]\n"
@


1.108
log
@userid is unsigned, but well, force it anyways; andrushock@@korovino.net
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.107 2003/06/28 16:23:06 deraadt Exp $");
d420 2
a421 1
			(void) system(bp);
@


1.108.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.113 2003/11/23 23:21:21 djm Exp $");
d91 1
a91 1
off_t limit_rate = 0;
d254 1
a254 1
			limit_rate = speed * 1024;
a269 1
			addargs(&args, "-q");
d420 1
a420 2
			if (system(bp) != 0)
				errs = 1;
d581 1
a581 1
			if (limit_rate)
d673 1
a673 1
	wait = (double)1000000L * lamt / limit_rate;
d899 2
a900 2

			if (limit_rate)
d1004 2
a1005 2
	    "usage: scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\n"
	    "           [-l limit] [-o ssh_option] [-P port] [-S program]\n"
@


1.108.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.117 2004/08/11 21:44:32 avsm Exp $");
d657 1
a657 1
	u_int64_t waitlen;
d675 1
a675 1
	waitlen = (double)1000000L * lamt / limit_rate;
d677 2
a678 2
	bwstart.tv_sec = waitlen / 1000000L;
	bwstart.tv_usec = waitlen % 1000000L;
a752 2
		if (verbose_mode)
			fprintf(stderr, "Sink: %s", buf);
a815 4
		if ((strchr(cp, '/') != NULL) || (strcmp(cp, "..") == 0)) {
			run_err("error: unexpected filename: %s", cp);
			exit(1);
		}
a836 2
			if (!iamrecursive)
				SCREWUP("received directory without -r");
d888 5
a892 2
				j = atomicio(read, remin, cp, amt);
				if (j <= 0) {
d931 1
a931 1
				if (fchmod(ofd, omode)) {
a933 2
					wrerr = DISPLAYED;
				}
d936 1
a936 1
				if (fchmod(ofd, omode & ~mask)) {
a938 2
					wrerr = DISPLAYED;
				}
@


1.107
log
@deal with typing of write vs read in atomicio
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.106 2003/06/12 15:34:09 nino Exp $");
d292 1
a292 1
		fatal("unknown user %d", (int) userid);
@


1.106
log
@Typo.

Ok markus@@.
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.105 2003/06/04 12:40:39 djm Exp $");
d543 1
a543 1
			(void) atomicio(write, remout, buf, strlen(buf));
d554 1
a554 1
		(void) atomicio(write, remout, buf, strlen(buf));
d574 1
a574 1
				(void) atomicio(write, remout, bp->buf, amt);
d576 1
a576 1
				result = atomicio(write, remout, bp->buf, amt);
d590 1
a590 1
			(void) atomicio(write, remout, "", 1);
d617 1
a617 1
		(void) atomicio(write, remout, path, strlen(path));
d627 1
a627 1
	(void) atomicio(write, remout, path, strlen(path));
d646 1
a646 1
	(void) atomicio(write, remout, "E\n", 2);
d736 1
a736 1
	(void) atomicio(write, remout, "", 1);
d754 1
a754 1
				(void) atomicio(write, STDERR_FILENO,
d762 1
a762 1
			(void) atomicio(write, remout, "", 1);
d784 1
a784 1
			(void) atomicio(write, remout, "", 1);
d869 1
a869 1
		(void) atomicio(write, remout, "", 1);
d906 1
a906 1
					j = atomicio(write, ofd, bp->buf, count);
d919 1
a919 1
		    (j = atomicio(write, ofd, bp->buf, count)) != count) {
d956 1
a956 1
			(void) atomicio(write, remout, "", 1);
d991 1
a991 1
			(void) atomicio(write, STDERR_FILENO, rbuf, cp - rbuf);
@


1.105
log
@kill ssh process upon receipt of signal, bz #241.
based on patch from esb AT hawaii.edu; ok markus@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.104 2003/06/04 12:18:49 djm Exp $");
d150 1
a150 1
	/* For a child to execute the command on the remote host using ssh. */
@


1.104
log
@ansify; ok markus@@
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.103 2003/06/03 02:56:16 millert Exp $");
d106 10
a115 1
pid_t do_cmd_pid;
d178 3
@


1.103
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.102 2003/03/05 22:33:43 markus Exp $");
d201 1
a201 3
main(argc, argv)
	int argc;
	char *argv[];
d341 1
a341 3
toremote(targ, argc, argv)
	char *targ, *argv[];
	int argc;
d429 1
a429 3
tolocal(argc, argv)
	int argc;
	char *argv[];
d478 1
a478 3
source(argc, argv)
	int argc;
	char *argv[];
d586 1
a586 3
rsource(name, statp)
	char *name;
	struct stat *statp;
d693 1
a693 3
sink(argc, argv)
	int argc;
	char *argv[];
d1024 1
a1024 2
verifydir(cp)
	char *cp;
d1038 1
a1038 2
okname(cp0)
	char *cp0;
d1068 1
a1068 3
allocbuf(bp, fd, blksize)
	BUF *bp;
	int fd, blksize;
d1092 1
a1092 2
lostconn(signo)
	int signo;
@


1.102
log
@fix memory leaks; from dlheine@@suif.Stanford.EDU/CLOUSEAU; ok djm@@
@
text
@d55 1
a55 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.101 2003/02/02 10:51:13 markus Exp $");
@


1.102.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d55 5
a59 1
 * 3. Neither the name of the University nor the names of its contributors
d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.108 2003/07/18 01:54:25 deraadt Exp $");
d110 1
a110 10
pid_t do_cmd_pid = -1;

static void
killchild(int signo)
{
	if (do_cmd_pid > 1)
		kill(do_cmd_pid, signo);

	_exit(1);
}
d145 1
a145 1
	/* Fork a child to execute the command on the remote host using ssh. */
a172 3
	signal(SIGTERM, killchild);
	signal(SIGINT, killchild);
	signal(SIGHUP, killchild);
d205 3
a207 1
main(int argc, char **argv)
d286 1
a286 1
		fatal("unknown user %u", (u_int) userid);
d347 3
a349 1
toremote(char *targ, int argc, char **argv)
d437 3
a439 1
tolocal(int argc, char **argv)
d488 3
a490 1
source(int argc, char **argv)
d543 1
a543 1
			(void) atomicio(vwrite, remout, buf, strlen(buf));
d554 1
a554 1
		(void) atomicio(vwrite, remout, buf, strlen(buf));
d574 1
a574 1
				(void) atomicio(vwrite, remout, bp->buf, amt);
d576 1
a576 1
				result = atomicio(vwrite, remout, bp->buf, amt);
d590 1
a590 1
			(void) atomicio(vwrite, remout, "", 1);
d598 3
a600 1
rsource(char *name, struct stat *statp)
d619 1
a619 1
		(void) atomicio(vwrite, remout, path, strlen(path));
d629 1
a629 1
	(void) atomicio(vwrite, remout, path, strlen(path));
d648 1
a648 1
	(void) atomicio(vwrite, remout, "E\n", 2);
d707 3
a709 1
sink(int argc, char **argv)
d740 1
a740 1
	(void) atomicio(vwrite, remout, "", 1);
d758 1
a758 1
				(void) atomicio(vwrite, STDERR_FILENO,
d766 1
a766 1
			(void) atomicio(vwrite, remout, "", 1);
d788 1
a788 1
			(void) atomicio(vwrite, remout, "", 1);
d873 1
a873 1
		(void) atomicio(vwrite, remout, "", 1);
d910 1
a910 1
					j = atomicio(vwrite, ofd, bp->buf, count);
d923 1
a923 1
		    (j = atomicio(vwrite, ofd, bp->buf, count)) != count) {
d960 1
a960 1
			(void) atomicio(vwrite, remout, "", 1);
d995 1
a995 1
			(void) atomicio(vwrite, STDERR_FILENO, rbuf, cp - rbuf);
d1040 2
a1041 1
verifydir(char *cp)
d1055 2
a1056 1
okname(char *cp0)
d1086 3
a1088 1
allocbuf(BUF *bp, int fd, int blksize)
d1112 2
a1113 1
lostconn(int signo)
@


1.102.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.113 2003/11/23 23:21:21 djm Exp $");
d91 1
a91 1
off_t limit_rate = 0;
d254 1
a254 1
			limit_rate = speed * 1024;
a269 1
			addargs(&args, "-q");
d420 1
a420 2
			if (system(bp) != 0)
				errs = 1;
d581 1
a581 1
			if (limit_rate)
d673 1
a673 1
	wait = (double)1000000L * lamt / limit_rate;
d899 2
a900 2

			if (limit_rate)
d1004 2
a1005 2
	    "usage: scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\n"
	    "           [-l limit] [-o ssh_option] [-P port] [-S program]\n"
@


1.101
log
@call okname() only when using system(3) for remote-remote copy;
fixes bugs #483, #472; ok deraadt@@, mouring@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.100 2003/01/23 14:06:15 markus Exp $");
d389 2
a390 1
				else if (!okname(suser))
d392 3
a394 1
				if (tuser && !okname(tuser))
d396 1
@


1.100
log
@scp -12; Sam Smith and others; ok provos@@, deraadt@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.99 2003/01/23 14:01:53 markus Exp $");
a363 2
		else if (!okname(tuser))
			exit(1);
d391 2
a465 2
			else if (!okname(suser))
				continue;
d1062 12
a1073 3
		if (!isalpha(c) && !isdigit(c) &&
		    c != '@@' && c != '_' && c != '-' && c != '.' && c != '+')
			goto bad;
@


1.99
log
@bandwidth limitation patch (scp -l) from niels@@; ok todd@@, deraadt@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.98 2003/01/10 10:29:35 djm Exp $");
d222 1
a222 1
	while ((ch = getopt(argc, argv, "dfl:prtvBCc:i:P:q46S:o:F:")) != -1)
d225 2
d1006 1
a1006 1
	    "usage: scp [-pqrvBC46] [-F config] [-S program] [-P port]\n"
@


1.98
log
@Don't ftruncate after write error, creating sparse files of incorrect length
mindrot bug #403, reported by rusr@@cup.hp.com; ok markus@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.97 2003/01/10 08:19:07 fgsch Exp $");
d89 2
d94 3
d210 2
a211 1
	char *targ;
d222 1
a222 1
	while ((ch = getopt(argc, argv, "dfprtvBCc:i:P:q46S:o:F:")) != -1)
d242 6
d577 2
d649 54
d899 4
d1005 1
a1005 1
	    "           [-c cipher] [-i identity] [-o option]\n"
@


1.97
log
@sftp progress meter support.
original diffs by Nils Nordman <nino at nforced dot com> via markus@@, merged
to -current by me, djm@@ ok.
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.95 2002/12/05 11:08:35 markus Exp $");
d851 1
a851 1
		if (ftruncate(ofd, size)) {
@


1.96
log
@1) include stalling time in total time
2) truncate filenames to 45 instead of 20 characters
3) print rate instead of progress bar, no more stars
4) scale output to tty width
based on a patch from Niels; ok fries@@ lebel@@ fgs@@ millert@@
@
text
@d85 1
a86 10
/* For progressmeter() -- number of seconds before xfer considered "stalled" */
#define STALLTIME	5
/* alarm() interval for updating progress meter */
#define PROGRESSTIME	1

/* Visual statistics about files as they are transferred. */
void progressmeter(int);

/* Returns width of the terminal (for progress meter calculations). */
int getttywidth(void);
a91 9
/* Time a transfer started. */
static struct timeval start;

/* Number of bytes of current file transferred so far. */
volatile off_t statbytes;

/* Total size of current file. */
off_t totalbytes = 0;

d479 1
a479 1
	off_t i, amt, result;
d545 2
a546 4
		if (showprogress) {
			totalbytes = stb.st_size;
			progressmeter(-1);
		}
d567 1
a567 1
			progressmeter(1);
d647 1
a647 1
	off_t size;
a808 4
		if (showprogress) {
			totalbytes = size;
			progressmeter(-1);
		}
d810 2
d845 1
a845 1
			progressmeter(1);
a1035 146
}

static void
updateprogressmeter(int ignore)
{
	int save_errno = errno;

	progressmeter(0);
	signal(SIGALRM, updateprogressmeter);
	alarm(PROGRESSTIME);
	errno = save_errno;
}

static int
foregroundproc(void)
{
	static pid_t pgrp = -1;
	int ctty_pgrp;

	if (pgrp == -1)
		pgrp = getpgrp();

	return ((ioctl(STDOUT_FILENO, TIOCGPGRP, &ctty_pgrp) != -1 &&
		 ctty_pgrp == pgrp));
}

void
progressmeter(int flag)
{
	static const char spaces[] = "                          "
	    "                                                   "
	    "                                                   "
	    "                                                   "
	    "                                                   "
	    "                                                   ";
	static const char prefixes[] = " KMGTP";
	static struct timeval lastupdate;
	static off_t lastsize;
	struct timeval now, td, wait;
	off_t cursize, abbrevsize, bytespersec;
	double elapsed;
	int ratio, remaining, i, ai, bi, nspaces;
	char buf[512];

	if (flag == -1) {
		(void) gettimeofday(&start, (struct timezone *) 0);
		lastupdate = start;
		lastsize = 0;
	}
	if (foregroundproc() == 0)
		return;

	(void) gettimeofday(&now, (struct timezone *) 0);
	cursize = statbytes;
	if (totalbytes != 0) {
		ratio = 100.0 * cursize / totalbytes;
		ratio = MAX(ratio, 0);
		ratio = MIN(ratio, 100);
	} else
		ratio = 100;

	abbrevsize = cursize;
	for (ai = 0; abbrevsize >= 10000 && ai < sizeof(prefixes); ai++)
		abbrevsize >>= 10;

	timersub(&now, &lastupdate, &wait);
	if (cursize > lastsize) {
		lastupdate = now;
		lastsize = cursize;
		wait.tv_sec = 0;
	}
	timersub(&now, &start, &td);
	elapsed = td.tv_sec + (td.tv_usec / 1000000.0);

	bytespersec = 0;
	if (statbytes > 0) {
		bytespersec = statbytes;
		if (elapsed > 0.0)
			bytespersec /= elapsed;
	}
	for (bi = 1; bytespersec >= 1024000 && bi < sizeof(prefixes); bi++)
		bytespersec >>= 10;

    	nspaces = MIN(getttywidth() - 79, sizeof(spaces) - 1);

	snprintf(buf, sizeof(buf),
	    "\r%-45.45s%.*s%3d%% %4lld%c%c %3lld.%01d%cB/s",
	    curfile,
	    nspaces,
	    spaces,
	    ratio,
	    (long long)abbrevsize,
	    prefixes[ai],
	    ai == 0 ? ' ' : 'B',
	    (long long)(bytespersec / 1024),
	    (int)((bytespersec % 1024) * 10 / 1024),
	    prefixes[bi]
	);

	if (flag != 1 &&
	    (statbytes <= 0 || elapsed <= 0.0 || cursize > totalbytes)) {
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    "   --:-- ETA");
	} else if (wait.tv_sec >= STALLTIME) {
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    " - stalled -");
	} else {
		if (flag != 1)
			remaining = (int)(totalbytes / (statbytes / elapsed) -
			    elapsed);
		else
			remaining = elapsed;

		i = remaining / 3600;
		if (i)
			snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
			    "%2d:", i);
		else
			snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
			    "   ");
		i = remaining % 3600;
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    "%02d:%02d%s", i / 60, i % 60,
		    (flag != 1) ? " ETA" : "    ");
	}
	atomicio(write, fileno(stdout), buf, strlen(buf));

	if (flag == -1) {
		signal(SIGALRM, updateprogressmeter);
		alarm(PROGRESSTIME);
	} else if (flag == 1) {
		alarm(0);
		atomicio(write, fileno(stdout), "\n", 1);
		statbytes = 0;
	}
}

int
getttywidth(void)
{
	struct winsize winsize;

	if (ioctl(fileno(stdout), TIOCGWINSZ, &winsize) != -1)
		return (winsize.ws_col ? winsize.ws_col : 80);
	else
		return (80);
@


1.95
log
@use roundup() similar to rcp/util.c and avoid problems with strange
filesystem block sizes, noted by tjr@@freebsd.org; ok djm@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.94 2002/11/27 17:53:35 markus Exp $");
d1087 6
d1097 1
a1097 1
	off_t cursize, abbrevsize;
d1099 1
a1099 1
	int ratio, barlength, i, remaining;
a1118 17
	snprintf(buf, sizeof(buf), "\r%-20.20s %3d%% ", curfile, ratio);

	barlength = getttywidth() - 51;
	if (barlength > 0) {
		i = barlength * ratio / 100;
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    "|%.*s%*s|", i,
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************",
		    barlength - i, "");
	}
	i = 0;
d1120 1
a1120 2
	while (abbrevsize >= 100000 && i < sizeof(prefixes)) {
		i++;
a1121 4
	}
	snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " %5llu %c%c ",
	    (unsigned long long) abbrevsize, prefixes[i],
	    prefixes[i] == ' ' ? ' ' : 'B');
a1126 4
		if (wait.tv_sec >= STALLTIME) {
			start.tv_sec += wait.tv_sec;
			start.tv_usec += wait.tv_usec;
		}
d1131 25
@


1.94
log
@allow usernames with embedded '@@', e.g. scp user@@vhost@@realhost:file /tmp;
http://bugzilla.mindrot.org/show_bug.cgi?id=447; ok mouring@@, millert@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.93 2002/11/26 00:45:03 wcobb Exp $");
d1034 2
a1035 1
	if (stb.st_blksize == 0)
a1036 3
	else
		size = blksize + (stb.st_blksize - blksize % stb.st_blksize) %
		    stb.st_blksize;
@


1.93
log
@Remove unnecessary fflush(stderr) calls, stderr is unbuffered by default.
ok markus@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.92 2002/11/07 22:35:38 markus Exp $");
d362 1
a362 1
	if ((thost = strchr(argv[argc - 1], '@@'))) {
d383 1
a383 1
			host = strchr(argv[i], '@@');
d462 1
a462 1
		if ((host = strchr(argv[i], '@@')) == NULL) {
d1013 1
a1013 1
		    c != '_' && c != '-' && c != '.' && c != '+')
@


1.92
log
@check exit status from ssh, and exit(1) if ssh fails; bug#369; binder@@arago.de
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.91 2002/06/19 00:27:55 deraadt Exp $");
a554 1
			fflush(stderr);
@


1.91
log
@KNF done automatically while reading....
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.90 2002/06/17 06:05:56 deraadt Exp $");
d122 3
d159 2
a160 1
	if (fork() == 0)  {
d178 2
d222 1
a222 1
	int ch, fflag, tflag;
d315 1
d330 16
@


1.91.2.1
log
@Update to OpenSSH 3.6
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.102 2003/03/05 22:33:43 markus Exp $");
a84 1
#include "progressmeter.h"
d86 10
a97 2
void bwlimit(int);

d101 8
a108 2
/* Bandwidth limit */
off_t limit = 0;
a121 3
/* This is used to store the pid of ssh_program */
pid_t do_cmd_pid;

d156 1
a156 2
	do_cmd_pid = fork();
	if (do_cmd_pid == 0) {
a173 2
	} else if (do_cmd_pid == -1) {
		fatal("fork: %s", strerror(errno));
d216 2
a217 3
	int ch, fflag, tflag, status;
	double speed;
	char *targ, *endp;
d228 1
a228 1
	while ((ch = getopt(argc, argv, "dfl:prtvBCc:i:P:q1246S:o:F:")) != -1)
a230 2
		case '1':
		case '2':
a247 6
		case 'l':
			speed = strtod(optarg, &endp);
			if (speed <= 0 || *endp != '\0')
				usage();
			limit = speed * 1024;
			break;
a308 1
	do_cmd_pid = -1;
a323 16
	/*
	 * Finally check the exit status of the ssh process, if one was forked
	 * and no error has occured yet
	 */
	if (do_cmd_pid != -1 && errs == 0) {
		if (remin != -1)
		    (void) close(remin);
		if (remout != -1)
		    (void) close(remout);
		if (waitpid(do_cmd_pid, &status, 0) == -1)
			errs = 1;
		else {
			if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
				errs = 1;
		}
	}
d339 1
a339 1
	if ((thost = strrchr(argv[argc - 1], '@@'))) {
d345 2
d360 1
a360 1
			host = strrchr(argv[i], '@@');
d372 1
a372 2
				else if (!okname(suser)) {
					xfree(bp);
a373 5
				}
				if (tuser && !okname(tuser)) {
					xfree(bp);
					continue;
				}
d439 1
a439 1
		if ((host = strrchr(argv[i], '@@')) == NULL) {
d447 2
d474 1
a474 1
	off_t i, amt, result, statbytes;
d532 1
d541 4
a544 2
		if (showprogress)
			start_progress_meter(curfile, stb.st_size, &statbytes);
a562 2
			if (limit)
				bwlimit(amt);
d565 1
a565 1
			stop_progress_meter();
a632 54
bwlimit(int amount)
{
	static struct timeval bwstart, bwend;
	static int lamt, thresh = 16384;
	u_int64_t wait;
	struct timespec ts, rm;

	if (!timerisset(&bwstart)) {
		gettimeofday(&bwstart, NULL);
		return;
	}

	lamt += amount;
	if (lamt < thresh)
		return;

	gettimeofday(&bwend, NULL);
	timersub(&bwend, &bwstart, &bwend);
	if (!timerisset(&bwend))
		return;

	lamt *= 8;
	wait = (double)1000000L * lamt / limit;

	bwstart.tv_sec = wait / 1000000L;
	bwstart.tv_usec = wait % 1000000L;

	if (timercmp(&bwstart, &bwend, >)) {
		timersub(&bwstart, &bwend, &bwend);

		/* Adjust the wait time */
		if (bwend.tv_sec) {
			thresh /= 2;
			if (thresh < 2048)
				thresh = 2048;
		} else if (bwend.tv_usec < 100) {
			thresh *= 2;
			if (thresh > 32768)
				thresh = 32768;
		}

		TIMEVAL_TO_TIMESPEC(&bwend, &ts);
		while (nanosleep(&ts, &rm) == -1) {
			if (errno != EINTR)
				break;
			ts = rm;
		}
	}

	lamt = 0;
	gettimeofday(&bwstart, NULL);
}

void
d645 1
a645 1
	off_t size, statbytes;
d807 4
a811 2
		if (showprogress)
			start_progress_meter(curfile, size, &statbytes);
a830 4
		
			if (limit)
				bwlimit(4096);

d845 1
a845 1
			stop_progress_meter();
d851 1
a851 1
		if (wrerr == NO && ftruncate(ofd, size) != 0) {
d932 2
a933 2
	    "usage: scp [-pqrvBC1246] [-F config] [-S program] [-P port]\n"
	    "           [-c cipher] [-i identity] [-l limit] [-o option]\n"
d990 3
a992 12
		if (!isalpha(c) && !isdigit(c)) {
			switch (c) {
			case '\'':
			case '"':
			case '`':
			case ' ':
			case '#':
				goto bad;
			default:
				break;
			}
		}
d1012 1
a1012 2
	size = roundup(stb.st_blksize, blksize);
	if (size == 0)
d1014 3
d1038 141
@


1.91.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d55 5
a59 1
 * 3. Neither the name of the University nor the names of its contributors
d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.108 2003/07/18 01:54:25 deraadt Exp $");
d110 1
a110 10
pid_t do_cmd_pid = -1;

static void
killchild(int signo)
{
	if (do_cmd_pid > 1)
		kill(do_cmd_pid, signo);

	_exit(1);
}
d145 1
a145 1
	/* Fork a child to execute the command on the remote host using ssh. */
a172 3
	signal(SIGTERM, killchild);
	signal(SIGINT, killchild);
	signal(SIGHUP, killchild);
d205 3
a207 1
main(int argc, char **argv)
d286 1
a286 1
		fatal("unknown user %u", (u_int) userid);
d347 3
a349 1
toremote(char *targ, int argc, char **argv)
d437 3
a439 1
tolocal(int argc, char **argv)
d488 3
a490 1
source(int argc, char **argv)
d543 1
a543 1
			(void) atomicio(vwrite, remout, buf, strlen(buf));
d554 1
a554 1
		(void) atomicio(vwrite, remout, buf, strlen(buf));
d574 1
a574 1
				(void) atomicio(vwrite, remout, bp->buf, amt);
d576 1
a576 1
				result = atomicio(vwrite, remout, bp->buf, amt);
d590 1
a590 1
			(void) atomicio(vwrite, remout, "", 1);
d598 3
a600 1
rsource(char *name, struct stat *statp)
d619 1
a619 1
		(void) atomicio(vwrite, remout, path, strlen(path));
d629 1
a629 1
	(void) atomicio(vwrite, remout, path, strlen(path));
d648 1
a648 1
	(void) atomicio(vwrite, remout, "E\n", 2);
d707 3
a709 1
sink(int argc, char **argv)
d740 1
a740 1
	(void) atomicio(vwrite, remout, "", 1);
d758 1
a758 1
				(void) atomicio(vwrite, STDERR_FILENO,
d766 1
a766 1
			(void) atomicio(vwrite, remout, "", 1);
d788 1
a788 1
			(void) atomicio(vwrite, remout, "", 1);
d873 1
a873 1
		(void) atomicio(vwrite, remout, "", 1);
d910 1
a910 1
					j = atomicio(vwrite, ofd, bp->buf, count);
d923 1
a923 1
		    (j = atomicio(vwrite, ofd, bp->buf, count)) != count) {
d960 1
a960 1
			(void) atomicio(vwrite, remout, "", 1);
d995 1
a995 1
			(void) atomicio(vwrite, STDERR_FILENO, rbuf, cp - rbuf);
d1040 2
a1041 1
verifydir(char *cp)
d1055 2
a1056 1
okname(char *cp0)
d1086 3
a1088 1
allocbuf(BUF *bp, int fd, int blksize)
d1112 2
a1113 1
lostconn(int signo)
@


1.90
log
@make usage like man page
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.89 2002/06/08 12:36:53 markus Exp $");
d222 1
a222 1
	addargs(&args, "ssh");	 	/* overwritten with ssh_program */
@


1.89
log
@remove FallBackToRsh
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.88 2002/04/06 18:24:09 mouring Exp $");
d932 3
a934 3
	    "usage: scp [-pqrvBC46] [-F config] [-S ssh] [-P port] [-c cipher] [-i identity]\n"
	    "           [-o option] f1 f2\n"
	    "   or: scp [options] f1 ... fn directory\n");
@


1.88
log
@Fixes potental double // within path.
http://bugzilla.mindrot.org/show_bug.cgi?id=76
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.87 2002/03/30 17:45:46 deraadt Exp $");
a224 1
	addargs(&args, "-oFallBackToRsh no");
d356 1
a356 2
			    "-x -o'FallBackToRsh no' "
			    "-o'ClearAllForwardings yes'";
@


1.88.2.1
log
@Pull in OpenSSH-3.4
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.91 2002/06/19 00:27:55 deraadt Exp $");
d222 1
a222 1
	addargs(&args, "ssh");		/* overwritten with ssh_program */
d225 1
d357 2
a358 1
			    "-x -o'ClearAllForwardings yes'";
d934 3
a936 3
	    "usage: scp [-pqrvBC46] [-F config] [-S program] [-P port]\n"
	    "           [-c cipher] [-i identity] [-o option]\n"
	    "           [[user@@]host1:]file1 [...] [[user@@]host2:]file2\n");
@


1.88.2.2
log
@Merge OpenSSH 3.6.1
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.102 2003/03/05 22:33:43 markus Exp $");
a84 1
#include "progressmeter.h"
d86 10
a97 2
void bwlimit(int);

d101 8
a108 2
/* Bandwidth limit */
off_t limit = 0;
a121 3
/* This is used to store the pid of ssh_program */
pid_t do_cmd_pid;

d156 1
a156 2
	do_cmd_pid = fork();
	if (do_cmd_pid == 0) {
a173 2
	} else if (do_cmd_pid == -1) {
		fatal("fork: %s", strerror(errno));
d216 2
a217 3
	int ch, fflag, tflag, status;
	double speed;
	char *targ, *endp;
d228 1
a228 1
	while ((ch = getopt(argc, argv, "dfl:prtvBCc:i:P:q1246S:o:F:")) != -1)
a230 2
		case '1':
		case '2':
a247 6
		case 'l':
			speed = strtod(optarg, &endp);
			if (speed <= 0 || *endp != '\0')
				usage();
			limit = speed * 1024;
			break;
a308 1
	do_cmd_pid = -1;
a323 16
	/*
	 * Finally check the exit status of the ssh process, if one was forked
	 * and no error has occured yet
	 */
	if (do_cmd_pid != -1 && errs == 0) {
		if (remin != -1)
		    (void) close(remin);
		if (remout != -1)
		    (void) close(remout);
		if (waitpid(do_cmd_pid, &status, 0) == -1)
			errs = 1;
		else {
			if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
				errs = 1;
		}
	}
d339 1
a339 1
	if ((thost = strrchr(argv[argc - 1], '@@'))) {
d345 2
d360 1
a360 1
			host = strrchr(argv[i], '@@');
d372 1
a372 2
				else if (!okname(suser)) {
					xfree(bp);
a373 5
				}
				if (tuser && !okname(tuser)) {
					xfree(bp);
					continue;
				}
d439 1
a439 1
		if ((host = strrchr(argv[i], '@@')) == NULL) {
d447 2
d474 1
a474 1
	off_t i, amt, result, statbytes;
d532 1
d541 4
a544 2
		if (showprogress)
			start_progress_meter(curfile, stb.st_size, &statbytes);
a562 2
			if (limit)
				bwlimit(amt);
d565 1
a565 1
			stop_progress_meter();
a632 54
bwlimit(int amount)
{
	static struct timeval bwstart, bwend;
	static int lamt, thresh = 16384;
	u_int64_t wait;
	struct timespec ts, rm;

	if (!timerisset(&bwstart)) {
		gettimeofday(&bwstart, NULL);
		return;
	}

	lamt += amount;
	if (lamt < thresh)
		return;

	gettimeofday(&bwend, NULL);
	timersub(&bwend, &bwstart, &bwend);
	if (!timerisset(&bwend))
		return;

	lamt *= 8;
	wait = (double)1000000L * lamt / limit;

	bwstart.tv_sec = wait / 1000000L;
	bwstart.tv_usec = wait % 1000000L;

	if (timercmp(&bwstart, &bwend, >)) {
		timersub(&bwstart, &bwend, &bwend);

		/* Adjust the wait time */
		if (bwend.tv_sec) {
			thresh /= 2;
			if (thresh < 2048)
				thresh = 2048;
		} else if (bwend.tv_usec < 100) {
			thresh *= 2;
			if (thresh > 32768)
				thresh = 32768;
		}

		TIMEVAL_TO_TIMESPEC(&bwend, &ts);
		while (nanosleep(&ts, &rm) == -1) {
			if (errno != EINTR)
				break;
			ts = rm;
		}
	}

	lamt = 0;
	gettimeofday(&bwstart, NULL);
}

void
d645 1
a645 1
	off_t size, statbytes;
d807 4
a811 2
		if (showprogress)
			start_progress_meter(curfile, size, &statbytes);
a830 4
		
			if (limit)
				bwlimit(4096);

d845 1
a845 1
			stop_progress_meter();
d851 1
a851 1
		if (wrerr == NO && ftruncate(ofd, size) != 0) {
d932 2
a933 2
	    "usage: scp [-pqrvBC1246] [-F config] [-S program] [-P port]\n"
	    "           [-c cipher] [-i identity] [-l limit] [-o option]\n"
d990 3
a992 12
		if (!isalpha(c) && !isdigit(c)) {
			switch (c) {
			case '\'':
			case '"':
			case '`':
			case ' ':
			case '#':
				goto bad;
			default:
				break;
			}
		}
d1012 1
a1012 2
	size = roundup(stb.st_blksize, blksize);
	if (size == 0)
d1014 3
d1038 141
@


1.87
log
@stretch banners
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.86 2001/12/05 03:56:39 itojun Exp $");
d759 1
a759 1
			    *targ ? "/" : "", cp);
@


1.86
log
@make it compile with more strict prototype checking
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.85 2001/10/01 08:06:28 markus Exp $");
d1076 1
a1076 1
	char buf[256];
d1102 7
a1108 4
		    "***************************************"
		    "***************************************"
		    "***************************************"
		    "***************************************",
@


1.85
log
@skip filenames containing \n; report jdamery@@chiark.greenend.org.uk
and matthew@@debian.org
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.84 2001/09/19 19:24:19 stevesk Exp $");
d898 1
a898 1
response()
d931 1
a931 1
usage()
@


1.85.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.86 2001/12/05 03:56:39 itojun Exp $");
d898 1
a898 1
response(void)
d931 1
a931 1
usage(void)
@


1.85.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.88 2002/04/06 18:24:09 mouring Exp $");
d759 1
a759 1
			    strcmp(targ, "/") ? "/" : "", cp);
d1076 1
a1076 1
	char buf[512];
d1102 4
a1105 7
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************",
@


1.85.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.85.2.2 2002/05/17 00:03:24 miod Exp $");
d222 1
a222 1
	addargs(&args, "ssh");		/* overwritten with ssh_program */
d225 1
d357 2
a358 1
			    "-x -o'ClearAllForwardings yes'";
d934 3
a936 3
	    "usage: scp [-pqrvBC46] [-F config] [-S program] [-P port]\n"
	    "           [-c cipher] [-i identity] [-o option]\n"
	    "           [[user@@]host1:]file1 [...] [[user@@]host2:]file2\n");
@


1.84
log
@add ClearAllForwardings ssh option and set it in scp and sftp; ok markus@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.83 2001/09/17 17:57:56 stevesk Exp $");
d487 5
@


1.83
log
@add -Fssh_config option; ok markus@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.82 2001/09/12 18:18:25 stevesk Exp $");
d226 1
d356 3
d365 2
a366 1
			    strlen(thost) + strlen(targ) + CMDNEEDS + 32;
d377 1
a377 1
				    "%s%s -x -o'FallBackToRsh no' -n "
d380 1
a380 1
				    suser, host, cmd, src,
d386 1
a386 1
				    "exec %s%s -x -o'FallBackToRsh no' -n %s "
d389 1
a389 1
				    host, cmd, src,
@


1.82
log
@don't forward agent for non third-party copies; ok markus@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.81 2001/08/29 20:44:03 markus Exp $");
d228 1
a228 1
	while ((ch = getopt(argc, argv, "dfprtvBCc:i:P:q46S:o:")) != -1)
d239 1
d923 3
a925 3
	(void) fprintf(stderr, "usage: scp "
	    "[-pqrvBC46] [-S ssh] [-P port] [-c cipher] [-i identity] "
	    "[-o option] f1 f2\n"
@


1.81
log
@clear the malloc'd buffer, otherwise source() will leak malloc'd memory; ok theo@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.80 2001/08/13 23:38:54 stevesk Exp $");
d224 1
@


1.80
log
@don't need main prototype (also sync with rcp); ok markus@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.79 2001/08/06 19:47:05 stevesk Exp $");
d1013 1
@


1.79
log
@use alarm vs. setitimer for portable; ok markus@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.78 2001/07/27 17:26:16 deraadt Exp $");
a202 1
int main(int, char *[]);
@


1.78
log
@shorten lines
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.77 2001/07/18 16:45:52 mouring Exp $");
d88 2
a1029 12

static void
alarmtimer(int wait)
{
	struct itimerval itv;

	itv.it_value.tv_sec = wait;
	itv.it_value.tv_usec = 0;
	itv.it_interval = itv.it_value;
	setitimer(ITIMER_REAL, &itv, NULL);
}

d1036 2
d1149 1
a1149 1
		alarmtimer(1);
d1151 1
a1151 1
		alarmtimer(0);
@


1.77
log
@Missing -o in scp usage()
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.76 2001/06/23 15:12:19 itojun Exp $");
d132 4
a135 2
		fprintf(stderr, "Executing: program %s host %s, user %s, command %s\n",
		    ssh_program, host, remuser ? remuser : "(unspecified)", cmd);
d808 2
a809 1
				if (j == -1 && (errno == EINTR || errno == EAGAIN)) {
d1098 4
a1101 2
		    "*****************************************************************************"
		    "*****************************************************************************",
@


1.76
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.75 2001/06/23 00:16:16 deraadt Exp $");
d918 2
a919 1
	    "[-pqrvBC46] [-S ssh] [-P port] [-c cipher] [-i identity] f1 f2\n"
@


1.75
log
@slightly better care
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.74 2001/06/16 08:57:35 markus Exp $");
d199 1
d1025 1
a1025 1
void
d1036 1
a1036 1
void
d1045 1
a1045 1
int
@


1.74
log
@no stdio or exit() in signal handlers.
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.73 2001/06/10 11:33:02 markus Exp $");
d638 1
a638 1
#define	SCREWUP(str)	{ why = str; goto screwup; }
d971 1
a971 1
		c = *cp;
@


1.73
log
@you cannot vfprintf(fp, fmt, ap) twice, from portable, via drahn@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.72 2001/06/03 19:38:42 markus Exp $");
d1016 5
a1020 2
		fprintf(stderr, "lost connection\n");
	exit(1);
@


1.72
log
@pass -v to ssh; from slade@@shore.net
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.71 2001/05/19 16:05:41 markus Exp $");
a926 1
	va_start(ap, fmt);
d933 1
d935 1
d940 1
d942 1
a944 1
	va_end(ap);
@


1.71
log
@ftruncate() instead of open()+O_TRUNC like rcp.c does
allows scp /path/to/file localhost:/path/to/file
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.70 2001/05/08 19:45:24 mouring Exp $");
d252 1
@


1.70
log
@Use addargs() in sftp plus some clean up of addargs().  OK Markus
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.69 2001/05/03 23:09:53 mouring Exp $");
d780 1
a780 1
		if ((ofd = open(np, O_WRONLY | O_CREAT | O_TRUNC, mode)) < 0) {
a834 1
#if 0
a838 1
#endif
@


1.69
log
@Move colon() and cleanhost() to misc.c where I should I have put it in
the first place
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.68 2001/04/22 12:34:05 markus Exp $");
d96 2
a97 2
/* setup arguments for the call to ssh */
void addargs(char *fmt, ...) __attribute__((format(printf, 1, 2)));
a119 7
/* This is the list of arguments that scp passes to ssh */
struct {
	char	**list;
	int	num;
	int	nalloc;
} args;

d163 3
a165 3
			addargs("-l%s", remuser);
		addargs("%s", host);
		addargs("%s", cmd);
d218 3
a220 3
	addargs("ssh");	 	/* overwritten with ssh_program */
	addargs("-x");
	addargs("-oFallBackToRsh no");
d229 1
a229 1
			addargs("-%c", ch);
d234 1
a234 1
			addargs("-%c%s", ch, optarg);
d237 1
a237 1
			addargs("-p%s", optarg);
d240 1
a240 1
			addargs("-oBatchmode yes");
a1162 22
}

void
addargs(char *fmt, ...)
{
	va_list ap;
	char buf[1024];

	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);

	if (args.list == NULL) {
		args.nalloc = 32;
		args.num = 0;
		args.list = xmalloc(args.nalloc * sizeof(char *));
	} else if (args.num+2 >= args.nalloc) {
		args.nalloc *= 2;
		args.list = xrealloc(args.list, args.nalloc * sizeof(char *));
	}
	args.list[args.num++] = xstrdup(buf);
	args.list[args.num] = NULL;
@


1.68
log
@scp > 2GB; niles@@scyld.com; ok deraadt@@, djm@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.67 2001/04/16 02:31:43 mouring Exp $");
d84 1
a84 1
#include "scp-common.h"
@


1.68.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.84 2001/09/19 19:24:19 stevesk Exp $");
d84 1
a84 1
#include "misc.h"
a87 2
/* alarm() interval for updating progress meter */
#define PROGRESSTIME	1
d96 2
a97 2
/* Struct for addargs */
arglist args;
d120 7
d139 2
a140 4
		fprintf(stderr,
		    "Executing: program %s host %s, user %s, command %s\n",
		    ssh_program, host,
		    remuser ? remuser : "(unspecified)", cmd);
d170 3
a172 3
			addargs(&args, "-l%s", remuser);
		addargs(&args, "%s", host);
		addargs(&args, "%s", cmd);
d225 3
a227 5
	addargs(&args, "ssh");	 	/* overwritten with ssh_program */
	addargs(&args, "-x");
	addargs(&args, "-oForwardAgent no");
	addargs(&args, "-oFallBackToRsh no");
	addargs(&args, "-oClearAllForwardings yes");
d230 1
a230 1
	while ((ch = getopt(argc, argv, "dfprtvBCc:i:P:q46S:o:F:")) != -1)
d236 1
a236 1
			addargs(&args, "-%c", ch);
d241 1
a241 2
		case 'F':
			addargs(&args, "-%c%s", ch, optarg);
d244 1
a244 1
			addargs(&args, "-p%s", optarg);
d247 1
a247 1
			addargs(&args, "-oBatchmode yes");
a258 1
			addargs(&args, "-v");
a354 3
			static char *ssh_options =
			    "-x -o'FallBackToRsh no' "
			    "-o'ClearAllForwardings yes'";
d361 1
a361 2
			    strlen(thost) + strlen(targ) +
			    strlen(ssh_options) + CMDNEEDS + 20;
d372 1
a372 1
				    "%s%s %s -n "
d375 1
a375 1
				    ssh_options, suser, host, cmd, src,
d381 1
a381 1
				    "exec %s%s %s -n %s "
d384 1
a384 1
				    ssh_options, host, cmd, src,
d644 1
a644 1
#define	SCREWUP(str)	do { why = str; goto screwup; } while (0)
d787 1
a787 1
		if ((ofd = open(np, O_WRONLY|O_CREAT, mode)) < 0) {
d811 1
a811 2
				if (j == -1 && (errno == EINTR ||
				    errno == EAGAIN)) {
d842 1
d847 1
d924 2
a925 3
	(void) fprintf(stderr,
	    "usage: scp [-pqrvBC46] [-F config] [-S ssh] [-P port] [-c cipher] [-i identity]\n"
	    "           [-o option] f1 f2\n"
d935 1
a941 1
	va_start(ap, fmt);
a942 1
	va_end(ap);
a946 1
		va_start(ap, fmt);
a947 1
		va_end(ap);
d950 1
d977 1
a977 1
		c = (int)*cp;
a1012 1
	memset(bp->buf, 0, size);
d1022 14
a1035 5
		write(STDERR_FILENO, "lost connection\n", 16);
	if (signo)
		_exit(1);
	else
		exit(1);
d1038 1
a1038 1
static void
a1043 2
	signal(SIGALRM, updateprogressmeter);
	alarm(PROGRESSTIME);
d1047 1
a1047 1
static int
d1096 2
a1097 4
		    "***************************************"
		    "***************************************"
		    "***************************************"
		    "***************************************",
d1153 1
a1153 1
		alarm(PROGRESSTIME);
d1155 1
a1155 1
		alarm(0);
d1170 22
@


1.68.2.2
log
@Merge OpenSSH 3.0
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.68.2.1 2001/09/27 19:03:55 jason Exp $");
a486 5
		if (strchr(name, '\n') != NULL) {
			run_err("%s: skipping, filename contains a newline",
			    name);
			goto next;
		}
@


1.68.2.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.86 2001/12/05 03:56:39 itojun Exp $");
d898 1
a898 1
response(void)
d931 1
a931 1
usage(void)
@


1.68.2.4
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.88 2002/04/06 18:24:09 mouring Exp $");
d759 1
a759 1
			    strcmp(targ, "/") ? "/" : "", cp);
d1076 1
a1076 1
	char buf[512];
d1102 4
a1105 7
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************",
@


1.67
log
@IPv6 support for sftp (which I bungled in my last patch) which is
borrowed from scp.c.  Thanks to Markus@@ for pointing it out.
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.66 2001/04/14 17:04:42 stevesk Exp $");
d103 1
a103 1
volatile u_long statbytes;
d471 2
a472 2
	off_t i;
	int amt, fd, haderr, indx, result;
@


1.66
log
@'T' handling rcp/scp sync; ok markus@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.65 2001/04/06 16:46:59 deraadt Exp $");
d84 1
a191 1
char *colon(char *);
a210 1
char *cleanhostname(char *);
a326 11
char *
cleanhostname(host)
	char *host;
{
	if (*host == '[' && host[strlen(host) - 1] == ']') {
		host[strlen(host) - 1] = '\0';
		return (host + 1);
	} else
		return host;
}

a950 24
}

char *
colon(cp)
	char *cp;
{
	int flag = 0;

	if (*cp == ':')		/* Leading colon is part of file name. */
		return (0);
	if (*cp == '[')
		flag = 1;

	for (; *cp; ++cp) {
		if (*cp == '@@' && *(cp+1) == '[')
			flag = 1;
		if (*cp == ']' && *(cp+1) == ':' && flag)
			return (cp+1);
		if (*cp == ':' && !flag)
			return (cp);
		if (*cp == '/')
			return (0);
	}
	return (0);
@


1.65
log
@remove trailing / from source paths; fixes pr#1756
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.64 2001/03/28 20:04:38 stevesk Exp $");
a651 1
	int dummy_usec;
d654 2
a701 2
#define getnum(t) (t) = 0; \
  while (*cp >= '0' && *cp <= '9') (t) = (t) * 10 + (*cp++ - '0');
d706 2
a707 2
			getnum(tv[1].tv_sec);
			if (*cp++ != ' ')
d709 2
a710 3
			getnum(dummy_usec);
			tv[1].tv_usec = 0;
			if (*cp++ != ' ')
d712 2
a713 2
			getnum(tv[0].tv_sec);
			if (*cp++ != ' ')
d715 2
a716 3
			getnum(dummy_usec);
			tv[0].tv_usec = 0;
			if (*cp++ != '\0')
@


1.64
log
@usage more like rcp and add missing -B to usage; ok markus@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.63 2001/03/28 19:56:23 stevesk Exp $");
d486 1
d491 3
@


1.63
log
@start to sync scp closer to rcp; ok markus@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.62 2001/03/21 12:33:33 markus Exp $");
d936 2
a937 2
	    "[-pqrvC46] [-S ssh] [-P port] [-c cipher] [-i identity] f1 f2; or:\n"
	    "       scp [options] f1 ... fn directory\n");
@


1.62
log
@alpha fixes, from simonb@@wasabisystems.com
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.61 2001/03/15 15:05:59 markus Exp $");
a189 2
extern int iamremote;

a205 1
int main(int, char *[]);
a277 1
		case '?':
d614 1
a614 1
	while ((dp = readdir(dirp))) {
d743 1
a743 1
		for (size = 0; *cp >= '0' && *cp <= '9';)
d826 1
a826 1
						"dropped connection");
d863 1
a863 1
						np, strerror(errno));
d868 1
a868 1
						np, strerror(errno));
d879 1
a879 1
					np, strerror(errno));
@


1.61
log
@use %lld in printf, ok millert@@/deraadt@@; report from ssh@@client.fi
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.60 2001/03/02 18:54:31 deraadt Exp $");
d533 1
a533 1
		    stb.st_size, last);
@


1.60
log
@make copyright lines the same format
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.59 2001/02/19 10:36:25 deraadt Exp $");
d531 1
a531 1
		snprintf(buf, sizeof buf, "C%04o %lu %s\n",
d533 1
a533 1
		    (u_long) stb.st_size, last);
@


1.59
log
@np is changed by recursion; vinschen@@redhat.com
@
text
@d17 2
a18 2
 * Copyright (c) 1999 Theo de Raadt. All rights reserved.
 * Copyright (c) 1999 Aaron Campbell. All rights reserved.
d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.58 2001/02/10 15:14:11 danh Exp $");
@


1.58
log
@fix memory leak; ok markus@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.57 2001/02/10 00:12:43 danh Exp $");
a787 2
			if (vect[0])
				xfree(vect[0]);
d790 1
a790 1
				if (utimes(np, tv) < 0)
d792 1
a792 1
						np, strerror(errno));
d795 3
a797 1
				(void) chmod(np, mode);
@


1.57
log
@revert a small change to allow -r option to work again; ok deraadt@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.56 2001/02/08 19:30:52 itojun Exp $");
d758 2
d786 1
a786 1
			vect[0] = np;
d788 2
@


1.56
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.55 2001/02/08 14:38:54 deraadt Exp $");
a757 2
				if (namebuf)
					xfree(namebuf);
@


1.55
log
@memory leak fix, and snprintf throughout
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.54 2001/02/07 18:01:17 itojun Exp $");
d208 1
d214 1
d1085 1
a1085 1
foregroundproc()
@


1.54
log
@unsigned long long -> %llu, not %qu.  markus ok
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.53 2001/02/04 23:56:22 deraadt Exp $");
d313 2
a314 1
	(void) sprintf(cmd, "scp%s%s%s%s", verbose_mode ? " -v" : "",
d385 3
a387 2
				sprintf(bp,
				    "%s%s -x -o'FallBackToRsh no' -n -l %s %s %s %s '%s%s%s:%s'",
d394 3
a396 2
				sprintf(bp,
				    "exec %s%s -x -o'FallBackToRsh no' -n %s %s %s '%s%s%s:%s'",
d410 1
a410 1
				(void) sprintf(bp, "%s -t %s", cmd, targ);
d437 1
a437 1
			(void) sprintf(bp, "exec %s%s%s %s %s", _PATH_CP,
d464 1
a464 1
		(void) sprintf(bp, "%s -f %s", cmd, src);
d521 1
a521 1
			(void) sprintf(buf, "T%lu 0 %lu 0\n",
d529 1
a529 1
		sprintf(buf, "C%04o %lu %s\n",
d598 1
a598 1
		(void) sprintf(path, "T%lu 0 %lu 0\n",
d607 1
a607 1
	(void) sprintf(path, "D%04o %d %.1024s\n",
d625 1
a625 1
		(void) sprintf(path, "%s/%s", name, dp->d_name);
d755 3
a757 1
			if (need > cursize)
d759 3
a761 1
			(void) sprintf(namebuf, "%s%s%s", targ,
@


1.53
log
@alpha happiness
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.52 2001/02/04 15:32:24 stevesk Exp $");
d1134 1
a1134 1
	snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " %5qd %c%c ",
@


1.52
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.51 2001/01/21 19:05:55 markus Exp $");
d1135 2
a1136 1
	    (quad_t) abbrevsize, prefixes[i], prefixes[i] == ' ' ? ' ' : 'B');
@


1.51
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.50 2001/01/19 15:55:11 markus Exp $");
d295 1
a295 1
	if (fflag) {	
@


1.50
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.49 2001/01/13 18:03:07 markus Exp $");
a79 1
#include "ssh.h"
d81 1
d83 1
@


1.49
log
@getopt() returns -1 not EOF; stevesk@@pobox.com
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.48 2001/01/01 14:52:49 markus Exp $");
d82 1
a82 2

#define _PATH_CP "cp"
d116 1
a116 1
char *ssh_program = SSH_PROGRAM;
@


1.48
log
@use shared fatal(); from stevesk@@pobox.com
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.47 2000/12/19 23:17:57 markus Exp $");
d232 1
a232 1
	while ((ch = getopt(argc, argv, "dfprtvBCc:i:P:q46S:o:")) != EOF)
@


1.47
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.46 2000/12/16 09:53:57 markus Exp $");
a182 13
}

void
fatal(const char *fmt,...)
{
	va_list ap;
	char buf[1024];

	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);
	fprintf(stderr, "%s\n", buf);
	exit(255);
@


1.46
log
@allow + in usernames; request from Florian.Weimer@@RUS.Uni-Stuttgart.DE
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.45 2000/12/16 09:39:57 markus Exp $");
d102 1
a102 1
volatile unsigned long statbytes;
d532 2
a533 2
			    (unsigned long) stb.st_mtime,
			    (unsigned long) stb.st_atime);
d540 2
a541 2
		    (unsigned int) (stb.st_mode & FILEMODEMASK),
		    (unsigned long) stb.st_size, last);
d609 2
a610 2
		    (unsigned long) statp->st_mtime,
		    (unsigned long) statp->st_atime);
d618 1
a618 1
	    (unsigned int) (statp->st_mode & FILEMODEMASK), 0, last);
@


1.45
log
@unused; from stevesk@@pobox.com
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.44 2000/12/11 17:27:33 deraadt Exp $");
d1021 2
a1022 1
		if (!isalpha(c) && !isdigit(c) && c != '_' && c != '-' && c != '.')
@


1.44
log
@when copying 0-sized files, do not re-print ETA time at completion
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.43 2000/10/18 18:23:02 markus Exp $");
a111 3

/* This is set to non-zero if compression is desired. */
int compress = 0;
@


1.43
log
@replace atomicio(read,...) with read(); ok deraadt@@
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.42 2000/10/14 10:07:21 markus Exp $");
d400 1
a400 1
				(void) sprintf(bp,
d402 4
a405 4
				     ssh_program, verbose_mode ? " -v" : "",
				     suser, host, cmd, src,
				     tuser ? tuser : "", tuser ? "@@" : "",
				     thost, targ);
d408 1
a408 1
				(void) sprintf(bp,
d410 4
a413 4
				     ssh_program, verbose_mode ? " -v" : "",
				     host, cmd, src,
				     tuser ? tuser : "", tuser ? "@@" : "",
				     thost, targ);
d542 3
a544 4
		(void) sprintf(buf, "C%04o %lu %s\n",
			     (unsigned int) (stb.st_mode & FILEMODEMASK),
			       (unsigned long) stb.st_size,
			       last);
d699 1
a699 1
					     buf + 1, strlen(buf + 1));
d1150 1
a1150 2
	     (quad_t) abbrevsize, prefixes[i], prefixes[i] == ' ' ? ' ' :
		 'B');
d1165 2
a1166 1
	if (statbytes <= 0 || elapsed <= 0.0 || cursize > totalbytes) {
d1168 1
a1168 1
			 "   --:-- ETA");
d1171 1
a1171 1
			 " - stalled -");
d1174 2
a1175 2
			remaining =
			    (int)(totalbytes / (statbytes / elapsed) - elapsed);
@


1.43.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.58 2001/02/10 15:14:11 danh Exp $");
d80 1
d82 2
a83 3
#include "atomicio.h"
#include "pathnames.h"
#include "log.h"
d102 1
a102 1
volatile u_long statbytes;
d113 3
d120 1
a120 1
char *ssh_program = _PATH_SSH_PROGRAM;
d188 13
a223 1
int main(int, char *[]);
a228 1
char *cleanhostname(char *);
d248 1
a248 1
	while ((ch = getopt(argc, argv, "dfprtvBCc:i:P:q46S:o:")) != -1)
d311 1
a311 1
	if (fflag) {
d329 1
a329 2
	(void) snprintf(cmd, sizeof cmd, "scp%s%s%s%s",
	    verbose_mode ? " -v" : "",
d400 6
a405 7
				snprintf(bp, len,
				    "%s%s -x -o'FallBackToRsh no' -n "
				    "-l %s %s %s %s '%s%s%s:%s'",
				    ssh_program, verbose_mode ? " -v" : "",
				    suser, host, cmd, src,
				    tuser ? tuser : "", tuser ? "@@" : "",
				    thost, targ);
d408 6
a413 7
				snprintf(bp, len,
				    "exec %s%s -x -o'FallBackToRsh no' -n %s "
				    "%s %s '%s%s%s:%s'",
				    ssh_program, verbose_mode ? " -v" : "",
				    host, cmd, src,
				    tuser ? tuser : "", tuser ? "@@" : "",
				    thost, targ);
d423 1
a423 1
				(void) snprintf(bp, len, "%s -t %s", cmd, targ);
d450 1
a450 1
			(void) snprintf(bp, len, "exec %s%s%s %s %s", _PATH_CP,
d477 1
a477 1
		(void) snprintf(bp, len, "%s -f %s", cmd, src);
d534 3
a536 3
			(void) snprintf(buf, sizeof buf, "T%lu 0 %lu 0\n",
			    (u_long) stb.st_mtime,
			    (u_long) stb.st_atime);
d542 4
a545 3
		snprintf(buf, sizeof buf, "C%04o %lu %s\n",
		    (u_int) (stb.st_mode & FILEMODEMASK),
		    (u_long) stb.st_size, last);
d612 3
a614 3
		(void) snprintf(path, sizeof(path), "T%lu 0 %lu 0\n",
		    (u_long) statp->st_mtime,
		    (u_long) statp->st_atime);
d621 2
a622 2
	(void) snprintf(path, sizeof path, "D%04o %d %.1024s\n",
	    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);
d639 1
a639 1
		(void) snprintf(path, sizeof path, "%s/%s", name, dp->d_name);
d700 1
a700 1
				    buf + 1, strlen(buf + 1));
d769 1
a769 3
			if (need > cursize) {
				if (namebuf)
					xfree(namebuf);
d771 1
a771 3
				cursize = need;
			}
			(void) snprintf(namebuf, need, "%s%s%s", targ,
d794 1
a794 1
			vect[0] = xstrdup(np);
a795 2
			if (vect[0])
				xfree(vect[0]);
d1025 1
a1025 2
		if (!isalpha(c) && !isdigit(c) &&
		    c != '_' && c != '-' && c != '.' && c != '+')
d1092 1
a1092 1
foregroundproc(void)
d1150 3
a1152 3
	snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " %5llu %c%c ",
	    (unsigned long long) abbrevsize, prefixes[i],
	    prefixes[i] == ' ' ? ' ' : 'B');
d1167 1
a1167 2
	if (flag != 1 &&
	    (statbytes <= 0 || elapsed <= 0.0 || cursize > totalbytes)) {
d1169 1
a1169 1
		    "   --:-- ETA");
d1172 1
a1172 1
		    " - stalled -");
d1175 2
a1176 2
			remaining = (int)(totalbytes / (statbytes / elapsed) -
			    elapsed);
@


1.43.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.59 2001/02/19 10:36:25 deraadt Exp $");
d788 2
d792 1
a792 1
				if (utimes(vect[0], tv) < 0)
d794 1
a794 1
					    vect[0], strerror(errno));
d797 1
a797 3
				(void) chmod(vect[0], mode);
			if (vect[0])
				xfree(vect[0]);
@


1.43.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d17 2
a18 2
 * Copyright (c) 1999 Theo de Raadt.  All rights reserved.
 * Copyright (c) 1999 Aaron Campbell.  All rights reserved.
d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.61 2001/03/15 15:05:59 markus Exp $");
d531 1
a531 1
		snprintf(buf, sizeof buf, "C%04o %lld %s\n",
d533 1
a533 1
		    stb.st_size, last);
@


1.43.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.68 2001/04/22 12:34:05 markus Exp $");
a83 1
#include "scp-common.h"
d102 1
a102 1
volatile off_t statbytes;
d190 2
d193 1
d208 1
d214 1
d281 1
d332 11
d487 2
a488 2
	off_t i, amt, result;
	int fd, haderr, indx;
a489 1
	int len;
a493 3
		len = strlen(name);
		while (len > 1 && name[len-1] == '/')
			name[--len] = '\0';
d533 1
a533 1
		    (long long)stb.st_size, last);
d618 1
a618 1
	while ((dp = readdir(dirp)) != NULL) {
d652 1
a654 2
#define	atime	tv[0]
#define	mtime	tv[1]
d701 2
d707 2
a708 2
			mtime.tv_sec = strtol(cp, &cp, 10);
			if (!cp || *cp++ != ' ')
d710 3
a712 2
			mtime.tv_usec = strtol(cp, &cp, 10);
			if (!cp || *cp++ != ' ')
d714 2
a715 2
			atime.tv_sec = strtol(cp, &cp, 10);
			if (!cp || *cp++ != ' ')
d717 3
a719 2
			atime.tv_usec = strtol(cp, &cp, 10);
			if (!cp || *cp++ != '\0')
d747 1
a747 1
		for (size = 0; isdigit(*cp);)
d830 1
a830 1
					    "dropped connection");
d867 1
a867 1
					    np, strerror(errno));
d872 1
a872 1
					    np, strerror(errno));
d883 1
a883 1
				    np, strerror(errno));
d940 2
a941 2
	    "[-pqrvBC46] [-S ssh] [-P port] [-c cipher] [-i identity] f1 f2\n"
	    "   or: scp [options] f1 ... fn directory\n");
d966 24
@


1.43.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.84 2001/09/19 19:24:19 stevesk Exp $");
d84 1
a84 1
#include "misc.h"
a87 2
/* alarm() interval for updating progress meter */
#define PROGRESSTIME	1
d96 2
a97 2
/* Struct for addargs */
arglist args;
d120 7
d139 2
a140 4
		fprintf(stderr,
		    "Executing: program %s host %s, user %s, command %s\n",
		    ssh_program, host,
		    remuser ? remuser : "(unspecified)", cmd);
d170 3
a172 3
			addargs(&args, "-l%s", remuser);
		addargs(&args, "%s", host);
		addargs(&args, "%s", cmd);
d225 3
a227 5
	addargs(&args, "ssh");	 	/* overwritten with ssh_program */
	addargs(&args, "-x");
	addargs(&args, "-oForwardAgent no");
	addargs(&args, "-oFallBackToRsh no");
	addargs(&args, "-oClearAllForwardings yes");
d230 1
a230 1
	while ((ch = getopt(argc, argv, "dfprtvBCc:i:P:q46S:o:F:")) != -1)
d236 1
a236 1
			addargs(&args, "-%c", ch);
d241 1
a241 2
		case 'F':
			addargs(&args, "-%c%s", ch, optarg);
d244 1
a244 1
			addargs(&args, "-p%s", optarg);
d247 1
a247 1
			addargs(&args, "-oBatchmode yes");
a258 1
			addargs(&args, "-v");
a354 3
			static char *ssh_options =
			    "-x -o'FallBackToRsh no' "
			    "-o'ClearAllForwardings yes'";
d361 1
a361 2
			    strlen(thost) + strlen(targ) +
			    strlen(ssh_options) + CMDNEEDS + 20;
d372 1
a372 1
				    "%s%s %s -n "
d375 1
a375 1
				    ssh_options, suser, host, cmd, src,
d381 1
a381 1
				    "exec %s%s %s -n %s "
d384 1
a384 1
				    ssh_options, host, cmd, src,
d644 1
a644 1
#define	SCREWUP(str)	do { why = str; goto screwup; } while (0)
d787 1
a787 1
		if ((ofd = open(np, O_WRONLY|O_CREAT, mode)) < 0) {
d811 1
a811 2
				if (j == -1 && (errno == EINTR ||
				    errno == EAGAIN)) {
d842 1
d847 1
d924 2
a925 3
	(void) fprintf(stderr,
	    "usage: scp [-pqrvBC46] [-F config] [-S ssh] [-P port] [-c cipher] [-i identity]\n"
	    "           [-o option] f1 f2\n"
d935 1
a941 1
	va_start(ap, fmt);
a942 1
	va_end(ap);
a946 1
		va_start(ap, fmt);
a947 1
		va_end(ap);
d950 1
d977 1
a977 1
		c = (int)*cp;
a1012 1
	memset(bp->buf, 0, size);
d1022 14
a1035 5
		write(STDERR_FILENO, "lost connection\n", 16);
	if (signo)
		_exit(1);
	else
		exit(1);
d1038 1
a1038 1
static void
a1043 2
	signal(SIGALRM, updateprogressmeter);
	alarm(PROGRESSTIME);
d1047 1
a1047 1
static int
d1096 2
a1097 4
		    "***************************************"
		    "***************************************"
		    "***************************************"
		    "***************************************",
d1153 1
a1153 1
		alarm(PROGRESSTIME);
d1155 1
a1155 1
		alarm(0);
d1170 22
@


1.43.2.6
log
@Merge OpenSSH 3.0
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.43.2.5 2001/09/27 00:15:42 miod Exp $");
a486 5
		if (strchr(name, '\n') != NULL) {
			run_err("%s: skipping, filename contains a newline",
			    name);
			goto next;
		}
@


1.43.2.7
log
@Merge OpenSSH 3.1.
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.86 2001/12/05 03:56:39 itojun Exp $");
d898 1
a898 1
response(void)
d931 1
a931 1
usage(void)
@


1.42
log
@remove spaces from arguments; from djm@@mindrot.org
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.41 2000/10/11 20:03:27 markus Exp $");
d831 4
a834 2
				j = atomicio(read, remin, cp, amt);
				if (j <= 0) {
@


1.41
log
@support 'scp -o' with help from mouring@@pconline.com
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.40 2000/09/21 11:11:42 markus Exp $");
d172 1
a172 1
			addargs("-l %s", remuser);
d259 1
a259 1
			addargs("-%c %s", ch, optarg);
d262 1
a262 1
			addargs("-p %s", optarg);
d265 1
a265 1
			addargs("-o Batchmode yes");
@


1.40
log
@utime() to utimes(); mouring@@pconline.com
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.39 2000/09/07 20:53:00 markus Exp $");
d95 3
a109 6
/* This is set to non-zero if IPv4 is desired. */
int IPv4 = 0;

/* This is set to non-zero if IPv6 is desired. */
int IPv6 = 0;

a118 14
/* This is set to non-zero if running in batch mode (that is, password
   and passphrase queries are not allowed). */
int batchmode = 0;

/* This is set to the cipher type string if given on the command line. */
char *cipher = NULL;

/* This is set to the RSA authentication identity file name if given on
   the command line. */
char *identity = NULL;

/* This is the port to use in contacting the remote site (is non-NULL). */
char *port = NULL;

d122 7
d141 2
a142 2
		fprintf(stderr, "Executing: host %s, user %s, command %s\n",
		    host, remuser ? remuser : "(unspecified)", cmd);
d161 1
a161 4
	if (fork() == 0) {
		char *args[100];	/* XXX careful */
		unsigned int i;

d170 5
a174 33
		i = 0;
		args[i++] = ssh_program;
		args[i++] = "-x";
		args[i++] = "-oFallBackToRsh no";
		if (IPv4)
			args[i++] = "-4";
		if (IPv6)
			args[i++] = "-6";
		if (verbose_mode)
			args[i++] = "-v";
		if (compress)
			args[i++] = "-C";
		if (batchmode)
			args[i++] = "-oBatchMode yes";
		if (cipher != NULL) {
			args[i++] = "-c";
			args[i++] = cipher;
		}
		if (identity != NULL) {
			args[i++] = "-i";
			args[i++] = identity;
		}
		if (port != NULL) {
			args[i++] = "-p";
			args[i++] = port;
		}
		if (remuser != NULL) {
			args[i++] = "-l";
			args[i++] = remuser;
		}
		args[i++] = host;
		args[i++] = cmd;
		args[i++] = NULL;
d176 1
a176 1
		execvp(ssh_program, args);
d242 5
d248 1
a248 1
	while ((ch = getopt(argc, argv, "dfprtvBCc:i:P:q46S:")) != EOF)
d252 8
a259 1
			IPv4 = 1;
d261 5
a265 2
		case '6':
			IPv6 = 1;
a269 3
		case 'P':
			port = optarg;
			break;
d274 7
a280 1
			ssh_program = optarg;
a294 18
		case 'c':
			cipher = optarg;
			break;
		case 'i':
			identity = optarg;
			break;
		case 'v':
			verbose_mode = 1;
			break;
		case 'B':
			batchmode = 1;
			break;
		case 'C':
			compress = 1;
			break;
		case 'q':
			showprogress = 0;
			break;
d1211 22
@


1.39
log
@typo
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.38 2000/09/07 20:27:53 deraadt Exp $");
a81 1
#include <utime.h>
a704 1
	struct utimbuf ut;
d706 1
d760 1
a760 1
			getnum(ut.modtime);
d764 1
d767 1
a767 1
			getnum(ut.actime);
d771 1
d839 1
a839 1
				if (utime(np, &ut) < 0)
d926 1
a926 1
			if (utime(np, &ut) < 0) {
@


1.38
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d15 1
a15 1
 *
d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.37 2000/09/01 15:25:13 deraadt Exp $");
@


1.37
log
@cleanup and fix -S support; stevesk@@sweden.hp.com
@
text
@d2 2
d5 2
a6 2
 * scp - secure remote copy.  This is basically patched BSD rcp which uses ssh
 * to do the data transfer (instead of using rcmd).
d8 11
a18 2
 * NOTE: This version should NOT be suid root.  (This uses ssh to do the transfer
 * and ssh has the necessary privileges.)
d20 8
a27 1
 * 1995 Timo Rinne <tri@@iki.fi>, Tatu Ylonen <ylo@@cs.hut.fi>
d29 11
a39 1
*/
d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.36 2000/08/24 21:46:59 deraadt Exp $");
@


1.36
log
@off_t in sink, to fix files > 2GB, i think, test is still running ;-)
@
text
@d50 1
a50 1
RCSID("$OpenBSD: scp.c,v 1.35 2000/08/19 02:50:07 deraadt Exp $");
d257 1
a257 1
	while ((ch = getopt(argc, argv, "dfprtvBCc:i:P:q46S")) != EOF)
@


1.35
log
@knf
@
text
@d50 1
a50 1
RCSID("$OpenBSD: scp.c,v 1.34 2000/08/19 02:26:08 deraadt Exp $");
d675 2
a676 1
	int setimes, size, targisdir, wrerrno = 0;
@


1.34
log
@-S prog support; tv@@debian.org
@
text
@d14 2
d50 1
a50 1
RCSID("$OpenBSD: scp.c,v 1.33 2000/07/13 23:19:31 provos Exp $");
d66 1
d119 1
a119 1
do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout)
d125 1
a125 1
			host, remuser ? remuser : "(unspecified)", cmd);
d145 1
a145 1
		char *args[100];
a214 2
/* This stuff used to be in BSD rcp extern.h. */

a229 2
/* Stuff from BSD rcp.c continues. */

d344 2
a345 2
		       iamrecursive ? " -r" : "", pflag ? " -p" : "",
		       targetshouldbedirectory ? " -d" : "");
d403 2
a404 2
				strlen(src) + (tuser ? strlen(tuser) : 0) +
				strlen(thost) + strlen(targ) + CMDNEEDS + 32;
d439 2
a440 2
				if (do_cmd(host, tuser,
					   bp, &remin, &remout) < 0)
d462 1
a462 1
				     strlen(argv[argc - 1]) + 20;
d465 2
a466 2
				       iamrecursive ? " -r" : "", pflag ? " -p" : "",
				       argv[i], argv[argc - 1]);
d492 1
a492 1
		if (do_cmd(host, suser, bp, &remin, &remout) < 0) {
d549 2
a550 2
				       (unsigned long) stb.st_mtime,
				       (unsigned long) stb.st_atime);
d627 2
a628 2
			       (unsigned long) statp->st_mtime,
			       (unsigned long) statp->st_atime);
d636 1
a636 2
		       (unsigned int) (statp->st_mode & FILEMODEMASK),
		       0, last);
d783 1
a783 1
				       *targ ? "/" : "", cp);
a982 37
/* Stuff below is from BSD rcp util.c. */

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: scp.c,v 1.33 2000/07/13 23:19:31 provos Exp $
 */

d1059 1
a1059 1
			stb.st_blksize;
d1148 4
a1151 4
			 "|%.*s%*s|", i,
			 "*****************************************************************************"
			 "*****************************************************************************",
			 barlength - i, "");
d1192 1
a1192 1
				 "%2d:", i);
d1195 1
a1195 1
				 "   ");
d1198 2
a1199 2
			 "%02d:%02d%s", i / 60, i % 60,
			 (flag != 1) ? " ETA" : "    ");
@


1.33
log
@close can fail on AFS, report error; from Greg Hudson <ghudson@@mit.edu>
@
text
@d48 1
a48 1
RCSID("$OpenBSD: scp.c,v 1.32 2000/06/20 01:39:44 markus Exp $");
d106 3
d154 1
a154 1
		args[i++] = SSH_PROGRAM;
d187 2
a188 2
		execvp(SSH_PROGRAM, args);
		perror(SSH_PROGRAM);
d258 1
a258 1
	while ((ch = getopt(argc, argv, "dfprtvBCc:i:P:q46")) != EOF)
d276 4
d403 1
a403 1
			len = strlen(SSH_PROGRAM) + strlen(argv[i]) +
d416 5
a420 5
					       "%s%s -x -o'FallBackToRsh no' -n -l %s %s %s %s '%s%s%s:%s'",
					       SSH_PROGRAM, verbose_mode ? " -v" : "",
					       suser, host, cmd, src,
					       tuser ? tuser : "", tuser ? "@@" : "",
					       thost, targ);
d424 5
a428 5
					       "exec %s%s -x -o'FallBackToRsh no' -n %s %s %s '%s%s%s:%s'",
					       SSH_PROGRAM, verbose_mode ? " -v" : "",
					       host, cmd, src,
					       tuser ? tuser : "", tuser ? "@@" : "",
					       thost, targ);
d956 3
a958 2
	(void) fprintf(stderr,
		       "usage: scp [-pqrvC46] [-P port] [-c cipher] [-i identity] f1 f2; or:\n       scp [options] f1 ... fn directory\n");
d1019 1
a1019 1
 *	$OpenBSD: scp.c,v 1.32 2000/06/20 01:39:44 markus Exp $
@


1.32
log
@OpenBSD tag
@
text
@d48 1
a48 1
RCSID("$OpenBSD: scp.c,v 1.31 2000/06/18 03:16:09 markus Exp $");
d884 4
a887 1
		(void) close(ofd);
d1011 1
a1011 1
 *	$OpenBSD: scp.c,v 1.31 2000/06/18 03:16:09 markus Exp $
@


1.31
log
@typo
@
text
@d48 1
a48 1
RCSID("$Id: scp.c,v 1.30 2000/05/02 18:21:48 deraadt Exp $");
d1008 1
a1008 1
 *	$Id: scp.c,v 1.30 2000/05/02 18:21:48 deraadt Exp $
@


1.30
log
@more atomicio
@
text
@d48 1
a48 1
RCSID("$Id: scp.c,v 1.29 2000/05/01 07:05:08 deraadt Exp $");
a157 1
		args[i++] = "-oFallBackToRsh no";
d1008 1
a1008 1
 *	$Id: scp.c,v 1.29 2000/05/01 07:05:08 deraadt Exp $
@


1.30.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@a13 2
 * Parts from:
 *
d48 1
a48 1
RCSID("$OpenBSD: scp.c,v 1.36 2000/08/24 21:46:59 deraadt Exp $");
a63 1
int do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout, int argc);
a105 3
/* This is the program to execute for the secured connection. ("ssh" or -S) */
char *ssh_program = SSH_PROGRAM;

d113 1
a113 1
do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout, int argc)
d119 1
a119 1
		    host, remuser ? remuser : "(unspecified)", cmd);
d139 1
a139 1
		char *args[100];	/* XXX careful */
d151 1
a151 1
		args[i++] = ssh_program;
d158 1
d185 2
a186 2
		execvp(ssh_program, args);
		perror(ssh_program);
d210 2
d227 2
d256 1
a256 1
	while ((ch = getopt(argc, argv, "dfprtvBCc:i:P:q46S")) != EOF)
a273 4
		case 'S':
			ssh_program = optarg;
			break;

d339 2
a340 2
	    iamrecursive ? " -r" : "", pflag ? " -p" : "",
	    targetshouldbedirectory ? " -d" : "");
d397 3
a399 3
			len = strlen(ssh_program) + strlen(argv[i]) +
			    strlen(src) + (tuser ? strlen(tuser) : 0) +
			    strlen(thost) + strlen(targ) + CMDNEEDS + 32;
d410 5
a414 5
				    "%s%s -x -o'FallBackToRsh no' -n -l %s %s %s %s '%s%s%s:%s'",
				     ssh_program, verbose_mode ? " -v" : "",
				     suser, host, cmd, src,
				     tuser ? tuser : "", tuser ? "@@" : "",
				     thost, targ);
d418 5
a422 5
				    "exec %s%s -x -o'FallBackToRsh no' -n %s %s %s '%s%s%s:%s'",
				     ssh_program, verbose_mode ? " -v" : "",
				     host, cmd, src,
				     tuser ? tuser : "", tuser ? "@@" : "",
				     thost, targ);
d434 2
a435 2
				if (do_cmd(host, tuser, bp, &remin,
				    &remout, argc) < 0)
d457 1
a457 1
			    strlen(argv[argc - 1]) + 20;
d460 2
a461 2
			    iamrecursive ? " -r" : "", pflag ? " -p" : "",
			    argv[i], argv[argc - 1]);
d487 1
a487 1
		if (do_cmd(host, suser, bp, &remin, &remout, argc) < 0) {
d544 2
a545 2
			    (unsigned long) stb.st_mtime,
			    (unsigned long) stb.st_atime);
d622 2
a623 2
		    (unsigned long) statp->st_mtime,
		    (unsigned long) statp->st_atime);
d631 2
a632 1
	    (unsigned int) (statp->st_mode & FILEMODEMASK), 0, last);
d671 1
a671 2
	off_t size;
	int setimes, targisdir, wrerrno = 0;
d779 1
a779 1
			    *targ ? "/" : "", cp);
d885 1
a885 4
		if (close(ofd) == -1) {
			wrerr = YES;
			wrerrno = errno;
		}
d947 2
a948 3
	(void) fprintf(stderr, "usage: scp "
	    "[-pqrvC46] [-S ssh] [-P port] [-c cipher] [-i identity] f1 f2; or:\n"
	    "       scp [options] f1 ... fn directory\n");
d975 37
d1088 1
a1088 1
		    stb.st_blksize;
d1177 4
a1180 4
		    "|%.*s%*s|", i,
		    "*****************************************************************************"
		    "*****************************************************************************",
		    barlength - i, "");
d1221 1
a1221 1
			    "%2d:", i);
d1224 1
a1224 1
			    "   ");
d1227 2
a1228 2
		    "%02d:%02d%s", i / 60, i % 60,
		    (flag != 1) ? " ETA" : "    ");
@


1.30.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@a1 2
 * scp - secure remote copy.  This is basically patched BSD rcp which
 * uses ssh to do the data transfer (instead of using rcmd).
d3 5
a7 2
 * NOTE: This version should NOT be suid root.  (This uses ssh to
 * do the transfer and ssh has the necessary privileges.)
d11 1
a11 30
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */
/*
 * Copyright (c) 1999 Theo de Raadt. All rights reserved.
 * Copyright (c) 1999 Aaron Campbell. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
d50 1
a50 1
RCSID("$OpenBSD: scp.c,v 1.43 2000/10/18 18:23:02 markus Exp $");
d54 1
a67 3
/* setup arguments for the call to ssh */
void addargs(char *fmt, ...) __attribute__((format(printf, 1, 2)));

d80 6
d95 14
a111 7
/* This is the list of arguments that scp passes to ssh */
struct {
	char	**list;
	int	num;
	int	nalloc;
} args;

d124 2
a125 2
		fprintf(stderr, "Executing: program %s host %s, user %s, command %s\n",
		    ssh_program, host, remuser ? remuser : "(unspecified)", cmd);
d144 4
a147 1
	if (fork() == 0)  {
d156 33
a188 5
		args.list[0] = ssh_program;
		if (remuser != NULL)
			addargs("-l%s", remuser);
		addargs("%s", host);
		addargs("%s", cmd);
d190 1
a190 1
		execvp(ssh_program, args.list);
a255 5
	args.list = NULL;
	addargs("ssh");	 	/* overwritten with ssh_program */
	addargs("-x");
	addargs("-oFallBackToRsh no");

d257 1
a257 1
	while ((ch = getopt(argc, argv, "dfprtvBCc:i:P:q46S:o:")) != EOF)
d261 2
d264 1
a264 2
		case 'C':
			addargs("-%c", ch);
d266 2
a267 4
		case 'o':
		case 'c':
		case 'i':
			addargs("-%c%s", ch, optarg);
d270 1
a270 7
			addargs("-p%s", optarg);
			break;
		case 'B':
			addargs("-oBatchmode yes");
			break;
		case 'p':
			pflag = 1;
d276 1
a276 7
			ssh_program = xstrdup(optarg);
			break;
		case 'v':
			verbose_mode = 1;
			break;
		case 'q':
			showprogress = 0;
d291 18
d678 1
a679 1
	struct timeval tv[2];
d733 1
a733 1
			getnum(tv[1].tv_sec);
a736 1
			tv[1].tv_usec = 0;
d739 1
a739 1
			getnum(tv[0].tv_sec);
a742 1
			tv[0].tv_usec = 0;
d810 1
a810 1
				if (utimes(np, tv) < 0)
d843 2
a844 4
				j = read(remin, cp, amt);
				if (j == -1 && (errno == EINTR || errno == EAGAIN)) {
					continue;
				} else if (j <= 0) {
d897 1
a897 1
			if (utimes(np, tv) < 0) {
a1222 22
}

void
addargs(char *fmt, ...)
{
	va_list ap;
	char buf[1024];

	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);

	if (args.list == NULL) {
		args.nalloc = 32;
		args.num = 0;
		args.list = xmalloc(args.nalloc * sizeof(char *));
	} else if (args.num+2 >= args.nalloc) {
		args.nalloc *= 2;
		args.list = xrealloc(args.list, args.nalloc * sizeof(char *));
	}
	args.list[args.num++] = xstrdup(buf);
	args.list[args.num] = NULL;
@


1.30.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.59 2001/02/19 10:36:25 deraadt Exp $");
d80 1
d82 2
a83 3
#include "atomicio.h"
#include "pathnames.h"
#include "log.h"
d102 1
a102 1
volatile u_long statbytes;
d113 3
d120 1
a120 1
char *ssh_program = _PATH_SSH_PROGRAM;
d188 13
a223 1
int main(int, char *[]);
a228 1
char *cleanhostname(char *);
d248 1
a248 1
	while ((ch = getopt(argc, argv, "dfprtvBCc:i:P:q46S:o:")) != -1)
d311 1
a311 1
	if (fflag) {
d329 1
a329 2
	(void) snprintf(cmd, sizeof cmd, "scp%s%s%s%s",
	    verbose_mode ? " -v" : "",
d400 6
a405 7
				snprintf(bp, len,
				    "%s%s -x -o'FallBackToRsh no' -n "
				    "-l %s %s %s %s '%s%s%s:%s'",
				    ssh_program, verbose_mode ? " -v" : "",
				    suser, host, cmd, src,
				    tuser ? tuser : "", tuser ? "@@" : "",
				    thost, targ);
d408 6
a413 7
				snprintf(bp, len,
				    "exec %s%s -x -o'FallBackToRsh no' -n %s "
				    "%s %s '%s%s%s:%s'",
				    ssh_program, verbose_mode ? " -v" : "",
				    host, cmd, src,
				    tuser ? tuser : "", tuser ? "@@" : "",
				    thost, targ);
d423 1
a423 1
				(void) snprintf(bp, len, "%s -t %s", cmd, targ);
d450 1
a450 1
			(void) snprintf(bp, len, "exec %s%s%s %s %s", _PATH_CP,
d477 1
a477 1
		(void) snprintf(bp, len, "%s -f %s", cmd, src);
d534 3
a536 3
			(void) snprintf(buf, sizeof buf, "T%lu 0 %lu 0\n",
			    (u_long) stb.st_mtime,
			    (u_long) stb.st_atime);
d542 4
a545 3
		snprintf(buf, sizeof buf, "C%04o %lu %s\n",
		    (u_int) (stb.st_mode & FILEMODEMASK),
		    (u_long) stb.st_size, last);
d612 3
a614 3
		(void) snprintf(path, sizeof(path), "T%lu 0 %lu 0\n",
		    (u_long) statp->st_mtime,
		    (u_long) statp->st_atime);
d621 2
a622 2
	(void) snprintf(path, sizeof path, "D%04o %d %.1024s\n",
	    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);
d639 1
a639 1
		(void) snprintf(path, sizeof path, "%s/%s", name, dp->d_name);
d700 1
a700 1
				    buf + 1, strlen(buf + 1));
d769 1
a769 3
			if (need > cursize) {
				if (namebuf)
					xfree(namebuf);
d771 1
a771 3
				cursize = need;
			}
			(void) snprintf(namebuf, need, "%s%s%s", targ,
d794 1
a794 1
			vect[0] = xstrdup(np);
d798 1
a798 1
				if (utimes(vect[0], tv) < 0)
d800 1
a800 1
					    vect[0], strerror(errno));
d803 1
a803 3
				(void) chmod(vect[0], mode);
			if (vect[0])
				xfree(vect[0]);
d1025 1
a1025 2
		if (!isalpha(c) && !isdigit(c) &&
		    c != '_' && c != '-' && c != '.' && c != '+')
d1092 1
a1092 1
foregroundproc(void)
d1150 3
a1152 3
	snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " %5llu %c%c ",
	    (unsigned long long) abbrevsize, prefixes[i],
	    prefixes[i] == ' ' ? ' ' : 'B');
d1167 1
a1167 2
	if (flag != 1 &&
	    (statbytes <= 0 || elapsed <= 0.0 || cursize > totalbytes)) {
d1169 1
a1169 1
		    "   --:-- ETA");
d1172 1
a1172 1
		    " - stalled -");
d1175 2
a1176 2
			remaining = (int)(totalbytes / (statbytes / elapsed) -
			    elapsed);
@


1.30.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d17 2
a18 2
 * Copyright (c) 1999 Theo de Raadt.  All rights reserved.
 * Copyright (c) 1999 Aaron Campbell.  All rights reserved.
d78 1
a78 1
RCSID("$OpenBSD: scp.c,v 1.61 2001/03/15 15:05:59 markus Exp $");
d531 1
a531 1
		snprintf(buf, sizeof buf, "C%04o %lld %s\n",
d533 1
a533 1
		    stb.st_size, last);
@


1.29
log
@fix very rare EAGAIN/EINTR issues; based on work by djm
@
text
@d48 1
a48 1
RCSID("$Id: scp.c,v 1.28 2000/04/16 04:47:43 deraadt Exp $");
d576 1
a576 1
				result = read(fd, bp->buf, amt);
d695 1
a695 1
		if (read(remin, cp, 1) <= 0)
d700 1
a700 1
			if (read(remin, &ch, sizeof(ch)) != sizeof(ch))
d838 1
a838 1
				j = read(remin, cp, amt);
d851 1
a851 1
					j = write(ofd, bp->buf, count);
d864 1
a864 1
		    (j = write(ofd, bp->buf, count)) != count) {
d916 1
a916 1
	if (read(remin, &resp, sizeof(resp)) != sizeof(resp))
d929 1
a929 1
			if (read(remin, &ch, sizeof(ch)) != sizeof(ch))
d1009 1
a1009 1
 *	$Id: scp.c,v 1.28 2000/04/16 04:47:43 deraadt Exp $
@


1.28
log
@after completion, replace the progress bar ETA counter with a final elapsed time; my idea, aaron wrote the patch
@
text
@d48 1
a48 1
RCSID("$Id: scp.c,v 1.27 2000/04/14 10:30:32 markus Exp $");
d546 1
a546 1
			(void) write(remout, buf, strlen(buf));
d559 1
a559 1
		(void) write(remout, buf, strlen(buf));
d581 1
a581 1
				(void) write(remout, bp->buf, amt);
d583 1
a583 1
				result = write(remout, bp->buf, amt);
d595 1
a595 1
			(void) write(remout, "", 1);
d624 1
a624 1
		(void) write(remout, path, strlen(path));
d635 1
a635 1
	(void) write(remout, path, strlen(path));
d654 1
a654 1
	(void) write(remout, "E\n", 2);
d690 1
a690 1
	(void) write(remout, "", 1);
d708 1
a708 1
				(void) write(STDERR_FILENO,
d716 1
a716 1
			(void) write(remout, "", 1);
d740 1
a740 1
			(void) write(remout, "", 1);
d819 1
a819 1
		(void) write(remout, "", 1);
d900 1
a900 1
			(void) write(remout, "", 1);
d935 1
a935 1
			(void) write(STDERR_FILENO, rbuf, cp - rbuf);
d1009 1
a1009 1
 *	$Id: scp.c,v 1.27 2000/04/14 10:30:32 markus Exp $
d1237 1
a1237 1
		write(fileno(stdout), "\n", 1);
@


1.27
log
@whitespace cleanup
@
text
@d48 1
a48 1
RCSID("$Id: scp.c,v 1.26 2000/03/16 20:56:14 markus Exp $");
d1009 1
a1009 1
 *	$Id: scp.c,v 1.26 2000/03/16 20:56:14 markus Exp $
d1212 6
a1217 1
		remaining = (int) (totalbytes / (statbytes / elapsed) - elapsed);
d1227 2
a1228 1
			 "%02d:%02d ETA", i / 60, i % 60);
@


1.26
log
@-pedantic: signed vs. unsigned, void*-arithm, etc
@
text
@d2 1
a2 1
 * 
d5 1
a5 1
 * 
d8 1
a8 1
 * 
d10 1
a10 1
 * 
d48 1
a48 1
RCSID("$Id: scp.c,v 1.25 2000/01/24 22:11:20 markus Exp $");
d112 1
a112 1
int 
d197 1
a197 1
void 
d260 1
a260 1
	       		IPv4 = 1;
d263 1
a263 1
	       		IPv6 = 1;
d1009 1
a1009 1
 *	$Id: scp.c,v 1.25 2000/01/24 22:11:20 markus Exp $
@


1.25
log
@allow '.' in usernames; from jedgar@@fxp.org
@
text
@d48 1
a48 1
RCSID("$Id: scp.c,v 1.24 2000/01/04 16:57:16 markus Exp $");
d1009 1
a1009 1
 *	$Id: scp.c,v 1.24 2000/01/04 16:57:16 markus Exp $
d1121 1
a1121 1
updateprogressmeter(void)
d1227 1
a1227 1
		signal(SIGALRM, (void *) updateprogressmeter);
@


1.24
log
@document -4, -6, and 'ssh -L 2022/::1/22'
@
text
@d48 1
a48 1
RCSID("$Id: scp.c,v 1.23 2000/01/04 00:07:59 markus Exp $");
d1009 1
a1009 1
 *	$Id: scp.c,v 1.23 2000/01/04 00:07:59 markus Exp $
d1063 1
a1063 1
		if (!isalpha(c) && !isdigit(c) && c != '_' && c != '-')
d1068 1
a1068 1
bad:	fprintf(stderr, "%s: invalid user name", cp0);
@


1.23
log
@ipv6 support: mostly gethostbyname->getaddrinfo/getnameinfo, new features:
sshd allows multiple ListenAddress and Port options.  note that libwrap is
not IPv6-ready. (based on patches from <kick@@kyoto.wide.ad.jp> and
fujiwara@@rcac.tdi.co.jp)
@
text
@d48 1
a48 1
RCSID("$Id: scp.c,v 1.22 1999/12/06 20:15:28 deraadt Exp $");
d948 1
a948 1
		       "usage: scp [-pqrvC] [-P port] [-c cipher] [-i identity] f1 f2; or:\n       scp [options] f1 ... fn directory\n");
d1009 1
a1009 1
 *	$Id: scp.c,v 1.22 1999/12/06 20:15:28 deraadt Exp $
@


1.22
log
@move atomicio into it's own file.  wrap all socket write()s which were doing
write(sock, buf, len) != len, with atomicio() calls.
@
text
@d48 1
a48 1
RCSID("$Id: scp.c,v 1.21 1999/11/24 20:26:35 markus Exp $");
d77 6
d154 5
d256 1
a256 1
	while ((ch = getopt(argc, argv, "dfprtvBCc:i:P:q")) != EOF)
d259 6
d354 11
d403 1
d415 2
a416 1
			} else
d420 1
a420 1
					       argv[i], cmd, src,
d423 1
d433 1
a433 1
				host = thost;
d483 1
d1009 1
a1009 1
 *	$Id: scp.c,v 1.21 1999/11/24 20:26:35 markus Exp $
d1016 2
d1020 2
d1024 5
a1028 1
		if (*cp == ':')
@


1.21
log
@progress meter overflow fix from damien@@ibs.com.au
@
text
@d48 1
a48 1
RCSID("$Id: scp.c,v 1.20 1999/11/24 19:53:50 markus Exp $");
d977 1
a977 1
 *	$Id: scp.c,v 1.20 1999/11/24 19:53:50 markus Exp $
a1067 24
/*
 * ensure all of data on socket comes through. f==read || f==write
 */
int
atomicio(f, fd, s, n)
	int (*f) ();
	char *s;
{
	int res, pos = 0;

	while (n > pos) {
		res = (f) (fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
		case 0:
			return (res);
		default:
			pos += res;
		}
	}
	return (pos);
}
@


1.20
log
@KNF, final part 3
@
text
@d48 1
a48 1
RCSID("$Id: scp.c,v 1.19 1999/11/24 00:26:03 deraadt Exp $");
d977 1
a977 1
 *	$Id: scp.c,v 1.19 1999/11/24 00:26:03 deraadt Exp $
d1149 1
a1149 1
		ratio = cursize * 100 / totalbytes;
@


1.19
log
@much more KNF
@
text
@d48 1
a48 1
RCSID("$Id: scp.c,v 1.18 1999/11/23 22:25:54 markus Exp $");
d100 5
a104 3
/* This function executes the given command as the specified user on the given
   host.  This returns < 0 if execution fails, and >= 0 otherwise.
   This assigns the input and output file descriptors on success. */
d115 4
a118 2
	/* Reserve two descriptors so that the real pipes won't get
	   descriptors 0 and 1 because that will screw up dup2 below. */
d977 1
a977 1
 *	$Id: scp.c,v 1.18 1999/11/23 22:25:54 markus Exp $
@


1.18
log
@KNF part 1
@
text
@d2 9
a10 9

scp - secure remote copy.  This is basically patched BSD rcp which uses ssh
to do the data transfer (instead of using rcmd).

NOTE: This version should NOT be suid root.  (This uses ssh to do the transfer
and ssh has the necessary privileges.)

1995 Timo Rinne <tri@@iki.fi>, Tatu Ylonen <ylo@@cs.hut.fi>

d48 1
a48 1
RCSID("$Id: scp.c,v 1.17 1999/11/22 21:02:38 markus Exp $");
d973 1
a973 1
 *	$Id: scp.c,v 1.17 1999/11/22 21:02:38 markus Exp $
@


1.17
log
@syslog changes:
* Unified Logmessage for all auth-types, for success and for failed
* Standard connections get only ONE line in the LOG when level==LOG:
  Auth-attempts are logged only, if authentication is:
        a) successfull or
        b) with passwd or
        c) we had more than AUTH_FAIL_LOG failues
* many log() became verbose()
* old behaviour with level=VERBOSE
@
text
@d10 1
a10 1
     
a44 1
 *	$Id: scp.c,v 1.16 1999/11/17 09:20:17 deraadt Exp $
d48 1
a48 1
RCSID("$Id: scp.c,v 1.16 1999/11/17 09:20:17 deraadt Exp $");
d93 1
a93 1
/* This is set to the RSA authentication identity file name if given on 
d104 2
a105 1
int do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout)
d107 74
a180 1
  int pin[2], pout[2], reserved[2];
d182 11
a192 88
  if (verbose_mode)
    fprintf(stderr, "Executing: host %s, user %s, command %s\n",
	    host, remuser ? remuser : "(unspecified)", cmd);

  /* Reserve two descriptors so that the real pipes won't get descriptors
     0 and 1 because that will screw up dup2 below. */
  pipe(reserved);

  /* Create a socket pair for communicating with ssh. */
  if (pipe(pin) < 0)
    fatal("pipe: %s", strerror(errno));
  if (pipe(pout) < 0)
    fatal("pipe: %s", strerror(errno));

  /* Free the reserved descriptors. */
  close(reserved[0]);
  close(reserved[1]);

  /* For a child to execute the command on the remote host using ssh. */
  if (fork() == 0) 
    {
      char *args[100];
      unsigned int i;

      /* Child. */
      close(pin[1]);
      close(pout[0]);
      dup2(pin[0], 0);
      dup2(pout[1], 1);
      close(pin[0]);
      close(pout[1]);

      i = 0;
      args[i++] = SSH_PROGRAM;
      args[i++] = "-x";
      args[i++] = "-oFallBackToRsh no";
      if (verbose_mode)
	args[i++] = "-v";
      if (compress)
	args[i++] = "-C";
      if (batchmode)
	args[i++] = "-oBatchMode yes";
      if (cipher != NULL)
	{
	  args[i++] = "-c";
	  args[i++] = cipher;
	}
      if (identity != NULL)
	{
	  args[i++] = "-i";
	  args[i++] = identity;
	}
      if (port != NULL)
	{
	  args[i++] = "-p";
	  args[i++] = port;
	}
      if (remuser != NULL)
	{
	  args[i++] = "-l";
	  args[i++] = remuser;
	}
      args[i++] = host;
      args[i++] = cmd;
      args[i++] = NULL;

      execvp(SSH_PROGRAM, args);
      perror(SSH_PROGRAM);
      exit(1);
    }
  /* Parent.  Close the other side, and return the local side. */
  close(pin[0]);
  *fdout = pin[1];
  close(pout[1]);
  *fdin = pout[0];
  return 0;
}

void fatal(const char *fmt, ...)
{
  va_list ap;
  char buf[1024];

  va_start(ap, fmt);
  vsnprintf(buf, sizeof(buf), fmt, ap);
  va_end(ap);
  fprintf(stderr, "%s\n", buf);
  exit(255);
d204 7
a210 7
BUF	*allocbuf(BUF *, int, int);
char	*colon(char *);
void	 lostconn(int);
void	 nospace(void);
int	 okname(char *);
void	 run_err(const char *, ...);
void	 verifydir(char *);
d215 1
a215 1
uid_t	userid;
d222 7
a228 7
int	 response(void);
void	 rsource(char *, struct stat *);
void	 sink(int, char *[]);
void	 source(int, char *[]);
void	 tolocal(int, char *[]);
void	 toremote(char *, int, char *[]);
void	 usage(void);
d241 3
a243 2
	while ((ch = getopt(argc, argv,  "dfprtvBCc:i:P:q")) != EOF)
		switch(ch) {			/* User-visible flags. */
d248 2
a249 2
		  	port = optarg;
		  	break;
d253 1
a253 1
						/* Server options. */
d257 1
a257 1
		case 'f':			/* "from" */
d261 1
a261 1
		case 't':			/* "to" */
d267 1
a267 1
		  	break;
d269 1
a269 1
		  	identity = optarg;
d273 1
a273 1
		  	break;
d275 2
a276 2
		  	batchmode = 1;
		  	break;
d278 2
a279 2
		  	compress = 1;
		  	break;
d281 2
a282 2
		  	showprogress = 0;
		  	break;
d291 1
a291 1
		fatal("unknown user %d", (int)userid);
d293 1
a293 1
	if (! isatty(STDERR_FILENO))
d299 3
a301 2
	if (fflag) {			/* Follow "protocol", send data. */
		(void)response();
d305 2
a306 2

	if (tflag) {			/* Receive data. */
a309 1

d317 3
a319 3
  	(void)sprintf(cmd, "scp%s%s%s%s", verbose_mode ? " -v" : "",
	    iamrecursive ? " -r" : "", pflag ? " -p" : "",
	    targetshouldbedirectory ? " -d" : "");
d321 1
a321 1
	(void)signal(SIGPIPE, lostconn);
d326 1
a326 1
		tolocal(argc, argv);		/* Dest is local host. */
d360 1
a360 1
		if (src) {			/* remote to remote */
d366 3
a368 3
			    strlen(src) + (tuser ? strlen(tuser) : 0) +
			    strlen(thost) + strlen(targ) + CMDNEEDS + 32;
		        bp = xmalloc(len);
d376 6
a381 6
				(void)sprintf(bp, 
				    "%s%s -x -o'FallBackToRsh no' -n -l %s %s %s %s '%s%s%s:%s'",
				    SSH_PROGRAM, verbose_mode ? " -v" : "",
				    suser, host, cmd, src,
				    tuser ? tuser : "", tuser ? "@@" : "",
				    thost, targ);
d383 11
a393 11
				(void)sprintf(bp,
				    "exec %s%s -x -o'FallBackToRsh no' -n %s %s %s '%s%s%s:%s'",
				    SSH_PROGRAM, verbose_mode ? " -v" : "",
				    argv[i], cmd, src,
				    tuser ? tuser : "", tuser ? "@@" : "",
				    thost, targ);
		        if (verbose_mode)
			  fprintf(stderr, "Executing: %s\n", bp);
			(void)system(bp);
			(void)xfree(bp);
		} else {			/* local to remote */
d396 2
a397 2
			        bp = xmalloc(len);
				(void)sprintf(bp, "%s -t %s", cmd, targ);
d399 1
a399 1
				if (do_cmd(host,  tuser,
d401 1
a401 1
				  exit(1);
d404 1
a404 1
				(void)xfree(bp);
d406 1
a406 1
			source(1, argv+i);
d420 1
a420 1
		if (!(src = colon(argv[i]))) {		/* Local to local. */
d422 1
a422 1
			    strlen(argv[argc - 1]) + 20;
d424 5
a428 5
			(void)sprintf(bp, "exec %s%s%s %s %s", _PATH_CP,
			    iamrecursive ? " -r" : "", pflag ? " -p" : "",
			    argv[i], argv[argc - 1]);
	  		if (verbose_mode)
			  fprintf(stderr, "Executing: %s\n", bp);
d431 1
a431 1
			(void)xfree(bp);
d449 6
a454 6
	        bp = xmalloc(len);
		(void)sprintf(bp, "%s -f %s", cmd, src);
	  	if (do_cmd(host, suser, bp, &remin, &remout) < 0) {
		  (void)xfree(bp);
		  ++errs;
		  continue;
d456 1
a456 1
	  	xfree(bp);
d458 1
a458 1
		(void)close(remin);
d476 1
a476 1
                name = argv[indx];
d507 4
a510 4
			(void)sprintf(buf, "T%lu 0 %lu 0\n",
				      (unsigned long)stb.st_mtime, 
				      (unsigned long)stb.st_atime);
			(void)write(remout, buf, strlen(buf));
d515 9
a523 10
		(void)sprintf(buf, "C%04o %lu %s\n",
			      (unsigned int)(stb.st_mode & FILEMODEMASK), 
			      (unsigned long)stb.st_size, 
			      last);
	        if (verbose_mode)
		  {
		    fprintf(stderr, "Sending file modes: %s", buf);
		    fflush(stderr);
		  }
		(void)write(remout, buf, strlen(buf));
d527 1
a527 1
next:			(void)close(fd);
a529 1

a533 1

d545 1
a545 1
				(void)write(remout, bp->buf, amt);
d553 1
a553 1
		if(showprogress)
d559 1
a559 1
			(void)write(remout, "", 1);
d562 1
a562 1
		(void)response();
d585 4
a588 4
		(void)sprintf(path, "T%lu 0 %lu 0\n",
			      (unsigned long)statp->st_mtime, 
			      (unsigned long)statp->st_atime);
		(void)write(remout, path, strlen(path));
d594 6
a599 6
	(void)sprintf(path, 
	    "D%04o %d %.1024s\n", (unsigned int)(statp->st_mode & FILEMODEMASK),
		      0, last);
  	if (verbose_mode)
	  fprintf(stderr, "Entering directory: %s", path);
	(void)write(remout, path, strlen(path));
d613 1
a613 1
		(void)sprintf(path, "%s/%s", name, dp->d_name);
d617 3
a619 3
	(void)closedir(dirp);
	(void)write(remout, "E\n", 2);
	(void)response();
d629 3
a631 1
	enum { YES, NO, DISPLAYED } wrerr;
d637 2
a638 2
  	struct utimbuf ut;
  	int dummy_usec;
d645 1
a645 1
		(void)umask(mask);
d653 2
a654 2
        
	(void)write(remout, "", 1);
d672 2
a673 2
				(void)write(STDERR_FILENO,
				    buf + 1, strlen(buf + 1));
d680 1
a680 1
			(void)write(remout, "", 1);
a682 1

d704 1
a704 1
			(void)write(remout, "", 1);
d730 1
a730 1
	        for (size = 0; *cp >= '0' && *cp <= '9';)
d741 3
a743 3
			  namebuf = xmalloc(need);
			(void)sprintf(namebuf, "%s%s%s", targ,
			    *targ ? "/" : "", cp);
d757 1
a757 1
					(void)chmod(np, mode);
d759 2
a760 1
				/* Handle copying from a read-only directory */
d770 2
a771 2
				    run_err("%s: set times: %s",
					np, strerror(errno));
d774 1
a774 1
				(void)chmod(np, mode);
d779 1
a779 1
		if ((ofd = open(np, O_WRONLY|O_CREAT|O_TRUNC, mode)) < 0) {
d783 1
a783 1
		(void)write(remout, "", 1);
d785 1
a785 1
			(void)close(ofd);
d805 1
a805 1
					    "dropped connection");
d810 1
a810 1
			statbytes += j;
d818 1
a818 1
						wrerrno = j >= 0 ? EIO : errno; 
d830 1
a830 1
			wrerrno = j >= 0 ? EIO : errno; 
d842 1
a842 1
					    np, strerror(errno));
d847 1
a847 1
					    np, strerror(errno));
d849 2
a850 2
		(void)close(ofd);
		(void)response();
d855 1
a855 1
				    np, strerror(errno));
d859 1
a859 1
		switch(wrerr) {
d864 1
a864 1
			(void)write(remout, "", 1);
d884 2
a885 2
	switch(resp) {
	case 0:				/* ok */
d890 2
a891 2
	case 1:				/* error, followed by error msg */
	case 2:				/* fatal error, "" */
d899 1
a899 1
			(void)write(STDERR_FILENO, rbuf, cp - rbuf);
d911 2
a912 2
	(void)fprintf(stderr,
	    "usage: scp [-pqrvC] [-P port] [-c cipher] [-i identity] f1 f2; or:\n       scp [options] f1 ... fn directory\n");
d917 1
a917 1
run_err(const char *fmt, ...)
d926 10
a935 12
	(void)fprintf(fp, "%c", 0x01);
	(void)fprintf(fp, "scp: ");
	(void)vfprintf(fp, fmt, ap);
	(void)fprintf(fp, "\n");
	(void)fflush(fp);

	if (!iamremote)
	  {
	    vfprintf(stderr, fmt, ap);
	    fprintf(stderr, "\n");
	  }

d973 1
a973 1
 *	$Id: scp.c,v 1.16 1999/11/17 09:20:17 deraadt Exp $
d1040 5
a1044 5
        if (stb.st_blksize == 0)
	  size = blksize;
        else
  	  size = blksize + (stb.st_blksize - blksize % stb.st_blksize) %
	    stb.st_blksize;
d1047 4
a1050 4
  	if (bp->buf == NULL)
	  bp->buf = xmalloc(size);
  	else
	  bp->buf = xrealloc(bp->buf, size);
d1069 2
a1070 2
int (*f)();
char *s;
d1074 2
a1075 2
	while (n>pos) {
		res = (f)(fd, s+pos, n-pos);
d1078 1
a1078 1
			if (errno==EINTR || errno==EAGAIN)
d1092 1
a1092 1
   struct itimerval itv;
d1094 4
a1097 4
   itv.it_value.tv_sec = wait;
   itv.it_value.tv_usec = 0;
   itv.it_interval = itv.it_value;
   setitimer(ITIMER_REAL, &itv, NULL);
d1118 2
a1119 2
	return((ioctl(STDOUT_FILENO, TIOCGPGRP, &ctty_pgrp) != -1 &&
	    ctty_pgrp == pgrp));
d1135 1
a1135 1
		(void)gettimeofday(&start, (struct timezone *)0);
d1138 1
a1138 1
	}   
d1142 1
a1142 1
	(void)gettimeofday(&now, (struct timezone *)0);
d1148 1
a1148 2
	}
	else
d1151 1
a1151 1
	snprintf(buf, sizeof(buf), "\r%-20.20s %3d%% ", curfile, ratio); 
d1157 4
a1160 4
		    "|%.*s%*s|", i,
"*****************************************************************************"
"*****************************************************************************",
		    barlength - i, "");
a1161 1

d1169 2
a1170 2
	    (quad_t)abbrevsize, prefixes[i], prefixes[i] == ' ' ? ' ' :
	    'B');
a1181 1

d1187 1
a1187 1
		    "   --:-- ETA");
d1190 1
a1190 1
		    " - stalled -");
d1192 1
a1192 1
		remaining = (int)(totalbytes / (statbytes / elapsed) - elapsed);
d1196 1
a1196 1
			    "%2d:", i);
d1199 1
a1199 1
			    "   ");
d1202 1
a1202 1
		    "%02d:%02d ETA", i / 60, i % 60);
d1207 1
a1207 1
		signal(SIGALRM, (void *)updateprogressmeter);
d1222 1
a1222 1
		return(winsize.ws_col ? winsize.ws_col : 80);
d1224 1
a1224 1
		return(80);
a1225 2


@


1.16
log
@foregroundproc() in scp
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.15 1999/11/12 17:10:51 markus Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.15 1999/11/12 17:10:51 markus Exp $");
d79 1
a79 1
int verbose = 0;
d109 1
a109 1
  if (verbose)
d145 1
a145 1
      if (verbose)
d275 1
a275 1
			verbose = 1;
d320 1
a320 1
  	(void)sprintf(cmd, "scp%s%s%s%s", verbose ? " -v" : "",
d381 1
a381 1
				    SSH_PROGRAM, verbose ? " -v" : "",
d388 1
a388 1
				    SSH_PROGRAM, verbose ? " -v" : "",
d392 1
a392 1
		        if (verbose)
d430 1
a430 1
	  		if (verbose)
d522 1
a522 1
	        if (verbose)
d603 1
a603 1
  	if (verbose)
d979 1
a979 1
 *	$Id: scp.c,v 1.15 1999/11/12 17:10:51 markus Exp $
@


1.15
log
@fix overflow reported by damien@@ibs.com.au: off_t totalsize, ok niels,aaron
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.14 1999/10/27 02:14:38 aaron Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.14 1999/10/27 02:14:38 aaron Exp $");
d979 1
a979 1
 *	$Id: scp.c,v 1.14 1999/10/27 02:14:38 aaron Exp $
d1115 13
d1145 3
d1164 1
a1164 1
		"|%.*s%*s|", i,
d1167 1
a1167 1
                 barlength - i, "");
@


1.14
log
@Calculation fix in progressmeter() for ETA > 1hr; pasto on my part.
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.13 1999/10/08 01:25:20 aaron Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.13 1999/10/08 01:25:20 aaron Exp $");
d73 1
a73 1
unsigned long totalbytes = 0;
d979 1
a979 1
 *	$Id: scp.c,v 1.13 1999/10/08 01:25:20 aaron Exp $
@


1.13
log
@Print out the progress meter for 0 length files, too; deraadt@@
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.12 1999/10/05 12:17:05 aaron Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.12 1999/10/05 12:17:05 aaron Exp $");
d979 1
a979 1
 *	$Id: scp.c,v 1.12 1999/10/05 12:17:05 aaron Exp $
d1186 1
a1186 1
		i = elapsed / 3600;
@


1.12
log
@- Fix the progress meter for receiving files, too.
- Add a check for totalbytes <= 0 in progressmeter(), so we don't / 0.
- Reset statbytes when we issue progressmeter(1), just to be safe.
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.11 1999/10/05 10:58:37 aaron Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.11 1999/10/05 10:58:37 aaron Exp $");
d979 1
a979 1
 *	$Id: scp.c,v 1.11 1999/10/05 10:58:37 aaron Exp $
a1132 2
	if (totalbytes <= 0)
		return;
d1134 8
a1141 3
	ratio = cursize * 100 / totalbytes;
	ratio = MAX(ratio, 0);
	ratio = MIN(ratio, 100);
@


1.11
log
@Show filenames in the progress meter while transferring.
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.10 1999/10/04 01:59:56 deraadt Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.10 1999/10/04 01:59:56 deraadt Exp $");
d535 2
a536 4
		totalbytes = stb.st_size;

		/* kick-start the progress meter */
		if(showprogress)
d538 1
d752 1
d799 1
d979 1
a979 1
 *	$Id: scp.c,v 1.10 1999/10/04 01:59:56 deraadt Exp $
d1133 2
d1202 1
@


1.10
log
@it is incredible what some people try to do in signal handlers
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.9 1999/10/03 20:43:12 deraadt Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.9 1999/10/03 20:43:12 deraadt Exp $");
d57 1
a57 1
/* For progressmeter() function. */
d60 7
d68 5
a72 1
unsigned long statbytes = 0;
d74 3
a76 2
void progressmeter(int);
int getttywidth(void);
d480 1
d504 1
d978 1
a978 1
 *	$Id: scp.c,v 1.9 1999/10/03 20:43:12 deraadt Exp $
d1119 1
a1119 1
	static off_t lastsize = 0;
d1129 1
d1136 1
a1136 1
	snprintf(buf, sizeof(buf), "\r%3d%% ", ratio); 
d1138 1
a1138 1
	barlength = getttywidth() - 30;
@


1.9
log
@errno trashing considered harmfull
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.8 1999/10/02 19:18:22 deraadt Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.8 1999/10/02 19:18:22 deraadt Exp $");
d964 1
a964 1
 *	$Id: scp.c,v 1.8 1999/10/02 19:18:22 deraadt Exp $
d1055 25
d1140 2
a1141 2
		(quad_t)abbrevsize, prefixes[i], prefixes[i] == ' ' ? ' ' :
		'B');
d1159 1
a1159 1
			"   --:-- ETA");
d1162 1
a1162 1
			" - stalled -");
d1168 1
a1168 1
				"%2d:", i);
d1171 1
a1171 1
				"   ");
d1174 1
a1174 1
			"%02d:%02d ETA", i / 60, i % 60);
d1176 1
a1176 1
	write(fileno(stdout), buf, strlen(buf));
d1182 2
a1183 2
			alarmtimer(0);
			putc('\n', stdout);
a1184 1
	fflush(stdout);
@


1.8
log
@Wall
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.7 1999/10/02 18:33:56 deraadt Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.7 1999/10/02 18:33:56 deraadt Exp $");
d964 1
a964 1
 *	$Id: scp.c,v 1.7 1999/10/02 18:33:56 deraadt Exp $
d1069 2
d1072 1
@


1.7
log
@isatty() fixes for the progress meter; markus.friedl@@informatik.uni-erlangen.de
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.6 1999/09/30 21:25:03 aaron Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.6 1999/09/30 21:25:03 aaron Exp $");
d64 1
d964 1
a964 1
 *	$Id: scp.c,v 1.6 1999/09/30 21:25:03 aaron Exp $
d1055 2
a1056 1
void alarmtimer(int wait)
d1066 2
a1067 1
static void updateprogressmeter(void)
d1072 2
a1073 1
void progressmeter(int flag)
d1160 2
a1161 1
int getttywidth(void)
@


1.6
log
@- Add -q option to shutup the progressmeter; markus friedl
- Describe -q in man page (needs conversion to mdoc still).
- Cleanup usage string.
- Correct a typo; espie@@
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.5 1999/09/30 05:11:29 deraadt Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.5 1999/09/30 05:11:29 deraadt Exp $");
d283 3
d779 5
d798 1
d813 2
d963 1
a963 1
 *	$Id: scp.c,v 1.5 1999/09/30 05:11:29 deraadt Exp $
@


1.5
log
@do not bother with dinosaur pacification
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.4 1999/09/30 01:21:41 aaron Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.4 1999/09/30 01:21:41 aaron Exp $");
d71 3
d232 1
a232 1
	while ((ch = getopt(argc, argv,  "dfprtvBCc:i:P:")) != EOF)
d270 3
d520 2
a521 1
		progressmeter(-1);
d542 2
a543 1
		progressmeter(1);
d889 1
a889 1
	    "usage: scp [-p] f1 f2; or: scp [-pr] f1 ... fn directory\n");
d952 1
a952 1
 *	$Id: scp.c,v 1.4 1999/09/30 01:21:41 aaron Exp $
d1112 1
a1112 1
	elapsed = td.tv_sec + (td.tv_sec / 1000000.0);
@


1.4
log
@Put our ftp(1) progress meter into scp(1).
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.3 1999/09/29 21:15:54 deraadt Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.3 1999/09/29 21:15:54 deraadt Exp $");
a52 1
#ifdef HAVE_UTIME_H
a53 13
#ifdef _NEXT_SOURCE
struct utimbuf {
  time_t actime;
  time_t modtime;
};
#endif /* _NEXT_SOURCE */
#else
struct utimbuf
{
  long actime;
  long modtime;
};
#endif
a56 10
#ifndef STDIN_FILENO
#define STDIN_FILENO 0
#endif
#ifndef STDOUT_FILENO
#define STDOUT_FILENO 1
#endif
#ifndef STDERR_FILENO
#define STDERR_FILENO 2
#endif

a808 1
#ifdef HAVE_FCHMOD
a809 3
#else /* HAVE_FCHMOD */
				if (chmod(np, omode))
#endif /* HAVE_FCHMOD */
a813 1
#ifdef HAVE_FCHMOD
a814 3
#else /* HAVE_FCHMOD */
				if (chmod(np, omode & ~mask))
#endif /* HAVE_FCHMOD */
d944 1
a944 1
 *	$Id: scp.c,v 1.3 1999/09/29 21:15:54 deraadt Exp $
@


1.3
log
@we have setsid
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.2 1999/09/29 18:16:20 dugsong Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.2 1999/09/29 18:16:20 dugsong Exp $");
d81 8
d535 5
d556 1
d559 2
d976 1
a976 1
 *	$Id: scp.c,v 1.2 1999/09/29 18:16:20 dugsong Exp $
d1066 114
@


1.2
log
@update krb4/AFS support to ssh-1.2.27-afs-kerberos-pl1 level, clean up unused variables, update manpages
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.1 1999/09/26 20:53:37 deraadt Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.1 1999/09/26 20:53:37 deraadt Exp $");
d960 1
a960 1
 *	$Id: scp.c,v 1.1 1999/09/26 20:53:37 deraadt Exp $
a1020 1
#ifdef HAVE_ST_BLKSIZE
d1031 1
a1031 4
	  stb.st_blksize;
#else /* HAVE_ST_BLKSIZE */
	size = blksize;
#endif /* HAVE_ST_BLKSIZE */
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d45 1
a45 1
 *	$Id: scp.c,v 1.6 1999/05/04 11:59:09 bg Exp $
d49 1
a49 1
RCSID("$Id: scp.c,v 1.6 1999/05/04 11:59:09 bg Exp $");
a80 5
#if defined(KERBEROS_TGT_PASSING) || defined(AFS)
/* This is set to non-zero to disable authentication forwarding. */
int nofwd = 0;
#endif
 
a150 4
#if defined(KERBEROS_TGT_PASSING) || defined(AFS)
      if (nofwd)
	args[i++] = "-k";
#endif
a244 3
#if defined(KERBEROS_TGT_PASSING) || defined(AFS)
	while ((ch = getopt(argc, argv, "kdfprtvBCc:i:P:")) != EOF)
#else
a245 1
#endif
a256 5
#if defined(KERBEROS_TGT_PASSING) || defined(AFS)
 	        case 'k':
			nofwd = 1;
			break;
#endif
d960 1
a960 1
 *	$Id: scp.c,v 1.6 1999/05/04 11:59:09 bg Exp $
@

