head	1.92;
access;
symbols
	OPENBSD_6_1:1.89.0.4
	OPENBSD_6_1_BASE:1.89
	OPENBSD_6_0:1.88.0.4
	OPENBSD_6_0_BASE:1.88
	OPENBSD_5_9:1.87.0.2
	OPENBSD_5_9_BASE:1.87
	OPENBSD_5_8:1.85.0.2
	OPENBSD_5_8_BASE:1.85
	OPENBSD_5_7:1.84.0.2
	OPENBSD_5_7_BASE:1.84
	OPENBSD_5_6:1.80.0.4
	OPENBSD_5_6_BASE:1.80
	OPENBSD_5_5:1.79.0.4
	OPENBSD_5_5_BASE:1.79
	OPENBSD_5_4:1.76.0.2
	OPENBSD_5_4_BASE:1.76
	OPENBSD_5_3:1.75.0.2
	OPENBSD_5_3_BASE:1.75
	OPENBSD_5_2:1.73.0.6
	OPENBSD_5_2_BASE:1.73
	OPENBSD_5_1_BASE:1.73
	OPENBSD_5_1:1.73.0.4
	OPENBSD_5_0:1.73.0.2
	OPENBSD_5_0_BASE:1.73
	OPENBSD_4_9:1.70.0.2
	OPENBSD_4_9_BASE:1.70
	OPENBSD_4_8:1.69.0.4
	OPENBSD_4_8_BASE:1.69
	OPENBSD_4_7:1.69.0.2
	OPENBSD_4_7_BASE:1.69
	OPENBSD_4_6:1.68.0.4
	OPENBSD_4_6_BASE:1.68
	OPENBSD_4_5:1.64.0.2
	OPENBSD_4_5_BASE:1.64
	OPENBSD_4_4:1.63.0.2
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.60.0.2
	OPENBSD_4_3_BASE:1.60
	OPENBSD_4_2:1.57.0.2
	OPENBSD_4_2_BASE:1.57
	OPENBSD_4_1:1.55.0.2
	OPENBSD_4_1_BASE:1.55
	OPENBSD_4_0:1.54.0.4
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.40.0.4
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.40.0.2
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.39.0.4
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.39.0.2
	OPENBSD_3_6_BASE:1.39
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_2_9:1.7.0.4
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5;
locks; strict;
comment	@ * @;


1.92
date	2017.05.30.14.10.53;	author markus;	state Exp;
branches;
next	1.91;
commitid	YtVAQPzV4sHWCSyk;

1.91
date	2017.05.30.08.52.19;	author markus;	state Exp;
branches;
next	1.90;
commitid	AQD3o1zTZEMIcuBx;

1.90
date	2017.05.17.01.24.17;	author djm;	state Exp;
branches;
next	1.89;
commitid	eeQm0WTdCYidaM5F;

1.89
date	2016.08.13.17.47.41;	author markus;	state Exp;
branches;
next	1.88;
commitid	dl4RDERdJITM8DKC;

1.88
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.87;
commitid	kr9hjdmg99uVnhW2;

1.87
date	2016.01.14.16.17.40;	author markus;	state Exp;
branches;
next	1.86;
commitid	W9ye0gltieEl87AJ;

1.86
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.85;
commitid	K3glY441IowbrjDE;

1.85
date	2015.05.01.03.23.51;	author djm;	state Exp;
branches;
next	1.84;
commitid	weFq4BCuIOdeuIhV;

1.84
date	2015.02.16.22.13.32;	author djm;	state Exp;
branches;
next	1.83;
commitid	vWL0dluw4oITNbM8;

1.83
date	2015.01.19.20.16.15;	author markus;	state Exp;
branches;
next	1.82;
commitid	U9l75XYAjMKaQ8Jp;

1.82
date	2015.01.19.19.52.16;	author markus;	state Exp;
branches;
next	1.81;
commitid	UHlhoIB5NMb8eAPm;

1.81
date	2015.01.13.19.31.40;	author markus;	state Exp;
branches;
next	1.80;
commitid	sCqZ9ho1RfL2Vg0U;

1.80
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2014.01.29.06.18.35;	author djm;	state Exp;
branches;
next	1.77;

1.77
date	2013.11.06.16.52.11;	author markus;	state Exp;
branches;
next	1.76;

1.76
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2013.01.08.18.49.04;	author markus;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2012.10.01.13.59.51;	author naddy;	state Exp;
branches;
next	1.73;

1.73
date	2011.06.17.21.44.31;	author djm;	state Exp;
branches;
next	1.72;

1.72
date	2011.05.23.03.30.07;	author djm;	state Exp;
branches;
next	1.71;

1.71
date	2011.05.20.03.25.45;	author djm;	state Exp;
branches;
next	1.70;

1.70
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.69;

1.69
date	2010.03.07.11.57.13;	author dtucker;	state Exp;
branches;
next	1.68;

1.68
date	2009.06.22.05.39.28;	author dtucker;	state Exp;
branches;
next	1.67;

1.67
date	2009.05.28.16.50.16;	author andreas;	state Exp;
branches;
next	1.66;

1.66
date	2009.05.25.06.48.01;	author andreas;	state Exp;
branches;
next	1.65;

1.65
date	2009.03.05.07.18.19;	author djm;	state Exp;
branches;
next	1.64;

1.64
date	2008.11.04.08.22.13;	author djm;	state Exp;
branches;
next	1.63;

1.63
date	2008.07.10.18.08.11;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2008.05.08.12.21.16;	author djm;	state Exp;
branches;
next	1.61;

1.61
date	2008.05.08.12.02.23;	author djm;	state Exp;
branches;
next	1.60;

1.60
date	2007.10.29.04.08.08;	author dtucker;	state Exp;
branches;
next	1.59;

1.59
date	2007.09.21.08.15.29;	author djm;	state Exp;
branches;
next	1.58;

1.58
date	2007.09.04.03.21.03;	author djm;	state Exp;
branches;
next	1.57;

1.57
date	2007.06.07.19.37.34;	author pvalchev;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.05.06.52.37;	author djm;	state Exp;
branches;
next	1.55;

1.55
date	2007.02.19.10.45.58;	author dtucker;	state Exp;
branches;
next	1.54;

1.54
date	2006.08.12.20.46.46;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2006.08.06.01.13.32;	author stevesk;	state Exp;
branches;
next	1.52;

1.52
date	2006.08.05.08.28.24;	author dtucker;	state Exp;
branches;
next	1.51;

1.51
date	2006.08.05.07.52.52;	author dtucker;	state Exp;
branches;
next	1.50;

1.50
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.48;

1.48
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.47;

1.47
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.46;

1.46
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.30.09.58.15;	author djm;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.42;

1.42
date	2006.03.20.18.14.02;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.24.17.32.43;	author avsm;	state Exp;
branches
	1.40.2.1
	1.40.4.1;
next	1.39;

1.39
date	2004.07.17.05.31.41;	author dtucker;	state Exp;
branches
	1.39.2.1
	1.39.4.1;
next	1.38;

1.38
date	2004.07.03.11.02.25;	author dtucker;	state Exp;
branches;
next	1.37;

1.37
date	2004.06.22.05.05.45;	author dtucker;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches;
next	1.35;

1.35
date	2003.11.17.11.06.07;	author markus;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2003.10.15.09.48.45;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.11.11.36.23;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.23.20.17.11;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2003.08.28.12.54.34;	author markus;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2003.08.24.17.36.52;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.22.10.56.09;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.22.13.35.22;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.28.16.23.06;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.07.08.29.57;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.02.09.48.07;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.01.10.22.21;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.01.10.10.23;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.16.17.30.33;	author markus;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2003.02.04.09.33.22;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.21.23.03.51;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.26.11.38.43;	author markus;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2002.09.09.14.54.15;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.09.06.48.06;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.04.10.41.47;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.04.04.15.33;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.30.21.59.45;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.28.01.50.37;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.26.15.00.32;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.19.18.01.00;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.14.21.35.00;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.04.23.05.49;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.15.15.47.49;	author mouring;	state Exp;
branches
	1.7.2.1
	1.7.4.1;
next	1.6;

1.6
date	2002.05.12.23.53.45;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.25.20.12.10;	author stevesk;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.03.19.14.27.39;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.19.10.41.32;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.19.10.35.39;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.03.18.17.28.37;	author provos;	state Exp;
branches;
next	;

1.5.2.1
date	2002.05.18.04.12.11;	author jason;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.05.18.04.50.38;	author jason;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.7.2.1
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.19.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.22.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.31.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.35.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	;

1.39.2.1
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.39.4.1
date	2005.09.04.18.40.02;	author brad;	state Exp;
branches;
next	;

1.40.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.40.4.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;

1.75.2.1
date	2013.11.08.05.52.21;	author djm;	state Exp;
branches;
next	;

1.76.2.1
date	2013.11.08.00.25.26;	author djm;	state Exp;
branches;
next	;


desc
@@


1.92
log
@switch auth2-pubkey.c to modern APIs; with & ok djm@@
@
text
@/* $OpenBSD: monitor_wrap.c,v 1.91 2017/05/30 08:52:19 markus Exp $ */
/*
 * Copyright 2002 Niels Provos <provos@@citi.umich.edu>
 * Copyright 2002 Markus Friedl <markus@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/uio.h>
#include <sys/queue.h>

#include <errno.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#ifdef WITH_OPENSSL
#include <openssl/bn.h>
#include <openssl/dh.h>
#endif

#include "xmalloc.h"
#include "ssh.h"
#ifdef WITH_OPENSSL
#include "dh.h"
#endif
#include "buffer.h"
#include "key.h"
#include "cipher.h"
#include "kex.h"
#include "hostfile.h"
#include "auth.h"
#include "auth-options.h"
#include "packet.h"
#include "mac.h"
#include "log.h"
#include <zlib.h>
#include "monitor.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"
#include "atomicio.h"
#include "monitor_fdpass.h"
#include "misc.h"
#include "uuencode.h"

#include "channels.h"
#include "session.h"
#include "servconf.h"

#include "ssherr.h"

/* Imports */
extern z_stream incoming_stream;
extern z_stream outgoing_stream;
extern struct monitor *pmonitor;
extern Buffer loginmsg;
extern ServerOptions options;

void
mm_log_handler(LogLevel level, const char *msg, void *ctx)
{
	Buffer log_msg;
	struct monitor *mon = (struct monitor *)ctx;

	if (mon->m_log_sendfd == -1)
		fatal("%s: no log channel", __func__);

	buffer_init(&log_msg);
	/*
	 * Placeholder for packet length. Will be filled in with the actual
	 * packet length once the packet has been constucted. This saves
	 * fragile math.
	 */
	buffer_put_int(&log_msg, 0);

	buffer_put_int(&log_msg, level);
	buffer_put_cstring(&log_msg, msg);
	put_u32(buffer_ptr(&log_msg), buffer_len(&log_msg) - 4);
	if (atomicio(vwrite, mon->m_log_sendfd, buffer_ptr(&log_msg),
	    buffer_len(&log_msg)) != buffer_len(&log_msg))
		fatal("%s: write: %s", __func__, strerror(errno));
	buffer_free(&log_msg);
}

int
mm_is_monitor(void)
{
	/*
	 * m_pid is only set in the privileged part, and
	 * points to the unprivileged child.
	 */
	return (pmonitor && pmonitor->m_pid > 0);
}

void
mm_request_send(int sock, enum monitor_reqtype type, Buffer *m)
{
	u_int mlen = buffer_len(m);
	u_char buf[5];

	debug3("%s entering: type %d", __func__, type);

	put_u32(buf, mlen + 1);
	buf[4] = (u_char) type;		/* 1st byte of payload is mesg-type */
	if (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))
		fatal("%s: write: %s", __func__, strerror(errno));
	if (atomicio(vwrite, sock, buffer_ptr(m), mlen) != mlen)
		fatal("%s: write: %s", __func__, strerror(errno));
}

void
mm_request_receive(int sock, Buffer *m)
{
	u_char buf[4];
	u_int msg_len;

	debug3("%s entering", __func__);

	if (atomicio(read, sock, buf, sizeof(buf)) != sizeof(buf)) {
		if (errno == EPIPE)
			cleanup_exit(255);
		fatal("%s: read: %s", __func__, strerror(errno));
	}
	msg_len = get_u32(buf);
	if (msg_len > 256 * 1024)
		fatal("%s: read: bad msg_len %d", __func__, msg_len);
	buffer_clear(m);
	buffer_append_space(m, msg_len);
	if (atomicio(read, sock, buffer_ptr(m), msg_len) != msg_len)
		fatal("%s: read: %s", __func__, strerror(errno));
}

void
mm_request_receive_expect(int sock, enum monitor_reqtype type, Buffer *m)
{
	u_char rtype;

	debug3("%s entering: type %d", __func__, type);

	mm_request_receive(sock, m);
	rtype = buffer_get_char(m);
	if (rtype != type)
		fatal("%s: read: rtype %d != type %d", __func__,
		    rtype, type);
}

#ifdef WITH_OPENSSL
DH *
mm_choose_dh(int min, int nbits, int max)
{
	BIGNUM *p, *g;
	int success = 0;
	Buffer m;

	buffer_init(&m);
	buffer_put_int(&m, min);
	buffer_put_int(&m, nbits);
	buffer_put_int(&m, max);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_MODULI, &m);

	debug3("%s: waiting for MONITOR_ANS_MODULI", __func__);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_MODULI, &m);

	success = buffer_get_char(&m);
	if (success == 0)
		fatal("%s: MONITOR_ANS_MODULI failed", __func__);

	if ((p = BN_new()) == NULL)
		fatal("%s: BN_new failed", __func__);
	if ((g = BN_new()) == NULL)
		fatal("%s: BN_new failed", __func__);
	buffer_get_bignum2(&m, p);
	buffer_get_bignum2(&m, g);

	debug3("%s: remaining %d", __func__, buffer_len(&m));
	buffer_free(&m);

	return (dh_new_group(g, p));
}
#endif

int
mm_key_sign(struct sshkey *key, u_char **sigp, u_int *lenp,
    const u_char *data, u_int datalen, const char *hostkey_alg)
{
	struct kex *kex = *pmonitor->m_pkex;
	Buffer m;

	debug3("%s entering", __func__);

	buffer_init(&m);
	buffer_put_int(&m, kex->host_key_index(key, 0, active_state));
	buffer_put_string(&m, data, datalen);
	buffer_put_cstring(&m, hostkey_alg);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SIGN, &m);

	debug3("%s: waiting for MONITOR_ANS_SIGN", __func__);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SIGN, &m);
	*sigp  = buffer_get_string(&m, lenp);
	buffer_free(&m);

	return (0);
}

struct passwd *
mm_getpwnamallow(const char *username)
{
	Buffer m;
	struct passwd *pw;
	u_int len, i;
	ServerOptions *newopts;

	debug3("%s entering", __func__);

	buffer_init(&m);
	buffer_put_cstring(&m, username);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PWNAM, &m);

	debug3("%s: waiting for MONITOR_ANS_PWNAM", __func__);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PWNAM, &m);

	if (buffer_get_char(&m) == 0) {
		pw = NULL;
		goto out;
	}
	pw = buffer_get_string(&m, &len);
	if (len != sizeof(struct passwd))
		fatal("%s: struct passwd size mismatch", __func__);
	pw->pw_name = buffer_get_string(&m, NULL);
	pw->pw_passwd = buffer_get_string(&m, NULL);
	pw->pw_gecos = buffer_get_string(&m, NULL);
	pw->pw_class = buffer_get_string(&m, NULL);
	pw->pw_dir = buffer_get_string(&m, NULL);
	pw->pw_shell = buffer_get_string(&m, NULL);

out:
	/* copy options block as a Match directive may have changed some */
	newopts = buffer_get_string(&m, &len);
	if (len != sizeof(*newopts))
		fatal("%s: option block size mismatch", __func__);

#define M_CP_STROPT(x) do { \
		if (newopts->x != NULL) \
			newopts->x = buffer_get_string(&m, NULL); \
	} while (0)
#define M_CP_STRARRAYOPT(x, nx) do { \
		for (i = 0; i < newopts->nx; i++) \
			newopts->x[i] = buffer_get_string(&m, NULL); \
	} while (0)
	/* See comment in servconf.h */
	COPY_MATCH_STRING_OPTS();
#undef M_CP_STROPT
#undef M_CP_STRARRAYOPT

	copy_set_server_options(&options, newopts, 1);
	log_change_level(options.log_level);
	free(newopts);

	buffer_free(&m);

	return (pw);
}

char *
mm_auth2_read_banner(void)
{
	Buffer m;
	char *banner;

	debug3("%s entering", __func__);

	buffer_init(&m);
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_AUTH2_READ_BANNER, &m);
	buffer_clear(&m);

	mm_request_receive_expect(pmonitor->m_recvfd,
	    MONITOR_ANS_AUTH2_READ_BANNER, &m);
	banner = buffer_get_string(&m, NULL);
	buffer_free(&m);

	/* treat empty banner as missing banner */
	if (strlen(banner) == 0) {
		free(banner);
		banner = NULL;
	}
	return (banner);
}

/* Inform the privileged process about service and style */

void
mm_inform_authserv(char *service, char *style)
{
	Buffer m;

	debug3("%s entering", __func__);

	buffer_init(&m);
	buffer_put_cstring(&m, service);
	buffer_put_cstring(&m, style ? style : "");

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_AUTHSERV, &m);

	buffer_free(&m);
}

/* Do the password authentication */
int
mm_auth_password(Authctxt *authctxt, char *password)
{
	Buffer m;
	int authenticated = 0;

	debug3("%s entering", __func__);

	buffer_init(&m);
	buffer_put_cstring(&m, password);
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_AUTHPASSWORD, &m);

	debug3("%s: waiting for MONITOR_ANS_AUTHPASSWORD", __func__);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_AUTHPASSWORD, &m);

	authenticated = buffer_get_int(&m);

	buffer_free(&m);

	debug3("%s: user %sauthenticated",
	    __func__, authenticated ? "" : "not ");
	return (authenticated);
}

int
mm_user_key_allowed(struct passwd *pw, struct sshkey *key,
    int pubkey_auth_attempt)
{
	return (mm_key_allowed(MM_USERKEY, NULL, NULL, key,
	    pubkey_auth_attempt));
}

int
mm_hostbased_key_allowed(struct passwd *pw, const char *user, const char *host,
    struct sshkey *key)
{
	return (mm_key_allowed(MM_HOSTKEY, user, host, key, 0));
}

int
mm_key_allowed(enum mm_keytype type, const char *user, const char *host,
    struct sshkey *key, int pubkey_auth_attempt)
{
	Buffer m;
	u_char *blob;
	u_int len;
	int allowed = 0, have_forced = 0;

	debug3("%s entering", __func__);

	/* Convert the key to a blob and the pass it over */
	if (!key_to_blob(key, &blob, &len))
		return (0);

	buffer_init(&m);
	buffer_put_int(&m, type);
	buffer_put_cstring(&m, user ? user : "");
	buffer_put_cstring(&m, host ? host : "");
	buffer_put_string(&m, blob, len);
	buffer_put_int(&m, pubkey_auth_attempt);
	free(blob);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_KEYALLOWED, &m);

	debug3("%s: waiting for MONITOR_ANS_KEYALLOWED", __func__);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_KEYALLOWED, &m);

	allowed = buffer_get_int(&m);

	/* fake forced command */
	auth_clear_options();
	have_forced = buffer_get_int(&m);
	forced_command = have_forced ? xstrdup("true") : NULL;

	buffer_free(&m);

	return (allowed);
}

/*
 * This key verify needs to send the key type along, because the
 * privileged parent makes the decision if the key is allowed
 * for authentication.
 */

int
mm_sshkey_verify(const struct sshkey *key, const u_char *sig, size_t siglen,
    const u_char *data, size_t datalen, u_int compat)
{
	Buffer m;
	u_char *blob;
	u_int len;
	u_int encoded_ret = 0;

	debug3("%s entering", __func__);

	/* Convert the key to a blob and the pass it over */
	if (!key_to_blob(key, &blob, &len))
		return (0);

	buffer_init(&m);
	buffer_put_string(&m, blob, len);
	buffer_put_string(&m, sig, siglen);
	buffer_put_string(&m, data, datalen);
	free(blob);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_KEYVERIFY, &m);

	debug3("%s: waiting for MONITOR_ANS_KEYVERIFY", __func__);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_KEYVERIFY, &m);

	encoded_ret = buffer_get_int(&m);

	buffer_free(&m);

	if (encoded_ret != 0)
		return SSH_ERR_SIGNATURE_INVALID;
	return 0;
}

void
mm_send_keystate(struct monitor *monitor)
{
	struct ssh *ssh = active_state;		/* XXX */
	struct sshbuf *m;
	int r;

	if ((m = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = ssh_packet_get_state(ssh, m)) != 0)
		fatal("%s: get_state failed: %s",
		    __func__, ssh_err(r));
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_KEYEXPORT, m);
	debug3("%s: Finished sending state", __func__);
	sshbuf_free(m);
}

int
mm_pty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)
{
	Buffer m;
	char *p, *msg;
	int success = 0, tmp1 = -1, tmp2 = -1;

	/* Kludge: ensure there are fds free to receive the pty/tty */
	if ((tmp1 = dup(pmonitor->m_recvfd)) == -1 ||
	    (tmp2 = dup(pmonitor->m_recvfd)) == -1) {
		error("%s: cannot allocate fds for pty", __func__);
		if (tmp1 > 0)
			close(tmp1);
		if (tmp2 > 0)
			close(tmp2);
		return 0;
	}
	close(tmp1);
	close(tmp2);

	buffer_init(&m);
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PTY, &m);

	debug3("%s: waiting for MONITOR_ANS_PTY", __func__);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PTY, &m);

	success = buffer_get_int(&m);
	if (success == 0) {
		debug3("%s: pty alloc failed", __func__);
		buffer_free(&m);
		return (0);
	}
	p = buffer_get_string(&m, NULL);
	msg = buffer_get_string(&m, NULL);
	buffer_free(&m);

	strlcpy(namebuf, p, namebuflen); /* Possible truncation */
	free(p);

	buffer_append(&loginmsg, msg, strlen(msg));
	free(msg);

	if ((*ptyfd = mm_receive_fd(pmonitor->m_recvfd)) == -1 ||
	    (*ttyfd = mm_receive_fd(pmonitor->m_recvfd)) == -1)
		fatal("%s: receive fds failed", __func__);

	/* Success */
	return (1);
}

void
mm_session_pty_cleanup2(Session *s)
{
	Buffer m;

	if (s->ttyfd == -1)
		return;
	buffer_init(&m);
	buffer_put_cstring(&m, s->tty);
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PTYCLEANUP, &m);
	buffer_free(&m);

	/* closed dup'ed master */
	if (s->ptymaster != -1 && close(s->ptymaster) < 0)
		error("close(s->ptymaster/%d): %s",
		    s->ptymaster, strerror(errno));

	/* unlink pty from session */
	s->ttyfd = -1;
}

/* Request process termination */

void
mm_terminate(void)
{
	Buffer m;

	buffer_init(&m);
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_TERM, &m);
	buffer_free(&m);
}

static void
mm_chall_setup(char **name, char **infotxt, u_int *numprompts,
    char ***prompts, u_int **echo_on)
{
	*name = xstrdup("");
	*infotxt = xstrdup("");
	*numprompts = 1;
	*prompts = xcalloc(*numprompts, sizeof(char *));
	*echo_on = xcalloc(*numprompts, sizeof(u_int));
	(*echo_on)[0] = 0;
}

int
mm_bsdauth_query(void *ctx, char **name, char **infotxt,
   u_int *numprompts, char ***prompts, u_int **echo_on)
{
	Buffer m;
	u_int success;
	char *challenge;

	debug3("%s: entering", __func__);

	buffer_init(&m);
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_BSDAUTHQUERY, &m);

	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_BSDAUTHQUERY,
	    &m);
	success = buffer_get_int(&m);
	if (success == 0) {
		debug3("%s: no challenge", __func__);
		buffer_free(&m);
		return (-1);
	}

	/* Get the challenge, and format the response */
	challenge  = buffer_get_string(&m, NULL);
	buffer_free(&m);

	mm_chall_setup(name, infotxt, numprompts, prompts, echo_on);
	(*prompts)[0] = challenge;

	debug3("%s: received challenge: %s", __func__, challenge);

	return (0);
}

int
mm_bsdauth_respond(void *ctx, u_int numresponses, char **responses)
{
	Buffer m;
	int authok;

	debug3("%s: entering", __func__);
	if (numresponses != 1)
		return (-1);

	buffer_init(&m);
	buffer_put_cstring(&m, responses[0]);
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_BSDAUTHRESPOND, &m);

	mm_request_receive_expect(pmonitor->m_recvfd,
	    MONITOR_ANS_BSDAUTHRESPOND, &m);

	authok = buffer_get_int(&m);
	buffer_free(&m);

	return ((authok == 0) ? -1 : 0);
}

#ifdef GSSAPI
OM_uint32
mm_ssh_gssapi_server_ctx(Gssctxt **ctx, gss_OID goid)
{
	Buffer m;
	OM_uint32 major;

	/* Client doesn't get to see the context */
	*ctx = NULL;

	buffer_init(&m);
	buffer_put_string(&m, goid->elements, goid->length);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSSETUP, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSSETUP, &m);

	major = buffer_get_int(&m);

	buffer_free(&m);
	return (major);
}

OM_uint32
mm_ssh_gssapi_accept_ctx(Gssctxt *ctx, gss_buffer_desc *in,
    gss_buffer_desc *out, OM_uint32 *flags)
{
	Buffer m;
	OM_uint32 major;
	u_int len;

	buffer_init(&m);
	buffer_put_string(&m, in->value, in->length);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSSTEP, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSSTEP, &m);

	major = buffer_get_int(&m);
	out->value = buffer_get_string(&m, &len);
	out->length = len;
	if (flags)
		*flags = buffer_get_int(&m);

	buffer_free(&m);

	return (major);
}

OM_uint32
mm_ssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)
{
	Buffer m;
	OM_uint32 major;

	buffer_init(&m);
	buffer_put_string(&m, gssbuf->value, gssbuf->length);
	buffer_put_string(&m, gssmic->value, gssmic->length);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSCHECKMIC, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSCHECKMIC,
	    &m);

	major = buffer_get_int(&m);
	buffer_free(&m);
	return(major);
}

int
mm_ssh_gssapi_userok(char *user)
{
	Buffer m;
	int authenticated = 0;

	buffer_init(&m);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSUSEROK, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSUSEROK,
				  &m);

	authenticated = buffer_get_int(&m);

	buffer_free(&m);
	debug3("%s: user %sauthenticated",__func__, authenticated ? "" : "not ");
	return (authenticated);
}
#endif /* GSSAPI */

@


1.91
log
@switch from Key typedef with struct sshkey; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.90 2017/05/17 01:24:17 djm Exp $ */
d421 2
a422 2
mm_key_verify(struct sshkey *key, u_char *sig, u_int siglen, u_char *data,
    u_int datalen)
d427 1
a427 1
	int verified = 0;
d446 1
a446 1
	verified = buffer_get_int(&m);
d450 3
a452 1
	return (verified);
@


1.90
log
@allow LogLevel in sshd_config Match blocks; ok dtucker bz#2717
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.89 2016/08/13 17:47:41 markus Exp $ */
d208 1
a208 1
mm_key_sign(Key *key, u_char **sigp, u_int *lenp,
d360 2
a361 1
mm_user_key_allowed(struct passwd *pw, Key *key, int pubkey_auth_attempt)
d369 1
a369 1
    Key *key)
d376 1
a376 1
    Key *key, int pubkey_auth_attempt)
d421 2
a422 1
mm_key_verify(Key *key, u_char *sig, u_int siglen, u_char *data, u_int datalen)
@


1.89
log
@remove ssh1 server code; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.88 2016/03/07 19:02:43 djm Exp $ */
d283 1
@


1.88
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.87 2016/01/14 16:17:40 markus Exp $ */
a76 1
extern int compat20;
a372 12
mm_auth_rhosts_rsa_key_allowed(struct passwd *pw, const char *user,
    const char *host, Key *key)
{
	int ret;

	key->type = KEY_RSA; /* XXX hack for key_to_blob */
	ret = mm_key_allowed(MM_RSAHOSTKEY, user, host, key, 0);
	key->type = KEY_RSA1;
	return (ret);
}

int
a549 22
#ifdef WITH_SSH1
int
mm_ssh1_session_key(BIGNUM *num)
{
	int rsafail;
	Buffer m;

	buffer_init(&m);
	buffer_put_bignum2(&m, num);
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SESSKEY, &m);

	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SESSKEY, &m);

	rsafail = buffer_get_int(&m);
	buffer_get_bignum2(&m, num);

	buffer_free(&m);

	return (rsafail);
}
#endif

a617 115


void
mm_ssh1_session_id(u_char session_id[16])
{
	Buffer m;
	int i;

	debug3("%s entering", __func__);

	buffer_init(&m);
	for (i = 0; i < 16; i++)
		buffer_put_char(&m, session_id[i]);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SESSID, &m);
	buffer_free(&m);
}

#ifdef WITH_SSH1
int
mm_auth_rsa_key_allowed(struct passwd *pw, BIGNUM *client_n, Key **rkey)
{
	Buffer m;
	Key *key;
	u_char *blob;
	u_int blen;
	int allowed = 0, have_forced = 0;

	debug3("%s entering", __func__);

	buffer_init(&m);
	buffer_put_bignum2(&m, client_n);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_RSAKEYALLOWED, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_RSAKEYALLOWED, &m);

	allowed = buffer_get_int(&m);

	/* fake forced command */
	auth_clear_options();
	have_forced = buffer_get_int(&m);
	forced_command = have_forced ? xstrdup("true") : NULL;

	if (allowed && rkey != NULL) {
		blob = buffer_get_string(&m, &blen);
		if ((key = key_from_blob(blob, blen)) == NULL)
			fatal("%s: key_from_blob failed", __func__);
		*rkey = key;
		free(blob);
	}
	buffer_free(&m);

	return (allowed);
}

BIGNUM *
mm_auth_rsa_generate_challenge(Key *key)
{
	Buffer m;
	BIGNUM *challenge;
	u_char *blob;
	u_int blen;

	debug3("%s entering", __func__);

	if ((challenge = BN_new()) == NULL)
		fatal("%s: BN_new failed", __func__);

	key->type = KEY_RSA;    /* XXX cheat for key_to_blob */
	if (key_to_blob(key, &blob, &blen) == 0)
		fatal("%s: key_to_blob failed", __func__);
	key->type = KEY_RSA1;

	buffer_init(&m);
	buffer_put_string(&m, blob, blen);
	free(blob);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_RSACHALLENGE, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_RSACHALLENGE, &m);

	buffer_get_bignum2(&m, challenge);
	buffer_free(&m);

	return (challenge);
}

int
mm_auth_rsa_verify_response(Key *key, BIGNUM *p, u_char response[16])
{
	Buffer m;
	u_char *blob;
	u_int blen;
	int success = 0;

	debug3("%s entering", __func__);

	key->type = KEY_RSA;    /* XXX cheat for key_to_blob */
	if (key_to_blob(key, &blob, &blen) == 0)
		fatal("%s: key_to_blob failed", __func__);
	key->type = KEY_RSA1;

	buffer_init(&m);
	buffer_put_string(&m, blob, blen);
	buffer_put_string(&m, response, 16);
	free(blob);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_RSARESPONSE, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_RSARESPONSE, &m);

	success = buffer_get_int(&m);
	buffer_free(&m);

	return (success);
}
#endif
@


1.87
log
@remove roaming support; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.86 2015/12/04 16:41:28 markus Exp $ */
d367 1
a367 1
mm_hostbased_key_allowed(struct passwd *pw, char *user, char *host,
d374 2
a375 2
mm_auth_rhosts_rsa_key_allowed(struct passwd *pw, char *user,
    char *host, Key *key)
d386 2
a387 2
mm_key_allowed(enum mm_keytype type, char *user, char *host, Key *key,
    int pubkey_auth_attempt)
@


1.86
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.85 2015/05/01 03:23:51 djm Exp $ */
a72 1
#include "roaming.h"
@


1.85
log
@prevent authorized_keys options picked up on public key tests without
a corresponding private key authentication being applied to other
authentication methods. Reported by halex@@, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.84 2015/02/16 22:13:32 djm Exp $ */
d211 1
a211 1
    const u_char *data, u_int datalen)
d221 1
@


1.84
log
@Revise hostkeys@@openssh.com hostkey learning extension.

The client will not ask the server to prove ownership of the private
halves of any hitherto-unseen hostkeys it offers to the client.

Allow UpdateHostKeys option to take an 'ask' argument to let the
user manually review keys offered.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.83 2015/01/19 20:16:15 markus Exp $ */
d360 1
a360 1
mm_user_key_allowed(struct passwd *pw, Key *key)
d362 2
a363 1
	return (mm_key_allowed(MM_USERKEY, NULL, NULL, key));
d370 1
a370 1
	return (mm_key_allowed(MM_HOSTKEY, user, host, key));
d380 1
a380 1
	ret = mm_key_allowed(MM_RSAHOSTKEY, user, host, key);
d386 2
a387 1
mm_key_allowed(enum mm_keytype type, char *user, char *host, Key *key)
d405 1
@


1.83
log
@adapt kex to sshbuf and struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.82 2015/01/19 19:52:16 markus Exp $ */
d210 2
a211 1
mm_key_sign(Key *key, u_char **sigp, u_int *lenp, u_char *data, u_int datalen)
d219 1
a219 1
	buffer_put_int(&m, kex->host_key_index(key, active_state));
@


1.82
log
@update packet.c & isolate, introduce struct ssh
a) switch packet.c to buffer api and isolate per-connection info into struct ssh
b) (de)serialization of the state is moved from monitor to packet.c
c) the old packet.c API is implemented in opacket.[ch]
d) compress.c/h is removed and integrated into packet.c
with and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.81 2015/01/13 19:31:40 markus Exp $ */
d212 1
a212 1
	Kex *kex = *pmonitor->m_pkex;
d218 1
a218 1
	buffer_put_int(&m, kex->host_key_index(key));
@


1.81
log
@adapt mac.c to ssherr.h return codes (de-fatal) and simplify dependencies
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.80 2014/04/29 18:01:49 markus Exp $ */
d75 2
a458 129
/* Export key state after authentication */
Newkeys *
mm_newkeys_from_blob(u_char *blob, int blen)
{
	Buffer b;
	u_int len;
	Newkeys *newkey = NULL;
	Enc *enc;
	Mac *mac;
	Comp *comp;

	debug3("%s: %p(%d)", __func__, blob, blen);
#ifdef DEBUG_PK
	dump_base64(stderr, blob, blen);
#endif
	buffer_init(&b);
	buffer_append(&b, blob, blen);

	newkey = xcalloc(1, sizeof(*newkey));
	enc = &newkey->enc;
	mac = &newkey->mac;
	comp = &newkey->comp;

	/* Enc structure */
	enc->name = buffer_get_string(&b, NULL);
	buffer_get(&b, &enc->cipher, sizeof(enc->cipher));
	enc->enabled = buffer_get_int(&b);
	enc->block_size = buffer_get_int(&b);
	enc->key = buffer_get_string(&b, &enc->key_len);
	enc->iv = buffer_get_string(&b, &enc->iv_len);

	if (enc->name == NULL || cipher_by_name(enc->name) != enc->cipher)
		fatal("%s: bad cipher name %s or pointer %p", __func__,
		    enc->name, enc->cipher);

	/* Mac structure */
	if (cipher_authlen(enc->cipher) == 0) {
		mac->name = buffer_get_string(&b, NULL);
		if (mac->name == NULL || mac_setup(mac, mac->name) != 0)
			fatal("%s: can not setup mac %s", __func__, mac->name);
		mac->enabled = buffer_get_int(&b);
		mac->key = buffer_get_string(&b, &len);
		if (len > mac->key_len)
			fatal("%s: bad mac key length: %u > %d", __func__, len,
			    mac->key_len);
		mac->key_len = len;
	}

	/* Comp structure */
	comp->type = buffer_get_int(&b);
	comp->enabled = buffer_get_int(&b);
	comp->name = buffer_get_string(&b, NULL);

	len = buffer_len(&b);
	if (len != 0)
		error("newkeys_from_blob: remaining bytes in blob %u", len);
	buffer_free(&b);
	return (newkey);
}

int
mm_newkeys_to_blob(int mode, u_char **blobp, u_int *lenp)
{
	Buffer b;
	int len;
	Enc *enc;
	Mac *mac;
	Comp *comp;
	Newkeys *newkey = (Newkeys *)packet_get_newkeys(mode);

	debug3("%s: converting %p", __func__, newkey);

	if (newkey == NULL) {
		error("%s: newkey == NULL", __func__);
		return 0;
	}
	enc = &newkey->enc;
	mac = &newkey->mac;
	comp = &newkey->comp;

	buffer_init(&b);
	/* Enc structure */
	buffer_put_cstring(&b, enc->name);
	/* The cipher struct is constant and shared, you export pointer */
	buffer_append(&b, &enc->cipher, sizeof(enc->cipher));
	buffer_put_int(&b, enc->enabled);
	buffer_put_int(&b, enc->block_size);
	buffer_put_string(&b, enc->key, enc->key_len);
	packet_get_keyiv(mode, enc->iv, enc->iv_len);
	buffer_put_string(&b, enc->iv, enc->iv_len);

	/* Mac structure */
	if (cipher_authlen(enc->cipher) == 0) {
		buffer_put_cstring(&b, mac->name);
		buffer_put_int(&b, mac->enabled);
		buffer_put_string(&b, mac->key, mac->key_len);
	}

	/* Comp structure */
	buffer_put_int(&b, comp->type);
	buffer_put_int(&b, comp->enabled);
	buffer_put_cstring(&b, comp->name);

	len = buffer_len(&b);
	if (lenp != NULL)
		*lenp = len;
	if (blobp != NULL) {
		*blobp = xmalloc(len);
		memcpy(*blobp, buffer_ptr(&b), len);
	}
	explicit_bzero(buffer_ptr(&b), len);
	buffer_free(&b);
	return len;
}

static void
mm_send_kex(Buffer *m, Kex *kex)
{
	buffer_put_string(m, kex->session_id, kex->session_id_len);
	buffer_put_int(m, kex->we_need);
	buffer_put_int(m, kex->hostkey_type);
	buffer_put_int(m, kex->kex_type);
	buffer_put_string(m, buffer_ptr(&kex->my), buffer_len(&kex->my));
	buffer_put_string(m, buffer_ptr(&kex->peer), buffer_len(&kex->peer));
	buffer_put_int(m, kex->flags);
	buffer_put_cstring(m, kex->client_version_string);
	buffer_put_cstring(m, kex->server_version_string);
}

d462 10
a471 98
	Buffer m, *input, *output;
	u_char *blob, *p;
	u_int bloblen, plen;
	u_int32_t seqnr, packets;
	u_int64_t blocks, bytes;

	buffer_init(&m);

	if (!compat20) {
		u_char iv[24];
		u_char *key;
		u_int ivlen, keylen;

		buffer_put_int(&m, packet_get_protocol_flags());

		buffer_put_int(&m, packet_get_ssh1_cipher());

		debug3("%s: Sending ssh1 KEY+IV", __func__);
		keylen = packet_get_encryption_key(NULL);
		key = xmalloc(keylen+1);	/* add 1 if keylen == 0 */
		keylen = packet_get_encryption_key(key);
		buffer_put_string(&m, key, keylen);
		explicit_bzero(key, keylen);
		free(key);

		ivlen = packet_get_keyiv_len(MODE_OUT);
		packet_get_keyiv(MODE_OUT, iv, ivlen);
		buffer_put_string(&m, iv, ivlen);
		ivlen = packet_get_keyiv_len(MODE_IN);
		packet_get_keyiv(MODE_IN, iv, ivlen);
		buffer_put_string(&m, iv, ivlen);
		goto skip;
	} else {
		/* Kex for rekeying */
		mm_send_kex(&m, *monitor->m_pkex);
	}

	debug3("%s: Sending new keys: %p %p",
	    __func__, packet_get_newkeys(MODE_OUT),
	    packet_get_newkeys(MODE_IN));

	/* Keys from Kex */
	if (!mm_newkeys_to_blob(MODE_OUT, &blob, &bloblen))
		fatal("%s: conversion of newkeys failed", __func__);

	buffer_put_string(&m, blob, bloblen);
	free(blob);

	if (!mm_newkeys_to_blob(MODE_IN, &blob, &bloblen))
		fatal("%s: conversion of newkeys failed", __func__);

	buffer_put_string(&m, blob, bloblen);
	free(blob);

	packet_get_state(MODE_OUT, &seqnr, &blocks, &packets, &bytes);
	buffer_put_int(&m, seqnr);
	buffer_put_int64(&m, blocks);
	buffer_put_int(&m, packets);
	buffer_put_int64(&m, bytes);
	packet_get_state(MODE_IN, &seqnr, &blocks, &packets, &bytes);
	buffer_put_int(&m, seqnr);
	buffer_put_int64(&m, blocks);
	buffer_put_int(&m, packets);
	buffer_put_int64(&m, bytes);

	debug3("%s: New keys have been sent", __func__);
 skip:
	/* More key context */
	plen = packet_get_keycontext(MODE_OUT, NULL);
	p = xmalloc(plen+1);
	packet_get_keycontext(MODE_OUT, p);
	buffer_put_string(&m, p, plen);
	free(p);

	plen = packet_get_keycontext(MODE_IN, NULL);
	p = xmalloc(plen+1);
	packet_get_keycontext(MODE_IN, p);
	buffer_put_string(&m, p, plen);
	free(p);

	/* Compression state */
	debug3("%s: Sending compression state", __func__);
	buffer_put_string(&m, &outgoing_stream, sizeof(outgoing_stream));
	buffer_put_string(&m, &incoming_stream, sizeof(incoming_stream));

	/* Network I/O buffers */
	input = (Buffer *)packet_get_input();
	output = (Buffer *)packet_get_output();
	buffer_put_string(&m, buffer_ptr(input), buffer_len(input));
	buffer_put_string(&m, buffer_ptr(output), buffer_len(output));

	/* Roaming */
	if (compat20) {
		buffer_put_int64(&m, get_sent_bytes());
		buffer_put_int64(&m, get_recv_bytes());
	}

	mm_request_send(monitor->m_recvfd, MONITOR_REQ_KEYEXPORT, &m);
d473 1
a473 2

	buffer_free(&m);
@


1.80
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.79 2014/02/02 03:44:31 djm Exp $ */
d495 1
a495 1
		if (mac->name == NULL || mac_setup(mac, mac->name) == -1)
@


1.79
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.78 2014/01/29 06:18:35 djm Exp $ */
d39 1
d42 1
a42 1
#include <openssl/evp.h>
d46 1
d48 1
d171 1
d205 1
d775 1
d795 1
d883 1
d979 1
@


1.78
log
@remove experimental, never-enabled JPAKE code; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.77 2013/11/06 16:52:11 markus Exp $ */
d562 1
a562 1
	memset(buffer_ptr(&b), 0, len);
d606 1
a606 1
		memset(key, 0, keylen);
@


1.77
log
@fix rekeying for AES-GCM modes; ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.76 2013/05/17 00:13:13 djm Exp $ */
a64 2
#include "schnorr.h"
#include "jpake.h"
a1057 161
#ifdef JPAKE
void
mm_auth2_jpake_get_pwdata(Authctxt *authctxt, BIGNUM **s,
    char **hash_scheme, char **salt)
{
	Buffer m;

	debug3("%s entering", __func__);

	buffer_init(&m);
	mm_request_send(pmonitor->m_recvfd,
	    MONITOR_REQ_JPAKE_GET_PWDATA, &m);

	debug3("%s: waiting for MONITOR_ANS_JPAKE_GET_PWDATA", __func__);
	mm_request_receive_expect(pmonitor->m_recvfd,
	    MONITOR_ANS_JPAKE_GET_PWDATA, &m);

	*hash_scheme = buffer_get_string(&m, NULL);
	*salt = buffer_get_string(&m, NULL);

	buffer_free(&m);
}

void
mm_jpake_step1(struct modp_group *grp,
    u_char **id, u_int *id_len,
    BIGNUM **priv1, BIGNUM **priv2, BIGNUM **g_priv1, BIGNUM **g_priv2,
    u_char **priv1_proof, u_int *priv1_proof_len,
    u_char **priv2_proof, u_int *priv2_proof_len)
{
	Buffer m;

	debug3("%s entering", __func__);

	buffer_init(&m);
	mm_request_send(pmonitor->m_recvfd,
	    MONITOR_REQ_JPAKE_STEP1, &m);

	debug3("%s: waiting for MONITOR_ANS_JPAKE_STEP1", __func__);
	mm_request_receive_expect(pmonitor->m_recvfd,
	    MONITOR_ANS_JPAKE_STEP1, &m);

	if ((*priv1 = BN_new()) == NULL ||
	    (*priv2 = BN_new()) == NULL ||
	    (*g_priv1 = BN_new()) == NULL ||
	    (*g_priv2 = BN_new()) == NULL)
		fatal("%s: BN_new", __func__);

	*id = buffer_get_string(&m, id_len);
	/* priv1 and priv2 are, well, private */
	buffer_get_bignum2(&m, *g_priv1);
	buffer_get_bignum2(&m, *g_priv2);
	*priv1_proof = buffer_get_string(&m, priv1_proof_len);
	*priv2_proof = buffer_get_string(&m, priv2_proof_len);

	buffer_free(&m);
}

void
mm_jpake_step2(struct modp_group *grp, BIGNUM *s,
    BIGNUM *mypub1, BIGNUM *theirpub1, BIGNUM *theirpub2, BIGNUM *mypriv2,
    const u_char *theirid, u_int theirid_len,
    const u_char *myid, u_int myid_len,
    const u_char *theirpub1_proof, u_int theirpub1_proof_len,
    const u_char *theirpub2_proof, u_int theirpub2_proof_len,
    BIGNUM **newpub,
    u_char **newpub_exponent_proof, u_int *newpub_exponent_proof_len)
{
	Buffer m;

	debug3("%s entering", __func__);

	buffer_init(&m);
	/* monitor already has all bignums except theirpub1, theirpub2 */
	buffer_put_bignum2(&m, theirpub1);
	buffer_put_bignum2(&m, theirpub2);
	/* monitor already knows our id */
	buffer_put_string(&m, theirid, theirid_len);
	buffer_put_string(&m, theirpub1_proof, theirpub1_proof_len);
	buffer_put_string(&m, theirpub2_proof, theirpub2_proof_len);

	mm_request_send(pmonitor->m_recvfd,
	    MONITOR_REQ_JPAKE_STEP2, &m);

	debug3("%s: waiting for MONITOR_ANS_JPAKE_STEP2", __func__);
	mm_request_receive_expect(pmonitor->m_recvfd,
	    MONITOR_ANS_JPAKE_STEP2, &m);

	if ((*newpub = BN_new()) == NULL)
		fatal("%s: BN_new", __func__);

	buffer_get_bignum2(&m, *newpub);
	*newpub_exponent_proof = buffer_get_string(&m,
	    newpub_exponent_proof_len);

	buffer_free(&m);
}

void
mm_jpake_key_confirm(struct modp_group *grp, BIGNUM *s, BIGNUM *step2_val,
    BIGNUM *mypriv2, BIGNUM *mypub1, BIGNUM *mypub2,
    BIGNUM *theirpub1, BIGNUM *theirpub2,
    const u_char *my_id, u_int my_id_len,
    const u_char *their_id, u_int their_id_len,
    const u_char *sess_id, u_int sess_id_len,
    const u_char *theirpriv2_s_proof, u_int theirpriv2_s_proof_len,
    BIGNUM **k,
    u_char **confirm_hash, u_int *confirm_hash_len)
{
	Buffer m;

	debug3("%s entering", __func__);

	buffer_init(&m);
	/* monitor already has all bignums except step2_val */
	buffer_put_bignum2(&m, step2_val);
	/* monitor already knows all the ids */
	buffer_put_string(&m, theirpriv2_s_proof, theirpriv2_s_proof_len);

	mm_request_send(pmonitor->m_recvfd,
	    MONITOR_REQ_JPAKE_KEY_CONFIRM, &m);

	debug3("%s: waiting for MONITOR_ANS_JPAKE_KEY_CONFIRM", __func__);
	mm_request_receive_expect(pmonitor->m_recvfd,
	    MONITOR_ANS_JPAKE_KEY_CONFIRM, &m);

	/* 'k' is sensitive and stays in the monitor */
	*confirm_hash = buffer_get_string(&m, confirm_hash_len);

	buffer_free(&m);
}

int
mm_jpake_check_confirm(const BIGNUM *k,
    const u_char *peer_id, u_int peer_id_len,
    const u_char *sess_id, u_int sess_id_len,
    const u_char *peer_confirm_hash, u_int peer_confirm_hash_len)
{
	Buffer m;
	int success = 0;

	debug3("%s entering", __func__);

	buffer_init(&m);
	/* k is dummy in slave, ignored */
	/* monitor knows all the ids */
	buffer_put_string(&m, peer_confirm_hash, peer_confirm_hash_len);
	mm_request_send(pmonitor->m_recvfd,
	    MONITOR_REQ_JPAKE_CHECK_CONFIRM, &m);

	debug3("%s: waiting for MONITOR_ANS_JPAKE_CHECK_CONFIRM", __func__);
	mm_request_receive_expect(pmonitor->m_recvfd,
	    MONITOR_ANS_JPAKE_CHECK_CONFIRM, &m);

	success = buffer_get_int(&m);
	buffer_free(&m);

	debug3("%s: success = %d", __func__, success);
	return success;
}
#endif /* JPAKE */
@


1.76
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.75 2013/01/08 18:49:04 markus Exp $ */
d472 1
a472 1
	newkey = xmalloc(sizeof(*newkey));
@


1.76.2.1
log
@cherrypick commit:

----------------------------
revision 1.77
date: 2013/11/06 16:52:11;  author: markus;  state: Exp;  lines: +2 -2;
fix rekeying for AES-GCM modes; ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.76 2013/05/17 00:13:13 djm Exp $ */
d472 1
a472 1
	newkey = xcalloc(1, sizeof(*newkey));
@


1.75
log
@support AES-GCM as defined in RFC 5647 (but with simpler KEX handling)
ok and feedback djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.74 2012/10/01 13:59:51 naddy Exp $ */
d278 1
a278 1
	xfree(newopts);
d304 1
a304 1
		xfree(banner);
d397 1
a397 1
	xfree(blob);
d440 1
a440 1
	xfree(blob);
d609 1
a609 1
		xfree(key);
d632 1
a632 1
	xfree(blob);
d638 1
a638 1
	xfree(blob);
d658 1
a658 1
	xfree(p);
d664 1
a664 1
	xfree(p);
d726 1
a726 1
	xfree(p);
d729 1
a729 1
	xfree(msg);
d907 1
a907 1
		xfree(blob);
d934 1
a934 1
	xfree(blob);
d963 1
a963 1
	xfree(blob);
@


1.75.2.1
log
@openssh-6.4 for the 5.3 branch; reminded by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.76.2.1 2013/11/08 00:25:26 djm Exp $ */
d472 1
a472 1
	newkey = xcalloc(1, sizeof(*newkey));
@


1.74
log
@pasto; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.73 2011/06/17 21:44:31 djm Exp $ */
d483 1
a483 4
	enc->iv = buffer_get_string(&b, &len);
	if (len != enc->block_size)
		fatal("%s: bad ivlen: expected %u != %u", __func__,
		    enc->block_size, len);
d490 11
a500 9
	mac->name = buffer_get_string(&b, NULL);
	if (mac->name == NULL || mac_setup(mac, mac->name) == -1)
		fatal("%s: can not setup mac %s", __func__, mac->name);
	mac->enabled = buffer_get_int(&b);
	mac->key = buffer_get_string(&b, &len);
	if (len > mac->key_len)
		fatal("%s: bad mac key length: %u > %d", __func__, len,
		    mac->key_len);
	mac->key_len = len;
d542 2
a543 2
	packet_get_keyiv(mode, enc->iv, enc->block_size);
	buffer_put_string(&b, enc->iv, enc->block_size);
d546 5
a550 3
	buffer_put_cstring(&b, mac->name);
	buffer_put_int(&b, mac->enabled);
	buffer_put_string(&b, mac->key, mac->key_len);
@


1.73
log
@make the pre-auth privsep slave log via a socketpair shared with the
monitor rather than /var/empty/dev/log; ok dtucker@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.72 2011/05/23 03:30:07 djm Exp $ */
d613 1
a613 1
		ivlen = packet_get_keyiv_len(MODE_OUT);
@


1.72
log
@allow AuthorizedKeysFile to specify multiple files, separated by spaces.
Bring back authorized_keys2 as a default search path (to avoid breaking
existing users of this file), but override this in sshd_config so it will
be no longer used on fresh installs. Maybe in 2015 we can remove it
entierly :)

feedback and ok markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.71 2011/05/20 03:25:45 djm Exp $ */
d81 26
@


1.71
log
@use a macro to define which string options to copy between configs
for Match. This avoids problems caused by forgetting to keep three
code locations in perfect sync and ordering

"this is at once beautiful and horrible" + ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.70 2010/08/31 11:54:45 djm Exp $ */
d205 1
a205 1
	u_int len;
d242 4
d249 1
@


1.70
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.69 2010/03/07 11:57:13 dtucker Exp $ */
d237 9
a245 2
	if (newopts->banner != NULL)
		newopts->banner = buffer_get_string(&m, NULL);
@


1.69
log
@Hold authentication debug messages until after successful authentication.
Fixes an info leak of environment variables specified in authorized_keys,
reported by Jacob Appelbaum.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.68 2009/06/22 05:39:28 dtucker Exp $ */
d67 1
@


1.68
log
@alphabetize includes; reduces diff vs portable and style(9).  ok stevesk djm
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.67 2009/05/28 16:50:16 andreas Exp $ */
a338 13
static void
mm_send_debug(Buffer *m)
{
	char *msg;

	while (buffer_len(m)) {
		msg = buffer_get_string(m, NULL);
		debug3("%s: Sending debug: %s", __func__, msg);
		packet_send_debug("%s", msg);
		xfree(msg);
	}
}

a371 3
	/* Send potential debug messages */
	mm_send_debug(&m);

a868 1
	mm_send_debug(&m);
@


1.67
log
@Keep track of number of bytes read and written. Needed for upcoming
changes. Most code from Martin Forssen, maf at appgate dot com.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.66 2009/05/25 06:48:01 andreas Exp $ */
a31 4
#include <openssl/bn.h>
#include <openssl/dh.h>
#include <openssl/evp.h>

d38 4
@


1.66
log
@Put the globals in packet.c into a struct and don't access it directly
from other files. No functional changes.
ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.65 2009/03/05 07:18:19 djm Exp $ */
d71 1
d652 6
@


1.65
log
@refactor the (disabled) Schnorr proof code to make it a little more
generally useful
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.64 2008/11/04 08:22:13 djm Exp $ */
a73 1
extern Newkeys *newkeys[];
a76 1
extern Buffer input, output;
d499 1
a499 1
	Newkeys *newkey = newkeys[mode];
d561 1
a561 1
	Buffer m;
d599 2
a600 1
	    __func__, newkeys[MODE_OUT], newkeys[MODE_IN]);
d647 4
a650 2
	buffer_put_string(&m, buffer_ptr(&input), buffer_len(&input));
	buffer_put_string(&m, buffer_ptr(&output), buffer_len(&output));
@


1.64
log
@Add support for an experimental zero-knowledge password authentication
method using the J-PAKE protocol described in F. Hao, P. Ryan,
"Password Authenticated Key Exchange by Juggling", 16th Workshop on
Security Protocols, Cambridge, April 2008.

This method allows password-based authentication without exposing
the password to the server. Instead, the client and server exchange
cryptographic proofs to demonstrate of knowledge of the password while
revealing nothing useful to an attacker or compromised endpoint.

This is experimental, work-in-progress code and is presently
compiled-time disabled (turn on -DJPAKE in Makefile.inc).

"just commit it.  It isn't too intrusive." deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.63 2008/07/10 18:08:11 markus Exp $ */
d65 1
d1053 1
a1053 1
mm_jpake_step1(struct jpake_group *grp,
d1088 1
a1088 1
mm_jpake_step2(struct jpake_group *grp, BIGNUM *s,
d1128 1
a1128 1
mm_jpake_key_confirm(struct jpake_group *grp, BIGNUM *s, BIGNUM *step2_val,
@


1.63
log
@sync v1 and v2 traffic accounting; add it to sshd, too; ok djm@@, dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.62 2008/05/08 12:21:16 djm Exp $ */
d34 1
d65 1
d1027 162
@


1.62
log
@Make the maximum number of sessions run-time controllable via
a sshd_config MaxSessions knob. This is useful for disabling
login/shell/subsystem access while leaving port-forwarding working
(MaxSessions 0), disabling connection multiplexing (MaxSessions 1) or
simply increasing the number of allows multiplexed sessions.

Because some bozos are sure to configure MaxSessions in excess of the
number of available file descriptors in sshd (which, at peak, might be
as many as 9*MaxSessions), audit sshd to ensure that it doesn't leak fds
on error paths, and make it fail gracefully on out-of-fd conditions -
sending channel errors instead of than exiting with fatal().

bz#1090; MaxSessions config bits and manpage from junyer AT gmail.com

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.61 2008/05/08 12:02:23 djm Exp $ */
d564 1
a564 1
	u_int64_t blocks;
d613 1
a613 1
	packet_get_state(MODE_OUT, &seqnr, &blocks, &packets);
d617 2
a618 1
	packet_get_state(MODE_IN, &seqnr, &blocks, &packets);
d622 1
@


1.61
log
@Implement a channel success/failure status confirmation callback
mechanism. Each channel maintains a queue of callbacks, which will
be drained in order (RFC4253 guarantees confirm messages are not
reordered within an channel).

Also includes a abandonment callback to clean up if a channel is
closed without sending confirmation messages. This probably
shouldn't happen in compliant implementations, but it could be
abused to leak memory.

ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.60 2007/10/29 04:08:08 dtucker Exp $ */
d657 14
a670 1
	int success = 0;
d715 3
a717 2
	if (close(s->ptymaster) < 0)
		error("close(s->ptymaster): %s", strerror(errno));
@


1.60
log
@Send config block back to slave for invalid users too so options
set by a Match block (eg Banner) behave the same for non-existent
users.  Found by and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.59 2007/09/21 08:15:29 djm Exp $ */
d30 1
@


1.59
log
@unifdef -DBSD_AUTH
unifdef -USKEY

These options have been in use for some years;
ok markus@@ "no objection" millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.58 2007/09/04 03:21:03 djm Exp $ */
d215 2
a216 2
		buffer_free(&m);
		return (NULL);
d228 1
@


1.58
log
@make file descriptor passing code return an error rather than call fatal()
when it encounters problems, and use this to make session multiplexing
masters survive slaves failing to pass all stdio FDs; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.57 2007/06/07 19:37:34 pvalchev Exp $ */
a807 60
#ifdef SKEY
int
mm_skey_query(void *ctx, char **name, char **infotxt,
   u_int *numprompts, char ***prompts, u_int **echo_on)
{
	Buffer m;
	u_int success;
	char *challenge;

	debug3("%s: entering", __func__);

	buffer_init(&m);
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SKEYQUERY, &m);

	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SKEYQUERY,
	    &m);
	success = buffer_get_int(&m);
	if (success == 0) {
		debug3("%s: no challenge", __func__);
		buffer_free(&m);
		return (-1);
	}

	/* Get the challenge, and format the response */
	challenge  = buffer_get_string(&m, NULL);
	buffer_free(&m);

	debug3("%s: received challenge: %s", __func__, challenge);

	mm_chall_setup(name, infotxt, numprompts, prompts, echo_on);

	xasprintf(*prompts, "%s%s", challenge, SKEY_PROMPT);
	xfree(challenge);

	return (0);
}

int
mm_skey_respond(void *ctx, u_int numresponses, char **responses)
{
	Buffer m;
	int authok;

	debug3("%s: entering", __func__);
	if (numresponses != 1)
		return (-1);

	buffer_init(&m);
	buffer_put_cstring(&m, responses[0]);
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SKEYRESPOND, &m);

	mm_request_receive_expect(pmonitor->m_recvfd,
	    MONITOR_ANS_SKEYRESPOND, &m);

	authok = buffer_get_int(&m);
	buffer_free(&m);

	return ((authok == 0) ? -1 : 0);
}
#endif /* SKEY */
@


1.57
log
@Add a new MAC algorithm for data integrity, UMAC-64 (not default yet, must
specify umac-64@@openssh.com). Provides about 20% end-to-end speedup
compared to hmac-md5. Represents a different approach to message
authentication to that of HMAC that may be beneficial if HMAC based on one
of its underlying hash algorithms is found to be vulnerable to a new attack.
http://www.ietf.org/rfc/rfc4418.txt

in conjunction with and OK djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.56 2007/06/05 06:52:37 djm Exp $ */
d679 3
a681 2
	*ptyfd = mm_receive_fd(pmonitor->m_recvfd);
	*ttyfd = mm_receive_fd(pmonitor->m_recvfd);
@


1.56
log
@Preserve MAC ctx between packets, saving 2xhash calls per-packet.
Yields around a 12-16% end-to-end speedup for arcfour256/hmac-md5

patch from markus@@ tested dtucker@@ and myself, ok markus@@ and me (I'm
committing at his request)
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.55 2007/02/19 10:45:58 dtucker Exp $ */
d468 1
a468 1
		fatal("%s: can not init mac %s", __func__, mac->name);
@


1.55
log
@Teach Match how handle config directives that are used before authentication.
This allows configurations such as permitting password authentication from
the local net only while requiring pubkey from offsite.  ok djm@@, man page
bits ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.54 2006/08/12 20:46:46 miod Exp $ */
d467 1
a467 1
	if (mac->name == NULL || mac_init(mac, mac->name) == -1)
@


1.54
log
@Revert previous include file ordering change, for ssh to compile under gcc2
(or until openssl include files are cleaned of parameter names in function
prototypes)
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.53 2006/08/06 01:13:32 stevesk Exp $ */
d66 1
d76 1
d201 2
a202 1
	u_int pwlen;
d218 2
a219 2
	pw = buffer_get_string(&m, &pwlen);
	if (pwlen != sizeof(struct passwd))
d227 10
@


1.53
log
@"zlib.h" can be <zlib.h>; ok djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.52 2006/08/05 08:28:24 dtucker Exp $ */
a39 1
#include <zlib.h>
d54 1
@


1.52
log
@Zap unused variables in -DSKEY code.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.51 2006/08/05 07:52:52 dtucker Exp $ */
d40 1
a54 1
#include "zlib.h"
@


1.51
log
@Add headers required to build with KERBEROS5=no.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.50 2006/08/03 03:34:42 deraadt Exp $ */
a799 1
	int len;
d801 1
a801 1
	char *p, *challenge;
@


1.50
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.49 2006/08/01 23:22:47 stevesk Exp $ */
d29 1
d39 1
@


1.49
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.48 2006/07/22 20:48:23 stevesk Exp $ */
a27 2
#include "includes.h"

d35 1
d39 1
d42 3
d46 1
a48 2
#include "buffer.h"
#include "bufaux.h"
d54 3
a57 1
#include "xmalloc.h"
a61 1
#include "auth.h"
a63 4

#ifdef GSSAPI
#include "ssh-gss.h"
#endif
@


1.48
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.47 2006/07/11 20:07:25 stevesk Exp $ */
d37 1
@


1.47
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.46 2006/07/06 16:03:53 stevesk Exp $ */
d37 1
@


1.46
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.45 2006/03/30 09:58:15 djm Exp $ */
d35 1
@


1.45
log
@replace {GET,PUT}_XXBIT macros with functionally similar functions,
silencing a heap of lint warnings. also allows them to use
__bounded__ checking which can't be applied to macros; requested
by and feedback from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_wrap.c,v 1.44 2006/03/25 13:17:02 djm Exp $ */
d30 2
d34 2
@


1.44
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d49 1
a49 1
#include "getput.h"
d86 1
a86 1
	PUT_32BIT(buf, mlen + 1);
d107 1
a107 1
	msg_len = GET_32BIT(buf);
@


1.43
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.42
log
@sprinkle u_int throughout pty subsystem, ok markus
@
text
@d723 2
a724 2
	*prompts = xmalloc(*numprompts * sizeof(char *));
	*echo_on = xmalloc(*numprompts * sizeof(u_int));
d817 1
a817 5
	len = strlen(challenge) + strlen(SKEY_PROMPT) + 1;
	p = xmalloc(len);
	strlcpy(p, challenge, len);
	strlcat(p, SKEY_PROMPT, len);
	(*prompts)[0] = p;
@


1.41
log
@RCSID() can die
@
text
@d629 1
a629 1
mm_pty_allocate(int *ptyfd, int *ttyfd, char *namebuf, int namebuflen)
@


1.40
log
@Switch atomicio to use a simpler interface; it now returns a size_t
(containing number of bytes read/written), and indicates error by
returning 0.  EOF is signalled by errno==EPIPE.
Typical use now becomes:

if (atomicio(read, ..., len) != len)
        err(1,"read");

ok deraadt@@, cloder@@, djm@@
@
text
@a27 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.39 2004/07/17 05:31:41 dtucker Exp $");
@


1.40.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: monitor_wrap.c,v 1.54 2006/08/12 20:46:46 miod Exp $ */
d27 2
a28 2
#include <sys/types.h>
#include <sys/uio.h>
a32 8
#include <errno.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
a34 3
#include "buffer.h"
#include "key.h"
#include "cipher.h"
a35 1
#include "hostfile.h"
d38 2
d43 1
a43 1
#include <zlib.h>
a44 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
d46 1
d49 1
a49 1
#include "misc.h"
d51 1
d55 4
d86 1
a86 1
	put_u32(buf, mlen + 1);
d107 1
a107 1
	msg_len = get_u32(buf);
d630 1
a630 1
mm_pty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)
d724 2
a725 2
	*prompts = xcalloc(*numprompts, sizeof(char *));
	*echo_on = xcalloc(*numprompts, sizeof(u_int));
d792 1
d794 1
a794 1
	char *challenge;
d818 5
a822 1
	xasprintf(*prompts, "%s%s", challenge, SKEY_PROMPT);
@


1.40.4.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: monitor_wrap.c,v 1.54 2006/08/12 20:46:46 miod Exp $ */
d27 2
a28 2
#include <sys/types.h>
#include <sys/uio.h>
a32 8
#include <errno.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
a34 3
#include "buffer.h"
#include "key.h"
#include "cipher.h"
a35 1
#include "hostfile.h"
d38 2
d43 1
a43 1
#include <zlib.h>
a44 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
d46 1
d49 1
a49 1
#include "misc.h"
d51 1
d55 4
d86 1
a86 1
	put_u32(buf, mlen + 1);
d107 1
a107 1
	msg_len = get_u32(buf);
d630 1
a630 1
mm_pty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)
d724 2
a725 2
	*prompts = xcalloc(*numprompts, sizeof(char *));
	*echo_on = xcalloc(*numprompts, sizeof(u_int));
d792 1
d794 1
a794 1
	char *challenge;
d818 5
a822 1
	xasprintf(*prompts, "%s%s", challenge, SKEY_PROMPT);
@


1.39
log
@Move "Last logged in at.." message generation to the monitor, right
before recording the new login.  Fixes missing lastlog message when
/var/log/lastlog is not world-readable and incorrect datestamp when
multiple sessions are used (bz #463);  much assistance & ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.38 2004/07/03 11:02:25 dtucker Exp $");
d89 1
a89 1
		fatal("%s: write", __func__);
d91 1
a91 1
		fatal("%s: write", __func__);
a98 1
	ssize_t res;
d102 2
a103 3
	res = atomicio(read, sock, buf, sizeof(buf));
	if (res != sizeof(buf)) {
		if (res == 0)
d105 1
a105 1
		fatal("%s: read: %ld", __func__, (long)res);
d112 2
a113 3
	res = atomicio(read, sock, buffer_ptr(m), msg_len);
	if (res != msg_len)
		fatal("%s: read: %ld != msg_len", __func__, (long)res);
@


1.39.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.40 2005/05/24 17:32:43 avsm Exp $");
d89 1
a89 1
		fatal("%s: write: %s", __func__, strerror(errno));
d91 1
a91 1
		fatal("%s: write: %s", __func__, strerror(errno));
d99 1
d103 3
a105 2
	if (atomicio(read, sock, buf, sizeof(buf)) != sizeof(buf)) {
		if (errno == EPIPE)
d107 1
a107 1
		fatal("%s: read: %s", __func__, strerror(errno));
d114 3
a116 2
	if (atomicio(read, sock, buffer_ptr(m), msg_len) != msg_len)
		fatal("%s: read: %s", __func__, strerror(errno));
@


1.39.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.40 2005/05/24 17:32:43 avsm Exp $");
d89 1
a89 1
		fatal("%s: write: %s", __func__, strerror(errno));
d91 1
a91 1
		fatal("%s: write: %s", __func__, strerror(errno));
d99 1
d103 3
a105 2
	if (atomicio(read, sock, buf, sizeof(buf)) != sizeof(buf)) {
		if (errno == EPIPE)
d107 1
a107 1
		fatal("%s: read: %s", __func__, strerror(errno));
d114 3
a116 2
	if (atomicio(read, sock, buffer_ptr(m), msg_len) != msg_len)
		fatal("%s: read: %s", __func__, strerror(errno));
@


1.38
log
@Put s/key functions inside #ifdef SKEY same as monitor.c,
from des@@freebsd via bz #330, ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.37 2004/06/22 05:05:45 dtucker Exp $");
d66 1
d636 1
a636 1
	char *p;
d652 1
d657 3
@


1.37
log
@Change login->username, will prevent -Wshadow errors in Portable; ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.36 2004/06/21 17:36:31 avsm Exp $");
d784 1
d848 1
@


1.36
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.35 2003/11/17 11:06:07 markus Exp $");
d189 1
a189 1
mm_getpwnamallow(const char *login)
d198 1
a198 1
	buffer_put_cstring(&m, login);
@


1.35
log
@replace "gssapi" with "gssapi-with-mic"; from Simon Wilkinson; test + ok jakob.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.34 2003/10/15 09:48:45 markus Exp $");
d78 1
a78 1
mm_request_send(int socket, enum monitor_reqtype type, Buffer *m)
d87 1
a87 1
	if (atomicio(vwrite, socket, buf, sizeof(buf)) != sizeof(buf))
d89 1
a89 1
	if (atomicio(vwrite, socket, buffer_ptr(m), mlen) != mlen)
d94 1
a94 1
mm_request_receive(int socket, Buffer *m)
d102 1
a102 1
	res = atomicio(read, socket, buf, sizeof(buf));
d113 1
a113 1
	res = atomicio(read, socket, buffer_ptr(m), msg_len);
d119 1
a119 1
mm_request_receive_expect(int socket, enum monitor_reqtype type, Buffer *m)
d125 1
a125 1
	mm_request_receive(socket, m);
d537 1
a537 1
mm_send_keystate(struct monitor *pmonitor)
d573 1
a573 1
		mm_send_kex(&m, *pmonitor->m_pkex);
d625 1
a625 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_KEYEXPORT, &m);
d963 1
a963 1
mm_ssh_gssapi_server_ctx(Gssctxt **ctx, gss_OID oid)
d972 1
a972 1
	buffer_put_string(&m, oid->elements, oid->length);
@


1.35.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.39 2004/07/17 05:31:41 dtucker Exp $");
a65 1
extern Buffer loginmsg;
d78 1
a78 1
mm_request_send(int sock, enum monitor_reqtype type, Buffer *m)
d87 1
a87 1
	if (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))
d89 1
a89 1
	if (atomicio(vwrite, sock, buffer_ptr(m), mlen) != mlen)
d94 1
a94 1
mm_request_receive(int sock, Buffer *m)
d102 1
a102 1
	res = atomicio(read, sock, buf, sizeof(buf));
d113 1
a113 1
	res = atomicio(read, sock, buffer_ptr(m), msg_len);
d119 1
a119 1
mm_request_receive_expect(int sock, enum monitor_reqtype type, Buffer *m)
d125 1
a125 1
	mm_request_receive(sock, m);
d189 1
a189 1
mm_getpwnamallow(const char *username)
d198 1
a198 1
	buffer_put_cstring(&m, username);
d537 1
a537 1
mm_send_keystate(struct monitor *monitor)
d573 1
a573 1
		mm_send_kex(&m, *monitor->m_pkex);
d625 1
a625 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_KEYEXPORT, &m);
d635 1
a635 1
	char *p, *msg;
a650 1
	msg = buffer_get_string(&m, NULL);
a655 3
	buffer_append(&loginmsg, msg, strlen(msg));
	xfree(msg);

a783 1
#ifdef SKEY
a846 1
#endif /* SKEY */
d963 1
a963 1
mm_ssh_gssapi_server_ctx(Gssctxt **ctx, gss_OID goid)
d972 1
a972 1
	buffer_put_string(&m, goid->elements, goid->length);
@


1.34
log
@check pmonitor != NULL
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.33 2003/10/11 11:36:23 markus Exp $");
d1006 19
@


1.33
log
@return NULL for missing banner; ok djm@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.32 2003/09/23 20:17:11 markus Exp $");
d74 1
a74 1
	return (pmonitor->m_pid > 0);
@


1.32
log
@replace fatal_cleanup() and linked list of fatal callbacks with static
cleanup_exit() function.  re-refine cleanup_exit() where appropriate,
allocate sshd's authctxt eary to allow simpler cleanup in sshd.
tested by many, ok deraadt@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.31 2003/08/28 12:54:34 markus Exp $");
d223 2
a224 1
char *mm_auth2_read_banner(void)
d235 2
a236 1
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_AUTH2_READ_BANNER, &m);
d240 5
@


1.31
log
@remove kerberos support from ssh1, since it has been replaced with GSSAPI;
but keep kerberos passwd auth for ssh1 and 2; ok djm, hin, henning, ...
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.30 2003/08/24 17:36:52 deraadt Exp $");
d67 10
d105 1
a105 1
			fatal_cleanup();
d657 1
a657 1
mm_session_pty_cleanup2(void *session)
a658 1
	Session *s = session;
@


1.31.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.35 2003/11/17 11:06:07 markus Exp $");
a66 10
int
mm_is_monitor(void)
{
	/*
	 * m_pid is only set in the privileged part, and
	 * points to the unprivileged child.
	 */
	return (pmonitor && pmonitor->m_pid > 0);
}

d95 1
a95 1
			cleanup_exit(255);
d213 1
a213 2
char *
mm_auth2_read_banner(void)
d224 1
a224 2
	mm_request_receive_expect(pmonitor->m_recvfd,
	    MONITOR_ANS_AUTH2_READ_BANNER, &m);
a227 5
	/* treat empty banner as missing banner */
	if (strlen(banner) == 0) {
		xfree(banner);
		banner = NULL;
	}
d647 1
a647 1
mm_session_pty_cleanup2(Session *s)
d649 1
a989 19
}

OM_uint32
mm_ssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)
{
	Buffer m;
	OM_uint32 major;

	buffer_init(&m);
	buffer_put_string(&m, gssbuf->value, gssbuf->length);
	buffer_put_string(&m, gssmic->value, gssmic->length);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSCHECKMIC, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSCHECKMIC,
	    &m);

	major = buffer_get_int(&m);
	buffer_free(&m);
	return(major);
@


1.31.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.39 2004/07/17 05:31:41 dtucker Exp $");
a65 1
extern Buffer loginmsg;
d78 1
a78 1
mm_request_send(int sock, enum monitor_reqtype type, Buffer *m)
d87 1
a87 1
	if (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))
d89 1
a89 1
	if (atomicio(vwrite, sock, buffer_ptr(m), mlen) != mlen)
d94 1
a94 1
mm_request_receive(int sock, Buffer *m)
d102 1
a102 1
	res = atomicio(read, sock, buf, sizeof(buf));
d113 1
a113 1
	res = atomicio(read, sock, buffer_ptr(m), msg_len);
d119 1
a119 1
mm_request_receive_expect(int sock, enum monitor_reqtype type, Buffer *m)
d125 1
a125 1
	mm_request_receive(sock, m);
d189 1
a189 1
mm_getpwnamallow(const char *username)
d198 1
a198 1
	buffer_put_cstring(&m, username);
d537 1
a537 1
mm_send_keystate(struct monitor *monitor)
d573 1
a573 1
		mm_send_kex(&m, *monitor->m_pkex);
d625 1
a625 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_KEYEXPORT, &m);
d635 1
a635 1
	char *p, *msg;
a650 1
	msg = buffer_get_string(&m, NULL);
a655 3
	buffer_append(&loginmsg, msg, strlen(msg));
	xfree(msg);

a783 1
#ifdef SKEY
a846 1
#endif /* SKEY */
d963 1
a963 1
mm_ssh_gssapi_server_ctx(Gssctxt **ctx, gss_OID goid)
d972 1
a972 1
	buffer_put_string(&m, goid->elements, goid->length);
@


1.30
log
@64 bit cleanups; markus ok
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.29 2003/08/22 10:56:09 markus Exp $");
a943 35

#ifdef KRB5
int
mm_auth_krb5(void *ctx, void *argp, char **userp, void *resp)
{
	krb5_data *tkt, *reply;
	Buffer m;
	int success;

	debug3("%s entering", __func__);
	tkt = (krb5_data *) argp;
	reply = (krb5_data *) resp;

	buffer_init(&m);
	buffer_put_string(&m, tkt->data, tkt->length);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_KRB5, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_KRB5, &m);

	success = buffer_get_int(&m);
	if (success) {
		u_int len;

		*userp = buffer_get_string(&m, NULL);
		reply->data = buffer_get_string(&m, &len);
		reply->length = len;
	} else {
		memset(reply, 0, sizeof(*reply));
		*userp = NULL;
	}

	buffer_free(&m);
	return (success);
}
#endif /* KRB5 */
@


1.29
log
@support GSS API user authentication; patches from Simon Wilkinson,
stripped down and tested by Jakob and myself.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.28 2003/07/22 13:35:22 markus Exp $");
d1008 1
d1017 2
a1018 1
	out->value = buffer_get_string(&m, &out->length);
@


1.28
log
@remove (already disabled) KRB4/AFS support, re-enable -k in ssh(1);
test+ok henning@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.27 2003/06/28 16:23:06 deraadt Exp $");
d55 4
d978 66
a1043 1
#endif
@


1.27
log
@deal with typing of write vs read in atomicio
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.26 2003/04/07 08:29:57 markus Exp $");
a939 36

#ifdef KRB4
int
mm_auth_krb4(Authctxt *authctxt, void *_auth, char **client, void *_reply)
{
	KTEXT auth, reply;
 	Buffer m;
	u_int rlen;
	int success = 0;
	char *p;

	debug3("%s entering", __func__);
	auth = _auth;
	reply = _reply;

	buffer_init(&m);
	buffer_put_string(&m, auth->dat, auth->length);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_KRB4, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_KRB4, &m);

	success = buffer_get_int(&m);
	if (success) {
		*client = buffer_get_string(&m, NULL);
		p = buffer_get_string(&m, &rlen);
		if (rlen >= MAX_KTXT_LEN)
			fatal("%s: reply from monitor too large", __func__);
		reply->length = rlen;
		memcpy(reply->dat, p, rlen);
		memset(p, 0, rlen);
		xfree(p);
	}
	buffer_free(&m);
	return (success);
}
#endif
@


1.26
log
@typo: get correct counters; introduced during rekeying change.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.25 2003/04/02 09:48:07 markus Exp $");
d73 1
a73 1
	if (atomicio(write, socket, buf, sizeof(buf)) != sizeof(buf))
d75 1
a75 1
	if (atomicio(write, socket, buffer_ptr(m), mlen) != mlen)
@


1.25
log
@reapply rekeying chage, tested by henning@@, ok djm@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.24 2003/04/01 10:22:21 markus Exp $");
d575 1
a575 1
	packet_get_state(MODE_OUT, &seqnr, &blocks, &packets);
@


1.24
log
@backout rekeying changes (for 3.6.1)
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.23 2003/04/01 10:10:23 markus Exp $");
d521 2
d571 8
a578 2
	buffer_put_int(&m, packet_get_seqnr(MODE_OUT));
	buffer_put_int(&m, packet_get_seqnr(MODE_IN));
@


1.23
log
@rekeying bugfixes and automatic rekeying:

* both client and server rekey _automatically_
      (a) after 2^31 packets, because after 2^32 packets
          the sequence number for packets wraps
      (b) after 2^(blocksize_in_bits/4) blocks
  (see: http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-00.txt)
  (a) and (b) are _enabled_ by default, and only disabled for known
  openssh versions, that don't support rekeying properly.
* client option 'RekeyLimit'
* do not reply to requests during rekeying
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.22 2003/02/16 17:30:33 markus Exp $");
a520 2
	u_int32_t seqnr, packets;
	u_int64_t blocks;
d569 2
a570 8
	packet_get_state(MODE_OUT, &seqnr, &blocks, &packets);
	buffer_put_int(&m, seqnr);
	buffer_put_int64(&m, blocks);
	buffer_put_int(&m, packets);
	packet_get_state(MODE_OUT, &seqnr, &blocks, &packets);
	buffer_put_int(&m, seqnr);
	buffer_put_int64(&m, blocks);
	buffer_put_int(&m, packets);
@


1.22
log
@fix permitrootlogin forced-commands-only for privsep; bux #387; ok provos@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.21 2003/02/04 09:33:22 markus Exp $");
d521 2
d571 8
a578 2
	buffer_put_int(&m, packet_get_seqnr(MODE_OUT));
	buffer_put_int(&m, packet_get_seqnr(MODE_IN));
@


1.22.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.31 2003/08/28 12:54:34 markus Exp $");
a54 4
#ifdef GSSAPI
#include "ssh-gss.h"
#endif

d73 1
a73 1
	if (atomicio(vwrite, socket, buf, sizeof(buf)) != sizeof(buf))
d75 1
a75 1
	if (atomicio(vwrite, socket, buffer_ptr(m), mlen) != mlen)
a520 2
	u_int32_t seqnr, packets;
	u_int64_t blocks;
d569 2
a570 8
	packet_get_state(MODE_OUT, &seqnr, &blocks, &packets);
	buffer_put_int(&m, seqnr);
	buffer_put_int64(&m, blocks);
	buffer_put_int(&m, packets);
	packet_get_state(MODE_IN, &seqnr, &blocks, &packets);
	buffer_put_int(&m, seqnr);
	buffer_put_int64(&m, blocks);
	buffer_put_int(&m, packets);
d933 3
a935 3
#ifdef GSSAPI
OM_uint32
mm_ssh_gssapi_server_ctx(Gssctxt **ctx, gss_OID oid)
d937 5
a941 2
	Buffer m;
	OM_uint32 major;
d943 3
a945 2
	/* Client doesn't get to see the context */
	*ctx = NULL;
d948 1
a948 1
	buffer_put_string(&m, oid->elements, oid->length);
d950 2
a951 4
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSSETUP, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSSETUP, &m);

	major = buffer_get_int(&m);
d953 11
d965 1
a965 1
	return (major);
d967 1
d969 3
a971 3
OM_uint32
mm_ssh_gssapi_accept_ctx(Gssctxt *ctx, gss_buffer_desc *in,
    gss_buffer_desc *out, OM_uint32 *flags)
d973 1
d975 5
a979 2
	OM_uint32 major;
	u_int len;
d982 1
a982 1
	buffer_put_string(&m, in->value, in->length);
d984 2
a985 2
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSSTEP, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSSTEP, &m);
d987 3
a989 5
	major = buffer_get_int(&m);
	out->value = buffer_get_string(&m, &len);
	out->length = len;
	if (flags)
		*flags = buffer_get_int(&m);
d991 7
a997 18
	buffer_free(&m);

	return (major);
}

int
mm_ssh_gssapi_userok(char *user)
{
	Buffer m;
	int authenticated = 0;

	buffer_init(&m);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSUSEROK, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSUSEROK,
				  &m);

	authenticated = buffer_get_int(&m);
d1000 1
a1000 2
	debug3("%s: user %sauthenticated",__func__, authenticated ? "" : "not ");
	return (authenticated);
d1002 1
a1002 1
#endif /* GSSAPI */
@


1.22.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.35 2003/11/17 11:06:07 markus Exp $");
a66 10
int
mm_is_monitor(void)
{
	/*
	 * m_pid is only set in the privileged part, and
	 * points to the unprivileged child.
	 */
	return (pmonitor && pmonitor->m_pid > 0);
}

d95 1
a95 1
			cleanup_exit(255);
d213 1
a213 2
char *
mm_auth2_read_banner(void)
d224 1
a224 2
	mm_request_receive_expect(pmonitor->m_recvfd,
	    MONITOR_ANS_AUTH2_READ_BANNER, &m);
a227 5
	/* treat empty banner as missing banner */
	if (strlen(banner) == 0) {
		xfree(banner);
		banner = NULL;
	}
d647 1
a647 1
mm_session_pty_cleanup2(Session *s)
d649 1
a989 19
}

OM_uint32
mm_ssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)
{
	Buffer m;
	OM_uint32 major;

	buffer_init(&m);
	buffer_put_string(&m, gssbuf->value, gssbuf->length);
	buffer_put_string(&m, gssmic->value, gssmic->length);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSCHECKMIC, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSCHECKMIC,
	    &m);

	major = buffer_get_int(&m);
	buffer_free(&m);
	return(major);
@


1.21
log
@skey/bsdauth: use 0 to indicate failure instead of -1, because
the buffer API only supports unsigned ints.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.20 2002/11/21 23:03:51 deraadt Exp $");
d37 1
d314 1
a314 1
	int allowed = 0;
d336 5
d843 1
a843 1
	int allowed = 0;
d854 5
@


1.20
log
@KNF
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.19 2002/09/26 11:38:43 markus Exp $");
d698 1
a698 1
	int res;
d708 2
a709 2
	res = buffer_get_int(&m);
	if (res == -1) {
d755 2
a756 1
	int len, res;
d766 2
a767 2
	res = buffer_get_int(&m);
	if (res == -1) {
@


1.19
log
@krb4 + privsep; ok dugsong@@, deraadt@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.18 2002/09/09 14:54:15 markus Exp $");
d953 1
a953 1
	return (success); 
@


1.19.2.1
log
@Update to OpenSSH 3.6
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.22 2003/02/16 17:30:33 markus Exp $");
a36 1
#include "auth-options.h"
d313 1
a313 1
	int allowed = 0, have_forced = 0;
a334 5
	/* fake forced command */
	auth_clear_options();
	have_forced = buffer_get_int(&m);
	forced_command = have_forced ? xstrdup("true") : NULL;

d698 1
a698 1
	u_int success;
d708 2
a709 2
	success = buffer_get_int(&m);
	if (success == 0) {
d755 1
a755 2
	int len;
	u_int success;
d765 2
a766 2
	success = buffer_get_int(&m);
	if (success == 0) {
d836 1
a836 1
	int allowed = 0, have_forced = 0;
a847 5
	/* fake forced command */
	auth_clear_options();
	have_forced = buffer_get_int(&m);
	forced_command = have_forced ? xstrdup("true") : NULL;

d953 1
a953 1
	return (success);
@


1.19.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.31 2003/08/28 12:54:34 markus Exp $");
a54 4
#ifdef GSSAPI
#include "ssh-gss.h"
#endif

d73 1
a73 1
	if (atomicio(vwrite, socket, buf, sizeof(buf)) != sizeof(buf))
d75 1
a75 1
	if (atomicio(vwrite, socket, buffer_ptr(m), mlen) != mlen)
a520 2
	u_int32_t seqnr, packets;
	u_int64_t blocks;
d569 2
a570 8
	packet_get_state(MODE_OUT, &seqnr, &blocks, &packets);
	buffer_put_int(&m, seqnr);
	buffer_put_int64(&m, blocks);
	buffer_put_int(&m, packets);
	packet_get_state(MODE_IN, &seqnr, &blocks, &packets);
	buffer_put_int(&m, seqnr);
	buffer_put_int64(&m, blocks);
	buffer_put_int(&m, packets);
d933 3
a935 3
#ifdef GSSAPI
OM_uint32
mm_ssh_gssapi_server_ctx(Gssctxt **ctx, gss_OID oid)
d937 5
a941 2
	Buffer m;
	OM_uint32 major;
d943 3
a945 2
	/* Client doesn't get to see the context */
	*ctx = NULL;
d948 1
a948 1
	buffer_put_string(&m, oid->elements, oid->length);
d950 2
a951 4
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSSETUP, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSSETUP, &m);

	major = buffer_get_int(&m);
d953 11
d965 1
a965 1
	return (major);
d967 1
d969 3
a971 3
OM_uint32
mm_ssh_gssapi_accept_ctx(Gssctxt *ctx, gss_buffer_desc *in,
    gss_buffer_desc *out, OM_uint32 *flags)
d973 1
d975 5
a979 2
	OM_uint32 major;
	u_int len;
d982 1
a982 1
	buffer_put_string(&m, in->value, in->length);
d984 2
a985 2
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSSTEP, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSSTEP, &m);
d987 3
a989 5
	major = buffer_get_int(&m);
	out->value = buffer_get_string(&m, &len);
	out->length = len;
	if (flags)
		*flags = buffer_get_int(&m);
d991 7
a997 18
	buffer_free(&m);

	return (major);
}

int
mm_ssh_gssapi_userok(char *user)
{
	Buffer m;
	int authenticated = 0;

	buffer_init(&m);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSUSEROK, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSUSEROK,
				  &m);

	authenticated = buffer_get_int(&m);
d1000 1
a1000 2
	debug3("%s: user %sauthenticated",__func__, authenticated ? "" : "not ");
	return (authenticated);
d1002 1
a1002 1
#endif /* GSSAPI */
@


1.18
log
@signed vs unsigned from -pedantic; ok henning@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.17 2002/09/09 06:48:06 itojun Exp $");
d920 36
@


1.17
log
@kerberos support for privsep.  confirmed to work by lha@@stacken.kth.se
patch from markus
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.16 2002/07/04 10:41:47 markus Exp $");
d600 1
a600 1
	u_char *p;
@


1.16
log
@don't allocate, copy, and discard if there is not interested in the data; ok deraadt@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.15 2002/07/04 04:15:33 deraadt Exp $");
d920 35
@


1.15
log
@patch memory leaks; grendel@@zeitbombe.org
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.14 2002/06/30 21:59:45 deraadt Exp $");
a446 1
	u_char *buf;
d484 6
a489 2
	buf = xmalloc(len);
	memcpy(buf, buffer_ptr(&b), len);
a491 6
	if (lenp != NULL)
		*lenp = len;
	if (blobp != NULL)
		*blobp = buf;
	else
		xfree(blobp);
@


1.14
log
@minor KNF
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.13 2002/06/28 01:50:37 deraadt Exp $");
d493 2
@


1.13
log
@use ssize_t
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.12 2002/06/26 15:00:32 deraadt Exp $");
d208 1
a208 1
char* mm_auth2_read_banner(void)
d689 1
a689 1
	*prompts = xmalloc(*numprompts * sizeof(char*));
@


1.12
log
@more %u
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.11 2002/06/19 18:01:00 markus Exp $");
d65 1
a66 1
	u_int mlen = buffer_len(m);
d82 1
a83 1
	u_int msg_len;
@


1.11
log
@make the monitor sync the transfer ssh1 session key;
transfer keycontext only for RC4 (this is still depends on EVP
implementation details and is broken).
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.10 2002/06/19 00:27:55 deraadt Exp $");
d412 1
a412 1
		fatal("%s: bad ivlen: expected %d != %d", __func__,
d426 1
a426 1
		fatal("%s: bad mac key length: %d > %d", __func__, len,
d437 1
a437 1
		error("newkeys_from_blob: remaining bytes in blob %d", len);
@


1.10
log
@KNF done automatically while reading....
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.9 2002/06/14 21:35:00 todd Exp $");
d521 2
a522 1
		int ivlen;
d528 8
a535 1
		debug3("%s: Sending ssh1 IV", __func__);
@


1.9
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.8 2002/06/04 23:05:49 markus Exp $");
d71 1
a71 1
	buf[4] = (u_char) type;         /* 1st byte of payload is mesg-type */
d222 1
a222 1
	
d678 2
a679 2
	*name       = xstrdup("");
	*infotxt    = xstrdup("");
@


1.8
log
@__FUNCTION__ -> __func__
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.7 2002/05/15 15:47:49 mouring Exp $");
d426 1
a426 1
		fatal("%s: bad mac key lenght: %d > %d", __func__, len,
@


1.7
log
@'monitor' variable clashes with at least one lame platform (NeXT).  Renamed
to 'pmonitor'.  provos@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.6 2002/05/12 23:53:45 djm Exp $");
d68 1
a68 1
	debug3("%s entering: type %d", __FUNCTION__, type);
d73 1
a73 1
		fatal("%s: write", __FUNCTION__);
d75 1
a75 1
		fatal("%s: write", __FUNCTION__);
d85 1
a85 1
	debug3("%s entering", __FUNCTION__);
d91 1
a91 1
		fatal("%s: read: %ld", __FUNCTION__, (long)res);
d95 1
a95 1
		fatal("%s: read: bad msg_len %d", __FUNCTION__, msg_len);
d100 1
a100 1
		fatal("%s: read: %ld != msg_len", __FUNCTION__, (long)res);
d108 1
a108 1
	debug3("%s entering: type %d", __FUNCTION__, type);
d113 1
a113 1
		fatal("%s: read: rtype %d != type %d", __FUNCTION__,
d131 1
a131 1
	debug3("%s: waiting for MONITOR_ANS_MODULI", __FUNCTION__);
d136 1
a136 1
		fatal("%s: MONITOR_ANS_MODULI failed", __FUNCTION__);
d139 1
a139 1
		fatal("%s: BN_new failed", __FUNCTION__);
d141 1
a141 1
		fatal("%s: BN_new failed", __FUNCTION__);
d145 1
a145 1
	debug3("%s: remaining %d", __FUNCTION__, buffer_len(&m));
d157 1
a157 1
	debug3("%s entering", __FUNCTION__);
d165 1
a165 1
	debug3("%s: waiting for MONITOR_ANS_SIGN", __FUNCTION__);
d180 1
a180 1
	debug3("%s entering", __FUNCTION__);
d187 1
a187 1
	debug3("%s: waiting for MONITOR_ANS_PWNAM", __FUNCTION__);
d196 1
a196 1
		fatal("%s: struct passwd size mismatch", __FUNCTION__);
d213 1
a213 1
	debug3("%s entering", __FUNCTION__);
d233 1
a233 1
	debug3("%s entering", __FUNCTION__);
d251 1
a251 1
	debug3("%s entering", __FUNCTION__);
d257 1
a257 1
	debug3("%s: waiting for MONITOR_ANS_AUTHPASSWORD", __FUNCTION__);
d265 1
a265 1
	    __FUNCTION__, authenticated ? "" : "not ");
d301 1
a301 1
		debug3("%s: Sending debug: %s", __FUNCTION__, msg);
d315 1
a315 1
	debug3("%s entering", __FUNCTION__);
d330 1
a330 1
	debug3("%s: waiting for MONITOR_ANS_KEYALLOWED", __FUNCTION__);
d357 1
a357 1
	debug3("%s entering", __FUNCTION__);
d371 1
a371 1
	debug3("%s: waiting for MONITOR_ANS_KEYVERIFY", __FUNCTION__);
d392 1
a392 1
	debug3("%s: %p(%d)", __FUNCTION__, blob, blen);
d412 1
a412 1
		fatal("%s: bad ivlen: expected %d != %d", __FUNCTION__,
d416 1
a416 1
		fatal("%s: bad cipher name %s or pointer %p", __FUNCTION__,
d422 1
a422 1
		fatal("%s: can not init mac %s", __FUNCTION__, mac->name);
d426 1
a426 1
		fatal("%s: bad mac key lenght: %d > %d", __FUNCTION__, len,
d453 1
a453 1
	debug3("%s: converting %p", __FUNCTION__, newkey);
d456 1
a456 1
		error("%s: newkey == NULL", __FUNCTION__);
d527 1
a527 1
		debug3("%s: Sending ssh1 IV", __FUNCTION__);
d541 1
a541 1
	    __FUNCTION__, newkeys[MODE_OUT], newkeys[MODE_IN]);
d545 1
a545 1
		fatal("%s: conversion of newkeys failed", __FUNCTION__);
d551 1
a551 1
		fatal("%s: conversion of newkeys failed", __FUNCTION__);
d559 1
a559 1
	debug3("%s: New keys have been sent", __FUNCTION__);
d575 1
a575 1
	debug3("%s: Sending compression state", __FUNCTION__);
d584 1
a584 1
	debug3("%s: Finished sending state", __FUNCTION__);
d599 1
a599 1
	debug3("%s: waiting for MONITOR_ANS_PTY", __FUNCTION__);
d604 1
a604 1
		debug3("%s: pty alloc failed", __FUNCTION__);
d694 1
a694 1
	debug3("%s: entering", __FUNCTION__);
d703 1
a703 1
		debug3("%s: no challenge", __FUNCTION__);
d715 1
a715 1
	debug3("%s: received challenge: %s", __FUNCTION__, challenge);
d726 1
a726 1
	debug3("%s: entering", __FUNCTION__);
d751 1
a751 1
	debug3("%s: entering", __FUNCTION__);
d760 1
a760 1
		debug3("%s: no challenge", __FUNCTION__);
d769 1
a769 1
	debug3("%s: received challenge: %s", __FUNCTION__, challenge);
d789 1
a789 1
	debug3("%s: entering", __FUNCTION__);
d812 1
a812 1
	debug3("%s entering", __FUNCTION__);
d831 1
a831 1
	debug3("%s entering", __FUNCTION__);
d844 1
a844 1
			fatal("%s: key_from_blob failed", __FUNCTION__);
d862 1
a862 1
	debug3("%s entering", __FUNCTION__);
d865 1
a865 1
		fatal("%s: BN_new failed", __FUNCTION__);
d869 1
a869 1
		fatal("%s: key_to_blob failed", __FUNCTION__);
d893 1
a893 1
	debug3("%s entering", __FUNCTION__);
d897 1
a897 1
		fatal("%s: key_to_blob failed", __FUNCTION__);
@


1.7.4.1
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.7 2002/05/15 15:47:49 mouring Exp $");
@


1.7.2.1
log
@Update OpenSSH to version 3.2.2.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.7 2002/05/15 15:47:49 mouring Exp $");
@


1.7.2.2
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.7.2.1 2002/05/17 00:03:23 miod Exp $");
d68 1
a68 1
	debug3("%s entering: type %d", __func__, type);
d71 1
a71 1
	buf[4] = (u_char) type;		/* 1st byte of payload is mesg-type */
d73 1
a73 1
		fatal("%s: write", __func__);
d75 1
a75 1
		fatal("%s: write", __func__);
d85 1
a85 1
	debug3("%s entering", __func__);
d91 1
a91 1
		fatal("%s: read: %ld", __func__, (long)res);
d95 1
a95 1
		fatal("%s: read: bad msg_len %d", __func__, msg_len);
d100 1
a100 1
		fatal("%s: read: %ld != msg_len", __func__, (long)res);
d108 1
a108 1
	debug3("%s entering: type %d", __func__, type);
d113 1
a113 1
		fatal("%s: read: rtype %d != type %d", __func__,
d131 1
a131 1
	debug3("%s: waiting for MONITOR_ANS_MODULI", __func__);
d136 1
a136 1
		fatal("%s: MONITOR_ANS_MODULI failed", __func__);
d139 1
a139 1
		fatal("%s: BN_new failed", __func__);
d141 1
a141 1
		fatal("%s: BN_new failed", __func__);
d145 1
a145 1
	debug3("%s: remaining %d", __func__, buffer_len(&m));
d157 1
a157 1
	debug3("%s entering", __func__);
d165 1
a165 1
	debug3("%s: waiting for MONITOR_ANS_SIGN", __func__);
d180 1
a180 1
	debug3("%s entering", __func__);
d187 1
a187 1
	debug3("%s: waiting for MONITOR_ANS_PWNAM", __func__);
d196 1
a196 1
		fatal("%s: struct passwd size mismatch", __func__);
d213 1
a213 1
	debug3("%s entering", __func__);
d222 1
a222 1

d233 1
a233 1
	debug3("%s entering", __func__);
d251 1
a251 1
	debug3("%s entering", __func__);
d257 1
a257 1
	debug3("%s: waiting for MONITOR_ANS_AUTHPASSWORD", __func__);
d265 1
a265 1
	    __func__, authenticated ? "" : "not ");
d301 1
a301 1
		debug3("%s: Sending debug: %s", __func__, msg);
d315 1
a315 1
	debug3("%s entering", __func__);
d330 1
a330 1
	debug3("%s: waiting for MONITOR_ANS_KEYALLOWED", __func__);
d357 1
a357 1
	debug3("%s entering", __func__);
d371 1
a371 1
	debug3("%s: waiting for MONITOR_ANS_KEYVERIFY", __func__);
d392 1
a392 1
	debug3("%s: %p(%d)", __func__, blob, blen);
d412 1
a412 1
		fatal("%s: bad ivlen: expected %d != %d", __func__,
d416 1
a416 1
		fatal("%s: bad cipher name %s or pointer %p", __func__,
d422 1
a422 1
		fatal("%s: can not init mac %s", __func__, mac->name);
d426 1
a426 1
		fatal("%s: bad mac key length: %d > %d", __func__, len,
d453 1
a453 1
	debug3("%s: converting %p", __func__, newkey);
d456 1
a456 1
		error("%s: newkey == NULL", __func__);
d521 1
a521 2
		u_char *key;
		u_int ivlen, keylen;
d527 1
a527 8
		debug3("%s: Sending ssh1 KEY+IV", __func__);
		keylen = packet_get_encryption_key(NULL);
		key = xmalloc(keylen+1);	/* add 1 if keylen == 0 */
		keylen = packet_get_encryption_key(key);
		buffer_put_string(&m, key, keylen);
		memset(key, 0, keylen);
		xfree(key);

d541 1
a541 1
	    __func__, newkeys[MODE_OUT], newkeys[MODE_IN]);
d545 1
a545 1
		fatal("%s: conversion of newkeys failed", __func__);
d551 1
a551 1
		fatal("%s: conversion of newkeys failed", __func__);
d559 1
a559 1
	debug3("%s: New keys have been sent", __func__);
d575 1
a575 1
	debug3("%s: Sending compression state", __func__);
d584 1
a584 1
	debug3("%s: Finished sending state", __func__);
d599 1
a599 1
	debug3("%s: waiting for MONITOR_ANS_PTY", __func__);
d604 1
a604 1
		debug3("%s: pty alloc failed", __func__);
d678 2
a679 2
	*name = xstrdup("");
	*infotxt = xstrdup("");
d694 1
a694 1
	debug3("%s: entering", __func__);
d703 1
a703 1
		debug3("%s: no challenge", __func__);
d715 1
a715 1
	debug3("%s: received challenge: %s", __func__, challenge);
d726 1
a726 1
	debug3("%s: entering", __func__);
d751 1
a751 1
	debug3("%s: entering", __func__);
d760 1
a760 1
		debug3("%s: no challenge", __func__);
d769 1
a769 1
	debug3("%s: received challenge: %s", __func__, challenge);
d789 1
a789 1
	debug3("%s: entering", __func__);
d812 1
a812 1
	debug3("%s entering", __func__);
d831 1
a831 1
	debug3("%s entering", __func__);
d844 1
a844 1
			fatal("%s: key_from_blob failed", __func__);
d862 1
a862 1
	debug3("%s entering", __func__);
d865 1
a865 1
		fatal("%s: BN_new failed", __func__);
d869 1
a869 1
		fatal("%s: key_to_blob failed", __func__);
d893 1
a893 1
	debug3("%s entering", __func__);
d897 1
a897 1
		fatal("%s: key_to_blob failed", __func__);
@


1.7.2.3
log
@Update to OpenSSH 3.5
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.19 2002/09/26 11:38:43 markus Exp $");
d65 1
a66 1
	u_char buf[5];
d82 1
a83 1
	ssize_t res;
d208 1
a208 1
char *mm_auth2_read_banner(void)
d412 1
a412 1
		fatal("%s: bad ivlen: expected %u != %u", __func__,
d426 1
a426 1
		fatal("%s: bad mac key length: %u > %d", __func__, len,
d437 1
a437 1
		error("newkeys_from_blob: remaining bytes in blob %u", len);
d447 1
d485 4
d491 2
a492 6
	if (blobp != NULL) {
		*blobp = xmalloc(len);
		memcpy(*blobp, buffer_ptr(&b), len);
	}
	memset(buffer_ptr(&b), 0, len);
	buffer_free(&b);
d601 1
a601 1
	char *p;
d689 1
a689 1
	*prompts = xmalloc(*numprompts * sizeof(char *));
a920 71

#ifdef KRB4
int
mm_auth_krb4(Authctxt *authctxt, void *_auth, char **client, void *_reply)
{
	KTEXT auth, reply;
 	Buffer m;
	u_int rlen;
	int success = 0;
	char *p;

	debug3("%s entering", __func__);
	auth = _auth;
	reply = _reply;

	buffer_init(&m);
	buffer_put_string(&m, auth->dat, auth->length);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_KRB4, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_KRB4, &m);

	success = buffer_get_int(&m);
	if (success) {
		*client = buffer_get_string(&m, NULL);
		p = buffer_get_string(&m, &rlen);
		if (rlen >= MAX_KTXT_LEN)
			fatal("%s: reply from monitor too large", __func__);
		reply->length = rlen;
		memcpy(reply->dat, p, rlen);
		memset(p, 0, rlen);
		xfree(p);
	}
	buffer_free(&m);
	return (success); 
}
#endif

#ifdef KRB5
int
mm_auth_krb5(void *ctx, void *argp, char **userp, void *resp)
{
	krb5_data *tkt, *reply;
	Buffer m;
	int success;

	debug3("%s entering", __func__);
	tkt = (krb5_data *) argp;
	reply = (krb5_data *) resp;

	buffer_init(&m);
	buffer_put_string(&m, tkt->data, tkt->length);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_KRB5, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_KRB5, &m);

	success = buffer_get_int(&m);
	if (success) {
		u_int len;

		*userp = buffer_get_string(&m, NULL);
		reply->data = buffer_get_string(&m, &len);
		reply->length = len;
	} else {
		memset(reply, 0, sizeof(*reply));
		*userp = NULL;
	}

	buffer_free(&m);
	return (success);
}
#endif
@


1.6
log
@Fix sshd Banner option for privsep; ok markus@@ provos@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.5 2002/03/25 20:12:10 stevesk Exp $");
d59 1
a59 1
extern struct monitor *monitor;
d129 1
a129 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_MODULI, &m);
d132 1
a132 1
	mm_request_receive_expect(monitor->m_recvfd, MONITOR_ANS_MODULI, &m);
d154 1
a154 1
	Kex *kex = *monitor->m_pkex;
d163 1
a163 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_SIGN, &m);
d166 1
a166 1
	mm_request_receive_expect(monitor->m_recvfd, MONITOR_ANS_SIGN, &m);
d185 1
a185 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_PWNAM, &m);
d188 1
a188 1
	mm_request_receive_expect(monitor->m_recvfd, MONITOR_ANS_PWNAM, &m);
d216 1
a216 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_AUTH2_READ_BANNER, &m);
d219 1
a219 1
	mm_request_receive_expect(monitor->m_recvfd, MONITOR_ANS_AUTH2_READ_BANNER, &m);
d239 1
a239 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_AUTHSERV, &m);
d255 1
a255 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_AUTHPASSWORD, &m);
d258 1
a258 1
	mm_request_receive_expect(monitor->m_recvfd, MONITOR_ANS_AUTHPASSWORD, &m);
d328 1
a328 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_KEYALLOWED, &m);
d331 1
a331 1
	mm_request_receive_expect(monitor->m_recvfd, MONITOR_ANS_KEYALLOWED, &m);
d369 1
a369 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_KEYVERIFY, &m);
d372 1
a372 1
	mm_request_receive_expect(monitor->m_recvfd, MONITOR_ANS_KEYVERIFY, &m);
d511 1
a511 1
mm_send_keystate(struct monitor *monitor)
d537 1
a537 1
		mm_send_kex(&m, *monitor->m_pkex);
d583 1
a583 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_KEYEXPORT, &m);
d597 1
a597 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_PTY, &m);
d600 1
a600 1
	mm_request_receive_expect(monitor->m_recvfd, MONITOR_ANS_PTY, &m);
d614 2
a615 2
	*ptyfd = mm_receive_fd(monitor->m_recvfd);
	*ttyfd = mm_receive_fd(monitor->m_recvfd);
d631 1
a631 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_PTYCLEANUP, &m);
d650 1
a650 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_TERM, &m);
d662 1
a662 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_SESSKEY, &m);
d664 1
a664 1
	mm_request_receive_expect(monitor->m_recvfd, MONITOR_ANS_SESSKEY, &m);
d697 1
a697 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_BSDAUTHQUERY, &m);
d699 1
a699 1
	mm_request_receive_expect(monitor->m_recvfd, MONITOR_ANS_BSDAUTHQUERY,
d732 1
a732 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_BSDAUTHRESPOND, &m);
d734 1
a734 1
	mm_request_receive_expect(monitor->m_recvfd,
d754 1
a754 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_SKEYQUERY, &m);
d756 1
a756 1
	mm_request_receive_expect(monitor->m_recvfd, MONITOR_ANS_SKEYQUERY,
d795 1
a795 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_SKEYRESPOND, &m);
d797 1
a797 1
	mm_request_receive_expect(monitor->m_recvfd,
d818 1
a818 1
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_SESSID, &m);
d836 2
a837 2
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_RSAKEYALLOWED, &m);
	mm_request_receive_expect(monitor->m_recvfd, MONITOR_ANS_RSAKEYALLOWED, &m);
d876 2
a877 2
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_RSACHALLENGE, &m);
	mm_request_receive_expect(monitor->m_recvfd, MONITOR_ANS_RSACHALLENGE, &m);
d905 2
a906 2
	mm_request_send(monitor->m_recvfd, MONITOR_REQ_RSARESPONSE, &m);
	mm_request_receive_expect(monitor->m_recvfd, MONITOR_ANS_RSARESPONSE, &m);
@


1.5
log
@ssize_t args use "%ld" and cast to (long)
size_t args use "%lu" and cast to (u_long)
ok markus@@ and thanks millert@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.4 2002/03/19 14:27:39 markus Exp $");
d206 18
@


1.5.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.7 2002/05/15 15:47:49 mouring Exp $");
d59 1
a59 1
extern struct monitor *pmonitor;
d129 1
a129 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_MODULI, &m);
d132 1
a132 1
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_MODULI, &m);
d154 1
a154 1
	Kex *kex = *pmonitor->m_pkex;
d163 1
a163 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SIGN, &m);
d166 1
a166 1
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SIGN, &m);
d185 1
a185 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PWNAM, &m);
d188 1
a188 1
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PWNAM, &m);
a207 18
char* mm_auth2_read_banner(void)
{
	Buffer m;
	char *banner;

	debug3("%s entering", __FUNCTION__);

	buffer_init(&m);
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_AUTH2_READ_BANNER, &m);
	buffer_clear(&m);

	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_AUTH2_READ_BANNER, &m);
	banner = buffer_get_string(&m, NULL);
	buffer_free(&m);
	
	return (banner);
}

d221 1
a221 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_AUTHSERV, &m);
d237 1
a237 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_AUTHPASSWORD, &m);
d240 1
a240 1
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_AUTHPASSWORD, &m);
d310 1
a310 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_KEYALLOWED, &m);
d313 1
a313 1
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_KEYALLOWED, &m);
d351 1
a351 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_KEYVERIFY, &m);
d354 1
a354 1
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_KEYVERIFY, &m);
d493 1
a493 1
mm_send_keystate(struct monitor *pmonitor)
d519 1
a519 1
		mm_send_kex(&m, *pmonitor->m_pkex);
d565 1
a565 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_KEYEXPORT, &m);
d579 1
a579 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PTY, &m);
d582 1
a582 1
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PTY, &m);
d596 2
a597 2
	*ptyfd = mm_receive_fd(pmonitor->m_recvfd);
	*ttyfd = mm_receive_fd(pmonitor->m_recvfd);
d613 1
a613 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PTYCLEANUP, &m);
d632 1
a632 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_TERM, &m);
d644 1
a644 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SESSKEY, &m);
d646 1
a646 1
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SESSKEY, &m);
d679 1
a679 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_BSDAUTHQUERY, &m);
d681 1
a681 1
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_BSDAUTHQUERY,
d714 1
a714 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_BSDAUTHRESPOND, &m);
d716 1
a716 1
	mm_request_receive_expect(pmonitor->m_recvfd,
d736 1
a736 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SKEYQUERY, &m);
d738 1
a738 1
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SKEYQUERY,
d777 1
a777 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SKEYRESPOND, &m);
d779 1
a779 1
	mm_request_receive_expect(pmonitor->m_recvfd,
d800 1
a800 1
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SESSID, &m);
d818 2
a819 2
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_RSAKEYALLOWED, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_RSAKEYALLOWED, &m);
d858 2
a859 2
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_RSACHALLENGE, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_RSACHALLENGE, &m);
d887 2
a888 2
	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_RSARESPONSE, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_RSARESPONSE, &m);
@


1.5.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.5.2.3
log
@Pull in OpenSSH-3.4
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.11 2002/06/19 18:01:00 markus Exp $");
d68 1
a68 1
	debug3("%s entering: type %d", __func__, type);
d71 1
a71 1
	buf[4] = (u_char) type;		/* 1st byte of payload is mesg-type */
d73 1
a73 1
		fatal("%s: write", __func__);
d75 1
a75 1
		fatal("%s: write", __func__);
d85 1
a85 1
	debug3("%s entering", __func__);
d91 1
a91 1
		fatal("%s: read: %ld", __func__, (long)res);
d95 1
a95 1
		fatal("%s: read: bad msg_len %d", __func__, msg_len);
d100 1
a100 1
		fatal("%s: read: %ld != msg_len", __func__, (long)res);
d108 1
a108 1
	debug3("%s entering: type %d", __func__, type);
d113 1
a113 1
		fatal("%s: read: rtype %d != type %d", __func__,
d131 1
a131 1
	debug3("%s: waiting for MONITOR_ANS_MODULI", __func__);
d136 1
a136 1
		fatal("%s: MONITOR_ANS_MODULI failed", __func__);
d139 1
a139 1
		fatal("%s: BN_new failed", __func__);
d141 1
a141 1
		fatal("%s: BN_new failed", __func__);
d145 1
a145 1
	debug3("%s: remaining %d", __func__, buffer_len(&m));
d157 1
a157 1
	debug3("%s entering", __func__);
d165 1
a165 1
	debug3("%s: waiting for MONITOR_ANS_SIGN", __func__);
d180 1
a180 1
	debug3("%s entering", __func__);
d187 1
a187 1
	debug3("%s: waiting for MONITOR_ANS_PWNAM", __func__);
d196 1
a196 1
		fatal("%s: struct passwd size mismatch", __func__);
d213 1
a213 1
	debug3("%s entering", __func__);
d222 1
a222 1

d233 1
a233 1
	debug3("%s entering", __func__);
d251 1
a251 1
	debug3("%s entering", __func__);
d257 1
a257 1
	debug3("%s: waiting for MONITOR_ANS_AUTHPASSWORD", __func__);
d265 1
a265 1
	    __func__, authenticated ? "" : "not ");
d301 1
a301 1
		debug3("%s: Sending debug: %s", __func__, msg);
d315 1
a315 1
	debug3("%s entering", __func__);
d330 1
a330 1
	debug3("%s: waiting for MONITOR_ANS_KEYALLOWED", __func__);
d357 1
a357 1
	debug3("%s entering", __func__);
d371 1
a371 1
	debug3("%s: waiting for MONITOR_ANS_KEYVERIFY", __func__);
d392 1
a392 1
	debug3("%s: %p(%d)", __func__, blob, blen);
d412 1
a412 1
		fatal("%s: bad ivlen: expected %d != %d", __func__,
d416 1
a416 1
		fatal("%s: bad cipher name %s or pointer %p", __func__,
d422 1
a422 1
		fatal("%s: can not init mac %s", __func__, mac->name);
d426 1
a426 1
		fatal("%s: bad mac key length: %d > %d", __func__, len,
d453 1
a453 1
	debug3("%s: converting %p", __func__, newkey);
d456 1
a456 1
		error("%s: newkey == NULL", __func__);
d521 1
a521 2
		u_char *key;
		u_int ivlen, keylen;
d527 1
a527 8
		debug3("%s: Sending ssh1 KEY+IV", __func__);
		keylen = packet_get_encryption_key(NULL);
		key = xmalloc(keylen+1);	/* add 1 if keylen == 0 */
		keylen = packet_get_encryption_key(key);
		buffer_put_string(&m, key, keylen);
		memset(key, 0, keylen);
		xfree(key);

d541 1
a541 1
	    __func__, newkeys[MODE_OUT], newkeys[MODE_IN]);
d545 1
a545 1
		fatal("%s: conversion of newkeys failed", __func__);
d551 1
a551 1
		fatal("%s: conversion of newkeys failed", __func__);
d559 1
a559 1
	debug3("%s: New keys have been sent", __func__);
d575 1
a575 1
	debug3("%s: Sending compression state", __func__);
d584 1
a584 1
	debug3("%s: Finished sending state", __func__);
d599 1
a599 1
	debug3("%s: waiting for MONITOR_ANS_PTY", __func__);
d604 1
a604 1
		debug3("%s: pty alloc failed", __func__);
d678 2
a679 2
	*name = xstrdup("");
	*infotxt = xstrdup("");
d694 1
a694 1
	debug3("%s: entering", __func__);
d703 1
a703 1
		debug3("%s: no challenge", __func__);
d715 1
a715 1
	debug3("%s: received challenge: %s", __func__, challenge);
d726 1
a726 1
	debug3("%s: entering", __func__);
d751 1
a751 1
	debug3("%s: entering", __func__);
d760 1
a760 1
		debug3("%s: no challenge", __func__);
d769 1
a769 1
	debug3("%s: received challenge: %s", __func__, challenge);
d789 1
a789 1
	debug3("%s: entering", __func__);
d812 1
a812 1
	debug3("%s entering", __func__);
d831 1
a831 1
	debug3("%s entering", __func__);
d844 1
a844 1
			fatal("%s: key_from_blob failed", __func__);
d862 1
a862 1
	debug3("%s entering", __func__);
d865 1
a865 1
		fatal("%s: BN_new failed", __func__);
d869 1
a869 1
		fatal("%s: key_to_blob failed", __func__);
d893 1
a893 1
	debug3("%s entering", __func__);
d897 1
a897 1
		fatal("%s: key_to_blob failed", __func__);
@


1.5.2.4
log
@Update to OpenSSH 3.5
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.19 2002/09/26 11:38:43 markus Exp $");
d65 1
a66 1
	u_char buf[5];
d82 1
a83 1
	ssize_t res;
d208 1
a208 1
char *mm_auth2_read_banner(void)
d412 1
a412 1
		fatal("%s: bad ivlen: expected %u != %u", __func__,
d426 1
a426 1
		fatal("%s: bad mac key length: %u > %d", __func__, len,
d437 1
a437 1
		error("newkeys_from_blob: remaining bytes in blob %u", len);
d447 1
d485 4
d491 2
a492 6
	if (blobp != NULL) {
		*blobp = xmalloc(len);
		memcpy(*blobp, buffer_ptr(&b), len);
	}
	memset(buffer_ptr(&b), 0, len);
	buffer_free(&b);
d601 1
a601 1
	char *p;
d689 1
a689 1
	*prompts = xmalloc(*numprompts * sizeof(char *));
a920 71

#ifdef KRB4
int
mm_auth_krb4(Authctxt *authctxt, void *_auth, char **client, void *_reply)
{
	KTEXT auth, reply;
 	Buffer m;
	u_int rlen;
	int success = 0;
	char *p;

	debug3("%s entering", __func__);
	auth = _auth;
	reply = _reply;

	buffer_init(&m);
	buffer_put_string(&m, auth->dat, auth->length);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_KRB4, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_KRB4, &m);

	success = buffer_get_int(&m);
	if (success) {
		*client = buffer_get_string(&m, NULL);
		p = buffer_get_string(&m, &rlen);
		if (rlen >= MAX_KTXT_LEN)
			fatal("%s: reply from monitor too large", __func__);
		reply->length = rlen;
		memcpy(reply->dat, p, rlen);
		memset(p, 0, rlen);
		xfree(p);
	}
	buffer_free(&m);
	return (success); 
}
#endif

#ifdef KRB5
int
mm_auth_krb5(void *ctx, void *argp, char **userp, void *resp)
{
	krb5_data *tkt, *reply;
	Buffer m;
	int success;

	debug3("%s entering", __func__);
	tkt = (krb5_data *) argp;
	reply = (krb5_data *) resp;

	buffer_init(&m);
	buffer_put_string(&m, tkt->data, tkt->length);

	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_KRB5, &m);
	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_KRB5, &m);

	success = buffer_get_int(&m);
	if (success) {
		u_int len;

		*userp = buffer_get_string(&m, NULL);
		reply->data = buffer_get_string(&m, &len);
		reply->length = len;
	} else {
		memset(reply, 0, sizeof(*reply));
		*userp = NULL;
	}

	buffer_free(&m);
	return (success);
}
#endif
@


1.5.2.5
log
@Merge OpenSSH 3.6.1
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.24 2003/04/01 10:22:21 markus Exp $");
a36 1
#include "auth-options.h"
d313 1
a313 1
	int allowed = 0, have_forced = 0;
a334 5
	/* fake forced command */
	auth_clear_options();
	have_forced = buffer_get_int(&m);
	forced_command = have_forced ? xstrdup("true") : NULL;

d698 1
a698 1
	u_int success;
d708 2
a709 2
	success = buffer_get_int(&m);
	if (success == 0) {
d755 1
a755 2
	int len;
	u_int success;
d765 2
a766 2
	success = buffer_get_int(&m);
	if (success == 0) {
d836 1
a836 1
	int allowed = 0, have_forced = 0;
a847 5
	/* fake forced command */
	auth_clear_options();
	have_forced = buffer_get_int(&m);
	forced_command = have_forced ? xstrdup("true") : NULL;

d953 1
a953 1
	return (success);
@


1.4
log
@make getpwnamallow() allways call pwcopy()
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.3 2002/03/19 10:41:32 markus Exp $");
d91 1
a91 1
		fatal("%s: read: %d", __FUNCTION__, res);
d100 1
a100 1
		fatal("%s: read: %d != msg_len", __FUNCTION__, res);
@


1.3
log
@whitespace KNF
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.2 2002/03/19 10:35:39 markus Exp $");
a205 12
}

void
pwfree(struct passwd *pw)
{
	xfree(pw->pw_name);
	xfree(pw->pw_passwd);
	xfree(pw->pw_gecos);
	xfree(pw->pw_class);
	xfree(pw->pw_dir);
	xfree(pw->pw_shell);
	xfree(pw);
@


1.2
log
@clean up prototypes
@
text
@d28 1
a28 1
RCSID("$OpenBSD: monitor_wrap.c,v 1.1 2002/03/18 17:28:37 provos Exp $");
d140 1
a140 1
	if ((g = BN_new()) == NULL) 
d258 1
a258 1
	debug3("%s: user %sauthenticated", 
d337 1
a337 1
/* 
d531 1
a531 1
		mm_send_kex(&m, *monitor->m_pkex); 
d627 1
a627 1
	
@


1.1
log
@implementation of the interface between privileged and unprivileged process
for ssh-privsep
@
text
@d28 1
a28 1
RCSID("$OpenBSD$");
d288 1
a288 1
void
d490 1
a490 1
void
d668 1
a668 1
void
@

