head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.6
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.4.0.2
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2016.05.02.08.49.03;	author djm;	state Exp;
branches;
next	1.5;
commitid	RYYIr1bk0phq4fXa;

1.5
date	2015.10.05.17.11.21;	author djm;	state Exp;
branches;
next	1.4;
commitid	97jl7RyPjvjpVUiA;

1.4
date	2015.03.24.20.03.44;	author markus;	state Exp;
branches;
next	1.3;
commitid	p8PYSpaBhqXgLzkN;

1.3
date	2015.02.05.12.59.57;	author millert;	state Exp;
branches;
next	1.2;
commitid	DTQbfd4poqBW8iSJ;

1.2
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.1;
commitid	1h9UxAQmwdaqUzyX;

1.1
date	2014.04.30.05.29.56;	author djm;	state Exp;
branches;
next	;


desc
@@


1.6
log
@fix signed/unsigned errors reported by clang-3.7; add
sshbuf_dup_string() to replace a common idiom of
strdup(sshbuf_ptr()) with better safety checking;
feedback and ok markus@@
@
text
@/*	$OpenBSD: sshbuf-misc.c,v 1.5 2015/10/05 17:11:21 djm Exp $	*/
/*
 * Copyright (c) 2011 Damien Miller
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <limits.h>
#include <string.h>
#include <resolv.h>
#include <ctype.h>

#include "ssherr.h"
#define SSHBUF_INTERNAL
#include "sshbuf.h"

void
sshbuf_dump_data(const void *s, size_t len, FILE *f)
{
	size_t i, j;
	const u_char *p = (const u_char *)s;

	for (i = 0; i < len; i += 16) {
		fprintf(f, "%.4zu: ", i);
		for (j = i; j < i + 16; j++) {
			if (j < len)
				fprintf(f, "%02x ", p[j]);
			else
				fprintf(f, "   ");
		}
		fprintf(f, " ");
		for (j = i; j < i + 16; j++) {
			if (j < len) {
				if  (isascii(p[j]) && isprint(p[j]))
					fprintf(f, "%c", p[j]);
				else
					fprintf(f, ".");
			}
		}
		fprintf(f, "\n");
	}
}

void
sshbuf_dump(struct sshbuf *buf, FILE *f)
{
	fprintf(f, "buffer %p len = %zu\n", buf, sshbuf_len(buf));
	sshbuf_dump_data(sshbuf_ptr(buf), sshbuf_len(buf), f);
}

char *
sshbuf_dtob16(struct sshbuf *buf)
{
	size_t i, j, len = sshbuf_len(buf);
	const u_char *p = sshbuf_ptr(buf);
	char *ret;
	const char hex[] = "0123456789abcdef";

	if (len == 0)
		return strdup("");
	if (SIZE_MAX / 2 <= len || (ret = malloc(len * 2 + 1)) == NULL)
		return NULL;
	for (i = j = 0; i < len; i++) {
		ret[j++] = hex[(p[i] >> 4) & 0xf];
		ret[j++] = hex[p[i] & 0xf];
	}
	ret[j] = '\0';
	return ret;
}

char *
sshbuf_dtob64(struct sshbuf *buf)
{
	size_t len = sshbuf_len(buf), plen;
	const u_char *p = sshbuf_ptr(buf);
	char *ret;
	int r;

	if (len == 0)
		return strdup("");
	plen = ((len + 2) / 3) * 4 + 1;
	if (SIZE_MAX / 2 <= len || (ret = malloc(plen)) == NULL)
		return NULL;
	if ((r = b64_ntop(p, len, ret, plen)) == -1) {
		explicit_bzero(ret, plen);
		free(ret);
		return NULL;
	}
	return ret;
}

int
sshbuf_b64tod(struct sshbuf *buf, const char *b64)
{
	size_t plen = strlen(b64);
	int nlen, r;
	u_char *p;

	if (plen == 0)
		return 0;
	if ((p = malloc(plen)) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((nlen = b64_pton(b64, p, plen)) < 0) {
		explicit_bzero(p, plen);
		free(p);
		return SSH_ERR_INVALID_FORMAT;
	}
	if ((r = sshbuf_put(buf, p, nlen)) < 0) {
		explicit_bzero(p, plen);
		free(p);
		return r;
	}
	explicit_bzero(p, plen);
	free(p);
	return 0;
}

char *
sshbuf_dup_string(struct sshbuf *buf)
{
	const u_char *p = NULL, *s = sshbuf_ptr(buf);
	size_t l = sshbuf_len(buf);
	char *r;

	if (s == NULL || l > SIZE_MAX)
		return NULL;
	/* accept a nul only as the last character in the buffer */
	if (l > 0 && (p = memchr(s, '\0', l)) != NULL) {
		if (p != s + l - 1)
			return NULL;
		l--; /* the nul is put back below */
	}
	if ((r = malloc(l + 1)) == NULL)
		return NULL;
	if (l > 0)
		memcpy(r, s, l);
	r[l] = '\0';
	return r;
}

@


1.5
log
@some more bzero->explicit_bzero, from Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: sshbuf-misc.c,v 1.4 2015/03/24 20:03:44 markus Exp $	*/
d133 23
@


1.4
log
@correct fmt-string for size_t as noted by Nicholas Lemonias; ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sshbuf-misc.c,v 1.3 2015/02/05 12:59:57 millert Exp $	*/
d102 1
a102 1
		bzero(ret, plen);
d121 1
a121 1
		bzero(p, plen);
d126 1
a126 1
		bzero(p, plen);
d130 1
a130 1
	bzero(p, plen);
@


1.3
log
@Include stdint.h, not limits.h to get SIZE_MAX.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sshbuf-misc.c,v 1.2 2014/06/24 01:13:21 djm Exp $	*/
d41 1
a41 1
		fprintf(f, "%.4zd: ", i);
@


1.2
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: sshbuf-misc.c,v 1.1 2014/04/30 05:29:56 djm Exp $	*/
d23 1
@


1.1
log
@New buffer API; the first installment of the conversion/replacement
of OpenSSH's internals to make them usable as a standalone library.

This includes a set of wrappers to make it compatible with the
existing buffer API so replacement can occur incrementally.

With and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
sshbuf_dump(struct sshbuf *buf, FILE *f)
d36 2
a37 2
	const u_char *p = sshbuf_ptr(buf);
	size_t i, j, len = sshbuf_len(buf);
a38 1
	fprintf(f, "buffer %p len = %zu\n", buf, len);
d58 7
@

