head	1.37;
access;
symbols
	OPENBSD_6_1:1.37.0.4
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.30.0.8
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.4
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.2
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.6
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.20
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.18
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.16
	OPENBSD_5_0:1.27.0.14
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.12
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.10
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.6
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.8
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.4
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.8
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.6
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.4
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.14
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.12
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.10
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.8
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.37
date	2017.03.10.04.24.55;	author djm;	state Exp;
branches;
next	1.36;
commitid	lYyv5Du16rJNkDbh;

1.36
date	2017.03.10.03.52.48;	author djm;	state Exp;
branches;
next	1.35;
commitid	fqpEJoRhMO4L9sYd;

1.35
date	2017.02.15.23.38.31;	author jsg;	state Exp;
branches;
next	1.34;
commitid	uCgROEhs2BGzlpQm;

1.34
date	2017.02.03.23.01.19;	author djm;	state Exp;
branches;
next	1.33;
commitid	0GOZFYpYrdIWnKZ0;

1.33
date	2016.11.06.05.46.37;	author djm;	state Exp;
branches;
next	1.32;
commitid	poSnZnjhu4JbUKhm;

1.32
date	2016.09.21.16.55.42;	author djm;	state Exp;
branches;
next	1.31;
commitid	V4nKx0FClx3Fk9aM;

1.31
date	2016.08.23.03.22.49;	author djm;	state Exp;
branches;
next	1.30;
commitid	GvzewXumLx5WkBbS;

1.30
date	2015.05.04.06.10.48;	author djm;	state Exp;
branches;
next	1.29;
commitid	KfZDG8r2EByk0YBR;

1.29
date	2013.11.20.20.54.10;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.10.23.06.19;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.20.18.42.26;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.02.22.00.04.44;	author stevesk;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2002.03.01.13.12.10;	author markus;	state Exp;
branches
	1.19.12.1
	1.19.14.1;
next	1.18;

1.18
date	2002.02.28.19.36.28;	author stevesk;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.11.16.21.42;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.05.16.54.51;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.27.04.48.53;	author markus;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.06.24.05.25.10;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.10.17.51.04;	author markus;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.01.21.19.05.52;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.19.23.17.57;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.07.20.27.52;	author deraadt;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.06.20.01.39.42;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.06.19.32.14;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.14.10.30.31;	author markus;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.03.23.22.15.33;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	99.11.24.19.53.48;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	99.11.24.00.26.02;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.11.23.22.25.54;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.36;	author deraadt;	state Exp;
branches;
next	;

1.6.2.1
date	2000.06.12.02.37.34;	author jason;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.09.01.18.23.20;	author jason;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2000.11.08.21.30.56;	author jason;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.03.12.15.44.12;	author jason;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.03.21.18.52.51;	author jason;	state Exp;
branches;
next	;

1.9.2.1
date	2001.02.16.20.13.06;	author jason;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.02.19.17.19.05;	author jason;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.03.21.19.46.26;	author jason;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2001.05.07.21.09.31;	author jason;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.12.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	;

1.14.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	;

1.19.12.1
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.19.14.1
date	2005.09.04.18.40.02;	author brad;	state Exp;
branches;
next	;

1.20.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.21.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.37
log
@make hostname matching really insensitive to case; bz#2685,
reported by Petr Cerny; ok dtucker@@
@
text
@/* $OpenBSD: match.c,v 1.36 2017/03/10 03:52:48 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Simple pattern matching, with '*' and '?' as wildcards.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */
/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "xmalloc.h"
#include "match.h"
#include "misc.h"

/*
 * Returns true if the given string matches the pattern (which may contain ?
 * and * as wildcards), and zero if it does not match.
 */

int
match_pattern(const char *s, const char *pattern)
{
	for (;;) {
		/* If at end of pattern, accept if also at end of string. */
		if (!*pattern)
			return !*s;

		if (*pattern == '*') {
			/* Skip the asterisk. */
			pattern++;

			/* If at end of pattern, accept immediately. */
			if (!*pattern)
				return 1;

			/* If next character in pattern is known, optimize. */
			if (*pattern != '?' && *pattern != '*') {
				/*
				 * Look instances of the next character in
				 * pattern, and try to match starting from
				 * those.
				 */
				for (; *s; s++)
					if (*s == *pattern &&
					    match_pattern(s + 1, pattern + 1))
						return 1;
				/* Failed. */
				return 0;
			}
			/*
			 * Move ahead one character at a time and try to
			 * match at each position.
			 */
			for (; *s; s++)
				if (match_pattern(s, pattern))
					return 1;
			/* Failed. */
			return 0;
		}
		/*
		 * There must be at least one more character in the string.
		 * If we are at the end, fail.
		 */
		if (!*s)
			return 0;

		/* Check if the next character of the string is acceptable. */
		if (*pattern != '?' && *pattern != *s)
			return 0;

		/* Move to the next character, both in string and in pattern. */
		s++;
		pattern++;
	}
	/* NOTREACHED */
}

/*
 * Tries to match the string against the
 * comma-separated sequence of subpatterns (each possibly preceded by ! to
 * indicate negation).  Returns -1 if negation matches, 1 if there is
 * a positive match, 0 if there is no match at all.
 */
int
match_pattern_list(const char *string, const char *pattern, int dolower)
{
	char sub[1024];
	int negated;
	int got_positive;
	u_int i, subi, len = strlen(pattern);

	got_positive = 0;
	for (i = 0; i < len;) {
		/* Check if the subpattern is negated. */
		if (pattern[i] == '!') {
			negated = 1;
			i++;
		} else
			negated = 0;

		/*
		 * Extract the subpattern up to a comma or end.  Convert the
		 * subpattern to lowercase.
		 */
		for (subi = 0;
		    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';
		    subi++, i++)
			sub[subi] = dolower && isupper((u_char)pattern[i]) ?
			    tolower((u_char)pattern[i]) : pattern[i];
		/* If subpattern too long, return failure (no match). */
		if (subi >= sizeof(sub) - 1)
			return 0;

		/* If the subpattern was terminated by a comma, then skip it. */
		if (i < len && pattern[i] == ',')
			i++;

		/* Null-terminate the subpattern. */
		sub[subi] = '\0';

		/* Try to match the subpattern against the string. */
		if (match_pattern(string, sub)) {
			if (negated)
				return -1;		/* Negative */
			else
				got_positive = 1;	/* Positive */
		}
	}

	/*
	 * Return success if got a positive match.  If there was a negative
	 * match, we have already returned -1 and never get here.
	 */
	return got_positive;
}

/*
 * Tries to match the host name (which must be in all lowercase) against the
 * comma-separated sequence of subpatterns (each possibly preceded by ! to
 * indicate negation).  Returns -1 if negation matches, 1 if there is
 * a positive match, 0 if there is no match at all.
 */
int
match_hostname(const char *host, const char *pattern)
{
	char *hostcopy = xstrdup(host);
	int r;

	lowercase(hostcopy);
	r = match_pattern_list(hostcopy, pattern, 1);
	free(hostcopy);
	return r;
}

/*
 * returns 0 if we get a negative match for the hostname or the ip
 * or if we get no match at all.  returns -1 on error, or 1 on
 * successful match.
 */
int
match_host_and_ip(const char *host, const char *ipaddr,
    const char *patterns)
{
	int mhost, mip;

	if ((mip = addr_match_list(ipaddr, patterns)) == -2)
		return -1; /* error in ipaddr match */
	else if (host == NULL || ipaddr == NULL || mip == -1)
		return 0; /* negative ip address match, or testing pattern */

	/* negative hostname match */
	if ((mhost = match_hostname(host, patterns)) == -1)
		return 0;
	/* no match at all */
	if (mhost == 0 && mip == 0)
		return 0;
	return 1;
}

/*
 * Match user, user@@host_or_ip, user@@host_or_ip_list against pattern.
 * If user, host and ipaddr are all NULL then validate pattern/
 * Returns -1 on invalid pattern, 0 on no match, 1 on match.
 */
int
match_user(const char *user, const char *host, const char *ipaddr,
    const char *pattern)
{
	char *p, *pat;
	int ret;

	/* test mode */
	if (user == NULL && host == NULL && ipaddr == NULL) {
		if ((p = strchr(pattern, '@@')) != NULL &&
		    match_host_and_ip(NULL, NULL, p + 1) < 0)
			return -1;
		return 0;
	}

	if ((p = strchr(pattern,'@@')) == NULL)
		return match_pattern(user, pattern);

	pat = xstrdup(pattern);
	p = strchr(pat, '@@');
	*p++ = '\0';

	if ((ret = match_pattern(user, pat)) == 1)
		ret = match_host_and_ip(host, ipaddr, p);
	free(pat);

	return ret;
}

/*
 * Returns first item from client-list that is also supported by server-list,
 * caller must free the returned string.
 */
#define	MAX_PROP	40
#define	SEP	","
char *
match_list(const char *client, const char *server, u_int *next)
{
	char *sproposals[MAX_PROP];
	char *c, *s, *p, *ret, *cp, *sp;
	int i, j, nproposals;

	c = cp = xstrdup(client);
	s = sp = xstrdup(server);

	for ((p = strsep(&sp, SEP)), i=0; p && *p != '\0';
	    (p = strsep(&sp, SEP)), i++) {
		if (i < MAX_PROP)
			sproposals[i] = p;
		else
			break;
	}
	nproposals = i;

	for ((p = strsep(&cp, SEP)), i=0; p && *p != '\0';
	    (p = strsep(&cp, SEP)), i++) {
		for (j = 0; j < nproposals; j++) {
			if (strcmp(p, sproposals[j]) == 0) {
				ret = xstrdup(p);
				if (next != NULL)
					*next = (cp == NULL) ?
					    strlen(c) : (u_int)(cp - c);
				free(c);
				free(s);
				return ret;
			}
		}
	}
	if (next != NULL)
		*next = strlen(c);
	free(c);
	free(s);
	return NULL;
}

/*
 * Filters a comma-separated list of strings, excluding any entry matching
 * the 'filter' pattern list. Caller must free returned string.
 */
char *
match_filter_list(const char *proposal, const char *filter)
{
	size_t len = strlen(proposal) + 1;
	char *fix_prop = malloc(len);
	char *orig_prop = strdup(proposal);
	char *cp, *tmp;

	if (fix_prop == NULL || orig_prop == NULL) {
		free(orig_prop);
		free(fix_prop);
		return NULL;
	}

	tmp = orig_prop;
	*fix_prop = '\0';
	while ((cp = strsep(&tmp, ",")) != NULL) {
		if (match_pattern_list(cp, filter, 0) != 1) {
			if (*fix_prop != '\0')
				strlcat(fix_prop, ",", len);
			strlcat(fix_prop, cp, len);
		}
	}
	free(orig_prop);
	return fix_prop;
}

@


1.36
log
@reword a comment to make it fit 80 columns
@
text
@d1 1
a1 1
/* $OpenBSD: match.c,v 1.35 2017/02/15 23:38:31 jsg Exp $ */
d43 1
d47 1
d180 7
a186 1
	return match_pattern_list(host, pattern, 1);
@


1.35
log
@Fix memory leaks in match_filter_list() error paths.

ok dtucker@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: match.c,v 1.34 2017/02/03 23:01:19 djm Exp $ */
d146 1
a146 1
		/* If the subpattern was terminated by a comma, skip the comma. */
@


1.34
log
@support =- for removing methods from algorithms lists, e.g.
Ciphers=-*cbc; suggested by Cristian Ionescu-Idbohrn in bz#2671
"I like it" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: match.c,v 1.33 2016/11/06 05:46:37 djm Exp $ */
d298 3
a300 1
	if (fix_prop == NULL || orig_prop == NULL)
d302 1
@


1.33
log
@Validate address ranges for AllowUser/DenyUsers at configuration load
time and refuse to accept bad ones. It was previously possible to
specify invalid CIDR address ranges (e.g. djm@@127.1.2.3/55) and these
would always match.

Thanks to Laurence Parry for a detailed bug report. ok markus (for
a previous diff version)
@
text
@d1 1
a1 1
/* $OpenBSD: match.c,v 1.32 2016/09/21 16:55:42 djm Exp $ */
d285 29
@


1.32
log
@Revert two recent changes to negated address matching. The new
behaviour offers unintuitive surprises. We'll find a better way
to deal with single negated matches.

match.c 1.31:
> fix matching for pattern lists that contain a single negated match,
> e.g. "Host !example"
>
> report and patch from Robin Becker. bz#1918 ok dtucker@@

addrmatch.c 1.11:
> fix negated address matching where the address list consists of a
> single negated match, e.g. "Match addr !192.20.0.1"
>
> Report and patch from Jakub Jelen. bz#2397 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: match.c,v 1.31 2016/08/23 03:22:49 djm Exp $ */
a191 1
	/* error in ipaddr match */
d193 3
a195 3
		return -1;
	else if (mip == -1) /* negative ip address match */
		return 0;
d207 3
a209 1
 * match user, user@@host_or_ip, user@@host_or_ip_list against pattern
d217 8
@


1.31
log
@fix matching for pattern lists that contain a single negated match,
e.g. "Host !example"

report and patch from Robin Becker. bz#1918 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: match.c,v 1.30 2015/05/04 06:10:48 djm Exp $ */
d159 1
a159 2
		} else if (negated)
			got_positive = 1;
@


1.30
log
@Remove pattern length argument from match_pattern_list(),
we only ever use it for strlen(pattern).

Prompted by hanno AT hboeck.de pointing an out-of-bound read
error caused by an incorrect pattern length found using AFL
and his own tools.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: match.c,v 1.29 2013/11/20 20:54:10 deraadt Exp $ */
d159 2
a160 1
		}
@


1.29
log
@unsigned casts for ctype macros where neccessary
ok guenther millert markus
@
text
@d1 1
a1 1
/* $OpenBSD: match.c,v 1.28 2013/05/17 00:13:13 djm Exp $ */
a115 1

d117 1
a117 2
match_pattern_list(const char *string, const char *pattern, u_int len,
    int dolower)
d122 1
a122 1
	u_int i, subi;
d176 1
a176 1
match_hostname(const char *host, const char *pattern, u_int len)
d178 1
a178 1
	return match_pattern_list(host, pattern, len, 1);
d199 1
a199 1
	if ((mhost = match_hostname(host, patterns, strlen(patterns))) == -1)
@


1.28
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: match.c,v 1.27 2008/06/10 23:06:19 djm Exp $ */
d142 2
a143 2
			sub[subi] = dolower && isupper(pattern[i]) ?
			    (char)tolower(pattern[i]) : pattern[i];
@


1.27
log
@support CIDR address matching in .ssh/authorized_keys from="..." stanzas

ok and extensive testing dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: match.c,v 1.26 2006/08/03 03:34:42 deraadt Exp $ */
d41 1
d228 1
a228 1
	xfree(pat);
d235 1
a235 1
 * caller must xfree() returned string.
d266 2
a267 2
				xfree(c);
				xfree(s);
d274 2
a275 2
	xfree(c);
	xfree(s);
@


1.26
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: match.c,v 1.25 2006/07/22 20:48:23 stevesk Exp $ */
d184 2
a185 1
 * or if we get no match at all.  returns 1 otherwise.
d193 4
a196 2
	/* negative ipaddr match */
	if ((mip = match_hostname(ipaddr, patterns, strlen(patterns))) == -1)
d198 1
@


1.25
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: match.c,v 1.24 2006/03/25 13:17:02 djm Exp $ */
d38 1
a38 1
#include "includes.h"
d43 1
a44 1
#include "xmalloc.h"
@


1.24
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d41 1
@


1.23
log
@be strict with tolower() casting
@
text
@d1 1
@


1.22
log
@RCSID() can die
@
text
@d140 1
a140 1
			    tolower(pattern[i]) : pattern[i];
@


1.21
log
@move #include <ctype.h> out of includes.h; ok djm@@
@
text
@a37 1
RCSID("$OpenBSD: match.c,v 1.20 2005/06/17 02:44:32 djm Exp $");
@


1.21.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: match.c,v 1.26 2006/08/03 03:34:42 deraadt Exp $ */
d37 2
a38 1
#include <sys/types.h>
a40 1
#include <string.h>
d42 1
a43 1
#include "match.h"
d141 1
a141 1
			    (char)tolower(pattern[i]) : pattern[i];
@


1.20
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d38 3
a40 1
RCSID("$OpenBSD: match.c,v 1.19 2002/03/01 13:12:10 markus Exp $");
@


1.20.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: match.c,v 1.26 2006/08/03 03:34:42 deraadt Exp $ */
d37 2
a38 4
#include <sys/types.h>

#include <ctype.h>
#include <string.h>
d40 1
a41 1
#include "match.h"
d139 1
a139 1
			    (char)tolower(pattern[i]) : pattern[i];
@


1.19
log
@undo the 'delay hostname lookup' change
match.c must not use compress.c (via canonhost.c/packet.c)
thanks to wilfried@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: match.c,v 1.17 2002/02/11 16:21:42 markus Exp $");
d257 1
a257 1
					    strlen(c) : cp - c;
@


1.19.14.1
log
@upgrade to OpenSSH 4.2
@
text
@d38 1
a38 1
RCSID("$OpenBSD: match.c,v 1.20 2005/06/17 02:44:32 djm Exp $");
d257 1
a257 1
					    strlen(c) : (u_int)(cp - c);
@


1.19.12.1
log
@upgrade to OpenSSH 4.2
@
text
@d38 1
a38 1
RCSID("$OpenBSD: match.c,v 1.20 2005/06/17 02:44:32 djm Exp $");
d257 1
a257 1
					    strlen(c) : (u_int)(cp - c);
@


1.18
log
@delay hostname lookup until we see a ``@@'' in DenyUsers and AllowUsers
for sshd -u0; ok markus@@
@
text
@a40 1
#include "canohost.h"
d205 1
a205 1
match_user(const char *user, int verify_reverse_mapping,
d219 1
a219 3
		ret = match_host_and_ip(
		    get_canonical_hostname(verify_reverse_mapping),
		    get_remote_ipaddr(), p);
@


1.17
log
@support up to 40 algorithms per proposal
@
text
@d38 1
a38 1
RCSID("$OpenBSD: match.c,v 1.16 2001/12/19 07:18:56 deraadt Exp $");
d41 1
d206 1
a206 1
match_user(const char *user, const char *host, const char *ipaddr,
d220 3
a222 1
		ret = match_host_and_ip(host, ipaddr, p);
@


1.16
log
@basic KNF done while i was looking for something else
@
text
@d38 1
a38 1
RCSID("$OpenBSD: match.c,v 1.15 2001/12/05 16:54:51 markus Exp $");
d229 1
a229 1
#define	MAX_PROP	20
@


1.15
log
@make theo and djm happy: bye bye regexp
@
text
@d38 1
a38 1
RCSID("$OpenBSD: match.c,v 1.14 2001/06/27 04:48:53 markus Exp $");
d136 2
a137 2
		     i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';
		     subi++, i++)
d139 1
a139 1
			     tolower(pattern[i]) : pattern[i];
d242 1
a242 1
	     (p = strsep(&sp, SEP)), i++) {
d251 1
a251 1
	     (p = strsep(&cp, SEP)), i++) {
@


1.14
log
@tridge@@samba.org
@
text
@d38 1
a38 1
RCSID("$OpenBSD: match.c,v 1.13 2001/06/24 05:25:10 markus Exp $");
d107 1
a107 1
 * Tries to match the host name (which must be in all lowercase) against the
d114 2
a115 1
match_hostname(const char *host, const char *pattern, u_int len)
d138 2
a139 1
			sub[subi] = isupper(pattern[i]) ? tolower(pattern[i]) : pattern[i];
d151 2
a152 2
		/* Try to match the subpattern against the host name. */
		if (match_pattern(host, sub)) {
d165 12
@


1.14.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d38 1
a38 1
RCSID("$OpenBSD: match.c,v 1.19 2002/03/01 13:12:10 markus Exp $");
d107 1
a107 1
 * Tries to match the string against the
d114 1
a114 2
match_pattern_list(const char *string, const char *pattern, u_int len,
    int dolower)
d135 3
a137 4
		    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';
		    subi++, i++)
			sub[subi] = dolower && isupper(pattern[i]) ?
			    tolower(pattern[i]) : pattern[i];
d149 2
a150 2
		/* Try to match the subpattern against the string. */
		if (match_pattern(string, sub)) {
a165 12
 * Tries to match the host name (which must be in all lowercase) against the
 * comma-separated sequence of subpatterns (each possibly preceded by ! to
 * indicate negation).  Returns -1 if negation matches, 1 if there is
 * a positive match, 0 if there is no match at all.
 */
int
match_hostname(const char *host, const char *pattern, u_int len)
{
	return match_pattern_list(host, pattern, len, 1);
}

/*
d215 1
a215 1
#define	MAX_PROP	40
d228 1
a228 1
	    (p = strsep(&sp, SEP)), i++) {
d237 1
a237 1
	    (p = strsep(&cp, SEP)), i++) {
@


1.13
log
@move ip+hostname check to match.c
@
text
@d38 1
a38 1
RCSID("$OpenBSD: match.c,v 1.12 2001/03/10 17:51:04 markus Exp $");
d185 24
@


1.12
log
@add PreferredAuthentications
@
text
@d38 1
a38 1
RCSID("$OpenBSD: match.c,v 1.11 2001/01/21 19:05:52 markus Exp $");
d165 9
d175 16
@


1.12.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d38 1
a38 1
RCSID("$OpenBSD: match.c,v 1.14 2001/06/27 04:48:53 markus Exp $");
a164 42
/*
 * returns 0 if we get a negative match for the hostname or the ip
 * or if we get no match at all.  returns 1 otherwise.
 */
int
match_host_and_ip(const char *host, const char *ipaddr,
    const char *patterns)
{
	int mhost, mip;

	/* negative ipaddr match */
	if ((mip = match_hostname(ipaddr, patterns, strlen(patterns))) == -1)
		return 0;
	/* negative hostname match */
	if ((mhost = match_hostname(host, patterns, strlen(patterns))) == -1)
		return 0;
	/* no match at all */
	if (mhost == 0 && mip == 0)
		return 0;
	return 1;
}

/*
 * match user, user@@host_or_ip, user@@host_or_ip_list against pattern
 */
int
match_user(const char *user, const char *host, const char *ipaddr,
    const char *pattern)
{
	char *p, *pat;
	int ret;

	if ((p = strchr(pattern,'@@')) == NULL)
		return match_pattern(user, pattern);

	pat = xstrdup(pattern);
	p = strchr(pat, '@@');
	*p++ = '\0';

	if ((ret = match_pattern(user, pat)) == 1)
		ret = match_host_and_ip(host, ipaddr, p);
	xfree(pat);
a165 7
	return ret;
}

/*
 * Returns first item from client-list that is also supported by server-list,
 * caller must xfree() returned string.
 */
@


1.12.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d38 1
a38 1
RCSID("$OpenBSD: match.c,v 1.19 2002/03/01 13:12:10 markus Exp $");
d107 1
a107 1
 * Tries to match the string against the
d114 1
a114 2
match_pattern_list(const char *string, const char *pattern, u_int len,
    int dolower)
d135 3
a137 4
		    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';
		    subi++, i++)
			sub[subi] = dolower && isupper(pattern[i]) ?
			    tolower(pattern[i]) : pattern[i];
d149 2
a150 2
		/* Try to match the subpattern against the string. */
		if (match_pattern(string, sub)) {
a165 12
 * Tries to match the host name (which must be in all lowercase) against the
 * comma-separated sequence of subpatterns (each possibly preceded by ! to
 * indicate negation).  Returns -1 if negation matches, 1 if there is
 * a positive match, 0 if there is no match at all.
 */
int
match_hostname(const char *host, const char *pattern, u_int len)
{
	return match_pattern_list(host, pattern, len, 1);
}

/*
d215 1
a215 1
#define	MAX_PROP	40
d228 1
a228 1
	    (p = strsep(&sp, SEP)), i++) {
d237 1
a237 1
	    (p = strsep(&cp, SEP)), i++) {
@


1.11
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d13 23
d38 1
a38 1
RCSID("$OpenBSD: match.c,v 1.10 2000/12/19 23:17:57 markus Exp $");
d41 1
d163 43
@


1.10
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: match.c,v 1.9 2000/09/07 20:27:52 deraadt Exp $");
d17 1
a17 1
#include "ssh.h"
@


1.9
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: match.c,v 1.8 2000/06/20 01:39:42 markus Exp $");
d90 1
a90 1
match_hostname(const char *host, const char *pattern, unsigned int len)
d95 1
a95 1
	unsigned int i, subi;
@


1.9.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: match.c,v 1.11 2001/01/21 19:05:52 markus Exp $");
d17 1
a17 1
#include "match.h"
d90 1
a90 1
match_hostname(const char *host, const char *pattern, u_int len)
d95 1
a95 1
	u_int i, subi;
@


1.9.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.9.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@a12 23
/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
d15 1
a15 1
RCSID("$OpenBSD: match.c,v 1.12 2001/03/10 17:51:04 markus Exp $");
a17 1
#include "xmalloc.h"
a138 43
}


#define	MAX_PROP	20
#define	SEP	","
char *
match_list(const char *client, const char *server, u_int *next)
{
	char *sproposals[MAX_PROP];
	char *c, *s, *p, *ret, *cp, *sp;
	int i, j, nproposals;

	c = cp = xstrdup(client);
	s = sp = xstrdup(server);

	for ((p = strsep(&sp, SEP)), i=0; p && *p != '\0';
	     (p = strsep(&sp, SEP)), i++) {
		if (i < MAX_PROP)
			sproposals[i] = p;
		else
			break;
	}
	nproposals = i;

	for ((p = strsep(&cp, SEP)), i=0; p && *p != '\0';
	     (p = strsep(&cp, SEP)), i++) {
		for (j = 0; j < nproposals; j++) {
			if (strcmp(p, sproposals[j]) == 0) {
				ret = xstrdup(p);
				if (next != NULL)
					*next = (cp == NULL) ?
					    strlen(c) : cp - c;
				xfree(c);
				xfree(s);
				return ret;
			}
		}
	}
	if (next != NULL)
		*next = strlen(c);
	xfree(c);
	xfree(s);
	return NULL;
@


1.9.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.9.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: match.c,v 1.14 2001/06/27 04:48:53 markus Exp $");
a164 42
/*
 * returns 0 if we get a negative match for the hostname or the ip
 * or if we get no match at all.  returns 1 otherwise.
 */
int
match_host_and_ip(const char *host, const char *ipaddr,
    const char *patterns)
{
	int mhost, mip;

	/* negative ipaddr match */
	if ((mip = match_hostname(ipaddr, patterns, strlen(patterns))) == -1)
		return 0;
	/* negative hostname match */
	if ((mhost = match_hostname(host, patterns, strlen(patterns))) == -1)
		return 0;
	/* no match at all */
	if (mhost == 0 && mip == 0)
		return 0;
	return 1;
}

/*
 * match user, user@@host_or_ip, user@@host_or_ip_list against pattern
 */
int
match_user(const char *user, const char *host, const char *ipaddr,
    const char *pattern)
{
	char *p, *pat;
	int ret;

	if ((p = strchr(pattern,'@@')) == NULL)
		return match_pattern(user, pattern);

	pat = xstrdup(pattern);
	p = strchr(pat, '@@');
	*p++ = '\0';

	if ((ret = match_pattern(user, pat)) == 1)
		ret = match_host_and_ip(host, ipaddr, p);
	xfree(pat);
a165 7
	return ret;
}

/*
 * Returns first item from client-list that is also supported by server-list,
 * caller must xfree() returned string.
 */
@


1.9.2.6
log
@Merge OpenSSH 3.1.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: match.c,v 1.19 2002/03/01 13:12:10 markus Exp $");
d107 1
a107 1
 * Tries to match the string against the
d114 1
a114 2
match_pattern_list(const char *string, const char *pattern, u_int len,
    int dolower)
d135 3
a137 4
		    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';
		    subi++, i++)
			sub[subi] = dolower && isupper(pattern[i]) ?
			    tolower(pattern[i]) : pattern[i];
d149 2
a150 2
		/* Try to match the subpattern against the string. */
		if (match_pattern(string, sub)) {
a165 12
 * Tries to match the host name (which must be in all lowercase) against the
 * comma-separated sequence of subpatterns (each possibly preceded by ! to
 * indicate negation).  Returns -1 if negation matches, 1 if there is
 * a positive match, 0 if there is no match at all.
 */
int
match_hostname(const char *host, const char *pattern, u_int len)
{
	return match_pattern_list(host, pattern, len, 1);
}

/*
d215 1
a215 1
#define	MAX_PROP	40
d228 1
a228 1
	    (p = strsep(&sp, SEP)), i++) {
d237 1
a237 1
	    (p = strsep(&cp, SEP)), i++) {
@


1.8
log
@OpenBSD tag
@
text
@a1 3
 *
 * match.c
 *
a2 1
 *
a4 3
 *
 * Created: Thu Jun 22 01:17:50 1995 ylo
 *
d7 5
d15 1
a15 1
RCSID("$OpenBSD: match.c,v 1.7 2000/06/06 19:32:14 markus Exp $");
@


1.7
log
@fix match_hostname() logic for auth-rsa: deny access if we have a negative match or no match at all
@
text
@d17 1
a17 1
RCSID("$Id: match.c,v 1.6 2000/04/14 10:30:31 markus Exp $");
@


1.6
log
@whitespace cleanup
@
text
@d17 1
a17 1
RCSID("$Id: match.c,v 1.5 2000/03/23 22:15:33 markus Exp $");
d87 2
a88 2
 * indicate negation).  Returns true if there is a positive match; zero
 * otherwise.
d130 1
a130 1
				return 0;	/* Fail */
d132 1
a132 1
				got_positive = 1;
d138 1
a138 1
	 * match, we have already returned zero and never get here.
@


1.6.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d17 1
a17 1
RCSID("$Id: match.c,v 1.7 2000/06/06 19:32:14 markus Exp $");
d87 2
a88 2
 * indicate negation).  Returns -1 if negation matches, 1 if there is
 * a positive match, 0 if there is no match at all.
d130 1
a130 1
				return -1;		/* Negative */
d132 1
a132 1
				got_positive = 1;	/* Positive */
d138 1
a138 1
	 * match, we have already returned -1 and never get here.
@


1.6.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d17 1
a17 1
RCSID("$OpenBSD: match.c,v 1.8 2000/06/20 01:39:42 markus Exp $");
@


1.6.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a13 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d17 1
a17 1
RCSID("$OpenBSD: match.c,v 1.9 2000/09/07 20:27:52 deraadt Exp $");
@


1.6.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d15 1
a15 1
RCSID("$OpenBSD: match.c,v 1.11 2001/01/21 19:05:52 markus Exp $");
d17 1
a17 1
#include "match.h"
d90 1
a90 1
match_hostname(const char *host, const char *pattern, u_int len)
d95 1
a95 1
	u_int i, subi;
@


1.6.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@a12 23
/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
d15 1
a15 1
RCSID("$OpenBSD: match.c,v 1.12 2001/03/10 17:51:04 markus Exp $");
a17 1
#include "xmalloc.h"
a138 43
}


#define	MAX_PROP	20
#define	SEP	","
char *
match_list(const char *client, const char *server, u_int *next)
{
	char *sproposals[MAX_PROP];
	char *c, *s, *p, *ret, *cp, *sp;
	int i, j, nproposals;

	c = cp = xstrdup(client);
	s = sp = xstrdup(server);

	for ((p = strsep(&sp, SEP)), i=0; p && *p != '\0';
	     (p = strsep(&sp, SEP)), i++) {
		if (i < MAX_PROP)
			sproposals[i] = p;
		else
			break;
	}
	nproposals = i;

	for ((p = strsep(&cp, SEP)), i=0; p && *p != '\0';
	     (p = strsep(&cp, SEP)), i++) {
		for (j = 0; j < nproposals; j++) {
			if (strcmp(p, sproposals[j]) == 0) {
				ret = xstrdup(p);
				if (next != NULL)
					*next = (cp == NULL) ?
					    strlen(c) : cp - c;
				xfree(c);
				xfree(s);
				return ret;
			}
		}
	}
	if (next != NULL)
		*next = strlen(c);
	xfree(c);
	xfree(s);
	return NULL;
@


1.5
log
@initial support for DSA keys. ok deraadt@@, niels@@
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
RCSID("$Id: match.c,v 1.2 2000/02/07 19:12:54 markus Exp $");
d26 1
a26 1
int 
@


1.4
log
@KNF, final part 3
@
text
@d17 1
a17 1
RCSID("$Id: match.c,v 1.3 1999/11/24 00:26:02 deraadt Exp $");
d82 59
@


1.3
log
@much more KNF
@
text
@d17 1
a17 1
RCSID("$Id: match.c,v 1.2 1999/11/23 22:25:54 markus Exp $");
d21 4
a24 2
/* Returns true if the given string matches the pattern (which may contain
   ? and * as wildcards), and zero if it does not match. */
a33 1
		/* Process '*'. */
d44 5
a48 3
				/* Look instances of the next character in
				   pattern, and try to match starting from
				   those. */
d56 4
a59 2
			/* Move ahead one character at a time and try to
			   match at each position. */
d66 4
a69 2
		/* There must be at least one more character in the
		   string.  If we are at the end, fail. */
d73 1
a73 2
		/* Check if the next character of the string is
		   acceptable. */
d77 1
a77 2
		/* Move to the next character, both in string and in
		   pattern. */
@


1.2
log
@KNF part 1
@
text
@d2 13
a14 13

match.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Thu Jun 22 01:17:50 1995 ylo

Simple pattern matching, with '*' and '?' as wildcards.

*/
d17 1
a17 1
RCSID("$Id: match.c,v 1.1 1999/09/26 20:53:36 deraadt Exp $");
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d17 1
a17 1
RCSID("$Id: match.c,v 1.2 1999/05/04 11:58:50 bg Exp $");
d23 3
a25 2
	  
int match_pattern(const char *s, const char *pattern)
d27 50
a76 52
  while (1)
    {
      /* If at end of pattern, accept if also at end of string. */
      if (!*pattern)
        return !*s;

      /* Process '*'. */
      if (*pattern == '*')
        {
	  /* Skip the asterisk. */
	  pattern++;

	  /* If at end of pattern, accept immediately. */
          if (!*pattern)
            return 1;

	  /* If next character in pattern is known, optimize. */
          if (*pattern != '?' && *pattern != '*')
            {
	      /* Look instances of the next character in pattern, and try
		 to match starting from those. */
              for (; *s; s++)
                if (*s == *pattern &&
                    match_pattern(s + 1, pattern + 1))
                  return 1;
	      /* Failed. */
              return 0;
            }

	  /* Move ahead one character at a time and try to match at each
	     position. */
          for (; *s; s++)
            if (match_pattern(s, pattern))
              return 1;
	  /* Failed. */
          return 0;
        }

      /* There must be at least one more character in the string.  If we are
	 at the end, fail. */
      if (!*s)
        return 0;

      /* Check if the next character of the string is acceptable. */
      if (*pattern != '?' && *pattern != *s)
	return 0;
      
      /* Move to the next character, both in string and in pattern. */
      s++;
      pattern++;
    }
  /*NOTREACHED*/
@

