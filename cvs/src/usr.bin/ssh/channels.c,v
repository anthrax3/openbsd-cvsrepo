head	1.375;
access;
symbols
	OPENBSD_6_2:1.375.0.2
	OPENBSD_6_2_BASE:1.375
	OPENBSD_6_1:1.357.0.4
	OPENBSD_6_1_BASE:1.357
	OPENBSD_6_0:1.351.0.4
	OPENBSD_6_0_BASE:1.351
	OPENBSD_5_9:1.349.0.2
	OPENBSD_5_9_BASE:1.349
	OPENBSD_5_8:1.347.0.2
	OPENBSD_5_8_BASE:1.347
	OPENBSD_5_7:1.341.0.2
	OPENBSD_5_7_BASE:1.341
	OPENBSD_5_6:1.336.0.4
	OPENBSD_5_6_BASE:1.336
	OPENBSD_5_5:1.331.0.4
	OPENBSD_5_5_BASE:1.331
	OPENBSD_5_4:1.324.0.2
	OPENBSD_5_4_BASE:1.324
	OPENBSD_5_3:1.319.0.2
	OPENBSD_5_3_BASE:1.319
	OPENBSD_5_2:1.318.0.2
	OPENBSD_5_2_BASE:1.318
	OPENBSD_5_1_BASE:1.315
	OPENBSD_5_1:1.315.0.2
	OPENBSD_5_0:1.311.0.2
	OPENBSD_5_0_BASE:1.311
	OPENBSD_4_9:1.310.0.2
	OPENBSD_4_9_BASE:1.310
	OPENBSD_4_8:1.309.0.2
	OPENBSD_4_8_BASE:1.309
	OPENBSD_4_7:1.303.0.2
	OPENBSD_4_7_BASE:1.303
	OPENBSD_4_6:1.296.0.4
	OPENBSD_4_6_BASE:1.296
	OPENBSD_4_5:1.295.0.2
	OPENBSD_4_5_BASE:1.295
	OPENBSD_4_4:1.286.0.2
	OPENBSD_4_4_BASE:1.286
	OPENBSD_4_3:1.272.0.2
	OPENBSD_4_3_BASE:1.272
	OPENBSD_4_2:1.270.0.2
	OPENBSD_4_2_BASE:1.270
	OPENBSD_4_1:1.268.0.2
	OPENBSD_4_1_BASE:1.268
	OPENBSD_4_0:1.266.0.4
	OPENBSD_4_0_BASE:1.266
	OPENBSD_3_9:1.235.0.2
	OPENBSD_3_9_BASE:1.235
	OPENBSD_3_8:1.223.0.2
	OPENBSD_3_8_BASE:1.223
	OPENBSD_3_7:1.214.0.2
	OPENBSD_3_7_BASE:1.214
	OPENBSD_3_6:1.210.0.2
	OPENBSD_3_6_BASE:1.210
	OPENBSD_3_5:1.200.0.2
	OPENBSD_3_5_BASE:1.200
	OPENBSD_3_4:1.195.0.2
	OPENBSD_3_4_BASE:1.195
	OPENBSD_3_3:1.187.0.2
	OPENBSD_3_3_BASE:1.187
	OPENBSD_3_2:1.183.0.2
	OPENBSD_3_2_BASE:1.183
	OPENBSD_3_1:1.172.0.2
	OPENBSD_3_1_BASE:1.172
	OPENBSD_3_0:1.140.0.2
	OPENBSD_3_0_BASE:1.140
	OPENBSD_2_9_BASE:1.109
	OPENBSD_2_9:1.109.0.2
	OPENBSD_2_8:1.72.0.2
	OPENBSD_2_8_BASE:1.72
	OPENBSD_2_7:1.57.0.2
	OPENBSD_2_7_BASE:1.57
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16;
locks; strict;
comment	@ * @;


1.375
date	2017.09.24.13.45.34;	author djm;	state Exp;
branches;
next	1.374;
commitid	Nql0DPC7dzTdhRKO;

1.374
date	2017.09.24.09.50.01;	author djm;	state Exp;
branches;
next	1.373;
commitid	q9A9PUkLnznh4vNr;

1.373
date	2017.09.23.22.04.07;	author djm;	state Exp;
branches;
next	1.372;
commitid	2n1gLfcvroMktFBv;

1.372
date	2017.09.21.19.16.53;	author markus;	state Exp;
branches;
next	1.371;
commitid	trdBaE0Ug2XpXLIx;

1.371
date	2017.09.19.12.10.30;	author millert;	state Exp;
branches;
next	1.370;
commitid	WtGwMy1Fkc1suVqN;

1.370
date	2017.09.12.07.55.48;	author djm;	state Exp;
branches;
next	1.369;
commitid	OB4OI2rnBGrG1n5l;

1.369
date	2017.09.12.07.32.04;	author djm;	state Exp;
branches;
next	1.368;
commitid	sUUgRFylTBLbCWA5;

1.368
date	2017.09.12.06.35.31;	author djm;	state Exp;
branches;
next	1.367;
commitid	dCi8XAU8Wl0yr6jz;

1.367
date	2017.09.12.06.32.07;	author djm;	state Exp;
branches;
next	1.366;
commitid	Amj5uk8F1JrQpmI5;

1.366
date	2017.08.30.03.59.08;	author djm;	state Exp;
branches;
next	1.365;
commitid	y3aRFk7WWt6orSgY;

1.365
date	2017.05.31.08.58.52;	author deraadt;	state Exp;
branches;
next	1.364;
commitid	MC62PdxBV8J69NxR;

1.364
date	2017.05.31.00.43.04;	author djm;	state Exp;
branches;
next	1.363;
commitid	leJDJmq6y3Yym73c;

1.363
date	2017.05.30.14.23.52;	author markus;	state Exp;
branches;
next	1.362;
commitid	tEOGxoM4kvBMLD6J;

1.362
date	2017.05.30.08.49.58;	author markus;	state Exp;
branches;
next	1.361;
commitid	fNW8t9IZCtjp7ovj;

1.361
date	2017.05.26.19.35.50;	author markus;	state Exp;
branches;
next	1.360;
commitid	FJuDC2xBxXzmleXf;

1.360
date	2017.05.26.19.34.12;	author markus;	state Exp;
branches;
next	1.359;
commitid	f3BVDuNkonQJrWkO;

1.359
date	2017.04.30.23.28.41;	author djm;	state Exp;
branches;
next	1.358;
commitid	mCEJ1LTymp03ZrA9;

1.358
date	2017.04.30.23.13.25;	author djm;	state Exp;
branches;
next	1.357;
commitid	Ss7V57MvgEZubdtr;

1.357
date	2017.02.01.02.59.09;	author dtucker;	state Exp;
branches;
next	1.356;
commitid	e2JoLM95qcfyR1rz;

1.356
date	2016.10.18.17.32.54;	author dtucker;	state Exp;
branches;
next	1.355;
commitid	JggzBelUQQppwx9c;

1.355
date	2016.09.30.20.24.46;	author djm;	state Exp;
branches;
next	1.354;
commitid	aC7qYr3wJiS3LvIs;

1.354
date	2016.09.30.09.19.13;	author markus;	state Exp;
branches;
next	1.353;
commitid	VHQRRel9yTEUINVH;

1.353
date	2016.09.19.07.52.42;	author natano;	state Exp;
branches;
next	1.352;
commitid	hCnkOvi95f37XsAS;

1.352
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.351;
commitid	ZllbGwdb0fOmLhjK;

1.351
date	2016.07.19.11.38.53;	author dtucker;	state Exp;
branches;
next	1.350;
commitid	irR1fmaEKVFxN0Xr;

1.350
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.349;
commitid	kr9hjdmg99uVnhW2;

1.349
date	2016.02.05.13.28.19;	author naddy;	state Exp;
branches;
next	1.348;
commitid	wnYEQEpanijcUuwK;

1.348
date	2015.10.15.23.51.40;	author djm;	state Exp;
branches;
next	1.347;
commitid	Zt9fWcnXm9hrhBex;

1.347
date	2015.07.01.02.26.31;	author djm;	state Exp;
branches;
next	1.346;
commitid	qLSneKZZQQvEyM5i;

1.346
date	2015.06.30.05.25.07;	author djm;	state Exp;
branches;
next	1.345;
commitid	AWocFF4YDu4r4jE3;

1.345
date	2015.06.30.05.23.25;	author djm;	state Exp;
branches;
next	1.344;
commitid	sjHbytnwDXhNlyNM;

1.344
date	2015.06.05.15.13.13;	author millert;	state Exp;
branches;
next	1.343;
commitid	0NclEIC5no7MeTYR;

1.343
date	2015.05.08.03.25.07;	author dtucker;	state Exp;
branches;
next	1.342;
commitid	H7HNKklhMuF2D3fN;

1.342
date	2015.04.24.01.36.00;	author deraadt;	state Exp;
branches;
next	1.341;
commitid	LHkUmZjv49ojnnuH;

1.341
date	2015.02.06.23.21.59;	author millert;	state Exp;
branches;
next	1.340;
commitid	STdsVrA5MGLlnbLm;

1.340
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.339;
commitid	cBx23BaCk6gYBpRj;

1.339
date	2015.01.19.20.07.45;	author markus;	state Exp;
branches;
next	1.338;
commitid	GrtSC5ve2VERgUln;

1.338
date	2014.12.11.08.20.09;	author djm;	state Exp;
branches;
next	1.337;
commitid	UtK7Mx4xawqsfx0b;

1.337
date	2014.10.08.22.15.06;	author djm;	state Exp;
branches;
next	1.336;
commitid	t4miGDttZW8e2mPO;

1.336
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.335;
commitid	z7plx8Gkj6l2sxem;

1.335
date	2014.07.05.23.11.48;	author djm;	state Exp;
branches;
next	1.334;
commitid	AwBUeNivPD1XnBgv;

1.334
date	2014.07.03.22.33.41;	author djm;	state Exp;
branches;
next	1.333;
commitid	xcCXA8OL6k2cNgez;

1.333
date	2014.06.27.16.41.56;	author markus;	state Exp;
branches;
next	1.332;
commitid	npS0wYoZKjQDRx0P;

1.332
date	2014.04.28.03.09.18;	author djm;	state Exp;
branches;
next	1.331;

1.331
date	2014.02.26.20.29.29;	author djm;	state Exp;
branches;
next	1.330;

1.330
date	2014.02.15.23.05.36;	author djm;	state Exp;
branches;
next	1.329;

1.329
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.328;

1.328
date	2013.12.19.01.04.36;	author djm;	state Exp;
branches;
next	1.327;

1.327
date	2013.11.08.00.39.15;	author djm;	state Exp;
branches;
next	1.326;

1.326
date	2013.09.19.01.24.46;	author djm;	state Exp;
branches;
next	1.325;

1.325
date	2013.09.13.06.54.34;	author djm;	state Exp;
branches;
next	1.324;

1.324
date	2013.07.12.00.19.58;	author djm;	state Exp;
branches
	1.324.2.1;
next	1.323;

1.323
date	2013.06.07.15.37.52;	author dtucker;	state Exp;
branches;
next	1.322;

1.322
date	2013.06.01.13.15.51;	author dtucker;	state Exp;
branches;
next	1.321;

1.321
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.320;

1.320
date	2013.04.06.16.07.00;	author markus;	state Exp;
branches;
next	1.319;

1.319
date	2012.12.02.20.46.11;	author djm;	state Exp;
branches
	1.319.2.1;
next	1.318;

1.318
date	2012.04.23.08.18.17;	author djm;	state Exp;
branches;
next	1.317;

1.317
date	2012.04.11.13.16.19;	author djm;	state Exp;
branches;
next	1.316;

1.316
date	2012.03.29.23.54.36;	author dtucker;	state Exp;
branches;
next	1.315;

1.315
date	2011.09.23.07.45.05;	author markus;	state Exp;
branches;
next	1.314;

1.314
date	2011.09.23.00.22.04;	author dtucker;	state Exp;
branches;
next	1.313;

1.313
date	2011.09.10.22.26.34;	author markus;	state Exp;
branches;
next	1.312;

1.312
date	2011.09.09.22.46.44;	author djm;	state Exp;
branches;
next	1.311;

1.311
date	2011.06.22.22.08.42;	author djm;	state Exp;
branches;
next	1.310;

1.310
date	2010.11.24.01.24.14;	author djm;	state Exp;
branches;
next	1.309;

1.309
date	2010.08.05.13.08.42;	author djm;	state Exp;
branches;
next	1.308;

1.308
date	2010.07.13.23.13.16;	author djm;	state Exp;
branches;
next	1.307;

1.307
date	2010.07.13.11.52.06;	author djm;	state Exp;
branches;
next	1.306;

1.306
date	2010.06.25.07.20.04;	author djm;	state Exp;
branches;
next	1.305;

1.305
date	2010.06.25.07.14.45;	author djm;	state Exp;
branches;
next	1.304;

1.304
date	2010.05.14.23.29.23;	author djm;	state Exp;
branches;
next	1.303;

1.303
date	2010.01.30.21.12.08;	author djm;	state Exp;
branches;
next	1.302;

1.302
date	2010.01.26.01.28.35;	author djm;	state Exp;
branches;
next	1.301;

1.301
date	2010.01.11.01.39.46;	author dtucker;	state Exp;
branches;
next	1.300;

1.300
date	2010.01.09.23.04.13;	author dtucker;	state Exp;
branches;
next	1.299;

1.299
date	2009.11.11.21.37.03;	author markus;	state Exp;
branches;
next	1.298;

1.298
date	2009.11.10.04.30.44;	author dtucker;	state Exp;
branches;
next	1.297;

1.297
date	2009.10.28.16.38.18;	author reyk;	state Exp;
branches;
next	1.296;

1.296
date	2009.05.25.06.48.00;	author andreas;	state Exp;
branches;
next	1.295;

1.295
date	2009.02.12.03.00.56;	author djm;	state Exp;
branches;
next	1.294;

1.294
date	2009.01.22.09.49.57;	author djm;	state Exp;
branches;
next	1.293;

1.293
date	2009.01.22.09.46.01;	author djm;	state Exp;
branches;
next	1.292;

1.292
date	2009.01.14.01.38.06;	author djm;	state Exp;
branches;
next	1.291;

1.291
date	2009.01.01.21.14.35;	author djm;	state Exp;
branches;
next	1.290;

1.290
date	2008.12.09.03.20.42;	author stevesk;	state Exp;
branches;
next	1.289;

1.289
date	2008.12.02.19.09.38;	author markus;	state Exp;
branches;
next	1.288;

1.288
date	2008.11.11.03.55.11;	author stevesk;	state Exp;
branches;
next	1.287;

1.287
date	2008.11.01.06.43.33;	author stevesk;	state Exp;
branches;
next	1.286;

1.286
date	2008.07.16.11.52.19;	author djm;	state Exp;
branches;
next	1.285;

1.285
date	2008.07.13.22.13.07;	author djm;	state Exp;
branches;
next	1.284;

1.284
date	2008.07.12.04.52.50;	author djm;	state Exp;
branches;
next	1.283;

1.283
date	2008.07.10.18.05.58;	author markus;	state Exp;
branches;
next	1.282;

1.282
date	2008.06.16.13.22.53;	author dtucker;	state Exp;
branches;
next	1.281;

1.281
date	2008.06.15.20.06.26;	author djm;	state Exp;
branches;
next	1.280;

1.280
date	2008.06.12.15.19.17;	author djm;	state Exp;
branches;
next	1.279;

1.279
date	2008.06.12.03.40.52;	author djm;	state Exp;
branches;
next	1.278;

1.278
date	2008.06.10.04.50.25;	author dtucker;	state Exp;
branches;
next	1.277;

1.277
date	2008.05.09.16.17.51;	author markus;	state Exp;
branches;
next	1.276;

1.276
date	2008.05.09.04.55.56;	author djm;	state Exp;
branches;
next	1.275;

1.275
date	2008.05.08.12.02.23;	author djm;	state Exp;
branches;
next	1.274;

1.274
date	2008.05.08.06.59.01;	author markus;	state Exp;
branches;
next	1.273;

1.273
date	2008.04.02.21.36.51;	author markus;	state Exp;
branches;
next	1.272;

1.272
date	2008.01.19.23.02.40;	author djm;	state Exp;
branches
	1.272.2.1;
next	1.271;

1.271
date	2007.12.27.14.22.08;	author dtucker;	state Exp;
branches;
next	1.270;

1.270
date	2007.06.25.08.20.03;	author dtucker;	state Exp;
branches
	1.270.2.1;
next	1.269;

1.269
date	2007.06.11.08.04.44;	author markus;	state Exp;
branches;
next	1.268;

1.268
date	2007.01.03.03.01.40;	author stevesk;	state Exp;
branches
	1.268.2.1;
next	1.267;

1.267
date	2006.12.12.03.58.42;	author djm;	state Exp;
branches;
next	1.266;

1.266
date	2006.08.29.10.40.18;	author djm;	state Exp;
branches;
next	1.265;

1.265
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.264;

1.264
date	2006.08.01.23.36.11;	author stevesk;	state Exp;
branches;
next	1.263;

1.263
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.262;

1.262
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.261;

1.261
date	2006.07.25.02.59.21;	author stevesk;	state Exp;
branches;
next	1.260;

1.260
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.259;

1.259
date	2006.07.21.21.13.30;	author stevesk;	state Exp;
branches;
next	1.258;

1.258
date	2006.07.21.12.43.36;	author dtucker;	state Exp;
branches;
next	1.257;

1.257
date	2006.07.17.12.06.00;	author dtucker;	state Exp;
branches;
next	1.256;

1.256
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.255;

1.255
date	2006.07.12.22.28.51;	author stevesk;	state Exp;
branches;
next	1.254;

1.254
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.253;

1.253
date	2006.07.11.18.50.47;	author markus;	state Exp;
branches;
next	1.252;

1.252
date	2006.07.10.12.08.08;	author djm;	state Exp;
branches;
next	1.251;

1.251
date	2006.07.03.17.59.32;	author stevesk;	state Exp;
branches;
next	1.250;

1.250
date	2006.04.16.00.48.52;	author djm;	state Exp;
branches;
next	1.249;

1.249
date	2006.03.30.09.41.25;	author djm;	state Exp;
branches;
next	1.248;

1.248
date	2006.03.28.01.52.28;	author deraadt;	state Exp;
branches;
next	1.247;

1.247
date	2006.03.25.18.58.10;	author deraadt;	state Exp;
branches;
next	1.246;

1.246
date	2006.03.25.18.56.54;	author deraadt;	state Exp;
branches;
next	1.245;

1.245
date	2006.03.25.18.43.30;	author deraadt;	state Exp;
branches;
next	1.244;

1.244
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.243;

1.243
date	2006.03.25.01.13.23;	author djm;	state Exp;
branches;
next	1.242;

1.242
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.241;

1.241
date	2006.03.20.18.48.34;	author deraadt;	state Exp;
branches;
next	1.240;

1.240
date	2006.03.20.18.35.12;	author deraadt;	state Exp;
branches;
next	1.239;

1.239
date	2006.03.20.18.26.55;	author deraadt;	state Exp;
branches;
next	1.238;

1.238
date	2006.03.20.18.14.02;	author deraadt;	state Exp;
branches;
next	1.237;

1.237
date	2006.03.19.18.52.11;	author deraadt;	state Exp;
branches;
next	1.236;

1.236
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.235;

1.235
date	2006.02.20.16.36.14;	author stevesk;	state Exp;
branches
	1.235.2.1;
next	1.234;

1.234
date	2006.02.10.00.27.13;	author stevesk;	state Exp;
branches;
next	1.233;

1.233
date	2006.02.07.01.42.00;	author stevesk;	state Exp;
branches;
next	1.232;

1.232
date	2006.01.30.12.22.22;	author reyk;	state Exp;
branches;
next	1.231;

1.231
date	2005.12.30.15.56.36;	author reyk;	state Exp;
branches;
next	1.230;

1.230
date	2005.12.28.22.46.06;	author stevesk;	state Exp;
branches;
next	1.229;

1.229
date	2005.12.12.13.46.18;	author markus;	state Exp;
branches;
next	1.228;

1.228
date	2005.12.06.22.38.27;	author reyk;	state Exp;
branches;
next	1.227;

1.227
date	2005.10.14.02.29.37;	author stevesk;	state Exp;
branches;
next	1.226;

1.226
date	2005.10.11.23.37.37;	author djm;	state Exp;
branches;
next	1.225;

1.225
date	2005.10.10.10.23.08;	author djm;	state Exp;
branches;
next	1.224;

1.224
date	2005.09.07.08.53.53;	author markus;	state Exp;
branches;
next	1.223;

1.223
date	2005.07.17.07.17.54;	author djm;	state Exp;
branches
	1.223.2.1;
next	1.222;

1.222
date	2005.07.17.06.49.04;	author djm;	state Exp;
branches;
next	1.221;

1.221
date	2005.07.16.01.35.24;	author djm;	state Exp;
branches;
next	1.220;

1.220
date	2005.07.04.14.04.11;	author markus;	state Exp;
branches;
next	1.219;

1.219
date	2005.07.04.00.58.42;	author djm;	state Exp;
branches;
next	1.218;

1.218
date	2005.07.01.13.19.47;	author markus;	state Exp;
branches;
next	1.217;

1.217
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches;
next	1.216;

1.216
date	2005.06.16.08.00.00;	author markus;	state Exp;
branches;
next	1.215;

1.215
date	2005.06.16.03.38.36;	author djm;	state Exp;
branches;
next	1.214;

1.214
date	2005.03.14.11.46.56;	author markus;	state Exp;
branches
	1.214.2.1;
next	1.213;

1.213
date	2005.03.10.22.01.05;	author deraadt;	state Exp;
branches;
next	1.212;

1.212
date	2005.03.01.10.09.52;	author djm;	state Exp;
branches;
next	1.211;

1.211
date	2004.10.29.21.47.15;	author djm;	state Exp;
branches;
next	1.210;

1.210
date	2004.08.23.11.48.47;	author djm;	state Exp;
branches
	1.210.2.1;
next	1.209;

1.209
date	2004.08.11.21.43.04;	author avsm;	state Exp;
branches;
next	1.208;

1.208
date	2004.07.11.17.48.47;	author deraadt;	state Exp;
branches;
next	1.207;

1.207
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches;
next	1.206;

1.206
date	2004.06.18.11.11.54;	author djm;	state Exp;
branches;
next	1.205;

1.205
date	2004.06.14.01.44.38;	author djm;	state Exp;
branches;
next	1.204;

1.204
date	2004.06.13.15.03.02;	author djm;	state Exp;
branches;
next	1.203;

1.203
date	2004.05.26.23.02.39;	author markus;	state Exp;
branches;
next	1.202;

1.202
date	2004.05.21.11.33.11;	author djm;	state Exp;
branches;
next	1.201;

1.201
date	2004.05.11.19.01.43;	author deraadt;	state Exp;
branches;
next	1.200;

1.200
date	2004.01.19.09.24.21;	author markus;	state Exp;
branches
	1.200.2.1;
next	1.199;

1.199
date	2003.12.02.17.01.14;	author markus;	state Exp;
branches;
next	1.198;

1.198
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches;
next	1.197;

1.197
date	2003.09.23.20.41.11;	author markus;	state Exp;
branches;
next	1.196;

1.196
date	2003.09.19.11.31.33;	author markus;	state Exp;
branches;
next	1.195;

1.195
date	2003.09.16.21.02.40;	author markus;	state Exp;
branches
	1.195.2.1;
next	1.194;

1.194
date	2003.08.29.10.04.36;	author markus;	state Exp;
branches;
next	1.193;

1.193
date	2003.07.02.14.51.16;	author markus;	state Exp;
branches;
next	1.192;

1.192
date	2003.07.02.12.56.34;	author markus;	state Exp;
branches;
next	1.191;

1.191
date	2003.06.24.08.23.46;	author markus;	state Exp;
branches;
next	1.190;

1.190
date	2003.05.11.20.30.24;	author markus;	state Exp;
branches;
next	1.189;

1.189
date	2003.04.14.14.17.50;	author markus;	state Exp;
branches;
next	1.188;

1.188
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches;
next	1.187;

1.187
date	2003.03.05.22.33.43;	author markus;	state Exp;
branches
	1.187.2.1;
next	1.186;

1.186
date	2003.01.10.10.32.54;	author djm;	state Exp;
branches;
next	1.185;

1.185
date	2003.01.01.18.08.52;	author markus;	state Exp;
branches;
next	1.184;

1.184
date	2002.12.13.10.03.15;	author markus;	state Exp;
branches;
next	1.183;

1.183
date	2002.09.17.07.47.02;	author itojun;	state Exp;
branches
	1.183.2.1;
next	1.182;

1.182
date	2002.09.13.19.23.09;	author stevesk;	state Exp;
branches;
next	1.181;

1.181
date	2002.09.09.14.54.14;	author markus;	state Exp;
branches;
next	1.180;

1.180
date	2002.07.04.08.12.15;	author deraadt;	state Exp;
branches;
next	1.179;

1.179
date	2002.06.26.08.55.02;	author markus;	state Exp;
branches;
next	1.178;

1.178
date	2002.06.24.14.33.27;	author markus;	state Exp;
branches;
next	1.177;

1.177
date	2002.06.23.21.34.07;	author markus;	state Exp;
branches;
next	1.176;

1.176
date	2002.06.23.21.06.41;	author deraadt;	state Exp;
branches;
next	1.175;

1.175
date	2002.06.10.22.28.41;	author markus;	state Exp;
branches;
next	1.174;

1.174
date	2002.06.09.13.32.01;	author markus;	state Exp;
branches;
next	1.173;

1.173
date	2002.04.22.21.04.52;	author markus;	state Exp;
branches;
next	1.172;

1.172
date	2002.03.25.21.13.51;	author markus;	state Exp;
branches
	1.172.2.1;
next	1.171;

1.171
date	2002.03.04.19.37.58;	author markus;	state Exp;
branches;
next	1.170;

1.170
date	2002.02.27.21.23.13;	author stevesk;	state Exp;
branches;
next	1.169;

1.169
date	2002.02.24.19.59.42;	author stevesk;	state Exp;
branches;
next	1.168;

1.168
date	2002.02.14.23.27.59;	author markus;	state Exp;
branches;
next	1.167;

1.167
date	2002.02.06.14.55.15;	author markus;	state Exp;
branches;
next	1.166;

1.166
date	2002.02.05.14.32.55;	author markus;	state Exp;
branches;
next	1.165;

1.165
date	2002.02.03.17.58.21;	author markus;	state Exp;
branches;
next	1.164;

1.164
date	2002.02.03.17.55.55;	author markus;	state Exp;
branches;
next	1.163;

1.163
date	2002.01.27.14.57.46;	author stevesk;	state Exp;
branches;
next	1.162;

1.162
date	2002.01.24.21.09.25;	author stevesk;	state Exp;
branches;
next	1.161;

1.161
date	2002.01.21.23.27.10;	author markus;	state Exp;
branches;
next	1.160;

1.160
date	2002.01.16.13.17.51;	author markus;	state Exp;
branches;
next	1.159;

1.159
date	2002.01.14.13.55.55;	author markus;	state Exp;
branches;
next	1.158;

1.158
date	2002.01.09.17.26.35;	author markus;	state Exp;
branches;
next	1.157;

1.157
date	2002.01.09.17.16.00;	author markus;	state Exp;
branches;
next	1.156;

1.156
date	2002.01.05.10.43.40;	author markus;	state Exp;
branches;
next	1.155;

1.155
date	2001.12.29.21.56.01;	author stevesk;	state Exp;
branches;
next	1.154;

1.154
date	2001.12.28.15.06.00;	author markus;	state Exp;
branches;
next	1.153;

1.153
date	2001.12.28.14.50.54;	author markus;	state Exp;
branches;
next	1.152;

1.152
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.151;

1.151
date	2001.12.27.20.39.58;	author markus;	state Exp;
branches;
next	1.150;

1.150
date	2001.12.20.22.50.24;	author djm;	state Exp;
branches;
next	1.149;

1.149
date	2001.12.20.16.37.29;	author markus;	state Exp;
branches;
next	1.148;

1.148
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.147;

1.147
date	2001.12.08.17.49.28;	author stevesk;	state Exp;
branches;
next	1.146;

1.146
date	2001.12.06.18.20.32;	author stevesk;	state Exp;
branches;
next	1.145;

1.145
date	2001.12.06.18.09.23;	author stevesk;	state Exp;
branches;
next	1.144;

1.144
date	2001.12.06.18.02.32;	author stevesk;	state Exp;
branches;
next	1.143;

1.143
date	2001.12.05.10.06.12;	author deraadt;	state Exp;
branches;
next	1.142;

1.142
date	2001.12.05.03.56.39;	author itojun;	state Exp;
branches;
next	1.141;

1.141
date	2001.11.29.21.10.51;	author stevesk;	state Exp;
branches;
next	1.140;

1.140
date	2001.10.10.22.18.47;	author markus;	state Exp;
branches
	1.140.2.1;
next	1.139;

1.139
date	2001.10.09.21.59.41;	author markus;	state Exp;
branches;
next	1.138;

1.138
date	2001.10.08.11.48.57;	author markus;	state Exp;
branches;
next	1.137;

1.137
date	2001.10.07.17.49.40;	author markus;	state Exp;
branches;
next	1.136;

1.136
date	2001.10.04.15.05.40;	author markus;	state Exp;
branches;
next	1.135;

1.135
date	2001.10.01.21.38.53;	author markus;	state Exp;
branches;
next	1.134;

1.134
date	2001.09.17.21.04.01;	author markus;	state Exp;
branches;
next	1.133;

1.133
date	2001.09.17.20.52.47;	author markus;	state Exp;
branches;
next	1.132;

1.132
date	2001.07.17.21.04.56;	author markus;	state Exp;
branches;
next	1.131;

1.131
date	2001.07.02.22.52.56;	author markus;	state Exp;
branches;
next	1.130;

1.130
date	2001.06.30.18.08.39;	author stevesk;	state Exp;
branches;
next	1.129;

1.129
date	2001.06.29.18.40.28;	author stevesk;	state Exp;
branches;
next	1.128;

1.128
date	2001.06.25.08.25.35;	author markus;	state Exp;
branches;
next	1.127;

1.127
date	2001.06.23.15.12.17;	author itojun;	state Exp;
branches;
next	1.126;

1.126
date	2001.06.20.13.56.39;	author markus;	state Exp;
branches;
next	1.125;

1.125
date	2001.06.07.20.23.04;	author markus;	state Exp;
branches;
next	1.124;

1.124
date	2001.06.05.10.24.32;	author markus;	state Exp;
branches;
next	1.123;

1.123
date	2001.06.04.21.59.42;	author markus;	state Exp;
branches;
next	1.122;

1.122
date	2001.06.03.14.55.38;	author markus;	state Exp;
branches;
next	1.121;

1.121
date	2001.05.31.10.30.14;	author markus;	state Exp;
branches;
next	1.120;

1.120
date	2001.05.30.12.55.09;	author markus;	state dead;
branches;
next	1.119;

1.119
date	2001.05.28.23.25.24;	author markus;	state Exp;
branches;
next	1.118;

1.118
date	2001.05.28.23.14.49;	author markus;	state Exp;
branches;
next	1.117;

1.117
date	2001.05.19.19.57.09;	author stevesk;	state Exp;
branches;
next	1.116;

1.116
date	2001.05.16.22.09.20;	author markus;	state Exp;
branches;
next	1.115;

1.115
date	2001.05.09.22.51.57;	author markus;	state Exp;
branches;
next	1.114;

1.114
date	2001.05.08.19.17.30;	author markus;	state Exp;
branches;
next	1.113;

1.113
date	2001.05.04.23.47.33;	author markus;	state Exp;
branches;
next	1.112;

1.112
date	2001.05.04.14.34.34;	author markus;	state Exp;
branches;
next	1.111;

1.111
date	2001.05.03.15.07.39;	author stevesk;	state Exp;
branches;
next	1.110;

1.110
date	2001.04.29.19.16.52;	author markus;	state Exp;
branches;
next	1.109;

1.109
date	2001.04.17.12.55.03;	author markus;	state Exp;
branches
	1.109.2.1;
next	1.108;

1.108
date	2001.04.14.16.17.14;	author markus;	state Exp;
branches;
next	1.107;

1.107
date	2001.04.13.22.46.52;	author beck;	state Exp;
branches;
next	1.106;

1.106
date	2001.04.11.13.56.13;	author markus;	state Exp;
branches;
next	1.105;

1.105
date	2001.04.10.12.15.23;	author markus;	state Exp;
branches;
next	1.104;

1.104
date	2001.04.10.07.46.58;	author markus;	state Exp;
branches;
next	1.103;

1.103
date	2001.04.07.08.55.17;	author markus;	state Exp;
branches;
next	1.102;

1.102
date	2001.04.06.21.00.10;	author markus;	state Exp;
branches;
next	1.101;

1.101
date	2001.04.05.10.42.48;	author markus;	state Exp;
branches;
next	1.100;

1.100
date	2001.04.04.20.25.35;	author markus;	state Exp;
branches;
next	1.99;

1.99
date	2001.03.16.19.06.29;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2001.03.04.17.42.28;	author millert;	state Exp;
branches;
next	1.97;

1.97
date	2001.03.04.00.03.59;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2001.02.28.21.31.32;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2001.02.28.21.27.48;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2001.02.28.12.55.07;	author markus;	state Exp;
branches;
next	1.93;

1.93
date	2001.02.28.08.54.55;	author markus;	state Exp;
branches;
next	1.92;

1.92
date	2001.02.16.13.38.18;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2001.02.15.23.19.59;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2001.02.08.21.58.28;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2001.02.04.15.32.23;	author stevesk;	state Exp;
branches;
next	1.88;

1.88
date	2001.02.01.21.58.08;	author markus;	state Exp;
branches;
next	1.87;

1.87
date	2001.01.31.20.37.22;	author markus;	state Exp;
branches;
next	1.86;

1.86
date	2001.01.31.19.26.19;	author markus;	state Exp;
branches;
next	1.85;

1.85
date	2001.01.29.19.42.35;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2001.01.29.16.55.36;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2001.01.24.21.03.50;	author stevesk;	state Exp;
branches;
next	1.82;

1.82
date	2001.01.21.19.05.46;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2001.01.19.15.55.10;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2001.01.08.22.03.23;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2000.12.29.22.19.13;	author markus;	state Exp;
branches;
next	1.78;

1.78
date	2000.12.29.11.05.55;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2000.12.19.23.17.56;	author markus;	state Exp;
branches;
next	1.76;

1.76
date	2000.12.19.22.43.44;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2000.12.05.20.34.09;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2000.11.30.22.54.31;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	2000.11.06.23.04.55;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2000.10.27.07.48.22;	author markus;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2000.10.27.07.32.17;	author markus;	state Exp;
branches;
next	1.70;

1.70
date	2000.09.28.18.03.18;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2000.09.21.11.25.33;	author markus;	state Exp;
branches;
next	1.68;

1.68
date	2000.09.07.20.40.29;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2000.09.07.20.27.50;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2000.08.19.21.55.51;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2000.08.19.18.48.10;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2000.07.16.08.27.21;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2000.06.25.20.17.57;	author provos;	state Exp;
branches;
next	1.62;

1.62
date	2000.06.20.01.39.39;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2000.06.17.16.01.33;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2000.06.17.15.58.46;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2000.05.30.17.23.36;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2000.05.17.08.20.15;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2000.05.08.17.42.24;	author markus;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2000.05.03.18.03.06;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2000.05.02.19.33.12;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2000.05.01.20.21.40;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2000.05.01.19.11.35;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2000.05.01.18.31.27;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2000.04.28.08.10.20;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2000.04.16.16.40.43;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2000.04.14.10.30.30;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2000.04.14.10.09.14;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2000.04.10.15.19.43;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2000.04.06.09.43.15;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2000.04.04.06.18.01;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2000.04.03.07.07.15;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2000.03.28.20.39.05;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2000.03.28.20.33.50;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2000.03.28.20.31.25;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2000.03.27.17.41.50;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2000.03.16.20.56.14;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2000.01.24.20.37.29;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2000.01.10.10.12.52;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2000.01.04.07.52.03;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2000.01.04.00.07.58;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	99.12.27.09.48.38;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	99.12.12.19.20.02;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	99.12.06.12.07.21;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	99.12.01.13.59.15;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	99.11.25.09.10.33;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	99.11.24.20.07.25;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	99.11.24.20.02.11;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	99.11.24.19.53.45;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	99.11.24.00.26.01;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	99.11.23.22.25.53;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	99.11.22.21.02.38;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	99.11.19.19.58.18;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	99.11.19.19.18.20;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	99.11.19.16.32.01;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	99.11.11.23.36.52;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	99.11.02.19.42.35;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	99.10.28.21.26.09;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	99.10.26.22.39.44;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	99.10.17.16.56.08;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	99.10.16.21.19.00;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.10.16.20.47.13;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	99.10.14.18.17.42;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	99.10.05.22.18.52;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	99.10.04.20.45.01;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	99.10.03.19.22.38;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.09.30.08.34.24;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.09.30.08.03.39;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.09.30.05.11.29;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.09.29.21.14.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.09.29.18.16.19;	author dugsong;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.00.10.16;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.09.28.07.56.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.04.45.36;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.34;	author deraadt;	state Exp;
branches;
next	;

1.57.2.1
date	2000.06.12.02.37.32;	author jason;	state Exp;
branches;
next	1.57.2.2;

1.57.2.2
date	2000.09.01.18.23.18;	author jason;	state Exp;
branches;
next	1.57.2.3;

1.57.2.3
date	2000.11.08.21.30.32;	author jason;	state Exp;
branches;
next	1.57.2.4;

1.57.2.4
date	2001.03.12.15.44.08;	author jason;	state Exp;
branches;
next	1.57.2.5;

1.57.2.5
date	2001.03.21.18.52.38;	author jason;	state Exp;
branches;
next	;

1.72.2.1
date	2001.02.16.20.12.57;	author jason;	state Exp;
branches;
next	1.72.2.2;

1.72.2.2
date	2001.02.19.17.18.44;	author jason;	state Exp;
branches;
next	1.72.2.3;

1.72.2.3
date	2001.03.21.19.46.23;	author jason;	state Exp;
branches;
next	1.72.2.4;

1.72.2.4
date	2001.05.07.21.09.27;	author jason;	state Exp;
branches;
next	1.72.2.5;

1.72.2.5
date	2001.06.12.22.47.33;	author miod;	state Exp;
branches;
next	1.72.2.6;

1.72.2.6
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.72.2.7;

1.72.2.7
date	2001.11.15.00.14.59;	author miod;	state Exp;
branches;
next	1.72.2.8;

1.72.2.8
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.109.2.1
date	2001.06.12.22.31.48;	author jason;	state Exp;
branches;
next	1.109.2.2;

1.109.2.2
date	2001.06.21.23.45.23;	author jason;	state Exp;
branches;
next	1.109.2.3;

1.109.2.3
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.109.2.4;

1.109.2.4
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.109.2.5;

1.109.2.5
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.109.2.6;

1.109.2.6
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.140.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.140.2.2;

1.140.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.140.2.3;

1.140.2.3
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.140.2.4;

1.140.2.4
date	2002.06.26.18.22.34;	author miod;	state Exp;
branches;
next	1.140.2.5;

1.140.2.5
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.172.2.1
date	2002.05.18.04.12.10;	author jason;	state Exp;
branches;
next	1.172.2.2;

1.172.2.2
date	2002.05.18.04.50.37;	author jason;	state Exp;
branches;
next	1.172.2.3;

1.172.2.3
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	1.172.2.4;

1.172.2.4
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.172.2.5;

1.172.2.5
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.183.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.183.2.2;

1.183.2.2
date	2003.09.16.21.20.25;	author brad;	state Exp;
branches;
next	1.183.2.3;

1.183.2.3
date	2003.09.16.21.25.56;	author brad;	state Exp;
branches;
next	;

1.187.2.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.187.2.2;

1.187.2.2
date	2003.09.16.21.30.49;	author brad;	state Exp;
branches;
next	1.187.2.3;

1.187.2.3
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.195.2.1
date	2004.02.28.03.51.32;	author brad;	state Exp;
branches;
next	1.195.2.2;

1.195.2.2
date	2004.08.19.22.37.30;	author brad;	state Exp;
branches;
next	;

1.200.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	1.200.2.2;

1.200.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.210.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.210.2.2;

1.210.2.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	1.210.2.3;

1.210.2.3
date	2005.09.02.03.44.59;	author brad;	state Exp;
branches;
next	;

1.214.2.1
date	2005.09.04.18.40.01;	author brad;	state Exp;
branches;
next	1.214.2.2;

1.214.2.2
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.223.2.1
date	2006.02.03.03.01.55;	author brad;	state Exp;
branches;
next	1.223.2.2;

1.223.2.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.235.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;

1.268.2.1
date	2008.04.03.03.41.25;	author brad;	state Exp;
branches;
next	;

1.270.2.1
date	2008.04.03.03.41.40;	author brad;	state Exp;
branches;
next	;

1.272.2.1
date	2008.04.03.03.42.02;	author brad;	state Exp;
branches;
next	;

1.319.2.1
date	2013.11.08.05.52.21;	author djm;	state Exp;
branches;
next	;

1.324.2.1
date	2013.11.08.01.33.56;	author djm;	state Exp;
branches;
next	;


desc
@@


1.375
log
@fix inverted test on channel open failure path that "upgraded" a
transient failure into a fatal error; reported by sthen and also seen
by benno@@; ok sthen@@
@
text
@/* $OpenBSD: channels.c,v 1.374 2017/09/24 09:50:01 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * This file contains functions for generic socket connection forwarding.
 * There is also code for initiating connection forwarding for X11 connections,
 * arbitrary tcp/ip connections, and the authentication agent connection.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 * SSH2 support added by Markus Friedl.
 * Copyright (c) 1999, 2000, 2001, 2002 Markus Friedl.  All rights reserved.
 * Copyright (c) 1999 Dug Song.  All rights reserved.
 * Copyright (c) 1999 Theo de Raadt.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/un.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/queue.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <netdb.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#include "xmalloc.h"
#include "ssh.h"
#include "ssh2.h"
#include "ssherr.h"
#include "sshbuf.h"
#include "packet.h"
#include "log.h"
#include "misc.h"
#include "channels.h"
#include "compat.h"
#include "canohost.h"
#include "key.h"
#include "authfd.h"
#include "pathnames.h"

/* -- agent forwarding */
#define	NUM_SOCKS	10

/* -- tcp forwarding */
/* special-case port number meaning allow any port */
#define FWD_PERMIT_ANY_PORT	0

/* special-case wildcard meaning allow any host */
#define FWD_PERMIT_ANY_HOST	"*"

/* -- X11 forwarding */
/* Maximum number of fake X11 displays to try. */
#define MAX_DISPLAYS  1000

/*
 * Data structure for storing which hosts are permitted for forward requests.
 * The local sides of any remote forwards are stored in this array to prevent
 * a corrupt remote server from accessing arbitrary TCP/IP ports on our local
 * network (which might be behind a firewall).
 */
/* XXX: streamlocal wants a path instead of host:port */
/*      Overload host_to_connect; we could just make this match Forward */
/*	XXX - can we use listen_host instead of listen_path? */
typedef struct {
	char *host_to_connect;		/* Connect to 'host'. */
	int port_to_connect;		/* Connect to 'port'. */
	char *listen_host;		/* Remote side should listen address. */
	char *listen_path;		/* Remote side should listen path. */
	int listen_port;		/* Remote side should listen port. */
	Channel *downstream;		/* Downstream mux*/
} ForwardPermission;

typedef void chan_fn(struct ssh *, Channel *c,
    fd_set *readset, fd_set *writeset);

/* Master structure for channels state */
struct ssh_channels {
	/*
	 * Pointer to an array containing all allocated channels.  The array
	 * is dynamically extended as needed.
	 */
	Channel **channels;

	/*
	 * Size of the channel array.  All slots of the array must always be
	 * initialized (at least the type field); unused slots set to NULL
	 */
	u_int channels_alloc;

	/*
	 * Maximum file descriptor value used in any of the channels.  This is
	 * updated in channel_new.
	 */
	int channel_max_fd;

	/*
	 * 'channel_pre*' are called just before select() to add any bits
	 * relevant to channels in the select bitmasks.
	 *
	 * 'channel_post*': perform any appropriate operations for
	 * channels which have events pending.
	 */
	chan_fn **channel_pre;
	chan_fn **channel_post;

	/* -- tcp forwarding */

	/* List of all permitted host/port pairs to connect by the user. */
	ForwardPermission *permitted_opens;

	/* List of all permitted host/port pairs to connect by the admin. */
	ForwardPermission *permitted_adm_opens;

	/*
	 * Number of permitted host/port pairs in the array permitted by
	 * the user.
	 */
	u_int num_permitted_opens;

	/*
	 * Number of permitted host/port pair in the array permitted by
	 * the admin.
	 */
	u_int num_adm_permitted_opens;

	/*
	 * If this is true, all opens are permitted.  This is the case on
	 * the server on which we have to trust the client anyway, and the
	 * user could do anything after logging in anyway.
	 */
	int all_opens_permitted;

	/* -- X11 forwarding */

	/* Saved X11 local (client) display. */
	char *x11_saved_display;

	/* Saved X11 authentication protocol name. */
	char *x11_saved_proto;

	/* Saved X11 authentication data.  This is the real data. */
	char *x11_saved_data;
	u_int x11_saved_data_len;

	/* Deadline after which all X11 connections are refused */
	u_int x11_refuse_time;

	/*
	 * Fake X11 authentication data.  This is what the server will be
	 * sending us; we should replace any occurrences of this by the
	 * real data.
	 */
	u_char *x11_fake_data;
	u_int x11_fake_data_len;

	/* AF_UNSPEC or AF_INET or AF_INET6 */
	int IPv4or6;
};

/* helper */
static void port_open_helper(struct ssh *ssh, Channel *c, char *rtype);
static const char *channel_rfwd_bind_host(const char *listen_host);

/* non-blocking connect helpers */
static int connect_next(struct channel_connect *);
static void channel_connect_ctx_free(struct channel_connect *);
static Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);
static int rdynamic_connect_finish(struct ssh *, Channel *);

/* Setup helper */
static void channel_handler_init(struct ssh_channels *sc);

/* -- channel core */

void
channel_init_channels(struct ssh *ssh)
{
	struct ssh_channels *sc;

	if ((sc = calloc(1, sizeof(*sc))) == NULL ||
	    (sc->channel_pre = calloc(SSH_CHANNEL_MAX_TYPE,
	    sizeof(*sc->channel_pre))) == NULL ||
	    (sc->channel_post = calloc(SSH_CHANNEL_MAX_TYPE,
	    sizeof(*sc->channel_post))) == NULL)
		fatal("%s: allocation failed", __func__);
	sc->channels_alloc = 10;
	sc->channels = xcalloc(sc->channels_alloc, sizeof(*sc->channels));
	sc->IPv4or6 = AF_UNSPEC;
	channel_handler_init(sc);

	ssh->chanctxt = sc;
}

Channel *
channel_by_id(struct ssh *ssh, int id)
{
	Channel *c;

	if (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {
		logit("%s: %d: bad id", __func__, id);
		return NULL;
	}
	c = ssh->chanctxt->channels[id];
	if (c == NULL) {
		logit("%s: %d: bad id: channel free", __func__, id);
		return NULL;
	}
	return c;
}

Channel *
channel_by_remote_id(struct ssh *ssh, u_int remote_id)
{
	Channel *c;
	u_int i;

	for (i = 0; i < ssh->chanctxt->channels_alloc; i++) {
		c = ssh->chanctxt->channels[i];
		if (c != NULL && c->have_remote_id && c->remote_id == remote_id)
			return c;
	}
	return NULL;
}

/*
 * Returns the channel if it is allowed to receive protocol messages.
 * Private channels, like listening sockets, may not receive messages.
 */
Channel *
channel_lookup(struct ssh *ssh, int id)
{
	Channel *c;

	if ((c = channel_by_id(ssh, id)) == NULL)
		return NULL;

	switch (c->type) {
	case SSH_CHANNEL_X11_OPEN:
	case SSH_CHANNEL_LARVAL:
	case SSH_CHANNEL_CONNECTING:
	case SSH_CHANNEL_DYNAMIC:
	case SSH_CHANNEL_RDYNAMIC_OPEN:
	case SSH_CHANNEL_RDYNAMIC_FINISH:
	case SSH_CHANNEL_OPENING:
	case SSH_CHANNEL_OPEN:
	case SSH_CHANNEL_ABANDONED:
	case SSH_CHANNEL_MUX_PROXY:
		return c;
	}
	logit("Non-public channel %d, type %d.", id, c->type);
	return NULL;
}

/*
 * Register filedescriptors for a channel, used when allocating a channel or
 * when the channel consumer/producer is ready, e.g. shell exec'd
 */
static void
channel_register_fds(struct ssh *ssh, Channel *c, int rfd, int wfd, int efd,
    int extusage, int nonblock, int is_tty)
{
	struct ssh_channels *sc = ssh->chanctxt;

	/* Update the maximum file descriptor value. */
	sc->channel_max_fd = MAXIMUM(sc->channel_max_fd, rfd);
	sc->channel_max_fd = MAXIMUM(sc->channel_max_fd, wfd);
	sc->channel_max_fd = MAXIMUM(sc->channel_max_fd, efd);

	if (rfd != -1)
		fcntl(rfd, F_SETFD, FD_CLOEXEC);
	if (wfd != -1 && wfd != rfd)
		fcntl(wfd, F_SETFD, FD_CLOEXEC);
	if (efd != -1 && efd != rfd && efd != wfd)
		fcntl(efd, F_SETFD, FD_CLOEXEC);

	c->rfd = rfd;
	c->wfd = wfd;
	c->sock = (rfd == wfd) ? rfd : -1;
	c->efd = efd;
	c->extended_usage = extusage;

	if ((c->isatty = is_tty) != 0)
		debug2("channel %d: rfd %d isatty", c->self, c->rfd);

	/* enable nonblocking mode */
	if (nonblock) {
		if (rfd != -1)
			set_nonblock(rfd);
		if (wfd != -1)
			set_nonblock(wfd);
		if (efd != -1)
			set_nonblock(efd);
	}
}

/*
 * Allocate a new channel object and set its type and socket. This will cause
 * remote_name to be freed.
 */
Channel *
channel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,
    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)
{
	struct ssh_channels *sc = ssh->chanctxt;
	u_int i, found;
	Channel *c;

	/* Try to find a free slot where to put the new channel. */
	for (i = 0; i < sc->channels_alloc; i++) {
		if (sc->channels[i] == NULL) {
			/* Found a free slot. */
			found = i;
			break;
		}
	}
	if (i >= sc->channels_alloc) {
		/*
		 * There are no free slots. Take last+1 slot and expand
		 * the array.
		 */
		found = sc->channels_alloc;
		if (sc->channels_alloc > CHANNELS_MAX_CHANNELS)
			fatal("%s: internal error: channels_alloc %d too big",
			    __func__, sc->channels_alloc);
		sc->channels = xrecallocarray(sc->channels, sc->channels_alloc,
		    sc->channels_alloc + 10, sizeof(*sc->channels));
		sc->channels_alloc += 10;
		debug2("channel: expanding %d", sc->channels_alloc);
	}
	/* Initialize and return new channel. */
	c = sc->channels[found] = xcalloc(1, sizeof(Channel));
	if ((c->input = sshbuf_new()) == NULL ||
	    (c->output = sshbuf_new()) == NULL ||
	    (c->extended = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	c->ostate = CHAN_OUTPUT_OPEN;
	c->istate = CHAN_INPUT_OPEN;
	channel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);
	c->self = found;
	c->type = type;
	c->ctype = ctype;
	c->local_window = window;
	c->local_window_max = window;
	c->local_maxpacket = maxpack;
	c->remote_name = xstrdup(remote_name);
	c->ctl_chan = -1;
	c->delayed = 1;		/* prevent call to channel_post handler */
	TAILQ_INIT(&c->status_confirms);
	debug("channel %d: new [%s]", found, remote_name);
	return c;
}

static void
channel_find_maxfd(struct ssh_channels *sc)
{
	u_int i;
	int max = 0;
	Channel *c;

	for (i = 0; i < sc->channels_alloc; i++) {
		c = sc->channels[i];
		if (c != NULL) {
			max = MAXIMUM(max, c->rfd);
			max = MAXIMUM(max, c->wfd);
			max = MAXIMUM(max, c->efd);
		}
	}
	sc->channel_max_fd = max;
}

int
channel_close_fd(struct ssh *ssh, int *fdp)
{
	struct ssh_channels *sc = ssh->chanctxt;
	int ret = 0, fd = *fdp;

	if (fd != -1) {
		ret = close(fd);
		*fdp = -1;
		if (fd == sc->channel_max_fd)
			channel_find_maxfd(sc);
	}
	return ret;
}

/* Close all channel fd/socket. */
static void
channel_close_fds(struct ssh *ssh, Channel *c)
{
	channel_close_fd(ssh, &c->sock);
	channel_close_fd(ssh, &c->rfd);
	channel_close_fd(ssh, &c->wfd);
	channel_close_fd(ssh, &c->efd);
}

static void
fwd_perm_clear(ForwardPermission *fp)
{
	free(fp->host_to_connect);
	free(fp->listen_host);
	free(fp->listen_path);
	bzero(fp, sizeof(*fp));
}

enum { FWDPERM_USER, FWDPERM_ADMIN };

static int
fwd_perm_list_add(struct ssh *ssh, int which,
    const char *host_to_connect, int port_to_connect,
    const char *listen_host, const char *listen_path, int listen_port,
    Channel *downstream)
{
	ForwardPermission **fpl;
	u_int n, *nfpl;

	switch (which) {
	case FWDPERM_USER:
		fpl = &ssh->chanctxt->permitted_opens;
		nfpl = &ssh->chanctxt->num_permitted_opens;
		break;
	case FWDPERM_ADMIN:
		fpl = &ssh->chanctxt->permitted_adm_opens;
		nfpl = &ssh->chanctxt->num_adm_permitted_opens;
		break;
	default:
		fatal("%s: invalid list %d", __func__, which);
	}

	if (*nfpl >= INT_MAX)
		fatal("%s: overflow", __func__);

	*fpl = xrecallocarray(*fpl, *nfpl, *nfpl + 1, sizeof(**fpl));
	n = (*nfpl)++;
#define MAYBE_DUP(s) ((s == NULL) ? NULL : xstrdup(s))
	(*fpl)[n].host_to_connect = MAYBE_DUP(host_to_connect);
	(*fpl)[n].port_to_connect = port_to_connect;
	(*fpl)[n].listen_host = MAYBE_DUP(listen_host);
	(*fpl)[n].listen_path = MAYBE_DUP(listen_path);
	(*fpl)[n].listen_port = listen_port;
	(*fpl)[n].downstream = downstream;
#undef MAYBE_DUP
	return (int)n;
}

static void
mux_remove_remote_forwardings(struct ssh *ssh, Channel *c)
{
	struct ssh_channels *sc = ssh->chanctxt;
	ForwardPermission *fp;
	int r;
	u_int i;

	for (i = 0; i < sc->num_permitted_opens; i++) {
		fp = &sc->permitted_opens[i];
		if (fp->downstream != c)
			continue;

		/* cancel on the server, since mux client is gone */
		debug("channel %d: cleanup remote forward for %s:%u",
		    c->self, fp->listen_host, fp->listen_port);
		if ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||
		    (r = sshpkt_put_cstring(ssh,
		    "cancel-tcpip-forward")) != 0 ||
		    (r = sshpkt_put_u8(ssh, 0)) != 0 ||
		    (r = sshpkt_put_cstring(ssh,
		    channel_rfwd_bind_host(fp->listen_host))) != 0 ||
		    (r = sshpkt_put_u32(ssh, fp->listen_port)) != 0 ||
		    (r = sshpkt_send(ssh)) != 0) {
			fatal("%s: channel %i: %s", __func__,
			    c->self, ssh_err(r));
		}
		fwd_perm_clear(fp); /* unregister */
	}
}

/* Free the channel and close its fd/socket. */
void
channel_free(struct ssh *ssh, Channel *c)
{
	struct ssh_channels *sc = ssh->chanctxt;
	char *s;
	u_int i, n;
	Channel *other;
	struct channel_confirm *cc;

	for (n = 0, i = 0; i < sc->channels_alloc; i++) {
		if ((other = sc->channels[i]) == NULL)
			continue;
		n++;
		/* detach from mux client and prepare for closing */
		if (c->type == SSH_CHANNEL_MUX_CLIENT &&
		    other->type == SSH_CHANNEL_MUX_PROXY &&
		    other->mux_ctx == c) {
			other->mux_ctx = NULL;
			other->type = SSH_CHANNEL_OPEN;
			other->istate = CHAN_INPUT_CLOSED;
			other->ostate = CHAN_OUTPUT_CLOSED;
		}
	}
	debug("channel %d: free: %s, nchannels %u", c->self,
	    c->remote_name ? c->remote_name : "???", n);

	if (c->type == SSH_CHANNEL_MUX_CLIENT)
		mux_remove_remote_forwardings(ssh, c);

	s = channel_open_message(ssh);
	debug3("channel %d: status: %s", c->self, s);
	free(s);

	channel_close_fds(ssh, c);
	sshbuf_free(c->input);
	sshbuf_free(c->output);
	sshbuf_free(c->extended);
	c->input = c->output = c->extended = NULL;
	free(c->remote_name);
	c->remote_name = NULL;
	free(c->path);
	c->path = NULL;
	free(c->listening_addr);
	c->listening_addr = NULL;
	while ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {
		if (cc->abandon_cb != NULL)
			cc->abandon_cb(ssh, c, cc->ctx);
		TAILQ_REMOVE(&c->status_confirms, cc, entry);
		explicit_bzero(cc, sizeof(*cc));
		free(cc);
	}
	if (c->filter_cleanup != NULL && c->filter_ctx != NULL)
		c->filter_cleanup(ssh, c->self, c->filter_ctx);
	sc->channels[c->self] = NULL;
	explicit_bzero(c, sizeof(*c));
	free(c);
}

void
channel_free_all(struct ssh *ssh)
{
	u_int i;

	for (i = 0; i < ssh->chanctxt->channels_alloc; i++)
		if (ssh->chanctxt->channels[i] != NULL)
			channel_free(ssh, ssh->chanctxt->channels[i]);
}

/*
 * Closes the sockets/fds of all channels.  This is used to close extra file
 * descriptors after a fork.
 */
void
channel_close_all(struct ssh *ssh)
{
	u_int i;

	for (i = 0; i < ssh->chanctxt->channels_alloc; i++)
		if (ssh->chanctxt->channels[i] != NULL)
			channel_close_fds(ssh, ssh->chanctxt->channels[i]);
}

/*
 * Stop listening to channels.
 */
void
channel_stop_listening(struct ssh *ssh)
{
	u_int i;
	Channel *c;

	for (i = 0; i < ssh->chanctxt->channels_alloc; i++) {
		c = ssh->chanctxt->channels[i];
		if (c != NULL) {
			switch (c->type) {
			case SSH_CHANNEL_AUTH_SOCKET:
			case SSH_CHANNEL_PORT_LISTENER:
			case SSH_CHANNEL_RPORT_LISTENER:
			case SSH_CHANNEL_X11_LISTENER:
			case SSH_CHANNEL_UNIX_LISTENER:
			case SSH_CHANNEL_RUNIX_LISTENER:
				channel_close_fd(ssh, &c->sock);
				channel_free(ssh, c);
				break;
			}
		}
	}
}

/*
 * Returns true if no channel has too much buffered data, and false if one or
 * more channel is overfull.
 */
int
channel_not_very_much_buffered_data(struct ssh *ssh)
{
	u_int i;
	u_int maxsize = ssh_packet_get_maxsize(ssh);
	Channel *c;

	for (i = 0; i < ssh->chanctxt->channels_alloc; i++) {
		c = ssh->chanctxt->channels[i];
		if (c == NULL || c->type != SSH_CHANNEL_OPEN)
			continue;
		if (sshbuf_len(c->output) > maxsize) {
			debug2("channel %d: big output buffer %zu > %u",
			    c->self, sshbuf_len(c->output), maxsize);
			return 0;
		}
	}
	return 1;
}

/* Returns true if any channel is still open. */
int
channel_still_open(struct ssh *ssh)
{
	u_int i;
	Channel *c;

	for (i = 0; i < ssh->chanctxt->channels_alloc; i++) {
		c = ssh->chanctxt->channels[i];
		if (c == NULL)
			continue;
		switch (c->type) {
		case SSH_CHANNEL_X11_LISTENER:
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_RPORT_LISTENER:
		case SSH_CHANNEL_MUX_LISTENER:
		case SSH_CHANNEL_CLOSED:
		case SSH_CHANNEL_AUTH_SOCKET:
		case SSH_CHANNEL_DYNAMIC:
		case SSH_CHANNEL_RDYNAMIC_OPEN:
		case SSH_CHANNEL_CONNECTING:
		case SSH_CHANNEL_ZOMBIE:
		case SSH_CHANNEL_ABANDONED:
		case SSH_CHANNEL_UNIX_LISTENER:
		case SSH_CHANNEL_RUNIX_LISTENER:
			continue;
		case SSH_CHANNEL_LARVAL:
			continue;
		case SSH_CHANNEL_OPENING:
		case SSH_CHANNEL_OPEN:
		case SSH_CHANNEL_RDYNAMIC_FINISH:
		case SSH_CHANNEL_X11_OPEN:
		case SSH_CHANNEL_MUX_CLIENT:
		case SSH_CHANNEL_MUX_PROXY:
			return 1;
		default:
			fatal("%s: bad channel type %d", __func__, c->type);
			/* NOTREACHED */
		}
	}
	return 0;
}

/* Returns the id of an open channel suitable for keepaliving */
int
channel_find_open(struct ssh *ssh)
{
	u_int i;
	Channel *c;

	for (i = 0; i < ssh->chanctxt->channels_alloc; i++) {
		c = ssh->chanctxt->channels[i];
		if (c == NULL || !c->have_remote_id)
			continue;
		switch (c->type) {
		case SSH_CHANNEL_CLOSED:
		case SSH_CHANNEL_DYNAMIC:
		case SSH_CHANNEL_RDYNAMIC_OPEN:
		case SSH_CHANNEL_RDYNAMIC_FINISH:
		case SSH_CHANNEL_X11_LISTENER:
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_RPORT_LISTENER:
		case SSH_CHANNEL_MUX_LISTENER:
		case SSH_CHANNEL_MUX_CLIENT:
		case SSH_CHANNEL_MUX_PROXY:
		case SSH_CHANNEL_OPENING:
		case SSH_CHANNEL_CONNECTING:
		case SSH_CHANNEL_ZOMBIE:
		case SSH_CHANNEL_ABANDONED:
		case SSH_CHANNEL_UNIX_LISTENER:
		case SSH_CHANNEL_RUNIX_LISTENER:
			continue;
		case SSH_CHANNEL_LARVAL:
		case SSH_CHANNEL_AUTH_SOCKET:
		case SSH_CHANNEL_OPEN:
		case SSH_CHANNEL_X11_OPEN:
			return i;
		default:
			fatal("%s: bad channel type %d", __func__, c->type);
			/* NOTREACHED */
		}
	}
	return -1;
}

/*
 * Returns a message describing the currently open forwarded connections,
 * suitable for sending to the client.  The message contains crlf pairs for
 * newlines.
 */
char *
channel_open_message(struct ssh *ssh)
{
	struct sshbuf *buf;
	Channel *c;
	u_int i;
	int r;
	char *ret;

	if ((buf = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new", __func__);
	if ((r = sshbuf_putf(buf,
	    "The following connections are open:\r\n")) != 0)
		fatal("%s: sshbuf_putf: %s", __func__, ssh_err(r));
	for (i = 0; i < ssh->chanctxt->channels_alloc; i++) {
		c = ssh->chanctxt->channels[i];
		if (c == NULL)
			continue;
		switch (c->type) {
		case SSH_CHANNEL_X11_LISTENER:
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_RPORT_LISTENER:
		case SSH_CHANNEL_CLOSED:
		case SSH_CHANNEL_AUTH_SOCKET:
		case SSH_CHANNEL_ZOMBIE:
		case SSH_CHANNEL_ABANDONED:
		case SSH_CHANNEL_MUX_LISTENER:
		case SSH_CHANNEL_UNIX_LISTENER:
		case SSH_CHANNEL_RUNIX_LISTENER:
			continue;
		case SSH_CHANNEL_LARVAL:
		case SSH_CHANNEL_OPENING:
		case SSH_CHANNEL_CONNECTING:
		case SSH_CHANNEL_DYNAMIC:
		case SSH_CHANNEL_RDYNAMIC_OPEN:
		case SSH_CHANNEL_RDYNAMIC_FINISH:
		case SSH_CHANNEL_OPEN:
		case SSH_CHANNEL_X11_OPEN:
		case SSH_CHANNEL_MUX_PROXY:
		case SSH_CHANNEL_MUX_CLIENT:
			if ((r = sshbuf_putf(buf, "  #%d %.300s "
			    "(t%d %s%u i%u/%zu o%u/%zu fd %d/%d cc %d)\r\n",
			    c->self, c->remote_name,
			    c->type,
			    c->have_remote_id ? "r" : "nr", c->remote_id,
			    c->istate, sshbuf_len(c->input),
			    c->ostate, sshbuf_len(c->output),
			    c->rfd, c->wfd, c->ctl_chan)) != 0)
				fatal("%s: sshbuf_putf: %s",
				    __func__, ssh_err(r));
			continue;
		default:
			fatal("%s: bad channel type %d", __func__, c->type);
			/* NOTREACHED */
		}
	}
	if ((ret = sshbuf_dup_string(buf)) == NULL)
		fatal("%s: sshbuf_dup_string", __func__);
	sshbuf_free(buf);
	return ret;
}

static void
open_preamble(struct ssh *ssh, const char *where, Channel *c, const char *type)
{
	int r;

	if ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN)) != 0 ||
	    (r = sshpkt_put_cstring(ssh, type)) != 0 ||
	    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||
	    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||
	    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {
		fatal("%s: channel %i: open: %s", where, c->self, ssh_err(r));
	}
}

void
channel_send_open(struct ssh *ssh, int id)
{
	Channel *c = channel_lookup(ssh, id);
	int r;

	if (c == NULL) {
		logit("channel_send_open: %d: bad id", id);
		return;
	}
	debug2("channel %d: send open", id);
	open_preamble(ssh, __func__, c, c->ctype);
	if ((r = sshpkt_send(ssh)) != 0)
		fatal("%s: channel %i: %s", __func__, c->self, ssh_err(r));
}

void
channel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)
{
	Channel *c = channel_lookup(ssh, id);
	int r;

	if (c == NULL) {
		logit("%s: %d: unknown channel id", __func__, id);
		return;
	}
	if (!c->have_remote_id)
		fatal(":%s: channel %d: no remote id", __func__, c->self);

	debug2("channel %d: request %s confirm %d", id, service, wantconfirm);
	if ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||
	    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||
	    (r = sshpkt_put_cstring(ssh, service)) != 0 ||
	    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {
		fatal("%s: channel %i: %s", __func__, c->self, ssh_err(r));
	}
}

void
channel_register_status_confirm(struct ssh *ssh, int id,
    channel_confirm_cb *cb, channel_confirm_abandon_cb *abandon_cb, void *ctx)
{
	struct channel_confirm *cc;
	Channel *c;

	if ((c = channel_lookup(ssh, id)) == NULL)
		fatal("%s: %d: bad id", __func__, id);

	cc = xcalloc(1, sizeof(*cc));
	cc->cb = cb;
	cc->abandon_cb = abandon_cb;
	cc->ctx = ctx;
	TAILQ_INSERT_TAIL(&c->status_confirms, cc, entry);
}

void
channel_register_open_confirm(struct ssh *ssh, int id,
    channel_open_fn *fn, void *ctx)
{
	Channel *c = channel_lookup(ssh, id);

	if (c == NULL) {
		logit("%s: %d: bad id", __func__, id);
		return;
	}
	c->open_confirm = fn;
	c->open_confirm_ctx = ctx;
}

void
channel_register_cleanup(struct ssh *ssh, int id,
    channel_callback_fn *fn, int do_close)
{
	Channel *c = channel_by_id(ssh, id);

	if (c == NULL) {
		logit("%s: %d: bad id", __func__, id);
		return;
	}
	c->detach_user = fn;
	c->detach_close = do_close;
}

void
channel_cancel_cleanup(struct ssh *ssh, int id)
{
	Channel *c = channel_by_id(ssh, id);

	if (c == NULL) {
		logit("%s: %d: bad id", __func__, id);
		return;
	}
	c->detach_user = NULL;
	c->detach_close = 0;
}

void
channel_register_filter(struct ssh *ssh, int id, channel_infilter_fn *ifn,
    channel_outfilter_fn *ofn, channel_filter_cleanup_fn *cfn, void *ctx)
{
	Channel *c = channel_lookup(ssh, id);

	if (c == NULL) {
		logit("%s: %d: bad id", __func__, id);
		return;
	}
	c->input_filter = ifn;
	c->output_filter = ofn;
	c->filter_ctx = ctx;
	c->filter_cleanup = cfn;
}

void
channel_set_fds(struct ssh *ssh, int id, int rfd, int wfd, int efd,
    int extusage, int nonblock, int is_tty, u_int window_max)
{
	Channel *c = channel_lookup(ssh, id);
	int r;

	if (c == NULL || c->type != SSH_CHANNEL_LARVAL)
		fatal("channel_activate for non-larval channel %d.", id);
	if (!c->have_remote_id)
		fatal(":%s: channel %d: no remote id", __func__, c->self);

	channel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, is_tty);
	c->type = SSH_CHANNEL_OPEN;
	c->local_window = c->local_window_max = window_max;

	if ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_WINDOW_ADJUST)) != 0 ||
	    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||
	    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		fatal("%s: channel %i: %s", __func__, c->self, ssh_err(r));
}

static void
channel_pre_listener(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	FD_SET(c->sock, readset);
}

static void
channel_pre_connecting(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	debug3("channel %d: waiting for connection", c->self);
	FD_SET(c->sock, writeset);
}

static void
channel_pre_open(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	if (c->istate == CHAN_INPUT_OPEN &&
	    c->remote_window > 0 &&
	    sshbuf_len(c->input) < c->remote_window &&
	    sshbuf_check_reserve(c->input, CHAN_RBUF) == 0)
		FD_SET(c->rfd, readset);
	if (c->ostate == CHAN_OUTPUT_OPEN ||
	    c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {
		if (sshbuf_len(c->output) > 0) {
			FD_SET(c->wfd, writeset);
		} else if (c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {
			if (CHANNEL_EFD_OUTPUT_ACTIVE(c))
				debug2("channel %d: "
				    "obuf_empty delayed efd %d/(%zu)", c->self,
				    c->efd, sshbuf_len(c->extended));
			else
				chan_obuf_empty(ssh, c);
		}
	}
	/** XXX check close conditions, too */
	if (c->efd != -1 && !(c->istate == CHAN_INPUT_CLOSED &&
	    c->ostate == CHAN_OUTPUT_CLOSED)) {
		if (c->extended_usage == CHAN_EXTENDED_WRITE &&
		    sshbuf_len(c->extended) > 0)
			FD_SET(c->efd, writeset);
		else if (c->efd != -1 && !(c->flags & CHAN_EOF_SENT) &&
		    (c->extended_usage == CHAN_EXTENDED_READ ||
		    c->extended_usage == CHAN_EXTENDED_IGNORE) &&
		    sshbuf_len(c->extended) < c->remote_window)
			FD_SET(c->efd, readset);
	}
	/* XXX: What about efd? races? */
}

/*
 * This is a special state for X11 authentication spoofing.  An opened X11
 * connection (when authentication spoofing is being done) remains in this
 * state until the first packet has been completely read.  The authentication
 * data in that packet is then substituted by the real data if it matches the
 * fake data, and the channel is put into normal mode.
 * XXX All this happens at the client side.
 * Returns: 0 = need more data, -1 = wrong cookie, 1 = ok
 */
static int
x11_open_helper(struct ssh *ssh, struct sshbuf *b)
{
	struct ssh_channels *sc = ssh->chanctxt;
	u_char *ucp;
	u_int proto_len, data_len;

	/* Is this being called after the refusal deadline? */
	if (sc->x11_refuse_time != 0 &&
	    (u_int)monotime() >= sc->x11_refuse_time) {
		verbose("Rejected X11 connection after ForwardX11Timeout "
		    "expired");
		return -1;
	}

	/* Check if the fixed size part of the packet is in buffer. */
	if (sshbuf_len(b) < 12)
		return 0;

	/* Parse the lengths of variable-length fields. */
	ucp = sshbuf_mutable_ptr(b);
	if (ucp[0] == 0x42) {	/* Byte order MSB first. */
		proto_len = 256 * ucp[6] + ucp[7];
		data_len = 256 * ucp[8] + ucp[9];
	} else if (ucp[0] == 0x6c) {	/* Byte order LSB first. */
		proto_len = ucp[6] + 256 * ucp[7];
		data_len = ucp[8] + 256 * ucp[9];
	} else {
		debug2("Initial X11 packet contains bad byte order byte: 0x%x",
		    ucp[0]);
		return -1;
	}

	/* Check if the whole packet is in buffer. */
	if (sshbuf_len(b) <
	    12 + ((proto_len + 3) & ~3) + ((data_len + 3) & ~3))
		return 0;

	/* Check if authentication protocol matches. */
	if (proto_len != strlen(sc->x11_saved_proto) ||
	    memcmp(ucp + 12, sc->x11_saved_proto, proto_len) != 0) {
		debug2("X11 connection uses different authentication protocol.");
		return -1;
	}
	/* Check if authentication data matches our fake data. */
	if (data_len != sc->x11_fake_data_len ||
	    timingsafe_bcmp(ucp + 12 + ((proto_len + 3) & ~3),
		sc->x11_fake_data, sc->x11_fake_data_len) != 0) {
		debug2("X11 auth data does not match fake data.");
		return -1;
	}
	/* Check fake data length */
	if (sc->x11_fake_data_len != sc->x11_saved_data_len) {
		error("X11 fake_data_len %d != saved_data_len %d",
		    sc->x11_fake_data_len, sc->x11_saved_data_len);
		return -1;
	}
	/*
	 * Received authentication protocol and data match
	 * our fake data. Substitute the fake data with real
	 * data.
	 */
	memcpy(ucp + 12 + ((proto_len + 3) & ~3),
	    sc->x11_saved_data, sc->x11_saved_data_len);
	return 1;
}

static void
channel_pre_x11_open(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	int ret = x11_open_helper(ssh, c->output);

	/* c->force_drain = 1; */

	if (ret == 1) {
		c->type = SSH_CHANNEL_OPEN;
		channel_pre_open(ssh, c, readset, writeset);
	} else if (ret == -1) {
		logit("X11 connection rejected because of wrong authentication.");
		debug2("X11 rejected %d i%d/o%d",
		    c->self, c->istate, c->ostate);
		chan_read_failed(ssh, c);
		sshbuf_reset(c->input);
		chan_ibuf_empty(ssh, c);
		sshbuf_reset(c->output);
		chan_write_failed(ssh, c);
		debug2("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
	}
}

static void
channel_pre_mux_client(struct ssh *ssh,
    Channel *c, fd_set *readset, fd_set *writeset)
{
	if (c->istate == CHAN_INPUT_OPEN && !c->mux_pause &&
	    sshbuf_check_reserve(c->input, CHAN_RBUF) == 0)
		FD_SET(c->rfd, readset);
	if (c->istate == CHAN_INPUT_WAIT_DRAIN) {
		/* clear buffer immediately (discard any partial packet) */
		sshbuf_reset(c->input);
		chan_ibuf_empty(ssh, c);
		/* Start output drain. XXX just kill chan? */
		chan_rcvd_oclose(ssh, c);
	}
	if (c->ostate == CHAN_OUTPUT_OPEN ||
	    c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {
		if (sshbuf_len(c->output) > 0)
			FD_SET(c->wfd, writeset);
		else if (c->ostate == CHAN_OUTPUT_WAIT_DRAIN)
			chan_obuf_empty(ssh, c);
	}
}

/* try to decode a socks4 header */
static int
channel_decode_socks4(Channel *c, struct sshbuf *input, struct sshbuf *output)
{
	const u_char *p;
	char *host;
	u_int len, have, i, found, need;
	char username[256];
	struct {
		u_int8_t version;
		u_int8_t command;
		u_int16_t dest_port;
		struct in_addr dest_addr;
	} s4_req, s4_rsp;
	int r;

	debug2("channel %d: decode socks4", c->self);

	have = sshbuf_len(input);
	len = sizeof(s4_req);
	if (have < len)
		return 0;
	p = sshbuf_ptr(input);

	need = 1;
	/* SOCKS4A uses an invalid IP address 0.0.0.x */
	if (p[4] == 0 && p[5] == 0 && p[6] == 0 && p[7] != 0) {
		debug2("channel %d: socks4a request", c->self);
		/* ... and needs an extra string (the hostname) */
		need = 2;
	}
	/* Check for terminating NUL on the string(s) */
	for (found = 0, i = len; i < have; i++) {
		if (p[i] == '\0') {
			found++;
			if (found == need)
				break;
		}
		if (i > 1024) {
			/* the peer is probably sending garbage */
			debug("channel %d: decode socks4: too long",
			    c->self);
			return -1;
		}
	}
	if (found < need)
		return 0;
	if ((r = sshbuf_get(input, &s4_req.version, 1)) != 0 ||
	    (r = sshbuf_get(input, &s4_req.command, 1)) != 0 ||
	    (r = sshbuf_get(input, &s4_req.dest_port, 2)) != 0 ||
	    (r = sshbuf_get(input, &s4_req.dest_addr, 4)) != 0) {
		debug("channels %d: decode socks4: %s", c->self, ssh_err(r));
		return -1;
	}
	have = sshbuf_len(input);
	p = sshbuf_ptr(input);
	if (memchr(p, '\0', have) == NULL) {
		error("channel %d: decode socks4: user not nul terminated",
		    c->self);
		return -1;
	}
	len = strlen(p);
	debug2("channel %d: decode socks4: user %s/%d", c->self, p, len);
	len++; /* trailing '\0' */
	strlcpy(username, p, sizeof(username));
	if ((r = sshbuf_consume(input, len)) != 0) {
		fatal("%s: channel %d: consume: %s", __func__,
		    c->self, ssh_err(r));
	}
	free(c->path);
	c->path = NULL;
	if (need == 1) {			/* SOCKS4: one string */
		host = inet_ntoa(s4_req.dest_addr);
		c->path = xstrdup(host);
	} else {				/* SOCKS4A: two strings */
		have = sshbuf_len(input);
		p = sshbuf_ptr(input);
		if (memchr(p, '\0', have) == NULL) {
			error("channel %d: decode socks4a: host not nul "
			    "terminated", c->self);
			return -1;
		}
		len = strlen(p);
		debug2("channel %d: decode socks4a: host %s/%d",
		    c->self, p, len);
		len++;				/* trailing '\0' */
		if (len > NI_MAXHOST) {
			error("channel %d: hostname \"%.100s\" too long",
			    c->self, p);
			return -1;
		}
		c->path = xstrdup(p);
		if ((r = sshbuf_consume(input, len)) != 0) {
			fatal("%s: channel %d: consume: %s", __func__,
			    c->self, ssh_err(r));
		}
	}
	c->host_port = ntohs(s4_req.dest_port);

	debug2("channel %d: dynamic request: socks4 host %s port %u command %u",
	    c->self, c->path, c->host_port, s4_req.command);

	if (s4_req.command != 1) {
		debug("channel %d: cannot handle: %s cn %d",
		    c->self, need == 1 ? "SOCKS4" : "SOCKS4A", s4_req.command);
		return -1;
	}
	s4_rsp.version = 0;			/* vn: 0 for reply */
	s4_rsp.command = 90;			/* cd: req granted */
	s4_rsp.dest_port = 0;			/* ignored */
	s4_rsp.dest_addr.s_addr = INADDR_ANY;	/* ignored */
	if ((r = sshbuf_put(output, &s4_rsp, sizeof(s4_rsp))) != 0) {
		fatal("%s: channel %d: append reply: %s", __func__,
		    c->self, ssh_err(r));
	}
	return 1;
}

/* try to decode a socks5 header */
#define SSH_SOCKS5_AUTHDONE	0x1000
#define SSH_SOCKS5_NOAUTH	0x00
#define SSH_SOCKS5_IPV4		0x01
#define SSH_SOCKS5_DOMAIN	0x03
#define SSH_SOCKS5_IPV6		0x04
#define SSH_SOCKS5_CONNECT	0x01
#define SSH_SOCKS5_SUCCESS	0x00

static int
channel_decode_socks5(Channel *c, struct sshbuf *input, struct sshbuf *output)
{
	/* XXX use get/put_u8 instead of trusting struct padding */
	struct {
		u_int8_t version;
		u_int8_t command;
		u_int8_t reserved;
		u_int8_t atyp;
	} s5_req, s5_rsp;
	u_int16_t dest_port;
	char dest_addr[255+1], ntop[INET6_ADDRSTRLEN];
	const u_char *p;
	u_int have, need, i, found, nmethods, addrlen, af;
	int r;

	debug2("channel %d: decode socks5", c->self);
	p = sshbuf_ptr(input);
	if (p[0] != 0x05)
		return -1;
	have = sshbuf_len(input);
	if (!(c->flags & SSH_SOCKS5_AUTHDONE)) {
		/* format: ver | nmethods | methods */
		if (have < 2)
			return 0;
		nmethods = p[1];
		if (have < nmethods + 2)
			return 0;
		/* look for method: "NO AUTHENTICATION REQUIRED" */
		for (found = 0, i = 2; i < nmethods + 2; i++) {
			if (p[i] == SSH_SOCKS5_NOAUTH) {
				found = 1;
				break;
			}
		}
		if (!found) {
			debug("channel %d: method SSH_SOCKS5_NOAUTH not found",
			    c->self);
			return -1;
		}
		if ((r = sshbuf_consume(input, nmethods + 2)) != 0) {
			fatal("%s: channel %d: consume: %s", __func__,
			    c->self, ssh_err(r));
		}
		/* version, method */
		if ((r = sshbuf_put_u8(output, 0x05)) != 0 ||
		    (r = sshbuf_put_u8(output, SSH_SOCKS5_NOAUTH)) != 0) {
			fatal("%s: channel %d: append reply: %s", __func__,
			    c->self, ssh_err(r));
		}
		c->flags |= SSH_SOCKS5_AUTHDONE;
		debug2("channel %d: socks5 auth done", c->self);
		return 0;				/* need more */
	}
	debug2("channel %d: socks5 post auth", c->self);
	if (have < sizeof(s5_req)+1)
		return 0;			/* need more */
	memcpy(&s5_req, p, sizeof(s5_req));
	if (s5_req.version != 0x05 ||
	    s5_req.command != SSH_SOCKS5_CONNECT ||
	    s5_req.reserved != 0x00) {
		debug2("channel %d: only socks5 connect supported", c->self);
		return -1;
	}
	switch (s5_req.atyp){
	case SSH_SOCKS5_IPV4:
		addrlen = 4;
		af = AF_INET;
		break;
	case SSH_SOCKS5_DOMAIN:
		addrlen = p[sizeof(s5_req)];
		af = -1;
		break;
	case SSH_SOCKS5_IPV6:
		addrlen = 16;
		af = AF_INET6;
		break;
	default:
		debug2("channel %d: bad socks5 atyp %d", c->self, s5_req.atyp);
		return -1;
	}
	need = sizeof(s5_req) + addrlen + 2;
	if (s5_req.atyp == SSH_SOCKS5_DOMAIN)
		need++;
	if (have < need)
		return 0;
	if ((r = sshbuf_consume(input, sizeof(s5_req))) != 0) {
		fatal("%s: channel %d: consume: %s", __func__,
		    c->self, ssh_err(r));
	}
	if (s5_req.atyp == SSH_SOCKS5_DOMAIN) {
		/* host string length */
		if ((r = sshbuf_consume(input, 1)) != 0) {
			fatal("%s: channel %d: consume: %s", __func__,
			    c->self, ssh_err(r));
		}
	}
	if ((r = sshbuf_get(input, &dest_addr, addrlen)) != 0 ||
	    (r = sshbuf_get(input, &dest_port, 2)) != 0) {
		debug("channel %d: parse addr/port: %s", c->self, ssh_err(r));
		return -1;
	}
	dest_addr[addrlen] = '\0';
	free(c->path);
	c->path = NULL;
	if (s5_req.atyp == SSH_SOCKS5_DOMAIN) {
		if (addrlen >= NI_MAXHOST) {
			error("channel %d: dynamic request: socks5 hostname "
			    "\"%.100s\" too long", c->self, dest_addr);
			return -1;
		}
		c->path = xstrdup(dest_addr);
	} else {
		if (inet_ntop(af, dest_addr, ntop, sizeof(ntop)) == NULL)
			return -1;
		c->path = xstrdup(ntop);
	}
	c->host_port = ntohs(dest_port);

	debug2("channel %d: dynamic request: socks5 host %s port %u command %u",
	    c->self, c->path, c->host_port, s5_req.command);

	s5_rsp.version = 0x05;
	s5_rsp.command = SSH_SOCKS5_SUCCESS;
	s5_rsp.reserved = 0;			/* ignored */
	s5_rsp.atyp = SSH_SOCKS5_IPV4;
	dest_port = 0;				/* ignored */

	if ((r = sshbuf_put(output, &s5_rsp, sizeof(s5_rsp))) != 0 ||
	    (r = sshbuf_put_u32(output, ntohl(INADDR_ANY))) != 0 ||
	    (r = sshbuf_put(output, &dest_port, sizeof(dest_port))) != 0)
		fatal("%s: channel %d: append reply: %s", __func__,
		    c->self, ssh_err(r));
	return 1;
}

Channel *
channel_connect_stdio_fwd(struct ssh *ssh,
    const char *host_to_connect, u_short port_to_connect, int in, int out)
{
	Channel *c;

	debug("%s %s:%d", __func__, host_to_connect, port_to_connect);

	c = channel_new(ssh, "stdio-forward", SSH_CHANNEL_OPENING, in, out,
	    -1, CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,
	    0, "stdio-forward", /*nonblock*/0);

	c->path = xstrdup(host_to_connect);
	c->host_port = port_to_connect;
	c->listening_port = 0;
	c->force_drain = 1;

	channel_register_fds(ssh, c, in, out, -1, 0, 1, 0);
	port_open_helper(ssh, c, "direct-tcpip");

	return c;
}

/* dynamic port forwarding */
static void
channel_pre_dynamic(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	const u_char *p;
	u_int have;
	int ret;

	have = sshbuf_len(c->input);
	debug2("channel %d: pre_dynamic: have %d", c->self, have);
	/* sshbuf_dump(c->input, stderr); */
	/* check if the fixed size part of the packet is in buffer. */
	if (have < 3) {
		/* need more */
		FD_SET(c->sock, readset);
		return;
	}
	/* try to guess the protocol */
	p = sshbuf_ptr(c->input);
	/* XXX sshbuf_peek_u8? */
	switch (p[0]) {
	case 0x04:
		ret = channel_decode_socks4(c, c->input, c->output);
		break;
	case 0x05:
		ret = channel_decode_socks5(c, c->input, c->output);
		break;
	default:
		ret = -1;
		break;
	}
	if (ret < 0) {
		chan_mark_dead(ssh, c);
	} else if (ret == 0) {
		debug2("channel %d: pre_dynamic: need more", c->self);
		/* need more */
		FD_SET(c->sock, readset);
		if (sshbuf_len(c->output))
			FD_SET(c->sock, writeset);
	} else {
		/* switch to the next state */
		c->type = SSH_CHANNEL_OPENING;
		port_open_helper(ssh, c, "direct-tcpip");
	}
}

/* simulate read-error */
static void
rdynamic_close(struct ssh *ssh, Channel *c)
{
	c->type = SSH_CHANNEL_OPEN;
	chan_read_failed(ssh, c);
	sshbuf_reset(c->input);
	chan_ibuf_empty(ssh, c);
	sshbuf_reset(c->output);
	chan_write_failed(ssh, c);
}

/* reverse dynamic port forwarding */
static void
channel_before_prepare_select_rdynamic(struct ssh *ssh, Channel *c)
{
	const u_char *p;
	u_int have, len;
	int r, ret;

	have = sshbuf_len(c->output);
	debug2("channel %d: pre_rdynamic: have %d", c->self, have);
	/* sshbuf_dump(c->output, stderr); */
	/* EOF received */
	if (c->flags & CHAN_EOF_RCVD) {
		if ((r = sshbuf_consume(c->output, have)) != 0) {
			fatal("%s: channel %d: consume: %s",
			    __func__, c->self, ssh_err(r));
		}
		rdynamic_close(ssh, c);
		return;
	}
	/* check if the fixed size part of the packet is in buffer. */
	if (have < 3)
		return;
	/* try to guess the protocol */
	p = sshbuf_ptr(c->output);
	switch (p[0]) {
	case 0x04:
		/* switch input/output for reverse forwarding */
		ret = channel_decode_socks4(c, c->output, c->input);
		break;
	case 0x05:
		ret = channel_decode_socks5(c, c->output, c->input);
		break;
	default:
		ret = -1;
		break;
	}
	if (ret < 0) {
		rdynamic_close(ssh, c);
	} else if (ret == 0) {
		debug2("channel %d: pre_rdynamic: need more", c->self);
		/* send socks request to peer */
		len = sshbuf_len(c->input);
		if (len > 0 && len < c->remote_window) {
			if ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||
			    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||
			    (r = sshpkt_put_stringb(ssh, c->input)) != 0 ||
			    (r = sshpkt_send(ssh)) != 0) {
				fatal("%s: channel %i: rdynamic: %s", __func__,
				    c->self, ssh_err(r));
			}
			if ((r = sshbuf_consume(c->input, len)) != 0) {
				fatal("%s: channel %d: consume: %s",
				    __func__, c->self, ssh_err(r));
			}
			c->remote_window -= len;
		}
	} else if (rdynamic_connect_finish(ssh, c) < 0) {
		/* the connect failed */
		rdynamic_close(ssh, c);
	}
}

/* This is our fake X11 server socket. */
static void
channel_post_x11_listener(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	Channel *nc;
	struct sockaddr_storage addr;
	int r, newsock, oerrno, remote_port;
	socklen_t addrlen;
	char buf[16384], *remote_ipaddr;

	if (!FD_ISSET(c->sock, readset))
		return;

	debug("X11 connection requested.");
	addrlen = sizeof(addr);
	newsock = accept(c->sock, (struct sockaddr *)&addr, &addrlen);
	if (c->single_connection) {
		oerrno = errno;
		debug2("single_connection: closing X11 listener.");
		channel_close_fd(ssh, &c->sock);
		chan_mark_dead(ssh, c);
		errno = oerrno;
	}
	if (newsock < 0) {
		if (errno != EINTR && errno != EWOULDBLOCK &&
		    errno != ECONNABORTED)
			error("accept: %.100s", strerror(errno));
		if (errno == EMFILE || errno == ENFILE)
			c->notbefore = monotime() + 1;
		return;
	}
	set_nodelay(newsock);
	remote_ipaddr = get_peer_ipaddr(newsock);
	remote_port = get_peer_port(newsock);
	snprintf(buf, sizeof buf, "X11 connection from %.200s port %d",
	    remote_ipaddr, remote_port);

	nc = channel_new(ssh, "accepted x11 socket",
	    SSH_CHANNEL_OPENING, newsock, newsock, -1,
	    c->local_window_max, c->local_maxpacket, 0, buf, 1);
	open_preamble(ssh, __func__, nc, "x11");
	if ((r = sshpkt_put_cstring(ssh, remote_ipaddr)) != 0) {
		fatal("%s: channel %i: reply %s", __func__,
		    c->self, ssh_err(r));
	}
	if ((datafellows & SSH_BUG_X11FWD) != 0)
		debug2("channel %d: ssh2 x11 bug compat mode", nc->self);
	else if ((r = sshpkt_put_u32(ssh, remote_port)) != 0) {
		fatal("%s: channel %i: reply %s", __func__,
		    c->self, ssh_err(r));
	}
	if ((r = sshpkt_send(ssh)) != 0)
		fatal("%s: channel %i: send %s", __func__, c->self, ssh_err(r));
	free(remote_ipaddr);
}

static void
port_open_helper(struct ssh *ssh, Channel *c, char *rtype)
{
	char *local_ipaddr = get_local_ipaddr(c->sock);
	int local_port = c->sock == -1 ? 65536 : get_local_port(c->sock);
	char *remote_ipaddr = get_peer_ipaddr(c->sock);
	int remote_port = get_peer_port(c->sock);
	int r;

	if (remote_port == -1) {
		/* Fake addr/port to appease peers that validate it (Tectia) */
		free(remote_ipaddr);
		remote_ipaddr = xstrdup("127.0.0.1");
		remote_port = 65535;
	}

	free(c->remote_name);
	xasprintf(&c->remote_name,
	    "%s: listening port %d for %.100s port %d, "
	    "connect from %.200s port %d to %.100s port %d",
	    rtype, c->listening_port, c->path, c->host_port,
	    remote_ipaddr, remote_port, local_ipaddr, local_port);

	open_preamble(ssh, __func__, c, rtype);
	if (strcmp(rtype, "direct-tcpip") == 0) {
		/* target host, port */
		if ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||
		    (r = sshpkt_put_u32(ssh, c->host_port)) != 0) {
			fatal("%s: channel %i: reply %s", __func__,
			    c->self, ssh_err(r));
		}
	} else if (strcmp(rtype, "direct-streamlocal@@openssh.com") == 0) {
		/* target path */
		if ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {
			fatal("%s: channel %i: reply %s", __func__,
			    c->self, ssh_err(r));
		}
	} else if (strcmp(rtype, "forwarded-streamlocal@@openssh.com") == 0) {
		/* listen path */
		if ((r = sshpkt_put_cstring(ssh, c->path)) != 0) {
			fatal("%s: channel %i: reply %s", __func__,
			    c->self, ssh_err(r));
		}
	} else {
		/* listen address, port */
		if ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||
		    (r = sshpkt_put_u32(ssh, local_port)) != 0) {
			fatal("%s: channel %i: reply %s", __func__,
			    c->self, ssh_err(r));
		}
	}
	if (strcmp(rtype, "forwarded-streamlocal@@openssh.com") == 0) {
		/* reserved for future owner/mode info */
		if ((r = sshpkt_put_cstring(ssh, "")) != 0) {
			fatal("%s: channel %i: reply %s", __func__,
			    c->self, ssh_err(r));
		}
	} else {
		/* originator host and port */
		if ((r = sshpkt_put_cstring(ssh, remote_ipaddr)) != 0 ||
		    (r = sshpkt_put_u32(ssh, (u_int)remote_port)) != 0) {
			fatal("%s: channel %i: reply %s", __func__,
			    c->self, ssh_err(r));
		}
	}
	if ((r = sshpkt_send(ssh)) != 0)
		fatal("%s: channel %i: send %s", __func__, c->self, ssh_err(r));
	free(remote_ipaddr);
	free(local_ipaddr);
}

static void
channel_set_reuseaddr(int fd)
{
	int on = 1;

	/*
	 * Set socket options.
	 * Allow local port reuse in TIME_WAIT.
	 */
	if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1)
		error("setsockopt SO_REUSEADDR fd %d: %s", fd, strerror(errno));
}

void
channel_set_x11_refuse_time(struct ssh *ssh, u_int refuse_time)
{
	ssh->chanctxt->x11_refuse_time = refuse_time;
}

/*
 * This socket is listening for connections to a forwarded TCP/IP port.
 */
static void
channel_post_port_listener(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	Channel *nc;
	struct sockaddr_storage addr;
	int newsock, nextstate;
	socklen_t addrlen;
	char *rtype;

	if (!FD_ISSET(c->sock, readset))
		return;

	debug("Connection to port %d forwarding to %.100s port %d requested.",
	    c->listening_port, c->path, c->host_port);

	if (c->type == SSH_CHANNEL_RPORT_LISTENER) {
		nextstate = SSH_CHANNEL_OPENING;
		rtype = "forwarded-tcpip";
	} else if (c->type == SSH_CHANNEL_RUNIX_LISTENER) {
		nextstate = SSH_CHANNEL_OPENING;
		rtype = "forwarded-streamlocal@@openssh.com";
	} else if (c->host_port == PORT_STREAMLOCAL) {
		nextstate = SSH_CHANNEL_OPENING;
		rtype = "direct-streamlocal@@openssh.com";
	} else if (c->host_port == 0) {
		nextstate = SSH_CHANNEL_DYNAMIC;
		rtype = "dynamic-tcpip";
	} else {
		nextstate = SSH_CHANNEL_OPENING;
		rtype = "direct-tcpip";
	}

	addrlen = sizeof(addr);
	newsock = accept(c->sock, (struct sockaddr *)&addr, &addrlen);
	if (newsock < 0) {
		if (errno != EINTR && errno != EWOULDBLOCK &&
		    errno != ECONNABORTED)
			error("accept: %.100s", strerror(errno));
		if (errno == EMFILE || errno == ENFILE)
			c->notbefore = monotime() + 1;
		return;
	}
	if (c->host_port != PORT_STREAMLOCAL)
		set_nodelay(newsock);
	nc = channel_new(ssh, rtype, nextstate, newsock, newsock, -1,
	    c->local_window_max, c->local_maxpacket, 0, rtype, 1);
	nc->listening_port = c->listening_port;
	nc->host_port = c->host_port;
	if (c->path != NULL)
		nc->path = xstrdup(c->path);

	if (nextstate != SSH_CHANNEL_DYNAMIC)
		port_open_helper(ssh, nc, rtype);
}

/*
 * This is the authentication agent socket listening for connections from
 * clients.
 */
static void
channel_post_auth_listener(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	Channel *nc;
	int r, newsock;
	struct sockaddr_storage addr;
	socklen_t addrlen;

	if (!FD_ISSET(c->sock, readset))
		return;

	addrlen = sizeof(addr);
	newsock = accept(c->sock, (struct sockaddr *)&addr, &addrlen);
	if (newsock < 0) {
		error("accept from auth socket: %.100s", strerror(errno));
		if (errno == EMFILE || errno == ENFILE)
			c->notbefore = monotime() + 1;
		return;
	}
	nc = channel_new(ssh, "accepted auth socket",
	    SSH_CHANNEL_OPENING, newsock, newsock, -1,
	    c->local_window_max, c->local_maxpacket,
	    0, "accepted auth socket", 1);
	open_preamble(ssh, __func__, nc, "auth-agent@@openssh.com");
	if ((r = sshpkt_send(ssh)) != 0)
		fatal("%s: channel %i: %s", __func__, c->self, ssh_err(r));
}

static void
channel_post_connecting(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	int err = 0, sock, isopen, r;
	socklen_t sz = sizeof(err);

	if (!FD_ISSET(c->sock, writeset))
		return;
	if (!c->have_remote_id)
		fatal(":%s: channel %d: no remote id", __func__, c->self);
	/* for rdynamic the OPEN_CONFIRMATION has been sent already */
	isopen = (c->type == SSH_CHANNEL_RDYNAMIC_FINISH);
	if (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, &err, &sz) < 0) {
		err = errno;
		error("getsockopt SO_ERROR failed");
	}
	if (err == 0) {
		debug("channel %d: connected to %s port %d",
		    c->self, c->connect_ctx.host, c->connect_ctx.port);
		channel_connect_ctx_free(&c->connect_ctx);
		c->type = SSH_CHANNEL_OPEN;
		if (isopen) {
			/* no message necessary */
		} else {
			if ((r = sshpkt_start(ssh,
			    SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||
			    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||
			    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||
			    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||
			    (r = sshpkt_put_u32(ssh, c->local_maxpacket))
			    != 0)
				fatal("%s: channel %i: confirm: %s", __func__,
				    c->self, ssh_err(r));
			if ((r = sshpkt_send(ssh)) != 0)
				fatal("%s: channel %i: %s", __func__, c->self,
				    ssh_err(r));
		}
	} else {
		debug("channel %d: connection failed: %s",
		    c->self, strerror(err));
		/* Try next address, if any */
		if ((sock = connect_next(&c->connect_ctx)) > 0) {
			close(c->sock);
			c->sock = c->rfd = c->wfd = sock;
			channel_find_maxfd(ssh->chanctxt);
			return;
		}
		/* Exhausted all addresses */
		error("connect_to %.100s port %d: failed.",
		    c->connect_ctx.host, c->connect_ctx.port);
		channel_connect_ctx_free(&c->connect_ctx);
		if (isopen) {
			rdynamic_close(ssh, c);
		} else {
			if ((r = sshpkt_start(ssh,
			    SSH2_MSG_CHANNEL_OPEN_FAILURE)) != 0 ||
			    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||
			    (r = sshpkt_put_u32(ssh, SSH2_OPEN_CONNECT_FAILED))
			    != 0)
				fatal("%s: channel %i: failure: %s", __func__,
				    c->self, ssh_err(r));
			if ((datafellows & SSH_BUG_OPENFAILURE) == 0 &&
			    ((r = sshpkt_put_cstring(ssh, strerror(err))) != 0 ||
			    (r = sshpkt_put_cstring(ssh, "")) != 0))
				fatal("%s: channel %i: failure: %s", __func__,
				    c->self, ssh_err(r));
			if ((r = sshpkt_send(ssh)) != 0)
				fatal("%s: channel %i: %s", __func__, c->self,
				    ssh_err(r));
			chan_mark_dead(ssh, c);
		}
	}
}

static int
channel_handle_rfd(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	char buf[CHAN_RBUF];
	ssize_t len;
	int r;

	if (c->rfd == -1 || !FD_ISSET(c->rfd, readset))
		return 1;

	len = read(c->rfd, buf, sizeof(buf));
	if (len < 0 && (errno == EINTR || errno == EAGAIN))
		return 1;
	if (len <= 0) {
		debug2("channel %d: read<=0 rfd %d len %zd",
		    c->self, c->rfd, len);
		if (c->type != SSH_CHANNEL_OPEN) {
			debug2("channel %d: not open", c->self);
			chan_mark_dead(ssh, c);
			return -1;
		} else {
			chan_read_failed(ssh, c);
		}
		return -1;
	}
	if (c->input_filter != NULL) {
		if (c->input_filter(ssh, c, buf, len) == -1) {
			debug2("channel %d: filter stops", c->self);
			chan_read_failed(ssh, c);
		}
	} else if (c->datagram) {
		if ((r = sshbuf_put_string(c->input, buf, len)) != 0)
			fatal("%s: channel %d: put datagram: %s", __func__,
			    c->self, ssh_err(r));
	} else if ((r = sshbuf_put(c->input, buf, len)) != 0) {
		fatal("%s: channel %d: put data: %s", __func__,
		    c->self, ssh_err(r));
	}
	return 1;
}

static int
channel_handle_wfd(struct ssh *ssh, Channel *c,
   fd_set *readset, fd_set *writeset)
{
	struct termios tio;
	u_char *data = NULL, *buf; /* XXX const; need filter API change */
	size_t dlen, olen = 0;
	int r, len;

	if (c->wfd == -1 || !FD_ISSET(c->wfd, writeset) ||
	    sshbuf_len(c->output) == 0)
		return 1;

	/* Send buffered output data to the socket. */
	olen = sshbuf_len(c->output);
	if (c->output_filter != NULL) {
		if ((buf = c->output_filter(ssh, c, &data, &dlen)) == NULL) {
			debug2("channel %d: filter stops", c->self);
			if (c->type != SSH_CHANNEL_OPEN)
				chan_mark_dead(ssh, c);
			else
				chan_write_failed(ssh, c);
			return -1;
		}
	} else if (c->datagram) {
		if ((r = sshbuf_get_string(c->output, &data, &dlen)) != 0)
			fatal("%s: channel %d: get datagram: %s", __func__,
			    c->self, ssh_err(r));
		buf = data;
	} else {
		buf = data = sshbuf_mutable_ptr(c->output);
		dlen = sshbuf_len(c->output);
	}

	if (c->datagram) {
		/* ignore truncated writes, datagrams might get lost */
		len = write(c->wfd, buf, dlen);
		free(data);
		if (len < 0 && (errno == EINTR || errno == EAGAIN))
			return 1;
		if (len <= 0)
			goto write_fail;
		goto out;
	}

	len = write(c->wfd, buf, dlen);
	if (len < 0 && (errno == EINTR || errno == EAGAIN))
		return 1;
	if (len <= 0) {
 write_fail:
		if (c->type != SSH_CHANNEL_OPEN) {
			debug2("channel %d: not open", c->self);
			chan_mark_dead(ssh, c);
			return -1;
		} else {
			chan_write_failed(ssh, c);
		}
		return -1;
	}
	if (c->isatty && dlen >= 1 && buf[0] != '\r') {
		if (tcgetattr(c->wfd, &tio) == 0 &&
		    !(tio.c_lflag & ECHO) && (tio.c_lflag & ICANON)) {
			/*
			 * Simulate echo to reduce the impact of
			 * traffic analysis. We need to match the
			 * size of a SSH2_MSG_CHANNEL_DATA message
			 * (4 byte channel id + buf)
			 */
			if ((r = sshpkt_msg_ignore(ssh, 4+len)) != 0 ||
			    (r = sshpkt_send(ssh)) != 0)
				fatal("%s: channel %d: ignore: %s",
				    __func__, c->self, ssh_err(r));
		}
	}
	if ((r = sshbuf_consume(c->output, len)) != 0) {
		fatal("%s: channel %d: consume: %s",
		    __func__, c->self, ssh_err(r));
	}
 out:
	c->local_consumed += olen - sshbuf_len(c->output);

	return 1;
}

static int
channel_handle_efd_write(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	int r;
	ssize_t len;

	if (!FD_ISSET(c->efd, writeset) || sshbuf_len(c->extended) == 0)
		return 1;

	len = write(c->efd, sshbuf_ptr(c->extended),
	    sshbuf_len(c->extended));
	debug2("channel %d: written %zd to efd %d", c->self, len, c->efd);
	if (len < 0 && (errno == EINTR || errno == EAGAIN))
		return 1;
	if (len <= 0) {
		debug2("channel %d: closing write-efd %d", c->self, c->efd);
		channel_close_fd(ssh, &c->efd);
	} else {
		if ((r = sshbuf_consume(c->extended, len)) != 0) {
			fatal("%s: channel %d: consume: %s",
			    __func__, c->self, ssh_err(r));
		}
		c->local_consumed += len;
	}
	return 1;
}

static int
channel_handle_efd_read(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	char buf[CHAN_RBUF];
	int r;
	ssize_t len;

	if (!FD_ISSET(c->efd, readset))
		return 1;

	len = read(c->efd, buf, sizeof(buf));
	debug2("channel %d: read %zd from efd %d", c->self, len, c->efd);
	if (len < 0 && (errno == EINTR || errno == EAGAIN))
		return 1;
	if (len <= 0) {
		debug2("channel %d: closing read-efd %d",
		    c->self, c->efd);
		channel_close_fd(ssh, &c->efd);
	} else {
		if (c->extended_usage == CHAN_EXTENDED_IGNORE) {
			debug3("channel %d: discard efd",
			    c->self);
		} else if ((r = sshbuf_put(c->extended, buf, len)) != 0) {
			fatal("%s: channel %d: append: %s",
			    __func__, c->self, ssh_err(r));
		}
	}
	return 1;
}

static int
channel_handle_efd(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	if (c->efd == -1)
		return 1;

	/** XXX handle drain efd, too */

	if (c->extended_usage == CHAN_EXTENDED_WRITE)
		return channel_handle_efd_write(ssh, c, readset, writeset);
	else if (c->extended_usage == CHAN_EXTENDED_READ ||
	    c->extended_usage == CHAN_EXTENDED_IGNORE)
		return channel_handle_efd_read(ssh, c, readset, writeset);

	return 1;
}

static int
channel_check_window(struct ssh *ssh, Channel *c)
{
	int r;

	if (c->type == SSH_CHANNEL_OPEN &&
	    !(c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD)) &&
	    ((c->local_window_max - c->local_window >
	    c->local_maxpacket*3) ||
	    c->local_window < c->local_window_max/2) &&
	    c->local_consumed > 0) {
		if (!c->have_remote_id)
			fatal(":%s: channel %d: no remote id",
			    __func__, c->self);
		if ((r = sshpkt_start(ssh,
		    SSH2_MSG_CHANNEL_WINDOW_ADJUST)) != 0 ||
		    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||
		    (r = sshpkt_put_u32(ssh, c->local_consumed)) != 0 ||
		    (r = sshpkt_send(ssh)) != 0) {
			fatal("%s: channel %i: %s", __func__,
			    c->self, ssh_err(r));
		}
		debug2("channel %d: window %d sent adjust %d",
		    c->self, c->local_window,
		    c->local_consumed);
		c->local_window += c->local_consumed;
		c->local_consumed = 0;
	}
	return 1;
}

static void
channel_post_open(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	channel_handle_rfd(ssh, c, readset, writeset);
	channel_handle_wfd(ssh, c, readset, writeset);
	channel_handle_efd(ssh, c, readset, writeset);
	channel_check_window(ssh, c);
}

static u_int
read_mux(struct ssh *ssh, Channel *c, u_int need)
{
	char buf[CHAN_RBUF];
	ssize_t len;
	u_int rlen;
	int r;

	if (sshbuf_len(c->input) < need) {
		rlen = need - sshbuf_len(c->input);
		len = read(c->rfd, buf, MINIMUM(rlen, CHAN_RBUF));
		if (len < 0 && (errno == EINTR || errno == EAGAIN))
			return sshbuf_len(c->input);
		if (len <= 0) {
			debug2("channel %d: ctl read<=0 rfd %d len %zd",
			    c->self, c->rfd, len);
			chan_read_failed(ssh, c);
			return 0;
		} else if ((r = sshbuf_put(c->input, buf, len)) != 0) {
			fatal("%s: channel %d: append: %s",
			    __func__, c->self, ssh_err(r));
		}
	}
	return sshbuf_len(c->input);
}

static void
channel_post_mux_client_read(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	u_int need;

	if (c->rfd == -1 || !FD_ISSET(c->rfd, readset))
		return;
	if (c->istate != CHAN_INPUT_OPEN && c->istate != CHAN_INPUT_WAIT_DRAIN)
		return;
	if (c->mux_pause)
		return;

	/*
	 * Don't not read past the precise end of packets to
	 * avoid disrupting fd passing.
	 */
	if (read_mux(ssh, c, 4) < 4) /* read header */
		return;
	/* XXX sshbuf_peek_u32 */
	need = PEEK_U32(sshbuf_ptr(c->input));
#define CHANNEL_MUX_MAX_PACKET	(256 * 1024)
	if (need > CHANNEL_MUX_MAX_PACKET) {
		debug2("channel %d: packet too big %u > %u",
		    c->self, CHANNEL_MUX_MAX_PACKET, need);
		chan_rcvd_oclose(ssh, c);
		return;
	}
	if (read_mux(ssh, c, need + 4) < need + 4) /* read body */
		return;
	if (c->mux_rcb(ssh, c) != 0) {
		debug("channel %d: mux_rcb failed", c->self);
		chan_mark_dead(ssh, c);
		return;
	}
}

static void
channel_post_mux_client_write(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	ssize_t len;
	int r;

	if (c->wfd == -1 || !FD_ISSET(c->wfd, writeset) ||
	    sshbuf_len(c->output) == 0)
		return;

	len = write(c->wfd, sshbuf_ptr(c->output), sshbuf_len(c->output));
	if (len < 0 && (errno == EINTR || errno == EAGAIN))
		return;
	if (len <= 0) {
		chan_mark_dead(ssh, c);
		return;
	}
	if ((r = sshbuf_consume(c->output, len)) != 0)
		fatal("%s: channel %d: consume: %s", __func__,
		    c->self, ssh_err(r));
}

static void
channel_post_mux_client(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	channel_post_mux_client_read(ssh, c, readset, writeset);
	channel_post_mux_client_write(ssh, c, readset, writeset);
}

static void
channel_post_mux_listener(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
{
	Channel *nc;
	struct sockaddr_storage addr;
	socklen_t addrlen;
	int newsock;
	uid_t euid;
	gid_t egid;

	if (!FD_ISSET(c->sock, readset))
		return;

	debug("multiplexing control connection");

	/*
	 * Accept connection on control socket
	 */
	memset(&addr, 0, sizeof(addr));
	addrlen = sizeof(addr);
	if ((newsock = accept(c->sock, (struct sockaddr*)&addr,
	    &addrlen)) == -1) {
		error("%s accept: %s", __func__, strerror(errno));
		if (errno == EMFILE || errno == ENFILE)
			c->notbefore = monotime() + 1;
		return;
	}

	if (getpeereid(newsock, &euid, &egid) < 0) {
		error("%s getpeereid failed: %s", __func__,
		    strerror(errno));
		close(newsock);
		return;
	}
	if ((euid != 0) && (getuid() != euid)) {
		error("multiplex uid mismatch: peer euid %u != uid %u",
		    (u_int)euid, (u_int)getuid());
		close(newsock);
		return;
	}
	nc = channel_new(ssh, "multiplex client", SSH_CHANNEL_MUX_CLIENT,
	    newsock, newsock, -1, c->local_window_max,
	    c->local_maxpacket, 0, "mux-control", 1);
	nc->mux_rcb = c->mux_rcb;
	debug3("%s: new mux channel %d fd %d", __func__, nc->self, nc->sock);
	/* establish state */
	nc->mux_rcb(ssh, nc);
	/* mux state transitions must not elicit protocol messages */
	nc->flags |= CHAN_LOCAL;
}

static void
channel_handler_init(struct ssh_channels *sc)
{
	chan_fn **pre, **post;

	if ((pre = calloc(SSH_CHANNEL_MAX_TYPE, sizeof(*pre))) == NULL ||
	   (post = calloc(SSH_CHANNEL_MAX_TYPE, sizeof(*post))) == NULL)
		fatal("%s: allocation failed", __func__);

	pre[SSH_CHANNEL_OPEN] =			&channel_pre_open;
	pre[SSH_CHANNEL_X11_OPEN] =		&channel_pre_x11_open;
	pre[SSH_CHANNEL_PORT_LISTENER] =	&channel_pre_listener;
	pre[SSH_CHANNEL_RPORT_LISTENER] =	&channel_pre_listener;
	pre[SSH_CHANNEL_UNIX_LISTENER] =	&channel_pre_listener;
	pre[SSH_CHANNEL_RUNIX_LISTENER] =	&channel_pre_listener;
	pre[SSH_CHANNEL_X11_LISTENER] =		&channel_pre_listener;
	pre[SSH_CHANNEL_AUTH_SOCKET] =		&channel_pre_listener;
	pre[SSH_CHANNEL_CONNECTING] =		&channel_pre_connecting;
	pre[SSH_CHANNEL_DYNAMIC] =		&channel_pre_dynamic;
	pre[SSH_CHANNEL_RDYNAMIC_FINISH] =	&channel_pre_connecting;
	pre[SSH_CHANNEL_MUX_LISTENER] =		&channel_pre_listener;
	pre[SSH_CHANNEL_MUX_CLIENT] =		&channel_pre_mux_client;

	post[SSH_CHANNEL_OPEN] =		&channel_post_open;
	post[SSH_CHANNEL_PORT_LISTENER] =	&channel_post_port_listener;
	post[SSH_CHANNEL_RPORT_LISTENER] =	&channel_post_port_listener;
	post[SSH_CHANNEL_UNIX_LISTENER] =	&channel_post_port_listener;
	post[SSH_CHANNEL_RUNIX_LISTENER] =	&channel_post_port_listener;
	post[SSH_CHANNEL_X11_LISTENER] =	&channel_post_x11_listener;
	post[SSH_CHANNEL_AUTH_SOCKET] =		&channel_post_auth_listener;
	post[SSH_CHANNEL_CONNECTING] =		&channel_post_connecting;
	post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open;
	post[SSH_CHANNEL_RDYNAMIC_FINISH] =	&channel_post_connecting;
	post[SSH_CHANNEL_MUX_LISTENER] =	&channel_post_mux_listener;
	post[SSH_CHANNEL_MUX_CLIENT] =		&channel_post_mux_client;

	sc->channel_pre = pre;
	sc->channel_post = post;
}

/* gc dead channels */
static void
channel_garbage_collect(struct ssh *ssh, Channel *c)
{
	if (c == NULL)
		return;
	if (c->detach_user != NULL) {
		if (!chan_is_dead(ssh, c, c->detach_close))
			return;
		debug2("channel %d: gc: notify user", c->self);
		c->detach_user(ssh, c->self, NULL);
		/* if we still have a callback */
		if (c->detach_user != NULL)
			return;
		debug2("channel %d: gc: user detached", c->self);
	}
	if (!chan_is_dead(ssh, c, 1))
		return;
	debug2("channel %d: garbage collecting", c->self);
	channel_free(ssh, c);
}

enum channel_table { CHAN_PRE, CHAN_POST };

static void
channel_handler(struct ssh *ssh, int table,
    fd_set *readset, fd_set *writeset, time_t *unpause_secs)
{
	struct ssh_channels *sc = ssh->chanctxt;
	chan_fn **ftab = table == CHAN_PRE ? sc->channel_pre : sc->channel_post;
	u_int i, oalloc;
	Channel *c;
	time_t now;

	now = monotime();
	if (unpause_secs != NULL)
		*unpause_secs = 0;
	for (i = 0, oalloc = sc->channels_alloc; i < oalloc; i++) {
		c = sc->channels[i];
		if (c == NULL)
			continue;
		if (c->delayed) {
			if (table == CHAN_PRE)
				c->delayed = 0;
			else
				continue;
		}
		if (ftab[c->type] != NULL) {
			/*
			 * Run handlers that are not paused.
			 */
			if (c->notbefore <= now)
				(*ftab[c->type])(ssh, c, readset, writeset);
			else if (unpause_secs != NULL) {
				/*
				 * Collect the time that the earliest
				 * channel comes off pause.
				 */
				debug3("%s: chan %d: skip for %d more seconds",
				    __func__, c->self,
				    (int)(c->notbefore - now));
				if (*unpause_secs == 0 ||
				    (c->notbefore - now) < *unpause_secs)
					*unpause_secs = c->notbefore - now;
			}
		}
		channel_garbage_collect(ssh, c);
	}
	if (unpause_secs != NULL && *unpause_secs != 0)
		debug3("%s: first channel unpauses in %d seconds",
		    __func__, (int)*unpause_secs);
}

/*
 * Create sockets before allocating the select bitmasks.
 * This is necessary for things that need to happen after reading
 * the network-input but before channel_prepare_select().
 */
static void
channel_before_prepare_select(struct ssh *ssh)
{
	struct ssh_channels *sc = ssh->chanctxt;
	Channel *c;
	u_int i, oalloc;

	for (i = 0, oalloc = sc->channels_alloc; i < oalloc; i++) {
		c = sc->channels[i];
		if (c == NULL)
			continue;
		if (c->type == SSH_CHANNEL_RDYNAMIC_OPEN)
			channel_before_prepare_select_rdynamic(ssh, c);
	}
}

/*
 * Allocate/update select bitmasks and add any bits relevant to channels in
 * select bitmasks.
 */
void
channel_prepare_select(struct ssh *ssh, fd_set **readsetp, fd_set **writesetp,
    int *maxfdp, u_int *nallocp, time_t *minwait_secs)
{
	u_int n, sz, nfdset;

	channel_before_prepare_select(ssh); /* might update channel_max_fd */

	n = MAXIMUM(*maxfdp, ssh->chanctxt->channel_max_fd);

	nfdset = howmany(n+1, NFDBITS);
	/* Explicitly test here, because xrealloc isn't always called */
	if (nfdset && SIZE_MAX / nfdset < sizeof(fd_mask))
		fatal("channel_prepare_select: max_fd (%d) is too large", n);
	sz = nfdset * sizeof(fd_mask);

	/* perhaps check sz < nalloc/2 and shrink? */
	if (*readsetp == NULL || sz > *nallocp) {
		*readsetp = xreallocarray(*readsetp, nfdset, sizeof(fd_mask));
		*writesetp = xreallocarray(*writesetp, nfdset, sizeof(fd_mask));
		*nallocp = sz;
	}
	*maxfdp = n;
	memset(*readsetp, 0, sz);
	memset(*writesetp, 0, sz);

	if (!ssh_packet_is_rekeying(ssh))
		channel_handler(ssh, CHAN_PRE, *readsetp, *writesetp,
		    minwait_secs);
}

/*
 * After select, perform any appropriate operations for channels which have
 * events pending.
 */
void
channel_after_select(struct ssh *ssh, fd_set *readset, fd_set *writeset)
{
	channel_handler(ssh, CHAN_POST, readset, writeset, NULL);
}

/*
 * Enqueue data for channels with open or draining c->input.
 */
static void
channel_output_poll_input_open(struct ssh *ssh, Channel *c)
{
	size_t len, plen;
	const u_char *pkt;
	int r;

	if ((len = sshbuf_len(c->input)) == 0) {
		if (c->istate == CHAN_INPUT_WAIT_DRAIN) {
			/*
			 * input-buffer is empty and read-socket shutdown:
			 * tell peer, that we will not send more data:
			 * send IEOF.
			 * hack for extended data: delay EOF if EFD still
			 * in use.
			 */
			if (CHANNEL_EFD_INPUT_ACTIVE(c))
				debug2("channel %d: "
				    "ibuf_empty delayed efd %d/(%zu)",
				    c->self, c->efd, sshbuf_len(c->extended));
			else
				chan_ibuf_empty(ssh, c);
		}
		return;
	}

	if (!c->have_remote_id)
		fatal(":%s: channel %d: no remote id", __func__, c->self);

	if (c->datagram) {
		/* Check datagram will fit; drop if not */
		if ((r = sshbuf_get_string_direct(c->input, &pkt, &plen)) != 0)
			fatal("%s: channel %d: get datagram: %s", __func__,
			    c->self, ssh_err(r));
		/*
		 * XXX this does tail-drop on the datagram queue which is
		 * usually suboptimal compared to head-drop. Better to have
		 * backpressure at read time? (i.e. read + discard)
		 */
		if (plen > c->remote_window || plen > c->remote_maxpacket) {
			debug("channel %d: datagram too big", c->self);
			return;
		}
		/* Enqueue it */
		if ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||
		    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||
		    (r = sshpkt_put_string(ssh, pkt, plen)) != 0 ||
		    (r = sshpkt_send(ssh)) != 0) {
			fatal("%s: channel %i: datagram: %s", __func__,
			    c->self, ssh_err(r));
		}
		c->remote_window -= plen;
		return;
	}

	/* Enqueue packet for buffered data. */
	if (len > c->remote_window)
		len = c->remote_window;
	if (len > c->remote_maxpacket)
		len = c->remote_maxpacket;
	if (len == 0)
		return;
	if ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||
	    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||
	    (r = sshpkt_put_string(ssh, sshbuf_ptr(c->input), len)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0) {
		fatal("%s: channel %i: data: %s", __func__,
		    c->self, ssh_err(r));
	}
	if ((r = sshbuf_consume(c->input, len)) != 0)
		fatal("%s: channel %i: consume: %s", __func__,
		    c->self, ssh_err(r));
	c->remote_window -= len;
}

/*
 * Enqueue data for channels with open c->extended in read mode.
 */
static void
channel_output_poll_extended_read(struct ssh *ssh, Channel *c)
{
	size_t len;
	int r;

	if ((len = sshbuf_len(c->extended)) == 0)
		return;

	debug2("channel %d: rwin %u elen %zu euse %d", c->self,
	    c->remote_window, sshbuf_len(c->extended), c->extended_usage);
	if (len > c->remote_window)
		len = c->remote_window;
	if (len > c->remote_maxpacket)
		len = c->remote_maxpacket;
	if (len == 0)
		return;
	if (!c->have_remote_id)
		fatal(":%s: channel %d: no remote id", __func__, c->self);
	if ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_EXTENDED_DATA)) != 0 ||
	    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||
	    (r = sshpkt_put_u32(ssh, SSH2_EXTENDED_DATA_STDERR)) != 0 ||
	    (r = sshpkt_put_string(ssh, sshbuf_ptr(c->extended), len)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0) {
		fatal("%s: channel %i: data: %s", __func__,
		    c->self, ssh_err(r));
	}
	if ((r = sshbuf_consume(c->extended, len)) != 0)
		fatal("%s: channel %i: consume: %s", __func__,
		    c->self, ssh_err(r));
	c->remote_window -= len;
	debug2("channel %d: sent ext data %zu", c->self, len);
}

/* If there is data to send to the connection, enqueue some of it now. */
void
channel_output_poll(struct ssh *ssh)
{
	struct ssh_channels *sc = ssh->chanctxt;
	Channel *c;
	u_int i;

	for (i = 0; i < sc->channels_alloc; i++) {
		c = sc->channels[i];
		if (c == NULL)
			continue;

		/*
		 * We are only interested in channels that can have buffered
		 * incoming data.
		 */
		if (c->type != SSH_CHANNEL_OPEN)
			continue;
		if ((c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD))) {
			/* XXX is this true? */
			debug3("channel %d: will not send data after close",
			    c->self);
			continue;
		}

		/* Get the amount of buffered data for this channel. */
		if (c->istate == CHAN_INPUT_OPEN ||
		    c->istate == CHAN_INPUT_WAIT_DRAIN)
			channel_output_poll_input_open(ssh, c);
		/* Send extended data, i.e. stderr */
		if (!(c->flags & CHAN_EOF_SENT) &&
		    c->extended_usage == CHAN_EXTENDED_READ)
			channel_output_poll_extended_read(ssh, c);
	}
}

/* -- mux proxy support  */

/*
 * When multiplexing channel messages for mux clients we have to deal
 * with downstream messages from the mux client and upstream messages
 * from the ssh server:
 * 1) Handling downstream messages is straightforward and happens
 *    in channel_proxy_downstream():
 *    - We forward all messages (mostly) unmodified to the server.
 *    - However, in order to route messages from upstream to the correct
 *      downstream client, we have to replace the channel IDs used by the
 *      mux clients with a unique channel ID because the mux clients might
 *      use conflicting channel IDs.
 *    - so we inspect and change both SSH2_MSG_CHANNEL_OPEN and
 *      SSH2_MSG_CHANNEL_OPEN_CONFIRMATION messages, create a local
 *      SSH_CHANNEL_MUX_PROXY channel and replace the mux clients ID
 *      with the newly allocated channel ID.
 * 2) Upstream messages are received by matching SSH_CHANNEL_MUX_PROXY
 *    channels and procesed by channel_proxy_upstream(). The local channel ID
 *    is then translated back to the original mux client ID.
 * 3) In both cases we need to keep track of matching SSH2_MSG_CHANNEL_CLOSE
 *    messages so we can clean up SSH_CHANNEL_MUX_PROXY channels.
 * 4) The SSH_CHANNEL_MUX_PROXY channels also need to closed when the
 *    downstream mux client are removed.
 * 5) Handling SSH2_MSG_CHANNEL_OPEN messages from the upstream server
 *    requires more work, because they are not addressed to a specific
 *    channel. E.g. client_request_forwarded_tcpip() needs to figure
 *    out whether the request is addressed to the local client or a
 *    specific downstream client based on the listen-address/port.
 * 6) Agent and X11-Forwarding have a similar problem and are currenly
 *    not supported as the matching session/channel cannot be identified
 *    easily.
 */

/*
 * receive packets from downstream mux clients:
 * channel callback fired on read from mux client, creates
 * SSH_CHANNEL_MUX_PROXY channels and translates channel IDs
 * on channel creation.
 */
int
channel_proxy_downstream(struct ssh *ssh, Channel *downstream)
{
	Channel *c = NULL;
	struct sshbuf *original = NULL, *modified = NULL;
	const u_char *cp;
	char *ctype = NULL, *listen_host = NULL;
	u_char type;
	size_t have;
	int ret = -1, r;
	u_int id, remote_id, listen_port;

	/* sshbuf_dump(downstream->input, stderr); */
	if ((r = sshbuf_get_string_direct(downstream->input, &cp, &have))
	    != 0) {
		error("%s: malformed message: %s", __func__, ssh_err(r));
		return -1;
	}
	if (have < 2) {
		error("%s: short message", __func__);
		return -1;
	}
	type = cp[1];
	/* skip padlen + type */
	cp += 2;
	have -= 2;
	if (ssh_packet_log_type(type))
		debug3("%s: channel %u: down->up: type %u", __func__,
		    downstream->self, type);

	switch (type) {
	case SSH2_MSG_CHANNEL_OPEN:
		if ((original = sshbuf_from(cp, have)) == NULL ||
		    (modified = sshbuf_new()) == NULL) {
			error("%s: alloc", __func__);
			goto out;
		}
		if ((r = sshbuf_get_cstring(original, &ctype, NULL)) != 0 ||
		    (r = sshbuf_get_u32(original, &id)) != 0) {
			error("%s: parse error %s", __func__, ssh_err(r));
			goto out;
		}
		c = channel_new(ssh, "mux proxy", SSH_CHANNEL_MUX_PROXY,
		   -1, -1, -1, 0, 0, 0, ctype, 1);
		c->mux_ctx = downstream;	/* point to mux client */
		c->mux_downstream_id = id;	/* original downstream id */
		if ((r = sshbuf_put_cstring(modified, ctype)) != 0 ||
		    (r = sshbuf_put_u32(modified, c->self)) != 0 ||
		    (r = sshbuf_putb(modified, original)) != 0) {
			error("%s: compose error %s", __func__, ssh_err(r));
			channel_free(ssh, c);
			goto out;
		}
		break;
	case SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:
		/*
		 * Almost the same as SSH2_MSG_CHANNEL_OPEN, except then we
		 * need to parse 'remote_id' instead of 'ctype'.
		 */
		if ((original = sshbuf_from(cp, have)) == NULL ||
		    (modified = sshbuf_new()) == NULL) {
			error("%s: alloc", __func__);
			goto out;
		}
		if ((r = sshbuf_get_u32(original, &remote_id)) != 0 ||
		    (r = sshbuf_get_u32(original, &id)) != 0) {
			error("%s: parse error %s", __func__, ssh_err(r));
			goto out;
		}
		c = channel_new(ssh, "mux proxy", SSH_CHANNEL_MUX_PROXY,
		   -1, -1, -1, 0, 0, 0, "mux-down-connect", 1);
		c->mux_ctx = downstream;	/* point to mux client */
		c->mux_downstream_id = id;
		c->remote_id = remote_id;
		c->have_remote_id = 1;
		if ((r = sshbuf_put_u32(modified, remote_id)) != 0 ||
		    (r = sshbuf_put_u32(modified, c->self)) != 0 ||
		    (r = sshbuf_putb(modified, original)) != 0) {
			error("%s: compose error %s", __func__, ssh_err(r));
			channel_free(ssh, c);
			goto out;
		}
		break;
	case SSH2_MSG_GLOBAL_REQUEST:
		if ((original = sshbuf_from(cp, have)) == NULL) {
			error("%s: alloc", __func__);
			goto out;
		}
		if ((r = sshbuf_get_cstring(original, &ctype, NULL)) != 0) {
			error("%s: parse error %s", __func__, ssh_err(r));
			goto out;
		}
		if (strcmp(ctype, "tcpip-forward") != 0) {
			error("%s: unsupported request %s", __func__, ctype);
			goto out;
		}
		if ((r = sshbuf_get_u8(original, NULL)) != 0 ||
		    (r = sshbuf_get_cstring(original, &listen_host, NULL)) != 0 ||
		    (r = sshbuf_get_u32(original, &listen_port)) != 0) {
			error("%s: parse error %s", __func__, ssh_err(r));
			goto out;
		}
		if (listen_port > 65535) {
			error("%s: tcpip-forward for %s: bad port %u",
			    __func__, listen_host, listen_port);
			goto out;
		}
		/* Record that connection to this host/port is permitted. */
		fwd_perm_list_add(ssh, FWDPERM_USER, "<mux>", -1,
		    listen_host, NULL, (int)listen_port, downstream);
		listen_host = NULL;
		break;
	case SSH2_MSG_CHANNEL_CLOSE:
		if (have < 4)
			break;
		remote_id = PEEK_U32(cp);
		if ((c = channel_by_remote_id(ssh, remote_id)) != NULL) {
			if (c->flags & CHAN_CLOSE_RCVD)
				channel_free(ssh, c);
			else
				c->flags |= CHAN_CLOSE_SENT;
		}
		break;
	}
	if (modified) {
		if ((r = sshpkt_start(ssh, type)) != 0 ||
		    (r = sshpkt_putb(ssh, modified)) != 0 ||
		    (r = sshpkt_send(ssh)) != 0) {
			error("%s: send %s", __func__, ssh_err(r));
			goto out;
		}
	} else {
		if ((r = sshpkt_start(ssh, type)) != 0 ||
		    (r = sshpkt_put(ssh, cp, have)) != 0 ||
		    (r = sshpkt_send(ssh)) != 0) {
			error("%s: send %s", __func__, ssh_err(r));
			goto out;
		}
	}
	ret = 0;
 out:
	free(ctype);
	free(listen_host);
	sshbuf_free(original);
	sshbuf_free(modified);
	return ret;
}

/*
 * receive packets from upstream server and de-multiplex packets
 * to correct downstream:
 * implemented as a helper for channel input handlers,
 * replaces local (proxy) channel ID with downstream channel ID.
 */
int
channel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)
{
	struct sshbuf *b = NULL;
	Channel *downstream;
	const u_char *cp = NULL;
	size_t len;
	int r;

	/*
	 * When receiving packets from the peer we need to check whether we
	 * need to forward the packets to the mux client. In this case we
	 * restore the orignal channel id and keep track of CLOSE messages,
	 * so we can cleanup the channel.
	 */
	if (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)
		return 0;
	if ((downstream = c->mux_ctx) == NULL)
		return 0;
	switch (type) {
	case SSH2_MSG_CHANNEL_CLOSE:
	case SSH2_MSG_CHANNEL_DATA:
	case SSH2_MSG_CHANNEL_EOF:
	case SSH2_MSG_CHANNEL_EXTENDED_DATA:
	case SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:
	case SSH2_MSG_CHANNEL_OPEN_FAILURE:
	case SSH2_MSG_CHANNEL_WINDOW_ADJUST:
	case SSH2_MSG_CHANNEL_SUCCESS:
	case SSH2_MSG_CHANNEL_FAILURE:
	case SSH2_MSG_CHANNEL_REQUEST:
		break;
	default:
		debug2("%s: channel %u: unsupported type %u", __func__,
		    c->self, type);
		return 0;
	}
	if ((b = sshbuf_new()) == NULL) {
		error("%s: alloc reply", __func__);
		goto out;
	}
	/* get remaining payload (after id) */
	cp = sshpkt_ptr(ssh, &len);
	if (cp == NULL) {
		error("%s: no packet", __func__);
		goto out;
	}
	/* translate id and send to muxclient */
	if ((r = sshbuf_put_u8(b, 0)) != 0 ||	/* padlen */
	    (r = sshbuf_put_u8(b, type)) != 0 ||
	    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||
	    (r = sshbuf_put(b, cp, len)) != 0 ||
	    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {
		error("%s: compose for muxclient %s", __func__, ssh_err(r));
		goto out;
	}
	/* sshbuf_dump(b, stderr); */
	if (ssh_packet_log_type(type))
		debug3("%s: channel %u: up->down: type %u", __func__, c->self,
		    type);
 out:
	/* update state */
	switch (type) {
	case SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:
		/* record remote_id for SSH2_MSG_CHANNEL_CLOSE */
		if (cp && len > 4) {
			c->remote_id = PEEK_U32(cp);
			c->have_remote_id = 1;
		}
		break;
	case SSH2_MSG_CHANNEL_CLOSE:
		if (c->flags & CHAN_CLOSE_SENT)
			channel_free(ssh, c);
		else
			c->flags |= CHAN_CLOSE_RCVD;
		break;
	}
	sshbuf_free(b);
	return 1;
}

/* -- protocol input */

/* Parse a channel ID from the current packet */
static int
channel_parse_id(struct ssh *ssh, const char *where, const char *what)
{
	u_int32_t id;
	int r;

	if ((r = sshpkt_get_u32(ssh, &id)) != 0) {
		error("%s: parse id: %s", where, ssh_err(r));
		ssh_packet_disconnect(ssh, "Invalid %s message", what);
	}
	if (id > INT_MAX) {
		error("%s: bad channel id %u: %s", where, id, ssh_err(r));
		ssh_packet_disconnect(ssh, "Invalid %s channel id", what);
	}
	return (int)id;
}

/* Lookup a channel from an ID in the current packet */
static Channel *
channel_from_packet_id(struct ssh *ssh, const char *where, const char *what)
{
	int id = channel_parse_id(ssh, where, what);
	Channel *c;

	if ((c = channel_lookup(ssh, id)) == NULL) {
		ssh_packet_disconnect(ssh,
		    "%s packet referred to nonexistent channel %d", what, id);
	}
	return c;
}

int
channel_input_data(int type, u_int32_t seq, struct ssh *ssh)
{
	const u_char *data;
	size_t data_len, win_len;
	Channel *c = channel_from_packet_id(ssh, __func__, "data");
	int r;

	if (channel_proxy_upstream(c, type, seq, ssh))
		return 0;

	/* Ignore any data for non-open channels (might happen on close) */
	if (c->type != SSH_CHANNEL_OPEN &&
	    c->type != SSH_CHANNEL_RDYNAMIC_OPEN &&
	    c->type != SSH_CHANNEL_RDYNAMIC_FINISH &&
	    c->type != SSH_CHANNEL_X11_OPEN)
		return 0;

	/* Get the data. */
	if ((r = sshpkt_get_string_direct(ssh, &data, &data_len)) != 0)
		fatal("%s: channel %d: get data: %s", __func__,
		    c->self, ssh_err(r));
	ssh_packet_check_eom(ssh);

	win_len = data_len;
	if (c->datagram)
		win_len += 4;  /* string length header */

	/*
	 * The sending side reduces its window as it sends data, so we
	 * must 'fake' consumption of the data in order to ensure that window
	 * updates are sent back. Otherwise the connection might deadlock.
	 */
	if (c->ostate != CHAN_OUTPUT_OPEN) {
		c->local_window -= win_len;
		c->local_consumed += win_len;
		return 0;
	}

	if (win_len > c->local_maxpacket) {
		logit("channel %d: rcvd big packet %zu, maxpack %u",
		    c->self, win_len, c->local_maxpacket);
		return 0;
	}
	if (win_len > c->local_window) {
		logit("channel %d: rcvd too much data %zu, win %u",
		    c->self, win_len, c->local_window);
		return 0;
	}
	c->local_window -= win_len;

	if (c->datagram) {
		if ((r = sshbuf_put_string(c->output, data, data_len)) != 0)
			fatal("%s: channel %d: append datagram: %s",
			    __func__, c->self, ssh_err(r));
	} else if ((r = sshbuf_put(c->output, data, data_len)) != 0)
		fatal("%s: channel %d: append data: %s",
		    __func__, c->self, ssh_err(r));

	return 0;
}

int
channel_input_extended_data(int type, u_int32_t seq, struct ssh *ssh)
{
	const u_char *data;
	size_t data_len;
	u_int32_t tcode;
	Channel *c = channel_from_packet_id(ssh, __func__, "extended data");
	int r;

	if (channel_proxy_upstream(c, type, seq, ssh))
		return 0;
	if (c->type != SSH_CHANNEL_OPEN) {
		logit("channel %d: ext data for non open", c->self);
		return 0;
	}
	if (c->flags & CHAN_EOF_RCVD) {
		if (datafellows & SSH_BUG_EXTEOF)
			debug("channel %d: accepting ext data after eof",
			    c->self);
		else
			ssh_packet_disconnect(ssh, "Received extended_data "
			    "after EOF on channel %d.", c->self);
	}

	if ((r = sshpkt_get_u32(ssh, &tcode)) != 0) {
		error("%s: parse tcode: %s", __func__, ssh_err(r));
		ssh_packet_disconnect(ssh, "Invalid extended_data message");
	}
	if (c->efd == -1 ||
	    c->extended_usage != CHAN_EXTENDED_WRITE ||
	    tcode != SSH2_EXTENDED_DATA_STDERR) {
		logit("channel %d: bad ext data", c->self);
		return 0;
	}
	if ((r = sshpkt_get_string_direct(ssh, &data, &data_len)) != 0) {
		error("%s: parse data: %s", __func__, ssh_err(r));
		ssh_packet_disconnect(ssh, "Invalid extended_data message");
	}
	ssh_packet_check_eom(ssh);

	if (data_len > c->local_window) {
		logit("channel %d: rcvd too much extended_data %zu, win %u",
		    c->self, data_len, c->local_window);
		return 0;
	}
	debug2("channel %d: rcvd ext data %zu", c->self, data_len);
	/* XXX sshpkt_getb? */
	if ((r = sshbuf_put(c->extended, data, data_len)) != 0)
		error("%s: append: %s", __func__, ssh_err(r));
	c->local_window -= data_len;
	return 0;
}

int
channel_input_ieof(int type, u_int32_t seq, struct ssh *ssh)
{
	Channel *c = channel_from_packet_id(ssh, __func__, "ieof");

	ssh_packet_check_eom(ssh);

	if (channel_proxy_upstream(c, type, seq, ssh))
		return 0;
	chan_rcvd_ieof(ssh, c);

	/* XXX force input close */
	if (c->force_drain && c->istate == CHAN_INPUT_OPEN) {
		debug("channel %d: FORCE input drain", c->self);
		c->istate = CHAN_INPUT_WAIT_DRAIN;
		if (sshbuf_len(c->input) == 0)
			chan_ibuf_empty(ssh, c);
	}
	return 0;
}

int
channel_input_oclose(int type, u_int32_t seq, struct ssh *ssh)
{
	Channel *c = channel_from_packet_id(ssh, __func__, "oclose");

	if (channel_proxy_upstream(c, type, seq, ssh))
		return 0;
	ssh_packet_check_eom(ssh);
	chan_rcvd_oclose(ssh, c);
	return 0;
}

int
channel_input_open_confirmation(int type, u_int32_t seq, struct ssh *ssh)
{
	Channel *c = channel_from_packet_id(ssh, __func__, "open confirmation");
	u_int32_t remote_window, remote_maxpacket;
	int r;

	if (channel_proxy_upstream(c, type, seq, ssh))
		return 0;
	if (c->type != SSH_CHANNEL_OPENING)
		packet_disconnect("Received open confirmation for "
		    "non-opening channel %d.", c->self);
	/*
	 * Record the remote channel number and mark that the channel
	 * is now open.
	 */
	if ((r = sshpkt_get_u32(ssh, &c->remote_id)) != 0 ||
	    (r = sshpkt_get_u32(ssh, &remote_window)) != 0 ||
	    (r = sshpkt_get_u32(ssh, &remote_maxpacket)) != 0) {
		error("%s: window/maxpacket: %s", __func__, ssh_err(r));
		packet_disconnect("Invalid open confirmation message");
	}
	ssh_packet_check_eom(ssh);

	c->have_remote_id = 1;
	c->remote_window = remote_window;
	c->remote_maxpacket = remote_maxpacket;
	c->type = SSH_CHANNEL_OPEN;
	if (c->open_confirm) {
		debug2("%s: channel %d: callback start", __func__, c->self);
		c->open_confirm(ssh, c->self, 1, c->open_confirm_ctx);
		debug2("%s: channel %d: callback done", __func__, c->self);
	}
	debug2("channel %d: open confirm rwindow %u rmax %u", c->self,
	    c->remote_window, c->remote_maxpacket);
	return 0;
}

static char *
reason2txt(int reason)
{
	switch (reason) {
	case SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED:
		return "administratively prohibited";
	case SSH2_OPEN_CONNECT_FAILED:
		return "connect failed";
	case SSH2_OPEN_UNKNOWN_CHANNEL_TYPE:
		return "unknown channel type";
	case SSH2_OPEN_RESOURCE_SHORTAGE:
		return "resource shortage";
	}
	return "unknown reason";
}

int
channel_input_open_failure(int type, u_int32_t seq, struct ssh *ssh)
{
	Channel *c = channel_from_packet_id(ssh, __func__, "open failure");
	u_int32_t reason;
	char *msg = NULL;
	int r;

	if (channel_proxy_upstream(c, type, seq, ssh))
		return 0;
	if (c->type != SSH_CHANNEL_OPENING)
		packet_disconnect("Received open failure for "
		    "non-opening channel %d.", c->self);
	if ((r = sshpkt_get_u32(ssh, &reason)) != 0) {
		error("%s: reason: %s", __func__, ssh_err(r));
		packet_disconnect("Invalid open failure message");
	}
	if ((datafellows & SSH_BUG_OPENFAILURE) == 0) {
		/* skip language */
		if ((r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||
		    (r = sshpkt_get_string_direct(ssh, NULL, NULL)) != 0) {
			error("%s: message/lang: %s", __func__, ssh_err(r));
			packet_disconnect("Invalid open failure message");
		}
	}
	ssh_packet_check_eom(ssh);
	logit("channel %d: open failed: %s%s%s", c->self,
	    reason2txt(reason), msg ? ": ": "", msg ? msg : "");
	free(msg);
	if (c->open_confirm) {
		debug2("%s: channel %d: callback start", __func__, c->self);
		c->open_confirm(ssh, c->self, 0, c->open_confirm_ctx);
		debug2("%s: channel %d: callback done", __func__, c->self);
	}
	/* Schedule the channel for cleanup/deletion. */
	chan_mark_dead(ssh, c);
	return 0;
}

int
channel_input_window_adjust(int type, u_int32_t seq, struct ssh *ssh)
{
	int id = channel_parse_id(ssh, __func__, "window adjust");
	Channel *c;
	u_int32_t adjust;
	u_int new_rwin;
	int r;

	if ((c = channel_lookup(ssh, id)) == NULL) {
		logit("Received window adjust for non-open channel %d.", id);
		return 0;
	}

	if (channel_proxy_upstream(c, type, seq, ssh))
		return 0;
	if ((r = sshpkt_get_u32(ssh, &adjust)) != 0) {
		error("%s: adjust: %s", __func__, ssh_err(r));
		packet_disconnect("Invalid window adjust message");
	}
	ssh_packet_check_eom(ssh);
	debug2("channel %d: rcvd adjust %u", c->self, adjust);
	if ((new_rwin = c->remote_window + adjust) < c->remote_window) {
		fatal("channel %d: adjust %u overflows remote window %u",
		    c->self, adjust, c->remote_window);
	}
	c->remote_window = new_rwin;
	return 0;
}

int
channel_input_status_confirm(int type, u_int32_t seq, struct ssh *ssh)
{
	int id = channel_parse_id(ssh, __func__, "status confirm");
	Channel *c;
	struct channel_confirm *cc;

	/* Reset keepalive timeout */
	packet_set_alive_timeouts(0);

	debug2("%s: type %d id %d", __func__, type, id);

	if ((c = channel_lookup(ssh, id)) == NULL) {
		logit("%s: %d: unknown", __func__, id);
		return 0;
	}
	if (channel_proxy_upstream(c, type, seq, ssh))
		return 0;
	ssh_packet_check_eom(ssh);
	if ((cc = TAILQ_FIRST(&c->status_confirms)) == NULL)
		return 0;
	cc->cb(ssh, type, c, cc->ctx);
	TAILQ_REMOVE(&c->status_confirms, cc, entry);
	explicit_bzero(cc, sizeof(*cc));
	free(cc);
	return 0;
}

/* -- tcp forwarding */

void
channel_set_af(struct ssh *ssh, int af)
{
	ssh->chanctxt->IPv4or6 = af;
}


/*
 * Determine whether or not a port forward listens to loopback, the
 * specified address or wildcard. On the client, a specified bind
 * address will always override gateway_ports. On the server, a
 * gateway_ports of 1 (``yes'') will override the client's specification
 * and force a wildcard bind, whereas a value of 2 (``clientspecified'')
 * will bind to whatever address the client asked for.
 *
 * Special-case listen_addrs are:
 *
 * "0.0.0.0"               -> wildcard v4/v6 if SSH_OLD_FORWARD_ADDR
 * "" (empty string), "*"  -> wildcard v4/v6
 * "localhost"             -> loopback v4/v6
 * "127.0.0.1" / "::1"     -> accepted even if gateway_ports isn't set
 */
static const char *
channel_fwd_bind_addr(const char *listen_addr, int *wildcardp,
    int is_client, struct ForwardOptions *fwd_opts)
{
	const char *addr = NULL;
	int wildcard = 0;

	if (listen_addr == NULL) {
		/* No address specified: default to gateway_ports setting */
		if (fwd_opts->gateway_ports)
			wildcard = 1;
	} else if (fwd_opts->gateway_ports || is_client) {
		if (((datafellows & SSH_OLD_FORWARD_ADDR) &&
		    strcmp(listen_addr, "0.0.0.0") == 0 && is_client == 0) ||
		    *listen_addr == '\0' || strcmp(listen_addr, "*") == 0 ||
		    (!is_client && fwd_opts->gateway_ports == 1)) {
			wildcard = 1;
			/*
			 * Notify client if they requested a specific listen
			 * address and it was overridden.
			 */
			if (*listen_addr != '\0' &&
			    strcmp(listen_addr, "0.0.0.0") != 0 &&
			    strcmp(listen_addr, "*") != 0) {
				packet_send_debug("Forwarding listen address "
				    "\"%s\" overridden by server "
				    "GatewayPorts", listen_addr);
			}
		} else if (strcmp(listen_addr, "localhost") != 0 ||
		    strcmp(listen_addr, "127.0.0.1") == 0 ||
		    strcmp(listen_addr, "::1") == 0) {
			/* Accept localhost address when GatewayPorts=yes */
			addr = listen_addr;
		}
	} else if (strcmp(listen_addr, "127.0.0.1") == 0 ||
	    strcmp(listen_addr, "::1") == 0) {
		/*
		 * If a specific IPv4/IPv6 localhost address has been
		 * requested then accept it even if gateway_ports is in
		 * effect. This allows the client to prefer IPv4 or IPv6.
		 */
		addr = listen_addr;
	}
	if (wildcardp != NULL)
		*wildcardp = wildcard;
	return addr;
}

static int
channel_setup_fwd_listener_tcpip(struct ssh *ssh, int type,
    struct Forward *fwd, int *allocated_listen_port,
    struct ForwardOptions *fwd_opts)
{
	Channel *c;
	int sock, r, success = 0, wildcard = 0, is_client;
	struct addrinfo hints, *ai, *aitop;
	const char *host, *addr;
	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
	in_port_t *lport_p;

	is_client = (type == SSH_CHANNEL_PORT_LISTENER);

	if (is_client && fwd->connect_path != NULL) {
		host = fwd->connect_path;
	} else {
		host = (type == SSH_CHANNEL_RPORT_LISTENER) ?
		    fwd->listen_host : fwd->connect_host;
		if (host == NULL) {
			error("No forward host name.");
			return 0;
		}
		if (strlen(host) >= NI_MAXHOST) {
			error("Forward host name too long.");
			return 0;
		}
	}

	/* Determine the bind address, cf. channel_fwd_bind_addr() comment */
	addr = channel_fwd_bind_addr(fwd->listen_host, &wildcard,
	    is_client, fwd_opts);
	debug3("%s: type %d wildcard %d addr %s", __func__,
	    type, wildcard, (addr == NULL) ? "NULL" : addr);

	/*
	 * getaddrinfo returns a loopback address if the hostname is
	 * set to NULL and hints.ai_flags is not AI_PASSIVE
	 */
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = ssh->chanctxt->IPv4or6;
	hints.ai_flags = wildcard ? AI_PASSIVE : 0;
	hints.ai_socktype = SOCK_STREAM;
	snprintf(strport, sizeof strport, "%d", fwd->listen_port);
	if ((r = getaddrinfo(addr, strport, &hints, &aitop)) != 0) {
		if (addr == NULL) {
			/* This really shouldn't happen */
			packet_disconnect("getaddrinfo: fatal error: %s",
			    ssh_gai_strerror(r));
		} else {
			error("%s: getaddrinfo(%.64s): %s", __func__, addr,
			    ssh_gai_strerror(r));
		}
		return 0;
	}
	if (allocated_listen_port != NULL)
		*allocated_listen_port = 0;
	for (ai = aitop; ai; ai = ai->ai_next) {
		switch (ai->ai_family) {
		case AF_INET:
			lport_p = &((struct sockaddr_in *)ai->ai_addr)->
			    sin_port;
			break;
		case AF_INET6:
			lport_p = &((struct sockaddr_in6 *)ai->ai_addr)->
			    sin6_port;
			break;
		default:
			continue;
		}
		/*
		 * If allocating a port for -R forwards, then use the
		 * same port for all address families.
		 */
		if (type == SSH_CHANNEL_RPORT_LISTENER &&
		    fwd->listen_port == 0 && allocated_listen_port != NULL &&
		    *allocated_listen_port > 0)
			*lport_p = htons(*allocated_listen_port);

		if (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop, sizeof(ntop),
		    strport, sizeof(strport),
		    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
			error("%s: getnameinfo failed", __func__);
			continue;
		}
		/* Create a port to listen for the host. */
		sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
		if (sock < 0) {
			/* this is no error since kernel may not support ipv6 */
			verbose("socket: %.100s", strerror(errno));
			continue;
		}

		channel_set_reuseaddr(sock);

		debug("Local forwarding listening on %s port %s.",
		    ntop, strport);

		/* Bind the socket to the address. */
		if (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {
			/*
			 * address can be in if use ipv6 address is
			 * already bound
			 */
			verbose("bind: %.100s", strerror(errno));
			close(sock);
			continue;
		}
		/* Start listening for connections on the socket. */
		if (listen(sock, SSH_LISTEN_BACKLOG) < 0) {
			error("listen: %.100s", strerror(errno));
			close(sock);
			continue;
		}

		/*
		 * fwd->listen_port == 0 requests a dynamically allocated port -
		 * record what we got.
		 */
		if (type == SSH_CHANNEL_RPORT_LISTENER &&
		    fwd->listen_port == 0 &&
		    allocated_listen_port != NULL &&
		    *allocated_listen_port == 0) {
			*allocated_listen_port = get_local_port(sock);
			debug("Allocated listen port %d",
			    *allocated_listen_port);
		}

		/* Allocate a channel number for the socket. */
		c = channel_new(ssh, "port listener", type, sock, sock, -1,
		    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,
		    0, "port listener", 1);
		c->path = xstrdup(host);
		c->host_port = fwd->connect_port;
		c->listening_addr = addr == NULL ? NULL : xstrdup(addr);
		if (fwd->listen_port == 0 && allocated_listen_port != NULL &&
		    !(datafellows & SSH_BUG_DYNAMIC_RPORT))
			c->listening_port = *allocated_listen_port;
		else
			c->listening_port = fwd->listen_port;
		success = 1;
	}
	if (success == 0)
		error("%s: cannot listen to port: %d", __func__,
		    fwd->listen_port);
	freeaddrinfo(aitop);
	return success;
}

static int
channel_setup_fwd_listener_streamlocal(struct ssh *ssh, int type,
    struct Forward *fwd, struct ForwardOptions *fwd_opts)
{
	struct sockaddr_un sunaddr;
	const char *path;
	Channel *c;
	int port, sock;
	mode_t omask;

	switch (type) {
	case SSH_CHANNEL_UNIX_LISTENER:
		if (fwd->connect_path != NULL) {
			if (strlen(fwd->connect_path) > sizeof(sunaddr.sun_path)) {
				error("Local connecting path too long: %s",
				    fwd->connect_path);
				return 0;
			}
			path = fwd->connect_path;
			port = PORT_STREAMLOCAL;
		} else {
			if (fwd->connect_host == NULL) {
				error("No forward host name.");
				return 0;
			}
			if (strlen(fwd->connect_host) >= NI_MAXHOST) {
				error("Forward host name too long.");
				return 0;
			}
			path = fwd->connect_host;
			port = fwd->connect_port;
		}
		break;
	case SSH_CHANNEL_RUNIX_LISTENER:
		path = fwd->listen_path;
		port = PORT_STREAMLOCAL;
		break;
	default:
		error("%s: unexpected channel type %d", __func__, type);
		return 0;
	}

	if (fwd->listen_path == NULL) {
		error("No forward path name.");
		return 0;
	}
	if (strlen(fwd->listen_path) > sizeof(sunaddr.sun_path)) {
		error("Local listening path too long: %s", fwd->listen_path);
		return 0;
	}

	debug3("%s: type %d path %s", __func__, type, fwd->listen_path);

	/* Start a Unix domain listener. */
	omask = umask(fwd_opts->streamlocal_bind_mask);
	sock = unix_listener(fwd->listen_path, SSH_LISTEN_BACKLOG,
	    fwd_opts->streamlocal_bind_unlink);
	umask(omask);
	if (sock < 0)
		return 0;

	debug("Local forwarding listening on path %s.", fwd->listen_path);

	/* Allocate a channel number for the socket. */
	c = channel_new(ssh, "unix listener", type, sock, sock, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,
	    0, "unix listener", 1);
	c->path = xstrdup(path);
	c->host_port = port;
	c->listening_port = PORT_STREAMLOCAL;
	c->listening_addr = xstrdup(fwd->listen_path);
	return 1;
}

static int
channel_cancel_rport_listener_tcpip(struct ssh *ssh,
    const char *host, u_short port)
{
	u_int i;
	int found = 0;

	for (i = 0; i < ssh->chanctxt->channels_alloc; i++) {
		Channel *c = ssh->chanctxt->channels[i];
		if (c == NULL || c->type != SSH_CHANNEL_RPORT_LISTENER)
			continue;
		if (strcmp(c->path, host) == 0 && c->listening_port == port) {
			debug2("%s: close channel %d", __func__, i);
			channel_free(ssh, c);
			found = 1;
		}
	}

	return found;
}

static int
channel_cancel_rport_listener_streamlocal(struct ssh *ssh, const char *path)
{
	u_int i;
	int found = 0;

	for (i = 0; i < ssh->chanctxt->channels_alloc; i++) {
		Channel *c = ssh->chanctxt->channels[i];
		if (c == NULL || c->type != SSH_CHANNEL_RUNIX_LISTENER)
			continue;
		if (c->path == NULL)
			continue;
		if (strcmp(c->path, path) == 0) {
			debug2("%s: close channel %d", __func__, i);
			channel_free(ssh, c);
			found = 1;
		}
	}

	return found;
}

int
channel_cancel_rport_listener(struct ssh *ssh, struct Forward *fwd)
{
	if (fwd->listen_path != NULL) {
		return channel_cancel_rport_listener_streamlocal(ssh,
		    fwd->listen_path);
	} else {
		return channel_cancel_rport_listener_tcpip(ssh,
		    fwd->listen_host, fwd->listen_port);
	}
}

static int
channel_cancel_lport_listener_tcpip(struct ssh *ssh,
    const char *lhost, u_short lport, int cport,
    struct ForwardOptions *fwd_opts)
{
	u_int i;
	int found = 0;
	const char *addr = channel_fwd_bind_addr(lhost, NULL, 1, fwd_opts);

	for (i = 0; i < ssh->chanctxt->channels_alloc; i++) {
		Channel *c = ssh->chanctxt->channels[i];
		if (c == NULL || c->type != SSH_CHANNEL_PORT_LISTENER)
			continue;
		if (c->listening_port != lport)
			continue;
		if (cport == CHANNEL_CANCEL_PORT_STATIC) {
			/* skip dynamic forwardings */
			if (c->host_port == 0)
				continue;
		} else {
			if (c->host_port != cport)
				continue;
		}
		if ((c->listening_addr == NULL && addr != NULL) ||
		    (c->listening_addr != NULL && addr == NULL))
			continue;
		if (addr == NULL || strcmp(c->listening_addr, addr) == 0) {
			debug2("%s: close channel %d", __func__, i);
			channel_free(ssh, c);
			found = 1;
		}
	}

	return found;
}

static int
channel_cancel_lport_listener_streamlocal(struct ssh *ssh, const char *path)
{
	u_int i;
	int found = 0;

	if (path == NULL) {
		error("%s: no path specified.", __func__);
		return 0;
	}

	for (i = 0; i < ssh->chanctxt->channels_alloc; i++) {
		Channel *c = ssh->chanctxt->channels[i];
		if (c == NULL || c->type != SSH_CHANNEL_UNIX_LISTENER)
			continue;
		if (c->listening_addr == NULL)
			continue;
		if (strcmp(c->listening_addr, path) == 0) {
			debug2("%s: close channel %d", __func__, i);
			channel_free(ssh, c);
			found = 1;
		}
	}

	return found;
}

int
channel_cancel_lport_listener(struct ssh *ssh,
    struct Forward *fwd, int cport, struct ForwardOptions *fwd_opts)
{
	if (fwd->listen_path != NULL) {
		return channel_cancel_lport_listener_streamlocal(ssh,
		    fwd->listen_path);
	} else {
		return channel_cancel_lport_listener_tcpip(ssh,
		    fwd->listen_host, fwd->listen_port, cport, fwd_opts);
	}
}

/* protocol local port fwd, used by ssh */
int
channel_setup_local_fwd_listener(struct ssh *ssh,
    struct Forward *fwd, struct ForwardOptions *fwd_opts)
{
	if (fwd->listen_path != NULL) {
		return channel_setup_fwd_listener_streamlocal(ssh,
		    SSH_CHANNEL_UNIX_LISTENER, fwd, fwd_opts);
	} else {
		return channel_setup_fwd_listener_tcpip(ssh,
		    SSH_CHANNEL_PORT_LISTENER, fwd, NULL, fwd_opts);
	}
}

/* protocol v2 remote port fwd, used by sshd */
int
channel_setup_remote_fwd_listener(struct ssh *ssh, struct Forward *fwd,
    int *allocated_listen_port, struct ForwardOptions *fwd_opts)
{
	if (fwd->listen_path != NULL) {
		return channel_setup_fwd_listener_streamlocal(ssh,
		    SSH_CHANNEL_RUNIX_LISTENER, fwd, fwd_opts);
	} else {
		return channel_setup_fwd_listener_tcpip(ssh,
		    SSH_CHANNEL_RPORT_LISTENER, fwd, allocated_listen_port,
		    fwd_opts);
	}
}

/*
 * Translate the requested rfwd listen host to something usable for
 * this server.
 */
static const char *
channel_rfwd_bind_host(const char *listen_host)
{
	if (listen_host == NULL) {
		if (datafellows & SSH_BUG_RFWD_ADDR)
			return "127.0.0.1";
		else
			return "localhost";
	} else if (*listen_host == '\0' || strcmp(listen_host, "*") == 0) {
		if (datafellows & SSH_BUG_RFWD_ADDR)
			return "0.0.0.0";
		else
			return "";
	} else
		return listen_host;
}

/*
 * Initiate forwarding of connections to port "port" on remote host through
 * the secure channel to host:port from local side.
 * Returns handle (index) for updating the dynamic listen port with
 * channel_update_permitted_opens().
 */
int
channel_request_remote_forwarding(struct ssh *ssh, struct Forward *fwd)
{
	int r, success = 0, idx = -1;
	char *host_to_connect, *listen_host, *listen_path;
	int port_to_connect, listen_port;

	/* Send the forward request to the remote side. */
	if (fwd->listen_path != NULL) {
		if ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||
		    (r = sshpkt_put_cstring(ssh,
		    "streamlocal-forward@@openssh.com")) != 0 ||
		    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */
		    (r = sshpkt_put_cstring(ssh, fwd->listen_path)) != 0 ||
		    (r = sshpkt_send(ssh)) != 0 ||
		    (r = ssh_packet_write_wait(ssh)) != 0)
			fatal("%s: request streamlocal: %s",
			    __func__, ssh_err(r));
	} else {
		if ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||
		    (r = sshpkt_put_cstring(ssh, "tcpip-forward")) != 0 ||
		    (r = sshpkt_put_u8(ssh, 1)) != 0 || /* want reply */
		    (r = sshpkt_put_cstring(ssh,
		    channel_rfwd_bind_host(fwd->listen_host))) != 0 ||
		    (r = sshpkt_put_u32(ssh, fwd->listen_port)) != 0 ||
		    (r = sshpkt_send(ssh)) != 0 ||
		    (r = ssh_packet_write_wait(ssh)) != 0)
			fatal("%s: request tcpip-forward: %s",
			    __func__, ssh_err(r));
	}
	/* Assume that server accepts the request */
	success = 1;
	if (success) {
		/* Record that connection to this host/port is permitted. */
		host_to_connect = listen_host = listen_path = NULL;
		port_to_connect = listen_port = 0;
		if (fwd->connect_path != NULL) {
			host_to_connect = xstrdup(fwd->connect_path);
			port_to_connect = PORT_STREAMLOCAL;
		} else {
			host_to_connect = xstrdup(fwd->connect_host);
			port_to_connect = fwd->connect_port;
		}
		if (fwd->listen_path != NULL) {
			listen_path = xstrdup(fwd->listen_path);
			listen_port = PORT_STREAMLOCAL;
		} else {
			if (fwd->listen_host != NULL)
				listen_host = xstrdup(fwd->listen_host);
			listen_port = fwd->listen_port;
		}
		idx = fwd_perm_list_add(ssh, FWDPERM_USER,
		    host_to_connect, port_to_connect,
		    listen_host, listen_path, listen_port, NULL);
	}
	return idx;
}

static int
open_match(ForwardPermission *allowed_open, const char *requestedhost,
    int requestedport)
{
	if (allowed_open->host_to_connect == NULL)
		return 0;
	if (allowed_open->port_to_connect != FWD_PERMIT_ANY_PORT &&
	    allowed_open->port_to_connect != requestedport)
		return 0;
	if (strcmp(allowed_open->host_to_connect, FWD_PERMIT_ANY_HOST) != 0 &&
	    strcmp(allowed_open->host_to_connect, requestedhost) != 0)
		return 0;
	return 1;
}

/*
 * Note that in the listen host/port case
 * we don't support FWD_PERMIT_ANY_PORT and
 * need to translate between the configured-host (listen_host)
 * and what we've sent to the remote server (channel_rfwd_bind_host)
 */
static int
open_listen_match_tcpip(ForwardPermission *allowed_open,
    const char *requestedhost, u_short requestedport, int translate)
{
	const char *allowed_host;

	if (allowed_open->host_to_connect == NULL)
		return 0;
	if (allowed_open->listen_port != requestedport)
		return 0;
	if (!translate && allowed_open->listen_host == NULL &&
	    requestedhost == NULL)
		return 1;
	allowed_host = translate ?
	    channel_rfwd_bind_host(allowed_open->listen_host) :
	    allowed_open->listen_host;
	if (allowed_host == NULL ||
	    strcmp(allowed_host, requestedhost) != 0)
		return 0;
	return 1;
}

static int
open_listen_match_streamlocal(ForwardPermission *allowed_open,
    const char *requestedpath)
{
	if (allowed_open->host_to_connect == NULL)
		return 0;
	if (allowed_open->listen_port != PORT_STREAMLOCAL)
		return 0;
	if (allowed_open->listen_path == NULL ||
	    strcmp(allowed_open->listen_path, requestedpath) != 0)
		return 0;
	return 1;
}

/*
 * Request cancellation of remote forwarding of connection host:port from
 * local side.
 */
static int
channel_request_rforward_cancel_tcpip(struct ssh *ssh,
    const char *host, u_short port)
{
	struct ssh_channels *sc = ssh->chanctxt;
	int r;
	u_int i;
	ForwardPermission *fp;

	for (i = 0; i < sc->num_permitted_opens; i++) {
		fp = &sc->permitted_opens[i];
		if (open_listen_match_tcpip(fp, host, port, 0))
			break;
		fp = NULL;
	}
	if (fp == NULL) {
		debug("%s: requested forward not found", __func__);
		return -1;
	}
	if ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||
	    (r = sshpkt_put_cstring(ssh, "cancel-tcpip-forward")) != 0 ||
	    (r = sshpkt_put_u8(ssh, 0)) != 0 || /* want reply */
	    (r = sshpkt_put_cstring(ssh, channel_rfwd_bind_host(host))) != 0 ||
	    (r = sshpkt_put_u32(ssh, port)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		fatal("%s: send cancel: %s", __func__, ssh_err(r));

	fwd_perm_clear(fp); /* unregister */

	return 0;
}

/*
 * Request cancellation of remote forwarding of Unix domain socket
 * path from local side.
 */
static int
channel_request_rforward_cancel_streamlocal(struct ssh *ssh, const char *path)
{
	struct ssh_channels *sc = ssh->chanctxt;
	int r;
	u_int i;
	ForwardPermission *fp;

	for (i = 0; i < sc->num_permitted_opens; i++) {
		fp = &sc->permitted_opens[i];
		if (open_listen_match_streamlocal(fp, path))
			break;
		fp = NULL;
	}
	if (fp == NULL) {
		debug("%s: requested forward not found", __func__);
		return -1;
	}
	if ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||
	    (r = sshpkt_put_cstring(ssh,
	    "cancel-streamlocal-forward@@openssh.com")) != 0 ||
	    (r = sshpkt_put_u8(ssh, 0)) != 0 || /* want reply */
	    (r = sshpkt_put_cstring(ssh, path)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		fatal("%s: send cancel: %s", __func__, ssh_err(r));

	fwd_perm_clear(fp); /* unregister */

	return 0;
}

/*
 * Request cancellation of remote forwarding of a connection from local side.
 */
int
channel_request_rforward_cancel(struct ssh *ssh, struct Forward *fwd)
{
	if (fwd->listen_path != NULL) {
		return channel_request_rforward_cancel_streamlocal(ssh,
		    fwd->listen_path);
	} else {
		return channel_request_rforward_cancel_tcpip(ssh,
		    fwd->listen_host,
		    fwd->listen_port ? fwd->listen_port : fwd->allocated_port);
	}
}

/*
 * Permits opening to any host/port if permitted_opens[] is empty.  This is
 * usually called by the server, because the user could connect to any port
 * anyway, and the server has no way to know but to trust the client anyway.
 */
void
channel_permit_all_opens(struct ssh *ssh)
{
	if (ssh->chanctxt->num_permitted_opens == 0)
		ssh->chanctxt->all_opens_permitted = 1;
}

void
channel_add_permitted_opens(struct ssh *ssh, char *host, int port)
{
	struct ssh_channels *sc = ssh->chanctxt;

	debug("allow port forwarding to host %s port %d", host, port);
	fwd_perm_list_add(ssh, FWDPERM_USER, host, port, NULL, NULL, 0, NULL);
	sc->all_opens_permitted = 0;
}

/*
 * Update the listen port for a dynamic remote forward, after
 * the actual 'newport' has been allocated. If 'newport' < 0 is
 * passed then they entry will be invalidated.
 */
void
channel_update_permitted_opens(struct ssh *ssh, int idx, int newport)
{
	struct ssh_channels *sc = ssh->chanctxt;

	if (idx < 0 || (u_int)idx >= sc->num_permitted_opens) {
		debug("%s: index out of range: %d num_permitted_opens %d",
		    __func__, idx, sc->num_permitted_opens);
		return;
	}
	debug("%s allowed port %d for forwarding to host %s port %d",
	    newport > 0 ? "Updating" : "Removing",
	    newport,
	    sc->permitted_opens[idx].host_to_connect,
	    sc->permitted_opens[idx].port_to_connect);
	if (newport <= 0)
		fwd_perm_clear(&sc->permitted_opens[idx]);
	else {
		sc->permitted_opens[idx].listen_port =
		    (datafellows & SSH_BUG_DYNAMIC_RPORT) ? 0 : newport;
	}
}

int
channel_add_adm_permitted_opens(struct ssh *ssh, char *host, int port)
{
	debug("config allows port forwarding to host %s port %d", host, port);
	return fwd_perm_list_add(ssh, FWDPERM_ADMIN, host, port,
	    NULL, NULL, 0, NULL);
}

void
channel_disable_adm_local_opens(struct ssh *ssh)
{
	channel_clear_adm_permitted_opens(ssh);
	fwd_perm_list_add(ssh, FWDPERM_ADMIN, NULL, 0, NULL, NULL, 0, NULL);
}

void
channel_clear_permitted_opens(struct ssh *ssh)
{
	struct ssh_channels *sc = ssh->chanctxt;

	sc->permitted_opens = xrecallocarray(sc->permitted_opens,
	    sc->num_permitted_opens, 0, sizeof(*sc->permitted_opens));
	sc->num_permitted_opens = 0;
}

void
channel_clear_adm_permitted_opens(struct ssh *ssh)
{
	struct ssh_channels *sc = ssh->chanctxt;

	sc->permitted_adm_opens = xrecallocarray(sc->permitted_adm_opens,
	    sc->num_adm_permitted_opens, 0, sizeof(*sc->permitted_adm_opens));
	sc->num_adm_permitted_opens = 0;
}

/* returns port number, FWD_PERMIT_ANY_PORT or -1 on error */
int
permitopen_port(const char *p)
{
	int port;

	if (strcmp(p, "*") == 0)
		return FWD_PERMIT_ANY_PORT;
	if ((port = a2port(p)) > 0)
		return port;
	return -1;
}

/* Try to start non-blocking connect to next host in cctx list */
static int
connect_next(struct channel_connect *cctx)
{
	int sock, saved_errno;
	struct sockaddr_un *sunaddr;
	char ntop[NI_MAXHOST];
	char strport[MAXIMUM(NI_MAXSERV, sizeof(sunaddr->sun_path))];

	for (; cctx->ai; cctx->ai = cctx->ai->ai_next) {
		switch (cctx->ai->ai_family) {
		case AF_UNIX:
			/* unix:pathname instead of host:port */
			sunaddr = (struct sockaddr_un *)cctx->ai->ai_addr;
			strlcpy(ntop, "unix", sizeof(ntop));
			strlcpy(strport, sunaddr->sun_path, sizeof(strport));
			break;
		case AF_INET:
		case AF_INET6:
			if (getnameinfo(cctx->ai->ai_addr, cctx->ai->ai_addrlen,
			    ntop, sizeof(ntop), strport, sizeof(strport),
			    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
				error("connect_next: getnameinfo failed");
				continue;
			}
			break;
		default:
			continue;
		}
		if ((sock = socket(cctx->ai->ai_family, cctx->ai->ai_socktype,
		    cctx->ai->ai_protocol)) == -1) {
			if (cctx->ai->ai_next == NULL)
				error("socket: %.100s", strerror(errno));
			else
				verbose("socket: %.100s", strerror(errno));
			continue;
		}
		if (set_nonblock(sock) == -1)
			fatal("%s: set_nonblock(%d)", __func__, sock);
		if (connect(sock, cctx->ai->ai_addr,
		    cctx->ai->ai_addrlen) == -1 && errno != EINPROGRESS) {
			debug("connect_next: host %.100s ([%.100s]:%s): "
			    "%.100s", cctx->host, ntop, strport,
			    strerror(errno));
			saved_errno = errno;
			close(sock);
			errno = saved_errno;
			continue;	/* fail -- try next */
		}
		if (cctx->ai->ai_family != AF_UNIX)
			set_nodelay(sock);
		debug("connect_next: host %.100s ([%.100s]:%s) "
		    "in progress, fd=%d", cctx->host, ntop, strport, sock);
		cctx->ai = cctx->ai->ai_next;
		return sock;
	}
	return -1;
}

static void
channel_connect_ctx_free(struct channel_connect *cctx)
{
	free(cctx->host);
	if (cctx->aitop) {
		if (cctx->aitop->ai_family == AF_UNIX)
			free(cctx->aitop);
		else
			freeaddrinfo(cctx->aitop);
	}
	memset(cctx, 0, sizeof(*cctx));
}

/*
 * Return connecting socket to remote host:port or local socket path,
 * passing back the failure reason if appropriate.
 */
static int
connect_to_helper(struct ssh *ssh, const char *name, int port, int socktype,
    char *ctype, char *rname, struct channel_connect *cctx,
    int *reason, const char **errmsg)
{
	struct addrinfo hints;
	int gaierr;
	int sock = -1;
	char strport[NI_MAXSERV];

	if (port == PORT_STREAMLOCAL) {
		struct sockaddr_un *sunaddr;
		struct addrinfo *ai;

		if (strlen(name) > sizeof(sunaddr->sun_path)) {
			error("%.100s: %.100s", name, strerror(ENAMETOOLONG));
			return -1;
		}

		/*
		 * Fake up a struct addrinfo for AF_UNIX connections.
		 * channel_connect_ctx_free() must check ai_family
		 * and use free() not freeaddirinfo() for AF_UNIX.
		 */
		ai = xmalloc(sizeof(*ai) + sizeof(*sunaddr));
		memset(ai, 0, sizeof(*ai) + sizeof(*sunaddr));
		ai->ai_addr = (struct sockaddr *)(ai + 1);
		ai->ai_addrlen = sizeof(*sunaddr);
		ai->ai_family = AF_UNIX;
		ai->ai_socktype = socktype;
		ai->ai_protocol = PF_UNSPEC;
		sunaddr = (struct sockaddr_un *)ai->ai_addr;
		sunaddr->sun_family = AF_UNIX;
		strlcpy(sunaddr->sun_path, name, sizeof(sunaddr->sun_path));
		cctx->aitop = ai;
	} else {
		memset(&hints, 0, sizeof(hints));
		hints.ai_family = ssh->chanctxt->IPv4or6;
		hints.ai_socktype = socktype;
		snprintf(strport, sizeof strport, "%d", port);
		if ((gaierr = getaddrinfo(name, strport, &hints, &cctx->aitop))
		    != 0) {
			if (errmsg != NULL)
				*errmsg = ssh_gai_strerror(gaierr);
			if (reason != NULL)
				*reason = SSH2_OPEN_CONNECT_FAILED;
			error("connect_to %.100s: unknown host (%s)", name,
			    ssh_gai_strerror(gaierr));
			return -1;
		}
	}

	cctx->host = xstrdup(name);
	cctx->port = port;
	cctx->ai = cctx->aitop;

	if ((sock = connect_next(cctx)) == -1) {
		error("connect to %.100s port %d failed: %s",
		    name, port, strerror(errno));
		return -1;
	}

	return sock;
}

/* Return CONNECTING channel to remote host:port or local socket path */
static Channel *
connect_to(struct ssh *ssh, const char *host, int port,
    char *ctype, char *rname)
{
	struct channel_connect cctx;
	Channel *c;
	int sock;

	memset(&cctx, 0, sizeof(cctx));
	sock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,
	    &cctx, NULL, NULL);
	if (sock == -1) {
		channel_connect_ctx_free(&cctx);
		return NULL;
	}
	c = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);
	c->host_port = port;
	c->path = xstrdup(host);
	c->connect_ctx = cctx;

	return c;
}

/*
 * returns either the newly connected channel or the downstream channel
 * that needs to deal with this connection.
 */
Channel *
channel_connect_by_listen_address(struct ssh *ssh, const char *listen_host,
    u_short listen_port, char *ctype, char *rname)
{
	struct ssh_channels *sc = ssh->chanctxt;
	u_int i;
	ForwardPermission *fp;

	for (i = 0; i < sc->num_permitted_opens; i++) {
		fp = &sc->permitted_opens[i];
		if (open_listen_match_tcpip(fp, listen_host, listen_port, 1)) {
			if (fp->downstream)
				return fp->downstream;
			if (fp->port_to_connect == 0)
				return rdynamic_connect_prepare(ssh,
				    ctype, rname);
			return connect_to(ssh,
			    fp->host_to_connect, fp->port_to_connect,
			    ctype, rname);
		}
	}
	error("WARNING: Server requests forwarding for unknown listen_port %d",
	    listen_port);
	return NULL;
}

Channel *
channel_connect_by_listen_path(struct ssh *ssh, const char *path,
    char *ctype, char *rname)
{
	struct ssh_channels *sc = ssh->chanctxt;
	u_int i;
	ForwardPermission *fp;

	for (i = 0; i < sc->num_permitted_opens; i++) {
		fp = &sc->permitted_opens[i];
		if (open_listen_match_streamlocal(fp, path)) {
			return connect_to(ssh,
			    fp->host_to_connect, fp->port_to_connect,
			    ctype, rname);
		}
	}
	error("WARNING: Server requests forwarding for unknown path %.100s",
	    path);
	return NULL;
}

/* Check if connecting to that port is permitted and connect. */
Channel *
channel_connect_to_port(struct ssh *ssh, const char *host, u_short port,
    char *ctype, char *rname, int *reason, const char **errmsg)
{
	struct ssh_channels *sc = ssh->chanctxt;
	struct channel_connect cctx;
	Channel *c;
	u_int i, permit, permit_adm = 1;
	int sock;
	ForwardPermission *fp;

	permit = sc->all_opens_permitted;
	if (!permit) {
		for (i = 0; i < sc->num_permitted_opens; i++) {
			fp = &sc->permitted_opens[i];
			if (open_match(fp, host, port)) {
				permit = 1;
				break;
			}
		}
	}

	if (sc->num_adm_permitted_opens > 0) {
		permit_adm = 0;
		for (i = 0; i < sc->num_adm_permitted_opens; i++) {
			fp = &sc->permitted_adm_opens[i];
			if (open_match(fp, host, port)) {
				permit_adm = 1;
				break;
			}
		}
	}

	if (!permit || !permit_adm) {
		logit("Received request to connect to host %.100s port %d, "
		    "but the request was denied.", host, port);
		if (reason != NULL)
			*reason = SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED;
		return NULL;
	}

	memset(&cctx, 0, sizeof(cctx));
	sock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,
	    &cctx, reason, errmsg);
	if (sock == -1) {
		channel_connect_ctx_free(&cctx);
		return NULL;
	}

	c = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);
	c->host_port = port;
	c->path = xstrdup(host);
	c->connect_ctx = cctx;

	return c;
}

/* Check if connecting to that path is permitted and connect. */
Channel *
channel_connect_to_path(struct ssh *ssh, const char *path,
    char *ctype, char *rname)
{
	struct ssh_channels *sc = ssh->chanctxt;
	u_int i, permit, permit_adm = 1;
	ForwardPermission *fp;

	permit = sc->all_opens_permitted;
	if (!permit) {
		for (i = 0; i < sc->num_permitted_opens; i++) {
			fp = &sc->permitted_opens[i];
			if (open_match(fp, path, PORT_STREAMLOCAL)) {
				permit = 1;
				break;
			}
		}
	}

	if (sc->num_adm_permitted_opens > 0) {
		permit_adm = 0;
		for (i = 0; i < sc->num_adm_permitted_opens; i++) {
			fp = &sc->permitted_adm_opens[i];
			if (open_match(fp, path, PORT_STREAMLOCAL)) {
				permit_adm = 1;
				break;
			}
		}
	}

	if (!permit || !permit_adm) {
		logit("Received request to connect to path %.100s, "
		    "but the request was denied.", path);
		return NULL;
	}
	return connect_to(ssh, path, PORT_STREAMLOCAL, ctype, rname);
}

void
channel_send_window_changes(struct ssh *ssh)
{
	struct ssh_channels *sc = ssh->chanctxt;
	struct winsize ws;
	int r;
	u_int i;

	for (i = 0; i < sc->channels_alloc; i++) {
		if (sc->channels[i] == NULL || !sc->channels[i]->client_tty ||
		    sc->channels[i]->type != SSH_CHANNEL_OPEN)
			continue;
		if (ioctl(sc->channels[i]->rfd, TIOCGWINSZ, &ws) < 0)
			continue;
		channel_request_start(ssh, i, "window-change", 0);
		if ((r = sshpkt_put_u32(ssh, (u_int)ws.ws_col)) != 0 ||
		    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_row)) != 0 ||
		    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_xpixel)) != 0 ||
		    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_ypixel)) != 0 ||
		    (r = sshpkt_send(ssh)) != 0)
			fatal("%s: channel %u: send window-change: %s",
			    __func__, i, ssh_err(r));
	}
}

/* Return RDYNAMIC_OPEN channel: channel allows SOCKS, but is not connected */
static Channel *
rdynamic_connect_prepare(struct ssh *ssh, char *ctype, char *rname)
{
	Channel *c;
	int r;

	c = channel_new(ssh, ctype, SSH_CHANNEL_RDYNAMIC_OPEN, -1, -1, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);
	c->host_port = 0;
	c->path = NULL;

	/*
	 * We need to open the channel before we have a FD,
	 * so that we can get SOCKS header from peer.
	 */
	if ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||
	    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||
	    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||
	    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||
	    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {
		fatal("%s: channel %i: confirm: %s", __func__,
		    c->self, ssh_err(r));
	}
	return c;
}

/* Return CONNECTING socket to remote host:port or local socket path */
static int
rdynamic_connect_finish(struct ssh *ssh, Channel *c)
{
	struct channel_connect cctx;
	int sock;

	memset(&cctx, 0, sizeof(cctx));
	sock = connect_to_helper(ssh, c->path, c->host_port, SOCK_STREAM, NULL,
	    NULL, &cctx, NULL, NULL);
	if (sock == -1)
		channel_connect_ctx_free(&cctx);
	else {
		/* similar to SSH_CHANNEL_CONNECTING but we've already sent the open */
		c->type = SSH_CHANNEL_RDYNAMIC_FINISH;
		c->connect_ctx = cctx;
		channel_register_fds(ssh, c, sock, sock, -1, 0, 1, 0);
	}
	return sock;
}

/* -- X11 forwarding */

/*
 * Creates an internet domain socket for listening for X11 connections.
 * Returns 0 and a suitable display number for the DISPLAY variable
 * stored in display_numberp , or -1 if an error occurs.
 */
int
x11_create_display_inet(struct ssh *ssh, int x11_display_offset,
    int x11_use_localhost, int single_connection,
    u_int *display_numberp, int **chanids)
{
	Channel *nc = NULL;
	int display_number, sock;
	u_short port;
	struct addrinfo hints, *ai, *aitop;
	char strport[NI_MAXSERV];
	int gaierr, n, num_socks = 0, socks[NUM_SOCKS];

	if (chanids == NULL)
		return -1;

	for (display_number = x11_display_offset;
	    display_number < MAX_DISPLAYS;
	    display_number++) {
		port = 6000 + display_number;
		memset(&hints, 0, sizeof(hints));
		hints.ai_family = ssh->chanctxt->IPv4or6;
		hints.ai_flags = x11_use_localhost ? 0: AI_PASSIVE;
		hints.ai_socktype = SOCK_STREAM;
		snprintf(strport, sizeof strport, "%d", port);
		if ((gaierr = getaddrinfo(NULL, strport,
		    &hints, &aitop)) != 0) {
			error("getaddrinfo: %.100s", ssh_gai_strerror(gaierr));
			return -1;
		}
		for (ai = aitop; ai; ai = ai->ai_next) {
			if (ai->ai_family != AF_INET &&
			    ai->ai_family != AF_INET6)
				continue;
			sock = socket(ai->ai_family, ai->ai_socktype,
			    ai->ai_protocol);
			if (sock < 0) {
				error("socket: %.100s", strerror(errno));
				freeaddrinfo(aitop);
				return -1;
			}
			channel_set_reuseaddr(sock);
			if (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {
				debug2("%s: bind port %d: %.100s", __func__,
				    port, strerror(errno));
				close(sock);
				for (n = 0; n < num_socks; n++)
					close(socks[n]);
				num_socks = 0;
				break;
			}
			socks[num_socks++] = sock;
			if (num_socks == NUM_SOCKS)
				break;
		}
		freeaddrinfo(aitop);
		if (num_socks > 0)
			break;
	}
	if (display_number >= MAX_DISPLAYS) {
		error("Failed to allocate internet-domain X11 display socket.");
		return -1;
	}
	/* Start listening for connections on the socket. */
	for (n = 0; n < num_socks; n++) {
		sock = socks[n];
		if (listen(sock, SSH_LISTEN_BACKLOG) < 0) {
			error("listen: %.100s", strerror(errno));
			close(sock);
			return -1;
		}
	}

	/* Allocate a channel for each socket. */
	*chanids = xcalloc(num_socks + 1, sizeof(**chanids));
	for (n = 0; n < num_socks; n++) {
		sock = socks[n];
		nc = channel_new(ssh, "x11 listener",
		    SSH_CHANNEL_X11_LISTENER, sock, sock, -1,
		    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,
		    0, "X11 inet listener", 1);
		nc->single_connection = single_connection;
		(*chanids)[n] = nc->self;
	}
	(*chanids)[n] = -1;

	/* Return the display number for the DISPLAY environment variable. */
	*display_numberp = display_number;
	return 0;
}

static int
connect_local_xsocket(u_int dnr)
{
	int sock;
	struct sockaddr_un addr;

	sock = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sock < 0)
		error("socket: %.100s", strerror(errno));
	memset(&addr, 0, sizeof(addr));
	addr.sun_family = AF_UNIX;
	snprintf(addr.sun_path, sizeof addr.sun_path, _PATH_UNIX_X, dnr);
	if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0)
		return sock;
	close(sock);
	error("connect %.100s: %.100s", addr.sun_path, strerror(errno));
	return -1;
}

int
x11_connect_display(struct ssh *ssh)
{
	u_int display_number;
	const char *display;
	char buf[1024], *cp;
	struct addrinfo hints, *ai, *aitop;
	char strport[NI_MAXSERV];
	int gaierr, sock = 0;

	/* Try to open a socket for the local X server. */
	display = getenv("DISPLAY");
	if (!display) {
		error("DISPLAY not set.");
		return -1;
	}
	/*
	 * Now we decode the value of the DISPLAY variable and make a
	 * connection to the real X server.
	 */

	/*
	 * Check if it is a unix domain socket.  Unix domain displays are in
	 * one of the following formats: unix:d[.s], :d[.s], ::d[.s]
	 */
	if (strncmp(display, "unix:", 5) == 0 ||
	    display[0] == ':') {
		/* Connect to the unix domain socket. */
		if (sscanf(strrchr(display, ':') + 1, "%u",
		    &display_number) != 1) {
			error("Could not parse display number from DISPLAY: "
			    "%.100s", display);
			return -1;
		}
		/* Create a socket. */
		sock = connect_local_xsocket(display_number);
		if (sock < 0)
			return -1;

		/* OK, we now have a connection to the display. */
		return sock;
	}
	/*
	 * Connect to an inet socket.  The DISPLAY value is supposedly
	 * hostname:d[.s], where hostname may also be numeric IP address.
	 */
	strlcpy(buf, display, sizeof(buf));
	cp = strchr(buf, ':');
	if (!cp) {
		error("Could not find ':' in DISPLAY: %.100s", display);
		return -1;
	}
	*cp = 0;
	/*
	 * buf now contains the host name.  But first we parse the
	 * display number.
	 */
	if (sscanf(cp + 1, "%u", &display_number) != 1) {
		error("Could not parse display number from DISPLAY: %.100s",
		    display);
		return -1;
	}

	/* Look up the host address */
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = ssh->chanctxt->IPv4or6;
	hints.ai_socktype = SOCK_STREAM;
	snprintf(strport, sizeof strport, "%u", 6000 + display_number);
	if ((gaierr = getaddrinfo(buf, strport, &hints, &aitop)) != 0) {
		error("%.100s: unknown host. (%s)", buf,
		ssh_gai_strerror(gaierr));
		return -1;
	}
	for (ai = aitop; ai; ai = ai->ai_next) {
		/* Create a socket. */
		sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
		if (sock < 0) {
			debug2("socket: %.100s", strerror(errno));
			continue;
		}
		/* Connect it to the display. */
		if (connect(sock, ai->ai_addr, ai->ai_addrlen) < 0) {
			debug2("connect %.100s port %u: %.100s", buf,
			    6000 + display_number, strerror(errno));
			close(sock);
			continue;
		}
		/* Success */
		break;
	}
	freeaddrinfo(aitop);
	if (!ai) {
		error("connect %.100s port %u: %.100s", buf,
		    6000 + display_number, strerror(errno));
		return -1;
	}
	set_nodelay(sock);
	return sock;
}

/*
 * Requests forwarding of X11 connections, generates fake authentication
 * data, and enables authentication spoofing.
 * This should be called in the client only.
 */
void
x11_request_forwarding_with_spoofing(struct ssh *ssh, int client_session_id,
    const char *disp, const char *proto, const char *data, int want_reply)
{
	struct ssh_channels *sc = ssh->chanctxt;
	u_int data_len = (u_int) strlen(data) / 2;
	u_int i, value;
	const char *cp;
	char *new_data;
	int r, screen_number;

	if (sc->x11_saved_display == NULL)
		sc->x11_saved_display = xstrdup(disp);
	else if (strcmp(disp, sc->x11_saved_display) != 0) {
		error("x11_request_forwarding_with_spoofing: different "
		    "$DISPLAY already forwarded");
		return;
	}

	cp = strchr(disp, ':');
	if (cp)
		cp = strchr(cp, '.');
	if (cp)
		screen_number = (u_int)strtonum(cp + 1, 0, 400, NULL);
	else
		screen_number = 0;

	if (sc->x11_saved_proto == NULL) {
		/* Save protocol name. */
		sc->x11_saved_proto = xstrdup(proto);

		/* Extract real authentication data. */
		sc->x11_saved_data = xmalloc(data_len);
		for (i = 0; i < data_len; i++) {
			if (sscanf(data + 2 * i, "%2x", &value) != 1)
				fatal("x11_request_forwarding: bad "
				    "authentication data: %.100s", data);
			sc->x11_saved_data[i] = value;
		}
		sc->x11_saved_data_len = data_len;

		/* Generate fake data of the same length. */
		sc->x11_fake_data = xmalloc(data_len);
		arc4random_buf(sc->x11_fake_data, data_len);
		sc->x11_fake_data_len = data_len;
	}

	/* Convert the fake data into hex. */
	new_data = tohex(sc->x11_fake_data, data_len);

	/* Send the request packet. */
	channel_request_start(ssh, client_session_id, "x11-req", want_reply);
	if ((r = sshpkt_put_u8(ssh, 0)) != 0 || /* bool: single connection */
	    (r = sshpkt_put_cstring(ssh, proto)) != 0 ||
	    (r = sshpkt_put_cstring(ssh, new_data)) != 0 ||
	    (r = sshpkt_put_u32(ssh, screen_number)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0 ||
	    (r = ssh_packet_write_wait(ssh)) != 0)
		fatal("%s: send x11-req: %s", __func__, ssh_err(r));
	free(new_data);
}
@


1.374
log
@write the correct buffer when tunnel forwarding; doesn't matter
on OpenBSD (they are the same) but does matter on portable where
we use an output filter to translate os-specific tun/tap headers
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.373 2017/09/23 22:04:07 djm Exp $ */
d3098 1
a3098 1
		    (r = sshpkt_get_string_direct(ssh, NULL, NULL)) == 0) {
@


1.373
log
@fix tunnel forwarding problem introduced in refactor; reported by
stsp@@ ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.372 2017/09/21 19:16:53 markus Exp $ */
d1925 1
a1925 1
		len = write(c->wfd, data, dlen);
@


1.372
log
@Add 'reverse' dynamic forwarding which combines dynamic forwarding
(-D) with remote forwarding (-R) where the remote-forwarded port
expects SOCKS-requests.

The SSH server code is unchanged and the parsing happens at the SSH
clients side. Thus the full SOCKS-request is sent over the forwarded
channel and the client parses c->output. Parsing happens in
channel_before_prepare_select(), _before_ the select bitmask is
computed in the pre[] handlers, but after network input processing
in the post[] handlers.

help and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.371 2017/09/19 12:10:30 millert Exp $ */
d2422 2
a2423 1
	size_t len, dlen;
d2450 2
a2451 2
		if ((r = sshbuf_peek_string_direct(c->input, NULL, &dlen)) != 0)
			fatal("%s: channel %d: peek datagram: %s", __func__,
d2458 1
a2458 1
		if (dlen > c->remote_window || dlen > c->remote_maxpacket) {
d2465 1
a2465 1
		    (r = sshpkt_put_stringb(ssh, c->input)) != 0 ||
d2470 1
a2470 1
		c->remote_window -= dlen;
@


1.371
log
@Use explicit_bzero() instead of bzero() before free() to prevent
the compiler from optimizing away the bzero() call.  OK djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.370 2017/09/12 07:55:48 djm Exp $ */
d206 2
d281 2
d668 1
d679 1
d706 2
d773 2
d1127 1
a1127 2
channel_decode_socks4(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
d1143 1
a1143 1
	have = sshbuf_len(c->input);
d1147 1
a1147 1
	p = sshbuf_ptr(c->input);
d1172 4
a1175 4
	if ((r = sshbuf_get(c->input, &s4_req.version, 1)) != 0 ||
	    (r = sshbuf_get(c->input, &s4_req.command, 1)) != 0 ||
	    (r = sshbuf_get(c->input, &s4_req.dest_port, 2)) != 0 ||
	    (r = sshbuf_get(c->input, &s4_req.dest_addr, 4)) != 0) {
d1179 2
a1180 2
	have = sshbuf_len(c->input);
	p = sshbuf_ptr(c->input);
d1190 1
a1190 1
	if ((r = sshbuf_consume(c->input, len)) != 0) {
d1200 2
a1201 2
		have = sshbuf_len(c->input);
		p = sshbuf_ptr(c->input);
d1217 1
a1217 1
		if ((r = sshbuf_consume(c->input, len)) != 0) {
d1236 1
a1236 1
	if ((r = sshbuf_put(c->output, &s4_rsp, sizeof(s4_rsp))) != 0) {
d1253 1
a1253 2
channel_decode_socks5(struct ssh *ssh, Channel *c,
    fd_set *readset, fd_set *writeset)
d1269 1
a1269 1
	p = sshbuf_ptr(c->input);
d1272 1
a1272 1
	have = sshbuf_len(c->input);
d1292 1
a1292 1
		if ((r = sshbuf_consume(c->input, nmethods + 2)) != 0) {
d1297 2
a1298 2
		if ((r = sshbuf_put_u8(c->output, 0x05)) != 0 ||
		    (r = sshbuf_put_u8(c->output, SSH_SOCKS5_NOAUTH)) != 0) {
a1301 1
		FD_SET(c->sock, writeset);
d1338 1
a1338 1
	if ((r = sshbuf_consume(c->input, sizeof(s5_req))) != 0) {
d1344 1
a1344 1
		if ((r = sshbuf_consume(c->input, 1)) != 0) {
d1349 2
a1350 2
	if ((r = sshbuf_get(c->input, &dest_addr, addrlen)) != 0 ||
	    (r = sshbuf_get(c->input, &dest_port, 2)) != 0) {
d1380 3
a1382 3
	if ((r = sshbuf_put(c->output, &s5_rsp, sizeof(s5_rsp))) != 0 ||
	    (r = sshbuf_put_u32(c->output, ntohl(INADDR_ANY))) != 0 ||
	    (r = sshbuf_put(c->output, &dest_port, sizeof(dest_port))) != 0)
d1434 1
a1434 1
		ret = channel_decode_socks4(ssh, c, readset, writeset);
d1437 1
a1437 1
		ret = channel_decode_socks5(ssh, c, readset, writeset);
d1449 2
d1458 75
d1776 1
a1776 1
	int err = 0, sock, r;
d1783 2
a1784 1

d1794 15
a1808 8
		if ((r = sshpkt_start(ssh,
		    SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||
		    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||
		    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||
		    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||
		    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {
			fatal("%s: channel %i: confirm: %s", __func__,
			    c->self, ssh_err(r));
d1824 19
a1842 11
		if ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_FAILURE)) != 0 ||
		    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||
		    (r = sshpkt_put_u32(ssh, SSH2_OPEN_CONNECT_FAILED)) != 0) {
			fatal("%s: channel %i: failure: %s", __func__,
			    c->self, ssh_err(r));
		}
		if ((datafellows & SSH_BUG_OPENFAILURE) == 0 &&
		    ((r = sshpkt_put_cstring(ssh, strerror(err))) != 0 ||
		    (r = sshpkt_put_cstring(ssh, "")) != 0)) {
			fatal("%s: channel %i: failure: %s", __func__,
			    c->self, ssh_err(r));
a1843 1
		chan_mark_dead(ssh, c);
a1844 2
	if ((r = sshpkt_send(ssh)) != 0)
		fatal("%s: channel %i: %s", __func__, c->self, ssh_err(r));
d2256 1
d2269 1
d2351 21
d2381 2
d2888 2
d3128 1
a3128 1
        }
d4029 1
a4029 1
 * Return CONNECTING channel to remote host:port or local socket path,
d4032 4
a4035 3
static Channel *
connect_to_reason(struct ssh *ssh, const char *name, int port,
    char *ctype, char *rname, int *reason, const char **errmsg)
a4040 4
	struct channel_connect cctx;
	Channel *c;

	memset(&cctx, 0, sizeof(cctx));
d4048 1
a4048 1
			return (NULL);
d4061 1
a4061 1
		ai->ai_socktype = SOCK_STREAM;
d4066 1
a4066 1
		cctx.aitop = ai;
d4070 1
a4070 1
		hints.ai_socktype = SOCK_STREAM;
d4072 1
a4072 1
		if ((gaierr = getaddrinfo(name, strport, &hints, &cctx.aitop))
d4080 1
a4080 1
			return NULL;
d4084 3
a4086 3
	cctx.host = xstrdup(name);
	cctx.port = port;
	cctx.ai = cctx.aitop;
d4088 1
a4088 1
	if ((sock = connect_next(&cctx)) == -1) {
d4091 19
d4115 2
d4118 1
a4121 8
/* Return CONNECTING channel to remote host:port or local socket path */
static Channel *
connect_to(struct ssh *ssh, const char *name, int port,
    char *ctype, char *rname)
{
	return connect_to_reason(ssh, name, port, ctype, rname, NULL, NULL);
}

d4139 3
d4179 2
d4182 1
d4214 16
a4229 1
	return connect_to_reason(ssh, host, port, ctype, rname, reason, errmsg);
d4294 48
@


1.370
log
@unused variable
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.369 2017/09/12 07:32:04 djm Exp $ */
d566 1
a566 1
	bzero(c, sizeof(*c));
@


1.369
log
@fix tun/tap forwarding case in previous
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.368 2017/09/12 06:35:31 djm Exp $ */
d2494 1
a2494 1
	int ret = -1, r, idx;
d2593 1
a2593 1
		idx = fwd_perm_list_add(ssh, FWDPERM_USER, "<mux>", -1,
@


1.368
log
@Make remote channel ID a u_int

Previously we tracked the remote channel IDs in an int, but this is
strictly incorrect: the wire protocol uses uint32 and there is nothing
in-principle stopping a SSH implementation from sending, say, 0xffff0000.

In practice everyone numbers their channels sequentially, so this has
never been a problem.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.367 2017/09/12 06:32:07 djm Exp $ */
d1820 1
@


1.367
log
@refactor channels.c

Move static state to a "struct ssh_channels" that is allocated at
runtime and tracked as a member of struct ssh.

Explicitly pass "struct ssh" to all channels functions.

Replace use of the legacy packet APIs in channels.c.

Rework sshd_config PermitOpen handling: previously the configuration
parser would call directly into the channels layer. After the refactor
this is not possible, as the channels structures are allocated at
connection time and aren't available when the configuration is parsed.
The server config parser now tracks PermitOpen itself and explicitly
configures the channels code later.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.366 2017/08/30 03:59:08 djm Exp $ */
d249 1
a249 1
channel_by_remote_id(struct ssh *ssh, int remote_id)
d256 1
a256 1
		if (c != NULL && c->remote_id == remote_id)
a379 1
	c->remote_id = -1;
d695 1
a695 1
		if (c == NULL || c->remote_id < 0)
d770 1
a770 1
			    "(t%d r%d i%u/%zu o%u/%zu fd %d/%d cc %d)\r\n",
d772 2
a773 1
			    c->type, c->remote_id,
d831 3
d926 3
d1697 2
d1963 3
d2321 3
d2390 2
d2558 1
d2702 1
a2702 1
		if (cp && len > 4)
d2704 2
d2914 2
a2915 2
	c->remote_id = channel_parse_id(ssh, __func__, "open confirmation");
	if ((r = sshpkt_get_u32(ssh, &remote_window)) != 0 ||
d2922 1
@


1.366
log
@pass packet state down to some of the channels function (more
to come...); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.365 2017/05/31 08:58:52 deraadt Exp $ */
d55 1
d57 1
a63 1
#include <stdarg.h>
d69 1
a72 1
#include "buffer.h"
d80 2
a81 1
/* -- channel core */
d83 3
a85 5
/*
 * Pointer to an array containing all allocated channels.  The array is
 * dynamically extended as needed.
 */
static Channel **channels = NULL;
d87 2
a88 11
/*
 * Size of the channel array.  All slots of the array must always be
 * initialized (at least the type field); unused slots set to NULL
 */
static u_int channels_alloc = 0;

/*
 * Maximum file descriptor value used in any of the channels.  This is
 * updated in channel_new.
 */
static int channel_max_fd = 0;
d90 3
a92 2

/* -- tcp forwarding */
d112 2
a113 2
/* List of all permitted host/port pairs to connect by the user. */
static ForwardPermission *permitted_opens = NULL;
d115 7
a121 2
/* List of all permitted host/port pairs to connect by the admin. */
static ForwardPermission *permitted_adm_opens = NULL;
d123 5
a127 2
/* Number of permitted host/port pairs in the array permitted by the user. */
static int num_permitted_opens = 0;
d129 5
a133 2
/* Number of permitted host/port pair in the array permitted by the admin. */
static int num_adm_permitted_opens = 0;
d135 9
a143 2
/* special-case port number meaning allow any port */
#define FWD_PERMIT_ANY_PORT	0
d145 1
a145 2
/* special-case wildcard meaning allow any host */
#define FWD_PERMIT_ANY_HOST	"*"
d147 2
a148 6
/*
 * If this is true, all opens are permitted.  This is the case on the server
 * on which we have to trust the client anyway, and the user could do
 * anything after logging in anyway.
 */
static int all_opens_permitted = 0;
d150 2
d153 5
a157 1
/* -- X11 forwarding */
d159 5
a163 2
/* Maximum number of fake X11 displays to try. */
#define MAX_DISPLAYS  1000
d165 6
a170 2
/* Saved X11 local (client) display. */
static char *x11_saved_display = NULL;
d172 1
a172 2
/* Saved X11 authentication protocol name. */
static char *x11_saved_proto = NULL;
d174 2
a175 3
/* Saved X11 authentication data.  This is the real data. */
static char *x11_saved_data = NULL;
static u_int x11_saved_data_len = 0;
d177 2
a178 2
/* Deadline after which all X11 connections are refused */
static u_int x11_refuse_time;
d180 3
a182 6
/*
 * Fake X11 authentication data.  This is what the server will be sending us;
 * we should replace any occurrences of this by the real data.
 */
static u_char *x11_fake_data = NULL;
static u_int x11_fake_data_len;
d184 2
d187 7
a193 3
/* -- agent forwarding */

#define	NUM_SOCKS	10
d195 3
a197 2
/* AF_UNSPEC or AF_INET or AF_INET6 */
static int IPv4or6 = AF_UNSPEC;
d200 1
a200 1
static void port_open_helper(Channel *c, char *rtype);
d207 3
d212 19
d232 1
a232 1
channel_by_id(int id)
d236 2
a237 2
	if (id < 0 || (u_int)id >= channels_alloc) {
		logit("channel_by_id: %d: bad id", id);
d240 1
a240 1
	c = channels[id];
d242 1
a242 1
		logit("channel_by_id: %d: bad id: channel free", id);
d249 1
a249 1
channel_by_remote_id(int remote_id)
d254 2
a255 2
	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
d267 1
a267 1
channel_lookup(int id)
d271 2
a272 2
	if ((c = channel_by_id(id)) == NULL)
		return (NULL);
d283 1
a283 1
		return (c);
d286 1
a286 1
	return (NULL);
d294 1
a294 1
channel_register_fds(Channel *c, int rfd, int wfd, int efd,
d297 2
d300 3
a302 3
	channel_max_fd = MAXIMUM(channel_max_fd, rfd);
	channel_max_fd = MAXIMUM(channel_max_fd, wfd);
	channel_max_fd = MAXIMUM(channel_max_fd, efd);
d336 1
a336 1
channel_new(char *ctype, int type, int rfd, int wfd, int efd,
d339 2
a340 2
	int found;
	u_int i;
a342 7
	/* Do initial allocation if this is the first call. */
	if (channels_alloc == 0) {
		channels_alloc = 10;
		channels = xcalloc(channels_alloc, sizeof(Channel *));
		for (i = 0; i < channels_alloc; i++)
			channels[i] = NULL;
	}
d344 2
a345 2
	for (found = -1, i = 0; i < channels_alloc; i++)
		if (channels[i] == NULL) {
d347 1
a347 1
			found = (int)i;
d350 14
a363 12
	if (found < 0) {
		/* There are no free slots.  Take last+1 slot and expand the array.  */
		found = channels_alloc;
		if (channels_alloc > 10000)
			fatal("channel_new: internal error: channels_alloc %d "
			    "too big.", channels_alloc);
		channels = xreallocarray(channels, channels_alloc + 10,
		    sizeof(Channel *));
		channels_alloc += 10;
		debug2("channel: expanding %d", channels_alloc);
		for (i = found; i < channels_alloc; i++)
			channels[i] = NULL;
d366 5
a370 7
	c = channels[found] = xcalloc(1, sizeof(Channel));
	buffer_init(&c->input);
	buffer_init(&c->output);
	buffer_init(&c->extended);
	c->path = NULL;
	c->listening_addr = NULL;
	c->listening_port = 0;
d373 1
a373 3
	c->flags = 0;
	channel_register_fds(c, rfd, wfd, efd, extusage, nonblock, 0);
	c->notbefore = 0;
a378 1
	c->local_consumed = 0;
a381 12
	c->remote_window = 0;
	c->remote_maxpacket = 0;
	c->force_drain = 0;
	c->single_connection = 0;
	c->detach_user = NULL;
	c->detach_close = 0;
	c->open_confirm = NULL;
	c->open_confirm_ctx = NULL;
	c->input_filter = NULL;
	c->output_filter = NULL;
	c->filter_ctx = NULL;
	c->filter_cleanup = NULL;
a382 3
	c->mux_rcb = NULL;
	c->mux_ctx = NULL;
	c->mux_pause = 0;
d389 2
a390 2
static int
channel_find_maxfd(void)
d396 2
a397 2
	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
d404 1
a404 1
	return max;
d408 1
a408 1
channel_close_fd(int *fdp)
d410 1
d416 2
a417 2
		if (fd == channel_max_fd)
			channel_max_fd = channel_find_maxfd();
d424 10
a433 1
channel_close_fds(Channel *c)
d435 75
a509 4
	channel_close_fd(&c->sock);
	channel_close_fd(&c->rfd);
	channel_close_fd(&c->wfd);
	channel_close_fd(&c->efd);
d514 1
a514 1
channel_free(Channel *c)
d516 1
d522 12
a533 13
	for (n = 0, i = 0; i < channels_alloc; i++) {
		if ((other = channels[i]) != NULL) {
			n++;

			/* detach from mux client and prepare for closing */
			if (c->type == SSH_CHANNEL_MUX_CLIENT &&
			    other->type == SSH_CHANNEL_MUX_PROXY &&
			    other->mux_ctx == c) {
				other->mux_ctx = NULL;
				other->type = SSH_CHANNEL_OPEN;
				other->istate = CHAN_INPUT_CLOSED;
				other->ostate = CHAN_OUTPUT_CLOSED;
			}
d539 2
a540 28
	/* XXX more MUX cleanup: remove remote forwardings */
	if (c->type == SSH_CHANNEL_MUX_CLIENT) {
		for (i = 0; i < (u_int)num_permitted_opens; i++) {
			if (permitted_opens[i].downstream != c)
				continue;
			/* cancel on the server, since mux client is gone */
			debug("channel %d: cleanup remote forward for %s:%u",
			    c->self,
			    permitted_opens[i].listen_host,
			    permitted_opens[i].listen_port);
			packet_start(SSH2_MSG_GLOBAL_REQUEST);
			packet_put_cstring("cancel-tcpip-forward");
			packet_put_char(0);
			packet_put_cstring(channel_rfwd_bind_host(
			    permitted_opens[i].listen_host));
			packet_put_int(permitted_opens[i].listen_port);
			packet_send();
			/* unregister */
			permitted_opens[i].listen_port = 0;
			permitted_opens[i].port_to_connect = 0;
			free(permitted_opens[i].host_to_connect);
			permitted_opens[i].host_to_connect = NULL;
			free(permitted_opens[i].listen_host);
			permitted_opens[i].listen_host = NULL;
			permitted_opens[i].listen_path = NULL;
			permitted_opens[i].downstream = NULL;
		}
	}
d542 1
a542 1
	s = channel_open_message();
d546 5
a550 4
	channel_close_fds(c);
	buffer_free(&c->input);
	buffer_free(&c->output);
	buffer_free(&c->extended);
d559 1
a559 1
			cc->abandon_cb(c, cc->ctx);
d565 3
a567 2
		c->filter_cleanup(c->self, c->filter_ctx);
	channels[c->self] = NULL;
d572 1
a572 1
channel_free_all(void)
d576 3
a578 3
	for (i = 0; i < channels_alloc; i++)
		if (channels[i] != NULL)
			channel_free(channels[i]);
d586 1
a586 1
channel_close_all(void)
d590 3
a592 3
	for (i = 0; i < channels_alloc; i++)
		if (channels[i] != NULL)
			channel_close_fds(channels[i]);
d599 1
a599 1
channel_stop_listening(void)
d604 2
a605 2
	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
d614 2
a615 2
				channel_close_fd(&c->sock);
				channel_free(c);
d627 1
a627 1
channel_not_very_much_buffered_data(void)
d630 1
d633 8
a640 9
	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c != NULL && c->type == SSH_CHANNEL_OPEN) {
			if (buffer_len(&c->output) > packet_get_maxsize()) {
				debug2("channel %d: big output buffer %u > %u",
				    c->self, buffer_len(&c->output),
				    packet_get_maxsize());
				return 0;
			}
d648 1
a648 1
channel_still_open(void)
d653 2
a654 2
	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
d689 1
a689 1
channel_find_open(void)
d694 2
a695 2
	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
d733 1
a733 1
channel_open_message(void)
d735 1
a735 1
	Buffer buffer;
a736 1
	char buf[1024], *cp;
d738 2
d741 7
a747 5
	buffer_init(&buffer);
	snprintf(buf, sizeof buf, "The following connections are open:\r\n");
	buffer_append(&buffer, buf, strlen(buf));
	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
d770 2
a771 2
			snprintf(buf, sizeof buf,
			    "  #%d %.300s (t%d r%d i%u/%d o%u/%d fd %d/%d cc %d)\r\n",
d774 5
a778 4
			    c->istate, buffer_len(&c->input),
			    c->ostate, buffer_len(&c->output),
			    c->rfd, c->wfd, c->ctl_chan);
			buffer_append(&buffer, buf, strlen(buf));
d781 1
a781 1
			fatal("channel_open_message: bad channel type %d", c->type);
d785 18
a802 4
	buffer_append(&buffer, "\0", 1);
	cp = xstrdup((char *)buffer_ptr(&buffer));
	buffer_free(&buffer);
	return cp;
d806 1
a806 1
channel_send_open(int id)
d808 2
a809 1
	Channel *c = channel_lookup(id);
d816 3
a818 6
	packet_start(SSH2_MSG_CHANNEL_OPEN);
	packet_put_cstring(c->ctype);
	packet_put_int(c->self);
	packet_put_int(c->local_window);
	packet_put_int(c->local_maxpacket);
	packet_send();
d822 1
a822 1
channel_request_start(int id, char *service, int wantconfirm)
d824 2
a825 1
	Channel *c = channel_lookup(id);
d828 1
a828 1
		logit("channel_request_start: %d: unknown channel id", id);
d832 6
a837 4
	packet_start(SSH2_MSG_CHANNEL_REQUEST);
	packet_put_int(c->remote_id);
	packet_put_cstring(service);
	packet_put_char(wantconfirm);
d841 2
a842 2
channel_register_status_confirm(int id, channel_confirm_cb *cb,
    channel_confirm_abandon_cb *abandon_cb, void *ctx)
d847 2
a848 2
	if ((c = channel_lookup(id)) == NULL)
		fatal("channel_register_expect: %d: bad id", id);
d858 2
a859 1
channel_register_open_confirm(int id, channel_open_fn *fn, void *ctx)
d861 1
a861 1
	Channel *c = channel_lookup(id);
d864 1
a864 1
		logit("channel_register_open_confirm: %d: bad id", id);
d872 2
a873 1
channel_register_cleanup(int id, channel_callback_fn *fn, int do_close)
d875 1
a875 1
	Channel *c = channel_by_id(id);
d878 1
a878 1
		logit("channel_register_cleanup: %d: bad id", id);
d886 1
a886 1
channel_cancel_cleanup(int id)
d888 1
a888 1
	Channel *c = channel_by_id(id);
d891 1
a891 1
		logit("channel_cancel_cleanup: %d: bad id", id);
d899 1
a899 1
channel_register_filter(int id, channel_infilter_fn *ifn,
d902 1
a902 1
	Channel *c = channel_lookup(id);
d905 1
a905 1
		logit("channel_register_filter: %d: bad id", id);
d915 1
a915 1
channel_set_fds(int id, int rfd, int wfd, int efd,
d918 2
a919 1
	Channel *c = channel_lookup(id);
d923 1
a923 1
	channel_register_fds(c, rfd, wfd, efd, extusage, nonblock, is_tty);
d926 6
a931 4
	packet_start(SSH2_MSG_CHANNEL_WINDOW_ADJUST);
	packet_put_int(c->remote_id);
	packet_put_int(c->local_window);
	packet_send();
a933 13
/*
 * 'channel_pre*' are called just before select() to add any bits relevant to
 * channels in the select bitmasks.
 */
/*
 * 'channel_post*': perform any appropriate operations for channels which
 * have events pending.
 */
typedef void chan_fn(Channel *c, fd_set *readset, fd_set *writeset);
chan_fn *channel_pre[SSH_CHANNEL_MAX_TYPE];
chan_fn *channel_post[SSH_CHANNEL_MAX_TYPE];

/* ARGSUSED */
d935 2
a936 1
channel_pre_listener(Channel *c, fd_set *readset, fd_set *writeset)
a940 1
/* ARGSUSED */
d942 2
a943 1
channel_pre_connecting(Channel *c, fd_set *readset, fd_set *writeset)
d950 2
a951 1
channel_pre_open(Channel *c, fd_set *readset, fd_set *writeset)
d955 2
a956 2
	    buffer_len(&c->input) < c->remote_window &&
	    buffer_check_alloc(&c->input, CHAN_RBUF))
d960 1
a960 1
		if (buffer_len(&c->output) > 0) {
d964 3
a966 2
				debug2("channel %d: obuf_empty delayed efd %d/(%d)",
				    c->self, c->efd, buffer_len(&c->extended));
d968 1
a968 1
				chan_obuf_empty(c);
d975 1
a975 1
		    buffer_len(&c->extended) > 0)
d980 1
a980 1
		    buffer_len(&c->extended) < c->remote_window)
d996 1
a996 1
x11_open_helper(Buffer *b)
d998 1
d1003 2
a1004 1
	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
d1011 1
a1011 1
	if (buffer_len(b) < 12)
d1015 1
a1015 1
	ucp = buffer_ptr(b);
d1029 1
a1029 1
	if (buffer_len(b) <
d1034 2
a1035 2
	if (proto_len != strlen(x11_saved_proto) ||
	    memcmp(ucp + 12, x11_saved_proto, proto_len) != 0) {
d1040 1
a1040 1
	if (data_len != x11_fake_data_len ||
d1042 1
a1042 1
		x11_fake_data, x11_fake_data_len) != 0) {
d1047 1
a1047 1
	if (x11_fake_data_len != x11_saved_data_len) {
d1049 1
a1049 1
		    x11_fake_data_len, x11_saved_data_len);
d1058 1
a1058 1
	    x11_saved_data, x11_saved_data_len);
d1063 2
a1064 1
channel_pre_x11_open(Channel *c, fd_set *readset, fd_set *writeset)
d1066 1
a1066 1
	int ret = x11_open_helper(&c->output);
d1072 1
a1072 1
		channel_pre_open(c, readset, writeset);
d1075 7
a1081 6
		debug2("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
		chan_read_failed(c);
		buffer_clear(&c->input);
		chan_ibuf_empty(c);
		buffer_clear(&c->output);
		chan_write_failed(c);
d1087 2
a1088 1
channel_pre_mux_client(Channel *c, fd_set *readset, fd_set *writeset)
d1091 1
a1091 1
	    buffer_check_alloc(&c->input, CHAN_RBUF))
d1095 2
a1096 2
		buffer_clear(&c->input);
		chan_ibuf_empty(c);
d1098 1
a1098 1
		chan_rcvd_oclose(c);
d1102 1
a1102 1
		if (buffer_len(&c->output) > 0)
d1105 1
a1105 1
			chan_obuf_empty(c);
a1109 1
/* ARGSUSED */
d1111 2
a1112 1
channel_decode_socks4(Channel *c, fd_set *readset, fd_set *writeset)
d1114 2
a1115 1
	char *p, *host;
d1124 1
d1128 1
a1128 1
	have = buffer_len(&c->input);
d1132 1
a1132 1
	p = (char *)buffer_ptr(&c->input);
d1157 9
a1165 6
	buffer_get(&c->input, (char *)&s4_req.version, 1);
	buffer_get(&c->input, (char *)&s4_req.command, 1);
	buffer_get(&c->input, (char *)&s4_req.dest_port, 2);
	buffer_get(&c->input, (char *)&s4_req.dest_addr, 4);
	have = buffer_len(&c->input);
	p = (char *)buffer_ptr(&c->input);
d1173 1
a1173 4
	len++;					/* trailing '\0' */
	if (len > have)
		fatal("channel %d: decode socks4: len %d > have %d",
		    c->self, len, have);
d1175 4
a1178 2
	buffer_consume(&c->input, len);

d1185 2
a1186 2
		have = buffer_len(&c->input);
		p = (char *)buffer_ptr(&c->input);
d1202 4
a1205 1
		buffer_consume(&c->input, len);
d1221 4
a1224 1
	buffer_append(&c->output, &s4_rsp, sizeof(s4_rsp));
a1236 1
/* ARGSUSED */
d1238 2
a1239 1
channel_decode_socks5(Channel *c, fd_set *readset, fd_set *writeset)
d1241 1
d1250 1
a1250 1
	u_char *p;
d1252 1
d1255 1
a1255 1
	p = buffer_ptr(&c->input);
d1258 1
a1258 1
	have = buffer_len(&c->input);
d1278 10
a1287 3
		buffer_consume(&c->input, nmethods + 2);
		buffer_put_char(&c->output, 0x05);		/* version */
		buffer_put_char(&c->output, SSH_SOCKS5_NOAUTH);	/* method */
d1325 16
a1340 5
	buffer_consume(&c->input, sizeof(s5_req));
	if (s5_req.atyp == SSH_SOCKS5_DOMAIN)
		buffer_consume(&c->input, 1);    /* host string length */
	buffer_get(&c->input, &dest_addr, addrlen);
	buffer_get(&c->input, (char *)&dest_port, 2);
d1367 5
a1371 3
	buffer_append(&c->output, &s5_rsp, sizeof(s5_rsp));
	buffer_put_int(&c->output, ntohl(INADDR_ANY)); /* bind address */
	buffer_append(&c->output, &dest_port, sizeof(dest_port));
d1376 2
a1377 2
channel_connect_stdio_fwd(const char *host_to_connect, u_short port_to_connect,
    int in, int out)
d1381 1
a1381 2
	debug("channel_connect_stdio_fwd %s:%d", host_to_connect,
	    port_to_connect);
d1383 1
a1383 1
	c = channel_new("stdio-forward", SSH_CHANNEL_OPENING, in, out,
d1392 2
a1393 2
	channel_register_fds(c, in, out, -1, 0, 1, 0);
	port_open_helper(c, "direct-tcpip");
d1400 2
a1401 1
channel_pre_dynamic(Channel *c, fd_set *readset, fd_set *writeset)
d1403 1
a1403 1
	u_char *p;
d1407 1
a1407 1
	have = buffer_len(&c->input);
d1409 1
a1409 1
	/* buffer_dump(&c->input); */
d1417 2
a1418 1
	p = buffer_ptr(&c->input);
d1421 1
a1421 1
		ret = channel_decode_socks4(c, readset, writeset);
d1424 1
a1424 1
		ret = channel_decode_socks5(c, readset, writeset);
d1431 1
a1431 1
		chan_mark_dead(c);
d1439 1
a1439 1
		port_open_helper(c, "direct-tcpip");
a1443 1
/* ARGSUSED */
d1445 2
a1446 1
channel_post_x11_listener(Channel *c, fd_set *readset, fd_set *writeset)
d1450 1
a1450 1
	int newsock, oerrno;
a1452 1
	int remote_port;
d1454 40
a1493 42
	if (FD_ISSET(c->sock, readset)) {
		debug("X11 connection requested.");
		addrlen = sizeof(addr);
		newsock = accept(c->sock, (struct sockaddr *)&addr, &addrlen);
		if (c->single_connection) {
			oerrno = errno;
			debug2("single_connection: closing X11 listener.");
			channel_close_fd(&c->sock);
			chan_mark_dead(c);
			errno = oerrno;
		}
		if (newsock < 0) {
			if (errno != EINTR && errno != EWOULDBLOCK &&
			    errno != ECONNABORTED)
				error("accept: %.100s", strerror(errno));
			if (errno == EMFILE || errno == ENFILE)
				c->notbefore = monotime() + 1;
			return;
		}
		set_nodelay(newsock);
		remote_ipaddr = get_peer_ipaddr(newsock);
		remote_port = get_peer_port(newsock);
		snprintf(buf, sizeof buf, "X11 connection from %.200s port %d",
		    remote_ipaddr, remote_port);

		nc = channel_new("accepted x11 socket",
		    SSH_CHANNEL_OPENING, newsock, newsock, -1,
		    c->local_window_max, c->local_maxpacket, 0, buf, 1);
		packet_start(SSH2_MSG_CHANNEL_OPEN);
		packet_put_cstring("x11");
		packet_put_int(nc->self);
		packet_put_int(nc->local_window_max);
		packet_put_int(nc->local_maxpacket);
		/* originator ipaddr and port */
		packet_put_cstring(remote_ipaddr);
		if (datafellows & SSH_BUG_X11FWD) {
			debug2("ssh2 x11 bug compat mode");
		} else {
			packet_put_int(remote_port);
		}
		packet_send();
		free(remote_ipaddr);
d1495 3
d1501 1
a1501 1
port_open_helper(Channel *c, char *rtype)
a1502 1
	char buf[1024];
d1507 1
d1516 2
a1517 1
	snprintf(buf, sizeof buf,
d1523 1
a1523 8
	free(c->remote_name);
	c->remote_name = xstrdup(buf);

	packet_start(SSH2_MSG_CHANNEL_OPEN);
	packet_put_cstring(rtype);
	packet_put_int(c->self);
	packet_put_int(c->local_window_max);
	packet_put_int(c->local_maxpacket);
d1526 5
a1530 2
		packet_put_cstring(c->path);
		packet_put_int(c->host_port);
d1533 4
a1536 1
		packet_put_cstring(c->path);
d1539 4
a1542 1
		packet_put_cstring(c->path);
d1545 5
a1549 2
		packet_put_cstring(c->path);
		packet_put_int(local_port);
d1553 4
a1556 1
		packet_put_cstring("");
d1559 5
a1563 2
		packet_put_cstring(remote_ipaddr);
		packet_put_int((u_int)remote_port);
d1565 2
a1566 1
	packet_send();
d1585 1
a1585 1
channel_set_x11_refuse_time(u_int refuse_time)
d1587 1
a1587 1
	x11_refuse_time = refuse_time;
a1592 1
/* ARGSUSED */
d1594 2
a1595 1
channel_post_port_listener(Channel *c, fd_set *readset, fd_set *writeset)
d1603 5
a1607 21
	if (FD_ISSET(c->sock, readset)) {
		debug("Connection to port %d forwarding "
		    "to %.100s port %d requested.",
		    c->listening_port, c->path, c->host_port);

		if (c->type == SSH_CHANNEL_RPORT_LISTENER) {
			nextstate = SSH_CHANNEL_OPENING;
			rtype = "forwarded-tcpip";
		} else if (c->type == SSH_CHANNEL_RUNIX_LISTENER) {
			nextstate = SSH_CHANNEL_OPENING;
			rtype = "forwarded-streamlocal@@openssh.com";
		} else if (c->host_port == PORT_STREAMLOCAL) {
			nextstate = SSH_CHANNEL_OPENING;
			rtype = "direct-streamlocal@@openssh.com";
		} else if (c->host_port == 0) {
			nextstate = SSH_CHANNEL_DYNAMIC;
			rtype = "dynamic-tcpip";
		} else {
			nextstate = SSH_CHANNEL_OPENING;
			rtype = "direct-tcpip";
		}
d1609 16
a1624 18
		addrlen = sizeof(addr);
		newsock = accept(c->sock, (struct sockaddr *)&addr, &addrlen);
		if (newsock < 0) {
			if (errno != EINTR && errno != EWOULDBLOCK &&
			    errno != ECONNABORTED)
				error("accept: %.100s", strerror(errno));
			if (errno == EMFILE || errno == ENFILE)
				c->notbefore = monotime() + 1;
			return;
		}
		if (c->host_port != PORT_STREAMLOCAL)
			set_nodelay(newsock);
		nc = channel_new(rtype, nextstate, newsock, newsock, -1,
		    c->local_window_max, c->local_maxpacket, 0, rtype, 1);
		nc->listening_port = c->listening_port;
		nc->host_port = c->host_port;
		if (c->path != NULL)
			nc->path = xstrdup(c->path);
d1626 9
a1634 2
		if (nextstate != SSH_CHANNEL_DYNAMIC)
			port_open_helper(nc, rtype);
d1636 11
a1652 1
/* ARGSUSED */
d1654 2
a1655 1
channel_post_auth_listener(Channel *c, fd_set *readset, fd_set *writeset)
d1658 1
a1658 1
	int newsock;
d1662 10
a1671 20
	if (FD_ISSET(c->sock, readset)) {
		addrlen = sizeof(addr);
		newsock = accept(c->sock, (struct sockaddr *)&addr, &addrlen);
		if (newsock < 0) {
			error("accept from auth socket: %.100s",
			    strerror(errno));
			if (errno == EMFILE || errno == ENFILE)
				c->notbefore = monotime() + 1;
			return;
		}
		nc = channel_new("accepted auth socket",
		    SSH_CHANNEL_OPENING, newsock, newsock, -1,
		    c->local_window_max, c->local_maxpacket,
		    0, "accepted auth socket", 1);
		packet_start(SSH2_MSG_CHANNEL_OPEN);
		packet_put_cstring("auth-agent@@openssh.com");
		packet_put_int(nc->self);
		packet_put_int(c->local_window_max);
		packet_put_int(c->local_maxpacket);
		packet_send();
d1673 7
a1681 1
/* ARGSUSED */
d1683 2
a1684 1
channel_post_connecting(Channel *c, fd_set *readset, fd_set *writeset)
d1686 1
a1686 1
	int err = 0, sock;
d1689 46
a1734 37
	if (FD_ISSET(c->sock, writeset)) {
		if (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, &err, &sz) < 0) {
			err = errno;
			error("getsockopt SO_ERROR failed");
		}
		if (err == 0) {
			debug("channel %d: connected to %s port %d",
			    c->self, c->connect_ctx.host, c->connect_ctx.port);
			channel_connect_ctx_free(&c->connect_ctx);
			c->type = SSH_CHANNEL_OPEN;
			packet_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);
			packet_put_int(c->remote_id);
			packet_put_int(c->self);
			packet_put_int(c->local_window);
			packet_put_int(c->local_maxpacket);
		} else {
			debug("channel %d: connection failed: %s",
			    c->self, strerror(err));
			/* Try next address, if any */
			if ((sock = connect_next(&c->connect_ctx)) > 0) {
				close(c->sock);
				c->sock = c->rfd = c->wfd = sock;
				channel_max_fd = channel_find_maxfd();
				return;
			}
			/* Exhausted all addresses */
			error("connect_to %.100s port %d: failed.",
			    c->connect_ctx.host, c->connect_ctx.port);
			channel_connect_ctx_free(&c->connect_ctx);
			packet_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);
			packet_put_int(c->remote_id);
			packet_put_int(SSH2_OPEN_CONNECT_FAILED);
			if (!(datafellows & SSH_BUG_OPENFAILURE)) {
				packet_put_cstring(strerror(err));
				packet_put_cstring("");
			}
			chan_mark_dead(c);
d1736 1
a1736 1
		packet_send();
d1738 2
a1741 1
/* ARGSUSED */
d1743 2
a1744 1
channel_handle_rfd(Channel *c, fd_set *readset, fd_set *writeset)
d1747 2
a1748 1
	int len;
d1750 12
a1761 15
	if (c->rfd != -1 &&
	    FD_ISSET(c->rfd, readset)) {
		len = read(c->rfd, buf, sizeof(buf));
		if (len < 0 && (errno == EINTR || errno == EAGAIN))
			return 1;
		if (len <= 0) {
			debug2("channel %d: read<=0 rfd %d len %d",
			    c->self, c->rfd, len);
			if (c->type != SSH_CHANNEL_OPEN) {
				debug2("channel %d: not open", c->self);
				chan_mark_dead(c);
				return -1;
			} else {
				chan_read_failed(c);
			}
a1762 8
		}
		if (c->input_filter != NULL) {
			if (c->input_filter(c, buf, len) == -1) {
				debug2("channel %d: filter stops", c->self);
				chan_read_failed(c);
			}
		} else if (c->datagram) {
			buffer_put_string(&c->input, buf, len);
d1764 1
a1764 1
			buffer_append(&c->input, buf, len);
d1766 14
a1783 1
/* ARGSUSED */
d1785 2
a1786 1
channel_handle_wfd(Channel *c, fd_set *readset, fd_set *writeset)
d1789 7
a1795 3
	u_char *data = NULL, *buf;
	u_int dlen, olen = 0;
	int len;
d1798 9
a1806 18
	if (c->wfd != -1 &&
	    FD_ISSET(c->wfd, writeset) &&
	    buffer_len(&c->output) > 0) {
		olen = buffer_len(&c->output);
		if (c->output_filter != NULL) {
			if ((buf = c->output_filter(c, &data, &dlen)) == NULL) {
				debug2("channel %d: filter stops", c->self);
				if (c->type != SSH_CHANNEL_OPEN)
					chan_mark_dead(c);
				else
					chan_write_failed(c);
				return -1;
			}
		} else if (c->datagram) {
			buf = data = buffer_get_string(&c->output, &dlen);
		} else {
			buf = data = buffer_ptr(&c->output);
			dlen = buffer_len(&c->output);
d1808 8
d1817 4
a1820 17
		if (c->datagram) {
			/* ignore truncated writes, datagrams might get lost */
			len = write(c->wfd, buf, dlen);
			free(data);
			if (len < 0 && (errno == EINTR || errno == EAGAIN))
				return 1;
			if (len <= 0) {
				if (c->type != SSH_CHANNEL_OPEN)
					chan_mark_dead(c);
				else
					chan_write_failed(c);
				return -1;
			}
			goto out;
		}

		len = write(c->wfd, buf, dlen);
d1823 13
a1835 8
		if (len <= 0) {
			if (c->type != SSH_CHANNEL_OPEN) {
				debug2("channel %d: not open", c->self);
				chan_mark_dead(c);
				return -1;
			} else {
				chan_write_failed(c);
			}
d1837 2
d1840 15
a1854 12
		if (c->isatty && dlen >= 1 && buf[0] != '\r') {
			if (tcgetattr(c->wfd, &tio) == 0 &&
			    !(tio.c_lflag & ECHO) && (tio.c_lflag & ICANON)) {
				/*
				 * Simulate echo to reduce the impact of
				 * traffic analysis. We need to match the
				 * size of a SSH2_MSG_CHANNEL_DATA message
				 * (4 byte channel id + buf)
				 */
				packet_send_ignore(4 + len);
				packet_send();
			}
d1856 4
a1859 1
		buffer_consume(&c->output, len);
d1862 30
a1891 2
	if (olen > 0)
		c->local_consumed += olen - buffer_len(&c->output);
d1896 2
a1897 1
channel_handle_efd(Channel *c, fd_set *readset, fd_set *writeset)
d1900 5
a1904 1
	int len;
d1906 15
a1920 39
/** XXX handle drain efd, too */
	if (c->efd != -1) {
		if (c->extended_usage == CHAN_EXTENDED_WRITE &&
		    FD_ISSET(c->efd, writeset) &&
		    buffer_len(&c->extended) > 0) {
			len = write(c->efd, buffer_ptr(&c->extended),
			    buffer_len(&c->extended));
			debug2("channel %d: written %d to efd %d",
			    c->self, len, c->efd);
			if (len < 0 && (errno == EINTR || errno == EAGAIN))
				return 1;
			if (len <= 0) {
				debug2("channel %d: closing write-efd %d",
				    c->self, c->efd);
				channel_close_fd(&c->efd);
			} else {
				buffer_consume(&c->extended, len);
				c->local_consumed += len;
			}
		} else if (c->efd != -1 &&
		    (c->extended_usage == CHAN_EXTENDED_READ ||
		    c->extended_usage == CHAN_EXTENDED_IGNORE) &&
		    FD_ISSET(c->efd, readset)) {
			len = read(c->efd, buf, sizeof(buf));
			debug2("channel %d: read %d from efd %d",
			    c->self, len, c->efd);
			if (len < 0 && (errno == EINTR || errno == EAGAIN))
				return 1;
			if (len <= 0) {
				debug2("channel %d: closing read-efd %d",
				    c->self, c->efd);
				channel_close_fd(&c->efd);
			} else {
				if (c->extended_usage == CHAN_EXTENDED_IGNORE) {
					debug3("channel %d: discard efd",
					    c->self);
				} else
					buffer_append(&c->extended, buf, len);
			}
a1925 1
/* ARGSUSED */
d1927 2
a1928 1
channel_check_window(Channel *c)
d1930 19
d1955 8
a1962 4
		packet_start(SSH2_MSG_CHANNEL_WINDOW_ADJUST);
		packet_put_int(c->remote_id);
		packet_put_int(c->local_consumed);
		packet_send();
d1973 2
a1974 1
channel_post_open(Channel *c, fd_set *readset, fd_set *writeset)
d1976 4
a1979 4
	channel_handle_rfd(c, readset, writeset);
	channel_handle_wfd(c, readset, writeset);
	channel_handle_efd(c, readset, writeset);
	channel_check_window(c);
d1983 1
a1983 1
read_mux(Channel *c, u_int need)
d1986 1
a1986 1
	int len;
d1988 1
d1990 2
a1991 2
	if (buffer_len(&c->input) < need) {
		rlen = need - buffer_len(&c->input);
d1994 1
a1994 1
			return buffer_len(&c->input);
d1996 1
a1996 1
			debug2("channel %d: ctl read<=0 rfd %d len %d",
d1998 1
a1998 1
			chan_read_failed(c);
d2000 4
a2003 2
		} else
			buffer_append(&c->input, buf, len);
d2005 1
a2005 1
	return buffer_len(&c->input);
d2009 2
a2010 1
channel_post_mux_client(Channel *c, fd_set *readset, fd_set *writeset)
a2012 1
	ssize_t len;
d2014 15
a2028 10
	if (c->rfd != -1 && !c->mux_pause && FD_ISSET(c->rfd, readset) &&
	    (c->istate == CHAN_INPUT_OPEN ||
	    c->istate == CHAN_INPUT_WAIT_DRAIN)) {
		/*
		 * Don't not read past the precise end of packets to
		 * avoid disrupting fd passing.
		 */
		if (read_mux(c, 4) < 4) /* read header */
			return;
		need = get_u32(buffer_ptr(&c->input));
d2030 12
a2041 13
		if (need > CHANNEL_MUX_MAX_PACKET) {
			debug2("channel %d: packet too big %u > %u",
			    c->self, CHANNEL_MUX_MAX_PACKET, need);
			chan_rcvd_oclose(c);
			return;
		}
		if (read_mux(c, need + 4) < need + 4) /* read body */
			return;
		if (c->mux_rcb(c) != 0) {
			debug("channel %d: mux_rcb failed", c->self);
			chan_mark_dead(c);
			return;
		}
d2043 8
d2052 10
a2061 11
	if (c->wfd != -1 && FD_ISSET(c->wfd, writeset) &&
	    buffer_len(&c->output) > 0) {
		len = write(c->wfd, buffer_ptr(&c->output),
		    buffer_len(&c->output));
		if (len < 0 && (errno == EINTR || errno == EAGAIN))
			return;
		if (len <= 0) {
			chan_mark_dead(c);
			return;
		}
		buffer_consume(&c->output, len);
d2063 11
d2077 2
a2078 1
channel_post_mux_listener(Channel *c, fd_set *readset, fd_set *writeset)
d2117 1
a2117 1
	nc = channel_new("multiplex client", SSH_CHANNEL_MUX_CLIENT,
d2121 1
a2121 2
	debug3("%s: new mux channel %d fd %d", __func__,
	    nc->self, nc->sock);
d2123 1
a2123 1
	nc->mux_rcb(nc);
d2129 1
a2129 1
channel_handler_init(void)
d2131 30
a2160 1
	int i;
d2162 2
a2163 28
	for (i = 0; i < SSH_CHANNEL_MAX_TYPE; i++) {
		channel_pre[i] = NULL;
		channel_post[i] = NULL;
	}
	channel_pre[SSH_CHANNEL_OPEN] =			&channel_pre_open;
	channel_pre[SSH_CHANNEL_X11_OPEN] =		&channel_pre_x11_open;
	channel_pre[SSH_CHANNEL_PORT_LISTENER] =	&channel_pre_listener;
	channel_pre[SSH_CHANNEL_RPORT_LISTENER] =	&channel_pre_listener;
	channel_pre[SSH_CHANNEL_UNIX_LISTENER] =	&channel_pre_listener;
	channel_pre[SSH_CHANNEL_RUNIX_LISTENER] =	&channel_pre_listener;
	channel_pre[SSH_CHANNEL_X11_LISTENER] =		&channel_pre_listener;
	channel_pre[SSH_CHANNEL_AUTH_SOCKET] =		&channel_pre_listener;
	channel_pre[SSH_CHANNEL_CONNECTING] =		&channel_pre_connecting;
	channel_pre[SSH_CHANNEL_DYNAMIC] =		&channel_pre_dynamic;
	channel_pre[SSH_CHANNEL_MUX_LISTENER] =		&channel_pre_listener;
	channel_pre[SSH_CHANNEL_MUX_CLIENT] =		&channel_pre_mux_client;

	channel_post[SSH_CHANNEL_OPEN] =		&channel_post_open;
	channel_post[SSH_CHANNEL_PORT_LISTENER] =	&channel_post_port_listener;
	channel_post[SSH_CHANNEL_RPORT_LISTENER] =	&channel_post_port_listener;
	channel_post[SSH_CHANNEL_UNIX_LISTENER] =	&channel_post_port_listener;
	channel_post[SSH_CHANNEL_RUNIX_LISTENER] =	&channel_post_port_listener;
	channel_post[SSH_CHANNEL_X11_LISTENER] =	&channel_post_x11_listener;
	channel_post[SSH_CHANNEL_AUTH_SOCKET] =		&channel_post_auth_listener;
	channel_post[SSH_CHANNEL_CONNECTING] =		&channel_post_connecting;
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open;
	channel_post[SSH_CHANNEL_MUX_LISTENER] =	&channel_post_mux_listener;
	channel_post[SSH_CHANNEL_MUX_CLIENT] =		&channel_post_mux_client;
d2168 1
a2168 1
channel_garbage_collect(Channel *c)
d2173 1
a2173 1
		if (!chan_is_dead(c, c->detach_close))
d2176 1
a2176 1
		c->detach_user(c->self, NULL);
d2182 1
a2182 1
	if (!chan_is_dead(c, 1))
d2185 1
a2185 1
	channel_free(c);
d2188 2
d2191 1
a2191 1
channel_handler(struct ssh *ssh, chan_fn *ftab[],
d2194 2
a2195 1
	static int did_init = 0;
a2199 4
	if (!did_init) {
		channel_handler_init();
		did_init = 1;
	}
d2203 2
a2204 2
	for (i = 0, oalloc = channels_alloc; i < oalloc; i++) {
		c = channels[i];
d2208 1
a2208 1
			if (ftab == channel_pre)
d2218 1
a2218 1
				(*ftab[c->type])(c, readset, writeset);
d2232 1
a2232 1
		channel_garbage_collect(c);
d2249 1
a2249 1
	n = MAXIMUM(*maxfdp, channel_max_fd);
d2268 1
a2268 1
		channel_handler(ssh, channel_pre, *readsetp, *writesetp,
d2279 75
a2353 1
	channel_handler(ssh, channel_post, readset, writeset, NULL);
d2356 34
d2393 1
a2393 1
channel_output_poll(void)
d2395 1
d2397 1
a2397 1
	u_int i, len;
d2399 2
a2400 2
	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
d2412 2
a2413 1
			debug3("channel %d: will not send data after close", c->self);
d2418 3
a2420 55
		if ((c->istate == CHAN_INPUT_OPEN ||
		    c->istate == CHAN_INPUT_WAIT_DRAIN) &&
		    (len = buffer_len(&c->input)) > 0) {
			if (c->datagram) {
				if (len > 0) {
					u_char *data;
					u_int dlen;

					data = buffer_get_string(&c->input,
					    &dlen);
					if (dlen > c->remote_window ||
					    dlen > c->remote_maxpacket) {
						debug("channel %d: datagram "
						    "too big for channel",
						    c->self);
						free(data);
						continue;
					}
					packet_start(SSH2_MSG_CHANNEL_DATA);
					packet_put_int(c->remote_id);
					packet_put_string(data, dlen);
					packet_send();
					c->remote_window -= dlen;
					free(data);
				}
				continue;
			}
			/*
			 * Send some data for the other side over the secure
			 * connection.
			 */
			if (len > c->remote_window)
				len = c->remote_window;
			if (len > c->remote_maxpacket)
				len = c->remote_maxpacket;
			if (len > 0) {
				packet_start(SSH2_MSG_CHANNEL_DATA);
				packet_put_int(c->remote_id);
				packet_put_string(buffer_ptr(&c->input), len);
				packet_send();
				buffer_consume(&c->input, len);
				c->remote_window -= len;
			}
		} else if (c->istate == CHAN_INPUT_WAIT_DRAIN) {
			/*
			 * input-buffer is empty and read-socket shutdown:
			 * tell peer, that we will not send more data: send IEOF.
			 * hack for extended data: delay EOF if EFD still in use.
			 */
			if (CHANNEL_EFD_INPUT_ACTIVE(c))
				debug2("channel %d: ibuf_empty delayed efd %d/(%d)",
				    c->self, c->efd, buffer_len(&c->extended));
			else
				chan_ibuf_empty(c);
		}
d2423 2
a2424 19
		    c->remote_window > 0 &&
		    (len = buffer_len(&c->extended)) > 0 &&
		    c->extended_usage == CHAN_EXTENDED_READ) {
			debug2("channel %d: rwin %u elen %u euse %d",
			    c->self, c->remote_window, buffer_len(&c->extended),
			    c->extended_usage);
			if (len > c->remote_window)
				len = c->remote_window;
			if (len > c->remote_maxpacket)
				len = c->remote_maxpacket;
			packet_start(SSH2_MSG_CHANNEL_EXTENDED_DATA);
			packet_put_int(c->remote_id);
			packet_put_int(SSH2_EXTENDED_DATA_STDERR);
			packet_put_string(buffer_ptr(&c->extended), len);
			packet_send();
			buffer_consume(&c->extended, len);
			c->remote_window -= len;
			debug2("channel %d: sent ext data %d", c->self, len);
		}
d2469 1
a2469 1
channel_proxy_downstream(Channel *downstream)
a2471 1
	struct ssh *ssh = active_state;
d2480 2
a2481 2
	/* sshbuf_dump(&downstream->input, stderr); */
	if ((r = sshbuf_get_string_direct(&downstream->input, &cp, &have))
d2510 1
a2510 1
		c = channel_new("mux proxy", SSH_CHANNEL_MUX_PROXY,
d2518 1
a2518 1
			channel_free(c);
d2537 1
a2537 1
		c = channel_new("mux proxy", SSH_CHANNEL_MUX_PROXY,
d2546 1
a2546 1
			channel_free(c);
d2575 2
a2576 8
		permitted_opens = xreallocarray(permitted_opens,
		    num_permitted_opens + 1, sizeof(*permitted_opens));
		idx = num_permitted_opens++;
		permitted_opens[idx].host_to_connect = xstrdup("<mux>");
		permitted_opens[idx].port_to_connect = -1;
		permitted_opens[idx].listen_host = listen_host;
		permitted_opens[idx].listen_port = (int)listen_port;
		permitted_opens[idx].downstream = downstream;
d2583 1
a2583 1
		if ((c = channel_by_remote_id(remote_id)) != NULL) {
d2585 1
a2585 1
				channel_free(c);
d2672 1
a2672 1
	    (r = sshbuf_put_stringb(&downstream->output, b)) != 0) {
d2690 1
a2690 1
			channel_free(c);
d2701 32
a2732 1
/* ARGSUSED */
a2735 1
	int id;
d2737 3
a2739 2
	u_int data_len, win_len;
	Channel *c;
a2740 5
	/* Get the channel number and verify it. */
	id = packet_get_int();
	c = channel_lookup(id);
	if (c == NULL)
		packet_disconnect("Received data for nonexistent channel %d.", id);
d2750 5
a2754 1
	data = packet_get_string_ptr(&data_len);
d2760 3
a2762 5
	 * Ignore data for protocol > 1.3 if output end is no longer open.
	 * For protocol 2 the sending side is reducing its window as it sends
	 * data, so we must 'fake' consumption of the data in order to ensure
	 * that window updates are sent back.  Otherwise the connection might
	 * deadlock.
d2771 1
a2771 1
		logit("channel %d: rcvd big packet %d, maxpack %d",
d2773 1
d2776 1
a2776 1
		logit("channel %d: rcvd too much data %d, win %d",
d2782 8
a2789 5
	if (c->datagram)
		buffer_put_string(&c->output, data, data_len);
	else
		buffer_append(&c->output, data, data_len);
	packet_check_eom();
a2792 1
/* ARGSUSED */
d2796 5
a2800 8
	int id;
	char *data;
	u_int data_len, tcode;
	Channel *c;

	/* Get the channel number and verify it. */
	id = packet_get_int();
	c = channel_lookup(id);
a2801 2
	if (c == NULL)
		packet_disconnect("Received extended_data for bad channel %d.", id);
d2805 1
a2805 1
		logit("channel %d: ext data for non open", id);
d2810 2
a2811 1
			debug("channel %d: accepting ext data after eof", id);
d2813 7
a2819 2
			packet_disconnect("Received extended_data after EOF "
			    "on channel %d.", id);
a2820 1
	tcode = packet_get_int();
d2827 6
a2832 2
	data = packet_get_string(&data_len);
	packet_check_eom();
d2834 1
a2834 1
		logit("channel %d: rcvd too much extended_data %d, win %d",
a2835 1
		free(data);
d2838 4
a2841 1
	debug2("channel %d: rcvd ext data %d", c->self, data_len);
a2842 2
	buffer_append(&c->extended, data, data_len);
	free(data);
a2845 1
/* ARGSUSED */
d2849 3
a2851 2
	int id;
	Channel *c;
a2852 5
	id = packet_get_int();
	packet_check_eom();
	c = channel_lookup(id);
	if (c == NULL)
		packet_disconnect("Received ieof for nonexistent channel %d.", id);
d2855 1
a2855 1
	chan_rcvd_ieof(c);
d2861 2
a2862 2
		if (buffer_len(&c->input) == 0)
			chan_ibuf_empty(c);
a2866 1
/* ARGSUSED */
d2870 1
a2870 2
	int id = packet_get_int();
	Channel *c = channel_lookup(id);
a2871 2
	if (c == NULL)
		packet_disconnect("Received oclose for nonexistent channel %d.", id);
d2874 2
a2875 2
	packet_check_eom();
	chan_rcvd_oclose(c);
a2878 1
/* ARGSUSED */
d2882 3
a2884 5
	int id, remote_id;
	Channel *c;

	id = packet_get_int();
	c = channel_lookup(id);
a2885 3
	if (c==NULL)
		packet_disconnect("Received open confirmation for "
		    "unknown channel %d.", id);
d2890 15
a2904 4
		    "non-opening channel %d.", id);
	remote_id = packet_get_int();
	/* Record the remote channel number and mark that the channel is now open. */
	c->remote_id = remote_id;
a2905 3

	c->remote_window = packet_get_int();
	c->remote_maxpacket = packet_get_int();
d2907 3
a2909 3
		debug2("callback start");
		c->open_confirm(c->self, 1, c->open_confirm_ctx);
		debug2("callback done");
a2912 1
	packet_check_eom();
a2931 1
/* ARGSUSED */
d2935 4
a2938 6
	int id, reason;
	char *msg = NULL, *lang = NULL;
	Channel *c;

	id = packet_get_int();
	c = channel_lookup(id);
a2939 3
	if (c==NULL)
		packet_disconnect("Received open failure for "
		    "unknown channel %d.", id);
d2944 12
a2955 5
		    "non-opening channel %d.", id);
	reason = packet_get_int();
	if (!(datafellows & SSH_BUG_OPENFAILURE)) {
		msg  = packet_get_string(NULL);
		lang = packet_get_string(NULL);
d2957 2
a2958 1
	logit("channel %d: open failed: %s%s%s", id,
a2960 1
	free(lang);
d2962 3
a2964 3
		debug2("callback start");
		c->open_confirm(c->self, 0, c->open_confirm_ctx);
		debug2("callback done");
a2965 1
	packet_check_eom();
d2967 1
a2967 1
	chan_mark_dead(c);
a2970 1
/* ARGSUSED */
d2974 1
d2976 3
a2978 6
	int id;
	u_int adjust, tmp;

	/* Get the channel number and verify it. */
	id = packet_get_int();
	c = channel_lookup(id);
d2980 1
a2980 1
	if (c == NULL) {
d2983 2
a2984 1
	}
d2987 7
a2993 4
	adjust = packet_get_int();
	packet_check_eom();
	debug2("channel %d: rcvd adjust %u", id, adjust);
	if ((tmp = c->remote_window + adjust) < c->remote_window)
d2995 3
a2997 2
		    id, adjust, c->remote_window);
	c->remote_window = tmp;
a3000 1
/* ARGSUSED */
d3004 1
a3006 1
	int id;
d3011 1
a3011 2
	id = packet_get_int();
	debug2("channel_input_status_confirm: type %d id %d", type, id);
d3013 2
a3014 2
	if ((c = channel_lookup(id)) == NULL) {
		logit("channel_input_status_confirm: %d: unknown", id);
d3016 1
a3016 1
	}	
d3019 1
a3019 1
	packet_check_eom();
d3022 1
a3022 1
	cc->cb(type, c, cc->ctx);
d3032 1
a3032 1
channel_set_af(int af)
d3034 1
a3034 1
	IPv4or6 = af;
d3102 3
a3104 2
channel_setup_fwd_listener_tcpip(int type, struct Forward *fwd,
    int *allocated_listen_port, struct ForwardOptions *fwd_opts)
d3141 1
a3141 1
	hints.ai_family = IPv4or6;
d3175 3
a3177 2
		if (type == SSH_CHANNEL_RPORT_LISTENER && fwd->listen_port == 0 &&
		    allocated_listen_port != NULL && *allocated_listen_port > 0)
d3181 2
a3182 1
		    strport, sizeof(strport), NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
d3201 4
a3204 1
			/* address can be in use ipv6 address is already bound */
d3220 2
a3221 1
		if (type == SSH_CHANNEL_RPORT_LISTENER && fwd->listen_port == 0 &&
d3230 1
a3230 1
		c = channel_new("port listener", type, sock, sock, -1,
d3251 2
a3252 2
channel_setup_fwd_listener_streamlocal(int type, struct Forward *fwd,
    struct ForwardOptions *fwd_opts)
d3314 1
a3314 1
	c = channel_new("unix listener", type, sock, sock, -1,
d3325 2
a3326 1
channel_cancel_rport_listener_tcpip(const char *host, u_short port)
d3331 2
a3332 2
	for (i = 0; i < channels_alloc; i++) {
		Channel *c = channels[i];
d3337 1
a3337 1
			channel_free(c);
d3342 1
a3342 1
	return (found);
d3346 1
a3346 1
channel_cancel_rport_listener_streamlocal(const char *path)
d3351 2
a3352 2
	for (i = 0; i < channels_alloc; i++) {
		Channel *c = channels[i];
d3359 1
a3359 1
			channel_free(c);
d3364 1
a3364 1
	return (found);
d3368 1
a3368 1
channel_cancel_rport_listener(struct Forward *fwd)
d3370 7
a3376 4
	if (fwd->listen_path != NULL)
		return channel_cancel_rport_listener_streamlocal(fwd->listen_path);
	else
		return channel_cancel_rport_listener_tcpip(fwd->listen_host, fwd->listen_port);
d3380 3
a3382 2
channel_cancel_lport_listener_tcpip(const char *lhost, u_short lport,
    int cport, struct ForwardOptions *fwd_opts)
d3388 2
a3389 2
	for (i = 0; i < channels_alloc; i++) {
		Channel *c = channels[i];
d3407 1
a3407 1
			channel_free(c);
d3412 1
a3412 1
	return (found);
d3416 1
a3416 1
channel_cancel_lport_listener_streamlocal(const char *path)
d3426 2
a3427 2
	for (i = 0; i < channels_alloc; i++) {
		Channel *c = channels[i];
d3434 1
a3434 1
			channel_free(c);
d3439 1
a3439 1
	return (found);
d3443 2
a3444 1
channel_cancel_lport_listener(struct Forward *fwd, int cport, struct ForwardOptions *fwd_opts)
d3446 7
a3452 4
	if (fwd->listen_path != NULL)
		return channel_cancel_lport_listener_streamlocal(fwd->listen_path);
	else
		return channel_cancel_lport_listener_tcpip(fwd->listen_host, fwd->listen_port, cport, fwd_opts);
d3457 2
a3458 1
channel_setup_local_fwd_listener(struct Forward *fwd, struct ForwardOptions *fwd_opts)
d3461 1
a3461 1
		return channel_setup_fwd_listener_streamlocal(
d3464 2
a3465 2
		return channel_setup_fwd_listener_tcpip(SSH_CHANNEL_PORT_LISTENER,
		    fwd, NULL, fwd_opts);
d3471 1
a3471 1
channel_setup_remote_fwd_listener(struct Forward *fwd,
d3475 1
a3475 1
		return channel_setup_fwd_listener_streamlocal(
d3478 1
a3478 1
		return channel_setup_fwd_listener_tcpip(
d3512 1
a3512 1
channel_request_remote_forwarding(struct Forward *fwd)
d3514 3
a3516 1
	int success = 0, idx = -1;
a3518 1
	packet_start(SSH2_MSG_GLOBAL_REQUEST);
d3520 9
a3528 3
	    packet_put_cstring("streamlocal-forward@@openssh.com");
	    packet_put_char(1);		/* boolean: want reply */
	    packet_put_cstring(fwd->listen_path);
d3530 10
a3539 4
	    packet_put_cstring("tcpip-forward");
	    packet_put_char(1);		/* boolean: want reply */
	    packet_put_cstring(channel_rfwd_bind_host(fwd->listen_host));
	    packet_put_int(fwd->listen_port);
a3540 2
	packet_send();
	packet_write_wait();
d3545 2
a3546 3
		permitted_opens = xreallocarray(permitted_opens,
		    num_permitted_opens + 1, sizeof(*permitted_opens));
		idx = num_permitted_opens++;
d3548 2
a3549 4
			permitted_opens[idx].host_to_connect =
			    xstrdup(fwd->connect_path);
			permitted_opens[idx].port_to_connect =
			    PORT_STREAMLOCAL;
d3551 2
a3552 4
			permitted_opens[idx].host_to_connect =
			    xstrdup(fwd->connect_host);
			permitted_opens[idx].port_to_connect =
			    fwd->connect_port;
d3555 2
a3556 4
			permitted_opens[idx].listen_host = NULL;
			permitted_opens[idx].listen_path =
			    xstrdup(fwd->listen_path);
			permitted_opens[idx].listen_port = PORT_STREAMLOCAL;
d3558 7
a3564 6
			permitted_opens[idx].listen_host =
			    fwd->listen_host ? xstrdup(fwd->listen_host) : NULL;
			permitted_opens[idx].listen_path = NULL;
			permitted_opens[idx].listen_port = fwd->listen_port;
		}
		permitted_opens[idx].downstream = NULL;
d3566 1
a3566 1
	return (idx);
d3631 2
a3632 1
channel_request_rforward_cancel_tcpip(const char *host, u_short port)
d3634 4
a3637 1
	int i;
d3639 3
a3641 2
	for (i = 0; i < num_permitted_opens; i++) {
		if (open_listen_match_tcpip(&permitted_opens[i], host, port, 0))
d3643 1
d3645 1
a3645 1
	if (i >= num_permitted_opens) {
d3649 9
a3657 15
	packet_start(SSH2_MSG_GLOBAL_REQUEST);
	packet_put_cstring("cancel-tcpip-forward");
	packet_put_char(0);
	packet_put_cstring(channel_rfwd_bind_host(host));
	packet_put_int(port);
	packet_send();

	permitted_opens[i].listen_port = 0;
	permitted_opens[i].port_to_connect = 0;
	free(permitted_opens[i].host_to_connect);
	permitted_opens[i].host_to_connect = NULL;
	free(permitted_opens[i].listen_host);
	permitted_opens[i].listen_host = NULL;
	permitted_opens[i].listen_path = NULL;
	permitted_opens[i].downstream = NULL;
d3667 1
a3667 1
channel_request_rforward_cancel_streamlocal(const char *path)
d3669 4
a3672 1
	int i;
d3674 3
a3676 2
	for (i = 0; i < num_permitted_opens; i++) {
		if (open_listen_match_streamlocal(&permitted_opens[i], path))
d3678 1
d3680 1
a3680 1
	if (i >= num_permitted_opens) {
d3684 9
a3692 14
	packet_start(SSH2_MSG_GLOBAL_REQUEST);
	packet_put_cstring("cancel-streamlocal-forward@@openssh.com");
	packet_put_char(0);
	packet_put_cstring(path);
	packet_send();

	permitted_opens[i].listen_port = 0;
	permitted_opens[i].port_to_connect = 0;
	free(permitted_opens[i].host_to_connect);
	permitted_opens[i].host_to_connect = NULL;
	permitted_opens[i].listen_host = NULL;
	free(permitted_opens[i].listen_path);
	permitted_opens[i].listen_path = NULL;
	permitted_opens[i].downstream = NULL;
d3701 1
a3701 1
channel_request_rforward_cancel(struct Forward *fwd)
d3704 2
a3705 2
		return (channel_request_rforward_cancel_streamlocal(
		    fwd->listen_path));
d3707 3
a3709 2
		return (channel_request_rforward_cancel_tcpip(fwd->listen_host,
		    fwd->listen_port ? fwd->listen_port : fwd->allocated_port));
d3719 1
a3719 1
channel_permit_all_opens(void)
d3721 2
a3722 2
	if (num_permitted_opens == 0)
		all_opens_permitted = 1;
d3726 1
a3726 1
channel_add_permitted_opens(char *host, int port)
d3728 2
d3731 2
a3732 12

	permitted_opens = xreallocarray(permitted_opens,
	    num_permitted_opens + 1, sizeof(*permitted_opens));
	permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host);
	permitted_opens[num_permitted_opens].port_to_connect = port;
	permitted_opens[num_permitted_opens].listen_host = NULL;
	permitted_opens[num_permitted_opens].listen_path = NULL;
	permitted_opens[num_permitted_opens].listen_port = 0;
	permitted_opens[num_permitted_opens].downstream = NULL;
	num_permitted_opens++;

	all_opens_permitted = 0;
d3741 1
a3741 1
channel_update_permitted_opens(int idx, int newport)
d3743 5
a3747 3
	if (idx < 0 || idx >= num_permitted_opens) {
		debug("channel_update_permitted_opens: index out of range:"
		    " %d num_permitted_opens %d", idx, num_permitted_opens);
d3753 6
a3758 4
	    permitted_opens[idx].host_to_connect,
	    permitted_opens[idx].port_to_connect);
	if (newport >= 0)  {
		permitted_opens[idx].listen_port = 
a3759 9
	} else {
		permitted_opens[idx].listen_port = 0;
		permitted_opens[idx].port_to_connect = 0;
		free(permitted_opens[idx].host_to_connect);
		permitted_opens[idx].host_to_connect = NULL;
		free(permitted_opens[idx].listen_host);
		permitted_opens[idx].listen_host = NULL;
		free(permitted_opens[idx].listen_path);
		permitted_opens[idx].listen_path = NULL;
d3764 1
a3764 1
channel_add_adm_permitted_opens(char *host, int port)
d3767 2
a3768 19

	permitted_adm_opens = xreallocarray(permitted_adm_opens,
	    num_adm_permitted_opens + 1, sizeof(*permitted_adm_opens));
	permitted_adm_opens[num_adm_permitted_opens].host_to_connect
	     = xstrdup(host);
	permitted_adm_opens[num_adm_permitted_opens].port_to_connect = port;
	permitted_adm_opens[num_adm_permitted_opens].listen_host = NULL;
	permitted_adm_opens[num_adm_permitted_opens].listen_path = NULL;
	permitted_adm_opens[num_adm_permitted_opens].listen_port = 0;
	return ++num_adm_permitted_opens;
}

void
channel_disable_adm_local_opens(void)
{
	channel_clear_adm_permitted_opens();
	permitted_adm_opens = xcalloc(sizeof(*permitted_adm_opens), 1);
	permitted_adm_opens[num_adm_permitted_opens].host_to_connect = NULL;
	num_adm_permitted_opens = 1;
d3772 1
a3772 1
channel_clear_permitted_opens(void)
d3774 2
a3775 10
	int i;

	for (i = 0; i < num_permitted_opens; i++) {
		free(permitted_opens[i].host_to_connect);
		free(permitted_opens[i].listen_host);
		free(permitted_opens[i].listen_path);
	}
	free(permitted_opens);
	permitted_opens = NULL;
	num_permitted_opens = 0;
d3779 1
a3779 1
channel_clear_adm_permitted_opens(void)
d3781 1
a3781 1
	int i;
d3783 3
a3785 8
	for (i = 0; i < num_adm_permitted_opens; i++) {
		free(permitted_adm_opens[i].host_to_connect);
		free(permitted_adm_opens[i].listen_host);
		free(permitted_adm_opens[i].listen_path);
	}
	free(permitted_adm_opens);
	permitted_adm_opens = NULL;
	num_adm_permitted_opens = 0;
d3789 1
a3789 1
channel_print_adm_permitted_opens(void)
d3791 1
a3791 1
	int i;
d3793 3
a3795 12
	printf("permitopen");
	if (num_adm_permitted_opens == 0) {
		printf(" any\n");
		return;
	}
	for (i = 0; i < num_adm_permitted_opens; i++)
		if (permitted_adm_opens[i].host_to_connect == NULL)
			printf(" none");
		else
			printf(" %s:%d", permitted_adm_opens[i].host_to_connect,
			    permitted_adm_opens[i].port_to_connect);
	printf("\n");
d3817 2
a3818 1
	char ntop[NI_MAXHOST], strport[MAXIMUM(NI_MAXSERV,sizeof(sunaddr->sun_path))];
d3888 2
a3889 2
connect_to_reason(const char *name, int port, char *ctype, char *rname,
     int *reason, const char **errmsg)
d3927 1
a3927 1
		hints.ai_family = IPv4or6;
d3952 1
a3952 1
	c = channel_new(ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,
d3960 2
a3961 1
connect_to(const char *name, int port, char *ctype, char *rname)
d3963 1
a3963 1
	return connect_to_reason(name, port, ctype, rname, NULL, NULL);
d3971 1
a3971 1
channel_connect_by_listen_address(const char *listen_host,
d3974 3
a3976 1
	int i;
d3978 8
a3985 8
	for (i = 0; i < num_permitted_opens; i++) {
		if (open_listen_match_tcpip(&permitted_opens[i], listen_host,
		    listen_port, 1)) {
			if (permitted_opens[i].downstream)
				return permitted_opens[i].downstream;
			return connect_to(
			    permitted_opens[i].host_to_connect,
			    permitted_opens[i].port_to_connect, ctype, rname);
d3994 2
a3995 1
channel_connect_by_listen_path(const char *path, char *ctype, char *rname)
d3997 3
a3999 1
	int i;
d4001 6
a4006 5
	for (i = 0; i < num_permitted_opens; i++) {
		if (open_listen_match_streamlocal(&permitted_opens[i], path)) {
			return connect_to(
			    permitted_opens[i].host_to_connect,
			    permitted_opens[i].port_to_connect, ctype, rname);
d4016 2
a4017 2
channel_connect_to_port(const char *host, u_short port, char *ctype,
    char *rname, int *reason, const char **errmsg)
d4019 3
a4021 1
	int i, permit, permit_adm = 1;
d4023 1
a4023 1
	permit = all_opens_permitted;
d4025 3
a4027 2
		for (i = 0; i < num_permitted_opens; i++)
			if (open_match(&permitted_opens[i], host, port)) {
d4031 1
d4034 1
a4034 1
	if (num_adm_permitted_opens > 0) {
d4036 3
a4038 2
		for (i = 0; i < num_adm_permitted_opens; i++)
			if (open_match(&permitted_adm_opens[i], host, port)) {
d4042 1
d4052 1
a4052 1
	return connect_to_reason(host, port, ctype, rname, reason, errmsg);
d4057 2
a4058 1
channel_connect_to_path(const char *path, char *ctype, char *rname)
d4060 3
a4062 1
	int i, permit, permit_adm = 1;
d4064 1
a4064 1
	permit = all_opens_permitted;
d4066 3
a4068 2
		for (i = 0; i < num_permitted_opens; i++)
			if (open_match(&permitted_opens[i], path, PORT_STREAMLOCAL)) {
d4072 1
d4075 1
a4075 1
	if (num_adm_permitted_opens > 0) {
d4077 3
a4079 2
		for (i = 0; i < num_adm_permitted_opens; i++)
			if (open_match(&permitted_adm_opens[i], path, PORT_STREAMLOCAL)) {
d4083 1
d4091 1
a4091 1
	return connect_to(path, PORT_STREAMLOCAL, ctype, rname);
d4095 1
a4095 1
channel_send_window_changes(void)
d4097 3
a4100 1
	struct winsize ws;
d4102 3
a4104 3
	for (i = 0; i < channels_alloc; i++) {
		if (channels[i] == NULL || !channels[i]->client_tty ||
		    channels[i]->type != SSH_CHANNEL_OPEN)
d4106 1
a4106 1
		if (ioctl(channels[i]->rfd, TIOCGWINSZ, &ws) < 0)
d4108 8
a4115 6
		channel_request_start(i, "window-change", 0);
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
		packet_send();
d4127 3
a4129 2
x11_create_display_inet(int x11_display_offset, int x11_use_localhost,
    int single_connection, u_int *display_numberp, int **chanids)
d4146 1
a4146 1
		hints.ai_family = IPv4or6;
d4150 2
a4151 1
		if ((gaierr = getaddrinfo(NULL, strport, &hints, &aitop)) != 0) {
d4156 2
a4157 1
			if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)
d4168 2
a4169 1
				debug2("bind port %d: %.100s", port, strerror(errno));
d4171 1
a4171 2

				for (n = 0; n < num_socks; n++) {
a4172 1
				}
d4202 1
a4202 1
		nc = channel_new("x11 listener",
d4213 1
a4213 1
	return (0);
d4236 1
a4236 1
x11_connect_display(void)
d4263 4
a4266 3
		if (sscanf(strrchr(display, ':') + 1, "%u", &display_number) != 1) {
			error("Could not parse display number from DISPLAY: %.100s",
			    display);
d4288 4
a4291 1
	/* buf now contains the host name.  But first we parse the display number. */
d4300 1
a4300 1
	hints.ai_family = IPv4or6;
d4327 2
a4328 2
		error("connect %.100s port %u: %.100s", buf, 6000 + display_number,
		    strerror(errno));
d4341 2
a4342 2
x11_request_forwarding_with_spoofing(int client_session_id, const char *disp,
    const char *proto, const char *data, int want_reply)
d4344 1
d4347 1
d4349 1
a4349 2
	int screen_number;
	const char *cp;
d4351 3
a4353 3
	if (x11_saved_display == NULL)
		x11_saved_display = xstrdup(disp);
	else if (strcmp(disp, x11_saved_display) != 0) {
d4367 1
a4367 1
	if (x11_saved_proto == NULL) {
d4369 1
a4369 1
		x11_saved_proto = xstrdup(proto);
d4372 1
a4372 1
		x11_saved_data = xmalloc(data_len);
d4377 1
a4377 1
			x11_saved_data[i] = value;
d4379 1
a4379 1
		x11_saved_data_len = data_len;
d4382 3
a4384 3
		x11_fake_data = xmalloc(data_len);
		arc4random_buf(x11_fake_data, data_len);
		x11_fake_data_len = data_len;
d4388 1
a4388 1
	new_data = tohex(x11_fake_data, data_len);
d4391 8
a4398 7
	channel_request_start(client_session_id, "x11-req", want_reply);
	packet_put_char(0);	/* XXX bool single connection */
	packet_put_cstring(proto);
	packet_put_cstring(new_data);
	packet_put_int(screen_number);
	packet_send();
	packet_write_wait();
@


1.365
log
@These shutdown() SHUT_RDWR are not needed before close()
ok djm markus claudio
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.364 2017/05/31 00:43:04 djm Exp $ */
d1972 2
a1973 2
channel_handler(chan_fn *ftab[], fd_set *readset, fd_set *writeset,
    time_t *unpause_secs)
d2028 2
a2029 2
channel_prepare_select(fd_set **readsetp, fd_set **writesetp, int *maxfdp,
    u_int *nallocp, time_t *minwait_secs, int rekeying)
d2051 2
a2052 2
	if (!rekeying)
		channel_handler(channel_pre, *readsetp, *writesetp,
d2061 1
a2061 1
channel_after_select(fd_set *readset, fd_set *writeset)
d2063 1
a2063 1
	channel_handler(channel_post, readset, writeset, NULL);
@


1.364
log
@fix possible OOB strlen() in SOCKS4A hostname parsing; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.363 2017/05/30 14:23:52 markus Exp $ */
a471 2
	if (c->sock != -1)
		shutdown(c->sock, SHUT_RDWR);
@


1.363
log
@protocol handlers all get struct ssh passed; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.362 2017/05/30 08:49:58 markus Exp $ */
d1068 2
a1069 2
	if (memchr(p, '\0', have) == NULL)
		fatal("channel %d: decode socks4: user not nul terminated",
d1071 2
d1090 5
a1098 3
		if (len > have)
			fatal("channel %d: decode socks4a: len %d > have %d",
			    c->self, len, have);
@


1.362
log
@remove ssh1 references; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.361 2017/05/26 19:35:50 markus Exp $ */
d2370 1
a2370 1
channel_proxy_upstream(Channel *c, int type, u_int32_t seq, void *ctxt)
a2371 1
	struct ssh *ssh = active_state;
d2451 1
a2451 1
channel_input_data(int type, u_int32_t seq, void *ctxt)
d2463 1
a2463 1
	if (channel_proxy_upstream(c, type, seq, ctxt))
d2511 1
a2511 1
channel_input_extended_data(int type, u_int32_t seq, void *ctxt)
d2524 1
a2524 1
	if (channel_proxy_upstream(c, type, seq, ctxt))
d2561 1
a2561 1
channel_input_ieof(int type, u_int32_t seq, void *ctxt)
d2571 1
a2571 1
	if (channel_proxy_upstream(c, type, seq, ctxt))
d2587 1
a2587 1
channel_input_oclose(int type, u_int32_t seq, void *ctxt)
d2594 1
a2594 1
	if (channel_proxy_upstream(c, type, seq, ctxt))
d2603 1
a2603 1
channel_input_open_confirmation(int type, u_int32_t seq, void *ctxt)
d2614 1
a2614 1
	if (channel_proxy_upstream(c, type, seq, ctxt))
d2655 1
a2655 1
channel_input_open_failure(int type, u_int32_t seq, void *ctxt)
d2667 1
a2667 1
	if (channel_proxy_upstream(c, type, seq, ctxt))
d2694 1
a2694 1
channel_input_window_adjust(int type, u_int32_t seq, void *ctxt)
d2708 1
a2708 1
	if (channel_proxy_upstream(c, type, seq, ctxt))
d2722 1
a2722 1
channel_input_status_confirm(int type, u_int32_t seq, void *ctxt)
d2738 1
a2738 1
	if (channel_proxy_upstream(c, type, seq, ctxt))
@


1.361
log
@remove SSH_CHANNEL_XXX_DRAINING (ssh1 only); ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.360 2017/05/26 19:34:12 markus Exp $ */
d3161 1
a3161 1
/* protocol local port fwd, used by ssh (and sshd in v1) */
@


1.360
log
@remove channel_input_close_confirmation (ssh1 only); ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.359 2017/04/30 23:28:41 djm Exp $ */
a238 2
	case SSH_CHANNEL_INPUT_DRAINING:
	case SSH_CHANNEL_OUTPUT_DRAINING:
a604 3
		case SSH_CHANNEL_INPUT_DRAINING:
		case SSH_CHANNEL_OUTPUT_DRAINING:
			fatal("cannot happen: OUT_DRAIN");
a644 3
		case SSH_CHANNEL_INPUT_DRAINING:
		case SSH_CHANNEL_OUTPUT_DRAINING:
			fatal("cannot happen: OUT_DRAIN");
a690 2
		case SSH_CHANNEL_INPUT_DRAINING:
		case SSH_CHANNEL_OUTPUT_DRAINING:
@


1.359
log
@obliterate ssh1.h and some dead code that used it

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.358 2017/04/30 23:13:25 djm Exp $ */
a2595 1
/* proto version 1.5 overloads CLOSE_CONFIRMATION with OCLOSE */
a2608 20
	return 0;
}

/* ARGSUSED */
int
channel_input_close_confirmation(int type, u_int32_t seq, void *ctxt)
{
	int id = packet_get_int();
	Channel *c = channel_lookup(id);

	if (c == NULL)
		packet_disconnect("Received close confirmation for "
		    "out-of-range channel %d.", id);
	if (channel_proxy_upstream(c, type, seq, ctxt))
		return 0;
	packet_check_eom();
	if (c->type != SSH_CHANNEL_CLOSED && c->type != SSH_CHANNEL_ABANDONED)
		packet_disconnect("Received close confirmation for "
		    "non-closed channel %d (type %d).", id, c->type);
	channel_free(c);
@


1.358
log
@remove compat20/compat13/compat15 variables

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.357 2017/02/01 02:59:09 dtucker Exp $ */
a65 1
#include "ssh1.h"
a2595 40
/* ARGSUSED */
int
channel_input_close(int type, u_int32_t seq, void *ctxt)
{
	int id;
	Channel *c;

	id = packet_get_int();
	packet_check_eom();
	c = channel_lookup(id);
	if (c == NULL)
		packet_disconnect("Received close for nonexistent channel %d.", id);
	if (channel_proxy_upstream(c, type, seq, ctxt))
		return 0;
	/*
	 * Send a confirmation that we have closed the channel and no more
	 * data is coming for it.
	 */
	packet_start(SSH_MSG_CHANNEL_CLOSE_CONFIRMATION);
	packet_put_int(c->remote_id);
	packet_send();

	/*
	 * If the channel is in closed state, we have sent a close request,
	 * and the other side will eventually respond with a confirmation.
	 * Thus, we cannot free the channel here, because then there would be
	 * no-one to receive the confirmation.  The channel gets freed when
	 * the confirmation arrives.
	 */
	if (c->type != SSH_CHANNEL_CLOSED) {
		/*
		 * Not a closed channel - mark it as draining, which will
		 * cause it to be freed later.
		 */
		buffer_clear(&c->input);
		c->type = SSH_CHANNEL_OUTPUT_DRAINING;
	}
	return 0;
}

a2753 32
channel_input_port_open(int type, u_int32_t seq, void *ctxt)
{
	Channel *c = NULL;
	u_short host_port;
	char *host, *originator_string;
	int remote_id;

	remote_id = packet_get_int();
	host = packet_get_string(NULL);
	host_port = packet_get_int();

	if (packet_get_protocol_flags() & SSH_PROTOFLAG_HOST_IN_FWD_OPEN) {
		originator_string = packet_get_string(NULL);
	} else {
		originator_string = xstrdup("unknown (remote did not supply name)");
	}
	packet_check_eom();
	c = channel_connect_to_port(host, host_port,
	    "connected socket", originator_string, NULL, NULL);
	free(originator_string);
	free(host);
	if (c == NULL) {
		packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(remote_id);
		packet_send();
	} else
		c->remote_id = remote_id;
	return 0;
}

/* ARGSUSED */
int
a4086 75
 * This is called when SSH_SMSG_X11_OPEN is received.  The packet contains
 * the remote channel number.  We should do whatever we want, and respond
 * with either SSH_MSG_OPEN_CONFIRMATION or SSH_MSG_OPEN_FAILURE.
 */

/* ARGSUSED */
int
x11_input_open(int type, u_int32_t seq, void *ctxt)
{
	Channel *c = NULL;
	int remote_id, sock = 0;
	char *remote_host;

	debug("Received X11 open request.");

	remote_id = packet_get_int();

	if (packet_get_protocol_flags() & SSH_PROTOFLAG_HOST_IN_FWD_OPEN) {
		remote_host = packet_get_string(NULL);
	} else {
		remote_host = xstrdup("unknown (remote did not supply name)");
	}
	packet_check_eom();

	/* Obtain a connection to the real X display. */
	sock = x11_connect_display();
	if (sock != -1) {
		/* Allocate a channel for this connection. */
		c = channel_new("connected x11 socket",
		    SSH_CHANNEL_X11_OPEN, sock, sock, -1, 0, 0, 0,
		    remote_host, 1);
		c->remote_id = remote_id;
		c->force_drain = 1;
	}
	free(remote_host);
	if (c == NULL) {
		/* Send refusal to the remote host. */
		packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(remote_id);
	} else {
		/* Send a confirmation to the remote host. */
		packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
		packet_put_int(remote_id);
		packet_put_int(c->self);
	}
	packet_send();
	return 0;
}

/* dummy protocol handler that denies SSH-1 requests (agent/x11) */
/* ARGSUSED */
int
deny_input_open(int type, u_int32_t seq, void *ctxt)
{
	int rchan = packet_get_int();

	switch (type) {
	case SSH_SMSG_AGENT_OPEN:
		error("Warning: ssh server tried agent forwarding.");
		break;
	case SSH_SMSG_X11_OPEN:
		error("Warning: ssh server tried X11 forwarding.");
		break;
	default:
		error("deny_input_open: type %d", type);
		break;
	}
	error("Warning: this is probably a break-in attempt by a malicious server.");
	packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
	packet_put_int(rchan);
	packet_send();
	return 0;
}

/*
a4148 13
}


/* -- agent forwarding */

/* Sends a message to the server to request authentication fd forwarding. */

void
auth_request_forwarding(void)
{
	packet_start(SSH_CMSG_AGENT_REQUEST_FORWARDING);
	packet_send();
	packet_write_wait();
@


1.357
log
@Return true reason for port forwarding failures where feasible rather
than always "administratively prohibited".  bz#2674, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.356 2016/10/18 17:32:54 dtucker Exp $ */
a563 8
#if 0
			if (!compat20 &&
			    buffer_len(&c->input) > packet_get_maxsize()) {
				debug2("channel %d: big input buffer %d",
				    c->self, buffer_len(&c->input));
				return 0;
			}
#endif
a600 2
			if (!compat20)
				fatal("cannot happen: SSH_CHANNEL_LARVAL");
d610 1
a610 3
			if (!compat13)
				fatal("cannot happen: OUT_DRAIN");
			return 1;
d612 1
a612 1
			fatal("channel_still_open: bad channel type %d", c->type);
d653 1
a653 3
			if (!compat13)
				fatal("cannot happen: OUT_DRAIN");
			return i;
d655 1
a655 1
			fatal("channel_find_open: bad channel type %d", c->type);
a874 9
channel_pre_open_13(Channel *c, fd_set *readset, fd_set *writeset)
{
	if (buffer_len(&c->input) < packet_get_maxsize())
		FD_SET(c->sock, readset);
	if (buffer_len(&c->output) > 0)
		FD_SET(c->sock, writeset);
}

static void
a876 2
	u_int limit = compat20 ? c->remote_window : packet_get_maxsize();

d878 2
a879 2
	    limit > 0 &&
	    buffer_len(&c->input) < limit &&
d895 2
a896 2
	if (compat20 && c->efd != -1 && 
	    !(c->istate == CHAN_INPUT_CLOSED && c->ostate == CHAN_OUTPUT_CLOSED)) {
a908 23
/* ARGSUSED */
static void
channel_pre_input_draining(Channel *c, fd_set *readset, fd_set *writeset)
{
	if (buffer_len(&c->input) == 0) {
		packet_start(SSH_MSG_CHANNEL_CLOSE);
		packet_put_int(c->remote_id);
		packet_send();
		c->type = SSH_CHANNEL_CLOSED;
		debug2("channel %d: closing after input drain.", c->self);
	}
}

/* ARGSUSED */
static void
channel_pre_output_draining(Channel *c, fd_set *readset, fd_set *writeset)
{
	if (buffer_len(&c->output) == 0)
		chan_mark_dead(c);
	else
		FD_SET(c->sock, writeset);
}

a983 26
channel_pre_x11_open_13(Channel *c, fd_set *readset, fd_set *writeset)
{
	int ret = x11_open_helper(&c->output);

	if (ret == 1) {
		/* Start normal processing for the channel. */
		c->type = SSH_CHANNEL_OPEN;
		channel_pre_open_13(c, readset, writeset);
	} else if (ret == -1) {
		/*
		 * We have received an X11 connection that has bad
		 * authentication information.
		 */
		logit("X11 connection rejected because of wrong authentication.");
		buffer_clear(&c->input);
		buffer_clear(&c->output);
		channel_close_fd(&c->sock);
		c->sock = -1;
		c->type = SSH_CHANNEL_CLOSED;
		packet_start(SSH_MSG_CHANNEL_CLOSE);
		packet_put_int(c->remote_id);
		packet_send();
	}
}

static void
d1000 1
a1000 5
		/* for proto v1, the peer will send an IEOF */
		if (compat20)
			chan_write_failed(c);
		else
			c->type = SSH_CHANNEL_OPEN;
d1364 9
a1372 14
		if (compat20) {
			packet_start(SSH2_MSG_CHANNEL_OPEN);
			packet_put_cstring("x11");
			packet_put_int(nc->self);
			packet_put_int(nc->local_window_max);
			packet_put_int(nc->local_maxpacket);
			/* originator ipaddr and port */
			packet_put_cstring(remote_ipaddr);
			if (datafellows & SSH_BUG_X11FWD) {
				debug2("ssh2 x11 bug compat mode");
			} else {
				packet_put_int(remote_port);
			}
			packet_send();
d1374 1
a1374 6
			packet_start(SSH_SMSG_X11_OPEN);
			packet_put_int(nc->self);
			if (packet_get_protocol_flags() &
			    SSH_PROTOFLAG_HOST_IN_FWD_OPEN)
				packet_put_cstring(buf);
			packet_send();
d1376 1
d1406 15
a1420 30
	if (compat20) {
		packet_start(SSH2_MSG_CHANNEL_OPEN);
		packet_put_cstring(rtype);
		packet_put_int(c->self);
		packet_put_int(c->local_window_max);
		packet_put_int(c->local_maxpacket);
		if (strcmp(rtype, "direct-tcpip") == 0) {
			/* target host, port */
			packet_put_cstring(c->path);
			packet_put_int(c->host_port);
		} else if (strcmp(rtype, "direct-streamlocal@@openssh.com") == 0) {
			/* target path */
			packet_put_cstring(c->path);
		} else if (strcmp(rtype, "forwarded-streamlocal@@openssh.com") == 0) {
			/* listen path */
			packet_put_cstring(c->path);
		} else {
			/* listen address, port */
			packet_put_cstring(c->path);
			packet_put_int(local_port);
		}
		if (strcmp(rtype, "forwarded-streamlocal@@openssh.com") == 0) {
			/* reserved for future owner/mode info */
			packet_put_cstring("");
		} else {
			/* originator host and port */
			packet_put_cstring(remote_ipaddr);
			packet_put_int((u_int)remote_port);
		}
		packet_send();
d1422 1
a1422 2
		packet_start(SSH_MSG_PORT_OPEN);
		packet_put_int(c->self);
d1424 9
a1432 5
		packet_put_int(c->host_port);
		if (packet_get_protocol_flags() &
		    SSH_PROTOFLAG_HOST_IN_FWD_OPEN)
			packet_put_cstring(c->remote_name);
		packet_send();
d1434 1
d1544 5
a1548 10
		if (compat20) {
			packet_start(SSH2_MSG_CHANNEL_OPEN);
			packet_put_cstring("auth-agent@@openssh.com");
			packet_put_int(nc->self);
			packet_put_int(c->local_window_max);
			packet_put_int(c->local_maxpacket);
		} else {
			packet_start(SSH_SMSG_AGENT_OPEN);
			packet_put_int(nc->self);
		}
d1570 5
a1574 11
			if (compat20) {
				packet_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);
				packet_put_int(c->remote_id);
				packet_put_int(c->self);
				packet_put_int(c->local_window);
				packet_put_int(c->local_maxpacket);
			} else {
				packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
				packet_put_int(c->remote_id);
				packet_put_int(c->self);
			}
d1589 6
a1594 11
			if (compat20) {
				packet_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);
				packet_put_int(c->remote_id);
				packet_put_int(SSH2_OPEN_CONNECT_FAILED);
				if (!(datafellows & SSH_BUG_OPENFAILURE)) {
					packet_put_cstring(strerror(err));
					packet_put_cstring("");
				}
			} else {
				packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
				packet_put_int(c->remote_id);
a1620 4
			} else if (compat13) {
				buffer_clear(&c->output);
				c->type = SSH_CHANNEL_INPUT_DRAINING;
				debug2("channel %d: input draining.", c->self);
a1693 4
			} else if (compat13) {
				buffer_clear(&c->output);
				debug2("channel %d: input draining.", c->self);
				c->type = SSH_CHANNEL_INPUT_DRAINING;
d1699 1
a1699 1
		if (compat20 && c->isatty && dlen >= 1 && buf[0] != '\r') {
d1715 1
a1715 1
	if (compat20 && olen > 0)
a1797 2
	if (!compat20)
		return;
a1830 3
	if (!compat20)
		fatal("%s: entered with !compat20", __func__);

a1922 1
/* ARGSUSED */
d1924 1
a1924 1
channel_post_output_drain_13(Channel *c, fd_set *readset, fd_set *writeset)
d1926 1
a1926 1
	int len;
d1928 3
a1930 8
	/* Send buffered output data to the socket. */
	if (FD_ISSET(c->sock, writeset) && buffer_len(&c->output) > 0) {
		len = write(c->sock, buffer_ptr(&c->output),
			    buffer_len(&c->output));
		if (len <= 0)
			buffer_clear(&c->output);
		else
			buffer_consume(&c->output, len);
a1931 5
}

static void
channel_handler_init_20(void)
{
a1957 58
static void
channel_handler_init_13(void)
{
	channel_pre[SSH_CHANNEL_OPEN] =			&channel_pre_open_13;
	channel_pre[SSH_CHANNEL_X11_OPEN] =		&channel_pre_x11_open_13;
	channel_pre[SSH_CHANNEL_X11_LISTENER] =		&channel_pre_listener;
	channel_pre[SSH_CHANNEL_PORT_LISTENER] =	&channel_pre_listener;
	channel_pre[SSH_CHANNEL_AUTH_SOCKET] =		&channel_pre_listener;
	channel_pre[SSH_CHANNEL_INPUT_DRAINING] =	&channel_pre_input_draining;
	channel_pre[SSH_CHANNEL_OUTPUT_DRAINING] =	&channel_pre_output_draining;
	channel_pre[SSH_CHANNEL_CONNECTING] =		&channel_pre_connecting;
	channel_pre[SSH_CHANNEL_DYNAMIC] =		&channel_pre_dynamic;

	channel_post[SSH_CHANNEL_OPEN] =		&channel_post_open;
	channel_post[SSH_CHANNEL_X11_LISTENER] =	&channel_post_x11_listener;
	channel_post[SSH_CHANNEL_PORT_LISTENER] =	&channel_post_port_listener;
	channel_post[SSH_CHANNEL_AUTH_SOCKET] =		&channel_post_auth_listener;
	channel_post[SSH_CHANNEL_OUTPUT_DRAINING] =	&channel_post_output_drain_13;
	channel_post[SSH_CHANNEL_CONNECTING] =		&channel_post_connecting;
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open;
}

static void
channel_handler_init_15(void)
{
	channel_pre[SSH_CHANNEL_OPEN] =			&channel_pre_open;
	channel_pre[SSH_CHANNEL_X11_OPEN] =		&channel_pre_x11_open;
	channel_pre[SSH_CHANNEL_X11_LISTENER] =		&channel_pre_listener;
	channel_pre[SSH_CHANNEL_PORT_LISTENER] =	&channel_pre_listener;
	channel_pre[SSH_CHANNEL_AUTH_SOCKET] =		&channel_pre_listener;
	channel_pre[SSH_CHANNEL_CONNECTING] =		&channel_pre_connecting;
	channel_pre[SSH_CHANNEL_DYNAMIC] =		&channel_pre_dynamic;

	channel_post[SSH_CHANNEL_X11_LISTENER] =	&channel_post_x11_listener;
	channel_post[SSH_CHANNEL_PORT_LISTENER] =	&channel_post_port_listener;
	channel_post[SSH_CHANNEL_AUTH_SOCKET] =		&channel_post_auth_listener;
	channel_post[SSH_CHANNEL_OPEN] =		&channel_post_open;
	channel_post[SSH_CHANNEL_CONNECTING] =		&channel_post_connecting;
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open;
}

static void
channel_handler_init(void)
{
	int i;

	for (i = 0; i < SSH_CHANNEL_MAX_TYPE; i++) {
		channel_pre[i] = NULL;
		channel_post[i] = NULL;
	}
	if (compat20)
		channel_handler_init_20();
	else if (compat13)
		channel_handler_init_13();
	else
		channel_handler_init_15();
}

d2092 3
a2094 10
		if (compat13) {
			if (c->type != SSH_CHANNEL_OPEN &&
			    c->type != SSH_CHANNEL_INPUT_DRAINING)
				continue;
		} else {
			if (c->type != SSH_CHANNEL_OPEN)
				continue;
		}
		if (compat20 &&
		    (c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD))) {
d2132 4
a2135 15
			if (compat20) {
				if (len > c->remote_window)
					len = c->remote_window;
				if (len > c->remote_maxpacket)
					len = c->remote_maxpacket;
			} else {
				if (packet_is_interactive()) {
					if (len > 1024)
						len = 512;
				} else {
					/* Keep the packets at reasonable size. */
					if (len > packet_get_maxsize()/2)
						len = packet_get_maxsize()/2;
				}
			}
d2137 1
a2137 2
				packet_start(compat20 ?
				    SSH2_MSG_CHANNEL_DATA : SSH_MSG_CHANNEL_DATA);
a2144 2
			if (compat13)
				fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
d2157 1
a2157 2
		if (compat20 &&
		    !(c->flags & CHAN_EOF_SENT) &&
d2496 3
a2498 5
	if (!compat13 && c->ostate != CHAN_OUTPUT_OPEN) {
		if (compat20) {
			c->local_window -= win_len;
			c->local_consumed += win_len;
		}
d2502 8
a2509 11
	if (compat20) {
		if (win_len > c->local_maxpacket) {
			logit("channel %d: rcvd big packet %d, maxpack %d",
			    c->self, win_len, c->local_maxpacket);
		}
		if (win_len > c->local_window) {
			logit("channel %d: rcvd too much data %d, win %d",
			    c->self, win_len, c->local_window);
			return 0;
		}
		c->local_window -= win_len;
d2511 2
d2697 6
a2702 10
	if (compat20) {
		c->remote_window = packet_get_int();
		c->remote_maxpacket = packet_get_int();
		if (c->open_confirm) {
			debug2("callback start");
			c->open_confirm(c->self, 1, c->open_confirm_ctx);
			debug2("callback done");
		}
		debug2("channel %d: open confirm rwindow %u rmax %u", c->self,
		    c->remote_window, c->remote_maxpacket);
d2704 2
d2745 13
a2757 15
	if (compat20) {
		reason = packet_get_int();
		if (!(datafellows & SSH_BUG_OPENFAILURE)) {
			msg  = packet_get_string(NULL);
			lang = packet_get_string(NULL);
		}
		logit("channel %d: open failed: %s%s%s", id,
		    reason2txt(reason), msg ? ": ": "", msg ? msg : "");
		free(msg);
		free(lang);
		if (c->open_confirm) {
			debug2("callback start");
			c->open_confirm(c->self, 0, c->open_confirm_ctx);
			debug2("callback done");
		}
a2772 3
	if (!compat20)
		return 0;

d3323 1
a3323 1
	int type, success = 0, idx = -1;
d3326 5
a3330 37
	if (compat20) {
		packet_start(SSH2_MSG_GLOBAL_REQUEST);
		if (fwd->listen_path != NULL) {
		    packet_put_cstring("streamlocal-forward@@openssh.com");
		    packet_put_char(1);		/* boolean: want reply */
		    packet_put_cstring(fwd->listen_path);
		} else {
		    packet_put_cstring("tcpip-forward");
		    packet_put_char(1);		/* boolean: want reply */
		    packet_put_cstring(channel_rfwd_bind_host(fwd->listen_host));
		    packet_put_int(fwd->listen_port);
		}
		packet_send();
		packet_write_wait();
		/* Assume that server accepts the request */
		success = 1;
	} else if (fwd->listen_path == NULL) {
		packet_start(SSH_CMSG_PORT_FORWARD_REQUEST);
		packet_put_int(fwd->listen_port);
		packet_put_cstring(fwd->connect_host);
		packet_put_int(fwd->connect_port);
		packet_send();
		packet_write_wait();

		/* Wait for response from the remote side. */
		type = packet_read();
		switch (type) {
		case SSH_SMSG_SUCCESS:
			success = 1;
			break;
		case SSH_SMSG_FAILURE:
			break;
		default:
			/* Unknown packet */
			packet_disconnect("Protocol error for port forward request:"
			    "received packet type %d.", type);
		}
d3332 4
a3335 1
		logit("Warning: Server does not support remote stream local forwarding.");
d3337 4
a3438 3
	if (!compat20)
		return -1;

a3474 3
	if (!compat20)
		return -1;

d4289 2
a4290 6
	if (compat20) {
		channel_request_start(client_session_id, "x11-req", want_reply);
		packet_put_char(0);	/* XXX bool single connection */
	} else {
		packet_start(SSH_CMSG_X11_REQUEST_FORWARDING);
	}
@


1.356
log
@Remove channel_input_port_forward_request(); the only caller was the
recently-removed SSH1 server code so it's now dead code.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.355 2016/09/30 20:24:46 djm Exp $ */
d3041 1
a3041 1
	    "connected socket", originator_string);
d3996 4
a3999 1
/* Return CONNECTING channel to remote host:port or local socket path */
d4001 2
a4002 1
connect_to(const char *name, int port, char *ctype, char *rname)
d4043 6
a4048 1
		if ((gaierr = getaddrinfo(name, strport, &hints, &cctx.aitop)) != 0) {
d4071 7
d4122 2
a4123 1
channel_connect_to_port(const char *host, u_short port, char *ctype, char *rname)
d4148 2
d4152 1
a4152 1
	return connect_to(host, port, ctype, rname);
@


1.355
log
@fix some -Wpointer-sign warnings in the new mux proxy; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.354 2016/09/30 09:19:13 markus Exp $ */
a3772 37
}

/*
 * This is called after receiving CHANNEL_FORWARDING_REQUEST.  This initates
 * listening for the port, and sends back a success reply (or disconnect
 * message if there was an error).
 */
int
channel_input_port_forward_request(int is_root, struct ForwardOptions *fwd_opts)
{
	int success = 0;
	struct Forward fwd;

	/* Get arguments from the packet. */
	memset(&fwd, 0, sizeof(fwd));
	fwd.listen_port = packet_get_int();
	fwd.connect_host = packet_get_string(NULL);
	fwd.connect_port = packet_get_int();

	/*
	 * Check that an unprivileged user is not trying to forward a
	 * privileged port.
	 */
	if (fwd.listen_port < IPPORT_RESERVED && !is_root)
		packet_disconnect(
		    "Requested forwarding of port %d but user is not root.",
		    fwd.listen_port);
	if (fwd.connect_port == 0)
		packet_disconnect("Dynamic forwarding denied.");

	/* Initiate forwarding */
	success = channel_setup_local_fwd_listener(&fwd, fwd_opts);

	/* Free the argument string. */
	free(fwd.connect_host);

	return (success ? 0 : -1);
@


1.354
log
@ssh proxy mux mode (-O proxy; idea from Simon Tatham):
- mux client speaks the ssh-packet protocol directly over unix-domain socket.
- mux server acts as a proxy, translates channel IDs and relays to the server.
- no filedescriptor passing necessary.
- combined with unix-domain forwarding it's even possible to run mux client
  and server on different machines.
feedback & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.353 2016/09/19 07:52:42 natano Exp $ */
d2448 2
a2449 1
	int ret = -1, r, id, remote_id, listen_port, idx;
d2540 5
d2552 1
a2552 1
		permitted_opens[idx].listen_port = listen_port;
@


1.353
log
@Replace two more arc4random() loops with arc4random_buf().

tweaks and ok dtucker
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.352 2016/09/12 01:22:38 deraadt Exp $ */
d68 1
d118 1
d182 1
d207 14
d243 1
d421 1
d424 2
a425 2
	for (n = 0, i = 0; i < channels_alloc; i++)
		if (channels[i])
d427 12
d442 29
d616 1
d650 1
a675 1

a703 1
		case SSH_CHANNEL_MUX_CLIENT:
d716 2
d2398 272
d2687 2
d2751 2
d2798 2
d2824 2
a2825 1

a2859 1
	packet_check_eom();
d2862 3
a2875 1
	packet_check_eom();
d2879 3
d2899 6
a2904 1
	if (c==NULL || c->type != SSH_CHANNEL_OPENING)
d2954 6
a2959 1
	if (c==NULL || c->type != SSH_CHANNEL_OPENING)
d3003 2
a3058 2
	packet_check_eom();

d3065 3
d3615 1
d3711 1
d3749 1
d3830 1
d4093 4
d4106 2
@


1.352
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.351 2016/07/19 11:38:53 dtucker Exp $ */
a4150 1
	u_int32_t rnd = 0;
d4171 2
a4172 4
		/*
		 * Extract real authentication data and generate fake data
		 * of the same length.
		 */
a4173 1
		x11_fake_data = xmalloc(data_len);
a4177 2
			if (i % 4 == 0)
				rnd = arc4random();
a4178 2
			x11_fake_data[i] = rnd & 0xff;
			rnd >>= 8;
d4181 4
@


1.351
log
@Allow wildcard for PermitOpen hosts as well as ports.  bz#2582, patch from
openssh at mzpqnxow.com and jjelen at redhat.com.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.350 2016/03/07 19:02:43 djm Exp $ */
a42 1
#include <sys/param.h>	/* MIN MAX */
d241 3
a243 3
	channel_max_fd = MAX(channel_max_fd, rfd);
	channel_max_fd = MAX(channel_max_fd, wfd);
	channel_max_fd = MAX(channel_max_fd, efd);
d365 3
a367 3
			max = MAX(max, c->rfd);
			max = MAX(max, c->wfd);
			max = MAX(max, c->efd);
d1873 1
a1873 1
		len = read(c->rfd, buf, MIN(rlen, CHAN_RBUF));
d2176 1
a2176 1
	n = MAX(*maxfdp, channel_max_fd);
d3600 1
a3600 1
	char ntop[NI_MAXHOST], strport[MAX(NI_MAXSERV,sizeof(sunaddr->sun_path))];
@


1.350
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.349 2016/02/05 13:28:19 naddy Exp $ */
d135 3
d3271 2
a3272 1
	if (strcmp(allowed_open->host_to_connect, requestedhost) != 0)
@


1.349
log
@Only check errno if read() has returned an error.  EOF is not an error.
This fixes a problem where the mux master would sporadically fail to
notice that the client had exited.
ok mikeb@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.348 2015/10/15 23:51:40 djm Exp $ */
d1409 1
a1409 1
	int local_port = c->sock == -1 ? 65536 : get_sock_port(c->sock, 1);
d2905 1
a2905 1
			*allocated_listen_port = get_sock_port(sock, 1);
@


1.348
log
@fix some signed/unsigned integer type mismatches in format
strings; reported by Nicholas Lemonias
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.347 2015/07/01 02:26:31 djm Exp $ */
d1872 2
d1875 4
a1878 6
			if (errno != EINTR && errno != EAGAIN) {
				debug2("channel %d: ctl read<=0 rfd %d len %d",
				    c->self, c->rfd, len);
				chan_read_failed(c);
				return 0;
			}
@


1.347
log
@better refuse ForwardX11Trusted=no connections attempted after
ForwardX11Timeout expires; reported by Jann Horn
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.346 2015/06/30 05:25:07 djm Exp $ */
d655 1
a655 1
			    "  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d cc %d)\r\n",
@


1.346
log
@fatal() when a remote window update causes the window value to
overflow. Reported by Georg Wicherski, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.345 2015/06/30 05:23:25 djm Exp $ */
d158 3
d908 7
d1484 6
@


1.345
log
@Fix math error in remote window calculations that causes eventual stalls
for datagram channels. Reported by Georg Wicherski, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.344 2015/06/05 15:13:13 millert Exp $ */
d2617 1
a2617 1
	u_int adjust;
d2633 4
a2636 1
	c->remote_window += adjust;
@


1.344
log
@For "ssh -L 12345:/tmp/sock" don't fail with "No forward host name."
(we have a path, not a host name).  Based on a diff from Jared Yanovich.
OK djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.343 2015/05/08 03:25:07 dtucker Exp $ */
d2246 1
a2246 1
					c->remote_window -= dlen + 4;
@


1.343
log
@Use xcalloc for permitted_adm_opens instead of xmalloc to ensure it's zeroed.
Fixes post-auth crash with permitopen=none.  bz#2355, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.342 2015/04/24 01:36:00 deraadt Exp $ */
a2780 2
	host = (type == SSH_CHANNEL_RPORT_LISTENER) ?
	    fwd->listen_host : fwd->connect_host;
d2783 13
a2795 7
	if (host == NULL) {
		error("No forward host name.");
		return 0;
	}
	if (strlen(host) >= NI_MAXHOST) {
		error("Forward host name too long.");
		return 0;
@


1.342
log
@rename xrealloc() to xreallocarray() since it follows that form.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.341 2015/02/06 23:21:59 millert Exp $ */
d3501 1
a3501 1
	permitted_adm_opens = xmalloc(sizeof(*permitted_adm_opens));
@


1.341
log
@SIZE_MAX is standard, we should be using it in preference to the
obsolete SIZE_T_MAX.  OK miod@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.340 2015/01/20 23:14:00 deraadt Exp $ */
d299 1
a299 1
		channels = xrealloc(channels, channels_alloc + 10,
d2168 2
a2169 2
		*readsetp = xrealloc(*readsetp, nfdset, sizeof(fd_mask));
		*writesetp = xrealloc(*writesetp, nfdset, sizeof(fd_mask));
d3207 1
a3207 1
		permitted_opens = xrealloc(permitted_opens,
d3436 1
a3436 1
	permitted_opens = xrealloc(permitted_opens,
d3486 1
a3486 1
	permitted_adm_opens = xrealloc(permitted_adm_opens,
@


1.340
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.339 2015/01/19 20:07:45 markus Exp $ */
d57 1
a62 1
#include <limits.h>
d2162 1
a2162 1
	if (nfdset && SIZE_T_MAX / nfdset < sizeof(fd_mask))
@


1.339
log
@move dispatch to struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.338 2014/12/11 08:20:09 djm Exp $ */
d43 1
a43 1
#include <sys/param.h>
d62 1
@


1.338
log
@explicitly include sys/param.h in files that use the howmany() macro;
from portable
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.337 2014/10/08 22:15:06 djm Exp $ */
d2321 1
a2321 1
void
d2338 1
a2338 1
		return;
d2358 1
a2358 1
		return;
d2369 1
a2369 1
			return;
d2378 1
d2382 1
a2382 1
void
d2398 1
a2398 1
		return;
d2412 1
a2412 1
		return;
d2420 1
a2420 1
		return;
d2426 1
d2430 1
a2430 1
void
d2450 1
a2450 1

d2454 1
a2454 1
void
d2489 1
d2494 1
a2494 1
void
d2504 1
d2508 1
a2508 1
void
d2522 1
d2526 1
a2526 1
void
d2555 1
d2575 1
a2575 1
void
d2607 1
d2611 1
a2611 1
void
d2619 1
a2619 1
		return;
d2627 1
a2627 1
		return;
d2633 1
d2637 1
a2637 1
void
d2665 1
d2669 1
a2669 1
void
d2686 1
a2686 1
		return;
a2687 1
	;
d2689 1
a2689 1
		return;
d2694 1
d4042 1
a4042 1
void
d4082 1
d4087 1
a4087 1
void
d4107 1
@


1.337
log
@fix a few -Wpointer-sign warnings from clang
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.336 2014/07/15 15:54:14 millert Exp $ */
d43 1
@


1.336
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.335 2014/07/05 23:11:48 djm Exp $ */
d664 1
a664 1
	cp = xstrdup(buffer_ptr(&buffer));
d1050 1
a1050 1
	p = buffer_ptr(&c->input);
d1080 1
a1080 1
	p = buffer_ptr(&c->input);
d1100 1
a1100 1
		p = buffer_ptr(&c->input);
@


1.335
log
@fix remote-forward cancel regression; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.334 2014/07/03 22:33:41 djm Exp $ */
d43 1
d107 3
d112 1
a112 1
	u_short port_to_connect;	/* Connect to 'port'. */
d114 2
a115 1
	u_short listen_port;		/* Remote side should listen port. */
d474 2
d538 2
d586 2
d638 2
a1394 1
	int direct;
a1407 2
	direct = (strcmp(rtype, "direct-tcpip") == 0);

d1423 1
a1423 1
		if (direct) {
d1427 6
d1438 8
a1445 3
		/* originator host and port */
		packet_put_cstring(remote_ipaddr);
		packet_put_int((u_int)remote_port);
d1495 9
d1505 2
a1506 7
			if (c->host_port == 0) {
				nextstate = SSH_CHANNEL_DYNAMIC;
				rtype = "dynamic-tcpip";
			} else {
				nextstate = SSH_CHANNEL_OPENING;
				rtype = "direct-tcpip";
			}
d1519 2
a1520 1
		set_nodelay(newsock);
d1992 2
d2004 2
d2646 1
a2646 1
	c = channel_connect_to(host, host_port,
d2713 1
a2713 1
    int is_client, int gateway_ports)
d2720 1
a2720 1
		if (gateway_ports)
d2722 1
a2722 1
	} else if (gateway_ports || is_client) {
d2726 1
a2726 1
		    (!is_client && gateway_ports == 1)) {
d2760 2
a2761 3
channel_setup_fwd_listener(int type, const char *listen_addr,
    u_short listen_port, int *allocated_listen_port,
    const char *host_to_connect, u_short port_to_connect, int gateway_ports)
d2771 1
a2771 1
	    listen_addr : host_to_connect;
d2784 3
a2786 3
	addr = channel_fwd_bind_addr(listen_addr, &wildcard,
	    is_client, gateway_ports);
	debug3("channel_setup_fwd_listener: type %d wildcard %d addr %s",
d2797 1
a2797 1
	snprintf(strport, sizeof strport, "%d", listen_port);
d2804 1
a2804 2
			error("channel_setup_fwd_listener: "
			    "getaddrinfo(%.64s): %s", addr,
d2828 1
a2828 1
		if (type == SSH_CHANNEL_RPORT_LISTENER && listen_port == 0 &&
d2834 1
a2834 1
			error("channel_setup_fwd_listener: getnameinfo failed");
d2865 1
a2865 1
		 * listen_port == 0 requests a dynamically allocated port -
d2868 1
a2868 1
		if (type == SSH_CHANNEL_RPORT_LISTENER && listen_port == 0 &&
d2881 1
a2881 1
		c->host_port = port_to_connect;
d2883 1
a2883 1
		if (listen_port == 0 && allocated_listen_port != NULL &&
d2887 1
a2887 1
			c->listening_port = listen_port;
d2891 2
a2892 2
		error("channel_setup_fwd_listener: cannot listen to port: %d",
		    listen_port);
d2897 76
a2972 2
int
channel_cancel_rport_listener(const char *host, u_short port)
d2991 22
d3014 11
a3024 2
channel_cancel_lport_listener(const char *lhost, u_short lport,
    int cport, int gateway_ports)
d3028 1
a3028 1
	const char *addr = channel_fwd_bind_addr(lhost, NULL, 1, gateway_ports);
d3057 36
d3095 1
a3095 2
channel_setup_local_fwd_listener(const char *listen_host, u_short listen_port,
    const char *host_to_connect, u_short port_to_connect, int gateway_ports)
d3097 7
a3103 3
	return channel_setup_fwd_listener(SSH_CHANNEL_PORT_LISTENER,
	    listen_host, listen_port, NULL, host_to_connect, port_to_connect,
	    gateway_ports);
d3108 2
a3109 2
channel_setup_remote_fwd_listener(const char *listen_address,
    u_short listen_port, int *allocated_listen_port, int gateway_ports)
d3111 8
a3118 3
	return channel_setup_fwd_listener(SSH_CHANNEL_RPORT_LISTENER,
	    listen_address, listen_port, allocated_listen_port,
	    NULL, 0, gateway_ports);
d3149 1
a3149 2
channel_request_remote_forwarding(const char *listen_host, u_short listen_port,
    const char *host_to_connect, u_short port_to_connect)
d3156 10
a3165 4
		packet_put_cstring("tcpip-forward");
		packet_put_char(1);		/* boolean: want reply */
		packet_put_cstring(channel_rfwd_bind_host(listen_host));
		packet_put_int(listen_port);
d3170 1
a3170 1
	} else {
d3172 3
a3174 3
		packet_put_int(listen_port);
		packet_put_cstring(host_to_connect);
		packet_put_int(port_to_connect);
d3191 2
d3199 22
a3220 5
		permitted_opens[idx].host_to_connect = xstrdup(host_to_connect);
		permitted_opens[idx].port_to_connect = port_to_connect;
		permitted_opens[idx].listen_host = listen_host ?
		    xstrdup(listen_host) : NULL;
		permitted_opens[idx].listen_port = listen_port;
d3227 1
a3227 1
    u_short requestedport)
d3240 1
a3240 1
 * Note that in he listen host/port case
d3246 2
a3247 2
open_listen_match(ForwardPermission *allowed_open, const char *requestedhost,
    u_short requestedport, int translate)
d3267 14
d3285 2
a3286 2
int
channel_request_rforward_cancel(const char *host, u_short port)
d3294 1
a3294 1
		if (open_listen_match(&permitted_opens[i], host, port, 0))
d3308 1
d3310 35
d3346 1
a3348 1
	free(permitted_opens[i].listen_host);
d3350 2
d3357 15
d3377 1
a3377 1
channel_input_port_forward_request(int is_root, int gateway_ports)
a3378 1
	u_short port, host_port;
d3380 1
a3380 1
	char *hostname;
d3383 4
a3386 3
	port = packet_get_int();
	hostname = packet_get_string(NULL);
	host_port = packet_get_int();
d3392 1
a3392 1
	if (port < IPPORT_RESERVED && !is_root)
d3395 2
a3396 2
		    port);
	if (host_port == 0)
d3400 1
a3400 2
	success = channel_setup_local_fwd_listener(NULL, port, hostname,
	    host_port, gateway_ports);
d3403 1
a3403 1
	free(hostname);
d3430 1
d3465 2
d3481 1
d3503 1
d3518 1
d3562 2
a3563 1
	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
d3566 17
a3582 7
		if (cctx->ai->ai_family != AF_INET &&
		    cctx->ai->ai_family != AF_INET6)
			continue;
		if (getnameinfo(cctx->ai->ai_addr, cctx->ai->ai_addrlen,
		    ntop, sizeof(ntop), strport, sizeof(strport),
		    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
			error("connect_next: getnameinfo failed");
d3605 2
a3609 1
		set_nodelay(sock);
d3619 6
a3624 2
	if (cctx->aitop)
		freeaddrinfo(cctx->aitop);
d3628 1
a3628 1
/* Return CONNECTING channel to remote host, port */
d3630 1
a3630 1
connect_to(const char *host, u_short port, char *ctype, char *rname)
d3640 36
a3675 8
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = IPv4or6;
	hints.ai_socktype = SOCK_STREAM;
	snprintf(strport, sizeof strport, "%d", port);
	if ((gaierr = getaddrinfo(host, strport, &hints, &cctx.aitop)) != 0) {
		error("connect_to %.100s: unknown host (%s)", host,
		    ssh_gai_strerror(gaierr));
		return NULL;
d3678 1
a3678 1
	cctx.host = xstrdup(host);
d3684 1
a3684 1
		    host, port, strerror(errno));
d3701 1
a3701 1
		if (open_listen_match(&permitted_opens[i], listen_host,
d3713 17
d3732 1
a3732 1
channel_connect_to(const char *host, u_short port, char *ctype, char *rname)
d3760 32
@


1.334
log
@allow explicit ::1 and 127.0.0.1 forwarding bind addresses when
GatewayPorts=no; allows client to choose address family;
bz#2222 ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.333 2014/06/27 16:41:56 markus Exp $ */
d3054 3
@


1.333
log
@fix remote fwding with same listen port but different listen address
with gerhard@@, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.332 2014/04/28 03:09:18 djm Exp $ */
d2679 1
d2709 5
d2715 8
a2722 2
		else if (strcmp(listen_addr, "localhost") != 0)
			addr = listen_addr;
@


1.332
log
@buffer_get_string_ptr's return should be const to remind
callers that futzing with it will futz with the actual buffer
contents
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.331 2014/02/26 20:29:29 djm Exp $ */
d109 2
a110 1
	u_short listen_port;		/* Remote side should listen port number. */
d3005 2
d3012 39
d3064 1
a3064 2
		if (permitted_opens[i].host_to_connect != NULL &&
		    permitted_opens[i].listen_port == port)
d3078 1
a3079 1
	permitted_opens[i].port_to_connect = 0;
d3082 2
d3147 2
d3180 2
d3195 2
d3214 1
a3214 1
	for (i = 0; i < num_permitted_opens; i++)
d3216 2
d3228 1
a3228 1
	for (i = 0; i < num_adm_permitted_opens; i++)
d3230 2
a3268 9
static int
port_match(u_short allowedport, u_short requestedport)
{
	if (allowedport == FWD_PERMIT_ANY_PORT ||
	    allowedport == requestedport)
		return 1;
	return 0;
}

d3363 2
a3364 1
channel_connect_by_listen_address(u_short listen_port, char *ctype, char *rname)
d3369 2
a3370 2
		if (permitted_opens[i].host_to_connect != NULL &&
		    port_match(permitted_opens[i].listen_port, listen_port)) {
d3390 1
a3390 3
			if (permitted_opens[i].host_to_connect != NULL &&
			    port_match(permitted_opens[i].port_to_connect, port) &&
			    strcmp(permitted_opens[i].host_to_connect, host) == 0)
d3392 2
d3399 1
a3399 4
			if (permitted_adm_opens[i].host_to_connect != NULL &&
			    port_match(permitted_adm_opens[i].port_to_connect, port) &&
			    strcmp(permitted_adm_opens[i].host_to_connect, host)
			    == 0)
d3401 2
@


1.331
log
@don't assume that the socks4 username is \0 terminated;
spotted by Ben Hawkes; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.330 2014/02/15 23:05:36 djm Exp $ */
d2293 1
a2293 1
	char *data;
@


1.330
log
@avoid spurious "getsockname failed: Bad file descriptor" errors in ssh -W;
bz#2200, debian#738692 via Colin Watson; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.329 2014/01/31 16:39:19 tedu Exp $ */
d1067 3
@


1.329
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.328 2013/12/19 01:04:36 djm Exp $ */
d1381 1
a1381 1
	int local_port = get_sock_port(c->sock, 1);
@


1.328
log
@bz#2147: fix multiple remote forwardings with dynamically assigned
listen ports. In the s->c message to open the channel we were sending
zero (the magic number to request a dynamic port) instead of the actual
listen port. The client therefore had no way of discriminating between
them.

Diagnosis and fix by ronf AT timeheart.net
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.327 2013/11/08 00:39:15 djm Exp $ */
d418 1
a418 1
		bzero(cc, sizeof(*cc));
d2649 1
a2649 1
	bzero(cc, sizeof(*cc));
d3274 1
a3274 3
	bzero(cctx, sizeof(*cctx));
	cctx->host = NULL;
	cctx->ai = cctx->aitop = NULL;
@


1.327
log
@use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.326 2013/09/19 01:24:46 djm Exp $ */
d1380 2
d1396 1
a1396 1
	    "connect from %.200s port %d",
d1398 1
a1398 1
	    remote_ipaddr, remote_port);
d1416 1
a1416 1
			packet_put_int(c->listening_port);
d1433 1
@


1.326
log
@bz#1297 - tell the client (via packet_send_debug) when their preferred
listen address has been overridden by the server's GatewayPorts;
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.325 2013/09/13 06:54:34 djm Exp $ */
d699 1
a699 1
	cc = xmalloc(sizeof(*cc));
@


1.325
log
@avoid unaligned access in code that reused a buffer to send a
struct in_addr in a reply; simpler just use use buffer_put_int();
from portable; spotted by and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.324 2013/07/12 00:19:58 djm Exp $ */
d2688 1
a2688 1
		    (!is_client && gateway_ports == 1))
d2690 12
@


1.324
log
@fix pointer-signedness warnings from clang/llvm-3.3; "seems nice" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.323 2013/06/07 15:37:52 dtucker Exp $ */
a1233 1
	((struct in_addr *)&dest_addr)->s_addr = INADDR_ANY;
d1237 1
a1237 1
	buffer_append(&c->output, &dest_addr, sizeof(struct in_addr));
@


1.324.2.1
log
@cherrypick commit:

date: 2013/11/08 00:39:15;  author: djm;  state: Exp;  lines: +2 -2;
use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.324 2013/07/12 00:19:58 djm Exp $ */
d699 1
a699 1
	cc = xcalloc(1, sizeof(*cc));
@


1.323
log
@Add an "ABANDONED" channel state and use for mux sessions that are
disconnected via the ~. escape sequence.  Channels in this state will
be able to close if the server responds, but do not count as active channels.
This means that if you ~. all of the mux clients when using ControlPersist
on a broken network, the backgrounded mux master will exit when the
Control Persist time expires rather than hanging around indefinitely.
bz#1917, also reported and tested by tedu@@.  ok djm@@ markus@@.
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.322 2013/06/01 13:15:51 dtucker Exp $ */
d1137 2
a1138 1
	u_char *p, dest_addr[255+1], ntop[INET6_ADDRSTRLEN];
d1208 1
a1208 1
	buffer_get(&c->input, (char *)&dest_addr, addrlen);
@


1.322
log
@Use clock_gettime(CLOCK_MONOTONIC ...) for ssh timers so that things like
keepalives and rekeying will work properly over clock steps.  Suggested by
markus@@, "looks good" djm@@.
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.321 2013/05/17 00:13:13 djm Exp $ */
d212 1
d529 1
d575 1
d623 1
d2476 1
a2476 1
	if (c->type != SSH_CHANNEL_CLOSED)
@


1.321
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.320 2013/04/06 16:07:00 markus Exp $ */
d1333 1
a1333 1
				c->notbefore = time(NULL) + 1;
d1480 1
a1480 1
				c->notbefore = time(NULL) + 1;
d1516 1
a1516 1
				c->notbefore = time(NULL) + 1;
d1903 1
a1903 1
			c->notbefore = time(NULL) + 1;
d2066 1
a2066 1
	now = time(NULL);
@


1.320
log
@handle ECONNABORTED for accept(); ok deraadt some time ago...
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.319 2012/12/02 20:46:11 djm Exp $ */
d399 1
a399 1
	xfree(s);
d407 6
a412 12
	if (c->remote_name) {
		xfree(c->remote_name);
		c->remote_name = NULL;
	}
	if (c->path) {
		xfree(c->path);
		c->path = NULL;
	}
	if (c->listening_addr) {
		xfree(c->listening_addr);
		c->listening_addr = NULL;
	}
d418 1
a418 1
		xfree(cc);
d423 1
a423 1
	xfree(c);
d1072 2
a1073 4
	if (c->path != NULL) {
		xfree(c->path);
		c->path = NULL;
	}
d1206 2
a1207 4
	if (c->path != NULL) {
		xfree(c->path);
		c->path = NULL;
	}
d1367 1
a1367 1
		xfree(remote_ipaddr);
d1381 1
a1381 1
		xfree(remote_ipaddr);
d1394 1
a1394 1
	xfree(c->remote_name);
d1426 1
a1426 1
	xfree(remote_ipaddr);
d1672 1
a1672 1
			xfree(data);
d2196 1
a2196 1
						xfree(data);
d2204 1
a2204 1
					xfree(data);
d2376 1
a2376 1
		xfree(data);
d2382 1
a2382 1
	xfree(data);
d2548 2
a2549 4
		if (msg != NULL)
			xfree(msg);
		if (lang != NULL)
			xfree(lang);
d2607 2
a2608 2
	xfree(originator_string);
	xfree(host);
d2643 1
a2643 1
	xfree(cc);
d3017 1
a3017 1
	xfree(permitted_opens[i].host_to_connect);
d3056 1
a3056 1
	xfree(hostname);
d3111 1
a3111 1
		xfree(permitted_opens[idx].host_to_connect);
d3144 3
a3146 6
		if (permitted_opens[i].host_to_connect != NULL)
			xfree(permitted_opens[i].host_to_connect);
	if (num_permitted_opens > 0) {
		xfree(permitted_opens);
		permitted_opens = NULL;
	}
d3156 3
a3158 6
		if (permitted_adm_opens[i].host_to_connect != NULL)
			xfree(permitted_adm_opens[i].host_to_connect);
	if (num_adm_permitted_opens > 0) {
		xfree(permitted_adm_opens);
		permitted_adm_opens = NULL;
	}
d3252 1
a3252 1
	xfree(cctx->host);
d3615 1
a3615 1
	xfree(remote_host);
d3723 1
a3723 1
	xfree(new_data);
@


1.319
log
@make AllowTcpForwarding accept "local" and "remote" in addition to its
current "yes"/"no" to allow the server to specify whether just local or
remote TCP forwarding is enabled. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.318 2012/04/23 08:18:17 djm Exp $ */
d1322 1
a1322 1
	int newsock;
d1332 1
d1336 1
d1339 3
a1341 1
			error("accept: %.100s", strerror(errno));
d1486 3
a1488 1
			error("accept: %.100s", strerror(errno));
@


1.319.2.1
log
@openssh-6.4 for the 5.3 branch; reminded by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.324.2.1 2013/11/08 01:33:56 djm Exp $ */
d701 1
a701 1
	cc = xcalloc(1, sizeof(*cc));
@


1.318
log
@fix function proto/source mismatch
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.317 2012/04/11 13:16:19 djm Exp $ */
d3138 4
a3141 6
	if (num_adm_permitted_opens == 0) {
		permitted_adm_opens = xmalloc(sizeof(*permitted_adm_opens));
		permitted_adm_opens[num_adm_permitted_opens].host_to_connect
		   = NULL;
		num_adm_permitted_opens = 1;
	}
@


1.317
log
@don't spin in accept() when out of fds (ENFILE/ENFILE) - back off for a
while; ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.316 2012/03/29 23:54:36 dtucker Exp $ */
d2115 1
a2115 1
    u_int *nallocp, int *minwait_secs, int rekeying)
@


1.316
log
@Add PermitOpen none option based on patch from Loganaden Velvindron
(bz #1949).  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.315 2011/09/23 07:45:05 markus Exp $ */
d309 1
d1338 2
d1483 2
d1517 4
a1520 1
			error("accept from auth socket: %.100s", strerror(errno));
d1906 2
d2058 2
a2059 1
channel_handler(chan_fn *ftab[], fd_set *readset, fd_set *writeset)
d2064 1
d2070 3
d2083 19
a2101 2
		if (ftab[c->type] != NULL)
			(*ftab[c->type])(c, readset, writeset);
d2104 3
d2115 1
a2115 1
    u_int *nallocp, int rekeying)
d2138 2
a2139 1
		channel_handler(channel_pre, *readsetp, *writesetp);
d2149 1
a2149 1
	channel_handler(channel_post, readset, writeset);
@


1.315
log
@unbreak remote portforwarding with dynamic allocated listen ports:
1) send the actual listen port in the open message (instead of 0).
   this allows multiple forwardings with a dynamic listen port
2) update the matching permit-open entry, so we can identify where
   to connect to
report: den at skbkontur.ru and P. Szczygielski
feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.314 2011/09/23 00:22:04 dtucker Exp $ */
d3100 11
d3151 3
a3153 1
		if (permitted_adm_opens[i].host_to_connect != NULL)
@


1.314
log
@Add wildcard support to PermitOpen, allowing things like "PermitOpen
localhost:*".  bz #1857, ok djm markus.
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.313 2011/09/10 22:26:34 markus Exp $ */
a2788 1
		c->listening_port = listen_port;
d2790 5
d2903 2
d2910 1
a2910 1
	int type, success = 0;
d2949 4
a2952 4
		permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
		permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
		permitted_opens[num_permitted_opens].listen_port = listen_port;
		num_permitted_opens++;
d2954 1
a2954 1
	return (success ? 0 : -1);
d3055 29
@


1.313
log
@support cancellation of local/dynamic forwardings from ~C commandline;
ok & feedback djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.312 2011/09/09 22:46:44 djm Exp $ */
d124 3
d3111 22
d3235 1
a3235 1
		    permitted_opens[i].listen_port == listen_port) {
d3256 1
a3256 1
			    permitted_opens[i].port_to_connect == port &&
d3265 1
a3265 1
			    permitted_adm_opens[i].port_to_connect == port &&
@


1.312
log
@support for cancelling local and remote port forwards via the multiplex
socket. Use ssh -O cancel -L xx:xx:xx -R yy:yy:yy user@@host" to request
the cancellation of the specified forwardings; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.311 2011/06/22 22:08:42 djm Exp $ */
d2819 1
a2819 1
    u_short cport, int gateway_ports)
d2829 1
a2829 1
		if (c->listening_port != lport || c->host_port != cport)
d2831 8
@


1.311
log
@hook up a channel confirm callback to warn the user then requested X11
forwarding was refused by the server; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.310 2010/11/24 01:24:14 djm Exp $ */
d300 2
d411 4
d2621 40
d2686 3
a2688 30
	/*
	 * Determine whether or not a port forward listens to loopback,
	 * specified address or wildcard. On the client, a specified bind
	 * address will always override gateway_ports. On the server, a
	 * gateway_ports of 1 (``yes'') will override the client's
	 * specification and force a wildcard bind, whereas a value of 2
	 * (``clientspecified'') will bind to whatever address the client
	 * asked for.
	 *
	 * Special-case listen_addrs are:
	 *
	 * "0.0.0.0"               -> wildcard v4/v6 if SSH_OLD_FORWARD_ADDR
	 * "" (empty string), "*"  -> wildcard v4/v6
	 * "localhost"             -> loopback v4/v6
	 */
	addr = NULL;
	if (listen_addr == NULL) {
		/* No address specified: default to gateway_ports setting */
		if (gateway_ports)
			wildcard = 1;
	} else if (gateway_ports || is_client) {
		if (((datafellows & SSH_OLD_FORWARD_ADDR) &&
		    strcmp(listen_addr, "0.0.0.0") == 0 && is_client == 0) ||
		    *listen_addr == '\0' || strcmp(listen_addr, "*") == 0 ||
		    (!is_client && gateway_ports == 1))
			wildcard = 1;
		else if (strcmp(listen_addr, "localhost") != 0)
			addr = listen_addr;
	}

d2787 1
d2805 19
d2825 10
a2834 2
		if (c != NULL && c->type == SSH_CHANNEL_RPORT_LISTENER &&
		    strcmp(c->path, host) == 0 && c->listening_port == port) {
d2865 21
a2888 1

a2896 15
		const char *address_to_bind;
		if (listen_host == NULL) {
			if (datafellows & SSH_BUG_RFWD_ADDR)
				address_to_bind = "127.0.0.1";
			else
				address_to_bind = "localhost";
		} else if (*listen_host == '\0' ||
			   strcmp(listen_host, "*") == 0) {
			if (datafellows & SSH_BUG_RFWD_ADDR)
				address_to_bind = "0.0.0.0";
			else
				address_to_bind = "";
		} else
			address_to_bind = listen_host;

d2899 2
a2900 2
		packet_put_char(1);			/* boolean: want reply */
		packet_put_cstring(address_to_bind);
d2944 1
a2944 1
void
d2950 1
a2950 1
		return;
d2959 1
a2959 1
		return;
d2964 1
a2964 1
	packet_put_cstring(host == NULL ? "" : host);
d2972 2
@


1.310
log
@remove a debug() that pollutes stderr on client connecting to a server
in debug mode (channel_close_fds is called transitively from the session
code post-fork); bz#1719, ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.309 2010/08/05 13:08:42 djm Exp $ */
d3503 1
a3503 1
    const char *proto, const char *data)
d3556 1
a3556 1
		channel_request_start(client_session_id, "x11-req", 0);
@


1.309
log
@Fix a trio of bugs in the local/remote window calculation for datagram
data channels (i.e. TunnelForward):

Calculate local_consumed correctly in channel_handle_wfd() by measuring
the delta to buffer_len(c->output) from when we start to when we finish.
The proximal problem here is that the output_filter we use in portable
modified the length of the dequeued datagram (to futz with the headers
for !OpenBSD).

In channel_output_poll(), don't enqueue datagrams that won't fit in the
peer's advertised packet size (highly unlikely to ever occur) or which
won't fit in the peer's remaining window (more likely).

In channel_input_data(), account for the 4-byte string header in
datagram packets that we accept from the peer and enqueue in c->output.

report, analysis and testing 2/3 cases from wierbows AT us.ibm.com;
"looks good" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.308 2010/07/13 23:13:16 djm Exp $ */
a370 3
	debug3("channel %d: close_fds r %d w %d e %d",
	    c->self, c->rfd, c->wfd, c->efd);

@


1.308
log
@s/timing_safe_cmp/timingsafe_bcmp/g
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.307 2010/07/13 11:52:06 djm Exp $ */
d1635 1
a1635 1
	u_int dlen;
d1642 1
a1660 1
			c->local_consumed += dlen + 4;
d1672 1
a1672 1
			return 1;
a1705 3
		if (compat20 && len > 0) {
			c->local_consumed += len;
		}
d1707 3
d2153 8
d2246 1
a2246 1
	u_int data_len;
d2262 3
d2275 2
a2276 2
			c->local_window -= data_len;
			c->local_consumed += data_len;
d2282 1
a2282 1
		if (data_len > c->local_maxpacket) {
d2284 1
a2284 1
			    c->self, data_len, c->local_maxpacket);
d2286 1
a2286 1
		if (data_len > c->local_window) {
d2288 1
a2288 1
			    c->self, data_len, c->local_window);
d2291 1
a2291 1
		c->local_window -= data_len;
@


1.307
log
@implement a timing_safe_cmp() function to compare memory without leaking
timing information by short-circuiting like memcmp() and use it for
some of the more sensitive comparisons (though nothing high-value was
readily attackable anyway); "looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.306 2010/06/25 07:20:04 djm Exp $ */
d915 1
a915 1
	    timing_safe_cmp(ucp + 12 + ((proto_len + 3) & ~3),
@


1.306
log
@bz#1750: fix requirement for /dev/null inside ChrootDirectory for
internal-sftp accidentally introduced in r1.253 by removing the code
that opens and dup /dev/null to stderr and modifying the channels code
to read stderr but discard it instead; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.305 2010/06/25 07:14:45 djm Exp $ */
d915 1
a915 1
	    memcmp(ucp + 12 + ((proto_len + 3) & ~3),
@


1.305
log
@bz#1327: remove hardcoded limit of 100 permitopen clauses and port
forwards per direction; ok markus@@ stevesk@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.304 2010/05/14 23:29:23 djm Exp $ */
d837 3
a839 2
		else if (!(c->flags & CHAN_EOF_SENT) &&
		    c->extended_usage == CHAN_EXTENDED_READ &&
d1738 3
a1740 1
		} else if (c->extended_usage == CHAN_EXTENDED_READ &&
d1752 5
a1756 1
				buffer_append(&c->extended, buf, len);
@


1.304
log
@Pause the mux channel while waiting for reply from aynch callbacks.
Prevents misordering of replies if new requests arrive while waiting.

Extend channel open confirm callback to allow signalling failure
conditions as well as success. Use this to 1) fix a memory leak, 2)
start using the above pause mechanism and 3) delay sending a success/
failure message on mux slave session open until we receive a reply from
the server.

motivated by and with feedback from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.303 2010/01/30 21:12:08 djm Exp $ */
d113 1
a113 1
static ForwardPermission permitted_opens[SSH_MAX_FORWARDS_PER_DIRECTION];
d116 1
a116 1
static ForwardPermission permitted_adm_opens[SSH_MAX_FORWARDS_PER_DIRECTION];
a2812 4
	/* Record locally that connection to this host/port is permitted. */
	if (num_permitted_opens >= SSH_MAX_FORWARDS_PER_DIRECTION)
		fatal("channel_request_remote_forwarding: too many forwards");

d2862 3
a2959 2
	if (num_permitted_opens >= SSH_MAX_FORWARDS_PER_DIRECTION)
		fatal("channel_add_permitted_opens: too many forwards");
d2962 2
a2973 2
	if (num_adm_permitted_opens >= SSH_MAX_FORWARDS_PER_DIRECTION)
		fatal("channel_add_adm_permitted_opens: too many forwards");
d2976 2
d2992 4
d3007 4
@


1.303
log
@fake local addr:port when stdio fowarding as some servers (Tectia at
least) validate that they are well-formed;
reported by imorgan AT nas.nasa.gov
ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.302 2010/01/26 01:28:35 djm Exp $ */
d328 1
d702 1
a702 1
channel_register_open_confirm(int id, channel_callback_fn *fn, void *ctx)
d990 1
a990 1
	if (c->istate == CHAN_INPUT_OPEN &&
d1822 1
a1822 1
	if (c->rfd != -1 && FD_ISSET(c->rfd, readset) &&
d2445 1
a2445 1
			c->open_confirm(c->self, c->open_confirm_ctx);
d2496 5
@


1.302
log
@rewrite ssh(1) multiplexing code to a more sensible protocol.

The new multiplexing code uses channels for the listener and
accepted control sockets to make the mux master non-blocking, so
no stalls when processing messages from a slave.

avoid use of fatal() in mux master protocol parsing so an errant slave
process cannot take down a running master.

implement requesting of port-forwards over multiplexed sessions. Any
port forwards requested by the slave are added to those the master has
established.

add support for stdio forwarding ("ssh -W host:port ...") in mux slaves.

document master/slave mux protocol so that other tools can use it to
control a running ssh(1). Note: there are no guarantees that this
protocol won't be incompatibly changed (though it is versioned).

feedback Salvador Fandino, dtucker@@
channel changes ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.301 2010/01/11 01:39:46 dtucker Exp $ */
d1373 7
@


1.301
log
@Add a 'netcat mode' (ssh -W).  This connects stdio on the client to a single
port forward on the server.  This allows, for example, using ssh as
a ProxyCommand to route connections via intermediate servers.
bz #1618, man page help from jmc@@, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.300 2010/01/09 23:04:13 dtucker Exp $ */
a237 1
	c->ctl_fd = -1; /* XXX: set elsewhere */
d325 3
d370 2
a371 2
	debug3("channel %d: close_fds r %d w %d e %d c %d",
	    c->self, c->rfd, c->wfd, c->efd, c->ctl_fd);
a373 1
	channel_close_fd(&c->ctl_fd);
a398 2
	if (c->ctl_fd != -1)
		shutdown(c->ctl_fd, SHUT_RDWR);
d520 1
d534 1
d566 2
d618 2
d630 1
a630 1
			    "  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d cfd %d)\r\n",
d635 1
a635 1
			    c->rfd, c->wfd, c->ctl_fd);
a841 3
	if (compat20 && c->ctl_fd != -1 &&
	    c->istate == CHAN_INPUT_OPEN && c->ostate == CHAN_OUTPUT_OPEN)
		FD_SET(c->ctl_fd, readset);
d986 22
d1240 2
a1241 1
channel_connect_stdio_fwd(const char *host_to_connect, u_short port_to_connect)
a1243 1
	int in, out;
a1247 5
	in = dup(STDIN_FILENO);
	out = dup(STDOUT_FILENO);
	if (in < 0 || out < 0)
		fatal("channel_connect_stdio_fwd: dup() in/out failed");

a1749 28
channel_handle_ctl(Channel *c, fd_set *readset, fd_set *writeset)
{
	char buf[16];
	int len;

	/* Monitor control fd to detect if the slave client exits */
	if (c->ctl_fd != -1 && FD_ISSET(c->ctl_fd, readset)) {
		len = read(c->ctl_fd, buf, sizeof(buf));
		if (len < 0 && (errno == EINTR || errno == EAGAIN))
			return 1;
		if (len <= 0) {
			debug2("channel %d: ctl read<=0", c->self);
			if (c->type != SSH_CHANNEL_OPEN) {
				debug2("channel %d: not open", c->self);
				chan_mark_dead(c);
				return -1;
			} else {
				chan_read_failed(c);
				chan_write_failed(c);
			}
			return -1;
		} else
			fatal("%s: unexpected data on ctl fd", __func__);
	}
	return 1;
}

static int
a1778 1
	channel_handle_ctl(c, readset, writeset);
d1782 122
d1932 2
d1942 2
@


1.300
log
@Remove RoutingDomain from ssh since it's now not needed.  It can be replaced
with "route exec" or "nc -V" as a proxycommand.  "route exec" also ensures
that trafic such as DNS lookups stays withing the specified routingdomain.

For example (from reyk):
# route -T 2 exec /usr/sbin/sshd
or inherited from the parent process
$ route -T 2 exec sh
$ ssh 10.1.2.3

ok deraadt@@ markus@@ stevesk@@ reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.296 2009/05/25 06:48:00 andreas Exp $ */
d1213 29
@


1.299
log
@fix race condition in x11/agent channel allocation: don't read after
the end of the select read/write fdset and make sure a reused FD
is not touched before the pre-handlers are called.
with and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.298 2009/11/10 04:30:44 dtucker Exp $ */
a161 3
/* Set the routing domain a.k.a. VRF */
static int channel_rdomain = -1;

a2441 6
void
channel_set_rdomain(int rdomain)
{
	channel_rdomain = rdomain;
}

d2550 1
a2550 2
		sock = socket_rdomain(ai->ai_family, ai->ai_socktype,
		    ai->ai_protocol, channel_rdomain);
d2883 2
a2884 3
		if ((sock = socket_rdomain(cctx->ai->ai_family,
		    cctx->ai->ai_socktype, cctx->ai->ai_protocol,
		    channel_rdomain)) == -1) {
d3070 2
a3071 2
			sock = socket_rdomain(ai->ai_family, ai->ai_socktype,
			    ai->ai_protocol, channel_rdomain);
d3218 1
a3218 2
		sock = socket_rdomain(ai->ai_family, ai->ai_socktype,
		    ai->ai_protocol, channel_rdomain);
@


1.298
log
@Set close-on-exec on various descriptors so they don't get leaked to
child processes.  bz #1643, patch from jchadima at redhat, ok deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.297 2009/10/28 16:38:18 reyk Exp $ */
d329 1
a1226 1
	c->delayed = 0;
d1430 1
a1430 8
		if (nextstate == SSH_CHANNEL_DYNAMIC) {
			/*
			 * do not call the channel_post handler until
			 * this flag has been reset by a pre-handler.
			 * otherwise the FD_ISSET calls might overflow
			 */
			nc->delayed = 1;
		} else {
a1431 1
		}
a1756 2
	if (c->delayed)
		return;
d1888 1
a1888 1
	u_int i;
d1895 1
a1895 1
	for (i = 0; i < channels_alloc; i++) {
d1899 6
@


1.297
log
@Allow to set the rdomain in ssh/sftp/scp/sshd and ssh-keyscan.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.296 2009/05/25 06:48:00 andreas Exp $ */
d53 1
d231 6
a236 1
	/* XXX set close-on-exec -markus */
@


1.296
log
@Put the globals in packet.c into a struct and don't access it directly
from other files. No functional changes.
ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.295 2009/02/12 03:00:56 djm Exp $ */
d161 3
d2443 6
d2557 2
a2558 1
		sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
d2891 3
a2893 2
		if ((sock = socket(cctx->ai->ai_family, cctx->ai->ai_socktype,
		    cctx->ai->ai_protocol)) == -1) {
d3079 2
a3080 2
			sock = socket(ai->ai_family, ai->ai_socktype,
			    ai->ai_protocol);
d3227 2
a3228 1
		sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
@


1.295
log
@support remote port forwarding with a zero listen port (-R0:...) to
dyamically allocate a listen port at runtime (this is actually
specified in rfc4254); bz#1003 ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.294 2009/01/22 09:49:57 djm Exp $ */
d2412 1
a2412 1
	keep_alive_timeouts = 0;
@


1.294
log
@oops! I committed the wrong version of the Channel->path diff,
it was missing some tweaks suggested by stevesk@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.293 2009/01/22 09:46:01 djm Exp $ */
d2441 2
a2442 1
channel_setup_fwd_listener(int type, const char *listen_addr, u_short listen_port,
d2450 1
d2519 2
a2520 1

d2522 10
a2531 1
		if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)
d2533 9
d2557 2
a2558 1
		debug("Local forwarding listening on %s port %s.", ntop, strport);
d2573 13
d2628 1
a2628 1
	    listen_host, listen_port, host_to_connect, port_to_connect,
d2635 1
a2635 1
    u_short listen_port, int gateway_ports)
d2638 2
a2639 1
	    listen_address, listen_port, NULL, 0, gateway_ports);
@


1.293
log
@make Channel->path an allocated string, saving a few bytes here and
there and fixing bz#1380 in the process; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.292 2009/01/14 01:38:06 djm Exp $ */
d1179 1
a1179 1
		if (addrlen > NI_MAXHOST - 1) {
d2458 1
a2458 1
	if (strlen(host) > NI_MAXHOST) {
@


1.292
log
@support SOCKS4A protocol, from dwmw2 AT infradead.org via bz#1482;
"looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.291 2009/01/01 21:14:35 djm Exp $ */
d294 1
d401 4
d1038 4
d1044 1
a1044 1
		strlcpy(c->path, host, sizeof(c->path));
d1055 1
a1055 1
		if (strlcpy(c->path, p, sizeof(c->path)) >= sizeof(c->path)) {
d1060 1
d1101 1
a1101 1
	u_char *p, dest_addr[255+1];
d1174 16
a1189 4
	if (s5_req.atyp == SSH_SOCKS5_DOMAIN)
		strlcpy(c->path, (char *)dest_addr, sizeof(c->path));
	else if (inet_ntop(af, dest_addr, c->path, sizeof(c->path)) == NULL)
		return -1;
d1418 2
a1419 1
		strlcpy(nc->path, c->path, sizeof(nc->path));
d2458 1
a2458 1
	if (strlen(host) > SSH_CHANNEL_PATH_LEN - 1) {
d2555 1
a2555 1
		strlcpy(c->path, host, sizeof(c->path));
d2577 1
a2577 2
		    strncmp(c->path, host, sizeof(c->path)) == 0 &&
		    c->listening_port == port) {
@


1.291
log
@call channel destroy callbacks on receipt of open failure messages.
fixes client hangs when connecting to a server that has MaxSessions=0
set spotted by imorgan AT nas.nasa.gov; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.290 2008/12/09 03:20:42 stevesk Exp $ */
d978 1
a978 1
	u_int len, have, i, found;
d994 9
d1005 3
a1007 2
			found = 1;
			break;
d1016 1
a1016 1
	if (!found)
d1026 1
a1031 1
	buffer_consume(&c->input, 1);		/* trailing '\0' */
d1033 20
a1052 2
	host = inet_ntoa(s4_req.dest_addr);
	strlcpy(c->path, host, sizeof(c->path));
d1056 1
a1056 1
	    c->self, host, c->host_port, s4_req.command);
d1059 2
a1060 2
		debug("channel %d: cannot handle: socks4 cn %d",
		    c->self, s4_req.command);
@


1.290
log
@channel_print_adm_permitted_opens() should deal with all the printing
for that config option.  suggested by markus@@; ok markus@@ djm@@
dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.289 2008/12/02 19:09:38 markus Exp $ */
d2292 2
a2293 2
	/* Free the channel.  This will also close the socket. */
	channel_free(c);
@


1.289
log
@s/remote_id/id/ to be more consistent with other code; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.288 2008/11/11 03:55:11 stevesk Exp $ */
d2766 1
d2768 1
a2768 1
		printf(" any");
d2775 1
@


1.288
log
@for sshd -T print 'permitopen any' vs. 'permitopen' for case of no
permitopen's; ok and input dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.287 2008/11/01 06:43:33 stevesk Exp $ */
d2358 1
a2358 1
	int remote_id;
d2363 1
a2363 1
	remote_id = packet_get_int();
d2366 1
a2366 1
	debug2("channel_input_status_confirm: type %d id %d", type, remote_id);
d2368 2
a2369 2
	if ((c = channel_lookup(remote_id)) == NULL) {
		logit("channel_input_status_confirm: %d: unknown", remote_id);
@


1.287
log
@fix some typos in log messages; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.286 2008/07/16 11:52:19 djm Exp $ */
d2766 4
@


1.286
log
@this loop index should be automatic, not static
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.285 2008/07/13 22:13:07 djm Exp $ */
d689 1
a689 1
		logit("channel_register_open_comfirm: %d: bad id", id);
d2366 1
a2366 1
	debug2("channel_input_confirm: type %d id %d", type, remote_id);
d2369 1
a2369 1
		logit("channel_input_success_failure: %d: unknown", remote_id);
@


1.285
log
@use struct sockaddr_storage instead of struct sockaddr for accept(2)
address argument. from visibilis AT yahoo.com in bz#1485; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.284 2008/07/12 04:52:50 djm Exp $ */
d2764 1
a2764 1
	static int i;
@


1.284
log
@unbreak; move clearing of cctx struct to before first use
reported by dkrause@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.283 2008/07/10 18:05:58 markus Exp $ */
d1208 1
a1208 1
	struct sockaddr addr;
d1217 1
a1217 1
		newsock = accept(c->sock, &addr, &addrlen);
d1334 1
a1334 1
	struct sockaddr addr;
d1358 1
a1358 1
		newsock = accept(c->sock, &addr, &addrlen);
d1393 1
a1393 1
	struct sockaddr addr;
d1398 1
a1398 1
		newsock = accept(c->sock, &addr, &addrlen);
@


1.283
log
@missing bzero; from mickey; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.282 2008/06/16 13:22:53 dtucker Exp $ */
d2840 1
a2850 1
	memset(&cctx, 0, sizeof(cctx));
@


1.282
log
@Rename the isatty argument to is_tty so we don't shadow isatty(3).
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.281 2008/06/15 20:06:26 djm Exp $ */
d2850 1
@


1.281
log
@don't call isatty() on a pty master, instead pass a flag down to
channel_set_fds() indicating that te fds refer to a tty. Fixes a
hang on exit on Solaris (bz#1463) in portable but is actually
a generic bug; ok dtucker deraadt markus
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.280 2008/06/12 15:19:17 djm Exp $ */
d220 1
a220 1
    int extusage, int nonblock, int isatty)
d236 1
a236 1
	if ((c->isatty = isatty) != 0)
d740 1
a740 1
    int extusage, int nonblock, int isatty, u_int window_max)
d746 1
a746 1
	channel_register_fds(c, rfd, wfd, efd, extusage, nonblock, isatty);
@


1.280
log
@The multiplexing escape char handler commit last night introduced a
small memory leak per session; plug it.
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.279 2008/06/12 03:40:52 djm Exp $ */
d220 1
a220 1
    int extusage, int nonblock)
d236 1
a236 2
	/* XXX ugly hack: nonblock is only set by the server */
	if (nonblock && isatty(c->rfd)) {
a237 8
		c->isatty = 1;
		if (!isatty(c->wfd)) {
			error("channel %d: wfd %d is not a tty?",
			    c->self, c->wfd);
		}
	} else {
		c->isatty = 0;
	}
d297 1
a297 1
	channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
d740 1
a740 1
    int extusage, int nonblock, u_int window_max)
d746 1
a746 1
	channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
@


1.279
log
@Enable ~ escapes for multiplex slave sessions; give each channel
its own escape state and hook the escape filters up to muxed
channels. bz #1331

Mux slaves do not currently support the ~^Z and ~& escapes.

NB. this change cranks the mux protocol version, so a new ssh
mux client will not be able to connect to a running old ssh
mux master.

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.278 2008/06/10 04:50:25 dtucker Exp $ */
d326 2
d416 2
d733 1
a733 1
    channel_outfilter_fn *ofn, void *ctx)
d744 1
@


1.278
log
@Add extended test mode (-T) and connection parameters for test mode (-C).
-T causes sshd to write its effective configuration to stdout and exit.
-C causes any relevant Match rules to be applied before output.  The
combination allows tesing of the parser and config files.  ok deraadt djm
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.277 2008/05/09 16:17:51 markus Exp $ */
d729 1
a729 1
    channel_outfilter_fn *ofn)
d739 1
@


1.277
log
@error-fd race: don't enable the error fd in the select bitmask
for channels with both in- and output closed, since the channel
will go away before we call select();
report, lots of debugging help and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.276 2008/05/09 04:55:56 djm Exp $ */
d2762 11
@


1.276
log
@Try additional addresses when connecting to a port forward destination
whose DNS name resolves to more than one address. The previous behaviour
was to try the first address and give up.

Reported by stig AT venaas.com in bz#343

great feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.275 2008/05/08 12:02:23 djm Exp $ */
d817 2
a818 1
	if (compat20 && c->efd != -1) {
@


1.275
log
@Implement a channel success/failure status confirmation callback
mechanism. Each channel maintains a queue of callbacks, which will
be drained in order (RFC4253 guarantees confirm messages are not
reordered within an channel).

Also includes a abandonment callback to clean up if a channel is
closed without sending confirmation messages. This probably
shouldn't happen in compliant implementations, but it could be
abused to leak memory.

ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.274 2008/05/08 06:59:01 markus Exp $ */
d164 4
d1427 1
a1427 1
	int err = 0;
d1436 3
a1438 1
			debug("channel %d: connected", c->self);
d1452 1
a1452 1
			debug("channel %d: not connected: %s",
d1454 11
d2330 1
a2330 1
	int remote_id, sock = -1;
d2342 2
a2343 7
	sock = channel_connect_to(host, host_port);
	if (sock != -1) {
		c = channel_new("connected socket",
		    SSH_CHANNEL_CONNECTING, sock, sock, -1, 0, 0, 0,
		    originator_string, 1);
		c->remote_id = remote_id;
	}
d2345 1
d2350 2
a2351 2
	}
	xfree(host);
d2763 1
a2763 1
/* return socket to remote host, port */
d2765 1
a2765 1
connect_to(const char *host, u_short port)
d2767 1
a2767 1
	struct addrinfo hints, *ai, *aitop;
a2768 2
	int gaierr;
	int sock = -1;
d2770 3
a2772 11
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = IPv4or6;
	hints.ai_socktype = SOCK_STREAM;
	snprintf(strport, sizeof strport, "%d", port);
	if ((gaierr = getaddrinfo(host, strport, &hints, &aitop)) != 0) {
		error("connect_to %.100s: unknown host (%s)", host,
		    ssh_gai_strerror(gaierr));
		return -1;
	}
	for (ai = aitop; ai; ai = ai->ai_next) {
		if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)
d2774 4
a2777 3
		if (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop, sizeof(ntop),
		    strport, sizeof(strport), NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
			error("connect_to: getnameinfo failed");
d2780 3
a2782 3
		sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
		if (sock < 0) {
			if (ai->ai_next == NULL)
d2790 4
a2793 3
		if (connect(sock, ai->ai_addr, ai->ai_addrlen) < 0 &&
		    errno != EINPROGRESS) {
			error("connect_to %.100s port %s: %.100s", ntop, strport,
d2795 1
d2797 1
d2800 8
a2807 1
		break; /* success */
d2809 30
d2840 10
a2849 4
	freeaddrinfo(aitop);
	if (!ai) {
		error("connect_to %.100s port %d: failed.", host, port);
		return -1;
d2851 4
a2854 3
	/* success */
	set_nodelay(sock);
	return sock;
d2857 2
a2858 2
int
channel_connect_by_listen_address(u_short listen_port)
d2862 1
a2862 1
	for (i = 0; i < num_permitted_opens; i++)
d2864 1
a2864 1
		    permitted_opens[i].listen_port == listen_port)
d2867 3
a2869 1
			    permitted_opens[i].port_to_connect);
d2872 1
a2872 1
	return -1;
d2876 2
a2877 2
int
channel_connect_to(const char *host, u_short port)
d2903 1
a2903 1
		return -1;
d2905 1
a2905 1
	return connect_to(host, port);
@


1.274
log
@avoid extra malloc/copy/free when receiving data over the net;
~10% speedup for localhost-scp; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.273 2008/04/02 21:36:51 markus Exp $ */
d47 1
d318 2
a319 2
	c->confirm = NULL;
	c->confirm_ctx = NULL;
d322 1
d379 1
d403 7
d668 18
a685 1
channel_register_confirm(int id, channel_callback_fn *fn, void *ctx)
d690 1
a690 1
		logit("channel_register_comfirm: %d: bad id", id);
d693 2
a694 2
	c->confirm = fn;
	c->confirm_ctx = ctx;
d2222 1
a2222 1
		if (c->confirm) {
d2224 1
a2224 1
			c->confirm(c->self, c->confirm_ctx);
d2341 28
@


1.273
log
@avoid possible hijacking of x11-forwarded connections (back out 1.183)
CVE-2008-1483; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.272 2008/01/19 23:02:40 djm Exp $ */
d1998 1
a1998 1
	data = packet_get_string(&data_len);
a2011 1
		xfree(data);
a2022 1
			xfree(data);
a2026 1
	packet_check_eom();
d2031 1
a2031 1
	xfree(data);
@


1.272
log
@When we added support for specified bind addresses for port forwards, we
added a quirk SSH_OLD_FORWARD_ADDR. There is a bug in our handling of
this for -L port forwards that causes the client to listen on both v4
and v6 addresses when connected to a server with this quirk, despite
having set 0.0.0.0 as a bind_address.

report and patch from Jan.Pechanec AT Sun.COM; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.271 2007/12/27 14:22:08 dtucker Exp $ */
a2871 3

				if (ai->ai_next)
					continue;
@


1.272.2.1
log
@avoid possible hijacking of x11-forwarded connections (back out 1.183)
CVE-2008-1483; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.272 2008/01/19 23:02:40 djm Exp $ */
d2872 3
@


1.271
log
@Add a small helper function to consistently handle the EAI_SYSTEM error
code of getaddrinfo.  Prompted by vgiffin at apple com via bz #1417.
ok markus@@ stevesk@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.270 2007/06/25 08:20:03 dtucker Exp $ */
d2371 1
a2371 1
		    strcmp(listen_addr, "0.0.0.0") == 0) ||
@


1.270
log
@Correct test for window updates every three packets; prevents sending
window updates for every single packet.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.269 2007/06/11 08:04:44 markus Exp $ */
d2395 1
a2395 1
			    gai_strerror(r));
d2398 2
a2399 1
			    "getaddrinfo(%.64s): %s", addr, gai_strerror(r));
d2713 1
a2713 1
		    gai_strerror(gaierr));
d2855 1
a2855 1
			error("getaddrinfo: %.100s", gai_strerror(gaierr));
d3006 2
a3007 1
		error("%.100s: unknown host. (%s)", buf, gai_strerror(gaierr));
@


1.270.2.1
log
@avoid possible hijacking of x11-forwarded connections (back out 1.183)
CVE-2008-1483; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.270 2007/06/25 08:20:03 dtucker Exp $ */
d2871 3
@


1.269
log
@send 'window adjust' messages every tree packets and do not wait
until 50% of the window is consumed.  ok djm dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.268 2007/01/03 03:01:40 stevesk Exp $ */
d1643 1
a1643 1
	    ((c->local_window_max - c->local_window <
@


1.268
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.267 2006/12/12 03:58:42 djm Exp $ */
d1643 3
a1645 1
	    c->local_window < c->local_window_max/2 &&
@


1.268.2.1
log
@avoid possible hijacking of x11-forwarded connections (back out 1.183)
CVE-2008-1483; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.268 2007/01/03 03:01:40 stevesk Exp $ */
d2869 3
@


1.267
log
@bz #1019: some ssh.com versions apparently can't cope with the remote port
forwarding bind_address being a hostname, so send them an address for cases
where they are not explicitly specified (wildcard or localhost bind).
reported by daveroth AT acm.org; ok dtucker@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.266 2006/08/29 10:40:18 djm Exp $ */
d1050 1
a1050 1
		for (found = 0, i = 2 ; i < nmethods + 2; i++) {
@


1.266
log
@normalise some inconsistent (but harmless) NULL pointer checks
spotted by the Stanford SATURN tool, via Isil Dillig;
ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.265 2006/08/03 03:34:41 deraadt Exp $ */
d2508 12
a2519 5
		if (listen_host == NULL)
			address_to_bind = "localhost";
		else if (*listen_host == '\0' || strcmp(listen_host, "*") == 0)
			address_to_bind = "";
		else
@


1.265
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.264 2006/08/01 23:36:11 stevesk Exp $ */
d3123 1
a3123 3
	cp = disp;
	if (disp)
		cp = strchr(disp, ':');
@


1.264
log
@clean extra spaces
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.263 2006/08/01 23:22:47 stevesk Exp $ */
d42 1
a42 2
#include "includes.h"

a43 1
#include <sys/types.h>
d58 1
d60 1
a64 1
#include "xmalloc.h"
d67 1
a73 1
#include "bufaux.h"
@


1.263
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.262 2006/07/26 13:57:17 stevesk Exp $ */
d1052 1
a1052 1
			if (p[i] == SSH_SOCKS5_NOAUTH ) {
@


1.262
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.261 2006/07/25 02:59:21 stevesk Exp $ */
d55 1
@


1.261
log
@move #include <sys/time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.260 2006/07/22 20:48:22 stevesk Exp $ */
d55 1
@


1.260
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.259 2006/07/21 21:13:30 stevesk Exp $ */
d48 1
@


1.259
log
@more ARGSUSED (lint) for dispatch table-driven functions; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.258 2006/07/21 12:43:36 dtucker Exp $ */
d54 1
@


1.258
log
@Make PermitOpen take a list of permitted ports and act more like most other
keywords (ie the first match is the effective setting).  This also makes it
easier to override a previously set PermitOpen.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.257 2006/07/17 12:06:00 dtucker Exp $ */
d736 1
d743 1
d798 1
d811 1
d941 1
d1020 1
d1171 1
d1297 1
d1355 1
d1389 1
d1436 1
d1478 1
d1606 1
d1669 1
d3029 1
d3073 1
@


1.257
log
@Add PermitOpen directive to sshd_config which is equivalent to the
"permitopen" key option.  Allows server admin to allow TCP port forwarding
only two specific host/port pairs.  Useful when combined with Match.

If permitopen is used in both sshd_config and a key option, both must allow
a given connection before it will be permitted.

Note that users can still use external forwarders such as netcat, so to be
those must be controlled too for the limits to be effective.

Feedback & ok djm@@, man page corrections & ok jmc@@.
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.256 2006/07/17 01:31:09 stevesk Exp $ */
d2636 1
a2636 1
void
d2641 1
a2641 1
	debug("allow port forwarding to host %s port %d", host, port);
d2646 1
a2646 1
	num_adm_permitted_opens++;
@


1.256
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.255 2006/07/12 22:28:51 stevesk Exp $ */
d107 1
a107 1
/* List of all permitted host/port pairs to connect. */
d110 4
a113 1
/* Number of permitted host/port pairs in the array. */
d115 4
d2637 13
d2658 6
d2665 4
d2747 1
a2747 1
	int i, permit;
d2756 1
d2758 8
d2767 2
a2768 1
	if (!permit) {
@


1.255
log
@move #include <netdb.h> out of includes.h; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.254 2006/07/11 20:07:25 stevesk Exp $ */
d55 1
@


1.254
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.253 2006/07/11 18:50:47 markus Exp $ */
d53 1
@


1.253
log
@add ExitOnForwardFailure: terminate the connection if ssh(1)
cannot set up all requested dynamic, local, and remote port
forwardings. ok djm, dtucker, stevesk, jmc
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.252 2006/07/10 12:08:08 djm Exp $ */
d52 1
@


1.252
log
@fix misparsing of SOCKS 5 packets that could result in a crash;
reported by mk@@ ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.251 2006/07/03 17:59:32 stevesk Exp $ */
d2468 1
a2468 1
void
a2511 1
			logit("Warning: Server denied remote port forwarding.");
d2525 1
d2565 1
a2565 1
 * message if there was an error).  This never returns if there was an error.
d2567 1
a2567 1
void
d2571 1
d2591 1
a2591 1
	channel_setup_local_fwd_listener(NULL, port, hostname,
d2596 2
d2616 1
a2616 1
		fatal("channel_request_remote_forwarding: too many forwards");
@


1.251
log
@move #include <arpa/inet.h> out of includes.h; old ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.250 2006/04/16 00:48:52 djm Exp $ */
d1016 1
a1016 1
	u_int have, i, found, nmethods, addrlen, af;
d1077 4
a1080 1
	if (have < 4 + addrlen + 2)
@


1.250
log
@Fix condition where we could exit with a fatal error when an input
buffer became too large and the remote end had advertised a big window.
The problem was a mismatch in the backoff math between the channels code
and the buffer code, so make a buffer_check_alloc() function that the
channels code can use to propsectivly check whether an incremental
allocation will succeed.  bz #1131, debugged with the assistance of
cove AT wildpackets.com; ok dtucker@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.249 2006/03/30 09:41:25 djm Exp $ */
d47 4
@


1.249
log
@ARGSUSED for dispatch table-driven functions
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.248 2006/03/28 01:52:28 deraadt Exp $ */
a748 3
	/* check buffer limits */
	limit = MIN(limit, (BUFFER_MAX_LEN - BUFFER_MAX_CHUNK - CHAN_RBUF));

d751 2
a752 1
	    buffer_len(&c->input) < limit)
@


1.248
log
@do not accept unreasonable X ports numbers; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.247 2006/03/25 18:58:10 deraadt Exp $ */
d1942 2
d2003 1
d2050 1
d2074 1
d2113 1
d2126 1
d2143 1
d2191 1
d2223 1
d2248 1
@


1.247
log
@delete cast not required
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.246 2006/03/25 18:56:54 deraadt Exp $ */
d2855 1
a2855 1
	int display_number, sock = 0;
d2860 1
a2860 1
	int gaierr;
d2880 1
a2880 1
		if (sscanf(strrchr(display, ':') + 1, "%d", &display_number) != 1) {
d2905 1
a2905 1
	if (sscanf(cp + 1, "%d", &display_number) != 1) {
d2915 1
a2915 1
	snprintf(strport, sizeof strport, "%d", 6000 + display_number);
d2929 1
a2929 1
			debug2("connect %.100s port %d: %.100s", buf,
d2939 1
a2939 1
		error("connect %.100s port %d: %.100s", buf, 6000 + display_number,
@


1.246
log
@remove (char *) casts to a function that accepts void * for the arg
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.245 2006/03/25 18:43:30 deraadt Exp $ */
d1051 1
a1051 1
	memcpy((char *)&s5_req, p, sizeof(s5_req));
@


1.245
log
@use strtonum() instead of atoi() [limit X screens to 400, sorry]
@
text
@d1 1
a1 1
/* $OpenBSD: channels.c,v 1.244 2006/03/25 13:17:01 djm Exp $ */
d990 1
a990 1
	buffer_append(&c->output, (char *)&s4_rsp, sizeof(s4_rsp));
d1099 3
a1101 3
	buffer_append(&c->output, (char *)&s5_rsp, sizeof(s5_rsp));
	buffer_append(&c->output, (char *)&dest_addr, sizeof(struct in_addr));
	buffer_append(&c->output, (char *)&dest_port, sizeof(dest_port));
@


1.244
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d3048 1
a3048 1
		screen_number = atoi(cp + 1);
@


1.243
log
@change OpenSSH's xrealloc() function from being xrealloc(p, new_size) to
xrealloc(p, new_nmemb, new_itemsize).

realloc is particularly prone to integer overflows because it is almost
always allocating "n * size" bytes, so this is a far safer API;
ok deraadt@@
@
text
@d1 1
@


1.242
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d268 2
a269 2
		channels = xrealloc(channels,
		    (channels_alloc + 10) * sizeof(Channel *));
d1786 1
a1786 1
	u_int n, sz;
d1790 6
a1795 1
	sz = howmany(n+1, NFDBITS) * sizeof(fd_mask);
d1798 2
a1799 2
		*readsetp = xrealloc(*readsetp, sz);
		*writesetp = xrealloc(*writesetp, sz);
@


1.241
log
@spacing
@
text
@d251 1
a251 1
		channels = xmalloc(channels_alloc * sizeof(Channel *));
d276 1
a276 2
	c = channels[found] = xmalloc(sizeof(Channel));
	memset(c, 0, sizeof(Channel));
d2810 1
a2810 1
	*chanids = xmalloc(sizeof(**chanids) * (num_socks + 1));
@


1.240
log
@x11_fake_data is only ever used as u_char *
@
text
@a194 1

a239 1

a340 1

a354 1

a400 1

a413 1

a439 1

a468 1

a510 1

a554 1

d639 1
d652 1
d665 1
d678 1
d1451 1
d1534 1
d1578 1
d1606 1
a1817 1

a1936 1

a2545 1

a2612 1

@


1.239
log
@annoying spacing fixes getting in the way of real diffs
@
text
@d131 1
a131 1
static char *x11_fake_data = NULL;
@


1.238
log
@sprinkle u_int throughout pty subsystem, ok markus
@
text
@d2846 1
a2846 1
	if (connect(sock, (struct sockaddr *) & addr, sizeof(addr)) == 0)
@


1.237
log
@spacing
@
text
@d2728 4
a2731 4
		packet_put_int(ws.ws_col);
		packet_put_int(ws.ws_row);
		packet_put_int(ws.ws_xpixel);
		packet_put_int(ws.ws_ypixel);
@


1.236
log
@RCSID() can die
@
text
@d176 1
a176 1
	switch(c->type) {
a185 1
		break;
d724 1
a724 1
typedef void chan_fn(Channel *c, fd_set * readset, fd_set * writeset);
d729 1
a729 1
channel_pre_listener(Channel *c, fd_set * readset, fd_set * writeset)
d735 1
a735 1
channel_pre_connecting(Channel *c, fd_set * readset, fd_set * writeset)
d742 1
a742 1
channel_pre_open_13(Channel *c, fd_set * readset, fd_set * writeset)
d751 1
a751 1
channel_pre_open(Channel *c, fd_set * readset, fd_set * writeset)
d791 1
a791 1
channel_pre_input_draining(Channel *c, fd_set * readset, fd_set * writeset)
d803 1
a803 1
channel_pre_output_draining(Channel *c, fd_set * readset, fd_set * writeset)
d879 1
a879 1
channel_pre_x11_open_13(Channel *c, fd_set * readset, fd_set * writeset)
d905 1
a905 1
channel_pre_x11_open(Channel *c, fd_set * readset, fd_set * writeset)
d932 1
a932 1
channel_decode_socks4(Channel *c, fd_set * readset, fd_set * writeset)
d1010 1
a1010 1
channel_decode_socks5(Channel *c, fd_set * readset, fd_set * writeset)
d1113 1
a1113 1
channel_pre_dynamic(Channel *c, fd_set * readset, fd_set * writeset)
d1157 1
a1157 1
channel_post_x11_listener(Channel *c, fd_set * readset, fd_set * writeset)
d1282 1
a1282 1
channel_post_port_listener(Channel *c, fd_set * readset, fd_set * writeset)
d1339 1
a1339 1
channel_post_auth_listener(Channel *c, fd_set * readset, fd_set * writeset)
d1372 1
a1372 1
channel_post_connecting(Channel *c, fd_set * readset, fd_set * writeset)
d1418 1
a1418 1
channel_handle_rfd(Channel *c, fd_set * readset, fd_set * writeset)
d1458 1
a1458 1
channel_handle_wfd(Channel *c, fd_set * readset, fd_set * writeset)
d1540 1
a1540 1
channel_handle_efd(Channel *c, fd_set * readset, fd_set * writeset)
d1583 1
a1583 1
channel_handle_ctl(Channel *c, fd_set * readset, fd_set * writeset)
d1630 1
a1630 1
channel_post_open(Channel *c, fd_set * readset, fd_set * writeset)
d1644 1
a1644 1
channel_post_output_drain_13(Channel *c, fd_set * readset, fd_set * writeset)
d1761 1
a1761 1
channel_handler(chan_fn *ftab[], fd_set * readset, fd_set * writeset)
d1813 1
a1813 1
channel_after_select(fd_set * readset, fd_set * writeset)
@


1.235
log
@move #include <sys/un.h> out of includes.h; ok djm@@
@
text
@a41 1
RCSID("$OpenBSD: channels.c,v 1.234 2006/02/10 00:27:13 stevesk Exp $");
@


1.235.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: channels.c,v 1.266 2006/08/29 10:40:18 djm Exp $ */
d41 4
a45 1
#include <sys/ioctl.h>
a46 5
#include <sys/socket.h>
#include <sys/time.h>

#include <netinet/in.h>
#include <arpa/inet.h>
a47 5
#include <errno.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
a48 2
#include <unistd.h>
#include <stdarg.h>
a49 1
#include "xmalloc.h"
d54 1
a56 1
#include "buffer.h"
d63 1
d100 1
a100 1
/* List of all permitted host/port pairs to connect by the user. */
d103 1
a103 4
/* List of all permitted host/port pairs to connect by the admin. */
static ForwardPermission permitted_adm_opens[SSH_MAX_FORWARDS_PER_DIRECTION];

/* Number of permitted host/port pairs in the array permitted by the user. */
a104 4

/* Number of permitted host/port pair in the array permitted by the admin. */
static int num_adm_permitted_opens = 0;

d132 1
a132 1
static u_char *x11_fake_data = NULL;
d177 1
a177 1
	switch (c->type) {
d187 1
d197 1
d243 1
d255 1
a255 1
		channels = xcalloc(channels_alloc, sizeof(Channel *));
d272 2
a273 2
		channels = xrealloc(channels, channels_alloc + 10,
		    sizeof(Channel *));
d280 2
a281 1
	c = channels[found] = xcalloc(1, sizeof(Channel));
d345 1
d360 1
d407 1
d421 1
d448 1
d478 1
d521 1
d566 1
a650 1

a662 1

a674 1

a686 1

d726 1
a726 1
typedef void chan_fn(Channel *c, fd_set *readset, fd_set *writeset);
a729 1
/* ARGSUSED */
d731 1
a731 1
channel_pre_listener(Channel *c, fd_set *readset, fd_set *writeset)
a735 1
/* ARGSUSED */
d737 1
a737 1
channel_pre_connecting(Channel *c, fd_set *readset, fd_set *writeset)
d744 1
a744 1
channel_pre_open_13(Channel *c, fd_set *readset, fd_set *writeset)
d753 1
a753 1
channel_pre_open(Channel *c, fd_set *readset, fd_set *writeset)
d757 3
d762 1
a762 2
	    buffer_len(&c->input) < limit &&
	    buffer_check_alloc(&c->input, CHAN_RBUF))
a791 1
/* ARGSUSED */
d793 1
a793 1
channel_pre_input_draining(Channel *c, fd_set *readset, fd_set *writeset)
a803 1
/* ARGSUSED */
d805 1
a805 1
channel_pre_output_draining(Channel *c, fd_set *readset, fd_set *writeset)
d881 1
a881 1
channel_pre_x11_open_13(Channel *c, fd_set *readset, fd_set *writeset)
d907 1
a907 1
channel_pre_x11_open(Channel *c, fd_set *readset, fd_set *writeset)
a932 1
/* ARGSUSED */
d934 1
a934 1
channel_decode_socks4(Channel *c, fd_set *readset, fd_set *writeset)
d998 1
a998 1
	buffer_append(&c->output, &s4_rsp, sizeof(s4_rsp));
a1010 1
/* ARGSUSED */
d1012 1
a1012 1
channel_decode_socks5(Channel *c, fd_set *readset, fd_set *writeset)
d1022 1
a1022 1
	u_int have, need, i, found, nmethods, addrlen, af;
d1038 1
a1038 1
			if (p[i] == SSH_SOCKS5_NOAUTH) {
d1059 1
a1059 1
	memcpy(&s5_req, p, sizeof(s5_req));
d1083 1
a1083 4
	need = sizeof(s5_req) + addrlen + 2;
	if (s5_req.atyp == SSH_SOCKS5_DOMAIN)
		need++;
	if (have < need)
d1107 3
a1109 3
	buffer_append(&c->output, &s5_rsp, sizeof(s5_rsp));
	buffer_append(&c->output, &dest_addr, sizeof(struct in_addr));
	buffer_append(&c->output, &dest_port, sizeof(dest_port));
d1115 1
a1115 1
channel_pre_dynamic(Channel *c, fd_set *readset, fd_set *writeset)
a1157 1
/* ARGSUSED */
d1159 1
a1159 1
channel_post_x11_listener(Channel *c, fd_set *readset, fd_set *writeset)
a1282 1
/* ARGSUSED */
d1284 1
a1284 1
channel_post_port_listener(Channel *c, fd_set *readset, fd_set *writeset)
a1339 1
/* ARGSUSED */
d1341 1
a1341 1
channel_post_auth_listener(Channel *c, fd_set *readset, fd_set *writeset)
a1372 1
/* ARGSUSED */
d1374 1
a1374 1
channel_post_connecting(Channel *c, fd_set *readset, fd_set *writeset)
a1418 1
/* ARGSUSED */
d1420 1
a1420 1
channel_handle_rfd(Channel *c, fd_set *readset, fd_set *writeset)
a1458 2

/* ARGSUSED */
d1460 1
a1460 1
channel_handle_wfd(Channel *c, fd_set *readset, fd_set *writeset)
a1540 1

d1542 1
a1542 1
channel_handle_efd(Channel *c, fd_set *readset, fd_set *writeset)
a1583 2

/* ARGSUSED */
d1585 1
a1585 1
channel_handle_ctl(Channel *c, fd_set *readset, fd_set *writeset)
a1610 1

d1632 1
a1632 1
channel_post_open(Channel *c, fd_set *readset, fd_set *writeset)
a1644 1
/* ARGSUSED */
d1646 1
a1646 1
channel_post_output_drain_13(Channel *c, fd_set *readset, fd_set *writeset)
d1763 1
a1763 1
channel_handler(chan_fn *ftab[], fd_set *readset, fd_set *writeset)
d1791 1
a1791 1
	u_int n, sz, nfdset;
d1795 1
a1795 6
	nfdset = howmany(n+1, NFDBITS);
	/* Explicitly test here, because xrealloc isn't always called */
	if (nfdset && SIZE_T_MAX / nfdset < sizeof(fd_mask))
		fatal("channel_prepare_select: max_fd (%d) is too large", n);
	sz = nfdset * sizeof(fd_mask);

d1798 2
a1799 2
		*readsetp = xrealloc(*readsetp, nfdset, sizeof(fd_mask));
		*writesetp = xrealloc(*writesetp, nfdset, sizeof(fd_mask));
d1815 1
a1815 1
channel_after_select(fd_set *readset, fd_set *writeset)
d1822 1
a1942 1
/* ARGSUSED */
a2001 1
/* ARGSUSED */
a2047 1
/* ARGSUSED */
a2070 1
/* ARGSUSED */
a2108 1
/* ARGSUSED */
a2120 1
/* ARGSUSED */
a2136 1
/* ARGSUSED */
a2183 1
/* ARGSUSED */
a2214 1
/* ARGSUSED */
a2238 1
/* ARGSUSED */
d2453 1
a2453 1
int
d2497 1
a2510 1
	return (success ? 0 : -1);
d2550 1
a2550 1
 * message if there was an error).
d2552 2
a2553 1
int
a2556 1
	int success = 0;
d2576 1
a2576 1
	success = channel_setup_local_fwd_listener(NULL, port, hostname,
a2580 2

	return (success ? 0 : -1);
d2599 1
a2599 1
		fatal("channel_add_permitted_opens: too many forwards");
a2608 13
int
channel_add_adm_permitted_opens(char *host, int port)
{
	if (num_adm_permitted_opens >= SSH_MAX_FORWARDS_PER_DIRECTION)
		fatal("channel_add_adm_permitted_opens: too many forwards");
	debug("config allows port forwarding to host %s port %d", host, port);

	permitted_adm_opens[num_adm_permitted_opens].host_to_connect
	     = xstrdup(host);
	permitted_adm_opens[num_adm_permitted_opens].port_to_connect = port;
	return ++num_adm_permitted_opens;
}

d2618 1
a2620 10
void
channel_clear_adm_permitted_opens(void)
{
	int i;

	for (i = 0; i < num_adm_permitted_opens; i++)
		if (permitted_adm_opens[i].host_to_connect != NULL)
			xfree(permitted_adm_opens[i].host_to_connect);
	num_adm_permitted_opens = 0;
}
d2698 1
a2698 1
	int i, permit, permit_adm = 1;
a2706 1
	}
a2707 8
	if (num_adm_permitted_opens > 0) {
		permit_adm = 0;
		for (i = 0; i < num_adm_permitted_opens; i++)
			if (permitted_adm_opens[i].host_to_connect != NULL &&
			    permitted_adm_opens[i].port_to_connect == port &&
			    strcmp(permitted_adm_opens[i].host_to_connect, host)
			    == 0)
				permit_adm = 1;
d2709 1
a2709 2

	if (!permit || !permit_adm) {
d2730 4
a2733 4
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
d2819 1
a2819 1
	*chanids = xcalloc(num_socks + 1, sizeof(**chanids));
d2848 1
a2848 1
	if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0)
d2858 1
a2858 1
	u_int display_number;
d2863 1
a2863 1
	int gaierr, sock = 0;
d2883 1
a2883 1
		if (sscanf(strrchr(display, ':') + 1, "%u", &display_number) != 1) {
d2908 1
a2908 1
	if (sscanf(cp + 1, "%u", &display_number) != 1) {
d2918 1
a2918 1
	snprintf(strport, sizeof strport, "%u", 6000 + display_number);
d2932 1
a2932 1
			debug2("connect %.100s port %u: %.100s", buf,
d2942 1
a2942 1
		error("connect %.100s port %u: %.100s", buf, 6000 + display_number,
a2955 1
/* ARGSUSED */
a2998 1
/* ARGSUSED */
d3045 3
a3047 1
	cp = strchr(disp, ':');
d3051 1
a3051 1
		screen_number = (u_int)strtonum(cp + 1, 0, 400, NULL);
@


1.234
log
@move #include <sys/ioctl.h> out of includes.h; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.233 2006/02/07 01:42:00 stevesk Exp $");
d45 2
@


1.233
log
@move #include <termios.h> out of includes.h; ok markus@@
@
text
@d42 3
a44 1
RCSID("$OpenBSD: channels.c,v 1.232 2006/01/30 12:22:22 reyk Exp $");
@


1.232
log
@mark channel as write failed or dead instead of read failed on error
of the channel output filter.

ok markus@@
@
text
@d42 3
a44 1
RCSID("$OpenBSD: channels.c,v 1.231 2005/12/30 15:56:36 reyk Exp $");
@


1.231
log
@add channel output filter interface.

ok djm@@, suggested by markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.230 2005/12/28 22:46:06 stevesk Exp $");
d1468 5
a1472 1
				chan_read_failed(c);
@


1.230
log
@use 'break-in' for consistency; ok deraadt@@ ok and input jmc@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.229 2005/12/12 13:46:18 markus Exp $");
a60 2
#define CHAN_RBUF	16*1024

d301 1
d682 2
a683 1
channel_register_filter(int id, channel_filter_fn *fn)
d691 2
a692 1
	c->input_filter = fn;
d1457 1
a1457 1
	u_char *data;
d1465 12
a1477 1
			data = buffer_get_string(&c->output, &dlen);
d1480 1
a1480 1
			len = write(c->wfd, data, dlen);
d1493 2
a1494 3
		data = buffer_ptr(&c->output);
		dlen = buffer_len(&c->output);
		len = write(c->wfd, data, dlen);
d1511 1
a1511 1
		if (compat20 && c->isatty && dlen >= 1 && data[0] != '\r') {
d1518 1
a1518 1
				 * (4 byte channel id + data)
@


1.229
log
@make sure protocol messages for internal channels are ignored.
allow adjust messages for non-open channels; with and ok djm@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.228 2005/12/06 22:38:27 reyk Exp $");
d2994 1
a2994 1
	error("Warning: this is probably a break in attempt by a malicious server.");
@


1.228
log
@Add support for tun(4) forwarding over OpenSSH, based on an idea and
initial channel code bits by markus@@. This is a simple and easy way to
use OpenSSH for ad hoc virtual private network connections, e.g.
administrative tunnels or secure wireless access. It's based on a new
ssh channel and works similar to the existing TCP forwarding support,
except that it depends on the tun(4) network interface on both ends of
the connection for layer 2 or layer 3 tunneling. This diff also adds
support for LocalCommand in the ssh(1) client.

ok djm@@, markus@@, jmc@@ (manpages), tested and discussed with others
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.227 2005/10/14 02:29:37 stevesk Exp $");
d145 1
a145 1
channel_lookup(int id)
d150 1
a150 1
		logit("channel_lookup: %d: bad id", id);
d155 1
a155 1
		logit("channel_lookup: %d: bad id: channel free", id);
d162 28
d661 1
a661 1
	Channel *c = channel_lookup(id);
d673 1
a673 1
	Channel *c = channel_lookup(id);
d2208 2
a2209 3
	if (c == NULL || c->type != SSH_CHANNEL_OPEN) {
		logit("Received window adjust for "
		    "non-open channel %d.", id);
@


1.227
log
@free()->xfree(); ok djm@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.226 2005/10/11 23:37:37 djm Exp $");
d1416 2
d1436 17
d1808 16
d1946 4
a1949 1
	buffer_append(&c->output, data, data_len);
@


1.226
log
@bz #1076 set SO_REUSEADDR on X11 forwarding listner sockets, preventing
bind() failure when a previous connection's listeners are in TIME_WAIT,
reported by plattner AT inf.ethz.ch; ok dtucker@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.225 2005/10/10 10:23:08 djm Exp $");
d2457 1
a2457 1
	free(permitted_opens[i].host_to_connect);
@


1.225
log
@fix regression I introduced in 4.2: X11 forwardings initiated after
a session has exited (e.g. "(sleep 5; xterm) &") would not start.
bz #1086 reported by t8m AT centrum.cz; ok markus@@ dtucker@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.224 2005/09/07 08:53:53 markus Exp $");
d1232 13
d2201 1
a2201 1
	int sock, r, success = 0, on = 1, wildcard = 0, is_client;
d2288 2
a2289 7
		/*
		 * Set socket options.
		 * Allow local port reuse in TIME_WAIT.
		 */
		if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &on,
		    sizeof(on)) == -1)
			error("setsockopt SO_REUSEADDR: %s", strerror(errno));
d2696 1
@


1.224
log
@enforce chanid != NULL; ok djm
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.223 2005/07/17 07:17:54 djm Exp $");
d271 1
d631 1
a631 1
channel_register_cleanup(int id, channel_callback_fn *fn)
d640 1
d652 1
d1666 1
a1666 1
		if (!chan_is_dead(c, 0))
@


1.223
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.222 2005/07/17 06:49:04 djm Exp $");
d2659 3
d2721 1
a2721 2
	if (chanids != NULL)
		*chanids = xmalloc(sizeof(**chanids) * (num_socks + 1));
d2729 1
a2729 2
		if (*chanids != NULL)
			(*chanids)[n] = nc->self;
d2731 1
a2731 2
	if (*chanids != NULL)
		(*chanids)[n] = -1;
@


1.223.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.232 2006/01/30 12:22:22 reyk Exp $");
d61 2
d145 1
a145 1
channel_by_id(int id)
d150 1
a150 1
		logit("channel_by_id: %d: bad id", id);
d155 1
a155 1
		logit("channel_by_id: %d: bad id: channel free", id);
a161 28
 * Returns the channel if it is allowed to receive protocol messages.
 * Private channels, like listening sockets, may not receive messages.
 */
Channel *
channel_lookup(int id)
{
	Channel *c;

	if ((c = channel_by_id(id)) == NULL)
		return (NULL);

	switch(c->type) {
	case SSH_CHANNEL_X11_OPEN:
	case SSH_CHANNEL_LARVAL:
	case SSH_CHANNEL_CONNECTING:
	case SSH_CHANNEL_DYNAMIC:
	case SSH_CHANNEL_OPENING:
	case SSH_CHANNEL_OPEN:
	case SSH_CHANNEL_INPUT_DRAINING:
	case SSH_CHANNEL_OUTPUT_DRAINING:
		return (c);
		break;
	}
	logit("Non-public channel %d, type %d.", id, c->type);
	return (NULL);
}

/*
a270 1
	c->detach_close = 0;
a273 1
	c->output_filter = NULL;
d630 1
a630 1
channel_register_cleanup(int id, channel_callback_fn *fn, int do_close)
d632 1
a632 1
	Channel *c = channel_by_id(id);
a638 1
	c->detach_close = do_close;
d643 1
a643 1
	Channel *c = channel_by_id(id);
a649 1
	c->detach_close = 0;
d652 1
a652 2
channel_register_filter(int id, channel_infilter_fn *ifn,
    channel_outfilter_fn *ofn)
d660 1
a660 2
	c->input_filter = ifn;
	c->output_filter = ofn;
a1228 13
static void
channel_set_reuseaddr(int fd)
{
	int on = 1;

	/*
	 * Set socket options.
	 * Allow local port reuse in TIME_WAIT.
	 */
	if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1)
		error("setsockopt SO_REUSEADDR fd %d: %s", fd, strerror(errno));
}

a1399 2
		} else if (c->datagram) {
			buffer_put_string(&c->input, buf, len);
d1410 1
a1410 1
	u_char *data = NULL, *buf;
d1418 3
a1420 34
		if (c->output_filter != NULL) {
			if ((buf = c->output_filter(c, &data, &dlen)) == NULL) {
				debug2("channel %d: filter stops", c->self);
				if (c->type != SSH_CHANNEL_OPEN)
					chan_mark_dead(c);
				else
					chan_write_failed(c);
				return -1;
			}
		} else if (c->datagram) {
			buf = data = buffer_get_string(&c->output, &dlen);
		} else {
			buf = data = buffer_ptr(&c->output);
			dlen = buffer_len(&c->output);
		}

		if (c->datagram) {
			/* ignore truncated writes, datagrams might get lost */
			c->local_consumed += dlen + 4;
			len = write(c->wfd, buf, dlen);
			xfree(data);
			if (len < 0 && (errno == EINTR || errno == EAGAIN))
				return 1;
			if (len <= 0) {
				if (c->type != SSH_CHANNEL_OPEN)
					chan_mark_dead(c);
				else
					chan_write_failed(c);
				return -1;
			}
			return 1;
		}

		len = write(c->wfd, buf, dlen);
d1437 1
a1437 1
		if (compat20 && c->isatty && dlen >= 1 && buf[0] != '\r') {
d1444 1
a1444 1
				 * (4 byte channel id + buf)
d1663 1
a1663 1
		if (!chan_is_dead(c, c->detach_close))
a1772 16
			if (c->datagram) {
				if (len > 0) {
					u_char *data;
					u_int dlen;

					data = buffer_get_string(&c->input,
					    &dlen);
					packet_start(SSH2_MSG_CHANNEL_DATA);
					packet_put_int(c->remote_id);
					packet_put_string(data, dlen);
					packet_send();
					c->remote_window -= dlen + 4;
					xfree(data);
				}
				continue;
			}
d1895 1
a1895 4
	if (c->datagram)
		buffer_put_string(&c->output, data, data_len);
	else
		buffer_append(&c->output, data, data_len);
d2126 3
a2128 2
	if (c == NULL) {
		logit("Received window adjust for non-open channel %d.", id);
d2185 1
a2185 1
	int sock, r, success = 0, wildcard = 0, is_client;
d2272 7
a2278 2

		channel_set_reuseaddr(sock);
d2446 1
a2446 1
	xfree(permitted_opens[i].host_to_connect);
a2658 3
	if (chanids == NULL)
		return -1;

a2681 1
			channel_set_reuseaddr(sock);
d2718 2
a2719 1
	*chanids = xmalloc(sizeof(**chanids) * (num_socks + 1));
d2727 2
a2728 1
		(*chanids)[n] = nc->self;
d2730 2
a2731 1
	(*chanids)[n] = -1;
d2917 1
a2917 1
	error("Warning: this is probably a break-in attempt by a malicious server.");
@


1.223.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: channels.c,v 1.266 2006/08/29 10:40:18 djm Exp $ */
d41 2
a42 17
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/un.h>
#include <sys/socket.h>
#include <sys/time.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <errno.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include <stdarg.h>
a43 1
#include "xmalloc.h"
d48 1
a50 1
#include "buffer.h"
d57 1
d94 1
a94 1
/* List of all permitted host/port pairs to connect by the user. */
d97 1
a97 4
/* List of all permitted host/port pairs to connect by the admin. */
static ForwardPermission permitted_adm_opens[SSH_MAX_FORWARDS_PER_DIRECTION];

/* Number of permitted host/port pairs in the array permitted by the user. */
a98 4

/* Number of permitted host/port pair in the array permitted by the admin. */
static int num_adm_permitted_opens = 0;

d126 1
a126 1
static u_char *x11_fake_data = NULL;
d171 1
a171 1
	switch (c->type) {
d181 1
d191 1
d237 1
d249 1
a249 1
		channels = xcalloc(channels_alloc, sizeof(Channel *));
d266 2
a267 2
		channels = xrealloc(channels, channels_alloc + 10,
		    sizeof(Channel *));
d274 2
a275 1
	c = channels[found] = xcalloc(1, sizeof(Channel));
d339 1
d354 1
d401 1
d415 1
d442 1
d472 1
d515 1
d560 1
a644 1

a656 1

a668 1

a680 1

d720 1
a720 1
typedef void chan_fn(Channel *c, fd_set *readset, fd_set *writeset);
a723 1
/* ARGSUSED */
d725 1
a725 1
channel_pre_listener(Channel *c, fd_set *readset, fd_set *writeset)
a729 1
/* ARGSUSED */
d731 1
a731 1
channel_pre_connecting(Channel *c, fd_set *readset, fd_set *writeset)
d738 1
a738 1
channel_pre_open_13(Channel *c, fd_set *readset, fd_set *writeset)
d747 1
a747 1
channel_pre_open(Channel *c, fd_set *readset, fd_set *writeset)
d751 3
d756 1
a756 2
	    buffer_len(&c->input) < limit &&
	    buffer_check_alloc(&c->input, CHAN_RBUF))
a785 1
/* ARGSUSED */
d787 1
a787 1
channel_pre_input_draining(Channel *c, fd_set *readset, fd_set *writeset)
a797 1
/* ARGSUSED */
d799 1
a799 1
channel_pre_output_draining(Channel *c, fd_set *readset, fd_set *writeset)
d875 1
a875 1
channel_pre_x11_open_13(Channel *c, fd_set *readset, fd_set *writeset)
d901 1
a901 1
channel_pre_x11_open(Channel *c, fd_set *readset, fd_set *writeset)
a926 1
/* ARGSUSED */
d928 1
a928 1
channel_decode_socks4(Channel *c, fd_set *readset, fd_set *writeset)
d992 1
a992 1
	buffer_append(&c->output, &s4_rsp, sizeof(s4_rsp));
a1004 1
/* ARGSUSED */
d1006 1
a1006 1
channel_decode_socks5(Channel *c, fd_set *readset, fd_set *writeset)
d1016 1
a1016 1
	u_int have, need, i, found, nmethods, addrlen, af;
d1032 1
a1032 1
			if (p[i] == SSH_SOCKS5_NOAUTH) {
d1053 1
a1053 1
	memcpy(&s5_req, p, sizeof(s5_req));
d1077 1
a1077 4
	need = sizeof(s5_req) + addrlen + 2;
	if (s5_req.atyp == SSH_SOCKS5_DOMAIN)
		need++;
	if (have < need)
d1101 3
a1103 3
	buffer_append(&c->output, &s5_rsp, sizeof(s5_rsp));
	buffer_append(&c->output, &dest_addr, sizeof(struct in_addr));
	buffer_append(&c->output, &dest_port, sizeof(dest_port));
d1109 1
a1109 1
channel_pre_dynamic(Channel *c, fd_set *readset, fd_set *writeset)
a1151 1
/* ARGSUSED */
d1153 1
a1153 1
channel_post_x11_listener(Channel *c, fd_set *readset, fd_set *writeset)
a1276 1
/* ARGSUSED */
d1278 1
a1278 1
channel_post_port_listener(Channel *c, fd_set *readset, fd_set *writeset)
a1333 1
/* ARGSUSED */
d1335 1
a1335 1
channel_post_auth_listener(Channel *c, fd_set *readset, fd_set *writeset)
a1366 1
/* ARGSUSED */
d1368 1
a1368 1
channel_post_connecting(Channel *c, fd_set *readset, fd_set *writeset)
a1412 1
/* ARGSUSED */
d1414 1
a1414 1
channel_handle_rfd(Channel *c, fd_set *readset, fd_set *writeset)
a1452 2

/* ARGSUSED */
d1454 1
a1454 1
channel_handle_wfd(Channel *c, fd_set *readset, fd_set *writeset)
a1534 1

d1536 1
a1536 1
channel_handle_efd(Channel *c, fd_set *readset, fd_set *writeset)
a1577 2

/* ARGSUSED */
d1579 1
a1579 1
channel_handle_ctl(Channel *c, fd_set *readset, fd_set *writeset)
a1604 1

d1626 1
a1626 1
channel_post_open(Channel *c, fd_set *readset, fd_set *writeset)
a1638 1
/* ARGSUSED */
d1640 1
a1640 1
channel_post_output_drain_13(Channel *c, fd_set *readset, fd_set *writeset)
d1757 1
a1757 1
channel_handler(chan_fn *ftab[], fd_set *readset, fd_set *writeset)
d1785 1
a1785 1
	u_int n, sz, nfdset;
d1789 1
a1789 6
	nfdset = howmany(n+1, NFDBITS);
	/* Explicitly test here, because xrealloc isn't always called */
	if (nfdset && SIZE_T_MAX / nfdset < sizeof(fd_mask))
		fatal("channel_prepare_select: max_fd (%d) is too large", n);
	sz = nfdset * sizeof(fd_mask);

d1792 2
a1793 2
		*readsetp = xrealloc(*readsetp, nfdset, sizeof(fd_mask));
		*writesetp = xrealloc(*writesetp, nfdset, sizeof(fd_mask));
d1809 1
a1809 1
channel_after_select(fd_set *readset, fd_set *writeset)
d1816 1
a1936 1
/* ARGSUSED */
a1995 1
/* ARGSUSED */
a2041 1
/* ARGSUSED */
a2064 1
/* ARGSUSED */
a2102 1
/* ARGSUSED */
a2114 1
/* ARGSUSED */
a2130 1
/* ARGSUSED */
a2177 1
/* ARGSUSED */
a2208 1
/* ARGSUSED */
a2232 1
/* ARGSUSED */
d2447 1
a2447 1
int
d2491 1
a2504 1
	return (success ? 0 : -1);
d2544 1
a2544 1
 * message if there was an error).
d2546 2
a2547 1
int
a2550 1
	int success = 0;
d2570 1
a2570 1
	success = channel_setup_local_fwd_listener(NULL, port, hostname,
a2574 2

	return (success ? 0 : -1);
d2593 1
a2593 1
		fatal("channel_add_permitted_opens: too many forwards");
a2602 13
int
channel_add_adm_permitted_opens(char *host, int port)
{
	if (num_adm_permitted_opens >= SSH_MAX_FORWARDS_PER_DIRECTION)
		fatal("channel_add_adm_permitted_opens: too many forwards");
	debug("config allows port forwarding to host %s port %d", host, port);

	permitted_adm_opens[num_adm_permitted_opens].host_to_connect
	     = xstrdup(host);
	permitted_adm_opens[num_adm_permitted_opens].port_to_connect = port;
	return ++num_adm_permitted_opens;
}

d2612 1
a2614 10
void
channel_clear_adm_permitted_opens(void)
{
	int i;

	for (i = 0; i < num_adm_permitted_opens; i++)
		if (permitted_adm_opens[i].host_to_connect != NULL)
			xfree(permitted_adm_opens[i].host_to_connect);
	num_adm_permitted_opens = 0;
}
d2692 1
a2692 1
	int i, permit, permit_adm = 1;
a2700 1
	}
a2701 8
	if (num_adm_permitted_opens > 0) {
		permit_adm = 0;
		for (i = 0; i < num_adm_permitted_opens; i++)
			if (permitted_adm_opens[i].host_to_connect != NULL &&
			    permitted_adm_opens[i].port_to_connect == port &&
			    strcmp(permitted_adm_opens[i].host_to_connect, host)
			    == 0)
				permit_adm = 1;
d2703 1
a2703 2

	if (!permit || !permit_adm) {
d2724 4
a2727 4
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
d2813 1
a2813 1
	*chanids = xcalloc(num_socks + 1, sizeof(**chanids));
d2842 1
a2842 1
	if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0)
d2852 1
a2852 1
	u_int display_number;
d2857 1
a2857 1
	int gaierr, sock = 0;
d2877 1
a2877 1
		if (sscanf(strrchr(display, ':') + 1, "%u", &display_number) != 1) {
d2902 1
a2902 1
	if (sscanf(cp + 1, "%u", &display_number) != 1) {
d2912 1
a2912 1
	snprintf(strport, sizeof strport, "%u", 6000 + display_number);
d2926 1
a2926 1
			debug2("connect %.100s port %u: %.100s", buf,
d2936 1
a2936 1
		error("connect %.100s port %u: %.100s", buf, 6000 + display_number,
a2949 1
/* ARGSUSED */
a2992 1
/* ARGSUSED */
d3039 3
a3041 1
	cp = strchr(disp, ':');
d3045 1
a3045 1
		screen_number = (u_int)strtonum(cp + 1, 0, 400, NULL);
@


1.222
log
@Fix a number of X11 forwarding channel leaks:
1. Refuse multiple X11 forwarding requests on the same session
2. Clean up all listeners after a single_connection X11 forward, not just
   the one that made the single connection
3. Destroy X11 listeners when the session owning them goes away
testing and ok dtucker@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.221 2005/07/16 01:35:24 djm Exp $");
d732 2
a733 2
			       debug2("channel %d: obuf_empty delayed efd %d/(%d)",
				   c->self, c->efd, buffer_len(&c->extended));
d1810 2
a1811 2
			       debug2("channel %d: ibuf_empty delayed efd %d/(%d)",
				   c->self, c->efd, buffer_len(&c->extended));
@


1.221
log
@spacing
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.220 2005/07/04 14:04:11 markus Exp $");
d2650 1
a2650 1
    int single_connection, u_int *display_numberp)
d2718 2
d2727 2
d2730 2
@


1.220
log
@don't forget to set x11_saved_display
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.219 2005/07/04 00:58:42 djm Exp $");
d2955 1
a2955 1
		 * Extract real authentication data and generate fake data 
@


1.219
log
@implement support for X11 and agent forwarding over multiplex slave
connections. Because of protocol limitations, the slave connections inherit
the master's DISPLAY and SSH_AUTH_SOCK rather than distinctly forwarding
their own.

ok dtucker@@ "put it in" deraadt@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.218 2005/07/01 13:19:47 markus Exp $");
d2933 3
a2935 1
	if (x11_saved_display && strcmp(disp, x11_saved_display) != 0) {
@


1.218
log
@don't free() if getaddrinfo() fails; report mpech@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.217 2005/06/17 02:44:32 djm Exp $");
d114 3
d2927 1
a2927 1
	u_int i, value, len;
d2933 6
d2949 21
a2969 17
	/* Save protocol name. */
	x11_saved_proto = xstrdup(proto);

	/*
	 * Extract real authentication data and generate fake data of the
	 * same length.
	 */
	x11_saved_data = xmalloc(data_len);
	x11_fake_data = xmalloc(data_len);
	for (i = 0; i < data_len; i++) {
		if (sscanf(data + 2 * i, "%2x", &value) != 1)
			fatal("x11_request_forwarding: bad authentication data: %.100s", data);
		if (i % 4 == 0)
			rnd = arc4random();
		x11_saved_data[i] = value;
		x11_fake_data[i] = rnd & 0xff;
		rnd >>= 8;
a2970 2
	x11_saved_data_len = data_len;
	x11_fake_data_len = data_len;
d2973 1
a2973 5
	len = 2 * data_len + 1;
	new_data = xmalloc(len);
	for (i = 0; i < data_len; i++)
		snprintf(new_data + 2 * i, len - 2 * i,
		    "%02x", (u_char) x11_fake_data[i]);
@


1.217
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.216 2005/06/16 08:00:00 markus Exp $");
d2193 1
a2193 1
		return success;
d2197 1
a2197 1
		return success;
d2248 1
a2248 3
			verbose("channel_setup_fwd_listener: "
			    "getaddrinfo(%.64s): %s", addr, gai_strerror(r));
			packet_send_debug("channel_setup_fwd_listener: "
d2251 1
a2251 1
		aitop = NULL;
@


1.216
log
@don't exit if getpeername fails for forwarded ports; bugzilla #1054; ok djm
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.215 2005/06/16 03:38:36 djm Exp $");
d896 1
a896 1
	int len, have, i, found;
d981 1
a981 1
	int i, have, found, nmethods, addrlen, af;
d1077 2
a1078 1
	int have, ret;
@


1.215
log
@move x11_get_proto from ssh.c to clientloop.c, to make muliplexed xfwd easier
later; ok deraadt@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.214 2005/03/14 11:46:56 markus Exp $");
d1180 1
a1180 1
	u_short remote_port = get_peer_port(c->sock);
d1210 1
a1210 1
		packet_put_int(remote_port);
@


1.214
log
@limit input buffer size for channels; bugzilla #896; with and ok dtucker@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.213 2005/03/10 22:01:05 deraadt Exp $");
d2921 1
a2921 1
x11_request_forwarding_with_spoofing(int client_session_id,
d2931 3
a2933 3
	cp = getenv("DISPLAY");
	if (cp)
		cp = strchr(cp, ':');
@


1.214.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.223 2005/07/17 07:17:54 djm Exp $");
a113 3
/* Saved X11 local (client) display. */
static char *x11_saved_display = NULL;

d729 2
a730 2
				debug2("channel %d: obuf_empty delayed efd %d/(%d)",
				    c->self, c->efd, buffer_len(&c->extended));
d896 1
a896 1
	u_int len, have, i, found;
d981 1
a981 1
	u_int have, i, found, nmethods, addrlen, af;
d1077 1
a1077 2
	u_int have;
	int ret;
d1180 1
a1180 1
	int remote_port = get_peer_port(c->sock);
d1210 1
a1210 1
		packet_put_int((u_int)remote_port);
d1806 2
a1807 2
				debug2("channel %d: ibuf_empty delayed efd %d/(%d)",
				    c->self, c->efd, buffer_len(&c->extended));
d2192 1
a2192 1
		return 0;
d2196 1
a2196 1
		return 0;
d2247 3
a2249 1
			error("channel_setup_fwd_listener: "
d2252 1
a2252 1
		return 0;
d2648 1
a2648 1
    int single_connection, u_int *display_numberp, int **chanids)
a2715 2
	if (chanids != NULL)
		*chanids = xmalloc(sizeof(**chanids) * (num_socks + 1));
a2722 2
		if (*chanids != NULL)
			(*chanids)[n] = nc->self;
a2723 2
	if (*chanids != NULL)
		(*chanids)[n] = -1;
d2921 1
a2921 1
x11_request_forwarding_with_spoofing(int client_session_id, const char *disp,
d2925 1
a2925 1
	u_int i, value;
d2931 3
a2933 11
	if (x11_saved_display == NULL)
		x11_saved_display = xstrdup(disp);
	else if (strcmp(disp, x11_saved_display) != 0) {
		error("x11_request_forwarding_with_spoofing: different "
		    "$DISPLAY already forwarded");
		return;
	}

	cp = disp;
	if (disp)
		cp = strchr(disp, ':');
d2941 17
a2957 21
	if (x11_saved_proto == NULL) {
		/* Save protocol name. */
		x11_saved_proto = xstrdup(proto);
		/*
		 * Extract real authentication data and generate fake data
		 * of the same length.
		 */
		x11_saved_data = xmalloc(data_len);
		x11_fake_data = xmalloc(data_len);
		for (i = 0; i < data_len; i++) {
			if (sscanf(data + 2 * i, "%2x", &value) != 1)
				fatal("x11_request_forwarding: bad "
				    "authentication data: %.100s", data);
			if (i % 4 == 0)
				rnd = arc4random();
			x11_saved_data[i] = value;
			x11_fake_data[i] = rnd & 0xff;
			rnd >>= 8;
		}
		x11_saved_data_len = data_len;
		x11_fake_data_len = data_len;
d2959 2
d2963 5
a2967 1
	new_data = tohex(x11_fake_data, data_len);
@


1.214.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.232 2006/01/30 12:22:22 reyk Exp $");
d61 2
d145 1
a145 1
channel_by_id(int id)
d150 1
a150 1
		logit("channel_by_id: %d: bad id", id);
d155 1
a155 1
		logit("channel_by_id: %d: bad id: channel free", id);
a161 28
 * Returns the channel if it is allowed to receive protocol messages.
 * Private channels, like listening sockets, may not receive messages.
 */
Channel *
channel_lookup(int id)
{
	Channel *c;

	if ((c = channel_by_id(id)) == NULL)
		return (NULL);

	switch(c->type) {
	case SSH_CHANNEL_X11_OPEN:
	case SSH_CHANNEL_LARVAL:
	case SSH_CHANNEL_CONNECTING:
	case SSH_CHANNEL_DYNAMIC:
	case SSH_CHANNEL_OPENING:
	case SSH_CHANNEL_OPEN:
	case SSH_CHANNEL_INPUT_DRAINING:
	case SSH_CHANNEL_OUTPUT_DRAINING:
		return (c);
		break;
	}
	logit("Non-public channel %d, type %d.", id, c->type);
	return (NULL);
}

/*
a270 1
	c->detach_close = 0;
a273 1
	c->output_filter = NULL;
d630 1
a630 1
channel_register_cleanup(int id, channel_callback_fn *fn, int do_close)
d632 1
a632 1
	Channel *c = channel_by_id(id);
a638 1
	c->detach_close = do_close;
d643 1
a643 1
	Channel *c = channel_by_id(id);
a649 1
	c->detach_close = 0;
d652 1
a652 2
channel_register_filter(int id, channel_infilter_fn *ifn,
    channel_outfilter_fn *ofn)
d660 1
a660 2
	c->input_filter = ifn;
	c->output_filter = ofn;
a1228 13
static void
channel_set_reuseaddr(int fd)
{
	int on = 1;

	/*
	 * Set socket options.
	 * Allow local port reuse in TIME_WAIT.
	 */
	if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1)
		error("setsockopt SO_REUSEADDR fd %d: %s", fd, strerror(errno));
}

a1399 2
		} else if (c->datagram) {
			buffer_put_string(&c->input, buf, len);
d1410 1
a1410 1
	u_char *data = NULL, *buf;
d1418 3
a1420 34
		if (c->output_filter != NULL) {
			if ((buf = c->output_filter(c, &data, &dlen)) == NULL) {
				debug2("channel %d: filter stops", c->self);
				if (c->type != SSH_CHANNEL_OPEN)
					chan_mark_dead(c);
				else
					chan_write_failed(c);
				return -1;
			}
		} else if (c->datagram) {
			buf = data = buffer_get_string(&c->output, &dlen);
		} else {
			buf = data = buffer_ptr(&c->output);
			dlen = buffer_len(&c->output);
		}

		if (c->datagram) {
			/* ignore truncated writes, datagrams might get lost */
			c->local_consumed += dlen + 4;
			len = write(c->wfd, buf, dlen);
			xfree(data);
			if (len < 0 && (errno == EINTR || errno == EAGAIN))
				return 1;
			if (len <= 0) {
				if (c->type != SSH_CHANNEL_OPEN)
					chan_mark_dead(c);
				else
					chan_write_failed(c);
				return -1;
			}
			return 1;
		}

		len = write(c->wfd, buf, dlen);
d1437 1
a1437 1
		if (compat20 && c->isatty && dlen >= 1 && buf[0] != '\r') {
d1444 1
a1444 1
				 * (4 byte channel id + buf)
d1663 1
a1663 1
		if (!chan_is_dead(c, c->detach_close))
a1772 16
			if (c->datagram) {
				if (len > 0) {
					u_char *data;
					u_int dlen;

					data = buffer_get_string(&c->input,
					    &dlen);
					packet_start(SSH2_MSG_CHANNEL_DATA);
					packet_put_int(c->remote_id);
					packet_put_string(data, dlen);
					packet_send();
					c->remote_window -= dlen + 4;
					xfree(data);
				}
				continue;
			}
d1895 1
a1895 4
	if (c->datagram)
		buffer_put_string(&c->output, data, data_len);
	else
		buffer_append(&c->output, data, data_len);
d2126 3
a2128 2
	if (c == NULL) {
		logit("Received window adjust for non-open channel %d.", id);
d2185 1
a2185 1
	int sock, r, success = 0, wildcard = 0, is_client;
d2272 7
a2278 2

		channel_set_reuseaddr(sock);
d2446 1
a2446 1
	xfree(permitted_opens[i].host_to_connect);
a2658 3
	if (chanids == NULL)
		return -1;

a2681 1
			channel_set_reuseaddr(sock);
d2718 2
a2719 1
	*chanids = xmalloc(sizeof(**chanids) * (num_socks + 1));
d2727 2
a2728 1
		(*chanids)[n] = nc->self;
d2730 2
a2731 1
	(*chanids)[n] = -1;
d2917 1
a2917 1
	error("Warning: this is probably a break-in attempt by a malicious server.");
@


1.213
log
@spacing
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.212 2005/03/01 10:09:52 djm Exp $");
d61 2
d716 3
d1367 1
a1367 1
	char buf[16*1024];
d1456 1
a1456 1
	char buf[16*1024];
@


1.212
log
@bz#413: allow optional specification of bind address for port forwardings.
Patch originally by Dan Astorian, but worked on by several people
Adds GatewayPorts=clientspecified option on server to allow remote forwards
to bind to client-specified ports.

ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.211 2004/10/29 21:47:15 djm Exp $");
d1020 1
a1020 1
	switch(s5_req.atyp){
d2196 5
a2200 5
	 * specified address or wildcard. On the client, a specified bind 
	 * address will always override gateway_ports. On the server, a 
	 * gateway_ports of 1 (``yes'') will override the client's 
	 * specification and force a wildcard bind, whereas a value of 2 
	 * (``clientspecified'') will bind to whatever address the client 
d2310 1
a2310 1
	for(i = 0; i < channels_alloc; i++) {
d2620 1
a2620 1
		if (channels[i] == NULL || !channels[i]->client_tty || 
@


1.211
log
@fix some window size change bugs for multiplexed connections: windows sizes
were not being updated if they had changed after ~^Z suspends and SIGWINCH
was not being processed unless the first connection had requested a tty;
ok markus
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.210 2004/08/23 11:48:47 djm Exp $");
d2176 1
a2176 1
	int success, sock, on = 1;
d2178 1
a2178 1
	const char *host;
a2180 1
	success = 0;
d2183 1
d2195 33
d2233 1
a2233 1
	hints.ai_flags = gateway_ports ? AI_PASSIVE : 0;
d2236 13
a2248 2
	if (getaddrinfo(NULL, strport, &hints, &aitop) != 0)
		packet_disconnect("getaddrinfo: fatal error");
d2327 1
a2327 1
channel_setup_local_fwd_listener(u_short listen_port,
d2331 2
a2332 1
	    NULL, listen_port, host_to_connect, port_to_connect, gateway_ports);
d2350 1
a2350 1
channel_request_remote_forwarding(u_short listen_port,
d2361 8
a2368 1
		const char *address_to_bind = "0.0.0.0";
d2414 1
a2414 1
channel_request_rforward_cancel(u_short port)
a2416 1
	const char *address_to_bind = "0.0.0.0";
d2433 1
a2433 1
	packet_put_cstring(address_to_bind);
d2472 2
a2473 1
	channel_setup_local_fwd_listener(port, hostname, host_port, gateway_ports);
@


1.210
log
@typo, spotted by Martin.Kraemer AT Fujitsu-Siemens.com; ok markus
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.209 2004/08/11 21:43:04 avsm Exp $");
d2568 1
a2568 1
		if (channels[i] == NULL ||
@


1.210.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.212 2005/03/01 10:09:52 djm Exp $");
d2176 1
a2176 1
	int sock, r, success = 0, on = 1, wildcard = 0, is_client;
d2178 1
a2178 1
	const char *host, *addr;
d2181 1
a2183 1
	is_client = (type == SSH_CHANNEL_PORT_LISTENER);
a2194 33
	 * Determine whether or not a port forward listens to loopback,
	 * specified address or wildcard. On the client, a specified bind 
	 * address will always override gateway_ports. On the server, a 
	 * gateway_ports of 1 (``yes'') will override the client's 
	 * specification and force a wildcard bind, whereas a value of 2 
	 * (``clientspecified'') will bind to whatever address the client 
	 * asked for.
	 *
	 * Special-case listen_addrs are:
	 *
	 * "0.0.0.0"               -> wildcard v4/v6 if SSH_OLD_FORWARD_ADDR
	 * "" (empty string), "*"  -> wildcard v4/v6
	 * "localhost"             -> loopback v4/v6
	 */
	addr = NULL;
	if (listen_addr == NULL) {
		/* No address specified: default to gateway_ports setting */
		if (gateway_ports)
			wildcard = 1;
	} else if (gateway_ports || is_client) {
		if (((datafellows & SSH_OLD_FORWARD_ADDR) &&
		    strcmp(listen_addr, "0.0.0.0") == 0) ||
		    *listen_addr == '\0' || strcmp(listen_addr, "*") == 0 ||
		    (!is_client && gateway_ports == 1))
			wildcard = 1;
		else if (strcmp(listen_addr, "localhost") != 0)
			addr = listen_addr;
	}

	debug3("channel_setup_fwd_listener: type %d wildcard %d addr %s",
	    type, wildcard, (addr == NULL) ? "NULL" : addr);

	/*
d2200 1
a2200 1
	hints.ai_flags = wildcard ? AI_PASSIVE : 0;
d2203 2
a2204 13
	if ((r = getaddrinfo(addr, strport, &hints, &aitop)) != 0) {
		if (addr == NULL) {
			/* This really shouldn't happen */
			packet_disconnect("getaddrinfo: fatal error: %s",
			    gai_strerror(r));
		} else {
			verbose("channel_setup_fwd_listener: "
			    "getaddrinfo(%.64s): %s", addr, gai_strerror(r));
			packet_send_debug("channel_setup_fwd_listener: "
			    "getaddrinfo(%.64s): %s", addr, gai_strerror(r));
		}
		aitop = NULL;
	}
d2283 1
a2283 1
channel_setup_local_fwd_listener(const char *listen_host, u_short listen_port,
d2287 1
a2287 2
	    listen_host, listen_port, host_to_connect, port_to_connect,
	    gateway_ports);
d2305 1
a2305 1
channel_request_remote_forwarding(const char *listen_host, u_short listen_port,
d2316 1
a2316 8
		const char *address_to_bind;
		if (listen_host == NULL)
			address_to_bind = "localhost";
		else if (*listen_host == '\0' || strcmp(listen_host, "*") == 0)
			address_to_bind = "";
		else
			address_to_bind = listen_host;

d2362 1
a2362 1
channel_request_rforward_cancel(const char *host, u_short port)
d2365 1
d2382 1
a2382 1
	packet_put_cstring(host == NULL ? "" : host);
d2421 1
a2421 2
	channel_setup_local_fwd_listener(NULL, port, hostname,
	    host_port, gateway_ports);
d2568 1
a2568 1
		if (channels[i] == NULL || !channels[i]->client_tty || 
@


1.210.2.2
log
@upgrade to OpenSSH 4.1
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.214 2005/03/14 11:46:56 markus Exp $");
a60 2
#define CHAN_RBUF	16*1024

a713 3
	/* check buffer limits */
	limit = MIN(limit, (BUFFER_MAX_LEN - BUFFER_MAX_CHUNK - CHAN_RBUF));

d1020 1
a1020 1
	switch (s5_req.atyp){
d1362 1
a1362 1
	char buf[CHAN_RBUF];
d1451 1
a1451 1
	char buf[CHAN_RBUF];
d2196 5
a2200 5
	 * specified address or wildcard. On the client, a specified bind
	 * address will always override gateway_ports. On the server, a
	 * gateway_ports of 1 (``yes'') will override the client's
	 * specification and force a wildcard bind, whereas a value of 2
	 * (``clientspecified'') will bind to whatever address the client
d2310 1
a2310 1
	for (i = 0; i < channels_alloc; i++) {
d2620 1
a2620 1
		if (channels[i] == NULL || !channels[i]->client_tty ||
@


1.210.2.3
log
@upgrade to OpenSSH 4.2
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.223 2005/07/17 07:17:54 djm Exp $");
a113 3
/* Saved X11 local (client) display. */
static char *x11_saved_display = NULL;

d729 2
a730 2
				debug2("channel %d: obuf_empty delayed efd %d/(%d)",
				    c->self, c->efd, buffer_len(&c->extended));
d896 1
a896 1
	u_int len, have, i, found;
d981 1
a981 1
	u_int have, i, found, nmethods, addrlen, af;
d1077 1
a1077 2
	u_int have;
	int ret;
d1180 1
a1180 1
	int remote_port = get_peer_port(c->sock);
d1210 1
a1210 1
		packet_put_int((u_int)remote_port);
d1806 2
a1807 2
				debug2("channel %d: ibuf_empty delayed efd %d/(%d)",
				    c->self, c->efd, buffer_len(&c->extended));
d2192 1
a2192 1
		return 0;
d2196 1
a2196 1
		return 0;
d2247 3
a2249 1
			error("channel_setup_fwd_listener: "
d2252 1
a2252 1
		return 0;
d2648 1
a2648 1
    int single_connection, u_int *display_numberp, int **chanids)
a2715 2
	if (chanids != NULL)
		*chanids = xmalloc(sizeof(**chanids) * (num_socks + 1));
a2722 2
		if (*chanids != NULL)
			(*chanids)[n] = nc->self;
a2723 2
	if (*chanids != NULL)
		(*chanids)[n] = -1;
d2921 1
a2921 1
x11_request_forwarding_with_spoofing(int client_session_id, const char *disp,
d2925 1
a2925 1
	u_int i, value;
d2931 3
a2933 11
	if (x11_saved_display == NULL)
		x11_saved_display = xstrdup(disp);
	else if (strcmp(disp, x11_saved_display) != 0) {
		error("x11_request_forwarding_with_spoofing: different "
		    "$DISPLAY already forwarded");
		return;
	}

	cp = disp;
	if (disp)
		cp = strchr(disp, ':');
d2941 17
a2957 21
	if (x11_saved_proto == NULL) {
		/* Save protocol name. */
		x11_saved_proto = xstrdup(proto);
		/*
		 * Extract real authentication data and generate fake data
		 * of the same length.
		 */
		x11_saved_data = xmalloc(data_len);
		x11_fake_data = xmalloc(data_len);
		for (i = 0; i < data_len; i++) {
			if (sscanf(data + 2 * i, "%2x", &value) != 1)
				fatal("x11_request_forwarding: bad "
				    "authentication data: %.100s", data);
			if (i % 4 == 0)
				rnd = arc4random();
			x11_saved_data[i] = value;
			x11_fake_data[i] = rnd & 0xff;
			rnd >>= 8;
		}
		x11_saved_data_len = data_len;
		x11_fake_data_len = data_len;
d2959 2
d2963 5
a2967 1
	new_data = tohex(x11_fake_data, data_len);
@


1.209
log
@some signed/unsigned int comparison cleanups; markus@@ ok
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.208 2004/07/11 17:48:47 deraadt Exp $");
d2272 1
a2272 1
			debug2("%s: close clannel %d", __func__, i);
@


1.208
log
@spaces
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.207 2004/06/21 17:36:31 avsm Exp $");
d71 1
a71 1
static int channels_alloc = 0;
d144 1
a144 1
	if (id < 0 || id >= channels_alloc) {
d211 2
a212 1
	int i, found;
d226 1
a226 1
			found = i;
d229 1
a229 1
	if (found == -1) {
d276 2
a277 1
	int i, max = 0;
d326 1
a326 1
	int i, n;
d331 1
a331 1
	debug("channel %d: free: %s, nchannels %d", c->self,
d357 1
a357 1
	int i;
d372 1
a372 1
	int i;
d386 1
a386 1
	int i;
d443 1
a443 1
	int i;
d486 1
a486 1
	int i;
d534 1
a534 1
	int i;
d1673 1
a1673 1
	int i;
d1696 1
a1696 1
    int *nallocp, int rekeying)
d1698 1
a1698 2
	int n;
	u_int sz;
d1734 1
a1734 2
	int i;
	u_int len;
d2263 2
a2264 1
	int i, found = 0;
d2564 1
a2564 1
	int i;
@


1.207
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.206 2004/06/18 11:11:54 djm Exp $");
d739 1
a739 1
	if (compat20 && c->ctl_fd != -1 && 
d2270 1
a2270 1
	    	    c->listening_port == port) {
d2357 1
a2357 1
 * Request cancellation of remote forwarding of connection host:port from 
a2359 1

d2370 1
a2370 1
		if (permitted_opens[i].host_to_connect != NULL && 
@


1.206
log
@clientloop.c
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.205 2004/06/14 01:44:38 djm Exp $");
d2872 1
a2872 1
	u_int32_t rand = 0;
d2897 1
a2897 1
			rand = arc4random();
d2899 2
a2900 2
		x11_fake_data[i] = rand & 0xff;
		rand >>= 8;
@


1.205
log
@set_nonblock() instead of fnctl(...,O_NONBLOCK); "looks sane" deraadt@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.204 2004/06/13 15:03:02 djm Exp $");
d489 1
a489 1
		if (c == NULL)
@


1.204
log
@implement session multiplexing in the client (the server has supported this
since 2.0); ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.203 2004/05/26 23:02:39 markus Exp $");
d2500 2
a2501 2
		if (fcntl(sock, F_SETFL, O_NONBLOCK) < 0)
			fatal("connect_to: F_SETFL: %s", strerror(errno));
@


1.203
log
@missing freeaddrinfo; Andrey Matveev
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.202 2004/05/21 11:33:11 djm Exp $");
d175 1
d266 1
d308 2
a309 2
	debug3("channel %d: close_fds r %d w %d e %d",
	    c->self, c->rfd, c->wfd, c->efd);
d312 1
d338 2
d557 2
a558 1
			snprintf(buf, sizeof buf, "  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n",
d563 1
a563 1
			    c->rfd, c->wfd);
d604 1
a604 1
	debug2("channel %d: request %s", id, service) ;
d611 1
a611 1
channel_register_confirm(int id, channel_callback_fn *fn)
d620 1
d738 4
d1490 27
d1546 1
d2047 1
a2047 1
			c->confirm(c->self, NULL);
d2559 21
@


1.202
log
@bz #756: add support for the cancel-tcpip-forward request for the server and
the client (through the ~C commandline). reported by z3p AT twistedmatrix.com;
ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.201 2004/05/11 19:01:43 deraadt Exp $");
d2560 1
@


1.201
log
@improve some code lint did not like; djm millert ok
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.200 2004/01/19 09:24:21 markus Exp $");
d2221 20
d2318 36
d2420 2
a2421 1
		xfree(permitted_opens[i].host_to_connect);
d2489 2
a2490 1
		if (permitted_opens[i].listen_port == listen_port)
d2508 2
a2509 1
			if (permitted_opens[i].port_to_connect == port &&
@


1.200
log
@fake consumption for half closed channels since the peer is waiting for
window adjust messages; bugzilla #790 Matthew Dillon; test + ok dtucker@@
reproduce with sh -c 'ulimit -f 10; ssh host -n od /bsd | cat > foo'
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.199 2003/12/02 17:01:14 markus Exp $");
d1033 1
a1033 1
		strlcpy(c->path, dest_addr, sizeof(c->path));
@


1.200.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.209 2004/08/11 21:43:04 avsm Exp $");
d71 1
a71 1
static u_int channels_alloc = 0;
d144 1
a144 1
	if (id < 0 || (u_int)id >= channels_alloc) {
a174 1
	c->ctl_fd = -1; /* XXX: set elsewhere */
d210 1
a210 2
	int found;
	u_int i;
d224 1
a224 1
			found = (int)i;
d227 1
a227 1
	if (found < 0) {
a264 1
	c->confirm_ctx = NULL;
d273 1
a273 2
	u_int i;
	int max = 0;
d306 2
a307 2
	debug3("channel %d: close_fds r %d w %d e %d c %d",
	    c->self, c->rfd, c->wfd, c->efd, c->ctl_fd);
a309 1
	channel_close_fd(&c->ctl_fd);
d321 1
a321 1
	u_int i, n;
d326 1
a326 1
	debug("channel %d: free: %s, nchannels %u", c->self,
a334 2
	if (c->ctl_fd != -1)
		shutdown(c->ctl_fd, SHUT_RDWR);
d350 1
a350 1
	u_int i;
d365 1
a365 1
	u_int i;
d379 1
a379 1
	u_int i;
d436 1
a436 1
	u_int i;
d479 1
a479 1
	u_int i;
d484 1
a484 1
		if (c == NULL || c->remote_id < 0)
d527 1
a527 1
	u_int i;
d552 1
a552 2
			snprintf(buf, sizeof buf,
			    "  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d cfd %d)\r\n",
d557 1
a557 1
			    c->rfd, c->wfd, c->ctl_fd);
d598 1
a598 1
	debug2("channel %d: request %s confirm %d", id, service, wantconfirm);
d605 1
a605 1
channel_register_confirm(int id, channel_callback_fn *fn, void *ctx)
a613 1
	c->confirm_ctx = ctx;
a730 4
	/* XXX: What about efd? races? */
	if (compat20 && c->ctl_fd != -1 &&
	    c->istate == CHAN_INPUT_OPEN && c->ostate == CHAN_OUTPUT_OPEN)
		FD_SET(c->ctl_fd, readset);
d1033 1
a1033 1
		strlcpy(c->path, (char *)dest_addr, sizeof(c->path));
a1478 27
channel_handle_ctl(Channel *c, fd_set * readset, fd_set * writeset)
{
	char buf[16];
	int len;

	/* Monitor control fd to detect if the slave client exits */
	if (c->ctl_fd != -1 && FD_ISSET(c->ctl_fd, readset)) {
		len = read(c->ctl_fd, buf, sizeof(buf));
		if (len < 0 && (errno == EINTR || errno == EAGAIN))
			return 1;
		if (len <= 0) {
			debug2("channel %d: ctl read<=0", c->self);
			if (c->type != SSH_CHANNEL_OPEN) {
				debug2("channel %d: not open", c->self);
				chan_mark_dead(c);
				return -1;
			} else {
				chan_read_failed(c);
				chan_write_failed(c);
			}
			return -1;
		} else
			fatal("%s: unexpected data on ctl fd", __func__);
	}
	return 1;
}
static int
a1507 1
	channel_handle_ctl(c, readset, writeset);
d1632 1
a1632 1
	u_int i;
d1655 1
a1655 1
    u_int *nallocp, int rekeying)
d1657 2
a1658 1
	u_int n, sz;
d1694 2
a1695 1
	u_int i, len;
d2008 1
a2008 1
			c->confirm(c->self, c->confirm_ctx);
a2220 21
int
channel_cancel_rport_listener(const char *host, u_short port)
{
	u_int i;
	int found = 0;

	for(i = 0; i < channels_alloc; i++) {
		Channel *c = channels[i];

		if (c != NULL && c->type == SSH_CHANNEL_RPORT_LISTENER &&
		    strncmp(c->path, host, sizeof(c->path)) == 0 &&
		    c->listening_port == port) {
			debug2("%s: close clannel %d", __func__, i);
			channel_free(c);
			found = 1;
		}
	}

	return (found);
}

a2297 35
 * Request cancellation of remote forwarding of connection host:port from
 * local side.
 */
void
channel_request_rforward_cancel(u_short port)
{
	int i;
	const char *address_to_bind = "0.0.0.0";

	if (!compat20)
		return;

	for (i = 0; i < num_permitted_opens; i++) {
		if (permitted_opens[i].host_to_connect != NULL &&
		    permitted_opens[i].listen_port == port)
			break;
	}
	if (i >= num_permitted_opens) {
		debug("%s: requested forward not found", __func__);
		return;
	}
	packet_start(SSH2_MSG_GLOBAL_REQUEST);
	packet_put_cstring("cancel-tcpip-forward");
	packet_put_char(0);
	packet_put_cstring(address_to_bind);
	packet_put_int(port);
	packet_send();

	permitted_opens[i].listen_port = 0;
	permitted_opens[i].port_to_connect = 0;
	free(permitted_opens[i].host_to_connect);
	permitted_opens[i].host_to_connect = NULL;
}

/*
d2364 1
a2364 2
		if (permitted_opens[i].host_to_connect != NULL)
			xfree(permitted_opens[i].host_to_connect);
d2404 2
a2405 2
		if (set_nonblock(sock) == -1)
			fatal("%s: set_nonblock(%d)", __func__, sock);
d2432 1
a2432 2
		if (permitted_opens[i].host_to_connect != NULL &&
		    permitted_opens[i].listen_port == listen_port)
d2450 1
a2450 2
			if (permitted_opens[i].host_to_connect != NULL &&
			    permitted_opens[i].port_to_connect == port &&
a2462 21
void
channel_send_window_changes(void)
{
	u_int i;
	struct winsize ws;

	for (i = 0; i < channels_alloc; i++) {
		if (channels[i] == NULL ||
		    channels[i]->type != SSH_CHANNEL_OPEN)
			continue;
		if (ioctl(channels[i]->rfd, TIOCGWINSZ, &ws) < 0)
			continue;
		channel_request_start(i, "window-change", 0);
		packet_put_int(ws.ws_col);
		packet_put_int(ws.ws_row);
		packet_put_int(ws.ws_xpixel);
		packet_put_int(ws.ws_ypixel);
		packet_send();
	}
}

a2500 1
				freeaddrinfo(aitop);
d2752 1
a2752 1
	u_int32_t rnd = 0;
d2777 1
a2777 1
			rnd = arc4random();
d2779 2
a2780 2
		x11_fake_data[i] = rnd & 0xff;
		rnd >>= 8;
@


1.200.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.212 2005/03/01 10:09:52 djm Exp $");
d2176 1
a2176 1
	int sock, r, success = 0, on = 1, wildcard = 0, is_client;
d2178 1
a2178 1
	const char *host, *addr;
d2181 1
a2183 1
	is_client = (type == SSH_CHANNEL_PORT_LISTENER);
a2194 33
	 * Determine whether or not a port forward listens to loopback,
	 * specified address or wildcard. On the client, a specified bind 
	 * address will always override gateway_ports. On the server, a 
	 * gateway_ports of 1 (``yes'') will override the client's 
	 * specification and force a wildcard bind, whereas a value of 2 
	 * (``clientspecified'') will bind to whatever address the client 
	 * asked for.
	 *
	 * Special-case listen_addrs are:
	 *
	 * "0.0.0.0"               -> wildcard v4/v6 if SSH_OLD_FORWARD_ADDR
	 * "" (empty string), "*"  -> wildcard v4/v6
	 * "localhost"             -> loopback v4/v6
	 */
	addr = NULL;
	if (listen_addr == NULL) {
		/* No address specified: default to gateway_ports setting */
		if (gateway_ports)
			wildcard = 1;
	} else if (gateway_ports || is_client) {
		if (((datafellows & SSH_OLD_FORWARD_ADDR) &&
		    strcmp(listen_addr, "0.0.0.0") == 0) ||
		    *listen_addr == '\0' || strcmp(listen_addr, "*") == 0 ||
		    (!is_client && gateway_ports == 1))
			wildcard = 1;
		else if (strcmp(listen_addr, "localhost") != 0)
			addr = listen_addr;
	}

	debug3("channel_setup_fwd_listener: type %d wildcard %d addr %s",
	    type, wildcard, (addr == NULL) ? "NULL" : addr);

	/*
d2200 1
a2200 1
	hints.ai_flags = wildcard ? AI_PASSIVE : 0;
d2203 2
a2204 13
	if ((r = getaddrinfo(addr, strport, &hints, &aitop)) != 0) {
		if (addr == NULL) {
			/* This really shouldn't happen */
			packet_disconnect("getaddrinfo: fatal error: %s",
			    gai_strerror(r));
		} else {
			verbose("channel_setup_fwd_listener: "
			    "getaddrinfo(%.64s): %s", addr, gai_strerror(r));
			packet_send_debug("channel_setup_fwd_listener: "
			    "getaddrinfo(%.64s): %s", addr, gai_strerror(r));
		}
		aitop = NULL;
	}
d2272 1
a2272 1
			debug2("%s: close channel %d", __func__, i);
d2283 1
a2283 1
channel_setup_local_fwd_listener(const char *listen_host, u_short listen_port,
d2287 1
a2287 2
	    listen_host, listen_port, host_to_connect, port_to_connect,
	    gateway_ports);
d2305 1
a2305 1
channel_request_remote_forwarding(const char *listen_host, u_short listen_port,
d2316 1
a2316 8
		const char *address_to_bind;
		if (listen_host == NULL)
			address_to_bind = "localhost";
		else if (*listen_host == '\0' || strcmp(listen_host, "*") == 0)
			address_to_bind = "";
		else
			address_to_bind = listen_host;

d2362 1
a2362 1
channel_request_rforward_cancel(const char *host, u_short port)
d2365 1
d2382 1
a2382 1
	packet_put_cstring(host == NULL ? "" : host);
d2421 1
a2421 2
	channel_setup_local_fwd_listener(NULL, port, hostname,
	    host_port, gateway_ports);
d2568 1
a2568 1
		if (channels[i] == NULL || !channels[i]->client_tty || 
@


1.199
log
@use SSH_LISTEN_BACKLOG (=128) in listen(2).
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.198 2003/11/21 11:57:03 djm Exp $");
a1813 4
	/* same for protocol 1.5 if output end is no longer open */
	if (!compat13 && c->ostate != CHAN_OUTPUT_OPEN)
		return;

d1816 16
@


1.198
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.197 2003/09/23 20:41:11 markus Exp $");
d2188 1
a2188 1
		if (listen(sock, 5) < 0) {
d2519 1
a2519 1
		if (listen(sock, 5) < 0) {
@


1.197
log
@move client only agent code to clientloop.c
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.196 2003/09/19 11:31:33 markus Exp $");
d972 1
a972 1
		if (have < 2) 
d1037 1
a1037 1
	
@


1.196
log
@do not call channel_free_all on fatal; ok deraadt
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.195 2003/09/16 21:02:40 markus Exp $");
a2805 43
}

/* This is called to process an SSH_SMSG_AGENT_OPEN message. */

void
auth_input_open_request(int type, u_int32_t seq, void *ctxt)
{
	Channel *c = NULL;
	int remote_id, sock;

	/* Read the remote channel number from the message. */
	remote_id = packet_get_int();
	packet_check_eom();

	/*
	 * Get a connection to the local authentication agent (this may again
	 * get forwarded).
	 */
	sock = ssh_get_authentication_socket();

	/*
	 * If we could not connect the agent, send an error message back to
	 * the server. This should never happen unless the agent dies,
	 * because authentication forwarding is only enabled if we have an
	 * agent.
	 */
	if (sock >= 0) {
		c = channel_new("", SSH_CHANNEL_OPEN, sock, sock,
		    -1, 0, 0, 0, "authentication agent connection", 1);
		c->remote_id = remote_id;
		c->force_drain = 1;
	}
	if (c == NULL) {
		packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(remote_id);
	} else {
		/* Send a confirmation to the remote host. */
		debug("Forwarding authentication connection.");
		packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
		packet_put_int(remote_id);
		packet_put_int(c->self);
	}
	packet_send();
@


1.195
log
@more malloc/fatal fixes; ok millert/deraadt; ghudson at MIT.EDU
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.194 2003/08/29 10:04:36 markus Exp $");
a218 1
		fatal_add_cleanup((void (*) (void *)) channel_free_all, NULL);
@


1.195.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.200 2004/01/19 09:24:21 markus Exp $");
d219 1
d973 1
a973 1
		if (have < 2)
d1038 1
a1038 1

d1815 4
a1821 16
	/*
	 * Ignore data for protocol > 1.3 if output end is no longer open.
	 * For protocol 2 the sending side is reducing its window as it sends
	 * data, so we must 'fake' consumption of the data in order to ensure
	 * that window updates are sent back.  Otherwise the connection might
	 * deadlock.
	 */
	if (!compat13 && c->ostate != CHAN_OUTPUT_OPEN) {
		if (compat20) {
			c->local_window -= data_len;
			c->local_consumed += data_len;
		}
		xfree(data);
		return;
	}

d2189 1
a2189 1
		if (listen(sock, SSH_LISTEN_BACKLOG) < 0) {
d2520 1
a2520 1
		if (listen(sock, SSH_LISTEN_BACKLOG) < 0) {
d2807 43
@


1.195.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.209 2004/08/11 21:43:04 avsm Exp $");
d71 1
a71 1
static u_int channels_alloc = 0;
d144 1
a144 1
	if (id < 0 || (u_int)id >= channels_alloc) {
a174 1
	c->ctl_fd = -1; /* XXX: set elsewhere */
d210 1
a210 2
	int found;
	u_int i;
d224 1
a224 1
			found = (int)i;
d227 1
a227 1
	if (found < 0) {
a264 1
	c->confirm_ctx = NULL;
d273 1
a273 2
	u_int i;
	int max = 0;
d306 2
a307 2
	debug3("channel %d: close_fds r %d w %d e %d c %d",
	    c->self, c->rfd, c->wfd, c->efd, c->ctl_fd);
a309 1
	channel_close_fd(&c->ctl_fd);
d321 1
a321 1
	u_int i, n;
d326 1
a326 1
	debug("channel %d: free: %s, nchannels %u", c->self,
a334 2
	if (c->ctl_fd != -1)
		shutdown(c->ctl_fd, SHUT_RDWR);
d350 1
a350 1
	u_int i;
d365 1
a365 1
	u_int i;
d379 1
a379 1
	u_int i;
d436 1
a436 1
	u_int i;
d479 1
a479 1
	u_int i;
d484 1
a484 1
		if (c == NULL || c->remote_id < 0)
d527 1
a527 1
	u_int i;
d552 1
a552 2
			snprintf(buf, sizeof buf,
			    "  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d cfd %d)\r\n",
d557 1
a557 1
			    c->rfd, c->wfd, c->ctl_fd);
d598 1
a598 1
	debug2("channel %d: request %s confirm %d", id, service, wantconfirm);
d605 1
a605 1
channel_register_confirm(int id, channel_callback_fn *fn, void *ctx)
a613 1
	c->confirm_ctx = ctx;
a730 4
	/* XXX: What about efd? races? */
	if (compat20 && c->ctl_fd != -1 &&
	    c->istate == CHAN_INPUT_OPEN && c->ostate == CHAN_OUTPUT_OPEN)
		FD_SET(c->ctl_fd, readset);
d1033 1
a1033 1
		strlcpy(c->path, (char *)dest_addr, sizeof(c->path));
a1478 27
channel_handle_ctl(Channel *c, fd_set * readset, fd_set * writeset)
{
	char buf[16];
	int len;

	/* Monitor control fd to detect if the slave client exits */
	if (c->ctl_fd != -1 && FD_ISSET(c->ctl_fd, readset)) {
		len = read(c->ctl_fd, buf, sizeof(buf));
		if (len < 0 && (errno == EINTR || errno == EAGAIN))
			return 1;
		if (len <= 0) {
			debug2("channel %d: ctl read<=0", c->self);
			if (c->type != SSH_CHANNEL_OPEN) {
				debug2("channel %d: not open", c->self);
				chan_mark_dead(c);
				return -1;
			} else {
				chan_read_failed(c);
				chan_write_failed(c);
			}
			return -1;
		} else
			fatal("%s: unexpected data on ctl fd", __func__);
	}
	return 1;
}
static int
a1507 1
	channel_handle_ctl(c, readset, writeset);
d1632 1
a1632 1
	u_int i;
d1655 1
a1655 1
    u_int *nallocp, int rekeying)
d1657 2
a1658 1
	u_int n, sz;
d1694 2
a1695 1
	u_int i, len;
d2008 1
a2008 1
			c->confirm(c->self, c->confirm_ctx);
a2220 21
int
channel_cancel_rport_listener(const char *host, u_short port)
{
	u_int i;
	int found = 0;

	for(i = 0; i < channels_alloc; i++) {
		Channel *c = channels[i];

		if (c != NULL && c->type == SSH_CHANNEL_RPORT_LISTENER &&
		    strncmp(c->path, host, sizeof(c->path)) == 0 &&
		    c->listening_port == port) {
			debug2("%s: close clannel %d", __func__, i);
			channel_free(c);
			found = 1;
		}
	}

	return (found);
}

a2297 35
 * Request cancellation of remote forwarding of connection host:port from
 * local side.
 */
void
channel_request_rforward_cancel(u_short port)
{
	int i;
	const char *address_to_bind = "0.0.0.0";

	if (!compat20)
		return;

	for (i = 0; i < num_permitted_opens; i++) {
		if (permitted_opens[i].host_to_connect != NULL &&
		    permitted_opens[i].listen_port == port)
			break;
	}
	if (i >= num_permitted_opens) {
		debug("%s: requested forward not found", __func__);
		return;
	}
	packet_start(SSH2_MSG_GLOBAL_REQUEST);
	packet_put_cstring("cancel-tcpip-forward");
	packet_put_char(0);
	packet_put_cstring(address_to_bind);
	packet_put_int(port);
	packet_send();

	permitted_opens[i].listen_port = 0;
	permitted_opens[i].port_to_connect = 0;
	free(permitted_opens[i].host_to_connect);
	permitted_opens[i].host_to_connect = NULL;
}

/*
d2364 1
a2364 2
		if (permitted_opens[i].host_to_connect != NULL)
			xfree(permitted_opens[i].host_to_connect);
d2404 2
a2405 2
		if (set_nonblock(sock) == -1)
			fatal("%s: set_nonblock(%d)", __func__, sock);
d2432 1
a2432 2
		if (permitted_opens[i].host_to_connect != NULL &&
		    permitted_opens[i].listen_port == listen_port)
d2450 1
a2450 2
			if (permitted_opens[i].host_to_connect != NULL &&
			    permitted_opens[i].port_to_connect == port &&
a2462 21
void
channel_send_window_changes(void)
{
	u_int i;
	struct winsize ws;

	for (i = 0; i < channels_alloc; i++) {
		if (channels[i] == NULL ||
		    channels[i]->type != SSH_CHANNEL_OPEN)
			continue;
		if (ioctl(channels[i]->rfd, TIOCGWINSZ, &ws) < 0)
			continue;
		channel_request_start(i, "window-change", 0);
		packet_put_int(ws.ws_col);
		packet_put_int(ws.ws_row);
		packet_put_int(ws.ws_xpixel);
		packet_put_int(ws.ws_ypixel);
		packet_send();
	}
}

a2500 1
				freeaddrinfo(aitop);
d2752 1
a2752 1
	u_int32_t rnd = 0;
d2777 1
a2777 1
			rnd = arc4random();
d2779 2
a2780 2
		x11_fake_data[i] = rnd & 0xff;
		rnd >>= 8;
@


1.194
log
@be less chatty; debug -> debug2, cleanup; ok henning@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.193 2003/07/02 14:51:16 markus Exp $");
a230 1
		channels_alloc += 10;
d234 3
a237 1
		channels = xrealloc(channels, channels_alloc * sizeof(Channel *));
@


1.193
log
@(re)add socks5 suppport to -D; ok djm@@
now ssh(1) can act both as a socks 4 and socks 5 server and
dynamically forward ports.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.192 2003/07/02 12:56:34 markus Exp $");
d180 1
a180 1
		debug("channel %d: rfd %d isatty", c->self, c->rfd);
d306 1
a306 1
	debug3("channel_close_fds: channel %d: r %d w %d e %d",
d326 1
a326 1
	debug("channel_free: channel %d: %s, nchannels %d", c->self,
d330 1
a330 1
	debug3("channel_free: status: %s", s);
d598 1
a598 1
	debug("channel %d: request %s", id, service) ;
d741 1
a741 1
		debug("channel %d: closing after input drain.", c->self);
d782 1
a782 1
		debug("Initial X11 packet contains bad byte order byte: 0x%x",
d795 1
a795 1
		debug("X11 connection uses different authentication protocol.");
d802 1
a802 1
		debug("X11 auth data does not match fake data.");
d859 1
a859 1
		debug("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
d869 1
a869 1
		debug("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
d927 1
a927 1
	debug("channel %d: dynamic request: socks4 host %s port %u command %u",
d1004 1
a1004 1
		debug("channel %d: only socks5 connect supported", c->self);
d1021 1
a1021 1
		debug("channel %d: bad socks5 atyp %d", c->self, s5_req.atyp);
d1038 1
a1038 1
	debug("channel %d: dynamic request: socks5 host %s port %u command %u",
d1113 1
a1113 1
			debug("single_connection: closing X11 listener.");
d1139 1
a1139 1
				debug("ssh2 x11 bug compat mode");
d1358 1
a1358 1
			debug("channel %d: read<=0 rfd %d len %d",
d1361 1
a1361 1
				debug("channel %d: not open", c->self);
d1367 1
a1367 1
				debug("channel %d: input draining.", c->self);
d1375 1
a1375 1
				debug("channel %d: filter stops", c->self);
d1403 1
a1403 1
				debug("channel %d: not open", c->self);
d1408 1
a1408 1
				debug("channel %d: input draining.", c->self);
d1615 1
a1615 1
		debug("channel %d: gc: notify user", c->self);
d1620 1
a1620 1
		debug("channel %d: gc: user detached", c->self);
d1624 1
a1624 1
	debug("channel %d: garbage collecting", c->self);
d1999 1
a1999 1
		debug("channel %d: open confirm rwindow %u rmax %u", c->self,
d2492 1
a2492 1
				debug("bind port %d: %.100s", port, strerror(errno));
d2632 1
a2632 1
			debug("socket: %.100s", strerror(errno));
d2637 1
a2637 1
			debug("connect %.100s port %d: %.100s", buf,
@


1.192
log
@deny dynamic forwarding with -R for v1, too; ok djm@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.191 2003/06/24 08:23:46 markus Exp $");
d57 1
a57 1

d943 111
d1066 1
a1066 1
	if (have < 4) {
d1076 3
@


1.191
log
@int -> u_int; ok djm@@, deraadt@@, mouring@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.190 2003/05/11 20:30:24 markus Exp $");
d2193 6
a2198 2
		packet_disconnect("Requested forwarding of port %d but user is not root.",
				  port);
@


1.190
log
@make channel_new() strdup the 'remote_name' (not the caller); ok theo
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.189 2003/04/14 14:17:50 markus Exp $");
d421 1
a421 1
				debug2("channel %d: big output buffer %d > %d",
@


1.189
log
@avoid hardcoded SOCK_xx; with itojun@@; should allow ssh over SCTP
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.188 2003/04/08 20:21:28 itojun Exp $");
d258 1
a258 1
	c->remote_name = remote_name;
d1015 1
a1015 2
		    c->local_window_max, c->local_maxpacket,
		    0, xstrdup(buf), 1);
d1130 2
a1131 4
		nc = channel_new(rtype,
		    nextstate, newsock, newsock, -1,
		    c->local_window_max, c->local_maxpacket,
		    0, xstrdup(rtype), 1);
a1156 1
	char *name;
a1167 1
		name = xstrdup("accepted auth socket");
d1171 1
a1171 1
		    0, name, 1);
d1988 1
a1989 1
		xfree(originator_string);
d2082 1
a2082 1
		    0, xstrdup("port listener"), 1);
d2414 1
a2414 1
		    0, xstrdup("X11 inet listener"), 1);
d2571 1
a2575 1
		xfree(remote_host);
a2696 1
	char *name;
a2714 1
		name = xstrdup("authentication agent connection");
d2716 1
a2716 1
		    -1, 0, 0, 0, name, 1);
@


1.188
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.187 2003/03/05 22:33:43 markus Exp $");
d2055 1
a2055 1
		sock = socket(ai->ai_family, SOCK_STREAM, 0);
d2271 1
a2271 1
		sock = socket(ai->ai_family, SOCK_STREAM, 0);
d2372 2
a2373 1
			sock = socket(ai->ai_family, SOCK_STREAM, 0);
d2517 1
a2517 1
		sock = socket(ai->ai_family, SOCK_STREAM, 0);
@


1.187
log
@fix memory leaks; from dlheine@@suif.Stanford.EDU/CLOUSEAU; ok djm@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.186 2003/01/10 10:32:54 djm Exp $");
d145 1
a145 1
		log("channel_lookup: %d: bad id", id);
d150 1
a150 1
		log("channel_lookup: %d: bad id: channel free", id);
d577 1
a577 1
		log("channel_send_open: %d: bad id", id);
d595 1
a595 1
		log("channel_request_start: %d: unknown channel id", id);
d610 1
a610 1
		log("channel_register_comfirm: %d: bad id", id);
d621 1
a621 1
		log("channel_register_cleanup: %d: bad id", id);
d632 1
a632 1
		log("channel_cancel_cleanup: %d: bad id", id);
d643 1
a643 1
		log("channel_register_filter: %d: bad id", id);
d835 1
a835 1
		log("X11 connection rejected because of wrong authentication.");
d858 1
a858 1
		log("X11 connection rejected because of wrong authentication.");
d1714 1
a1714 1
			log("channel %d: rcvd big packet %d, maxpack %d",
d1718 1
a1718 1
			log("channel %d: rcvd too much data %d, win %d",
d1745 1
a1745 1
		log("channel %d: ext data for non open", id);
d1759 1
a1759 1
		log("channel %d: bad ext data", c->self);
d1765 1
a1765 1
		log("channel %d: rcvd too much extended_data %d, win %d",
d1931 1
a1931 1
		log("channel %d: open failed: %s%s%s", id,
d1958 1
a1958 1
		log("Received window adjust for "
d2160 1
a2160 1
			log("Warning: Server denied remote port forwarding.");
d2331 1
a2331 1
		log("Received request to connect to host %.100s port %d, "
@


1.187.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.194 2003/08/29 10:04:36 markus Exp $");
d57 1
a57 1
#include "bufaux.h"
d145 1
a145 1
		logit("channel_lookup: %d: bad id", id);
d150 1
a150 1
		logit("channel_lookup: %d: bad id: channel free", id);
d180 1
a180 1
		debug2("channel %d: rfd %d isatty", c->self, c->rfd);
d258 1
a258 1
	c->remote_name = xstrdup(remote_name);
d306 1
a306 1
	debug3("channel %d: close_fds r %d w %d e %d",
d326 1
a326 1
	debug("channel %d: free: %s, nchannels %d", c->self,
d330 1
a330 1
	debug3("channel %d: status: %s", c->self, s);
d421 1
a421 1
				debug2("channel %d: big output buffer %u > %u",
d577 1
a577 1
		logit("channel_send_open: %d: bad id", id);
d595 1
a595 1
		logit("channel_request_start: %d: unknown channel id", id);
d598 1
a598 1
	debug2("channel %d: request %s", id, service) ;
d610 1
a610 1
		logit("channel_register_comfirm: %d: bad id", id);
d621 1
a621 1
		logit("channel_register_cleanup: %d: bad id", id);
d632 1
a632 1
		logit("channel_cancel_cleanup: %d: bad id", id);
d643 1
a643 1
		logit("channel_register_filter: %d: bad id", id);
d741 1
a741 1
		debug2("channel %d: closing after input drain.", c->self);
d782 1
a782 1
		debug2("Initial X11 packet contains bad byte order byte: 0x%x",
d795 1
a795 1
		debug2("X11 connection uses different authentication protocol.");
d802 1
a802 1
		debug2("X11 auth data does not match fake data.");
d835 1
a835 1
		logit("X11 connection rejected because of wrong authentication.");
d858 2
a859 2
		logit("X11 connection rejected because of wrong authentication.");
		debug2("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
d869 1
a869 1
		debug2("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
d927 1
a927 1
	debug2("channel %d: dynamic request: socks4 host %s port %u command %u",
a942 111
/* try to decode a socks5 header */
#define SSH_SOCKS5_AUTHDONE	0x1000
#define SSH_SOCKS5_NOAUTH	0x00
#define SSH_SOCKS5_IPV4		0x01
#define SSH_SOCKS5_DOMAIN	0x03
#define SSH_SOCKS5_IPV6		0x04
#define SSH_SOCKS5_CONNECT	0x01
#define SSH_SOCKS5_SUCCESS	0x00

static int
channel_decode_socks5(Channel *c, fd_set * readset, fd_set * writeset)
{
	struct {
		u_int8_t version;
		u_int8_t command;
		u_int8_t reserved;
		u_int8_t atyp;
	} s5_req, s5_rsp;
	u_int16_t dest_port;
	u_char *p, dest_addr[255+1];
	int i, have, found, nmethods, addrlen, af;

	debug2("channel %d: decode socks5", c->self);
	p = buffer_ptr(&c->input);
	if (p[0] != 0x05)
		return -1;
	have = buffer_len(&c->input);
	if (!(c->flags & SSH_SOCKS5_AUTHDONE)) {
		/* format: ver | nmethods | methods */
		if (have < 2) 
			return 0;
		nmethods = p[1];
		if (have < nmethods + 2)
			return 0;
		/* look for method: "NO AUTHENTICATION REQUIRED" */
		for (found = 0, i = 2 ; i < nmethods + 2; i++) {
			if (p[i] == SSH_SOCKS5_NOAUTH ) {
				found = 1;
				break;
			}
		}
		if (!found) {
			debug("channel %d: method SSH_SOCKS5_NOAUTH not found",
			    c->self);
			return -1;
		}
		buffer_consume(&c->input, nmethods + 2);
		buffer_put_char(&c->output, 0x05);		/* version */
		buffer_put_char(&c->output, SSH_SOCKS5_NOAUTH);	/* method */
		FD_SET(c->sock, writeset);
		c->flags |= SSH_SOCKS5_AUTHDONE;
		debug2("channel %d: socks5 auth done", c->self);
		return 0;				/* need more */
	}
	debug2("channel %d: socks5 post auth", c->self);
	if (have < sizeof(s5_req)+1)
		return 0;			/* need more */
	memcpy((char *)&s5_req, p, sizeof(s5_req));
	if (s5_req.version != 0x05 ||
	    s5_req.command != SSH_SOCKS5_CONNECT ||
	    s5_req.reserved != 0x00) {
		debug2("channel %d: only socks5 connect supported", c->self);
		return -1;
	}
	switch(s5_req.atyp){
	case SSH_SOCKS5_IPV4:
		addrlen = 4;
		af = AF_INET;
		break;
	case SSH_SOCKS5_DOMAIN:
		addrlen = p[sizeof(s5_req)];
		af = -1;
		break;
	case SSH_SOCKS5_IPV6:
		addrlen = 16;
		af = AF_INET6;
		break;
	default:
		debug2("channel %d: bad socks5 atyp %d", c->self, s5_req.atyp);
		return -1;
	}
	if (have < 4 + addrlen + 2)
		return 0;
	buffer_consume(&c->input, sizeof(s5_req));
	if (s5_req.atyp == SSH_SOCKS5_DOMAIN)
		buffer_consume(&c->input, 1);    /* host string length */
	buffer_get(&c->input, (char *)&dest_addr, addrlen);
	buffer_get(&c->input, (char *)&dest_port, 2);
	dest_addr[addrlen] = '\0';
	if (s5_req.atyp == SSH_SOCKS5_DOMAIN)
		strlcpy(c->path, dest_addr, sizeof(c->path));
	else if (inet_ntop(af, dest_addr, c->path, sizeof(c->path)) == NULL)
		return -1;
	c->host_port = ntohs(dest_port);
	
	debug2("channel %d: dynamic request: socks5 host %s port %u command %u",
	    c->self, c->path, c->host_port, s5_req.command);

	s5_rsp.version = 0x05;
	s5_rsp.command = SSH_SOCKS5_SUCCESS;
	s5_rsp.reserved = 0;			/* ignored */
	s5_rsp.atyp = SSH_SOCKS5_IPV4;
	((struct in_addr *)&dest_addr)->s_addr = INADDR_ANY;
	dest_port = 0;				/* ignored */

	buffer_append(&c->output, (char *)&s5_rsp, sizeof(s5_rsp));
	buffer_append(&c->output, (char *)&dest_addr, sizeof(struct in_addr));
	buffer_append(&c->output, (char *)&dest_port, sizeof(dest_port));
	return 1;
}

d955 1
a955 1
	if (have < 3) {
a965 3
	case 0x05:
		ret = channel_decode_socks5(c, readset, writeset);
		break;
d999 1
a999 1
			debug2("single_connection: closing X11 listener.");
d1015 2
a1016 1
		    c->local_window_max, c->local_maxpacket, 0, buf, 1);
d1026 1
a1026 1
				debug2("ssh2 x11 bug compat mode");
d1131 4
a1134 2
		nc = channel_new(rtype, nextstate, newsock, newsock, -1,
		    c->local_window_max, c->local_maxpacket, 0, rtype, 1);
d1160 1
d1172 1
d1176 1
a1176 1
		    0, "accepted auth socket", 1);
d1249 1
a1249 1
			debug2("channel %d: read<=0 rfd %d len %d",
d1252 1
a1252 1
				debug2("channel %d: not open", c->self);
d1258 1
a1258 1
				debug2("channel %d: input draining.", c->self);
d1266 1
a1266 1
				debug2("channel %d: filter stops", c->self);
d1294 1
a1294 1
				debug2("channel %d: not open", c->self);
d1299 1
a1299 1
				debug2("channel %d: input draining.", c->self);
d1506 1
a1506 1
		debug2("channel %d: gc: notify user", c->self);
d1511 1
a1511 1
		debug2("channel %d: gc: user detached", c->self);
d1515 1
a1515 1
	debug2("channel %d: garbage collecting", c->self);
d1714 1
a1714 1
			logit("channel %d: rcvd big packet %d, maxpack %d",
d1718 1
a1718 1
			logit("channel %d: rcvd too much data %d, win %d",
d1745 1
a1745 1
		logit("channel %d: ext data for non open", id);
d1759 1
a1759 1
		logit("channel %d: bad ext data", c->self);
d1765 1
a1765 1
		logit("channel %d: rcvd too much extended_data %d, win %d",
d1890 1
a1890 1
		debug2("channel %d: open confirm rwindow %u rmax %u", c->self,
d1931 1
a1931 1
		logit("channel %d: open failed: %s%s%s", id,
d1958 1
a1958 1
		logit("Received window adjust for "
a1992 1
	xfree(originator_string);
d1994 1
d2055 1
a2055 1
		sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
d2087 1
a2087 1
		    0, "port listener", 1);
d2160 1
a2160 1
			logit("Warning: Server denied remote port forwarding.");
d2198 2
a2199 6
		packet_disconnect(
		    "Requested forwarding of port %d but user is not root.",
		    port);
	if (host_port == 0)
		packet_disconnect("Dynamic forwarding denied.");

d2271 1
a2271 1
		sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
d2331 1
a2331 1
		logit("Received request to connect to host %.100s port %d, "
d2372 1
a2372 2
			sock = socket(ai->ai_family, ai->ai_socktype,
			    ai->ai_protocol);
d2378 1
a2378 1
				debug2("bind port %d: %.100s", port, strerror(errno));
d2418 1
a2418 1
		    0, "X11 inet listener", 1);
d2516 1
a2516 1
		sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
d2518 1
a2518 1
			debug2("socket: %.100s", strerror(errno));
d2523 1
a2523 1
			debug2("connect %.100s port %d: %.100s", buf,
a2574 1
	xfree(remote_host);
d2579 1
d2701 1
d2720 1
d2722 1
a2722 1
		    -1, 0, 0, 0, "authentication agent connection", 1);
@


1.187.2.2
log
@upgrade to OpenSSH 3.7.1
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.195 2003/09/16 21:02:40 markus Exp $");
d231 1
a234 3
		channels = xrealloc(channels,
		    (channels_alloc + 10) * sizeof(Channel *));
		channels_alloc += 10;
d236 1
@


1.187.2.3
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.200 2004/01/19 09:24:21 markus Exp $");
d219 1
d973 1
a973 1
		if (have < 2)
d1038 1
a1038 1

d1815 4
a1821 16
	/*
	 * Ignore data for protocol > 1.3 if output end is no longer open.
	 * For protocol 2 the sending side is reducing its window as it sends
	 * data, so we must 'fake' consumption of the data in order to ensure
	 * that window updates are sent back.  Otherwise the connection might
	 * deadlock.
	 */
	if (!compat13 && c->ostate != CHAN_OUTPUT_OPEN) {
		if (compat20) {
			c->local_window -= data_len;
			c->local_consumed += data_len;
		}
		xfree(data);
		return;
	}

d2189 1
a2189 1
		if (listen(sock, SSH_LISTEN_BACKLOG) < 0) {
d2520 1
a2520 1
		if (listen(sock, SSH_LISTEN_BACKLOG) < 0) {
d2807 43
@


1.186
log
@hush socket() errors, except last. Fixes mindrot bug #408; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.185 2003/01/01 18:08:52 markus Exp $");
d1994 1
d2579 1
@


1.185
log
@move big output buffer messages to debug2
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.184 2002/12/13 10:03:15 markus Exp $");
d2272 4
a2275 1
			error("socket: %.100s", strerror(errno));
@


1.184
log
@cleanup debug messages, more useful information for the client user.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.183 2002/09/17 07:47:02 itojun Exp $");
d415 1
a415 1
				debug("channel %d: big input buffer %d",
d421 1
a421 1
				debug("channel %d: big output buffer %d > %d",
@


1.183
log
@don't quit while creating X11 listening socket.

http://mail-index.netbsd.org/current-users/2002/09/16/0005.html
got from portable.  markus ok
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.182 2002/09/13 19:23:09 stevesk Exp $");
d580 1
a580 1
	debug("send channel open %d", id);
d590 1
a590 1
channel_request_start(int local_id, char *service, int wantconfirm)
d592 1
a592 1
	Channel *c = channel_lookup(local_id);
d595 1
a595 1
		log("channel_request_start: %d: unknown channel id", local_id);
d598 1
a598 1
	debug("channel request %d: %s", local_id, service) ;
@


1.183.2.1
log
@Update to OpenSSH 3.6
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.187 2003/03/05 22:33:43 markus Exp $");
d415 1
a415 1
				debug2("channel %d: big input buffer %d",
d421 1
a421 1
				debug2("channel %d: big output buffer %d > %d",
d580 1
a580 1
	debug2("channel %d: send open", id);
d590 1
a590 1
channel_request_start(int id, char *service, int wantconfirm)
d592 1
a592 1
	Channel *c = channel_lookup(id);
d595 1
a595 1
		log("channel_request_start: %d: unknown channel id", id);
d598 1
a598 1
	debug("channel %d: request %s", id, service) ;
a1993 1
		xfree(originator_string);
d2272 1
a2272 4
			if (ai->ai_next == NULL)
				error("socket: %.100s", strerror(errno));
			else
				verbose("socket: %.100s", strerror(errno));
a2574 1
		xfree(remote_host);
@


1.183.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.194 2003/08/29 10:04:36 markus Exp $");
d57 1
a57 1
#include "bufaux.h"
d145 1
a145 1
		logit("channel_lookup: %d: bad id", id);
d150 1
a150 1
		logit("channel_lookup: %d: bad id: channel free", id);
d180 1
a180 1
		debug2("channel %d: rfd %d isatty", c->self, c->rfd);
d258 1
a258 1
	c->remote_name = xstrdup(remote_name);
d306 1
a306 1
	debug3("channel %d: close_fds r %d w %d e %d",
d326 1
a326 1
	debug("channel %d: free: %s, nchannels %d", c->self,
d330 1
a330 1
	debug3("channel %d: status: %s", c->self, s);
d421 1
a421 1
				debug2("channel %d: big output buffer %u > %u",
d577 1
a577 1
		logit("channel_send_open: %d: bad id", id);
d595 1
a595 1
		logit("channel_request_start: %d: unknown channel id", id);
d598 1
a598 1
	debug2("channel %d: request %s", id, service) ;
d610 1
a610 1
		logit("channel_register_comfirm: %d: bad id", id);
d621 1
a621 1
		logit("channel_register_cleanup: %d: bad id", id);
d632 1
a632 1
		logit("channel_cancel_cleanup: %d: bad id", id);
d643 1
a643 1
		logit("channel_register_filter: %d: bad id", id);
d741 1
a741 1
		debug2("channel %d: closing after input drain.", c->self);
d782 1
a782 1
		debug2("Initial X11 packet contains bad byte order byte: 0x%x",
d795 1
a795 1
		debug2("X11 connection uses different authentication protocol.");
d802 1
a802 1
		debug2("X11 auth data does not match fake data.");
d835 1
a835 1
		logit("X11 connection rejected because of wrong authentication.");
d858 2
a859 2
		logit("X11 connection rejected because of wrong authentication.");
		debug2("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
d869 1
a869 1
		debug2("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
d927 1
a927 1
	debug2("channel %d: dynamic request: socks4 host %s port %u command %u",
a942 111
/* try to decode a socks5 header */
#define SSH_SOCKS5_AUTHDONE	0x1000
#define SSH_SOCKS5_NOAUTH	0x00
#define SSH_SOCKS5_IPV4		0x01
#define SSH_SOCKS5_DOMAIN	0x03
#define SSH_SOCKS5_IPV6		0x04
#define SSH_SOCKS5_CONNECT	0x01
#define SSH_SOCKS5_SUCCESS	0x00

static int
channel_decode_socks5(Channel *c, fd_set * readset, fd_set * writeset)
{
	struct {
		u_int8_t version;
		u_int8_t command;
		u_int8_t reserved;
		u_int8_t atyp;
	} s5_req, s5_rsp;
	u_int16_t dest_port;
	u_char *p, dest_addr[255+1];
	int i, have, found, nmethods, addrlen, af;

	debug2("channel %d: decode socks5", c->self);
	p = buffer_ptr(&c->input);
	if (p[0] != 0x05)
		return -1;
	have = buffer_len(&c->input);
	if (!(c->flags & SSH_SOCKS5_AUTHDONE)) {
		/* format: ver | nmethods | methods */
		if (have < 2) 
			return 0;
		nmethods = p[1];
		if (have < nmethods + 2)
			return 0;
		/* look for method: "NO AUTHENTICATION REQUIRED" */
		for (found = 0, i = 2 ; i < nmethods + 2; i++) {
			if (p[i] == SSH_SOCKS5_NOAUTH ) {
				found = 1;
				break;
			}
		}
		if (!found) {
			debug("channel %d: method SSH_SOCKS5_NOAUTH not found",
			    c->self);
			return -1;
		}
		buffer_consume(&c->input, nmethods + 2);
		buffer_put_char(&c->output, 0x05);		/* version */
		buffer_put_char(&c->output, SSH_SOCKS5_NOAUTH);	/* method */
		FD_SET(c->sock, writeset);
		c->flags |= SSH_SOCKS5_AUTHDONE;
		debug2("channel %d: socks5 auth done", c->self);
		return 0;				/* need more */
	}
	debug2("channel %d: socks5 post auth", c->self);
	if (have < sizeof(s5_req)+1)
		return 0;			/* need more */
	memcpy((char *)&s5_req, p, sizeof(s5_req));
	if (s5_req.version != 0x05 ||
	    s5_req.command != SSH_SOCKS5_CONNECT ||
	    s5_req.reserved != 0x00) {
		debug2("channel %d: only socks5 connect supported", c->self);
		return -1;
	}
	switch(s5_req.atyp){
	case SSH_SOCKS5_IPV4:
		addrlen = 4;
		af = AF_INET;
		break;
	case SSH_SOCKS5_DOMAIN:
		addrlen = p[sizeof(s5_req)];
		af = -1;
		break;
	case SSH_SOCKS5_IPV6:
		addrlen = 16;
		af = AF_INET6;
		break;
	default:
		debug2("channel %d: bad socks5 atyp %d", c->self, s5_req.atyp);
		return -1;
	}
	if (have < 4 + addrlen + 2)
		return 0;
	buffer_consume(&c->input, sizeof(s5_req));
	if (s5_req.atyp == SSH_SOCKS5_DOMAIN)
		buffer_consume(&c->input, 1);    /* host string length */
	buffer_get(&c->input, (char *)&dest_addr, addrlen);
	buffer_get(&c->input, (char *)&dest_port, 2);
	dest_addr[addrlen] = '\0';
	if (s5_req.atyp == SSH_SOCKS5_DOMAIN)
		strlcpy(c->path, dest_addr, sizeof(c->path));
	else if (inet_ntop(af, dest_addr, c->path, sizeof(c->path)) == NULL)
		return -1;
	c->host_port = ntohs(dest_port);
	
	debug2("channel %d: dynamic request: socks5 host %s port %u command %u",
	    c->self, c->path, c->host_port, s5_req.command);

	s5_rsp.version = 0x05;
	s5_rsp.command = SSH_SOCKS5_SUCCESS;
	s5_rsp.reserved = 0;			/* ignored */
	s5_rsp.atyp = SSH_SOCKS5_IPV4;
	((struct in_addr *)&dest_addr)->s_addr = INADDR_ANY;
	dest_port = 0;				/* ignored */

	buffer_append(&c->output, (char *)&s5_rsp, sizeof(s5_rsp));
	buffer_append(&c->output, (char *)&dest_addr, sizeof(struct in_addr));
	buffer_append(&c->output, (char *)&dest_port, sizeof(dest_port));
	return 1;
}

d955 1
a955 1
	if (have < 3) {
a965 3
	case 0x05:
		ret = channel_decode_socks5(c, readset, writeset);
		break;
d999 1
a999 1
			debug2("single_connection: closing X11 listener.");
d1015 2
a1016 1
		    c->local_window_max, c->local_maxpacket, 0, buf, 1);
d1026 1
a1026 1
				debug2("ssh2 x11 bug compat mode");
d1131 4
a1134 2
		nc = channel_new(rtype, nextstate, newsock, newsock, -1,
		    c->local_window_max, c->local_maxpacket, 0, rtype, 1);
d1160 1
d1172 1
d1176 1
a1176 1
		    0, "accepted auth socket", 1);
d1249 1
a1249 1
			debug2("channel %d: read<=0 rfd %d len %d",
d1252 1
a1252 1
				debug2("channel %d: not open", c->self);
d1258 1
a1258 1
				debug2("channel %d: input draining.", c->self);
d1266 1
a1266 1
				debug2("channel %d: filter stops", c->self);
d1294 1
a1294 1
				debug2("channel %d: not open", c->self);
d1299 1
a1299 1
				debug2("channel %d: input draining.", c->self);
d1506 1
a1506 1
		debug2("channel %d: gc: notify user", c->self);
d1511 1
a1511 1
		debug2("channel %d: gc: user detached", c->self);
d1515 1
a1515 1
	debug2("channel %d: garbage collecting", c->self);
d1714 1
a1714 1
			logit("channel %d: rcvd big packet %d, maxpack %d",
d1718 1
a1718 1
			logit("channel %d: rcvd too much data %d, win %d",
d1745 1
a1745 1
		logit("channel %d: ext data for non open", id);
d1759 1
a1759 1
		logit("channel %d: bad ext data", c->self);
d1765 1
a1765 1
		logit("channel %d: rcvd too much extended_data %d, win %d",
d1890 1
a1890 1
		debug2("channel %d: open confirm rwindow %u rmax %u", c->self,
d1931 1
a1931 1
		logit("channel %d: open failed: %s%s%s", id,
d1958 1
a1958 1
		logit("Received window adjust for "
a1992 1
	xfree(originator_string);
d1994 1
d2055 1
a2055 1
		sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
d2087 1
a2087 1
		    0, "port listener", 1);
d2160 1
a2160 1
			logit("Warning: Server denied remote port forwarding.");
d2198 2
a2199 6
		packet_disconnect(
		    "Requested forwarding of port %d but user is not root.",
		    port);
	if (host_port == 0)
		packet_disconnect("Dynamic forwarding denied.");

d2271 1
a2271 1
		sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
d2331 1
a2331 1
		logit("Received request to connect to host %.100s port %d, "
d2372 1
a2372 2
			sock = socket(ai->ai_family, ai->ai_socktype,
			    ai->ai_protocol);
d2378 1
a2378 1
				debug2("bind port %d: %.100s", port, strerror(errno));
d2418 1
a2418 1
		    0, "X11 inet listener", 1);
d2516 1
a2516 1
		sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
d2518 1
a2518 1
			debug2("socket: %.100s", strerror(errno));
d2523 1
a2523 1
			debug2("connect %.100s port %d: %.100s", buf,
a2574 1
	xfree(remote_host);
d2579 1
d2701 1
d2720 1
d2722 1
a2722 1
		    -1, 0, 0, 0, "authentication agent connection", 1);
@


1.183.2.3
log
@upgrade to OpenSSH 3.7.1
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.195 2003/09/16 21:02:40 markus Exp $");
d231 1
a234 3
		channels = xrealloc(channels,
		    (channels_alloc + 10) * sizeof(Channel *));
		channels_alloc += 10;
d236 1
@


1.182
log
@remove use of SO_LINGER, it should not be needed. error check
SO_REUSEADDR. fixup comments. ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.181 2002/09/09 14:54:14 markus Exp $");
d2376 4
@


1.181
log
@signed vs unsigned from -pedantic; ok henning@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.180 2002/07/04 08:12:15 deraadt Exp $");
a2018 1
	struct linger linger;
d2061 2
a2062 2
		 * Set socket options.  We would like the socket to disappear
		 * as soon as it has been closed for whatever reason.
d2064 4
a2067 4
		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
		linger.l_onoff = 1;
		linger.l_linger = 5;
		setsockopt(sock, SOL_SOCKET, SO_LINGER, &linger, sizeof(linger));
@


1.180
log
@blah blah minor nothing as i read and re-read and re-read...
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.179 2002/06/26 08:55:02 markus Exp $");
d877 1
a877 1
	u_char *p, *host;
@


1.179
log
@limit # of channels to 10000
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.178 2002/06/24 14:33:27 markus Exp $");
d575 1
d593 1
d608 1
d619 1
d630 1
d641 1
d654 1
d825 1
d1406 1
d1484 1
d2586 1
@


1.178
log
@move channel counter to u_int
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.177 2002/06/23 21:34:07 markus Exp $");
d232 3
@


1.177
log
@tcode is u_int
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.176 2002/06/23 21:06:41 deraadt Exp $");
d208 1
a208 1
    int window, int maxpack, int extusage, char *remote_name, int nonblock)
a1570 1
	int len, i;
d1572 2
d1651 1
a1651 1
			debug2("channel %d: rwin %d elen %d euse %d",
d1877 1
a1877 1
		debug("channel %d: open confirm rwindow %d rmax %d", c->self,
d1934 2
a1935 1
	int id, adjust;
d1951 1
a1951 1
	debug2("channel %d: rcvd adjust %d", id, adjust);
@


1.176
log
@display, screen, row, col, xpixel, ypixel are u_int; markus ok
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.175 2002/06/10 22:28:41 markus Exp $");
a1719 1
	int tcode;
d1721 1
a1721 1
	u_int data_len;
@


1.175
log
@move creation of agent socket to session.c; no need for uidswapping
in channel.c.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.174 2002/06/09 13:32:01 markus Exp $");
d2325 2
a2326 2
 * Returns a suitable display number for the DISPLAY variable, or -1 if
 * an error occurs.
d2330 1
a2330 1
    int single_connection)
d2402 2
a2403 1
	return display_number;
@


1.174
log
@use tab not spaces (|unexpand)
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.173 2002/04/22 21:04:52 markus Exp $");
a48 1
#include "uidswap.h"
a130 4
/* Name and directory of socket for authentication agent forwarding. */
static char *auth_sock_name = NULL;
static char *auth_sock_dir = NULL;

a2667 99
}

/*
 * Returns the name of the forwarded authentication socket.  Returns NULL if
 * there is no forwarded authentication socket.  The returned value points to
 * a static buffer.
 */

char *
auth_get_socket_name(void)
{
	return auth_sock_name;
}

/* removes the agent forwarding socket */

void
auth_sock_cleanup_proc(void *_pw)
{
	struct passwd *pw = _pw;

	if (auth_sock_name) {
		temporarily_use_uid(pw);
		unlink(auth_sock_name);
		rmdir(auth_sock_dir);
		auth_sock_name = NULL;
		restore_uid();
	}
}

/*
 * This is called to process SSH_CMSG_AGENT_REQUEST_FORWARDING on the server.
 * This starts forwarding authentication requests.
 */

int
auth_input_request_forwarding(struct passwd * pw)
{
	Channel *nc;
	int sock;
	struct sockaddr_un sunaddr;

	if (auth_get_socket_name() != NULL) {
		error("authentication forwarding requested twice.");
		return 0;
	}

	/* Temporarily drop privileged uid for mkdir/bind. */
	temporarily_use_uid(pw);

	/* Allocate a buffer for the socket name, and format the name. */
	auth_sock_name = xmalloc(MAXPATHLEN);
	auth_sock_dir = xmalloc(MAXPATHLEN);
	strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXX", MAXPATHLEN);

	/* Create private directory for socket */
	if (mkdtemp(auth_sock_dir) == NULL) {
		packet_send_debug("Agent forwarding disabled: "
		    "mkdtemp() failed: %.100s", strerror(errno));
		restore_uid();
		xfree(auth_sock_name);
		xfree(auth_sock_dir);
		auth_sock_name = NULL;
		auth_sock_dir = NULL;
		return 0;
	}
	snprintf(auth_sock_name, MAXPATHLEN, "%s/agent.%d",
		 auth_sock_dir, (int) getpid());

	/* delete agent socket on fatal() */
	fatal_add_cleanup(auth_sock_cleanup_proc, pw);

	/* Create the socket. */
	sock = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sock < 0)
		packet_disconnect("socket: %.100s", strerror(errno));

	/* Bind it to the name. */
	memset(&sunaddr, 0, sizeof(sunaddr));
	sunaddr.sun_family = AF_UNIX;
	strlcpy(sunaddr.sun_path, auth_sock_name, sizeof(sunaddr.sun_path));

	if (bind(sock, (struct sockaddr *) & sunaddr, sizeof(sunaddr)) < 0)
		packet_disconnect("bind: %.100s", strerror(errno));

	/* Restore the privileged uid. */
	restore_uid();

	/* Start listening on the socket. */
	if (listen(sock, 5) < 0)
		packet_disconnect("listen: %.100s", strerror(errno));

	/* Allocate a channel for the authentication agent socket. */
	nc = channel_new("auth socket",
	    SSH_CHANNEL_AUTH_SOCKET, sock, sock, -1,
	    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,
	    0, xstrdup("auth socket"), 1);
	strlcpy(nc->path, auth_sock_name, sizeof(nc->path));
	return 1;
@


1.173
log
@request reply (success/failure) for -R style fwd in protocol v2,
depends on ordered replies.
fixes http://bugzilla.mindrot.org/show_bug.cgi?id=215; ok provos@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.172 2002/03/25 21:13:51 markus Exp $");
d710 2
a711 2
                               debug2("channel %d: obuf_empty delayed efd %d/(%d)",
                                   c->self, c->efd, buffer_len(&c->extended));
d1644 2
a1645 2
                               debug2("channel %d: ibuf_empty delayed efd %d/(%d)",
                                   c->self, c->efd, buffer_len(&c->extended));
@


1.172
log
@don't send stderr data after EOF, accept this from older known (broken)
sshd servers only, fixes http://bugzilla.mindrot.org/show_bug.cgi?id=179
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.171 2002/03/04 19:37:58 markus Exp $");
d2129 1
a2129 1
		packet_put_char(0);			/* boolean: want reply */
@


1.172.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.173 2002/04/22 21:04:52 markus Exp $");
d2129 1
a2129 1
		packet_put_char(1);			/* boolean: want reply */
@


1.172.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.172.2.3
log
@Pull in OpenSSH-3.4
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.179 2002/06/26 08:55:02 markus Exp $");
d49 1
d132 4
d213 1
a213 1
    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)
a236 3
		if (channels_alloc > 10000)
			fatal("channel_new: internal error: channels_alloc %d "
			    "too big.", channels_alloc);
d710 2
a711 2
			       debug2("channel %d: obuf_empty delayed efd %d/(%d)",
				   c->self, c->efd, buffer_len(&c->extended));
d1576 1
a1577 2
	int i;
	u_int len;
d1644 2
a1645 2
			       debug2("channel %d: ibuf_empty delayed efd %d/(%d)",
				   c->self, c->efd, buffer_len(&c->extended));
d1655 1
a1655 1
			debug2("channel %d: rwin %u elen %u euse %d",
d1725 1
d1727 1
a1727 1
	u_int data_len, tcode;
d1882 1
a1882 1
		debug("channel %d: open confirm rwindow %u rmax %u", c->self,
d1939 1
a1939 2
	int id;
	u_int adjust;
d1955 1
a1955 1
	debug2("channel %d: rcvd adjust %u", id, adjust);
d2330 2
a2331 2
 * Returns 0 and a suitable display number for the DISPLAY variable
 * stored in display_numberp , or -1 if an error occurs.
d2335 1
a2335 1
    int single_connection, u_int *display_numberp)
d2407 1
a2407 2
	*display_numberp = display_number;
	return (0);
d2673 99
@


1.172.2.4
log
@Update to OpenSSH 3.5
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.183 2002/09/17 07:47:02 itojun Exp $");
a574 1

a591 1

a605 1

a615 1

a625 1

a635 1

a647 1

a817 1

d869 1
a869 1
	char *p, *host;
a1397 1

a1474 1

d2009 1
d2052 2
a2053 2
		 * Set socket options.
		 * Allow local port reuse in TIME_WAIT.
d2055 4
a2058 4
		if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &on,
		    sizeof(on)) == -1)
			error("setsockopt SO_REUSEADDR: %s", strerror(errno));

a2366 4

				if (ai->ai_next)
					continue;

a2575 1

@


1.172.2.5
log
@Merge OpenSSH 3.6.1
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.187 2003/03/05 22:33:43 markus Exp $");
d415 1
a415 1
				debug2("channel %d: big input buffer %d",
d421 1
a421 1
				debug2("channel %d: big output buffer %d > %d",
d580 1
a580 1
	debug2("channel %d: send open", id);
d590 1
a590 1
channel_request_start(int id, char *service, int wantconfirm)
d592 1
a592 1
	Channel *c = channel_lookup(id);
d595 1
a595 1
		log("channel_request_start: %d: unknown channel id", id);
d598 1
a598 1
	debug("channel %d: request %s", id, service) ;
a1993 1
		xfree(originator_string);
d2272 1
a2272 4
			if (ai->ai_next == NULL)
				error("socket: %.100s", strerror(errno));
			else
				verbose("socket: %.100s", strerror(errno));
a2574 1
		xfree(remote_host);
@


1.171
log
@off by one; thanks to joost@@pine.nl
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.170 2002/02/27 21:23:13 stevesk Exp $");
d709 5
a713 1
			chan_obuf_empty(c);
d721 2
a722 1
		else if (c->extended_usage == CHAN_EXTENDED_READ &&
d1640 2
a1641 1
			 * tell peer, that we will not send more data: send IEOF
d1643 5
a1647 1
			chan_ibuf_empty(c);
d1651 1
d1739 7
@


1.170
log
@remove unneeded casts in [gs]etsockopt(); ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.169 2002/02/24 19:59:42 stevesk Exp $");
d149 1
a149 1
	if (id < 0 || id > channels_alloc) {
@


1.169
log
@disable Nagle in connect_to() and channel_post_port_listener() (port
forwarding endpoints).  the intention is to preserve the on-the-wire
appearance to applications at either end; the applications can then
enable TCP_NODELAY according to their requirements. ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.168 2002/02/14 23:27:59 markus Exp $");
d1187 1
a1187 2
		if (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, (char *)&err,
		    &sz) < 0) {
d2038 1
a2038 1
		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *)&on, sizeof(on));
d2041 1
a2041 1
		setsockopt(sock, SOL_SOCKET, SO_LINGER, (void *)&linger, sizeof(linger));
@


1.168
log
@increase the SSH v2 window size to 4 packets. comsumes a little
bit more memory for slow receivers but increases througput.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.167 2002/02/06 14:55:15 markus Exp $");
d1119 1
d2268 1
@


1.167
log
@channel_new never returns NULL, mouring@@; ok djm@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.166 2002/02/05 14:32:55 markus Exp $");
d647 1
a647 1
    int extusage, int nonblock)
d654 1
a654 2
	/* XXX window size? */
	c->local_window = c->local_window_max = c->local_maxpacket * 2;
@


1.166
log
@merge channel_request() into channel_request_start()
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.165 2002/02/03 17:58:21 markus Exp $");
a1006 5
		if (nc == NULL) {
			close(newsock);
			xfree(remote_ipaddr);
			return;
		}
a1123 5
		if (nc == NULL) {
			error("channel_post_port_listener: no new channel:");
			close(newsock);
			return;
		}
a1165 5
		if (nc == NULL) {
			error("channel_post_auth_listener: channel_new failed");
			xfree(name);
			close(newsock);
		}
d1965 1
a1965 6
		if (c == NULL) {
			error("channel_input_port_open: channel_new failed");
			close(sock);
		} else {
			c->remote_id = remote_id;
		}
a2061 5
		if (c == NULL) {
			error("channel_setup_fwd_listener: channel_new failed");
			close(sock);
			continue;
		}
d2385 1
a2385 2
		if (nc != NULL)
			nc->single_connection = single_connection;
d2537 2
a2538 7
		if (c == NULL) {
			error("x11_input_open: channel_new failed");
			close(sock);
		} else {
			c->remote_id = remote_id;
			c->force_drain = 1;
		}
a2751 7
	if (nc == NULL) {
		error("auth_input_request_forwarding: channel_new failed");
		auth_sock_cleanup_proc(pw);
		fatal_remove_cleanup(auth_sock_cleanup_proc, pw);
		close(sock);
		return 0;
	}
d2785 2
a2786 8
		if (c == NULL) {
			error("auth_input_open_request: channel_new failed");
			xfree(name);
			close(sock);
		} else {
			c->remote_id = remote_id;
			c->force_drain = 1;
		}
@


1.165
log
@generic callbacks are not really used, remove and
add a callback for msg of type SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
ok djm@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.164 2002/02/03 17:55:55 markus Exp $");
d591 1
a591 1
channel_request(int id, char *service, int wantconfirm)
d593 1
a593 8
	channel_request_start(id, service, wantconfirm);
	packet_send();
	debug("channel request %d: %s", id, service) ;
}
void
channel_request_start(int id, char *service, int wantconfirm)
{
	Channel *c = channel_lookup(id);
d595 1
a595 1
		log("channel_request: %d: bad id", id);
d598 1
@


1.164
log
@remove unused channel_input_channel_request
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.163 2002/01/27 14:57:46 stevesk Exp $");
a262 3
	c->cb_fn = NULL;
	c->cb_arg = NULL;
	c->cb_event = 0;
d266 1
d611 1
a611 1
channel_register_callback(int id, int mtype, channel_callback_fn *fn, void *arg)
d615 1
a615 1
		log("channel_register_callback: %d: bad id", id);
d618 1
a618 3
	c->cb_event = mtype;
	c->cb_fn = fn;
	c->cb_arg = arg;
d1881 1
a1881 1
		if (c->cb_fn != NULL && c->cb_event == type) {
d1883 1
a1883 1
			c->cb_fn(c->self, c->cb_arg);
@


1.163
log
@add X11UseLocalhost; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.162 2002/01/24 21:09:25 stevesk Exp $");
a1940 25
}

void
channel_input_channel_request(int type, u_int32_t seq, void *ctxt)
{
	int id;
	Channel *c;

	id = packet_get_int();
	c = channel_lookup(id);

	if (c == NULL ||
	    (c->type != SSH_CHANNEL_OPEN && c->type != SSH_CHANNEL_LARVAL))
		packet_disconnect("Received request for "
		    "non-open channel %d.", id);
	if (c->cb_fn != NULL && c->cb_event == type) {
		debug2("callback start");
		c->cb_fn(c->self, c->cb_arg);
		debug2("callback done");
	} else {
		char *service = packet_get_string(NULL);
		debug("channel %d: rcvd request for %s", c->self, service);
		debug("cb_fn %p cb_event %d", c->cb_fn , c->cb_event);
		xfree(service);
	}
@


1.162
log
@add set_nodelay() to set TCP_NODELAY on a socket (prep for nagle tuning).
no nagle changes just yet; ok djm@@ markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.161 2002/01/21 23:27:10 markus Exp $");
d2376 1
a2376 1
x11_create_display_inet(int x11_display_offset, int gateway_ports,
d2392 1
a2392 1
		hints.ai_flags = gateway_ports ? AI_PASSIVE : 0;
@


1.161
log
@cleanup channels faster if the are empty and we are in drain-state; ok deraadt@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.160 2002/01/16 13:17:51 markus Exp $");
d989 1
a989 1
	int newsock, on = 1;
d1007 1
a1007 4
		if (setsockopt(newsock, IPPROTO_TCP, TCP_NODELAY, &on,
		    sizeof on) == -1)
			error("setsockopt TCP_NODELAY: %.100s",
			    strerror(errno));
d2475 1
a2475 1
	int display_number, sock = 0, on = 1;
d2563 1
a2563 2
	if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &on, sizeof on) == -1)
		error("setsockopt TCP_NODELAY: %.100s", strerror(errno));
@


1.160
log
@wrapper for channel_setup_fwd_listener
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.159 2002/01/14 13:55:55 markus Exp $");
d1796 2
@


1.159
log
@remove function pointers for events, remove chan_init*; ok provos@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.158 2002/01/09 17:26:35 markus Exp $");
d2040 3
a2042 23
/*
 * Initiate forwarding of connections to local port "port" through the secure
 * channel to host:port from remote side.
 */
int
channel_request_local_forwarding(u_short listen_port, const char *host_to_connect,
    u_short port_to_connect, int gateway_ports)
{
	return channel_request_forwarding(
	    NULL, listen_port,
	    host_to_connect, port_to_connect,
	    gateway_ports, /*remote_fwd*/ 0);
}

/*
 * If 'remote_fwd' is true we have a '-R style' listener for protocol 2
 * (SSH_CHANNEL_RPORT_LISTENER).
 */
int
channel_request_forwarding(
    const char *listen_address, u_short listen_port,
    const char *host_to_connect, u_short port_to_connect,
    int gateway_ports, int remote_fwd)
d2045 1
a2045 1
	int success, sock, on = 1, type;
d2047 1
a2048 1
	const char *host;
d2052 2
d2055 3
a2057 6
	if (remote_fwd) {
		host = listen_address;
		type = SSH_CHANNEL_RPORT_LISTENER;
	} else {
		host = host_to_connect;
		type = SSH_CHANNEL_PORT_LISTENER;
a2058 1

a2063 1
	/* XXX listen_address is currently ignored */
d2081 1
a2081 1
			error("channel_request_forwarding: getnameinfo failed");
d2119 1
a2119 1
			error("channel_request_forwarding: channel_new failed");
d2129 1
a2129 1
		error("channel_request_forwarding: cannot listen to port: %d",
d2135 18
d2236 1
a2236 1
	channel_request_local_forwarding(port, hostname, host_port, gateway_ports);
@


1.158
log
@replace buffer_consume(b, buffer_len(b)) with buffer_clear(b); ok provos@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.157 2002/01/09 17:16:00 markus Exp $");
a219 1
		chan_init();
d248 3
a250 1
	chan_init_iostates(c);
@


1.157
log
@merge channel_pre_open_15/channel_pre_open_20; ok provos@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.156 2002/01/05 10:43:40 markus Exp $");
d1273 1
a1273 1
				buffer_consume(&c->output, buffer_len(&c->output));
d1315 1
a1315 1
				buffer_consume(&c->output, buffer_len(&c->output));
d1428 1
a1428 1
			buffer_consume(&c->output, buffer_len(&c->output));
d1831 1
a1831 1
		buffer_consume(&c->input, buffer_len(&c->input));
@


1.156
log
@fix hanging x11 channels for rejected cookies (e.g. XAUTHORITY=/dev/null xbiff)
bug #36, based on patch from djast@@cs.toronto.edu
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.155 2001/12/29 21:56:01 stevesk Exp $");
d706 1
a706 1
channel_pre_open_15(Channel *c, fd_set * readset, fd_set * writeset)
d708 1
a708 13
	/* test whether sockets are 'alive' for read/write */
	if (c->istate == CHAN_INPUT_OPEN)
		if (buffer_len(&c->input) < packet_get_maxsize())
			FD_SET(c->sock, readset);
	if (c->ostate == CHAN_OUTPUT_OPEN ||
	    c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {
		if (buffer_len(&c->output) > 0) {
			FD_SET(c->sock, writeset);
		} else if (c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {
			chan_obuf_empty(c);
		}
	}
}
a709 3
static void
channel_pre_open_20(Channel *c, fd_set * readset, fd_set * writeset)
{
d711 2
a712 2
	    c->remote_window > 0 &&
	    buffer_len(&c->input) < c->remote_window)
d723 1
a723 1
	if (c->efd != -1) {
d855 1
a855 4
		if (compat20)
			channel_pre_open_20(c, readset, writeset);
		else
			channel_pre_open_15(c, readset, writeset);
d1407 1
a1407 1
channel_post_open_1(Channel *c, fd_set * readset, fd_set * writeset)
d1413 1
a1413 6
}

static void
channel_post_open_2(Channel *c, fd_set * readset, fd_set * writeset)
{
	if (c->delayed)
a1414 2
	channel_handle_rfd(c, readset, writeset);
	channel_handle_wfd(c, readset, writeset);
a1415 1

d1437 1
a1437 1
	channel_pre[SSH_CHANNEL_OPEN] =			&channel_pre_open_20;
d1446 1
a1446 1
	channel_post[SSH_CHANNEL_OPEN] =		&channel_post_open_2;
d1452 1
a1452 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open_2;
d1468 1
a1468 1
	channel_post[SSH_CHANNEL_OPEN] =		&channel_post_open_1;
d1474 1
a1474 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open_1;
d1480 1
a1480 1
	channel_pre[SSH_CHANNEL_OPEN] =			&channel_pre_open_15;
d1491 1
a1491 1
	channel_post[SSH_CHANNEL_OPEN] =		&channel_post_open_1;
d1493 1
a1493 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open_1;
@


1.155
log
@remove unneeded casts and some char->u_char cleanup; ok markus@@
@
text
@d16 1
a16 1
 * Copyright (c) 1999, 2000, 2001 Markus Friedl.  All rights reserved.
d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.154 2001/12/28 15:06:00 markus Exp $");
d875 1
d877 9
a885 2
		chan_read_failed(c);	/** force close? */
		chan_write_failed(c);
d1818 1
a1818 1
	if (c->force_drain) {
@


1.154
log
@remove plen from the dispatch fn. it's no longer used.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.153 2001/12/28 14:50:54 markus Exp $");
d789 1
a789 1
	ucp = (u_char *) buffer_ptr(b);
@


1.153
log
@packet_read* no longer return the packet length, since it's not used.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.152 2001/12/28 12:14:27 markus Exp $");
d1713 1
a1713 1
channel_input_data(int type, int plen, u_int32_t seq, void *ctxt)
d1757 1
a1757 1
channel_input_extended_data(int type, int plen, u_int32_t seq, void *ctxt)
d1797 1
a1797 1
channel_input_ieof(int type, int plen, u_int32_t seq, void *ctxt)
d1818 1
a1818 1
channel_input_close(int type, int plen, u_int32_t seq, void *ctxt)
d1856 1
a1856 1
channel_input_oclose(int type, int plen, u_int32_t seq, void *ctxt)
d1868 1
a1868 1
channel_input_close_confirmation(int type, int plen, u_int32_t seq, void *ctxt)
d1884 1
a1884 1
channel_input_open_confirmation(int type, int plen, u_int32_t seq, void *ctxt)
d1931 1
a1931 1
channel_input_open_failure(int type, int plen, u_int32_t seq, void *ctxt)
d1962 1
a1962 1
channel_input_channel_request(int type, int plen, u_int32_t seq, void *ctxt)
d1987 1
a1987 1
channel_input_window_adjust(int type, int plen, u_int32_t seq, void *ctxt)
d2011 1
a2011 1
channel_input_port_open(int type, int plen, u_int32_t seq, void *ctxt)
d2598 1
a2598 1
x11_input_open(int type, int plen, u_int32_t seq, void *ctxt)
d2645 1
a2645 1
deny_input_open(int type, int plen, u_int32_t seq, void *ctxt)
d2656 1
a2656 1
		error("deny_input_open: type %d plen %d", type, plen);
d2856 1
a2856 1
auth_input_open_request(int type, int plen, u_int32_t seq, void *ctxt)
@


1.152
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.151 2001/12/27 20:39:58 markus Exp $");
d2184 1
a2184 1
	int payload_len, type, success = 0;
d2211 1
a2211 1
		type = packet_read(&payload_len);
@


1.151
log
@get rid of packet_integrity_check, use packet_done() instead.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.150 2001/12/20 22:50:24 djm Exp $");
d1751 1
a1751 1
	packet_done();
d1783 1
a1783 1
	packet_done();
d1803 1
a1803 1
	packet_done();
d1824 1
a1824 1
	packet_done();
d1861 1
a1861 1
	packet_done();
d1873 1
a1873 1
	packet_done();
d1911 1
a1911 1
	packet_done();
d1956 1
a1956 1
	packet_done();
d2005 1
a2005 1
	packet_done();
d2027 1
a2027 1
	packet_done();
d2613 1
a2613 1
	packet_done();
d2864 1
a2864 1
	packet_done();
@


1.150
log
@Conformance fix: we should send failing packet sequence number when
responding with a SSH_MSG_UNIMPLEMENTED message. Spotted by
yakk@@yakk.dot.net; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.149 2001/12/20 16:37:29 markus Exp $");
a1736 1
	packet_done();
a1749 2
	}else{
		packet_integrity_check(plen, 4 + 4 + data_len, type);
d1751 1
a1801 2
	packet_integrity_check(plen, 4, type);

d1803 1
a1822 2
	packet_integrity_check(plen, 4, type);

d1824 1
d1860 2
a1861 1
	packet_integrity_check(plen, 4, type);
a1888 3
	if (!compat20)
		packet_integrity_check(plen, 4 + 4, type);

a1902 1
		packet_done();
d1911 1
a1936 3
	if (!compat20)
		packet_integrity_check(plen, 4, type);

a1948 1
		packet_done();
d1956 1
a2861 2
	packet_integrity_check(plen, 4, type);

d2864 1
@


1.149
log
@setup x11 listen socket for just one connect if the client requests so.
(v2 only, but the openssh client does not support this feature).
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.148 2001/12/19 07:18:56 deraadt Exp $");
d1713 1
a1713 1
channel_input_data(int type, int plen, void *ctxt)
d1759 1
a1759 1
channel_input_extended_data(int type, int plen, void *ctxt)
d1799 1
a1799 1
channel_input_ieof(int type, int plen, void *ctxt)
d1821 1
a1821 1
channel_input_close(int type, int plen, void *ctxt)
d1860 1
a1860 1
channel_input_oclose(int type, int plen, void *ctxt)
d1871 1
a1871 1
channel_input_close_confirmation(int type, int plen, void *ctxt)
d1887 1
a1887 1
channel_input_open_confirmation(int type, int plen, void *ctxt)
d1937 1
a1937 1
channel_input_open_failure(int type, int plen, void *ctxt)
d1971 1
a1971 1
channel_input_channel_request(int type, int plen, void *ctxt)
d1996 1
a1996 1
channel_input_window_adjust(int type, int plen, void *ctxt)
d2020 1
a2020 1
channel_input_port_open(int type, int plen, void *ctxt)
d2607 1
a2607 1
x11_input_open(int type, int plen, void *ctxt)
d2654 1
a2654 1
deny_input_open(int type, int plen, void *ctxt)
d2865 1
a2865 1
auth_input_open_request(int type, int plen, void *ctxt)
@


1.148
log
@basic KNF done while i was looking for something else
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.147 2001/12/08 17:49:28 stevesk Exp $");
d266 1
d1007 5
d1038 2
a1039 2
			packet_put_int(c->local_window_max);
			packet_put_int(c->local_maxpacket);
d2408 2
a2409 1
x11_create_display_inet(int x11_display_offset, int gateway_ports)
d2411 1
d2473 1
a2473 1
		(void) channel_new("x11 listener",
d2477 2
@


1.147
log
@use only one path to X11 UNIX domain socket vs. an array of paths
to try.  report from djast@@cs.toronto.edu.  ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.146 2001/12/06 18:20:32 stevesk Exp $");
d797 1
a797 1
		      ucp[0]);
d887 1
a887 1
	char username[256];	
d934 1
a934 1
	
d1376 1
a1376 1
			     c->self, len, c->efd);
d1512 1
a1512 1
	for(i = 0; i < SSH_CHANNEL_MAX_TYPE; i++) {
d2411 2
a2412 2
	     display_number < MAX_DISPLAYS;
	     display_number++) {
d2524 1
a2524 1
			      display);
d2549 1
a2549 1
		      display);
@


1.146
log
@disable nagle for X11 fake server and client TCPs.  from netbsd.
ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.145 2001/12/06 18:09:23 stevesk Exp $");
d57 1
a2474 4
#ifndef X_UNIX_PATH
#define X_UNIX_PATH "/tmp/.X11-unix/X"
#endif

a2477 6
	static const char *const x_sockets[] = {
		X_UNIX_PATH "%u",
		"/var/X/.X11-unix/X" "%u",
		"/usr/spool/sockets/X11/" "%u",
		NULL
	};
a2479 1
	const char *const * path;
d2481 9
a2489 11
	for (path = x_sockets; *path; ++path) {
		sock = socket(AF_UNIX, SOCK_STREAM, 0);
		if (sock < 0)
			error("socket: %.100s", strerror(errno));
		memset(&addr, 0, sizeof(addr));
		addr.sun_family = AF_UNIX;
		snprintf(addr.sun_path, sizeof addr.sun_path, *path, dnr);
		if (connect(sock, (struct sockaddr *) & addr, sizeof(addr)) == 0)
			return sock;
		close(sock);
	}
@


1.145
log
@strncpy->strlcpy.  remaining strncpy's are necessary.  ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.144 2001/12/06 18:02:32 stevesk Exp $");
d996 1
a996 1
	int newsock;
d1009 4
d2509 1
a2509 1
	int display_number, sock = 0;
d2597 2
@


1.144
log
@shutdown(sock, SHUT_RDWR) not needed here; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.143 2001/12/05 10:06:12 deraadt Exp $");
d2547 1
a2547 2
	strncpy(buf, display, sizeof(buf));
	buf[sizeof(buf) - 1] = 0;
d2830 1
a2830 2
	strncpy(sunaddr.sun_path, auth_sock_name,
		sizeof(sunaddr.sun_path));
@


1.143
log
@minor KNF
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.142 2001/12/05 03:56:39 itojun Exp $");
a2427 1
				shutdown(sock, SHUT_RDWR);
a2429 1
					shutdown(socks[n], SHUT_RDWR);
a2451 1
			shutdown(sock, SHUT_RDWR);
@


1.142
log
@make it compile with more strict prototype checking
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.141 2001/11/29 21:10:51 stevesk Exp $");
d1280 1
a1280 1
		if(c->input_filter != NULL) {
d1728 1
a1728 1
	if (compat20){
d1912 1
a1912 1
	switch(reason) {
d2657 1
a2657 1
	switch(type){
@


1.141
log
@sshd X11 fake server will now listen on localhost by default:
$ echo $DISPLAY
localhost:12.0
$ netstat -an|grep 6012
tcp        0      0  127.0.0.1.6012         *.*                    LISTEN
tcp6       0      0  ::1.6012               *.*                    LISTEN
sshd_config gatewayports=yes can be used to revert back to the old
behavior.  will control this with another option later.  ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.140 2001/10/10 22:18:47 markus Exp $");
d364 1
a364 1
channel_close_all()
d405 1
a405 1
channel_not_very_much_buffered_data()
d435 1
a435 1
channel_still_open()
d478 1
a478 1
channel_find_open()
d523 1
a523 1
channel_open_message()
d1604 1
a1604 1
channel_output_poll()
d2268 1
a2268 1
channel_permit_all_opens()
d2749 1
a2749 1
auth_request_forwarding()
d2763 1
a2763 1
auth_get_socket_name()
@


1.140
log
@try to keep channels open until an exit-status message is sent.
don't kill the login shells if the shells stdin/out/err is closed.
this should now work:
ssh -2n localhost 'exec > /dev/null 2>&1; sleep 10; exit 5'; echo ?
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.139 2001/10/09 21:59:41 markus Exp $");
d2393 2
a2394 2
 * Returns a suitable value for the DISPLAY variable, or NULL if an error
 * occurs.
d2396 2
a2397 2
char *
x11_create_display_inet(int screen_number, int x11_display_offset)
a2403 2
	char display[512];
	char hostname[MAXHOSTNAMELEN];
d2411 1
a2411 1
		hints.ai_flags = AI_PASSIVE;		/* XXX loopback only ? */
d2416 1
a2416 1
			return NULL;
d2424 1
a2424 1
				return NULL;
d2447 1
a2447 1
		return NULL;
d2456 1
a2456 1
			return NULL;
a2459 6
	/* Set up a suitable value for the DISPLAY variable. */
	if (gethostname(hostname, sizeof(hostname)) < 0)
		fatal("gethostname: %.100s", strerror(errno));
	snprintf(display, sizeof display, "%.400s:%d.%d", hostname,
		 display_number, screen_number);

d2469 2
a2470 2
	/* Return a suitable value for the DISPLAY environment variable. */
	return xstrdup(display);
@


1.140.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d16 1
a16 1
 * Copyright (c) 1999, 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.171 2002/03/04 19:37:58 markus Exp $");
a56 1
#include "pathnames.h"
d148 1
a148 1
	if (id < 0 || id >= channels_alloc) {
d219 1
d248 1
a248 3
	c->ostate = CHAN_OUTPUT_OPEN;
	c->istate = CHAN_INPUT_OPEN;
	c->flags = 0;
d261 3
a264 1
	c->single_connection = 0;
a265 1
	c->confirm = NULL;
d364 1
a364 1
channel_close_all(void)
d405 1
a405 1
channel_not_very_much_buffered_data(void)
d435 1
a435 1
channel_still_open(void)
d478 1
a478 1
channel_find_open(void)
d523 1
a523 1
channel_open_message(void)
d590 1
a590 1
channel_request_start(int local_id, char *service, int wantconfirm)
d592 8
a599 1
	Channel *c = channel_lookup(local_id);
d601 1
a601 1
		log("channel_request_start: %d: unknown channel id", local_id);
a603 1
	debug("channel request %d: %s", local_id, service) ;
d610 1
a610 1
channel_register_confirm(int id, channel_callback_fn *fn)
d614 1
a614 1
		log("channel_register_comfirm: %d: bad id", id);
d617 3
a619 1
	c->confirm = fn;
d654 1
a654 1
    int extusage, int nonblock, u_int window_max)
d661 2
a662 1
	c->local_window = c->local_window_max = window_max;
d704 1
a704 1
channel_pre_open(Channel *c, fd_set * readset, fd_set * writeset)
d706 13
a718 1
	u_int limit = compat20 ? c->remote_window : packet_get_maxsize();
d720 3
d724 2
a725 2
	    limit > 0 &&
	    buffer_len(&c->input) < limit)
d736 1
a736 1
	if (compat20 && c->efd != -1) {
d787 1
a787 1
	ucp = buffer_ptr(b);
d796 1
a796 1
		    ucp[0]);
d868 4
a871 1
		channel_pre_open(c, readset, writeset);
a872 1
		log("X11 connection rejected because of wrong authentication.");
d874 2
a875 9
		chan_read_failed(c);
		buffer_clear(&c->input);
		chan_ibuf_empty(c);
		buffer_clear(&c->output);
		/* for proto v1, the peer will send an IEOF */
		if (compat20)
			chan_write_failed(c);
		else
			c->type = SSH_CHANNEL_OPEN;
d886 1
a886 1
	char username[256];
d933 1
a933 1

a1004 5
		if (c->single_connection) {
			debug("single_connection: closing X11 listener.");
			channel_close_fd(&c->sock);
			chan_mark_dead(c);
		}
a1008 1
		set_nodelay(newsock);
d1018 5
d1027 2
a1028 2
			packet_put_int(nc->local_window_max);
			packet_put_int(nc->local_maxpacket);
a1135 1
		set_nodelay(newsock);
d1140 5
d1187 5
d1213 2
a1214 1
		if (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, &err, &sz) < 0) {
d1272 1
a1272 1
				buffer_clear(&c->output);
d1280 1
a1280 1
		if (c->input_filter != NULL) {
d1314 1
a1314 1
				buffer_clear(&c->output);
d1371 1
a1371 1
			    c->self, len, c->efd);
d1406 1
a1406 1
channel_post_open(Channel *c, fd_set * readset, fd_set * writeset)
d1412 6
a1417 1
	if (!compat20)
d1419 2
d1422 1
d1435 1
a1435 1
			buffer_clear(&c->output);
d1444 1
a1444 1
	channel_pre[SSH_CHANNEL_OPEN] =			&channel_pre_open;
d1453 1
a1453 1
	channel_post[SSH_CHANNEL_OPEN] =		&channel_post_open;
d1459 1
a1459 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open;
d1475 1
a1475 1
	channel_post[SSH_CHANNEL_OPEN] =		&channel_post_open;
d1481 1
a1481 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open;
d1487 1
a1487 1
	channel_pre[SSH_CHANNEL_OPEN] =			&channel_pre_open;
d1498 1
a1498 1
	channel_post[SSH_CHANNEL_OPEN] =		&channel_post_open;
d1500 1
a1500 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open;
d1507 1
a1507 1
	for (i = 0; i < SSH_CHANNEL_MAX_TYPE; i++) {
d1604 1
a1604 1
channel_output_poll(void)
d1702 1
a1702 1
channel_input_data(int type, u_int32_t seq, void *ctxt)
d1726 1
d1728 1
a1728 1
	if (compat20) {
d1740 2
a1742 1
	packet_check_eom();
d1748 1
a1748 1
channel_input_extended_data(int type, u_int32_t seq, void *ctxt)
d1774 1
a1774 1
	packet_check_eom();
d1788 1
a1788 1
channel_input_ieof(int type, u_int32_t seq, void *ctxt)
d1793 2
a1795 1
	packet_check_eom();
d1802 1
a1802 1
	if (c->force_drain && c->istate == CHAN_INPUT_OPEN) {
a1804 2
		if (buffer_len(&c->input) == 0)
			chan_ibuf_empty(c);
d1810 1
a1810 1
channel_input_close(int type, u_int32_t seq, void *ctxt)
d1815 2
a1817 1
	packet_check_eom();
d1842 1
a1842 1
		buffer_clear(&c->input);
d1849 1
a1849 1
channel_input_oclose(int type, u_int32_t seq, void *ctxt)
d1853 1
a1853 2

	packet_check_eom();
d1860 1
a1860 1
channel_input_close_confirmation(int type, u_int32_t seq, void *ctxt)
d1865 1
a1865 1
	packet_check_eom();
d1876 1
a1876 1
channel_input_open_confirmation(int type, u_int32_t seq, void *ctxt)
d1881 3
d1898 2
a1899 1
		if (c->confirm) {
d1901 1
a1901 1
			c->confirm(c->self, NULL);
a1906 1
	packet_check_eom();
d1912 1
a1912 1
	switch (reason) {
d1926 1
a1926 1
channel_input_open_failure(int type, u_int32_t seq, void *ctxt)
d1932 3
d1947 1
a1954 1
	packet_check_eom();
d1960 26
a1985 1
channel_input_window_adjust(int type, u_int32_t seq, void *ctxt)
d2003 1
a2003 1
	packet_check_eom();
d2009 1
a2009 1
channel_input_port_open(int type, u_int32_t seq, void *ctxt)
d2025 1
a2025 1
	packet_check_eom();
d2031 6
a2036 1
		c->remote_id = remote_id;
d2055 23
a2077 3
static int
channel_setup_fwd_listener(int type, const char *listen_addr, u_short listen_port,
    const char *host_to_connect, u_short port_to_connect, int gateway_ports)
d2080 1
a2080 1
	int success, sock, on = 1;
d2082 1
a2083 1
	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
a2086 2
	host = (type == SSH_CHANNEL_RPORT_LISTENER) ?
	    listen_addr : host_to_connect;
d2088 6
a2093 3
	if (host == NULL) {
		error("No forward host name.");
		return success;
d2095 1
d2101 1
d2119 1
a2119 1
			error("channel_setup_fwd_listener: getnameinfo failed");
d2133 1
a2133 1
		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
d2136 1
a2136 1
		setsockopt(sock, SOL_SOCKET, SO_LINGER, &linger, sizeof(linger));
d2156 5
d2167 1
a2167 1
		error("channel_setup_fwd_listener: cannot listen to port: %d",
a2172 18
/* protocol local port fwd, used by ssh (and sshd in v1) */
int
channel_setup_local_fwd_listener(u_short listen_port,
    const char *host_to_connect, u_short port_to_connect, int gateway_ports)
{
	return channel_setup_fwd_listener(SSH_CHANNEL_PORT_LISTENER,
	    NULL, listen_port, host_to_connect, port_to_connect, gateway_ports);
}

/* protocol v2 remote port fwd, used by sshd */
int
channel_setup_remote_fwd_listener(const char *listen_address,
    u_short listen_port, int gateway_ports)
{
	return channel_setup_fwd_listener(SSH_CHANNEL_RPORT_LISTENER,
	    listen_address, listen_port, NULL, 0, gateway_ports);
}

d2182 1
a2182 1
	int type, success = 0;
d2209 1
a2209 1
		type = packet_read();
d2256 1
a2256 1
	channel_setup_local_fwd_listener(port, hostname, host_port, gateway_ports);
d2268 1
a2268 1
channel_permit_all_opens(void)
a2348 1
	set_nodelay(sock);
d2393 2
a2394 2
 * Returns a suitable display number for the DISPLAY variable, or -1 if
 * an error occurs.
d2396 2
a2397 3
int
x11_create_display_inet(int x11_display_offset, int x11_use_localhost,
    int single_connection)
a2398 1
	Channel *nc = NULL;
d2404 2
d2408 2
a2409 2
	    display_number < MAX_DISPLAYS;
	    display_number++) {
d2413 1
a2413 1
		hints.ai_flags = x11_use_localhost ? 0: AI_PASSIVE;
d2418 1
a2418 1
			return -1;
d2426 1
a2426 1
				return -1;
d2430 1
d2433 1
d2449 1
a2449 1
		return -1;
d2456 1
d2458 1
a2458 1
			return -1;
d2462 6
d2471 1
a2471 1
		nc = channel_new("x11 listener",
a2474 1
		nc->single_connection = single_connection;
d2477 2
a2478 2
	/* Return the display number for the DISPLAY environment variable. */
	return display_number;
d2481 4
d2488 6
d2496 1
d2498 11
a2508 9
	sock = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sock < 0)
		error("socket: %.100s", strerror(errno));
	memset(&addr, 0, sizeof(addr));
	addr.sun_family = AF_UNIX;
	snprintf(addr.sun_path, sizeof addr.sun_path, _PATH_UNIX_X, dnr);
	if (connect(sock, (struct sockaddr *) & addr, sizeof(addr)) == 0)
		return sock;
	close(sock);
d2543 1
a2543 1
			    display);
d2558 2
a2559 1
	strlcpy(buf, display, sizeof(buf));
d2569 1
a2569 1
		    display);
a2604 1
	set_nodelay(sock);
d2615 1
a2615 1
x11_input_open(int type, u_int32_t seq, void *ctxt)
d2630 1
a2630 1
	packet_check_eom();
d2639 7
a2645 2
		c->remote_id = remote_id;
		c->force_drain = 1;
d2662 1
a2662 1
deny_input_open(int type, u_int32_t seq, void *ctxt)
d2665 1
a2665 1
	switch (type) {
d2673 1
a2673 1
		error("deny_input_open: type %d", type);
d2757 1
a2757 1
auth_request_forwarding(void)
d2771 1
a2771 1
auth_get_socket_name(void)
d2842 2
a2843 1
	strlcpy(sunaddr.sun_path, auth_sock_name, sizeof(sunaddr.sun_path));
d2860 7
d2874 1
a2874 1
auth_input_open_request(int type, u_int32_t seq, void *ctxt)
d2880 2
a2883 1
	packet_check_eom();
d2901 8
a2908 2
		c->remote_id = remote_id;
		c->force_drain = 1;
@


1.140.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.173 2002/04/22 21:04:52 markus Exp $");
d709 1
a709 5
			if (CHANNEL_EFD_OUTPUT_ACTIVE(c))
                               debug2("channel %d: obuf_empty delayed efd %d/(%d)",
                                   c->self, c->efd, buffer_len(&c->extended));
			else
				chan_obuf_empty(c);
d717 1
a717 2
		else if (!(c->flags & CHAN_EOF_SENT) &&
		    c->extended_usage == CHAN_EXTENDED_READ &&
d1635 1
a1635 2
			 * tell peer, that we will not send more data: send IEOF.
			 * hack for extended data: delay EOF if EFD still in use.
d1637 1
a1637 5
			if (CHANNEL_EFD_INPUT_ACTIVE(c))
                               debug2("channel %d: ibuf_empty delayed efd %d/(%d)",
                                   c->self, c->efd, buffer_len(&c->extended));
			else
				chan_ibuf_empty(c);
a1640 1
		    !(c->flags & CHAN_EOF_SENT) &&
a1728 7
	if (c->flags & CHAN_EOF_RCVD) {
		if (datafellows & SSH_BUG_EXTEOF)
			debug("channel %d: accepting ext data after eof", id);
		else
			packet_disconnect("Received extended_data after EOF "
			    "on channel %d.", id);
	}
d2111 1
a2111 1
		packet_put_char(1);			/* boolean: want reply */
@


1.140.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.140.2.2 2002/05/17 00:03:23 miod Exp $");
d132 4
d710 2
a711 2
			       debug2("channel %d: obuf_empty delayed efd %d/(%d)",
				   c->self, c->efd, buffer_len(&c->extended));
d1644 2
a1645 2
			       debug2("channel %d: ibuf_empty delayed efd %d/(%d)",
				   c->self, c->efd, buffer_len(&c->extended));
d2673 99
@


1.140.2.4
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.179 2002/06/26 08:55:02 markus Exp $");
d49 1
d209 1
a209 1
    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)
a232 3
		if (channels_alloc > 10000)
			fatal("channel_new: internal error: channels_alloc %d "
			    "too big.", channels_alloc);
d1572 1
a1573 2
	int i;
	u_int len;
d1651 1
a1651 1
			debug2("channel %d: rwin %u elen %u euse %d",
d1721 1
d1723 1
a1723 1
	u_int data_len, tcode;
d1878 1
a1878 1
		debug("channel %d: open confirm rwindow %u rmax %u", c->self,
d1935 1
a1935 2
	int id;
	u_int adjust;
d1951 1
a1951 1
	debug2("channel %d: rcvd adjust %u", id, adjust);
d2326 2
a2327 2
 * Returns 0 and a suitable display number for the DISPLAY variable
 * stored in display_numberp , or -1 if an error occurs.
d2331 1
a2331 1
    int single_connection, u_int *display_numberp)
d2403 1
a2403 2
	*display_numberp = display_number;
	return (0);
@


1.140.2.5
log
@Update to OpenSSH 3.5
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.183 2002/09/17 07:47:02 itojun Exp $");
a574 1

a591 1

a605 1

a615 1

a625 1

a635 1

a647 1

a817 1

d869 1
a869 1
	char *p, *host;
a1397 1

a1474 1

d2009 1
d2052 2
a2053 2
		 * Set socket options.
		 * Allow local port reuse in TIME_WAIT.
d2055 4
a2058 4
		if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &on,
		    sizeof(on)) == -1)
			error("setsockopt SO_REUSEADDR: %s", strerror(errno));

a2366 4

				if (ai->ai_next)
					continue;

a2575 1

@


1.139
log
@simplify session close: no more delayed session_close, no more blocking wait() calls.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.138 2001/10/08 11:48:57 markus Exp $");
a333 4
	if (c->detach_user != NULL) {
		debug("channel_free: channel %d: detaching channel user", c->self);
		c->detach_user(c->self, NULL);
	}
d1519 22
d1558 1
a1558 18
		if (chan_is_dead(c)) {
			/*
			 * we have to remove the fd's from the select mask
			 * before the channels are free'd and the fd's are
			 * closed
			 */
			if (c->wfd != -1)
				FD_CLR(c->wfd, writeset);
			if (c->rfd != -1)
				FD_CLR(c->rfd, readset);
			if (c->efd != -1) {
				if (c->extended_usage == CHAN_EXTENDED_READ)
					FD_CLR(c->efd, readset);
				if (c->extended_usage == CHAN_EXTENDED_WRITE)
					FD_CLR(c->efd, writeset);
			}
			channel_free(c);
		}
d1629 1
a1629 1
			debug2("channel %d: no data after CLOSE", c->self);
@


1.138
log
@better debug
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.137 2001/10/07 17:49:40 markus Exp $");
a359 16
}

void
channel_detach_all(void)
{
	int i;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c != NULL && c->detach_user != NULL) {
			debug("channel_detach_all: channel %d", c->self);
			c->detach_user(c->self, NULL);
			c->detach_user = NULL;
		}
	}
@


1.137
log
@avoid possible FD_ISSET overflow for channels established
during channnel_after_select() (used for dynamic channels).
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.136 2001/10/04 15:05:40 markus Exp $");
d1143 1
a1143 1
				rtype = "direct-tcpip";
@


1.136
log
@comment out bogus conditions for selecting on connection_in
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.135 2001/10/01 21:38:53 markus Exp $");
d244 1
d978 1
a978 1

d1137 12
a1148 5
		rtype = (c->type == SSH_CHANNEL_RPORT_LISTENER) ?
		    "forwarded-tcpip" : "direct-tcpip";
		nextstate = (c->host_port == 0 &&
		    c->type != SSH_CHANNEL_RPORT_LISTENER) ?
		    SSH_CHANNEL_DYNAMIC : SSH_CHANNEL_OPENING;
d1169 8
a1176 1
		if (nextstate != SSH_CHANNEL_DYNAMIC)
d1178 1
d1428 2
d1437 2
@


1.135
log
@remove ugliness; vp@@drexel.edu via angelos
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.134 2001/09/17 21:04:01 markus Exp $");
d432 3
a434 1
			if (!compat20 && buffer_len(&c->input) > packet_get_maxsize()) {
d439 1
d441 3
a443 2
				debug("channel %d: big output buffer %d",
				    c->self, buffer_len(&c->output));
@


1.134
log
@don't send fake dummy packets on CR (\r)
bugreport from yyua@@cs.sfu.ca via solar@@@@openwall.com
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.133 2001/09/17 20:52:47 markus Exp $");
d136 1
a136 1
extern int IPv4or6;
d2039 6
@


1.133
log
@try to fix agent-forwarding-backconnection-bug, as seen on HPUX, for example;
with Lutz.Jaenicke@@aet.TU-Cottbus.DE,
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.132 2001/07/17 21:04:56 markus Exp $");
d1295 2
d1303 3
a1305 2
		len = write(c->wfd, buffer_ptr(&c->output),
		    buffer_len(&c->output));
d1322 1
a1322 1
		if (compat20 && c->isatty) {
@


1.132
log
@keep track of both maxfd and the size of the malloc'ed fdsets.
update maxfd if maxfd gets closed.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.131 2001/07/02 22:52:56 markus Exp $");
d263 1
d878 3
d1788 7
d2626 1
d2889 1
@


1.131
log
@improve cleanup/exit logic in ssh2:
stop listening to channels, detach channel users (e.g. sessions).
wait for children (i.e. dying sessions), send exit messages,
cleanup all channels.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.130 2001/06/30 18:08:39 stevesk Exp $");
d269 31
d308 4
a311 16
	if (c->sock != -1) {
		close(c->sock);
		c->sock = -1;
	}
	if (c->rfd != -1) {
		close(c->rfd);
		c->rfd = -1;
	}
	if (c->wfd != -1) {
		close(c->wfd);
		c->wfd = -1;
	}
	if (c->efd != -1) {
		close(c->efd);
		c->efd = -1;
	}
d409 1
a409 1
				close(c->sock);
d864 1
a864 1
		close(c->sock);
d1355 1
a1355 2
				close(c->efd);
				c->efd = -1;
d1370 1
a1370 2
				close(c->efd);
				c->efd = -1;
d1552 1
a1552 1
    int rekeying)
d1560 5
a1564 8
	if (*readsetp == NULL || n > *maxfdp) {
		if (*readsetp)
			xfree(*readsetp);
		if (*writesetp)
			xfree(*writesetp);
		*readsetp = xmalloc(sz);
		*writesetp = xmalloc(sz);
		*maxfdp = n;
d1566 1
@


1.130
log
@adress -> address; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.129 2001/06/29 18:40:28 stevesk Exp $");
d263 1
a263 1
	c->dettach_user = NULL;
d313 3
a315 3
	if (c->dettach_user != NULL) {
		debug("channel_free: channel %d: dettaching channel user", c->self);
		c->dettach_user(c->self, NULL);
d341 16
d373 26
d624 1
a624 1
	c->dettach_user = fn;
d634 1
a634 1
	c->dettach_user = NULL;
@


1.129
log
@use socklen_t for getsockopt arg #5; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.128 2001/06/25 08:25:35 markus Exp $");
d2267 1
a2267 1
channel_connect_by_listen_adress(u_short listen_port)
@


1.128
log
@update copyright for 2001
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.127 2001/06/23 15:12:17 itojun Exp $");
d1145 1
a1145 1
	int sz = sizeof(err);
@


1.127
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@a14 1
 *
d16 1
a16 1
 * Copyright (c) 1999,2000 Markus Friedl.  All rights reserved.
d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.126 2001/06/20 13:56:39 markus Exp $");
@


1.126
log
@move from channel_stop_listening to channel_free_all,
call channel_free_all before calling waitpid() in serverloop.
fixes the utmp handling; report from Lutz.Jaenicke@@aet.TU-Cottbus.DE
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.125 2001/06/07 20:23:04 markus Exp $");
a135 1

d140 1
a140 1
void	port_open_helper(Channel *c, char *rtype);
d166 1
a166 1
void
d272 1
a272 1
void
d635 1
a635 1
void
d641 1
a641 1
void
d648 1
a648 1
void
d657 1
a657 1
void
d674 1
a674 1
void
d700 1
a700 1
void
d712 1
a712 1
void
d730 1
a730 1
int
d788 1
a788 1
void
d813 1
a813 1
void
d832 1
a832 1
int
d902 1
a902 1
void
d942 1
a942 1
void
d1000 1
a1000 1
void
d1054 1
a1054 1
void
d1102 1
a1102 1
void
d1142 1
a1142 1
void
d1189 1
a1189 1
int
d1227 1
a1227 1
int
d1275 1
a1275 1
int
d1320 1
a1320 1
int
d1340 1
a1340 1
void
d1347 1
a1347 1
void
d1357 1
a1357 1
void
d1372 1
a1372 1
void
d1393 1
a1393 1
void
d1415 1
a1415 1
void
d1434 1
a1434 1
void
d1450 1
a1450 1
void
d1830 1
a1830 1
char *
d2216 1
a2216 1
int
d2400 1
a2400 2
static
int
@


1.125
log
@use xxx_put_cstring()
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.124 2001/06/05 10:24:32 markus Exp $");
d226 1
a226 5
		/*
		 * Kludge: arrange a call to channel_stop_listening if we
		 * terminate with fatal().
		 */
		fatal_add_cleanup((void (*) (void *)) channel_stop_listening, NULL);
a332 6

/*
 * Stops listening for channels, and removes any unix domain sockets that we
 * might have.
 */

d334 1
a334 1
channel_stop_listening()
a336 1
	Channel *c;
d338 3
a340 20
	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c != NULL) {
			switch (c->type) {
			case SSH_CHANNEL_AUTH_SOCKET:
				close(c->sock);
				/* auth_sock_cleanup_proc deletes the socket */
				channel_free(c);
				break;
			case SSH_CHANNEL_PORT_LISTENER:
			case SSH_CHANNEL_RPORT_LISTENER:
			case SSH_CHANNEL_X11_LISTENER:
				close(c->sock);
				channel_free(c);
				break;
			default:
				break;
			}
		}
	}
@


1.124
log
@don't delete the auth socket in channel_stop_listening()
auth_sock_cleanup_proc() will take care of this.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.123 2001/06/04 21:59:42 markus Exp $");
d1022 1
a1022 1
				packet_put_string(buf, strlen(buf));
@


1.123
log
@switch uid when cleaning up tmp files and sockets; reported by zen-parse@@gmx.net on bugtraq
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.122 2001/06/03 14:55:38 markus Exp $");
d355 1
a355 1
				unlink(c->path);
d2807 1
@


1.122
log
@use fatal_register_cleanup instead of atexit, sync with x11 authdir handling
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.121 2001/05/31 10:30:14 markus Exp $");
d2723 1
a2723 1
auth_sock_cleanup_proc(void *ignored)
d2725 2
d2728 1
d2732 1
d2776 1
a2776 1
	fatal_add_cleanup(auth_sock_cleanup_proc, NULL);
d2806 1
a2806 1
		auth_sock_cleanup_proc(NULL);
@


1.121
log
@undo the .c file split, just merge the header and keep the cvs history
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.123 2001/05/31 09:57:42 markus Exp $");
d2723 1
a2723 1
cleanup_socket(void)
d2725 5
a2729 2
	unlink(auth_sock_name);
	rmdir(auth_sock_dir);
d2771 3
a2773 5
	if (atexit(cleanup_socket) < 0) {
		int saved = errno;
		cleanup_socket();
		packet_disconnect("socket: %.100s", strerror(saved));
	}
d2802 1
@


1.120
log
@channel layer cleanup: merge header files and split .c files
@
text
@d43 1
a43 4
RCSID("$OpenBSD: channels.c,v 1.119 2001/05/28 23:25:24 markus Exp $");

#include <openssl/rsa.h>
#include <openssl/dsa.h>
a49 2
#include "buffer.h"
#include "bufaux.h"
a53 1
#include "nchan.h"
a58 2
/* Maximum number of fake X11 displays to try. */
#define MAX_DISPLAYS  1000
d60 1
a60 2
/* Max len of agent socket */
#define MAX_SOCKET_NAME 100
a79 10
/* Name and directory of socket for authentication agent forwarding. */
static char *channel_forwarded_auth_socket_name = NULL;
static char *channel_forwarded_auth_socket_dir = NULL;

/* Saved X11 authentication protocol name. */
char *x11_saved_proto = NULL;

/* Saved X11 authentication data.  This is the real data. */
char *x11_saved_data = NULL;
u_int x11_saved_data_len = 0;
d81 1
a81 6
/*
 * Fake X11 authentication data.  This is what the server will be sending us;
 * we should replace any occurrences of this by the real data.
 */
char *x11_fake_data = NULL;
u_int x11_fake_data_len;
d97 1
d107 29
a135 2
/* This is set to true if both sides support SSH_PROTOFLAG_HOST_IN_FWD_OPEN. */
static int have_hostname_in_open = 0;
d140 2
a141 1
void	 port_open_helper(Channel *c, char *rtype);
d143 1
a143 9
/* Sets specific protocol options. */

void
channel_set_options(int hostname_in_open)
{
	have_hostname_in_open = hostname_in_open;
}

/* lookup channel by id */
d289 332
a620 1
		c->rfd = -1;
d622 9
a630 7
	if (c->wfd != -1) {
		close(c->wfd);
		c->wfd = -1;
	}
	if (c->efd != -1) {
		close(c->efd);
		c->efd = -1;
d632 1
a634 2
/* Free the channel and close its fd/socket. */

d636 2
a637 1
channel_free(Channel *c)
d639 11
a649 29
	char *s;
	int i, n;

	for (n = 0, i = 0; i < channels_alloc; i++)
		if (channels[i])
			n++;
	debug("channel_free: channel %d: %s, nchannels %d", c->self,
	    c->remote_name ? c->remote_name : "???", n);

	s = channel_open_message();
	debug3("channel_free: status: %s", s);
	xfree(s);

	if (c->dettach_user != NULL) {
		debug("channel_free: channel %d: dettaching channel user", c->self);
		c->dettach_user(c->self, NULL);
	}
	if (c->sock != -1)
		shutdown(c->sock, SHUT_RDWR);
	channel_close_fds(c);
	buffer_free(&c->input);
	buffer_free(&c->output);
	buffer_free(&c->extended);
	if (c->remote_name) {
		xfree(c->remote_name);
		c->remote_name = NULL;
	}
	channels[c->self] = NULL;
	xfree(c);
d757 1
d760 1
a760 1
x11_open_helper(Channel *c)
d766 1
a766 1
	if (buffer_len(&c->output) < 12)
d770 1
a770 1
	ucp = (u_char *) buffer_ptr(&c->output);
d784 1
a784 1
	if (buffer_len(&c->output) <
d820 1
a820 1
	int ret = x11_open_helper(c);
d845 1
a845 1
	int ret = x11_open_helper(c);
d1020 2
a1021 1
			if (have_hostname_in_open)
d1072 2
a1073 1
		if (have_hostname_in_open)
d1135 1
d1147 1
d1151 1
a1151 1
		    0, xstrdup("accepted auth socket"), 1);
d1154 1
d1239 1
a1239 1
				debug("channel %d: status set to input draining.", c->self);
d1277 1
a1277 1
				debug("channel %d: status set to input draining.", c->self);
d1517 4
d1547 4
d1557 1
a1566 1

d1571 4
a1574 1
		/* We are only interested in channels that can have buffered incoming data. */
d1594 4
a1597 1
			/* Send some data for the other side over the secure connection. */
d1655 2
a1656 5
/*
 * This is called when a packet of type CHANNEL_DATA has just been received.
 * The message type has already been consumed, but channel number and data is
 * still there.
 */
d1703 1
a1743 30

/*
 * Returns true if no channel has too much buffered data, and false if one or
 * more channel is overfull.
 */

int
channel_not_very_much_buffered_data()
{
	u_int i;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c != NULL && c->type == SSH_CHANNEL_OPEN) {
			if (!compat20 && buffer_len(&c->input) > packet_get_maxsize()) {
				debug("channel %d: big input buffer %d",
				    c->self, buffer_len(&c->input));
				return 0;
			}
			if (buffer_len(&c->output) > packet_get_maxsize()) {
				debug("channel %d: big output buffer %d",
				    c->self, buffer_len(&c->output));
				return 0;
			}
		}
	}
	return 1;
}

d1934 12
a1945 155
void
channel_input_window_adjust(int type, int plen, void *ctxt)
{
	Channel *c;
	int id, adjust;

	if (!compat20)
		return;

	/* Get the channel number and verify it. */
	id = packet_get_int();
	c = channel_lookup(id);

	if (c == NULL || c->type != SSH_CHANNEL_OPEN) {
		log("Received window adjust for "
		    "non-open channel %d.", id);
		return;
	}
	adjust = packet_get_int();
	packet_done();
	debug2("channel %d: rcvd adjust %d", id, adjust);
	c->remote_window += adjust;
}

/*
 * Stops listening for channels, and removes any unix domain sockets that we
 * might have.
 */

void
channel_stop_listening()
{
	int i;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c != NULL) {
			switch (c->type) {
			case SSH_CHANNEL_AUTH_SOCKET:
				close(c->sock);
				unlink(c->path);
				channel_free(c);
				break;
			case SSH_CHANNEL_PORT_LISTENER:
			case SSH_CHANNEL_RPORT_LISTENER:
			case SSH_CHANNEL_X11_LISTENER:
				close(c->sock);
				channel_free(c);
				break;
			default:
				break;
			}
		}
	}
}

/*
 * Closes the sockets/fds of all channels.  This is used to close extra file
 * descriptors after a fork.
 */

void
channel_close_all()
{
	int i;

	for (i = 0; i < channels_alloc; i++)
		if (channels[i] != NULL)
			channel_close_fds(channels[i]);
}

/* Returns true if any channel is still open. */

int
channel_still_open()
{
	int i;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c == NULL)
			continue;
		switch (c->type) {
		case SSH_CHANNEL_X11_LISTENER:
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_RPORT_LISTENER:
		case SSH_CHANNEL_CLOSED:
		case SSH_CHANNEL_AUTH_SOCKET:
		case SSH_CHANNEL_DYNAMIC:
		case SSH_CHANNEL_CONNECTING:
		case SSH_CHANNEL_ZOMBIE:
			continue;
		case SSH_CHANNEL_LARVAL:
			if (!compat20)
				fatal("cannot happen: SSH_CHANNEL_LARVAL");
			continue;
		case SSH_CHANNEL_OPENING:
		case SSH_CHANNEL_OPEN:
		case SSH_CHANNEL_X11_OPEN:
			return 1;
		case SSH_CHANNEL_INPUT_DRAINING:
		case SSH_CHANNEL_OUTPUT_DRAINING:
			if (!compat13)
				fatal("cannot happen: OUT_DRAIN");
			return 1;
		default:
			fatal("channel_still_open: bad channel type %d", c->type);
			/* NOTREACHED */
		}
	}
	return 0;
}

/* Returns the id of an open channel suitable for keepaliving */

int
channel_find_open()
{
	int i;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c == NULL)
			continue;
		switch (c->type) {
		case SSH_CHANNEL_CLOSED:
		case SSH_CHANNEL_DYNAMIC:
		case SSH_CHANNEL_X11_LISTENER:
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_RPORT_LISTENER:
		case SSH_CHANNEL_OPENING:
		case SSH_CHANNEL_CONNECTING:
		case SSH_CHANNEL_ZOMBIE:
			continue;
		case SSH_CHANNEL_LARVAL:
		case SSH_CHANNEL_AUTH_SOCKET:
		case SSH_CHANNEL_OPEN:
		case SSH_CHANNEL_X11_OPEN:
			return i;
		case SSH_CHANNEL_INPUT_DRAINING:
		case SSH_CHANNEL_OUTPUT_DRAINING:
			if (!compat13)
				fatal("cannot happen: OUT_DRAIN");
			return i;
		default:
			fatal("channel_find_open: bad channel type %d", c->type);
			/* NOTREACHED */
		}
	}
	return -1;
}

d1947 10
a1956 5
/*
 * Returns a message describing the currently open forwarded connections,
 * suitable for sending to the client.  The message contains crlf pairs for
 * newlines.
 */
d1958 2
a1959 2
char *
channel_open_message()
d1961 8
a1968 4
	Buffer buffer;
	Channel *c;
	char buf[1024], *cp;
	int i;
d1970 16
a1985 34
	buffer_init(&buffer);
	snprintf(buf, sizeof buf, "The following connections are open:\r\n");
	buffer_append(&buffer, buf, strlen(buf));
	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c == NULL)
			continue;
		switch (c->type) {
		case SSH_CHANNEL_X11_LISTENER:
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_RPORT_LISTENER:
		case SSH_CHANNEL_CLOSED:
		case SSH_CHANNEL_AUTH_SOCKET:
		case SSH_CHANNEL_ZOMBIE:
			continue;
		case SSH_CHANNEL_LARVAL:
		case SSH_CHANNEL_OPENING:
		case SSH_CHANNEL_CONNECTING:
		case SSH_CHANNEL_DYNAMIC:
		case SSH_CHANNEL_OPEN:
		case SSH_CHANNEL_X11_OPEN:
		case SSH_CHANNEL_INPUT_DRAINING:
		case SSH_CHANNEL_OUTPUT_DRAINING:
			snprintf(buf, sizeof buf, "  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n",
			    c->self, c->remote_name,
			    c->type, c->remote_id,
			    c->istate, buffer_len(&c->input),
			    c->ostate, buffer_len(&c->output),
			    c->rfd, c->wfd);
			buffer_append(&buffer, buf, strlen(buf));
			continue;
		default:
			fatal("channel_open_message: bad channel type %d", c->type);
			/* NOTREACHED */
d1988 6
a1993 4
	buffer_append(&buffer, "\0", 1);
	cp = xstrdup(buffer_ptr(&buffer));
	buffer_free(&buffer);
	return cp;
d1996 3
d2024 1
a2024 1
	int success, sock, on = 1, ctype;
d2034 1
a2034 1
		ctype = SSH_CHANNEL_RPORT_LISTENER;
d2037 1
a2037 1
		ctype  =SSH_CHANNEL_PORT_LISTENER;
d2097 1
a2097 1
		c = channel_new("port listener", ctype, sock, sock, -1,
d2333 1
a2333 43
/*
 * This is called after receiving PORT_OPEN message.  This attempts to
 * connect to the given host:port, and sends back CHANNEL_OPEN_CONFIRMATION
 * or CHANNEL_OPEN_FAILURE.
 */

void
channel_input_port_open(int type, int plen, void *ctxt)
{
	Channel *c = NULL;
	u_short host_port;
	char *host, *originator_string;
	int remote_id, sock = -1;

	remote_id = packet_get_int();
	host = packet_get_string(NULL);
	host_port = packet_get_int();

	if (have_hostname_in_open) {
		originator_string = packet_get_string(NULL);
	} else {
		originator_string = xstrdup("unknown (remote did not supply name)");
	}
	packet_done();
	sock = channel_connect_to(host, host_port);
	if (sock != -1) {
		c = channel_new("connected socket",
		    SSH_CHANNEL_CONNECTING, sock, sock, -1, 0, 0, 0,
		    originator_string, 1);
		if (c == NULL) {
			error("channel_input_port_open: channel_new failed");
			close(sock);
		} else {
			c->remote_id = remote_id;
		}
	}
	if (c == NULL) {
		packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(remote_id);
		packet_send();
	}
	xfree(host);
}
a2339 3

#define	NUM_SOCKS	10

d2569 2
a2570 1
	if (have_hostname_in_open) {
d2629 1
a2630 1

d2695 3
d2717 1
a2717 1
	return channel_forwarded_auth_socket_name;
d2725 2
a2726 2
	unlink(channel_forwarded_auth_socket_name);
	rmdir(channel_forwarded_auth_socket_dir);
d2741 4
a2744 2
	if (auth_get_socket_name() != NULL)
		fatal("Protocol error: authentication forwarding requested twice.");
d2750 3
a2752 3
	channel_forwarded_auth_socket_name = xmalloc(MAX_SOCKET_NAME);
	channel_forwarded_auth_socket_dir = xmalloc(MAX_SOCKET_NAME);
	strlcpy(channel_forwarded_auth_socket_dir, "/tmp/ssh-XXXXXXXX", MAX_SOCKET_NAME);
d2755 3
a2757 3
	if (mkdtemp(channel_forwarded_auth_socket_dir) == NULL) {
		packet_send_debug("Agent forwarding disabled: mkdtemp() failed: %.100s",
		    strerror(errno));
d2759 4
a2762 4
		xfree(channel_forwarded_auth_socket_name);
		xfree(channel_forwarded_auth_socket_dir);
		channel_forwarded_auth_socket_name = NULL;
		channel_forwarded_auth_socket_dir = NULL;
d2765 2
a2766 2
	snprintf(channel_forwarded_auth_socket_name, MAX_SOCKET_NAME, "%s/agent.%d",
		 channel_forwarded_auth_socket_dir, (int) getpid());
d2781 1
a2781 1
	strncpy(sunaddr.sun_path, channel_forwarded_auth_socket_name,
d2804 1
a2804 1
	strlcpy(nc->path, channel_forwarded_auth_socket_name, sizeof(nc->path));
d2815 1
a2815 1
	char *dummyname;
d2835 3
a2837 2
		dummyname = xstrdup("authentication agent connection");
		c = channel_new("", SSH_CHANNEL_OPEN, sock, sock, -1, 0, 0, 0, dummyname, 1);
d2840 1
a2855 102
	packet_send();
}

void
channel_start_open(int id)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_open: %d: bad id", id);
		return;
	}
	debug("send channel open %d", id);
	packet_start(SSH2_MSG_CHANNEL_OPEN);
	packet_put_cstring(c->ctype);
	packet_put_int(c->self);
	packet_put_int(c->local_window);
	packet_put_int(c->local_maxpacket);
}
void
channel_open(int id)
{
	/* XXX REMOVE ME */
	channel_start_open(id);
	packet_send();
}
void
channel_request(int id, char *service, int wantconfirm)
{
	channel_request_start(id, service, wantconfirm);
	packet_send();
	debug("channel request %d: %s", id, service) ;
}
void
channel_request_start(int id, char *service, int wantconfirm)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_request: %d: bad id", id);
		return;
	}
	packet_start(SSH2_MSG_CHANNEL_REQUEST);
	packet_put_int(c->remote_id);
	packet_put_cstring(service);
	packet_put_char(wantconfirm);
}
void
channel_register_callback(int id, int mtype, channel_callback_fn *fn, void *arg)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_register_callback: %d: bad id", id);
		return;
	}
	c->cb_event = mtype;
	c->cb_fn = fn;
	c->cb_arg = arg;
}
void
channel_register_cleanup(int id, channel_callback_fn *fn)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_register_cleanup: %d: bad id", id);
		return;
	}
	c->dettach_user = fn;
}
void
channel_cancel_cleanup(int id)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_cancel_cleanup: %d: bad id", id);
		return;
	}
	c->dettach_user = NULL;
}
void
channel_register_filter(int id, channel_filter_fn *fn)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_register_filter: %d: bad id", id);
		return;
	}
	c->input_filter = fn;
}

void
channel_set_fds(int id, int rfd, int wfd, int efd,
    int extusage, int nonblock)
{
	Channel *c = channel_lookup(id);
	if (c == NULL || c->type != SSH_CHANNEL_LARVAL)
		fatal("channel_activate for non-larval channel %d.", id);
	channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
	c->type = SSH_CHANNEL_OPEN;
	/* XXX window size? */
	c->local_window = c->local_window_max = c->local_maxpacket * 2;
	packet_start(SSH2_MSG_CHANNEL_WINDOW_ADJUST);
	packet_put_int(c->remote_id);
	packet_put_int(c->local_window);
@


1.119
log
@cleanup, typo
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.118 2001/05/28 23:14:49 markus Exp $");
@


1.118
log
@undo broken channel fix and try a different one. there
should be still some select errors...
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.117 2001/05/19 19:57:09 stevesk Exp $");
d315 1
a315 2

	debug("channel_free: channel %d: (%s) nchannels: %d", c->self,
d319 1
a319 1
	debug3("channel_free: status: %s", c->self, s);
@


1.117
log
@typo in error message
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.116 2001/05/16 22:09:20 markus Exp $");
d283 3
d310 8
d320 1
a320 1
	debug("channel_free: channel %d: status: %s", c->self, s);
d907 1
a907 1
	if (c->istate == CHAN_INPUT_OPEN &&
d946 1
a946 2
	if ((c->ostate == CHAN_OUTPUT_OPEN ||
	    c->ostate == CHAN_OUTPUT_WAIT_DRAIN) &&
d1177 2
a1178 3
		if (ftab[c->type] == NULL)
			continue;
		(*ftab[c->type])(c, readset, writeset);
d1727 1
d1770 1
d1818 1
@


1.116
log
@more select() error fixes (don't set rfd/wfd to -1).
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.115 2001/05/09 22:51:57 markus Exp $");
d1564 1
a1564 1
	return "unkown reason";
@


1.115
log
@fix -R for protocol 2, noticed by greg@@nest.cx.
bug was introduced with experimental dynamic forwarding.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.114 2001/05/08 19:17:30 markus Exp $");
d896 1
a896 1
	if (c->rfd != -1 &&
d935 2
a936 1
	if (c->wfd != -1 &&
@


1.114
log
@adds correct error reporting to async connect()s
fixes the server-discards-data-before-connected-bug found by onoe@@sm.sony.co.jp
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.113 2001/05/04 23:47:33 markus Exp $");
d774 3
a776 2
		nextstate = (c->host_port == 0) ? SSH_CHANNEL_DYNAMIC :
		    SSH_CHANNEL_OPENING;
@


1.113
log
@move to Channel **channels (instead of Channel *channels), fixes realloc problems.
channel_new now returns a Channel *, favour Channel * over channel id.
remove old channel_allocate interface.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.112 2001/05/04 14:34:34 markus Exp $");
d845 3
d849 19
a867 5
		int err = 0;
		int sz = sizeof(err);
		c->type = SSH_CHANNEL_OPEN;
		if (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, (char *)&err, &sz) < 0) {
			debug("getsockopt SO_ERROR failed");
d869 10
a878 2
			if (err == 0) {
				debug("channel %d: connected", c->self);
d880 2
a881 4
				debug("channel %d: not connected: %s",
				    c->self, strerror(err));
				chan_read_failed(c);
				chan_write_failed(c);
d883 1
d885 1
d1549 16
d1588 2
a1589 2
		log("channel_open_failure: %d: reason %d %s", id,
		    reason, msg ? msg : "<no additional info>");
d1715 1
a1715 1
		case SSH_CHANNEL_CONNECTING: 	/* XXX ??? */
d1757 1
a1760 1
		case SSH_CHANNEL_CONNECTING: 	/* XXX ??? */
d2206 1
a2206 5
	} else {
		/*XXX delay answer? */
		packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
		packet_put_int(remote_id);
		packet_put_int(c->self);
a2207 1
	packet_send();
@


1.112
log
@channel_new() reallocs channels[], we cannot use Channel *c after calling
channel_new(), XXX fix this in the future...
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.111 2001/05/03 15:07:39 stevesk Exp $");
d75 1
a75 1
static Channel *channels = NULL;
d79 1
a79 2
 * initialized (at least the type field); unused slots are marked with type
 * SSH_CHANNEL_FREE.
d85 1
a85 1
 * updated in channel_allocate.
d152 1
d157 2
a158 2
	c = &channels[id];
	if (c->type == SSH_CHANNEL_FREE) {
d215 1
a215 1
int
d226 1
a226 1
		channels = xmalloc(channels_alloc * sizeof(Channel));
d228 1
a228 1
			channels[i].type = SSH_CHANNEL_FREE;
d237 1
a237 1
		if (channels[i].type == SSH_CHANNEL_FREE) {
d247 1
a247 1
		channels = xrealloc(channels, channels_alloc * sizeof(Channel));
d249 1
a249 1
			channels[i].type = SSH_CHANNEL_FREE;
d251 2
a252 2
	/* Initialize and return new channel number. */
	c = &channels[found];
d275 1
a275 1
	return found;
a276 7
/* old interface XXX */
int
channel_allocate(int type, int sock, char *remote_name)
{
	return channel_new("", type, sock, sock, -1, 0, 0, 0, remote_name, 1);
}

d304 1
a304 1
channel_free(int id)
d306 1
a306 2
	Channel *c = channel_lookup(id);
	char *s = channel_open_message();
d308 2
a309 3
	if (c == NULL)
		packet_disconnect("channel free: bad local channel %d", id);
	debug("channel_free: channel %d: status: %s", id, s);
d313 1
a313 1
		debug("channel_free: channel %d: dettaching channel user", id);
a321 1
	c->type = SSH_CHANNEL_FREE;
d326 2
d423 1
a423 1
		channel_free(c->self);
d635 1
a635 1
		channel_free(c->self);
d651 1
d653 1
a653 1
	int newsock, newch, oldch;
d671 1
a671 2
		oldch = c->self;
		newch = channel_new("x11",
d675 5
a679 1
		c = channel_lookup(oldch);
d683 1
a683 1
			packet_put_int(newch);
d696 1
a696 1
			packet_put_int(newch);
d763 1
a763 1
	int newsock, newch, nextstate, oldch;
d783 1
a783 2
		oldch = c->self;
		newch = channel_new(rtype,
a786 3

		c = channel_lookup(oldch);
		nc = channel_lookup(newch);
d788 2
a789 1
			error("xxx: no new channel:");
d808 2
a810 1
	int newsock, newch, oldch;
d820 1
a820 2
		oldch = c->self;
		newch = channel_new("accepted auth socket",
d824 4
a827 1
		c = channel_lookup(oldch);
d831 1
a831 1
			packet_put_int(newch);
d836 1
a836 1
			packet_put_int(newch);
d880 1
a880 1
				channel_free(c->self);
d919 1
a919 1
				channel_free(c->self);
d1137 2
a1138 2
		c = &channels[i];
		if (c->type == SSH_CHANNEL_FREE)
a1142 1
		c = &channels[i]; /* XXX realloc */
d1159 1
a1159 1
			channel_free(c->self);
d1205 4
a1208 1
		c = &channels[i];
d1392 2
a1393 2
		c = &channels[i];
		if (c->type == SSH_CHANNEL_OPEN) {
d1487 1
a1487 1
	channel_free(c->self);
d1555 1
a1555 1
	channel_free(id);
d1616 2
d1619 17
a1635 14
		switch (channels[i].type) {
		case SSH_CHANNEL_AUTH_SOCKET:
			close(channels[i].sock);
			unlink(channels[i].path);
			channel_free(i);
			break;
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_RPORT_LISTENER:
		case SSH_CHANNEL_X11_LISTENER:
			close(channels[i].sock);
			channel_free(i);
			break;
		default:
			break;
d1649 1
d1651 2
a1652 2
		if (channels[i].type != SSH_CHANNEL_FREE)
			channel_close_fds(&channels[i]);
d1660 8
a1667 4
	u_int i;
	for (i = 0; i < channels_alloc; i++)
		switch (channels[i].type) {
		case SSH_CHANNEL_FREE:
d1690 1
a1690 1
			fatal("channel_still_open: bad channel type %d", channels[i].type);
d1693 1
d1702 8
a1709 3
	u_int i;
	for (i = 0; i < channels_alloc; i++)
		switch (channels[i].type) {
a1711 1
		case SSH_CHANNEL_FREE:
d1729 1
a1729 1
			fatal("channel_find_open: bad channel type %d", channels[i].type);
d1732 1
d1747 2
a1749 1
	char buf[512], *cp;
d1755 3
a1757 1
		Channel *c = &channels[i];
a1758 1
		case SSH_CHANNEL_FREE:
d1816 2
a1817 1
	int success, ch, sock, on = 1, ctype;
d1833 1
a1833 1
	if (strlen(host) > sizeof(channels[0].path) - 1) {
d1890 1
a1890 1
		ch = channel_new("port listener", ctype, sock, sock, -1,
d1893 8
a1900 3
		strlcpy(channels[ch].path, host, sizeof(channels[ch].path));
		channels[ch].host_port = port_to_connect;
		channels[ch].listening_port = listen_port;
d2135 1
d2138 1
a2138 1
	int remote_channel, sock = -1, newch;
d2140 1
a2140 1
	remote_channel = packet_get_int();
d2152 14
a2165 4
		newch = channel_allocate(SSH_CHANNEL_CONNECTING,
		    sock, originator_string);
		channels[newch].remote_id = remote_channel;

d2168 2
a2169 7
		packet_put_int(remote_channel);
		packet_put_int(newch);
		packet_send();
	} else {
		packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(remote_channel);
		packet_send();
d2171 1
d2405 2
a2406 1
	int remote_channel, sock = 0, newch;
a2407 1
	u_int remote_len;
d2409 1
a2409 2
	/* Get remote channel number. */
	remote_channel = packet_get_int();
d2411 1
a2411 1
	/* Get remote originator name. */
d2413 1
a2413 2
		remote_host = packet_get_string(&remote_len);
		remote_len += 4;
a2415 1
		remote_len = 0;
d2417 1
a2417 3

	debug("Received X11 open request.");
	packet_integrity_check(plen, 4 + remote_len, SSH_SMSG_X11_OPEN);
d2421 13
a2433 1
	if (sock == -1) {
d2436 1
a2436 2
		packet_put_int(remote_channel);
		packet_send();
a2437 7
		/* Allocate a channel for this connection. */
		newch = channel_allocate(
		     (x11_saved_proto == NULL) ?
		     SSH_CHANNEL_OPEN : SSH_CHANNEL_X11_OPEN,
		     sock, remote_host);
		channels[newch].remote_id = remote_channel;

d2440 2
a2441 3
		packet_put_int(remote_channel);
		packet_put_int(newch);
		packet_send();
d2443 1
d2576 2
a2577 1
	int sock, newch;
d2632 1
a2632 1
	newch = channel_new("auth socket",
d2636 6
a2641 3

	strlcpy(channels[newch].path, channel_forwarded_auth_socket_name,
	    sizeof(channels[newch].path));
d2650 2
a2651 1
	int remch, sock, newch;
d2657 1
a2657 1
	remch = packet_get_int();
d2671 11
a2681 1
	if (sock < 0) {
d2683 7
a2689 3
		packet_put_int(remch);
		packet_send();
		return;
a2690 16
	debug("Forwarding authentication connection.");

	/*
	 * Dummy host name.  This will be freed when the channel is freed; it
	 * will still be valid in the packet_put_string below since the
	 * channel cannot yet be freed at that point.
	 */
	dummyname = xstrdup("authentication agent connection");

	newch = channel_allocate(SSH_CHANNEL_OPEN, sock, dummyname);
	channels[newch].remote_id = remch;

	/* Send a confirmation to the remote host. */
	packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
	packet_put_int(remch);
	packet_put_int(newch);
@


1.111
log
@typo in debug() string
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.110 2001/04/29 19:16:52 markus Exp $");
d660 1
a660 1
	int newsock, newch;
d678 1
d683 1
d767 1
a767 1
	int newsock, newch, nextstate;
d787 1
d793 1
d816 1
a816 1
	int newsock, newch;
d826 1
d831 1
d1147 1
@


1.110
log
@more ssh.com-2.0.x bug-compat; from per@@appgate.com
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.109 2001/04/17 12:55:03 markus Exp $");
d851 1
a851 1
				debug("channel %d: connected)", c->self);
@


1.109
log
@undo socks5 and https support since they are not really used and
only bloat ssh.  remove -D from usage(), since '-D' is experimental.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.108 2001/04/14 16:17:14 markus Exp $");
d1537 1
a1537 1
		if (packet_remaining() > 0) {
@


1.109.2.1
log
@Pull in patch from current:
Fix (markus):
- use fatal_register_cleanup instead of atexit, sync with x11 authdir handling
- switch uid when cleaning up tmp files and sockets; reported by zen-parse@@gmx.net on bugtraq
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.109 2001/04/17 12:55:03 markus Exp $");
d2527 1
a2527 1
auth_sock_cleanup_proc(void *_pw)
d2529 2
a2530 9
	struct passwd *pw = _pw;

	if (channel_forwarded_auth_socket_name) {
		temporarily_use_uid(pw);
		unlink(channel_forwarded_auth_socket_name);
		rmdir(channel_forwarded_auth_socket_dir);
		channel_forwarded_auth_socket_name = NULL;
		restore_uid();
	}
d2569 5
a2573 3
	/* delete agent socket on fatal() */
	fatal_add_cleanup(auth_sock_cleanup_proc, pw);

@


1.109.2.2
log
@Pull patch from current:
Fix (markus):
Unbreak -R forwarding for protocol 2
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.109.2.1 2001/06/12 22:31:48 jason Exp $");
d776 2
a777 3
		nextstate = (c->host_port == 0 &&
		    c->type != SSH_CHANNEL_RPORT_LISTENER) ?
		    SSH_CHANNEL_DYNAMIC : SSH_CHANNEL_OPENING;
@


1.109.2.3
log
@Pull in OpenSSH-2.9.9
@
text
@d15 1
d17 1
a17 1
 * Copyright (c) 1999, 2000, 2001 Markus Friedl.  All rights reserved.
d43 4
a46 1
RCSID("$OpenBSD: channels.c,v 1.134 2001/09/17 21:04:01 markus Exp $");
d53 2
d59 1
d65 2
d68 2
a69 1
/* -- channel core */
d75 1
a75 1
static Channel **channels = NULL;
d79 2
a80 1
 * initialized (at least the type field); unused slots set to NULL
d86 1
a86 1
 * updated in channel_new.
d90 3
d94 13
a106 1
/* -- tcp forwarding */
a121 1

d131 2
d134 2
a135 1
/* -- X11 forwarding */
d137 1
a137 2
/* Maximum number of fake X11 displays to try. */
#define MAX_DISPLAYS  1000
d139 1
a139 2
/* Saved X11 authentication protocol name. */
static char *x11_saved_proto = NULL;
d141 5
a145 25
/* Saved X11 authentication data.  This is the real data. */
static char *x11_saved_data = NULL;
static u_int x11_saved_data_len = 0;

/*
 * Fake X11 authentication data.  This is what the server will be sending us;
 * we should replace any occurrences of this by the real data.
 */
static char *x11_fake_data = NULL;
static u_int x11_fake_data_len;


/* -- agent forwarding */

#define	NUM_SOCKS	10

/* Name and directory of socket for authentication agent forwarding. */
static char *auth_sock_name = NULL;
static char *auth_sock_dir = NULL;

/* AF_UNSPEC or AF_INET or AF_INET6 */
extern int IPv4or6;

/* helper */
static void port_open_helper(Channel *c, char *rtype);
d147 1
a147 1
/* -- channel core */
a152 1

d157 2
a158 2
	c = channels[id];
	if (c == NULL) {
d170 1
a170 1
static void
d215 1
a215 1
Channel *
d226 1
a226 1
		channels = xmalloc(channels_alloc * sizeof(Channel *));
d228 6
a233 2
			channels[i] = NULL;
		fatal_add_cleanup((void (*) (void *)) channel_free_all, NULL);
d237 1
a237 1
		if (channels[i] == NULL) {
d247 1
a247 1
		channels = xrealloc(channels, channels_alloc * sizeof(Channel *));
d249 1
a249 1
			channels[i] = NULL;
d251 2
a252 2
	/* Initialize and return new channel. */
	c = channels[found] = xmalloc(sizeof(Channel));
d272 1
a272 2
	c->force_drain = 0;
	c->detach_user = NULL;
d275 1
a275 221
	return c;
}

static int
channel_find_maxfd(void)
{
	int i, max = 0;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c != NULL) {
			max = MAX(max, c->rfd);
			max = MAX(max, c->wfd);
			max = MAX(max, c->efd);
		}
	}
	return max;
}

int
channel_close_fd(int *fdp)
{
	int ret = 0, fd = *fdp;

	if (fd != -1) {
		ret = close(fd);
		*fdp = -1;
		if (fd == channel_max_fd)
			channel_max_fd = channel_find_maxfd();
	}
	return ret;
}

/* Close all channel fd/socket. */

static void
channel_close_fds(Channel *c)
{
	debug3("channel_close_fds: channel %d: r %d w %d e %d",
	    c->self, c->rfd, c->wfd, c->efd);

	channel_close_fd(&c->sock);
	channel_close_fd(&c->rfd);
	channel_close_fd(&c->wfd);
	channel_close_fd(&c->efd);
}

/* Free the channel and close its fd/socket. */

void
channel_free(Channel *c)
{
	char *s;
	int i, n;

	for (n = 0, i = 0; i < channels_alloc; i++)
		if (channels[i])
			n++;
	debug("channel_free: channel %d: %s, nchannels %d", c->self,
	    c->remote_name ? c->remote_name : "???", n);

	s = channel_open_message();
	debug3("channel_free: status: %s", s);
	xfree(s);

	if (c->detach_user != NULL) {
		debug("channel_free: channel %d: detaching channel user", c->self);
		c->detach_user(c->self, NULL);
	}
	if (c->sock != -1)
		shutdown(c->sock, SHUT_RDWR);
	channel_close_fds(c);
	buffer_free(&c->input);
	buffer_free(&c->output);
	buffer_free(&c->extended);
	if (c->remote_name) {
		xfree(c->remote_name);
		c->remote_name = NULL;
	}
	channels[c->self] = NULL;
	xfree(c);
}

void
channel_free_all(void)
{
	int i;

	for (i = 0; i < channels_alloc; i++)
		if (channels[i] != NULL)
			channel_free(channels[i]);
}

void
channel_detach_all(void)
{
	int i;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c != NULL && c->detach_user != NULL) {
			debug("channel_detach_all: channel %d", c->self);
			c->detach_user(c->self, NULL);
			c->detach_user = NULL;
		}
	}
}

/*
 * Closes the sockets/fds of all channels.  This is used to close extra file
 * descriptors after a fork.
 */

void
channel_close_all()
{
	int i;

	for (i = 0; i < channels_alloc; i++)
		if (channels[i] != NULL)
			channel_close_fds(channels[i]);
}

/*
 * Stop listening to channels.
 */

void
channel_stop_listening(void)
{
	int i;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c != NULL) {
			switch (c->type) {
			case SSH_CHANNEL_AUTH_SOCKET:
			case SSH_CHANNEL_PORT_LISTENER:
			case SSH_CHANNEL_RPORT_LISTENER:
			case SSH_CHANNEL_X11_LISTENER:
				channel_close_fd(&c->sock);
				channel_free(c);
				break;
			}
		}
	}
}

/*
 * Returns true if no channel has too much buffered data, and false if one or
 * more channel is overfull.
 */

int
channel_not_very_much_buffered_data()
{
	u_int i;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c != NULL && c->type == SSH_CHANNEL_OPEN) {
			if (!compat20 && buffer_len(&c->input) > packet_get_maxsize()) {
				debug("channel %d: big input buffer %d",
				    c->self, buffer_len(&c->input));
				return 0;
			}
			if (buffer_len(&c->output) > packet_get_maxsize()) {
				debug("channel %d: big output buffer %d",
				    c->self, buffer_len(&c->output));
				return 0;
			}
		}
	}
	return 1;
}

/* Returns true if any channel is still open. */

int
channel_still_open()
{
	int i;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c == NULL)
			continue;
		switch (c->type) {
		case SSH_CHANNEL_X11_LISTENER:
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_RPORT_LISTENER:
		case SSH_CHANNEL_CLOSED:
		case SSH_CHANNEL_AUTH_SOCKET:
		case SSH_CHANNEL_DYNAMIC:
		case SSH_CHANNEL_CONNECTING:
		case SSH_CHANNEL_ZOMBIE:
			continue;
		case SSH_CHANNEL_LARVAL:
			if (!compat20)
				fatal("cannot happen: SSH_CHANNEL_LARVAL");
			continue;
		case SSH_CHANNEL_OPENING:
		case SSH_CHANNEL_OPEN:
		case SSH_CHANNEL_X11_OPEN:
			return 1;
		case SSH_CHANNEL_INPUT_DRAINING:
		case SSH_CHANNEL_OUTPUT_DRAINING:
			if (!compat13)
				fatal("cannot happen: OUT_DRAIN");
			return 1;
		default:
			fatal("channel_still_open: bad channel type %d", c->type);
			/* NOTREACHED */
		}
	}
	return 0;
d277 1
a277 3

/* Returns the id of an open channel suitable for keepaliving */

d279 1
a279 46
channel_find_open()
{
	int i;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c == NULL)
			continue;
		switch (c->type) {
		case SSH_CHANNEL_CLOSED:
		case SSH_CHANNEL_DYNAMIC:
		case SSH_CHANNEL_X11_LISTENER:
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_RPORT_LISTENER:
		case SSH_CHANNEL_OPENING:
		case SSH_CHANNEL_CONNECTING:
		case SSH_CHANNEL_ZOMBIE:
			continue;
		case SSH_CHANNEL_LARVAL:
		case SSH_CHANNEL_AUTH_SOCKET:
		case SSH_CHANNEL_OPEN:
		case SSH_CHANNEL_X11_OPEN:
			return i;
		case SSH_CHANNEL_INPUT_DRAINING:
		case SSH_CHANNEL_OUTPUT_DRAINING:
			if (!compat13)
				fatal("cannot happen: OUT_DRAIN");
			return i;
		default:
			fatal("channel_find_open: bad channel type %d", c->type);
			/* NOTREACHED */
		}
	}
	return -1;
}


/*
 * Returns a message describing the currently open forwarded connections,
 * suitable for sending to the client.  The message contains crlf pairs for
 * newlines.
 */

char *
channel_open_message()
d281 1
a281 115
	Buffer buffer;
	Channel *c;
	char buf[1024], *cp;
	int i;

	buffer_init(&buffer);
	snprintf(buf, sizeof buf, "The following connections are open:\r\n");
	buffer_append(&buffer, buf, strlen(buf));
	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c == NULL)
			continue;
		switch (c->type) {
		case SSH_CHANNEL_X11_LISTENER:
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_RPORT_LISTENER:
		case SSH_CHANNEL_CLOSED:
		case SSH_CHANNEL_AUTH_SOCKET:
		case SSH_CHANNEL_ZOMBIE:
			continue;
		case SSH_CHANNEL_LARVAL:
		case SSH_CHANNEL_OPENING:
		case SSH_CHANNEL_CONNECTING:
		case SSH_CHANNEL_DYNAMIC:
		case SSH_CHANNEL_OPEN:
		case SSH_CHANNEL_X11_OPEN:
		case SSH_CHANNEL_INPUT_DRAINING:
		case SSH_CHANNEL_OUTPUT_DRAINING:
			snprintf(buf, sizeof buf, "  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n",
			    c->self, c->remote_name,
			    c->type, c->remote_id,
			    c->istate, buffer_len(&c->input),
			    c->ostate, buffer_len(&c->output),
			    c->rfd, c->wfd);
			buffer_append(&buffer, buf, strlen(buf));
			continue;
		default:
			fatal("channel_open_message: bad channel type %d", c->type);
			/* NOTREACHED */
		}
	}
	buffer_append(&buffer, "\0", 1);
	cp = xstrdup(buffer_ptr(&buffer));
	buffer_free(&buffer);
	return cp;
}

void
channel_send_open(int id)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_send_open: %d: bad id", id);
		return;
	}
	debug("send channel open %d", id);
	packet_start(SSH2_MSG_CHANNEL_OPEN);
	packet_put_cstring(c->ctype);
	packet_put_int(c->self);
	packet_put_int(c->local_window);
	packet_put_int(c->local_maxpacket);
	packet_send();
}

void
channel_request(int id, char *service, int wantconfirm)
{
	channel_request_start(id, service, wantconfirm);
	packet_send();
	debug("channel request %d: %s", id, service) ;
}
void
channel_request_start(int id, char *service, int wantconfirm)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_request: %d: bad id", id);
		return;
	}
	packet_start(SSH2_MSG_CHANNEL_REQUEST);
	packet_put_int(c->remote_id);
	packet_put_cstring(service);
	packet_put_char(wantconfirm);
}
void
channel_register_callback(int id, int mtype, channel_callback_fn *fn, void *arg)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_register_callback: %d: bad id", id);
		return;
	}
	c->cb_event = mtype;
	c->cb_fn = fn;
	c->cb_arg = arg;
}
void
channel_register_cleanup(int id, channel_callback_fn *fn)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_register_cleanup: %d: bad id", id);
		return;
	}
	c->detach_user = fn;
}
void
channel_cancel_cleanup(int id)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_cancel_cleanup: %d: bad id", id);
		return;
	}
	c->detach_user = NULL;
d283 4
d288 1
a288 1
channel_register_filter(int id, channel_filter_fn *fn)
d290 15
a304 4
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_register_filter: %d: bad id", id);
		return;
a305 1
	c->input_filter = fn;
d308 2
d311 1
a311 2
channel_set_fds(int id, int rfd, int wfd, int efd,
    int extusage, int nonblock)
d314 22
a335 10
	if (c == NULL || c->type != SSH_CHANNEL_LARVAL)
		fatal("channel_activate for non-larval channel %d.", id);
	channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
	c->type = SSH_CHANNEL_OPEN;
	/* XXX window size? */
	c->local_window = c->local_window_max = c->local_maxpacket * 2;
	packet_start(SSH2_MSG_CHANNEL_WINDOW_ADJUST);
	packet_put_int(c->remote_id);
	packet_put_int(c->local_window);
	packet_send();
d350 1
a350 1
static void
d356 1
a356 1
static void
d363 1
a363 1
static void
d372 1
a372 1
static void
d389 1
a389 1
static void
d415 1
a415 1
static void
d427 1
a427 1
static void
d431 1
a431 1
		chan_mark_dead(c);
a442 1
 * Returns: 0 = need more data, -1 = wrong cookie, 1 = ok
d444 2
a445 2
static int
x11_open_helper(Buffer *b)
d451 1
a451 1
	if (buffer_len(b) < 12)
d455 1
a455 1
	ucp = (u_char *) buffer_ptr(b);
d469 1
a469 1
	if (buffer_len(b) <
d502 1
a502 1
static void
d505 1
a505 1
	int ret = x11_open_helper(&c->output);
d518 1
a518 1
		channel_close_fd(&c->sock);
d527 1
a527 1
static void
d530 1
a530 4
	int ret = x11_open_helper(&c->output);

	/* c->force_drain = 1; */

d546 1
a546 1
static int
d616 1
a616 1
static void
d643 1
a643 1
		chan_mark_dead(c);
d656 1
a656 1
static void
a658 1
	Channel *nc;
d660 1
a660 1
	int newsock;
d678 1
a678 1
		nc = channel_new("accepted x11 socket",
a681 5
		if (nc == NULL) {
			close(newsock);
			xfree(remote_ipaddr);
			return;
		}
d685 1
a685 1
			packet_put_int(nc->self);
d698 3
a700 4
			packet_put_int(nc->self);
			if (packet_get_protocol_flags() &
			    SSH_PROTOFLAG_HOST_IN_FWD_OPEN)
				packet_put_cstring(buf);
d707 1
a707 1
static void
d750 1
a750 2
		if (packet_get_protocol_flags() &
		    SSH_PROTOFLAG_HOST_IN_FWD_OPEN)
d760 1
a760 1
static void
d765 1
a765 1
	int newsock, nextstate;
d786 1
a786 1
		nc = channel_new(rtype,
d790 2
d793 1
a793 2
			error("channel_post_port_listener: no new channel:");
			close(newsock);
d809 1
a809 1
static void
a811 3
	Channel *nc;
	char *name;
	int newsock;
d813 1
d823 1
a823 2
		name = xstrdup("accepted auth socket");
		nc = channel_new("accepted auth socket",
d826 1
a826 6
		    0, name, 1);
		if (nc == NULL) {
			error("channel_post_auth_listener: channel_new failed");
			xfree(name);
			close(newsock);
		}
d830 1
a830 1
			packet_put_int(nc->self);
d835 1
a835 1
			packet_put_int(nc->self);
d841 1
a841 1
static void
a843 3
	int err = 0;
	socklen_t sz = sizeof(err);

d845 5
a849 19
		if (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, (char *)&err,
		    &sz) < 0) {
			err = errno;
			error("getsockopt SO_ERROR failed");
		}
		if (err == 0) {
			debug("channel %d: connected", c->self);
			c->type = SSH_CHANNEL_OPEN;
			if (compat20) {
				packet_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);
				packet_put_int(c->remote_id);
				packet_put_int(c->self);
				packet_put_int(c->local_window);
				packet_put_int(c->local_maxpacket);
			} else {
				packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
				packet_put_int(c->remote_id);
				packet_put_int(c->self);
			}
d851 2
a852 10
			debug("channel %d: not connected: %s",
			    c->self, strerror(err));
			if (compat20) {
				packet_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);
				packet_put_int(c->remote_id);
				packet_put_int(SSH2_OPEN_CONNECT_FAILED);
				if (!(datafellows & SSH_BUG_OPENFAILURE)) {
					packet_put_cstring(strerror(err));
					packet_put_cstring("");
				}
d854 4
a857 2
				packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
				packet_put_int(c->remote_id);
a858 1
			chan_mark_dead(c);
a859 1
		packet_send();
d863 1
a863 1
static int
d879 1
a879 1
				chan_mark_dead(c);
d884 1
a884 1
				debug("channel %d: input draining.", c->self);
d901 1
a901 1
static int
a904 2
	u_char *data;
	u_int dlen;
d911 2
a912 3
		data = buffer_ptr(&c->output);
		dlen = buffer_len(&c->output);
		len = write(c->wfd, data, dlen);
d918 1
a918 1
				chan_mark_dead(c);
d922 1
a922 1
				debug("channel %d: input draining.", c->self);
d929 1
a929 1
		if (compat20 && c->isatty && dlen >= 1 && data[0] != '\r') {
d949 1
a949 1
static int
d969 2
a970 1
				channel_close_fd(&c->efd);
d985 2
a986 1
				channel_close_fd(&c->efd);
d994 1
a994 1
static int
d1014 1
a1014 1
static void
d1021 1
a1021 1
static void
d1031 1
a1031 1
static void
d1046 1
a1046 1
static void
d1067 1
a1067 1
static void
d1089 1
a1089 1
static void
d1108 1
a1108 1
static void
d1124 1
a1124 1
static void
d1136 4
a1139 2
		c = channels[i];
		if (c == NULL)
d1141 1
a1141 2
		if (ftab[c->type] != NULL)
			(*ftab[c->type])(c, readset, writeset);
d1158 1
a1158 1
			channel_free(c);
a1162 4
/*
 * Allocate/update select bitmasks and add any bits relevant to channels in
 * select bitmasks.
 */
d1165 1
a1165 1
    int *nallocp, int rekeying)
d1173 8
a1180 5
	/* perhaps check sz < nalloc/2 and shrink? */
	if (*readsetp == NULL || sz > *nallocp) {
		*readsetp = xrealloc(*readsetp, sz);
		*writesetp = xrealloc(*writesetp, sz);
		*nallocp = sz;
a1181 1
	*maxfdp = n;
a1188 4
/*
 * After select, perform any appropriate operations for channels which have
 * events pending.
 */
a1194 1

d1204 1
a1204 3
		c = channels[i];
		if (c == NULL)
			continue;
d1206 1
a1206 4
		/*
		 * We are only interested in channels that can have buffered
		 * incoming data.
		 */
d1226 1
a1226 4
			/*
			 * Send some data for the other side over the secure
			 * connection.
			 */
d1284 5
a1288 2

/* -- protocol input */
a1334 1

d1375 30
a1417 7

	/* XXX force input close */
	if (c->force_drain) {
		debug("channel %d: FORCE input drain", c->self);
		c->istate = CHAN_INPUT_WAIT_DRAIN;
	}

d1483 1
a1483 1
	channel_free(c);
a1519 16
static char *
reason2txt(int reason)
{
	switch(reason) {
	case SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED:
		return "administratively prohibited";
	case SSH2_OPEN_CONNECT_FAILED:
		return "connect failed";
	case SSH2_OPEN_UNKNOWN_CHANNEL_TYPE:
		return "unknown channel type";
	case SSH2_OPEN_RESOURCE_SHORTAGE:
		return "resource shortage";
	}
	return "unknown reason";
}

d1538 1
a1538 1
		if (!(datafellows & SSH_BUG_OPENFAILURE)) {
d1543 2
a1544 2
		log("channel %d: open failed: %s%s%s", id,
		    reason2txt(reason), msg ? ": ": "", msg ? msg : "");
d1551 1
a1551 1
	channel_free(c);
d1590 126
a1715 1
	c = channel_lookup(id);
d1717 5
a1721 10
	if (c == NULL || c->type != SSH_CHANNEL_OPEN) {
		log("Received window adjust for "
		    "non-open channel %d.", id);
		return;
	}
	adjust = packet_get_int();
	packet_done();
	debug2("channel %d: rcvd adjust %d", id, adjust);
	c->remote_window += adjust;
}
d1723 2
a1724 2
void
channel_input_port_open(int type, int plen, void *ctxt)
d1726 3
a1728 4
	Channel *c = NULL;
	u_short host_port;
	char *host, *originator_string;
	int remote_id, sock = -1;
d1730 32
a1761 20
	remote_id = packet_get_int();
	host = packet_get_string(NULL);
	host_port = packet_get_int();

	if (packet_get_protocol_flags() & SSH_PROTOFLAG_HOST_IN_FWD_OPEN) {
		originator_string = packet_get_string(NULL);
	} else {
		originator_string = xstrdup("unknown (remote did not supply name)");
	}
	packet_done();
	sock = channel_connect_to(host, host_port);
	if (sock != -1) {
		c = channel_new("connected socket",
		    SSH_CHANNEL_CONNECTING, sock, sock, -1, 0, 0, 0,
		    originator_string, 1);
		if (c == NULL) {
			error("channel_input_port_open: channel_new failed");
			close(sock);
		} else {
			c->remote_id = remote_id;
d1764 4
a1767 6
	if (c == NULL) {
		packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(remote_id);
		packet_send();
	}
	xfree(host);
a1769 3

/* -- tcp forwarding */

d1794 1
a1794 2
	Channel *c;
	int success, sock, on = 1, type;
d1804 1
a1804 1
		type = SSH_CHANNEL_RPORT_LISTENER;
d1807 1
a1807 1
		type = SSH_CHANNEL_PORT_LISTENER;
d1810 1
a1810 1
	if (strlen(host) > SSH_CHANNEL_PATH_LEN - 1) {
d1867 1
a1867 1
		c = channel_new("port listener", type, sock, sock, -1,
d1870 3
a1872 8
		if (c == NULL) {
			error("channel_request_forwarding: channel_new failed");
			close(sock);
			continue;
		}
		strlcpy(c->path, host, sizeof(c->path));
		c->host_port = port_to_connect;
		c->listening_port = listen_port;
d2010 1
a2010 1
static int
d2062 1
a2062 1
channel_connect_by_listen_address(u_short listen_port)
d2098 41
a2138 1
/* -- X11 forwarding */
d2145 3
d2237 2
a2238 1
static int
d2370 1
a2370 2
	Channel *c = NULL;
	int remote_id, sock = 0;
d2372 1
d2374 2
a2375 3
	debug("Received X11 open request.");

	remote_id = packet_get_int();
d2377 4
a2380 2
	if (packet_get_protocol_flags() & SSH_PROTOFLAG_HOST_IN_FWD_OPEN) {
		remote_host = packet_get_string(NULL);
d2383 1
d2385 3
a2387 1
	packet_done();
d2391 1
a2391 14
	if (sock != -1) {
		/* Allocate a channel for this connection. */
		c = channel_new("connected x11 socket",
		    SSH_CHANNEL_X11_OPEN, sock, sock, -1, 0, 0, 0,
		    remote_host, 1);
		if (c == NULL) {
			error("x11_input_open: channel_new failed");
			close(sock);
		} else {
			c->remote_id = remote_id;
			c->force_drain = 1;
		}
	}
	if (c == NULL) {
d2394 2
a2395 1
		packet_put_int(remote_id);
d2397 7
d2406 3
a2408 2
		packet_put_int(remote_id);
		packet_put_int(c->self);
a2409 1
	packet_send();
a2436 1
 * This should be called in the client only.
d2438 1
a2502 3

/* -- agent forwarding */

d2522 1
a2522 1
	return auth_sock_name;
d2532 1
a2532 1
	if (auth_sock_name) {
d2534 3
a2536 3
		unlink(auth_sock_name);
		rmdir(auth_sock_dir);
		auth_sock_name = NULL;
d2549 1
a2549 2
	Channel *nc;
	int sock;
d2552 2
a2553 4
	if (auth_get_socket_name() != NULL) {
		error("authentication forwarding requested twice.");
		return 0;
	}
d2559 3
a2561 3
	auth_sock_name = xmalloc(MAXPATHLEN);
	auth_sock_dir = xmalloc(MAXPATHLEN);
	strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXX", MAXPATHLEN);
d2564 3
a2566 3
	if (mkdtemp(auth_sock_dir) == NULL) {
		packet_send_debug("Agent forwarding disabled: "
		    "mkdtemp() failed: %.100s", strerror(errno));
d2568 4
a2571 4
		xfree(auth_sock_name);
		xfree(auth_sock_dir);
		auth_sock_name = NULL;
		auth_sock_dir = NULL;
d2574 2
a2575 2
	snprintf(auth_sock_name, MAXPATHLEN, "%s/agent.%d",
		 auth_sock_dir, (int) getpid());
d2588 1
a2588 1
	strncpy(sunaddr.sun_path, auth_sock_name,
d2602 1
a2602 1
	nc = channel_new("auth socket",
d2606 3
a2608 8
	if (nc == NULL) {
		error("auth_input_request_forwarding: channel_new failed");
		auth_sock_cleanup_proc(pw);
		fatal_remove_cleanup(auth_sock_cleanup_proc, pw);
		close(sock);
		return 0;
	}
	strlcpy(nc->path, auth_sock_name, sizeof(nc->path));
d2617 2
a2618 3
	Channel *c = NULL;
	int remote_id, sock;
	char *name;
d2623 1
a2623 1
	remote_id = packet_get_int();
d2637 96
a2732 12
	if (sock >= 0) {
		name = xstrdup("authentication agent connection");
		c = channel_new("", SSH_CHANNEL_OPEN, sock, sock,
		    -1, 0, 0, 0, name, 1);
		if (c == NULL) {
			error("auth_input_open_request: channel_new failed");
			xfree(name);
			close(sock);
		} else {
			c->remote_id = remote_id;
			c->force_drain = 1;
		}
d2734 6
d2741 2
a2742 8
		packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(remote_id);
	} else {
		/* Send a confirmation to the remote host. */
		debug("Forwarding authentication connection.");
		packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
		packet_put_int(remote_id);
		packet_put_int(c->self);
d2744 17
@


1.109.2.4
log
@Merge OpenSSH 3.0
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.109.2.3 2001/09/27 19:03:54 jason Exp $");
d136 1
a136 1
static int IPv4or6 = AF_UNSPEC;
a243 1
	memset(c, 0, sizeof(Channel));
d333 4
d361 16
d432 1
a432 3
#if 0
			if (!compat20 &&
			    buffer_len(&c->input) > packet_get_maxsize()) {
a436 1
#endif
d438 2
a439 3
				debug("channel %d: big output buffer %d > %d",
				    c->self, buffer_len(&c->output),
				    packet_get_maxsize());
d973 1
a973 1
	c->delayed = 0;
d1132 5
a1136 12
		if (c->type == SSH_CHANNEL_RPORT_LISTENER) {
			nextstate = SSH_CHANNEL_OPENING;
			rtype = "forwarded-tcpip";
		} else {
			if (c->host_port == 0) {
				nextstate = SSH_CHANNEL_DYNAMIC;
				rtype = "dynamic-tcpip";
			} else {
				nextstate = SSH_CHANNEL_OPENING;
				rtype = "direct-tcpip";
			}
		}
d1157 1
a1157 8
		if (nextstate == SSH_CHANNEL_DYNAMIC) {
			/*
			 * do not call the channel_post handler until
			 * this flag has been reset by a pre-handler.
			 * otherwise the FD_ISSET calls might overflow
			 */
			nc->delayed = 1;
		} else {
a1158 1
		}
a1407 2
	if (c->delayed)
		return;
a1414 2
	if (c->delayed)
		return;
a1514 22
/* gc dead channels */
static void
channel_garbage_collect(Channel *c)
{
	if (c == NULL)
		return;
	if (c->detach_user != NULL) {
		if (!chan_is_dead(c, 0))
			return;
		debug("channel %d: gc: notify user", c->self);
		c->detach_user(c->self, NULL);
		/* if we still have a callback */
		if (c->detach_user != NULL)
			return;
		debug("channel %d: gc: user detached", c->self);
	}
	if (!chan_is_dead(c, 1))
		return;
	debug("channel %d: garbage collecting", c->self);
	channel_free(c);
}

d1532 18
a1549 1
		channel_garbage_collect(c);
d1620 1
a1620 1
			debug3("channel %d: will not send data after close", c->self);
a2038 6

void
channel_set_af(int af)
{
	IPv4or6 = af;
}
@


1.109.2.5
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d16 1
a16 1
 * Copyright (c) 1999, 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.171 2002/03/04 19:37:58 markus Exp $");
a56 1
#include "pathnames.h"
d148 1
a148 1
	if (id < 0 || id >= channels_alloc) {
d219 1
d248 1
a248 3
	c->ostate = CHAN_OUTPUT_OPEN;
	c->istate = CHAN_INPUT_OPEN;
	c->flags = 0;
d261 3
a264 1
	c->single_connection = 0;
a265 1
	c->confirm = NULL;
d364 1
a364 1
channel_close_all(void)
d405 1
a405 1
channel_not_very_much_buffered_data(void)
d435 1
a435 1
channel_still_open(void)
d478 1
a478 1
channel_find_open(void)
d523 1
a523 1
channel_open_message(void)
d590 1
a590 1
channel_request_start(int local_id, char *service, int wantconfirm)
d592 8
a599 1
	Channel *c = channel_lookup(local_id);
d601 1
a601 1
		log("channel_request_start: %d: unknown channel id", local_id);
a603 1
	debug("channel request %d: %s", local_id, service) ;
d610 1
a610 1
channel_register_confirm(int id, channel_callback_fn *fn)
d614 1
a614 1
		log("channel_register_comfirm: %d: bad id", id);
d617 3
a619 1
	c->confirm = fn;
d654 1
a654 1
    int extusage, int nonblock, u_int window_max)
d661 2
a662 1
	c->local_window = c->local_window_max = window_max;
d704 1
a704 1
channel_pre_open(Channel *c, fd_set * readset, fd_set * writeset)
d706 13
a718 1
	u_int limit = compat20 ? c->remote_window : packet_get_maxsize();
d720 3
d724 2
a725 2
	    limit > 0 &&
	    buffer_len(&c->input) < limit)
d736 1
a736 1
	if (compat20 && c->efd != -1) {
d787 1
a787 1
	ucp = buffer_ptr(b);
d796 1
a796 1
		    ucp[0]);
d868 4
a871 1
		channel_pre_open(c, readset, writeset);
a872 1
		log("X11 connection rejected because of wrong authentication.");
d874 2
a875 9
		chan_read_failed(c);
		buffer_clear(&c->input);
		chan_ibuf_empty(c);
		buffer_clear(&c->output);
		/* for proto v1, the peer will send an IEOF */
		if (compat20)
			chan_write_failed(c);
		else
			c->type = SSH_CHANNEL_OPEN;
d886 1
a886 1
	char username[256];
d933 1
a933 1

a1004 5
		if (c->single_connection) {
			debug("single_connection: closing X11 listener.");
			channel_close_fd(&c->sock);
			chan_mark_dead(c);
		}
a1008 1
		set_nodelay(newsock);
d1018 5
d1027 2
a1028 2
			packet_put_int(nc->local_window_max);
			packet_put_int(nc->local_maxpacket);
a1135 1
		set_nodelay(newsock);
d1140 5
d1187 5
d1213 2
a1214 1
		if (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, &err, &sz) < 0) {
d1272 1
a1272 1
				buffer_clear(&c->output);
d1280 1
a1280 1
		if (c->input_filter != NULL) {
d1314 1
a1314 1
				buffer_clear(&c->output);
d1371 1
a1371 1
			    c->self, len, c->efd);
d1406 1
a1406 1
channel_post_open(Channel *c, fd_set * readset, fd_set * writeset)
d1412 6
a1417 1
	if (!compat20)
d1419 2
d1422 1
d1435 1
a1435 1
			buffer_clear(&c->output);
d1444 1
a1444 1
	channel_pre[SSH_CHANNEL_OPEN] =			&channel_pre_open;
d1453 1
a1453 1
	channel_post[SSH_CHANNEL_OPEN] =		&channel_post_open;
d1459 1
a1459 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open;
d1475 1
a1475 1
	channel_post[SSH_CHANNEL_OPEN] =		&channel_post_open;
d1481 1
a1481 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open;
d1487 1
a1487 1
	channel_pre[SSH_CHANNEL_OPEN] =			&channel_pre_open;
d1498 1
a1498 1
	channel_post[SSH_CHANNEL_OPEN] =		&channel_post_open;
d1500 1
a1500 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open;
d1507 1
a1507 1
	for (i = 0; i < SSH_CHANNEL_MAX_TYPE; i++) {
d1604 1
a1604 1
channel_output_poll(void)
d1702 1
a1702 1
channel_input_data(int type, u_int32_t seq, void *ctxt)
d1726 1
d1728 1
a1728 1
	if (compat20) {
d1740 2
a1742 1
	packet_check_eom();
d1748 1
a1748 1
channel_input_extended_data(int type, u_int32_t seq, void *ctxt)
d1774 1
a1774 1
	packet_check_eom();
d1788 1
a1788 1
channel_input_ieof(int type, u_int32_t seq, void *ctxt)
d1793 2
a1795 1
	packet_check_eom();
d1802 1
a1802 1
	if (c->force_drain && c->istate == CHAN_INPUT_OPEN) {
a1804 2
		if (buffer_len(&c->input) == 0)
			chan_ibuf_empty(c);
d1810 1
a1810 1
channel_input_close(int type, u_int32_t seq, void *ctxt)
d1815 2
a1817 1
	packet_check_eom();
d1842 1
a1842 1
		buffer_clear(&c->input);
d1849 1
a1849 1
channel_input_oclose(int type, u_int32_t seq, void *ctxt)
d1853 1
a1853 2

	packet_check_eom();
d1860 1
a1860 1
channel_input_close_confirmation(int type, u_int32_t seq, void *ctxt)
d1865 1
a1865 1
	packet_check_eom();
d1876 1
a1876 1
channel_input_open_confirmation(int type, u_int32_t seq, void *ctxt)
d1881 3
d1898 2
a1899 1
		if (c->confirm) {
d1901 1
a1901 1
			c->confirm(c->self, NULL);
a1906 1
	packet_check_eom();
d1912 1
a1912 1
	switch (reason) {
d1926 1
a1926 1
channel_input_open_failure(int type, u_int32_t seq, void *ctxt)
d1932 3
d1947 1
a1954 1
	packet_check_eom();
d1960 26
a1985 1
channel_input_window_adjust(int type, u_int32_t seq, void *ctxt)
d2003 1
a2003 1
	packet_check_eom();
d2009 1
a2009 1
channel_input_port_open(int type, u_int32_t seq, void *ctxt)
d2025 1
a2025 1
	packet_check_eom();
d2031 6
a2036 1
		c->remote_id = remote_id;
d2055 23
a2077 3
static int
channel_setup_fwd_listener(int type, const char *listen_addr, u_short listen_port,
    const char *host_to_connect, u_short port_to_connect, int gateway_ports)
d2080 1
a2080 1
	int success, sock, on = 1;
d2082 1
a2083 1
	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
a2086 2
	host = (type == SSH_CHANNEL_RPORT_LISTENER) ?
	    listen_addr : host_to_connect;
d2088 6
a2093 3
	if (host == NULL) {
		error("No forward host name.");
		return success;
d2095 1
d2101 1
d2119 1
a2119 1
			error("channel_setup_fwd_listener: getnameinfo failed");
d2133 1
a2133 1
		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
d2136 1
a2136 1
		setsockopt(sock, SOL_SOCKET, SO_LINGER, &linger, sizeof(linger));
d2156 5
d2167 1
a2167 1
		error("channel_setup_fwd_listener: cannot listen to port: %d",
a2172 18
/* protocol local port fwd, used by ssh (and sshd in v1) */
int
channel_setup_local_fwd_listener(u_short listen_port,
    const char *host_to_connect, u_short port_to_connect, int gateway_ports)
{
	return channel_setup_fwd_listener(SSH_CHANNEL_PORT_LISTENER,
	    NULL, listen_port, host_to_connect, port_to_connect, gateway_ports);
}

/* protocol v2 remote port fwd, used by sshd */
int
channel_setup_remote_fwd_listener(const char *listen_address,
    u_short listen_port, int gateway_ports)
{
	return channel_setup_fwd_listener(SSH_CHANNEL_RPORT_LISTENER,
	    listen_address, listen_port, NULL, 0, gateway_ports);
}

d2182 1
a2182 1
	int type, success = 0;
d2209 1
a2209 1
		type = packet_read();
d2256 1
a2256 1
	channel_setup_local_fwd_listener(port, hostname, host_port, gateway_ports);
d2268 1
a2268 1
channel_permit_all_opens(void)
a2348 1
	set_nodelay(sock);
d2393 2
a2394 2
 * Returns a suitable display number for the DISPLAY variable, or -1 if
 * an error occurs.
d2396 2
a2397 3
int
x11_create_display_inet(int x11_display_offset, int x11_use_localhost,
    int single_connection)
a2398 1
	Channel *nc = NULL;
d2404 2
d2408 2
a2409 2
	    display_number < MAX_DISPLAYS;
	    display_number++) {
d2413 1
a2413 1
		hints.ai_flags = x11_use_localhost ? 0: AI_PASSIVE;
d2418 1
a2418 1
			return -1;
d2426 1
a2426 1
				return -1;
d2430 1
d2433 1
d2449 1
a2449 1
		return -1;
d2456 1
d2458 1
a2458 1
			return -1;
d2462 6
d2471 1
a2471 1
		nc = channel_new("x11 listener",
a2474 1
		nc->single_connection = single_connection;
d2477 2
a2478 2
	/* Return the display number for the DISPLAY environment variable. */
	return display_number;
d2481 4
d2488 6
d2496 1
d2498 11
a2508 9
	sock = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sock < 0)
		error("socket: %.100s", strerror(errno));
	memset(&addr, 0, sizeof(addr));
	addr.sun_family = AF_UNIX;
	snprintf(addr.sun_path, sizeof addr.sun_path, _PATH_UNIX_X, dnr);
	if (connect(sock, (struct sockaddr *) & addr, sizeof(addr)) == 0)
		return sock;
	close(sock);
d2543 1
a2543 1
			    display);
d2558 2
a2559 1
	strlcpy(buf, display, sizeof(buf));
d2569 1
a2569 1
		    display);
a2604 1
	set_nodelay(sock);
d2615 1
a2615 1
x11_input_open(int type, u_int32_t seq, void *ctxt)
d2630 1
a2630 1
	packet_check_eom();
d2639 7
a2645 2
		c->remote_id = remote_id;
		c->force_drain = 1;
d2662 1
a2662 1
deny_input_open(int type, u_int32_t seq, void *ctxt)
d2665 1
a2665 1
	switch (type) {
d2673 1
a2673 1
		error("deny_input_open: type %d", type);
d2757 1
a2757 1
auth_request_forwarding(void)
d2771 1
a2771 1
auth_get_socket_name(void)
d2842 2
a2843 1
	strlcpy(sunaddr.sun_path, auth_sock_name, sizeof(sunaddr.sun_path));
d2860 7
d2874 1
a2874 1
auth_input_open_request(int type, u_int32_t seq, void *ctxt)
d2880 2
a2883 1
	packet_check_eom();
d2901 8
a2908 2
		c->remote_id = remote_id;
		c->force_drain = 1;
@


1.109.2.6
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.173 2002/04/22 21:04:52 markus Exp $");
d709 1
a709 5
			if (CHANNEL_EFD_OUTPUT_ACTIVE(c))
                               debug2("channel %d: obuf_empty delayed efd %d/(%d)",
                                   c->self, c->efd, buffer_len(&c->extended));
			else
				chan_obuf_empty(c);
d717 1
a717 2
		else if (!(c->flags & CHAN_EOF_SENT) &&
		    c->extended_usage == CHAN_EXTENDED_READ &&
d1635 1
a1635 2
			 * tell peer, that we will not send more data: send IEOF.
			 * hack for extended data: delay EOF if EFD still in use.
d1637 1
a1637 5
			if (CHANNEL_EFD_INPUT_ACTIVE(c))
                               debug2("channel %d: ibuf_empty delayed efd %d/(%d)",
                                   c->self, c->efd, buffer_len(&c->extended));
			else
				chan_ibuf_empty(c);
a1640 1
		    !(c->flags & CHAN_EOF_SENT) &&
a1728 7
	if (c->flags & CHAN_EOF_RCVD) {
		if (datafellows & SSH_BUG_EXTEOF)
			debug("channel %d: accepting ext data after eof", id);
		else
			packet_disconnect("Received extended_data after EOF "
			    "on channel %d.", id);
	}
d2111 1
a2111 1
		packet_put_char(1);			/* boolean: want reply */
@


1.108
log
@remove some channels that are not appropriate for keepalive.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.107 2001/04/13 22:46:52 beck Exp $");
a544 67

int
channel_decode_helper(Channel *c, int start, int lookfor)
{
	u_char *p;
	int i, have;

	p = buffer_ptr(&c->input);
	have = buffer_len(&c->input);
	debug2("channel %d: decode_helper: start %d have %d lookfor %d",
	    c->self, start, have, lookfor);
	if (have < start)
		return 0;
	for (i = start; i < have; i++) {
		if (p[i] == lookfor) {
			debug2("channel %d: decode_helper: matched at %d",
			    c->self, i);
			if (lookfor == '\0' ||
			    (i+3 < have &&
			    p[i+1] == '\n' &&
			    p[i+2] == '\r' &&
			    p[i+3] == '\n'))
				return i;
		}
		if (i > 4096) {
			/* the peer is probably sending garbage */
			debug("channel %d: decode_helper: too long",
			    c->self);
			return -1;
		}
	}
	return 0;	/* need more */
}

/* try to decode a http connect header */
int
channel_decode_https(Channel *c, fd_set * readset, fd_set * writeset)
{
	u_char *p, *host, *buf;
	int port, ret;
	char httpok[] = "HTTP/1.0 200\r\n\r\n";

	debug2("channel %d: decode https connect", c->self);
	ret = channel_decode_helper(c, strlen("connect "), '\r');
	if (ret <= 0)
		return ret;
	p = buffer_ptr(&c->input);
	buf = xmalloc(ret+1);
	host = xmalloc(ret);
	memcpy(buf, p, ret);
	buf[ret] = '\0';
	if (sscanf(buf, "CONNECT %[^:]:%u HTTP/", host, &port) != 2) {
		debug("channel %d: cannot parse http header", c->self);
		return -1;
	}
	debug("channel %d: dynamic request: https host %s port %u",
	    c->self, host, port);
	strlcpy(c->path, host, sizeof(c->path));
	c->host_port = port;
	xfree(host);
	xfree(buf);
	buffer_consume(&c->input, ret+4);
	buffer_append(&c->output, httpok, strlen(httpok));

	return 1;
}

d550 1
a550 1
	int len, have, ret;
d560 20
a579 3
	ret = channel_decode_helper(c, sizeof(s4_req), '\0');
	if (ret <= 0)
		return ret;
d584 1
a586 1
	have = buffer_len(&c->input);
a614 109
/* try to decode a socks5 header */
#define SSH_SOCKS5_AUTHDONE	0x1000
#define SSH_SOCKS5_NOAUTH	0x00
#define SSH_SOCKS5_IPV4		0x01
#define SSH_SOCKS5_DOMAIN	0x03
#define SSH_SOCKS5_IPV6		0x04
#define SSH_SOCKS5_CONNECT	0x01
#define SSH_SOCKS5_SUCCESS	0x00

int
channel_decode_socks5(Channel *c, fd_set * readset, fd_set * writeset)
{
	struct {
		u_int8_t version;
		u_int8_t command;
		u_int8_t reserved;
		u_int8_t atyp;
	} s5_req, s5_rsp;
	u_int16_t dest_port;
	u_char *p, dest_addr[255+1];
	int i, have, found, nmethods, addrlen, af;

	debug2("channel %d: decode socks5", c->self);
	p = buffer_ptr(&c->input);
	if (p[0] != 0x05)
		return -1;
	have = buffer_len(&c->input);
	if (!(c->flags & SSH_SOCKS5_AUTHDONE)) {
		/* format: ver | nmethods | methods */
		if (have < 2) 
			return 0;
		nmethods = p[1];
		if (have < nmethods + 2)
			return 0;
		/* look for method: "NO AUTHENTICATION REQUIRED" */
		for (found = 0, i = 2 ; i < nmethods + 2; i++) {
			if (p[i] == SSH_SOCKS5_NOAUTH ) {
				found = 1;
				break;
			}
		}
		if (!found) {
			debug("channel %d: method SSH_SOCKS5_NOAUTH not found",
			    c->self);
			return -1;
		}
		buffer_consume(&c->input, nmethods + 2);
		buffer_put_char(&c->output, 0x05);		/* version */
		buffer_put_char(&c->output, SSH_SOCKS5_NOAUTH);	/* method */
		FD_SET(c->sock, writeset);
		c->flags |= SSH_SOCKS5_AUTHDONE;
		debug2("channel %d: socks5 auth done", c->self);
		return 0;				/* need more */
	}
	debug2("channel %d: socks5 post auth", c->self);
	if (have < sizeof(s5_req)+1)
		return 0;			/* need more */
	memcpy((char *)&s5_req, p, sizeof(s5_req));
	if (s5_req.version != 0x05 ||
	    s5_req.command != SSH_SOCKS5_CONNECT ||
	    s5_req.reserved != 0x00) {
		debug("channel %d: only socks5 connect supported", c->self);
		return -1;
	}
	switch(s5_req.atyp){
	case SSH_SOCKS5_IPV4:
		addrlen = 4;
		af = AF_INET;
		break;
	case SSH_SOCKS5_DOMAIN:
		addrlen = p[sizeof(s5_req)];
		af = -1;
		break;
	case SSH_SOCKS5_IPV6:
		addrlen = 16;
		af = AF_INET6;
		break;
	default:
		debug("channel %d: bad socks5 atyp %d", c->self, s5_req.atyp);
		return -1;
	}
	if (have < 4 + addrlen + 2)
		return 0;
	buffer_consume(&c->input, sizeof(s5_req));
	buffer_get(&c->input, (char *)&dest_addr, addrlen);
	buffer_get(&c->input, (char *)&dest_port, 2);
	dest_addr[addrlen] = '\0';
	if (s5_req.atyp == SSH_SOCKS5_DOMAIN)
		strlcpy(c->path, dest_addr, sizeof(c->path));
	else if (inet_ntop(af, dest_addr, c->path, sizeof(c->path)) == NULL)
		return -1;
	c->host_port = ntohs(dest_port);
	
	debug("channel %d: dynamic request: socks5 host %s port %u command %u",
	    c->self, c->path, c->host_port, s5_req.command);

	s5_rsp.version = 0x05;
	s5_rsp.command = SSH_SOCKS5_SUCCESS;
	s5_rsp.reserved = 0;			/* ignored */
	s5_rsp.atyp = SSH_SOCKS5_IPV4;
	((struct in_addr *)&dest_addr)->s_addr = INADDR_ANY;
	dest_port = 0;				/* ignored */

	buffer_append(&c->output, (char *)&s5_rsp, sizeof(s5_rsp));
	buffer_append(&c->output, (char *)&dest_addr, sizeof(struct in_addr));
	buffer_append(&c->output, (char *)&dest_port, sizeof(dest_port));
	return 1;
}

a634 3
	case 'C':
		ret = channel_decode_https(c, readset, writeset);
		break;
a636 3
		break;
	case 0x05:
		ret = channel_decode_socks5(c, readset, writeset);
@


1.107
log
@Add options ClientAliveInterval and ClientAliveCountMax to sshd.
This gives the ability to do a "keepalive" via the encrypted channel
which can't be spoofed (unlike TCP keepalives). Useful for when you want
to use ssh connections to authenticate people for something, and know
relatively quickly when they are no longer authenticated. Disabled
by default (of course). ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.106 2001/04/11 13:56:13 markus Exp $");
a1854 2
			continue;
		case SSH_CHANNEL_LARVAL:
a1855 2
		case SSH_CHANNEL_AUTH_SOCKET:
		case SSH_CHANNEL_CONNECTING: 	/* XXX ??? */
d1861 4
@


1.106
log
@https-connect and socks5 support. i feel so bad.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.105 2001/04/10 12:15:23 markus Exp $");
d1845 35
@


1.105
log
@debug cleanup
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.104 2001/04/10 07:46:58 markus Exp $");
d579 33
d637 1
a637 1
	debug2("channel %d: pre_dynamic: user %s/%d", c->self, p, len);
d649 2
a650 4
	debug("channel %d: dynamic request: "
	    "socks%x://%s@@%s:%u/command?%u",
	    c->self, s4_req.version, username, host, c->host_port,
	    s4_req.command);
d665 109
d794 3
a799 4
#if 0
	case 'C':
		ret = channel_decode_https(c, readset, writeset);
		break;
a802 1
#endif
@


1.104
log
@cleanup socks4 handling
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.103 2001/04/07 08:55:17 markus Exp $");
d423 1
a423 1
		debug("Closing channel %d after input drain.", c->self);
d644 1
a644 1
	buffer_dump(&c->input);
d910 1
a910 1
				debug("Channel %d status set to input draining.", c->self);
d918 1
a918 1
				debug("filter stops channel %d", c->self);
d948 1
a948 1
				debug("Channel %d status set to input draining.", c->self);
@


1.103
log
@allow the ssh client act as a SOCKS4 proxy (dynamic local portforwarding).
work by Dan Kaminsky <dankamin@@cisco.com> and me. thanks to Dan for this
great patch: use 'ssh -D 1080 host' and make netscape use localhost:1080 as
a socks proxy.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.102 2001/04/06 21:00:10 markus Exp $");
a544 1
#define SSH_SOCKS_HEAD 1+1+2+4
d546 36
a581 2
void
channel_pre_dynamic(Channel *c, fd_set * readset, fd_set * writeset)
d584 2
a585 2
	int len, i, done, have;
	char username[256];
d590 1
a590 1
		struct in_addr dest_ip;
d593 4
a596 25
	have = buffer_len(&c->input);

	debug("channel %d: pre_dynamic have: %d", c->self, have);
	/*buffer_dump(&c->input);*/

	/* Check if the fixed size part of the packet is in buffer. */
	if (have < SSH_SOCKS_HEAD + 1) {
		/* need more */
		FD_SET(c->sock, readset);
		return;
	}
	/* Check for end of username */
	p = buffer_ptr(&c->input);
	done = 0;
	for (i = SSH_SOCKS_HEAD; i < have; i++) {
		if (p[i] == '\0') {
			done = 1;
			break;
		}
	}
	if (!done) {
		/* need more */
		FD_SET(c->sock, readset);
		return;
	}
d600 1
a600 1
	buffer_get(&c->input, (char *)&s4_req.dest_ip, 4);
d604 1
a604 1
	debug2("channel %d: pre_dynamic user: %s/%d", c->self, p, len);
d606 1
a606 1
		fatal("channel %d: pre_dynamic: len %d > have %d",
d612 1
a612 1
	host = inet_ntoa(s4_req.dest_ip);
d616 1
a616 1
	debug("channel %d: dynamic request received: "
d621 4
a624 5
	if ((s4_req.version != 4) || (s4_req.command != 1)) {
		debug("channel %d: cannot handle: socks VN %d CN %d",
		    c->self, s4_req.version, s4_req.command);
		channel_free(c->self);
		return;
d626 2
a627 3

	s4_rsp.version = 0;			/* VN: version of reply code */
	s4_rsp.command = 90;			/* CD: request granted */
d629 1
a629 1
	s4_rsp.dest_ip.s_addr = INADDR_ANY;	/* ignored */
d631 9
d641 39
a679 3
	/* switch to next state */
	c->type = SSH_CHANNEL_OPENING;
	port_open_helper(c, "direct-tcpip");
a681 1

d903 2
a904 6
			if (c->type == SSH_CHANNEL_DYNAMIC) {
				/*
				 * we are not yet connected to a remote peer,
				 * so the connection-close protocol won't work
				 */
				debug("channel %d: dynamic: closed", c->self);
d907 1
a907 2
			}
			if (compat13) {
d942 5
a946 1
			if (compat13) {
d1023 2
a1024 1
	if (!(c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD)) &&
a1072 6
channel_post_dynamic(Channel *c, fd_set * readset, fd_set * writeset)
{
	channel_handle_rfd(c, readset, writeset);
}

void
d1090 1
a1090 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_dynamic;
d1112 1
a1112 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_dynamic;
d1131 1
a1131 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_dynamic;
@


1.102
log
@do gid/groups-swap in addition to uid-swap, should help if /home/group
is chmod 750 + chgrp grp /home/group/, work be deraadt and me, thanks
to olar@@openwall.com is comments.  we had many requests for this.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.101 2001/04/05 10:42:48 markus Exp $");
d54 1
d137 2
d545 83
d680 50
d736 1
d738 1
a738 1
	int newsock, newch;
d740 1
a740 5
	char buf[1024], *remote_ipaddr, *rtype;
	int remote_port;

	rtype = (c->type == SSH_CHANNEL_RPORT_LISTENER) ?
	    "forwarded-tcpip" : "direct-tcpip";
d746 6
a757 8
		remote_ipaddr = get_peer_ipaddr(newsock);
		remote_port = get_peer_port(newsock);
		snprintf(buf, sizeof buf,
		    "listen port %d for %.100s port %d, "
		    "connect from %.200s port %d",
		    c->listening_port, c->path, c->host_port,
		    remote_ipaddr, remote_port);

d759 1
a759 1
		    SSH_CHANNEL_OPENING, newsock, newsock, -1,
d761 6
a766 29
		    0, xstrdup(buf), 1);
		if (compat20) {
			packet_start(SSH2_MSG_CHANNEL_OPEN);
			packet_put_cstring(rtype);
			packet_put_int(newch);
			packet_put_int(c->local_window_max);
			packet_put_int(c->local_maxpacket);
			if (c->type == SSH_CHANNEL_RPORT_LISTENER) {
				/* listen address, port */
				packet_put_string(c->path, strlen(c->path));
				packet_put_int(c->listening_port);
			} else {
				/* target host, port */
				packet_put_string(c->path, strlen(c->path));
				packet_put_int(c->host_port);
			}
			/* originator host and port */
			packet_put_cstring(remote_ipaddr);
			packet_put_int(remote_port);
			packet_send();
		} else {
			packet_start(SSH_MSG_PORT_OPEN);
			packet_put_int(newch);
			packet_put_string(c->path, strlen(c->path));
			packet_put_int(c->host_port);
			if (have_hostname_in_open) {
				packet_put_string(buf, strlen(buf));
			}
			packet_send();
d768 6
a773 1
		xfree(remote_ipaddr);
d849 9
d1019 6
d1034 1
d1042 1
d1056 1
d1064 1
d1076 1
d1083 1
d1637 1
d1689 1
@


1.101
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.100 2001/04/04 20:25:35 markus Exp $");
d2356 1
a2356 1
	temporarily_use_uid(pw->pw_uid);
@


1.100
log
@more robust rekeying
don't send channel data after rekeying is started.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.99 2001/03/16 19:06:29 markus Exp $");
d1790 1
a1790 1
void 
d1804 1
a1804 1
void 
@


1.99
log
@implement "permitopen" key option, restricts -L style forwarding to
to specified host:port pairs. based on work by harlan@@genua.de
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.98 2001/03/04 17:42:28 millert Exp $");
d1008 2
a1009 1
channel_prepare_select(fd_set **readsetp, fd_set **writesetp, int *maxfdp)
d1029 2
a1030 1
	channel_handler(channel_pre, *readsetp, *writesetp);
@


1.98
log
@log functions should not be passed strings that end in newline as they
get passed on to syslog() and when logging to stderr, do_log() appends
its own newline.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.97 2001/03/04 00:03:59 markus Exp $");
a143 12
/*
 * Permits opening to any host/port in SSH_MSG_PORT_OPEN.  This is usually
 * called by the server, because the user could connect to any port anyway,
 * and the server has no way to know but to trust the client anyway.
 */

void
channel_permit_all_opens()
{
	all_opens_permitted = 1;
}

d1776 39
a1814 1
/* XXX move to aux.c */
d1816 1
a1816 1
channel_connect_to(const char *host, u_short host_port)
d1826 1
a1826 1
	snprintf(strport, sizeof strport, "%d", host_port);
d1828 2
a1829 1
		error("%.100s: unknown host (%s)", host, gai_strerror(gaierr));
d1837 1
a1837 1
			error("channel_connect_to: getnameinfo failed");
a1839 1
		/* Create the socket. */
a1846 1
		/* Connect to the host/port. */
d1849 1
a1849 1
			error("connect %.100s port %s: %.100s", ntop, strport,
d1859 1
a1859 1
		error("connect %.100s port %d: failed.", host, host_port);
d1865 1
d1870 1
d1873 1
a1873 1
			return channel_connect_to(
d1881 22
d1914 1
a1914 2
	int remote_channel, sock = -1, newch, i, denied;
	u_int host_len, originator_len;
a1915 1
	/* Get remote channel number. */
d1917 1
a1917 5

	/* Get host name to connect to. */
	host = packet_get_string(&host_len);

	/* Get port to connect to. */
a1919 1
	/* Get remote originator name. */
d1921 1
a1921 2
		originator_string = packet_get_string(&originator_len);
		originator_len += 4;	/* size of packet_int */
a1923 1
		originator_len = 0;	/* no originator supplied */
d1925 3
a1927 24

	packet_integrity_check(plen,
	    4 + 4 + host_len + 4 + originator_len, SSH_MSG_PORT_OPEN);

	/* Check if opening that port is permitted. */
	denied = 0;
	if (!all_opens_permitted) {
		/* Go trough all permitted ports. */
		for (i = 0; i < num_permitted_opens; i++)
			if (permitted_opens[i].port_to_connect == host_port &&
			    strcmp(permitted_opens[i].host_to_connect, host) == 0)
				break;

		/* Check if we found the requested port among those permitted. */
		if (i >= num_permitted_opens) {
			/* The port is not permitted. */
			log("Received request to connect to %.100s:%d, but the request was denied.",
			    host, host_port);
			denied = 1;
		}
	}
	sock = denied ? -1 : channel_connect_to(host, host_port);
	if (sock > 0) {
		/* Allocate a channel for this connection. */
a1929 1
/*XXX delay answer? */
d1932 1
@


1.97
log
@debug1->2
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.96 2001/02/28 21:31:32 markus Exp $");
d524 1
a524 1
		log("X11 connection rejected because of wrong authentication.\r\n");
@


1.96
log
@typo
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.95 2001/02/28 21:27:48 markus Exp $");
d1072 1
a1072 1
			debug("channel %d: no data after CLOSE", c->self);
@


1.95
log
@use ignore message to simulate a SSH2_MSG_CHANNEL_DATA message
use random content in ignore messages.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.94 2001/02/28 12:55:07 markus Exp $");
d797 1
a797 1
				 * traffic analysis. We need too match the
@


1.94
log
@unify debug messages
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.93 2001/02/28 08:54:55 markus Exp $");
d771 1
a792 1
			struct termios tio;
d797 3
a799 1
				 * traffic analysis.
d801 1
a801 3
				packet_start(SSH2_MSG_IGNORE);
				memset(buffer_ptr(&c->output), 0, len);
				packet_put_string(buffer_ptr(&c->output), len);
@


1.93
log
@make sure remote stderr does not get truncated.
remove closed fd's from the select mask.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.92 2001/02/16 13:38:18 markus Exp $");
d198 1
a198 1
		debug("channel: %d: rfd %d isatty", c->self, c->rfd);
d201 1
a201 1
			error("channel: %d: wfd %d is not a tty?",
d1072 1
a1072 1
			debug("channel: %d: no data after CLOSE", c->self);
d1427 1
a1427 1
		debug("channel: %d rcvd request for %s", c->self, service);
@


1.92
log
@remove debug
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.91 2001/02/15 23:19:59 markus Exp $");
d827 8
a834 1
			if (len > 0) {
d843 4
a846 2
			if (len == 0) {
				debug("channel %d: closing efd %d",
d850 1
a850 1
			} else if (len > 0)
d852 1
d858 1
a858 1
channel_check_window(Channel *c, fd_set * readset, fd_set * writeset)
d889 2
a890 1
	channel_check_window(c, readset, writeset);
d998 18
a1015 1
		chan_delete_if_full_closed(c);
a1067 3
			if (c->istate != CHAN_INPUT_OPEN &&
			    c->istate != CHAN_INPUT_WAIT_DRAIN)
				continue;
d1071 1
d1077 3
a1079 2
		len = buffer_len(&c->input);
		if (len > 0) {
d1119 3
d1133 1
@


1.91
log
@genericize password padding function for SSH1 and SSH2.
add stylized echo to 2, too.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.90 2001/02/08 21:58:28 markus Exp $");
a802 1
				debug("channel: %d simulate echo (%d)", c->self, len);
@


1.90
log
@nuke sprintf, ok deraadt@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.89 2001/02/04 15:32:23 stevesk Exp $");
d196 12
d790 15
@


1.89
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.88 2001/02/01 21:58:08 markus Exp $");
d2173 1
a2173 1
	u_int i, value;
d2211 2
a2212 1
	new_data = xmalloc(2 * data_len + 1);
d2214 2
a2215 1
		sprintf(new_data + 2 * i, "%02x", (u_char) x11_fake_data[i]);
@


1.88
log
@use ipaddr in channel messages, ietf-secsh wants this
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.87 2001/01/31 20:37:22 markus Exp $");
d707 1
a707 1
                if (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, (char *)&err, &sz) < 0) {
d1564 1
a1564 1
	    	ctype = SSH_CHANNEL_RPORT_LISTENER;
d1770 1
a1770 1
			continue;	/* fail -- try next */	
d1777 1
a1777 1
		error("connect %.100s port %d: failed.", host, host_port);	
d2458 1
a2458 1
void   
@


1.87
log
@do not disconnect if local port forwarding fails, e.g. if port is already in use
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.86 2001/01/31 19:26:19 markus Exp $");
d603 1
a603 1
	char buf[1024], *remote_hostname, *rtype;
d619 1
a619 1
		remote_hostname = get_remote_hostname(newsock);
d625 1
a625 1
		    remote_hostname, remote_port);
d647 1
a647 1
			packet_put_cstring(remote_hostname);
d660 1
a660 1
		xfree(remote_hostname);
@


1.86
log
@ssh.com-2.0.1x does not send additional info in CHANNEL_OPEN_FAILURE messages; bug report from edmundo@@rano.org
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.85 2001/01/29 19:42:35 markus Exp $");
d1534 1
a1534 1
void
d1538 1
a1538 1
	channel_request_forwarding(
d1548 1
a1548 1
void
d1560 2
d1570 4
a1573 2
	if (strlen(host) > sizeof(channels[0].path) - 1)
		packet_disconnect("Forward host name too long.");
a1587 1
	success = 0;
d1636 2
a1637 1
		packet_disconnect("cannot listen port: %d", listen_port);	/*XXX ?disconnect? */
d1639 1
@


1.85
log
@add get_peer_ipaddr(socket), x11-fwd in ssh2 requires ipaddr, not DNS
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.84 2001/01/29 16:55:36 markus Exp $");
d1320 2
a1321 1
	int id;
d1334 5
a1338 4
		int reason = packet_get_int();
		char *msg  = packet_get_string(NULL);
		char *lang  = packet_get_string(NULL);
		log("channel_open_failure: %d: reason %d: %s", id, reason, msg);
d1340 6
a1345 2
		xfree(msg);
		xfree(lang);
@


1.84
log
@fix select overflow; ok deraadt@@ and stevesk@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.83 2001/01/24 21:03:50 stevesk Exp $");
d549 1
a549 1
	char buf[16384], *remote_hostname;
d560 1
a560 1
		remote_hostname = get_remote_hostname(newsock);
d563 1
a563 1
		    remote_hostname, remote_port);
d575 2
a576 2
			/* originator host and port */
			packet_put_cstring(remote_hostname);
d590 1
a590 1
		xfree(remote_hostname);
@


1.83
log
@missing freeaddrinfo(); ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.82 2001/01/21 19:05:46 markus Exp $");
d87 1
a87 1
static int channel_max_fd_value = 0;
d184 4
a187 6
	if (rfd > channel_max_fd_value)
		channel_max_fd_value = rfd;
	if (wfd > channel_max_fd_value)
		channel_max_fd_value = wfd;
	if (efd > channel_max_fd_value)
		channel_max_fd_value = efd;
d966 1
a966 1
channel_prepare_select(fd_set * readset, fd_set * writeset)
d968 19
a986 1
	channel_handler(channel_pre, readset, writeset);
d995 1
a995 1
/* If there is data to send to the connection, send some of it now. */
a1433 8
}

/* Returns the maximum file descriptor number used by the channels. */

int
channel_max_fd()
{
	return channel_max_fd_value;
@


1.82
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.81 2001/01/19 15:55:10 markus Exp $");
d1905 1
@


1.81
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d43 4
a46 1
RCSID("$OpenBSD: channels.c,v 1.80 2001/01/08 22:03:23 markus Exp $");
d49 2
d55 2
a56 3
#include "readconf.h"
#include "servconf.h"

d60 1
a60 6

#include "ssh1.h"
#include "ssh2.h"

#include <openssl/rsa.h>
#include <openssl/dsa.h>
d132 3
@


1.80
log
@O_NDELAY -> O_NONBLOCK; thanks stevesk@@pobox.com
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.79 2000/12/29 22:19:13 markus Exp $");
d57 1
@


1.79
log
@missing xfree; from vaughan99@@yahoo.com
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.78 2000/12/29 11:05:55 markus Exp $");
d1740 1
a1740 1
		if (fcntl(sock, F_SETFL, O_NDELAY) < 0)
@


1.78
log
@remove->unlink; stevesk@@pobox.com
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.77 2000/12/19 23:17:56 markus Exp $");
d310 2
d314 3
a316 1
	debug("channel_free: channel %d: status: %s", id, channel_open_message());
@


1.77
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.76 2000/12/19 22:43:44 markus Exp $");
d2230 1
a2230 1
	remove(channel_forwarded_auth_socket_name);
@


1.76
log
@remove() -> unlink() for consistency
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.75 2000/12/05 20:34:09 markus Exp $");
d98 1
a98 1
unsigned int x11_saved_data_len = 0;
d105 1
a105 1
unsigned int x11_fake_data_len;
d439 2
a440 2
	unsigned char *ucp;
	unsigned int proto_len, data_len;
d447 1
a447 1
	ucp = (unsigned char *) buffer_ptr(&c->output);
d1069 1
a1069 1
	unsigned int data_len;
d1115 1
a1115 1
	unsigned int data_len;
d1158 1
a1158 1
	unsigned int i;
d1426 1
a1426 1
	unsigned int i;
d1783 1
a1783 1
	unsigned int host_len, originator_len;
d1941 1
a1941 1
connect_local_xsocket(unsigned int dnr)
d2074 1
a2074 1
	unsigned int remote_len;
d2145 2
a2146 2
	unsigned int data_len = (unsigned int) strlen(data) / 2;
	unsigned int i, value;
d2186 1
a2186 1
		sprintf(new_data + 2 * i, "%02x", (unsigned char) x11_fake_data[i]);
@


1.75
log
@async connects for -R/-L; ok deraadt@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.74 2000/11/30 22:54:31 markus Exp $");
d1384 1
a1384 1
			remove(channels[i].path);
@


1.74
log
@debug -> warn if server tries to do -R style fwd w/o client requesting this; ok niels@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.73 2000/11/06 23:04:55 markus Exp $");
d349 7
d695 22
d875 1
d882 1
d895 1
d902 1
d913 1
d919 1
d1435 1
d1485 1
d1736 2
d1739 2
a1740 1
		if (connect(sock, ai->ai_addr, ai->ai_addrlen) < 0) {
d1826 3
a1828 1
		newch = channel_allocate(SSH_CHANNEL_OPEN, sock, originator_string);
@


1.73
log
@agent forwarding and -R for ssh2, based on work from jhuuskon@@messi.uku.fi
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.72 2000/10/27 07:48:22 markus Exp $");
d1726 2
a1727 1
	debug("channel_connect_by_listen_adress: unknown listen_port %d", listen_port);
@


1.72
log
@deny agent/x11 forwarding unless requested; thanks to jwl@@pobox.com
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.71 2000/10/27 07:32:17 markus Exp $");
d591 1
a591 1
	char buf[1024], *remote_hostname;
d594 3
d614 2
a615 1
		newch = channel_new("direct-tcpip",
d621 1
a621 1
			packet_put_cstring("direct-tcpip");
d625 9
a633 3
			/* target host and port */
			packet_put_string(c->path, strlen(c->path));
			packet_put_int(c->host_port);
d670 14
a683 4
		newch = channel_allocate(SSH_CHANNEL_OPENING, newsock,
		    xstrdup("accepted auth socket"));
		packet_start(SSH_SMSG_AGENT_OPEN);
		packet_put_int(newch);
d843 1
d845 1
d849 1
d851 1
d1353 1
d1397 1
d1443 1
d1476 9
d1486 4
d1491 4
a1494 2
channel_request_local_forwarding(u_short port, const char *host,
				 u_short host_port, int gateway_ports)
d1496 1
a1496 1
	int success, ch, sock, on = 1;
d1499 1
d1502 8
d1513 1
d1522 1
a1522 1
	snprintf(strport, sizeof strport, "%d", port);
d1532 1
a1532 1
			error("channel_request_local_forwarding: getnameinfo failed");
d1566 1
a1566 3
		ch = channel_new(
		    "port listener", SSH_CHANNEL_PORT_LISTENER,
		    sock, sock, -1,
d1570 2
a1571 2
		channels[ch].host_port = host_port;
		channels[ch].listening_port = port;
d1575 1
a1575 1
		packet_disconnect("cannot listen port: %d", port);
d1585 2
a1586 2
channel_request_remote_forwarding(u_short listen_port, const char *host_to_connect,
				  u_short port_to_connect)
d1588 2
a1589 1
	int payload_len;
a1593 5
	permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
	permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
	permitted_opens[num_permitted_opens].listen_port = listen_port;
	num_permitted_opens++;

d1602 4
d1613 21
a1633 5
		/*
		 * Wait for response from the remote side.  It will send a disconnect
		 * message on failure, and we will never see it here.
		 */
		packet_read_expect(&payload_len, SSH_SMSG_SUCCESS);
d1661 1
a1661 3
	/*
	 * Initiate forwarding,
	 */
d1717 13
d2254 5
a2258 2
	newch = channel_allocate(SSH_CHANNEL_AUTH_SOCKET, sock,
				 xstrdup("auth socket"));
@


1.72.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d43 1
a43 4
RCSID("$OpenBSD: channels.c,v 1.92 2001/02/16 13:38:18 markus Exp $");

#include <openssl/rsa.h>
#include <openssl/dsa.h>
a45 2
#include "ssh1.h"
#include "ssh2.h"
d50 3
a52 2
#include "log.h"
#include "misc.h"
d56 5
a60 1
#include "canohost.h"
d87 1
a87 1
static int channel_max_fd = 0;
d98 1
a98 1
u_int x11_saved_data_len = 0;
d105 1
a105 1
u_int x11_fake_data_len;
a132 3
/* AF_UNSPEC or AF_INET or AF_INET6 */
extern int IPv4or6;

d181 6
a186 4
	channel_max_fd = MAX(channel_max_fd, rfd);
	channel_max_fd = MAX(channel_max_fd, wfd);
	channel_max_fd = MAX(channel_max_fd, efd);

a194 12
	/* XXX ugly hack: nonblock is only set by the server */
	if (nonblock && isatty(c->rfd)) {
		debug("channel: %d: rfd %d isatty", c->self, c->rfd);
		c->isatty = 1;
		if (!isatty(c->wfd)) {
			error("channel: %d: wfd %d is not a tty?",
			    c->self, c->wfd);
		}
	} else {
		c->isatty = 0;
	}

a309 2
	char *s = channel_open_message();

d312 1
a312 3
	debug("channel_free: channel %d: status: %s", id, s);
	xfree(s);

a348 7
channel_pre_connecting(Channel *c, fd_set * readset, fd_set * writeset)
{
	debug3("channel %d: waiting for connection", c->self);
	FD_SET(c->sock, writeset);
}

void
d432 2
a433 2
	u_char *ucp;
	u_int proto_len, data_len;
d440 1
a440 1
	ucp = (u_char *) buffer_ptr(&c->output);
d537 1
a537 1
	char buf[16384], *remote_ipaddr;
d548 1
a548 1
		remote_ipaddr = get_peer_ipaddr(newsock);
d551 1
a551 1
		    remote_ipaddr, remote_port);
d563 2
a564 2
			/* originator ipaddr and port */
			packet_put_cstring(remote_ipaddr);
d578 1
a578 1
		xfree(remote_ipaddr);
d591 1
a591 1
	char buf[1024], *remote_ipaddr, *rtype;
a593 3
	rtype = (c->type == SSH_CHANNEL_RPORT_LISTENER) ?
	    "forwarded-tcpip" : "direct-tcpip";

d604 1
a604 1
		remote_ipaddr = get_peer_ipaddr(newsock);
d610 2
a611 3
		    remote_ipaddr, remote_port);

		newch = channel_new(rtype,
d617 1
a617 1
			packet_put_cstring(rtype);
d621 3
a623 9
			if (c->type == SSH_CHANNEL_RPORT_LISTENER) {
				/* listen address, port */
				packet_put_string(c->path, strlen(c->path));
				packet_put_int(c->listening_port);
			} else {
				/* target host, port */
				packet_put_string(c->path, strlen(c->path));
				packet_put_int(c->host_port);
			}
d625 1
a625 1
			packet_put_cstring(remote_ipaddr);
d638 1
a638 1
		xfree(remote_ipaddr);
d660 4
a663 14
		newch = channel_new("accepted auth socket",
		    SSH_CHANNEL_OPENING, newsock, newsock, -1,
		    c->local_window_max, c->local_maxpacket,
		    0, xstrdup("accepted auth socket"), 1);
		if (compat20) {
			packet_start(SSH2_MSG_CHANNEL_OPEN);
			packet_put_cstring("auth-agent@@openssh.com");
			packet_put_int(newch);
			packet_put_int(c->local_window_max);
			packet_put_int(c->local_maxpacket);
		} else {
			packet_start(SSH_SMSG_AGENT_OPEN);
			packet_put_int(newch);
		}
a667 22
void
channel_post_connecting(Channel *c, fd_set * readset, fd_set * writeset)
{
	if (FD_ISSET(c->sock, writeset)) {
		int err = 0;
		int sz = sizeof(err);
		c->type = SSH_CHANNEL_OPEN;
		if (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, (char *)&err, &sz) < 0) {
			debug("getsockopt SO_ERROR failed");
		} else {
			if (err == 0) {
				debug("channel %d: connected)", c->self);
			} else {
				debug("channel %d: not connected: %s",
				    c->self, strerror(err));
				chan_read_failed(c);
				chan_write_failed(c);
			}
		}
	}
}

a724 14
		if (compat20 && c->isatty) {
			struct termios tio;
			if (tcgetattr(c->wfd, &tio) == 0 &&
			    !(tio.c_lflag & ECHO) && (tio.c_lflag & ICANON)) {
				/*
				 * Simulate echo to reduce the impact of
				 * traffic analysis.
				 */
				packet_start(SSH2_MSG_IGNORE);
				memset(buffer_ptr(&c->output), 0, len);
				packet_put_string(buffer_ptr(&c->output), len);
				packet_send();
			}
		}
a822 1
	channel_pre[SSH_CHANNEL_RPORT_LISTENER] =	&channel_pre_listener;
a823 2
	channel_pre[SSH_CHANNEL_AUTH_SOCKET] =		&channel_pre_listener;
	channel_pre[SSH_CHANNEL_CONNECTING] =		&channel_pre_connecting;
a826 1
	channel_post[SSH_CHANNEL_RPORT_LISTENER] =	&channel_post_port_listener;
a827 2
	channel_post[SSH_CHANNEL_AUTH_SOCKET] =		&channel_post_auth_listener;
	channel_post[SSH_CHANNEL_CONNECTING] =		&channel_post_connecting;
a839 1
	channel_pre[SSH_CHANNEL_CONNECTING] =		&channel_pre_connecting;
a845 1
	channel_post[SSH_CHANNEL_CONNECTING] =		&channel_post_connecting;
a855 1
	channel_pre[SSH_CHANNEL_CONNECTING] =		&channel_pre_connecting;
a860 1
	channel_post[SSH_CHANNEL_CONNECTING] =		&channel_post_connecting;
d902 1
a902 1
channel_prepare_select(fd_set **readsetp, fd_set **writesetp, int *maxfdp)
d904 1
a904 19
	int n;
	u_int sz;

	n = MAX(*maxfdp, channel_max_fd);

	sz = howmany(n+1, NFDBITS) * sizeof(fd_mask);
	if (*readsetp == NULL || n > *maxfdp) {
		if (*readsetp)
			xfree(*readsetp);
		if (*writesetp)
			xfree(*writesetp);
		*readsetp = xmalloc(sz);
		*writesetp = xmalloc(sz);
		*maxfdp = n;
	}
	memset(*readsetp, 0, sz);
	memset(*writesetp, 0, sz);

	channel_handler(channel_pre, *readsetp, *writesetp);
d913 1
a913 1
/* If there is data to send to the connection, enqueue some of it now. */
d1010 1
a1010 1
	u_int data_len;
d1056 1
a1056 1
	u_int data_len;
d1099 1
a1099 1
	u_int i;
d1238 1
a1238 2
	int id, reason;
	char *msg = NULL, *lang = NULL;
d1251 4
a1254 5
		reason = packet_get_int();
		if (packet_remaining() > 0) {
			msg  = packet_get_string(NULL);
			lang = packet_get_string(NULL);
		}
d1256 2
a1257 6
		log("channel_open_failure: %d: reason %d %s", id,
		    reason, msg ? msg : "<no additional info>");
		if (msg != NULL)
			xfree(msg);
		if (lang != NULL)
			xfree(lang);
d1325 1
a1325 1
			unlink(channels[i].path);
a1328 1
		case SSH_CHANNEL_RPORT_LISTENER:
d1353 8
d1366 1
a1366 1
	u_int i;
a1371 1
		case SSH_CHANNEL_RPORT_LISTENER:
a1373 1
		case SSH_CHANNEL_CONNECTING: 	/* XXX ??? */
a1416 1
		case SSH_CHANNEL_RPORT_LISTENER:
a1421 1
		case SSH_CHANNEL_CONNECTING:
a1448 9
int
channel_request_local_forwarding(u_short listen_port, const char *host_to_connect,
    u_short port_to_connect, int gateway_ports)
{
	return channel_request_forwarding(
	    NULL, listen_port,
	    host_to_connect, port_to_connect,
	    gateway_ports, /*remote_fwd*/ 0);
}
d1450 3
a1452 9
/*
 * If 'remote_fwd' is true we have a '-R style' listener for protocol 2
 * (SSH_CHANNEL_RPORT_LISTENER).
 */
int
channel_request_forwarding(
    const char *listen_address, u_short listen_port,
    const char *host_to_connect, u_short port_to_connect,
    int gateway_ports, int remote_fwd)
d1454 1
a1454 1
	int success, ch, sock, on = 1, ctype;
a1456 1
	const char *host;
d1459 2
a1460 9
	success = 0;

	if (remote_fwd) {
		host = listen_address;
		ctype = SSH_CHANNEL_RPORT_LISTENER;
	} else {
		host = host_to_connect;
		ctype  =SSH_CHANNEL_PORT_LISTENER;
	}
a1461 6
	if (strlen(host) > sizeof(channels[0].path) - 1) {
		error("Forward host name too long.");
		return success;
	}

	/* XXX listen_address is currently ignored */
d1470 1
a1470 1
	snprintf(strport, sizeof strport, "%d", listen_port);
d1474 1
d1480 1
a1480 1
			error("channel_request_forwarding: getnameinfo failed");
d1514 3
a1516 1
		ch = channel_new("port listener", ctype, sock, sock, -1,
d1520 2
a1521 2
		channels[ch].host_port = port_to_connect;
		channels[ch].listening_port = listen_port;
d1525 1
a1525 2
		error("channel_request_forwarding: cannot listen to port: %d",
		    listen_port);
a1526 1
	return success;
d1535 2
a1536 2
channel_request_remote_forwarding(u_short listen_port,
    const char *host_to_connect, u_short port_to_connect)
d1538 1
a1538 2
	int payload_len, type, success = 0;

d1543 5
a1555 4
		packet_send();
		packet_write_wait();
		/* Assume that server accepts the request */
		success = 1;
d1563 5
a1567 21

		/* Wait for response from the remote side. */
		type = packet_read(&payload_len);
		switch (type) {
		case SSH_SMSG_SUCCESS:
			success = 1;
			break;
		case SSH_SMSG_FAILURE:
			log("Warning: Server denied remote port forwarding.");
			break;
		default:
			/* Unknown packet */
			packet_disconnect("Protocol error for port forward request:"
			    "received packet type %d.", type);
		}
	}
	if (success) {
		permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
		permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
		permitted_opens[num_permitted_opens].listen_port = listen_port;
		num_permitted_opens++;
d1595 3
a1597 1
	/* Initiate forwarding */
a1634 2
		if (fcntl(sock, F_SETFL, O_NONBLOCK) < 0)
			fatal("connect_to: F_SETFL: %s", strerror(errno));
d1636 1
a1636 2
		if (connect(sock, ai->ai_addr, ai->ai_addrlen) < 0 &&
		    errno != EINPROGRESS) {
d1640 1
a1640 1
			continue;	/* fail -- try next */
d1647 1
a1647 1
		error("connect %.100s port %d: failed.", host, host_port);
a1652 14
int
channel_connect_by_listen_adress(u_short listen_port)
{
	int i;
	for (i = 0; i < num_permitted_opens; i++)
		if (permitted_opens[i].listen_port == listen_port)
			return channel_connect_to(
			    permitted_opens[i].host_to_connect,
			    permitted_opens[i].port_to_connect);
	error("WARNING: Server requests forwarding for unknown listen_port %d",
	    listen_port);
	return -1;
}

d1665 1
a1665 1
	u_int host_len, originator_len;
d1708 1
a1708 3
		newch = channel_allocate(SSH_CHANNEL_CONNECTING,
		    sock, originator_string);
/*XXX delay answer? */
a1777 1
		freeaddrinfo(aitop);
d1821 1
a1821 1
connect_local_xsocket(u_int dnr)
d1954 1
a1954 1
	u_int remote_len;
d2025 2
a2026 2
	u_int data_len = (u_int) strlen(data) / 2;
	u_int i, value, len;
d2064 1
a2064 2
	len = 2 * data_len + 1;
	new_data = xmalloc(len);
d2066 1
a2066 2
		snprintf(new_data + 2 * i, len - 2 * i,
		    "%02x", (u_char) x11_fake_data[i]);
d2110 1
a2110 1
	unlink(channel_forwarded_auth_socket_name);
d2177 2
a2178 5
	newch = channel_new("auth socket",
	    SSH_CHANNEL_AUTH_SOCKET, sock, sock, -1,
	    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,
	    0, xstrdup("auth socket"), 1);

d2308 1
a2308 1
void
@


1.72.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.72.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.99 2001/03/16 19:06:29 markus Exp $");
d144 12
d198 1
a198 1
		debug("channel %d: rfd %d isatty", c->self, c->rfd);
d201 1
a201 1
			error("channel %d: wfd %d is not a tty?",
d524 1
a524 1
		log("X11 connection rejected because of wrong authentication.");
a770 1
	struct termios tio;
d792 1
d797 1
a797 3
				 * traffic analysis. We need to match the
				 * size of a SSH2_MSG_CHANNEL_DATA message
				 * (4 byte channel id + data)
d799 3
a801 1
				packet_send_ignore(4 + len);
d827 1
a827 8
			if (len < 0 && (errno == EINTR || errno == EAGAIN))
				return 1;
			if (len <= 0) {
				debug2("channel %d: closing write-efd %d",
				    c->self, c->efd);
				close(c->efd);
				c->efd = -1;
			} else {
d836 2
a837 4
			if (len < 0 && (errno == EINTR || errno == EAGAIN))
				return 1;
			if (len <= 0) {
				debug2("channel %d: closing read-efd %d",
d841 1
a841 1
			} else {
a842 1
			}
d848 1
a848 1
channel_check_window(Channel *c)
d879 1
a879 2

	channel_check_window(c);
d987 1
a987 18
		if (chan_is_dead(c)) {
			/*
			 * we have to remove the fd's from the select mask
			 * before the channels are free'd and the fd's are
			 * closed
			 */
			if (c->wfd != -1)
				FD_CLR(c->wfd, writeset);
			if (c->rfd != -1)
				FD_CLR(c->rfd, readset);
			if (c->efd != -1) {
				if (c->extended_usage == CHAN_EXTENDED_READ)
					FD_CLR(c->efd, readset);
				if (c->extended_usage == CHAN_EXTENDED_WRITE)
					FD_CLR(c->efd, writeset);
			}
			channel_free(c->self);
		}
d1040 3
d1046 1
a1046 2
			/* XXX is this true? */
			debug2("channel %d: no data after CLOSE", c->self);
d1051 2
a1052 3
		if ((c->istate == CHAN_INPUT_OPEN ||
		    c->istate == CHAN_INPUT_WAIT_DRAIN) &&
		    (len = buffer_len(&c->input)) > 0) {
a1091 3
			debug2("channel %d: rwin %d elen %d euse %d",
			    c->self, c->remote_window, buffer_len(&c->extended),
			    c->extended_usage);
a1102 1
			debug2("channel %d: sent ext data %d", c->self, len);
d1396 1
a1396 1
		debug("channel %d: rcvd request for %s", c->self, service);
d1757 1
a1757 39
/*
 * Permits opening to any host/port if permitted_opens[] is empty.  This is
 * usually called by the server, because the user could connect to any port
 * anyway, and the server has no way to know but to trust the client anyway.
 */
void
channel_permit_all_opens()
{
	if (num_permitted_opens == 0)
		all_opens_permitted = 1;
}

void 
channel_add_permitted_opens(char *host, int port)
{
	if (num_permitted_opens >= SSH_MAX_FORWARDS_PER_DIRECTION)
		fatal("channel_request_remote_forwarding: too many forwards");
	debug("allow port forwarding to host %s port %d", host, port);

	permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host);
	permitted_opens[num_permitted_opens].port_to_connect = port;
	num_permitted_opens++;

	all_opens_permitted = 0;
}

void 
channel_clear_permitted_opens(void)
{
	int i;

	for (i = 0; i < num_permitted_opens; i++)
		xfree(permitted_opens[i].host_to_connect);
	num_permitted_opens = 0;

}


/* return socket to remote host, port */
d1759 1
a1759 1
connect_to(const char *host, u_short port)
d1769 1
a1769 1
	snprintf(strport, sizeof strport, "%d", port);
d1771 1
a1771 2
		error("connect_to %.100s: unknown host (%s)", host,
		    gai_strerror(gaierr));
d1779 1
a1779 1
			error("connect_to: getnameinfo failed");
d1782 1
d1790 1
d1793 1
a1793 1
			error("connect_to %.100s port %s: %.100s", ntop, strport,
d1803 1
a1803 1
		error("connect_to %.100s port %d: failed.", host, port);
a1808 1

a1812 1

d1815 1
a1815 1
			return connect_to(
a1822 22
/* Check if connecting to that port is permitted and connect. */
int
channel_connect_to(const char *host, u_short port)
{
	int i, permit;

	permit = all_opens_permitted;
	if (!permit) {
		for (i = 0; i < num_permitted_opens; i++)
			if (permitted_opens[i].port_to_connect == port &&
			    strcmp(permitted_opens[i].host_to_connect, host) == 0)
				permit = 1;

	}
	if (!permit) {
		log("Received request to connect to host %.100s port %d, "
		    "but the request was denied.", host, port);
		return -1;
	}
	return connect_to(host, port);
}

d1834 2
a1835 1
	int remote_channel, sock = -1, newch;
d1837 1
d1839 5
a1843 1
	host = packet_get_string(NULL);
d1846 1
d1848 2
a1849 1
		originator_string = packet_get_string(NULL);
d1852 1
d1854 24
a1877 3
	packet_done();
	sock = channel_connect_to(host, host_port);
	if (sock != -1) {
d1880 1
a1882 1
		/*XXX delay answer? */
@


1.72.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.109 2001/04/17 12:55:03 markus Exp $");
a53 1
#include "bufaux.h"
a135 2
void	 port_open_helper(Channel *c, char *rtype);

d420 1
a420 1
		debug("channel %d: closing after input drain.", c->self);
a541 110
/* try to decode a socks4 header */
int
channel_decode_socks4(Channel *c, fd_set * readset, fd_set * writeset)
{
	u_char *p, *host;
	int len, have, i, found;
	char username[256];	
	struct {
		u_int8_t version;
		u_int8_t command;
		u_int16_t dest_port;
		struct in_addr dest_addr;
	} s4_req, s4_rsp;

	debug2("channel %d: decode socks4", c->self);

	have = buffer_len(&c->input);
	len = sizeof(s4_req);
	if (have < len)
		return 0;
	p = buffer_ptr(&c->input);
	for (found = 0, i = len; i < have; i++) {
		if (p[i] == '\0') {
			found = 1;
			break;
		}
		if (i > 1024) {
			/* the peer is probably sending garbage */
			debug("channel %d: decode socks4: too long",
			    c->self);
			return -1;
		}
	}
	if (!found)
		return 0;
	buffer_get(&c->input, (char *)&s4_req.version, 1);
	buffer_get(&c->input, (char *)&s4_req.command, 1);
	buffer_get(&c->input, (char *)&s4_req.dest_port, 2);
	buffer_get(&c->input, (char *)&s4_req.dest_addr, 4);
	have = buffer_len(&c->input);
	p = buffer_ptr(&c->input);
	len = strlen(p);
	debug2("channel %d: decode socks4: user %s/%d", c->self, p, len);
	if (len > have)
		fatal("channel %d: decode socks4: len %d > have %d",
		    c->self, len, have);
	strlcpy(username, p, sizeof(username));
	buffer_consume(&c->input, len);
	buffer_consume(&c->input, 1);		/* trailing '\0' */

	host = inet_ntoa(s4_req.dest_addr);
	strlcpy(c->path, host, sizeof(c->path));
	c->host_port = ntohs(s4_req.dest_port);
	
	debug("channel %d: dynamic request: socks4 host %s port %u command %u",
	    c->self, host, c->host_port, s4_req.command);

	if (s4_req.command != 1) {
		debug("channel %d: cannot handle: socks4 cn %d",
		    c->self, s4_req.command);
		return -1;
	}
	s4_rsp.version = 0;			/* vn: 0 for reply */
	s4_rsp.command = 90;			/* cd: req granted */
	s4_rsp.dest_port = 0;			/* ignored */
	s4_rsp.dest_addr.s_addr = INADDR_ANY;	/* ignored */
	buffer_append(&c->output, (char *)&s4_rsp, sizeof(s4_rsp));
	return 1;
}

/* dynamic port forwarding */
void
channel_pre_dynamic(Channel *c, fd_set * readset, fd_set * writeset)
{
	u_char *p;
	int have, ret;

	have = buffer_len(&c->input);

	debug2("channel %d: pre_dynamic: have %d", c->self, have);
	/* buffer_dump(&c->input); */
	/* check if the fixed size part of the packet is in buffer. */
	if (have < 4) {
		/* need more */
		FD_SET(c->sock, readset);
		return;
	}
	/* try to guess the protocol */
	p = buffer_ptr(&c->input);
	switch (p[0]) {
	case 0x04:
		ret = channel_decode_socks4(c, readset, writeset);
		break;
	default:
		ret = -1;
		break;
	}
	if (ret < 0) {
		channel_free(c->self);
	} else if (ret == 0) {
		debug2("channel %d: pre_dynamic: need more", c->self);
		/* need more */
		FD_SET(c->sock, readset);
	} else {
		/* switch to the next state */
		c->type = SSH_CHANNEL_OPENING;
		port_open_helper(c, "direct-tcpip");
	}
}

a593 50
void
port_open_helper(Channel *c, char *rtype)
{
	int direct;
	char buf[1024];
	char *remote_ipaddr = get_peer_ipaddr(c->sock);
	u_short remote_port = get_peer_port(c->sock);

	direct = (strcmp(rtype, "direct-tcpip") == 0);

	snprintf(buf, sizeof buf,
	    "%s: listening port %d for %.100s port %d, "
	    "connect from %.200s port %d",
	    rtype, c->listening_port, c->path, c->host_port,
	    remote_ipaddr, remote_port);

	xfree(c->remote_name);
	c->remote_name = xstrdup(buf);

	if (compat20) {
		packet_start(SSH2_MSG_CHANNEL_OPEN);
		packet_put_cstring(rtype);
		packet_put_int(c->self);
		packet_put_int(c->local_window_max);
		packet_put_int(c->local_maxpacket);
		if (direct) {
			/* target host, port */
			packet_put_cstring(c->path);
			packet_put_int(c->host_port);
		} else {
			/* listen address, port */
			packet_put_cstring(c->path);
			packet_put_int(c->listening_port);
		}
		/* originator host and port */
		packet_put_cstring(remote_ipaddr);
		packet_put_int(remote_port);
		packet_send();
	} else {
		packet_start(SSH_MSG_PORT_OPEN);
		packet_put_int(c->self);
		packet_put_cstring(c->path);
		packet_put_int(c->host_port);
		if (have_hostname_in_open)
			packet_put_cstring(c->remote_name);
		packet_send();
	}
	xfree(remote_ipaddr);
}

a599 1
	Channel *nc;
d601 1
a601 1
	int newsock, newch, nextstate;
d603 5
a607 1
	char *rtype;
a612 6

		rtype = (c->type == SSH_CHANNEL_RPORT_LISTENER) ?
		    "forwarded-tcpip" : "direct-tcpip";
		nextstate = (c->host_port == 0) ? SSH_CHANNEL_DYNAMIC :
		    SSH_CHANNEL_OPENING;

d619 8
d628 1
a628 1
		    nextstate, newsock, newsock, -1,
d630 29
a658 6
		    0, xstrdup(rtype), 1);

		nc = channel_lookup(newch);
		if (nc == NULL) {
			error("xxx: no new channel:");
			return;
d660 1
a660 6
		nc->listening_port = c->listening_port;
		nc->host_port = c->host_port;
		strlcpy(nc->path, c->path, sizeof(nc->path));

		if (nextstate != SSH_CHANNEL_DYNAMIC)
			port_open_helper(nc, rtype);
d736 1
a736 5
			if (c->type != SSH_CHANNEL_OPEN) {
				debug("channel %d: not open", c->self);
				channel_free(c->self);
				return -1;
			} else if (compat13) {
d739 1
a739 1
				debug("channel %d: status set to input draining.", c->self);
d747 1
a747 1
				debug("channel %d: filter stops", c->self);
d771 1
a771 5
			if (c->type != SSH_CHANNEL_OPEN) {
				debug("channel %d: not open", c->self);
				channel_free(c->self);
				return -1;
			} else if (compat13) {
d773 1
a773 1
				debug("channel %d: status set to input draining.", c->self);
d848 1
a848 2
	if (c->type == SSH_CHANNEL_OPEN &&
	    !(c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD)) &&
a905 1
	channel_pre[SSH_CHANNEL_DYNAMIC] =		&channel_pre_dynamic;
a912 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open_2;
a925 1
	channel_pre[SSH_CHANNEL_DYNAMIC] =		&channel_pre_dynamic;
a932 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open_1;
a943 1
	channel_pre[SSH_CHANNEL_DYNAMIC] =		&channel_pre_dynamic;
a949 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open_1;
d1008 1
a1008 2
channel_prepare_select(fd_set **readsetp, fd_set **writesetp, int *maxfdp,
    int rekeying)
d1028 1
a1028 2
	if (!rekeying)
		channel_handler(channel_pre, *readsetp, *writesetp);
a1500 1
		case SSH_CHANNEL_DYNAMIC:
a1522 35
/* Returns the id of an open channel suitable for keepaliving */

int
channel_find_open()
{
	u_int i;
	for (i = 0; i < channels_alloc; i++)
		switch (channels[i].type) {
		case SSH_CHANNEL_CLOSED:
		case SSH_CHANNEL_DYNAMIC:
		case SSH_CHANNEL_FREE:
		case SSH_CHANNEL_X11_LISTENER:
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_RPORT_LISTENER:
		case SSH_CHANNEL_OPENING:
			continue;
		case SSH_CHANNEL_LARVAL:
		case SSH_CHANNEL_AUTH_SOCKET:
		case SSH_CHANNEL_CONNECTING: 	/* XXX ??? */
		case SSH_CHANNEL_OPEN:
		case SSH_CHANNEL_X11_OPEN:
			return i;
		case SSH_CHANNEL_INPUT_DRAINING:
		case SSH_CHANNEL_OUTPUT_DRAINING:
			if (!compat13)
				fatal("cannot happen: OUT_DRAIN");
			return i;
		default:
			fatal("channel_find_open: bad channel type %d", channels[i].type);
			/* NOTREACHED */
		}
	return -1;
}


a1551 1
		case SSH_CHANNEL_DYNAMIC:
d1788 1
a1788 1
void
d1802 1
a1802 1
void
d2354 1
a2354 1
	temporarily_use_uid(pw);
@


1.72.2.5
log
@Pull in patch from current:
Errata:
sshd(8) allows users to delete arbitrary files named "cookies" if
X11 forwarding is enabled. X11 forwarding is disabled by default.
Fix (markus):
- use fatal_register_cleanup instead of atexit, sync with x11 authdir
  handling
- switch uid when cleaning up tmp files and sockets; reported by
  zen-parse@@gmx.net on bugtraq
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.72.2.4 2001/05/07 21:09:27 jason Exp $");
d2527 1
a2527 1
auth_sock_cleanup_proc(void *_pw)
d2529 2
a2530 9
	struct passwd *pw = _pw;

	if (channel_forwarded_auth_socket_name) {
		temporarily_use_uid(pw);
		unlink(channel_forwarded_auth_socket_name);
		rmdir(channel_forwarded_auth_socket_dir);
		channel_forwarded_auth_socket_name = NULL;
		restore_uid();
	}
d2569 5
a2573 3
	/* delete agent socket on fatal() */
	fatal_add_cleanup(auth_sock_cleanup_proc, pw);

@


1.72.2.6
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d15 1
d17 1
a17 1
 * Copyright (c) 1999, 2000, 2001 Markus Friedl.  All rights reserved.
d43 4
a46 1
RCSID("$OpenBSD: channels.c,v 1.134 2001/09/17 21:04:01 markus Exp $");
d53 2
d59 1
d65 2
d68 2
a69 1
/* -- channel core */
d75 1
a75 1
static Channel **channels = NULL;
d79 2
a80 1
 * initialized (at least the type field); unused slots set to NULL
d86 1
a86 1
 * updated in channel_new.
d90 3
d94 13
a106 1
/* -- tcp forwarding */
a121 1

d131 2
d134 2
a135 1
/* -- X11 forwarding */
d137 1
a137 2
/* Maximum number of fake X11 displays to try. */
#define MAX_DISPLAYS  1000
d139 1
a139 2
/* Saved X11 authentication protocol name. */
static char *x11_saved_proto = NULL;
d141 5
a145 25
/* Saved X11 authentication data.  This is the real data. */
static char *x11_saved_data = NULL;
static u_int x11_saved_data_len = 0;

/*
 * Fake X11 authentication data.  This is what the server will be sending us;
 * we should replace any occurrences of this by the real data.
 */
static char *x11_fake_data = NULL;
static u_int x11_fake_data_len;


/* -- agent forwarding */

#define	NUM_SOCKS	10

/* Name and directory of socket for authentication agent forwarding. */
static char *auth_sock_name = NULL;
static char *auth_sock_dir = NULL;

/* AF_UNSPEC or AF_INET or AF_INET6 */
extern int IPv4or6;

/* helper */
static void port_open_helper(Channel *c, char *rtype);
d147 1
a147 1
/* -- channel core */
a152 1

d157 2
a158 2
	c = channels[id];
	if (c == NULL) {
d170 1
a170 1
static void
d215 1
a215 1
Channel *
d226 1
a226 1
		channels = xmalloc(channels_alloc * sizeof(Channel *));
d228 6
a233 2
			channels[i] = NULL;
		fatal_add_cleanup((void (*) (void *)) channel_free_all, NULL);
d237 1
a237 1
		if (channels[i] == NULL) {
d247 1
a247 1
		channels = xrealloc(channels, channels_alloc * sizeof(Channel *));
d249 1
a249 1
			channels[i] = NULL;
d251 2
a252 2
	/* Initialize and return new channel. */
	c = channels[found] = xmalloc(sizeof(Channel));
d272 1
a272 2
	c->force_drain = 0;
	c->detach_user = NULL;
d275 1
a275 221
	return c;
}

static int
channel_find_maxfd(void)
{
	int i, max = 0;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c != NULL) {
			max = MAX(max, c->rfd);
			max = MAX(max, c->wfd);
			max = MAX(max, c->efd);
		}
	}
	return max;
}

int
channel_close_fd(int *fdp)
{
	int ret = 0, fd = *fdp;

	if (fd != -1) {
		ret = close(fd);
		*fdp = -1;
		if (fd == channel_max_fd)
			channel_max_fd = channel_find_maxfd();
	}
	return ret;
}

/* Close all channel fd/socket. */

static void
channel_close_fds(Channel *c)
{
	debug3("channel_close_fds: channel %d: r %d w %d e %d",
	    c->self, c->rfd, c->wfd, c->efd);

	channel_close_fd(&c->sock);
	channel_close_fd(&c->rfd);
	channel_close_fd(&c->wfd);
	channel_close_fd(&c->efd);
}

/* Free the channel and close its fd/socket. */

void
channel_free(Channel *c)
{
	char *s;
	int i, n;

	for (n = 0, i = 0; i < channels_alloc; i++)
		if (channels[i])
			n++;
	debug("channel_free: channel %d: %s, nchannels %d", c->self,
	    c->remote_name ? c->remote_name : "???", n);

	s = channel_open_message();
	debug3("channel_free: status: %s", s);
	xfree(s);

	if (c->detach_user != NULL) {
		debug("channel_free: channel %d: detaching channel user", c->self);
		c->detach_user(c->self, NULL);
	}
	if (c->sock != -1)
		shutdown(c->sock, SHUT_RDWR);
	channel_close_fds(c);
	buffer_free(&c->input);
	buffer_free(&c->output);
	buffer_free(&c->extended);
	if (c->remote_name) {
		xfree(c->remote_name);
		c->remote_name = NULL;
	}
	channels[c->self] = NULL;
	xfree(c);
}

void
channel_free_all(void)
{
	int i;

	for (i = 0; i < channels_alloc; i++)
		if (channels[i] != NULL)
			channel_free(channels[i]);
}

void
channel_detach_all(void)
{
	int i;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c != NULL && c->detach_user != NULL) {
			debug("channel_detach_all: channel %d", c->self);
			c->detach_user(c->self, NULL);
			c->detach_user = NULL;
		}
	}
}

/*
 * Closes the sockets/fds of all channels.  This is used to close extra file
 * descriptors after a fork.
 */

void
channel_close_all()
{
	int i;

	for (i = 0; i < channels_alloc; i++)
		if (channels[i] != NULL)
			channel_close_fds(channels[i]);
}

/*
 * Stop listening to channels.
 */

void
channel_stop_listening(void)
{
	int i;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c != NULL) {
			switch (c->type) {
			case SSH_CHANNEL_AUTH_SOCKET:
			case SSH_CHANNEL_PORT_LISTENER:
			case SSH_CHANNEL_RPORT_LISTENER:
			case SSH_CHANNEL_X11_LISTENER:
				channel_close_fd(&c->sock);
				channel_free(c);
				break;
			}
		}
	}
}

/*
 * Returns true if no channel has too much buffered data, and false if one or
 * more channel is overfull.
 */

int
channel_not_very_much_buffered_data()
{
	u_int i;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c != NULL && c->type == SSH_CHANNEL_OPEN) {
			if (!compat20 && buffer_len(&c->input) > packet_get_maxsize()) {
				debug("channel %d: big input buffer %d",
				    c->self, buffer_len(&c->input));
				return 0;
			}
			if (buffer_len(&c->output) > packet_get_maxsize()) {
				debug("channel %d: big output buffer %d",
				    c->self, buffer_len(&c->output));
				return 0;
			}
		}
	}
	return 1;
}

/* Returns true if any channel is still open. */

int
channel_still_open()
{
	int i;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c == NULL)
			continue;
		switch (c->type) {
		case SSH_CHANNEL_X11_LISTENER:
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_RPORT_LISTENER:
		case SSH_CHANNEL_CLOSED:
		case SSH_CHANNEL_AUTH_SOCKET:
		case SSH_CHANNEL_DYNAMIC:
		case SSH_CHANNEL_CONNECTING:
		case SSH_CHANNEL_ZOMBIE:
			continue;
		case SSH_CHANNEL_LARVAL:
			if (!compat20)
				fatal("cannot happen: SSH_CHANNEL_LARVAL");
			continue;
		case SSH_CHANNEL_OPENING:
		case SSH_CHANNEL_OPEN:
		case SSH_CHANNEL_X11_OPEN:
			return 1;
		case SSH_CHANNEL_INPUT_DRAINING:
		case SSH_CHANNEL_OUTPUT_DRAINING:
			if (!compat13)
				fatal("cannot happen: OUT_DRAIN");
			return 1;
		default:
			fatal("channel_still_open: bad channel type %d", c->type);
			/* NOTREACHED */
		}
	}
	return 0;
d277 1
a277 3

/* Returns the id of an open channel suitable for keepaliving */

d279 1
a279 46
channel_find_open()
{
	int i;
	Channel *c;

	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c == NULL)
			continue;
		switch (c->type) {
		case SSH_CHANNEL_CLOSED:
		case SSH_CHANNEL_DYNAMIC:
		case SSH_CHANNEL_X11_LISTENER:
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_RPORT_LISTENER:
		case SSH_CHANNEL_OPENING:
		case SSH_CHANNEL_CONNECTING:
		case SSH_CHANNEL_ZOMBIE:
			continue;
		case SSH_CHANNEL_LARVAL:
		case SSH_CHANNEL_AUTH_SOCKET:
		case SSH_CHANNEL_OPEN:
		case SSH_CHANNEL_X11_OPEN:
			return i;
		case SSH_CHANNEL_INPUT_DRAINING:
		case SSH_CHANNEL_OUTPUT_DRAINING:
			if (!compat13)
				fatal("cannot happen: OUT_DRAIN");
			return i;
		default:
			fatal("channel_find_open: bad channel type %d", c->type);
			/* NOTREACHED */
		}
	}
	return -1;
}


/*
 * Returns a message describing the currently open forwarded connections,
 * suitable for sending to the client.  The message contains crlf pairs for
 * newlines.
 */

char *
channel_open_message()
d281 1
a281 115
	Buffer buffer;
	Channel *c;
	char buf[1024], *cp;
	int i;

	buffer_init(&buffer);
	snprintf(buf, sizeof buf, "The following connections are open:\r\n");
	buffer_append(&buffer, buf, strlen(buf));
	for (i = 0; i < channels_alloc; i++) {
		c = channels[i];
		if (c == NULL)
			continue;
		switch (c->type) {
		case SSH_CHANNEL_X11_LISTENER:
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_RPORT_LISTENER:
		case SSH_CHANNEL_CLOSED:
		case SSH_CHANNEL_AUTH_SOCKET:
		case SSH_CHANNEL_ZOMBIE:
			continue;
		case SSH_CHANNEL_LARVAL:
		case SSH_CHANNEL_OPENING:
		case SSH_CHANNEL_CONNECTING:
		case SSH_CHANNEL_DYNAMIC:
		case SSH_CHANNEL_OPEN:
		case SSH_CHANNEL_X11_OPEN:
		case SSH_CHANNEL_INPUT_DRAINING:
		case SSH_CHANNEL_OUTPUT_DRAINING:
			snprintf(buf, sizeof buf, "  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n",
			    c->self, c->remote_name,
			    c->type, c->remote_id,
			    c->istate, buffer_len(&c->input),
			    c->ostate, buffer_len(&c->output),
			    c->rfd, c->wfd);
			buffer_append(&buffer, buf, strlen(buf));
			continue;
		default:
			fatal("channel_open_message: bad channel type %d", c->type);
			/* NOTREACHED */
		}
	}
	buffer_append(&buffer, "\0", 1);
	cp = xstrdup(buffer_ptr(&buffer));
	buffer_free(&buffer);
	return cp;
}

void
channel_send_open(int id)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_send_open: %d: bad id", id);
		return;
	}
	debug("send channel open %d", id);
	packet_start(SSH2_MSG_CHANNEL_OPEN);
	packet_put_cstring(c->ctype);
	packet_put_int(c->self);
	packet_put_int(c->local_window);
	packet_put_int(c->local_maxpacket);
	packet_send();
}

void
channel_request(int id, char *service, int wantconfirm)
{
	channel_request_start(id, service, wantconfirm);
	packet_send();
	debug("channel request %d: %s", id, service) ;
}
void
channel_request_start(int id, char *service, int wantconfirm)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_request: %d: bad id", id);
		return;
	}
	packet_start(SSH2_MSG_CHANNEL_REQUEST);
	packet_put_int(c->remote_id);
	packet_put_cstring(service);
	packet_put_char(wantconfirm);
}
void
channel_register_callback(int id, int mtype, channel_callback_fn *fn, void *arg)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_register_callback: %d: bad id", id);
		return;
	}
	c->cb_event = mtype;
	c->cb_fn = fn;
	c->cb_arg = arg;
}
void
channel_register_cleanup(int id, channel_callback_fn *fn)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_register_cleanup: %d: bad id", id);
		return;
	}
	c->detach_user = fn;
}
void
channel_cancel_cleanup(int id)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_cancel_cleanup: %d: bad id", id);
		return;
	}
	c->detach_user = NULL;
d283 4
d288 1
a288 1
channel_register_filter(int id, channel_filter_fn *fn)
d290 15
a304 4
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_register_filter: %d: bad id", id);
		return;
a305 1
	c->input_filter = fn;
d308 2
d311 1
a311 2
channel_set_fds(int id, int rfd, int wfd, int efd,
    int extusage, int nonblock)
d314 22
a335 10
	if (c == NULL || c->type != SSH_CHANNEL_LARVAL)
		fatal("channel_activate for non-larval channel %d.", id);
	channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
	c->type = SSH_CHANNEL_OPEN;
	/* XXX window size? */
	c->local_window = c->local_window_max = c->local_maxpacket * 2;
	packet_start(SSH2_MSG_CHANNEL_WINDOW_ADJUST);
	packet_put_int(c->remote_id);
	packet_put_int(c->local_window);
	packet_send();
d350 1
a350 1
static void
d356 1
a356 1
static void
d363 1
a363 1
static void
d372 1
a372 1
static void
d389 1
a389 1
static void
d415 1
a415 1
static void
d427 1
a427 1
static void
d431 1
a431 1
		chan_mark_dead(c);
a442 1
 * Returns: 0 = need more data, -1 = wrong cookie, 1 = ok
d444 2
a445 2
static int
x11_open_helper(Buffer *b)
d451 1
a451 1
	if (buffer_len(b) < 12)
d455 1
a455 1
	ucp = (u_char *) buffer_ptr(b);
d469 1
a469 1
	if (buffer_len(b) <
d502 1
a502 1
static void
d505 1
a505 1
	int ret = x11_open_helper(&c->output);
d518 1
a518 1
		channel_close_fd(&c->sock);
d527 1
a527 1
static void
d530 1
a530 4
	int ret = x11_open_helper(&c->output);

	/* c->force_drain = 1; */

d546 1
a546 1
static int
d616 1
a616 1
static void
d643 1
a643 1
		chan_mark_dead(c);
d656 1
a656 1
static void
a658 1
	Channel *nc;
d660 1
a660 1
	int newsock;
d678 1
a678 1
		nc = channel_new("accepted x11 socket",
a681 5
		if (nc == NULL) {
			close(newsock);
			xfree(remote_ipaddr);
			return;
		}
d685 1
a685 1
			packet_put_int(nc->self);
d698 3
a700 4
			packet_put_int(nc->self);
			if (packet_get_protocol_flags() &
			    SSH_PROTOFLAG_HOST_IN_FWD_OPEN)
				packet_put_cstring(buf);
d707 1
a707 1
static void
d750 1
a750 2
		if (packet_get_protocol_flags() &
		    SSH_PROTOFLAG_HOST_IN_FWD_OPEN)
d760 1
a760 1
static void
d765 1
a765 1
	int newsock, nextstate;
d776 2
a777 3
		nextstate = (c->host_port == 0 &&
		    c->type != SSH_CHANNEL_RPORT_LISTENER) ?
		    SSH_CHANNEL_DYNAMIC : SSH_CHANNEL_OPENING;
d785 1
a785 1
		nc = channel_new(rtype,
d789 2
d792 1
a792 2
			error("channel_post_port_listener: no new channel:");
			close(newsock);
d808 1
a808 1
static void
a810 3
	Channel *nc;
	char *name;
	int newsock;
d812 1
d822 1
a822 2
		name = xstrdup("accepted auth socket");
		nc = channel_new("accepted auth socket",
d825 1
a825 6
		    0, name, 1);
		if (nc == NULL) {
			error("channel_post_auth_listener: channel_new failed");
			xfree(name);
			close(newsock);
		}
d829 1
a829 1
			packet_put_int(nc->self);
d834 1
a834 1
			packet_put_int(nc->self);
d840 1
a840 1
static void
a842 3
	int err = 0;
	socklen_t sz = sizeof(err);

d844 5
a848 19
		if (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, (char *)&err,
		    &sz) < 0) {
			err = errno;
			error("getsockopt SO_ERROR failed");
		}
		if (err == 0) {
			debug("channel %d: connected", c->self);
			c->type = SSH_CHANNEL_OPEN;
			if (compat20) {
				packet_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);
				packet_put_int(c->remote_id);
				packet_put_int(c->self);
				packet_put_int(c->local_window);
				packet_put_int(c->local_maxpacket);
			} else {
				packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
				packet_put_int(c->remote_id);
				packet_put_int(c->self);
			}
d850 2
a851 10
			debug("channel %d: not connected: %s",
			    c->self, strerror(err));
			if (compat20) {
				packet_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);
				packet_put_int(c->remote_id);
				packet_put_int(SSH2_OPEN_CONNECT_FAILED);
				if (!(datafellows & SSH_BUG_OPENFAILURE)) {
					packet_put_cstring(strerror(err));
					packet_put_cstring("");
				}
d853 4
a856 2
				packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
				packet_put_int(c->remote_id);
a857 1
			chan_mark_dead(c);
a858 1
		packet_send();
d862 1
a862 1
static int
d878 1
a878 1
				chan_mark_dead(c);
d883 1
a883 1
				debug("channel %d: input draining.", c->self);
d900 1
a900 1
static int
a903 2
	u_char *data;
	u_int dlen;
d910 2
a911 3
		data = buffer_ptr(&c->output);
		dlen = buffer_len(&c->output);
		len = write(c->wfd, data, dlen);
d917 1
a917 1
				chan_mark_dead(c);
d921 1
a921 1
				debug("channel %d: input draining.", c->self);
d928 1
a928 1
		if (compat20 && c->isatty && dlen >= 1 && data[0] != '\r') {
d948 1
a948 1
static int
d968 2
a969 1
				channel_close_fd(&c->efd);
d984 2
a985 1
				channel_close_fd(&c->efd);
d993 1
a993 1
static int
d1013 1
a1013 1
static void
d1020 1
a1020 1
static void
d1030 1
a1030 1
static void
d1045 1
a1045 1
static void
d1066 1
a1066 1
static void
d1088 1
a1088 1
static void
d1107 1
a1107 1
static void
d1123 1
a1123 1
static void
d1135 4
a1138 2
		c = channels[i];
		if (c == NULL)
d1140 1
a1140 2
		if (ftab[c->type] != NULL)
			(*ftab[c->type])(c, readset, writeset);
d1157 1
a1157 1
			channel_free(c);
a1161 4
/*
 * Allocate/update select bitmasks and add any bits relevant to channels in
 * select bitmasks.
 */
d1164 1
a1164 1
    int *nallocp, int rekeying)
d1172 8
a1179 5
	/* perhaps check sz < nalloc/2 and shrink? */
	if (*readsetp == NULL || sz > *nallocp) {
		*readsetp = xrealloc(*readsetp, sz);
		*writesetp = xrealloc(*writesetp, sz);
		*nallocp = sz;
a1180 1
	*maxfdp = n;
a1187 4
/*
 * After select, perform any appropriate operations for channels which have
 * events pending.
 */
a1193 1

d1203 1
a1203 3
		c = channels[i];
		if (c == NULL)
			continue;
d1205 1
a1205 4
		/*
		 * We are only interested in channels that can have buffered
		 * incoming data.
		 */
d1225 1
a1225 4
			/*
			 * Send some data for the other side over the secure
			 * connection.
			 */
d1283 5
a1287 2

/* -- protocol input */
a1333 1

d1374 30
a1416 7

	/* XXX force input close */
	if (c->force_drain) {
		debug("channel %d: FORCE input drain", c->self);
		c->istate = CHAN_INPUT_WAIT_DRAIN;
	}

d1482 1
a1482 1
	channel_free(c);
a1518 16
static char *
reason2txt(int reason)
{
	switch(reason) {
	case SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED:
		return "administratively prohibited";
	case SSH2_OPEN_CONNECT_FAILED:
		return "connect failed";
	case SSH2_OPEN_UNKNOWN_CHANNEL_TYPE:
		return "unknown channel type";
	case SSH2_OPEN_RESOURCE_SHORTAGE:
		return "resource shortage";
	}
	return "unknown reason";
}

d1537 1
a1537 1
		if (!(datafellows & SSH_BUG_OPENFAILURE)) {
d1542 2
a1543 2
		log("channel %d: open failed: %s%s%s", id,
		    reason2txt(reason), msg ? ": ": "", msg ? msg : "");
d1550 1
a1550 1
	channel_free(c);
d1589 126
a1714 1
	c = channel_lookup(id);
d1716 5
a1720 10
	if (c == NULL || c->type != SSH_CHANNEL_OPEN) {
		log("Received window adjust for "
		    "non-open channel %d.", id);
		return;
	}
	adjust = packet_get_int();
	packet_done();
	debug2("channel %d: rcvd adjust %d", id, adjust);
	c->remote_window += adjust;
}
d1722 2
a1723 2
void
channel_input_port_open(int type, int plen, void *ctxt)
d1725 3
a1727 4
	Channel *c = NULL;
	u_short host_port;
	char *host, *originator_string;
	int remote_id, sock = -1;
d1729 32
a1760 20
	remote_id = packet_get_int();
	host = packet_get_string(NULL);
	host_port = packet_get_int();

	if (packet_get_protocol_flags() & SSH_PROTOFLAG_HOST_IN_FWD_OPEN) {
		originator_string = packet_get_string(NULL);
	} else {
		originator_string = xstrdup("unknown (remote did not supply name)");
	}
	packet_done();
	sock = channel_connect_to(host, host_port);
	if (sock != -1) {
		c = channel_new("connected socket",
		    SSH_CHANNEL_CONNECTING, sock, sock, -1, 0, 0, 0,
		    originator_string, 1);
		if (c == NULL) {
			error("channel_input_port_open: channel_new failed");
			close(sock);
		} else {
			c->remote_id = remote_id;
d1763 4
a1766 6
	if (c == NULL) {
		packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(remote_id);
		packet_send();
	}
	xfree(host);
a1768 3

/* -- tcp forwarding */

d1793 1
a1793 2
	Channel *c;
	int success, sock, on = 1, type;
d1803 1
a1803 1
		type = SSH_CHANNEL_RPORT_LISTENER;
d1806 1
a1806 1
		type = SSH_CHANNEL_PORT_LISTENER;
d1809 1
a1809 1
	if (strlen(host) > SSH_CHANNEL_PATH_LEN - 1) {
d1866 1
a1866 1
		c = channel_new("port listener", type, sock, sock, -1,
d1869 3
a1871 8
		if (c == NULL) {
			error("channel_request_forwarding: channel_new failed");
			close(sock);
			continue;
		}
		strlcpy(c->path, host, sizeof(c->path));
		c->host_port = port_to_connect;
		c->listening_port = listen_port;
d2009 1
a2009 1
static int
d2061 1
a2061 1
channel_connect_by_listen_address(u_short listen_port)
d2097 41
a2137 1
/* -- X11 forwarding */
d2144 3
d2236 2
a2237 1
static int
d2369 1
a2369 2
	Channel *c = NULL;
	int remote_id, sock = 0;
d2371 1
d2373 2
a2374 3
	debug("Received X11 open request.");

	remote_id = packet_get_int();
d2376 4
a2379 2
	if (packet_get_protocol_flags() & SSH_PROTOFLAG_HOST_IN_FWD_OPEN) {
		remote_host = packet_get_string(NULL);
d2382 1
d2384 3
a2386 1
	packet_done();
d2390 1
a2390 14
	if (sock != -1) {
		/* Allocate a channel for this connection. */
		c = channel_new("connected x11 socket",
		    SSH_CHANNEL_X11_OPEN, sock, sock, -1, 0, 0, 0,
		    remote_host, 1);
		if (c == NULL) {
			error("x11_input_open: channel_new failed");
			close(sock);
		} else {
			c->remote_id = remote_id;
			c->force_drain = 1;
		}
	}
	if (c == NULL) {
d2393 2
a2394 1
		packet_put_int(remote_id);
d2396 7
d2405 3
a2407 2
		packet_put_int(remote_id);
		packet_put_int(c->self);
a2408 1
	packet_send();
a2435 1
 * This should be called in the client only.
d2437 1
a2501 3

/* -- agent forwarding */

d2521 1
a2521 1
	return auth_sock_name;
d2531 1
a2531 1
	if (auth_sock_name) {
d2533 3
a2535 3
		unlink(auth_sock_name);
		rmdir(auth_sock_dir);
		auth_sock_name = NULL;
d2548 1
a2548 2
	Channel *nc;
	int sock;
d2551 2
a2552 4
	if (auth_get_socket_name() != NULL) {
		error("authentication forwarding requested twice.");
		return 0;
	}
d2558 3
a2560 3
	auth_sock_name = xmalloc(MAXPATHLEN);
	auth_sock_dir = xmalloc(MAXPATHLEN);
	strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXX", MAXPATHLEN);
d2563 3
a2565 3
	if (mkdtemp(auth_sock_dir) == NULL) {
		packet_send_debug("Agent forwarding disabled: "
		    "mkdtemp() failed: %.100s", strerror(errno));
d2567 4
a2570 4
		xfree(auth_sock_name);
		xfree(auth_sock_dir);
		auth_sock_name = NULL;
		auth_sock_dir = NULL;
d2573 2
a2574 2
	snprintf(auth_sock_name, MAXPATHLEN, "%s/agent.%d",
		 auth_sock_dir, (int) getpid());
d2587 1
a2587 1
	strncpy(sunaddr.sun_path, auth_sock_name,
d2601 1
a2601 1
	nc = channel_new("auth socket",
d2605 3
a2607 8
	if (nc == NULL) {
		error("auth_input_request_forwarding: channel_new failed");
		auth_sock_cleanup_proc(pw);
		fatal_remove_cleanup(auth_sock_cleanup_proc, pw);
		close(sock);
		return 0;
	}
	strlcpy(nc->path, auth_sock_name, sizeof(nc->path));
d2616 2
a2617 3
	Channel *c = NULL;
	int remote_id, sock;
	char *name;
d2622 1
a2622 1
	remote_id = packet_get_int();
d2636 96
a2731 12
	if (sock >= 0) {
		name = xstrdup("authentication agent connection");
		c = channel_new("", SSH_CHANNEL_OPEN, sock, sock,
		    -1, 0, 0, 0, name, 1);
		if (c == NULL) {
			error("auth_input_open_request: channel_new failed");
			xfree(name);
			close(sock);
		} else {
			c->remote_id = remote_id;
			c->force_drain = 1;
		}
d2733 6
d2740 2
a2741 8
		packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(remote_id);
	} else {
		/* Send a confirmation to the remote host. */
		debug("Forwarding authentication connection.");
		packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
		packet_put_int(remote_id);
		packet_put_int(c->self);
d2743 17
@


1.72.2.7
log
@Merge OpenSSH 3.0
@
text
@d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.72.2.6 2001/09/27 00:15:41 miod Exp $");
d136 1
a136 1
static int IPv4or6 = AF_UNSPEC;
a243 1
	memset(c, 0, sizeof(Channel));
d333 4
d361 16
d432 1
a432 3
#if 0
			if (!compat20 &&
			    buffer_len(&c->input) > packet_get_maxsize()) {
a436 1
#endif
d438 2
a439 3
				debug("channel %d: big output buffer %d > %d",
				    c->self, buffer_len(&c->output),
				    packet_get_maxsize());
d973 1
a973 1
	c->delayed = 0;
d1132 5
a1136 12
		if (c->type == SSH_CHANNEL_RPORT_LISTENER) {
			nextstate = SSH_CHANNEL_OPENING;
			rtype = "forwarded-tcpip";
		} else {
			if (c->host_port == 0) {
				nextstate = SSH_CHANNEL_DYNAMIC;
				rtype = "dynamic-tcpip";
			} else {
				nextstate = SSH_CHANNEL_OPENING;
				rtype = "direct-tcpip";
			}
		}
d1157 1
a1157 8
		if (nextstate == SSH_CHANNEL_DYNAMIC) {
			/*
			 * do not call the channel_post handler until
			 * this flag has been reset by a pre-handler.
			 * otherwise the FD_ISSET calls might overflow
			 */
			nc->delayed = 1;
		} else {
a1158 1
		}
a1407 2
	if (c->delayed)
		return;
a1414 2
	if (c->delayed)
		return;
a1514 22
/* gc dead channels */
static void
channel_garbage_collect(Channel *c)
{
	if (c == NULL)
		return;
	if (c->detach_user != NULL) {
		if (!chan_is_dead(c, 0))
			return;
		debug("channel %d: gc: notify user", c->self);
		c->detach_user(c->self, NULL);
		/* if we still have a callback */
		if (c->detach_user != NULL)
			return;
		debug("channel %d: gc: user detached", c->self);
	}
	if (!chan_is_dead(c, 1))
		return;
	debug("channel %d: garbage collecting", c->self);
	channel_free(c);
}

d1532 18
a1549 1
		channel_garbage_collect(c);
d1620 1
a1620 1
			debug3("channel %d: will not send data after close", c->self);
a2038 6

void
channel_set_af(int af)
{
	IPv4or6 = af;
}
@


1.72.2.8
log
@Merge OpenSSH 3.1.
@
text
@d16 1
a16 1
 * Copyright (c) 1999, 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d42 1
a42 1
RCSID("$OpenBSD: channels.c,v 1.171 2002/03/04 19:37:58 markus Exp $");
a56 1
#include "pathnames.h"
d148 1
a148 1
	if (id < 0 || id >= channels_alloc) {
d219 1
d248 1
a248 3
	c->ostate = CHAN_OUTPUT_OPEN;
	c->istate = CHAN_INPUT_OPEN;
	c->flags = 0;
d261 3
a264 1
	c->single_connection = 0;
a265 1
	c->confirm = NULL;
d364 1
a364 1
channel_close_all(void)
d405 1
a405 1
channel_not_very_much_buffered_data(void)
d435 1
a435 1
channel_still_open(void)
d478 1
a478 1
channel_find_open(void)
d523 1
a523 1
channel_open_message(void)
d590 1
a590 1
channel_request_start(int local_id, char *service, int wantconfirm)
d592 8
a599 1
	Channel *c = channel_lookup(local_id);
d601 1
a601 1
		log("channel_request_start: %d: unknown channel id", local_id);
a603 1
	debug("channel request %d: %s", local_id, service) ;
d610 1
a610 1
channel_register_confirm(int id, channel_callback_fn *fn)
d614 1
a614 1
		log("channel_register_comfirm: %d: bad id", id);
d617 3
a619 1
	c->confirm = fn;
d654 1
a654 1
    int extusage, int nonblock, u_int window_max)
d661 2
a662 1
	c->local_window = c->local_window_max = window_max;
d704 1
a704 1
channel_pre_open(Channel *c, fd_set * readset, fd_set * writeset)
d706 13
a718 1
	u_int limit = compat20 ? c->remote_window : packet_get_maxsize();
d720 3
d724 2
a725 2
	    limit > 0 &&
	    buffer_len(&c->input) < limit)
d736 1
a736 1
	if (compat20 && c->efd != -1) {
d787 1
a787 1
	ucp = buffer_ptr(b);
d796 1
a796 1
		    ucp[0]);
d868 4
a871 1
		channel_pre_open(c, readset, writeset);
a872 1
		log("X11 connection rejected because of wrong authentication.");
d874 2
a875 9
		chan_read_failed(c);
		buffer_clear(&c->input);
		chan_ibuf_empty(c);
		buffer_clear(&c->output);
		/* for proto v1, the peer will send an IEOF */
		if (compat20)
			chan_write_failed(c);
		else
			c->type = SSH_CHANNEL_OPEN;
d886 1
a886 1
	char username[256];
d933 1
a933 1

a1004 5
		if (c->single_connection) {
			debug("single_connection: closing X11 listener.");
			channel_close_fd(&c->sock);
			chan_mark_dead(c);
		}
a1008 1
		set_nodelay(newsock);
d1018 5
d1027 2
a1028 2
			packet_put_int(nc->local_window_max);
			packet_put_int(nc->local_maxpacket);
a1135 1
		set_nodelay(newsock);
d1140 5
d1187 5
d1213 2
a1214 1
		if (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, &err, &sz) < 0) {
d1272 1
a1272 1
				buffer_clear(&c->output);
d1280 1
a1280 1
		if (c->input_filter != NULL) {
d1314 1
a1314 1
				buffer_clear(&c->output);
d1371 1
a1371 1
			    c->self, len, c->efd);
d1406 1
a1406 1
channel_post_open(Channel *c, fd_set * readset, fd_set * writeset)
d1412 6
a1417 1
	if (!compat20)
d1419 2
d1422 1
d1435 1
a1435 1
			buffer_clear(&c->output);
d1444 1
a1444 1
	channel_pre[SSH_CHANNEL_OPEN] =			&channel_pre_open;
d1453 1
a1453 1
	channel_post[SSH_CHANNEL_OPEN] =		&channel_post_open;
d1459 1
a1459 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open;
d1475 1
a1475 1
	channel_post[SSH_CHANNEL_OPEN] =		&channel_post_open;
d1481 1
a1481 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open;
d1487 1
a1487 1
	channel_pre[SSH_CHANNEL_OPEN] =			&channel_pre_open;
d1498 1
a1498 1
	channel_post[SSH_CHANNEL_OPEN] =		&channel_post_open;
d1500 1
a1500 1
	channel_post[SSH_CHANNEL_DYNAMIC] =		&channel_post_open;
d1507 1
a1507 1
	for (i = 0; i < SSH_CHANNEL_MAX_TYPE; i++) {
d1604 1
a1604 1
channel_output_poll(void)
d1702 1
a1702 1
channel_input_data(int type, u_int32_t seq, void *ctxt)
d1726 1
d1728 1
a1728 1
	if (compat20) {
d1740 2
a1742 1
	packet_check_eom();
d1748 1
a1748 1
channel_input_extended_data(int type, u_int32_t seq, void *ctxt)
d1774 1
a1774 1
	packet_check_eom();
d1788 1
a1788 1
channel_input_ieof(int type, u_int32_t seq, void *ctxt)
d1793 2
a1795 1
	packet_check_eom();
d1802 1
a1802 1
	if (c->force_drain && c->istate == CHAN_INPUT_OPEN) {
a1804 2
		if (buffer_len(&c->input) == 0)
			chan_ibuf_empty(c);
d1810 1
a1810 1
channel_input_close(int type, u_int32_t seq, void *ctxt)
d1815 2
a1817 1
	packet_check_eom();
d1842 1
a1842 1
		buffer_clear(&c->input);
d1849 1
a1849 1
channel_input_oclose(int type, u_int32_t seq, void *ctxt)
d1853 1
a1853 2

	packet_check_eom();
d1860 1
a1860 1
channel_input_close_confirmation(int type, u_int32_t seq, void *ctxt)
d1865 1
a1865 1
	packet_check_eom();
d1876 1
a1876 1
channel_input_open_confirmation(int type, u_int32_t seq, void *ctxt)
d1881 3
d1898 2
a1899 1
		if (c->confirm) {
d1901 1
a1901 1
			c->confirm(c->self, NULL);
a1906 1
	packet_check_eom();
d1912 1
a1912 1
	switch (reason) {
d1926 1
a1926 1
channel_input_open_failure(int type, u_int32_t seq, void *ctxt)
d1932 3
d1947 1
a1954 1
	packet_check_eom();
d1960 26
a1985 1
channel_input_window_adjust(int type, u_int32_t seq, void *ctxt)
d2003 1
a2003 1
	packet_check_eom();
d2009 1
a2009 1
channel_input_port_open(int type, u_int32_t seq, void *ctxt)
d2025 1
a2025 1
	packet_check_eom();
d2031 6
a2036 1
		c->remote_id = remote_id;
d2055 23
a2077 3
static int
channel_setup_fwd_listener(int type, const char *listen_addr, u_short listen_port,
    const char *host_to_connect, u_short port_to_connect, int gateway_ports)
d2080 1
a2080 1
	int success, sock, on = 1;
d2082 1
a2083 1
	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
a2086 2
	host = (type == SSH_CHANNEL_RPORT_LISTENER) ?
	    listen_addr : host_to_connect;
d2088 6
a2093 3
	if (host == NULL) {
		error("No forward host name.");
		return success;
d2095 1
d2101 1
d2119 1
a2119 1
			error("channel_setup_fwd_listener: getnameinfo failed");
d2133 1
a2133 1
		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
d2136 1
a2136 1
		setsockopt(sock, SOL_SOCKET, SO_LINGER, &linger, sizeof(linger));
d2156 5
d2167 1
a2167 1
		error("channel_setup_fwd_listener: cannot listen to port: %d",
a2172 18
/* protocol local port fwd, used by ssh (and sshd in v1) */
int
channel_setup_local_fwd_listener(u_short listen_port,
    const char *host_to_connect, u_short port_to_connect, int gateway_ports)
{
	return channel_setup_fwd_listener(SSH_CHANNEL_PORT_LISTENER,
	    NULL, listen_port, host_to_connect, port_to_connect, gateway_ports);
}

/* protocol v2 remote port fwd, used by sshd */
int
channel_setup_remote_fwd_listener(const char *listen_address,
    u_short listen_port, int gateway_ports)
{
	return channel_setup_fwd_listener(SSH_CHANNEL_RPORT_LISTENER,
	    listen_address, listen_port, NULL, 0, gateway_ports);
}

d2182 1
a2182 1
	int type, success = 0;
d2209 1
a2209 1
		type = packet_read();
d2256 1
a2256 1
	channel_setup_local_fwd_listener(port, hostname, host_port, gateway_ports);
d2268 1
a2268 1
channel_permit_all_opens(void)
a2348 1
	set_nodelay(sock);
d2393 2
a2394 2
 * Returns a suitable display number for the DISPLAY variable, or -1 if
 * an error occurs.
d2396 2
a2397 3
int
x11_create_display_inet(int x11_display_offset, int x11_use_localhost,
    int single_connection)
a2398 1
	Channel *nc = NULL;
d2404 2
d2408 2
a2409 2
	    display_number < MAX_DISPLAYS;
	    display_number++) {
d2413 1
a2413 1
		hints.ai_flags = x11_use_localhost ? 0: AI_PASSIVE;
d2418 1
a2418 1
			return -1;
d2426 1
a2426 1
				return -1;
d2430 1
d2433 1
d2449 1
a2449 1
		return -1;
d2456 1
d2458 1
a2458 1
			return -1;
d2462 6
d2471 1
a2471 1
		nc = channel_new("x11 listener",
a2474 1
		nc->single_connection = single_connection;
d2477 2
a2478 2
	/* Return the display number for the DISPLAY environment variable. */
	return display_number;
d2481 4
d2488 6
d2496 1
d2498 11
a2508 9
	sock = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sock < 0)
		error("socket: %.100s", strerror(errno));
	memset(&addr, 0, sizeof(addr));
	addr.sun_family = AF_UNIX;
	snprintf(addr.sun_path, sizeof addr.sun_path, _PATH_UNIX_X, dnr);
	if (connect(sock, (struct sockaddr *) & addr, sizeof(addr)) == 0)
		return sock;
	close(sock);
d2543 1
a2543 1
			    display);
d2558 2
a2559 1
	strlcpy(buf, display, sizeof(buf));
d2569 1
a2569 1
		    display);
a2604 1
	set_nodelay(sock);
d2615 1
a2615 1
x11_input_open(int type, u_int32_t seq, void *ctxt)
d2630 1
a2630 1
	packet_check_eom();
d2639 7
a2645 2
		c->remote_id = remote_id;
		c->force_drain = 1;
d2662 1
a2662 1
deny_input_open(int type, u_int32_t seq, void *ctxt)
d2665 1
a2665 1
	switch (type) {
d2673 1
a2673 1
		error("deny_input_open: type %d", type);
d2757 1
a2757 1
auth_request_forwarding(void)
d2771 1
a2771 1
auth_get_socket_name(void)
d2842 2
a2843 1
	strlcpy(sunaddr.sun_path, auth_sock_name, sizeof(sunaddr.sun_path));
d2860 7
d2874 1
a2874 1
auth_input_open_request(int type, u_int32_t seq, void *ctxt)
d2880 2
a2883 1
	packet_check_eom();
d2901 8
a2908 2
		c->remote_id = remote_id;
		c->force_drain = 1;
@


1.71
log
@enable non-blocking IO on channels, and tty's (except for the client ttys).
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.70 2000/09/28 18:03:18 markus Exp $");
d1992 22
@


1.70
log
@debug -> debug2 cleanup
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.69 2000/09/21 11:25:33 markus Exp $");
d177 2
a178 1
channel_register_fds(Channel *c, int rfd, int wfd, int efd, int extusage)
d194 10
a203 6
	if (rfd != -1)
		set_nonblock(rfd);
	if (wfd != -1)
		set_nonblock(wfd);
	if (efd != -1)
		set_nonblock(efd);
d213 1
a213 1
    int window, int maxpack, int extusage, char *remote_name)
d253 1
a253 1
	channel_register_fds(c, rfd, wfd, efd, extusage);
d277 1
a277 1
	return channel_new("", type, sock, sock, -1, 0, 0, 0, remote_name);
d556 1
a556 1
		    0, xstrdup(buf));
d614 1
a614 1
		    0, xstrdup(buf));
d1518 1
a1518 1
		    0, xstrdup("port listener"));
d1808 1
a1808 1
		    0, xstrdup("X11 inet listener"));
d2298 2
a2299 1
channel_set_fds(int id, int rfd, int wfd, int efd, int extusage)
d2304 1
a2304 2

	channel_register_fds(c, rfd, wfd, efd, extusage);
@


1.69
log
@add context to dispatch_run
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.68 2000/09/07 20:40:29 markus Exp $");
d237 1
a237 1
		debug("channel: expanding %d", channels_alloc);
d740 1
a740 1
			debug("channel %d: written %d to efd %d",
d749 1
a749 1
			debug("channel %d: read %d from efd %d",
d772 1
a772 1
		debug("channel %d: window %d sent adjust %d",
d1079 1
a1079 1
	debug("channel %d: rcvd ext data %d", c->self, data_len);
d1221 1
a1221 1
			debug("callback start");
d1223 1
a1223 1
			debug("callback done");
d1272 1
a1272 1
		debug("callback start");
d1274 1
a1274 1
		debug("callback done");
d1278 1
a1278 1
debug("cb_fn %p cb_event %d", c->cb_fn , c->cb_event);
d1303 1
a1303 1
	debug("channel %d: rcvd adjust %d", id, adjust);
@


1.68
log
@cleanup window and packet sizes for ssh2 flow control; ok niels
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.67 2000/09/07 20:27:50 deraadt Exp $");
d1001 1
a1001 1
channel_input_data(int type, int plen)
d1046 1
a1046 1
channel_input_extended_data(int type, int plen)
d1116 1
a1116 1
channel_input_ieof(int type, int plen)
d1131 1
a1131 1
channel_input_close(int type, int plen)
d1170 1
a1170 1
channel_input_oclose(int type, int plen)
d1181 1
a1181 1
channel_input_close_confirmation(int type, int plen)
d1197 1
a1197 1
channel_input_open_confirmation(int type, int plen)
d1231 1
a1231 1
channel_input_open_failure(int type, int plen)
d1259 1
a1259 1
channel_input_channel_request(int type, int plen)
d1284 1
a1284 1
channel_input_window_adjust(int type, int plen)
d1655 1
a1655 1
channel_input_port_open(int type, int plen)
d1945 1
a1945 1
x11_input_open(int type, int plen)
d2160 1
a2160 1
auth_input_open_request(int type, int plen)
@


1.67
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.66 2000/08/19 21:55:51 markus Exp $");
a69 6
/* default window/packet sizes for tcp/x11-fwd-channel */
#define CHAN_TCP_WINDOW_DEFAULT	(8*1024)
#define CHAN_TCP_PACKET_DEFAULT	(CHAN_TCP_WINDOW_DEFAULT/2)
#define CHAN_X11_WINDOW_DEFAULT	(4*1024)
#define CHAN_X11_PACKET_DEFAULT	(CHAN_X11_WINDOW_DEFAULT/2)

d2302 1
a2302 1
	c->local_window = c->local_window_max = c->local_maxpacket/2;
@


1.66
log
@more ~ support for ssh2
@
text
@a1 3
 *
 * channels.c
 *
a2 1
 *
a4 3
 *
 * Created: Fri Mar 24 16:35:24 1995 ylo
 *
d9 7
d17 23
d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.65 2000/08/19 18:48:10 markus Exp $");
@


1.65
log
@support for ~. in ssh2
@
text
@d20 1
a20 1
RCSID("$OpenBSD: channels.c,v 1.64 2000/07/16 08:27:21 markus Exp $");
d670 1
a670 1
			if (c->input_filter(&c->input, buf, len) == -1) {
@


1.64
log
@make ssh-add accept dsa keys (the agent does not)
@
text
@d20 1
a20 1
RCSID("$OpenBSD: channels.c,v 1.63 2000/06/25 20:17:57 provos Exp $");
d247 1
d669 8
a676 1
		buffer_append(&c->input, buf, len);
d2263 10
@


1.63
log
@correct check for bad channel ids; from Wei Dai <weidai@@eskimo.com>
@
text
@d20 1
a20 1
RCSID("$OpenBSD: channels.c,v 1.62 2000/06/20 01:39:39 markus Exp $");
a25 1
#include "authfd.h"
d35 5
@


1.62
log
@OpenBSD tag
@
text
@d20 1
a20 1
RCSID("$OpenBSD: channels.c,v 1.61 2000/06/17 16:01:33 deraadt Exp $");
d138 1
a138 1
	if (id < 0 && id > channels_alloc) {
@


1.61
log
@a real nix
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.60 2000/06/17 15:58:46 deraadt Exp $");
@


1.60
log
@everyone says "nix it"
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.59 2000/05/30 17:23:36 markus Exp $");
a934 1
				/* debug("channel %d: send data len %d", c->self, len); */
@


1.59
log
@don't panic if mkdtemp fails for authfwd; jkb@@yahoo-inc.com via kris@@FreeBSD.org
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.58 2000/05/17 08:20:15 markus Exp $");
d935 1
a935 1
				debug("channel %d: send data len %d", c->self, len);
@


1.58
log
@enable nonblocking IO for sshd w/ proto 1, too; split out common code
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.57 2000/05/08 17:42:24 markus Exp $");
d2060 1
a2060 1
 * This if called to process SSH_CMSG_AGENT_REQUEST_FORWARDING on the server.
d2064 1
a2064 1
void
d2082 10
a2091 2
	if (mkdtemp(channel_forwarded_auth_socket_dir) == NULL)
		packet_disconnect("mkdtemp: %.100s", strerror(errno));
d2126 1
@


1.57
log
@bug compat w/ ssh-2.0.13 x11, split out bugs
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.56 2000/05/03 18:03:06 markus Exp $");
a147 17
}

void
set_nonblock(int fd)
{
	int val;
	val = fcntl(fd, F_GETFL, 0);
	if (val < 0) {
		error("fcntl(%d, F_GETFL, 0): %s", fd, strerror(errno));
		return;
	}
	if (val & O_NONBLOCK)
		return;
	debug("fd %d setting O_NONBLOCK", fd);
	val |= O_NONBLOCK;
	if (fcntl(fd, F_SETFL, val) == -1)
		error("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, strerror(errno));
@


1.57.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.59 2000/05/30 17:23:36 markus Exp $");
d150 17
d2077 1
a2077 1
 * This is called to process SSH_CMSG_AGENT_REQUEST_FORWARDING on the server.
d2081 1
a2081 1
int
d2099 2
a2100 10
	if (mkdtemp(channel_forwarded_auth_socket_dir) == NULL) {
		packet_send_debug("Agent forwarding disabled: mkdtemp() failed: %.100s",
		    strerror(errno));
		restore_uid();
		xfree(channel_forwarded_auth_socket_name);
		xfree(channel_forwarded_auth_socket_dir);
		channel_forwarded_auth_socket_name = NULL;
		channel_forwarded_auth_socket_dir = NULL;
		return 0;
	}
a2134 1
	return 1;
@


1.57.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d20 1
a20 1
RCSID("$OpenBSD: channels.c,v 1.66 2000/08/19 21:55:51 markus Exp $");
d26 1
a36 5
#include <openssl/rsa.h>
#include <openssl/dsa.h>
#include "key.h"
#include "authfd.h"

d138 1
a138 1
	if (id < 0 || id > channels_alloc) {
a242 1
	c->input_filter = NULL;
d664 1
a664 8
		if(c->input_filter != NULL) {
			if (c->input_filter(c, buf, len) == -1) {
				debug("filter stops channel %d", c->self);
				chan_read_failed(c);
			}
		} else {
			buffer_append(&c->input, buf, len);
		}
d935 1
a2251 10
}
void   
channel_register_filter(int id, channel_filter_fn *fn)
{
	Channel *c = channel_lookup(id);
	if (c == NULL) {
		log("channel_register_filter: %d: bad id", id);
		return;
	}
	c->input_filter = fn;
@


1.57.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a15 7
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
a16 23
 * Copyright (c) 1999,2000 Markus Friedl.  All rights reserved.
 * Copyright (c) 1999 Dug Song.  All rights reserved.
 * Copyright (c) 1999 Theo de Raadt.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d20 1
a20 1
RCSID("$OpenBSD: channels.c,v 1.72 2000/10/27 07:48:22 markus Exp $");
d47 6
d160 1
a160 2
channel_register_fds(Channel *c, int rfd, int wfd, int efd,
    int extusage, int nonblock)
d176 6
a181 10

	/* enable nonblocking mode */
	if (nonblock) {
		if (rfd != -1)
			set_nonblock(rfd);
		if (wfd != -1)
			set_nonblock(wfd);
		if (efd != -1)
			set_nonblock(efd);
	}
d191 1
a191 1
    int window, int maxpack, int extusage, char *remote_name, int nonblock)
d220 1
a220 1
		debug2("channel: expanding %d", channels_alloc);
d231 1
a231 1
	channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
d255 1
a255 1
	return channel_new("", type, sock, sock, -1, 0, 0, 0, remote_name, 1);
d534 1
a534 1
		    0, xstrdup(buf), 1);
d592 1
a592 1
		    0, xstrdup(buf), 1);
d723 1
a723 1
			debug2("channel %d: written %d to efd %d",
d732 1
a732 1
			debug2("channel %d: read %d from efd %d",
d755 1
a755 1
		debug2("channel %d: window %d sent adjust %d",
d984 1
a984 1
channel_input_data(int type, int plen, void *ctxt)
d1029 1
a1029 1
channel_input_extended_data(int type, int plen, void *ctxt)
d1062 1
a1062 1
	debug2("channel %d: rcvd ext data %d", c->self, data_len);
d1099 1
a1099 1
channel_input_ieof(int type, int plen, void *ctxt)
d1114 1
a1114 1
channel_input_close(int type, int plen, void *ctxt)
d1153 1
a1153 1
channel_input_oclose(int type, int plen, void *ctxt)
d1164 1
a1164 1
channel_input_close_confirmation(int type, int plen, void *ctxt)
d1180 1
a1180 1
channel_input_open_confirmation(int type, int plen, void *ctxt)
d1204 1
a1204 1
			debug2("callback start");
d1206 1
a1206 1
			debug2("callback done");
d1214 1
a1214 1
channel_input_open_failure(int type, int plen, void *ctxt)
d1242 1
a1242 1
channel_input_channel_request(int type, int plen, void *ctxt)
d1255 1
a1255 1
		debug2("callback start");
d1257 1
a1257 1
		debug2("callback done");
d1261 1
a1261 1
		debug("cb_fn %p cb_event %d", c->cb_fn , c->cb_event);
d1267 1
a1267 1
channel_input_window_adjust(int type, int plen, void *ctxt)
d1286 1
a1286 1
	debug2("channel %d: rcvd adjust %d", id, adjust);
d1496 1
a1496 1
		    0, xstrdup("port listener"), 1);
d1638 1
a1638 1
channel_input_port_open(int type, int plen, void *ctxt)
d1786 1
a1786 1
		    0, xstrdup("X11 inet listener"), 1);
d1928 1
a1928 1
x11_input_open(int type, int plen, void *ctxt)
a1971 22
/* dummy protocol handler that denies SSH-1 requests (agent/x11) */
void
deny_input_open(int type, int plen, void *ctxt)
{
	int rchan = packet_get_int();
	switch(type){
	case SSH_SMSG_AGENT_OPEN:
		error("Warning: ssh server tried agent forwarding.");
		break;
	case SSH_SMSG_X11_OPEN:
		error("Warning: ssh server tried X11 forwarding.");
		break;
	default:
		error("deny_input_open: type %d plen %d", type, plen);
		break;
	}
	error("Warning: this is probably a break in attempt by a malicious server.");
	packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
	packet_put_int(rchan);
	packet_send();
}

d2143 1
a2143 1
auth_input_open_request(int type, int plen, void *ctxt)
d2276 1
a2276 2
channel_set_fds(int id, int rfd, int wfd, int efd,
    int extusage, int nonblock)
d2281 2
a2282 1
	channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
d2285 1
a2285 1
	c->local_window = c->local_window_max = c->local_maxpacket * 2;
@


1.57.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d43 1
a43 4
RCSID("$OpenBSD: channels.c,v 1.92 2001/02/16 13:38:18 markus Exp $");

#include <openssl/rsa.h>
#include <openssl/dsa.h>
a45 2
#include "ssh1.h"
#include "ssh2.h"
d50 3
a52 2
#include "log.h"
#include "misc.h"
d56 5
a60 1
#include "canohost.h"
d87 1
a87 1
static int channel_max_fd = 0;
d98 1
a98 1
u_int x11_saved_data_len = 0;
d105 1
a105 1
u_int x11_fake_data_len;
a132 3
/* AF_UNSPEC or AF_INET or AF_INET6 */
extern int IPv4or6;

d181 6
a186 4
	channel_max_fd = MAX(channel_max_fd, rfd);
	channel_max_fd = MAX(channel_max_fd, wfd);
	channel_max_fd = MAX(channel_max_fd, efd);

a194 12
	/* XXX ugly hack: nonblock is only set by the server */
	if (nonblock && isatty(c->rfd)) {
		debug("channel: %d: rfd %d isatty", c->self, c->rfd);
		c->isatty = 1;
		if (!isatty(c->wfd)) {
			error("channel: %d: wfd %d is not a tty?",
			    c->self, c->wfd);
		}
	} else {
		c->isatty = 0;
	}

a309 2
	char *s = channel_open_message();

d312 1
a312 3
	debug("channel_free: channel %d: status: %s", id, s);
	xfree(s);

a348 7
channel_pre_connecting(Channel *c, fd_set * readset, fd_set * writeset)
{
	debug3("channel %d: waiting for connection", c->self);
	FD_SET(c->sock, writeset);
}

void
d432 2
a433 2
	u_char *ucp;
	u_int proto_len, data_len;
d440 1
a440 1
	ucp = (u_char *) buffer_ptr(&c->output);
d537 1
a537 1
	char buf[16384], *remote_ipaddr;
d548 1
a548 1
		remote_ipaddr = get_peer_ipaddr(newsock);
d551 1
a551 1
		    remote_ipaddr, remote_port);
d563 2
a564 2
			/* originator ipaddr and port */
			packet_put_cstring(remote_ipaddr);
d578 1
a578 1
		xfree(remote_ipaddr);
d591 1
a591 1
	char buf[1024], *remote_ipaddr, *rtype;
a593 3
	rtype = (c->type == SSH_CHANNEL_RPORT_LISTENER) ?
	    "forwarded-tcpip" : "direct-tcpip";

d604 1
a604 1
		remote_ipaddr = get_peer_ipaddr(newsock);
d610 2
a611 3
		    remote_ipaddr, remote_port);

		newch = channel_new(rtype,
d617 1
a617 1
			packet_put_cstring(rtype);
d621 3
a623 9
			if (c->type == SSH_CHANNEL_RPORT_LISTENER) {
				/* listen address, port */
				packet_put_string(c->path, strlen(c->path));
				packet_put_int(c->listening_port);
			} else {
				/* target host, port */
				packet_put_string(c->path, strlen(c->path));
				packet_put_int(c->host_port);
			}
d625 1
a625 1
			packet_put_cstring(remote_ipaddr);
d638 1
a638 1
		xfree(remote_ipaddr);
d660 4
a663 14
		newch = channel_new("accepted auth socket",
		    SSH_CHANNEL_OPENING, newsock, newsock, -1,
		    c->local_window_max, c->local_maxpacket,
		    0, xstrdup("accepted auth socket"), 1);
		if (compat20) {
			packet_start(SSH2_MSG_CHANNEL_OPEN);
			packet_put_cstring("auth-agent@@openssh.com");
			packet_put_int(newch);
			packet_put_int(c->local_window_max);
			packet_put_int(c->local_maxpacket);
		} else {
			packet_start(SSH_SMSG_AGENT_OPEN);
			packet_put_int(newch);
		}
a667 22
void
channel_post_connecting(Channel *c, fd_set * readset, fd_set * writeset)
{
	if (FD_ISSET(c->sock, writeset)) {
		int err = 0;
		int sz = sizeof(err);
		c->type = SSH_CHANNEL_OPEN;
		if (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, (char *)&err, &sz) < 0) {
			debug("getsockopt SO_ERROR failed");
		} else {
			if (err == 0) {
				debug("channel %d: connected)", c->self);
			} else {
				debug("channel %d: not connected: %s",
				    c->self, strerror(err));
				chan_read_failed(c);
				chan_write_failed(c);
			}
		}
	}
}

a724 14
		if (compat20 && c->isatty) {
			struct termios tio;
			if (tcgetattr(c->wfd, &tio) == 0 &&
			    !(tio.c_lflag & ECHO) && (tio.c_lflag & ICANON)) {
				/*
				 * Simulate echo to reduce the impact of
				 * traffic analysis.
				 */
				packet_start(SSH2_MSG_IGNORE);
				memset(buffer_ptr(&c->output), 0, len);
				packet_put_string(buffer_ptr(&c->output), len);
				packet_send();
			}
		}
a822 1
	channel_pre[SSH_CHANNEL_RPORT_LISTENER] =	&channel_pre_listener;
a823 2
	channel_pre[SSH_CHANNEL_AUTH_SOCKET] =		&channel_pre_listener;
	channel_pre[SSH_CHANNEL_CONNECTING] =		&channel_pre_connecting;
a826 1
	channel_post[SSH_CHANNEL_RPORT_LISTENER] =	&channel_post_port_listener;
a827 2
	channel_post[SSH_CHANNEL_AUTH_SOCKET] =		&channel_post_auth_listener;
	channel_post[SSH_CHANNEL_CONNECTING] =		&channel_post_connecting;
a839 1
	channel_pre[SSH_CHANNEL_CONNECTING] =		&channel_pre_connecting;
a845 1
	channel_post[SSH_CHANNEL_CONNECTING] =		&channel_post_connecting;
a855 1
	channel_pre[SSH_CHANNEL_CONNECTING] =		&channel_pre_connecting;
a860 1
	channel_post[SSH_CHANNEL_CONNECTING] =		&channel_post_connecting;
d902 1
a902 1
channel_prepare_select(fd_set **readsetp, fd_set **writesetp, int *maxfdp)
d904 1
a904 19
	int n;
	u_int sz;

	n = MAX(*maxfdp, channel_max_fd);

	sz = howmany(n+1, NFDBITS) * sizeof(fd_mask);
	if (*readsetp == NULL || n > *maxfdp) {
		if (*readsetp)
			xfree(*readsetp);
		if (*writesetp)
			xfree(*writesetp);
		*readsetp = xmalloc(sz);
		*writesetp = xmalloc(sz);
		*maxfdp = n;
	}
	memset(*readsetp, 0, sz);
	memset(*writesetp, 0, sz);

	channel_handler(channel_pre, *readsetp, *writesetp);
d913 1
a913 1
/* If there is data to send to the connection, enqueue some of it now. */
d1010 1
a1010 1
	u_int data_len;
d1056 1
a1056 1
	u_int data_len;
d1099 1
a1099 1
	u_int i;
d1238 1
a1238 2
	int id, reason;
	char *msg = NULL, *lang = NULL;
d1251 4
a1254 5
		reason = packet_get_int();
		if (packet_remaining() > 0) {
			msg  = packet_get_string(NULL);
			lang = packet_get_string(NULL);
		}
d1256 2
a1257 6
		log("channel_open_failure: %d: reason %d %s", id,
		    reason, msg ? msg : "<no additional info>");
		if (msg != NULL)
			xfree(msg);
		if (lang != NULL)
			xfree(lang);
d1325 1
a1325 1
			unlink(channels[i].path);
a1328 1
		case SSH_CHANNEL_RPORT_LISTENER:
d1353 8
d1366 1
a1366 1
	u_int i;
a1371 1
		case SSH_CHANNEL_RPORT_LISTENER:
a1373 1
		case SSH_CHANNEL_CONNECTING: 	/* XXX ??? */
a1416 1
		case SSH_CHANNEL_RPORT_LISTENER:
a1421 1
		case SSH_CHANNEL_CONNECTING:
a1448 9
int
channel_request_local_forwarding(u_short listen_port, const char *host_to_connect,
    u_short port_to_connect, int gateway_ports)
{
	return channel_request_forwarding(
	    NULL, listen_port,
	    host_to_connect, port_to_connect,
	    gateway_ports, /*remote_fwd*/ 0);
}
d1450 3
a1452 9
/*
 * If 'remote_fwd' is true we have a '-R style' listener for protocol 2
 * (SSH_CHANNEL_RPORT_LISTENER).
 */
int
channel_request_forwarding(
    const char *listen_address, u_short listen_port,
    const char *host_to_connect, u_short port_to_connect,
    int gateway_ports, int remote_fwd)
d1454 1
a1454 1
	int success, ch, sock, on = 1, ctype;
a1456 1
	const char *host;
d1459 2
a1460 9
	success = 0;

	if (remote_fwd) {
		host = listen_address;
		ctype = SSH_CHANNEL_RPORT_LISTENER;
	} else {
		host = host_to_connect;
		ctype  =SSH_CHANNEL_PORT_LISTENER;
	}
a1461 6
	if (strlen(host) > sizeof(channels[0].path) - 1) {
		error("Forward host name too long.");
		return success;
	}

	/* XXX listen_address is currently ignored */
d1470 1
a1470 1
	snprintf(strport, sizeof strport, "%d", listen_port);
d1474 1
d1480 1
a1480 1
			error("channel_request_forwarding: getnameinfo failed");
d1514 3
a1516 1
		ch = channel_new("port listener", ctype, sock, sock, -1,
d1520 2
a1521 2
		channels[ch].host_port = port_to_connect;
		channels[ch].listening_port = listen_port;
d1525 1
a1525 2
		error("channel_request_forwarding: cannot listen to port: %d",
		    listen_port);
a1526 1
	return success;
d1535 2
a1536 2
channel_request_remote_forwarding(u_short listen_port,
    const char *host_to_connect, u_short port_to_connect)
d1538 1
a1538 2
	int payload_len, type, success = 0;

d1543 5
a1555 4
		packet_send();
		packet_write_wait();
		/* Assume that server accepts the request */
		success = 1;
d1563 5
a1567 21

		/* Wait for response from the remote side. */
		type = packet_read(&payload_len);
		switch (type) {
		case SSH_SMSG_SUCCESS:
			success = 1;
			break;
		case SSH_SMSG_FAILURE:
			log("Warning: Server denied remote port forwarding.");
			break;
		default:
			/* Unknown packet */
			packet_disconnect("Protocol error for port forward request:"
			    "received packet type %d.", type);
		}
	}
	if (success) {
		permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
		permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
		permitted_opens[num_permitted_opens].listen_port = listen_port;
		num_permitted_opens++;
d1595 3
a1597 1
	/* Initiate forwarding */
a1634 2
		if (fcntl(sock, F_SETFL, O_NONBLOCK) < 0)
			fatal("connect_to: F_SETFL: %s", strerror(errno));
d1636 1
a1636 2
		if (connect(sock, ai->ai_addr, ai->ai_addrlen) < 0 &&
		    errno != EINPROGRESS) {
d1640 1
a1640 1
			continue;	/* fail -- try next */
d1647 1
a1647 1
		error("connect %.100s port %d: failed.", host, host_port);
a1652 14
int
channel_connect_by_listen_adress(u_short listen_port)
{
	int i;
	for (i = 0; i < num_permitted_opens; i++)
		if (permitted_opens[i].listen_port == listen_port)
			return channel_connect_to(
			    permitted_opens[i].host_to_connect,
			    permitted_opens[i].port_to_connect);
	error("WARNING: Server requests forwarding for unknown listen_port %d",
	    listen_port);
	return -1;
}

d1665 1
a1665 1
	u_int host_len, originator_len;
d1708 1
a1708 3
		newch = channel_allocate(SSH_CHANNEL_CONNECTING,
		    sock, originator_string);
/*XXX delay answer? */
a1777 1
		freeaddrinfo(aitop);
d1821 1
a1821 1
connect_local_xsocket(u_int dnr)
d1954 1
a1954 1
	u_int remote_len;
d2025 2
a2026 2
	u_int data_len = (u_int) strlen(data) / 2;
	u_int i, value, len;
d2064 1
a2064 2
	len = 2 * data_len + 1;
	new_data = xmalloc(len);
d2066 1
a2066 2
		snprintf(new_data + 2 * i, len - 2 * i,
		    "%02x", (u_char) x11_fake_data[i]);
d2110 1
a2110 1
	unlink(channel_forwarded_auth_socket_name);
d2177 2
a2178 5
	newch = channel_new("auth socket",
	    SSH_CHANNEL_AUTH_SOCKET, sock, sock, -1,
	    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,
	    0, xstrdup("auth socket"), 1);

d2308 1
a2308 1
void
@


1.57.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: channels.c,v 1.99 2001/03/16 19:06:29 markus Exp $");
d144 12
d198 1
a198 1
		debug("channel %d: rfd %d isatty", c->self, c->rfd);
d201 1
a201 1
			error("channel %d: wfd %d is not a tty?",
d524 1
a524 1
		log("X11 connection rejected because of wrong authentication.");
a770 1
	struct termios tio;
d792 1
d797 1
a797 3
				 * traffic analysis. We need to match the
				 * size of a SSH2_MSG_CHANNEL_DATA message
				 * (4 byte channel id + data)
d799 3
a801 1
				packet_send_ignore(4 + len);
d827 1
a827 8
			if (len < 0 && (errno == EINTR || errno == EAGAIN))
				return 1;
			if (len <= 0) {
				debug2("channel %d: closing write-efd %d",
				    c->self, c->efd);
				close(c->efd);
				c->efd = -1;
			} else {
d836 2
a837 4
			if (len < 0 && (errno == EINTR || errno == EAGAIN))
				return 1;
			if (len <= 0) {
				debug2("channel %d: closing read-efd %d",
d841 1
a841 1
			} else {
a842 1
			}
d848 1
a848 1
channel_check_window(Channel *c)
d879 1
a879 2

	channel_check_window(c);
d987 1
a987 18
		if (chan_is_dead(c)) {
			/*
			 * we have to remove the fd's from the select mask
			 * before the channels are free'd and the fd's are
			 * closed
			 */
			if (c->wfd != -1)
				FD_CLR(c->wfd, writeset);
			if (c->rfd != -1)
				FD_CLR(c->rfd, readset);
			if (c->efd != -1) {
				if (c->extended_usage == CHAN_EXTENDED_READ)
					FD_CLR(c->efd, readset);
				if (c->extended_usage == CHAN_EXTENDED_WRITE)
					FD_CLR(c->efd, writeset);
			}
			channel_free(c->self);
		}
d1040 3
d1046 1
a1046 2
			/* XXX is this true? */
			debug2("channel %d: no data after CLOSE", c->self);
d1051 2
a1052 3
		if ((c->istate == CHAN_INPUT_OPEN ||
		    c->istate == CHAN_INPUT_WAIT_DRAIN) &&
		    (len = buffer_len(&c->input)) > 0) {
a1091 3
			debug2("channel %d: rwin %d elen %d euse %d",
			    c->self, c->remote_window, buffer_len(&c->extended),
			    c->extended_usage);
a1102 1
			debug2("channel %d: sent ext data %d", c->self, len);
d1396 1
a1396 1
		debug("channel %d: rcvd request for %s", c->self, service);
d1757 1
a1757 39
/*
 * Permits opening to any host/port if permitted_opens[] is empty.  This is
 * usually called by the server, because the user could connect to any port
 * anyway, and the server has no way to know but to trust the client anyway.
 */
void
channel_permit_all_opens()
{
	if (num_permitted_opens == 0)
		all_opens_permitted = 1;
}

void 
channel_add_permitted_opens(char *host, int port)
{
	if (num_permitted_opens >= SSH_MAX_FORWARDS_PER_DIRECTION)
		fatal("channel_request_remote_forwarding: too many forwards");
	debug("allow port forwarding to host %s port %d", host, port);

	permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host);
	permitted_opens[num_permitted_opens].port_to_connect = port;
	num_permitted_opens++;

	all_opens_permitted = 0;
}

void 
channel_clear_permitted_opens(void)
{
	int i;

	for (i = 0; i < num_permitted_opens; i++)
		xfree(permitted_opens[i].host_to_connect);
	num_permitted_opens = 0;

}


/* return socket to remote host, port */
d1759 1
a1759 1
connect_to(const char *host, u_short port)
d1769 1
a1769 1
	snprintf(strport, sizeof strport, "%d", port);
d1771 1
a1771 2
		error("connect_to %.100s: unknown host (%s)", host,
		    gai_strerror(gaierr));
d1779 1
a1779 1
			error("connect_to: getnameinfo failed");
d1782 1
d1790 1
d1793 1
a1793 1
			error("connect_to %.100s port %s: %.100s", ntop, strport,
d1803 1
a1803 1
		error("connect_to %.100s port %d: failed.", host, port);
a1808 1

a1812 1

d1815 1
a1815 1
			return connect_to(
a1822 22
/* Check if connecting to that port is permitted and connect. */
int
channel_connect_to(const char *host, u_short port)
{
	int i, permit;

	permit = all_opens_permitted;
	if (!permit) {
		for (i = 0; i < num_permitted_opens; i++)
			if (permitted_opens[i].port_to_connect == port &&
			    strcmp(permitted_opens[i].host_to_connect, host) == 0)
				permit = 1;

	}
	if (!permit) {
		log("Received request to connect to host %.100s port %d, "
		    "but the request was denied.", host, port);
		return -1;
	}
	return connect_to(host, port);
}

d1834 2
a1835 1
	int remote_channel, sock = -1, newch;
d1837 1
d1839 5
a1843 1
	host = packet_get_string(NULL);
d1846 1
d1848 2
a1849 1
		originator_string = packet_get_string(NULL);
d1852 1
d1854 24
a1877 3
	packet_done();
	sock = channel_connect_to(host, host_port);
	if (sock != -1) {
d1880 1
a1882 1
		/*XXX delay answer? */
@


1.56
log
@GatewayPorts for sshd, ok deraadt@@
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.55 2000/05/02 19:33:12 markus Exp $");
d508 4
a511 1
		channel_pre_open_15(c, readset, writeset);
d555 5
a559 1
			packet_put_int(remote_port);
@


1.55
log
@set O_NONBLOCK
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.54 2000/05/01 20:21:40 markus Exp $");
d1555 1
a1555 1
channel_input_port_forward_request(int is_root)
a1573 1
	 * bind port to localhost only (gateway ports == 0).
d1575 1
a1575 1
	channel_request_local_forwarding(port, hostname, host_port, 0);
@


1.54
log
@unbreak, ok niels@@
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.53 2000/05/01 19:11:35 markus Exp $");
d150 17
d168 1
a168 1
 * register filedescriptors for a channel, used when allocating a channel or
d183 1
d189 6
@


1.53
log
@EINTR
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.52 2000/05/01 18:31:27 markus Exp $");
a252 1
		shutdown(c->sock, SHUT_RDWR);
d283 2
@


1.52
log
@init all fds, close all fds.
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.51 2000/04/28 08:10:20 markus Exp $");
d635 2
d663 3
a665 1
			    buffer_len(&c->output));
@


1.51
log
@support for x11-fwding, client+server
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.50 2000/04/16 16:40:43 markus Exp $");
d151 2
a152 2
 * Allocate a new channel object and set its type and socket. This will cause
 * remote_name to be freed.
d155 2
a156 3
int
channel_new(char *ctype, int type, int rfd, int wfd, int efd,
    int window, int maxpack, int extended_usage, char *remote_name)
a157 3
	int i, found;
	Channel *c;

d166 18
d220 1
a223 5
	c->rfd = rfd;
	c->wfd = wfd;
	c->sock = (rfd == wfd) ? rfd : -1;
	c->efd = efd;
	c->extended_usage = extended_usage;
d239 1
d246 26
a271 1
/* Free the channel and close its socket. */
d284 1
a284 19
	if (c->sock != -1) {
		shutdown(c->sock, SHUT_RDWR);
		close(c->sock);
		c->sock = -1;
	}
	if (compat20) {
		if (c->rfd != -1) {
			close(c->rfd);
			c->rfd = -1;
		}
		if (c->wfd != -1) {
			close(c->wfd);
			c->wfd = -1;
		}
		if (c->efd != -1) {
			close(c->efd);
			c->efd = -1;
		}
	}
d1288 1
a1288 1
 * Closes the sockets of all channels.  This is used to close extra file
d1296 1
a1296 1
	for (i = 0; i < channels_alloc; i++) {
d1298 1
a1298 2
			close(channels[i].sock);
	}
d2233 2
a2234 6
	if (rfd > channel_max_fd_value)
		channel_max_fd_value = rfd;
	if (wfd > channel_max_fd_value)
		channel_max_fd_value = wfd;
	if (efd > channel_max_fd_value)
		channel_max_fd_value = efd;
a2235 4
	c->rfd = rfd;
	c->wfd = wfd;
	c->efd = efd;
	c->extended_usage = extusage;
@


1.50
log
@fix pr 1196, listen_port and port_to_connect interchanged
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.49 2000/04/14 10:30:30 markus Exp $");
d43 5
a47 3
/* default buffer for tcp-fwd-channel */
#define CHAN_WINDOW_DEFAULT      (8*1024)
#define CHAN_PACKET_DEFAULT	 (CHAN_WINDOW_DEFAULT/2)
a208 6
	c->local_window = window;
	c->local_window_max = window;
	c->local_consumed = 0;
	c->local_maxpacket = maxpack;
	c->remote_window = 0;
	c->remote_maxpacket = 0;
d214 4
d374 1
d460 1
a460 1
channel_pre_x11_open_15(Channel *c, fd_set * readset, fd_set * writeset)
d468 1
a468 1
		chan_read_failed(c);
d482 1
d493 1
d495 23
a517 1
		remote_hostname, get_peer_port(newsock));
a518 7
		newch = channel_allocate(SSH_CHANNEL_OPENING, newsock,
					 xstrdup(buf));
		packet_start(SSH_SMSG_X11_OPEN);
		packet_put_int(newch);
		if (have_hostname_in_open)
			packet_put_string(buf, strlen(buf));
		packet_send();
d618 1
a618 1
			debug("channel %d: read<0 rfd %d len %d",
d750 1
d752 1
d756 1
d781 1
a781 1
	channel_pre[SSH_CHANNEL_X11_OPEN] =		&channel_pre_x11_open_15;
d1448 1
a1448 1
		    CHAN_WINDOW_DEFAULT, CHAN_PACKET_DEFAULT,
d1737 4
a1740 2
		(void) channel_allocate(SSH_CHANNEL_X11_LISTENER, sock,
					xstrdup("X11 inet listener"));
d1780 2
a1781 9

/*
 * This is called when SSH_SMSG_X11_OPEN is received.  The packet contains
 * the remote channel number.  We should do whatever we want, and respond
 * with either SSH_MSG_OPEN_CONFIRMATION or SSH_MSG_OPEN_FAILURE.
 */

void
x11_input_open(int type, int plen)
d1783 1
a1783 1
	int remote_channel, display_number, sock = 0, newch;
d1785 1
a1785 2
	char buf[1024], *cp, *remote_host;
	unsigned int remote_len;
a1789 15
	/* Get remote channel number. */
	remote_channel = packet_get_int();

	/* Get remote originator name. */
	if (have_hostname_in_open) {
		remote_host = packet_get_string(&remote_len);
		remote_len += 4;
	} else {
		remote_host = xstrdup("unknown (remote did not supply name)");
		remote_len = 0;
	}

	debug("Received X11 open request.");
	packet_integrity_check(plen, 4 + remote_len, SSH_SMSG_X11_OPEN);

d1794 1
a1794 1
		goto fail;
d1811 1
a1811 1
			goto fail;
d1816 1
a1816 1
			goto fail;
d1819 1
a1819 1
		goto success;
d1830 1
a1830 1
		goto fail;
d1837 1
a1837 1
		goto fail;
d1847 1
a1847 1
		goto fail;
d1870 1
a1870 1
		goto fail;
d1872 15
a1886 2
success:
	/* We have successfully obtained a connection to the real X display. */
d1888 11
a1898 6
	/* Allocate a channel for this connection. */
	if (x11_saved_proto == NULL)
		newch = channel_allocate(SSH_CHANNEL_OPEN, sock, remote_host);
	else
		newch = channel_allocate(SSH_CHANNEL_X11_OPEN, sock, remote_host);
	channels[newch].remote_id = remote_channel;
d1900 2
a1901 5
	/* Send a confirmation to the remote host. */
	packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
	packet_put_int(remote_channel);
	packet_put_int(newch);
	packet_send();
d1903 14
a1916 1
	return;
d1918 6
a1923 5
fail:
	/* Send refusal to the remote host. */
	packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
	packet_put_int(remote_channel);
	packet_send();
d1932 2
a1933 1
x11_request_forwarding_with_spoofing(const char *proto, const char *data)
d1979 8
a1986 3
	packet_start(SSH_CMSG_X11_REQUEST_FORWARDING);
	packet_put_string(proto, strlen(proto));
	packet_put_string(new_data, strlen(new_data));
d2136 1
a2136 1
channel_open(int id)
d2143 1
d2149 6
a2155 1
	debug("channel open %d", id);
@


1.49
log
@whitespace cleanup
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.48 2000/04/14 10:09:14 markus Exp $");
d1468 2
a1470 2
		packet_put_cstring(host_to_connect);
		packet_put_int(listen_port);
@


1.48
log
@check payload for (illegal) extra data
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d15 1
a15 1
 * 
d20 1
a20 1
RCSID("$Id: channels.c,v 1.47 2000/04/10 15:19:43 markus Exp $");
d112 1
a112 1
void 
d124 1
a124 1
void 
d153 1
a153 1
int 
d229 1
a229 1
int 
d237 1
a237 1
void 
d364 1
a364 1
	else 
d787 1
a787 1
void 
d809 1
a809 1
void 
d815 1
a815 1
void 
d823 1
a823 1
void 
d914 1
a914 1
void 
d959 1
a959 1
void 
d1005 1
a1005 1
int 
d1029 1
a1029 1
void 
d1044 1
a1044 1
void 
d1083 1
a1083 1
void 
d1094 1
a1094 1
void 
d1110 1
a1110 1
void 
d1144 1
a1144 1
void 
d1197 1
a1197 1
void 
d1226 1
a1226 1
void 
d1253 1
a1253 1
void 
d1265 1
a1265 1
int 
d1273 1
a1273 1
int 
d1360 1
a1360 1
void 
d1444 1
a1444 1
void 
d1487 1
a1487 1
void 
d1570 1
a1570 1
void 
d1764 1
a1764 1
void 
d1868 1
a1868 1
		error("connect %.100s port %d: %.100s", buf, 6000 + display_number, 
d1902 1
a1902 1
void 
d1960 1
a1960 1
void 
d1982 1
a1982 1
void 
d1994 1
a1994 1
void 
d2052 1
a2052 1
void 
@


1.47
log
@repair x11-fwd
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.46 2000/04/06 09:43:15 markus Exp $");
d543 1
d546 1
d939 1
d986 1
d1100 1
d1133 1
d1162 1
d1164 1
d1166 1
d1216 1
@


1.46
log
@no adjust after close
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.45 2000/04/04 06:18:01 markus Exp $");
d440 1
d464 1
@


1.45
log
@close efd on eof
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.44 2000/04/03 07:07:15 markus Exp $");
d677 1
a677 1
	if (!(c->flags & CHAN_CLOSE_SENT) &&
d840 2
a841 1
		if (compat20 && (c->flags & CHAN_CLOSE_SENT)) {
@


1.44
log
@channel layer support for ssh2
@
text
@d20 1
a20 1
RCSID("$Id: channels.c,v 1.43 2000/03/28 20:39:05 markus Exp $");
d645 1
d663 6
a668 1
			if (len > 0)
@


1.43
log
@typo
@
text
@d16 1
d20 1
a20 1
RCSID("$Id: channels.c,v 1.42 2000/03/28 20:33:50 markus Exp $");
d35 2
d171 1
d244 4
d251 15
d322 26
d535 20
a554 7

		packet_start(SSH_MSG_PORT_OPEN);
		packet_put_int(newch);
		packet_put_string(c->path, strlen(c->path));
		packet_put_int(c->host_port);
		if (have_hostname_in_open) {
			packet_put_string(buf, strlen(buf));
a555 1
		packet_send();
d633 50
d695 9
d719 10
d769 3
a771 1
	if (compat13)
d795 1
a795 2
		if (!compat13)
			chan_delete_if_full_closed(c);
d834 4
d843 5
a847 3
			if (packet_is_interactive()) {
				if (len > 1024)
					len = 512;
d849 8
a856 3
				/* Keep the packets at reasonable size. */
				if (len > packet_get_maxsize())
					len = packet_get_maxsize()/2;
d859 2
a860 1
				packet_start(SSH_MSG_CHANNEL_DATA);
d866 1
a866 1
debug("channel %d: send data len %d", c->self, len);
d877 17
d929 15
a943 1
	packet_integrity_check(plen, 4 + 4 + data_len, SSH_MSG_CHANNEL_DATA);
d947 39
d1001 1
a1001 1
			if (buffer_len(&c->input) > packet_get_maxsize()) {
d1102 2
a1103 1
	packet_integrity_check(plen, 4 + 4, type);
d1115 12
d1135 2
a1136 1
	packet_integrity_check(plen, 4, type);
d1144 6
a1149 1

d1154 48
d1266 4
d1311 1
d1440 20
a1459 11
	packet_start(SSH_CMSG_PORT_FORWARD_REQUEST);
	packet_put_int(port_to_connect);
	packet_put_string(host_to_connect, strlen(host_to_connect));
	packet_put_int(listen_port);
	packet_send();
	packet_write_wait();
	/*
	 * Wait for response from the remote side.  It will send a disconnect
	 * message on failure, and we will never see it here.
	 */
	packet_read_expect(&payload_len, SSH_SMSG_SUCCESS);
d2078 94
@


1.42
log
@missing close
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.41 2000/03/28 20:31:25 markus Exp $");
d240 1
a240 1
	if (c->sock =! -1) {
@


1.41
log
@replace big switch() with function tables (prepare for ssh2)
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.40 2000/03/27 17:41:50 markus Exp $");
d240 1
a240 1
	if (compat13)
d242 2
d663 2
a664 1
		chan_delete_if_full_closed(c);
@


1.40
log
@allow bigger packets
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.39 2000/03/16 20:56:14 markus Exp $");
d40 4
d88 3
a90 2
	char *host;		/* Host name. */
	u_short port;		/* Port number. */
d127 18
d151 2
a152 1
channel_allocate(int type, int sock, char *remote_name)
d158 6
a163 2
	if (sock > channel_max_fd_value)
		channel_max_fd_value = sock;
d198 1
d202 12
a213 1
	c->sock = sock;
d216 6
d225 5
d234 1
a234 1
channel_free(int channel)
d236 4
a239 4
	if (channel < 0 || channel >= channels_alloc ||
	    channels[channel].type == SSH_CHANNEL_FREE)
		packet_disconnect("channel free: bad local channel %d", channel);

d241 8
a248 8
		shutdown(channels[channel].sock, SHUT_RDWR);
	close(channels[channel].sock);
	buffer_free(&channels[channel].input);
	buffer_free(&channels[channel].output);
	channels[channel].type = SSH_CHANNEL_FREE;
	if (channels[channel].remote_name) {
		xfree(channels[channel].remote_name);
		channels[channel].remote_name = NULL;
d253 6
a258 2
 * This is called just before select() to add any bits relevant to channels
 * in the select bitmasks.
d260 18
d279 47
a325 2
void 
channel_prepare_select(fd_set * readset, fd_set * writeset)
a326 2
	int i;
	Channel *ch;
d330 75
a404 9
	for (i = 0; i < channels_alloc; i++) {
		ch = &channels[i];
redo:
		switch (ch->type) {
		case SSH_CHANNEL_X11_LISTENER:
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_AUTH_SOCKET:
			FD_SET(ch->sock, readset);
			break;
d406 13
a418 21
		case SSH_CHANNEL_OPEN:
			if (compat13) {
				if (buffer_len(&ch->input) < packet_get_maxsize())
					FD_SET(ch->sock, readset);
				if (buffer_len(&ch->output) > 0)
					FD_SET(ch->sock, writeset);
				break;
			}
			/* test whether sockets are 'alive' for read/write */
			if (ch->istate == CHAN_INPUT_OPEN)
				if (buffer_len(&ch->input) < packet_get_maxsize())
					FD_SET(ch->sock, readset);
			if (ch->ostate == CHAN_OUTPUT_OPEN ||
			    ch->ostate == CHAN_OUTPUT_WAIT_DRAIN) {
				if (buffer_len(&ch->output) > 0) {
					FD_SET(ch->sock, writeset);
				} else if (ch->ostate == CHAN_OUTPUT_WAIT_DRAIN) {
					chan_obuf_empty(ch);
				}
			}
			break;
d420 8
a427 12
		case SSH_CHANNEL_INPUT_DRAINING:
			if (!compat13)
				fatal("cannot happen: IN_DRAIN");
			if (buffer_len(&ch->input) == 0) {
				packet_start(SSH_MSG_CHANNEL_CLOSE);
				packet_put_int(ch->remote_id);
				packet_send();
				ch->type = SSH_CHANNEL_CLOSED;
				debug("Closing channel %d after input drain.", ch->self);
				break;
			}
			break;
d429 21
a449 9
		case SSH_CHANNEL_OUTPUT_DRAINING:
			if (!compat13)
				fatal("cannot happen: OUT_DRAIN");
			if (buffer_len(&ch->output) == 0) {
				channel_free(i);
				break;
			}
			FD_SET(ch->sock, writeset);
			break;
d451 11
a461 14
		case SSH_CHANNEL_X11_OPEN:
			/*
			 * This is a special state for X11 authentication
			 * spoofing.  An opened X11 connection (when
			 * authentication spoofing is being done) remains in
			 * this state until the first packet has been
			 * completely read.  The authentication data in that
			 * packet is then substituted by the real data if it
			 * matches the fake data, and the channel is put into
			 * normal mode.
			 */
			/* Check if the fixed size part of the packet is in buffer. */
			if (buffer_len(&ch->output) < 12)
				break;
d463 33
a495 14
			/* Parse the lengths of variable-length fields. */
			ucp = (unsigned char *) buffer_ptr(&ch->output);
			if (ucp[0] == 0x42) {	/* Byte order MSB first. */
				proto_len = 256 * ucp[6] + ucp[7];
				data_len = 256 * ucp[8] + ucp[9];
			} else if (ucp[0] == 0x6c) {	/* Byte order LSB first. */
				proto_len = ucp[6] + 256 * ucp[7];
				data_len = ucp[8] + 256 * ucp[9];
			} else {
				debug("Initial X11 packet contains bad byte order byte: 0x%x",
				      ucp[0]);
				ch->type = SSH_CHANNEL_OPEN;
				goto reject;
			}
d497 10
a506 4
			/* Check if the whole packet is in buffer. */
			if (buffer_len(&ch->output) <
			    12 + ((proto_len + 3) & ~3) + ((data_len + 3) & ~3))
				break;
d508 14
a521 29
			/* Check if authentication protocol matches. */
			if (proto_len != strlen(x11_saved_proto) ||
			    memcmp(ucp + 12, x11_saved_proto, proto_len) != 0) {
				debug("X11 connection uses different authentication protocol.");
				ch->type = SSH_CHANNEL_OPEN;
				goto reject;
			}
			/* Check if authentication data matches our fake data. */
			if (data_len != x11_fake_data_len ||
			    memcmp(ucp + 12 + ((proto_len + 3) & ~3),
				x11_fake_data, x11_fake_data_len) != 0) {
				debug("X11 auth data does not match fake data.");
				ch->type = SSH_CHANNEL_OPEN;
				goto reject;
			}
			/* Check fake data length */
			if (x11_fake_data_len != x11_saved_data_len) {
				error("X11 fake_data_len %d != saved_data_len %d",
				  x11_fake_data_len, x11_saved_data_len);
				ch->type = SSH_CHANNEL_OPEN;
				goto reject;
			}
			/*
			 * Received authentication protocol and data match
			 * our fake data. Substitute the fake data with real
			 * data.
			 */
			memcpy(ucp + 12 + ((proto_len + 3) & ~3),
			       x11_saved_data, x11_saved_data_len);
d523 5
a527 3
			/* Start normal processing for the channel. */
			ch->type = SSH_CHANNEL_OPEN;
			goto redo;
d529 6
a534 8
	reject:
			/*
			 * We have received an X11 connection that has bad
			 * authentication information.
			 */
			log("X11 connection rejected because of wrong authentication.\r\n");
			buffer_clear(&ch->input);
			buffer_clear(&ch->output);
d536 3
a538 6
				close(ch->sock);
				ch->sock = -1;
				ch->type = SSH_CHANNEL_CLOSED;
				packet_start(SSH_MSG_CHANNEL_CLOSE);
				packet_put_int(ch->remote_id);
				packet_send();
d540 1
a540 4
				debug("X11 rejected %d i%d/o%d", ch->self, ch->istate, ch->ostate);
				chan_read_failed(ch);
				chan_write_failed(ch);
				debug("X11 rejected %d i%d/o%d", ch->self, ch->istate, ch->ostate);
d542 10
a551 1
			break;
d553 15
a567 3
		case SSH_CHANNEL_FREE:
		default:
			continue;
d569 1
d571 1
d574 6
a579 4
/*
 * After select, perform any appropriate operations for channels which have
 * events pending.
 */
d581 2
a582 2
void 
channel_after_select(fd_set * readset, fd_set * writeset)
d584 11
a594 5
	struct sockaddr addr;
	int newsock, i, newch, len;
	socklen_t addrlen;
	Channel *ch;
	char buf[16384], *remote_hostname;
d596 10
a605 27
	/* Loop over all channels... */
	for (i = 0; i < channels_alloc; i++) {
		ch = &channels[i];
		switch (ch->type) {
		case SSH_CHANNEL_X11_LISTENER:
			/* This is our fake X11 server socket. */
			if (FD_ISSET(ch->sock, readset)) {
				debug("X11 connection requested.");
				addrlen = sizeof(addr);
				newsock = accept(ch->sock, &addr, &addrlen);
				if (newsock < 0) {
					error("accept: %.100s", strerror(errno));
					break;
				}
				remote_hostname = get_remote_hostname(newsock);
				snprintf(buf, sizeof buf, "X11 connection from %.200s port %d",
				remote_hostname, get_peer_port(newsock));
				xfree(remote_hostname);
				newch = channel_allocate(SSH_CHANNEL_OPENING, newsock,
							 xstrdup(buf));
				packet_start(SSH_SMSG_X11_OPEN);
				packet_put_int(newch);
				if (have_hostname_in_open)
					packet_put_string(buf, strlen(buf));
				packet_send();
			}
			break;
d607 6
a612 30
		case SSH_CHANNEL_PORT_LISTENER:
			/*
			 * This socket is listening for connections to a
			 * forwarded TCP/IP port.
			 */
			if (FD_ISSET(ch->sock, readset)) {
				debug("Connection to port %d forwarding to %.100s port %d requested.",
				      ch->listening_port, ch->path, ch->host_port);
				addrlen = sizeof(addr);
				newsock = accept(ch->sock, &addr, &addrlen);
				if (newsock < 0) {
					error("accept: %.100s", strerror(errno));
					break;
				}
				remote_hostname = get_remote_hostname(newsock);
				snprintf(buf, sizeof buf, "listen port %d for %.100s port %d, connect from %.200s port %d",
					 ch->listening_port, ch->path, ch->host_port,
				remote_hostname, get_peer_port(newsock));
				xfree(remote_hostname);
				newch = channel_allocate(SSH_CHANNEL_OPENING, newsock,
							 xstrdup(buf));
				packet_start(SSH_MSG_PORT_OPEN);
				packet_put_int(newch);
				packet_put_string(ch->path, strlen(ch->path));
				packet_put_int(ch->host_port);
				if (have_hostname_in_open)
					packet_put_string(buf, strlen(buf));
				packet_send();
			}
			break;
d614 8
a621 19
		case SSH_CHANNEL_AUTH_SOCKET:
			/*
			 * This is the authentication agent socket listening
			 * for connections from clients.
			 */
			if (FD_ISSET(ch->sock, readset)) {
				addrlen = sizeof(addr);
				newsock = accept(ch->sock, &addr, &addrlen);
				if (newsock < 0) {
					error("accept from auth socket: %.100s", strerror(errno));
					break;
				}
				newch = channel_allocate(SSH_CHANNEL_OPENING, newsock,
					xstrdup("accepted auth socket"));
				packet_start(SSH_SMSG_AGENT_OPEN);
				packet_put_int(newch);
				packet_send();
			}
			break;
d623 5
a627 6
		case SSH_CHANNEL_OPEN:
			/*
			 * This is an open two-way communication channel. It
			 * is not of interest to us at this point what kind
			 * of data is being transmitted.
			 */
d629 13
a641 35
			/*
			 * Read available incoming data and append it to
			 * buffer; shutdown socket, if read or write failes
			 */
			if (FD_ISSET(ch->sock, readset)) {
				len = read(ch->sock, buf, sizeof(buf));
				if (len <= 0) {
					if (compat13) {
						buffer_consume(&ch->output, buffer_len(&ch->output));
						ch->type = SSH_CHANNEL_INPUT_DRAINING;
						debug("Channel %d status set to input draining.", i);
					} else {
						chan_read_failed(ch);
					}
					break;
				}
				buffer_append(&ch->input, buf, len);
			}
			/* Send buffered output data to the socket. */
			if (FD_ISSET(ch->sock, writeset) && buffer_len(&ch->output) > 0) {
				len = write(ch->sock, buffer_ptr(&ch->output),
					    buffer_len(&ch->output));
				if (len <= 0) {
					if (compat13) {
						buffer_consume(&ch->output, buffer_len(&ch->output));
						debug("Channel %d status set to input draining.", i);
						ch->type = SSH_CHANNEL_INPUT_DRAINING;
					} else {
						chan_write_failed(ch);
					}
					break;
				}
				buffer_consume(&ch->output, len);
			}
			break;
d643 6
a648 13
		case SSH_CHANNEL_OUTPUT_DRAINING:
			if (!compat13)
				fatal("cannot happen: OUT_DRAIN");
			/* Send buffered output data to the socket. */
			if (FD_ISSET(ch->sock, writeset) && buffer_len(&ch->output) > 0) {
				len = write(ch->sock, buffer_ptr(&ch->output),
					    buffer_len(&ch->output));
				if (len <= 0)
					buffer_consume(&ch->output, buffer_len(&ch->output));
				else
					buffer_consume(&ch->output, len);
			}
			break;
d650 9
a658 3
		case SSH_CHANNEL_X11_OPEN:
		case SSH_CHANNEL_FREE:
		default:
d660 2
a661 1
		}
d665 12
d683 1
a683 1
	Channel *ch;
d686 1
a686 1
		ch = &channels[i];
d690 2
a691 2
			if (ch->type != SSH_CHANNEL_OPEN &&
			    ch->type != SSH_CHANNEL_INPUT_DRAINING)
d694 1
a694 1
			if (ch->type != SSH_CHANNEL_OPEN)
d696 2
a697 2
			if (ch->istate != CHAN_INPUT_OPEN &&
			    ch->istate != CHAN_INPUT_WAIT_DRAIN)
d702 1
a702 1
		len = buffer_len(&ch->input);
d713 10
a722 6
			packet_start(SSH_MSG_CHANNEL_DATA);
			packet_put_int(ch->remote_id);
			packet_put_string(buffer_ptr(&ch->input), len);
			packet_send();
			buffer_consume(&ch->input, len);
		} else if (ch->istate == CHAN_INPUT_WAIT_DRAIN) {
d729 1
a729 1
			chan_ibuf_empty(ch);
d741 1
a741 1
channel_input_data(int payload_len)
d746 1
a746 1
	Channel *ch;
d750 2
a751 1
	if (id < 0 || id >= channels_alloc)
a752 4
	ch = &channels[id];

	if (ch->type == SSH_CHANNEL_FREE)
		packet_disconnect("Received data for free channel %d.", ch->self);
d755 2
a756 2
	if (ch->type != SSH_CHANNEL_OPEN &&
	    ch->type != SSH_CHANNEL_X11_OPEN)
d760 1
a760 1
	if (!compat13 && ch->ostate != CHAN_OUTPUT_OPEN)
d765 3
a767 2
	packet_integrity_check(payload_len, 4 + 4 + data_len, SSH_MSG_CHANNEL_DATA);
	buffer_append(&ch->output, data, data_len);
d780 1
a780 1
	Channel *ch;
d783 5
a787 3
		ch = &channels[i];
		if (ch->type == SSH_CHANNEL_OPEN) {
			if (buffer_len(&ch->input) > packet_get_maxsize())
d789 4
a792 1
			if (buffer_len(&ch->output) > packet_get_maxsize())
d794 1
d800 14
a813 1
/* This is called after receiving CHANNEL_CLOSE/IEOF. */
d816 1
a816 1
channel_input_close()
d818 2
a819 1
	int channel;
d821 6
a826 11
	/* Get the channel number and verify it. */
	channel = packet_get_int();
	if (channel < 0 || channel >= channels_alloc ||
	    channels[channel].type == SSH_CHANNEL_FREE)
		packet_disconnect("Received data for nonexistent channel %d.", channel);

	if (!compat13) {
		/* proto version 1.5 overloads CLOSE with IEOF */
		chan_rcvd_ieof(&channels[channel]);
		return;
	}
d833 1
a833 1
	packet_put_int(channels[channel].remote_id);
d843 1
a843 1
	if (channels[channel].type != SSH_CHANNEL_CLOSED) {
d848 2
a849 3
		buffer_consume(&channels[channel].input,
			       buffer_len(&channels[channel].input));
		channels[channel].type = SSH_CHANNEL_OUTPUT_DRAINING;
d853 11
a863 1
/* This is called after receiving CHANNEL_CLOSE_CONFIRMATION/OCLOSE. */
d866 1
a866 1
channel_input_close_confirmation()
d868 2
a869 16
	int channel;

	/* Get the channel number and verify it. */
	channel = packet_get_int();
	if (channel < 0 || channel >= channels_alloc)
		packet_disconnect("Received close confirmation for out-of-range channel %d.",
				  channel);

	if (!compat13) {
		/* proto version 1.5 overloads CLOSE_CONFIRMATION with OCLOSE */
		chan_rcvd_oclose(&channels[channel]);
		return;
	}
	if (channels[channel].type != SSH_CHANNEL_CLOSED)
		packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
				  channel, channels[channel].type);
d871 7
a877 2
	/* Free the channel. */
	channel_free(channel);
a879 2
/* This is called after receiving CHANNEL_OPEN_CONFIRMATION. */

d881 1
a881 1
channel_input_open_confirmation()
d883 2
a884 1
	int channel, remote_channel;
d886 1
a886 6
	/* Get the channel number and verify it. */
	channel = packet_get_int();
	if (channel < 0 || channel >= channels_alloc ||
	    channels[channel].type != SSH_CHANNEL_OPENING)
		packet_disconnect("Received open confirmation for non-opening channel %d.",
				  channel);
d888 2
a889 2
	/* Get remote side's id for this channel. */
	remote_channel = packet_get_int();
d891 4
d896 2
a897 2
	channels[channel].remote_id = remote_channel;
	channels[channel].type = SSH_CHANNEL_OPEN;
a899 2
/* This is called after receiving CHANNEL_OPEN_FAILURE from the other side. */

d901 1
a901 1
channel_input_open_failure()
d903 7
a909 1
	int channel;
d911 3
a913 6
	/* Get the channel number and verify it. */
	channel = packet_get_int();
	if (channel < 0 || channel >= channels_alloc ||
	    channels[channel].type != SSH_CHANNEL_OPENING)
		packet_disconnect("Received open failure for non-opening channel %d.",
				  channel);
d916 1
a916 1
	channel_free(channel);
d1029 1
a1029 1
			snprintf(buf, sizeof buf, "  #%d %.300s (t%d r%d i%d/%d o%d/%d)\r\n",
d1033 2
a1034 1
			    c->ostate, buffer_len(&c->output));
d1038 1
a1038 1
			fatal("channel_still_open: bad channel type %d", c->type);
d1117 5
a1121 2
		ch = channel_allocate(SSH_CHANNEL_PORT_LISTENER, sock,
		    xstrdup("port listener"));
d1138 2
a1139 2
channel_request_remote_forwarding(u_short port, const char *host,
				  u_short remote_port)
d1146 3
a1148 2
	permitted_opens[num_permitted_opens].host = xstrdup(host);
	permitted_opens[num_permitted_opens].port = remote_port;
d1153 3
a1155 3
	packet_put_int(port);
	packet_put_string(host, strlen(host));
	packet_put_int(remote_port);
a1157 1

d1199 49
d1255 1
a1255 1
channel_input_port_open(int payload_len)
a1256 1
	int remote_channel, sock = 0, newch, i;
d1259 1
a1260 3
	struct addrinfo hints, *ai, *aitop;
	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
	int gaierr;
d1280 2
a1281 3
	packet_integrity_check(payload_len,
			       4 + 4 + host_len + 4 + originator_len,
			       SSH_MSG_PORT_OPEN);
d1284 1
d1288 2
a1289 2
			if (permitted_opens[i].port == host_port &&
			    strcmp(permitted_opens[i].host, host) == 0)
d1297 1
a1297 1
			goto fail;
d1300 14
a1313 39

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = IPv4or6;
	hints.ai_socktype = SOCK_STREAM;
	snprintf(strport, sizeof strport, "%d", host_port);
	if ((gaierr = getaddrinfo(host, strport, &hints, &aitop)) != 0) {
		error("%.100s: unknown host (%s)", host, gai_strerror(gaierr));
		goto fail;
	}

	for (ai = aitop; ai; ai = ai->ai_next) {
		if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)
			continue;
		if (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop, sizeof(ntop),
		    strport, sizeof(strport), NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
			error("channel_input_port_open: getnameinfo failed");
			continue;
		}
		/* Create the socket. */
		sock = socket(ai->ai_family, SOCK_STREAM, 0);
		if (sock < 0) {
			error("socket: %.100s", strerror(errno));
			continue;
		}
		/* Connect to the host/port. */
		if (connect(sock, ai->ai_addr, ai->ai_addrlen) < 0) {
			error("connect %.100s port %s: %.100s", ntop, strport,
			    strerror(errno));
			close(sock);
			continue;	/* fail -- try next */	
		}
		break; /* success */

	}
	freeaddrinfo(aitop);

	if (!ai) {
		error("connect %.100s port %d: failed.", host, host_port);	
		goto fail;
a1314 20

	/* Successful connection. */

	/* Allocate a channel for this connection. */
	newch = channel_allocate(SSH_CHANNEL_OPEN, sock, originator_string);
	channels[newch].remote_id = remote_channel;

	/* Send a confirmation to the remote host. */
	packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
	packet_put_int(remote_channel);
	packet_put_int(newch);
	packet_send();

	/* Free the argument string. */
	xfree(host);

	return;

fail:
	/* Free the argument string. */
a1315 5

	/* Send refusal to the remote host. */
	packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
	packet_put_int(remote_channel);
	packet_send();
d1449 1
a1449 1
x11_input_open(int payload_len)
d1472 1
a1472 1
	packet_integrity_check(payload_len, 4 + remote_len, SSH_SMSG_X11_OPEN);
d1538 11
a1548 1
		continue;
a1549 11
	/* Connect it to the display. */
	if (connect(sock, ai->ai_addr, ai->ai_addrlen) < 0) {
		debug("connect %.100s port %d: %.100s", buf, 6000 + display_number, 
		    strerror(errno));
		close(sock);
		continue;
	}
	/* Success */
	break;

	} /* (ai = aitop, ai; ai = ai->ai_next) */
d1737 1
a1737 1
auth_input_open_request()
d1741 2
@


1.39
log
@-pedantic: signed vs. unsigned, void*-arithm, etc
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.38 2000/01/24 20:37:29 markus Exp $");
d559 1
a559 1
				if (len > packet_get_maxsize()/2)
@


1.38
log
@do not connect() if request has been denied.
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.37 2000/01/10 10:12:52 markus Exp $");
d1040 1
a1040 1
	int host_len, originator_len;
d1287 1
a1287 1
	int remote_len;
@


1.37
log
@discard data for channel if state != CHAN_OUTPUT_OPEN, fixes lockup
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.36 2000/01/04 07:52:03 markus Exp $");
d1080 1
a1080 3
			packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
			packet_put_int(remote_channel);
			packet_send();
@


1.36
log
@listen on _all_ interfaces for X11-Fwd (hints.ai_flags = AI_PASSIVE)
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.35 2000/01/04 00:07:58 markus Exp $");
d536 1
d538 11
a548 3
		if (ch->type != SSH_CHANNEL_OPEN &&
		    ch->type != SSH_CHANNEL_INPUT_DRAINING)
			continue;
d588 1
a588 1
	int channel;
d591 1
d594 7
a600 4
	channel = packet_get_int();
	if (channel < 0 || channel >= channels_alloc ||
	    channels[channel].type == SSH_CHANNEL_FREE)
		packet_disconnect("Received data for nonexistent channel %d.", channel);
d603 6
a608 2
	if (channels[channel].type != SSH_CHANNEL_OPEN &&
	    channels[channel].type != SSH_CHANNEL_X11_OPEN)
d614 1
a614 1
	buffer_append(&channels[channel].output, data, data_len);
d631 1
a631 6
		switch (ch->type) {
		case SSH_CHANNEL_X11_LISTENER:
		case SSH_CHANNEL_PORT_LISTENER:
		case SSH_CHANNEL_AUTH_SOCKET:
			continue;
		case SSH_CHANNEL_OPEN:
a635 7
			continue;
		case SSH_CHANNEL_INPUT_DRAINING:
		case SSH_CHANNEL_OUTPUT_DRAINING:
		case SSH_CHANNEL_X11_OPEN:
		case SSH_CHANNEL_FREE:
		default:
			continue;
d862 5
a866 3
			snprintf(buf, sizeof buf, "  #%d %.300s (t%d r%d i%d o%d)\r\n",
				 c->self, c->remote_name,
				 c->type, c->remote_id, c->istate, c->ostate);
@


1.35
log
@ipv6 support: mostly gethostbyname->getaddrinfo/getnameinfo, new features:
sshd allows multiple ListenAddress and Port options.  note that libwrap is
not IPv6-ready. (based on patches from <kick@@kyoto.wide.ad.jp> and
fujiwara@@rcac.tdi.co.jp)
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.34 1999/12/27 09:48:38 markus Exp $");
d1171 1
a1171 1
		hints.ai_flags = 0 /*AI_PASSIVE*/;	/* XXX loopback only ? */
@


1.34
log
@use packet_get_maxsize for channels. consistence.
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.33 1999/12/12 19:20:02 markus Exp $");
d377 2
a378 1
	int addrlen, newsock, i, newch, len;
d416 1
a416 1
				debug("Connection to port %d forwarding to %.100s:%d requested.",
d425 1
a425 1
				snprintf(buf, sizeof buf, "listen port %d:%.100s:%d, connect from %.200s:%d",
d882 3
a884 2
	int ch, sock, on = 1;
	struct sockaddr_in sin;
a889 14
	/* Create a port to listen for the host. */
	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0)
		packet_disconnect("socket: %.100s", strerror(errno));

	/* Initialize socket address. */
	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	if (gateway_ports == 1)
		sin.sin_addr.s_addr = htonl(INADDR_ANY);
	else
		sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	sin.sin_port = htons(port);

d891 2
a892 2
	 * Set socket options.  We would like the socket to disappear as soon
	 * as it has been closed for whatever reason.
d894 58
a951 19
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *)&on, sizeof(on));
	linger.l_onoff = 1;
	linger.l_linger = 5;
	setsockopt(sock, SOL_SOCKET, SO_LINGER, (void *) &linger, sizeof(linger));

	/* Bind the socket to the address. */
	if (bind(sock, (struct sockaddr *) & sin, sizeof(sin)) < 0)
		packet_disconnect("bind: %.100s", strerror(errno));

	/* Start listening for connections on the socket. */
	if (listen(sock, 5) < 0)
		packet_disconnect("listen: %.100s", strerror(errno));

	/* Allocate a channel number for the socket. */
	ch = channel_allocate(SSH_CHANNEL_PORT_LISTENER, sock,
			      xstrdup("port listener"));
	strlcpy(channels[ch].path, host, sizeof(channels[ch].path));
	channels[ch].host_port = host_port;
	channels[ch].listening_port = port;
d1030 1
a1030 1
	int remote_channel, sock, newch, i;
a1031 1
	struct sockaddr_in sin;
a1032 1
	struct hostent *hp;
d1034 3
d1078 23
a1100 11
	memset(&sin, 0, sizeof(sin));
	sin.sin_addr.s_addr = inet_addr(host);
	if ((sin.sin_addr.s_addr & 0xffffffff) != 0xffffffff) {
		/* It was a valid numeric host address. */
		sin.sin_family = AF_INET;
	} else {
		/* Look up the host address from the name servers. */
		hp = gethostbyname(host);
		if (!hp) {
			error("%.100s: unknown host.", host);
			goto fail;
d1102 6
a1107 3
		if (!hp->h_addr_list[0]) {
			error("%.100s: host has no IP address.", host);
			goto fail;
d1109 2
a1110 11
		sin.sin_family = hp->h_addrtype;
		memcpy(&sin.sin_addr, hp->h_addr_list[0],
		       sizeof(sin.sin_addr));
	}
	sin.sin_port = htons(host_port);

	/* Create the socket. */
	sock = socket(sin.sin_family, SOCK_STREAM, 0);
	if (sock < 0) {
		error("socket: %.100s", strerror(errno));
		goto fail;
d1112 4
a1115 5
	/* Connect to the host/port. */
	if (connect(sock, (struct sockaddr *) & sin, sizeof(sin)) < 0) {
		error("connect %.100s:%d: %.100s", host, host_port,
		      strerror(errno));
		close(sock);
d1118 1
d1152 2
d1159 4
a1162 2
	struct sockaddr_in sin;
	char buf[512];
d1169 7
a1175 8
		memset(&sin, 0, sizeof(sin));
		sin.sin_family = AF_INET;
		sin.sin_addr.s_addr = htonl(INADDR_ANY);
		sin.sin_port = htons(port);

		sock = socket(AF_INET, SOCK_STREAM, 0);
		if (sock < 0) {
			error("socket: %.100s", strerror(errno));
d1178 22
a1199 5
		if (bind(sock, (struct sockaddr *) & sin, sizeof(sin)) < 0) {
			debug("bind port %d: %.100s", port, strerror(errno));
			shutdown(sock, SHUT_RDWR);
			close(sock);
			continue;
d1201 2
a1202 1
		break;
d1209 8
a1216 5
	if (listen(sock, 5) < 0) {
		error("listen: %.100s", strerror(errno));
		shutdown(sock, SHUT_RDWR);
		close(sock);
		return NULL;
d1218 1
d1222 1
a1222 1
	snprintf(buf, sizeof buf, "%.400s:%d.%d", hostname,
d1225 6
a1230 3
	/* Allocate a channel for the socket. */
	(void) channel_allocate(SSH_CHANNEL_X11_LISTENER, sock,
				xstrdup("X11 inet listener"));
d1233 1
a1233 1
	return xstrdup(buf);
d1279 1
a1279 1
	int remote_channel, display_number, sock, newch;
a1280 1
	struct sockaddr_in sin;
a1281 1
	struct hostent *hp;
d1283 3
d1351 8
a1358 29
	/* Try to parse the host name as a numeric IP address. */
	memset(&sin, 0, sizeof(sin));
	sin.sin_addr.s_addr = inet_addr(buf);
	if ((sin.sin_addr.s_addr & 0xffffffff) != 0xffffffff) {
		/* It was a valid numeric host address. */
		sin.sin_family = AF_INET;
	} else {
		/* Not a numeric IP address. */
		/* Look up the host address from the name servers. */
		hp = gethostbyname(buf);
		if (!hp) {
			error("%.100s: unknown host.", buf);
			goto fail;
		}
		if (!hp->h_addr_list[0]) {
			error("%.100s: host has no IP address.", buf);
			goto fail;
		}
		sin.sin_family = hp->h_addrtype;
		memcpy(&sin.sin_addr, hp->h_addr_list[0],
		       sizeof(sin.sin_addr));
	}
	/* Set port number. */
	sin.sin_port = htons(6000 + display_number);

	/* Create a socket. */
	sock = socket(sin.sin_family, SOCK_STREAM, 0);
	if (sock < 0) {
		error("socket: %.100s", strerror(errno));
d1361 7
d1369 3
a1371 3
	if (connect(sock, (struct sockaddr *) & sin, sizeof(sin)) < 0) {
		error("connect %.100s:%d: %.100s", buf, 6000 + display_number,
		      strerror(errno));
d1373 10
@


1.33
log
@type conflict for 'extern Type *options' in channels.c; dot@@dotat.at
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.32 1999/12/06 12:07:21 deraadt Exp $");
d254 1
a254 1
				debug("Closing channel %d after input drain.", i);
d446 2
a447 3
				int nchan;
				len = sizeof(addr);
				newsock = accept(ch->sock, &addr, &len);
d452 1
a452 1
				nchan = channel_allocate(SSH_CHANNEL_OPENING, newsock,
d455 1
a455 1
				packet_put_int(nchan);
d549 2
a550 2
				if (len > 16384)
					len = 16384;
@


1.32
log
@display great hatred towards strcpy
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.31 1999/12/01 13:59:15 markus Exp $");
d880 1
a880 1
				 u_short host_port)
a883 1
	extern Options options;
d897 1
a897 1
	if (options.gateway_ports == 1)
d985 5
a989 3

	/* Initiate forwarding. */
	channel_request_local_forwarding(port, hostname, host_port);
d1120 1
a1120 1
x11_create_display_inet(int screen_number)
a1121 1
	extern ServerOptions options;
d1128 1
a1128 1
	for (display_number = options.x11_display_offset;
@


1.31
log
@ports are u_short
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.30 1999/11/25 09:10:33 deraadt Exp $");
d924 1
a924 1
	strcpy(channels[ch].path, host);
d1501 2
a1502 1
	strcpy(channels[newch].path, channel_forwarded_auth_socket_name);
@


1.30
log
@fix type
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.29 1999/11/24 20:07:25 markus Exp $");
d85 1
a85 1
	int port;		/* Port number. */
d879 2
a880 2
channel_request_local_forwarding(int port, const char *host,
				 int host_port)
d935 2
a936 2
channel_request_remote_forwarding(int port, const char *host,
				  int remote_port)
d971 1
a971 1
	int port, host_port;
a978 4
	/* Port numbers are 16 bit quantities. */
	if ((port & 0xffff) != port)
		packet_disconnect("Requested forwarding of nonexistent port %d.", port);

d1003 2
a1004 1
	int remote_channel, sock, newch, host_port, i;
d1122 2
a1123 1
	int display_number, port, sock;
@


1.29
log
@fix packet_integrity_check() for !have_hostname_in_open.
report from mrwizard@@psu.edu via djm@@ibs.com.au
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.28 1999/11/24 20:02:11 markus Exp $");
d1183 1
a1183 1
connect_local_xsocket(unsigned dnr)
@


1.28
log
@set SO_REUSEADDR and SO_LINGER for forwarded ports.
chip@@valinux.com via damien@@ibs.com.au
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.27 1999/11/24 19:53:45 markus Exp $");
d1023 1
a1023 1
	if (have_hostname_in_open)
d1025 2
a1026 1
	else
d1028 2
d1032 1
a1032 1
			       4 + 4 + host_len + 4 + 4 + originator_len,
d1231 1
a1231 1
	if (have_hostname_in_open)
d1233 2
a1234 1
	else
d1236 2
d1240 1
a1240 1
	packet_integrity_check(payload_len, 4 + 4 + remote_len, SSH_SMSG_X11_OPEN);
@


1.27
log
@KNF, final part 3
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.26 1999/11/24 00:26:01 deraadt Exp $");
d882 1
a882 1
	int ch, sock;
d885 1
d903 9
@


1.26
log
@much more KNF
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.25 1999/11/23 22:25:53 markus Exp $");
d40 4
a43 2
/* Pointer to an array containing all allocated channels.  The array is
   dynamically extended as needed. */
d46 5
a50 3
/* Size of the channel array.  All slots of the array must always be
   initialized (at least the type field); unused slots are marked with
   type SSH_CHANNEL_FREE. */
d53 4
a56 2
/* Maximum file descriptor value used in any of the channels.  This is updated
   in channel_allocate. */
d70 4
a73 2
/* Fake X11 authentication data.  This is what the server will be sending
   us; we should replace any occurrences of this by the real data. */
d77 6
a82 4
/* Data structure for storing which hosts are permitted for forward requests.
   The local sides of any remote forwards are stored in this array to prevent
   a corrupt remote server from accessing arbitrary TCP/IP ports on our
   local network (which might be behind a firewall). */
d92 5
a96 3
/* If this is true, all opens are permitted.  This is the case on the
   server on which we have to trust the client anyway, and the user could
   do anything after logging in anyway. */
d110 5
a114 3
/* Permits opening to any host/port in SSH_MSG_PORT_OPEN.  This is usually
   called by the server, because the user could connect to any port anyway,
   and the server has no way to know but to trust the client anyway. */
d122 4
a125 2
/* Allocate a new channel object and set its type and socket.
   This will cause remote_name to be freed. */
d136 1
d144 4
a147 3

		/* Kludge: arrange a call to channel_stop_listening if we
		   terminate with fatal(). */
d158 1
a158 2
		/* There are no free slots.  Take last+1 slot and expand
		   the array.  */
d201 4
a204 2
/* This is called just before select() to add any bits relevant to
   channels in the select bitmasks. */
d270 10
a279 9
			/* This is a special state for X11 authentication
			   spoofing.  An opened X11 connection (when
			   authentication spoofing is being done) remains
			   in this state until the first packet has been
			   completely read.  The authentication data in
			   that packet is then substituted by the real
			   data if it matches the fake data, and the
			   channel is put into normal mode. */

d326 5
a330 3
			/* Received authentication protocol and data match
			   our fake data. Substitute the fake data with
			   real data. */
d339 4
a342 2
			/* We have received an X11 connection that has bad
			   authentication information. */
d368 4
a371 2
/* After select, perform any appropriate operations for channels which
   have events pending. */
d410 4
a413 2
			/* This socket is listening for connections to a
			   forwarded TCP/IP port. */
d441 4
a444 2
			/* This is the authentication agent socket
			   listening for connections from clients. */
d462 10
a471 7
			/* This is an open two-way communication channel.
			   It is not of interest to us at this point what
			   kind of data is being transmitted. */

			/* Read available incoming data and append it to
			   buffer; shutdown socket, if read or write
			   failes */
d536 1
a536 2
		/* We are only interested in channels that can have
		   buffered incoming data. */
d544 1
a544 2
			/* Send some data for the other side over the
			   secure connection. */
d561 4
a564 3
			/* input-buffer is empty and read-socket shutdown:
			   tell peer, that we will not send more data:
			   send IEOF */
d570 5
a574 3
/* This is called when a packet of type CHANNEL_DATA has just been received.
   The message type has already been consumed, but channel number and data
   is still there. */
d601 4
a604 2
/* Returns true if no channel has too much buffered data, and false if
   one or more channel is overfull. */
d654 5
a658 2
	/* Send a confirmation that we have closed the channel and no more
	   data is coming for it. */
d663 7
a669 5
	/* If the channel is in closed state, we have sent a close
	   request, and the other side will eventually respond with a
	   confirmation.  Thus, we cannot free the channel here, because
	   then there would be no-one to receive the confirmation.  The
	   channel gets freed when the confirmation arrives. */
d671 4
a674 2
		/* Not a closed channel - mark it as draining, which will
		   cause it to be freed later. */
d724 1
a724 2
	/* Record the remote channel number and mark that the channel is
	   now open. */
d747 4
a750 2
/* Stops listening for channels, and removes any unix domain sockets that
   we might have. */
d774 4
a777 2
/* Closes the sockets of all channels.  This is used to close extra file
   descriptors after a fork. */
d827 5
a831 3
/* Returns a message describing the currently open forwarded
   connections, suitable for sending to the client.  The message
   contains crlf pairs for newlines. */
d873 4
a876 2
/* Initiate forwarding of connections to local port "port" through the secure
   channel to host:port from remote side. */
d919 4
a922 2
/* Initiate forwarding of connections to port "port" on remote host through
   the secure channel to host:port from local side. */
d945 4
a948 2
	/* Wait for response from the remote side.  It will send a
	   disconnect message on failure, and we will never see it here. */
d952 5
a956 4
/* This is called after receiving CHANNEL_FORWARDING_REQUEST.  This initates
   listening for the port, and sends back a success reply (or disconnect
   message if there was an error).  This never returns if there was an
   error. */
d973 4
a976 2
	/* Check that an unprivileged user is not trying to forward a
	   privileged port. */
d988 5
a992 3
/* This is called after receiving PORT_OPEN message.  This attempts to connect
   to the given host:port, and sends back CHANNEL_OPEN_CONFIRMATION or
   CHANNEL_OPEN_FAILURE. */
d1102 5
a1106 3
/* Creates an internet domain socket for listening for X11 connections.
   Returns a suitable value for the DISPLAY variable, or NULL if an error
   occurs. */
d1198 5
a1202 3
/* This is called when SSH_SMSG_X11_OPEN is received.  The packet contains
   the remote channel number.  We should do whatever we want, and respond
   with either SSH_MSG_OPEN_CONFIRMATION or SSH_MSG_OPEN_FAILURE. */
d1232 9
a1240 5
	/* Now we decode the value of the DISPLAY variable and make a
	   connection to the real X server. */

	/* Check if it is a unix domain socket.  Unix domain displays are
	   in one of the following formats: unix:d[.s], :d[.s], ::d[.s] */
d1257 4
a1260 2
	/* Connect to an inet socket.  The DISPLAY value is supposedly
	   hostname:d[.s], where hostname may also be numeric IP address. */
d1269 1
a1269 2
	/* buf now contains the host name.  But first we parse the display
	   number. */
d1338 4
a1341 2
/* Requests forwarding of X11 connections, generates fake authentication
   data, and enables authentication spoofing. */
d1366 4
a1369 2
	/* Extract real authentication data and generate fake data of the
	   same length. */
d1409 5
a1413 3
/* Returns the name of the forwarded authentication socket.  Returns NULL
   if there is no forwarded authentication socket.  The returned value
   points to a static buffer. */
d1430 4
a1433 2
/* This if called to process SSH_CMSG_AGENT_REQUEST_FORWARDING on the server.
   This starts forwarding authentication requests. */
d1501 4
a1504 2
	/* Get a connection to the local authentication agent (this may
	   again get forwarded). */
d1507 6
a1512 4
	/* If we could not connect the agent, send an error message back
	   to the server. This should never happen unless the agent dies,
	   because authentication forwarding is only enabled if we have an
	   agent. */
d1521 5
a1525 3
	/* Dummy host name.  This will be freed when the channel is freed;
	   it will still be valid in the packet_put_string below since the
	   channel cannot yet be freed at that point. */
@


1.25
log
@KNF part 1
@
text
@d2 15
a16 15

channels.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Fri Mar 24 16:35:24 1995 ylo

This file contains functions for generic socket connection forwarding.
There is also code for initiating connection forwarding for X11 connections,
arbitrary tcp/ip connections, and the authentication agent connection.

*/
d19 1
a19 1
RCSID("$Id: channels.c,v 1.24 1999/11/22 21:02:38 markus Exp $");
@


1.24
log
@syslog changes:
* Unified Logmessage for all auth-types, for success and for failed
* Standard connections get only ONE line in the LOG when level==LOG:
  Auth-attempts are logged only, if authentication is:
        a) successfull or
        b) with passwd or
        c) we had more than AUTH_FAIL_LOG failues
* many log() became verbose()
* old behaviour with level=VERBOSE
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.23 1999/11/19 19:58:18 markus Exp $");
d55 1
a55 1
static char *channel_forwarded_auth_socket_dir  = NULL;
d73 3
a75 4
typedef struct
{
  char *host;		/* Host name. */
  int port;		/* Port number. */
d92 2
a93 1
void channel_set_options(int hostname_in_open)
d95 1
a95 1
  have_hostname_in_open = hostname_in_open;
d102 2
a103 1
void channel_permit_all_opens()
d105 1
a105 1
  all_opens_permitted = 1;
d108 1
a108 1
/* Allocate a new channel object and set its type and socket. 
d111 2
a112 1
int channel_allocate(int type, int sock, char *remote_name)
d114 2
a115 2
  int i, found;
  Channel *c;
d117 44
a160 49
  /* Update the maximum file descriptor value. */
  if (sock > channel_max_fd_value)
    channel_max_fd_value = sock;

  /* Do initial allocation if this is the first call. */
  if (channels_alloc == 0)
    {
      channels_alloc = 10;
      channels = xmalloc(channels_alloc * sizeof(Channel));
      for (i = 0; i < channels_alloc; i++)
	channels[i].type = SSH_CHANNEL_FREE;

      /* Kludge: arrange a call to channel_stop_listening if we terminate
	 with fatal(). */
      fatal_add_cleanup((void (*)(void *))channel_stop_listening, NULL);
    }

  /* Try to find a free slot where to put the new channel. */
  for (found = -1, i = 0; i < channels_alloc; i++)
    if (channels[i].type == SSH_CHANNEL_FREE)
      {
	/* Found a free slot. */
	found = i;
	break;
      }

  if (found == -1)
    {
      /* There are no free slots.  Take last+1 slot and expand the array.  */
      found = channels_alloc;
      channels_alloc += 10;
      debug("channel: expanding %d", channels_alloc);
      channels = xrealloc(channels, channels_alloc * sizeof(Channel));
      for (i = found; i < channels_alloc; i++)
        channels[i].type = SSH_CHANNEL_FREE;
    }

  /* Initialize and return new channel number. */
  c=&channels[found];
  buffer_init(&c->input);
  buffer_init(&c->output);
  chan_init_iostates(c);
  c->self = found;
  c->type = type;
  c->sock = sock;
  c->remote_id = -1;
  c->remote_name = remote_name;
  debug("channel %d: new [%s]", found, remote_name);
  return found;
d165 2
a166 1
void channel_free(int channel)
d168 14
a181 15
  if (channel < 0 || channel >= channels_alloc ||
      channels[channel].type == SSH_CHANNEL_FREE)
    packet_disconnect("channel free: bad local channel %d", channel);

  if(compat13)
    shutdown(channels[channel].sock, SHUT_RDWR);
  close(channels[channel].sock);
  buffer_free(&channels[channel].input);
  buffer_free(&channels[channel].output);
  channels[channel].type = SSH_CHANNEL_FREE;
  if (channels[channel].remote_name)
    {
      xfree(channels[channel].remote_name);
      channels[channel].remote_name = NULL;
    }
d187 2
a188 1
void channel_prepare_select(fd_set *readset, fd_set *writeset)
d190 126
a315 139
  int i;
  Channel *ch;
  unsigned char *ucp;
  unsigned int proto_len, data_len;

  for (i = 0; i < channels_alloc; i++)
    {
      ch = &channels[i];
    redo:
      switch (ch->type)
	{
	case SSH_CHANNEL_X11_LISTENER:
	case SSH_CHANNEL_PORT_LISTENER:
	case SSH_CHANNEL_AUTH_SOCKET:
	  FD_SET(ch->sock, readset);
	  break;

	case SSH_CHANNEL_OPEN:
	  if(compat13){
	    if (buffer_len(&ch->input) < packet_get_maxsize())
	      FD_SET(ch->sock, readset);
	    if (buffer_len(&ch->output) > 0)
	      FD_SET(ch->sock, writeset);
	    break;
	  }
	  /* test whether sockets are 'alive' for read/write */
          if (ch->istate == CHAN_INPUT_OPEN)
            if (buffer_len(&ch->input) < packet_get_maxsize())
              FD_SET(ch->sock, readset);
          if (ch->ostate == CHAN_OUTPUT_OPEN || ch->ostate == CHAN_OUTPUT_WAIT_DRAIN){
            if (buffer_len(&ch->output) > 0){
              FD_SET(ch->sock, writeset);
            }else if(ch->ostate == CHAN_OUTPUT_WAIT_DRAIN) {
              chan_obuf_empty(ch);
            }
          }
          break;

	case SSH_CHANNEL_INPUT_DRAINING:
 	  if (!compat13)
	    fatal("cannot happen: IN_DRAIN");
	  if (buffer_len(&ch->input) == 0)
	    {
	      packet_start(SSH_MSG_CHANNEL_CLOSE);
	      packet_put_int(ch->remote_id);
	      packet_send();
	      ch->type = SSH_CHANNEL_CLOSED;
	      debug("Closing channel %d after input drain.", i);
	      break;
	    }
	  break;

	case SSH_CHANNEL_OUTPUT_DRAINING:
 	  if (!compat13)
	    fatal("cannot happen: OUT_DRAIN");
	  if (buffer_len(&ch->output) == 0)
	    {
	      /* debug("Freeing channel %d after output drain.", i); */
	      channel_free(i);
	      break;
	    }
	  FD_SET(ch->sock, writeset);
	  break;

	case SSH_CHANNEL_X11_OPEN:
	  /* This is a special state for X11 authentication spoofing.  An
	     opened X11 connection (when authentication spoofing is being
	     done) remains in this state until the first packet has been
	     completely read.  The authentication data in that packet is
	     then substituted by the real data if it matches the fake data,
	     and the channel is put into normal mode. */

	  /* Check if the fixed size part of the packet is in buffer. */
	  if (buffer_len(&ch->output) < 12)
	    break;

	  /* Parse the lengths of variable-length fields. */
	  ucp = (unsigned char *)buffer_ptr(&ch->output);
	  if (ucp[0] == 0x42)
	    { /* Byte order MSB first. */
	      proto_len = 256 * ucp[6] + ucp[7];
	      data_len = 256 * ucp[8] + ucp[9];
	    }
	  else
	    if (ucp[0] == 0x6c)
	      { /* Byte order LSB first. */
		proto_len = ucp[6] + 256 * ucp[7];
		data_len = ucp[8] + 256 * ucp[9];
	      }
	    else
	      {
		debug("Initial X11 packet contains bad byte order byte: 0x%x",
		      ucp[0]);
		ch->type = SSH_CHANNEL_OPEN;
		goto reject;
	      }

	  /* Check if the whole packet is in buffer. */
	  if (buffer_len(&ch->output) <
	      12 + ((proto_len + 3) & ~3) + ((data_len + 3) & ~3))
	    break;
	  
	  /* Check if authentication protocol matches. */
	  if (proto_len != strlen(x11_saved_proto) || 
	      memcmp(ucp + 12, x11_saved_proto, proto_len) != 0)
	    {
	      debug("X11 connection uses different authentication protocol.");
	      ch->type = SSH_CHANNEL_OPEN;
	      goto reject;
	    }

	  /* Check if authentication data matches our fake data. */
	  if (data_len != x11_fake_data_len ||
	      memcmp(ucp + 12 + ((proto_len + 3) & ~3),
		     x11_fake_data, x11_fake_data_len) != 0)
	    {
	      debug("X11 auth data does not match fake data.");
	      ch->type = SSH_CHANNEL_OPEN;
	      goto reject;
	    }

	  /* Check fake data length */
	  if (x11_fake_data_len != x11_saved_data_len)
	    {
	      error("X11 fake_data_len %d != saved_data_len %d",
		     x11_fake_data_len, x11_saved_data_len);
	      ch->type = SSH_CHANNEL_OPEN;
	      goto reject;
	    }

	  /* Received authentication protocol and data match our fake data.
	     Substitute the fake data with real data. */
	  memcpy(ucp + 12 + ((proto_len + 3) & ~3),
		 x11_saved_data, x11_saved_data_len);

	  /* Start normal processing for the channel. */
	  ch->type = SSH_CHANNEL_OPEN;
	  goto redo;
	  
d317 24
a340 23
	  /* We have received an X11 connection that has bad authentication
	     information. */
	  log("X11 connection rejected because of wrong authentication.\r\n");
	  buffer_clear(&ch->input);
	  buffer_clear(&ch->output);
	  if (compat13) {
            close(ch->sock);
            ch->sock = -1;
            ch->type = SSH_CHANNEL_CLOSED;
            packet_start(SSH_MSG_CHANNEL_CLOSE);
            packet_put_int(ch->remote_id);
            packet_send();
          }else{
	    debug("X11 rejected %d i%d/o%d", ch->self, ch->istate, ch->ostate);
	    chan_read_failed(ch);
	    chan_write_failed(ch);
	    debug("X11 rejected %d i%d/o%d", ch->self, ch->istate, ch->ostate);
	  }
	  break;

	case SSH_CHANNEL_FREE:
	default:
	  continue;
a341 1
    }
d347 2
a348 1
void channel_after_select(fd_set *readset, fd_set *writeset)
d350 139
a488 50
  struct sockaddr addr;
  int addrlen, newsock, i, newch, len;
  Channel *ch;
  char buf[16384], *remote_hostname;
  
  /* Loop over all channels... */
  for (i = 0; i < channels_alloc; i++)
    {
      ch = &channels[i];
      switch (ch->type)
	{
	case SSH_CHANNEL_X11_LISTENER:
	  /* This is our fake X11 server socket. */
	  if (FD_ISSET(ch->sock, readset))
	    {
	      debug("X11 connection requested.");
	      addrlen = sizeof(addr);
	      newsock = accept(ch->sock, &addr, &addrlen);
	      if (newsock < 0)
		{
		  error("accept: %.100s", strerror(errno));
		  break;
		}
	      remote_hostname = get_remote_hostname(newsock);
	      snprintf(buf, sizeof buf, "X11 connection from %.200s port %d",
		      remote_hostname, get_peer_port(newsock));
	      xfree(remote_hostname);
	      newch = channel_allocate(SSH_CHANNEL_OPENING, newsock, 
				       xstrdup(buf));
	      packet_start(SSH_SMSG_X11_OPEN);
	      packet_put_int(newch);
	      if (have_hostname_in_open)
		packet_put_string(buf, strlen(buf));
	      packet_send();
	    }
	  break;
	  
	case SSH_CHANNEL_PORT_LISTENER:
	  /* This socket is listening for connections to a forwarded TCP/IP
	     port. */
	  if (FD_ISSET(ch->sock, readset))
	    {
	      debug("Connection to port %d forwarding to %.100s:%d requested.",
		    ch->listening_port, ch->path, ch->host_port);
	      addrlen = sizeof(addr);
	      newsock = accept(ch->sock, &addr, &addrlen);
	      if (newsock < 0)
		{
		  error("accept: %.100s", strerror(errno));
		  break;
a489 101
	      remote_hostname = get_remote_hostname(newsock);
	      snprintf(buf, sizeof buf, "listen port %d:%.100s:%d, connect from %.200s:%d",
		      ch->listening_port, ch->path, ch->host_port,
		      remote_hostname, get_peer_port(newsock));
	      xfree(remote_hostname);
	      newch = channel_allocate(SSH_CHANNEL_OPENING, newsock, 
				       xstrdup(buf));
	      packet_start(SSH_MSG_PORT_OPEN);
	      packet_put_int(newch);
	      packet_put_string(ch->path, strlen(ch->path));
	      packet_put_int(ch->host_port);
	      if (have_hostname_in_open)
		packet_put_string(buf, strlen(buf));
	      packet_send();
	    }
	  break;

	case SSH_CHANNEL_AUTH_SOCKET:
	  /* This is the authentication agent socket listening for connections
	     from clients. */
	  if (FD_ISSET(ch->sock, readset))
	    {
	      int nchan;
	      len = sizeof(addr);
	      newsock = accept(ch->sock, &addr, &len);
	      if (newsock < 0)
		{
		  error("accept from auth socket: %.100s", strerror(errno));
		  break;
		}

	      nchan = channel_allocate(SSH_CHANNEL_OPENING, newsock,
				     xstrdup("accepted auth socket"));
	      packet_start(SSH_SMSG_AGENT_OPEN);
	      packet_put_int(nchan);
	      packet_send();
	    }
	  break;

	case SSH_CHANNEL_OPEN:
	  /* This is an open two-way communication channel.  It is not of
	     interest to us at this point what kind of data is being
	     transmitted. */

	  /* Read available incoming data and append it to buffer;
	     shutdown socket, if read or write failes */
	  if (FD_ISSET(ch->sock, readset))
	    {
	      len = read(ch->sock, buf, sizeof(buf));
	      if (len <= 0)
		{
		  if (compat13) {
                    buffer_consume(&ch->output, buffer_len(&ch->output));
                    ch->type = SSH_CHANNEL_INPUT_DRAINING;
                    debug("Channel %d status set to input draining.", i);
                  }else{
                    chan_read_failed(ch);
		  }
		  break;
		}
	      buffer_append(&ch->input, buf, len);
	    }
	  /* Send buffered output data to the socket. */
	  if (FD_ISSET(ch->sock, writeset) && buffer_len(&ch->output) > 0)
	    {
	      len = write(ch->sock, buffer_ptr(&ch->output),
			  buffer_len(&ch->output));
	      if (len <= 0)
		{
		  if (compat13) {
                    buffer_consume(&ch->output, buffer_len(&ch->output));
                    debug("Channel %d status set to input draining.", i);
                    ch->type = SSH_CHANNEL_INPUT_DRAINING;
                  }else{
                    chan_write_failed(ch);
		  }
		  break;
		}
	      buffer_consume(&ch->output, len);
	    }
	  break;

	case SSH_CHANNEL_OUTPUT_DRAINING:
 	  if (!compat13)
		fatal("cannot happen: OUT_DRAIN");
	  /* Send buffered output data to the socket. */
	  if (FD_ISSET(ch->sock, writeset) && buffer_len(&ch->output) > 0)
	    {
	      len = write(ch->sock, buffer_ptr(&ch->output),
			  buffer_len(&ch->output));
	      if (len <= 0)
		buffer_consume(&ch->output, buffer_len(&ch->output));
	      else
		buffer_consume(&ch->output, len);
	    }
	  break;

	case SSH_CHANNEL_X11_OPEN:
	case SSH_CHANNEL_FREE:
	default:
	  continue;
a490 1
    }
d495 2
a496 1
void channel_output_poll()
d498 2
a499 2
  int len, i;
  Channel *ch;
d501 35
a535 39
  for (i = 0; i < channels_alloc; i++)
    {
      ch = &channels[i];
      /* We are only interested in channels that can have buffered incoming
	 data. */
      if (ch->type != SSH_CHANNEL_OPEN && 
	  ch->type != SSH_CHANNEL_INPUT_DRAINING)
	continue;

      /* Get the amount of buffered data for this channel. */
      len = buffer_len(&ch->input);
      if (len > 0)
	{
	  /* Send some data for the other side over the secure connection. */
	  if (packet_is_interactive())
	    {
	      if (len > 1024)
		len = 512;
	    }
	  else
	    {
	      if (len > 16384)
		len = 16384;  /* Keep the packets at reasonable size. */
	    }
	  packet_start(SSH_MSG_CHANNEL_DATA);
	  packet_put_int(ch->remote_id);
	  packet_put_string(buffer_ptr(&ch->input), len);
	  packet_send();
	  buffer_consume(&ch->input, len);
	}
      else if(ch->istate == CHAN_INPUT_WAIT_DRAIN)
     	{
 	  if (compat13)
	     fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
	  /* input-buffer is empty and read-socket shutdown:
	     tell peer, that we will not send more data: send IEOF */
	  chan_ibuf_empty(ch);
     	}
    }
d542 2
a543 1
void channel_input_data(int payload_len)
d545 20
a564 20
  int channel;
  char *data;
  unsigned int data_len;

  /* Get the channel number and verify it. */
  channel = packet_get_int();
  if (channel < 0 || channel >= channels_alloc ||
      channels[channel].type == SSH_CHANNEL_FREE)
    packet_disconnect("Received data for nonexistent channel %d.", channel);

  /* Ignore any data for non-open channels (might happen on close) */
  if (channels[channel].type != SSH_CHANNEL_OPEN &&
      channels[channel].type != SSH_CHANNEL_X11_OPEN)
    return; 

  /* Get the data. */
  data = packet_get_string(&data_len);
  packet_integrity_check(payload_len, 4 + 4+data_len, SSH_MSG_CHANNEL_DATA);
  buffer_append(&channels[channel].output, data, data_len);
  xfree(data);
d570 2
a571 1
int channel_not_very_much_buffered_data()
d573 23
a595 24
  unsigned int i;
  Channel *ch;
  
  for (i = 0; i < channels_alloc; i++)
    {
      ch = &channels[i];
      switch (ch->type)
	{
	case SSH_CHANNEL_X11_LISTENER:
	case SSH_CHANNEL_PORT_LISTENER:
	case SSH_CHANNEL_AUTH_SOCKET:
	  continue;
	case SSH_CHANNEL_OPEN:
	  if (buffer_len(&ch->input) > packet_get_maxsize())
	    return 0;
	  if (buffer_len(&ch->output) > packet_get_maxsize())
	    return 0;
	  continue;
	case SSH_CHANNEL_INPUT_DRAINING:
	case SSH_CHANNEL_OUTPUT_DRAINING:
	case SSH_CHANNEL_X11_OPEN:
	case SSH_CHANNEL_FREE:
	default:
	  continue;
d597 1
a597 2
    }
  return 1;
d602 2
a603 1
void channel_input_close()
d605 1
a605 1
  int channel;
d607 29
a635 33
  /* Get the channel number and verify it. */
  channel = packet_get_int();
  if (channel < 0 || channel >= channels_alloc ||
      channels[channel].type == SSH_CHANNEL_FREE)
    packet_disconnect("Received data for nonexistent channel %d.", channel);

  if(!compat13){
    /* proto version 1.5 overloads CLOSE with IEOF */
    chan_rcvd_ieof(&channels[channel]);
    return;
  }

  /* Send a confirmation that we have closed the channel and no more data is
     coming for it. */
  packet_start(SSH_MSG_CHANNEL_CLOSE_CONFIRMATION);
  packet_put_int(channels[channel].remote_id);
  packet_send();

  /* If the channel is in closed state, we have sent a close request, and
     the other side will eventually respond with a confirmation.  Thus,
     we cannot free the channel here, because then there would be no-one to
     receive the confirmation.  The channel gets freed when the confirmation
     arrives. */
  if (channels[channel].type != SSH_CHANNEL_CLOSED)
    {
      /* Not a closed channel - mark it as draining, which will cause it to
	 be freed later. */
      buffer_consume(&channels[channel].input, 
		     buffer_len(&channels[channel].input));
      channels[channel].type = SSH_CHANNEL_OUTPUT_DRAINING;
      /* debug("Setting status to output draining; output len = %d",
	 buffer_len(&channels[channel].output)); */
    }
d640 2
a641 1
void channel_input_close_confirmation()
d643 1
a643 1
  int channel;
d645 14
a658 15
  /* Get the channel number and verify it. */
  channel = packet_get_int();
  if (channel < 0 || channel >= channels_alloc)
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
		      channel);

  if(!compat13){
    /* proto version 1.5 overloads CLOSE_CONFIRMATION with OCLOSE */
    chan_rcvd_oclose(&channels[channel]);
    return;
  }

  if (channels[channel].type != SSH_CHANNEL_CLOSED)
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
		      channel, channels[channel].type);
d660 2
a661 2
  /* Free the channel. */
  channel_free(channel);
d666 2
a667 1
void channel_input_open_confirmation()
d669 1
a669 1
  int channel, remote_channel;
d671 14
a684 13
  /* Get the channel number and verify it. */
  channel = packet_get_int();
  if (channel < 0 || channel >= channels_alloc ||
      channels[channel].type != SSH_CHANNEL_OPENING)
    packet_disconnect("Received open confirmation for non-opening channel %d.",
		      channel);

  /* Get remote side's id for this channel. */
  remote_channel = packet_get_int();

  /* Record the remote channel number and mark that the channel is now open. */
  channels[channel].remote_id = remote_channel;
  channels[channel].type = SSH_CHANNEL_OPEN;
d689 2
a690 1
void channel_input_open_failure()
d692 8
a699 1
  int channel;
d701 2
a702 9
  /* Get the channel number and verify it. */
  channel = packet_get_int();
  if (channel < 0 || channel >= channels_alloc ||
      channels[channel].type != SSH_CHANNEL_OPENING)
    packet_disconnect("Received open failure for non-opening channel %d.",
		      channel);
  
  /* Free the channel.  This will also close the socket. */
  channel_free(channel);
d708 2
a709 1
void channel_stop_listening()
d711 16
a726 17
  int i;
  for (i = 0; i < channels_alloc; i++)
    {
      switch (channels[i].type)
	{
	case SSH_CHANNEL_AUTH_SOCKET:
	  close(channels[i].sock);
	  remove(channels[i].path);
	  channel_free(i);
	  break;
	case SSH_CHANNEL_PORT_LISTENER:
	case SSH_CHANNEL_X11_LISTENER:
	  close(channels[i].sock);
	  channel_free(i);
	  break;
	default:
	  break;
a727 1
    }
d733 2
a734 1
void channel_close_all()
d736 5
a740 6
  int i;
  for (i = 0; i < channels_alloc; i++)
    {
      if (channels[i].type != SSH_CHANNEL_FREE)
	close(channels[i].sock);
    }
d745 2
a746 1
int channel_max_fd()
d748 1
a748 1
  return channel_max_fd_value;
d753 2
a754 1
int channel_still_open()
d756 23
a778 24
  unsigned int i;
  for (i = 0; i < channels_alloc; i++)
    switch (channels[i].type)
      {
      case SSH_CHANNEL_FREE:
      case SSH_CHANNEL_X11_LISTENER:
      case SSH_CHANNEL_PORT_LISTENER:
      case SSH_CHANNEL_CLOSED:
      case SSH_CHANNEL_AUTH_SOCKET:
	continue;
      case SSH_CHANNEL_OPENING:
      case SSH_CHANNEL_OPEN:
      case SSH_CHANNEL_X11_OPEN:
	return 1;
      case SSH_CHANNEL_INPUT_DRAINING:
      case SSH_CHANNEL_OUTPUT_DRAINING:
 	if (!compat13)
	  fatal("cannot happen: OUT_DRAIN");
	return 1;
      default:
	fatal("channel_still_open: bad channel type %d", channels[i].type);
	/*NOTREACHED*/
      }
  return 0;
d785 2
a786 1
char *channel_open_message()
d788 6
a793 25
  Buffer buffer;
  int i;
  char buf[512], *cp;

  buffer_init(&buffer);
  snprintf(buf, sizeof buf, "The following connections are open:\r\n");
  buffer_append(&buffer, buf, strlen(buf));
  for (i = 0; i < channels_alloc; i++){
    Channel *c=&channels[i];
    switch (c->type)
      {
      case SSH_CHANNEL_FREE:
      case SSH_CHANNEL_X11_LISTENER:
      case SSH_CHANNEL_PORT_LISTENER:
      case SSH_CHANNEL_CLOSED:
      case SSH_CHANNEL_AUTH_SOCKET:
	continue;
      case SSH_CHANNEL_OPENING:
      case SSH_CHANNEL_OPEN:
      case SSH_CHANNEL_X11_OPEN:
      case SSH_CHANNEL_INPUT_DRAINING:
      case SSH_CHANNEL_OUTPUT_DRAINING:
	snprintf(buf, sizeof buf, "  #%d %.300s (t%d r%d i%d o%d)\r\n",
		 c->self,c->remote_name,
		 c->type,c->remote_id, c->istate,c->ostate);
d795 28
a822 10
	continue;
      default:
	fatal("channel_still_open: bad channel type %d", c->type);
	/*NOTREACHED*/
      }
  }
  buffer_append(&buffer, "\0", 1);
  cp = xstrdup(buffer_ptr(&buffer));
  buffer_free(&buffer);
  return cp;
d828 40
a867 39
void channel_request_local_forwarding(int port, const char *host,
				      int host_port)
{
  int ch, sock;
  struct sockaddr_in sin;
  extern Options options;

  if (strlen(host) > sizeof(channels[0].path) - 1)
    packet_disconnect("Forward host name too long.");
  
  /* Create a port to listen for the host. */
  sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock < 0)
    packet_disconnect("socket: %.100s", strerror(errno));

  /* Initialize socket address. */
  memset(&sin, 0, sizeof(sin));
  sin.sin_family = AF_INET;
  if (options.gateway_ports == 1)
    sin.sin_addr.s_addr = htonl(INADDR_ANY);
  else
    sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
  sin.sin_port = htons(port);
  
  /* Bind the socket to the address. */
  if (bind(sock, (struct sockaddr *)&sin, sizeof(sin)) < 0)
    packet_disconnect("bind: %.100s", strerror(errno));
      
  /* Start listening for connections on the socket. */
  if (listen(sock, 5) < 0)
    packet_disconnect("listen: %.100s", strerror(errno));
	    
  /* Allocate a channel number for the socket. */
  ch = channel_allocate(SSH_CHANNEL_PORT_LISTENER, sock,
			xstrdup("port listener"));
  strcpy(channels[ch].path, host); /* note: host name stored here */
  channels[ch].host_port = host_port; /* port on host to connect to */
  channels[ch].listening_port = port; /* port being listened */
}  
d872 24
a895 22
void channel_request_remote_forwarding(int port, const char *host,
				       int remote_port)
{
  int payload_len;
  /* Record locally that connection to this host/port is permitted. */
  if (num_permitted_opens >= SSH_MAX_FORWARDS_PER_DIRECTION)
    fatal("channel_request_remote_forwarding: too many forwards");	/* XXX why panic? -markus */
  permitted_opens[num_permitted_opens].host = xstrdup(host);
  permitted_opens[num_permitted_opens].port = remote_port;
  num_permitted_opens++;

  /* Send the forward request to the remote side. */
  packet_start(SSH_CMSG_PORT_FORWARD_REQUEST);
  packet_put_int(port);
  packet_put_string(host, strlen(host));
  packet_put_int(remote_port);
  packet_send();
  packet_write_wait();
  
  /* Wait for response from the remote side.  It will send a disconnect
     message on failure, and we will never see it here. */
  packet_read_expect(&payload_len, SSH_SMSG_SUCCESS);
d900 1
a900 1
   message if there was an error).  This never returns if there was an 
d903 2
a904 1
void channel_input_port_forward_request(int is_root)
d906 2
a907 17
  int port, host_port;
  char *hostname;
  
  /* Get arguments from the packet. */
  port = packet_get_int();
  hostname = packet_get_string(NULL);
  host_port = packet_get_int();
  
  /* Port numbers are 16 bit quantities. */
  if ((port & 0xffff) != port)
    packet_disconnect("Requested forwarding of nonexistent port %d.", port);

  /* Check that an unprivileged user is not trying to forward a privileged
     port. */
  if (port < IPPORT_RESERVED && !is_root)
    packet_disconnect("Requested forwarding of port %d but user is not root.",
		      port);
d909 14
a922 2
  /* Initiate forwarding. */
  channel_request_local_forwarding(port, hostname, host_port);
d924 5
a928 2
  /* Free the argument string. */
  xfree(hostname);
d935 2
a936 1
void channel_input_port_open(int payload_len)
d938 103
a1040 115
  int remote_channel, sock, newch, host_port, i;
  struct sockaddr_in sin;
  char *host, *originator_string;
  struct hostent *hp;
  int host_len, originator_len;

  /* Get remote channel number. */
  remote_channel = packet_get_int();

  /* Get host name to connect to. */
  host = packet_get_string(&host_len);

  /* Get port to connect to. */
  host_port = packet_get_int();

  /* Get remote originator name. */
  if (have_hostname_in_open)
    originator_string = packet_get_string(&originator_len);
  else
    originator_string = xstrdup("unknown (remote did not supply name)");

  packet_integrity_check(payload_len,
			 4 + 4 + host_len + 4 + 4 + originator_len,
			 SSH_MSG_PORT_OPEN);

  /* Check if opening that port is permitted. */
  if (!all_opens_permitted)
    {
      /* Go trough all permitted ports. */
      for (i = 0; i < num_permitted_opens; i++)
	if (permitted_opens[i].port == host_port &&
	    strcmp(permitted_opens[i].host, host) == 0)
	  break;

      /* Check if we found the requested port among those permitted. */
      if (i >= num_permitted_opens)
	{
	  /* The port is not permitted. */
	  log("Received request to connect to %.100s:%d, but the request was denied.",
	      host, host_port);
	  packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
	  packet_put_int(remote_channel);
	  packet_send();
	}
    }
  
  memset(&sin, 0, sizeof(sin));
  sin.sin_addr.s_addr = inet_addr(host);
  if ((sin.sin_addr.s_addr & 0xffffffff) != 0xffffffff)
    {
      /* It was a valid numeric host address. */
      sin.sin_family = AF_INET;
    }
  else
    {
      /* Look up the host address from the name servers. */
      hp = gethostbyname(host);
      if (!hp)
	{
	  error("%.100s: unknown host.", host);
	  goto fail;
	}
      if (!hp->h_addr_list[0])
	{
	  error("%.100s: host has no IP address.", host);
	  goto fail;
	}
      sin.sin_family = hp->h_addrtype;
      memcpy(&sin.sin_addr, hp->h_addr_list[0], 
	     sizeof(sin.sin_addr));
    }
  sin.sin_port = htons(host_port);

  /* Create the socket. */
  sock = socket(sin.sin_family, SOCK_STREAM, 0);
  if (sock < 0)
    {
      error("socket: %.100s", strerror(errno));
      goto fail;
    }

  /* Connect to the host/port. */
  if (connect(sock, (struct sockaddr *)&sin, sizeof(sin)) < 0)
    {
      error("connect %.100s:%d: %.100s", host, host_port,
	    strerror(errno));
      close(sock);
      goto fail;
    }

  /* Successful connection. */

  /* Allocate a channel for this connection. */
  newch = channel_allocate(SSH_CHANNEL_OPEN, sock, originator_string);
  channels[newch].remote_id = remote_channel;
  
  /* Send a confirmation to the remote host. */
  packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
  packet_put_int(remote_channel);
  packet_put_int(newch);
  packet_send();

  /* Free the argument string. */
  xfree(host);
  
  return;

 fail:
  /* Free the argument string. */
  xfree(host);

  /* Send refusal to the remote host. */
  packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
  packet_put_int(remote_channel);
  packet_send();
d1043 1
a1043 1
/* Creates an internet domain socket for listening for X11 connections. 
d1047 2
a1048 1
char *x11_create_display_inet(int screen_number)
d1050 48
a1097 54
  extern ServerOptions options;
  int display_number, port, sock;
  struct sockaddr_in sin;
  char buf[512];
  char hostname[MAXHOSTNAMELEN];

  for (display_number = options.x11_display_offset; display_number < MAX_DISPLAYS; display_number++)
    {
      port = 6000 + display_number;
      memset(&sin, 0, sizeof(sin));
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = htonl(INADDR_ANY);
      sin.sin_port = htons(port);
      
      sock = socket(AF_INET, SOCK_STREAM, 0);
      if (sock < 0)
	{
	  error("socket: %.100s", strerror(errno));
	  return NULL;
	}
      
      if (bind(sock, (struct sockaddr *)&sin, sizeof(sin)) < 0)
	{
	  debug("bind port %d: %.100s", port, strerror(errno));
	  shutdown(sock, SHUT_RDWR);
	  close(sock);
	  continue;
	}
      break;
    }
  if (display_number >= MAX_DISPLAYS)
    {
      error("Failed to allocate internet-domain X11 display socket.");
      return NULL;
    }

  /* Start listening for connections on the socket. */
  if (listen(sock, 5) < 0)
    {
      error("listen: %.100s", strerror(errno));
      shutdown(sock, SHUT_RDWR);
      close(sock);
      return NULL;
    }

  /* Set up a suitable value for the DISPLAY variable. */
  if (gethostname(hostname, sizeof(hostname)) < 0)
    fatal("gethostname: %.100s", strerror(errno));
  snprintf(buf, sizeof buf, "%.400s:%d.%d", hostname,
    display_number, screen_number);
	    
  /* Allocate a channel for the socket. */
  (void)channel_allocate(SSH_CHANNEL_X11_LISTENER, sock,
			 xstrdup("X11 inet listener"));
d1099 2
a1100 2
  /* Return a suitable value for the DISPLAY environment variable. */
  return xstrdup(buf);
d1111 23
a1133 24
  static const char *const x_sockets[] = {
    X_UNIX_PATH "%u",
    "/var/X/.X11-unix/X" "%u",
    "/usr/spool/sockets/X11/" "%u",
    NULL
  };
  int sock;
  struct sockaddr_un addr;
  const char *const *path;

  for (path = x_sockets; *path; ++path)
    {
      sock = socket(AF_UNIX, SOCK_STREAM, 0);
      if (sock < 0)
	error("socket: %.100s", strerror(errno));
      memset(&addr, 0, sizeof(addr));
      addr.sun_family = AF_UNIX;
      snprintf(addr.sun_path, sizeof addr.sun_path, *path, dnr);
      if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0)
	return sock;
      close(sock);
    }
  error("connect %.100s: %.100s", addr.sun_path, strerror(errno));
  return -1;
d1141 2
a1142 1
void x11_input_open(int payload_len)
d1144 124
a1267 139
  int remote_channel, display_number, sock, newch;
  const char *display;
  struct sockaddr_in sin;
  char buf[1024], *cp, *remote_host;
  struct hostent *hp;
  int remote_len;

  /* Get remote channel number. */
  remote_channel = packet_get_int();

  /* Get remote originator name. */
  if (have_hostname_in_open)
    remote_host = packet_get_string(&remote_len);
  else
    remote_host = xstrdup("unknown (remote did not supply name)");

  debug("Received X11 open request.");
  packet_integrity_check(payload_len, 4 + 4+remote_len, SSH_SMSG_X11_OPEN);

  /* Try to open a socket for the local X server. */
  display = getenv("DISPLAY");
  if (!display)
    {
      error("DISPLAY not set.");
      goto fail;
    }
  
  /* Now we decode the value of the DISPLAY variable and make a connection
     to the real X server. */

  /* Check if it is a unix domain socket.  Unix domain displays are in one
     of the following formats: unix:d[.s], :d[.s], ::d[.s] */
  if (strncmp(display, "unix:", 5) == 0 ||
      display[0] == ':')
    {
      /* Connect to the unix domain socket. */
      if (sscanf(strrchr(display, ':') + 1, "%d", &display_number) != 1)
	{
	  error("Could not parse display number from DISPLAY: %.100s",
		display);
	  goto fail;
	}
      /* Create a socket. */
      sock = connect_local_xsocket(display_number);
      if (sock < 0)
	goto fail;

      /* OK, we now have a connection to the display. */
      goto success;
    }
  
  /* Connect to an inet socket.  The DISPLAY value is supposedly
      hostname:d[.s], where hostname may also be numeric IP address. */
  strncpy(buf, display, sizeof(buf));
  buf[sizeof(buf) - 1] = 0;
  cp = strchr(buf, ':');
  if (!cp)
    {
      error("Could not find ':' in DISPLAY: %.100s", display);
      goto fail;
    }
  *cp = 0;
  /* buf now contains the host name.  But first we parse the display number. */
  if (sscanf(cp + 1, "%d", &display_number) != 1)
    {
       error("Could not parse display number from DISPLAY: %.100s",
	     display);
      goto fail;
    }
  
  /* Try to parse the host name as a numeric IP address. */
  memset(&sin, 0, sizeof(sin));
  sin.sin_addr.s_addr = inet_addr(buf);
  if ((sin.sin_addr.s_addr & 0xffffffff) != 0xffffffff)
    {
      /* It was a valid numeric host address. */
      sin.sin_family = AF_INET;
    }
  else
    {
      /* Not a numeric IP address. */
      /* Look up the host address from the name servers. */
      hp = gethostbyname(buf);
      if (!hp)
	{
	  error("%.100s: unknown host.", buf);
	  goto fail;
	}
      if (!hp->h_addr_list[0])
	{
	  error("%.100s: host has no IP address.", buf);
	  goto fail;
	}
      sin.sin_family = hp->h_addrtype;
      memcpy(&sin.sin_addr, hp->h_addr_list[0], 
	     sizeof(sin.sin_addr));
    }
  /* Set port number. */
  sin.sin_port = htons(6000 + display_number);

  /* Create a socket. */
  sock = socket(sin.sin_family, SOCK_STREAM, 0);
  if (sock < 0)
    {
      error("socket: %.100s", strerror(errno));
      goto fail;
    }
  /* Connect it to the display. */
  if (connect(sock, (struct sockaddr *)&sin, sizeof(sin)) < 0)
    {
      error("connect %.100s:%d: %.100s", buf, 6000 + display_number, 
	    strerror(errno));
      close(sock);
      goto fail;
    }

 success:
  /* We have successfully obtained a connection to the real X display. */
  
  /* Allocate a channel for this connection. */
  if (x11_saved_proto == NULL)
    newch = channel_allocate(SSH_CHANNEL_OPEN, sock, remote_host);
  else
    newch = channel_allocate(SSH_CHANNEL_X11_OPEN, sock, remote_host);
  channels[newch].remote_id = remote_channel;
  
  /* Send a confirmation to the remote host. */
  packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
  packet_put_int(remote_channel);
  packet_put_int(newch);
  packet_send();
  
  return;

 fail:
  /* Send refusal to the remote host. */
  packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
  packet_put_int(remote_channel);
  packet_send();
d1273 2
a1274 1
void x11_request_forwarding_with_spoofing(const char *proto, const char *data)
d1276 49
a1324 50
  unsigned int data_len = (unsigned int)strlen(data) / 2;
  unsigned int i, value;
  char *new_data;
  int screen_number;
  const char *cp;
  u_int32_t rand = 0;

  cp = getenv("DISPLAY");
  if (cp)
    cp = strchr(cp, ':');
  if (cp)
    cp = strchr(cp, '.');
  if (cp)
    screen_number = atoi(cp + 1);
  else
    screen_number = 0;

  /* Save protocol name. */
  x11_saved_proto = xstrdup(proto);

  /* Extract real authentication data and generate fake data of the same
     length. */
  x11_saved_data = xmalloc(data_len);
  x11_fake_data = xmalloc(data_len);
  for (i = 0; i < data_len; i++)
    {
      if (sscanf(data + 2 * i, "%2x", &value) != 1)
	fatal("x11_request_forwarding: bad authentication data: %.100s", data);
      if (i % 4 == 0)
	rand = arc4random();
      x11_saved_data[i] = value;
      x11_fake_data[i] = rand & 0xff;
      rand >>= 8;
    }
  x11_saved_data_len = data_len;
  x11_fake_data_len = data_len;

  /* Convert the fake data into hex. */
  new_data = xmalloc(2 * data_len + 1);
  for (i = 0; i < data_len; i++)
    sprintf(new_data + 2 * i, "%02x", (unsigned char)x11_fake_data[i]);

  /* Send the request packet. */
  packet_start(SSH_CMSG_X11_REQUEST_FORWARDING);
  packet_put_string(proto, strlen(proto));
  packet_put_string(new_data, strlen(new_data));
  packet_put_int(screen_number);
  packet_send();
  packet_write_wait();
  xfree(new_data);
d1329 2
a1330 1
void auth_request_forwarding()
d1332 3
a1334 3
  packet_start(SSH_CMSG_AGENT_REQUEST_FORWARDING);
  packet_send();
  packet_write_wait();
d1341 2
a1342 1
char *auth_get_socket_name()
d1344 1
a1344 1
  return channel_forwarded_auth_socket_name;
d1349 5
a1353 3
void cleanup_socket(void) {
  remove(channel_forwarded_auth_socket_name);
  rmdir(channel_forwarded_auth_socket_dir);
d1359 2
a1360 1
void auth_input_request_forwarding(struct passwd *pw)
d1362 50
a1411 51
  int sock, newch;
  struct sockaddr_un sunaddr;
  
  if (auth_get_socket_name() != NULL)
    fatal("Protocol error: authentication forwarding requested twice.");

  /* Temporarily drop privileged uid for mkdir/bind. */
  temporarily_use_uid(pw->pw_uid);

  /* Allocate a buffer for the socket name, and format the name. */
  channel_forwarded_auth_socket_name = xmalloc(MAX_SOCKET_NAME);
  channel_forwarded_auth_socket_dir  = xmalloc(MAX_SOCKET_NAME);
  strlcpy(channel_forwarded_auth_socket_dir, "/tmp/ssh-XXXXXXXX", MAX_SOCKET_NAME);

  /* Create private directory for socket */
  if (mkdtemp(channel_forwarded_auth_socket_dir) == NULL)
    packet_disconnect("mkdtemp: %.100s", strerror(errno));
  snprintf(channel_forwarded_auth_socket_name, MAX_SOCKET_NAME,
	   "%s/agent.%d", channel_forwarded_auth_socket_dir, (int)getpid());

  if (atexit(cleanup_socket) < 0) {
    int saved=errno;
    cleanup_socket();
    packet_disconnect("socket: %.100s", strerror(saved));
  }

  /* Create the socket. */
  sock = socket(AF_UNIX, SOCK_STREAM, 0);
  if (sock < 0)
    packet_disconnect("socket: %.100s", strerror(errno));

  /* Bind it to the name. */
  memset(&sunaddr, 0, sizeof(sunaddr));
  sunaddr.sun_family = AF_UNIX;
  strncpy(sunaddr.sun_path, channel_forwarded_auth_socket_name, 
          sizeof(sunaddr.sun_path));

  if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0)
    packet_disconnect("bind: %.100s", strerror(errno));

  /* Restore the privileged uid. */
  restore_uid();

  /* Start listening on the socket. */
  if (listen(sock, 5) < 0)
    packet_disconnect("listen: %.100s", strerror(errno));

  /* Allocate a channel for the authentication agent socket. */
  newch = channel_allocate(SSH_CHANNEL_AUTH_SOCKET, sock,
    		       xstrdup("auth socket"));
  strcpy(channels[newch].path, channel_forwarded_auth_socket_name);
d1416 2
a1417 1
void auth_input_open_request()
d1419 21
a1439 2
  int remch, sock, newch;
  char *dummyname;
d1441 13
a1453 33
  /* Read the remote channel number from the message. */
  remch = packet_get_int();
  
  /* Get a connection to the local authentication agent (this may again get
     forwarded). */
  sock = ssh_get_authentication_socket();

  /* If we could not connect the agent, send an error message back to
     the server. This should never happen unless the agent
     dies, because authentication forwarding is only enabled if we have an
     agent. */
  if (sock < 0){
    packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
    packet_put_int(remch);
    packet_send();
    return;
  }

  debug("Forwarding authentication connection.");

  /* Dummy host name.  This will be freed when the channel is freed; it will
     still be valid in the packet_put_string below since the channel cannot
     yet be freed at that point. */
  dummyname = xstrdup("authentication agent connection");
  
  newch = channel_allocate(SSH_CHANNEL_OPEN, sock, dummyname);
  channels[newch].remote_id = remch;
  
  /* Send a confirmation to the remote host. */
  packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
  packet_put_int(remch);
  packet_put_int(newch);
  packet_send();
@


1.23
log
@SSH_CMSG_MAX_PACKET_SIZE, some clients use this, some need this, niels@@
[hope this time my ISP stays alive during commit]
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.22 1999/11/19 19:18:20 deraadt Exp $");
d907 1
a907 1
    fatal("channel_request_remote_forwarding: too many forwards");
@


1.22
log
@make this compile, bad markus
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.20 1999/11/11 23:36:52 markus Exp $");
d211 1
a211 1
	    if (buffer_len(&ch->input) < 32768)
d219 1
a219 1
            if (buffer_len(&ch->input) < 32768)
d614 1
a614 1
	  if (buffer_len(&ch->input) > 32768)
d616 1
a616 1
	  if (buffer_len(&ch->output) > 32768)
@


1.21
log
@SSH_CMSG_MAX_PACKET_SIZE, some clients use this, some need this, niels@@
@
text
@d211 1
a211 1
	    if (buffer_len(&ch->input) < packet_get_maxsize())
d219 1
a219 1
            if (buffer_len(&ch->input) < packet_get_maxsize())
d614 1
a614 1
	  if (buffer_len(&ch->input) > packet_get_maxsize())
d616 1
a616 1
	  if (buffer_len(&ch->output) > packet_get_maxsize())
@


1.20
log
@make all access to options via 'extern Options options'
and 'extern ServerOptions options' respectively;
options are no longer passed as arguments:
 * make options handling more consistent
 * remove #include "readconf.h" from ssh.h
 * readconf.h is only included if necessary
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.19 1999/11/02 19:42:35 markus Exp $");
d211 1
a211 1
	    if (buffer_len(&ch->input) < 32768)
d219 1
a219 1
            if (buffer_len(&ch->input) < 32768)
d614 1
a614 1
	  if (buffer_len(&ch->input) > 32768)
d616 1
a616 1
	  if (buffer_len(&ch->output) > 32768)
@


1.19
log
@replace assert() with error, fatal or packet_disconnect
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.18 1999/10/28 21:26:09 markus Exp $");
d27 1
@


1.18
log
@remove broken x11 fix and document istate/ostate
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.17 1999/10/26 22:39:44 markus Exp $");
d169 4
a172 2
  assert(channel >= 0 && channel < channels_alloc &&
	 channels[channel].type != SSH_CHANNEL_FREE);
d312 9
a322 1
	  assert(x11_fake_data_len == x11_saved_data_len);
@


1.17
log
@more usefull debug messages and simplify channel alloc code
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.16 1999/10/17 16:56:08 markus Exp $");
a157 1
  c->x11 = 0;
a317 2
	  /* Enable X11 Problem FIX */
	  ch->x11 = 1;
@


1.16
log
@re-implement the proto-1.5 channel close protocol, see nchan.ms.
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.15 1999/10/16 21:19:00 deraadt Exp $");
d111 2
a112 1
  int i, old_channels;
d132 1
a132 1
  for (i = 0; i < channels_alloc; i++)
d135 3
a137 11
	/* Found a free slot.  Initialize the fields and return its number. */
	buffer_init(&channels[i].input);
	buffer_init(&channels[i].output);
	channels[i].self = i;
	channels[i].type = type;
	channels[i].x11 = 0;
	channels[i].sock = sock;
	channels[i].remote_id = -1;
	channels[i].remote_name = remote_name;
        chan_init_iostates(&channels[i]);
	return i;
d140 24
a163 19
  /* There are no free slots.  Must expand the array. */
  old_channels = channels_alloc;
  channels_alloc += 10;
  channels = xrealloc(channels, channels_alloc * sizeof(Channel));
  for (i = old_channels; i < channels_alloc; i++)
    channels[i].type = SSH_CHANNEL_FREE;

  /* We know that the next one after the old maximum channel number is now
     available.  Initialize and return its number. */
  buffer_init(&channels[old_channels].input);
  buffer_init(&channels[old_channels].output);
  channels[old_channels].self = old_channels;
  channels[old_channels].type = type;
  channels[old_channels].x11 = 0;
  channels[old_channels].sock = sock;
  channels[old_channels].remote_id = -1;
  channels[old_channels].remote_name = remote_name;
  chan_init_iostates(&channels[old_channels]);
  return old_channels;
d337 1
a337 1
	    debug("X11 rejected %d 0x%x 0x%x", ch->self, ch->istate, ch->ostate);
d340 1
a340 1
	    debug("X11 rejected %d 0x%x 0x%x", ch->self, ch->istate, ch->ostate);
d408 3
a410 3
	      snprintf(buf, sizeof buf, "port %d, connection from %.200s port %d",
		      ch->listening_port, remote_hostname,
		      get_peer_port(newsock));
d831 3
a833 2
	snprintf(buf, sizeof buf, "  #%d/%d %.300s\r\n",
		 c->self,c->type,c->remote_name);
@


1.15
log
@snprintf
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.14 1999/10/16 20:47:13 markus Exp $");
d139 1
a140 1
	channels[i].flags = 0;
d143 1
d160 1
a161 1
  channels[old_channels].flags = 0;
d164 1
d218 1
a218 1
          if (!(ch->flags & CHAN_SHUT_RD))
d221 1
a221 1
          if (!(ch->flags & CHAN_SHUT_WR)){
d224 2
a225 5
            }else if(ch->flags & CHAN_IEOF_RCVD){
              /* if output-buffer empty AND IEOF received,
                 we won't get more data for writing */
              chan_shutdown_write(ch);
              chan_send_oclose(ch);
d321 2
d339 4
a342 4
            chan_shutdown_read(ch);	/* shutdown, since close() does not update ch->flags */
            chan_send_ieof(ch);		/* no need to wait for output-buffer */
            chan_shutdown_write(ch);
            chan_send_oclose(ch);
d465 1
a465 4
                    buffer_consume(&ch->output, buffer_len(&ch->output));
                    chan_shutdown_read(ch);
                    /* we have to wait until the input-buffer has been
                       sent to our peer before we can send IEOF */
d483 1
a483 3
                    buffer_consume(&ch->output, buffer_len(&ch->output));
                    chan_shutdown_write(ch);
                    chan_send_oclose(ch);
a488 1
	  chan_del_if_dead(ch);
d551 1
a551 1
      else if(ch->flags & CHAN_SHUT_RD)
d554 1
a554 1
	     fatal("cannot happen: CHAN_SHUT_RD set for proto 1.3");
d557 1
a557 1
	  chan_send_ieof(ch);
@


1.14
log
@support for SSH protocol 1.5 which is poorly documented, the RFC.troff lies.
interops (x11,agent,etc) with 1.2.27 and protocol 1.3
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.13 1999/10/14 18:17:42 markus Exp $");
d381 1
a381 1
	      sprintf(buf, "X11 connection from %.200s port %d",
d409 1
a409 1
	      sprintf(buf, "port %d, connection from %.200s port %d",
d821 1
a821 1
  sprintf(buf, "The following connections are open:\r\n");
d1168 1
a1168 1
      sprintf(addr.sun_path, *path, dnr);
@


1.13
log
@fix old connect() race security-bug for ssh-agent and agent-forwarding
by removing the connect() junk, with the following restrictions:
1) change the version to "OpenSSH-1.1":
   agent-forwarding will work only between OpenSSH-1.1 client and
   OpenSSH-1.1 server
2) renamed the environment variable of OpenSSH-1.1 to
   "SSH_AUTH_SOCKET", since useing OpenSSH-1.0 ssh-add against the new
   ssh-agent does not work
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.12 1999/10/05 22:18:52 markus Exp $");
d29 4
a35 14
/* Definitions for channel types. */
#define SSH_CHANNEL_FREE		0 /* This channel is free (unused). */
#define SSH_CHANNEL_X11_LISTENER	1 /* Listening for inet X11 conn. */
#define SSH_CHANNEL_PORT_LISTENER	2 /* Listening on a port. */
#define SSH_CHANNEL_OPENING		3 /* waiting for confirmation */
#define SSH_CHANNEL_OPEN		4 /* normal open two-way channel */
#define SSH_CHANNEL_CLOSED		5 /* waiting for close confirmation */
/*	SSH_CHANNEL_AUTH_FD		6    authentication fd */
#define SSH_CHANNEL_AUTH_SOCKET		7 /* authentication socket */
/*	SSH_CHANNEL_AUTH_SOCKET_FD	8    connection to auth socket */
#define SSH_CHANNEL_X11_OPEN		9 /* reading first X11 packet */
#define SSH_CHANNEL_INPUT_DRAINING	10 /* sending remaining data to conn */
#define SSH_CHANNEL_OUTPUT_DRAINING	11 /* sending remaining data to app */

a38 16
/* Data structure for channel data.  This is iniailized in channel_allocate
   and cleared in channel_free. */

typedef struct
{
  int type;
  int sock;
  int remote_id;
  Buffer input;
  Buffer output;
  char path[200]; /* path for unix domain sockets, or host name for forwards */
  int host_port;  /* port to connect for forwards */
  int listening_port; /* port being listened for forwards */
  char *remote_name;
} Channel;

d137 1
d140 1
d157 1
d160 1
d172 2
a173 1
  shutdown(channels[channel].sock, SHUT_RDWR);
d208 22
a229 5
	  if (buffer_len(&ch->input) < 32768)
	    FD_SET(ch->sock, readset);
	  if (buffer_len(&ch->output) > 0)
	    FD_SET(ch->sock, writeset);
	  break;
d232 2
d246 2
d330 13
a342 6
	  close(ch->sock);
	  ch->sock = -1;
	  ch->type = SSH_CHANNEL_CLOSED;
	  packet_start(SSH_MSG_CHANNEL_CLOSE);
	  packet_put_int(ch->remote_id);
	  packet_send();
d451 3
a453 1
	  /* Read available incoming data and append it to buffer. */
d459 10
a468 3
		  buffer_consume(&ch->output, buffer_len(&ch->output));
		  ch->type = SSH_CHANNEL_INPUT_DRAINING;
		  debug("Channel %d status set to input draining.", i);
d480 9
a488 3
		  buffer_consume(&ch->output, buffer_len(&ch->output));
		  debug("Channel %d status set to input draining.", i);
		  ch->type = SSH_CHANNEL_INPUT_DRAINING;
d493 1
d497 2
d556 8
d606 1
a606 1
      switch (channels[i].type)
d629 1
a629 1
/* This is called after receiving CHANNEL_CLOSE. */
d641 6
d670 1
a670 1
/* This is called after receiving CHANNEL_CLOSE_CONFIRMATION. */
d681 7
d797 1
d800 2
d823 3
a825 2
  for (i = 0; i < channels_alloc; i++)
    switch (channels[i].type)
d838 2
a839 1
	sprintf(buf, "  %.300s\r\n", channels[i].remote_name);
d843 1
a843 1
	fatal("channel_still_open: bad channel type %d", channels[i].type);
d846 1
@


1.12
log
@move auth-sockets to private dir
delete minfd residua
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.11 1999/10/04 20:45:01 markus Exp $");
d39 1
a39 1
#define SSH_CHANNEL_AUTH_FD		6 /* authentication fd */
d41 1
a41 1
#define SSH_CHANNEL_AUTH_SOCKET_FD	8 /* connection to auth socket */
a224 2
	case SSH_CHANNEL_AUTH_SOCKET_FD:
	case SSH_CHANNEL_AUTH_FD:
d351 1
a351 1
  int addrlen, newsock, i, newch, len, port;
a417 23
	case SSH_CHANNEL_AUTH_FD:
	  /* This is the authentication agent file descriptor.  It is used to
	     obtain the real connection to the agent. */
	case SSH_CHANNEL_AUTH_SOCKET_FD:
	  /* This is the temporary connection obtained by connecting the
	     authentication agent socket. */
	  if (FD_ISSET(ch->sock, readset))
	    {
	      len = recv(ch->sock, buf, sizeof(buf), 0);
	      if (len <= 0)
		{
		  channel_free(i);
		  break;
		}
	      if (len != 3 || (unsigned char)buf[0] != SSH_AUTHFD_CONNECT)
		break; /* Ignore any messages of wrong length or type. */
	      port = 256 * (unsigned char)buf[1] + (unsigned char)buf[2];
	      packet_start(SSH_SMSG_AGENT_OPEN);
	      packet_put_int(port);
	      packet_send();
	    }
	  break;

d423 1
d427 6
a432 2
		error("Accept from authentication socket failed");
	      (void)channel_allocate(SSH_CHANNEL_AUTH_SOCKET_FD, newsock,
d434 3
a577 2
	case SSH_CHANNEL_AUTH_SOCKET_FD:
	case SSH_CHANNEL_AUTH_FD:
a745 1
      case SSH_CHANNEL_AUTH_FD:
a746 1
      case SSH_CHANNEL_AUTH_SOCKET_FD:
a780 1
      case SSH_CHANNEL_AUTH_FD:
a781 1
      case SSH_CHANNEL_AUTH_SOCKET_FD:
d1417 1
a1417 1
  int port, sock, newch;
d1420 2
a1421 2
  /* Read the port number from the message. */
  port = packet_get_int();
d1425 1
a1425 1
  sock = ssh_get_authentication_connection_fd();
d1427 2
a1428 2
  /* If we could not connect the agent, just return.  This will cause the
     client to timeout and fail.  This should never happen unless the agent
d1431 4
a1434 1
  if (sock < 0)
d1436 1
d1445 6
a1450 5
  /* Allocate a channel for the new connection. */
  newch = channel_allocate(SSH_CHANNEL_OPENING, sock, dummyname);

  /* Fake a forwarding request. */
  packet_start(SSH_MSG_PORT_OPEN);
a1451 4
  packet_put_string("localhost", strlen("localhost"));
  packet_put_int(port);
  if (have_hostname_in_open)
    packet_put_string(dummyname, strlen(dummyname));
@


1.11
log
@nuke genminfd/AUTH_FD
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.10 1999/10/03 19:22:38 deraadt Exp $");
d46 3
d78 1
a78 2
/* These two variables are for authentication agent forwarding. */
static int channel_forwarded_auth_fd = -1;
d80 1
a911 1
    
a1361 9
/* Returns the number of the file descriptor to pass to child programs as
   the authentication fd.  Returns -1 if there is no forwarded authentication
   fd. */

int auth_get_fd()
{
  return channel_forwarded_auth_fd;
}

d1371 7
a1382 1
  mode_t savedumask;
d1389 3
d1393 15
a1407 3
  channel_forwarded_auth_socket_name = xmalloc(100);
  sprintf(channel_forwarded_auth_socket_name, SSH_AGENT_SOCKET, 
          (int)getpid());
a1419 5
  savedumask = umask(0077);

  /* Temporarily use a privileged uid. */
  temporarily_use_uid(pw->pw_uid);

a1424 2

  umask(savedumask);
@


1.10
log
@use SHUT_* symbols
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.9 1999/09/30 08:34:24 deraadt Exp $");
a1382 1
  int pfd = get_permanent_fd(pw->pw_shell);
d1384 2
d1387 7
a1393 17
  if (pfd < 0) 
    {
      int sock, newch;
      struct sockaddr_un sunaddr;
      
      if (auth_get_socket_name() != NULL)
	fatal("Protocol error: authentication forwarding requested twice.");
    
      /* Allocate a buffer for the socket name, and format the name. */
      channel_forwarded_auth_socket_name = xmalloc(100);
      sprintf(channel_forwarded_auth_socket_name, SSH_AGENT_SOCKET, 
	      (int)getpid());
    
      /* Create the socket. */
      sock = socket(AF_UNIX, SOCK_STREAM, 0);
      if (sock < 0)
	packet_disconnect("socket: %.100s", strerror(errno));
d1395 4
a1398 5
      /* Bind it to the name. */
      memset(&sunaddr, 0, sizeof(sunaddr));
      sunaddr.sun_family = AF_UNIX;
      strncpy(sunaddr.sun_path, channel_forwarded_auth_socket_name, 
	      sizeof(sunaddr.sun_path));
d1400 5
a1404 1
      savedumask = umask(0077);
d1406 1
a1406 2
      /* Temporarily use a privileged uid. */
      temporarily_use_uid(pw->pw_uid);
d1408 2
a1409 2
      if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0)
	packet_disconnect("bind: %.100s", strerror(errno));
d1411 2
a1412 2
      /* Restore the privileged uid. */
      restore_uid();
d1414 2
a1415 1
      umask(savedumask);
d1417 1
a1417 3
      /* Start listening on the socket. */
      if (listen(sock, 5) < 0)
	packet_disconnect("listen: %.100s", strerror(errno));
d1419 3
a1421 12
      /* Allocate a channel for the authentication agent socket. */
      newch = channel_allocate(SSH_CHANNEL_AUTH_SOCKET, sock,
			       xstrdup("auth socket"));
      strcpy(channels[newch].path, channel_forwarded_auth_socket_name);
    }
  else 
    {
      int sockets[2], i, cnt, newfd;
      int *dups = xmalloc(sizeof (int) * (pfd + 1));
      
      if (auth_get_fd() != -1)
	fatal("Protocol error: authentication forwarding requested twice.");
d1423 4
a1426 35
      /* Create a socket pair. */
      if (socketpair(AF_UNIX, SOCK_STREAM, 0, sockets) < 0)
	packet_disconnect("socketpair: %.100s", strerror(errno));
    
      /* Dup some descriptors to get the authentication fd to pfd,
	 because some shells arbitrarily close descriptors below that.
	 Don't use dup2 because maybe some systems don't have it?? */
      for (cnt = 0;; cnt++) 
	{
	  if ((dups[cnt] = dup(packet_get_connection_in())) < 0)
	    fatal("auth_input_request_forwarding: dup failed");
	  if (dups[cnt] == pfd)
	    break;
	}
      close(dups[cnt]);
      
      /* Move the file descriptor we pass to children up high where
	 the shell won't close it. */
      newfd = dup(sockets[1]);
      if (newfd != pfd)
	fatal ("auth_input_request_forwarding: dup didn't return %d.", pfd);
      close(sockets[1]);
      sockets[1] = newfd;
      /* Close duped descriptors. */
      for (i = 0; i < cnt; i++)
	close(dups[i]);
      free(dups);
    
      /* Record the file descriptor to be passed to children. */
      channel_forwarded_auth_fd = sockets[1];
    
      /* Allcate a channel for the authentication fd. */
      (void)channel_allocate(SSH_CHANNEL_AUTH_FD, sockets[0],
			     xstrdup("auth fd"));
    }
@


1.9
log
@even smaller
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.8 1999/09/30 08:03:39 deraadt Exp $");
d191 1
a191 1
  shutdown(channels[channel].sock, 2);
d1077 1
a1077 1
	  shutdown(sock, 2);
d1093 1
a1093 1
      shutdown(sock, 2);
@


1.8
log
@IPPORT_RESERVED
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.7 1999/09/30 05:11:29 deraadt Exp $");
d1415 1
a1415 1
      if (bind(sock, (struct sockaddr *)&sunaddr, AF_UNIX_SIZE(sunaddr)) < 0)
@


1.7
log
@do not bother with dinosaur pacification
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.6 1999/09/29 21:14:16 deraadt Exp $");
d913 1
a913 1
  if (port < 1024 && !is_root)
@


1.6
log
@numerous sprintf, strncpy, strcpy cleanups
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.5 1999/09/29 18:16:19 dugsong Exp $");
a976 3
#ifdef BROKEN_INET_ADDR
  sin.sin_addr.s_addr = inet_network(host);
#else /* BROKEN_INET_ADDR */
a977 1
#endif /* BROKEN_INET_ADDR */
a1224 3
#ifdef BROKEN_INET_ADDR
  sin.sin_addr.s_addr = inet_network(buf);
#else /* BROKEN_INET_ADDR */
a1225 1
#endif /* BROKEN_INET_ADDR */
a1383 1
#ifdef HAVE_UMASK
a1384 1
#endif /* HAVE_UMASK */
a1409 1
#ifdef HAVE_UMASK
a1410 1
#endif /* HAVE_UMASK */
a1420 1
#ifdef HAVE_UMASK
a1421 1
#endif /* HAVE_UMASK */
@


1.5
log
@update krb4/AFS support to ssh-1.2.27-afs-kerberos-pl1 level, clean up unused variables, update manpages
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.4 1999/09/29 00:10:16 deraadt Exp $");
a20 3
#ifndef HAVE_GETHOSTNAME
#include <sys/utsname.h>
#endif
d1061 1
a1061 5
#ifdef HAVE_GETHOSTNAME
  char hostname[257];
#else
  struct utsname uts;
#endif
a1102 5
#ifdef HPSUX_NONSTANDARD_X11_KLUDGE
  /* HPSUX has some special shared memory stuff in their X server, which
     appears to be enable if the host name matches that of the local machine.
     However, it can be circumvented by using the IP address of the local
     machine instead.  */
d1105 2
a1106 28
  {
    struct hostent *hp;
    struct in_addr addr;
    hp = gethostbyname(hostname);
    if (!hp->h_addr_list[0])
      {
	error("Could not server IP address for %.200d.", hostname);
	packet_send_debug("Could not get server IP address for %.200d.", 
			  hostname);
	shutdown(sock, 2);
	close(sock);
	return NULL;
      }
    memcpy(&addr, hp->h_addr_list[0], sizeof(addr));
    sprintf(buf, "%.100s:%d.%d", inet_ntoa(addr), display_number, 
	    screen_number);
  }
#else /* HPSUX_NONSTANDARD_X11_KLUDGE */
#ifdef HAVE_GETHOSTNAME
  if (gethostname(hostname, sizeof(hostname)) < 0)
    fatal("gethostname: %.100s", strerror(errno));
  sprintf(buf, "%.400s:%d.%d", hostname, display_number, screen_number);
#else /* HAVE_GETHOSTNAME */
  if (uname(&uts) < 0)
    fatal("uname: %s", strerror(errno));
  sprintf(buf, "%.400s:%d.%d", uts.nodename, display_number, screen_number);
#endif /* HAVE_GETHOSTNAME */
#endif /* HPSUX_NONSTANDARD_X11_KLUDGE */
@


1.4
log
@GatewayPorts and ssh -g; markus.friedl@@informatik.uni-erlangen.de
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.3 1999/09/28 07:56:47 deraadt Exp $");
d1350 1
a1350 1
  u_int32_t rand;
@


1.3
log
@X11DisplayOffset; aaron
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.2 1999/09/28 04:45:36 provos Exp $");
d832 1
d845 4
a848 1
  sin.sin_addr.s_addr = INADDR_ANY;
d1075 1
a1075 1
      sin.sin_addr.s_addr = INADDR_ANY;
@


1.2
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.1 1999/09/26 20:53:34 deraadt Exp $");
d30 1
d1056 1
d1066 1
a1066 1
  for (display_number = 1; display_number < MAX_DISPLAYS; display_number++)
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d19 1
a19 1
RCSID("$Id: channels.c,v 1.7 1999/06/14 14:41:38 bg Exp $");
d1337 1
a1337 2
void x11_request_forwarding_with_spoofing(RandomState *state,
					  const char *proto, const char *data)
d1344 1
d1367 2
d1370 2
a1371 1
      x11_fake_data[i] = random_get_byte(state);
@

