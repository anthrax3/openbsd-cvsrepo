head	1.23;
access;
symbols
	OPENBSD_3_3:1.22.0.4
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.23
date	2003.07.22.13.35.22;	author markus;	state dead;
branches;
next	1.22;

1.22
date	2002.09.09.14.54.15;	author markus;	state Exp;
branches
	1.22.2.1
	1.22.4.1;
next	1.21;

1.21
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.23.12.58.26;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.22.06.15.47;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.20.09.17.19;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.06.23.15.12.19;	author itojun;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.01.16.23.58.09;	author deraadt;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2000.12.19.23.17.57;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.07.20.27.52;	author deraadt;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2000.06.22.23.55.00;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.05.18.53.42;	author markus;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.05.04.22.38.00;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.26.20.56.29;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.14.10.30.32;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.16.20.56.14;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.11.24.19.53.49;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	99.11.24.00.26.02;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.11.23.22.25.54;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	99.10.01.18.18.40;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.18.16.19;	author dugsong;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.36;	author deraadt;	state Exp;
branches;
next	;

1.11.2.1
date	2000.09.01.18.23.21;	author jason;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2000.11.08.21.31.06;	author jason;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.03.12.15.44.13;	author jason;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2001.03.21.18.52.56;	author jason;	state Exp;
branches;
next	;

1.13.2.1
date	2001.02.16.20.13.10;	author jason;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.02.19.17.19.11;	author jason;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2001.03.21.19.46.27;	author jason;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2001.05.07.21.09.32;	author jason;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.13.2.6;

1.13.2.6
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.15.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.04.22.19.56.42;	author miod;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2002.04.24.06.37.43;	author miod;	state Exp;
branches;
next	;

1.16.2.1
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.04.23.02.13.50;	author jason;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2002.04.23.14.17.47;	author jason;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.16.2.5;

1.16.2.5
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.17.2.1
date	2002.05.18.04.12.11;	author jason;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.05.18.04.50.38;	author jason;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	;

1.22.2.1
date	2003.09.16.21.20.26;	author brad;	state dead;
branches;
next	;

1.22.4.1
date	2003.09.16.20.50.43;	author brad;	state dead;
branches;
next	;


desc
@@


1.23
log
@remove (already disabled) KRB4/AFS support, re-enable -k in ssh(1);
test+ok henning@@
@
text
@/*
 * Copyright (c) 1999 Dug Song.  All rights reserved.
 * Copyright (c) 2002 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "includes.h"
#include "uuencode.h"

RCSID("$OpenBSD: radix.c,v 1.22 2002/09/09 14:54:15 markus Exp $");

#ifdef AFS
#include <krb.h>

#include <radix.h>
#include "bufaux.h"

int
creds_to_radix(CREDENTIALS *creds, u_char *buf, size_t buflen)
{
	Buffer b;
	int ret;

	buffer_init(&b);

	buffer_put_char(&b, 1);	/* version */

	buffer_append(&b, creds->service, strlen(creds->service));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->instance, strlen(creds->instance));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->realm, strlen(creds->realm));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->pname, strlen(creds->pname));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->pinst, strlen(creds->pinst));
	buffer_put_char(&b, '\0');

	/* Null string to repeat the realm. */
	buffer_put_char(&b, '\0');

	buffer_put_int(&b, creds->issue_date);
	buffer_put_int(&b, krb_life_to_time(creds->issue_date,
	    creds->lifetime));
	buffer_append(&b, creds->session, sizeof(creds->session));
	buffer_put_short(&b, creds->kvno);

	/* 32 bit size + data */
	buffer_put_string(&b, creds->ticket_st.dat, creds->ticket_st.length);

	ret = uuencode(buffer_ptr(&b), buffer_len(&b), (char *)buf, buflen);

	buffer_free(&b);
	return ret;
}

#define GETSTRING(b, t, tlen) \
	do { \
		int i, found = 0; \
		for (i = 0; i < tlen; i++) { \
			if (buffer_len(b) == 0) \
				goto done; \
			t[i] = buffer_get_char(b); \
			if (t[i] == '\0') { \
				found = 1; \
				break; \
			} \
		} \
		if (!found) \
			goto done; \
	} while(0)

int
radix_to_creds(const char *buf, CREDENTIALS *creds)
{
	Buffer b;
	u_char *space;
	char c, version, *p;
	u_int endTime, len;
	int blen, ret;

	ret = 0;
	blen = strlen(buf);

	/* sanity check for size */
	if (blen > 8192)
		return 0;

	buffer_init(&b);
	space = buffer_append_space(&b, blen);

	/* check version and length! */
	len = uudecode(buf, space, blen);
	if (len < 1)
		goto done;

	version = buffer_get_char(&b);

	GETSTRING(&b, creds->service, sizeof creds->service);
	GETSTRING(&b, creds->instance, sizeof creds->instance);
	GETSTRING(&b, creds->realm, sizeof creds->realm);
	GETSTRING(&b, creds->pname, sizeof creds->pname);
	GETSTRING(&b, creds->pinst, sizeof creds->pinst);

	if (buffer_len(&b) == 0)
		goto done;

	/* Ignore possibly different realm. */
	while (buffer_len(&b) > 0 && (c = buffer_get_char(&b)) != '\0')
		;

	if (buffer_len(&b) == 0)
		goto done;

	creds->issue_date = buffer_get_int(&b);

	endTime = buffer_get_int(&b);
	creds->lifetime = krb_time_to_life(creds->issue_date, endTime);

	len = buffer_len(&b);
	if (len < sizeof(creds->session))
		goto done;
	memcpy(&creds->session, buffer_ptr(&b), sizeof(creds->session));
	buffer_consume(&b, sizeof(creds->session));

	creds->kvno = buffer_get_short(&b);

	p = buffer_get_string(&b, &len);
	if (len < 0 || len > sizeof(creds->ticket_st.dat))
		goto done;
	memcpy(&creds->ticket_st.dat, p, len);
	creds->ticket_st.length = len;

	ret = 1;
done:
	buffer_free(&b);
	return ret;
}
#endif /* AFS */
@


1.22
log
@signed vs unsigned from -pedantic; ok henning@@
@
text
@d29 1
a29 1
RCSID("$OpenBSD: radix.c,v 1.21 2002/06/19 00:27:55 deraadt Exp $");
@


1.22.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d29 1
a29 1
RCSID("$OpenBSD: radix.c,v 1.22 2002/09/09 14:54:15 markus Exp $");
@


1.22.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d29 1
a29 1
RCSID("$OpenBSD: radix.c,v 1.22 2002/09/09 14:54:15 markus Exp $");
@


1.21
log
@KNF done automatically while reading....
@
text
@d29 1
a29 1
RCSID("$OpenBSD: radix.c,v 1.20 2002/04/23 12:58:26 markus Exp $");
d96 4
a99 3
	char c, version, *space, *p;
	u_int endTime;
	int len, blen, ret;
@


1.20
log
@send complete ticket; semerad@@ss1000.ms.mff.cuni.cz
@
text
@d29 1
a29 1
RCSID("$OpenBSD: radix.c,v 1.19 2002/04/22 06:15:47 markus Exp $");
d151 1
a151 1
	
@


1.19
log
@fix check for overflow
@
text
@d29 1
a29 1
RCSID("$OpenBSD: radix.c,v 1.18 2002/04/20 09:17:19 markus Exp $");
d68 1
a68 2
	buffer_put_string(&b, creds->ticket_st.dat,
	    sizeof(creds->ticket_st.length));
@


1.18
log
@rewrite using the buffer_* API, fixes overflow; ok deraadt@@
@
text
@d29 1
a29 1
RCSID("$OpenBSD: radix.c,v 1.17 2001/11/19 19:02:16 mpech Exp $");
d79 1
a79 1
		int i; \
d84 2
a85 1
			if (t[i] == '\0') \
d87 1
d89 1
a89 1
		if (t[i] != '\0') \
@


1.17
log
@kill more registers

millert@@ ok
@
text
@d3 1
d29 1
a29 1
RCSID("$OpenBSD: radix.c,v 1.16 2001/06/23 15:12:19 itojun Exp $");
d35 1
d37 5
a41 13
typedef u_char my_u_char;
typedef u_int my_u_int32_t;
typedef u_short my_u_short;

/* Nasty macros from BIND-4.9.2 */

#define GETSHORT(s, cp) { \
	my_u_char *t_cp = (my_u_char *)(cp); \
	(s) = (((my_u_short)t_cp[0]) << 8) \
	    | (((my_u_short)t_cp[1])) \
	    ; \
	(cp) += 2; \
}
d43 1
a43 9
#define GETLONG(l, cp) { \
	my_u_char *t_cp = (my_u_char *)(cp); \
	(l) = (((my_u_int32_t)t_cp[0]) << 24) \
	    | (((my_u_int32_t)t_cp[1]) << 16) \
	    | (((my_u_int32_t)t_cp[2]) << 8) \
	    | (((my_u_int32_t)t_cp[3])) \
	    ; \
	(cp) += 4; \
}
d45 1
a45 7
#define PUTSHORT(s, cp) { \
	my_u_short t_s = (my_u_short)(s); \
	my_u_char *t_cp = (my_u_char *)(cp); \
	*t_cp++ = t_s >> 8; \
	*t_cp   = t_s; \
	(cp) += 2; \
}
d47 10
a56 24
#define PUTLONG(l, cp) { \
	my_u_int32_t t_l = (my_u_int32_t)(l); \
	my_u_char *t_cp = (my_u_char *)(cp); \
	*t_cp++ = t_l >> 24; \
	*t_cp++ = t_l >> 16; \
	*t_cp++ = t_l >> 8; \
	*t_cp   = t_l; \
	(cp) += 4; \
}

#define GETSTRING(s, p, p_l) {			\
    char *p_targ = (p) + p_l;		\
    char *s_c = (s);			\
    char *p_c = (p);			\
    while (*p_c && (p_c < p_targ)) {		\
	*s_c++ = *p_c++;			\
    }						\
    if (p_c == p_targ) {			\
	return 1;				\
    }						\
    *s_c = *p_c++;				\
    (p_l) = (p_l) - (p_c - (p));		\
    (p) = p_c;					\
}
a57 31

int
creds_to_radix(CREDENTIALS *creds, u_char *buf, size_t buflen)
{
	char *p, *s;
	int len;
	char temp[2048];

	p = temp;
	*p++ = 1;		/* version */
	s = creds->service;
	while (*s)
		*p++ = *s++;
	*p++ = *s;
	s = creds->instance;
	while (*s)
		*p++ = *s++;
	*p++ = *s;
	s = creds->realm;
	while (*s)
		*p++ = *s++;
	*p++ = *s;

	s = creds->pname;
	while (*s)
		*p++ = *s++;
	*p++ = *s;
	s = creds->pinst;
	while (*s)
		*p++ = *s++;
	*p++ = *s;
d59 1
a59 19
	*p++ = '\0';

	PUTLONG(creds->issue_date, p);
	{
		u_int endTime;
		endTime = (u_int) krb_life_to_time(creds->issue_date,
							  creds->lifetime);
		PUTLONG(endTime, p);
	}

	memcpy(p, &creds->session, sizeof(creds->session));
	p += sizeof(creds->session);

	PUTSHORT(creds->kvno, p);
	PUTLONG(creds->ticket_st.length, p);

	memcpy(p, creds->ticket_st.dat, creds->ticket_st.length);
	p += creds->ticket_st.length;
	len = p - temp;
d61 29
a89 2
	return (uuencode((u_char *)temp, len, (char *)buf, buflen));
}
d94 4
d99 2
a100 4
	char *p;
	int len, tl;
	char version;
	char temp[2048];
d102 2
a103 2
	len = uudecode(buf, (u_char *)temp, sizeof(temp));
	if (len < 0)
d106 2
a107 1
	p = temp;
d110 1
d112 3
a114 8
		return 0;
	version = *p;
	p++;
	len--;

	GETSTRING(creds->service, p, len);
	GETSTRING(creds->instance, p, len);
	GETSTRING(creds->realm, p, len);
d116 5
a120 8
	GETSTRING(creds->pname, p, len);
	GETSTRING(creds->pinst, p, len);
	/* Ignore possibly different realm. */
	while (*p && len)
		p++, len--;
	if (len == 0)
		return 0;
	p++, len--;
d122 2
a123 3
	/* Enough space for remaining fixed-length parts? */
	if (len < (4 + 4 + sizeof(creds->session) + 2 + 4))
		return 0;
d125 3
a127 17
	GETLONG(creds->issue_date, p);
	len -= 4;
	{
		u_int endTime;
		GETLONG(endTime, p);
		len -= 4;
		creds->lifetime = krb_time_to_life(creds->issue_date, endTime);
	}

	memcpy(&creds->session, p, sizeof(creds->session));
	p += sizeof(creds->session);
	len -= sizeof(creds->session);

	GETSHORT(creds->kvno, p);
	len -= 2;
	GETLONG(creds->ticket_st.length, p);
	len -= 4;
d129 2
a130 3
	tl = creds->ticket_st.length;
	if (tl < 0 || tl > len || tl > sizeof(creds->ticket_st.dat))
		return 0;
d132 1
a132 3
	memcpy(creds->ticket_st.dat, p, tl);
	p += tl;
	len -= tl;
d134 21
a154 1
	return 1;
@


1.17.2.1
log
@Update to OpenSSH-3.2.2
@
text
@a2 1
 * Copyright (c) 2002 Markus Friedl.  All rights reserved.
d28 1
a28 1
RCSID("$OpenBSD: radix.c,v 1.20 2002/04/23 12:58:26 markus Exp $");
a33 1
#include "bufaux.h"
d35 31
a65 5
int
creds_to_radix(CREDENTIALS *creds, u_char *buf, size_t buflen)
{
	Buffer b;
	int ret;
d67 9
a75 1
	buffer_init(&b);
d77 14
a90 1
	buffer_put_char(&b, 1);	/* version */
a91 10
	buffer_append(&b, creds->service, strlen(creds->service));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->instance, strlen(creds->instance));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->realm, strlen(creds->realm));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->pname, strlen(creds->pname));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->pinst, strlen(creds->pinst));
	buffer_put_char(&b, '\0');
d93 30
d124 19
a142 1
	buffer_put_char(&b, '\0');
d144 2
a145 30
	buffer_put_int(&b, creds->issue_date);
	buffer_put_int(&b, krb_life_to_time(creds->issue_date,
	    creds->lifetime));
	buffer_append(&b, creds->session, sizeof(creds->session));
	buffer_put_short(&b, creds->kvno);

	/* 32 bit size + data */
	buffer_put_string(&b, creds->ticket_st.dat, creds->ticket_st.length);

	ret = uuencode(buffer_ptr(&b), buffer_len(&b), (char *)buf, buflen);

	buffer_free(&b);
	return ret;
}

#define GETSTRING(b, t, tlen) \
	do { \
		int i, found = 0; \
		for (i = 0; i < tlen; i++) { \
			if (buffer_len(b) == 0) \
				goto done; \
			t[i] = buffer_get_char(b); \
			if (t[i] == '\0') { \
				found = 1; \
				break; \
			} \
		} \
		if (!found) \
			goto done; \
	} while(0)
a149 4
	Buffer b;
	char c, version, *space, *p;
	u_int endTime;
	int len, blen, ret;
d151 4
a154 2
	ret = 0;
	blen = strlen(buf);
d156 2
a157 2
	/* sanity check for size */
	if (blen > 8192)
d160 1
a160 2
	buffer_init(&b);
	space = buffer_append_space(&b, blen);
a162 1
	len = uudecode(buf, space, blen);
d164 8
a171 1
		goto done;
d173 8
a180 1
	version = buffer_get_char(&b);
d182 3
a184 5
	GETSTRING(&b, creds->service, sizeof creds->service);
	GETSTRING(&b, creds->instance, sizeof creds->instance);
	GETSTRING(&b, creds->realm, sizeof creds->realm);
	GETSTRING(&b, creds->pname, sizeof creds->pname);
	GETSTRING(&b, creds->pinst, sizeof creds->pinst);
d186 17
a202 2
	if (buffer_len(&b) == 0)
		goto done;
d204 3
a206 6
	/* Ignore possibly different realm. */
	while (buffer_len(&b) > 0 && (c = buffer_get_char(&b)) != '\0')
		;

	if (buffer_len(&b) == 0)
		goto done;
d208 3
a210 1
	creds->issue_date = buffer_get_int(&b);
d212 1
a212 21
	endTime = buffer_get_int(&b);
	creds->lifetime = krb_time_to_life(creds->issue_date, endTime);

	len = buffer_len(&b);
	if (len < sizeof(creds->session))
		goto done;
	memcpy(&creds->session, buffer_ptr(&b), sizeof(creds->session));
	buffer_consume(&b, sizeof(creds->session));

	creds->kvno = buffer_get_short(&b);

	p = buffer_get_string(&b, &len);
	if (len < 0 || len > sizeof(creds->ticket_st.dat))
		goto done;
	memcpy(&creds->ticket_st.dat, p, len);
	creds->ticket_st.length = len;
	
	ret = 1;
done:
	buffer_free(&b);
	return ret;
@


1.17.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.17.2.3
log
@Pull in OpenSSH-3.4
@
text
@d29 1
a29 1
RCSID("$OpenBSD: radix.c,v 1.21 2002/06/19 00:27:55 deraadt Exp $");
d151 1
a151 1

@


1.17.2.4
log
@Update to OpenSSH 3.5
@
text
@d29 1
a29 1
RCSID("$OpenBSD: radix.c,v 1.22 2002/09/09 14:54:15 markus Exp $");
d96 3
a98 4
	u_char *space;
	char c, version, *p;
	u_int endTime, len;
	int blen, ret;
@


1.16
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d28 1
a28 1
RCSID("$OpenBSD: radix.c,v 1.15 2001/01/16 23:58:09 deraadt Exp $");
d42 1
a42 1
	register my_u_char *t_cp = (my_u_char *)(cp); \
d50 1
a50 1
	register my_u_char *t_cp = (my_u_char *)(cp); \
d60 2
a61 2
	register my_u_short t_s = (my_u_short)(s); \
	register my_u_char *t_cp = (my_u_char *)(cp); \
d68 2
a69 2
	register my_u_int32_t t_l = (my_u_int32_t)(l); \
	register my_u_char *t_cp = (my_u_char *)(cp); \
d78 3
a80 3
    register char *p_targ = (p) + p_l;		\
    register char *s_c = (s);			\
    register char *p_c = (p);			\
@


1.16.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d28 1
a28 1
RCSID("$OpenBSD: radix.c,v 1.17 2001/11/19 19:02:16 mpech Exp $");
d42 1
a42 1
	my_u_char *t_cp = (my_u_char *)(cp); \
d50 1
a50 1
	my_u_char *t_cp = (my_u_char *)(cp); \
d60 2
a61 2
	my_u_short t_s = (my_u_short)(s); \
	my_u_char *t_cp = (my_u_char *)(cp); \
d68 2
a69 2
	my_u_int32_t t_l = (my_u_int32_t)(l); \
	my_u_char *t_cp = (my_u_char *)(cp); \
d78 3
a80 3
    char *p_targ = (p) + p_l;		\
    char *s_c = (s);			\
    char *p_c = (p);			\
@


1.16.2.2
log
@Pull in patches from current:
Fix buffer overflow in AFS/Kerberos token handling.
@
text
@a2 1
 * Copyright (c) 2002 Markus Friedl.  All rights reserved.
d28 1
a28 1
RCSID("$OpenBSD: radix.c,v 1.19 2002/04/22 06:15:47 markus Exp $");
a33 1
#include "bufaux.h"
d35 31
a65 5
int
creds_to_radix(CREDENTIALS *creds, u_char *buf, size_t buflen)
{
	Buffer b;
	int ret;
d67 9
a75 1
	buffer_init(&b);
d77 14
a90 1
	buffer_put_char(&b, 1);	/* version */
a91 10
	buffer_append(&b, creds->service, strlen(creds->service));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->instance, strlen(creds->instance));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->realm, strlen(creds->realm));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->pname, strlen(creds->pname));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->pinst, strlen(creds->pinst));
	buffer_put_char(&b, '\0');
d93 30
d124 19
a142 1
	buffer_put_char(&b, '\0');
d144 2
a145 31
	buffer_put_int(&b, creds->issue_date);
	buffer_put_int(&b, krb_life_to_time(creds->issue_date,
	    creds->lifetime));
	buffer_append(&b, creds->session, sizeof(creds->session));
	buffer_put_short(&b, creds->kvno);

	/* 32 bit size + data */
	buffer_put_string(&b, creds->ticket_st.dat,
	    sizeof(creds->ticket_st.length));

	ret = uuencode(buffer_ptr(&b), buffer_len(&b), (char *)buf, buflen);

	buffer_free(&b);
	return ret;
}

#define GETSTRING(b, t, tlen) \
	do { \
		int i, found = 0; \
		for (i = 0; i < tlen; i++) { \
			if (buffer_len(b) == 0) \
				goto done; \
			t[i] = buffer_get_char(b); \
			if (t[i] == '\0') { \
				found = 1; \
				break; \
			} \
		} \
		if (!found) \
			goto done; \
	} while(0)
a149 4
	Buffer b;
	char c, version, *space, *p;
	u_int endTime;
	int len, blen, ret;
d151 4
a154 2
	ret = 0;
	blen = strlen(buf);
d156 2
a157 2
	/* sanity check for size */
	if (blen > 8192)
d160 1
a160 2
	buffer_init(&b);
	space = buffer_append_space(&b, blen);
a162 1
	len = uudecode(buf, space, blen);
d164 8
a171 1
		goto done;
d173 8
a180 1
	version = buffer_get_char(&b);
d182 3
a184 5
	GETSTRING(&b, creds->service, sizeof creds->service);
	GETSTRING(&b, creds->instance, sizeof creds->instance);
	GETSTRING(&b, creds->realm, sizeof creds->realm);
	GETSTRING(&b, creds->pname, sizeof creds->pname);
	GETSTRING(&b, creds->pinst, sizeof creds->pinst);
d186 17
a202 2
	if (buffer_len(&b) == 0)
		goto done;
d204 3
a206 6
	/* Ignore possibly different realm. */
	while (buffer_len(&b) > 0 && (c = buffer_get_char(&b)) != '\0')
		;

	if (buffer_len(&b) == 0)
		goto done;
d208 3
a210 1
	creds->issue_date = buffer_get_int(&b);
d212 1
a212 21
	endTime = buffer_get_int(&b);
	creds->lifetime = krb_time_to_life(creds->issue_date, endTime);

	len = buffer_len(&b);
	if (len < sizeof(creds->session))
		goto done;
	memcpy(&creds->session, buffer_ptr(&b), sizeof(creds->session));
	buffer_consume(&b, sizeof(creds->session));

	creds->kvno = buffer_get_short(&b);

	p = buffer_get_string(&b, &len);
	if (len < 0 || len > sizeof(creds->ticket_st.dat))
		goto done;
	memcpy(&creds->ticket_st.dat, p, len);
	creds->ticket_st.length = len;
	
	ret = 1;
done:
	buffer_free(&b);
	return ret;
@


1.16.2.3
log
@Pull in patch from current:
- send complete ticket; semerad@@ss1000.ms.mff.cuni.cz
@
text
@d29 1
a29 1
RCSID("$OpenBSD: radix.c,v 1.16.2.2 2002/04/23 02:13:50 jason Exp $");
d68 2
a69 1
	buffer_put_string(&b, creds->ticket_st.dat, creds->ticket_st.length);
@


1.16.2.4
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d29 1
a29 1
RCSID("$OpenBSD: radix.c,v 1.16.2.3 2002/04/23 14:17:47 jason Exp $");
d151 1
a151 1

@


1.16.2.5
log
@Update to OpenSSH 3.5
@
text
@d29 1
a29 1
RCSID("$OpenBSD: radix.c,v 1.22 2002/09/09 14:54:15 markus Exp $");
d96 3
a98 4
	u_char *space;
	char c, version, *p;
	u_int endTime, len;
	int blen, ret;
@


1.15
log
@indent
@
text
@d28 1
a28 1
RCSID("$OpenBSD: radix.c,v 1.14 2000/12/19 23:17:57 markus Exp $");
d32 2
@


1.15.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d28 1
a28 1
RCSID("$OpenBSD: radix.c,v 1.16 2001/06/23 15:12:19 itojun Exp $");
a31 2

#include <radix.h>
@


1.15.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d28 1
a28 1
RCSID("$OpenBSD: radix.c,v 1.17 2001/11/19 19:02:16 mpech Exp $");
d42 1
a42 1
	my_u_char *t_cp = (my_u_char *)(cp); \
d50 1
a50 1
	my_u_char *t_cp = (my_u_char *)(cp); \
d60 2
a61 2
	my_u_short t_s = (my_u_short)(s); \
	my_u_char *t_cp = (my_u_char *)(cp); \
d68 2
a69 2
	my_u_int32_t t_l = (my_u_int32_t)(l); \
	my_u_char *t_cp = (my_u_char *)(cp); \
d78 3
a80 3
    char *p_targ = (p) + p_l;		\
    char *s_c = (s);			\
    char *p_c = (p);			\
@


1.15.2.3
log
@Errata #24 (markus@@)
Fix a buffer overflow in AFS/Kerberos token handling.
@
text
@a2 1
 * Copyright (c) 2002 Markus Friedl.  All rights reserved.
d28 1
a28 1
RCSID("$OpenBSD: radix.c,v 1.19 2002/04/22 06:15:47 markus Exp $");
a33 1
#include "bufaux.h"
d35 31
a65 5
int
creds_to_radix(CREDENTIALS *creds, u_char *buf, size_t buflen)
{
	Buffer b;
	int ret;
d67 9
a75 1
	buffer_init(&b);
d77 14
a90 1
	buffer_put_char(&b, 1);	/* version */
a91 10
	buffer_append(&b, creds->service, strlen(creds->service));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->instance, strlen(creds->instance));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->realm, strlen(creds->realm));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->pname, strlen(creds->pname));
	buffer_put_char(&b, '\0');
	buffer_append(&b, creds->pinst, strlen(creds->pinst));
	buffer_put_char(&b, '\0');
d93 30
d124 19
a142 1
	buffer_put_char(&b, '\0');
d144 2
a145 31
	buffer_put_int(&b, creds->issue_date);
	buffer_put_int(&b, krb_life_to_time(creds->issue_date,
	    creds->lifetime));
	buffer_append(&b, creds->session, sizeof(creds->session));
	buffer_put_short(&b, creds->kvno);

	/* 32 bit size + data */
	buffer_put_string(&b, creds->ticket_st.dat,
	    sizeof(creds->ticket_st.length));

	ret = uuencode(buffer_ptr(&b), buffer_len(&b), (char *)buf, buflen);

	buffer_free(&b);
	return ret;
}

#define GETSTRING(b, t, tlen) \
	do { \
		int i, found = 0; \
		for (i = 0; i < tlen; i++) { \
			if (buffer_len(b) == 0) \
				goto done; \
			t[i] = buffer_get_char(b); \
			if (t[i] == '\0') { \
				found = 1; \
				break; \
			} \
		} \
		if (!found) \
			goto done; \
	} while(0)
a149 4
	Buffer b;
	char c, version, *space, *p;
	u_int endTime;
	int len, blen, ret;
d151 4
a154 2
	ret = 0;
	blen = strlen(buf);
d156 2
a157 2
	/* sanity check for size */
	if (blen > 8192)
d160 1
a160 2
	buffer_init(&b);
	space = buffer_append_space(&b, blen);
a162 1
	len = uudecode(buf, space, blen);
d164 8
a171 1
		goto done;
d173 8
a180 1
	version = buffer_get_char(&b);
d182 3
a184 5
	GETSTRING(&b, creds->service, sizeof creds->service);
	GETSTRING(&b, creds->instance, sizeof creds->instance);
	GETSTRING(&b, creds->realm, sizeof creds->realm);
	GETSTRING(&b, creds->pname, sizeof creds->pname);
	GETSTRING(&b, creds->pinst, sizeof creds->pinst);
d186 17
a202 2
	if (buffer_len(&b) == 0)
		goto done;
d204 3
a206 6
	/* Ignore possibly different realm. */
	while (buffer_len(&b) > 0 && (c = buffer_get_char(&b)) != '\0')
		;

	if (buffer_len(&b) == 0)
		goto done;
d208 3
a210 1
	creds->issue_date = buffer_get_int(&b);
d212 1
a212 21
	endTime = buffer_get_int(&b);
	creds->lifetime = krb_time_to_life(creds->issue_date, endTime);

	len = buffer_len(&b);
	if (len < sizeof(creds->session))
		goto done;
	memcpy(&creds->session, buffer_ptr(&b), sizeof(creds->session));
	buffer_consume(&b, sizeof(creds->session));

	creds->kvno = buffer_get_short(&b);

	p = buffer_get_string(&b, &len);
	if (len < 0 || len > sizeof(creds->ticket_st.dat))
		goto done;
	memcpy(&creds->ticket_st.dat, p, len);
	creds->ticket_st.length = len;
	
	ret = 1;
done:
	buffer_free(&b);
	return ret;
@


1.15.2.4
log
@Errata #24, take 2 (markus):
send complete ticket
@
text
@d29 1
a29 1
RCSID("$OpenBSD: radix.c,v 1.20 2002/04/23 12:58:26 markus Exp $");
d68 2
a69 1
	buffer_put_string(&b, creds->ticket_st.dat, creds->ticket_st.length);
@


1.14
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: radix.c,v 1.13 2000/09/07 20:27:52 deraadt Exp $");
d40 1
a40 1
	register my_u_char *t_cp = (my_u_char*)(cp); \
d48 1
a48 1
	register my_u_char *t_cp = (my_u_char*)(cp); \
d59 1
a59 1
	register my_u_char *t_cp = (my_u_char*)(cp); \
d67 1
a67 1
	register my_u_char *t_cp = (my_u_char*)(cp); \
d76 3
a78 3
    register char* p_targ = (p) + p_l;		\
    register char* s_c = (s);			\
    register char* p_c = (p);			\
@


1.13
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: radix.c,v 1.12 2000/06/22 23:55:00 djm Exp $");
d33 3
a35 3
typedef unsigned char my_u_char;
typedef unsigned int my_u_int32_t;
typedef unsigned short my_u_short;
d92 1
a92 1
creds_to_radix(CREDENTIALS *creds, unsigned char *buf, size_t buflen)
d126 2
a127 2
		unsigned int endTime;
		endTime = (unsigned int) krb_life_to_time(creds->issue_date,
d142 1
a142 1
	return (uuencode((unsigned char *)temp, len, (char *)buf, buflen));
d154 1
a154 1
	len = uudecode(buf, (unsigned char *)temp, sizeof(temp));
d187 1
a187 1
		unsigned int endTime;
@


1.13.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d28 1
a28 1
RCSID("$OpenBSD: radix.c,v 1.15 2001/01/16 23:58:09 deraadt Exp $");
d33 3
a35 3
typedef u_char my_u_char;
typedef u_int my_u_int32_t;
typedef u_short my_u_short;
d40 1
a40 1
	register my_u_char *t_cp = (my_u_char *)(cp); \
d48 1
a48 1
	register my_u_char *t_cp = (my_u_char *)(cp); \
d59 1
a59 1
	register my_u_char *t_cp = (my_u_char *)(cp); \
d67 1
a67 1
	register my_u_char *t_cp = (my_u_char *)(cp); \
d76 3
a78 3
    register char *p_targ = (p) + p_l;		\
    register char *s_c = (s);			\
    register char *p_c = (p);			\
d92 1
a92 1
creds_to_radix(CREDENTIALS *creds, u_char *buf, size_t buflen)
d126 2
a127 2
		u_int endTime;
		endTime = (u_int) krb_life_to_time(creds->issue_date,
d142 1
a142 1
	return (uuencode((u_char *)temp, len, (char *)buf, buflen));
d154 1
a154 1
	len = uudecode(buf, (u_char *)temp, sizeof(temp));
d187 1
a187 1
		u_int endTime;
@


1.13.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.13.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.13.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.13.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: radix.c,v 1.16 2001/06/23 15:12:19 itojun Exp $");
a31 2

#include <radix.h>
@


1.13.2.6
log
@Merge OpenSSH 3.1.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: radix.c,v 1.17 2001/11/19 19:02:16 mpech Exp $");
d42 1
a42 1
	my_u_char *t_cp = (my_u_char *)(cp); \
d50 1
a50 1
	my_u_char *t_cp = (my_u_char *)(cp); \
d60 2
a61 2
	my_u_short t_s = (my_u_short)(s); \
	my_u_char *t_cp = (my_u_char *)(cp); \
d68 2
a69 2
	my_u_int32_t t_l = (my_u_int32_t)(l); \
	my_u_char *t_cp = (my_u_char *)(cp); \
d78 3
a80 3
    char *p_targ = (p) + p_l;		\
    char *s_c = (s);			\
    char *p_c = (p);			\
@


1.12
log
@Missing CVS idents; ok markus
@
text
@d2 1
a2 1
 *   radix.c
d4 19
a22 1
 *   Dug Song <dugsong@@UMICH.EDU>
d28 1
a28 1
RCSID("$OpenBSD$");
@


1.11
log
@remote trailing comments before calling __b64_pton
@
text
@d10 2
@


1.11.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@a9 2
RCSID("$OpenBSD: radix.c,v 1.12 2000/06/22 23:55:00 djm Exp $");

@


1.11.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 1
a2 1
 * Copyright (c) 1999 Dug Song.  All rights reserved.
d4 1
a4 19
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d10 1
a10 1
RCSID("$OpenBSD: radix.c,v 1.13 2000/09/07 20:27:52 deraadt Exp $");
@


1.11.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d28 1
a28 1
RCSID("$OpenBSD: radix.c,v 1.15 2001/01/16 23:58:09 deraadt Exp $");
d33 3
a35 3
typedef u_char my_u_char;
typedef u_int my_u_int32_t;
typedef u_short my_u_short;
d40 1
a40 1
	register my_u_char *t_cp = (my_u_char *)(cp); \
d48 1
a48 1
	register my_u_char *t_cp = (my_u_char *)(cp); \
d59 1
a59 1
	register my_u_char *t_cp = (my_u_char *)(cp); \
d67 1
a67 1
	register my_u_char *t_cp = (my_u_char *)(cp); \
d76 3
a78 3
    register char *p_targ = (p) + p_l;		\
    register char *s_c = (s);			\
    register char *p_c = (p);			\
d92 1
a92 1
creds_to_radix(CREDENTIALS *creds, u_char *buf, size_t buflen)
d126 2
a127 2
		u_int endTime;
		endTime = (u_int) krb_life_to_time(creds->issue_date,
d142 1
a142 1
	return (uuencode((u_char *)temp, len, (char *)buf, buflen));
d154 1
a154 1
	len = uudecode(buf, (u_char *)temp, sizeof(temp));
d187 1
a187 1
		u_int endTime;
@


1.11.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.10
log
@replace broken uuencode w/ libc b64_ntop
@
text
@d134 2
a135 1
	if (!(len = uudecode(buf, (unsigned char *)temp, sizeof(temp))))
@


1.9
log
@add DSA pubkey auth and other SSH2 fixes.  use ssh-keygen -[xX]
for trading keys with the real and the original SSH, directly from the
people who invented the SSH protocol.
@
text
@d72 1
a72 1
creds_to_radix(CREDENTIALS *creds, unsigned char *buf)
d122 1
a122 1
	return (uuencode((unsigned char *)temp, len, (char *)buf));
@


1.8
log
@whitespace cleanup
@
text
@a3 4
 *   base-64 encoding pinched from lynx2-7-2, who pinched it from rpem.
 *   Originally written by Mark Riordan 12 August 1990 and 17 Feb 1991
 *   and placed in the public domain.
 *
d8 1
a11 91

char six2pr[64] = {
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
	'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
	'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
	'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
};

unsigned char pr2six[256];

int
uuencode(unsigned char *bufin, unsigned int nbytes, char *bufcoded)
{
	/* ENC is the basic 1 character encoding function to make a char printing */
#define ENC(c) six2pr[c]

	register char *outptr = bufcoded;
	unsigned int i;

	for (i = 0; i < nbytes; i += 3) {
		*(outptr++) = ENC(*bufin >> 2);						/* c1 */
		*(outptr++) = ENC(((*bufin << 4) & 060)   | ((bufin[1] >> 4) & 017));	/* c2 */
		*(outptr++) = ENC(((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03));	/* c3 */
		*(outptr++) = ENC(bufin[2] & 077);					/* c4 */
		bufin += 3;
	}
	if (i == nbytes + 1) {
		outptr[-1] = '=';
	} else if (i == nbytes + 2) {
		outptr[-1] = '=';
		outptr[-2] = '=';
	}
	*outptr = '\0';
	return (outptr - bufcoded);
}

int
uudecode(const char *bufcoded, unsigned char *bufplain, int outbufsize)
{
	/* single character decode */
#define DEC(c) pr2six[(unsigned char)c]
#define MAXVAL 63

	static int first = 1;
	int nbytesdecoded, j;
	const char *bufin = bufcoded;
	register unsigned char *bufout = bufplain;
	register int nprbytes;

	/* If this is the first call, initialize the mapping table. */
	if (first) {
		first = 0;
		for (j = 0; j < 256; j++)
			pr2six[j] = MAXVAL + 1;
		for (j = 0; j < 64; j++)
			pr2six[(unsigned char) six2pr[j]] = (unsigned char) j;
	}
	/* Strip leading whitespace. */
	while (*bufcoded == ' ' || *bufcoded == '\t')
		bufcoded++;

	/*
	 * Figure out how many characters are in the input buffer. If this
	 * would decode into more bytes than would fit into the output
	 * buffer, adjust the number of input bytes downwards.
	 */
	bufin = bufcoded;
	while (DEC(*(bufin++)) <= MAXVAL);
	nprbytes = bufin - bufcoded - 1;
	nbytesdecoded = ((nprbytes + 3) / 4) * 3;
	if (nbytesdecoded > outbufsize)
		nprbytes = (outbufsize * 4) / 3;

	bufin = bufcoded;

	while (nprbytes > 0) {
		*(bufout++) = (unsigned char) (DEC(*bufin)   << 2 | DEC(bufin[1]) >> 4);
		*(bufout++) = (unsigned char) (DEC(bufin[1]) << 4 | DEC(bufin[2]) >> 2);
		*(bufout++) = (unsigned char) (DEC(bufin[2]) << 6 | DEC(bufin[3]));
		bufin += 4;
		nprbytes -= 4;
	}
	if (nprbytes & 03) {
		if (DEC(bufin[-2]) > MAXVAL)
			nbytesdecoded -= 2;
		else
			nbytesdecoded -= 1;
	}
	return (nbytesdecoded);
}
@


1.7
log
@-pedantic: signed vs. unsigned, void*-arithm, etc
@
text
@d3 1
a3 1
 * 
d7 1
a7 1
 * 
d26 1
a26 1
int 
d52 1
a52 1
int 
d165 1
a165 1
int 
d219 1
a219 1
int 
@


1.6
log
@KNF, final part 3
@
text
@d216 1
a216 1
	return (uuencode(temp, len, buf));
d228 1
a228 1
	if (!(len = uudecode(buf, temp, sizeof(temp))))
@


1.5
log
@much more KNF
@
text
@d77 5
a81 3
	/* Figure out how many characters are in the input buffer. If this
	   would decode into more bytes than would fit into the output
	   buffer, adjust the number of input bytes downwards. */
@


1.4
log
@KNF part 1
@
text
@d2 8
a9 8
  radix.c

  base-64 encoding pinched from lynx2-7-2, who pinched it from rpem.
  Originally written by Mark Riordan 12 August 1990 and 17 Feb 1991
  and placed in the public domain.

  Dug Song <dugsong@@UMICH.EDU>
*/
@


1.3
log
@s/long/int/
@
text
@d10 1
a10 1
  
d17 5
a21 5
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
d26 2
a27 1
int uuencode(unsigned char *bufin, unsigned int nbytes, char *bufcoded)
d29 1
a29 1
  /* ENC is the basic 1 character encoding function to make a char printing */
d31 19
a49 19
  
  register char *outptr = bufcoded;
  unsigned int i;
  
  for (i=0; i<nbytes; i += 3) {
    *(outptr++) = ENC(*bufin >> 2);            /* c1 */
    *(outptr++) = ENC(((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)); /*c2*/
    *(outptr++) = ENC(((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03));/*c3*/
    *(outptr++) = ENC(bufin[2] & 077);         /* c4 */
    bufin += 3;
  }
  if (i == nbytes+1) {
    outptr[-1] = '=';
  } else if (i == nbytes+2) {
    outptr[-1] = '=';
    outptr[-2] = '=';
  }
  *outptr = '\0';
  return(outptr - bufcoded);
d52 2
a53 1
int uudecode(const char *bufcoded, unsigned char *bufplain, int outbufsize)
d55 1
a55 1
  /* single character decode */
d58 45
a102 43
  
  static int first = 1;
  int nbytesdecoded, j;
  const char *bufin = bufcoded;
  register unsigned char *bufout = bufplain;
  register int nprbytes;
  
  /* If this is the first call, initialize the mapping table. */
  if (first) {
    first = 0;
    for(j=0; j<256; j++) pr2six[j] = MAXVAL+1;
    for(j=0; j<64; j++) pr2six[(unsigned char)six2pr[j]] = (unsigned char)j;
  }
  
  /* Strip leading whitespace. */
  while (*bufcoded==' ' || *bufcoded == '\t') bufcoded++;
  
  /* Figure out how many characters are in the input buffer.
     If this would decode into more bytes than would fit into
     the output buffer, adjust the number of input bytes downwards. */
  bufin = bufcoded;
  while (DEC(*(bufin++)) <= MAXVAL);
  nprbytes = bufin - bufcoded - 1;
  nbytesdecoded = ((nprbytes+3)/4) * 3;
  if (nbytesdecoded > outbufsize)
    nprbytes = (outbufsize*4)/3;
  
  bufin = bufcoded;
  
  while (nprbytes > 0) {
    *(bufout++) = (unsigned char) (DEC(*bufin) << 2 | DEC(bufin[1]) >> 4);
    *(bufout++) = (unsigned char) (DEC(bufin[1]) << 4 | DEC(bufin[2]) >> 2);
    *(bufout++) = (unsigned char) (DEC(bufin[2]) << 6 | DEC(bufin[3]));
    bufin += 4;
    nprbytes -= 4;
  }
  if (nprbytes & 03) {
    if (DEC(bufin[-2]) > MAXVAL)
      nbytesdecoded -= 2;
    else 
      nbytesdecoded -= 1;
  }
  return(nbytesdecoded);
d163 2
a164 1
int creds_to_radix(CREDENTIALS *creds, unsigned char *buf)
d166 47
a212 32
  char *p, *s;
  int len;
  char temp[2048];
  
  p = temp;
  *p++ = 1; /* version */
  s = creds->service;	while (*s) *p++ = *s++; *p++ = *s;
  s = creds->instance;	while (*s) *p++ = *s++; *p++ = *s;
  s = creds->realm;	while (*s) *p++ = *s++; *p++ = *s;

  s = creds->pname;	while (*s) *p++ = *s++;   *p++ = *s;
  s = creds->pinst;	while (*s) *p++ = *s++;   *p++ = *s;
  /* Null string to repeat the realm. */
  *p++ = '\0';

  PUTLONG(creds->issue_date,p);
  {
    unsigned int	endTime ;
    endTime = (unsigned int)krb_life_to_time(creds->issue_date,
					      creds->lifetime);
    PUTLONG(endTime,p);
  }

  memcpy(p,&creds->session, sizeof(creds->session));
  p += sizeof(creds->session);
  
  PUTSHORT(creds->kvno,p);
  PUTLONG(creds->ticket_st.length,p);
  
  memcpy(p,creds->ticket_st.dat, creds->ticket_st.length);
  p += creds->ticket_st.length;
  len = p - temp;
d214 1
a214 1
  return(uuencode(temp, len, buf));
d217 2
a218 1
int radix_to_creds(const char *buf, CREDENTIALS *creds)
d221 61
a281 56
  char *p;
  int len, tl;
  char version;
  char temp[2048];
  
  if (!(len = uudecode(buf, temp, sizeof(temp))))
    return 0;
  
  p = temp;

  /* check version and length! */
  if (len < 1) return 0;
  version = *p; p++; len--;

  GETSTRING(creds->service, p, len);
  GETSTRING(creds->instance, p, len);
  GETSTRING(creds->realm, p, len);
  
  GETSTRING(creds->pname, p, len);
  GETSTRING(creds->pinst, p, len);
  /* Ignore possibly different realm. */
  while (*p && len) p++, len--;
  if (len == 0) return 0;
  p++, len--;
  
  /* Enough space for remaining fixed-length parts? */
  if (len < (4 + 4 + sizeof(creds->session) + 2 + 4))
    return 0;
  
  GETLONG(creds->issue_date,p);
  len -= 4;
  {
    unsigned int	endTime;
    GETLONG(endTime,p);
    len -= 4;
    creds->lifetime = krb_time_to_life(creds->issue_date, endTime);
  }

  memcpy(&creds->session, p, sizeof(creds->session));
  p += sizeof(creds->session);
  len -= sizeof(creds->session);
  
  GETSHORT(creds->kvno,p);
  len -= 2;
  GETLONG(creds->ticket_st.length,p);
  len -= 4;

  tl = creds->ticket_st.length;
  if (tl < 0 || tl > len || tl > sizeof(creds->ticket_st.dat))
    return 0;
  
  memcpy(creds->ticket_st.dat, p, tl);
  p += tl;
  len -= tl;
  
  return 1;
a282 1

@


1.2
log
@update krb4/AFS support to ssh-1.2.27-afs-kerberos-pl1 level, clean up unused variables, update manpages
@
text
@d178 2
a179 2
    unsigned long	endTime ;
    endTime = (unsigned long)krb_life_to_time(creds->issue_date,
d232 1
a232 1
    unsigned long	endTime;
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d8 1
a8 1
  dugsong@@UMICH.EDU
a14 1
#include <kafs.h>
d54 1
a54 1
#define DEC(c) pr2six[c]
d77 1
a77 1
  while (pr2six[(unsigned char)*(bufin++)] <= MAXVAL);
d93 1
a93 1
    if (pr2six[bufin[-2]] > MAXVAL)
@

