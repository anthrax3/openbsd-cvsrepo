head	1.37;
access;
symbols
	OPENBSD_4_6:1.36.0.14
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.10
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.8
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.6
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.4
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.35.0.4
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.29.0.8
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.6
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.4
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.28.0.4
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.26.0.4
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.14.0.4
	OPENBSD_2_8:1.14.0.2;
locks; strict;
comment	@ * @;


1.37
date	2010.02.08.12.48.38;	author markus;	state dead;
branches;
next	1.36;

1.36
date	2006.11.06.21.25.28;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.35.4.1;
next	1.34;

1.34
date	2006.08.01.23.36.12;	author stevesk;	state Exp;
branches;
next	1.33;

1.33
date	2006.07.25.02.01.34;	author stevesk;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.08.00.21.31;	author djm;	state Exp;
branches
	1.29.6.1
	1.29.8.1;
next	1.28;

1.28
date	2003.06.12.19.12.02;	author markus;	state Exp;
branches
	1.28.2.1
	1.28.4.1;
next	1.27;

1.27
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.23.03.30.17;	author deraadt;	state Exp;
branches
	1.26.2.1
	1.26.4.1;
next	1.25;

1.25
date	2002.03.26.18.46.59;	author rees;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2002.03.25.17.34.27;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.24.18.05.29;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.21.21.54.34;	author rees;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.21.18.08.15;	author rees;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.21.16.57.15;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.21.16.54.53;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.21.16.38.06;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.27.18.22.16;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.28.09.49.31;	author djm;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.09.17.20.22.14;	author markus;	state Exp;
branches
	1.14.2.1
	1.14.4.1;
next	1.13;

1.13
date	2001.08.02.16.14.05;	author jakob;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.01.23.38.45;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.01.22.03.33;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.31.12.53.34;	author jakob;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.31.08.41.10;	author jakob;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.30.16.06.07;	author jakob;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.26.20.04.27;	author rees;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.25.11.59.35;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.04.23.13.09;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.02.22.40.17;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.26.20.14.10;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.26.06.32.59;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.26.05.33.34;	author markus;	state Exp;
branches;
next	;

1.14.2.1
date	2001.09.27.18.27.43;	author miod;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2001.11.15.00.14.59;	author miod;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.14.4.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.14.4.4;

1.14.4.4
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.15.2.1
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.06.26.18.22.35;	author miod;	state Exp;
branches;
next	;

1.25.2.1
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	;

1.26.2.1
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.26.4.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.26.4.2;

1.26.4.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.28.2.1
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.28.4.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	;

1.29.6.1
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	1.29.6.2;

1.29.6.2
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.29.8.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	1.29.8.2;

1.29.8.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.35.4.1
date	2006.11.08.00.42.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.37
log
@remove obsole scard code
@
text
@/* $OpenBSD: scard.c,v 1.36 2006/11/06 21:25:28 markus Exp $ */
/*
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifdef SMARTCARD

#include <sys/types.h>

#include <openssl/evp.h>

#include <sectok.h>
#include <string.h>

#include "xmalloc.h"
#include "key.h"
#include "log.h"
#include "misc.h"
#include "scard.h"

#if OPENSSL_VERSION_NUMBER < 0x00907000L
#define USE_ENGINE
#define RSA_get_default_method RSA_get_default_openssl_method
#else
#endif

#ifdef USE_ENGINE
#include <openssl/engine.h>
#define sc_get_rsa sc_get_engine
#else
#define sc_get_rsa sc_get_rsa_method
#endif

#define CLA_SSH 0x05
#define INS_DECRYPT 0x10
#define INS_GET_KEYLENGTH 0x20
#define INS_GET_PUBKEY 0x30
#define INS_GET_RESPONSE 0xc0

#define MAX_BUF_SIZE 256

u_char DEFAUT0[] = {0xad, 0x9f, 0x61, 0xfe, 0xfa, 0x20, 0xce, 0x63};

static int sc_fd = -1;
static char *sc_reader_id = NULL;
static char *sc_pin = NULL;
static int cla = 0x00;	/* class */

static void sc_mk_digest(const char *pin, u_char *digest);
static int get_AUT0(u_char *aut0);
static int try_AUT0(void);

/* interface to libsectok */

static int
sc_open(void)
{
	int sw;

	if (sc_fd >= 0)
		return sc_fd;

	sc_fd = sectok_friendly_open(sc_reader_id, STONOWAIT, &sw);
	if (sc_fd < 0) {
		error("sectok_open failed: %s", sectok_get_sw(sw));
		return SCARD_ERROR_FAIL;
	}
	if (! sectok_cardpresent(sc_fd)) {
		debug("smartcard in reader %s not present, skipping",
		    sc_reader_id);
		sc_close();
		return SCARD_ERROR_NOCARD;
	}
	if (sectok_reset(sc_fd, 0, NULL, &sw) <= 0) {
		error("sectok_reset failed: %s", sectok_get_sw(sw));
		sc_fd = -1;
		return SCARD_ERROR_FAIL;
	}
	if ((cla = cyberflex_inq_class(sc_fd)) < 0)
		cla = 0;

	debug("sc_open ok %d", sc_fd);
	return sc_fd;
}

static int
sc_enable_applet(void)
{
	static u_char aid[] = {0xfc, 0x53, 0x73, 0x68, 0x2e, 0x62, 0x69, 0x6e};
	int sw = 0;

	/* select applet id */
	sectok_apdu(sc_fd, cla, 0xa4, 0x04, 0, sizeof aid, aid, 0, NULL, &sw);
	if (!sectok_swOK(sw)) {
		error("sectok_apdu failed: %s", sectok_get_sw(sw));
		sc_close();
		return -1;
	}
	return 0;
}

static int
sc_init(void)
{
	int status;

	status = sc_open();
	if (status == SCARD_ERROR_NOCARD) {
		return SCARD_ERROR_NOCARD;
	}
	if (status < 0) {
		error("sc_open failed");
		return status;
	}
	if (sc_enable_applet() < 0) {
		error("sc_enable_applet failed");
		return SCARD_ERROR_APPLET;
	}
	return 0;
}

static int
sc_read_pubkey(Key * k)
{
	u_char buf[2], *n;
	char *p;
	int len, sw, status = -1;

	len = sw = 0;
	n = NULL;

	if (sc_fd < 0) {
		if (sc_init() < 0)
			goto err;
	}

	/* get key size */
	sectok_apdu(sc_fd, CLA_SSH, INS_GET_KEYLENGTH, 0, 0, 0, NULL,
	    sizeof(buf), buf, &sw);
	if (!sectok_swOK(sw)) {
		error("could not obtain key length: %s", sectok_get_sw(sw));
		goto err;
	}
	len = (buf[0] << 8) | buf[1];
	len /= 8;
	debug("INS_GET_KEYLENGTH: len %d sw %s", len, sectok_get_sw(sw));

	n = xmalloc(len);
	/* get n */
	sectok_apdu(sc_fd, CLA_SSH, INS_GET_PUBKEY, 0, 0, 0, NULL, len, n, &sw);

	if (sw == 0x6982) {
		if (try_AUT0() < 0)
			goto err;
		sectok_apdu(sc_fd, CLA_SSH, INS_GET_PUBKEY, 0, 0, 0, NULL, len, n, &sw);
	}
	if (!sectok_swOK(sw)) {
		error("could not obtain public key: %s", sectok_get_sw(sw));
		goto err;
	}

	debug("INS_GET_KEYLENGTH: sw %s", sectok_get_sw(sw));

	if (BN_bin2bn(n, len, k->rsa->n) == NULL) {
		error("c_read_pubkey: BN_bin2bn failed");
		goto err;
	}

	/* currently the java applet just stores 'n' */
	if (!BN_set_word(k->rsa->e, 35)) {
		error("c_read_pubkey: BN_set_word(e, 35) failed");
		goto err;
	}

	status = 0;
	p = key_fingerprint(k, SSH_FP_MD5, SSH_FP_HEX);
	debug("fingerprint %u %s", key_size(k), p);
	xfree(p);

err:
	if (n != NULL)
		xfree(n);
	sc_close();
	return status;
}

/* private key operations */

static int
sc_private_decrypt(int flen, u_char *from, u_char *to, RSA *rsa,
    int padding)
{
	u_char *padded = NULL;
	int sw, len, olen, status = -1;

	debug("sc_private_decrypt called");

	olen = len = sw = 0;
	if (sc_fd < 0) {
		status = sc_init();
		if (status < 0)
			goto err;
	}
	if (padding != RSA_PKCS1_PADDING)
		goto err;

	len = BN_num_bytes(rsa->n);
	padded = xmalloc(len);

	sectok_apdu(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, len, from, len, padded, &sw);

	if (sw == 0x6982) {
		if (try_AUT0() < 0)
			goto err;
		sectok_apdu(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, len, from, len, padded, &sw);
	}
	if (!sectok_swOK(sw)) {
		error("sc_private_decrypt: INS_DECRYPT failed: %s",
		    sectok_get_sw(sw));
		goto err;
	}
	olen = RSA_padding_check_PKCS1_type_2(to, len, padded + 1, len - 1,
	    len);
err:
	if (padded)
		xfree(padded);
	sc_close();
	return (olen >= 0 ? olen : status);
}

static int
sc_private_encrypt(int flen, u_char *from, u_char *to, RSA *rsa,
    int padding)
{
	u_char *padded = NULL;
	int sw, len, status = -1;

	len = sw = 0;
	if (sc_fd < 0) {
		status = sc_init();
		if (status < 0)
			goto err;
	}
	if (padding != RSA_PKCS1_PADDING)
		goto err;

	debug("sc_private_encrypt called");
	len = BN_num_bytes(rsa->n);
	padded = xmalloc(len);

	if (RSA_padding_add_PKCS1_type_1(padded, len, (u_char *)from, flen) <= 0) {
		error("RSA_padding_add_PKCS1_type_1 failed");
		goto err;
	}
	sectok_apdu(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, len, padded, len, to, &sw);
	if (sw == 0x6982) {
		if (try_AUT0() < 0)
			goto err;
		sectok_apdu(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, len, padded, len, to, &sw);
	}
	if (!sectok_swOK(sw)) {
		error("sc_private_encrypt: INS_DECRYPT failed: %s",
		    sectok_get_sw(sw));
		goto err;
	}
err:
	if (padded)
		xfree(padded);
	sc_close();
	return (len >= 0 ? len : status);
}

/* called on free */

static int (*orig_finish)(RSA *rsa) = NULL;

static int
sc_finish(RSA *rsa)
{
	if (orig_finish)
		orig_finish(rsa);
	sc_close();
	return 1;
}

/* engine for overloading private key operations */

static RSA_METHOD *
sc_get_rsa_method(void)
{
	static RSA_METHOD smart_rsa;
	const RSA_METHOD *def = RSA_get_default_method();

	/* use the OpenSSL version */
	memcpy(&smart_rsa, def, sizeof(smart_rsa));

	smart_rsa.name		= "sectok";

	/* overload */
	smart_rsa.rsa_priv_enc	= sc_private_encrypt;
	smart_rsa.rsa_priv_dec	= sc_private_decrypt;

	/* save original */
	orig_finish		= def->finish;
	smart_rsa.finish	= sc_finish;

	return &smart_rsa;
}

#ifdef USE_ENGINE
static ENGINE *
sc_get_engine(void)
{
	static ENGINE *smart_engine = NULL;

	if ((smart_engine = ENGINE_new()) == NULL)
		fatal("ENGINE_new failed");

	ENGINE_set_id(smart_engine, "sectok");
	ENGINE_set_name(smart_engine, "libsectok");

	ENGINE_set_RSA(smart_engine, sc_get_rsa_method());
	ENGINE_set_DSA(smart_engine, DSA_get_default_openssl_method());
	ENGINE_set_DH(smart_engine, DH_get_default_openssl_method());
	ENGINE_set_RAND(smart_engine, RAND_SSLeay());
	ENGINE_set_BN_mod_exp(smart_engine, BN_mod_exp);

	return smart_engine;
}
#endif

void
sc_close(void)
{
	if (sc_fd >= 0) {
		sectok_close(sc_fd);
		sc_fd = -1;
	}
}

Key **
sc_get_keys(const char *id, const char *pin)
{
	Key *k, *n, **keys;
	int status, nkeys = 2;

	if (sc_reader_id != NULL)
		xfree(sc_reader_id);
	sc_reader_id = xstrdup(id);

	if (sc_pin != NULL)
		xfree(sc_pin);
	sc_pin = (pin == NULL) ? NULL : xstrdup(pin);

	k = key_new(KEY_RSA);
	if (k == NULL) {
		return NULL;
	}
	status = sc_read_pubkey(k);
	if (status == SCARD_ERROR_NOCARD) {
		key_free(k);
		return NULL;
	}
	if (status < 0) {
		error("sc_read_pubkey failed");
		key_free(k);
		return NULL;
	}
	keys = xcalloc((nkeys+1), sizeof(Key *));

	n = key_new(KEY_RSA1);
	if ((BN_copy(n->rsa->n, k->rsa->n) == NULL) ||
	    (BN_copy(n->rsa->e, k->rsa->e) == NULL))
		fatal("sc_get_keys: BN_copy failed");
	RSA_set_method(n->rsa, sc_get_rsa());
	n->flags |= KEY_FLAG_EXT;
	keys[0] = n;

	n = key_new(KEY_RSA);
	if ((BN_copy(n->rsa->n, k->rsa->n) == NULL) ||
	    (BN_copy(n->rsa->e, k->rsa->e) == NULL))
		fatal("sc_get_keys: BN_copy failed");
	RSA_set_method(n->rsa, sc_get_rsa());
	n->flags |= KEY_FLAG_EXT;
	keys[1] = n;

	keys[2] = NULL;

	key_free(k);
	return keys;
}

#define NUM_RSA_KEY_ELEMENTS 5+1
#define COPY_RSA_KEY(x, i) \
	do { \
		len = BN_num_bytes(prv->rsa->x); \
		elements[i] = xmalloc(len); \
		debug("#bytes %d", len); \
		if (BN_bn2bin(prv->rsa->x, elements[i]) < 0) \
			goto done; \
	} while (0)

static void
sc_mk_digest(const char *pin, u_char *digest)
{
	const EVP_MD *evp_md = EVP_sha1();
	EVP_MD_CTX md;

	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, pin, strlen(pin));
	EVP_DigestFinal(&md, digest, NULL);
}

static int
get_AUT0(u_char *aut0)
{
	char *pass;

	pass = read_passphrase("Enter passphrase for smartcard: ", RP_ALLOW_STDIN);
	if (pass == NULL)
		return -1;
	if (!strcmp(pass, "-")) {
		memcpy(aut0, DEFAUT0, sizeof DEFAUT0);
		return 0;
	}
	sc_mk_digest(pass, aut0);
	memset(pass, 0, strlen(pass));
	xfree(pass);
	return 0;
}

static int
try_AUT0(void)
{
	u_char aut0[EVP_MAX_MD_SIZE];

	/* permission denied; try PIN if provided */
	if (sc_pin && strlen(sc_pin) > 0) {
		sc_mk_digest(sc_pin, aut0);
		if (cyberflex_verify_AUT0(sc_fd, cla, aut0, 8) < 0) {
			error("smartcard passphrase incorrect");
			return (-1);
		}
	} else {
		/* try default AUT0 key */
		if (cyberflex_verify_AUT0(sc_fd, cla, DEFAUT0, 8) < 0) {
			/* default AUT0 key failed; prompt for passphrase */
			if (get_AUT0(aut0) < 0 ||
			    cyberflex_verify_AUT0(sc_fd, cla, aut0, 8) < 0) {
				error("smartcard passphrase incorrect");
				return (-1);
			}
		}
	}
	return (0);
}

int
sc_put_key(Key *prv, const char *id)
{
	u_char *elements[NUM_RSA_KEY_ELEMENTS];
	u_char key_fid[2];
	u_char AUT0[EVP_MAX_MD_SIZE];
	int len, status = -1, i, fd = -1, ret;
	int sw = 0, cla = 0x00;

	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++)
		elements[i] = NULL;

	COPY_RSA_KEY(q, 0);
	COPY_RSA_KEY(p, 1);
	COPY_RSA_KEY(iqmp, 2);
	COPY_RSA_KEY(dmq1, 3);
	COPY_RSA_KEY(dmp1, 4);
	COPY_RSA_KEY(n, 5);
	len = BN_num_bytes(prv->rsa->n);
	fd = sectok_friendly_open(id, STONOWAIT, &sw);
	if (fd < 0) {
		error("sectok_open failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (! sectok_cardpresent(fd)) {
		error("smartcard in reader %s not present", id);
		goto done;
	}
	ret = sectok_reset(fd, 0, NULL, &sw);
	if (ret <= 0) {
		error("sectok_reset failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if ((cla = cyberflex_inq_class(fd)) < 0) {
		error("cyberflex_inq_class failed");
		goto done;
	}
	memcpy(AUT0, DEFAUT0, sizeof(DEFAUT0));
	if (cyberflex_verify_AUT0(fd, cla, AUT0, sizeof(DEFAUT0)) < 0) {
		if (get_AUT0(AUT0) < 0 ||
		    cyberflex_verify_AUT0(fd, cla, AUT0, sizeof(DEFAUT0)) < 0) {
			memset(AUT0, 0, sizeof(DEFAUT0));
			error("smartcard passphrase incorrect");
			goto done;
		}
	}
	memset(AUT0, 0, sizeof(DEFAUT0));
	key_fid[0] = 0x00;
	key_fid[1] = 0x12;
	if (cyberflex_load_rsa_priv(fd, cla, key_fid, 5, 8*len, elements,
	    &sw) < 0) {
		error("cyberflex_load_rsa_priv failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (!sectok_swOK(sw))
		goto done;
	logit("cyberflex_load_rsa_priv done");
	key_fid[0] = 0x73;
	key_fid[1] = 0x68;
	if (cyberflex_load_rsa_pub(fd, cla, key_fid, len, elements[5],
	    &sw) < 0) {
		error("cyberflex_load_rsa_pub failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (!sectok_swOK(sw))
		goto done;
	logit("cyberflex_load_rsa_pub done");
	status = 0;

done:
	memset(elements[0], '\0', BN_num_bytes(prv->rsa->q));
	memset(elements[1], '\0', BN_num_bytes(prv->rsa->p));
	memset(elements[2], '\0', BN_num_bytes(prv->rsa->iqmp));
	memset(elements[3], '\0', BN_num_bytes(prv->rsa->dmq1));
	memset(elements[4], '\0', BN_num_bytes(prv->rsa->dmp1));
	memset(elements[5], '\0', BN_num_bytes(prv->rsa->n));

	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++)
		if (elements[i])
			xfree(elements[i]);
	if (fd != -1)
		sectok_close(fd);
	return (status);
}

char *
sc_get_key_label(Key *key)
{
	return xstrdup("smartcard key");
}

#endif /* SMARTCARD */
@


1.36
log
@add missing checks for openssl return codes; with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: scard.c,v 1.35 2006/08/03 03:34:42 deraadt Exp $ */
@


1.35
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: scard.c,v 1.34 2006/08/01 23:36:12 stevesk Exp $ */
d392 3
a394 2
	BN_copy(n->rsa->n, k->rsa->n);
	BN_copy(n->rsa->e, k->rsa->e);
d400 3
a402 2
	BN_copy(n->rsa->n, k->rsa->n);
	BN_copy(n->rsa->e, k->rsa->e);
@


1.35.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: scard.c,v 1.36 2006/11/06 21:25:28 markus Exp $ */
d392 2
a393 3
	if ((BN_copy(n->rsa->n, k->rsa->n) == NULL) ||
	    (BN_copy(n->rsa->e, k->rsa->e) == NULL))
		fatal("sc_get_keys: BN_copy failed");
d399 2
a400 3
	if ((BN_copy(n->rsa->n, k->rsa->n) == NULL) ||
	    (BN_copy(n->rsa->e, k->rsa->e) == NULL))
		fatal("sc_get_keys: BN_copy failed");
@


1.34
log
@clean extra spaces
@
text
@d1 1
a1 1
/* $OpenBSD: scard.c,v 1.33 2006/07/25 02:01:34 stevesk Exp $ */
d27 2
a28 1
#include "includes.h"
d35 1
a37 1
#include "xmalloc.h"
@


1.33
log
@need #include <string.h>
@
text
@d1 1
a1 1
/* $OpenBSD: scard.c,v 1.32 2006/03/25 13:17:02 djm Exp $ */
d130 1
a130 1
	if (status < 0 ) {
d220 1
a220 1
		if (status < 0 )
d260 1
a260 1
		if (status < 0 )
d383 1
a383 1
	if (status < 0 ) {
@


1.32
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d30 1
d32 1
@


1.31
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.30
log
@RCSID() can die
@
text
@d385 1
a385 1
	keys = xmalloc((nkeys+1) * sizeof(Key *));
@


1.29
log
@kill a tiny header; ok deraadt@@
@
text
@a26 1
RCSID("$OpenBSD: scard.c,v 1.28 2003/06/12 19:12:02 markus Exp $");
@


1.29.6.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: scard.c,v 1.35 2006/08/03 03:34:42 deraadt Exp $ */
d26 2
a27 2

#include <sys/types.h>
a29 1

a30 1
#include <string.h>
a31 1
#include "xmalloc.h"
d34 1
d128 1
a128 1
	if (status < 0) {
d218 1
a218 1
		if (status < 0)
d258 1
a258 1
		if (status < 0)
d381 1
a381 1
	if (status < 0) {
d386 1
a386 1
	keys = xcalloc((nkeys+1), sizeof(Key *));
@


1.29.6.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: scard.c,v 1.36 2006/11/06 21:25:28 markus Exp $ */
d392 2
a393 3
	if ((BN_copy(n->rsa->n, k->rsa->n) == NULL) ||
	    (BN_copy(n->rsa->e, k->rsa->e) == NULL))
		fatal("sc_get_keys: BN_copy failed");
d399 2
a400 3
	if ((BN_copy(n->rsa->n, k->rsa->n) == NULL) ||
	    (BN_copy(n->rsa->e, k->rsa->e) == NULL))
		fatal("sc_get_keys: BN_copy failed");
@


1.29.8.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: scard.c,v 1.35 2006/08/03 03:34:42 deraadt Exp $ */
d26 2
a27 2

#include <sys/types.h>
a29 1

a30 1
#include <string.h>
a31 1
#include "xmalloc.h"
d34 1
d128 1
a128 1
	if (status < 0) {
d218 1
a218 1
		if (status < 0)
d258 1
a258 1
		if (status < 0)
d381 1
a381 1
	if (status < 0) {
d386 1
a386 1
	keys = xcalloc((nkeys+1), sizeof(Key *));
@


1.29.8.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: scard.c,v 1.36 2006/11/06 21:25:28 markus Exp $ */
d392 2
a393 3
	if ((BN_copy(n->rsa->n, k->rsa->n) == NULL) ||
	    (BN_copy(n->rsa->e, k->rsa->e) == NULL))
		fatal("sc_get_keys: BN_copy failed");
d399 2
a400 3
	if ((BN_copy(n->rsa->n, k->rsa->n) == NULL) ||
	    (BN_copy(n->rsa->e, k->rsa->e) == NULL))
		fatal("sc_get_keys: BN_copy failed");
@


1.28
log
@add sc_get_key_label; larsch at trustcenter.de; bugzilla#591
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.27 2003/04/08 20:21:29 itojun Exp $");
d35 1
a35 1
#include "readpass.h"
@


1.28.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.29 2004/05/08 00:21:31 djm Exp $");
d35 1
a35 1
#include "misc.h"
@


1.28.4.1
log
@upgrade to OpenSSH 3.9
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.29 2004/05/08 00:21:31 djm Exp $");
d35 1
a35 1
#include "misc.h"
@


1.27
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.26 2002/06/23 03:30:17 deraadt Exp $");
d557 7
@


1.26
log
@various KNF and %d for unsigned
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.25 2002/03/26 18:46:59 rees Exp $");
d529 1
a529 1
	log("cyberflex_load_rsa_priv done");
d539 1
a539 1
	log("cyberflex_load_rsa_pub done");
@


1.26.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.28 2003/06/12 19:12:02 markus Exp $");
d529 1
a529 1
	logit("cyberflex_load_rsa_priv done");
d539 1
a539 1
	logit("cyberflex_load_rsa_pub done");
a556 7

char *
sc_get_key_label(Key *key)
{
	return xstrdup("smartcard key");
}

@


1.26.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.28 2003/06/12 19:12:02 markus Exp $");
d529 1
a529 1
	logit("cyberflex_load_rsa_priv done");
d539 1
a539 1
	logit("cyberflex_load_rsa_pub done");
a556 7

char *
sc_get_key_label(Key *key)
{
	return xstrdup("smartcard key");
}

@


1.26.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@@


1.25
log
@try_AUT0 in read_pubkey too, for those paranoid few who want to acl 'sh'
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.24 2002/03/25 17:34:27 markus Exp $");
d194 1
a194 1
	debug("fingerprint %d %s", key_size(k), p);
@


1.25.2.1
log
@Pull in OpenSSH-3.4
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.26 2002/06/23 03:30:17 deraadt Exp $");
d194 1
a194 1
	debug("fingerprint %u %s", key_size(k), p);
@


1.24
log
@change sc_get_key to sc_get_keys and hide smartcard details in scard.c
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.23 2002/03/24 18:05:29 markus Exp $");
d68 1
d168 6
a203 26
static int
try_AUT0(void)
{
	u_char aut0[EVP_MAX_MD_SIZE];

	/* permission denied; try PIN if provided */
	if (sc_pin && strlen(sc_pin) > 0) {
		sc_mk_digest(sc_pin, aut0);
		if (cyberflex_verify_AUT0(sc_fd, cla, aut0, 8) < 0) {
			error("smartcard passphrase incorrect");
			return (-1);
		}
	} else {
		/* try default AUT0 key */
		if (cyberflex_verify_AUT0(sc_fd, cla, DEFAUT0, 8) < 0) {
			/* default AUT0 key failed; prompt for passphrase */
			if (get_AUT0(aut0) < 0 ||
			    cyberflex_verify_AUT0(sc_fd, cla, aut0, 8) < 0) {
				error("smartcard passphrase incorrect");
				return (-1);
			}
		}
	}
	return (0);
}

d445 26
@


1.23
log
@we need to figure out AUT0 for sc_private_encrypt, too
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.22 2002/03/21 21:54:34 rees Exp $");
a28 1
#include <openssl/engine.h>
d38 4
a41 6
#ifdef OPENSSL_VERSION_NUMBER
#if OPENSSL_VERSION_NUMBER >= 0x00907000L
#define RSA_get_default_openssl_method RSA_get_default_method
#define DSA_get_default_openssl_method DSA_get_default_method
#define DH_get_default_openssl_method DH_get_default_method
#define ENGINE_set_BN_mod_exp(x,y)
d43 6
d149 1
a149 2
		status = sc_init();
		if (status < 0 )
a321 1

d324 2
a325 5
static ENGINE *smart_engine = NULL;
static RSA_METHOD smart_rsa;

ENGINE *
sc_get_engine(void)
d327 2
a328 3
	const RSA_METHOD *def;

	def = RSA_get_default_openssl_method();
d343 9
d358 1
a358 1
	ENGINE_set_RSA(smart_engine, &smart_rsa);
d366 1
d377 2
a378 2
Key *
sc_get_key(const char *id, const char *pin)
d380 2
a381 2
	Key *k;
	int status;
d405 20
a424 1
	return k;
@


1.22
log
@Add PIN-protection for secret key.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.21 2002/03/21 18:08:15 rees Exp $");
d195 26
a227 1
	u_char aut0[EVP_MAX_MD_SIZE];
d247 2
a248 18
		/* permission denied; try PIN if provided */
		if (sc_pin && strlen(sc_pin) > 0) {
			sc_mk_digest(sc_pin, aut0);
			if (cyberflex_verify_AUT0(sc_fd, cla, aut0, 8) < 0) {
				error("smartcard passphrase incorrect");
				goto err;
			}
		} else {
			/* try default AUT0 key */
			if (cyberflex_verify_AUT0(sc_fd, cla, DEFAUT0, 8) < 0) {
				/* default AUT0 key failed; prompt for passphrase */
				if (get_AUT0(aut0) < 0 ||
				    cyberflex_verify_AUT0(sc_fd, cla, aut0, 8) < 0) {
					error("smartcard passphrase incorrect");
					goto err;
				}
			}
		}
d290 5
d296 1
a296 1
		error("sc_private_decrypt: INS_DECRYPT failed: %s",
@


1.21
log
@In sc_put_key(), sc_reader_id should be id.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.20 2002/03/21 16:57:15 markus Exp $");
d36 1
a37 1
#include "readpass.h"
d56 2
d60 1
d63 3
d202 1
d219 23
a241 2
	sectok_apdu(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, len, (u_char *)from,
	    0, NULL, &sw);
a246 7
	sectok_apdu(sc_fd, CLA_SSH, INS_GET_RESPONSE, 0, 0, 0, NULL,
	    len, padded, &sw);
	if (!sectok_swOK(sw)) {
		error("sc_private_decrypt: INS_GET_RESPONSE failed: %s",
		    sectok_get_sw(sw));
		goto err;
	}
d280 1
a280 1
	sectok_apdu(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, len, padded, 0, NULL, &sw);
a285 7
	sectok_apdu(sc_fd, CLA_SSH, INS_GET_RESPONSE, 0, 0, 0, NULL,
	    len, to, &sw);
	if (!sectok_swOK(sw)) {
		error("sc_private_decrypt: INS_GET_RESPONSE failed: %s",
		    sectok_get_sw(sw));
		goto err;
	}
d357 1
a357 1
sc_get_key(const char *id)
d366 4
d397 2
a398 2
static int
get_AUT0(char *aut0)
d402 9
d416 5
a420 3
	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, pass, strlen(pass));
	EVP_DigestFinal(&md, aut0, NULL);
a430 1
	u_char DEFAUT0[] = {0xad, 0x9f, 0x61, 0xfe, 0xfa, 0x20, 0xce, 0x63};
d467 2
a468 1
			error("cyberflex_verify_AUT0 failed");
d472 1
@


1.20
log
@remove const
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.19 2002/03/21 16:54:53 markus Exp $");
d417 1
a417 1
	fd = sectok_friendly_open(sc_reader_id, STONOWAIT, &sw);
d423 1
a423 2
		error("smartcard in reader %s not present",
		    sc_reader_id);
@


1.19
log
@move key upload to scard.[ch]
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.18 2002/03/21 16:38:06 markus Exp $");
d192 1
a192 1
sc_private_decrypt(int flen, const u_char *from, u_char *to, RSA *rsa,
d236 1
a236 1
sc_private_encrypt(int flen, const u_char *from, u_char *to, RSA *rsa,
@


1.18
log
@make compile w/ openssl 0.9.7
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.17 2001/12/27 18:22:16 markus Exp $");
d30 1
d37 1
d367 113
@


1.17
log
@call fatal() for openssl allocation failures
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.16 2001/12/19 07:18:56 deraadt Exp $");
d37 9
d190 2
a191 1
sc_private_decrypt(int flen, u_char *from, u_char *to, RSA *rsa, int padding)
d210 2
a211 1
	sectok_apdu(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, len, from, 0, NULL, &sw);
d234 2
a235 1
sc_private_encrypt(int flen, u_char *from, u_char *to, RSA *rsa, int padding)
d253 1
a253 1
	if (RSA_padding_add_PKCS1_type_1(padded, len, from, flen) <= 0) {
d294 1
a294 14
static RSA_METHOD smart_rsa =
{
	"sectok",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	0,
	NULL,
};
d299 1
a299 1
	RSA_METHOD *def;
d303 5
a315 11
	/* just use the OpenSSL version */
	smart_rsa.rsa_pub_enc   = def->rsa_pub_enc;
	smart_rsa.rsa_pub_dec   = def->rsa_pub_dec;
	smart_rsa.rsa_mod_exp	= def->rsa_mod_exp;
	smart_rsa.bn_mod_exp	= def->bn_mod_exp;
	smart_rsa.init		= def->init;
	smart_rsa.flags		= def->flags;
	smart_rsa.app_data	= def->app_data;
	smart_rsa.rsa_sign	= def->rsa_sign;
	smart_rsa.rsa_verify	= def->rsa_verify;

d321 1
@


1.16
log
@basic KNF done while i was looking for something else
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.15 2001/09/28 09:49:31 djm Exp $");
d323 2
a324 1
	smart_engine = ENGINE_new();
@


1.15
log
@Fix segv when smartcard communication error occurs during key load. ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.14 2001/09/17 20:22:14 markus Exp $");
d51 1
a51 1
static int 
d82 1
a82 1
static int 
d98 1
a98 1
static int 
d118 1
a118 1
static int 
d136 1
a136 1
	     sizeof(buf), buf, &sw);
d207 1
a207 1
	     len, padded, &sw);
d252 1
a252 1
	     len, to, &sw);
@


1.15.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.17 2001/12/27 18:22:16 markus Exp $");
d51 1
a51 1
static int
d82 1
a82 1
static int
d98 1
a98 1
static int
d118 1
a118 1
static int
d136 1
a136 1
	    sizeof(buf), buf, &sw);
d207 1
a207 1
	    len, padded, &sw);
d252 1
a252 1
	    len, to, &sw);
d323 1
a323 2
	if ((smart_engine = ENGINE_new()) == NULL)
		fatal("ENGINE_new failed");
@


1.15.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.25 2002/03/26 18:46:59 rees Exp $");
d29 1
a29 1
#include <openssl/evp.h>
a34 1
#include "readpass.h"
a36 13
#if OPENSSL_VERSION_NUMBER < 0x00907000L
#define USE_ENGINE
#define RSA_get_default_method RSA_get_default_openssl_method
#else
#endif

#ifdef USE_ENGINE
#include <openssl/engine.h>
#define sc_get_rsa sc_get_engine
#else
#define sc_get_rsa sc_get_rsa_method
#endif

a44 2
u_char DEFAUT0[] = {0xad, 0x9f, 0x61, 0xfe, 0xfa, 0x20, 0xce, 0x63};

a46 1
static char *sc_pin = NULL;
a48 4
static void sc_mk_digest(const char *pin, u_char *digest);
static int get_AUT0(u_char *aut0);
static int try_AUT0(void);

d129 2
a130 1
		if (sc_init() < 0)
a147 6

	if (sw == 0x6982) {
		if (try_AUT0() < 0)
			goto err;
		sectok_apdu(sc_fd, CLA_SSH, INS_GET_PUBKEY, 0, 0, 0, NULL, len, n, &sw);
	}
d181 1
a181 2
sc_private_decrypt(int flen, u_char *from, u_char *to, RSA *rsa,
    int padding)
d200 5
a204 6
	sectok_apdu(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, len, from, len, padded, &sw);

	if (sw == 0x6982) {
		if (try_AUT0() < 0)
			goto err;
		sectok_apdu(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, len, from, len, padded, &sw);
d206 2
d209 1
a209 1
		error("sc_private_decrypt: INS_DECRYPT failed: %s",
d223 1
a223 2
sc_private_encrypt(int flen, u_char *from, u_char *to, RSA *rsa,
    int padding)
d241 1
a241 1
	if (RSA_padding_add_PKCS1_type_1(padded, len, (u_char *)from, flen) <= 0) {
d245 5
a249 5
	sectok_apdu(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, len, padded, len, to, &sw);
	if (sw == 0x6982) {
		if (try_AUT0() < 0)
			goto err;
		sectok_apdu(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, len, padded, len, to, &sw);
d251 2
d254 1
a254 1
		error("sc_private_encrypt: INS_DECRYPT failed: %s",
d278 1
d281 2
a282 2
static RSA_METHOD *
sc_get_rsa_method(void)
d284 12
a295 2
	static RSA_METHOD smart_rsa;
	const RSA_METHOD *def = RSA_get_default_method();
d297 4
a300 2
	/* use the OpenSSL version */
	memcpy(&smart_rsa, def, sizeof(smart_rsa));
d302 1
a302 1
	smart_rsa.name		= "sectok";
d312 10
a321 8
	return &smart_rsa;
}

#ifdef USE_ENGINE
static ENGINE *
sc_get_engine(void)
{
	static ENGINE *smart_engine = NULL;
d328 1
a328 2

	ENGINE_set_RSA(smart_engine, sc_get_rsa_method());
a335 1
#endif
d346 2
a347 2
Key **
sc_get_keys(const char *id, const char *pin)
d349 2
a350 2
	Key *k, *n, **keys;
	int status, nkeys = 2;
a355 4
	if (sc_pin != NULL)
		xfree(sc_pin);
	sc_pin = (pin == NULL) ? NULL : xstrdup(pin);

d370 1
a370 170
	keys = xmalloc((nkeys+1) * sizeof(Key *));

	n = key_new(KEY_RSA1);
	BN_copy(n->rsa->n, k->rsa->n);
	BN_copy(n->rsa->e, k->rsa->e);
	RSA_set_method(n->rsa, sc_get_rsa());
	n->flags |= KEY_FLAG_EXT;
	keys[0] = n;

	n = key_new(KEY_RSA);
	BN_copy(n->rsa->n, k->rsa->n);
	BN_copy(n->rsa->e, k->rsa->e);
	RSA_set_method(n->rsa, sc_get_rsa());
	n->flags |= KEY_FLAG_EXT;
	keys[1] = n;

	keys[2] = NULL;

	key_free(k);
	return keys;
}

#define NUM_RSA_KEY_ELEMENTS 5+1
#define COPY_RSA_KEY(x, i) \
	do { \
		len = BN_num_bytes(prv->rsa->x); \
		elements[i] = xmalloc(len); \
		debug("#bytes %d", len); \
		if (BN_bn2bin(prv->rsa->x, elements[i]) < 0) \
			goto done; \
	} while (0)

static void
sc_mk_digest(const char *pin, u_char *digest)
{
	const EVP_MD *evp_md = EVP_sha1();
	EVP_MD_CTX md;

	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, pin, strlen(pin));
	EVP_DigestFinal(&md, digest, NULL);
}

static int
get_AUT0(u_char *aut0)
{
	char *pass;

	pass = read_passphrase("Enter passphrase for smartcard: ", RP_ALLOW_STDIN);
	if (pass == NULL)
		return -1;
	if (!strcmp(pass, "-")) {
		memcpy(aut0, DEFAUT0, sizeof DEFAUT0);
		return 0;
	}
	sc_mk_digest(pass, aut0);
	memset(pass, 0, strlen(pass));
	xfree(pass);
	return 0;
}

static int
try_AUT0(void)
{
	u_char aut0[EVP_MAX_MD_SIZE];

	/* permission denied; try PIN if provided */
	if (sc_pin && strlen(sc_pin) > 0) {
		sc_mk_digest(sc_pin, aut0);
		if (cyberflex_verify_AUT0(sc_fd, cla, aut0, 8) < 0) {
			error("smartcard passphrase incorrect");
			return (-1);
		}
	} else {
		/* try default AUT0 key */
		if (cyberflex_verify_AUT0(sc_fd, cla, DEFAUT0, 8) < 0) {
			/* default AUT0 key failed; prompt for passphrase */
			if (get_AUT0(aut0) < 0 ||
			    cyberflex_verify_AUT0(sc_fd, cla, aut0, 8) < 0) {
				error("smartcard passphrase incorrect");
				return (-1);
			}
		}
	}
	return (0);
}

int
sc_put_key(Key *prv, const char *id)
{
	u_char *elements[NUM_RSA_KEY_ELEMENTS];
	u_char key_fid[2];
	u_char AUT0[EVP_MAX_MD_SIZE];
	int len, status = -1, i, fd = -1, ret;
	int sw = 0, cla = 0x00;

	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++)
		elements[i] = NULL;

	COPY_RSA_KEY(q, 0);
	COPY_RSA_KEY(p, 1);
	COPY_RSA_KEY(iqmp, 2);
	COPY_RSA_KEY(dmq1, 3);
	COPY_RSA_KEY(dmp1, 4);
	COPY_RSA_KEY(n, 5);
	len = BN_num_bytes(prv->rsa->n);
	fd = sectok_friendly_open(id, STONOWAIT, &sw);
	if (fd < 0) {
		error("sectok_open failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (! sectok_cardpresent(fd)) {
		error("smartcard in reader %s not present", id);
		goto done;
	}
	ret = sectok_reset(fd, 0, NULL, &sw);
	if (ret <= 0) {
		error("sectok_reset failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if ((cla = cyberflex_inq_class(fd)) < 0) {
		error("cyberflex_inq_class failed");
		goto done;
	}
	memcpy(AUT0, DEFAUT0, sizeof(DEFAUT0));
	if (cyberflex_verify_AUT0(fd, cla, AUT0, sizeof(DEFAUT0)) < 0) {
		if (get_AUT0(AUT0) < 0 ||
		    cyberflex_verify_AUT0(fd, cla, AUT0, sizeof(DEFAUT0)) < 0) {
			memset(AUT0, 0, sizeof(DEFAUT0));
			error("smartcard passphrase incorrect");
			goto done;
		}
	}
	memset(AUT0, 0, sizeof(DEFAUT0));
	key_fid[0] = 0x00;
	key_fid[1] = 0x12;
	if (cyberflex_load_rsa_priv(fd, cla, key_fid, 5, 8*len, elements,
	    &sw) < 0) {
		error("cyberflex_load_rsa_priv failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (!sectok_swOK(sw))
		goto done;
	log("cyberflex_load_rsa_priv done");
	key_fid[0] = 0x73;
	key_fid[1] = 0x68;
	if (cyberflex_load_rsa_pub(fd, cla, key_fid, len, elements[5],
	    &sw) < 0) {
		error("cyberflex_load_rsa_pub failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (!sectok_swOK(sw))
		goto done;
	log("cyberflex_load_rsa_pub done");
	status = 0;

done:
	memset(elements[0], '\0', BN_num_bytes(prv->rsa->q));
	memset(elements[1], '\0', BN_num_bytes(prv->rsa->p));
	memset(elements[2], '\0', BN_num_bytes(prv->rsa->iqmp));
	memset(elements[3], '\0', BN_num_bytes(prv->rsa->dmq1));
	memset(elements[4], '\0', BN_num_bytes(prv->rsa->dmp1));
	memset(elements[5], '\0', BN_num_bytes(prv->rsa->n));

	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++)
		if (elements[i])
			xfree(elements[i]);
	if (fd != -1)
		sectok_close(fd);
	return (status);
@


1.15.2.3
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.15.2.2 2002/05/17 00:03:24 miod Exp $");
d194 1
a194 1
	debug("fingerprint %u %s", key_size(k), p);
@


1.14
log
@never keep a connection to the smartcard open.
allows ssh-keygen -D U while the agent is running; report from jakob@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.13 2001/08/02 16:14:05 jakob Exp $");
d126 1
@


1.14.4.1
log
@Pull in OpenSSH-2.9.9
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.14 2001/09/17 20:22:14 markus Exp $");
@


1.14.4.2
log
@Merge OpenSSH 3.0
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.14.4.1 2001/09/27 19:03:55 jason Exp $");
a125 1
	n = NULL;
@


1.14.4.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.17 2001/12/27 18:22:16 markus Exp $");
d51 1
a51 1
static int
d82 1
a82 1
static int
d98 1
a98 1
static int
d118 1
a118 1
static int
d136 1
a136 1
	    sizeof(buf), buf, &sw);
d207 1
a207 1
	    len, padded, &sw);
d252 1
a252 1
	    len, to, &sw);
d323 1
a323 2
	if ((smart_engine = ENGINE_new()) == NULL)
		fatal("ENGINE_new failed");
@


1.14.4.4
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.25 2002/03/26 18:46:59 rees Exp $");
d29 1
a29 1
#include <openssl/evp.h>
a34 1
#include "readpass.h"
a36 13
#if OPENSSL_VERSION_NUMBER < 0x00907000L
#define USE_ENGINE
#define RSA_get_default_method RSA_get_default_openssl_method
#else
#endif

#ifdef USE_ENGINE
#include <openssl/engine.h>
#define sc_get_rsa sc_get_engine
#else
#define sc_get_rsa sc_get_rsa_method
#endif

a44 2
u_char DEFAUT0[] = {0xad, 0x9f, 0x61, 0xfe, 0xfa, 0x20, 0xce, 0x63};

a46 1
static char *sc_pin = NULL;
a48 4
static void sc_mk_digest(const char *pin, u_char *digest);
static int get_AUT0(u_char *aut0);
static int try_AUT0(void);

d129 2
a130 1
		if (sc_init() < 0)
a147 6

	if (sw == 0x6982) {
		if (try_AUT0() < 0)
			goto err;
		sectok_apdu(sc_fd, CLA_SSH, INS_GET_PUBKEY, 0, 0, 0, NULL, len, n, &sw);
	}
d181 1
a181 2
sc_private_decrypt(int flen, u_char *from, u_char *to, RSA *rsa,
    int padding)
d200 5
a204 6
	sectok_apdu(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, len, from, len, padded, &sw);

	if (sw == 0x6982) {
		if (try_AUT0() < 0)
			goto err;
		sectok_apdu(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, len, from, len, padded, &sw);
d206 2
d209 1
a209 1
		error("sc_private_decrypt: INS_DECRYPT failed: %s",
d223 1
a223 2
sc_private_encrypt(int flen, u_char *from, u_char *to, RSA *rsa,
    int padding)
d241 1
a241 1
	if (RSA_padding_add_PKCS1_type_1(padded, len, (u_char *)from, flen) <= 0) {
d245 5
a249 5
	sectok_apdu(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, len, padded, len, to, &sw);
	if (sw == 0x6982) {
		if (try_AUT0() < 0)
			goto err;
		sectok_apdu(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, len, padded, len, to, &sw);
d251 2
d254 1
a254 1
		error("sc_private_encrypt: INS_DECRYPT failed: %s",
d278 1
d281 2
a282 2
static RSA_METHOD *
sc_get_rsa_method(void)
d284 12
a295 2
	static RSA_METHOD smart_rsa;
	const RSA_METHOD *def = RSA_get_default_method();
d297 4
a300 2
	/* use the OpenSSL version */
	memcpy(&smart_rsa, def, sizeof(smart_rsa));
d302 1
a302 1
	smart_rsa.name		= "sectok";
d312 10
a321 8
	return &smart_rsa;
}

#ifdef USE_ENGINE
static ENGINE *
sc_get_engine(void)
{
	static ENGINE *smart_engine = NULL;
d328 1
a328 2

	ENGINE_set_RSA(smart_engine, sc_get_rsa_method());
a335 1
#endif
d346 2
a347 2
Key **
sc_get_keys(const char *id, const char *pin)
d349 2
a350 2
	Key *k, *n, **keys;
	int status, nkeys = 2;
a355 4
	if (sc_pin != NULL)
		xfree(sc_pin);
	sc_pin = (pin == NULL) ? NULL : xstrdup(pin);

d370 1
a370 170
	keys = xmalloc((nkeys+1) * sizeof(Key *));

	n = key_new(KEY_RSA1);
	BN_copy(n->rsa->n, k->rsa->n);
	BN_copy(n->rsa->e, k->rsa->e);
	RSA_set_method(n->rsa, sc_get_rsa());
	n->flags |= KEY_FLAG_EXT;
	keys[0] = n;

	n = key_new(KEY_RSA);
	BN_copy(n->rsa->n, k->rsa->n);
	BN_copy(n->rsa->e, k->rsa->e);
	RSA_set_method(n->rsa, sc_get_rsa());
	n->flags |= KEY_FLAG_EXT;
	keys[1] = n;

	keys[2] = NULL;

	key_free(k);
	return keys;
}

#define NUM_RSA_KEY_ELEMENTS 5+1
#define COPY_RSA_KEY(x, i) \
	do { \
		len = BN_num_bytes(prv->rsa->x); \
		elements[i] = xmalloc(len); \
		debug("#bytes %d", len); \
		if (BN_bn2bin(prv->rsa->x, elements[i]) < 0) \
			goto done; \
	} while (0)

static void
sc_mk_digest(const char *pin, u_char *digest)
{
	const EVP_MD *evp_md = EVP_sha1();
	EVP_MD_CTX md;

	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, pin, strlen(pin));
	EVP_DigestFinal(&md, digest, NULL);
}

static int
get_AUT0(u_char *aut0)
{
	char *pass;

	pass = read_passphrase("Enter passphrase for smartcard: ", RP_ALLOW_STDIN);
	if (pass == NULL)
		return -1;
	if (!strcmp(pass, "-")) {
		memcpy(aut0, DEFAUT0, sizeof DEFAUT0);
		return 0;
	}
	sc_mk_digest(pass, aut0);
	memset(pass, 0, strlen(pass));
	xfree(pass);
	return 0;
}

static int
try_AUT0(void)
{
	u_char aut0[EVP_MAX_MD_SIZE];

	/* permission denied; try PIN if provided */
	if (sc_pin && strlen(sc_pin) > 0) {
		sc_mk_digest(sc_pin, aut0);
		if (cyberflex_verify_AUT0(sc_fd, cla, aut0, 8) < 0) {
			error("smartcard passphrase incorrect");
			return (-1);
		}
	} else {
		/* try default AUT0 key */
		if (cyberflex_verify_AUT0(sc_fd, cla, DEFAUT0, 8) < 0) {
			/* default AUT0 key failed; prompt for passphrase */
			if (get_AUT0(aut0) < 0 ||
			    cyberflex_verify_AUT0(sc_fd, cla, aut0, 8) < 0) {
				error("smartcard passphrase incorrect");
				return (-1);
			}
		}
	}
	return (0);
}

int
sc_put_key(Key *prv, const char *id)
{
	u_char *elements[NUM_RSA_KEY_ELEMENTS];
	u_char key_fid[2];
	u_char AUT0[EVP_MAX_MD_SIZE];
	int len, status = -1, i, fd = -1, ret;
	int sw = 0, cla = 0x00;

	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++)
		elements[i] = NULL;

	COPY_RSA_KEY(q, 0);
	COPY_RSA_KEY(p, 1);
	COPY_RSA_KEY(iqmp, 2);
	COPY_RSA_KEY(dmq1, 3);
	COPY_RSA_KEY(dmp1, 4);
	COPY_RSA_KEY(n, 5);
	len = BN_num_bytes(prv->rsa->n);
	fd = sectok_friendly_open(id, STONOWAIT, &sw);
	if (fd < 0) {
		error("sectok_open failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (! sectok_cardpresent(fd)) {
		error("smartcard in reader %s not present", id);
		goto done;
	}
	ret = sectok_reset(fd, 0, NULL, &sw);
	if (ret <= 0) {
		error("sectok_reset failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if ((cla = cyberflex_inq_class(fd)) < 0) {
		error("cyberflex_inq_class failed");
		goto done;
	}
	memcpy(AUT0, DEFAUT0, sizeof(DEFAUT0));
	if (cyberflex_verify_AUT0(fd, cla, AUT0, sizeof(DEFAUT0)) < 0) {
		if (get_AUT0(AUT0) < 0 ||
		    cyberflex_verify_AUT0(fd, cla, AUT0, sizeof(DEFAUT0)) < 0) {
			memset(AUT0, 0, sizeof(DEFAUT0));
			error("smartcard passphrase incorrect");
			goto done;
		}
	}
	memset(AUT0, 0, sizeof(DEFAUT0));
	key_fid[0] = 0x00;
	key_fid[1] = 0x12;
	if (cyberflex_load_rsa_priv(fd, cla, key_fid, 5, 8*len, elements,
	    &sw) < 0) {
		error("cyberflex_load_rsa_priv failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (!sectok_swOK(sw))
		goto done;
	log("cyberflex_load_rsa_priv done");
	key_fid[0] = 0x73;
	key_fid[1] = 0x68;
	if (cyberflex_load_rsa_pub(fd, cla, key_fid, len, elements[5],
	    &sw) < 0) {
		error("cyberflex_load_rsa_pub failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (!sectok_swOK(sw))
		goto done;
	log("cyberflex_load_rsa_pub done");
	status = 0;

done:
	memset(elements[0], '\0', BN_num_bytes(prv->rsa->q));
	memset(elements[1], '\0', BN_num_bytes(prv->rsa->p));
	memset(elements[2], '\0', BN_num_bytes(prv->rsa->iqmp));
	memset(elements[3], '\0', BN_num_bytes(prv->rsa->dmq1));
	memset(elements[4], '\0', BN_num_bytes(prv->rsa->dmp1));
	memset(elements[5], '\0', BN_num_bytes(prv->rsa->n));

	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++)
		if (elements[i])
			xfree(elements[i]);
	if (fd != -1)
		sectok_close(fd);
	return (status);
@


1.14.2.1
log
@A few files forgotten during last OpenSSH update. Spotted by naddy@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.14 2001/09/17 20:22:14 markus Exp $");
@


1.14.2.2
log
@Merge OpenSSH 3.0
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.14.2.1 2001/09/27 18:27:43 miod Exp $");
a125 1
	n = NULL;
@


1.14.2.3
log
@Merge OpenSSH 3.1.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.17 2001/12/27 18:22:16 markus Exp $");
d51 1
a51 1
static int
d82 1
a82 1
static int
d98 1
a98 1
static int
d118 1
a118 1
static int
d136 1
a136 1
	    sizeof(buf), buf, &sw);
d207 1
a207 1
	    len, padded, &sw);
d252 1
a252 1
	    len, to, &sw);
d323 1
a323 2
	if ((smart_engine = ENGINE_new()) == NULL)
		fatal("ENGINE_new failed");
@


1.13
log
@clean up some /* SMARTCARD */. ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.12 2001/08/01 23:38:45 markus Exp $");
d123 1
a123 1
	int len, sw, status;
d130 1
a130 1
			return status;
d138 1
a138 2
		sc_close();
		return -1;
d149 1
a149 2
		xfree(n);
		return -1;
d151 1
d156 1
a156 3
		xfree(n);
		sc_close();
		return -1;
a157 1
	xfree(n);
d162 1
a162 1
		return -1;
d165 1
d170 5
a174 1
	return 0;
d183 1
a183 1
	int sw, len, olen, status;
a202 1
		sc_close();
a209 1
		sc_close();
d217 1
d225 1
a225 1
	int sw, len, status;
a247 1
		sc_close();
a254 1
		sc_close();
d260 1
a368 1
	sc_close();
@


1.12
log
@support finish rsa keys.
free public keys after login -> call finish -> close smartcard.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.11 2001/08/01 22:03:33 markus Exp $");
d372 1
a372 1
#endif
@


1.11
log
@use strings instead of ints for smartcard reader ids
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.10 2001/07/31 12:53:34 jakob Exp $");
d265 14
d308 4
a317 1
	smart_rsa.finish	= def->finish;
@


1.10
log
@close smartcard connection if card is missing.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.9 2001/07/31 08:41:10 jakob Exp $");
d46 1
a46 1
static int sc_reader_num = -1;
d59 1
a59 1
	sc_fd = sectok_open(sc_reader_num, STONOWAIT, &sw);
d65 2
a66 2
		debug("smartcard in reader %d not present, skipping",
		    sc_reader_num);
d329 1
a329 1
sc_get_key(int num)
d334 4
a337 1
	sc_reader_num = num;
@


1.9
log
@do not complain about missing smartcards. ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.8 2001/07/30 16:06:07 jakob Exp $");
d67 1
@


1.8
log
@better errorcodes from sc_*; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.7 2001/07/26 20:04:27 rees Exp $");
d65 1
a65 1
		error("smartcard in reader %d not present, skipping",
d331 1
d338 6
a343 1
	if (sc_read_pubkey(k) < 0) {
@


1.7
log
@Inquire Cyberflex class for 0xf0 cards
change aid to conform to 7816-5
remove gratuitous fid selects
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.6 2001/07/25 11:59:35 markus Exp $");
d59 1
a59 1
	sc_fd = sectok_open(sc_reader_num, 0, &sw);
d62 6
a67 1
		return -1;
d72 1
a72 1
		return sc_fd;
d100 7
a106 1
	if (sc_open() < 0) {
d108 1
a108 1
		return -1;
d112 1
a112 1
		return -1;
d122 1
a122 1
	int len, sw;
d126 5
a130 3
	if (sc_fd < 0)
		if (sc_init() < 0)
			return -1;
d181 1
a181 1
	int sw, len, olen;
d186 3
a188 2
	if (sc_fd < 0)
		if (sc_init() < 0)
d190 1
d217 1
a217 1
	return olen;
d224 1
a224 1
	int sw, len;
d227 3
a229 2
	if (sc_fd < 0)
		if (sc_init() < 0)
d231 1
d261 1
a261 1
	return len;
@


1.6
log
@typo in comment
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.5 2001/07/04 23:13:09 markus Exp $");
a53 1
	u_char atr[256];
d64 1
a64 1
	if (sectok_reset(sc_fd, 0, atr, &sw) <= 0) {
d69 2
d79 2
a80 2
	u_char contID[2], aid[MAX_BUF_SIZE];
	int i, len, sw, aid_len;
d82 2
a83 20
	len = sw = 0;
	contID[0] = 0x77;
	contID[1] = 0x78;

	if (sectok_selectfile(sc_fd, cla, root_fid, &sw) < 0) {
		error("sectok_selectfile root_fid failed: %s",
		    sectok_get_sw(sw));
		sc_close();
		return -1;
	}
	if (sectok_selectfile(sc_fd, cla, contID, &sw) < 0) {
		error("sectok_selectfile failed: %s", sectok_get_sw(sw));
		sc_close();
		return -1;
	}
	/* send applet id */
	for (i = 0; i < sizeof(aid); i++)
		aid[i] = 0x77;
	aid_len = 5;
	sectok_apdu(sc_fd, cla, 0xa4, 0x04, 0, aid_len, aid, 0, NULL, &sw);
@


1.5
log
@handle card removal more gracefully, add sc_close() to scard.h
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.4 2001/07/02 22:40:17 markus Exp $");
d96 1
a96 1
	/* send appled id */
@


1.4
log
@update for sectok.h interface changes.
improve error handling.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.3 2001/06/26 20:14:10 markus Exp $");
d46 1
a46 1
static int sc_reader_num = 0;
d52 1
a52 1
sc_open(int num)
a58 1
	sc_reader_num = num;
d60 1
a60 1
	sc_fd = sectok_open(sc_reader_num, 0, NULL);
d62 2
a63 2
		error("sectok_open failed %d", sc_fd);
		return sc_fd;
d70 1
d88 1
d93 1
d103 15
d132 4
d141 1
d161 1
d190 3
d203 1
d211 1
d229 3
d247 1
d255 1
d318 9
d328 1
a328 1
sc_get_key(int sc_reader_num)
d332 1
a332 8
	if (sc_open(sc_reader_num) < 0) {
		error("sc_open failed");
		return NULL;
	}
	if (sc_enable_applet() < 0) {
		error("sc_enable_applet failed");
		return NULL;
	}
d343 1
@


1.3
log
@add smartcard support to the client, too (now you can use both
the agent and the client).
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.2 2001/06/26 06:32:59 itojun Exp $");
a53 1
	int n;
d55 1
d61 1
a61 1
	sc_fd = scopen(sc_reader_num, 0, NULL);
d63 1
a63 1
		error("scopen failed %d", sc_fd);
d66 2
a67 3
	n = screset(sc_fd, atr, NULL);
	if (n <= 0) {
		error("screset failed.");
d71 1
a71 1
	debug("open ok %d", sc_fd);
d76 1
a76 9
sc_reset(void)
{
	scclose(sc_fd);
	sc_fd = -1;
	return sc_open(sc_reader_num);
}

static int
selectfile(int fd, int f0, int f1, int verbose)
d78 2
a79 24
	int n, r1, r2, code;
	u_char buf[2], obuf[256];

	buf[0] = f0;
	buf[1] = f1;
	n = scrw(sc_fd, cla, 0xa4, 0, 0, 2, buf, sizeof obuf, obuf, &r1, &r2);
	if (n < 0) {
		error("selectfile: scwrite failed");
		return -2;
	}
	if (r1 == 0x90 || r1 == 0x61)
		code = 0;
	else if (r1 == 0x6a && r2 == 0x82)
		/* file not found */
		code = -1;
	else
		code = -2;
	if (verbose && n > 0)
		dump_reply(obuf, n, 0, 0);
	if (verbose || code == -2) {
		error("%x.%x: %s", f0, f1, get_r1r2s(r1, r2));
	}
	return code;
}
d81 1
a81 10
static int 
sc_enable_applet(void)
{
	u_char data[MAX_BUF_SIZE];
	u_char progID[2], contID[2], aid[MAX_BUF_SIZE];
	int i, len, rv, r1, r2, aid_len;

	len = rv = r1 = r2 = 0;
	progID[0] = 0x77;
	progID[1] = 0x77;
a83 1
	aid_len = 5;
d85 3
a87 6
	for (i = 0; i < 16; i++)
		aid[i] = 0x77;

	rv = selectfile(sc_fd, contID[0], contID[1], 0);
	if (rv < 0) {
		error("selectfile failed");
d90 11
a100 10
	for (i = 0; i < aid_len; i++)
		data[i] = (u_char) aid[i];
	rv = scwrite(sc_fd, cla, 0xa4, 0x04, 0, aid_len, data, &r1, &r2);
	if (r1 != 0x90 && r1 != 0x61) {
		/* error */
		error("selecting the cardlet: ");
		for (i = 0; i < aid_len; i++) {
			error("%02x", (u_char) aid[i]);
		}
		print_r1r2(r1, r2);
d109 3
a111 3
	u_char          buf[256];
	char           *p;
	int             len, rv, r1, r2;
d113 1
a113 1
	len = rv = r1 = r2 = 0;
d116 5
a120 4
	rv = scread(sc_fd, CLA_SSH, INS_GET_KEYLENGTH, 0, 0, 2, buf, &r1, &r2);
	if (rv < 0) {
		error("could not obtain key length.");
		return rv;
a122 1
	debug("INS_GET_KEYLENGTH: len %d r1 %d r2 %d", len, r1, r2);
d124 1
d126 1
d128 5
a132 4
	rv = scread(sc_fd, CLA_SSH, INS_GET_PUBKEY, 0, 0, len, buf, &r1, &r2);
	if (rv < 0) {
		error("could not obtain public key");
		return rv;
d134 8
a141 2
	debug("INS_GET_PUBKEY: len %d r1 %d r2 %d", len, r1, r2);
	BN_bin2bn(buf, len, k->rsa->n);
d144 4
a147 1
	BN_set_word(k->rsa->e, 35);	/* XXX */
d159 1
a159 2
sc_private_decrypt(int flen, unsigned char *from,
    unsigned char *to, RSA *rsa, int padding)
d161 2
a162 2
        int rv, num, r1, r2, olen;
        u_char *padded = NULL;
d166 2
a167 2
	olen = num = r1 = r2 = 0;
        if (padding != RSA_PKCS1_PADDING)
d170 2
a171 2
        num = BN_num_bytes(rsa->n);
	padded = xmalloc(num);
d173 4
a176 3
	rv = scwrite(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, num, from, &r1, &r2);
	if (rv < 0) {
		error("scwrite() for decrypt failed.");
d179 5
a183 7
	if (r1 != 0x90 && r1 != 0x61) {
		error("INS_DECRYPT: r1 %x r2 %x", r1, r2);
                goto err;
	}
	rv = scread(sc_fd, CLA_SSH, INS_GET_RESPONSE, 0, 0, num, padded, &r1, &r2);
	if (rv < 0) {
		error("scread() for decrypt failed");
d186 2
a187 6
	if (r1 != 0x90 && r1 != 0x61) {
		error("INS_GET_RESPONSE: r1 %x r2 %x", r1, r2);
                goto err;
	}
	debug("r1 %x r2 %x", r1, r2);
	olen = RSA_padding_check_PKCS1_type_2(to, num, padded + 1, num - 1, num);
a193 1

d195 1
a195 2
sc_private_encrypt(int flen, unsigned char *from,
    unsigned char *to, RSA *rsa, int padding)
d197 2
a198 2
        int rv, i, num, r1, r2;
        u_char *padded = NULL;
d200 2
a201 2
	num = r1 = r2 = 0;
        if (padding != RSA_PKCS1_PADDING)
d205 4
a208 4
        num = BN_num_bytes(rsa->n);
	padded = xmalloc(num);
	i = RSA_padding_add_PKCS1_type_1(padded, num, from, flen);
	if (i <= 0) {
d212 12
a223 19
        rv = scwrite(sc_fd, CLA_SSH, INS_DECRYPT, 0, 0, num, padded, &r1, &r2);
        if (rv < 0) {
                error("scwrite() for rsa failed");
		sc_reset();
                goto err;
        }
	if (r1 != 0x90 && r1 != 0x61) {
		error("INS_DECRYPT: r1 %x r2 %x", r1, r2);
                goto err;
	}
        rv = scread(sc_fd, CLA_SSH, INS_GET_RESPONSE, 0, 0, num, to, &r1, &r2);
        if (rv < 0) {
                error("scread() for rsa failed");
		sc_reset();
                goto err;
        }
	if (r1 != 0x90 && r1 != 0x61) {
		error("INS_GET_RESPONSE: r1 %x r2 %x", r1, r2);
                goto err;
d228 1
a228 1
	return num;
d236 11
a246 11
        "smartcard",
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        0,
        NULL,
d261 2
a262 2
        smart_rsa.rsa_pub_enc   = def->rsa_pub_enc;
        smart_rsa.rsa_pub_dec   = def->rsa_pub_dec;
d274 2
a275 2
	ENGINE_set_id(smart_engine, "xxx");
	ENGINE_set_name(smart_engine, "xxx");
a288 1
	int rv;
d290 1
a290 2
	rv = sc_open (sc_reader_num);
	if (rv < 0) {
d294 1
a294 2
	rv = sc_enable_applet();
	if (rv < 0) {
d302 1
a302 2
	rv = sc_read_pubkey (k);
	if (rv < 0) {
@


1.2
log
@prototype pedant.  not very creative...
- () -> (void)
- no variable names
@
text
@d27 1
a27 1
RCSID("$OpenBSD: scard.c,v 1.1 2001/06/26 05:33:34 markus Exp $");
d165 1
a165 1
	error("len %d r1 %d r2 %d", len, r1, r2);
d174 1
a174 1
	debug("len %d r1 %d r2 %d", len, r1, r2);
d243 1
a243 1
	error("sc_private_encrypt called");
@


1.1
log
@more smartcard support.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: ssh-agent.c,v 1.56 2001/06/25 08:25:40 markus Exp $");
d296 1
a296 1
sc_get_engine()
@

