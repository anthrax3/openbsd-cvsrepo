head	1.83;
access;
symbols
	OPENBSD_6_0:1.82.0.12
	OPENBSD_6_0_BASE:1.82
	OPENBSD_5_9:1.82.0.8
	OPENBSD_5_9_BASE:1.82
	OPENBSD_5_8:1.82.0.6
	OPENBSD_5_8_BASE:1.82
	OPENBSD_5_7:1.82.0.2
	OPENBSD_5_7_BASE:1.82
	OPENBSD_5_6:1.82.0.4
	OPENBSD_5_6_BASE:1.82
	OPENBSD_5_5:1.80.0.4
	OPENBSD_5_5_BASE:1.80
	OPENBSD_5_4:1.79.0.2
	OPENBSD_5_4_BASE:1.79
	OPENBSD_5_3:1.77.0.2
	OPENBSD_5_3_BASE:1.77
	OPENBSD_5_2:1.75.0.8
	OPENBSD_5_2_BASE:1.75
	OPENBSD_5_1_BASE:1.75
	OPENBSD_5_1:1.75.0.6
	OPENBSD_5_0:1.75.0.4
	OPENBSD_5_0_BASE:1.75
	OPENBSD_4_9:1.75.0.2
	OPENBSD_4_9_BASE:1.75
	OPENBSD_4_8:1.74.0.2
	OPENBSD_4_8_BASE:1.74
	OPENBSD_4_7:1.73.0.6
	OPENBSD_4_7_BASE:1.73
	OPENBSD_4_6:1.73.0.8
	OPENBSD_4_6_BASE:1.73
	OPENBSD_4_5:1.73.0.4
	OPENBSD_4_5_BASE:1.73
	OPENBSD_4_4:1.73.0.2
	OPENBSD_4_4_BASE:1.73
	OPENBSD_4_3:1.71.0.2
	OPENBSD_4_3_BASE:1.71
	OPENBSD_4_2:1.70.0.6
	OPENBSD_4_2_BASE:1.70
	OPENBSD_4_1:1.70.0.2
	OPENBSD_4_1_BASE:1.70
	OPENBSD_4_0:1.70.0.4
	OPENBSD_4_0_BASE:1.70
	OPENBSD_3_9:1.62.0.4
	OPENBSD_3_9_BASE:1.62
	OPENBSD_3_8:1.62.0.2
	OPENBSD_3_8_BASE:1.62
	OPENBSD_3_7:1.59.0.4
	OPENBSD_3_7_BASE:1.59
	OPENBSD_3_6:1.59.0.2
	OPENBSD_3_6_BASE:1.59
	OPENBSD_3_5:1.55.0.2
	OPENBSD_3_5_BASE:1.55
	OPENBSD_3_4:1.52.0.2
	OPENBSD_3_4_BASE:1.52
	OPENBSD_3_3:1.47.0.2
	OPENBSD_3_3_BASE:1.47
	OPENBSD_3_2:1.44.0.2
	OPENBSD_3_2_BASE:1.44
	OPENBSD_3_1:1.40.0.2
	OPENBSD_3_1_BASE:1.40
	OPENBSD_3_0:1.25.0.2
	OPENBSD_3_0_BASE:1.25
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.83
date	2016.08.13.17.47.41;	author markus;	state dead;
branches;
next	1.82;
commitid	dl4RDERdJITM8DKC;

1.82
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.81;
commitid	z7plx8Gkj6l2sxem;

1.81
date	2014.07.03.11.16.55;	author djm;	state Exp;
branches;
next	1.80;
commitid	qUeYjXdfTNrKthSc;

1.80
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.79;

1.79
date	2013.05.19.02.42.42;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.77;

1.77
date	2012.12.02.20.34.09;	author djm;	state Exp;
branches;
next	1.76;

1.76
date	2012.11.04.11.09.15;	author djm;	state Exp;
branches;
next	1.75;

1.75
date	2010.08.31.09.58.37;	author djm;	state Exp;
branches;
next	1.74;

1.74
date	2010.06.25.08.46.17;	author djm;	state Exp;
branches;
next	1.73;

1.73
date	2008.07.04.23.30.16;	author djm;	state Exp;
branches;
next	1.72;

1.72
date	2008.05.08.12.02.23;	author djm;	state Exp;
branches;
next	1.71;

1.71
date	2007.09.21.08.15.29;	author djm;	state Exp;
branches;
next	1.70;

1.70
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.68;

1.68
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.67;

1.67
date	2006.07.20.15.26.14;	author stevesk;	state Exp;
branches;
next	1.66;

1.66
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.65;

1.65
date	2006.03.20.18.17.20;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.19.18.52.11;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2005.07.16.01.35.24;	author djm;	state Exp;
branches
	1.62.2.1
	1.62.4.1;
next	1.61;

1.61
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches;
next	1.60;

1.60
date	2005.05.20.12.57.01;	author djm;	state Exp;
branches;
next	1.59;

1.59
date	2004.07.28.09.40.29;	author markus;	state Exp;
branches
	1.59.2.1
	1.59.4.1;
next	1.58;

1.58
date	2004.07.21.10.33.31;	author djm;	state Exp;
branches;
next	1.57;

1.57
date	2004.05.23.23.59.53;	author dtucker;	state Exp;
branches;
next	1.56;

1.56
date	2004.05.09.01.19.27;	author djm;	state Exp;
branches;
next	1.55;

1.55
date	2003.11.08.16.02.40;	author jakob;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2003.11.04.08.54.09;	author djm;	state Exp;
branches;
next	1.53;

1.53
date	2003.09.23.20.17.11;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2003.08.28.12.54.34;	author markus;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2003.08.26.09.58.43;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2003.08.13.08.46.30;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2003.07.22.13.35.22;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2003.02.06.21.22.42;	author markus;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2003.01.23.00.03.00;	author djm;	state Exp;
branches;
next	1.45;

1.45
date	2002.11.21.23.03.51;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2002.09.26.11.38.43;	author markus;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2002.09.09.06.48.06;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2002.08.22.21.33.58;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2002.04.10.08.21.47;	author markus;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2002.03.19.14.27.39;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.18.17.50.31;	author provos;	state Exp;
branches;
next	1.37;

1.37
date	2002.03.18.01.12.14;	author provos;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.17.20.25.56;	author provos;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.03.17.53.25;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2001.12.28.14.50.54;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2001.12.28.13.57.33;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.27.20.39.58;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.27.19.54.53;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.27.18.22.16;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.25.18.53.00;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.05.03.56.39;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.26.16.15.23;	author dugsong;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2001.06.23.15.12.17;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.18.14.13.28;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.23.12.02.49;	author markus;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.03.21.11.43.44;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.20.18.57.04;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.08.18.47.12;	author stevesk;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.22.21.59.43;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.13.22.49.40;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.12.16.16.23;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.07.22.35.45;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.22.23.06.39;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.21.19.05.43;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.19.15.55.10;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.18.16.59.59;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.07.19.06.25;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.27.12.34.49;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.19.23.17.55;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.10.01.04.40;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.11.20.27.23;	author markus;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.10.03.18.03.03;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.07.20.27.49;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.20.18.42.40;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.29.18.11.52;	author markus;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.04.26.21.28.32;	author markus;	state Exp;
branches;
next	;

1.2.2.1
date	2000.09.01.18.23.17;	author jason;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2000.11.08.21.30.23;	author jason;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2000.11.10.20.49.29;	author jason;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2001.03.12.15.44.07;	author jason;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2001.03.21.18.52.34;	author jason;	state Exp;
branches;
next	;

1.6.2.1
date	2000.11.10.20.51.02;	author jason;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.02.16.20.12.53;	author jason;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.02.19.17.18.38;	author jason;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.03.21.19.46.22;	author jason;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.05.07.21.09.26;	author jason;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2002.03.08.17.04.41;	author brad;	state Exp;
branches;
next	;

1.22.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.03.09.00.20.43;	author miod;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2002.06.02.22.56.09;	author miod;	state Exp;
branches;
next	;

1.25.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2002.06.22.07.23.16;	author miod;	state Exp;
branches;
next	1.25.2.4;

1.25.2.4
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.40.2.1
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.40.2.3;

1.40.2.3
date	2003.04.03.22.35.16;	author miod;	state Exp;
branches;
next	;

1.44.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2003.09.16.21.20.24;	author brad;	state Exp;
branches;
next	;

1.47.2.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.52.2.1
date	2004.02.28.03.51.32;	author brad;	state Exp;
branches;
next	1.52.2.2;

1.52.2.2
date	2004.08.19.22.37.30;	author brad;	state Exp;
branches;
next	;

1.55.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	;

1.59.2.1
date	2005.09.02.03.44.59;	author brad;	state Exp;
branches;
next	;

1.59.4.1
date	2005.09.04.18.39.56;	author brad;	state Exp;
branches;
next	;

1.62.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.62.4.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.83
log
@remove ssh1 server code; ok djm@@
@
text
@/* $OpenBSD: auth1.c,v 1.82 2014/07/15 15:54:14 millert Exp $ */
/*
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <pwd.h>

#include "xmalloc.h"
#include "rsa.h"
#include "ssh1.h"
#include "packet.h"
#include "buffer.h"
#include "log.h"
#include "misc.h"
#include "servconf.h"
#include "compat.h"
#include "key.h"
#include "hostfile.h"
#include "auth.h"
#include "channels.h"
#include "session.h"
#include "uidswap.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"

/* import */
extern ServerOptions options;

static int auth1_process_password(Authctxt *);
static int auth1_process_rsa(Authctxt *);
static int auth1_process_rhosts_rsa(Authctxt *);
static int auth1_process_tis_challenge(Authctxt *);
static int auth1_process_tis_response(Authctxt *);

struct AuthMethod1 {
	int type;
	char *name;
	int *enabled;
	int (*method)(Authctxt *);
};

const struct AuthMethod1 auth1_methods[] = {
	{
		SSH_CMSG_AUTH_PASSWORD, "password",
		&options.password_authentication, auth1_process_password
	},
	{
		SSH_CMSG_AUTH_RSA, "rsa",
		&options.rsa_authentication, auth1_process_rsa
	},
	{
		SSH_CMSG_AUTH_RHOSTS_RSA, "rhosts-rsa",
		&options.rhosts_rsa_authentication, auth1_process_rhosts_rsa
	},
	{
		SSH_CMSG_AUTH_TIS, "challenge-response",
		&options.challenge_response_authentication,
		auth1_process_tis_challenge
	},
	{
		SSH_CMSG_AUTH_TIS_RESPONSE, "challenge-response",
		&options.challenge_response_authentication,
		auth1_process_tis_response
	},
	{ -1, NULL, NULL, NULL}
};

static const struct AuthMethod1
*lookup_authmethod1(int type)
{
	int i;

	for (i = 0; auth1_methods[i].name != NULL; i++)
		if (auth1_methods[i].type == type)
			return (&(auth1_methods[i]));

	return (NULL);
}

static char *
get_authname(int type)
{
	const struct AuthMethod1 *a;
	static char buf[64];

	if ((a = lookup_authmethod1(type)) != NULL)
		return (a->name);
	snprintf(buf, sizeof(buf), "bad-auth-msg-%d", type);
	return (buf);
}

/*ARGSUSED*/
static int
auth1_process_password(Authctxt *authctxt)
{
	int authenticated = 0;
	char *password;
	u_int dlen;

	/*
	 * Read user password.  It is in plain text, but was
	 * transmitted over the encrypted channel so it is
	 * not visible to an outside observer.
	 */
	password = packet_get_string(&dlen);
	packet_check_eom();

	/* Try authentication with the password. */
	authenticated = PRIVSEP(auth_password(authctxt, password));

	explicit_bzero(password, dlen);
	free(password);

	return (authenticated);
}

/*ARGSUSED*/
static int
auth1_process_rsa(Authctxt *authctxt)
{
	int authenticated = 0;
	BIGNUM *n;

	/* RSA authentication requested. */
	if ((n = BN_new()) == NULL)
		fatal("do_authloop: BN_new failed");
	packet_get_bignum(n);
	packet_check_eom();
	authenticated = auth_rsa(authctxt, n);
	BN_clear_free(n);

	return (authenticated);
}

/*ARGSUSED*/
static int
auth1_process_rhosts_rsa(Authctxt *authctxt)
{
	int keybits, authenticated = 0;
	u_int bits;
	char *client_user;
	Key *client_host_key;
	u_int ulen;

	/*
	 * Get client user name.  Note that we just have to
	 * trust the client; root on the client machine can
	 * claim to be any user.
	 */
	client_user = packet_get_cstring(&ulen);

	/* Get the client host key. */
	client_host_key = key_new(KEY_RSA1);
	bits = packet_get_int();
	packet_get_bignum(client_host_key->rsa->e);
	packet_get_bignum(client_host_key->rsa->n);

	keybits = BN_num_bits(client_host_key->rsa->n);
	if (keybits < 0 || bits != (u_int)keybits) {
		verbose("Warning: keysize mismatch for client_host_key: "
		    "actual %d, announced %d",
		    BN_num_bits(client_host_key->rsa->n), bits);
	}
	packet_check_eom();

	authenticated = auth_rhosts_rsa(authctxt, client_user,
	    client_host_key);
	key_free(client_host_key);

	auth_info(authctxt, "ruser %.100s", client_user);
	free(client_user);

	return (authenticated);
}

/*ARGSUSED*/
static int
auth1_process_tis_challenge(Authctxt *authctxt)
{
	char *challenge;

	if ((challenge = get_challenge(authctxt)) == NULL)
		return (0);

	debug("sending challenge '%s'", challenge);
	packet_start(SSH_SMSG_AUTH_TIS_CHALLENGE);
	packet_put_cstring(challenge);
	free(challenge);
	packet_send();
	packet_write_wait();

	return (-1);
}

/*ARGSUSED*/
static int
auth1_process_tis_response(Authctxt *authctxt)
{
	int authenticated = 0;
	char *response;
	u_int dlen;

	response = packet_get_string(&dlen);
	packet_check_eom();
	authenticated = verify_response(authctxt, response);
	explicit_bzero(response, dlen);
	free(response);

	return (authenticated);
}

/*
 * read packets, try to authenticate the user and
 * return only if authentication is successful
 */
static void
do_authloop(Authctxt *authctxt)
{
	int authenticated = 0;
	int type = 0;
	const struct AuthMethod1 *meth;

	debug("Attempting authentication for %s%.100s.",
	    authctxt->valid ? "" : "invalid user ", authctxt->user);

	/* If the user has no password, accept authentication immediately. */
	if (options.permit_empty_passwd && options.password_authentication &&
#ifdef KRB5
	    (!options.kerberos_authentication || options.kerberos_or_local_passwd) &&
#endif
	    PRIVSEP(auth_password(authctxt, ""))) {
		auth_log(authctxt, 1, 0, "without authentication", NULL);
		return;
	}

	/* Indicate that authentication is needed. */
	packet_start(SSH_SMSG_FAILURE);
	packet_send();
	packet_write_wait();

	for (;;) {
		/* default to fail */
		authenticated = 0;


		/* Get a packet from the client. */
		type = packet_read();
		if (authctxt->failures >= options.max_authtries)
			goto skip;
		if ((meth = lookup_authmethod1(type)) == NULL) {
			logit("Unknown message during authentication: "
			    "type %d", type);
			goto skip;
		}

		if (!*(meth->enabled)) {
			verbose("%s authentication disabled.", meth->name);
			goto skip;
		}

		authenticated = meth->method(authctxt);
		if (authenticated == -1)
			continue; /* "postponed" */

		if (authctxt->as) {
			auth_close(authctxt->as);
			authctxt->as = NULL;
		}
		if (!authctxt->valid && authenticated)
			fatal("INTERNAL ERROR: authenticated invalid user %s",
			    authctxt->user);

		/* Special handling for root */
		if (authenticated && authctxt->pw->pw_uid == 0 &&
		    !auth_root_allowed(meth->name))
			authenticated = 0;

 skip:
		/* Log before sending the reply */
		auth_log(authctxt, authenticated, 0, get_authname(type), NULL);

		if (authenticated)
			return;

		if (++authctxt->failures >= options.max_authtries)
			auth_maxtries_exceeded(authctxt);

		packet_start(SSH_SMSG_FAILURE);
		packet_send();
		packet_write_wait();
	}
}

/*
 * Performs authentication of an incoming connection.  Session key has already
 * been exchanged and encryption is enabled.
 */
void
do_authentication(Authctxt *authctxt)
{
	u_int ulen;
	char *user, *style = NULL;

	/* Get the name of the user that we wish to log in as. */
	packet_read_expect(SSH_CMSG_USER);

	/* Get the user name. */
	user = packet_get_cstring(&ulen);
	packet_check_eom();

	if ((style = strchr(user, ':')) != NULL)
		*style++ = '\0';

	authctxt->user = user;
	authctxt->style = style;

	/* Verify that the user is a valid user. */
	if ((authctxt->pw = PRIVSEP(getpwnamallow(user))) != NULL)
		authctxt->valid = 1;
	else {
		debug("do_authentication: invalid user %s", user);
		authctxt->pw = fakepw();
	}

	/* Configuration may have changed as a result of Match */
	if (options.num_auth_methods != 0)
		fatal("AuthenticationMethods is not supported with SSH "
		    "protocol 1");

	setproctitle("%s%s", authctxt->valid ? user : "unknown",
	    use_privsep ? " [net]" : "");

	/*
	 * If we are not running as root, the user must have the same uid as
	 * the server.
	 */
	if (!use_privsep && getuid() != 0 && authctxt->pw &&
	    authctxt->pw->pw_uid != getuid())
		packet_disconnect("Cannot change user when server not running as root.");

	/*
	 * Loop until the user has been authenticated or the connection is
	 * closed, do_authloop() returns only if authentication is successful
	 */
	do_authloop(authctxt);

	/* The user has been authenticated and accepted. */
	packet_start(SSH_SMSG_SUCCESS);
	packet_send();
	packet_write_wait();
}
@


1.82
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.81 2014/07/03 11:16:55 djm Exp $ */
@


1.81
log
@make the "Too many authentication failures" message include the
user, source address, port and protocol in a format similar to the
authentication success / failure messages; bz#2199, ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.80 2014/02/02 03:44:31 djm Exp $ */
d27 1
@


1.80
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.79 2013/05/19 02:42:42 djm Exp $ */
d300 1
a300 1
			packet_disconnect(AUTH_FAIL_MSG, authctxt->user);
@


1.79
log
@Standardise logging of supplemental information during userauth. Keys
and ruser is now logged in the auth success/failure message alongside
the local username, remote host/port and protocol in use. Certificates
contents and CA are logged too.

Pushing all logging onto a single line simplifies log analysis as it is
no longer necessary to relate information scattered across multiple log
entries. "I like it" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.78 2013/05/17 00:13:13 djm Exp $ */
d125 1
a125 1
	memset(password, 0, dlen);
d220 1
a220 1
	memset(response, 'r', dlen);
@


1.78
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.77 2012/12/02 20:34:09 djm Exp $ */
d43 5
a47 5
static int auth1_process_password(Authctxt *, char *, size_t);
static int auth1_process_rsa(Authctxt *, char *, size_t);
static int auth1_process_rhosts_rsa(Authctxt *, char *, size_t);
static int auth1_process_tis_challenge(Authctxt *, char *, size_t);
static int auth1_process_tis_response(Authctxt *, char *, size_t);
d53 1
a53 1
	int (*method)(Authctxt *, char *, size_t);
d108 1
a108 1
auth1_process_password(Authctxt *authctxt, char *info, size_t infolen)
d133 1
a133 1
auth1_process_rsa(Authctxt *authctxt, char *info, size_t infolen)
d151 1
a151 1
auth1_process_rhosts_rsa(Authctxt *authctxt, char *info, size_t infolen)
d184 1
a184 1
	snprintf(info, infolen, " ruser %.100s", client_user);
d192 1
a192 1
auth1_process_tis_challenge(Authctxt *authctxt, char *info, size_t infolen)
d211 1
a211 1
auth1_process_tis_response(Authctxt *authctxt, char *info, size_t infolen)
a233 1
	char info[1024];
d246 1
a246 1
		auth_log(authctxt, 1, 0, "without authentication", NULL, "");
a258 1
		info[0] = '\0';
d275 1
a275 1
		authenticated = meth->method(authctxt, info, sizeof(info));
d294 1
a294 2
		auth_log(authctxt, authenticated, 0, get_authname(type),
		    NULL, info);
@


1.77
log
@Fixes logging of partial authentication when privsep is enabled
Previously, we recorded "Failed xxx" since we reset authenticated before
calling auth_log() in auth2.c. This adds an explcit "Partial" state.

Add a "submethod" to auth_log() to report which submethod is used
for keyboard-interactive.

Fix multiple authentication when one of the methods is
keyboard-interactive.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.76 2012/11/04 11:09:15 djm Exp $ */
d126 1
a126 1
	xfree(password);
d185 1
a185 1
	xfree(client_user);
d202 1
a202 1
	xfree(challenge);
d221 1
a221 1
	xfree(response);
@


1.76
log
@Support multiple required authentication via an AuthenticationMethods
option. This option lists one or more comma-separated lists of
authentication method names. Successful completion of all the methods in
any list is required for authentication to complete;
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.75 2010/08/31 09:58:37 djm Exp $ */
d247 1
a247 1
		auth_log(authctxt, 1, "without authentication", "");
d296 2
a297 1
		auth_log(authctxt, authenticated, get_authname(type), info);
@


1.75
log
@Add buffer_get_cstring() and related functions that verify that the
string extracted from the buffer contains no embedded \0 characters*
This prevents random (possibly malicious) crap from being appended to
strings where it would not be noticed if the string is used with
a string(3) function.

Use the new API in a few sensitive places.

* actually, we allow a single one at the end of the string for now because
we don't know how many deployed implementations get this wrong, but don't
count on this to remain indefinitely.
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.74 2010/06/25 08:46:17 djm Exp $ */
d340 5
@


1.74
log
@skip the initial check for access with an empty password when
PermitEmptyPasswords=no;
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.73 2008/07/04 23:30:16 djm Exp $ */
d164 1
a164 1
	client_user = packet_get_string(&ulen);
d324 1
a324 1
	user = packet_get_string(&ulen);
@


1.73
log
@Make protocol 1 MaxAuthTries logic match protocol 2's.

Do not treat the first protocol 2 authentication attempt as
a failure IFF it is for method "none".

Makes MaxAuthTries' user-visible behaviour identical for
protocol 1 vs 2.

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.72 2008/05/08 12:02:23 djm Exp $ */
d242 1
a242 1
	if (options.password_authentication &&
@


1.72
log
@Implement a channel success/failure status confirmation callback
mechanism. Each channel maintains a queue of callbacks, which will
be drained in order (RFC4253 guarantees confirm messages are not
reordered within an channel).

Also includes a abandonment callback to clean up if a channel is
closed without sending confirmation messages. This probably
shouldn't happen in compliant implementations, but it could be
abused to leak memory.

ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.71 2007/09/21 08:15:29 djm Exp $ */
d264 2
d301 1
a301 1
		if (authctxt->failures++ > options.max_authtries)
@


1.71
log
@unifdef -DBSD_AUTH
unifdef -USKEY

These options have been in use for some years;
ok markus@@ "no objection" millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.70 2006/08/03 03:34:41 deraadt Exp $ */
d14 1
@


1.70
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.69 2006/08/01 23:22:47 stevesk Exp $ */
a277 1
#ifdef BSD_AUTH
a281 1
#endif
@


1.69
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.68 2006/07/22 20:48:22 stevesk Exp $ */
a12 2
#include "includes.h"

d18 1
d28 2
d34 3
@


1.68
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.67 2006/07/20 15:26:14 stevesk Exp $ */
d17 1
@


1.67
log
@missed some needed #include <unistd.h> when KERBEROS5=no; issue from
massimo@@cedoc.mo.it
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.66 2006/03/25 13:17:01 djm Exp $ */
d17 1
@


1.66
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d14 4
@


1.65
log
@sprinkle some ARGSUSED for table driven functions (which sometimes must ignore their args)
@
text
@d1 1
@


1.64
log
@spacing
@
text
@d94 1
d119 1
d137 1
d178 1
d197 1
@


1.63
log
@RCSID() can die
@
text
@d75 1
a75 1
	for(i = 0; auth1_methods[i].name != NULL; i++)
@


1.62
log
@spacing
@
text
@a12 1
RCSID("$OpenBSD: auth1.c,v 1.61 2005/06/17 02:44:32 djm Exp $");
@


1.62.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth1.c,v 1.70 2006/08/03 03:34:41 deraadt Exp $ */
d12 2
a13 6
#include <sys/types.h>

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <pwd.h>
a22 2
#include "key.h"
#include "hostfile.h"
a26 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
d76 1
a76 1
	for (i = 0; auth1_methods[i].name != NULL; i++)
a94 1
/*ARGSUSED*/
a118 1
/*ARGSUSED*/
a135 1
/*ARGSUSED*/
a175 1
/*ARGSUSED*/
a193 1
/*ARGSUSED*/
@


1.62.4.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth1.c,v 1.70 2006/08/03 03:34:41 deraadt Exp $ */
d12 2
a13 6
#include <sys/types.h>

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <pwd.h>
a22 2
#include "key.h"
#include "hostfile.h"
a26 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
d76 1
a76 1
	for (i = 0; auth1_methods[i].name != NULL; i++)
a94 1
/*ARGSUSED*/
a118 1
/*ARGSUSED*/
a135 1
/*ARGSUSED*/
a175 1
/*ARGSUSED*/
a193 1
/*ARGSUSED*/
@


1.61
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.60 2005/05/20 12:57:01 djm Exp $");
d172 1
a172 1
	
d180 1
a180 1
	
@


1.60
log
@split protocol 1 auth methods into separate functions, makes authloop
much more readable; fixes and ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.59 2004/07/28 09:40:29 markus Exp $");
d139 1
a139 1
	int authenticated = 0;
d158 2
a159 1
	if (bits != BN_num_bits(client_host_key->rsa->n)) {
@


1.59
log
@more s/illegal/invalid/
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.58 2004/07/21 10:33:31 djm Exp $");
d32 51
a82 3
/*
 * convert ssh auth msg type into description
 */
d86 76
a161 13
	static char buf[1024];
	switch (type) {
	case SSH_CMSG_AUTH_PASSWORD:
		return "password";
	case SSH_CMSG_AUTH_RSA:
		return "rsa";
	case SSH_CMSG_AUTH_RHOSTS_RSA:
		return "rhosts-rsa";
	case SSH_CMSG_AUTH_RHOSTS:
		return "rhosts";
	case SSH_CMSG_AUTH_TIS:
	case SSH_CMSG_AUTH_TIS_RESPONSE:
		return "challenge-response";
d163 44
a206 2
	snprintf(buf, sizeof buf, "bad-auth-msg-%d", type);
	return buf;
a216 4
	u_int bits;
	Key *client_host_key;
	BIGNUM *n;
	char *client_user, *password;
a217 2
	u_int dlen;
	u_int ulen;
d219 1
d247 5
d253 3
a255 101
		/* Process the packet. */
		switch (type) {
		case SSH_CMSG_AUTH_RHOSTS_RSA:
			if (!options.rhosts_rsa_authentication) {
				verbose("Rhosts with RSA authentication disabled.");
				break;
			}
			/*
			 * Get client user name.  Note that we just have to
			 * trust the client; root on the client machine can
			 * claim to be any user.
			 */
			client_user = packet_get_string(&ulen);

			/* Get the client host key. */
			client_host_key = key_new(KEY_RSA1);
			bits = packet_get_int();
			packet_get_bignum(client_host_key->rsa->e);
			packet_get_bignum(client_host_key->rsa->n);

			if (bits != BN_num_bits(client_host_key->rsa->n))
				verbose("Warning: keysize mismatch for client_host_key: "
				    "actual %d, announced %d",
				    BN_num_bits(client_host_key->rsa->n), bits);
			packet_check_eom();

			authenticated = auth_rhosts_rsa(authctxt, client_user,
			    client_host_key);
			key_free(client_host_key);

			snprintf(info, sizeof info, " ruser %.100s", client_user);
			xfree(client_user);
			break;

		case SSH_CMSG_AUTH_RSA:
			if (!options.rsa_authentication) {
				verbose("RSA authentication disabled.");
				break;
			}
			/* RSA authentication requested. */
			if ((n = BN_new()) == NULL)
				fatal("do_authloop: BN_new failed");
			packet_get_bignum(n);
			packet_check_eom();
			authenticated = auth_rsa(authctxt, n);
			BN_clear_free(n);
			break;

		case SSH_CMSG_AUTH_PASSWORD:
			if (!options.password_authentication) {
				verbose("Password authentication disabled.");
				break;
			}
			/*
			 * Read user password.  It is in plain text, but was
			 * transmitted over the encrypted channel so it is
			 * not visible to an outside observer.
			 */
			password = packet_get_string(&dlen);
			packet_check_eom();

			/* Try authentication with the password. */
			authenticated = PRIVSEP(auth_password(authctxt, password));

			memset(password, 0, strlen(password));
			xfree(password);
			break;

		case SSH_CMSG_AUTH_TIS:
			debug("rcvd SSH_CMSG_AUTH_TIS");
			if (options.challenge_response_authentication == 1) {
				char *challenge = get_challenge(authctxt);
				if (challenge != NULL) {
					debug("sending challenge '%s'", challenge);
					packet_start(SSH_SMSG_AUTH_TIS_CHALLENGE);
					packet_put_cstring(challenge);
					xfree(challenge);
					packet_send();
					packet_write_wait();
					continue;
				}
			}
			break;
		case SSH_CMSG_AUTH_TIS_RESPONSE:
			debug("rcvd SSH_CMSG_AUTH_TIS_RESPONSE");
			if (options.challenge_response_authentication == 1) {
				char *response = packet_get_string(&dlen);
				packet_check_eom();
				authenticated = verify_response(authctxt, response);
				memset(response, 'r', dlen);
				xfree(response);
			}
			break;

		default:
			/*
			 * Any unknown messages will be ignored (and failure
			 * returned) during authentication.
			 */
			logit("Unknown message during authentication: type %d", type);
			break;
d257 5
d274 1
a274 1
		    !auth_root_allowed(get_authname(type)))
d277 1
@


1.59.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.62 2005/07/16 01:35:24 djm Exp $");
d32 3
a34 51
static int auth1_process_password(Authctxt *, char *, size_t);
static int auth1_process_rsa(Authctxt *, char *, size_t);
static int auth1_process_rhosts_rsa(Authctxt *, char *, size_t);
static int auth1_process_tis_challenge(Authctxt *, char *, size_t);
static int auth1_process_tis_response(Authctxt *, char *, size_t);

struct AuthMethod1 {
	int type;
	char *name;
	int *enabled;
	int (*method)(Authctxt *, char *, size_t);
};

const struct AuthMethod1 auth1_methods[] = {
	{
		SSH_CMSG_AUTH_PASSWORD, "password",
		&options.password_authentication, auth1_process_password
	},
	{
		SSH_CMSG_AUTH_RSA, "rsa",
		&options.rsa_authentication, auth1_process_rsa
	},
	{
		SSH_CMSG_AUTH_RHOSTS_RSA, "rhosts-rsa",
		&options.rhosts_rsa_authentication, auth1_process_rhosts_rsa
	},
	{
		SSH_CMSG_AUTH_TIS, "challenge-response",
		&options.challenge_response_authentication,
		auth1_process_tis_challenge
	},
	{
		SSH_CMSG_AUTH_TIS_RESPONSE, "challenge-response",
		&options.challenge_response_authentication,
		auth1_process_tis_response
	},
	{ -1, NULL, NULL, NULL}
};

static const struct AuthMethod1
*lookup_authmethod1(int type)
{
	int i;

	for(i = 0; auth1_methods[i].name != NULL; i++)
		if (auth1_methods[i].type == type)
			return (&(auth1_methods[i]));

	return (NULL);
}

d38 13
a50 77
	const struct AuthMethod1 *a;
	static char buf[64];

	if ((a = lookup_authmethod1(type)) != NULL)
		return (a->name);
	snprintf(buf, sizeof(buf), "bad-auth-msg-%d", type);
	return (buf);
}

static int
auth1_process_password(Authctxt *authctxt, char *info, size_t infolen)
{
	int authenticated = 0;
	char *password;
	u_int dlen;

	/*
	 * Read user password.  It is in plain text, but was
	 * transmitted over the encrypted channel so it is
	 * not visible to an outside observer.
	 */
	password = packet_get_string(&dlen);
	packet_check_eom();

	/* Try authentication with the password. */
	authenticated = PRIVSEP(auth_password(authctxt, password));

	memset(password, 0, dlen);
	xfree(password);

	return (authenticated);
}

static int
auth1_process_rsa(Authctxt *authctxt, char *info, size_t infolen)
{
	int authenticated = 0;
	BIGNUM *n;

	/* RSA authentication requested. */
	if ((n = BN_new()) == NULL)
		fatal("do_authloop: BN_new failed");
	packet_get_bignum(n);
	packet_check_eom();
	authenticated = auth_rsa(authctxt, n);
	BN_clear_free(n);

	return (authenticated);
}

static int
auth1_process_rhosts_rsa(Authctxt *authctxt, char *info, size_t infolen)
{
	int keybits, authenticated = 0;
	u_int bits;
	char *client_user;
	Key *client_host_key;
	u_int ulen;

	/*
	 * Get client user name.  Note that we just have to
	 * trust the client; root on the client machine can
	 * claim to be any user.
	 */
	client_user = packet_get_string(&ulen);

	/* Get the client host key. */
	client_host_key = key_new(KEY_RSA1);
	bits = packet_get_int();
	packet_get_bignum(client_host_key->rsa->e);
	packet_get_bignum(client_host_key->rsa->n);

	keybits = BN_num_bits(client_host_key->rsa->n);
	if (keybits < 0 || bits != (u_int)keybits) {
		verbose("Warning: keysize mismatch for client_host_key: "
		    "actual %d, announced %d",
		    BN_num_bits(client_host_key->rsa->n), bits);
d52 2
a53 44
	packet_check_eom();

	authenticated = auth_rhosts_rsa(authctxt, client_user,
	    client_host_key);
	key_free(client_host_key);

	snprintf(info, infolen, " ruser %.100s", client_user);
	xfree(client_user);

	return (authenticated);
}

static int
auth1_process_tis_challenge(Authctxt *authctxt, char *info, size_t infolen)
{
	char *challenge;

	if ((challenge = get_challenge(authctxt)) == NULL)
		return (0);

	debug("sending challenge '%s'", challenge);
	packet_start(SSH_SMSG_AUTH_TIS_CHALLENGE);
	packet_put_cstring(challenge);
	xfree(challenge);
	packet_send();
	packet_write_wait();

	return (-1);
}

static int
auth1_process_tis_response(Authctxt *authctxt, char *info, size_t infolen)
{
	int authenticated = 0;
	char *response;
	u_int dlen;

	response = packet_get_string(&dlen);
	packet_check_eom();
	authenticated = verify_response(authctxt, response);
	memset(response, 'r', dlen);
	xfree(response);

	return (authenticated);
d64 4
d69 2
a71 1
	const struct AuthMethod1 *meth;
a98 5
		if ((meth = lookup_authmethod1(type)) == NULL) {
			logit("Unknown message during authentication: "
			    "type %d", type);
			goto skip;
		}
d100 101
a200 3
		if (!*(meth->enabled)) {
			verbose("%s authentication disabled.", meth->name);
			goto skip;
a201 5

		authenticated = meth->method(authctxt, info, sizeof(info));
		if (authenticated == -1)
			continue; /* "postponed" */

d214 1
a214 1
		    !auth_root_allowed(meth->name))
a216 1
 skip:
@


1.59.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.62 2005/07/16 01:35:24 djm Exp $");
d32 3
a34 51
static int auth1_process_password(Authctxt *, char *, size_t);
static int auth1_process_rsa(Authctxt *, char *, size_t);
static int auth1_process_rhosts_rsa(Authctxt *, char *, size_t);
static int auth1_process_tis_challenge(Authctxt *, char *, size_t);
static int auth1_process_tis_response(Authctxt *, char *, size_t);

struct AuthMethod1 {
	int type;
	char *name;
	int *enabled;
	int (*method)(Authctxt *, char *, size_t);
};

const struct AuthMethod1 auth1_methods[] = {
	{
		SSH_CMSG_AUTH_PASSWORD, "password",
		&options.password_authentication, auth1_process_password
	},
	{
		SSH_CMSG_AUTH_RSA, "rsa",
		&options.rsa_authentication, auth1_process_rsa
	},
	{
		SSH_CMSG_AUTH_RHOSTS_RSA, "rhosts-rsa",
		&options.rhosts_rsa_authentication, auth1_process_rhosts_rsa
	},
	{
		SSH_CMSG_AUTH_TIS, "challenge-response",
		&options.challenge_response_authentication,
		auth1_process_tis_challenge
	},
	{
		SSH_CMSG_AUTH_TIS_RESPONSE, "challenge-response",
		&options.challenge_response_authentication,
		auth1_process_tis_response
	},
	{ -1, NULL, NULL, NULL}
};

static const struct AuthMethod1
*lookup_authmethod1(int type)
{
	int i;

	for(i = 0; auth1_methods[i].name != NULL; i++)
		if (auth1_methods[i].type == type)
			return (&(auth1_methods[i]));

	return (NULL);
}

d38 13
a50 77
	const struct AuthMethod1 *a;
	static char buf[64];

	if ((a = lookup_authmethod1(type)) != NULL)
		return (a->name);
	snprintf(buf, sizeof(buf), "bad-auth-msg-%d", type);
	return (buf);
}

static int
auth1_process_password(Authctxt *authctxt, char *info, size_t infolen)
{
	int authenticated = 0;
	char *password;
	u_int dlen;

	/*
	 * Read user password.  It is in plain text, but was
	 * transmitted over the encrypted channel so it is
	 * not visible to an outside observer.
	 */
	password = packet_get_string(&dlen);
	packet_check_eom();

	/* Try authentication with the password. */
	authenticated = PRIVSEP(auth_password(authctxt, password));

	memset(password, 0, dlen);
	xfree(password);

	return (authenticated);
}

static int
auth1_process_rsa(Authctxt *authctxt, char *info, size_t infolen)
{
	int authenticated = 0;
	BIGNUM *n;

	/* RSA authentication requested. */
	if ((n = BN_new()) == NULL)
		fatal("do_authloop: BN_new failed");
	packet_get_bignum(n);
	packet_check_eom();
	authenticated = auth_rsa(authctxt, n);
	BN_clear_free(n);

	return (authenticated);
}

static int
auth1_process_rhosts_rsa(Authctxt *authctxt, char *info, size_t infolen)
{
	int keybits, authenticated = 0;
	u_int bits;
	char *client_user;
	Key *client_host_key;
	u_int ulen;

	/*
	 * Get client user name.  Note that we just have to
	 * trust the client; root on the client machine can
	 * claim to be any user.
	 */
	client_user = packet_get_string(&ulen);

	/* Get the client host key. */
	client_host_key = key_new(KEY_RSA1);
	bits = packet_get_int();
	packet_get_bignum(client_host_key->rsa->e);
	packet_get_bignum(client_host_key->rsa->n);

	keybits = BN_num_bits(client_host_key->rsa->n);
	if (keybits < 0 || bits != (u_int)keybits) {
		verbose("Warning: keysize mismatch for client_host_key: "
		    "actual %d, announced %d",
		    BN_num_bits(client_host_key->rsa->n), bits);
d52 2
a53 44
	packet_check_eom();

	authenticated = auth_rhosts_rsa(authctxt, client_user,
	    client_host_key);
	key_free(client_host_key);

	snprintf(info, infolen, " ruser %.100s", client_user);
	xfree(client_user);

	return (authenticated);
}

static int
auth1_process_tis_challenge(Authctxt *authctxt, char *info, size_t infolen)
{
	char *challenge;

	if ((challenge = get_challenge(authctxt)) == NULL)
		return (0);

	debug("sending challenge '%s'", challenge);
	packet_start(SSH_SMSG_AUTH_TIS_CHALLENGE);
	packet_put_cstring(challenge);
	xfree(challenge);
	packet_send();
	packet_write_wait();

	return (-1);
}

static int
auth1_process_tis_response(Authctxt *authctxt, char *info, size_t infolen)
{
	int authenticated = 0;
	char *response;
	u_int dlen;

	response = packet_get_string(&dlen);
	packet_check_eom();
	authenticated = verify_response(authctxt, response);
	memset(response, 'r', dlen);
	xfree(response);

	return (authenticated);
d64 4
d69 2
a71 1
	const struct AuthMethod1 *meth;
a98 5
		if ((meth = lookup_authmethod1(type)) == NULL) {
			logit("Unknown message during authentication: "
			    "type %d", type);
			goto skip;
		}
d100 101
a200 3
		if (!*(meth->enabled)) {
			verbose("%s authentication disabled.", meth->name);
			goto skip;
a201 5

		authenticated = meth->method(authctxt, info, sizeof(info));
		if (authenticated == -1)
			continue; /* "postponed" */

d214 1
a214 1
		    !auth_root_allowed(meth->name))
a216 1
 skip:
@


1.58
log
@bz#899: Don't display invalid usernames in setproctitle
from peak AT argo.troja.mff.cuni.cz; ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.57 2004/05/23 23:59:53 dtucker Exp $");
d74 1
a74 1
	    authctxt->valid ? "" : "illegal user ", authctxt->user);
d259 1
a259 1
		debug("do_authentication: illegal user %s", user);
@


1.57
log
@Add MaxAuthTries sshd config option; ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.56 2004/05/09 01:19:27 djm Exp $");
d263 1
a263 1
	setproctitle("%s%s", authctxt->pw ? user : "unknown",
@


1.56
log
@kill some more tiny files; ok deraadt@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.55 2003/11/08 16:02:40 jakob Exp $");
d223 1
a223 1
		if (authctxt->failures++ > AUTH_FAIL_MAX)
@


1.55
log
@remove unused variable (pw). ok djm@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.54 2003/11/04 08:54:09 djm Exp $");
a19 1
#include "mpaux.h"
@


1.55.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.59 2004/07/28 09:40:29 markus Exp $");
d20 1
d75 1
a75 1
	    authctxt->valid ? "" : "invalid user ", authctxt->user);
d224 1
a224 1
		if (authctxt->failures++ > options.max_authtries)
d260 1
a260 1
		debug("do_authentication: invalid user %s", user);
d264 1
a264 1
	setproctitle("%s%s", authctxt->valid ? user : "unknown",
@


1.54
log
@standardise arguments to auth methods - they should all take authctxt.
check authctxt->valid rather then pw != NULL; ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.53 2003/09/23 20:17:11 markus Exp $");
a72 1
	struct passwd *pw = authctxt->pw;
@


1.53
log
@replace fatal_cleanup() and linked list of fatal callbacks with static
cleanup_exit() function.  re-refine cleanup_exit() where appropriate,
allocate sshd's authctxt eary to allow simpler cleanup in sshd.
tested by many, ok deraadt@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.52 2003/08/28 12:54:34 markus Exp $");
d128 1
a128 1
			authenticated = auth_rhosts_rsa(pw, client_user,
d146 1
a146 1
			authenticated = auth_rsa(pw, n);
@


1.52
log
@remove kerberos support from ssh1, since it has been replaced with GSSAPI;
but keep kerberos passwd auth for ssh1 and 2; ok djm, hin, henning, ...
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.51 2003/08/26 09:58:43 markus Exp $");
d238 2
a239 2
Authctxt *
do_authentication(void)
a240 1
	Authctxt *authctxt;
a253 1
	authctxt = authctxt_new();
a285 2

	return (authctxt);
@


1.52.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.55 2003/11/08 16:02:40 jakob Exp $");
d73 1
d128 1
a128 1
			authenticated = auth_rhosts_rsa(authctxt, client_user,
d146 1
a146 1
			authenticated = auth_rsa(authctxt, n);
d238 2
a239 2
void
do_authentication(Authctxt *authctxt)
d241 1
d255 1
d288 2
@


1.52.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.59 2004/07/28 09:40:29 markus Exp $");
d20 1
d75 1
a75 1
	    authctxt->valid ? "" : "invalid user ", authctxt->user);
d224 1
a224 1
		if (authctxt->failures++ > options.max_authtries)
d260 1
a260 1
		debug("do_authentication: invalid user %s", user);
d264 1
a264 1
	setproctitle("%s%s", authctxt->valid ? user : "unknown",
@


1.51
log
@fix passwd auth for 'username leaks via timing'; with djm@@, original patches from solar
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.50 2003/08/13 08:46:30 markus Exp $");
a51 4
#ifdef KRB5
	case SSH_CMSG_AUTH_KERBEROS:
		return "kerberos";
#endif
a103 42

#ifdef KRB5
		case SSH_CMSG_AUTH_KERBEROS:
			if (!options.kerberos_authentication) {
				verbose("Kerberos authentication disabled.");
			} else {
				char *kdata = packet_get_string(&dlen);
				packet_check_eom();

				if (kdata[0] != 4) { /* KRB_PROT_VERSION */
 					krb5_data tkt, reply;
					tkt.length = dlen;
					tkt.data = kdata;

					if (PRIVSEP(auth_krb5(authctxt, &tkt,
					    &client_user, &reply))) {
						authenticated = 1;
						snprintf(info, sizeof(info),
						    " tktuser %.100s",
						    client_user);

 						/* Send response to client */
 						packet_start(
						    SSH_SMSG_AUTH_KERBEROS_RESPONSE);
 						packet_put_string((char *)
						    reply.data, reply.length);
 						packet_send();
 						packet_write_wait();

 						if (reply.length)
 							xfree(reply.data);
						xfree(client_user);
					}
				}
				xfree(kdata);
			}
			break;
		case SSH_CMSG_HAVE_KERBEROS_TGT:
			packet_send_debug("Kerberos TGT passing disabled before authentication.");
			break;
#endif

a253 10

#ifdef KRB5
	/* XXX - SSH.com Kerberos v5 braindeath. */
	if ((datafellows & SSH_BUG_K5USER) &&
	    options.kerberos_authentication) {
		char *p;
		if ((p = strchr(user, '@@')) != NULL)
			*p = '\0';
	}
#endif
@


1.50
log
@remove RhostsAuthentication; suggested by djm@@ before; ok djm@@, deraadt@@,
fgsch@@, miod@@, henning@@, jakob@@ and others
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.49 2003/07/22 13:35:22 markus Exp $");
d318 1
a318 1
	else
d320 2
@


1.49
log
@remove (already disabled) KRB4/AFS support, re-enable -k in ssh(1);
test+ok henning@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.48 2003/04/08 20:21:28 itojun Exp $");
a148 21

		case SSH_CMSG_AUTH_RHOSTS:
			if (!options.rhosts_authentication) {
				verbose("Rhosts authentication disabled.");
				break;
			}
			/*
			 * Get client user name.  Note that we just have to
			 * trust the client; this is one reason why rhosts
			 * authentication is insecure. (Another is
			 * IP-spoofing on a local network.)
			 */
			client_user = packet_get_string(&ulen);
			packet_check_eom();

			/* Try to authenticate using /etc/hosts.equiv and .rhosts. */
			authenticated = auth_rhosts(pw, client_user);

			snprintf(info, sizeof info, " ruser %.100s", client_user);
			xfree(client_user);
			break;
@


1.48
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.47 2003/02/06 21:22:42 markus Exp $");
d52 1
a52 1
#if defined(KRB4) || defined(KRB5)
d84 1
a84 1
#if defined(KRB4) || defined(KRB5)
d109 1
a109 1
#if defined(KRB4) || defined(KRB5)
d117 1
a117 26
				if (kdata[0] == 4) { /* KRB_PROT_VERSION */
#ifdef KRB4
					KTEXT_ST tkt, reply;
					tkt.length = dlen;
					if (tkt.length < MAX_KTXT_LEN)
						memcpy(tkt.dat, kdata, tkt.length);

					if (PRIVSEP(auth_krb4(authctxt, &tkt,
					    &client_user, &reply))) {
						authenticated = 1;
						snprintf(info, sizeof(info),
						    " tktuser %.100s",
						    client_user);

						packet_start(
						    SSH_SMSG_AUTH_KERBEROS_RESPONSE);
						packet_put_string((char *)
						    reply.dat, reply.length);
						packet_send();
						packet_write_wait();

						xfree(client_user);
					}
#endif /* KRB4 */
				} else {
#ifdef KRB5
a140 1
#endif /* KRB5 */
a144 4
#endif /* KRB4 || KRB5 */

#if defined(AFS) || defined(KRB5)
			/* XXX - punt on backward compatibility here. */
d148 1
a148 6
#ifdef AFS
		case SSH_CMSG_HAVE_AFS_TOKEN:
			packet_send_debug("AFS token passing disabled before authentication.");
			break;
#endif /* AFS */
#endif /* AFS || KRB5 */
@


1.47
log
@undo broken fix for #387, fixes #486
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.46 2003/01/23 00:03:00 djm Exp $");
d303 1
a303 1
			log("Unknown message during authentication: type %d", type);
@


1.47.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.52 2003/08/28 12:54:34 markus Exp $");
d52 4
d84 1
a84 1
#ifdef KRB5
d108 98
d303 1
a303 1
			logit("Unknown message during authentication: type %d", type);
d357 10
d374 1
a374 1
	else {
a375 2
		authctxt->pw = fakepw();
	}
@


1.47.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.55 2003/11/08 16:02:40 jakob Exp $");
d73 1
d128 1
a128 1
			authenticated = auth_rhosts_rsa(authctxt, client_user,
d146 1
a146 1
			authenticated = auth_rsa(authctxt, n);
d238 2
a239 2
void
do_authentication(Authctxt *authctxt)
d241 1
d255 1
d288 2
@


1.46
log
@Don't log TIS auth response; "get rid of it" - markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.45 2002/11/21 23:03:51 deraadt Exp $");
d317 1
a317 2
		if (!use_privsep &&
		    authenticated && authctxt->pw->pw_uid == 0 &&
@


1.45
log
@KNF
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.44 2002/09/26 11:38:43 markus Exp $");
a290 1
				debug("got response '%s'", response);
@


1.44
log
@krb4 + privsep; ok dugsong@@, deraadt@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.43 2002/09/09 06:48:06 itojun Exp $");
d153 1
a153 1
 
@


1.44.2.1
log
@Update to OpenSSH 3.6
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.47 2003/02/06 21:22:42 markus Exp $");
d153 1
a153 1

d291 1
d318 2
a319 1
		if (authenticated && authctxt->pw->pw_uid == 0 &&
@


1.44.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.52 2003/08/28 12:54:34 markus Exp $");
d52 4
d84 1
a84 1
#ifdef KRB5
d108 98
d303 1
a303 1
			logit("Unknown message during authentication: type %d", type);
d357 10
d374 1
a374 1
	else {
a375 2
		authctxt->pw = fakepw();
	}
@


1.43
log
@kerberos support for privsep.  confirmed to work by lha@@stacken.kth.se
patch from markus
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.42 2002/08/22 21:33:58 markus Exp $");
d119 1
a119 2
					KTEXT_ST tkt;

d124 2
a125 1
					if (auth_krb4(authctxt, &tkt, &client_user)) {
d130 8
@


1.42
log
@auth_root_allowed() is handled by the monitor in the privsep case,
so skip this for use_privsep, ok stevesk@@, fixes bugzilla #387/325
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.41 2002/06/19 00:27:55 deraadt Exp $");
d135 1
a135 1
					krb5_data tkt;
d139 2
a140 1
					if (auth_krb5(authctxt, &tkt, &client_user)) {
d145 11
@


1.41
log
@KNF done automatically while reading....
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.40 2002/04/10 08:21:47 markus Exp $");
d298 2
a299 1
		if (authenticated && authctxt->pw->pw_uid == 0 &&
@


1.40
log
@strip '@@' from username only for KerbV and known broken clients, bug #204
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.39 2002/03/19 14:27:39 markus Exp $");
d207 1
a207 1
				     BN_num_bits(client_host_key->rsa->n), bits);
@


1.40.2.1
log
@Pull in OpenSSH-3.4
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.41 2002/06/19 00:27:55 deraadt Exp $");
d207 1
a207 1
				    BN_num_bits(client_host_key->rsa->n), bits);
@


1.40.2.2
log
@Update to OpenSSH 3.5
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.44 2002/09/26 11:38:43 markus Exp $");
d119 2
a120 1
					KTEXT_ST tkt, reply;
d125 1
a125 2
					if (PRIVSEP(auth_krb4(authctxt, &tkt,
					    &client_user, &reply))) {
a129 8

						packet_start(
						    SSH_SMSG_AUTH_KERBEROS_RESPONSE);
						packet_put_string((char *)
						    reply.dat, reply.length);
						packet_send();
						packet_write_wait();

d135 1
a135 1
 					krb5_data tkt, reply;
d139 1
a139 2
					if (PRIVSEP(auth_krb5(authctxt, &tkt,
					    &client_user, &reply))) {
a143 11
 
 						/* Send response to client */
 						packet_start(
						    SSH_SMSG_AUTH_KERBEROS_RESPONSE);
 						packet_put_string((char *)
						    reply.data, reply.length);
 						packet_send();
 						packet_write_wait();

 						if (reply.length)
 							xfree(reply.data);
d298 1
a298 2
		if (!use_privsep &&
		    authenticated && authctxt->pw->pw_uid == 0 &&
@


1.40.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.47 2003/02/06 21:22:42 markus Exp $");
d153 1
a153 1

d291 1
d318 2
a319 1
		if (authenticated && authctxt->pw->pw_uid == 0 &&
@


1.39
log
@make getpwnamallow() allways call pwcopy()
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.38 2002/03/18 17:50:31 provos Exp $");
d326 1
a326 1
	char *p, *user, *style = NULL;
d338 1
d340 7
a346 2
	if ((p = strchr(user, '@@')) != NULL)
		*p = '\0';
@


1.38
log
@integrate privilege separated openssh; its turned off by default for now.
work done by me and markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.35 2002/02/03 17:53:25 markus Exp $");
a26 1
#include "misc.h"
a324 1
	struct passwd *pw = NULL, *pwent;
d347 1
a347 2
	pwent = PRIVSEP(getpwnamallow(user));
	if (pwent) {
d349 1
a349 2
		pw = pwcopy(pwent);
	} else {
a350 7
		pw = NULL;
	}
	/* Free memory */
	if (use_privsep && pwent != NULL)
		pwfree(pwent);

	authctxt->pw = pw;
d352 1
a352 1
	setproctitle("%s%s", pw ? user : "unknown",
d359 2
a360 1
	if (!use_privsep && getuid() != 0 && pw && pw->pw_uid != getuid())
@


1.37
log
@have the authentication functions return the authentication context
and then do_authenticated; okay millert@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.36 2002/03/17 20:25:56 provos Exp $");
d29 1
d88 1
a88 1
	    auth_password(authctxt, "")) {
d247 1
a247 1
			authenticated = auth_password(authctxt, password);
d326 1
a326 1
	struct passwd *pw;
d349 2
a350 2
	pw = getpwnamallow(user);
	if (pw) {
d352 1
a352 1
		pw = pwcopy(pw);
d357 4
d363 2
a364 1
	setproctitle("%s", pw ? user : "unknown");
d370 1
a370 1
	if (getuid() != 0 && pw && pw->pw_uid != getuid())
@


1.36
log
@getpwnamallow returns struct passwd * only if user valid; okay markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.35 2002/02/03 17:53:25 markus Exp $");
d321 1
a321 1
void
d378 1
a378 2
	/* Perform session preparation. */
	do_authenticated(authctxt);
@


1.35
log
@don't use channel_input_channel_request and callback
use new server_input_channel_req() instead:
	server_input_channel_req does generic request parsing on server side
	session_input_channel_req handles just session specific things now
ok djm@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.34 2001/12/28 14:50:54 markus Exp $");
d348 2
a349 2
	pw = getpwnam(user);
	if (pw && allowed_user(pw)) {
@


1.34
log
@packet_read* no longer return the packet length, since it's not used.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.33 2001/12/28 13:57:33 markus Exp $");
d25 1
@


1.33
log
@packet_get_bignum* no longer returns a size
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.32 2001/12/28 12:14:27 markus Exp $");
a73 1
	int plen;
d103 1
a103 1
		type = packet_read(&plen);
a324 1
	int plen;
d329 1
a329 1
	packet_read_expect(&plen, SSH_CMSG_USER);
@


1.32
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.31 2001/12/27 20:39:58 markus Exp $");
d74 1
a74 1
	int plen, nlen, elen;
d201 2
a202 2
			packet_get_bignum(client_host_key->rsa->e, &elen);
			packet_get_bignum(client_host_key->rsa->n, &nlen);
d226 1
a226 1
			packet_get_bignum(n, &nlen);
@


1.31
log
@get rid of packet_integrity_check, use packet_done() instead.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.30 2001/12/27 19:54:53 markus Exp $");
d115 1
a115 1
				packet_done();
d177 1
a177 1
			packet_done();
d208 1
a208 1
			packet_done();
d227 1
a227 1
			packet_done();
d243 1
a243 1
			packet_done();
d272 1
a272 1
				packet_done();
d335 1
a335 1
	packet_done();
@


1.30
log
@auth_rhosts_rsa now accept generic keys.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.29 2001/12/27 18:22:16 markus Exp $");
d115 1
a115 2

				packet_integrity_check(plen, 4 + dlen, type);
d177 1
a177 1
			packet_integrity_check(plen, 4 + ulen, type);
d208 1
a208 1
			packet_integrity_check(plen, (4 + ulen) + 4 + elen + nlen, type);
d227 1
a227 1
			packet_integrity_check(plen, nlen, type);
d243 1
a243 1
			packet_integrity_check(plen, 4 + dlen, type);
d272 1
a272 1
				packet_integrity_check(plen, 4 + dlen, type);
d335 1
a335 1
	packet_integrity_check(plen, (4 + ulen), SSH_CMSG_USER);
@


1.29
log
@call fatal() for openssl allocation failures
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.28 2001/12/25 18:53:00 markus Exp $");
d212 1
a212 1
			    client_host_key->rsa);
@


1.28
log
@be more carefull on allocation
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.27 2001/12/19 07:18:56 deraadt Exp $");
d69 1
a69 1
	RSA *client_host_key;
d200 1
a200 7
			client_host_key = RSA_new();
			if (client_host_key == NULL)
				fatal("RSA_new failed");
			client_host_key->e = BN_new();
			client_host_key->n = BN_new();
			if (client_host_key->e == NULL || client_host_key->n == NULL)
				fatal("BN_new failed");
d202 2
a203 2
			packet_get_bignum(client_host_key->e, &elen);
			packet_get_bignum(client_host_key->n, &nlen);
d205 1
a205 1
			if (bits != BN_num_bits(client_host_key->n))
d207 2
a208 1
				    "actual %d, announced %d", BN_num_bits(client_host_key->n), bits);
d211 3
a213 2
			authenticated = auth_rhosts_rsa(pw, client_user, client_host_key);
			RSA_free(client_host_key);
d225 2
a226 3
			n = BN_new();
			if (n == NULL)
				fatal("BN_new failed");
@


1.27
log
@basic KNF done while i was looking for something else
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.26 2001/12/05 03:56:39 itojun Exp $");
d230 2
@


1.26
log
@make it compile with more strict prototype checking
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.25 2001/06/26 16:15:23 dugsong Exp $");
d80 1
a80 1
	     authctxt->valid ? "" : "illegal user ", authctxt->user);
d91 1
a91 1
	
d115 1
a115 1
				
d117 1
a117 1
				
d121 1
a121 1
					
d125 1
a125 1
					
d139 1
a139 1
					
d153 1
a153 1
			
d165 1
a165 1
			
d347 1
a347 1
	
@


1.25
log
@Kerberos v5 support for SSH1, mostly from Assar Westerlund <assar@@freebsd.org> and Bjorn Gronvall <bg@@sics.se>. markus@@ ok
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.24 2001/06/23 15:12:17 itojun Exp $");
d326 1
a326 1
do_authentication()
@


1.25.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.35 2002/02/03 17:53:25 markus Exp $");
a24 1
#include "channels.h"
d69 1
a69 1
	Key *client_host_key;
d74 1
d80 1
a80 1
	    authctxt->valid ? "" : "illegal user ", authctxt->user);
d91 1
a91 1

d104 1
a104 1
		type = packet_read();
d115 3
a117 2
				packet_check_eom();

d121 1
a121 1

d125 1
a125 1

d139 1
a139 1

d153 1
a153 1

d165 1
a165 1

d178 1
a178 1
			packet_check_eom();
d200 7
a206 1
			client_host_key = key_new(KEY_RSA1);
d208 2
a209 2
			packet_get_bignum(client_host_key->rsa->e);
			packet_get_bignum(client_host_key->rsa->n);
d211 1
a211 1
			if (bits != BN_num_bits(client_host_key->rsa->n))
d213 5
a217 7
				    "actual %d, announced %d",
				     BN_num_bits(client_host_key->rsa->n), bits);
			packet_check_eom();

			authenticated = auth_rhosts_rsa(pw, client_user,
			    client_host_key);
			key_free(client_host_key);
d229 3
a231 4
			if ((n = BN_new()) == NULL)
				fatal("do_authloop: BN_new failed");
			packet_get_bignum(n);
			packet_check_eom();
d247 1
a247 1
			packet_check_eom();
d276 1
a276 1
				packet_check_eom();
d326 1
a326 1
do_authentication(void)
d330 1
d335 1
a335 1
	packet_read_expect(SSH_CMSG_USER);
d339 1
a339 1
	packet_check_eom();
d347 1
a347 1

@


1.25.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.40 2002/04/10 08:21:47 markus Exp $");
d27 1
a28 1
#include "monitor_wrap.h"
d87 1
a87 1
	    PRIVSEP(auth_password(authctxt, ""))) {
d246 1
a246 1
			authenticated = PRIVSEP(auth_password(authctxt, password));
d321 1
a321 1
Authctxt *
d325 1
d327 1
a327 1
	char *user, *style = NULL;
a338 1
#ifdef KRB5
d340 2
a341 7
	if ((datafellows & SSH_BUG_K5USER) &&
	    options.kerberos_authentication) {
		char *p;
		if ((p = strchr(user, '@@')) != NULL)
			*p = '\0';
	}
#endif
d348 2
a349 1
	if ((authctxt->pw = PRIVSEP(getpwnamallow(user))) != NULL)
d351 2
a352 1
	else
d354 3
d358 1
a358 2
	setproctitle("%s%s", authctxt->pw ? user : "unknown",
	    use_privsep ? " [net]" : "");
d364 1
a364 2
	if (!use_privsep && getuid() != 0 && authctxt->pw &&
	    authctxt->pw->pw_uid != getuid())
d378 2
a379 1
	return (authctxt);
@


1.25.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.25.2.2 2002/05/17 00:03:23 miod Exp $");
d207 1
a207 1
				    BN_num_bits(client_host_key->rsa->n), bits);
@


1.25.2.4
log
@Update to OpenSSH 3.5
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.44 2002/09/26 11:38:43 markus Exp $");
d119 2
a120 1
					KTEXT_ST tkt, reply;
d125 1
a125 2
					if (PRIVSEP(auth_krb4(authctxt, &tkt,
					    &client_user, &reply))) {
a129 8

						packet_start(
						    SSH_SMSG_AUTH_KERBEROS_RESPONSE);
						packet_put_string((char *)
						    reply.dat, reply.length);
						packet_send();
						packet_write_wait();

d135 1
a135 1
 					krb5_data tkt, reply;
d139 1
a139 2
					if (PRIVSEP(auth_krb5(authctxt, &tkt,
					    &client_user, &reply))) {
a143 11
 
 						/* Send response to client */
 						packet_start(
						    SSH_SMSG_AUTH_KERBEROS_RESPONSE);
 						packet_put_string((char *)
						    reply.data, reply.length);
 						packet_send();
 						packet_write_wait();

 						if (reply.length)
 							xfree(reply.data);
d298 1
a298 2
		if (!use_privsep &&
		    authenticated && authctxt->pw->pw_uid == 0 &&
@


1.24
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.23 2001/05/18 14:13:28 markus Exp $");
d27 1
d51 1
a51 1
#ifdef KRB4
d84 1
a84 1
#ifdef KRB4
d91 1
a91 1

a107 14
#ifdef AFS
		case SSH_CMSG_HAVE_KERBEROS_TGT:
			if (!options.kerberos_tgt_passing) {
				verbose("Kerberos tgt passing disabled.");
				break;
			} else {
				/* Accept Kerberos tgt. */
				char *tgt = packet_get_string(&dlen);
				packet_integrity_check(plen, 4 + dlen, type);
				if (!auth_kerberos_tgt(pw, tgt))
					verbose("Kerberos tgt REFUSED for %.100s", authctxt->user);
				xfree(tgt);
			}
			continue;
d109 1
a109 15
		case SSH_CMSG_HAVE_AFS_TOKEN:
			if (!options.afs_token_passing || !k_hasafs()) {
				verbose("AFS token passing disabled.");
				break;
			} else {
				/* Accept AFS token. */
				char *token_string = packet_get_string(&dlen);
				packet_integrity_check(plen, 4 + dlen, type);
				if (!auth_afs_token(pw, token_string))
					verbose("AFS token REFUSED for %.100s", authctxt->user);
				xfree(token_string);
			}
			continue;
#endif /* AFS */
#ifdef KRB4
a112 1
				break;
d114 18
a131 14
				/* Try Kerberos v4 authentication. */
				KTEXT_ST auth;
				char *tkt_user = NULL;
				char *kdata = packet_get_string((u_int *) &auth.length);
				packet_integrity_check(plen, 4 + auth.length, type);

				if (authctxt->valid) {
					if (auth.length < MAX_KTXT_LEN)
						memcpy(auth.dat, kdata, auth.length);
					authenticated = auth_krb4(pw->pw_name, &auth, &tkt_user);
					if (authenticated) {
						snprintf(info, sizeof info,
						    " tktuser %.100s", tkt_user);
						xfree(tkt_user);
d133 15
d152 14
a165 2
#endif /* KRB4 */

d332 1
a332 1
	char *user, *style = NULL;
d342 1
a342 1
		*style++ = 0;
d344 4
@


1.23
log
@improved kbd-interactive support. work by per@@appgate.com and me
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.22 2001/03/23 12:02:49 markus Exp $");
d34 1
a34 1
char *
d63 1
a63 1
void
@


1.22
log
@authctxt is now passed to do_authenticated
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.21 2001/03/21 11:43:44 markus Exp $");
d255 2
a256 2
			if (options.challenge_reponse_authentication == 1) {
				char *challenge = get_challenge(authctxt, authctxt->style);
d261 1
d270 1
a270 1
			if (options.challenge_reponse_authentication == 1) {
@


1.22.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.25 2001/06/26 16:15:23 dugsong Exp $");
a26 1
#include "uidswap.h"
d34 1
a34 1
static char *
d50 1
a50 1
#if defined(KRB4) || defined(KRB5)
d63 1
a63 1
static void
d83 1
a83 1
#if defined(KRB4) || defined(KRB5)
d90 1
a90 1
	
d107 14
d122 15
a136 1
#if defined(KRB4) || defined(KRB5)
d140 1
d142 14
a155 32
				char *kdata = packet_get_string(&dlen);
				
				packet_integrity_check(plen, 4 + dlen, type);
				
				if (kdata[0] == 4) { /* KRB_PROT_VERSION */
#ifdef KRB4
					KTEXT_ST tkt;
					
					tkt.length = dlen;
					if (tkt.length < MAX_KTXT_LEN)
						memcpy(tkt.dat, kdata, tkt.length);
					
					if (auth_krb4(authctxt, &tkt, &client_user)) {
						authenticated = 1;
						snprintf(info, sizeof(info),
						    " tktuser %.100s",
						    client_user);
						xfree(client_user);
					}
#endif /* KRB4 */
				} else {
#ifdef KRB5
					krb5_data tkt;
					tkt.length = dlen;
					tkt.data = kdata;
					
					if (auth_krb5(authctxt, &tkt, &client_user)) {
						authenticated = 1;
						snprintf(info, sizeof(info),
						    " tktuser %.100s",
						    client_user);
						xfree(client_user);
a156 1
#endif /* KRB5 */
d161 2
a162 14
#endif /* KRB4 || KRB5 */
			
#if defined(AFS) || defined(KRB5)
			/* XXX - punt on backward compatibility here. */
		case SSH_CMSG_HAVE_KERBEROS_TGT:
			packet_send_debug("Kerberos TGT passing disabled before authentication.");
			break;
#ifdef AFS
		case SSH_CMSG_HAVE_AFS_TOKEN:
			packet_send_debug("AFS token passing disabled before authentication.");
			break;
#endif /* AFS */
#endif /* AFS || KRB5 */
			
d255 2
a256 2
			if (options.challenge_response_authentication == 1) {
				char *challenge = get_challenge(authctxt);
a260 1
					xfree(challenge);
d269 1
a269 1
			if (options.challenge_response_authentication == 1) {
d328 1
a328 1
	char *p, *user, *style = NULL;
d338 1
a338 1
		*style++ = '\0';
a339 4
	/* XXX - SSH.com Kerberos v5 braindeath. */
	if ((p = strchr(user, '@@')) != NULL)
		*p = '\0';
	
@


1.22.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.35 2002/02/03 17:53:25 markus Exp $");
a24 1
#include "channels.h"
d69 1
a69 1
	Key *client_host_key;
d74 1
d80 1
a80 1
	    authctxt->valid ? "" : "illegal user ", authctxt->user);
d91 1
a91 1

d104 1
a104 1
		type = packet_read();
d115 3
a117 2
				packet_check_eom();

d121 1
a121 1

d125 1
a125 1

d139 1
a139 1

d153 1
a153 1

d165 1
a165 1

d178 1
a178 1
			packet_check_eom();
d200 7
a206 1
			client_host_key = key_new(KEY_RSA1);
d208 2
a209 2
			packet_get_bignum(client_host_key->rsa->e);
			packet_get_bignum(client_host_key->rsa->n);
d211 1
a211 1
			if (bits != BN_num_bits(client_host_key->rsa->n))
d213 5
a217 7
				    "actual %d, announced %d",
				     BN_num_bits(client_host_key->rsa->n), bits);
			packet_check_eom();

			authenticated = auth_rhosts_rsa(pw, client_user,
			    client_host_key);
			key_free(client_host_key);
d229 3
a231 4
			if ((n = BN_new()) == NULL)
				fatal("do_authloop: BN_new failed");
			packet_get_bignum(n);
			packet_check_eom();
d247 1
a247 1
			packet_check_eom();
d276 1
a276 1
				packet_check_eom();
d326 1
a326 1
do_authentication(void)
d330 1
d335 1
a335 1
	packet_read_expect(SSH_CMSG_USER);
d339 1
a339 1
	packet_check_eom();
d347 1
a347 1

@


1.22.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.40 2002/04/10 08:21:47 markus Exp $");
d27 1
a28 1
#include "monitor_wrap.h"
d87 1
a87 1
	    PRIVSEP(auth_password(authctxt, ""))) {
d246 1
a246 1
			authenticated = PRIVSEP(auth_password(authctxt, password));
d321 1
a321 1
Authctxt *
d325 1
d327 1
a327 1
	char *user, *style = NULL;
a338 1
#ifdef KRB5
d340 2
a341 7
	if ((datafellows & SSH_BUG_K5USER) &&
	    options.kerberos_authentication) {
		char *p;
		if ((p = strchr(user, '@@')) != NULL)
			*p = '\0';
	}
#endif
d348 2
a349 1
	if ((authctxt->pw = PRIVSEP(getpwnamallow(user))) != NULL)
d351 2
a352 1
	else
d354 3
d358 1
a358 2
	setproctitle("%s%s", authctxt->pw ? user : "unknown",
	    use_privsep ? " [net]" : "");
d364 1
a364 2
	if (!use_privsep && getuid() != 0 && authctxt->pw &&
	    authctxt->pw->pw_uid != getuid())
d378 2
a379 1
	return (authctxt);
@


1.21
log
@merge common ssh v1/2 code
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.20 2001/03/20 18:57:04 markus Exp $");
a373 3

	xfree(authctxt->user);
	xfree(authctxt);
@


1.20
log
@add changes need for BSD_AUTH plus disabled BSD_AUTH code
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.19 2001/03/08 18:47:12 stevesk Exp $");
d379 1
a379 1
	do_authenticated(pw);
@


1.19
log
@unused; ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.18 2001/02/22 21:59:43 markus Exp $");
d86 1
a86 1
	    auth_password(pw, "")) {
d247 1
a247 1
			authenticated = auth_password(pw, password);
d287 6
@


1.18
log
@use pwcopy in ssh.c, too
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.17 2001/02/13 22:49:40 markus Exp $");
a29 1
extern char *forced_command;
@


1.17
log
@setproctitle(user) only if getpwnam succeeds
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.16 2001/02/12 16:16:23 markus Exp $");
d26 1
@


1.16
log
@PermitRootLogin={yes,without-password,forced-commands-only,no}
(before this change, root could login even if PermitRootLogin==no)
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.15 2001/02/07 22:35:45 markus Exp $");
a337 2
	setproctitle("%s", user);

d348 2
@


1.15
log
@move k_setpag() to a central place; ok dugsong@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.14 2001/01/22 23:06:39 markus Exp $");
d292 2
a293 1
		if (authenticated && authctxt->pw->pw_uid == 0 && !auth_root_allowed())
@


1.14
log
@rename skey -> challenge response.
auto-enable kbd-interactive for ssh2 if challenge-reponse is enabled.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.13 2001/01/21 19:05:43 markus Exp $");
a337 8

#ifdef AFS
	/* If machine has AFS, set process authentication group. */
	if (k_hasafs()) {
		k_setpag();
		k_unlog();
	}
#endif /* AFS */
@


1.13
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.12 2001/01/19 15:55:10 markus Exp $");
d255 1
a255 1
			if (options.skey_authentication == 1) {
d269 1
a269 1
			if (options.skey_authentication == 1) {
@


1.12
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.11 2001/01/18 16:59:59 markus Exp $");
a16 1
#include "ssh.h"
d21 1
@


1.11
log
@1) removes fake skey from sshd, since this will be much
   harder with /usr/libexec/auth/login_XXX
2) share/unify code used in ssh-1 and ssh-2 authentication (server side)
3) make addition of BSD_AUTH and other challenge reponse methods
   easier.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.10 2001/01/07 19:06:25 markus Exp $");
d18 1
@


1.10
log
@missing free, stevesk@@pobox.com
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.9 2000/12/27 12:34:49 markus Exp $");
d46 3
a52 4
#ifdef SKEY
	case SSH_CMSG_AUTH_TIS_RESPONSE:
		return "s/key";
#endif
d59 2
a60 5
 * read packets and try to authenticate local user 'luser'.
 * return if authentication is successful. not that pw == NULL
 * if the user does not exists or is not allowed to login.
 * each auth method has to 'fake' authentication for nonexisting
 * users.
d63 1
a63 1
do_authloop(struct passwd * pw, char *luser)
a65 1
	int attempt = 0;
d70 1
a70 1
	char user[1024];
d75 14
a88 1
	void (*authlog) (const char *fmt,...) = verbose;
d95 1
a95 1
	for (attempt = 1;; attempt++) {
d99 1
a99 1
		strlcpy(user, "", sizeof user);
d116 1
a116 1
					verbose("Kerberos tgt REFUSED for %.100s", luser);
d130 1
a130 1
					verbose("AFS token REFUSED for %.100s", luser);
a137 1
				/* packet_get_all(); */
d147 3
a149 5
				if (auth.length < MAX_KTXT_LEN)
					memcpy(auth.dat, kdata, auth.length);
				xfree(kdata);

				if (pw != NULL) {
d152 2
a153 1
						snprintf(user, sizeof user, " tktuser %s", tkt_user);
d157 1
d179 1
a179 1
			snprintf(user, sizeof user, " ruser %s", client_user);
d215 1
a215 1
			snprintf(user, sizeof user, " ruser %s", client_user);
a251 1
#ifdef SKEY
d255 3
a257 10
				char *skeyinfo = NULL;
				if (pw != NULL)
					skeyinfo = skey_keyinfo(pw->pw_name);
				if (skeyinfo == NULL) {
					debug("generating fake skeyinfo for %.100s.", luser);
					skeyinfo = skey_fake_keyinfo(luser);
				}
				if (skeyinfo != NULL) {
					/* we send our s/key- in tis-challenge messages */
					debug("sending challenge '%s'", skeyinfo);
d259 1
a259 1
					packet_put_cstring(skeyinfo);
d270 1
a270 1
				debug("skey response == '%s'", response);
d272 2
a273 3
				authenticated = (pw != NULL &&
				    skey_haskey(pw->pw_name) == 0 &&
				    skey_passcheck(pw->pw_name, response) != -1);
a276 6
#else
		case SSH_CMSG_AUTH_TIS:
			/* TIS Authentication is unsupported */
			log("TIS authentication unsupported.");
			break;
#endif
d286 7
a292 2
		if (authenticated && pw == NULL)
			fatal("internal error: authenticated for pw == NULL");
d294 2
a295 29
		/*
		 * Check if the user is logging in as root and root logins
		 * are disallowed.
		 * Note that root login is allowed for forced commands.
		 */
		if (authenticated && pw && pw->pw_uid == 0 && !options.permit_root_login) {
			if (forced_command) {
				log("Root login accepted for forced command.");
			} else {
				authenticated = 0;
				log("ROOT LOGIN REFUSED FROM %.200s",
				    get_canonical_hostname());
			}
		}

		/* Raise logging level */
		if (authenticated ||
		    attempt == AUTH_FAIL_LOG ||
		    type == SSH_CMSG_AUTH_PASSWORD)
			authlog = log;

		authlog("%s %s for %s%.100s from %.200s port %d%s",
			authenticated ? "Accepted" : "Failed",
			get_authname(type),
			pw ? "" : "illegal user ",
			pw && pw->pw_uid == 0 ? "ROOT" : luser,
			get_remote_ipaddr(),
			get_remote_port(),
			user);
d300 2
a301 2
		if (attempt > AUTH_FAIL_MAX)
			packet_disconnect(AUTH_FAIL_MSG, luser);
a302 1
		/* Send a message indicating that the authentication attempt failed. */
d316 2
a317 1
	struct passwd *pw, pwcopy;
d320 1
a320 1
	char *user;
d329 7
d349 2
a350 10
		/* Take a copy of the returned structure. */
		memset(&pwcopy, 0, sizeof(pwcopy));
		pwcopy.pw_name = xstrdup(pw->pw_name);
		pwcopy.pw_passwd = xstrdup(pw->pw_passwd);
		pwcopy.pw_uid = pw->pw_uid;
		pwcopy.pw_gid = pw->pw_gid;
		pwcopy.pw_class = xstrdup(pw->pw_class);
		pwcopy.pw_dir = xstrdup(pw->pw_dir);
		pwcopy.pw_shell = xstrdup(pw->pw_shell);
		pw = &pwcopy;
d352 1
d355 1
d364 5
a368 19
	debug("Attempting authentication for %s%.100s.", pw ? "" : "illegal user ", user);

	/* If the user has no password, accept authentication immediately. */
	if (options.password_authentication &&
#ifdef KRB4
	    (!options.kerberos_authentication || options.kerberos_or_local_passwd) &&
#endif /* KRB4 */
	    auth_password(pw, "")) {
		/* Authentication with empty password succeeded. */
		log("Login for user %s from %.100s, accepted without authentication.",
		    user, get_remote_ipaddr());
	} else {
		/* Loop until the user has been authenticated or the
		   connection is closed, do_authloop() returns only if
		   authentication is successful */
		do_authloop(pw, user);
	}
	if (pw == NULL)
		fatal("internal error, authentication successful for user '%.100s'", user);
d374 3
a376 1
	xfree(user);
@


1.9
log
@typo
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.8 2000/12/19 23:17:55 markus Exp $");
d417 1
@


1.8
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.7 2000/11/10 01:04:40 markus Exp $");
d61 1
a61 1
 * return if authentication is successfull. not that pw == NULL
d407 1
a407 1
		   authentication is successfull */
d411 1
a411 1
		fatal("internal error, authentication successfull for user '%.100s'", user);
@


1.7
log
@typo; from mouring@@pconline.com
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.6 2000/10/11 20:27:23 markus Exp $");
d71 1
a71 1
	unsigned int bits;
d76 1
a76 1
	unsigned int dlen;
d78 1
a78 1
	unsigned int ulen;
d137 1
a137 1
				char *kdata = packet_get_string((unsigned int *) &auth.length);
d349 1
a349 1
	unsigned int ulen;
@


1.6
log
@new cipher framework
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.5 2000/10/03 18:03:03 markus Exp $");
d251 1
a251 1
					skey_keyinfo(pw->pw_name);
@


1.6.2.1
log
@Pull in patch from current:
Errata:
skey logins for ssh-1 do not work.
Fix (markus):
typo; from mouring@@pconline.com
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.6 2000/10/11 20:27:23 markus Exp $");
d251 1
a251 1
					skeyinfo = skey_keyinfo(pw->pw_name);
@


1.6.2.2
log
@Pull in OpenSSH 2.5.0
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.17 2001/02/13 22:49:40 markus Exp $");
d17 1
a17 1
#include "ssh1.h"
a20 1
#include "log.h"
a45 3
	case SSH_CMSG_AUTH_TIS:
	case SSH_CMSG_AUTH_TIS_RESPONSE:
		return "challenge-response";
d50 4
d60 5
a64 2
 * read packets, try to authenticate the user and
 * return only if authentication is successful
d67 1
a67 1
do_authloop(Authctxt *authctxt)
d70 2
a71 1
	u_int bits;
d75 2
a76 2
	char info[1024];
	u_int dlen;
d78 1
a78 1
	u_int ulen;
d80 1
a80 14
	struct passwd *pw = authctxt->pw;

	debug("Attempting authentication for %s%.100s.",
	     authctxt->valid ? "" : "illegal user ", authctxt->user);

	/* If the user has no password, accept authentication immediately. */
	if (options.password_authentication &&
#ifdef KRB4
	    (!options.kerberos_authentication || options.kerberos_or_local_passwd) &&
#endif
	    auth_password(pw, "")) {
		auth_log(authctxt, 1, "without authentication", "");
		return;
	}
d87 1
a87 1
	for (;;) {
d91 1
a91 1
		info[0] = '\0';
d108 1
a108 1
					verbose("Kerberos tgt REFUSED for %.100s", authctxt->user);
d122 1
a122 1
					verbose("AFS token REFUSED for %.100s", authctxt->user);
d130 1
d137 1
a137 1
				char *kdata = packet_get_string((u_int *) &auth.length);
d140 5
a144 3
				if (authctxt->valid) {
					if (auth.length < MAX_KTXT_LEN)
						memcpy(auth.dat, kdata, auth.length);
d147 1
a147 2
						snprintf(info, sizeof info,
						    " tktuser %.100s", tkt_user);
a150 1
				xfree(kdata);
d172 1
a172 1
			snprintf(info, sizeof info, " ruser %.100s", client_user);
d208 1
a208 1
			snprintf(info, sizeof info, " ruser %.100s", client_user);
d245 1
d248 11
a258 4
			if (options.challenge_reponse_authentication == 1) {
				char *challenge = get_challenge(authctxt, authctxt->style);
				if (challenge != NULL) {
					debug("sending challenge '%s'", challenge);
d260 1
a260 1
					packet_put_cstring(challenge);
d269 1
a269 1
			if (options.challenge_reponse_authentication == 1) {
d271 1
a271 1
				debug("got response '%s'", response);
d273 3
a275 2
				authenticated = verify_response(authctxt, response);
				memset(response, 'r', dlen);
d279 6
d294 2
a295 8
		if (!authctxt->valid && authenticated)
			fatal("INTERNAL ERROR: authenticated invalid user %s",
			    authctxt->user);

		/* Special handling for root */
		if (authenticated && authctxt->pw->pw_uid == 0 &&
		    !auth_root_allowed(get_authname(type)))
			authenticated = 0;
d297 29
a325 2
		/* Log before sending the reply */
		auth_log(authctxt, authenticated, get_authname(type), info);
d330 2
a331 2
		if (authctxt->failures++ > AUTH_FAIL_MAX)
			packet_disconnect(AUTH_FAIL_MSG, authctxt->user);
d333 1
d347 1
a347 2
	Authctxt *authctxt;
	struct passwd *pw;
d349 2
a350 2
	u_int ulen;
	char *user, *style = NULL;
d359 1
a359 2
	if ((style = strchr(user, ':')) != NULL)
		*style++ = 0;
d361 7
a367 3
	authctxt = authctxt_new();
	authctxt->user = user;
	authctxt->style = style;
d372 10
a381 2
		authctxt->valid = 1;
		pw = pwcopy(pw);
a382 1
		debug("do_authentication: illegal user %s", user);
a384 3
	authctxt->pw = pw;

	setproctitle("%s", pw ? user : "unknown");
d393 19
a411 5
	/*
	 * Loop until the user has been authenticated or the connection is
	 * closed, do_authloop() returns only if authentication is successful
	 */
	do_authloop(authctxt);
a416 3

	xfree(authctxt->user);
	xfree(authctxt);
@


1.6.2.3
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.6.2.4
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.19 2001/03/08 18:47:12 stevesk Exp $");
a25 1
#include "misc.h"
d29 1
@


1.6.2.5
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.22 2001/03/23 12:02:49 markus Exp $");
d86 1
a86 1
	    auth_password(authctxt, "")) {
d247 1
a247 1
			authenticated = auth_password(authctxt, password);
a286 6
#ifdef BSD_AUTH
		if (authctxt->as) {
			auth_close(authctxt->as);
			authctxt->as = NULL;
		}
#endif
d369 3
d373 1
a373 1
	do_authenticated(authctxt);
@


1.6.2.6
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.25 2001/06/26 16:15:23 dugsong Exp $");
a26 1
#include "uidswap.h"
d34 1
a34 1
static char *
d50 1
a50 1
#if defined(KRB4) || defined(KRB5)
d63 1
a63 1
static void
d83 1
a83 1
#if defined(KRB4) || defined(KRB5)
d90 1
a90 1
	
d107 14
d122 15
a136 1
#if defined(KRB4) || defined(KRB5)
d140 1
d142 14
a155 32
				char *kdata = packet_get_string(&dlen);
				
				packet_integrity_check(plen, 4 + dlen, type);
				
				if (kdata[0] == 4) { /* KRB_PROT_VERSION */
#ifdef KRB4
					KTEXT_ST tkt;
					
					tkt.length = dlen;
					if (tkt.length < MAX_KTXT_LEN)
						memcpy(tkt.dat, kdata, tkt.length);
					
					if (auth_krb4(authctxt, &tkt, &client_user)) {
						authenticated = 1;
						snprintf(info, sizeof(info),
						    " tktuser %.100s",
						    client_user);
						xfree(client_user);
					}
#endif /* KRB4 */
				} else {
#ifdef KRB5
					krb5_data tkt;
					tkt.length = dlen;
					tkt.data = kdata;
					
					if (auth_krb5(authctxt, &tkt, &client_user)) {
						authenticated = 1;
						snprintf(info, sizeof(info),
						    " tktuser %.100s",
						    client_user);
						xfree(client_user);
a156 1
#endif /* KRB5 */
d161 2
a162 14
#endif /* KRB4 || KRB5 */
			
#if defined(AFS) || defined(KRB5)
			/* XXX - punt on backward compatibility here. */
		case SSH_CMSG_HAVE_KERBEROS_TGT:
			packet_send_debug("Kerberos TGT passing disabled before authentication.");
			break;
#ifdef AFS
		case SSH_CMSG_HAVE_AFS_TOKEN:
			packet_send_debug("AFS token passing disabled before authentication.");
			break;
#endif /* AFS */
#endif /* AFS || KRB5 */
			
d255 2
a256 2
			if (options.challenge_response_authentication == 1) {
				char *challenge = get_challenge(authctxt);
a260 1
					xfree(challenge);
d269 1
a269 1
			if (options.challenge_response_authentication == 1) {
d328 1
a328 1
	char *p, *user, *style = NULL;
d338 1
a338 1
		*style++ = '\0';
a339 4
	/* XXX - SSH.com Kerberos v5 braindeath. */
	if ((p = strchr(user, '@@')) != NULL)
		*p = '\0';
	
@


1.6.2.7
log
@Merge OpenSSH 3.1.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.35 2002/02/03 17:53:25 markus Exp $");
a24 1
#include "channels.h"
d69 1
a69 1
	Key *client_host_key;
d74 1
d80 1
a80 1
	    authctxt->valid ? "" : "illegal user ", authctxt->user);
d91 1
a91 1

d104 1
a104 1
		type = packet_read();
d115 3
a117 2
				packet_check_eom();

d121 1
a121 1

d125 1
a125 1

d139 1
a139 1

d153 1
a153 1

d165 1
a165 1

d178 1
a178 1
			packet_check_eom();
d200 7
a206 1
			client_host_key = key_new(KEY_RSA1);
d208 2
a209 2
			packet_get_bignum(client_host_key->rsa->e);
			packet_get_bignum(client_host_key->rsa->n);
d211 1
a211 1
			if (bits != BN_num_bits(client_host_key->rsa->n))
d213 5
a217 7
				    "actual %d, announced %d",
				     BN_num_bits(client_host_key->rsa->n), bits);
			packet_check_eom();

			authenticated = auth_rhosts_rsa(pw, client_user,
			    client_host_key);
			key_free(client_host_key);
d229 3
a231 4
			if ((n = BN_new()) == NULL)
				fatal("do_authloop: BN_new failed");
			packet_get_bignum(n);
			packet_check_eom();
d247 1
a247 1
			packet_check_eom();
d276 1
a276 1
				packet_check_eom();
d326 1
a326 1
do_authentication(void)
d330 1
d335 1
a335 1
	packet_read_expect(SSH_CMSG_USER);
d339 1
a339 1
	packet_check_eom();
d347 1
a347 1

@


1.5
log
@move fake-auth from auth1.c to individual auth methods, disables s/key in debug-msg
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.4 2000/09/07 20:27:49 deraadt Exp $");
a19 1
#include "cipher.h"
@


1.4
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.3 2000/08/20 18:42:40 millert Exp $");
d61 5
a65 2
 * The user does not exist or access is denied,
 * but fake indication that authentication is needed.
d68 1
a68 67
do_fake_authloop1(char *user)
{
	int attempt = 0;

	log("Faking authloop for illegal user %.200s from %.200s port %d",
	    user,
	    get_remote_ipaddr(),
	    get_remote_port());

	/* Indicate that authentication is needed. */
	packet_start(SSH_SMSG_FAILURE);
	packet_send();
	packet_write_wait();

	/*
	 * Keep reading packets, and always respond with a failure.  This is
	 * to avoid disclosing whether such a user really exists.
	 */
	for (attempt = 1;; attempt++) {
		/* Read a packet.  This will not return if the client disconnects. */
		int plen;
		int type = packet_read(&plen);
#ifdef SKEY
		unsigned int dlen;
		char *password, *skeyinfo;
		password = NULL;
		/* Try to send a fake s/key challenge. */
		if (options.skey_authentication == 1 &&
		    (skeyinfo = skey_fake_keyinfo(user)) != NULL) {
			if (type == SSH_CMSG_AUTH_TIS) {
				packet_start(SSH_SMSG_AUTH_TIS_CHALLENGE);
				packet_put_string(skeyinfo, strlen(skeyinfo));
				packet_send();
				packet_write_wait();
				continue;
			} else if (type == SSH_CMSG_AUTH_PASSWORD &&
				   options.password_authentication &&
				   (password = packet_get_string(&dlen)) != NULL &&
				   dlen == 5 &&
				   strncasecmp(password, "s/key", 5) == 0 ) {
				packet_send_debug(skeyinfo);
			}
		}
		if (password != NULL)
			xfree(password);
#endif
		if (attempt > AUTH_FAIL_MAX)
			packet_disconnect(AUTH_FAIL_MSG, user);

		/*
		 * Send failure.  This should be indistinguishable from a
		 * failed authentication.
		 */
		packet_start(SSH_SMSG_FAILURE);
		packet_send();
		packet_write_wait();
	}
	/* NOTREACHED */
	abort();
}

/*
 * read packets and try to authenticate local user *pw.
 * return if authentication is successfull
 */
void
do_authloop(struct passwd * pw)
d70 1
d89 3
a91 1
		int authenticated = 0;
a101 1
				/* packet_get_all(); */
d109 1
a109 1
					verbose("Kerberos tgt REFUSED for %s", pw->pw_name);
a115 1
				/* packet_get_all(); */
d123 1
a123 1
					verbose("AFS token REFUSED for %s", pw->pw_name);
d145 6
a150 5
				authenticated = auth_krb4(pw->pw_name, &auth, &tkt_user);

				if (authenticated) {
					snprintf(user, sizeof user, " tktuser %s", tkt_user);
					xfree(tkt_user);
d170 1
a170 2
			/* Try to authenticate using /etc/hosts.equiv and
			   .rhosts. */
d202 1
a202 1
				log("Warning: keysize mismatch for client_host_key: "
d250 3
a252 1
				char *skeyinfo = skey_keyinfo(pw->pw_name);
d254 2
a255 2
					debug("generating fake skeyinfo for %.100s.", pw->pw_name);
					skeyinfo = skey_fake_keyinfo(pw->pw_name);
d261 1
a261 1
					packet_put_string(skeyinfo, strlen(skeyinfo));
d274 3
a276 2
				authenticated = (skey_haskey(pw->pw_name) == 0 &&
						 skey_passcheck(pw->pw_name, response) != -1);
d295 2
d303 1
a303 1
		if (authenticated && pw->pw_uid == 0 && !options.permit_root_login) {
d319 1
a319 1
		authlog("%s %s for %.200s from %.200s port %d%s",
d322 2
a323 1
			pw->pw_uid == 0 ? "ROOT" : pw->pw_name,
d332 1
a332 1
			packet_disconnect(AUTH_FAIL_MSG, pw->pw_name);
d372 14
a385 14
	if (!pw || !allowed_user(pw))
		do_fake_authloop1(user);
	xfree(user);

	/* Take a copy of the returned structure. */
	memset(&pwcopy, 0, sizeof(pwcopy));
	pwcopy.pw_name = xstrdup(pw->pw_name);
	pwcopy.pw_passwd = xstrdup(pw->pw_passwd);
	pwcopy.pw_uid = pw->pw_uid;
	pwcopy.pw_gid = pw->pw_gid;
	pwcopy.pw_class = xstrdup(pw->pw_class);
	pwcopy.pw_dir = xstrdup(pw->pw_dir);
	pwcopy.pw_shell = xstrdup(pw->pw_shell);
	pw = &pwcopy;
d391 1
a391 1
	if (getuid() != 0 && pw->pw_uid != getuid())
d394 1
a394 1
	debug("Attempting authentication for %.100s.", pw->pw_name);
d404 1
a404 1
		    pw->pw_name, get_remote_ipaddr());
d409 1
a409 1
		do_authloop(pw);
d411 2
@


1.3
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@d4 6
d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.2 2000/04/29 18:11:52 markus Exp $");
@


1.2
log
@keysize warnings error() -> log()
@
text
@d7 1
a7 1
RCSID("$OpenBSD: auth1.c,v 1.1 2000/04/26 21:28:32 markus Exp $");
d432 1
@


1.2.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d7 1
a7 1
RCSID("$OpenBSD: auth1.c,v 1.3 2000/08/20 18:42:40 millert Exp $");
a431 1
	pwcopy.pw_class = xstrdup(pw->pw_class);
@


1.2.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@a3 6
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d7 1
a7 1
RCSID("$OpenBSD: auth1.c,v 1.6 2000/10/11 20:27:23 markus Exp $");
d14 1
d55 2
a56 5
 * read packets and try to authenticate local user 'luser'.
 * return if authentication is successfull. not that pw == NULL
 * if the user does not exists or is not allowed to login.
 * each auth method has to 'fake' authentication for nonexisting
 * users.
d59 67
a125 1
do_authloop(struct passwd * pw, char *luser)
a126 1
	int authenticated = 0;
d145 1
a145 3
		/* default to fail */
		authenticated = 0;

d156 1
d164 1
a164 1
					verbose("Kerberos tgt REFUSED for %.100s", luser);
d171 1
d179 1
a179 1
					verbose("AFS token REFUSED for %.100s", luser);
d201 5
a205 6
				if (pw != NULL) {
					authenticated = auth_krb4(pw->pw_name, &auth, &tkt_user);
					if (authenticated) {
						snprintf(user, sizeof user, " tktuser %s", tkt_user);
						xfree(tkt_user);
					}
d225 2
a226 1
			/* Try to authenticate using /etc/hosts.equiv and .rhosts. */
d258 1
a258 1
				verbose("Warning: keysize mismatch for client_host_key: "
d306 1
a306 3
				char *skeyinfo = NULL;
				if (pw != NULL)
					skey_keyinfo(pw->pw_name);
d308 2
a309 2
					debug("generating fake skeyinfo for %.100s.", luser);
					skeyinfo = skey_fake_keyinfo(luser);
d315 1
a315 1
					packet_put_cstring(skeyinfo);
d328 2
a329 3
				authenticated = (pw != NULL &&
				    skey_haskey(pw->pw_name) == 0 &&
				    skey_passcheck(pw->pw_name, response) != -1);
a347 2
		if (authenticated && pw == NULL)
			fatal("internal error: authenticated for pw == NULL");
d354 1
a354 1
		if (authenticated && pw && pw->pw_uid == 0 && !options.permit_root_login) {
d370 1
a370 1
		authlog("%s %s for %s%.100s from %.200s port %d%s",
d373 1
a373 2
			pw ? "" : "illegal user ",
			pw && pw->pw_uid == 0 ? "ROOT" : luser,
d382 1
a382 1
			packet_disconnect(AUTH_FAIL_MSG, luser);
d422 14
a435 14
	if (pw && allowed_user(pw)) {
		/* Take a copy of the returned structure. */
		memset(&pwcopy, 0, sizeof(pwcopy));
		pwcopy.pw_name = xstrdup(pw->pw_name);
		pwcopy.pw_passwd = xstrdup(pw->pw_passwd);
		pwcopy.pw_uid = pw->pw_uid;
		pwcopy.pw_gid = pw->pw_gid;
		pwcopy.pw_class = xstrdup(pw->pw_class);
		pwcopy.pw_dir = xstrdup(pw->pw_dir);
		pwcopy.pw_shell = xstrdup(pw->pw_shell);
		pw = &pwcopy;
	} else {
		pw = NULL;
	}
d441 1
a441 1
	if (getuid() != 0 && pw && pw->pw_uid != getuid())
d444 1
a444 1
	debug("Attempting authentication for %s%.100s.", pw ? "" : "illegal user ", user);
d454 1
a454 1
		    user, get_remote_ipaddr());
d459 1
a459 1
		do_authloop(pw, user);
a460 2
	if (pw == NULL)
		fatal("internal error, authentication successfull for user '%.100s'", user);
@


1.2.2.3
log
@Pull in patch from current:
Errata:
skey logins for ssh-1 do not work.
Fix (markus):
typo; from mouring@@pconline.com
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.2.2.2 2000/11/08 21:30:23 jason Exp $");
d251 1
a251 1
					skeyinfo = skey_keyinfo(pw->pw_name);
@


1.2.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.17 2001/02/13 22:49:40 markus Exp $");
d17 1
a17 1
#include "ssh1.h"
a20 1
#include "log.h"
a45 3
	case SSH_CMSG_AUTH_TIS:
	case SSH_CMSG_AUTH_TIS_RESPONSE:
		return "challenge-response";
d50 4
d60 5
a64 2
 * read packets, try to authenticate the user and
 * return only if authentication is successful
d67 1
a67 1
do_authloop(Authctxt *authctxt)
d70 2
a71 1
	u_int bits;
d75 2
a76 2
	char info[1024];
	u_int dlen;
d78 1
a78 1
	u_int ulen;
d80 1
a80 14
	struct passwd *pw = authctxt->pw;

	debug("Attempting authentication for %s%.100s.",
	     authctxt->valid ? "" : "illegal user ", authctxt->user);

	/* If the user has no password, accept authentication immediately. */
	if (options.password_authentication &&
#ifdef KRB4
	    (!options.kerberos_authentication || options.kerberos_or_local_passwd) &&
#endif
	    auth_password(pw, "")) {
		auth_log(authctxt, 1, "without authentication", "");
		return;
	}
d87 1
a87 1
	for (;;) {
d91 1
a91 1
		info[0] = '\0';
d108 1
a108 1
					verbose("Kerberos tgt REFUSED for %.100s", authctxt->user);
d122 1
a122 1
					verbose("AFS token REFUSED for %.100s", authctxt->user);
d130 1
d137 1
a137 1
				char *kdata = packet_get_string((u_int *) &auth.length);
d140 5
a144 3
				if (authctxt->valid) {
					if (auth.length < MAX_KTXT_LEN)
						memcpy(auth.dat, kdata, auth.length);
d147 1
a147 2
						snprintf(info, sizeof info,
						    " tktuser %.100s", tkt_user);
a150 1
				xfree(kdata);
d172 1
a172 1
			snprintf(info, sizeof info, " ruser %.100s", client_user);
d208 1
a208 1
			snprintf(info, sizeof info, " ruser %.100s", client_user);
d245 1
d248 11
a258 4
			if (options.challenge_reponse_authentication == 1) {
				char *challenge = get_challenge(authctxt, authctxt->style);
				if (challenge != NULL) {
					debug("sending challenge '%s'", challenge);
d260 1
a260 1
					packet_put_cstring(challenge);
d269 1
a269 1
			if (options.challenge_reponse_authentication == 1) {
d271 1
a271 1
				debug("got response '%s'", response);
d273 3
a275 2
				authenticated = verify_response(authctxt, response);
				memset(response, 'r', dlen);
d279 6
d294 2
a295 8
		if (!authctxt->valid && authenticated)
			fatal("INTERNAL ERROR: authenticated invalid user %s",
			    authctxt->user);

		/* Special handling for root */
		if (authenticated && authctxt->pw->pw_uid == 0 &&
		    !auth_root_allowed(get_authname(type)))
			authenticated = 0;
d297 29
a325 2
		/* Log before sending the reply */
		auth_log(authctxt, authenticated, get_authname(type), info);
d330 2
a331 2
		if (authctxt->failures++ > AUTH_FAIL_MAX)
			packet_disconnect(AUTH_FAIL_MSG, authctxt->user);
d333 1
d347 1
a347 2
	Authctxt *authctxt;
	struct passwd *pw;
d349 2
a350 2
	u_int ulen;
	char *user, *style = NULL;
d359 1
a359 2
	if ((style = strchr(user, ':')) != NULL)
		*style++ = 0;
d361 7
a367 3
	authctxt = authctxt_new();
	authctxt->user = user;
	authctxt->style = style;
d372 10
a381 2
		authctxt->valid = 1;
		pw = pwcopy(pw);
a382 1
		debug("do_authentication: illegal user %s", user);
a384 3
	authctxt->pw = pw;

	setproctitle("%s", pw ? user : "unknown");
d393 19
a411 5
	/*
	 * Loop until the user has been authenticated or the connection is
	 * closed, do_authloop() returns only if authentication is successful
	 */
	do_authloop(authctxt);
a416 3

	xfree(authctxt->user);
	xfree(authctxt);
@


1.2.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.19 2001/03/08 18:47:12 stevesk Exp $");
a25 1
#include "misc.h"
d29 1
@


1.1
log
@split auth/sshconnect in one file per protocol version
@
text
@d7 1
a7 1
RCSID("$OpenBSD: auth1.c,v 1.1 2000/04/18 15:01:30 markus Exp $");
d258 2
a259 2
				error("Warning: keysize mismatch for client_host_key: "
				      "actual %d, announced %d", BN_num_bits(client_host_key->n), bits);
@

