head	1.81;
access;
symbols
	OPENBSD_6_1:1.80.0.4
	OPENBSD_6_1_BASE:1.80
	OPENBSD_6_0:1.78.0.6
	OPENBSD_6_0_BASE:1.78
	OPENBSD_5_9:1.78.0.2
	OPENBSD_5_9_BASE:1.78
	OPENBSD_5_8:1.77.0.4
	OPENBSD_5_8_BASE:1.77
	OPENBSD_5_7:1.77.0.2
	OPENBSD_5_7_BASE:1.77
	OPENBSD_5_6:1.76.0.4
	OPENBSD_5_6_BASE:1.76
	OPENBSD_5_5:1.74.0.4
	OPENBSD_5_5_BASE:1.74
	OPENBSD_5_4:1.71.0.2
	OPENBSD_5_4_BASE:1.71
	OPENBSD_5_3:1.70.0.26
	OPENBSD_5_3_BASE:1.70
	OPENBSD_5_2:1.70.0.24
	OPENBSD_5_2_BASE:1.70
	OPENBSD_5_1_BASE:1.70
	OPENBSD_5_1:1.70.0.22
	OPENBSD_5_0:1.70.0.20
	OPENBSD_5_0_BASE:1.70
	OPENBSD_4_9:1.70.0.18
	OPENBSD_4_9_BASE:1.70
	OPENBSD_4_8:1.70.0.16
	OPENBSD_4_8_BASE:1.70
	OPENBSD_4_7:1.70.0.12
	OPENBSD_4_7_BASE:1.70
	OPENBSD_4_6:1.70.0.14
	OPENBSD_4_6_BASE:1.70
	OPENBSD_4_5:1.70.0.10
	OPENBSD_4_5_BASE:1.70
	OPENBSD_4_4:1.70.0.8
	OPENBSD_4_4_BASE:1.70
	OPENBSD_4_3:1.70.0.6
	OPENBSD_4_3_BASE:1.70
	OPENBSD_4_2:1.70.0.4
	OPENBSD_4_2_BASE:1.70
	OPENBSD_4_1:1.70.0.2
	OPENBSD_4_1_BASE:1.70
	OPENBSD_4_0:1.69.0.4
	OPENBSD_4_0_BASE:1.69
	OPENBSD_3_9:1.62.0.2
	OPENBSD_3_9_BASE:1.62
	OPENBSD_3_8:1.61.0.2
	OPENBSD_3_8_BASE:1.61
	OPENBSD_3_7:1.60.0.4
	OPENBSD_3_7_BASE:1.60
	OPENBSD_3_6:1.60.0.2
	OPENBSD_3_6_BASE:1.60
	OPENBSD_3_5:1.56.0.4
	OPENBSD_3_5_BASE:1.56
	OPENBSD_3_4:1.56.0.2
	OPENBSD_3_4_BASE:1.56
	OPENBSD_3_3:1.52.0.4
	OPENBSD_3_3_BASE:1.52
	OPENBSD_3_2:1.52.0.2
	OPENBSD_3_2_BASE:1.52
	OPENBSD_3_1:1.49.0.2
	OPENBSD_3_1_BASE:1.49
	OPENBSD_3_0:1.41.0.2
	OPENBSD_3_0_BASE:1.41
	OPENBSD_2_9_BASE:1.31
	OPENBSD_2_9:1.31.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.81
date	2017.05.01.14.08.26;	author djm;	state dead;
branches;
next	1.80;
commitid	0IFSREZ5gQRufp5E;

1.80
date	2017.03.10.03.53.11;	author dtucker;	state Exp;
branches;
next	1.79;
commitid	4xxUS4OLfpCaJcTU;

1.79
date	2016.09.19.07.52.42;	author natano;	state Exp;
branches;
next	1.78;
commitid	hCnkOvi95f37XsAS;

1.78
date	2015.11.15.22.26.49;	author jcs;	state Exp;
branches;
next	1.77;
commitid	mjNGB5AAtJeHDag2;

1.77
date	2015.01.14.20.05.27;	author djm;	state Exp;
branches;
next	1.76;
commitid	YqNUZu0ifI7Q95nk;

1.76
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.75;
commitid	z7plx8Gkj6l2sxem;

1.75
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.74;
commitid	1h9UxAQmwdaqUzyX;

1.74
date	2014.02.02.03.44.32;	author djm;	state Exp;
branches;
next	1.73;

1.73
date	2014.01.27.19.18.54;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2013.09.02.22.00.34;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.70;

1.70
date	2006.11.06.21.25.28;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.69.4.1;
next	1.68;

1.68
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.67;

1.67
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.66;

1.66
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.65;

1.65
date	2006.04.25.08.02.27;	author dtucker;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.19.18.51.19;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2005.10.30.08.52.18;	author djm;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2005.06.17.02.44.33;	author djm;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2004.07.28.09.40.29;	author markus;	state Exp;
branches
	1.60.2.1
	1.60.4.1;
next	1.59;

1.59
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches;
next	1.58;

1.58
date	2004.05.09.01.19.28;	author djm;	state Exp;
branches;
next	1.57;

1.57
date	2004.05.08.00.21.31;	author djm;	state Exp;
branches;
next	1.56;

1.56
date	2003.08.28.12.54.34;	author markus;	state Exp;
branches
	1.56.2.1
	1.56.4.1;
next	1.55;

1.55
date	2003.08.13.08.46.31;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2003.07.22.13.35.22;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches;
next	1.52;

1.52
date	2002.08.08.13.50.23;	author aaron;	state Exp;
branches
	1.52.2.1
	1.52.4.1;
next	1.51;

1.51
date	2002.05.23.19.24.30;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2002.04.21.16.25.06;	author stevesk;	state Exp;
branches;
next	1.49;

1.49
date	2002.03.14.15.24.27;	author markus;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2002.02.11.16.15.46;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2001.12.28.14.50.54;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2001.12.28.13.57.33;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2001.12.27.20.39.58;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2001.12.27.18.22.16;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2001.10.06.11.18.19;	author markus;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.09.27.15.31.17;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2001.07.05.20.32.47;	author stevesk;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.26.20.14.11;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.26.16.15.24;	author dugsong;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.23.22.37.46;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.23.15.12.21;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.23.02.34.32;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.07.20.23.05;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.18.14.13.29;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.17.08.14.01;	author markus;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2001.04.12.19.15.25;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.26.08.07.09;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.08.21.42.33;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2001.02.15.23.19.59;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2001.02.12.12.45.06;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.08.23.11.43;	author dugsong;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.08.19.30.52;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.08.10.47.04;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.03.10.08.37;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.29.19.47.31;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.22.23.06.40;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.22.08.15.00;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.21.19.06.00;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.19.15.55.12;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.18.17.00.00;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.16.23.58.09;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.08.21.55.41;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.19.23.17.58;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.10.17.01.53;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.25.16.42.53;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.23.21.03.47;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.12.19.50.38;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.12.09.59.19;	author markus;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.10.11.20.27.24;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.07.20.27.54;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.19.21.34.44;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.16.08.27.22;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.08.17.12.16;	author markus;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.05.04.22.38.00;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.26.21.28.33;	author markus;	state Exp;
branches;
next	;

1.3.2.1
date	2000.09.01.18.23.24;	author jason;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2000.11.08.21.31.29;	author jason;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2001.03.12.15.44.17;	author jason;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2001.03.21.18.53.15;	author jason;	state Exp;
branches;
next	;

1.8.2.1
date	2001.02.16.20.13.22;	author jason;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.02.19.17.19.36;	author jason;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.03.21.19.46.31;	author jason;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2001.05.07.21.09.37;	author jason;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2001.09.27.00.15.43;	author miod;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2001.11.15.00.15.00;	author miod;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.31.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	1.31.2.4;

1.31.2.4
date	2002.06.02.22.56.11;	author miod;	state Exp;
branches;
next	;

1.41.2.1
date	2002.03.07.17.37.48;	author jason;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2002.06.22.07.23.18;	author miod;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.49.2.1
date	2002.05.18.04.12.11;	author jason;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2002.05.18.04.50.38;	author jason;	state Exp;
branches;
next	1.49.2.3;

1.49.2.3
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	1.49.2.4;

1.49.2.4
date	2002.10.11.14.51.53;	author miod;	state Exp;
branches;
next	;

1.52.2.1
date	2003.09.16.21.20.28;	author brad;	state Exp;
branches;
next	;

1.52.4.1
date	2003.09.16.20.50.44;	author brad;	state Exp;
branches;
next	1.52.4.2;

1.52.4.2
date	2004.03.04.18.18.17;	author brad;	state Exp;
branches;
next	;

1.56.2.1
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.56.4.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	;

1.60.2.1
date	2005.09.02.03.45.01;	author brad;	state Exp;
branches;
next	;

1.60.4.1
date	2005.09.04.18.40.10;	author brad;	state Exp;
branches;
next	1.60.4.2;

1.60.4.2
date	2006.02.03.02.53.45;	author brad;	state Exp;
branches;
next	;

1.61.2.1
date	2006.02.03.03.01.58;	author brad;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	1.61.2.3;

1.61.2.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.62.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	1.62.2.2;

1.62.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.69.4.1
date	2006.11.08.00.42.11;	author brad;	state Exp;
branches;
next	;


desc
@@


1.81
log
@this one I did forget to "cvs rm"
@
text
@/* $OpenBSD: sshconnect1.c,v 1.80 2017/03/10 03:53:11 dtucker Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Code to connect to a remote host, and to perform the client side of the
 * login (authentication) dialog.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <openssl/bn.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <pwd.h>

#include "xmalloc.h"
#include "ssh.h"
#include "ssh1.h"
#include "rsa.h"
#include "buffer.h"
#include "packet.h"
#include "key.h"
#include "cipher.h"
#include "kex.h"
#include "uidswap.h"
#include "log.h"
#include "misc.h"
#include "readconf.h"
#include "authfd.h"
#include "sshconnect.h"
#include "authfile.h"
#include "canohost.h"
#include "hostfile.h"
#include "auth.h"
#include "digest.h"
#include "ssherr.h"

/* Session id for the current session. */
u_char session_id[16];
u_int supported_authentications = 0;

extern Options options;
extern char *__progname;

/*
 * Checks if the user has an authentication agent, and if so, tries to
 * authenticate using the agent.
 */
static int
try_agent_authentication(void)
{
	int r, type, agent_fd, ret = 0;
	u_char response[16];
	size_t i;
	BIGNUM *challenge;
	struct ssh_identitylist *idlist = NULL;

	/* Get connection to the agent. */
	if ((r = ssh_get_authentication_socket(&agent_fd)) != 0) {
		if (r != SSH_ERR_AGENT_NOT_PRESENT)
			debug("%s: ssh_get_authentication_socket: %s",
			    __func__, ssh_err(r));
		return 0;
	}

	if ((challenge = BN_new()) == NULL)
		fatal("try_agent_authentication: BN_new failed");

	/* Loop through identities served by the agent. */
	if ((r = ssh_fetch_identitylist(agent_fd, 1, &idlist)) != 0) {
		if (r != SSH_ERR_AGENT_NO_IDENTITIES)
			debug("%s: ssh_fetch_identitylist: %s",
			    __func__, ssh_err(r));
		goto out;
	}
	for (i = 0; i < idlist->nkeys; i++) {
		/* Try this identity. */
		debug("Trying RSA authentication via agent with '%.100s'",
		    idlist->comments[i]);

		/* Tell the server that we are willing to authenticate using this key. */
		packet_start(SSH_CMSG_AUTH_RSA);
		packet_put_bignum(idlist->keys[i]->rsa->n);
		packet_send();
		packet_write_wait();

		/* Wait for server's response. */
		type = packet_read();

		/* The server sends failure if it doesn't like our key or
		   does not support RSA authentication. */
		if (type == SSH_SMSG_FAILURE) {
			debug("Server refused our key.");
			continue;
		}
		/* Otherwise it should have sent a challenge. */
		if (type != SSH_SMSG_AUTH_RSA_CHALLENGE)
			packet_disconnect("Protocol error during RSA authentication: %d",
					  type);

		packet_get_bignum(challenge);
		packet_check_eom();

		debug("Received RSA challenge from server.");

		/* Ask the agent to decrypt the challenge. */
		if ((r = ssh_decrypt_challenge(agent_fd, idlist->keys[i],
		    challenge, session_id, response)) != 0) {
			/*
			 * The agent failed to authenticate this identifier
			 * although it advertised it supports this.  Just
			 * return a wrong value.
			 */
			logit("Authentication agent failed to decrypt "
			    "challenge: %s", ssh_err(r));
			explicit_bzero(response, sizeof(response));
		}
		debug("Sending response to RSA challenge.");

		/* Send the decrypted challenge back to the server. */
		packet_start(SSH_CMSG_AUTH_RSA_RESPONSE);
		for (i = 0; i < 16; i++)
			packet_put_char(response[i]);
		packet_send();
		packet_write_wait();

		/* Wait for response from the server. */
		type = packet_read();

		/*
		 * The server returns success if it accepted the
		 * authentication.
		 */
		if (type == SSH_SMSG_SUCCESS) {
			debug("RSA authentication accepted by server.");
			ret = 1;
			break;
		} else if (type != SSH_SMSG_FAILURE)
			packet_disconnect("Protocol error waiting RSA auth "
			    "response: %d", type);
	}
	if (ret != 1)
		debug("RSA authentication using agent refused.");
 out:
	ssh_free_identitylist(idlist);
	ssh_close_authentication_socket(agent_fd);
	BN_clear_free(challenge);
	return ret;
}

/*
 * Computes the proper response to a RSA challenge, and sends the response to
 * the server.
 */
static void
respond_to_rsa_challenge(BIGNUM * challenge, RSA * prv)
{
	u_char buf[32], response[16];
	struct ssh_digest_ctx *md;
	int i, len;

	/* Decrypt the challenge using the private key. */
	/* XXX think about Bleichenbacher, too */
	if (rsa_private_decrypt(challenge, challenge, prv) != 0)
		packet_disconnect(
		    "respond_to_rsa_challenge: rsa_private_decrypt failed");

	/* Compute the response. */
	/* The response is MD5 of decrypted challenge plus session id. */
	len = BN_num_bytes(challenge);
	if (len <= 0 || (u_int)len > sizeof(buf))
		packet_disconnect(
		    "respond_to_rsa_challenge: bad challenge length %d", len);

	memset(buf, 0, sizeof(buf));
	BN_bn2bin(challenge, buf + sizeof(buf) - len);
	if ((md = ssh_digest_start(SSH_DIGEST_MD5)) == NULL ||
	    ssh_digest_update(md, buf, 32) < 0 ||
	    ssh_digest_update(md, session_id, 16) < 0 ||
	    ssh_digest_final(md, response, sizeof(response)) < 0)
		fatal("%s: md5 failed", __func__);
	ssh_digest_free(md);

	debug("Sending response to host key RSA challenge.");

	/* Send the response back to the server. */
	packet_start(SSH_CMSG_AUTH_RSA_RESPONSE);
	for (i = 0; i < 16; i++)
		packet_put_char(response[i]);
	packet_send();
	packet_write_wait();

	explicit_bzero(buf, sizeof(buf));
	explicit_bzero(response, sizeof(response));
	explicit_bzero(&md, sizeof(md));
}

/*
 * Checks if the user has authentication file, and if so, tries to authenticate
 * the user using it.
 */
static int
try_rsa_authentication(int idx)
{
	BIGNUM *challenge;
	Key *public, *private;
	char buf[300], *passphrase = NULL, *comment, *authfile;
	int i, perm_ok = 1, type, quit;

	public = options.identity_keys[idx];
	authfile = options.identity_files[idx];
	comment = xstrdup(authfile);

	debug("Trying RSA authentication with key '%.100s'", comment);

	/* Tell the server that we are willing to authenticate using this key. */
	packet_start(SSH_CMSG_AUTH_RSA);
	packet_put_bignum(public->rsa->n);
	packet_send();
	packet_write_wait();

	/* Wait for server's response. */
	type = packet_read();

	/*
	 * The server responds with failure if it doesn't like our key or
	 * doesn't support RSA authentication.
	 */
	if (type == SSH_SMSG_FAILURE) {
		debug("Server refused our key.");
		free(comment);
		return 0;
	}
	/* Otherwise, the server should respond with a challenge. */
	if (type != SSH_SMSG_AUTH_RSA_CHALLENGE)
		packet_disconnect("Protocol error during RSA authentication: %d", type);

	/* Get the challenge from the packet. */
	if ((challenge = BN_new()) == NULL)
		fatal("try_rsa_authentication: BN_new failed");
	packet_get_bignum(challenge);
	packet_check_eom();

	debug("Received RSA challenge from server.");

	/*
	 * If the key is not stored in external hardware, we have to
	 * load the private key.  Try first with empty passphrase; if it
	 * fails, ask for a passphrase.
	 */
	if (public->flags & SSHKEY_FLAG_EXT)
		private = public;
	else
		private = key_load_private_type(KEY_RSA1, authfile, "", NULL,
		    &perm_ok);
	if (private == NULL && !options.batch_mode && perm_ok) {
		snprintf(buf, sizeof(buf),
		    "Enter passphrase for RSA key '%.100s': ", comment);
		for (i = 0; i < options.number_of_password_prompts; i++) {
			passphrase = read_passphrase(buf, 0);
			if (strcmp(passphrase, "") != 0) {
				private = key_load_private_type(KEY_RSA1,
				    authfile, passphrase, NULL, NULL);
				quit = 0;
			} else {
				debug2("no passphrase given, try next key");
				quit = 1;
			}
			if (private != NULL || quit)
				break;
			debug2("bad passphrase given, try again...");
		}
	}

	if (private != NULL)
		maybe_add_key_to_agent(authfile, private, comment, passphrase);

	if (passphrase != NULL) {
		explicit_bzero(passphrase, strlen(passphrase));
		free(passphrase);
	}

	/* We no longer need the comment. */
	free(comment);

	if (private == NULL) {
		if (!options.batch_mode && perm_ok)
			error("Bad passphrase.");

		/* Send a dummy response packet to avoid protocol error. */
		packet_start(SSH_CMSG_AUTH_RSA_RESPONSE);
		for (i = 0; i < 16; i++)
			packet_put_char(0);
		packet_send();
		packet_write_wait();

		/* Expect the server to reject it... */
		packet_read_expect(SSH_SMSG_FAILURE);
		BN_clear_free(challenge);
		return 0;
	}

	/* Compute and send a response to the challenge. */
	respond_to_rsa_challenge(challenge, private->rsa);

	/* Destroy the private key unless it in external hardware. */
	if (!(private->flags & SSHKEY_FLAG_EXT))
		key_free(private);

	/* We no longer need the challenge. */
	BN_clear_free(challenge);

	/* Wait for response from the server. */
	type = packet_read();
	if (type == SSH_SMSG_SUCCESS) {
		debug("RSA authentication accepted by server.");
		return 1;
	}
	if (type != SSH_SMSG_FAILURE)
		packet_disconnect("Protocol error waiting RSA auth response: %d", type);
	debug("RSA authentication refused.");
	return 0;
}

/*
 * Tries to authenticate the user using combined rhosts or /etc/hosts.equiv
 * authentication and RSA host authentication.
 */
static int
try_rhosts_rsa_authentication(const char *local_user, Key * host_key)
{
	int type;
	BIGNUM *challenge;

	debug("Trying rhosts or /etc/hosts.equiv with RSA host authentication.");

	/* Tell the server that we are willing to authenticate using this key. */
	packet_start(SSH_CMSG_AUTH_RHOSTS_RSA);
	packet_put_cstring(local_user);
	packet_put_int(BN_num_bits(host_key->rsa->n));
	packet_put_bignum(host_key->rsa->e);
	packet_put_bignum(host_key->rsa->n);
	packet_send();
	packet_write_wait();

	/* Wait for server's response. */
	type = packet_read();

	/* The server responds with failure if it doesn't admit our
	   .rhosts authentication or doesn't know our host key. */
	if (type == SSH_SMSG_FAILURE) {
		debug("Server refused our rhosts authentication or host key.");
		return 0;
	}
	/* Otherwise, the server should respond with a challenge. */
	if (type != SSH_SMSG_AUTH_RSA_CHALLENGE)
		packet_disconnect("Protocol error during RSA authentication: %d", type);

	/* Get the challenge from the packet. */
	if ((challenge = BN_new()) == NULL)
		fatal("try_rhosts_rsa_authentication: BN_new failed");
	packet_get_bignum(challenge);
	packet_check_eom();

	debug("Received RSA challenge for host key from server.");

	/* Compute a response to the challenge. */
	respond_to_rsa_challenge(challenge, host_key->rsa);

	/* We no longer need the challenge. */
	BN_clear_free(challenge);

	/* Wait for response from the server. */
	type = packet_read();
	if (type == SSH_SMSG_SUCCESS) {
		debug("Rhosts or /etc/hosts.equiv with RSA host authentication accepted by server.");
		return 1;
	}
	if (type != SSH_SMSG_FAILURE)
		packet_disconnect("Protocol error waiting RSA auth response: %d", type);
	debug("Rhosts or /etc/hosts.equiv with RSA host authentication refused.");
	return 0;
}

/*
 * Tries to authenticate with any string-based challenge/response system.
 * Note that the client code is not tied to s/key or TIS.
 */
static int
try_challenge_response_authentication(void)
{
	int type, i;
	u_int clen;
	char prompt[1024];
	char *challenge, *response;

	debug("Doing challenge response authentication.");

	for (i = 0; i < options.number_of_password_prompts; i++) {
		/* request a challenge */
		packet_start(SSH_CMSG_AUTH_TIS);
		packet_send();
		packet_write_wait();

		type = packet_read();
		if (type != SSH_SMSG_FAILURE &&
		    type != SSH_SMSG_AUTH_TIS_CHALLENGE) {
			packet_disconnect("Protocol error: got %d in response "
			    "to SSH_CMSG_AUTH_TIS", type);
		}
		if (type != SSH_SMSG_AUTH_TIS_CHALLENGE) {
			debug("No challenge.");
			return 0;
		}
		challenge = packet_get_string(&clen);
		packet_check_eom();
		snprintf(prompt, sizeof prompt, "%s%s", challenge,
		    strchr(challenge, '\n') ? "" : "\nResponse: ");
		free(challenge);
		if (i != 0)
			error("Permission denied, please try again.");
		if (options.cipher == SSH_CIPHER_NONE)
			logit("WARNING: Encryption is disabled! "
			    "Response will be transmitted in clear text.");
		response = read_passphrase(prompt, 0);
		if (strcmp(response, "") == 0) {
			free(response);
			break;
		}
		packet_start(SSH_CMSG_AUTH_TIS_RESPONSE);
		ssh_put_password(response);
		explicit_bzero(response, strlen(response));
		free(response);
		packet_send();
		packet_write_wait();
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS)
			return 1;
		if (type != SSH_SMSG_FAILURE)
			packet_disconnect("Protocol error: got %d in response "
			    "to SSH_CMSG_AUTH_TIS_RESPONSE", type);
	}
	/* failure */
	return 0;
}

/*
 * Tries to authenticate with plain passwd authentication.
 */
static int
try_password_authentication(char *prompt)
{
	int type, i;
	char *password;

	debug("Doing password authentication.");
	if (options.cipher == SSH_CIPHER_NONE)
		logit("WARNING: Encryption is disabled! Password will be transmitted in clear text.");
	for (i = 0; i < options.number_of_password_prompts; i++) {
		if (i != 0)
			error("Permission denied, please try again.");
		password = read_passphrase(prompt, 0);
		packet_start(SSH_CMSG_AUTH_PASSWORD);
		ssh_put_password(password);
		explicit_bzero(password, strlen(password));
		free(password);
		packet_send();
		packet_write_wait();

		type = packet_read();
		if (type == SSH_SMSG_SUCCESS)
			return 1;
		if (type != SSH_SMSG_FAILURE)
			packet_disconnect("Protocol error: got %d in response to passwd auth", type);
	}
	/* failure */
	return 0;
}

/*
 * SSH1 key exchange
 */
void
ssh_kex(char *host, struct sockaddr *hostaddr)
{
	int i;
	BIGNUM *key;
	Key *host_key, *server_key;
	int bits, rbits;
	int ssh_cipher_default = SSH_CIPHER_3DES;
	u_char session_key[SSH_SESSION_KEY_LENGTH];
	u_char cookie[8];
	u_int supported_ciphers;
	u_int server_flags, client_flags;

	debug("Waiting for server public key.");

	/* Wait for a public key packet from the server. */
	packet_read_expect(SSH_SMSG_PUBLIC_KEY);

	/* Get cookie from the packet. */
	for (i = 0; i < 8; i++)
		cookie[i] = packet_get_char();

	/* Get the public key. */
	if ((server_key = key_new(KEY_RSA1)) == NULL)
		fatal("%s: key_new(KEY_RSA1) failed", __func__);
	bits = packet_get_int();
	packet_get_bignum(server_key->rsa->e);
	packet_get_bignum(server_key->rsa->n);

	rbits = BN_num_bits(server_key->rsa->n);
	if (bits != rbits) {
		logit("Warning: Server lies about size of server public key: "
		    "actual size is %d bits vs. announced %d.", rbits, bits);
		logit("Warning: This may be due to an old implementation of ssh.");
	}
	/* Get the host key. */
	if ((host_key = key_new(KEY_RSA1)) == NULL)
		fatal("%s: key_new(KEY_RSA1) failed", __func__);
	bits = packet_get_int();
	packet_get_bignum(host_key->rsa->e);
	packet_get_bignum(host_key->rsa->n);

	rbits = BN_num_bits(host_key->rsa->n);
	if (bits != rbits) {
		logit("Warning: Server lies about size of server host key: "
		    "actual size is %d bits vs. announced %d.", rbits, bits);
		logit("Warning: This may be due to an old implementation of ssh.");
	}

	/* Get protocol flags. */
	server_flags = packet_get_int();
	packet_set_protocol_flags(server_flags);

	supported_ciphers = packet_get_int();
	supported_authentications = packet_get_int();
	packet_check_eom();

	debug("Received server public key (%d bits) and host key (%d bits).",
	    BN_num_bits(server_key->rsa->n), BN_num_bits(host_key->rsa->n));

	if (verify_host_key(host, hostaddr, host_key) == -1)
		fatal("Host key verification failed.");

	client_flags = SSH_PROTOFLAG_SCREEN_NUMBER | SSH_PROTOFLAG_HOST_IN_FWD_OPEN;

	derive_ssh1_session_id(host_key->rsa->n, server_key->rsa->n, cookie, session_id);

	/*
	 * Generate an encryption key for the session.   The key is a 256 bit
	 * random number, interpreted as a 32-byte key, with the least
	 * significant 8 bits being the first byte of the key.
	 */
	arc4random_buf(session_key, sizeof(session_key));

	/*
	 * According to the protocol spec, the first byte of the session key
	 * is the highest byte of the integer.  The session key is xored with
	 * the first 16 bytes of the session id.
	 */
	if ((key = BN_new()) == NULL)
		fatal("ssh_kex: BN_new failed");
	if (BN_set_word(key, 0) == 0)
		fatal("ssh_kex: BN_set_word failed");
	for (i = 0; i < SSH_SESSION_KEY_LENGTH; i++) {
		if (BN_lshift(key, key, 8) == 0)
			fatal("ssh_kex: BN_lshift failed");
		if (i < 16) {
			if (BN_add_word(key, session_key[i] ^ session_id[i])
			    == 0)
				fatal("ssh_kex: BN_add_word failed");
		} else {
			if (BN_add_word(key, session_key[i]) == 0)
				fatal("ssh_kex: BN_add_word failed");
		}
	}

	/*
	 * Encrypt the integer using the public key and host key of the
	 * server (key with smaller modulus first).
	 */
	if (BN_cmp(server_key->rsa->n, host_key->rsa->n) < 0) {
		/* Public key has smaller modulus. */
		if (BN_num_bits(host_key->rsa->n) <
		    BN_num_bits(server_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("respond_to_rsa_challenge: host_key %d < server_key %d + "
			    "SSH_KEY_BITS_RESERVED %d",
			    BN_num_bits(host_key->rsa->n),
			    BN_num_bits(server_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
		}
		if (rsa_public_encrypt(key, key, server_key->rsa) != 0 ||
		    rsa_public_encrypt(key, key, host_key->rsa) != 0)
			fatal("%s: rsa_public_encrypt failed", __func__);
	} else {
		/* Host key has smaller modulus (or they are equal). */
		if (BN_num_bits(server_key->rsa->n) <
		    BN_num_bits(host_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("respond_to_rsa_challenge: server_key %d < host_key %d + "
			    "SSH_KEY_BITS_RESERVED %d",
			    BN_num_bits(server_key->rsa->n),
			    BN_num_bits(host_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
		}
		if (rsa_public_encrypt(key, key, host_key->rsa) != 0 ||
		    rsa_public_encrypt(key, key, server_key->rsa) != 0)
			fatal("%s: rsa_public_encrypt failed", __func__);
	}

	/* Destroy the public keys since we no longer need them. */
	key_free(server_key);
	key_free(host_key);

	if (options.cipher == SSH_CIPHER_NOT_SET) {
		if (cipher_mask_ssh1(1) & supported_ciphers & (1 << ssh_cipher_default))
			options.cipher = ssh_cipher_default;
	} else if (options.cipher == SSH_CIPHER_INVALID ||
	    !(cipher_mask_ssh1(1) & (1 << options.cipher))) {
		logit("No valid SSH1 cipher, using %.100s instead.",
		    cipher_name(ssh_cipher_default));
		options.cipher = ssh_cipher_default;
	}
	/* Check that the selected cipher is supported. */
	if (!(supported_ciphers & (1 << options.cipher)))
		fatal("Selected cipher type %.100s not supported by server.",
		    cipher_name(options.cipher));

	debug("Encryption type: %.100s", cipher_name(options.cipher));

	/* Send the encrypted session key to the server. */
	packet_start(SSH_CMSG_SESSION_KEY);
	packet_put_char(options.cipher);

	/* Send the cookie back to the server. */
	for (i = 0; i < 8; i++)
		packet_put_char(cookie[i]);

	/* Send and destroy the encrypted encryption key integer. */
	packet_put_bignum(key);
	BN_clear_free(key);

	/* Send protocol flags. */
	packet_put_int(client_flags);

	/* Send the packet now. */
	packet_send();
	packet_write_wait();

	debug("Sent encrypted session key.");

	/* Set the encryption key. */
	packet_set_encryption_key(session_key, SSH_SESSION_KEY_LENGTH, options.cipher);

	/*
	 * We will no longer need the session key here.
	 * Destroy any extra copies.
	 */
	explicit_bzero(session_key, sizeof(session_key));

	/*
	 * Expect a success message from the server.  Note that this message
	 * will be received in encrypted form.
	 */
	packet_read_expect(SSH_SMSG_SUCCESS);

	debug("Received encrypted confirmation.");
}

/*
 * Authenticate user
 */
void
ssh_userauth1(const char *local_user, const char *server_user, char *host,
    Sensitive *sensitive)
{
	int i, type;

	if (supported_authentications == 0)
		fatal("ssh_userauth1: server supports no auth methods");

	/* Send the name of the user to log in as on the server. */
	packet_start(SSH_CMSG_USER);
	packet_put_cstring(server_user);
	packet_send();
	packet_write_wait();

	/*
	 * The server should respond with success if no authentication is
	 * needed (the user has no password).  Otherwise the server responds
	 * with failure.
	 */
	type = packet_read();

	/* check whether the connection was accepted without authentication. */
	if (type == SSH_SMSG_SUCCESS)
		goto success;
	if (type != SSH_SMSG_FAILURE)
		packet_disconnect("Protocol error: got %d in response to SSH_CMSG_USER", type);

	/*
	 * Try .rhosts or /etc/hosts.equiv authentication with RSA host
	 * authentication.
	 */
	if ((supported_authentications & (1 << SSH_AUTH_RHOSTS_RSA)) &&
	    options.rhosts_rsa_authentication) {
		for (i = 0; i < sensitive->nkeys; i++) {
			if (sensitive->keys[i] != NULL &&
			    sensitive->keys[i]->type == KEY_RSA1 &&
			    try_rhosts_rsa_authentication(local_user,
			    sensitive->keys[i]))
				goto success;
		}
	}
	/* Try RSA authentication if the server supports it. */
	if ((supported_authentications & (1 << SSH_AUTH_RSA)) &&
	    options.rsa_authentication) {
		/*
		 * Try RSA authentication using the authentication agent. The
		 * agent is tried first because no passphrase is needed for
		 * it, whereas identity files may require passphrases.
		 */
		if (try_agent_authentication())
			goto success;

		/* Try RSA authentication for each identity. */
		for (i = 0; i < options.num_identity_files; i++)
			if (options.identity_keys[i] != NULL &&
			    options.identity_keys[i]->type == KEY_RSA1 &&
			    try_rsa_authentication(i))
				goto success;
	}
	/* Try challenge response authentication if the server supports it. */
	if ((supported_authentications & (1 << SSH_AUTH_TIS)) &&
	    options.challenge_response_authentication && !options.batch_mode) {
		if (try_challenge_response_authentication())
			goto success;
	}
	/* Try password authentication if the server supports it. */
	if ((supported_authentications & (1 << SSH_AUTH_PASSWORD)) &&
	    options.password_authentication && !options.batch_mode) {
		char prompt[80];

		snprintf(prompt, sizeof(prompt), "%.30s@@%.128s's password: ",
		    server_user, host);
		if (try_password_authentication(prompt))
			goto success;
	}
	/* All authentication methods have failed.  Exit with an error message. */
	fatal("Permission denied.");
	/* NOTREACHED */

 success:
	return;	/* need statement after label */
}
@


1.80
log
@Check for NULL return value from key_new.  Patch from jjelen at redhat.com
via bz#2687, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.79 2016/09/19 07:52:42 natano Exp $ */
@


1.79
log
@Replace two more arc4random() loops with arc4random_buf().

tweaks and ok dtucker
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.78 2015/11/15 22:26:49 jcs Exp $ */
d518 2
a519 1
	server_key = key_new(KEY_RSA1);
d531 2
a532 1
	host_key = key_new(KEY_RSA1);
@


1.78
log
@Add an AddKeysToAgent client option which can be set to 'yes', 'no',
'ask', or 'confirm', and defaults to 'no'.  When enabled, a private
key that is used during authentication will be added to ssh-agent if
it is running (with confirmation enabled if set to 'confirm').

Initial version from Joachim Schipper many years ago.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.77 2015/01/14 20:05:27 djm Exp $ */
a506 1
	u_int32_t rnd = 0;
d565 1
a565 6
	for (i = 0; i < 32; i++) {
		if (i % 4 == 0)
			rnd = arc4random();
		session_key[i] = rnd & 0xff;
		rnd >>= 8;
	}
@


1.77
log
@move authfd.c and its tentacles to the new buffer/key API;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.76 2014/07/15 15:54:14 millert Exp $ */
d219 1
a219 1
	char buf[300], *passphrase, *comment, *authfile;
a280 2
			explicit_bzero(passphrase, strlen(passphrase));
			free(passphrase);
d286 9
@


1.76
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.75 2014/06/24 01:13:21 djm Exp $ */
d21 1
d48 1
d64 1
a64 3
	int type;
	char *comment;
	AuthenticationConnection *auth;
d66 1
a66 2
	u_int i;
	Key *key;
d68 1
d71 4
a74 2
	auth = ssh_get_authentication_connection();
	if (!auth)
d76 1
d80 1
d82 7
a88 4
	for (key = ssh_get_first_identity(auth, &comment, 1);
	    key != NULL;
	    key = ssh_get_next_identity(auth, &comment, 1)) {

d90 2
a91 2
		debug("Trying RSA authentication via agent with '%.100s'", comment);
		free(comment);
d95 1
a95 1
		packet_put_bignum(key->rsa->n);
a105 1
			key_free(key);
d119 2
a120 1
		if (!ssh_decrypt_challenge(auth, key, challenge, session_id, 1, response)) {
d126 2
a127 1
			logit("Authentication agent failed to decrypt challenge.");
a129 1
		key_free(key);
d142 4
a145 1
		/* The server returns success if it accepted the authentication. */
a146 2
			ssh_close_authentication_connection(auth);
			BN_clear_free(challenge);
d148 5
a152 6
			return 1;
		}
		/* Otherwise it should return failure. */
		if (type != SSH_SMSG_FAILURE)
			packet_disconnect("Protocol error waiting RSA auth response: %d",
					  type);
d154 5
a158 1
	ssh_close_authentication_connection(auth);
d160 1
a160 2
	debug("RSA authentication using agent refused.");
	return 0;
@


1.75
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.74 2014/02/02 03:44:32 djm Exp $ */
d38 1
a42 1
#include "misc.h"
@


1.74
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.73 2014/01/27 19:18:54 markus Exp $ */
d166 1
a166 1
	if (rsa_private_decrypt(challenge, challenge, prv) <= 0)
d253 1
a253 1
	if (public->flags & KEY_FLAG_EXT)
d302 1
a302 1
	if (!(private->flags & KEY_FLAG_EXT))
d592 3
a594 2
		rsa_public_encrypt(key, key, server_key->rsa);
		rsa_public_encrypt(key, key, host_key->rsa);
d605 3
a607 2
		rsa_public_encrypt(key, key, host_key->rsa);
		rsa_public_encrypt(key, key, server_key->rsa);
@


1.73
log
@replace openssl MD5 with our ssh_digest_*; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.72 2013/09/02 22:00:34 deraadt Exp $ */
d120 1
a120 1
			memset(response, 0, sizeof(response));
d195 3
a197 3
	memset(buf, 0, sizeof(buf));
	memset(response, 0, sizeof(response));
	memset(&md, 0, sizeof(md));
d271 1
a271 1
			memset(passphrase, 0, strlen(passphrase));
d427 1
a427 1
		memset(response, 0, strlen(response));
d460 1
a460 1
		memset(password, 0, strlen(password));
d652 5
a656 2
	/* We will no longer need the session key here.  Destroy any extra copies. */
	memset(session_key, 0, sizeof(session_key));
@


1.72
log
@All the instances of arc4random_stir() are bogus, since arc4random()
does this itself, inside itself, and has for a very long time..  Actually,
this was probably reducing the entropy available.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.71 2013/05/17 00:13:14 djm Exp $ */
a19 1
#include <openssl/md5.h>
d46 1
d161 1
a161 1
	MD5_CTX md;
d179 6
a184 4
	MD5_Init(&md);
	MD5_Update(&md, buf, 32);
	MD5_Update(&md, session_id, 16);
	MD5_Final(response, &md);
@


1.71
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.70 2006/11/06 21:25:28 markus Exp $ */
a540 3

	/* Generate a session key. */
	arc4random_stir();
@


1.70
log
@add missing checks for openssl return codes; with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.69 2006/08/03 03:34:42 deraadt Exp $ */
d84 1
a84 1
		xfree(comment);
d231 1
a231 1
		xfree(comment);
d270 1
a270 1
			xfree(passphrase);
d277 1
a277 1
	xfree(comment);
d412 1
a412 1
		xfree(challenge);
d420 1
a420 1
			xfree(response);
d426 1
a426 1
		xfree(response);
d459 1
a459 1
		xfree(password);
@


1.69
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.68 2006/08/01 23:22:47 stevesk Exp $ */
d563 3
a565 2
		fatal("respond_to_rsa_challenge: BN_new failed");
	BN_set_word(key, 0);
d567 10
a576 5
		BN_lshift(key, key, 8);
		if (i < 16)
			BN_add_word(key, session_key[i] ^ session_id[i]);
		else
			BN_add_word(key, session_key[i]);
@


1.69.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.70 2006/11/06 21:25:28 markus Exp $ */
d563 2
a564 3
		fatal("ssh_kex: BN_new failed");
	if (BN_set_word(key, 0) == 0)
		fatal("ssh_kex: BN_set_word failed");
d566 5
a570 10
		if (BN_lshift(key, key, 8) == 0)
			fatal("ssh_kex: BN_lshift failed");
		if (i < 16) {
			if (BN_add_word(key, session_key[i] ^ session_id[i])
			    == 0)
				fatal("ssh_kex: BN_add_word failed");
		} else {
			if (BN_add_word(key, session_key[i]) == 0)
				fatal("ssh_kex: BN_add_word failed");
		}
@


1.68
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.67 2006/07/26 13:57:17 stevesk Exp $ */
d16 2
a17 1
#include "includes.h"
d25 2
d28 1
a30 1
#include "xmalloc.h"
d34 2
a39 1
#include "key.h"
a43 1
#include "cipher.h"
d45 1
@


1.67
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.66 2006/07/22 20:48:23 stevesk Exp $ */
d21 1
@


1.66
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.65 2006/04/25 08:02:27 dtucker Exp $ */
d21 1
@


1.65
log
@Prevent ssh from trying to open private keys with bad permissions more than
once or prompting for their passphrases (which it subsequently ignores
anyway), similar to a previous change in ssh-add.  bz #1186, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.64 2006/03/25 13:17:02 djm Exp $ */
d20 2
@


1.64
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d200 1
a200 1
	int i, type, quit;
d246 3
a248 2
		private = key_load_private_type(KEY_RSA1, authfile, "", NULL);
	if (private == NULL && !options.batch_mode) {
d255 1
a255 1
				    authfile, passphrase, NULL);
d272 1
a272 1
		if (!options.batch_mode)
@


1.63
log
@RCSID() can die
@
text
@d1 1
@


1.62
log
@no need to escape single quotes in comments, no binary change
@
text
@a15 1
RCSID("$OpenBSD: sshconnect1.c,v 1.61 2005/06/17 02:44:33 djm Exp $");
@


1.62.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: sshconnect1.c,v 1.69 2006/08/03 03:34:42 deraadt Exp $ */
d15 2
a16 2
#include <sys/types.h>
#include <sys/socket.h>
a20 7
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <pwd.h>

#include "xmalloc.h"
d23 1
a26 2
#include "key.h"
#include "cipher.h"
d31 1
d36 1
a37 1
#include "hostfile.h"
d200 1
a200 1
	int i, perm_ok = 1, type, quit;
d246 2
a247 3
		private = key_load_private_type(KEY_RSA1, authfile, "", NULL,
		    &perm_ok);
	if (private == NULL && !options.batch_mode && perm_ok) {
d254 1
a254 1
				    authfile, passphrase, NULL, NULL);
d271 1
a271 1
		if (!options.batch_mode && perm_ok)
@


1.62.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.70 2006/11/06 21:25:28 markus Exp $ */
d563 2
a564 3
		fatal("ssh_kex: BN_new failed");
	if (BN_set_word(key, 0) == 0)
		fatal("ssh_kex: BN_set_word failed");
d566 5
a570 10
		if (BN_lshift(key, key, 8) == 0)
			fatal("ssh_kex: BN_lshift failed");
		if (i < 16) {
			if (BN_add_word(key, session_key[i] ^ session_id[i])
			    == 0)
				fatal("ssh_kex: BN_add_word failed");
		} else {
			if (BN_add_word(key, session_key[i]) == 0)
				fatal("ssh_kex: BN_add_word failed");
		}
@


1.61
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.60 2004/07/28 09:40:29 markus Exp $");
d87 1
a87 1
		/* The server sends failure if it doesn\'t like our key or
d218 2
a219 2
	 * The server responds with failure if it doesn\'t like our key or
	 * doesn\'t support RSA authentication.
@


1.61.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.62 2005/10/30 08:52:18 djm Exp $");
d87 1
a87 1
		/* The server sends failure if it doesn't like our key or
d218 2
a219 2
	 * The server responds with failure if it doesn't like our key or
	 * doesn't support RSA authentication.
@


1.61.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: sshconnect1.c,v 1.69 2006/08/03 03:34:42 deraadt Exp $ */
d15 2
a16 2
#include <sys/types.h>
#include <sys/socket.h>
a20 7
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <pwd.h>

#include "xmalloc.h"
d23 1
a26 2
#include "key.h"
#include "cipher.h"
d31 1
d36 1
a37 1
#include "hostfile.h"
d200 1
a200 1
	int i, perm_ok = 1, type, quit;
d246 2
a247 3
		private = key_load_private_type(KEY_RSA1, authfile, "", NULL,
		    &perm_ok);
	if (private == NULL && !options.batch_mode && perm_ok) {
d254 1
a254 1
				    authfile, passphrase, NULL, NULL);
d271 1
a271 1
		if (!options.batch_mode && perm_ok)
@


1.61.2.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect1.c,v 1.70 2006/11/06 21:25:28 markus Exp $ */
d563 2
a564 3
		fatal("ssh_kex: BN_new failed");
	if (BN_set_word(key, 0) == 0)
		fatal("ssh_kex: BN_set_word failed");
d566 5
a570 10
		if (BN_lshift(key, key, 8) == 0)
			fatal("ssh_kex: BN_lshift failed");
		if (i < 16) {
			if (BN_add_word(key, session_key[i] ^ session_id[i])
			    == 0)
				fatal("ssh_kex: BN_add_word failed");
		} else {
			if (BN_add_word(key, session_key[i]) == 0)
				fatal("ssh_kex: BN_add_word failed");
		}
@


1.60
log
@more s/illegal/invalid/
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.59 2004/06/21 17:36:31 avsm Exp $");
d165 1
a165 1
	if (len <= 0 || len > sizeof(buf))
@


1.60.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.61 2005/06/17 02:44:33 djm Exp $");
d165 1
a165 1
	if (len <= 0 || (u_int)len > sizeof(buf))
@


1.60.4.2
log
@upgrade to OpenSSH 4.3
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.62 2005/10/30 08:52:18 djm Exp $");
d87 1
a87 1
		/* The server sends failure if it doesn't like our key or
d218 2
a219 2
	 * The server responds with failure if it doesn't like our key or
	 * doesn't support RSA authentication.
@


1.60.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.61 2005/06/17 02:44:33 djm Exp $");
d165 1
a165 1
	if (len <= 0 || (u_int)len > sizeof(buf))
@


1.59
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.58 2004/05/09 01:19:28 djm Exp $");
d601 1
a601 1
	} else if (options.cipher == SSH_CIPHER_ILLEGAL ||
@


1.58
log
@kill some more tiny files; ok deraadt@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.57 2004/05/08 00:21:31 djm Exp $");
d479 1
a479 1
	u_int32_t rand = 0;
d543 3
a545 3
			rand = arc4random();
		session_key[i] = rand & 0xff;
		rand >>= 8;
@


1.57
log
@kill a tiny header; ok deraadt@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.56 2003/08/28 12:54:34 markus Exp $");
d27 1
a27 1
#include "mpaux.h"
d531 1
a531 1
	compute_session_id(session_id, cookie, host_key->rsa->n, server_key->rsa->n);
@


1.56
log
@remove kerberos support from ssh1, since it has been replaced with GSSAPI;
but keep kerberos passwd auth for ssh1 and 2; ok djm, hin, henning, ...
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.55 2003/08/13 08:46:31 markus Exp $");
d35 1
a35 1
#include "readpass.h"
@


1.56.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.60 2004/07/28 09:40:29 markus Exp $");
d27 1
a27 1
#include "kex.h"
d35 1
a35 1
#include "misc.h"
d479 1
a479 1
	u_int32_t rnd = 0;
d531 1
a531 1
	derive_ssh1_session_id(host_key->rsa->n, server_key->rsa->n, cookie, session_id);
d543 3
a545 3
			rnd = arc4random();
		session_key[i] = rnd & 0xff;
		rnd >>= 8;
d601 1
a601 1
	} else if (options.cipher == SSH_CIPHER_INVALID ||
@


1.56.4.1
log
@upgrade to OpenSSH 3.9
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.60 2004/07/28 09:40:29 markus Exp $");
d27 1
a27 1
#include "kex.h"
d35 1
a35 1
#include "misc.h"
d479 1
a479 1
	u_int32_t rnd = 0;
d531 1
a531 1
	derive_ssh1_session_id(host_key->rsa->n, server_key->rsa->n, cookie, session_id);
d543 3
a545 3
			rnd = arc4random();
		session_key[i] = rnd & 0xff;
		rnd >>= 8;
d601 1
a601 1
	} else if (options.cipher == SSH_CIPHER_INVALID ||
@


1.55
log
@remove RhostsAuthentication; suggested by djm@@ before; ok djm@@, deraadt@@,
fgsch@@, miod@@, henning@@, jakob@@ and others
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.54 2003/07/22 13:35:22 markus Exp $");
a20 4
#ifdef KRB5
#include <krb5.h>
#endif

a368 184
#ifdef KRB5
static int
try_krb5_authentication(krb5_context *context, krb5_auth_context *auth_context)
{
	krb5_error_code problem;
	const char *tkfile;
	struct stat buf;
	krb5_ccache ccache = NULL;
	const char *remotehost;
	krb5_data ap;
	int type;
	krb5_ap_rep_enc_part *reply = NULL;
	int ret;

	memset(&ap, 0, sizeof(ap));

	problem = krb5_init_context(context);
	if (problem) {
		debug("Kerberos v5: krb5_init_context failed");
		ret = 0;
		goto out;
	}

	tkfile = krb5_cc_default_name(*context);
	if (strncmp(tkfile, "FILE:", 5) == 0)
		tkfile += 5;

	if (stat(tkfile, &buf) == 0 && getuid() != buf.st_uid) {
		debug("Kerberos v5: could not get default ccache (permission denied).");
		ret = 0;
		goto out;
	}

	problem = krb5_cc_default(*context, &ccache);
	if (problem) {
		debug("Kerberos v5: krb5_cc_default failed: %s",
		    krb5_get_err_text(*context, problem));
		ret = 0;
		goto out;
	}

	remotehost = get_canonical_hostname(1);

	problem = krb5_mk_req(*context, auth_context, AP_OPTS_MUTUAL_REQUIRED,
	    "host", remotehost, NULL, ccache, &ap);
	if (problem) {
		debug("Kerberos v5: krb5_mk_req failed: %s",
		    krb5_get_err_text(*context, problem));
		ret = 0;
		goto out;
	}

	packet_start(SSH_CMSG_AUTH_KERBEROS);
	packet_put_string((char *) ap.data, ap.length);
	packet_send();
	packet_write_wait();

	xfree(ap.data);
	ap.length = 0;

	type = packet_read();
	switch (type) {
	case SSH_SMSG_FAILURE:
		/* Should really be SSH_SMSG_AUTH_KERBEROS_FAILURE */
		debug("Kerberos v5 authentication failed.");
		ret = 0;
		break;

	case SSH_SMSG_AUTH_KERBEROS_RESPONSE:
		/* SSH_SMSG_AUTH_KERBEROS_SUCCESS */
		debug("Kerberos v5 authentication accepted.");

		/* Get server's response. */
		ap.data = packet_get_string((unsigned int *) &ap.length);
		packet_check_eom();
		/* XXX je to dobre? */

		problem = krb5_rd_rep(*context, *auth_context, &ap, &reply);
		if (problem) {
			ret = 0;
		}
		ret = 1;
		break;

	default:
		packet_disconnect("Protocol error on Kerberos v5 response: %d",
		    type);
		ret = 0;
		break;

	}

 out:
	if (ccache != NULL)
		krb5_cc_close(*context, ccache);
	if (reply != NULL)
		krb5_free_ap_rep_enc_part(*context, reply);
	if (ap.length > 0)
		krb5_data_free(&ap);

	return (ret);
}

static void
send_krb5_tgt(krb5_context context, krb5_auth_context auth_context)
{
	int fd, type;
	krb5_error_code problem;
	krb5_data outbuf;
	krb5_ccache ccache = NULL;
	krb5_creds creds;
	krb5_kdc_flags flags;
	const char *remotehost;

	memset(&creds, 0, sizeof(creds));
	memset(&outbuf, 0, sizeof(outbuf));

	fd = packet_get_connection_in();

	problem = krb5_auth_con_setaddrs_from_fd(context, auth_context, &fd);
	if (problem)
		goto out;

	problem = krb5_cc_default(context, &ccache);
	if (problem)
		goto out;

	problem = krb5_cc_get_principal(context, ccache, &creds.client);
	if (problem)
		goto out;

	problem = krb5_build_principal(context, &creds.server,
	    strlen(creds.client->realm), creds.client->realm,
	    "krbtgt", creds.client->realm, NULL);
	if (problem)
		goto out;

	creds.times.endtime = 0;

	flags.i = 0;
	flags.b.forwarded = 1;
	flags.b.forwardable = krb5_config_get_bool(context,  NULL,
	    "libdefaults", "forwardable", NULL);

	remotehost = get_canonical_hostname(1);

	problem = krb5_get_forwarded_creds(context, auth_context,
	    ccache, flags.i, remotehost, &creds, &outbuf);
	if (problem)
		goto out;

	packet_start(SSH_CMSG_HAVE_KERBEROS_TGT);
	packet_put_string((char *)outbuf.data, outbuf.length);
	packet_send();
	packet_write_wait();

	type = packet_read();

	if (type == SSH_SMSG_SUCCESS) {
		char *pname;

		krb5_unparse_name(context, creds.client, &pname);
		debug("Kerberos v5 TGT forwarded (%s).", pname);
		xfree(pname);
	} else
		debug("Kerberos v5 TGT forwarding failed.");

	return;

 out:
	if (problem)
		debug("Kerberos v5 TGT forwarding failed: %s",
		    krb5_get_err_text(context, problem));
	if (creds.client)
		krb5_free_principal(context, creds.client);
	if (creds.server)
		krb5_free_principal(context, creds.server);
	if (ccache)
		krb5_cc_close(context, ccache);
	if (outbuf.data)
		xfree(outbuf.data);
}
#endif /* KRB5 */

a656 4
#ifdef KRB5
	krb5_context context = NULL;
	krb5_auth_context auth_context = NULL;
#endif
a680 15
#ifdef KRB5
	if ((supported_authentications & (1 << SSH_AUTH_KERBEROS)) &&
	    options.kerberos_authentication) {
		debug("Trying Kerberos v5 authentication.");

		if (try_krb5_authentication(&context, &auth_context)) {
			type = packet_read();
			if (type == SSH_SMSG_SUCCESS)
				goto success;
			if (type != SSH_SMSG_FAILURE)
				packet_disconnect("Protocol error: got %d in response to Kerberos v5 auth", type);
		}
	}
#endif /* KRB5 */

a733 13
#ifdef KRB5
	/* Try Kerberos v5 TGT passing. */
	if ((supported_authentications & (1 << SSH_PASS_KERBEROS_TGT)) &&
	    options.kerberos_tgt_passing && context && auth_context) {
		if (options.cipher == SSH_CIPHER_NONE)
			logit("WARNING: Encryption is disabled! Ticket will be transmitted in the clear!");
		send_krb5_tgt(context, auth_context);
	}
	if (auth_context)
		krb5_auth_con_free(context, auth_context);
	if (context)
		krb5_free_context(context);
#endif
@


1.54
log
@remove (already disabled) KRB4/AFS support, re-enable -k in ssh(1);
test+ok henning@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.53 2003/04/08 20:21:29 itojun Exp $");
a887 20
	/*
	 * Use rhosts authentication if running in privileged socket and we
	 * do not wish to remain anonymous.
	 */
	if ((supported_authentications & (1 << SSH_AUTH_RHOSTS)) &&
	    options.rhosts_authentication) {
		debug("Trying rhosts authentication.");
		packet_start(SSH_CMSG_AUTH_RHOSTS);
		packet_put_cstring(local_user);
		packet_send();
		packet_write_wait();

		/* The server should respond with success or failure. */
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS)
			goto success;
		if (type != SSH_SMSG_FAILURE)
			packet_disconnect("Protocol error: got %d in response to rhosts auth",
					  type);
	}
@


1.53
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.52 2002/08/08 13:50:23 aaron Exp $");
a20 3
#ifdef KRB4
#include <krb.h>
#endif
a23 4
#ifdef AFS
#include <kafs.h>
#include "radix.h"
#endif
a372 122
#ifdef KRB4
static int
try_krb4_authentication(void)
{
	KTEXT_ST auth;		/* Kerberos data */
	char *reply;
	char inst[INST_SZ];
	char *realm;
	CREDENTIALS cred;
	int r, type;
	socklen_t slen;
	Key_schedule schedule;
	u_long checksum, cksum;
	MSG_DAT msg_data;
	struct sockaddr_in local, foreign;
	struct stat st;

	/* Don't do anything if we don't have any tickets. */
	if (stat(tkt_string(), &st) < 0)
		return 0;

	strlcpy(inst, (char *)krb_get_phost(get_canonical_hostname(1)),
	    INST_SZ);

	realm = (char *)krb_realmofhost(get_canonical_hostname(1));
	if (!realm) {
		debug("Kerberos v4: no realm for %s", get_canonical_hostname(1));
		return 0;
	}
	/* This can really be anything. */
	checksum = (u_long)getpid();

	r = krb_mk_req(&auth, KRB4_SERVICE_NAME, inst, realm, checksum);
	if (r != KSUCCESS) {
		debug("Kerberos v4 krb_mk_req failed: %s", krb_err_txt[r]);
		return 0;
	}
	/* Get session key to decrypt the server's reply with. */
	r = krb_get_cred(KRB4_SERVICE_NAME, inst, realm, &cred);
	if (r != KSUCCESS) {
		debug("get_cred failed: %s", krb_err_txt[r]);
		return 0;
	}
	des_key_sched((des_cblock *) cred.session, schedule);

	/* Send authentication info to server. */
	packet_start(SSH_CMSG_AUTH_KERBEROS);
	packet_put_string((char *) auth.dat, auth.length);
	packet_send();
	packet_write_wait();

	/* Zero the buffer. */
	(void) memset(auth.dat, 0, MAX_KTXT_LEN);

	slen = sizeof(local);
	memset(&local, 0, sizeof(local));
	if (getsockname(packet_get_connection_in(),
	    (struct sockaddr *)&local, &slen) < 0)
		debug("getsockname failed: %s", strerror(errno));

	slen = sizeof(foreign);
	memset(&foreign, 0, sizeof(foreign));
	if (getpeername(packet_get_connection_in(),
	    (struct sockaddr *)&foreign, &slen) < 0) {
		debug("getpeername failed: %s", strerror(errno));
		fatal_cleanup();
	}
	/* Get server reply. */
	type = packet_read();
	switch (type) {
	case SSH_SMSG_FAILURE:
		/* Should really be SSH_SMSG_AUTH_KERBEROS_FAILURE */
		debug("Kerberos v4 authentication failed.");
		return 0;
		break;

	case SSH_SMSG_AUTH_KERBEROS_RESPONSE:
		/* SSH_SMSG_AUTH_KERBEROS_SUCCESS */
		debug("Kerberos v4 authentication accepted.");

		/* Get server's response. */
		reply = packet_get_string((u_int *) &auth.length);
		if (auth.length >= MAX_KTXT_LEN)
			fatal("Kerberos v4: Malformed response from server");
		memcpy(auth.dat, reply, auth.length);
		xfree(reply);

		packet_check_eom();

		/*
		 * If his response isn't properly encrypted with the session
		 * key, and the decrypted checksum fails to match, he's
		 * bogus. Bail out.
		 */
		r = krb_rd_priv(auth.dat, auth.length, schedule, &cred.session,
		    &foreign, &local, &msg_data);
		if (r != KSUCCESS) {
			debug("Kerberos v4 krb_rd_priv failed: %s",
			    krb_err_txt[r]);
			packet_disconnect("Kerberos v4 challenge failed!");
		}
		/* Fetch the (incremented) checksum that we supplied in the request. */
		memcpy((char *)&cksum, (char *)msg_data.app_data,
		    sizeof(cksum));
		cksum = ntohl(cksum);

		/* If it matches, we're golden. */
		if (cksum == checksum + 1) {
			debug("Kerberos v4 challenge successful.");
			return 1;
		} else
			packet_disconnect("Kerberos v4 challenge failed!");
		break;

	default:
		packet_disconnect("Protocol error on Kerberos v4 response: %d", type);
	}
	return 0;
}

#endif /* KRB4 */

a556 123
#ifdef AFS
static void
send_krb4_tgt(void)
{
	CREDENTIALS *creds;
	struct stat st;
	char buffer[4096], pname[ANAME_SZ], pinst[INST_SZ], prealm[REALM_SZ];
	int problem, type;

	/* Don't do anything if we don't have any tickets. */
	if (stat(tkt_string(), &st) < 0)
		return;

	creds = xmalloc(sizeof(*creds));

	problem = krb_get_tf_fullname(TKT_FILE, pname, pinst, prealm);
	if (problem)
		goto out;

	problem = krb_get_cred("krbtgt", prealm, prealm, creds);
	if (problem)
		goto out;

	if (time(0) > krb_life_to_time(creds->issue_date, creds->lifetime)) {
		problem = RD_AP_EXP;
		goto out;
	}
	creds_to_radix(creds, (u_char *)buffer, sizeof(buffer));

	packet_start(SSH_CMSG_HAVE_KERBEROS_TGT);
	packet_put_cstring(buffer);
	packet_send();
	packet_write_wait();

	type = packet_read();

	if (type == SSH_SMSG_SUCCESS)
		debug("Kerberos v4 TGT forwarded (%s%s%s@@%s).",
		    creds->pname, creds->pinst[0] ? "." : "",
		    creds->pinst, creds->realm);
	else
		debug("Kerberos v4 TGT rejected.");

	xfree(creds);
	return;

 out:
	debug("Kerberos v4 TGT passing failed: %s", krb_err_txt[problem]);
	xfree(creds);
}

static void
send_afs_tokens(void)
{
	CREDENTIALS creds;
	struct ViceIoctl parms;
	struct ClearToken ct;
	int i, type, len;
	char buf[2048], *p, *server_cell;
	char buffer[8192];

	/* Move over ktc_GetToken, here's something leaner. */
	for (i = 0; i < 100; i++) {	/* just in case */
		parms.in = (char *) &i;
		parms.in_size = sizeof(i);
		parms.out = buf;
		parms.out_size = sizeof(buf);
		if (k_pioctl(0, VIOCGETTOK, &parms, 0) != 0)
			break;
		p = buf;

		/* Get secret token. */
		memcpy(&creds.ticket_st.length, p, sizeof(u_int));
		if (creds.ticket_st.length > MAX_KTXT_LEN)
			break;
		p += sizeof(u_int);
		memcpy(creds.ticket_st.dat, p, creds.ticket_st.length);
		p += creds.ticket_st.length;

		/* Get clear token. */
		memcpy(&len, p, sizeof(len));
		if (len != sizeof(struct ClearToken))
			break;
		p += sizeof(len);
		memcpy(&ct, p, len);
		p += len;
		p += sizeof(len);	/* primary flag */
		server_cell = p;

		/* Flesh out our credentials. */
		strlcpy(creds.service, "afs", sizeof(creds.service));
		creds.instance[0] = '\0';
		strlcpy(creds.realm, server_cell, REALM_SZ);
		memcpy(creds.session, ct.HandShakeKey, DES_KEY_SZ);
		creds.issue_date = ct.BeginTimestamp;
		creds.lifetime = krb_time_to_life(creds.issue_date,
		    ct.EndTimestamp);
		creds.kvno = ct.AuthHandle;
		snprintf(creds.pname, sizeof(creds.pname), "AFS ID %d", ct.ViceId);
		creds.pinst[0] = '\0';

		/* Encode token, ship it off. */
		if (creds_to_radix(&creds, (u_char *)buffer,
		    sizeof(buffer)) <= 0)
			break;
		packet_start(SSH_CMSG_HAVE_AFS_TOKEN);
		packet_put_cstring(buffer);
		packet_send();
		packet_write_wait();

		/* Roger, Roger. Clearance, Clarence. What's your vector,
		   Victor? */
		type = packet_read();

		if (type == SSH_SMSG_FAILURE)
			debug("AFS token for cell %s rejected.", server_cell);
		else if (type != SSH_SMSG_SUCCESS)
			packet_disconnect("Protocol error on AFS token response: %d", type);
	}
}

#endif /* AFS */

a887 15
#ifdef KRB4
	if ((supported_authentications & (1 << SSH_AUTH_KERBEROS)) &&
	    options.kerberos_authentication) {
		debug("Trying Kerberos v4 authentication.");

		if (try_krb4_authentication()) {
			type = packet_read();
			if (type == SSH_SMSG_SUCCESS)
				goto success;
			if (type != SSH_SMSG_FAILURE)
				packet_disconnect("Protocol error: got %d in response to Kerberos v4 auth", type);
		}
	}
#endif /* KRB4 */

a973 18

#ifdef AFS
	/* Try Kerberos v4 TGT passing if the server supports it. */
	if ((supported_authentications & (1 << SSH_PASS_KERBEROS_TGT)) &&
	    options.kerberos_tgt_passing) {
		if (options.cipher == SSH_CIPHER_NONE)
			logit("WARNING: Encryption is disabled! Ticket will be transmitted in the clear!");
		send_krb4_tgt();
	}
	/* Try AFS token passing if the server supports it. */
	if ((supported_authentications & (1 << SSH_PASS_AFS_TOKEN)) &&
	    options.afs_token_passing && k_hasafs()) {
		if (options.cipher == SSH_CIPHER_NONE)
			logit("WARNING: Encryption is disabled! Token will be transmitted in the clear!");
		send_afs_tokens();
	}
#endif /* AFS */

@


1.52
log
@Use & to test if bits are set, not &&; markus@@ ok.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.51 2002/05/23 19:24:30 markus Exp $");
d122 1
a122 1
			log("Authentication agent failed to decrypt challenge.");
d847 1
a847 1
			log("WARNING: Encryption is disabled! "
d882 1
a882 1
		log("WARNING: Encryption is disabled! Password will be transmitted in clear text.");
d938 1
a938 1
		log("Warning: Server lies about size of server public key: "
d940 1
a940 1
		log("Warning: This may be due to an old implementation of ssh.");
d950 1
a950 1
		log("Warning: Server lies about size of server host key: "
d952 1
a952 1
		log("Warning: This may be due to an old implementation of ssh.");
d1043 1
a1043 1
		log("No valid SSH1 cipher, using %.100s instead.",
d1233 1
a1233 1
			log("WARNING: Encryption is disabled! Ticket will be transmitted in the clear!");
d1247 1
a1247 1
			log("WARNING: Encryption is disabled! Ticket will be transmitted in the clear!");
d1254 1
a1254 1
			log("WARNING: Encryption is disabled! Token will be transmitted in the clear!");
@


1.52.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.56 2003/08/28 12:54:34 markus Exp $");
d21 11
d122 1
a122 1
			logit("Authentication agent failed to decrypt challenge.");
d380 429
d847 1
a847 1
			logit("WARNING: Encryption is disabled! "
d882 1
a882 1
		logit("WARNING: Encryption is disabled! Password will be transmitted in clear text.");
d938 1
a938 1
		logit("Warning: Server lies about size of server public key: "
d940 1
a940 1
		logit("Warning: This may be due to an old implementation of ssh.");
d950 1
a950 1
		logit("Warning: Server lies about size of server host key: "
d952 1
a952 1
		logit("Warning: This may be due to an old implementation of ssh.");
d1043 1
a1043 1
		logit("No valid SSH1 cipher, using %.100s instead.",
d1097 4
d1125 50
d1228 31
@


1.52.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.56 2003/08/28 12:54:34 markus Exp $");
d21 11
d122 1
a122 1
			logit("Authentication agent failed to decrypt challenge.");
d380 429
d847 1
a847 1
			logit("WARNING: Encryption is disabled! "
d882 1
a882 1
		logit("WARNING: Encryption is disabled! Password will be transmitted in clear text.");
d938 1
a938 1
		logit("Warning: Server lies about size of server public key: "
d940 1
a940 1
		logit("Warning: This may be due to an old implementation of ssh.");
d950 1
a950 1
		logit("Warning: Server lies about size of server host key: "
d952 1
a952 1
		logit("Warning: This may be due to an old implementation of ssh.");
d1043 1
a1043 1
		logit("No valid SSH1 cipher, using %.100s instead.",
d1097 4
d1125 50
d1228 31
@


1.52.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@@


1.51
log
@add /usr/libexec/ssh-keysign: a setuid helper program for hostbased authentication
in protocol v2 (needs to access the hostkeys).
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.50 2002/04/21 16:25:06 stevesk Exp $");
d254 1
a254 1
	if (public->flags && KEY_FLAG_EXT)
@


1.50
log
@spelling in error message; ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.49 2002/03/14 15:24:27 markus Exp $");
d1095 1
a1095 1
    Key **keys, int nkeys)
d1181 5
a1185 3
		for (i = 0; i < nkeys; i++) {
			if (keys[i] != NULL && keys[i]->type == KEY_RSA1 &&
			    try_rhosts_rsa_authentication(local_user, keys[i]))
@


1.49
log
@don't trust size sent by (rogue) server; noted by s.esser@@e-matters.de
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.48 2002/02/11 16:15:46 markus Exp $");
d848 1
a848 1
			    "Reponse will be transmitted in clear text.");
@


1.49.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.50 2002/04/21 16:25:06 stevesk Exp $");
d848 1
a848 1
			    "Response will be transmitted in clear text.");
@


1.49.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.49.2.3
log
@Pull in OpenSSH-3.4
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.51 2002/05/23 19:24:30 markus Exp $");
d1095 1
a1095 1
    Sensitive *sensitive)
d1181 3
a1183 5
		for (i = 0; i < sensitive->nkeys; i++) {
			if (sensitive->keys[i] != NULL &&
			    sensitive->keys[i]->type == KEY_RSA1 &&
			    try_rhosts_rsa_authentication(local_user,
			    sensitive->keys[i]))
@


1.49.2.4
log
@Update to OpenSSH 3.5
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.52 2002/08/08 13:50:23 aaron Exp $");
d254 1
a254 1
	if (public->flags & KEY_FLAG_EXT)
@


1.48
log
@include md5.h, not evp.h
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.47 2001/12/28 14:50:54 markus Exp $");
d462 2
@


1.47
log
@packet_read* no longer return the packet length, since it's not used.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.46 2001/12/28 13:57:33 markus Exp $");
d19 1
a19 1
#include <openssl/evp.h>
@


1.46
log
@packet_get_bignum* no longer returns a size
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.45 2001/12/28 12:14:27 markus Exp $");
a69 1
	int plen;
d96 1
a96 1
		type = packet_read(&plen);
d136 1
a136 1
		type = packet_read(&plen);
d211 1
a211 1
	int i, type, quit, plen;
d226 1
a226 1
	type = packet_read(&plen);
d293 1
a293 1
		packet_read_expect(&plen, SSH_SMSG_FAILURE);
d309 1
a309 1
	type = packet_read(&plen);
a328 1
	int plen;
d342 1
a342 1
	type = packet_read(&plen);
d369 1
a369 1
	type = packet_read(&plen);
d389 1
a389 1
	int r, type, plen;
d448 1
a448 1
	type = packet_read(&plen);
d510 1
a510 1
	int type, payload_len;
d560 1
a560 1
	type = packet_read(&payload_len);
d606 1
a606 1
	int fd, type, payload_len;
d656 1
a656 1
	type = packet_read(&payload_len);
d691 1
a691 1
	int problem, type, len;
d718 1
a718 1
	type = packet_read(&len);
d796 1
a796 1
		type = packet_read(&len);
a814 1
	int payload_len;
d827 1
a827 1
		type = packet_read(&payload_len);
d858 1
a858 1
		type = packet_read(&payload_len);
d875 1
a875 1
	int type, i, payload_len;
d892 1
a892 1
		type = packet_read(&payload_len);
a916 1
	int payload_len;
d922 1
a922 1
	packet_read_expect(&payload_len, SSH_SMSG_PUBLIC_KEY);
d1083 1
a1083 1
	packet_read_expect(&payload_len, SSH_SMSG_SUCCESS);
a1099 1
	int payload_len;
d1115 1
a1115 1
	type = packet_read(&payload_len);
d1129 1
a1129 1
			type = packet_read(&payload_len);
d1144 1
a1144 1
			type = packet_read(&payload_len);
d1166 1
a1166 1
		type = packet_read(&payload_len);
@


1.45
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.44 2001/12/27 20:39:58 markus Exp $");
d70 1
a70 1
	int plen, clen;
d111 1
a111 1
		packet_get_bignum(challenge, &clen);
d212 1
a212 1
	int i, type, quit, plen, clen;
d245 1
a245 1
	packet_get_bignum(challenge, &clen);
d330 1
a330 1
	int plen, clen;
d359 1
a359 1
	packet_get_bignum(challenge, &clen);
d920 1
a920 1
	int payload_len, clen, sum_len = 0;
d935 2
a936 4
	packet_get_bignum(server_key->rsa->e, &clen);
	sum_len += clen;
	packet_get_bignum(server_key->rsa->n, &clen);
	sum_len += clen;
d947 2
a948 4
	packet_get_bignum(host_key->rsa->e, &clen);
	sum_len += clen;
	packet_get_bignum(host_key->rsa->n, &clen);
	sum_len += clen;
@


1.44
log
@get rid of packet_integrity_check, use packet_done() instead.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.43 2001/12/27 18:22:16 markus Exp $");
d112 1
a112 1
		packet_done();
d246 1
a246 1
	packet_done();
d360 1
a360 1
	packet_done();
d467 1
a467 1
		packet_done();
d576 1
a576 1
		packet_done();
d841 1
a841 1
		packet_done();
d967 1
a967 1
	packet_done();
@


1.43
log
@call fatal() for openssl allocation failures
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.42 2001/12/19 07:18:56 deraadt Exp $");
d112 1
a112 2

		packet_integrity_check(plen, clen, type);
d246 1
a246 2

	packet_integrity_check(plen, clen, type);
d360 1
a360 2

	packet_integrity_check(plen, clen, type);
d467 1
a467 1
		packet_integrity_check(plen, 4 + auth.length, type);
d576 1
a576 2

		packet_integrity_check(payload_len, 4 + ap.length, type);
d841 1
a841 1
		packet_integrity_check(payload_len, (4 + clen), type);
d967 1
a971 3
	packet_integrity_check(payload_len,
	    8 + 4 + sum_len + 0 + 4 + 0 + 0 + 4 + 4 + 4,
	    SSH_SMSG_PUBLIC_KEY);
@


1.42
log
@basic KNF done while i was looking for something else
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.41 2001/10/06 11:18:19 markus Exp $");
d79 2
a80 2
	challenge = BN_new();

d244 2
a245 1
	challenge = BN_new();
d359 2
a360 1
	challenge = BN_new();
d917 1
a917 3
	RSA *host_key;
	RSA *public_key;
	Key k;
d937 3
a939 4
	public_key = RSA_new();
	bits = packet_get_int();/* bits */
	public_key->e = BN_new();
	packet_get_bignum(public_key->e, &clen);
d941 1
a941 2
	public_key->n = BN_new();
	packet_get_bignum(public_key->n, &clen);
d944 1
a944 1
	rbits = BN_num_bits(public_key->n);
d951 3
a953 4
	host_key = RSA_new();
	bits = packet_get_int();/* bits */
	host_key->e = BN_new();
	packet_get_bignum(host_key->e, &clen);
d955 1
a955 2
	host_key->n = BN_new();
	packet_get_bignum(host_key->n, &clen);
d958 1
a958 1
	rbits = BN_num_bits(host_key->n);
d973 1
a973 1
	    BN_num_bits(public_key->n), BN_num_bits(host_key->n));
d978 1
a978 3
	k.type = KEY_RSA1;
	k.rsa = host_key;
	if (verify_host_key(host, hostaddr, &k) == -1)
d983 1
a983 1
	compute_session_id(session_id, cookie, host_key->n, public_key->n);
d1005 2
a1006 1
	key = BN_new();
d1020 1
a1020 1
	if (BN_cmp(public_key->n, host_key->n) < 0) {
d1022 3
a1024 3
		if (BN_num_bits(host_key->n) <
		    BN_num_bits(public_key->n) + SSH_KEY_BITS_RESERVED) {
			fatal("respond_to_rsa_challenge: host_key %d < public_key %d + "
d1026 2
a1027 2
			    BN_num_bits(host_key->n),
			    BN_num_bits(public_key->n),
d1030 2
a1031 2
		rsa_public_encrypt(key, key, public_key);
		rsa_public_encrypt(key, key, host_key);
d1034 3
a1036 3
		if (BN_num_bits(public_key->n) <
		    BN_num_bits(host_key->n) + SSH_KEY_BITS_RESERVED) {
			fatal("respond_to_rsa_challenge: public_key %d < host_key %d + "
d1038 2
a1039 2
			    BN_num_bits(public_key->n),
			    BN_num_bits(host_key->n),
d1042 2
a1043 2
		rsa_public_encrypt(key, key, host_key);
		rsa_public_encrypt(key, key, public_key);
d1047 2
a1048 2
	RSA_free(public_key);
	RSA_free(host_key);
@


1.41
log
@unify hostkey check error messages, simplify prompt.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.40 2001/09/27 15:31:17 markus Exp $");
d83 2
a84 2
	     key != NULL;
	     key = ssh_get_next_identity(auth, &comment, 1)) {
d403 1
a403 1
	
d406 1
a406 1
	
d414 1
a414 1
	
d427 1
a427 1
	
d433 1
a433 1
	
d436 1
a436 1
	
d442 1
a442 1
	
d458 1
a458 1
		
d462 1
a462 1
		
d467 1
a467 1
		
d469 1
a469 1
		
d486 1
a486 1
		
d494 1
a494 1
		
d516 1
a516 1
	
d518 1
a518 1
	
d525 1
a525 1
	
d529 1
a529 1
	
d535 1
a535 1
	
d543 1
a543 1
	
d545 1
a545 1
	
d554 1
a554 1
	
d559 1
a559 1
	
d562 1
a562 1
	
d565 6
a570 6
        case SSH_SMSG_FAILURE:
                /* Should really be SSH_SMSG_AUTH_KERBEROS_FAILURE */
                debug("Kerberos v5 authentication failed.");
                ret = 0;
                break;
		
d572 11
a582 11
                /* SSH_SMSG_AUTH_KERBEROS_SUCCESS */
                debug("Kerberos v5 authentication accepted.");
		
                /* Get server's response. */
                ap.data = packet_get_string((unsigned int *) &ap.length);
		
                packet_integrity_check(payload_len, 4 + ap.length, type);
                /* XXX je to dobre? */
		
                problem = krb5_rd_rep(*context, *auth_context, &ap, &reply);
                if (problem) {
d587 1
a587 1
		
d593 1
a593 1
		
d595 1
a595 1
	
d603 1
a603 1
	
d617 1
a617 1
	
d620 1
a620 1
	
d622 1
a622 1
	
d626 1
a626 1
	
d630 1
a630 1
	
d634 1
a634 1
	
d640 1
a640 1
	
d642 1
a642 1
	
d647 1
a647 1
	
d649 1
a649 1
	
d654 1
a654 1
	
d659 1
a659 1
	
d661 1
a661 1
	
d664 1
a664 1
		
d670 1
a670 1
	
d672 1
a672 1
	
d696 1
a696 1
	
d700 1
a700 1
	
d702 1
a702 1
	
d706 1
a706 1
	
d710 1
a710 1
	
d716 1
a716 1
	
d721 1
a721 1
	
d723 1
a723 1
	
d730 1
a730 1
	
d733 1
a733 1
	
d748 1
a748 1
	
d758 1
a758 1
		
d766 1
a766 1
		
d776 1
a776 1
		
d788 1
a788 1
		
d801 1
a801 1
		
d845 1
a845 1
		     strchr(challenge, '\n') ? "" : "\nResponse: ");
d977 1
a977 1
	      BN_num_bits(public_key->n), BN_num_bits(host_key->n));
d980 2
a981 2
			       8 + 4 + sum_len + 0 + 4 + 0 + 0 + 4 + 4 + 4,
			       SSH_SMSG_PUBLIC_KEY);
d1030 4
a1033 4
			      "SSH_KEY_BITS_RESERVED %d",
			      BN_num_bits(host_key->n),
			      BN_num_bits(public_key->n),
			      SSH_KEY_BITS_RESERVED);
d1042 4
a1045 4
			      "SSH_KEY_BITS_RESERVED %d",
			      BN_num_bits(public_key->n),
			      BN_num_bits(host_key->n),
			      SSH_KEY_BITS_RESERVED);
d1067 1
a1067 1
		      cipher_name(options.cipher));
d1120 1
a1120 1
	
d1142 1
a1142 1
	
d1145 1
a1145 1
            options.kerberos_authentication) {
d1147 1
a1147 1
		
d1157 1
a1157 1
	
d1162 1
a1162 1
		
d1172 1
a1172 1
	
d1257 1
a1257 1
	
@


1.41.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.48 2002/02/11 16:15:46 markus Exp $");
d19 1
a19 1
#include <openssl/md5.h>
d70 1
d79 2
a80 2
	if ((challenge = BN_new()) == NULL)
		fatal("try_agent_authentication: BN_new failed");
d83 2
a84 2
	    key != NULL;
	    key = ssh_get_next_identity(auth, &comment, 1)) {
d97 1
a97 1
		type = packet_read();
d111 3
a113 2
		packet_get_bignum(challenge);
		packet_check_eom();
d138 1
a138 1
		type = packet_read();
d213 1
a213 1
	int i, type, quit;
d228 1
a228 1
	type = packet_read();
d244 4
a247 4
	if ((challenge = BN_new()) == NULL)
		fatal("try_rsa_authentication: BN_new failed");
	packet_get_bignum(challenge);
	packet_check_eom();
d295 1
a295 1
		packet_read_expect(SSH_SMSG_FAILURE);
d311 1
a311 1
	type = packet_read();
d331 1
d345 1
a345 1
	type = packet_read();
d358 4
a361 4
	if ((challenge = BN_new()) == NULL)
		fatal("try_rhosts_rsa_authentication: BN_new failed");
	packet_get_bignum(challenge);
	packet_check_eom();
d372 1
a372 1
	type = packet_read();
d392 1
a392 1
	int r, type;
d403 1
a403 1

d406 1
a406 1

d414 1
a414 1

d427 1
a427 1

d433 1
a433 1

d436 1
a436 1

d442 1
a442 1

d451 1
a451 1
	type = packet_read();
d458 1
a458 1

d462 1
a462 1

d467 3
a469 3

		packet_check_eom();

d486 1
a486 1

d494 1
a494 1

d513 1
a513 1
	int type;
d516 1
a516 1

d518 1
a518 1

d525 1
a525 1

d529 1
a529 1

d535 1
a535 1

d543 1
a543 1

d545 1
a545 1

d554 1
a554 1

d559 1
a559 1

d562 2
a563 2

	type = packet_read();
d565 6
a570 6
	case SSH_SMSG_FAILURE:
		/* Should really be SSH_SMSG_AUTH_KERBEROS_FAILURE */
		debug("Kerberos v5 authentication failed.");
		ret = 0;
		break;

d572 11
a582 10
		/* SSH_SMSG_AUTH_KERBEROS_SUCCESS */
		debug("Kerberos v5 authentication accepted.");

		/* Get server's response. */
		ap.data = packet_get_string((unsigned int *) &ap.length);
		packet_check_eom();
		/* XXX je to dobre? */

		problem = krb5_rd_rep(*context, *auth_context, &ap, &reply);
		if (problem) {
d587 1
a587 1

d593 1
a593 1

d595 1
a595 1

d603 1
a603 1

d610 1
a610 1
	int fd, type;
d617 1
a617 1

d620 1
a620 1

d622 1
a622 1

d626 1
a626 1

d630 1
a630 1

d634 1
a634 1

d640 1
a640 1

d642 1
a642 1

d647 1
a647 1

d649 1
a649 1

d654 1
a654 1

d659 3
a661 3

	type = packet_read();

d664 1
a664 1

d670 1
a670 1

d672 1
a672 1

d695 2
a696 2
	int problem, type;

d700 1
a700 1

d702 1
a702 1

d706 1
a706 1

d710 1
a710 1

d716 1
a716 1

d721 3
a723 3

	type = packet_read();

d730 1
a730 1

d733 1
a733 1

d748 1
a748 1

d758 1
a758 1

d766 1
a766 1

d776 1
a776 1

d788 1
a788 1

d800 2
a801 2
		type = packet_read();

d819 1
d832 1
a832 1
		type = packet_read();
d843 1
a843 1
		packet_check_eom();
d845 1
a845 1
		    strchr(challenge, '\n') ? "" : "\nResponse: ");
d863 1
a863 1
		type = packet_read();
d880 1
a880 1
	int type, i;
d897 1
a897 1
		type = packet_read();
d915 3
a917 1
	Key *host_key, *server_key;
d924 1
d930 1
a930 1
	packet_read_expect(SSH_SMSG_PUBLIC_KEY);
d937 8
a944 4
	server_key = key_new(KEY_RSA1);
	bits = packet_get_int();
	packet_get_bignum(server_key->rsa->e);
	packet_get_bignum(server_key->rsa->n);
d946 1
a946 1
	rbits = BN_num_bits(server_key->rsa->n);
d953 8
a960 4
	host_key = key_new(KEY_RSA1);
	bits = packet_get_int();
	packet_get_bignum(host_key->rsa->e);
	packet_get_bignum(host_key->rsa->n);
d962 1
a962 1
	rbits = BN_num_bits(host_key->rsa->n);
a974 1
	packet_check_eom();
d977 1
a977 1
	    BN_num_bits(server_key->rsa->n), BN_num_bits(host_key->rsa->n));
d979 6
a984 1
	if (verify_host_key(host, hostaddr, host_key) == -1)
d989 1
a989 1
	compute_session_id(session_id, cookie, host_key->rsa->n, server_key->rsa->n);
d1011 1
a1011 2
	if ((key = BN_new()) == NULL)
		fatal("respond_to_rsa_challenge: BN_new failed");
d1025 1
a1025 1
	if (BN_cmp(server_key->rsa->n, host_key->rsa->n) < 0) {
d1027 7
a1033 7
		if (BN_num_bits(host_key->rsa->n) <
		    BN_num_bits(server_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("respond_to_rsa_challenge: host_key %d < server_key %d + "
			    "SSH_KEY_BITS_RESERVED %d",
			    BN_num_bits(host_key->rsa->n),
			    BN_num_bits(server_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
d1035 2
a1036 2
		rsa_public_encrypt(key, key, server_key->rsa);
		rsa_public_encrypt(key, key, host_key->rsa);
d1039 7
a1045 7
		if (BN_num_bits(server_key->rsa->n) <
		    BN_num_bits(host_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("respond_to_rsa_challenge: server_key %d < host_key %d + "
			    "SSH_KEY_BITS_RESERVED %d",
			    BN_num_bits(server_key->rsa->n),
			    BN_num_bits(host_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
d1047 2
a1048 2
		rsa_public_encrypt(key, key, host_key->rsa);
		rsa_public_encrypt(key, key, server_key->rsa);
d1052 2
a1053 2
	key_free(server_key);
	key_free(host_key);
d1067 1
a1067 1
		    cipher_name(options.cipher));
d1102 1
a1102 1
	packet_read_expect(SSH_SMSG_SUCCESS);
d1119 2
a1120 1

d1135 1
a1135 1
	type = packet_read();
d1142 1
a1142 1

d1145 1
a1145 1
	    options.kerberos_authentication) {
d1147 1
a1147 1

d1149 1
a1149 1
			type = packet_read();
d1157 1
a1157 1

d1162 1
a1162 1

d1164 1
a1164 1
			type = packet_read();
d1172 1
a1172 1

d1186 1
a1186 1
		type = packet_read();
d1257 1
a1257 1

@


1.41.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.50 2002/04/21 16:25:06 stevesk Exp $");
a461 2
		if (auth.length >= MAX_KTXT_LEN)
			fatal("Kerberos v4: Malformed response from server");
d846 1
a846 1
			    "Response will be transmitted in clear text.");
@


1.41.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.41.2.2 2002/05/17 00:03:24 miod Exp $");
d1095 1
a1095 1
    Sensitive *sensitive)
d1181 3
a1183 5
		for (i = 0; i < sensitive->nkeys; i++) {
			if (sensitive->keys[i] != NULL &&
			    sensitive->keys[i]->type == KEY_RSA1 &&
			    try_rhosts_rsa_authentication(local_user,
			    sensitive->keys[i]))
@


1.41.2.4
log
@Update to OpenSSH 3.5
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.52 2002/08/08 13:50:23 aaron Exp $");
d254 1
a254 1
	if (public->flags & KEY_FLAG_EXT)
@


1.40
log
@typos; from solar
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.39 2001/07/05 20:32:47 stevesk Exp $");
d985 1
a985 1
		fatal("host_key verification failed");
@


1.39
log
@statement after label; ok dugsong@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.38 2001/06/26 20:14:11 markus Exp $");
d823 3
a825 3
	
	debug("Doing challenge reponse authentication.");
	
@


1.38
log
@add smartcard support to the client, too (now you can use both
the agent and the client).
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.37 2001/06/26 16:15:24 dugsong Exp $");
d1274 2
@


1.37
log
@Kerberos v5 support for SSH1, mostly from Assar Westerlund <assar@@freebsd.org> and Bjorn Gronvall <bg@@sics.se>. markus@@ ok
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.36 2001/06/23 22:37:46 markus Exp $");
d208 1
a208 1
try_rsa_authentication(const char *authfile)
d212 1
a212 1
	char buf[300], *passphrase, *comment;
d215 4
a218 7
	/* Try to load identification for the authentication key. */
	/* XXKEYLOAD */
	public = key_load_public_type(KEY_RSA1, authfile, &comment);
	if (public == NULL) {
		/* Could not load it.  Fail. */
		return 0;
	}
a226 3
	/* We no longer need the public key. */
	key_free(public);

d252 2
a253 1
	 * Load the private key.  Try first with empty passphrase; if it
d256 4
a259 1
	private = key_load_private_type(KEY_RSA1, authfile, "", NULL);
d303 3
a305 2
	/* Destroy the private key. */
	key_free(private);
d1220 1
a1220 1
			    try_rsa_authentication(options.identity_files[i]))
@


1.36
log
@consistent with ssh2: skip key if empty passphrase is entered,
retry num_of_passwd_prompt times if passphrase is wrong. ok fgsch@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.35 2001/06/23 15:12:21 itojun Exp $");
d24 3
d49 1
d386 1
a386 1
try_kerberos_authentication(void)
d404 5
a408 4

	strncpy(inst, (char *) krb_get_phost(get_canonical_hostname(1)), INST_SZ);

	realm = (char *) krb_realmofhost(get_canonical_hostname(1));
d410 1
a410 1
		debug("Kerberos V4: no realm for %s", get_canonical_hostname(1));
d414 2
a415 2
	checksum = (u_long) getpid();

d418 1
a418 1
		debug("Kerberos V4 krb_mk_req failed: %s", krb_err_txt[r]);
d428 1
a428 1

d434 1
a434 1

d437 1
a437 1

d441 1
a441 1
			(struct sockaddr *) & local, &slen) < 0)
d443 1
a443 1

d447 1
a447 1
			(struct sockaddr *) & foreign, &slen) < 0) {
d456 1
a456 1
		debug("Kerberos V4 authentication failed.");
d459 1
a459 1

d462 2
a463 2
		debug("Kerberos V4 authentication accepted.");

d468 1
a468 1

d470 1
a470 1

d477 1
a477 1
				&foreign, &local, &msg_data);
d479 3
a481 2
			debug("Kerberos V4 krb_rd_priv failed: %s", krb_err_txt[r]);
			packet_disconnect("Kerberos V4 challenge failed!");
d484 2
a485 1
		(void) memcpy((char *) &cksum, (char *) msg_data.app_data, sizeof(cksum));
d487 1
a487 1

d490 1
a490 1
			debug("Kerberos V4 challenge successful.");
d493 1
a493 1
			packet_disconnect("Kerberos V4 challenge failed!");
d495 1
a495 1

d497 1
a497 1
		packet_disconnect("Protocol error on Kerberos V4 response: %d", type);
d504 185
d690 2
a691 2
static int
send_kerberos_tgt(void)
a693 3
	char pname[ANAME_SZ], pinst[INST_SZ], prealm[REALM_SZ];
	int r, type, plen;
	char buffer[8192];
d695 3
a697 1

d700 2
a701 2
		return 0;

d703 9
a711 9

	if ((r = krb_get_tf_fullname(TKT_FILE, pname, pinst, prealm)) != KSUCCESS) {
		debug("Kerberos V4 tf_fullname failed: %s", krb_err_txt[r]);
		return 0;
	}
	if ((r = krb_get_cred("krbtgt", prealm, prealm, creds)) != GC_OK) {
		debug("Kerberos V4 get_cred failed: %s", krb_err_txt[r]);
		return 0;
	}
d713 2
a714 2
		debug("Kerberos V4 ticket expired: %s", TKT_FILE);
		return 0;
d716 2
a717 3
	creds_to_radix(creds, (u_char *)buffer, sizeof buffer);
	xfree(creds);

d722 16
a737 9

	type = packet_read(&plen);

	if (type == SSH_SMSG_FAILURE)
		debug("Kerberos TGT for realm %s rejected.", prealm);
	else if (type != SSH_SMSG_SUCCESS)
		packet_disconnect("Protocol error on Kerberos TGT response: %d", type);

	return 1;
d746 1
a746 1
	int i, type, len, plen;
d749 1
a749 1

d759 1
a759 1

d767 1
a767 1

d777 1
a777 1

d779 1
a779 1
		strlcpy(creds.service, "afs", sizeof creds.service);
d784 2
a785 1
		creds.lifetime = krb_time_to_life(creds.issue_date, ct.EndTimestamp);
d789 1
a789 1

d791 2
a792 1
		if (creds_to_radix(&creds, (u_char *) buffer, sizeof buffer) <= 0)
d801 2
a802 2
		type = packet_read(&plen);

d824 1
a824 1

d826 1
a826 1

d1115 4
d1121 1
a1121 1

d1140 1
a1140 1
		return;
d1142 14
a1155 10
		packet_disconnect("Protocol error: got %d in response to SSH_CMSG_USER",
				  type);

#ifdef AFS
	/* Try Kerberos tgt passing if the server supports it. */
	if ((supported_authentications & (1 << SSH_PASS_KERBEROS_TGT)) &&
	    options.kerberos_tgt_passing) {
		if (options.cipher == SSH_CIPHER_NONE)
			log("WARNING: Encryption is disabled! Ticket will be transmitted in the clear!");
		(void) send_kerberos_tgt();
d1157 2
a1158 9
	/* Try AFS token passing if the server supports it. */
	if ((supported_authentications & (1 << SSH_PASS_AFS_TOKEN)) &&
	    options.afs_token_passing && k_hasafs()) {
		if (options.cipher == SSH_CIPHER_NONE)
			log("WARNING: Encryption is disabled! Token will be transmitted in the clear!");
		send_afs_tokens();
	}
#endif /* AFS */

d1162 3
a1164 3
		debug("Trying Kerberos authentication.");
		if (try_kerberos_authentication()) {
			/* The server should respond with success or failure. */
d1167 1
a1167 1
				return;
d1169 1
a1169 1
				packet_disconnect("Protocol error: got %d in response to Kerberos auth", type);
d1173 1
a1173 1

d1189 1
a1189 1
			return;
d1203 1
a1203 1
				return;
d1215 1
a1215 1
			return;
d1222 1
a1222 1
				return;
d1228 1
a1228 1
			return;
d1238 1
a1238 1
			return;
d1243 32
@


1.35
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.34 2001/06/23 02:34:32 markus Exp $");
d207 3
a209 5
	Key *public;
	Key *private;
	char *passphrase, *comment;
	int type, i;
	int plen, clen;
d258 4
a261 5
	if (private == NULL) {
		char buf[300];
		snprintf(buf, sizeof buf, "Enter passphrase for RSA key '%.100s': ",
		    comment);
		if (!options.batch_mode)
d263 8
a270 9
		else {
			debug("Will not query passphrase for %.100s in batch mode.",
			      comment);
			passphrase = xstrdup("");
		}

		/* Load the authentication file using the pasphrase. */
		private = key_load_private_type(KEY_RSA1, authfile, passphrase, NULL);
		if (private == NULL) {
d273 3
a275 14
			error("Bad passphrase.");

			/* Send a dummy response packet to avoid protocol error. */
			packet_start(SSH_CMSG_AUTH_RSA_RESPONSE);
			for (i = 0; i < 16; i++)
				packet_put_char(0);
			packet_send();
			packet_write_wait();

			/* Expect the server to reject it... */
			packet_read_expect(&plen, SSH_SMSG_FAILURE);
			xfree(comment);
			BN_clear_free(challenge);
			return 0;
a276 3
		/* Destroy the passphrase. */
		memset(passphrase, 0, strlen(passphrase));
		xfree(passphrase);
d280 17
@


1.34
log
@get rid of known_hosts2, use it for hostkey lookup, but do not modify.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.33 2001/06/07 20:23:05 markus Exp $");
d58 1
a58 1
int
d158 1
a158 1
void
d203 1
a203 1
int
d324 1
a324 1
int
d382 1
a382 1
int
d499 1
a499 1
int
d544 1
a544 1
void
d618 1
a618 1
int
d680 1
a680 1
int
@


1.33
log
@use xxx_put_cstring()
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.32 2001/05/18 14:13:29 markus Exp $");
d787 2
a788 2
	check_host_key(host, hostaddr, &k,
	    options.user_hostfile, options.system_hostfile);
@


1.32
log
@improved kbd-interactive support. work by per@@appgate.com and me
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.31 2001/04/17 08:14:01 markus Exp $");
d335 1
a335 1
	packet_put_string(local_user, strlen(local_user));
d530 1
a530 1
	packet_put_string(buffer, strlen(buffer));
d597 1
a597 1
		packet_put_string(buffer, strlen(buffer));
d925 1
a925 1
	packet_put_string(server_user, strlen(server_user));
d983 1
a983 1
		packet_put_string(local_user, strlen(local_user));
@


1.31
log
@check for key!=NULL, thanks to costa
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.30 2001/04/12 19:15:25 markus Exp $");
d619 1
a619 1
try_challenge_reponse_authentication(void)
d1027 2
a1028 2
	    options.challenge_reponse_authentication && !options.batch_mode) {
		if (try_challenge_reponse_authentication())
@


1.31.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.39 2001/07/05 20:32:47 stevesk Exp $");
a23 3
#ifdef KRB5
#include <krb5.h>
#endif
a45 1
#include "auth.h"
d58 1
a58 1
static int
d158 1
a158 1
static void
d203 2
a204 2
static int
try_rsa_authentication(int idx)
d207 5
a211 7
	Key *public, *private;
	char buf[300], *passphrase, *comment, *authfile;
	int i, type, quit, plen, clen;

	public = options.identity_keys[idx];
	authfile = options.identity_files[idx];
	comment = xstrdup(authfile);
d213 7
d228 3
d256 1
a256 2
	 * If the key is not stored in external hardware, we have to
	 * load the private key.  Try first with empty passphrase; if it
d259 6
a264 8
	if (public->flags && KEY_FLAG_EXT)
		private = public;
	else
		private = key_load_private_type(KEY_RSA1, authfile, "", NULL);
	if (private == NULL && !options.batch_mode) {
		snprintf(buf, sizeof(buf),
		    "Enter passphrase for RSA key '%.100s': ", comment);
		for (i = 0; i < options.number_of_password_prompts; i++) {
d266 9
a274 8
			if (strcmp(passphrase, "") != 0) {
				private = key_load_private_type(KEY_RSA1,
				    authfile, passphrase, NULL);
				quit = 0;
			} else {
				debug2("no passphrase given, try next key");
				quit = 1;
			}
d277 14
a290 3
			if (private != NULL || quit)
				break;
			debug2("bad passphrase given, try again...");
d292 3
a298 17
	if (private == NULL) {
		if (!options.batch_mode)
			error("Bad passphrase.");

		/* Send a dummy response packet to avoid protocol error. */
		packet_start(SSH_CMSG_AUTH_RSA_RESPONSE);
		for (i = 0; i < 16; i++)
			packet_put_char(0);
		packet_send();
		packet_write_wait();

		/* Expect the server to reject it... */
		packet_read_expect(&plen, SSH_SMSG_FAILURE);
		BN_clear_free(challenge);
		return 0;
	}

d302 2
a303 3
	/* Destroy the private key unless it in external hardware. */
	if (!(private->flags & KEY_FLAG_EXT))
		key_free(private);
d324 1
a324 1
static int
d335 1
a335 1
	packet_put_cstring(local_user);
d382 2
a383 2
static int
try_krb4_authentication(void)
d401 4
a404 5
	
	strlcpy(inst, (char *)krb_get_phost(get_canonical_hostname(1)),
	    INST_SZ);
	
	realm = (char *)krb_realmofhost(get_canonical_hostname(1));
d406 1
a406 1
		debug("Kerberos v4: no realm for %s", get_canonical_hostname(1));
d410 2
a411 2
	checksum = (u_long)getpid();
	
d414 1
a414 1
		debug("Kerberos v4 krb_mk_req failed: %s", krb_err_txt[r]);
d424 1
a424 1
	
d430 1
a430 1
	
d433 1
a433 1
	
d437 1
a437 1
	    (struct sockaddr *)&local, &slen) < 0)
d439 1
a439 1
	
d443 1
a443 1
	    (struct sockaddr *)&foreign, &slen) < 0) {
d452 1
a452 1
		debug("Kerberos v4 authentication failed.");
d455 1
a455 1
		
d458 2
a459 2
		debug("Kerberos v4 authentication accepted.");
		
d464 1
a464 1
		
d466 1
a466 1
		
d473 1
a473 1
		    &foreign, &local, &msg_data);
d475 2
a476 3
			debug("Kerberos v4 krb_rd_priv failed: %s",
			    krb_err_txt[r]);
			packet_disconnect("Kerberos v4 challenge failed!");
d479 1
a479 2
		memcpy((char *)&cksum, (char *)msg_data.app_data,
		    sizeof(cksum));
d481 1
a481 1
		
d484 1
a484 1
			debug("Kerberos v4 challenge successful.");
d487 1
a487 1
			packet_disconnect("Kerberos v4 challenge failed!");
d489 1
a489 1
		
d491 1
a491 1
		packet_disconnect("Protocol error on Kerberos v4 response: %d", type);
a497 185
#ifdef KRB5
static int
try_krb5_authentication(krb5_context *context, krb5_auth_context *auth_context)
{
	krb5_error_code problem;
	const char *tkfile;
	struct stat buf;
	krb5_ccache ccache = NULL;
	const char *remotehost;
	krb5_data ap;
	int type, payload_len;
	krb5_ap_rep_enc_part *reply = NULL;
	int ret;
	
	memset(&ap, 0, sizeof(ap));
	
	problem = krb5_init_context(context);
	if (problem) {
		debug("Kerberos v5: krb5_init_context failed");
		ret = 0;
		goto out;
	}
	
	tkfile = krb5_cc_default_name(*context);
	if (strncmp(tkfile, "FILE:", 5) == 0)
		tkfile += 5;
	
	if (stat(tkfile, &buf) == 0 && getuid() != buf.st_uid) {
		debug("Kerberos v5: could not get default ccache (permission denied).");
		ret = 0;
		goto out;
	}
	
	problem = krb5_cc_default(*context, &ccache);
	if (problem) {
		debug("Kerberos v5: krb5_cc_default failed: %s",
		    krb5_get_err_text(*context, problem));
		ret = 0;
		goto out;
	}
	
	remotehost = get_canonical_hostname(1);
	
	problem = krb5_mk_req(*context, auth_context, AP_OPTS_MUTUAL_REQUIRED,
	    "host", remotehost, NULL, ccache, &ap);
	if (problem) {
		debug("Kerberos v5: krb5_mk_req failed: %s",
		    krb5_get_err_text(*context, problem));
		ret = 0;
		goto out;
	}
	
	packet_start(SSH_CMSG_AUTH_KERBEROS);
	packet_put_string((char *) ap.data, ap.length);
	packet_send();
	packet_write_wait();
	
	xfree(ap.data);
	ap.length = 0;
	
	type = packet_read(&payload_len);
	switch (type) {
        case SSH_SMSG_FAILURE:
                /* Should really be SSH_SMSG_AUTH_KERBEROS_FAILURE */
                debug("Kerberos v5 authentication failed.");
                ret = 0;
                break;
		
	case SSH_SMSG_AUTH_KERBEROS_RESPONSE:
                /* SSH_SMSG_AUTH_KERBEROS_SUCCESS */
                debug("Kerberos v5 authentication accepted.");
		
                /* Get server's response. */
                ap.data = packet_get_string((unsigned int *) &ap.length);
		
                packet_integrity_check(payload_len, 4 + ap.length, type);
                /* XXX je to dobre? */
		
                problem = krb5_rd_rep(*context, *auth_context, &ap, &reply);
                if (problem) {
			ret = 0;
		}
		ret = 1;
		break;
		
	default:
		packet_disconnect("Protocol error on Kerberos v5 response: %d",
		    type);
		ret = 0;
		break;
		
	}
	
 out:
	if (ccache != NULL)
		krb5_cc_close(*context, ccache);
	if (reply != NULL)
		krb5_free_ap_rep_enc_part(*context, reply);
	if (ap.length > 0)
		krb5_data_free(&ap);
	
	return (ret);
}

static void
send_krb5_tgt(krb5_context context, krb5_auth_context auth_context)
{
	int fd, type, payload_len;
	krb5_error_code problem;
	krb5_data outbuf;
	krb5_ccache ccache = NULL;
	krb5_creds creds;
	krb5_kdc_flags flags;
	const char *remotehost;
	
	memset(&creds, 0, sizeof(creds));
	memset(&outbuf, 0, sizeof(outbuf));
	
	fd = packet_get_connection_in();
	
	problem = krb5_auth_con_setaddrs_from_fd(context, auth_context, &fd);
	if (problem)
		goto out;
	
	problem = krb5_cc_default(context, &ccache);
	if (problem)
		goto out;
	
	problem = krb5_cc_get_principal(context, ccache, &creds.client);
	if (problem)
		goto out;
	
	problem = krb5_build_principal(context, &creds.server,
	    strlen(creds.client->realm), creds.client->realm,
	    "krbtgt", creds.client->realm, NULL);
	if (problem)
		goto out;
	
	creds.times.endtime = 0;
	
	flags.i = 0;
	flags.b.forwarded = 1;
	flags.b.forwardable = krb5_config_get_bool(context,  NULL,
	    "libdefaults", "forwardable", NULL);
	
	remotehost = get_canonical_hostname(1);
	
	problem = krb5_get_forwarded_creds(context, auth_context,
	    ccache, flags.i, remotehost, &creds, &outbuf);
	if (problem)
		goto out;
	
	packet_start(SSH_CMSG_HAVE_KERBEROS_TGT);
	packet_put_string((char *)outbuf.data, outbuf.length);
	packet_send();
	packet_write_wait();
	
	type = packet_read(&payload_len);
	
	if (type == SSH_SMSG_SUCCESS) {
		char *pname;
		
		krb5_unparse_name(context, creds.client, &pname);
		debug("Kerberos v5 TGT forwarded (%s).", pname);
		xfree(pname);
	} else
		debug("Kerberos v5 TGT forwarding failed.");
	
	return;
	
 out:
	if (problem)
		debug("Kerberos v5 TGT forwarding failed: %s",
		    krb5_get_err_text(context, problem));
	if (creds.client)
		krb5_free_principal(context, creds.client);
	if (creds.server)
		krb5_free_principal(context, creds.server);
	if (ccache)
		krb5_cc_close(context, ccache);
	if (outbuf.data)
		xfree(outbuf.data);
}
#endif /* KRB5 */

d499 2
a500 2
static void
send_krb4_tgt(void)
d503 3
d507 1
a507 3
	char buffer[4096], pname[ANAME_SZ], pinst[INST_SZ], prealm[REALM_SZ];
	int problem, type, len;
	
d510 2
a511 2
		return;
	
d513 9
a521 9
	
	problem = krb_get_tf_fullname(TKT_FILE, pname, pinst, prealm);
	if (problem)
		goto out;
	
	problem = krb_get_cred("krbtgt", prealm, prealm, creds);
	if (problem)
		goto out;
	
d523 2
a524 2
		problem = RD_AP_EXP;
		goto out;
d526 3
a528 2
	creds_to_radix(creds, (u_char *)buffer, sizeof(buffer));
	
d530 1
a530 1
	packet_put_cstring(buffer);
d533 9
a541 16
	
	type = packet_read(&len);
	
	if (type == SSH_SMSG_SUCCESS)
		debug("Kerberos v4 TGT forwarded (%s%s%s@@%s).",
		    creds->pname, creds->pinst[0] ? "." : "",
		    creds->pinst, creds->realm);
	else
		debug("Kerberos v4 TGT rejected.");
	
	xfree(creds);
	return;
	
 out:
	debug("Kerberos v4 TGT passing failed: %s", krb_err_txt[problem]);
	xfree(creds);
d544 1
a544 1
static void
d550 1
a550 1
	int i, type, len;
d553 1
a553 1
	
d563 1
a563 1
		
d571 1
a571 1
		
d581 1
a581 1
		
d583 1
a583 1
		strlcpy(creds.service, "afs", sizeof(creds.service));
d588 1
a588 2
		creds.lifetime = krb_time_to_life(creds.issue_date,
		    ct.EndTimestamp);
d592 1
a592 1
		
d594 1
a594 2
		if (creds_to_radix(&creds, (u_char *)buffer,
		    sizeof(buffer)) <= 0)
d597 1
a597 1
		packet_put_cstring(buffer);
d603 2
a604 2
		type = packet_read(&len);
		
d618 2
a619 2
static int
try_challenge_response_authentication(void)
d626 1
a626 1
	
d628 1
a628 1
	
d680 1
a680 1
static int
d787 2
a788 2
	if (verify_host_key(host, hostaddr, &k) == -1)
		fatal("host_key verification failed");
a916 4
#ifdef KRB5
	krb5_context context = NULL;
	krb5_auth_context auth_context = NULL;
#endif
d919 1
a919 1
	
d925 1
a925 1
	packet_put_cstring(server_user);
d938 1
a938 1
		goto success;
d940 17
a956 14
		packet_disconnect("Protocol error: got %d in response to SSH_CMSG_USER", type);
	
#ifdef KRB5
	if ((supported_authentications & (1 << SSH_AUTH_KERBEROS)) &&
            options.kerberos_authentication) {
		debug("Trying Kerberos v5 authentication.");
		
		if (try_krb5_authentication(&context, &auth_context)) {
			type = packet_read(&payload_len);
			if (type == SSH_SMSG_SUCCESS)
				goto success;
			if (type != SSH_SMSG_FAILURE)
				packet_disconnect("Protocol error: got %d in response to Kerberos v5 auth", type);
		}
d958 2
a959 2
#endif /* KRB5 */
	
d963 3
a965 3
		debug("Trying Kerberos v4 authentication.");
		
		if (try_krb4_authentication()) {
d968 1
a968 1
				goto success;
d970 1
a970 1
				packet_disconnect("Protocol error: got %d in response to Kerberos v4 auth", type);
d974 1
a974 1
	
d983 1
a983 1
		packet_put_cstring(local_user);
d990 1
a990 1
			goto success;
d1004 1
a1004 1
				goto success;
d1016 1
a1016 1
			goto success;
d1022 2
a1023 2
			    try_rsa_authentication(i))
				goto success;
d1027 3
a1029 3
	    options.challenge_response_authentication && !options.batch_mode) {
		if (try_challenge_response_authentication())
			goto success;
d1039 1
a1039 1
			goto success;
a1043 34

 success:
#ifdef KRB5
	/* Try Kerberos v5 TGT passing. */
	if ((supported_authentications & (1 << SSH_PASS_KERBEROS_TGT)) &&
	    options.kerberos_tgt_passing && context && auth_context) {
		if (options.cipher == SSH_CIPHER_NONE)
			log("WARNING: Encryption is disabled! Ticket will be transmitted in the clear!");
		send_krb5_tgt(context, auth_context);
	}
	if (auth_context)
		krb5_auth_con_free(context, auth_context);
	if (context)
		krb5_free_context(context);
#endif
	
#ifdef AFS
	/* Try Kerberos v4 TGT passing if the server supports it. */
	if ((supported_authentications & (1 << SSH_PASS_KERBEROS_TGT)) &&
	    options.kerberos_tgt_passing) {
		if (options.cipher == SSH_CIPHER_NONE)
			log("WARNING: Encryption is disabled! Ticket will be transmitted in the clear!");
		send_krb4_tgt();
	}
	/* Try AFS token passing if the server supports it. */
	if ((supported_authentications & (1 << SSH_PASS_AFS_TOKEN)) &&
	    options.afs_token_passing && k_hasafs()) {
		if (options.cipher == SSH_CIPHER_NONE)
			log("WARNING: Encryption is disabled! Token will be transmitted in the clear!");
		send_afs_tokens();
	}
#endif /* AFS */

	return;	/* need statement after label */
@


1.31.2.2
log
@Merge OpenSSH 3.0
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.31.2.1 2001/09/27 19:03:55 jason Exp $");
d823 3
a825 3

	debug("Doing challenge response authentication.");

d985 1
a985 1
		fatal("Host key verification failed.");
@


1.31.2.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.48 2002/02/11 16:15:46 markus Exp $");
d19 1
a19 1
#include <openssl/md5.h>
d70 1
d79 2
a80 2
	if ((challenge = BN_new()) == NULL)
		fatal("try_agent_authentication: BN_new failed");
d83 2
a84 2
	    key != NULL;
	    key = ssh_get_next_identity(auth, &comment, 1)) {
d97 1
a97 1
		type = packet_read();
d111 3
a113 2
		packet_get_bignum(challenge);
		packet_check_eom();
d138 1
a138 1
		type = packet_read();
d213 1
a213 1
	int i, type, quit;
d228 1
a228 1
	type = packet_read();
d244 4
a247 4
	if ((challenge = BN_new()) == NULL)
		fatal("try_rsa_authentication: BN_new failed");
	packet_get_bignum(challenge);
	packet_check_eom();
d295 1
a295 1
		packet_read_expect(SSH_SMSG_FAILURE);
d311 1
a311 1
	type = packet_read();
d331 1
d345 1
a345 1
	type = packet_read();
d358 4
a361 4
	if ((challenge = BN_new()) == NULL)
		fatal("try_rhosts_rsa_authentication: BN_new failed");
	packet_get_bignum(challenge);
	packet_check_eom();
d372 1
a372 1
	type = packet_read();
d392 1
a392 1
	int r, type;
d403 1
a403 1

d406 1
a406 1

d414 1
a414 1

d427 1
a427 1

d433 1
a433 1

d436 1
a436 1

d442 1
a442 1

d451 1
a451 1
	type = packet_read();
d458 1
a458 1

d462 1
a462 1

d467 3
a469 3

		packet_check_eom();

d486 1
a486 1

d494 1
a494 1

d513 1
a513 1
	int type;
d516 1
a516 1

d518 1
a518 1

d525 1
a525 1

d529 1
a529 1

d535 1
a535 1

d543 1
a543 1

d545 1
a545 1

d554 1
a554 1

d559 1
a559 1

d562 2
a563 2

	type = packet_read();
d565 6
a570 6
	case SSH_SMSG_FAILURE:
		/* Should really be SSH_SMSG_AUTH_KERBEROS_FAILURE */
		debug("Kerberos v5 authentication failed.");
		ret = 0;
		break;

d572 11
a582 10
		/* SSH_SMSG_AUTH_KERBEROS_SUCCESS */
		debug("Kerberos v5 authentication accepted.");

		/* Get server's response. */
		ap.data = packet_get_string((unsigned int *) &ap.length);
		packet_check_eom();
		/* XXX je to dobre? */

		problem = krb5_rd_rep(*context, *auth_context, &ap, &reply);
		if (problem) {
d587 1
a587 1

d593 1
a593 1

d595 1
a595 1

d603 1
a603 1

d610 1
a610 1
	int fd, type;
d617 1
a617 1

d620 1
a620 1

d622 1
a622 1

d626 1
a626 1

d630 1
a630 1

d634 1
a634 1

d640 1
a640 1

d642 1
a642 1

d647 1
a647 1

d649 1
a649 1

d654 1
a654 1

d659 3
a661 3

	type = packet_read();

d664 1
a664 1

d670 1
a670 1

d672 1
a672 1

d695 2
a696 2
	int problem, type;

d700 1
a700 1

d702 1
a702 1

d706 1
a706 1

d710 1
a710 1

d716 1
a716 1

d721 3
a723 3

	type = packet_read();

d730 1
a730 1

d733 1
a733 1

d748 1
a748 1

d758 1
a758 1

d766 1
a766 1

d776 1
a776 1

d788 1
a788 1

d800 2
a801 2
		type = packet_read();

d819 1
d832 1
a832 1
		type = packet_read();
d843 1
a843 1
		packet_check_eom();
d845 1
a845 1
		    strchr(challenge, '\n') ? "" : "\nResponse: ");
d863 1
a863 1
		type = packet_read();
d880 1
a880 1
	int type, i;
d897 1
a897 1
		type = packet_read();
d915 3
a917 1
	Key *host_key, *server_key;
d924 1
d930 1
a930 1
	packet_read_expect(SSH_SMSG_PUBLIC_KEY);
d937 8
a944 4
	server_key = key_new(KEY_RSA1);
	bits = packet_get_int();
	packet_get_bignum(server_key->rsa->e);
	packet_get_bignum(server_key->rsa->n);
d946 1
a946 1
	rbits = BN_num_bits(server_key->rsa->n);
d953 8
a960 4
	host_key = key_new(KEY_RSA1);
	bits = packet_get_int();
	packet_get_bignum(host_key->rsa->e);
	packet_get_bignum(host_key->rsa->n);
d962 1
a962 1
	rbits = BN_num_bits(host_key->rsa->n);
a974 1
	packet_check_eom();
d977 1
a977 1
	    BN_num_bits(server_key->rsa->n), BN_num_bits(host_key->rsa->n));
d979 6
a984 1
	if (verify_host_key(host, hostaddr, host_key) == -1)
d989 1
a989 1
	compute_session_id(session_id, cookie, host_key->rsa->n, server_key->rsa->n);
d1011 1
a1011 2
	if ((key = BN_new()) == NULL)
		fatal("respond_to_rsa_challenge: BN_new failed");
d1025 1
a1025 1
	if (BN_cmp(server_key->rsa->n, host_key->rsa->n) < 0) {
d1027 7
a1033 7
		if (BN_num_bits(host_key->rsa->n) <
		    BN_num_bits(server_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("respond_to_rsa_challenge: host_key %d < server_key %d + "
			    "SSH_KEY_BITS_RESERVED %d",
			    BN_num_bits(host_key->rsa->n),
			    BN_num_bits(server_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
d1035 2
a1036 2
		rsa_public_encrypt(key, key, server_key->rsa);
		rsa_public_encrypt(key, key, host_key->rsa);
d1039 7
a1045 7
		if (BN_num_bits(server_key->rsa->n) <
		    BN_num_bits(host_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("respond_to_rsa_challenge: server_key %d < host_key %d + "
			    "SSH_KEY_BITS_RESERVED %d",
			    BN_num_bits(server_key->rsa->n),
			    BN_num_bits(host_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
d1047 2
a1048 2
		rsa_public_encrypt(key, key, host_key->rsa);
		rsa_public_encrypt(key, key, server_key->rsa);
d1052 2
a1053 2
	key_free(server_key);
	key_free(host_key);
d1067 1
a1067 1
		    cipher_name(options.cipher));
d1102 1
a1102 1
	packet_read_expect(SSH_SMSG_SUCCESS);
d1119 2
a1120 1

d1135 1
a1135 1
	type = packet_read();
d1142 1
a1142 1

d1145 1
a1145 1
	    options.kerberos_authentication) {
d1147 1
a1147 1

d1149 1
a1149 1
			type = packet_read();
d1157 1
a1157 1

d1162 1
a1162 1

d1164 1
a1164 1
			type = packet_read();
d1172 1
a1172 1

d1186 1
a1186 1
		type = packet_read();
d1257 1
a1257 1

@


1.31.2.4
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.50 2002/04/21 16:25:06 stevesk Exp $");
a461 2
		if (auth.length >= MAX_KTXT_LEN)
			fatal("Kerberos v4: Malformed response from server");
d846 1
a846 1
			    "Response will be transmitted in clear text.");
@


1.30
log
@implement HostbasedAuthentication (= RhostRSAAuthentication for ssh v2)
similar to RhostRSAAuthentication unless you enable (the experimental)
HostbasedUsesNameFromPacketOnly option.  please test. :)
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.29 2001/03/26 08:07:09 markus Exp $");
d1002 1
a1002 1
			if (keys[i]->type == KEY_RSA1 &&
@


1.29
log
@simpler key load/save interface, see authfile.h
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.28 2001/03/08 21:42:33 markus Exp $");
d914 2
a915 5
ssh_userauth(
    const char *local_user,
    const char *server_user,
    char *host,
    Key *own_host_key)
d921 1
a921 1
		fatal("ssh_userauth: server supports no auth methods");
d1000 6
a1005 3
	    options.rhosts_rsa_authentication && own_host_key != NULL) {
		if (try_rhosts_rsa_authentication(local_user, own_host_key))
			return;
@


1.28
log
@implement client side of SSH2_MSG_USERAUTH_PK_OK (test public key ->
no need to do enter passphrase or do expensive sign operations if the
server does not accept key).
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.27 2001/02/15 23:19:59 markus Exp $");
d214 3
a216 3
	public = key_new(KEY_RSA1);
	if (!load_public_key(authfile, public, &comment)) {
		key_free(public);
a254 1
	private = key_new(KEY_RSA1);
d259 2
a260 1
	if (!load_private_key(authfile, "", private, NULL)) {
d273 2
a274 1
		if (!load_private_key(authfile, passphrase, private, NULL)) {
a288 1
			key_free(private);
d325 1
a325 1
try_rhosts_rsa_authentication(const char *local_user, RSA * host_key)
d336 3
a338 3
	packet_put_int(BN_num_bits(host_key->n));
	packet_put_bignum(host_key->e);
	packet_put_bignum(host_key->n);
d364 1
a364 1
	respond_to_rsa_challenge(challenge, host_key);
d918 1
a918 1
    int host_key_valid, RSA *own_host_key)
d1003 1
a1003 1
	    options.rhosts_rsa_authentication && host_key_valid) {
@


1.27
log
@genericize password padding function for SSH1 and SSH2.
add stylized echo to 2, too.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.26 2001/02/12 12:45:06 markus Exp $");
d1020 2
a1021 1
			if (options.identity_files_type[i] == KEY_RSA1 &&
@


1.26
log
@fix xmalloc(0), ok dugsong@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.25 2001/02/08 23:11:43 dugsong Exp $");
a53 14
void
ssh1_put_password(char *password)
{
	int size;
	char *padded;

	size = roundup(strlen(password) + 1, 32);
	padded = xmalloc(size);
	strlcpy(padded, password, size);
	packet_put_string(padded, size);
	memset(padded, 0, size);
	xfree(padded);
}

d661 1
a661 1
		ssh1_put_password(response);
d694 1
a694 1
		ssh1_put_password(password);
@


1.25
log
@mitigate SSH1 traffic analysis - from Solar Designer <solar@@openwall.com>, ok provos@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.24 2001/02/08 19:30:52 itojun Exp $");
d60 1
a60 1
	size = roundup(strlen(password), 32);
@


1.24
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.23 2001/02/08 10:47:04 itojun Exp $");
d54 14
d675 1
a675 1
		packet_put_string(response, strlen(response));
d708 1
a708 1
		packet_put_string(password, strlen(password));
@


1.23
log
@%.30s is too short for IPv6 numeric address.  use %.128s for now.  markus ok
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.22 2001/02/03 10:08:37 markus Exp $");
d59 1
a59 1
try_agent_authentication()
d383 1
a383 1
try_kerberos_authentication()
d500 1
a500 1
send_kerberos_tgt()
d619 1
a619 1
try_challenge_reponse_authentication()
@


1.22
log
@make ReverseMappingCheck optional in sshd_config; ok djm@@,dugsong@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.21 2001/01/29 19:47:31 markus Exp $");
d1035 1
a1035 1
		snprintf(prompt, sizeof(prompt), "%.30s@@%.40s's password: ",
@


1.21
log
@handle rsa_private_decrypt failures; helps against the Bleichenbacher pkcs#1 attack
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.20 2001/01/22 23:06:40 markus Exp $");
d402 1
a402 1
	strncpy(inst, (char *) krb_get_phost(get_canonical_hostname()), INST_SZ);
d404 1
a404 1
	realm = (char *) krb_realmofhost(get_canonical_hostname());
d406 1
a406 1
		debug("Kerberos V4: no realm for %s", get_canonical_hostname());
@


1.20
log
@rename skey -> challenge response.
auto-enable kbd-interactive for ssh2 if challenge-reponse is enabled.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.19 2001/01/22 08:15:00 markus Exp $");
d166 4
a169 1
	rsa_private_decrypt(challenge, challenge, prv);
d175 2
a176 2
		packet_disconnect("respond_to_rsa_challenge: bad challenge length %d",
				  len);
@


1.19
log
@only AFS needs radix.[ch]
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.18 2001/01/21 19:06:00 markus Exp $");
d616 1
a616 1
try_skey_authentication()
d624 1
a624 1
	debug("Doing skey authentication.");
d636 1
a636 1
			    "to skey-auth", type);
d639 1
a639 1
			debug("No challenge for skey authentication.");
d668 1
a668 1
			    "to skey-auth-reponse", type);
d1021 1
a1021 1
	/* Try skey authentication if the server supports it. */
d1023 2
a1024 2
	    options.skey_authentication && !options.batch_mode) {
		if (try_skey_authentication())
@


1.18
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.17 2001/01/19 15:55:12 markus Exp $");
a22 1
#include "radix.h"
d26 1
@


1.17
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.16 2001/01/18 17:00:00 markus Exp $");
a18 2
#include <openssl/dsa.h>
#include <openssl/rsa.h>
d21 10
a32 2
#include "ssh.h"
#include "ssh1.h"
d37 1
d43 3
@


1.16
log
@1) removes fake skey from sshd, since this will be much
   harder with /usr/libexec/auth/login_XXX
2) share/unify code used in ssh-1 and ssh-2 authentication (server side)
3) make addition of BSD_AUTH and other challenge reponse methods
   easier.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.15 2001/01/16 23:58:09 deraadt Exp $");
d26 1
@


1.15
log
@indent
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.14 2001/01/08 21:55:41 markus Exp $");
d633 2
a634 1
		snprintf(prompt, sizeof prompt, "%s\nResponse: ", challenge);
@


1.14
log
@more cleanups and fixes from stevesk@@pobox.com:
1) try_agent_authentication() for loop will overwrite key just
   allocated with key_new(); don't alloc
2) call ssh_close_authentication_connection() before exit
   try_agent_authentication()
3) free mem on bad passphrase in try_rsa_authentication()
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.13 2000/12/19 23:17:58 markus Exp $");
d580 1
a580 1
		if (creds_to_radix(&creds, (u_char*) buffer, sizeof buffer) <= 0)
d900 2
a901 2
    const char* local_user,
    const char* server_user,
@


1.13
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.12 2000/12/10 17:01:53 markus Exp $");
a64 1
	key = key_new(KEY_RSA1);
d127 1
d137 1
d274 2
@


1.12
log
@always request new challenge for skey/tis-auth, fixes interop with
other implementations; report from roth@@feep.net
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.11 2000/11/25 16:42:53 markus Exp $");
d37 2
a38 2
unsigned char session_id[16];
unsigned int supported_authentications = 0;
d53 2
a54 2
	unsigned char response[16];
	unsigned int i;
d149 1
a149 1
	unsigned char buf[32], response[16];
d444 1
a444 1
		reply = packet_get_string((unsigned int *) &auth.length);
d509 1
a509 1
	creds_to_radix(creds, (unsigned char *)buffer, sizeof buffer);
d548 1
a548 1
		memcpy(&creds.ticket_st.length, p, sizeof(unsigned int));
d551 1
a551 1
		p += sizeof(unsigned int);
d577 1
a577 1
		if (creds_to_radix(&creds, (unsigned char*) buffer, sizeof buffer) <= 0)
d606 1
a606 1
	unsigned int clen;
d705 4
a708 4
	unsigned char session_key[SSH_SESSION_KEY_LENGTH];
	unsigned char cookie[8];
	unsigned int supported_ciphers;
	unsigned int server_flags, client_flags;
@


1.11
log
@reorder check for illegal ciphers, bugreport from espie@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.10 2000/11/23 21:03:47 markus Exp $");
d607 1
d612 5
a616 4
	/* request a challenge */
	packet_start(SSH_CMSG_AUTH_TIS);
	packet_send();
	packet_write_wait();
d618 14
a631 19
	type = packet_read(&payload_len);
	if (type != SSH_SMSG_FAILURE &&
	    type != SSH_SMSG_AUTH_TIS_CHALLENGE) {
		packet_disconnect("Protocol error: got %d in response "
				  "to skey-auth", type);
	}
	if (type != SSH_SMSG_AUTH_TIS_CHALLENGE) {
		debug("No challenge for skey authentication.");
		return 0;
	}
	challenge = packet_get_string(&clen);
	packet_integrity_check(payload_len, (4 + clen), type);
	if (options.cipher == SSH_CIPHER_NONE)
		log("WARNING: Encryption is disabled! "
		    "Reponse will be transmitted in clear text.");
	fprintf(stderr, "%s\n", challenge);
	xfree(challenge);
	fflush(stderr);
	for (i = 0; i < options.number_of_password_prompts; i++) {
d634 8
a641 1
		response = read_passphrase("Response: ", 0);
d653 1
a653 1
					  "to skey-auth-reponse", type);
@


1.10
log
@complain about invalid ciphers for ssh1/ssh2, fall back to reasonable defaults
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.9 2000/11/12 19:50:38 markus Exp $");
d836 4
a839 1
	if (options.cipher == SSH_CIPHER_ILLEGAL ||
a843 3
	} else if (options.cipher == SSH_CIPHER_NOT_SET) {
		if (cipher_mask_ssh1(1) & supported_ciphers & (1 << ssh_cipher_default))
			options.cipher = ssh_cipher_default;
@


1.9
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.8 2000/10/12 09:59:19 markus Exp $");
d836 2
a837 1
	if (options.cipher == SSH_CIPHER_ILLEGAL) {
@


1.8
log
@enable DES in SSH-1 clients only
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.7 2000/10/11 20:27:24 markus Exp $");
d65 1
a65 1
	key = key_new(KEY_RSA);
d199 1
a199 1
	public = key_new(KEY_RSA);
d240 1
a240 1
	private = key_new(KEY_RSA);
d763 1
a763 1
	k.type = KEY_RSA;
d997 2
a998 1
			if (try_rsa_authentication(options.identity_files[i]))
@


1.8.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.27 2001/02/15 23:19:59 markus Exp $");
d19 2
a22 10
#ifdef KRB4
#include <krb.h>
#endif
#ifdef AFS
#include <kafs.h>
#include "radix.h"
#endif

#include "ssh.h"
#include "ssh1.h"
d25 1
a29 1
#include "log.h"
a34 3
#include "readpass.h"
#include "cipher.h"
#include "canohost.h"
d37 2
a38 2
u_char session_id[16];
u_int supported_authentications = 0;
d48 1
a48 1
try_agent_authentication(void)
d53 2
a54 2
	u_char response[16];
	u_int i;
d65 1
a127 1
			ssh_close_authentication_connection(auth);
a136 1
	ssh_close_authentication_connection(auth);
d149 1
a149 1
	u_char buf[32], response[16];
d154 1
a154 4
	/* XXX think about Bleichenbacher, too */
	if (rsa_private_decrypt(challenge, challenge, prv) <= 0)
		packet_disconnect(
		    "respond_to_rsa_challenge: rsa_private_decrypt failed");
d160 2
a161 2
		packet_disconnect(
		    "respond_to_rsa_challenge: bad challenge length %d", len);
d199 1
a199 1
	public = key_new(KEY_RSA1);
d240 1
a240 1
	private = key_new(KEY_RSA1);
a272 2
			key_free(private);
			BN_clear_free(challenge);
d366 1
a366 1
try_kerberos_authentication(void)
d385 1
a385 1
	strncpy(inst, (char *) krb_get_phost(get_canonical_hostname(1)), INST_SZ);
d387 1
a387 1
	realm = (char *) krb_realmofhost(get_canonical_hostname(1));
d389 1
a389 1
		debug("Kerberos V4: no realm for %s", get_canonical_hostname(1));
d444 1
a444 1
		reply = packet_get_string((u_int *) &auth.length);
d483 1
a483 1
send_kerberos_tgt(void)
d509 1
a509 1
	creds_to_radix(creds, (u_char *)buffer, sizeof buffer);
d548 1
a548 1
		memcpy(&creds.ticket_st.length, p, sizeof(u_int));
d551 1
a551 1
		p += sizeof(u_int);
d577 1
a577 1
		if (creds_to_radix(&creds, (u_char *) buffer, sizeof buffer) <= 0)
d602 1
a602 1
try_challenge_reponse_authentication(void)
d606 1
a606 2
	u_int clen;
	char prompt[1024];
d609 1
a609 1
	debug("Doing challenge reponse authentication.");
d611 23
a634 20
		/* request a challenge */
		packet_start(SSH_CMSG_AUTH_TIS);
		packet_send();
		packet_write_wait();

		type = packet_read(&payload_len);
		if (type != SSH_SMSG_FAILURE &&
		    type != SSH_SMSG_AUTH_TIS_CHALLENGE) {
			packet_disconnect("Protocol error: got %d in response "
			    "to SSH_CMSG_AUTH_TIS", type);
		}
		if (type != SSH_SMSG_AUTH_TIS_CHALLENGE) {
			debug("No challenge.");
			return 0;
		}
		challenge = packet_get_string(&clen);
		packet_integrity_check(payload_len, (4 + clen), type);
		snprintf(prompt, sizeof prompt, "%s%s", challenge,
		     strchr(challenge, '\n') ? "" : "\nResponse: ");
		xfree(challenge);
d637 1
a637 8
		if (options.cipher == SSH_CIPHER_NONE)
			log("WARNING: Encryption is disabled! "
			    "Reponse will be transmitted in clear text.");
		response = read_passphrase(prompt, 0);
		if (strcmp(response, "") == 0) {
			xfree(response);
			break;
		}
d639 1
a639 1
		ssh_put_password(response);
d649 1
a649 1
			    "to SSH_CMSG_AUTH_TIS_RESPONSE", type);
d672 1
a672 1
		ssh_put_password(password);
d701 4
a704 4
	u_char session_key[SSH_SESSION_KEY_LENGTH];
	u_char cookie[8];
	u_int supported_ciphers;
	u_int server_flags, client_flags;
d763 1
a763 1
	k.type = KEY_RSA1;
d836 1
a836 5
	if (options.cipher == SSH_CIPHER_NOT_SET) {
		if (cipher_mask_ssh1(1) & supported_ciphers & (1 << ssh_cipher_default))
			options.cipher = ssh_cipher_default;
	} else if (options.cipher == SSH_CIPHER_ILLEGAL ||
	    !(cipher_mask_ssh1(1) & (1 << options.cipher))) {
d840 3
d892 2
a893 2
    const char *local_user,
    const char *server_user,
d997 1
a997 2
			if (options.identity_files_type[i] == KEY_RSA1 &&
			    try_rsa_authentication(options.identity_files[i]))
d1000 1
a1000 1
	/* Try challenge response authentication if the server supports it. */
d1002 2
a1003 2
	    options.challenge_reponse_authentication && !options.batch_mode) {
		if (try_challenge_reponse_authentication())
d1011 1
a1011 1
		snprintf(prompt, sizeof(prompt), "%.30s@@%.128s's password: ",
@


1.8.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.8.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.28 2001/03/08 21:42:33 markus Exp $");
d1020 1
a1020 2
			if (options.identity_keys[i] != NULL &&
			    options.identity_keys[i]->type == KEY_RSA1 &&
@


1.8.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.31 2001/04/17 08:14:01 markus Exp $");
d214 3
a216 3
	/* XXKEYLOAD */
	public = key_load_public_type(KEY_RSA1, authfile, &comment);
	if (public == NULL) {
d255 1
d260 1
a260 2
	private = key_load_private_type(KEY_RSA1, authfile, "", NULL);
	if (private == NULL) {
d273 1
a273 2
		private = key_load_private_type(KEY_RSA1, authfile, passphrase, NULL);
		if (private == NULL) {
d288 1
d325 1
a325 1
try_rhosts_rsa_authentication(const char *local_user, Key * host_key)
d336 3
a338 3
	packet_put_int(BN_num_bits(host_key->rsa->n));
	packet_put_bignum(host_key->rsa->e);
	packet_put_bignum(host_key->rsa->n);
d364 1
a364 1
	respond_to_rsa_challenge(challenge, host_key->rsa);
d914 5
a918 2
ssh_userauth1(const char *local_user, const char *server_user, char *host,
    Key **keys, int nkeys)
d924 1
a924 1
		fatal("ssh_userauth1: server supports no auth methods");
d1003 3
a1005 6
	    options.rhosts_rsa_authentication) {
		for (i = 0; i < nkeys; i++) {
			if (keys[i] != NULL && keys[i]->type == KEY_RSA1 &&
			    try_rhosts_rsa_authentication(local_user, keys[i]))
				return;
		}
@


1.8.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.39 2001/07/05 20:32:47 stevesk Exp $");
a23 3
#ifdef KRB5
#include <krb5.h>
#endif
a45 1
#include "auth.h"
d58 1
a58 1
static int
d158 1
a158 1
static void
d203 2
a204 2
static int
try_rsa_authentication(int idx)
d207 5
a211 7
	Key *public, *private;
	char buf[300], *passphrase, *comment, *authfile;
	int i, type, quit, plen, clen;

	public = options.identity_keys[idx];
	authfile = options.identity_files[idx];
	comment = xstrdup(authfile);
d213 7
d228 3
d256 1
a256 2
	 * If the key is not stored in external hardware, we have to
	 * load the private key.  Try first with empty passphrase; if it
d259 6
a264 8
	if (public->flags && KEY_FLAG_EXT)
		private = public;
	else
		private = key_load_private_type(KEY_RSA1, authfile, "", NULL);
	if (private == NULL && !options.batch_mode) {
		snprintf(buf, sizeof(buf),
		    "Enter passphrase for RSA key '%.100s': ", comment);
		for (i = 0; i < options.number_of_password_prompts; i++) {
d266 9
a274 8
			if (strcmp(passphrase, "") != 0) {
				private = key_load_private_type(KEY_RSA1,
				    authfile, passphrase, NULL);
				quit = 0;
			} else {
				debug2("no passphrase given, try next key");
				quit = 1;
			}
d277 14
a290 3
			if (private != NULL || quit)
				break;
			debug2("bad passphrase given, try again...");
d292 3
a298 17
	if (private == NULL) {
		if (!options.batch_mode)
			error("Bad passphrase.");

		/* Send a dummy response packet to avoid protocol error. */
		packet_start(SSH_CMSG_AUTH_RSA_RESPONSE);
		for (i = 0; i < 16; i++)
			packet_put_char(0);
		packet_send();
		packet_write_wait();

		/* Expect the server to reject it... */
		packet_read_expect(&plen, SSH_SMSG_FAILURE);
		BN_clear_free(challenge);
		return 0;
	}

d302 2
a303 3
	/* Destroy the private key unless it in external hardware. */
	if (!(private->flags & KEY_FLAG_EXT))
		key_free(private);
d324 1
a324 1
static int
d335 1
a335 1
	packet_put_cstring(local_user);
d382 2
a383 2
static int
try_krb4_authentication(void)
d401 4
a404 5
	
	strlcpy(inst, (char *)krb_get_phost(get_canonical_hostname(1)),
	    INST_SZ);
	
	realm = (char *)krb_realmofhost(get_canonical_hostname(1));
d406 1
a406 1
		debug("Kerberos v4: no realm for %s", get_canonical_hostname(1));
d410 2
a411 2
	checksum = (u_long)getpid();
	
d414 1
a414 1
		debug("Kerberos v4 krb_mk_req failed: %s", krb_err_txt[r]);
d424 1
a424 1
	
d430 1
a430 1
	
d433 1
a433 1
	
d437 1
a437 1
	    (struct sockaddr *)&local, &slen) < 0)
d439 1
a439 1
	
d443 1
a443 1
	    (struct sockaddr *)&foreign, &slen) < 0) {
d452 1
a452 1
		debug("Kerberos v4 authentication failed.");
d455 1
a455 1
		
d458 2
a459 2
		debug("Kerberos v4 authentication accepted.");
		
d464 1
a464 1
		
d466 1
a466 1
		
d473 1
a473 1
		    &foreign, &local, &msg_data);
d475 2
a476 3
			debug("Kerberos v4 krb_rd_priv failed: %s",
			    krb_err_txt[r]);
			packet_disconnect("Kerberos v4 challenge failed!");
d479 1
a479 2
		memcpy((char *)&cksum, (char *)msg_data.app_data,
		    sizeof(cksum));
d481 1
a481 1
		
d484 1
a484 1
			debug("Kerberos v4 challenge successful.");
d487 1
a487 1
			packet_disconnect("Kerberos v4 challenge failed!");
d489 1
a489 1
		
d491 1
a491 1
		packet_disconnect("Protocol error on Kerberos v4 response: %d", type);
a497 185
#ifdef KRB5
static int
try_krb5_authentication(krb5_context *context, krb5_auth_context *auth_context)
{
	krb5_error_code problem;
	const char *tkfile;
	struct stat buf;
	krb5_ccache ccache = NULL;
	const char *remotehost;
	krb5_data ap;
	int type, payload_len;
	krb5_ap_rep_enc_part *reply = NULL;
	int ret;
	
	memset(&ap, 0, sizeof(ap));
	
	problem = krb5_init_context(context);
	if (problem) {
		debug("Kerberos v5: krb5_init_context failed");
		ret = 0;
		goto out;
	}
	
	tkfile = krb5_cc_default_name(*context);
	if (strncmp(tkfile, "FILE:", 5) == 0)
		tkfile += 5;
	
	if (stat(tkfile, &buf) == 0 && getuid() != buf.st_uid) {
		debug("Kerberos v5: could not get default ccache (permission denied).");
		ret = 0;
		goto out;
	}
	
	problem = krb5_cc_default(*context, &ccache);
	if (problem) {
		debug("Kerberos v5: krb5_cc_default failed: %s",
		    krb5_get_err_text(*context, problem));
		ret = 0;
		goto out;
	}
	
	remotehost = get_canonical_hostname(1);
	
	problem = krb5_mk_req(*context, auth_context, AP_OPTS_MUTUAL_REQUIRED,
	    "host", remotehost, NULL, ccache, &ap);
	if (problem) {
		debug("Kerberos v5: krb5_mk_req failed: %s",
		    krb5_get_err_text(*context, problem));
		ret = 0;
		goto out;
	}
	
	packet_start(SSH_CMSG_AUTH_KERBEROS);
	packet_put_string((char *) ap.data, ap.length);
	packet_send();
	packet_write_wait();
	
	xfree(ap.data);
	ap.length = 0;
	
	type = packet_read(&payload_len);
	switch (type) {
        case SSH_SMSG_FAILURE:
                /* Should really be SSH_SMSG_AUTH_KERBEROS_FAILURE */
                debug("Kerberos v5 authentication failed.");
                ret = 0;
                break;
		
	case SSH_SMSG_AUTH_KERBEROS_RESPONSE:
                /* SSH_SMSG_AUTH_KERBEROS_SUCCESS */
                debug("Kerberos v5 authentication accepted.");
		
                /* Get server's response. */
                ap.data = packet_get_string((unsigned int *) &ap.length);
		
                packet_integrity_check(payload_len, 4 + ap.length, type);
                /* XXX je to dobre? */
		
                problem = krb5_rd_rep(*context, *auth_context, &ap, &reply);
                if (problem) {
			ret = 0;
		}
		ret = 1;
		break;
		
	default:
		packet_disconnect("Protocol error on Kerberos v5 response: %d",
		    type);
		ret = 0;
		break;
		
	}
	
 out:
	if (ccache != NULL)
		krb5_cc_close(*context, ccache);
	if (reply != NULL)
		krb5_free_ap_rep_enc_part(*context, reply);
	if (ap.length > 0)
		krb5_data_free(&ap);
	
	return (ret);
}

static void
send_krb5_tgt(krb5_context context, krb5_auth_context auth_context)
{
	int fd, type, payload_len;
	krb5_error_code problem;
	krb5_data outbuf;
	krb5_ccache ccache = NULL;
	krb5_creds creds;
	krb5_kdc_flags flags;
	const char *remotehost;
	
	memset(&creds, 0, sizeof(creds));
	memset(&outbuf, 0, sizeof(outbuf));
	
	fd = packet_get_connection_in();
	
	problem = krb5_auth_con_setaddrs_from_fd(context, auth_context, &fd);
	if (problem)
		goto out;
	
	problem = krb5_cc_default(context, &ccache);
	if (problem)
		goto out;
	
	problem = krb5_cc_get_principal(context, ccache, &creds.client);
	if (problem)
		goto out;
	
	problem = krb5_build_principal(context, &creds.server,
	    strlen(creds.client->realm), creds.client->realm,
	    "krbtgt", creds.client->realm, NULL);
	if (problem)
		goto out;
	
	creds.times.endtime = 0;
	
	flags.i = 0;
	flags.b.forwarded = 1;
	flags.b.forwardable = krb5_config_get_bool(context,  NULL,
	    "libdefaults", "forwardable", NULL);
	
	remotehost = get_canonical_hostname(1);
	
	problem = krb5_get_forwarded_creds(context, auth_context,
	    ccache, flags.i, remotehost, &creds, &outbuf);
	if (problem)
		goto out;
	
	packet_start(SSH_CMSG_HAVE_KERBEROS_TGT);
	packet_put_string((char *)outbuf.data, outbuf.length);
	packet_send();
	packet_write_wait();
	
	type = packet_read(&payload_len);
	
	if (type == SSH_SMSG_SUCCESS) {
		char *pname;
		
		krb5_unparse_name(context, creds.client, &pname);
		debug("Kerberos v5 TGT forwarded (%s).", pname);
		xfree(pname);
	} else
		debug("Kerberos v5 TGT forwarding failed.");
	
	return;
	
 out:
	if (problem)
		debug("Kerberos v5 TGT forwarding failed: %s",
		    krb5_get_err_text(context, problem));
	if (creds.client)
		krb5_free_principal(context, creds.client);
	if (creds.server)
		krb5_free_principal(context, creds.server);
	if (ccache)
		krb5_cc_close(context, ccache);
	if (outbuf.data)
		xfree(outbuf.data);
}
#endif /* KRB5 */

d499 2
a500 2
static void
send_krb4_tgt(void)
d503 3
d507 1
a507 3
	char buffer[4096], pname[ANAME_SZ], pinst[INST_SZ], prealm[REALM_SZ];
	int problem, type, len;
	
d510 2
a511 2
		return;
	
d513 9
a521 9
	
	problem = krb_get_tf_fullname(TKT_FILE, pname, pinst, prealm);
	if (problem)
		goto out;
	
	problem = krb_get_cred("krbtgt", prealm, prealm, creds);
	if (problem)
		goto out;
	
d523 2
a524 2
		problem = RD_AP_EXP;
		goto out;
d526 3
a528 2
	creds_to_radix(creds, (u_char *)buffer, sizeof(buffer));
	
d530 1
a530 1
	packet_put_cstring(buffer);
d533 9
a541 16
	
	type = packet_read(&len);
	
	if (type == SSH_SMSG_SUCCESS)
		debug("Kerberos v4 TGT forwarded (%s%s%s@@%s).",
		    creds->pname, creds->pinst[0] ? "." : "",
		    creds->pinst, creds->realm);
	else
		debug("Kerberos v4 TGT rejected.");
	
	xfree(creds);
	return;
	
 out:
	debug("Kerberos v4 TGT passing failed: %s", krb_err_txt[problem]);
	xfree(creds);
d544 1
a544 1
static void
d550 1
a550 1
	int i, type, len;
d553 1
a553 1
	
d563 1
a563 1
		
d571 1
a571 1
		
d581 1
a581 1
		
d583 1
a583 1
		strlcpy(creds.service, "afs", sizeof(creds.service));
d588 1
a588 2
		creds.lifetime = krb_time_to_life(creds.issue_date,
		    ct.EndTimestamp);
d592 1
a592 1
		
d594 1
a594 2
		if (creds_to_radix(&creds, (u_char *)buffer,
		    sizeof(buffer)) <= 0)
d597 1
a597 1
		packet_put_cstring(buffer);
d603 2
a604 2
		type = packet_read(&len);
		
d618 2
a619 2
static int
try_challenge_response_authentication(void)
d626 1
a626 1
	
d628 1
a628 1
	
d680 1
a680 1
static int
d787 2
a788 2
	if (verify_host_key(host, hostaddr, &k) == -1)
		fatal("host_key verification failed");
a916 4
#ifdef KRB5
	krb5_context context = NULL;
	krb5_auth_context auth_context = NULL;
#endif
d919 1
a919 1
	
d925 1
a925 1
	packet_put_cstring(server_user);
d938 1
a938 1
		goto success;
d940 17
a956 14
		packet_disconnect("Protocol error: got %d in response to SSH_CMSG_USER", type);
	
#ifdef KRB5
	if ((supported_authentications & (1 << SSH_AUTH_KERBEROS)) &&
            options.kerberos_authentication) {
		debug("Trying Kerberos v5 authentication.");
		
		if (try_krb5_authentication(&context, &auth_context)) {
			type = packet_read(&payload_len);
			if (type == SSH_SMSG_SUCCESS)
				goto success;
			if (type != SSH_SMSG_FAILURE)
				packet_disconnect("Protocol error: got %d in response to Kerberos v5 auth", type);
		}
d958 2
a959 2
#endif /* KRB5 */
	
d963 3
a965 3
		debug("Trying Kerberos v4 authentication.");
		
		if (try_krb4_authentication()) {
d968 1
a968 1
				goto success;
d970 1
a970 1
				packet_disconnect("Protocol error: got %d in response to Kerberos v4 auth", type);
d974 1
a974 1
	
d983 1
a983 1
		packet_put_cstring(local_user);
d990 1
a990 1
			goto success;
d1004 1
a1004 1
				goto success;
d1016 1
a1016 1
			goto success;
d1022 2
a1023 2
			    try_rsa_authentication(i))
				goto success;
d1027 3
a1029 3
	    options.challenge_response_authentication && !options.batch_mode) {
		if (try_challenge_response_authentication())
			goto success;
d1039 1
a1039 1
			goto success;
a1043 34

 success:
#ifdef KRB5
	/* Try Kerberos v5 TGT passing. */
	if ((supported_authentications & (1 << SSH_PASS_KERBEROS_TGT)) &&
	    options.kerberos_tgt_passing && context && auth_context) {
		if (options.cipher == SSH_CIPHER_NONE)
			log("WARNING: Encryption is disabled! Ticket will be transmitted in the clear!");
		send_krb5_tgt(context, auth_context);
	}
	if (auth_context)
		krb5_auth_con_free(context, auth_context);
	if (context)
		krb5_free_context(context);
#endif
	
#ifdef AFS
	/* Try Kerberos v4 TGT passing if the server supports it. */
	if ((supported_authentications & (1 << SSH_PASS_KERBEROS_TGT)) &&
	    options.kerberos_tgt_passing) {
		if (options.cipher == SSH_CIPHER_NONE)
			log("WARNING: Encryption is disabled! Ticket will be transmitted in the clear!");
		send_krb4_tgt();
	}
	/* Try AFS token passing if the server supports it. */
	if ((supported_authentications & (1 << SSH_PASS_AFS_TOKEN)) &&
	    options.afs_token_passing && k_hasafs()) {
		if (options.cipher == SSH_CIPHER_NONE)
			log("WARNING: Encryption is disabled! Token will be transmitted in the clear!");
		send_afs_tokens();
	}
#endif /* AFS */

	return;	/* need statement after label */
@


1.8.2.6
log
@Merge OpenSSH 3.0
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.8.2.5 2001/09/27 00:15:43 miod Exp $");
d823 3
a825 3

	debug("Doing challenge response authentication.");

d985 1
a985 1
		fatal("Host key verification failed.");
@


1.8.2.7
log
@Merge OpenSSH 3.1.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.48 2002/02/11 16:15:46 markus Exp $");
d19 1
a19 1
#include <openssl/md5.h>
d70 1
d79 2
a80 2
	if ((challenge = BN_new()) == NULL)
		fatal("try_agent_authentication: BN_new failed");
d83 2
a84 2
	    key != NULL;
	    key = ssh_get_next_identity(auth, &comment, 1)) {
d97 1
a97 1
		type = packet_read();
d111 3
a113 2
		packet_get_bignum(challenge);
		packet_check_eom();
d138 1
a138 1
		type = packet_read();
d213 1
a213 1
	int i, type, quit;
d228 1
a228 1
	type = packet_read();
d244 4
a247 4
	if ((challenge = BN_new()) == NULL)
		fatal("try_rsa_authentication: BN_new failed");
	packet_get_bignum(challenge);
	packet_check_eom();
d295 1
a295 1
		packet_read_expect(SSH_SMSG_FAILURE);
d311 1
a311 1
	type = packet_read();
d331 1
d345 1
a345 1
	type = packet_read();
d358 4
a361 4
	if ((challenge = BN_new()) == NULL)
		fatal("try_rhosts_rsa_authentication: BN_new failed");
	packet_get_bignum(challenge);
	packet_check_eom();
d372 1
a372 1
	type = packet_read();
d392 1
a392 1
	int r, type;
d403 1
a403 1

d406 1
a406 1

d414 1
a414 1

d427 1
a427 1

d433 1
a433 1

d436 1
a436 1

d442 1
a442 1

d451 1
a451 1
	type = packet_read();
d458 1
a458 1

d462 1
a462 1

d467 3
a469 3

		packet_check_eom();

d486 1
a486 1

d494 1
a494 1

d513 1
a513 1
	int type;
d516 1
a516 1

d518 1
a518 1

d525 1
a525 1

d529 1
a529 1

d535 1
a535 1

d543 1
a543 1

d545 1
a545 1

d554 1
a554 1

d559 1
a559 1

d562 2
a563 2

	type = packet_read();
d565 6
a570 6
	case SSH_SMSG_FAILURE:
		/* Should really be SSH_SMSG_AUTH_KERBEROS_FAILURE */
		debug("Kerberos v5 authentication failed.");
		ret = 0;
		break;

d572 11
a582 10
		/* SSH_SMSG_AUTH_KERBEROS_SUCCESS */
		debug("Kerberos v5 authentication accepted.");

		/* Get server's response. */
		ap.data = packet_get_string((unsigned int *) &ap.length);
		packet_check_eom();
		/* XXX je to dobre? */

		problem = krb5_rd_rep(*context, *auth_context, &ap, &reply);
		if (problem) {
d587 1
a587 1

d593 1
a593 1

d595 1
a595 1

d603 1
a603 1

d610 1
a610 1
	int fd, type;
d617 1
a617 1

d620 1
a620 1

d622 1
a622 1

d626 1
a626 1

d630 1
a630 1

d634 1
a634 1

d640 1
a640 1

d642 1
a642 1

d647 1
a647 1

d649 1
a649 1

d654 1
a654 1

d659 3
a661 3

	type = packet_read();

d664 1
a664 1

d670 1
a670 1

d672 1
a672 1

d695 2
a696 2
	int problem, type;

d700 1
a700 1

d702 1
a702 1

d706 1
a706 1

d710 1
a710 1

d716 1
a716 1

d721 3
a723 3

	type = packet_read();

d730 1
a730 1

d733 1
a733 1

d748 1
a748 1

d758 1
a758 1

d766 1
a766 1

d776 1
a776 1

d788 1
a788 1

d800 2
a801 2
		type = packet_read();

d819 1
d832 1
a832 1
		type = packet_read();
d843 1
a843 1
		packet_check_eom();
d845 1
a845 1
		    strchr(challenge, '\n') ? "" : "\nResponse: ");
d863 1
a863 1
		type = packet_read();
d880 1
a880 1
	int type, i;
d897 1
a897 1
		type = packet_read();
d915 3
a917 1
	Key *host_key, *server_key;
d924 1
d930 1
a930 1
	packet_read_expect(SSH_SMSG_PUBLIC_KEY);
d937 8
a944 4
	server_key = key_new(KEY_RSA1);
	bits = packet_get_int();
	packet_get_bignum(server_key->rsa->e);
	packet_get_bignum(server_key->rsa->n);
d946 1
a946 1
	rbits = BN_num_bits(server_key->rsa->n);
d953 8
a960 4
	host_key = key_new(KEY_RSA1);
	bits = packet_get_int();
	packet_get_bignum(host_key->rsa->e);
	packet_get_bignum(host_key->rsa->n);
d962 1
a962 1
	rbits = BN_num_bits(host_key->rsa->n);
a974 1
	packet_check_eom();
d977 1
a977 1
	    BN_num_bits(server_key->rsa->n), BN_num_bits(host_key->rsa->n));
d979 6
a984 1
	if (verify_host_key(host, hostaddr, host_key) == -1)
d989 1
a989 1
	compute_session_id(session_id, cookie, host_key->rsa->n, server_key->rsa->n);
d1011 1
a1011 2
	if ((key = BN_new()) == NULL)
		fatal("respond_to_rsa_challenge: BN_new failed");
d1025 1
a1025 1
	if (BN_cmp(server_key->rsa->n, host_key->rsa->n) < 0) {
d1027 7
a1033 7
		if (BN_num_bits(host_key->rsa->n) <
		    BN_num_bits(server_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("respond_to_rsa_challenge: host_key %d < server_key %d + "
			    "SSH_KEY_BITS_RESERVED %d",
			    BN_num_bits(host_key->rsa->n),
			    BN_num_bits(server_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
d1035 2
a1036 2
		rsa_public_encrypt(key, key, server_key->rsa);
		rsa_public_encrypt(key, key, host_key->rsa);
d1039 7
a1045 7
		if (BN_num_bits(server_key->rsa->n) <
		    BN_num_bits(host_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("respond_to_rsa_challenge: server_key %d < host_key %d + "
			    "SSH_KEY_BITS_RESERVED %d",
			    BN_num_bits(server_key->rsa->n),
			    BN_num_bits(host_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
d1047 2
a1048 2
		rsa_public_encrypt(key, key, host_key->rsa);
		rsa_public_encrypt(key, key, server_key->rsa);
d1052 2
a1053 2
	key_free(server_key);
	key_free(host_key);
d1067 1
a1067 1
		    cipher_name(options.cipher));
d1102 1
a1102 1
	packet_read_expect(SSH_SMSG_SUCCESS);
d1119 2
a1120 1

d1135 1
a1135 1
	type = packet_read();
d1142 1
a1142 1

d1145 1
a1145 1
	    options.kerberos_authentication) {
d1147 1
a1147 1

d1149 1
a1149 1
			type = packet_read();
d1157 1
a1157 1

d1162 1
a1162 1

d1164 1
a1164 1
			type = packet_read();
d1172 1
a1172 1

d1186 1
a1186 1
		type = packet_read();
d1257 1
a1257 1

@


1.7
log
@new cipher framework
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.6 2000/09/07 20:27:54 deraadt Exp $");
d841 1
a841 1
		if (cipher_mask1() & supported_ciphers & (1 << ssh_cipher_default))
@


1.6
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.5 2000/08/19 21:34:44 markus Exp $");
a27 1
#include "cipher.h"
d838 2
a839 2
		    cipher_name(SSH_FALLBACK_CIPHER));
		options.cipher = SSH_FALLBACK_CIPHER;
a842 6
		else {
			debug("Cipher %s not supported, using %.100s instead.",
			    cipher_name(ssh_cipher_default),
			    cipher_name(SSH_FALLBACK_CIPHER));
			options.cipher = SSH_FALLBACK_CIPHER;
		}
@


1.5
log
@add SSH2/DSA support to the agent and some other DSA related cleanups.
(note that we cannot talk to ssh.com's ssh2 agents)
@
text
@a4 1
 * Created: Sat Mar 18 22:15:47 1995 ylo
d8 5
d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.4 2000/07/16 08:27:22 markus Exp $");
@


1.4
log
@make ssh-add accept dsa keys (the agent does not)
@
text
@d12 1
a12 1
RCSID("$OpenBSD: sshconnect1.c,v 1.3 2000/05/08 17:12:16 markus Exp $");
d47 1
a47 1
	int status, type;
d52 3
a54 1
	BIGNUM *e, *n, *challenge;
a60 2
	e = BN_new();
	n = BN_new();
d62 1
d65 3
a67 4
	for (status = ssh_get_first_identity(auth, e, n, &comment);
	     status;
	     status = ssh_get_next_identity(auth, e, n, &comment)) {
		int plen, clen;
d75 1
a75 1
		packet_put_bignum(n);
d86 1
d101 6
a106 4
		if (!ssh_decrypt_challenge(auth, e, n, challenge,
					   session_id, 1, response)) {
			/* The agent failed to authenticate this identifier although it
			   advertised it supports this.  Just return a wrong value. */
d110 1
d125 1
a126 3
			BN_clear_free(e);
			BN_clear_free(n);
			BN_clear_free(challenge);
a133 3

	BN_clear_free(e);
	BN_clear_free(n);
a134 1

@


1.3
log
@complain about invalid ciphers in SSH1 (e.g. arcfour is SSH2 only)
@
text
@d12 1
a12 1
RCSID("$OpenBSD: sshconnect1.c,v 1.2 2000/05/04 22:38:00 markus Exp $");
a23 1
#include "authfd.h"
d29 1
@


1.3.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d12 1
a12 1
RCSID("$OpenBSD: sshconnect1.c,v 1.5 2000/08/19 21:34:44 markus Exp $");
d24 1
a29 1
#include "authfd.h"
d47 1
a47 1
	int type;
d52 1
a52 3
	int plen, clen;
	Key *key;
	BIGNUM *challenge;
d59 2
a61 1
	key = key_new(KEY_RSA);
d64 4
a67 3
	for (key = ssh_get_first_identity(auth, &comment, 1);
	     key != NULL;
	     key = ssh_get_next_identity(auth, &comment, 1)) {
d75 1
a75 1
		packet_put_bignum(key->rsa->n);
a85 1
			key_free(key);
d100 4
a103 6
		if (!ssh_decrypt_challenge(auth, key, challenge, session_id, 1, response)) {
			/*
			 * The agent failed to authenticate this identifier
			 * although it advertised it supports this.  Just
			 * return a wrong value.
			 */
a106 1
		key_free(key);
d121 3
a124 1
			debug("RSA authentication accepted by server.");
d132 3
d136 1
@


1.3.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d5 1
a8 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d12 1
a12 1
RCSID("$OpenBSD: sshconnect1.c,v 1.8 2000/10/12 09:59:19 markus Exp $");
d24 1
d835 2
a836 2
		    cipher_name(ssh_cipher_default));
		options.cipher = ssh_cipher_default;
d838 1
a838 1
		if (cipher_mask_ssh1(1) & supported_ciphers & (1 << ssh_cipher_default))
d840 6
@


1.3.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.27 2001/02/15 23:19:59 markus Exp $");
d19 2
a22 10
#ifdef KRB4
#include <krb.h>
#endif
#ifdef AFS
#include <kafs.h>
#include "radix.h"
#endif

#include "ssh.h"
#include "ssh1.h"
d25 1
a29 1
#include "log.h"
a34 3
#include "readpass.h"
#include "cipher.h"
#include "canohost.h"
d37 2
a38 2
u_char session_id[16];
u_int supported_authentications = 0;
d48 1
a48 1
try_agent_authentication(void)
d53 2
a54 2
	u_char response[16];
	u_int i;
d65 1
a127 1
			ssh_close_authentication_connection(auth);
a136 1
	ssh_close_authentication_connection(auth);
d149 1
a149 1
	u_char buf[32], response[16];
d154 1
a154 4
	/* XXX think about Bleichenbacher, too */
	if (rsa_private_decrypt(challenge, challenge, prv) <= 0)
		packet_disconnect(
		    "respond_to_rsa_challenge: rsa_private_decrypt failed");
d160 2
a161 2
		packet_disconnect(
		    "respond_to_rsa_challenge: bad challenge length %d", len);
d199 1
a199 1
	public = key_new(KEY_RSA1);
d240 1
a240 1
	private = key_new(KEY_RSA1);
a272 2
			key_free(private);
			BN_clear_free(challenge);
d366 1
a366 1
try_kerberos_authentication(void)
d385 1
a385 1
	strncpy(inst, (char *) krb_get_phost(get_canonical_hostname(1)), INST_SZ);
d387 1
a387 1
	realm = (char *) krb_realmofhost(get_canonical_hostname(1));
d389 1
a389 1
		debug("Kerberos V4: no realm for %s", get_canonical_hostname(1));
d444 1
a444 1
		reply = packet_get_string((u_int *) &auth.length);
d483 1
a483 1
send_kerberos_tgt(void)
d509 1
a509 1
	creds_to_radix(creds, (u_char *)buffer, sizeof buffer);
d548 1
a548 1
		memcpy(&creds.ticket_st.length, p, sizeof(u_int));
d551 1
a551 1
		p += sizeof(u_int);
d577 1
a577 1
		if (creds_to_radix(&creds, (u_char *) buffer, sizeof buffer) <= 0)
d602 1
a602 1
try_challenge_reponse_authentication(void)
d606 1
a606 2
	u_int clen;
	char prompt[1024];
d609 1
a609 1
	debug("Doing challenge reponse authentication.");
d611 23
a634 20
		/* request a challenge */
		packet_start(SSH_CMSG_AUTH_TIS);
		packet_send();
		packet_write_wait();

		type = packet_read(&payload_len);
		if (type != SSH_SMSG_FAILURE &&
		    type != SSH_SMSG_AUTH_TIS_CHALLENGE) {
			packet_disconnect("Protocol error: got %d in response "
			    "to SSH_CMSG_AUTH_TIS", type);
		}
		if (type != SSH_SMSG_AUTH_TIS_CHALLENGE) {
			debug("No challenge.");
			return 0;
		}
		challenge = packet_get_string(&clen);
		packet_integrity_check(payload_len, (4 + clen), type);
		snprintf(prompt, sizeof prompt, "%s%s", challenge,
		     strchr(challenge, '\n') ? "" : "\nResponse: ");
		xfree(challenge);
d637 1
a637 8
		if (options.cipher == SSH_CIPHER_NONE)
			log("WARNING: Encryption is disabled! "
			    "Reponse will be transmitted in clear text.");
		response = read_passphrase(prompt, 0);
		if (strcmp(response, "") == 0) {
			xfree(response);
			break;
		}
d639 1
a639 1
		ssh_put_password(response);
d649 1
a649 1
			    "to SSH_CMSG_AUTH_TIS_RESPONSE", type);
d672 1
a672 1
		ssh_put_password(password);
d701 4
a704 4
	u_char session_key[SSH_SESSION_KEY_LENGTH];
	u_char cookie[8];
	u_int supported_ciphers;
	u_int server_flags, client_flags;
d763 1
a763 1
	k.type = KEY_RSA1;
d836 1
a836 5
	if (options.cipher == SSH_CIPHER_NOT_SET) {
		if (cipher_mask_ssh1(1) & supported_ciphers & (1 << ssh_cipher_default))
			options.cipher = ssh_cipher_default;
	} else if (options.cipher == SSH_CIPHER_ILLEGAL ||
	    !(cipher_mask_ssh1(1) & (1 << options.cipher))) {
d840 3
d892 2
a893 2
    const char *local_user,
    const char *server_user,
d997 1
a997 2
			if (options.identity_files_type[i] == KEY_RSA1 &&
			    try_rsa_authentication(options.identity_files[i]))
d1000 1
a1000 1
	/* Try challenge response authentication if the server supports it. */
d1002 2
a1003 2
	    options.challenge_reponse_authentication && !options.batch_mode) {
		if (try_challenge_reponse_authentication())
d1011 1
a1011 1
		snprintf(prompt, sizeof(prompt), "%.30s@@%.128s's password: ",
@


1.3.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect1.c,v 1.28 2001/03/08 21:42:33 markus Exp $");
d1020 1
a1020 2
			if (options.identity_keys[i] != NULL &&
			    options.identity_keys[i]->type == KEY_RSA1 &&
@


1.2
log
@replace broken uuencode w/ libc b64_ntop
@
text
@d12 1
a12 1
RCSID("$OpenBSD: sshconnect1.c,v 1.1 2000/04/26 21:28:33 markus Exp $");
d835 5
a839 1
	if (options.cipher == SSH_CIPHER_NOT_SET) {
d844 2
a845 2
			      cipher_name(ssh_cipher_default),
			      cipher_name(SSH_FALLBACK_CIPHER));
@


1.1
log
@split auth/sshconnect in one file per protocol version
@
text
@d12 1
a12 1
RCSID("$OpenBSD: sshconnect1.c,v 1.1 2000/04/18 15:01:33 markus Exp $");
d508 1
a508 1
	creds_to_radix(creds, (unsigned char *)buffer);
d576 1
a576 1
		if (!creds_to_radix(&creds, (unsigned char*) buffer))
@

