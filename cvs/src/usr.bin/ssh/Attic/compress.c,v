head	1.27;
access;
symbols
	OPENBSD_5_6:1.26.0.18
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.16
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.12
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.10
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.8
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.6
	OPENBSD_5_0:1.26.0.4
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.25.0.18
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.14
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.16
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.12
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.10
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.8
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.6
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.4
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.21.0.10
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.8
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.6
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.4
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.19.0.8
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.01.19.19.52.16;	author markus;	state dead;
branches;
next	1.26;
commitid	UHlhoIB5NMb8eAPm;

1.26
date	2010.09.08.04.13.31;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2006.08.06.01.13.32;	author stevesk;	state Exp;
branches;
next	1.24;

1.24
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.13.19.45.15;	author markus;	state Exp;
branches
	1.21.8.1
	1.21.10.1;
next	1.20;

1.20
date	2004.01.13.19.23.15;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.18.17.31.54;	author provos;	state Exp;
branches
	1.19.6.1
	1.19.8.1;
next	1.18;

1.18
date	2002.03.16.11.24.53;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.29.21.56.01;	author stevesk;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.27.11.58.16;	author markus;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.04.05.10.39.01;	author markus;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.02.08.19.30.51;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.21.19.05.48;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.20.19.37.21;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.19.23.17.56;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.07.20.27.50;	author deraadt;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.06.20.01.39.40;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.14.10.30.31;	author markus;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.03.28.20.25.14;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.16.20.56.14;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	99.11.24.19.53.46;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	99.11.24.00.26.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.11.23.22.25.53;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.34;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	2000.09.01.18.23.19;	author jason;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2000.11.08.21.30.39;	author jason;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.03.12.15.44.09;	author jason;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2001.03.21.18.52.43;	author jason;	state Exp;
branches;
next	;

1.9.2.1
date	2001.02.16.20.13.00;	author jason;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.02.19.17.18.50;	author jason;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.03.21.19.46.24;	author jason;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2001.05.07.21.09.28;	author jason;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2001.11.15.00.14.59;	author miod;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.14.2.1
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.15.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	;

1.19.6.1
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.19.8.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	;

1.21.8.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.21.10.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.27
log
@update packet.c & isolate, introduce struct ssh
a) switch packet.c to buffer api and isolate per-connection info into struct ssh
b) (de)serialization of the state is moved from monitor to packet.c
c) the old packet.c API is implemented in opacket.[ch]
d) compress.c/h is removed and integrated into packet.c
with and ok djm@@
@
text
@/* $OpenBSD: compress.c,v 1.26 2010/09/08 04:13:31 deraadt Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Interface to packet compression for ssh.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>

#include <stdarg.h>

#include "log.h"
#include "buffer.h"
#include "compress.h"

#include <zlib.h>

z_stream incoming_stream;
z_stream outgoing_stream;
static int compress_init_send_called = 0;
static int compress_init_recv_called = 0;
static int inflate_failed = 0;
static int deflate_failed = 0;

/*
 * Initializes compression; level is compression level from 1 to 9
 * (as in gzip).
 */

void
buffer_compress_init_send(int level)
{
	if (compress_init_send_called == 1)
		deflateEnd(&outgoing_stream);
	compress_init_send_called = 1;
	debug("Enabling compression at level %d.", level);
	if (level < 1 || level > 9)
		fatal("Bad compression level %d.", level);
	deflateInit(&outgoing_stream, level);
}
void
buffer_compress_init_recv(void)
{
	if (compress_init_recv_called == 1)
		inflateEnd(&incoming_stream);
	compress_init_recv_called = 1;
	inflateInit(&incoming_stream);
}

/* Frees any data structures allocated for compression. */

void
buffer_compress_uninit(void)
{
	debug("compress outgoing: raw data %llu, compressed %llu, factor %.2f",
	    (unsigned long long)outgoing_stream.total_in,
	    (unsigned long long)outgoing_stream.total_out,
	    outgoing_stream.total_in == 0 ? 0.0 :
	    (double) outgoing_stream.total_out / outgoing_stream.total_in);
	debug("compress incoming: raw data %llu, compressed %llu, factor %.2f",
	    (unsigned long long)incoming_stream.total_out,
	    (unsigned long long)incoming_stream.total_in,
	    incoming_stream.total_out == 0 ? 0.0 :
	    (double) incoming_stream.total_in / incoming_stream.total_out);
	if (compress_init_recv_called == 1 && inflate_failed == 0)
		inflateEnd(&incoming_stream);
	if (compress_init_send_called == 1 && deflate_failed == 0)
		deflateEnd(&outgoing_stream);
}

/*
 * Compresses the contents of input_buffer into output_buffer.  All packets
 * compressed using this function will form a single compressed data stream;
 * however, data will be flushed at the end of every call so that each
 * output_buffer can be decompressed independently (but in the appropriate
 * order since they together form a single compression stream) by the
 * receiver.  This appends the compressed data to the output buffer.
 */

void
buffer_compress(Buffer * input_buffer, Buffer * output_buffer)
{
	u_char buf[4096];
	int status;

	/* This case is not handled below. */
	if (buffer_len(input_buffer) == 0)
		return;

	/* Input is the contents of the input buffer. */
	outgoing_stream.next_in = buffer_ptr(input_buffer);
	outgoing_stream.avail_in = buffer_len(input_buffer);

	/* Loop compressing until deflate() returns with avail_out != 0. */
	do {
		/* Set up fixed-size output buffer. */
		outgoing_stream.next_out = buf;
		outgoing_stream.avail_out = sizeof(buf);

		/* Compress as much data into the buffer as possible. */
		status = deflate(&outgoing_stream, Z_PARTIAL_FLUSH);
		switch (status) {
		case Z_OK:
			/* Append compressed data to output_buffer. */
			buffer_append(output_buffer, buf,
			    sizeof(buf) - outgoing_stream.avail_out);
			break;
		default:
			deflate_failed = 1;
			fatal("buffer_compress: deflate returned %d", status);
			/* NOTREACHED */
		}
	} while (outgoing_stream.avail_out == 0);
}

/*
 * Uncompresses the contents of input_buffer into output_buffer.  All packets
 * uncompressed using this function will form a single compressed data
 * stream; however, data will be flushed at the end of every call so that
 * each output_buffer.  This must be called for the same size units that the
 * buffer_compress was called, and in the same order that buffers compressed
 * with that.  This appends the uncompressed data to the output buffer.
 */

void
buffer_uncompress(Buffer * input_buffer, Buffer * output_buffer)
{
	u_char buf[4096];
	int status;

	incoming_stream.next_in = buffer_ptr(input_buffer);
	incoming_stream.avail_in = buffer_len(input_buffer);

	for (;;) {
		/* Set up fixed-size output buffer. */
		incoming_stream.next_out = buf;
		incoming_stream.avail_out = sizeof(buf);

		status = inflate(&incoming_stream, Z_PARTIAL_FLUSH);
		switch (status) {
		case Z_OK:
			buffer_append(output_buffer, buf,
			    sizeof(buf) - incoming_stream.avail_out);
			break;
		case Z_BUF_ERROR:
			/*
			 * Comments in zlib.h say that we should keep calling
			 * inflate() until we get an error.  This appears to
			 * be the error that we get.
			 */
			return;
		default:
			inflate_failed = 1;
			fatal("buffer_uncompress: inflate returned %d", status);
			/* NOTREACHED */
		}
	}
}
@


1.26
log
@work around name-space collisions some buggy compilers (looking at you
gcc, at least in earlier versions, but this does not forgive your current
transgressions) seen between zlib and openssl
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: compress.c,v 1.25 2006/08/06 01:13:32 stevesk Exp $ */
@


1.25
log
@"zlib.h" can be <zlib.h>; ok djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: compress.c,v 1.24 2006/08/03 03:34:42 deraadt Exp $ */
a17 1
#include <zlib.h>
d22 2
@


1.24
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: compress.c,v 1.23 2006/03/25 13:17:01 djm Exp $ */
d18 1
a21 1
#include "zlib.h"
@


1.23
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d15 3
a17 1
#include "includes.h"
@


1.22
log
@RCSID() can die
@
text
@d1 1
@


1.21
log
@cast for portability; millert@@
@
text
@a14 1
RCSID("$OpenBSD: compress.c,v 1.20 2004/01/13 19:23:15 markus Exp $");
@


1.21.8.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: compress.c,v 1.25 2006/08/06 01:13:32 stevesk Exp $ */
d14 2
a15 4
#include <sys/types.h>

#include <stdarg.h>
#include <zlib.h>
d19 1
@


1.21.10.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: compress.c,v 1.25 2006/08/06 01:13:32 stevesk Exp $ */
d14 2
a15 4
#include <sys/types.h>

#include <stdarg.h>
#include <zlib.h>
d19 1
@


1.20
log
@-Wall; ok henning
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.19 2002/03/18 17:31:54 provos Exp $");
d60 2
a61 1
	    outgoing_stream.total_in, outgoing_stream.total_out,
d65 2
a66 1
	    incoming_stream.total_out, incoming_stream.total_in,
@


1.19
log
@export compression streams for ssh-privsep
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.18 2002/03/16 11:24:53 markus Exp $");
d59 1
a59 1
	debug("compress outgoing: raw data %lu, compressed %lu, factor %.2f",
d63 1
a63 1
	debug("compress incoming: raw data %lu, compressed %lu, factor %.2f",
@


1.19.6.1
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.21 2004/01/13 19:45:15 markus Exp $");
d59 2
a60 3
	debug("compress outgoing: raw data %llu, compressed %llu, factor %.2f",
	    (unsigned long long)outgoing_stream.total_in,
	    (unsigned long long)outgoing_stream.total_out,
d63 2
a64 3
	debug("compress incoming: raw data %llu, compressed %llu, factor %.2f",
	    (unsigned long long)incoming_stream.total_out,
	    (unsigned long long)incoming_stream.total_in,
@


1.19.8.1
log
@upgrade to OpenSSH 3.8
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.21 2004/01/13 19:45:15 markus Exp $");
d59 2
a60 3
	debug("compress outgoing: raw data %llu, compressed %llu, factor %.2f",
	    (unsigned long long)outgoing_stream.total_in,
	    (unsigned long long)outgoing_stream.total_out,
d63 2
a64 3
	debug("compress incoming: raw data %llu, compressed %llu, factor %.2f",
	    (unsigned long long)incoming_stream.total_out,
	    (unsigned long long)incoming_stream.total_in,
@


1.18
log
@skip inflateEnd if inflate fails; ok provos@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.17 2001/12/29 21:56:01 stevesk Exp $");
d22 2
a23 2
static z_stream incoming_stream;
static z_stream outgoing_stream;
@


1.17
log
@remove unneeded casts and some char->u_char cleanup; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.16 2001/12/19 07:18:56 deraadt Exp $");
d26 2
d67 1
a67 1
	if (compress_init_recv_called == 1)
d69 1
a69 1
	if (compress_init_send_called == 1)
d111 1
d155 1
@


1.16
log
@basic KNF done while i was looking for something else
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.15 2001/09/27 11:58:16 markus Exp $");
d83 1
a83 1
	char buf[4096];
d91 1
a91 1
	outgoing_stream.next_in = (u_char *) buffer_ptr(input_buffer);
d97 1
a97 1
		outgoing_stream.next_out = (u_char *)buf;
d127 1
a127 1
	char buf[4096];
d130 1
a130 1
	incoming_stream.next_in = (u_char *) buffer_ptr(input_buffer);
d135 1
a135 1
		incoming_stream.next_out = (u_char *) buf;
@


1.15
log
@mem leak; chombier@@mac.com
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.14 2001/04/05 10:39:01 markus Exp $");
d58 3
a60 3
	      outgoing_stream.total_in, outgoing_stream.total_out,
	      outgoing_stream.total_in == 0 ? 0.0 :
	      (double) outgoing_stream.total_out / outgoing_stream.total_in);
d62 3
a64 3
	      incoming_stream.total_out, incoming_stream.total_in,
	      incoming_stream.total_out == 0 ? 0.0 :
	      (double) incoming_stream.total_in / incoming_stream.total_out);
@


1.15.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.17 2001/12/29 21:56:01 stevesk Exp $");
d58 3
a60 3
	    outgoing_stream.total_in, outgoing_stream.total_out,
	    outgoing_stream.total_in == 0 ? 0.0 :
	    (double) outgoing_stream.total_out / outgoing_stream.total_in);
d62 3
a64 3
	    incoming_stream.total_out, incoming_stream.total_in,
	    incoming_stream.total_out == 0 ? 0.0 :
	    (double) incoming_stream.total_in / incoming_stream.total_out);
d83 1
a83 1
	u_char buf[4096];
d91 1
a91 1
	outgoing_stream.next_in = buffer_ptr(input_buffer);
d97 1
a97 1
		outgoing_stream.next_out = buf;
d127 1
a127 1
	u_char buf[4096];
d130 1
a130 1
	incoming_stream.next_in = buffer_ptr(input_buffer);
d135 1
a135 1
		incoming_stream.next_out = buf;
@


1.15.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.19 2002/03/18 17:31:54 provos Exp $");
d22 2
a23 2
z_stream incoming_stream;
z_stream outgoing_stream;
a25 2
static int inflate_failed = 0;
static int deflate_failed = 0;
d65 1
a65 1
	if (compress_init_recv_called == 1 && inflate_failed == 0)
d67 1
a67 1
	if (compress_init_send_called == 1 && deflate_failed == 0)
a108 1
			deflate_failed = 1;
a151 1
			inflate_failed = 1;
@


1.14
log
@reset compress state per direction when rekeying.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.13 2001/02/08 19:30:51 itojun Exp $");
d36 1
a36 1
		deflateEnd(&incoming_stream);
@


1.14.2.1
log
@Merge OpenSSH 3.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.14 2001/04/05 10:39:01 markus Exp $");
d36 1
a36 1
		deflateEnd(&outgoing_stream);
@


1.14.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.17 2001/12/29 21:56:01 stevesk Exp $");
d58 3
a60 3
	    outgoing_stream.total_in, outgoing_stream.total_out,
	    outgoing_stream.total_in == 0 ? 0.0 :
	    (double) outgoing_stream.total_out / outgoing_stream.total_in);
d62 3
a64 3
	    incoming_stream.total_out, incoming_stream.total_in,
	    incoming_stream.total_out == 0 ? 0.0 :
	    (double) incoming_stream.total_in / incoming_stream.total_out);
d83 1
a83 1
	u_char buf[4096];
d91 1
a91 1
	outgoing_stream.next_in = buffer_ptr(input_buffer);
d97 1
a97 1
		outgoing_stream.next_out = buf;
d127 1
a127 1
	u_char buf[4096];
d130 1
a130 1
	incoming_stream.next_in = buffer_ptr(input_buffer);
d135 1
a135 1
		incoming_stream.next_out = buf;
@


1.14.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.19 2002/03/18 17:31:54 provos Exp $");
d22 2
a23 2
z_stream incoming_stream;
z_stream outgoing_stream;
a25 2
static int inflate_failed = 0;
static int deflate_failed = 0;
d65 1
a65 1
	if (compress_init_recv_called == 1 && inflate_failed == 0)
d67 1
a67 1
	if (compress_init_send_called == 1 && deflate_failed == 0)
a108 1
			deflate_failed = 1;
a151 1
			inflate_failed = 1;
@


1.13
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.12 2001/01/21 19:05:48 markus Exp $");
d24 2
d33 1
a33 1
buffer_compress_init(int level)
d35 3
d41 8
a49 1
	deflateInit(&outgoing_stream, level);
d65 4
a68 2
	inflateEnd(&incoming_stream);
	deflateEnd(&outgoing_stream);
@


1.12
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.11 2000/12/20 19:37:21 markus Exp $");
d20 1
@


1.11
log
@fix prototypes; from  stevesk@@pobox.com
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.10 2000/12/19 23:17:56 markus Exp $");
d17 1
a17 1
#include "ssh.h"
@


1.10
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.9 2000/09/07 20:27:50 deraadt Exp $");
d42 1
a42 1
buffer_compress_uninit()
@


1.9
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.8 2000/06/20 01:39:40 markus Exp $");
d76 1
a76 1
	outgoing_stream.next_in = (unsigned char *) buffer_ptr(input_buffer);
d82 1
a82 1
		outgoing_stream.next_out = (unsigned char *)buf;
d115 1
a115 1
	incoming_stream.next_in = (unsigned char *) buffer_ptr(input_buffer);
d120 1
a120 1
		incoming_stream.next_out = (unsigned char *) buf;
@


1.9.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.13 2001/02/08 19:30:51 itojun Exp $");
d17 1
a17 1
#include "log.h"
a19 1
#include "compress.h"
d42 1
a42 1
buffer_compress_uninit(void)
d76 1
a76 1
	outgoing_stream.next_in = (u_char *) buffer_ptr(input_buffer);
d82 1
a82 1
		outgoing_stream.next_out = (u_char *)buf;
d115 1
a115 1
	incoming_stream.next_in = (u_char *) buffer_ptr(input_buffer);
d120 1
a120 1
		incoming_stream.next_out = (u_char *) buf;
@


1.9.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.9.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.9.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.14 2001/04/05 10:39:01 markus Exp $");
a23 2
static int compress_init_send_called = 0;
static int compress_init_recv_called = 0;
d31 1
a31 1
buffer_compress_init_send(int level)
a32 3
	if (compress_init_send_called == 1)
		deflateEnd(&incoming_stream);
	compress_init_send_called = 1;
d36 1
a38 8
void
buffer_compress_init_recv(void)
{
	if (compress_init_recv_called == 1)
		inflateEnd(&incoming_stream);
	compress_init_recv_called = 1;
	inflateInit(&incoming_stream);
}
d53 2
a54 4
	if (compress_init_recv_called == 1)
		inflateEnd(&incoming_stream);
	if (compress_init_send_called == 1)
		deflateEnd(&outgoing_stream);
@


1.9.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@@


1.9.2.6
log
@Merge OpenSSH 3.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.9.2.5 2001/09/27 00:15:41 miod Exp $");
d36 1
a36 1
		deflateEnd(&outgoing_stream);
@


1.9.2.7
log
@Merge OpenSSH 3.1.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.17 2001/12/29 21:56:01 stevesk Exp $");
d58 3
a60 3
	    outgoing_stream.total_in, outgoing_stream.total_out,
	    outgoing_stream.total_in == 0 ? 0.0 :
	    (double) outgoing_stream.total_out / outgoing_stream.total_in);
d62 3
a64 3
	    incoming_stream.total_out, incoming_stream.total_in,
	    incoming_stream.total_out == 0 ? 0.0 :
	    (double) incoming_stream.total_in / incoming_stream.total_out);
d83 1
a83 1
	u_char buf[4096];
d91 1
a91 1
	outgoing_stream.next_in = buffer_ptr(input_buffer);
d97 1
a97 1
		outgoing_stream.next_out = buf;
d127 1
a127 1
	u_char buf[4096];
d130 1
a130 1
	incoming_stream.next_in = buffer_ptr(input_buffer);
d135 1
a135 1
		incoming_stream.next_out = buf;
@


1.8
log
@OpenBSD tag
@
text
@a1 3
 *
 * compress.c
 *
a2 1
 *
a4 3
 *
 * Created: Wed Oct 25 22:12:46 1995 ylo
 *
d7 5
d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.7 2000/04/14 10:30:31 markus Exp $");
@


1.7
log
@whitespace cleanup
@
text
@d17 1
a17 1
RCSID("$Id: compress.c,v 1.6 2000/03/28 20:25:14 markus Exp $");
@


1.7.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d17 1
a17 1
RCSID("$OpenBSD: compress.c,v 1.8 2000/06/20 01:39:40 markus Exp $");
@


1.7.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a13 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d17 1
a17 1
RCSID("$OpenBSD: compress.c,v 1.9 2000/09/07 20:27:50 deraadt Exp $");
@


1.7.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d15 1
a15 1
RCSID("$OpenBSD: compress.c,v 1.13 2001/02/08 19:30:51 itojun Exp $");
d17 1
a17 1
#include "log.h"
a19 1
#include "compress.h"
d42 1
a42 1
buffer_compress_uninit(void)
d76 1
a76 1
	outgoing_stream.next_in = (u_char *) buffer_ptr(input_buffer);
d82 1
a82 1
		outgoing_stream.next_out = (u_char *)buf;
d115 1
a115 1
	incoming_stream.next_in = (u_char *) buffer_ptr(input_buffer);
d120 1
a120 1
		incoming_stream.next_out = (u_char *) buf;
@


1.7.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.6
log
@cleanup, less code
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
RCSID("$Id: compress.c,v 1.6 2000/03/22 13:40:45 markus Exp $");
d31 1
a31 1
void 
d43 1
a43 1
void 
d67 1
a67 1
void 
d111 1
a111 1
void 
@


1.5
log
@-pedantic: signed vs. unsigned, void*-arithm, etc
@
text
@d17 1
a17 1
RCSID("$Id: compress.c,v 1.4 1999/11/24 19:53:46 markus Exp $");
d93 1
a93 1
				      sizeof(buf) - outgoing_stream.avail_out);
a94 9
		case Z_STREAM_END:
			fatal("buffer_compress: deflate returned Z_STREAM_END");
			/* NOTREACHED */
		case Z_STREAM_ERROR:
			fatal("buffer_compress: deflate returned Z_STREAM_ERROR");
			/* NOTREACHED */
		case Z_BUF_ERROR:
			fatal("buffer_compress: deflate returned Z_BUF_ERROR");
			/* NOTREACHED */
d99 1
a99 2
	}
	while (outgoing_stream.avail_out == 0);
d120 4
a123 2
	incoming_stream.next_out = (unsigned char *) buf;
	incoming_stream.avail_out = sizeof(buf);
a124 1
	for (;;) {
d129 1
a129 3
				      sizeof(buf) - incoming_stream.avail_out);
			incoming_stream.next_out = (unsigned char *) buf;
			incoming_stream.avail_out = sizeof(buf);
a130 9
		case Z_STREAM_END:
			fatal("buffer_uncompress: inflate returned Z_STREAM_END");
			/* NOTREACHED */
		case Z_DATA_ERROR:
			fatal("buffer_uncompress: inflate returned Z_DATA_ERROR");
			/* NOTREACHED */
		case Z_STREAM_ERROR:
			fatal("buffer_uncompress: inflate returned Z_STREAM_ERROR");
			/* NOTREACHED */
a137 3
		case Z_MEM_ERROR:
			fatal("buffer_uncompress: inflate returned Z_MEM_ERROR");
			/* NOTREACHED */
d140 1
@


1.4
log
@KNF, final part 3
@
text
@d17 1
a17 1
RCSID("$Id: compress.c,v 1.3 1999/11/24 00:26:01 deraadt Exp $");
d78 1
a78 1
	outgoing_stream.next_in = buffer_ptr(input_buffer);
d84 1
a84 1
		outgoing_stream.next_out = buf;
d127 1
a127 1
	incoming_stream.next_in = buffer_ptr(input_buffer);
d130 1
a130 1
	incoming_stream.next_out = buf;
d139 1
a139 1
			incoming_stream.next_out = buf;
@


1.3
log
@much more KNF
@
text
@d17 1
a17 1
RCSID("$Id: compress.c,v 1.2 1999/11/23 22:25:53 markus Exp $");
d26 4
a29 2
/* Initializes compression; level is compression level from 1 to 9
   (as in gzip). */
d58 8
a65 7
/* Compresses the contents of input_buffer into output_buffer.  All
   packets compressed using this function will form a single
   compressed data stream; however, data will be flushed at the end of
   every call so that each output_buffer can be decompressed
   independently (but in the appropriate order since they together
   form a single compression stream) by the receiver.  This appends
   the compressed data to the output buffer. */
d112 8
a119 7
/* Uncompresses the contents of input_buffer into output_buffer.  All
   packets uncompressed using this function will form a single
   compressed data stream; however, data will be flushed at the end of
   every call so that each output_buffer.  This must be called for the
   same size units that the buffer_compress was called, and in the
   same order that buffers compressed with that.  This appends the
   uncompressed data to the output buffer. */
d152 5
a156 3
			/* Comments in zlib.h say that we should keep
			   calling inflate() until we get an error.  This
			   appears to be the error that we get. */
@


1.2
log
@KNF part 1
@
text
@d2 13
a14 13

compress.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Wed Oct 25 22:12:46 1995 ylo

Interface to packet compression for ssh.

*/
d17 1
a17 1
RCSID("$Id: compress.c,v 1.1 1999/09/26 20:53:34 deraadt Exp $");
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d17 1
a17 1
RCSID("$Id: compress.c,v 1.2 1999/05/04 11:58:38 bg Exp $");
d26 2
a27 2
/* Initializes compression; level is compression level from 1 to 9 (as in
   gzip). */
d29 2
a30 1
void buffer_compress_init(int level)
d32 5
a36 5
  debug("Enabling compression at level %d.", level);
  if (level < 1 || level > 9)
    fatal("Bad compression level %d.", level);
  inflateInit(&incoming_stream);
  deflateInit(&outgoing_stream, level);
d41 2
a42 1
void buffer_compress_uninit()
d44 10
a53 10
  debug("compress outgoing: raw data %lu, compressed %lu, factor %.2f",
	outgoing_stream.total_in, outgoing_stream.total_out,
	outgoing_stream.total_in == 0 ? 0.0 :
	 (double)outgoing_stream.total_out / outgoing_stream.total_in);
  debug("compress incoming: raw data %lu, compressed %lu, factor %.2f",
	incoming_stream.total_out, incoming_stream.total_in,
	incoming_stream.total_out == 0 ? 0.0 :
	  (double)incoming_stream.total_in / incoming_stream.total_out);
  inflateEnd(&incoming_stream);
  deflateEnd(&outgoing_stream);
d64 2
a65 1
void buffer_compress(Buffer *input_buffer, Buffer *output_buffer)
d67 2
a68 2
  char buf[4096];
  int status;
d70 35
a104 36
  /* This case is not handled below. */
  if (buffer_len(input_buffer) == 0)
    return;

  /* Input is the contents of the input buffer. */
  outgoing_stream.next_in = buffer_ptr(input_buffer);
  outgoing_stream.avail_in = buffer_len(input_buffer);

  /* Loop compressing until deflate() returns with avail_out != 0. */
  do
    {
      /* Set up fixed-size output buffer. */
      outgoing_stream.next_out = buf;
      outgoing_stream.avail_out = sizeof(buf);

      /* Compress as much data into the buffer as possible. */
      status = deflate(&outgoing_stream, Z_PARTIAL_FLUSH);
      switch (status)
	{
	case Z_OK:
	  /* Append compressed data to output_buffer. */
	  buffer_append(output_buffer, buf,
			sizeof(buf) - outgoing_stream.avail_out);
	  break;
	case Z_STREAM_END:
	  fatal("buffer_compress: deflate returned Z_STREAM_END");
	  /*NOTREACHED*/
	case Z_STREAM_ERROR:
	  fatal("buffer_compress: deflate returned Z_STREAM_ERROR");
	  /*NOTREACHED*/
	case Z_BUF_ERROR:
	  fatal("buffer_compress: deflate returned Z_BUF_ERROR");
	  /*NOTREACHED*/
	default:
	  fatal("buffer_compress: deflate returned %d", status);
	  /*NOTREACHED*/
d106 1
a106 2
    }
  while (outgoing_stream.avail_out == 0);
d117 2
a118 1
void buffer_uncompress(Buffer *input_buffer, Buffer *output_buffer)
d120 2
a121 2
  char buf[4096];
  int status;
d123 2
a124 2
  incoming_stream.next_in = buffer_ptr(input_buffer);
  incoming_stream.avail_in = buffer_len(input_buffer);
d126 2
a127 2
  incoming_stream.next_out = buf;
  incoming_stream.avail_out = sizeof(buf);
d129 29
a157 30
  for (;;)
    {
      status = inflate(&incoming_stream, Z_PARTIAL_FLUSH);
      switch (status)
	{
	case Z_OK:
	  buffer_append(output_buffer, buf,
			sizeof(buf) - incoming_stream.avail_out);
	  incoming_stream.next_out = buf;
	  incoming_stream.avail_out = sizeof(buf);
	  break;
	case Z_STREAM_END:
	  fatal("buffer_uncompress: inflate returned Z_STREAM_END");
	  /*NOTREACHED*/
	case Z_DATA_ERROR:
	  fatal("buffer_uncompress: inflate returned Z_DATA_ERROR");
	  /*NOTREACHED*/
	case Z_STREAM_ERROR:
	  fatal("buffer_uncompress: inflate returned Z_STREAM_ERROR");
	  /*NOTREACHED*/
	case Z_BUF_ERROR:
	  /* Comments in zlib.h say that we should keep calling inflate()
	     until we get an error.  This appears to be the error that we
	     get. */
	  return;
	case Z_MEM_ERROR:
	  fatal("buffer_uncompress: inflate returned Z_MEM_ERROR");
	  /*NOTREACHED*/
	default:
	  fatal("buffer_uncompress: inflate returned %d", status);
a158 1
    }
a159 1

@

