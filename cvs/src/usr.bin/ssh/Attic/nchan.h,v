head	1.13;
access;
symbols
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.13
date	2001.05.30.12.55.11;	author markus;	state dead;
branches;
next	1.12;

1.12
date	2001.05.28.23.14.50;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.04.23.47.34;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.28.08.54.55;	author markus;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.09.07.20.27.52;	author deraadt;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.06.20.01.39.43;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.03.07.07.15;	author markus;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.03.28.20.31.27;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	99.11.24.16.15.25;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	99.11.24.00.26.02;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.10.17.16.56.09;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	99.10.16.22.29.01;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	99.10.16.20.47.14;	author markus;	state Exp;
branches;
next	;

1.7.2.1
date	2000.09.01.18.23.21;	author jason;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2000.11.08.21.31.00;	author jason;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.03.12.15.44.12;	author jason;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2001.03.21.18.52.54;	author jason;	state Exp;
branches;
next	;

1.9.2.1
date	2001.03.21.19.46.26;	author jason;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.05.07.21.09.31;	author jason;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.09.27.00.15.42;	author miod;	state dead;
branches;
next	;

1.10.2.1
date	2001.09.27.19.03.54;	author jason;	state dead;
branches;
next	;


desc
@@


1.13
log
@channel layer cleanup: merge header files and split .c files
@
text
@/*
 * Copyright (c) 1999 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* RCSID("$OpenBSD: nchan.h,v 1.12 2001/05/28 23:14:50 markus Exp $"); */

#ifndef NCHAN_H
#define NCHAN_H

/*
 * SSH Protocol 1.5 aka New Channel Protocol
 * Thanks to Martina, Axel and everyone who left Erlangen, leaving me bored.
 * Written by Markus Friedl in October 1999
 *
 * Protocol versions 1.3 and 1.5 differ in the handshake protocol used for the
 * tear down of channels:
 *
 * 1.3:	strict request-ack-protocol:
 * 	CLOSE	->
 * 		<-  CLOSE_CONFIRM
 *
 * 1.5:	uses variations of:
 * 	IEOF	->
 * 		<-  OCLOSE
 * 		<-  IEOF
 * 	OCLOSE	->
 * 	i.e. both sides have to close the channel
 *
 * See the debugging output from 'ssh -v' and 'sshd -d' of
 * ssh-1.2.27 as an example.
 *
 */

/* ssh-proto-1.5 overloads prot-1.3-message-types */
#define SSH_MSG_CHANNEL_INPUT_EOF	SSH_MSG_CHANNEL_CLOSE
#define SSH_MSG_CHANNEL_OUTPUT_CLOSE	SSH_MSG_CHANNEL_CLOSE_CONFIRMATION

/* possible input states */
#define CHAN_INPUT_OPEN			0x01
#define CHAN_INPUT_WAIT_DRAIN		0x02
#define CHAN_INPUT_WAIT_OCLOSE		0x04
#define CHAN_INPUT_CLOSED		0x08

/* possible output states */
#define CHAN_OUTPUT_OPEN		0x10
#define CHAN_OUTPUT_WAIT_DRAIN		0x20
#define CHAN_OUTPUT_WAIT_IEOF		0x40
#define CHAN_OUTPUT_CLOSED		0x80

#define CHAN_CLOSE_SENT			0x01
#define CHAN_CLOSE_RCVD			0x02

/* Channel EVENTS */
typedef void    chan_event_fn(Channel * c);

/* for the input state */
extern chan_event_fn	*chan_rcvd_oclose;
extern chan_event_fn	*chan_read_failed;
extern chan_event_fn	*chan_ibuf_empty;

/* for the output state */
extern chan_event_fn	*chan_rcvd_ieof;
extern chan_event_fn	*chan_write_failed;
extern chan_event_fn	*chan_obuf_empty;

int chan_is_dead(Channel * c);
void chan_mark_dead(Channel * c);

void    chan_init_iostates(Channel * c);
void	chan_init(void);
#endif
@


1.12
log
@undo broken channel fix and try a different one. there
should be still some select errors...
@
text
@d25 1
a25 1
/* RCSID("$OpenBSD: nchan.h,v 1.11 2001/05/04 23:47:34 markus Exp $"); */
@


1.11
log
@move to Channel **channels (instead of Channel *channels), fixes realloc problems.
channel_new now returns a Channel *, favour Channel * over channel id.
remove old channel_allocate interface.
@
text
@d25 1
a25 1
/* RCSID("$OpenBSD: nchan.h,v 1.10 2001/02/28 08:54:55 markus Exp $"); */
a71 2
#define CHAN_DEAD			0x04

@


1.10
log
@make sure remote stderr does not get truncated.
remove closed fd's from the select mask.
@
text
@d25 1
a25 1
/* RCSID("$OpenBSD: nchan.h,v 1.9 2000/09/07 20:27:52 deraadt Exp $"); */
d72 1
d89 1
@


1.10.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d25 1
a25 1
/* RCSID("$OpenBSD: nchan.h,v 1.10 2001/02/28 08:54:55 markus Exp $"); */
@


1.9
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d25 1
a25 1
/* RCSID("$OpenBSD: nchan.h,v 1.8 2000/06/20 01:39:43 markus Exp $"); */
d87 1
a87 1
extern chan_event_fn	*chan_delete_if_full_closed;
@


1.9.2.1
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d25 1
a25 1
/* RCSID("$OpenBSD: nchan.h,v 1.10 2001/02/28 08:54:55 markus Exp $"); */
d87 1
a87 1
int chan_is_dead(Channel * c);
@


1.9.2.2
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.9.2.3
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d25 1
a25 1
/* RCSID("$OpenBSD: nchan.h,v 1.9.2.2 2001/05/07 21:09:31 jason Exp $"); */
@


1.8
log
@OpenBSD tag
@
text
@a11 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Markus Friedl.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d25 1
a25 1
/* RCSID("$OpenBSD: nchan.h,v 1.7 2000/04/03 07:07:15 markus Exp $"); */
@


1.7
log
@channel layer support for ssh2
@
text
@d30 1
a30 1
/* RCSID("$Id: nchan.h,v 1.6 2000/03/28 20:31:27 markus Exp $"); */
@


1.7.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d30 1
a30 1
/* RCSID("$OpenBSD: nchan.h,v 1.8 2000/06/20 01:39:43 markus Exp $"); */
@


1.7.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d12 5
d30 1
a30 1
/* RCSID("$OpenBSD: nchan.h,v 1.9 2000/09/07 20:27:52 deraadt Exp $"); */
@


1.7.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@@


1.7.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d25 1
a25 1
/* RCSID("$OpenBSD: nchan.h,v 1.10 2001/02/28 08:54:55 markus Exp $"); */
d87 1
a87 1
int chan_is_dead(Channel * c);
@


1.6
log
@replace big switch() with function tables (prepare for ssh2)
@
text
@d30 1
a30 1
/* RCSID("$Id: nchan.h,v 1.5 1999/11/24 16:15:25 markus Exp $"); */
d75 18
a92 9
/* EVENTS for the input state */
void    chan_rcvd_oclose(Channel * c);
void    chan_read_failed(Channel * c);
void    chan_ibuf_empty(Channel * c);

/* EVENTS for the output state */
void    chan_rcvd_ieof(Channel * c);
void    chan_write_failed(Channel * c);
void    chan_obuf_empty(Channel * c);
d95 1
a95 2

void	chan_delete_if_full_closed(Channel *c);
@


1.5
log
@missing copyright
@
text
@d30 1
a30 1
/* RCSID("$Id: nchan.h,v 1.3 1999/10/17 16:56:09 markus Exp $"); */
d86 2
@


1.4
log
@much more KNF
@
text
@d1 29
@


1.3
log
@re-implement the proto-1.5 channel close protocol, see nchan.ms.
@
text
@d1 1
a1 1
/* RCSID("$Id: nchan.h,v 1.2 1999/10/16 22:29:01 markus Exp $"); */
d10 1
a10 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
 * 
d24 1
a24 1
 * 
d27 1
a27 1
 * 
d47 3
a49 3
void chan_rcvd_oclose(Channel *c);
void chan_read_failed(Channel *c);
void chan_ibuf_empty(Channel *c);
d52 3
a54 3
void chan_rcvd_ieof(Channel *c);
void chan_write_failed(Channel *c);
void chan_obuf_empty(Channel *c);
d56 1
a56 1
void chan_init_iostates(Channel *c);
@


1.2
log
@add CVS tags, fix comments and whitespace
@
text
@d1 1
a1 1
/* RCSID("$Id: servconf.h,v 1.9 1999/10/12 18:11:54 markus Exp $"); */
a27 27
 * Details: (for Channel data structure see channels.h)
 * 
 * - the output_buffer gets data received from the remote peer and
 *   is written to the socket,
 * - the input_buffer gets data from the socket and is sent to remote peer.
 * - the socket represents the local object communicating with an object
 *   reachable via the peer
 * 
 * 	PEER A					PEER B
 * 
 * read(sock, input_buffer) < 0;
 * shutdown_read();
 * flush(input_buffer) =: DATA
 * send(DATA)			->      rcvd(DATA)
 * 					write(sock, output_buffer:=DATA);
 * send(IEOF)			->	rcvd(IEOF)
 * 					shutdown_write() if:
 * 						a) write fails
 * 						b) rcvd_IEOF==true &&
 * 						   output_buffer==empty
 * rcvd(OCLOSE)			<-	send(OCLOSE)
 *
 * The channel is now half closed. No data will flow from A to B.
 *
 * Note that each side can remove the channel only if 2 messages
 * have been sent and received and the associated socket has been
 * shutdown, see below:
d30 15
a44 20
enum {
	/* ssh-proto-1.5 overloads message-types */
	CHAN_IEOF   = SSH_MSG_CHANNEL_CLOSE,
			/* there will be no more data from sender */
	CHAN_OCLOSE = SSH_MSG_CHANNEL_CLOSE_CONFIRMATION,
			/* all received data has been written to the socket */

	/* channel close flags */
	CHAN_IEOF_SENT 		= 0x01,
	CHAN_IEOF_RCVD 		= 0x02,
	CHAN_OCLOSE_SENT 	= 0x04,
	CHAN_OCLOSE_RCVD 	= 0x08,
	CHAN_SHUT_RD 		= 0x10,
	CHAN_SHUT_WR 		= 0x20,

	/* a channel can be removed if ALL the following flags are set: */
	CHAN_CLOSED 		= CHAN_IEOF_SENT | CHAN_IEOF_RCVD |
				  CHAN_OCLOSE_SENT | CHAN_OCLOSE_RCVD |
				  CHAN_SHUT_RD | CHAN_SHUT_WR
};
d46 6
a51 1
void chan_del_if_dead(Channel *c);
d53 4
a56 5
void chan_rcvd_oclose(Channel *c);
void chan_send_ieof(Channel *c);
void chan_send_oclose(Channel *c);
void chan_shutdown_read(Channel *c);
void chan_shutdown_write(Channel *c);
@


1.1
log
@support for SSH protocol 1.5 which is poorly documented, the RFC.troff lies.
interops (x11,agent,etc) with 1.2.27 and protocol 1.3
@
text
@d1 2
a5 1

d7 49
a55 45
	SSH Protocol 1.5 aka New Channel Protocol
	Thanks to Martina, Axel and everyone who left Erlangen, leaving me bored.
	Written by Markus Friedl in October 1999

	Protocol versions 1.3 and 1.5 differ in the handshake protocol used for the
	tear down of channels:

	1.3:	strict request-ack-protocol:
		CLOSE	->
			<-  CLOSE_CONFIRM

	1.5:	uses variations of:
		IEOF	->
			<-  OCLOSE
			<-  IEOF
		OCLOSE	->

	See the debugging output from 'ssh -v' and 'sshd -d' in ssh-1.2.27, for example.

	Details: (for Channel data structure see channels.h)

	the output_buffer gets data received from the remote peer and is written to the socket,
	the input_buffer gets data from the socket and is sent to remote peer.
	the socket represents the local object communicating with an object reachable via the peer

		PEER A					PEER B

	read(sock, input_buffer) < 0;
	shutdown_read();
	flush(input_buffer) =: DATA
	send(DATA)			->      rcvd(DATA)                                         
						write(sock, output_buffer:=DATA);                  
	send(IEOF)			->	rcvd(IEOF)                                         
						shutdown_write() if:                               
							a) write fails                             
							b) rcvd_IEOF==true && output_buffer==empty
					<-	send(OCLOSE)
	rcvd(OCLOSE)				destroy channel
	shutdown_read() if not already
	destroy channel

	Note that each side can close the channel only if 2 messages
	have been sent and received and the associated socket has been shutdown, see below:
*/

d59 4
a62 2
	CHAN_IEOF   = SSH_MSG_CHANNEL_CLOSE,			/* no more data from sender */
	CHAN_OCLOSE = SSH_MSG_CHANNEL_CLOSE_CONFIRMATION,	/* all received data has been output */
d65 2
a66 2
	CHAN_IEOF_SENT 		= 0x01,	
	CHAN_IEOF_RCVD 		= 0x02,	
d70 1
a70 1
	CHAN_SHUT_WR 		= 0x20,	
@

