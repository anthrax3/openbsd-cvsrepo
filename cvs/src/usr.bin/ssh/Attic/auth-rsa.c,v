head	1.91;
access;
symbols
	OPENBSD_6_0:1.90.0.10
	OPENBSD_6_0_BASE:1.90
	OPENBSD_5_9:1.90.0.6
	OPENBSD_5_9_BASE:1.90
	OPENBSD_5_8:1.90.0.4
	OPENBSD_5_8_BASE:1.90
	OPENBSD_5_7:1.90.0.2
	OPENBSD_5_7_BASE:1.90
	OPENBSD_5_6:1.88.0.4
	OPENBSD_5_6_BASE:1.88
	OPENBSD_5_5:1.86.0.4
	OPENBSD_5_5_BASE:1.86
	OPENBSD_5_4:1.85.0.2
	OPENBSD_5_4_BASE:1.85
	OPENBSD_5_3:1.81.0.2
	OPENBSD_5_3_BASE:1.81
	OPENBSD_5_2:1.80.0.6
	OPENBSD_5_2_BASE:1.80
	OPENBSD_5_1_BASE:1.80
	OPENBSD_5_1:1.80.0.4
	OPENBSD_5_0:1.80.0.2
	OPENBSD_5_0_BASE:1.80
	OPENBSD_4_9:1.79.0.2
	OPENBSD_4_9_BASE:1.79
	OPENBSD_4_8:1.78.0.2
	OPENBSD_4_8_BASE:1.78
	OPENBSD_4_7:1.74.0.2
	OPENBSD_4_7_BASE:1.74
	OPENBSD_4_6:1.73.0.8
	OPENBSD_4_6_BASE:1.73
	OPENBSD_4_5:1.73.0.4
	OPENBSD_4_5_BASE:1.73
	OPENBSD_4_4:1.73.0.2
	OPENBSD_4_4_BASE:1.73
	OPENBSD_4_3:1.72.0.6
	OPENBSD_4_3_BASE:1.72
	OPENBSD_4_2:1.72.0.4
	OPENBSD_4_2_BASE:1.72
	OPENBSD_4_1:1.72.0.2
	OPENBSD_4_1_BASE:1.72
	OPENBSD_4_0:1.71.0.4
	OPENBSD_4_0_BASE:1.71
	OPENBSD_3_9:1.64.0.2
	OPENBSD_3_9_BASE:1.64
	OPENBSD_3_8:1.63.0.2
	OPENBSD_3_8_BASE:1.63
	OPENBSD_3_7:1.62.0.2
	OPENBSD_3_7_BASE:1.62
	OPENBSD_3_6:1.60.0.2
	OPENBSD_3_6_BASE:1.60
	OPENBSD_3_5:1.58.0.2
	OPENBSD_3_5_BASE:1.58
	OPENBSD_3_4:1.57.0.2
	OPENBSD_3_4_BASE:1.57
	OPENBSD_3_3:1.56.0.4
	OPENBSD_3_3_BASE:1.56
	OPENBSD_3_2:1.56.0.2
	OPENBSD_3_2_BASE:1.56
	OPENBSD_3_1:1.55.0.2
	OPENBSD_3_1_BASE:1.55
	OPENBSD_3_0:1.44.0.2
	OPENBSD_3_0_BASE:1.44
	OPENBSD_2_9_BASE:1.40
	OPENBSD_2_9:1.40.0.2
	OPENBSD_2_8:1.32.0.2
	OPENBSD_2_8_BASE:1.32
	OPENBSD_2_7:1.23.0.2
	OPENBSD_2_7_BASE:1.23
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.91
date	2016.08.13.17.47.41;	author markus;	state dead;
branches;
next	1.90;
commitid	dl4RDERdJITM8DKC;

1.90
date	2015.01.28.22.36.00;	author djm;	state Exp;
branches;
next	1.89;
commitid	P7KG9D8zB61mMUPV;

1.89
date	2014.12.21.22.27.56;	author djm;	state Exp;
branches;
next	1.88;
commitid	EbtriidyZdsmXksl;

1.88
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.87;
commitid	z7plx8Gkj6l2sxem;

1.87
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.86;
commitid	1h9UxAQmwdaqUzyX;

1.86
date	2014.01.27.19.18.54;	author markus;	state Exp;
branches;
next	1.85;

1.85
date	2013.07.12.00.19.58;	author djm;	state Exp;
branches;
next	1.84;

1.84
date	2013.06.21.00.34.49;	author djm;	state Exp;
branches;
next	1.83;

1.83
date	2013.05.19.02.42.42;	author djm;	state Exp;
branches;
next	1.82;

1.82
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.81;

1.81
date	2012.10.30.21.29.54;	author djm;	state Exp;
branches;
next	1.80;

1.80
date	2011.05.23.03.30.07;	author djm;	state Exp;
branches;
next	1.79;

1.79
date	2010.12.03.23.55.27;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2010.07.13.23.13.16;	author djm;	state Exp;
branches;
next	1.77;

1.77
date	2010.07.13.11.52.06;	author djm;	state Exp;
branches;
next	1.76;

1.76
date	2010.05.11.02.58.04;	author djm;	state Exp;
branches;
next	1.75;

1.75
date	2010.04.16.01.47.26;	author djm;	state Exp;
branches;
next	1.74;

1.74
date	2010.03.04.10.36.03;	author djm;	state Exp;
branches;
next	1.73;

1.73
date	2008.07.02.12.03.51;	author dtucker;	state Exp;
branches;
next	1.72;

1.72
date	2006.11.06.21.25.27;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches
	1.71.4.1;
next	1.70;

1.70
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.69;

1.69
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.68;

1.68
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.67;

1.67
date	2006.03.25.18.29.35;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.65;

1.65
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2006.02.20.17.19.53;	author stevesk;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2004.12.11.01.48.56;	author dtucker;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2004.12.06.11.41.03;	author dtucker;	state Exp;
branches;
next	1.60;

1.60
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2004.05.09.01.19.27;	author djm;	state Exp;
branches;
next	1.58;

1.58
date	2003.11.04.08.54.09;	author djm;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2002.06.10.16.53.06;	author stevesk;	state Exp;
branches
	1.56.2.1
	1.56.4.1;
next	1.55;

1.55
date	2002.03.29.19.18.33;	author stevesk;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2002.03.26.23.13.03;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2002.03.25.09.21.13;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2002.03.18.17.50.31;	author provos;	state Exp;
branches;
next	1.51;

1.51
date	2002.03.14.16.56.33;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2001.12.28.14.50.54;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2001.12.27.20.39.58;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2001.12.27.18.22.16;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2001.12.18.10.06.24;	author jakob;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.29.22.08.48;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2001.07.23.18.14.58;	author stevesk;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2001.06.25.17.54.47;	author provos;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.22.21.55.48;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2001.05.20.17.20.35;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2001.04.06.21.00.07;	author markus;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2001.03.01.02.45.10;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2001.01.21.19.05.42;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.20.17.34.25;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.20.15.55.20;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.19.15.55.10;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2000.12.19.23.17.55;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2000.11.14.23.42.40;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.14.12.19.45;	author markus;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2000.10.11.19.59.52;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2000.10.03.18.03.03;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2000.09.07.21.13.36;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2000.09.07.20.27.49;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2000.07.07.03.55.03;	author todd;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.20.01.39.38;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.18.04.05.02;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.06.19.32.13;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.29.18.11.51;	author markus;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2000.04.26.20.48.42;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.14.10.30.29;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.12.09.39.09;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.23.22.15.33;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.11.10.59.11;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.18.09.41.05;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	99.12.02.23.05.08;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	99.12.02.20.17.49;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	99.11.24.19.53.44;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	99.11.24.00.26.00;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.11.23.22.25.52;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	99.11.22.21.02.38;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	99.11.18.14.00.48;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.11.15.20.53.24;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	99.11.11.23.36.52;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	99.11.02.19.42.34;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.10.27.16.37.45;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.10.18.01.54.18;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	99.10.11.20.00.35;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	99.09.30.17.08.51;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.21.14.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.09.28.04.45.35;	author provos;	state Exp;
branches;
next	;

1.23.2.1
date	2000.06.12.02.37.31;	author jason;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2000.09.01.18.23.17;	author jason;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2000.11.08.21.30.21;	author jason;	state Exp;
branches;
next	1.23.2.4;

1.23.2.4
date	2001.03.12.15.44.07;	author jason;	state Exp;
branches;
next	1.23.2.5;

1.23.2.5
date	2001.03.21.18.52.33;	author jason;	state Exp;
branches;
next	;

1.32.2.1
date	2001.02.16.20.12.52;	author jason;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2001.02.19.17.18.36;	author jason;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2001.03.21.19.46.22;	author jason;	state Exp;
branches;
next	1.32.2.4;

1.32.2.4
date	2001.05.07.21.09.25;	author jason;	state Exp;
branches;
next	1.32.2.5;

1.32.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.32.2.6;

1.32.2.6
date	2002.03.08.17.04.41;	author brad;	state Exp;
branches;
next	;

1.40.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2002.03.09.00.20.43;	author miod;	state Exp;
branches;
next	1.40.2.3;

1.40.2.3
date	2002.06.02.22.56.09;	author miod;	state Exp;
branches;
next	;

1.44.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.44.2.3;

1.44.2.3
date	2002.06.22.07.23.16;	author miod;	state Exp;
branches;
next	;

1.55.2.1
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	;

1.56.2.1
date	2003.09.16.21.20.24;	author brad;	state Exp;
branches;
next	;

1.56.4.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.56.4.2;

1.56.4.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.57.2.1
date	2004.02.28.03.51.32;	author brad;	state Exp;
branches;
next	1.57.2.2;

1.57.2.2
date	2004.08.19.22.37.30;	author brad;	state Exp;
branches;
next	;

1.58.2.1
date	2004.08.19.04.13.25;	author brad;	state Exp;
branches;
next	1.58.2.2;

1.58.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.60.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.60.2.2;

1.60.2.2
date	2005.09.02.03.44.59;	author brad;	state Exp;
branches;
next	;

1.62.2.1
date	2005.09.04.18.39.52;	author brad;	state Exp;
branches;
next	;

1.63.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	1.63.2.2;

1.63.2.2
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.64.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	1.64.2.2;

1.64.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.71.4.1
date	2006.11.08.00.42.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.91
log
@remove ssh1 server code; ok djm@@
@
text
@/* $OpenBSD: auth-rsa.c,v 1.90 2015/01/28 22:36:00 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * RSA-based authentication.  This code determines whether to admit a login
 * based on RSA authentication.  This file also contains functions to check
 * validity of the host key.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <openssl/rsa.h>

#include <pwd.h>
#include <stdio.h>
#include <string.h>

#include "xmalloc.h"
#include "rsa.h"
#include "packet.h"
#include "ssh1.h"
#include "uidswap.h"
#include "match.h"
#include "buffer.h"
#include "pathnames.h"
#include "log.h"
#include "misc.h"
#include "servconf.h"
#include "key.h"
#include "auth-options.h"
#include "hostfile.h"
#include "auth.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"
#include "ssh.h"

#include "digest.h"

/* import */
extern ServerOptions options;

/*
 * Session identifier that is used to bind key exchange and authentication
 * responses to a particular session.
 */
extern u_char session_id[16];

/*
 * The .ssh/authorized_keys file contains public keys, one per line, in the
 * following format:
 *   options bits e n comment
 * where bits, e and n are decimal numbers,
 * and comment is any string of characters up to newline.  The maximum
 * length of a line is SSH_MAX_PUBKEY_BYTES characters.  See sshd(8) for a
 * description of the options.
 */

BIGNUM *
auth_rsa_generate_challenge(Key *key)
{
	BIGNUM *challenge;
	BN_CTX *ctx;

	if ((challenge = BN_new()) == NULL)
		fatal("auth_rsa_generate_challenge: BN_new() failed");
	/* Generate a random challenge. */
	if (BN_rand(challenge, 256, 0, 0) == 0)
		fatal("auth_rsa_generate_challenge: BN_rand failed");
	if ((ctx = BN_CTX_new()) == NULL)
		fatal("auth_rsa_generate_challenge: BN_CTX_new failed");
	if (BN_mod(challenge, challenge, key->rsa->n, ctx) == 0)
		fatal("auth_rsa_generate_challenge: BN_mod failed");
	BN_CTX_free(ctx);

	return challenge;
}

int
auth_rsa_verify_response(Key *key, BIGNUM *challenge, u_char response[16])
{
	u_char buf[32], mdbuf[16];
	struct ssh_digest_ctx *md;
	int len;

	/* don't allow short keys */
	if (BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE) {
		error("%s: RSA modulus too small: %d < minimum %d bits",
		    __func__,
		    BN_num_bits(key->rsa->n), SSH_RSA_MINIMUM_MODULUS_SIZE);
		return (0);
	}

	/* The response is MD5 of decrypted challenge plus session id. */
	len = BN_num_bytes(challenge);
	if (len <= 0 || len > 32)
		fatal("%s: bad challenge length %d", __func__, len);
	memset(buf, 0, 32);
	BN_bn2bin(challenge, buf + 32 - len);
	if ((md = ssh_digest_start(SSH_DIGEST_MD5)) == NULL ||
	    ssh_digest_update(md, buf, 32) < 0 ||
	    ssh_digest_update(md, session_id, 16) < 0 ||
	    ssh_digest_final(md, mdbuf, sizeof(mdbuf)) < 0)
		fatal("%s: md5 failed", __func__);
	ssh_digest_free(md);

	/* Verify that the response is the original challenge. */
	if (timingsafe_bcmp(response, mdbuf, 16) != 0) {
		/* Wrong answer. */
		return (0);
	}
	/* Correct answer. */
	return (1);
}

/*
 * Performs the RSA authentication challenge-response dialog with the client,
 * and returns true (non-zero) if the client gave the correct answer to
 * our challenge; returns zero if the client gives a wrong answer.
 */

int
auth_rsa_challenge_dialog(Key *key)
{
	BIGNUM *challenge, *encrypted_challenge;
	u_char response[16];
	int i, success;

	if ((encrypted_challenge = BN_new()) == NULL)
		fatal("auth_rsa_challenge_dialog: BN_new() failed");

	challenge = PRIVSEP(auth_rsa_generate_challenge(key));

	/* Encrypt the challenge with the public key. */
	if (rsa_public_encrypt(encrypted_challenge, challenge, key->rsa) != 0)
		fatal("%s: rsa_public_encrypt failed", __func__);

	/* Send the encrypted challenge to the client. */
	packet_start(SSH_SMSG_AUTH_RSA_CHALLENGE);
	packet_put_bignum(encrypted_challenge);
	packet_send();
	BN_clear_free(encrypted_challenge);
	packet_write_wait();

	/* Wait for a response. */
	packet_read_expect(SSH_CMSG_AUTH_RSA_RESPONSE);
	for (i = 0; i < 16; i++)
		response[i] = (u_char)packet_get_char();
	packet_check_eom();

	success = PRIVSEP(auth_rsa_verify_response(key, challenge, response));
	BN_clear_free(challenge);
	return (success);
}

static int
rsa_key_allowed_in_file(struct passwd *pw, char *file,
    const BIGNUM *client_n, Key **rkey)
{
	char *fp, line[SSH_MAX_PUBKEY_BYTES];
	int allowed = 0, bits;
	FILE *f;
	u_long linenum = 0;
	Key *key;

	debug("trying public RSA key file %s", file);
	if ((f = auth_openkeyfile(file, pw, options.strict_modes)) == NULL)
		return 0;

	/*
	 * Go though the accepted keys, looking for the current key.  If
	 * found, perform a challenge-response dialog to verify that the
	 * user really has the corresponding private key.
	 */
	key = key_new(KEY_RSA1);
	while (read_keyfile_line(f, file, line, sizeof(line), &linenum) != -1) {
		char *cp;
		char *key_options;
		int keybits;

		/* Skip leading whitespace, empty and comment lines. */
		for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (!*cp || *cp == '\n' || *cp == '#')
			continue;

		/*
		 * Check if there are options for this key, and if so,
		 * save their starting address and skip the option part
		 * for now.  If there are no options, set the starting
		 * address to NULL.
		 */
		if (*cp < '0' || *cp > '9') {
			int quoted = 0;
			key_options = cp;
			for (; *cp && (quoted || (*cp != ' ' && *cp != '\t')); cp++) {
				if (*cp == '\\' && cp[1] == '"')
					cp++;	/* Skip both */
				else if (*cp == '"')
					quoted = !quoted;
			}
		} else
			key_options = NULL;

		/* Parse the key from the line. */
		if (hostfile_read_key(&cp, &bits, key) == 0) {
			debug("%.100s, line %lu: non ssh1 key syntax",
			    file, linenum);
			continue;
		}
		/* cp now points to the comment part. */

		/*
		 * Check if the we have found the desired key (identified
		 * by its modulus).
		 */
		if (BN_cmp(key->rsa->n, client_n) != 0)
			continue;

		/* check the real bits  */
		keybits = BN_num_bits(key->rsa->n);
		if (keybits < 0 || bits != keybits)
			logit("Warning: %s, line %lu: keysize mismatch: "
			    "actual %d vs. announced %d.",
			    file, linenum, BN_num_bits(key->rsa->n), bits);

		if ((fp = sshkey_fingerprint(key, options.fingerprint_hash,
		    SSH_FP_DEFAULT)) == NULL)
			continue;
		debug("matching key found: file %s, line %lu %s %s",
		    file, linenum, key_type(key), fp);
		free(fp);

		/* Never accept a revoked key */
		if (auth_key_is_revoked(key))
			break;

		/* We have found the desired key. */
		/*
		 * If our options do not allow this key to be used,
		 * do not send challenge.
		 */
		if (!auth_parse_options(pw, key_options, file, linenum))
			continue;
		if (key_is_cert_authority)
			continue;
		/* break out, this key is allowed */
		allowed = 1;
		break;
	}

	/* Close the file. */
	fclose(f);

	/* return key if allowed */
	if (allowed && rkey != NULL)
		*rkey = key;
	else
		key_free(key);

	return allowed;
}

/*
 * check if there's user key matching client_n,
 * return key if login is allowed, NULL otherwise
 */

int
auth_rsa_key_allowed(struct passwd *pw, BIGNUM *client_n, Key **rkey)
{
	char *file;
	u_int i, allowed = 0;

	temporarily_use_uid(pw);

	for (i = 0; !allowed && i < options.num_authkeys_files; i++) {
		if (strcasecmp(options.authorized_keys_files[i], "none") == 0)
			continue;
		file = expand_authorized_keys(
		    options.authorized_keys_files[i], pw);
		allowed = rsa_key_allowed_in_file(pw, file, client_n, rkey);
		free(file);
	}

	restore_uid();

	return allowed;
}

/*
 * Performs the RSA authentication dialog with the client.  This returns
 * 0 if the client could not be authenticated, and 1 if authentication was
 * successful.  This may exit if there is a serious protocol violation.
 */
int
auth_rsa(Authctxt *authctxt, BIGNUM *client_n)
{
	Key *key;
	struct passwd *pw = authctxt->pw;

	/* no user given */
	if (!authctxt->valid)
		return 0;

	if (!PRIVSEP(auth_rsa_key_allowed(pw, client_n, &key))) {
		auth_clear_options();
		return (0);
	}

	/* Perform the challenge-response dialog for this key. */
	if (!auth_rsa_challenge_dialog(key)) {
		/* Wrong response. */
		verbose("Wrong response to RSA authentication challenge.");
		packet_send_debug("Wrong response to RSA authentication challenge.");
		/*
		 * Break out of the loop. Otherwise we might send
		 * another challenge and break the protocol.
		 */
		key_free(key);
		return (0);
	}
	/*
	 * Correct response.  The client has been successfully
	 * authenticated. Note that we have not yet processed the
	 * options; this will be reset if the options cause the
	 * authentication to be rejected.
	 */
	pubkey_auth_info(authctxt, key, NULL);

	packet_send_debug("RSA authentication accepted.");
	return (1);
}
@


1.90
log
@update to new API (key_fingerprint => sshkey_fingerprint)
check sshkey_fingerprint return values;
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.89 2014/12/21 22:27:56 djm Exp $ */
@


1.89
log
@Add FingerprintHash option to control algorithm used for key
fingerprints. Default changes from MD5 to SHA256 and format
from hex to base64.

Feedback and ok naddy@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.88 2014/07/15 15:54:14 millert Exp $ */
d236 3
a238 2
		fp = key_fingerprint(key, options.fingerprint_hash,
		    SSH_FP_DEFAULT);
@


1.88
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.87 2014/06/24 01:13:21 djm Exp $ */
d236 2
a237 1
		fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
@


1.87
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.86 2014/01/27 19:18:54 markus Exp $ */
d35 1
a45 1
#include "misc.h"
@


1.86
log
@replace openssl MD5 with our ssh_digest_*; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.85 2013/07/12 00:19:58 djm Exp $ */
d144 2
a145 1
	rsa_public_encrypt(encrypted_challenge, challenge, key->rsa);
@


1.85
log
@fix pointer-signedness warnings from clang/llvm-3.3; "seems nice" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.84 2013/06/21 00:34:49 djm Exp $ */
a20 1
#include <openssl/md5.h>
d47 2
d92 1
a92 1
	MD5_CTX md;
d97 2
a98 1
		error("auth_rsa_verify_response: RSA modulus too small: %d < minimum %d bits",
d106 1
a106 1
		fatal("auth_rsa_verify_response: bad challenge length %d", len);
d109 6
a114 4
	MD5_Init(&md);
	MD5_Update(&md, buf, 32);
	MD5_Update(&md, session_id, 16);
	MD5_Final(mdbuf, &md);
@


1.84
log
@for hostbased authentication, print the client host and user on
the auth success/failure line; bz#2064, ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.83 2013/05/19 02:42:42 djm Exp $ */
d165 1
a165 2
	int allowed = 0;
	u_int bits;
d226 1
a226 1
		if (keybits < 0 || bits != (u_int)keybits)
@


1.83
log
@Standardise logging of supplemental information during userauth. Keys
and ruser is now logged in the auth success/failure message alongside
the local username, remote host/port and protocol in use. Certificates
contents and CA are logged too.

Pushing all logging onto a single line simplifies log analysis as it is
no longer necessary to relate information scattered across multiple log
entries. "I like it" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.82 2013/05/17 00:13:13 djm Exp $ */
d332 1
a332 1
	pubkey_auth_info(authctxt, key);
@


1.82
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.81 2012/10/30 21:29:54 djm Exp $ */
d164 1
a164 1
	char line[SSH_MAX_PUBKEY_BYTES];
d232 5
a302 1
	char *fp;
d332 1
a332 5
	fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
	verbose("Found matching %s key: %s",
	    key_type(key), fp);
	free(fp);
	key_free(key);
@


1.81
log
@new sshd_config option AuthorizedKeysCommand to support fetching
authorized_keys from a command in addition to (or instead of) from
the filesystem. The command is run as the target server user unless
another specified via a new AuthorizedKeysCommandUser option.

patch originally by jchadima AT redhat.com, reworked by me; feedback
and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.80 2011/05/23 03:30:07 djm Exp $ */
d281 1
a281 1
		xfree(file);
d331 1
a331 1
	xfree(fp);
@


1.80
log
@allow AuthorizedKeysFile to specify multiple files, separated by spaces.
Bring back authorized_keys2 as a default search path (to avoid breaking
existing users of this file), but override this in sshd_config so it will
be no longer used on fresh installs. Maybe in 2015 we can remove it
entierly :)

feedback and ok markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.79 2010/12/03 23:55:27 djm Exp $ */
d276 2
@


1.79
log
@move check for revoked keys to run earlier (in auth_rsa_key_allowed)
bz#1829; patch from ldv AT altlinux.org; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.78 2010/07/13 23:13:16 djm Exp $ */
d160 3
a162 7
/*
 * check if there's user key matching client_n,
 * return key if login is allowed, NULL otherwise
 */

int
auth_rsa_key_allowed(struct passwd *pw, BIGNUM *client_n, Key **rkey)
d164 1
a164 1
	char line[SSH_MAX_PUBKEY_BYTES], *file;
a170 5
	/* Temporarily use the user's uid. */
	temporarily_use_uid(pw);

	/* The authorized keys. */
	file = authorized_keys_file(pw);
d172 2
a173 11
	f = auth_openkeyfile(file, pw, options.strict_modes);
	if (!f) {
		xfree(file);
		restore_uid();
		return (0);
	}

	/* Flag indicating whether the key is allowed. */
	allowed = 0;

	key = key_new(KEY_RSA1);
d180 1
d218 4
a221 1
		/* Check if the we have found the desired key (identified by its modulus). */
a249 3
	/* Restore the privileged uid. */
	restore_uid();

a250 1
	xfree(file);
d258 27
a284 1
	return (allowed);
@


1.78
log
@s/timing_safe_cmp/timingsafe_bcmp/g
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.77 2010/07/13 11:52:06 djm Exp $ */
a93 3
	if (auth_key_is_revoked(key))
		return 0;

d245 4
@


1.77
log
@implement a timing_safe_cmp() function to compare memory without leaking
timing information by short-circuiting like memcmp() and use it for
some of the more sensitive comparisons (though nothing high-value was
readily attackable anyway); "looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.76 2010/05/11 02:58:04 djm Exp $ */
d116 1
a116 1
	if (timing_safe_cmp(response, mdbuf, 16) != 0) {
@


1.76
log
@don't accept certificates marked as "cert-authority" here; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.75 2010/04/16 01:47:26 djm Exp $ */
d116 1
a116 1
	if (memcmp(response, mdbuf, 16) != 0) {
@


1.75
log
@revised certificate format ssh-{dss,rsa}-cert-v01@@openssh.com with the
following changes:

move the nonce field to the beginning of the certificate where it can
better protect against chosen-prefix attacks on the signature hash

Rename "constraints" field to "critical options"

Add a new non-critical "extensions" field

Add a serial number

The older format is still support for authentication and cert generation
(use "ssh-keygen -t v00 -s ca_key ..." to generate a v00 certificate)

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.74 2010/03/04 10:36:03 djm Exp $ */
d256 2
a257 1

@


1.74
log
@Add a TrustedUserCAKeys option to sshd_config to specify CA keys that
are trusted to authenticate users (in addition than doing it per-user
in authorized_keys).

Add a RevokedKeys option to sshd_config and a @@revoked marker to
known_hosts to allow keys to me revoked and banned for user or host
authentication.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.73 2008/07/02 12:03:51 dtucker Exp $ */
a33 1
#include "auth-options.h"
d38 1
@


1.73
log
@Merge duplicate host key file checks, based in part on a patch from Rob
Holland via bz #1348 .  Also checks for non-regular files during protocol
1 RSA auth.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.72 2006/11/06 21:25:27 markus Exp $ */
d93 3
@


1.72
log
@add missing checks for openssl return codes; with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.71 2006/08/03 03:34:41 deraadt Exp $ */
a172 1
	struct stat st;
d181 1
a181 10

	/* Fail quietly if file does not exist */
	if (stat(file, &st) < 0) {
		/* Restore the privileged uid. */
		restore_uid();
		xfree(file);
		return (0);
	}
	/* Open the file containing the authorized keys. */
	f = fopen(file, "r");
a182 7
		/* Restore the privileged uid. */
		restore_uid();
		xfree(file);
		return (0);
	}
	if (options.strict_modes &&
	    secure_filename(f, file, pw, line, sizeof(line)) != 0) {
a183 2
		fclose(f);
		logit("Authentication refused: %s", line);
@


1.71
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.70 2006/08/01 23:22:47 stevesk Exp $ */
d76 2
a77 1
	BN_rand(challenge, 256, 0, 0);
d79 3
a81 2
		fatal("auth_rsa_generate_challenge: BN_CTX_new() failed");
	BN_mod(challenge, challenge, key->rsa->n, ctx);
@


1.71.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.72 2006/11/06 21:25:27 markus Exp $ */
d76 1
a76 2
	if (BN_rand(challenge, 256, 0, 0) == 0)
		fatal("auth_rsa_generate_challenge: BN_rand failed");
d78 2
a79 3
		fatal("auth_rsa_generate_challenge: BN_CTX_new failed");
	if (BN_mod(challenge, challenge, key->rsa->n, ctx) == 0)
		fatal("auth_rsa_generate_challenge: BN_mod failed");
@


1.70
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.69 2006/07/22 20:48:22 stevesk Exp $ */
a16 2
#include "includes.h"

d27 1
a29 1
#include "xmalloc.h"
d33 1
d38 2
d41 3
a43 1
#include "hostfile.h"
@


1.69
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.68 2006/07/06 16:03:53 stevesk Exp $ */
d26 1
@


1.68
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.67 2006/03/25 18:29:35 deraadt Exp $ */
d26 1
@


1.67
log
@needed casts (always will be needed)
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.66 2006/03/25 13:17:01 djm Exp $ */
d24 2
@


1.66
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d143 1
a143 1
		response[i] = packet_get_char();
@


1.65
log
@RCSID() can die
@
text
@d1 1
@


1.64
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@a16 1
RCSID("$OpenBSD: auth-rsa.c,v 1.63 2005/06/17 02:44:32 djm Exp $");
@


1.64.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth-rsa.c,v 1.71 2006/08/03 03:34:41 deraadt Exp $ */
d16 3
a24 5
#include <pwd.h>
#include <stdio.h>
#include <string.h>

#include "xmalloc.h"
d27 1
a30 1
#include "buffer.h"
d35 1
a35 1
#include "key.h"
a36 4
#include "auth.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
d143 1
a143 1
		response[i] = (u_char)packet_get_char();
@


1.64.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.72 2006/11/06 21:25:27 markus Exp $ */
d76 1
a76 2
	if (BN_rand(challenge, 256, 0, 0) == 0)
		fatal("auth_rsa_generate_challenge: BN_rand failed");
d78 2
a79 3
		fatal("auth_rsa_generate_challenge: BN_CTX_new failed");
	if (BN_mod(challenge, challenge, key->rsa->n, ctx) == 0)
		fatal("auth_rsa_generate_challenge: BN_mod failed");
@


1.63
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d17 4
a20 1
RCSID("$OpenBSD: auth-rsa.c,v 1.62 2004/12/11 01:48:56 dtucker Exp $");
@


1.63.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth-rsa.c,v 1.71 2006/08/03 03:34:41 deraadt Exp $ */
d16 2
a17 2
#include <sys/types.h>
#include <sys/stat.h>
a21 5
#include <pwd.h>
#include <stdio.h>
#include <string.h>

#include "xmalloc.h"
d24 1
a27 1
#include "buffer.h"
d32 1
a32 1
#include "key.h"
a33 4
#include "auth.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
d140 1
a140 1
		response[i] = (u_char)packet_get_char();
@


1.63.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.72 2006/11/06 21:25:27 markus Exp $ */
d76 1
a76 2
	if (BN_rand(challenge, 256, 0, 0) == 0)
		fatal("auth_rsa_generate_challenge: BN_rand failed");
d78 2
a79 3
		fatal("auth_rsa_generate_challenge: BN_CTX_new failed");
	if (BN_mod(challenge, challenge, key->rsa->n, ctx) == 0)
		fatal("auth_rsa_generate_challenge: BN_mod failed");
@


1.62
log
@Fix debug call in error path of authorized_keys processing and fix related
warnings; ok djm@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.61 2004/12/06 11:41:03 dtucker Exp $");
d208 1
d247 2
a248 1
		if (bits != BN_num_bits(key->rsa->n))
@


1.62.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.63 2005/06/17 02:44:32 djm Exp $");
a207 1
		int keybits;
d246 1
a246 2
		keybits = BN_num_bits(key->rsa->n);
		if (keybits < 0 || bits != (u_int)keybits)
@


1.61
log
@Discard over-length authorized_keys entries rather than complaining when
they don't decode.  bz #884, with & ok djm@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.60 2004/06/21 17:36:31 avsm Exp $");
d36 1
@


1.60
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.59 2004/05/09 01:19:27 djm Exp $");
d52 1
a52 1
 * length of a line is 8000 characters.  See the documentation for a
d155 1
a155 1
	char line[8192], *file;
d204 1
a204 1
	while (fgets(line, sizeof(line), f)) {
a206 2

		linenum++;
@


1.60.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.62 2004/12/11 01:48:56 dtucker Exp $");
a35 1
#include "misc.h"
d52 1
a52 1
 * length of a line is SSH_MAX_PUBKEY_BYTES characters.  See sshd(8) for a
d155 1
a155 1
	char line[SSH_MAX_PUBKEY_BYTES], *file;
d204 1
a204 1
	while (read_keyfile_line(f, file, line, sizeof(line), &linenum) != -1) {
d207 2
@


1.60.2.2
log
@upgrade to OpenSSH 4.2
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.63 2005/06/17 02:44:32 djm Exp $");
a207 1
		int keybits;
d246 1
a246 2
		keybits = BN_num_bits(key->rsa->n);
		if (keybits < 0 || bits != (u_int)keybits)
@


1.59
log
@kill some more tiny files; ok deraadt@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.58 2003/11/04 08:54:09 djm Exp $");
d206 1
a206 1
		char *options;
d224 1
a224 1
			options = cp;
d232 1
a232 1
			options = NULL;
d257 1
a257 1
		if (!auth_parse_options(pw, options, file, linenum))
@


1.58
log
@standardise arguments to auth methods - they should all take authctxt.
check authctxt->valid rather then pw != NULL; ok markus@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.57 2003/04/08 20:21:28 itojun Exp $");
a25 1
#include "mpaux.h"
@


1.58.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.60 2004/06/21 17:36:31 avsm Exp $");
d26 1
d207 1
a207 1
		char *key_options;
d225 1
a225 1
			key_options = cp;
d233 1
a233 1
			key_options = NULL;
d258 1
a258 1
		if (!auth_parse_options(pw, key_options, file, linenum))
@


1.58.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.62 2004/12/11 01:48:56 dtucker Exp $");
a35 1
#include "misc.h"
d52 1
a52 1
 * length of a line is SSH_MAX_PUBKEY_BYTES characters.  See sshd(8) for a
d155 1
a155 1
	char line[SSH_MAX_PUBKEY_BYTES], *file;
d204 1
a204 1
	while (read_keyfile_line(f, file, line, sizeof(line), &linenum) != -1) {
d207 2
@


1.57
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.56 2002/06/10 16:53:06 stevesk Exp $");
d287 1
a287 1
auth_rsa(struct passwd *pw, BIGNUM *client_n)
d291 1
d294 1
a294 1
	if (pw == NULL)
@


1.57.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.58 2003/11/04 08:54:09 djm Exp $");
d287 1
a287 1
auth_rsa(Authctxt *authctxt, BIGNUM *client_n)
a290 1
	struct passwd *pw = authctxt->pw;
d293 1
a293 1
	if (!authctxt->valid)
@


1.57.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.60 2004/06/21 17:36:31 avsm Exp $");
d26 1
d207 1
a207 1
		char *key_options;
d225 1
a225 1
			key_options = cp;
d233 1
a233 1
			key_options = NULL;
d258 1
a258 1
		if (!auth_parse_options(pw, key_options, file, linenum))
@


1.56
log
@display minimum RSA modulus in error(); ok markus@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.55 2002/03/29 19:18:33 stevesk Exp $");
d190 1
a190 1
		log("Authentication refused: %s", line);
d249 1
a249 1
			log("Warning: %s, line %lu: keysize mismatch: "
@


1.56.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.57 2003/04/08 20:21:28 itojun Exp $");
d190 1
a190 1
		logit("Authentication refused: %s", line);
d249 1
a249 1
			logit("Warning: %s, line %lu: keysize mismatch: "
@


1.56.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.57 2003/04/08 20:21:28 itojun Exp $");
d190 1
a190 1
		logit("Authentication refused: %s", line);
d249 1
a249 1
			logit("Warning: %s, line %lu: keysize mismatch: "
@


1.56.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.58 2003/11/04 08:54:09 djm Exp $");
d287 1
a287 1
auth_rsa(Authctxt *authctxt, BIGNUM *client_n)
a290 1
	struct passwd *pw = authctxt->pw;
d293 1
a293 1
	if (!authctxt->valid)
@


1.55
log
@make RSA modulus minimum #define; ok markus@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.54 2002/03/26 23:13:03 markus Exp $");
d84 2
a85 2
		error("auth_rsa_verify_response: n too small: %d bits",
		    BN_num_bits(key->rsa->n));
@


1.55.2.1
log
@Pull in OpenSSH-3.4
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.56 2002/06/10 16:53:06 stevesk Exp $");
d84 2
a85 2
		error("auth_rsa_verify_response: RSA modulus too small: %d < minimum %d bits",
		    BN_num_bits(key->rsa->n), SSH_RSA_MINIMUM_MODULUS_SIZE);
@


1.54
log
@disallow RSA keys < 768 for protocol 1, too (rhosts-rsa and rsa auth)
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.53 2002/03/25 09:21:13 markus Exp $");
d36 1
d83 1
a83 1
	if (BN_num_bits(key->rsa->n) < 768) {
@


1.53
log
@return 0 (not NULL); tomh@@po.crl.go.jp
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.52 2002/03/18 17:50:31 provos Exp $");
d80 7
@


1.52
log
@integrate privilege separated openssh; its turned off by default for now.
work done by me and markus@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.50 2001/12/28 14:50:54 markus Exp $");
d168 1
a168 1
		return (NULL);
d176 1
a176 1
		return (NULL);
d184 1
a184 1
		return (NULL);
@


1.51
log
@split auth_rsa() for better readability and privsep; ok provos@@
@
text
@d35 1
d56 1
a56 1
static BIGNUM *
d74 1
a74 1
static int
d117 1
a117 1
	challenge = auth_rsa_generate_challenge(key);
d135 1
a135 1
	success = auth_rsa_verify_response(key, challenge, response);
d145 1
a145 1
static int
d149 1
a149 1
	int allowed;
d288 1
a288 1
	if (auth_rsa_key_allowed(pw, client_n, &key) == 0) {
@


1.50
log
@packet_read* no longer return the packet length, since it's not used.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.49 2001/12/28 12:14:27 markus Exp $");
d55 45
d107 1
a107 1
auth_rsa_challenge_dialog(RSA *pk)
d110 2
a111 5
	BN_CTX *ctx;
	u_char buf[32], mdbuf[16], response[16];
	MD5_CTX md;
	u_int i;
	int len;
a114 2
	if ((challenge = BN_new()) == NULL)
		fatal("auth_rsa_challenge_dialog: BN_new() failed");
d116 1
a116 6
	/* Generate a random challenge. */
	BN_rand(challenge, 256, 0, 0);
	if ((ctx = BN_CTX_new()) == NULL)
		fatal("auth_rsa_challenge_dialog: BN_CTX_new() failed");
	BN_mod(challenge, challenge, pk->n, ctx);
	BN_CTX_free(ctx);
d119 1
a119 1
	rsa_public_encrypt(encrypted_challenge, challenge, pk);
d134 1
a134 10
	/* The response is MD5 of decrypted challenge plus session id. */
	len = BN_num_bytes(challenge);
	if (len <= 0 || len > 32)
		fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
	memset(buf, 0, 32);
	BN_bn2bin(challenge, buf + 32 - len);
	MD5_Init(&md);
	MD5_Update(&md, buf, 32);
	MD5_Update(&md, session_id, 16);
	MD5_Final(mdbuf, &md);
d136 1
a136 8

	/* Verify that the response is the original challenge. */
	if (memcmp(response, mdbuf, 16) != 0) {
		/* Wrong answer. */
		return 0;
	}
	/* Correct answer. */
	return 1;
d140 2
a141 3
 * Performs the RSA authentication dialog with the client.  This returns
 * 0 if the client could not be authenticated, and 1 if authentication was
 * successful.  This may exit if there is a serious protocol violation.
d144 2
a145 2
int
auth_rsa(struct passwd *pw, BIGNUM *client_n)
d148 1
a148 1
	int authenticated;
a153 5
	char *fp;

	/* no user given */
	if (pw == NULL)
		return 0;
d167 1
a167 1
		return 0;
a173 2
		packet_send_debug("Could not open %.900s for reading.", file);
		packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
d175 1
a175 1
		return 0;
a181 1
		packet_send_debug("Authentication refused: %s", line);
d183 1
a183 1
		return 0;
d185 3
a187 2
	/* Flag indicating whether authentication has succeeded. */
	authenticated = 0;
d252 2
a253 26
		/* Perform the challenge-response dialog for this key. */
		if (!auth_rsa_challenge_dialog(key->rsa)) {
			/* Wrong response. */
			verbose("Wrong response to RSA authentication challenge.");
			packet_send_debug("Wrong response to RSA authentication challenge.");
			/*
			 * Break out of the loop. Otherwise we might send
			 * another challenge and break the protocol.
			 */
			break;
		}
		/*
		 * Correct response.  The client has been successfully
		 * authenticated. Note that we have not yet processed the
		 * options; this will be reset if the options cause the
		 * authentication to be rejected.
		 * Break out of the loop if authentication was successful;
		 * otherwise continue searching.
		 */
		authenticated = 1;

	 	fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
		verbose("Found matching %s key: %s",
		    key_type(key), fp);
		xfree(fp);

d264 22
a285 1
	key_free(key);
d287 1
a287 3
	if (authenticated)
		packet_send_debug("RSA authentication accepted.");
	else
d289 26
d316 2
a317 2
	/* Return authentication result. */
	return authenticated;
@


1.49
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.48 2001/12/27 20:39:58 markus Exp $");
d69 1
a69 1
	int plen, len;
d94 1
a94 1
	packet_read_expect(&plen, SSH_CMSG_AUTH_RSA_RESPONSE);
@


1.48
log
@get rid of packet_integrity_check, use packet_done() instead.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.47 2001/12/27 18:22:16 markus Exp $");
d97 1
a97 1
	packet_done();
@


1.47
log
@call fatal() for openssl allocation failures
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.46 2001/12/18 10:06:24 jakob Exp $");
a94 1
	packet_integrity_check(plen, 16, SSH_CMSG_AUTH_RSA_RESPONSE);
d97 1
@


1.46
log
@log fingerprint on successful public key authentication, simplify usage of key structs; ok markus@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.45 2001/11/29 22:08:48 markus Exp $");
d71 4
a74 2
	encrypted_challenge = BN_new();
	challenge = BN_new();
d78 2
a79 1
	ctx = BN_CTX_new();
@


1.45
log
@fix protocol error: send 'failed' message instead of a 2nd challenge
(happens if the same key is in authorized_keys twice).
reported Ralf_Meister@@genua.de; ok djm@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.44 2001/07/23 18:14:58 stevesk Exp $");
d34 1
d132 2
a133 1
	RSA *pk;
d175 1
a175 3
	pk = RSA_new();
	pk->e = BN_new();
	pk->n = BN_new();
d213 1
a213 1
		if (!auth_rsa_read_key(&cp, &bits, pk->e, pk->n)) {
d221 1
a221 1
		if (BN_cmp(pk->n, client_n) != 0)
d225 1
a225 1
		if (bits != BN_num_bits(pk->n))
d228 1
a228 1
			    file, linenum, BN_num_bits(pk->n), bits);
d239 1
a239 1
		if (!auth_rsa_challenge_dialog(pk)) {
d258 6
d274 1
a274 1
	RSA_free(pk);
@


1.44
log
@use %lu; ok markus@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.43 2001/06/25 17:54:47 provos Exp $");
d243 5
a247 1
			continue;
@


1.44.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.50 2001/12/28 14:50:54 markus Exp $");
a33 1
#include "hostfile.h"
d68 1
a68 1
	int len;
d70 2
a71 4
	if ((encrypted_challenge = BN_new()) == NULL)
		fatal("auth_rsa_challenge_dialog: BN_new() failed");
	if ((challenge = BN_new()) == NULL)
		fatal("auth_rsa_challenge_dialog: BN_new() failed");
d75 1
a75 2
	if ((ctx = BN_CTX_new()) == NULL)
		fatal("auth_rsa_challenge_dialog: BN_CTX_new() failed");
d90 2
a91 1
	packet_read_expect(SSH_CMSG_AUTH_RSA_RESPONSE);
a93 1
	packet_check_eom();
d131 1
a131 2
	Key *key;
	char *fp;
d173 3
a175 1
	key = key_new(KEY_RSA1);
d213 1
a213 1
		if (hostfile_read_key(&cp, &bits, key) == 0) {
d221 1
a221 1
		if (BN_cmp(key->rsa->n, client_n) != 0)
d225 1
a225 1
		if (bits != BN_num_bits(key->rsa->n))
d228 1
a228 1
			    file, linenum, BN_num_bits(key->rsa->n), bits);
d239 1
a239 1
		if (!auth_rsa_challenge_dialog(key->rsa)) {
d243 1
a243 5
			/*
			 * Break out of the loop. Otherwise we might send
			 * another challenge and break the protocol.
			 */
			break;
a253 6

	 	fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
		verbose("Found matching %s key: %s",
		    key_type(key), fp);
		xfree(fp);

d264 1
a264 1
	key_free(key);
@


1.44.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.55 2002/03/29 19:18:33 stevesk Exp $");
a34 2
#include "monitor_wrap.h"
#include "ssh.h"
a54 52
BIGNUM *
auth_rsa_generate_challenge(Key *key)
{
	BIGNUM *challenge;
	BN_CTX *ctx;

	if ((challenge = BN_new()) == NULL)
		fatal("auth_rsa_generate_challenge: BN_new() failed");
	/* Generate a random challenge. */
	BN_rand(challenge, 256, 0, 0);
	if ((ctx = BN_CTX_new()) == NULL)
		fatal("auth_rsa_generate_challenge: BN_CTX_new() failed");
	BN_mod(challenge, challenge, key->rsa->n, ctx);
	BN_CTX_free(ctx);

	return challenge;
}

int
auth_rsa_verify_response(Key *key, BIGNUM *challenge, u_char response[16])
{
	u_char buf[32], mdbuf[16];
	MD5_CTX md;
	int len;

	/* don't allow short keys */
	if (BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE) {
		error("auth_rsa_verify_response: n too small: %d bits",
		    BN_num_bits(key->rsa->n));
		return (0);
	}

	/* The response is MD5 of decrypted challenge plus session id. */
	len = BN_num_bytes(challenge);
	if (len <= 0 || len > 32)
		fatal("auth_rsa_verify_response: bad challenge length %d", len);
	memset(buf, 0, 32);
	BN_bn2bin(challenge, buf + 32 - len);
	MD5_Init(&md);
	MD5_Update(&md, buf, 32);
	MD5_Update(&md, session_id, 16);
	MD5_Final(mdbuf, &md);

	/* Verify that the response is the original challenge. */
	if (memcmp(response, mdbuf, 16) != 0) {
		/* Wrong answer. */
		return (0);
	}
	/* Correct answer. */
	return (1);
}

d62 1
a62 1
auth_rsa_challenge_dialog(Key *key)
d65 5
a69 2
	u_char response[16];
	int i, success;
d73 2
d76 6
a81 1
	challenge = PRIVSEP(auth_rsa_generate_challenge(key));
d84 1
a84 1
	rsa_public_encrypt(encrypted_challenge, challenge, key->rsa);
d99 10
a108 1
	success = PRIVSEP(auth_rsa_verify_response(key, challenge, response));
d110 8
a117 1
	return (success);
d121 3
a123 2
 * check if there's user key matching client_n,
 * return key if login is allowed, NULL otherwise
d127 1
a127 1
auth_rsa_key_allowed(struct passwd *pw, BIGNUM *client_n, Key **rkey)
d130 1
a130 1
	int allowed = 0;
d136 5
d154 1
a154 1
		return (0);
d161 2
d164 1
a164 1
		return (0);
d171 1
d173 1
a173 1
		return (0);
d175 2
a176 3

	/* Flag indicating whether the key is allowed. */
	allowed = 0;
d241 26
a266 2
		/* break out, this key is allowed */
		allowed = 1;
d277 4
a280 3
	/* return key if allowed */
	if (allowed && rkey != NULL)
		*rkey = key;
a281 20
		key_free(key);
	return (allowed);
}

/*
 * Performs the RSA authentication dialog with the client.  This returns
 * 0 if the client could not be authenticated, and 1 if authentication was
 * successful.  This may exit if there is a serious protocol violation.
 */
int
auth_rsa(struct passwd *pw, BIGNUM *client_n)
{
	Key *key;
	char *fp;

	/* no user given */
	if (pw == NULL)
		return 0;

	if (!PRIVSEP(auth_rsa_key_allowed(pw, client_n, &key))) {
a282 26
		return (0);
	}

	/* Perform the challenge-response dialog for this key. */
	if (!auth_rsa_challenge_dialog(key)) {
		/* Wrong response. */
		verbose("Wrong response to RSA authentication challenge.");
		packet_send_debug("Wrong response to RSA authentication challenge.");
		/*
		 * Break out of the loop. Otherwise we might send
		 * another challenge and break the protocol.
		 */
		key_free(key);
		return (0);
	}
	/*
	 * Correct response.  The client has been successfully
	 * authenticated. Note that we have not yet processed the
	 * options; this will be reset if the options cause the
	 * authentication to be rejected.
	 */
	fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
	verbose("Found matching %s key: %s",
	    key_type(key), fp);
	xfree(fp);
	key_free(key);
d284 2
a285 2
	packet_send_debug("RSA authentication accepted.");
	return (1);
@


1.44.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.44.2.2 2002/05/17 00:03:23 miod Exp $");
d84 2
a85 2
		error("auth_rsa_verify_response: RSA modulus too small: %d < minimum %d bits",
		    BN_num_bits(key->rsa->n), SSH_RSA_MINIMUM_MODULUS_SIZE);
@


1.43
log
@terminate secure_filename checking after checking homedir.  that way it
works on AFS.  okay markus@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.42 2001/06/22 21:55:48 markus Exp $");
d226 1
a226 1
			log("Warning: %s, line %ld: keysize mismatch: "
@


1.42
log
@merge authorized_keys2 into authorized_keys.
authorized_keys2 is used for backward compat.
(just append authorized_keys2 to authorized_keys).
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.41 2001/05/20 17:20:35 markus Exp $");
d162 1
a162 1
	    secure_filename(f, file, pw->pw_uid, line, sizeof(line)) != 0) {
@


1.41
log
@configurable authorized_keys{,2} location; originally from peter@@; ok djm@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.40 2001/04/06 21:00:07 markus Exp $");
d214 1
a214 3
			debug("%.100s, line %lu: bad key syntax",
			    file, linenum);
			packet_send_debug("%.100s, line %lu: bad key syntax",
@


1.40
log
@do gid/groups-swap in addition to uid-swap, should help if /home/group
is chmod 750 + chgrp grp /home/group/, work be deraadt and me, thanks
to olar@@openwall.com is comments.  we had many requests for this.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.39 2001/03/01 02:45:10 deraadt Exp $");
d125 1
a125 1
	char line[8192], file[MAXPATHLEN];
d141 2
a142 2
	snprintf(file, sizeof file, "%.500s/%.100s", pw->pw_dir,
		 _PATH_SSH_USER_PERMITTED_KEYS);
d148 1
d158 1
d161 8
a168 35
	if (options.strict_modes) {
		int fail = 0;
		char buf[1024];
		/* Check open file in order to avoid open/stat races */
		if (fstat(fileno(f), &st) < 0 ||
		    (st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
		    (st.st_mode & 022) != 0) {
			snprintf(buf, sizeof buf, "RSA authentication refused for %.100s: "
				 "bad ownership or modes for '%s'.", pw->pw_name, file);
			fail = 1;
		} else {
			/* Check path to _PATH_SSH_USER_PERMITTED_KEYS */
			int i;
			static const char *check[] = {
				"", _PATH_SSH_USER_DIR, NULL
			};
			for (i = 0; check[i]; i++) {
				snprintf(line, sizeof line, "%.500s/%.100s", pw->pw_dir, check[i]);
				if (stat(line, &st) < 0 ||
				    (st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
				    (st.st_mode & 022) != 0) {
					snprintf(buf, sizeof buf, "RSA authentication refused for %.100s: "
						 "bad ownership or modes for '%s'.", pw->pw_name, line);
					fail = 1;
					break;
				}
			}
		}
		if (fail) {
			fclose(f);
			log("%s", buf);
			packet_send_debug("%s", buf);
			restore_uid();
			return 0;
		}
d263 1
@


1.40.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.44 2001/07/23 18:14:58 stevesk Exp $");
d125 1
a125 1
	char line[8192], *file;
d141 2
a142 2
	file = authorized_keys_file(pw);
	debug("trying public RSA key file %s", file);
a147 1
		xfree(file);
a156 1
		xfree(file);
d159 35
a193 8
	if (options.strict_modes &&
	    secure_filename(f, file, pw, line, sizeof(line)) != 0) {
		xfree(file);
		fclose(f);
		log("Authentication refused: %s", line);
		packet_send_debug("Authentication refused: %s", line);
		restore_uid();
		return 0;
d239 3
a241 1
			debug("%.100s, line %lu: non ssh1 key syntax",
d253 1
a253 1
			log("Warning: %s, line %lu: keysize mismatch: "
a287 1
	xfree(file);
@


1.40.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.50 2001/12/28 14:50:54 markus Exp $");
a33 1
#include "hostfile.h"
d68 1
a68 1
	int len;
d70 2
a71 4
	if ((encrypted_challenge = BN_new()) == NULL)
		fatal("auth_rsa_challenge_dialog: BN_new() failed");
	if ((challenge = BN_new()) == NULL)
		fatal("auth_rsa_challenge_dialog: BN_new() failed");
d75 1
a75 2
	if ((ctx = BN_CTX_new()) == NULL)
		fatal("auth_rsa_challenge_dialog: BN_CTX_new() failed");
d90 2
a91 1
	packet_read_expect(SSH_CMSG_AUTH_RSA_RESPONSE);
a93 1
	packet_check_eom();
d131 1
a131 2
	Key *key;
	char *fp;
d173 3
a175 1
	key = key_new(KEY_RSA1);
d213 1
a213 1
		if (hostfile_read_key(&cp, &bits, key) == 0) {
d221 1
a221 1
		if (BN_cmp(key->rsa->n, client_n) != 0)
d225 1
a225 1
		if (bits != BN_num_bits(key->rsa->n))
d228 1
a228 1
			    file, linenum, BN_num_bits(key->rsa->n), bits);
d239 1
a239 1
		if (!auth_rsa_challenge_dialog(key->rsa)) {
d243 1
a243 5
			/*
			 * Break out of the loop. Otherwise we might send
			 * another challenge and break the protocol.
			 */
			break;
a253 6

	 	fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
		verbose("Found matching %s key: %s",
		    key_type(key), fp);
		xfree(fp);

d264 1
a264 1
	key_free(key);
@


1.40.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.55 2002/03/29 19:18:33 stevesk Exp $");
a34 2
#include "monitor_wrap.h"
#include "ssh.h"
a54 52
BIGNUM *
auth_rsa_generate_challenge(Key *key)
{
	BIGNUM *challenge;
	BN_CTX *ctx;

	if ((challenge = BN_new()) == NULL)
		fatal("auth_rsa_generate_challenge: BN_new() failed");
	/* Generate a random challenge. */
	BN_rand(challenge, 256, 0, 0);
	if ((ctx = BN_CTX_new()) == NULL)
		fatal("auth_rsa_generate_challenge: BN_CTX_new() failed");
	BN_mod(challenge, challenge, key->rsa->n, ctx);
	BN_CTX_free(ctx);

	return challenge;
}

int
auth_rsa_verify_response(Key *key, BIGNUM *challenge, u_char response[16])
{
	u_char buf[32], mdbuf[16];
	MD5_CTX md;
	int len;

	/* don't allow short keys */
	if (BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE) {
		error("auth_rsa_verify_response: n too small: %d bits",
		    BN_num_bits(key->rsa->n));
		return (0);
	}

	/* The response is MD5 of decrypted challenge plus session id. */
	len = BN_num_bytes(challenge);
	if (len <= 0 || len > 32)
		fatal("auth_rsa_verify_response: bad challenge length %d", len);
	memset(buf, 0, 32);
	BN_bn2bin(challenge, buf + 32 - len);
	MD5_Init(&md);
	MD5_Update(&md, buf, 32);
	MD5_Update(&md, session_id, 16);
	MD5_Final(mdbuf, &md);

	/* Verify that the response is the original challenge. */
	if (memcmp(response, mdbuf, 16) != 0) {
		/* Wrong answer. */
		return (0);
	}
	/* Correct answer. */
	return (1);
}

d62 1
a62 1
auth_rsa_challenge_dialog(Key *key)
d65 5
a69 2
	u_char response[16];
	int i, success;
d73 2
d76 6
a81 1
	challenge = PRIVSEP(auth_rsa_generate_challenge(key));
d84 1
a84 1
	rsa_public_encrypt(encrypted_challenge, challenge, key->rsa);
d99 10
a108 1
	success = PRIVSEP(auth_rsa_verify_response(key, challenge, response));
d110 8
a117 1
	return (success);
d121 3
a123 2
 * check if there's user key matching client_n,
 * return key if login is allowed, NULL otherwise
d127 1
a127 1
auth_rsa_key_allowed(struct passwd *pw, BIGNUM *client_n, Key **rkey)
d130 1
a130 1
	int allowed = 0;
d136 5
d154 1
a154 1
		return (0);
d161 2
d164 1
a164 1
		return (0);
d171 1
d173 1
a173 1
		return (0);
d175 2
a176 3

	/* Flag indicating whether the key is allowed. */
	allowed = 0;
d241 26
a266 2
		/* break out, this key is allowed */
		allowed = 1;
d277 4
a280 3
	/* return key if allowed */
	if (allowed && rkey != NULL)
		*rkey = key;
a281 20
		key_free(key);
	return (allowed);
}

/*
 * Performs the RSA authentication dialog with the client.  This returns
 * 0 if the client could not be authenticated, and 1 if authentication was
 * successful.  This may exit if there is a serious protocol violation.
 */
int
auth_rsa(struct passwd *pw, BIGNUM *client_n)
{
	Key *key;
	char *fp;

	/* no user given */
	if (pw == NULL)
		return 0;

	if (!PRIVSEP(auth_rsa_key_allowed(pw, client_n, &key))) {
a282 26
		return (0);
	}

	/* Perform the challenge-response dialog for this key. */
	if (!auth_rsa_challenge_dialog(key)) {
		/* Wrong response. */
		verbose("Wrong response to RSA authentication challenge.");
		packet_send_debug("Wrong response to RSA authentication challenge.");
		/*
		 * Break out of the loop. Otherwise we might send
		 * another challenge and break the protocol.
		 */
		key_free(key);
		return (0);
	}
	/*
	 * Correct response.  The client has been successfully
	 * authenticated. Note that we have not yet processed the
	 * options; this will be reset if the options cause the
	 * authentication to be rejected.
	 */
	fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
	verbose("Found matching %s key: %s",
	    key_type(key), fp);
	xfree(fp);
	key_free(key);
d284 2
a285 2
	packet_send_debug("RSA authentication accepted.");
	return (1);
@


1.39
log
@KNF
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.38 2001/01/21 19:05:42 markus Exp $");
d138 1
a138 1
	temporarily_use_uid(pw->pw_uid);
@


1.38
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.37 2001/01/20 17:34:25 markus Exp $");
d189 2
a190 2
			log("%s",buf);
			packet_send_debug("%s",buf);
@


1.37
log
@typo
@
text
@d17 4
a20 1
RCSID("$OpenBSD: auth-rsa.c,v 1.36 2001/01/20 15:55:20 markus Exp $");
a24 1
#include "ssh.h"
a28 1
#include "servconf.h"
d31 3
a33 4

#include <openssl/rsa.h>
#include <openssl/md5.h>

@


1.36
log
@pass the filename to auth_parse_options()
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.35 2001/01/19 15:55:10 markus Exp $");
d125 1
a125 1
	char line[8192], file[MAXPATHNAME];
@


1.35
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.34 2000/12/19 23:17:55 markus Exp $");
d125 1
a125 1
	char line[8192], file[1024];
d240 1
a240 1
			      _PATH_SSH_USER_PERMITTED_KEYS, linenum);
d242 1
a242 1
					  _PATH_SSH_USER_PERMITTED_KEYS, linenum);
d262 1
a262 1
		if (!auth_parse_options(pw, options, linenum))
@


1.34
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.33 2000/11/14 23:42:40 markus Exp $");
d23 1
d29 1
d142 1
a142 1
		 SSH_USER_PERMITTED_KEYS);
d170 1
a170 1
			/* Check path to SSH_USER_PERMITTED_KEYS */
d173 1
a173 1
				"", SSH_USER_DIR, NULL
d240 1
a240 1
			      SSH_USER_PERMITTED_KEYS, linenum);
d242 1
a242 1
					  SSH_USER_PERMITTED_KEYS, linenum);
@


1.33
log
@parse options only if key matches; fixes some confusing messages seen by the client
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.32 2000/10/14 12:19:45 markus Exp $");
d40 1
a40 1
extern unsigned char session_id[16];
d63 1
a63 1
	unsigned char buf[32], mdbuf[16], response[16];
d65 1
a65 1
	unsigned int i;
d125 1
a125 1
	unsigned int bits;
d127 1
a127 1
	unsigned long linenum = 0;
@


1.32
log
@do not send RSA challenge if key is not allowed by key-options; from eivind@@ThinkSec.com
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.31 2000/10/11 19:59:52 markus Exp $");
a233 6
		/*
		 * If our options do not allow this key to be used,
		 * do not send challenge.
		 */
		if (!auth_parse_options(pw, options, linenum))
			continue;
d256 6
@


1.32.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d17 1
a17 4
RCSID("$OpenBSD: auth-rsa.c,v 1.38 2001/01/21 19:05:42 markus Exp $");

#include <openssl/rsa.h>
#include <openssl/md5.h>
d22 1
a22 1
#include "ssh1.h"
d26 1
d28 4
a31 4
#include "pathnames.h"
#include "log.h"
#include "servconf.h"
#include "auth.h"
d40 1
a40 1
extern u_char session_id[16];
d63 1
a63 1
	u_char buf[32], mdbuf[16], response[16];
d65 1
a65 1
	u_int i;
d123 1
a123 1
	char line[8192], file[MAXPATHLEN];
d125 1
a125 1
	u_int bits;
d127 1
a127 1
	u_long linenum = 0;
d140 1
a140 1
		 _PATH_SSH_USER_PERMITTED_KEYS);
d168 1
a168 1
			/* Check path to _PATH_SSH_USER_PERMITTED_KEYS */
d171 1
a171 1
				"", _PATH_SSH_USER_DIR, NULL
d234 6
d244 1
a244 1
			    file, linenum);
d246 1
a246 1
			    file, linenum);
a261 6
		/*
		 * If our options do not allow this key to be used,
		 * do not send challenge.
		 */
		if (!auth_parse_options(pw, options, file, linenum))
			continue;
@


1.32.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.32.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.39 2001/03/01 02:45:10 deraadt Exp $");
d189 2
a190 2
			log("%s", buf);
			packet_send_debug("%s", buf);
@


1.32.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.40 2001/04/06 21:00:07 markus Exp $");
d138 1
a138 1
	temporarily_use_uid(pw);
@


1.32.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.44 2001/07/23 18:14:58 stevesk Exp $");
d125 1
a125 1
	char line[8192], *file;
d141 2
a142 2
	file = authorized_keys_file(pw);
	debug("trying public RSA key file %s", file);
a147 1
		xfree(file);
a156 1
		xfree(file);
d159 35
a193 8
	if (options.strict_modes &&
	    secure_filename(f, file, pw, line, sizeof(line)) != 0) {
		xfree(file);
		fclose(f);
		log("Authentication refused: %s", line);
		packet_send_debug("Authentication refused: %s", line);
		restore_uid();
		return 0;
d239 3
a241 1
			debug("%.100s, line %lu: non ssh1 key syntax",
d253 1
a253 1
			log("Warning: %s, line %lu: keysize mismatch: "
a287 1
	xfree(file);
@


1.32.2.6
log
@Merge OpenSSH 3.1.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.50 2001/12/28 14:50:54 markus Exp $");
a33 1
#include "hostfile.h"
d68 1
a68 1
	int len;
d70 2
a71 4
	if ((encrypted_challenge = BN_new()) == NULL)
		fatal("auth_rsa_challenge_dialog: BN_new() failed");
	if ((challenge = BN_new()) == NULL)
		fatal("auth_rsa_challenge_dialog: BN_new() failed");
d75 1
a75 2
	if ((ctx = BN_CTX_new()) == NULL)
		fatal("auth_rsa_challenge_dialog: BN_CTX_new() failed");
d90 2
a91 1
	packet_read_expect(SSH_CMSG_AUTH_RSA_RESPONSE);
a93 1
	packet_check_eom();
d131 1
a131 2
	Key *key;
	char *fp;
d173 3
a175 1
	key = key_new(KEY_RSA1);
d213 1
a213 1
		if (hostfile_read_key(&cp, &bits, key) == 0) {
d221 1
a221 1
		if (BN_cmp(key->rsa->n, client_n) != 0)
d225 1
a225 1
		if (bits != BN_num_bits(key->rsa->n))
d228 1
a228 1
			    file, linenum, BN_num_bits(key->rsa->n), bits);
d239 1
a239 1
		if (!auth_rsa_challenge_dialog(key->rsa)) {
d243 1
a243 5
			/*
			 * Break out of the loop. Otherwise we might send
			 * another challenge and break the protocol.
			 */
			break;
a253 6

	 	fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
		verbose("Found matching %s key: %s",
		    key_type(key), fp);
		xfree(fp);

d264 1
a264 1
	key_free(key);
@


1.31
log
@clear auth options unless auth sucessfull
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.30 2000/10/03 18:03:03 markus Exp $");
d234 6
d278 2
a279 3
		authenticated = auth_parse_options(pw, options, linenum);
		if (authenticated)
			break;
@


1.30
log
@move fake-auth from auth1.c to individual auth methods, disables s/key in debug-msg
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.29 2000/09/07 21:13:36 markus Exp $");
d287 2
@


1.29
log
@some more Copyright fixes
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.28 2000/09/07 20:27:49 deraadt Exp $");
d32 4
a122 1
	extern ServerOptions options;
d130 4
@


1.28
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@a13 23
 *
 *
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.27 2000/07/07 03:55:03 todd Exp $");
@


1.27
log
@clean code is good code
@
text
@a1 3
 *
 * auth-rsa.c
 *
a2 1
 *
a4 3
 *
 * Created: Mon Mar 27 01:46:52 1995 ylo
 *
d9 28
d40 1
a40 1
RCSID("$OpenBSD: auth-rsa.c,v 1.25 2000/06/18 04:05:02 markus Exp $");
@


1.26
log
@OpenBSD tag
@
text
@d182 2
a183 2
			log(buf);
			packet_send_debug(buf);
@


1.25
log
@split auth-rsa option parsing into auth-options
add options support to authorized_keys2
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.24 2000/06/06 19:32:13 markus Exp $");
@


1.24
log
@fix match_hostname() logic for auth-rsa: deny access if we have a negative match or no match at all
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.23 2000/04/29 18:11:51 markus Exp $");
d29 1
a33 8
/* Flags that may be set in authorized_keys options. */
extern int no_port_forwarding_flag;
extern int no_agent_forwarding_flag;
extern int no_x11_forwarding_flag;
extern int no_pty_flag;
extern char *forced_command;
extern struct envstring *custom_environment;

a128 1
	int mname, mip;
a263 186
		 */
		authenticated = 1;

		/* RSA part of authentication was accepted.  Now process the options. */
		if (options) {
			while (*options && *options != ' ' && *options != '\t') {
				cp = "no-port-forwarding";
				if (strncmp(options, cp, strlen(cp)) == 0) {
					packet_send_debug("Port forwarding disabled.");
					no_port_forwarding_flag = 1;
					options += strlen(cp);
					goto next_option;
				}
				cp = "no-agent-forwarding";
				if (strncmp(options, cp, strlen(cp)) == 0) {
					packet_send_debug("Agent forwarding disabled.");
					no_agent_forwarding_flag = 1;
					options += strlen(cp);
					goto next_option;
				}
				cp = "no-X11-forwarding";
				if (strncmp(options, cp, strlen(cp)) == 0) {
					packet_send_debug("X11 forwarding disabled.");
					no_x11_forwarding_flag = 1;
					options += strlen(cp);
					goto next_option;
				}
				cp = "no-pty";
				if (strncmp(options, cp, strlen(cp)) == 0) {
					packet_send_debug("Pty allocation disabled.");
					no_pty_flag = 1;
					options += strlen(cp);
					goto next_option;
				}
				cp = "command=\"";
				if (strncmp(options, cp, strlen(cp)) == 0) {
					int i;
					options += strlen(cp);
					forced_command = xmalloc(strlen(options) + 1);
					i = 0;
					while (*options) {
						if (*options == '"')
							break;
						if (*options == '\\' && options[1] == '"') {
							options += 2;
							forced_command[i++] = '"';
							continue;
						}
						forced_command[i++] = *options++;
					}
					if (!*options) {
						debug("%.100s, line %lu: missing end quote",
						      SSH_USER_PERMITTED_KEYS, linenum);
						packet_send_debug("%.100s, line %lu: missing end quote",
								  SSH_USER_PERMITTED_KEYS, linenum);
						continue;
					}
					forced_command[i] = 0;
					packet_send_debug("Forced command: %.900s", forced_command);
					options++;
					goto next_option;
				}
				cp = "environment=\"";
				if (strncmp(options, cp, strlen(cp)) == 0) {
					int i;
					char *s;
					struct envstring *new_envstring;
					options += strlen(cp);
					s = xmalloc(strlen(options) + 1);
					i = 0;
					while (*options) {
						if (*options == '"')
							break;
						if (*options == '\\' && options[1] == '"') {
							options += 2;
							s[i++] = '"';
							continue;
						}
						s[i++] = *options++;
					}
					if (!*options) {
						debug("%.100s, line %lu: missing end quote",
						      SSH_USER_PERMITTED_KEYS, linenum);
						packet_send_debug("%.100s, line %lu: missing end quote",
								  SSH_USER_PERMITTED_KEYS, linenum);
						continue;
					}
					s[i] = 0;
					packet_send_debug("Adding to environment: %.900s", s);
					debug("Adding to environment: %.900s", s);
					options++;
					new_envstring = xmalloc(sizeof(struct envstring));
					new_envstring->s = s;
					new_envstring->next = custom_environment;
					custom_environment = new_envstring;
					goto next_option;
				}
				cp = "from=\"";
				if (strncmp(options, cp, strlen(cp)) == 0) {
					char *patterns = xmalloc(strlen(options) + 1);
					int i;
					options += strlen(cp);
					i = 0;
					while (*options) {
						if (*options == '"')
							break;
						if (*options == '\\' && options[1] == '"') {
							options += 2;
							patterns[i++] = '"';
							continue;
						}
						patterns[i++] = *options++;
					}
					if (!*options) {
						debug("%.100s, line %lu: missing end quote",
						      SSH_USER_PERMITTED_KEYS, linenum);
						packet_send_debug("%.100s, line %lu: missing end quote",
								  SSH_USER_PERMITTED_KEYS, linenum);
						continue;
					}
					patterns[i] = 0;
					options++;
					/*
					 * Deny access if we get a negative
					 * match for the hostname or the ip
					 * or if we get not match at all
					 */
					mname = match_hostname(get_canonical_hostname(),
					    patterns, strlen(patterns));
					mip = match_hostname(get_remote_ipaddr(),
					    patterns, strlen(patterns));
					if (mname == -1 || mip == -1 ||
					    (mname != 1 && mip != 1)) {
						log("RSA authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
						    pw->pw_name, get_canonical_hostname(),
						    get_remote_ipaddr());
						packet_send_debug("Your host '%.200s' is not permitted to use this key for login.",
						get_canonical_hostname());
						xfree(patterns);
						/* key invalid for this host, reset flags */
						authenticated = 0;
						no_agent_forwarding_flag = 0;
						no_port_forwarding_flag = 0;
						no_pty_flag = 0;
						no_x11_forwarding_flag = 0;
						while (custom_environment) {
							struct envstring *ce = custom_environment;
							custom_environment = ce->next;
							xfree(ce->s);
							xfree(ce);
						}
						if (forced_command) {
							xfree(forced_command);
							forced_command = NULL;
						}
						break;
					}
					xfree(patterns);
					/* Host name matches. */
					goto next_option;
				}
		bad_option:
				log("Bad options in %.100s file, line %lu: %.50s",
				    SSH_USER_PERMITTED_KEYS, linenum, options);
				packet_send_debug("Bad options in %.100s file, line %lu: %.50s",
						  SSH_USER_PERMITTED_KEYS, linenum, options);
				authenticated = 0;
				break;

		next_option:
				/*
				 * Skip the comma, and move to the next option
				 * (or break out if there are no more).
				 */
				if (!*options)
					fatal("Bugs in auth-rsa.c option processing.");
				if (*options == ' ' || *options == '\t')
					break;		/* End of options. */
				if (*options != ',')
					goto bad_option;
				options++;
				/* Process the next option. */
				continue;
			}
		}
		/*
d267 1
@


1.23
log
@keysize warnings error() -> log()
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.22 2000/04/26 20:48:42 markus Exp $");
d136 1
d394 11
a404 4
					if (!match_hostname(get_canonical_hostname(), patterns,
						     strlen(patterns)) &&
					    !match_hostname(get_remote_ipaddr(), patterns,
						     strlen(patterns))) {
@


1.23.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.24 2000/06/06 19:32:13 markus Exp $");
a135 1
	int mname, mip;
d393 4
a396 11
					/*
					 * Deny access if we get a negative
					 * match for the hostname or the ip
					 * or if we get not match at all
					 */
					mname = match_hostname(get_canonical_hostname(),
					    patterns, strlen(patterns));
					mip = match_hostname(get_remote_ipaddr(),
					    patterns, strlen(patterns));
					if (mname == -1 || mip == -1 ||
					    (mname != 1 && mip != 1)) {
@


1.23.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d19 1
a19 1
RCSID("$OpenBSD: auth-rsa.c,v 1.27 2000/07/07 03:55:03 todd Exp $");
a28 1
#include "auth-options.h"
d33 8
d136 1
d190 2
a191 2
			log("%s",buf);
			packet_send_debug("%s",buf);
d272 186
a460 1
		authenticated = auth_parse_options(pw, options, linenum);
@


1.23.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a15 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d19 1
a19 1
RCSID("$OpenBSD: auth-rsa.c,v 1.32 2000/10/14 12:19:45 markus Exp $");
a33 4

/* import */
extern ServerOptions options;

d121 1
a129 4
	/* no user given */
	if (pw == NULL)
		return 0;

a228 6
		/*
		 * If our options do not allow this key to be used,
		 * do not send challenge.
		 */
		if (!auth_parse_options(pw, options, linenum))
			continue;
d267 3
a269 2
		authenticated = 1;
		break;
a281 2
	else
		auth_clear_options();
@


1.23.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d17 1
a17 4
RCSID("$OpenBSD: auth-rsa.c,v 1.38 2001/01/21 19:05:42 markus Exp $");

#include <openssl/rsa.h>
#include <openssl/md5.h>
d22 1
a22 1
#include "ssh1.h"
d26 1
d28 4
a31 4
#include "pathnames.h"
#include "log.h"
#include "servconf.h"
#include "auth.h"
d40 1
a40 1
extern u_char session_id[16];
d63 1
a63 1
	u_char buf[32], mdbuf[16], response[16];
d65 1
a65 1
	u_int i;
d123 1
a123 1
	char line[8192], file[MAXPATHLEN];
d125 1
a125 1
	u_int bits;
d127 1
a127 1
	u_long linenum = 0;
d140 1
a140 1
		 _PATH_SSH_USER_PERMITTED_KEYS);
d168 1
a168 1
			/* Check path to _PATH_SSH_USER_PERMITTED_KEYS */
d171 1
a171 1
				"", _PATH_SSH_USER_DIR, NULL
d234 6
d244 1
a244 1
			    file, linenum);
d246 1
a246 1
			    file, linenum);
a261 6
		/*
		 * If our options do not allow this key to be used,
		 * do not send challenge.
		 */
		if (!auth_parse_options(pw, options, file, linenum))
			continue;
@


1.23.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.39 2001/03/01 02:45:10 deraadt Exp $");
d189 2
a190 2
			log("%s", buf);
			packet_send_debug("%s", buf);
@


1.22
log
@missing fclose
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.21 2000/04/14 10:30:29 markus Exp $");
a257 1

@


1.21
log
@whitespace cleanup
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.20 2000/04/12 09:39:09 markus Exp $");
d188 1
@


1.20
log
@#include <ssl/foo.h> -> <openssh/foo.h>
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d15 1
a15 1
 * 
d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.19 2000/03/23 22:15:33 markus Exp $");
d241 1
a241 1
				          SSH_USER_PERMITTED_KEYS, linenum);
@


1.19
log
@initial support for DSA keys. ok deraadt@@, niels@@
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.4 2000/02/11 11:12:40 markus Exp $");
d30 2
a31 2
#include <ssl/rsa.h>
#include <ssl/md5.h>
@


1.18
log
@delay MD5 computation until client sends response, free() early, cleanup.
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.17 2000/01/18 09:41:05 markus Exp $");
d27 1
d64 1
a64 1
auth_rsa_challenge_dialog(BIGNUM *e, BIGNUM *n)
a66 1
	RSA *pk;
d79 1
a79 1
	BN_mod(challenge, challenge, n, ctx);
a81 7
	/* Create the public key data structure. */
	pk = RSA_new();
	pk->e = BN_new();
	BN_copy(pk->e, e);
	pk->n = BN_new();
	BN_copy(pk->n, n);

a83 1
	RSA_free(pk);
d135 1
a135 1
	BIGNUM *e, *n;
d197 3
a199 2
	e = BN_new();
	n = BN_new();
d237 1
a237 1
		if (!auth_rsa_read_key(&cp, &bits, e, n)) {
d247 1
a247 1
		if (BN_cmp(n, client_n) != 0)
d251 1
a251 1
		if (bits != BN_num_bits(n))
d254 1
a254 1
			    file, linenum, BN_num_bits(n), bits);
d258 1
d260 1
a260 1
		if (!auth_rsa_challenge_dialog(e, n)) {
d463 1
a463 2
	BN_clear_free(n);
	BN_clear_free(e);
@


1.17
log
@fix user/1056, sshd keeps restrictions; dbt@@meat.net
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.16 1999/12/02 23:05:08 markus Exp $");
d65 1
a65 1
	BIGNUM *challenge, *encrypted_challenge, *aux;
d67 1
a67 1
	BN_CTX *ctx = BN_CTX_new();
a74 1
	aux = BN_new();
d78 1
d80 1
d97 1
d100 6
a115 3

	/* We will no longer need these. */
	BN_clear_free(encrypted_challenge);
a116 8
	BN_clear_free(aux);
	BN_CTX_free(ctx);

	/* Wait for a response. */
	packet_read_expect(&plen, SSH_CMSG_AUTH_RSA_RESPONSE);
	packet_integrity_check(plen, 16, SSH_CMSG_AUTH_RSA_RESPONSE);
	for (i = 0; i < 16; i++)
		response[i] = packet_get_char();
@


1.16
log
@warn only about mismatch if key is _used_
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.15 1999/12/02 20:17:49 markus Exp $");
d412 1
d414 14
@


1.15
log
@warn about keysize-mismatch with log() not error()
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.14 1999/11/24 19:53:44 markus Exp $");
d256 4
a264 4

		/* Check if the we have found the desired key (identified by its modulus). */
		if (BN_cmp(n, client_n) != 0)
			continue;
@


1.14
log
@KNF, final part 3
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.13 1999/11/24 00:26:00 deraadt Exp $");
d258 3
a260 3
			error("Warning: error in %s, line %ld: keysize mismatch: "
			      "actual size %d vs. announced %d.",
			      file, linenum, BN_num_bits(n), bits);
@


1.13
log
@much more KNF
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.12 1999/11/23 22:25:52 markus Exp $");
d40 4
a43 2
/* Session identifier that is used to bind key exchange and authentication
   responses to a particular session. */
d46 15
a60 12
/* The .ssh/authorized_keys file contains public keys, one per line, in the
   following format:
     options bits e n comment
   where bits, e and n are decimal numbers,
   and comment is any string of characters up to newline.  The maximum
   length of a line is 8000 characters.  See the documentation for a
   description of the options.
*/

/* Performs the RSA authentication challenge-response dialog with the client,
   and returns true (non-zero) if the client gave the correct answer to
   our challenge; returns zero if the client gives a wrong answer. */
d130 5
a134 3
/* Performs the RSA authentication dialog with the client.  This returns
   0 if the client could not be authenticated, and 1 if authentication was
   successful.  This may exit if there is a serious protocol violation. */
a207 1
	/* Initialize mp-int variables. */
d211 5
a215 3
	/* Go though the accepted keys, looking for the current key.  If
	   found, perform a challenge-response dialog to verify that the
	   user really has the corresponding private key. */
d222 3
a224 4
		/* Skip leading whitespace. */
		for (cp = line; *cp == ' ' || *cp == '\t'; cp++);

		/* Skip empty and comment lines. */
d228 6
a233 4
		/* Check if there are options for this key, and if so,
		   save their starting address and skip the option part
		   for now.  If there are no options, set the starting
		   address to NULL. */
d264 1
a264 1
			continue;	/* Wrong key. */
d275 6
a280 4
		/* Correct response.  The client has been successfully
		   authenticated. Note that we have not yet processed the
		   options; this will be reset if the options cause the
		   authentication to be rejected. */
a419 1
				/* Unknown option. */
d428 4
a431 2
				/* Skip the comma, and move to the next option
				   (or break out if there are no more). */
d435 1
a435 1
					break;	/* End of options. */
d443 4
a446 2
		/* Break out of the loop if authentication was successful;
		   otherwise continue searching. */
a456 1
	/* Clear any mp-int variables. */
@


1.12
log
@KNF part 1
@
text
@d2 15
a16 15

auth-rsa.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Mon Mar 27 01:46:52 1995 ylo

RSA-based authentication.  This code determines whether to admit a login
based on RSA authentication.  This file also contains functions to check
validity of the host key.

*/
d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.11 1999/11/22 21:02:38 markus Exp $");
@


1.11
log
@syslog changes:
* Unified Logmessage for all auth-types, for success and for failed
* Standard connections get only ONE line in the LOG when level==LOG:
  Auth-attempts are logged only, if authentication is:
        a) successfull or
        b) with passwd or
        c) we had more than AUTH_FAIL_LOG failues
* many log() became verbose()
* old behaviour with level=VERBOSE
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.10 1999/11/18 14:00:48 markus Exp $");
d47 1
a47 1
   where bits, e and n are decimal numbers, 
d60 63
a122 65
  BIGNUM *challenge, *encrypted_challenge, *aux;
  RSA *pk;
  BN_CTX *ctx = BN_CTX_new();
  unsigned char buf[32], mdbuf[16], response[16];
  MD5_CTX md;
  unsigned int i;
  int plen, len;

  encrypted_challenge = BN_new();
  challenge = BN_new();
  aux = BN_new();

  /* Generate a random challenge. */
  BN_rand(challenge, 256, 0, 0);
  BN_mod(challenge, challenge, n, ctx);
  
  /* Create the public key data structure. */
  pk = RSA_new();
  pk->e = BN_new();
  BN_copy(pk->e, e);
  pk->n = BN_new();
  BN_copy(pk->n, n);

  /* Encrypt the challenge with the public key. */
  rsa_public_encrypt(encrypted_challenge, challenge, pk);
  RSA_free(pk);

  /* Send the encrypted challenge to the client. */
  packet_start(SSH_SMSG_AUTH_RSA_CHALLENGE);
  packet_put_bignum(encrypted_challenge);
  packet_send();
  packet_write_wait();

  /* The response is MD5 of decrypted challenge plus session id. */
  len = BN_num_bytes(challenge);
  if (len <= 0 || len > 32)
    fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
  memset(buf, 0, 32);
  BN_bn2bin(challenge, buf + 32 - len);
  MD5_Init(&md);
  MD5_Update(&md, buf, 32);
  MD5_Update(&md, session_id, 16);
  MD5_Final(mdbuf, &md);

  /* We will no longer need these. */
  BN_clear_free(encrypted_challenge);
  BN_clear_free(challenge);
  BN_clear_free(aux);
  BN_CTX_free(ctx);
  
  /* Wait for a response. */
  packet_read_expect(&plen, SSH_CMSG_AUTH_RSA_RESPONSE);
  packet_integrity_check(plen, 16, SSH_CMSG_AUTH_RSA_RESPONSE);
  for (i = 0; i < 16; i++)
    response[i] = packet_get_char();

  /* Verify that the response is the original challenge. */
  if (memcmp(response, mdbuf, 16) != 0)
    {
      /* Wrong answer. */
      return 0;
    }

  /* Correct answer. */
  return 1;
d132 30
a161 111
  extern ServerOptions options;
  char line[8192], file[1024];
  int authenticated;
  unsigned int bits;
  FILE *f;
  unsigned long linenum = 0;
  struct stat st;
  BIGNUM *e, *n;

  /* Temporarily use the user's uid. */
  temporarily_use_uid(pw->pw_uid);

  /* The authorized keys. */
  snprintf(file, sizeof file, "%.500s/%.100s", pw->pw_dir,
    SSH_USER_PERMITTED_KEYS);
  
  /* Fail quietly if file does not exist */
  if (stat(file, &st) < 0)
    {
      /* Restore the privileged uid. */
      restore_uid();
      return 0;
    }

  /* Open the file containing the authorized keys. */
  f = fopen(file, "r");
  if (!f)
    {
      /* Restore the privileged uid. */
      restore_uid();
      packet_send_debug("Could not open %.900s for reading.", file);
      packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
      return 0;
    }

  if (options.strict_modes) {
    int fail=0;
    char buf[1024];
    /* Check open file in order to avoid open/stat races */
    if (fstat(fileno(f), &st) < 0 ||
        (st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
        (st.st_mode & 022) != 0) {
      snprintf(buf, sizeof buf, "RSA authentication refused for %.100s: "
               "bad ownership or modes for '%s'.", pw->pw_name, file);
      fail=1;
    }else{
      /* Check path to SSH_USER_PERMITTED_KEYS */
      int i;
      static const char *check[] = {
            "", SSH_USER_DIR, NULL
      };
      for (i=0; check[i]; i++) {
        snprintf(line, sizeof line, "%.500s/%.100s", pw->pw_dir, check[i]);
        if (stat(line, &st) < 0 ||
            (st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
            (st.st_mode & 022) != 0) {
          snprintf(buf, sizeof buf, "RSA authentication refused for %.100s: "
                   "bad ownership or modes for '%s'.", pw->pw_name, line);
          fail=1;
          break;
        }
      }
    }
    if (fail) {
      log(buf);
      packet_send_debug(buf);
      restore_uid();
      return 0;
    }
  } 

  /* Flag indicating whether authentication has succeeded. */
  authenticated = 0;
  
  /* Initialize mp-int variables. */
  e = BN_new();
  n = BN_new();

  /* Go though the accepted keys, looking for the current key.  If found,
     perform a challenge-response dialog to verify that the user really has
     the corresponding private key. */
  while (fgets(line, sizeof(line), f))
    {
      char *cp;
      char *options;

      linenum++;

      /* Skip leading whitespace. */
      for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
	;

      /* Skip empty and comment lines. */
      if (!*cp || *cp == '\n' || *cp == '#')
	continue;

      /* Check if there are options for this key, and if so, save their 
	 starting address and skip the option part for now.  If there are no 
	 options, set the starting address to NULL. */
      if (*cp < '0' || *cp > '9')
	{
	  int quoted = 0;
	  options = cp;
	  for (; *cp && (quoted || (*cp != ' ' && *cp != '\t')); cp++)
	    {
	      if (*cp == '\\' && cp[1] == '"')
		cp++; /* Skip both */
	      else
		if (*cp == '"')
		  quoted = !quoted;
	    }
d163 34
a196 11
      else
	options = NULL;
      
      /* Parse the key from the line. */
      if (!auth_rsa_read_key(&cp, &bits, e, n))
	{
	  debug("%.100s, line %lu: bad key syntax", 
		SSH_USER_PERMITTED_KEYS, linenum);
	  packet_send_debug("%.100s, line %lu: bad key syntax", 
			    SSH_USER_PERMITTED_KEYS, linenum);
	  continue;
d198 2
a199 1
      /* cp now points to the comment part. */
d201 35
a235 21
      /* check the real bits  */
      if (bits != BN_num_bits(n))
        error("Warning: error in %s, line %ld: keysize mismatch: "
              "actual size %d vs. announced %d.",
              file, linenum, BN_num_bits(n), bits);

      /* Check if the we have found the desired key (identified by its
	 modulus). */
      if (BN_cmp(n, client_n) != 0)
	continue; /* Wrong key. */

      /* We have found the desired key. */

      /* Perform the challenge-response dialog for this key. */
      if (!auth_rsa_challenge_dialog(e, n))
	{
	  /* Wrong response. */
	  verbose("Wrong response to RSA authentication challenge.");
	  packet_send_debug("Wrong response to RSA authentication challenge.");
	  continue;
	}
d237 7
a243 17
      /* Correct response.  The client has been successfully authenticated.
	 Note that we have not yet processed the options; this will be reset
	 if the options cause the authentication to be rejected. */
      authenticated = 1;

      /* RSA part of authentication was accepted.  Now process the options. */
      if (options)
	{
	  while (*options && *options != ' ' && *options != '\t')
	    {
	      cp = "no-port-forwarding";
	      if (strncmp(options, cp, strlen(cp)) == 0)
		{
		  packet_send_debug("Port forwarding disabled.");
		  no_port_forwarding_flag = 1;
		  options += strlen(cp);
		  goto next_option;
d245 20
a264 15
	      cp = "no-agent-forwarding";
	      if (strncmp(options, cp, strlen(cp)) == 0)
		{
		  packet_send_debug("Agent forwarding disabled.");
		  no_agent_forwarding_flag = 1;
		  options += strlen(cp);
		  goto next_option;
		}
	      cp = "no-X11-forwarding";
	      if (strncmp(options, cp, strlen(cp)) == 0)
		{
		  packet_send_debug("X11 forwarding disabled.");
		  no_x11_forwarding_flag = 1;
		  options += strlen(cp);
		  goto next_option;
d266 163
a428 58
	      cp = "no-pty";
	      if (strncmp(options, cp, strlen(cp)) == 0)
		{
		  packet_send_debug("Pty allocation disabled.");
		  no_pty_flag = 1;
		  options += strlen(cp);
		  goto next_option;
		}
	      cp = "command=\"";
	      if (strncmp(options, cp, strlen(cp)) == 0)
		{
		  int i;
		  options += strlen(cp);
		  forced_command = xmalloc(strlen(options) + 1);
		  i = 0;
		  while (*options)
		    {
		      if (*options == '"')
			break;
		      if (*options == '\\' && options[1] == '"')
			{
			  options += 2;
			  forced_command[i++] = '"';
			  continue;
			}
		      forced_command[i++] = *options++;
		    }
		  if (!*options)
		    {
		      debug("%.100s, line %lu: missing end quote",
			    SSH_USER_PERMITTED_KEYS, linenum);
		      packet_send_debug("%.100s, line %lu: missing end quote",
					SSH_USER_PERMITTED_KEYS, linenum);
		      continue;
		    }
		  forced_command[i] = 0;
		  packet_send_debug("Forced command: %.900s", forced_command);
		  options++;
		  goto next_option;
		}
	      cp = "environment=\"";
	      if (strncmp(options, cp, strlen(cp)) == 0)
		{
		  int i;
		  char *s;
		  struct envstring *new_envstring;
		  options += strlen(cp);
		  s = xmalloc(strlen(options) + 1);
		  i = 0;
		  while (*options)
		    {
		      if (*options == '"')
			break;
		      if (*options == '\\' && options[1] == '"')
			{
			  options += 2;
			  s[i++] = '"';
			  continue;
a429 19
		      s[i++] = *options++;
		    }
		  if (!*options)
		    {
		      debug("%.100s, line %lu: missing end quote",
			    SSH_USER_PERMITTED_KEYS, linenum);
		      packet_send_debug("%.100s, line %lu: missing end quote",
					SSH_USER_PERMITTED_KEYS, linenum);
		      continue;
		    }
		  s[i] = 0;
		  packet_send_debug("Adding to environment: %.900s", s);
		  debug("Adding to environment: %.900s", s);
		  options++;
		  new_envstring = xmalloc(sizeof(struct envstring));
		  new_envstring->s = s;
		  new_envstring->next = custom_environment;
		  custom_environment = new_envstring;
		  goto next_option;
d431 3
a433 10
	      cp = "from=\"";
	      if (strncmp(options, cp, strlen(cp)) == 0)
		{
		  char *patterns = xmalloc(strlen(options) + 1);
		  int i;
		  options += strlen(cp);
		  i = 0;
		  while (*options)
		    {
		      if (*options == '"')
a434 58
		      if (*options == '\\' && options[1] == '"')
			{
			  options += 2;
			  patterns[i++] = '"';
			  continue;
			}
		      patterns[i++] = *options++;
		    }
		  if (!*options)
		    {
		      debug("%.100s, line %lu: missing end quote",
			    SSH_USER_PERMITTED_KEYS, linenum);
		      packet_send_debug("%.100s, line %lu: missing end quote",
					SSH_USER_PERMITTED_KEYS, linenum);
		      continue;
		    }
		  patterns[i] = 0;
		  options++;
		  if (!match_hostname(get_canonical_hostname(), patterns,
				     strlen(patterns)) &&
		      !match_hostname(get_remote_ipaddr(), patterns,
				      strlen(patterns)))
		    {
		      log("RSA authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
			  pw->pw_name, get_canonical_hostname(),
			  get_remote_ipaddr());
		      packet_send_debug("Your host '%.200s' is not permitted to use this key for login.",
					get_canonical_hostname());
		      xfree(patterns);
		      authenticated = 0;
		      break;
		    }
		  xfree(patterns);
		  /* Host name matches. */
		  goto next_option;
		}
	    bad_option:
	      /* Unknown option. */
	      log("Bad options in %.100s file, line %lu: %.50s",
		  SSH_USER_PERMITTED_KEYS, linenum, options);
	      packet_send_debug("Bad options in %.100s file, line %lu: %.50s",
				SSH_USER_PERMITTED_KEYS, linenum, options);
	      authenticated = 0;
	      break;

	    next_option:
	      /* Skip the comma, and move to the next option (or break out
		 if there are no more). */
	      if (!*options)
		fatal("Bugs in auth-rsa.c option processing.");
	      if (*options == ' ' || *options == '\t')
		break; /* End of options. */
	      if (*options != ',')
		goto bad_option;
	      options++;
	      /* Process the next option. */
	      continue;
	    }
d437 9
a445 15
      /* Break out of the loop if authentication was successful; otherwise
	 continue searching. */
      if (authenticated)
	break;
    }

  /* Restore the privileged uid. */
  restore_uid();

  /* Close the file. */
  fclose(f);
  
  /* Clear any mp-int variables. */
  BN_clear_free(n);
  BN_clear_free(e);
d447 2
a448 2
  if (authenticated)
    packet_send_debug("RSA authentication accepted.");
d450 2
a451 2
  /* Return authentication result. */
  return authenticated;
@


1.10
log
@more %d vs. %s in fmt-strings
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.9 1999/11/15 20:53:24 markus Exp $");
d277 1
a277 1
	  log("Wrong response to RSA authentication challenge.");
@


1.9
log
@the keysize of rsa-parameter 'n' is passed implizit,
a few more checks and warnings about 'pretended' keysizes.
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.8 1999/11/11 23:36:52 markus Exp $");
d262 1
a262 1
        error("Warning: error in %s, line %d: keysize mismatch: "
@


1.8
log
@make all access to options via 'extern Options options'
and 'extern ServerOptions options' respectively;
options are no longer passed as arguments:
 * make options handling more consistent
 * remove #include "readconf.h" from ssh.h
 * readconf.h is only included if necessary
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.7 1999/11/02 19:42:34 markus Exp $");
d58 1
a58 1
auth_rsa_challenge_dialog(unsigned int bits, BIGNUM *e, BIGNUM *n)
d135 1
a135 1
  char line[8192];
d147 1
a147 1
  snprintf(line, sizeof line, "%.500s/%.100s", pw->pw_dir,
d151 1
a151 1
  if (stat(line, &st) < 0)
d159 1
a159 1
  f = fopen(line, "r");
d164 1
a164 1
      packet_send_debug("Could not open %.900s for reading.", line);
d177 1
a177 1
               "bad ownership or modes for '%s'.", pw->pw_name, line);
d260 6
d274 1
a274 1
      if (!auth_rsa_challenge_dialog(bits, e, n))
@


1.7
log
@replace assert() with error, fatal or packet_disconnect
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.6 1999/10/27 16:37:45 deraadt Exp $");
d27 1
d132 1
a132 1
auth_rsa(struct passwd *pw, BIGNUM *client_n, int strict_modes)
d134 1
d169 1
a169 1
  if (strict_modes) {
@


1.6
log
@use libssl md5 routines
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.5 1999/10/18 01:54:18 provos Exp $");
d94 2
a95 1
  assert(len <= 32 && len);
@


1.5
log
@the session key is only the least significant 256-bits, mask the rest away
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.4 1999/10/11 20:00:35 markus Exp $");
d29 1
a29 1
#include <md5.h>
d97 4
a100 4
  MD5Init(&md);
  MD5Update(&md, buf, 32);
  MD5Update(&md, session_id, 16);
  MD5Final(mdbuf, &md);
@


1.4
log
@make sure ~/.ssh/authorized_keys is not writable for group/world (sshd)
don't load private keys if they are group/world-{rwx} (ssh,sshd and ssh-add)
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.3 1999/09/30 17:08:51 deraadt Exp $");
d93 1
a93 1
  len = (BN_num_bits(challenge) + 7) / 8;
@


1.3
log
@use libc md5
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.2 1999/09/29 21:14:15 deraadt Exp $");
d130 1
a130 1
auth_rsa(struct passwd *pw, BIGNUM *client_n)
d140 4
a143 1
  /* Open the file containing the authorized keys. */
d147 1
a147 2
  /* Temporarily use the user's uid. */
  temporarily_use_uid(pw->pw_uid);
d154 2
d165 36
@


1.2
log
@numerous sprintf, strncpy, strcpy cleanups
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.1 1999/09/28 04:45:35 provos Exp $");
a24 1
#include "ssh_md5.h"
d29 1
d63 1
a63 1
  struct MD5Context md;
@


1.1
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d19 1
a19 1
RCSID("$Id: auth-rsa.c,v 1.4 1999/06/14 14:41:35 bg Exp $");
d141 2
a142 1
  sprintf(line, "%.500s/%.100s", pw->pw_dir, SSH_USER_PERMITTED_KEYS);
@

