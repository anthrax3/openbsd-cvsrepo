head	1.22;
access;
symbols
	OPENBSD_6_0:1.21.0.10
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.6
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.16
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.14
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.12
	OPENBSD_5_0:1.16.0.10
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.8
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.6
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.4
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.4
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.8.0.8
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.6
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_2_9:1.5.0.2
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4;
locks; strict;
comment	@ * @;


1.22
date	2016.09.28.16.33.07;	author djm;	state dead;
branches;
next	1.21;
commitid	e2NJzal9PUi2o22D;

1.21
date	2015.02.06.23.21.59;	author millert;	state Exp;
branches;
next	1.20;
commitid	STdsVrA5MGLlnbLm;

1.20
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	cBx23BaCk6gYBpRj;

1.19
date	2014.01.04.17.50.55;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2013.11.08.00.39.15;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2009.06.22.05.39.28;	author dtucker;	state Exp;
branches
	1.16.16.1;
next	1.15;

1.15
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.12;

1.12
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.11.19.01.43;	author deraadt;	state Exp;
branches
	1.9.6.1
	1.9.8.1;
next	1.8;

1.8
date	2002.08.02.14.43.15;	author millert;	state Exp;
branches
	1.8.6.1
	1.8.8.1;
next	1.7;

1.7
date	2002.06.28.01.49.31;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.04.23.05.49;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.28.16.45.27;	author stevesk;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.03.25.20.12.10;	author stevesk;	state Exp;
branches
	1.4.2.1
	1.4.4.1;
next	1.3;

1.3
date	2002.03.19.10.41.32;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.19.10.35.39;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.03.18.17.26.58;	author provos;	state Exp;
branches;
next	;

1.4.2.1
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	;

1.4.4.1
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.5.2.1
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.8.6.1
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.8.8.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	;

1.9.6.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.9.8.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;

1.16.16.1
date	2013.11.08.05.52.21;	author djm;	state Exp;
branches;
next	;

1.17.2.1
date	2013.11.08.01.33.56;	author djm;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Remove support for pre-authentication compression. Doing compression
early in the protocol probably seemed reasonable in the 1990s, but
today it's clearly a bad idea in terms of both cryptography (cf.
multiple compression oracle attacks in TLS) and attack surface.

Moreover, to support it across privilege-separation zlib needed
the assistance of a complex shared-memory manager that made the
required attack surface considerably larger.

Prompted by Guido Vranken pointing out a compiler-elided security
check in the shared memory manager found by Stack
(http://css.csail.mit.edu/stack/); ok deraadt@@ markus@@

NB. pre-auth authentication has been disabled by default in sshd
for >10 years.
@
text
@/* $OpenBSD: monitor_mm.c,v 1.21 2015/02/06 23:21:59 millert Exp $ */
/*
 * Copyright 2002 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/tree.h>

#include <errno.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "xmalloc.h"
#include "ssh.h"
#include "log.h"
#include "monitor_mm.h"

static int
mm_compare(struct mm_share *a, struct mm_share *b)
{
	ptrdiff_t diff = (char *)a->address - (char *)b->address;

	if (diff == 0)
		return (0);
	else if (diff < 0)
		return (-1);
	else
		return (1);
}

RB_GENERATE(mmtree, mm_share, next, mm_compare)

static struct mm_share *
mm_make_entry(struct mm_master *mm, struct mmtree *head,
    void *address, size_t size)
{
	struct mm_share *tmp, *tmp2;

	if (mm->mmalloc == NULL)
		tmp = xcalloc(1, sizeof(struct mm_share));
	else
		tmp = mm_xmalloc(mm->mmalloc, sizeof(struct mm_share));
	tmp->address = address;
	tmp->size = size;

	tmp2 = RB_INSERT(mmtree, head, tmp);
	if (tmp2 != NULL)
		fatal("mm_make_entry(%p): double address %p->%p(%zu)",
		    mm, tmp2, address, size);

	return (tmp);
}

/* Creates a shared memory area of a certain size */

struct mm_master *
mm_create(struct mm_master *mmalloc, size_t size)
{
	void *address;
	struct mm_master *mm;

	if (mmalloc == NULL)
		mm = xcalloc(1, sizeof(struct mm_master));
	else
		mm = mm_xmalloc(mmalloc, sizeof(struct mm_master));

	/*
	 * If the memory map has a mm_master it can be completely
	 * shared including authentication between the child
	 * and the client.
	 */
	mm->mmalloc = mmalloc;

	address = mmap(NULL, size, PROT_WRITE|PROT_READ, MAP_ANON|MAP_SHARED,
	    -1, 0);
	if (address == MAP_FAILED)
		fatal("mmap(%zu): %s", size, strerror(errno));

	mm->address = address;
	mm->size = size;

	RB_INIT(&mm->rb_free);
	RB_INIT(&mm->rb_allocated);

	mm_make_entry(mm, &mm->rb_free, address, size);

	return (mm);
}

/* Frees either the allocated or the free list */

static void
mm_freelist(struct mm_master *mmalloc, struct mmtree *head)
{
	struct mm_share *mms, *next;

	for (mms = RB_ROOT(head); mms; mms = next) {
		next = RB_NEXT(mmtree, head, mms);
		RB_REMOVE(mmtree, head, mms);
		if (mmalloc == NULL)
			free(mms);
		else
			mm_free(mmalloc, mms);
	}
}

/* Destroys a memory mapped area */

void
mm_destroy(struct mm_master *mm)
{
	mm_freelist(mm->mmalloc, &mm->rb_free);
	mm_freelist(mm->mmalloc, &mm->rb_allocated);

	if (munmap(mm->address, mm->size) == -1)
		fatal("munmap(%p, %zu): %s", mm->address, mm->size,
		    strerror(errno));
	if (mm->mmalloc == NULL)
		free(mm);
	else
		mm_free(mm->mmalloc, mm);
}

void *
mm_xmalloc(struct mm_master *mm, size_t size)
{
	void *address;

	address = mm_malloc(mm, size);
	if (address == NULL)
		fatal("%s: mm_malloc(%zu)", __func__, size);
	memset(address, 0, size);
	return (address);
}


/* Allocates data from a memory mapped area */

void *
mm_malloc(struct mm_master *mm, size_t size)
{
	struct mm_share *mms, *tmp;

	if (size == 0)
		fatal("mm_malloc: try to allocate 0 space");
	if (size > SIZE_MAX - MM_MINSIZE + 1)
		fatal("mm_malloc: size too big");

	size = ((size + (MM_MINSIZE - 1)) / MM_MINSIZE) * MM_MINSIZE;

	RB_FOREACH(mms, mmtree, &mm->rb_free) {
		if (mms->size >= size)
			break;
	}

	if (mms == NULL)
		return (NULL);

	/* Debug */
	memset(mms->address, 0xd0, size);

	tmp = mm_make_entry(mm, &mm->rb_allocated, mms->address, size);

	/* Does not change order in RB tree */
	mms->size -= size;
	mms->address = (char *)mms->address + size;

	if (mms->size == 0) {
		RB_REMOVE(mmtree, &mm->rb_free, mms);
		if (mm->mmalloc == NULL)
			free(mms);
		else
			mm_free(mm->mmalloc, mms);
	}

	return (tmp->address);
}

/* Frees memory in a memory mapped area */

void
mm_free(struct mm_master *mm, void *address)
{
	struct mm_share *mms, *prev, tmp;

	tmp.address = address;
	mms = RB_FIND(mmtree, &mm->rb_allocated, &tmp);
	if (mms == NULL)
		fatal("mm_free(%p): can not find %p", mm, address);

	/* Debug */
	memset(mms->address, 0xd0, mms->size);

	/* Remove from allocated list and insert in free list */
	RB_REMOVE(mmtree, &mm->rb_allocated, mms);
	if (RB_INSERT(mmtree, &mm->rb_free, mms) != NULL)
		fatal("mm_free(%p): double address %p", mm, address);

	/* Find previous entry */
	prev = mms;
	if (RB_LEFT(prev, next)) {
		prev = RB_LEFT(prev, next);
		while (RB_RIGHT(prev, next))
			prev = RB_RIGHT(prev, next);
	} else {
		if (RB_PARENT(prev, next) &&
		    (prev == RB_RIGHT(RB_PARENT(prev, next), next)))
			prev = RB_PARENT(prev, next);
		else {
			while (RB_PARENT(prev, next) &&
			    (prev == RB_LEFT(RB_PARENT(prev, next), next)))
				prev = RB_PARENT(prev, next);
			prev = RB_PARENT(prev, next);
		}
	}

	/* Check if range does not overlap */
	if (prev != NULL && MM_ADDRESS_END(prev) > address)
		fatal("mm_free: memory corruption: %p(%zu) > %p",
		    prev->address, prev->size, address);

	/* See if we can merge backwards */
	if (prev != NULL && MM_ADDRESS_END(prev) == address) {
		prev->size += mms->size;
		RB_REMOVE(mmtree, &mm->rb_free, mms);
		if (mm->mmalloc == NULL)
			free(mms);
		else
			mm_free(mm->mmalloc, mms);
	} else
		prev = mms;

	if (prev == NULL)
		return;

	/* Check if we can merge forwards */
	mms = RB_NEXT(mmtree, &mm->rb_free, prev);
	if (mms == NULL)
		return;

	if (MM_ADDRESS_END(prev) > mms->address)
		fatal("mm_free: memory corruption: %p < %p(%zu)",
		    mms->address, prev->address, prev->size);
	if (MM_ADDRESS_END(prev) != mms->address)
		return;

	prev->size += mms->size;
	RB_REMOVE(mmtree, &mm->rb_free, mms);

	if (mm->mmalloc == NULL)
		free(mms);
	else
		mm_free(mm->mmalloc, mms);
}

static void
mm_sync_list(struct mmtree *oldtree, struct mmtree *newtree,
    struct mm_master *mm, struct mm_master *mmold)
{
	struct mm_master *mmalloc = mm->mmalloc;
	struct mm_share *mms, *new;

	/* Sync free list */
	RB_FOREACH(mms, mmtree, oldtree) {
		/* Check the values */
		mm_memvalid(mmold, mms, sizeof(struct mm_share));
		mm_memvalid(mm, mms->address, mms->size);

		new = mm_xmalloc(mmalloc, sizeof(struct mm_share));
		memcpy(new, mms, sizeof(struct mm_share));
		RB_INSERT(mmtree, newtree, new);
	}
}

void
mm_share_sync(struct mm_master **pmm, struct mm_master **pmmalloc)
{
	struct mm_master *mm;
	struct mm_master *mmalloc;
	struct mm_master *mmold;
	struct mmtree rb_free, rb_allocated;

	debug3("%s: Share sync", __func__);

	mm = *pmm;
	mmold = mm->mmalloc;
	mm_memvalid(mmold, mm, sizeof(*mm));

	mmalloc = mm_create(NULL, mm->size);
	mm = mm_xmalloc(mmalloc, sizeof(struct mm_master));
	memcpy(mm, *pmm, sizeof(struct mm_master));
	mm->mmalloc = mmalloc;

	rb_free = mm->rb_free;
	rb_allocated = mm->rb_allocated;

	RB_INIT(&mm->rb_free);
	RB_INIT(&mm->rb_allocated);

	mm_sync_list(&rb_free, &mm->rb_free, mm, mmold);
	mm_sync_list(&rb_allocated, &mm->rb_allocated, mm, mmold);

	mm_destroy(mmold);

	*pmm = mm;
	*pmmalloc = mmalloc;

	debug3("%s: Share sync end", __func__);
}

void
mm_memvalid(struct mm_master *mm, void *address, size_t size)
{
	void *end = (char *)address + size;

	if (address < mm->address)
		fatal("mm_memvalid: address too small: %p", address);
	if (end < address)
		fatal("mm_memvalid: end < address: %p < %p", end, address);
	if (end > MM_ADDRESS_END(mm))
		fatal("mm_memvalid: address too large: %p", address);
}
@


1.21
log
@SIZE_MAX is standard, we should be using it in preference to the
obsolete SIZE_T_MAX.  OK miod@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_mm.c,v 1.20 2015/01/20 23:14:00 deraadt Exp $ */
@


1.20
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_mm.c,v 1.19 2014/01/04 17:50:55 tedu Exp $ */
d34 1
a36 1
#include <limits.h>
d171 1
a171 1
	if (size > SIZE_T_MAX - MM_MINSIZE + 1)
@


1.19
log
@use standard types and formats for size_t like variables. ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_mm.c,v 1.18 2013/11/08 00:39:15 djm Exp $ */
a29 1
#include <sys/param.h>
d36 1
@


1.18
log
@use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_mm.c,v 1.17 2013/05/17 00:13:13 djm Exp $ */
d34 1
d46 1
a46 1
	long diff = (char *)a->address - (char *)b->address;
d73 2
a74 2
		fatal("mm_make_entry(%p): double address %p->%p(%lu)",
		    mm, tmp2, address, (u_long)size);
d100 1
a100 1
	    -1, (off_t)0);
d102 1
a102 1
		fatal("mmap(%lu): %s", (u_long)size, strerror(errno));
d141 1
a141 1
		fatal("munmap(%p, %lu): %s", mm->address, (u_long)mm->size,
d156 1
a156 1
		fatal("%s: mm_malloc(%lu)", __func__, (u_long)size);
d191 1
a191 1
	mms->address = (u_char *)mms->address + size;
d244 2
a245 2
		fatal("mm_free: memory corruption: %p(%lu) > %p",
		    prev->address, (u_long)prev->size, address);
d267 2
a268 2
		fatal("mm_free: memory corruption: %p < %p(%lu)",
		    mms->address, prev->address, (u_long)prev->size);
d339 1
a339 1
	void *end = (u_char *)address + size;
d345 1
a345 1
	if (end > (void *)((u_char *)mm->address + mm->size))
@


1.17
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_mm.c,v 1.16 2009/06/22 05:39:28 dtucker Exp $ */
d64 1
a64 1
		tmp = xmalloc(sizeof(struct mm_share));
d87 1
a87 1
		mm = xmalloc(sizeof(struct mm_master));
d156 1
@


1.17.2.1
log
@cherrypick commit:

date: 2013/11/08 00:39:15;  author: djm;  state: Exp;  lines: +2 -2;
use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_mm.c,v 1.17 2013/05/17 00:13:13 djm Exp $ */
d64 1
a64 1
		tmp = xcalloc(1, sizeof(struct mm_share));
d87 1
a87 1
		mm = xcalloc(1, sizeof(struct mm_master));
a155 1
	memset(address, 0, size);
@


1.16
log
@alphabetize includes; reduces diff vs portable and style(9).  ok stevesk djm
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_mm.c,v 1.15 2006/08/03 03:34:42 deraadt Exp $ */
d34 1
d125 1
a125 1
			xfree(mms);
d143 1
a143 1
		xfree(mm);
d194 1
a194 1
			xfree(mms);
d250 1
a250 1
			xfree(mms);
d274 1
a274 1
		xfree(mms);
@


1.16.16.1
log
@openssh-6.4 for the 5.3 branch; reminded by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_mm.c,v 1.17.2.1 2013/11/08 01:33:56 djm Exp $ */
d63 1
a63 1
		tmp = xcalloc(1, sizeof(struct mm_share));
d86 1
a86 1
		mm = xcalloc(1, sizeof(struct mm_master));
a154 1
	memset(address, 0, size);
@


1.15
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_mm.c,v 1.14 2006/07/26 02:35:17 stevesk Exp $ */
d33 1
a34 1
#include <stdarg.h>
@


1.14
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_mm.c,v 1.13 2006/07/22 20:48:23 stevesk Exp $ */
d27 1
a27 2
#include "includes.h"

d29 1
d34 1
d36 1
a37 1
#include "xmalloc.h"
@


1.13
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_mm.c,v 1.12 2006/07/11 20:07:25 stevesk Exp $ */
d30 1
@


1.12
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor_mm.c,v 1.11 2006/03/25 13:17:02 djm Exp $ */
d32 1
@


1.11
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d30 2
@


1.10
log
@RCSID() can die
@
text
@d1 1
@


1.9
log
@improve some code lint did not like; djm millert ok
@
text
@a26 1
RCSID("$OpenBSD: monitor_mm.c,v 1.8 2002/08/02 14:43:15 millert Exp $");
@


1.9.6.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: monitor_mm.c,v 1.15 2006/08/03 03:34:42 deraadt Exp $ */
d26 3
a28 1
#include <sys/types.h>
a29 6
#include <sys/tree.h>
#include <sys/param.h>

#include <errno.h>
#include <string.h>
#include <stdarg.h>
d31 1
a32 1
#include "ssh.h"
@


1.9.8.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: monitor_mm.c,v 1.15 2006/08/03 03:34:42 deraadt Exp $ */
d26 3
a28 1
#include <sys/types.h>
a29 6
#include <sys/tree.h>
#include <sys/param.h>

#include <errno.h>
#include <string.h>
#include <stdarg.h>
d31 1
a32 1
#include "ssh.h"
@


1.8
log
@Change mm_zalloc() sanity checks to be more in line with what
we do in calloc() and add a check to monitor_mm.c.
OK provos@@ and markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: monitor_mm.c,v 1.7 2002/06/28 01:49:31 millert Exp $");
d93 1
a93 1
	    -1, 0);
@


1.8.6.1
log
@upgrade to OpenSSH 3.9
@
text
@d27 1
a27 1
RCSID("$OpenBSD: monitor_mm.c,v 1.9 2004/05/11 19:01:43 deraadt Exp $");
d93 1
a93 1
	    -1, (off_t)0);
@


1.8.8.1
log
@upgrade to OpenSSH 3.9
@
text
@d27 1
a27 1
RCSID("$OpenBSD: monitor_mm.c,v 1.9 2004/05/11 19:01:43 deraadt Exp $");
d93 1
a93 1
	    -1, (off_t)0);
@


1.7
log
@tree(3) wants an int return value for its compare functions and
the difference between two pointers is not an int.  Just do the
safest thing and store the result in a long and then return 0,
-1, or 1 based on that result.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: monitor_mm.c,v 1.6 2002/06/04 23:05:49 markus Exp $");
d163 2
d166 1
a166 1
	size = ((size + MM_MINSIZE - 1) / MM_MINSIZE) * MM_MINSIZE;
@


1.6
log
@__FUNCTION__ -> __func__
@
text
@d27 1
a27 1
RCSID("$OpenBSD: monitor_mm.c,v 1.5 2002/05/28 16:45:27 stevesk Exp $");
d39 8
a46 1
	return ((char *)a->address - (char *)b->address);
@


1.5
log
@print strerror(errno) on mmap/munmap error; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: monitor_mm.c,v 1.4 2002/03/25 20:12:10 stevesk Exp $");
d142 1
a142 1
		fatal("%s: mm_malloc(%lu)", __FUNCTION__, (u_long)size);
d291 1
a291 1
	debug3("%s: Share sync", __FUNCTION__);
d316 1
a316 1
	debug3("%s: Share sync end", __FUNCTION__);
@


1.5.2.1
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d88 1
a88 1
		fatal("mmap(%lu)", (u_long)size);
d127 2
a128 1
		fatal("munmap(%p, %lu)", mm->address, (u_long)mm->size);
@


1.4
log
@ssize_t args use "%ld" and cast to (long)
size_t args use "%lu" and cast to (u_long)
ok markus@@ and thanks millert@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: monitor_mm.c,v 1.3 2002/03/19 10:41:32 markus Exp $");
d88 1
a88 1
		fatal("mmap(%lu)", (u_long)size);
d127 2
a128 1
		fatal("munmap(%p, %lu)", mm->address, (u_long)mm->size);
@


1.4.2.1
log
@Pull in OpenSSH-3.4
@
text
@d27 1
a27 1
RCSID("$OpenBSD: monitor_mm.c,v 1.6 2002/06/04 23:05:49 markus Exp $");
d88 1
a88 1
		fatal("mmap(%lu): %s", (u_long)size, strerror(errno));
d127 1
a127 2
		fatal("munmap(%p, %lu): %s", mm->address, (u_long)mm->size,
		    strerror(errno));
d141 1
a141 1
		fatal("%s: mm_malloc(%lu)", __func__, (u_long)size);
d290 1
a290 1
	debug3("%s: Share sync", __func__);
d315 1
a315 1
	debug3("%s: Share sync end", __func__);
@


1.4.2.2
log
@Update to OpenSSH 3.5
@
text
@d27 1
a27 1
RCSID("$OpenBSD: monitor_mm.c,v 1.8 2002/08/02 14:43:15 millert Exp $");
d39 1
a39 8
	long diff = (char *)a->address - (char *)b->address;

	if (diff == 0)
		return (0);
	else if (diff < 0)
		return (-1);
	else
		return (1);
a155 2
	if (size > SIZE_T_MAX - MM_MINSIZE + 1)
		fatal("mm_malloc: size too big");
d157 1
a157 1
	size = ((size + (MM_MINSIZE - 1)) / MM_MINSIZE) * MM_MINSIZE;
@


1.4.4.1
log
@Update OpenSSH to version 3.2.2.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: monitor_mm.c,v 1.4 2002/03/25 20:12:10 stevesk Exp $");
@


1.4.4.2
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d27 1
a27 1
RCSID("$OpenBSD: monitor_mm.c,v 1.4.4.1 2002/05/17 00:03:23 miod Exp $");
d88 1
a88 1
		fatal("mmap(%lu): %s", (u_long)size, strerror(errno));
d127 1
a127 2
		fatal("munmap(%p, %lu): %s", mm->address, (u_long)mm->size,
		    strerror(errno));
d141 1
a141 1
		fatal("%s: mm_malloc(%lu)", __func__, (u_long)size);
d290 1
a290 1
	debug3("%s: Share sync", __func__);
d315 1
a315 1
	debug3("%s: Share sync end", __func__);
@


1.4.4.3
log
@Update to OpenSSH 3.5
@
text
@d27 1
a27 1
RCSID("$OpenBSD: monitor_mm.c,v 1.8 2002/08/02 14:43:15 millert Exp $");
d39 1
a39 8
	long diff = (char *)a->address - (char *)b->address;

	if (diff == 0)
		return (0);
	else if (diff < 0)
		return (-1);
	else
		return (1);
a155 2
	if (size > SIZE_T_MAX - MM_MINSIZE + 1)
		fatal("mm_malloc: size too big");
d157 1
a157 1
	size = ((size + (MM_MINSIZE - 1)) / MM_MINSIZE) * MM_MINSIZE;
@


1.3
log
@whitespace KNF
@
text
@d27 1
a27 1
RCSID("$OpenBSD: monitor_mm.c,v 1.2 2002/03/19 10:35:39 markus Exp $");
d59 2
a60 2
		fatal("mm_make_entry(%p): double address %p->%p(%d)",
		    mm, tmp2, address, size);
d88 1
a88 1
		fatal("mmap(%d)", size);
d127 1
a127 1
		fatal("munmap(%p, %d)", mm->address, mm->size);
d141 1
a141 1
		fatal("%s: mm_malloc(%d)", __FUNCTION__, size);
d226 2
a227 2
		fatal("mm_free: memory corruption: %p(%d) > %p",
		    prev->address, prev->size, address);
d249 2
a250 2
		fatal("mm_free: memory corruption: %p < %p(%d)",
		    mms->address, prev->address, prev->size);
@


1.2
log
@clean up prototypes
@
text
@d27 1
a27 1
RCSID("$OpenBSD: monitor_mm.c,v 1.1 2002/03/18 17:26:58 provos Exp $");
d78 1
a78 1
	/* 
d166 1
a166 1
 	/* Debug */
d198 1
a198 1
 	/* Debug */
@


1.1
log
@shared memory abstraction for ssh-privsep
@
text
@d27 1
a27 1
RCSID("$OpenBSD$");
d103 1
a103 1
void
d263 1
a263 1
void
@

