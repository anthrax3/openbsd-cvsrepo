head	1.70;
access;
symbols
	OPENBSD_3_4:1.62.0.2
	OPENBSD_3_4_BASE:1.62
	OPENBSD_3_3:1.57.0.2
	OPENBSD_3_3_BASE:1.57
	OPENBSD_3_2:1.49.0.2
	OPENBSD_3_2_BASE:1.49
	OPENBSD_3_1:1.46.0.2
	OPENBSD_3_1_BASE:1.46
	OPENBSD_3_0:1.40.0.2
	OPENBSD_3_0_BASE:1.40
	OPENBSD_2_9_BASE:1.36
	OPENBSD_2_9:1.36.0.2
	OPENBSD_2_7:1.26.0.2
	OPENBSD_2_8:1.22.0.2;
locks; strict;
comment	@ * @;


1.70
date	2004.02.17.11.03.08;	author djm;	state dead;
branches;
next	1.69;

1.69
date	2004.02.17.07.17.29;	author djm;	state Exp;
branches;
next	1.68;

1.68
date	2004.02.17.05.39.51;	author djm;	state Exp;
branches;
next	1.67;

1.67
date	2004.01.23.17.57.48;	author mouring;	state Exp;
branches;
next	1.66;

1.66
date	2004.01.13.09.25.05;	author djm;	state Exp;
branches;
next	1.65;

1.65
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches;
next	1.64;

1.64
date	2003.11.08.19.17.29;	author jmc;	state Exp;
branches;
next	1.63;

1.63
date	2003.10.07.07.04.16;	author djm;	state Exp;
branches;
next	1.62;

1.62
date	2003.08.25.08.13.09;	author fgsch;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2003.07.19.00.45.53;	author djm;	state Exp;
branches;
next	1.60;

1.60
date	2003.05.15.03.43.59;	author mouring;	state Exp;
branches;
next	1.59;

1.59
date	2003.05.15.03.39.07;	author mouring;	state Exp;
branches;
next	1.58;

1.58
date	2003.04.14.21.31.27;	author mouring;	state Exp;
branches;
next	1.57;

1.57
date	2003.03.05.22.33.43;	author markus;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2003.01.16.03.41.55;	author djm;	state Exp;
branches;
next	1.55;

1.55
date	2003.01.14.10.58.00;	author djm;	state Exp;
branches;
next	1.54;

1.54
date	2003.01.13.11.04.04;	author djm;	state Exp;
branches;
next	1.53;

1.53
date	2003.01.10.23.23.24;	author fgsch;	state Exp;
branches;
next	1.52;

1.52
date	2003.01.10.08.19.07;	author fgsch;	state Exp;
branches;
next	1.51;

1.51
date	2003.01.08.23.53.26;	author djm;	state Exp;
branches;
next	1.50;

1.50
date	2002.11.21.23.03.51;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2002.09.12.00.13.06;	author djm;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2002.09.11.22.41.50;	author djm;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.23.09.30.14;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2002.03.30.18.51.15;	author markus;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2002.03.19.06.32.56;	author mpech;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.13.00.59.23;	author djm;	state Exp;
branches;
next	1.43;

1.43
date	2002.02.12.12.32.27;	author djm;	state Exp;
branches;
next	1.42;

1.42
date	2002.02.05.00.00.46;	author djm;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2001.08.14.09.23.02;	author markus;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2001.07.31.12.42.50;	author jakob;	state Exp;
branches;
next	1.38;

1.38
date	2001.07.09.07.04.53;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.23.15.12.20;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2001.04.15.08.43.46;	author markus;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2001.04.12.23.17.54;	author mouring;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.11.07.06.22;	author djm;	state Exp;
branches;
next	1.33;

1.33
date	2001.04.05.10.42.53;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.23.13.10.57;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2001.03.16.13.44.24;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.16.09.55.53;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.16.08.16.18;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.14.15.15.58;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.13.22.42.54;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.07.10.11.23;	author djm;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2001.03.06.06.11.44;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.04.17.42.28;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.01.02.18.04;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.14.09.46.03;	author djm;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.02.12.20.53.33;	author stevesk;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.10.00.45.26;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.09.11.46.24;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.08.22.28.07;	author stevesk;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.08.17.57.59;	author stevesk;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.08.15.02.01;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.07.22.55.47;	author stevesk;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.07.22.36.03;	author stevesk;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.07.18.10.39;	author stevesk;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.07.13.12.29;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.07.00.10.18;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.06.23.55.20;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.06.22.18.16;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.06.05.22.02;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.05.00.02.32;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.04.23.47.46;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.04.22.17.52;	author stevesk;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.04.21.41.21;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.04.15.32.25;	author stevesk;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.04.15.17.00;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.04.11.11.54;	author djm;	state Exp;
branches;
next	;

1.22.2.1
date	2001.02.16.20.13.15;	author jason;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2001.02.19.17.19.23;	author jason;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2001.03.21.19.46.29;	author jason;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2001.05.07.21.09.34;	author jason;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.22.2.6;

1.22.2.6
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.26.2.1
date	2001.03.12.15.44.15;	author jason;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2001.03.21.18.53.05;	author jason;	state Exp;
branches;
next	;

1.36.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	1.36.2.3;

1.36.2.3
date	2002.06.02.22.56.11;	author miod;	state Exp;
branches;
next	;

1.40.2.1
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.40.2.3;

1.40.2.3
date	2002.06.26.18.22.36;	author miod;	state Exp;
branches;
next	1.40.2.4;

1.40.2.4
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.46.2.1
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.46.2.2;

1.46.2.2
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.46.2.3;

1.46.2.3
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.49.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2003.09.16.21.20.27;	author brad;	state Exp;
branches;
next	;

1.57.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.57.2.2;

1.57.2.2
date	2004.03.04.18.18.16;	author brad;	state dead;
branches;
next	;

1.62.2.1
date	2004.02.28.03.51.34;	author brad;	state dead;
branches;
next	;


desc
@@


1.70
log
@sftp.c and sftp-int.c, together at last; ok markus@@
@
text
@/*
 * Copyright (c) 2001-2004 Damien Miller <djm@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* XXX: recursive operations */

#include "includes.h"
RCSID("$OpenBSD: sftp-int.c,v 1.69 2004/02/17 07:17:29 djm Exp $");

#include <glob.h>

#include "buffer.h"
#include "xmalloc.h"
#include "log.h"
#include "pathnames.h"

#include "sftp.h"
#include "sftp-common.h"
#include "sftp-client.h"

int remote_glob(struct sftp_conn *, const char *, int,
    int (*)(const char *, int), glob_t *); /* sftp-glob.c */

/* File to read commands from */
extern FILE *infile;

/* Are we in batchfile mode? */
extern int batchmode;

/* Size of buffer used when copying files */
extern size_t copy_buffer_len;

/* Number of concurrent outstanding requests */
extern int num_requests;

/* This is set to 0 if the progressmeter is not desired. */
int showprogress = 1;

/* Separators for interactive commands */
#define WHITESPACE " \t\r\n"

/* Define what type of ls view (0 - multi-column) */
#define LONG_VIEW 1		/* Full view ala ls -l */
#define SHORT_VIEW 2		/* Single row view ala ls -1 */

/* Commands for interactive mode */
#define I_CHDIR		1
#define I_CHGRP		2
#define I_CHMOD		3
#define I_CHOWN		4
#define I_GET		5
#define I_HELP		6
#define I_LCHDIR	7
#define I_LLS		8
#define I_LMKDIR	9
#define I_LPWD		10
#define I_LS		11
#define I_LUMASK	12
#define I_MKDIR		13
#define I_PUT		14
#define I_PWD		15
#define I_QUIT		16
#define I_RENAME	17
#define I_RM		18
#define I_RMDIR		19
#define I_SHELL		20
#define I_SYMLINK	21
#define I_VERSION	22
#define I_PROGRESS	23

struct CMD {
	const char *c;
	const int n;
};

static const struct CMD cmds[] = {
	{ "bye",	I_QUIT },
	{ "cd",		I_CHDIR },
	{ "chdir",	I_CHDIR },
	{ "chgrp",	I_CHGRP },
	{ "chmod",	I_CHMOD },
	{ "chown",	I_CHOWN },
	{ "dir",	I_LS },
	{ "exit",	I_QUIT },
	{ "get",	I_GET },
	{ "mget",	I_GET },
	{ "help",	I_HELP },
	{ "lcd",	I_LCHDIR },
	{ "lchdir",	I_LCHDIR },
	{ "lls",	I_LLS },
	{ "lmkdir",	I_LMKDIR },
	{ "ln",		I_SYMLINK },
	{ "lpwd",	I_LPWD },
	{ "ls",		I_LS },
	{ "lumask",	I_LUMASK },
	{ "mkdir",	I_MKDIR },
	{ "progress",	I_PROGRESS },
	{ "put",	I_PUT },
	{ "mput",	I_PUT },
	{ "pwd",	I_PWD },
	{ "quit",	I_QUIT },
	{ "rename",	I_RENAME },
	{ "rm",		I_RM },
	{ "rmdir",	I_RMDIR },
	{ "symlink",	I_SYMLINK },
	{ "version",	I_VERSION },
	{ "!",		I_SHELL },
	{ "?",		I_HELP },
	{ NULL,			-1}
};

int interactive_loop(int fd_in, int fd_out, char *file1, char *file2);

static void
help(void)
{
	printf("Available commands:\n");
	printf("cd path                       Change remote directory to 'path'\n");
	printf("lcd path                      Change local directory to 'path'\n");
	printf("chgrp grp path                Change group of file 'path' to 'grp'\n");
	printf("chmod mode path               Change permissions of file 'path' to 'mode'\n");
	printf("chown own path                Change owner of file 'path' to 'own'\n");
	printf("help                          Display this help text\n");
	printf("get remote-path [local-path]  Download file\n");
	printf("lls [ls-options [path]]       Display local directory listing\n");
	printf("ln oldpath newpath            Symlink remote file\n");
	printf("lmkdir path                   Create local directory\n");
	printf("lpwd                          Print local working directory\n");
	printf("ls [path]                     Display remote directory listing\n");
	printf("lumask umask                  Set local umask to 'umask'\n");
	printf("mkdir path                    Create remote directory\n");
	printf("progress                      Toggle display of progress meter\n");
	printf("put local-path [remote-path]  Upload file\n");
	printf("pwd                           Display remote working directory\n");
	printf("exit                          Quit sftp\n");
	printf("quit                          Quit sftp\n");
	printf("rename oldpath newpath        Rename remote file\n");
	printf("rmdir path                    Remove remote directory\n");
	printf("rm path                       Delete remote file\n");
	printf("symlink oldpath newpath       Symlink remote file\n");
	printf("version                       Show SFTP version\n");
	printf("!command                      Execute 'command' in local shell\n");
	printf("!                             Escape to local shell\n");
	printf("?                             Synonym for help\n");
}

static void
local_do_shell(const char *args)
{
	int status;
	char *shell;
	pid_t pid;

	if (!*args)
		args = NULL;

	if ((shell = getenv("SHELL")) == NULL)
		shell = _PATH_BSHELL;

	if ((pid = fork()) == -1)
		fatal("Couldn't fork: %s", strerror(errno));

	if (pid == 0) {
		/* XXX: child has pipe fds to ssh subproc open - issue? */
		if (args) {
			debug3("Executing %s -c \"%s\"", shell, args);
			execl(shell, shell, "-c", args, (char *)NULL);
		} else {
			debug3("Executing %s", shell);
			execl(shell, shell, (char *)NULL);
		}
		fprintf(stderr, "Couldn't execute \"%s\": %s\n", shell,
		    strerror(errno));
		_exit(1);
	}
	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for child: %s", strerror(errno));
	if (!WIFEXITED(status))
		error("Shell exited abormally");
	else if (WEXITSTATUS(status))
		error("Shell exited with status %d", WEXITSTATUS(status));
}

static void
local_do_ls(const char *args)
{
	if (!args || !*args)
		local_do_shell(_PATH_LS);
	else {
		int len = strlen(_PATH_LS " ") + strlen(args) + 1;
		char *buf = xmalloc(len);

		/* XXX: quoting - rip quoting code from ftp? */
		snprintf(buf, len, _PATH_LS " %s", args);
		local_do_shell(buf);
		xfree(buf);
	}
}

/* Strip one path (usually the pwd) from the start of another */
static char *
path_strip(char *path, char *strip)
{
	size_t len;

	if (strip == NULL)
		return (xstrdup(path));

	len = strlen(strip);
	if (strip != NULL && strncmp(path, strip, len) == 0) {
		if (strip[len - 1] != '/' && path[len] == '/')
			len++;
		return (xstrdup(path + len));
	}

	return (xstrdup(path));
}

static char *
path_append(char *p1, char *p2)
{
	char *ret;
	int len = strlen(p1) + strlen(p2) + 2;

	ret = xmalloc(len);
	strlcpy(ret, p1, len);
	if (p1[strlen(p1) - 1] != '/')
		strlcat(ret, "/", len);
	strlcat(ret, p2, len);

	return(ret);
}

static char *
make_absolute(char *p, char *pwd)
{
	char *abs;

	/* Derelativise */
	if (p && p[0] != '/') {
		abs = path_append(pwd, p);
		xfree(p);
		return(abs);
	} else
		return(p);
}

static int
infer_path(const char *p, char **ifp)
{
	char *cp;

	cp = strrchr(p, '/');
	if (cp == NULL) {
		*ifp = xstrdup(p);
		return(0);
	}

	if (!cp[1]) {
		error("Invalid path");
		return(-1);
	}

	*ifp = xstrdup(cp + 1);
	return(0);
}

static int
parse_getput_flags(const char **cpp, int *pflag)
{
	const char *cp = *cpp;

	/* Check for flags */
	if (cp[0] == '-' && cp[1] && strchr(WHITESPACE, cp[2])) {
		switch (cp[1]) {
		case 'p':
		case 'P':
			*pflag = 1;
			break;
		default:
			error("Invalid flag -%c", cp[1]);
			return(-1);
		}
		cp += 2;
		*cpp = cp + strspn(cp, WHITESPACE);
	}

	return(0);
}

static int
parse_ls_flags(const char **cpp, int *lflag)
{
	const char *cp = *cpp;

	/* Check for flags */
	if (cp++[0] == '-') {
		for(; strchr(WHITESPACE, *cp) == NULL; cp++) {
			switch (*cp) {
			case 'l':
				*lflag = LONG_VIEW;
				break;
			case '1':
				*lflag = SHORT_VIEW;
				break;
			default:
				error("Invalid flag -%c", *cp);
				return(-1);
			}
		}
		*cpp = cp + strspn(cp, WHITESPACE);
	}

	return(0);
}

static int
get_pathname(const char **cpp, char **path)
{
	const char *cp = *cpp, *end;
	char quot;
	int i, j;

	cp += strspn(cp, WHITESPACE);
	if (!*cp) {
		*cpp = cp;
		*path = NULL;
		return (0);
	}

	*path = xmalloc(strlen(cp) + 1);

	/* Check for quoted filenames */
	if (*cp == '\"' || *cp == '\'') {
		quot = *cp++;

		/* Search for terminating quote, unescape some chars */
		for (i = j = 0; i <= strlen(cp); i++) {
			if (cp[i] == quot) {	/* Found quote */
				i++;
				(*path)[j] = '\0';
				break;
			}
			if (cp[i] == '\0') {	/* End of string */
				error("Unterminated quote");
				goto fail;
			}
			if (cp[i] == '\\') {	/* Escaped characters */
				i++;
				if (cp[i] != '\'' && cp[i] != '\"' &&
				    cp[i] != '\\') {
					error("Bad escaped character '\%c'",
					    cp[i]);
					goto fail;
				}
			}
			(*path)[j++] = cp[i];
		}

		if (j == 0) {
			error("Empty quotes");
			goto fail;
		}
		*cpp = cp + i + strspn(cp + i, WHITESPACE);
	} else {
		/* Read to end of filename */
		end = strpbrk(cp, WHITESPACE);
		if (end == NULL)
			end = strchr(cp, '\0');
		*cpp = end + strspn(end, WHITESPACE);

		memcpy(*path, cp, end - cp);
		(*path)[end - cp] = '\0';
	}
	return (0);

 fail:
	xfree(*path);
	*path = NULL;
	return (-1);
}

static int
is_dir(char *path)
{
	struct stat sb;

	/* XXX: report errors? */
	if (stat(path, &sb) == -1)
		return(0);

	return(sb.st_mode & S_IFDIR);
}

static int
is_reg(char *path)
{
	struct stat sb;

	if (stat(path, &sb) == -1)
		fatal("stat %s: %s", path, strerror(errno));

	return(S_ISREG(sb.st_mode));
}

static int
remote_is_dir(struct sftp_conn *conn, char *path)
{
	Attrib *a;

	/* XXX: report errors? */
	if ((a = do_stat(conn, path, 1)) == NULL)
		return(0);
	if (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))
		return(0);
	return(a->perm & S_IFDIR);
}

static int
process_get(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
{
	char *abs_src = NULL;
	char *abs_dst = NULL;
	char *tmp;
	glob_t g;
	int err = 0;
	int i;

	abs_src = xstrdup(src);
	abs_src = make_absolute(abs_src, pwd);

	memset(&g, 0, sizeof(g));
	debug3("Looking up %s", abs_src);
	if (remote_glob(conn, abs_src, 0, NULL, &g)) {
		error("File \"%s\" not found.", abs_src);
		err = -1;
		goto out;
	}

	/* If multiple matches, dst must be a directory or unspecified */
	if (g.gl_matchc > 1 && dst && !is_dir(dst)) {
		error("Multiple files match, but \"%s\" is not a directory",
		    dst);
		err = -1;
		goto out;
	}

	for (i = 0; g.gl_pathv[i]; i++) {
		if (infer_path(g.gl_pathv[i], &tmp)) {
			err = -1;
			goto out;
		}

		if (g.gl_matchc == 1 && dst) {
			/* If directory specified, append filename */
			if (is_dir(dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(dst);
		} else if (dst) {
			abs_dst = path_append(dst, tmp);
			xfree(tmp);
		} else
			abs_dst = tmp;

		printf("Fetching %s to %s\n", g.gl_pathv[i], abs_dst);
		if (do_download(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
			err = -1;
		xfree(abs_dst);
		abs_dst = NULL;
	}

out:
	xfree(abs_src);
	if (abs_dst)
		xfree(abs_dst);
	globfree(&g);
	return(err);
}

static int
process_put(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
{
	char *tmp_dst = NULL;
	char *abs_dst = NULL;
	char *tmp;
	glob_t g;
	int err = 0;
	int i;

	if (dst) {
		tmp_dst = xstrdup(dst);
		tmp_dst = make_absolute(tmp_dst, pwd);
	}

	memset(&g, 0, sizeof(g));
	debug3("Looking up %s", src);
	if (glob(src, 0, NULL, &g)) {
		error("File \"%s\" not found.", src);
		err = -1;
		goto out;
	}

	/* If multiple matches, dst may be directory or unspecified */
	if (g.gl_matchc > 1 && tmp_dst && !remote_is_dir(conn, tmp_dst)) {
		error("Multiple files match, but \"%s\" is not a directory",
		    tmp_dst);
		err = -1;
		goto out;
	}

	for (i = 0; g.gl_pathv[i]; i++) {
		if (!is_reg(g.gl_pathv[i])) {
			error("skipping non-regular file %s",
			    g.gl_pathv[i]);
			continue;
		}
		if (infer_path(g.gl_pathv[i], &tmp)) {
			err = -1;
			goto out;
		}

		if (g.gl_matchc == 1 && tmp_dst) {
			/* If directory specified, append filename */
			if (remote_is_dir(conn, tmp_dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(tmp_dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(tmp_dst);

		} else if (tmp_dst) {
			abs_dst = path_append(tmp_dst, tmp);
			xfree(tmp);
		} else
			abs_dst = make_absolute(tmp, pwd);

		printf("Uploading %s to %s\n", g.gl_pathv[i], abs_dst);
		if (do_upload(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
			err = -1;
	}

out:
	if (abs_dst)
		xfree(abs_dst);
	if (tmp_dst)
		xfree(tmp_dst);
	globfree(&g);
	return(err);
}

static int
sdirent_comp(const void *aa, const void *bb)
{
	SFTP_DIRENT *a = *(SFTP_DIRENT **)aa;
	SFTP_DIRENT *b = *(SFTP_DIRENT **)bb;

	return (strcmp(a->filename, b->filename));
}

/* sftp ls.1 replacement for directories */
static int
do_ls_dir(struct sftp_conn *conn, char *path, char *strip_path, int lflag)
{
	int n, c = 1, colspace = 0, columns = 1;
	SFTP_DIRENT **d;

	if ((n = do_readdir(conn, path, &d)) != 0)
		return (n);

	if (!(lflag & SHORT_VIEW)) {
		int m = 0, width = 80;
		struct winsize ws;
		char *tmp;

		/* Count entries for sort and find longest filename */
		for (n = 0; d[n] != NULL; n++)
			m = MAX(m, strlen(d[n]->filename));

		/* Add any subpath that also needs to be counted */
		tmp = path_strip(path, strip_path);
		m += strlen(tmp);
		xfree(tmp);

		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
			width = ws.ws_col;

		columns = width / (m + 2);
		columns = MAX(columns, 1);
		colspace = width / columns;
		colspace = MIN(colspace, width);
	}

	qsort(d, n, sizeof(*d), sdirent_comp);

	for (n = 0; d[n] != NULL; n++) {
		char *tmp, *fname;

		tmp = path_append(path, d[n]->filename);
		fname = path_strip(tmp, strip_path);
		xfree(tmp);

		if (lflag & LONG_VIEW) {
			char *lname;
			struct stat sb;

			memset(&sb, 0, sizeof(sb));
			attrib_to_stat(&d[n]->a, &sb);
			lname = ls_file(fname, &sb, 1);
			printf("%s\n", lname);
			xfree(lname);
		} else {
			printf("%-*s", colspace, fname);
			if (c >= columns) {
				printf("\n");
				c = 1;
			} else
				c++;
		}

		xfree(fname);
	}

	if (!(lflag & LONG_VIEW) && (c != 1))
		printf("\n");

	free_sftp_dirents(d);
	return (0);
}

/* sftp ls.1 replacement which handles path globs */
static int
do_globbed_ls(struct sftp_conn *conn, char *path, char *strip_path,
    int lflag)
{
	glob_t g;
	int i, c = 1, colspace = 0, columns = 1;
	Attrib *a;

	memset(&g, 0, sizeof(g));

	if (remote_glob(conn, path, GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE,
	    NULL, &g)) {
		error("Can't ls: \"%s\" not found", path);
		return (-1);
	}

	/*
	 * If the glob returns a single match, which is the same as the
	 * input glob, and it is a directory, then just list its contents
	 */
	if (g.gl_pathc == 1 &&
	    strncmp(path, g.gl_pathv[0], strlen(g.gl_pathv[0]) - 1) == 0) {
		if ((a = do_lstat(conn, path, 1)) == NULL) {
			globfree(&g);
			return (-1);
		}
		if ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&
		    S_ISDIR(a->perm)) {
			globfree(&g);
			return (do_ls_dir(conn, path, strip_path, lflag));
		}
	}

	if (!(lflag & SHORT_VIEW)) {
		int m = 0, width = 80;
		struct winsize ws;

		/* Count entries for sort and find longest filename */
		for (i = 0; g.gl_pathv[i]; i++)
			m = MAX(m, strlen(g.gl_pathv[i]));

		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
			width = ws.ws_col;

		columns = width / (m + 2);
		columns = MAX(columns, 1);
		colspace = width / columns;
	}

	for (i = 0; g.gl_pathv[i]; i++) {
		char *fname;

		fname = path_strip(g.gl_pathv[i], strip_path);

		if (lflag & LONG_VIEW) {
			char *lname;
			struct stat sb;

			/*
			 * XXX: this is slow - 1 roundtrip per path
			 * A solution to this is to fork glob() and
			 * build a sftp specific version which keeps the
			 * attribs (which currently get thrown away)
			 * that the server returns as well as the filenames.
			 */
			memset(&sb, 0, sizeof(sb));
			a = do_lstat(conn, g.gl_pathv[i], 1);
			if (a != NULL)
				attrib_to_stat(a, &sb);
			lname = ls_file(fname, &sb, 1);
			printf("%s\n", lname);
			xfree(lname);
		} else {
			printf("%-*s", colspace, fname);
			if (c >= columns) {
				printf("\n");
				c = 1;
			} else
				c++;
		}
		xfree(fname);
	}

	if (!(lflag & LONG_VIEW) && (c != 1))
		printf("\n");

	if (g.gl_pathc)
		globfree(&g);

	return (0);
}

static int
parse_args(const char **cpp, int *pflag, int *lflag, int *iflag,
    unsigned long *n_arg, char **path1, char **path2)
{
	const char *cmd, *cp = *cpp;
	char *cp2;
	int base = 0;
	long l;
	int i, cmdnum;

	/* Skip leading whitespace */
	cp = cp + strspn(cp, WHITESPACE);

	/* Ignore blank lines and lines which begin with comment '#' char */
	if (*cp == '\0' || *cp == '#')
		return (0);

	/* Check for leading '-' (disable error processing) */
	*iflag = 0;
	if (*cp == '-') {
		*iflag = 1;
		cp++;
	}

	/* Figure out which command we have */
	for (i = 0; cmds[i].c; i++) {
		int cmdlen = strlen(cmds[i].c);

		/* Check for command followed by whitespace */
		if (!strncasecmp(cp, cmds[i].c, cmdlen) &&
		    strchr(WHITESPACE, cp[cmdlen])) {
			cp += cmdlen;
			cp = cp + strspn(cp, WHITESPACE);
			break;
		}
	}
	cmdnum = cmds[i].n;
	cmd = cmds[i].c;

	/* Special case */
	if (*cp == '!') {
		cp++;
		cmdnum = I_SHELL;
	} else if (cmdnum == -1) {
		error("Invalid command.");
		return (-1);
	}

	/* Get arguments and parse flags */
	*lflag = *pflag = *n_arg = 0;
	*path1 = *path2 = NULL;
	switch (cmdnum) {
	case I_GET:
	case I_PUT:
		if (parse_getput_flags(&cp, pflag))
			return(-1);
		/* Get first pathname (mandatory) */
		if (get_pathname(&cp, path1))
			return(-1);
		if (*path1 == NULL) {
			error("You must specify at least one path after a "
			    "%s command.", cmd);
			return(-1);
		}
		/* Try to get second pathname (optional) */
		if (get_pathname(&cp, path2))
			return(-1);
		break;
	case I_RENAME:
	case I_SYMLINK:
		if (get_pathname(&cp, path1))
			return(-1);
		if (get_pathname(&cp, path2))
			return(-1);
		if (!*path1 || !*path2) {
			error("You must specify two paths after a %s "
			    "command.", cmd);
			return(-1);
		}
		break;
	case I_RM:
	case I_MKDIR:
	case I_RMDIR:
	case I_CHDIR:
	case I_LCHDIR:
	case I_LMKDIR:
		/* Get pathname (mandatory) */
		if (get_pathname(&cp, path1))
			return(-1);
		if (*path1 == NULL) {
			error("You must specify a path after a %s command.",
			    cmd);
			return(-1);
		}
		break;
	case I_LS:
		if (parse_ls_flags(&cp, lflag))
			return(-1);
		/* Path is optional */
		if (get_pathname(&cp, path1))
			return(-1);
		break;
	case I_LLS:
	case I_SHELL:
		/* Uses the rest of the line */
		break;
	case I_LUMASK:
		base = 8;
	case I_CHMOD:
		base = 8;
	case I_CHOWN:
	case I_CHGRP:
		/* Get numeric arg (mandatory) */
		l = strtol(cp, &cp2, base);
		if (cp2 == cp || ((l == LONG_MIN || l == LONG_MAX) &&
		    errno == ERANGE) || l < 0) {
			error("You must supply a numeric argument "
			    "to the %s command.", cmd);
			return(-1);
		}
		cp = cp2;
		*n_arg = l;
		if (cmdnum == I_LUMASK && strchr(WHITESPACE, *cp))
			break;
		if (cmdnum == I_LUMASK || !strchr(WHITESPACE, *cp)) {
			error("You must supply a numeric argument "
			    "to the %s command.", cmd);
			return(-1);
		}
		cp += strspn(cp, WHITESPACE);

		/* Get pathname (mandatory) */
		if (get_pathname(&cp, path1))
			return(-1);
		if (*path1 == NULL) {
			error("You must specify a path after a %s command.",
			    cmd);
			return(-1);
		}
		break;
	case I_QUIT:
	case I_PWD:
	case I_LPWD:
	case I_HELP:
	case I_VERSION:
	case I_PROGRESS:
		break;
	default:
		fatal("Command not implemented");
	}

	*cpp = cp;
	return(cmdnum);
}

static int
parse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd,
    int err_abort)
{
	char *path1, *path2, *tmp;
	int pflag, lflag, iflag, cmdnum, i;
	unsigned long n_arg;
	Attrib a, *aa;
	char path_buf[MAXPATHLEN];
	int err = 0;
	glob_t g;

	path1 = path2 = NULL;
	cmdnum = parse_args(&cmd, &pflag, &lflag, &iflag, &n_arg,
	    &path1, &path2);

	if (iflag != 0)
		err_abort = 0;

	memset(&g, 0, sizeof(g));

	/* Perform command */
	switch (cmdnum) {
	case 0:
		/* Blank line */
		break;
	case -1:
		/* Unrecognized command */
		err = -1;
		break;
	case I_GET:
		err = process_get(conn, path1, path2, *pwd, pflag);
		break;
	case I_PUT:
		err = process_put(conn, path1, path2, *pwd, pflag);
		break;
	case I_RENAME:
		path1 = make_absolute(path1, *pwd);
		path2 = make_absolute(path2, *pwd);
		err = do_rename(conn, path1, path2);
		break;
	case I_SYMLINK:
		path2 = make_absolute(path2, *pwd);
		err = do_symlink(conn, path1, path2);
		break;
	case I_RM:
		path1 = make_absolute(path1, *pwd);
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			printf("Removing %s\n", g.gl_pathv[i]);
			err = do_rm(conn, g.gl_pathv[i]);
			if (err != 0 && err_abort)
				break;
		}
		break;
	case I_MKDIR:
		path1 = make_absolute(path1, *pwd);
		attrib_clear(&a);
		a.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;
		a.perm = 0777;
		err = do_mkdir(conn, path1, &a);
		break;
	case I_RMDIR:
		path1 = make_absolute(path1, *pwd);
		err = do_rmdir(conn, path1);
		break;
	case I_CHDIR:
		path1 = make_absolute(path1, *pwd);
		if ((tmp = do_realpath(conn, path1)) == NULL) {
			err = 1;
			break;
		}
		if ((aa = do_stat(conn, tmp, 0)) == NULL) {
			xfree(tmp);
			err = 1;
			break;
		}
		if (!(aa->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)) {
			error("Can't change directory: Can't check target");
			xfree(tmp);
			err = 1;
			break;
		}
		if (!S_ISDIR(aa->perm)) {
			error("Can't change directory: \"%s\" is not "
			    "a directory", tmp);
			xfree(tmp);
			err = 1;
			break;
		}
		xfree(*pwd);
		*pwd = tmp;
		break;
	case I_LS:
		if (!path1) {
			do_globbed_ls(conn, *pwd, *pwd, lflag);
			break;
		}

		/* Strip pwd off beginning of non-absolute paths */
		tmp = NULL;
		if (*path1 != '/')
			tmp = *pwd;

		path1 = make_absolute(path1, *pwd);
		err = do_globbed_ls(conn, path1, tmp, lflag);
		break;
	case I_LCHDIR:
		if (chdir(path1) == -1) {
			error("Couldn't change local directory to "
			    "\"%s\": %s", path1, strerror(errno));
			err = 1;
		}
		break;
	case I_LMKDIR:
		if (mkdir(path1, 0777) == -1) {
			error("Couldn't create local directory "
			    "\"%s\": %s", path1, strerror(errno));
			err = 1;
		}
		break;
	case I_LLS:
		local_do_ls(cmd);
		break;
	case I_SHELL:
		local_do_shell(cmd);
		break;
	case I_LUMASK:
		umask(n_arg);
		printf("Local umask: %03lo\n", n_arg);
		break;
	case I_CHMOD:
		path1 = make_absolute(path1, *pwd);
		attrib_clear(&a);
		a.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;
		a.perm = n_arg;
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			printf("Changing mode on %s\n", g.gl_pathv[i]);
			err = do_setstat(conn, g.gl_pathv[i], &a);
			if (err != 0 && err_abort)
				break;
		}
		break;
	case I_CHOWN:
	case I_CHGRP:
		path1 = make_absolute(path1, *pwd);
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			if (!(aa = do_stat(conn, g.gl_pathv[i], 0))) {
				if (err != 0 && err_abort)
					break;
				else
					continue;
			}
			if (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {
				error("Can't get current ownership of "
				    "remote file \"%s\"", g.gl_pathv[i]);
				if (err != 0 && err_abort)
					break;
				else
					continue;
			}
			aa->flags &= SSH2_FILEXFER_ATTR_UIDGID;
			if (cmdnum == I_CHOWN) {
				printf("Changing owner on %s\n", g.gl_pathv[i]);
				aa->uid = n_arg;
			} else {
				printf("Changing group on %s\n", g.gl_pathv[i]);
				aa->gid = n_arg;
			}
			err = do_setstat(conn, g.gl_pathv[i], aa);
			if (err != 0 && err_abort)
				break;
		}
		break;
	case I_PWD:
		printf("Remote working directory: %s\n", *pwd);
		break;
	case I_LPWD:
		if (!getcwd(path_buf, sizeof(path_buf))) {
			error("Couldn't get local cwd: %s", strerror(errno));
			err = -1;
			break;
		}
		printf("Local working directory: %s\n", path_buf);
		break;
	case I_QUIT:
		/* Processed below */
		break;
	case I_HELP:
		help();
		break;
	case I_VERSION:
		printf("SFTP protocol version %u\n", sftp_proto_version(conn));
		break;
	case I_PROGRESS:
		showprogress = !showprogress;
		if (showprogress)
			printf("Progress meter enabled\n");
		else
			printf("Progress meter disabled\n");
		break;
	default:
		fatal("%d is not implemented", cmdnum);
	}

	if (g.gl_pathc)
		globfree(&g);
	if (path1)
		xfree(path1);
	if (path2)
		xfree(path2);

	/* If an unignored error occurs in batch mode we should abort. */
	if (err_abort && err != 0)
		return (-1);
	else if (cmdnum == I_QUIT)
		return (1);

	return (0);
}

int
interactive_loop(int fd_in, int fd_out, char *file1, char *file2)
{
	char *pwd;
	char *dir = NULL;
	char cmd[2048];
	struct sftp_conn *conn;
	int err;

	conn = do_init(fd_in, fd_out, copy_buffer_len, num_requests);
	if (conn == NULL)
		fatal("Couldn't initialise connection to server");

	pwd = do_realpath(conn, ".");
	if (pwd == NULL)
		fatal("Need cwd");

	if (file1 != NULL) {
		dir = xstrdup(file1);
		dir = make_absolute(dir, pwd);

		if (remote_is_dir(conn, dir) && file2 == NULL) {
			printf("Changing to: %s\n", dir);
			snprintf(cmd, sizeof cmd, "cd \"%s\"", dir);
			if (parse_dispatch_command(conn, cmd, &pwd, 1) != 0)
				return (-1);
		} else {
			if (file2 == NULL)
				snprintf(cmd, sizeof cmd, "get %s", dir);
			else
				snprintf(cmd, sizeof cmd, "get %s %s", dir,
				    file2);

			err = parse_dispatch_command(conn, cmd, &pwd, 1);
			xfree(dir);
			xfree(pwd);
			return (err);
		}
		xfree(dir);
	}

	setvbuf(stdout, NULL, _IOLBF, 0);
	setvbuf(infile, NULL, _IOLBF, 0);

	err = 0;
	for (;;) {
		char *cp;

		printf("sftp> ");

		/* XXX: use libedit */
		if (fgets(cmd, sizeof(cmd), infile) == NULL) {
			printf("\n");
			break;
		}

		if (batchmode) /* Echo command */
			printf("%s", cmd);

		cp = strrchr(cmd, '\n');
		if (cp)
			*cp = '\0';

		err = parse_dispatch_command(conn, cmd, &pwd, batchmode);
		if (err != 0)
			break;
	}
	xfree(pwd);

	/* err == 1 signifies normal "quit" exit */
	return (err >= 0 ? 0 : -1);
}

@


1.69
log
@Remove useless headers; ok deraadt@@
@
text
@d20 1
a20 1
RCSID("$OpenBSD: sftp-int.c,v 1.68 2004/02/17 05:39:51 djm Exp $");
@


1.68
log
@switch to license.template for code written by me (belated, I know...)
@
text
@d20 1
a20 1
RCSID("$OpenBSD: sftp-int.c,v 1.67 2004/01/23 17:57:48 mouring Exp $");
a30 1
#include "sftp-glob.h"
d32 3
a34 1
#include "sftp-int.h"
d123 2
@


1.67
log
@Fix issue pointed out with ls not handling large directories with embeded
paths correctly.  OK damien@@
@
text
@d2 1
a2 1
 * Copyright (c) 2001,2002 Damien Miller.  All rights reserved.
d4 3
a6 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d8 7
a14 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d20 1
a20 1
RCSID("$OpenBSD: sftp-int.c,v 1.66 2004/01/13 09:25:05 djm Exp $");
@


1.66
log
@Tidy sftp batchmode handling, eliminate junk to stderr (bugzilla #754) and
enable use of "-b -" to accept batchfile from stdin; ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.65 2003/11/21 11:57:03 djm Exp $");
d600 1
d606 5
d617 1
@


1.65
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.64 2003/11/08 19:17:29 jmc Exp $");
d46 3
d1175 3
a1177 1
		} else if (infile != stdin) /* Bluff typing */
d1184 1
a1184 1
		err = parse_dispatch_command(conn, cmd, &pwd, infile != stdin);
@


1.64
log
@typos from Jonathon Gray;
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.63 2003/10/07 07:04:16 djm Exp $");
d365 1
a365 1
				if (cp[i] != '\'' && cp[i] != '\"' && 
d393 2
a394 2
 	xfree(*path);
	*path = NULL;	
d534 1
a534 1
			error("skipping non-regular file %s", 
d602 1
a602 1
		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1) 
d672 1
a672 1
	    		return (-1);
d683 1
a683 1
		struct winsize ws;	
d686 1
a686 1
 		for (i = 0; g.gl_pathv[i]; i++)
d763 1
a763 1
		
@


1.63
log
@sftp quoting fix from admorten AT umich.edu; ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.62 2003/08/25 08:13:09 fgsch Exp $");
d55 1
a55 1
/* Seperators for interactive commands */
@


1.62
log
@fix div by zero when listing for filename lengths longer than width.
markus@@ ok.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.60 2003/05/15 03:43:59 mouring Exp $");
d355 1
@


1.62.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.62 2003/08/25 08:13:09 fgsch Exp $");
@


1.61
log
@fix sftp filename parsing for arguments with escaped quotes. bz #517; ok markus
@
text
@d605 1
d692 1
@


1.60
log
@Teach ls how to display multiple column display and allow users to return
to single column format via 'ls -1'.  OK @@djm
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.59 2003/05/15 03:39:07 mouring Exp $");
d337 1
a337 1
	int i;
d346 2
d352 20
a371 4
		end = strchr(cp, quot);
		if (end == NULL) {
			error("Unterminated quote");
			goto fail;
d373 2
a374 1
		if (cp == end) {
d378 1
a378 1
		*cpp = end + 1 + strspn(end + 1, WHITESPACE);
d385 3
d389 1
a389 7

	i = end - cp;

	*path = xmalloc(i + 1);
	memcpy(*path, cp, i);
	(*path)[i] = '\0';
	return(0);
d392 2
a393 1
	*path = NULL;
@


1.59
log
@Make put/get (globed and nonglobed) code more consistant. OK djm@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.58 2003/04/14 21:31:27 mouring Exp $");
d58 4
d316 4
a319 1
				*lflag = 1;
d570 1
a570 1
	int n;
d576 14
a589 3
	/* Count entries for sort */
	for (n = 0; d[n] != NULL; n++)
		;
d600 1
a600 1
		if (lflag) {
d610 6
a615 2
			/* XXX - multicolumn display would be nice here */
			printf("%s\n", fname);
d621 3
d634 1
a634 1
	int i;
a635 1
	struct stat sb;
d662 15
d678 1
a678 1
		char *fname, *lname;
d682 4
a685 1
		if (lflag) {
d701 6
a706 2
			/* XXX - multicolumn display would be nice here */
			printf("%s\n", fname);
d710 3
@


1.58
log
@Missing globfree(&g) in process_put() spotted by Vince Brimhall
<VBrimhall@@novell.com>.  ok@@ Theo
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.57 2003/03/05 22:33:43 markus Exp $");
d430 2
a431 23
	/* Only one match, dst may be file, directory or unspecified */
	if (g.gl_pathv[0] && g.gl_matchc == 1) {
		if (dst) {
			/* If directory specified, append filename */
			if (is_dir(dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(dst);
		} else if (infer_path(g.gl_pathv[0], &abs_dst)) {
			err = -1;
			goto out;
		}
		err = do_download(conn, g.gl_pathv[0], abs_dst, pflag);
		goto out;
	}

	/* Multiple matches, dst may be directory or unspecified */
	if (dst && !is_dir(dst)) {
d443 13
a455 1
		if (dst) {
d499 2
a500 32
	/* Only one match, dst may be file, directory or unspecified */
	if (g.gl_pathv[0] && g.gl_matchc == 1) {
		if (!is_reg(g.gl_pathv[0])) {
			error("Can't upload %s: not a regular file",
			    g.gl_pathv[0]);
			err = 1;
			goto out;
		}
		if (tmp_dst) {
			/* If directory specified, append filename */
			if (remote_is_dir(conn, tmp_dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(tmp_dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(tmp_dst);
		} else {
			if (infer_path(g.gl_pathv[0], &abs_dst)) {
				err = -1;
				goto out;
			}
			abs_dst = make_absolute(abs_dst, pwd);
		}
		err = do_upload(conn, g.gl_pathv[0], abs_dst, pflag);
		goto out;
	}

	/* Multiple matches, dst may be directory or unspecified */
	if (tmp_dst && !remote_is_dir(conn, tmp_dst)) {
d517 14
a530 1
		if (tmp_dst) {
@


1.57
log
@fix memory leaks; from dlheine@@suif.Stanford.EDU/CLOUSEAU; ok djm@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.56 2003/01/16 03:41:55 djm Exp $");
d572 1
@


1.57.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.62 2003/08/25 08:13:09 fgsch Exp $");
a57 4
/* Define what type of ls view (0 - multi-column) */
#define LONG_VIEW 1		/* Full view ala ls -l */
#define SHORT_VIEW 2		/* Single row view ala ls -1 */

d312 1
a312 4
				*lflag = LONG_VIEW;
				break;
			case '1':
				*lflag = SHORT_VIEW;
d330 1
a330 1
	int i, j;
a338 2
	*path = xmalloc(strlen(cp) + 1);

d343 4
a346 20
		/* Search for terminating quote, unescape some chars */
		for (i = j = 0; i <= strlen(cp); i++) {
			if (cp[i] == quot) {	/* Found quote */
				(*path)[j] = '\0';
				break;
			}
			if (cp[i] == '\0') {	/* End of string */
				error("Unterminated quote");
				goto fail;
			}
			if (cp[i] == '\\') {	/* Escaped characters */
				i++;
				if (cp[i] != '\'' && cp[i] != '\"' && 
				    cp[i] != '\\') {
					error("Bad escaped character '\%c'",
					    cp[i]);
					goto fail;
				}
			}
			(*path)[j++] = cp[i];
d348 1
a348 2

		if (j == 0) {
d352 1
a352 1
		*cpp = cp + i + strspn(cp + i, WHITESPACE);
d359 3
d363 4
a366 4
		memcpy(*path, cp, end - cp);
		(*path)[end - cp] = '\0';
	}
	return (0);
d369 1
a369 2
 	xfree(*path);
	*path = NULL;	
d430 23
a452 2
	/* If multiple matches, dst must be a directory or unspecified */
	if (g.gl_matchc > 1 && dst && !is_dir(dst)) {
d464 1
a464 13

		if (g.gl_matchc == 1 && dst) {
			/* If directory specified, append filename */
			if (is_dir(dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(dst);
		} else if (dst) {
d508 32
a539 2
	/* If multiple matches, dst may be directory or unspecified */
	if (g.gl_matchc > 1 && tmp_dst && !remote_is_dir(conn, tmp_dst)) {
d556 1
a556 14

		if (g.gl_matchc == 1 && tmp_dst) {
			/* If directory specified, append filename */
			if (remote_is_dir(conn, tmp_dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(tmp_dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(tmp_dst);

		} else if (tmp_dst) {
a571 1
	globfree(&g);
d588 1
a588 1
	int n, c = 1, colspace = 0, columns = 1;
d594 3
a596 15
	if (!(lflag & SHORT_VIEW)) {
		int m = 0, width = 80;
		struct winsize ws;

		/* Count entries for sort and find longest filename */
		for (n = 0; d[n] != NULL; n++)
			m = MAX(m, strlen(d[n]->filename));

		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1) 
			width = ws.ws_col;

		columns = width / (m + 2);
		columns = MAX(columns, 1);
		colspace = width / columns;
	}
d607 1
a607 1
		if (lflag & LONG_VIEW) {
d617 2
a618 6
			printf("%-*s", colspace, fname);
			if (c >= columns) {
				printf("\n");
				c = 1;
			} else
				c++;
a623 3
	if (!(lflag & LONG_VIEW) && (c != 1))
		printf("\n");

d634 1
a634 1
	int i, c = 1, colspace = 0, columns = 1;
d636 1
a662 16
	if (!(lflag & SHORT_VIEW)) {
		int m = 0, width = 80;
		struct winsize ws;	

		/* Count entries for sort and find longest filename */
 		for (i = 0; g.gl_pathv[i]; i++)
			m = MAX(m, strlen(g.gl_pathv[i]));

		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
			width = ws.ws_col;

		columns = width / (m + 2);
		columns = MAX(columns, 1);
		colspace = width / columns;
	}

d664 1
a664 1
		char *fname;
d668 1
a668 4
		if (lflag & LONG_VIEW) {
			char *lname;
			struct stat sb;

d684 2
a685 6
			printf("%-*s", colspace, fname);
			if (c >= columns) {
				printf("\n");
				c = 1;
			} else
				c++;
a688 3

	if (!(lflag & LONG_VIEW) && (c != 1))
		printf("\n");
@


1.57.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.57.2.1 2003/09/16 20:50:43 brad Exp $");
@


1.56
log
@explicitly use first glob result
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.55 2003/01/14 10:58:00 djm Exp $");
d1109 1
@


1.55
log
@Don't try to upload or download non-regular files. Report from
apoloval@@pantuflo.escet.urjc.es; ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.54 2003/01/13 11:04:04 djm Exp $");
d510 1
a510 1
		if (!is_reg(g.gl_pathv[i])) {
@


1.54
log
@make cmds[] array static to avoid conflict with BSDI libc.
mindrot bug #466. Fix from mdev@@idg.nl; ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.53 2003/01/10 23:23:24 fgsch Exp $");
d386 11
d510 6
d547 5
@


1.53
log
@typo; from Nils Nordman <nino at nforced dot com>.
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.50 2002/11/21 23:03:51 deraadt Exp $");
d88 1
a88 1
const struct CMD cmds[] = {
@


1.52
log
@sftp progress meter support.
original diffs by Nils Nordman <nino at nforced dot com> via markus@@, merged
to -current by me, djm@@ ok.
@
text
@d142 1
a142 1
	printf("preogress                     Toggle display of progress meter\n");
@


1.51
log
@Cleanup error handling for batchmode
Allow blank lines and comments in input
Ability to suppress abort on error in batchmode ("-put blah")

Fixes mindrot bug #452; markus@@ ok
@
text
@d52 3
d81 1
d109 1
d142 1
a435 1
		printf("Fetching %s to %s\n", g.gl_pathv[0], abs_dst);
a516 1
		printf("Uploading %s to %s\n", g.gl_pathv[0], abs_dst);
d819 1
d1024 7
@


1.50
log
@KNF
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.49 2002/09/12 00:13:06 djm Exp $");
d671 1
a671 1
parse_args(const char **cpp, int *pflag, int *lflag,
d683 3
a685 3
	/* Ignore blank lines */
	if (!*cp)
		return(-1);
d687 7
d715 1
a715 1
		return(-1);
d825 2
a826 1
parse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd)
d829 1
a829 1
	int pflag, lflag, cmdnum, i;
d837 1
a837 1
	cmdnum = parse_args(&cmd, &pflag, &lflag, &n_arg,
d840 3
d847 3
d851 2
d874 3
a876 2
			if (do_rm(conn, g.gl_pathv[i]) == -1)
				err = -1;
d929 1
a929 2

		do_globbed_ls(conn, path1, tmp, lflag);
d963 3
a965 1
			do_setstat(conn, g.gl_pathv[i], &a);
d969 1
d973 6
a978 2
			if (!(aa = do_stat(conn, g.gl_pathv[i], 0)))
				continue;
d982 4
a985 1
				continue;
a986 1
			printf("Changing owner on %s\n", g.gl_pathv[i]);
d988 6
a993 14
			aa->uid = n_arg;
			do_setstat(conn, g.gl_pathv[i], aa);
		}
		break;
	case I_CHGRP:
		path1 = make_absolute(path1, *pwd);
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			if (!(aa = do_stat(conn, g.gl_pathv[i], 0)))
				continue;
			if (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {
				error("Can't get current ownership of "
				    "remote file \"%s\"", g.gl_pathv[i]);
				continue;
d995 3
a997 4
			printf("Changing group on %s\n", g.gl_pathv[i]);
			aa->flags &= SSH2_FILEXFER_ATTR_UIDGID;
			aa->gid = n_arg;
			do_setstat(conn, g.gl_pathv[i], aa);
d1004 6
a1009 6
		if (!getcwd(path_buf, sizeof(path_buf)))
			error("Couldn't get local cwd: %s",
			    strerror(errno));
		else
			printf("Local working directory: %s\n",
			    path_buf);
d1012 2
a1013 1
		return(-1);
d1031 5
a1035 3
	/* If an error occurs in batch mode we should abort. */
	if (infile != stdin && err > 0)
		return -1;
d1037 1
a1037 1
	return(0);
d1040 1
a1040 1
void
d1047 1
d1064 2
a1065 1
			parse_dispatch_command(conn, cmd, &pwd);
d1073 1
a1073 1
			parse_dispatch_command(conn, cmd, &pwd);
d1075 1
a1075 1
			return;
d1079 1
d1083 1
d1100 2
a1101 1
		if (parse_dispatch_command(conn, cmd, &pwd))
d1105 3
d1109 1
@


1.49
log
@zap unused var introduced in last commit
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.48 2002/09/11 22:41:50 djm Exp $");
d555 1
a555 1
	return (strcmp(a->filename, b->filename));	
d568 1
a568 1
	/* Count entries for sort */	
d576 1
a576 1
		
d594 1
a594 1
		
d604 1
a604 1
do_globbed_ls(struct sftp_conn *conn, char *path, char *strip_path, 
d614 1
a614 1
	if (remote_glob(conn, path, GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE, 
d621 1
a621 1
	 * If the glob returns a single match, which is the same as the 
d624 1
a624 1
	if (g.gl_pathc == 1 && 
d630 1
a630 1
		if ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) && 
d645 2
a646 2
			 * A solution to this is to fork glob() and 
			 * build a sftp specific version which keeps the 
d671 1
a671 1
parse_args(const char **cpp, int *pflag, int *lflag, 
d905 1
a905 1
		
@


1.49.2.1
log
@Update to OpenSSH 3.6
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.57 2003/03/05 22:33:43 markus Exp $");
a51 3
/* This is set to 0 if the progressmeter is not desired. */
int showprogress = 1;

a77 1
#define I_PROGRESS	23
d84 1
a84 1
static const struct CMD cmds[] = {
a104 1
	{ "progress",	I_PROGRESS },
a136 1
	printf("progress                      Toggle display of progress meter\n");
a379 11
is_reg(char *path)
{
	struct stat sb;

	if (stat(path, &sb) == -1)
		fatal("stat %s: %s", path, strerror(errno));

	return(S_ISREG(sb.st_mode));
}

static int
d430 1
a493 6
		if (!is_reg(g.gl_pathv[0])) {
			error("Can't upload %s: not a regular file",
			    g.gl_pathv[0]);
			err = 1;
			goto out;
		}
d512 1
a525 5
		if (!is_reg(g.gl_pathv[i])) {
			error("skipping non-regular file %s", 
			    g.gl_pathv[i]);
			continue;
		}
d555 1
a555 1
	return (strcmp(a->filename, b->filename));
d568 1
a568 1
	/* Count entries for sort */
d576 1
a576 1

d594 1
a594 1

d604 1
a604 1
do_globbed_ls(struct sftp_conn *conn, char *path, char *strip_path,
d614 1
a614 1
	if (remote_glob(conn, path, GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE,
d621 1
a621 1
	 * If the glob returns a single match, which is the same as the
d624 1
a624 1
	if (g.gl_pathc == 1 &&
d630 1
a630 1
		if ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&
d645 2
a646 2
			 * A solution to this is to fork glob() and
			 * build a sftp specific version which keeps the
d671 1
a671 1
parse_args(const char **cpp, int *pflag, int *lflag, int *iflag,
d683 3
a685 3
	/* Ignore blank lines and lines which begin with comment '#' char */
	if (*cp == '\0' || *cp == '#')
		return (0);
a686 7
	/* Check for leading '-' (disable error processing) */
	*iflag = 0;
	if (*cp == '-') {
		*iflag = 1;
		cp++;
	}
		
d708 1
a708 1
		return (-1);
a807 1
	case I_PROGRESS:
d818 1
a818 2
parse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd,
    int err_abort)
d821 1
a821 1
	int pflag, lflag, iflag, cmdnum, i;
d829 1
a829 1
	cmdnum = parse_args(&cmd, &pflag, &lflag, &iflag, &n_arg,
a831 3
	if (iflag != 0)
		err_abort = 0;

a835 3
	case 0:
		/* Blank line */
		break;
a836 2
		/* Unrecognized command */
		err = -1;
d858 2
a859 3
			err = do_rm(conn, g.gl_pathv[i]);
			if (err != 0 && err_abort)
				break;
d905 1
a905 1

d912 2
a913 1
		err = do_globbed_ls(conn, path1, tmp, lflag);
d947 1
a947 3
			err = do_setstat(conn, g.gl_pathv[i], &a);
			if (err != 0 && err_abort)
				break;
d951 16
d971 2
a972 6
			if (!(aa = do_stat(conn, g.gl_pathv[i], 0))) {
				if (err != 0 && err_abort)
					break;
				else
					continue;
			}
d976 1
a976 4
				if (err != 0 && err_abort)
					break;
				else
					continue;
d978 1
d980 2
a981 10
			if (cmdnum == I_CHOWN) {
				printf("Changing owner on %s\n", g.gl_pathv[i]);
				aa->uid = n_arg;
			} else {
				printf("Changing group on %s\n", g.gl_pathv[i]);
				aa->gid = n_arg;
			}
			err = do_setstat(conn, g.gl_pathv[i], aa);
			if (err != 0 && err_abort)
				break;
d988 6
a993 6
		if (!getcwd(path_buf, sizeof(path_buf))) {
			error("Couldn't get local cwd: %s", strerror(errno));
			err = -1;
			break;
		}
		printf("Local working directory: %s\n", path_buf);
d996 1
a996 2
		/* Processed below */
		break;
a1002 7
	case I_PROGRESS:
		showprogress = !showprogress;
		if (showprogress)
			printf("Progress meter enabled\n");
		else
			printf("Progress meter disabled\n");
		break;
d1014 3
a1016 5
	/* If an unignored error occurs in batch mode we should abort. */
	if (err_abort && err != 0)
		return (-1);
	else if (cmdnum == I_QUIT)
		return (1);
d1018 1
a1018 1
	return (0);
d1021 1
a1021 1
int
a1027 1
	int err;
d1044 1
a1044 2
			if (parse_dispatch_command(conn, cmd, &pwd, 1) != 0)
				return (-1);
d1052 1
a1052 1
			err = parse_dispatch_command(conn, cmd, &pwd, 1);
d1054 1
a1054 2
			xfree(pwd);
			return (err);
a1057 1

a1060 1
	err = 0;
d1077 1
a1077 2
		err = parse_dispatch_command(conn, cmd, &pwd, infile != stdin);
		if (err != 0)
a1080 3

	/* err == 1 signifies normal "quit" exit */
	return (err >= 0 ? 0 : -1);
a1081 1

@


1.49.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.62 2003/08/25 08:13:09 fgsch Exp $");
a57 4
/* Define what type of ls view (0 - multi-column) */
#define LONG_VIEW 1		/* Full view ala ls -l */
#define SHORT_VIEW 2		/* Single row view ala ls -1 */

d312 1
a312 4
				*lflag = LONG_VIEW;
				break;
			case '1':
				*lflag = SHORT_VIEW;
d330 1
a330 1
	int i, j;
a338 2
	*path = xmalloc(strlen(cp) + 1);

d343 4
a346 20
		/* Search for terminating quote, unescape some chars */
		for (i = j = 0; i <= strlen(cp); i++) {
			if (cp[i] == quot) {	/* Found quote */
				(*path)[j] = '\0';
				break;
			}
			if (cp[i] == '\0') {	/* End of string */
				error("Unterminated quote");
				goto fail;
			}
			if (cp[i] == '\\') {	/* Escaped characters */
				i++;
				if (cp[i] != '\'' && cp[i] != '\"' && 
				    cp[i] != '\\') {
					error("Bad escaped character '\%c'",
					    cp[i]);
					goto fail;
				}
			}
			(*path)[j++] = cp[i];
d348 1
a348 2

		if (j == 0) {
d352 1
a352 1
		*cpp = cp + i + strspn(cp + i, WHITESPACE);
d359 3
d363 4
a366 4
		memcpy(*path, cp, end - cp);
		(*path)[end - cp] = '\0';
	}
	return (0);
d369 1
a369 2
 	xfree(*path);
	*path = NULL;	
d430 23
a452 2
	/* If multiple matches, dst must be a directory or unspecified */
	if (g.gl_matchc > 1 && dst && !is_dir(dst)) {
d464 1
a464 13

		if (g.gl_matchc == 1 && dst) {
			/* If directory specified, append filename */
			if (is_dir(dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(dst);
		} else if (dst) {
d508 32
a539 2
	/* If multiple matches, dst may be directory or unspecified */
	if (g.gl_matchc > 1 && tmp_dst && !remote_is_dir(conn, tmp_dst)) {
d556 1
a556 14

		if (g.gl_matchc == 1 && tmp_dst) {
			/* If directory specified, append filename */
			if (remote_is_dir(conn, tmp_dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(tmp_dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(tmp_dst);

		} else if (tmp_dst) {
a571 1
	globfree(&g);
d588 1
a588 1
	int n, c = 1, colspace = 0, columns = 1;
d594 3
a596 15
	if (!(lflag & SHORT_VIEW)) {
		int m = 0, width = 80;
		struct winsize ws;

		/* Count entries for sort and find longest filename */
		for (n = 0; d[n] != NULL; n++)
			m = MAX(m, strlen(d[n]->filename));

		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1) 
			width = ws.ws_col;

		columns = width / (m + 2);
		columns = MAX(columns, 1);
		colspace = width / columns;
	}
d607 1
a607 1
		if (lflag & LONG_VIEW) {
d617 2
a618 6
			printf("%-*s", colspace, fname);
			if (c >= columns) {
				printf("\n");
				c = 1;
			} else
				c++;
a623 3
	if (!(lflag & LONG_VIEW) && (c != 1))
		printf("\n");

d634 1
a634 1
	int i, c = 1, colspace = 0, columns = 1;
d636 1
a662 16
	if (!(lflag & SHORT_VIEW)) {
		int m = 0, width = 80;
		struct winsize ws;	

		/* Count entries for sort and find longest filename */
 		for (i = 0; g.gl_pathv[i]; i++)
			m = MAX(m, strlen(g.gl_pathv[i]));

		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
			width = ws.ws_col;

		columns = width / (m + 2);
		columns = MAX(columns, 1);
		colspace = width / columns;
	}

d664 1
a664 1
		char *fname;
d668 1
a668 4
		if (lflag & LONG_VIEW) {
			char *lname;
			struct stat sb;

d684 2
a685 6
			printf("%-*s", colspace, fname);
			if (c >= columns) {
				printf("\n");
				c = 1;
			} else
				c++;
a688 3

	if (!(lflag & LONG_VIEW) && (c != 1))
		printf("\n");
@


1.48
log
@support for short/long listings and globbing in "ls"; ok markus@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.47 2002/06/23 09:30:14 deraadt Exp $");
a209 1
	char *ret;
@


1.47
log
@bunch of u_int vs int stuff
@
text
@a24 1
/* XXX: globbed ls */
d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.46 2002/03/30 18:51:15 markus Exp $");
d205 20
d233 1
a233 1
	if (strcmp(p1, "/") != 0)
d298 23
d551 123
a673 2
parse_args(const char **cpp, int *pflag, unsigned long *n_arg,
    char **path1, char **path2)
d713 1
a713 1
	*pflag = *n_arg = 0;
d760 2
d822 1
a822 1
	int pflag, cmdnum, i;
d830 2
a831 1
	cmdnum = parse_args(&cmd, &pflag, &n_arg, &path1, &path2);
d903 1
a903 1
			do_ls(conn, *pwd);
d906 6
d913 2
a914 12
		if ((tmp = do_realpath(conn, path1)) == NULL)
			break;
		xfree(path1);
		path1 = tmp;
		if ((aa = do_stat(conn, path1, 0)) == NULL)
			break;
		if ((aa->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&
		    !S_ISDIR(aa->perm)) {
			error("Can't ls: \"%s\" is not a directory", path1);
			break;
		}
		do_ls(conn, path1);
@


1.46
log
@check waitpid for EINTR; based on patch from peter@@ifm.liu.se
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.45 2002/03/19 06:32:56 mpech Exp $");
d840 1
a840 1
		printf("SFTP protocol version %d\n", sftp_proto_version(conn));
@


1.46.2.1
log
@Pull in OpenSSH-3.4
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.47 2002/06/23 09:30:14 deraadt Exp $");
d840 1
a840 1
		printf("SFTP protocol version %u\n", sftp_proto_version(conn));
@


1.46.2.2
log
@Update to OpenSSH 3.5
@
text
@d25 1
d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.49 2002/09/12 00:13:06 djm Exp $");
a205 19
/* Strip one path (usually the pwd) from the start of another */
static char *
path_strip(char *path, char *strip)
{
	size_t len;

	if (strip == NULL)
		return (xstrdup(path));

	len = strlen(strip);
	if (strip != NULL && strncmp(path, strip, len) == 0) {
		if (strip[len - 1] != '/' && path[len] == '/')
			len++;
		return (xstrdup(path + len));
	}

	return (xstrdup(path));
}

d214 1
a214 1
	if (p1[strlen(p1) - 1] != '/')
a278 23
parse_ls_flags(const char **cpp, int *lflag)
{
	const char *cp = *cpp;

	/* Check for flags */
	if (cp++[0] == '-') {
		for(; strchr(WHITESPACE, *cp) == NULL; cp++) {
			switch (*cp) {
			case 'l':
				*lflag = 1;
				break;
			default:
				error("Invalid flag -%c", *cp);
				return(-1);
			}
		}
		*cpp = cp + strspn(cp, WHITESPACE);
	}

	return(0);
}

static int
d509 2
a510 123
sdirent_comp(const void *aa, const void *bb)
{
	SFTP_DIRENT *a = *(SFTP_DIRENT **)aa;
	SFTP_DIRENT *b = *(SFTP_DIRENT **)bb;

	return (strcmp(a->filename, b->filename));	
}

/* sftp ls.1 replacement for directories */
static int
do_ls_dir(struct sftp_conn *conn, char *path, char *strip_path, int lflag)
{
	int n;
	SFTP_DIRENT **d;

	if ((n = do_readdir(conn, path, &d)) != 0)
		return (n);

	/* Count entries for sort */	
	for (n = 0; d[n] != NULL; n++)
		;

	qsort(d, n, sizeof(*d), sdirent_comp);

	for (n = 0; d[n] != NULL; n++) {
		char *tmp, *fname;
		
		tmp = path_append(path, d[n]->filename);
		fname = path_strip(tmp, strip_path);
		xfree(tmp);

		if (lflag) {
			char *lname;
			struct stat sb;

			memset(&sb, 0, sizeof(sb));
			attrib_to_stat(&d[n]->a, &sb);
			lname = ls_file(fname, &sb, 1);
			printf("%s\n", lname);
			xfree(lname);
		} else {
			/* XXX - multicolumn display would be nice here */
			printf("%s\n", fname);
		}
		
		xfree(fname);
	}

	free_sftp_dirents(d);
	return (0);
}

/* sftp ls.1 replacement which handles path globs */
static int
do_globbed_ls(struct sftp_conn *conn, char *path, char *strip_path, 
    int lflag)
{
	glob_t g;
	int i;
	Attrib *a;
	struct stat sb;

	memset(&g, 0, sizeof(g));

	if (remote_glob(conn, path, GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE, 
	    NULL, &g)) {
		error("Can't ls: \"%s\" not found", path);
		return (-1);
	}

	/*
	 * If the glob returns a single match, which is the same as the 
	 * input glob, and it is a directory, then just list its contents
	 */
	if (g.gl_pathc == 1 && 
	    strncmp(path, g.gl_pathv[0], strlen(g.gl_pathv[0]) - 1) == 0) {
		if ((a = do_lstat(conn, path, 1)) == NULL) {
			globfree(&g);
	    		return (-1);
		}
		if ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) && 
		    S_ISDIR(a->perm)) {
			globfree(&g);
			return (do_ls_dir(conn, path, strip_path, lflag));
		}
	}

	for (i = 0; g.gl_pathv[i]; i++) {
		char *fname, *lname;

		fname = path_strip(g.gl_pathv[i], strip_path);

		if (lflag) {
			/*
			 * XXX: this is slow - 1 roundtrip per path
			 * A solution to this is to fork glob() and 
			 * build a sftp specific version which keeps the 
			 * attribs (which currently get thrown away)
			 * that the server returns as well as the filenames.
			 */
			memset(&sb, 0, sizeof(sb));
			a = do_lstat(conn, g.gl_pathv[i], 1);
			if (a != NULL)
				attrib_to_stat(a, &sb);
			lname = ls_file(fname, &sb, 1);
			printf("%s\n", lname);
			xfree(lname);
		} else {
			/* XXX - multicolumn display would be nice here */
			printf("%s\n", fname);
		}
		xfree(fname);
	}

	if (g.gl_pathc)
		globfree(&g);

	return (0);
}

static int
parse_args(const char **cpp, int *pflag, int *lflag, 
    unsigned long *n_arg, char **path1, char **path2)
d550 1
a550 1
	*lflag = *pflag = *n_arg = 0;
a596 2
		if (parse_ls_flags(&cp, lflag))
			return(-1);
d657 1
a657 1
	int pflag, lflag, cmdnum, i;
d665 1
a665 2
	cmdnum = parse_args(&cmd, &pflag, &lflag, &n_arg,
	    &path1, &path2);
d737 1
a737 1
			do_globbed_ls(conn, *pwd, *pwd, lflag);
a739 6
		
		/* Strip pwd off beginning of non-absolute paths */
		tmp = NULL;
		if (*path1 != '/')
			tmp = *pwd;

d741 12
a752 2

		do_globbed_ls(conn, path1, tmp, lflag);
@


1.46.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d28 1
a28 1
RCSID("$OpenBSD: sftp-int.c,v 1.57 2003/03/05 22:33:43 markus Exp $");
a51 3
/* This is set to 0 if the progressmeter is not desired. */
int showprogress = 1;

a77 1
#define I_PROGRESS	23
d84 1
a84 1
static const struct CMD cmds[] = {
a104 1
	{ "progress",	I_PROGRESS },
a136 1
	printf("progress                      Toggle display of progress meter\n");
a379 11
is_reg(char *path)
{
	struct stat sb;

	if (stat(path, &sb) == -1)
		fatal("stat %s: %s", path, strerror(errno));

	return(S_ISREG(sb.st_mode));
}

static int
d430 1
a493 6
		if (!is_reg(g.gl_pathv[0])) {
			error("Can't upload %s: not a regular file",
			    g.gl_pathv[0]);
			err = 1;
			goto out;
		}
d512 1
a525 5
		if (!is_reg(g.gl_pathv[i])) {
			error("skipping non-regular file %s", 
			    g.gl_pathv[i]);
			continue;
		}
d555 1
a555 1
	return (strcmp(a->filename, b->filename));
d568 1
a568 1
	/* Count entries for sort */
d576 1
a576 1

d594 1
a594 1

d604 1
a604 1
do_globbed_ls(struct sftp_conn *conn, char *path, char *strip_path,
d614 1
a614 1
	if (remote_glob(conn, path, GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE,
d621 1
a621 1
	 * If the glob returns a single match, which is the same as the
d624 1
a624 1
	if (g.gl_pathc == 1 &&
d630 1
a630 1
		if ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&
d645 2
a646 2
			 * A solution to this is to fork glob() and
			 * build a sftp specific version which keeps the
d671 1
a671 1
parse_args(const char **cpp, int *pflag, int *lflag, int *iflag,
d683 3
a685 3
	/* Ignore blank lines and lines which begin with comment '#' char */
	if (*cp == '\0' || *cp == '#')
		return (0);
a686 7
	/* Check for leading '-' (disable error processing) */
	*iflag = 0;
	if (*cp == '-') {
		*iflag = 1;
		cp++;
	}
		
d708 1
a708 1
		return (-1);
a807 1
	case I_PROGRESS:
d818 1
a818 2
parse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd,
    int err_abort)
d821 1
a821 1
	int pflag, lflag, iflag, cmdnum, i;
d829 1
a829 1
	cmdnum = parse_args(&cmd, &pflag, &lflag, &iflag, &n_arg,
a831 3
	if (iflag != 0)
		err_abort = 0;

a835 3
	case 0:
		/* Blank line */
		break;
a836 2
		/* Unrecognized command */
		err = -1;
d858 2
a859 3
			err = do_rm(conn, g.gl_pathv[i]);
			if (err != 0 && err_abort)
				break;
d905 1
a905 1

d912 2
a913 1
		err = do_globbed_ls(conn, path1, tmp, lflag);
d947 1
a947 3
			err = do_setstat(conn, g.gl_pathv[i], &a);
			if (err != 0 && err_abort)
				break;
d951 16
d971 2
a972 6
			if (!(aa = do_stat(conn, g.gl_pathv[i], 0))) {
				if (err != 0 && err_abort)
					break;
				else
					continue;
			}
d976 1
a976 4
				if (err != 0 && err_abort)
					break;
				else
					continue;
d978 1
d980 2
a981 10
			if (cmdnum == I_CHOWN) {
				printf("Changing owner on %s\n", g.gl_pathv[i]);
				aa->uid = n_arg;
			} else {
				printf("Changing group on %s\n", g.gl_pathv[i]);
				aa->gid = n_arg;
			}
			err = do_setstat(conn, g.gl_pathv[i], aa);
			if (err != 0 && err_abort)
				break;
d988 6
a993 6
		if (!getcwd(path_buf, sizeof(path_buf))) {
			error("Couldn't get local cwd: %s", strerror(errno));
			err = -1;
			break;
		}
		printf("Local working directory: %s\n", path_buf);
d996 1
a996 2
		/* Processed below */
		break;
a1002 7
	case I_PROGRESS:
		showprogress = !showprogress;
		if (showprogress)
			printf("Progress meter enabled\n");
		else
			printf("Progress meter disabled\n");
		break;
d1014 3
a1016 5
	/* If an unignored error occurs in batch mode we should abort. */
	if (err_abort && err != 0)
		return (-1);
	else if (cmdnum == I_QUIT)
		return (1);
d1018 1
a1018 1
	return (0);
d1021 1
a1021 1
int
a1027 1
	int err;
d1044 1
a1044 2
			if (parse_dispatch_command(conn, cmd, &pwd, 1) != 0)
				return (-1);
d1052 1
a1052 1
			err = parse_dispatch_command(conn, cmd, &pwd, 1);
d1054 1
a1054 2
			xfree(pwd);
			return (err);
a1057 1

a1060 1
	err = 0;
d1077 1
a1077 2
		err = parse_dispatch_command(conn, cmd, &pwd, infile != stdin);
		if (err != 0)
a1080 3

	/* err == 1 signifies normal "quit" exit */
	return (err >= 0 ? 0 : -1);
a1081 1

@


1.45
log
@use xfree() after xstrdup().

markus@@ ok
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.44 2002/02/13 00:59:23 djm Exp $");
d181 3
a183 2
	if (waitpid(pid, &status, 0) == -1)
		fatal("Couldn't wait for child: %s", strerror(errno));
@


1.44
log
@API cleanup and backwards compat for filexfer v.0 servers; ok markus@@
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.43 2002/02/12 12:32:27 djm Exp $");
d891 1
d894 1
@


1.43
log
@Perform multiple overlapping read/write requests in file transfer. Mostly
done by Tobias Ringstrom <tori@@ringstrom.mine.nu>; ok markus@@
@
text
@d2 1
a2 1
 * Copyright (c) 2001 Damien Miller.  All rights reserved.
d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.42 2002/02/05 00:00:46 djm Exp $");
a52 3
/* Version of server we are speaking to */
int version;

d338 1
a338 1
remote_is_dir(int in, int out, char *path)
d343 1
a343 1
	if ((a = do_stat(in, out, path, 1)) == NULL)
d351 1
a351 1
process_get(int in, int out, char *src, char *dst, char *pwd, int pflag)
d365 1
a365 1
	if (remote_glob(in, out, abs_src, 0, NULL, &g)) {
d389 1
a389 2
		err = do_download(in, out, g.gl_pathv[0], abs_dst, pflag,
		    copy_buffer_len, num_requests);
d413 1
a413 2
		if (do_download(in, out, g.gl_pathv[i], abs_dst, pflag,
		    copy_buffer_len, num_requests) == -1)
d428 1
a428 1
process_put(int in, int out, char *src, char *dst, char *pwd, int pflag)
d454 1
a454 1
			if (remote_is_dir(in, out, tmp_dst)) {
d471 1
a471 2
		err = do_upload(in, out, g.gl_pathv[0], abs_dst, pflag,
		    copy_buffer_len, num_requests);
d476 1
a476 1
	if (tmp_dst && !remote_is_dir(in, out, tmp_dst)) {
d495 1
a495 2
		if (do_upload(in, out, g.gl_pathv[i], abs_dst, pflag, 
		    copy_buffer_len, num_requests) == -1)
d653 1
a653 1
parse_dispatch_command(int in, int out, const char *cmd, char **pwd)
d673 1
a673 1
		err = process_get(in, out, path1, path2, *pwd, pflag);
d676 1
a676 1
		err = process_put(in, out, path1, path2, *pwd, pflag);
d681 1
a681 1
		err = do_rename(in, out, path1, path2);
d684 2
a685 8
		if (version < 3) {
			error("The server (version %d) does not support "
			    "this operation", version);
			err = -1;
		} else {
			path2 = make_absolute(path2, *pwd);
			err = do_symlink(in, out, path1, path2);
		}
d689 1
a689 1
		remote_glob(in, out, path1, GLOB_NOCHECK, NULL, &g);
d692 1
a692 1
			if (do_rm(in, out, g.gl_pathv[i]) == -1)
d701 1
a701 1
		err = do_mkdir(in, out, path1, &a);
d705 1
a705 1
		err = do_rmdir(in, out, path1);
d709 1
a709 1
		if ((tmp = do_realpath(in, out, path1)) == NULL) {
d713 1
a713 1
		if ((aa = do_stat(in, out, tmp, 0)) == NULL) {
d736 1
a736 1
			do_ls(in, out, *pwd);
d740 1
a740 1
		if ((tmp = do_realpath(in, out, path1)) == NULL)
d744 1
a744 1
		if ((aa = do_stat(in, out, path1, 0)) == NULL)
d751 1
a751 1
		do_ls(in, out, path1);
d782 1
a782 1
		remote_glob(in, out, path1, GLOB_NOCHECK, NULL, &g);
d785 1
a785 1
			do_setstat(in, out, g.gl_pathv[i], &a);
d790 1
a790 1
		remote_glob(in, out, path1, GLOB_NOCHECK, NULL, &g);
d792 1
a792 1
			if (!(aa = do_stat(in, out, g.gl_pathv[i], 0)))
d802 1
a802 1
			do_setstat(in, out, g.gl_pathv[i], aa);
d807 1
a807 1
		remote_glob(in, out, path1, GLOB_NOCHECK, NULL, &g);
d809 1
a809 1
			if (!(aa = do_stat(in, out, g.gl_pathv[i], 0)))
d819 1
a819 1
			do_setstat(in, out, g.gl_pathv[i], aa);
d839 1
a839 1
		printf("SFTP protocol version %d\n", version);
d865 1
d867 2
a868 2
	version = do_init(fd_in, fd_out);
	if (version == -1)
d871 1
a871 1
	pwd = do_realpath(fd_in, fd_out, ".");
d879 1
a879 1
		if (remote_is_dir(fd_in, fd_out, dir) && file2 == NULL) {
d882 1
a882 1
			parse_dispatch_command(fd_in, fd_out, cmd, &pwd);
d890 1
a890 1
			parse_dispatch_command(fd_in, fd_out, cmd, &pwd);
d913 1
a913 1
		if (parse_dispatch_command(fd_in, fd_out, cmd, &pwd))
@


1.42
log
@Add "-B" option to specify copy buffer length (default 32k); ok markus@@
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.41 2001/12/19 07:18:56 deraadt Exp $");
d50 3
d393 1
a393 1
		    copy_buffer_len);
d418 1
a418 1
		    copy_buffer_len) == -1)
d477 1
a477 1
		    copy_buffer_len);
d502 1
a502 1
		    copy_buffer_len) == -1)
@


1.41
log
@basic KNF done while i was looking for something else
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.40 2001/08/14 09:23:02 markus Exp $");
d47 3
d389 2
a390 1
		err = do_download(in, out, g.gl_pathv[0], abs_dst, pflag);
d414 2
a415 1
		if (do_download(in, out, g.gl_pathv[i], abs_dst, pflag) == -1)
d473 2
a474 1
		err = do_upload(in, out, g.gl_pathv[0], abs_dst, pflag);
d498 2
a499 1
		if (do_upload(in, out, g.gl_pathv[i], abs_dst, pflag) == -1)
@


1.40
log
@"bye"; hk63a@@netscape.net
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.39 2001/07/31 12:42:50 jakob Exp $");
d210 1
a210 1
	if (strcmp(p1, "/") != 0) 
d398 1
a398 1
	for(i = 0; g.gl_pathv[i]; i++) {
d480 1
a480 1
	for(i = 0; g.gl_pathv[i]; i++) {
d522 1
a522 1
	for(i = 0; cmds[i].c; i++) {
d693 1
a693 1
		for(i = 0; g.gl_pathv[i]; i++) {
d786 1
a786 1
		for(i = 0; g.gl_pathv[i]; i++) {
d794 1
a794 1
		for(i = 0; g.gl_pathv[i]; i++) {
d811 1
a811 1
		for(i = 0; g.gl_pathv[i]; i++) {
d899 1
a899 1
	for(;;) {
@


1.40.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d2 1
a2 1
 * Copyright (c) 2001,2002 Damien Miller.  All rights reserved.
d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.44 2002/02/13 00:59:23 djm Exp $");
d47 2
a48 5
/* Size of buffer used when copying files */
extern size_t copy_buffer_len;

/* Number of concurrent outstanding requests */
extern int num_requests;
d210 1
a210 1
	if (strcmp(p1, "/") != 0)
d335 1
a335 1
remote_is_dir(struct sftp_conn *conn, char *path)
d340 1
a340 1
	if ((a = do_stat(conn, path, 1)) == NULL)
d348 1
a348 1
process_get(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
d362 1
a362 1
	if (remote_glob(conn, abs_src, 0, NULL, &g)) {
d386 1
a386 1
		err = do_download(conn, g.gl_pathv[0], abs_dst, pflag);
d398 1
a398 1
	for (i = 0; g.gl_pathv[i]; i++) {
d410 1
a410 1
		if (do_download(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
d425 1
a425 1
process_put(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
d451 1
a451 1
			if (remote_is_dir(conn, tmp_dst)) {
d468 1
a468 1
		err = do_upload(conn, g.gl_pathv[0], abs_dst, pflag);
d473 1
a473 1
	if (tmp_dst && !remote_is_dir(conn, tmp_dst)) {
d480 1
a480 1
	for (i = 0; g.gl_pathv[i]; i++) {
d492 1
a492 1
		if (do_upload(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
d522 1
a522 1
	for (i = 0; cmds[i].c; i++) {
d650 1
a650 1
parse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd)
d670 1
a670 1
		err = process_get(conn, path1, path2, *pwd, pflag);
d673 1
a673 1
		err = process_put(conn, path1, path2, *pwd, pflag);
d678 1
a678 1
		err = do_rename(conn, path1, path2);
d681 8
a688 2
		path2 = make_absolute(path2, *pwd);
		err = do_symlink(conn, path1, path2);
d692 2
a693 2
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
d695 1
a695 1
			if (do_rm(conn, g.gl_pathv[i]) == -1)
d704 1
a704 1
		err = do_mkdir(conn, path1, &a);
d708 1
a708 1
		err = do_rmdir(conn, path1);
d712 1
a712 1
		if ((tmp = do_realpath(conn, path1)) == NULL) {
d716 1
a716 1
		if ((aa = do_stat(conn, tmp, 0)) == NULL) {
d739 1
a739 1
			do_ls(conn, *pwd);
d743 1
a743 1
		if ((tmp = do_realpath(conn, path1)) == NULL)
d747 1
a747 1
		if ((aa = do_stat(conn, path1, 0)) == NULL)
d754 1
a754 1
		do_ls(conn, path1);
d785 2
a786 2
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
d788 1
a788 1
			do_setstat(conn, g.gl_pathv[i], &a);
d793 3
a795 3
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			if (!(aa = do_stat(conn, g.gl_pathv[i], 0)))
d805 1
a805 1
			do_setstat(conn, g.gl_pathv[i], aa);
d810 3
a812 3
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			if (!(aa = do_stat(conn, g.gl_pathv[i], 0)))
d822 1
a822 1
			do_setstat(conn, g.gl_pathv[i], aa);
d842 1
a842 1
		printf("SFTP protocol version %d\n", sftp_proto_version(conn));
a867 1
	struct sftp_conn *conn;
d869 2
a870 2
	conn = do_init(fd_in, fd_out, copy_buffer_len, num_requests);
	if (conn == NULL)
d873 1
a873 1
	pwd = do_realpath(conn, ".");
d881 1
a881 1
		if (remote_is_dir(conn, dir) && file2 == NULL) {
d884 1
a884 1
			parse_dispatch_command(conn, cmd, &pwd);
d892 1
a892 1
			parse_dispatch_command(conn, cmd, &pwd);
d899 1
a899 1
	for (;;) {
d915 1
a915 1
		if (parse_dispatch_command(conn, cmd, &pwd))
@


1.40.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.46 2002/03/30 18:51:15 markus Exp $");
d181 2
a182 3
	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for child: %s", strerror(errno));
a890 1
			xfree(dir);
a892 1
		xfree(dir);
@


1.40.2.3
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.40.2.2 2002/05/17 00:03:24 miod Exp $");
d840 1
a840 1
		printf("SFTP protocol version %u\n", sftp_proto_version(conn));
@


1.40.2.4
log
@Update to OpenSSH 3.5
@
text
@d25 1
d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.49 2002/09/12 00:13:06 djm Exp $");
a205 19
/* Strip one path (usually the pwd) from the start of another */
static char *
path_strip(char *path, char *strip)
{
	size_t len;

	if (strip == NULL)
		return (xstrdup(path));

	len = strlen(strip);
	if (strip != NULL && strncmp(path, strip, len) == 0) {
		if (strip[len - 1] != '/' && path[len] == '/')
			len++;
		return (xstrdup(path + len));
	}

	return (xstrdup(path));
}

d214 1
a214 1
	if (p1[strlen(p1) - 1] != '/')
a278 23
parse_ls_flags(const char **cpp, int *lflag)
{
	const char *cp = *cpp;

	/* Check for flags */
	if (cp++[0] == '-') {
		for(; strchr(WHITESPACE, *cp) == NULL; cp++) {
			switch (*cp) {
			case 'l':
				*lflag = 1;
				break;
			default:
				error("Invalid flag -%c", *cp);
				return(-1);
			}
		}
		*cpp = cp + strspn(cp, WHITESPACE);
	}

	return(0);
}

static int
d509 2
a510 123
sdirent_comp(const void *aa, const void *bb)
{
	SFTP_DIRENT *a = *(SFTP_DIRENT **)aa;
	SFTP_DIRENT *b = *(SFTP_DIRENT **)bb;

	return (strcmp(a->filename, b->filename));	
}

/* sftp ls.1 replacement for directories */
static int
do_ls_dir(struct sftp_conn *conn, char *path, char *strip_path, int lflag)
{
	int n;
	SFTP_DIRENT **d;

	if ((n = do_readdir(conn, path, &d)) != 0)
		return (n);

	/* Count entries for sort */	
	for (n = 0; d[n] != NULL; n++)
		;

	qsort(d, n, sizeof(*d), sdirent_comp);

	for (n = 0; d[n] != NULL; n++) {
		char *tmp, *fname;
		
		tmp = path_append(path, d[n]->filename);
		fname = path_strip(tmp, strip_path);
		xfree(tmp);

		if (lflag) {
			char *lname;
			struct stat sb;

			memset(&sb, 0, sizeof(sb));
			attrib_to_stat(&d[n]->a, &sb);
			lname = ls_file(fname, &sb, 1);
			printf("%s\n", lname);
			xfree(lname);
		} else {
			/* XXX - multicolumn display would be nice here */
			printf("%s\n", fname);
		}
		
		xfree(fname);
	}

	free_sftp_dirents(d);
	return (0);
}

/* sftp ls.1 replacement which handles path globs */
static int
do_globbed_ls(struct sftp_conn *conn, char *path, char *strip_path, 
    int lflag)
{
	glob_t g;
	int i;
	Attrib *a;
	struct stat sb;

	memset(&g, 0, sizeof(g));

	if (remote_glob(conn, path, GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE, 
	    NULL, &g)) {
		error("Can't ls: \"%s\" not found", path);
		return (-1);
	}

	/*
	 * If the glob returns a single match, which is the same as the 
	 * input glob, and it is a directory, then just list its contents
	 */
	if (g.gl_pathc == 1 && 
	    strncmp(path, g.gl_pathv[0], strlen(g.gl_pathv[0]) - 1) == 0) {
		if ((a = do_lstat(conn, path, 1)) == NULL) {
			globfree(&g);
	    		return (-1);
		}
		if ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) && 
		    S_ISDIR(a->perm)) {
			globfree(&g);
			return (do_ls_dir(conn, path, strip_path, lflag));
		}
	}

	for (i = 0; g.gl_pathv[i]; i++) {
		char *fname, *lname;

		fname = path_strip(g.gl_pathv[i], strip_path);

		if (lflag) {
			/*
			 * XXX: this is slow - 1 roundtrip per path
			 * A solution to this is to fork glob() and 
			 * build a sftp specific version which keeps the 
			 * attribs (which currently get thrown away)
			 * that the server returns as well as the filenames.
			 */
			memset(&sb, 0, sizeof(sb));
			a = do_lstat(conn, g.gl_pathv[i], 1);
			if (a != NULL)
				attrib_to_stat(a, &sb);
			lname = ls_file(fname, &sb, 1);
			printf("%s\n", lname);
			xfree(lname);
		} else {
			/* XXX - multicolumn display would be nice here */
			printf("%s\n", fname);
		}
		xfree(fname);
	}

	if (g.gl_pathc)
		globfree(&g);

	return (0);
}

static int
parse_args(const char **cpp, int *pflag, int *lflag, 
    unsigned long *n_arg, char **path1, char **path2)
d550 1
a550 1
	*lflag = *pflag = *n_arg = 0;
a596 2
		if (parse_ls_flags(&cp, lflag))
			return(-1);
d657 1
a657 1
	int pflag, lflag, cmdnum, i;
d665 1
a665 2
	cmdnum = parse_args(&cmd, &pflag, &lflag, &n_arg,
	    &path1, &path2);
d737 1
a737 1
			do_globbed_ls(conn, *pwd, *pwd, lflag);
a739 6
		
		/* Strip pwd off beginning of non-absolute paths */
		tmp = NULL;
		if (*path1 != '/')
			tmp = *pwd;

d741 12
a752 2

		do_globbed_ls(conn, path1, tmp, lflag);
@


1.39
log
@avoid paths beginning with "//"; <vinschen@@redhat.com>
ok markus@@
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.38 2001/07/09 07:04:53 deraadt Exp $");
d83 1
@


1.38
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.37 2001/06/23 15:12:20 itojun Exp $");
d209 2
a210 1
	strlcat(ret, "/", len);
@


1.37
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.36 2001/04/15 08:43:46 markus Exp $");
d168 1
a168 1
			execl(shell, shell, "-c", args, NULL);
d171 1
a171 1
			execl(shell, shell, NULL);
@


1.36
log
@some unused variable and typos; from tomh@@po.crl.go.jp
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.35 2001/04/12 23:17:54 mouring Exp $");
d116 1
a116 1
void
d148 1
a148 1
void
d185 1
a185 1
void
d201 1
a201 1
char *
d215 1
a215 1
char *
d229 1
a229 1
int
d249 1
a249 1
int
d272 1
a272 1
int
d320 1
a320 1
int
d332 1
a332 1
int
d345 1
a345 1
int
d422 1
a422 1
int
d502 1
a502 1
int
d647 1
a647 1
int
@


1.36.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.40 2001/08/14 09:23:02 markus Exp $");
a82 1
	{ "bye",	I_QUIT },
d116 1
a116 1
static void
d148 1
a148 1
static void
d168 1
a168 1
			execl(shell, shell, "-c", args, (char *)NULL);
d171 1
a171 1
			execl(shell, shell, (char *)NULL);
d185 1
a185 1
static void
d201 1
a201 1
static char *
d209 1
a209 2
	if (strcmp(p1, "/") != 0) 
		strlcat(ret, "/", len);
d215 1
a215 1
static char *
d229 1
a229 1
static int
d249 1
a249 1
static int
d272 1
a272 1
static int
d320 1
a320 1
static int
d332 1
a332 1
static int
d345 1
a345 1
static int
d422 1
a422 1
static int
d502 1
a502 1
static int
d647 1
a647 1
static int
@


1.36.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d2 1
a2 1
 * Copyright (c) 2001,2002 Damien Miller.  All rights reserved.
d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.44 2002/02/13 00:59:23 djm Exp $");
d47 2
a48 5
/* Size of buffer used when copying files */
extern size_t copy_buffer_len;

/* Number of concurrent outstanding requests */
extern int num_requests;
d210 1
a210 1
	if (strcmp(p1, "/") != 0)
d335 1
a335 1
remote_is_dir(struct sftp_conn *conn, char *path)
d340 1
a340 1
	if ((a = do_stat(conn, path, 1)) == NULL)
d348 1
a348 1
process_get(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
d362 1
a362 1
	if (remote_glob(conn, abs_src, 0, NULL, &g)) {
d386 1
a386 1
		err = do_download(conn, g.gl_pathv[0], abs_dst, pflag);
d398 1
a398 1
	for (i = 0; g.gl_pathv[i]; i++) {
d410 1
a410 1
		if (do_download(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
d425 1
a425 1
process_put(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
d451 1
a451 1
			if (remote_is_dir(conn, tmp_dst)) {
d468 1
a468 1
		err = do_upload(conn, g.gl_pathv[0], abs_dst, pflag);
d473 1
a473 1
	if (tmp_dst && !remote_is_dir(conn, tmp_dst)) {
d480 1
a480 1
	for (i = 0; g.gl_pathv[i]; i++) {
d492 1
a492 1
		if (do_upload(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
d522 1
a522 1
	for (i = 0; cmds[i].c; i++) {
d650 1
a650 1
parse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd)
d670 1
a670 1
		err = process_get(conn, path1, path2, *pwd, pflag);
d673 1
a673 1
		err = process_put(conn, path1, path2, *pwd, pflag);
d678 1
a678 1
		err = do_rename(conn, path1, path2);
d681 8
a688 2
		path2 = make_absolute(path2, *pwd);
		err = do_symlink(conn, path1, path2);
d692 2
a693 2
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
d695 1
a695 1
			if (do_rm(conn, g.gl_pathv[i]) == -1)
d704 1
a704 1
		err = do_mkdir(conn, path1, &a);
d708 1
a708 1
		err = do_rmdir(conn, path1);
d712 1
a712 1
		if ((tmp = do_realpath(conn, path1)) == NULL) {
d716 1
a716 1
		if ((aa = do_stat(conn, tmp, 0)) == NULL) {
d739 1
a739 1
			do_ls(conn, *pwd);
d743 1
a743 1
		if ((tmp = do_realpath(conn, path1)) == NULL)
d747 1
a747 1
		if ((aa = do_stat(conn, path1, 0)) == NULL)
d754 1
a754 1
		do_ls(conn, path1);
d785 2
a786 2
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
d788 1
a788 1
			do_setstat(conn, g.gl_pathv[i], &a);
d793 3
a795 3
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			if (!(aa = do_stat(conn, g.gl_pathv[i], 0)))
d805 1
a805 1
			do_setstat(conn, g.gl_pathv[i], aa);
d810 3
a812 3
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			if (!(aa = do_stat(conn, g.gl_pathv[i], 0)))
d822 1
a822 1
			do_setstat(conn, g.gl_pathv[i], aa);
d842 1
a842 1
		printf("SFTP protocol version %d\n", sftp_proto_version(conn));
a867 1
	struct sftp_conn *conn;
d869 2
a870 2
	conn = do_init(fd_in, fd_out, copy_buffer_len, num_requests);
	if (conn == NULL)
d873 1
a873 1
	pwd = do_realpath(conn, ".");
d881 1
a881 1
		if (remote_is_dir(conn, dir) && file2 == NULL) {
d884 1
a884 1
			parse_dispatch_command(conn, cmd, &pwd);
d892 1
a892 1
			parse_dispatch_command(conn, cmd, &pwd);
d899 1
a899 1
	for (;;) {
d915 1
a915 1
		if (parse_dispatch_command(conn, cmd, &pwd))
@


1.36.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.46 2002/03/30 18:51:15 markus Exp $");
d181 2
a182 3
	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for child: %s", strerror(errno));
a890 1
			xfree(dir);
a892 1
		xfree(dir);
@


1.35
log
@Add support for:
	sftp [user@@]host[:file [file]]	- Fetch remote file(s)
	sftp [user@@]host[:dir[/]]	- Start in remote dir/
OK deraadt@@
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.34 2001/04/11 07:06:22 djm Exp $");
d151 1
a151 1
	int ret, status;
d168 1
a168 1
			ret = execl(shell, shell, "-c", args, NULL);
d171 1
a171 1
			ret = execl(shell, shell, NULL);
@


1.34
log
@'mget' and 'mput' aliases; ok markus@@
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.33 2001/04/05 10:42:53 markus Exp $");
d861 1
a861 1
interactive_loop(int fd_in, int fd_out)
d864 1
d875 19
@


1.33
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.32 2001/03/23 13:10:57 markus Exp $");
d91 1
d103 1
@


1.32
log
@fix put, upload to _absolute_ path, ok djm@@
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.31 2001/03/16 13:44:24 markus Exp $");
d670 2
a671 2
  		break;
  	case I_RENAME:
@


1.31
log
@discourage strcat/strcpy
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.30 2001/03/16 09:55:53 markus Exp $");
d456 6
a461 3
		} else if (infer_path(g.gl_pathv[0], &abs_dst)) {
			err = -1;
			goto out;
@


1.30
log
@fix memset and whitespace
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.29 2001/03/16 08:16:18 djm Exp $");
d203 1
d205 4
a208 4
	ret = xmalloc(strlen(p1) + strlen(p2) + 2);
	strcpy(ret, p1);
	strcat(ret, "/");
	strcat(ret, p2);
@


1.29
log
@Revise globbing for get/put to be more shell-like. In particular,
"get/put file* directory/" now works. ok markus@@
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.28 2001/03/14 15:15:58 markus Exp $");
d286 1
a286 1
		
d351 1
a351 1
	
d355 1
a355 1
	memset(&g, '\0', sizeof(g));
d387 1
a387 1
		error("Multiple files match, but \"%s\" is not a directory", 
d392 1
a392 1
	
d434 1
a434 1
	memset(&g, '\0', sizeof(g));
d466 1
a466 1
		error("Multiple files match, but \"%s\" is not a directory", 
d741 1
a741 1
		if ((aa->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) && 
@


1.28
log
@add version command
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.27 2001/03/13 22:42:54 djm Exp $");
d200 13
d215 1
a215 1
	char buf[2048];
d219 1
a219 1
		snprintf(buf, sizeof(buf), "%s/%s", pwd, p);
d221 14
a234 1
		p = xstrdup(buf);
d237 7
a243 1
	return(p);
d318 13
a330 1
infer_path(const char *p, char **ifp)
d332 1
a332 1
	char *cp;
d334 4
a337 3
	cp = strrchr(p, '/');
	if (cp == NULL) {
		*ifp = xstrdup(p);
d339 70
d411 75
a485 3
	if (!cp[1]) {
		error("Invalid path");
		return(-1);
d488 6
a493 2
	*ifp = xstrdup(cp + 1);
	return(0);
d655 2
d662 1
a662 27
		memset(&g, 0, sizeof(g));
		if (!remote_glob(in, out, path1, 0, NULL, &g)) {
			if (path2) {
				/* XXX: target should be directory */
				error("You cannot specify a target when "
				    "downloading multiple files");
				err = -1;
				break;
			}
			for(i = 0; g.gl_pathv[i]; i++) {
				if (!infer_path(g.gl_pathv[i], &path2)) {
					printf("Fetching %s\n", g.gl_pathv[i]);
					if (do_download(in, out, g.gl_pathv[i],
					    path2, pflag) == -1)
						err = -1;
					free(path2);
					path2 = NULL;
				} else
					err = -1;
			}
		} else {
			if (!path2 && infer_path(path1, &path2)) {
				err = -1;
				break;
			}
			err = do_download(in, out, path1, path2, pflag);
		}
d665 1
a665 26
		if (!glob(path1, 0, NULL, &g)) {
			if (path2) {
				error("You cannot specify a target when "
				    "uploading multiple files");
				err = -1;
				break;
			}
			for(i = 0; g.gl_pathv[i]; i++) {
				if (!infer_path(g.gl_pathv[i], &path2)) {
					path2 = make_absolute(path2, *pwd);
					printf("Uploading %s\n", g.gl_pathv[i]);
					if (do_upload(in, out, g.gl_pathv[i],
					    path2, pflag) == -1)
						err = -1;
					free(path2);
					path2 = NULL;
				} else
					err = -1;
			}
		} else {
			if (!path2 && infer_path(path1, &path2)) {
				err = -1;
				break;
			}
			err = do_upload(in, out, path1, path2, pflag);
		}
d708 1
a708 1
		if ((aa = do_stat(in, out, tmp)) == NULL) {
d739 1
a739 1
		if ((aa = do_stat(in, out, path1)) == NULL)
d787 1
a787 1
			if (!(aa = do_stat(in, out, g.gl_pathv[i])))
d804 1
a804 1
			if (!(aa = do_stat(in, out, g.gl_pathv[i])))
d840 2
@


1.27
log
@sftp client filename globbing for get, put, ch{mod,grp,own}. ok markus@@
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.26 2001/03/07 10:11:23 djm Exp $");
d75 1
d108 1
d140 1
d440 1
d690 3
@


1.26
log
@Support for new draft (draft-ietf-secsh-filexfer-01). New symlink handling
functions and small protocol change.
@
text
@a24 2
/* XXX: finish implementation of all commands */
/* XXX: do fnmatch() instead of using raw pathname */
d29 3
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.25 2001/03/06 06:11:44 deraadt Exp $");
d40 1
a286 2
	debug("XXX: P = \"%s\"", p);

a361 3
		/* Otherwise try to guess it from first path */
		if (*path2 == NULL && infer_path(*path1, path2))
			return(-1);
d450 1
a450 1
	int pflag, cmdnum;
d455 1
d465 27
a491 2
		path1 = make_absolute(path1, *pwd);
		err = do_download(in, out, path1, path2, pflag);
d494 28
a521 4
		path2 = make_absolute(path2, *pwd);
		err = do_upload(in, out, path1, path2, pflag);
		break;
	case I_RENAME:
d538 6
a543 1
		err = do_rm(in, out, path1);
d631 5
a635 1
		do_setstat(in, out, path1, &a);
d639 13
a651 6
		if (!(aa = do_stat(in, out, path1)))
			break;
		if (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {
			error("Can't get current ownership of "
			    "remote file \"%s\"", path1);
			break;
a652 3
		aa->flags &= SSH2_FILEXFER_ATTR_UIDGID;
		aa->uid = n_arg;
		do_setstat(in, out, path1, aa);
d656 13
a668 6
		if (!(aa = do_stat(in, out, path1)))
			break;
		if (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {
			error("Can't get current ownership of "
			    "remote file \"%s\"", path1);
			break;
a669 3
		aa->flags &= SSH2_FILEXFER_ATTR_UIDGID;
		aa->gid = n_arg;
		do_setstat(in, out, path1, aa);
@


1.26.2.1
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.22 2001/02/14 09:46:03 djm Exp $");
d43 6
d73 1
d94 1
d105 1
d123 1
d136 1
d368 1
a368 1
		/* Get first pathname (mandatory) */
d457 2
a458 1
	char path_buf[PATH_MAX];
d469 1
a469 1
		do_download(in, out, path1, path2, pflag);
d473 1
a473 1
		do_upload(in, out, path1, path2, pflag);
d478 11
a488 1
		do_rename(in, out, path1, path2);
d492 1
a492 1
		do_rm(in, out, path1);
d499 1
a499 1
		do_mkdir(in, out, path1, &a);
d503 1
a503 1
		do_rmdir(in, out, path1);
d507 2
a508 1
		if ((tmp = do_realpath(in, out, path1)) == NULL)
d510 1
d513 1
d519 1
d526 1
d552 1
a552 1
		if (chdir(path1) == -1)
d555 2
d559 1
a559 1
		if (mkdir(path1, 0777) == -1)
d562 2
d613 1
a613 1
			error("Couldn't get local cwd: %s\n",
d632 5
d646 4
d655 1
a655 1
	setvbuf(stdin, NULL, _IOLBF, 0);
d663 1
a663 1
		if (fgets(cmd, sizeof(cmd), stdin) == NULL) {
d666 3
a668 1
		}
d672 1
@


1.26.2.2
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d25 2
d31 1
a31 3
RCSID("$OpenBSD: sftp-int.c,v 1.31 2001/03/16 13:44:24 markus Exp $");

#include <glob.h>
a39 1
#include "sftp-glob.h"
a42 6
/* File to read commands from */
extern FILE *infile;

/* Version of server we are speaking to */
int version;

a66 2
#define I_SYMLINK	21
#define I_VERSION	22
a86 1
	{ "ln",		I_SYMLINK },
a96 2
	{ "symlink",	I_SYMLINK },
	{ "version",	I_VERSION },
a113 1
	printf("ln oldpath newpath            Symlink remote file\n");
a125 2
	printf("symlink oldpath newpath       Symlink remote file\n");
	printf("version                       Show SFTP version\n");
a184 14
path_append(char *p1, char *p2)
{
	char *ret;
	int len = strlen(p1) + strlen(p2) + 2;

	ret = xmalloc(len);
	strlcpy(ret, p1, len);
	strlcat(ret, "/", len);
	strlcat(ret, p2, len);

	return(ret);
}

char *
d187 1
a187 1
	char *abs;
d191 1
a191 1
		abs = path_append(pwd, p);
d193 1
a193 19
		return(abs);
	} else
		return(p);
}

int
infer_path(const char *p, char **ifp)
{
	char *cp;

	cp = strrchr(p, '/');
	if (cp == NULL) {
		*ifp = xstrdup(p);
		return(0);
	}

	if (!cp[1]) {
		error("Invalid path");
		return(-1);
d196 1
a196 2
	*ifp = xstrdup(cp + 1);
	return(0);
d239 1
a239 1

d271 1
a271 1
is_dir(char *path)
d273 1
a273 1
	struct stat sb;
d275 1
a275 3
	/* XXX: report errors? */
	if (stat(path, &sb) == -1)
		return(0);
d277 3
a279 10
	return(sb.st_mode & S_IFDIR);
}

int
remote_is_dir(int in, int out, char *path)
{
	Attrib *a;

	/* XXX: report errors? */
	if ((a = do_stat(in, out, path, 1)) == NULL)
d281 1
a281 4
	if (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))
		return(0);
	return(a->perm & S_IFDIR);
}
d283 3
a285 144
int
process_get(int in, int out, char *src, char *dst, char *pwd, int pflag)
{
	char *abs_src = NULL;
	char *abs_dst = NULL;
	char *tmp;
	glob_t g;
	int err = 0;
	int i;

	abs_src = xstrdup(src);
	abs_src = make_absolute(abs_src, pwd);

	memset(&g, 0, sizeof(g));
	debug3("Looking up %s", abs_src);
	if (remote_glob(in, out, abs_src, 0, NULL, &g)) {
		error("File \"%s\" not found.", abs_src);
		err = -1;
		goto out;
	}

	/* Only one match, dst may be file, directory or unspecified */
	if (g.gl_pathv[0] && g.gl_matchc == 1) {
		if (dst) {
			/* If directory specified, append filename */
			if (is_dir(dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(dst);
		} else if (infer_path(g.gl_pathv[0], &abs_dst)) {
			err = -1;
			goto out;
		}
		printf("Fetching %s to %s\n", g.gl_pathv[0], abs_dst);
		err = do_download(in, out, g.gl_pathv[0], abs_dst, pflag);
		goto out;
	}

	/* Multiple matches, dst may be directory or unspecified */
	if (dst && !is_dir(dst)) {
		error("Multiple files match, but \"%s\" is not a directory",
		    dst);
		err = -1;
		goto out;
	}

	for(i = 0; g.gl_pathv[i]; i++) {
		if (infer_path(g.gl_pathv[i], &tmp)) {
			err = -1;
			goto out;
		}
		if (dst) {
			abs_dst = path_append(dst, tmp);
			xfree(tmp);
		} else
			abs_dst = tmp;

		printf("Fetching %s to %s\n", g.gl_pathv[i], abs_dst);
		if (do_download(in, out, g.gl_pathv[i], abs_dst, pflag) == -1)
			err = -1;
		xfree(abs_dst);
		abs_dst = NULL;
	}

out:
	xfree(abs_src);
	if (abs_dst)
		xfree(abs_dst);
	globfree(&g);
	return(err);
}

int
process_put(int in, int out, char *src, char *dst, char *pwd, int pflag)
{
	char *tmp_dst = NULL;
	char *abs_dst = NULL;
	char *tmp;
	glob_t g;
	int err = 0;
	int i;

	if (dst) {
		tmp_dst = xstrdup(dst);
		tmp_dst = make_absolute(tmp_dst, pwd);
	}

	memset(&g, 0, sizeof(g));
	debug3("Looking up %s", src);
	if (glob(src, 0, NULL, &g)) {
		error("File \"%s\" not found.", src);
		err = -1;
		goto out;
	}

	/* Only one match, dst may be file, directory or unspecified */
	if (g.gl_pathv[0] && g.gl_matchc == 1) {
		if (tmp_dst) {
			/* If directory specified, append filename */
			if (remote_is_dir(in, out, tmp_dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(tmp_dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(tmp_dst);
		} else if (infer_path(g.gl_pathv[0], &abs_dst)) {
			err = -1;
			goto out;
		}
		printf("Uploading %s to %s\n", g.gl_pathv[0], abs_dst);
		err = do_upload(in, out, g.gl_pathv[0], abs_dst, pflag);
		goto out;
	}

	/* Multiple matches, dst may be directory or unspecified */
	if (tmp_dst && !remote_is_dir(in, out, tmp_dst)) {
		error("Multiple files match, but \"%s\" is not a directory",
		    tmp_dst);
		err = -1;
		goto out;
	}

	for(i = 0; g.gl_pathv[i]; i++) {
		if (infer_path(g.gl_pathv[i], &tmp)) {
			err = -1;
			goto out;
		}
		if (tmp_dst) {
			abs_dst = path_append(tmp_dst, tmp);
			xfree(tmp);
		} else
			abs_dst = make_absolute(tmp, pwd);

		printf("Uploading %s to %s\n", g.gl_pathv[i], abs_dst);
		if (do_upload(in, out, g.gl_pathv[i], abs_dst, pflag) == -1)
			err = -1;
d288 2
a289 6
out:
	if (abs_dst)
		xfree(abs_dst);
	if (tmp_dst)
		xfree(tmp_dst);
	return(err);
d352 3
d357 1
a357 1
	case I_SYMLINK:
a429 1
	case I_VERSION:
d443 1
a443 1
	int pflag, cmdnum, i;
d446 1
a446 3
	char path_buf[MAXPATHLEN];
	int err = 0;
	glob_t g;
a450 2
	memset(&g, 0, sizeof(g));

d456 2
a457 1
		err = process_get(in, out, path1, path2, *pwd, pflag);
d460 4
a463 3
		err = process_put(in, out, path1, path2, *pwd, pflag);
  		break;
  	case I_RENAME:
d466 1
a466 11
		err = do_rename(in, out, path1, path2);
		break;
	case I_SYMLINK:
		if (version < 3) {
			error("The server (version %d) does not support "
			    "this operation", version);
			err = -1;
		} else {
			path2 = make_absolute(path2, *pwd);
			err = do_symlink(in, out, path1, path2);
		}
d470 1
a470 6
		remote_glob(in, out, path1, GLOB_NOCHECK, NULL, &g);
		for(i = 0; g.gl_pathv[i]; i++) {
			printf("Removing %s\n", g.gl_pathv[i]);
			if (do_rm(in, out, g.gl_pathv[i]) == -1)
				err = -1;
		}
d477 1
a477 1
		err = do_mkdir(in, out, path1, &a);
d481 1
a481 1
		err = do_rmdir(in, out, path1);
d485 1
a485 2
		if ((tmp = do_realpath(in, out, path1)) == NULL) {
			err = 1;
d487 1
a487 2
		}
		if ((aa = do_stat(in, out, tmp, 0)) == NULL) {
a488 1
			err = 1;
a493 1
			err = 1;
a499 1
			err = 1;
d515 1
a515 1
		if ((aa = do_stat(in, out, path1, 0)) == NULL)
d517 1
a517 1
		if ((aa->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&
d525 1
a525 1
		if (chdir(path1) == -1) {
a527 2
			err = 1;
		}
d530 1
a530 1
		if (mkdir(path1, 0777) == -1) {
a532 2
			err = 1;
		}
d549 1
a549 5
		remote_glob(in, out, path1, GLOB_NOCHECK, NULL, &g);
		for(i = 0; g.gl_pathv[i]; i++) {
			printf("Changing mode on %s\n", g.gl_pathv[i]);
			do_setstat(in, out, g.gl_pathv[i], &a);
		}
d553 6
a558 13
		remote_glob(in, out, path1, GLOB_NOCHECK, NULL, &g);
		for(i = 0; g.gl_pathv[i]; i++) {
			if (!(aa = do_stat(in, out, g.gl_pathv[i], 0)))
				continue;
			if (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {
				error("Can't get current ownership of "
				    "remote file \"%s\"", g.gl_pathv[i]);
				continue;
			}
			printf("Changing owner on %s\n", g.gl_pathv[i]);
			aa->flags &= SSH2_FILEXFER_ATTR_UIDGID;
			aa->uid = n_arg;
			do_setstat(in, out, g.gl_pathv[i], aa);
d560 3
d566 6
a571 13
		remote_glob(in, out, path1, GLOB_NOCHECK, NULL, &g);
		for(i = 0; g.gl_pathv[i]; i++) {
			if (!(aa = do_stat(in, out, g.gl_pathv[i], 0)))
				continue;
			if (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {
				error("Can't get current ownership of "
				    "remote file \"%s\"", g.gl_pathv[i]);
				continue;
			}
			printf("Changing group on %s\n", g.gl_pathv[i]);
			aa->flags &= SSH2_FILEXFER_ATTR_UIDGID;
			aa->gid = n_arg;
			do_setstat(in, out, g.gl_pathv[i], aa);
d573 3
d582 1
a582 1
			error("Couldn't get local cwd: %s",
a592 3
	case I_VERSION:
		printf("SFTP protocol version %d\n", version);
		break;
a596 2
	if (g.gl_pathc)
		globfree(&g);
a600 5

	/* If an error occurs in batch mode we should abort. */
	if (infile != stdin && err > 0)
		return -1;

a609 4
	version = do_init(fd_in, fd_out);
	if (version == -1)
		fatal("Couldn't initialise connection to server");

d615 1
a615 1
	setvbuf(infile, NULL, _IOLBF, 0);
d623 1
a623 1
		if (fgets(cmd, sizeof(cmd), infile) == NULL) {
d626 1
a626 3
		} else if (infile != stdin) /* Bluff typing */
			printf("%s", cmd);

a629 1

@


1.25
log
@sftp -b batchfile; mouring@@etoh.eviladmin.org
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.24 2001/03/04 17:42:28 millert Exp $");
d43 5
a47 1
extern FILE* infile;
d73 1
d94 1
d105 1
d123 1
d136 1
d368 1
a368 1
		/* Get first pathname (mandatory) */
d480 10
d645 4
@


1.24
log
@log functions should not be passed strings that end in newline as they
get passed on to syslog() and when logging to stderr, do_log() appends
its own newline.
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.23 2001/03/01 02:18:04 deraadt Exp $");
d43 2
d449 1
d460 1
a460 1
		do_download(in, out, path1, path2, pflag);
d464 1
a464 1
		do_upload(in, out, path1, path2, pflag);
d469 1
a469 1
		do_rename(in, out, path1, path2);
d473 1
a473 1
		do_rm(in, out, path1);
d480 1
a480 1
		do_mkdir(in, out, path1, &a);
d484 1
a484 1
		do_rmdir(in, out, path1);
d488 2
a489 1
		if ((tmp = do_realpath(in, out, path1)) == NULL)
d491 1
d494 1
d500 1
d507 1
d533 1
a533 1
		if (chdir(path1) == -1)
d536 2
d540 1
a540 1
		if (mkdir(path1, 0777) == -1)
d543 2
d613 5
d632 1
a632 1
	setvbuf(stdin, NULL, _IOLBF, 0);
d640 1
a640 1
		if (fgets(cmd, sizeof(cmd), stdin) == NULL) {
d643 3
a645 1
		}
d649 1
@


1.23
log
@use MAXPATHLEN over PATH_MAX, since it is more portable
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.22 2001/02/14 09:46:03 djm Exp $");
d582 1
a582 1
			error("Couldn't get local cwd: %s\n",
@


1.22
log
@Fix and document 'preserve modes & times' option ('-p' flag in sftp);
ok markus@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.21 2001/02/12 20:53:33 stevesk Exp $");
d446 1
a446 1
	char path_buf[PATH_MAX];
@


1.22.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.22 2001/02/14 09:46:03 djm Exp $");
@


1.22.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.22.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d25 2
d31 1
a31 3
RCSID("$OpenBSD: sftp-int.c,v 1.31 2001/03/16 13:44:24 markus Exp $");

#include <glob.h>
a39 1
#include "sftp-glob.h"
a42 6
/* File to read commands from */
extern FILE *infile;

/* Version of server we are speaking to */
int version;

a66 2
#define I_SYMLINK	21
#define I_VERSION	22
a86 1
	{ "ln",		I_SYMLINK },
a96 2
	{ "symlink",	I_SYMLINK },
	{ "version",	I_VERSION },
a113 1
	printf("ln oldpath newpath            Symlink remote file\n");
a125 2
	printf("symlink oldpath newpath       Symlink remote file\n");
	printf("version                       Show SFTP version\n");
a184 14
path_append(char *p1, char *p2)
{
	char *ret;
	int len = strlen(p1) + strlen(p2) + 2;

	ret = xmalloc(len);
	strlcpy(ret, p1, len);
	strlcat(ret, "/", len);
	strlcat(ret, p2, len);

	return(ret);
}

char *
d187 1
a187 1
	char *abs;
d191 1
a191 1
		abs = path_append(pwd, p);
d193 1
a193 19
		return(abs);
	} else
		return(p);
}

int
infer_path(const char *p, char **ifp)
{
	char *cp;

	cp = strrchr(p, '/');
	if (cp == NULL) {
		*ifp = xstrdup(p);
		return(0);
	}

	if (!cp[1]) {
		error("Invalid path");
		return(-1);
d196 1
a196 2
	*ifp = xstrdup(cp + 1);
	return(0);
d239 1
a239 1

d271 1
a271 1
is_dir(char *path)
d273 1
a273 1
	struct stat sb;
d275 1
a275 3
	/* XXX: report errors? */
	if (stat(path, &sb) == -1)
		return(0);
d277 3
a279 10
	return(sb.st_mode & S_IFDIR);
}

int
remote_is_dir(int in, int out, char *path)
{
	Attrib *a;

	/* XXX: report errors? */
	if ((a = do_stat(in, out, path, 1)) == NULL)
d281 1
a281 4
	if (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))
		return(0);
	return(a->perm & S_IFDIR);
}
d283 3
a285 144
int
process_get(int in, int out, char *src, char *dst, char *pwd, int pflag)
{
	char *abs_src = NULL;
	char *abs_dst = NULL;
	char *tmp;
	glob_t g;
	int err = 0;
	int i;

	abs_src = xstrdup(src);
	abs_src = make_absolute(abs_src, pwd);

	memset(&g, 0, sizeof(g));
	debug3("Looking up %s", abs_src);
	if (remote_glob(in, out, abs_src, 0, NULL, &g)) {
		error("File \"%s\" not found.", abs_src);
		err = -1;
		goto out;
	}

	/* Only one match, dst may be file, directory or unspecified */
	if (g.gl_pathv[0] && g.gl_matchc == 1) {
		if (dst) {
			/* If directory specified, append filename */
			if (is_dir(dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(dst);
		} else if (infer_path(g.gl_pathv[0], &abs_dst)) {
			err = -1;
			goto out;
		}
		printf("Fetching %s to %s\n", g.gl_pathv[0], abs_dst);
		err = do_download(in, out, g.gl_pathv[0], abs_dst, pflag);
		goto out;
	}

	/* Multiple matches, dst may be directory or unspecified */
	if (dst && !is_dir(dst)) {
		error("Multiple files match, but \"%s\" is not a directory",
		    dst);
		err = -1;
		goto out;
	}

	for(i = 0; g.gl_pathv[i]; i++) {
		if (infer_path(g.gl_pathv[i], &tmp)) {
			err = -1;
			goto out;
		}
		if (dst) {
			abs_dst = path_append(dst, tmp);
			xfree(tmp);
		} else
			abs_dst = tmp;

		printf("Fetching %s to %s\n", g.gl_pathv[i], abs_dst);
		if (do_download(in, out, g.gl_pathv[i], abs_dst, pflag) == -1)
			err = -1;
		xfree(abs_dst);
		abs_dst = NULL;
	}

out:
	xfree(abs_src);
	if (abs_dst)
		xfree(abs_dst);
	globfree(&g);
	return(err);
}

int
process_put(int in, int out, char *src, char *dst, char *pwd, int pflag)
{
	char *tmp_dst = NULL;
	char *abs_dst = NULL;
	char *tmp;
	glob_t g;
	int err = 0;
	int i;

	if (dst) {
		tmp_dst = xstrdup(dst);
		tmp_dst = make_absolute(tmp_dst, pwd);
	}

	memset(&g, 0, sizeof(g));
	debug3("Looking up %s", src);
	if (glob(src, 0, NULL, &g)) {
		error("File \"%s\" not found.", src);
		err = -1;
		goto out;
	}

	/* Only one match, dst may be file, directory or unspecified */
	if (g.gl_pathv[0] && g.gl_matchc == 1) {
		if (tmp_dst) {
			/* If directory specified, append filename */
			if (remote_is_dir(in, out, tmp_dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(tmp_dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(tmp_dst);
		} else if (infer_path(g.gl_pathv[0], &abs_dst)) {
			err = -1;
			goto out;
		}
		printf("Uploading %s to %s\n", g.gl_pathv[0], abs_dst);
		err = do_upload(in, out, g.gl_pathv[0], abs_dst, pflag);
		goto out;
	}

	/* Multiple matches, dst may be directory or unspecified */
	if (tmp_dst && !remote_is_dir(in, out, tmp_dst)) {
		error("Multiple files match, but \"%s\" is not a directory",
		    tmp_dst);
		err = -1;
		goto out;
	}

	for(i = 0; g.gl_pathv[i]; i++) {
		if (infer_path(g.gl_pathv[i], &tmp)) {
			err = -1;
			goto out;
		}
		if (tmp_dst) {
			abs_dst = path_append(tmp_dst, tmp);
			xfree(tmp);
		} else
			abs_dst = make_absolute(tmp, pwd);

		printf("Uploading %s to %s\n", g.gl_pathv[i], abs_dst);
		if (do_upload(in, out, g.gl_pathv[i], abs_dst, pflag) == -1)
			err = -1;
d288 2
a289 6
out:
	if (abs_dst)
		xfree(abs_dst);
	if (tmp_dst)
		xfree(tmp_dst);
	return(err);
d352 3
d357 1
a357 1
	case I_SYMLINK:
a429 1
	case I_VERSION:
d443 1
a443 1
	int pflag, cmdnum, i;
d446 1
a446 3
	char path_buf[MAXPATHLEN];
	int err = 0;
	glob_t g;
a450 2
	memset(&g, 0, sizeof(g));

d456 2
a457 1
		err = process_get(in, out, path1, path2, *pwd, pflag);
d460 4
a463 3
		err = process_put(in, out, path1, path2, *pwd, pflag);
  		break;
  	case I_RENAME:
d466 1
a466 11
		err = do_rename(in, out, path1, path2);
		break;
	case I_SYMLINK:
		if (version < 3) {
			error("The server (version %d) does not support "
			    "this operation", version);
			err = -1;
		} else {
			path2 = make_absolute(path2, *pwd);
			err = do_symlink(in, out, path1, path2);
		}
d470 1
a470 6
		remote_glob(in, out, path1, GLOB_NOCHECK, NULL, &g);
		for(i = 0; g.gl_pathv[i]; i++) {
			printf("Removing %s\n", g.gl_pathv[i]);
			if (do_rm(in, out, g.gl_pathv[i]) == -1)
				err = -1;
		}
d477 1
a477 1
		err = do_mkdir(in, out, path1, &a);
d481 1
a481 1
		err = do_rmdir(in, out, path1);
d485 1
a485 2
		if ((tmp = do_realpath(in, out, path1)) == NULL) {
			err = 1;
d487 1
a487 2
		}
		if ((aa = do_stat(in, out, tmp, 0)) == NULL) {
a488 1
			err = 1;
a493 1
			err = 1;
a499 1
			err = 1;
d515 1
a515 1
		if ((aa = do_stat(in, out, path1, 0)) == NULL)
d517 1
a517 1
		if ((aa->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&
d525 1
a525 1
		if (chdir(path1) == -1) {
a527 2
			err = 1;
		}
d530 1
a530 1
		if (mkdir(path1, 0777) == -1) {
a532 2
			err = 1;
		}
d549 1
a549 5
		remote_glob(in, out, path1, GLOB_NOCHECK, NULL, &g);
		for(i = 0; g.gl_pathv[i]; i++) {
			printf("Changing mode on %s\n", g.gl_pathv[i]);
			do_setstat(in, out, g.gl_pathv[i], &a);
		}
d553 6
a558 13
		remote_glob(in, out, path1, GLOB_NOCHECK, NULL, &g);
		for(i = 0; g.gl_pathv[i]; i++) {
			if (!(aa = do_stat(in, out, g.gl_pathv[i], 0)))
				continue;
			if (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {
				error("Can't get current ownership of "
				    "remote file \"%s\"", g.gl_pathv[i]);
				continue;
			}
			printf("Changing owner on %s\n", g.gl_pathv[i]);
			aa->flags &= SSH2_FILEXFER_ATTR_UIDGID;
			aa->uid = n_arg;
			do_setstat(in, out, g.gl_pathv[i], aa);
d560 3
d566 6
a571 13
		remote_glob(in, out, path1, GLOB_NOCHECK, NULL, &g);
		for(i = 0; g.gl_pathv[i]; i++) {
			if (!(aa = do_stat(in, out, g.gl_pathv[i], 0)))
				continue;
			if (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {
				error("Can't get current ownership of "
				    "remote file \"%s\"", g.gl_pathv[i]);
				continue;
			}
			printf("Changing group on %s\n", g.gl_pathv[i]);
			aa->flags &= SSH2_FILEXFER_ATTR_UIDGID;
			aa->gid = n_arg;
			do_setstat(in, out, g.gl_pathv[i], aa);
d573 3
d582 1
a582 1
			error("Couldn't get local cwd: %s",
a592 3
	case I_VERSION:
		printf("SFTP protocol version %d\n", version);
		break;
a596 2
	if (g.gl_pathc)
		globfree(&g);
a600 5

	/* If an error occurs in batch mode we should abort. */
	if (infile != stdin && err > 0)
		return -1;

a609 4
	version = do_init(fd_in, fd_out);
	if (version == -1)
		fatal("Couldn't initialise connection to server");

d615 1
a615 1
	setvbuf(infile, NULL, _IOLBF, 0);
d623 1
a623 1
		if (fgets(cmd, sizeof(cmd), infile) == NULL) {
d626 1
a626 3
		} else if (infile != stdin) /* Bluff typing */
			printf("%s", cmd);

a629 1

@


1.22.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.36 2001/04/15 08:43:46 markus Exp $");
a90 1
	{ "mget",	I_GET },
a101 1
	{ "mput",	I_PUT },
d149 1
a149 1
	int status;
d166 1
a166 1
			execl(shell, shell, "-c", args, NULL);
d169 1
a169 1
			execl(shell, shell, NULL);
d456 3
a458 6
		} else {
			if (infer_path(g.gl_pathv[0], &abs_dst)) {
				err = -1;
				goto out;
			}
			abs_dst = make_absolute(abs_dst, pwd);
d667 2
a668 2
		break;
	case I_RENAME:
d856 1
a856 1
interactive_loop(int fd_in, int fd_out, char *file1, char *file2)
a858 1
	char *dir = NULL;
a868 19
	if (file1 != NULL) {
		dir = xstrdup(file1);
		dir = make_absolute(dir, pwd);

		if (remote_is_dir(fd_in, fd_out, dir) && file2 == NULL) {
			printf("Changing to: %s\n", dir);
			snprintf(cmd, sizeof cmd, "cd \"%s\"", dir);
			parse_dispatch_command(fd_in, fd_out, cmd, &pwd);
		} else {
			if (file2 == NULL)
				snprintf(cmd, sizeof cmd, "get %s", dir);
			else
				snprintf(cmd, sizeof cmd, "get %s %s", dir,
				    file2);

			parse_dispatch_command(fd_in, fd_out, cmd, &pwd);
			return;
		}
	}
@


1.22.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.40 2001/08/14 09:23:02 markus Exp $");
a82 1
	{ "bye",	I_QUIT },
d116 1
a116 1
static void
d148 1
a148 1
static void
d168 1
a168 1
			execl(shell, shell, "-c", args, (char *)NULL);
d171 1
a171 1
			execl(shell, shell, (char *)NULL);
d185 1
a185 1
static void
d201 1
a201 1
static char *
d209 1
a209 2
	if (strcmp(p1, "/") != 0) 
		strlcat(ret, "/", len);
d215 1
a215 1
static char *
d229 1
a229 1
static int
d249 1
a249 1
static int
d272 1
a272 1
static int
d320 1
a320 1
static int
d332 1
a332 1
static int
d345 1
a345 1
static int
d422 1
a422 1
static int
d502 1
a502 1
static int
d647 1
a647 1
static int
@


1.22.2.6
log
@Merge OpenSSH 3.1.
@
text
@d2 1
a2 1
 * Copyright (c) 2001,2002 Damien Miller.  All rights reserved.
d29 1
a29 1
RCSID("$OpenBSD: sftp-int.c,v 1.44 2002/02/13 00:59:23 djm Exp $");
d47 2
a48 5
/* Size of buffer used when copying files */
extern size_t copy_buffer_len;

/* Number of concurrent outstanding requests */
extern int num_requests;
d210 1
a210 1
	if (strcmp(p1, "/") != 0)
d335 1
a335 1
remote_is_dir(struct sftp_conn *conn, char *path)
d340 1
a340 1
	if ((a = do_stat(conn, path, 1)) == NULL)
d348 1
a348 1
process_get(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
d362 1
a362 1
	if (remote_glob(conn, abs_src, 0, NULL, &g)) {
d386 1
a386 1
		err = do_download(conn, g.gl_pathv[0], abs_dst, pflag);
d398 1
a398 1
	for (i = 0; g.gl_pathv[i]; i++) {
d410 1
a410 1
		if (do_download(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
d425 1
a425 1
process_put(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
d451 1
a451 1
			if (remote_is_dir(conn, tmp_dst)) {
d468 1
a468 1
		err = do_upload(conn, g.gl_pathv[0], abs_dst, pflag);
d473 1
a473 1
	if (tmp_dst && !remote_is_dir(conn, tmp_dst)) {
d480 1
a480 1
	for (i = 0; g.gl_pathv[i]; i++) {
d492 1
a492 1
		if (do_upload(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
d522 1
a522 1
	for (i = 0; cmds[i].c; i++) {
d650 1
a650 1
parse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd)
d670 1
a670 1
		err = process_get(conn, path1, path2, *pwd, pflag);
d673 1
a673 1
		err = process_put(conn, path1, path2, *pwd, pflag);
d678 1
a678 1
		err = do_rename(conn, path1, path2);
d681 8
a688 2
		path2 = make_absolute(path2, *pwd);
		err = do_symlink(conn, path1, path2);
d692 2
a693 2
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
d695 1
a695 1
			if (do_rm(conn, g.gl_pathv[i]) == -1)
d704 1
a704 1
		err = do_mkdir(conn, path1, &a);
d708 1
a708 1
		err = do_rmdir(conn, path1);
d712 1
a712 1
		if ((tmp = do_realpath(conn, path1)) == NULL) {
d716 1
a716 1
		if ((aa = do_stat(conn, tmp, 0)) == NULL) {
d739 1
a739 1
			do_ls(conn, *pwd);
d743 1
a743 1
		if ((tmp = do_realpath(conn, path1)) == NULL)
d747 1
a747 1
		if ((aa = do_stat(conn, path1, 0)) == NULL)
d754 1
a754 1
		do_ls(conn, path1);
d785 2
a786 2
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
d788 1
a788 1
			do_setstat(conn, g.gl_pathv[i], &a);
d793 3
a795 3
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			if (!(aa = do_stat(conn, g.gl_pathv[i], 0)))
d805 1
a805 1
			do_setstat(conn, g.gl_pathv[i], aa);
d810 3
a812 3
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			if (!(aa = do_stat(conn, g.gl_pathv[i], 0)))
d822 1
a822 1
			do_setstat(conn, g.gl_pathv[i], aa);
d842 1
a842 1
		printf("SFTP protocol version %d\n", sftp_proto_version(conn));
a867 1
	struct sftp_conn *conn;
d869 2
a870 2
	conn = do_init(fd_in, fd_out, copy_buffer_len, num_requests);
	if (conn == NULL)
d873 1
a873 1
	pwd = do_realpath(conn, ".");
d881 1
a881 1
		if (remote_is_dir(conn, dir) && file2 == NULL) {
d884 1
a884 1
			parse_dispatch_command(conn, cmd, &pwd);
d892 1
a892 1
			parse_dispatch_command(conn, cmd, &pwd);
d899 1
a899 1
	for (;;) {
d915 1
a915 1
		if (parse_dispatch_command(conn, cmd, &pwd))
@


1.21
log
@lumask now works with 1 numeric arg; ok markus@@, djm@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.20 2001/02/10 00:45:26 djm Exp $");
d207 1
d212 1
a212 1
			error("Invalid flag -%c", *cp);
@


1.20
log
@check correct char in getput flags
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.19 2001/02/09 11:46:24 djm Exp $");
d296 1
d298 1
d392 1
d398 3
a400 1
		if (*cp < '0' && *cp > '9') {
d405 5
a409 2
		*n_arg = strtoul(cp, (char**)&cp, base);
		if (!*cp || !strchr(WHITESPACE, *cp)) {
d541 1
@


1.19
log
@Check for NULL attribs for chown, chmod & chgrp operations, only send
relevant attribs back to server; ok markus@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.18 2001/02/08 22:28:07 stevesk Exp $");
d206 1
a206 1
		switch (*cp) {
@


1.18
log
@_PATH_LS; ok markus@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.17 2001/02/08 17:57:59 stevesk Exp $");
d543 2
a544 1
		aa = do_stat(in, out, path1);
d550 1
d556 2
a557 1
		aa = do_stat(in, out, path1);
d563 1
@


1.17
log
@typo
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.16 2001/02/08 15:02:01 deraadt Exp $");
d172 1
a172 1
		local_do_shell("ls");
d174 1
a174 1
		int len = sizeof("/bin/ls ") + strlen(args) + 1;
d178 1
a178 1
		snprintf(buf, len, "/bin/ls %s", args);
@


1.16
log
@plug a memory leak
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.15 2001/02/07 22:55:47 stevesk Exp $");
d522 1
a522 1
			error("Couldn't create local directory to "
@


1.15
log
@lowercase cmds[].c also; ok markus@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.14 2001/02/07 22:36:03 stevesk Exp $");
d174 2
a175 1
		char *buf = xmalloc(8 + strlen(args) + 1);
d178 1
a178 1
		sprintf(buf, "/bin/ls %s", args);
d180 1
a231 1

a243 1

a247 1

a253 1

a261 1

a265 1

a276 1

a426 1

a586 1

@


1.14
log
@portable; ok markus@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.13 2001/02/07 18:10:39 stevesk Exp $");
d74 23
a96 23
	{ "CD",		I_CHDIR },
	{ "CHDIR",	I_CHDIR },
	{ "CHGRP",	I_CHGRP },
	{ "CHMOD",	I_CHMOD },
	{ "CHOWN",	I_CHOWN },
	{ "DIR",	I_LS },
	{ "EXIT",	I_QUIT },
	{ "GET",	I_GET },
	{ "HELP",	I_HELP },
	{ "LCD",	I_LCHDIR },
	{ "LCHDIR",	I_LCHDIR },
	{ "LLS",	I_LLS },
	{ "LMKDIR",	I_LMKDIR },
	{ "LPWD",	I_LPWD },
	{ "LS",		I_LS },
	{ "LUMASK",	I_LUMASK },
	{ "MKDIR",	I_MKDIR },
	{ "PUT",	I_PUT },
	{ "PWD",	I_PWD },
	{ "QUIT",	I_QUIT },
	{ "RENAME",	I_RENAME },
	{ "RM",		I_RM },
	{ "RMDIR",	I_RMDIR },
@


1.13
log
@more man page cleanup and sync of help text with man page; ok markus@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.12 2001/02/07 13:12:29 djm Exp $");
d607 2
a608 2
	setlinebuf(stdout);
	setlinebuf(stdin);
@


1.12
log
@Check that target is a directory before doing ls; ok markus@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.11 2001/02/07 00:10:18 markus Exp $");
d106 20
a125 20
	printf("CD path                       Change remote directory to 'path'\n");
	printf("LCD path                      Change local directory to 'path'\n");
	printf("CHGRP grp path                Change group of file 'path' to 'grp'\n");
	printf("CHMOD mode path               Change permissions of file 'path' to 'mode'\n");
	printf("CHOWN own path                Change owner of file 'path' to 'own'\n");
	printf("HELP                          Display this help text\n");
	printf("GET remote-path [local-path]  Download file\n");
	printf("LLS [ls options] [path]       Display local directory listing\n");
	printf("LMKDIR path                   Create local directory\n");
	printf("LPWD                          Print local working directory\n");
	printf("LS [path]                     Display remote directory listing\n");
	printf("LUMASK umask                  Set local umask to 'umask'\n");
	printf("MKDIR path                    Create remote directory\n");
	printf("PUT local-path [remote-path]  Upload file\n");
	printf("PWD                           Display remote working directory\n");
	printf("EXIT                          Quit sftp\n");
	printf("QUIT                          Quit sftp\n");
	printf("RENAME oldpath newpath        Rename remote file\n");
	printf("RMDIR path                    Remove remote directory\n");
	printf("RM path                       Delete remote file\n");
d128 1
@


1.11
log
@check for stat failures, too; ok djm@@
@
text
@d27 1
d31 1
a31 1
RCSID("$OpenBSD: sftp-int.c,v 1.10 2001/02/06 23:55:20 markus Exp $");
d502 4
d507 12
a518 1
		do_ls(in, out, path1?path1:*pwd);
@


1.10
log
@dir==ls
@
text
@d30 1
a30 1
RCSID("$OpenBSD: sftp-int.c,v 1.9 2001/02/06 22:18:16 djm Exp $");
d480 6
a485 2
		tmp = do_realpath(in, out, path1);
		aa = do_stat(in, out, tmp);
d497 2
a498 4
		if (tmp) {
			xfree(*pwd);
			*pwd = tmp;
		}
@


1.9
log
@stat target for remote chdir before doing chdir
@
text
@d30 1
a30 1
RCSID("$OpenBSD: sftp-int.c,v 1.8 2001/02/06 05:22:02 provos Exp $");
d78 1
@


1.8
log
@cleanup get_pathname, fix pwd after failed cd. okay djm@@
@
text
@d30 1
a30 1
RCSID("$OpenBSD: sftp-int.c,v 1.7 2001/02/05 00:02:32 deraadt Exp $");
d480 12
@


1.7
log
@? == help
@
text
@d30 1
a30 1
RCSID("$OpenBSD: sftp-int.c,v 1.6 2001/02/04 23:47:46 deraadt Exp $");
d219 2
a220 1
	const char *quot, *cp = *cpp;
d227 2
a228 1
		return(0);
d233 4
a236 4
		quot = cp++;
		for(i = 0; cp[i] && cp[i] != *quot; i++)
			;
		if (!cp[i]) {
d238 1
a238 2
			*path = NULL;
			return(-1);
d240 2
a241 1
		if (i == 0) {
d243 1
a243 2
			*path = NULL;
			return(-1);
d245 9
a253 6
		*path = xmalloc(i + 1);
		memcpy(*path, cp, i);
		(*path)[i] = '\0';
		cp += i + 1;
		*cpp = cp + strspn(cp, WHITESPACE);
		return(0);
d256 1
a256 3
	/* Read to end of filename */
	for(i = 0; cp[i] && cp[i] != ' '; i++)
		;
a260 2
	cp += i;
	*cpp = cp + strspn(cp, WHITESPACE);
d263 5
d436 1
a436 1
	char *path1, *path2;
d479 5
a483 2
		xfree(*pwd);
		*pwd = do_realpath(in, out, path1);
@


1.6
log
@sort commands, so that abbreviations work as expected
@
text
@d30 1
a30 1
RCSID("$OpenBSD: sftp-int.c,v 1.5 2001/02/04 22:17:52 stevesk Exp $");
d96 1
@


1.5
log
@debugging sftp: precedence and missing break.  chmod, chown, chgrp
seem to be working now.
@
text
@d30 1
a30 1
RCSID("$OpenBSD: sftp-int.c,v 1.4 2001/02/04 21:41:21 markus Exp $");
d68 1
a69 1
	const char *c;
d73 24
a96 24
	{ I_CHDIR,	"CD" },
	{ I_CHDIR,	"CHDIR" },
	{ I_CHGRP,	"CHGRP" },
	{ I_CHMOD,	"CHMOD" },
	{ I_CHOWN,	"CHOWN" },
	{ I_HELP,	"HELP" },
	{ I_GET,	"GET" },
	{ I_LCHDIR,	"LCD" },
	{ I_LCHDIR,	"LCHDIR" },
	{ I_LLS,	"LLS" },
	{ I_LMKDIR,	"LMKDIR" },
	{ I_LPWD,	"LPWD" },
	{ I_LS,		"LS" },
	{ I_LUMASK,	"LUMASK" },
	{ I_MKDIR,	"MKDIR" },
	{ I_PUT,	"PUT" },
	{ I_PWD,	"PWD" },
	{ I_QUIT,	"EXIT" },
	{ I_QUIT,	"QUIT" },
	{ I_RENAME,	"RENAME" },
	{ I_RMDIR,	"RMDIR" },
	{ I_RM,		"RM" },
	{ I_SHELL,	"!" },
	{ -1,		NULL}
@


1.4
log
@use base 8 for umask/chmod
@
text
@d30 1
a30 1
RCSID("$OpenBSD: sftp-int.c,v 1.3 2001/02/04 15:32:25 stevesk Exp $");
d505 1
d509 1
a509 1
		if (!aa->flags & SSH2_FILEXFER_ATTR_UIDGID) {
d520 1
a520 1
		if (!aa->flags & SSH2_FILEXFER_ATTR_UIDGID) {
@


1.3
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d30 1
a30 1
RCSID("$OpenBSD: sftp-int.c,v 1.2 2001/02/04 15:17:00 markus Exp $");
d292 1
d387 1
d396 1
a396 1
		*n_arg = strtoul(cp, (char**)&cp, 0);
@


1.2
log
@fix LCD
@
text
@d30 1
a30 1
RCSID("$OpenBSD: sftp-int.c,v 1.1 2001/02/04 11:11:54 djm Exp $");
d133 1
a133 1
	
d136 1
a136 1
	
d152 1
a152 1
		fprintf(stderr, "Couldn't execute \"%s\": %s\n", shell, 
d164 1
a164 1
void 
d370 1
a370 1
			error("You must specify a path after a %s command.", 
d406 1
a406 1
			error("You must specify a path after a %s command.", 
@


1.1
log
@Basic interactive sftp client; ok theo@@
@
text
@d30 1
a30 1
RCSID("$OpenBSD$");
a74 1
	{ I_CHDIR,	"LCD" },
d80 1
@

