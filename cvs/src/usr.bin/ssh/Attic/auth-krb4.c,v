head	1.31;
access;
symbols
	OPENBSD_3_3:1.29.0.2
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.31
date	2003.07.22.13.35.22;	author markus;	state dead;
branches;
next	1.30;

1.30
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.21.10.34.48;	author mpech;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2002.09.26.11.38.43;	author markus;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2002.06.11.05.46.20;	author mpech;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.18.01.30.10;	author dugsong;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.26.16.15.22;	author dugsong;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2001.01.22.08.15.00;	author markus;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2001.01.21.19.05.41;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.19.15.55.10;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2000.12.19.23.17.54;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.03.18.03.02;	author markus;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2000.09.07.20.27.49;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.28.03.50.54;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.02.17.27.04;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.22.23.54.59;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.14.10.30.29;	author markus;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2000.03.21.23.11.10;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.16.20.56.14;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	99.12.01.16.54.34;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	99.11.24.00.26.00;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.11.23.22.25.52;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	99.11.15.00.42.00;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	99.11.14.22.58.44;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.11.10.22.24.01;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	99.11.02.19.10.14;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	99.10.01.18.18.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.21.14.15;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.18.16.18;	author dugsong;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.33;	author deraadt;	state Exp;
branches;
next	;

1.14.2.1
date	2000.09.01.18.23.16;	author jason;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2000.11.08.21.30.17;	author jason;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2001.03.12.15.44.07;	author jason;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2001.03.21.18.52.32;	author jason;	state Exp;
branches;
next	;

1.19.2.1
date	2001.02.16.20.12.51;	author jason;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.02.19.17.18.33;	author jason;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2001.03.21.19.46.22;	author jason;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2001.05.07.21.09.25;	author jason;	state Exp;
branches;
next	1.19.2.5;

1.19.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.19.2.6;

1.19.2.6
date	2002.03.08.17.04.41;	author brad;	state Exp;
branches;
next	;

1.23.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2002.03.09.00.20.43;	author miod;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2002.06.02.22.56.09;	author miod;	state Exp;
branches;
next	;

1.24.2.1
date	2002.03.07.17.37.45;	author jason;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2002.06.22.07.23.16;	author miod;	state Exp;
branches;
next	1.24.2.4;

1.24.2.4
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.26.2.1
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2002.10.11.14.51.51;	author miod;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2003.04.03.22.35.16;	author miod;	state Exp;
branches;
next	;

1.28.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2003.09.16.21.20.24;	author brad;	state dead;
branches;
next	;

1.29.2.1
date	2003.09.16.20.50.42;	author brad;	state dead;
branches;
next	;


desc
@@


1.31
log
@remove (already disabled) KRB4/AFS support, re-enable -k in ssh(1);
test+ok henning@@
@
text
@/*
 * Copyright (c) 1999 Dug Song.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "includes.h"
RCSID("$OpenBSD: auth-krb4.c,v 1.30 2003/04/08 20:21:28 itojun Exp $");

#include "ssh.h"
#include "ssh1.h"
#include "packet.h"
#include "xmalloc.h"
#include "log.h"
#include "servconf.h"
#include "uidswap.h"
#include "auth.h"

#ifdef AFS
#include "radix.h"
#endif

#ifdef KRB4
extern ServerOptions options;

static int
krb4_init(void *context)
{
	static int cleanup_registered = 0;
	Authctxt *authctxt = (Authctxt *)context;
	const char *tkt_root = TKT_ROOT;
	struct stat st;
	int fd;

	if (!authctxt->krb4_ticket_file) {
		/* Set unique ticket string manually since we're still root. */
		authctxt->krb4_ticket_file = xmalloc(MAXPATHLEN);
#ifdef AFS
		if (lstat("/ticket", &st) != -1)
			tkt_root = "/ticket/";
#endif /* AFS */
		snprintf(authctxt->krb4_ticket_file, MAXPATHLEN, "%s%u_%ld",
		    tkt_root, authctxt->pw->pw_uid, (long)getpid());
		krb_set_tkt_string(authctxt->krb4_ticket_file);
	}
	/* Register ticket cleanup in case of fatal error. */
	if (!cleanup_registered) {
		fatal_add_cleanup(krb4_cleanup_proc, authctxt);
		cleanup_registered = 1;
	}
	/* Try to create our ticket file. */
	if ((fd = mkstemp(authctxt->krb4_ticket_file)) != -1) {
		close(fd);
		return (1);
	}
	/* Ticket file exists - make sure user owns it (just passed ticket). */
	if (lstat(authctxt->krb4_ticket_file, &st) != -1) {
		if (st.st_mode == (S_IFREG | S_IRUSR | S_IWUSR) &&
		    st.st_uid == authctxt->pw->pw_uid)
			return (1);
	}
	/* Failure - cancel cleanup function, leaving ticket for inspection. */
	logit("WARNING: bad ticket file %s", authctxt->krb4_ticket_file);

	fatal_remove_cleanup(krb4_cleanup_proc, authctxt);
	cleanup_registered = 0;

	xfree(authctxt->krb4_ticket_file);
	authctxt->krb4_ticket_file = NULL;

	return (0);
}

/*
 * try krb4 authentication,
 * return 1 on success, 0 on failure, -1 if krb4 is not available
 */
int
auth_krb4_password(Authctxt *authctxt, const char *password)
{
	AUTH_DAT adata;
	KTEXT_ST tkt;
	struct hostent *hp;
	struct passwd *pw;
	char localhost[MAXHOSTNAMELEN], phost[INST_SZ], realm[REALM_SZ];
	u_int32_t faddr;
	int r;

	if ((pw = authctxt->pw) == NULL)
		return (0);

	/*
	 * Try Kerberos password authentication only for non-root
	 * users and only if Kerberos is installed.
	 */
	if (pw->pw_uid != 0 && krb_get_lrealm(realm, 1) == KSUCCESS) {
		/* Set up our ticket file. */
		if (!krb4_init(authctxt)) {
			logit("Couldn't initialize Kerberos ticket file for %s!",
			    pw->pw_name);
			goto failure;
		}
		/* Try to get TGT using our password. */
		r = krb_get_pw_in_tkt((char *) pw->pw_name, "", realm,
		    "krbtgt", realm, DEFAULT_TKT_LIFE, (char *)password);
		if (r != INTK_OK) {
			debug("Kerberos v4 password authentication for %s "
			    "failed: %s", pw->pw_name, krb_err_txt[r]);
			goto failure;
		}
		/* Successful authentication. */
		chown(tkt_string(), pw->pw_uid, pw->pw_gid);

		/*
		 * Now that we have a TGT, try to get a local
		 * "rcmd" ticket to ensure that we are not talking
		 * to a bogus Kerberos server.
		 */
		gethostname(localhost, sizeof(localhost));
		strlcpy(phost, (char *)krb_get_phost(localhost),
		    sizeof(phost));
		r = krb_mk_req(&tkt, KRB4_SERVICE_NAME, phost, realm, 33);

		if (r == KSUCCESS) {
			if ((hp = gethostbyname(localhost)) == NULL) {
				logit("Couldn't get local host address!");
				goto failure;
			}
			memmove((void *)&faddr, (void *)hp->h_addr,
			    sizeof(faddr));

			/* Verify our "rcmd" ticket. */
			r = krb_rd_req(&tkt, KRB4_SERVICE_NAME, phost,
			    faddr, &adata, "");
			if (r == RD_AP_UNDEC) {
				/*
				 * Probably didn't have a srvtab on
				 * localhost. Disallow login.
				 */
				logit("Kerberos v4 TGT for %s unverifiable, "
				    "no srvtab installed? krb_rd_req: %s",
				    pw->pw_name, krb_err_txt[r]);
				goto failure;
			} else if (r != KSUCCESS) {
				logit("Kerberos v4 %s ticket unverifiable: %s",
				    KRB4_SERVICE_NAME, krb_err_txt[r]);
				goto failure;
			}
		} else if (r == KDC_PR_UNKNOWN) {
			/*
			 * Disallow login if no rcmd service exists, and
			 * log the error.
			 */
			logit("Kerberos v4 TGT for %s unverifiable: %s; %s.%s "
			    "not registered, or srvtab is wrong?", pw->pw_name,
			    krb_err_txt[r], KRB4_SERVICE_NAME, phost);
			goto failure;
		} else {
			/*
			 * TGT is bad, forget it. Possibly spoofed!
			 */
			debug("WARNING: Kerberos v4 TGT possibly spoofed "
			    "for %s: %s", pw->pw_name, krb_err_txt[r]);
			goto failure;
		}
		/* Authentication succeeded. */
		return (1);
	} else
		/* Logging in as root or no local Kerberos realm. */
		debug("Unable to authenticate to Kerberos.");

 failure:
	krb4_cleanup_proc(authctxt);

	if (!options.kerberos_or_local_passwd)
		return (0);

	/* Fall back to ordinary passwd authentication. */
	return (-1);
}

void
krb4_cleanup_proc(void *context)
{
	Authctxt *authctxt = (Authctxt *)context;
	debug("krb4_cleanup_proc called");
	if (authctxt->krb4_ticket_file) {
		(void) dest_tkt();
		xfree(authctxt->krb4_ticket_file);
		authctxt->krb4_ticket_file = NULL;
	}
}

int
auth_krb4(Authctxt *authctxt, KTEXT auth, char **client, KTEXT reply)
{
	AUTH_DAT adat = {0};
	Key_schedule schedule;
	struct sockaddr_in local, foreign;
	char instance[INST_SZ];
	socklen_t slen;
	u_int cksum;
	int r, s;

	s = packet_get_connection_in();

	slen = sizeof(local);
	memset(&local, 0, sizeof(local));
	if (getsockname(s, (struct sockaddr *) & local, &slen) < 0)
		debug("getsockname failed: %.100s", strerror(errno));
	slen = sizeof(foreign);
	memset(&foreign, 0, sizeof(foreign));
	if (getpeername(s, (struct sockaddr *) & foreign, &slen) < 0) {
		debug("getpeername failed: %.100s", strerror(errno));
		fatal_cleanup();
	}
	instance[0] = '*';
	instance[1] = 0;

	/* Get the encrypted request, challenge, and session key. */
	if ((r = krb_rd_req(auth, KRB4_SERVICE_NAME, instance,
	    0, &adat, ""))) {
		debug("Kerberos v4 krb_rd_req: %.100s", krb_err_txt[r]);
		return (0);
	}
	des_key_sched((des_cblock *) adat.session, schedule);

	*client = xmalloc(MAX_K_NAME_SZ);
	(void) snprintf(*client, MAX_K_NAME_SZ, "%s%s%s@@%s", adat.pname,
	    *adat.pinst ? "." : "", adat.pinst, adat.prealm);

	/* Check ~/.klogin authorization now. */
	if (kuserok(&adat, authctxt->user) != KSUCCESS) {
		logit("Kerberos v4 .klogin authorization failed for %s to "
		    "account %s", *client, authctxt->user);
		xfree(*client);
		*client = NULL;
		return (0);
	}
	/* Increment the checksum, and return it encrypted with the
	   session key. */
	cksum = adat.checksum + 1;
	cksum = htonl(cksum);

	/* If we can't successfully encrypt the checksum, we send back an
	   empty message, admitting our failure. */
	if ((r = krb_mk_priv((u_char *) & cksum, reply->dat, sizeof(cksum) + 1,
	    schedule, &adat.session, &local, &foreign)) < 0) {
		debug("Kerberos v4 mk_priv: (%d) %s", r, krb_err_txt[r]);
		reply->dat[0] = 0;
		reply->length = 0;
	} else
		reply->length = r;

	/* Clear session key. */
	memset(&adat.session, 0, sizeof(adat.session));
	return (1);
}
#endif /* KRB4 */

#ifdef AFS
int
auth_krb4_tgt(Authctxt *authctxt, const char *string)
{
	CREDENTIALS creds;
	struct passwd *pw;

	if ((pw = authctxt->pw) == NULL)
		goto failure;

	temporarily_use_uid(pw);

	if (!radix_to_creds(string, &creds)) {
		logit("Protocol error decoding Kerberos v4 TGT");
		goto failure;
	}
	if (strncmp(creds.service, "", 1) == 0)	/* backward compatibility */
		strlcpy(creds.service, "krbtgt", sizeof creds.service);

	if (strcmp(creds.service, "krbtgt")) {
		logit("Kerberos v4 TGT (%s%s%s@@%s) rejected for %s",
		    creds.pname, creds.pinst[0] ? "." : "", creds.pinst,
		    creds.realm, pw->pw_name);
		goto failure;
	}
	if (!krb4_init(authctxt))
		goto failure;

	if (in_tkt(creds.pname, creds.pinst) != KSUCCESS)
		goto failure;

	if (save_credentials(creds.service, creds.instance, creds.realm,
	    creds.session, creds.lifetime, creds.kvno, &creds.ticket_st,
	    creds.issue_date) != KSUCCESS) {
		debug("Kerberos v4 TGT refused: couldn't save credentials");
		goto failure;
	}
	/* Successful authentication, passed all checks. */
	chown(tkt_string(), pw->pw_uid, pw->pw_gid);

	debug("Kerberos v4 TGT accepted (%s%s%s@@%s)",
	    creds.pname, creds.pinst[0] ? "." : "", creds.pinst, creds.realm);
	memset(&creds, 0, sizeof(creds));

	restore_uid();

	return (1);

 failure:
	krb4_cleanup_proc(authctxt);
	memset(&creds, 0, sizeof(creds));
	restore_uid();

	return (0);
}

int
auth_afs_token(Authctxt *authctxt, const char *token_string)
{
	CREDENTIALS creds;
	struct passwd *pw;
	uid_t uid;

	if ((pw = authctxt->pw) == NULL)
		return (0);

	if (!radix_to_creds(token_string, &creds)) {
		logit("Protocol error decoding AFS token");
		return (0);
	}
	if (strncmp(creds.service, "", 1) == 0)	/* backward compatibility */
		strlcpy(creds.service, "afs", sizeof creds.service);

	if (strncmp(creds.pname, "AFS ID ", 7) == 0)
		uid = atoi(creds.pname + 7);
	else
		uid = pw->pw_uid;

	if (kafs_settoken(creds.realm, uid, &creds)) {
		logit("AFS token (%s@@%s) rejected for %s",
		    creds.pname, creds.realm, pw->pw_name);
		memset(&creds, 0, sizeof(creds));
		return (0);
	}
	debug("AFS token accepted (%s@@%s)", creds.pname, creds.realm);
	memset(&creds, 0, sizeof(creds));

	return (1);
}
#endif /* AFS */
@


1.30
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.29 2003/02/21 10:34:48 mpech Exp $");
@


1.29
log
@...sizeof(&adat.session) is not good here.

henning@@, deraadt@@, millert@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.28 2002/09/26 11:38:43 markus Exp $");
d81 1
a81 1
	log("WARNING: bad ticket file %s", authctxt->krb4_ticket_file);
d117 1
a117 1
			log("Couldn't initialize Kerberos ticket file for %s!",
d144 1
a144 1
				log("Couldn't get local host address!");
d158 1
a158 1
				log("Kerberos v4 TGT for %s unverifiable, "
d163 1
a163 1
				log("Kerberos v4 %s ticket unverifiable: %s",
d172 1
a172 1
			log("Kerberos v4 TGT for %s unverifiable: %s; %s.%s "
d252 1
a252 1
		log("Kerberos v4 .klogin authorization failed for %s to "
d292 1
a292 1
		log("Protocol error decoding Kerberos v4 TGT");
d299 1
a299 1
		log("Kerberos v4 TGT (%s%s%s@@%s) rejected for %s",
d346 1
a346 1
		log("Protocol error decoding AFS token");
d358 1
a358 1
		log("AFS token (%s@@%s) rejected for %s",
@


1.29.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.29 2003/02/21 10:34:48 mpech Exp $");
@


1.28
log
@krb4 + privsep; ok dugsong@@, deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.27 2002/06/11 05:46:20 mpech Exp $");
d274 1
a274 1
	memset(&adat.session, 0, sizeof(&adat.session));
@


1.28.2.1
log
@Update to OpenSSH 3.6
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.29 2003/02/21 10:34:48 mpech Exp $");
d274 1
a274 1
	memset(&adat.session, 0, sizeof(adat.session));
@


1.28.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.28.2.1 2003/04/01 00:12:13 margarida Exp $");
@


1.27
log
@pid_t cleanup. Markus need this now to keep hacking.
markus@@, millert@@ ok

Note: big usr.bin/ cleanup is comming. Now I'm waiting Ok from espie@@ for
make/.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.26 2002/03/18 01:30:10 dugsong Exp $");
d213 1
a213 1
auth_krb4(Authctxt *authctxt, KTEXT auth, char **client)
a215 1
	KTEXT_ST reply;
d265 1
a265 1
	if ((r = krb_mk_priv((u_char *) & cksum, reply.dat, sizeof(cksum) + 1,
d268 2
a269 2
		reply.dat[0] = 0;
		reply.length = 0;
d271 1
a271 1
		reply.length = r;
a274 5

	packet_start(SSH_SMSG_AUTH_KERBEROS_RESPONSE);
	packet_put_string((char *) reply.dat, reply.length);
	packet_send();
	packet_write_wait();
@


1.26
log
@set client to NULL after xfree(), from Rolf Braun <rbraun+ssh@@andrew.cmu.edu>
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.25 2001/12/19 07:18:56 deraadt Exp $");
d60 2
a61 2
		snprintf(authctxt->krb4_ticket_file, MAXPATHLEN, "%s%u_%d",
		    tkt_root, authctxt->pw->pw_uid, getpid());
@


1.26.2.1
log
@Pull in OpenSSH-3.4
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.27 2002/06/11 05:46:20 mpech Exp $");
d60 2
a61 2
		snprintf(authctxt->krb4_ticket_file, MAXPATHLEN, "%s%u_%ld",
		    tkt_root, authctxt->pw->pw_uid, (long)getpid());
@


1.26.2.2
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.28 2002/09/26 11:38:43 markus Exp $");
d213 1
a213 1
auth_krb4(Authctxt *authctxt, KTEXT auth, char **client, KTEXT reply)
d216 1
d266 1
a266 1
	if ((r = krb_mk_priv((u_char *) & cksum, reply->dat, sizeof(cksum) + 1,
d269 2
a270 2
		reply->dat[0] = 0;
		reply->length = 0;
d272 1
a272 1
		reply->length = r;
d276 5
@


1.26.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.29 2003/02/21 10:34:48 mpech Exp $");
d274 1
a274 1
	memset(&adat.session, 0, sizeof(adat.session));
@


1.25
log
@basic KNF done while i was looking for something else
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.24 2001/06/26 16:15:22 dugsong Exp $");
d256 1
@


1.24
log
@Kerberos v5 support for SSH1, mostly from Assar Westerlund <assar@@freebsd.org> and Bjorn Gronvall <bg@@sics.se>. markus@@ ok
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.23 2001/01/22 08:15:00 markus Exp $");
d52 1
a52 1
	
d82 1
a82 1
	
d85 1
a85 1
	
d88 1
a88 1
	
d106 1
a106 1
	
d109 1
a109 1
	
d131 1
a131 1
		
d141 1
a141 1
		
d149 1
a149 1
			
d189 1
a189 1
	
d192 1
a192 1
	
d195 1
a195 1
	
d223 1
a223 1
	
d225 1
a225 1
	
d238 1
a238 1
	
d246 1
a246 1
	
d250 1
a250 1
	
d262 1
a262 1
	
d272 1
a272 1
	
d275 1
a275 1
	
d290 1
a290 1
	
d293 1
a293 1
	
d295 1
a295 1
	
d302 1
a302 1
	
d311 1
a311 1
	
d314 1
a314 1
	
d323 1
a323 1
	
d327 1
a327 1
	
d329 1
a329 1
	
d331 1
a331 1
	
d336 1
a336 1
	
d346 1
a346 1
	
d349 1
a349 1
	
d356 1
a356 1
	
d361 1
a361 1
	
d370 1
a370 1
	
@


1.24.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.25 2001/12/19 07:18:56 deraadt Exp $");
d52 1
a52 1

d82 1
a82 1

d85 1
a85 1

d88 1
a88 1

d106 1
a106 1

d109 1
a109 1

d131 1
a131 1

d141 1
a141 1

d149 1
a149 1

d189 1
a189 1

d192 1
a192 1

d195 1
a195 1

d223 1
a223 1

d225 1
a225 1

d238 1
a238 1

d246 1
a246 1

d250 1
a250 1

d262 1
a262 1

d272 1
a272 1

d275 1
a275 1

d290 1
a290 1

d293 1
a293 1

d295 1
a295 1

d302 1
a302 1

d311 1
a311 1

d314 1
a314 1

d323 1
a323 1

d327 1
a327 1

d329 1
a329 1

d331 1
a331 1

d336 1
a336 1

d346 1
a346 1

d349 1
a349 1

d356 1
a356 1

d361 1
a361 1

d370 1
a370 1

@


1.24.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.26 2002/03/18 01:30:10 dugsong Exp $");
a255 1
		*client = NULL;
@


1.24.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.24.2.2 2002/05/17 00:03:23 miod Exp $");
d60 2
a61 2
		snprintf(authctxt->krb4_ticket_file, MAXPATHLEN, "%s%u_%ld",
		    tkt_root, authctxt->pw->pw_uid, (long)getpid());
@


1.24.2.4
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.28 2002/09/26 11:38:43 markus Exp $");
d213 1
a213 1
auth_krb4(Authctxt *authctxt, KTEXT auth, char **client, KTEXT reply)
d216 1
d266 1
a266 1
	if ((r = krb_mk_priv((u_char *) & cksum, reply->dat, sizeof(cksum) + 1,
d269 2
a270 2
		reply->dat[0] = 0;
		reply->length = 0;
d272 1
a272 1
		reply->length = r;
d276 5
@


1.23
log
@only AFS needs radix.[ch]
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.22 2001/01/21 19:05:41 markus Exp $");
d34 1
d42 1
a42 1
char *ticket = NULL;
d44 47
a90 1
extern ServerOptions options;
a95 1

d97 1
a97 1
auth_krb4_password(struct passwd * pw, const char *password)
d102 3
a104 4
	u_long faddr;
	char localhost[MAXHOSTNAMELEN];
	char phost[INST_SZ];
	char realm[REALM_SZ];
d106 4
a109 1

a114 1

d116 1
a116 1
		if (!krb4_init(pw->pw_uid)) {
d119 1
a119 1
			goto kerberos_auth_failure;
d122 2
a123 3
		r = krb_get_pw_in_tkt((char *) pw->pw_name, "",
		    realm, "krbtgt", realm,
		    DEFAULT_TKT_LIFE, (char *) password);
d125 3
a127 4
			packet_send_debug("Kerberos V4 password "
			    "authentication for %s failed: %s",
			    pw->pw_name, krb_err_txt[r]);
			goto kerberos_auth_failure;
d131 1
a131 1

d137 3
a139 3
		(void) gethostname(localhost, sizeof(localhost));
		(void) strlcpy(phost, (char *) krb_get_phost(localhost),
		    INST_SZ);
d141 1
a141 1

d143 1
a143 1
			if (!(hp = gethostbyname(localhost))) {
d145 1
a145 1
				goto kerberos_auth_failure;
d147 1
a147 1
			memmove((void *) &faddr, (void *) hp->h_addr,
d149 1
a149 1

d158 1
a158 1
				log("Kerberos V4 TGT for %s unverifiable, "
d161 1
a161 1
				goto kerberos_auth_failure;
d163 1
a163 1
				log("Kerberos V4 %s ticket unverifiable: %s",
d165 1
a165 1
				goto kerberos_auth_failure;
d172 1
a172 1
			log("Kerberos V4 TGT for %s unverifiable: %s; %s.%s "
d174 2
a175 2
			krb_err_txt[r], KRB4_SERVICE_NAME, phost);
			goto kerberos_auth_failure;
d180 3
a182 4
			packet_send_debug("WARNING: Kerberos V4 TGT "
			    "possibly spoofed for %s: %s",
			    pw->pw_name, krb_err_txt[r]);
			goto kerberos_auth_failure;
a183 1

d185 2
a186 8
		return 1;

kerberos_auth_failure:
		krb4_cleanup_proc(NULL);

		if (!options.kerberos_or_local_passwd)
			return 0;
	} else {
d188 8
a195 2
		packet_send_debug("Unable to authenticate to Kerberos.");
	}
d197 1
a197 1
	return -1;
d201 1
a201 1
krb4_cleanup_proc(void *ignore)
d203 1
d205 1
a205 1
	if (ticket) {
d207 2
a208 38
		xfree(ticket);
		ticket = NULL;
	}
}

int
krb4_init(uid_t uid)
{
	static int cleanup_registered = 0;
	const char *tkt_root = TKT_ROOT;
	struct stat st;
	int fd;

	if (!ticket) {
		/* Set unique ticket string manually since we're still root. */
		ticket = xmalloc(MAXPATHLEN);
#ifdef AFS
		if (lstat("/ticket", &st) != -1)
			tkt_root = "/ticket/";
#endif /* AFS */
		snprintf(ticket, MAXPATHLEN, "%s%u_%d", tkt_root, uid, getpid());
		(void) krb_set_tkt_string(ticket);
	}
	/* Register ticket cleanup in case of fatal error. */
	if (!cleanup_registered) {
		fatal_add_cleanup(krb4_cleanup_proc, NULL);
		cleanup_registered = 1;
	}
	/* Try to create our ticket file. */
	if ((fd = mkstemp(ticket)) != -1) {
		close(fd);
		return 1;
	}
	/* Ticket file exists - make sure user owns it (just passed ticket). */
	if (lstat(ticket, &st) != -1) {
		if (st.st_mode == (S_IFREG | S_IRUSR | S_IWUSR) &&
		    st.st_uid == uid)
			return 1;
a209 8
	/* Failure - cancel cleanup function, leaving bad ticket for inspection. */
	log("WARNING: bad ticket file %s", ticket);
	fatal_remove_cleanup(krb4_cleanup_proc, NULL);
	cleanup_registered = 0;
	xfree(ticket);
	ticket = NULL;

	return 0;
d213 1
a213 1
auth_krb4(const char *server_user, KTEXT auth, char **client)
d217 2
a219 1
	int r, s;
d222 2
a223 3
	Key_schedule schedule;
	struct sockaddr_in local, foreign;

d225 1
a225 1

d238 1
a238 1

d240 4
a243 3
	if ((r = krb_rd_req(auth, KRB4_SERVICE_NAME, instance, 0, &adat, ""))) {
		packet_send_debug("Kerberos V4 krb_rd_req: %.100s", krb_err_txt[r]);
		return 0;
d246 1
a246 1

d250 1
a250 1

d252 3
a254 4
	if (kuserok(&adat, (char *) server_user) != KSUCCESS) {
		packet_send_debug("Kerberos V4 .klogin authorization failed!");
		log("Kerberos V4 .klogin authorization failed for %s to account %s",
		    *client, server_user);
d256 1
a256 1
		return 0;
d262 1
a262 1

d267 1
a267 1
		packet_send_debug("Kerberos V4 mk_priv: (%d) %s", r, krb_err_txt[r]);
d272 1
a272 1

d275 1
a275 1

d280 1
a280 1
	return 1;
d286 1
a286 1
auth_kerberos_tgt(struct passwd *pw, const char *string)
d289 7
a295 3

	if (pw == NULL)
		goto auth_kerberos_tgt_failure;
d297 2
a298 3
		log("Protocol error decoding Kerberos V4 tgt");
		packet_send_debug("Protocol error decoding Kerberos V4 tgt");
		goto auth_kerberos_tgt_failure;
d302 1
a302 1

d304 1
a304 4
		log("Kerberos V4 tgt (%s%s%s@@%s) rejected for %s", creds.pname,
		    creds.pinst[0] ? "." : "", creds.pinst, creds.realm,
		    pw->pw_name);
		packet_send_debug("Kerberos V4 tgt (%s%s%s@@%s) rejected for %s",
d307 1
a307 1
		goto auth_kerberos_tgt_failure;
d309 3
a311 3
	if (!krb4_init(pw->pw_uid))
		goto auth_kerberos_tgt_failure;

d313 2
a314 2
		goto auth_kerberos_tgt_failure;

d316 4
a319 4
	    creds.session, creds.lifetime, creds.kvno,
	    &creds.ticket_st, creds.issue_date) != KSUCCESS) {
		packet_send_debug("Kerberos V4 tgt refused: couldn't save credentials");
		goto auth_kerberos_tgt_failure;
d323 3
a325 4

	packet_send_debug("Kerberos V4 tgt accepted (%s.%s@@%s, %s%s%s@@%s)",
	    creds.service, creds.instance, creds.realm, creds.pname,
	    creds.pinst[0] ? "." : "", creds.pinst, creds.realm);
d327 7
a333 7
	packet_start(SSH_SMSG_SUCCESS);
	packet_send();
	packet_write_wait();
	return 1;

auth_kerberos_tgt_failure:
	krb4_cleanup_proc(NULL);
d335 3
a337 4
	packet_start(SSH_SMSG_FAILURE);
	packet_send();
	packet_write_wait();
	return 0;
d341 1
a341 1
auth_afs_token(struct passwd *pw, const char *token_string)
d344 1
d346 4
a349 9

	if (pw == NULL) {
		/* XXX fake protocol error */
		packet_send_debug("Protocol error decoding AFS token");
		packet_start(SSH_SMSG_FAILURE);
		packet_send();
		packet_write_wait();
		return 0;
	}
d352 1
a352 5
		packet_send_debug("Protocol error decoding AFS token");
		packet_start(SSH_SMSG_FAILURE);
		packet_send();
		packet_write_wait();
		return 0;
d356 1
a356 1

d361 1
a361 1

d363 2
a364 4
		log("AFS token (%s@@%s) rejected for %s", creds.pname, creds.realm,
		    pw->pw_name);
		packet_send_debug("AFS token (%s@@%s) rejected for %s", creds.pname,
		    creds.realm, pw->pw_name);
d366 1
a366 4
		packet_start(SSH_SMSG_FAILURE);
		packet_send();
		packet_write_wait();
		return 0;
d368 1
a368 2
	packet_send_debug("AFS token accepted (%s@@%s, %s@@%s)", creds.service,
	    creds.realm, creds.pname, creds.realm);
d370 2
a371 4
	packet_start(SSH_SMSG_SUCCESS);
	packet_send();
	packet_write_wait();
	return 1;
@


1.23.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.24 2001/06/26 16:15:22 dugsong Exp $");
a33 1
#include "uidswap.h"
d41 2
a44 48
static int
krb4_init(void *context)
{
	static int cleanup_registered = 0;
	Authctxt *authctxt = (Authctxt *)context;
	const char *tkt_root = TKT_ROOT;
	struct stat st;
	int fd;
	
	if (!authctxt->krb4_ticket_file) {
		/* Set unique ticket string manually since we're still root. */
		authctxt->krb4_ticket_file = xmalloc(MAXPATHLEN);
#ifdef AFS
		if (lstat("/ticket", &st) != -1)
			tkt_root = "/ticket/";
#endif /* AFS */
		snprintf(authctxt->krb4_ticket_file, MAXPATHLEN, "%s%u_%d",
		    tkt_root, authctxt->pw->pw_uid, getpid());
		krb_set_tkt_string(authctxt->krb4_ticket_file);
	}
	/* Register ticket cleanup in case of fatal error. */
	if (!cleanup_registered) {
		fatal_add_cleanup(krb4_cleanup_proc, authctxt);
		cleanup_registered = 1;
	}
	/* Try to create our ticket file. */
	if ((fd = mkstemp(authctxt->krb4_ticket_file)) != -1) {
		close(fd);
		return (1);
	}
	/* Ticket file exists - make sure user owns it (just passed ticket). */
	if (lstat(authctxt->krb4_ticket_file, &st) != -1) {
		if (st.st_mode == (S_IFREG | S_IRUSR | S_IWUSR) &&
		    st.st_uid == authctxt->pw->pw_uid)
			return (1);
	}
	/* Failure - cancel cleanup function, leaving ticket for inspection. */
	log("WARNING: bad ticket file %s", authctxt->krb4_ticket_file);
	
	fatal_remove_cleanup(krb4_cleanup_proc, authctxt);
	cleanup_registered = 0;
	
	xfree(authctxt->krb4_ticket_file);
	authctxt->krb4_ticket_file = NULL;
	
	return (0);
}

d49 1
d51 1
a51 1
auth_krb4_password(Authctxt *authctxt, const char *password)
d56 4
a59 3
	struct passwd *pw;
	char localhost[MAXHOSTNAMELEN], phost[INST_SZ], realm[REALM_SZ];
	u_int32_t faddr;
d61 1
a61 4
	
	if ((pw = authctxt->pw) == NULL)
		return (0);
	
d67 1
d69 1
a69 1
		if (!krb4_init(authctxt)) {
d72 1
a72 1
			goto failure;
d75 3
a77 2
		r = krb_get_pw_in_tkt((char *) pw->pw_name, "", realm,
		    "krbtgt", realm, DEFAULT_TKT_LIFE, (char *)password);
d79 4
a82 3
			debug("Kerberos v4 password authentication for %s "
			    "failed: %s", pw->pw_name, krb_err_txt[r]);
			goto failure;
d86 1
a86 1
		
d92 3
a94 3
		gethostname(localhost, sizeof(localhost));
		strlcpy(phost, (char *)krb_get_phost(localhost),
		    sizeof(phost));
d96 1
a96 1
		
d98 1
a98 1
			if ((hp = gethostbyname(localhost)) == NULL) {
d100 1
a100 1
				goto failure;
d102 1
a102 1
			memmove((void *)&faddr, (void *)hp->h_addr,
d104 1
a104 1
			
d113 1
a113 1
				log("Kerberos v4 TGT for %s unverifiable, "
d116 1
a116 1
				goto failure;
d118 1
a118 1
				log("Kerberos v4 %s ticket unverifiable: %s",
d120 1
a120 1
				goto failure;
d127 1
a127 1
			log("Kerberos v4 TGT for %s unverifiable: %s; %s.%s "
d129 2
a130 2
			    krb_err_txt[r], KRB4_SERVICE_NAME, phost);
			goto failure;
d135 4
a138 3
			debug("WARNING: Kerberos v4 TGT possibly spoofed "
			    "for %s: %s", pw->pw_name, krb_err_txt[r]);
			goto failure;
d140 1
d142 8
a149 2
		return (1);
	} else
d151 2
a152 8
		debug("Unable to authenticate to Kerberos.");
	
 failure:
	krb4_cleanup_proc(authctxt);
	
	if (!options.kerberos_or_local_passwd)
		return (0);
	
d154 1
a154 1
	return (-1);
d158 1
a158 1
krb4_cleanup_proc(void *context)
a159 1
	Authctxt *authctxt = (Authctxt *)context;
d161 1
a161 1
	if (authctxt->krb4_ticket_file) {
d163 38
a200 2
		xfree(authctxt->krb4_ticket_file);
		authctxt->krb4_ticket_file = NULL;
d202 8
d213 1
a213 1
auth_krb4(Authctxt *authctxt, KTEXT auth, char **client)
a216 2
	Key_schedule schedule;
	struct sockaddr_in local, foreign;
d218 1
d221 3
a223 2
	int r, s;
	
d225 1
a225 1
	
d238 1
a238 1
	
d240 3
a242 4
	if ((r = krb_rd_req(auth, KRB4_SERVICE_NAME, instance,
	    0, &adat, ""))) {
		debug("Kerberos v4 krb_rd_req: %.100s", krb_err_txt[r]);
		return (0);
d245 1
a245 1
	
d249 1
a249 1
	
d251 4
a254 3
	if (kuserok(&adat, authctxt->user) != KSUCCESS) {
		log("Kerberos v4 .klogin authorization failed for %s to "
		    "account %s", *client, authctxt->user);
d256 1
a256 1
		return (0);
d262 1
a262 1
	
d267 1
a267 1
		debug("Kerberos v4 mk_priv: (%d) %s", r, krb_err_txt[r]);
d272 1
a272 1
	
d275 1
a275 1
	
d280 1
a280 1
	return (1);
d286 1
a286 1
auth_krb4_tgt(Authctxt *authctxt, const char *string)
d289 3
a291 7
	struct passwd *pw;
	
	if ((pw = authctxt->pw) == NULL)
		goto failure;
	
	temporarily_use_uid(pw);
	
d293 3
a295 2
		log("Protocol error decoding Kerberos v4 TGT");
		goto failure;
d299 1
a299 1
	
d301 4
a304 1
		log("Kerberos v4 TGT (%s%s%s@@%s) rejected for %s",
d307 1
a307 1
		goto failure;
d309 3
a311 3
	if (!krb4_init(authctxt))
		goto failure;
	
d313 2
a314 2
		goto failure;
	
d316 4
a319 4
	    creds.session, creds.lifetime, creds.kvno, &creds.ticket_st,
	    creds.issue_date) != KSUCCESS) {
		debug("Kerberos v4 TGT refused: couldn't save credentials");
		goto failure;
d323 4
a326 3
	
	debug("Kerberos v4 TGT accepted (%s%s%s@@%s)",
	    creds.pname, creds.pinst[0] ? "." : "", creds.pinst, creds.realm);
d328 7
a334 7
	
	restore_uid();
	
	return (1);
	
 failure:
	krb4_cleanup_proc(authctxt);
d336 4
a339 3
	restore_uid();
	
	return (0);
d343 1
a343 1
auth_afs_token(Authctxt *authctxt, const char *token_string)
a345 1
	struct passwd *pw;
d347 9
a355 4
	
	if ((pw = authctxt->pw) == NULL)
		return (0);
	
d358 5
a362 1
		return (0);
d366 1
a366 1
	
d371 1
a371 1
	
d373 4
a376 2
		log("AFS token (%s@@%s) rejected for %s",
		    creds.pname, creds.realm, pw->pw_name);
d378 4
a381 1
		return (0);
d383 2
a384 1
	debug("AFS token accepted (%s@@%s)", creds.pname, creds.realm);
d386 4
a389 2
	
	return (1);
@


1.23.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.25 2001/12/19 07:18:56 deraadt Exp $");
d52 1
a52 1

d82 1
a82 1

d85 1
a85 1

d88 1
a88 1

d106 1
a106 1

d109 1
a109 1

d131 1
a131 1

d141 1
a141 1

d149 1
a149 1

d189 1
a189 1

d192 1
a192 1

d195 1
a195 1

d223 1
a223 1

d225 1
a225 1

d238 1
a238 1

d246 1
a246 1

d250 1
a250 1

d262 1
a262 1

d272 1
a272 1

d275 1
a275 1

d290 1
a290 1

d293 1
a293 1

d295 1
a295 1

d302 1
a302 1

d311 1
a311 1

d314 1
a314 1

d323 1
a323 1

d327 1
a327 1

d329 1
a329 1

d331 1
a331 1

d336 1
a336 1

d346 1
a346 1

d349 1
a349 1

d356 1
a356 1

d361 1
a361 1

d370 1
a370 1

@


1.23.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.26 2002/03/18 01:30:10 dugsong Exp $");
a255 1
		*client = NULL;
@


1.22
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.21 2001/01/19 15:55:10 markus Exp $");
d35 2
d38 1
@


1.21
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d26 4
d32 1
a32 2
#include "ssh.h"
#include "ssh1.h"
d34 2
a35 2

RCSID("$OpenBSD: auth-krb4.c,v 1.20 2000/12/19 23:17:54 markus Exp $");
@


1.20
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d29 1
d32 1
a32 1
RCSID("$OpenBSD: auth-krb4.c,v 1.19 2000/10/03 18:03:02 markus Exp $");
@


1.19
log
@move fake-auth from auth1.c to individual auth methods, disables s/key in debug-msg
@
text
@d31 1
a31 1
RCSID("$OpenBSD: auth-krb4.c,v 1.18 2000/09/07 20:27:49 deraadt Exp $");
d49 1
a49 1
	unsigned long faddr;
@


1.19.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@a25 4
RCSID("$OpenBSD: auth-krb4.c,v 1.23 2001/01/22 08:15:00 markus Exp $");

#include "ssh.h"
#include "ssh1.h"
d28 1
a28 1
#include "log.h"
a29 1
#include "auth.h"
d31 1
a31 3
#ifdef AFS
#include "radix.h"
#endif
d49 1
a49 1
	u_long faddr;
@


1.19.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.19.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.19.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.19.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.24 2001/06/26 16:15:22 dugsong Exp $");
a33 1
#include "uidswap.h"
d41 2
a44 48
static int
krb4_init(void *context)
{
	static int cleanup_registered = 0;
	Authctxt *authctxt = (Authctxt *)context;
	const char *tkt_root = TKT_ROOT;
	struct stat st;
	int fd;
	
	if (!authctxt->krb4_ticket_file) {
		/* Set unique ticket string manually since we're still root. */
		authctxt->krb4_ticket_file = xmalloc(MAXPATHLEN);
#ifdef AFS
		if (lstat("/ticket", &st) != -1)
			tkt_root = "/ticket/";
#endif /* AFS */
		snprintf(authctxt->krb4_ticket_file, MAXPATHLEN, "%s%u_%d",
		    tkt_root, authctxt->pw->pw_uid, getpid());
		krb_set_tkt_string(authctxt->krb4_ticket_file);
	}
	/* Register ticket cleanup in case of fatal error. */
	if (!cleanup_registered) {
		fatal_add_cleanup(krb4_cleanup_proc, authctxt);
		cleanup_registered = 1;
	}
	/* Try to create our ticket file. */
	if ((fd = mkstemp(authctxt->krb4_ticket_file)) != -1) {
		close(fd);
		return (1);
	}
	/* Ticket file exists - make sure user owns it (just passed ticket). */
	if (lstat(authctxt->krb4_ticket_file, &st) != -1) {
		if (st.st_mode == (S_IFREG | S_IRUSR | S_IWUSR) &&
		    st.st_uid == authctxt->pw->pw_uid)
			return (1);
	}
	/* Failure - cancel cleanup function, leaving ticket for inspection. */
	log("WARNING: bad ticket file %s", authctxt->krb4_ticket_file);
	
	fatal_remove_cleanup(krb4_cleanup_proc, authctxt);
	cleanup_registered = 0;
	
	xfree(authctxt->krb4_ticket_file);
	authctxt->krb4_ticket_file = NULL;
	
	return (0);
}

d49 1
d51 1
a51 1
auth_krb4_password(Authctxt *authctxt, const char *password)
d56 4
a59 3
	struct passwd *pw;
	char localhost[MAXHOSTNAMELEN], phost[INST_SZ], realm[REALM_SZ];
	u_int32_t faddr;
d61 1
a61 4
	
	if ((pw = authctxt->pw) == NULL)
		return (0);
	
d67 1
d69 1
a69 1
		if (!krb4_init(authctxt)) {
d72 1
a72 1
			goto failure;
d75 3
a77 2
		r = krb_get_pw_in_tkt((char *) pw->pw_name, "", realm,
		    "krbtgt", realm, DEFAULT_TKT_LIFE, (char *)password);
d79 4
a82 3
			debug("Kerberos v4 password authentication for %s "
			    "failed: %s", pw->pw_name, krb_err_txt[r]);
			goto failure;
d86 1
a86 1
		
d92 3
a94 3
		gethostname(localhost, sizeof(localhost));
		strlcpy(phost, (char *)krb_get_phost(localhost),
		    sizeof(phost));
d96 1
a96 1
		
d98 1
a98 1
			if ((hp = gethostbyname(localhost)) == NULL) {
d100 1
a100 1
				goto failure;
d102 1
a102 1
			memmove((void *)&faddr, (void *)hp->h_addr,
d104 1
a104 1
			
d113 1
a113 1
				log("Kerberos v4 TGT for %s unverifiable, "
d116 1
a116 1
				goto failure;
d118 1
a118 1
				log("Kerberos v4 %s ticket unverifiable: %s",
d120 1
a120 1
				goto failure;
d127 1
a127 1
			log("Kerberos v4 TGT for %s unverifiable: %s; %s.%s "
d129 2
a130 2
			    krb_err_txt[r], KRB4_SERVICE_NAME, phost);
			goto failure;
d135 4
a138 3
			debug("WARNING: Kerberos v4 TGT possibly spoofed "
			    "for %s: %s", pw->pw_name, krb_err_txt[r]);
			goto failure;
d140 1
d142 8
a149 2
		return (1);
	} else
d151 2
a152 8
		debug("Unable to authenticate to Kerberos.");
	
 failure:
	krb4_cleanup_proc(authctxt);
	
	if (!options.kerberos_or_local_passwd)
		return (0);
	
d154 1
a154 1
	return (-1);
d158 1
a158 1
krb4_cleanup_proc(void *context)
a159 1
	Authctxt *authctxt = (Authctxt *)context;
d161 1
a161 1
	if (authctxt->krb4_ticket_file) {
d163 38
a200 2
		xfree(authctxt->krb4_ticket_file);
		authctxt->krb4_ticket_file = NULL;
d202 8
d213 1
a213 1
auth_krb4(Authctxt *authctxt, KTEXT auth, char **client)
a216 2
	Key_schedule schedule;
	struct sockaddr_in local, foreign;
d218 1
d221 3
a223 2
	int r, s;
	
d225 1
a225 1
	
d238 1
a238 1
	
d240 3
a242 4
	if ((r = krb_rd_req(auth, KRB4_SERVICE_NAME, instance,
	    0, &adat, ""))) {
		debug("Kerberos v4 krb_rd_req: %.100s", krb_err_txt[r]);
		return (0);
d245 1
a245 1
	
d249 1
a249 1
	
d251 4
a254 3
	if (kuserok(&adat, authctxt->user) != KSUCCESS) {
		log("Kerberos v4 .klogin authorization failed for %s to "
		    "account %s", *client, authctxt->user);
d256 1
a256 1
		return (0);
d262 1
a262 1
	
d267 1
a267 1
		debug("Kerberos v4 mk_priv: (%d) %s", r, krb_err_txt[r]);
d272 1
a272 1
	
d275 1
a275 1
	
d280 1
a280 1
	return (1);
d286 1
a286 1
auth_krb4_tgt(Authctxt *authctxt, const char *string)
d289 3
a291 7
	struct passwd *pw;
	
	if ((pw = authctxt->pw) == NULL)
		goto failure;
	
	temporarily_use_uid(pw);
	
d293 3
a295 2
		log("Protocol error decoding Kerberos v4 TGT");
		goto failure;
d299 1
a299 1
	
d301 4
a304 1
		log("Kerberos v4 TGT (%s%s%s@@%s) rejected for %s",
d307 1
a307 1
		goto failure;
d309 3
a311 3
	if (!krb4_init(authctxt))
		goto failure;
	
d313 2
a314 2
		goto failure;
	
d316 4
a319 4
	    creds.session, creds.lifetime, creds.kvno, &creds.ticket_st,
	    creds.issue_date) != KSUCCESS) {
		debug("Kerberos v4 TGT refused: couldn't save credentials");
		goto failure;
d323 4
a326 3
	
	debug("Kerberos v4 TGT accepted (%s%s%s@@%s)",
	    creds.pname, creds.pinst[0] ? "." : "", creds.pinst, creds.realm);
d328 7
a334 7
	
	restore_uid();
	
	return (1);
	
 failure:
	krb4_cleanup_proc(authctxt);
d336 4
a339 3
	restore_uid();
	
	return (0);
d343 1
a343 1
auth_afs_token(Authctxt *authctxt, const char *token_string)
a345 1
	struct passwd *pw;
d347 9
a355 4
	
	if ((pw = authctxt->pw) == NULL)
		return (0);
	
d358 5
a362 1
		return (0);
d366 1
a366 1
	
d371 1
a371 1
	
d373 4
a376 2
		log("AFS token (%s@@%s) rejected for %s",
		    creds.pname, creds.realm, pw->pw_name);
d378 4
a381 1
		return (0);
d383 2
a384 1
	debug("AFS token accepted (%s@@%s)", creds.pname, creds.realm);
d386 4
a389 2
	
	return (1);
@


1.19.2.6
log
@Merge OpenSSH 3.1.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth-krb4.c,v 1.25 2001/12/19 07:18:56 deraadt Exp $");
d52 1
a52 1

d82 1
a82 1

d85 1
a85 1

d88 1
a88 1

d106 1
a106 1

d109 1
a109 1

d131 1
a131 1

d141 1
a141 1

d149 1
a149 1

d189 1
a189 1

d192 1
a192 1

d195 1
a195 1

d223 1
a223 1

d225 1
a225 1

d238 1
a238 1

d246 1
a246 1

d250 1
a250 1

d262 1
a262 1

d272 1
a272 1

d275 1
a275 1

d290 1
a290 1

d293 1
a293 1

d295 1
a295 1

d302 1
a302 1

d311 1
a311 1

d314 1
a314 1

d323 1
a323 1

d327 1
a327 1

d329 1
a329 1

d331 1
a331 1

d336 1
a336 1

d346 1
a346 1

d349 1
a349 1

d356 1
a356 1

d361 1
a361 1

d370 1
a370 1

@


1.18
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d31 1
a31 1
RCSID("$OpenBSD: auth-krb4.c,v 1.17 2000/08/28 03:50:54 deraadt Exp $");
d283 2
d339 1
a339 1
	uid_t uid = pw->pw_uid;
d341 8
d362 2
@


1.17
log
@print uid/gid as unsigned
@
text
@d2 21
a22 2
 *    Dug Song <dugsong@@UMICH.EDU>
 *    Kerberos v4 authentication and ticket-passing routines.
d31 1
a31 1
RCSID("$OpenBSD: auth-krb4.c,v 1.16 2000/08/02 17:27:04 provos Exp $");
@


1.16
log
@disallow kerberos authentication if we can't verify the TGT; from
dugsong@@
kerberos authentication is on by default only if you have a srvtab.
@
text
@d12 1
a12 1
RCSID("$OpenBSD: auth-krb4.c,v 1.15 2000/06/22 23:54:59 djm Exp $");
d157 1
a157 1
		snprintf(ticket, MAXPATHLEN, "%s%d_%d", tkt_root, uid, getpid());
@


1.15
log
@Missing CVS idents; ok markus
@
text
@d12 1
a12 1
RCSID("$OpenBSD$");
d85 1
a85 1
				 * localhost. Allow login.
d90 1
d98 1
a98 1
			 * Allow login if no rcmd service exists, but
d104 1
@


1.14
log
@whitespace cleanup
@
text
@d12 2
@


1.14.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@a11 2
RCSID("$OpenBSD: auth-krb4.c,v 1.17 2000/08/28 03:50:54 deraadt Exp $");

d83 1
a83 1
				 * localhost. Disallow login.
a87 1
				goto kerberos_auth_failure;
d95 1
a95 1
			 * Disallow login if no rcmd service exists, and
a100 1
			goto kerberos_auth_failure;
d153 1
a153 1
		snprintf(ticket, MAXPATHLEN, "%s%u_%d", tkt_root, uid, getpid());
@


1.14.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 2
a3 21
 * Copyright (c) 1999 Dug Song.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d12 1
a12 1
RCSID("$OpenBSD: auth-krb4.c,v 1.19 2000/10/03 18:03:02 markus Exp $");
a263 2
	if (pw == NULL)
		goto auth_kerberos_tgt_failure;
d318 1
a318 1
	uid_t uid;
a319 8
	if (pw == NULL) {
		/* XXX fake protocol error */
		packet_send_debug("Protocol error decoding AFS token");
		packet_start(SSH_SMSG_FAILURE);
		packet_send();
		packet_write_wait();
		return 0;
	}
a332 2
	else
		uid = pw->pw_uid;
@


1.14.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@a25 4
RCSID("$OpenBSD: auth-krb4.c,v 1.23 2001/01/22 08:15:00 markus Exp $");

#include "ssh.h"
#include "ssh1.h"
d28 1
a28 1
#include "log.h"
a29 1
#include "auth.h"
d31 1
a31 3
#ifdef AFS
#include "radix.h"
#endif
d49 1
a49 1
	u_long faddr;
@


1.14.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.13
log
@-Wall
@
text
@d22 1
a22 1
int 
d138 1
a138 1
int 
d182 1
a182 1
int 
d255 1
a255 1
int 
d310 1
a310 1
int 
@


1.12
log
@-pedantic: signed vs. unsigned, void*-arithm, etc
@
text
@d142 1
a142 1
	char *tkt_root = TKT_ROOT;
@


1.11
log
@move skey-auth from auth-passwd.c to auth-skey.c, same for krb4
@
text
@d189 1
d196 1
a196 1
	r = sizeof(local);
d198 1
a198 1
	if (getsockname(s, (struct sockaddr *) & local, &r) < 0)
d200 1
a200 1
	r = sizeof(foreign);
d202 1
a202 1
	if (getpeername(s, (struct sockaddr *) & foreign, &r) < 0) {
@


1.10
log
@much more KNF
@
text
@d10 1
d14 112
@


1.9
log
@KNF part 1
@
text
@d2 3
a4 9

   auth-kerberos.c

   Dug Song <dugsong@@UMICH.EDU>

   Kerberos v4 authentication and ticket-passing routines.

   $Id: auth-krb4.c,v 1.8 1999/11/15 00:42:00 markus Exp $
*/
d104 1
a104 1
			*adat.pinst ? "." : "", adat.pinst, adat.prealm);
d122 1
a122 1
		             schedule, &adat.session, &local, &foreign)) < 0) {
d156 2
a157 1
		    creds.pinst[0] ? "." : "", creds.pinst, creds.realm, pw->pw_name);
d159 2
a160 2
		     creds.pname, creds.pinst[0] ? "." : "", creds.pinst,
				  creds.realm, pw->pw_name);
d170 2
a171 2
			     creds.session, creds.lifetime, creds.kvno,
		             &creds.ticket_st, creds.issue_date) != KSUCCESS) {
d179 2
a180 2
			  creds.service, creds.instance, creds.realm, creds.pname,
			  creds.pinst[0] ? "." : "", creds.pinst, creds.realm);
d220 1
a220 1
				  creds.realm, pw->pw_name);
d228 1
a228 1
			  creds.realm, creds.pname, creds.realm);
@


1.8
log
@disconnect if getpeername() fails
@
text
@d9 1
a9 1
   $Id: auth-krb4.c,v 1.7 1999/11/14 22:58:44 markus Exp $
d23 6
a28 7
  debug("krb4_cleanup_proc called");
  
  if (ticket) {
    (void) dest_tkt();
    xfree(ticket);
    ticket = NULL;
  }
d31 2
a32 1
int krb4_init(uid_t uid)
d34 8
a41 8
  static int cleanup_registered = 0;
  char *tkt_root = TKT_ROOT;
  struct stat st;
  int fd;

  if (!ticket) {
    /* Set unique ticket string manually since we're still root. */
    ticket = xmalloc(MAXPATHLEN);
d43 2
a44 2
    if (lstat("/ticket", &st) != -1)
      tkt_root = "/ticket/";
d46 27
a72 26
    snprintf(ticket, MAXPATHLEN, "%s%d_%d", tkt_root, uid, getpid());
    (void) krb_set_tkt_string(ticket);
  }
  /* Register ticket cleanup in case of fatal error. */
  if (!cleanup_registered) {
    fatal_add_cleanup(krb4_cleanup_proc, NULL);
    cleanup_registered = 1;
  }
  /* Try to create our ticket file. */
  if ((fd = mkstemp(ticket)) != -1) {
    close(fd);
    return 1;
  }
  /* Ticket file exists - make sure user owns it (just passed ticket). */
  if (lstat(ticket, &st) != -1) {
    if (st.st_mode == (S_IFREG|S_IRUSR|S_IWUSR) && st.st_uid == uid)
      return 1;
  }
  /* Failure - cancel cleanup function, leaving bad ticket for inspection. */
  log("WARNING: bad ticket file %s", ticket);
  fatal_remove_cleanup(krb4_cleanup_proc, NULL);
  cleanup_registered = 0;
  xfree(ticket);
  ticket = NULL;
  
  return 0;
d75 2
a76 1
int auth_krb4(const char *server_user, KTEXT auth, char **client)
d78 65
a142 64
  AUTH_DAT adat   = { 0 };
  KTEXT_ST reply;
  char instance[INST_SZ];
  int r, s;
  u_int cksum;
  Key_schedule schedule;
  struct sockaddr_in local, foreign;
  
  s = packet_get_connection_in();
  
  r = sizeof(local);
  memset(&local, 0, sizeof(local));
  if (getsockname(s, (struct sockaddr *) &local, &r) < 0)
    debug("getsockname failed: %.100s", strerror(errno));
  r = sizeof(foreign);
  memset(&foreign, 0, sizeof(foreign));
  if (getpeername(s, (struct sockaddr *)&foreign, &r) < 0) {
    debug("getpeername failed: %.100s", strerror(errno));
    fatal_cleanup();
  }
  
  instance[0] = '*'; instance[1] = 0;
  
  /* Get the encrypted request, challenge, and session key. */
  if ((r = krb_rd_req(auth, KRB4_SERVICE_NAME, instance, 0, &adat, ""))) {
    packet_send_debug("Kerberos V4 krb_rd_req: %.100s", krb_err_txt[r]);
    return 0;
  }
  des_key_sched((des_cblock *)adat.session, schedule);
  
  *client = xmalloc(MAX_K_NAME_SZ);
  (void) snprintf(*client, MAX_K_NAME_SZ, "%s%s%s@@%s", adat.pname,
                  *adat.pinst ? "." : "", adat.pinst, adat.prealm);

  /* Check ~/.klogin authorization now. */
  if (kuserok(&adat, (char *)server_user) != KSUCCESS) {
    packet_send_debug("Kerberos V4 .klogin authorization failed!");
    log("Kerberos V4 .klogin authorization failed for %s to account %s",
	*client, server_user);
    xfree(*client);
    return 0;
  }
  /* Increment the checksum, and return it encrypted with the session key. */
  cksum = adat.checksum + 1;
  cksum = htonl(cksum);
  
  /* If we can't successfully encrypt the checksum, we send back an empty
     message, admitting our failure. */
  if ((r = krb_mk_priv((u_char *)&cksum, reply.dat, sizeof(cksum)+1,
		       schedule, &adat.session, &local, &foreign)) < 0) {
    packet_send_debug("Kerberos V4 mk_priv: (%d) %s", r, krb_err_txt[r]);
    reply.dat[0] = 0;
    reply.length = 0;
  }
  else reply.length = r;
  
  /* Clear session key. */
  memset(&adat.session, 0, sizeof(&adat.session));
  
  packet_start(SSH_SMSG_AUTH_KERBEROS_RESPONSE);
  packet_put_string((char *) reply.dat, reply.length);
  packet_send();
  packet_write_wait();
  return 1;
d147 2
a148 1
int auth_kerberos_tgt(struct passwd *pw, const char *string)
d150 49
a198 49
  CREDENTIALS creds;
  
  if (!radix_to_creds(string, &creds)) {
    log("Protocol error decoding Kerberos V4 tgt");
    packet_send_debug("Protocol error decoding Kerberos V4 tgt");
    goto auth_kerberos_tgt_failure;
  }
  if (strncmp(creds.service, "", 1) == 0) /* backward compatibility */
    strlcpy(creds.service, "krbtgt", sizeof creds.service);
  
  if (strcmp(creds.service, "krbtgt")) {
    log("Kerberos V4 tgt (%s%s%s@@%s) rejected for %s", creds.pname,
	creds.pinst[0] ? "." : "", creds.pinst, creds.realm, pw->pw_name);
    packet_send_debug("Kerberos V4 tgt (%s%s%s@@%s) rejected for %s",
		      creds.pname, creds.pinst[0] ? "." : "", creds.pinst,
		      creds.realm, pw->pw_name);
    goto auth_kerberos_tgt_failure;
  }
  if (!krb4_init(pw->pw_uid))
    goto auth_kerberos_tgt_failure;

  if (in_tkt(creds.pname, creds.pinst) != KSUCCESS)
    goto auth_kerberos_tgt_failure;
  
  if (save_credentials(creds.service, creds.instance, creds.realm,
		       creds.session, creds.lifetime, creds.kvno,
		       &creds.ticket_st, creds.issue_date) != KSUCCESS) {
    packet_send_debug("Kerberos V4 tgt refused: couldn't save credentials");
    goto auth_kerberos_tgt_failure;
  }
  /* Successful authentication, passed all checks. */
  chown(tkt_string(), pw->pw_uid, pw->pw_gid);
  
  packet_send_debug("Kerberos V4 tgt accepted (%s.%s@@%s, %s%s%s@@%s)",
		    creds.service, creds.instance, creds.realm, creds.pname,
		    creds.pinst[0] ? "." : "", creds.pinst, creds.realm);
  memset(&creds, 0, sizeof(creds));
  packet_start(SSH_SMSG_SUCCESS);
  packet_send();
  packet_write_wait();
  return 1;
  
 auth_kerberos_tgt_failure:
  krb4_cleanup_proc(NULL);
  memset(&creds, 0, sizeof(creds));
  packet_start(SSH_SMSG_FAILURE);
  packet_send();
  packet_write_wait();
  return 0;
d201 2
a202 1
int auth_afs_token(struct passwd *pw, const char *token_string)
d204 2
a205 2
  CREDENTIALS creds;
  uid_t uid = pw->pw_uid;
d207 32
a238 32
  if (!radix_to_creds(token_string, &creds)) {
    log("Protocol error decoding AFS token");
    packet_send_debug("Protocol error decoding AFS token");
    packet_start(SSH_SMSG_FAILURE);
    packet_send();
    packet_write_wait();
    return 0;
  }
  if (strncmp(creds.service, "", 1) == 0) /* backward compatibility */
    strlcpy(creds.service, "afs", sizeof creds.service);
  
  if (strncmp(creds.pname, "AFS ID ", 7) == 0)
    uid = atoi(creds.pname + 7);
  
  if (kafs_settoken(creds.realm, uid, &creds)) {
    log("AFS token (%s@@%s) rejected for %s", creds.pname, creds.realm,
	pw->pw_name);
    packet_send_debug("AFS token (%s@@%s) rejected for %s", creds.pname,
		      creds.realm, pw->pw_name);
    memset(&creds, 0, sizeof(creds));
    packet_start(SSH_SMSG_FAILURE);
    packet_send();
    packet_write_wait();
    return 0;
  }
  packet_send_debug("AFS token accepted (%s@@%s, %s@@%s)", creds.service,
		    creds.realm, creds.pname, creds.realm);
  memset(&creds, 0, sizeof(creds));
  packet_start(SSH_SMSG_SUCCESS);
  packet_send();
  packet_write_wait();
  return 1;
@


1.7
log
@missing xfree(*client)
@
text
@d9 1
a9 1
   $Id: auth-krb4.c,v 1.6 1999/11/10 22:24:01 markus Exp $
d92 1
a92 1
  if (getpeername(s, (struct sockaddr *)&foreign, &r) < 0)
d94 2
@


1.6
log
@remove x11- and krb-cleanup from fatal() + krb-cleanup cleanup
@
text
@d9 1
a9 1
   $Id: auth-krb4.c,v 1.5 1999/11/02 19:10:14 markus Exp $
d113 1
@


1.5
log
@remove unused argument. ok dugsong
@
text
@d9 1
a9 1
   $Id: auth-krb4.c,v 1.4 1999/10/01 18:18:40 deraadt Exp $
d18 4
a21 1
int ssh_tf_init(uid_t uid)
d23 12
a34 1
  extern char *ticket;
d38 4
a41 3
  
  /* Set unique ticket string manually since we're still root. */
  ticket = xmalloc(MAXPATHLEN);
d43 2
a44 2
  if (lstat("/ticket", &st) != -1)
    tkt_root = "/ticket/";
d46 12
a57 10
  snprintf(ticket, MAXPATHLEN, "%s%d_%d", tkt_root, uid, getpid());
  (void) krb_set_tkt_string(ticket);

  /* Make sure we own this ticket file, and we created it. */
  if (lstat(ticket, &st) == -1 && errno == ENOENT) {
    /* good, no ticket file exists. create it. */
    if ((fd = open(ticket, O_RDWR|O_CREAT|O_EXCL, 0600)) != -1) {
      close(fd);
      return 1;
    }
d59 2
a60 3
  else {
    /* file exists. make sure server_user owns it (e.g. just passed ticket),
       and that it isn't a symlink, and that it is mode 600. */
d64 1
a64 1
  /* Failure. */
d66 5
d127 1
a127 2
  else
    reply.length = r;
a143 2
  extern char *ticket;
  int r;
d154 3
a156 4
    log("Kerberos V4 tgt (%s%s%s@@%s) rejected for uid %d",
	creds.pname, creds.pinst[0] ? "." : "", creds.pinst, creds.realm,
	pw->pw_uid);
    packet_send_debug("Kerberos V4 tgt (%s%s%s@@%s) rejected for uid %d",
d158 1
a158 1
		      creds.realm, pw->pw_uid);
d161 9
a169 7
  if (!ssh_tf_init(pw->pw_uid) ||
      (r = in_tkt(creds.pname, creds.pinst)) ||
      (r = save_credentials(creds.service, creds.instance, creds.realm,
			    creds.session, creds.lifetime, creds.kvno,
			    &creds.ticket_st, creds.issue_date))) {
    xfree(ticket);
    ticket = NULL;
d174 2
a175 1
  chown(ticket, pw->pw_uid, pw->pw_gid);
d177 3
a179 4
		    creds.service, creds.instance, creds.realm,
		    creds.pname, creds.pinst[0] ? "." : "",
		    creds.pinst, creds.realm);
  
d184 3
a186 2

auth_kerberos_tgt_failure:
d214 5
a218 4
    log("AFS token (%s@@%s) rejected for uid %d", creds.pname,
	creds.realm, uid);
    packet_send_debug("AFS token (%s@@%s) rejected for uid %d", creds.pname,
		      creds.realm, uid);
d226 1
@


1.4
log
@s/long/int/
@
text
@d9 1
a9 1
   $Id: auth-krb4.c,v 1.3 1999/09/29 21:14:15 deraadt Exp $
d174 1
a174 1
int auth_afs_token(char *server_user, uid_t uid, const char *string)
d177 1
d179 1
a179 1
  if (!radix_to_creds(string, &creds)) {
@


1.3
log
@numerous sprintf, strncpy, strcpy cleanups
@
text
@d9 1
a9 1
   $Id: auth-krb4.c,v 1.2 1999/09/29 18:16:18 dugsong Exp $
d59 1
a59 1
  u_long cksum;
@


1.2
log
@update krb4/AFS support to ssh-1.2.27-afs-kerberos-pl1 level, clean up unused variables, update manpages
@
text
@d9 1
a9 1
   $Id$
d133 1
a133 1
    strcpy(creds.service, "krbtgt");
d187 1
a187 1
    strcpy(creds.service, "afs");
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d5 1
a5 1
   Hacked together by Dug Song <dugsong@@umich.edu>.
d7 1
a7 1
   Kerberos authentication and ticket-passing routines.
d9 1
a17 3
#include <sys/param.h>
#include <krb.h>

d24 1
a24 1

d31 1
a31 1
  sprintf(ticket, "%.100s%d_%d", tkt_root, uid, getpid());
d35 1
a35 1
  if (lstat(ticket, &st) < 0 && errno == ENOENT) {
d49 1
a49 1
  log("WARNING: bad ticket file %.100s", ticket);
d77 1
a77 2
  r = krb_rd_req(auth, KRB4_SERVICE_NAME, instance, 0, &adat, "");
  if (r != KSUCCESS) {
d84 2
a85 2
  sprintf(*client, "%.100s%.100s%.100s@@%.100s", adat.pname, *adat.pinst ? "." : "",
		 adat.pinst, adat.prealm);
d90 1
a90 1
    log("Kerberos V4 .klogin authorization failed for %.100s to account %.100s",
d102 1
a102 1
    packet_send_debug("Kerberos V4 mk_priv: (%d) %.100s", r, krb_err_txt[r]);
a120 5
#include <kafs.h>


#ifdef KERBEROS_TGT_PASSING

d136 1
a136 1
    log("Kerberos V4 tgt (%.100s%.100s%.100s@@%.100s) rejected for uid %d",
d139 1
a139 1
    packet_send_debug("Kerberos V4 tgt (%.100s%.100s%.100s@@%.100s) rejected for uid %d",
d146 3
a148 3
      (r = save_credentials(creds.service,creds.instance,creds.realm,
			    creds.session,creds.lifetime,creds.kvno,
			    &creds.ticket_st,creds.issue_date))) {
d156 1
a156 1
  packet_send_debug("Kerberos V4 ticket accepted (%.100s.%.100s@@%.100s, %.100s%.100s%.100s@@%.100s)",
a172 1
#endif /* KERBEROS_TGT_PASSING */
d193 3
a195 3
    log("AFS token (%.100s@@%.100s) rejected for uid %d",
	creds.pname, creds.realm, uid);
    packet_send_debug("AFS token (%.100s@@%.100s) rejected for uid %d", creds.pname,
d202 1
a202 1
  packet_send_debug("AFS token accepted (%.100s@@%.100s, %.100s@@%.100s)", creds.service,
@

