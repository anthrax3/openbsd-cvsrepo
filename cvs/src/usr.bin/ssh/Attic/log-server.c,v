head	1.21;
access;
symbols
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.21
date	2001.03.03.23.59.34;	author markus;	state dead;
branches;
next	1.20;

1.20
date	2001.01.21.19.05.50;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.18.16.20.21;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.07.11.28.05;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.12.20.53.10;	author markus;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2000.09.07.20.27.52;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.20.01.39.42;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.14.10.30.31;	author markus;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2000.03.28.20.26.21;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.27.18.50.09;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.11.24.00.26.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.11.23.22.25.53;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.11.22.21.02.38;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	99.11.14.22.28.44;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	99.11.10.23.36.44;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.11.10.22.24.01;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	99.10.17.20.39.11;	author dugsong;	state Exp;
branches;
next	1.4;

1.4
date	99.09.30.05.11.29;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.09.30.05.03.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.18.16.19;	author dugsong;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.36;	author deraadt;	state Exp;
branches;
next	;

1.14.2.1
date	2000.09.01.18.23.20;	author jason;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2000.11.08.21.30.55;	author jason;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2001.03.12.15.44.11;	author jason;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2001.03.21.18.52.48;	author jason;	state dead;
branches;
next	;

1.17.2.1
date	2001.02.16.20.13.04;	author jason;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2001.02.19.17.19.01;	author jason;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2001.03.21.19.46.25;	author jason;	state dead;
branches;
next	;


desc
@@


1.21
log
@log*.c -> log.c
@
text
@/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Server-side versions of debug(), log(), etc.  These normally send the output
 * to the system log.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "includes.h"
RCSID("$OpenBSD: log-server.c,v 1.20 2001/01/21 19:05:50 markus Exp $");

#include <syslog.h>
#include "packet.h"
#include "xmalloc.h"
#include "log.h"

static LogLevel log_level = SYSLOG_LEVEL_INFO;
static int log_on_stderr = 0;
static int log_facility = LOG_AUTH;

/* Initialize the log.
 *   av0	program name (should be argv[0])
 *   on_stderr	print also on stderr
 *   level	logging level
 */

void
log_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)
{
	switch (level) {
	case SYSLOG_LEVEL_QUIET:
	case SYSLOG_LEVEL_FATAL:
	case SYSLOG_LEVEL_ERROR:
	case SYSLOG_LEVEL_INFO:
	case SYSLOG_LEVEL_VERBOSE:
	case SYSLOG_LEVEL_DEBUG1:
	case SYSLOG_LEVEL_DEBUG2:
	case SYSLOG_LEVEL_DEBUG3:
		log_level = level;
		break;
	default:
		fprintf(stderr, "Unrecognized internal syslog level code %d\n",
			(int) level);
		exit(1);
	}
	switch (facility) {
	case SYSLOG_FACILITY_DAEMON:
		log_facility = LOG_DAEMON;
		break;
	case SYSLOG_FACILITY_USER:
		log_facility = LOG_USER;
		break;
	case SYSLOG_FACILITY_AUTH:
		log_facility = LOG_AUTH;
		break;
	case SYSLOG_FACILITY_LOCAL0:
		log_facility = LOG_LOCAL0;
		break;
	case SYSLOG_FACILITY_LOCAL1:
		log_facility = LOG_LOCAL1;
		break;
	case SYSLOG_FACILITY_LOCAL2:
		log_facility = LOG_LOCAL2;
		break;
	case SYSLOG_FACILITY_LOCAL3:
		log_facility = LOG_LOCAL3;
		break;
	case SYSLOG_FACILITY_LOCAL4:
		log_facility = LOG_LOCAL4;
		break;
	case SYSLOG_FACILITY_LOCAL5:
		log_facility = LOG_LOCAL5;
		break;
	case SYSLOG_FACILITY_LOCAL6:
		log_facility = LOG_LOCAL6;
		break;
	case SYSLOG_FACILITY_LOCAL7:
		log_facility = LOG_LOCAL7;
		break;
	default:
		fprintf(stderr, "Unrecognized internal syslog facility code %d\n",
			(int) facility);
		exit(1);
	}
	log_on_stderr = on_stderr;
}

#define MSGBUFSIZ 1024

void
do_log(LogLevel level, const char *fmt, va_list args)
{
	char msgbuf[MSGBUFSIZ];
	char fmtbuf[MSGBUFSIZ];
	char *txt = NULL;
	int pri = LOG_INFO;
	extern char *__progname;

	if (level > log_level)
		return;
	switch (level) {
	case SYSLOG_LEVEL_FATAL:
		txt = "fatal";
		pri = LOG_CRIT;
		break;
	case SYSLOG_LEVEL_ERROR:
		txt = "error";
		pri = LOG_ERR;
		break;
	case SYSLOG_LEVEL_INFO:
		pri = LOG_INFO;
		break;
	case SYSLOG_LEVEL_VERBOSE:
		pri = LOG_INFO;
		break;
	case SYSLOG_LEVEL_DEBUG1:
		txt = "debug1";
		pri = LOG_DEBUG;
		break;
	case SYSLOG_LEVEL_DEBUG2:
		txt = "debug2";
		pri = LOG_DEBUG;
		break;
	case SYSLOG_LEVEL_DEBUG3:
		txt = "debug3";
		pri = LOG_DEBUG;
		break;
	default:
		txt = "internal error";
		pri = LOG_ERR;
		break;
	}
	if (txt != NULL) {
		snprintf(fmtbuf, sizeof(fmtbuf), "%s: %s", txt, fmt);
		vsnprintf(msgbuf, sizeof(msgbuf), fmtbuf, args);
	} else {
		vsnprintf(msgbuf, sizeof(msgbuf), fmt, args);
	}
	if (log_on_stderr) {
		fprintf(stderr, "%s\n", msgbuf);
	} else {
		openlog(__progname, LOG_PID, log_facility);
		syslog(pri, "%.500s", msgbuf);
		closelog();
	}
}
@


1.20
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log-server.c,v 1.19 2001/01/18 16:20:21 markus Exp $");
@


1.19
log
@log() is at pri=LOG_INFO, since LOG_NOTICE goes to /dev/console on many systems
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log-server.c,v 1.18 2001/01/07 11:28:05 markus Exp $");
d44 1
a44 1
#include "ssh.h"
@


1.18
log
@rename SYSLOG_LEVEL_INFO->SYSLOG_LEVEL_NOTICE
syslog priority changes:
	fatal() LOG_ERR  -> LOG_CRIT
	log()   LOG_INFO -> LOG_NOTICE
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log-server.c,v 1.17 2000/09/12 20:53:10 markus Exp $");
d46 1
a46 1
static LogLevel log_level = SYSLOG_LEVEL_NOTICE;
d63 1
a63 1
	case SYSLOG_LEVEL_NOTICE:
d139 2
a140 2
	case SYSLOG_LEVEL_NOTICE:
		pri = LOG_NOTICE;
@


1.17
log
@multiple debug levels
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log-server.c,v 1.16 2000/09/07 20:27:52 deraadt Exp $");
d46 1
a46 1
static LogLevel log_level = SYSLOG_LEVEL_INFO;
d61 1
d63 1
a63 2
	case SYSLOG_LEVEL_FATAL:
	case SYSLOG_LEVEL_INFO:
d131 4
d139 2
a140 3
	case SYSLOG_LEVEL_FATAL:
		txt = "fatal";
		pri = LOG_ERR;
a141 1
	case SYSLOG_LEVEL_INFO:
@


1.17.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log-server.c,v 1.20 2001/01/21 19:05:50 markus Exp $");
d44 1
a44 1
#include "log.h"
d61 1
a62 1
	case SYSLOG_LEVEL_ERROR:
d131 4
a136 4
		pri = LOG_CRIT;
		break;
	case SYSLOG_LEVEL_ERROR:
		txt = "error";
a139 2
		pri = LOG_INFO;
		break;
@


1.17.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.17.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log-server.c,v 1.17.2.2 2001/02/19 17:19:01 jason Exp $");
@


1.16
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log-server.c,v 1.15 2000/06/20 01:39:42 markus Exp $");
d65 3
a67 1
	case SYSLOG_LEVEL_DEBUG:
d143 10
a152 2
	case SYSLOG_LEVEL_DEBUG:
		txt = "debug";
@


1.15
log
@OpenBSD tag
@
text
@a1 3
 *
 * log-server.c
 *
a2 1
 *
a4 3
 *
 * Created: Mon Mar 20 21:19:30 1995 ylo
 *
d8 28
d39 1
a39 1
RCSID("$OpenBSD: log-server.c,v 1.14 2000/04/14 10:30:31 markus Exp $");
@


1.14
log
@whitespace cleanup
@
text
@d18 1
a18 1
RCSID("$Id: log-server.c,v 1.13 2000/03/28 20:26:21 markus Exp $");
@


1.14.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d18 1
a18 1
RCSID("$OpenBSD: log-server.c,v 1.15 2000/06/20 01:39:42 markus Exp $");
@


1.14.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a14 28
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d18 1
a18 1
RCSID("$OpenBSD: log-server.c,v 1.17 2000/09/12 20:53:10 markus Exp $");
d44 1
a44 3
	case SYSLOG_LEVEL_DEBUG1:
	case SYSLOG_LEVEL_DEBUG2:
	case SYSLOG_LEVEL_DEBUG3:
d120 2
a121 10
	case SYSLOG_LEVEL_DEBUG1:
		txt = "debug1";
		pri = LOG_DEBUG;
		break;
	case SYSLOG_LEVEL_DEBUG2:
		txt = "debug2";
		pri = LOG_DEBUG;
		break;
	case SYSLOG_LEVEL_DEBUG3:
		txt = "debug3";
@


1.14.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log-server.c,v 1.20 2001/01/21 19:05:50 markus Exp $");
d44 1
a44 1
#include "log.h"
d61 1
a62 1
	case SYSLOG_LEVEL_ERROR:
d131 4
a136 4
		pri = LOG_CRIT;
		break;
	case SYSLOG_LEVEL_ERROR:
		txt = "error";
a139 2
		pri = LOG_INFO;
		break;
@


1.14.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log-server.c,v 1.14.2.3 2001/03/12 15:44:11 jason Exp $");
@


1.13
log
@do not log() if debuggin to stderr
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d14 1
a14 1
 * 
d18 1
a18 1
RCSID("$Id: log-server.c,v 1.13 2000/03/22 13:40:45 markus Exp $");
d35 1
a35 1
void 
@


1.12
log
@rename a cpp symbol, to avoid param.h collision
@
text
@d18 1
a18 1
RCSID("$Id: log-server.c,v 1.11 1999/11/24 00:26:02 deraadt Exp $");
d135 1
a135 1
	if (log_on_stderr)
d137 5
a141 3
	openlog(__progname, LOG_PID, log_facility);
	syslog(pri, "%.500s", msgbuf);
	closelog();
@


1.11
log
@much more KNF
@
text
@d18 1
a18 1
RCSID("$Id: log-server.c,v 1.10 1999/11/23 22:25:53 markus Exp $");
d94 1
a94 1
#define MSGBUFSIZE 1024
d99 2
a100 2
	char msgbuf[MSGBUFSIZE];
	char fmtbuf[MSGBUFSIZE];
@


1.10
log
@KNF part 1
@
text
@d2 14
a15 14

log-server.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Mon Mar 20 21:19:30 1995 ylo

Server-side versions of debug(), log(), etc.  These normally send the output
to the system log.

*/
d18 1
a18 1
RCSID("$Id: log-server.c,v 1.9 1999/11/22 21:02:38 markus Exp $");
@


1.9
log
@syslog changes:
* Unified Logmessage for all auth-types, for success and for failed
* Standard connections get only ONE line in the LOG when level==LOG:
  Auth-attempts are logged only, if authentication is:
        a) successfull or
        b) with passwd or
        c) we had more than AUTH_FAIL_LOG failues
* many log() became verbose()
* old behaviour with level=VERBOSE
@
text
@d18 1
a18 1
RCSID("$Id: log-server.c,v 1.8 1999/11/14 22:28:44 markus Exp $");
d30 4
a33 4
     av0	program name (should be argv[0])
     on_stderr	print also on stderr
     level	logging level
     */
d35 2
a36 1
void log_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)
d38 54
a91 59
  
  switch (level)
    {
    case SYSLOG_LEVEL_QUIET:
    case SYSLOG_LEVEL_ERROR:
    case SYSLOG_LEVEL_FATAL:
    case SYSLOG_LEVEL_INFO:
    case SYSLOG_LEVEL_VERBOSE:
    case SYSLOG_LEVEL_DEBUG:
      log_level = level;
      break;
    default:
      fprintf(stderr, "Unrecognized internal syslog level code %d\n",
	      (int)level);
      exit(1);
    }

  switch (facility)
    {
    case SYSLOG_FACILITY_DAEMON:
      log_facility = LOG_DAEMON;
      break;
    case SYSLOG_FACILITY_USER:
      log_facility = LOG_USER;
      break;
    case SYSLOG_FACILITY_AUTH:
      log_facility = LOG_AUTH;
      break;
    case SYSLOG_FACILITY_LOCAL0:
      log_facility = LOG_LOCAL0;
      break;
    case SYSLOG_FACILITY_LOCAL1:
      log_facility = LOG_LOCAL1;
      break;
    case SYSLOG_FACILITY_LOCAL2:
      log_facility = LOG_LOCAL2;
      break;
    case SYSLOG_FACILITY_LOCAL3:
      log_facility = LOG_LOCAL3;
      break;
    case SYSLOG_FACILITY_LOCAL4:
      log_facility = LOG_LOCAL4;
      break;
    case SYSLOG_FACILITY_LOCAL5:
      log_facility = LOG_LOCAL5;
      break;
    case SYSLOG_FACILITY_LOCAL6:
      log_facility = LOG_LOCAL6;
      break;
    case SYSLOG_FACILITY_LOCAL7:
      log_facility = LOG_LOCAL7;
      break;
    default:
      fprintf(stderr, "Unrecognized internal syslog facility code %d\n",
	      (int)facility);
      exit(1);
    }

  log_on_stderr = on_stderr;
d99 41
a139 43
  char msgbuf[MSGBUFSIZE];
  char fmtbuf[MSGBUFSIZE];
  char *txt = NULL;
  int pri = LOG_INFO;
  extern char *__progname;

  if (level > log_level)
    return;
  switch (level)
    {
    case SYSLOG_LEVEL_ERROR:
      txt = "error";
      pri = LOG_ERR;
      break;
    case SYSLOG_LEVEL_FATAL:
      txt = "fatal";
      pri = LOG_ERR;
      break;
    case SYSLOG_LEVEL_INFO:
    case SYSLOG_LEVEL_VERBOSE:
      pri = LOG_INFO;
      break;
    case SYSLOG_LEVEL_DEBUG:
      txt = "debug";
      pri = LOG_DEBUG;
      break;
    default:
      txt = "internal error";
      pri = LOG_ERR;
      break;
    }

  if (txt != NULL) {
    snprintf(fmtbuf, sizeof(fmtbuf), "%s: %s", txt, fmt);
    vsnprintf(msgbuf, sizeof(msgbuf), fmtbuf, args);
  }else{
    vsnprintf(msgbuf, sizeof(msgbuf), fmt, args);
  }
  if (log_on_stderr)
    fprintf(stderr, "%s\n", msgbuf);
  openlog(__progname, LOG_PID, log_facility);
  syslog(pri, "%.500s", msgbuf);
  closelog();
@


1.8
log
@avoid extra fd per sshd, from millert@@
@
text
@d18 1
a18 1
RCSID("$Id: log-server.c,v 1.7 1999/11/10 23:36:44 markus Exp $");
d44 1
a44 1
    case SYSLOG_LEVEL_CHAT:
d122 1
a122 3
      pri = LOG_INFO;
      break;
    case SYSLOG_LEVEL_CHAT:
@


1.7
log
@add LogLevel {QUIET, FATAL, ERROR, INFO, CHAT, DEBUG} to ssh/sshd,
obsoletes QuietMode and FascistLogging in sshd.
@
text
@d18 1
a18 1
RCSID("$Id: log-server.c,v 1.5 1999/10/17 20:39:11 dugsong Exp $");
d27 1
a36 1
  int log_facility;
a95 2
  closelog(); /* Close any previous log. */
  openlog(av0, LOG_PID, log_facility);
d107 1
d145 1
d147 1
@


1.6
log
@remove x11- and krb-cleanup from fatal() + krb-cleanup cleanup
@
text
@d25 1
a25 2
static int log_debug = 0;
static int log_quiet = 0;
d31 1
a31 2
     debug	send debugging messages to system log
     quiet	don\'t log anything
d34 1
a34 2
void log_init(char *av0, int on_stderr, int debug, int quiet, 
	      SyslogFacility facility)
d38 16
a94 2
  log_debug = debug;
  log_quiet = quiet;
d102 2
a103 5
#define DECL_MSGBUF char msgbuf[MSGBUFSIZE]

/* Log this message (information that usually should go to the log). */

void log(const char *fmt, ...)
d105 4
a108 13
  va_list args;
  DECL_MSGBUF;
  if (log_quiet)
    return;
  va_start(args, fmt);
  vsnprintf(msgbuf, MSGBUFSIZE, fmt, args);
  va_end(args);
  if (log_on_stderr)
    fprintf(stderr, "log: %s\n", msgbuf);
  syslog(LOG_INFO, "log: %.500s", msgbuf);
}

/* Debugging messages that should not be logged during normal operation. */
d110 1
a110 5
void debug(const char *fmt, ...)
{
  va_list args;
  DECL_MSGBUF;
  if (!log_debug || log_quiet)
d112 1
a112 53
  va_start(args, fmt);
  vsnprintf(msgbuf, MSGBUFSIZE, fmt, args);
  va_end(args);
  if (log_on_stderr)
    fprintf(stderr, "debug: %s\n", msgbuf);
  syslog(LOG_DEBUG, "debug: %.500s", msgbuf);
}

/* Error messages that should be logged. */

void error(const char *fmt, ...)
{
  va_list args;
  DECL_MSGBUF;
  if (log_quiet)
    return;
  va_start(args, fmt);
  vsnprintf(msgbuf, MSGBUFSIZE, fmt, args);
  va_end(args);
  if (log_on_stderr)
    fprintf(stderr, "error: %s\n", msgbuf);
  syslog(LOG_ERR, "error: %.500s", msgbuf);
}

struct fatal_cleanup
{
  struct fatal_cleanup *next;
  void (*proc)(void *);
  void *context;
};

static struct fatal_cleanup *fatal_cleanups = NULL;

/* Registers a cleanup function to be called by fatal() before exiting. */

void fatal_add_cleanup(void (*proc)(void *), void *context)
{
  struct fatal_cleanup *cu;

  cu = xmalloc(sizeof(*cu));
  cu->proc = proc;
  cu->context = context;
  cu->next = fatal_cleanups;
  fatal_cleanups = cu;
}

/* Removes a cleanup frunction to be called at fatal(). */

void fatal_remove_cleanup(void (*proc)(void *context), void *context)
{
  struct fatal_cleanup **cup, *cu;
  
  for (cup = &fatal_cleanups; *cup; cup = &cu->next)
d114 22
a135 7
      cu = *cup;
      if (cu->proc == proc && cu->context == context)
	{
	  *cup = cu->next;
	  xfree(cu);
	  return;
	}
a136 3
  fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx\n",
	(unsigned long)proc, (unsigned long)context);
}
d138 5
a142 16
/* Fatal messages.  This function never returns. */

void fatal(const char *fmt, ...)
{
  va_list args;
  struct fatal_cleanup *cu, *next_cu;
  static int fatal_called = 0;
  DECL_MSGBUF;

  if (!log_quiet) {
    va_start(args, fmt);
    vsnprintf(msgbuf, MSGBUFSIZE, fmt, args);
    va_end(args);
    if (log_on_stderr)
      fprintf(stderr, "fatal: %s\n", msgbuf);
    syslog(LOG_ERR, "fatal: %.500s", msgbuf);
d144 3
a146 15

  if (fatal_called)
    exit(1);
  fatal_called = 1;

  /* Call cleanup functions. */
  for (cu = fatal_cleanups; cu; cu = next_cu)
    {
      next_cu = cu->next;
      debug("Calling cleanup 0x%lx(0x%lx)",
	    (unsigned long)cu->proc, (unsigned long)cu->context);
      (*cu->proc)(cu->context);
    }

  exit(1);
@


1.5
log
@-Wall, get rid of unused headers/vars
@
text
@d18 1
a18 1
RCSID("$Id: log-server.c,v 1.4 1999/09/30 05:11:29 deraadt Exp $");
a189 3
#if defined(KRB4)
  extern char *ticket;
#endif /* KRB4 */
d192 8
a199 8
  if (log_quiet)
    exit(1);
  va_start(args, fmt);
  vsnprintf(msgbuf, MSGBUFSIZE, fmt, args);
  va_end(args);
  if (log_on_stderr)
    fprintf(stderr, "fatal: %s\n", msgbuf);
  syslog(LOG_ERR, "fatal: %.500s", msgbuf);
a212 15
#if defined(KRB4)
  /* If you forwarded a ticket you get one shot for proper
     authentication. */
  /* If tgt was passed unlink file */
  if (ticket)
    {
      if (strcmp(ticket,"none"))
	unlink(ticket);
      else
	ticket = NULL;
    }
#endif /* KRB4 */

  /* If local XAUTHORITY was created, remove it. */
  if (xauthfile) unlink(xauthfile);
@


1.4
log
@do not bother with dinosaur pacification
@
text
@d18 1
a18 1
RCSID("$Id: log-server.c,v 1.3 1999/09/30 05:03:04 deraadt Exp $");
a20 1
#include <sys/syslog.h>
@


1.3
log
@cull more ancient garbage from pre-POSIX days
@
text
@d18 1
a18 1
RCSID("$Id: log-server.c,v 1.2 1999/09/29 18:16:19 dugsong Exp $");
a91 1
#ifdef HAVE_VSNPRINTF
a92 4
#else
static char msgbuf[MSGBUFSIZE];
#define DECL_MSGBUF
#endif
@


1.2
log
@update krb4/AFS support to ssh-1.2.27-afs-kerberos-pl1 level, clean up unused variables, update manpages
@
text
@d18 1
a18 1
RCSID("$Id: log-server.c,v 1.1 1999/09/26 20:53:36 deraadt Exp $");
a20 1
#ifdef NEED_SYS_SYSLOG_H
a21 1
#endif /* NEED_SYS_SYSLOG_H */
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d18 1
a18 1
RCSID("$Id: log-server.c,v 1.7 1999/05/04 11:58:48 bg Exp $");
d231 1
a231 2
	/* ticket -> FILE:path */
	unlink(ticket + 5);
@

