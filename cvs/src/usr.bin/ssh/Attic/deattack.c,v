head	1.34;
access;
symbols
	OPENBSD_6_1:1.32.0.12
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.32.0.10
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.6
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.30.0.36
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.34
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.30
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.28
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.26
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.24
	OPENBSD_5_0:1.30.0.22
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.20
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.18
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.14
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.16
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.12
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.10
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.8
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.6
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.4
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.8
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.6
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.8
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.18.0.6
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.34
date	2017.05.01.09.27.45;	author djm;	state dead;
branches;
next	1.33;
commitid	2RnrVyYg4aG6rnQ4;

1.33
date	2017.04.30.23.26.16;	author djm;	state Exp;
branches;
next	1.32;
commitid	ur12vOD9kYPHm9ch;

1.32
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	cBx23BaCk6gYBpRj;

1.31
date	2015.01.19.19.52.16;	author markus;	state Exp;
branches;
next	1.30;
commitid	UHlhoIB5NMb8eAPm;

1.30
date	2006.09.16.19.53.37;	author djm;	state Exp;
branches;
next	1.29;

1.29
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.30.09.58.15;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.25.01.13.23;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.22.21.27.15;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.20.18.41.54;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2006.02.07.03.59.20;	author stevesk;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2003.09.18.08.49.45;	author markus;	state Exp;
branches
	1.19.8.1;
next	1.18;

1.18
date	2002.03.04.17.27.39;	author stevesk;	state Exp;
branches
	1.18.6.1
	1.18.8.1;
next	1.17;

1.17
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.05.03.56.39;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.23.15.12.18;	author itojun;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.03.01.02.45.10;	author deraadt;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.01.21.19.05.48;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.19.23.17.56;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.31.13.18.53;	author markus;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.09.07.20.27.51;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.19.02.17.12;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.20.01.39.41;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.11.24.00.26.01;	author deraadt;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.11.23.22.25.53;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	99.11.02.19.42.35;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	99.10.05.22.18.52;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	99.10.05.02.35.57;	author dugsong;	state Exp;
branches;
next	1.1;

1.1
date	99.10.05.01.23.54;	author dugsong;	state Exp;
branches;
next	;

1.6.2.1
date	2000.09.01.18.23.19;	author jason;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.11.08.21.30.43;	author jason;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.03.12.15.44.10;	author jason;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.03.21.18.52.44;	author jason;	state Exp;
branches;
next	;

1.10.2.1
date	2001.02.16.20.13.00;	author jason;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.02.19.17.18.52;	author jason;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.03.21.19.46.24;	author jason;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.05.07.21.09.29;	author jason;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.13.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	;

1.14.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	;

1.18.6.1
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.18.8.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	;

1.19.8.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.20.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.34
log
@don't know why cvs didn't exterminate these the first time around,
I use rm -f and everuthing...

pointed out by sobrado@@
@
text
@@


1.33
log
@remove the (in)famous SSHv1 CRC compensation attack detector.

Despite your cameo in The Matrix movies, you will not be missed.

ok markus
@
text
@@


1.32
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@a0 163
/* $OpenBSD: deattack.c,v 1.31 2015/01/19 19:52:16 markus Exp $ */
/*
 * Cryptographic attack detector for ssh - source code
 *
 * Copyright (c) 1998 CORE SDI S.A., Buenos Aires, Argentina.
 *
 * All rights reserved. Redistribution and use in source and binary
 * forms, with or without modification, are permitted provided that
 * this copyright notice is retained.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES ARE DISCLAIMED. IN NO EVENT SHALL CORE SDI S.A. BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY OR
 * CONSEQUENTIAL DAMAGES RESULTING FROM THE USE OR MISUSE OF THIS
 * SOFTWARE.
 *
 * Ariel Futoransky <futo@@core-sdi.com>
 * <http://www.core-sdi.com>
 */

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include "deattack.h"
#include "crc32.h"
#include "sshbuf.h"
#include "misc.h"

/*
 * CRC attack detection has a worst-case behaviour that is O(N^3) over
 * the number of identical blocks in a packet. This behaviour can be 
 * exploited to create a limited denial of service attack. 
 * 
 * However, because we are dealing with encrypted data, identical
 * blocks should only occur every 2^35 maximally-sized packets or so. 
 * Consequently, we can detect this DoS by looking for identical blocks
 * in a packet.
 *
 * The parameter below determines how many identical blocks we will
 * accept in a single packet, trading off between attack detection and
 * likelihood of terminating a legitimate connection. A value of 32 
 * corresponds to an average of 2^40 messages before an attack is
 * misdetected
 */
#define MAX_IDENTICAL	32

/* SSH Constants */
#define SSH_MAXBLOCKS	(32 * 1024)
#define SSH_BLOCKSIZE	(8)

/* Hashing constants */
#define HASH_MINSIZE	(8 * 1024)
#define HASH_ENTRYSIZE	(2)
#define HASH_FACTOR(x)	((x)*3/2)
#define HASH_UNUSEDCHAR	(0xff)
#define HASH_UNUSED	(0xffff)
#define HASH_IV		(0xfffe)

#define HASH_MINBLOCKS	(7*SSH_BLOCKSIZE)


/* Hash function (Input keys are cipher results) */
#define HASH(x)		PEEK_U32(x)

#define CMP(a, b)	(memcmp(a, b, SSH_BLOCKSIZE))

static void
crc_update(u_int32_t *a, u_int32_t b)
{
	b ^= *a;
	*a = ssh_crc32((u_char *)&b, sizeof(b));
}

/* detect if a block is used in a particular pattern */
static int
check_crc(const u_char *S, const u_char *buf, u_int32_t len)
{
	u_int32_t crc;
	const u_char *c;

	crc = 0;
	for (c = buf; c < buf + len; c += SSH_BLOCKSIZE) {
		if (!CMP(S, c)) {
			crc_update(&crc, 1);
			crc_update(&crc, 0);
		} else {
			crc_update(&crc, 0);
			crc_update(&crc, 0);
		}
	}
	return crc == 0;
}

void
deattack_init(struct deattack_ctx *dctx)
{
	bzero(dctx, sizeof(*dctx));
	dctx->n = HASH_MINSIZE / HASH_ENTRYSIZE;
}

/* Detect a crc32 compensation attack on a packet */
int
detect_attack(struct deattack_ctx *dctx, const u_char *buf, u_int32_t len)
{
	u_int32_t i, j, l, same;
	u_int16_t *tmp;
	const u_char *c, *d;

	if (len > (SSH_MAXBLOCKS * SSH_BLOCKSIZE) ||
	    len % SSH_BLOCKSIZE != 0)
		return DEATTACK_ERROR;
	for (l = dctx->n; l < HASH_FACTOR(len / SSH_BLOCKSIZE); l = l << 2)
		;

	if (dctx->h == NULL) {
		if ((dctx->h = calloc(l, HASH_ENTRYSIZE)) == NULL)
			return DEATTACK_ERROR;
		dctx->n = l;
	} else {
		if (l > dctx->n) {
			if ((tmp = reallocarray(dctx->h, l, HASH_ENTRYSIZE))
			    == NULL) {
				free(dctx->h);
				dctx->h = NULL;
				return DEATTACK_ERROR;
			}
			dctx->h = tmp;
			dctx->n = l;
		}
	}

	if (len <= HASH_MINBLOCKS) {
		for (c = buf; c < buf + len; c += SSH_BLOCKSIZE) {
			for (d = buf; d < c; d += SSH_BLOCKSIZE) {
				if (!CMP(c, d)) {
					if ((check_crc(c, buf, len)))
						return DEATTACK_DETECTED;
					else
						break;
				}
			}
		}
		return DEATTACK_OK;
	}
	memset(dctx->h, HASH_UNUSEDCHAR, dctx->n * HASH_ENTRYSIZE);

	for (c = buf, same = j = 0; c < (buf + len); c += SSH_BLOCKSIZE, j++) {
		for (i = HASH(c) & (dctx->n - 1); dctx->h[i] != HASH_UNUSED;
		    i = (i + 1) & (dctx->n - 1)) {
			if (!CMP(c, buf + dctx->h[i] * SSH_BLOCKSIZE)) {
				if (++same > MAX_IDENTICAL)
					return DEATTACK_DOS_DETECTED;
				if (check_crc(c, buf, len))
					return DEATTACK_DETECTED;
				else
					break;
			}
		}
		dctx->h[i] = j;
	}
	return DEATTACK_OK;
}
@


1.31
log
@update packet.c & isolate, introduce struct ssh
a) switch packet.c to buffer api and isolate per-connection info into struct ssh
b) (de)serialization of the state is moved from monitor to packet.c
c) the old packet.c API is implemented in opacket.[ch]
d) compress.c/h is removed and integrated into packet.c
with and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: deattack.c,v 1.30 2006/09/16 19:53:37 djm Exp $ */
a20 1
#include <sys/param.h>
@


1.30
log
@limit maximum work performed by the CRC compensation attack detector,
problem reported by Tavis Ormandy, Google Security Team;
ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: deattack.c,v 1.29 2006/08/03 03:34:42 deraadt Exp $ */
d21 1
a21 2
#include <sys/types.h>

d24 1
a24 1
#include <stdarg.h>
a25 1
#include "xmalloc.h"
a26 1
#include "log.h"
d28 1
d65 1
a65 1
#define HASH(x)		get_u32(x)
d78 1
a78 1
check_crc(u_char *S, u_char *buf, u_int32_t len)
d81 1
a81 1
	u_char *c;
d93 1
a93 1
	return (crc == 0);
d96 6
d105 1
a105 1
detect_attack(u_char *buf, u_int32_t len)
d107 3
a109 6
	static u_int16_t *h = (u_int16_t *) NULL;
	static u_int32_t n = HASH_MINSIZE / HASH_ENTRYSIZE;
	u_int32_t i, j;
	u_int32_t l, same;
	u_char *c;
	u_char *d;
d112 3
a114 4
	    len % SSH_BLOCKSIZE != 0) {
		fatal("detect_attack: bad length %d", len);
	}
	for (l = n; l < HASH_FACTOR(len / SSH_BLOCKSIZE); l = l << 2)
d117 4
a120 4
	if (h == NULL) {
		debug("Installing crc compensation attack detector.");
		h = (u_int16_t *) xcalloc(l, HASH_ENTRYSIZE);
		n = l;
d122 9
a130 3
		if (l > n) {
			h = (u_int16_t *)xrealloc(h, l, HASH_ENTRYSIZE);
			n = l;
d139 1
a139 1
						return (DEATTACK_DETECTED);
d145 1
a145 1
		return (DEATTACK_OK);
d147 1
a147 1
	memset(h, HASH_UNUSEDCHAR, n * HASH_ENTRYSIZE);
d150 3
a152 3
		for (i = HASH(c) & (n - 1); h[i] != HASH_UNUSED;
		    i = (i + 1) & (n - 1)) {
			if (!CMP(c, buf + h[i] * SSH_BLOCKSIZE)) {
d154 1
a154 1
					return (DEATTACK_DOS_DETECTED);
d156 1
a156 1
					return (DEATTACK_DETECTED);
d161 1
a161 1
		h[i] = j;
d163 1
a163 1
	return (DEATTACK_OK);
@


1.29
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: deattack.c,v 1.28 2006/07/22 20:48:23 stevesk Exp $ */
d33 18
d106 1
a106 1
	u_int32_t l;
d143 1
a143 1
	for (c = buf, j = 0; c < (buf + len); c += SSH_BLOCKSIZE, j++) {
d147 2
@


1.28
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: deattack.c,v 1.27 2006/03/30 09:58:15 djm Exp $ */
d21 1
a21 1
#include "includes.h"
d24 2
d27 1
a30 1
#include "xmalloc.h"
@


1.27
log
@replace {GET,PUT}_XXBIT macros with functionally similar functions,
silencing a heap of lint warnings. also allows them to use
__bounded__ checking which can't be applied to macros; requested
by and feedback from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: deattack.c,v 1.26 2006/03/25 13:17:01 djm Exp $ */
d22 2
@


1.26
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a25 1
#include "getput.h"
d27 1
d45 1
a45 1
#define HASH(x)		GET_32BIT(x)
@


1.25
log
@change OpenSSH's xrealloc() function from being xrealloc(p, new_size) to
xrealloc(p, new_nmemb, new_itemsize).

realloc is particularly prone to integer overflows because it is almost
always allocating "n * size" bytes, so this is a far safer API;
ok deraadt@@
@
text
@d1 1
@


1.24
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d100 1
a100 1
			h = (u_int16_t *) xrealloc(h, l * HASH_ENTRYSIZE);
@


1.23
log
@remove IV support from the CRC attack detector, OpenSSH has never used
it - it only applied to IDEA-CFB, which we don't support.
prompted by NetBSD Coverity report via elad AT netbsd.org;
feedback markus@@ "nuke it" deraadt@@
@
text
@d96 1
a96 1
		h = (u_int16_t *) xmalloc(l * HASH_ENTRYSIZE);
@


1.22
log
@spacing
@
text
@d57 1
a57 2
check_crc(u_char *S, u_char *buf, u_int32_t len,
	  u_char *IV)
a62 4
	if (IV && !CMP(S, IV)) {
		crc_update(&crc, 1);
		crc_update(&crc, 0);
	}
d78 1
a78 1
detect_attack(u_char *buf, u_int32_t len, u_char *IV)
a106 6
			if (IV && (!CMP(c, IV))) {
				if ((check_crc(c, buf, len, IV)))
					return (DEATTACK_DETECTED);
				else
					break;
			}
d109 1
a109 1
					if ((check_crc(c, buf, len, IV)))
a119 3
	if (IV)
		h[HASH(IV) & (n - 1)] = HASH_IV;

d123 2
a124 9
			if (h[i] == HASH_IV) {
				if (!CMP(c, IV)) {
					if (check_crc(c, buf, len, IV))
						return (DEATTACK_DETECTED);
					else
						break;
				}
			} else if (!CMP(c, buf + h[i] * SSH_BLOCKSIZE)) {
				if (check_crc(c, buf, len, IV))
@


1.21
log
@RCSID() can die
@
text
@d52 1
a52 1
	*a = ssh_crc32((u_char *) &b, sizeof(b));
@


1.20
log
@duplicate #include
@
text
@a20 1
RCSID("$OpenBSD: deattack.c,v 1.19 2003/09/18 08:49:45 markus Exp $");
@


1.20.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: deattack.c,v 1.30 2006/09/16 19:53:37 djm Exp $ */
d20 2
a21 1
#include <sys/types.h>
a22 5
#include <string.h>
#include <stdio.h>
#include <stdarg.h>

#include "xmalloc.h"
d26 2
a27 19
#include "misc.h"

/*
 * CRC attack detection has a worst-case behaviour that is O(N^3) over
 * the number of identical blocks in a packet. This behaviour can be 
 * exploited to create a limited denial of service attack. 
 * 
 * However, because we are dealing with encrypted data, identical
 * blocks should only occur every 2^35 maximally-sized packets or so. 
 * Consequently, we can detect this DoS by looking for identical blocks
 * in a packet.
 *
 * The parameter below determines how many identical blocks we will
 * accept in a single packet, trading off between attack detection and
 * likelihood of terminating a legitimate connection. A value of 32 
 * corresponds to an average of 2^40 messages before an attack is
 * misdetected
 */
#define MAX_IDENTICAL	32
d45 1
a45 1
#define HASH(x)		get_u32(x)
d53 1
a53 1
	*a = ssh_crc32((u_char *)&b, sizeof(b));
d58 2
a59 1
check_crc(u_char *S, u_char *buf, u_int32_t len)
d65 4
d84 1
a84 1
detect_attack(u_char *buf, u_int32_t len)
d89 1
a89 1
	u_int32_t l, same;
d102 1
a102 1
		h = (u_int16_t *) xcalloc(l, HASH_ENTRYSIZE);
d106 1
a106 1
			h = (u_int16_t *)xrealloc(h, l, HASH_ENTRYSIZE);
d113 6
d121 1
a121 1
					if ((check_crc(c, buf, len)))
d132 4
a135 1
	for (c = buf, same = j = 0; c < (buf + len); c += SSH_BLOCKSIZE, j++) {
d138 9
a146 4
			if (!CMP(c, buf + h[i] * SSH_BLOCKSIZE)) {
				if (++same > MAX_IDENTICAL)
					return (DEATTACK_DOS_DETECTED);
				if (check_crc(c, buf, len))
@


1.19
log
@more buffer allocation fixes; from Solar Designer; CAN-2003-0682; ok millert@@
@
text
@d21 1
a21 1
RCSID("$OpenBSD: deattack.c,v 1.18 2002/03/04 17:27:39 stevesk Exp $");
a27 1
#include "deattack.h"
@


1.19.8.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: deattack.c,v 1.30 2006/09/16 19:53:37 djm Exp $ */
d20 2
a21 1
#include <sys/types.h>
a22 5
#include <string.h>
#include <stdio.h>
#include <stdarg.h>

#include "xmalloc.h"
d26 3
a28 19
#include "misc.h"

/*
 * CRC attack detection has a worst-case behaviour that is O(N^3) over
 * the number of identical blocks in a packet. This behaviour can be 
 * exploited to create a limited denial of service attack. 
 * 
 * However, because we are dealing with encrypted data, identical
 * blocks should only occur every 2^35 maximally-sized packets or so. 
 * Consequently, we can detect this DoS by looking for identical blocks
 * in a packet.
 *
 * The parameter below determines how many identical blocks we will
 * accept in a single packet, trading off between attack detection and
 * likelihood of terminating a legitimate connection. A value of 32 
 * corresponds to an average of 2^40 messages before an attack is
 * misdetected
 */
#define MAX_IDENTICAL	32
d46 1
a46 1
#define HASH(x)		get_u32(x)
d54 1
a54 1
	*a = ssh_crc32((u_char *)&b, sizeof(b));
d59 2
a60 1
check_crc(u_char *S, u_char *buf, u_int32_t len)
d66 4
d85 1
a85 1
detect_attack(u_char *buf, u_int32_t len)
d90 1
a90 1
	u_int32_t l, same;
d103 1
a103 1
		h = (u_int16_t *) xcalloc(l, HASH_ENTRYSIZE);
d107 1
a107 1
			h = (u_int16_t *)xrealloc(h, l, HASH_ENTRYSIZE);
d114 6
d122 1
a122 1
					if ((check_crc(c, buf, len)))
d133 4
a136 1
	for (c = buf, same = j = 0; c < (buf + len); c += SSH_BLOCKSIZE, j++) {
d139 9
a147 4
			if (!CMP(c, buf + h[i] * SSH_BLOCKSIZE)) {
				if (++same > MAX_IDENTICAL)
					return (DEATTACK_DOS_DETECTED);
				if (check_crc(c, buf, len))
@


1.18
log
@$OpenBSD$ and RCSID() cleanup: don't use RCSID() in .h files; add
missing RCSID() to .c files and remove dup /*$OpenBSD$*/ from .c
files.  ok markus@@
@
text
@d21 1
a21 1
RCSID("$OpenBSD:$");
d103 1
a104 1
		h = (u_int16_t *) xmalloc(n * HASH_ENTRYSIZE);
d107 1
a108 1
			h = (u_int16_t *) xrealloc(h, n * HASH_ENTRYSIZE);
@


1.18.6.1
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d21 1
a21 1
RCSID("$OpenBSD: deattack.c,v 1.19 2003/09/18 08:49:45 markus Exp $");
a102 1
		h = (u_int16_t *) xmalloc(l * HASH_ENTRYSIZE);
d104 1
a106 1
			h = (u_int16_t *) xrealloc(h, l * HASH_ENTRYSIZE);
d108 1
@


1.18.8.1
log
@upgrade to OpenSSH 3.8
@
text
@d21 1
a21 1
RCSID("$OpenBSD: deattack.c,v 1.19 2003/09/18 08:49:45 markus Exp $");
a102 1
		h = (u_int16_t *) xmalloc(l * HASH_ENTRYSIZE);
d104 1
a106 1
			h = (u_int16_t *) xrealloc(h, l * HASH_ENTRYSIZE);
d108 1
@


1.17
log
@basic KNF done while i was looking for something else
@
text
@a0 2
/*	$OpenBSD: deattack.c,v 1.16 2001/12/05 03:56:39 itojun Exp $	*/

d21 2
@


1.16
log
@make it compile with more strict prototype checking
@
text
@d1 1
a1 1
/*	$OpenBSD: deattack.c,v 1.15 2001/11/19 19:02:16 mpech Exp $	*/
d40 1
a40 1
#define HASH_IV     	(0xfffe)
d138 1
a138 1
		     i = (i + 1) & (n - 1)) {
@


1.15
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: deattack.c,v 1.14 2001/06/23 15:12:18 itojun Exp $	*/
d28 1
@


1.14
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d1 1
a1 1
/*	$OpenBSD: deattack.c,v 1.13 2001/03/01 02:45:10 deraadt Exp $	*/
d88 1
a88 1
	register u_int32_t i, j;
d90 1
a90 1
	register u_char *c;
@


1.14.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d1 2
a22 2
RCSID("$OpenBSD: deattack.c,v 1.18 2002/03/04 17:27:39 stevesk Exp $");

a27 1
#include "deattack.h"
d39 1
a39 1
#define HASH_IV		(0xfffe)
d88 1
a88 1
	u_int32_t i, j;
d90 1
a90 1
	u_char *c;
d137 1
a137 1
		    i = (i + 1) & (n - 1)) {
@


1.13
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: deattack.c,v 1.12 2001/01/21 19:05:48 markus Exp $	*/
d49 1
a49 2

void
d57 1
a57 1
int
@


1.13.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d1 1
a1 1
/*	$OpenBSD: deattack.c,v 1.14 2001/06/23 15:12:18 itojun Exp $	*/
d49 2
a50 1
static void
d58 1
a58 1
static int
@


1.13.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d1 2
a22 2
RCSID("$OpenBSD: deattack.c,v 1.18 2002/03/04 17:27:39 stevesk Exp $");

a27 1
#include "deattack.h"
d39 1
a39 1
#define HASH_IV		(0xfffe)
d88 1
a88 1
	u_int32_t i, j;
d90 1
a90 1
	u_char *c;
d137 1
a137 1
		    i = (i + 1) & (n - 1)) {
@


1.12
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d1 1
a1 1
/*	$OpenBSD: deattack.c,v 1.11 2000/12/19 23:17:56 markus Exp $	*/
d47 1
a47 1
#define CMP(a,b)	(memcmp(a, b, SSH_BLOCKSIZE))
@


1.11
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d1 1
a1 1
/*	$OpenBSD: deattack.c,v 1.10 2000/10/31 13:18:53 markus Exp $	*/
d24 1
a24 1
#include "ssh.h"
@


1.10
log
@so that large packets do not wrap "n"; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: deattack.c,v 1.9 2000/09/07 20:27:51 deraadt Exp $	*/
d54 1
a54 1
	*a = ssh_crc32((unsigned char *) &b, sizeof(b));
d59 2
a60 2
check_crc(unsigned char *S, unsigned char *buf, u_int32_t len,
	  unsigned char *IV)
d63 1
a63 1
	unsigned char *c;
d85 1
a85 1
detect_attack(unsigned char *buf, u_int32_t len, unsigned char *IV)
d91 2
a92 2
	register unsigned char *c;
	unsigned char *d;
@


1.10.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d1 1
a1 1
/*	$OpenBSD: deattack.c,v 1.12 2001/01/21 19:05:48 markus Exp $	*/
d24 1
a24 1
#include "log.h"
d54 1
a54 1
	*a = ssh_crc32((u_char *) &b, sizeof(b));
d59 2
a60 2
check_crc(u_char *S, u_char *buf, u_int32_t len,
	  u_char *IV)
d63 1
a63 1
	u_char *c;
d85 1
a85 1
detect_attack(u_char *buf, u_int32_t len, u_char *IV)
d91 2
a92 2
	register u_char *c;
	u_char *d;
@


1.10.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.10.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: deattack.c,v 1.13 2001/03/01 02:45:10 deraadt Exp $	*/
d47 1
a47 1
#define CMP(a, b)	(memcmp(a, b, SSH_BLOCKSIZE))
@


1.10.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.10.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: deattack.c,v 1.14 2001/06/23 15:12:18 itojun Exp $	*/
d49 2
a50 1
static void
d58 1
a58 1
static int
@


1.10.2.6
log
@Merge OpenSSH 3.1.
@
text
@d1 2
a22 2
RCSID("$OpenBSD: deattack.c,v 1.18 2002/03/04 17:27:39 stevesk Exp $");

a27 1
#include "deattack.h"
d39 1
a39 1
#define HASH_IV		(0xfffe)
d88 1
a88 1
	u_int32_t i, j;
d90 1
a90 1
	u_char *c;
d137 1
a137 1
		    i = (i + 1) & (n - 1)) {
@


1.9
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d1 1
a1 1
/*	$OpenBSD: deattack.c,v 1.8 2000/08/19 02:17:12 deraadt Exp $	*/
d88 1
a88 1
	static u_int16_t n = HASH_MINSIZE / HASH_ENTRYSIZE;
@


1.8
log
@rename crc32() to ssh_crc32() to avoid zlib name clash.  do not move to
libz crc32 function yet, because it has ugly "long"'s in it; oneill@@cs.sfu.ca
@
text
@d1 2
a3 1
 * $OpenBSD: deattack.c,v 1.7 2000/06/20 01:39:41 markus Exp $
@


1.7
log
@OpenBSD tag
@
text
@d2 1
a2 1
 * $OpenBSD: deattack.c,v 1.6 1999/11/24 00:26:01 deraadt Exp $
d53 1
a53 1
	*a = crc32((unsigned char *) &b, sizeof(b));
@


1.6
log
@much more KNF
@
text
@d2 1
a2 1
 * $Id: deattack.c,v 1.5 1999/11/23 22:25:53 markus Exp $
@


1.6.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d2 1
a2 1
 * $OpenBSD: deattack.c,v 1.8 2000/08/19 02:17:12 deraadt Exp $
d53 1
a53 1
	*a = ssh_crc32((unsigned char *) &b, sizeof(b));
@


1.6.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@a0 2
/*	$OpenBSD: deattack.c,v 1.10 2000/10/31 13:18:53 markus Exp $	*/

d2 1
d87 1
a87 1
	static u_int32_t n = HASH_MINSIZE / HASH_ENTRYSIZE;
@


1.6.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d1 1
a1 1
/*	$OpenBSD: deattack.c,v 1.12 2001/01/21 19:05:48 markus Exp $	*/
d24 1
a24 1
#include "log.h"
d54 1
a54 1
	*a = ssh_crc32((u_char *) &b, sizeof(b));
d59 2
a60 2
check_crc(u_char *S, u_char *buf, u_int32_t len,
	  u_char *IV)
d63 1
a63 1
	u_char *c;
d85 1
a85 1
detect_attack(u_char *buf, u_int32_t len, u_char *IV)
d91 2
a92 2
	register u_char *c;
	u_char *d;
@


1.6.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: deattack.c,v 1.13 2001/03/01 02:45:10 deraadt Exp $	*/
d47 1
a47 1
#define CMP(a, b)	(memcmp(a, b, SSH_BLOCKSIZE))
@


1.5
log
@KNF part 1
@
text
@d2 1
a2 1
 * $Id: deattack.c,v 1.4 1999/11/02 19:42:35 markus Exp $
d18 2
a19 1
 * <http://www.core-sdi.com> */
@


1.4
log
@replace assert() with error, fatal or packet_disconnect
@
text
@d2 1
a2 1
 * $Id: deattack.c,v 1.3 1999/10/05 22:18:52 markus Exp $
d28 2
a29 2
#define SSH_MAXBLOCKS (32 * 1024)
#define SSH_BLOCKSIZE (8)
d32 6
a37 6
#define HASH_MINSIZE (8 * 1024)
#define HASH_ENTRYSIZE (2)
#define HASH_FACTOR(x) ((x)*3/2)
#define HASH_UNUSEDCHAR (0xff)
#define HASH_UNUSED (0xffff)
#define HASH_IV     (0xfffe)
d39 1
a39 1
#define HASH_MINBLOCKS  (7*SSH_BLOCKSIZE)
d43 1
a43 1
#define HASH(x) GET_32BIT(x)
d45 1
a45 1
#define CMP(a,b) (memcmp(a, b, SSH_BLOCKSIZE))
d49 1
a49 1
crc_update(u_int32_t * a, u_int32_t b)
d51 2
a52 2
  b ^= *a;
  *a = crc32((unsigned char *) &b, sizeof(b));
d55 1
a55 5
/*
   check_crc
   detects if a block is used in a particular pattern
 */

d57 2
a58 1
check_crc(unsigned char *S, unsigned char *buf, u_int32_t len, unsigned char *IV)
d60 2
a61 2
  u_int32_t          crc;
  unsigned char  *c;
d63 15
a77 20
  crc = 0;
  if (IV && !CMP(S, IV))
  {
    crc_update(&crc, 1);
    crc_update(&crc, 0);
  }
  for (c = buf; c < buf + len; c += SSH_BLOCKSIZE)
  {
    if (!CMP(S, c))
    {
      crc_update(&crc, 1);
      crc_update(&crc, 0);
    } else
    {
      crc_update(&crc, 0);
      crc_update(&crc, 0);
    }
  }

  return (crc == 0);
d81 1
a81 4
/*
   detect_attack
   Detects a crc32 compensation attack on a packet
 */
d85 13
a97 83
  static u_int16_t  *h = (u_int16_t *) NULL;
  static u_int16_t   n = HASH_MINSIZE / HASH_ENTRYSIZE;
  register u_int32_t i, j;
  u_int32_t          l;
  register unsigned char *c;
  unsigned char  *d;

  if (len > (SSH_MAXBLOCKS * SSH_BLOCKSIZE) ||
      len % SSH_BLOCKSIZE != 0) {
    fatal("detect_attack: bad length %d", len);
  }

  for (l = n; l < HASH_FACTOR(len / SSH_BLOCKSIZE); l = l << 2);

  if (h == NULL)
  {
    debug("Installing crc compensation attack detector.");
    n = l;
    h = (u_int16_t *) xmalloc(n * HASH_ENTRYSIZE);
  } else
  {
    if (l > n)
    {
      n = l;
      h = (u_int16_t *) xrealloc(h, n * HASH_ENTRYSIZE);
    }
  }


  if (len <= HASH_MINBLOCKS)
  {
    for (c = buf; c < buf + len; c += SSH_BLOCKSIZE)
    {
      if (IV && (!CMP(c, IV)))
      {
	if ((check_crc(c, buf, len, IV)))
	  return (DEATTACK_DETECTED);
	else
	  break;
      }
      for (d = buf; d < c; d += SSH_BLOCKSIZE)
      {
	if (!CMP(c, d))
	{
	  if ((check_crc(c, buf, len, IV)))
	    return (DEATTACK_DETECTED);
	  else
	    break;
	}
      }
    }
    return (DEATTACK_OK);
  }
  memset(h, HASH_UNUSEDCHAR, n * HASH_ENTRYSIZE);

  if (IV)
    h[HASH(IV) & (n - 1)] = HASH_IV;


  for (c = buf, j = 0; c < (buf + len); c += SSH_BLOCKSIZE, j++)
  {
    for (i = HASH(c) & (n - 1); h[i] != HASH_UNUSED;
	 i = (i + 1) & (n - 1))
    {
      if (h[i] == HASH_IV)
      {
	if (!CMP(c, IV))
	{
	  if (check_crc(c, buf, len, IV))
	    return (DEATTACK_DETECTED);
	  else
	    break;
	}
      } else if (!CMP(c, buf + h[i] * SSH_BLOCKSIZE))
      {
	if (check_crc(c, buf, len, IV))
	  return (DEATTACK_DETECTED);
	else
	  break;
      }
    }
    h[i] = j;
  }
d99 55
a153 1
  return (DEATTACK_OK);
@


1.3
log
@move auth-sockets to private dir
delete minfd residua
@
text
@d2 1
a2 1
 * $Id: deattack.c,v 1.2 1999/10/05 02:35:57 dugsong Exp $
d103 4
a106 3

  assert(len <= (SSH_MAXBLOCKS * SSH_BLOCKSIZE));
  assert(len % SSH_BLOCKSIZE == 0);
@


1.2
log
@include licensing info
@
text
@d2 1
a2 1
 * $Id: deattack.c,v 1.1 1999/10/05 01:23:54 dugsong Exp $
d23 1
@


1.1
log
@crc32 compensation attack fix from CORE-SDI. "it's not crypto..." -- deraadt@@
@
text
@d2 17
a18 4
 * $Id: deattack.c,v 1.9 1998/06/27 00:02:22 futo Exp $ Cryptographic attack
 * detector for ssh - source code (C)1998 CORE-SDI, Buenos Aires Argentina
 * Ariel Futoransky(futo@@core-sdi.com) <http://www.core-sdi.com>
 */
@

