head	1.62;
access;
symbols
	OPENBSD_6_1:1.60.0.4
	OPENBSD_6_1_BASE:1.60
	OPENBSD_6_0:1.59.0.4
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.58.0.2
	OPENBSD_5_9_BASE:1.58
	OPENBSD_5_8:1.53.0.2
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.51.0.4
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.45.0.10
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.8
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.6
	OPENBSD_5_0:1.45.0.4
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.2
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.44.0.2
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.39.0.16
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.12
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.39.0.10
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.8
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.6
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.39.0.2
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.39.0.4
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.32.0.4
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.31.0.6
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.31.0.4
	OPENBSD_3_6_BASE:1.31
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	OPENBSD_3_3:1.28.0.2
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_8:1.6.0.2;
locks; strict;
comment	@ * @;


1.62
date	2017.07.01.13.50.45;	author djm;	state Exp;
branches;
next	1.61;
commitid	jGKycoTTk52hb7Q7;

1.61
date	2017.05.07.23.15.59;	author djm;	state Exp;
branches;
next	1.60;
commitid	uIPOxK9LAWTB4bJn;

1.60
date	2016.09.12.23.39.34;	author djm;	state Exp;
branches;
next	1.59;
commitid	iCcFAjoNKm0iqrGH;

1.59
date	2016.04.21.06.08.02;	author djm;	state Exp;
branches;
next	1.58;
commitid	TEz9L872jtCmA2c4;

1.58
date	2015.12.11.04.21.12;	author mmcc;	state Exp;
branches;
next	1.57;
commitid	frWDG3VpknGQboCf;

1.57
date	2015.12.10.17.08.40;	author mmcc;	state Exp;
branches;
next	1.56;
commitid	qST12VGCwbX5zIfM;

1.56
date	2015.12.07.20.04.09;	author markus;	state Exp;
branches;
next	1.55;
commitid	aB7LutqkxfrBQUpy;

1.55
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.54;
commitid	K3glY441IowbrjDE;

1.54
date	2015.09.09.00.52.44;	author djm;	state Exp;
branches;
next	1.53;
commitid	7pkI8QCAs17HGhr3;

1.53
date	2015.06.15.01.32.50;	author djm;	state Exp;
branches;
next	1.52;
commitid	yNtGBRPF6ifQw78h;

1.52
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.51;
commitid	1h9UxAQmwdaqUzyX;

1.51
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.50;

1.50
date	2014.01.09.23.20.00;	author djm;	state Exp;
branches;
next	1.49;

1.49
date	2013.12.30.23.52.27;	author djm;	state Exp;
branches;
next	1.48;

1.48
date	2013.12.27.22.37.18;	author djm;	state Exp;
branches;
next	1.47;

1.47
date	2013.12.27.22.30.17;	author djm;	state Exp;
branches;
next	1.46;

1.46
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.45;

1.45
date	2010.08.31.09.58.37;	author djm;	state Exp;
branches;
next	1.44;

1.44
date	2010.07.16.14.07.35;	author djm;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.13.23.13.16;	author djm;	state Exp;
branches;
next	1.42;

1.42
date	2010.07.13.11.52.06;	author djm;	state Exp;
branches;
next	1.41;

1.41
date	2010.04.16.01.47.26;	author djm;	state Exp;
branches;
next	1.40;

1.40
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.39;

1.39
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.25.01.13.23;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.20.18.26.55;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.20.17.17.23;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2005.06.17.02.44.33;	author djm;	state Exp;
branches
	1.32.2.1
	1.32.4.1;
next	1.31;

1.31
date	2003.11.10.16.23.41;	author jakob;	state Exp;
branches
	1.31.4.1
	1.31.6.1;
next	1.30;

1.30
date	2003.06.18.11.28.11;	author markus;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2003.06.16.08.22.35;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.12.09.33.04;	author markus;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2002.11.21.23.03.51;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.08.27.17.13.56;	author stevesk;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2002.08.02.22.20.30;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.02.21.23.41;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.04.10.41.47;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.04.04.15.33;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.23.03.30.17;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.10.16.53.06;	author stevesk;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.31.13.20.50;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.02.20.11.38;	author markus;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2002.03.29.19.18.33;	author stevesk;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.24.19.14.59;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.25.21.42.11;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.05.10.06.12;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.10.13.22.42;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.07.22.10.28;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.07.21.40.21;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.17.19.27.15;	author stevesk;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.06.06.23.13.54;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.27.10.57.00;	author markus;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.03.27.10.34.08;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.08.19.30.52;	author itojun;	state Exp;
branches
	1.6.2.1
	1.6.4.1;
next	1.5;

1.5
date	2001.01.21.19.05.58;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.16.19.20.06;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.06.11.23.27;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.19.23.17.58;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.12.19.50.38;	author markus;	state Exp;
branches;
next	;

1.6.2.1
date	2001.02.16.20.13.19;	author jason;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.02.19.17.19.31;	author jason;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.03.21.19.46.30;	author jason;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.05.07.21.09.36;	author jason;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2001.11.15.22.50.30;	author miod;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.6.4.1
date	2001.03.12.15.44.16;	author jason;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.03.21.18.53.10;	author jason;	state Exp;
branches;
next	;

1.8.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.11.15.22.51.15;	author miod;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2002.06.02.22.56.11;	author miod;	state Exp;
branches;
next	;

1.10.2.1
date	2001.11.14.03.24.39;	author jason;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2002.06.22.07.23.18;	author miod;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2002.06.26.18.22.36;	author miod;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.18.2.1
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.10.11.14.51.53;	author miod;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2003.04.03.22.35.18;	author miod;	state Exp;
branches;
next	;

1.26.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2003.09.16.21.20.28;	author brad;	state Exp;
branches;
next	;

1.28.2.1
date	2003.09.16.20.50.44;	author brad;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.30.2.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	;

1.31.4.1
date	2005.09.02.03.45.01;	author brad;	state Exp;
branches;
next	;

1.31.6.1
date	2005.09.04.18.40.10;	author brad;	state Exp;
branches;
next	;

1.32.2.1
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	;

1.32.4.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	;


desc
@@


1.62
log
@remove post-SSHv1 removal dead code from rsa.c and merge the
remaining bit that it still used into ssh-rsa.c; ok markus
@
text
@/* $OpenBSD: ssh-rsa.c,v 1.61 2017/05/07 23:15:59 djm Exp $ */
/*
 * Copyright (c) 2000, 2003 Markus Friedl <markus@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <openssl/evp.h>
#include <openssl/err.h>

#include <string.h>

#include "sshbuf.h"
#include "compat.h"
#include "ssherr.h"
#define SSHKEY_INTERNAL
#include "sshkey.h"
#include "digest.h"

static int openssh_RSA_verify(int, u_char *, size_t, u_char *, size_t, RSA *);

static const char *
rsa_hash_alg_ident(int hash_alg)
{
	switch (hash_alg) {
	case SSH_DIGEST_SHA1:
		return "ssh-rsa";
	case SSH_DIGEST_SHA256:
		return "rsa-sha2-256";
	case SSH_DIGEST_SHA512:
		return "rsa-sha2-512";
	}
	return NULL;
}

static int
rsa_hash_alg_from_ident(const char *ident)
{
	if (strcmp(ident, "ssh-rsa") == 0 ||
	    strcmp(ident, "ssh-rsa-cert-v01@@openssh.com") == 0)
		return SSH_DIGEST_SHA1;
	if (strcmp(ident, "rsa-sha2-256") == 0)
		return SSH_DIGEST_SHA256;
	if (strcmp(ident, "rsa-sha2-512") == 0)
		return SSH_DIGEST_SHA512;
	return -1;
}

static int
rsa_hash_alg_nid(int type)
{
	switch (type) {
	case SSH_DIGEST_SHA1:
		return NID_sha1;
	case SSH_DIGEST_SHA256:
		return NID_sha256;
	case SSH_DIGEST_SHA512:
		return NID_sha512;
	default:
		return -1;
	}
}

/* calculate p-1 and q-1 */
int
ssh_rsa_generate_additional_parameters(struct sshkey *key)
{
	RSA *rsa;
	BIGNUM *aux = NULL;
	BN_CTX *ctx = NULL;
	int r;

	if (key == NULL || key->rsa == NULL ||
	    sshkey_type_plain(key->type) != KEY_RSA)
		return SSH_ERR_INVALID_ARGUMENT;

	if ((ctx = BN_CTX_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((aux = BN_new()) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	rsa = key->rsa;

	if ((BN_sub(aux, rsa->q, BN_value_one()) == 0) ||
	    (BN_mod(rsa->dmq1, rsa->d, aux, ctx) == 0) ||
	    (BN_sub(aux, rsa->p, BN_value_one()) == 0) ||
	    (BN_mod(rsa->dmp1, rsa->d, aux, ctx) == 0)) {
		r = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}
	r = 0;
 out:
	BN_clear_free(aux);
	BN_CTX_free(ctx);
	return r;
}

/* RSASSA-PKCS1-v1_5 (PKCS #1 v2.0 signature) with SHA1 */
int
ssh_rsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
    const u_char *data, size_t datalen, const char *alg_ident)
{
	u_char digest[SSH_DIGEST_MAX_LENGTH], *sig = NULL;
	size_t slen;
	u_int dlen, len;
	int nid, hash_alg, ret = SSH_ERR_INTERNAL_ERROR;
	struct sshbuf *b = NULL;

	if (lenp != NULL)
		*lenp = 0;
	if (sigp != NULL)
		*sigp = NULL;

	if (alg_ident == NULL || strlen(alg_ident) == 0)
		hash_alg = SSH_DIGEST_SHA1;
	else
		hash_alg = rsa_hash_alg_from_ident(alg_ident);
	if (key == NULL || key->rsa == NULL || hash_alg == -1 ||
	    sshkey_type_plain(key->type) != KEY_RSA)
		return SSH_ERR_INVALID_ARGUMENT;
	if (BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE)
		return SSH_ERR_KEY_LENGTH;
	slen = RSA_size(key->rsa);
	if (slen <= 0 || slen > SSHBUF_MAX_BIGNUM)
		return SSH_ERR_INVALID_ARGUMENT;

	/* hash the data */
	nid = rsa_hash_alg_nid(hash_alg);
	if ((dlen = ssh_digest_bytes(hash_alg)) == 0)
		return SSH_ERR_INTERNAL_ERROR;
	if ((ret = ssh_digest_memory(hash_alg, data, datalen,
	    digest, sizeof(digest))) != 0)
		goto out;

	if ((sig = malloc(slen)) == NULL) {
		ret = SSH_ERR_ALLOC_FAIL;
		goto out;
	}

	if (RSA_sign(nid, digest, dlen, sig, &len, key->rsa) != 1) {
		ret = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}
	if (len < slen) {
		size_t diff = slen - len;
		memmove(sig + diff, sig, len);
		explicit_bzero(sig, diff);
	} else if (len > slen) {
		ret = SSH_ERR_INTERNAL_ERROR;
		goto out;
	}
	/* encode signature */
	if ((b = sshbuf_new()) == NULL) {
		ret = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((ret = sshbuf_put_cstring(b, rsa_hash_alg_ident(hash_alg))) != 0 ||
	    (ret = sshbuf_put_string(b, sig, slen)) != 0)
		goto out;
	len = sshbuf_len(b);
	if (sigp != NULL) {
		if ((*sigp = malloc(len)) == NULL) {
			ret = SSH_ERR_ALLOC_FAIL;
			goto out;
		}
		memcpy(*sigp, sshbuf_ptr(b), len);
	}
	if (lenp != NULL)
		*lenp = len;
	ret = 0;
 out:
	explicit_bzero(digest, sizeof(digest));
	if (sig != NULL) {
		explicit_bzero(sig, slen);
		free(sig);
	}
	sshbuf_free(b);
	return ret;
}

int
ssh_rsa_verify(const struct sshkey *key,
    const u_char *sig, size_t siglen, const u_char *data, size_t datalen)
{
	char *ktype = NULL;
	int hash_alg, ret = SSH_ERR_INTERNAL_ERROR;
	size_t len, diff, modlen, dlen;
	struct sshbuf *b = NULL;
	u_char digest[SSH_DIGEST_MAX_LENGTH], *osigblob, *sigblob = NULL;

	if (key == NULL || key->rsa == NULL ||
	    sshkey_type_plain(key->type) != KEY_RSA ||
	    sig == NULL || siglen == 0)
		return SSH_ERR_INVALID_ARGUMENT;
	if (BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE)
		return SSH_ERR_KEY_LENGTH;

	if ((b = sshbuf_from(sig, siglen)) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if (sshbuf_get_cstring(b, &ktype, NULL) != 0) {
		ret = SSH_ERR_INVALID_FORMAT;
		goto out;
	}
	if ((hash_alg = rsa_hash_alg_from_ident(ktype)) == -1) {
		ret = SSH_ERR_KEY_TYPE_MISMATCH;
		goto out;
	}
	if (sshbuf_get_string(b, &sigblob, &len) != 0) {
		ret = SSH_ERR_INVALID_FORMAT;
		goto out;
	}
	if (sshbuf_len(b) != 0) {
		ret = SSH_ERR_UNEXPECTED_TRAILING_DATA;
		goto out;
	}
	/* RSA_verify expects a signature of RSA_size */
	modlen = RSA_size(key->rsa);
	if (len > modlen) {
		ret = SSH_ERR_KEY_BITS_MISMATCH;
		goto out;
	} else if (len < modlen) {
		diff = modlen - len;
		osigblob = sigblob;
		if ((sigblob = realloc(sigblob, modlen)) == NULL) {
			sigblob = osigblob; /* put it back for clear/free */
			ret = SSH_ERR_ALLOC_FAIL;
			goto out;
		}
		memmove(sigblob + diff, sigblob, len);
		explicit_bzero(sigblob, diff);
		len = modlen;
	}
	if ((dlen = ssh_digest_bytes(hash_alg)) == 0) {
		ret = SSH_ERR_INTERNAL_ERROR;
		goto out;
	}
	if ((ret = ssh_digest_memory(hash_alg, data, datalen,
	    digest, sizeof(digest))) != 0)
		goto out;

	ret = openssh_RSA_verify(hash_alg, digest, dlen, sigblob, len,
	    key->rsa);
 out:
	if (sigblob != NULL) {
		explicit_bzero(sigblob, len);
		free(sigblob);
	}
	free(ktype);
	sshbuf_free(b);
	explicit_bzero(digest, sizeof(digest));
	return ret;
}

/*
 * See:
 * http://www.rsasecurity.com/rsalabs/pkcs/pkcs-1/
 * ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.asn
 */

/*
 * id-sha1 OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
 *	oiw(14) secsig(3) algorithms(2) 26 }
 */
static const u_char id_sha1[] = {
	0x30, 0x21, /* type Sequence, length 0x21 (33) */
	0x30, 0x09, /* type Sequence, length 0x09 */
	0x06, 0x05, /* type OID, length 0x05 */
	0x2b, 0x0e, 0x03, 0x02, 0x1a, /* id-sha1 OID */
	0x05, 0x00, /* NULL */
	0x04, 0x14  /* Octet string, length 0x14 (20), followed by sha1 hash */
};

/*
 * See http://csrc.nist.gov/groups/ST/crypto_apps_infra/csor/algorithms.html
 * id-sha256 OBJECT IDENTIFIER ::= { joint-iso-itu-t(2) country(16) us(840)
 *      organization(1) gov(101) csor(3) nistAlgorithm(4) hashAlgs(2)
 *      id-sha256(1) }
 */
static const u_char id_sha256[] = {
	0x30, 0x31, /* type Sequence, length 0x31 (49) */
	0x30, 0x0d, /* type Sequence, length 0x0d (13) */
	0x06, 0x09, /* type OID, length 0x09 */
	0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, /* id-sha256 */
	0x05, 0x00, /* NULL */
	0x04, 0x20  /* Octet string, length 0x20 (32), followed by sha256 hash */
};

/*
 * See http://csrc.nist.gov/groups/ST/crypto_apps_infra/csor/algorithms.html
 * id-sha512 OBJECT IDENTIFIER ::= { joint-iso-itu-t(2) country(16) us(840)
 *      organization(1) gov(101) csor(3) nistAlgorithm(4) hashAlgs(2)
 *      id-sha256(3) }
 */
static const u_char id_sha512[] = {
	0x30, 0x51, /* type Sequence, length 0x51 (81) */
	0x30, 0x0d, /* type Sequence, length 0x0d (13) */
	0x06, 0x09, /* type OID, length 0x09 */
	0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, /* id-sha512 */
	0x05, 0x00, /* NULL */
	0x04, 0x40  /* Octet string, length 0x40 (64), followed by sha512 hash */
};

static int
rsa_hash_alg_oid(int hash_alg, const u_char **oidp, size_t *oidlenp)
{
	switch (hash_alg) {
	case SSH_DIGEST_SHA1:
		*oidp = id_sha1;
		*oidlenp = sizeof(id_sha1);
		break;
	case SSH_DIGEST_SHA256:
		*oidp = id_sha256;
		*oidlenp = sizeof(id_sha256);
		break;
	case SSH_DIGEST_SHA512:
		*oidp = id_sha512;
		*oidlenp = sizeof(id_sha512);
		break;
	default:
		return SSH_ERR_INVALID_ARGUMENT;
	}
	return 0;
}

static int
openssh_RSA_verify(int hash_alg, u_char *hash, size_t hashlen,
    u_char *sigbuf, size_t siglen, RSA *rsa)
{
	size_t rsasize = 0, oidlen = 0, hlen = 0;
	int ret, len, oidmatch, hashmatch;
	const u_char *oid = NULL;
	u_char *decrypted = NULL;

	if ((ret = rsa_hash_alg_oid(hash_alg, &oid, &oidlen)) != 0)
		return ret;
	ret = SSH_ERR_INTERNAL_ERROR;
	hlen = ssh_digest_bytes(hash_alg);
	if (hashlen != hlen) {
		ret = SSH_ERR_INVALID_ARGUMENT;
		goto done;
	}
	rsasize = RSA_size(rsa);
	if (rsasize <= 0 || rsasize > SSHBUF_MAX_BIGNUM ||
	    siglen == 0 || siglen > rsasize) {
		ret = SSH_ERR_INVALID_ARGUMENT;
		goto done;
	}
	if ((decrypted = malloc(rsasize)) == NULL) {
		ret = SSH_ERR_ALLOC_FAIL;
		goto done;
	}
	if ((len = RSA_public_decrypt(siglen, sigbuf, decrypted, rsa,
	    RSA_PKCS1_PADDING)) < 0) {
		ret = SSH_ERR_LIBCRYPTO_ERROR;
		goto done;
	}
	if (len < 0 || (size_t)len != hlen + oidlen) {
		ret = SSH_ERR_INVALID_FORMAT;
		goto done;
	}
	oidmatch = timingsafe_bcmp(decrypted, oid, oidlen) == 0;
	hashmatch = timingsafe_bcmp(decrypted + oidlen, hash, hlen) == 0;
	if (!oidmatch || !hashmatch) {
		ret = SSH_ERR_SIGNATURE_INVALID;
		goto done;
	}
	ret = 0;
done:
	if (decrypted) {
		explicit_bzero(decrypted, rsasize);
		free(decrypted);
	}
	return ret;
}
@


1.61
log
@Refuse RSA keys <1024 bits in length. Improve reporting for keys that
do not meet this requirement. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.60 2016/09/12 23:39:34 djm Exp $ */
d74 35
@


1.60
log
@handle certs in rsa_hash_alg_from_ident(), saving an unnecessary
special case elsewhere.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.59 2016/04/21 06:08:02 djm Exp $ */
d97 1
a97 2
	    sshkey_type_plain(key->type) != KEY_RSA ||
	    BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE)
d99 2
a170 1
	    BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE ||
d173 2
@


1.59
log
@make argument == NULL tests more consistent
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.58 2015/12/11 04:21:12 mmcc Exp $ */
d51 2
a52 1
	if (strcmp(ident, "ssh-rsa") == 0)
d92 1
a92 2
	if (alg_ident == NULL || strlen(alg_ident) == 0 ||
	    strncmp(alg_ident, "ssh-rsa-cert", strlen("ssh-rsa-cert")) == 0)
@


1.58
log
@Remove NULL-checks before sshbuf_free().

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.57 2015/12/10 17:08:40 mmcc Exp $ */
d170 2
a171 1
	    BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE)
@


1.57
log
@Remove NULL-checks before free().

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.56 2015/12/07 20:04:09 markus Exp $ */
d154 1
a154 2
	if (b != NULL)
		sshbuf_free(b);
d224 1
a224 2
	if (b != NULL)
		sshbuf_free(b);
@


1.56
log
@stricter encoding type checks for ssh-rsa; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.55 2015/12/04 16:41:28 markus Exp $ */
d224 1
a224 2
	if (ktype != NULL)
		free(ktype);
@


1.55
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.54 2015/09/09 00:52:44 djm Exp $ */
a50 2
	if (ident == NULL || strlen(ident) == 0)
		return SSH_DIGEST_SHA1;
a56 2
	if (strncmp(ident, "ssh-rsa-cert", strlen("ssh-rsa-cert")) == 0)
		return SSH_DIGEST_SHA1;
d91 5
a95 1
	hash_alg = rsa_hash_alg_from_ident(alg_ident);
@


1.54
log
@openssh_RSA_verify return type is int, so don't make it size_t within
the function itself with only negative numbers or zero assigned to it.
bz#2460
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.53 2015/06/15 01:32:50 djm Exp $ */
d34 45
d82 1
a82 1
    const u_char *data, size_t datalen, u_int compat)
a83 1
	int hash_alg;
d87 1
a87 1
	int nid, ret = SSH_ERR_INTERNAL_ERROR;
d95 4
a98 2
	if (key == NULL || key->rsa == NULL ||
	    sshkey_type_plain(key->type) != KEY_RSA)
d105 1
a105 2
	hash_alg = SSH_DIGEST_SHA1;
	nid = NID_sha1;
d134 1
a134 1
	if ((ret = sshbuf_put_cstring(b, "ssh-rsa")) != 0 ||
d161 1
a161 2
    const u_char *signature, size_t signaturelen,
    const u_char *data, size_t datalen, u_int compat)
d174 1
a174 1
	if ((b = sshbuf_from(signature, signaturelen)) == NULL)
d180 1
a180 1
	if (strcmp("ssh-rsa", ktype) != 0) {
a208 1
	hash_alg = SSH_DIGEST_SHA1;
d237 1
d251 52
d312 2
d315 1
a315 9
	switch (hash_alg) {
	case SSH_DIGEST_SHA1:
		oid = id_sha1;
		oidlen = sizeof(id_sha1);
		hlen = 20;
		break;
	default:
		goto done;
	}
@


1.53
log
@return failure on RSA signature error; reported by Albert S
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.52 2014/06/24 01:13:21 djm Exp $ */
d211 2
a212 2
	size_t ret, rsasize = 0, oidlen = 0, hlen = 0;
	int len, oidmatch, hashmatch;
@


1.52
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.51 2014/02/02 03:44:31 djm Exp $ */
d111 1
a111 1
	return 0;
@


1.51
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.50 2014/01/09 23:20:00 djm Exp $ */
d25 1
a25 4
#include "xmalloc.h"
#include "log.h"
#include "buffer.h"
#include "key.h"
d27 3
a29 2
#include "misc.h"
#include "ssh.h"
d32 1
a32 1
static int openssh_RSA_verify(int, u_char *, u_int, u_char *, u_int, RSA *);
d36 2
a37 2
ssh_rsa_sign(const Key *key, u_char **sigp, u_int *lenp,
    const u_char *data, u_int datalen)
d40 17
a56 10
	u_char digest[SSH_DIGEST_MAX_LENGTH], *sig;
	u_int slen, dlen, len;
	int ok, nid;
	Buffer b;

	if (key == NULL || key_type_plain(key->type) != KEY_RSA ||
	    key->rsa == NULL) {
		error("%s: no RSA key", __func__);
		return -1;
	}
d61 9
a69 3
	if ((dlen = ssh_digest_bytes(hash_alg)) == 0) {
		error("%s: bad hash algorithm %d", __func__, hash_alg);
		return -1;
a70 11
	if (ssh_digest_memory(hash_alg, data, datalen,
	    digest, sizeof(digest)) != 0) {
		error("%s: ssh_digest_memory failed", __func__);
		return -1;
	}

	slen = RSA_size(key->rsa);
	sig = xmalloc(slen);

	ok = RSA_sign(nid, digest, dlen, sig, &len, key->rsa);
	explicit_bzero(digest, sizeof(digest));
d72 3
a74 7
	if (ok != 1) {
		int ecode = ERR_get_error();

		error("%s: RSA_sign failed: %s", __func__,
		    ERR_error_string(ecode, NULL));
		free(sig);
		return -1;
d77 1
a77 2
		u_int diff = slen - len;
		debug("slen %u > len %u", slen, len);
d81 2
a82 3
		error("%s: slen %u slen2 %u", __func__, slen, len);
		free(sig);
		return -1;
d85 15
a99 4
	buffer_init(&b);
	buffer_put_cstring(&b, "ssh-rsa");
	buffer_put_string(&b, sig, slen);
	len = buffer_len(&b);
d102 6
a107 3
	if (sigp != NULL) {
		*sigp = xmalloc(len);
		memcpy(*sigp, buffer_ptr(&b), len);
d109 2
a110 4
	buffer_free(&b);
	explicit_bzero(sig, slen);
	free(sig);

d115 3
a117 2
ssh_rsa_verify(const Key *key, const u_char *signature, u_int signaturelen,
    const u_char *data, u_int datalen)
d119 17
a135 22
	Buffer b;
	int hash_alg;
	char *ktype;
	u_char digest[SSH_DIGEST_MAX_LENGTH], *sigblob;
	u_int len, dlen, modlen;
	int rlen, ret;

	if (key == NULL || key_type_plain(key->type) != KEY_RSA ||
	    key->rsa == NULL) {
		error("%s: no RSA key", __func__);
		return -1;
	}

	if (BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE) {
		error("%s: RSA modulus too small: %d < minimum %d bits",
		    __func__, BN_num_bits(key->rsa->n),
		    SSH_RSA_MINIMUM_MODULUS_SIZE);
		return -1;
	}
	buffer_init(&b);
	buffer_append(&b, signature, signaturelen);
	ktype = buffer_get_cstring(&b, NULL);
d137 2
a138 4
		error("%s: cannot handle type %s", __func__, ktype);
		buffer_free(&b);
		free(ktype);
		return -1;
d140 7
a146 8
	free(ktype);
	sigblob = buffer_get_string(&b, &len);
	rlen = buffer_len(&b);
	buffer_free(&b);
	if (rlen != 0) {
		error("%s: remaining bytes in signature %d", __func__, rlen);
		free(sigblob);
		return -1;
d151 2
a152 3
		error("%s: len %u > modlen %u", __func__, len, modlen);
		free(sigblob);
		return -1;
d154 7
a160 4
		u_int diff = modlen - len;
		debug("%s: add padding: modlen %u > len %u", __func__,
		    modlen, len);
		sigblob = xrealloc(sigblob, 1, modlen);
a164 1
	/* hash the data */
d167 2
a168 7
		error("%s: bad hash algorithm %d", __func__, hash_alg);
		return -1;
	}
	if (ssh_digest_memory(hash_alg, data, datalen,
	    digest, sizeof(digest)) != 0) {
		error("%s: ssh_digest_memory failed", __func__);
		return -1;
d170 3
d176 9
a185 3
	explicit_bzero(sigblob, len);
	free(sigblob);
	debug("%s: signature %scorrect", __func__, (ret == 0) ? "in" : "");
d208 2
a209 2
openssh_RSA_verify(int hash_alg, u_char *hash, u_int hashlen,
    u_char *sigbuf, u_int siglen, RSA *rsa)
d211 1
a211 1
	u_int ret, rsasize, oidlen = 0, hlen = 0;
d216 1
a216 1
	ret = 0;
d227 1
a227 1
		error("bad hashlen");
d231 7
a237 2
	if (siglen == 0 || siglen > rsasize) {
		error("bad siglen");
a239 1
	decrypted = xmalloc(rsasize);
d242 1
a242 2
		error("RSA_public_decrypt failed: %s",
		    ERR_error_string(ERR_get_error(), NULL));
d245 2
a246 2
	if (len < 0 || (u_int)len != hlen + oidlen) {
		error("bad decrypted len: %d != %d + %d", len, hlen, oidlen);
d251 2
a252 2
	if (!oidmatch) {
		error("oid mismatch");
d255 5
a259 3
	if (!hashmatch) {
		error("hash mismatch");
		goto done;
a260 3
	ret = 1;
done:
	free(decrypted);
@


1.50
log
@Introduce digest API and use it to perform all hashing operations
rather than calling OpenSSL EVP_Digest* directly. Will make it easier
to build a reduced-feature OpenSSH without OpenSSL in future;
feedback, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.49 2013/12/30 23:52:27 djm Exp $ */
d70 1
a70 1
	memset(digest, 'd', sizeof(digest));
d84 1
a84 1
		memset(sig, 0, diff);
d102 1
a102 1
	memset(sig, 's', slen);
d161 1
a161 1
		memset(sigblob, 0, diff);
d178 2
a179 2
	memset(digest, 'd', sizeof(digest));
	memset(sigblob, 's', len);
@


1.49
log
@refuse RSA keys from old proprietary clients/servers that use the
obsolete RSA+MD5 signature scheme. it will still be possible to connect
with these clients/servers but only DSA keys will be accepted, and we'll
deprecate them entirely in a future release. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.48 2013/12/27 22:37:18 djm Exp $ */
d32 1
d41 2
a42 3
	const EVP_MD *evp_md;
	EVP_MD_CTX md;
	u_char digest[EVP_MAX_MD_SIZE], *sig;
d53 2
d56 7
a62 2
	if ((evp_md = EVP_get_digestbynid(nid)) == NULL) {
		error("%s: EVP_get_digestbynid %d failed", __func__, nid);
a64 3
	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, data, datalen);
	EVP_DigestFinal(&md, digest, &dlen);
d113 1
a113 2
	const EVP_MD *evp_md;
	EVP_MD_CTX md;
d115 1
a115 1
	u_char digest[EVP_MAX_MD_SIZE], *sigblob;
d117 1
a117 1
	int rlen, ret, nid;
d164 9
a172 4
	nid = NID_sha1;
	if ((evp_md = EVP_get_digestbynid(nid)) == NULL) {
		error("%s: EVP_get_digestbynid %d failed", __func__, nid);
		free(sigblob);
a174 3
	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, data, datalen);
	EVP_DigestFinal(&md, digest, &dlen);
d176 2
a177 1
	ret = openssh_RSA_verify(nid, digest, dlen, sigblob, len, key->rsa);
d204 1
a204 1
openssh_RSA_verify(int type, u_char *hash, u_int hashlen,
d213 2
a214 2
	switch (type) {
	case NID_sha1:
@


1.48
log
@correct comment
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.47 2013/12/27 22:30:17 djm Exp $ */
d53 1
a53 1
	nid = (datafellows & SSH_BUG_RSASIGMD5) ? NID_md5 : NID_sha1;
d161 1
a161 1
	nid = (datafellows & SSH_BUG_RSASIGMD5) ? NID_md5 : NID_sha1;
a195 12
/*
 * id-md5 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)
 *	rsadsi(113549) digestAlgorithm(2) 5 }
 */
static const u_char id_md5[] = {
	0x30, 0x20, /* type Sequence, length 0x20 (32) */
	0x30, 0x0c, /* type Sequence, length 0x0c (12) */
	0x06, 0x08, /* type OID, length 0x08 */
	0x2a, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, /* id-md5 */
	0x05, 0x00, /* NULL */
	0x04, 0x10  /* Octet string, length 0x10 (16), followed by md5 hash */
};
a211 5
		break;
	case NID_md5:
		oid = id_md5;
		oidlen = sizeof(id_md5);
		hlen = 16;
@


1.47
log
@make the original RSA and DSA signing/verification code look more like
the ECDSA/Ed25519 ones: use key_type_plain() when checking the key type
rather than tediously listing all variants, use __func__ for debug/
error messages
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.46 2013/05/17 00:13:14 djm Exp $ */
d202 2
a203 2
	0x30, 0x0c, /* type Sequence, length 0x09 */
	0x06, 0x08, /* type OID, length 0x05 */
@


1.46
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.45 2010/08/31 09:58:37 djm Exp $ */
d47 3
a49 3
	if (key == NULL || key->rsa == NULL || (key->type != KEY_RSA &&
	    key->type != KEY_RSA_CERT && key->type != KEY_RSA_CERT_V00)) {
		error("ssh_rsa_sign: no RSA key");
d52 1
d55 1
a55 1
		error("ssh_rsa_sign: EVP_get_digestbynid %d failed", nid);
d71 1
a71 1
		error("ssh_rsa_sign: RSA_sign failed: %s",
d82 1
a82 1
		error("ssh_rsa_sign: slen %u slen2 %u", slen, len);
d116 3
a118 3
	if (key == NULL || key->rsa == NULL || (key->type != KEY_RSA &&
	    key->type != KEY_RSA_CERT && key->type != KEY_RSA_CERT_V00)) {
		error("ssh_rsa_verify: no RSA key");
d121 1
d123 3
a125 2
		error("ssh_rsa_verify: RSA modulus too small: %d < minimum %d bits",
		    BN_num_bits(key->rsa->n), SSH_RSA_MINIMUM_MODULUS_SIZE);
d132 1
a132 1
		error("ssh_rsa_verify: cannot handle type %s", ktype);
d142 1
a142 1
		error("ssh_rsa_verify: remaining bytes in signature %d", rlen);
d149 1
a149 1
		error("ssh_rsa_verify: len %u > modlen %u", len, modlen);
d154 1
a154 1
		debug("ssh_rsa_verify: add padding: modlen %u > len %u",
d163 1
a163 1
		error("ssh_rsa_verify: EVP_get_digestbynid %d failed", nid);
d175 1
a175 1
	debug("ssh_rsa_verify: signature %scorrect", (ret==0) ? "in" : "");
@


1.45
log
@Add buffer_get_cstring() and related functions that verify that the
string extracted from the buffer contains no embedded \0 characters*
This prevents random (possibly malicious) crap from being appended to
strings where it would not be noticed if the string is used with
a string(3) function.

Use the new API in a few sensitive places.

* actually, we allow a single one at the end of the string for now because
we don't know how many deployed implementations get this wrong, but don't
count on this to remain indefinitely.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.44 2010/07/16 14:07:35 djm Exp $ */
d72 1
a72 1
		xfree(sig);
d82 1
a82 1
		xfree(sig);
d98 1
a98 1
	xfree(sig);
d131 1
a131 1
		xfree(ktype);
d134 1
a134 1
	xfree(ktype);
d140 1
a140 1
		xfree(sigblob);
d147 1
a147 1
		xfree(sigblob);
d161 1
a161 1
		xfree(sigblob);
d171 1
a171 1
	xfree(sigblob);
d262 1
a262 2
	if (decrypted)
		xfree(decrypted);
@


1.44
log
@more timing paranoia - compare all parts of the expected decrypted
data before returning. AFAIK not exploitable in the SSH protocol.
"groovy" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.43 2010/07/13 23:13:16 djm Exp $ */
d127 1
a127 1
	ktype = buffer_get_string(&b, NULL);
@


1.43
log
@s/timing_safe_cmp/timingsafe_bcmp/g
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.42 2010/07/13 11:52:06 djm Exp $ */
d211 1
a211 1
	int len;
d250 3
a252 1
	if (timingsafe_bcmp(decrypted, oid, oidlen) != 0) {
d256 1
a256 1
	if (timingsafe_bcmp(decrypted + oidlen, hash, hlen) != 0) {
@


1.42
log
@implement a timing_safe_cmp() function to compare memory without leaking
timing information by short-circuiting like memcmp() and use it for
some of the more sensitive comparisons (though nothing high-value was
readily attackable anyway); "looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.41 2010/04/16 01:47:26 djm Exp $ */
d250 1
a250 1
	if (timing_safe_cmp(decrypted, oid, oidlen) != 0) {
d254 1
a254 1
	if (timing_safe_cmp(decrypted + oidlen, hash, hlen) != 0) {
@


1.41
log
@revised certificate format ssh-{dss,rsa}-cert-v01@@openssh.com with the
following changes:

move the nonce field to the beginning of the certificate where it can
better protect against chosen-prefix attacks on the signature hash

Rename "constraints" field to "critical options"

Add a new non-critical "extensions" field

Add a serial number

The older format is still support for authentication and cert generation
(use "ssh-keygen -t v00 -s ca_key ..." to generate a v00 certificate)

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.40 2010/02/26 20:29:54 djm Exp $ */
d30 1
d250 1
a250 1
	if (memcmp(decrypted, oid, oidlen) != 0) {
d254 1
a254 1
	if (memcmp(decrypted + oidlen, hash, hlen) != 0) {
@


1.40
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.39 2006/08/03 03:34:42 deraadt Exp $ */
d46 2
a47 3
	if (key == NULL ||
	    (key->type != KEY_RSA && key->type != KEY_RSA_CERT) ||
	    key->rsa == NULL) {
d114 2
a115 3
	if (key == NULL ||
	    (key->type != KEY_RSA && key->type != KEY_RSA_CERT) ||
	    key->rsa == NULL) {
@


1.39
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.38 2006/07/22 20:48:23 stevesk Exp $ */
d46 3
a48 1
	if (key == NULL || key->type != KEY_RSA || key->rsa == NULL) {
d115 3
a117 1
	if (key == NULL || key->type != KEY_RSA || key->rsa == NULL) {
@


1.38
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-rsa.c,v 1.37 2006/03/25 13:17:02 djm Exp $ */
d17 2
a18 1
#include "includes.h"
a27 1
#include "bufaux.h"
@


1.37
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d21 2
@


1.36
log
@change OpenSSH's xrealloc() function from being xrealloc(p, new_size) to
xrealloc(p, new_nmemb, new_itemsize).

realloc is particularly prone to integer overflows because it is almost
always allocating "n * size" bytes, so this is a far safer API;
ok deraadt@@
@
text
@d1 1
@


1.35
log
@annoying spacing fixes getting in the way of real diffs
@
text
@d147 1
a147 1
		sigblob = xrealloc(sigblob, modlen);
@


1.34
log
@in a switch (), break after return or goto is stupid
@
text
@d64 1
@


1.33
log
@RCSID() can die
@
text
@a221 1
		break;
@


1.32
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@a16 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.31 2003/11/10 16:23:41 jakob Exp $");
@


1.32.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh-rsa.c,v 1.39 2006/08/03 03:34:42 deraadt Exp $ */
d16 2
a17 2

#include <sys/types.h>
a21 2
#include <string.h>

d25 1
a64 1

d147 1
a147 1
		sigblob = xrealloc(sigblob, 1, modlen);
d223 1
@


1.32.4.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh-rsa.c,v 1.39 2006/08/03 03:34:42 deraadt Exp $ */
d16 2
a17 2

#include <sys/types.h>
a21 2
#include <string.h>

d25 1
a64 1

d147 1
a147 1
		sigblob = xrealloc(sigblob, 1, modlen);
d223 1
@


1.31
log
@constify. ok markus@@ & djm@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.30 2003/06/18 11:28:11 markus Exp $");
d241 1
a241 1
	if (len != hlen + oidlen) {
@


1.31.6.1
log
@upgrade to OpenSSH 4.2
@
text
@d17 1
a17 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.32 2005/06/17 02:44:33 djm Exp $");
d241 1
a241 1
	if (len < 0 || (u_int)len != hlen + oidlen) {
@


1.31.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d17 1
a17 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.32 2005/06/17 02:44:33 djm Exp $");
d241 1
a241 1
	if (len < 0 || (u_int)len != hlen + oidlen) {
@


1.30
log
@backout last change, since it violates pkcs#1
switch to share/misc/license.template
@
text
@d17 1
a17 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.28 2003/02/12 09:33:04 markus Exp $");
d34 2
a35 2
ssh_rsa_sign(Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d99 2
a100 2
ssh_rsa_verify(Key *key, u_char *signature, u_int signaturelen,
    u_char *data, u_int datalen)
@


1.30.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d17 1
a17 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.31 2003/11/10 16:23:41 jakob Exp $");
d34 2
a35 2
ssh_rsa_sign(const Key *key, u_char **sigp, u_int *lenp,
    const u_char *data, u_int datalen)
d99 2
a100 2
ssh_rsa_verify(const Key *key, const u_char *signature, u_int signaturelen,
    const u_char *data, u_int datalen)
@


1.29
log
@make sure the signature has at least the expected length (don't
insist on len == hlen + oidlen, since this breaks some smartcards)
bugzilla #592; ok djm@@
@
text
@d2 1
a2 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d4 3
a6 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d8 7
a14 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a15 1

d241 2
a242 2
	if (len < hlen + oidlen) {
		error("bad decrypted len: %d < %d + %d", len, hlen, oidlen);
@


1.28
log
@merge ssh-dss.h ssh-rsa.h into key.h; ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.27 2002/11/21 23:03:51 deraadt Exp $");
d250 2
a251 2
	if (len != hlen + oidlen) {
		error("bad decrypted len: %d != %d + %d", len, hlen, oidlen);
@


1.28.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2003 Markus Friedl <markus@@openbsd.org>
d4 8
a11 3
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
d13 10
a22 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d24 1
d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.30 2003/06/18 11:28:11 markus Exp $");
@


1.28.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d17 1
a17 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.31 2003/11/10 16:23:41 jakob Exp $");
d34 2
a35 2
ssh_rsa_sign(const Key *key, u_char **sigp, u_int *lenp,
    const u_char *data, u_int datalen)
d99 2
a100 2
ssh_rsa_verify(const Key *key, const u_char *signature, u_int signaturelen,
    const u_char *data, u_int datalen)
@


1.27
log
@KNF
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.26 2002/08/27 17:13:56 stevesk Exp $");
a35 1
#include "ssh-rsa.h"
@


1.26
log
@RSA_public_decrypt() returns -1 on error so len must be signed; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.25 2002/08/02 22:20:30 markus Exp $");
d40 1
a40 1
static int openssh_RSA_verify(int, u_char *, u_int, u_char *, u_int , RSA *);
@


1.26.2.1
log
@Update to OpenSSH 3.6
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.28 2003/02/12 09:33:04 markus Exp $");
d36 1
d40 1
a40 1
static int openssh_RSA_verify(int, u_char *, u_int, u_char *, u_int, RSA *);
@


1.26.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2003 Markus Friedl <markus@@openbsd.org>
d4 8
a11 3
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
d13 10
a22 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d24 1
d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.30 2003/06/18 11:28:11 markus Exp $");
@


1.25
log
@replace RSA_verify with our own version and avoid the OpenSSL ASN.1 parser
for authentication; ok deraadt/djm
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.24 2002/08/02 21:23:41 markus Exp $");
d214 2
a215 1
	u_int ret, rsasize, len, oidlen = 0, hlen = 0;
@


1.24
log
@diff is u_int (2x); ok deraadt/provos
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.23 2002/07/04 10:41:47 markus Exp $");
d40 2
d172 1
a172 1
	ret = RSA_verify(nid, digest, dlen, sigblob, len, key->rsa);
a175 5
	if (ret == 0) {
		int ecode = ERR_get_error();
		error("ssh_rsa_verify: RSA_verify failed: %s",
		    ERR_error_string(ecode, NULL));
	}
d177 89
@


1.23
log
@don't allocate, copy, and discard if there is not interested in the data; ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.22 2002/07/04 04:15:33 deraadt Exp $");
d79 1
a79 1
		int diff = slen - len;
d152 1
a152 1
		int diff = modlen - len;
@


1.22
log
@patch memory leaks; grendel@@zeitbombe.org
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.21 2002/06/23 03:30:17 deraadt Exp $");
d47 1
a47 1
	u_char digest[EVP_MAX_MD_SIZE], *sig, *ret;
d93 6
a98 2
	ret = xmalloc(len);
	memcpy(ret, buffer_ptr(&b), len);
a102 6
	if (lenp != NULL)
		*lenp = len;
	if (sigp != NULL)
		*sigp = ret;
	else
		xfree(ret);
@


1.21
log
@various KNF and %d for unsigned
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.20 2002/06/10 16:53:06 stevesk Exp $");
d103 2
@


1.20
log
@display minimum RSA modulus in error(); ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.19 2002/05/31 13:20:50 markus Exp $");
d42 1
a42 3
ssh_rsa_sign(
    Key *key,
    u_char **sigp, u_int *lenp,
d73 2
a74 1
		error("ssh_rsa_sign: RSA_sign failed: %s", ERR_error_string(ecode, NULL));
d80 1
a80 1
		debug("slen %d > len %d", slen, len);
d84 1
a84 1
		error("ssh_rsa_sign: slen %d slen2 %d", slen, len);
d107 1
a107 3
ssh_rsa_verify(
    Key *key,
    u_char *signature, u_int signaturelen,
d148 1
a148 1
		error("ssh_rsa_verify: len %d > modlen %d", len, modlen);
d153 1
a153 1
		debug("ssh_rsa_verify: add padding: modlen %d > len %d",
d176 2
a177 1
		error("ssh_rsa_verify: RSA_verify failed: %s", ERR_error_string(ecode, NULL));
@


1.19
log
@pad received signature with leading zeros, because RSA_verify expects
a signature of RSA_size. the drafts says the signature is transmitted
unpadded (e.g. putty does not pad), reported by anakin@@pobox.com
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.18 2002/04/02 20:11:38 markus Exp $");
d126 2
a127 2
		error("ssh_rsa_verify: n too small: %d bits",
		    BN_num_bits(key->rsa->n));
@


1.18
log
@ignore SSH_BUG_SIGBLOB for ssh-rsa; #187
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.17 2002/03/29 19:18:33 stevesk Exp $");
d118 1
a118 1
	u_int len, dlen;
d147 15
@


1.18.2.1
log
@Pull in OpenSSH-3.4
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.21 2002/06/23 03:30:17 deraadt Exp $");
d42 3
a44 1
ssh_rsa_sign(Key *key, u_char **sigp, u_int *lenp,
d75 1
a75 2
		error("ssh_rsa_sign: RSA_sign failed: %s",
		    ERR_error_string(ecode, NULL));
d81 1
a81 1
		debug("slen %u > len %u", slen, len);
d85 1
a85 1
		error("ssh_rsa_sign: slen %u slen2 %u", slen, len);
d108 3
a110 1
ssh_rsa_verify(Key *key, u_char *signature, u_int signaturelen,
d118 1
a118 1
	u_int len, dlen, modlen;
d126 2
a127 2
		error("ssh_rsa_verify: RSA modulus too small: %d < minimum %d bits",
		    BN_num_bits(key->rsa->n), SSH_RSA_MINIMUM_MODULUS_SIZE);
a147 15
	/* RSA_verify expects a signature of RSA_size */
	modlen = RSA_size(key->rsa);
	if (len > modlen) {
		error("ssh_rsa_verify: len %u > modlen %u", len, modlen);
		xfree(sigblob);
		return -1;
	} else if (len < modlen) {
		int diff = modlen - len;
		debug("ssh_rsa_verify: add padding: modlen %u > len %u",
		    modlen, len);
		sigblob = xrealloc(sigblob, modlen);
		memmove(sigblob + diff, sigblob, len);
		memset(sigblob, 0, diff);
		len = modlen;
	}
d164 1
a164 2
		error("ssh_rsa_verify: RSA_verify failed: %s",
		    ERR_error_string(ecode, NULL));
@


1.18.2.2
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.26 2002/08/27 17:13:56 stevesk Exp $");
a39 2
static int openssh_RSA_verify(int, u_char *, u_int, u_char *, u_int , RSA *);

d47 1
a47 1
	u_char digest[EVP_MAX_MD_SIZE], *sig;
d79 1
a79 1
		u_int diff = slen - len;
d93 2
a94 6
	if (lenp != NULL)
		*lenp = len;
	if (sigp != NULL) {
		*sigp = xmalloc(len);
		memcpy(*sigp, buffer_ptr(&b), len);
	}
d99 4
d152 1
a152 1
		u_int diff = modlen - len;
d170 1
a170 1
	ret = openssh_RSA_verify(nid, digest, dlen, sigblob, len, key->rsa);
d174 5
a179 90
	return ret;
}

/*
 * See:
 * http://www.rsasecurity.com/rsalabs/pkcs/pkcs-1/
 * ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.asn
 */
/*
 * id-sha1 OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
 *	oiw(14) secsig(3) algorithms(2) 26 }
 */
static const u_char id_sha1[] = {
	0x30, 0x21, /* type Sequence, length 0x21 (33) */
	0x30, 0x09, /* type Sequence, length 0x09 */
	0x06, 0x05, /* type OID, length 0x05 */
	0x2b, 0x0e, 0x03, 0x02, 0x1a, /* id-sha1 OID */
	0x05, 0x00, /* NULL */
	0x04, 0x14  /* Octet string, length 0x14 (20), followed by sha1 hash */
};
/*
 * id-md5 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)
 *	rsadsi(113549) digestAlgorithm(2) 5 }
 */
static const u_char id_md5[] = {
	0x30, 0x20, /* type Sequence, length 0x20 (32) */
	0x30, 0x0c, /* type Sequence, length 0x09 */
	0x06, 0x08, /* type OID, length 0x05 */
	0x2a, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, /* id-md5 */
	0x05, 0x00, /* NULL */
	0x04, 0x10  /* Octet string, length 0x10 (16), followed by md5 hash */
};

static int
openssh_RSA_verify(int type, u_char *hash, u_int hashlen,
    u_char *sigbuf, u_int siglen, RSA *rsa)
{
	u_int ret, rsasize, oidlen = 0, hlen = 0;
	int len;
	const u_char *oid = NULL;
	u_char *decrypted = NULL;

	ret = 0;
	switch (type) {
	case NID_sha1:
		oid = id_sha1;
		oidlen = sizeof(id_sha1);
		hlen = 20;
		break;
	case NID_md5:
		oid = id_md5;
		oidlen = sizeof(id_md5);
		hlen = 16;
		break;
	default:
		goto done;
		break;
	}
	if (hashlen != hlen) {
		error("bad hashlen");
		goto done;
	}
	rsasize = RSA_size(rsa);
	if (siglen == 0 || siglen > rsasize) {
		error("bad siglen");
		goto done;
	}
	decrypted = xmalloc(rsasize);
	if ((len = RSA_public_decrypt(siglen, sigbuf, decrypted, rsa,
	    RSA_PKCS1_PADDING)) < 0) {
		error("RSA_public_decrypt failed: %s",
		    ERR_error_string(ERR_get_error(), NULL));
		goto done;
	}
	if (len != hlen + oidlen) {
		error("bad decrypted len: %d != %d + %d", len, hlen, oidlen);
		goto done;
	}
	if (memcmp(decrypted, oid, oidlen) != 0) {
		error("oid mismatch");
		goto done;
	}
	if (memcmp(decrypted + oidlen, hash, hlen) != 0) {
		error("hash mismatch");
		goto done;
	}
	ret = 1;
done:
	if (decrypted)
		xfree(decrypted);
@


1.18.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.28 2003/02/12 09:33:04 markus Exp $");
d36 1
d40 1
a40 1
static int openssh_RSA_verify(int, u_char *, u_int, u_char *, u_int, RSA *);
@


1.17
log
@make RSA modulus minimum #define; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.16 2002/02/24 19:14:59 markus Exp $");
a57 4
	if (datafellows & SSH_BUG_SIGBLOB) {
		error("ssh_rsa_sign: SSH_BUG_SIGBLOB not supported");
		return -1;
	}
a122 4
		return -1;
	}
	if (datafellows & SSH_BUG_SIGBLOB) {
		error("ssh_rsa_verify: SSH_BUG_SIGBLOB not supported");
@


1.16
log
@signed vs. unsigned: make size arguments u_int, ok stevesk@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.15 2002/01/25 21:42:11 markus Exp $");
d38 1
d133 1
a133 1
	if (BN_num_bits(key->rsa->n) < 768) {
@


1.15
log
@use static EVP_MAX_MD_SIZE buffers for EVP_DigestFinal; ok stevesk@@
don't use evp_md->md_size, it's not public.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.14 2001/12/05 10:06:12 deraadt Exp $");
d43 2
a44 2
    u_char **sigp, int *lenp,
    u_char *data, int datalen)
d113 2
a114 2
    u_char *signature, int signaturelen,
    u_char *data, int datalen)
@


1.14
log
@minor KNF
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.13 2001/11/10 13:22:42 markus Exp $");
d48 1
a48 1
	u_char *digest, *sig, *ret;
a65 2
	dlen = evp_md->md_size;
	digest = xmalloc(dlen);
d68 1
a68 1
	EVP_DigestFinal(&md, digest, NULL);
d74 1
a74 2
	memset(digest, 'd', dlen);
	xfree(digest);
d120 1
a120 1
	u_char *sigblob, *digest;
a160 2
	dlen = evp_md->md_size;
	digest = xmalloc(dlen);
d163 1
a163 1
	EVP_DigestFinal(&md, digest, NULL);
d166 1
a166 2
	memset(digest, 'd', dlen);
	xfree(digest);
@


1.13
log
@KNF (unexpand)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.12 2001/11/07 22:10:28 markus Exp $");
d153 1
a153 1
	if(rlen != 0) {
@


1.12
log
@missing free and sync dss/rsa code.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.11 2001/11/07 21:40:21 markus Exp $");
d57 1
a57 1
        if (datafellows & SSH_BUG_SIGBLOB) {
d131 1
a131 1
        if (datafellows & SSH_BUG_SIGBLOB) {
@


1.11
log
@ssh_rsa_sign/verify: SSH_BUG_SIGBLOB not supported
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.10 2001/09/17 19:27:15 stevesk Exp $");
d154 1
a155 1
		error("ssh_rsa_verify: remaining bytes in signature %d", rlen);
d160 1
a161 1
		error("ssh_rsa_verify: EVP_get_digestbynid %d failed", nid);
@


1.10
log
@u_char*/char* cleanup; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.9 2001/06/06 23:13:54 markus Exp $");
d57 4
d129 4
@


1.10.2.1
log
@Pull in patches from current (Errata 002):
Update to OpenSSH-3.0.1 via errata patch (Instead of using release tarball)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.13 2001/11/10 13:22:42 markus Exp $");
a56 4
	if (datafellows & SSH_BUG_SIGBLOB) {
		error("ssh_rsa_sign: SSH_BUG_SIGBLOB not supported");
		return -1;
	}
a126 4
	if (datafellows & SSH_BUG_SIGBLOB) {
		error("ssh_rsa_verify: SSH_BUG_SIGBLOB not supported");
		return -1;
	}
d146 1
a147 1
		xfree(sigblob);
d152 1
a153 1
		xfree(sigblob);
@


1.10.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.16 2002/02/24 19:14:59 markus Exp $");
d43 2
a44 2
    u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d48 1
a48 1
	u_char digest[EVP_MAX_MD_SIZE], *sig, *ret;
d66 2
d70 1
a70 1
	EVP_DigestFinal(&md, digest, &dlen);
d76 2
a77 1
	memset(digest, 'd', sizeof(digest));
d116 2
a117 2
    u_char *signature, u_int signaturelen,
    u_char *data, u_int datalen)
d123 1
a123 1
	u_char digest[EVP_MAX_MD_SIZE], *sigblob;
d153 1
a153 1
	if (rlen != 0) {
d164 2
d168 1
a168 1
	EVP_DigestFinal(&md, digest, &dlen);
d171 2
a172 1
	memset(digest, 'd', sizeof(digest));
@


1.10.2.3
log
@Update OpenSSH to version 3.2.2.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.18 2002/04/02 20:11:38 markus Exp $");
a37 1
#include "ssh.h"
d57 4
d128 5
a132 1
	if (BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE) {
@


1.10.2.4
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.10.2.3 2002/05/17 00:03:24 miod Exp $");
d118 1
a118 1
	u_int len, dlen, modlen;
d126 2
a127 2
		error("ssh_rsa_verify: RSA modulus too small: %d < minimum %d bits",
		    BN_num_bits(key->rsa->n), SSH_RSA_MINIMUM_MODULUS_SIZE);
a146 15
	}
	/* RSA_verify expects a signature of RSA_size */
	modlen = RSA_size(key->rsa);
	if (len > modlen) {
		error("ssh_rsa_verify: len %d > modlen %d", len, modlen);
		xfree(sigblob);
		return -1;
	} else if (len < modlen) {
		int diff = modlen - len;
		debug("ssh_rsa_verify: add padding: modlen %d > len %d",
		    modlen, len);
		sigblob = xrealloc(sigblob, modlen);
		memmove(sigblob + diff, sigblob, len);
		memset(sigblob, 0, diff);
		len = modlen;
@


1.10.2.5
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.10.2.4 2002/06/22 07:23:18 miod Exp $");
d42 3
a44 1
ssh_rsa_sign(Key *key, u_char **sigp, u_int *lenp,
d75 1
a75 2
		error("ssh_rsa_sign: RSA_sign failed: %s",
		    ERR_error_string(ecode, NULL));
d81 1
a81 1
		debug("slen %u > len %u", slen, len);
d85 1
a85 1
		error("ssh_rsa_sign: slen %u slen2 %u", slen, len);
d108 3
a110 1
ssh_rsa_verify(Key *key, u_char *signature, u_int signaturelen,
d151 1
a151 1
		error("ssh_rsa_verify: len %u > modlen %u", len, modlen);
d156 1
a156 1
		debug("ssh_rsa_verify: add padding: modlen %u > len %u",
d179 1
a179 2
		error("ssh_rsa_verify: RSA_verify failed: %s",
		    ERR_error_string(ecode, NULL));
@


1.10.2.6
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.26 2002/08/27 17:13:56 stevesk Exp $");
a39 2
static int openssh_RSA_verify(int, u_char *, u_int, u_char *, u_int , RSA *);

d47 1
a47 1
	u_char digest[EVP_MAX_MD_SIZE], *sig;
d79 1
a79 1
		u_int diff = slen - len;
d93 2
a94 6
	if (lenp != NULL)
		*lenp = len;
	if (sigp != NULL) {
		*sigp = xmalloc(len);
		memcpy(*sigp, buffer_ptr(&b), len);
	}
d99 4
d152 1
a152 1
		u_int diff = modlen - len;
d170 1
a170 1
	ret = openssh_RSA_verify(nid, digest, dlen, sigblob, len, key->rsa);
d174 5
a179 90
	return ret;
}

/*
 * See:
 * http://www.rsasecurity.com/rsalabs/pkcs/pkcs-1/
 * ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.asn
 */
/*
 * id-sha1 OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
 *	oiw(14) secsig(3) algorithms(2) 26 }
 */
static const u_char id_sha1[] = {
	0x30, 0x21, /* type Sequence, length 0x21 (33) */
	0x30, 0x09, /* type Sequence, length 0x09 */
	0x06, 0x05, /* type OID, length 0x05 */
	0x2b, 0x0e, 0x03, 0x02, 0x1a, /* id-sha1 OID */
	0x05, 0x00, /* NULL */
	0x04, 0x14  /* Octet string, length 0x14 (20), followed by sha1 hash */
};
/*
 * id-md5 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)
 *	rsadsi(113549) digestAlgorithm(2) 5 }
 */
static const u_char id_md5[] = {
	0x30, 0x20, /* type Sequence, length 0x20 (32) */
	0x30, 0x0c, /* type Sequence, length 0x09 */
	0x06, 0x08, /* type OID, length 0x05 */
	0x2a, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, /* id-md5 */
	0x05, 0x00, /* NULL */
	0x04, 0x10  /* Octet string, length 0x10 (16), followed by md5 hash */
};

static int
openssh_RSA_verify(int type, u_char *hash, u_int hashlen,
    u_char *sigbuf, u_int siglen, RSA *rsa)
{
	u_int ret, rsasize, oidlen = 0, hlen = 0;
	int len;
	const u_char *oid = NULL;
	u_char *decrypted = NULL;

	ret = 0;
	switch (type) {
	case NID_sha1:
		oid = id_sha1;
		oidlen = sizeof(id_sha1);
		hlen = 20;
		break;
	case NID_md5:
		oid = id_md5;
		oidlen = sizeof(id_md5);
		hlen = 16;
		break;
	default:
		goto done;
		break;
	}
	if (hashlen != hlen) {
		error("bad hashlen");
		goto done;
	}
	rsasize = RSA_size(rsa);
	if (siglen == 0 || siglen > rsasize) {
		error("bad siglen");
		goto done;
	}
	decrypted = xmalloc(rsasize);
	if ((len = RSA_public_decrypt(siglen, sigbuf, decrypted, rsa,
	    RSA_PKCS1_PADDING)) < 0) {
		error("RSA_public_decrypt failed: %s",
		    ERR_error_string(ERR_get_error(), NULL));
		goto done;
	}
	if (len != hlen + oidlen) {
		error("bad decrypted len: %d != %d + %d", len, hlen, oidlen);
		goto done;
	}
	if (memcmp(decrypted, oid, oidlen) != 0) {
		error("oid mismatch");
		goto done;
	}
	if (memcmp(decrypted + oidlen, hash, hlen) != 0) {
		error("hash mismatch");
		goto done;
	}
	ret = 1;
done:
	if (decrypted)
		xfree(decrypted);
@


1.9
log
@cleanup, remove old code
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.8 2001/03/27 10:57:00 markus Exp $");
d133 1
a133 1
	buffer_append(&b, (char *) signature, signaturelen);
d142 1
a142 1
	sigblob = (u_char *)buffer_get_string(&b, &len);
@


1.8
log
@some older systems use NID_md5 instead of NID_sha1 for RSASSA-PKCS1-v1_5
signatures in SSH protocol 2, ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.7 2001/03/27 10:34:08 markus Exp $");
a105 1
	debug2("ssh_rsa_sign: done");
@


1.8.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.10 2001/09/17 19:27:15 stevesk Exp $");
d106 1
d134 1
a134 1
	buffer_append(&b, signature, signaturelen);
d143 1
a143 1
	sigblob = buffer_get_string(&b, &len);
@


1.8.2.2
log
@Merge OpenSSH 3.0.1.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.8.2.1 2001/09/27 19:03:55 jason Exp $");
a56 4
	if (datafellows & SSH_BUG_SIGBLOB) {
		error("ssh_rsa_sign: SSH_BUG_SIGBLOB not supported");
		return -1;
	}
a126 4
	if (datafellows & SSH_BUG_SIGBLOB) {
		error("ssh_rsa_verify: SSH_BUG_SIGBLOB not supported");
		return -1;
	}
d146 1
a147 1
		xfree(sigblob);
d152 1
a153 1
		xfree(sigblob);
@


1.8.2.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.16 2002/02/24 19:14:59 markus Exp $");
d43 2
a44 2
    u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d48 1
a48 1
	u_char digest[EVP_MAX_MD_SIZE], *sig, *ret;
d66 2
d70 1
a70 1
	EVP_DigestFinal(&md, digest, &dlen);
d76 2
a77 1
	memset(digest, 'd', sizeof(digest));
d116 2
a117 2
    u_char *signature, u_int signaturelen,
    u_char *data, u_int datalen)
d123 1
a123 1
	u_char digest[EVP_MAX_MD_SIZE], *sigblob;
d153 1
a153 1
	if (rlen != 0) {
d164 2
d168 1
a168 1
	EVP_DigestFinal(&md, digest, &dlen);
d171 2
a172 1
	memset(digest, 'd', sizeof(digest));
@


1.8.2.4
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.18 2002/04/02 20:11:38 markus Exp $");
a37 1
#include "ssh.h"
d57 4
d128 5
a132 1
	if (BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE) {
@


1.7
log
@use EVP_get_digestbynid, reorder some calls and fix missing free.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.6 2001/02/08 19:30:52 itojun Exp $");
d37 1
d57 1
a57 1
	nid = NID_sha1;
d151 1
a151 1
	nid = NID_sha1;
@


1.6
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.5 2001/01/21 19:05:58 markus Exp $");
d45 1
a45 1
	EVP_MD *evp_md = EVP_sha1();
d49 1
a49 1
	int ok;
d56 5
a60 3
	slen = RSA_size(key->rsa);
	sig = xmalloc(slen);

d67 4
a70 1
	ok = RSA_sign(NID_sha1, digest, dlen, sig, &len, key->rsa);
d116 1
a116 1
	EVP_MD *evp_md = EVP_sha1();
d121 1
a121 2
	int rlen;
	int ret;
d146 1
d150 6
a155 1

d162 1
a162 1
	ret = RSA_verify(NID_sha1, digest, dlen, sigblob, len, key->rsa);
@


1.6.4.1
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.6 2001/02/08 19:30:52 itojun Exp $");
@


1.6.4.2
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.6.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.6 2001/02/08 19:30:52 itojun Exp $");
@


1.6.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.6.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.6.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.8 2001/03/27 10:57:00 markus Exp $");
a36 1
#include "compat.h"
d45 1
a45 1
	const EVP_MD *evp_md;
d49 1
a49 1
	int ok, nid;
d56 3
a58 5
	nid = (datafellows & SSH_BUG_RSASIGMD5) ? NID_md5 : NID_sha1;
	if ((evp_md = EVP_get_digestbynid(nid)) == NULL) {
		error("ssh_rsa_sign: EVP_get_digestbynid %d failed", nid);
		return -1;
	}
d65 1
a65 4
	slen = RSA_size(key->rsa);
	sig = xmalloc(slen);

	ok = RSA_sign(nid, digest, dlen, sig, &len, key->rsa);
d111 1
a111 1
	const EVP_MD *evp_md;
d116 2
a117 1
	int rlen, ret, nid;
a141 1
		xfree(sigblob);
d145 1
a145 6
	nid = (datafellows & SSH_BUG_RSASIGMD5) ? NID_md5 : NID_sha1;
	if ((evp_md = EVP_get_digestbynid(nid)) == NULL) {
		xfree(sigblob);
		error("ssh_rsa_verify: EVP_get_digestbynid %d failed", nid);
		return -1;
	}
d152 1
a152 1
	ret = RSA_verify(nid, digest, dlen, sigblob, len, key->rsa);
@


1.6.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.10 2001/09/17 19:27:15 stevesk Exp $");
d106 1
d134 1
a134 1
	buffer_append(&b, signature, signaturelen);
d143 1
a143 1
	sigblob = buffer_get_string(&b, &len);
@


1.6.2.6
log
@Merge OpenSSH 3.0.1.

This is likely to be the last commit to the 2.8-STABLE branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.6.2.5 2001/09/27 00:15:42 miod Exp $");
a56 4
	if (datafellows & SSH_BUG_SIGBLOB) {
		error("ssh_rsa_sign: SSH_BUG_SIGBLOB not supported");
		return -1;
	}
a126 4
	if (datafellows & SSH_BUG_SIGBLOB) {
		error("ssh_rsa_verify: SSH_BUG_SIGBLOB not supported");
		return -1;
	}
d146 1
a147 1
		xfree(sigblob);
d152 1
a153 1
		xfree(sigblob);
@


1.6.2.7
log
@Merge OpenSSH 3.1.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.16 2002/02/24 19:14:59 markus Exp $");
d43 2
a44 2
    u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d48 1
a48 1
	u_char digest[EVP_MAX_MD_SIZE], *sig, *ret;
d66 2
d70 1
a70 1
	EVP_DigestFinal(&md, digest, &dlen);
d76 2
a77 1
	memset(digest, 'd', sizeof(digest));
d116 2
a117 2
    u_char *signature, u_int signaturelen,
    u_char *data, u_int datalen)
d123 1
a123 1
	u_char digest[EVP_MAX_MD_SIZE], *sigblob;
d153 1
a153 1
	if (rlen != 0) {
d164 2
d168 1
a168 1
	EVP_DigestFinal(&md, digest, &dlen);
d171 2
a172 1
	memset(digest, 'd', sizeof(digest));
@


1.5
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.4 2001/01/16 19:20:06 markus Exp $");
d36 1
@


1.4
log
@make "ssh-rsa" key format for ssh2 confirm to the ietf-drafts; from galb@@vandyke.com.
note that you have to delete older ssh2-rsa keys, since they are in the
wrong format, too. they must be removed from .ssh/authorized_keys2
and .ssh/known_hosts2, etc.
(cd; grep -v ssh-rsa .ssh/authorized_keys2 > TMP && mv TMP .ssh/authorized_keys2)
additionally, we now check that BN_num_bits(rsa->n) >= 768.
@
text
@d26 4
a29 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.3 2001/01/06 11:23:27 markus Exp $");
a30 1
#include "ssh.h"
d32 1
a34 6

#include <openssl/evp.h>
#include <openssl/dsa.h>
#include <openssl/rsa.h>
#include <openssl/err.h>

@


1.3
log
@remove unused
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.2 2000/12/19 23:17:58 markus Exp $");
d123 5
@


1.2
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: ssh-rsa.c,v 1.1 2000/11/12 19:50:38 markus Exp $");
a38 3

#define INTBLOB_LEN	20
#define SIGBLOB_LEN	(2*INTBLOB_LEN)
@


1.1
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dsa.c,v 1.11 2000/09/07 20:27:51 deraadt Exp $");
d47 2
a48 2
    unsigned char **sigp, int *lenp,
    unsigned char *data, int datalen)
d52 2
a53 2
	unsigned char *digest, *sig, *ret;
	unsigned int slen, dlen, len;
d112 2
a113 2
    unsigned char *signature, int signaturelen,
    unsigned char *data, int datalen)
d119 2
a120 2
	unsigned char *sigblob, *digest;
	unsigned int len, dlen;
d138 1
a138 1
	sigblob = (unsigned char *)buffer_get_string(&b, &len);
@

