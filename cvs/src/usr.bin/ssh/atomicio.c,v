head	1.28;
access;
symbols
	OPENBSD_6_0:1.27.0.10
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.6
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.18
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.16
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.12
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.10
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.8
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.6
	OPENBSD_5_0:1.26.0.4
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.25.0.14
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.10
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.12
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.8
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.6
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.4
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.4
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.10.0.8
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.6
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.4
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.28
date	2016.07.27.23.18.12;	author djm;	state Exp;
branches;
next	1.27;
commitid	fxNJrxLsLfGsH05p;

1.27
date	2015.01.16.06.40.12;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	Uu5nFG3wCl0LACBb;

1.26
date	2010.09.22.22.58.51;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.25.12.02.27;	author dtucker;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.19.02.04.43;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.21;

1.21
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.20;

1.20
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.16.07.59.00;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.16.00.52.55;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.01.05.51.34;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.11.19.31.18;	author otto;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2005.05.24.17.32.43;	author avsm;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2003.07.31.15.50.16;	author avsm;	state Exp;
branches
	1.12.6.1
	1.12.8.1;
next	1.11;

1.11
date	2003.06.28.16.23.06;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.08.22.48.07;	author markus;	state Exp;
branches
	1.10.6.1
	1.10.8.1;
next	1.9;

1.9
date	2001.03.02.18.54.30;	author deraadt;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.01.21.19.05.40;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.18.18.04.02;	author markus;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.10.17.20.28.10;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.07.20.27.49;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.20.01.39.37;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.16.20.56.13;	author markus;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.02.01.22.32.53;	author d;	state Exp;
branches;
next	1.1;

1.1
date	99.12.06.20.15.25;	author deraadt;	state Exp;
branches;
next	;

1.3.2.1
date	2000.09.01.18.23.16;	author jason;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2000.11.08.21.30.16;	author jason;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2001.03.12.15.44.06;	author jason;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2001.03.21.18.52.31;	author jason;	state Exp;
branches;
next	;

1.7.2.1
date	2001.02.16.20.12.51;	author jason;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.02.19.17.18.31;	author jason;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.03.21.19.46.21;	author jason;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2001.05.07.21.09.25;	author jason;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	;

1.9.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.03.09.00.20.43;	author miod;	state Exp;
branches;
next	;

1.10.6.1
date	2003.09.16.21.20.23;	author brad;	state Exp;
branches;
next	;

1.10.8.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.10.8.2;

1.10.8.2
date	2004.03.04.18.18.14;	author brad;	state Exp;
branches;
next	;

1.12.6.1
date	2005.09.02.03.44.59;	author brad;	state Exp;
branches;
next	;

1.12.8.1
date	2005.09.04.18.39.52;	author brad;	state Exp;
branches;
next	;

1.13.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.14.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.28
log
@better bounds check on iovcnt (we only ever use fixed, positive values)
@
text
@/* $OpenBSD: atomicio.c,v 1.27 2015/01/16 06:40:12 deraadt Exp $ */
/*
 * Copyright (c) 2006 Damien Miller. All rights reserved.
 * Copyright (c) 2005 Anil Madhavapeddy. All rights reserved.
 * Copyright (c) 1995,1999 Theo de Raadt.  All rights reserved.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/uio.h>

#include <errno.h>
#include <poll.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "atomicio.h"

/*
 * ensure all of data on socket comes through. f==read || f==vwrite
 */
size_t
atomicio6(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n,
    int (*cb)(void *, size_t), void *cb_arg)
{
	char *s = _s;
	size_t pos = 0;
	ssize_t res;
	struct pollfd pfd;

	pfd.fd = fd;
	pfd.events = f == read ? POLLIN : POLLOUT;
	while (n > pos) {
		res = (f) (fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR)
				continue;
			if (errno == EAGAIN) {
				(void)poll(&pfd, 1, -1);
				continue;
			}
			return 0;
		case 0:
			errno = EPIPE;
			return pos;
		default:
			pos += (size_t)res;
			if (cb != NULL && cb(cb_arg, (size_t)res) == -1) {
				errno = EINTR;
				return pos;
			}
		}
	}
	return pos;
}

size_t
atomicio(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n)
{
	return atomicio6(f, fd, _s, n, NULL, NULL);
}

/*
 * ensure all of data on socket comes through. f==readv || f==writev
 */
size_t
atomiciov6(ssize_t (*f) (int, const struct iovec *, int), int fd,
    const struct iovec *_iov, int iovcnt,
    int (*cb)(void *, size_t), void *cb_arg)
{
	size_t pos = 0, rem;
	ssize_t res;
	struct iovec iov_array[IOV_MAX], *iov = iov_array;
	struct pollfd pfd;

	if (iovcnt < 0 || iovcnt > IOV_MAX) {
		errno = EINVAL;
		return 0;
	}
	/* Make a copy of the iov array because we may modify it below */
	memcpy(iov, _iov, (size_t)iovcnt * sizeof(*_iov));

	pfd.fd = fd;
	pfd.events = f == readv ? POLLIN : POLLOUT;
	for (; iovcnt > 0 && iov[0].iov_len > 0;) {
		res = (f) (fd, iov, iovcnt);
		switch (res) {
		case -1:
			if (errno == EINTR)
				continue;
			if (errno == EAGAIN) {
				(void)poll(&pfd, 1, -1);
				continue;
			}
			return 0;
		case 0:
			errno = EPIPE;
			return pos;
		default:
			rem = (size_t)res;
			pos += rem;
			/* skip completed iov entries */
			while (iovcnt > 0 && rem >= iov[0].iov_len) {
				rem -= iov[0].iov_len;
				iov++;
				iovcnt--;
			}
			/* This shouldn't happen... */
			if (rem > 0 && (iovcnt <= 0 || rem > iov[0].iov_len)) {
				errno = EFAULT;
				return 0;
			}
			if (iovcnt == 0)
				break;
			/* update pointer in partially complete iov */
			iov[0].iov_base = ((char *)iov[0].iov_base) + rem;
			iov[0].iov_len -= rem;
		}
		if (cb != NULL && cb(cb_arg, (size_t)res) == -1) {
			errno = EINTR;
			return pos;
		}
	}
	return pos;
}

size_t
atomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,
    const struct iovec *_iov, int iovcnt)
{
	return atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);
}
@


1.27
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: atomicio.c,v 1.26 2010/09/22 22:58:51 djm Exp $ */
d97 1
a97 1
	if (iovcnt > IOV_MAX) {
d102 1
a102 1
	memcpy(iov, _iov, iovcnt * sizeof(*_iov));
@


1.26
log
@add an option per-read/write callback to atomicio

factor out bandwidth limiting code from scp(1) into a generic bandwidth
limiter that can be attached using the atomicio callback mechanism

add a bandwidth limit option to sftp(1) using the above

"very nice" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: atomicio.c,v 1.25 2007/06/25 12:02:27 dtucker Exp $ */
a28 1
#include <sys/param.h>
d35 1
@


1.25
log
@Include <poll.h> like the man page says rather than <sys/poll.h>.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: atomicio.c,v 1.24 2007/06/19 02:04:43 djm Exp $ */
d43 2
a44 1
atomicio(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n)
d69 4
d75 7
a81 1
	return (pos);
d88 3
a90 2
atomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,
    const struct iovec *_iov, int iovcnt)
d140 4
d146 7
@


1.24
log
@if the fd passed to atomicio/atomiciov() is non blocking, then poll() to
avoid a spin if it is not yet ready for reading/writing; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: atomicio.c,v 1.23 2006/08/03 03:34:41 deraadt Exp $ */
a30 1
#include <sys/poll.h>
d33 1
@


1.23
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: atomicio.c,v 1.22 2006/07/26 02:35:17 stevesk Exp $ */
d31 1
d35 1
d48 1
d50 2
d56 1
a56 1
			if (errno == EINTR || errno == EAGAIN)
d58 4
d83 1
d92 2
d98 4
a101 1
			if (errno == EINTR || errno == EAGAIN)
d103 1
@


1.22
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: atomicio.c,v 1.21 2006/07/22 20:48:22 stevesk Exp $ */
a28 2
#include "includes.h"

d30 1
@


1.21
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: atomicio.c,v 1.20 2006/07/11 20:07:25 stevesk Exp $ */
d30 2
@


1.20
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: atomicio.c,v 1.19 2006/04/16 07:59:00 djm Exp $ */
d32 1
@


1.19
log
@reorder sanity test so that it cannot dereference past the end of the
iov array; well spotted canacar@@!
@
text
@d1 1
a1 1
/* $OpenBSD: atomicio.c,v 1.18 2006/04/16 00:52:55 djm Exp $ */
d30 2
@


1.18
log
@introduce atomiciov() function that wraps readv/writev to retry
interrupted transfers like atomicio() does for read/write;
feedback deraadt@@ dtucker@@ stevesk@@ ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: atomicio.c,v 1.17 2006/04/01 05:51:34 djm Exp $ */
d98 1
a98 1
			if (rem > iov[0].iov_len || (rem > 0 && iovcnt <= 0)) {
@


1.17
log
@ANSIfy; requested deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: atomicio.c,v 1.16 2006/03/25 13:17:01 djm Exp $ */
d3 1
d58 52
@


1.16
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d36 1
a36 5
atomicio(f, fd, _s, n)
	ssize_t (*f) (int, void *, size_t);
	int fd;
	void *_s;
	size_t n;
@


1.15
log
@RCSID() can die
@
text
@d1 1
@


1.14
log
@type correctness; from Ray Lai in PR 5011; ok millert@@
@
text
@a27 1
RCSID("$OpenBSD: atomicio.c,v 1.13 2005/05/24 17:32:43 avsm Exp $");
@


1.14.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: atomicio.c,v 1.23 2006/08/03 03:34:41 deraadt Exp $ */
a1 1
 * Copyright (c) 2006 Damien Miller. All rights reserved.
d27 2
a28 5
#include <sys/param.h>
#include <sys/uio.h>

#include <errno.h>
#include <string.h>
d36 5
a40 1
atomicio(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n)
a60 52
}

/*
 * ensure all of data on socket comes through. f==readv || f==writev
 */
size_t
atomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,
    const struct iovec *_iov, int iovcnt)
{
	size_t pos = 0, rem;
	ssize_t res;
	struct iovec iov_array[IOV_MAX], *iov = iov_array;

	if (iovcnt > IOV_MAX) {
		errno = EINVAL;
		return 0;
	}
	/* Make a copy of the iov array because we may modify it below */
	memcpy(iov, _iov, iovcnt * sizeof(*_iov));

	for (; iovcnt > 0 && iov[0].iov_len > 0;) {
		res = (f) (fd, iov, iovcnt);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
			return 0;
		case 0:
			errno = EPIPE;
			return pos;
		default:
			rem = (size_t)res;
			pos += rem;
			/* skip completed iov entries */
			while (iovcnt > 0 && rem >= iov[0].iov_len) {
				rem -= iov[0].iov_len;
				iov++;
				iovcnt--;
			}
			/* This shouldn't happen... */
			if (rem > 0 && (iovcnt <= 0 || rem > iov[0].iov_len)) {
				errno = EFAULT;
				return 0;
			}
			if (iovcnt == 0)
				break;
			/* update pointer in partially complete iov */
			iov[0].iov_base = ((char *)iov[0].iov_base) + rem;
			iov[0].iov_len -= rem;
		}
	}
	return pos;
@


1.13
log
@Switch atomicio to use a simpler interface; it now returns a size_t
(containing number of bytes read/written), and indicates error by
returning 0.  EOF is signalled by errno==EPIPE.
Typical use now becomes:

if (atomicio(read, ..., len) != len)
        err(1,"read");

ok deraadt@@, cloder@@, djm@@
@
text
@d28 1
a28 1
RCSID("$OpenBSD: atomicio.c,v 1.12 2003/07/31 15:50:16 avsm Exp $");
d57 1
a57 1
			pos += (u_int)res;
@


1.13.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: atomicio.c,v 1.23 2006/08/03 03:34:41 deraadt Exp $ */
a1 1
 * Copyright (c) 2006 Damien Miller. All rights reserved.
d27 2
a28 5
#include <sys/param.h>
#include <sys/uio.h>

#include <errno.h>
#include <string.h>
d36 5
a40 1
atomicio(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n)
d57 1
a57 1
			pos += (size_t)res;
a60 52
}

/*
 * ensure all of data on socket comes through. f==readv || f==writev
 */
size_t
atomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,
    const struct iovec *_iov, int iovcnt)
{
	size_t pos = 0, rem;
	ssize_t res;
	struct iovec iov_array[IOV_MAX], *iov = iov_array;

	if (iovcnt > IOV_MAX) {
		errno = EINVAL;
		return 0;
	}
	/* Make a copy of the iov array because we may modify it below */
	memcpy(iov, _iov, iovcnt * sizeof(*_iov));

	for (; iovcnt > 0 && iov[0].iov_len > 0;) {
		res = (f) (fd, iov, iovcnt);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
			return 0;
		case 0:
			errno = EPIPE;
			return pos;
		default:
			rem = (size_t)res;
			pos += rem;
			/* skip completed iov entries */
			while (iovcnt > 0 && rem >= iov[0].iov_len) {
				rem -= iov[0].iov_len;
				iov++;
				iovcnt--;
			}
			/* This shouldn't happen... */
			if (rem > 0 && (iovcnt <= 0 || rem > iov[0].iov_len)) {
				errno = EFAULT;
				return 0;
			}
			if (iovcnt == 0)
				break;
			/* update pointer in partially complete iov */
			iov[0].iov_base = ((char *)iov[0].iov_base) + rem;
			iov[0].iov_len -= rem;
		}
	}
	return pos;
@


1.12
log
@correct comment: atomicio takes vwrite, not write; deraadt@@ ok
@
text
@d2 1
d28 1
a28 1
RCSID("$OpenBSD: atomicio.c,v 1.11 2003/06/28 16:23:06 deraadt Exp $");
d35 1
a35 1
ssize_t
d43 2
a44 1
	ssize_t res, pos = 0;
d52 1
d54 2
a55 1
			return (res);
d57 1
a57 1
			pos += res;
@


1.12.8.1
log
@upgrade to OpenSSH 4.2
@
text
@a1 1
 * Copyright (c) 2005 Anil Madhavapeddy. All rights reserved.
d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.13 2005/05/24 17:32:43 avsm Exp $");
d34 1
a34 1
size_t
d42 1
a42 2
	size_t pos = 0;
	ssize_t res;
a49 1
			return 0;
d51 1
a51 2
			errno = EPIPE;
			return pos;
d53 1
a53 1
			pos += (u_int)res;
@


1.12.6.1
log
@upgrade to OpenSSH 4.2
@
text
@a1 1
 * Copyright (c) 2005 Anil Madhavapeddy. All rights reserved.
d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.13 2005/05/24 17:32:43 avsm Exp $");
d34 1
a34 1
size_t
d42 1
a42 2
	size_t pos = 0;
	ssize_t res;
a49 1
			return 0;
d51 1
a51 2
			errno = EPIPE;
			return pos;
d53 1
a53 1
			pos += (u_int)res;
@


1.11
log
@deal with typing of write vs read in atomicio
@
text
@d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.10 2001/05/08 22:48:07 markus Exp $");
d32 1
a32 1
 * ensure all of data on socket comes through. f==read || f==write
@


1.10
log
@no need for xmalloc.h, thanks to espie@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.9 2001/03/02 18:54:30 deraadt Exp $");
d36 1
a36 1
	ssize_t (*f) ();
@


1.10.6.1
log
@upgrade to OpenSSH 3.7
@
text
@d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.12 2003/07/31 15:50:16 avsm Exp $");
d32 1
a32 1
 * ensure all of data on socket comes through. f==read || f==vwrite
d36 1
a36 1
	ssize_t (*f) (int, void *, size_t);
@


1.10.8.1
log
@upgrade to OpenSSH 3.7
@
text
@d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.12 2003/07/31 15:50:16 avsm Exp $");
d32 1
a32 1
 * ensure all of data on socket comes through. f==read || f==vwrite
d36 1
a36 1
	ssize_t (*f) (int, void *, size_t);
@


1.10.8.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@@


1.9
log
@make copyright lines the same format
@
text
@d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.8 2001/01/21 19:05:40 markus Exp $");
a28 1
#include "xmalloc.h"
@


1.9.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.10 2001/05/08 22:48:07 markus Exp $");
d29 1
@


1.9.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@@


1.8
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d2 1
a2 1
 * Copyright (c) 1995,1999 Theo de Raadt
d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.7 2000/10/18 18:04:02 markus Exp $");
@


1.7
log
@undo
@
text
@d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.5 2000/09/07 20:27:49 deraadt Exp $");
d30 1
a30 1
#include "ssh.h"
@


1.7.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.8 2001/01/21 19:05:40 markus Exp $");
d30 1
a30 1
#include "atomicio.h"
@


1.7.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.7.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d2 1
a2 1
 * Copyright (c) 1995,1999 Theo de Raadt.  All rights reserved.
d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.9 2001/03/02 18:54:30 deraadt Exp $");
@


1.7.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.7.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.10 2001/05/08 22:48:07 markus Exp $");
d29 1
@


1.6
log
@return number of characters processed; ok deraadt@@
@
text
@d52 1
a52 1
			return (pos);
@


1.5
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.4 2000/06/20 01:39:37 markus Exp $");
d52 1
a52 1
			return (res);
@


1.4
log
@OpenBSD tag
@
text
@d2 1
a2 1
 * Copyright (c) 1999 Theo de Raadt
d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.3 2000/03/16 20:56:13 markus Exp $");
@


1.3
log
@-pedantic: signed vs. unsigned, void*-arithm, etc
@
text
@d27 1
a27 1
RCSID("$Id: atomicio.c,v 1.2 2000/02/01 22:32:53 d Exp $");
@


1.3.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.4 2000/06/20 01:39:37 markus Exp $");
@


1.3.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 1
a2 1
 * Copyright (c) 1995,1999 Theo de Raadt
d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.7 2000/10/18 18:04:02 markus Exp $");
@


1.3.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.8 2001/01/21 19:05:40 markus Exp $");
d30 1
a30 1
#include "atomicio.h"
@


1.3.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d2 1
a2 1
 * Copyright (c) 1995,1999 Theo de Raadt.  All rights reserved.
d27 1
a27 1
RCSID("$OpenBSD: atomicio.c,v 1.9 2001/03/02 18:54:30 deraadt Exp $");
@


1.2
log
@int atomicio -> ssize_t (for alpha). ok deraadt@@
@
text
@d27 1
a27 1
RCSID("$Id: atomicio.c,v 1.1 1999/12/06 20:15:25 deraadt Exp $");
d36 1
a36 1
atomicio(f, fd, s, n)
d39 1
a39 1
	void *s;
d42 1
@


1.1
log
@move atomicio into it's own file.  wrap all socket write()s which were doing
write(sock, buf, len) != len, with atomicio() calls.
@
text
@d27 1
a27 1
RCSID("$Id: scp.c,v 1.21 1999/11/24 20:26:35 markus Exp $");
d35 1
a35 1
int
d37 1
a37 1
	int (*f) ();
d42 1
a42 1
	int res, pos = 0;
@

