head	1.279;
access;
symbols
	OPENBSD_6_1:1.270.0.4
	OPENBSD_6_1_BASE:1.270
	OPENBSD_6_0:1.259.0.4
	OPENBSD_6_0_BASE:1.259
	OPENBSD_5_9:1.250.0.2
	OPENBSD_5_9_BASE:1.250
	OPENBSD_5_8:1.239.0.2
	OPENBSD_5_8_BASE:1.239
	OPENBSD_5_7:1.232.0.2
	OPENBSD_5_7_BASE:1.232
	OPENBSD_5_6:1.220.0.4
	OPENBSD_5_6_BASE:1.220
	OPENBSD_5_5:1.218.0.4
	OPENBSD_5_5_BASE:1.218
	OPENBSD_5_4:1.204.0.2
	OPENBSD_5_4_BASE:1.204
	OPENBSD_5_3:1.196.0.2
	OPENBSD_5_3_BASE:1.196
	OPENBSD_5_2:1.194.0.4
	OPENBSD_5_2_BASE:1.194
	OPENBSD_5_1_BASE:1.194
	OPENBSD_5_1:1.194.0.2
	OPENBSD_5_0:1.193.0.2
	OPENBSD_5_0_BASE:1.193
	OPENBSD_4_9:1.190.0.2
	OPENBSD_4_9_BASE:1.190
	OPENBSD_4_8:1.187.0.2
	OPENBSD_4_8_BASE:1.187
	OPENBSD_4_7:1.183.0.2
	OPENBSD_4_7_BASE:1.183
	OPENBSD_4_6:1.177.0.4
	OPENBSD_4_6_BASE:1.177
	OPENBSD_4_5:1.176.0.2
	OPENBSD_4_5_BASE:1.176
	OPENBSD_4_4:1.167.0.2
	OPENBSD_4_4_BASE:1.167
	OPENBSD_4_3:1.165.0.2
	OPENBSD_4_3_BASE:1.165
	OPENBSD_4_2:1.162.0.2
	OPENBSD_4_2_BASE:1.162
	OPENBSD_4_1:1.161.0.2
	OPENBSD_4_1_BASE:1.161
	OPENBSD_4_0:1.159.0.4
	OPENBSD_4_0_BASE:1.159
	OPENBSD_3_9:1.148.0.2
	OPENBSD_3_9_BASE:1.148
	OPENBSD_3_8:1.143.0.2
	OPENBSD_3_8_BASE:1.143
	OPENBSD_3_7:1.139.0.2
	OPENBSD_3_7_BASE:1.139
	OPENBSD_3_6:1.134.0.2
	OPENBSD_3_6_BASE:1.134
	OPENBSD_3_5:1.128.0.2
	OPENBSD_3_5_BASE:1.128
	OPENBSD_3_4:1.121.0.2
	OPENBSD_3_4_BASE:1.121
	OPENBSD_3_3:1.102.0.2
	OPENBSD_3_3_BASE:1.102
	OPENBSD_3_2:1.100.0.2
	OPENBSD_3_2_BASE:1.100
	OPENBSD_3_1:1.95.0.2
	OPENBSD_3_1_BASE:1.95
	OPENBSD_3_0:1.91.0.2
	OPENBSD_3_0_BASE:1.91
	OPENBSD_2_9_BASE:1.76
	OPENBSD_2_9:1.76.0.2
	OPENBSD_2_8:1.49.0.2
	OPENBSD_2_8_BASE:1.49
	OPENBSD_2_7:1.31.0.2
	OPENBSD_2_7_BASE:1.31
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12;
locks; strict;
comment	@ * @;


1.279
date	2017.09.21.19.16.53;	author markus;	state Exp;
branches;
next	1.278;
commitid	trdBaE0Ug2XpXLIx;

1.278
date	2017.09.03.23.33.13;	author djm;	state Exp;
branches;
next	1.277;
commitid	q1zVRYKqwm3ABblA;

1.277
date	2017.05.30.18.58.37;	author bluhm;	state Exp;
branches;
next	1.276;
commitid	j7BllWBE4YuWyULn;

1.276
date	2017.05.20.02.35.47;	author djm;	state Exp;
branches;
next	1.275;
commitid	FZOhlVaUBOkCniKA;

1.275
date	2017.04.30.23.18.22;	author djm;	state Exp;
branches;
next	1.274;
commitid	JXK97829jBc4Iwod;

1.274
date	2017.04.30.23.15.04;	author djm;	state Exp;
branches;
next	1.273;
commitid	xiQciajHVystMZXG;

1.273
date	2017.04.30.23.11.45;	author djm;	state Exp;
branches;
next	1.272;
commitid	3llBg4zmLG3MyoI5;

1.272
date	2017.04.30.23.10.43;	author djm;	state Exp;
branches;
next	1.271;
commitid	I15vriCkYNtbTkea;

1.271
date	2017.04.28.03.20.27;	author dtucker;	state Exp;
branches;
next	1.270;
commitid	caVz6KsS81NStuJJ;

1.270
date	2017.03.10.04.27.32;	author djm;	state Exp;
branches;
next	1.269;
commitid	c45ROQNdXOYvK8Jn;

1.269
date	2017.03.10.03.24.48;	author dtucker;	state Exp;
branches;
next	1.268;
commitid	tbOBDaNtZ640dGui;

1.268
date	2017.02.03.23.01.19;	author djm;	state Exp;
branches;
next	1.267;
commitid	0GOZFYpYrdIWnKZ0;

1.267
date	2017.02.03.05.05.56;	author djm;	state Exp;
branches;
next	1.266;
commitid	qxeDJqCIRUEP0iRm;

1.266
date	2017.01.30.00.38.50;	author djm;	state Exp;
branches;
next	1.265;
commitid	bZXARe0Ma8icmYH0;

1.265
date	2017.01.30.00.34.01;	author djm;	state Exp;
branches;
next	1.264;
commitid	SPPdOH0UZzgHuQrL;

1.264
date	2017.01.06.09.27.52;	author djm;	state Exp;
branches;
next	1.263;
commitid	WgBQhqIyisSPHjEd;

1.263
date	2017.01.06.03.53.58;	author djm;	state Exp;
branches;
next	1.262;
commitid	eWmpvuZuBx8hWom1;

1.262
date	2016.10.25.04.08.13;	author jsg;	state Exp;
branches;
next	1.261;
commitid	7ttvG8vQjUu6V5xy;

1.261
date	2016.10.23.22.04.05;	author dtucker;	state Exp;
branches;
next	1.260;
commitid	v1YsIAvaioz9gRAs;

1.260
date	2016.08.25.23.56.51;	author djm;	state Exp;
branches;
next	1.259;
commitid	skbFx4w6mJ4NUtQk;

1.259
date	2016.07.22.03.35.11;	author djm;	state Exp;
branches;
next	1.258;
commitid	ZJf4lBy4cZbbCrzQ;

1.258
date	2016.07.20.10.45.27;	author naddy;	state Exp;
branches;
next	1.257;
commitid	ZInJNkRKhPqbM9fZ;

1.257
date	2016.07.15.00.24.30;	author djm;	state Exp;
branches;
next	1.256;
commitid	PAQPO8bvkonq4i81;

1.256
date	2016.06.03.04.09.38;	author dtucker;	state Exp;
branches;
next	1.255;
commitid	KcqPbgryCK0G1AKK;

1.255
date	2016.06.03.03.14.41;	author dtucker;	state Exp;
branches;
next	1.254;
commitid	ovpSdW3xBjKJO7iw;

1.254
date	2016.05.04.14.29.58;	author markus;	state Exp;
branches;
next	1.253;
commitid	9ydzI4x49mjHtEkc;

1.253
date	2016.05.04.12.21.53;	author markus;	state Exp;
branches;
next	1.252;
commitid	cxcRWNRjlPdtRVOI;

1.252
date	2016.04.15.00.30.19;	author djm;	state Exp;
branches;
next	1.251;
commitid	my9uXywHtGIyCVPH;

1.251
date	2016.04.06.06.42.17;	author djm;	state Exp;
branches;
next	1.250;
commitid	His5Dv7TLGORp9Rs;

1.250
date	2016.02.08.23.40.12;	author djm;	state Exp;
branches;
next	1.249;
commitid	UfTqGuD9ArPs4C6W;

1.249
date	2016.01.29.02.54.45;	author dtucker;	state Exp;
branches;
next	1.248;
commitid	PeK9nimTzIqJuIOX;

1.248
date	2016.01.14.16.17.40;	author markus;	state Exp;
branches;
next	1.247;
commitid	W9ye0gltieEl87AJ;

1.247
date	2016.01.14.14.34.34;	author deraadt;	state Exp;
branches;
next	1.246;
commitid	ZDYRhanUMbi82fa7;

1.246
date	2015.11.15.22.26.49;	author jcs;	state Exp;
branches;
next	1.245;
commitid	mjNGB5AAtJeHDag2;

1.245
date	2015.10.27.08.54.52;	author djm;	state Exp;
branches;
next	1.244;
commitid	sjKkz6VxgHMYwFAQ;

1.244
date	2015.10.27.00.49.53;	author djm;	state Exp;
branches;
next	1.243;
commitid	aRhkP917OTIhVCca;

1.243
date	2015.10.25.23.14.03;	author dtucker;	state Exp;
branches;
next	1.242;
commitid	peGpfgXy7lm0e1sV;

1.242
date	2015.10.07.15.59.12;	author djm;	state Exp;
branches;
next	1.241;
commitid	Mvg3IVY4l5gpDOr5;

1.241
date	2015.09.24.06.15.11;	author djm;	state Exp;
branches;
next	1.240;
commitid	nGLvQjqT3Z8tECCC;

1.240
date	2015.08.21.23.53.08;	author djm;	state Exp;
branches;
next	1.239;
commitid	RXCVtp5Xh7EW47YJ;

1.239
date	2015.07.30.00.01.34;	author djm;	state Exp;
branches
	1.239.2.1;
next	1.238;
commitid	YReS3Mui4FCZvL7z;

1.238
date	2015.07.10.06.21.53;	author markus;	state Exp;
branches;
next	1.237;
commitid	iQTtbsbSVdO9zivU;

1.237
date	2015.06.26.05.13.20;	author djm;	state Exp;
branches;
next	1.236;
commitid	aatIZb7eUXNmlgZ5;

1.236
date	2015.05.22.04.45.52;	author djm;	state Exp;
branches;
next	1.235;
commitid	9oNeW1etk8sSUbSN;

1.235
date	2015.05.04.06.10.48;	author djm;	state Exp;
branches;
next	1.234;
commitid	KfZDG8r2EByk0YBR;

1.234
date	2015.04.24.01.36.00;	author deraadt;	state Exp;
branches;
next	1.233;
commitid	LHkUmZjv49ojnnuH;

1.233
date	2015.03.30.00.00.29;	author djm;	state Exp;
branches;
next	1.232;
commitid	7BrLvfAOSTtb6R35;

1.232
date	2015.02.16.22.13.32;	author djm;	state Exp;
branches
	1.232.2.1;
next	1.231;
commitid	vWL0dluw4oITNbM8;

1.231
date	2015.02.02.07.41.40;	author djm;	state Exp;
branches;
next	1.230;
commitid	BbR5A5ZMa2IOA9vD;

1.230
date	2015.01.30.11.43.14;	author djm;	state Exp;
branches;
next	1.229;
commitid	NHgy1atCg6tWjTbF;

1.229
date	2015.01.26.03.04.45;	author djm;	state Exp;
branches;
next	1.228;
commitid	Xp9DfQmHQHbZ815k;

1.228
date	2015.01.16.06.40.12;	author deraadt;	state Exp;
branches;
next	1.227;
commitid	Uu5nFG3wCl0LACBb;

1.227
date	2015.01.15.09.40.00;	author djm;	state Exp;
branches;
next	1.226;
commitid	akRUKeZEbb3ylbKG;

1.226
date	2015.01.13.07.39.19;	author djm;	state Exp;
branches;
next	1.225;
commitid	oriBpre3xTnTQZ4b;

1.225
date	2015.01.08.13.44.36;	author djm;	state Exp;
branches;
next	1.224;
commitid	C7jHDoo2nTKYVLlz;

1.224
date	2014.12.21.22.27.56;	author djm;	state Exp;
branches;
next	1.223;
commitid	EbtriidyZdsmXksl;

1.223
date	2014.12.04.02.24.32;	author djm;	state Exp;
branches;
next	1.222;
commitid	0YGyOuIh3H3xTolw;

1.222
date	2014.10.24.02.01.20;	author lteo;	state Exp;
branches;
next	1.221;
commitid	K0sGF4uE2LYJ8DMA;

1.221
date	2014.10.08.22.20.25;	author djm;	state Exp;
branches;
next	1.220;
commitid	FjkSE9L51UbRANmo;

1.220
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.219;
commitid	z7plx8Gkj6l2sxem;

1.219
date	2014.04.23.12.42.34;	author djm;	state Exp;
branches;
next	1.218;

1.218
date	2014.02.23.20.11.36;	author djm;	state Exp;
branches;
next	1.217;

1.217
date	2014.02.22.01.32.19;	author djm;	state Exp;
branches;
next	1.216;

1.216
date	2014.01.29.06.18.35;	author djm;	state Exp;
branches;
next	1.215;

1.215
date	2013.12.06.13.39.49;	author markus;	state Exp;
branches;
next	1.214;

1.214
date	2013.11.20.20.54.10;	author deraadt;	state Exp;
branches;
next	1.213;

1.213
date	2013.10.24.00.51.48;	author dtucker;	state Exp;
branches;
next	1.212;

1.212
date	2013.10.23.03.05.19;	author djm;	state Exp;
branches;
next	1.211;

1.211
date	2013.10.23.03.03.07;	author djm;	state Exp;
branches;
next	1.210;

1.210
date	2013.10.20.06.19.27;	author djm;	state Exp;
branches;
next	1.209;

1.209
date	2013.10.16.22.49.38;	author djm;	state Exp;
branches;
next	1.208;

1.208
date	2013.10.16.02.31.45;	author djm;	state Exp;
branches;
next	1.207;

1.207
date	2013.10.14.23.28.23;	author djm;	state Exp;
branches;
next	1.206;

1.206
date	2013.10.14.22.22.02;	author djm;	state Exp;
branches;
next	1.205;

1.205
date	2013.08.20.00.11.37;	author djm;	state Exp;
branches;
next	1.204;

1.204
date	2013.06.10.19.19.44;	author dtucker;	state Exp;
branches;
next	1.203;

1.203
date	2013.06.05.22.00.28;	author dtucker;	state Exp;
branches;
next	1.202;

1.202
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.201;

1.201
date	2013.05.16.10.43.34;	author dtucker;	state Exp;
branches;
next	1.200;

1.200
date	2013.05.16.09.12.31;	author dtucker;	state Exp;
branches;
next	1.199;

1.199
date	2013.05.16.04.27.50;	author djm;	state Exp;
branches;
next	1.198;

1.198
date	2013.05.16.02.00.34;	author dtucker;	state Exp;
branches;
next	1.197;

1.197
date	2013.03.06.23.36.53;	author djm;	state Exp;
branches;
next	1.196;

1.196
date	2013.02.22.04.45.08;	author dtucker;	state Exp;
branches;
next	1.195;

1.195
date	2013.02.17.23.16.57;	author dtucker;	state Exp;
branches;
next	1.194;

1.194
date	2011.09.23.07.45.05;	author markus;	state Exp;
branches;
next	1.193;

1.193
date	2011.05.24.07.15.47;	author djm;	state Exp;
branches;
next	1.192;

1.192
date	2011.05.06.21.34.32;	author djm;	state Exp;
branches;
next	1.191;

1.191
date	2011.05.06.21.31.38;	author djm;	state Exp;
branches;
next	1.190;

1.190
date	2010.11.13.23.27.50;	author djm;	state Exp;
branches;
next	1.189;

1.189
date	2010.09.22.05.01.29;	author djm;	state Exp;
branches;
next	1.188;

1.188
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.187;

1.187
date	2010.07.19.09.15.12;	author djm;	state Exp;
branches;
next	1.186;

1.186
date	2010.06.25.23.15.36;	author djm;	state Exp;
branches;
next	1.185;

1.185
date	2010.06.25.07.14.46;	author djm;	state Exp;
branches;
next	1.184;

1.184
date	2010.05.16.12.55.51;	author markus;	state Exp;
branches;
next	1.183;

1.183
date	2010.02.08.10.50.20;	author markus;	state Exp;
branches;
next	1.182;

1.182
date	2010.01.09.23.04.13;	author dtucker;	state Exp;
branches;
next	1.181;

1.181
date	2009.12.29.16.38.41;	author stevesk;	state Exp;
branches;
next	1.180;

1.180
date	2009.12.25.19.40.21;	author stevesk;	state Exp;
branches;
next	1.179;

1.179
date	2009.10.28.16.38.18;	author reyk;	state Exp;
branches;
next	1.178;

1.178
date	2009.10.08.14.03.41;	author markus;	state Exp;
branches;
next	1.177;

1.177
date	2009.06.27.09.35.06;	author andreas;	state Exp;
branches;
next	1.176;

1.176
date	2009.02.12.03.00.56;	author djm;	state Exp;
branches;
next	1.175;

1.175
date	2009.01.22.10.02.34;	author djm;	state Exp;
branches;
next	1.174;

1.174
date	2009.01.15.17.38.43;	author stevesk;	state Exp;
branches;
next	1.173;

1.173
date	2008.12.09.02.58.16;	author djm;	state Exp;
branches;
next	1.172;

1.172
date	2008.11.04.19.18.00;	author stevesk;	state Exp;
branches;
next	1.171;

1.171
date	2008.11.04.08.22.13;	author djm;	state Exp;
branches;
next	1.170;

1.170
date	2008.11.03.02.44.41;	author stevesk;	state Exp;
branches;
next	1.169;

1.169
date	2008.11.03.01.07.02;	author stevesk;	state Exp;
branches;
next	1.168;

1.168
date	2008.11.01.17.40.33;	author stevesk;	state Exp;
branches;
next	1.167;

1.167
date	2008.06.26.11.46.31;	author grunk;	state Exp;
branches;
next	1.166;

1.166
date	2008.06.11.21.01.35;	author grunk;	state Exp;
branches;
next	1.165;

1.165
date	2008.01.19.23.09.49;	author djm;	state Exp;
branches;
next	1.164;

1.164
date	2007.12.31.10.41.31;	author dtucker;	state Exp;
branches;
next	1.163;

1.163
date	2007.10.22.19.10.24;	author markus;	state Exp;
branches;
next	1.162;

1.162
date	2007.03.20.03.56.12;	author tedu;	state Exp;
branches;
next	1.161;

1.161
date	2007.01.21.01.45.35;	author stevesk;	state Exp;
branches;
next	1.160;

1.160
date	2007.01.17.23.22.52;	author dtucker;	state Exp;
branches;
next	1.159;

1.159
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.158;

1.158
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.157;

1.157
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.156;

1.156
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.155;

1.155
date	2006.07.12.22.28.52;	author stevesk;	state Exp;
branches;
next	1.154;

1.154
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.153;

1.153
date	2006.07.11.18.50.48;	author markus;	state Exp;
branches;
next	1.152;

1.152
date	2006.07.05.02.42.09;	author stevesk;	state Exp;
branches;
next	1.151;

1.151
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.150;

1.150
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.149;

1.149
date	2006.03.19.02.24.05;	author djm;	state Exp;
branches;
next	1.148;

1.148
date	2006.02.22.00.04.44;	author stevesk;	state Exp;
branches
	1.148.2.1;
next	1.147;

1.147
date	2006.02.20.17.19.54;	author stevesk;	state Exp;
branches;
next	1.146;

1.146
date	2006.02.12.10.44.18;	author djm;	state Exp;
branches;
next	1.145;

1.145
date	2005.12.08.18.34.11;	author reyk;	state Exp;
branches;
next	1.144;

1.144
date	2005.12.06.22.38.27;	author reyk;	state Exp;
branches;
next	1.143;

1.143
date	2005.07.30.02.03.47;	author djm;	state Exp;
branches
	1.143.2.1;
next	1.142;

1.142
date	2005.07.17.07.17.55;	author djm;	state Exp;
branches;
next	1.141;

1.141
date	2005.06.08.11.25.09;	author djm;	state Exp;
branches;
next	1.140;

1.140
date	2005.05.16.15.30.51;	author markus;	state Exp;
branches;
next	1.139;

1.139
date	2005.03.10.22.01.05;	author deraadt;	state Exp;
branches
	1.139.2.1;
next	1.138;

1.138
date	2005.03.10.10.15.02;	author dtucker;	state Exp;
branches;
next	1.137;

1.137
date	2005.03.04.08.48.06;	author djm;	state Exp;
branches;
next	1.136;

1.136
date	2005.03.01.10.40.26;	author djm;	state Exp;
branches;
next	1.135;

1.135
date	2005.03.01.10.09.52;	author djm;	state Exp;
branches;
next	1.134;

1.134
date	2004.07.11.17.48.47;	author deraadt;	state Exp;
branches
	1.134.2.1;
next	1.133;

1.133
date	2004.06.17.15.10.14;	author djm;	state Exp;
branches;
next	1.132;

1.132
date	2004.06.13.15.03.02;	author djm;	state Exp;
branches;
next	1.131;

1.131
date	2004.05.27.00.50.13;	author dtucker;	state Exp;
branches;
next	1.130;

1.130
date	2004.04.27.09.46.36;	author djm;	state Exp;
branches;
next	1.129;

1.129
date	2004.04.18.23.10.26;	author djm;	state Exp;
branches;
next	1.128;

1.128
date	2004.03.05.10.53.58;	author markus;	state Exp;
branches
	1.128.2.1;
next	1.127;

1.127
date	2003.12.16.15.49.51;	author markus;	state Exp;
branches;
next	1.126;

1.126
date	2003.12.09.21.53.36;	author markus;	state Exp;
branches;
next	1.125;

1.125
date	2003.11.12.16.39.58;	author jakob;	state Exp;
branches;
next	1.124;

1.124
date	2003.10.14.19.42.10;	author jakob;	state Exp;
branches;
next	1.123;

1.123
date	2003.10.11.08.24.07;	author markus;	state Exp;
branches;
next	1.122;

1.122
date	2003.10.08.15.21.24;	author markus;	state Exp;
branches;
next	1.121;

1.121
date	2003.09.01.18.15.50;	author markus;	state Exp;
branches
	1.121.2.1;
next	1.120;

1.120
date	2003.09.01.12.50.46;	author markus;	state Exp;
branches;
next	1.119;

1.119
date	2003.08.28.12.54.34;	author markus;	state Exp;
branches;
next	1.118;

1.118
date	2003.08.22.10.56.09;	author markus;	state Exp;
branches;
next	1.117;

1.117
date	2003.08.13.09.07.09;	author markus;	state Exp;
branches;
next	1.116;

1.116
date	2003.08.13.08.46.30;	author markus;	state Exp;
branches;
next	1.115;

1.115
date	2003.07.22.13.35.22;	author markus;	state Exp;
branches;
next	1.114;

1.114
date	2003.07.03.08.09.05;	author djm;	state Exp;
branches;
next	1.113;

1.113
date	2003.06.26.20.08.33;	author markus;	state Exp;
branches;
next	1.112;

1.112
date	2003.05.16.03.27.12;	author djm;	state Exp;
branches;
next	1.111;

1.111
date	2003.05.15.14.55.25;	author djm;	state Exp;
branches;
next	1.110;

1.110
date	2003.05.15.14.02.47;	author jakob;	state Exp;
branches;
next	1.109;

1.109
date	2003.05.15.04.08.44;	author jakob;	state Exp;
branches;
next	1.108;

1.108
date	2003.05.15.01.48.10;	author jakob;	state Exp;
branches;
next	1.107;

1.107
date	2003.05.14.18.16.20;	author jakob;	state Exp;
branches;
next	1.106;

1.106
date	2003.04.09.12.00.37;	author djm;	state Exp;
branches;
next	1.105;

1.105
date	2003.04.02.09.48.07;	author markus;	state Exp;
branches;
next	1.104;

1.104
date	2003.04.01.10.22.21;	author markus;	state Exp;
branches;
next	1.103;

1.103
date	2003.04.01.10.10.23;	author markus;	state Exp;
branches;
next	1.102;

1.102
date	2003.02.05.09.02.28;	author markus;	state Exp;
branches
	1.102.2.1;
next	1.101;

1.101
date	2002.11.07.22.08.07;	author markus;	state Exp;
branches;
next	1.100;

1.100
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches
	1.100.2.1;
next	1.99;

1.99
date	2002.06.10.17.45.20;	author stevesk;	state Exp;
branches;
next	1.98;

1.98
date	2002.06.08.12.46.14;	author markus;	state Exp;
branches;
next	1.97;

1.97
date	2002.06.08.05.40.01;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2002.06.08.05.17.01;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2002.02.04.12.15.25;	author markus;	state Exp;
branches
	1.95.2.1;
next	1.94;

1.94
date	2002.01.04.17.59.17;	author stevesk;	state Exp;
branches;
next	1.93;

1.93
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2001.11.17.19.14.34;	author stevesk;	state Exp;
branches;
next	1.91;

1.91
date	2001.10.01.21.51.16;	author markus;	state Exp;
branches
	1.91.2.1;
next	1.90;

1.90
date	2001.09.19.19.24.18;	author stevesk;	state Exp;
branches;
next	1.89;

1.89
date	2001.09.03.20.58.33;	author stevesk;	state Exp;
branches;
next	1.88;

1.88
date	2001.08.30.16.04.35;	author stevesk;	state Exp;
branches;
next	1.87;

1.87
date	2001.08.28.09.51.26;	author markus;	state Exp;
branches;
next	1.86;

1.86
date	2001.08.01.22.03.33;	author markus;	state Exp;
branches;
next	1.85;

1.85
date	2001.07.31.09.28.44;	author jakob;	state Exp;
branches;
next	1.84;

1.84
date	2001.07.25.14.35.18;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2001.07.22.22.04.19;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2001.06.26.16.15.23;	author dugsong;	state Exp;
branches;
next	1.81;

1.81
date	2001.06.23.02.34.30;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2001.06.08.15.25.40;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2001.05.24.18.57.53;	author stevesk;	state Exp;
branches;
next	1.78;

1.78
date	2001.05.18.14.13.28;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2001.04.30.11.18.51;	author markus;	state Exp;
branches;
next	1.76;

1.76
date	2001.04.17.10.53.25;	author markus;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2001.04.15.21.28.35;	author stevesk;	state Exp;
branches;
next	1.74;

1.74
date	2001.04.12.20.09.37;	author stevesk;	state Exp;
branches;
next	1.73;

1.73
date	2001.04.12.19.39.27;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2001.04.12.19.15.25;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2001.04.07.08.55.17;	author markus;	state Exp;
branches;
next	1.70;

1.70
date	2001.04.02.14.20.23;	author stevesk;	state Exp;
branches;
next	1.69;

1.69
date	2001.03.20.19.10.16;	author markus;	state Exp;
branches;
next	1.68;

1.68
date	2001.03.19.17.07.23;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2001.03.10.17.51.04;	author markus;	state Exp;
branches;
next	1.66;

1.66
date	2001.03.10.12.53.52;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2001.03.08.00.15.47;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2001.03.04.17.42.28;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2001.02.24.10.37.55;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2001.02.11.12.59.25;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2001.02.08.14.39.36;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2001.01.28.20.36.16;	author stevesk;	state Exp;
branches;
next	1.59;

1.59
date	2001.01.22.23.06.39;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2001.01.21.19.05.53;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2001.01.20.23.02.07;	author djm;	state Exp;
branches;
next	1.56;

1.56
date	2001.01.20.17.59.40;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2001.01.19.15.55.11;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2001.01.18.16.20.22;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2001.01.07.11.28.05;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2000.12.27.12.30.19;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2000.12.19.23.17.57;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2000.11.12.19.50.37;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2000.10.11.20.27.23;	author markus;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2000.10.11.20.14.39;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2000.09.07.21.13.37;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2000.09.07.20.27.53;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2000.08.02.17.27.04;	author provos;	state Exp;
branches;
next	1.44;

1.44
date	2000.08.02.16.27.16;	author provos;	state Exp;
branches;
next	1.43;

1.43
date	2000.07.14.22.59.46;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2000.07.13.22.53.21;	author provos;	state Exp;
branches;
next	1.41;

1.41
date	2000.07.11.19.17.44;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2000.07.10.16.27.05;	author ho;	state Exp;
branches;
next	1.39;

1.39
date	2000.07.09.01.27.33;	author ho;	state Exp;
branches;
next	1.38;

1.38
date	2000.07.08.23.17.31;	author provos;	state Exp;
branches;
next	1.37;

1.37
date	2000.06.20.01.39.43;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2000.06.18.00.57.48;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2000.05.31.09.20.38;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2000.05.31.06.36.40;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2000.05.29.20.20.46;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2000.05.22.18.42.01;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2000.05.08.17.12.15;	author markus;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2000.05.06.17.45.36;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2000.05.02.22.18.04;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.26.22.43.14;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.26.20.56.29;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.14.10.30.32;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2000.04.12.07.45.44;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2000.03.28.20.31.28;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.28.19.51.58;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	99.12.01.13.59.15;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	99.11.24.20.24.09;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	99.11.24.20.19.37;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	99.11.24.19.53.49;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	99.11.24.00.26.02;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.11.23.22.25.54;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	99.11.22.21.52.41;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	99.11.19.16.04.17;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	99.11.14.21.45.07;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	99.11.10.23.36.44;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	99.10.15.21.39.02;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	99.10.12.21.04.21;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	99.10.06.20.07.42;	author dugsong;	state Exp;
branches;
next	1.9;

1.9
date	99.10.03.22.01.39;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	99.10.03.21.50.03;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	99.09.30.08.03.39;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.09.30.05.03.05;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.09.29.18.16.19;	author dugsong;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.17.52.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.00.10.16;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.04.45.36;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.37;	author deraadt;	state Exp;
branches;
next	;

1.31.2.1
date	2000.06.12.02.37.34;	author jason;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2000.09.01.18.23.21;	author jason;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2000.11.08.21.31.07;	author jason;	state Exp;
branches;
next	1.31.2.4;

1.31.2.4
date	2001.03.12.15.44.13;	author jason;	state Exp;
branches;
next	1.31.2.5;

1.31.2.5
date	2001.03.21.18.52.57;	author jason;	state Exp;
branches;
next	;

1.49.2.1
date	2001.02.16.20.13.10;	author jason;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2001.02.19.17.19.12;	author jason;	state Exp;
branches;
next	1.49.2.3;

1.49.2.3
date	2001.03.21.19.46.27;	author jason;	state Exp;
branches;
next	1.49.2.4;

1.49.2.4
date	2001.05.07.21.09.32;	author jason;	state Exp;
branches;
next	1.49.2.5;

1.49.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.49.2.6;

1.49.2.6
date	2001.11.15.00.14.59;	author miod;	state Exp;
branches;
next	1.49.2.7;

1.49.2.7
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.76.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.76.2.2;

1.76.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.76.2.3;

1.76.2.3
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	;

1.91.2.1
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.91.2.2;

1.91.2.2
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	;

1.95.2.1
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.95.2.2;

1.95.2.2
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.100.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.100.2.2;

1.100.2.2
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.102.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.102.2.2;

1.102.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.121.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.121.2.2;

1.121.2.2
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.128.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	1.128.2.2;

1.128.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.134.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.134.2.2;

1.134.2.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	1.134.2.3;

1.134.2.3
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.139.2.1
date	2005.09.04.18.40.02;	author brad;	state Exp;
branches;
next	1.139.2.2;

1.139.2.2
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.143.2.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.143.2.2;

1.143.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	;

1.148.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	;

1.232.2.1
date	2016.01.14.14.48.36;	author sthen;	state Exp;
branches;
next	;
commitid	gQA5KCdbB521AiGx;

1.239.2.1
date	2016.01.14.14.48.18;	author sthen;	state Exp;
branches;
next	;
commitid	A7IQpw6n5l3sEY5z;


desc
@@


1.279
log
@Add 'reverse' dynamic forwarding which combines dynamic forwarding
(-D) with remote forwarding (-R) where the remote-forwarded port
expects SOCKS-requests.

The SSH server code is unchanged and the parsing happens at the SSH
clients side. Thus the full SOCKS-request is sent over the forwarded
channel and the client parses c->output. Parsing happens in
channel_before_prepare_select(), _before_ the select bitmask is
computed in the pre[] handlers, but after network input processing
in the post[] handlers.

help and ok djm@@
@
text
@/* $OpenBSD: readconf.c,v 1.278 2017/09/03 23:33:13 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Functions for reading the configuration files.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/un.h>

#include <netinet/in.h>
#include <netinet/ip.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <glob.h>
#include <netdb.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <util.h>
#include <vis.h>

#include "xmalloc.h"
#include "ssh.h"
#include "compat.h"
#include "cipher.h"
#include "pathnames.h"
#include "log.h"
#include "sshkey.h"
#include "misc.h"
#include "readconf.h"
#include "match.h"
#include "kex.h"
#include "mac.h"
#include "uidswap.h"
#include "myproposal.h"
#include "digest.h"

/* Format of the configuration file:

   # Configuration data is parsed as follows:
   #  1. command line options
   #  2. user-specific file
   #  3. system-wide file
   # Any configuration value is only changed the first time it is set.
   # Thus, host-specific definitions should be at the beginning of the
   # configuration file, and defaults at the end.

   # Host-specific declarations.  These may override anything above.  A single
   # host may match multiple declarations; these are processed in the order
   # that they are given in.

   Host *.ngs.fi ngs.fi
     User foo

   Host fake.com
     HostName another.host.name.real.org
     User blaah
     Port 34289
     ForwardX11 no
     ForwardAgent no

   Host books.com
     RemoteForward 9999 shadows.cs.hut.fi:9999
     Ciphers 3des-cbc

   Host fascist.blob.com
     Port 23123
     User tylonen
     PasswordAuthentication no

   Host puukko.hut.fi
     User t35124p
     ProxyCommand ssh-proxy %h %p

   Host *.fr
     PublicKeyAuthentication no

   Host *.su
     Ciphers aes128-ctr
     PasswordAuthentication no

   Host vpn.fake.com
     Tunnel yes
     TunnelDevice 3

   # Defaults for various options
   Host *
     ForwardAgent no
     ForwardX11 no
     PasswordAuthentication yes
     RSAAuthentication yes
     RhostsRSAAuthentication yes
     StrictHostKeyChecking yes
     TcpKeepAlive no
     IdentityFile ~/.ssh/identity
     Port 22
     EscapeChar ~

*/

static int read_config_file_depth(const char *filename, struct passwd *pw,
    const char *host, const char *original_host, Options *options,
    int flags, int *activep, int depth);
static int process_config_line_depth(Options *options, struct passwd *pw,
    const char *host, const char *original_host, char *line,
    const char *filename, int linenum, int *activep, int flags, int depth);

/* Keyword tokens. */

typedef enum {
	oBadOption,
	oHost, oMatch, oInclude,
	oForwardAgent, oForwardX11, oForwardX11Trusted, oForwardX11Timeout,
	oGatewayPorts, oExitOnForwardFailure,
	oPasswordAuthentication, oRSAAuthentication,
	oChallengeResponseAuthentication, oXAuthLocation,
	oIdentityFile, oHostName, oPort, oCipher, oRemoteForward, oLocalForward,
	oCertificateFile, oAddKeysToAgent, oIdentityAgent,
	oUser, oEscapeChar, oRhostsRSAAuthentication, oProxyCommand,
	oGlobalKnownHostsFile, oUserKnownHostsFile, oConnectionAttempts,
	oBatchMode, oCheckHostIP, oStrictHostKeyChecking, oCompression,
	oCompressionLevel, oTCPKeepAlive, oNumberOfPasswordPrompts,
	oUsePrivilegedPort, oLogFacility, oLogLevel, oCiphers, oMacs,
	oPubkeyAuthentication,
	oKbdInteractiveAuthentication, oKbdInteractiveDevices, oHostKeyAlias,
	oDynamicForward, oPreferredAuthentications, oHostbasedAuthentication,
	oHostKeyAlgorithms, oBindAddress, oPKCS11Provider,
	oClearAllForwardings, oNoHostAuthenticationForLocalhost,
	oEnableSSHKeysign, oRekeyLimit, oVerifyHostKeyDNS, oConnectTimeout,
	oAddressFamily, oGssAuthentication, oGssDelegateCreds,
	oServerAliveInterval, oServerAliveCountMax, oIdentitiesOnly,
	oSendEnv, oControlPath, oControlMaster, oControlPersist,
	oHashKnownHosts,
	oTunnel, oTunnelDevice,
	oLocalCommand, oPermitLocalCommand, oRemoteCommand,
	oVisualHostKey,
	oKexAlgorithms, oIPQoS, oRequestTTY, oIgnoreUnknown, oProxyUseFdpass,
	oCanonicalDomains, oCanonicalizeHostname, oCanonicalizeMaxDots,
	oCanonicalizeFallbackLocal, oCanonicalizePermittedCNAMEs,
	oStreamLocalBindMask, oStreamLocalBindUnlink, oRevokedHostKeys,
	oFingerprintHash, oUpdateHostkeys, oHostbasedKeyTypes,
	oPubkeyAcceptedKeyTypes, oProxyJump,
	oIgnore, oIgnoredUnknownOption, oDeprecated, oUnsupported
} OpCodes;

/* Textual representations of the tokens. */

static struct {
	const char *name;
	OpCodes opcode;
} keywords[] = {
	/* Deprecated options */
	{ "protocol", oIgnore }, /* NB. silently ignored */
	{ "cipher", oDeprecated },
	{ "fallbacktorsh", oDeprecated },
	{ "globalknownhostsfile2", oDeprecated },
	{ "rhostsauthentication", oDeprecated },
	{ "userknownhostsfile2", oDeprecated },
	{ "useroaming", oDeprecated },
	{ "usersh", oDeprecated },

	/* Unsupported options */
	{ "afstokenpassing", oUnsupported },
	{ "kerberosauthentication", oUnsupported },
	{ "kerberostgtpassing", oUnsupported },

	/* Sometimes-unsupported options */
#if defined(GSSAPI)
	{ "gssapiauthentication", oGssAuthentication },
	{ "gssapidelegatecredentials", oGssDelegateCreds },
# else
	{ "gssapiauthentication", oUnsupported },
	{ "gssapidelegatecredentials", oUnsupported },
#endif
#ifdef ENABLE_PKCS11
	{ "smartcarddevice", oPKCS11Provider },
	{ "pkcs11provider", oPKCS11Provider },
# else
	{ "smartcarddevice", oUnsupported },
	{ "pkcs11provider", oUnsupported },
#endif
	{ "rsaauthentication", oUnsupported },
	{ "rhostsrsaauthentication", oUnsupported },
	{ "compressionlevel", oUnsupported },

	{ "forwardagent", oForwardAgent },
	{ "forwardx11", oForwardX11 },
	{ "forwardx11trusted", oForwardX11Trusted },
	{ "forwardx11timeout", oForwardX11Timeout },
	{ "exitonforwardfailure", oExitOnForwardFailure },
	{ "xauthlocation", oXAuthLocation },
	{ "gatewayports", oGatewayPorts },
	{ "useprivilegedport", oUsePrivilegedPort },
	{ "passwordauthentication", oPasswordAuthentication },
	{ "kbdinteractiveauthentication", oKbdInteractiveAuthentication },
	{ "kbdinteractivedevices", oKbdInteractiveDevices },
	{ "pubkeyauthentication", oPubkeyAuthentication },
	{ "dsaauthentication", oPubkeyAuthentication },		    /* alias */
	{ "hostbasedauthentication", oHostbasedAuthentication },
	{ "challengeresponseauthentication", oChallengeResponseAuthentication },
	{ "skeyauthentication", oChallengeResponseAuthentication }, /* alias */
	{ "tisauthentication", oChallengeResponseAuthentication },  /* alias */
	{ "identityfile", oIdentityFile },
	{ "identityfile2", oIdentityFile },			/* obsolete */
	{ "identitiesonly", oIdentitiesOnly },
	{ "certificatefile", oCertificateFile },
	{ "addkeystoagent", oAddKeysToAgent },
	{ "identityagent", oIdentityAgent },
	{ "hostname", oHostName },
	{ "hostkeyalias", oHostKeyAlias },
	{ "proxycommand", oProxyCommand },
	{ "port", oPort },
	{ "ciphers", oCiphers },
	{ "macs", oMacs },
	{ "remoteforward", oRemoteForward },
	{ "localforward", oLocalForward },
	{ "user", oUser },
	{ "host", oHost },
	{ "match", oMatch },
	{ "escapechar", oEscapeChar },
	{ "globalknownhostsfile", oGlobalKnownHostsFile },
	{ "userknownhostsfile", oUserKnownHostsFile },
	{ "connectionattempts", oConnectionAttempts },
	{ "batchmode", oBatchMode },
	{ "checkhostip", oCheckHostIP },
	{ "stricthostkeychecking", oStrictHostKeyChecking },
	{ "compression", oCompression },
	{ "tcpkeepalive", oTCPKeepAlive },
	{ "keepalive", oTCPKeepAlive },				/* obsolete */
	{ "numberofpasswordprompts", oNumberOfPasswordPrompts },
	{ "syslogfacility", oLogFacility },
	{ "loglevel", oLogLevel },
	{ "dynamicforward", oDynamicForward },
	{ "preferredauthentications", oPreferredAuthentications },
	{ "hostkeyalgorithms", oHostKeyAlgorithms },
	{ "bindaddress", oBindAddress },
	{ "clearallforwardings", oClearAllForwardings },
	{ "enablesshkeysign", oEnableSSHKeysign },
	{ "verifyhostkeydns", oVerifyHostKeyDNS },
	{ "nohostauthenticationforlocalhost", oNoHostAuthenticationForLocalhost },
	{ "rekeylimit", oRekeyLimit },
	{ "connecttimeout", oConnectTimeout },
	{ "addressfamily", oAddressFamily },
	{ "serveraliveinterval", oServerAliveInterval },
	{ "serveralivecountmax", oServerAliveCountMax },
	{ "sendenv", oSendEnv },
	{ "controlpath", oControlPath },
	{ "controlmaster", oControlMaster },
	{ "controlpersist", oControlPersist },
	{ "hashknownhosts", oHashKnownHosts },
	{ "include", oInclude },
	{ "tunnel", oTunnel },
	{ "tunneldevice", oTunnelDevice },
	{ "localcommand", oLocalCommand },
	{ "permitlocalcommand", oPermitLocalCommand },
	{ "remotecommand", oRemoteCommand },
	{ "visualhostkey", oVisualHostKey },
	{ "kexalgorithms", oKexAlgorithms },
	{ "ipqos", oIPQoS },
	{ "requesttty", oRequestTTY },
	{ "proxyusefdpass", oProxyUseFdpass },
	{ "canonicaldomains", oCanonicalDomains },
	{ "canonicalizefallbacklocal", oCanonicalizeFallbackLocal },
	{ "canonicalizehostname", oCanonicalizeHostname },
	{ "canonicalizemaxdots", oCanonicalizeMaxDots },
	{ "canonicalizepermittedcnames", oCanonicalizePermittedCNAMEs },
	{ "streamlocalbindmask", oStreamLocalBindMask },
	{ "streamlocalbindunlink", oStreamLocalBindUnlink },
	{ "revokedhostkeys", oRevokedHostKeys },
	{ "fingerprinthash", oFingerprintHash },
	{ "updatehostkeys", oUpdateHostkeys },
	{ "hostbasedkeytypes", oHostbasedKeyTypes },
	{ "pubkeyacceptedkeytypes", oPubkeyAcceptedKeyTypes },
	{ "ignoreunknown", oIgnoreUnknown },
	{ "proxyjump", oProxyJump },

	{ NULL, oBadOption }
};

/*
 * Adds a local TCP/IP port forward to options.  Never returns if there is an
 * error.
 */

void
add_local_forward(Options *options, const struct Forward *newfwd)
{
	struct Forward *fwd;
	extern uid_t original_real_uid;
	int i;

	if (!bind_permitted(newfwd->listen_port, original_real_uid) &&
	    newfwd->listen_path == NULL)
		fatal("Privileged ports can only be forwarded by root.");
	/* Don't add duplicates */
	for (i = 0; i < options->num_local_forwards; i++) {
		if (forward_equals(newfwd, options->local_forwards + i))
			return;
	}
	options->local_forwards = xreallocarray(options->local_forwards,
	    options->num_local_forwards + 1,
	    sizeof(*options->local_forwards));
	fwd = &options->local_forwards[options->num_local_forwards++];

	fwd->listen_host = newfwd->listen_host;
	fwd->listen_port = newfwd->listen_port;
	fwd->listen_path = newfwd->listen_path;
	fwd->connect_host = newfwd->connect_host;
	fwd->connect_port = newfwd->connect_port;
	fwd->connect_path = newfwd->connect_path;
}

/*
 * Adds a remote TCP/IP port forward to options.  Never returns if there is
 * an error.
 */

void
add_remote_forward(Options *options, const struct Forward *newfwd)
{
	struct Forward *fwd;
	int i;

	/* Don't add duplicates */
	for (i = 0; i < options->num_remote_forwards; i++) {
		if (forward_equals(newfwd, options->remote_forwards + i))
			return;
	}
	options->remote_forwards = xreallocarray(options->remote_forwards,
	    options->num_remote_forwards + 1,
	    sizeof(*options->remote_forwards));
	fwd = &options->remote_forwards[options->num_remote_forwards++];

	fwd->listen_host = newfwd->listen_host;
	fwd->listen_port = newfwd->listen_port;
	fwd->listen_path = newfwd->listen_path;
	fwd->connect_host = newfwd->connect_host;
	fwd->connect_port = newfwd->connect_port;
	fwd->connect_path = newfwd->connect_path;
	fwd->handle = newfwd->handle;
	fwd->allocated_port = 0;
}

static void
clear_forwardings(Options *options)
{
	int i;

	for (i = 0; i < options->num_local_forwards; i++) {
		free(options->local_forwards[i].listen_host);
		free(options->local_forwards[i].listen_path);
		free(options->local_forwards[i].connect_host);
		free(options->local_forwards[i].connect_path);
	}
	if (options->num_local_forwards > 0) {
		free(options->local_forwards);
		options->local_forwards = NULL;
	}
	options->num_local_forwards = 0;
	for (i = 0; i < options->num_remote_forwards; i++) {
		free(options->remote_forwards[i].listen_host);
		free(options->remote_forwards[i].listen_path);
		free(options->remote_forwards[i].connect_host);
		free(options->remote_forwards[i].connect_path);
	}
	if (options->num_remote_forwards > 0) {
		free(options->remote_forwards);
		options->remote_forwards = NULL;
	}
	options->num_remote_forwards = 0;
	options->tun_open = SSH_TUNMODE_NO;
}

void
add_certificate_file(Options *options, const char *path, int userprovided)
{
	int i;

	if (options->num_certificate_files >= SSH_MAX_CERTIFICATE_FILES)
		fatal("Too many certificate files specified (max %d)",
		    SSH_MAX_CERTIFICATE_FILES);

	/* Avoid registering duplicates */
	for (i = 0; i < options->num_certificate_files; i++) {
		if (options->certificate_file_userprovided[i] == userprovided &&
		    strcmp(options->certificate_files[i], path) == 0) {
			debug2("%s: ignoring duplicate key %s", __func__, path);
			return;
		}
	}

	options->certificate_file_userprovided[options->num_certificate_files] =
	    userprovided;
	options->certificate_files[options->num_certificate_files++] =
	    xstrdup(path);
}

void
add_identity_file(Options *options, const char *dir, const char *filename,
    int userprovided)
{
	char *path;
	int i;

	if (options->num_identity_files >= SSH_MAX_IDENTITY_FILES)
		fatal("Too many identity files specified (max %d)",
		    SSH_MAX_IDENTITY_FILES);

	if (dir == NULL) /* no dir, filename is absolute */
		path = xstrdup(filename);
	else if (xasprintf(&path, "%s%s", dir, filename) >= PATH_MAX)
		fatal("Identity file path %s too long", path);

	/* Avoid registering duplicates */
	for (i = 0; i < options->num_identity_files; i++) {
		if (options->identity_file_userprovided[i] == userprovided &&
		    strcmp(options->identity_files[i], path) == 0) {
			debug2("%s: ignoring duplicate key %s", __func__, path);
			free(path);
			return;
		}
	}

	options->identity_file_userprovided[options->num_identity_files] =
	    userprovided;
	options->identity_files[options->num_identity_files++] = path;
}

int
default_ssh_port(void)
{
	static int port;
	struct servent *sp;

	if (port == 0) {
		sp = getservbyname(SSH_SERVICE_NAME, "tcp");
		port = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;
	}
	return port;
}

/*
 * Execute a command in a shell.
 * Return its exit status or -1 on abnormal exit.
 */
static int
execute_in_shell(const char *cmd)
{
	char *shell;
	pid_t pid;
	int devnull, status;
	extern uid_t original_real_uid;

	if ((shell = getenv("SHELL")) == NULL)
		shell = _PATH_BSHELL;

	/* Need this to redirect subprocess stdin/out */
	if ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1)
		fatal("open(/dev/null): %s", strerror(errno));

	debug("Executing command: '%.500s'", cmd);

	/* Fork and execute the command. */
	if ((pid = fork()) == 0) {
		char *argv[4];

		/* Child.  Permanently give up superuser privileges. */
		permanently_drop_suid(original_real_uid);

		/* Redirect child stdin and stdout. Leave stderr */
		if (dup2(devnull, STDIN_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (dup2(devnull, STDOUT_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (devnull > STDERR_FILENO)
			close(devnull);
		closefrom(STDERR_FILENO + 1);

		argv[0] = shell;
		argv[1] = "-c";
		argv[2] = xstrdup(cmd);
		argv[3] = NULL;

		execv(argv[0], argv);
		error("Unable to execute '%.100s': %s", cmd, strerror(errno));
		/* Die with signal to make this error apparent to parent. */
		signal(SIGTERM, SIG_DFL);
		kill(getpid(), SIGTERM);
		_exit(1);
	}
	/* Parent. */
	if (pid < 0)
		fatal("%s: fork: %.100s", __func__, strerror(errno));

	close(devnull);

	while (waitpid(pid, &status, 0) == -1) {
		if (errno != EINTR && errno != EAGAIN)
			fatal("%s: waitpid: %s", __func__, strerror(errno));
	}
	if (!WIFEXITED(status)) {
		error("command '%.100s' exited abnormally", cmd);
		return -1;
	}
	debug3("command returned status %d", WEXITSTATUS(status));
	return WEXITSTATUS(status);
}

/*
 * Parse and execute a Match directive.
 */
static int
match_cfg_line(Options *options, char **condition, struct passwd *pw,
    const char *host_arg, const char *original_host, int post_canon,
    const char *filename, int linenum)
{
	char *arg, *oattrib, *attrib, *cmd, *cp = *condition, *host, *criteria;
	const char *ruser;
	int r, port, this_result, result = 1, attributes = 0, negate;
	char thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];

	/*
	 * Configuration is likely to be incomplete at this point so we
	 * must be prepared to use default values.
	 */
	port = options->port <= 0 ? default_ssh_port() : options->port;
	ruser = options->user == NULL ? pw->pw_name : options->user;
	if (post_canon) {
		host = xstrdup(options->hostname);
	} else if (options->hostname != NULL) {
		/* NB. Please keep in sync with ssh.c:main() */
		host = percent_expand(options->hostname,
		    "h", host_arg, (char *)NULL);
	} else {
		host = xstrdup(host_arg);
	}

	debug2("checking match for '%s' host %s originally %s",
	    cp, host, original_host);
	while ((oattrib = attrib = strdelim(&cp)) && *attrib != '\0') {
		criteria = NULL;
		this_result = 1;
		if ((negate = attrib[0] == '!'))
			attrib++;
		/* criteria "all" and "canonical" have no argument */
		if (strcasecmp(attrib, "all") == 0) {
			if (attributes > 1 ||
			    ((arg = strdelim(&cp)) != NULL && *arg != '\0')) {
				error("%.200s line %d: '%s' cannot be combined "
				    "with other Match attributes",
				    filename, linenum, oattrib);
				result = -1;
				goto out;
			}
			if (result)
				result = negate ? 0 : 1;
			goto out;
		}
		attributes++;
		if (strcasecmp(attrib, "canonical") == 0) {
			r = !!post_canon;  /* force bitmask member to boolean */
			if (r == (negate ? 1 : 0))
				this_result = result = 0;
			debug3("%.200s line %d: %smatched '%s'",
			    filename, linenum,
			    this_result ? "" : "not ", oattrib);
			continue;
		}
		/* All other criteria require an argument */
		if ((arg = strdelim(&cp)) == NULL || *arg == '\0') {
			error("Missing Match criteria for %s", attrib);
			result = -1;
			goto out;
		}
		if (strcasecmp(attrib, "host") == 0) {
			criteria = xstrdup(host);
			r = match_hostname(host, arg) == 1;
			if (r == (negate ? 1 : 0))
				this_result = result = 0;
		} else if (strcasecmp(attrib, "originalhost") == 0) {
			criteria = xstrdup(original_host);
			r = match_hostname(original_host, arg) == 1;
			if (r == (negate ? 1 : 0))
				this_result = result = 0;
		} else if (strcasecmp(attrib, "user") == 0) {
			criteria = xstrdup(ruser);
			r = match_pattern_list(ruser, arg, 0) == 1;
			if (r == (negate ? 1 : 0))
				this_result = result = 0;
		} else if (strcasecmp(attrib, "localuser") == 0) {
			criteria = xstrdup(pw->pw_name);
			r = match_pattern_list(pw->pw_name, arg, 0) == 1;
			if (r == (negate ? 1 : 0))
				this_result = result = 0;
		} else if (strcasecmp(attrib, "exec") == 0) {
			if (gethostname(thishost, sizeof(thishost)) == -1)
				fatal("gethostname: %s", strerror(errno));
			strlcpy(shorthost, thishost, sizeof(shorthost));
			shorthost[strcspn(thishost, ".")] = '\0';
			snprintf(portstr, sizeof(portstr), "%d", port);

			cmd = percent_expand(arg,
			    "L", shorthost,
			    "d", pw->pw_dir,
			    "h", host,
			    "l", thishost,
			    "n", original_host,
			    "p", portstr,
			    "r", ruser,
			    "u", pw->pw_name,
			    (char *)NULL);
			if (result != 1) {
				/* skip execution if prior predicate failed */
				debug3("%.200s line %d: skipped exec "
				    "\"%.100s\"", filename, linenum, cmd);
				free(cmd);
				continue;
			}
			r = execute_in_shell(cmd);
			if (r == -1) {
				fatal("%.200s line %d: match exec "
				    "'%.100s' error", filename,
				    linenum, cmd);
			}
			criteria = xstrdup(cmd);
			free(cmd);
			/* Force exit status to boolean */
			r = r == 0;
			if (r == (negate ? 1 : 0))
				this_result = result = 0;
		} else {
			error("Unsupported Match attribute %s", attrib);
			result = -1;
			goto out;
		}
		debug3("%.200s line %d: %smatched '%s \"%.100s\"' ",
		    filename, linenum, this_result ? "": "not ",
		    oattrib, criteria);
		free(criteria);
	}
	if (attributes == 0) {
		error("One or more attributes required for Match");
		result = -1;
		goto out;
	}
 out:
	if (result != -1)
		debug2("match %sfound", result ? "" : "not ");
	*condition = cp;
	free(host);
	return result;
}

/* Check and prepare a domain name: removes trailing '.' and lowercases */
static void
valid_domain(char *name, const char *filename, int linenum)
{
	size_t i, l = strlen(name);
	u_char c, last = '\0';

	if (l == 0)
		fatal("%s line %d: empty hostname suffix", filename, linenum);
	if (!isalpha((u_char)name[0]) && !isdigit((u_char)name[0]))
		fatal("%s line %d: hostname suffix \"%.100s\" "
		    "starts with invalid character", filename, linenum, name);
	for (i = 0; i < l; i++) {
		c = tolower((u_char)name[i]);
		name[i] = (char)c;
		if (last == '.' && c == '.')
			fatal("%s line %d: hostname suffix \"%.100s\" contains "
			    "consecutive separators", filename, linenum, name);
		if (c != '.' && c != '-' && !isalnum(c) &&
		    c != '_') /* technically invalid, but common */
			fatal("%s line %d: hostname suffix \"%.100s\" contains "
			    "invalid characters", filename, linenum, name);
		last = c;
	}
	if (name[l - 1] == '.')
		name[l - 1] = '\0';
}

/*
 * Returns the number of the token pointed to by cp or oBadOption.
 */
static OpCodes
parse_token(const char *cp, const char *filename, int linenum,
    const char *ignored_unknown)
{
	int i;

	for (i = 0; keywords[i].name; i++)
		if (strcmp(cp, keywords[i].name) == 0)
			return keywords[i].opcode;
	if (ignored_unknown != NULL &&
	    match_pattern_list(cp, ignored_unknown, 1) == 1)
		return oIgnoredUnknownOption;
	error("%s: line %d: Bad configuration option: %s",
	    filename, linenum, cp);
	return oBadOption;
}

/* Multistate option parsing */
struct multistate {
	char *key;
	int value;
};
static const struct multistate multistate_flag[] = {
	{ "true",			1 },
	{ "false",			0 },
	{ "yes",			1 },
	{ "no",				0 },
	{ NULL, -1 }
};
static const struct multistate multistate_yesnoask[] = {
	{ "true",			1 },
	{ "false",			0 },
	{ "yes",			1 },
	{ "no",				0 },
	{ "ask",			2 },
	{ NULL, -1 }
};
static const struct multistate multistate_strict_hostkey[] = {
	{ "true",			SSH_STRICT_HOSTKEY_YES },
	{ "false",			SSH_STRICT_HOSTKEY_OFF },
	{ "yes",			SSH_STRICT_HOSTKEY_YES },
	{ "no",				SSH_STRICT_HOSTKEY_OFF },
	{ "ask",			SSH_STRICT_HOSTKEY_ASK },
	{ "off",			SSH_STRICT_HOSTKEY_OFF },
	{ "accept-new",			SSH_STRICT_HOSTKEY_NEW },
	{ NULL, -1 }
};
static const struct multistate multistate_yesnoaskconfirm[] = {
	{ "true",			1 },
	{ "false",			0 },
	{ "yes",			1 },
	{ "no",				0 },
	{ "ask",			2 },
	{ "confirm",			3 },
	{ NULL, -1 }
};
static const struct multistate multistate_addressfamily[] = {
	{ "inet",			AF_INET },
	{ "inet6",			AF_INET6 },
	{ "any",			AF_UNSPEC },
	{ NULL, -1 }
};
static const struct multistate multistate_controlmaster[] = {
	{ "true",			SSHCTL_MASTER_YES },
	{ "yes",			SSHCTL_MASTER_YES },
	{ "false",			SSHCTL_MASTER_NO },
	{ "no",				SSHCTL_MASTER_NO },
	{ "auto",			SSHCTL_MASTER_AUTO },
	{ "ask",			SSHCTL_MASTER_ASK },
	{ "autoask",			SSHCTL_MASTER_AUTO_ASK },
	{ NULL, -1 }
};
static const struct multistate multistate_tunnel[] = {
	{ "ethernet",			SSH_TUNMODE_ETHERNET },
	{ "point-to-point",		SSH_TUNMODE_POINTOPOINT },
	{ "true",			SSH_TUNMODE_DEFAULT },
	{ "yes",			SSH_TUNMODE_DEFAULT },
	{ "false",			SSH_TUNMODE_NO },
	{ "no",				SSH_TUNMODE_NO },
	{ NULL, -1 }
};
static const struct multistate multistate_requesttty[] = {
	{ "true",			REQUEST_TTY_YES },
	{ "yes",			REQUEST_TTY_YES },
	{ "false",			REQUEST_TTY_NO },
	{ "no",				REQUEST_TTY_NO },
	{ "force",			REQUEST_TTY_FORCE },
	{ "auto",			REQUEST_TTY_AUTO },
	{ NULL, -1 }
};
static const struct multistate multistate_canonicalizehostname[] = {
	{ "true",			SSH_CANONICALISE_YES },
	{ "false",			SSH_CANONICALISE_NO },
	{ "yes",			SSH_CANONICALISE_YES },
	{ "no",				SSH_CANONICALISE_NO },
	{ "always",			SSH_CANONICALISE_ALWAYS },
	{ NULL, -1 }
};

/*
 * Processes a single option line as used in the configuration files. This
 * only sets those values that have not already been set.
 */
int
process_config_line(Options *options, struct passwd *pw, const char *host,
    const char *original_host, char *line, const char *filename,
    int linenum, int *activep, int flags)
{
	return process_config_line_depth(options, pw, host, original_host,
	    line, filename, linenum, activep, flags, 0);
}

#define WHITESPACE " \t\r\n"
static int
process_config_line_depth(Options *options, struct passwd *pw, const char *host,
    const char *original_host, char *line, const char *filename,
    int linenum, int *activep, int flags, int depth)
{
	char *s, **charptr, *endofnumber, *keyword, *arg, *arg2;
	char **cpptr, fwdarg[256];
	u_int i, *uintptr, max_entries = 0;
	int r, oactive, negated, opcode, *intptr, value, value2, cmdline = 0;
	int remotefwd, dynamicfwd;
	LogLevel *log_level_ptr;
	SyslogFacility *log_facility_ptr;
	long long val64;
	size_t len;
	struct Forward fwd;
	const struct multistate *multistate_ptr;
	struct allowed_cname *cname;
	glob_t gl;

	if (activep == NULL) { /* We are processing a command line directive */
		cmdline = 1;
		activep = &cmdline;
	}

	/* Strip trailing whitespace. Allow \f (form feed) at EOL only */
	if ((len = strlen(line)) == 0)
		return 0;
	for (len--; len > 0; len--) {
		if (strchr(WHITESPACE "\f", line[len]) == NULL)
			break;
		line[len] = '\0';
	}

	s = line;
	/* Get the keyword. (Each line is supposed to begin with a keyword). */
	if ((keyword = strdelim(&s)) == NULL)
		return 0;
	/* Ignore leading whitespace. */
	if (*keyword == '\0')
		keyword = strdelim(&s);
	if (keyword == NULL || !*keyword || *keyword == '\n' || *keyword == '#')
		return 0;
	/* Match lowercase keyword */
	lowercase(keyword);

	opcode = parse_token(keyword, filename, linenum,
	    options->ignored_unknown);

	switch (opcode) {
	case oBadOption:
		/* don't panic, but count bad options */
		return -1;
	case oIgnore:
		return 0;
	case oIgnoredUnknownOption:
		debug("%s line %d: Ignored unknown option \"%s\"",
		    filename, linenum, keyword);
		return 0;
	case oConnectTimeout:
		intptr = &options->connection_timeout;
parse_time:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing time value.",
			    filename, linenum);
		if (strcmp(arg, "none") == 0)
			value = -1;
		else if ((value = convtime(arg)) == -1)
			fatal("%s line %d: invalid time value.",
			    filename, linenum);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case oForwardAgent:
		intptr = &options->forward_agent;
 parse_flag:
		multistate_ptr = multistate_flag;
 parse_multistate:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing argument.",
			    filename, linenum);
		value = -1;
		for (i = 0; multistate_ptr[i].key != NULL; i++) {
			if (strcasecmp(arg, multistate_ptr[i].key) == 0) {
				value = multistate_ptr[i].value;
				break;
			}
		}
		if (value == -1)
			fatal("%s line %d: unsupported option \"%s\".",
			    filename, linenum, arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case oForwardX11:
		intptr = &options->forward_x11;
		goto parse_flag;

	case oForwardX11Trusted:
		intptr = &options->forward_x11_trusted;
		goto parse_flag;

	case oForwardX11Timeout:
		intptr = &options->forward_x11_timeout;
		goto parse_time;

	case oGatewayPorts:
		intptr = &options->fwd_opts.gateway_ports;
		goto parse_flag;

	case oExitOnForwardFailure:
		intptr = &options->exit_on_forward_failure;
		goto parse_flag;

	case oUsePrivilegedPort:
		intptr = &options->use_privileged_port;
		goto parse_flag;

	case oPasswordAuthentication:
		intptr = &options->password_authentication;
		goto parse_flag;

	case oKbdInteractiveAuthentication:
		intptr = &options->kbd_interactive_authentication;
		goto parse_flag;

	case oKbdInteractiveDevices:
		charptr = &options->kbd_interactive_devices;
		goto parse_string;

	case oPubkeyAuthentication:
		intptr = &options->pubkey_authentication;
		goto parse_flag;

	case oHostbasedAuthentication:
		intptr = &options->hostbased_authentication;
		goto parse_flag;

	case oChallengeResponseAuthentication:
		intptr = &options->challenge_response_authentication;
		goto parse_flag;

	case oGssAuthentication:
		intptr = &options->gss_authentication;
		goto parse_flag;

	case oGssDelegateCreds:
		intptr = &options->gss_deleg_creds;
		goto parse_flag;

	case oBatchMode:
		intptr = &options->batch_mode;
		goto parse_flag;

	case oCheckHostIP:
		intptr = &options->check_host_ip;
		goto parse_flag;

	case oVerifyHostKeyDNS:
		intptr = &options->verify_host_key_dns;
		multistate_ptr = multistate_yesnoask;
		goto parse_multistate;

	case oStrictHostKeyChecking:
		intptr = &options->strict_host_key_checking;
		multistate_ptr = multistate_strict_hostkey;
		goto parse_multistate;

	case oCompression:
		intptr = &options->compression;
		goto parse_flag;

	case oTCPKeepAlive:
		intptr = &options->tcp_keep_alive;
		goto parse_flag;

	case oNoHostAuthenticationForLocalhost:
		intptr = &options->no_host_authentication_for_localhost;
		goto parse_flag;

	case oNumberOfPasswordPrompts:
		intptr = &options->number_of_password_prompts;
		goto parse_int;

	case oRekeyLimit:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename,
			    linenum);
		if (strcmp(arg, "default") == 0) {
			val64 = 0;
		} else {
			if (scan_scaled(arg, &val64) == -1)
				fatal("%.200s line %d: Bad number '%s': %s",
				    filename, linenum, arg, strerror(errno));
			if (val64 != 0 && val64 < 16)
				fatal("%.200s line %d: RekeyLimit too small",
				    filename, linenum);
		}
		if (*activep && options->rekey_limit == -1)
			options->rekey_limit = val64;
		if (s != NULL) { /* optional rekey interval present */
			if (strcmp(s, "none") == 0) {
				(void)strdelim(&s);	/* discard */
				break;
			}
			intptr = &options->rekey_interval;
			goto parse_time;
		}
		break;

	case oIdentityFile:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (*activep) {
			intptr = &options->num_identity_files;
			if (*intptr >= SSH_MAX_IDENTITY_FILES)
				fatal("%.200s line %d: Too many identity files specified (max %d).",
				    filename, linenum, SSH_MAX_IDENTITY_FILES);
			add_identity_file(options, NULL,
			    arg, flags & SSHCONF_USERCONF);
		}
		break;

	case oCertificateFile:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.",
			    filename, linenum);
		if (*activep) {
			intptr = &options->num_certificate_files;
			if (*intptr >= SSH_MAX_CERTIFICATE_FILES) {
				fatal("%.200s line %d: Too many certificate "
				    "files specified (max %d).",
				    filename, linenum,
				    SSH_MAX_CERTIFICATE_FILES);
			}
			add_certificate_file(options, arg,
			    flags & SSHCONF_USERCONF);
		}
		break;

	case oXAuthLocation:
		charptr=&options->xauth_location;
		goto parse_string;

	case oUser:
		charptr = &options->user;
parse_string:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.",
			    filename, linenum);
		if (*activep && *charptr == NULL)
			*charptr = xstrdup(arg);
		break;

	case oGlobalKnownHostsFile:
		cpptr = (char **)&options->system_hostfiles;
		uintptr = &options->num_system_hostfiles;
		max_entries = SSH_MAX_HOSTS_FILES;
parse_char_array:
		if (*activep && *uintptr == 0) {
			while ((arg = strdelim(&s)) != NULL && *arg != '\0') {
				if ((*uintptr) >= max_entries)
					fatal("%s line %d: "
					    "too many authorized keys files.",
					    filename, linenum);
				cpptr[(*uintptr)++] = xstrdup(arg);
			}
		}
		return 0;

	case oUserKnownHostsFile:
		cpptr = (char **)&options->user_hostfiles;
		uintptr = &options->num_user_hostfiles;
		max_entries = SSH_MAX_HOSTS_FILES;
		goto parse_char_array;

	case oHostName:
		charptr = &options->hostname;
		goto parse_string;

	case oHostKeyAlias:
		charptr = &options->host_key_alias;
		goto parse_string;

	case oPreferredAuthentications:
		charptr = &options->preferred_authentications;
		goto parse_string;

	case oBindAddress:
		charptr = &options->bind_address;
		goto parse_string;

	case oPKCS11Provider:
		charptr = &options->pkcs11_provider;
		goto parse_string;

	case oProxyCommand:
		charptr = &options->proxy_command;
		/* Ignore ProxyCommand if ProxyJump already specified */
		if (options->jump_host != NULL)
			charptr = &options->jump_host; /* Skip below */
parse_command:
		if (s == NULL)
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		len = strspn(s, WHITESPACE "=");
		if (*activep && *charptr == NULL)
			*charptr = xstrdup(s + len);
		return 0;

	case oProxyJump:
		if (s == NULL) {
			fatal("%.200s line %d: Missing argument.",
			    filename, linenum);
		}
		len = strspn(s, WHITESPACE "=");
		if (parse_jump(s + len, options, *activep) == -1) {
			fatal("%.200s line %d: Invalid ProxyJump \"%s\"",
			    filename, linenum, s + len);
		}
		return 0;

	case oPort:
		intptr = &options->port;
parse_int:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (arg[0] < '0' || arg[0] > '9')
			fatal("%.200s line %d: Bad number.", filename, linenum);

		/* Octal, decimal, or hex format? */
		value = strtol(arg, &endofnumber, 0);
		if (arg == endofnumber)
			fatal("%.200s line %d: Bad number.", filename, linenum);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case oConnectionAttempts:
		intptr = &options->connection_attempts;
		goto parse_int;

	case oCiphers:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (*arg != '-' && !ciphers_valid(*arg == '+' ? arg + 1 : arg))
			fatal("%.200s line %d: Bad SSH2 cipher spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && options->ciphers == NULL)
			options->ciphers = xstrdup(arg);
		break;

	case oMacs:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (*arg != '-' && !mac_valid(*arg == '+' ? arg + 1 : arg))
			fatal("%.200s line %d: Bad SSH2 Mac spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && options->macs == NULL)
			options->macs = xstrdup(arg);
		break;

	case oKexAlgorithms:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.",
			    filename, linenum);
		if (*arg != '-' &&
		    !kex_names_valid(*arg == '+' ? arg + 1 : arg))
			fatal("%.200s line %d: Bad SSH2 KexAlgorithms '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && options->kex_algorithms == NULL)
			options->kex_algorithms = xstrdup(arg);
		break;

	case oHostKeyAlgorithms:
		charptr = &options->hostkeyalgorithms;
parse_keytypes:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.",
			    filename, linenum);
		if (*arg != '-' &&
		    !sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))
			fatal("%s line %d: Bad key types '%s'.",
				filename, linenum, arg ? arg : "<NONE>");
		if (*activep && *charptr == NULL)
			*charptr = xstrdup(arg);
		break;

	case oLogLevel:
		log_level_ptr = &options->log_level;
		arg = strdelim(&s);
		value = log_level_number(arg);
		if (value == SYSLOG_LEVEL_NOT_SET)
			fatal("%.200s line %d: unsupported log level '%s'",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && *log_level_ptr == SYSLOG_LEVEL_NOT_SET)
			*log_level_ptr = (LogLevel) value;
		break;

	case oLogFacility:
		log_facility_ptr = &options->log_facility;
		arg = strdelim(&s);
		value = log_facility_number(arg);
		if (value == SYSLOG_FACILITY_NOT_SET)
			fatal("%.200s line %d: unsupported log facility '%s'",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*log_facility_ptr == -1)
			*log_facility_ptr = (SyslogFacility) value;
		break;

	case oLocalForward:
	case oRemoteForward:
	case oDynamicForward:
		arg = strdelim(&s);
		if (arg == NULL || *arg == '\0')
			fatal("%.200s line %d: Missing port argument.",
			    filename, linenum);

		remotefwd = (opcode == oRemoteForward);
		dynamicfwd = (opcode == oDynamicForward);

		if (!dynamicfwd) {
			arg2 = strdelim(&s);
			if (arg2 == NULL || *arg2 == '\0') {
				if (remotefwd)
					dynamicfwd = 1;
				else
					fatal("%.200s line %d: Missing target "
					    "argument.", filename, linenum);
			} else {
				/* construct a string for parse_forward */
				snprintf(fwdarg, sizeof(fwdarg), "%s:%s", arg,
				    arg2);
			}
		}
		if (dynamicfwd)
			strlcpy(fwdarg, arg, sizeof(fwdarg));

		if (parse_forward(&fwd, fwdarg, dynamicfwd, remotefwd) == 0)
			fatal("%.200s line %d: Bad forwarding specification.",
			    filename, linenum);

		if (*activep) {
			if (remotefwd) {
				add_remote_forward(options, &fwd);
			} else {
				add_local_forward(options, &fwd);
			}
		}
		break;

	case oClearAllForwardings:
		intptr = &options->clear_forwardings;
		goto parse_flag;

	case oHost:
		if (cmdline)
			fatal("Host directive not supported as a command-line "
			    "option");
		*activep = 0;
		arg2 = NULL;
		while ((arg = strdelim(&s)) != NULL && *arg != '\0') {
			if ((flags & SSHCONF_NEVERMATCH) != 0)
				break;
			negated = *arg == '!';
			if (negated)
				arg++;
			if (match_pattern(host, arg)) {
				if (negated) {
					debug("%.200s line %d: Skipping Host "
					    "block because of negated match "
					    "for %.100s", filename, linenum,
					    arg);
					*activep = 0;
					break;
				}
				if (!*activep)
					arg2 = arg; /* logged below */
				*activep = 1;
			}
		}
		if (*activep)
			debug("%.200s line %d: Applying options for %.100s",
			    filename, linenum, arg2);
		/* Avoid garbage check below, as strdelim is done. */
		return 0;

	case oMatch:
		if (cmdline)
			fatal("Host directive not supported as a command-line "
			    "option");
		value = match_cfg_line(options, &s, pw, host, original_host,
		    flags & SSHCONF_POSTCANON, filename, linenum);
		if (value < 0)
			fatal("%.200s line %d: Bad Match condition", filename,
			    linenum);
		*activep = (flags & SSHCONF_NEVERMATCH) ? 0 : value;
		break;

	case oEscapeChar:
		intptr = &options->escape_char;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (strcmp(arg, "none") == 0)
			value = SSH_ESCAPECHAR_NONE;
		else if (arg[1] == '\0')
			value = (u_char) arg[0];
		else if (arg[0] == '^' && arg[2] == 0 &&
		    (u_char) arg[1] >= 64 && (u_char) arg[1] < 128)
			value = (u_char) arg[1] & 31;
		else {
			fatal("%.200s line %d: Bad escape character.",
			    filename, linenum);
			/* NOTREACHED */
			value = 0;	/* Avoid compiler warning. */
		}
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case oAddressFamily:
		intptr = &options->address_family;
		multistate_ptr = multistate_addressfamily;
		goto parse_multistate;

	case oEnableSSHKeysign:
		intptr = &options->enable_ssh_keysign;
		goto parse_flag;

	case oIdentitiesOnly:
		intptr = &options->identities_only;
		goto parse_flag;

	case oServerAliveInterval:
		intptr = &options->server_alive_interval;
		goto parse_time;

	case oServerAliveCountMax:
		intptr = &options->server_alive_count_max;
		goto parse_int;

	case oSendEnv:
		while ((arg = strdelim(&s)) != NULL && *arg != '\0') {
			if (strchr(arg, '=') != NULL)
				fatal("%s line %d: Invalid environment name.",
				    filename, linenum);
			if (!*activep)
				continue;
			if (options->num_send_env >= MAX_SEND_ENV)
				fatal("%s line %d: too many send env.",
				    filename, linenum);
			options->send_env[options->num_send_env++] =
			    xstrdup(arg);
		}
		break;

	case oControlPath:
		charptr = &options->control_path;
		goto parse_string;

	case oControlMaster:
		intptr = &options->control_master;
		multistate_ptr = multistate_controlmaster;
		goto parse_multistate;

	case oControlPersist:
		/* no/false/yes/true, or a time spec */
		intptr = &options->control_persist;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing ControlPersist"
			    " argument.", filename, linenum);
		value = 0;
		value2 = 0;	/* timeout */
		if (strcmp(arg, "no") == 0 || strcmp(arg, "false") == 0)
			value = 0;
		else if (strcmp(arg, "yes") == 0 || strcmp(arg, "true") == 0)
			value = 1;
		else if ((value2 = convtime(arg)) >= 0)
			value = 1;
		else
			fatal("%.200s line %d: Bad ControlPersist argument.",
			    filename, linenum);
		if (*activep && *intptr == -1) {
			*intptr = value;
			options->control_persist_timeout = value2;
		}
		break;

	case oHashKnownHosts:
		intptr = &options->hash_known_hosts;
		goto parse_flag;

	case oTunnel:
		intptr = &options->tun_open;
		multistate_ptr = multistate_tunnel;
		goto parse_multistate;

	case oTunnelDevice:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		value = a2tun(arg, &value2);
		if (value == SSH_TUNID_ERR)
			fatal("%.200s line %d: Bad tun device.", filename, linenum);
		if (*activep) {
			options->tun_local = value;
			options->tun_remote = value2;
		}
		break;

	case oLocalCommand:
		charptr = &options->local_command;
		goto parse_command;

	case oPermitLocalCommand:
		intptr = &options->permit_local_command;
		goto parse_flag;

	case oRemoteCommand:
		charptr = &options->remote_command;
		goto parse_command;

	case oVisualHostKey:
		intptr = &options->visual_host_key;
		goto parse_flag;

	case oInclude:
		if (cmdline)
			fatal("Include directive not supported as a "
			    "command-line option");
		value = 0;
		while ((arg = strdelim(&s)) != NULL && *arg != '\0') {
			/*
			 * Ensure all paths are anchored. User configuration
			 * files may begin with '~/' but system configurations
			 * must not. If the path is relative, then treat it
			 * as living in ~/.ssh for user configurations or
			 * /etc/ssh for system ones.
			 */
			if (*arg == '~' && (flags & SSHCONF_USERCONF) == 0)
				fatal("%.200s line %d: bad include path %s.",
				    filename, linenum, arg);
			if (*arg != '/' && *arg != '~') {
				xasprintf(&arg2, "%s/%s",
				    (flags & SSHCONF_USERCONF) ?
				    "~/" _PATH_SSH_USER_DIR : SSHDIR, arg);
			} else
				arg2 = xstrdup(arg);
			memset(&gl, 0, sizeof(gl));
			r = glob(arg2, GLOB_TILDE, NULL, &gl);
			if (r == GLOB_NOMATCH) {
				debug("%.200s line %d: include %s matched no "
				    "files",filename, linenum, arg2);
				free(arg2);
				continue;
			} else if (r != 0 || gl.gl_pathc < 0)
				fatal("%.200s line %d: glob failed for %s.",
				    filename, linenum, arg2);
			free(arg2);
			oactive = *activep;
			for (i = 0; i < (u_int)gl.gl_pathc; i++) {
				debug3("%.200s line %d: Including file %s "
				    "depth %d%s", filename, linenum,
				    gl.gl_pathv[i], depth,
				    oactive ? "" : " (parse only)");
				r = read_config_file_depth(gl.gl_pathv[i],
				    pw, host, original_host, options,
				    flags | SSHCONF_CHECKPERM |
				    (oactive ? 0 : SSHCONF_NEVERMATCH),
				    activep, depth + 1);
				if (r != 1 && errno != ENOENT) {
					fatal("Can't open user config file "
					    "%.100s: %.100s", gl.gl_pathv[i],
					    strerror(errno));
				}
				/*
				 * don't let Match in includes clobber the
				 * containing file's Match state.
				 */
				*activep = oactive;
				if (r != 1)
					value = -1;
			}
			globfree(&gl);
		}
		if (value != 0)
			return value;
		break;

	case oIPQoS:
		arg = strdelim(&s);
		if ((value = parse_ipqos(arg)) == -1)
			fatal("%s line %d: Bad IPQoS value: %s",
			    filename, linenum, arg);
		arg = strdelim(&s);
		if (arg == NULL)
			value2 = value;
		else if ((value2 = parse_ipqos(arg)) == -1)
			fatal("%s line %d: Bad IPQoS value: %s",
			    filename, linenum, arg);
		if (*activep) {
			options->ip_qos_interactive = value;
			options->ip_qos_bulk = value2;
		}
		break;

	case oRequestTTY:
		intptr = &options->request_tty;
		multistate_ptr = multistate_requesttty;
		goto parse_multistate;

	case oIgnoreUnknown:
		charptr = &options->ignored_unknown;
		goto parse_string;

	case oProxyUseFdpass:
		intptr = &options->proxy_use_fdpass;
		goto parse_flag;

	case oCanonicalDomains:
		value = options->num_canonical_domains != 0;
		while ((arg = strdelim(&s)) != NULL && *arg != '\0') {
			valid_domain(arg, filename, linenum);
			if (!*activep || value)
				continue;
			if (options->num_canonical_domains >= MAX_CANON_DOMAINS)
				fatal("%s line %d: too many hostname suffixes.",
				    filename, linenum);
			options->canonical_domains[
			    options->num_canonical_domains++] = xstrdup(arg);
		}
		break;

	case oCanonicalizePermittedCNAMEs:
		value = options->num_permitted_cnames != 0;
		while ((arg = strdelim(&s)) != NULL && *arg != '\0') {
			/* Either '*' for everything or 'list:list' */
			if (strcmp(arg, "*") == 0)
				arg2 = arg;
			else {
				lowercase(arg);
				if ((arg2 = strchr(arg, ':')) == NULL ||
				    arg2[1] == '\0') {
					fatal("%s line %d: "
					    "Invalid permitted CNAME \"%s\"",
					    filename, linenum, arg);
				}
				*arg2 = '\0';
				arg2++;
			}
			if (!*activep || value)
				continue;
			if (options->num_permitted_cnames >= MAX_CANON_DOMAINS)
				fatal("%s line %d: too many permitted CNAMEs.",
				    filename, linenum);
			cname = options->permitted_cnames +
			    options->num_permitted_cnames++;
			cname->source_list = xstrdup(arg);
			cname->target_list = xstrdup(arg2);
		}
		break;

	case oCanonicalizeHostname:
		intptr = &options->canonicalize_hostname;
		multistate_ptr = multistate_canonicalizehostname;
		goto parse_multistate;

	case oCanonicalizeMaxDots:
		intptr = &options->canonicalize_max_dots;
		goto parse_int;

	case oCanonicalizeFallbackLocal:
		intptr = &options->canonicalize_fallback_local;
		goto parse_flag;

	case oStreamLocalBindMask:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing StreamLocalBindMask argument.", filename, linenum);
		/* Parse mode in octal format */
		value = strtol(arg, &endofnumber, 8);
		if (arg == endofnumber || value < 0 || value > 0777)
			fatal("%.200s line %d: Bad mask.", filename, linenum);
		options->fwd_opts.streamlocal_bind_mask = (mode_t)value;
		break;

	case oStreamLocalBindUnlink:
		intptr = &options->fwd_opts.streamlocal_bind_unlink;
		goto parse_flag;

	case oRevokedHostKeys:
		charptr = &options->revoked_host_keys;
		goto parse_string;

	case oFingerprintHash:
		intptr = &options->fingerprint_hash;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.",
			    filename, linenum);
		if ((value = ssh_digest_alg_by_name(arg)) == -1)
			fatal("%.200s line %d: Invalid hash algorithm \"%s\".",
			    filename, linenum, arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case oUpdateHostkeys:
		intptr = &options->update_hostkeys;
		multistate_ptr = multistate_yesnoask;
		goto parse_multistate;

	case oHostbasedKeyTypes:
		charptr = &options->hostbased_key_types;
		goto parse_keytypes;

	case oPubkeyAcceptedKeyTypes:
		charptr = &options->pubkey_key_types;
		goto parse_keytypes;

	case oAddKeysToAgent:
		intptr = &options->add_keys_to_agent;
		multistate_ptr = multistate_yesnoaskconfirm;
		goto parse_multistate;

	case oIdentityAgent:
		charptr = &options->identity_agent;
		goto parse_string;

	case oDeprecated:
		debug("%s line %d: Deprecated option \"%s\"",
		    filename, linenum, keyword);
		return 0;

	case oUnsupported:
		error("%s line %d: Unsupported option \"%s\"",
		    filename, linenum, keyword);
		return 0;

	default:
		fatal("%s: Unimplemented opcode %d", __func__, opcode);
	}

	/* Check that there is no garbage at end of line. */
	if ((arg = strdelim(&s)) != NULL && *arg != '\0') {
		fatal("%.200s line %d: garbage at end of line; \"%.200s\".",
		    filename, linenum, arg);
	}
	return 0;
}

/*
 * Reads the config file and modifies the options accordingly.  Options
 * should already be initialized before this call.  This never returns if
 * there is an error.  If the file does not exist, this returns 0.
 */
int
read_config_file(const char *filename, struct passwd *pw, const char *host,
    const char *original_host, Options *options, int flags)
{
	int active = 1;

	return read_config_file_depth(filename, pw, host, original_host,
	    options, flags, &active, 0);
}

#define READCONF_MAX_DEPTH	16
static int
read_config_file_depth(const char *filename, struct passwd *pw,
    const char *host, const char *original_host, Options *options,
    int flags, int *activep, int depth)
{
	FILE *f;
	char line[4096];
	int linenum;
	int bad_options = 0;

	if (depth < 0 || depth > READCONF_MAX_DEPTH)
		fatal("Too many recursive configuration includes");

	if ((f = fopen(filename, "r")) == NULL)
		return 0;

	if (flags & SSHCONF_CHECKPERM) {
		struct stat sb;

		if (fstat(fileno(f), &sb) == -1)
			fatal("fstat %s: %s", filename, strerror(errno));
		if (((sb.st_uid != 0 && sb.st_uid != getuid()) ||
		    (sb.st_mode & 022) != 0))
			fatal("Bad owner or permissions on %s", filename);
	}

	debug("Reading configuration data %.200s", filename);

	/*
	 * Mark that we are now processing the options.  This flag is turned
	 * on/off by Host specifications.
	 */
	linenum = 0;
	while (fgets(line, sizeof(line), f)) {
		/* Update line number counter. */
		linenum++;
		if (strlen(line) == sizeof(line) - 1)
			fatal("%s line %d too long", filename, linenum);
		if (process_config_line_depth(options, pw, host, original_host,
		    line, filename, linenum, activep, flags, depth) != 0)
			bad_options++;
	}
	fclose(f);
	if (bad_options > 0)
		fatal("%s: terminating, %d bad configuration options",
		    filename, bad_options);
	return 1;
}

/* Returns 1 if a string option is unset or set to "none" or 0 otherwise. */
int
option_clear_or_none(const char *o)
{
	return o == NULL || strcasecmp(o, "none") == 0;
}

/*
 * Initializes options to special values that indicate that they have not yet
 * been set.  Read_config_file will only set options with this value. Options
 * are processed in the following order: command line, user config file,
 * system config file.  Last, fill_default_options is called.
 */

void
initialize_options(Options * options)
{
	memset(options, 'X', sizeof(*options));
	options->forward_agent = -1;
	options->forward_x11 = -1;
	options->forward_x11_trusted = -1;
	options->forward_x11_timeout = -1;
	options->stdio_forward_host = NULL;
	options->stdio_forward_port = 0;
	options->clear_forwardings = -1;
	options->exit_on_forward_failure = -1;
	options->xauth_location = NULL;
	options->fwd_opts.gateway_ports = -1;
	options->fwd_opts.streamlocal_bind_mask = (mode_t)-1;
	options->fwd_opts.streamlocal_bind_unlink = -1;
	options->use_privileged_port = -1;
	options->pubkey_authentication = -1;
	options->challenge_response_authentication = -1;
	options->gss_authentication = -1;
	options->gss_deleg_creds = -1;
	options->password_authentication = -1;
	options->kbd_interactive_authentication = -1;
	options->kbd_interactive_devices = NULL;
	options->hostbased_authentication = -1;
	options->batch_mode = -1;
	options->check_host_ip = -1;
	options->strict_host_key_checking = -1;
	options->compression = -1;
	options->tcp_keep_alive = -1;
	options->port = -1;
	options->address_family = -1;
	options->connection_attempts = -1;
	options->connection_timeout = -1;
	options->number_of_password_prompts = -1;
	options->ciphers = NULL;
	options->macs = NULL;
	options->kex_algorithms = NULL;
	options->hostkeyalgorithms = NULL;
	options->num_identity_files = 0;
	options->num_certificate_files = 0;
	options->hostname = NULL;
	options->host_key_alias = NULL;
	options->proxy_command = NULL;
	options->jump_user = NULL;
	options->jump_host = NULL;
	options->jump_port = -1;
	options->jump_extra = NULL;
	options->user = NULL;
	options->escape_char = -1;
	options->num_system_hostfiles = 0;
	options->num_user_hostfiles = 0;
	options->local_forwards = NULL;
	options->num_local_forwards = 0;
	options->remote_forwards = NULL;
	options->num_remote_forwards = 0;
	options->log_facility = SYSLOG_FACILITY_NOT_SET;
	options->log_level = SYSLOG_LEVEL_NOT_SET;
	options->preferred_authentications = NULL;
	options->bind_address = NULL;
	options->pkcs11_provider = NULL;
	options->enable_ssh_keysign = - 1;
	options->no_host_authentication_for_localhost = - 1;
	options->identities_only = - 1;
	options->rekey_limit = - 1;
	options->rekey_interval = -1;
	options->verify_host_key_dns = -1;
	options->server_alive_interval = -1;
	options->server_alive_count_max = -1;
	options->num_send_env = 0;
	options->control_path = NULL;
	options->control_master = -1;
	options->control_persist = -1;
	options->control_persist_timeout = 0;
	options->hash_known_hosts = -1;
	options->tun_open = -1;
	options->tun_local = -1;
	options->tun_remote = -1;
	options->local_command = NULL;
	options->permit_local_command = -1;
	options->remote_command = NULL;
	options->add_keys_to_agent = -1;
	options->identity_agent = NULL;
	options->visual_host_key = -1;
	options->ip_qos_interactive = -1;
	options->ip_qos_bulk = -1;
	options->request_tty = -1;
	options->proxy_use_fdpass = -1;
	options->ignored_unknown = NULL;
	options->num_canonical_domains = 0;
	options->num_permitted_cnames = 0;
	options->canonicalize_max_dots = -1;
	options->canonicalize_fallback_local = -1;
	options->canonicalize_hostname = -1;
	options->revoked_host_keys = NULL;
	options->fingerprint_hash = -1;
	options->update_hostkeys = -1;
	options->hostbased_key_types = NULL;
	options->pubkey_key_types = NULL;
}

/*
 * A petite version of fill_default_options() that just fills the options
 * needed for hostname canonicalization to proceed.
 */
void
fill_default_options_for_canonicalization(Options *options)
{
	if (options->canonicalize_max_dots == -1)
		options->canonicalize_max_dots = 1;
	if (options->canonicalize_fallback_local == -1)
		options->canonicalize_fallback_local = 1;
	if (options->canonicalize_hostname == -1)
		options->canonicalize_hostname = SSH_CANONICALISE_NO;
}

/*
 * Called after processing other sources of option data, this fills those
 * options for which no value has been specified with their default values.
 */
void
fill_default_options(Options * options)
{
	if (options->forward_agent == -1)
		options->forward_agent = 0;
	if (options->forward_x11 == -1)
		options->forward_x11 = 0;
	if (options->forward_x11_trusted == -1)
		options->forward_x11_trusted = 0;
	if (options->forward_x11_timeout == -1)
		options->forward_x11_timeout = 1200;
	/*
	 * stdio forwarding (-W) changes the default for these but we defer
	 * setting the values so they can be overridden.
	 */
	if (options->exit_on_forward_failure == -1)
		options->exit_on_forward_failure =
		    options->stdio_forward_host != NULL ? 1 : 0;
	if (options->clear_forwardings == -1)
		options->clear_forwardings =
		    options->stdio_forward_host != NULL ? 1 : 0;
	if (options->clear_forwardings == 1)
		clear_forwardings(options);

	if (options->xauth_location == NULL)
		options->xauth_location = _PATH_XAUTH;
	if (options->fwd_opts.gateway_ports == -1)
		options->fwd_opts.gateway_ports = 0;
	if (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)
		options->fwd_opts.streamlocal_bind_mask = 0177;
	if (options->fwd_opts.streamlocal_bind_unlink == -1)
		options->fwd_opts.streamlocal_bind_unlink = 0;
	if (options->use_privileged_port == -1)
		options->use_privileged_port = 0;
	if (options->pubkey_authentication == -1)
		options->pubkey_authentication = 1;
	if (options->challenge_response_authentication == -1)
		options->challenge_response_authentication = 1;
	if (options->gss_authentication == -1)
		options->gss_authentication = 0;
	if (options->gss_deleg_creds == -1)
		options->gss_deleg_creds = 0;
	if (options->password_authentication == -1)
		options->password_authentication = 1;
	if (options->kbd_interactive_authentication == -1)
		options->kbd_interactive_authentication = 1;
	if (options->hostbased_authentication == -1)
		options->hostbased_authentication = 0;
	if (options->batch_mode == -1)
		options->batch_mode = 0;
	if (options->check_host_ip == -1)
		options->check_host_ip = 1;
	if (options->strict_host_key_checking == -1)
		options->strict_host_key_checking = SSH_STRICT_HOSTKEY_ASK;
	if (options->compression == -1)
		options->compression = 0;
	if (options->tcp_keep_alive == -1)
		options->tcp_keep_alive = 1;
	if (options->port == -1)
		options->port = 0;	/* Filled in ssh_connect. */
	if (options->address_family == -1)
		options->address_family = AF_UNSPEC;
	if (options->connection_attempts == -1)
		options->connection_attempts = 1;
	if (options->number_of_password_prompts == -1)
		options->number_of_password_prompts = 3;
	/* options->hostkeyalgorithms, default set in myproposals.h */
	if (options->add_keys_to_agent == -1)
		options->add_keys_to_agent = 0;
	if (options->num_identity_files == 0) {
		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_RSA, 0);
		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_DSA, 0);
		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_ECDSA, 0);
		add_identity_file(options, "~/",
		    _PATH_SSH_CLIENT_ID_ED25519, 0);
	}
	if (options->escape_char == -1)
		options->escape_char = '~';
	if (options->num_system_hostfiles == 0) {
		options->system_hostfiles[options->num_system_hostfiles++] =
		    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE);
		options->system_hostfiles[options->num_system_hostfiles++] =
		    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE2);
	}
	if (options->num_user_hostfiles == 0) {
		options->user_hostfiles[options->num_user_hostfiles++] =
		    xstrdup(_PATH_SSH_USER_HOSTFILE);
		options->user_hostfiles[options->num_user_hostfiles++] =
		    xstrdup(_PATH_SSH_USER_HOSTFILE2);
	}
	if (options->log_level == SYSLOG_LEVEL_NOT_SET)
		options->log_level = SYSLOG_LEVEL_INFO;
	if (options->log_facility == SYSLOG_FACILITY_NOT_SET)
		options->log_facility = SYSLOG_FACILITY_USER;
	if (options->no_host_authentication_for_localhost == - 1)
		options->no_host_authentication_for_localhost = 0;
	if (options->identities_only == -1)
		options->identities_only = 0;
	if (options->enable_ssh_keysign == -1)
		options->enable_ssh_keysign = 0;
	if (options->rekey_limit == -1)
		options->rekey_limit = 0;
	if (options->rekey_interval == -1)
		options->rekey_interval = 0;
	if (options->verify_host_key_dns == -1)
		options->verify_host_key_dns = 0;
	if (options->server_alive_interval == -1)
		options->server_alive_interval = 0;
	if (options->server_alive_count_max == -1)
		options->server_alive_count_max = 3;
	if (options->control_master == -1)
		options->control_master = 0;
	if (options->control_persist == -1) {
		options->control_persist = 0;
		options->control_persist_timeout = 0;
	}
	if (options->hash_known_hosts == -1)
		options->hash_known_hosts = 0;
	if (options->tun_open == -1)
		options->tun_open = SSH_TUNMODE_NO;
	if (options->tun_local == -1)
		options->tun_local = SSH_TUNID_ANY;
	if (options->tun_remote == -1)
		options->tun_remote = SSH_TUNID_ANY;
	if (options->permit_local_command == -1)
		options->permit_local_command = 0;
	if (options->visual_host_key == -1)
		options->visual_host_key = 0;
	if (options->ip_qos_interactive == -1)
		options->ip_qos_interactive = IPTOS_LOWDELAY;
	if (options->ip_qos_bulk == -1)
		options->ip_qos_bulk = IPTOS_THROUGHPUT;
	if (options->request_tty == -1)
		options->request_tty = REQUEST_TTY_AUTO;
	if (options->proxy_use_fdpass == -1)
		options->proxy_use_fdpass = 0;
	if (options->canonicalize_max_dots == -1)
		options->canonicalize_max_dots = 1;
	if (options->canonicalize_fallback_local == -1)
		options->canonicalize_fallback_local = 1;
	if (options->canonicalize_hostname == -1)
		options->canonicalize_hostname = SSH_CANONICALISE_NO;
	if (options->fingerprint_hash == -1)
		options->fingerprint_hash = SSH_FP_HASH_DEFAULT;
	if (options->update_hostkeys == -1)
		options->update_hostkeys = 0;
	if (kex_assemble_names(KEX_CLIENT_ENCRYPT, &options->ciphers) != 0 ||
	    kex_assemble_names(KEX_CLIENT_MAC, &options->macs) != 0 ||
	    kex_assemble_names(KEX_CLIENT_KEX, &options->kex_algorithms) != 0 ||
	    kex_assemble_names(KEX_DEFAULT_PK_ALG,
	    &options->hostbased_key_types) != 0 ||
	    kex_assemble_names(KEX_DEFAULT_PK_ALG,
	    &options->pubkey_key_types) != 0)
		fatal("%s: kex_assemble_names failed", __func__);

#define CLEAR_ON_NONE(v) \
	do { \
		if (option_clear_or_none(v)) { \
			free(v); \
			v = NULL; \
		} \
	} while(0)
	CLEAR_ON_NONE(options->local_command);
	CLEAR_ON_NONE(options->remote_command);
	CLEAR_ON_NONE(options->proxy_command);
	CLEAR_ON_NONE(options->control_path);
	CLEAR_ON_NONE(options->revoked_host_keys);
	/* options->identity_agent distinguishes NULL from 'none' */
	/* options->user will be set in the main program if appropriate */
	/* options->hostname will be set in the main program if appropriate */
	/* options->host_key_alias should not be set by default */
	/* options->preferred_authentications will be set in ssh */
}

struct fwdarg {
	char *arg;
	int ispath;
};

/*
 * parse_fwd_field
 * parses the next field in a port forwarding specification.
 * sets fwd to the parsed field and advances p past the colon
 * or sets it to NULL at end of string.
 * returns 0 on success, else non-zero.
 */
static int
parse_fwd_field(char **p, struct fwdarg *fwd)
{
	char *ep, *cp = *p;
	int ispath = 0;

	if (*cp == '\0') {
		*p = NULL;
		return -1;	/* end of string */
	}

	/*
	 * A field escaped with square brackets is used literally.
	 * XXX - allow ']' to be escaped via backslash?
	 */
	if (*cp == '[') {
		/* find matching ']' */
		for (ep = cp + 1; *ep != ']' && *ep != '\0'; ep++) {
			if (*ep == '/')
				ispath = 1;
		}
		/* no matching ']' or not at end of field. */
		if (ep[0] != ']' || (ep[1] != ':' && ep[1] != '\0'))
			return -1;
		/* NUL terminate the field and advance p past the colon */
		*ep++ = '\0';
		if (*ep != '\0')
			*ep++ = '\0';
		fwd->arg = cp + 1;
		fwd->ispath = ispath;
		*p = ep;
		return 0;
	}

	for (cp = *p; *cp != '\0'; cp++) {
		switch (*cp) {
		case '\\':
			memmove(cp, cp + 1, strlen(cp + 1) + 1);
			if (*cp == '\0')
				return -1;
			break;
		case '/':
			ispath = 1;
			break;
		case ':':
			*cp++ = '\0';
			goto done;
		}
	}
done:
	fwd->arg = *p;
	fwd->ispath = ispath;
	*p = cp;
	return 0;
}

/*
 * parse_forward
 * parses a string containing a port forwarding specification of the form:
 *   dynamicfwd == 0
 *	[listenhost:]listenport|listenpath:connecthost:connectport|connectpath
 *	listenpath:connectpath
 *   dynamicfwd == 1
 *	[listenhost:]listenport
 * returns number of arguments parsed or zero on error
 */
int
parse_forward(struct Forward *fwd, const char *fwdspec, int dynamicfwd, int remotefwd)
{
	struct fwdarg fwdargs[4];
	char *p, *cp;
	int i;

	memset(fwd, 0, sizeof(*fwd));
	memset(fwdargs, 0, sizeof(fwdargs));

	cp = p = xstrdup(fwdspec);

	/* skip leading spaces */
	while (isspace((u_char)*cp))
		cp++;

	for (i = 0; i < 4; ++i) {
		if (parse_fwd_field(&cp, &fwdargs[i]) != 0)
			break;
	}

	/* Check for trailing garbage */
	if (cp != NULL && *cp != '\0') {
		i = 0;	/* failure */
	}

	switch (i) {
	case 1:
		if (fwdargs[0].ispath) {
			fwd->listen_path = xstrdup(fwdargs[0].arg);
			fwd->listen_port = PORT_STREAMLOCAL;
		} else {
			fwd->listen_host = NULL;
			fwd->listen_port = a2port(fwdargs[0].arg);
		}
		fwd->connect_host = xstrdup("socks");
		break;

	case 2:
		if (fwdargs[0].ispath && fwdargs[1].ispath) {
			fwd->listen_path = xstrdup(fwdargs[0].arg);
			fwd->listen_port = PORT_STREAMLOCAL;
			fwd->connect_path = xstrdup(fwdargs[1].arg);
			fwd->connect_port = PORT_STREAMLOCAL;
		} else if (fwdargs[1].ispath) {
			fwd->listen_host = NULL;
			fwd->listen_port = a2port(fwdargs[0].arg);
			fwd->connect_path = xstrdup(fwdargs[1].arg);
			fwd->connect_port = PORT_STREAMLOCAL;
		} else {
			fwd->listen_host = xstrdup(fwdargs[0].arg);
			fwd->listen_port = a2port(fwdargs[1].arg);
			fwd->connect_host = xstrdup("socks");
		}
		break;

	case 3:
		if (fwdargs[0].ispath) {
			fwd->listen_path = xstrdup(fwdargs[0].arg);
			fwd->listen_port = PORT_STREAMLOCAL;
			fwd->connect_host = xstrdup(fwdargs[1].arg);
			fwd->connect_port = a2port(fwdargs[2].arg);
		} else if (fwdargs[2].ispath) {
			fwd->listen_host = xstrdup(fwdargs[0].arg);
			fwd->listen_port = a2port(fwdargs[1].arg);
			fwd->connect_path = xstrdup(fwdargs[2].arg);
			fwd->connect_port = PORT_STREAMLOCAL;
		} else {
			fwd->listen_host = NULL;
			fwd->listen_port = a2port(fwdargs[0].arg);
			fwd->connect_host = xstrdup(fwdargs[1].arg);
			fwd->connect_port = a2port(fwdargs[2].arg);
		}
		break;

	case 4:
		fwd->listen_host = xstrdup(fwdargs[0].arg);
		fwd->listen_port = a2port(fwdargs[1].arg);
		fwd->connect_host = xstrdup(fwdargs[2].arg);
		fwd->connect_port = a2port(fwdargs[3].arg);
		break;
	default:
		i = 0; /* failure */
	}

	free(p);

	if (dynamicfwd) {
		if (!(i == 1 || i == 2))
			goto fail_free;
	} else {
		if (!(i == 3 || i == 4)) {
			if (fwd->connect_path == NULL &&
			    fwd->listen_path == NULL)
				goto fail_free;
		}
		if (fwd->connect_port <= 0 && fwd->connect_path == NULL)
			goto fail_free;
	}

	if ((fwd->listen_port < 0 && fwd->listen_path == NULL) ||
	    (!remotefwd && fwd->listen_port == 0))
		goto fail_free;
	if (fwd->connect_host != NULL &&
	    strlen(fwd->connect_host) >= NI_MAXHOST)
		goto fail_free;
	/* XXX - if connecting to a remote socket, max sun len may not match this host */
	if (fwd->connect_path != NULL &&
	    strlen(fwd->connect_path) >= PATH_MAX_SUN)
		goto fail_free;
	if (fwd->listen_host != NULL &&
	    strlen(fwd->listen_host) >= NI_MAXHOST)
		goto fail_free;
	if (fwd->listen_path != NULL &&
	    strlen(fwd->listen_path) >= PATH_MAX_SUN)
		goto fail_free;

	return (i);

 fail_free:
	free(fwd->connect_host);
	fwd->connect_host = NULL;
	free(fwd->connect_path);
	fwd->connect_path = NULL;
	free(fwd->listen_host);
	fwd->listen_host = NULL;
	free(fwd->listen_path);
	fwd->listen_path = NULL;
	return (0);
}

int
parse_jump(const char *s, Options *o, int active)
{
	char *orig, *sdup, *cp;
	char *host = NULL, *user = NULL;
	int ret = -1, port = -1, first;

	active &= o->proxy_command == NULL && o->jump_host == NULL;

	orig = sdup = xstrdup(s);
	first = active;
	do {
		if ((cp = strrchr(sdup, ',')) == NULL)
			cp = sdup; /* last */
		else
			*cp++ = '\0';

		if (first) {
			/* First argument and configuration is active */
			if (parse_user_host_port(cp, &user, &host, &port) != 0)
				goto out;
		} else {
			/* Subsequent argument or inactive configuration */
			if (parse_user_host_port(cp, NULL, NULL, NULL) != 0)
				goto out;
		}
		first = 0; /* only check syntax for subsequent hosts */
	} while (cp != sdup);
	/* success */
	if (active) {
		o->jump_user = user;
		o->jump_host = host;
		o->jump_port = port;
		o->proxy_command = xstrdup("none");
		user = host = NULL;
		if ((cp = strrchr(s, ',')) != NULL && cp != s) {
			o->jump_extra = xstrdup(s);
			o->jump_extra[cp - s] = '\0';
		}
	}
	ret = 0;
 out:
	free(orig);
	free(user);
	free(host);
	return ret;
}

/* XXX the following is a near-vebatim copy from servconf.c; refactor */
static const char *
fmt_multistate_int(int val, const struct multistate *m)
{
	u_int i;

	for (i = 0; m[i].key != NULL; i++) {
		if (m[i].value == val)
			return m[i].key;
	}
	return "UNKNOWN";
}

static const char *
fmt_intarg(OpCodes code, int val)
{
	if (val == -1)
		return "unset";
	switch (code) {
	case oAddressFamily:
		return fmt_multistate_int(val, multistate_addressfamily);
	case oVerifyHostKeyDNS:
	case oUpdateHostkeys:
		return fmt_multistate_int(val, multistate_yesnoask);
	case oStrictHostKeyChecking:
		return fmt_multistate_int(val, multistate_strict_hostkey);
	case oControlMaster:
		return fmt_multistate_int(val, multistate_controlmaster);
	case oTunnel:
		return fmt_multistate_int(val, multistate_tunnel);
	case oRequestTTY:
		return fmt_multistate_int(val, multistate_requesttty);
	case oCanonicalizeHostname:
		return fmt_multistate_int(val, multistate_canonicalizehostname);
	case oFingerprintHash:
		return ssh_digest_alg_name(val);
	default:
		switch (val) {
		case 0:
			return "no";
		case 1:
			return "yes";
		default:
			return "UNKNOWN";
		}
	}
}

static const char *
lookup_opcode_name(OpCodes code)
{
	u_int i;

	for (i = 0; keywords[i].name != NULL; i++)
		if (keywords[i].opcode == code)
			return(keywords[i].name);
	return "UNKNOWN";
}

static void
dump_cfg_int(OpCodes code, int val)
{
	printf("%s %d\n", lookup_opcode_name(code), val);
}

static void
dump_cfg_fmtint(OpCodes code, int val)
{
	printf("%s %s\n", lookup_opcode_name(code), fmt_intarg(code, val));
}

static void
dump_cfg_string(OpCodes code, const char *val)
{
	if (val == NULL)
		return;
	printf("%s %s\n", lookup_opcode_name(code), val);
}

static void
dump_cfg_strarray(OpCodes code, u_int count, char **vals)
{
	u_int i;

	for (i = 0; i < count; i++)
		printf("%s %s\n", lookup_opcode_name(code), vals[i]);
}

static void
dump_cfg_strarray_oneline(OpCodes code, u_int count, char **vals)
{
	u_int i;

	printf("%s", lookup_opcode_name(code));
	for (i = 0; i < count; i++)
		printf(" %s",  vals[i]);
	printf("\n");
}

static void
dump_cfg_forwards(OpCodes code, u_int count, const struct Forward *fwds)
{
	const struct Forward *fwd;
	u_int i;

	/* oDynamicForward */
	for (i = 0; i < count; i++) {
		fwd = &fwds[i];
		if (code == oDynamicForward && fwd->connect_host != NULL &&
		    strcmp(fwd->connect_host, "socks") != 0)
			continue;
		if (code == oLocalForward && fwd->connect_host != NULL &&
		    strcmp(fwd->connect_host, "socks") == 0)
			continue;
		printf("%s", lookup_opcode_name(code));
		if (fwd->listen_port == PORT_STREAMLOCAL)
			printf(" %s", fwd->listen_path);
		else if (fwd->listen_host == NULL)
			printf(" %d", fwd->listen_port);
		else {
			printf(" [%s]:%d",
			    fwd->listen_host, fwd->listen_port);
		}
		if (code != oDynamicForward) {
			if (fwd->connect_port == PORT_STREAMLOCAL)
				printf(" %s", fwd->connect_path);
			else if (fwd->connect_host == NULL)
				printf(" %d", fwd->connect_port);
			else {
				printf(" [%s]:%d",
				    fwd->connect_host, fwd->connect_port);
			}
		}
		printf("\n");
	}
}

void
dump_client_config(Options *o, const char *host)
{
	int i;
	char buf[8];

	/* This is normally prepared in ssh_kex2 */
	if (kex_assemble_names(KEX_DEFAULT_PK_ALG, &o->hostkeyalgorithms) != 0)
		fatal("%s: kex_assemble_names failed", __func__);

	/* Most interesting options first: user, host, port */
	dump_cfg_string(oUser, o->user);
	dump_cfg_string(oHostName, host);
	dump_cfg_int(oPort, o->port);

	/* Flag options */
	dump_cfg_fmtint(oAddressFamily, o->address_family);
	dump_cfg_fmtint(oBatchMode, o->batch_mode);
	dump_cfg_fmtint(oCanonicalizeFallbackLocal, o->canonicalize_fallback_local);
	dump_cfg_fmtint(oCanonicalizeHostname, o->canonicalize_hostname);
	dump_cfg_fmtint(oChallengeResponseAuthentication, o->challenge_response_authentication);
	dump_cfg_fmtint(oCheckHostIP, o->check_host_ip);
	dump_cfg_fmtint(oCompression, o->compression);
	dump_cfg_fmtint(oControlMaster, o->control_master);
	dump_cfg_fmtint(oEnableSSHKeysign, o->enable_ssh_keysign);
	dump_cfg_fmtint(oClearAllForwardings, o->clear_forwardings);
	dump_cfg_fmtint(oExitOnForwardFailure, o->exit_on_forward_failure);
	dump_cfg_fmtint(oFingerprintHash, o->fingerprint_hash);
	dump_cfg_fmtint(oForwardAgent, o->forward_agent);
	dump_cfg_fmtint(oForwardX11, o->forward_x11);
	dump_cfg_fmtint(oForwardX11Trusted, o->forward_x11_trusted);
	dump_cfg_fmtint(oGatewayPorts, o->fwd_opts.gateway_ports);
#ifdef GSSAPI
	dump_cfg_fmtint(oGssAuthentication, o->gss_authentication);
	dump_cfg_fmtint(oGssDelegateCreds, o->gss_deleg_creds);
#endif /* GSSAPI */
	dump_cfg_fmtint(oHashKnownHosts, o->hash_known_hosts);
	dump_cfg_fmtint(oHostbasedAuthentication, o->hostbased_authentication);
	dump_cfg_fmtint(oIdentitiesOnly, o->identities_only);
	dump_cfg_fmtint(oKbdInteractiveAuthentication, o->kbd_interactive_authentication);
	dump_cfg_fmtint(oNoHostAuthenticationForLocalhost, o->no_host_authentication_for_localhost);
	dump_cfg_fmtint(oPasswordAuthentication, o->password_authentication);
	dump_cfg_fmtint(oPermitLocalCommand, o->permit_local_command);
	dump_cfg_fmtint(oProxyUseFdpass, o->proxy_use_fdpass);
	dump_cfg_fmtint(oPubkeyAuthentication, o->pubkey_authentication);
	dump_cfg_fmtint(oRequestTTY, o->request_tty);
	dump_cfg_fmtint(oStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);
	dump_cfg_fmtint(oStrictHostKeyChecking, o->strict_host_key_checking);
	dump_cfg_fmtint(oTCPKeepAlive, o->tcp_keep_alive);
	dump_cfg_fmtint(oTunnel, o->tun_open);
	dump_cfg_fmtint(oUsePrivilegedPort, o->use_privileged_port);
	dump_cfg_fmtint(oVerifyHostKeyDNS, o->verify_host_key_dns);
	dump_cfg_fmtint(oVisualHostKey, o->visual_host_key);
	dump_cfg_fmtint(oUpdateHostkeys, o->update_hostkeys);

	/* Integer options */
	dump_cfg_int(oCanonicalizeMaxDots, o->canonicalize_max_dots);
	dump_cfg_int(oConnectionAttempts, o->connection_attempts);
	dump_cfg_int(oForwardX11Timeout, o->forward_x11_timeout);
	dump_cfg_int(oNumberOfPasswordPrompts, o->number_of_password_prompts);
	dump_cfg_int(oServerAliveCountMax, o->server_alive_count_max);
	dump_cfg_int(oServerAliveInterval, o->server_alive_interval);

	/* String options */
	dump_cfg_string(oBindAddress, o->bind_address);
	dump_cfg_string(oCiphers, o->ciphers ? o->ciphers : KEX_CLIENT_ENCRYPT);
	dump_cfg_string(oControlPath, o->control_path);
	dump_cfg_string(oHostKeyAlgorithms, o->hostkeyalgorithms);
	dump_cfg_string(oHostKeyAlias, o->host_key_alias);
	dump_cfg_string(oHostbasedKeyTypes, o->hostbased_key_types);
	dump_cfg_string(oIdentityAgent, o->identity_agent);
	dump_cfg_string(oKbdInteractiveDevices, o->kbd_interactive_devices);
	dump_cfg_string(oKexAlgorithms, o->kex_algorithms ? o->kex_algorithms : KEX_CLIENT_KEX);
	dump_cfg_string(oLocalCommand, o->local_command);
	dump_cfg_string(oRemoteCommand, o->remote_command);
	dump_cfg_string(oLogLevel, log_level_name(o->log_level));
	dump_cfg_string(oMacs, o->macs ? o->macs : KEX_CLIENT_MAC);
#ifdef ENABLE_PKCS11
	dump_cfg_string(oPKCS11Provider, o->pkcs11_provider);
#endif
	dump_cfg_string(oPreferredAuthentications, o->preferred_authentications);
	dump_cfg_string(oPubkeyAcceptedKeyTypes, o->pubkey_key_types);
	dump_cfg_string(oRevokedHostKeys, o->revoked_host_keys);
	dump_cfg_string(oXAuthLocation, o->xauth_location);

	/* Forwards */
	dump_cfg_forwards(oDynamicForward, o->num_local_forwards, o->local_forwards);
	dump_cfg_forwards(oLocalForward, o->num_local_forwards, o->local_forwards);
	dump_cfg_forwards(oRemoteForward, o->num_remote_forwards, o->remote_forwards);

	/* String array options */
	dump_cfg_strarray(oIdentityFile, o->num_identity_files, o->identity_files);
	dump_cfg_strarray_oneline(oCanonicalDomains, o->num_canonical_domains, o->canonical_domains);
	dump_cfg_strarray_oneline(oGlobalKnownHostsFile, o->num_system_hostfiles, o->system_hostfiles);
	dump_cfg_strarray_oneline(oUserKnownHostsFile, o->num_user_hostfiles, o->user_hostfiles);
	dump_cfg_strarray(oSendEnv, o->num_send_env, o->send_env);

	/* Special cases */

	/* oConnectTimeout */
	if (o->connection_timeout == -1)
		printf("connecttimeout none\n");
	else
		dump_cfg_int(oConnectTimeout, o->connection_timeout);

	/* oTunnelDevice */
	printf("tunneldevice");
	if (o->tun_local == SSH_TUNID_ANY)
		printf(" any");
	else
		printf(" %d", o->tun_local);
	if (o->tun_remote == SSH_TUNID_ANY)
		printf(":any");
	else
		printf(":%d", o->tun_remote);
	printf("\n");

	/* oCanonicalizePermittedCNAMEs */
	if ( o->num_permitted_cnames > 0) {
		printf("canonicalizePermittedcnames");
		for (i = 0; i < o->num_permitted_cnames; i++) {
			printf(" %s:%s", o->permitted_cnames[i].source_list,
			    o->permitted_cnames[i].target_list);
		}
		printf("\n");
	}

	/* oControlPersist */
	if (o->control_persist == 0 || o->control_persist_timeout == 0)
		dump_cfg_fmtint(oControlPersist, o->control_persist);
	else
		dump_cfg_int(oControlPersist, o->control_persist_timeout);

	/* oEscapeChar */
	if (o->escape_char == SSH_ESCAPECHAR_NONE)
		printf("escapechar none\n");
	else {
		vis(buf, o->escape_char, VIS_WHITE, 0);
		printf("escapechar %s\n", buf);
	}

	/* oIPQoS */
	printf("ipqos %s ", iptos2str(o->ip_qos_interactive));
	printf("%s\n", iptos2str(o->ip_qos_bulk));

	/* oRekeyLimit */
	printf("rekeylimit %llu %d\n",
	    (unsigned long long)o->rekey_limit, o->rekey_interval);

	/* oStreamLocalBindMask */
	printf("streamlocalbindmask 0%o\n",
	    o->fwd_opts.streamlocal_bind_mask);

	/* oProxyCommand / oProxyJump */
	if (o->jump_host == NULL)
		dump_cfg_string(oProxyCommand, o->proxy_command);
	else {
		/* Check for numeric addresses */
		i = strchr(o->jump_host, ':') != NULL ||
		    strspn(o->jump_host, "1234567890.") == strlen(o->jump_host);
		snprintf(buf, sizeof(buf), "%d", o->jump_port);
		printf("proxyjump %s%s%s%s%s%s%s%s%s\n",
		    /* optional additional jump spec */
		    o->jump_extra == NULL ? "" : o->jump_extra,
		    o->jump_extra == NULL ? "" : ",",
		    /* optional user */
		    o->jump_user == NULL ? "" : o->jump_user,
		    o->jump_user == NULL ? "" : "@@",
		    /* opening [ if hostname is numeric */
		    i ? "[" : "",
		    /* mandatory hostname */
		    o->jump_host,
		    /* closing ] if hostname is numeric */
		    i ? "]" : "",
		    /* optional port number */
		    o->jump_port <= 0 ? "" : ":",
		    o->jump_port <= 0 ? "" : buf);
	}
}
@


1.278
log
@Expand ssh_config's StrictModes option with two new settings:

StrictModes=accept-new will automatically accept hitherto-unseen keys
but will refuse connections for changed or invalid hostkeys.

StrictModes=off is the same as StrictModes=no

Motivation:

StrictModes=no combines two behaviours for host key processing:
automatically learning new hostkeys and continuing to connect to hosts
with invalid/changed hostkeys. The latter behaviour is quite dangerous
since it removes most of the protections the SSH protocol is supposed to
provide.

Quite a few users want to automatically learn hostkeys however, so
this makes that feature available with less danger.

At some point in the future, StrictModes=no will change to be a synonym
for accept-new, with its current behaviour remaining available via
StrictModes=off.

bz#2400, suggested by Michael Samuel; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.277 2017/05/30 18:58:37 bluhm Exp $ */
d824 1
d1244 4
a1247 2
		if (opcode == oLocalForward ||
		    opcode == oRemoteForward) {
d1249 13
a1261 7
			if (arg2 == NULL || *arg2 == '\0')
				fatal("%.200s line %d: Missing target argument.",
				    filename, linenum);

			/* construct a string for parse_forward */
			snprintf(fwdarg, sizeof(fwdarg), "%s:%s", arg, arg2);
		} else if (opcode == oDynamicForward) {
a1262 1
		}
d1264 1
a1264 3
		if (parse_forward(&fwd, fwdarg,
		    opcode == oDynamicForward ? 1 : 0,
		    opcode == oRemoteForward ? 1 : 0) == 0)
d1269 3
a1271 2
			if (opcode == oLocalForward ||
			    opcode == oDynamicForward)
d1273 1
a1273 2
			else if (opcode == oRemoteForward)
				add_remote_forward(options, &fwd);
@


1.277
log
@Add RemoteCommand option to specify a command in the ssh config
file instead of giving it on the client's command line.  This command
will be executed on the remote host.  The feature allows to automate
tasks using ssh config.
OK markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.276 2017/05/20 02:35:47 djm Exp $ */
d739 10
d982 1
a982 1
		multistate_ptr = multistate_yesnoask;
d1925 1
a1925 1
		options->strict_host_key_checking = 2;	/* 2 is default */
a2324 1
	case oStrictHostKeyChecking:
d2327 2
@


1.276
log
@there's no reason to artificially limit the key path here, just check
that it fits PATH_MAX; spotted by Matthew Patton
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.275 2017/04/30 23:18:22 djm Exp $ */
d151 2
a152 1
	oTunnel, oTunnelDevice, oLocalCommand, oPermitLocalCommand,
d273 1
d1430 4
d1822 1
d2025 1
d2503 1
@


1.275
log
@remove SSHv1 configuration options and man pages bits

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.274 2017/04/30 23:15:04 djm Exp $ */
d426 2
a427 2
	else
		(void)xasprintf(&path, "%.100s%.100s", dir, filename);
@


1.274
log
@remove SSHv1 ciphers; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.273 2017/04/30 23:11:45 djm Exp $ */
a938 8
	case oRSAAuthentication:
		intptr = &options->rsa_authentication;
		goto parse_flag;

	case oRhostsRSAAuthentication:
		intptr = &options->rhosts_rsa_authentication;
		goto parse_flag;

a988 4
	case oCompressionLevel:
		intptr = &options->compression_level;
		goto parse_int;

a1752 1
	options->rsa_authentication = -1;
a1759 1
	options->rhosts_rsa_authentication = -1;
a1765 1
	options->compression_level = -1;
a1888 2
	if (options->rsa_authentication == -1)
		options->rsa_authentication = 1;
a1900 2
	if (options->rhosts_rsa_authentication == -1)
		options->rhosts_rsa_authentication = 0;
a1912 2
	if (options->compression_level == -1)
		options->compression_level = 6;
a2466 4
#ifdef WITH_RSA1
	dump_cfg_fmtint(oRhostsRSAAuthentication, o->rhosts_rsa_authentication);
	dump_cfg_fmtint(oRSAAuthentication, o->rsa_authentication);
#endif
@


1.273
log
@remove options.protocol and client Protocol configuration knob

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.272 2017/04/30 23:10:43 djm Exp $ */
d170 1
a228 1
	{ "cipher", oCipher },
a1162 13
	case oCipher:
		intptr = &options->cipher;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		value = cipher_number(arg);
		if (value == -1)
			fatal("%.200s line %d: Bad cipher '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

a1785 1
	options->cipher = -1;
a1941 3
	/* Selected in ssh_login(). */
	if (options->cipher == -1)
		options->cipher = SSH_CIPHER_NOT_SET;
a2570 4

	/* oCipher */
	if (o->cipher != SSH_CIPHER_NOT_SET)
		printf("Cipher %s\n", cipher_name(o->cipher));
@


1.272
log
@unifdef WITH_SSH1
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.271 2017/04/28 03:20:27 dtucker Exp $ */
d140 1
a140 1
	oUsePrivilegedPort, oLogFacility, oLogLevel, oCiphers, oProtocol, oMacs,
d159 1
a159 1
	oIgnoredUnknownOption, oDeprecated, oUnsupported
d169 1
a230 1
	{ "protocol", oProtocol },
d854 2
a1225 13
	case oProtocol:
		intptr = &options->protocol;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		value = proto_spec(arg);
		if (value == SSH_PROTO_UNKNOWN)
			fatal("%.200s line %d: Bad protocol spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && *intptr == SSH_PROTO_UNKNOWN)
			*intptr = value;
		break;

a1803 1
	options->protocol = SSH_PROTO_UNKNOWN;
a1959 2
	if (options->protocol == SSH_PROTO_UNKNOWN)
		options->protocol = SSH_PROTO_2;
d1963 5
a1967 14
		if (options->protocol & SSH_PROTO_1) {
			add_identity_file(options, "~/",
			    _PATH_SSH_CLIENT_IDENTITY, 0);
		}
		if (options->protocol & SSH_PROTO_2) {
			add_identity_file(options, "~/",
			    _PATH_SSH_CLIENT_ID_RSA, 0);
			add_identity_file(options, "~/",
			    _PATH_SSH_CLIENT_ID_DSA, 0);
			add_identity_file(options, "~/",
			    _PATH_SSH_CLIENT_ID_ECDSA, 0);
			add_identity_file(options, "~/",
			    _PATH_SSH_CLIENT_ID_ED25519, 0);
		}
a2357 11
	case oProtocol:
		switch (val) {
		case SSH_PROTO_1:
			return "1";
		case SSH_PROTO_2:
			return "2";
		case (SSH_PROTO_1|SSH_PROTO_2):
			return "2,1";
		default:
			return "UNKNOWN";
		}
a2501 1
	dump_cfg_fmtint(oProtocol, o->protocol);
@


1.271
log
@Add SyslogFacility option to ssh(1) matching the equivalent option in
sshd(8).  bz#2705, patch from erahn at arista.com, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.270 2017/03/10 04:27:32 djm Exp $ */
a195 5
#ifdef WITH_SSH1
	{ "rsaauthentication", oRSAAuthentication },
	{ "rhostsrsaauthentication", oRhostsRSAAuthentication },
	{ "compressionlevel", oCompressionLevel },
# else
a198 1
#endif
a2554 3
#ifdef WITH_SSH1
	dump_cfg_int(oCompressionLevel, o->compression_level);
#endif
@


1.270
log
@better match sshd config parser behaviour: fatal() if line is overlong,
increase line buffer to match sshd's; bz#2651 reported by Don Fong;
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.269 2017/03/10 03:24:48 dtucker Exp $ */
d140 1
a140 1
	oUsePrivilegedPort, oLogLevel, oCiphers, oProtocol, oMacs,
d253 1
d819 1
d1254 11
d1839 1
d2014 2
@


1.269
log
@Plug mem leak on GLOB_NOMATCH case.  From jjelen at redhat.com via
bz#2687, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.268 2017/02/03 23:01:19 djm Exp $ */
d1708 1
a1708 1
	char line[1024];
d1738 2
@


1.268
log
@support =- for removing methods from algorithms lists, e.g.
Ciphers=-*cbc; suggested by Cristian Ionescu-Idbohrn in bz#2671
"I like it" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.267 2017/02/03 05:05:56 djm Exp $ */
d1488 1
@


1.267
log
@allow form-feed characters at EOL; bz#2431 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.266 2017/01/30 00:38:50 djm Exp $ */
d1182 1
a1182 1
		if (!ciphers_valid(*arg == '+' ? arg + 1 : arg))
d1193 1
a1193 1
		if (!mac_valid(*arg == '+' ? arg + 1 : arg))
d1205 2
a1206 1
		if (!kex_names_valid(*arg == '+' ? arg + 1 : arg))
d1220 2
a1221 1
		if (!sshkey_names_valid2(*arg == '+' ? arg + 1 : arg, 1))
@


1.266
log
@small cleanup post SSHv1 removal:

remove SSHv1-isms in commented examples

reorder token table to group deprecated and compile-time conditional tokens
better

fix config dumping code for some compile-time conditional options that
weren't being correctly skipped (SSHv1 and PKCS#11)
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.265 2017/01/30 00:34:01 djm Exp $ */
d830 1
a830 1
	/* Strip trailing whitespace */
d834 1
a834 1
		if (strchr(WHITESPACE, line[len]) == NULL)
@


1.265
log
@some explicit NULL tests when dumping configured forwardings;
from Karsten Weiss
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.264 2017/01/06 09:27:52 djm Exp $ */
d81 1
a81 1
     Cipher 3des
d96 1
a96 1
     Cipher none
d168 38
a213 1
	{ "rhostsauthentication", oDeprecated },
a216 1
	{ "rsaauthentication", oRSAAuthentication },
a218 1
	{ "rhostsrsaauthentication", oRhostsRSAAuthentication },
a222 12
	{ "kerberosauthentication", oUnsupported },
	{ "kerberostgtpassing", oUnsupported },
	{ "afstokenpassing", oUnsupported },
#if defined(GSSAPI)
	{ "gssapiauthentication", oGssAuthentication },
	{ "gssapidelegatecredentials", oGssDelegateCreds },
#else
	{ "gssapiauthentication", oUnsupported },
	{ "gssapidelegatecredentials", oUnsupported },
#endif
	{ "fallbacktorsh", oDeprecated },
	{ "usersh", oDeprecated },
a243 1
	{ "globalknownhostsfile2", oDeprecated },
a244 1
	{ "userknownhostsfile2", oDeprecated },
a249 1
	{ "compressionlevel", oCompressionLevel },
a257 7
#ifdef ENABLE_PKCS11
	{ "smartcarddevice", oPKCS11Provider },
	{ "pkcs11provider", oPKCS11Provider },
#else
	{ "smartcarddevice", oUnsupported },
	{ "pkcs11provider", oUnsupported },
#endif
a277 1
	{ "useroaming", oDeprecated },
d2525 1
d2528 1
d2540 1
d2542 1
d2562 1
d2564 1
@


1.264
log
@fix previous
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.263 2017/01/06 03:53:58 djm Exp $ */
d2437 1
a2437 1
		if (code == oDynamicForward &&
d2440 1
a2440 1
		if (code == oLocalForward &&
@


1.263
log
@show a useful error message when included config files can't be
opened; bz#2653, ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.262 2016/10/25 04:08:13 jsg Exp $ */
d1490 1
a1490 1
				if (errno != ENOENT) {
@


1.262
log
@Fix logic in add_local_forward() that inverted a test when code was
refactored out into bind_permitted().  This broke ssh port forwarding
for non-priv ports as a non root user.

ok dtucker@@ 'looks good' deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.261 2016/10/23 22:04:05 dtucker Exp $ */
d1490 5
@


1.261
log
@Factor out "can bind to low ports" check into its own function.  This will make
it easier for Portable to support platforms with permissions models other than
uid==0 (eg bz#2625).  ok djm@@, "doesn't offend me too much" deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.260 2016/08/25 23:56:51 djm Exp $ */
d300 1
a300 1
	if (bind_permitted(newfwd->listen_port, original_real_uid) &&
@


1.260
log
@remove superfluous NOTREACHED comment
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.259 2016/07/22 03:35:11 djm Exp $ */
d300 1
a300 1
	if (newfwd->listen_port < IPPORT_RESERVED && original_real_uid != 0 &&
@


1.259
log
@reverse the order in which -J/JumpHost proxies are visited to be
more intuitive and document

reported by and manpage bits naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.258 2016/07/20 10:45:27 naddy Exp $ */
a845 1
		/* NOTREACHED */
@


1.258
log
@Do not clobber the global jump_host variables when parsing an inactive
configuration.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.257 2016/07/15 00:24:30 djm Exp $ */
d2278 6
a2283 1
	while ((cp = strsep(&sdup, ",")) && cp != NULL) {
d2294 1
a2294 1
	}
d2302 4
a2305 2
		if ((cp = strchr(s, ',')) != NULL && cp[1] != '\0')
			o->jump_extra = xstrdup(cp + 1);
d2629 3
d2643 1
a2643 4
		    o->jump_port <= 0 ? "" : buf,
		    /* optional additional jump spec */
		    o->jump_extra == NULL ? "" : ",",
		    o->jump_extra == NULL ? "" : o->jump_extra);
@


1.257
log
@Add a ProxyJump ssh_config(5) option and corresponding -J ssh(1)
command-line flag to allow simplified indirection through a
SSH bastion or "jump host".

These options construct a proxy command that connects to the
specified jump host(s) (more than one may be specified) and uses
port-forwarding to establish a connection to the next destination.

This codifies the safest way of indirecting connections through SSH
servers and makes it easy to use.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.256 2016/06/03 04:09:38 dtucker Exp $ */
d2272 1
a2272 1
	int ret = -1, port = -1;
d2277 1
d2279 1
a2279 1
		if (active) {
d2288 1
a2288 1
		active = 0; /* only check syntax for subsequent hosts */
d2291 9
a2299 8
	free(orig);
	o->jump_user = user;
	o->jump_host = host;
	o->jump_port = port;
	o->proxy_command = xstrdup("none");
	user = host = NULL;
	if ((cp = strchr(s, ',')) != NULL && cp[1] != '\0')
		o->jump_extra = xstrdup(cp + 1);
d2302 1
@


1.256
log
@Allow ExitOnForwardFailure and ClearAllForwardings to be overridden when
using ssh -W (but still default to yes in that case).  bz#2577, ok djm@@.
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.255 2016/06/03 03:14:41 dtucker Exp $ */
d158 1
a158 1
	oPubkeyAcceptedKeyTypes,
d283 1
d1110 3
d1121 12
d1793 4
d2267 38
d2456 1
a2456 1
	char vbuf[5];
a2533 1
	dump_cfg_string(oProxyCommand, o->proxy_command);
d2594 2
a2595 2
		vis(vbuf, o->escape_char, VIS_WHITE, 0);
		printf("escapechar %s\n", vbuf);
d2609 26
@


1.255
log
@Move the host and port used by ssh -W into the Options struct.
This will make future changes a bit easier.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.254 2016/05/04 14:29:58 markus Exp $ */
d1738 1
a1784 1
	options->clear_forwardings = -1;
d1858 4
d1863 8
a1870 1
		options->exit_on_forward_failure = 0;
a1958 2
	if (options->clear_forwardings == 1)
		clear_forwardings(options);
d2419 1
@


1.254
log
@allow setting IdentityAgent to SSH_AUTH_SOCK; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.253 2016/05/04 12:21:53 markus Exp $ */
d1736 2
@


1.253
log
@IdentityAgent for specifying specific agent sockets; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.252 2016/04/15 00:30:19 djm Exp $ */
d2020 1
@


1.252
log
@Include directive for ssh_config(5); feedback & ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.251 2016/04/06 06:42:17 djm Exp $ */
d135 1
a135 1
	oCertificateFile, oAddKeysToAgent,
d205 1
d1625 4
d1807 1
d2455 1
@


1.251
log
@don't record duplicate LocalForward and RemoteForward entries;
fixes failure with ExitOnForwardFailure+hostname canonicalisation
where the same forwards are added on the second pass through
the configuration file. bz#2562; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.250 2016/02/08 23:40:12 djm Exp $ */
d27 1
d118 7
d129 1
a129 1
	oHost, oMatch,
d258 1
a783 1
#define WHITESPACE " \t\r\n"
d789 10
d802 1
a802 1
	int negated, opcode, *intptr, value, value2, cmdline = 0;
d809 1
d1269 2
d1303 1
a1303 1
		*activep = value;
d1431 57
a1645 1

a1650 1

d1655 12
d1669 1
a1669 1
	int active, linenum;
d1672 3
a1693 1
	active = 1;
d1698 2
a1699 2
		if (process_config_line(options, pw, host, original_host,
		    line, filename, linenum, &active, flags) != 0)
@


1.250
log
@don't attempt to percent_expand() already-canonicalised addresses,
avoiding unnecessary failures when attempting to connect to scoped
IPv6 addresses (that naturally contain '%' characters)
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.249 2016/01/29 02:54:45 dtucker Exp $ */
d287 1
d292 5
d319 1
d321 5
@


1.249
log
@Allow RekeyLimits in excess of 4G up to 2**63 bits (limited by the return
type of scan_scaled).  Part of bz#2521, ok djm.
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.248 2016/01/14 16:17:40 markus Exp $ */
d513 3
a515 1
	if (options->hostname != NULL) {
d519 1
a519 1
	} else
d521 1
@


1.248
log
@remove roaming support; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.247 2016/01/14 14:34:34 deraadt Exp $ */
a966 4
			/* check for too-large or too-small limits */
			if (val64 > UINT_MAX)
				fatal("%.200s line %d: RekeyLimit too large",
				    filename, linenum);
d972 1
a972 1
			options->rekey_limit = (u_int32_t)val64;
d2421 2
a2422 2
	printf("rekeylimit %lld %d\n",
	    (long long)o->rekey_limit, o->rekey_interval);
@


1.247
log
@Disable experimental client-side roaming support.  Server side was
disabled/gutted for years already, but this aspect was surprisingly
forgotten.
Thanks for report from Qualys
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.246 2015/11/15 22:26:49 jcs Exp $ */
d144 1
a144 1
	oVisualHostKey, oUseRoaming,
d255 1
a255 1
	{ "useroaming", oUseRoaming },
a1415 4
	case oUseRoaming:
		intptr = &options->use_roaming;
		goto parse_flag;

a1699 1
	options->use_roaming = 0;
a1872 1
	options->use_roaming = 0;
@


1.246
log
@Add an AddKeysToAgent client option which can be set to 'yes', 'no',
'ask', or 'confirm', and defaults to 'no'.  When enabled, a private
key that is used during authentication will be added to ssh-agent if
it is running (with confirmation enabled if set to 'confirm').

Initial version from Joachim Schipper many years ago.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.245 2015/10/27 08:54:52 djm Exp $ */
d1704 1
a1704 1
	options->use_roaming = -1;
d1878 1
a1878 2
	if (options->use_roaming == -1)
		options->use_roaming = 1;
@


1.245
log
@fix execv arguments in a way less likely to cause grief for -portable;
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.243 2015/10/25 23:14:03 dtucker Exp $ */
d127 1
a127 1
	oCertificateFile,
d196 1
d704 9
d1534 5
d1705 1
d1810 2
@


1.244
log
@avoid de-const warning & shrink; ok dtucker@@
@
text
@d449 1
a449 1
		char *argv[] = { shell, "-c", xstrdup(cmd), NULL };
d462 5
@


1.243
log
@Do not prepend "exec" to the shell command run by "Match exec" in a config
file.  It's an unnecessary optimization from repurposed ProxyCommand code
and prevents some things working with some shells.  bz#2471, pointed out
by res at qoxp.net.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.242 2015/10/07 15:59:12 djm Exp $ */
d449 1
a449 1
		char *argv[4];
a461 5

		argv[0] = shell;
		argv[1] = "-c";
		argv[2] = cmd;
		argv[3] = NULL;
@


1.242
log
@include PubkeyAcceptedKeyTypes in ssh -G config dump
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.241 2015/09/24 06:15:11 djm Exp $ */
d433 1
a433 1
	char *shell, *command_string;
a440 6
	/*
	 * Use "exec" to avoid "sh -c" processes on some platforms
	 * (e.g. Solaris)
	 */
	xasprintf(&command_string, "exec %s", cmd);

d465 1
a465 1
		argv[2] = command_string;
a479 1
	free(command_string);
@


1.241
log
@add ssh_config CertificateFile option to explicitly list
a certificate; patch from Meghana Bhat on bz#2436; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.240 2015/08/21 23:53:08 djm Exp $ */
d2352 1
@


1.240
log
@Fix printing (ssh -G ...) of HostKeyAlgorithms=+...
Reported by Bryan Drewery
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.239 2015/07/30 00:01:34 djm Exp $ */
d127 1
d195 1
d359 24
d998 18
d1660 1
@


1.239
log
@Allow ssh_config and sshd_config kex parameters options be prefixed
by a '+' to indicate that the specified items be appended to the
default rather than replacing it.

approach suggested by dtucker@@, feedback dlg@@, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.238 2015/07/10 06:21:53 markus Exp $ */
d2232 4
d2296 1
a2296 1
	dump_cfg_string(oHostKeyAlgorithms, o->hostkeyalgorithms ? o->hostkeyalgorithms : KEX_DEFAULT_PK_ALG);
@


1.239.2.1
log
@MFC changes by: deraadt@@cvs.openbsd.org 2016/01/14 07:34:34

Disable experimental client-side roaming support.  Server side was
disabled/gutted for years already, but this aspect was surprisingly
forgotten.
Thanks for report from Qualys
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.239 2015/07/30 00:01:34 djm Exp $ */
d1651 1
a1651 1
	options->use_roaming = 0;
d1822 2
a1823 1
	options->use_roaming = 0;
@


1.238
log
@Turn off DSA by default; add HostKeyAlgorithms to the server and
PubkeyAcceptedKeyTypes to the client side, so it still can be
tested or turned back on; feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.237 2015/06/26 05:13:20 djm Exp $ */
d1077 1
a1077 1
		if (!ciphers_valid(arg))
d1088 1
a1088 1
		if (!mac_valid(arg))
d1100 1
a1100 1
		if (!kex_names_valid(arg))
d1114 1
a1114 1
		if (!sshkey_names_valid2(arg, 1))
a1752 3
	/* options->ciphers, default set in myproposals.h */
	/* options->macs, default set in myproposals.h */
	/* options->kex_algorithms, default set in myproposals.h */
d1844 8
a1851 4
	if (options->hostbased_key_types == NULL)
		options->hostbased_key_types = xstrdup(KEX_DEFAULT_PK_ALG);
	if (options->pubkey_key_types == NULL)
		options->pubkey_key_types = xstrdup(KEX_DEFAULT_PK_ALG);
@


1.237
log
@Fix \-escaping bug that caused forward path parsing to skip two
characters and skip past the end of the string.

Based on patch by Salvador Fandino; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.236 2015/05/22 04:45:52 djm Exp $ */
d149 1
d268 1
d1108 2
d1112 2
a1113 1
			fatal("%.200s line %d: Missing argument.", filename, linenum);
d1115 4
a1118 4
			fatal("%.200s line %d: Bad protocol 2 host key algorithms '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && options->hostkeyalgorithms == NULL)
			options->hostkeyalgorithms = xstrdup(arg);
d1481 5
a1485 10
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.",
			    filename, linenum);
		if (!sshkey_names_valid2(arg, 1))
			fatal("%s line %d: Bad key types '%s'.",
				filename, linenum, arg ? arg : "<NONE>");
		if (*activep && *charptr == NULL)
			*charptr = xstrdup(arg);
		break;
d1667 1
d1848 3
a1850 1
		options->hostbased_key_types = xstrdup("*");
@


1.236
log
@Reorder EscapeChar option parsing to avoid a single-byte out-
of-bounds read. bz#2396 from Jaak Ristioja; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.235 2015/05/04 06:10:48 djm Exp $ */
d1916 2
a1917 1
			cp++;
@


1.235
log
@Remove pattern length argument from match_pattern_list(),
we only ever use it for strlen(pattern).

Prompted by hanno AT hboeck.de pointing an out-of-bound read
error caused by an incorrect pattern length found using AFL
and his own tools.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.234 2015/04/24 01:36:00 deraadt Exp $ */
d1227 5
a1231 1
		if (arg[0] == '^' && arg[2] == 0 &&
a1233 4
		else if (strlen(arg) == 1)
			value = (u_char) arg[0];
		else if (strcmp(arg, "none") == 0)
			value = SSH_ESCAPECHAR_NONE;
@


1.234
log
@rename xrealloc() to xreallocarray() since it follows that form.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.233 2015/03/30 00:00:29 djm Exp $ */
a482 1
	size_t len;
a534 1
		len = strlen(arg);
d537 1
a537 1
			r = match_hostname(host, arg, len) == 1;
d542 1
a542 1
			r = match_hostname(original_host, arg, len) == 1;
d547 1
a547 1
			r = match_pattern_list(ruser, arg, len, 0) == 1;
d552 1
a552 1
			r = match_pattern_list(pw->pw_name, arg, len, 0) == 1;
d654 2
a655 2
	if (ignored_unknown != NULL && match_pattern_list(cp, ignored_unknown,
	    strlen(ignored_unknown), 1) == 1)
@


1.233
log
@fix uninitialised memory read when parsing a config file consisting
of a single nul byte. Found by hanno AT hboeck.de using AFL;
ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.232 2015/02/16 22:13:32 djm Exp $ */
d286 1
a286 1
	options->local_forwards = xrealloc(options->local_forwards,
d309 1
a309 1
	options->remote_forwards = xrealloc(options->remote_forwards,
@


1.232
log
@Revise hostkeys@@openssh.com hostkey learning extension.

The client will not ask the server to prove ownership of the private
halves of any hitherto-unseen hostkeys it offers to the client.

Allow UpdateHostKeys option to take an 'ask' argument to let the
user manually review keys offered.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.231 2015/02/02 07:41:40 djm Exp $ */
d754 3
a756 1
	for (len = strlen(line) - 1; len > 0; len--) {
@


1.232.2.1
log
@MFC changes by: deraadt@@cvs.openbsd.org 2016/01/14 07:34:34

Disable experimental client-side roaming support.  Server side was
disabled/gutted for years already, but this aspect was surprisingly
forgotten.
Thanks for report from Qualys
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.232 2015/02/16 22:13:32 djm Exp $ */
d1651 1
a1651 1
	options->use_roaming = 0;
d1824 2
a1825 1
	options->use_roaming = 0;
@


1.231
log
@turn UpdateHostkeys off by default until I figure out mlarkin@@'s
warning message; requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.230 2015/01/30 11:43:14 djm Exp $ */
d1471 2
a1472 1
		goto parse_flag;
d2097 1
@


1.230
log
@Add a ssh_config HostbasedKeyType option to control which
host public key types are tried during hostbased authentication.

This may be used to prevent too many keys being sent to the server,
and blowing past its MaxAuthTries limit.

bz#2211 based on patch by Iain Morgan; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.229 2015/01/26 03:04:45 djm Exp $ */
d1844 1
a1844 1
		options->update_hostkeys = 1;
@


1.229
log
@Host key rotation support.

Add a hostkeys@@openssh.com protocol extension (global request) for
a server to inform a client of all its available host key after
authentication has completed. The client may record the keys in
known_hosts, allowing it to upgrade to better host key algorithms
and a server to gracefully rotate its keys.

The client side of this is controlled by a UpdateHostkeys config
option (default on).

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.228 2015/01/16 06:40:12 deraadt Exp $ */
d148 1
a148 1
	oFingerprintHash, oUpdateHostkeys,
d266 1
d1473 13
d1665 1
d1845 2
d2287 1
d2296 1
a2297 1
	dump_cfg_string(oRevokedHostKeys, o->revoked_host_keys);
d2299 1
@


1.228
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.227 2015/01/15 09:40:00 djm Exp $ */
d148 1
a148 1
	oFingerprintHash,
d265 1
d1468 4
d1650 1
d1828 2
d2253 1
@


1.227
log
@sync ssh-keysign, ssh-keygen and some dependencies to the new
buffer/key API; mostly mechanical, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.226 2015/01/13 07:39:19 djm Exp $ */
d34 1
@


1.226
log
@add sshd_config HostbasedAcceptedKeyTypes and PubkeyAcceptedKeyTypes
options to allow sshd to control what public key types will be
accepted. Currently defaults to all. Feedback & ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.225 2015/01/08 13:44:36 djm Exp $ */
d43 1
a43 1
#include "key.h"
a46 1
#include "buffer.h"
@


1.225
log
@fix ssh_config FingerprintHash evaluation order; from Petr Lautrbach
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.224 2014/12/21 22:27:56 djm Exp $ */
d1107 1
a1107 1
		if (!key_names_valid2(arg))
@


1.224
log
@Add FingerprintHash option to control algorithm used for key
fingerprints. Default changes from MD5 to SHA256 and format
from hex to base64.

Feedback and ok naddy@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.223 2014/12/04 02:24:32 djm Exp $ */
d1455 1
d1463 2
a1464 2
		if (*activep)
			options->fingerprint_hash = value;
@


1.223
log
@add RevokedHostKeys option for the client

Allow textfile or KRL-based revocation of hostkeys.
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.222 2014/10/24 02:01:20 lteo Exp $ */
d52 1
d148 1
d264 1
d1454 12
d1643 1
d1819 3
d2079 2
d2215 1
@


1.222
log
@Remove unnecessary include: netinet/in_systm.h is not needed by these
programs.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.221 2014/10/08 22:20:25 djm Exp $ */
d146 1
a146 1
	oStreamLocalBindMask, oStreamLocalBindUnlink,
d261 1
d1447 4
d1627 1
d1813 1
d2247 1
@


1.221
log
@Tweak config reparsing with host canonicalisation

Make the second pass through the config files always run when
hostname canonicalisation is enabled.

Add a "Match canonical" criteria that allows ssh_config Match
blocks to trigger only in the second config pass.

Add a -G option to ssh that causes it to parse its configuration
and dump the result to stdout, similar to "sshd -T"

Allow ssh_config Port options set in the second config parse
phase to be applied (they were being ignored).

bz#2267 bz#2286; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.220 2014/07/15 15:54:14 millert Exp $ */
a21 1
#include <netinet/in_systm.h>
@


1.220
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.219 2014/04/23 12:42:34 djm Exp $ */
d36 1
d52 1
d132 1
a132 1
	oGlobalKnownHostsFile2, oUserKnownHostsFile2, oPubkeyAuthentication,
d209 1
a209 1
	{ "userknownhostsfile2", oDeprecated }, 
d462 1
a462 1
	} 
d472 2
a473 1
    const char *host_arg, const char *filename, int linenum)
d475 1
a475 1
	char *arg, *attrib, *cmd, *cp = *condition, *host;
d477 1
a477 1
	int r, port, result = 1, attributes = 0;
d494 8
a501 3
	debug3("checking match for '%s' host %s", cp, host);
	while ((attrib = strdelim(&cp)) && *attrib != '\0') {
		attributes++;
d503 1
a503 1
			if (attributes != 1 ||
d505 3
a507 2
				error("'all' cannot be combined with other "
				    "Match attributes");
d511 2
a512 2
			*condition = cp;
			result = 1;
d515 11
d533 4
a536 5
			if (match_hostname(host, arg, len) != 1)
				result = 0;
			else
				debug("%.200s line %d: matched 'Host %.100s' ",
				    filename, linenum, host);
d538 4
a541 6
			if (match_hostname(host_arg, arg, len) != 1)
				result = 0;
			else
				debug("%.200s line %d: matched "
				    "'OriginalHost %.100s' ",
				    filename, linenum, host_arg);
d543 4
a546 5
			if (match_pattern_list(ruser, arg, len, 0) != 1)
				result = 0;
			else
				debug("%.200s line %d: matched 'User %.100s' ",
				    filename, linenum, ruser);
d548 4
a551 6
			if (match_pattern_list(pw->pw_name, arg, len, 0) != 1)
				result = 0;
			else
				debug("%.200s line %d: matched "
				    "'LocalUser %.100s' ",
				    filename, linenum, pw->pw_name);
d564 1
a564 1
			    "n", host_arg,
d571 10
a580 18
				debug("%.200s line %d: skipped exec \"%.100s\"",
				    filename, linenum, cmd);
			} else {
				r = execute_in_shell(cmd);
				if (r == -1) {
					fatal("%.200s line %d: match exec "
					    "'%.100s' error", filename,
					    linenum, cmd);
				} else if (r == 0) {
					debug("%.200s line %d: matched "
					    "'exec \"%.100s\"'", filename,
					    linenum, cmd);
				} else {
					debug("%.200s line %d: no match "
					    "'exec \"%.100s\"'", filename,
					    linenum, cmd);
					result = 0;
				}
d582 1
d584 4
d593 4
d603 3
a605 1
	debug3("match %sfound", result ? "" : "not ");
a606 1
 out:
d729 2
a730 1
    char *line, const char *filename, int linenum, int *activep, int userconfig)
d786 3
a788 1
		if ((value = convtime(arg)) == -1)
d825 1
a825 1
	
d960 2
a961 1
			add_identity_file(options, NULL, arg, userconfig);
d1209 2
a1210 2
		value = match_cfg_line(options, &s, pw, host,
		    filename, linenum);
d1458 1
a1458 1
		fatal("process_config_line: Unimplemented opcode %d", opcode);
d1478 1
a1478 1
    Options *options, int flags)
d1509 2
a1510 2
		if (process_config_line(options, pw, host, line, filename,
		    linenum, &active, flags & SSHCONF_USERCONF) != 0)
d2020 292
@


1.219
log
@don't record duplicate IdentityFiles
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.218 2014/02/23 20:11:36 djm Exp $ */
d19 1
d44 1
a46 1
#include "misc.h"
d145 1
d258 2
d271 1
a271 1
add_local_forward(Options *options, const Forward *newfwd)
d273 1
a273 1
	Forward *fwd;
d276 2
a277 1
	if (newfwd->listen_port < IPPORT_RESERVED && original_real_uid != 0)
d286 1
d289 1
d298 1
a298 1
add_remote_forward(Options *options, const Forward *newfwd)
d300 1
a300 1
	Forward *fwd;
d309 1
d312 1
d324 1
d326 1
d335 1
d337 1
d722 1
a722 1
	Forward fwd;
d812 1
a812 1
		intptr = &options->gateway_ports;
d1412 15
d1524 3
a1526 1
	options->gateway_ports = -1;
d1639 6
a1644 2
	if (options->gateway_ports == -1)
		options->gateway_ports = 0;
d1794 67
d1865 2
a1866 1
 *	[listenhost:]listenport:connecthost:connectport
d1872 1
a1872 1
parse_forward(Forward *fwd, const char *fwdspec, int dynamicfwd, int remotefwd)
d1874 2
a1876 1
	char *p, *cp, *fwdarg[4];
d1878 2
a1879 1
	memset(fwd, '\0', sizeof(*fwd));
d1887 2
a1888 2
	for (i = 0; i < 4; ++i)
		if ((fwdarg[i] = hpdelim(&cp)) == NULL)
d1890 1
d1893 1
a1893 1
	if (cp != NULL)
d1895 1
d1899 7
a1905 2
		fwd->listen_host = NULL;
		fwd->listen_port = a2port(fwdarg[0]);
d1910 15
a1924 3
		fwd->listen_host = xstrdup(cleanhostname(fwdarg[0]));
		fwd->listen_port = a2port(fwdarg[1]);
		fwd->connect_host = xstrdup("socks");
d1928 16
a1943 4
		fwd->listen_host = NULL;
		fwd->listen_port = a2port(fwdarg[0]);
		fwd->connect_host = xstrdup(cleanhostname(fwdarg[1]));
		fwd->connect_port = a2port(fwdarg[2]);
d1947 4
a1950 4
		fwd->listen_host = xstrdup(cleanhostname(fwdarg[0]));
		fwd->listen_port = a2port(fwdarg[1]);
		fwd->connect_host = xstrdup(cleanhostname(fwdarg[2]));
		fwd->connect_port = a2port(fwdarg[3]);
d1962 6
a1967 3
		if (!(i == 3 || i == 4))
			goto fail_free;
		if (fwd->connect_port <= 0)
d1971 2
a1972 1
	if (fwd->listen_port < 0 || (!remotefwd && fwd->listen_port == 0))
a1973 1

d1977 4
d1984 3
a1986 1

d1993 2
d1997 2
@


1.218
log
@reparse ssh_config and ~/.ssh/config if hostname canonicalisation changes
the hostname. This allows users to write configurations that always
refer to canonical hostnames, e.g.

CanonicalizeHostname yes
CanonicalDomains int.example.org example.org
CanonicalizeFallbackLocal no

Host *.int.example.org
    Compression off
Host *.example.org
    User djm

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.217 2014/02/22 01:32:19 djm Exp $ */
d339 1
d349 10
@


1.217
log
@when processing Match blocks, skip 'exec' clauses if previous predicates
failed to match; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.216 2014/01/29 06:18:35 djm Exp $ */
d1461 7
d1565 15
a1582 1

d1735 1
a1735 1
		if (v != NULL && strcasecmp(v, "none") == 0) { \
@


1.216
log
@remove experimental, never-enabled JPAKE code; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.215 2013/12/06 13:39:49 markus Exp $ */
d531 3
a533 7
			r = execute_in_shell(cmd);
			if (r == -1) {
				fatal("%.200s line %d: match exec '%.100s' "
				    "error", filename, linenum, cmd);
			} else if (r == 0) {
				debug("%.200s line %d: matched "
				    "'exec \"%.100s\"' ",
d535 17
a551 2
			} else
				result = 0;
@


1.215
log
@support ed25519 keys (hostkeys and user identities) using the public domain
ed25519 reference code from SUPERCOP, see http://ed25519.cr.yp.to/software.html
feedback, help & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.214 2013/11/20 20:54:10 deraadt Exp $ */
d140 1
a140 1
	oVisualHostKey, oUseRoaming, oZeroKnowledgePasswordAuthentication,
a246 6
#ifdef JPAKE
	{ "zeroknowledgepasswordauthentication",
	    oZeroKnowledgePasswordAuthentication },
#else
	{ "zeroknowledgepasswordauthentication", oUnsupported },
#endif
a791 4
	case oZeroKnowledgePasswordAuthentication:
		intptr = &options->zero_knowledge_password_authentication;
		goto parse_flag;

a1533 1
	options->zero_knowledge_password_authentication = -1;
a1686 2
	if (options->zero_knowledge_password_authentication == -1)
		options->zero_knowledge_password_authentication = 0;
@


1.214
log
@unsigned casts for ctype macros where neccessary
ok guenther millert markus
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.213 2013/10/24 00:51:48 dtucker Exp $ */
d1640 2
@


1.213
log
@Disallow empty Match statements and add "Match all" which matches everything.
ok djm, man page help jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.212 2013/10/23 03:05:19 djm Exp $ */
d1748 1
a1748 1
	while (isspace(*cp))
@


1.212
log
@comment
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.211 2013/10/23 03:03:07 djm Exp $ */
d456 1
a456 1
	int r, port, result = 1;
d475 13
d553 5
@


1.211
log
@Hostname may have %h sequences that should be expanded prior to Match
evaluation; spotted by Iain Morgan
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.210 2013/10/20 06:19:27 djm Exp $ */
d467 1
@


1.210
log
@rename "command" subclause of the recently-added "Match" keyword to
"exec"; it's shorter, clearer in intent and we might want to add the
ability to match against the command being executed at the remote end in
the future.
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.209 2013/10/16 22:49:38 djm Exp $ */
d454 2
a455 2
	char *arg, *attrib, *cmd, *cp = *condition;
	const char *ruser, *host;
d466 5
a470 1
	host = options->hostname == NULL ? host_arg : options->hostname;
d476 2
a477 1
			return -1;
d536 2
a537 1
			return -1;
d542 2
@


1.209
log
@s/canonicalise/canonicalize/ for consistency with existing spelling,
e.g. authorized_keys; pointed out by naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.208 2013/10/16 02:31:45 djm Exp $ */
d501 1
a501 1
		} else if (strcasecmp(attrib, "command") == 0) {
d520 1
a520 1
				fatal("%.200s line %d: match command '%.100s' "
d524 1
a524 1
				    "'Command \"%.100s\"' ",
@


1.208
log
@Implement client-side hostname canonicalisation to allow an explicit
search path of domain suffixes to use to convert unqualified host names
to fully-qualified ones for host key matching.
This is particularly useful for host certificates, which would otherwise
need to list unqualified names alongside fully-qualified ones (and this
causes a number of problems).

"looks fine" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.207 2013/10/14 23:28:23 djm Exp $ */
d142 2
a143 2
	oCanonicalDomains, oCanonicaliseHostname, oCanonicaliseMaxDots,
	oCanonicaliseFallbackLocal, oCanonicalisePermittedCNAMEs,
d258 4
a261 4
	{ "canonicalisefallbacklocal", oCanonicaliseFallbackLocal },
	{ "canonicalisehostname", oCanonicaliseHostname },
	{ "canonicalisemaxdots", oCanonicaliseMaxDots },
	{ "canonicalisepermittedcnames", oCanonicalisePermittedCNAMEs },
d641 1
a641 1
static const struct multistate multistate_canonicalisehostname[] = {
d1318 1
a1318 1
	case oCanonicalisePermittedCNAMEs:
d1347 3
a1349 3
	case oCanonicaliseHostname:
		intptr = &options->canonicalise_hostname;
		multistate_ptr = multistate_canonicalisehostname;
d1352 2
a1353 2
	case oCanonicaliseMaxDots:
		intptr = &options->canonicalise_max_dots;
d1356 2
a1357 2
	case oCanonicaliseFallbackLocal:
		intptr = &options->canonicalise_fallback_local;
d1525 3
a1527 3
	options->canonicalise_max_dots = -1;
	options->canonicalise_fallback_local = -1;
	options->canonicalise_hostname = -1;
d1679 6
a1684 6
	if (options->canonicalise_max_dots == -1)
		options->canonicalise_max_dots = 1;
	if (options->canonicalise_fallback_local == -1)
		options->canonicalise_fallback_local = 1;
	if (options->canonicalise_hostname == -1)
		options->canonicalise_hostname = SSH_CANONICALISE_NO;
@


1.207
log
@refactor client config code a little:

add multistate option partsing to readconf.c, similar to servconf.c's
existing code.

move checking of options that accept "none" as an argument to readconf.c

add a lowercase() function and use it instead of explicit tolower() in
loops

part of a larger diff that was ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.206 2013/10/14 22:22:02 djm Exp $ */
d142 2
d257 5
d539 28
d641 8
d668 1
d1304 56
d1523 5
d1679 6
@


1.206
log
@add a "Match" keyword to ssh_config that allows matching on hostname,
user and result of arbitrary commands. "nice work" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.205 2013/08/20 00:11:37 djm Exp $ */
d552 55
d624 1
d648 1
a648 2
	for (i = 0; i < strlen(keyword); i++)
		keyword[i] = tolower(keyword[i]);
d678 3
a680 1
parse_flag:
d683 12
a694 8
			fatal("%.200s line %d: Missing yes/no argument.", filename, linenum);
		value = 0;	/* To avoid compiler warning... */
		if (strcmp(arg, "yes") == 0 || strcmp(arg, "true") == 0)
			value = 1;
		else if (strcmp(arg, "no") == 0 || strcmp(arg, "false") == 0)
			value = 0;
		else
			fatal("%.200s line %d: Bad yes/no argument.", filename, linenum);
d777 2
a778 1
		goto parse_yesnoask;
d782 2
a783 17
parse_yesnoask:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing yes/no/ask argument.",
			    filename, linenum);
		value = 0;	/* To avoid compiler warning... */
		if (strcmp(arg, "yes") == 0 || strcmp(arg, "true") == 0)
			value = 1;
		else if (strcmp(arg, "no") == 0 || strcmp(arg, "false") == 0)
			value = 0;
		else if (strcmp(arg, "ask") == 0)
			value = 2;
		else
			fatal("%.200s line %d: Bad yes/no/ask argument.", filename, linenum);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;
a1123 4
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing address family.",
			    filename, linenum);
d1125 2
a1126 11
		if (strcasecmp(arg, "inet") == 0)
			value = AF_INET;
		else if (strcasecmp(arg, "inet6") == 0)
			value = AF_INET6;
		else if (strcasecmp(arg, "any") == 0)
			value = AF_UNSPEC;
		else
			fatal("Unsupported AddressFamily \"%s\"", arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;
d1165 2
a1166 21
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing ControlMaster argument.",
			    filename, linenum);
		value = 0;	/* To avoid compiler warning... */
		if (strcmp(arg, "yes") == 0 || strcmp(arg, "true") == 0)
			value = SSHCTL_MASTER_YES;
		else if (strcmp(arg, "no") == 0 || strcmp(arg, "false") == 0)
			value = SSHCTL_MASTER_NO;
		else if (strcmp(arg, "auto") == 0)
			value = SSHCTL_MASTER_AUTO;
		else if (strcmp(arg, "ask") == 0)
			value = SSHCTL_MASTER_ASK;
		else if (strcmp(arg, "autoask") == 0)
			value = SSHCTL_MASTER_AUTO_ASK;
		else
			fatal("%.200s line %d: Bad ControlMaster argument.",
			    filename, linenum);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;
d1198 2
a1199 19
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing yes/point-to-point/"
			    "ethernet/no argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcasecmp(arg, "ethernet") == 0)
			value = SSH_TUNMODE_ETHERNET;
		else if (strcasecmp(arg, "point-to-point") == 0)
			value = SSH_TUNMODE_POINTOPOINT;
		else if (strcasecmp(arg, "yes") == 0)
			value = SSH_TUNMODE_DEFAULT;
		else if (strcasecmp(arg, "no") == 0)
			value = SSH_TUNMODE_NO;
		else
			fatal("%s line %d: Bad yes/point-to-point/ethernet/"
			    "no argument: %s", filename, linenum, arg);
		if (*activep)
			*intptr = value;
		break;
a1247 4
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing argument.",
			    filename, linenum);
d1249 2
a1250 13
		if (strcasecmp(arg, "yes") == 0)
			value = REQUEST_TTY_YES;
		else if (strcasecmp(arg, "no") == 0)
			value = REQUEST_TTY_NO;
		else if (strcasecmp(arg, "force") == 0)
			value = REQUEST_TTY_FORCE;
		else if (strcasecmp(arg, "auto") == 0)
			value = REQUEST_TTY_AUTO;
		else
			fatal("Unsupported RequestTTY \"%s\"", arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;
d1574 10
a1583 2
	/* options->local_command should not be set by default */
	/* options->proxy_command should not be set by default */
@


1.205
log
@Add a ssh_config ProxyUseFDPass option that supports the use of
ProxyCommands that establish a connection and then pass a connected
file descriptor back to ssh(1). This allows the ProxyCommand to exit
rather than have to shuffle data back and forth and enables ssh to use
getpeername, etc. to obtain address information just like it does with
regular directly-connected sockets. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.204 2013/06/10 19:19:44 dtucker Exp $ */
d18 1
d26 1
d28 2
d49 1
d118 1
d124 1
a124 1
	oUser, oHost, oEscapeChar, oRhostsRSAAuthentication, oProxyCommand,
d198 1
d353 179
a534 1

a556 1

d558 2
a559 3
process_config_line(Options *options, const char *host,
		    char *line, const char *filename, int linenum,
		    int *activep, int userconfig)
d564 1
a564 1
	int negated, opcode, *intptr, value, value2;
d570 5
d1013 3
d1042 12
d1307 2
a1308 2
read_config_file(const char *filename, const char *host, Options *options,
    int flags)
d1339 2
a1340 2
		if (process_config_line(options, host, line, filename, linenum,
		    &active, flags & SSHCONF_USERCONF) != 0)
@


1.204
log
@revert 1.203 while we investigate crashes reported by okan@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.202 2013/05/17 00:13:14 djm Exp $ */
d135 1
a135 1
	oKexAlgorithms, oIPQoS, oRequestTTY, oIgnoreUnknown,
d247 1
d1070 4
d1235 1
d1386 2
@


1.203
log
@plug another memleak.  bz#1967, from Zhenbo Xu, detected by Melton, ok djm
@
text
@a816 2
		free(fwd.connect_host);
		free(fwd.listen_host);
@


1.202
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.201 2013/05/16 10:43:34 dtucker Exp $ */
d817 2
@


1.201
log
@remove now-unused variables
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.200 2013/05/16 09:12:31 dtucker Exp $ */
d305 2
a306 3
		if (options->local_forwards[i].listen_host != NULL)
			xfree(options->local_forwards[i].listen_host);
		xfree(options->local_forwards[i].connect_host);
d309 1
a309 1
		xfree(options->local_forwards);
d314 2
a315 3
		if (options->remote_forwards[i].listen_host != NULL)
			xfree(options->remote_forwards[i].listen_host);
		xfree(options->remote_forwards[i].connect_host);
d318 1
a318 1
		xfree(options->remote_forwards);
d1449 1
a1449 1
	xfree(p);
d1475 4
a1478 8
	if (fwd->connect_host != NULL) {
		xfree(fwd->connect_host);
		fwd->connect_host = NULL;
	}
	if (fwd->listen_host != NULL) {
		xfree(fwd->listen_host);
		fwd->listen_host = NULL;
	}
@


1.200
log
@switch RekeyLimit traffic volume parsing to scan_scaled.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.199 2013/05/16 04:27:50 djm Exp $ */
d382 1
a382 1
	int negated, opcode, *intptr, value, value2, scale;
d384 1
a384 1
	long long orig, val64;
@


1.199
log
@add the ability to ignore specific unrecognised ssh_config options;
bz#866; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.198 2013/05/16 02:00:34 dtucker Exp $ */
d30 1
d579 5
a583 27
			if (arg[0] < '0' || arg[0] > '9')
				fatal("%.200s line %d: Bad number.", filename,
				    linenum);
			orig = val64 = strtoll(arg, &endofnumber, 10);
			if (arg == endofnumber)
				fatal("%.200s line %d: Bad number.", filename,
			 linenum);
	 		switch (toupper(*endofnumber)) {
			case '\0':
				scale = 1;
				break;
			case 'K':
				scale = 1<<10;
				break;
			case 'M':
				scale = 1<<20;
				break;
			case 'G':
				scale = 1<<30;
				break;
			default:
				fatal("%.200s line %d: Invalid RekeyLimit "
				    "suffix", filename, linenum);
			}
			val64 *= scale;
			/* detect integer wrap and too-large limits */
			if ((val64 / scale) != orig || val64 > UINT_MAX)
@


1.198
log
@Add an optional second argument to RekeyLimit in the client to allow
rekeying based on elapsed time in addition to amount of traffic.
with djm@@ jmc@@, ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.197 2013/03/06 23:36:53 djm Exp $ */
d134 2
a135 2
	oKexAlgorithms, oIPQoS, oRequestTTY,
	oDeprecated, oUnsupported
d246 1
d351 2
a352 1
parse_token(const char *cp, const char *filename, int linenum)
d354 1
a354 1
	u_int i;
d357 1
a357 1
		if (strcasecmp(cp, keywords[i].name) == 0)
d359 3
a361 1

d380 1
a380 1
	u_int *uintptr, max_entries = 0;
d403 3
d407 2
a408 1
	opcode = parse_token(keyword, filename, linenum);
d415 4
d1088 4
d1253 1
@


1.197
log
@g/c unused variable (-Wunused)
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.196 2013/02/22 04:45:08 dtucker Exp $ */
d561 37
a597 22
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (arg[0] < '0' || arg[0] > '9')
			fatal("%.200s line %d: Bad number.", filename, linenum);
		orig = val64 = strtoll(arg, &endofnumber, 10);
		if (arg == endofnumber)
			fatal("%.200s line %d: Bad number.", filename, linenum);
		switch (toupper(*endofnumber)) {
		case '\0':
			scale = 1;
			break;
		case 'K':
			scale = 1<<10;
			break;
		case 'M':
			scale = 1<<20;
			break;
		case 'G':
			scale = 1<<30;
			break;
		default:
			fatal("%.200s line %d: Invalid RekeyLimit suffix",
			    filename, linenum);
a598 8
		val64 *= scale;
		/* detect integer wrap and too-large limits */
		if ((val64 / scale) != orig || val64 > UINT_MAX)
			fatal("%.200s line %d: RekeyLimit too large",
			    filename, linenum);
		if (val64 < 16)
			fatal("%.200s line %d: RekeyLimit too small",
			    filename, linenum);
d601 8
d1216 1
d1350 2
@


1.196
log
@Don't complain if IdentityFiles specified in system-wide configs are missing.
ok djm, deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.195 2013/02/17 23:16:57 dtucker Exp $ */
a1230 2
	int len;

@


1.195
log
@Keep track of which IndentityFile options were manually supplied and which
were default options, and don't warn if the latter are missing.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.194 2011/09/23 07:45:05 markus Exp $ */
d372 1
a372 1
		    int *activep)
d605 1
a605 1
			add_identity_file(options, NULL, arg, 1);
d1092 1
a1092 1
    int checkperm)
d1102 1
a1102 1
	if (checkperm) {
d1123 2
a1124 1
		if (process_config_line(options, host, line, filename, linenum, &active) != 0)
@


1.194
log
@unbreak remote portforwarding with dynamic allocated listen ports:
1) send the actual listen port in the open message (instead of 0).
   this allows multiple forwardings with a dynamic listen port
2) update the matching permit-open entry, so we can identify where
   to connect to
report: den at skbkontur.ru and P. Szczygielski
feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.193 2011/05/24 07:15:47 djm Exp $ */
d325 20
d605 1
a605 3
			charptr = &options->identity_files[*intptr];
			*charptr = xstrdup(arg);
			*intptr = *intptr + 1;
d1297 2
a1298 5
			len = 2 + strlen(_PATH_SSH_CLIENT_IDENTITY) + 1;
			options->identity_files[options->num_identity_files] =
			    xmalloc(len);
			snprintf(options->identity_files[options->num_identity_files++],
			    len, "~/%.100s", _PATH_SSH_CLIENT_IDENTITY);
d1301 6
a1306 17
			len = 2 + strlen(_PATH_SSH_CLIENT_ID_RSA) + 1;
			options->identity_files[options->num_identity_files] =
			    xmalloc(len);
			snprintf(options->identity_files[options->num_identity_files++],
			    len, "~/%.100s", _PATH_SSH_CLIENT_ID_RSA);

			len = 2 + strlen(_PATH_SSH_CLIENT_ID_DSA) + 1;
			options->identity_files[options->num_identity_files] =
			    xmalloc(len);
			snprintf(options->identity_files[options->num_identity_files++],
			    len, "~/%.100s", _PATH_SSH_CLIENT_ID_DSA);

			len = 2 + strlen(_PATH_SSH_CLIENT_ID_ECDSA) + 1;
			options->identity_files[options->num_identity_files] =
			    xmalloc(len);
			snprintf(options->identity_files[options->num_identity_files++],
			    len, "~/%.100s", _PATH_SSH_CLIENT_ID_ECDSA);
@


1.193
log
@Remove undocumented legacy options UserKnownHostsFile2 and
GlobalKnownHostsFile2 by making UserKnownHostsFile/GlobalKnownHostsFile
accept multiple paths per line and making their defaults include
known_hosts2; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.192 2011/05/06 21:34:32 djm Exp $ */
d293 1
@


1.192
log
@Add a RequestTTY ssh_config option to allow configuration-based
control over tty allocation (like -t/-T); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.191 2011/05/06 21:31:38 djm Exp $ */
d193 1
a193 1
	{ "globalknownhostsfile2", oGlobalKnownHostsFile2 },	/* obsolete */
d195 1
a195 1
	{ "userknownhostsfile2", oUserKnownHostsFile2 },	/* obsolete */
d353 3
a355 1
	char *s, **charptr, *endofnumber, *keyword, *arg, *arg2, fwdarg[256];
d599 2
a600 1
			fatal("%.200s line %d: Missing argument.", filename, linenum);
d606 14
a619 2
		charptr = &options->system_hostfile;
		goto parse_string;
d622 4
a625 10
		charptr = &options->user_hostfile;
		goto parse_string;

	case oGlobalKnownHostsFile2:
		charptr = &options->system_hostfile2;
		goto parse_string;

	case oUserKnownHostsFile2:
		charptr = &options->user_hostfile2;
		goto parse_string;
d1166 2
a1167 4
	options->system_hostfile = NULL;
	options->user_hostfile = NULL;
	options->system_hostfile2 = NULL;
	options->user_hostfile2 = NULL;
d1306 12
a1317 8
	if (options->system_hostfile == NULL)
		options->system_hostfile = _PATH_SSH_SYSTEM_HOSTFILE;
	if (options->user_hostfile == NULL)
		options->user_hostfile = _PATH_SSH_USER_HOSTFILE;
	if (options->system_hostfile2 == NULL)
		options->system_hostfile2 = _PATH_SSH_SYSTEM_HOSTFILE2;
	if (options->user_hostfile2 == NULL)
		options->user_hostfile2 = _PATH_SSH_USER_HOSTFILE2;
@


1.191
log
@support negated Host matching, e.g.

Host *.example.org !c.example.org
	User mekmitasdigoat

Will match "a.example.org", "b.example.org", but not "c.example.org"
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.190 2010/11/13 23:27:50 djm Exp $ */
d134 1
a134 1
	oKexAlgorithms, oIPQoS,
d245 1
d1013 20
d1193 1
d1351 2
@


1.190
log
@allow ssh and sshd to set arbitrary TOS/DSCP/QoS values instead of
hardcoding lowdelay/throughput.

bz#1733 patch from philipp AT redfish-solutions.com; ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.189 2010/09/22 05:01:29 djm Exp $ */
d353 1
a353 1
	int opcode, *intptr, value, value2, scale;
d792 5
a796 1
		while ((arg = strdelim(&s)) != NULL && *arg != '\0')
d798 10
a807 1
				debug("Applying options for %.100s", arg);
a808 1
				break;
d810 4
@


1.189
log
@add a KexAlgorithms knob to the client and server configuration to allow
selection of which key exchange methods are used by ssh(1) and sshd(8)
and their order of preference.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.188 2010/08/31 11:54:45 djm Exp $ */
d20 2
d134 1
a134 1
	oKexAlgorithms,
d244 1
d975 17
d1154 2
d1309 4
@


1.188
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.187 2010/07/19 09:15:12 djm Exp $ */
d132 1
d241 1
d700 12
d1091 1
d1205 1
@


1.187
log
@add a "ControlPersist" option that automatically starts a background
ssh(1) multiplex master when connecting. This connection can stay alive
indefinitely, or can be set to automatically close after a user-specified
duration of inactivity. bz#1330 - patch by dwmw2 AT infradead.org, but
further hacked on by wmertens AT cisco.com, apb AT cequrux.com,
martin-mindrot-bugzilla AT earth.li and myself; "looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.186 2010/06/25 23:15:36 djm Exp $ */
d1213 6
@


1.186
log
@Add X11ForwardTimeout option to specify timeout for untrusted X11
authentication cookies to avoid fallback in X11 code to fully-trusted
implicit authentication using SO_PEERCRED described at:
http://lists.x.org/archives/xorg-devel/2010-May/008636.html

After the X11ForwardTimeout has expired the client will now refuse
incoming X11 channel opens.

based on patch from Tavis Ormandy; "nice" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.185 2010/06/25 07:14:46 djm Exp $ */
d128 2
a129 1
	oSendEnv, oControlPath, oControlMaster, oHashKnownHosts,
d226 1
d883 24
d1108 2
d1245 4
@


1.185
log
@bz#1327: remove hardcoded limit of 100 permitopen clauses and port
forwards per direction; ok markus@@ stevesk@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.184 2010/05/16 12:55:51 markus Exp $ */
d110 2
a111 2
	oForwardAgent, oForwardX11, oForwardX11Trusted, oGatewayPorts,
	oExitOnForwardFailure,
d143 1
d414 4
d1022 1
d1109 2
@


1.184
log
@mux support for remote forwarding with dynamic port allocation,
use with
	LPORT=`ssh -S muxsocket -R0:localhost:25 -O forward somehost`
feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.183 2010/02/08 10:50:20 markus Exp $ */
d251 1
d254 3
a256 2
	if (options->num_local_forwards >= SSH_MAX_FORWARDS_PER_DIRECTION)
		fatal("Too many local forwards (max %d).", SSH_MAX_FORWARDS_PER_DIRECTION);
d274 4
a277 3
	if (options->num_remote_forwards >= SSH_MAX_FORWARDS_PER_DIRECTION)
		fatal("Too many remote forwards (max %d).",
		    SSH_MAX_FORWARDS_PER_DIRECTION);
d297 4
d307 4
d1057 1
d1059 1
@


1.183
log
@replace our obsolete smartcard code with PKCS#11.
	ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-11/v2-20/pkcs-11v2-20.pdf
ssh(1) and ssh-keygen(1) use dlopen(3) directly to talk to a PKCS#11
provider (shared library) while ssh-agent(1) delegates PKCS#11 to
a forked a ssh-pkcs11-helper process.
PKCS#11 is currently a compile time option.
feedback and ok djm@@; inspired by patches from Alon Bar-Lev
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.182 2010/01/09 23:04:13 dtucker Exp $ */
d281 1
@


1.182
log
@Remove RoutingDomain from ssh since it's now not needed.  It can be replaced
with "route exec" or "nc -V" as a proxycommand.  "route exec" also ensures
that trafic such as DNS lookups stays withing the specified routingdomain.

For example (from reyk):
# route -T 2 exec /usr/sbin/sshd
or inherited from the parent process
$ route -T 2 exec sh
$ ssh 10.1.2.3

ok deraadt@@ markus@@ stevesk@@ reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.178 2009/10/08 14:03:41 markus Exp $ */
d123 1
a123 1
	oHostKeyAlgorithms, oBindAddress, oSmartcardDevice,
d205 3
a207 2
#ifdef SMARTCARD
	{ "smartcarddevice", oSmartcardDevice },
d210 1
d609 2
a610 2
	case oSmartcardDevice:
		charptr = &options->smartcard_device;
d1051 1
a1051 1
	options->smartcard_device = NULL;
@


1.181
log
@Rename RDomain config option to RoutingDomain to be more clear and
consistent with other options.

NOTE: if you currently use RDomain in the ssh client or server config,
or ssh/sshd -o, you must update to use RoutingDomain.

ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.180 2009/12/25 19:40:21 stevesk Exp $ */
d130 2
a131 2
	oVisualHostKey, oUseRoaming, oRDomain,
	oZeroKnowledgePasswordAuthentication, oDeprecated, oUnsupported
a228 1
	{ "routingdomain", oRDomain },
a916 13
	case oRDomain:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.",
			    filename, linenum);
		value = a2rdomain(arg);
		if (value == -1)
			fatal("%.200s line %d: Bad rdomain.",
			    filename, linenum);
		if (*activep)
			options->rdomain = value;
		break;

a1066 1
	options->rdomain = -1;
a1214 1
	/* options->rdomain should not be set by default */
@


1.180
log
@validate routing domain is in range 0-RT_TABLEID_MAX.
'Looks right' deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.179 2009/10/28 16:38:18 reyk Exp $ */
d229 1
a229 1
	{ "rdomain", oRDomain },
@


1.179
log
@Allow to set the rdomain in ssh/sftp/scp/sshd and ssh-keyscan.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.178 2009/10/08 14:03:41 markus Exp $ */
d923 1
a923 1
		value = a2port(arg);
@


1.178
log
@disable protocol 1 by default (after a transition period of about 10 years)
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.177 2009/06/27 09:35:06 andreas Exp $ */
d130 2
a131 2
	oVisualHostKey, oUseRoaming, oZeroKnowledgePasswordAuthentication,
	oDeprecated, oUnsupported
d229 1
d918 13
d1081 1
d1230 1
@


1.177
log
@Add client option UseRoaming. It doesn't do anything yet but will
control whether the client tries to use roaming if enabled on the
server. From Martin Forssen.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.176 2009/02/12 03:00:56 djm Exp $ */
d1140 1
a1140 1
		options->protocol = SSH_PROTO_1|SSH_PROTO_2;
@


1.176
log
@support remote port forwarding with a zero listen port (-R0:...) to
dyamically allocate a listen port at runtime (this is actually
specified in rfc4254); bz#1003 ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.175 2009/01/22 10:02:34 djm Exp $ */
d130 1
a130 1
	oVisualHostKey, oZeroKnowledgePasswordAuthentication,
d228 1
d913 4
d1066 1
d1203 2
@


1.175
log
@make a2port() return -1 when it encounters an invalid port number
rather than 0, which it will now treat as valid (needed for future work)

adjust current consumers of a2port() to check its return value is <= 0,
which in turn required some things to be converted from u_short => int

make use of int vs. u_short consistent in some other places too

feedback & ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.174 2009/01/15 17:38:43 stevesk Exp $ */
d733 2
a734 1
		    opcode == oDynamicForward ? 1 : 0) == 0)
d1219 1
a1219 1
parse_forward(Forward *fwd, const char *fwdspec, int dynamicfwd)
d1282 1
a1282 1
	if (fwd->listen_port <= 0)
d1288 4
@


1.174
log
@1) use obsolete instead of alias for consistency
2) oUserKnownHostsFile not obsolete but oGlobalKnownHostsFile2 is
   so move the comment.
3) reorder so like options are together

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.173 2008/12/09 02:58:16 djm Exp $ */
d1277 1
a1277 1
		if (fwd->connect_port == 0)
d1281 1
a1281 1
	if (fwd->listen_port == 0)
@


1.173
log
@don't leave junk (free'd) pointers around in Forward *fwd argument on
failure; avoids double-free in ~C -L handler when given an invalid
forwarding specification; bz#1539 report from adejong AT debian.org
via Colin Watson; ok markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.172 2008/11/04 19:18:00 stevesk Exp $ */
d172 1
a172 1
	{ "identityfile2", oIdentityFile },			/* alias */
d188 2
a189 2
	{ "userknownhostsfile", oUserKnownHostsFile },		/* obsolete */
	{ "globalknownhostsfile2", oGlobalKnownHostsFile2 },
@


1.172
log
@because parse_forward() is now used to parse all forward types (DLR),
and it malloc's space for host variables, we don't need to malloc
here.  fixes small memory leaks.

previously dynamic forwards were not parsed in parse_forward() and
space was not malloc'd in that case.

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.171 2008/11/04 08:22:13 djm Exp $ */
d1291 1
a1291 1
	if (fwd->connect_host != NULL)
d1293 3
a1295 1
	if (fwd->listen_host != NULL)
d1297 2
@


1.171
log
@Add support for an experimental zero-knowledge password authentication
method using the J-PAKE protocol described in F. Hao, P. Ryan,
"Password Authenticated Key Exchange by Juggling", 16th Workshop on
Security Protocols, Cambridge, April 2008.

This method allows password-based authentication without exposing
the password to the server. Instead, the client and server exchange
cryptographic proofs to demonstrate of knowledge of the password while
revealing nothing useful to an attacker or compromised endpoint.

This is experimental, work-in-progress code and is presently
compiled-time disabled (turn on -DJPAKE in Makefile.inc).

"just commit it.  It isn't too intrusive." deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.170 2008/11/03 02:44:41 stevesk Exp $ */
d254 1
a254 2
	fwd->listen_host = (newfwd->listen_host == NULL) ?
	    NULL : xstrdup(newfwd->listen_host);
d256 1
a256 1
	fwd->connect_host = xstrdup(newfwd->connect_host);
d274 1
a274 2
	fwd->listen_host = (newfwd->listen_host == NULL) ?
	    NULL : xstrdup(newfwd->listen_host);
d276 1
a276 1
	fwd->connect_host = xstrdup(newfwd->connect_host);
@


1.170
log
@fix comment
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.169 2008/11/03 01:07:02 stevesk Exp $ */
d130 1
a130 1
	oVisualHostKey,
d228 7
d417 4
d1063 1
d1200 2
@


1.169
log
@remove valueless comment
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.168 2008/11/01 17:40:33 stevesk Exp $ */
d1223 1
a1223 1
	/* Check for trailing garbage in 4-arg case*/
@


1.168
log
@merge dynamic forward parsing into parse_forward(); 'i think this is OK' djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.167 2008/06/26 11:46:31 grunk Exp $ */
a939 1
	/* Open the file. */
@


1.167
log
@Move SSH Fingerprint Visualization away from sharing the config option
CheckHostIP to an own config option named VisualHostKey.
While there, fix the behaviour that ssh would draw a random art picture
on every newly seen host even when the option was not enabled.

prodded by deraadt@@, discussions,
help and ok markus@@ djm@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.165 2008/01/19 23:09:49 djm Exp $ */
d704 1
a708 4
		arg2 = strdelim(&s);
		if (arg2 == NULL || *arg2 == '\0')
			fatal("%.200s line %d: Missing target argument.",
			    filename, linenum);
d710 6
a715 2
		/* construct a string for parse_forward */
		snprintf(fwdarg, sizeof(fwdarg), "%s:%s", arg, arg2);
d717 8
a724 1
		if (parse_forward(&fwd, fwdarg) == 0)
d729 2
a730 1
			if (opcode == oLocalForward)
a736 26
	case oDynamicForward:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing port argument.",
			    filename, linenum);
		memset(&fwd, '\0', sizeof(fwd));
		fwd.connect_host = "socks";
		fwd.listen_host = hpdelim(&arg);
		if (fwd.listen_host == NULL ||
		    strlen(fwd.listen_host) >= NI_MAXHOST)
			fatal("%.200s line %d: Bad forwarding specification.",
			    filename, linenum);
		if (arg) {
			fwd.listen_port = a2port(arg);
			fwd.listen_host = cleanhostname(fwd.listen_host);
		} else {
			fwd.listen_port = a2port(fwd.listen_host);
			fwd.listen_host = NULL;
		}
		if (fwd.listen_port == 0)
			fatal("%.200s line %d: Badly formatted port number.",
			    filename, linenum);
		if (*activep)
			add_local_forward(options, &fwd);
		break;

d1200 1
d1202 2
d1207 1
a1207 1
parse_forward(Forward *fwd, const char *fwdspec)
d1229 12
d1260 11
a1270 1
	if (fwd->listen_port == 0 || fwd->connect_port == 0)
@


1.166
log
@Introduce SSH Fingerprint ASCII Visualization, a technique inspired by the
graphical hash visualization schemes known as "random art", and by
Dan Kaminsky's musings on the subject during a BlackOp talk at the
23C3 in Berlin.

Scientific publication (original paper):
"Hash Visualization: a New Technique to improve Real-World Security",
Perrig A. and Song D., 1999, International Workshop on Cryptographic
Techniques and E-Commerce (CrypTEC '99)
http://sparrow.ece.cmu.edu/~adrian/projects/validation/validation.pdf

The algorithm used here is a worm crawling over a discrete plane,
leaving a trace (augmenting the field) everywhere it goes.
Movement is taken from dgst_raw 2bit-wise.  Bumping into walls
makes the respective movement vector be ignored for this turn,
thus switching to the other color of the chessboard.
Graphs are not unambiguous for now, because circles in graphs can be
walked in either direction.

discussions with several people,
help, corrections and ok markus@@ djm@@
@
text
@d130 1
d227 1
d452 1
a452 17
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing CheckHostIP argument.",
			    filename, linenum);
		value = 0;	/* To avoid compiler warning... */
		if (strcmp(arg, "yes") == 0 || strcmp(arg, "true") == 0)
			value = SSHCTL_CHECKHOSTIP_YES;
		else if (strcmp(arg, "no") == 0 || strcmp(arg, "false") == 0)
			value = SSHCTL_CHECKHOSTIP_NO;
		else if (strcmp(arg, "fingerprint") == 0)
			value = SSHCTL_CHECKHOSTIP_FPR;
		else
			fatal("%.200s line %d: Bad CheckHostIP argument.",
			    filename, linenum);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;
d915 4
d1069 1
d1204 2
@


1.165
log
@promote rekeylimit to a int64 so it can hold the maximum useful limit
of 2^32; report and patch from Jan.Pechanec AT Sun.COM, ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.164 2007/12/31 10:41:31 dtucker Exp $ */
d450 17
a466 1
		goto parse_flag;
@


1.164
log
@Prevent strict-aliasing warnings on newer gcc versions.  bz #1355, patch
from Dmitry V. Levin, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.163 2007/10/22 19:10:24 markus Exp $ */
a496 1
		intptr = &options->rekey_limit;
d524 1
a524 1
		if ((val64 / scale) != orig || val64 > INT_MAX)
d530 2
a531 2
		if (*activep && *intptr == -1)
			*intptr = (int)val64;
@


1.163
log
@make sure that both the local and remote port are correct when
parsing -L; Jan Pechanec (bz #1378)
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.162 2007/03/20 03:56:12 tedu Exp $ */
d324 1
d691 1
a691 1
		intptr = (int *) &options->log_level;
d697 2
a698 2
		if (*activep && (LogLevel) *intptr == SYSLOG_LEVEL_NOT_SET)
			*intptr = (LogLevel) value;
@


1.162
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.161 2007/01/21 01:45:35 stevesk Exp $ */
d1253 1
a1253 1
	if (fwd->listen_port == 0 && fwd->connect_port == 0)
@


1.161
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.160 2007/01/17 23:22:52 dtucker Exp $ */
d1222 1
a1222 1
	while (*cp && isspace(*cp))
@


1.160
log
@Honour activep for times (eg ServerAliveInterval) while parsing
ssh_config and ~/.ssh/config so they work properly with Host directives.
From mario.lorenz@@wincor-nixdorf.com via bz #1275.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.159 2006/08/03 03:34:42 deraadt Exp $ */
d543 1
a543 1
			charptr =  &options->identity_files[*intptr];
@


1.159
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.158 2006/08/01 23:22:47 stevesk Exp $ */
d362 1
a362 1
		if (*intptr == -1)
@


1.158
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.157 2006/07/22 20:48:23 stevesk Exp $ */
a14 2
#include "includes.h"

d24 1
d29 1
a30 1
#include "xmalloc.h"
d35 1
d39 1
@


1.157
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.156 2006/07/17 01:31:09 stevesk Exp $ */
d26 1
@


1.156
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.155 2006/07/12 22:28:52 stevesk Exp $ */
d26 1
@


1.155
log
@move #include <netdb.h> out of includes.h; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.154 2006/07/11 20:07:25 stevesk Exp $ */
d26 1
@


1.154
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.153 2006/07/11 18:50:48 markus Exp $ */
d25 1
@


1.153
log
@add ExitOnForwardFailure: terminate the connection if ssh(1)
cannot set up all requested dynamic, local, and remote port
forwardings. ok djm, dtucker, stevesk, jmc
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.152 2006/07/05 02:42:09 stevesk Exp $ */
d24 1
@


1.152
log
@move #include <netinet/in.h> out of includes.h; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.151 2006/03/25 13:17:02 djm Exp $ */
d105 1
d136 1
d389 4
d994 1
d1075 2
@


1.151
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d19 3
@


1.150
log
@RCSID() can die
@
text
@d1 1
@


1.149
log
@potential NULL pointer dereferences detected by Coverity
via elad AT netbsd.org; ok deraadt@@
@
text
@a14 1
RCSID("$OpenBSD: readconf.c,v 1.148 2006/02/22 00:04:44 stevesk Exp $");
@


1.148
log
@move #include <ctype.h> out of includes.h; ok djm@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.147 2006/02/20 17:19:54 stevesk Exp $");
d326 2
a327 1
	keyword = strdelim(&s);
@


1.148.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: readconf.c,v 1.159 2006/08/03 03:34:42 deraadt Exp $ */
d14 3
a18 3
#include <sys/socket.h>

#include <netinet/in.h>
a20 6
#include <errno.h>
#include <netdb.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
d22 1
a23 1
#include "ssh.h"
a27 1
#include "key.h"
a30 1
#include "buffer.h"
a101 1
	oExitOnForwardFailure,
a131 1
	{ "exitonforwardfailure", oExitOnForwardFailure },
d326 1
a326 2
	if ((keyword = strdelim(&s)) == NULL)
		return 0;
a382 4
	case oExitOnForwardFailure:
		intptr = &options->exit_on_forward_failure;
		goto parse_flag;

a983 1
	options->exit_on_forward_failure = -1;
a1063 2
	if (options->exit_on_forward_failure == -1)
		options->exit_on_forward_failure = 0;
@


1.147
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.146 2006/02/12 10:44:18 djm Exp $");
d19 2
@


1.146
log
@raise error when the user specifies a RekeyLimit that is smaller than 16
(the smallest of our cipher's blocksize) or big enough to cause integer
wraparound; ok & feedback dtucker@@
@
text
@d15 4
a18 1
RCSID("$OpenBSD: readconf.c,v 1.145 2005/12/08 18:34:11 reyk Exp $");
@


1.145
log
@two changes to the new ssh tunnel support. this breaks compatibility
with the initial commit but is required for a portable approach.
- make the tunnel id u_int and platform friendly, use predefined types.
- support configuration of layer 2 (ethernet) or layer 3
(point-to-point, default) modes. configuration is done using the
Tunnel (yes|point-to-point|ethernet|no) option is ssh_config(5) and
restricted by the PermitTunnel (yes|point-to-point|ethernet|no) option
in sshd_config(5).

ok djm@@, man page bits by jmc@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.144 2005/12/06 22:38:27 reyk Exp $");
d307 2
a308 1
	int opcode, *intptr, value, value2;
d481 1
a481 1
		value = strtol(arg, &endofnumber, 10);
d485 3
d489 1
a489 1
			value *= 1<<10;
d492 1
a492 1
			value *= 1<<20;
d495 1
a495 1
			value *= 1<<30;
d497 3
d501 8
d510 1
a510 1
			*intptr = value;
@


1.144
log
@Add support for tun(4) forwarding over OpenSSH, based on an idea and
initial channel code bits by markus@@. This is a simple and easy way to
use OpenSSH for ad hoc virtual private network connections, e.g.
administrative tunnels or secure wireless access. It's based on a new
ssh channel and works similar to the existing TCP forwarding support,
except that it depends on the tun(4) network interface on both ends of
the connection for layer 2 or layer 3 tunneling. This diff also adds
support for LocalCommand in the ssh(1) client.

ok djm@@, markus@@, jmc@@ (manpages), tested and discussed with others
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.143 2005/07/30 02:03:47 djm Exp $");
d274 1
a274 1
	options->tun_open = 0;
d836 19
a854 1
		goto parse_flag;
d861 1
a861 1
		if (value < -1)
d1151 5
a1155 1
		options->tun_open = 0;
@


1.143
log
@listen_hosts initialisation here too; spotted greg AT y2005.nest.cx
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.142 2005/07/17 07:17:55 djm Exp $");
d73 4
d114 1
d206 4
d274 1
d307 1
a307 1
	int opcode, *intptr, value;
d564 2
a567 1
		charptr = &options->proxy_command;
d834 25
d1003 5
d1132 5
@


1.143.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.145 2005/12/08 18:34:11 reyk Exp $");
a72 4
   Host vpn.fake.com
     Tunnel yes
     TunnelDevice 3

a109 1
	oTunnel, oTunnelDevice, oLocalCommand, oPermitLocalCommand,
a200 4
	{ "tunnel", oTunnel },
	{ "tunneldevice", oTunnelDevice },
	{ "localcommand", oLocalCommand },
	{ "permitlocalcommand", oPermitLocalCommand },
a264 1
	options->tun_open = SSH_TUNMODE_NO;
d297 1
a297 1
	int opcode, *intptr, value, value2;
a553 2
		charptr = &options->proxy_command;
parse_command:
d556 1
a822 43
	case oTunnel:
		intptr = &options->tun_open;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing yes/point-to-point/"
			    "ethernet/no argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcasecmp(arg, "ethernet") == 0)
			value = SSH_TUNMODE_ETHERNET;
		else if (strcasecmp(arg, "point-to-point") == 0)
			value = SSH_TUNMODE_POINTOPOINT;
		else if (strcasecmp(arg, "yes") == 0)
			value = SSH_TUNMODE_DEFAULT;
		else if (strcasecmp(arg, "no") == 0)
			value = SSH_TUNMODE_NO;
		else
			fatal("%s line %d: Bad yes/point-to-point/ethernet/"
			    "no argument: %s", filename, linenum, arg);
		if (*activep)
			*intptr = value;
		break;

	case oTunnelDevice:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		value = a2tun(arg, &value2);
		if (value == SSH_TUNID_ERR)
			fatal("%.200s line %d: Bad tun device.", filename, linenum);
		if (*activep) {
			options->tun_local = value;
			options->tun_remote = value2;
		}
		break;

	case oLocalCommand:
		charptr = &options->local_command;
		goto parse_command;

	case oPermitLocalCommand:
		intptr = &options->permit_local_command;
		goto parse_flag;

a966 5
	options->tun_open = -1;
	options->tun_local = -1;
	options->tun_remote = -1;
	options->local_command = NULL;
	options->permit_local_command = -1;
a1090 9
	if (options->tun_open == -1)
		options->tun_open = SSH_TUNMODE_NO;
	if (options->tun_local == -1)
		options->tun_local = SSH_TUNID_ANY;
	if (options->tun_remote == -1)
		options->tun_remote = SSH_TUNID_ANY;
	if (options->permit_local_command == -1)
		options->permit_local_command = 0;
	/* options->local_command should not be set by default */
@


1.143.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: readconf.c,v 1.159 2006/08/03 03:34:42 deraadt Exp $ */
d14 2
a15 13
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>

#include <netinet/in.h>

#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
d17 1
a18 1
#include "ssh.h"
a22 1
#include "key.h"
a25 1
#include "buffer.h"
a96 1
	oExitOnForwardFailure,
a126 1
	{ "exitonforwardfailure", oExitOnForwardFailure },
d307 1
a307 2
	int opcode, *intptr, value, value2, scale;
	long long orig, val64;
d320 1
a320 2
	if ((keyword = strdelim(&s)) == NULL)
		return 0;
a376 4
	case oExitOnForwardFailure:
		intptr = &options->exit_on_forward_failure;
		goto parse_flag;

d480 1
a480 1
		orig = val64 = strtoll(arg, &endofnumber, 10);
a483 3
		case '\0':
			scale = 1;
			break;
d485 1
a485 1
			scale = 1<<10;
d488 1
a488 1
			scale = 1<<20;
d491 1
a491 1
			scale = 1<<30;
a492 3
		default:
			fatal("%.200s line %d: Invalid RekeyLimit suffix",
			    filename, linenum);
a493 8
		val64 *= scale;
		/* detect integer wrap and too-large limits */
		if ((val64 / scale) != orig || val64 > INT_MAX)
			fatal("%.200s line %d: RekeyLimit too large",
			    filename, linenum);
		if (val64 < 16)
			fatal("%.200s line %d: RekeyLimit too small",
			    filename, linenum);
d495 1
a495 1
			*intptr = (int)val64;
a963 1
	options->exit_on_forward_failure = -1;
a1043 2
	if (options->exit_on_forward_failure == -1)
		options->exit_on_forward_failure = 0;
@


1.142
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.141 2005/06/08 11:25:09 djm Exp $");
d696 1
a696 1
			fwd.listen_host = "";
@


1.141
log
@add ControlMaster=auto/autoask options to support opportunistic multiplexing;
tested avsm@@ and jakob@@, ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.140 2005/05/16 15:30:51 markus Exp $");
d840 1
a840 1
		     filename, linenum, arg);
@


1.140
log
@check return value from strdelim() for NULL (AddressFamily); mpech
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.139 2005/03/10 22:01:05 deraadt Exp $");
d797 21
a817 1
		goto parse_yesnoask;
@


1.139
log
@spacing
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.138 2005/03/10 10:15:02 dtucker Exp $");
d744 3
@


1.139.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.143 2005/07/30 02:03:47 djm Exp $");
d696 1
a696 1
			fwd.listen_host = NULL;
a743 3
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing address family.",
			    filename, linenum);
d794 1
a794 21
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing ControlMaster argument.",
			    filename, linenum);
		value = 0;	/* To avoid compiler warning... */
		if (strcmp(arg, "yes") == 0 || strcmp(arg, "true") == 0)
			value = SSHCTL_MASTER_YES;
		else if (strcmp(arg, "no") == 0 || strcmp(arg, "false") == 0)
			value = SSHCTL_MASTER_NO;
		else if (strcmp(arg, "auto") == 0)
			value = SSHCTL_MASTER_AUTO;
		else if (strcmp(arg, "ask") == 0)
			value = SSHCTL_MASTER_ASK;
		else if (strcmp(arg, "autoask") == 0)
			value = SSHCTL_MASTER_AUTO_ASK;
		else
			fatal("%.200s line %d: Bad ControlMaster argument.",
			    filename, linenum);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;
d817 1
a817 1
		    filename, linenum, arg);
@


1.139.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.145 2005/12/08 18:34:11 reyk Exp $");
a72 4
   Host vpn.fake.com
     Tunnel yes
     TunnelDevice 3

a109 1
	oTunnel, oTunnelDevice, oLocalCommand, oPermitLocalCommand,
a200 4
	{ "tunnel", oTunnel },
	{ "tunneldevice", oTunnelDevice },
	{ "localcommand", oLocalCommand },
	{ "permitlocalcommand", oPermitLocalCommand },
a264 1
	options->tun_open = SSH_TUNMODE_NO;
d297 1
a297 1
	int opcode, *intptr, value, value2;
a553 2
		charptr = &options->proxy_command;
parse_command:
d556 1
a822 43
	case oTunnel:
		intptr = &options->tun_open;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing yes/point-to-point/"
			    "ethernet/no argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcasecmp(arg, "ethernet") == 0)
			value = SSH_TUNMODE_ETHERNET;
		else if (strcasecmp(arg, "point-to-point") == 0)
			value = SSH_TUNMODE_POINTOPOINT;
		else if (strcasecmp(arg, "yes") == 0)
			value = SSH_TUNMODE_DEFAULT;
		else if (strcasecmp(arg, "no") == 0)
			value = SSH_TUNMODE_NO;
		else
			fatal("%s line %d: Bad yes/point-to-point/ethernet/"
			    "no argument: %s", filename, linenum, arg);
		if (*activep)
			*intptr = value;
		break;

	case oTunnelDevice:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		value = a2tun(arg, &value2);
		if (value == SSH_TUNID_ERR)
			fatal("%.200s line %d: Bad tun device.", filename, linenum);
		if (*activep) {
			options->tun_local = value;
			options->tun_remote = value2;
		}
		break;

	case oLocalCommand:
		charptr = &options->local_command;
		goto parse_command;

	case oPermitLocalCommand:
		intptr = &options->permit_local_command;
		goto parse_flag;

a966 5
	options->tun_open = -1;
	options->tun_local = -1;
	options->tun_remote = -1;
	options->local_command = NULL;
	options->permit_local_command = -1;
a1090 9
	if (options->tun_open == -1)
		options->tun_open = SSH_TUNMODE_NO;
	if (options->tun_local == -1)
		options->tun_local = SSH_TUNID_ANY;
	if (options->tun_remote == -1)
		options->tun_remote = SSH_TUNID_ANY;
	if (options->permit_local_command == -1)
		options->permit_local_command = 0;
	/* options->local_command should not be set by default */
@


1.138
log
@Check listen addresses for null, prevents xfree from dying during
ClearAllForwardings (bz #996).  From  Craig Leres, ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.137 2005/03/04 08:48:06 djm Exp $");
d302 1
a302 1
	for(len = strlen(line) - 1; len > 0; len--) {
@


1.137
log
@fix SendEnv config parsing bug found by Roumen Petrov; ok dtucker@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.136 2005/03/01 10:40:26 djm Exp $");
d254 2
a255 1
		xfree(options->local_forwards[i].listen_host);
d260 2
a261 1
		xfree(options->remote_forwards[i].listen_host);
@


1.136
log
@add support for hashing host names and addresses added to known_hosts files,
to improve privacy of which hosts user have been visiting; ok markus@@ deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.135 2005/03/01 10:09:52 djm Exp $");
d776 2
@


1.135
log
@bz#413: allow optional specification of bind address for port forwardings.
Patch originally by Dan Astorian, but worked on by several people
Adds GatewayPorts=clientspecified option on server to allow remote forwards
to bind to client-specified ports.

ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.134 2004/07/11 17:48:47 deraadt Exp $");
d109 1
a109 1
	oSendEnv, oControlPath, oControlMaster,
d200 1
d792 4
d939 1
d1062 2
@


1.134
log
@spaces
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.133 2004/06/17 15:10:14 djm Exp $");
d209 1
a209 2
add_local_forward(Options *options, u_short port, const char *host,
		  u_short host_port)
d213 1
a213 1
	if (port < IPPORT_RESERVED && original_real_uid != 0)
d218 6
a223 3
	fwd->port = port;
	fwd->host = xstrdup(host);
	fwd->host_port = host_port;
d232 1
a232 2
add_remote_forward(Options *options, u_short port, const char *host,
		   u_short host_port)
d239 6
a244 3
	fwd->port = port;
	fwd->host = xstrdup(host);
	fwd->host_port = host_port;
d252 4
a255 2
	for (i = 0; i < options->num_local_forwards; i++)
		xfree(options->local_forwards[i].host);
d257 4
a260 2
	for (i = 0; i < options->num_remote_forwards; i++)
		xfree(options->remote_forwards[i].host);
d293 1
a293 1
	char buf[256], *s, **charptr, *endofnumber, *keyword, *arg;
d296 1
a296 2
	u_short fwd_port, fwd_host_port;
	char sfwd_host_port[6];
d653 1
a653 1
		if (!arg || *arg == '\0')
d656 3
a658 2
		if ((fwd_port = a2port(arg)) == 0)
			fatal("%.200s line %d: Bad listen port.",
d660 5
a664 6
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing second argument.",
			    filename, linenum);
		if (sscanf(arg, "%255[^:]:%5[0-9]", buf, sfwd_host_port) != 2 &&
		    sscanf(arg, "%255[^/]/%5[0-9]", buf, sfwd_host_port) != 2)
d667 1
a667 3
		if ((fwd_host_port = a2port(sfwd_host_port)) == 0)
			fatal("%.200s line %d: Bad forwarding port.",
			    filename, linenum);
d670 1
a670 2
				add_local_forward(options, fwd_port, buf,
				    fwd_host_port);
d672 1
a672 2
				add_remote_forward(options, fwd_port, buf,
				    fwd_host_port);
d681 15
a695 2
		fwd_port = a2port(arg);
		if (fwd_port == 0)
d699 1
a699 1
			add_local_forward(options, fwd_port, "socks", 0);
d1061 65
@


1.134.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.138 2005/03/10 10:15:02 dtucker Exp $");
d109 1
a109 1
	oSendEnv, oControlPath, oControlMaster, oHashKnownHosts,
a199 1
	{ "hashknownhosts", oHashKnownHosts },
d209 2
a210 1
add_local_forward(Options *options, const Forward *newfwd)
d214 1
a214 1
	if (newfwd->listen_port < IPPORT_RESERVED && original_real_uid != 0)
d219 3
a221 6

	fwd->listen_host = (newfwd->listen_host == NULL) ?
	    NULL : xstrdup(newfwd->listen_host);
	fwd->listen_port = newfwd->listen_port;
	fwd->connect_host = xstrdup(newfwd->connect_host);
	fwd->connect_port = newfwd->connect_port;
d230 2
a231 1
add_remote_forward(Options *options, const Forward *newfwd)
d238 3
a240 6

	fwd->listen_host = (newfwd->listen_host == NULL) ?
	    NULL : xstrdup(newfwd->listen_host);
	fwd->listen_port = newfwd->listen_port;
	fwd->connect_host = xstrdup(newfwd->connect_host);
	fwd->connect_port = newfwd->connect_port;
d248 2
a249 5
	for (i = 0; i < options->num_local_forwards; i++) {
		if (options->local_forwards[i].listen_host != NULL)
			xfree(options->local_forwards[i].listen_host);
		xfree(options->local_forwards[i].connect_host);
	}
d251 2
a252 5
	for (i = 0; i < options->num_remote_forwards; i++) {
		if (options->remote_forwards[i].listen_host != NULL)
			xfree(options->remote_forwards[i].listen_host);
		xfree(options->remote_forwards[i].connect_host);
	}
d285 1
a285 1
	char *s, **charptr, *endofnumber, *keyword, *arg, *arg2, fwdarg[256];
d288 2
a289 1
	Forward fwd;
d646 1
a646 1
		if (arg == NULL || *arg == '\0')
d649 2
a650 3
		arg2 = strdelim(&s);
		if (arg2 == NULL || *arg2 == '\0')
			fatal("%.200s line %d: Missing target argument.",
d652 6
a657 5

		/* construct a string for parse_forward */
		snprintf(fwdarg, sizeof(fwdarg), "%s:%s", arg, arg2);

		if (parse_forward(&fwd, fwdarg) == 0)
d660 3
a662 1

d665 2
a666 1
				add_local_forward(options, &fwd);
d668 2
a669 1
				add_remote_forward(options, &fwd);
d678 2
a679 15
		memset(&fwd, '\0', sizeof(fwd));
		fwd.connect_host = "socks";
		fwd.listen_host = hpdelim(&arg);
		if (fwd.listen_host == NULL ||
		    strlen(fwd.listen_host) >= NI_MAXHOST)
			fatal("%.200s line %d: Bad forwarding specification.",
			    filename, linenum);
		if (arg) {
			fwd.listen_port = a2port(arg);
			fwd.listen_host = cleanhostname(fwd.listen_host);
		} else {
			fwd.listen_port = a2port(fwd.listen_host);
			fwd.listen_host = "";
		}
		if (fwd.listen_port == 0)
d683 1
a683 1
			add_local_forward(options, &fwd);
a758 2
			if (!*activep)
				continue;
a774 4
	case oHashKnownHosts:
		intptr = &options->hash_known_hosts;
		goto parse_flag;

a917 1
	options->hash_known_hosts = -1;
a1039 2
	if (options->hash_known_hosts == -1)
		options->hash_known_hosts = 0;
a1044 65
}

/*
 * parse_forward
 * parses a string containing a port forwarding specification of the form:
 *	[listenhost:]listenport:connecthost:connectport
 * returns number of arguments parsed or zero on error
 */
int
parse_forward(Forward *fwd, const char *fwdspec)
{
	int i;
	char *p, *cp, *fwdarg[4];

	memset(fwd, '\0', sizeof(*fwd));

	cp = p = xstrdup(fwdspec);

	/* skip leading spaces */
	while (*cp && isspace(*cp))
		cp++;

	for (i = 0; i < 4; ++i)
		if ((fwdarg[i] = hpdelim(&cp)) == NULL)
			break;

	/* Check for trailing garbage in 4-arg case*/
	if (cp != NULL)
		i = 0;	/* failure */

	switch (i) {
	case 3:
		fwd->listen_host = NULL;
		fwd->listen_port = a2port(fwdarg[0]);
		fwd->connect_host = xstrdup(cleanhostname(fwdarg[1]));
		fwd->connect_port = a2port(fwdarg[2]);
		break;

	case 4:
		fwd->listen_host = xstrdup(cleanhostname(fwdarg[0]));
		fwd->listen_port = a2port(fwdarg[1]);
		fwd->connect_host = xstrdup(cleanhostname(fwdarg[2]));
		fwd->connect_port = a2port(fwdarg[3]);
		break;
	default:
		i = 0; /* failure */
	}

	xfree(p);

	if (fwd->listen_port == 0 && fwd->connect_port == 0)
		goto fail_free;

	if (fwd->connect_host != NULL &&
	    strlen(fwd->connect_host) >= NI_MAXHOST)
		goto fail_free;

	return (i);

 fail_free:
	if (fwd->connect_host != NULL)
		xfree(fwd->connect_host);
	if (fwd->listen_host != NULL)
		xfree(fwd->listen_host);
	return (0);
@


1.134.2.2
log
@upgrade to OpenSSH 4.1
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.139 2005/03/10 22:01:05 deraadt Exp $");
d302 1
a302 1
	for (len = strlen(line) - 1; len > 0; len--) {
@


1.134.2.3
log
@upgrade to OpenSSH 4.2
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.143 2005/07/30 02:03:47 djm Exp $");
d696 1
a696 1
			fwd.listen_host = NULL;
a743 3
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing address family.",
			    filename, linenum);
d794 1
a794 21
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing ControlMaster argument.",
			    filename, linenum);
		value = 0;	/* To avoid compiler warning... */
		if (strcmp(arg, "yes") == 0 || strcmp(arg, "true") == 0)
			value = SSHCTL_MASTER_YES;
		else if (strcmp(arg, "no") == 0 || strcmp(arg, "false") == 0)
			value = SSHCTL_MASTER_NO;
		else if (strcmp(arg, "auto") == 0)
			value = SSHCTL_MASTER_AUTO;
		else if (strcmp(arg, "ask") == 0)
			value = SSHCTL_MASTER_ASK;
		else if (strcmp(arg, "autoask") == 0)
			value = SSHCTL_MASTER_AUTO_ASK;
		else
			fatal("%.200s line %d: Bad ControlMaster argument.",
			    filename, linenum);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;
d817 1
a817 1
		    filename, linenum, arg);
@


1.133
log
@Add option for confirmation (ControlMaster=ask) via ssh-askpass before opening
shared connections; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.132 2004/06/13 15:03:02 djm Exp $");
d805 1
a805 1
read_config_file(const char *filename, const char *host, Options *options, 
d819 1
a819 1
		
@


1.132
log
@implement session multiplexing in the client (the server has supported this
since 2.0); ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.131 2004/05/27 00:50:13 dtucker Exp $");
d773 1
a773 1
		goto parse_flag;
@


1.131
log
@Kill dead code after fatal(); ok djm@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.130 2004/04/27 09:46:36 djm Exp $");
d109 1
a109 1
	oSendEnv,
d198 2
d767 8
d916 2
d1038 2
@


1.130
log
@bz #815: implement ability to pass specified environment variables from the
client to the server; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.129 2004/04/18 23:10:26 djm Exp $");
d810 1
a810 1
		if (fstat(fileno(f), &sb) == -1) {
a811 3
			fclose(f);
			return (0);
		}
d813 1
a813 1
		    (sb.st_mode & 022) != 0)) {
a814 2
			return 0;
		}
@


1.129
log
@perform strict ownership and modes checks for ~/.ssh/config files, as these
can be used to execute arbitrary programs; ok markus@@

NB. ssh will now exit when it detects a config with poor permissions
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.128 2004/03/05 10:53:58 markus Exp $");
d109 1
d197 1
d752 13
d910 1
@


1.128
log
@add IdentitiesOnly; ok djm@@, pb@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.127 2003/12/16 15:49:51 markus Exp $");
d780 2
a781 1
read_config_file(const char *filename, const char *host, Options *options)
d789 1
a789 2
	f = fopen(filename, "r");
	if (!f)
d791 15
@


1.128.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.134 2004/07/11 17:48:47 deraadt Exp $");
a108 1
	oSendEnv, oControlPath, oControlMaster,
a195 3
	{ "sendenv", oSendEnv },
	{ "controlpath", oControlPath },
	{ "controlmaster", oControlMaster },
a749 21
	case oSendEnv:
		while ((arg = strdelim(&s)) != NULL && *arg != '\0') {
			if (strchr(arg, '=') != NULL)
				fatal("%s line %d: Invalid environment name.",
				    filename, linenum);
			if (options->num_send_env >= MAX_SEND_ENV)
				fatal("%s line %d: too many send env.",
				    filename, linenum);
			options->send_env[options->num_send_env++] =
			    xstrdup(arg);
		}
		break;

	case oControlPath:
		charptr = &options->control_path;
		goto parse_string;

	case oControlMaster:
		intptr = &options->control_master;
		goto parse_yesnoask;

d780 1
a780 2
read_config_file(const char *filename, const char *host, Options *options,
    int checkperm)
d788 2
a789 1
	if ((f = fopen(filename, "r")) == NULL)
a791 10
	if (checkperm) {
		struct stat sb;

		if (fstat(fileno(f), &sb) == -1)
			fatal("fstat %s: %s", filename, strerror(errno));
		if (((sb.st_uid != 0 && sb.st_uid != getuid()) ||
		    (sb.st_mode & 022) != 0))
			fatal("Bad owner or permissions on %s", filename);
	}

a879 3
	options->num_send_env = 0;
	options->control_path = NULL;
	options->control_master = -1;
a999 2
	if (options->control_master == -1)
		options->control_master = 0;
@


1.128.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.138 2005/03/10 10:15:02 dtucker Exp $");
d109 1
a109 1
	oSendEnv, oControlPath, oControlMaster, oHashKnownHosts,
a199 1
	{ "hashknownhosts", oHashKnownHosts },
d209 2
a210 1
add_local_forward(Options *options, const Forward *newfwd)
d214 1
a214 1
	if (newfwd->listen_port < IPPORT_RESERVED && original_real_uid != 0)
d219 3
a221 6

	fwd->listen_host = (newfwd->listen_host == NULL) ?
	    NULL : xstrdup(newfwd->listen_host);
	fwd->listen_port = newfwd->listen_port;
	fwd->connect_host = xstrdup(newfwd->connect_host);
	fwd->connect_port = newfwd->connect_port;
d230 2
a231 1
add_remote_forward(Options *options, const Forward *newfwd)
d238 3
a240 6

	fwd->listen_host = (newfwd->listen_host == NULL) ?
	    NULL : xstrdup(newfwd->listen_host);
	fwd->listen_port = newfwd->listen_port;
	fwd->connect_host = xstrdup(newfwd->connect_host);
	fwd->connect_port = newfwd->connect_port;
d248 2
a249 5
	for (i = 0; i < options->num_local_forwards; i++) {
		if (options->local_forwards[i].listen_host != NULL)
			xfree(options->local_forwards[i].listen_host);
		xfree(options->local_forwards[i].connect_host);
	}
d251 2
a252 5
	for (i = 0; i < options->num_remote_forwards; i++) {
		if (options->remote_forwards[i].listen_host != NULL)
			xfree(options->remote_forwards[i].listen_host);
		xfree(options->remote_forwards[i].connect_host);
	}
d285 1
a285 1
	char *s, **charptr, *endofnumber, *keyword, *arg, *arg2, fwdarg[256];
d288 2
a289 1
	Forward fwd;
d646 1
a646 1
		if (arg == NULL || *arg == '\0')
d649 2
a650 3
		arg2 = strdelim(&s);
		if (arg2 == NULL || *arg2 == '\0')
			fatal("%.200s line %d: Missing target argument.",
d652 6
a657 5

		/* construct a string for parse_forward */
		snprintf(fwdarg, sizeof(fwdarg), "%s:%s", arg, arg2);

		if (parse_forward(&fwd, fwdarg) == 0)
d660 3
a662 1

d665 2
a666 1
				add_local_forward(options, &fwd);
d668 2
a669 1
				add_remote_forward(options, &fwd);
d678 2
a679 15
		memset(&fwd, '\0', sizeof(fwd));
		fwd.connect_host = "socks";
		fwd.listen_host = hpdelim(&arg);
		if (fwd.listen_host == NULL ||
		    strlen(fwd.listen_host) >= NI_MAXHOST)
			fatal("%.200s line %d: Bad forwarding specification.",
			    filename, linenum);
		if (arg) {
			fwd.listen_port = a2port(arg);
			fwd.listen_host = cleanhostname(fwd.listen_host);
		} else {
			fwd.listen_port = a2port(fwd.listen_host);
			fwd.listen_host = "";
		}
		if (fwd.listen_port == 0)
d683 1
a683 1
			add_local_forward(options, &fwd);
a758 2
			if (!*activep)
				continue;
a774 4
	case oHashKnownHosts:
		intptr = &options->hash_known_hosts;
		goto parse_flag;

a917 1
	options->hash_known_hosts = -1;
a1039 2
	if (options->hash_known_hosts == -1)
		options->hash_known_hosts = 0;
a1044 65
}

/*
 * parse_forward
 * parses a string containing a port forwarding specification of the form:
 *	[listenhost:]listenport:connecthost:connectport
 * returns number of arguments parsed or zero on error
 */
int
parse_forward(Forward *fwd, const char *fwdspec)
{
	int i;
	char *p, *cp, *fwdarg[4];

	memset(fwd, '\0', sizeof(*fwd));

	cp = p = xstrdup(fwdspec);

	/* skip leading spaces */
	while (*cp && isspace(*cp))
		cp++;

	for (i = 0; i < 4; ++i)
		if ((fwdarg[i] = hpdelim(&cp)) == NULL)
			break;

	/* Check for trailing garbage in 4-arg case*/
	if (cp != NULL)
		i = 0;	/* failure */

	switch (i) {
	case 3:
		fwd->listen_host = NULL;
		fwd->listen_port = a2port(fwdarg[0]);
		fwd->connect_host = xstrdup(cleanhostname(fwdarg[1]));
		fwd->connect_port = a2port(fwdarg[2]);
		break;

	case 4:
		fwd->listen_host = xstrdup(cleanhostname(fwdarg[0]));
		fwd->listen_port = a2port(fwdarg[1]);
		fwd->connect_host = xstrdup(cleanhostname(fwdarg[2]));
		fwd->connect_port = a2port(fwdarg[3]);
		break;
	default:
		i = 0; /* failure */
	}

	xfree(p);

	if (fwd->listen_port == 0 && fwd->connect_port == 0)
		goto fail_free;

	if (fwd->connect_host != NULL &&
	    strlen(fwd->connect_host) >= NI_MAXHOST)
		goto fail_free;

	return (i);

 fail_free:
	if (fwd->connect_host != NULL)
		xfree(fwd->connect_host);
	if (fwd->listen_host != NULL)
		xfree(fwd->listen_host);
	return (0);
@


1.127
log
@application layer keep alive (ServerAliveInterval ServerAliveCountMax)
for ssh(1), similar to the sshd(8) option; ok beck@@; with help from
jmc and dtucker@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.126 2003/12/09 21:53:36 markus Exp $");
d108 1
a108 1
	oServerAliveInterval, oServerAliveCountMax,
d150 1
d738 4
d875 1
d988 2
@


1.126
log
@rename keepalive to tcpkeepalive; the old name causes too much
confusion; ok djm, dtucker; with help from jmc@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.125 2003/11/12 16:39:58 jakob Exp $");
d108 1
d193 2
d311 1
a311 1
/* parse_time: */
d737 8
d872 2
d988 4
@


1.125
log
@update SSHFP validation. ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.124 2003/10/14 19:42:10 jakob Exp $");
d81 1
a81 1
     KeepAlives no
d99 1
a99 1
	oCompressionLevel, oKeepAlives, oNumberOfPasswordPrompts,
d172 2
a173 1
	{ "keepalive", oKeepAlives },
d429 2
a430 2
	case oKeepAlives:
		intptr = &options->keepalives;
d828 1
a828 1
	options->keepalives = -1;
d911 2
a912 2
	if (options->keepalives == -1)
		options->keepalives = 1;
@


1.124
log
@include SSHFP lookup code (not enabled by default). ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.123 2003/10/11 08:24:07 markus Exp $");
d402 1
a402 1
		goto parse_flag;
d406 1
@


1.123
log
@remote x11 clients are now untrusted by default, uses xauth(8) to generate
untrusted cookies; ForwardX11Trusted=yes restores old behaviour.
ok deraadt; feedback and ok djm/fries
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.122 2003/10/08 15:21:24 markus Exp $");
a185 1
#ifdef DNS
a186 3
#else
	{ "verifyhostkeydns", oUnsupported },
#endif
@


1.122
log
@default GSS API to no in client, too; ok jakob, deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.121 2003/09/01 18:15:50 markus Exp $");
d92 1
a92 1
	oForwardAgent, oForwardX11, oGatewayPorts,
d119 1
d344 4
d812 1
d879 2
@


1.121
log
@remove unused kerberos code; ok henning@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.120 2003/09/01 12:50:46 markus Exp $");
d886 1
a886 1
		options->gss_authentication = 1;
@


1.121.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.127 2003/12/16 15:49:51 markus Exp $");
d81 1
a81 1
     TcpKeepAlive no
d92 1
a92 1
	oForwardAgent, oForwardX11, oForwardX11Trusted, oGatewayPorts,
d99 1
a99 1
	oCompressionLevel, oTCPKeepAlive, oNumberOfPasswordPrompts,
a107 1
	oServerAliveInterval, oServerAliveCountMax,
a118 1
	{ "forwardx11trusted", oForwardX11Trusted },
d171 1
a171 2
	{ "tcpkeepalive", oTCPKeepAlive },
	{ "keepalive", oTCPKeepAlive },				/* obsolete */
d185 1
d187 3
a193 2
	{ "serveraliveinterval", oServerAliveInterval },
	{ "serveralivecountmax", oServerAliveCountMax },
d310 1
a310 1
parse_time:
a342 4
	case oForwardX11Trusted:
		intptr = &options->forward_x11_trusted;
		goto parse_flag;

d401 1
a401 1
		goto parse_yesnoask;
a404 1
parse_yesnoask:
d426 2
a427 2
	case oTCPKeepAlive:
		intptr = &options->tcp_keep_alive;
a730 8
	case oServerAliveInterval:
		intptr = &options->server_alive_interval;
		goto parse_time;

	case oServerAliveCountMax:
		intptr = &options->server_alive_count_max;
		goto parse_int;

a806 1
	options->forward_x11_trusted = -1;
d824 1
a824 1
	options->tcp_keep_alive = -1;
a856 2
	options->server_alive_interval = -1;
	options->server_alive_count_max = -1;
a872 2
	if (options->forward_x11_trusted == -1)
		options->forward_x11_trusted = 0;
d886 1
a886 1
		options->gss_authentication = 0;
d905 2
a906 2
	if (options->tcp_keep_alive == -1)
		options->tcp_keep_alive = 1;
a968 4
	if (options->server_alive_interval == -1)
		options->server_alive_interval = 0;
	if (options->server_alive_count_max == -1)
		options->server_alive_count_max = 3;
@


1.121.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.134 2004/07/11 17:48:47 deraadt Exp $");
d108 1
a108 2
	oServerAliveInterval, oServerAliveCountMax, oIdentitiesOnly,
	oSendEnv, oControlPath, oControlMaster,
a149 1
	{ "identitiesonly", oIdentitiesOnly },
a194 3
	{ "sendenv", oSendEnv },
	{ "controlpath", oControlPath },
	{ "controlmaster", oControlMaster },
a736 4
	case oIdentitiesOnly:
		intptr = &options->identities_only;
		goto parse_flag;

a744 21
	case oSendEnv:
		while ((arg = strdelim(&s)) != NULL && *arg != '\0') {
			if (strchr(arg, '=') != NULL)
				fatal("%s line %d: Invalid environment name.",
				    filename, linenum);
			if (options->num_send_env >= MAX_SEND_ENV)
				fatal("%s line %d: too many send env.",
				    filename, linenum);
			options->send_env[options->num_send_env++] =
			    xstrdup(arg);
		}
		break;

	case oControlPath:
		charptr = &options->control_path;
		goto parse_string;

	case oControlMaster:
		intptr = &options->control_master;
		goto parse_yesnoask;

d775 1
a775 2
read_config_file(const char *filename, const char *host, Options *options,
    int checkperm)
d783 2
a784 1
	if ((f = fopen(filename, "r")) == NULL)
a786 10
	if (checkperm) {
		struct stat sb;

		if (fstat(fileno(f), &sb) == -1)
			fatal("fstat %s: %s", filename, strerror(errno));
		if (((sb.st_uid != 0 && sb.st_uid != getuid()) ||
		    (sb.st_mode & 022) != 0))
			fatal("Bad owner or permissions on %s", filename);
	}

a869 1
	options->identities_only = - 1;
a873 3
	options->num_send_env = 0;
	options->control_path = NULL;
	options->control_master = -1;
a981 2
	if (options->identities_only == -1)
		options->identities_only = 0;
a991 2
	if (options->control_master == -1)
		options->control_master = 0;
@


1.120
log
@rm gssapidelegatecreds alias; never supported before
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.119 2003/08/28 12:54:34 markus Exp $");
a94 1
	oKerberosAuthentication, oKerberosTgtPassing,
a382 8
	case oKerberosAuthentication:
		intptr = &options->kerberos_authentication;
		goto parse_flag;

	case oKerberosTgtPassing:
		intptr = &options->kerberos_tgt_passing;
		goto parse_flag;

a812 2
	options->kerberos_authentication = -1;
	options->kerberos_tgt_passing = -1;
a884 4
	if (options->kerberos_authentication == -1)
		options->kerberos_authentication = 1;
	if (options->kerberos_tgt_passing == -1)
		options->kerberos_tgt_passing = 1;
@


1.119
log
@remove kerberos support from ssh1, since it has been replaced with GSSAPI;
but keep kerberos passwd auth for ssh1 and 2; ok djm, hin, henning, ...
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.118 2003/08/22 10:56:09 markus Exp $");
a139 1
	{ "gssapidelegatecreds", oGssDelegateCreds },
@


1.118
log
@support GSS API user authentication; patches from Simon Wilkinson,
stripped down and tested by Jakob and myself.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.117 2003/08/13 09:07:09 markus Exp $");
a134 4
#ifdef KRB5
	{ "kerberosauthentication", oKerberosAuthentication },
	{ "kerberostgtpassing", oKerberosTgtPassing },
#else
a136 1
#endif
@


1.117
log
@socks4->socks, since with support both 4 and 5; dtucker@@zip.com.au
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.116 2003/08/13 08:46:30 markus Exp $");
d108 1
a108 1
	oAddressFamily,
d143 8
d398 8
d830 2
d906 4
@


1.116
log
@remove RhostsAuthentication; suggested by djm@@ before; ok djm@@, deraadt@@,
fgsch@@, miod@@, henning@@, jakob@@ and others
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.115 2003/07/22 13:35:22 markus Exp $");
d671 1
a671 1
			add_local_forward(options, fwd_port, "socks4", 0);
@


1.115
log
@remove (already disabled) KRB4/AFS support, re-enable -k in ssh(1);
test+ok henning@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.114 2003/07/03 08:09:05 djm Exp $");
a59 1
     RhostsAuthentication no
a76 1
     RhostsAuthentication yes
d92 1
a92 1
	oForwardAgent, oForwardX11, oGatewayPorts, oRhostsAuthentication,
d123 1
a123 1
	{ "rhostsauthentication", oRhostsAuthentication },
a349 4
	case oRhostsAuthentication:
		intptr = &options->rhosts_authentication;
		goto parse_flag;

a808 1
	options->rhosts_authentication = -1;
a877 2
	if (options->rhosts_authentication == -1)
		options->rhosts_authentication = 0;
@


1.114
log
@fix AddressFamily option in config file, from brent@@graveland.net; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.113 2003/06/26 20:08:33 markus Exp $");
d97 1
a97 1
	oKerberosAuthentication, oKerberosTgtPassing, oAFSTokenPassing,
d137 1
a137 1
#if defined(KRB4) || defined(KRB5)
a143 3
#if defined(AFS)
	{ "afstokenpassing", oAFSTokenPassing },
#else
a144 1
#endif
a395 4
	case oAFSTokenPassing:
		intptr = &options->afs_token_passing;
		goto parse_flag;

a820 1
	options->afs_token_passing = -1;
a896 2
	if (options->afs_token_passing == -1)
		options->afs_token_passing = 1;
@


1.113
log
@do not dump core for 'ssh -o proxycommand host'; ok deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.112 2003/05/16 03:27:12 djm Exp $");
a288 1
	extern int IPv4or6;
d727 1
d729 1
a729 1
			IPv4or6 = AF_INET;
d731 1
a731 1
			IPv4or6 = AF_INET6;
d733 1
a733 1
			IPv4or6 = AF_UNSPEC;
d736 2
d842 1
d930 2
@


1.112
log
@add AddressFamily option to ssh_config (like -4, -6 on commandline).
Portable bug #534; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.111 2003/05/15 14:55:25 djm Exp $");
d547 2
@


1.111
log
@add a ConnectTimeout option to ssh, based on patch from
Jean-Charles Longuet (jclonguet at free.fr); portable #207 ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.110 2003/05/15 14:02:47 jakob Exp $");
d110 1
d198 1
d289 1
d722 12
@


1.110
log
@warn for unsupported config option. ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.109 2003/05/15 04:08:44 jakob Exp $");
d109 1
a109 1
	oEnableSSHKeysign, oRekeyLimit, oVerifyHostKeyDNS,
d196 1
d311 14
d824 1
@


1.109
log
@disable kerberos when not supported. ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.108 2003/05/15 01:48:10 jakob Exp $");
d110 1
a110 1
	oDeprecated
d136 1
d139 5
d145 3
d182 1
d184 3
d189 1
d191 3
d715 5
a866 1
#if defined(KRB4) || defined(KRB5)
a867 3
#else
		options->kerberos_authentication = 0;
#endif
a868 1
#if defined(KRB4) || defined(KRB5)
a869 3
#else
		options->kerberos_tgt_passing = 0;
#endif
a870 1
#if defined(AFS)
a871 3
#else
		options->afs_token_passing = 0;
#endif
@


1.108
log
@always parse kerberos options. ok djm@@ markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.107 2003/05/14 18:16:20 jakob Exp $");
d845 1
d847 3
d851 1
d853 3
d857 1
d859 3
@


1.107
log
@add experimental support for verifying hos keys using DNS as described
in draft-ietf-secsh-dns-xx.txt. more information in README.dns.
ok markus@@ and henning@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.106 2003/04/09 12:00:37 djm Exp $");
d97 1
a97 9
#if defined(KRB4) || defined(KRB5)
	oKerberosAuthentication,
#endif
#if defined(AFS) || defined(KRB5)
	oKerberosTgtPassing,
#endif
#ifdef AFS
	oAFSTokenPassing,
#endif
a135 1
#if defined(KRB4) || defined(KRB5)
a136 2
#endif
#if defined(AFS) || defined(KRB5)
a137 2
#endif
#ifdef AFS
a138 1
#endif
d357 1
a357 1
#if defined(KRB4) || defined(KRB5)
d361 1
a361 2
#endif
#if defined(AFS) || defined(KRB5)
d365 1
a365 2
#endif
#ifdef AFS
d369 1
a369 1
#endif
a770 1
#if defined(KRB4) || defined(KRB5)
a771 2
#endif
#if defined(AFS) || defined(KRB5)
a772 2
#endif
#ifdef AFS
a773 1
#endif
a843 1
#if defined(KRB4) || defined(KRB5)
a845 2
#endif
#if defined(AFS) || defined(KRB5)
a847 2
#endif
#ifdef AFS
a849 1
#endif
@


1.106
log
@strip trailing whitespace from config lines before parsing. Fixes bz 528;
ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.105 2003/04/02 09:48:07 markus Exp $");
d117 1
a117 1
	oEnableSSHKeysign, oRekeyLimit,
d190 1
d394 4
d835 1
d954 2
@


1.105
log
@reapply rekeying chage, tested by henning@@, ok djm@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.104 2003/04/01 10:22:21 markus Exp $");
d282 7
@


1.104
log
@backout rekeying changes (for 3.6.1)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.103 2003/04/01 10:10:23 markus Exp $");
d117 1
a117 1
	oEnableSSHKeysign,
d191 1
d425 25
d822 1
d939 2
@


1.103
log
@rekeying bugfixes and automatic rekeying:

* both client and server rekey _automatically_
      (a) after 2^31 packets, because after 2^32 packets
          the sequence number for packets wraps
      (b) after 2^(blocksize_in_bits/4) blocks
  (see: http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-00.txt)
  (a) and (b) are _enabled_ by default, and only disabled for known
  openssh versions, that don't support rekeying properly.
* client option 'RekeyLimit'
* do not reply to requests during rekeying
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.102 2003/02/05 09:02:28 markus Exp $");
d117 1
a117 1
	oEnableSSHKeysign, oRekeyLimit,
a190 1
	{ "rekeylimit", oRekeyLimit },
a423 25
	case oRekeyLimit:
		intptr = &options->rekey_limit;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (arg[0] < '0' || arg[0] > '9')
			fatal("%.200s line %d: Bad number.", filename, linenum);
		value = strtol(arg, &endofnumber, 10);
		if (arg == endofnumber)
			fatal("%.200s line %d: Bad number.", filename, linenum);
		switch (toupper(*endofnumber)) {
		case 'K':
			value *= 1<<10;
			break;
		case 'M':
			value *= 1<<20;
			break;
		case 'G':
			value *= 1<<30;
			break;
		}
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

a795 1
	options->rekey_limit = - 1;
a911 2
	if (options->rekey_limit == -1)
		options->rekey_limit = 0;
@


1.102
log
@simplify ProxyCommand parsing, remove strcat/xrealloc; ok henning@@, djm@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.101 2002/11/07 22:08:07 markus Exp $");
d117 1
a117 1
	oEnableSSHKeysign,
d191 1
d425 25
d822 1
d939 2
@


1.102.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.121 2003/09/01 18:15:50 markus Exp $");
d60 1
d78 1
d94 1
a94 1
	oForwardAgent, oForwardX11, oGatewayPorts,
d97 9
d117 2
a118 3
	oEnableSSHKeysign, oRekeyLimit, oVerifyHostKeyDNS, oConnectTimeout,
	oAddressFamily, oGssAuthentication, oGssDelegateCreds,
	oDeprecated, oUnsupported
d132 1
a132 1
	{ "rhostsauthentication", oDeprecated },
d144 8
a151 9
	{ "kerberosauthentication", oUnsupported },
	{ "kerberostgtpassing", oUnsupported },
	{ "afstokenpassing", oUnsupported },
#if defined(GSSAPI)
	{ "gssapiauthentication", oGssAuthentication },
	{ "gssapidelegatecredentials", oGssDelegateCreds },
#else
	{ "gssapiauthentication", oUnsupported },
	{ "gssapidelegatecredentials", oUnsupported },
a186 1
#ifdef SMARTCARD
a187 3
#else
	{ "smartcarddevice", oUnsupported },
#endif
a189 5
#ifdef DNS
	{ "verifyhostkeydns", oVerifyHostKeyDNS },
#else
	{ "verifyhostkeydns", oUnsupported },
#endif
a190 3
	{ "rekeylimit", oRekeyLimit },
	{ "connecttimeout", oConnectTimeout },
	{ "addressfamily", oAddressFamily },
a281 7
	/* Strip trailing whitespace */
	for(len = strlen(line) - 1; len > 0; len--) {
		if (strchr(WHITESPACE, line[len]) == NULL)
			break;
		line[len] = '\0';
	}

a297 14
	case oConnectTimeout:
		intptr = &options->connection_timeout;
/* parse_time: */
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing time value.",
			    filename, linenum);
		if ((value = convtime(arg)) == -1)
			fatal("%s line %d: invalid time value.",
			    filename, linenum);
		if (*intptr == -1)
			*intptr = value;
		break;

d327 4
d362 8
a369 3

	case oGssAuthentication:
		intptr = &options->gss_authentication;
d371 4
a374 3

	case oGssDelegateCreds:
		intptr = &options->gss_deleg_creds;
d376 1
a376 1

a384 4
	case oVerifyHostKeyDNS:
		intptr = &options->verify_host_key_dns;
		goto parse_flag;

a423 25
	case oRekeyLimit:
		intptr = &options->rekey_limit;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (arg[0] < '0' || arg[0] > '9')
			fatal("%.200s line %d: Bad number.", filename, linenum);
		value = strtol(arg, &endofnumber, 10);
		if (arg == endofnumber)
			fatal("%.200s line %d: Bad number.", filename, linenum);
		switch (toupper(*endofnumber)) {
		case 'K':
			value *= 1<<10;
			break;
		case 'M':
			value *= 1<<20;
			break;
		case 'G':
			value *= 1<<30;
			break;
		}
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

a489 2
		if (s == NULL)
			fatal("%.200s line %d: Missing argument.", filename, linenum);
d627 1
a627 1
			add_local_forward(options, fwd_port, "socks", 0);
a666 15
	case oAddressFamily:
		arg = strdelim(&s);
		intptr = &options->address_family;
		if (strcasecmp(arg, "inet") == 0)
			value = AF_INET;
		else if (strcasecmp(arg, "inet6") == 0)
			value = AF_INET6;
		else if (strcasecmp(arg, "any") == 0)
			value = AF_UNSPEC;
		else
			fatal("Unsupported AddressFamily \"%s\"", arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

a675 5
	case oUnsupported:
		error("%s line %d: Unsupported option \"%s\"",
		    filename, linenum, keyword);
		return 0;

d745 1
d749 9
a757 2
	options->gss_authentication = -1;
	options->gss_deleg_creds = -1;
a769 1
	options->address_family = -1;
a770 1
	options->connection_timeout = -1;
a795 2
	options->rekey_limit = - 1;
	options->verify_host_key_dns = -1;
d818 2
d826 12
a837 4
	if (options->gss_authentication == -1)
		options->gss_authentication = 1;
	if (options->gss_deleg_creds == -1)
		options->gss_deleg_creds = 0;
a859 2
	if (options->address_family == -1)
		options->address_family = AF_UNSPEC;
a911 4
	if (options->rekey_limit == -1)
		options->rekey_limit = 0;
	if (options->verify_host_key_dns == -1)
		options->verify_host_key_dns = 0;
@


1.102.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.127 2003/12/16 15:49:51 markus Exp $");
d81 1
a81 1
     TcpKeepAlive no
d92 1
a92 1
	oForwardAgent, oForwardX11, oForwardX11Trusted, oGatewayPorts,
d99 1
a99 1
	oCompressionLevel, oTCPKeepAlive, oNumberOfPasswordPrompts,
a107 1
	oServerAliveInterval, oServerAliveCountMax,
a118 1
	{ "forwardx11trusted", oForwardX11Trusted },
d171 1
a171 2
	{ "tcpkeepalive", oTCPKeepAlive },
	{ "keepalive", oTCPKeepAlive },				/* obsolete */
d185 1
d187 3
a193 2
	{ "serveraliveinterval", oServerAliveInterval },
	{ "serveralivecountmax", oServerAliveCountMax },
d310 1
a310 1
parse_time:
a342 4
	case oForwardX11Trusted:
		intptr = &options->forward_x11_trusted;
		goto parse_flag;

d401 1
a401 1
		goto parse_yesnoask;
a404 1
parse_yesnoask:
d426 2
a427 2
	case oTCPKeepAlive:
		intptr = &options->tcp_keep_alive;
a730 8
	case oServerAliveInterval:
		intptr = &options->server_alive_interval;
		goto parse_time;

	case oServerAliveCountMax:
		intptr = &options->server_alive_count_max;
		goto parse_int;

a806 1
	options->forward_x11_trusted = -1;
d824 1
a824 1
	options->tcp_keep_alive = -1;
a856 2
	options->server_alive_interval = -1;
	options->server_alive_count_max = -1;
a872 2
	if (options->forward_x11_trusted == -1)
		options->forward_x11_trusted = 0;
d886 1
a886 1
		options->gss_authentication = 0;
d905 2
a906 2
	if (options->tcp_keep_alive == -1)
		options->tcp_keep_alive = 1;
a968 4
	if (options->server_alive_interval == -1)
		options->server_alive_interval = 0;
	if (options->server_alive_count_max == -1)
		options->server_alive_count_max = 3;
@


1.101
log
@we cannot use HostbasedAuthentication for enabling ssh-keysign(8),
because HostbasedAuthentication might be enabled based on the
target host and ssh-keysign(8) does not know the remote hostname
and not trust ssh(1) about the hostname, so we add a new option
EnableSSHKeysign; ok djm@@, report from zierke@@informatik.uni-hamburg.de
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.100 2002/06/19 00:27:55 deraadt Exp $");
d269 1
d276 1
a276 1
	char buf[256], *s, *string, **charptr, *endofnumber, *keyword, *arg;
d278 1
d491 1
a491 6
		string = xstrdup("");
		while ((arg = strdelim(&s)) != NULL && *arg != '\0') {
			string = xrealloc(string, strlen(string) + strlen(arg) + 2);
			strcat(string, " ");
			strcat(string, arg);
		}
d493 1
a493 3
			*charptr = string;
		else
			xfree(string);
@


1.100
log
@KNF done automatically while reading....
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.99 2002/06/10 17:45:20 stevesk Exp $");
d117 1
d189 1
d672 4
d799 1
d915 2
@


1.100.2.1
log
@Update to OpenSSH 3.6
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.102 2003/02/05 09:02:28 markus Exp $");
a116 1
	oEnableSSHKeysign,
a187 1
	{ "enablesshkeysign", oEnableSSHKeysign },
a266 1
#define WHITESPACE " \t\r\n"
d273 1
a273 1
	char buf[256], *s, **charptr, *endofnumber, *keyword, *arg;
a274 1
	size_t len;
d487 6
a492 1
		len = strspn(s, WHITESPACE "=");
d494 3
a496 1
			*charptr = xstrdup(s + len);
a669 4
	case oEnableSSHKeysign:
		intptr = &options->enable_ssh_keysign;
		goto parse_flag;

a792 1
	options->enable_ssh_keysign = - 1;
a907 2
	if (options->enable_ssh_keysign == -1)
		options->enable_ssh_keysign = 0;
@


1.100.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.121 2003/09/01 18:15:50 markus Exp $");
d60 1
d78 1
d94 1
a94 1
	oForwardAgent, oForwardX11, oGatewayPorts,
d97 9
d117 2
a118 3
	oEnableSSHKeysign, oRekeyLimit, oVerifyHostKeyDNS, oConnectTimeout,
	oAddressFamily, oGssAuthentication, oGssDelegateCreds,
	oDeprecated, oUnsupported
d132 1
a132 1
	{ "rhostsauthentication", oDeprecated },
d144 8
a151 9
	{ "kerberosauthentication", oUnsupported },
	{ "kerberostgtpassing", oUnsupported },
	{ "afstokenpassing", oUnsupported },
#if defined(GSSAPI)
	{ "gssapiauthentication", oGssAuthentication },
	{ "gssapidelegatecredentials", oGssDelegateCreds },
#else
	{ "gssapiauthentication", oUnsupported },
	{ "gssapidelegatecredentials", oUnsupported },
a186 1
#ifdef SMARTCARD
a187 3
#else
	{ "smartcarddevice", oUnsupported },
#endif
a189 5
#ifdef DNS
	{ "verifyhostkeydns", oVerifyHostKeyDNS },
#else
	{ "verifyhostkeydns", oUnsupported },
#endif
a190 3
	{ "rekeylimit", oRekeyLimit },
	{ "connecttimeout", oConnectTimeout },
	{ "addressfamily", oAddressFamily },
a281 7
	/* Strip trailing whitespace */
	for(len = strlen(line) - 1; len > 0; len--) {
		if (strchr(WHITESPACE, line[len]) == NULL)
			break;
		line[len] = '\0';
	}

a297 14
	case oConnectTimeout:
		intptr = &options->connection_timeout;
/* parse_time: */
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing time value.",
			    filename, linenum);
		if ((value = convtime(arg)) == -1)
			fatal("%s line %d: invalid time value.",
			    filename, linenum);
		if (*intptr == -1)
			*intptr = value;
		break;

d327 4
d362 8
a369 3

	case oGssAuthentication:
		intptr = &options->gss_authentication;
d371 4
a374 3

	case oGssDelegateCreds:
		intptr = &options->gss_deleg_creds;
d376 1
a376 1

a384 4
	case oVerifyHostKeyDNS:
		intptr = &options->verify_host_key_dns;
		goto parse_flag;

a423 25
	case oRekeyLimit:
		intptr = &options->rekey_limit;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (arg[0] < '0' || arg[0] > '9')
			fatal("%.200s line %d: Bad number.", filename, linenum);
		value = strtol(arg, &endofnumber, 10);
		if (arg == endofnumber)
			fatal("%.200s line %d: Bad number.", filename, linenum);
		switch (toupper(*endofnumber)) {
		case 'K':
			value *= 1<<10;
			break;
		case 'M':
			value *= 1<<20;
			break;
		case 'G':
			value *= 1<<30;
			break;
		}
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

a489 2
		if (s == NULL)
			fatal("%.200s line %d: Missing argument.", filename, linenum);
d627 1
a627 1
			add_local_forward(options, fwd_port, "socks", 0);
a666 15
	case oAddressFamily:
		arg = strdelim(&s);
		intptr = &options->address_family;
		if (strcasecmp(arg, "inet") == 0)
			value = AF_INET;
		else if (strcasecmp(arg, "inet6") == 0)
			value = AF_INET6;
		else if (strcasecmp(arg, "any") == 0)
			value = AF_UNSPEC;
		else
			fatal("Unsupported AddressFamily \"%s\"", arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

a675 5
	case oUnsupported:
		error("%s line %d: Unsupported option \"%s\"",
		    filename, linenum, keyword);
		return 0;

d745 1
d749 9
a757 2
	options->gss_authentication = -1;
	options->gss_deleg_creds = -1;
a769 1
	options->address_family = -1;
a770 1
	options->connection_timeout = -1;
a795 2
	options->rekey_limit = - 1;
	options->verify_host_key_dns = -1;
d818 2
d826 12
a837 4
	if (options->gss_authentication == -1)
		options->gss_authentication = 1;
	if (options->gss_deleg_creds == -1)
		options->gss_deleg_creds = 0;
a859 2
	if (options->address_family == -1)
		options->address_family = AF_UNSPEC;
a911 4
	if (options->rekey_limit == -1)
		options->rekey_limit = 0;
	if (options->verify_host_key_dns == -1)
		options->verify_host_key_dns = 0;
@


1.99
log
@change RhostsRSAAuthentication and RhostsAuthentication default to no
since ssh is no longer setuid root by default; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.98 2002/06/08 12:46:14 markus Exp $");
d95 1
a95 1
	oPasswordAuthentication, oRSAAuthentication, 
@


1.98
log
@silently ignore deprecated options, since FallBackToRsh might be passed
by remote scp commands.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.97 2002/06/08 05:40:01 markus Exp $");
d817 1
a817 1
		options->rhosts_authentication = 1;
d841 1
a841 1
		options->rhosts_rsa_authentication = 1;
@


1.97
log
@just warn about Deprecated options for now
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.96 2002/06/08 05:17:01 markus Exp $");
d671 1
a671 1
		error("%s line %d: Deprecated option \"%s\"",
d673 1
a673 1
		break;
@


1.96
log
@deprecate FallBackToRsh and UseRsh; patch from djm@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.95 2002/02/04 12:15:25 markus Exp $");
d671 1
a671 1
		fatal("%s line %d: Deprecated option \"%s\"",
@


1.95
log
@add SYSLOG_FACILITY_NOT_SET = -1, SYSLOG_LEVEL_NOT_SET = -1,
fixes arm/netbsd; based on patch from bjh21@@netbsd.org; ok djm@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.94 2002/01/04 17:59:17 stevesk Exp $");
d44 1
a44 1
     FallBackToRsh no
d68 1
a68 1
     UseRsh yes
a81 2
     FallBackToRsh no
     UseRsh no
d95 1
a95 1
	oPasswordAuthentication, oRSAAuthentication, oFallBackToRsh, oUseRsh,
d116 2
a117 1
	oClearAllForwardings, oNoHostAuthenticationForLocalhost
d152 2
a153 2
	{ "fallbacktorsh", oFallBackToRsh },
	{ "usersh", oUseRsh },
a372 8
	case oFallBackToRsh:
		intptr = &options->fallback_to_rsh;
		goto parse_flag;

	case oUseRsh:
		intptr = &options->use_rsh;
		goto parse_flag;

d670 5
a761 2
	options->fallback_to_rsh = -1;
	options->use_rsh = -1;
a843 4
	if (options->fallback_to_rsh == -1)
		options->fallback_to_rsh = 0;
	if (options->use_rsh == -1)
		options->use_rsh = 0;
@


1.95.2.1
log
@Pull in OpenSSH-3.4
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.100 2002/06/19 00:27:55 deraadt Exp $");
d44 1
a44 1
     User foo
d68 1
a68 1
     PublicKeyAuthentication no
d82 2
d97 1
a97 1
	oPasswordAuthentication, oRSAAuthentication,
d118 1
a118 2
	oClearAllForwardings, oNoHostAuthenticationForLocalhost,
	oDeprecated
d153 2
a154 2
	{ "fallbacktorsh", oDeprecated },
	{ "usersh", oDeprecated },
d374 8
a678 5
	case oDeprecated:
		debug("%s line %d: Deprecated option \"%s\"",
		    filename, linenum, keyword);
		return 0;

d766 2
d823 1
a823 1
		options->rhosts_authentication = 0;
d847 1
a847 1
		options->rhosts_rsa_authentication = 0;
d850 4
@


1.95.2.2
log
@Merge OpenSSH 3.6.1
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.104 2003/04/01 10:22:21 markus Exp $");
a116 1
	oEnableSSHKeysign,
a187 1
	{ "enablesshkeysign", oEnableSSHKeysign },
a266 1
#define WHITESPACE " \t\r\n"
d273 1
a273 1
	char buf[256], *s, **charptr, *endofnumber, *keyword, *arg;
a274 1
	size_t len;
d487 6
a492 1
		len = strspn(s, WHITESPACE "=");
d494 3
a496 1
			*charptr = xstrdup(s + len);
a669 4
	case oEnableSSHKeysign:
		intptr = &options->enable_ssh_keysign;
		goto parse_flag;

a792 1
	options->enable_ssh_keysign = - 1;
a907 2
	if (options->enable_ssh_keysign == -1)
		options->enable_ssh_keysign = 0;
@


1.94
log
@remove #ifdef _PATH_XAUTH/#endif; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.93 2001/12/19 07:18:56 deraadt Exp $");
d592 1
a592 1
		if (value == (LogLevel) - 1)
d595 1
a595 1
		if (*activep && (LogLevel) * intptr == -1)
d795 1
a795 1
	options->log_level = (LogLevel) - 1;
d912 1
a912 1
	if (options->log_level == (LogLevel) - 1)
@


1.93
log
@basic KNF done while i was looking for something else
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.92 2001/11/17 19:14:34 stevesk Exp $");
a815 1
#ifdef _PATH_XAUTH
a817 1
#endif
@


1.92
log
@enum/int type cleanup where it made sense to do so; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.91 2001/10/01 21:51:16 markus Exp $");
d118 1
a118 1
	oClearAllForwardings, oNoHostAuthenticationForLocalhost 
d188 2
a189 2
	{ "clearallforwardings", oClearAllForwardings }, 
	{ "nohostauthenticationforlocalhost", oNoHostAuthenticationForLocalhost }, 
d226 1
a226 1
		      SSH_MAX_FORWARDS_PER_DIRECTION);
d395 1
a395 1
			      filename, linenum);
d437 1
a437 1
				      filename, linenum, SSH_MAX_IDENTITY_FILES);
d537 1
a537 1
			      filename, linenum, arg ? arg : "<NONE>");
d548 1
a548 1
			      filename, linenum, arg ? arg : "<NONE>");
d559 1
a559 1
			      filename, linenum, arg ? arg : "<NONE>");
d570 1
a570 1
			      filename, linenum, arg ? arg : "<NONE>");
d583 1
a583 1
			      filename, linenum, arg ? arg : "<NONE>");
d594 1
a594 1
			      filename, linenum, arg ? arg : "<NONE>");
d671 1
a671 1
			      filename, linenum);
d686 1
a686 1
		      filename, linenum, arg);
d728 1
a728 1
		      filename, bad_options);
@


1.91
log
@add NoHostAuthenticationForLocalhost; note that the hostkey is
now check for localhost, too.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.90 2001/09/19 19:24:18 stevesk Exp $");
d190 1
a190 1
	{ NULL, 0 }
@


1.91.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.95 2002/02/04 12:15:25 markus Exp $");
d118 1
a118 1
	oClearAllForwardings, oNoHostAuthenticationForLocalhost
d188 3
a190 3
	{ "clearallforwardings", oClearAllForwardings },
	{ "nohostauthenticationforlocalhost", oNoHostAuthenticationForLocalhost },
	{ NULL, oBadOption }
d226 1
a226 1
		    SSH_MAX_FORWARDS_PER_DIRECTION);
d395 1
a395 1
			    filename, linenum);
d437 1
a437 1
				    filename, linenum, SSH_MAX_IDENTITY_FILES);
d537 1
a537 1
			    filename, linenum, arg ? arg : "<NONE>");
d548 1
a548 1
			    filename, linenum, arg ? arg : "<NONE>");
d559 1
a559 1
			    filename, linenum, arg ? arg : "<NONE>");
d570 1
a570 1
			    filename, linenum, arg ? arg : "<NONE>");
d583 1
a583 1
			    filename, linenum, arg ? arg : "<NONE>");
d592 1
a592 1
		if (value == SYSLOG_LEVEL_NOT_SET)
d594 2
a595 2
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && (LogLevel) *intptr == SYSLOG_LEVEL_NOT_SET)
d671 1
a671 1
			    filename, linenum);
d686 1
a686 1
		     filename, linenum, arg);
d728 1
a728 1
		    filename, bad_options);
d795 1
a795 1
	options->log_level = SYSLOG_LEVEL_NOT_SET;
d816 1
d819 1
d914 1
a914 1
	if (options->log_level == SYSLOG_LEVEL_NOT_SET)
@


1.91.2.2
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.91.2.1 2002/03/07 17:37:47 jason Exp $");
d44 1
a44 1
     User foo
d68 1
a68 1
     PublicKeyAuthentication no
d82 2
d97 1
a97 1
	oPasswordAuthentication, oRSAAuthentication,
d118 1
a118 2
	oClearAllForwardings, oNoHostAuthenticationForLocalhost,
	oDeprecated
d153 2
a154 2
	{ "fallbacktorsh", oDeprecated },
	{ "usersh", oDeprecated },
d374 8
a678 5
	case oDeprecated:
		debug("%s line %d: Deprecated option \"%s\"",
		    filename, linenum, keyword);
		return 0;

d766 2
d823 1
a823 1
		options->rhosts_authentication = 0;
d847 1
a847 1
		options->rhosts_rsa_authentication = 0;
d850 4
@


1.90
log
@add ClearAllForwardings ssh option and set it in scp and sftp; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.89 2001/09/03 20:58:33 stevesk Exp $");
d118 1
a118 1
	oClearAllForwardings
d189 1
d417 4
d799 1
d918 2
@


1.89
log
@fatal() for nonexistent -Fssh_config. ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.88 2001/08/30 16:04:35 stevesk Exp $");
d117 2
a118 1
	oHostKeyAlgorithms, oBindAddress, oSmartcardDevice
d188 1
d232 13
d637 4
d789 1
d910 2
@


1.88
log
@validate ports for LocalForward/RemoteForward.
add host/port alternative syntax for IPv6 (like -L/-R).
ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.87 2001/08/28 09:51:26 markus Exp $");
d671 1
a671 1
 * there is an error.  If the file does not exist, this returns immediately.
d674 1
a674 1
void
d685 1
a685 1
		return;
d705 1
@


1.87
log
@don't set DynamicForward unless Host matches
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.86 2001/08/01 22:03:33 markus Exp $");
d261 1
d579 1
d583 5
a587 5
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		fwd_port = a2port(arg);
		if (fwd_port == 0)
			fatal("%.200s line %d: Badly formatted port number.",
			      filename, linenum);
d591 16
a606 25
			      filename, linenum);
		if (sscanf(arg, "%255[^:]:%hu", buf, &fwd_host_port) != 2)
			fatal("%.200s line %d: Badly formatted host:port.",
			      filename, linenum);
		if (*activep)
			add_remote_forward(options, fwd_port, buf, fwd_host_port);
		break;

	case oLocalForward:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		fwd_port = a2port(arg);
		if (fwd_port == 0)
			fatal("%.200s line %d: Badly formatted port number.",
			      filename, linenum);
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing second argument.",
			      filename, linenum);
		if (sscanf(arg, "%255[^:]:%hu", buf, &fwd_host_port) != 2)
			fatal("%.200s line %d: Badly formatted host:port.",
			      filename, linenum);
		if (*activep)
			add_local_forward(options, fwd_port, buf, fwd_host_port);
@


1.86
log
@use strings instead of ints for smartcard reader ids
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.85 2001/07/31 09:28:44 jakob Exp $");
d625 2
a626 1
		add_local_forward(options, fwd_port, "socks4", 0);
@


1.85
log
@add 'SmartcardDevice' client option to specify which smartcard device is used
to access a smartcard used for storing the user's private RSA key. ok markus@@.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.84 2001/07/25 14:35:18 markus Exp $");
d470 2
a471 2
		intptr = &options->smartcard_device;
		goto parse_int;
d778 1
a778 1
	options->smartcard_device = -1;
@


1.84
log
@cleanup connect(); connection_attempts 4 -> 1; from eivind@@freebsd.org
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.83 2001/07/22 22:04:19 markus Exp $");
d117 1
a117 1
	oHostKeyAlgorithms, oBindAddress
d186 1
d469 4
d778 1
@


1.83
log
@enable challenge-response auth by default; ok millert@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.82 2001/06/26 16:15:23 dugsong Exp $");
d844 1
a844 1
		options->connection_attempts = 4;
@


1.82
log
@Kerberos v5 support for SSH1, mostly from Assar Westerlund <assar@@freebsd.org> and Bjorn Gronvall <bg@@sics.se>. markus@@ ok
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.81 2001/06/23 02:34:30 markus Exp $");
d804 1
a804 1
		options->challenge_response_authentication = 0;
@


1.81
log
@get rid of known_hosts2, use it for hostkey lookup, but do not modify.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.80 2001/06/08 15:25:40 markus Exp $");
d99 1
a99 1
#ifdef KRB4
d101 4
a104 1
#endif /* KRB4 */
d106 1
a106 1
	oKerberosTgtPassing, oAFSTokenPassing,
d143 1
a143 1
#ifdef KRB4
d145 4
a148 1
#endif /* KRB4 */
a149 1
	{ "kerberostgtpassing", oKerberosTgtPassing },
d341 1
a341 2

#ifdef KRB4
d345 2
a346 3
#endif /* KRB4 */

#ifdef AFS
d350 2
a351 1

a355 1

d728 1
a728 1
#ifdef KRB4
d731 3
a734 1
	options->kerberos_tgt_passing = -1;
d805 1
a805 1
#ifdef KRB4
d808 2
a809 2
#endif /* KRB4 */
#ifdef AFS
d812 2
d816 1
a816 1
#endif /* AFS */
@


1.80
log
@move the path for xauth to pathnames.h
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.79 2001/05/24 18:57:53 stevesk Exp $");
d165 1
a165 1
	{ "userknownhostsfile", oUserKnownHostsFile },
d167 1
a167 1
	{ "userknownhostsfile2", oUserKnownHostsFile2 },
@


1.79
log
@don't perform escape processing when ``EscapeChar none''; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.78 2001/05/18 14:13:28 markus Exp $");
d784 1
a784 1
#ifdef XAUTH_PATH
d786 2
a787 2
		options->xauth_location = XAUTH_PATH;
#endif /* XAUTH_PATH */
@


1.78
log
@improved kbd-interactive support. work by per@@appgate.com and me
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.77 2001/04/30 11:18:51 markus Exp $");
d642 1
a642 1
			value = -2;
@


1.77
log
@implement 'ssh -b bind_address' like 'telnet -b'
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.76 2001/04/17 10:53:25 markus Exp $");
d334 1
a334 1
		intptr = &options->challenge_reponse_authentication;
d724 1
a724 1
	options->challenge_reponse_authentication = -1;
d798 2
a799 2
	if (options->challenge_reponse_authentication == -1)
		options->challenge_reponse_authentication = 0;
@


1.76
log
@add HostKeyAlgorithms; based on patch from res@@shore.net; ok provos@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.75 2001/04/15 21:28:35 stevesk Exp $");
d114 1
a114 1
	oHostKeyAlgorithms
d180 1
d461 4
d767 1
@


1.76.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.90 2001/09/19 19:24:18 stevesk Exp $");
d99 1
a99 1
#if defined(KRB4) || defined(KRB5)
d101 1
a101 4
#endif
#if defined(AFS) || defined(KRB5)
	oKerberosTgtPassing,
#endif
d103 1
a103 1
	oAFSTokenPassing,
d114 1
a114 2
	oHostKeyAlgorithms, oBindAddress, oSmartcardDevice,
	oClearAllForwardings
d140 1
a140 1
#if defined(KRB4) || defined(KRB5)
d142 2
a143 2
#endif
#if defined(AFS) || defined(KRB5)
a144 2
#endif
#ifdef AFS
d165 1
a165 1
	{ "userknownhostsfile", oUserKnownHostsFile },		/* obsolete */
d167 1
a167 1
	{ "userknownhostsfile2", oUserKnownHostsFile2 },	/* obsolete */
a179 3
	{ "bindaddress", oBindAddress },
	{ "smartcarddevice", oSmartcardDevice },
	{ "clearallforwardings", oClearAllForwardings }, 
a222 13
static void
clear_forwardings(Options *options)
{
	int i;

	for (i = 0; i < options->num_local_forwards; i++)
		xfree(options->local_forwards[i].host);
	options->num_local_forwards = 0;
	for (i = 0; i < options->num_remote_forwards; i++)
		xfree(options->remote_forwards[i].host);
	options->num_remote_forwards = 0;
}

a253 1
	char sfwd_host_port[6];
d333 1
a333 1
		intptr = &options->challenge_response_authentication;
d335 2
a336 1
#if defined(KRB4) || defined(KRB5)
d340 3
a342 2
#endif
#if defined(AFS) || defined(KRB5)
d346 1
a346 2
#endif
#ifdef AFS
d351 1
a459 8
	case oBindAddress:
		charptr = &options->bind_address;
		goto parse_string;

	case oSmartcardDevice:
		charptr = &options->smartcard_device;
		goto parse_string;

d565 19
a584 1
	case oRemoteForward:
d587 5
a591 5
			fatal("%.200s line %d: Missing port argument.",
			    filename, linenum);
		if ((fwd_port = a2port(arg)) == 0)
			fatal("%.200s line %d: Bad listen port.",
			    filename, linenum);
d595 6
a600 16
			    filename, linenum);
		if (sscanf(arg, "%255[^:]:%5[0-9]", buf, sfwd_host_port) != 2 &&
		    sscanf(arg, "%255[^/]/%5[0-9]", buf, sfwd_host_port) != 2)
			fatal("%.200s line %d: Bad forwarding specification.",
			    filename, linenum);
		if ((fwd_host_port = a2port(sfwd_host_port)) == 0)
			fatal("%.200s line %d: Bad forwarding port.",
			    filename, linenum);
		if (*activep) {
			if (opcode == oLocalForward)
				add_local_forward(options, fwd_port, buf,
				    fwd_host_port);
			else if (opcode == oRemoteForward)
				add_remote_forward(options, fwd_port, buf,
				    fwd_host_port);
		}
d612 1
a612 2
		if (*activep)
			add_local_forward(options, fwd_port, "socks4", 0);
a614 4
	case oClearAllForwardings:
		intptr = &options->clear_forwardings;
		goto parse_flag;

d637 1
a637 1
			value = SSH_ESCAPECHAR_NONE;
d664 1
a664 1
 * there is an error.  If the file does not exist, this returns 0.
d667 1
a667 1
int
d678 1
a678 1
		return 0;
a697 1
	return 1;
d719 2
a720 2
	options->challenge_response_authentication = -1;
#if defined(KRB4) || defined(KRB5)
d723 1
a723 1
#if defined(AFS) || defined(KRB5)
a724 2
#endif
#ifdef AFS
a759 1
	options->clear_forwardings = -1;
a761 2
	options->bind_address = NULL;
	options->smartcard_device = NULL;
d778 1
a778 1
#ifdef _PATH_XAUTH
d780 2
a781 2
		options->xauth_location = _PATH_XAUTH;
#endif
d792 3
a794 3
	if (options->challenge_response_authentication == -1)
		options->challenge_response_authentication = 1;
#if defined(KRB4) || defined(KRB5)
d797 2
a798 2
#endif
#if defined(AFS) || defined(KRB5)
a800 2
#endif
#ifdef AFS
d803 1
a803 1
#endif
d831 1
a831 1
		options->connection_attempts = 1;
a875 2
	if (options->clear_forwardings == 1)
		clear_forwardings(options);
@


1.76.2.2
log
@Merge OpenSSH 3.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.76.2.1 2001/09/27 19:03:54 jason Exp $");
d118 1
a118 1
	oClearAllForwardings, oNoHostAuthenticationForLocalhost 
a188 1
	{ "nohostauthenticationforlocalhost", oNoHostAuthenticationForLocalhost }, 
a415 4
	case oNoHostAuthenticationForLocalhost:
		intptr = &options->no_host_authentication_for_localhost;
		goto parse_flag;

a793 1
	options->no_host_authentication_for_localhost = - 1;
a911 2
	if (options->no_host_authentication_for_localhost == - 1)
		options->no_host_authentication_for_localhost = 0;
@


1.76.2.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.95 2002/02/04 12:15:25 markus Exp $");
d118 1
a118 1
	oClearAllForwardings, oNoHostAuthenticationForLocalhost
d188 3
a190 3
	{ "clearallforwardings", oClearAllForwardings },
	{ "nohostauthenticationforlocalhost", oNoHostAuthenticationForLocalhost },
	{ NULL, oBadOption }
d226 1
a226 1
		    SSH_MAX_FORWARDS_PER_DIRECTION);
d395 1
a395 1
			    filename, linenum);
d437 1
a437 1
				    filename, linenum, SSH_MAX_IDENTITY_FILES);
d537 1
a537 1
			    filename, linenum, arg ? arg : "<NONE>");
d548 1
a548 1
			    filename, linenum, arg ? arg : "<NONE>");
d559 1
a559 1
			    filename, linenum, arg ? arg : "<NONE>");
d570 1
a570 1
			    filename, linenum, arg ? arg : "<NONE>");
d583 1
a583 1
			    filename, linenum, arg ? arg : "<NONE>");
d592 1
a592 1
		if (value == SYSLOG_LEVEL_NOT_SET)
d594 2
a595 2
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && (LogLevel) *intptr == SYSLOG_LEVEL_NOT_SET)
d671 1
a671 1
			    filename, linenum);
d686 1
a686 1
		     filename, linenum, arg);
d728 1
a728 1
		    filename, bad_options);
d795 1
a795 1
	options->log_level = SYSLOG_LEVEL_NOT_SET;
d816 1
d819 1
d914 1
a914 1
	if (options->log_level == SYSLOG_LEVEL_NOT_SET)
@


1.75
log
@use fatal() or error() vs. fprintf(); ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.74 2001/04/12 20:09:37 stevesk Exp $");
d113 2
a114 1
	oDynamicForward, oPreferredAuthentications, oHostbasedAuthentication
d179 1
d530 11
d746 1
d839 1
@


1.74
log
@robust port validation; ok markus@@ jakob@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.73 2001/04/12 19:39:27 markus Exp $");
d234 2
a235 2
	fprintf(stderr, "%s: line %d: Bad configuration option: %s\n",
		filename, linenum, cp);
@


1.73
log
@typo
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.72 2001/04/12 19:15:25 markus Exp $");
d556 2
a557 1
		if (arg[0] < '0' || arg[0] > '9')
a559 1
		fwd_port = atoi(arg);
d575 2
a576 1
		if (arg[0] < '0' || arg[0] > '9')
a578 1
		fwd_port = atoi(arg);
d595 2
a596 1
		if (arg[0] < '0' || arg[0] > '9')
a598 1
		fwd_port = atoi(arg);
@


1.72
log
@implement HostbasedAuthentication (= RhostRSAAuthentication for ssh v2)
similar to RhostRSAAuthentication unless you enable (the experimental)
HostbasedUsesNameFromPacketOnly option.  please test. :)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.71 2001/04/07 08:55:17 markus Exp $");
d135 1
a135 1
	{ "hostbaedauthentication", oHostbasedAuthentication },
@


1.71
log
@allow the ssh client act as a SOCKS4 proxy (dynamic local portforwarding).
work by Dan Kaminsky <dankamin@@cisco.com> and me. thanks to Dan for this
great patch: use 'ssh -D 1080 host' and make netscape use localhost:1080 as
a socks proxy.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.70 2001/04/02 14:20:23 stevesk Exp $");
d113 1
a113 1
	oDynamicForward, oPreferredAuthentications
d134 2
a162 1
	{ "rhostsrsaauthentication", oRhostsRSAAuthentication },
d326 4
d600 1
a600 1
                break;
d718 1
d796 2
@


1.70
log
@correct comment; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.69 2001/03/20 19:10:16 markus Exp $");
d113 1
a113 1
	oPreferredAuthentications
d175 1
d584 12
@


1.69
log
@default to SSH protocol version 2
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.67 2001/03/10 17:51:04 markus Exp $");
d220 1
a220 2
 * Returns the number of the token pointed to by cp of length len. Never
 * returns if the token is not known.
@


1.68
log
@undo /etc/shell and proto 2,1 change for openssh-2.5.2
@
text
@d806 1
a806 1
		options->protocol = SSH_PROTO_1|SSH_PROTO_2|SSH_PROTO_1_PREFERRED;
@


1.67
log
@add PreferredAuthentications
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.66 2001/03/10 12:53:52 deraadt Exp $");
d806 1
a806 1
		options->protocol = SSH_PROTO_1|SSH_PROTO_2;
@


1.66
log
@default to SSH2, now that m68k runs fast
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.65 2001/03/08 00:15:47 markus Exp $");
d112 2
a113 1
	oKbdInteractiveAuthentication, oKbdInteractiveDevices, oHostKeyAlias
d175 1
d449 4
d729 1
d845 1
@


1.65
log
@turn off useprivilegedports by default. only rhost-auth needs
this. older sshd's may need this, too.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.64 2001/03/04 17:42:28 millert Exp $");
d799 1
a799 1
		options->protocol = SSH_PROTO_1|SSH_PROTO_2|SSH_PROTO_1_PREFERRED;
@


1.64
log
@log functions should not be passed strings that end in newline as they
get passed on to syslog() and when logging to stderr, do_log() appends
its own newline.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.63 2001/02/24 10:37:55 deraadt Exp $");
d746 1
a746 1
		options->use_privileged_port = 1;
@


1.63
log
@look for id_rsa by default, before id_dsa
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.62 2001/02/11 12:59:25 markus Exp $");
d189 1
a189 1
		fatal("Privileged ports can only be forwarded by root.\n");
d535 1
a535 1
			fatal("%.200s line %d: unsupported log level '%s'\n",
d660 1
a660 1
		fatal("%s: terminating, %d bad configuration options\n",
@


1.62
log
@1) clean up the MAC support for SSH-2
2) allow you to specify the MAC with 'ssh -m'
3) or the 'MACs' keyword in ssh(d)_config
4) add hmac-{md5,sha1}-96
	ok stevesk@@, provos@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.61 2001/02/08 14:39:36 deraadt Exp $");
d809 6
@


1.61
log
@snprintf
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.60 2001/01/28 20:36:16 stevesk Exp $");
d26 2
d110 1
a110 1
	oUsePrivilegedPort, oLogLevel, oCiphers, oProtocol,
d153 1
d506 11
d708 1
d797 1
@


1.60
log
@``StrictHostKeyChecking ask'' documentation and small cleanup.
ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.59 2001/01/22 23:06:39 markus Exp $");
d718 2
d786 1
d788 3
a790 3
			    xmalloc(2 + strlen(_PATH_SSH_CLIENT_IDENTITY) + 1);
			sprintf(options->identity_files[options->num_identity_files++],
			    "~/%.100s", _PATH_SSH_CLIENT_IDENTITY);
d793 1
d795 3
a797 3
			    xmalloc(2 + strlen(_PATH_SSH_CLIENT_ID_DSA) + 1);
			sprintf(options->identity_files[options->num_identity_files++],
			    "~/%.100s", _PATH_SSH_CLIENT_ID_DSA);
@


1.59
log
@rename skey -> challenge response.
auto-enable kbd-interactive for ssh2 if challenge-reponse is enabled.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.58 2001/01/21 19:05:53 markus Exp $");
d360 1
a360 1
			fatal("%.200s line %d: Missing yes/no argument.",
@


1.58
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.57 2001/01/20 23:02:07 djm Exp $");
d96 1
a96 1
	oSkeyAuthentication, oXAuthLocation,
d107 1
a107 1
	oCompressionLevel, oKeepAlives, oNumberOfPasswordPrompts, oTISAuthentication,
d130 4
a133 2
	{ "dsaauthentication", oPubkeyAuthentication },		/* alias */
	{ "skeyauthentication", oSkeyAuthentication },
a169 1
	{ "tisauthentication", oTISAuthentication },
d320 2
a321 4
	case oTISAuthentication:
		/* fallthrough, there is no difference on the client side */
	case oSkeyAuthentication:
		intptr = &options->skey_authentication;
d669 1
a669 1
	options->skey_authentication = -1;
d736 2
a737 2
	if (options->skey_authentication == -1)
		options->skey_authentication = 0;
d751 1
a751 1
		options->kbd_interactive_authentication = 0;
@


1.57
log
@KNF; ok markus
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.56 2001/01/20 17:59:40 deraadt Exp $");
a17 2
#include "readconf.h"
#include "match.h"
d20 1
d22 4
@


1.56
log
@fix SIGSEGV from -o ""; problem noted by jehsom@@togetherweb.com
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.55 2001/01/19 15:55:11 markus Exp $");
d601 1
a601 2
	if ((arg = strdelim(&s)) != NULL && *arg != '\0')
	{
@


1.55
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.54 2001/01/18 16:20:22 markus Exp $");
d249 1
a249 1
	if (!*keyword || *keyword == '\n' || *keyword == '#')
@


1.54
log
@log() is at pri=LOG_INFO, since LOG_NOTICE goes to /dev/console on many systems
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.53 2001/01/07 11:28:05 markus Exp $");
d22 1
d784 1
a784 1
			    xmalloc(2 + strlen(SSH_CLIENT_IDENTITY) + 1);
d786 1
a786 1
			    "~/%.100s", SSH_CLIENT_IDENTITY);
d790 1
a790 1
			    xmalloc(2 + strlen(SSH_CLIENT_ID_DSA) + 1);
d792 1
a792 1
			    "~/%.100s", SSH_CLIENT_ID_DSA);
d798 1
a798 1
		options->system_hostfile = SSH_SYSTEM_HOSTFILE;
d800 1
a800 1
		options->user_hostfile = SSH_USER_HOSTFILE;
d802 1
a802 1
		options->system_hostfile2 = SSH_SYSTEM_HOSTFILE2;
d804 1
a804 1
		options->user_hostfile2 = SSH_USER_HOSTFILE2;
@


1.53
log
@rename SYSLOG_LEVEL_INFO->SYSLOG_LEVEL_NOTICE
syslog priority changes:
	fatal() LOG_ERR  -> LOG_CRIT
	log()   LOG_INFO -> LOG_NOTICE
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.52 2000/12/27 12:30:19 markus Exp $");
d805 1
a805 1
		options->log_level = SYSLOG_LEVEL_NOTICE;
@


1.52
log
@new option: HostKeyAlias: allows the user to record the host key
under a different name. This is useful for ssh tunneling over
forwarded connections or if you run multiple sshd's on different
ports on the same machine.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.51 2000/12/19 23:17:57 markus Exp $");
d805 1
a805 1
		options->log_level = SYSLOG_LEVEL_INFO;
@


1.51
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.50 2000/11/12 19:50:37 markus Exp $");
d106 1
a106 1
	oKbdInteractiveAuthentication, oKbdInteractiveDevices
d140 1
d437 4
d695 1
d809 1
@


1.50
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.49 2000/10/11 20:27:23 markus Exp $");
d216 1
a216 1
	unsigned int i;
d574 2
a575 2
		    (unsigned char) arg[1] >= 64 && (unsigned char) arg[1] < 128)
			value = (unsigned char) arg[1] & 31;
d577 1
a577 1
			value = (unsigned char) arg[0];
@


1.49
log
@new cipher framework
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.48 2000/10/11 20:14:39 markus Exp $");
d71 1
a71 1
     ForwardX11 yes
d104 2
a105 2
	oUsePrivilegedPort, oLogLevel, oCiphers, oProtocol, oIdentityFile2,
	oGlobalKnownHostsFile2, oUserKnownHostsFile2, oDSAAuthentication,
d125 2
a126 1
	{ "dsaauthentication", oDSAAuthentication },
d138 1
a138 1
	{ "identityfile2", oIdentityFile2 },
d302 2
a303 2
	case oDSAAuthentication:
		intptr = &options->dsa_authentication;
a387 1
	case oIdentityFile2:
d392 1
a392 3
			intptr = (opcode == oIdentityFile) ?
			    &options->num_identity_files :
			    &options->num_identity_files2;
d396 1
a396 3
			charptr = (opcode == oIdentityFile) ?
			    &options->identity_files[*intptr] :
			    &options->identity_files2[*intptr];
d661 1
a661 1
	options->dsa_authentication = -1;
a688 1
	options->num_identity_files2 = 0;
d726 2
a727 2
	if (options->dsa_authentication == -1)
		options->dsa_authentication = 1;
d775 12
a786 10
		options->identity_files[0] =
			xmalloc(2 + strlen(SSH_CLIENT_IDENTITY) + 1);
		sprintf(options->identity_files[0], "~/%.100s", SSH_CLIENT_IDENTITY);
		options->num_identity_files = 1;
	}
	if (options->num_identity_files2 == 0) {
		options->identity_files2[0] =
			xmalloc(2 + strlen(SSH_CLIENT_ID_DSA) + 1);
		sprintf(options->identity_files2[0], "~/%.100s", SSH_CLIENT_ID_DSA);
		options->num_identity_files2 = 1;
@


1.49.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.62 2001/02/11 12:59:25 markus Exp $");
d18 2
a21 8
#include "cipher.h"
#include "pathnames.h"
#include "log.h"
#include "readconf.h"
#include "match.h"
#include "misc.h"
#include "kex.h"
#include "mac.h"
d71 1
a71 1
     ForwardX11 no
d92 1
a92 1
	oChallengeResponseAuthentication, oXAuthLocation,
d103 4
a106 4
	oCompressionLevel, oKeepAlives, oNumberOfPasswordPrompts,
	oUsePrivilegedPort, oLogLevel, oCiphers, oProtocol, oMacs,
	oGlobalKnownHostsFile2, oUserKnownHostsFile2, oPubkeyAuthentication,
	oKbdInteractiveAuthentication, oKbdInteractiveDevices, oHostKeyAlias
d125 2
a126 5
	{ "pubkeyauthentication", oPubkeyAuthentication },
	{ "dsaauthentication", oPubkeyAuthentication },		    /* alias */
	{ "challengeresponseauthentication", oChallengeResponseAuthentication },
	{ "skeyauthentication", oChallengeResponseAuthentication }, /* alias */
	{ "tisauthentication", oChallengeResponseAuthentication },  /* alias */
d137 1
a137 1
	{ "identityfile2", oIdentityFile },			/* alias */
a138 1
	{ "hostkeyalias", oHostKeyAlias },
a142 1
	{ "macs", oMacs },
d162 1
d215 1
a215 1
	u_int i;
d246 1
a246 1
	if (keyword == NULL || !*keyword || *keyword == '\n' || *keyword == '#')
d301 2
a302 2
	case oPubkeyAuthentication:
		intptr = &options->pubkey_authentication;
d313 4
a316 2
	case oChallengeResponseAuthentication:
		intptr = &options->challenge_reponse_authentication;
d355 1
a355 1
			fatal("%.200s line %d: Missing yes/no/ask argument.",
d387 1
d392 3
a394 1
			intptr = &options->num_identity_files;
d398 3
a400 1
			charptr =  &options->identity_files[*intptr];
a439 4
	case oHostKeyAlias:
		charptr = &options->host_key_alias;
		goto parse_string;

a498 11
	case oMacs:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (!mac_valid(arg))
			fatal("%.200s line %d: Bad SSH2 Mac spec '%s'.",
			      filename, linenum, arg ? arg : "<NONE>");
		if (*activep && options->macs == NULL)
			options->macs = xstrdup(arg);
		break;

d578 2
a579 2
		    (u_char) arg[1] >= 64 && (u_char) arg[1] < 128)
			value = (u_char) arg[1] & 31;
d581 1
a581 1
			value = (u_char) arg[0];
d599 2
a600 1
	if ((arg = strdelim(&s)) != NULL && *arg != '\0') {
d665 2
a666 2
	options->pubkey_authentication = -1;
	options->challenge_reponse_authentication = -1;
a690 1
	options->macs = NULL;
d693 1
a694 1
	options->host_key_alias = NULL;
a714 2
	int len;

d731 4
a734 4
	if (options->pubkey_authentication == -1)
		options->pubkey_authentication = 1;
	if (options->challenge_reponse_authentication == -1)
		options->challenge_reponse_authentication = 0;
d748 1
a748 1
		options->kbd_interactive_authentication = 1;
a776 1
	/* options->macs, default set in myproposals.h */
d780 10
a789 14
		if (options->protocol & SSH_PROTO_1) {
			len = 2 + strlen(_PATH_SSH_CLIENT_IDENTITY) + 1;
			options->identity_files[options->num_identity_files] =
			    xmalloc(len);
			snprintf(options->identity_files[options->num_identity_files++],
			    len, "~/%.100s", _PATH_SSH_CLIENT_IDENTITY);
		}
		if (options->protocol & SSH_PROTO_2) {
			len = 2 + strlen(_PATH_SSH_CLIENT_ID_DSA) + 1;
			options->identity_files[options->num_identity_files] =
			    xmalloc(len);
			snprintf(options->identity_files[options->num_identity_files++],
			    len, "~/%.100s", _PATH_SSH_CLIENT_ID_DSA);
		}
d794 1
a794 1
		options->system_hostfile = _PATH_SSH_SYSTEM_HOSTFILE;
d796 1
a796 1
		options->user_hostfile = _PATH_SSH_USER_HOSTFILE;
d798 1
a798 1
		options->system_hostfile2 = _PATH_SSH_SYSTEM_HOSTFILE2;
d800 1
a800 1
		options->user_hostfile2 = _PATH_SSH_USER_HOSTFILE2;
a805 1
	/* options->host_key_alias should not be set by default */
@


1.49.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.49.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.68 2001/03/19 17:07:23 markus Exp $");
d112 1
a112 2
	oKbdInteractiveAuthentication, oKbdInteractiveDevices, oHostKeyAlias,
	oPreferredAuthentications
a173 1
	{ "preferredauthentications", oPreferredAuthentications },
d189 1
a189 1
		fatal("Privileged ports can only be forwarded by root.");
a446 4
	case oPreferredAuthentications:
		charptr = &options->preferred_authentications;
		goto parse_string;

d535 1
a535 1
			fatal("%.200s line %d: unsupported log level '%s'",
d660 1
a660 1
		fatal("%s: terminating, %d bad configuration options",
a722 1
	options->preferred_authentications = NULL;
d746 1
a746 1
		options->use_privileged_port = 0;
a808 6
			len = 2 + strlen(_PATH_SSH_CLIENT_ID_RSA) + 1;
			options->identity_files[options->num_identity_files] =
			    xmalloc(len);
			snprintf(options->identity_files[options->num_identity_files++],
			    len, "~/%.100s", _PATH_SSH_CLIENT_ID_RSA);

a831 1
	/* options->preferred_authentications will be set in ssh */
@


1.49.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.76 2001/04/17 10:53:25 markus Exp $");
d113 1
a113 2
	oDynamicForward, oPreferredAuthentications, oHostbasedAuthentication,
	oHostKeyAlgorithms
a133 2
	{ "rhostsrsaauthentication", oRhostsRSAAuthentication },
	{ "hostbasedauthentication", oHostbasedAuthentication },
d161 1
a174 1
	{ "dynamicforward", oDynamicForward },
a175 1
	{ "hostkeyalgorithms", oHostKeyAlgorithms },
d220 2
a221 1
 * Returns the number of the token pointed to by cp or oBadOption.
d233 2
a234 2
	error("%s: line %d: Bad configuration option: %s",
	    filename, linenum, cp);
a324 4
	case oHostbasedAuthentication:
		intptr = &options->hostbased_authentication;
		goto parse_flag;

a522 11
	case oHostKeyAlgorithms:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (!key_names_valid2(arg))
			fatal("%.200s line %d: Bad protocol 2 host key algorithms '%s'.",
			      filename, linenum, arg ? arg : "<NONE>");
		if (*activep && options->hostkeyalgorithms == NULL)
			options->hostkeyalgorithms = xstrdup(arg);
		break;

d551 1
a551 2
		fwd_port = a2port(arg);
		if (fwd_port == 0)
d554 1
d570 1
a570 2
		fwd_port = a2port(arg);
		if (fwd_port == 0)
d573 1
a584 12
	case oDynamicForward:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing port argument.",
			    filename, linenum);
		fwd_port = a2port(arg);
		if (fwd_port == 0)
			fatal("%.200s line %d: Badly formatted port number.",
			    filename, linenum);
		add_local_forward(options, fwd_port, "socks4", 0);
		break;

a700 1
	options->hostbased_authentication = -1;
a714 1
	options->hostkeyalgorithms = NULL;
a777 2
	if (options->hostbased_authentication == -1)
		options->hostbased_authentication = 0;
a804 1
	/* options->hostkeyalgorithms, default set in myproposals.h */
d806 1
a806 1
		options->protocol = SSH_PROTO_1|SSH_PROTO_2;
@


1.49.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.90 2001/09/19 19:24:18 stevesk Exp $");
d99 1
a99 1
#if defined(KRB4) || defined(KRB5)
d101 1
a101 4
#endif
#if defined(AFS) || defined(KRB5)
	oKerberosTgtPassing,
#endif
d103 1
a103 1
	oAFSTokenPassing,
d114 1
a114 2
	oHostKeyAlgorithms, oBindAddress, oSmartcardDevice,
	oClearAllForwardings
d140 1
a140 1
#if defined(KRB4) || defined(KRB5)
d142 2
a143 2
#endif
#if defined(AFS) || defined(KRB5)
a144 2
#endif
#ifdef AFS
d165 1
a165 1
	{ "userknownhostsfile", oUserKnownHostsFile },		/* obsolete */
d167 1
a167 1
	{ "userknownhostsfile2", oUserKnownHostsFile2 },	/* obsolete */
a179 3
	{ "bindaddress", oBindAddress },
	{ "smartcarddevice", oSmartcardDevice },
	{ "clearallforwardings", oClearAllForwardings }, 
a222 13
static void
clear_forwardings(Options *options)
{
	int i;

	for (i = 0; i < options->num_local_forwards; i++)
		xfree(options->local_forwards[i].host);
	options->num_local_forwards = 0;
	for (i = 0; i < options->num_remote_forwards; i++)
		xfree(options->remote_forwards[i].host);
	options->num_remote_forwards = 0;
}

a253 1
	char sfwd_host_port[6];
d333 1
a333 1
		intptr = &options->challenge_response_authentication;
d335 2
a336 1
#if defined(KRB4) || defined(KRB5)
d340 3
a342 2
#endif
#if defined(AFS) || defined(KRB5)
d346 1
a346 2
#endif
#ifdef AFS
d351 1
a459 8
	case oBindAddress:
		charptr = &options->bind_address;
		goto parse_string;

	case oSmartcardDevice:
		charptr = &options->smartcard_device;
		goto parse_string;

d565 19
a584 1
	case oRemoteForward:
d587 5
a591 5
			fatal("%.200s line %d: Missing port argument.",
			    filename, linenum);
		if ((fwd_port = a2port(arg)) == 0)
			fatal("%.200s line %d: Bad listen port.",
			    filename, linenum);
d595 6
a600 16
			    filename, linenum);
		if (sscanf(arg, "%255[^:]:%5[0-9]", buf, sfwd_host_port) != 2 &&
		    sscanf(arg, "%255[^/]/%5[0-9]", buf, sfwd_host_port) != 2)
			fatal("%.200s line %d: Bad forwarding specification.",
			    filename, linenum);
		if ((fwd_host_port = a2port(sfwd_host_port)) == 0)
			fatal("%.200s line %d: Bad forwarding port.",
			    filename, linenum);
		if (*activep) {
			if (opcode == oLocalForward)
				add_local_forward(options, fwd_port, buf,
				    fwd_host_port);
			else if (opcode == oRemoteForward)
				add_remote_forward(options, fwd_port, buf,
				    fwd_host_port);
		}
d612 1
a612 2
		if (*activep)
			add_local_forward(options, fwd_port, "socks4", 0);
a614 4
	case oClearAllForwardings:
		intptr = &options->clear_forwardings;
		goto parse_flag;

d637 1
a637 1
			value = SSH_ESCAPECHAR_NONE;
d664 1
a664 1
 * there is an error.  If the file does not exist, this returns 0.
d667 1
a667 1
int
d678 1
a678 1
		return 0;
a697 1
	return 1;
d719 2
a720 2
	options->challenge_response_authentication = -1;
#if defined(KRB4) || defined(KRB5)
d723 1
a723 1
#if defined(AFS) || defined(KRB5)
a724 2
#endif
#ifdef AFS
a759 1
	options->clear_forwardings = -1;
a761 2
	options->bind_address = NULL;
	options->smartcard_device = NULL;
d778 1
a778 1
#ifdef _PATH_XAUTH
d780 2
a781 2
		options->xauth_location = _PATH_XAUTH;
#endif
d792 3
a794 3
	if (options->challenge_response_authentication == -1)
		options->challenge_response_authentication = 1;
#if defined(KRB4) || defined(KRB5)
d797 2
a798 2
#endif
#if defined(AFS) || defined(KRB5)
a800 2
#endif
#ifdef AFS
d803 1
a803 1
#endif
d831 1
a831 1
		options->connection_attempts = 1;
a875 2
	if (options->clear_forwardings == 1)
		clear_forwardings(options);
@


1.49.2.6
log
@Merge OpenSSH 3.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.49.2.5 2001/09/27 00:15:42 miod Exp $");
d118 1
a118 1
	oClearAllForwardings, oNoHostAuthenticationForLocalhost 
a188 1
	{ "nohostauthenticationforlocalhost", oNoHostAuthenticationForLocalhost }, 
a415 4
	case oNoHostAuthenticationForLocalhost:
		intptr = &options->no_host_authentication_for_localhost;
		goto parse_flag;

a793 1
	options->no_host_authentication_for_localhost = - 1;
a911 2
	if (options->no_host_authentication_for_localhost == - 1)
		options->no_host_authentication_for_localhost = 0;
@


1.49.2.7
log
@Merge OpenSSH 3.1.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.95 2002/02/04 12:15:25 markus Exp $");
d118 1
a118 1
	oClearAllForwardings, oNoHostAuthenticationForLocalhost
d188 3
a190 3
	{ "clearallforwardings", oClearAllForwardings },
	{ "nohostauthenticationforlocalhost", oNoHostAuthenticationForLocalhost },
	{ NULL, oBadOption }
d226 1
a226 1
		    SSH_MAX_FORWARDS_PER_DIRECTION);
d395 1
a395 1
			    filename, linenum);
d437 1
a437 1
				    filename, linenum, SSH_MAX_IDENTITY_FILES);
d537 1
a537 1
			    filename, linenum, arg ? arg : "<NONE>");
d548 1
a548 1
			    filename, linenum, arg ? arg : "<NONE>");
d559 1
a559 1
			    filename, linenum, arg ? arg : "<NONE>");
d570 1
a570 1
			    filename, linenum, arg ? arg : "<NONE>");
d583 1
a583 1
			    filename, linenum, arg ? arg : "<NONE>");
d592 1
a592 1
		if (value == SYSLOG_LEVEL_NOT_SET)
d594 2
a595 2
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && (LogLevel) *intptr == SYSLOG_LEVEL_NOT_SET)
d671 1
a671 1
			    filename, linenum);
d686 1
a686 1
		     filename, linenum, arg);
d728 1
a728 1
		    filename, bad_options);
d795 1
a795 1
	options->log_level = SYSLOG_LEVEL_NOT_SET;
d816 1
d819 1
d914 1
a914 1
	if (options->log_level == SYSLOG_LEVEL_NOT_SET)
@


1.48
log
@add support for s/key (kbd-interactive) to ssh2, based on work by mkiernan@@avantgo.com and me
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.47 2000/09/07 21:13:37 markus Exp $");
a17 1
#include "cipher.h"
@


1.47
log
@some more Copyright fixes
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.46 2000/09/07 20:27:53 deraadt Exp $");
d106 2
a107 1
	oGlobalKnownHostsFile2, oUserKnownHostsFile2, oDSAAuthentication
d123 2
d294 8
d676 2
d748 2
@


1.46
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@a11 23
 *
 *
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.45 2000/08/02 17:27:04 provos Exp $");
@


1.45
log
@disallow kerberos authentication if we can't verify the TGT; from
dugsong@@
kerberos authentication is on by default only if you have a srvtab.
@
text
@a1 3
 *
 * readconf.c
 *
a2 1
 *
a4 3
 *
 * Created: Sat Apr 22 00:03:10 1995 ylo
 *
d7 28
d38 1
a38 1
RCSID("$OpenBSD: readconf.c,v 1.44 2000/08/02 16:27:16 provos Exp $");
@


1.44
log
@disable kerberos authentication by default
@
text
@d17 1
a17 1
RCSID("$OpenBSD: readconf.c,v 1.43 2000/07/14 22:59:46 markus Exp $");
d727 1
a727 1
		options->kerberos_authentication = 0;
@


1.43
log
@ allow leading whitespace. ok niels
@
text
@d17 1
a17 1
RCSID("$OpenBSD: readconf.c,v 1.42 2000/07/13 22:53:21 provos Exp $");
d727 1
a727 1
		options->kerberos_authentication = 1;
@


1.42
log
@allow multiple whitespace but only one '=' between tokens, bug report from
Ralf S. Engelschall <rse@@engelschall.com> but different fix. okay deraadt@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: readconf.c,v 1.41 2000/07/11 19:17:44 deraadt Exp $");
d245 1
a245 1
		keyword = s;
@


1.41
log
@disable FallBackToRsh by default
@
text
@d17 1
a17 1
RCSID("$OpenBSD: readconf.c,v 1.40 2000/07/10 16:27:05 ho Exp $");
a166 4
/* Characters considered whitespace in strsep calls. */
#define WHITESPACE " \t\r\n="


d240 7
a246 3
	/* Skip leading whitespace. */
	s = line + strspn(line, WHITESPACE);
	if (!*s || *s == '\n' || *s == '#')
a248 2
	/* Get the keyword. (Each line is supposed to begin with a keyword). */
	keyword = strsep(&s, WHITESPACE);
d259 1
a259 1
		arg = strsep(&s, WHITESPACE);
d345 1
a345 1
		arg = strsep(&s, WHITESPACE);
d380 1
a380 1
		arg = strsep(&s, WHITESPACE);
d405 1
a405 1
		arg = strsep(&s, WHITESPACE);
d435 1
a435 1
		while ((arg = strsep(&s, WHITESPACE)) != NULL && *arg != '\0') {
d449 1
a449 1
		arg = strsep(&s, WHITESPACE);
d469 1
a469 1
		arg = strsep(&s, WHITESPACE);
d481 1
a481 1
		arg = strsep(&s, WHITESPACE);
d493 1
a493 1
		arg = strsep(&s, WHITESPACE);
d506 1
a506 1
		arg = strsep(&s, WHITESPACE);
d516 1
a516 1
		arg = strsep(&s, WHITESPACE);
d523 1
a523 1
		arg = strsep(&s, WHITESPACE);
d535 1
a535 1
		arg = strsep(&s, WHITESPACE);
d542 1
a542 1
		arg = strsep(&s, WHITESPACE);
d555 1
a555 1
		while ((arg = strsep(&s, WHITESPACE)) != NULL && *arg != '\0')
d561 1
a561 1
		/* Avoid garbage check below, as strsep is done. */
d566 1
a566 1
		arg = strsep(&s, WHITESPACE);
d591 1
a591 1
	if ((arg = strsep(&s, WHITESPACE)) != NULL && *arg != '\0')
@


1.40
log
@Get the correct message on errors. (niels@@ ok)
@
text
@d17 1
a17 1
RCSID("$OpenBSD: readconf.c,v 1.39 2000/07/09 01:27:33 ho Exp $");
d742 1
a742 1
		options->fallback_to_rsh = 1;
@


1.39
log
@Better conditions for strsep() ending.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: readconf.c,v 1.38 2000/07/08 23:17:31 provos Exp $");
d262 1
a262 1
		if (!arg)
d348 1
a348 1
		if (!arg)
d383 1
a383 1
		if (!arg)
d408 1
a408 1
		if (!arg)
d437 1
a437 1
		while ((arg = strsep(&s, WHITESPACE)) != NULL) {
d452 1
a452 1
		if (!arg)
d472 1
a472 1
		if (!arg)
d484 1
a484 1
		if (!arg)
d496 1
a496 1
		if (!arg)
d519 1
a519 1
		if (!arg)
d526 1
a526 1
		if (!arg)
d538 1
a538 1
		if (!arg)
d545 1
a545 1
		if (!arg)
d557 1
a557 1
		while ((arg = strsep(&s, WHITESPACE)) != NULL)
d563 1
a563 1
		/* Avoid garbage check below, as strsep already returned NULL. */
d569 1
a569 1
		if (!arg)
@


1.38
log
@replace strtok with strsep; from David Young <dyoung@@onthejob.net>
@
text
@d17 1
a17 1
RCSID("$OpenBSD: readconf.c,v 1.37 2000/06/20 01:39:43 markus Exp $");
d593 5
a597 3
	if (strsep(&s, WHITESPACE) != NULL)
		fatal("%.200s line %d: garbage at end of line.",
		      filename, linenum);
@


1.37
log
@OpenBSD tag
@
text
@d17 1
a17 1
RCSID("$OpenBSD: readconf.c,v 1.36 2000/06/18 00:57:48 deraadt Exp $");
d167 1
a167 1
/* Characters considered whitespace in strtok calls. */
d240 1
a240 1
	char buf[256], *cp, *string, **charptr, *cp2;
d245 2
a246 2
	cp = line + strspn(line, WHITESPACE);
	if (!*cp || *cp == '\n' || *cp == '#')
d250 2
a251 2
	cp = strtok(cp, WHITESPACE);
	opcode = parse_token(cp, filename, linenum);
d261 2
a262 2
		cp = strtok(NULL, WHITESPACE);
		if (!cp)
d265 1
a265 1
		if (strcmp(cp, "yes") == 0 || strcmp(cp, "true") == 0)
d267 1
a267 1
		else if (strcmp(cp, "no") == 0 || strcmp(cp, "false") == 0)
d347 2
a348 2
		cp = strtok(NULL, WHITESPACE);
		if (!cp)
d352 1
a352 1
		if (strcmp(cp, "yes") == 0 || strcmp(cp, "true") == 0)
d354 1
a354 1
		else if (strcmp(cp, "no") == 0 || strcmp(cp, "false") == 0)
d356 1
a356 1
		else if (strcmp(cp, "ask") == 0)
d382 2
a383 2
		cp = strtok(NULL, WHITESPACE);
		if (!cp)
d395 1
a395 1
			*charptr = xstrdup(cp);
d407 2
a408 2
		cp = strtok(NULL, WHITESPACE);
		if (!cp)
d411 1
a411 1
			*charptr = xstrdup(cp);
d437 2
a438 2
		while ((cp = strtok(NULL, WHITESPACE)) != NULL) {
			string = xrealloc(string, strlen(string) + strlen(cp) + 2);
d440 1
a440 1
			strcat(string, cp);
d451 2
a452 2
		cp = strtok(NULL, WHITESPACE);
		if (!cp)
d454 1
a454 1
		if (cp[0] < '0' || cp[0] > '9')
d458 2
a459 2
		value = strtol(cp, &cp2, 0);
		if (cp == cp2)
d471 2
a472 2
		cp = strtok(NULL, WHITESPACE);
		if (!cp)
d474 1
a474 1
		value = cipher_number(cp);
d477 1
a477 1
			      filename, linenum, cp ? cp : "<NONE>");
d483 2
a484 2
		cp = strtok(NULL, WHITESPACE);
		if (!cp)
d486 1
a486 1
		if (!ciphers_valid(cp))
d488 1
a488 1
			      filename, linenum, cp ? cp : "<NONE>");
d490 1
a490 1
			options->ciphers = xstrdup(cp);
d495 2
a496 2
		cp = strtok(NULL, WHITESPACE);
		if (!cp)
d498 1
a498 1
		value = proto_spec(cp);
d501 1
a501 1
			      filename, linenum, cp ? cp : "<NONE>");
d508 2
a509 2
		cp = strtok(NULL, WHITESPACE);
		value = log_level_number(cp);
d512 1
a512 1
			      filename, linenum, cp ? cp : "<NONE>");
d518 2
a519 2
		cp = strtok(NULL, WHITESPACE);
		if (!cp)
d521 1
a521 1
		if (cp[0] < '0' || cp[0] > '9')
d524 3
a526 3
		fwd_port = atoi(cp);
		cp = strtok(NULL, WHITESPACE);
		if (!cp)
d529 1
a529 1
		if (sscanf(cp, "%255[^:]:%hu", buf, &fwd_host_port) != 2)
d537 2
a538 2
		cp = strtok(NULL, WHITESPACE);
		if (!cp)
d540 1
a540 1
		if (cp[0] < '0' || cp[0] > '9')
d543 3
a545 3
		fwd_port = atoi(cp);
		cp = strtok(NULL, WHITESPACE);
		if (!cp)
d548 1
a548 1
		if (sscanf(cp, "%255[^:]:%hu", buf, &fwd_host_port) != 2)
d557 3
a559 3
		while ((cp = strtok(NULL, WHITESPACE)) != NULL)
			if (match_pattern(host, cp)) {
				debug("Applying options for %.100s", cp);
d563 1
a563 1
		/* Avoid garbage check below, as strtok already returned NULL. */
d568 2
a569 2
		cp = strtok(NULL, WHITESPACE);
		if (!cp)
d571 6
a576 6
		if (cp[0] == '^' && cp[2] == 0 &&
		    (unsigned char) cp[1] >= 64 && (unsigned char) cp[1] < 128)
			value = (unsigned char) cp[1] & 31;
		else if (strlen(cp) == 1)
			value = (unsigned char) cp[0];
		else if (strcmp(cp, "none") == 0)
d593 1
a593 1
	if (strtok(NULL, WHITESPACE) != NULL)
@


1.36
log
@include = in WHITESPACE; markus ok
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.35 2000/05/31 09:20:38 markus Exp $");
@


1.35
log
@typo, unused
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.34 2000/05/31 06:36:40 markus Exp $");
d168 1
a168 1
#define WHITESPACE " \t\r\n"
@


1.34
log
@xauth_location support; pr 1234
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.33 2000/05/29 20:20:46 markus Exp $");
d711 1
a711 1
		options->xauth_location == XAUTH_PATH;
@


1.33
log
@forwardagent defaults to no, add ssh -A
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.32 2000/05/22 18:42:01 markus Exp $");
d95 1
a95 1
	oSkeyAuthentication,
d119 1
d400 4
d652 1
d709 4
@


1.32
log
@check strtok() != NULL; ok niels@@
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.31 2000/05/08 17:12:15 markus Exp $");
d700 1
a700 1
		options->forward_agent = 1;
@


1.31
log
@complain about invalid ciphers in SSH1 (e.g. arcfour is SSH2 only)
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.30 2000/05/06 17:45:36 markus Exp $");
d467 2
d479 2
d491 2
@


1.31.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.35 2000/05/31 09:20:38 markus Exp $");
d95 1
a95 1
	oSkeyAuthentication, oXAuthLocation,
a118 1
	{ "xauthlocation", oXAuthLocation },
a398 4
	case oXAuthLocation:
		charptr=&options->xauth_location;
		goto parse_string;

a466 2
		if (!cp)
			fatal("%.200s line %d: Missing argument.", filename, linenum);
a476 2
		if (!cp)
			fatal("%.200s line %d: Missing argument.", filename, linenum);
a486 2
		if (!cp)
			fatal("%.200s line %d: Missing argument.", filename, linenum);
a640 1
	options->xauth_location = NULL;
d694 1
a694 1
		options->forward_agent = 0;
a696 4
#ifdef XAUTH_PATH
	if (options->xauth_location == NULL)
		options->xauth_location = XAUTH_PATH;
#endif /* XAUTH_PATH */
@


1.31.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d17 1
a17 1
RCSID("$OpenBSD: readconf.c,v 1.45 2000/08/02 17:27:04 provos Exp $");
d167 4
d240 1
a240 1
	char buf[256], *s, *string, **charptr, *endofnumber, *keyword, *arg;
d244 3
a246 7
	s = line;
	/* Get the keyword. (Each line is supposed to begin with a keyword). */
	keyword = strdelim(&s);
	/* Ignore leading whitespace. */
	if (*keyword == '\0')
		keyword = strdelim(&s);
	if (!*keyword || *keyword == '\n' || *keyword == '#')
d249 3
a251 1
	opcode = parse_token(keyword, filename, linenum);
d261 2
a262 2
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
d265 1
a265 1
		if (strcmp(arg, "yes") == 0 || strcmp(arg, "true") == 0)
d267 1
a267 1
		else if (strcmp(arg, "no") == 0 || strcmp(arg, "false") == 0)
d347 2
a348 2
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
d352 1
a352 1
		if (strcmp(arg, "yes") == 0 || strcmp(arg, "true") == 0)
d354 1
a354 1
		else if (strcmp(arg, "no") == 0 || strcmp(arg, "false") == 0)
d356 1
a356 1
		else if (strcmp(arg, "ask") == 0)
d382 2
a383 2
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
d395 1
a395 1
			*charptr = xstrdup(arg);
d407 2
a408 2
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
d411 1
a411 1
			*charptr = xstrdup(arg);
d437 2
a438 2
		while ((arg = strdelim(&s)) != NULL && *arg != '\0') {
			string = xrealloc(string, strlen(string) + strlen(arg) + 2);
d440 1
a440 1
			strcat(string, arg);
d451 2
a452 2
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
d454 1
a454 1
		if (arg[0] < '0' || arg[0] > '9')
d458 2
a459 2
		value = strtol(arg, &endofnumber, 0);
		if (arg == endofnumber)
d471 2
a472 2
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
d474 1
a474 1
		value = cipher_number(arg);
d477 1
a477 1
			      filename, linenum, arg ? arg : "<NONE>");
d483 2
a484 2
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
d486 1
a486 1
		if (!ciphers_valid(arg))
d488 1
a488 1
			      filename, linenum, arg ? arg : "<NONE>");
d490 1
a490 1
			options->ciphers = xstrdup(arg);
d495 2
a496 2
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
d498 1
a498 1
		value = proto_spec(arg);
d501 1
a501 1
			      filename, linenum, arg ? arg : "<NONE>");
d508 2
a509 2
		arg = strdelim(&s);
		value = log_level_number(arg);
d512 1
a512 1
			      filename, linenum, arg ? arg : "<NONE>");
d518 2
a519 2
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
d521 1
a521 1
		if (arg[0] < '0' || arg[0] > '9')
d524 3
a526 3
		fwd_port = atoi(arg);
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
d529 1
a529 1
		if (sscanf(arg, "%255[^:]:%hu", buf, &fwd_host_port) != 2)
d537 2
a538 2
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
d540 1
a540 1
		if (arg[0] < '0' || arg[0] > '9')
d543 3
a545 3
		fwd_port = atoi(arg);
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
d548 1
a548 1
		if (sscanf(arg, "%255[^:]:%hu", buf, &fwd_host_port) != 2)
d557 3
a559 3
		while ((arg = strdelim(&s)) != NULL && *arg != '\0')
			if (match_pattern(host, arg)) {
				debug("Applying options for %.100s", arg);
d563 1
a563 1
		/* Avoid garbage check below, as strdelim is done. */
d568 2
a569 2
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
d571 6
a576 6
		if (arg[0] == '^' && arg[2] == 0 &&
		    (unsigned char) arg[1] >= 64 && (unsigned char) arg[1] < 128)
			value = (unsigned char) arg[1] & 31;
		else if (strlen(arg) == 1)
			value = (unsigned char) arg[0];
		else if (strcmp(arg, "none") == 0)
d593 3
a595 5
	if ((arg = strdelim(&s)) != NULL && *arg != '\0')
	{
		fatal("%.200s line %d: garbage at end of line; \"%.200s\".",
		      filename, linenum, arg);
	}
d740 1
a740 1
		options->fallback_to_rsh = 0;
@


1.31.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a13 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d17 1
a17 1
RCSID("$OpenBSD: readconf.c,v 1.49 2000/10/11 20:27:23 markus Exp $");
d20 1
d108 1
a108 2
	oGlobalKnownHostsFile2, oUserKnownHostsFile2, oDSAAuthentication,
	oKbdInteractiveAuthentication, oKbdInteractiveDevices
a123 2
	{ "kbdinteractiveauthentication", oKbdInteractiveAuthentication },
	{ "kbdinteractivedevices", oKbdInteractiveDevices },
a292 8
	case oKbdInteractiveAuthentication:
		intptr = &options->kbd_interactive_authentication;
		goto parse_flag;

	case oKbdInteractiveDevices:
		charptr = &options->kbd_interactive_devices;
		goto parse_string;

a666 2
	options->kbd_interactive_authentication = -1;
	options->kbd_interactive_devices = NULL;
a736 2
	if (options->kbd_interactive_authentication == -1)
		options->kbd_interactive_authentication = 0;
@


1.31.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.62 2001/02/11 12:59:25 markus Exp $");
d18 2
a21 8
#include "cipher.h"
#include "pathnames.h"
#include "log.h"
#include "readconf.h"
#include "match.h"
#include "misc.h"
#include "kex.h"
#include "mac.h"
d71 1
a71 1
     ForwardX11 no
d92 1
a92 1
	oChallengeResponseAuthentication, oXAuthLocation,
d103 4
a106 4
	oCompressionLevel, oKeepAlives, oNumberOfPasswordPrompts,
	oUsePrivilegedPort, oLogLevel, oCiphers, oProtocol, oMacs,
	oGlobalKnownHostsFile2, oUserKnownHostsFile2, oPubkeyAuthentication,
	oKbdInteractiveAuthentication, oKbdInteractiveDevices, oHostKeyAlias
d125 2
a126 5
	{ "pubkeyauthentication", oPubkeyAuthentication },
	{ "dsaauthentication", oPubkeyAuthentication },		    /* alias */
	{ "challengeresponseauthentication", oChallengeResponseAuthentication },
	{ "skeyauthentication", oChallengeResponseAuthentication }, /* alias */
	{ "tisauthentication", oChallengeResponseAuthentication },  /* alias */
d137 1
a137 1
	{ "identityfile2", oIdentityFile },			/* alias */
a138 1
	{ "hostkeyalias", oHostKeyAlias },
a142 1
	{ "macs", oMacs },
d162 1
d215 1
a215 1
	u_int i;
d246 1
a246 1
	if (keyword == NULL || !*keyword || *keyword == '\n' || *keyword == '#')
d301 2
a302 2
	case oPubkeyAuthentication:
		intptr = &options->pubkey_authentication;
d313 4
a316 2
	case oChallengeResponseAuthentication:
		intptr = &options->challenge_reponse_authentication;
d355 1
a355 1
			fatal("%.200s line %d: Missing yes/no/ask argument.",
d387 1
d392 3
a394 1
			intptr = &options->num_identity_files;
d398 3
a400 1
			charptr =  &options->identity_files[*intptr];
a439 4
	case oHostKeyAlias:
		charptr = &options->host_key_alias;
		goto parse_string;

a498 11
	case oMacs:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (!mac_valid(arg))
			fatal("%.200s line %d: Bad SSH2 Mac spec '%s'.",
			      filename, linenum, arg ? arg : "<NONE>");
		if (*activep && options->macs == NULL)
			options->macs = xstrdup(arg);
		break;

d578 2
a579 2
		    (u_char) arg[1] >= 64 && (u_char) arg[1] < 128)
			value = (u_char) arg[1] & 31;
d581 1
a581 1
			value = (u_char) arg[0];
d599 2
a600 1
	if ((arg = strdelim(&s)) != NULL && *arg != '\0') {
d665 2
a666 2
	options->pubkey_authentication = -1;
	options->challenge_reponse_authentication = -1;
a690 1
	options->macs = NULL;
d693 1
a694 1
	options->host_key_alias = NULL;
a714 2
	int len;

d731 4
a734 4
	if (options->pubkey_authentication == -1)
		options->pubkey_authentication = 1;
	if (options->challenge_reponse_authentication == -1)
		options->challenge_reponse_authentication = 0;
d748 1
a748 1
		options->kbd_interactive_authentication = 1;
a776 1
	/* options->macs, default set in myproposals.h */
d780 10
a789 14
		if (options->protocol & SSH_PROTO_1) {
			len = 2 + strlen(_PATH_SSH_CLIENT_IDENTITY) + 1;
			options->identity_files[options->num_identity_files] =
			    xmalloc(len);
			snprintf(options->identity_files[options->num_identity_files++],
			    len, "~/%.100s", _PATH_SSH_CLIENT_IDENTITY);
		}
		if (options->protocol & SSH_PROTO_2) {
			len = 2 + strlen(_PATH_SSH_CLIENT_ID_DSA) + 1;
			options->identity_files[options->num_identity_files] =
			    xmalloc(len);
			snprintf(options->identity_files[options->num_identity_files++],
			    len, "~/%.100s", _PATH_SSH_CLIENT_ID_DSA);
		}
d794 1
a794 1
		options->system_hostfile = _PATH_SSH_SYSTEM_HOSTFILE;
d796 1
a796 1
		options->user_hostfile = _PATH_SSH_USER_HOSTFILE;
d798 1
a798 1
		options->system_hostfile2 = _PATH_SSH_SYSTEM_HOSTFILE2;
d800 1
a800 1
		options->user_hostfile2 = _PATH_SSH_USER_HOSTFILE2;
a805 1
	/* options->host_key_alias should not be set by default */
@


1.31.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.68 2001/03/19 17:07:23 markus Exp $");
d112 1
a112 2
	oKbdInteractiveAuthentication, oKbdInteractiveDevices, oHostKeyAlias,
	oPreferredAuthentications
a173 1
	{ "preferredauthentications", oPreferredAuthentications },
d189 1
a189 1
		fatal("Privileged ports can only be forwarded by root.");
a446 4
	case oPreferredAuthentications:
		charptr = &options->preferred_authentications;
		goto parse_string;

d535 1
a535 1
			fatal("%.200s line %d: unsupported log level '%s'",
d660 1
a660 1
		fatal("%s: terminating, %d bad configuration options",
a722 1
	options->preferred_authentications = NULL;
d746 1
a746 1
		options->use_privileged_port = 0;
a808 6
			len = 2 + strlen(_PATH_SSH_CLIENT_ID_RSA) + 1;
			options->identity_files[options->num_identity_files] =
			    xmalloc(len);
			snprintf(options->identity_files[options->num_identity_files++],
			    len, "~/%.100s", _PATH_SSH_CLIENT_ID_RSA);

a831 1
	/* options->preferred_authentications will be set in ssh */
@


1.30
log
@add DSAAuthetication option to ssh/sshd, document SSH2 in sshd.8
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.29 2000/05/02 22:18:04 markus Exp $");
d478 1
a478 1
			fatal("%.200s line %d: Bad cipher spec '%s'.",
d748 1
@


1.29
log
@default DSA key file ~/.ssh/id_dsa
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.28 2000/04/26 22:43:14 markus Exp $");
d108 1
a108 1
	oGlobalKnownHostsFile2, oUserKnownHostsFile2
d124 1
d294 4
d645 1
d705 2
@


1.28
log
@ssh/sshd default to proto 1 and 2
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.27 2000/04/26 20:56:29 markus Exp $");
a747 1
#if 0
d750 2
a751 2
			xmalloc(2 + strlen(SSH2_CLIENT_IDENTITY) + 1);
		sprintf(options->identity_files2[0], "~/%.100s", SSH2_CLIENT_IDENTITY);
a753 1
#endif
@


1.27
log
@add DSA pubkey auth and other SSH2 fixes.  use ssh-keygen -[xX]
for trading keys with the real and the original SSH, directly from the
people who invented the SSH protocol.
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.26 2000/04/14 10:30:32 markus Exp $");
d741 1
a741 1
		options->protocol = SSH_PROTO_1;
@


1.26
log
@whitespace cleanup
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.25 2000/04/12 07:45:44 markus Exp $");
d107 2
a108 1
	oUsePrivilegedPort, oLogLevel, oCiphers, oProtocol
d135 1
d150 2
d375 1
d380 4
a383 1
			if (options->num_identity_files >= SSH_MAX_IDENTITY_FILES)
d386 5
a390 1
			options->identity_files[options->num_identity_files++] = xstrdup(cp);
d412 8
d665 1
d672 2
d748 8
d762 4
@


1.25
log
@add Cipher and Protocol options to ssh/sshd, e.g.:
ssh -o 'Protocol 1,2' if you prefer proto 1, ssh -o 'Ciphers arcfour,3des-cbc'
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
RCSID("$Id: readconf.c,v 1.24 2000/03/28 20:31:28 markus Exp $");
d170 1
a170 1
void 
d191 1
a191 1
void 
d210 1
a210 1
static OpCodes 
d570 1
a570 1
void 
d610 1
a610 1
void 
d661 1
a661 1
void 
@


1.24
log
@replace big switch() with function tables (prepare for ssh2)
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.23 2000/02/28 19:51:58 markus Exp $");
d24 1
d107 1
a107 1
	oUsePrivilegedPort, oLogLevel
d138 2
d450 20
d642 2
d717 2
@


1.23
log
@turn off x11-fwd for the client, too.
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.22 1999/12/01 13:59:15 markus Exp $");
d22 1
@


1.22
log
@ports are u_short
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.21 1999/11/24 20:24:09 markus Exp $");
d641 1
a641 1
		options->forward_x11 = 1;
@


1.21
log
@remove dead #ifdef-0-code
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.20 1999/11/24 20:19:37 markus Exp $");
d167 2
a168 2
add_local_forward(Options *options, int port, const char *host,
		  int host_port)
a171 2
	if ((port & 0xffff) != port)
		fatal("Requested forwarding of nonexistent port %d.", port);
d188 2
a189 2
add_remote_forward(Options *options, int port, const char *host,
		   int host_port)
d231 2
a232 1
	int opcode, *intptr, value, fwd_port, fwd_host_port;
d469 1
a469 1
		if (sscanf(cp, "%255[^:]:%d", buf, &fwd_host_port) != 2)
d488 1
a488 1
		if (sscanf(cp, "%255[^:]:%d", buf, &fwd_host_port) != 2)
@


1.20
log
@strcasecmp instead of tolower
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.19 1999/11/24 19:53:49 markus Exp $");
d232 1
a232 1
	char buf[256], *cp, *string, **charptr;
d423 5
a427 11
#if 0
		value = atoi(cp);
#else
		{
			char *ptr;
			/* Octal, decimal, or hex format? */
			value = strtol(cp, &ptr, 0);
			if (cp == ptr)
				fatal("%.200s line %d: Bad number.", filename, linenum);
		}
#endif
@


1.19
log
@KNF, final part 3
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.18 1999/11/24 00:26:02 deraadt Exp $");
d214 1
a214 1
		if (strcmp(cp, keywords[i].name) == 0)
a241 7
	{
		char *t = cp;
		for (; *t != 0; t++)
			if ('A' <= *t && *t <= 'Z')
				*t = *t - 'A' + 'a';	/* tolower */

	}
@


1.18
log
@much more KNF
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.17 1999/11/23 22:25:54 markus Exp $");
d161 4
a164 2
/* Adds a local TCP/IP port forward to options.  Never returns if there
   is an error. */
d184 4
a187 2
/* Adds a remote TCP/IP port forward to options.  Never returns if there
   is an error. */
d203 4
a206 2
/* Returns the number of the token pointed to by cp of length len.
   Never returns if the token is not known. */
d222 4
a225 2
/* Processes a single option line as used in the configuration files.
   This only sets those values that have not already been set. */
d240 1
a240 2
	/* Get the keyword. (Each line is supposed to begin with a
	   keyword). */
d253 2
a254 1
		return -1;	/* don't panic, but count bad options */
d435 2
a436 2
			value = strtol(cp, &ptr, 0);	/* Octal, decimal, or
							   hex format? */
d517 1
a517 2
		/* Avoid garbage check below, as strtok already returned
		   NULL. */
d554 5
a558 3
/* Reads the config file and modifies the options accordingly.  Options should
   already be initialized before this call.  This never returns if there
   is an error.  If the file does not exist, this returns immediately. */
d575 4
a578 2
	/* Mark that we are now processing the options.  This flag is
	   turned on/off by Host specifications. */
d593 6
a598 4
/* Initializes options to special values that indicate that they have not
   yet been set.  Read_config_file will only set options with this value.
   Options are processed in the following order: command line, user config
   file, system config file.  Last, fill_default_options is called. */
d644 4
a647 2
/* Called after processing other sources of option data, this fills those
   options for which no value has been specified with their default values. */
@


1.17
log
@KNF part 1
@
text
@d2 13
a14 13

readconf.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Sat Apr 22 00:03:10 1995 ylo

Functions for reading the configuration files.

*/
d17 1
a17 1
RCSID("$Id: readconf.c,v 1.16 1999/11/22 21:52:41 markus Exp $");
@


1.16
log
@tranfer s/key challenge/response data in SSH_SMSG_AUTH_TIS_CHALLENGE
messages. allows use of s/key in windows (ttssh, securecrt) and
ssh-1.2.27 clients without 'ssh -v', ok: niels@@
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.15 1999/11/19 16:04:17 markus Exp $");
d89 5
a93 6
typedef enum
{
  oBadOption,
  oForwardAgent, oForwardX11, oGatewayPorts, oRhostsAuthentication,
  oPasswordAuthentication, oRSAAuthentication, oFallBackToRsh, oUseRsh,
  oSkeyAuthentication,
d95 1
a95 1
  oKerberosAuthentication,
d98 1
a98 1
  oKerberosTgtPassing, oAFSTokenPassing,
d100 6
a105 6
  oIdentityFile, oHostName, oPort, oCipher, oRemoteForward, oLocalForward, 
  oUser, oHost, oEscapeChar, oRhostsRSAAuthentication, oProxyCommand,
  oGlobalKnownHostsFile, oUserKnownHostsFile, oConnectionAttempts,
  oBatchMode, oCheckHostIP, oStrictHostKeyChecking, oCompression,
  oCompressionLevel, oKeepAlives, oNumberOfPasswordPrompts, oTISAuthentication,
  oUsePrivilegedPort, oLogLevel
d110 12
a121 14
static struct
{
  const char *name;
  OpCodes opcode;
} keywords[] =
{
  { "forwardagent", oForwardAgent },
  { "forwardx11", oForwardX11 },
  { "gatewayports", oGatewayPorts },
  { "useprivilegedport", oUsePrivilegedPort },
  { "rhostsauthentication", oRhostsAuthentication },
  { "passwordauthentication", oPasswordAuthentication },
  { "rsaauthentication", oRSAAuthentication },
  { "skeyauthentication", oSkeyAuthentication },
d123 1
a123 1
  { "kerberosauthentication", oKerberosAuthentication },
d126 2
a127 2
  { "kerberostgtpassing", oKerberosTgtPassing },
  { "afstokenpassing", oAFSTokenPassing },
d129 26
a154 26
  { "fallbacktorsh", oFallBackToRsh },
  { "usersh", oUseRsh },
  { "identityfile", oIdentityFile },
  { "hostname", oHostName },
  { "proxycommand", oProxyCommand },
  { "port", oPort },
  { "cipher", oCipher },
  { "remoteforward", oRemoteForward },
  { "localforward", oLocalForward },
  { "user", oUser },
  { "host", oHost },
  { "escapechar", oEscapeChar },
  { "rhostsrsaauthentication", oRhostsRSAAuthentication },
  { "globalknownhostsfile", oGlobalKnownHostsFile },
  { "userknownhostsfile", oUserKnownHostsFile },
  { "connectionattempts", oConnectionAttempts },
  { "batchmode", oBatchMode },
  { "checkhostip", oCheckHostIP },
  { "stricthostkeychecking", oStrictHostKeyChecking },
  { "compression", oCompression },
  { "compressionlevel", oCompressionLevel },
  { "keepalive", oKeepAlives },
  { "numberofpasswordprompts", oNumberOfPasswordPrompts },
  { "tisauthentication", oTISAuthentication },
  { "loglevel", oLogLevel },
  { NULL, 0 }
d164 3
a166 2
void add_local_forward(Options *options, int port, const char *host,
		       int host_port)
d168 12
a179 12
  Forward *fwd;
  extern uid_t original_real_uid;
  if ((port & 0xffff) != port)
    fatal("Requested forwarding of nonexistent port %d.", port);
  if (port < IPPORT_RESERVED && original_real_uid != 0)
    fatal("Privileged ports can only be forwarded by root.\n");
  if (options->num_local_forwards >= SSH_MAX_FORWARDS_PER_DIRECTION)
    fatal("Too many local forwards (max %d).", SSH_MAX_FORWARDS_PER_DIRECTION);
  fwd = &options->local_forwards[options->num_local_forwards++];
  fwd->port = port;
  fwd->host = xstrdup(host);
  fwd->host_port = host_port;
d185 3
a187 2
void add_remote_forward(Options *options, int port, const char *host,
		       int host_port)
d189 8
a196 8
  Forward *fwd;
  if (options->num_remote_forwards >= SSH_MAX_FORWARDS_PER_DIRECTION)
    fatal("Too many remote forwards (max %d).", 
	  SSH_MAX_FORWARDS_PER_DIRECTION);
  fwd = &options->remote_forwards[options->num_remote_forwards++];
  fwd->port = port;
  fwd->host = xstrdup(host);
  fwd->host_port = host_port;
d202 2
a203 1
static OpCodes parse_token(const char *cp, const char *filename, int linenum)
d205 1
a205 1
  unsigned int i;
d207 7
a213 7
  for (i = 0; keywords[i].name; i++)
    if (strcmp(cp, keywords[i].name) == 0)
      return keywords[i].opcode;

  fprintf(stderr, "%s: line %d: Bad configuration option: %s\n", 
	  filename, linenum, cp);
  return oBadOption;
d221 2
a222 2
			 char *line, const char *filename, int linenum,
			 int *activep)
d224 2
a225 2
  char buf[256], *cp, *string, **charptr;
  int opcode, *intptr, value, fwd_port, fwd_host_port;
d227 71
a297 71
  /* Skip leading whitespace. */
  cp = line + strspn(line, WHITESPACE);
  if (!*cp || *cp == '\n' || *cp == '#')
    return 0;

  /* Get the keyword. (Each line is supposed to begin with a keyword). */
  cp = strtok(cp, WHITESPACE);
  {
    char *t = cp;
    for (; *t != 0; t++)
      if ('A' <= *t && *t <= 'Z')
	*t = *t - 'A' + 'a';	/* tolower */
      
  }
  opcode = parse_token(cp, filename, linenum);

  switch (opcode)
    {
    case oBadOption:
      return -1;		/* don't panic, but count bad options */
      /*NOTREACHED*/
    case oForwardAgent:
      intptr = &options->forward_agent;
    parse_flag:
      cp = strtok(NULL, WHITESPACE);
      if (!cp)
	fatal("%.200s line %d: Missing yes/no argument.", filename, linenum);
      value = 0; /* To avoid compiler warning... */
      if (strcmp(cp, "yes") == 0 || strcmp(cp, "true") == 0)
	value = 1;
      else if (strcmp(cp, "no") == 0 || strcmp(cp, "false") == 0)
	value = 0;
      else
	fatal("%.200s line %d: Bad yes/no argument.", filename, linenum);
      if (*activep && *intptr == -1)
	*intptr = value;
      break;
      
    case oForwardX11:
      intptr = &options->forward_x11;
      goto parse_flag;

    case oGatewayPorts:
      intptr = &options->gateway_ports;
      goto parse_flag;
      
    case oUsePrivilegedPort:
      intptr = &options->use_privileged_port;
      goto parse_flag;
      
    case oRhostsAuthentication:
      intptr = &options->rhosts_authentication;
      goto parse_flag;
      
    case oPasswordAuthentication:
      intptr = &options->password_authentication;
      goto parse_flag;
      
    case oRSAAuthentication:
      intptr = &options->rsa_authentication;
      goto parse_flag;
      
    case oRhostsRSAAuthentication:
      intptr = &options->rhosts_rsa_authentication;
      goto parse_flag;

    case oTISAuthentication:
      /* fallthrough, there is no difference on the client side */
    case oSkeyAuthentication:
      intptr = &options->skey_authentication;
      goto parse_flag;
d300 3
a302 3
    case oKerberosAuthentication:
      intptr = &options->kerberos_authentication;
      goto parse_flag;
d306 7
a312 7
    case oKerberosTgtPassing:
      intptr = &options->kerberos_tgt_passing;
      goto parse_flag;

    case oAFSTokenPassing:
      intptr = &options->afs_token_passing;
      goto parse_flag;
d314 108
a421 110
      
    case oFallBackToRsh:
      intptr = &options->fallback_to_rsh;
      goto parse_flag;
      
    case oUseRsh:
      intptr = &options->use_rsh;
      goto parse_flag;

    case oBatchMode:
      intptr = &options->batch_mode;
      goto parse_flag;

    case oCheckHostIP:
      intptr = &options->check_host_ip;
      goto parse_flag;

    case oStrictHostKeyChecking:
      intptr = &options->strict_host_key_checking;
      cp = strtok(NULL, WHITESPACE);
      if (!cp)
	fatal("%.200s line %d: Missing yes/no argument.",
	      filename, linenum);
      value = 0; /* To avoid compiler warning... */
      if (strcmp(cp, "yes") == 0 || strcmp(cp, "true") == 0)
	value = 1;
      else if (strcmp(cp, "no") == 0 || strcmp(cp, "false") == 0)
	value = 0;
      else if (strcmp(cp, "ask") == 0)
	value = 2;
      else
	fatal("%.200s line %d: Bad yes/no/ask argument.", filename, linenum);
      if (*activep && *intptr == -1)
	*intptr = value;
      break;
      
    case oCompression:
      intptr = &options->compression;
      goto parse_flag;

    case oKeepAlives:
      intptr = &options->keepalives;
      goto parse_flag;

    case oNumberOfPasswordPrompts:
      intptr = &options->number_of_password_prompts;
      goto parse_int;

    case oCompressionLevel:
      intptr = &options->compression_level;
      goto parse_int;

    case oIdentityFile:
      cp = strtok(NULL, WHITESPACE);
      if (!cp)
	fatal("%.200s line %d: Missing argument.", filename, linenum);
      if (*activep)
	{
	  if (options->num_identity_files >= SSH_MAX_IDENTITY_FILES)
	    fatal("%.200s line %d: Too many identity files specified (max %d).",
		  filename, linenum, SSH_MAX_IDENTITY_FILES);
	  options->identity_files[options->num_identity_files++] = xstrdup(cp);
	}
      break;
      
    case oUser:
      charptr = &options->user;
    parse_string:
      cp = strtok(NULL, WHITESPACE);
      if (!cp)
	fatal("%.200s line %d: Missing argument.", filename, linenum);
      if (*activep && *charptr == NULL)
	*charptr = xstrdup(cp);
      break;
      
    case oGlobalKnownHostsFile:
      charptr = &options->system_hostfile;
      goto parse_string;
      
    case oUserKnownHostsFile:
      charptr = &options->user_hostfile;
      goto parse_string;

    case oHostName:
      charptr = &options->hostname;
      goto parse_string;
      
    case oProxyCommand:
      charptr = &options->proxy_command;
      string = xstrdup("");
      while ((cp = strtok(NULL, WHITESPACE)) != NULL)
	{
	  string = xrealloc(string, strlen(string) + strlen(cp) + 2);
	  strcat(string, " ");
	  strcat(string, cp);
	}
      if (*activep && *charptr == NULL)
	*charptr = string;
      else
	xfree(string);
      return 0;

    case oPort:
      intptr = &options->port;
    parse_int:
      cp = strtok(NULL, WHITESPACE);
      if (!cp)
	fatal("%.200s line %d: Missing argument.", filename, linenum);
      if (cp[0] < '0' || cp[0] > '9')
	fatal("%.200s line %d: Bad number.", filename, linenum);
d423 1
a423 1
      value = atoi(cp);
d425 7
a431 6
      {
	char *ptr;
	value = strtol(cp, &ptr, 0); /* Octal, decimal, or hex format? */
	if (cp == ptr)
	  fatal("%.200s line %d: Bad number.", filename, linenum);	    
      }
d433 111
a543 114
      if (*activep && *intptr == -1)
	*intptr = value;
      break;
      
    case oConnectionAttempts:
      intptr = &options->connection_attempts;
      goto parse_int;

    case oCipher:
      intptr = &options->cipher;
      cp = strtok(NULL, WHITESPACE);
      value = cipher_number(cp);
      if (value == -1)
	fatal("%.200s line %d: Bad cipher '%s'.",
	      filename, linenum, cp ? cp : "<NONE>");
      if (*activep && *intptr == -1)
	*intptr = value;
      break;

    case oLogLevel:
      intptr = (int *)&options->log_level;
      cp = strtok(NULL, WHITESPACE);
      value = log_level_number(cp);
      if (value == (LogLevel)-1)
        fatal("%.200s line %d: unsupported log level '%s'\n",
	      filename, linenum, cp ? cp : "<NONE>");
      if (*activep && (LogLevel)*intptr == -1)
	*intptr = (LogLevel)value;
      break;
      
    case oRemoteForward:
      cp = strtok(NULL, WHITESPACE);
      if (!cp)
	fatal("%.200s line %d: Missing argument.", filename, linenum);
      if (cp[0] < '0' || cp[0] > '9')
	fatal("%.200s line %d: Badly formatted port number.", 
	      filename, linenum);
      fwd_port = atoi(cp);
      cp = strtok(NULL, WHITESPACE);
      if (!cp)
	fatal("%.200s line %d: Missing second argument.", 
	      filename, linenum);
      if (sscanf(cp, "%255[^:]:%d", buf, &fwd_host_port) != 2)
	fatal("%.200s line %d: Badly formatted host:port.", 
	      filename, linenum);
      if (*activep)
	add_remote_forward(options, fwd_port, buf, fwd_host_port);
      break;
      
    case oLocalForward:
      cp = strtok(NULL, WHITESPACE);
      if (!cp)
	fatal("%.200s line %d: Missing argument.", filename, linenum);
      if (cp[0] < '0' || cp[0] > '9')
	fatal("%.200s line %d: Badly formatted port number.", 
	      filename, linenum);
      fwd_port = atoi(cp);
      cp = strtok(NULL, WHITESPACE);
      if (!cp)
	fatal("%.200s line %d: Missing second argument.", 
	      filename, linenum);
      if (sscanf(cp, "%255[^:]:%d", buf, &fwd_host_port) != 2)
	fatal("%.200s line %d: Badly formatted host:port.", 
	      filename, linenum);
      if (*activep)
	add_local_forward(options, fwd_port, buf, fwd_host_port);
      break;
      
    case oHost:
      *activep = 0;
      while ((cp = strtok(NULL, WHITESPACE)) != NULL)
	if (match_pattern(host, cp))
	  {
	    debug("Applying options for %.100s", cp);
	    *activep = 1;
	    break;
	  }
      /* Avoid garbage check below, as strtok already returned NULL. */
      return 0;

    case oEscapeChar:
      intptr = &options->escape_char;
      cp = strtok(NULL, WHITESPACE);
      if (!cp)
	fatal("%.200s line %d: Missing argument.", filename, linenum);
      if (cp[0] == '^' && cp[2] == 0 && 
	  (unsigned char)cp[1] >= 64 && (unsigned char)cp[1] < 128)
	value = (unsigned char)cp[1] & 31;
      else
	if (strlen(cp) == 1)
	  value = (unsigned char)cp[0];
	else
	  if (strcmp(cp, "none") == 0)
	    value = -2;
	  else
	    {
	      fatal("%.200s line %d: Bad escape character.", 
		    filename, linenum);
	      /*NOTREACHED*/
	      value = 0; /* Avoid compiler warning. */
	    }
      if (*activep && *intptr == -1)
	*intptr = value;
      break;
      
    default:
      fatal("process_config_line: Unimplemented opcode %d", opcode);
    }
  
  /* Check that there is no garbage at end of line. */
  if (strtok(NULL, WHITESPACE) != NULL)
    fatal("%.200s line %d: garbage at end of line.",
	  filename, linenum);
  return 0;
d551 2
a552 1
void read_config_file(const char *filename, const char *host, Options *options)
d554 26
a579 27
  FILE *f;
  char line[1024];
  int active, linenum;
  int bad_options = 0;

  /* Open the file. */
  f = fopen(filename, "r");
  if (!f)
    return;

  debug("Reading configuration data %.200s", filename);

  /* Mark that we are now processing the options.  This flag is turned on/off
     by Host specifications. */
  active = 1;
  linenum = 0;
  while (fgets(line, sizeof(line), f))
    {
      /* Update line number counter. */
      linenum++;
      if (process_config_line(options, host, line, filename, linenum, &active) != 0)
	bad_options++;
    }
  fclose(f);
  if (bad_options > 0)
    fatal("%s: terminating, %d bad configuration options\n", 
          filename, bad_options);
d587 2
a588 1
void initialize_options(Options *options)
d590 8
a597 8
  memset(options, 'X', sizeof(*options));
  options->forward_agent = -1;
  options->forward_x11 = -1;
  options->gateway_ports = -1;
  options->use_privileged_port = -1;
  options->rhosts_authentication = -1;
  options->rsa_authentication = -1;
  options->skey_authentication = -1;
d599 1
a599 1
  options->kerberos_authentication = -1;
d602 2
a603 2
  options->kerberos_tgt_passing = -1;
  options->afs_token_passing = -1;
d605 24
a628 24
  options->password_authentication = -1;
  options->rhosts_rsa_authentication = -1;
  options->fallback_to_rsh = -1;
  options->use_rsh = -1;
  options->batch_mode = -1;
  options->check_host_ip = -1;
  options->strict_host_key_checking = -1;
  options->compression = -1;
  options->keepalives = -1;
  options->compression_level = -1;
  options->port = -1;
  options->connection_attempts = -1;
  options->number_of_password_prompts = -1;
  options->cipher = -1;
  options->num_identity_files = 0;
  options->hostname = NULL;
  options->proxy_command = NULL;
  options->user = NULL;
  options->escape_char = -1;
  options->system_hostfile = NULL;
  options->user_hostfile = NULL;
  options->num_local_forwards = 0;
  options->num_remote_forwards = 0;
  options->log_level = (LogLevel)-1;
d634 2
a635 1
void fill_default_options(Options *options)
d637 14
a650 14
  if (options->forward_agent == -1)
    options->forward_agent = 1;
  if (options->forward_x11 == -1)
    options->forward_x11 = 1;
  if (options->gateway_ports == -1)
    options->gateway_ports = 0;
  if (options->use_privileged_port == -1)
    options->use_privileged_port = 1;
  if (options->rhosts_authentication == -1)
    options->rhosts_authentication = 1;
  if (options->rsa_authentication == -1)
    options->rsa_authentication = 1;
  if (options->skey_authentication == -1)
    options->skey_authentication = 0;
d652 2
a653 2
  if (options->kerberos_authentication == -1)
    options->kerberos_authentication = 1;
d656 4
a659 4
  if (options->kerberos_tgt_passing == -1)
    options->kerberos_tgt_passing = 1;
  if (options->afs_token_passing == -1)
    options->afs_token_passing = 1;
d661 46
a706 46
  if (options->password_authentication == -1)
    options->password_authentication = 1;
  if (options->rhosts_rsa_authentication == -1)
    options->rhosts_rsa_authentication = 1;
  if (options->fallback_to_rsh == -1)
    options->fallback_to_rsh = 1;
  if (options->use_rsh == -1)
    options->use_rsh = 0;
  if (options->batch_mode == -1)
    options->batch_mode = 0;
  if (options->check_host_ip == -1)
    options->check_host_ip = 1;
  if (options->strict_host_key_checking == -1)
    options->strict_host_key_checking = 2; /* 2 is default */
  if (options->compression == -1)
    options->compression = 0;
  if (options->keepalives == -1)
    options->keepalives = 1;
  if (options->compression_level == -1)
    options->compression_level = 6;
  if (options->port == -1)
    options->port = 0; /* Filled in ssh_connect. */
  if (options->connection_attempts == -1)
    options->connection_attempts = 4;
  if (options->number_of_password_prompts == -1)
    options->number_of_password_prompts = 3;
  if (options->cipher == -1)
    options->cipher = SSH_CIPHER_NOT_SET; /* Selected in ssh_login(). */
  if (options->num_identity_files == 0)
    {
      options->identity_files[0] = 
	xmalloc(2 + strlen(SSH_CLIENT_IDENTITY) + 1);
      sprintf(options->identity_files[0], "~/%.100s", SSH_CLIENT_IDENTITY);
      options->num_identity_files = 1;
    }
  if (options->escape_char == -1)
    options->escape_char = '~';
  if (options->system_hostfile == NULL)
    options->system_hostfile = SSH_SYSTEM_HOSTFILE;
  if (options->user_hostfile == NULL)
    options->user_hostfile = SSH_USER_HOSTFILE;
  if (options->log_level == (LogLevel)-1)
    options->log_level = SYSLOG_LEVEL_INFO;
  /* options->proxy_command should not be set by default */
  /* options->user will be set in the main program if appropriate */
  /* options->hostname will be set in the main program if appropriate */
a707 1

@


1.15
log
@bugfix: loglevels are per host in clientconfig,
factor out common log-level parsing code.
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.14 1999/11/14 21:45:07 markus Exp $");
d94 1
d124 1
d293 6
a360 9
      
    case oTISAuthentication:
      cp = strtok(NULL, WHITESPACE);
      if (cp != 0 && (strcmp(cp, "yes") == 0 || strcmp(cp, "true") == 0))
	fprintf(stderr,
		"%.99s line %d: Warning, TIS is not supported.\n",
		filename,
		linenum);
      break;
d600 1
d651 2
@


1.14
log
@print _all_ bad config-options in ssh(1), too
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.13 1999/11/10 23:36:44 markus Exp $");
a157 17
/* textual representation of log-levels */

static struct 
{
  const char *name;
  LogLevel level;
} log_levels[] =
{
  { "QUIET", SYSLOG_LEVEL_QUIET },
  { "FATAL", SYSLOG_LEVEL_FATAL },
  { "ERROR", SYSLOG_LEVEL_ERROR },
  { "INFO",  SYSLOG_LEVEL_INFO },
  { "CHAT",  SYSLOG_LEVEL_CHAT },
  { "DEBUG", SYSLOG_LEVEL_DEBUG },
  { NULL, 0 }
};

d223 1
a223 1
  int opcode, *intptr, value, fwd_port, fwd_host_port, i;
d448 2
a449 1
	fatal("%.200s line %d: Bad cipher.", filename, linenum);
d455 1
d457 6
a462 17
      if (!cp)
        {
          fprintf(stderr, "%s line %d: missing level name.\n",
	          filename, linenum);
          exit(1);
        }
      for (i = 0; log_levels[i].name; i++)
        if (strcasecmp(log_levels[i].name, cp) == 0)
          break;
      if (!log_levels[i].name)
        {
          fprintf(stderr, "%s line %d: unsupported log level %s\n",
	          filename, linenum, cp);
          exit(1);
        }
      if (options->log_level == (LogLevel)(-1))
        options->log_level = log_levels[i].level;
@


1.13
log
@add LogLevel {QUIET, FATAL, ERROR, INFO, CHAT, DEBUG} to ssh/sshd,
obsoletes QuietMode and FascistLogging in sshd.
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.12 1999/10/15 21:39:02 markus Exp $");
d91 1
d226 3
a228 4
  fatal("%.200s line %d: Bad configuration option.",
	filename, linenum);
  /*NOTREACHED*/
  return 0;
d234 2
a235 1
void process_config_line(Options *options, const char *host,
d245 1
a245 1
    return;
d260 3
a262 1

d432 1
a432 1
      return;
d539 1
a539 1
      return;
d567 1
a567 1
      fatal("parse_config_file: Unimplemented opcode %d", opcode);
d574 1
d587 1
d604 2
a605 2

      process_config_line(options, host, line, filename, linenum, &active);
d608 3
@


1.12
log
@typo: s/UsePrivilegedPorts/UsePrivilegedPort/
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.11 1999/10/12 21:04:21 markus Exp $");
d104 1
a104 1
  oUsePrivilegedPort
d153 18
d239 1
a239 1
  int opcode, *intptr, value, fwd_port, fwd_host_port;
d466 21
d649 1
d720 2
@


1.11
log
@-P/UsePrivilegedPort from 1.2.27, it turns of allocation of priv. port
and disabled rhosts/rhosts-rsa, ok deraadt@@
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.10 1999/10/06 20:07:42 dugsong Exp $");
d118 1
a118 1
  { "useprivilegedports", oUsePrivilegedPort },
@


1.10
log
@implement client NumberOfPasswordPrompts option
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.9 1999/10/03 22:01:39 provos Exp $");
d103 2
a104 1
  oCompressionLevel, oKeepAlives, oNumberOfPasswordPrompts, oTISAuthentication
d118 1
d267 4
d577 1
d623 2
@


1.9
log
@fix last commit.
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.8 1999/10/03 21:50:03 provos Exp $");
d103 1
a103 1
  oCompressionLevel, oKeepAlives, oTISAuthentication
d149 1
d340 4
d592 1
d654 2
@


1.8
log
@add code to detect DNS spoofing:

the main idea is to not only store the host key for the hostname but
also for the according IP address.  When we check the host key in the
known_hosts file, we also check the key against the according IP address.
When the server key changes, host_status = HOST_CHANGED.  If
check_host_in_hostfile() returns differing status for the IP address
that means that either DNS was spoofed or that the IP address
for the host and the host key changed at the same time.
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.7 1999/09/30 08:03:39 deraadt Exp $");
d306 4
@


1.7
log
@IPPORT_RESERVED
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.6 1999/09/30 05:03:05 deraadt Exp $");
d102 2
a103 2
  oBatchMode, oStrictHostKeyChecking, oCompression, oCompressionLevel,
  oKeepAlives, oTISAuthentication
d144 1
d576 1
d630 2
@


1.6
log
@cull more ancient garbage from pre-POSIX days
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.5 1999/09/29 18:16:19 dugsong Exp $");
d166 1
a166 1
  if (port < 1024 && original_real_uid != 0)
@


1.5
log
@update krb4/AFS support to ssh-1.2.27-afs-kerberos-pl1 level, clean up unused variables, update manpages
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.4 1999/09/29 17:52:12 deraadt Exp $");
a325 1
#ifdef WITH_ZLIB
a328 1
#endif /* WITH_ZLIB */
a342 1
#ifdef WITH_ZLIB
a345 1
#endif /* WITH_ZLIB */
a575 1
#ifdef WITH_ZLIB
a576 1
#endif /* WITH_ZLIB */
a577 1
#ifdef WITH_ZLIB
a578 1
#endif /* WITH_ZLIB */
a629 1
#ifdef WITH_ZLIB
a631 1
#endif /* WITH_ZLIB */
a633 1
#ifdef WITH_ZLIB
a635 1
#endif /* WITH_ZLIB */
@


1.4
log
@disable portforwarding for reserved/bad ports; Markus.Friedl@@informatik.uni-erlangen.de
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.3 1999/09/29 00:10:16 deraadt Exp $");
a95 3
#ifdef KERBEROS_TGT_PASSING
  oKerberosTgtPassing,
#endif
d97 1
a97 1
  oAFSTokenPassing,
d123 1
a123 1
#ifdef KERBEROS_TGT_PASSING
a124 2
#endif
#ifdef AFS
d285 1
a285 1
#ifdef KERBEROS_TGT_PASSING
a288 1
#endif
a289 1
#ifdef AFS
d570 1
a570 1
#ifdef KERBEROS_TGT_PASSING
a571 2
#endif
#ifdef AFS
d619 2
a620 2
#endif
#ifdef KERBEROS_TGT_PASSING
a622 2
#endif
#ifdef AFS
d625 1
a625 1
#endif
@


1.3
log
@GatewayPorts and ssh -g; markus.friedl@@informatik.uni-erlangen.de
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.2 1999/09/28 04:45:36 provos Exp $");
d168 5
@


1.2
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.1 1999/09/26 20:53:37 deraadt Exp $");
d91 1
a91 1
  oForwardAgent, oForwardX11, oRhostsAuthentication,
d119 1
d258 4
d566 1
d614 2
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d17 1
a17 1
RCSID("$Id: readconf.c,v 1.13 1999/06/14 10:20:32 bg Exp $");
a82 1
     Cipher idea
@

