head	1.266;
access;
symbols
	OPENBSD_6_2_BASE:1.266
	OPENBSD_6_1:1.255.0.4
	OPENBSD_6_1_BASE:1.255
	OPENBSD_6_0:1.247.0.4
	OPENBSD_6_0_BASE:1.247
	OPENBSD_5_9:1.239.0.2
	OPENBSD_5_9_BASE:1.239
	OPENBSD_5_8:1.226.0.2
	OPENBSD_5_8_BASE:1.226
	OPENBSD_5_7:1.223.0.2
	OPENBSD_5_7_BASE:1.223
	OPENBSD_5_6:1.210.0.4
	OPENBSD_5_6_BASE:1.210
	OPENBSD_5_5:1.204.0.4
	OPENBSD_5_5_BASE:1.204
	OPENBSD_5_4:1.198.0.2
	OPENBSD_5_4_BASE:1.198
	OPENBSD_5_3:1.192.0.2
	OPENBSD_5_3_BASE:1.192
	OPENBSD_5_2:1.189.0.2
	OPENBSD_5_2_BASE:1.189
	OPENBSD_5_1_BASE:1.188
	OPENBSD_5_1:1.188.0.4
	OPENBSD_5_0:1.188.0.2
	OPENBSD_5_0_BASE:1.188
	OPENBSD_4_9:1.186.0.2
	OPENBSD_4_9_BASE:1.186
	OPENBSD_4_8:1.183.0.2
	OPENBSD_4_8_BASE:1.183
	OPENBSD_4_7:1.180.0.2
	OPENBSD_4_7_BASE:1.180
	OPENBSD_4_6:1.171.0.4
	OPENBSD_4_6_BASE:1.171
	OPENBSD_4_5:1.170.0.2
	OPENBSD_4_5_BASE:1.170
	OPENBSD_4_4:1.167.0.2
	OPENBSD_4_4_BASE:1.167
	OPENBSD_4_3:1.165.0.2
	OPENBSD_4_3_BASE:1.165
	OPENBSD_4_2:1.164.0.2
	OPENBSD_4_2_BASE:1.164
	OPENBSD_4_1:1.162.0.2
	OPENBSD_4_1_BASE:1.162
	OPENBSD_4_0:1.162.0.4
	OPENBSD_4_0_BASE:1.162
	OPENBSD_3_9:1.146.0.2
	OPENBSD_3_9_BASE:1.146
	OPENBSD_3_8:1.142.0.2
	OPENBSD_3_8_BASE:1.142
	OPENBSD_3_7:1.138.0.4
	OPENBSD_3_7_BASE:1.138
	OPENBSD_3_6:1.138.0.2
	OPENBSD_3_6_BASE:1.138
	OPENBSD_3_5:1.135.0.2
	OPENBSD_3_5_BASE:1.135
	OPENBSD_3_4:1.124.0.2
	OPENBSD_3_4_BASE:1.124
	OPENBSD_3_3:1.112.0.2
	OPENBSD_3_3_BASE:1.112
	OPENBSD_3_2:1.107.0.2
	OPENBSD_3_2_BASE:1.107
	OPENBSD_3_1:1.99.0.2
	OPENBSD_3_1_BASE:1.99
	OPENBSD_3_0:1.83.0.2
	OPENBSD_3_0_BASE:1.83
	OPENBSD_2_9_BASE:1.72
	OPENBSD_2_9:1.72.0.2
	OPENBSD_2_8:1.27.0.2
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10;
locks; strict;
comment	@ * @;


1.266
date	2017.08.27.00.38.41;	author dtucker;	state Exp;
branches;
next	1.265;
commitid	U93v7JNgL01HOZjG;

1.265
date	2017.08.11.04.47.12;	author djm;	state Exp;
branches;
next	1.264;
commitid	XMuNn6CWMrhoqCG2;

1.264
date	2017.06.14.00.31.38;	author dtucker;	state Exp;
branches;
next	1.263;
commitid	zcfajTuHJn2eDlGi;

1.263
date	2017.05.31.07.00.13;	author markus;	state Exp;
branches;
next	1.262;
commitid	X93t1IqdA6G5YFwi;

1.262
date	2017.05.31.05.08.46;	author djm;	state Exp;
branches;
next	1.261;
commitid	yEO1wN67NKiQY7xQ;

1.261
date	2017.05.30.14.23.52;	author markus;	state Exp;
branches;
next	1.260;
commitid	tEOGxoM4kvBMLD6J;

1.260
date	2017.05.30.14.19.15;	author markus;	state Exp;
branches;
next	1.259;
commitid	dfOwUWTpwAeNiW8V;

1.259
date	2017.05.30.08.52.20;	author markus;	state Exp;
branches;
next	1.258;
commitid	AQD3o1zTZEMIcuBx;

1.258
date	2017.05.05.10.42.49;	author naddy;	state Exp;
branches;
next	1.257;
commitid	Lis1W6ZyAoexJa23;

1.257
date	2017.04.30.23.18.44;	author djm;	state Exp;
branches;
next	1.256;
commitid	NPnVhZTcf5ddO7Ys;

1.256
date	2017.04.28.03.24.53;	author djm;	state Exp;
branches;
next	1.255;
commitid	bKp9xSPojYdIUplz;

1.255
date	2017.03.11.23.40.26;	author djm;	state Exp;
branches;
next	1.254;
commitid	5c5HtUIeIqLbXY2B;

1.254
date	2017.02.03.02.56.00;	author dtucker;	state Exp;
branches;
next	1.253;
commitid	FFnrndqVo2L4heRx;

1.253
date	2017.01.30.00.32.28;	author djm;	state Exp;
branches;
next	1.252;
commitid	76JXLALe772PRmBO;

1.252
date	2017.01.30.00.32.03;	author djm;	state Exp;
branches;
next	1.251;
commitid	5ZUDvI8FJSrOp0Gg;

1.251
date	2016.12.04.23.54.02;	author djm;	state Exp;
branches;
next	1.250;
commitid	8dj9Bi9tWSTLD97F;

1.250
date	2016.09.28.20.32.42;	author djm;	state Exp;
branches;
next	1.249;
commitid	TvNoQIkfkdH4jhbD;

1.249
date	2016.09.28.16.33.07;	author djm;	state Exp;
branches;
next	1.248;
commitid	e2NJzal9PUi2o22D;

1.248
date	2016.09.22.02.29.57;	author dtucker;	state Exp;
branches;
next	1.247;
commitid	SPWH3P6WseCPFxzk;

1.247
date	2016.07.22.05.46.11;	author dtucker;	state Exp;
branches;
next	1.246;
commitid	LODqKPMg2HhVfobt;

1.246
date	2016.07.17.04.20.16;	author djm;	state Exp;
branches;
next	1.245;
commitid	Tgv3JW0XntG1C5ZI;

1.245
date	2016.05.24.04.43.45;	author dtucker;	state Exp;
branches;
next	1.244;
commitid	9CAIn8nADq025zdf;

1.244
date	2016.05.23.23.30.50;	author djm;	state Exp;
branches;
next	1.243;
commitid	HEb71O8UjH9Yyj0N;

1.243
date	2016.05.02.10.26.04;	author djm;	state Exp;
branches;
next	1.242;
commitid	rVUG0L3JBpFl5b0k;

1.242
date	2016.05.02.08.49.03;	author djm;	state Exp;
branches;
next	1.241;
commitid	RYYIr1bk0phq4fXa;

1.241
date	2016.04.28.14.30.21;	author djm;	state Exp;
branches;
next	1.240;
commitid	OR7FY2jiylxWTYct;

1.240
date	2016.03.14.16.20.54;	author djm;	state Exp;
branches;
next	1.239;
commitid	mu0i9yfzLNq3LUMt;

1.239
date	2016.02.23.01.34.14;	author djm;	state Exp;
branches;
next	1.238;
commitid	BvCWeeFDKHDznO26;

1.238
date	2016.02.05.04.31.21;	author jsg;	state Exp;
branches;
next	1.237;
commitid	FilHy9sYRcRCCcC1;

1.237
date	2016.01.14.22.56.56;	author markus;	state Exp;
branches;
next	1.236;
commitid	wjm52VmSUdBkFKQk;

1.236
date	2016.01.14.16.17.40;	author markus;	state Exp;
branches;
next	1.235;
commitid	W9ye0gltieEl87AJ;

1.235
date	2015.12.11.02.31.47;	author mmcc;	state Exp;
branches;
next	1.234;
commitid	f7EpsYIFQYQNXTtF;

1.234
date	2015.12.11.02.20.28;	author djm;	state Exp;
branches;
next	1.233;
commitid	NUwbaO6bOxtvjc7f;

1.233
date	2015.12.11.00.20.04;	author mmcc;	state Exp;
branches;
next	1.232;
commitid	5insXikipROHNgzs;

1.232
date	2015.12.10.17.08.40;	author mmcc;	state Exp;
branches;
next	1.231;
commitid	qST12VGCwbX5zIfM;

1.231
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.230;
commitid	K3glY441IowbrjDE;

1.230
date	2015.12.04.00.24.55;	author djm;	state Exp;
branches;
next	1.229;
commitid	vakDpiC7Fj6sY8Gm;

1.229
date	2015.11.15.22.26.49;	author jcs;	state Exp;
branches;
next	1.228;
commitid	mjNGB5AAtJeHDag2;

1.228
date	2015.10.13.16.15.21;	author djm;	state Exp;
branches;
next	1.227;
commitid	p1bqmYEkUEBpark2;

1.227
date	2015.09.24.06.15.11;	author djm;	state Exp;
branches;
next	1.226;
commitid	nGLvQjqT3Z8tECCC;

1.226
date	2015.07.30.00.01.34;	author djm;	state Exp;
branches;
next	1.225;
commitid	YReS3Mui4FCZvL7z;

1.225
date	2015.07.10.06.21.53;	author markus;	state Exp;
branches;
next	1.224;
commitid	iQTtbsbSVdO9zivU;

1.224
date	2015.05.04.06.10.48;	author djm;	state Exp;
branches;
next	1.223;
commitid	KfZDG8r2EByk0YBR;

1.223
date	2015.01.30.11.43.14;	author djm;	state Exp;
branches;
next	1.222;
commitid	NHgy1atCg6tWjTbF;

1.222
date	2015.01.28.22.36.00;	author djm;	state Exp;
branches;
next	1.221;
commitid	P7KG9D8zB61mMUPV;

1.221
date	2015.01.20.20.16.21;	author markus;	state Exp;
branches;
next	1.220;
commitid	Saj27Ko6Js1nmjQ4;

1.220
date	2015.01.20.07.56.44;	author djm;	state Exp;
branches;
next	1.219;
commitid	qxxTmGsJjhbXtWyF;

1.219
date	2015.01.19.20.16.15;	author markus;	state Exp;
branches;
next	1.218;
commitid	U9l75XYAjMKaQ8Jp;

1.218
date	2015.01.19.20.07.45;	author markus;	state Exp;
branches;
next	1.217;
commitid	GrtSC5ve2VERgUln;

1.217
date	2015.01.19.19.52.16;	author markus;	state Exp;
branches;
next	1.216;
commitid	UHlhoIB5NMb8eAPm;

1.216
date	2015.01.18.13.33.34;	author djm;	state Exp;
branches;
next	1.215;
commitid	NhEd0JxiGwBmOAgm;

1.215
date	2015.01.15.11.04.36;	author djm;	state Exp;
branches;
next	1.214;
commitid	ChZxgQ24AXPApuin;

1.214
date	2015.01.14.20.05.27;	author djm;	state Exp;
branches;
next	1.213;
commitid	YqNUZu0ifI7Q95nk;

1.213
date	2015.01.08.10.14.08;	author djm;	state Exp;
branches;
next	1.212;
commitid	397Wklb10N5bP6VW;

1.212
date	2014.12.21.22.27.56;	author djm;	state Exp;
branches;
next	1.211;
commitid	EbtriidyZdsmXksl;

1.211
date	2014.12.11.05.13.28;	author djm;	state Exp;
branches;
next	1.210;
commitid	L6rP2dFRyQPq4gUX;

1.210
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.209;
commitid	z7plx8Gkj6l2sxem;

1.209
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.208;
commitid	1h9UxAQmwdaqUzyX;

1.208
date	2014.06.05.22.17.50;	author djm;	state Exp;
branches;
next	1.207;
commitid	o1eDZomlzJ5dY6mv;

1.207
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.206;

1.206
date	2014.04.18.23.52.25;	author djm;	state Exp;
branches;
next	1.205;

1.205
date	2014.03.27.23.01.27;	author markus;	state Exp;
branches;
next	1.204;

1.204
date	2014.02.02.03.44.32;	author djm;	state Exp;
branches
	1.204.4.1;
next	1.203;

1.203
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.202;

1.202
date	2014.01.29.06.18.35;	author djm;	state Exp;
branches;
next	1.201;

1.201
date	2014.01.09.23.20.00;	author djm;	state Exp;
branches;
next	1.200;

1.200
date	2013.12.30.23.52.28;	author djm;	state Exp;
branches;
next	1.199;

1.199
date	2013.11.02.21.59.15;	author markus;	state Exp;
branches;
next	1.198;

1.198
date	2013.06.05.12.52.38;	author dtucker;	state Exp;
branches;
next	1.197;

1.197
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.196;

1.196
date	2013.05.16.02.00.34;	author dtucker;	state Exp;
branches;
next	1.195;

1.195
date	2013.05.10.03.40.07;	author djm;	state Exp;
branches;
next	1.194;

1.194
date	2013.04.05.00.14.00;	author djm;	state Exp;
branches;
next	1.193;

1.193
date	2013.03.05.20.16.09;	author markus;	state Exp;
branches;
next	1.192;

1.192
date	2013.02.17.23.16.57;	author dtucker;	state Exp;
branches;
next	1.191;

1.191
date	2013.02.15.00.21.01;	author dtucker;	state Exp;
branches;
next	1.190;

1.190
date	2012.12.02.20.26.11;	author djm;	state Exp;
branches;
next	1.189;

1.189
date	2012.06.22.12.30.26;	author dtucker;	state Exp;
branches;
next	1.188;

1.188
date	2011.05.24.07.15.47;	author djm;	state Exp;
branches;
next	1.187;

1.187
date	2011.05.06.02.05.41;	author djm;	state Exp;
branches;
next	1.186;

1.186
date	2010.11.29.23.45.51;	author djm;	state Exp;
branches;
next	1.185;

1.185
date	2010.09.22.05.01.29;	author djm;	state Exp;
branches;
next	1.184;

1.184
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.183;

1.183
date	2010.04.26.22.28.24;	author djm;	state Exp;
branches;
next	1.182;

1.182
date	2010.04.16.01.47.26;	author djm;	state Exp;
branches;
next	1.181;

1.181
date	2010.04.10.02.10.56;	author djm;	state Exp;
branches;
next	1.180;

1.180
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.179;

1.179
date	2010.01.13.01.20.20;	author dtucker;	state Exp;
branches;
next	1.178;

1.178
date	2010.01.11.04.46.45;	author dtucker;	state Exp;
branches;
next	1.177;

1.177
date	2010.01.04.01.45.30;	author dtucker;	state Exp;
branches;
next	1.176;

1.176
date	2009.12.06.23.41.15;	author dtucker;	state Exp;
branches;
next	1.175;

1.175
date	2009.11.20.00.59.36;	author dtucker;	state Exp;
branches;
next	1.174;

1.174
date	2009.11.10.04.30.45;	author dtucker;	state Exp;
branches;
next	1.173;

1.173
date	2009.10.24.11.13.54;	author andreas;	state Exp;
branches;
next	1.172;

1.172
date	2009.10.23.01.57.11;	author djm;	state Exp;
branches;
next	1.171;

1.171
date	2009.03.05.07.18.19;	author djm;	state Exp;
branches;
next	1.170;

1.170
date	2008.11.04.08.22.13;	author djm;	state Exp;
branches;
next	1.169;

1.169
date	2008.11.01.04.50.08;	author djm;	state Exp;
branches;
next	1.168;

1.168
date	2008.10.03.23.56.28;	author deraadt;	state Exp;
branches;
next	1.167;

1.167
date	2008.07.31.14.48.28;	author markus;	state Exp;
branches;
next	1.166;

1.166
date	2008.07.17.08.48.00;	author djm;	state Exp;
branches;
next	1.165;

1.165
date	2008.01.19.23.09.49;	author djm;	state Exp;
branches;
next	1.164;

1.164
date	2007.05.17.23.53.41;	author jolan;	state Exp;
branches;
next	1.163;

1.163
date	2007.05.17.20.48.13;	author djm;	state Exp;
branches;
next	1.162;

1.162
date	2006.08.30.00.06.51;	author dtucker;	state Exp;
branches;
next	1.161;

1.161
date	2006.08.18.13.54.54;	author djm;	state Exp;
branches;
next	1.160;

1.160
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.159;

1.159
date	2006.08.01.23.22.48;	author stevesk;	state Exp;
branches;
next	1.158;

1.158
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.157;

1.157
date	2006.07.20.15.26.15;	author stevesk;	state Exp;
branches;
next	1.156;

1.156
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.155;

1.155
date	2006.06.08.14.45.49;	author markus;	state Exp;
branches;
next	1.154;

1.154
date	2006.06.06.10.20.20;	author markus;	state Exp;
branches;
next	1.153;

1.153
date	2006.05.08.10.49.48;	author djm;	state Exp;
branches;
next	1.152;

1.152
date	2006.04.25.08.02.27;	author dtucker;	state Exp;
branches;
next	1.151;

1.151
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.150;

1.150
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.149;

1.149
date	2006.03.19.18.51.19;	author deraadt;	state Exp;
branches;
next	1.148;

1.148
date	2006.03.19.07.41.30;	author djm;	state Exp;
branches;
next	1.147;

1.147
date	2006.03.07.09.07.40;	author djm;	state Exp;
branches;
next	1.146;

1.146
date	2006.02.20.17.19.54;	author stevesk;	state Exp;
branches
	1.146.2.1;
next	1.145;

1.145
date	2006.02.10.01.44.27;	author stevesk;	state Exp;
branches;
next	1.144;

1.144
date	2006.02.07.01.18.09;	author stevesk;	state Exp;
branches;
next	1.143;

1.143
date	2005.10.14.02.17.59;	author stevesk;	state Exp;
branches;
next	1.142;

1.142
date	2005.08.30.22.08.05;	author djm;	state Exp;
branches
	1.142.2.1;
next	1.141;

1.141
date	2005.07.25.11.59.40;	author markus;	state Exp;
branches;
next	1.140;

1.140
date	2005.07.17.07.17.55;	author djm;	state Exp;
branches;
next	1.139;

1.139
date	2005.06.17.02.44.33;	author djm;	state Exp;
branches;
next	1.138;

1.138
date	2004.06.13.12.53.24;	author djm;	state Exp;
branches
	1.138.2.1
	1.138.4.1;
next	1.137;

1.137
date	2004.05.08.00.21.31;	author djm;	state Exp;
branches;
next	1.136;

1.136
date	2004.04.08.16.08.21;	author henning;	state Exp;
branches;
next	1.135;

1.135
date	2004.03.05.10.53.58;	author markus;	state Exp;
branches
	1.135.2.1;
next	1.134;

1.134
date	2004.01.19.21.25.15;	author markus;	state Exp;
branches;
next	1.133;

1.133
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches;
next	1.132;

1.132
date	2003.11.17.11.06.07;	author markus;	state Exp;
branches;
next	1.131;

1.131
date	2003.11.17.09.45.39;	author djm;	state Exp;
branches;
next	1.130;

1.130
date	2003.11.14.13.19.09;	author markus;	state Exp;
branches;
next	1.129;

1.129
date	2003.11.02.11.01.03;	author markus;	state Exp;
branches;
next	1.128;

1.128
date	2003.10.26.16.57.43;	author avsm;	state Exp;
branches;
next	1.127;

1.127
date	2003.10.11.08.26.43;	author markus;	state Exp;
branches;
next	1.126;

1.126
date	2003.10.07.21.58.28;	author deraadt;	state Exp;
branches;
next	1.125;

1.125
date	2003.10.07.01.47.27;	author dtucker;	state Exp;
branches;
next	1.124;

1.124
date	2003.08.25.10.33.33;	author djm;	state Exp;
branches
	1.124.2.1;
next	1.123;

1.123
date	2003.08.24.17.36.52;	author deraadt;	state Exp;
branches;
next	1.122;

1.122
date	2003.08.22.13.20.03;	author markus;	state Exp;
branches;
next	1.121;

1.121
date	2003.08.22.10.56.09;	author markus;	state Exp;
branches;
next	1.120;

1.120
date	2003.06.24.08.23.46;	author markus;	state Exp;
branches;
next	1.119;

1.119
date	2003.05.15.00.28.28;	author markus;	state Exp;
branches;
next	1.118;

1.118
date	2003.05.14.02.15.47;	author markus;	state Exp;
branches;
next	1.117;

1.117
date	2003.05.12.16.55.37;	author markus;	state Exp;
branches;
next	1.116;

1.116
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches;
next	1.115;

1.115
date	2003.04.02.09.48.07;	author markus;	state Exp;
branches;
next	1.114;

1.114
date	2003.04.01.10.22.21;	author markus;	state Exp;
branches;
next	1.113;

1.113
date	2003.04.01.10.10.23;	author markus;	state Exp;
branches;
next	1.112;

1.112
date	2003.03.05.22.33.43;	author markus;	state Exp;
branches
	1.112.2.1;
next	1.111;

1.111
date	2003.02.16.17.09.57;	author markus;	state Exp;
branches;
next	1.110;

1.110
date	2002.12.19.00.07.02;	author djm;	state Exp;
branches;
next	1.109;

1.109
date	2002.12.13.10.03.15;	author markus;	state Exp;
branches;
next	1.108;

1.108
date	2002.11.21.22.45.31;	author markus;	state Exp;
branches;
next	1.107;

1.107
date	2002.07.01.19.48.46;	author markus;	state Exp;
branches
	1.107.2.1;
next	1.106;

1.106
date	2002.06.30.21.59.45;	author deraadt;	state Exp;
branches;
next	1.105;

1.105
date	2002.06.23.03.30.17;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2002.05.31.10.30.33;	author markus;	state Exp;
branches;
next	1.102;

1.102
date	2002.05.25.08.50.39;	author markus;	state Exp;
branches;
next	1.101;

1.101
date	2002.05.24.08.45.14;	author markus;	state Exp;
branches;
next	1.100;

1.100
date	2002.05.23.19.24.30;	author markus;	state Exp;
branches;
next	1.99;

1.99
date	2002.03.26.15.58.46;	author markus;	state Exp;
branches
	1.99.2.1;
next	1.98;

1.98
date	2002.03.19.10.49.35;	author markus;	state Exp;
branches;
next	1.97;

1.97
date	2002.02.25.16.33.27;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2002.02.24.19.14.59;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2002.02.03.17.59.23;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2002.01.25.21.00.24;	author markus;	state Exp;
branches;
next	1.93;

1.93
date	2002.01.13.17.57.37;	author markus;	state Exp;
branches;
next	1.92;

1.92
date	2001.12.28.15.06.00;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2001.12.28.14.50.54;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2001.12.20.22.50.24;	author djm;	state Exp;
branches;
next	1.88;

1.88
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2001.12.05.10.06.13;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2001.12.05.03.56.39;	author itojun;	state Exp;
branches;
next	1.85;

1.85
date	2001.11.07.16.03.17;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2001.10.29.19.27.15;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2001.10.06.11.18.19;	author markus;	state Exp;
branches
	1.83.2.1;
next	1.82;

1.82
date	2001.08.31.11.46.39;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2001.07.23.09.06.28;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2001.06.26.20.14.11;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2001.06.25.20.26.37;	author stevesk;	state Exp;
branches;
next	1.78;

1.78
date	2001.06.24.05.47.13;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2001.06.24.05.35.34;	author markus;	state Exp;
branches;
next	1.76;

1.76
date	2001.06.23.15.12.21;	author itojun;	state Exp;
branches;
next	1.75;

1.75
date	2001.06.23.02.34.33;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2001.05.19.16.32.16;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	2001.05.18.14.13.29;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2001.04.18.23.43.26;	author markus;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2001.04.18.22.03.45;	author markus;	state Exp;
branches;
next	1.70;

1.70
date	2001.04.17.10.53.26;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2001.04.15.08.43.47;	author markus;	state Exp;
branches;
next	1.68;

1.68
date	2001.04.12.19.15.25;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2001.04.05.10.42.56;	author markus;	state Exp;
branches;
next	1.66;

1.66
date	2001.04.04.20.25.38;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2001.04.04.14.34.58;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2001.04.04.09.48.35;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2001.04.04.00.06.54;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2001.04.03.23.32.12;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2001.04.03.19.53.29;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2001.03.29.21.06.21;	author stevesk;	state Exp;
branches;
next	1.59;

1.59
date	2001.03.29.14.24.59;	author provos;	state Exp;
branches;
next	1.58;

1.58
date	2001.03.28.21.59.40;	author provos;	state Exp;
branches;
next	1.57;

1.57
date	2001.03.27.17.46.49;	author provos;	state Exp;
branches;
next	1.56;

1.56
date	2001.03.26.08.07.09;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2001.03.23.11.04.07;	author djm;	state Exp;
branches;
next	1.54;

1.54
date	2001.03.12.22.02.02;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2001.03.10.17.51.04;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2001.03.10.12.48.27;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2001.03.08.21.42.33;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2001.03.05.17.17.21;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2001.02.28.09.57.07;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2001.02.15.23.19.59;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2001.02.11.12.59.25;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2001.02.10.12.09.21;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2001.02.09.17.10.53;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2001.02.09.12.28.35;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2001.02.08.10.47.05;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2001.02.06.22.26.17;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.04.15.32.26;	author stevesk;	state Exp;
branches;
next	1.40;

1.40
date	2001.01.31.20.48.08;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.22.23.06.40;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2001.01.22.17.22.28;	author stevesk;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.21.19.06.00;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.20.18.20.29;	author stevesk;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.04.22.21.26;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2000.12.27.12.34.50;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2000.12.20.19.37.22;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2000.12.19.23.17.58;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.15.17.30.14;	author provos;	state Exp;
branches;
next	1.30;

1.30
date	2000.12.03.11.15.04;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2000.11.23.21.03.47;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.12.19.50.38;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.19.16.45.16;	author provos;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2000.10.14.12.16.56;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.12.09.59.19;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.11.20.27.24;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.11.20.14.39;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.11.04.02.17;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.27.21.41.34;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.21.11.25.07;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.17.15.38.58;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.07.20.27.55;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.19.21.34.44;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.16.08.27.22;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.21.16.46.10;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.19.00.50.11;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.02.02.00.19;	author todd;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.31.09.20.38;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.25.20.45.20;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.08.17.42.25;	author markus;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.05.08.17.12.16;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.07.18.23.32;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.06.17.45.37;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.03.17.55.21;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.01.18.41.06;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.27.17.54.01;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.27.08.01.27;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.26.21.33.53;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.26.21.28.33;	author markus;	state Exp;
branches;
next	;

1.10.2.1
date	2000.06.12.02.37.38;	author jason;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2000.09.01.18.23.24;	author jason;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2000.11.08.21.31.30;	author jason;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.03.12.15.44.17;	author jason;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2001.03.21.18.53.16;	author jason;	state Exp;
branches;
next	;

1.27.2.1
date	2001.02.16.20.13.22;	author jason;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2001.02.19.17.19.37;	author jason;	state Exp;
branches;
next	1.27.2.3;

1.27.2.3
date	2001.03.21.19.46.31;	author jason;	state Exp;
branches;
next	1.27.2.4;

1.27.2.4
date	2001.05.07.21.09.37;	author jason;	state Exp;
branches;
next	1.27.2.5;

1.27.2.5
date	2001.09.27.00.15.43;	author miod;	state Exp;
branches;
next	1.27.2.6;

1.27.2.6
date	2001.11.15.00.15.00;	author miod;	state Exp;
branches;
next	1.27.2.7;

1.27.2.7
date	2001.11.15.22.50.30;	author miod;	state Exp;
branches;
next	1.27.2.8;

1.27.2.8
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.72.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.72.2.2;

1.72.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.72.2.3;

1.72.2.3
date	2001.11.15.22.51.15;	author miod;	state Exp;
branches;
next	1.72.2.4;

1.72.2.4
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	1.72.2.5;

1.72.2.5
date	2002.06.02.22.56.11;	author miod;	state Exp;
branches;
next	;

1.83.2.1
date	2001.11.14.03.24.39;	author jason;	state Exp;
branches;
next	1.83.2.2;

1.83.2.2
date	2002.03.07.17.37.48;	author jason;	state Exp;
branches;
next	1.83.2.3;

1.83.2.3
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.83.2.4;

1.83.2.4
date	2002.06.22.07.23.18;	author miod;	state Exp;
branches;
next	1.83.2.5;

1.83.2.5
date	2002.06.26.18.22.36;	author miod;	state Exp;
branches;
next	1.83.2.6;

1.83.2.6
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.99.2.1
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	1.99.2.2;

1.99.2.2
date	2002.10.11.14.51.53;	author miod;	state Exp;
branches;
next	1.99.2.3;

1.99.2.3
date	2003.04.03.22.35.18;	author miod;	state Exp;
branches;
next	;

1.107.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.107.2.2;

1.107.2.2
date	2003.09.16.21.20.29;	author brad;	state Exp;
branches;
next	;

1.112.2.1
date	2003.09.16.20.50.44;	author brad;	state Exp;
branches;
next	1.112.2.2;

1.112.2.2
date	2004.03.04.18.18.17;	author brad;	state Exp;
branches;
next	;

1.124.2.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	1.124.2.2;

1.124.2.2
date	2004.08.19.22.37.33;	author brad;	state Exp;
branches;
next	;

1.135.2.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	;

1.138.2.1
date	2005.09.02.03.45.01;	author brad;	state Exp;
branches;
next	;

1.138.4.1
date	2005.09.04.18.40.11;	author brad;	state Exp;
branches;
next	1.138.4.2;

1.138.4.2
date	2006.02.03.02.53.45;	author brad;	state Exp;
branches;
next	;

1.142.2.1
date	2006.02.03.03.01.58;	author brad;	state Exp;
branches;
next	1.142.2.2;

1.142.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	;

1.146.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	;

1.204.4.1
date	2014.04.21.00.30.48;	author djm;	state Exp;
branches;
next	;


desc
@@


1.266
log
@Increase the buffer sizes for user prompts to ensure that they won't be
truncated by snprintf.  Based on patch from cjwatson at debian.org via
bz#2768, ok djm@@
@
text
@/* $OpenBSD: sshconnect2.c,v 1.265 2017/08/11 04:47:12 djm Exp $ */
/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 * Copyright (c) 2008 Damien Miller.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/queue.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <pwd.h>
#include <unistd.h>
#include <vis.h>

#include "xmalloc.h"
#include "ssh.h"
#include "ssh2.h"
#include "buffer.h"
#include "packet.h"
#include "compat.h"
#include "cipher.h"
#include "key.h"
#include "kex.h"
#include "myproposal.h"
#include "sshconnect.h"
#include "authfile.h"
#include "dh.h"
#include "authfd.h"
#include "log.h"
#include "misc.h"
#include "readconf.h"
#include "match.h"
#include "dispatch.h"
#include "canohost.h"
#include "msg.h"
#include "pathnames.h"
#include "uidswap.h"
#include "hostfile.h"
#include "ssherr.h"
#include "utf8.h"

#ifdef GSSAPI
#include "ssh-gss.h"
#endif

/* import */
extern char *client_version_string;
extern char *server_version_string;
extern Options options;

/*
 * SSH2 key exchange
 */

u_char *session_id2 = NULL;
u_int session_id2_len = 0;

char *xxx_host;
struct sockaddr *xxx_hostaddr;

static int
verify_host_key_callback(struct sshkey *hostkey, struct ssh *ssh)
{
	if (verify_host_key(xxx_host, xxx_hostaddr, hostkey) == -1)
		fatal("Host key verification failed.");
	return 0;
}

static char *
order_hostkeyalgs(char *host, struct sockaddr *hostaddr, u_short port)
{
	char *oavail, *avail, *first, *last, *alg, *hostname, *ret;
	size_t maxlen;
	struct hostkeys *hostkeys;
	int ktype;
	u_int i;

	/* Find all hostkeys for this hostname */
	get_hostfile_hostname_ipaddr(host, hostaddr, port, &hostname, NULL);
	hostkeys = init_hostkeys();
	for (i = 0; i < options.num_user_hostfiles; i++)
		load_hostkeys(hostkeys, hostname, options.user_hostfiles[i]);
	for (i = 0; i < options.num_system_hostfiles; i++)
		load_hostkeys(hostkeys, hostname, options.system_hostfiles[i]);

	oavail = avail = xstrdup(KEX_DEFAULT_PK_ALG);
	maxlen = strlen(avail) + 1;
	first = xmalloc(maxlen);
	last = xmalloc(maxlen);
	*first = *last = '\0';

#define ALG_APPEND(to, from) \
	do { \
		if (*to != '\0') \
			strlcat(to, ",", maxlen); \
		strlcat(to, from, maxlen); \
	} while (0)

	while ((alg = strsep(&avail, ",")) && *alg != '\0') {
		if ((ktype = sshkey_type_from_name(alg)) == KEY_UNSPEC)
			fatal("%s: unknown alg %s", __func__, alg);
		if (lookup_key_in_hostkeys_by_type(hostkeys,
		    sshkey_type_plain(ktype), NULL))
			ALG_APPEND(first, alg);
		else
			ALG_APPEND(last, alg);
	}
#undef ALG_APPEND
	xasprintf(&ret, "%s%s%s", first,
	    (*first == '\0' || *last == '\0') ? "" : ",", last);
	if (*first != '\0')
		debug3("%s: prefer hostkeyalgs: %s", __func__, first);

	free(first);
	free(last);
	free(hostname);
	free(oavail);
	free_hostkeys(hostkeys);

	return ret;
}

void
ssh_kex2(char *host, struct sockaddr *hostaddr, u_short port)
{
	char *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };
	char *s;
	struct kex *kex;
	int r;

	xxx_host = host;
	xxx_hostaddr = hostaddr;

	if ((s = kex_names_cat(options.kex_algorithms, "ext-info-c")) == NULL)
		fatal("%s: kex_names_cat", __func__);
	myproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(s);
	myproposal[PROPOSAL_ENC_ALGS_CTOS] =
	    compat_cipher_proposal(options.ciphers);
	myproposal[PROPOSAL_ENC_ALGS_STOC] =
	    compat_cipher_proposal(options.ciphers);
	myproposal[PROPOSAL_COMP_ALGS_CTOS] =
	    myproposal[PROPOSAL_COMP_ALGS_STOC] = options.compression ?
	    "zlib@@openssh.com,zlib,none" : "none,zlib@@openssh.com,zlib";
	myproposal[PROPOSAL_MAC_ALGS_CTOS] =
	    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;
	if (options.hostkeyalgorithms != NULL) {
		if (kex_assemble_names(KEX_DEFAULT_PK_ALG,
		    &options.hostkeyalgorithms) != 0)
			fatal("%s: kex_assemble_namelist", __func__);
		myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =
		    compat_pkalg_proposal(options.hostkeyalgorithms);
	} else {
		/* Enforce default */
		options.hostkeyalgorithms = xstrdup(KEX_DEFAULT_PK_ALG);
		/* Prefer algorithms that we already have keys for */
		myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =
		    compat_pkalg_proposal(
		    order_hostkeyalgs(host, hostaddr, port));
	}

	if (options.rekey_limit || options.rekey_interval)
		packet_set_rekey_limits(options.rekey_limit,
		    options.rekey_interval);

	/* start key exchange */
	if ((r = kex_setup(active_state, myproposal)) != 0)
		fatal("kex_setup: %s", ssh_err(r));
	kex = active_state->kex;
#ifdef WITH_OPENSSL
	kex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;
	kex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;
	kex->kex[KEX_DH_GRP14_SHA256] = kexdh_client;
	kex->kex[KEX_DH_GRP16_SHA512] = kexdh_client;
	kex->kex[KEX_DH_GRP18_SHA512] = kexdh_client;
	kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;
	kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;
	kex->kex[KEX_ECDH_SHA2] = kexecdh_client;
#endif
	kex->kex[KEX_C25519_SHA256] = kexc25519_client;
	kex->client_version_string=client_version_string;
	kex->server_version_string=server_version_string;
	kex->verify_host_key=&verify_host_key_callback;

	ssh_dispatch_run_fatal(active_state, DISPATCH_BLOCK, &kex->done);

	/* remove ext-info from the KEX proposals for rekeying */
	myproposal[PROPOSAL_KEX_ALGS] =
	    compat_kex_proposal(options.kex_algorithms);
	if ((r = kex_prop2buf(kex->my, myproposal)) != 0)
		fatal("kex_prop2buf: %s", ssh_err(r));

	session_id2 = kex->session_id;
	session_id2_len = kex->session_id_len;

#ifdef DEBUG_KEXDH
	/* send 1st encrypted/maced/compressed message */
	packet_start(SSH2_MSG_IGNORE);
	packet_put_cstring("markus");
	packet_send();
	packet_write_wait();
#endif
}

/*
 * Authenticate user
 */

typedef struct cauthctxt Authctxt;
typedef struct cauthmethod Authmethod;
typedef struct identity Identity;
typedef struct idlist Idlist;

struct identity {
	TAILQ_ENTRY(identity) next;
	int	agent_fd;		/* >=0 if agent supports key */
	struct sshkey	*key;		/* public/private key */
	char	*filename;		/* comment for agent-only keys */
	int	tried;
	int	isprivate;		/* key points to the private key */
	int	userprovided;
};
TAILQ_HEAD(idlist, identity);

struct cauthctxt {
	const char *server_user;
	const char *local_user;
	const char *host;
	const char *service;
	struct cauthmethod *method;
	sig_atomic_t success;
	char *authlist;
	int attempt;
	/* pubkey */
	struct idlist keys;
	int agent_fd;
	/* hostbased */
	Sensitive *sensitive;
	char *oktypes, *ktypes;
	const char *active_ktype;
	/* kbd-interactive */
	int info_req_seen;
	/* generic */
	void *methoddata;
};

struct cauthmethod {
	char	*name;		/* string to compare against server's list */
	int	(*userauth)(Authctxt *authctxt);
	void	(*cleanup)(Authctxt *authctxt);
	int	*enabled;	/* flag in option struct that enables method */
	int	*batch_flag;	/* flag in option struct that disables method */
};

int	input_userauth_service_accept(int, u_int32_t, struct ssh *);
int	input_userauth_ext_info(int, u_int32_t, struct ssh *);
int	input_userauth_success(int, u_int32_t, struct ssh *);
int	input_userauth_success_unexpected(int, u_int32_t, struct ssh *);
int	input_userauth_failure(int, u_int32_t, struct ssh *);
int	input_userauth_banner(int, u_int32_t, struct ssh *);
int	input_userauth_error(int, u_int32_t, struct ssh *);
int	input_userauth_info_req(int, u_int32_t, struct ssh *);
int	input_userauth_pk_ok(int, u_int32_t, struct ssh *);
int	input_userauth_passwd_changereq(int, u_int32_t, struct ssh *);

int	userauth_none(Authctxt *);
int	userauth_pubkey(Authctxt *);
int	userauth_passwd(Authctxt *);
int	userauth_kbdint(Authctxt *);
int	userauth_hostbased(Authctxt *);

#ifdef GSSAPI
int	userauth_gssapi(Authctxt *authctxt);
int	input_gssapi_response(int type, u_int32_t, struct ssh *);
int	input_gssapi_token(int type, u_int32_t, struct ssh *);
int	input_gssapi_hash(int type, u_int32_t, struct ssh *);
int	input_gssapi_error(int, u_int32_t, struct ssh *);
int	input_gssapi_errtok(int, u_int32_t, struct ssh *);
#endif

void	userauth(Authctxt *, char *);

static int sign_and_send_pubkey(Authctxt *, Identity *);
static void pubkey_prepare(Authctxt *);
static void pubkey_cleanup(Authctxt *);
static void pubkey_reset(Authctxt *);
static struct sshkey *load_identity_file(Identity *);

static Authmethod *authmethod_get(char *authlist);
static Authmethod *authmethod_lookup(const char *name);
static char *authmethods_get(void);

Authmethod authmethods[] = {
#ifdef GSSAPI
	{"gssapi-with-mic",
		userauth_gssapi,
		NULL,
		&options.gss_authentication,
		NULL},
#endif
	{"hostbased",
		userauth_hostbased,
		NULL,
		&options.hostbased_authentication,
		NULL},
	{"publickey",
		userauth_pubkey,
		NULL,
		&options.pubkey_authentication,
		NULL},
	{"keyboard-interactive",
		userauth_kbdint,
		NULL,
		&options.kbd_interactive_authentication,
		&options.batch_mode},
	{"password",
		userauth_passwd,
		NULL,
		&options.password_authentication,
		&options.batch_mode},
	{"none",
		userauth_none,
		NULL,
		NULL,
		NULL},
	{NULL, NULL, NULL, NULL, NULL}
};

void
ssh_userauth2(const char *local_user, const char *server_user, char *host,
    Sensitive *sensitive)
{
	struct ssh *ssh = active_state;
	Authctxt authctxt;
	int r;

	if (options.challenge_response_authentication)
		options.kbd_interactive_authentication = 1;
	if (options.preferred_authentications == NULL)
		options.preferred_authentications = authmethods_get();

	/* setup authentication context */
	memset(&authctxt, 0, sizeof(authctxt));
	pubkey_prepare(&authctxt);
	authctxt.server_user = server_user;
	authctxt.local_user = local_user;
	authctxt.host = host;
	authctxt.service = "ssh-connection";		/* service name */
	authctxt.success = 0;
	authctxt.method = authmethod_lookup("none");
	authctxt.authlist = NULL;
	authctxt.methoddata = NULL;
	authctxt.sensitive = sensitive;
	authctxt.active_ktype = authctxt.oktypes = authctxt.ktypes = NULL;
	authctxt.info_req_seen = 0;
	authctxt.agent_fd = -1;
	if (authctxt.method == NULL)
		fatal("ssh_userauth2: internal error: cannot send userauth none request");

	if ((r = sshpkt_start(ssh, SSH2_MSG_SERVICE_REQUEST)) != 0 ||
	    (r = sshpkt_put_cstring(ssh, "ssh-userauth")) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		fatal("%s: %s", __func__, ssh_err(r));

	ssh->authctxt = &authctxt;
	ssh_dispatch_init(ssh, &input_userauth_error);
	ssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_ext_info);
	ssh_dispatch_set(ssh, SSH2_MSG_SERVICE_ACCEPT, &input_userauth_service_accept);
	ssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt.success);	/* loop until success */
	ssh->authctxt = NULL;

	pubkey_cleanup(&authctxt);
	ssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);

	if (!authctxt.success)
		fatal("Authentication failed.");
	debug("Authentication succeeded (%s).", authctxt.method->name);
}

/* ARGSUSED */
int
input_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	int r;

	if (ssh_packet_remaining(ssh) > 0) {
		char *reply;

		if ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)
			goto out;
		debug2("service_accept: %s", reply);
		free(reply);
	} else {
		debug2("buggy server: service_accept w/o service");
	}
	if ((r = sshpkt_get_end(ssh)) != 0)
		goto out;
	debug("SSH2_MSG_SERVICE_ACCEPT received");

	/* initial userauth request */
	userauth_none(authctxt);

	ssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);
	ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);
	ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);
	ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);
	r = 0;
 out:
	return r;
}

/* ARGSUSED */
int
input_userauth_ext_info(int type, u_int32_t seqnr, struct ssh *ssh)
{
	return kex_input_ext_info(type, seqnr, ssh);
}

void
userauth(Authctxt *authctxt, char *authlist)
{
	if (authctxt->method != NULL && authctxt->method->cleanup != NULL)
		authctxt->method->cleanup(authctxt);

	free(authctxt->methoddata);
	authctxt->methoddata = NULL;
	if (authlist == NULL) {
		authlist = authctxt->authlist;
	} else {
		free(authctxt->authlist);
		authctxt->authlist = authlist;
	}
	for (;;) {
		Authmethod *method = authmethod_get(authlist);
		if (method == NULL)
			fatal("%s@@%s: Permission denied (%s).",
			    authctxt->server_user, authctxt->host, authlist);
		authctxt->method = method;

		/* reset the per method handler */
		dispatch_range(SSH2_MSG_USERAUTH_PER_METHOD_MIN,
		    SSH2_MSG_USERAUTH_PER_METHOD_MAX, NULL);

		/* and try new method */
		if (method->userauth(authctxt) != 0) {
			debug2("we sent a %s packet, wait for reply", method->name);
			break;
		} else {
			debug2("we did not send a packet, disable method");
			method->enabled = NULL;
		}
	}
}

/* ARGSUSED */
int
input_userauth_error(int type, u_int32_t seq, struct ssh *ssh)
{
	fatal("input_userauth_error: bad message during authentication: "
	    "type %d", type);
	return 0;
}

/* ARGSUSED */
int
input_userauth_banner(int type, u_int32_t seq, struct ssh *ssh)
{
	char *msg, *lang;
	u_int len;

	debug3("%s", __func__);
	msg = packet_get_string(&len);
	lang = packet_get_string(NULL);
	if (len > 0 && options.log_level >= SYSLOG_LEVEL_INFO)
		fmprintf(stderr, "%s", msg);
	free(msg);
	free(lang);
	return 0;
}

/* ARGSUSED */
int
input_userauth_success(int type, u_int32_t seq, struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;

	if (authctxt == NULL)
		fatal("input_userauth_success: no authentication context");
	free(authctxt->authlist);
	authctxt->authlist = NULL;
	if (authctxt->method != NULL && authctxt->method->cleanup != NULL)
		authctxt->method->cleanup(authctxt);
	free(authctxt->methoddata);
	authctxt->methoddata = NULL;
	authctxt->success = 1;			/* break out */
	return 0;
}

int
input_userauth_success_unexpected(int type, u_int32_t seq, struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;

	if (authctxt == NULL)
		fatal("%s: no authentication context", __func__);

	fatal("Unexpected authentication success during %s.",
	    authctxt->method->name);
	return 0;
}

/* ARGSUSED */
int
input_userauth_failure(int type, u_int32_t seq, struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	char *authlist = NULL;
	int partial;

	if (authctxt == NULL)
		fatal("input_userauth_failure: no authentication context");

	authlist = packet_get_string(NULL);
	partial = packet_get_char();
	packet_check_eom();

	if (partial != 0) {
		verbose("Authenticated with partial success.");
		/* reset state */
		pubkey_reset(authctxt);
	}
	debug("Authentications that can continue: %s", authlist);

	userauth(authctxt, authlist);
	return 0;
}

/* ARGSUSED */
int
input_userauth_pk_ok(int type, u_int32_t seq, struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	struct sshkey *key = NULL;
	Identity *id = NULL;
	Buffer b;
	int pktype, sent = 0;
	u_int alen, blen;
	char *pkalg, *fp;
	u_char *pkblob;

	if (authctxt == NULL)
		fatal("input_userauth_pk_ok: no authentication context");
	if (datafellows & SSH_BUG_PKOK) {
		/* this is similar to SSH_BUG_PKAUTH */
		debug2("input_userauth_pk_ok: SSH_BUG_PKOK");
		pkblob = packet_get_string(&blen);
		buffer_init(&b);
		buffer_append(&b, pkblob, blen);
		pkalg = buffer_get_string(&b, &alen);
		buffer_free(&b);
	} else {
		pkalg = packet_get_string(&alen);
		pkblob = packet_get_string(&blen);
	}
	packet_check_eom();

	debug("Server accepts key: pkalg %s blen %u", pkalg, blen);

	if ((pktype = key_type_from_name(pkalg)) == KEY_UNSPEC) {
		debug("unknown pkalg %s", pkalg);
		goto done;
	}
	if ((key = key_from_blob(pkblob, blen)) == NULL) {
		debug("no key from blob. pkalg %s", pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error("input_userauth_pk_ok: type mismatch "
		    "for decoded key (received %d, expected %d)",
		    key->type, pktype);
		goto done;
	}
	if ((fp = sshkey_fingerprint(key, options.fingerprint_hash,
	    SSH_FP_DEFAULT)) == NULL)
		goto done;
	debug2("input_userauth_pk_ok: fp %s", fp);
	free(fp);

	/*
	 * search keys in the reverse order, because last candidate has been
	 * moved to the end of the queue.  this also avoids confusion by
	 * duplicate keys
	 */
	TAILQ_FOREACH_REVERSE(id, &authctxt->keys, idlist, next) {
		if (key_equal(key, id->key)) {
			sent = sign_and_send_pubkey(authctxt, id);
			break;
		}
	}
done:
	if (key != NULL)
		key_free(key);
	free(pkalg);
	free(pkblob);

	/* try another method if we did not send a packet */
	if (sent == 0)
		userauth(authctxt, NULL);
	return 0;
}

#ifdef GSSAPI
int
userauth_gssapi(Authctxt *authctxt)
{
	Gssctxt *gssctxt = NULL;
	static gss_OID_set gss_supported = NULL;
	static u_int mech = 0;
	OM_uint32 min;
	int ok = 0;

	/* Try one GSSAPI method at a time, rather than sending them all at
	 * once. */

	if (gss_supported == NULL)
		gss_indicate_mechs(&min, &gss_supported);

	/* Check to see if the mechanism is usable before we offer it */
	while (mech < gss_supported->count && !ok) {
		/* My DER encoding requires length<128 */
		if (gss_supported->elements[mech].length < 128 &&
		    ssh_gssapi_check_mechanism(&gssctxt, 
		    &gss_supported->elements[mech], authctxt->host)) {
			ok = 1; /* Mechanism works */
		} else {
			mech++;
		}
	}

	if (!ok)
		return 0;

	authctxt->methoddata=(void *)gssctxt;

	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);

	packet_put_int(1);

	packet_put_int((gss_supported->elements[mech].length) + 2);
	packet_put_char(SSH_GSS_OIDTYPE);
	packet_put_char(gss_supported->elements[mech].length);
	packet_put_raw(gss_supported->elements[mech].elements,
	    gss_supported->elements[mech].length);

	packet_send();

	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_RESPONSE, &input_gssapi_response);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_ERROR, &input_gssapi_error);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);

	mech++; /* Move along to next candidate */

	return 1;
}

static OM_uint32
process_gssapi_token(struct ssh *ssh, gss_buffer_t recv_tok)
{
	Authctxt *authctxt = ssh->authctxt;
	Gssctxt *gssctxt = authctxt->methoddata;
	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;
	gss_buffer_desc mic = GSS_C_EMPTY_BUFFER;
	gss_buffer_desc gssbuf;
	OM_uint32 status, ms, flags;
	Buffer b;

	status = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,
	    recv_tok, &send_tok, &flags);

	if (send_tok.length > 0) {
		if (GSS_ERROR(status))
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK);
		else
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_TOKEN);

		packet_put_string(send_tok.value, send_tok.length);
		packet_send();
		gss_release_buffer(&ms, &send_tok);
	}

	if (status == GSS_S_COMPLETE) {
		/* send either complete or MIC, depending on mechanism */
		if (!(flags & GSS_C_INTEG_FLAG)) {
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE);
			packet_send();
		} else {
			ssh_gssapi_buildmic(&b, authctxt->server_user,
			    authctxt->service, "gssapi-with-mic");

			gssbuf.value = buffer_ptr(&b);
			gssbuf.length = buffer_len(&b);

			status = ssh_gssapi_sign(gssctxt, &gssbuf, &mic);

			if (!GSS_ERROR(status)) {
				packet_start(SSH2_MSG_USERAUTH_GSSAPI_MIC);
				packet_put_string(mic.value, mic.length);

				packet_send();
			}

			buffer_free(&b);
			gss_release_buffer(&ms, &mic);
		}
	}

	return status;
}

/* ARGSUSED */
int
input_gssapi_response(int type, u_int32_t plen, struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	Gssctxt *gssctxt;
	int oidlen;
	char *oidv;

	if (authctxt == NULL)
		fatal("input_gssapi_response: no authentication context");
	gssctxt = authctxt->methoddata;

	/* Setup our OID */
	oidv = packet_get_string(&oidlen);

	if (oidlen <= 2 ||
	    oidv[0] != SSH_GSS_OIDTYPE ||
	    oidv[1] != oidlen - 2) {
		free(oidv);
		debug("Badly encoded mechanism OID received");
		userauth(authctxt, NULL);
		return 0;
	}

	if (!ssh_gssapi_check_oid(gssctxt, oidv + 2, oidlen - 2))
		fatal("Server returned different OID than expected");

	packet_check_eom();

	free(oidv);

	if (GSS_ERROR(process_gssapi_token(ssh, GSS_C_NO_BUFFER))) {
		/* Start again with next method on list */
		debug("Trying to start again");
		userauth(authctxt, NULL);
		return 0;
	}
	return 0;
}

/* ARGSUSED */
int
input_gssapi_token(int type, u_int32_t plen, struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	gss_buffer_desc recv_tok;
	OM_uint32 status;
	u_int slen;

	if (authctxt == NULL)
		fatal("input_gssapi_response: no authentication context");

	recv_tok.value = packet_get_string(&slen);
	recv_tok.length = slen;	/* safe typecast */

	packet_check_eom();

	status = process_gssapi_token(ssh, &recv_tok);

	free(recv_tok.value);

	if (GSS_ERROR(status)) {
		/* Start again with the next method in the list */
		userauth(authctxt, NULL);
		return 0;
	}
	return 0;
}

/* ARGSUSED */
int
input_gssapi_errtok(int type, u_int32_t plen, struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	Gssctxt *gssctxt;
	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;
	gss_buffer_desc recv_tok;
	OM_uint32 ms;
	u_int len;

	if (authctxt == NULL)
		fatal("input_gssapi_response: no authentication context");
	gssctxt = authctxt->methoddata;

	recv_tok.value = packet_get_string(&len);
	recv_tok.length = len;

	packet_check_eom();

	/* Stick it into GSSAPI and see what it says */
	(void)ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,
	    &recv_tok, &send_tok, NULL);

	free(recv_tok.value);
	gss_release_buffer(&ms, &send_tok);

	/* Server will be returning a failed packet after this one */
	return 0;
}

/* ARGSUSED */
int
input_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)
{
	char *msg;
	char *lang;

	/* maj */(void)packet_get_int();
	/* min */(void)packet_get_int();
	msg=packet_get_string(NULL);
	lang=packet_get_string(NULL);

	packet_check_eom();

	debug("Server GSSAPI Error:\n%s", msg);
	free(msg);
	free(lang);
	return 0;
}
#endif /* GSSAPI */

int
userauth_none(Authctxt *authctxt)
{
	/* initial userauth request */
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
	packet_send();
	return 1;
}

int
userauth_passwd(Authctxt *authctxt)
{
	static int attempt = 0;
	char prompt[256];
	char *password;
	const char *host = options.host_key_alias ?  options.host_key_alias :
	    authctxt->host;

	if (attempt++ >= options.number_of_password_prompts)
		return 0;

	if (attempt != 1)
		error("Permission denied, please try again.");

	snprintf(prompt, sizeof(prompt), "%.30s@@%.128s's password: ",
	    authctxt->server_user, host);
	password = read_passphrase(prompt, 0);
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
	packet_put_char(0);
	packet_put_cstring(password);
	explicit_bzero(password, strlen(password));
	free(password);
	packet_add_padding(64);
	packet_send();

	dispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,
	    &input_userauth_passwd_changereq);

	return 1;
}

/*
 * parse PASSWD_CHANGEREQ, prompt user and send SSH2_MSG_USERAUTH_REQUEST
 */
/* ARGSUSED */
int
input_userauth_passwd_changereq(int type, u_int32_t seqnr, struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	char *info, *lang, *password = NULL, *retype = NULL;
	char prompt[256];
	const char *host;

	debug2("input_userauth_passwd_changereq");

	if (authctxt == NULL)
		fatal("input_userauth_passwd_changereq: "
		    "no authentication context");
	host = options.host_key_alias ? options.host_key_alias : authctxt->host;

	info = packet_get_string(NULL);
	lang = packet_get_string(NULL);
	if (strlen(info) > 0)
		logit("%s", info);
	free(info);
	free(lang);
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
	packet_put_char(1);			/* additional info */
	snprintf(prompt, sizeof(prompt),
	    "Enter %.30s@@%.128s's old password: ",
	    authctxt->server_user, host);
	password = read_passphrase(prompt, 0);
	packet_put_cstring(password);
	explicit_bzero(password, strlen(password));
	free(password);
	password = NULL;
	while (password == NULL) {
		snprintf(prompt, sizeof(prompt),
		    "Enter %.30s@@%.128s's new password: ",
		    authctxt->server_user, host);
		password = read_passphrase(prompt, RP_ALLOW_EOF);
		if (password == NULL) {
			/* bail out */
			return 0;
		}
		snprintf(prompt, sizeof(prompt),
		    "Retype %.30s@@%.128s's new password: ",
		    authctxt->server_user, host);
		retype = read_passphrase(prompt, 0);
		if (strcmp(password, retype) != 0) {
			explicit_bzero(password, strlen(password));
			free(password);
			logit("Mismatch; try again, EOF to quit.");
			password = NULL;
		}
		explicit_bzero(retype, strlen(retype));
		free(retype);
	}
	packet_put_cstring(password);
	explicit_bzero(password, strlen(password));
	free(password);
	packet_add_padding(64);
	packet_send();

	dispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,
	    &input_userauth_passwd_changereq);
	return 0;
}

static const char *
key_sign_encode(const struct sshkey *key)
{
	struct ssh *ssh = active_state;

	if (key->type == KEY_RSA) {
		switch (ssh->kex->rsa_sha2) {
		case 256:
			return "rsa-sha2-256";
		case 512:
			return "rsa-sha2-512";
		}
	}
	return key_ssh_name(key);
}

static int
identity_sign(struct identity *id, u_char **sigp, size_t *lenp,
    const u_char *data, size_t datalen, u_int compat)
{
	struct sshkey *prv;
	int ret;

	/* the agent supports this key */
	if (id->key != NULL && id->agent_fd != -1)
		return ssh_agent_sign(id->agent_fd, id->key, sigp, lenp,
		    data, datalen, key_sign_encode(id->key), compat);

	/*
	 * we have already loaded the private key or
	 * the private key is stored in external hardware
	 */
	if (id->key != NULL &&
	    (id->isprivate || (id->key->flags & SSHKEY_FLAG_EXT)))
		return (sshkey_sign(id->key, sigp, lenp, data, datalen,
		    key_sign_encode(id->key), compat));

	/* load the private key from the file */
	if ((prv = load_identity_file(id)) == NULL)
		return SSH_ERR_KEY_NOT_FOUND;
	if (id->key != NULL && !sshkey_equal_public(prv, id->key)) {
		error("%s: private key %s contents do not match public",
		   __func__, id->filename);
		return SSH_ERR_KEY_NOT_FOUND;
	}
	ret = sshkey_sign(prv, sigp, lenp, data, datalen,
	    key_sign_encode(prv), compat);
	sshkey_free(prv);
	return (ret);
}

static int
id_filename_matches(Identity *id, Identity *private_id)
{
	const char *suffixes[] = { ".pub", "-cert.pub", NULL };
	size_t len = strlen(id->filename), plen = strlen(private_id->filename);
	size_t i, slen;

	if (strcmp(id->filename, private_id->filename) == 0)
		return 1;
	for (i = 0; suffixes[i]; i++) {
		slen = strlen(suffixes[i]);
		if (len > slen && plen == len - slen &&
		    strcmp(id->filename + (len - slen), suffixes[i]) == 0 &&
		    memcmp(id->filename, private_id->filename, plen) == 0)
			return 1;
	}
	return 0;
}

static int
sign_and_send_pubkey(Authctxt *authctxt, Identity *id)
{
	Buffer b;
	Identity *private_id;
	u_char *blob, *signature;
	size_t slen;
	u_int bloblen, skip = 0;
	int matched, ret = -1, have_sig = 1;
	char *fp;

	if ((fp = sshkey_fingerprint(id->key, options.fingerprint_hash,
	    SSH_FP_DEFAULT)) == NULL)
		return 0;
	debug3("%s: %s %s", __func__, key_type(id->key), fp);
	free(fp);

	if (key_to_blob(id->key, &blob, &bloblen) == 0) {
		/* we cannot handle this key */
		debug3("sign_and_send_pubkey: cannot handle key");
		return 0;
	}
	/* data to be signed */
	buffer_init(&b);
	if (datafellows & SSH_OLD_SESSIONID) {
		buffer_append(&b, session_id2, session_id2_len);
		skip = session_id2_len;
	} else {
		buffer_put_string(&b, session_id2, session_id2_len);
		skip = buffer_len(&b);
	}
	buffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);
	buffer_put_cstring(&b, authctxt->server_user);
	buffer_put_cstring(&b,
	    datafellows & SSH_BUG_PKSERVICE ?
	    "ssh-userauth" :
	    authctxt->service);
	if (datafellows & SSH_BUG_PKAUTH) {
		buffer_put_char(&b, have_sig);
	} else {
		buffer_put_cstring(&b, authctxt->method->name);
		buffer_put_char(&b, have_sig);
		buffer_put_cstring(&b, key_sign_encode(id->key));
	}
	buffer_put_string(&b, blob, bloblen);

	/*
	 * If the key is an certificate, try to find a matching private key
	 * and use it to complete the signature.
	 * If no such private key exists, fall back to trying the certificate
	 * key itself in case it has a private half already loaded.
	 */
	if (key_is_cert(id->key)) {
		matched = 0;
		TAILQ_FOREACH(private_id, &authctxt->keys, next) {
			if (sshkey_equal_public(id->key, private_id->key) &&
			    id->key->type != private_id->key->type) {
				id = private_id;
				matched = 1;
				break;
			}
		}
		/*
		 * Exact key matches are preferred, but also allow
		 * filename matches for non-PKCS#11/agent keys that
		 * didn't load public keys. This supports the case
		 * of keeping just a private key file and public
		 * certificate on disk.
		 */
		if (!matched && !id->isprivate && id->agent_fd == -1 &&
		    (id->key->flags & SSHKEY_FLAG_EXT) == 0) {
			TAILQ_FOREACH(private_id, &authctxt->keys, next) {
				if (private_id->key == NULL &&
				    id_filename_matches(id, private_id)) {
					id = private_id;
					matched = 1;
					break;
				}
			}
		}
		if (matched) {
			debug2("%s: using private key \"%s\"%s for "
			    "certificate", __func__, id->filename,
			    id->agent_fd != -1 ? " from agent" : "");
		} else {
			debug("%s: no separate private key for certificate "
			    "\"%s\"", __func__, id->filename);
		}
	}

	/* generate signature */
	ret = identity_sign(id, &signature, &slen,
	    buffer_ptr(&b), buffer_len(&b), datafellows);
	if (ret != 0) {
		if (ret != SSH_ERR_KEY_NOT_FOUND)
			error("%s: signing failed: %s", __func__, ssh_err(ret));
		free(blob);
		buffer_free(&b);
		return 0;
	}
#ifdef DEBUG_PK
	buffer_dump(&b);
#endif
	if (datafellows & SSH_BUG_PKSERVICE) {
		buffer_clear(&b);
		buffer_append(&b, session_id2, session_id2_len);
		skip = session_id2_len;
		buffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);
		buffer_put_cstring(&b, authctxt->server_user);
		buffer_put_cstring(&b, authctxt->service);
		buffer_put_cstring(&b, authctxt->method->name);
		buffer_put_char(&b, have_sig);
		if (!(datafellows & SSH_BUG_PKAUTH))
			buffer_put_cstring(&b, key_ssh_name(id->key));
		buffer_put_string(&b, blob, bloblen);
	}
	free(blob);

	/* append signature */
	buffer_put_string(&b, signature, slen);
	free(signature);

	/* skip session id and packet type */
	if (buffer_len(&b) < skip + 1)
		fatal("userauth_pubkey: internal error");
	buffer_consume(&b, skip + 1);

	/* put remaining data from buffer into packet */
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_raw(buffer_ptr(&b), buffer_len(&b));
	buffer_free(&b);
	packet_send();

	return 1;
}

static int
send_pubkey_test(Authctxt *authctxt, Identity *id)
{
	u_char *blob;
	u_int bloblen, have_sig = 0;

	debug3("send_pubkey_test");

	if (key_to_blob(id->key, &blob, &bloblen) == 0) {
		/* we cannot handle this key */
		debug3("send_pubkey_test: cannot handle key");
		return 0;
	}
	/* register callback for USERAUTH_PK_OK message */
	dispatch_set(SSH2_MSG_USERAUTH_PK_OK, &input_userauth_pk_ok);

	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
	packet_put_char(have_sig);
	if (!(datafellows & SSH_BUG_PKAUTH))
		packet_put_cstring(key_sign_encode(id->key));
	packet_put_string(blob, bloblen);
	free(blob);
	packet_send();
	return 1;
}

static struct sshkey *
load_identity_file(Identity *id)
{
	struct sshkey *private = NULL;
	char prompt[300], *passphrase, *comment;
	int r, perm_ok = 0, quit = 0, i;
	struct stat st;

	if (stat(id->filename, &st) < 0) {
		(id->userprovided ? logit : debug3)("no such identity: %s: %s",
		    id->filename, strerror(errno));
		return NULL;
	}
	snprintf(prompt, sizeof prompt,
	    "Enter passphrase for key '%.100s': ", id->filename);
	for (i = 0; i <= options.number_of_password_prompts; i++) {
		if (i == 0)
			passphrase = "";
		else {
			passphrase = read_passphrase(prompt, 0);
			if (*passphrase == '\0') {
				debug2("no passphrase given, try next key");
				free(passphrase);
				break;
			}
		}
		switch ((r = sshkey_load_private_type(KEY_UNSPEC, id->filename,
		    passphrase, &private, &comment, &perm_ok))) {
		case 0:
			break;
		case SSH_ERR_KEY_WRONG_PASSPHRASE:
			if (options.batch_mode) {
				quit = 1;
				break;
			}
			if (i != 0)
				debug2("bad passphrase given, try again...");
			break;
		case SSH_ERR_SYSTEM_ERROR:
			if (errno == ENOENT) {
				debug2("Load key \"%s\": %s",
				    id->filename, ssh_err(r));
				quit = 1;
				break;
			}
			/* FALLTHROUGH */
		default:
			error("Load key \"%s\": %s", id->filename, ssh_err(r));
			quit = 1;
			break;
		}
		if (!quit && private != NULL && id->agent_fd == -1 &&
		    !(id->key && id->isprivate))
			maybe_add_key_to_agent(id->filename, private, comment,
			    passphrase);
		if (i > 0) {
			explicit_bzero(passphrase, strlen(passphrase));
			free(passphrase);
		}
		free(comment);
		if (private != NULL || quit)
			break;
	}
	return private;
}

/*
 * try keys in the following order:
 * 	1. certificates listed in the config file
 * 	2. other input certificates
 *	3. agent keys that are found in the config file
 *	4. other agent keys
 *	5. keys that are only listed in the config file
 */
static void
pubkey_prepare(Authctxt *authctxt)
{
	struct identity *id, *id2, *tmp;
	struct idlist agent, files, *preferred;
	struct sshkey *key;
	int agent_fd = -1, i, r, found;
	size_t j;
	struct ssh_identitylist *idlist;

	TAILQ_INIT(&agent);	/* keys from the agent */
	TAILQ_INIT(&files);	/* keys from the config file */
	preferred = &authctxt->keys;
	TAILQ_INIT(preferred);	/* preferred order of keys */

	/* list of keys stored in the filesystem and PKCS#11 */
	for (i = 0; i < options.num_identity_files; i++) {
		key = options.identity_keys[i];
		if (key && key->cert && key->cert->type != SSH2_CERT_TYPE_USER)
			continue;
		options.identity_keys[i] = NULL;
		id = xcalloc(1, sizeof(*id));
		id->agent_fd = -1;
		id->key = key;
		id->filename = xstrdup(options.identity_files[i]);
		id->userprovided = options.identity_file_userprovided[i];
		TAILQ_INSERT_TAIL(&files, id, next);
	}
	/* list of certificates specified by user */
	for (i = 0; i < options.num_certificate_files; i++) {
		key = options.certificates[i];
		if (!key_is_cert(key) || key->cert == NULL ||
		    key->cert->type != SSH2_CERT_TYPE_USER)
			continue;
		id = xcalloc(1, sizeof(*id));
		id->agent_fd = -1;
		id->key = key;
		id->filename = xstrdup(options.certificate_files[i]);
		id->userprovided = options.certificate_file_userprovided[i];
		TAILQ_INSERT_TAIL(preferred, id, next);
	}
	/* list of keys supported by the agent */
	if ((r = ssh_get_authentication_socket(&agent_fd)) != 0) {
		if (r != SSH_ERR_AGENT_NOT_PRESENT)
			debug("%s: ssh_get_authentication_socket: %s",
			    __func__, ssh_err(r));
	} else if ((r = ssh_fetch_identitylist(agent_fd, &idlist)) != 0) {
		if (r != SSH_ERR_AGENT_NO_IDENTITIES)
			debug("%s: ssh_fetch_identitylist: %s",
			    __func__, ssh_err(r));
		close(agent_fd);
	} else {
		for (j = 0; j < idlist->nkeys; j++) {
			found = 0;
			TAILQ_FOREACH(id, &files, next) {
				/*
				 * agent keys from the config file are
				 * preferred
				 */
				if (sshkey_equal(idlist->keys[j], id->key)) {
					TAILQ_REMOVE(&files, id, next);
					TAILQ_INSERT_TAIL(preferred, id, next);
					id->agent_fd = agent_fd;
					found = 1;
					break;
				}
			}
			if (!found && !options.identities_only) {
				id = xcalloc(1, sizeof(*id));
				/* XXX "steals" key/comment from idlist */
				id->key = idlist->keys[j];
				id->filename = idlist->comments[j];
				idlist->keys[j] = NULL;
				idlist->comments[j] = NULL;
				id->agent_fd = agent_fd;
				TAILQ_INSERT_TAIL(&agent, id, next);
			}
		}
		ssh_free_identitylist(idlist);
		/* append remaining agent keys */
		for (id = TAILQ_FIRST(&agent); id; id = TAILQ_FIRST(&agent)) {
			TAILQ_REMOVE(&agent, id, next);
			TAILQ_INSERT_TAIL(preferred, id, next);
		}
		authctxt->agent_fd = agent_fd;
	}
	/* Prefer PKCS11 keys that are explicitly listed */
	TAILQ_FOREACH_SAFE(id, &files, next, tmp) {
		if (id->key == NULL || (id->key->flags & SSHKEY_FLAG_EXT) == 0)
			continue;
		found = 0;
		TAILQ_FOREACH(id2, &files, next) {
			if (id2->key == NULL ||
			    (id2->key->flags & SSHKEY_FLAG_EXT) == 0)
				continue;
			if (sshkey_equal(id->key, id2->key)) {
				TAILQ_REMOVE(&files, id, next);
				TAILQ_INSERT_TAIL(preferred, id, next);
				found = 1;
				break;
			}
		}
		/* If IdentitiesOnly set and key not found then don't use it */
		if (!found && options.identities_only) {
			TAILQ_REMOVE(&files, id, next);
			explicit_bzero(id, sizeof(*id));
			free(id);
		}
	}
	/* append remaining keys from the config file */
	for (id = TAILQ_FIRST(&files); id; id = TAILQ_FIRST(&files)) {
		TAILQ_REMOVE(&files, id, next);
		TAILQ_INSERT_TAIL(preferred, id, next);
	}
	/* finally, filter by PubkeyAcceptedKeyTypes */
	TAILQ_FOREACH_SAFE(id, preferred, next, id2) {
		if (id->key != NULL &&
		    match_pattern_list(sshkey_ssh_name(id->key),
		    options.pubkey_key_types, 0) != 1) {
			debug("Skipping %s key %s - "
			    "not in PubkeyAcceptedKeyTypes",
			    sshkey_ssh_name(id->key), id->filename);
			TAILQ_REMOVE(preferred, id, next);
			sshkey_free(id->key);
			free(id->filename);
			memset(id, 0, sizeof(*id));
			continue;
		}
		debug2("key: %s (%p)%s%s", id->filename, id->key,
		    id->userprovided ? ", explicit" : "",
		    id->agent_fd != -1 ? ", agent" : "");
	}
}

static void
pubkey_cleanup(Authctxt *authctxt)
{
	Identity *id;

	if (authctxt->agent_fd != -1)
		ssh_close_authentication_socket(authctxt->agent_fd);
	for (id = TAILQ_FIRST(&authctxt->keys); id;
	    id = TAILQ_FIRST(&authctxt->keys)) {
		TAILQ_REMOVE(&authctxt->keys, id, next);
		sshkey_free(id->key);
		free(id->filename);
		free(id);
	}
}

static void
pubkey_reset(Authctxt *authctxt)
{
	Identity *id;

	TAILQ_FOREACH(id, &authctxt->keys, next)
		id->tried = 0;
}

static int
try_identity(Identity *id)
{
	if (!id->key)
		return (0);
	if (key_type_plain(id->key->type) == KEY_RSA &&
	    (datafellows & SSH_BUG_RSASIGMD5) != 0) {
		debug("Skipped %s key %s for RSA/MD5 server",
		    key_type(id->key), id->filename);
		return (0);
	}
	return 1;
}

int
userauth_pubkey(Authctxt *authctxt)
{
	Identity *id;
	int sent = 0;
	char *fp;

	while ((id = TAILQ_FIRST(&authctxt->keys))) {
		if (id->tried++)
			return (0);
		/* move key to the end of the queue */
		TAILQ_REMOVE(&authctxt->keys, id, next);
		TAILQ_INSERT_TAIL(&authctxt->keys, id, next);
		/*
		 * send a test message if we have the public key. for
		 * encrypted keys we cannot do this and have to load the
		 * private key instead
		 */
		if (id->key != NULL) {
			if (try_identity(id)) {
				if ((fp = sshkey_fingerprint(id->key,
				    options.fingerprint_hash,
				    SSH_FP_DEFAULT)) == NULL) {
					error("%s: sshkey_fingerprint failed",
					    __func__);
					return 0;
				}
				debug("Offering public key: %s %s %s",
				    sshkey_type(id->key), fp, id->filename);
				free(fp);
				sent = send_pubkey_test(authctxt, id);
			}
		} else {
			debug("Trying private key: %s", id->filename);
			id->key = load_identity_file(id);
			if (id->key != NULL) {
				if (try_identity(id)) {
					id->isprivate = 1;
					sent = sign_and_send_pubkey(
					    authctxt, id);
				}
				key_free(id->key);
				id->key = NULL;
				id->isprivate = 0;
			}
		}
		if (sent)
			return (sent);
	}
	return (0);
}

/*
 * Send userauth request message specifying keyboard-interactive method.
 */
int
userauth_kbdint(Authctxt *authctxt)
{
	static int attempt = 0;

	if (attempt++ >= options.number_of_password_prompts)
		return 0;
	/* disable if no SSH2_MSG_USERAUTH_INFO_REQUEST has been seen */
	if (attempt > 1 && !authctxt->info_req_seen) {
		debug3("userauth_kbdint: disable: no info_req_seen");
		dispatch_set(SSH2_MSG_USERAUTH_INFO_REQUEST, NULL);
		return 0;
	}

	debug2("userauth_kbdint");
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
	packet_put_cstring("");					/* lang */
	packet_put_cstring(options.kbd_interactive_devices ?
	    options.kbd_interactive_devices : "");
	packet_send();

	dispatch_set(SSH2_MSG_USERAUTH_INFO_REQUEST, &input_userauth_info_req);
	return 1;
}

/*
 * parse INFO_REQUEST, prompt user and send INFO_RESPONSE
 */
int
input_userauth_info_req(int type, u_int32_t seq, struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	char *name, *inst, *lang, *prompt, *response;
	u_int num_prompts, i;
	int echo = 0;

	debug2("input_userauth_info_req");

	if (authctxt == NULL)
		fatal("input_userauth_info_req: no authentication context");

	authctxt->info_req_seen = 1;

	name = packet_get_string(NULL);
	inst = packet_get_string(NULL);
	lang = packet_get_string(NULL);
	if (strlen(name) > 0)
		logit("%s", name);
	if (strlen(inst) > 0)
		logit("%s", inst);
	free(name);
	free(inst);
	free(lang);

	num_prompts = packet_get_int();
	/*
	 * Begin to build info response packet based on prompts requested.
	 * We commit to providing the correct number of responses, so if
	 * further on we run into a problem that prevents this, we have to
	 * be sure and clean this up and send a correct error response.
	 */
	packet_start(SSH2_MSG_USERAUTH_INFO_RESPONSE);
	packet_put_int(num_prompts);

	debug2("input_userauth_info_req: num_prompts %d", num_prompts);
	for (i = 0; i < num_prompts; i++) {
		prompt = packet_get_string(NULL);
		echo = packet_get_char();

		response = read_passphrase(prompt, echo ? RP_ECHO : 0);

		packet_put_cstring(response);
		explicit_bzero(response, strlen(response));
		free(response);
		free(prompt);
	}
	packet_check_eom(); /* done with parsing incoming message. */

	packet_add_padding(64);
	packet_send();
	return 0;
}

static int
ssh_keysign(struct sshkey *key, u_char **sigp, size_t *lenp,
    const u_char *data, size_t datalen)
{
	struct sshbuf *b;
	struct stat st;
	pid_t pid;
	int i, r, to[2], from[2], status, sock = packet_get_connection_in();
	u_char rversion = 0, version = 2;
	void (*osigchld)(int);

	*sigp = NULL;
	*lenp = 0;

	if (stat(_PATH_SSH_KEY_SIGN, &st) < 0) {
		error("%s: not installed: %s", __func__, strerror(errno));
		return -1;
	}
	if (fflush(stdout) != 0) {
		error("%s: fflush: %s", __func__, strerror(errno));
		return -1;
	}
	if (pipe(to) < 0) {
		error("%s: pipe: %s", __func__, strerror(errno));
		return -1;
	}
	if (pipe(from) < 0) {
		error("%s: pipe: %s", __func__, strerror(errno));
		return -1;
	}
	if ((pid = fork()) < 0) {
		error("%s: fork: %s", __func__, strerror(errno));
		return -1;
	}
	osigchld = signal(SIGCHLD, SIG_DFL);
	if (pid == 0) {
		/* keep the socket on exec */
		fcntl(sock, F_SETFD, 0);
		permanently_drop_suid(getuid());
		close(from[0]);
		if (dup2(from[1], STDOUT_FILENO) < 0)
			fatal("%s: dup2: %s", __func__, strerror(errno));
		close(to[1]);
		if (dup2(to[0], STDIN_FILENO) < 0)
			fatal("%s: dup2: %s", __func__, strerror(errno));
		close(from[1]);
		close(to[0]);
		/* Close everything but stdio and the socket */
		for (i = STDERR_FILENO + 1; i < sock; i++)
			close(i);
		closefrom(sock + 1);
		debug3("%s: [child] pid=%ld, exec %s",
		    __func__, (long)getpid(), _PATH_SSH_KEY_SIGN);
		execl(_PATH_SSH_KEY_SIGN, _PATH_SSH_KEY_SIGN, (char *)NULL);
		fatal("%s: exec(%s): %s", __func__, _PATH_SSH_KEY_SIGN,
		    strerror(errno));
	}
	close(from[1]);
	close(to[0]);

	if ((b = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	/* send # of sock, data to be signed */
	if ((r = sshbuf_put_u32(b, sock)) != 0 ||
	    (r = sshbuf_put_string(b, data, datalen)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (ssh_msg_send(to[1], version, b) == -1)
		fatal("%s: couldn't send request", __func__);
	sshbuf_reset(b);
	r = ssh_msg_recv(from[0], b);
	close(from[0]);
	close(to[1]);
	if (r < 0) {
		error("%s: no reply", __func__);
		goto fail;
	}

	errno = 0;
	while (waitpid(pid, &status, 0) < 0) {
		if (errno != EINTR) {
			error("%s: waitpid %ld: %s",
			    __func__, (long)pid, strerror(errno));
			goto fail;
		}
	}
	if (!WIFEXITED(status)) {
		error("%s: exited abnormally", __func__);
		goto fail;
	}
	if (WEXITSTATUS(status) != 0) {
		error("%s: exited with status %d",
		    __func__, WEXITSTATUS(status));
		goto fail;
	}
	if ((r = sshbuf_get_u8(b, &rversion)) != 0) {
		error("%s: buffer error: %s", __func__, ssh_err(r));
		goto fail;
	}
	if (rversion != version) {
		error("%s: bad version", __func__);
		goto fail;
	}
	if ((r = sshbuf_get_string(b, sigp, lenp)) != 0) {
		error("%s: buffer error: %s", __func__, ssh_err(r));
 fail:
		signal(SIGCHLD, osigchld);
		sshbuf_free(b);
		return -1;
	}
	signal(SIGCHLD, osigchld);
	sshbuf_free(b);

	return 0;
}

int
userauth_hostbased(Authctxt *authctxt)
{
	struct ssh *ssh = active_state;
	struct sshkey *private = NULL;
	struct sshbuf *b = NULL;
	const char *service;
	u_char *sig = NULL, *keyblob = NULL;
	char *fp = NULL, *chost = NULL, *lname = NULL;
	size_t siglen = 0, keylen = 0;
	int i, r, success = 0;

	if (authctxt->ktypes == NULL) {
		authctxt->oktypes = xstrdup(options.hostbased_key_types);
		authctxt->ktypes = authctxt->oktypes;
	}

	/*
	 * Work through each listed type pattern in HostbasedKeyTypes,
	 * trying each hostkey that matches the type in turn.
	 */
	for (;;) {
		if (authctxt->active_ktype == NULL)
			authctxt->active_ktype = strsep(&authctxt->ktypes, ",");
		if (authctxt->active_ktype == NULL ||
		    *authctxt->active_ktype == '\0')
			break;
		debug3("%s: trying key type %s", __func__,
		    authctxt->active_ktype);

		/* check for a useful key */
		private = NULL;
		for (i = 0; i < authctxt->sensitive->nkeys; i++) {
			if (authctxt->sensitive->keys[i] == NULL ||
			    authctxt->sensitive->keys[i]->type == KEY_UNSPEC)
				continue;
			if (match_pattern_list(
			    sshkey_ssh_name(authctxt->sensitive->keys[i]),
			    authctxt->active_ktype, 0) != 1)
				continue;
			/* we take and free the key */
			private = authctxt->sensitive->keys[i];
			authctxt->sensitive->keys[i] = NULL;
			break;
		}
		/* Found one */
		if (private != NULL)
			break;
		/* No more keys of this type; advance */
		authctxt->active_ktype = NULL;
	}
	if (private == NULL) {
		free(authctxt->oktypes);
		authctxt->oktypes = authctxt->ktypes = NULL;
		authctxt->active_ktype = NULL;
		debug("No more client hostkeys for hostbased authentication.");
		goto out;
	}

	if ((fp = sshkey_fingerprint(private, options.fingerprint_hash,
	    SSH_FP_DEFAULT)) == NULL) {
		error("%s: sshkey_fingerprint failed", __func__);
		goto out;
	}
	debug("%s: trying hostkey %s %s",
	    __func__, sshkey_ssh_name(private), fp);

	/* figure out a name for the client host */
	if ((lname = get_local_name(packet_get_connection_in())) == NULL) {
		error("%s: cannot get local ipaddr/name", __func__);
		goto out;
	}

	/* XXX sshbuf_put_stringf? */
	xasprintf(&chost, "%s.", lname);
	debug2("%s: chost %s", __func__, chost);

	service = datafellows & SSH_BUG_HBSERVICE ? "ssh-userauth" :
	    authctxt->service;

	/* construct data */
	if ((b = sshbuf_new()) == NULL) {
		error("%s: sshbuf_new failed", __func__);
		goto out;
	}
	if ((r = sshkey_to_blob(private, &keyblob, &keylen)) != 0) {
		error("%s: sshkey_to_blob: %s", __func__, ssh_err(r));
		goto out;
	}
	if ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||
	    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
	    (r = sshbuf_put_cstring(b, authctxt->server_user)) != 0 ||
	    (r = sshbuf_put_cstring(b, service)) != 0 ||
	    (r = sshbuf_put_cstring(b, authctxt->method->name)) != 0 ||
	    (r = sshbuf_put_cstring(b, key_ssh_name(private))) != 0 ||
	    (r = sshbuf_put_string(b, keyblob, keylen)) != 0 ||
	    (r = sshbuf_put_cstring(b, chost)) != 0 ||
	    (r = sshbuf_put_cstring(b, authctxt->local_user)) != 0) {
		error("%s: buffer error: %s", __func__, ssh_err(r));
		goto out;
	}

#ifdef DEBUG_PK
	sshbuf_dump(b, stderr);
#endif
	if (authctxt->sensitive->external_keysign)
		r = ssh_keysign(private, &sig, &siglen,
		    sshbuf_ptr(b), sshbuf_len(b));
	else if ((r = sshkey_sign(private, &sig, &siglen,
	    sshbuf_ptr(b), sshbuf_len(b), NULL, datafellows)) != 0)
		debug("%s: sshkey_sign: %s", __func__, ssh_err(r));
	if (r != 0) {
		error("sign using hostkey %s %s failed",
		    sshkey_ssh_name(private), fp);
		goto out;
	}
	if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
	    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||
	    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||
	    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||
	    (r = sshpkt_put_cstring(ssh, key_ssh_name(private))) != 0 ||
	    (r = sshpkt_put_string(ssh, keyblob, keylen)) != 0 ||
	    (r = sshpkt_put_cstring(ssh, chost)) != 0 ||
	    (r = sshpkt_put_cstring(ssh, authctxt->local_user)) != 0 ||
	    (r = sshpkt_put_string(ssh, sig, siglen)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0) {
		error("%s: packet error: %s", __func__, ssh_err(r));
		goto out;
	}
	success = 1;

 out:
	if (sig != NULL) {
		explicit_bzero(sig, siglen);
		free(sig);
	}
	free(keyblob);
	free(lname);
	free(fp);
	free(chost);
	sshkey_free(private);
	sshbuf_free(b);

	return success;
}

/* find auth method */

/*
 * given auth method name, if configurable options permit this method fill
 * in auth_ident field and return true, otherwise return false.
 */
static int
authmethod_is_enabled(Authmethod *method)
{
	if (method == NULL)
		return 0;
	/* return false if options indicate this method is disabled */
	if  (method->enabled == NULL || *method->enabled == 0)
		return 0;
	/* return false if batch mode is enabled but method needs interactive mode */
	if  (method->batch_flag != NULL && *method->batch_flag != 0)
		return 0;
	return 1;
}

static Authmethod *
authmethod_lookup(const char *name)
{
	Authmethod *method = NULL;
	if (name != NULL)
		for (method = authmethods; method->name != NULL; method++)
			if (strcmp(name, method->name) == 0)
				return method;
	debug2("Unrecognized authentication method name: %s", name ? name : "NULL");
	return NULL;
}

/* XXX internal state */
static Authmethod *current = NULL;
static char *supported = NULL;
static char *preferred = NULL;

/*
 * Given the authentication method list sent by the server, return the
 * next method we should try.  If the server initially sends a nil list,
 * use a built-in default list.
 */
static Authmethod *
authmethod_get(char *authlist)
{
	char *name = NULL;
	u_int next;

	/* Use a suitable default if we're passed a nil list.  */
	if (authlist == NULL || strlen(authlist) == 0)
		authlist = options.preferred_authentications;

	if (supported == NULL || strcmp(authlist, supported) != 0) {
		debug3("start over, passed a different list %s", authlist);
		free(supported);
		supported = xstrdup(authlist);
		preferred = options.preferred_authentications;
		debug3("preferred %s", preferred);
		current = NULL;
	} else if (current != NULL && authmethod_is_enabled(current))
		return current;

	for (;;) {
		if ((name = match_list(preferred, supported, &next)) == NULL) {
			debug("No more authentication methods to try.");
			current = NULL;
			return NULL;
		}
		preferred += next;
		debug3("authmethod_lookup %s", name);
		debug3("remaining preferred: %s", preferred);
		if ((current = authmethod_lookup(name)) != NULL &&
		    authmethod_is_enabled(current)) {
			debug3("authmethod_is_enabled %s", name);
			debug("Next authentication method: %s", name);
			free(name);
			return current;
		}
		free(name);
	}
}

static char *
authmethods_get(void)
{
	Authmethod *method = NULL;
	Buffer b;
	char *list;

	buffer_init(&b);
	for (method = authmethods; method->name != NULL; method++) {
		if (authmethod_is_enabled(method)) {
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			buffer_append(&b, method->name, strlen(method->name));
		}
	}
	if ((list = sshbuf_dup_string(&b)) == NULL)
		fatal("%s: sshbuf_dup_string failed", __func__);
	buffer_free(&b);
	return list;
}

@


1.265
log
@refuse to a private keys when its corresponding .pub key does not
match. bz#2737 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.264 2017/06/14 00:31:38 dtucker Exp $ */
d890 1
a890 1
	char prompt[150];
d930 1
a930 1
	char prompt[150];
@


1.264
log
@Add user@@host prefix to client's "Permisison denied" messages, useful in
particular when using "stacked" connections where it's not clear which
host is denying.  bz#2720, ok djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.263 2017/05/31 07:00:13 markus Exp $ */
d1032 5
@


1.263
log
@remove now obsolete ctx from ssh_dispatch_run; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.262 2017/05/31 05:08:46 djm Exp $ */
d464 2
a465 1
			fatal("Permission denied (%s).", authlist);
@


1.262
log
@another ctx => ssh conversion (in GSSAPI code)
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.261 2017/05/30 14:23:52 markus Exp $ */
d212 1
a212 1
	dispatch_run(DISPATCH_BLOCK, &kex->done, active_state);
d396 1
a396 1
	ssh_dispatch_run(ssh, DISPATCH_BLOCK, &authctxt.success, ssh);	/* loop until success */
@


1.261
log
@protocol handlers all get struct ssh passed; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.260 2017/05/30 14:19:15 markus Exp $ */
d698 1
a698 1
process_gssapi_token(void *ctxt, gss_buffer_t recv_tok)
a699 1
	struct ssh *ssh = ctxt;
d783 1
a783 1
	if (GSS_ERROR(process_gssapi_token(ctxt, GSS_C_NO_BUFFER))) {
d809 1
a809 1
	status = process_gssapi_token(ctxt, &recv_tok);
@


1.260
log
@ssh: pass struct ssh to auth functions, too; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.259 2017/05/30 08:52:20 markus Exp $ */
d282 10
a291 10
int	input_userauth_service_accept(int, u_int32_t, void *);
int	input_userauth_ext_info(int, u_int32_t, void *);
int	input_userauth_success(int, u_int32_t, void *);
int	input_userauth_success_unexpected(int, u_int32_t, void *);
int	input_userauth_failure(int, u_int32_t, void *);
int	input_userauth_banner(int, u_int32_t, void *);
int	input_userauth_error(int, u_int32_t, void *);
int	input_userauth_info_req(int, u_int32_t, void *);
int	input_userauth_pk_ok(int, u_int32_t, void *);
int	input_userauth_passwd_changereq(int, u_int32_t, void *);
d301 5
a305 5
int	input_gssapi_response(int type, u_int32_t, void *);
int	input_gssapi_token(int type, u_int32_t, void *);
int	input_gssapi_hash(int type, u_int32_t, void *);
int	input_gssapi_error(int, u_int32_t, void *);
int	input_gssapi_errtok(int, u_int32_t, void *);
d409 1
a409 1
input_userauth_service_accept(int type, u_int32_t seqnr, void *ctxt)
a410 1
	struct ssh *ssh = ctxt;
d442 1
a442 1
input_userauth_ext_info(int type, u_int32_t seqnr, void *ctxt)
d444 1
a444 1
	return kex_input_ext_info(type, seqnr, ctxt);
d484 1
a484 1
input_userauth_error(int type, u_int32_t seq, void *ctxt)
d493 1
a493 1
input_userauth_banner(int type, u_int32_t seq, void *ctxt)
d510 1
a510 1
input_userauth_success(int type, u_int32_t seq, void *ctxt)
a511 1
	struct ssh *ssh = ctxt;
d527 1
a527 1
input_userauth_success_unexpected(int type, u_int32_t seq, void *ctxt)
a528 1
	struct ssh *ssh = ctxt;
d541 1
a541 1
input_userauth_failure(int type, u_int32_t seq, void *ctxt)
a542 1
	struct ssh *ssh = ctxt;
d567 1
a567 1
input_userauth_pk_ok(int type, u_int32_t seq, void *ctxt)
a568 1
	struct ssh *ssh = ctxt;
d754 1
a754 1
input_gssapi_response(int type, u_int32_t plen, void *ctxt)
a755 1
	struct ssh *ssh = ctxt;
d795 1
a795 1
input_gssapi_token(int type, u_int32_t plen, void *ctxt)
a796 1
	struct ssh *ssh = ctxt;
d824 1
a824 1
input_gssapi_errtok(int type, u_int32_t plen, void *ctxt)
a825 1
	struct ssh *ssh = ctxt;
d855 1
a855 1
input_gssapi_error(int type, u_int32_t plen, void *ctxt)
d926 1
a926 1
input_userauth_passwd_changereq(int type, u_int32_t seqnr, void *ctxt)
a927 1
	struct ssh *ssh = ctxt;
d1556 1
a1556 1
input_userauth_info_req(int type, u_int32_t seq, void *ctxt)
a1557 1
	struct ssh *ssh = ctxt;
@


1.259
log
@switch from Key typedef with struct sshkey; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.258 2017/05/05 10:42:49 naddy Exp $ */
d392 1
d396 2
a397 1
	ssh_dispatch_run(ssh, DISPATCH_BLOCK, &authctxt.success, &authctxt);	/* loop until success */
d411 2
a412 2
	Authctxt *authctxt = ctxt;
	struct ssh *ssh = active_state;
d445 1
a445 1
	return kex_input_ext_info(type, seqnr, active_state);
d513 2
a514 1
	Authctxt *authctxt = ctxt;
d531 2
a532 1
	Authctxt *authctxt = ctxt;
d546 2
a547 1
	Authctxt *authctxt = ctxt;
d573 2
a574 1
	Authctxt *authctxt = ctxt;
d705 2
a706 1
	Authctxt *authctxt = ctxt;
d761 2
a762 1
	Authctxt *authctxt = ctxt;
d803 2
a804 1
	Authctxt *authctxt = ctxt;
d833 2
a834 1
	Authctxt *authctxt = ctxt;
d936 2
a937 1
	Authctxt *authctxt = ctxt;
d1567 2
a1568 1
	Authctxt *authctxt = ctxt;
@


1.258
log
@more simplification and removal of SSHv1-related code; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.257 2017/04/30 23:18:44 djm Exp $ */
d90 1
a90 1
verify_host_key_callback(Key *hostkey, struct ssh *ssh)
d314 1
a314 1
static Key *load_identity_file(Identity *);
d569 1
a569 1
	Key *key = NULL;
d1010 1
a1010 1
	Key *prv;
d1220 1
a1220 1
static Key *
d1223 1
a1223 1
	Key *private = NULL;
@


1.257
log
@remove KEY_RSA1

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.256 2017/04/28 03:24:53 djm Exp $ */
d1340 1
a1340 1
	} else if ((r = ssh_fetch_identitylist(agent_fd, 2, &idlist)) != 0) {
@


1.256
log
@include key fingerprint in "Offering public key" debug message
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.255 2017/03/11 23:40:26 djm Exp $ */
a1311 2
		if (key && key->type == KEY_RSA1)
			continue;
d1464 1
a1464 1
	return (id->key->type != KEY_RSA1);
a1756 1
			    authctxt->sensitive->keys[i]->type == KEY_RSA1 ||
@


1.255
log
@allow ssh to use certificates accompanied by a private key file but no
corresponding plain *.pub public key. bz#2617 based on patch from
Adam Eijdenberg; ok dtucker@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.254 2017/02/03 02:56:00 dtucker Exp $ */
d1474 1
d1489 10
a1498 2
				debug("Offering %s public key: %s",
				    key_type(id->key), id->filename);
@


1.254
log
@Make ssh_packet_set_rekey_limits take u32 for the number of seconds
until rekeying (negative values are rejected at config parse time).
This allows the removal of some casts and a signed vs unsigned
comparison warning.

rekey_time is cast to int64 for the comparison which is a no-op
on OpenBSD, but should also do the right thing in -portable on
anything still using 32bit time_t (until the system time actually
wraps, anyway).

some early guidance deraadt@@, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.253 2017/01/30 00:32:28 djm Exp $ */
d991 1
a991 1
identity_sign_encode(struct identity *id)
d995 1
a995 1
	if (id->key->type == KEY_RSA) {
d1003 1
a1003 1
	return key_ssh_name(id->key);
a1011 3
	const char *alg;

	alg = identity_sign_encode(id);
d1014 1
a1014 1
	if (id->agent_fd != -1)
d1016 1
a1016 1
		    data, datalen, alg, compat);
d1022 5
a1026 3
	if (id->isprivate || (id->key->flags & SSHKEY_FLAG_EXT))
		return (sshkey_sign(id->key, sigp, lenp, data, datalen, alg,
		    compat));
d1030 2
a1031 1
	ret = sshkey_sign(prv, sigp, lenp, data, datalen, alg, compat);
d1037 19
d1097 1
a1097 1
		buffer_put_cstring(&b, identity_sign_encode(id));
d1117 18
d1213 1
a1213 1
		packet_put_cstring(identity_sign_encode(id));
@


1.253
log
@misplaced braces in test; from Karsten Weiss
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.252 2017/01/30 00:32:03 djm Exp $ */
d190 2
a191 2
		packet_set_rekey_limits((u_int32_t)options.rekey_limit,
		    (time_t)options.rekey_interval);
@


1.252
log
@don't dereference authctxt before testing != NULL, it causes compilers
to make assumptions; from Karsten Weiss
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.251 2016/12/04 23:54:02 djm Exp $ */
d1627 1
a1627 1
	if ((r = sshbuf_put_u32(b, sock) != 0) ||
@


1.251
log
@Fix public key authentication when multiple authentication is in use.
Instead of deleting and re-preparing the entire keys list, just reset
the 'used' flags; the keys list is already in a good order (with already-
tried keys at the back)

Analysis and patch from Vincent Brillault on bz#2642; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.250 2016/09/28 20:32:42 djm Exp $ */
d929 1
a929 2
	const char *host = options.host_key_alias ? options.host_key_alias :
	    authctxt->host;
d936 1
@


1.250
log
@restore pre-auth compression support in the client -- the previous
commit was intended to remove it from the server only.

remove a few server-side pre-auth compression bits that escaped

adjust wording of Compression directive in sshd_config(5)

pointed out by naddy@@ ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.249 2016/09/28 16:33:07 djm Exp $ */
d313 1
d556 1
a556 2
		pubkey_cleanup(authctxt);
		pubkey_prepare(authctxt);
d1409 9
d1466 1
@


1.249
log
@Remove support for pre-authentication compression. Doing compression
early in the protocol probably seemed reasonable in the 1990s, but
today it's clearly a bad idea in terms of both cryptography (cf.
multiple compression oracle attacks in TLS) and attack surface.

Moreover, to support it across privilege-separation zlib needed
the assistance of a complex shared-memory manager that made the
required attack surface considerably larger.

Prompted by Guido Vranken pointing out a compiler-elided security
check in the shared memory manager found by Stack
(http://css.csail.mit.edu/stack/); ok deraadt@@ markus@@

NB. pre-auth authentication has been disabled by default in sshd
for >10 years.
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.248 2016/09/22 02:29:57 dtucker Exp $ */
d171 1
a171 1
	    "zlib@@openssh.com,none" : "none,zlib@@openssh.com";
@


1.248
log
@If ssh receives a PACKET_DISCONNECT during userauth it will cause
ssh_dispatch_run(DISPATCH_BLOCK, ...) to return without the session
being authenticated.  Check for this and exit if necessary.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.247 2016/07/22 05:46:11 dtucker Exp $ */
d171 1
a171 1
	    "zlib@@openssh.com,zlib,none" : "none,zlib@@openssh.com,zlib";
@


1.247
log
@Lower loglevel for "Authenticated with partial success" message similar to
other similar level.  bz#2599, patch from cgallek at gmail.com, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.246 2016/07/17 04:20:16 djm Exp $ */
d399 2
@


1.246
log
@support UTF-8 characters in ssh(1) banners using schwarze@@'s
safe fmprintf printer; bz#2058

feedback schwarze@@ ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.245 2016/05/24 04:43:45 dtucker Exp $ */
d551 1
a551 1
		logit("Authenticated with partial success.");
@


1.245
log
@KNF compression proposal and simplify the client side a little.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.244 2016/05/23 23:30:50 djm Exp $ */
d68 1
d491 1
a491 1
	char *msg, *raw, *lang;
d494 2
a495 2
	debug3("input_userauth_banner");
	raw = packet_get_string(&len);
d497 3
a499 9
	if (len > 0 && options.log_level >= SYSLOG_LEVEL_INFO) {
		if (len > 65536)
			len = 65536;
		msg = xmalloc(len * 4 + 1); /* max expansion from strnvis() */
		strnvis(msg, raw, len * 4 + 1, VIS_SAFE|VIS_OCTAL|VIS_NOSLASH);
		fprintf(stderr, "%s", msg);
		free(msg);
	}
	free(raw);
@


1.244
log
@prefer agent-hosted keys to keys from PKCS#11; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.243 2016/05/02 10:26:04 djm Exp $ */
d168 3
a170 7
	if (options.compression) {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] =
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "zlib@@openssh.com,zlib,none";
	} else {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] =
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none,zlib@@openssh.com,zlib";
	}
@


1.243
log
@add support for additional fixed DH groups from
draft-ietf-curdle-ssh-kex-sha2-03

diffie-hellman-group14-sha256 (2K group)
diffie-hellman-group16-sha512 (4K group)
diffie-hellman-group18-sha512 (8K group)

based on patch from Mark D. Baushke and Darren Tucker
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.242 2016/05/02 08:49:03 djm Exp $ */
a1293 23
	/* Prefer PKCS11 keys that are explicitly listed */
	TAILQ_FOREACH_SAFE(id, &files, next, tmp) {
		if (id->key == NULL || (id->key->flags & SSHKEY_FLAG_EXT) == 0)
			continue;
		found = 0;
		TAILQ_FOREACH(id2, &files, next) {
			if (id2->key == NULL ||
			    (id2->key->flags & SSHKEY_FLAG_EXT) == 0)
				continue;
			if (sshkey_equal(id->key, id2->key)) {
				TAILQ_REMOVE(&files, id, next);
				TAILQ_INSERT_TAIL(preferred, id, next);
				found = 1;
				break;
			}
		}
		/* If IdentitiesOnly set and key not found then don't use it */
		if (!found && options.identities_only) {
			TAILQ_REMOVE(&files, id, next);
			explicit_bzero(id, sizeof(*id));
			free(id);
		}
	}
d1351 23
@


1.242
log
@fix signed/unsigned errors reported by clang-3.7; add
sshbuf_dup_string() to replace a common idiom of
strdup(sshbuf_ptr()) with better safety checking;
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.241 2016/04/28 14:30:21 djm Exp $ */
d203 3
@


1.241
log
@fix comment
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.240 2016/03/14 16:20:54 djm Exp $ */
d1917 2
a1918 2
	buffer_append(&b, "\0", 1);
	list = xstrdup(buffer_ptr(&b));
@


1.240
log
@unbreak authentication using lone certificate keys in ssh-agent:
when attempting pubkey auth with a certificate, if no separate
private key is found among the keys then try with the certificate
key itself.

bz#2550 reported by Peter Moody
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.239 2016/02/23 01:34:14 djm Exp $ */
d1089 2
a1090 2
	 * If no such private key exists, return failure and continue with
	 * other methods of authentication.
@


1.239
log
@fix spurious error message when incorrect passphrase entered for
keys; reported by espie@@ ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.238 2016/02/05 04:31:21 jsg Exp $ */
d1107 1
a1107 2
			/* XXX maybe verbose/error? */
			debug("%s: no private key for certificate "
a1108 3
			free(blob);
			buffer_free(&b);
			return 0;
@


1.238
log
@avoid an uninitialised value when NumberOfPasswordPrompts is 0
ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.237 2016/01/14 22:56:56 markus Exp $ */
d1034 1
a1034 1
		return (-1); /* XXX return decent error code */
d1120 2
a1121 1
		error("%s: signing failed: %s", __func__, ssh_err(ret));
@


1.237
log
@fd leaks; report Qualys Security Advisory team; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.236 2016/01/14 16:17:40 markus Exp $ */
d1193 1
a1193 1
	Key *private;
@


1.236
log
@remove roaming support; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.235 2015/12/11 02:31:47 mmcc Exp $ */
d1339 1
@


1.235
log
@Remove NULL-checks before sshkey_free().

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.234 2015/12/11 02:20:28 djm Exp $ */
a213 4
	if (options.use_roaming && !kex->roaming) {
		debug("Roaming not allowed by server");
		options.use_roaming = 0;
	}
@


1.234
log
@correct error messages; from Tomas Kuthan bz#2507
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.233 2015/12/11 00:20:04 mmcc Exp $ */
d1413 1
a1413 2
		if (id->key)
			sshkey_free(id->key);
@


1.233
log
@Pass (char *)NULL rather than (char *)0 to execl and execlp.

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.232 2015/12/10 17:08:40 mmcc Exp $ */
d1124 1
@


1.232
log
@Remove NULL-checks before free().

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.231 2015/12/04 16:41:28 markus Exp $ */
d1617 1
a1617 1
		execl(_PATH_SSH_KEY_SIGN, _PATH_SSH_KEY_SIGN, (char *) 0);
@


1.231
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.230 2015/12/04 00:24:55 djm Exp $ */
d1252 1
a1252 2
		if (comment)
			free(comment);
@


1.230
log
@clean up agent_fd handling; properly initialise it to -1 and
make tests consistent

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.229 2015/11/15 22:26:49 jcs Exp $ */
d154 1
d161 3
a163 2
	myproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(
	    options.kex_algorithms);
d218 5
d286 2
d363 1
d365 1
a365 1
	int type;
a368 19

	packet_start(SSH2_MSG_SERVICE_REQUEST);
	packet_put_cstring("ssh-userauth");
	packet_send();
	debug("SSH2_MSG_SERVICE_REQUEST sent");
	packet_write_wait();
	type = packet_read();
	if (type != SSH2_MSG_SERVICE_ACCEPT)
		fatal("Server denied authentication request: %d", type);
	if (packet_remaining() > 0) {
		char *reply = packet_get_string(NULL);
		debug2("service_accept: %s", reply);
		free(reply);
	} else {
		debug2("buggy server: service_accept w/o service");
	}
	packet_check_eom();
	debug("SSH2_MSG_SERVICE_ACCEPT received");

d390 9
a398 8
	/* initial userauth request */
	userauth_none(&authctxt);

	dispatch_init(&input_userauth_error);
	dispatch_set(SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);
	dispatch_set(SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);
	dispatch_set(SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);
	dispatch_run(DISPATCH_BLOCK, &authctxt.success, &authctxt);	/* loop until success */
d401 1
a401 1
	dispatch_range(SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);
d406 41
d998 16
d1020 3
d1027 1
a1027 1
		    data, datalen, compat);
d1034 1
a1034 1
		return (sshkey_sign(id->key, sigp, lenp, data, datalen,
d1039 1
a1039 1
	ret = sshkey_sign(prv, sigp, lenp, data, datalen, compat);
d1086 1
a1086 1
		buffer_put_cstring(&b, key_ssh_name(id->key));
d1186 1
a1186 1
		packet_put_cstring(key_ssh_name(id->key));
d1790 1
a1790 1
	    sshbuf_ptr(b), sshbuf_len(b), datafellows)) != 0)
@


1.229
log
@Add an AddKeysToAgent client option which can be set to 'yes', 'no',
'ask', or 'confirm', and defaults to 'no'.  When enabled, a private
key that is used during authentication will be added to ssh-agent if
it is running (with confirmation enabled if set to 'confirm').

Initial version from Joachim Schipper many years ago.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.228 2015/10/13 16:15:21 djm Exp $ */
d973 1
a973 1
	if (id->agent_fd)
d1192 1
a1192 1
		if (!quit && private != NULL && !id->agent_fd &&
d1222 1
a1222 1
	int agent_fd, i, r, found;
d1240 1
d1276 1
d1345 3
a1347 2
		debug2("key: %s (%p),%s", id->filename, id->key,
		    id->userprovided ? " explicit" : "");
@


1.228
log
@apply PubkeyAcceptedKeyTypes filtering earlier, so all skipped
keys are noted before pubkey authentication starts. ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.227 2015/09/24 06:15:11 djm Exp $ */
d308 1
a308 1
static Key *load_identity_file(char *, int);
d985 1
a985 1
	if ((prv = load_identity_file(id->filename, id->userprovided)) == NULL)
d1142 1
a1142 1
load_identity_file(char *filename, int userprovided)
d1145 1
a1145 1
	char prompt[300], *passphrase;
d1149 3
a1151 3
	if (stat(filename, &st) < 0) {
		(userprovided ? logit : debug3)("no such identity: %s: %s",
		    filename, strerror(errno));
d1155 1
a1155 1
	    "Enter passphrase for key '%.100s': ", filename);
d1167 2
a1168 2
		switch ((r = sshkey_load_private_type(KEY_UNSPEC, filename,
		    passphrase, &private, NULL, &perm_ok))) {
d1182 1
a1182 1
				    filename, ssh_err(r));
d1188 1
a1188 1
			error("Load key \"%s\": %s", filename, ssh_err(r));
d1192 4
d1200 2
d1404 1
a1404 2
			id->key = load_identity_file(id->filename,
			    id->userprovided);
@


1.227
log
@add ssh_config CertificateFile option to explicitly list
a certificate; patch from Meghana Bhat on bz#2436; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.226 2015/07/30 00:01:34 djm Exp $ */
d1323 14
a1336 1
	TAILQ_FOREACH(id, preferred, next) {
a1363 6
	if (match_pattern_list(sshkey_ssh_name(id->key),
	    options.pubkey_key_types, 0) != 1) {
		debug("Skipping %s key %s for not in PubkeyAcceptedKeyTypes",
		    sshkey_ssh_name(id->key), id->filename);
		return (0);
	}
@


1.226
log
@Allow ssh_config and sshd_config kex parameters options be prefixed
by a '+' to indicate that the specified items be appended to the
default rather than replacing it.

approach suggested by dtucker@@, feedback dlg@@, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.225 2015/07/10 06:21:53 markus Exp $ */
d996 1
a997 1
	u_int bloblen;
d999 2
a1000 3
	u_int skip = 0;
	int ret = -1;
	int have_sig = 1;
d1006 1
a1006 1
	debug3("sign_and_send_pubkey: %s %s", key_type(id->key), fp);
d1038 30
d1204 5
a1208 3
 *	1. agent keys that are found in the config file
 *	2. other agent keys
 *	3. keys that are only listed in the config file
d1261 12
@


1.225
log
@Turn off DSA by default; add HostKeyAlgorithms to the server and
PubkeyAcceptedKeyTypes to the client side, so it still can be
tested or turned back on; feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.224 2015/05/04 06:10:48 djm Exp $ */
d160 2
a161 8
	if (options.ciphers == (char *)-1) {
		logit("No valid ciphers for protocol version 2 given, using defaults.");
		options.ciphers = NULL;
	}
	if (options.ciphers != NULL) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] = options.ciphers;
	}
d163 1
a163 1
	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_CTOS]);
d165 1
a165 1
	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_STOC]);
d173 6
a178 5
	if (options.macs != NULL) {
		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
		myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;
	}
	if (options.hostkeyalgorithms != NULL)
d181 1
a181 1
	else {
a188 4
	if (options.kex_algorithms != NULL)
		myproposal[PROPOSAL_KEX_ALGS] = options.kex_algorithms;
	myproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(
	    myproposal[PROPOSAL_KEX_ALGS]);
@


1.224
log
@Remove pattern length argument from match_pattern_list(),
we only ever use it for strlen(pattern).

Prompted by hanno AT hboeck.de pointing an out-of-bound read
error caused by an incorrect pattern length found using AFL
and his own tools.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.223 2015/01/30 11:43:14 djm Exp $ */
d187 2
d1312 20
d1350 1
a1350 5
			if (key_type_plain(id->key->type) == KEY_RSA &&
			    (datafellows & SSH_BUG_RSASIGMD5) != 0) {
				debug("Skipped %s key %s for RSA/MD5 server",
				    key_type(id->key), id->filename);
			} else if (id->key->type != KEY_RSA1) {
d1360 2
a1361 7
				id->isprivate = 1;
				if (key_type_plain(id->key->type) == KEY_RSA &&
				    (datafellows & SSH_BUG_RSASIGMD5) != 0) {
					debug("Skipped %s key %s for RSA/MD5 "
					    "server", key_type(id->key),
					    id->filename);
				} else {
@


1.223
log
@Add a ssh_config HostbasedKeyType option to control which
host public key types are tried during hostbased authentication.

This may be used to prevent too many keys being sent to the server,
and blowing past its MaxAuthTries limit.

bz#2211 based on patch by Iain Morgan; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.222 2015/01/28 22:36:00 djm Exp $ */
d1605 1
a1605 2
			    authctxt->active_ktype,
			    strlen(authctxt->active_ktype), 0) != 1)
@


1.222
log
@update to new API (key_fingerprint => sshkey_fingerprint)
check sshkey_fingerprint return values;
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.221 2015/01/20 20:16:21 markus Exp $ */
d270 2
d400 1
d1452 2
a1453 2
ssh_keysign(Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d1455 1
a1455 1
	Buffer b;
d1458 3
a1460 1
	int to[2], from[2], status, version = 2;
d1462 2
a1463 1
	debug2("ssh_keysign called");
d1466 5
a1470 1
		error("ssh_keysign: not installed: %s", strerror(errno));
a1472 2
	if (fflush(stdout) != 0)
		error("ssh_keysign: fflush: %s", strerror(errno));
d1474 1
a1474 1
		error("ssh_keysign: pipe: %s", strerror(errno));
d1478 1
a1478 1
		error("ssh_keysign: pipe: %s", strerror(errno));
d1482 1
a1482 1
		error("ssh_keysign: fork: %s", strerror(errno));
d1485 1
d1488 1
a1488 1
		fcntl(packet_get_connection_in(), F_SETFD, 0);
d1492 1
a1492 1
			fatal("ssh_keysign: dup2: %s", strerror(errno));
d1495 1
a1495 1
			fatal("ssh_keysign: dup2: %s", strerror(errno));
d1498 6
d1505 1
a1505 1
		fatal("ssh_keysign: exec(%s): %s", _PATH_SSH_KEY_SIGN,
d1511 10
a1520 11
	buffer_init(&b);
	buffer_put_int(&b, packet_get_connection_in()); /* send # of socket */
	buffer_put_string(&b, data, datalen);
	if (ssh_msg_send(to[1], version, &b) == -1)
		fatal("ssh_keysign: couldn't send request");

	if (ssh_msg_recv(from[0], &b) < 0) {
		error("ssh_keysign: no reply");
		buffer_free(&b);
		return -1;
	}
d1523 4
d1528 30
a1557 7
	while (waitpid(pid, &status, 0) < 0)
		if (errno != EINTR)
			break;

	if (buffer_get_char(&b) != version) {
		error("ssh_keysign: bad version");
		buffer_free(&b);
d1560 2
a1561 2
	*sigp = buffer_get_string(&b, lenp);
	buffer_free(&b);
d1569 3
a1571 5
	Key *private = NULL;
	Sensitive *sensitive = authctxt->sensitive;
	Buffer b;
	u_char *signature, *blob;
	char *chost, *pkalg, *p;
d1573 9
a1581 2
	u_int blen, slen;
	int ok, i, found = 0;
d1583 12
a1594 1
	/* XXX provide some way to allow user to specify key types attempted */
d1596 12
a1607 5
	/* check for a useful key */
	for (i = 0; i < sensitive->nkeys; i++) {
		private = sensitive->keys[i];
		if (private && private->type != KEY_RSA1) {
			found = 1;
d1609 2
a1610 1
			sensitive->keys[i] = NULL;
d1613 5
d1619 4
a1622 1
	if (!found) {
d1624 1
a1624 1
		return 0;
d1627 4
a1630 5
	debug("%s: trying hostkey type %s", __func__, key_type(private));

	if (key_to_blob(private, &blob, &blen) == 0) {
		key_free(private);
		return 0;
d1632 2
d1636 3
a1638 6
	p = get_local_name(packet_get_connection_in());
	if (p == NULL) {
		error("userauth_hostbased: cannot get local ipaddr/name");
		key_free(private);
		free(blob);
		return 0;
d1640 4
a1643 3
	xasprintf(&chost, "%s.", p);
	debug2("userauth_hostbased: chost %s", chost);
	free(p);
d1647 1
a1647 2
	pkalg = xstrdup(key_ssh_name(private));
	buffer_init(&b);
d1649 21
a1669 9
	buffer_put_string(&b, session_id2, session_id2_len);
	buffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);
	buffer_put_cstring(&b, authctxt->server_user);
	buffer_put_cstring(&b, service);
	buffer_put_cstring(&b, authctxt->method->name);
	buffer_put_cstring(&b, pkalg);
	buffer_put_string(&b, blob, blen);
	buffer_put_cstring(&b, chost);
	buffer_put_cstring(&b, authctxt->local_user);
d1671 1
a1671 1
	buffer_dump(&b);
d1673 30
a1702 14
	if (sensitive->external_keysign)
		ok = ssh_keysign(private, &signature, &slen,
		    buffer_ptr(&b), buffer_len(&b));
	else
		ok = key_sign(private, &signature, &slen,
		    buffer_ptr(&b), buffer_len(&b));
	key_free(private);
	buffer_free(&b);
	if (ok != 0) {
		error("key_sign failed");
		free(chost);
		free(pkalg);
		free(blob);
		return 0;
d1704 3
a1706 11
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
	packet_put_cstring(pkalg);
	packet_put_string(blob, blen);
	packet_put_cstring(chost);
	packet_put_cstring(authctxt->local_user);
	packet_put_string(signature, slen);
	explicit_bzero(signature, slen);
	free(signature);
d1708 2
a1709 2
	free(pkalg);
	free(blob);
d1711 1
a1711 2
	packet_send();
	return 1;
@


1.221
log
@kex_setup errors are fatal()
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.220 2015/01/20 07:56:44 djm Exp $ */
d588 3
a590 1
	fp = sshkey_fingerprint(key, options.fingerprint_hash, SSH_FP_DEFAULT);
d1008 3
a1010 1
	fp = key_fingerprint(id->key, options.fingerprint_hash, SSH_FP_DEFAULT);
@


1.220
log
@make this compile with KERBEROS5 enabled
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.219 2015/01/19 20:16:15 markus Exp $ */
d155 1
d202 2
a203 1
	kex_setup(active_state, myproposal);
@


1.219
log
@adapt kex to sshbuf and struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.218 2015/01/19 20:07:45 markus Exp $ */
d726 1
a726 1
void
d747 1
a747 1
		return;
d761 1
a761 1
		return;
d763 1
d767 1
a767 1
void
d790 1
a790 1
		return;
d792 1
d796 1
a796 1
void
d823 1
d827 1
a827 1
void
d843 1
@


1.218
log
@move dispatch to struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.217 2015/01/19 19:52:16 markus Exp $ */
d89 1
a89 1
verify_host_key_callback(Key *hostkey)
d154 1
a154 1
	Kex *kex;
d201 2
a202 2
	kex = kex_setup(myproposal);
	active_state->kex = kex;
d215 1
a215 1
	dispatch_run(DISPATCH_BLOCK, &kex->done, kex);
@


1.217
log
@update packet.c & isolate, introduce struct ssh
a) switch packet.c to buffer api and isolate per-connection info into struct ssh
b) (de)serialization of the state is moved from monitor to packet.c
c) the old packet.c API is implemented in opacket.[ch]
d) compress.c/h is removed and integrated into packet.c
with and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.216 2015/01/18 13:33:34 djm Exp $ */
d282 8
a289 8
void	input_userauth_success(int, u_int32_t, void *);
void	input_userauth_success_unexpected(int, u_int32_t, void *);
void	input_userauth_failure(int, u_int32_t, void *);
void	input_userauth_banner(int, u_int32_t, void *);
void	input_userauth_error(int, u_int32_t, void *);
void	input_userauth_info_req(int, u_int32_t, void *);
void	input_userauth_pk_ok(int, u_int32_t, void *);
void	input_userauth_passwd_changereq(int, u_int32_t, void *);
d299 5
a303 5
void	input_gssapi_response(int type, u_int32_t, void *);
void	input_gssapi_token(int type, u_int32_t, void *);
void	input_gssapi_hash(int type, u_int32_t, void *);
void	input_gssapi_error(int, u_int32_t, void *);
void	input_gssapi_errtok(int, u_int32_t, void *);
d452 1
a452 1
void
d457 1
d461 1
a461 1
void
d480 1
d484 1
a484 1
void
d498 1
d501 1
a501 1
void
d511 1
d515 1
a515 1
void
d538 1
d542 1
a542 1
void
d610 1
d894 1
a894 1
void
d935 1
a935 1
			return;
d958 1
d1383 1
a1383 1
void
d1435 1
@


1.216
log
@avoid trailing ',' in host key algorithms
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.215 2015/01/15 11:04:36 djm Exp $ */
a87 2
Kex *xxx_kex = NULL;

d202 1
a213 2

	xxx_kex = kex;
@


1.215
log
@fix regression reported by brad@@ for passworded keys without
agent present
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.214 2015/01/14 20:05:27 djm Exp $ */
d138 2
a139 1
	xasprintf(&ret, "%s%s%s", first, *first == '\0' ? "" : ",", last);
@


1.214
log
@move authfd.c and its tentacles to the new buffer/key API;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.213 2015/01/08 10:14:08 djm Exp $ */
d399 1
d1106 1
a1106 1
	int r, perm_ok = 0, quit, i;
d1136 2
a1137 1
			debug2("bad passphrase given, try again...");
@


1.213
log
@deprecate key_load_private_pem() and sshkey_load_private_pem()
interfaces. Refactor the generic key loading API to not require
pathnames to be specified (they weren't really used).

Fixes a few other things en passant:

Makes ed25519 keys work for hostbased authentication (ssh-keysign
previously used the PEM-only routines).

Fixes key comment regression bz#2306: key pathnames were being lost as
comment fields.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.212 2014/12/21 22:27:56 djm Exp $ */
d67 1
d129 1
a129 1
		if ((ktype = key_type_from_name(alg)) == KEY_UNSPEC)
d132 1
a132 1
		    key_type_plain(ktype), NULL))
d240 2
a241 2
typedef struct Authctxt Authctxt;
typedef struct Authmethod Authmethod;
d247 2
a248 2
	AuthenticationConnection *ac;	/* set if agent supports key */
	Key	*key;			/* public/private key */
d256 1
a256 1
struct Authctxt {
d261 1
a261 1
	Authmethod *method;
d264 1
d266 2
a267 2
	Idlist keys;
	AuthenticationConnection *agent;
d275 2
a276 1
struct Authmethod {
d582 1
a582 1
	fp = key_fingerprint(key, options.fingerprint_hash, SSH_FP_DEFAULT);
d956 2
a957 2
identity_sign(Identity *id, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d963 4
a966 3
	if (id->ac)
		return (ssh_agent_sign(id->ac, id->key, sigp, lenp,
		    data, datalen));
d972 2
a973 1
		return (key_sign(id->key, sigp, lenp, data, datalen));
d976 3
a978 3
		return (-1);
	ret = key_sign(prv, sigp, lenp, data, datalen);
	key_free(prv);
d987 2
a988 1
	u_int bloblen, slen;
d1029 2
a1030 2
	    buffer_ptr(&b), buffer_len(&b));
	if (ret == -1) {
d1105 1
a1105 1
	int perm_ok = 0, quit, i;
d1113 6
a1118 12
	private = key_load_private_type(KEY_UNSPEC, filename, "", NULL, &perm_ok);
	if (!perm_ok) {
		if (private != NULL)
			key_free(private);
		return NULL;
	}
	if (private == NULL) {
		if (options.batch_mode)
			return NULL;
		snprintf(prompt, sizeof prompt,
		    "Enter passphrase for key '%.100s': ", filename);
		for (i = 0; i < options.number_of_password_prompts; i++) {
d1120 1
a1120 5
			if (strcmp(passphrase, "") != 0) {
				private = key_load_private_type(KEY_UNSPEC,
				    filename, passphrase, NULL, NULL);
				quit = 0;
			} else {
d1122 19
d1142 1
d1144 7
a1152 3
			if (private != NULL || quit)
				break;
			debug2("bad passphrase given, try again...");
d1154 2
d1169 6
a1174 6
	Identity *id, *id2, *tmp;
	Idlist agent, files, *preferred;
	Key *key;
	AuthenticationConnection *ac;
	char *comment;
	int i, found;
d1204 1
a1204 1
			if (key_equal(id->key, id2->key)) {
d1219 10
a1228 4
	if ((ac = ssh_get_authentication_connection())) {
		for (key = ssh_get_first_identity(ac, &comment, 2);
		    key != NULL;
		    key = ssh_get_next_identity(ac, &comment, 2)) {
d1231 5
a1235 4
				/* agent keys from the config file are preferred */
				if (key_equal(key, id->key)) {
					key_free(key);
					free(comment);
d1238 1
a1238 1
					id->ac = ac;
d1245 6
a1250 3
				id->key = key;
				id->filename = comment;
				id->ac = ac;
d1254 1
d1260 1
a1260 1
		authctxt->agent = ac;
d1278 2
a1279 2
	if (authctxt->agent != NULL)
		ssh_close_authentication_connection(authctxt->agent);
d1284 1
a1284 1
			key_free(id->key);
@


1.212
log
@Add FingerprintHash option to control algorithm used for key
fingerprints. Default changes from MD5 to SHA256 and format
from hex to base64.

Feedback and ok naddy@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.211 2014/12/11 05:13:28 djm Exp $ */
d1485 2
@


1.211
log
@show in debug output which hostkeys are being tried when attempting
hostbased auth; patch from Iain Morgan
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.210 2014/07/15 15:54:14 millert Exp $ */
d579 1
a579 1
	fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
d988 1
a988 1
	fp = key_fingerprint(id->key, SSH_FP_MD5, SSH_FP_HEX);
@


1.210
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.209 2014/06/24 01:13:21 djm Exp $ */
d1500 3
d1507 1
@


1.209
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.208 2014/06/05 22:17:50 djm Exp $ */
d58 1
a59 1
#include "misc.h"
@


1.208
log
@fix inverted test that caused PKCS#11 keys that were explicitly listed
not to be preferred. Reported by Dirk-Willem van Gulik
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.207 2014/04/29 18:01:49 markus Exp $ */
d967 1
a967 1
	if (id->isprivate || (id->key->flags & KEY_FLAG_EXT))
d1175 1
a1175 1
		if (id->key == NULL || (id->key->flags & KEY_FLAG_EXT) == 0)
d1180 1
a1180 1
			    (id2->key->flags & KEY_FLAG_EXT) == 0)
@


1.207
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.206 2014/04/18 23:52:25 djm Exp $ */
d1180 1
a1180 1
			    (id2->key->flags & KEY_FLAG_EXT) != 0)
@


1.206
log
@OpenSSH 6.5 and 6.6 have a bug that causes ~0.2% of connections
using the curve25519-sha256@@libssh.org KEX exchange method to fail
when connecting with something that implements the spec properly.

Disable this KEX method when speaking to one of the affected
versions.

reported by Aris Adamantiadis; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.205 2014/03/27 23:01:27 markus Exp $ */
d202 1
d208 1
@


1.205
log
@disable weak proposals in sshd, but keep them in ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.204 2014/02/02 03:44:32 djm Exp $ */
d193 2
@


1.204
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.203 2014/01/31 16:39:19 tedu Exp $ */
d153 1
@


1.204.4.1
log
@MFC:

reliability fix for OpenSSH using curve25519-sha256@@libssh.org key
exchange method.

revision 1.71
date: 2014/04/18 23:52:25;  author: djm;  state: Exp;  lines: +2 -2;
OpenSSH 6.5 and 6.6 have a bug that causes ~0.2% of connections
using the curve25519-sha256@@libssh.org KEX exchange method to fail
when connecting with something that implements the spec properly.

Disable this KEX method when speaking to one of the affected
versions.

revision 1.57
date: 2014/04/16 23:22:45;  author: djm;  state: Exp;  lines: +4 -1;
skip leading zero bytes in buffer_put_bignum2_from_string();
reported by jan AT mojzis.com; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.204 2014/02/02 03:44:32 djm Exp $ */
a191 2
	myproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(
	    myproposal[PROPOSAL_KEX_ALGS]);
@


1.203
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.202 2014/01/29 06:18:35 djm Exp $ */
d866 1
a866 1
	memset(password, 0, strlen(password));
d912 1
a912 1
	memset(password, 0, strlen(password));
d929 1
a929 1
			memset(password, 0, strlen(password));
d934 1
a934 1
		memset(retype, 0, strlen(retype));
d938 1
a938 1
	memset(password, 0, strlen(password));
d1123 1
a1123 1
			memset(passphrase, 0, strlen(passphrase));
d1382 1
a1382 1
		memset(response, 0, strlen(response));
d1552 1
a1552 1
	memset(signature, 's', slen);
@


1.202
log
@remove experimental, never-enabled JPAKE code; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.201 2014/01/09 23:20:00 djm Exp $ */
d1187 1
a1187 1
			bzero(id, sizeof(*id));
@


1.201
log
@Introduce digest API and use it to perform all hashing operations
rather than calling OpenSSL EVP_Digest* directly. Will make it easier
to build a reduced-feature OpenSSH without OpenSSL in future;
feedback, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.200 2013/12/30 23:52:28 djm Exp $ */
a66 2
#include "schnorr.h"
#include "jpake.h"
a283 3
void	input_userauth_jpake_server_step1(int, u_int32_t, void *);
void	input_userauth_jpake_server_step2(int, u_int32_t, void *);
void	input_userauth_jpake_server_confirm(int, u_int32_t, void *);
a289 3
int	userauth_jpake(Authctxt *);

void	userauth_jpake_cleanup(Authctxt *);
a328 7
#ifdef JPAKE
	{"jpake-01@@openssh.com",
		userauth_jpake,
		userauth_jpake_cleanup,
		&options.zero_knowledge_password_authentication,
		&options.batch_mode},
#endif
a946 203
#ifdef JPAKE
static char *
pw_encrypt(const char *password, const char *crypt_scheme, const char *salt)
{
	/* OpenBSD crypt(3) handles all of these */
	if (strcmp(crypt_scheme, "crypt") == 0 ||
	    strcmp(crypt_scheme, "bcrypt") == 0 ||
	    strcmp(crypt_scheme, "md5crypt") == 0 ||
	    strcmp(crypt_scheme, "crypt-extended") == 0)
		return xstrdup(crypt(password, salt));
	error("%s: unsupported password encryption scheme \"%.100s\"",
	    __func__, crypt_scheme);
	return NULL;
}

static BIGNUM *
jpake_password_to_secret(Authctxt *authctxt, const char *crypt_scheme,
    const char *salt)
{
	char prompt[256], *password, *crypted;
	u_char *secret;
	u_int secret_len;
	BIGNUM *ret;

	snprintf(prompt, sizeof(prompt), "%.30s@@%.128s's password (JPAKE): ",
	    authctxt->server_user, authctxt->host);
	password = read_passphrase(prompt, 0);

	if ((crypted = pw_encrypt(password, crypt_scheme, salt)) == NULL) {
		logit("Disabling %s authentication", authctxt->method->name);
		authctxt->method->enabled = NULL;
		/* Continue with an empty password to fail gracefully */
		crypted = xstrdup("");
	}

#ifdef JPAKE_DEBUG
	debug3("%s: salt = %s", __func__, salt);
	debug3("%s: scheme = %s", __func__, crypt_scheme);
	debug3("%s: crypted = %s", __func__, crypted);
#endif

	if (hash_buffer(crypted, strlen(crypted), SSH_DIGEST_SHA1,
	    &secret, &secret_len) != 0)
		fatal("%s: hash_buffer", __func__);

	bzero(password, strlen(password));
	bzero(crypted, strlen(crypted));
	free(password);
	free(crypted);

	if ((ret = BN_bin2bn(secret, secret_len, NULL)) == NULL)
		fatal("%s: BN_bin2bn (secret)", __func__);
	bzero(secret, secret_len);
	free(secret);

	return ret;
}

/* ARGSUSED */
void
input_userauth_jpake_server_step1(int type, u_int32_t seq, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	struct jpake_ctx *pctx = authctxt->methoddata;
	u_char *x3_proof, *x4_proof, *x2_s_proof;
	u_int x3_proof_len, x4_proof_len, x2_s_proof_len;
	char *crypt_scheme, *salt;

	/* Disable this message */
	dispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_STEP1, NULL);

	if ((pctx->g_x3 = BN_new()) == NULL ||
	    (pctx->g_x4 = BN_new()) == NULL)
		fatal("%s: BN_new", __func__);

	/* Fetch step 1 values */
	crypt_scheme = packet_get_string(NULL);
	salt = packet_get_string(NULL);
	pctx->server_id = packet_get_string(&pctx->server_id_len);
	packet_get_bignum2(pctx->g_x3);
	packet_get_bignum2(pctx->g_x4);
	x3_proof = packet_get_string(&x3_proof_len);
	x4_proof = packet_get_string(&x4_proof_len);
	packet_check_eom();

	JPAKE_DEBUG_CTX((pctx, "step 1 received in %s", __func__));

	/* Obtain password and derive secret */
	pctx->s = jpake_password_to_secret(authctxt, crypt_scheme, salt);
	bzero(crypt_scheme, strlen(crypt_scheme));
	bzero(salt, strlen(salt));
	free(crypt_scheme);
	free(salt);
	JPAKE_DEBUG_BN((pctx->s, "%s: s = ", __func__));

	/* Calculate step 2 values */
	jpake_step2(pctx->grp, pctx->s, pctx->g_x1,
	    pctx->g_x3, pctx->g_x4, pctx->x2,
	    pctx->server_id, pctx->server_id_len,
	    pctx->client_id, pctx->client_id_len,
	    x3_proof, x3_proof_len,
	    x4_proof, x4_proof_len,
	    &pctx->a,
	    &x2_s_proof, &x2_s_proof_len);

	bzero(x3_proof, x3_proof_len);
	bzero(x4_proof, x4_proof_len);
	free(x3_proof);
	free(x4_proof);

	JPAKE_DEBUG_CTX((pctx, "step 2 sending in %s", __func__));

	/* Send values for step 2 */
	packet_start(SSH2_MSG_USERAUTH_JPAKE_CLIENT_STEP2);
	packet_put_bignum2(pctx->a);
	packet_put_string(x2_s_proof, x2_s_proof_len);
	packet_send();

	bzero(x2_s_proof, x2_s_proof_len);
	free(x2_s_proof);

	/* Expect step 2 packet from peer */
	dispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_STEP2,
	    input_userauth_jpake_server_step2);
}

/* ARGSUSED */
void
input_userauth_jpake_server_step2(int type, u_int32_t seq, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	struct jpake_ctx *pctx = authctxt->methoddata;
	u_char *x4_s_proof;
	u_int x4_s_proof_len;

	/* Disable this message */
	dispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_STEP2, NULL);

	if ((pctx->b = BN_new()) == NULL)
		fatal("%s: BN_new", __func__);

	/* Fetch step 2 values */
	packet_get_bignum2(pctx->b);
	x4_s_proof = packet_get_string(&x4_s_proof_len);
	packet_check_eom();

	JPAKE_DEBUG_CTX((pctx, "step 2 received in %s", __func__));

	/* Derive shared key and calculate confirmation hash */
	jpake_key_confirm(pctx->grp, pctx->s, pctx->b,
	    pctx->x2, pctx->g_x1, pctx->g_x2, pctx->g_x3, pctx->g_x4,
	    pctx->client_id, pctx->client_id_len,
	    pctx->server_id, pctx->server_id_len,
	    session_id2, session_id2_len,
	    x4_s_proof, x4_s_proof_len,
	    &pctx->k,
	    &pctx->h_k_cid_sessid, &pctx->h_k_cid_sessid_len);

	bzero(x4_s_proof, x4_s_proof_len);
	free(x4_s_proof);

	JPAKE_DEBUG_CTX((pctx, "confirm sending in %s", __func__));

	/* Send key confirmation proof */
	packet_start(SSH2_MSG_USERAUTH_JPAKE_CLIENT_CONFIRM);
	packet_put_string(pctx->h_k_cid_sessid, pctx->h_k_cid_sessid_len);
	packet_send();

	/* Expect confirmation from peer */
	dispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_CONFIRM,
	    input_userauth_jpake_server_confirm);
}

/* ARGSUSED */
void
input_userauth_jpake_server_confirm(int type, u_int32_t seq, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	struct jpake_ctx *pctx = authctxt->methoddata;

	/* Disable this message */
	dispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_CONFIRM, NULL);

	pctx->h_k_sid_sessid = packet_get_string(&pctx->h_k_sid_sessid_len);
	packet_check_eom();

	JPAKE_DEBUG_CTX((pctx, "confirm received in %s", __func__));

	/* Verify expected confirmation hash */
	if (jpake_check_confirm(pctx->k,
	    pctx->server_id, pctx->server_id_len,
	    session_id2, session_id2_len,
	    pctx->h_k_sid_sessid, pctx->h_k_sid_sessid_len) == 1)
		debug("%s: %s success", __func__, authctxt->method->name);
	else {
		debug("%s: confirmation mismatch", __func__);
		/* XXX stash this so if auth succeeds then we can warn/kill */
	}

	userauth_jpake_cleanup(authctxt);
}
#endif /* JPAKE */

a1560 73

#ifdef JPAKE
int
userauth_jpake(Authctxt *authctxt)
{
	struct jpake_ctx *pctx;
	u_char *x1_proof, *x2_proof;
	u_int x1_proof_len, x2_proof_len;
	static int attempt = 0; /* XXX share with userauth_password's? */

	if (attempt++ >= options.number_of_password_prompts)
		return 0;
	if (attempt != 1)
		error("Permission denied, please try again.");

	if (authctxt->methoddata != NULL)
		fatal("%s: authctxt->methoddata already set (%p)",
		    __func__, authctxt->methoddata);

	authctxt->methoddata = pctx = jpake_new();

	/*
	 * Send request immediately, to get the protocol going while
	 * we do the initial computations.
	 */
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
	packet_send();
	packet_write_wait();

	jpake_step1(pctx->grp,
	    &pctx->client_id, &pctx->client_id_len,
	    &pctx->x1, &pctx->x2, &pctx->g_x1, &pctx->g_x2,
	    &x1_proof, &x1_proof_len,
	    &x2_proof, &x2_proof_len);

	JPAKE_DEBUG_CTX((pctx, "step 1 sending in %s", __func__));

	packet_start(SSH2_MSG_USERAUTH_JPAKE_CLIENT_STEP1);
	packet_put_string(pctx->client_id, pctx->client_id_len);
	packet_put_bignum2(pctx->g_x1);
	packet_put_bignum2(pctx->g_x2);
	packet_put_string(x1_proof, x1_proof_len);
	packet_put_string(x2_proof, x2_proof_len);
	packet_send();

	bzero(x1_proof, x1_proof_len);
	bzero(x2_proof, x2_proof_len);
	free(x1_proof);
	free(x2_proof);

	/* Expect step 1 packet from peer */
	dispatch_set(SSH2_MSG_USERAUTH_JPAKE_SERVER_STEP1,
	    input_userauth_jpake_server_step1);
	dispatch_set(SSH2_MSG_USERAUTH_SUCCESS,
	    &input_userauth_success_unexpected);

	return 1;
}

void
userauth_jpake_cleanup(Authctxt *authctxt)
{
	debug3("%s: clean up", __func__);
	if (authctxt->methoddata != NULL) {
		jpake_free(authctxt->methoddata);
		authctxt->methoddata = NULL;
	}
	dispatch_set(SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);
}
#endif /* JPAKE */
@


1.200
log
@refuse RSA keys from old proprietary clients/servers that use the
obsolete RSA+MD5 signature scheme. it will still be possible to connect
with these clients/servers but only DSA keys will be accepted, and we'll
deprecate them entirely in a future release. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.199 2013/11/02 21:59:15 markus Exp $ */
d1003 1
a1003 1
	if (hash_buffer(crypted, strlen(crypted), EVP_sha256(),
@


1.199
log
@use curve25519 for default key exchange (curve25519-sha256@@libssh.org);
initial patch from Aris Adamantiadis; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.198 2013/06/05 12:52:38 dtucker Exp $ */
d185 1
a185 1
		    options.hostkeyalgorithms;
d189 2
a190 1
		    order_hostkeyalgs(host, hostaddr, port);
d1487 11
a1497 5
		if (id->key && id->key->type != KEY_RSA1) {
			debug("Offering %s public key: %s", key_type(id->key),
			    id->filename);
			sent = send_pubkey_test(authctxt, id);
		} else if (id->key == NULL) {
d1503 9
a1511 1
				sent = sign_and_send_pubkey(authctxt, id);
@


1.198
log
@Fix memory leaks found by Zhenbo Xu and the Melton tool.  bz#1967, ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.197 2013/05/17 00:13:14 djm Exp $ */
d205 1
@


1.197
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.196 2013/05/16 02:00:34 dtucker Exp $ */
d1319 3
a1321 1
	if (!perm_ok)
d1323 1
d1915 1
@


1.196
log
@Add an optional second argument to RekeyLimit in the client to allow
rekeying based on elapsed time in addition to amount of traffic.
with djm@@ jmc@@, ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.195 2013/05/10 03:40:07 djm Exp $ */
d143 4
a146 4
	xfree(first);
	xfree(last);
	xfree(hostname);
	xfree(oavail);
d381 1
a381 1
		xfree(reply);
d428 2
a429 4
	if (authctxt->methoddata) {
		xfree(authctxt->methoddata);
		authctxt->methoddata = NULL;
	}
d433 1
a433 2
		if (authctxt->authlist)
			xfree(authctxt->authlist);
d481 1
a481 1
		xfree(msg);
d483 2
a484 2
	xfree(raw);
	xfree(lang);
d495 2
a496 4
	if (authctxt->authlist) {
		xfree(authctxt->authlist);
		authctxt->authlist = NULL;
	}
d499 2
a500 4
	if (authctxt->methoddata) {
		xfree(authctxt->methoddata);
		authctxt->methoddata = NULL;
	}
d589 1
a589 1
	xfree(fp);
d605 2
a606 2
	xfree(pkalg);
	xfree(pkblob);
d744 1
a744 1
		xfree(oidv);
d755 1
a755 1
	xfree(oidv);
d784 1
a784 1
	xfree(recv_tok.value);
d817 1
a817 1
	xfree(recv_tok.value);
d838 2
a839 2
	xfree(msg);
	xfree(lang);
d880 1
a880 1
	xfree(password);
d913 2
a914 2
	xfree(info);
	xfree(lang);
d926 1
a926 1
	xfree(password);
d943 1
a943 1
			xfree(password);
d948 1
a948 1
		xfree(retype);
d952 1
a952 1
	xfree(password);
d1007 2
a1008 2
	xfree(password);
	xfree(crypted);
d1013 1
a1013 1
	xfree(secret);
d1051 2
a1052 2
	xfree(crypt_scheme);
	xfree(salt);
d1067 2
a1068 2
	xfree(x3_proof);
	xfree(x4_proof);
d1079 1
a1079 1
	xfree(x2_s_proof);
d1119 1
a1119 1
	xfree(x4_s_proof);
d1201 1
a1201 1
	xfree(fp);
d1236 1
a1236 1
		xfree(blob);
d1256 1
a1256 1
	xfree(blob);
d1260 1
a1260 1
	xfree(signature);
d1300 1
a1300 1
	xfree(blob);
d1337 1
a1337 1
			xfree(passphrase);
d1414 1
a1414 1
					xfree(comment);
d1460 2
a1461 3
		if (id->filename)
			xfree(id->filename);
		xfree(id);
d1559 3
a1561 3
	xfree(name);
	xfree(inst);
	xfree(lang);
d1582 2
a1583 2
		xfree(response);
		xfree(prompt);
d1703 1
a1703 1
		xfree(blob);
d1708 1
a1708 1
	xfree(p);
d1737 3
a1739 3
		xfree(chost);
		xfree(pkalg);
		xfree(blob);
d1752 4
a1755 4
	xfree(signature);
	xfree(chost);
	xfree(pkalg);
	xfree(blob);
d1810 2
a1811 2
	xfree(x1_proof);
	xfree(x2_proof);
d1888 1
a1888 2
		if (supported != NULL)
			xfree(supported);
d1909 1
a1909 1
			xfree(name);
@


1.195
log
@fix bzero(ptr_to_struct, sizeof(ptr_to_struct)); bz#2100 from
Colin Watson
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.194 2013/04/05 00:14:00 djm Exp $ */
d194 3
a196 2
	if (options.rekey_limit)
		packet_set_rekey_limit((u_int32_t)options.rekey_limit);
@


1.194
log
@hush some {unused, printf type} warnings
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.193 2013/03/05 20:16:09 markus Exp $ */
d1406 1
a1406 1
			bzero(id, sizeof(id));
@


1.193
log
@reset pubkey order on partial success; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.192 2013/02/17 23:16:57 dtucker Exp $ */
d807 1
a807 1
	OM_uint32 status, ms;
d820 1
a820 1
	status = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,
a832 1
	OM_uint32 maj, min;
d836 2
a837 2
	maj=packet_get_int();
	min=packet_get_int();
@


1.192
log
@Keep track of which IndentityFile options were manually supplied and which
were default options, and don't warn if the latter are missing.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.191 2013/02/15 00:21:01 dtucker Exp $ */
d537 1
a537 1
	if (partial != 0)
d539 4
@


1.191
log
@Warn more loudly if an IdentityFile provided by the user cannot be read.
bz #1981, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.190 2012/12/02 20:26:11 djm Exp $ */
d1381 1
a1381 1
		id->userprovided = 1;
@


1.190
log
@Make IdentitiesOnly apply to keys obtained from a PKCS11Provider.
This allows control of which keys are offered from tokens using
IdentityFile. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.189 2012/06/22 12:30:26 dtucker Exp $ */
d245 1
d310 1
a310 1
static Key *load_identity_file(char *);
d1184 1
a1184 1
	if ((prv = load_identity_file(id->filename)) == NULL)
d1309 1
a1309 1
load_identity_file(char *filename)
d1317 2
a1318 1
		debug3("no such identity: %s", filename);
d1381 1
d1446 2
a1447 1
		debug2("key: %s (%p)", id->filename, id->key);
d1492 2
a1493 1
			id->key = load_identity_file(id->filename);
@


1.189
log
@remove dead code following 'for (;;)' loops.
From Steve.McClellan at radisys com, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.188 2011/05/24 07:15:47 djm Exp $ */
d1356 1
a1356 1
	Identity *id;
d1368 1
a1368 1
	/* list of keys stored in the filesystem */
d1380 23
@


1.188
log
@Remove undocumented legacy options UserKnownHostsFile2 and
GlobalKnownHostsFile2 by making UserKnownHostsFile/GlobalKnownHostsFile
accept multiple paths per line and making their defaults include
known_hosts2; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.187 2011/05/06 02:05:41 djm Exp $ */
a1889 2
	if (name != NULL)
		xfree(name);
@


1.187
log
@fix memory leak; bz#1849 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.186 2010/11/29 23:45:51 djm Exp $ */
d106 1
d111 4
a114 4
	load_hostkeys(hostkeys, hostname, options.user_hostfile2);
	load_hostkeys(hostkeys, hostname, options.system_hostfile2);
	load_hostkeys(hostkeys, hostname, options.user_hostfile);
	load_hostkeys(hostkeys, hostname, options.system_hostfile);
@


1.186
log
@automatically order the hostkeys requested by the client based on
which hostkeys are already recorded in known_hosts. This avoids
hostkey warnings when connecting to servers with new ECDSA keys
that are preferred by default; with markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.185 2010/09/22 05:01:29 djm Exp $ */
d1885 1
d1889 2
@


1.185
log
@add a KexAlgorithms knob to the client and server configuration to allow
selection of which key exchange methods are used by ssh(1) and sshd(8)
and their order of preference.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.184 2010/08/31 11:54:45 djm Exp $ */
d66 1
d99 52
d152 1
a152 1
ssh_kex2(char *host, struct sockaddr *hostaddr)
d185 5
@


1.184
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.183 2010/04/26 22:28:24 djm Exp $ */
d132 2
@


1.183
log
@bz#1502: authctxt.success is declared as an int, but passed by
reference to function that accepts sig_atomic_t*. Convert it to
the latter; ok markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.182 2010/04/16 01:47:26 djm Exp $ */
d142 1
@


1.182
log
@revised certificate format ssh-{dss,rsa}-cert-v01@@openssh.com with the
following changes:

move the nonce field to the beginning of the certificate where it can
better protect against chosen-prefix attacks on the signature hash

Rename "constraints" field to "critical options"

Add a new non-critical "extensions" field

Add a serial number

The older format is still support for authentication and cert generation
(use "ssh-keygen -t v00 -s ca_key ..." to generate a v00 certificate)

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.181 2010/04/10 02:10:56 djm Exp $ */
d192 1
a192 1
	int success;
@


1.181
log
@show the key type that we are offering in debug(), helps distinguish
between certs and plain keys as the path to the private key is usually
the same.
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.180 2010/02/26 20:29:54 djm Exp $ */
d1137 1
d1139 3
a1141 1
	debug3("sign_and_send_pubkey");
@


1.180
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.179 2010/01/13 01:20:20 dtucker Exp $ */
d1395 2
a1396 1
			debug("Offering public key: %s", id->filename);
@


1.179
log
@Make HostBased authentication work with a ProxyCommand.  bz #1569, patch
from imorgan at nas nasa gov, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.178 2010/01/11 04:46:45 dtucker Exp $ */
d1307 2
@


1.178
log
@Do not prompt for a passphrase if we fail to open a keyfile, and log the
reason the open failed to debug.
bz #1693, found by tj AT castaglia org, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.177 2010/01/04 01:45:30 dtucker Exp $ */
d1511 1
a1511 1
		error("ssh_keysign: no installed: %s", strerror(errno));
d1583 1
a1583 1
	char *chost, *pkalg, *p, myname[NI_MAXHOST];
d1607 1
a1607 10
	p = NULL;
	if (packet_connection_is_on_socket())
		p = get_local_name(packet_get_connection_in());
	if (p == NULL) {
		if (gethostname(myname, sizeof(myname)) == -1) {
			verbose("userauth_hostbased: gethostname: %s", 
			    strerror(errno));
		} else
			p = xstrdup(myname);
	}
@


1.177
log
@Don't escape backslashes in the SSH2 banner.  bz#1533, patch from
Michal Gorny via Gentoo.
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.176 2009/12/06 23:41:15 dtucker Exp $ */
d1247 1
a1247 1
	int perm_ok, quit, i;
@


1.176
log
@zap unused variable and strlen; from Steve McClellan, ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.175 2009/11/20 00:59:36 dtucker Exp $ */
d418 1
a418 1
		strnvis(msg, raw, len * 4 + 1, VIS_SAFE|VIS_OCTAL);
@


1.175
log
@Use the HostKeyAlias when prompting for passwords.  bz#1039, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.174 2009/11/10 04:30:45 dtucker Exp $ */
d1586 1
a1586 1
	int ok, i, len, found = 0;
a1622 1
	len = strlen(p) + 2;
@


1.174
log
@Set close-on-exec on various descriptors so they don't get leaked to
child processes.  bz #1643, patch from jchadima at redhat, ok deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.173 2009/10/24 11:13:54 andreas Exp $ */
d801 2
d811 1
a811 1
	    authctxt->server_user, authctxt->host);
d840 2
d862 1
a862 1
	    authctxt->server_user, authctxt->host);
d871 1
a871 1
		    authctxt->server_user, authctxt->host);
d879 1
a879 1
		    authctxt->server_user, authctxt->host);
@


1.173
log
@Let the client detect if the server supports roaming by looking
for the resume@@appgate.com kex algorithm.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.172 2009/10/23 01:57:11 djm Exp $ */
d34 1
d1525 2
@


1.172
log
@disallow a hostile server from checking jpake auth by sending an
out-of-sequence success message. (doesn't affect code enabled by default)
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.171 2009/03/05 07:18:19 djm Exp $ */
d148 5
@


1.171
log
@refactor the (disabled) Schnorr proof code to make it a little more
generally useful
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.170 2008/11/04 08:22:13 djm Exp $ */
d207 1
d425 1
d432 2
d441 12
d1722 2
d1736 1
@


1.170
log
@Add support for an experimental zero-knowledge password authentication
method using the J-PAKE protocol described in F. Hao, P. Ryan,
"Password Authenticated Key Exchange by Juggling", 16th Workshop on
Security Protocols, Cambridge, April 2008.

This method allows password-based authentication without exposing
the password to the server. Instead, the client and server exchange
cryptographic proofs to demonstrate of knowledge of the password while
revealing nothing useful to an attacker or compromised endpoint.

This is experimental, work-in-progress code and is presently
compiled-time disabled (turn on -DJPAKE in Makefile.inc).

"just commit it.  It isn't too intrusive." deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.169 2008/11/01 04:50:08 djm Exp $ */
d65 1
@


1.169
log
@sprinkle ARGSUSED on dispatch handlers
nuke stale unusued prototype
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.168 2008/10/03 23:56:28 deraadt Exp $ */
d4 1
d65 1
d200 1
d212 3
d221 3
d249 1
d255 1
d260 1
d263 7
d272 1
d277 1
d283 1
d285 1
a285 1
	{NULL, NULL, NULL, NULL}
d353 3
d873 203
d1650 70
d1821 1
@


1.168
log
@Repair strnvis() buffersize of 4*n+1, with termination gauranteed by the
function.
spotted by des@@freebsd, who commited an incorrect fix to the freebsd tree
and (as is fairly typical) did not report the problem to us.  But this fix
is correct.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.167 2008/07/31 14:48:28 markus Exp $ */
a214 1
int	userauth_kerberos(Authctxt *);
d363 1
d371 1
d393 1
d411 1
d432 2
d616 1
d656 1
d684 1
d714 1
d779 1
d783 1
@


1.167
log
@don't allocate space for empty banners; report t8m at centrum.cz; ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.166 2008/07/17 08:48:00 djm Exp $ */
d383 2
a384 2
		msg = xmalloc(len * 4); /* max expansion from strnvis() */
		strnvis(msg, raw, len * 4, VIS_SAFE|VIS_OCTAL);
@


1.166
log
@strnvis preauth banner; pointed out by mpf@@ ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.165 2008/01/19 23:09:49 djm Exp $ */
d380 1
a380 1
	if (options.log_level >= SYSLOG_LEVEL_INFO) {
@


1.165
log
@promote rekeylimit to a int64 so it can hold the maximum useful limit
of 2^32; report and patch from Jan.Pechanec AT Sun.COM, ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.164 2007/05/17 23:53:41 jolan Exp $ */
d39 1
d374 2
a375 1
	char *msg, *lang;
d378 1
a378 1
	msg = packet_get_string(NULL);
d380 5
a384 1
	if (options.log_level >= SYSLOG_LEVEL_INFO)
d386 3
a388 1
	xfree(msg);
@


1.164
log
@djm owes me a vb and a tism cd for breaking ssh compilation
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.163 2007/05/17 20:48:13 djm Exp $ */
d129 1
a129 1
		packet_set_rekey_limit(options.rekey_limit);
@


1.163
log
@fall back to gethostname() when the outgoing connection is not
on a socket, such as is the case when ProxyCommand is used.
Gives hostbased auth an opportunity to work; bz#616, report
and feedback stuart AT kaloram.com; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.162 2006/08/30 00:06:51 dtucker Exp $ */
d33 1
@


1.162
log
@Fix regression where SSH2 banner is printed at loglevels ERROR and FATAL
where previously it weren't.  bz #1221, found by Dean Kopesky, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.161 2006/08/18 13:54:54 djm Exp $ */
d1306 1
a1306 1
	char *chost, *pkalg, *p;
d1330 10
a1339 1
	p = get_local_name(packet_get_connection_in());
@


1.161
log
@bz #1218 - disable SPNEGO as per RFC4462; diff from simon AT sxw.org.uk
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.160 2006/08/03 03:34:42 deraadt Exp $ */
d377 1
a377 1
	if (options.log_level > SYSLOG_LEVEL_QUIET)
@


1.160
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.159 2006/08/01 23:22:48 stevesk Exp $ */
a507 5
		if (gssctxt)
			ssh_gssapi_delete_ctx(&gssctxt);
		ssh_gssapi_build_ctx(&gssctxt);
		ssh_gssapi_set_oid(gssctxt, &gss_supported->elements[mech]);

d510 2
a511 2
		    !GSS_ERROR(ssh_gssapi_import_name(gssctxt,
		    authctxt->host))) {
d518 1
a518 2
	if (!ok) {
		ssh_gssapi_delete_ctx(&gssctxt);
a519 1
	}
@


1.159
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.158 2006/07/22 20:48:23 stevesk Exp $ */
a25 2
#include "includes.h"

d27 1
d35 2
d39 1
a41 1
#include "xmalloc.h"
a44 1
#include "bufaux.h"
d46 1
@


1.158
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.157 2006/07/20 15:26:15 stevesk Exp $ */
d34 1
@


1.157
log
@missed some needed #include <unistd.h> when KERBEROS5=no; issue from
massimo@@cedoc.mo.it
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.156 2006/07/11 20:07:25 stevesk Exp $ */
d34 1
@


1.156
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.155 2006/06/08 14:45:49 markus Exp $ */
d34 1
@


1.155
log
@do not set the gid, noted by solar; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.154 2006/06/06 10:20:20 markus Exp $ */
d32 2
@


1.154
log
@replace remaining setuid() calls with permanently_set_uid() and
check seteuid() return values; report Marcus Meissner; ok dtucker djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.153 2006/05/08 10:49:48 djm Exp $ */
d1255 1
a1255 1
		permanently_set_uid(getpwuid(getuid()));
@


1.153
log
@uint32_t -> u_int32_t (which we use everywhere else)
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.152 2006/04/25 08:02:27 dtucker Exp $ */
d55 1
d1255 1
a1255 2
		seteuid(getuid());
		setuid(getuid());
@


1.152
log
@Prevent ssh from trying to open private keys with bad permissions more than
once or prompting for their passphrases (which it subsequently ignores
anyway), similar to a previous change in ssh-add.  bz #1186, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect2.c,v 1.151 2006/03/25 13:17:02 djm Exp $ */
d765 1
a765 1
input_userauth_passwd_changereq(int type, uint32_t seqnr, void *ctxt)
@


1.151
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d972 1
a972 1
	int quit, i;
d979 3
a981 1
	private = key_load_private_type(KEY_UNSPEC, filename, "", NULL);
d990 2
a991 2
				private = key_load_private_type(KEY_UNSPEC, filename,
				    passphrase, NULL);
@


1.150
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.149
log
@RCSID() can die
@
text
@d1031 1
a1031 2
		id = xmalloc(sizeof(*id));
		memset(id, 0, sizeof(*id));
d1055 1
a1055 2
				id = xmalloc(sizeof(*id));
				memset(id, 0, sizeof(*id));
d1336 1
a1336 3
	chost = xmalloc(len);
	strlcpy(chost, p, len);
	strlcat(chost, ".", len);
@


1.148
log
@memory leaks detected by Coverity via elad AT netbsd.org;
deraadt@@ ok
@
text
@a25 1
RCSID("$OpenBSD: sshconnect2.c,v 1.147 2006/03/07 09:07:40 djm Exp $");
@


1.147
log
@Implement the diffie-hellman-group-exchange-sha256 key exchange method
using the SHA256 code in libc (and wrapper to make it into an OpenSSL
EVP), interop tested against CVS PuTTY
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.146 2006/02/20 17:19:54 stevesk Exp $");
d516 2
a517 1
	if (!ok)
d519 1
d1335 1
d1374 1
d1390 1
@


1.146
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.145 2006/02/10 01:44:27 stevesk Exp $");
d128 1
@


1.146.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: sshconnect2.c,v 1.162 2006/08/30 00:06:51 dtucker Exp $ */
d25 3
a28 1
#include <sys/socket.h>
a32 8
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <pwd.h>
#include <unistd.h>

#include "xmalloc.h"
d35 1
d39 1
a40 1
#include "key.h"
a54 1
#include "uidswap.h"
a127 1
	kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;
d369 1
a369 1
	if (options.log_level >= SYSLOG_LEVEL_INFO)
d500 5
d507 2
a508 2
		    ssh_gssapi_check_mechanism(&gssctxt, 
		    &gss_supported->elements[mech], authctxt->host)) {
d762 1
a762 1
input_userauth_passwd_changereq(int type, u_int32_t seqnr, void *ctxt)
d969 1
a969 1
	int perm_ok, quit, i;
d976 1
a976 3
	private = key_load_private_type(KEY_UNSPEC, filename, "", NULL, &perm_ok);
	if (!perm_ok)
		return NULL;
d985 2
a986 2
				private = key_load_private_type(KEY_UNSPEC,
				    filename, passphrase, NULL, NULL);
d1029 2
a1030 1
		id = xcalloc(1, sizeof(*id));
d1054 2
a1055 1
				id = xcalloc(1, sizeof(*id));
d1251 2
a1252 1
		permanently_drop_suid(getuid());
a1331 1
		xfree(blob);
d1335 3
a1337 1
	xasprintf(&chost, "%s.", p);
a1369 1
		xfree(blob);
a1384 1
	xfree(blob);
@


1.145
log
@move #include <sys/wait.h> out of includes.h; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.144 2006/02/07 01:18:09 stevesk Exp $");
d31 1
@


1.144
log
@move #include <sys/queue.h> out of includes.h; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.143 2005/10/14 02:17:59 stevesk Exp $");
d28 2
@


1.143
log
@no trailing "\n" for log functions; ok djm@@
@
text
@d26 3
a28 1
RCSID("$OpenBSD: sshconnect2.c,v 1.142 2005/08/30 22:08:05 djm Exp $");
@


1.142
log
@destroy credentials if krb5_kuserok() call fails. Stops credentials being
delegated to users who are not authorised for GSSAPIAuthentication when
GSSAPIDeletegateCredentials=yes and another authentication mechanism succeeds;
bz#1073 reported by paul.moore AT centrify.com, fix by simon AT sxw.org.uk,
tested todd@@ biorn@@ jakob@@; ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.141 2005/07/25 11:59:40 markus Exp $");
d703 1
a703 1
	debug("Server GSSAPI Error:\n%s\n", msg);
@


1.142.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.143 2005/10/14 02:17:59 stevesk Exp $");
d703 1
a703 1
	debug("Server GSSAPI Error:\n%s", msg);
@


1.142.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: sshconnect2.c,v 1.162 2006/08/30 00:06:51 dtucker Exp $ */
d25 2
a26 12
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/queue.h>
#include <sys/stat.h>

#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <pwd.h>
#include <unistd.h>
a27 1
#include "xmalloc.h"
d30 1
d34 1
a35 1
#include "key.h"
a49 1
#include "uidswap.h"
a122 1
	kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;
d364 1
a364 1
	if (options.log_level >= SYSLOG_LEVEL_INFO)
d495 5
d502 2
a503 2
		    ssh_gssapi_check_mechanism(&gssctxt, 
		    &gss_supported->elements[mech], authctxt->host)) {
d757 1
a757 1
input_userauth_passwd_changereq(int type, u_int32_t seqnr, void *ctxt)
d964 1
a964 1
	int perm_ok, quit, i;
d971 1
a971 3
	private = key_load_private_type(KEY_UNSPEC, filename, "", NULL, &perm_ok);
	if (!perm_ok)
		return NULL;
d980 2
a981 2
				private = key_load_private_type(KEY_UNSPEC,
				    filename, passphrase, NULL, NULL);
d1024 2
a1025 1
		id = xcalloc(1, sizeof(*id));
d1049 2
a1050 1
				id = xcalloc(1, sizeof(*id));
d1246 2
a1247 1
		permanently_drop_suid(getuid());
a1326 1
		xfree(blob);
d1330 3
a1332 1
	xasprintf(&chost, "%s.", p);
a1364 1
		xfree(blob);
a1379 1
	xfree(blob);
@


1.141
log
@add a new compression method that delays compression until the user
has been authenticated successfully and set compression to 'delayed'
for sshd.

this breaks older openssh clients (< 3.5) if they insist on
compression, so you have to re-enable compression in sshd_config.
ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.140 2005/07/17 07:17:55 djm Exp $");
d546 2
a547 1
	gss_buffer_desc gssbuf, mic;
@


1.140
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.139 2005/06/17 02:44:33 djm Exp $");
d102 1
a102 1
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "zlib,none";
d105 1
a105 1
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none,zlib";
@


1.139
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.138 2004/06/13 12:53:24 djm Exp $");
d353 1
a353 1
	   "type %d", type);
d680 1
a680 1
				     &recv_tok, &send_tok, NULL);
@


1.138
log
@implement diffie-hellman-group14-sha1 kex method (trivial extension to
existing diffie-hellman-group1-sha1); ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.137 2004/05/08 00:21:31 djm Exp $");
d483 1
a483 1
	static int mech = 0;
d510 2
a511 1
	if (!ok) return 0;
@


1.138.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.142 2005/08/30 22:08:05 djm Exp $");
d102 1
a102 1
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "zlib@@openssh.com,zlib,none";
d105 1
a105 1
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none,zlib@@openssh.com,zlib";
d353 1
a353 1
	    "type %d", type);
d483 1
a483 1
	static u_int mech = 0;
d510 1
a510 2
	if (!ok)
		return 0;
d545 1
a545 2
	gss_buffer_desc mic = GSS_C_EMPTY_BUFFER;
	gss_buffer_desc gssbuf;
d679 1
a679 1
	    &recv_tok, &send_tok, NULL);
@


1.138.4.2
log
@upgrade to OpenSSH 4.3
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.143 2005/10/14 02:17:59 stevesk Exp $");
d703 1
a703 1
	debug("Server GSSAPI Error:\n%s", msg);
@


1.138.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.142 2005/08/30 22:08:05 djm Exp $");
d102 1
a102 1
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "zlib@@openssh.com,zlib,none";
d105 1
a105 1
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none,zlib@@openssh.com,zlib";
d353 1
a353 1
	    "type %d", type);
d483 1
a483 1
	static u_int mech = 0;
d510 1
a510 2
	if (!ok)
		return 0;
d545 1
a545 2
	gss_buffer_desc mic = GSS_C_EMPTY_BUFFER;
	gss_buffer_desc gssbuf;
d679 1
a679 1
	    &recv_tok, &send_tok, NULL);
@


1.137
log
@kill a tiny header; ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.136 2004/04/08 16:08:21 henning Exp $");
d121 1
@


1.136
log
@swap the last two parameters to TAILQ_FOREACH_REVERSE. matches what FreeBSD
and NetBSD do.
ok millert@@ mcbride@@ markus@@ ho@@, checked to not affect ports by naddy@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.135 2004/03/05 10:53:58 markus Exp $");
d44 1
a44 1
#include "readpass.h"
@


1.135
log
@add IdentitiesOnly; ok djm@@, pb@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.134 2004/01/19 21:25:15 markus Exp $");
d459 1
a459 1
	TAILQ_FOREACH_REVERSE(id, &authctxt->keys, next, idlist) {
@


1.135.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.138 2004/06/13 12:53:24 djm Exp $");
d44 1
a44 1
#include "misc.h"
a120 1
	kex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;
@


1.134
log
@fix mem leaks; some fixes from Pete Flugstad; tested dtucker@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.133 2003/11/21 11:57:03 djm Exp $");
d1045 1
a1045 1
			if (!found) {
@


1.133
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.132 2003/11/17 11:06:07 markus Exp $");
d1268 1
a1268 1
		buffer_clear(&b);
d1280 1
a1280 1
		buffer_clear(&b);
d1284 1
a1284 1
	buffer_clear(&b);
@


1.132
log
@replace "gssapi" with "gssapi-with-mic"; from Simon Wilkinson; test + ok jakob.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.131 2003/11/17 09:45:39 djm Exp $");
d477 1
a477 1
int 
d547 1
a547 1
	
d556 1
a556 1
			
d561 1
a561 1
	
d573 1
a573 1
			
d575 1
a575 1
			
d579 1
a579 1
				
d582 1
a582 1
				
d585 1
a585 1
		}	   
d587 1
a587 1
	
d1034 1
a1034 1
				/* agent keys from the config file are preferred */ 
@


1.131
log
@return error on msg send/receive failure (rather than fatal); ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.130 2003/11/14 13:19:09 markus Exp $");
d223 1
a223 1
	{"gssapi",
d544 3
a546 1
	OM_uint32 status, ms;
d549 1
a549 1
	    recv_tok, &send_tok, NULL);
d563 23
a585 3
		/* If that succeeded, send a exchange complete message */
		packet_start(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE);
		packet_send();
@


1.130
log
@cleanup and minor fixes for the client code; from Simon Wilkinson
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.129 2003/11/02 11:01:03 markus Exp $");
d1241 2
a1242 1
	ssh_msg_send(to[1], version, &b);
@


1.129
log
@remove support for SSH_BUG_GSSAPI_BER; simon@@sxw.org.uk
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.128 2003/10/26 16:57:43 avsm Exp $");
d538 31
a573 1
	OM_uint32 status, ms;
a575 1
	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;
d587 1
a589 1
		xfree(oidv);
d600 1
a600 9
	status = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,
	    GSS_C_NO_BUFFER, &send_tok, NULL);
	if (GSS_ERROR(status)) {
		if (send_tok.length > 0) {
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK);
			packet_put_string(send_tok.value, send_tok.length);
			packet_send();
			gss_release_buffer(&ms, &send_tok);
		}
a605 6

	/* We must have data to send */
	packet_start(SSH2_MSG_USERAUTH_GSSAPI_TOKEN);
	packet_put_string(send_tok.value, send_tok.length);
	packet_send();
	gss_release_buffer(&ms, &send_tok);
a611 2
	Gssctxt *gssctxt;
	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;
d613 1
a613 1
	OM_uint32 status, ms;
a617 1
	gssctxt = authctxt->methoddata;
d624 1
a624 2
	status = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,
	    &recv_tok, &send_tok, NULL);
a628 6
		if (send_tok.length > 0) {
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK);
			packet_put_string(send_tok.value, send_tok.length);
			packet_send();
			gss_release_buffer(&ms, &send_tok);
		}
a631 13
	}

	if (send_tok.length > 0) {
		packet_start(SSH2_MSG_USERAUTH_GSSAPI_TOKEN);
		packet_put_string(send_tok.value, send_tok.length);
		packet_send();
		gss_release_buffer(&ms, &send_tok);
	}

	if (status == GSS_S_COMPLETE) {
		/* If that succeeded, send a exchange complete message */
		packet_start(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE);
		packet_send();
@


1.128
log
@rename 'supported' static var in userauth_gssapi() to 'gss_supported'
to avoid shadowing the global version.  markus@@ ok
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.127 2003/10/11 08:26:43 markus Exp $");
d520 5
a524 11
	/* Some servers encode the OID incorrectly (as we used to) */
	if (datafellows & SSH_BUG_GSSAPI_BER) {
		packet_put_string(gss_supported->elements[mech].elements,
		    gss_supported->elements[mech].length);
	} else {
		packet_put_int((gss_supported->elements[mech].length)+2);
		packet_put_char(SSH_GSS_OIDTYPE);
		packet_put_char(gss_supported->elements[mech].length);
		packet_put_raw(gss_supported->elements[mech].elements,
		    gss_supported->elements[mech].length);
	}
d555 7
a561 12
	if (datafellows & SSH_BUG_GSSAPI_BER) {
		if (!ssh_gssapi_check_oid(gssctxt, oidv, oidlen))
			fatal("Server returned different OID than expected");
	} else {
		if(oidv[0] != SSH_GSS_OIDTYPE || oidv[1] != oidlen-2) {
			debug("Badly encoded mechanism OID received");
			userauth(authctxt, NULL);
			xfree(oidv);
			return;
		}
		if (!ssh_gssapi_check_oid(gssctxt, oidv+2, oidlen-2))
			fatal("Server returned different OID than expected");
d563 3
@


1.127
log
@search keys in reverse order; fixes #684
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.126 2003/10/07 21:58:28 deraadt Exp $");
d481 1
a481 1
	static gss_OID_set supported = NULL;
d489 2
a490 2
	if (supported == NULL)
		gss_indicate_mechs(&min, &supported);
d493 1
a493 1
	while (mech<supported->count && !ok) {
d497 1
a497 1
		ssh_gssapi_set_oid(gssctxt, &supported->elements[mech]);
d500 1
a500 1
		if (supported->elements[mech].length < 128 &&
d522 2
a523 2
		packet_put_string(supported->elements[mech].elements,
		    supported->elements[mech].length);
d525 1
a525 1
		packet_put_int((supported->elements[mech].length)+2);
d527 3
a529 3
		packet_put_char(supported->elements[mech].length);
		packet_put_raw(supported->elements[mech].elements,
		    supported->elements[mech].length);
@


1.126
log
@set ptr to NULL after free
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.125 2003/10/07 01:47:27 dtucker Exp $");
d454 6
a459 1
	TAILQ_FOREACH(id, &authctxt->keys, next) {
d1092 1
@


1.125
log
@Don't use logit for banner, since it truncates to MSGBUFSIZ; bz #668 & #707.
ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.124 2003/08/25 10:33:33 djm Exp $");
d359 1
d375 1
a375 1
	if (authctxt->authlist)
d377 3
a379 1
	if (authctxt->methoddata)
d381 2
d615 1
a615 1
	status=ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,
@


1.124
log
@fprintf->logit to silence login banner with "ssh -q"; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.123 2003/08/24 17:36:52 deraadt Exp $");
d362 2
a363 1
	logit("%s", msg);
@


1.124.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.134 2004/01/19 21:25:15 markus Exp $");
d223 1
a223 1
	{"gssapi-with-mic",
a358 1

d362 1
a362 2
	if (options.log_level > SYSLOG_LEVEL_QUIET)
		fprintf(stderr, "%s", msg);
d373 1
a373 1
	if (authctxt->authlist) {
d375 1
a375 3
		authctxt->authlist = NULL;
	}
	if (authctxt->methoddata) {
a376 2
		authctxt->methoddata = NULL;
	}
d448 1
a448 6
	/*
	 * search keys in the reverse order, because last candidate has been
	 * moved to the end of the queue.  this also avoids confusion by
	 * duplicate keys
	 */
	TAILQ_FOREACH_REVERSE(id, &authctxt->keys, next, idlist) {
d466 1
a466 1
int
d470 1
a470 1
	static gss_OID_set gss_supported = NULL;
d478 2
a479 2
	if (gss_supported == NULL)
		gss_indicate_mechs(&min, &gss_supported);
d482 1
a482 1
	while (mech < gss_supported->count && !ok) {
d486 1
a486 1
		ssh_gssapi_set_oid(gssctxt, &gss_supported->elements[mech]);
d489 1
a489 1
		if (gss_supported->elements[mech].length < 128 &&
d509 11
a519 5
	packet_put_int((gss_supported->elements[mech].length) + 2);
	packet_put_char(SSH_GSS_OIDTYPE);
	packet_put_char(gss_supported->elements[mech].length);
	packet_put_raw(gss_supported->elements[mech].elements,
	    gss_supported->elements[mech].length);
a532 53
static OM_uint32
process_gssapi_token(void *ctxt, gss_buffer_t recv_tok)
{
	Authctxt *authctxt = ctxt;
	Gssctxt *gssctxt = authctxt->methoddata;
	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;
	gss_buffer_desc gssbuf, mic;
	OM_uint32 status, ms, flags;
	Buffer b;

	status = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,
	    recv_tok, &send_tok, &flags);

	if (send_tok.length > 0) {
		if (GSS_ERROR(status))
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK);
		else
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_TOKEN);

		packet_put_string(send_tok.value, send_tok.length);
		packet_send();
		gss_release_buffer(&ms, &send_tok);
	}

	if (status == GSS_S_COMPLETE) {
		/* send either complete or MIC, depending on mechanism */
		if (!(flags & GSS_C_INTEG_FLAG)) {
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE);
			packet_send();
		} else {
			ssh_gssapi_buildmic(&b, authctxt->server_user,
			    authctxt->service, "gssapi-with-mic");

			gssbuf.value = buffer_ptr(&b);
			gssbuf.length = buffer_len(&b);

			status = ssh_gssapi_sign(gssctxt, &gssbuf, &mic);

			if (!GSS_ERROR(status)) {
				packet_start(SSH2_MSG_USERAUTH_GSSAPI_MIC);
				packet_put_string(mic.value, mic.length);

				packet_send();
			}

			buffer_free(&b);
			gss_release_buffer(&ms, &mic);
		}
	}

	return status;
}

d538 1
d541 1
d550 12
a561 7
	if (oidlen <= 2 ||
	    oidv[0] != SSH_GSS_OIDTYPE ||
	    oidv[1] != oidlen - 2) {
		xfree(oidv);
		debug("Badly encoded mechanism OID received");
		userauth(authctxt, NULL);
		return;
a563 3
	if (!ssh_gssapi_check_oid(gssctxt, oidv + 2, oidlen - 2))
		fatal("Server returned different OID than expected");

d568 9
a576 1
	if (GSS_ERROR(process_gssapi_token(ctxt, GSS_C_NO_BUFFER))) {
d582 6
d594 2
d597 1
a597 1
	OM_uint32 status;
d602 1
d609 2
a610 1
	status = process_gssapi_token(ctxt, &recv_tok);
d615 6
d625 13
d1017 1
a1017 1
				/* agent keys from the config file are preferred */
a1080 1
		/* move key to the end of the queue */
d1245 1
a1245 2
	if (ssh_msg_send(to[1], version, &b) == -1)
		fatal("ssh_keysign: couldn't send request");
d1249 1
a1249 1
		buffer_free(&b);
d1261 1
a1261 1
		buffer_free(&b);
d1265 1
a1265 1
	buffer_free(&b);
@


1.124.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.138 2004/06/13 12:53:24 djm Exp $");
d44 1
a44 1
#include "misc.h"
a120 1
	kex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;
d1045 1
a1045 1
			if (!found && !options.identities_only) {
@


1.123
log
@64 bit cleanups; markus ok
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.122 2003/08/22 13:20:03 markus Exp $");
d362 1
a362 1
	fprintf(stderr, "%s", msg);
@


1.122
log
@remove support for "kerberos-2@@ssh.com"
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.121 2003/08/22 10:56:09 markus Exp $");
d648 1
d654 2
a655 1
	recv_tok.value = packet_get_string(&recv_tok.length);
@


1.121
log
@support GSS API user authentication; patches from Simon Wilkinson,
stripped down and tested by Jakob and myself.
@
text
@d26 1
a26 5
RCSID("$OpenBSD: sshconnect2.c,v 1.120 2003/06/24 08:23:46 markus Exp $");

#ifdef KRB5
#include <krb5.h>
#endif
a231 6
#if KRB5
	{"kerberos-2@@ssh.com",
		userauth_kerberos,
		&options.kerberos_authentication,
		NULL},
#endif
a1359 88

#if KRB5
static int
ssh_krb5_helper(krb5_data *ap)
{
	krb5_context xcontext = NULL;	/* XXX share with ssh1 */
	krb5_auth_context xauth_context = NULL;

	krb5_context *context;
	krb5_auth_context *auth_context;
	krb5_error_code problem;
	const char *tkfile;
	struct stat buf;
	krb5_ccache ccache = NULL;
	const char *remotehost;
	int ret;

	memset(ap, 0, sizeof(*ap));

	context = &xcontext;
	auth_context = &xauth_context;

	problem = krb5_init_context(context);
	if (problem) {
		debug("Kerberos v5: krb5_init_context failed");
		ret = 0;
		goto out;
	}

	tkfile = krb5_cc_default_name(*context);
	if (strncmp(tkfile, "FILE:", 5) == 0)
		tkfile += 5;

	if (stat(tkfile, &buf) == 0 && getuid() != buf.st_uid) {
		debug("Kerberos v5: could not get default ccache (permission denied).");
		ret = 0;
		goto out;
	}

	problem = krb5_cc_default(*context, &ccache);
	if (problem) {
		debug("Kerberos v5: krb5_cc_default failed: %s",
		    krb5_get_err_text(*context, problem));
		ret = 0;
		goto out;
	}

	remotehost = get_canonical_hostname(1);

	problem = krb5_mk_req(*context, auth_context, AP_OPTS_MUTUAL_REQUIRED,
	    "host", remotehost, NULL, ccache, ap);
	if (problem) {
		debug("Kerberos v5: krb5_mk_req failed: %s",
		    krb5_get_err_text(*context, problem));
		ret = 0;
		goto out;
	}
	ret = 1;

 out:
	if (ccache != NULL)
		krb5_cc_close(*context, ccache);
	if (*auth_context)
		krb5_auth_con_free(*context, *auth_context);
	if (*context)
		krb5_free_context(*context);
	return (ret);
}

int
userauth_kerberos(Authctxt *authctxt)
{
	krb5_data ap;

	if (ssh_krb5_helper(&ap) == 0)
		return (0);

	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
	packet_put_string(ap.data, ap.length);
	packet_send();

	krb5_data_free(&ap);
	return (1);
}
#endif
@


1.120
log
@int -> u_int; ok djm@@, deraadt@@, mouring@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.119 2003/05/15 00:28:28 markus Exp $");
d55 4
d180 2
d205 9
d226 6
d302 1
d326 4
d385 2
d474 222
@


1.119
log
@cleanup unregister of per-method packet handlers; ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.118 2003/05/14 02:15:47 markus Exp $");
d65 1
a65 1
int session_id2_len = 0;
d589 1
a589 1
	int skip = 0;
@


1.118
log
@implement kerberos over ssh2 ("kerberos-2@@ssh.com"); tested with jakob@@
server interops with commercial client; ok jakob@@ djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.117 2003/05/12 16:55:37 markus Exp $");
a201 1
static void clear_auth_state(Authctxt *);
d296 2
d300 1
d316 6
a358 1
	clear_auth_state(authctxt);
a379 1
	clear_auth_state(authctxt);
a441 4
	/* unregister */
	clear_auth_state(authctxt);
	dispatch_set(SSH2_MSG_USERAUTH_PK_OK, NULL);

a555 7
}

static void
clear_auth_state(Authctxt *authctxt)
{
	/* XXX clear authentication state */
	dispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ, NULL);
@


1.117
log
@for pubkey authentication try the user keys in the following order:
	1. agent keys that are found in the config file
	2. other agent keys
	3. keys that are only listed in the config file
this helps when an agent has many keys, where the server might
close the connection before the correct key is used. report & ok pb@@
@
text
@d26 5
a30 1
RCSID("$OpenBSD: sshconnect2.c,v 1.116 2003/04/08 20:21:29 itojun Exp $");
d197 1
d216 6
d1125 88
@


1.116
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.115 2003/04/02 09:48:07 markus Exp $");
d144 2
d147 9
a155 3
typedef int sign_cb_fn(
    Authctxt *authctxt, Key *key,
    u_char **sigp, u_int *lenp, u_char *data, u_int datalen);
d166 1
a166 3
	Key *last_key;
	sign_cb_fn *last_key_sign;
	int last_key_hint;
d196 1
a196 1
static int sign_and_send_pubkey(Authctxt *, Key *, sign_cb_fn *);
d198 3
d263 1
a263 1
	authctxt.agent = ssh_get_authentication_connection();
d285 1
a285 3
	if (authctxt.agent != NULL)
		ssh_close_authentication_connection(authctxt.agent);

d370 1
d393 1
a393 2
	debug("Server accepts key: pkalg %s blen %u lastkey %p hint %d",
	    pkalg, blen, authctxt->last_key, authctxt->last_key_hint);
d395 21
a415 4
	do {
		if (authctxt->last_key == NULL ||
		    authctxt->last_key_sign == NULL) {
			debug("no last key or no sign cb");
d418 2
a419 25
		if ((pktype = key_type_from_name(pkalg)) == KEY_UNSPEC) {
			debug("unknown pkalg %s", pkalg);
			break;
		}
		if ((key = key_from_blob(pkblob, blen)) == NULL) {
			debug("no key from blob. pkalg %s", pkalg);
			break;
		}
		if (key->type != pktype) {
			error("input_userauth_pk_ok: type mismatch "
			    "for decoded key (received %d, expected %d)",
			    key->type, pktype);
			break;
		}
		fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
		debug2("input_userauth_pk_ok: fp %s", fp);
		xfree(fp);
		if (!key_equal(key, authctxt->last_key)) {
			debug("key != last_key");
			break;
		}
		sent = sign_and_send_pubkey(authctxt, key,
		   authctxt->last_key_sign);
	} while (0);

a431 1

d550 8
d559 16
a574 7
	if (authctxt->last_key != NULL && authctxt->last_key_hint == -1) {
		debug3("clear_auth_state: key_free %p", authctxt->last_key);
		key_free(authctxt->last_key);
	}
	authctxt->last_key = NULL;
	authctxt->last_key_hint = -2;
	authctxt->last_key_sign = NULL;
d578 1
a578 1
sign_and_send_pubkey(Authctxt *authctxt, Key *k, sign_cb_fn *sign_callback)
d589 1
a589 1
	if (key_to_blob(k, &blob, &bloblen) == 0) {
d614 1
a614 1
		buffer_put_cstring(&b, key_ssh_name(k));
d619 1
a619 1
	ret = (*sign_callback)(authctxt, k, &signature, &slen,
d639 1
a639 1
			buffer_put_cstring(&b, key_ssh_name(k));
d663 1
a663 2
send_pubkey_test(Authctxt *authctxt, Key *k, sign_cb_fn *sign_callback,
    int hint)
d670 1
a670 1
	if (key_to_blob(k, &blob, &bloblen) == 0) {
a675 3
	authctxt->last_key_sign = sign_callback;
	authctxt->last_key_hint = hint;
	authctxt->last_key = k;
d684 1
a684 1
		packet_put_cstring(key_ssh_name(k));
d729 8
a736 3
static int
identity_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d738 6
a743 2
	Key *private;
	int idx, ret;
d745 59
a803 14
	idx = authctxt->last_key_hint;
	if (idx < 0)
		return -1;

	/* private key is stored in external hardware */
	if (options.identity_keys[idx]->flags & KEY_FLAG_EXT)
		return key_sign(options.identity_keys[idx], sigp, lenp, data, datalen);

	private = load_identity_file(options.identity_files[idx]);
	if (private == NULL)
		return -1;
	ret = key_sign(private, sigp, lenp, data, datalen);
	key_free(private);
	return ret;
d806 2
a807 10
static int
agent_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
{
	return ssh_agent_sign(authctxt->agent, key, sigp, lenp, data, datalen);
}

static int
key_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d809 1
a809 2
	return key_sign(key, sigp, lenp, data, datalen);
}
d811 11
a821 26
static int
userauth_pubkey_agent(Authctxt *authctxt)
{
	static int called = 0;
	int ret = 0;
	char *comment;
	Key *k;

	if (called == 0) {
		if (ssh_get_num_identities(authctxt->agent, 2) == 0)
			debug2("userauth_pubkey_agent: no keys at all");
		called = 1;
	}
	k = ssh_get_next_identity(authctxt->agent, &comment, 2);
	if (k == NULL) {
		debug2("userauth_pubkey_agent: no more keys");
	} else {
		debug("Offering agent key: %s", comment);
		xfree(comment);
		ret = send_pubkey_test(authctxt, k, agent_sign_cb, -1);
		if (ret == 0)
			key_free(k);
	}
	if (ret == 0)
		debug2("userauth_pubkey_agent: no message sent");
	return ret;
d827 1
a827 1
	static int idx = 0;
a828 2
	Key *key;
	char *filename;
d830 21
a850 15
	if (authctxt->agent != NULL) {
		do {
			sent = userauth_pubkey_agent(authctxt);
		} while (!sent && authctxt->agent->howmany > 0);
	}
	while (!sent && idx < options.num_identity_files) {
		key = options.identity_keys[idx];
		filename = options.identity_files[idx];
		if (key == NULL) {
			debug("Trying private key: %s", filename);
			key = load_identity_file(filename);
			if (key != NULL) {
				sent = sign_and_send_pubkey(authctxt, key,
				    key_sign_cb);
				key_free(key);
a851 4
		} else if (key->type != KEY_RSA1) {
			debug("Offering public key: %s", filename);
			sent = send_pubkey_test(authctxt, key,
			    identity_sign_cb, idx);
d853 2
a854 1
		idx++;
d856 1
a856 1
	return sent;
@


1.115
log
@reapply rekeying chage, tested by henning@@, ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.114 2003/04/01 10:22:21 markus Exp $");
d85 1
a85 1
		log("No valid ciphers for protocol version 2 given, using defaults.");
d352 1
a352 1
		log("Authenticated with partial success.");
d497 1
a497 1
		log("%s", info);
d529 1
a529 1
			log("Mismatch; try again, EOF to quit.");
d868 1
a868 1
		log("%s", name);
d870 1
a870 1
		log("%s", inst);
@


1.114
log
@backout rekeying changes (for 3.6.1)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.113 2003/04/01 10:10:23 markus Exp $");
d110 3
@


1.113
log
@rekeying bugfixes and automatic rekeying:

* both client and server rekey _automatically_
      (a) after 2^31 packets, because after 2^32 packets
          the sequence number for packets wraps
      (b) after 2^(blocksize_in_bits/4) blocks
  (see: http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-00.txt)
  (a) and (b) are _enabled_ by default, and only disabled for known
  openssh versions, that don't support rekeying properly.
* client option 'RekeyLimit'
* do not reply to requests during rekeying
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.112 2003/03/05 22:33:43 markus Exp $");
a109 3

	if (options.rekey_limit)
		packet_set_rekey_limit(options.rekey_limit);
@


1.112
log
@fix memory leaks; from dlheine@@suif.Stanford.EDU/CLOUSEAU; ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.111 2003/02/16 17:09:57 markus Exp $");
d110 3
@


1.112.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.124 2003/08/25 10:33:33 djm Exp $");
a50 4
#ifdef GSSAPI
#include "ssh-gss.h"
#endif

d61 1
a61 1
u_int session_id2_len = 0;
d85 1
a85 1
		logit("No valid ciphers for protocol version 2 given, using defaults.");
a110 3
	if (options.rekey_limit)
		packet_set_rekey_limit(options.rekey_limit);

a140 2
typedef struct identity Identity;
typedef struct idlist Idlist;
d142 3
a144 9
struct identity {
	TAILQ_ENTRY(identity) next;
	AuthenticationConnection *ac;	/* set if agent supports key */
	Key	*key;			/* public/private key */
	char	*filename;		/* comment for agent-only keys */
	int	tried;
	int	isprivate;		/* key points to the private key */
};
TAILQ_HEAD(idlist, identity);
d155 3
a157 1
	Idlist keys;
a162 2
	/* generic */
	void *methoddata;
a183 10
int	userauth_kerberos(Authctxt *);

#ifdef GSSAPI
int	userauth_gssapi(Authctxt *authctxt);
void	input_gssapi_response(int type, u_int32_t, void *);
void	input_gssapi_token(int type, u_int32_t, void *);
void	input_gssapi_hash(int type, u_int32_t, void *);
void	input_gssapi_error(int, u_int32_t, void *);
void	input_gssapi_errtok(int, u_int32_t, void *);
#endif
d187 2
a188 4
static int sign_and_send_pubkey(Authctxt *, Identity *);
static void pubkey_prepare(Authctxt *);
static void pubkey_cleanup(Authctxt *);
static Key *load_identity_file(char *);
a194 6
#ifdef GSSAPI
	{"gssapi",
		userauth_gssapi,
		&options.gss_authentication,
		NULL},
#endif
d251 1
a251 1
	pubkey_prepare(&authctxt);
a258 1
	authctxt.methoddata = NULL;
d273 2
a274 2
	pubkey_cleanup(&authctxt);
	dispatch_range(SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);
a277 1

a280 4
	if (authctxt->methoddata) {
		xfree(authctxt->methoddata);
		authctxt->methoddata = NULL;
	}
a292 6

		/* reset the per method handler */
		dispatch_range(SSH2_MSG_USERAUTH_PER_METHOD_MIN,
		    SSH2_MSG_USERAUTH_PER_METHOD_MAX, NULL);

		/* and try new method */
d317 1
a317 1
	logit("%s", msg);
d330 1
a330 2
	if (authctxt->methoddata)
		xfree(authctxt->methoddata);
d349 1
a349 1
		logit("Authenticated with partial success.");
d352 1
a359 1
	Identity *id = NULL;
d382 2
a383 1
	debug("Server accepts key: pkalg %s blen %u", pkalg, blen);
d385 18
a402 21
	if ((pktype = key_type_from_name(pkalg)) == KEY_UNSPEC) {
		debug("unknown pkalg %s", pkalg);
		goto done;
	}
	if ((key = key_from_blob(pkblob, blen)) == NULL) {
		debug("no key from blob. pkalg %s", pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error("input_userauth_pk_ok: type mismatch "
		    "for decoded key (received %d, expected %d)",
		    key->type, pktype);
		goto done;
	}
	fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
	debug2("input_userauth_pk_ok: fp %s", fp);
	xfree(fp);

	TAILQ_FOREACH(id, &authctxt->keys, next) {
		if (key_equal(key, id->key)) {
			sent = sign_and_send_pubkey(authctxt, id);
d405 11
a415 2
	}
done:
d421 4
a427 199
}

#ifdef GSSAPI
int 
userauth_gssapi(Authctxt *authctxt)
{
	Gssctxt *gssctxt = NULL;
	static gss_OID_set supported = NULL;
	static int mech = 0;
	OM_uint32 min;
	int ok = 0;

	/* Try one GSSAPI method at a time, rather than sending them all at
	 * once. */

	if (supported == NULL)
		gss_indicate_mechs(&min, &supported);

	/* Check to see if the mechanism is usable before we offer it */
	while (mech<supported->count && !ok) {
		if (gssctxt)
			ssh_gssapi_delete_ctx(&gssctxt);
		ssh_gssapi_build_ctx(&gssctxt);
		ssh_gssapi_set_oid(gssctxt, &supported->elements[mech]);

		/* My DER encoding requires length<128 */
		if (supported->elements[mech].length < 128 &&
		    !GSS_ERROR(ssh_gssapi_import_name(gssctxt,
		    authctxt->host))) {
			ok = 1; /* Mechanism works */
		} else {
			mech++;
		}
	}

	if (!ok) return 0;

	authctxt->methoddata=(void *)gssctxt;

	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);

	packet_put_int(1);

	/* Some servers encode the OID incorrectly (as we used to) */
	if (datafellows & SSH_BUG_GSSAPI_BER) {
		packet_put_string(supported->elements[mech].elements,
		    supported->elements[mech].length);
	} else {
		packet_put_int((supported->elements[mech].length)+2);
		packet_put_char(SSH_GSS_OIDTYPE);
		packet_put_char(supported->elements[mech].length);
		packet_put_raw(supported->elements[mech].elements,
		    supported->elements[mech].length);
	}

	packet_send();

	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_RESPONSE, &input_gssapi_response);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_ERROR, &input_gssapi_error);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);

	mech++; /* Move along to next candidate */

	return 1;
}

void
input_gssapi_response(int type, u_int32_t plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	Gssctxt *gssctxt;
	OM_uint32 status, ms;
	int oidlen;
	char *oidv;
	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;

	if (authctxt == NULL)
		fatal("input_gssapi_response: no authentication context");
	gssctxt = authctxt->methoddata;

	/* Setup our OID */
	oidv = packet_get_string(&oidlen);

	if (datafellows & SSH_BUG_GSSAPI_BER) {
		if (!ssh_gssapi_check_oid(gssctxt, oidv, oidlen))
			fatal("Server returned different OID than expected");
	} else {
		if(oidv[0] != SSH_GSS_OIDTYPE || oidv[1] != oidlen-2) {
			debug("Badly encoded mechanism OID received");
			userauth(authctxt, NULL);
			xfree(oidv);
			return;
		}
		if (!ssh_gssapi_check_oid(gssctxt, oidv+2, oidlen-2))
			fatal("Server returned different OID than expected");
	}

	packet_check_eom();

	xfree(oidv);

	status = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,
	    GSS_C_NO_BUFFER, &send_tok, NULL);
	if (GSS_ERROR(status)) {
		if (send_tok.length > 0) {
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK);
			packet_put_string(send_tok.value, send_tok.length);
			packet_send();
			gss_release_buffer(&ms, &send_tok);
		}
		/* Start again with next method on list */
		debug("Trying to start again");
		userauth(authctxt, NULL);
		return;
	}

	/* We must have data to send */
	packet_start(SSH2_MSG_USERAUTH_GSSAPI_TOKEN);
	packet_put_string(send_tok.value, send_tok.length);
	packet_send();
	gss_release_buffer(&ms, &send_tok);
}

void
input_gssapi_token(int type, u_int32_t plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	Gssctxt *gssctxt;
	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;
	gss_buffer_desc recv_tok;
	OM_uint32 status, ms;
	u_int slen;

	if (authctxt == NULL)
		fatal("input_gssapi_response: no authentication context");
	gssctxt = authctxt->methoddata;

	recv_tok.value = packet_get_string(&slen);
	recv_tok.length = slen;	/* safe typecast */

	packet_check_eom();

	status=ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,
	    &recv_tok, &send_tok, NULL);

	xfree(recv_tok.value);

	if (GSS_ERROR(status)) {
		if (send_tok.length > 0) {
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK);
			packet_put_string(send_tok.value, send_tok.length);
			packet_send();
			gss_release_buffer(&ms, &send_tok);
		}
		/* Start again with the next method in the list */
		userauth(authctxt, NULL);
		return;
	}

	if (send_tok.length > 0) {
		packet_start(SSH2_MSG_USERAUTH_GSSAPI_TOKEN);
		packet_put_string(send_tok.value, send_tok.length);
		packet_send();
		gss_release_buffer(&ms, &send_tok);
	}

	if (status == GSS_S_COMPLETE) {
		/* If that succeeded, send a exchange complete message */
		packet_start(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE);
		packet_send();
	}
}

void
input_gssapi_errtok(int type, u_int32_t plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	Gssctxt *gssctxt;
	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;
	gss_buffer_desc recv_tok;
	OM_uint32 status, ms;
	u_int len;

	if (authctxt == NULL)
		fatal("input_gssapi_response: no authentication context");
	gssctxt = authctxt->methoddata;

	recv_tok.value = packet_get_string(&len);
	recv_tok.length = len;

	packet_check_eom();

	/* Stick it into GSSAPI and see what it says */
	status = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,
				     &recv_tok, &send_tok, NULL);
a428 4
	xfree(recv_tok.value);
	gss_release_buffer(&ms, &send_tok);

	/* Server will be returning a failed packet after this one */
a430 20
void
input_gssapi_error(int type, u_int32_t plen, void *ctxt)
{
	OM_uint32 maj, min;
	char *msg;
	char *lang;

	maj=packet_get_int();
	min=packet_get_int();
	msg=packet_get_string(NULL);
	lang=packet_get_string(NULL);

	packet_check_eom();

	debug("Server GSSAPI Error:\n%s\n", msg);
	xfree(msg);
	xfree(lang);
}
#endif /* GSSAPI */

d494 1
a494 1
		logit("%s", info);
d526 1
a526 1
			logit("Mismatch; try again, EOF to quit.");
d542 2
a543 3
static int
identity_sign(Identity *id, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d545 2
a546 2
	Key *prv;
	int ret;
d548 7
a554 16
	/* the agent supports this key */
	if (id->ac)
		return (ssh_agent_sign(id->ac, id->key, sigp, lenp,
		    data, datalen));
	/*
	 * we have already loaded the private key or
	 * the private key is stored in external hardware
	 */
	if (id->isprivate || (id->key->flags & KEY_FLAG_EXT))
		return (key_sign(id->key, sigp, lenp, data, datalen));
	/* load the private key from the file */
	if ((prv = load_identity_file(id->filename)) == NULL)
		return (-1);
	ret = key_sign(prv, sigp, lenp, data, datalen);
	key_free(prv);
	return (ret);
d558 1
a558 1
sign_and_send_pubkey(Authctxt *authctxt, Identity *id)
d563 1
a563 1
	u_int skip = 0;
d569 1
a569 1
	if (key_to_blob(id->key, &blob, &bloblen) == 0) {
d594 1
a594 1
		buffer_put_cstring(&b, key_ssh_name(id->key));
d599 1
a599 1
	ret = identity_sign(id, &signature, &slen,
d619 1
a619 1
			buffer_put_cstring(&b, key_ssh_name(id->key));
d643 2
a644 1
send_pubkey_test(Authctxt *authctxt, Identity *id)
d651 1
a651 1
	if (key_to_blob(id->key, &blob, &bloblen) == 0) {
d657 3
d668 1
a668 1
		packet_put_cstring(key_ssh_name(id->key));
d713 26
a738 8
/*
 * try keys in the following order:
 *	1. agent keys that are found in the config file
 *	2. other agent keys
 *	3. keys that are only listed in the config file
 */
static void
pubkey_prepare(Authctxt *authctxt)
d740 2
a741 6
	Identity *id;
	Idlist agent, files, *preferred;
	Key *key;
	AuthenticationConnection *ac;
	char *comment;
	int i, found;
d743 5
a747 59
	TAILQ_INIT(&agent);	/* keys from the agent */
	TAILQ_INIT(&files);	/* keys from the config file */
	preferred = &authctxt->keys;
	TAILQ_INIT(preferred);	/* preferred order of keys */

	/* list of keys stored in the filesystem */
	for (i = 0; i < options.num_identity_files; i++) {
		key = options.identity_keys[i];
		if (key && key->type == KEY_RSA1)
			continue;
		options.identity_keys[i] = NULL;
		id = xmalloc(sizeof(*id));
		memset(id, 0, sizeof(*id));
		id->key = key;
		id->filename = xstrdup(options.identity_files[i]);
		TAILQ_INSERT_TAIL(&files, id, next);
	}
	/* list of keys supported by the agent */
	if ((ac = ssh_get_authentication_connection())) {
		for (key = ssh_get_first_identity(ac, &comment, 2);
		    key != NULL;
		    key = ssh_get_next_identity(ac, &comment, 2)) {
			found = 0;
			TAILQ_FOREACH(id, &files, next) {
				/* agent keys from the config file are preferred */ 
				if (key_equal(key, id->key)) {
					key_free(key);
					xfree(comment);
					TAILQ_REMOVE(&files, id, next);
					TAILQ_INSERT_TAIL(preferred, id, next);
					id->ac = ac;
					found = 1;
					break;
				}
			}
			if (!found) {
				id = xmalloc(sizeof(*id));
				memset(id, 0, sizeof(*id));
				id->key = key;
				id->filename = comment;
				id->ac = ac;
				TAILQ_INSERT_TAIL(&agent, id, next);
			}
		}
		/* append remaining agent keys */
		for (id = TAILQ_FIRST(&agent); id; id = TAILQ_FIRST(&agent)) {
			TAILQ_REMOVE(&agent, id, next);
			TAILQ_INSERT_TAIL(preferred, id, next);
		}
		authctxt->agent = ac;
	}
	/* append remaining keys from the config file */
	for (id = TAILQ_FIRST(&files); id; id = TAILQ_FIRST(&files)) {
		TAILQ_REMOVE(&files, id, next);
		TAILQ_INSERT_TAIL(preferred, id, next);
	}
	TAILQ_FOREACH(id, preferred, next) {
		debug2("key: %s (%p)", id->filename, id->key);
	}
d750 2
a751 2
static void
pubkey_cleanup(Authctxt *authctxt)
d753 4
a756 1
	Identity *id;
d758 18
a775 11
	if (authctxt->agent != NULL)
		ssh_close_authentication_connection(authctxt->agent);
	for (id = TAILQ_FIRST(&authctxt->keys); id;
	    id = TAILQ_FIRST(&authctxt->keys)) {
		TAILQ_REMOVE(&authctxt->keys, id, next);
		if (id->key)
			key_free(id->key);
		if (id->filename)
			xfree(id->filename);
		xfree(id);
	}
d781 1
a781 1
	Identity *id;
d783 2
d786 15
a800 21
	while ((id = TAILQ_FIRST(&authctxt->keys))) {
		if (id->tried++)
			return (0);
		TAILQ_REMOVE(&authctxt->keys, id, next);
		TAILQ_INSERT_TAIL(&authctxt->keys, id, next);
		/*
		 * send a test message if we have the public key. for
		 * encrypted keys we cannot do this and have to load the
		 * private key instead
		 */
		if (id->key && id->key->type != KEY_RSA1) {
			debug("Offering public key: %s", id->filename);
			sent = send_pubkey_test(authctxt, id);
		} else if (id->key == NULL) {
			debug("Trying private key: %s", id->filename);
			id->key = load_identity_file(id->filename);
			if (id->key != NULL) {
				id->isprivate = 1;
				sent = sign_and_send_pubkey(authctxt, id);
				key_free(id->key);
				id->key = NULL;
d802 4
d807 1
a807 2
		if (sent)
			return (sent);
d809 1
a809 1
	return (0);
d865 1
a865 1
		logit("%s", name);
d867 1
a867 1
		logit("%s", inst);
@


1.112.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.134 2004/01/19 21:25:15 markus Exp $");
d223 1
a223 1
	{"gssapi-with-mic",
a358 1

d362 1
a362 2
	if (options.log_level > SYSLOG_LEVEL_QUIET)
		fprintf(stderr, "%s", msg);
d373 1
a373 1
	if (authctxt->authlist) {
d375 1
a375 3
		authctxt->authlist = NULL;
	}
	if (authctxt->methoddata) {
a376 2
		authctxt->methoddata = NULL;
	}
d448 1
a448 6
	/*
	 * search keys in the reverse order, because last candidate has been
	 * moved to the end of the queue.  this also avoids confusion by
	 * duplicate keys
	 */
	TAILQ_FOREACH_REVERSE(id, &authctxt->keys, next, idlist) {
d466 1
a466 1
int
d470 1
a470 1
	static gss_OID_set gss_supported = NULL;
d478 2
a479 2
	if (gss_supported == NULL)
		gss_indicate_mechs(&min, &gss_supported);
d482 1
a482 1
	while (mech < gss_supported->count && !ok) {
d486 1
a486 1
		ssh_gssapi_set_oid(gssctxt, &gss_supported->elements[mech]);
d489 1
a489 1
		if (gss_supported->elements[mech].length < 128 &&
d509 11
a519 5
	packet_put_int((gss_supported->elements[mech].length) + 2);
	packet_put_char(SSH_GSS_OIDTYPE);
	packet_put_char(gss_supported->elements[mech].length);
	packet_put_raw(gss_supported->elements[mech].elements,
	    gss_supported->elements[mech].length);
a532 53
static OM_uint32
process_gssapi_token(void *ctxt, gss_buffer_t recv_tok)
{
	Authctxt *authctxt = ctxt;
	Gssctxt *gssctxt = authctxt->methoddata;
	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;
	gss_buffer_desc gssbuf, mic;
	OM_uint32 status, ms, flags;
	Buffer b;

	status = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,
	    recv_tok, &send_tok, &flags);

	if (send_tok.length > 0) {
		if (GSS_ERROR(status))
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK);
		else
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_TOKEN);

		packet_put_string(send_tok.value, send_tok.length);
		packet_send();
		gss_release_buffer(&ms, &send_tok);
	}

	if (status == GSS_S_COMPLETE) {
		/* send either complete or MIC, depending on mechanism */
		if (!(flags & GSS_C_INTEG_FLAG)) {
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE);
			packet_send();
		} else {
			ssh_gssapi_buildmic(&b, authctxt->server_user,
			    authctxt->service, "gssapi-with-mic");

			gssbuf.value = buffer_ptr(&b);
			gssbuf.length = buffer_len(&b);

			status = ssh_gssapi_sign(gssctxt, &gssbuf, &mic);

			if (!GSS_ERROR(status)) {
				packet_start(SSH2_MSG_USERAUTH_GSSAPI_MIC);
				packet_put_string(mic.value, mic.length);

				packet_send();
			}

			buffer_free(&b);
			gss_release_buffer(&ms, &mic);
		}
	}

	return status;
}

d538 1
d541 1
d550 12
a561 7
	if (oidlen <= 2 ||
	    oidv[0] != SSH_GSS_OIDTYPE ||
	    oidv[1] != oidlen - 2) {
		xfree(oidv);
		debug("Badly encoded mechanism OID received");
		userauth(authctxt, NULL);
		return;
a563 3
	if (!ssh_gssapi_check_oid(gssctxt, oidv + 2, oidlen - 2))
		fatal("Server returned different OID than expected");

d568 9
a576 1
	if (GSS_ERROR(process_gssapi_token(ctxt, GSS_C_NO_BUFFER))) {
d582 6
d594 2
d597 1
a597 1
	OM_uint32 status;
d602 1
d609 2
a610 1
	status = process_gssapi_token(ctxt, &recv_tok);
d615 6
d625 13
d1017 1
a1017 1
				/* agent keys from the config file are preferred */
a1080 1
		/* move key to the end of the queue */
d1245 1
a1245 2
	if (ssh_msg_send(to[1], version, &b) == -1)
		fatal("ssh_keysign: couldn't send request");
d1249 1
a1249 1
		buffer_free(&b);
d1261 1
a1261 1
		buffer_free(&b);
d1265 1
a1265 1
	buffer_free(&b);
@


1.111
log
@split kex into client and server code, no need to link
server code into the client; ok provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.110 2002/12/19 00:07:02 djm Exp $");
d1017 1
@


1.110
log
@s/msg_send/ssh_msg_send/ to avoid namespace clashes in portable; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.109 2002/12/13 10:03:15 markus Exp $");
d113 2
@


1.109
log
@cleanup debug messages, more useful information for the client user.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.108 2002/11/21 22:45:31 markus Exp $");
d948 1
a948 1
	msg_send(to[1], version, &b);
d950 1
a950 1
	if (msg_recv(from[0], &b) < 0) {
@


1.108
log
@debug->debug2, unify debug messages
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.107 2002/07/01 19:48:46 markus Exp $");
d239 1
a239 1
		debug("buggy server: service_accept w/o service");
d274 1
a274 1
	debug("ssh-userauth2 successful: method %s", authctxt.method->name);
d348 1
a348 1
	debug("authentications that can continue: %s", authlist);
d380 1
a380 1
	debug("input_userauth_pk_ok: pkalg %s blen %u lastkey %p hint %d",
d765 1
a765 1
		debug("userauth_pubkey_agent: testing agent key %s", comment);
d793 1
a793 1
			debug("try privkey: %s", filename);
d801 1
a801 1
			debug("try pubkey: %s", filename);
d907 1
a907 1
	debug("ssh_keysign called");
d996 1
a996 1
		debug("userauth_hostbased: no more client hostkeys");
a1109 1

d1130 1
a1130 1
			debug("no more auth methods to try");
d1140 1
a1140 1
			debug("next auth method to try is %s", name);
@


1.107
log
@for compression=yes, we fallback to no-compression if the server does
not support compression, vice versa for compression=no. ok mouring@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.106 2002/06/30 21:59:45 deraadt Exp $");
a130 1
	debug("done: ssh_kex2.");
a225 1
	debug("send SSH2_MSG_SERVICE_REQUEST");
d229 1
d232 2
a233 3
	if (type != SSH2_MSG_SERVICE_ACCEPT) {
		fatal("denied SSH2_MSG_SERVICE_ACCEPT: %d", type);
	}
d236 1
a236 1
		debug("service_accept: %s", reply);
d242 1
a242 1
	debug("got SSH2_MSG_SERVICE_ACCEPT");
@


1.107.2.1
log
@Update to OpenSSH 3.6
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.112 2003/03/05 22:33:43 markus Exp $");
a112 2
	kex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;
	kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;
d131 1
d227 1
a230 1
	debug("SSH2_MSG_SERVICE_REQUEST sent");
d233 3
a235 2
	if (type != SSH2_MSG_SERVICE_ACCEPT)
		fatal("Server denied authentication request: %d", type);
d238 1
a238 1
		debug2("service_accept: %s", reply);
d241 1
a241 1
		debug2("buggy server: service_accept w/o service");
d244 1
a244 1
	debug("SSH2_MSG_SERVICE_ACCEPT received");
d276 1
a276 1
	debug("Authentication succeeded (%s).", authctxt.method->name);
d350 1
a350 1
	debug("Authentications that can continue: %s", authlist);
d382 1
a382 1
	debug("Server accepts key: pkalg %s blen %u lastkey %p hint %d",
d767 1
a767 1
		debug("Offering agent key: %s", comment);
d795 1
a795 1
			debug("Trying private key: %s", filename);
d803 1
a803 1
			debug("Offering public key: %s", filename);
d909 1
a909 1
	debug2("ssh_keysign called");
d950 1
a950 1
	ssh_msg_send(to[1], version, &b);
d952 1
a952 1
	if (ssh_msg_recv(from[0], &b) < 0) {
d998 1
a998 1
		debug("No more client hostkeys for hostbased authentication.");
a1016 1
	xfree(p);
d1112 1
d1133 1
a1133 1
			debug("No more authentication methods to try.");
d1143 1
a1143 1
			debug("Next authentication method: %s", name);
@


1.107.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.124 2003/08/25 10:33:33 djm Exp $");
a50 4
#ifdef GSSAPI
#include "ssh-gss.h"
#endif

d61 1
a61 1
u_int session_id2_len = 0;
d85 1
a85 1
		logit("No valid ciphers for protocol version 2 given, using defaults.");
a110 3
	if (options.rekey_limit)
		packet_set_rekey_limit(options.rekey_limit);

a140 2
typedef struct identity Identity;
typedef struct idlist Idlist;
d142 3
a144 9
struct identity {
	TAILQ_ENTRY(identity) next;
	AuthenticationConnection *ac;	/* set if agent supports key */
	Key	*key;			/* public/private key */
	char	*filename;		/* comment for agent-only keys */
	int	tried;
	int	isprivate;		/* key points to the private key */
};
TAILQ_HEAD(idlist, identity);
d155 3
a157 1
	Idlist keys;
a162 2
	/* generic */
	void *methoddata;
a183 10
int	userauth_kerberos(Authctxt *);

#ifdef GSSAPI
int	userauth_gssapi(Authctxt *authctxt);
void	input_gssapi_response(int type, u_int32_t, void *);
void	input_gssapi_token(int type, u_int32_t, void *);
void	input_gssapi_hash(int type, u_int32_t, void *);
void	input_gssapi_error(int, u_int32_t, void *);
void	input_gssapi_errtok(int, u_int32_t, void *);
#endif
d187 2
a188 4
static int sign_and_send_pubkey(Authctxt *, Identity *);
static void pubkey_prepare(Authctxt *);
static void pubkey_cleanup(Authctxt *);
static Key *load_identity_file(char *);
a194 6
#ifdef GSSAPI
	{"gssapi",
		userauth_gssapi,
		&options.gss_authentication,
		NULL},
#endif
d251 1
a251 1
	pubkey_prepare(&authctxt);
a258 1
	authctxt.methoddata = NULL;
d273 2
a274 2
	pubkey_cleanup(&authctxt);
	dispatch_range(SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);
a277 1

a280 4
	if (authctxt->methoddata) {
		xfree(authctxt->methoddata);
		authctxt->methoddata = NULL;
	}
a292 6

		/* reset the per method handler */
		dispatch_range(SSH2_MSG_USERAUTH_PER_METHOD_MIN,
		    SSH2_MSG_USERAUTH_PER_METHOD_MAX, NULL);

		/* and try new method */
d317 1
a317 1
	logit("%s", msg);
d330 1
a330 2
	if (authctxt->methoddata)
		xfree(authctxt->methoddata);
d349 1
a349 1
		logit("Authenticated with partial success.");
d352 1
a359 1
	Identity *id = NULL;
d382 2
a383 1
	debug("Server accepts key: pkalg %s blen %u", pkalg, blen);
d385 18
a402 21
	if ((pktype = key_type_from_name(pkalg)) == KEY_UNSPEC) {
		debug("unknown pkalg %s", pkalg);
		goto done;
	}
	if ((key = key_from_blob(pkblob, blen)) == NULL) {
		debug("no key from blob. pkalg %s", pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error("input_userauth_pk_ok: type mismatch "
		    "for decoded key (received %d, expected %d)",
		    key->type, pktype);
		goto done;
	}
	fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
	debug2("input_userauth_pk_ok: fp %s", fp);
	xfree(fp);

	TAILQ_FOREACH(id, &authctxt->keys, next) {
		if (key_equal(key, id->key)) {
			sent = sign_and_send_pubkey(authctxt, id);
d405 11
a415 2
	}
done:
d421 4
a427 199
}

#ifdef GSSAPI
int 
userauth_gssapi(Authctxt *authctxt)
{
	Gssctxt *gssctxt = NULL;
	static gss_OID_set supported = NULL;
	static int mech = 0;
	OM_uint32 min;
	int ok = 0;

	/* Try one GSSAPI method at a time, rather than sending them all at
	 * once. */

	if (supported == NULL)
		gss_indicate_mechs(&min, &supported);

	/* Check to see if the mechanism is usable before we offer it */
	while (mech<supported->count && !ok) {
		if (gssctxt)
			ssh_gssapi_delete_ctx(&gssctxt);
		ssh_gssapi_build_ctx(&gssctxt);
		ssh_gssapi_set_oid(gssctxt, &supported->elements[mech]);

		/* My DER encoding requires length<128 */
		if (supported->elements[mech].length < 128 &&
		    !GSS_ERROR(ssh_gssapi_import_name(gssctxt,
		    authctxt->host))) {
			ok = 1; /* Mechanism works */
		} else {
			mech++;
		}
	}

	if (!ok) return 0;

	authctxt->methoddata=(void *)gssctxt;

	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);

	packet_put_int(1);

	/* Some servers encode the OID incorrectly (as we used to) */
	if (datafellows & SSH_BUG_GSSAPI_BER) {
		packet_put_string(supported->elements[mech].elements,
		    supported->elements[mech].length);
	} else {
		packet_put_int((supported->elements[mech].length)+2);
		packet_put_char(SSH_GSS_OIDTYPE);
		packet_put_char(supported->elements[mech].length);
		packet_put_raw(supported->elements[mech].elements,
		    supported->elements[mech].length);
	}

	packet_send();

	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_RESPONSE, &input_gssapi_response);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_ERROR, &input_gssapi_error);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);

	mech++; /* Move along to next candidate */

	return 1;
}

void
input_gssapi_response(int type, u_int32_t plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	Gssctxt *gssctxt;
	OM_uint32 status, ms;
	int oidlen;
	char *oidv;
	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;

	if (authctxt == NULL)
		fatal("input_gssapi_response: no authentication context");
	gssctxt = authctxt->methoddata;

	/* Setup our OID */
	oidv = packet_get_string(&oidlen);

	if (datafellows & SSH_BUG_GSSAPI_BER) {
		if (!ssh_gssapi_check_oid(gssctxt, oidv, oidlen))
			fatal("Server returned different OID than expected");
	} else {
		if(oidv[0] != SSH_GSS_OIDTYPE || oidv[1] != oidlen-2) {
			debug("Badly encoded mechanism OID received");
			userauth(authctxt, NULL);
			xfree(oidv);
			return;
		}
		if (!ssh_gssapi_check_oid(gssctxt, oidv+2, oidlen-2))
			fatal("Server returned different OID than expected");
	}

	packet_check_eom();

	xfree(oidv);

	status = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,
	    GSS_C_NO_BUFFER, &send_tok, NULL);
	if (GSS_ERROR(status)) {
		if (send_tok.length > 0) {
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK);
			packet_put_string(send_tok.value, send_tok.length);
			packet_send();
			gss_release_buffer(&ms, &send_tok);
		}
		/* Start again with next method on list */
		debug("Trying to start again");
		userauth(authctxt, NULL);
		return;
	}

	/* We must have data to send */
	packet_start(SSH2_MSG_USERAUTH_GSSAPI_TOKEN);
	packet_put_string(send_tok.value, send_tok.length);
	packet_send();
	gss_release_buffer(&ms, &send_tok);
}

void
input_gssapi_token(int type, u_int32_t plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	Gssctxt *gssctxt;
	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;
	gss_buffer_desc recv_tok;
	OM_uint32 status, ms;
	u_int slen;

	if (authctxt == NULL)
		fatal("input_gssapi_response: no authentication context");
	gssctxt = authctxt->methoddata;

	recv_tok.value = packet_get_string(&slen);
	recv_tok.length = slen;	/* safe typecast */

	packet_check_eom();

	status=ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,
	    &recv_tok, &send_tok, NULL);

	xfree(recv_tok.value);

	if (GSS_ERROR(status)) {
		if (send_tok.length > 0) {
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK);
			packet_put_string(send_tok.value, send_tok.length);
			packet_send();
			gss_release_buffer(&ms, &send_tok);
		}
		/* Start again with the next method in the list */
		userauth(authctxt, NULL);
		return;
	}

	if (send_tok.length > 0) {
		packet_start(SSH2_MSG_USERAUTH_GSSAPI_TOKEN);
		packet_put_string(send_tok.value, send_tok.length);
		packet_send();
		gss_release_buffer(&ms, &send_tok);
	}

	if (status == GSS_S_COMPLETE) {
		/* If that succeeded, send a exchange complete message */
		packet_start(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE);
		packet_send();
	}
}

void
input_gssapi_errtok(int type, u_int32_t plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	Gssctxt *gssctxt;
	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;
	gss_buffer_desc recv_tok;
	OM_uint32 status, ms;
	u_int len;

	if (authctxt == NULL)
		fatal("input_gssapi_response: no authentication context");
	gssctxt = authctxt->methoddata;

	recv_tok.value = packet_get_string(&len);
	recv_tok.length = len;

	packet_check_eom();

	/* Stick it into GSSAPI and see what it says */
	status = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,
				     &recv_tok, &send_tok, NULL);
a428 4
	xfree(recv_tok.value);
	gss_release_buffer(&ms, &send_tok);

	/* Server will be returning a failed packet after this one */
a430 20
void
input_gssapi_error(int type, u_int32_t plen, void *ctxt)
{
	OM_uint32 maj, min;
	char *msg;
	char *lang;

	maj=packet_get_int();
	min=packet_get_int();
	msg=packet_get_string(NULL);
	lang=packet_get_string(NULL);

	packet_check_eom();

	debug("Server GSSAPI Error:\n%s\n", msg);
	xfree(msg);
	xfree(lang);
}
#endif /* GSSAPI */

d494 1
a494 1
		logit("%s", info);
d526 1
a526 1
			logit("Mismatch; try again, EOF to quit.");
d542 2
a543 3
static int
identity_sign(Identity *id, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d545 2
a546 2
	Key *prv;
	int ret;
d548 7
a554 16
	/* the agent supports this key */
	if (id->ac)
		return (ssh_agent_sign(id->ac, id->key, sigp, lenp,
		    data, datalen));
	/*
	 * we have already loaded the private key or
	 * the private key is stored in external hardware
	 */
	if (id->isprivate || (id->key->flags & KEY_FLAG_EXT))
		return (key_sign(id->key, sigp, lenp, data, datalen));
	/* load the private key from the file */
	if ((prv = load_identity_file(id->filename)) == NULL)
		return (-1);
	ret = key_sign(prv, sigp, lenp, data, datalen);
	key_free(prv);
	return (ret);
d558 1
a558 1
sign_and_send_pubkey(Authctxt *authctxt, Identity *id)
d563 1
a563 1
	u_int skip = 0;
d569 1
a569 1
	if (key_to_blob(id->key, &blob, &bloblen) == 0) {
d594 1
a594 1
		buffer_put_cstring(&b, key_ssh_name(id->key));
d599 1
a599 1
	ret = identity_sign(id, &signature, &slen,
d619 1
a619 1
			buffer_put_cstring(&b, key_ssh_name(id->key));
d643 2
a644 1
send_pubkey_test(Authctxt *authctxt, Identity *id)
d651 1
a651 1
	if (key_to_blob(id->key, &blob, &bloblen) == 0) {
d657 3
d668 1
a668 1
		packet_put_cstring(key_ssh_name(id->key));
d713 26
a738 8
/*
 * try keys in the following order:
 *	1. agent keys that are found in the config file
 *	2. other agent keys
 *	3. keys that are only listed in the config file
 */
static void
pubkey_prepare(Authctxt *authctxt)
d740 2
a741 6
	Identity *id;
	Idlist agent, files, *preferred;
	Key *key;
	AuthenticationConnection *ac;
	char *comment;
	int i, found;
d743 5
a747 59
	TAILQ_INIT(&agent);	/* keys from the agent */
	TAILQ_INIT(&files);	/* keys from the config file */
	preferred = &authctxt->keys;
	TAILQ_INIT(preferred);	/* preferred order of keys */

	/* list of keys stored in the filesystem */
	for (i = 0; i < options.num_identity_files; i++) {
		key = options.identity_keys[i];
		if (key && key->type == KEY_RSA1)
			continue;
		options.identity_keys[i] = NULL;
		id = xmalloc(sizeof(*id));
		memset(id, 0, sizeof(*id));
		id->key = key;
		id->filename = xstrdup(options.identity_files[i]);
		TAILQ_INSERT_TAIL(&files, id, next);
	}
	/* list of keys supported by the agent */
	if ((ac = ssh_get_authentication_connection())) {
		for (key = ssh_get_first_identity(ac, &comment, 2);
		    key != NULL;
		    key = ssh_get_next_identity(ac, &comment, 2)) {
			found = 0;
			TAILQ_FOREACH(id, &files, next) {
				/* agent keys from the config file are preferred */ 
				if (key_equal(key, id->key)) {
					key_free(key);
					xfree(comment);
					TAILQ_REMOVE(&files, id, next);
					TAILQ_INSERT_TAIL(preferred, id, next);
					id->ac = ac;
					found = 1;
					break;
				}
			}
			if (!found) {
				id = xmalloc(sizeof(*id));
				memset(id, 0, sizeof(*id));
				id->key = key;
				id->filename = comment;
				id->ac = ac;
				TAILQ_INSERT_TAIL(&agent, id, next);
			}
		}
		/* append remaining agent keys */
		for (id = TAILQ_FIRST(&agent); id; id = TAILQ_FIRST(&agent)) {
			TAILQ_REMOVE(&agent, id, next);
			TAILQ_INSERT_TAIL(preferred, id, next);
		}
		authctxt->agent = ac;
	}
	/* append remaining keys from the config file */
	for (id = TAILQ_FIRST(&files); id; id = TAILQ_FIRST(&files)) {
		TAILQ_REMOVE(&files, id, next);
		TAILQ_INSERT_TAIL(preferred, id, next);
	}
	TAILQ_FOREACH(id, preferred, next) {
		debug2("key: %s (%p)", id->filename, id->key);
	}
d750 2
a751 2
static void
pubkey_cleanup(Authctxt *authctxt)
d753 4
a756 1
	Identity *id;
d758 18
a775 11
	if (authctxt->agent != NULL)
		ssh_close_authentication_connection(authctxt->agent);
	for (id = TAILQ_FIRST(&authctxt->keys); id;
	    id = TAILQ_FIRST(&authctxt->keys)) {
		TAILQ_REMOVE(&authctxt->keys, id, next);
		if (id->key)
			key_free(id->key);
		if (id->filename)
			xfree(id->filename);
		xfree(id);
	}
d781 1
a781 1
	Identity *id;
d783 2
d786 15
a800 21
	while ((id = TAILQ_FIRST(&authctxt->keys))) {
		if (id->tried++)
			return (0);
		TAILQ_REMOVE(&authctxt->keys, id, next);
		TAILQ_INSERT_TAIL(&authctxt->keys, id, next);
		/*
		 * send a test message if we have the public key. for
		 * encrypted keys we cannot do this and have to load the
		 * private key instead
		 */
		if (id->key && id->key->type != KEY_RSA1) {
			debug("Offering public key: %s", id->filename);
			sent = send_pubkey_test(authctxt, id);
		} else if (id->key == NULL) {
			debug("Trying private key: %s", id->filename);
			id->key = load_identity_file(id->filename);
			if (id->key != NULL) {
				id->isprivate = 1;
				sent = sign_and_send_pubkey(authctxt, id);
				key_free(id->key);
				id->key = NULL;
d802 4
d807 1
a807 2
		if (sent)
			return (sent);
d809 1
a809 1
	return (0);
d865 1
a865 1
		logit("%s", name);
d867 1
a867 1
		logit("%s", inst);
@


1.106
log
@minor KNF
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.105 2002/06/23 03:30:17 deraadt Exp $");
d98 1
a98 1
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "zlib";
d101 1
a101 1
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none";
@


1.105
log
@various KNF and %d for unsigned
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.104 2002/06/19 00:27:55 deraadt Exp $");
d425 1
a425 1
	/* try another method if we did not send a packet*/
@


1.104
log
@KNF done automatically while reading....
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.103 2002/05/31 10:30:33 markus Exp $");
d302 1
d309 1
d321 1
d333 1
d382 1
a382 1
	debug("input_userauth_pk_ok: pkalg %s blen %d lastkey %p hint %d",
d901 1
a901 3
ssh_keysign(
    Key *key,
    u_char **sigp, u_int *lenp,
d1103 1
@


1.103
log
@extent ssh-keysign protocol:
pass # of socket-fd to ssh-keysign, keysign verfies locally used
ip-address using this socket-fd, restricts fake local hostnames
to actual local hostnames; ok stevesk@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.102 2002/05/25 08:50:39 markus Exp $");
d398 1
a398 1
			     key->type, pktype);
d466 1
a466 1
	dispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ, 
d498 1
a498 1
	snprintf(prompt, sizeof(prompt), 
d507 1
a507 1
		snprintf(prompt, sizeof(prompt), 
d515 1
a515 1
		snprintf(prompt, sizeof(prompt), 
d533 2
a534 2
	
	dispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ, 
@


1.102
log
@execlp->execl; from stevesk
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.101 2002/05/24 08:45:14 markus Exp $");
d905 1
a905 1
	int to[2], from[2], status, version = 1;
d936 2
d946 1
d958 3
a960 3
        while (waitpid(pid, &status, 0) < 0)
                if (errno != EINTR)
                        break;
@


1.101
log
@stat ssh-keysign first, print error if stat fails;
some debug->error; fix comment
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.100 2002/05/23 19:24:30 markus Exp $");
d936 1
a936 1
		execlp(_PATH_SSH_KEY_SIGN, _PATH_SSH_KEY_SIGN, (char *) 0);
@


1.100
log
@add /usr/libexec/ssh-keysign: a setuid helper program for hostbased authentication
in protocol v2 (needs to access the hostkeys).
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.99 2002/03/26 15:58:46 markus Exp $");
d903 1
d909 4
d948 1
a948 1
		debug("ssh_keysign: no reply");
d952 7
d960 1
a960 1
		debug("ssh_keysign: bad version");
a966 7
	close(from[0]);
	close(to[1]);

        while (waitpid(pid, &status, 0) < 0)
                if (errno != EINTR)
                        break;

a969 4
/*
 * this will be move to an external program (ssh-keysign) ASAP. ssh-keysign
 * will be setuid-root and the sbit can be removed from /usr/bin/ssh.
 */
@


1.99
log
@client side support for PASSWD_CHANGEREQ
based on work by johan.andersson@@appgate.com; ok provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.98 2002/03/19 10:49:35 markus Exp $");
d48 2
d159 1
a159 2
	Key **keys;
	int nkeys;
d219 1
a219 1
    Key **keys, int nkeys)
d259 1
a259 2
	authctxt.keys = keys;
	authctxt.nkeys = nkeys;
d896 69
d973 1
d982 2
a983 2
	for (i = 0; i < authctxt->nkeys; i++) {
		private = authctxt->keys[i];
d987 1
a987 1
			authctxt->keys[i] = NULL;
d1029 6
a1034 1
	ok = key_sign(private, &signature, &slen, buffer_ptr(&b), buffer_len(&b));
@


1.99.2.1
log
@Pull in OpenSSH-3.4
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.105 2002/06/23 03:30:17 deraadt Exp $");
a47 2
#include "msg.h"
#include "pathnames.h"
d157 2
a158 1
	Sensitive *sensitive;
d218 1
a218 1
    Sensitive *sensitive)
d258 2
a259 1
	authctxt.sensitive = sensitive;
a301 1

a307 1

a318 1

a329 1

d378 1
a378 1
	debug("input_userauth_pk_ok: pkalg %s blen %u lastkey %p hint %d",
d398 1
a398 1
			    key->type, pktype);
d466 1
a466 1
	dispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,
d498 1
a498 1
	snprintf(prompt, sizeof(prompt),
d507 1
a507 1
		snprintf(prompt, sizeof(prompt),
d515 1
a515 1
		snprintf(prompt, sizeof(prompt),
d533 2
a534 2

	dispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,
d896 4
a899 75
static int
ssh_keysign(Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
{
	Buffer b;
	struct stat st;
	pid_t pid;
	int to[2], from[2], status, version = 2;

	debug("ssh_keysign called");

	if (stat(_PATH_SSH_KEY_SIGN, &st) < 0) {
		error("ssh_keysign: no installed: %s", strerror(errno));
		return -1;
	}
	if (fflush(stdout) != 0)
		error("ssh_keysign: fflush: %s", strerror(errno));
	if (pipe(to) < 0) {
		error("ssh_keysign: pipe: %s", strerror(errno));
		return -1;
	}
	if (pipe(from) < 0) {
		error("ssh_keysign: pipe: %s", strerror(errno));
		return -1;
	}
	if ((pid = fork()) < 0) {
		error("ssh_keysign: fork: %s", strerror(errno));
		return -1;
	}
	if (pid == 0) {
		seteuid(getuid());
		setuid(getuid());
		close(from[0]);
		if (dup2(from[1], STDOUT_FILENO) < 0)
			fatal("ssh_keysign: dup2: %s", strerror(errno));
		close(to[1]);
		if (dup2(to[0], STDIN_FILENO) < 0)
			fatal("ssh_keysign: dup2: %s", strerror(errno));
		close(from[1]);
		close(to[0]);
		execl(_PATH_SSH_KEY_SIGN, _PATH_SSH_KEY_SIGN, (char *) 0);
		fatal("ssh_keysign: exec(%s): %s", _PATH_SSH_KEY_SIGN,
		    strerror(errno));
	}
	close(from[1]);
	close(to[0]);

	buffer_init(&b);
	buffer_put_int(&b, packet_get_connection_in()); /* send # of socket */
	buffer_put_string(&b, data, datalen);
	msg_send(to[1], version, &b);

	if (msg_recv(from[0], &b) < 0) {
		error("ssh_keysign: no reply");
		buffer_clear(&b);
		return -1;
	}
	close(from[0]);
	close(to[1]);

	while (waitpid(pid, &status, 0) < 0)
		if (errno != EINTR)
			break;

	if (buffer_get_char(&b) != version) {
		error("ssh_keysign: bad version");
		buffer_clear(&b);
		return -1;
	}
	*sigp = buffer_get_string(&b, lenp);
	buffer_clear(&b);

	return 0;
}

a903 1
	Sensitive *sensitive = authctxt->sensitive;
d912 2
a913 2
	for (i = 0; i < sensitive->nkeys; i++) {
		private = sensitive->keys[i];
d917 1
a917 1
			sensitive->keys[i] = NULL;
d959 1
a959 6
	if (sensitive->external_keysign)
		ok = ssh_keysign(private, &signature, &slen,
		    buffer_ptr(&b), buffer_len(&b));
	else
		ok = key_sign(private, &signature, &slen,
		    buffer_ptr(&b), buffer_len(&b));
a1021 1

@


1.99.2.2
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.107 2002/07/01 19:48:46 markus Exp $");
d98 1
a98 1
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "zlib,none";
d101 1
a101 1
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none,zlib";
d425 1
a425 1
	/* try another method if we did not send a packet */
@


1.99.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.114 2003/04/01 10:22:21 markus Exp $");
a112 2
	kex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;
	kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;
d131 1
d227 1
a230 1
	debug("SSH2_MSG_SERVICE_REQUEST sent");
d233 3
a235 2
	if (type != SSH2_MSG_SERVICE_ACCEPT)
		fatal("Server denied authentication request: %d", type);
d238 1
a238 1
		debug2("service_accept: %s", reply);
d241 1
a241 1
		debug2("buggy server: service_accept w/o service");
d244 1
a244 1
	debug("SSH2_MSG_SERVICE_ACCEPT received");
d276 1
a276 1
	debug("Authentication succeeded (%s).", authctxt.method->name);
d350 1
a350 1
	debug("Authentications that can continue: %s", authlist);
d382 1
a382 1
	debug("Server accepts key: pkalg %s blen %u lastkey %p hint %d",
d767 1
a767 1
		debug("Offering agent key: %s", comment);
d795 1
a795 1
			debug("Trying private key: %s", filename);
d803 1
a803 1
			debug("Offering public key: %s", filename);
d909 1
a909 1
	debug2("ssh_keysign called");
d950 1
a950 1
	ssh_msg_send(to[1], version, &b);
d952 1
a952 1
	if (ssh_msg_recv(from[0], &b) < 0) {
d998 1
a998 1
		debug("No more client hostkeys for hostbased authentication.");
a1016 1
	xfree(p);
d1112 1
d1133 1
a1133 1
			debug("No more authentication methods to try.");
d1143 1
a1143 1
			debug("Next authentication method: %s", name);
@


1.98
log
@KNF whitespace
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.97 2002/02/25 16:33:27 markus Exp $");
d175 1
d443 1
a443 1
	char prompt[80];
d465 4
d471 66
d542 2
@


1.97
log
@more u_* fixes
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.96 2002/02/24 19:14:59 markus Exp $");
d394 1
a394 1
		if (key->type != pktype) { 
@


1.96
log
@signed vs. unsigned: make size arguments u_int, ok stevesk@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.95 2002/02/03 17:59:23 markus Exp $");
d570 1
a570 1
	int bloblen, have_sig = 0;
d959 1
a959 1
	int next;
@


1.95
log
@more cross checking if announced vs. used key type; ok stevesk@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.94 2002/01/25 21:00:24 markus Exp $");
d141 1
a141 1
    u_char **sigp, int *lenp, u_char *data, int datalen);
d356 4
a359 2
	int pktype, alen, blen, sent = 0;
	char *pkalg, *pkblob, *fp;
d485 1
a485 1
	int bloblen, slen;
d637 2
a638 2
identity_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
    u_char *data, int datalen)
d660 2
a661 2
agent_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
    u_char *data, int datalen)
d667 2
a668 2
key_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
    u_char *data, int datalen)
@


1.94
log
@unused include
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.93 2002/01/13 17:57:37 markus Exp $");
d356 1
a356 1
	int alen, blen, sent = 0;
d384 1
a384 1
		if (key_type_from_name(pkalg) == KEY_UNSPEC) {
d390 6
@


1.93
log
@use buffer API and avoid static strings of fixed size; ok provos@@/mouring@@
@
text
@d26 1
a26 6
RCSID("$OpenBSD: sshconnect2.c,v 1.92 2001/12/28 15:06:00 markus Exp $");

#include <openssl/bn.h>
#include <openssl/md5.h>
#include <openssl/dh.h>
#include <openssl/hmac.h>
a30 1
#include "rsa.h"
a32 1
#include "uidswap.h"
a37 1
#include "key.h"
@


1.92
log
@remove plen from the dispatch fn. it's no longer used.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.91 2001/12/28 14:50:54 markus Exp $");
a993 3

#define	DELIM	","

d998 2
a999 1
	char buf[1024];
d1001 1
a1001 1
	buf[0] = '\0';
d1004 3
a1006 3
			if (buf[0] != '\0')
				strlcat(buf, DELIM, sizeof buf);
			strlcat(buf, method->name, sizeof buf);
d1009 4
a1012 1
	return xstrdup(buf);
@


1.91
log
@packet_read* no longer return the packet length, since it's not used.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.90 2001/12/28 12:14:27 markus Exp $");
d177 6
a182 6
void	input_userauth_success(int, int, u_int32_t, void *);
void	input_userauth_failure(int, int, u_int32_t, void *);
void	input_userauth_banner(int, int, u_int32_t, void *);
void	input_userauth_error(int, int, u_int32_t, void *);
void	input_userauth_info_req(int, int, u_int32_t, void *);
void	input_userauth_pk_ok(int, int, u_int32_t, void *);
d310 1
a310 1
input_userauth_error(int type, int plen, u_int32_t seq, void *ctxt)
d316 1
a316 1
input_userauth_banner(int type, int plen, u_int32_t seq, void *ctxt)
d327 1
a327 1
input_userauth_success(int type, int plen, u_int32_t seq, void *ctxt)
d338 1
a338 1
input_userauth_failure(int type, int plen, u_int32_t seq, void *ctxt)
d359 1
a359 1
input_userauth_pk_ok(int type, int plen, u_int32_t seq, void *ctxt)
d770 1
a770 1
input_userauth_info_req(int type, int plen, u_int32_t seq, void *ctxt)
@


1.90
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.89 2001/12/20 22:50:24 djm Exp $");
a228 1
	int plen;
d238 1
a238 1
	type = packet_read(&plen);
d243 1
a243 1
		char *reply = packet_get_string(&plen);
@


1.89
log
@Conformance fix: we should send failing packet sequence number when
responding with a SSH_MSG_UNIMPLEMENTED message. Spotted by
yakk@@yakk.dot.net; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.88 2001/12/19 07:18:56 deraadt Exp $");
d250 1
a250 1
	packet_done();
d350 1
a350 1
	packet_done();
d382 1
a382 1
	packet_done();
d818 1
a818 1
	packet_done(); /* done with parsing incoming message. */
@


1.88
log
@basic KNF done while i was looking for something else
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.87 2001/12/05 10:06:13 deraadt Exp $");
d177 6
a182 6
void	input_userauth_success(int, int, void *);
void	input_userauth_failure(int, int, void *);
void	input_userauth_banner(int, int, void *);
void	input_userauth_error(int, int, void *);
void	input_userauth_info_req(int, int, void *);
void	input_userauth_pk_ok(int, int, void *);
d311 1
a311 1
input_userauth_error(int type, int plen, void *ctxt)
d317 1
a317 1
input_userauth_banner(int type, int plen, void *ctxt)
d328 1
a328 1
input_userauth_success(int type, int plen, void *ctxt)
d339 1
a339 1
input_userauth_failure(int type, int plen, void *ctxt)
d360 1
a360 1
input_userauth_pk_ok(int type, int plen, void *ctxt)
d771 1
a771 1
input_userauth_info_req(int type, int plen, void *ctxt)
@


1.87
log
@minor KNF
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.86 2001/12/05 03:56:39 itojun Exp $");
d114 1
a114 1
	        myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =
d616 1
a616 1
		     "Enter passphrase for key '%.100s': ", filename);
d649 1
a649 1
	if (options.identity_keys[idx]->flags & KEY_FLAG_EXT) 
@


1.86
log
@make it compile with more strict prototype checking
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.85 2001/11/07 16:03:17 markus Exp $");
d410 1
a410 1
	} while(0);
d449 1
a449 1
	if(attempt != 1)
d713 1
a713 1
		} while(!sent && authctxt->agent->howmany > 0);
@


1.85
log
@pad using the padding field from the ssh2 packet instead of sending
extra ignore messages. tested against several other ssh servers.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.84 2001/10/29 19:27:15 markus Exp $");
d177 12
a188 12
void	input_userauth_success(int type, int plen, void *ctxt);
void	input_userauth_failure(int type, int plen, void *ctxt);
void	input_userauth_banner(int type, int plen, void *ctxt);
void	input_userauth_error(int type, int plen, void *ctxt);
void	input_userauth_info_req(int type, int plen, void *ctxt);
void	input_userauth_pk_ok(int type, int plen, void *ctxt);

int	userauth_none(Authctxt *authctxt);
int	userauth_pubkey(Authctxt *authctxt);
int	userauth_passwd(Authctxt *authctxt);
int	userauth_kbdint(Authctxt *authctxt);
int	userauth_hostbased(Authctxt *authctxt);
d190 1
a190 1
void	userauth(Authctxt *authctxt, char *authlist);
@


1.84
log
@hostbased: check for client hostkey before building chost
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.83 2001/10/06 11:18:19 markus Exp $");
d463 1
a463 1
	packet_inject_ignore(64);
d820 1
a820 1
	packet_inject_ignore(64);
@


1.83
log
@unify hostkey check error messages, simplify prompt.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.82 2001/08/31 11:46:39 markus Exp $");
a838 10
	p = get_local_name(packet_get_connection_in());
	if (p == NULL) {
		error("userauth_hostbased: cannot get local ipaddr/name");
		return 0;
	}
	len = strlen(p) + 2;
	chost = xmalloc(len);
	strlcpy(chost, p, len);
	strlcat(chost, ".", len);
	debug2("userauth_hostbased: chost %s", chost);
d850 1
a850 1
		xfree(chost);
a854 1
		xfree(chost);
d857 13
a886 1
	debug2("xxx: chost %s", chost);
@


1.83.2.1
log
@Pull in patches from current (Errata 002):
Update to OpenSSH-3.0.1 via errata patch (Instead of using release tarball)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.85 2001/11/07 16:03:17 markus Exp $");
d463 1
a463 1
	packet_add_padding(64);
d820 1
a820 1
	packet_add_padding(64);
d839 10
d860 1
a860 1
		debug("userauth_hostbased: no more client hostkeys");
d865 1
a867 13
	/* figure out a name for the client host */
	p = get_local_name(packet_get_connection_in());
	if (p == NULL) {
		error("userauth_hostbased: cannot get local ipaddr/name");
		key_free(private);
		return 0;
	}
	len = strlen(p) + 2;
	chost = xmalloc(len);
	strlcpy(chost, p, len);
	strlcat(chost, ".", len);
	debug2("userauth_hostbased: chost %s", chost);

d885 1
@


1.83.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d26 6
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.97 2002/02/25 16:33:27 markus Exp $");
d36 1
d39 1
d45 1
d114 1
a114 1
		myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =
d149 1
a149 1
    u_char **sigp, u_int *lenp, u_char *data, u_int datalen);
d177 12
a188 12
void	input_userauth_success(int, u_int32_t, void *);
void	input_userauth_failure(int, u_int32_t, void *);
void	input_userauth_banner(int, u_int32_t, void *);
void	input_userauth_error(int, u_int32_t, void *);
void	input_userauth_info_req(int, u_int32_t, void *);
void	input_userauth_pk_ok(int, u_int32_t, void *);

int	userauth_none(Authctxt *);
int	userauth_pubkey(Authctxt *);
int	userauth_passwd(Authctxt *);
int	userauth_kbdint(Authctxt *);
int	userauth_hostbased(Authctxt *);
d190 1
a190 1
void	userauth(Authctxt *, char *);
d229 1
d239 1
a239 1
	type = packet_read();
d244 1
a244 1
		char *reply = packet_get_string(NULL);
d250 1
a250 1
	packet_check_eom();
d311 1
a311 1
input_userauth_error(int type, u_int32_t seq, void *ctxt)
d317 1
a317 1
input_userauth_banner(int type, u_int32_t seq, void *ctxt)
d328 1
a328 1
input_userauth_success(int type, u_int32_t seq, void *ctxt)
d339 1
a339 1
input_userauth_failure(int type, u_int32_t seq, void *ctxt)
d350 1
a350 1
	packet_check_eom();
d360 1
a360 1
input_userauth_pk_ok(int type, u_int32_t seq, void *ctxt)
d365 2
a366 4
	int pktype, sent = 0;
	u_int alen, blen;
	char *pkalg, *fp;
	u_char *pkblob;
d382 1
a382 1
	packet_check_eom();
d393 1
a393 1
		if ((pktype = key_type_from_name(pkalg)) == KEY_UNSPEC) {
a400 6
		if (key->type != pktype) { 
			error("input_userauth_pk_ok: type mismatch "
			    "for decoded key (received %d, expected %d)",
			     key->type, pktype);
			break;
		}
d410 1
a410 1
	} while (0);
d449 1
a449 1
	if (attempt != 1)
d486 1
a486 1
	u_int bloblen, slen;
d571 1
a571 1
	u_int bloblen, have_sig = 0;
d616 1
a616 1
		    "Enter passphrase for key '%.100s': ", filename);
d638 2
a639 2
identity_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d649 1
a649 1
	if (options.identity_keys[idx]->flags & KEY_FLAG_EXT)
d661 2
a662 2
agent_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d668 2
a669 2
key_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d713 1
a713 1
		} while (!sent && authctxt->agent->howmany > 0);
d771 1
a771 1
input_userauth_info_req(int type, u_int32_t seq, void *ctxt)
d818 1
a818 1
	packet_check_eom(); /* done with parsing incoming message. */
d960 1
a960 1
	u_int next;
d995 3
d1002 1
a1002 2
	Buffer b;
	char *list;
d1004 1
a1004 1
	buffer_init(&b);
d1007 3
a1009 3
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			buffer_append(&b, method->name, strlen(method->name));
d1012 1
a1012 4
	buffer_append(&b, "\0", 1);
	list = xstrdup(buffer_ptr(&b));
	buffer_free(&b);
	return list;
@


1.83.2.3
log
@Update OpenSSH to version 3.2.2.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.99 2002/03/26 15:58:46 markus Exp $");
a174 1
void	input_userauth_passwd_changereq(int, u_int32_t, void *);
d394 1
a394 1
		if (key->type != pktype) {
d442 1
a442 1
	char prompt[150];
a463 4

	dispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ, 
	    &input_userauth_passwd_changereq);

a465 66
/*
 * parse PASSWD_CHANGEREQ, prompt user and send SSH2_MSG_USERAUTH_REQUEST
 */
void
input_userauth_passwd_changereq(int type, uint32_t seqnr, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	char *info, *lang, *password = NULL, *retype = NULL;
	char prompt[150];

	debug2("input_userauth_passwd_changereq");

	if (authctxt == NULL)
		fatal("input_userauth_passwd_changereq: "
		    "no authentication context");

	info = packet_get_string(NULL);
	lang = packet_get_string(NULL);
	if (strlen(info) > 0)
		log("%s", info);
	xfree(info);
	xfree(lang);
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
	packet_put_char(1);			/* additional info */
	snprintf(prompt, sizeof(prompt), 
	    "Enter %.30s@@%.128s's old password: ",
	    authctxt->server_user, authctxt->host);
	password = read_passphrase(prompt, 0);
	packet_put_cstring(password);
	memset(password, 0, strlen(password));
	xfree(password);
	password = NULL;
	while (password == NULL) {
		snprintf(prompt, sizeof(prompt), 
		    "Enter %.30s@@%.128s's new password: ",
		    authctxt->server_user, authctxt->host);
		password = read_passphrase(prompt, RP_ALLOW_EOF);
		if (password == NULL) {
			/* bail out */
			return;
		}
		snprintf(prompt, sizeof(prompt), 
		    "Retype %.30s@@%.128s's new password: ",
		    authctxt->server_user, authctxt->host);
		retype = read_passphrase(prompt, 0);
		if (strcmp(password, retype) != 0) {
			memset(password, 0, strlen(password));
			xfree(password);
			log("Mismatch; try again, EOF to quit.");
			password = NULL;
		}
		memset(retype, 0, strlen(retype));
		xfree(retype);
	}
	packet_put_cstring(password);
	memset(password, 0, strlen(password));
	xfree(password);
	packet_add_padding(64);
	packet_send();
	
	dispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ, 
	    &input_userauth_passwd_changereq);
}
a470 2
	dispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ, NULL);

@


1.83.2.4
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.83.2.3 2002/05/17 00:03:24 miod Exp $");
a47 2
#include "msg.h"
#include "pathnames.h"
d157 2
a158 1
	Sensitive *sensitive;
d218 1
a218 1
    Sensitive *sensitive)
d258 2
a259 1
	authctxt.sensitive = sensitive;
d398 1
a398 1
			    key->type, pktype);
d466 1
a466 1
	dispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,
d498 1
a498 1
	snprintf(prompt, sizeof(prompt),
d507 1
a507 1
		snprintf(prompt, sizeof(prompt),
d515 1
a515 1
		snprintf(prompt, sizeof(prompt),
d533 2
a534 2

	dispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,
d896 4
a899 77
static int
ssh_keysign(
    Key *key,
    u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
{
	Buffer b;
	struct stat st;
	pid_t pid;
	int to[2], from[2], status, version = 2;

	debug("ssh_keysign called");

	if (stat(_PATH_SSH_KEY_SIGN, &st) < 0) {
		error("ssh_keysign: no installed: %s", strerror(errno));
		return -1;
	}
	if (fflush(stdout) != 0)
		error("ssh_keysign: fflush: %s", strerror(errno));
	if (pipe(to) < 0) {
		error("ssh_keysign: pipe: %s", strerror(errno));
		return -1;
	}
	if (pipe(from) < 0) {
		error("ssh_keysign: pipe: %s", strerror(errno));
		return -1;
	}
	if ((pid = fork()) < 0) {
		error("ssh_keysign: fork: %s", strerror(errno));
		return -1;
	}
	if (pid == 0) {
		seteuid(getuid());
		setuid(getuid());
		close(from[0]);
		if (dup2(from[1], STDOUT_FILENO) < 0)
			fatal("ssh_keysign: dup2: %s", strerror(errno));
		close(to[1]);
		if (dup2(to[0], STDIN_FILENO) < 0)
			fatal("ssh_keysign: dup2: %s", strerror(errno));
		close(from[1]);
		close(to[0]);
		execl(_PATH_SSH_KEY_SIGN, _PATH_SSH_KEY_SIGN, (char *) 0);
		fatal("ssh_keysign: exec(%s): %s", _PATH_SSH_KEY_SIGN,
		    strerror(errno));
	}
	close(from[1]);
	close(to[0]);

	buffer_init(&b);
	buffer_put_int(&b, packet_get_connection_in()); /* send # of socket */
	buffer_put_string(&b, data, datalen);
	msg_send(to[1], version, &b);

	if (msg_recv(from[0], &b) < 0) {
		error("ssh_keysign: no reply");
		buffer_clear(&b);
		return -1;
	}
	close(from[0]);
	close(to[1]);

	while (waitpid(pid, &status, 0) < 0)
		if (errno != EINTR)
			break;

	if (buffer_get_char(&b) != version) {
		error("ssh_keysign: bad version");
		buffer_clear(&b);
		return -1;
	}
	*sigp = buffer_get_string(&b, lenp);
	buffer_clear(&b);

	return 0;
}

a903 1
	Sensitive *sensitive = authctxt->sensitive;
d912 2
a913 2
	for (i = 0; i < sensitive->nkeys; i++) {
		private = sensitive->keys[i];
d917 1
a917 1
			sensitive->keys[i] = NULL;
d959 1
a959 6
	if (sensitive->external_keysign)
		ok = ssh_keysign(private, &signature, &slen,
		    buffer_ptr(&b), buffer_len(&b));
	else
		ok = key_sign(private, &signature, &slen,
		    buffer_ptr(&b), buffer_len(&b));
@


1.83.2.5
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.83.2.4 2002/06/22 07:23:18 miod Exp $");
a301 1

a307 1

a318 1

a329 1

d378 1
a378 1
	debug("input_userauth_pk_ok: pkalg %s blen %u lastkey %p hint %d",
d897 3
a899 1
ssh_keysign(Key *key, u_char **sigp, u_int *lenp,
a1100 1

@


1.83.2.6
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.107 2002/07/01 19:48:46 markus Exp $");
d98 1
a98 1
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "zlib,none";
d101 1
a101 1
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none,zlib";
d425 1
a425 1
	/* try another method if we did not send a packet */
@


1.82
log
@disable kbd-interactive if we don't get SSH2_MSG_USERAUTH_INFO_REQUEST messages
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.81 2001/07/23 09:06:28 markus Exp $");
d78 1
a78 1
		fatal("verify_host_key failed");
@


1.81
log
@reorder default sequence of userauth methods to match ssh behaviour:
hostbased,publickey,keyboard-interactive,password
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.80 2001/06/26 20:14:11 markus Exp $");
d167 2
d257 1
d268 1
d746 6
d782 2
@


1.80
log
@add smartcard support to the client, too (now you can use both
the agent and the client).
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.79 2001/06/25 20:26:37 stevesk Exp $");
d198 4
d206 4
a209 4
	{"hostbased",
		userauth_hostbased,
		&options.hostbased_authentication,
		NULL},
a212 4
		&options.batch_mode},
	{"keyboard-interactive",
		userauth_kbdint,
		&options.kbd_interactive_authentication,
@


1.79
log
@prototype cleanup; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.78 2001/06/24 05:47:13 markus Exp $");
d643 5
@


1.78
log
@oops, missing format string
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.77 2001/06/24 05:35:34 markus Exp $");
d464 1
a464 1
void
d979 2
a980 1
char *
@


1.77
log
@switch to readpassphrase(3)
2.7/8-stable needs readpassphrase.[ch] from libc
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.76 2001/06/23 15:12:21 itojun Exp $");
d772 1
a772 1
		log(name);
d774 1
a774 1
		log(inst);
@


1.76
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.75 2001/06/23 02:34:33 markus Exp $");
a47 1
#include "cli.h"
d772 1
a772 1
		cli_mesg(name);
d774 1
a774 1
		cli_mesg(inst);
d794 1
a794 1
		response = cli_prompt(prompt, echo);
@


1.75
log
@get rid of known_hosts2, use it for hostkey lookup, but do not modify.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.74 2001/05/19 16:32:16 markus Exp $");
d75 1
a75 1
int
d191 6
a196 8
int
sign_and_send_pubkey(Authctxt *authctxt, Key *k,
    sign_cb_fn *sign_callback);
void	clear_auth_state(Authctxt *authctxt);

Authmethod *authmethod_get(char *authlist);
Authmethod *authmethod_lookup(const char *name);
char *authmethods_get(void);
d478 1
a478 1
int
d563 1
a563 1
int
d596 1
a596 1
Key *
d634 1
a634 1
int
d652 2
a653 1
int agent_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
d659 2
a660 1
int key_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
d666 1
a666 1
int
d903 1
a903 1
int
d917 1
a917 1
Authmethod *
d938 1
a938 1
Authmethod *
@


1.74
log
@change preferredauthentication order to
	publickey,hostbased,password,keyboard-interactive
document that hostbased defaults to no, document order
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.73 2001/05/18 14:13:29 markus Exp $");
d76 1
a76 1
check_host_key_callback(Key *hostkey)
d78 2
a79 2
	check_host_key(xxx_host, xxx_hostaddr, hostkey,
	    options.user_hostfile2, options.system_hostfile2);
d122 1
a122 1
	kex->check_host_key=&check_host_key_callback;
@


1.73
log
@improved kbd-interactive support. work by per@@appgate.com and me
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.72 2001/04/18 23:43:26 markus Exp $");
d205 4
a216 4
	{"hostbased",
		userauth_hostbased,
		&options.hostbased_authentication,
		NULL},
@


1.72
log
@more ssh v2 hostbased-auth interop: ssh.com >= 2.1.0 works now
(however the 2.1.0 server seems to work only if debug is enabled...)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.71 2001/04/18 22:03:45 markus Exp $");
d232 1
a232 1
	if (options.challenge_reponse_authentication)
d790 1
@


1.72.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.82 2001/08/31 11:46:39 markus Exp $");
d48 1
d75 2
a76 2
static int
verify_host_key_callback(Key *hostkey)
d78 2
a79 2
	if (verify_host_key(xxx_host, xxx_hostaddr, hostkey) == -1)
		fatal("verify_host_key failed");
d122 1
a122 1
	kex->verify_host_key=&verify_host_key_callback;
a167 2
	/* kbd-interactive */
	int info_req_seen;
d191 8
a198 6
static int sign_and_send_pubkey(Authctxt *, Key *, sign_cb_fn *);
static void clear_auth_state(Authctxt *);

static Authmethod *authmethod_get(char *authlist);
static Authmethod *authmethod_lookup(const char *name);
static char *authmethods_get(void);
a200 4
	{"hostbased",
		userauth_hostbased,
		&options.hostbased_authentication,
		NULL},
d205 4
d213 4
a216 4
	{"password",
		userauth_passwd,
		&options.password_authentication,
		&options.batch_mode},
d232 1
a232 1
	if (options.challenge_response_authentication)
a257 1
	memset(&authctxt, 0, sizeof(authctxt));
a267 1
	authctxt.info_req_seen = 0;
d467 1
a467 1
static void
d480 1
a480 1
static int
d565 1
a565 1
static int
d598 1
a598 1
static Key *
d636 1
a636 1
static int
a645 5

	/* private key is stored in external hardware */
	if (options.identity_keys[idx]->flags & KEY_FLAG_EXT) 
		return key_sign(options.identity_keys[idx], sigp, lenp, data, datalen);

d654 1
a654 2
static int
agent_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
d660 1
a660 2
static int
key_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
d666 1
a666 1
static int
a737 6
	/* disable if no SSH2_MSG_USERAUTH_INFO_REQUEST has been seen */
	if (attempt > 1 && !authctxt->info_req_seen) {
		debug3("userauth_kbdint: disable: no info_req_seen");
		dispatch_set(SSH2_MSG_USERAUTH_INFO_REQUEST, NULL);
		return 0;
	}
a768 2
	authctxt->info_req_seen = 1;

d773 1
a773 1
		log("%s", name);
d775 1
a775 1
		log("%s", inst);
a789 1
	debug2("input_userauth_info_req: num_prompts %d", num_prompts);
d794 1
a794 1
		response = read_passphrase(prompt, echo ? RP_ECHO : 0);
d902 1
a902 1
static int
d916 1
a916 1
static Authmethod *
d937 1
a937 1
static Authmethod *
d979 1
a979 2

static char *
@


1.72.2.2
log
@Merge OpenSSH 3.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.72.2.1 2001/09/27 19:03:55 jason Exp $");
d78 1
a78 1
		fatal("Host key verification failed.");
@


1.72.2.3
log
@Merge OpenSSH 3.0.1.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.72.2.2 2001/11/15 00:15:19 miod Exp $");
d463 1
a463 1
	packet_add_padding(64);
d820 1
a820 1
	packet_add_padding(64);
d839 10
d860 1
a860 1
		debug("userauth_hostbased: no more client hostkeys");
d865 1
a867 13
	/* figure out a name for the client host */
	p = get_local_name(packet_get_connection_in());
	if (p == NULL) {
		error("userauth_hostbased: cannot get local ipaddr/name");
		key_free(private);
		return 0;
	}
	len = strlen(p) + 2;
	chost = xmalloc(len);
	strlcpy(chost, p, len);
	strlcat(chost, ".", len);
	debug2("userauth_hostbased: chost %s", chost);

d885 1
@


1.72.2.4
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d26 6
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.97 2002/02/25 16:33:27 markus Exp $");
d36 1
d39 1
d45 1
d114 1
a114 1
		myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =
d149 1
a149 1
    u_char **sigp, u_int *lenp, u_char *data, u_int datalen);
d177 12
a188 12
void	input_userauth_success(int, u_int32_t, void *);
void	input_userauth_failure(int, u_int32_t, void *);
void	input_userauth_banner(int, u_int32_t, void *);
void	input_userauth_error(int, u_int32_t, void *);
void	input_userauth_info_req(int, u_int32_t, void *);
void	input_userauth_pk_ok(int, u_int32_t, void *);

int	userauth_none(Authctxt *);
int	userauth_pubkey(Authctxt *);
int	userauth_passwd(Authctxt *);
int	userauth_kbdint(Authctxt *);
int	userauth_hostbased(Authctxt *);
d190 1
a190 1
void	userauth(Authctxt *, char *);
d229 1
d239 1
a239 1
	type = packet_read();
d244 1
a244 1
		char *reply = packet_get_string(NULL);
d250 1
a250 1
	packet_check_eom();
d311 1
a311 1
input_userauth_error(int type, u_int32_t seq, void *ctxt)
d317 1
a317 1
input_userauth_banner(int type, u_int32_t seq, void *ctxt)
d328 1
a328 1
input_userauth_success(int type, u_int32_t seq, void *ctxt)
d339 1
a339 1
input_userauth_failure(int type, u_int32_t seq, void *ctxt)
d350 1
a350 1
	packet_check_eom();
d360 1
a360 1
input_userauth_pk_ok(int type, u_int32_t seq, void *ctxt)
d365 2
a366 4
	int pktype, sent = 0;
	u_int alen, blen;
	char *pkalg, *fp;
	u_char *pkblob;
d382 1
a382 1
	packet_check_eom();
d393 1
a393 1
		if ((pktype = key_type_from_name(pkalg)) == KEY_UNSPEC) {
a400 6
		if (key->type != pktype) { 
			error("input_userauth_pk_ok: type mismatch "
			    "for decoded key (received %d, expected %d)",
			     key->type, pktype);
			break;
		}
d410 1
a410 1
	} while (0);
d449 1
a449 1
	if (attempt != 1)
d486 1
a486 1
	u_int bloblen, slen;
d571 1
a571 1
	u_int bloblen, have_sig = 0;
d616 1
a616 1
		    "Enter passphrase for key '%.100s': ", filename);
d638 2
a639 2
identity_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d649 1
a649 1
	if (options.identity_keys[idx]->flags & KEY_FLAG_EXT)
d661 2
a662 2
agent_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d668 2
a669 2
key_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d713 1
a713 1
		} while (!sent && authctxt->agent->howmany > 0);
d771 1
a771 1
input_userauth_info_req(int type, u_int32_t seq, void *ctxt)
d818 1
a818 1
	packet_check_eom(); /* done with parsing incoming message. */
d960 1
a960 1
	u_int next;
d995 3
d1002 1
a1002 2
	Buffer b;
	char *list;
d1004 1
a1004 1
	buffer_init(&b);
d1007 3
a1009 3
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			buffer_append(&b, method->name, strlen(method->name));
d1012 1
a1012 4
	buffer_append(&b, "\0", 1);
	list = xstrdup(buffer_ptr(&b));
	buffer_free(&b);
	return list;
@


1.72.2.5
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.99 2002/03/26 15:58:46 markus Exp $");
a174 1
void	input_userauth_passwd_changereq(int, u_int32_t, void *);
d394 1
a394 1
		if (key->type != pktype) {
d442 1
a442 1
	char prompt[150];
a463 4

	dispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ, 
	    &input_userauth_passwd_changereq);

a465 66
/*
 * parse PASSWD_CHANGEREQ, prompt user and send SSH2_MSG_USERAUTH_REQUEST
 */
void
input_userauth_passwd_changereq(int type, uint32_t seqnr, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	char *info, *lang, *password = NULL, *retype = NULL;
	char prompt[150];

	debug2("input_userauth_passwd_changereq");

	if (authctxt == NULL)
		fatal("input_userauth_passwd_changereq: "
		    "no authentication context");

	info = packet_get_string(NULL);
	lang = packet_get_string(NULL);
	if (strlen(info) > 0)
		log("%s", info);
	xfree(info);
	xfree(lang);
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
	packet_put_char(1);			/* additional info */
	snprintf(prompt, sizeof(prompt), 
	    "Enter %.30s@@%.128s's old password: ",
	    authctxt->server_user, authctxt->host);
	password = read_passphrase(prompt, 0);
	packet_put_cstring(password);
	memset(password, 0, strlen(password));
	xfree(password);
	password = NULL;
	while (password == NULL) {
		snprintf(prompt, sizeof(prompt), 
		    "Enter %.30s@@%.128s's new password: ",
		    authctxt->server_user, authctxt->host);
		password = read_passphrase(prompt, RP_ALLOW_EOF);
		if (password == NULL) {
			/* bail out */
			return;
		}
		snprintf(prompt, sizeof(prompt), 
		    "Retype %.30s@@%.128s's new password: ",
		    authctxt->server_user, authctxt->host);
		retype = read_passphrase(prompt, 0);
		if (strcmp(password, retype) != 0) {
			memset(password, 0, strlen(password));
			xfree(password);
			log("Mismatch; try again, EOF to quit.");
			password = NULL;
		}
		memset(retype, 0, strlen(retype));
		xfree(retype);
	}
	packet_put_cstring(password);
	memset(password, 0, strlen(password));
	xfree(password);
	packet_add_padding(64);
	packet_send();
	
	dispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ, 
	    &input_userauth_passwd_changereq);
}
a470 2
	dispatch_set(SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ, NULL);

@


1.71
log
@use FDQN with trailing dot in the hostbased auth packets, ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.70 2001/04/17 10:53:26 markus Exp $");
d818 1
d851 2
a854 5
	if (datafellows & SSH_OLD_SESSIONID) {
		buffer_append(&b, session_id2, session_id2_len);
	} else {
		buffer_put_string(&b, session_id2, session_id2_len);
	}
d856 1
d859 1
a859 4
	buffer_put_cstring(&b,
	    datafellows & SSH_BUG_HBSERVICE ?
	    "ssh-userauth" :
	    authctxt->service);
@


1.70
log
@add HostKeyAlgorithms; based on patch from res@@shore.net; ok provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.69 2001/04/15 08:43:47 markus Exp $");
d819 1
a819 1
	int ok, i, found = 0;
d826 4
a829 1
	chost = xstrdup(p);
@


1.69
log
@some unused variable and typos; from tomh@@po.crl.go.jp
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.68 2001/04/12 19:15:25 markus Exp $");
d114 3
@


1.68
log
@implement HostbasedAuthentication (= RhostRSAAuthentication for ssh v2)
similar to RhostRSAAuthentication unless you enable (the experimental)
HostbasedUsesNameFromPacketOnly option.  please test. :)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.67 2001/04/05 10:42:56 markus Exp $");
d361 1
a361 1
	int alen, blen, pktype, sent = 0;
d389 1
a389 1
		if ((pktype = key_type_from_name(pkalg)) == KEY_UNSPEC) {
@


1.67
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.66 2001/04/04 20:25:38 markus Exp $");
d56 1
d151 1
a153 1
	AuthenticationConnection *agent;
d157 1
d161 4
d184 1
d210 4
d222 2
a223 1
ssh_userauth2(const char *server_user, char *host)
d257 1
d263 2
d802 90
@


1.66
log
@more robust rekeying
don't send channel data after rekeying is started.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.65 2001/04/04 14:34:58 markus Exp $");
d645 1
a645 1
        return key_sign(key, sigp, lenp, data, datalen);
d828 1
a828 1
 * use a built-in default list. 
@


1.65
log
@enable server side rekeying + some rekey related clientup.
todo: we should not send any non-KEX messages after we send KEXINIT
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.64 2001/04/04 09:48:35 markus Exp $");
d122 1
a122 1
	dispatch_run(DISPATCH_BLOCK, &kex->newkeys, kex);
@


1.64
log
@don't sent multiple kexinit-requests.
send newkeys, block while waiting for newkeys.
fix comments.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.63 2001/04/04 00:06:54 markus Exp $");
d114 1
a121 1
	/* start key exchange */
a215 1
	int i;
d256 1
a256 4
	/* dispatch_init(&input_userauth_error); */
        for (i = 50; i <= 254; i++) {
                dispatch_set(i, &input_userauth_error);
        }
@


1.63
log
@enable client rekeying
	(1) force rekeying with ~R, or
	(2) if the server requests rekeying.
works against ssh-2.0.12/2.0.13/2.1.0/2.2.0/2.3.0/2.3.1/2.4.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.62 2001/04/03 23:32:12 markus Exp $");
d114 1
a114 1
	kex = kex_start(myproposal);
d257 1
a257 1
	//dispatch_init(&input_userauth_error);
@


1.62
log
@undo parts of recent my changes: main part of keyexchange does not
need dispatch-callbacks, since application data is delayed until
the keyexchange completes (if i understand the drafts correctly).

add some infrastructure for re-keying.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.61 2001/04/03 19:53:29 markus Exp $");
d72 2
d118 2
@


1.61
log
@move kex to kex*.c, used dispatch_set() callbacks for kex. should
make rekeying easier.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.60 2001/03/29 21:06:21 stevesk Exp $");
d119 3
@


1.60
log
@need to set both STOC and CTOS for SSH_BUG_BIGENDIANAES; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.59 2001/03/29 14:24:59 provos Exp $");
a49 1
#include "dispatch.h"
d55 1
a55 3

void ssh_dh1_client(Kex *, char *, struct sockaddr *, Buffer *, Buffer *);
void ssh_dhgex_client(Kex *, char *, struct sockaddr *, Buffer *, Buffer *);
d69 11
a82 1
	int i, plen;
d84 3
a86 2
	Buffer *client_kexinit, *server_kexinit;
	char *sprop[PROPOSAL_MAX];
d112 4
a115 29
	/* buffers with raw kexinit messages */
	server_kexinit = xmalloc(sizeof(*server_kexinit));
	buffer_init(server_kexinit);
	client_kexinit = kex_init(myproposal);

	/* algorithm negotiation */
	kex_exchange_kexinit(client_kexinit, server_kexinit, sprop);
	kex = kex_choose_conf(myproposal, sprop, 0);
	for (i = 0; i < PROPOSAL_MAX; i++)
		xfree(sprop[i]);

	/* server authentication and session key agreement */
	switch(kex->kex_type) {
	case DH_GRP1_SHA1:
		ssh_dh1_client(kex, host, hostaddr,
			       client_kexinit, server_kexinit);
		break;
	case DH_GEX_SHA1:
		ssh_dhgex_client(kex, host, hostaddr, client_kexinit,
				 server_kexinit);
		break;
	default:
		fatal("Unsupported key exchange %d", kex->kex_type);
	}

	buffer_free(client_kexinit);
	buffer_free(server_kexinit);
	xfree(client_kexinit);
	xfree(server_kexinit);
d117 2
a118 10
	debug("Wait SSH2_MSG_NEWKEYS.");
	packet_read_expect(&plen, SSH2_MSG_NEWKEYS);
	packet_done();
	debug("GOT SSH2_MSG_NEWKEYS.");

	debug("send SSH2_MSG_NEWKEYS.");
	packet_start(SSH2_MSG_NEWKEYS);
	packet_send();
	packet_write_wait();
	debug("done: send SSH2_MSG_NEWKEYS.");
d127 1
a127 333
	debug("done: KEX2.");
}

/* diffie-hellman-group1-sha1 */

void
ssh_dh1_client(Kex *kex, char *host, struct sockaddr *hostaddr,
	       Buffer *client_kexinit, Buffer *server_kexinit)
{
#ifdef DEBUG_KEXDH
	int i;
#endif
	int plen, dlen;
	u_int klen, kout;
	char *signature = NULL;
	u_int slen;
	char *server_host_key_blob = NULL;
	Key *server_host_key;
	u_int sbloblen;
	DH *dh;
	BIGNUM *dh_server_pub = 0;
	BIGNUM *shared_secret = 0;
	u_char *kbuf;
	u_char *hash;

	debug("Sending SSH2_MSG_KEXDH_INIT.");
	/* generate and send 'e', client DH public key */
	dh = dh_new_group1();
	dh_gen_key(dh, kex->we_need * 8);
	packet_start(SSH2_MSG_KEXDH_INIT);
	packet_put_bignum2(dh->pub_key);
	packet_send();
	packet_write_wait();

#ifdef DEBUG_KEXDH
	fprintf(stderr, "\np= ");
	BN_print_fp(stderr, dh->p);
	fprintf(stderr, "\ng= ");
	BN_print_fp(stderr, dh->g);
	fprintf(stderr, "\npub= ");
	BN_print_fp(stderr, dh->pub_key);
	fprintf(stderr, "\n");
	DHparams_print_fp(stderr, dh);
#endif

	debug("Wait SSH2_MSG_KEXDH_REPLY.");

	packet_read_expect(&plen, SSH2_MSG_KEXDH_REPLY);

	debug("Got SSH2_MSG_KEXDH_REPLY.");

	/* key, cert */
	server_host_key_blob = packet_get_string(&sbloblen);
	server_host_key = key_from_blob(server_host_key_blob, sbloblen);
	if (server_host_key == NULL)
		fatal("cannot decode server_host_key_blob");

	check_host_key(host, hostaddr, server_host_key,
		       options.user_hostfile2, options.system_hostfile2);

	/* DH paramter f, server public DH key */
	dh_server_pub = BN_new();
	if (dh_server_pub == NULL)
		fatal("dh_server_pub == NULL");
	packet_get_bignum2(dh_server_pub, &dlen);

#ifdef DEBUG_KEXDH
	fprintf(stderr, "\ndh_server_pub= ");
	BN_print_fp(stderr, dh_server_pub);
	fprintf(stderr, "\n");
	debug("bits %d", BN_num_bits(dh_server_pub));
#endif

	/* signed H */
	signature = packet_get_string(&slen);
	packet_done();

	if (!dh_pub_is_valid(dh, dh_server_pub))
		packet_disconnect("bad server public DH value");

	klen = DH_size(dh);
	kbuf = xmalloc(klen);
	kout = DH_compute_key(kbuf, dh_server_pub, dh);
#ifdef DEBUG_KEXDH
	debug("shared secret: len %d/%d", klen, kout);
	fprintf(stderr, "shared secret == ");
	for (i = 0; i< kout; i++)
		fprintf(stderr, "%02x", (kbuf[i])&0xff);
	fprintf(stderr, "\n");
#endif
	shared_secret = BN_new();

	BN_bin2bn(kbuf, kout, shared_secret);
	memset(kbuf, 0, klen);
	xfree(kbuf);

	/* calc and verify H */
	hash = kex_hash(
	    client_version_string,
	    server_version_string,
	    buffer_ptr(client_kexinit), buffer_len(client_kexinit),
	    buffer_ptr(server_kexinit), buffer_len(server_kexinit),
	    server_host_key_blob, sbloblen,
	    dh->pub_key,
	    dh_server_pub,
	    shared_secret
	);
	xfree(server_host_key_blob);
	DH_free(dh);
	BN_free(dh_server_pub);
#ifdef DEBUG_KEXDH
	fprintf(stderr, "hash == ");
	for (i = 0; i< 20; i++)
		fprintf(stderr, "%02x", (hash[i])&0xff);
	fprintf(stderr, "\n");
#endif
	if (key_verify(server_host_key, (u_char *)signature, slen, hash, 20) != 1)
		fatal("key_verify failed for server_host_key");
	key_free(server_host_key);
	xfree(signature);

	kex_derive_keys(kex, hash, shared_secret);
	BN_clear_free(shared_secret);
	packet_set_kex(kex);

	/* save session id */
	session_id2_len = 20;
	session_id2 = xmalloc(session_id2_len);
	memcpy(session_id2, hash, session_id2_len);
}

/* diffie-hellman-group-exchange-sha1 */

/*
 * Estimates the group order for a Diffie-Hellman group that has an
 * attack complexity approximately the same as O(2**bits).  Estimate
 * with:  O(exp(1.9223 * (ln q)^(1/3) (ln ln q)^(2/3)))
 */

int
dh_estimate(int bits)
{

	if (bits < 64)
		return (512);	/* O(2**63) */
	if (bits < 128)
		return (1024);	/* O(2**86) */
	if (bits < 192)
		return (2048);	/* O(2**116) */
	return (4096);		/* O(2**156) */
}

void
ssh_dhgex_client(Kex *kex, char *host, struct sockaddr *hostaddr,
		 Buffer *client_kexinit, Buffer *server_kexinit)
{
#ifdef DEBUG_KEXDH
	int i;
#endif
	int plen, dlen;
	u_int klen, kout;
	char *signature = NULL;
	u_int slen, nbits, min, max;
	char *server_host_key_blob = NULL;
	Key *server_host_key;
	u_int sbloblen;
	DH *dh;
	BIGNUM *dh_server_pub = 0;
	BIGNUM *shared_secret = 0;
	BIGNUM *p = 0, *g = 0;
	u_char *kbuf;
	u_char *hash;

	nbits = dh_estimate(kex->we_need * 8);

	if (datafellows & SSH_OLD_DHGEX) {
		debug("Sending SSH2_MSG_KEX_DH_GEX_REQUEST_OLD.");

		/* Old GEX request */
		packet_start(SSH2_MSG_KEX_DH_GEX_REQUEST_OLD);
		packet_put_int(nbits);
		min = DH_GRP_MIN;
		max = DH_GRP_MAX;
	} else {
		debug("Sending SSH2_MSG_KEX_DH_GEX_REQUEST.");

		/* New GEX request */
		min = DH_GRP_MIN;
		max = DH_GRP_MAX;

		packet_start(SSH2_MSG_KEX_DH_GEX_REQUEST);
		packet_put_int(min);
		packet_put_int(nbits);
		packet_put_int(max);
	}
	packet_send();
	packet_write_wait();

#ifdef DEBUG_KEXDH
	fprintf(stderr, "\nmin = %d, nbits = %d, max = %d", min, nbits, max);
#endif

	debug("Wait SSH2_MSG_KEX_DH_GEX_GROUP.");

	packet_read_expect(&plen, SSH2_MSG_KEX_DH_GEX_GROUP);

	debug("Got SSH2_MSG_KEX_DH_GEX_GROUP.");

	if ((p = BN_new()) == NULL)
		fatal("BN_new");
	packet_get_bignum2(p, &dlen);
	if ((g = BN_new()) == NULL)
		fatal("BN_new");
	packet_get_bignum2(g, &dlen);

	if (BN_num_bits(p) < min || BN_num_bits(p) > max)
		fatal("DH_GEX group out of range: %d !< %d !< %d",
		    min, BN_num_bits(p), max);

	dh = dh_new_group(g, p);

	dh_gen_key(dh, kex->we_need * 8);

#ifdef DEBUG_KEXDH
	fprintf(stderr, "\np= ");
	BN_print_fp(stderr, dh->p);
	fprintf(stderr, "\ng= ");
	BN_print_fp(stderr, dh->g);
	fprintf(stderr, "\npub= ");
	BN_print_fp(stderr, dh->pub_key);
	fprintf(stderr, "\n");
	DHparams_print_fp(stderr, dh);
#endif

	debug("Sending SSH2_MSG_KEX_DH_GEX_INIT.");
	/* generate and send 'e', client DH public key */
	packet_start(SSH2_MSG_KEX_DH_GEX_INIT);
	packet_put_bignum2(dh->pub_key);
	packet_send();
	packet_write_wait();

	debug("Wait SSH2_MSG_KEX_DH_GEX_REPLY.");

	packet_read_expect(&plen, SSH2_MSG_KEX_DH_GEX_REPLY);

	debug("Got SSH2_MSG_KEXDH_REPLY.");

	/* key, cert */
	server_host_key_blob = packet_get_string(&sbloblen);
	server_host_key = key_from_blob(server_host_key_blob, sbloblen);
	if (server_host_key == NULL)
		fatal("cannot decode server_host_key_blob");

	check_host_key(host, hostaddr, server_host_key,
		       options.user_hostfile2, options.system_hostfile2);

	/* DH paramter f, server public DH key */
	dh_server_pub = BN_new();
	if (dh_server_pub == NULL)
		fatal("dh_server_pub == NULL");
	packet_get_bignum2(dh_server_pub, &dlen);

#ifdef DEBUG_KEXDH
	fprintf(stderr, "\ndh_server_pub= ");
	BN_print_fp(stderr, dh_server_pub);
	fprintf(stderr, "\n");
	debug("bits %d", BN_num_bits(dh_server_pub));
#endif

	/* signed H */
	signature = packet_get_string(&slen);
	packet_done();

	if (!dh_pub_is_valid(dh, dh_server_pub))
		packet_disconnect("bad server public DH value");

	klen = DH_size(dh);
	kbuf = xmalloc(klen);
	kout = DH_compute_key(kbuf, dh_server_pub, dh);
#ifdef DEBUG_KEXDH
	debug("shared secret: len %d/%d", klen, kout);
	fprintf(stderr, "shared secret == ");
	for (i = 0; i< kout; i++)
		fprintf(stderr, "%02x", (kbuf[i])&0xff);
	fprintf(stderr, "\n");
#endif
	shared_secret = BN_new();

	BN_bin2bn(kbuf, kout, shared_secret);
	memset(kbuf, 0, klen);
	xfree(kbuf);

	if (datafellows & SSH_OLD_DHGEX) {
		/* These values are not included in the hash */
		min = -1;
		max = -1;
	}

	/* calc and verify H */
	hash = kex_hash_gex(
	    client_version_string,
	    server_version_string,
	    buffer_ptr(client_kexinit), buffer_len(client_kexinit),
	    buffer_ptr(server_kexinit), buffer_len(server_kexinit),
	    server_host_key_blob, sbloblen,
	    min, nbits, max,
	    dh->p, dh->g,
	    dh->pub_key,
	    dh_server_pub,
	    shared_secret
	);
	xfree(server_host_key_blob);
	DH_free(dh);
	BN_free(dh_server_pub);
#ifdef DEBUG_KEXDH
	fprintf(stderr, "hash == ");
	for (i = 0; i< 20; i++)
		fprintf(stderr, "%02x", (hash[i])&0xff);
	fprintf(stderr, "\n");
#endif
	if (key_verify(server_host_key, (u_char *)signature, slen, hash, 20) != 1)
		fatal("key_verify failed for server_host_key");
	key_free(server_host_key);
	xfree(signature);

	kex_derive_keys(kex, hash, shared_secret);
	BN_clear_free(shared_secret);
	packet_set_kex(kex);

	/* save session id */
	session_id2_len = 20;
	session_id2 = xmalloc(session_id2_len);
	memcpy(session_id2, hash, session_id2_len);
d209 1
d250 4
a253 1
	dispatch_init(&input_userauth_error);
@


1.59
log
@use recommended defaults
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.58 2001/03/28 21:59:40 provos Exp $");
d88 4
a102 3

	myproposal[PROPOSAL_ENC_ALGS_STOC] =
	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_STOC]);
@


1.58
log
@forgot to include min and max params in hash, okay markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.57 2001/03/27 17:46:49 provos Exp $");
d339 1
a339 1
		max = MIN(DH_GRP_MAX, nbits * 1.25);
@


1.57
log
@make dh group exchange more flexible, allow min and max group size,
okay markus@@, deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.56 2001/03/26 08:07:09 markus Exp $");
d443 6
d456 2
a457 1
	    nbits, dh->p, dh->g,
@


1.56
log
@simpler key load/save interface, see authfile.h
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.55 2001/03/23 11:04:07 djm Exp $");
d49 1
d313 1
a313 1
	u_int slen, nbits;
d326 20
a345 3
	debug("Sending SSH2_MSG_KEX_DH_GEX_REQUEST.");
	packet_start(SSH2_MSG_KEX_DH_GEX_REQUEST);
	packet_put_int(nbits);
d350 1
a350 1
	fprintf(stderr, "\nnbits = %d", nbits);
d365 5
@


1.55
log
@Compat for OpenSSH with broken Rijndael/AES. ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.54 2001/03/12 22:02:02 markus Exp $");
d904 1
a904 1
	int success = 0, quit, i;
d911 3
a913 4
	private = key_new(KEY_UNSPEC);
	if (!load_private_key(filename, "", private, NULL)) {
		if (options.batch_mode) {
			key_free(private);
a914 1
		}
d920 2
a921 2
				success = load_private_key(filename,
				    passphrase, private, NULL);
d929 1
a929 1
			if (success || quit)
a931 4
		}
		if (!success) {
			key_free(private);
			return NULL;
@


1.54
log
@remove old key_fingerprint interface, s/_ex//
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.53 2001/03/10 17:51:04 markus Exp $");
d98 3
@


1.53
log
@add PreferredAuthentications
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.52 2001/03/10 12:48:27 markus Exp $");
d663 1
a663 1
	char *pkalg, *pkblob;
a689 1
		debug2("last_key %s", key_fingerprint(authctxt->last_key));
d698 3
a700 1
		debug2("input_userauth_pk_ok: fp %s", key_fingerprint(key));
@


1.52
log
@ignore nonexisting private keys; report rjmooney@@mediaone.net
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.51 2001/03/08 21:42:33 markus Exp $");
d54 1
a501 1
void	authmethod_clear(void);
d504 1
d555 3
a567 1
	authmethod_clear();
a1111 33
#define	DELIM	","

static char *def_authlist = "publickey,password";
static char *authlist_current = NULL;	 /* clean copy used for comparison */
static char *authname_current = NULL;	 /* last used auth method */
static char *authlist_working = NULL;	 /* copy that gets modified by strtok_r() */
static char *authlist_state = NULL;	 /* state variable for strtok_r() */

/*
 * Before starting to use a new authentication method list sent by the
 * server, reset internal variables.  This should also be called when
 * finished processing server list to free resources.
 */
void
authmethod_clear(void)
{
	if (authlist_current != NULL) {
		xfree(authlist_current);
		authlist_current = NULL;
	}
	if (authlist_working != NULL) {
		xfree(authlist_working);
		authlist_working = NULL;
	}
	if (authname_current != NULL) {
		xfree(authname_current);
		authname_current = NULL;
	}
	if (authlist_state != NULL)
		authlist_state = NULL;
	return;
}

d1142 4
d1149 1
a1149 3
 * use a built-in default list.  If the server sends a nil list after
 * previously sending a valid list, continue using the list originally
 * sent.
a1150 1

d1154 3
a1156 2
	char *name = NULL, *authname_old;
	Authmethod *method = NULL;
d1160 1
a1160 1
		authlist = def_authlist;
d1162 10
a1171 15
	if (authlist_current == NULL || strcmp(authlist, authlist_current) != 0) {
		/* start over if passed a different list */
		debug3("start over, passed a different list");
		authmethod_clear();
		authlist_current = xstrdup(authlist);
		authlist_working = xstrdup(authlist);
		name = strtok_r(authlist_working, DELIM, &authlist_state);
	} else {
		/*
		 * try to use previously used authentication method
		 * or continue to use previously passed list
		 */
		name = (authname_current != NULL) ?
		    authname_current : strtok_r(NULL, DELIM, &authlist_state);
	}
d1173 7
a1179 1
	while (name != NULL) {
d1181 3
a1183 2
		method = authmethod_lookup(name);
		if (method != NULL && authmethod_is_enabled(method)) {
d1185 2
a1186 1
			break;
a1187 2
		name = strtok_r(NULL, DELIM, &authlist_state);
		method = NULL;
d1189 1
a1190 8
	authname_old = authname_current;
	if (method != NULL) {
		debug("next auth method to try is %s", name);
		authname_current = xstrdup(name);
	} else {
		debug("no more auth methods to try");
		authname_current = NULL;
	}
d1192 6
a1197 2
	if (authname_old != NULL)
		xfree(authname_old);
d1199 9
a1207 1
	return (method);
@


1.51
log
@implement client side of SSH2_MSG_USERAUTH_PK_OK (test public key ->
no need to do enter passphrase or do expensive sign operations if the
server does not accept key).
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.50 2001/03/05 17:17:21 markus Exp $");
d898 1
d900 4
@


1.50
log
@generate a 2*need size (~300 instead of 1024/2048) random private
exponent during the DH key agreement. according to Niels (the great
german advisor) this is safe since /etc/primes contains strong
primes only.

References:
        P. C. van Oorschot and M. J. Wiener, On Diffie-Hellman key
        agreement with short exponents, In Advances in Cryptology
        - EUROCRYPT'96, LNCS 1070, Springer-Verlag, 1996, pp.332-343.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.49 2001/02/28 09:57:07 markus Exp $");
d470 4
d487 1
d494 7
d561 1
d581 24
d627 3
a634 1
	Authmethod *method = NULL;
d650 49
a698 7
	for (;;) {
		method = authmethod_get(authlist);
		if (method == NULL)
			fatal("Permission denied (%s).", authlist);
		authctxt->method = method;
		if (method->userauth(authctxt) != 0) {
			debug2("we sent a %s packet, wait for reply", method->name);
a699 3
		} else {
			debug2("we did not send a packet, disable method");
			method->enabled = NULL;
d701 17
a717 2
	}
	xfree(authlist);
a728 1
	packet_write_wait();
a757 1
	packet_write_wait();
d761 13
d785 1
d816 2
a817 1
	ret = (*sign_callback)(authctxt, k, &signature, &slen, buffer_ptr(&b), buffer_len(&b));
d829 1
d840 1
a853 2

	/* send */
a854 1
	packet_write_wait();
d859 3
a861 3
/* sign callback */
int key_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
    u_char *data, int datalen)
d863 2
a864 2
	return key_sign(key, sigp, lenp, data, datalen);
}
d866 1
a866 8
int
userauth_pubkey_identity(Authctxt *authctxt, char *filename)
{
	Key *k;
	int i, ret, try_next, success = 0;
	struct stat st;
	char *passphrase;
	char prompt[300];
d868 3
a870 2
	if (stat(filename, &st) != 0) {
		debug("key does not exist: %s", filename);
d873 25
a897 1
	debug("try pubkey: %s", filename);
d899 2
a900 2
	k = key_new(KEY_UNSPEC);
	if (!load_private_key(filename, "", k, NULL)) {
d902 2
a903 2
			key_free(k);
			return 0;
d910 3
a912 2
				success = load_private_key(filename, passphrase, k, NULL);
				try_next = 0;
d915 1
a915 1
				try_next = 1;
d919 1
a919 1
			if (success || try_next)
d924 2
a925 2
			key_free(k);
			return 0;
d928 18
a945 2
	ret = sign_and_send_pubkey(authctxt, k, key_sign_cb);
	key_free(k);
a948 1
/* sign callback */
d955 6
d978 1
a978 1
		debug("userauth_pubkey_agent: trying agent key %s", comment);
d980 3
a982 2
		ret = sign_and_send_pubkey(authctxt, k, agent_sign_cb);
		key_free(k);
d994 2
d1003 15
a1017 3
		if (options.identity_files_type[idx] != KEY_RSA1)
			sent = userauth_pubkey_identity(authctxt,
			    options.identity_files[idx]);
a1042 1
	packet_write_wait();
a1099 1
	packet_write_wait();
@


1.49
log
@in ssh protocol v2 use ignore messages for padding (instead of trailing \0).
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.48 2001/02/15 23:19:59 markus Exp $");
d174 1
a174 1
	dh_gen_key(dh);
d319 1
a319 1
	nbits = dh_estimate(kex->enc[MODE_OUT].cipher->key_len * 8);
d345 1
a345 1
	dh_gen_key(dh);
@


1.48
log
@genericize password padding function for SSH1 and SSH2.
add stylized echo to 2, too.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.47 2001/02/11 12:59:25 markus Exp $");
d661 1
a661 1
	ssh_put_password(password);
d664 1
d932 1
a932 1
		ssh_put_password(response);
d939 1
@


1.47
log
@1) clean up the MAC support for SSH-2
2) allow you to specify the MAC with 'ssh -m'
3) or the 'MACs' keyword in ssh(d)_config
4) add hmac-{md5,sha1}-96
	ok stevesk@@, provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.46 2001/02/10 12:09:21 markus Exp $");
d661 1
a661 1
	packet_put_cstring(password);
d931 1
a931 1
		packet_put_cstring(response);
@


1.46
log
@remove some lines
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.45 2001/02/09 17:10:53 markus Exp $");
d87 1
a87 1
		myproposal[PROPOSAL_COMP_ALGS_CTOS] = "zlib";
d90 1
a90 1
		myproposal[PROPOSAL_COMP_ALGS_CTOS] = "none";
d92 4
@


1.45
log
@partial success: debug->log; "Permission denied" if no more auth methods
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.44 2001/02/09 12:28:35 markus Exp $");
d885 1
a885 2
 * parse SSH2_MSG_USERAUTH_INFO_REQUEST, prompt user and send
 * SSH2_MSG_USERAUTH_INFO_RESPONSE
d891 1
a891 5
	char *name = NULL;
	char *inst = NULL;
	char *lang = NULL;
	char *prompt = NULL;
	char *response = NULL;
a902 1

a904 2
	xfree(name);

d907 1
d909 1
a909 1
	xfree(lang); 				/* unused */
@


1.44
log
@do not free twice, thanks to /etc/malloc.conf
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.43 2001/02/08 10:47:05 itojun Exp $");
d604 1
a604 1
		debug("partial success");
d610 1
a610 1
			fatal("Unable to find an authentication method");
@


1.43
log
@%.30s is too short for IPv6 numeric address.  use %.128s for now.  markus ok
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.42 2001/02/06 22:26:17 markus Exp $");
d973 1
a973 1
		authlist_state = NULL;
@


1.42
log
@do not ask for passphrase in batch mode; report from ejb@@ql.org
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.41 2001/02/04 15:32:26 stevesk Exp $");
d649 1
a649 1
	snprintf(prompt, sizeof(prompt), "%.30s@@%.40s's password: ",
@


1.41
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.40 2001/01/31 20:48:08 markus Exp $");
d760 1
a760 1
	int i, ret, try_next;
d762 2
d773 4
a776 3
		int success = 0;
		char *passphrase;
		char prompt[300];
@


1.40
log
@unused
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.39 2001/01/22 23:06:40 markus Exp $");
d148 1
a148 1
ssh_dh1_client(Kex *kex, char *host, struct sockaddr *hostaddr, 
d284 1
a284 1
	
d419 1
a419 1
	    nbits, dh->p, dh->g, 
d610 1
a610 1
                        fatal("Unable to find an authentication method");
d619 1
a619 1
	}	
d685 1
a685 1
		skip = session_id2_len; 
d701 1
a701 1
		buffer_put_cstring(&b, key_ssh_name(k)); 
d724 1
a724 1
			buffer_put_cstring(&b, key_ssh_name(k)); 
d1013 1
a1013 1
 */ 
d1020 1
a1020 1
	
@


1.39
log
@rename skey -> challenge response.
auto-enable kbd-interactive for ssh2 if challenge-reponse is enabled.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.38 2001/01/22 17:22:28 stevesk Exp $");
a531 1
		packet_done();
@


1.38
log
@fix memory leaks in SSH2 key exchange; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.37 2001/01/21 19:06:00 markus Exp $");
d515 3
@


1.37
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.36 2001/01/20 18:20:29 stevesk Exp $");
d251 1
d261 1
d264 1
d426 1
d436 1
d439 1
@


1.36
log
@dh_new_group() does not return NULL.  ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.35 2001/01/04 22:21:26 markus Exp $");
a28 2
#include <openssl/rsa.h>
#include <openssl/dsa.h>
d34 1
a40 1
#include "readconf.h"
d42 1
a42 1
#include "ssh2.h"
d51 3
@


1.35
log
@handle SSH2_MSG_USERAUTH_BANNER; fixes bug when connecting to a server that prints a banner (e.g. /etc/issue.net)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.34 2000/12/27 12:34:50 markus Exp $");
d335 1
a335 2
	if ((dh = dh_new_group(g, p)) == NULL)
		fatal("dh_new_group");
@


1.34
log
@typo
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.33 2000/12/20 19:37:22 markus Exp $");
d470 1
d547 1
d558 13
a570 1
	fatal("input_userauth_error: bad message during authentication");
@


1.33
log
@fix prototypes; from  stevesk@@pobox.com
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.32 2000/12/19 23:17:58 markus Exp $");
d551 1
a551 1
	debug("ssh-userauth2 successfull: method %s", authctxt.method->name);
@


1.32
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.31 2000/12/15 17:30:14 provos Exp $");
d478 1
a478 1
void	authmethod_clear();
d936 1
a936 1
authmethod_clear()
@


1.31
log
@compute diffie-hellman in parallel between server and client. okay markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.30 2000/12/03 11:15:04 markus Exp $");
d66 1
a66 1
unsigned char *session_id2 = NULL;
d154 1
a154 1
	unsigned int klen, kout;
d156 1
a156 1
	unsigned int slen;
d159 1
a159 1
	unsigned int sbloblen;
d163 2
a164 2
	unsigned char *kbuf;
	unsigned char *hash;
d256 1
a256 1
	if (key_verify(server_host_key, (unsigned char *)signature, slen, hash, 20) != 1)
d298 1
a298 1
	unsigned int klen, kout;
d300 1
a300 1
	unsigned int slen, nbits;
d303 1
a303 1
	unsigned int sbloblen;
d308 2
a309 2
	unsigned char *kbuf;
	unsigned char *hash;
d429 1
a429 1
	if (key_verify(server_host_key, (unsigned char *)signature, slen, hash, 20) != 1)
d451 1
a451 1
    unsigned char **sigp, int *lenp, unsigned char *data, int datalen);
d647 1
a647 1
	unsigned char *blob, *signature;
d728 2
a729 2
int key_sign_cb(Authctxt *authctxt, Key *key, unsigned char **sigp, int *lenp,
    unsigned char *data, int datalen)
d780 2
a781 2
int agent_sign_cb(Authctxt *authctxt, Key *key, unsigned char **sigp, int *lenp,
    unsigned char *data, int datalen)
d872 1
a872 1
	unsigned int num_prompts, i;
@


1.30
log
@support f-secure/ssh.com 2.0.12; ok niels@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.29 2000/11/23 21:03:47 markus Exp $");
d169 1
d337 2
@


1.29
log
@complain about invalid ciphers for ssh1/ssh2, fall back to reasonable defaults
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.28 2000/11/12 19:50:38 markus Exp $");
d650 1
d653 1
d668 1
a668 1
	    datafellows & SSH_BUG_PUBKEYAUTH ?
d671 7
a677 3
	buffer_put_cstring(&b, authctxt->method->name);
	buffer_put_char(&b, have_sig);
	buffer_put_cstring(&b, key_ssh_name(k)); 
d690 1
a690 1
	if (datafellows & SSH_BUG_PUBKEYAUTH) {
d698 2
a699 1
		buffer_put_cstring(&b, key_ssh_name(k)); 
@


1.28
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.27 2000/10/19 16:45:16 provos Exp $");
d77 3
a79 8
	if (options.ciphers == NULL) {
		if (options.cipher == SSH_CIPHER_3DES) {
			options.ciphers = "3des-cbc";
		} else if (options.cipher == SSH_CIPHER_BLOWFISH) {
			options.ciphers = "blowfish-cbc";
		} else if (options.cipher == SSH_CIPHER_DES) {
			fatal("cipher DES not supported for protocol version 2");
		}
@


1.27
log
@don't reference freed memory. okay deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.26 2000/10/14 12:16:56 markus Exp $");
a47 1
#include "dsa.h"
d198 1
a198 1
	server_host_key = dsa_key_from_blob(server_host_key_blob, sbloblen);
d260 2
a261 2
	if (dsa_verify(server_host_key, (unsigned char *)signature, slen, hash, 20) != 1)
		fatal("dsa_verify failed for server_host_key");
d368 1
a368 1
	server_host_key = dsa_key_from_blob(server_host_key_blob, sbloblen);
d431 2
a432 2
	if (dsa_verify(server_host_key, (unsigned char *)signature, slen, hash, 20) != 1)
		fatal("dsa_verify failed for server_host_key");
d487 1
a487 1
		&options.dsa_authentication,
d655 4
a658 2
	dsa_make_key_blob(k, &blob, &bloblen);

d676 1
a676 1
	buffer_put_cstring(&b, KEX_DSS); 
d686 1
a686 1
#ifdef DEBUG_DSS
d697 1
a697 1
		buffer_put_cstring(&b, KEX_DSS); 
d723 1
a723 1
int dsa_sign_cb(Authctxt *authctxt, Key *key, unsigned char **sigp, int *lenp,
d726 1
a726 1
	return dsa_sign(key, sigp, lenp, data, datalen);
d742 1
a742 1
	k = key_new(KEY_DSA);
d748 1
a748 2
		     "Enter passphrase for %s key '%.100s': ",
		     key_type(k), filename);
d769 1
a769 1
	ret = sign_and_send_pubkey(authctxt, k, dsa_sign_cb);
d785 1
a787 1
	int ret;
d790 2
a791 1
		k = ssh_get_first_identity(authctxt->agent, &comment, 2);
a792 2
	} else {
		k = ssh_get_next_identity(authctxt->agent, &comment, 2);
d794 1
d796 6
a801 2
		debug2("no more DSA keys from agent");
		return 0;
d803 2
a804 4
	debug("trying DSA agent key %s", comment);
	xfree(comment);
	ret = sign_and_send_pubkey(authctxt, k, agent_sign_cb);
	key_free(k);
d814 11
a824 4
	if (authctxt->agent != NULL)
		sent = userauth_pubkey_agent(authctxt);
	while (sent == 0 && idx < options.num_identity_files2)
		sent = userauth_pubkey_identity(authctxt, options.identity_files2[idx++]);
@


1.27.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.48 2001/02/15 23:19:59 markus Exp $");
d29 2
a35 1
#include "ssh2.h"
d42 1
d44 1
a44 1
#include "cipher.h"
d48 1
a53 3
#include "log.h"
#include "readconf.h"
#include "readpass.h"
d67 1
a67 1
u_char *session_id2 = NULL;
d78 8
a85 3
	if (options.ciphers == (char *)-1) {
		log("No valid ciphers for protocol version 2 given, using defaults.");
		options.ciphers = NULL;
d92 1
a92 1
		myproposal[PROPOSAL_COMP_ALGS_CTOS] =
d95 1
a95 1
		myproposal[PROPOSAL_COMP_ALGS_CTOS] =
a97 4
	if (options.macs != NULL) {
		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
		myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;
	}
d153 1
a153 1
ssh_dh1_client(Kex *kex, char *host, struct sockaddr *hostaddr,
d160 1
a160 1
	u_int klen, kout;
d162 1
a162 1
	u_int slen;
d165 1
a165 1
	u_int sbloblen;
d169 2
a170 2
	u_char *kbuf;
	u_char *hash;
a174 1
	dh_gen_key(dh);
d199 1
a199 1
	server_host_key = key_from_blob(server_host_key_blob, sbloblen);
a254 1
	BN_free(dh_server_pub);
d261 2
a262 2
	if (key_verify(server_host_key, (u_char *)signature, slen, hash, 20) != 1)
		fatal("key_verify failed for server_host_key");
a263 1
	xfree(signature);
a265 1
	BN_clear_free(shared_secret);
d285 1
a285 1

d303 1
a303 1
	u_int klen, kout;
d305 1
a305 1
	u_int slen, nbits;
d308 1
a308 1
	u_int sbloblen;
d313 2
a314 2
	u_char *kbuf;
	u_char *hash;
d340 2
a341 3
	dh = dh_new_group(g, p);

	dh_gen_key(dh);
d369 1
a369 1
	server_host_key = key_from_blob(server_host_key_blob, sbloblen);
d419 1
a419 1
	    nbits, dh->p, dh->g,
a425 1
	BN_free(dh_server_pub);
d432 2
a433 2
	if (key_verify(server_host_key, (u_char *)signature, slen, hash, 20) != 1)
		fatal("key_verify failed for server_host_key");
a434 1
	xfree(signature);
a436 1
	BN_clear_free(shared_secret);
d454 1
a454 1
    u_char **sigp, int *lenp, u_char *data, int datalen);
a472 1
void	input_userauth_banner(int type, int plen, void *ctxt);
d481 1
a481 1
void	authmethod_clear(void);
d488 1
a488 1
		&options.pubkey_authentication,
a511 3
	if (options.challenge_reponse_authentication)
		options.kbd_interactive_authentication = 1;

d525 1
a548 1
	dispatch_set(SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);
d554 1
a554 1
	debug("ssh-userauth2 successful: method %s", authctxt.method->name);
d559 1
a559 13
	fatal("input_userauth_error: bad message during authentication: "
	   "type %d", type);
}
void
input_userauth_banner(int type, int plen, void *ctxt)
{
	char *msg, *lang;
	debug3("input_userauth_banner");
	msg = packet_get_string(NULL);
	lang = packet_get_string(NULL);
	fprintf(stderr, "%s", msg);
	xfree(msg);
	xfree(lang);
d585 1
a585 1
		log("Authenticated with partial success.");
d591 1
a591 1
			fatal("Permission denied (%s).", authlist);
d600 1
a600 1
	}
d630 1
a630 1
	snprintf(prompt, sizeof(prompt), "%.30s@@%.128s's password: ",
d638 1
a638 1
	ssh_put_password(password);
d650 1
a650 1
	u_char *blob, *signature;
d656 2
a657 6
	debug3("sign_and_send_pubkey");
	if (key_to_blob(k, &blob, &bloblen) == 0) {
		/* we cannot handle this key */
		debug3("sign_and_send_pubkey: cannot handle key");
		return 0;
	}
d662 1
a662 1
		skip = session_id2_len;
d670 1
a670 1
	    datafellows & SSH_BUG_PKSERVICE ?
d673 3
a675 7
	if (datafellows & SSH_BUG_PKAUTH) {
		buffer_put_char(&b, have_sig);
	} else {
		buffer_put_cstring(&b, authctxt->method->name);
		buffer_put_char(&b, have_sig);
		buffer_put_cstring(&b, key_ssh_name(k));
	}
d685 1
a685 1
#ifdef DEBUG_PK
d688 1
a688 1
	if (datafellows & SSH_BUG_PKSERVICE) {
d696 1
a696 2
		if (!(datafellows & SSH_BUG_PKAUTH))
			buffer_put_cstring(&b, key_ssh_name(k));
d722 2
a723 2
int key_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
    u_char *data, int datalen)
d725 1
a725 1
	return key_sign(key, sigp, lenp, data, datalen);
d732 1
a732 1
	int i, ret, try_next, success = 0;
a733 2
	char *passphrase;
	char prompt[300];
d741 1
a741 1
	k = key_new(KEY_UNSPEC);
d743 3
a745 4
		if (options.batch_mode) {
			key_free(k);
			return 0;
		}
d747 2
a748 1
		     "Enter passphrase for key '%.100s': ", filename);
d769 1
a769 1
	ret = sign_and_send_pubkey(authctxt, k, key_sign_cb);
d775 2
a776 2
int agent_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
    u_char *data, int datalen)
a784 1
	int ret = 0;
d787 1
d790 1
a790 2
		if (ssh_get_num_identities(authctxt->agent, 2) == 0)
			debug2("userauth_pubkey_agent: no keys at all");
d792 2
a794 1
	k = ssh_get_next_identity(authctxt->agent, &comment, 2);
d796 2
a797 6
		debug2("userauth_pubkey_agent: no more keys");
	} else {
		debug("userauth_pubkey_agent: trying agent key %s", comment);
		xfree(comment);
		ret = sign_and_send_pubkey(authctxt, k, agent_sign_cb);
		key_free(k);
d799 4
a802 2
	if (ret == 0)
		debug2("userauth_pubkey_agent: no message sent");
d812 4
a815 11
	if (authctxt->agent != NULL) {
		do {
			sent = userauth_pubkey_agent(authctxt);
		} while(!sent && authctxt->agent->howmany > 0);
	}
	while (!sent && idx < options.num_identity_files) {
		if (options.identity_files_type[idx] != KEY_RSA1)
			sent = userauth_pubkey_identity(authctxt,
			    options.identity_files[idx]);
		idx++;
	}
d846 2
a847 1
 * parse INFO_REQUEST, prompt user and send INFO_RESPONSE
d853 6
a858 2
	char *name, *inst, *lang, *prompt, *response;
	u_int num_prompts, i;
d869 1
d872 2
a875 1
	xfree(name);
d877 1
a877 1
	xfree(lang);
d895 1
a895 1
		ssh_put_password(response);
d922 1
a922 1
authmethod_clear(void)
d934 1
a934 1
		authname_current = NULL;
d977 1
a977 1
 */
d984 1
a984 1

@


1.27.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.27.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.54 2001/03/12 22:02:02 markus Exp $");
a53 1
#include "match.h"
d174 1
a174 1
	dh_gen_key(dh, kex->we_need * 8);
d319 1
a319 1
	nbits = dh_estimate(kex->we_need * 8);
d345 1
a345 1
	dh_gen_key(dh, kex->we_need * 8);
a469 4
	char *authlist;
	Key *last_key;
	sign_cb_fn *last_key_sign;
	int last_key_hint;
a482 1
void	input_userauth_pk_ok(int type, int plen, void *ctxt);
d489 1
a489 7
void	userauth(Authctxt *authctxt, char *authlist);

int
sign_and_send_pubkey(Authctxt *authctxt, Key *k,
    sign_cb_fn *sign_callback);
void	clear_auth_state(Authctxt *authctxt);

a491 1
char *authmethods_get(void);
a541 3
	if (options.preferred_authentications == NULL)
		options.preferred_authentications = authmethods_get();

a548 1
	authctxt.authlist = NULL;
d551 1
a567 24
userauth(Authctxt *authctxt, char *authlist)
{
	if (authlist == NULL) {
		authlist = authctxt->authlist;
	} else {
		if (authctxt->authlist)
			xfree(authctxt->authlist);
		authctxt->authlist = authlist;
	}
	for (;;) {
		Authmethod *method = authmethod_get(authlist);
		if (method == NULL)
			fatal("Permission denied (%s).", authlist);
		authctxt->method = method;
		if (method->userauth(authctxt) != 0) {
			debug2("we sent a %s packet, wait for reply", method->name);
			break;
		} else {
			debug2("we did not send a packet, disable method");
			method->enabled = NULL;
		}
	}
}
void
a589 3
	if (authctxt->authlist)
		xfree(authctxt->authlist);
	clear_auth_state(authctxt);
d595 1
d611 7
a617 35
	clear_auth_state(authctxt);
	userauth(authctxt, authlist);
}
void
input_userauth_pk_ok(int type, int plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	Key *key = NULL;
	Buffer b;
	int alen, blen, pktype, sent = 0;
	char *pkalg, *pkblob, *fp;

	if (authctxt == NULL)
		fatal("input_userauth_pk_ok: no authentication context");
	if (datafellows & SSH_BUG_PKOK) {
		/* this is similar to SSH_BUG_PKAUTH */
		debug2("input_userauth_pk_ok: SSH_BUG_PKOK");
		pkblob = packet_get_string(&blen);
		buffer_init(&b);
		buffer_append(&b, pkblob, blen);
		pkalg = buffer_get_string(&b, &alen);
		buffer_free(&b);
	} else {
		pkalg = packet_get_string(&alen);
		pkblob = packet_get_string(&blen);
	}
	packet_done();

	debug("input_userauth_pk_ok: pkalg %s blen %d lastkey %p hint %d",
	    pkalg, blen, authctxt->last_key, authctxt->last_key_hint);

	do {
		if (authctxt->last_key == NULL ||
		    authctxt->last_key_sign == NULL) {
			debug("no last key or no sign cb");
d619 3
d623 2
a624 32
		if ((pktype = key_type_from_name(pkalg)) == KEY_UNSPEC) {
			debug("unknown pkalg %s", pkalg);
			break;
		}
		if ((key = key_from_blob(pkblob, blen)) == NULL) {
			debug("no key from blob. pkalg %s", pkalg);
			break;
		}
		fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
		debug2("input_userauth_pk_ok: fp %s", fp);
		xfree(fp);
		if (!key_equal(key, authctxt->last_key)) {
			debug("key != last_key");
			break;
		}
		sent = sign_and_send_pubkey(authctxt, key,
		   authctxt->last_key_sign);
	} while(0);

	if (key != NULL)
		key_free(key);
	xfree(pkalg);
	xfree(pkblob);

	/* unregister */
	clear_auth_state(authctxt);
	dispatch_set(SSH2_MSG_USERAUTH_PK_OK, NULL);

	/* try another method if we did not send a packet*/
	if (sent == 0)
		userauth(authctxt, NULL);

d636 1
d661 1
a661 1
	packet_put_cstring(password);
a663 1
	packet_inject_ignore(64);
d665 1
a668 13
void
clear_auth_state(Authctxt *authctxt)
{
	/* XXX clear authentication state */
	if (authctxt->last_key != NULL && authctxt->last_key_hint == -1) {
		debug3("clear_auth_state: key_free %p", authctxt->last_key);
		key_free(authctxt->last_key);
	}
	authctxt->last_key = NULL;
	authctxt->last_key_hint = -2;
	authctxt->last_key_sign = NULL;
}

a679 1

d710 1
a710 2
	ret = (*sign_callback)(authctxt, k, &signature, &slen,
	    buffer_ptr(&b), buffer_len(&b));
a721 1
		skip = session_id2_len;
a731 1

d745 2
d748 1
d753 3
a755 3
int
send_pubkey_test(Authctxt *authctxt, Key *k, sign_cb_fn *sign_callback,
    int hint)
d757 1
a757 27
	u_char *blob;
	int bloblen, have_sig = 0;

	debug3("send_pubkey_test");

	if (key_to_blob(k, &blob, &bloblen) == 0) {
		/* we cannot handle this key */
		debug3("send_pubkey_test: cannot handle key");
		return 0;
	}
	/* register callback for USERAUTH_PK_OK message */
	authctxt->last_key_sign = sign_callback;
	authctxt->last_key_hint = hint;
	authctxt->last_key = k;
	dispatch_set(SSH2_MSG_USERAUTH_PK_OK, &input_userauth_pk_ok);

	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
	packet_put_char(have_sig);
	if (!(datafellows & SSH_BUG_PKAUTH))
		packet_put_cstring(key_ssh_name(k));
	packet_put_string(blob, bloblen);
	xfree(blob);
	packet_send();
	return 1;
d760 2
a761 2
Key *
load_identity_file(char *filename)
d763 2
a764 3
	Key *private;
	char prompt[300], *passphrase;
	int success = 0, quit, i;
d766 2
d769 3
a771 3
	if (stat(filename, &st) < 0) {
		debug3("no such identity: %s", filename);
		return NULL;
d773 4
a776 2
	private = key_new(KEY_UNSPEC);
	if (!load_private_key(filename, "", private, NULL)) {
d778 2
a779 2
			key_free(private);
			return NULL;
d786 2
a787 3
				success = load_private_key(filename,
				    passphrase, private, NULL);
				quit = 0;
d790 1
a790 1
				quit = 1;
d794 1
a794 1
			if (success || quit)
d799 2
a800 2
			key_free(private);
			return NULL;
d803 2
a804 18
	return private;
}

int
identity_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
    u_char *data, int datalen)
{
	Key *private;
	int idx, ret;

	idx = authctxt->last_key_hint;
	if (idx < 0)
		return -1;
	private = load_identity_file(options.identity_files[idx]);
	if (private == NULL)
		return -1;
	ret = key_sign(private, sigp, lenp, data, datalen);
	key_free(private);
d808 1
a814 6
int key_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
    u_char *data, int datalen)
{
        return key_sign(key, sigp, lenp, data, datalen);
}

d832 1
a832 1
		debug("userauth_pubkey_agent: testing agent key %s", comment);
d834 2
a835 3
		ret = send_pubkey_test(authctxt, k, agent_sign_cb, -1);
		if (ret == 0)
			key_free(k);
a846 2
	Key *key;
	char *filename;
d854 3
a856 15
		key = options.identity_keys[idx];
		filename = options.identity_files[idx];
		if (key == NULL) {
			debug("try privkey: %s", filename);
			key = load_identity_file(filename);
			if (key != NULL) {
				sent = sign_and_send_pubkey(authctxt, key,
				    key_sign_cb);
				key_free(key);
			}
		} else if (key->type != KEY_RSA1) {
			debug("try pubkey: %s", filename);
			sent = send_pubkey_test(authctxt, key,
			    identity_sign_cb, idx);
		}
d882 1
d931 1
a931 1
		packet_put_cstring(response);
a937 1
	packet_inject_ignore(64);
d939 1
d944 33
a1006 4
/* XXX internal state */
static Authmethod *current = NULL;
static char *supported = NULL;
static char *preferred = NULL;
d1010 3
a1012 1
 * use a built-in default list. 
d1014 1
d1018 2
a1019 3

	char *name = NULL;
	int next;
d1023 1
a1023 1
		authlist = options.preferred_authentications;
d1025 15
a1039 10
	if (supported == NULL || strcmp(authlist, supported) != 0) {
		debug3("start over, passed a different list %s", authlist);
		if (supported != NULL)
			xfree(supported);
		supported = xstrdup(authlist);
		preferred = options.preferred_authentications;
		debug3("preferred %s", preferred);
		current = NULL;
	} else if (current != NULL && authmethod_is_enabled(current))
		return current;
d1041 1
a1041 7
	for (;;) {
		if ((name = match_list(preferred, supported, &next)) == NULL) {
			debug("no more auth methods to try");
			current = NULL;
			return NULL;
		}
		preferred += next;
d1043 2
a1044 3
		debug3("remaining preferred: %s", preferred);
		if ((current = authmethod_lookup(name)) != NULL &&
		    authmethod_is_enabled(current)) {
d1046 1
a1046 2
			debug("next auth method to try is %s", name);
			return current;
d1048 2
a1050 1
}
d1052 8
d1061 2
a1062 6
#define	DELIM	","
char *
authmethods_get(void)
{
	Authmethod *method = NULL;
	char buf[1024];
d1064 1
a1064 9
	buf[0] = '\0';
	for (method = authmethods; method->name != NULL; method++) {
		if (authmethod_is_enabled(method)) {
			if (buf[0] != '\0')
				strlcat(buf, DELIM, sizeof buf);
			strlcat(buf, method->name, sizeof buf);
		}
	}
	return xstrdup(buf);
@


1.27.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.72 2001/04/18 23:43:26 markus Exp $");
d49 1
a49 1
#include "dh.h"
d55 3
a57 2
#include "dispatch.h"
#include "canohost.h"
a70 13
char *xxx_host;
struct sockaddr *xxx_hostaddr;

Kex *xxx_kex = NULL;

int
check_host_key_callback(Key *hostkey)
{
	check_host_key(xxx_host, xxx_hostaddr, hostkey,
	    options.user_hostfile2, options.system_hostfile2);
	return 0;
}

d74 1
d76 2
a77 3

	xxx_host = host;
	xxx_hostaddr = hostaddr;
a86 4
	myproposal[PROPOSAL_ENC_ALGS_CTOS] =
	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_CTOS]);
	myproposal[PROPOSAL_ENC_ALGS_STOC] =
	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_STOC]);
a97 9
	if (options.hostkeyalgorithms != NULL)
	        myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =
		    options.hostkeyalgorithms;

	/* start key exchange */
	kex = kex_setup(myproposal);
	kex->client_version_string=client_version_string;
	kex->server_version_string=server_version_string;
	kex->check_host_key=&check_host_key_callback;
d99 29
a127 1
	xxx_kex = kex;
d129 4
a132 1
	dispatch_run(DISPATCH_BLOCK, &kex->done, kex);
d134 5
a138 2
	session_id2 = kex->session_id;
	session_id2_len = kex->session_id_len;
d147 304
a450 1
	debug("done: ssh_kex2.");
a465 1
	const char *local_user;
d468 1
a471 1
	/* pubkey */
a474 4
	AuthenticationConnection *agent;
	/* hostbased */
	Key **keys;
	int nkeys;
a493 1
int	userauth_hostbased(Authctxt *authctxt);
a518 4
	{"hostbased",
		userauth_hostbased,
		&options.hostbased_authentication,
		NULL},
d527 1
a527 2
ssh_userauth2(const char *local_user, const char *server_user, char *host,
    Key **keys, int nkeys)
a560 1
	authctxt.local_user = local_user;
a565 2
	authctxt.keys = keys;
	authctxt.nkeys = nkeys;
d662 1
a662 1
	int alen, blen, sent = 0;
d690 1
a690 1
		if (key_type_from_name(pkalg) == KEY_UNSPEC) {
d901 1
a901 1
	int quit, i;
d908 4
a911 3
	private = key_load_private_type(KEY_UNSPEC, filename, "", NULL);
	if (private == NULL) {
		if (options.batch_mode)
d913 1
d919 2
a920 2
				private = key_load_private_type(KEY_UNSPEC, filename,
				    passphrase, NULL);
d928 1
a928 1
			if (private != NULL || quit)
d932 4
d967 1
a967 1
	return key_sign(key, sigp, lenp, data, datalen);
a1110 89
/*
 * this will be move to an external program (ssh-keysign) ASAP. ssh-keysign
 * will be setuid-root and the sbit can be removed from /usr/bin/ssh.
 */
int
userauth_hostbased(Authctxt *authctxt)
{
	Key *private = NULL;
	Buffer b;
	u_char *signature, *blob;
	char *chost, *pkalg, *p;
	const char *service;
	u_int blen, slen;
	int ok, i, len, found = 0;

	p = get_local_name(packet_get_connection_in());
	if (p == NULL) {
		error("userauth_hostbased: cannot get local ipaddr/name");
		return 0;
	}
	len = strlen(p) + 2;
	chost = xmalloc(len);
	strlcpy(chost, p, len);
	strlcat(chost, ".", len);
	debug2("userauth_hostbased: chost %s", chost);
	/* check for a useful key */
	for (i = 0; i < authctxt->nkeys; i++) {
		private = authctxt->keys[i];
		if (private && private->type != KEY_RSA1) {
			found = 1;
			/* we take and free the key */
			authctxt->keys[i] = NULL;
			break;
		}
	}
	if (!found) {
		xfree(chost);
		return 0;
	}
	if (key_to_blob(private, &blob, &blen) == 0) {
		key_free(private);
		xfree(chost);
		return 0;
	}
	service = datafellows & SSH_BUG_HBSERVICE ? "ssh-userauth" :
	    authctxt->service;
	pkalg = xstrdup(key_ssh_name(private));
	buffer_init(&b);
	/* construct data */
	buffer_put_string(&b, session_id2, session_id2_len);
	buffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);
	buffer_put_cstring(&b, authctxt->server_user);
	buffer_put_cstring(&b, service);
	buffer_put_cstring(&b, authctxt->method->name);
	buffer_put_cstring(&b, pkalg);
	buffer_put_string(&b, blob, blen);
	buffer_put_cstring(&b, chost);
	buffer_put_cstring(&b, authctxt->local_user);
#ifdef DEBUG_PK
	buffer_dump(&b);
#endif
	debug2("xxx: chost %s", chost);
	ok = key_sign(private, &signature, &slen, buffer_ptr(&b), buffer_len(&b));
	key_free(private);
	buffer_free(&b);
	if (ok != 0) {
		error("key_sign failed");
		xfree(chost);
		xfree(pkalg);
		return 0;
	}
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
	packet_put_cstring(pkalg);
	packet_put_string(blob, blen);
	packet_put_cstring(chost);
	packet_put_cstring(authctxt->local_user);
	packet_put_string(signature, slen);
	memset(signature, 's', slen);
	xfree(signature);
	xfree(chost);
	xfree(pkalg);

	packet_send();
	return 1;
}

d1150 1
a1150 1
 * use a built-in default list.
@


1.27.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.82 2001/08/31 11:46:39 markus Exp $");
d48 1
d75 2
a76 2
static int
verify_host_key_callback(Key *hostkey)
d78 2
a79 2
	if (verify_host_key(xxx_host, xxx_hostaddr, hostkey) == -1)
		fatal("verify_host_key failed");
d122 1
a122 1
	kex->verify_host_key=&verify_host_key_callback;
a167 2
	/* kbd-interactive */
	int info_req_seen;
d191 8
a198 6
static int sign_and_send_pubkey(Authctxt *, Key *, sign_cb_fn *);
static void clear_auth_state(Authctxt *);

static Authmethod *authmethod_get(char *authlist);
static Authmethod *authmethod_lookup(const char *name);
static char *authmethods_get(void);
a200 4
	{"hostbased",
		userauth_hostbased,
		&options.hostbased_authentication,
		NULL},
d205 4
d213 4
a216 4
	{"password",
		userauth_passwd,
		&options.password_authentication,
		&options.batch_mode},
d232 1
a232 1
	if (options.challenge_response_authentication)
a257 1
	memset(&authctxt, 0, sizeof(authctxt));
a267 1
	authctxt.info_req_seen = 0;
d467 1
a467 1
static void
d480 1
a480 1
static int
d565 1
a565 1
static int
d598 1
a598 1
static Key *
d636 1
a636 1
static int
a645 5

	/* private key is stored in external hardware */
	if (options.identity_keys[idx]->flags & KEY_FLAG_EXT) 
		return key_sign(options.identity_keys[idx], sigp, lenp, data, datalen);

d654 1
a654 2
static int
agent_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
d660 1
a660 2
static int
key_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
d666 1
a666 1
static int
a737 6
	/* disable if no SSH2_MSG_USERAUTH_INFO_REQUEST has been seen */
	if (attempt > 1 && !authctxt->info_req_seen) {
		debug3("userauth_kbdint: disable: no info_req_seen");
		dispatch_set(SSH2_MSG_USERAUTH_INFO_REQUEST, NULL);
		return 0;
	}
a768 2
	authctxt->info_req_seen = 1;

d773 1
a773 1
		log("%s", name);
d775 1
a775 1
		log("%s", inst);
a789 1
	debug2("input_userauth_info_req: num_prompts %d", num_prompts);
d794 1
a794 1
		response = read_passphrase(prompt, echo ? RP_ECHO : 0);
d902 1
a902 1
static int
d916 1
a916 1
static Authmethod *
d937 1
a937 1
static Authmethod *
d979 1
a979 2

static char *
@


1.27.2.6
log
@Merge OpenSSH 3.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.27.2.5 2001/09/27 00:15:43 miod Exp $");
d78 1
a78 1
		fatal("Host key verification failed.");
@


1.27.2.7
log
@Merge OpenSSH 3.0.1.

This is likely to be the last commit to the 2.8-STABLE branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.27.2.6 2001/11/15 00:15:00 miod Exp $");
d463 1
a463 1
	packet_add_padding(64);
d820 1
a820 1
	packet_add_padding(64);
d839 10
d860 1
a860 1
		debug("userauth_hostbased: no more client hostkeys");
d865 1
a867 13
	/* figure out a name for the client host */
	p = get_local_name(packet_get_connection_in());
	if (p == NULL) {
		error("userauth_hostbased: cannot get local ipaddr/name");
		key_free(private);
		return 0;
	}
	len = strlen(p) + 2;
	chost = xmalloc(len);
	strlcpy(chost, p, len);
	strlcat(chost, ".", len);
	debug2("userauth_hostbased: chost %s", chost);

d885 1
@


1.27.2.8
log
@Merge OpenSSH 3.1.
@
text
@d26 6
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.97 2002/02/25 16:33:27 markus Exp $");
d36 1
d39 1
d45 1
d114 1
a114 1
		myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =
d149 1
a149 1
    u_char **sigp, u_int *lenp, u_char *data, u_int datalen);
d177 12
a188 12
void	input_userauth_success(int, u_int32_t, void *);
void	input_userauth_failure(int, u_int32_t, void *);
void	input_userauth_banner(int, u_int32_t, void *);
void	input_userauth_error(int, u_int32_t, void *);
void	input_userauth_info_req(int, u_int32_t, void *);
void	input_userauth_pk_ok(int, u_int32_t, void *);

int	userauth_none(Authctxt *);
int	userauth_pubkey(Authctxt *);
int	userauth_passwd(Authctxt *);
int	userauth_kbdint(Authctxt *);
int	userauth_hostbased(Authctxt *);
d190 1
a190 1
void	userauth(Authctxt *, char *);
d229 1
d239 1
a239 1
	type = packet_read();
d244 1
a244 1
		char *reply = packet_get_string(NULL);
d250 1
a250 1
	packet_check_eom();
d311 1
a311 1
input_userauth_error(int type, u_int32_t seq, void *ctxt)
d317 1
a317 1
input_userauth_banner(int type, u_int32_t seq, void *ctxt)
d328 1
a328 1
input_userauth_success(int type, u_int32_t seq, void *ctxt)
d339 1
a339 1
input_userauth_failure(int type, u_int32_t seq, void *ctxt)
d350 1
a350 1
	packet_check_eom();
d360 1
a360 1
input_userauth_pk_ok(int type, u_int32_t seq, void *ctxt)
d365 2
a366 4
	int pktype, sent = 0;
	u_int alen, blen;
	char *pkalg, *fp;
	u_char *pkblob;
d382 1
a382 1
	packet_check_eom();
d393 1
a393 1
		if ((pktype = key_type_from_name(pkalg)) == KEY_UNSPEC) {
a400 6
		if (key->type != pktype) { 
			error("input_userauth_pk_ok: type mismatch "
			    "for decoded key (received %d, expected %d)",
			     key->type, pktype);
			break;
		}
d410 1
a410 1
	} while (0);
d449 1
a449 1
	if (attempt != 1)
d486 1
a486 1
	u_int bloblen, slen;
d571 1
a571 1
	u_int bloblen, have_sig = 0;
d616 1
a616 1
		    "Enter passphrase for key '%.100s': ", filename);
d638 2
a639 2
identity_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d649 1
a649 1
	if (options.identity_keys[idx]->flags & KEY_FLAG_EXT)
d661 2
a662 2
agent_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d668 2
a669 2
key_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d713 1
a713 1
		} while (!sent && authctxt->agent->howmany > 0);
d771 1
a771 1
input_userauth_info_req(int type, u_int32_t seq, void *ctxt)
d818 1
a818 1
	packet_check_eom(); /* done with parsing incoming message. */
d960 1
a960 1
	u_int next;
d995 3
d1002 1
a1002 2
	Buffer b;
	char *list;
d1004 1
a1004 1
	buffer_init(&b);
d1007 3
a1009 3
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			buffer_append(&b, method->name, strlen(method->name));
d1012 1
a1012 4
	buffer_append(&b, "\0", 1);
	list = xstrdup(buffer_ptr(&b));
	buffer_free(&b);
	return list;
@


1.26
log
@OpenSSH_2.3; note that is is not complete, but the version number needs to be changed for interoperability reasons
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.25 2000/10/12 09:59:19 markus Exp $");
d982 1
a982 1
	char *name = NULL;
d1016 1
a1016 3
	if (authname_current != NULL)
		xfree(authname_current);

a1019 1
		return method;
a1022 1
		return NULL;
d1024 5
@


1.25
log
@enable DES in SSH-1 clients only
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.24 2000/10/11 20:27:24 markus Exp $");
d660 4
a663 1
	if (datafellows & SSH_COMPAT_SESSIONID_ENCODING) {
a665 3
	} else {
		buffer_append(&b, session_id2, session_id2_len);
		skip = session_id2_len; 
@


1.24
log
@new cipher framework
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.23 2000/10/11 20:14:39 markus Exp $");
d83 2
@


1.23
log
@add support for s/key (kbd-interactive) to ssh2, based on work by mkiernan@@avantgo.com and me
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.22 2000/10/11 04:02:17 provos Exp $");
a39 1
#include "cipher.h"
d78 7
a87 8
	} else if (options.cipher == SSH_CIPHER_3DES) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] =
		    (char *) cipher_name(SSH_CIPHER_3DES_CBC);
	} else if (options.cipher == SSH_CIPHER_BLOWFISH) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] =
		    (char *) cipher_name(SSH_CIPHER_BLOWFISH_CBC);
d314 1
a314 1
	nbits = dh_estimate(kex->enc[MODE_OUT].key_len * 8);
@


1.22
log
@First rough implementation of the diffie-hellman group exchange.  The
client can ask the server for bigger groups to perform the diffie-hellman
in, thus increasing the attack complexity when using ciphers with longer
keys.  University of Windsor provided network, T the company.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.21 2000/09/27 21:41:34 markus Exp $");
d52 1
d461 1
a462 1
	Authmethod *method;
d474 3
d479 1
d482 2
a483 1
Authmethod *authmethod_get(char *auth_list);
d494 8
d538 4
a541 1
	authctxt.method = NULL;
d544 1
a544 8
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt.server_user);
	packet_put_cstring(authctxt.service);
	packet_put_cstring("none");
	packet_send();
	packet_write_wait();

	authmethod_clear();
d554 1
a554 1
	debug("ssh-userauth2 successfull");
a575 1
	int dlen;
d580 1
a580 1
	authlist = packet_get_string(&dlen);
a588 1
		/* try old method or get next method */
d592 1
d594 1
a594 1
			debug2("we sent a packet, wait for reply");
d605 13
d636 1
a636 1
	packet_put_cstring("password");
d654 1
d673 2
a674 2
	buffer_put_cstring(&b, "publickey");
	buffer_put_char(&b, 1);
d694 2
a695 2
		buffer_put_cstring(&b, "publickey");
		buffer_put_char(&b, 1);
d819 86
d991 1
d1006 1
d1008 2
a1009 1
		if (method != NULL && authmethod_is_enabled(method))
d1011 1
d1013 1
d1019 1
a1019 1
	if (name != NULL) {
@


1.21
log
@use key_type()
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.20 2000/09/21 11:25:07 markus Exp $");
d55 3
d71 83
a153 2
ssh_kex_dh(Kex *kex, char *host, struct sockaddr *hostaddr,
    Buffer *client_kexinit, Buffer *server_kexinit)
d203 1
a203 1
	    options.user_hostfile2, options.system_hostfile2);
d273 21
d295 2
a296 1
ssh_kex2(char *host, struct sockaddr *hostaddr)
d298 24
a321 4
	int i, plen;
	Kex *kex;
	Buffer *client_kexinit, *server_kexinit;
	char *sprop[PROPOSAL_MAX];
d323 3
a325 19
	if (options.ciphers != NULL) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] = options.ciphers;
	} else if (options.cipher == SSH_CIPHER_3DES) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] =
		    (char *) cipher_name(SSH_CIPHER_3DES_CBC);
	} else if (options.cipher == SSH_CIPHER_BLOWFISH) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] =
		    (char *) cipher_name(SSH_CIPHER_BLOWFISH_CBC);
	}
	if (options.compression) {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] = "zlib";
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "zlib";
	} else {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] = "none";
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none";
	}
d327 1
a327 4
	/* buffers with raw kexinit messages */
	server_kexinit = xmalloc(sizeof(*server_kexinit));
	buffer_init(server_kexinit);
	client_kexinit = kex_init(myproposal);
d329 1
a329 5
	/* algorithm negotiation */
	kex_exchange_kexinit(client_kexinit, server_kexinit, sprop);
	kex = kex_choose_conf(myproposal, sprop, 0);
	for (i = 0; i < PROPOSAL_MAX; i++)
		xfree(sprop[i]);
d331 1
a331 2
	/* server authentication and session key agreement */
	ssh_kex_dh(kex, host, hostaddr, client_kexinit, server_kexinit);
d333 8
a340 4
	buffer_free(client_kexinit);
	buffer_free(server_kexinit);
	xfree(client_kexinit);
	xfree(server_kexinit);
d342 10
a351 4
	debug("Wait SSH2_MSG_NEWKEYS.");
	packet_read_expect(&plen, SSH2_MSG_NEWKEYS);
	packet_done();
	debug("GOT SSH2_MSG_NEWKEYS.");
d353 4
a356 2
	debug("send SSH2_MSG_NEWKEYS.");
	packet_start(SSH2_MSG_NEWKEYS);
a358 1
	debug("done: send SSH2_MSG_NEWKEYS.");
d360 65
d426 4
a429 5
	/* send 1st encrypted/maced/compressed message */
	packet_start(SSH2_MSG_IGNORE);
	packet_put_cstring("markus");
	packet_send();
	packet_write_wait();
d431 11
a441 1
	debug("done: KEX2.");
@


1.20
log
@change login logic in ssh2, allows plugin of other auth methods
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.19 2000/09/17 15:38:58 markus Exp $");
d537 2
a538 2
		     "Enter passphrase for DSA key '%.100s': ",
		     filename);
@


1.19
log
@fix DEBUG_KEXDH
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.18 2000/09/07 20:27:55 deraadt Exp $");
d52 1
d260 148
d409 1
a409 1
ssh2_try_passwd(const char *server_user, const char *host, const char *service)
d422 1
a422 1
	    server_user, host);
d425 2
a426 2
	packet_put_cstring(server_user);
	packet_put_cstring(service);
a436 5
typedef int sign_fn(
    Key *key,
    unsigned char **sigp, int *lenp,
    unsigned char *data, int datalen);

d438 1
a438 2
ssh2_sign_and_send_pubkey(Key *k, sign_fn *do_sign,
    const char *server_user, const char *host, const char *service)
d458 1
a458 1
	buffer_put_cstring(&b, server_user);
d462 1
a462 1
	    service);
d469 1
a469 1
	ret = do_sign(k, &signature, &slen, buffer_ptr(&b), buffer_len(&b));
d482 2
a483 2
		buffer_put_cstring(&b, server_user);
		buffer_put_cstring(&b, service);
d496 1
a496 1
		fatal("ssh2_try_pubkey: internal error");
d511 7
d519 1
a519 2
ssh2_try_pubkey(char *filename,
    const char *server_user, const char *host, const char *service)
d522 1
a522 1
	int ret = 0;
d539 15
a553 4
		passphrase = read_passphrase(prompt, 0);
		success = load_private_key(filename, passphrase, k, NULL);
		memset(passphrase, 0, strlen(passphrase));
		xfree(passphrase);
d559 1
a559 1
	ret = ssh2_sign_and_send_pubkey(k, dsa_sign, server_user, host, service);
d564 2
a565 3
int agent_sign(
    Key *key,
    unsigned char **sigp, int *lenp,
d568 1
a568 7
	int ret = -1;
	AuthenticationConnection *ac = ssh_get_authentication_connection();
	if (ac != NULL) {
		ret = ssh_agent_sign(ac, key, sigp, lenp, data, datalen);
		ssh_close_authentication_connection(ac);
	}
	return ret;
d572 1
a572 2
ssh2_try_agent(AuthenticationConnection *ac,
    const char *server_user, const char *host, const char *service)
d580 2
a581 2
		k = ssh_get_first_identity(ac, &comment, 2);
		called ++;
d583 1
a583 1
		k = ssh_get_next_identity(ac, &comment, 2);
d585 2
a586 1
	if (k == NULL)
d588 1
d591 1
a591 1
	ret = ssh2_sign_and_send_pubkey(k, agent_sign, server_user, host, service);
d596 29
d626 39
a664 1
ssh_userauth2(const char *server_user, char *host)
d666 8
a673 9
	AuthenticationConnection *ac = ssh_get_authentication_connection();
	int type;
	int plen;
	int sent;
	unsigned int dlen;
	int partial;
	int i = 0;
	char *auths;
	char *service = "ssh-connection";		/* service name */
d675 7
a681 5
	debug("send SSH2_MSG_SERVICE_REQUEST");
	packet_start(SSH2_MSG_SERVICE_REQUEST);
	packet_put_cstring("ssh-userauth");
	packet_send();
	packet_write_wait();
d683 23
a705 3
	type = packet_read(&plen);
	if (type != SSH2_MSG_SERVICE_ACCEPT) {
		fatal("denied SSH2_MSG_SERVICE_ACCEPT: %d", type);
d707 6
a712 7
	if (packet_remaining() > 0) {
		char *reply = packet_get_string(&plen);
		debug("service_accept: %s", reply);
		xfree(reply);
	} else {
		/* payload empty for ssh-2.0.13 ?? */
		debug("buggy server: service_accept w/o service");
a713 2
	packet_done();
	debug("got SSH2_MSG_SERVICE_ACCEPT");
d715 2
a716 7
	/* INITIAL request for auth */
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(server_user);
	packet_put_cstring(service);
	packet_put_cstring("none");
	packet_send();
	packet_write_wait();
d718 8
a725 39
	for (;;) {
		sent = 0;
		type = packet_read(&plen);
		if (type == SSH2_MSG_USERAUTH_SUCCESS)
			break;
		if (type != SSH2_MSG_USERAUTH_FAILURE)
			fatal("access denied: %d", type);
		/* SSH2_MSG_USERAUTH_FAILURE means: try again */
		auths = packet_get_string(&dlen);
		debug("authentications that can continue: %s", auths);
		partial = packet_get_char();
		packet_done();
		if (partial)
			debug("partial success");
		if (options.dsa_authentication &&
		    strstr(auths, "publickey") != NULL) {
			if (ac != NULL)
				sent = ssh2_try_agent(ac,
				    server_user, host, service);
			if (!sent) {
				while (i < options.num_identity_files2) {
					sent = ssh2_try_pubkey(
					    options.identity_files2[i++],
					    server_user, host, service);
					if (sent)
						break;
				}
			}
		}
		if (!sent) {
			if (options.password_authentication &&
			    !options.batch_mode &&
			    strstr(auths, "password") != NULL) {
				sent = ssh2_try_passwd(server_user, host, service);
			}
		}
		if (!sent)
			fatal("Permission denied (%s).", auths);
		xfree(auths);
a726 4
	if (ac != NULL)
		ssh_close_authentication_connection(ac);
	packet_done();
	debug("ssh-userauth2 successfull");
@


1.18
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.17 2000/08/19 21:34:44 markus Exp $");
d70 3
d96 1
a96 1
	bignum_print(dh->p);
d98 1
a98 1
	bignum_print(dh->g);
d100 1
a100 1
	bignum_print(dh->pub_key);
d128 1
a128 1
	bignum_print(dh_server_pub);
@


1.17
log
@add SSH2/DSA support to the agent and some other DSA related cleanups.
(note that we cannot talk to ssh.com's ssh2 agents)
@
text
@a11 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Markus Friedl.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.16 2000/07/16 08:27:22 markus Exp $");
@


1.16
log
@make ssh-add accept dsa keys (the agent does not)
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.14 2000/06/19 00:50:11 markus Exp $");
d57 1
d295 1
a295 1
void
d303 1
d328 6
a333 2
	do_sign(k, &signature, &slen, buffer_ptr(&b), buffer_len(&b));
	key_free(k); /* XXX */
d366 2
d375 1
d401 41
a441 2
	ssh2_sign_and_send_pubkey(k, dsa_sign, server_user, host, service);
	return 1;
d447 1
d502 2
a503 3
			while (i < options.num_identity_files2) {
				sent = ssh2_try_pubkey(
				    options.identity_files2[i++],
d505 8
a512 2
				if (sent)
					break;
d526 2
@


1.15
log
@missing free; nuke old comment
@
text
@d289 7
a295 2
int
ssh2_try_pubkey(char *filename,
a298 1
	Key *k;
a300 1
	struct stat st;
a302 23
	if (stat(filename, &st) != 0) {
		debug("key does not exist: %s", filename);
		return 0;
	}
	debug("try pubkey: %s", filename);

	k = key_new(KEY_DSA);
	if (!load_private_key(filename, "", k, NULL)) {
		int success = 0;
		char *passphrase;
		char prompt[300];
		snprintf(prompt, sizeof prompt,
		     "Enter passphrase for DSA key '%.100s': ",
		     filename);
		passphrase = read_passphrase(prompt, 0);
		success = load_private_key(filename, passphrase, k, NULL);
		memset(passphrase, 0, strlen(passphrase));
		xfree(passphrase);
		if (!success) {
			key_free(k);
			return 0;
		}
	}
d326 2
a327 2
	dsa_sign(k, &signature, &slen, buffer_ptr(&b), buffer_len(&b));
	key_free(k);
d360 33
@


1.14
log
@make userauth+pubkey interop with ssh.com-2.2.0
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.13 2000/06/02 02:00:19 todd Exp $");
d318 2
a319 1
		if (!success)
d321 1
a351 1
		/* e.g. ssh-2.0.13: data-to-be-signed != data-on-the-wire */
@


1.13
log
@teach protocol v2 to count login failures properly and also enable an
explanation of why the password prompt comes up again like v1; this is NOT
crypto
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.12 2000/05/31 09:20:38 markus Exp $");
d298 1
d325 7
a331 1
	buffer_append(&b, session_id2, session_id2_len);
d367 1
a367 1
	if (buffer_len(&b) < session_id2_len + 1)
d369 1
a369 1
	buffer_consume(&b, session_id2_len + 1);
@


1.12
log
@typo, unused
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.11 2000/05/25 20:45:20 markus Exp $");
d267 1
a267 1
	if (attempt++ > options.number_of_password_prompts)
d269 3
@


1.11
log
@split kexinit/kexdh, factor out common code
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.10 2000/05/08 17:42:25 markus Exp $");
a73 1
	int i;
@


1.10
log
@bug compat w/ ssh-2.0.13 x11, split out bugs
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.9 2000/05/08 17:12:16 markus Exp $");
d71 2
a72 1
ssh_kex2(char *host, struct sockaddr *hostaddr)
d74 2
a75 6
	Kex *kex;
	char *cprop[PROPOSAL_MAX];
	char *sprop[PROPOSAL_MAX];
	Buffer *client_kexinit;
	Buffer *server_kexinit;
	int payload_len, dlen;
a76 1
	char *ptr;
a84 1
	int i;
a87 60
/* KEXINIT */

	debug("Sending KEX init.");
	if (options.ciphers != NULL) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] = options.ciphers;
	} else if (options.cipher == SSH_CIPHER_3DES) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] =
		    cipher_name(SSH_CIPHER_3DES_CBC);
	} else if (options.cipher == SSH_CIPHER_BLOWFISH) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] =
		    cipher_name(SSH_CIPHER_BLOWFISH_CBC);
	}
	if (options.compression) {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] = "zlib";
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "zlib";
	} else {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] = "none";
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none";
	}
	for (i = 0; i < PROPOSAL_MAX; i++)
		cprop[i] = xstrdup(myproposal[i]);

	client_kexinit = kex_init(cprop);
	packet_start(SSH2_MSG_KEXINIT);
	packet_put_raw(buffer_ptr(client_kexinit), buffer_len(client_kexinit));	
	packet_send();
	packet_write_wait();

	debug("done");

	packet_read_expect(&payload_len, SSH2_MSG_KEXINIT);

	/* save payload for session_id */
	server_kexinit = xmalloc(sizeof(*server_kexinit));
	buffer_init(server_kexinit);
	ptr = packet_get_raw(&payload_len);
	buffer_append(server_kexinit, ptr, payload_len);

	/* skip cookie */
	for (i = 0; i < 16; i++)
		(void) packet_get_char();
	/* kex init proposal strings */
	for (i = 0; i < PROPOSAL_MAX; i++) {
		sprop[i] = packet_get_string(NULL);
		debug("got kexinit string: %s", sprop[i]);
	}
	i = (int) packet_get_char();
	debug("first kex follow == %d", i);
	i = packet_get_int();
	debug("reserved == %d", i);
	packet_done();

	debug("done read kexinit");
	kex = kex_choose_conf(cprop, sprop, 0);

/* KEXDH */

a88 1

d109 1
a109 1
	packet_read_expect(&payload_len, SSH2_MSG_KEXDH_REPLY);
d170 1
a170 4
	buffer_free(client_kexinit);
	buffer_free(server_kexinit);
	xfree(client_kexinit);
	xfree(server_kexinit);
a183 3
	/* have keys, free DH */
	DH_free(dh);

d188 48
d238 1
a238 1
	packet_read_expect(&payload_len, SSH2_MSG_NEWKEYS);
d257 1
@


1.10.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.13 2000/06/02 02:00:19 todd Exp $");
d71 1
a71 2
ssh_kex_dh(Kex *kex, char *host, struct sockaddr *hostaddr,
    Buffer *client_kexinit, Buffer *server_kexinit)
d73 6
a78 1
	int plen, dlen;
d80 1
d89 1
d93 60
d154 1
d175 1
a175 1
	packet_read_expect(&plen, SSH2_MSG_KEXDH_REPLY);
d236 4
a239 1
	DH_free(dh);
d253 3
a259 48
}

void
ssh_kex2(char *host, struct sockaddr *hostaddr)
{
	int i, plen;
	Kex *kex;
	Buffer *client_kexinit, *server_kexinit;
	char *sprop[PROPOSAL_MAX];

	if (options.ciphers != NULL) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] = options.ciphers;
	} else if (options.cipher == SSH_CIPHER_3DES) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] =
		    (char *) cipher_name(SSH_CIPHER_3DES_CBC);
	} else if (options.cipher == SSH_CIPHER_BLOWFISH) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] =
		    (char *) cipher_name(SSH_CIPHER_BLOWFISH_CBC);
	}
	if (options.compression) {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] = "zlib";
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "zlib";
	} else {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] = "none";
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none";
	}

	/* buffers with raw kexinit messages */
	server_kexinit = xmalloc(sizeof(*server_kexinit));
	buffer_init(server_kexinit);
	client_kexinit = kex_init(myproposal);

	/* algorithm negotiation */
	kex_exchange_kexinit(client_kexinit, server_kexinit, sprop);
	kex = kex_choose_conf(myproposal, sprop, 0);
	for (i = 0; i < PROPOSAL_MAX; i++)
		xfree(sprop[i]);

	/* server authentication and session key agreement */
	ssh_kex_dh(kex, host, hostaddr, client_kexinit, server_kexinit);

	buffer_free(client_kexinit);
	buffer_free(server_kexinit);
	xfree(client_kexinit);
	xfree(server_kexinit);
d262 1
a262 1
	packet_read_expect(&plen, SSH2_MSG_NEWKEYS);
a280 1

d291 1
a291 1
	if (attempt++ >= options.number_of_password_prompts)
a292 3

	if(attempt != 1)
		error("Permission denied, please try again.");
@


1.10.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.17 2000/08/19 21:34:44 markus Exp $");
a56 1
#include "authfd.h"
a288 5
typedef int sign_fn(
    Key *key,
    unsigned char **sigp, int *lenp,
    unsigned char *data, int datalen);

d290 1
a290 1
ssh2_sign_and_send_pubkey(Key *k, sign_fn *do_sign,
d294 1
d297 7
a303 2
	int skip = 0;
	int ret = -1;
d305 15
d324 1
a324 7
	if (datafellows & SSH_COMPAT_SESSIONID_ENCODING) {
		buffer_put_string(&b, session_id2, session_id2_len);
		skip = buffer_len(&b);
	} else {
		buffer_append(&b, session_id2, session_id2_len);
		skip = session_id2_len; 
	}
d337 2
a338 6
	ret = do_sign(k, &signature, &slen, buffer_ptr(&b), buffer_len(&b));
	if (ret == -1) {
		xfree(blob);
		buffer_free(&b);
		return 0;
	}
d343 1
d360 1
a360 1
	if (buffer_len(&b) < skip + 1)
d362 1
a362 1
	buffer_consume(&b, skip + 1);
a371 1

a374 74
int
ssh2_try_pubkey(char *filename,
    const char *server_user, const char *host, const char *service)
{
	Key *k;
	int ret = 0;
	struct stat st;

	if (stat(filename, &st) != 0) {
		debug("key does not exist: %s", filename);
		return 0;
	}
	debug("try pubkey: %s", filename);

	k = key_new(KEY_DSA);
	if (!load_private_key(filename, "", k, NULL)) {
		int success = 0;
		char *passphrase;
		char prompt[300];
		snprintf(prompt, sizeof prompt,
		     "Enter passphrase for DSA key '%.100s': ",
		     filename);
		passphrase = read_passphrase(prompt, 0);
		success = load_private_key(filename, passphrase, k, NULL);
		memset(passphrase, 0, strlen(passphrase));
		xfree(passphrase);
		if (!success) {
			key_free(k);
			return 0;
		}
	}
	ret = ssh2_sign_and_send_pubkey(k, dsa_sign, server_user, host, service);
	key_free(k);
	return ret;
}

int agent_sign(
    Key *key,
    unsigned char **sigp, int *lenp,
    unsigned char *data, int datalen)
{
	int ret = -1;
	AuthenticationConnection *ac = ssh_get_authentication_connection();
	if (ac != NULL) {
		ret = ssh_agent_sign(ac, key, sigp, lenp, data, datalen);
		ssh_close_authentication_connection(ac);
	}
	return ret;
}

int
ssh2_try_agent(AuthenticationConnection *ac,
    const char *server_user, const char *host, const char *service)
{
	static int called = 0;
	char *comment;
	Key *k;
	int ret;

	if (called == 0) {
		k = ssh_get_first_identity(ac, &comment, 2);
		called ++;
	} else {
		k = ssh_get_next_identity(ac, &comment, 2);
	}
	if (k == NULL)
		return 0;
	debug("trying DSA agent key %s", comment);
	xfree(comment);
	ret = ssh2_sign_and_send_pubkey(k, agent_sign, server_user, host, service);
	key_free(k);
	return ret;
}

a377 1
	AuthenticationConnection *ac = ssh_get_authentication_connection();
d432 3
a434 2
			if (ac != NULL)
				sent = ssh2_try_agent(ac,
d436 2
a437 8
			if (!sent) {
				while (i < options.num_identity_files2) {
					sent = ssh2_try_pubkey(
					    options.identity_files2[i++],
					    server_user, host, service);
					if (sent)
						break;
				}
a450 2
	if (ac != NULL)
		ssh_close_authentication_connection(ac);
@


1.10.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d12 5
d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.27 2000/10/19 16:45:16 provos Exp $");
d45 1
a56 2
#include "cli.h"
#include "dispatch.h"
a58 3
void ssh_dh1_client(Kex *, char *, struct sockaddr *, Buffer *, Buffer *);
void ssh_dhgex_client(Kex *, char *, struct sockaddr *, Buffer *, Buffer *);

d72 2
a73 1
ssh_kex2(char *host, struct sockaddr *hostaddr)
a74 86
	int i, plen;
	Kex *kex;
	Buffer *client_kexinit, *server_kexinit;
	char *sprop[PROPOSAL_MAX];

	if (options.ciphers == NULL) {
		if (options.cipher == SSH_CIPHER_3DES) {
			options.ciphers = "3des-cbc";
		} else if (options.cipher == SSH_CIPHER_BLOWFISH) {
			options.ciphers = "blowfish-cbc";
		} else if (options.cipher == SSH_CIPHER_DES) {
			fatal("cipher DES not supported for protocol version 2");
		}
	}
	if (options.ciphers != NULL) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] = options.ciphers;
	}
	if (options.compression) {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] = "zlib";
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "zlib";
	} else {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] = "none";
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none";
	}

	/* buffers with raw kexinit messages */
	server_kexinit = xmalloc(sizeof(*server_kexinit));
	buffer_init(server_kexinit);
	client_kexinit = kex_init(myproposal);

	/* algorithm negotiation */
	kex_exchange_kexinit(client_kexinit, server_kexinit, sprop);
	kex = kex_choose_conf(myproposal, sprop, 0);
	for (i = 0; i < PROPOSAL_MAX; i++)
		xfree(sprop[i]);

	/* server authentication and session key agreement */
	switch(kex->kex_type) {
	case DH_GRP1_SHA1:
		ssh_dh1_client(kex, host, hostaddr,
			       client_kexinit, server_kexinit);
		break;
	case DH_GEX_SHA1:
		ssh_dhgex_client(kex, host, hostaddr, client_kexinit,
				 server_kexinit);
		break;
	default:
		fatal("Unsupported key exchange %d", kex->kex_type);
	}

	buffer_free(client_kexinit);
	buffer_free(server_kexinit);
	xfree(client_kexinit);
	xfree(server_kexinit);

	debug("Wait SSH2_MSG_NEWKEYS.");
	packet_read_expect(&plen, SSH2_MSG_NEWKEYS);
	packet_done();
	debug("GOT SSH2_MSG_NEWKEYS.");

	debug("send SSH2_MSG_NEWKEYS.");
	packet_start(SSH2_MSG_NEWKEYS);
	packet_send();
	packet_write_wait();
	debug("done: send SSH2_MSG_NEWKEYS.");

#ifdef DEBUG_KEXDH
	/* send 1st encrypted/maced/compressed message */
	packet_start(SSH2_MSG_IGNORE);
	packet_put_cstring("markus");
	packet_send();
	packet_write_wait();
#endif
	debug("done: KEX2.");
}

/* diffie-hellman-group1-sha1 */

void
ssh_dh1_client(Kex *kex, char *host, struct sockaddr *hostaddr, 
	       Buffer *client_kexinit, Buffer *server_kexinit)
{
#ifdef DEBUG_KEXDH
	int i;
#endif
d98 1
a98 1
	BN_print_fp(stderr, dh->p);
d100 1
a100 1
	BN_print_fp(stderr, dh->g);
d102 1
a102 1
	BN_print_fp(stderr, dh->pub_key);
d120 1
a120 1
		       options.user_hostfile2, options.system_hostfile2);
d130 1
a130 1
	BN_print_fp(stderr, dh_server_pub);
a189 21
/* diffie-hellman-group-exchange-sha1 */

/*
 * Estimates the group order for a Diffie-Hellman group that has an
 * attack complexity approximately the same as O(2**bits).  Estimate
 * with:  O(exp(1.9223 * (ln q)^(1/3) (ln ln q)^(2/3)))
 */

int
dh_estimate(int bits)
{
	
	if (bits < 64)
		return (512);	/* O(2**63) */
	if (bits < 128)
		return (1024);	/* O(2**86) */
	if (bits < 192)
		return (2048);	/* O(2**116) */
	return (4096);		/* O(2**156) */
}

d191 1
a191 2
ssh_dhgex_client(Kex *kex, char *host, struct sockaddr *hostaddr,
		 Buffer *client_kexinit, Buffer *server_kexinit)
d193 4
a196 16
#ifdef DEBUG_KEXDH
	int i;
#endif
	int plen, dlen;
	unsigned int klen, kout;
	char *signature = NULL;
	unsigned int slen, nbits;
	char *server_host_key_blob = NULL;
	Key *server_host_key;
	unsigned int sbloblen;
	DH *dh;
	BIGNUM *dh_server_pub = 0;
	BIGNUM *shared_secret = 0;
	BIGNUM *p = 0, *g = 0;
	unsigned char *kbuf;
	unsigned char *hash;
d198 19
a216 1
	nbits = dh_estimate(kex->enc[MODE_OUT].cipher->key_len * 8);
d218 4
a221 5
	debug("Sending SSH2_MSG_KEX_DH_GEX_REQUEST.");
	packet_start(SSH2_MSG_KEX_DH_GEX_REQUEST);
	packet_put_int(nbits);
	packet_send();
	packet_write_wait();
d223 5
a227 3
#ifdef DEBUG_KEXDH
	fprintf(stderr, "\nnbits = %d", nbits);
#endif
d229 2
a230 1
	debug("Wait SSH2_MSG_KEX_DH_GEX_GROUP.");
d232 4
a235 1
	packet_read_expect(&plen, SSH2_MSG_KEX_DH_GEX_GROUP);
d237 4
a240 1
	debug("Got SSH2_MSG_KEX_DH_GEX_GROUP.");
d242 5
a246 8
	if ((p = BN_new()) == NULL)
		fatal("BN_new");
	packet_get_bignum2(p, &dlen);
	if ((g = BN_new()) == NULL)
		fatal("BN_new");
	packet_get_bignum2(g, &dlen);
	if ((dh = dh_new_group(g, p)) == NULL)
		fatal("dh_new_group");
d249 3
a251 14
	fprintf(stderr, "\np= ");
	BN_print_fp(stderr, dh->p);
	fprintf(stderr, "\ng= ");
	BN_print_fp(stderr, dh->g);
	fprintf(stderr, "\npub= ");
	BN_print_fp(stderr, dh->pub_key);
	fprintf(stderr, "\n");
	DHparams_print_fp(stderr, dh);
#endif

	debug("Sending SSH2_MSG_KEX_DH_GEX_INIT.");
	/* generate and send 'e', client DH public key */
	packet_start(SSH2_MSG_KEX_DH_GEX_INIT);
	packet_put_bignum2(dh->pub_key);
a253 27

	debug("Wait SSH2_MSG_KEX_DH_GEX_REPLY.");

	packet_read_expect(&plen, SSH2_MSG_KEX_DH_GEX_REPLY);

	debug("Got SSH2_MSG_KEXDH_REPLY.");

	/* key, cert */
	server_host_key_blob = packet_get_string(&sbloblen);
	server_host_key = dsa_key_from_blob(server_host_key_blob, sbloblen);
	if (server_host_key == NULL)
		fatal("cannot decode server_host_key_blob");

	check_host_key(host, hostaddr, server_host_key,
		       options.user_hostfile2, options.system_hostfile2);

	/* DH paramter f, server public DH key */
	dh_server_pub = BN_new();
	if (dh_server_pub == NULL)
		fatal("dh_server_pub == NULL");
	packet_get_bignum2(dh_server_pub, &dlen);

#ifdef DEBUG_KEXDH
	fprintf(stderr, "\ndh_server_pub= ");
	BN_print_fp(stderr, dh_server_pub);
	fprintf(stderr, "\n");
	debug("bits %d", BN_num_bits(dh_server_pub));
d255 1
a255 55

	/* signed H */
	signature = packet_get_string(&slen);
	packet_done();

	if (!dh_pub_is_valid(dh, dh_server_pub))
		packet_disconnect("bad server public DH value");

	klen = DH_size(dh);
	kbuf = xmalloc(klen);
	kout = DH_compute_key(kbuf, dh_server_pub, dh);
#ifdef DEBUG_KEXDH
	debug("shared secret: len %d/%d", klen, kout);
	fprintf(stderr, "shared secret == ");
	for (i = 0; i< kout; i++)
		fprintf(stderr, "%02x", (kbuf[i])&0xff);
	fprintf(stderr, "\n");
#endif
	shared_secret = BN_new();

	BN_bin2bn(kbuf, kout, shared_secret);
	memset(kbuf, 0, klen);
	xfree(kbuf);

	/* calc and verify H */
	hash = kex_hash_gex(
	    client_version_string,
	    server_version_string,
	    buffer_ptr(client_kexinit), buffer_len(client_kexinit),
	    buffer_ptr(server_kexinit), buffer_len(server_kexinit),
	    server_host_key_blob, sbloblen,
	    nbits, dh->p, dh->g, 
	    dh->pub_key,
	    dh_server_pub,
	    shared_secret
	);
	xfree(server_host_key_blob);
	DH_free(dh);
#ifdef DEBUG_KEXDH
	fprintf(stderr, "hash == ");
	for (i = 0; i< 20; i++)
		fprintf(stderr, "%02x", (hash[i])&0xff);
	fprintf(stderr, "\n");
#endif
	if (dsa_verify(server_host_key, (unsigned char *)signature, slen, hash, 20) != 1)
		fatal("dsa_verify failed for server_host_key");
	key_free(server_host_key);

	kex_derive_keys(kex, hash, shared_secret);
	packet_set_kex(kex);

	/* save session id */
	session_id2_len = 20;
	session_id2 = xmalloc(session_id2_len);
	memcpy(session_id2, hash, session_id2_len);
a260 156

typedef struct Authctxt Authctxt;
typedef struct Authmethod Authmethod;

typedef int sign_cb_fn(
    Authctxt *authctxt, Key *key,
    unsigned char **sigp, int *lenp, unsigned char *data, int datalen);

struct Authctxt {
	const char *server_user;
	const char *host;
	const char *service;
	AuthenticationConnection *agent;
	Authmethod *method;
	int success;
};
struct Authmethod {
	char	*name;		/* string to compare against server's list */
	int	(*userauth)(Authctxt *authctxt);
	int	*enabled;	/* flag in option struct that enables method */
	int	*batch_flag;	/* flag in option struct that disables method */
};

void	input_userauth_success(int type, int plen, void *ctxt);
void	input_userauth_failure(int type, int plen, void *ctxt);
void	input_userauth_error(int type, int plen, void *ctxt);
void	input_userauth_info_req(int type, int plen, void *ctxt);

int	userauth_none(Authctxt *authctxt);
int	userauth_pubkey(Authctxt *authctxt);
int	userauth_passwd(Authctxt *authctxt);
int	userauth_kbdint(Authctxt *authctxt);

void	authmethod_clear();
Authmethod *authmethod_get(char *authlist);
Authmethod *authmethod_lookup(const char *name);

Authmethod authmethods[] = {
	{"publickey",
		userauth_pubkey,
		&options.dsa_authentication,
		NULL},
	{"password",
		userauth_passwd,
		&options.password_authentication,
		&options.batch_mode},
	{"keyboard-interactive",
		userauth_kbdint,
		&options.kbd_interactive_authentication,
		&options.batch_mode},
	{"none",
		userauth_none,
		NULL,
		NULL},
	{NULL, NULL, NULL, NULL}
};

void
ssh_userauth2(const char *server_user, char *host)
{
	Authctxt authctxt;
	int type;
	int plen;

	debug("send SSH2_MSG_SERVICE_REQUEST");
	packet_start(SSH2_MSG_SERVICE_REQUEST);
	packet_put_cstring("ssh-userauth");
	packet_send();
	packet_write_wait();
	type = packet_read(&plen);
	if (type != SSH2_MSG_SERVICE_ACCEPT) {
		fatal("denied SSH2_MSG_SERVICE_ACCEPT: %d", type);
	}
	if (packet_remaining() > 0) {
		char *reply = packet_get_string(&plen);
		debug("service_accept: %s", reply);
		xfree(reply);
		packet_done();
	} else {
		debug("buggy server: service_accept w/o service");
	}
	packet_done();
	debug("got SSH2_MSG_SERVICE_ACCEPT");

	/* setup authentication context */
	authctxt.agent = ssh_get_authentication_connection();
	authctxt.server_user = server_user;
	authctxt.host = host;
	authctxt.service = "ssh-connection";		/* service name */
	authctxt.success = 0;
	authctxt.method = authmethod_lookup("none");
	if (authctxt.method == NULL)
		fatal("ssh_userauth2: internal error: cannot send userauth none request");
	authmethod_clear();

	/* initial userauth request */
	userauth_none(&authctxt);

	dispatch_init(&input_userauth_error);
	dispatch_set(SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);
	dispatch_set(SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);
	dispatch_run(DISPATCH_BLOCK, &authctxt.success, &authctxt);	/* loop until success */

	if (authctxt.agent != NULL)
		ssh_close_authentication_connection(authctxt.agent);

	debug("ssh-userauth2 successfull: method %s", authctxt.method->name);
}
void
input_userauth_error(int type, int plen, void *ctxt)
{
	fatal("input_userauth_error: bad message during authentication");
}
void
input_userauth_success(int type, int plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	if (authctxt == NULL)
		fatal("input_userauth_success: no authentication context");
	authctxt->success = 1;			/* break out */
}
void
input_userauth_failure(int type, int plen, void *ctxt)
{
	Authmethod *method = NULL;
	Authctxt *authctxt = ctxt;
	char *authlist = NULL;
	int partial;

	if (authctxt == NULL)
		fatal("input_userauth_failure: no authentication context");

	authlist = packet_get_string(NULL);
	partial = packet_get_char();
	packet_done();

	if (partial != 0)
		debug("partial success");
	debug("authentications that can continue: %s", authlist);

	for (;;) {
		method = authmethod_get(authlist);
		if (method == NULL)
                        fatal("Unable to find an authentication method");
		authctxt->method = method;
		if (method->userauth(authctxt) != 0) {
			debug2("we sent a %s packet, wait for reply", method->name);
			break;
		} else {
			debug2("we did not send a packet, disable method");
			method->enabled = NULL;
		}
	}	
	xfree(authlist);
}

d262 1
a262 14
userauth_none(Authctxt *authctxt)
{
	/* initial userauth request */
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
	packet_send();
	packet_write_wait();
	return 1;
}

int
userauth_passwd(Authctxt *authctxt)
d275 1
a275 1
	    authctxt->server_user, authctxt->host);
d278 3
a280 3
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
d290 5
d296 2
a297 1
sign_and_send_pubkey(Authctxt *authctxt, Key *k, sign_cb_fn *sign_callback)
a303 1
	int have_sig = 1;
d309 4
a312 1
	if (datafellows & SSH_OLD_SESSIONID) {
a314 3
	} else {
		buffer_put_string(&b, session_id2, session_id2_len);
		skip = buffer_len(&b);
d317 1
a317 1
	buffer_put_cstring(&b, authctxt->server_user);
d321 3
a323 3
	    authctxt->service);
	buffer_put_cstring(&b, authctxt->method->name);
	buffer_put_char(&b, have_sig);
d328 1
a328 1
	ret = (*sign_callback)(authctxt, k, &signature, &slen, buffer_ptr(&b), buffer_len(&b));
d341 4
a344 4
		buffer_put_cstring(&b, authctxt->server_user);
		buffer_put_cstring(&b, authctxt->service);
		buffer_put_cstring(&b, authctxt->method->name);
		buffer_put_char(&b, have_sig);
d355 1
a355 1
		fatal("userauth_pubkey: internal error");
a369 7
/* sign callback */
int dsa_sign_cb(Authctxt *authctxt, Key *key, unsigned char **sigp, int *lenp,
    unsigned char *data, int datalen)
{
	return dsa_sign(key, sigp, lenp, data, datalen);
}

d371 2
a372 1
userauth_pubkey_identity(Authctxt *authctxt, char *filename)
d375 1
a375 1
	int i, ret, try_next;
d390 6
a395 17
		     "Enter passphrase for %s key '%.100s': ",
		     key_type(k), filename);
		for (i = 0; i < options.number_of_password_prompts; i++) {
			passphrase = read_passphrase(prompt, 0);
			if (strcmp(passphrase, "") != 0) {
				success = load_private_key(filename, passphrase, k, NULL);
				try_next = 0;
			} else {
				debug2("no passphrase given, try next key");
				try_next = 1;
			}
			memset(passphrase, 0, strlen(passphrase));
			xfree(passphrase);
			if (success || try_next)
				break;
			debug2("bad passphrase given, try again...");
		}
d401 1
a401 1
	ret = sign_and_send_pubkey(authctxt, k, dsa_sign_cb);
d406 3
a408 2
/* sign callback */
int agent_sign_cb(Authctxt *authctxt, Key *key, unsigned char **sigp, int *lenp,
d411 7
a417 1
	return ssh_agent_sign(authctxt->agent, key, sigp, lenp, data, datalen);
d421 2
a422 1
userauth_pubkey_agent(Authctxt *authctxt)
d430 2
a431 2
		k = ssh_get_first_identity(authctxt->agent, &comment, 2);
		called = 1;
d433 1
a433 1
		k = ssh_get_next_identity(authctxt->agent, &comment, 2);
d435 1
a435 2
	if (k == NULL) {
		debug2("no more DSA keys from agent");
a436 1
	}
d439 1
a439 1
	ret = sign_and_send_pubkey(authctxt, k, agent_sign_cb);
d444 2
a445 2
int
userauth_pubkey(Authctxt *authctxt)
d447 9
a455 2
	static int idx = 0;
	int sent = 0;
d457 3
a459 26
	if (authctxt->agent != NULL)
		sent = userauth_pubkey_agent(authctxt);
	while (sent == 0 && idx < options.num_identity_files2)
		sent = userauth_pubkey_identity(authctxt, options.identity_files2[idx++]);
	return sent;
}

/*
 * Send userauth request message specifying keyboard-interactive method.
 */
int
userauth_kbdint(Authctxt *authctxt)
{
	static int attempt = 0;

	if (attempt++ >= options.number_of_password_prompts)
		return 0;

	debug2("userauth_kbdint");
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
	packet_put_cstring("");					/* lang */
	packet_put_cstring(options.kbd_interactive_devices ?
	    options.kbd_interactive_devices : "");
d463 11
a473 58
	dispatch_set(SSH2_MSG_USERAUTH_INFO_REQUEST, &input_userauth_info_req);
	return 1;
}

/*
 * parse SSH2_MSG_USERAUTH_INFO_REQUEST, prompt user and send
 * SSH2_MSG_USERAUTH_INFO_RESPONSE
 */
void
input_userauth_info_req(int type, int plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	char *name = NULL;
	char *inst = NULL;
	char *lang = NULL;
	char *prompt = NULL;
	char *response = NULL;
	unsigned int num_prompts, i;
	int echo = 0;

	debug2("input_userauth_info_req");

	if (authctxt == NULL)
		fatal("input_userauth_info_req: no authentication context");

	name = packet_get_string(NULL);
	inst = packet_get_string(NULL);
	lang = packet_get_string(NULL);

	if (strlen(name) > 0)
		cli_mesg(name);
	xfree(name);

	if (strlen(inst) > 0)
		cli_mesg(inst);
	xfree(inst);
	xfree(lang); 				/* unused */

	num_prompts = packet_get_int();
	/*
	 * Begin to build info response packet based on prompts requested.
	 * We commit to providing the correct number of responses, so if
	 * further on we run into a problem that prevents this, we have to
	 * be sure and clean this up and send a correct error response.
	 */
	packet_start(SSH2_MSG_USERAUTH_INFO_RESPONSE);
	packet_put_int(num_prompts);

	for (i = 0; i < num_prompts; i++) {
		prompt = packet_get_string(NULL);
		echo = packet_get_char();

		response = cli_prompt(prompt, echo);

		packet_put_cstring(response);
		memset(response, 0, strlen(response));
		xfree(response);
		xfree(prompt);
d475 2
a476 1
	packet_done(); /* done with parsing incoming message. */
d478 5
a484 1
}
d486 4
a489 104
/* find auth method */

#define	DELIM	","

static char *def_authlist = "publickey,password";
static char *authlist_current = NULL;	 /* clean copy used for comparison */
static char *authname_current = NULL;	 /* last used auth method */
static char *authlist_working = NULL;	 /* copy that gets modified by strtok_r() */
static char *authlist_state = NULL;	 /* state variable for strtok_r() */

/*
 * Before starting to use a new authentication method list sent by the
 * server, reset internal variables.  This should also be called when
 * finished processing server list to free resources.
 */
void
authmethod_clear()
{
	if (authlist_current != NULL) {
		xfree(authlist_current);
		authlist_current = NULL;
	}
	if (authlist_working != NULL) {
		xfree(authlist_working);
		authlist_working = NULL;
	}
	if (authname_current != NULL) {
		xfree(authname_current);
		authlist_state = NULL;
	}
	if (authlist_state != NULL)
		authlist_state = NULL;
	return;
}

/*
 * given auth method name, if configurable options permit this method fill
 * in auth_ident field and return true, otherwise return false.
 */
int
authmethod_is_enabled(Authmethod *method)
{
	if (method == NULL)
		return 0;
	/* return false if options indicate this method is disabled */
	if  (method->enabled == NULL || *method->enabled == 0)
		return 0;
	/* return false if batch mode is enabled but method needs interactive mode */
	if  (method->batch_flag != NULL && *method->batch_flag != 0)
		return 0;
	return 1;
}

Authmethod *
authmethod_lookup(const char *name)
{
	Authmethod *method = NULL;
	if (name != NULL)
		for (method = authmethods; method->name != NULL; method++)
			if (strcmp(name, method->name) == 0)
				return method;
	debug2("Unrecognized authentication method name: %s", name ? name : "NULL");
	return NULL;
}

/*
 * Given the authentication method list sent by the server, return the
 * next method we should try.  If the server initially sends a nil list,
 * use a built-in default list.  If the server sends a nil list after
 * previously sending a valid list, continue using the list originally
 * sent.
 */ 

Authmethod *
authmethod_get(char *authlist)
{
	char *name = NULL, *authname_old;
	Authmethod *method = NULL;
	
	/* Use a suitable default if we're passed a nil list.  */
	if (authlist == NULL || strlen(authlist) == 0)
		authlist = def_authlist;

	if (authlist_current == NULL || strcmp(authlist, authlist_current) != 0) {
		/* start over if passed a different list */
		debug3("start over, passed a different list");
		authmethod_clear();
		authlist_current = xstrdup(authlist);
		authlist_working = xstrdup(authlist);
		name = strtok_r(authlist_working, DELIM, &authlist_state);
	} else {
		/*
		 * try to use previously used authentication method
		 * or continue to use previously passed list
		 */
		name = (authname_current != NULL) ?
		    authname_current : strtok_r(NULL, DELIM, &authlist_state);
	}

	while (name != NULL) {
		debug3("authmethod_lookup %s", name);
		method = authmethod_lookup(name);
		if (method != NULL && authmethod_is_enabled(method)) {
			debug3("authmethod_is_enabled %s", name);
d491 23
d515 10
a524 2
		name = strtok_r(NULL, DELIM, &authlist_state);
		method = NULL;
d526 4
a529 14

	authname_old = authname_current;
	if (method != NULL) {
		debug("next auth method to try is %s", name);
		authname_current = xstrdup(name);
	} else {
		debug("no more auth methods to try");
		authname_current = NULL;
	}

	if (authname_old != NULL)
		xfree(authname_old);

	return (method);
@


1.10.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.48 2001/02/15 23:19:59 markus Exp $");
d29 2
a35 1
#include "ssh2.h"
d42 1
d44 1
a44 1
#include "cipher.h"
d48 1
a53 3
#include "log.h"
#include "readconf.h"
#include "readpass.h"
d67 1
a67 1
u_char *session_id2 = NULL;
d78 8
a85 3
	if (options.ciphers == (char *)-1) {
		log("No valid ciphers for protocol version 2 given, using defaults.");
		options.ciphers = NULL;
d92 1
a92 1
		myproposal[PROPOSAL_COMP_ALGS_CTOS] =
d95 1
a95 1
		myproposal[PROPOSAL_COMP_ALGS_CTOS] =
a97 4
	if (options.macs != NULL) {
		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
		myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;
	}
d153 1
a153 1
ssh_dh1_client(Kex *kex, char *host, struct sockaddr *hostaddr,
d160 1
a160 1
	u_int klen, kout;
d162 1
a162 1
	u_int slen;
d165 1
a165 1
	u_int sbloblen;
d169 2
a170 2
	u_char *kbuf;
	u_char *hash;
a174 1
	dh_gen_key(dh);
d199 1
a199 1
	server_host_key = key_from_blob(server_host_key_blob, sbloblen);
a254 1
	BN_free(dh_server_pub);
d261 2
a262 2
	if (key_verify(server_host_key, (u_char *)signature, slen, hash, 20) != 1)
		fatal("key_verify failed for server_host_key");
a263 1
	xfree(signature);
a265 1
	BN_clear_free(shared_secret);
d285 1
a285 1

d303 1
a303 1
	u_int klen, kout;
d305 1
a305 1
	u_int slen, nbits;
d308 1
a308 1
	u_int sbloblen;
d313 2
a314 2
	u_char *kbuf;
	u_char *hash;
d340 2
a341 3
	dh = dh_new_group(g, p);

	dh_gen_key(dh);
d369 1
a369 1
	server_host_key = key_from_blob(server_host_key_blob, sbloblen);
d419 1
a419 1
	    nbits, dh->p, dh->g,
a425 1
	BN_free(dh_server_pub);
d432 2
a433 2
	if (key_verify(server_host_key, (u_char *)signature, slen, hash, 20) != 1)
		fatal("key_verify failed for server_host_key");
a434 1
	xfree(signature);
a436 1
	BN_clear_free(shared_secret);
d454 1
a454 1
    u_char **sigp, int *lenp, u_char *data, int datalen);
a472 1
void	input_userauth_banner(int type, int plen, void *ctxt);
d481 1
a481 1
void	authmethod_clear(void);
d488 1
a488 1
		&options.pubkey_authentication,
a511 3
	if (options.challenge_reponse_authentication)
		options.kbd_interactive_authentication = 1;

d525 1
a548 1
	dispatch_set(SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);
d554 1
a554 1
	debug("ssh-userauth2 successful: method %s", authctxt.method->name);
d559 1
a559 13
	fatal("input_userauth_error: bad message during authentication: "
	   "type %d", type);
}
void
input_userauth_banner(int type, int plen, void *ctxt)
{
	char *msg, *lang;
	debug3("input_userauth_banner");
	msg = packet_get_string(NULL);
	lang = packet_get_string(NULL);
	fprintf(stderr, "%s", msg);
	xfree(msg);
	xfree(lang);
d585 1
a585 1
		log("Authenticated with partial success.");
d591 1
a591 1
			fatal("Permission denied (%s).", authlist);
d600 1
a600 1
	}
d630 1
a630 1
	snprintf(prompt, sizeof(prompt), "%.30s@@%.128s's password: ",
d638 1
a638 1
	ssh_put_password(password);
d650 1
a650 1
	u_char *blob, *signature;
d656 2
a657 6
	debug3("sign_and_send_pubkey");
	if (key_to_blob(k, &blob, &bloblen) == 0) {
		/* we cannot handle this key */
		debug3("sign_and_send_pubkey: cannot handle key");
		return 0;
	}
d662 1
a662 1
		skip = session_id2_len;
d670 1
a670 1
	    datafellows & SSH_BUG_PKSERVICE ?
d673 3
a675 7
	if (datafellows & SSH_BUG_PKAUTH) {
		buffer_put_char(&b, have_sig);
	} else {
		buffer_put_cstring(&b, authctxt->method->name);
		buffer_put_char(&b, have_sig);
		buffer_put_cstring(&b, key_ssh_name(k));
	}
d685 1
a685 1
#ifdef DEBUG_PK
d688 1
a688 1
	if (datafellows & SSH_BUG_PKSERVICE) {
d696 1
a696 2
		if (!(datafellows & SSH_BUG_PKAUTH))
			buffer_put_cstring(&b, key_ssh_name(k));
d722 2
a723 2
int key_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
    u_char *data, int datalen)
d725 1
a725 1
	return key_sign(key, sigp, lenp, data, datalen);
d732 1
a732 1
	int i, ret, try_next, success = 0;
a733 2
	char *passphrase;
	char prompt[300];
d741 1
a741 1
	k = key_new(KEY_UNSPEC);
d743 3
a745 4
		if (options.batch_mode) {
			key_free(k);
			return 0;
		}
d747 2
a748 1
		     "Enter passphrase for key '%.100s': ", filename);
d769 1
a769 1
	ret = sign_and_send_pubkey(authctxt, k, key_sign_cb);
d775 2
a776 2
int agent_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
    u_char *data, int datalen)
a784 1
	int ret = 0;
d787 1
d790 1
a790 2
		if (ssh_get_num_identities(authctxt->agent, 2) == 0)
			debug2("userauth_pubkey_agent: no keys at all");
d792 2
a794 1
	k = ssh_get_next_identity(authctxt->agent, &comment, 2);
d796 2
a797 6
		debug2("userauth_pubkey_agent: no more keys");
	} else {
		debug("userauth_pubkey_agent: trying agent key %s", comment);
		xfree(comment);
		ret = sign_and_send_pubkey(authctxt, k, agent_sign_cb);
		key_free(k);
d799 4
a802 2
	if (ret == 0)
		debug2("userauth_pubkey_agent: no message sent");
d812 4
a815 11
	if (authctxt->agent != NULL) {
		do {
			sent = userauth_pubkey_agent(authctxt);
		} while(!sent && authctxt->agent->howmany > 0);
	}
	while (!sent && idx < options.num_identity_files) {
		if (options.identity_files_type[idx] != KEY_RSA1)
			sent = userauth_pubkey_identity(authctxt,
			    options.identity_files[idx]);
		idx++;
	}
d846 2
a847 1
 * parse INFO_REQUEST, prompt user and send INFO_RESPONSE
d853 6
a858 2
	char *name, *inst, *lang, *prompt, *response;
	u_int num_prompts, i;
d869 1
d872 2
a875 1
	xfree(name);
d877 1
a877 1
	xfree(lang);
d895 1
a895 1
		ssh_put_password(response);
d922 1
a922 1
authmethod_clear(void)
d934 1
a934 1
		authname_current = NULL;
d977 1
a977 1
 */
d984 1
a984 1

@


1.10.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: sshconnect2.c,v 1.54 2001/03/12 22:02:02 markus Exp $");
a53 1
#include "match.h"
d174 1
a174 1
	dh_gen_key(dh, kex->we_need * 8);
d319 1
a319 1
	nbits = dh_estimate(kex->we_need * 8);
d345 1
a345 1
	dh_gen_key(dh, kex->we_need * 8);
a469 4
	char *authlist;
	Key *last_key;
	sign_cb_fn *last_key_sign;
	int last_key_hint;
a482 1
void	input_userauth_pk_ok(int type, int plen, void *ctxt);
d489 1
a489 7
void	userauth(Authctxt *authctxt, char *authlist);

int
sign_and_send_pubkey(Authctxt *authctxt, Key *k,
    sign_cb_fn *sign_callback);
void	clear_auth_state(Authctxt *authctxt);

a491 1
char *authmethods_get(void);
a541 3
	if (options.preferred_authentications == NULL)
		options.preferred_authentications = authmethods_get();

a548 1
	authctxt.authlist = NULL;
d551 1
a567 24
userauth(Authctxt *authctxt, char *authlist)
{
	if (authlist == NULL) {
		authlist = authctxt->authlist;
	} else {
		if (authctxt->authlist)
			xfree(authctxt->authlist);
		authctxt->authlist = authlist;
	}
	for (;;) {
		Authmethod *method = authmethod_get(authlist);
		if (method == NULL)
			fatal("Permission denied (%s).", authlist);
		authctxt->method = method;
		if (method->userauth(authctxt) != 0) {
			debug2("we sent a %s packet, wait for reply", method->name);
			break;
		} else {
			debug2("we did not send a packet, disable method");
			method->enabled = NULL;
		}
	}
}
void
a589 3
	if (authctxt->authlist)
		xfree(authctxt->authlist);
	clear_auth_state(authctxt);
d595 1
d611 7
a617 35
	clear_auth_state(authctxt);
	userauth(authctxt, authlist);
}
void
input_userauth_pk_ok(int type, int plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	Key *key = NULL;
	Buffer b;
	int alen, blen, pktype, sent = 0;
	char *pkalg, *pkblob, *fp;

	if (authctxt == NULL)
		fatal("input_userauth_pk_ok: no authentication context");
	if (datafellows & SSH_BUG_PKOK) {
		/* this is similar to SSH_BUG_PKAUTH */
		debug2("input_userauth_pk_ok: SSH_BUG_PKOK");
		pkblob = packet_get_string(&blen);
		buffer_init(&b);
		buffer_append(&b, pkblob, blen);
		pkalg = buffer_get_string(&b, &alen);
		buffer_free(&b);
	} else {
		pkalg = packet_get_string(&alen);
		pkblob = packet_get_string(&blen);
	}
	packet_done();

	debug("input_userauth_pk_ok: pkalg %s blen %d lastkey %p hint %d",
	    pkalg, blen, authctxt->last_key, authctxt->last_key_hint);

	do {
		if (authctxt->last_key == NULL ||
		    authctxt->last_key_sign == NULL) {
			debug("no last key or no sign cb");
d619 3
d623 2
a624 32
		if ((pktype = key_type_from_name(pkalg)) == KEY_UNSPEC) {
			debug("unknown pkalg %s", pkalg);
			break;
		}
		if ((key = key_from_blob(pkblob, blen)) == NULL) {
			debug("no key from blob. pkalg %s", pkalg);
			break;
		}
		fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
		debug2("input_userauth_pk_ok: fp %s", fp);
		xfree(fp);
		if (!key_equal(key, authctxt->last_key)) {
			debug("key != last_key");
			break;
		}
		sent = sign_and_send_pubkey(authctxt, key,
		   authctxt->last_key_sign);
	} while(0);

	if (key != NULL)
		key_free(key);
	xfree(pkalg);
	xfree(pkblob);

	/* unregister */
	clear_auth_state(authctxt);
	dispatch_set(SSH2_MSG_USERAUTH_PK_OK, NULL);

	/* try another method if we did not send a packet*/
	if (sent == 0)
		userauth(authctxt, NULL);

d636 1
d661 1
a661 1
	packet_put_cstring(password);
a663 1
	packet_inject_ignore(64);
d665 1
a668 13
void
clear_auth_state(Authctxt *authctxt)
{
	/* XXX clear authentication state */
	if (authctxt->last_key != NULL && authctxt->last_key_hint == -1) {
		debug3("clear_auth_state: key_free %p", authctxt->last_key);
		key_free(authctxt->last_key);
	}
	authctxt->last_key = NULL;
	authctxt->last_key_hint = -2;
	authctxt->last_key_sign = NULL;
}

a679 1

d710 1
a710 2
	ret = (*sign_callback)(authctxt, k, &signature, &slen,
	    buffer_ptr(&b), buffer_len(&b));
a721 1
		skip = session_id2_len;
a731 1

d745 2
d748 1
d753 3
a755 3
int
send_pubkey_test(Authctxt *authctxt, Key *k, sign_cb_fn *sign_callback,
    int hint)
d757 1
a757 27
	u_char *blob;
	int bloblen, have_sig = 0;

	debug3("send_pubkey_test");

	if (key_to_blob(k, &blob, &bloblen) == 0) {
		/* we cannot handle this key */
		debug3("send_pubkey_test: cannot handle key");
		return 0;
	}
	/* register callback for USERAUTH_PK_OK message */
	authctxt->last_key_sign = sign_callback;
	authctxt->last_key_hint = hint;
	authctxt->last_key = k;
	dispatch_set(SSH2_MSG_USERAUTH_PK_OK, &input_userauth_pk_ok);

	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(authctxt->server_user);
	packet_put_cstring(authctxt->service);
	packet_put_cstring(authctxt->method->name);
	packet_put_char(have_sig);
	if (!(datafellows & SSH_BUG_PKAUTH))
		packet_put_cstring(key_ssh_name(k));
	packet_put_string(blob, bloblen);
	xfree(blob);
	packet_send();
	return 1;
d760 2
a761 2
Key *
load_identity_file(char *filename)
d763 2
a764 3
	Key *private;
	char prompt[300], *passphrase;
	int success = 0, quit, i;
d766 2
d769 3
a771 3
	if (stat(filename, &st) < 0) {
		debug3("no such identity: %s", filename);
		return NULL;
d773 4
a776 2
	private = key_new(KEY_UNSPEC);
	if (!load_private_key(filename, "", private, NULL)) {
d778 2
a779 2
			key_free(private);
			return NULL;
d786 2
a787 3
				success = load_private_key(filename,
				    passphrase, private, NULL);
				quit = 0;
d790 1
a790 1
				quit = 1;
d794 1
a794 1
			if (success || quit)
d799 2
a800 2
			key_free(private);
			return NULL;
d803 2
a804 18
	return private;
}

int
identity_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
    u_char *data, int datalen)
{
	Key *private;
	int idx, ret;

	idx = authctxt->last_key_hint;
	if (idx < 0)
		return -1;
	private = load_identity_file(options.identity_files[idx]);
	if (private == NULL)
		return -1;
	ret = key_sign(private, sigp, lenp, data, datalen);
	key_free(private);
d808 1
a814 6
int key_sign_cb(Authctxt *authctxt, Key *key, u_char **sigp, int *lenp,
    u_char *data, int datalen)
{
        return key_sign(key, sigp, lenp, data, datalen);
}

d832 1
a832 1
		debug("userauth_pubkey_agent: testing agent key %s", comment);
d834 2
a835 3
		ret = send_pubkey_test(authctxt, k, agent_sign_cb, -1);
		if (ret == 0)
			key_free(k);
a846 2
	Key *key;
	char *filename;
d854 3
a856 15
		key = options.identity_keys[idx];
		filename = options.identity_files[idx];
		if (key == NULL) {
			debug("try privkey: %s", filename);
			key = load_identity_file(filename);
			if (key != NULL) {
				sent = sign_and_send_pubkey(authctxt, key,
				    key_sign_cb);
				key_free(key);
			}
		} else if (key->type != KEY_RSA1) {
			debug("try pubkey: %s", filename);
			sent = send_pubkey_test(authctxt, key,
			    identity_sign_cb, idx);
		}
d882 1
d931 1
a931 1
		packet_put_cstring(response);
a937 1
	packet_inject_ignore(64);
d939 1
d944 33
a1006 4
/* XXX internal state */
static Authmethod *current = NULL;
static char *supported = NULL;
static char *preferred = NULL;
d1010 3
a1012 1
 * use a built-in default list. 
d1014 1
d1018 2
a1019 3

	char *name = NULL;
	int next;
d1023 1
a1023 1
		authlist = options.preferred_authentications;
d1025 15
a1039 10
	if (supported == NULL || strcmp(authlist, supported) != 0) {
		debug3("start over, passed a different list %s", authlist);
		if (supported != NULL)
			xfree(supported);
		supported = xstrdup(authlist);
		preferred = options.preferred_authentications;
		debug3("preferred %s", preferred);
		current = NULL;
	} else if (current != NULL && authmethod_is_enabled(current))
		return current;
d1041 1
a1041 7
	for (;;) {
		if ((name = match_list(preferred, supported, &next)) == NULL) {
			debug("no more auth methods to try");
			current = NULL;
			return NULL;
		}
		preferred += next;
d1043 2
a1044 3
		debug3("remaining preferred: %s", preferred);
		if ((current = authmethod_lookup(name)) != NULL &&
		    authmethod_is_enabled(current)) {
d1046 1
a1046 2
			debug("next auth method to try is %s", name);
			return current;
d1048 2
a1050 1
}
d1052 8
d1061 2
a1062 6
#define	DELIM	","
char *
authmethods_get(void)
{
	Authmethod *method = NULL;
	char buf[1024];
d1064 1
a1064 9
	buf[0] = '\0';
	for (method = authmethods; method->name != NULL; method++) {
		if (authmethod_is_enabled(method)) {
			if (buf[0] != '\0')
				strlcat(buf, DELIM, sizeof buf);
			strlcat(buf, method->name, sizeof buf);
		}
	}
	return xstrdup(buf);
@


1.9
log
@complain about invalid ciphers in SSH1 (e.g. arcfour is SSH2 only)
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.8 2000/05/07 18:23:32 markus Exp $");
d348 4
a351 1
	buffer_put_cstring(&b, service);
a355 1
	xfree(blob);
d363 13
@


1.8
log
@make x11-fwd interop w/ ssh-2.0.13
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.7 2000/05/06 17:45:37 markus Exp $");
d99 1
a99 5
	} else if (
	    options.cipher == SSH_CIPHER_ARCFOUR ||
	    options.cipher == SSH_CIPHER_3DES_CBC ||
	    options.cipher == SSH_CIPHER_CAST128_CBC ||
	    options.cipher == SSH_CIPHER_BLOWFISH_CBC) {
d101 6
a106 1
		myproposal[PROPOSAL_ENC_ALGS_STOC] = cipher_name(options.cipher);
@


1.7
log
@add DSAAuthetication option to ssh/sshd, document SSH2 in sshd.8
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.6 2000/05/03 17:55:21 markus Exp $");
d408 1
a408 1
		log("buggy server: service_accept w/o service");
@


1.6
log
@respect number_of_password_prompts
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.5 2000/05/01 18:41:06 markus Exp $");
d435 1
a435 1
		if (options.rsa_authentication &&
@


1.5
log
@check whether file exists before asking for passphrase
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.4 2000/04/27 17:54:01 markus Exp $");
d286 1
d289 3
@


1.4
log
@less debug, respect .ssh/config
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.3 2000/04/27 08:01:27 markus Exp $");
d313 1
d315 4
d326 1
a326 1
                snprintf(prompt, sizeof prompt,
d328 1
a328 1
                     filename);
@


1.3
log
@xfree DSA blobs
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.2 2000/04/26 21:33:53 markus Exp $");
a332 2
//DSA_print_fp(stderr, k->dsa, 8);

d426 2
a427 1
		if (strstr(auths, "publickey") != NULL) {
d437 3
a439 1
			if (strstr(auths, "password") != NULL) {
a440 2
			} else {
				fatal("passwd auth not supported: %s", auths);
a441 2
			if (!sent)
				fatal("no more auths: %s", auths);
d443 2
@


1.2
log
@remove debug
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.1 2000/04/26 21:28:33 markus Exp $");
d234 1
d345 1
@


1.1
log
@split auth/sshconnect in one file per protocol version
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sshconnect2.c,v 1.1 2000/04/18 15:01:34 markus Exp $");
a182 2

dump_base64(stderr, server_host_key_blob, sbloblen);
@

