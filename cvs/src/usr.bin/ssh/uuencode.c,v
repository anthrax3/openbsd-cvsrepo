head	1.28;
access;
symbols
	OPENBSD_6_2:1.28.0.12
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.10
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.8
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.4
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.2
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.27.0.4
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.8
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.6
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.10
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.8
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.6
	OPENBSD_5_0:1.26.0.4
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.25.0.6
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.24.0.12
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.10
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.8
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.6
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.4
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.17.0.10
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.8
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.6
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.28
date	2015.04.24.01.36.24;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	451VF2nlhfxoPy9t;

1.27
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2009.03.05.11.30.50;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2006.08.01.23.22.48;	author stevesk;	state Exp;
branches;
next	1.22;

1.22
date	2006.07.05.02.42.09;	author stevesk;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.26.01.31.48;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.25.13.17.03;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.19.18.51.19;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.10.16.23.41;	author jakob;	state Exp;
branches
	1.17.8.1
	1.17.10.1;
next	1.16;

1.16
date	2002.09.09.14.54.15;	author markus;	state Exp;
branches
	1.16.4.1
	1.16.6.1;
next	1.15;

1.15
date	2002.03.04.17.27.39;	author stevesk;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.02.25.16.33.27;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.24.18.31.09;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.01.02.27.18;	author deraadt;	state Exp;
branches
	1.12.2.1
	1.12.4.1;
next	1.11;

1.11
date	2001.03.01.02.20.50;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.08.19.30.53;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.07.08.54.16;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.19.23.17.59;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.07.20.27.55;	author deraadt;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.06.22.23.55.00;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.05.18.53.42;	author markus;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.05.04.22.38.00;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.27.08.02.19;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.26.21.51.50;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.26.20.56.30;	author markus;	state Exp;
branches;
next	;

1.5.2.1
date	2000.09.01.18.23.25;	author jason;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2000.11.08.21.31.38;	author jason;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.03.12.15.44.18;	author jason;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2001.03.21.18.53.20;	author jason;	state Exp;
branches;
next	;

1.7.2.1
date	2001.02.16.20.13.24;	author jason;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.02.19.17.19.43;	author jason;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.03.21.19.46.32;	author jason;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2001.05.07.21.09.39;	author jason;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2001.09.27.00.15.43;	author miod;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2002.03.08.17.04.44;	author brad;	state Exp;
branches;
next	;

1.12.2.1
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	;

1.12.4.1
date	2002.03.07.17.37.48;	author jason;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.15.2.1
date	2002.10.11.14.51.53;	author miod;	state Exp;
branches;
next	;

1.16.4.1
date	2004.03.04.18.18.17;	author brad;	state Exp;
branches;
next	;

1.16.6.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	;

1.17.8.1
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	;

1.17.10.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	;


desc
@@


1.28
log
@2*len -> use xreallocarray()
ok djm
@
text
@/* $OpenBSD: uuencode.c,v 1.27 2013/05/17 00:13:14 djm Exp $ */
/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <netinet/in.h>
#include <resolv.h>
#include <stdio.h>
#include <stdlib.h>

#include "xmalloc.h"
#include "uuencode.h"

/*
 * Encode binary 'src' of length 'srclength', writing base64-encoded text
 * to 'target' of size 'targsize'. Will always nul-terminate 'target'.
 * Returns the number of bytes stored in 'target' or -1 on error (inc.
 * 'targsize' too small).
 */
int
uuencode(const u_char *src, u_int srclength,
    char *target, size_t targsize)
{
	return __b64_ntop(src, srclength, target, targsize);
}

/*
 * Decode base64-encoded 'src' into buffer 'target' of 'targsize' bytes.
 * Will skip leading and trailing whitespace. Returns the number of bytes
 * stored in 'target' or -1 on error (inc. targsize too small).
 */
int
uudecode(const char *src, u_char *target, size_t targsize)
{
	int len;
	char *encoded, *p;

	/* copy the 'readonly' source */
	encoded = xstrdup(src);
	/* skip whitespace and data */
	for (p = encoded; *p == ' ' || *p == '\t'; p++)
		;
	for (; *p != '\0' && *p != ' ' && *p != '\t'; p++)
		;
	/* and remove trailing whitespace because __b64_pton needs this */
	*p = '\0';
	len = __b64_pton(encoded, target, targsize);
	free(encoded);
	return len;
}

void
dump_base64(FILE *fp, const u_char *data, u_int len)
{
	char *buf;
	int i, n;

	if (len > 65536) {
		fprintf(fp, "dump_base64: len > 65536\n");
		return;
	}
	buf = xreallocarray(NULL, 2, len);
	n = uuencode(data, len, buf, 2*len);
	for (i = 0; i < n; i++) {
		fprintf(fp, "%c", buf[i]);
		if (i % 70 == 69)
			fprintf(fp, "\n");
	}
	if (i % 70 != 69)
		fprintf(fp, "\n");
	free(buf);
}
@


1.27
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: uuencode.c,v 1.26 2010/08/31 11:54:45 djm Exp $ */
d83 1
a83 1
	buf = xmalloc(2*len);
@


1.26
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: uuencode.c,v 1.25 2009/03/05 11:30:50 djm Exp $ */
d30 1
d69 1
a69 1
	xfree(encoded);
d92 1
a92 1
	xfree(buf);
@


1.25
log
@document what these functions do so I don't ever have to recuse into
b64_pton/ntop to remember their return values
@
text
@d1 1
a1 1
/* $OpenBSD: uuencode.c,v 1.24 2006/08/03 03:34:42 deraadt Exp $ */
d73 1
a73 1
dump_base64(FILE *fp, u_char *data, u_int len)
@


1.24
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: uuencode.c,v 1.23 2006/08/01 23:22:48 stevesk Exp $ */
d34 6
d47 5
@


1.23
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: uuencode.c,v 1.22 2006/07/05 02:42:09 stevesk Exp $ */
a25 2
#include "includes.h"

a26 1

a27 1

@


1.22
log
@move #include <netinet/in.h> out of includes.h; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: uuencode.c,v 1.21 2006/03/26 01:31:48 deraadt Exp $ */
d33 1
@


1.21
log
@typo
@
text
@d1 1
a1 1
/* $OpenBSD: uuencode.c,v 1.20 2006/03/25 13:17:03 djm Exp $ */
d28 6
a35 2

#include <resolv.h>
@


1.20
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d63 1
a63 1
	char *buf;;
@


1.19
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.18
log
@RCSID() can die
@
text
@d62 1
a62 1
	char *buf = xmalloc(2*len);
d65 5
@


1.17
log
@constify. ok markus@@ & djm@@
@
text
@a25 1
RCSID("$OpenBSD: uuencode.c,v 1.16 2002/09/09 14:54:15 markus Exp $");
@


1.17.8.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: uuencode.c,v 1.24 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 4
#include <sys/types.h>
#include <netinet/in.h>
#include <resolv.h>
#include <stdio.h>
d31 2
d63 1
a63 1
	char *buf;
a65 5
	if (len > 65536) {
		fprintf(fp, "dump_base64: len > 65536\n");
		return;
	}
	buf = xmalloc(2*len);
@


1.17.10.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: uuencode.c,v 1.24 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 4
#include <sys/types.h>
#include <netinet/in.h>
#include <resolv.h>
#include <stdio.h>
d31 2
d63 1
a63 1
	char *buf;
a65 5
	if (len > 65536) {
		fprintf(fp, "dump_base64: len > 65536\n");
		return;
	}
	buf = xmalloc(2*len);
@


1.16
log
@signed vs unsigned from -pedantic; ok henning@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: uuencode.c,v 1.15 2002/03/04 17:27:39 stevesk Exp $");
d34 1
a34 1
uuencode(u_char *src, u_int srclength,
@


1.16.4.1
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: uuencode.c,v 1.17 2003/11/10 16:23:41 jakob Exp $");
d34 1
a34 1
uuencode(const u_char *src, u_int srclength,
@


1.16.6.1
log
@upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: uuencode.c,v 1.17 2003/11/10 16:23:41 jakob Exp $");
d34 1
a34 1
uuencode(const u_char *src, u_int srclength,
@


1.15
log
@$OpenBSD$ and RCSID() cleanup: don't use RCSID() in .h files; add
missing RCSID() to .c files and remove dup /*$OpenBSD$*/ from .c
files.  ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: uuencode.c,v 1.14 2002/02/25 16:33:27 markus Exp $");
d63 1
a63 1
	u_char *buf = xmalloc(2*len);
@


1.15.2.1
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: uuencode.c,v 1.16 2002/09/09 14:54:15 markus Exp $");
d63 1
a63 1
	char *buf = xmalloc(2*len);
@


1.14
log
@more u_* fixes
@
text
@a0 2
/*	$OpenBSD: uuencode.c,v 1.13 2002/02/24 18:31:09 markus Exp $	*/

d26 2
a31 2

RCSID("$OpenBSD: uuencode.c,v 1.13 2002/02/24 18:31:09 markus Exp $");
@


1.13
log
@typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.12 2001/03/01 02:27:18 deraadt Exp $	*/
d33 1
a33 1
RCSID("$OpenBSD: uuencode.c,v 1.12 2001/03/01 02:27:18 deraadt Exp $");
d63 1
a63 1
dump_base64(FILE *fp, u_char *data, int len)
@


1.12
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.10 2001/02/08 19:30:53 itojun Exp $	*/
d33 1
a33 1
RCSID("$OpenBSD: uuencode.c,v 1.10 2001/02/08 19:30:53 itojun Exp $");
d55 1
a55 1
	/* and remote trailing whitespace because __b64_pton needs this */
@


1.12.2.1
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d1 2
a27 2
RCSID("$OpenBSD: uuencode.c,v 1.15 2002/03/04 17:27:39 stevesk Exp $");

d33 2
d55 1
a55 1
	/* and remove trailing whitespace because __b64_pton needs this */
d63 1
a63 1
dump_base64(FILE *fp, u_char *data, u_int len)
@


1.12.4.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d1 2
a27 2
RCSID("$OpenBSD: uuencode.c,v 1.15 2002/03/04 17:27:39 stevesk Exp $");

d33 2
d55 1
a55 1
	/* and remove trailing whitespace because __b64_pton needs this */
d63 1
a63 1
dump_base64(FILE *fp, u_char *data, u_int len)
@


1.12.4.2
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: uuencode.c,v 1.16 2002/09/09 14:54:15 markus Exp $");
d63 1
a63 1
	char *buf = xmalloc(2*len);
@


1.11
log
@get rid of extra header
@
text
@d31 2
@


1.10
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.9 2001/02/07 08:54:16 deraadt Exp $	*/
d31 1
a31 3
#include <resolv.h>

RCSID("$OpenBSD: uuencode.c,v 1.9 2001/02/07 08:54:16 deraadt Exp $");
@


1.9
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.8 2000/12/19 23:17:59 markus Exp $	*/
d29 1
d33 1
a33 1
RCSID("$OpenBSD: uuencode.c,v 1.8 2000/12/19 23:17:59 markus Exp $");
@


1.8
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.7 2000/09/07 20:27:55 deraadt Exp $	*/
d32 1
a32 1
RCSID("$OpenBSD: uuencode.c,v 1.7 2000/09/07 20:27:55 deraadt Exp $");
d66 1
@


1.7
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 1
a32 1
RCSID("$OpenBSD: uuencode.c,v 1.6 2000/06/22 23:55:00 djm Exp $");
d35 1
a35 1
uuencode(unsigned char *src, unsigned int srclength,
d42 1
a42 1
uudecode(const char *src, unsigned char *target, size_t targsize)
d62 1
a62 1
dump_base64(FILE *fp, unsigned char *data, int len)
d64 1
a64 1
	unsigned char *buf = xmalloc(2*len);
@


1.7.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.10 2001/02/08 19:30:53 itojun Exp $	*/
a28 1
#include "uuencode.h"
d32 1
a32 1
RCSID("$OpenBSD: uuencode.c,v 1.10 2001/02/08 19:30:53 itojun Exp $");
d35 1
a35 1
uuencode(u_char *src, u_int srclength,
d42 1
a42 1
uudecode(const char *src, u_char *target, size_t targsize)
d62 1
a62 1
dump_base64(FILE *fp, u_char *data, int len)
d64 1
a64 1
	u_char *buf = xmalloc(2*len);
a65 1

@


1.7.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.7.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.12 2001/03/01 02:27:18 deraadt Exp $	*/
d33 1
a33 1
RCSID("$OpenBSD: uuencode.c,v 1.12 2001/03/01 02:27:18 deraadt Exp $");
@


1.7.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.7.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@@


1.7.2.6
log
@Merge OpenSSH 3.1.
@
text
@d1 2
a27 2
RCSID("$OpenBSD: uuencode.c,v 1.15 2002/03/04 17:27:39 stevesk Exp $");

d33 2
d55 1
a55 1
	/* and remove trailing whitespace because __b64_pton needs this */
d63 1
a63 1
dump_base64(FILE *fp, u_char *data, u_int len)
@


1.6
log
@Missing CVS idents; ok markus
@
text
@d1 2
d5 20
d26 1
d32 1
a32 1
RCSID("$OpenBSD$");
@


1.5
log
@remote trailing comments before calling __b64_pton
@
text
@d9 2
@


1.5.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@a8 2
RCSID("$OpenBSD: uuencode.c,v 1.6 2000/06/22 23:55:00 djm Exp $");

@


1.5.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@a0 2
/*	$OpenBSD: uuencode.c,v 1.7 2000/09/07 20:27:55 deraadt Exp $	*/

a2 20
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a3 1

d9 1
a9 1
RCSID("$OpenBSD: uuencode.c,v 1.7 2000/09/07 20:27:55 deraadt Exp $");
@


1.5.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.10 2001/02/08 19:30:53 itojun Exp $	*/
a28 1
#include "uuencode.h"
d32 1
a32 1
RCSID("$OpenBSD: uuencode.c,v 1.10 2001/02/08 19:30:53 itojun Exp $");
d35 1
a35 1
uuencode(u_char *src, u_int srclength,
d42 1
a42 1
uudecode(const char *src, u_char *target, size_t targsize)
d62 1
a62 1
dump_base64(FILE *fp, u_char *data, int len)
d64 1
a64 1
	u_char *buf = xmalloc(2*len);
a65 1

@


1.5.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: uuencode.c,v 1.12 2001/03/01 02:27:18 deraadt Exp $	*/
d33 1
a33 1
RCSID("$OpenBSD: uuencode.c,v 1.12 2001/03/01 02:27:18 deraadt Exp $");
@


1.4
log
@replace broken uuencode w/ libc b64_ntop
@
text
@d13 1
a13 1
	return b64_ntop(src, srclength, target, targsize);
d19 15
a33 1
	return b64_pton(src, target, targsize);
@


1.3
log
@remove debug
@
text
@d2 1
a2 5
 *   base-64 encoding pinched from lynx2-7-2, who pinched it from rpem.
 *   Originally written by Mark Riordan 12 August 1990 and 17 Feb 1991
 *   and placed in the public domain.
 *
 *   Dug Song <dugsong@@UMICH.EDU>
a3 1

d7 1
a7 9
char six2pr[64] = {
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
	'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
	'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
	'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
};

unsigned char pr2six[256];
d10 2
a11 1
uuencode(unsigned char *bufin, unsigned int nbytes, char *bufcoded)
d13 1
a13 23
	/* ENC is the basic 1 character encoding function to make a char printing */
#define ENC(c) six2pr[c]

	register char *outptr = bufcoded;
	unsigned int i;

	for (i = 0; i < nbytes; i += 3) {
		*(outptr++) = ENC(*bufin >> 2);						/* c1 */
		*(outptr++) = ENC(((*bufin << 4) & 060)   | ((bufin[1] >> 4) & 017));	/* c2 */
		*(outptr++) = ENC(((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03));	/* c3 */
		*(outptr++) = ENC(bufin[2] & 077);					/* c4 */
		bufin += 3;
	}
	if (i == nbytes + 1) {
		outptr[-1] = '=';
	} else if (i == nbytes + 2) {
		outptr[-1] = '=';
		outptr[-2] = '=';
	} else if (i == nbytes) {
		*(outptr++) = '=';
	}
	*outptr = '\0';
	return (outptr - bufcoded);
d17 1
a17 1
uudecode(const char *bufcoded, unsigned char *bufplain, int outbufsize)
d19 1
a19 51
	/* single character decode */
#define DEC(c) pr2six[(unsigned char)c]
#define MAXVAL 63

	static int first = 1;
	int nbytesdecoded, j;
	const char *bufin = bufcoded;
	register unsigned char *bufout = bufplain;
	register int nprbytes;

	/* If this is the first call, initialize the mapping table. */
	if (first) {
		first = 0;
		for (j = 0; j < 256; j++)
			pr2six[j] = MAXVAL + 1;
		for (j = 0; j < 64; j++)
			pr2six[(unsigned char) six2pr[j]] = (unsigned char) j;
	}
	/* Strip leading whitespace. */
	while (*bufcoded == ' ' || *bufcoded == '\t')
		bufcoded++;

	/*
	 * Figure out how many characters are in the input buffer. If this
	 * would decode into more bytes than would fit into the output
	 * buffer, adjust the number of input bytes downwards.
	 */
	bufin = bufcoded;
	while (DEC(*(bufin++)) <= MAXVAL)
		;
	nprbytes = bufin - bufcoded - 1;
	nbytesdecoded = ((nprbytes + 3) / 4) * 3;
	if (nbytesdecoded > outbufsize)
		nprbytes = (outbufsize * 4) / 3;

	bufin = bufcoded;

	while (nprbytes > 0) {
		*(bufout++) = (unsigned char) (DEC(*bufin)   << 2 | DEC(bufin[1]) >> 4);
		*(bufout++) = (unsigned char) (DEC(bufin[1]) << 4 | DEC(bufin[2]) >> 2);
		*(bufout++) = (unsigned char) (DEC(bufin[2]) << 6 | DEC(bufin[3]));
		bufin += 4;
		nprbytes -= 4;
	}
	if (nprbytes & 03) {
		if (DEC(bufin[-2]) > MAXVAL)
			nbytesdecoded -= 2;
		else
			nbytesdecoded -= 1;
	}
	return (nbytesdecoded);
d27 1
a27 1
	n = uuencode(data, len, buf);
@


1.2
log
@add trailing =
@
text
@a43 1
		debug("uuencode: i == nbytes");
@


1.1
log
@add DSA pubkey auth and other SSH2 fixes.  use ssh-keygen -[xX]
for trading keys with the real and the original SSH, directly from the
people who invented the SSH protocol.
@
text
@d43 3
d82 2
a83 1
	while (DEC(*(bufin++)) <= MAXVAL);
@

