head	1.286;
access;
symbols
	OPENBSD_6_1_BASE:1.286
	OPENBSD_6_0:1.282.0.4
	OPENBSD_6_0_BASE:1.282
	OPENBSD_5_9:1.280.0.2
	OPENBSD_5_9_BASE:1.280
	OPENBSD_5_8:1.278.0.2
	OPENBSD_5_8_BASE:1.278
	OPENBSD_5_7:1.277.0.2
	OPENBSD_5_7_BASE:1.277
	OPENBSD_5_6:1.274.0.4
	OPENBSD_5_6_BASE:1.274
	OPENBSD_5_5:1.271.0.2
	OPENBSD_5_5_BASE:1.271
	OPENBSD_5_4:1.266.0.2
	OPENBSD_5_4_BASE:1.266
	OPENBSD_5_3:1.261.0.2
	OPENBSD_5_3_BASE:1.261
	OPENBSD_5_2:1.260.0.2
	OPENBSD_5_2_BASE:1.260
	OPENBSD_5_1_BASE:1.259
	OPENBSD_5_1:1.259.0.2
	OPENBSD_5_0:1.258.0.4
	OPENBSD_5_0_BASE:1.258
	OPENBSD_4_9:1.258.0.2
	OPENBSD_4_9_BASE:1.258
	OPENBSD_4_8:1.256.0.2
	OPENBSD_4_8_BASE:1.256
	OPENBSD_4_7:1.252.0.2
	OPENBSD_4_7_BASE:1.252
	OPENBSD_4_6:1.246.0.4
	OPENBSD_4_6_BASE:1.246
	OPENBSD_4_5:1.245.0.2
	OPENBSD_4_5_BASE:1.245
	OPENBSD_4_4:1.241.0.2
	OPENBSD_4_4_BASE:1.241
	OPENBSD_4_3:1.230.0.2
	OPENBSD_4_3_BASE:1.230
	OPENBSD_4_2:1.221.0.4
	OPENBSD_4_2_BASE:1.221
	OPENBSD_4_1:1.221.0.2
	OPENBSD_4_1_BASE:1.221
	OPENBSD_4_0:1.219.0.4
	OPENBSD_4_0_BASE:1.219
	OPENBSD_3_9:1.197.0.2
	OPENBSD_3_9_BASE:1.197
	OPENBSD_3_8:1.186.0.2
	OPENBSD_3_8_BASE:1.186
	OPENBSD_3_7:1.181.0.2
	OPENBSD_3_7_BASE:1.181
	OPENBSD_3_6:1.180.0.2
	OPENBSD_3_6_BASE:1.180
	OPENBSD_3_5:1.172.0.2
	OPENBSD_3_5_BASE:1.172
	OPENBSD_3_4:1.163.0.2
	OPENBSD_3_4_BASE:1.163
	OPENBSD_3_3:1.154.0.2
	OPENBSD_3_3_BASE:1.154
	OPENBSD_3_2:1.150.0.2
	OPENBSD_3_2_BASE:1.150
	OPENBSD_3_1:1.134.0.2
	OPENBSD_3_1_BASE:1.134
	OPENBSD_3_0:1.108.0.2
	OPENBSD_3_0_BASE:1.108
	OPENBSD_2_9_BASE:1.74
	OPENBSD_2_9:1.74.0.2
	OPENBSD_2_8:1.42.0.2
	OPENBSD_2_8_BASE:1.42
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12;
locks; strict;
comment	@ * @;


1.286
date	2016.11.30.03.00.05;	author djm;	state Exp;
branches;
next	1.285;
commitid	JiLWdRxWiRohf4cK;

1.285
date	2016.08.23.16.21.45;	author otto;	state Exp;
branches;
next	1.284;
commitid	A4di08z2qutpEwLq;

1.284
date	2016.08.19.03.18.06;	author djm;	state Exp;
branches;
next	1.283;
commitid	o9ZQ52UJzA8fd7BT;

1.283
date	2016.08.13.17.47.41;	author markus;	state Exp;
branches;
next	1.282;
commitid	dl4RDERdJITM8DKC;

1.282
date	2016.03.10.11.47.57;	author djm;	state Exp;
branches;
next	1.281;
commitid	hkgEeRUB9YRvLBZ6;

1.281
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.280;
commitid	kr9hjdmg99uVnhW2;

1.280
date	2016.02.16.03.37.48;	author djm;	state Exp;
branches
	1.280.2.1;
next	1.279;
commitid	0gARkv0PhATEOkNA;

1.279
date	2015.10.24.22.52.22;	author djm;	state Exp;
branches;
next	1.278;
commitid	ckR8zXcof7GWY2Bd;

1.278
date	2015.04.24.01.36.00;	author deraadt;	state Exp;
branches
	1.278.2.1;
next	1.277;
commitid	LHkUmZjv49ojnnuH;

1.277
date	2015.01.16.06.40.12;	author deraadt;	state Exp;
branches
	1.277.2.1;
next	1.276;
commitid	Uu5nFG3wCl0LACBb;

1.276
date	2015.01.14.20.05.27;	author djm;	state Exp;
branches;
next	1.275;
commitid	YqNUZu0ifI7Q95nk;

1.275
date	2014.12.22.07.55.51;	author djm;	state Exp;
branches;
next	1.274;
commitid	Obssn4758PtR7Red;

1.274
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.273;
commitid	z7plx8Gkj6l2sxem;

1.273
date	2014.07.03.22.40.43;	author djm;	state Exp;
branches;
next	1.272;
commitid	cw6lnAok4n9rxQzD;

1.272
date	2014.07.03.03.34.09;	author djm;	state Exp;
branches;
next	1.271;
commitid	O9Tt7hhD3nOW2fIY;

1.271
date	2014.03.03.22.22.30;	author djm;	state Exp;
branches;
next	1.270;

1.270
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.269;

1.269
date	2014.01.18.09.36.26;	author dtucker;	state Exp;
branches;
next	1.268;

1.268
date	2013.10.29.09.48.02;	author djm;	state Exp;
branches;
next	1.267;

1.267
date	2013.10.14.21.20.52;	author djm;	state Exp;
branches;
next	1.266;

1.266
date	2013.07.19.07.37.48;	author markus;	state Exp;
branches;
next	1.265;

1.265
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.264;

1.264
date	2013.04.19.01.03.01;	author djm;	state Exp;
branches;
next	1.263;

1.263
date	2013.04.17.09.04.09;	author dtucker;	state Exp;
branches;
next	1.262;

1.262
date	2013.03.06.23.35.23;	author djm;	state Exp;
branches;
next	1.261;

1.261
date	2012.12.02.20.46.11;	author djm;	state Exp;
branches;
next	1.260;

1.260
date	2012.03.15.03.10.27;	author guenther;	state Exp;
branches;
next	1.259;

1.259
date	2011.10.24.02.13.13;	author djm;	state Exp;
branches;
next	1.258;

1.258
date	2010.11.25.04.10.09;	author djm;	state Exp;
branches;
next	1.257;

1.257
date	2010.11.13.23.27.50;	author djm;	state Exp;
branches;
next	1.256;

1.256
date	2010.06.25.07.20.04;	author djm;	state Exp;
branches;
next	1.255;

1.255
date	2010.06.22.04.59.12;	author djm;	state Exp;
branches;
next	1.254;

1.254
date	2010.06.18.03.16.03;	author djm;	state Exp;
branches;
next	1.253;

1.253
date	2010.04.23.22.42.05;	author djm;	state Exp;
branches;
next	1.252;

1.252
date	2010.03.07.11.57.13;	author dtucker;	state Exp;
branches;
next	1.251;

1.251
date	2010.01.12.08.33.17;	author dtucker;	state Exp;
branches;
next	1.250;

1.250
date	2010.01.12.01.31.05;	author dtucker;	state Exp;
branches;
next	1.249;

1.249
date	2009.11.20.00.15.41;	author dtucker;	state Exp;
branches;
next	1.248;

1.248
date	2009.11.19.23.39.50;	author djm;	state Exp;
branches;
next	1.247;

1.247
date	2009.10.06.04.46.40;	author djm;	state Exp;
branches;
next	1.246;

1.246
date	2009.04.17.19.23.06;	author stevesk;	state Exp;
branches;
next	1.245;

1.245
date	2009.01.22.09.46.01;	author djm;	state Exp;
branches;
next	1.244;

1.244
date	2008.11.09.12.34.47;	author tobias;	state Exp;
branches;
next	1.243;

1.243
date	2008.10.02.14.39.35;	author millert;	state Exp;
branches;
next	1.242;

1.242
date	2008.08.21.04.09.57;	author djm;	state Exp;
branches;
next	1.241;

1.241
date	2008.06.16.13.22.53;	author dtucker;	state Exp;
branches;
next	1.240;

1.240
date	2008.06.15.20.06.26;	author djm;	state Exp;
branches;
next	1.239;

1.239
date	2008.06.14.18.33.43;	author djm;	state Exp;
branches;
next	1.238;

1.238
date	2008.05.09.16.16.06;	author markus;	state Exp;
branches;
next	1.237;

1.237
date	2008.05.08.12.21.16;	author djm;	state Exp;
branches;
next	1.236;

1.236
date	2008.05.08.12.02.23;	author djm;	state Exp;
branches;
next	1.235;

1.235
date	2008.05.07.05.49.37;	author pyr;	state Exp;
branches;
next	1.234;

1.234
date	2008.04.18.22.01.33;	author djm;	state Exp;
branches;
next	1.233;

1.233
date	2008.03.26.21.28.14;	author djm;	state Exp;
branches;
next	1.232;

1.232
date	2008.03.25.23.01.41;	author djm;	state Exp;
branches;
next	1.231;

1.231
date	2008.03.25.11.58.02;	author djm;	state Exp;
branches;
next	1.230;

1.230
date	2008.02.22.05.58.56;	author djm;	state Exp;
branches
	1.230.2.1;
next	1.229;

1.229
date	2008.02.20.15.25.26;	author markus;	state Exp;
branches;
next	1.228;

1.228
date	2008.02.13.22.38.17;	author djm;	state Exp;
branches;
next	1.227;

1.227
date	2008.02.10.10.54.29;	author djm;	state Exp;
branches;
next	1.226;

1.226
date	2008.02.08.23.24.07;	author djm;	state Exp;
branches;
next	1.225;

1.225
date	2008.02.04.21.53.00;	author markus;	state Exp;
branches;
next	1.224;

1.224
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.223;

1.223
date	2007.08.23.02.55.51;	author djm;	state Exp;
branches;
next	1.222;

1.222
date	2007.08.23.02.49.43;	author djm;	state Exp;
branches;
next	1.221;

1.221
date	2007.01.21.01.41.54;	author stevesk;	state Exp;
branches
	1.221.2.1
	1.221.4.1;
next	1.220;

1.220
date	2006.10.09.23.36.11;	author djm;	state Exp;
branches;
next	1.219;

1.219
date	2006.08.29.10.40.19;	author djm;	state Exp;
branches
	1.219.4.1;
next	1.218;

1.218
date	2006.08.18.09.15.20;	author markus;	state Exp;
branches;
next	1.217;

1.217
date	2006.08.04.20.46.05;	author stevesk;	state Exp;
branches;
next	1.216;

1.216
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.215;

1.215
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.214;

1.214
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.213;

1.213
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.212;

1.212
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.211;

1.211
date	2006.07.20.15.26.15;	author stevesk;	state Exp;
branches;
next	1.210;

1.210
date	2006.07.19.13.07.10;	author dtucker;	state Exp;
branches;
next	1.209;

1.209
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.208;

1.208
date	2006.07.11.18.50.48;	author markus;	state Exp;
branches;
next	1.207;

1.207
date	2006.07.08.21.48.53;	author stevesk;	state Exp;
branches;
next	1.206;

1.206
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.205;

1.205
date	2006.07.06.10.47.05;	author djm;	state Exp;
branches;
next	1.204;

1.204
date	2006.07.02.22.45.59;	author stevesk;	state Exp;
branches;
next	1.203;

1.203
date	2006.04.20.21.53.44;	author djm;	state Exp;
branches;
next	1.202;

1.202
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.201;

1.201
date	2006.03.25.01.13.23;	author djm;	state Exp;
branches;
next	1.200;

1.200
date	2006.03.20.18.26.55;	author deraadt;	state Exp;
branches;
next	1.199;

1.199
date	2006.03.19.18.53.12;	author deraadt;	state Exp;
branches;
next	1.198;

1.198
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.197;

1.197
date	2006.02.28.01.10.21;	author djm;	state Exp;
branches
	1.197.2.1;
next	1.196;

1.196
date	2006.02.20.17.19.54;	author stevesk;	state Exp;
branches;
next	1.195;

1.195
date	2006.02.20.17.02.44;	author stevesk;	state Exp;
branches;
next	1.194;

1.194
date	2006.02.20.16.36.14;	author stevesk;	state Exp;
branches;
next	1.193;

1.193
date	2006.02.10.01.44.27;	author stevesk;	state Exp;
branches;
next	1.192;

1.192
date	2006.02.08.12.15.27;	author stevesk;	state Exp;
branches;
next	1.191;

1.191
date	2005.12.24.02.27.41;	author djm;	state Exp;
branches;
next	1.190;

1.190
date	2005.12.17.21.13.05;	author stevesk;	state Exp;
branches;
next	1.189;

1.189
date	2005.12.12.13.46.18;	author markus;	state Exp;
branches;
next	1.188;

1.188
date	2005.10.30.08.52.17;	author djm;	state Exp;
branches;
next	1.187;

1.187
date	2005.10.10.10.23.08;	author djm;	state Exp;
branches;
next	1.186;

1.186
date	2005.07.25.11.59.40;	author markus;	state Exp;
branches
	1.186.2.1;
next	1.185;

1.185
date	2005.07.17.07.17.55;	author djm;	state Exp;
branches;
next	1.184;

1.184
date	2005.07.17.06.49.04;	author djm;	state Exp;
branches;
next	1.183;

1.183
date	2005.07.16.01.35.24;	author djm;	state Exp;
branches;
next	1.182;

1.182
date	2005.06.17.02.44.33;	author djm;	state Exp;
branches;
next	1.181;

1.181
date	2004.12.23.17.35.48;	author markus;	state Exp;
branches
	1.181.2.1;
next	1.180;

1.180
date	2004.07.28.09.40.29;	author markus;	state Exp;
branches
	1.180.2.1;
next	1.179;

1.179
date	2004.07.17.05.31.41;	author dtucker;	state Exp;
branches;
next	1.178;

1.178
date	2004.07.11.17.48.47;	author deraadt;	state Exp;
branches;
next	1.177;

1.177
date	2004.06.30.08.36.59;	author djm;	state Exp;
branches;
next	1.176;

1.176
date	2004.06.21.17.53.03;	author djm;	state Exp;
branches;
next	1.175;

1.175
date	2004.05.11.19.01.43;	author deraadt;	state Exp;
branches;
next	1.174;

1.174
date	2004.05.09.01.19.28;	author djm;	state Exp;
branches;
next	1.173;

1.173
date	2004.04.27.09.46.37;	author djm;	state Exp;
branches;
next	1.172;

1.172
date	2004.01.30.09.48.57;	author markus;	state Exp;
branches
	1.172.2.1;
next	1.171;

1.171
date	2004.01.13.19.23.15;	author markus;	state Exp;
branches;
next	1.170;

1.170
date	2003.12.23.16.12.10;	author jakob;	state Exp;
branches;
next	1.169;

1.169
date	2003.12.02.17.01.15;	author markus;	state Exp;
branches;
next	1.168;

1.168
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches;
next	1.167;

1.167
date	2003.11.04.08.54.09;	author djm;	state Exp;
branches;
next	1.166;

1.166
date	2003.10.14.19.54.39;	author markus;	state Exp;
branches;
next	1.165;

1.165
date	2003.09.23.20.17.11;	author markus;	state Exp;
branches;
next	1.164;

1.164
date	2003.09.18.08.49.45;	author markus;	state Exp;
branches;
next	1.163;

1.163
date	2003.08.31.13.29.05;	author markus;	state Exp;
branches
	1.163.2.1;
next	1.162;

1.162
date	2003.08.28.12.54.34;	author markus;	state Exp;
branches;
next	1.161;

1.161
date	2003.08.22.10.56.09;	author markus;	state Exp;
branches;
next	1.160;

1.160
date	2003.08.13.08.33.02;	author markus;	state Exp;
branches;
next	1.159;

1.159
date	2003.07.22.13.35.22;	author markus;	state Exp;
branches;
next	1.158;

1.158
date	2003.06.02.09.17.34;	author markus;	state Exp;
branches;
next	1.157;

1.157
date	2003.05.14.22.24.42;	author markus;	state Exp;
branches;
next	1.156;

1.156
date	2003.05.11.20.30.25;	author markus;	state Exp;
branches;
next	1.155;

1.155
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches;
next	1.154;

1.154
date	2003.03.05.22.33.43;	author markus;	state Exp;
branches
	1.154.2.1;
next	1.153;

1.153
date	2003.02.06.09.26.23;	author markus;	state Exp;
branches;
next	1.152;

1.152
date	2002.12.10.08.56.00;	author markus;	state Exp;
branches;
next	1.151;

1.151
date	2002.12.04.04.36.47;	author stevesk;	state Exp;
branches;
next	1.150;

1.150
date	2002.09.16.19.55.33;	author stevesk;	state Exp;
branches
	1.150.2.1;
next	1.149;

1.149
date	2002.09.12.19.50.36;	author stevesk;	state Exp;
branches;
next	1.148;

1.148
date	2002.08.29.15.57.25;	author stevesk;	state Exp;
branches;
next	1.147;

1.147
date	2002.08.22.21.45.41;	author markus;	state Exp;
branches;
next	1.146;

1.146
date	2002.07.30.17.03.55;	author markus;	state Exp;
branches;
next	1.145;

1.145
date	2002.07.22.11.03.06;	author markus;	state Exp;
branches;
next	1.144;

1.144
date	2002.07.19.15.43.33;	author markus;	state Exp;
branches;
next	1.143;

1.143
date	2002.06.30.21.54.16;	author deraadt;	state Exp;
branches;
next	1.142;

1.142
date	2002.06.26.13.49.26;	author deraadt;	state Exp;
branches;
next	1.141;

1.141
date	2002.06.26.08.58.26;	author markus;	state Exp;
branches;
next	1.140;

1.140
date	2002.06.23.21.06.41;	author deraadt;	state Exp;
branches;
next	1.139;

1.139
date	2002.06.23.20.39.45;	author deraadt;	state Exp;
branches;
next	1.138;

1.138
date	2002.06.20.23.05.55;	author markus;	state Exp;
branches;
next	1.137;

1.137
date	2002.06.11.05.46.20;	author mpech;	state Exp;
branches;
next	1.136;

1.136
date	2002.06.10.22.28.41;	author markus;	state Exp;
branches;
next	1.135;

1.135
date	2002.05.16.22.09.59;	author stevesk;	state Exp;
branches;
next	1.134;

1.134
date	2002.03.29.18.59.31;	author markus;	state Exp;
branches
	1.134.2.1;
next	1.133;

1.133
date	2002.03.28.15.34.51;	author markus;	state Exp;
branches;
next	1.132;

1.132
date	2002.03.19.10.49.35;	author markus;	state Exp;
branches;
next	1.131;

1.131
date	2002.03.19.10.35.39;	author markus;	state Exp;
branches;
next	1.130;

1.130
date	2002.03.18.17.50.31;	author provos;	state Exp;
branches;
next	1.129;

1.129
date	2002.03.18.03.41.08;	author provos;	state Exp;
branches;
next	1.128;

1.128
date	2002.02.16.00.51.44;	author markus;	state Exp;
branches;
next	1.127;

1.127
date	2002.02.15.23.11.26;	author markus;	state Exp;
branches;
next	1.126;

1.126
date	2002.02.14.23.28.00;	author markus;	state Exp;
branches;
next	1.125;

1.125
date	2002.02.09.17.37.34;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2002.02.06.14.37.22;	author markus;	state Exp;
branches;
next	1.123;

1.123
date	2002.02.03.17.53.25;	author markus;	state Exp;
branches;
next	1.122;

1.122
date	2002.01.29.22.46.41;	author markus;	state Exp;
branches;
next	1.121;

1.121
date	2002.01.29.16.29.02;	author stevesk;	state Exp;
branches;
next	1.120;

1.120
date	2002.01.29.14.32.03;	author markus;	state Exp;
branches;
next	1.119;

1.119
date	2002.01.27.14.57.46;	author stevesk;	state Exp;
branches;
next	1.118;

1.118
date	2002.01.26.16.44.22;	author stevesk;	state Exp;
branches;
next	1.117;

1.117
date	2001.12.28.14.50.54;	author markus;	state Exp;
branches;
next	1.116;

1.116
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.115;

1.115
date	2001.12.27.20.39.58;	author markus;	state Exp;
branches;
next	1.114;

1.114
date	2001.12.20.16.37.29;	author markus;	state Exp;
branches;
next	1.113;

1.113
date	2001.12.19.15.43.11;	author stevesk;	state Exp;
branches;
next	1.112;

1.112
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2001.12.06.18.09.23;	author stevesk;	state Exp;
branches;
next	1.110;

1.110
date	2001.12.01.21.41.48;	author markus;	state Exp;
branches;
next	1.109;

1.109
date	2001.11.29.21.10.51;	author stevesk;	state Exp;
branches;
next	1.108;

1.108
date	2001.10.11.13.45.21;	author markus;	state Exp;
branches
	1.108.2.1;
next	1.107;

1.107
date	2001.10.10.22.18.47;	author markus;	state Exp;
branches;
next	1.106;

1.106
date	2001.10.09.21.59.41;	author markus;	state Exp;
branches;
next	1.105;

1.105
date	2001.10.09.19.32.49;	author markus;	state Exp;
branches;
next	1.104;

1.104
date	2001.10.09.10.12.08;	author markus;	state Exp;
branches;
next	1.103;

1.103
date	2001.10.06.00.36.42;	author markus;	state Exp;
branches;
next	1.102;

1.102
date	2001.09.16.14.46.54;	author markus;	state Exp;
branches;
next	1.101;

1.101
date	2001.09.14.18.59.11;	author markus;	state Exp;
branches;
next	1.100;

1.100
date	2001.08.16.19.18.34;	author jakob;	state Exp;
branches;
next	1.99;

1.99
date	2001.07.09.07.04.53;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2001.07.02.13.59.15;	author markus;	state Exp;
branches;
next	1.97;

1.97
date	2001.06.27.02.12.53;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2001.06.26.16.15.24;	author dugsong;	state Exp;
branches;
next	1.95;

1.95
date	2001.06.25.08.25.39;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2001.06.23.15.12.20;	author itojun;	state Exp;
branches;
next	1.93;

1.93
date	2001.06.21.21.08.25;	author markus;	state Exp;
branches;
next	1.92;

1.92
date	2001.06.19.15.40.45;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2001.06.19.14.09.45;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2001.06.19.12.34.09;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2001.06.13.09.10.31;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2001.06.12.21.30.57;	author markus;	state Exp;
branches;
next	1.87;

1.87
date	2001.06.12.21.21.29;	author markus;	state Exp;
branches;
next	1.86;

1.86
date	2001.06.12.16.10.38;	author markus;	state Exp;
branches;
next	1.85;

1.85
date	2001.06.12.10.58.29;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2001.06.11.10.18.24;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2001.06.07.22.25.02;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2001.06.05.16.46.19;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2001.06.04.23.16.16;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2001.06.04.21.59.43;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2001.06.03.14.55.39;	author markus;	state Exp;
branches;
next	1.78;

1.78
date	2001.05.31.10.30.16;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2001.05.30.12.55.13;	author markus;	state Exp;
branches;
next	1.76;

1.76
date	2001.05.19.00.36.40;	author djm;	state Exp;
branches;
next	1.75;

1.75
date	2001.05.03.15.45.15;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2001.04.17.19.34.25;	author markus;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2001.04.16.08.19.31;	author djm;	state Exp;
branches;
next	1.72;

1.72
date	2001.04.14.16.33.20;	author stevesk;	state Exp;
branches;
next	1.71;

1.71
date	2001.04.06.21.00.12;	author markus;	state Exp;
branches;
next	1.70;

1.70
date	2001.04.05.15.48.18;	author stevesk;	state Exp;
branches;
next	1.69;

1.69
date	2001.03.25.13.16.11;	author stevesk;	state Exp;
branches;
next	1.68;

1.68
date	2001.03.25.00.01.34;	author djm;	state Exp;
branches;
next	1.67;

1.67
date	2001.03.23.14.28.32;	author markus;	state Exp;
branches;
next	1.66;

1.66
date	2001.03.21.21.06.30;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2001.03.21.11.43.44;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2001.03.20.19.35.29;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2001.03.20.19.21.21;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2001.03.20.18.57.04;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2001.03.16.19.06.30;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2001.03.15.22.07.08;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2001.03.04.01.46.30;	author djm;	state Exp;
branches;
next	1.58;

1.58
date	2001.03.02.18.54.31;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2001.02.23.15.37.45;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2001.02.16.14.03.43;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2001.02.08.19.30.52;	author itojun;	state Exp;
branches;
next	1.54;

1.54
date	2001.02.08.17.11.23;	author stevesk;	state Exp;
branches;
next	1.53;

1.53
date	2001.02.04.15.32.25;	author stevesk;	state Exp;
branches;
next	1.52;

1.52
date	2001.02.03.10.08.37;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2001.01.21.19.05.56;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2001.01.19.15.55.11;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2001.01.18.17.00.00;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2001.01.13.18.43.31;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2001.01.13.18.32.50;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2001.01.04.22.41.03;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2000.12.19.23.17.58;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2000.11.14.23.44.19;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2000.11.06.23.04.56;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2000.10.27.07.32.18;	author markus;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2000.10.18.18.42.00;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2000.10.15.14.14.01;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2000.10.14.12.12.09;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2000.10.11.20.27.23;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2000.09.07.20.27.53;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2000.09.05.08.59.57;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.04.19.07.21;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.04.19.06.03;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.04.19.03.40;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.31.22.05.42;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.28.03.50.54;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.25.16.10.05;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.21.16.23.31;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2000.08.20.18.42.40;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.20.18.30.59;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.20.18.25.53;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.17.20.06.34;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2000.08.17.20.05.10;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.11.08.11.33;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.05.20.18.07;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.26.21.59.18;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.18.04.42.54;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.18.04.05.02;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.17.22.52.33;	author jakob;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.05.19.53.40;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2000.05.31.06.36.40;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.30.17.23.37;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.25.03.10.18;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.22.16.51.44;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.03.18.03.07;	author markus;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.05.02.12.44.38;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.02.08.05.32;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.02.07.32.44;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.29.16.06.08;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.28.08.10.20;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.27.15.23.02;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.19.09.24.39;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.14.10.30.33;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.14.10.09.16;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.06.08.55.22;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.28.21.15.45;	author markus;	state Exp;
branches;
next	;

1.12.2.1
date	2000.06.12.02.37.35;	author jason;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2000.09.01.18.23.22;	author jason;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2000.11.08.21.31.14;	author jason;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2001.03.12.15.44.14;	author jason;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2001.03.21.18.53.03;	author jason;	state Exp;
branches;
next	;

1.42.2.1
date	2001.02.16.20.13.13;	author jason;	state Exp;
branches;
next	1.42.2.2;

1.42.2.2
date	2001.02.19.17.19.21;	author jason;	state Exp;
branches;
next	1.42.2.3;

1.42.2.3
date	2001.03.21.19.46.28;	author jason;	state Exp;
branches;
next	1.42.2.4;

1.42.2.4
date	2001.05.07.21.09.33;	author jason;	state Exp;
branches;
next	1.42.2.5;

1.42.2.5
date	2001.06.12.22.47.36;	author miod;	state Exp;
branches;
next	1.42.2.6;

1.42.2.6
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.42.2.7;

1.42.2.7
date	2001.11.15.00.15.00;	author miod;	state Exp;
branches;
next	1.42.2.8;

1.42.2.8
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.74.2.1
date	2001.06.12.22.31.48;	author jason;	state Exp;
branches;
next	1.74.2.2;

1.74.2.2
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.74.2.3;

1.74.2.3
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.74.2.4;

1.74.2.4
date	2001.12.03.00.36.34;	author miod;	state Exp;
branches;
next	1.74.2.5;

1.74.2.5
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	1.74.2.6;

1.74.2.6
date	2002.06.02.22.56.11;	author miod;	state Exp;
branches;
next	;

1.108.2.1
date	2001.12.05.19.31.48;	author jason;	state Exp;
branches;
next	1.108.2.2;

1.108.2.2
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.108.2.3;

1.108.2.3
date	2002.03.08.15.17.18;	author brad;	state Exp;
branches;
next	1.108.2.4;

1.108.2.4
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.108.2.5;

1.108.2.5
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.108.2.6;

1.108.2.6
date	2002.06.26.18.22.35;	author miod;	state Exp;
branches;
next	1.108.2.7;

1.108.2.7
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.134.2.1
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.134.2.2;

1.134.2.2
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.134.2.3;

1.134.2.3
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.150.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.150.2.2;

1.150.2.2
date	2003.09.16.21.20.27;	author brad;	state Exp;
branches;
next	;

1.154.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.154.2.2;

1.154.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.163.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.163.2.2;

1.163.2.2
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.172.2.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	1.172.2.2;

1.172.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.180.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.180.2.2;

1.180.2.2
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.181.2.1
date	2005.09.04.18.40.03;	author brad;	state Exp;
branches;
next	1.181.2.2;

1.181.2.2
date	2006.02.03.02.53.45;	author brad;	state Exp;
branches;
next	;

1.186.2.1
date	2006.02.03.03.01.57;	author brad;	state Exp;
branches;
next	1.186.2.2;

1.186.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	1.186.2.3;

1.186.2.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.197.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	1.197.2.2;

1.197.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.219.4.1
date	2006.11.08.00.42.10;	author brad;	state Exp;
branches;
next	;

1.221.2.1
date	2008.03.31.01.07.59;	author brad;	state Exp;
branches;
next	;

1.221.4.1
date	2008.03.31.01.12.07;	author brad;	state Exp;
branches;
next	;

1.230.2.1
date	2008.03.31.01.14.45;	author brad;	state Exp;
branches;
next	;

1.277.2.1
date	2016.03.10.11.53.34;	author djm;	state Exp;
branches;
next	;
commitid	vyP3g0KkyGHjLn64;

1.278.2.1
date	2016.03.10.11.54.22;	author djm;	state Exp;
branches;
next	;
commitid	RHl1ZFSHZMn0dwUr;

1.280.2.1
date	2016.03.10.11.55.43;	author djm;	state Exp;
branches;
next	;
commitid	c1TZUbcM2tXW9IKe;


desc
@@


1.286
log
@Add a sshd_config DisableForwaring option that disables X11, agent,
TCP, tunnel and Unix domain socket forwarding, as well as anything
else we might implement in the future.

This, like the 'restrict' authorized_keys flag, is intended to be a
simple and future-proof way of restricting an account. Suggested as
a complement to 'restrict' by Jann Horn; ok markus@@
@
text
@/* $OpenBSD: session.c,v 1.285 2016/08/23 16:21:45 otto Exp $ */
/*
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 * SSH2 support by Markus Friedl.
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/queue.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <grp.h>
#include <login_cap.h>
#include <netdb.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "xmalloc.h"
#include "ssh.h"
#include "ssh2.h"
#include "sshpty.h"
#include "packet.h"
#include "buffer.h"
#include "match.h"
#include "uidswap.h"
#include "compat.h"
#include "channels.h"
#include "key.h"
#include "cipher.h"
#include "kex.h"
#include "hostfile.h"
#include "auth.h"
#include "auth-options.h"
#include "authfd.h"
#include "pathnames.h"
#include "log.h"
#include "misc.h"
#include "servconf.h"
#include "sshlogin.h"
#include "serverloop.h"
#include "canohost.h"
#include "session.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"
#include "sftp.h"

#ifdef KRB5
#include <kafs.h>
#endif

#define IS_INTERNAL_SFTP(c) \
	(!strncmp(c, INTERNAL_SFTP_NAME, sizeof(INTERNAL_SFTP_NAME) - 1) && \
	 (c[sizeof(INTERNAL_SFTP_NAME) - 1] == '\0' || \
	  c[sizeof(INTERNAL_SFTP_NAME) - 1] == ' ' || \
	  c[sizeof(INTERNAL_SFTP_NAME) - 1] == '\t'))

/* func */

Session *session_new(void);
void	session_set_fds(Session *, int, int, int, int, int);
void	session_pty_cleanup(Session *);
void	session_proctitle(Session *);
int	session_setup_x11fwd(Session *);
int	do_exec_pty(Session *, const char *);
int	do_exec_no_pty(Session *, const char *);
int	do_exec(Session *, const char *);
void	do_login(Session *, const char *);
void	do_child(Session *, const char *);
void	do_motd(void);
int	check_quietlogin(Session *, const char *);

static void do_authenticated2(Authctxt *);

static int session_pty_req(Session *);

/* import */
extern ServerOptions options;
extern char *__progname;
extern int log_stderr;
extern int debug_flag;
extern u_int utmp_len;
extern int startup_pipe;
extern void destroy_sensitive_data(void);
extern Buffer loginmsg;

/* original command from peer. */
const char *original_command = NULL;

/* data */
static int sessions_first_unused = -1;
static int sessions_nalloc = 0;
static Session *sessions = NULL;

#define SUBSYSTEM_NONE			0
#define SUBSYSTEM_EXT			1
#define SUBSYSTEM_INT_SFTP		2
#define SUBSYSTEM_INT_SFTP_ERROR	3

login_cap_t *lc;

static int is_child = 0;
static int in_chroot = 0;

/* Name and directory of socket for authentication agent forwarding. */
static char *auth_sock_name = NULL;
static char *auth_sock_dir = NULL;

/* removes the agent forwarding socket */

static void
auth_sock_cleanup_proc(struct passwd *pw)
{
	if (auth_sock_name != NULL) {
		temporarily_use_uid(pw);
		unlink(auth_sock_name);
		rmdir(auth_sock_dir);
		auth_sock_name = NULL;
		restore_uid();
	}
}

static int
auth_input_request_forwarding(struct passwd * pw)
{
	Channel *nc;
	int sock = -1;

	if (auth_sock_name != NULL) {
		error("authentication forwarding requested twice.");
		return 0;
	}

	/* Temporarily drop privileged uid for mkdir/bind. */
	temporarily_use_uid(pw);

	/* Allocate a buffer for the socket name, and format the name. */
	auth_sock_dir = xstrdup("/tmp/ssh-XXXXXXXXXX");

	/* Create private directory for socket */
	if (mkdtemp(auth_sock_dir) == NULL) {
		packet_send_debug("Agent forwarding disabled: "
		    "mkdtemp() failed: %.100s", strerror(errno));
		restore_uid();
		free(auth_sock_dir);
		auth_sock_dir = NULL;
		goto authsock_err;
	}

	xasprintf(&auth_sock_name, "%s/agent.%ld",
	    auth_sock_dir, (long) getpid());

	/* Start a Unix listener on auth_sock_name. */
	sock = unix_listener(auth_sock_name, SSH_LISTEN_BACKLOG, 0);

	/* Restore the privileged uid. */
	restore_uid();

	/* Check for socket/bind/listen failure. */
	if (sock < 0)
		goto authsock_err;

	/* Allocate a channel for the authentication agent socket. */
	nc = channel_new("auth socket",
	    SSH_CHANNEL_AUTH_SOCKET, sock, sock, -1,
	    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,
	    0, "auth socket", 1);
	nc->path = xstrdup(auth_sock_name);
	return 1;

 authsock_err:
	free(auth_sock_name);
	if (auth_sock_dir != NULL) {
		rmdir(auth_sock_dir);
		free(auth_sock_dir);
	}
	if (sock != -1)
		close(sock);
	auth_sock_name = NULL;
	auth_sock_dir = NULL;
	return 0;
}

static void
display_loginmsg(void)
{
	if (buffer_len(&loginmsg) > 0) {
		buffer_append(&loginmsg, "\0", 1);
		printf("%s", (char *)buffer_ptr(&loginmsg));
		buffer_clear(&loginmsg);
	}
}

void
do_authenticated(Authctxt *authctxt)
{
	setproctitle("%s", authctxt->pw->pw_name);

	/* setup the channel layer */
	/* XXX - streamlocal? */
	if (no_port_forwarding_flag || options.disable_forwarding ||
	    (options.allow_tcp_forwarding & FORWARD_LOCAL) == 0)
		channel_disable_adm_local_opens();
	else
		channel_permit_all_opens();

	auth_debug_send();

	do_authenticated2(authctxt);
	do_cleanup(authctxt);
}

/* Check untrusted xauth strings for metacharacters */
static int
xauth_valid_string(const char *s)
{
	size_t i;

	for (i = 0; s[i] != '\0'; i++) {
		if (!isalnum((u_char)s[i]) &&
		    s[i] != '.' && s[i] != ':' && s[i] != '/' &&
		    s[i] != '-' && s[i] != '_')
		return 0;
	}
	return 1;
}

#define USE_PIPES 1
/*
 * This is called to fork and execute a command when we have no tty.  This
 * will call do_child from the child, and server_loop from the parent after
 * setting up file descriptors and such.
 */
int
do_exec_no_pty(Session *s, const char *command)
{
	pid_t pid;
#ifdef USE_PIPES
	int pin[2], pout[2], perr[2];

	if (s == NULL)
		fatal("do_exec_no_pty: no session");

	/* Allocate pipes for communicating with the program. */
	if (pipe(pin) < 0) {
		error("%s: pipe in: %.100s", __func__, strerror(errno));
		return -1;
	}
	if (pipe(pout) < 0) {
		error("%s: pipe out: %.100s", __func__, strerror(errno));
		close(pin[0]);
		close(pin[1]);
		return -1;
	}
	if (pipe(perr) < 0) {
		error("%s: pipe err: %.100s", __func__,
		    strerror(errno));
		close(pin[0]);
		close(pin[1]);
		close(pout[0]);
		close(pout[1]);
		return -1;
	}
#else
	int inout[2], err[2];

	if (s == NULL)
		fatal("do_exec_no_pty: no session");

	/* Uses socket pairs to communicate with the program. */
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) < 0) {
		error("%s: socketpair #1: %.100s", __func__, strerror(errno));
		return -1;
	}
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, err) < 0) {
		error("%s: socketpair #2: %.100s", __func__,
		    strerror(errno));
		close(inout[0]);
		close(inout[1]);
		return -1;
	}
#endif

	session_proctitle(s);

	/* Fork the child. */
	switch ((pid = fork())) {
	case -1:
		error("%s: fork: %.100s", __func__, strerror(errno));
#ifdef USE_PIPES
		close(pin[0]);
		close(pin[1]);
		close(pout[0]);
		close(pout[1]);
		close(perr[0]);
		close(perr[1]);
#else
		close(inout[0]);
		close(inout[1]);
		close(err[0]);
		close(err[1]);
#endif
		return -1;
	case 0:
		is_child = 1;

		/* Child.  Reinitialize the log since the pid has changed. */
		log_init(__progname, options.log_level,
		    options.log_facility, log_stderr);

		/*
		 * Create a new session and process group since the 4.4BSD
		 * setlogin() affects the entire process group.
		 */
		if (setsid() < 0)
			error("setsid failed: %.100s", strerror(errno));

#ifdef USE_PIPES
		/*
		 * Redirect stdin.  We close the parent side of the socket
		 * pair, and make the child side the standard input.
		 */
		close(pin[1]);
		if (dup2(pin[0], 0) < 0)
			perror("dup2 stdin");
		close(pin[0]);

		/* Redirect stdout. */
		close(pout[0]);
		if (dup2(pout[1], 1) < 0)
			perror("dup2 stdout");
		close(pout[1]);

		/* Redirect stderr. */
		close(perr[0]);
		if (dup2(perr[1], 2) < 0)
			perror("dup2 stderr");
		close(perr[1]);
#else
		/*
		 * Redirect stdin, stdout, and stderr.  Stdin and stdout will
		 * use the same socket, as some programs (particularly rdist)
		 * seem to depend on it.
		 */
		close(inout[1]);
		close(err[1]);
		if (dup2(inout[0], 0) < 0)	/* stdin */
			perror("dup2 stdin");
		if (dup2(inout[0], 1) < 0)	/* stdout (same as stdin) */
			perror("dup2 stdout");
		close(inout[0]);
		if (dup2(err[0], 2) < 0)	/* stderr */
			perror("dup2 stderr");
		close(err[0]);
#endif

		/* Do processing for the child (exec command etc). */
		do_child(s, command);
		/* NOTREACHED */
	default:
		break;
	}

	s->pid = pid;
	/* Set interactive/non-interactive mode. */
	packet_set_interactive(s->display != NULL,
	    options.ip_qos_interactive, options.ip_qos_bulk);

#ifdef USE_PIPES
	/* We are the parent.  Close the child sides of the pipes. */
	close(pin[0]);
	close(pout[1]);
	close(perr[1]);

	session_set_fds(s, pin[1], pout[0], perr[0],
	    s->is_subsystem, 0);
#else
	/* We are the parent.  Close the child sides of the socket pairs. */
	close(inout[0]);
	close(err[0]);

	/*
	 * Enter the interactive session.  Note: server_loop must be able to
	 * handle the case that fdin and fdout are the same.
	 */
	session_set_fds(s, inout[1], inout[1], err[1],
	    s->is_subsystem, 0);
#endif
	return 0;
}

/*
 * This is called to fork and execute a command when we have a tty.  This
 * will call do_child from the child, and server_loop from the parent after
 * setting up file descriptors, controlling tty, updating wtmp, utmp,
 * lastlog, and other such operations.
 */
int
do_exec_pty(Session *s, const char *command)
{
	int fdout, ptyfd, ttyfd, ptymaster;
	pid_t pid;

	if (s == NULL)
		fatal("do_exec_pty: no session");
	ptyfd = s->ptyfd;
	ttyfd = s->ttyfd;

	/*
	 * Create another descriptor of the pty master side for use as the
	 * standard input.  We could use the original descriptor, but this
	 * simplifies code in server_loop.  The descriptor is bidirectional.
	 * Do this before forking (and cleanup in the child) so as to
	 * detect and gracefully fail out-of-fd conditions.
	 */
	if ((fdout = dup(ptyfd)) < 0) {
		error("%s: dup #1: %s", __func__, strerror(errno));
		close(ttyfd);
		close(ptyfd);
		return -1;
	}
	/* we keep a reference to the pty master */
	if ((ptymaster = dup(ptyfd)) < 0) {
		error("%s: dup #2: %s", __func__, strerror(errno));
		close(ttyfd);
		close(ptyfd);
		close(fdout);
		return -1;
	}

	/* Fork the child. */
	switch ((pid = fork())) {
	case -1:
		error("%s: fork: %.100s", __func__, strerror(errno));
		close(fdout);
		close(ptymaster);
		close(ttyfd);
		close(ptyfd);
		return -1;
	case 0:
		is_child = 1;

		close(fdout);
		close(ptymaster);

		/* Child.  Reinitialize the log because the pid has changed. */
		log_init(__progname, options.log_level,
		    options.log_facility, log_stderr);
		/* Close the master side of the pseudo tty. */
		close(ptyfd);

		/* Make the pseudo tty our controlling tty. */
		pty_make_controlling_tty(&ttyfd, s->tty);

		/* Redirect stdin/stdout/stderr from the pseudo tty. */
		if (dup2(ttyfd, 0) < 0)
			error("dup2 stdin: %s", strerror(errno));
		if (dup2(ttyfd, 1) < 0)
			error("dup2 stdout: %s", strerror(errno));
		if (dup2(ttyfd, 2) < 0)
			error("dup2 stderr: %s", strerror(errno));

		/* Close the extra descriptor for the pseudo tty. */
		close(ttyfd);

		/* record login, etc. similar to login(1) */
		do_login(s, command);

		/*
		 * Do common processing for the child, such as execing
		 * the command.
		 */
		do_child(s, command);
		/* NOTREACHED */
	default:
		break;
	}
	s->pid = pid;

	/* Parent.  Close the slave side of the pseudo tty. */
	close(ttyfd);

	/* Enter interactive session. */
	s->ptymaster = ptymaster;
	packet_set_interactive(1, 
	    options.ip_qos_interactive, options.ip_qos_bulk);
	session_set_fds(s, ptyfd, fdout, -1, 1, 1);
	return 0;
}

/*
 * This is called to fork and execute a command.  If another command is
 * to be forced, execute that instead.
 */
int
do_exec(Session *s, const char *command)
{
	struct ssh *ssh = active_state; /* XXX */
	int ret;
	const char *forced = NULL, *tty = NULL;
	char session_type[1024];

	if (options.adm_forced_command) {
		original_command = command;
		command = options.adm_forced_command;
		forced = "(config)";
	} else if (forced_command) {
		original_command = command;
		command = forced_command;
		forced = "(key-option)";
	}
	if (forced != NULL) {
		if (IS_INTERNAL_SFTP(command)) {
			s->is_subsystem = s->is_subsystem ?
			    SUBSYSTEM_INT_SFTP : SUBSYSTEM_INT_SFTP_ERROR;
		} else if (s->is_subsystem)
			s->is_subsystem = SUBSYSTEM_EXT;
		snprintf(session_type, sizeof(session_type),
		    "forced-command %s '%.900s'", forced, command);
	} else if (s->is_subsystem) {
		snprintf(session_type, sizeof(session_type),
		    "subsystem '%.900s'", s->subsys);
	} else if (command == NULL) {
		snprintf(session_type, sizeof(session_type), "shell");
	} else {
		/* NB. we don't log unforced commands to preserve privacy */
		snprintf(session_type, sizeof(session_type), "command");
	}

	if (s->ttyfd != -1) {
		tty = s->tty;
		if (strncmp(tty, "/dev/", 5) == 0)
			tty += 5;
	}

	verbose("Starting session: %s%s%s for %s from %.200s port %d id %d",
	    session_type,
	    tty == NULL ? "" : " on ",
	    tty == NULL ? "" : tty,
	    s->pw->pw_name,
	    ssh_remote_ipaddr(ssh),
	    ssh_remote_port(ssh),
	    s->self);

#ifdef GSSAPI
	if (options.gss_authentication) {
		temporarily_use_uid(s->pw);
		ssh_gssapi_storecreds();
		restore_uid();
	}
#endif
	if (s->ttyfd != -1)
		ret = do_exec_pty(s, command);
	else
		ret = do_exec_no_pty(s, command);

	original_command = NULL;

	/*
	 * Clear loginmsg: it's the child's responsibility to display
	 * it to the user, otherwise multiple sessions may accumulate
	 * multiple copies of the login messages.
	 */
	buffer_clear(&loginmsg);

	return ret;
}


/* administrative, login(1)-like work */
void
do_login(Session *s, const char *command)
{
	struct ssh *ssh = active_state;	/* XXX */
	socklen_t fromlen;
	struct sockaddr_storage from;
	struct passwd * pw = s->pw;
	pid_t pid = getpid();

	/*
	 * Get IP address of client. If the connection is not a socket, let
	 * the address be 0.0.0.0.
	 */
	memset(&from, 0, sizeof(from));
	fromlen = sizeof(from);
	if (packet_connection_is_on_socket()) {
		if (getpeername(packet_get_connection_in(),
		    (struct sockaddr *)&from, &fromlen) < 0) {
			debug("getpeername: %.100s", strerror(errno));
			cleanup_exit(255);
		}
	}

	/* Record that there was a login on that tty from the remote host. */
	if (!use_privsep)
		record_login(pid, s->tty, pw->pw_name, pw->pw_uid,
		    session_get_remote_name_or_ip(ssh, utmp_len,
		    options.use_dns),
		    (struct sockaddr *)&from, fromlen);

	if (check_quietlogin(s, command))
		return;

	display_loginmsg();

	do_motd();
}

/*
 * Display the message of the day.
 */
void
do_motd(void)
{
	FILE *f;
	char buf[256];

	if (options.print_motd) {
		f = fopen(login_getcapstr(lc, "welcome", "/etc/motd",
		    "/etc/motd"), "r");
		if (f) {
			while (fgets(buf, sizeof(buf), f))
				fputs(buf, stdout);
			fclose(f);
		}
	}
}


/*
 * Check for quiet login, either .hushlogin or command given.
 */
int
check_quietlogin(Session *s, const char *command)
{
	char buf[256];
	struct passwd *pw = s->pw;
	struct stat st;

	/* Return 1 if .hushlogin exists or a command given. */
	if (command != NULL)
		return 1;
	snprintf(buf, sizeof(buf), "%.200s/.hushlogin", pw->pw_dir);
	if (login_getcapbool(lc, "hushlogin", 0) || stat(buf, &st) >= 0)
		return 1;
	return 0;
}

/*
 * Sets the value of the given variable in the environment.  If the variable
 * already exists, its value is overridden.
 */
void
child_set_env(char ***envp, u_int *envsizep, const char *name,
	const char *value)
{
	char **env;
	u_int envsize;
	u_int i, namelen;

	if (strchr(name, '=') != NULL) {
		error("Invalid environment variable \"%.100s\"", name);
		return;
	}

	/*
	 * Find the slot where the value should be stored.  If the variable
	 * already exists, we reuse the slot; otherwise we append a new slot
	 * at the end of the array, expanding if necessary.
	 */
	env = *envp;
	namelen = strlen(name);
	for (i = 0; env[i]; i++)
		if (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')
			break;
	if (env[i]) {
		/* Reuse the slot. */
		free(env[i]);
	} else {
		/* New variable.  Expand if necessary. */
		envsize = *envsizep;
		if (i >= envsize - 1) {
			if (envsize >= 1000)
				fatal("child_set_env: too many env vars");
			envsize += 50;
			env = (*envp) = xreallocarray(env, envsize, sizeof(char *));
			*envsizep = envsize;
		}
		/* Need to set the NULL pointer at end of array beyond the new slot. */
		env[i + 1] = NULL;
	}

	/* Allocate space and format the variable in the appropriate slot. */
	env[i] = xmalloc(strlen(name) + 1 + strlen(value) + 1);
	snprintf(env[i], strlen(name) + 1 + strlen(value) + 1, "%s=%s", name, value);
}

/*
 * Reads environment variables from the given file and adds/overrides them
 * into the environment.  If the file does not exist, this does nothing.
 * Otherwise, it must consist of empty lines, comments (line starts with '#')
 * and assignments of the form name=value.  No other forms are allowed.
 */
static void
read_environment_file(char ***env, u_int *envsize,
	const char *filename)
{
	FILE *f;
	char buf[4096];
	char *cp, *value;
	u_int lineno = 0;

	f = fopen(filename, "r");
	if (!f)
		return;

	while (fgets(buf, sizeof(buf), f)) {
		if (++lineno > 1000)
			fatal("Too many lines in environment file %s", filename);
		for (cp = buf; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (!*cp || *cp == '#' || *cp == '\n')
			continue;

		cp[strcspn(cp, "\n")] = '\0';

		value = strchr(cp, '=');
		if (value == NULL) {
			fprintf(stderr, "Bad line %u in %.100s\n", lineno,
			    filename);
			continue;
		}
		/*
		 * Replace the equals sign by nul, and advance value to
		 * the value string.
		 */
		*value = '\0';
		value++;
		child_set_env(env, envsize, cp, value);
	}
	fclose(f);
}

static char **
do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	/* Set basic environment. */
	for (i = 0; i < s->num_env; i++)
		child_set_env(&env, &envsize, s->env[i].name, s->env[i].val);

	child_set_env(&env, &envsize, "USER", pw->pw_name);
	child_set_env(&env, &envsize, "LOGNAME", pw->pw_name);
	child_set_env(&env, &envsize, "HOME", pw->pw_dir);
	if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
		child_set_env(&env, &envsize, "PATH", _PATH_STDPATH);
	else
		child_set_env(&env, &envsize, "PATH", getenv("PATH"));

	snprintf(buf, sizeof buf, "%.200s/%.50s", _PATH_MAILDIR, pw->pw_name);
	child_set_env(&env, &envsize, "MAIL", buf);

	/* Normal systems set SHELL by default. */
	child_set_env(&env, &envsize, "SHELL", shell);

	if (getenv("TZ"))
		child_set_env(&env, &envsize, "TZ", getenv("TZ"));

	/* Set custom environment options from RSA authentication. */
	while (custom_environment) {
		struct envstring *ce = custom_environment;
		char *str = ce->s;

		for (i = 0; str[i] != '=' && str[i]; i++)
			;
		if (str[i] == '=') {
			str[i] = 0;
			child_set_env(&env, &envsize, str, str + i + 1);
		}
		custom_environment = ce->next;
		free(ce->s);
		free(ce);
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, "%.50s %d %d",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, "SSH_CLIENT", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, "%.50s %d %.50s %d",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, "SSH_CONNECTION", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, "SSH_TTY", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, "TERM", s->term);
	if (s->display)
		child_set_env(&env, &envsize, "DISPLAY", s->display);
	if (original_command)
		child_set_env(&env, &envsize, "SSH_ORIGINAL_COMMAND",
		    original_command);
#ifdef KRB5
	if (s->authctxt->krb5_ticket_file)
		child_set_env(&env, &envsize, "KRB5CCNAME",
		    s->authctxt->krb5_ticket_file);
#endif
	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env) {
		snprintf(buf, sizeof buf, "%.200s/.ssh/environment",
		    pw->pw_dir);
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, "Environment:\n");
		for (i = 0; env[i]; i++)
			fprintf(stderr, "  %.200s\n", env[i]);
	}
	return env;
}

/*
 * Run $HOME/.ssh/rc, /etc/ssh/sshrc, or xauth (whichever is found
 * first in this order).
 */
static void
do_rc_files(Session *s, const char *shell)
{
	FILE *f = NULL;
	char cmd[1024];
	int do_xauth;
	struct stat st;

	do_xauth =
	    s->display != NULL && s->auth_proto != NULL && s->auth_data != NULL;

	/* ignore _PATH_SSH_USER_RC for subsystems and admin forced commands */
	if (!s->is_subsystem && options.adm_forced_command == NULL &&
	    !no_user_rc && options.permit_user_rc &&
	    stat(_PATH_SSH_USER_RC, &st) >= 0) {
		snprintf(cmd, sizeof cmd, "%s -c '%s %s'",
		    shell, _PATH_BSHELL, _PATH_SSH_USER_RC);
		if (debug_flag)
			fprintf(stderr, "Running %s\n", cmd);
		f = popen(cmd, "w");
		if (f) {
			if (do_xauth)
				fprintf(f, "%s %s\n", s->auth_proto,
				    s->auth_data);
			pclose(f);
		} else
			fprintf(stderr, "Could not run %s\n",
			    _PATH_SSH_USER_RC);
	} else if (stat(_PATH_SSH_SYSTEM_RC, &st) >= 0) {
		if (debug_flag)
			fprintf(stderr, "Running %s %s\n", _PATH_BSHELL,
			    _PATH_SSH_SYSTEM_RC);
		f = popen(_PATH_BSHELL " " _PATH_SSH_SYSTEM_RC, "w");
		if (f) {
			if (do_xauth)
				fprintf(f, "%s %s\n", s->auth_proto,
				    s->auth_data);
			pclose(f);
		} else
			fprintf(stderr, "Could not run %s\n",
			    _PATH_SSH_SYSTEM_RC);
	} else if (do_xauth && options.xauth_location != NULL) {
		/* Add authority data to .Xauthority if appropriate. */
		if (debug_flag) {
			fprintf(stderr,
			    "Running %.500s remove %.100s\n",
			    options.xauth_location, s->auth_display);
			fprintf(stderr,
			    "%.500s add %.100s %.100s %.100s\n",
			    options.xauth_location, s->auth_display,
			    s->auth_proto, s->auth_data);
		}
		snprintf(cmd, sizeof cmd, "%s -q -",
		    options.xauth_location);
		f = popen(cmd, "w");
		if (f) {
			fprintf(f, "remove %s\n",
			    s->auth_display);
			fprintf(f, "add %s %s %s\n",
			    s->auth_display, s->auth_proto,
			    s->auth_data);
			pclose(f);
		} else {
			fprintf(stderr, "Could not run %s\n",
			    cmd);
		}
	}
}

static void
do_nologin(struct passwd *pw)
{
	FILE *f = NULL;
	char buf[1024], *nl, *def_nl = _PATH_NOLOGIN;
	struct stat sb;

	if (login_getcapbool(lc, "ignorenologin", 0) || pw->pw_uid == 0)
		return;
	nl = login_getcapstr(lc, "nologin", def_nl, def_nl);

	if (stat(nl, &sb) == -1) {
		if (nl != def_nl)
			free(nl);
		return;
	}

	/* /etc/nologin exists.  Print its contents if we can and exit. */
	logit("User %.100s not allowed because %s exists", pw->pw_name, nl);
	if ((f = fopen(nl, "r")) != NULL) {
		while (fgets(buf, sizeof(buf), f))
			fputs(buf, stderr);
		fclose(f);
	}
	exit(254);
}

/*
 * Chroot into a directory after checking it for safety: all path components
 * must be root-owned directories with strict permissions.
 */
static void
safely_chroot(const char *path, uid_t uid)
{
	const char *cp;
	char component[PATH_MAX];
	struct stat st;

	if (*path != '/')
		fatal("chroot path does not begin at root");
	if (strlen(path) >= sizeof(component))
		fatal("chroot path too long");

	/*
	 * Descend the path, checking that each component is a
	 * root-owned directory with strict permissions.
	 */
	for (cp = path; cp != NULL;) {
		if ((cp = strchr(cp, '/')) == NULL)
			strlcpy(component, path, sizeof(component));
		else {
			cp++;
			memcpy(component, path, cp - path);
			component[cp - path] = '\0';
		}
	
		debug3("%s: checking '%s'", __func__, component);

		if (stat(component, &st) != 0)
			fatal("%s: stat(\"%s\"): %s", __func__,
			    component, strerror(errno));
		if (st.st_uid != 0 || (st.st_mode & 022) != 0)
			fatal("bad ownership or modes for chroot "
			    "directory %s\"%s\"", 
			    cp == NULL ? "" : "component ", component);
		if (!S_ISDIR(st.st_mode))
			fatal("chroot path %s\"%s\" is not a directory",
			    cp == NULL ? "" : "component ", component);

	}

	if (chdir(path) == -1)
		fatal("Unable to chdir to chroot path \"%s\": "
		    "%s", path, strerror(errno));
	if (chroot(path) == -1)
		fatal("chroot(\"%s\"): %s", path, strerror(errno));
	if (chdir("/") == -1)
		fatal("%s: chdir(/) after chroot: %s",
		    __func__, strerror(errno));
	verbose("Changed root directory to \"%s\"", path);
}

/* Set login name, uid, gid, and groups. */
void
do_setusercontext(struct passwd *pw)
{
	char *chroot_path, *tmp;

	if (getuid() == 0 || geteuid() == 0) {
		/* Prepare groups */
		if (setusercontext(lc, pw, pw->pw_uid,
		    (LOGIN_SETALL & ~(LOGIN_SETPATH|LOGIN_SETUSER))) < 0) {
			perror("unable to set user context");
			exit(1);
		}

		if (!in_chroot && options.chroot_directory != NULL &&
		    strcasecmp(options.chroot_directory, "none") != 0) {
                        tmp = tilde_expand_filename(options.chroot_directory,
			    pw->pw_uid);
			chroot_path = percent_expand(tmp, "h", pw->pw_dir,
			    "u", pw->pw_name, (char *)NULL);
			safely_chroot(chroot_path, pw->pw_uid);
			free(tmp);
			free(chroot_path);
			/* Make sure we don't attempt to chroot again */
			free(options.chroot_directory);
			options.chroot_directory = NULL;
			in_chroot = 1;
		}

		/* Set UID */
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETUSER) < 0) {
			perror("unable to set user context (setuser)");
			exit(1);
		}
	} else if (options.chroot_directory != NULL &&
	    strcasecmp(options.chroot_directory, "none") != 0) {
		fatal("server lacks privileges to chroot to ChrootDirectory");
	}

	if (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)
		fatal("Failed to set uids to %u.", (u_int) pw->pw_uid);
}

static void
do_pwchange(Session *s)
{
	fflush(NULL);
	fprintf(stderr, "WARNING: Your password has expired.\n");
	if (s->ttyfd != -1) {
		fprintf(stderr,
		    "You must change your password now and login again!\n");
		execl(_PATH_PASSWD_PROG, "passwd", (char *)NULL);
		perror("passwd");
	} else {
		fprintf(stderr,
		    "Password change required but no TTY available.\n");
	}
	exit(1);
}

static void
child_close_fds(void)
{
	extern int auth_sock;

	if (auth_sock != -1) {
		close(auth_sock);
		auth_sock = -1;
	}

	if (packet_get_connection_in() == packet_get_connection_out())
		close(packet_get_connection_in());
	else {
		close(packet_get_connection_in());
		close(packet_get_connection_out());
	}
	/*
	 * Close all descriptors related to channels.  They will still remain
	 * open in the parent.
	 */
	/* XXX better use close-on-exec? -markus */
	channel_close_all();

	/*
	 * Close any extra file descriptors.  Note that there may still be
	 * descriptors left by system functions.  They will be closed later.
	 */
	endpwent();

	/*
	 * Close any extra open file descriptors so that we don't have them
	 * hanging around in clients.  Note that we want to do this after
	 * initgroups, because at least on Solaris 2.3 it leaves file
	 * descriptors open.
	 */
	closefrom(STDERR_FILENO + 1);
}

/*
 * Performs common processing for the child, such as setting up the
 * environment, closing extra file descriptors, setting the user and group
 * ids, and executing the command or shell.
 */
#define ARGV_MAX 10
void
do_child(Session *s, const char *command)
{
	extern char **environ;
	char **env;
	char *argv[ARGV_MAX];
	const char *shell, *shell0;
	struct passwd *pw = s->pw;
	int r = 0;

	/* remove hostkey from the child's memory */
	destroy_sensitive_data();

	/* Force a password change */
	if (s->authctxt->force_pwchange) {
		do_setusercontext(pw);
		child_close_fds();
		do_pwchange(s);
		exit(1);
	}

	/*
	 * Login(1) does this as well, and it needs uid 0 for the "-h"
	 * switch, so we let login(1) to this for us.
	 */
	do_nologin(pw);
	do_setusercontext(pw);

	/*
	 * Get the shell from the password data.  An empty shell field is
	 * legal, and means /bin/sh.
	 */
	shell = (pw->pw_shell[0] == '\0') ? _PATH_BSHELL : pw->pw_shell;

	/*
	 * Make sure $SHELL points to the shell from the password file,
	 * even if shell is overridden from login.conf
	 */
	env = do_setup_env(s, shell);

	shell = login_getcapstr(lc, "shell", (char *)shell, (char *)shell);

	/*
	 * Close the connection descriptors; note that this is the child, and
	 * the server will still have the socket open, and it is important
	 * that we do not shutdown it.  Note that the descriptors cannot be
	 * closed before building the environment, as we call
	 * ssh_remote_ipaddr there.
	 */
	child_close_fds();

	/*
	 * Must take new environment into use so that .ssh/rc,
	 * /etc/ssh/sshrc and xauth are run in the proper environment.
	 */
	environ = env;

#ifdef KRB5
	/*
	 * At this point, we check to see if AFS is active and if we have
	 * a valid Kerberos 5 TGT. If so, it seems like a good idea to see
	 * if we can (and need to) extend the ticket into an AFS token. If
	 * we don't do this, we run into potential problems if the user's
	 * home directory is in AFS and it's not world-readable.
	 */

	if (options.kerberos_get_afs_token && k_hasafs() &&
	    (s->authctxt->krb5_ctx != NULL)) {
		char cell[64];

		debug("Getting AFS token");

		k_setpag();

		if (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)
			krb5_afslog(s->authctxt->krb5_ctx,
			    s->authctxt->krb5_fwd_ccache, cell, NULL);

		krb5_afslog_home(s->authctxt->krb5_ctx,
		    s->authctxt->krb5_fwd_ccache, NULL, NULL, pw->pw_dir);
	}
#endif

	/* Change current directory to the user's home directory. */
	if (chdir(pw->pw_dir) < 0) {
		/* Suppress missing homedir warning for chroot case */
		r = login_getcapbool(lc, "requirehome", 0);
		if (r || !in_chroot) {
			fprintf(stderr, "Could not chdir to home "
			    "directory %s: %s\n", pw->pw_dir,
			    strerror(errno));
		}
		if (r)
			exit(1);
	}

	closefrom(STDERR_FILENO + 1);

	do_rc_files(s, shell);

	/* restore SIGPIPE for child */
	signal(SIGPIPE, SIG_DFL);

	if (s->is_subsystem == SUBSYSTEM_INT_SFTP_ERROR) {
		printf("This service allows sftp connections only.\n");
		fflush(NULL);
		exit(1);
	} else if (s->is_subsystem == SUBSYSTEM_INT_SFTP) {
		extern int optind, optreset;
		int i;
		char *p, *args;

		setproctitle("%s@@%s", s->pw->pw_name, INTERNAL_SFTP_NAME);
		args = xstrdup(command ? command : "sftp-server");
		for (i = 0, (p = strtok(args, " ")); p; (p = strtok(NULL, " ")))
			if (i < ARGV_MAX - 1)
				argv[i++] = p;
		argv[i] = NULL;
		optind = optreset = 1;
		__progname = argv[0];
		exit(sftp_server_main(i, argv, s->pw));
	}

	fflush(NULL);

	/* Get the last component of the shell name. */
	if ((shell0 = strrchr(shell, '/')) != NULL)
		shell0++;
	else
		shell0 = shell;

	/*
	 * If we have no command, execute the shell.  In this case, the shell
	 * name to be passed in argv[0] is preceded by '-' to indicate that
	 * this is a login shell.
	 */
	if (!command) {
		char argv0[256];

		/* Start the shell.  Set initial character to '-'. */
		argv0[0] = '-';

		if (strlcpy(argv0 + 1, shell0, sizeof(argv0) - 1)
		    >= sizeof(argv0) - 1) {
			errno = EINVAL;
			perror(shell);
			exit(1);
		}

		/* Execute the shell. */
		argv[0] = argv0;
		argv[1] = NULL;
		execve(shell, argv, env);

		/* Executing the shell failed. */
		perror(shell);
		exit(1);
	}
	/*
	 * Execute the command using the user's shell.  This uses the -c
	 * option to execute the command.
	 */
	argv[0] = (char *) shell0;
	argv[1] = "-c";
	argv[2] = (char *) command;
	argv[3] = NULL;
	execve(shell, argv, env);
	perror(shell);
	exit(1);
}

void
session_unused(int id)
{
	debug3("%s: session id %d unused", __func__, id);
	if (id >= options.max_sessions ||
	    id >= sessions_nalloc) {
		fatal("%s: insane session id %d (max %d nalloc %d)",
		    __func__, id, options.max_sessions, sessions_nalloc);
	}
	memset(&sessions[id], 0, sizeof(*sessions));
	sessions[id].self = id;
	sessions[id].used = 0;
	sessions[id].chanid = -1;
	sessions[id].ptyfd = -1;
	sessions[id].ttyfd = -1;
	sessions[id].ptymaster = -1;
	sessions[id].x11_chanids = NULL;
	sessions[id].next_unused = sessions_first_unused;
	sessions_first_unused = id;
}

Session *
session_new(void)
{
	Session *s, *tmp;

	if (sessions_first_unused == -1) {
		if (sessions_nalloc >= options.max_sessions)
			return NULL;
		debug2("%s: allocate (allocated %d max %d)",
		    __func__, sessions_nalloc, options.max_sessions);
		tmp = xreallocarray(sessions, sessions_nalloc + 1,
		    sizeof(*sessions));
		if (tmp == NULL) {
			error("%s: cannot allocate %d sessions",
			    __func__, sessions_nalloc + 1);
			return NULL;
		}
		sessions = tmp;
		session_unused(sessions_nalloc++);
	}

	if (sessions_first_unused >= sessions_nalloc ||
	    sessions_first_unused < 0) {
		fatal("%s: insane first_unused %d max %d nalloc %d",
		    __func__, sessions_first_unused, options.max_sessions,
		    sessions_nalloc);
	}

	s = &sessions[sessions_first_unused];
	if (s->used) {
		fatal("%s: session %d already used",
		    __func__, sessions_first_unused);
	}
	sessions_first_unused = s->next_unused;
	s->used = 1;
	s->next_unused = -1;
	debug("session_new: session %d", s->self);

	return s;
}

static void
session_dump(void)
{
	int i;
	for (i = 0; i < sessions_nalloc; i++) {
		Session *s = &sessions[i];

		debug("dump: used %d next_unused %d session %d %p "
		    "channel %d pid %ld",
		    s->used,
		    s->next_unused,
		    s->self,
		    s,
		    s->chanid,
		    (long)s->pid);
	}
}

int
session_open(Authctxt *authctxt, int chanid)
{
	Session *s = session_new();
	debug("session_open: channel %d", chanid);
	if (s == NULL) {
		error("no more sessions");
		return 0;
	}
	s->authctxt = authctxt;
	s->pw = authctxt->pw;
	if (s->pw == NULL || !authctxt->valid)
		fatal("no user for session %d", s->self);
	debug("session_open: session %d: link with channel %d", s->self, chanid);
	s->chanid = chanid;
	return 1;
}

Session *
session_by_tty(char *tty)
{
	int i;
	for (i = 0; i < sessions_nalloc; i++) {
		Session *s = &sessions[i];
		if (s->used && s->ttyfd != -1 && strcmp(s->tty, tty) == 0) {
			debug("session_by_tty: session %d tty %s", i, tty);
			return s;
		}
	}
	debug("session_by_tty: unknown tty %.100s", tty);
	session_dump();
	return NULL;
}

static Session *
session_by_channel(int id)
{
	int i;
	for (i = 0; i < sessions_nalloc; i++) {
		Session *s = &sessions[i];
		if (s->used && s->chanid == id) {
			debug("session_by_channel: session %d channel %d",
			    i, id);
			return s;
		}
	}
	debug("session_by_channel: unknown channel %d", id);
	session_dump();
	return NULL;
}

static Session *
session_by_x11_channel(int id)
{
	int i, j;

	for (i = 0; i < sessions_nalloc; i++) {
		Session *s = &sessions[i];

		if (s->x11_chanids == NULL || !s->used)
			continue;
		for (j = 0; s->x11_chanids[j] != -1; j++) {
			if (s->x11_chanids[j] == id) {
				debug("session_by_x11_channel: session %d "
				    "channel %d", s->self, id);
				return s;
			}
		}
	}
	debug("session_by_x11_channel: unknown channel %d", id);
	session_dump();
	return NULL;
}

static Session *
session_by_pid(pid_t pid)
{
	int i;
	debug("session_by_pid: pid %ld", (long)pid);
	for (i = 0; i < sessions_nalloc; i++) {
		Session *s = &sessions[i];
		if (s->used && s->pid == pid)
			return s;
	}
	error("session_by_pid: unknown pid %ld", (long)pid);
	session_dump();
	return NULL;
}

static int
session_window_change_req(Session *s)
{
	s->col = packet_get_int();
	s->row = packet_get_int();
	s->xpixel = packet_get_int();
	s->ypixel = packet_get_int();
	packet_check_eom();
	pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
	return 1;
}

static int
session_pty_req(Session *s)
{
	u_int len;
	int n_bytes;

	if (no_pty_flag || !options.permit_tty) {
		debug("Allocating a pty not permitted for this authentication.");
		return 0;
	}
	if (s->ttyfd != -1) {
		packet_disconnect("Protocol error: you already have a pty.");
		return 0;
	}

	s->term = packet_get_string(&len);
	s->col = packet_get_int();
	s->row = packet_get_int();
	s->xpixel = packet_get_int();
	s->ypixel = packet_get_int();

	if (strcmp(s->term, "") == 0) {
		free(s->term);
		s->term = NULL;
	}

	/* Allocate a pty and open it. */
	debug("Allocating pty.");
	if (!PRIVSEP(pty_allocate(&s->ptyfd, &s->ttyfd, s->tty,
	    sizeof(s->tty)))) {
		free(s->term);
		s->term = NULL;
		s->ptyfd = -1;
		s->ttyfd = -1;
		error("session_pty_req: session %d alloc failed", s->self);
		return 0;
	}
	debug("session_pty_req: session %d alloc %s", s->self, s->tty);

	n_bytes = packet_remaining();
	tty_parse_modes(s->ttyfd, &n_bytes);

	if (!use_privsep)
		pty_setowner(s->pw, s->tty);

	/* Set window size from the packet. */
	pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);

	packet_check_eom();
	session_proctitle(s);
	return 1;
}

static int
session_subsystem_req(Session *s)
{
	struct stat st;
	u_int len;
	int success = 0;
	char *prog, *cmd;
	u_int i;

	s->subsys = packet_get_string(&len);
	packet_check_eom();
	debug2("subsystem request for %.100s by user %s", s->subsys,
	    s->pw->pw_name);

	for (i = 0; i < options.num_subsystems; i++) {
		if (strcmp(s->subsys, options.subsystem_name[i]) == 0) {
			prog = options.subsystem_command[i];
			cmd = options.subsystem_args[i];
			if (strcmp(INTERNAL_SFTP_NAME, prog) == 0) {
				s->is_subsystem = SUBSYSTEM_INT_SFTP;
				debug("subsystem: %s", prog);
			} else {
				if (stat(prog, &st) < 0)
					debug("subsystem: cannot stat %s: %s",
					    prog, strerror(errno));
				s->is_subsystem = SUBSYSTEM_EXT;
				debug("subsystem: exec() %s", cmd);
			}
			success = do_exec(s, cmd) == 0;
			break;
		}
	}

	if (!success)
		logit("subsystem request for %.100s by user %s failed, "
		    "subsystem not found", s->subsys, s->pw->pw_name);

	return success;
}

static int
session_x11_req(Session *s)
{
	int success;

	if (s->auth_proto != NULL || s->auth_data != NULL) {
		error("session_x11_req: session %d: "
		    "x11 forwarding already active", s->self);
		return 0;
	}
	s->single_connection = packet_get_char();
	s->auth_proto = packet_get_string(NULL);
	s->auth_data = packet_get_string(NULL);
	s->screen = packet_get_int();
	packet_check_eom();

	if (xauth_valid_string(s->auth_proto) &&
	    xauth_valid_string(s->auth_data))
		success = session_setup_x11fwd(s);
	else {
		success = 0;
		error("Invalid X11 forwarding data");
	}
	if (!success) {
		free(s->auth_proto);
		free(s->auth_data);
		s->auth_proto = NULL;
		s->auth_data = NULL;
	}
	return success;
}

static int
session_shell_req(Session *s)
{
	packet_check_eom();
	return do_exec(s, NULL) == 0;
}

static int
session_exec_req(Session *s)
{
	u_int len, success;

	char *command = packet_get_string(&len);
	packet_check_eom();
	success = do_exec(s, command) == 0;
	free(command);
	return success;
}

static int
session_break_req(Session *s)
{

	packet_get_int();	/* ignored */
	packet_check_eom();

	if (s->ptymaster == -1 || tcsendbreak(s->ptymaster, 0) < 0)
		return 0;
	return 1;
}

static int
session_env_req(Session *s)
{
	char *name, *val;
	u_int name_len, val_len, i;

	name = packet_get_cstring(&name_len);
	val = packet_get_cstring(&val_len);
	packet_check_eom();

	/* Don't set too many environment variables */
	if (s->num_env > 128) {
		debug2("Ignoring env request %s: too many env vars", name);
		goto fail;
	}

	for (i = 0; i < options.num_accept_env; i++) {
		if (match_pattern(name, options.accept_env[i])) {
			debug2("Setting env %d: %s=%s", s->num_env, name, val);
			s->env = xreallocarray(s->env, s->num_env + 1,
			    sizeof(*s->env));
			s->env[s->num_env].name = name;
			s->env[s->num_env].val = val;
			s->num_env++;
			return (1);
		}
	}
	debug2("Ignoring env request %s: disallowed name", name);

 fail:
	free(name);
	free(val);
	return (0);
}

static int
session_auth_agent_req(Session *s)
{
	static int called = 0;
	packet_check_eom();
	if (no_agent_forwarding_flag || !options.allow_agent_forwarding) {
		debug("session_auth_agent_req: no_agent_forwarding_flag");
		return 0;
	}
	if (called) {
		return 0;
	} else {
		called = 1;
		return auth_input_request_forwarding(s->pw);
	}
}

int
session_input_channel_req(Channel *c, const char *rtype)
{
	int success = 0;
	Session *s;

	if ((s = session_by_channel(c->self)) == NULL) {
		logit("session_input_channel_req: no session %d req %.100s",
		    c->self, rtype);
		return 0;
	}
	debug("session_input_channel_req: session %d req %s", s->self, rtype);

	/*
	 * a session is in LARVAL state until a shell, a command
	 * or a subsystem is executed
	 */
	if (c->type == SSH_CHANNEL_LARVAL) {
		if (strcmp(rtype, "shell") == 0) {
			success = session_shell_req(s);
		} else if (strcmp(rtype, "exec") == 0) {
			success = session_exec_req(s);
		} else if (strcmp(rtype, "pty-req") == 0) {
			success = session_pty_req(s);
		} else if (strcmp(rtype, "x11-req") == 0) {
			success = session_x11_req(s);
		} else if (strcmp(rtype, "auth-agent-req@@openssh.com") == 0) {
			success = session_auth_agent_req(s);
		} else if (strcmp(rtype, "subsystem") == 0) {
			success = session_subsystem_req(s);
		} else if (strcmp(rtype, "env") == 0) {
			success = session_env_req(s);
		}
	}
	if (strcmp(rtype, "window-change") == 0) {
		success = session_window_change_req(s);
	} else if (strcmp(rtype, "break") == 0) {
		success = session_break_req(s);
	}

	return success;
}

void
session_set_fds(Session *s, int fdin, int fdout, int fderr, int ignore_fderr,
    int is_tty)
{
	/*
	 * now that have a child and a pipe to the child,
	 * we can activate our channel and register the fd's
	 */
	if (s->chanid == -1)
		fatal("no channel for session %d", s->self);
	channel_set_fds(s->chanid,
	    fdout, fdin, fderr,
	    ignore_fderr ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,
	    1, is_tty, CHAN_SES_WINDOW_DEFAULT);
}

/*
 * Function to perform pty cleanup. Also called if we get aborted abnormally
 * (e.g., due to a dropped connection).
 */
void
session_pty_cleanup2(Session *s)
{
	if (s == NULL) {
		error("session_pty_cleanup: no session");
		return;
	}
	if (s->ttyfd == -1)
		return;

	debug("session_pty_cleanup: session %d release %s", s->self, s->tty);

	/* Record that the user has logged out. */
	if (s->pid != 0)
		record_logout(s->pid, s->tty);

	/* Release the pseudo-tty. */
	if (getuid() == 0)
		pty_release(s->tty);

	/*
	 * Close the server side of the socket pairs.  We must do this after
	 * the pty cleanup, so that another process doesn't get this pty
	 * while we're still cleaning up.
	 */
	if (s->ptymaster != -1 && close(s->ptymaster) < 0)
		error("close(s->ptymaster/%d): %s",
		    s->ptymaster, strerror(errno));

	/* unlink pty from session */
	s->ttyfd = -1;
}

void
session_pty_cleanup(Session *s)
{
	PRIVSEP(session_pty_cleanup2(s));
}

static char *
sig2name(int sig)
{
#define SSH_SIG(x) if (sig == SIG ## x) return #x
	SSH_SIG(ABRT);
	SSH_SIG(ALRM);
	SSH_SIG(FPE);
	SSH_SIG(HUP);
	SSH_SIG(ILL);
	SSH_SIG(INT);
	SSH_SIG(KILL);
	SSH_SIG(PIPE);
	SSH_SIG(QUIT);
	SSH_SIG(SEGV);
	SSH_SIG(TERM);
	SSH_SIG(USR1);
	SSH_SIG(USR2);
#undef	SSH_SIG
	return "SIG@@openssh.com";
}

static void
session_close_x11(int id)
{
	Channel *c;

	if ((c = channel_by_id(id)) == NULL) {
		debug("session_close_x11: x11 channel %d missing", id);
	} else {
		/* Detach X11 listener */
		debug("session_close_x11: detach x11 channel %d", id);
		channel_cancel_cleanup(id);
		if (c->ostate != CHAN_OUTPUT_CLOSED)
			chan_mark_dead(c);
	}
}

static void
session_close_single_x11(int id, void *arg)
{
	Session *s;
	u_int i;

	debug3("session_close_single_x11: channel %d", id);
	channel_cancel_cleanup(id);
	if ((s = session_by_x11_channel(id)) == NULL)
		fatal("session_close_single_x11: no x11 channel %d", id);
	for (i = 0; s->x11_chanids[i] != -1; i++) {
		debug("session_close_single_x11: session %d: "
		    "closing channel %d", s->self, s->x11_chanids[i]);
		/*
		 * The channel "id" is already closing, but make sure we
		 * close all of its siblings.
		 */
		if (s->x11_chanids[i] != id)
			session_close_x11(s->x11_chanids[i]);
	}
	free(s->x11_chanids);
	s->x11_chanids = NULL;
	free(s->display);
	s->display = NULL;
	free(s->auth_proto);
	s->auth_proto = NULL;
	free(s->auth_data);
	s->auth_data = NULL;
	free(s->auth_display);
	s->auth_display = NULL;
}

static void
session_exit_message(Session *s, int status)
{
	Channel *c;

	if ((c = channel_lookup(s->chanid)) == NULL)
		fatal("session_exit_message: session %d: no channel %d",
		    s->self, s->chanid);
	debug("session_exit_message: session %d channel %d pid %ld",
	    s->self, s->chanid, (long)s->pid);

	if (WIFEXITED(status)) {
		channel_request_start(s->chanid, "exit-status", 0);
		packet_put_int(WEXITSTATUS(status));
		packet_send();
	} else if (WIFSIGNALED(status)) {
		channel_request_start(s->chanid, "exit-signal", 0);
		packet_put_cstring(sig2name(WTERMSIG(status)));
		packet_put_char(WCOREDUMP(status)? 1 : 0);
		packet_put_cstring("");
		packet_put_cstring("");
		packet_send();
	} else {
		/* Some weird exit cause.  Just exit. */
		packet_disconnect("wait returned status %04x.", status);
	}

	/* disconnect channel */
	debug("session_exit_message: release channel %d", s->chanid);

	/*
	 * Adjust cleanup callback attachment to send close messages when
	 * the channel gets EOF. The session will be then be closed
	 * by session_close_by_channel when the childs close their fds.
	 */
	channel_register_cleanup(c->self, session_close_by_channel, 1);

	/*
	 * emulate a write failure with 'chan_write_failed', nobody will be
	 * interested in data we write.
	 * Note that we must not call 'chan_read_failed', since there could
	 * be some more data waiting in the pipe.
	 */
	if (c->ostate != CHAN_OUTPUT_CLOSED)
		chan_write_failed(c);
}

void
session_close(Session *s)
{
	struct ssh *ssh = active_state; /* XXX */
	u_int i;

	verbose("Close session: user %s from %.200s port %d id %d",
	    s->pw->pw_name,
	    ssh_remote_ipaddr(ssh),
	    ssh_remote_port(ssh),
	    s->self);

	if (s->ttyfd != -1)
		session_pty_cleanup(s);
	free(s->term);
	free(s->display);
	free(s->x11_chanids);
	free(s->auth_display);
	free(s->auth_data);
	free(s->auth_proto);
	free(s->subsys);
	if (s->env != NULL) {
		for (i = 0; i < s->num_env; i++) {
			free(s->env[i].name);
			free(s->env[i].val);
		}
		free(s->env);
	}
	session_proctitle(s);
	session_unused(s->self);
}

void
session_close_by_pid(pid_t pid, int status)
{
	Session *s = session_by_pid(pid);
	if (s == NULL) {
		debug("session_close_by_pid: no session for pid %ld",
		    (long)pid);
		return;
	}
	if (s->chanid != -1)
		session_exit_message(s, status);
	if (s->ttyfd != -1)
		session_pty_cleanup(s);
	s->pid = 0;
}

/*
 * this is called when a channel dies before
 * the session 'child' itself dies
 */
void
session_close_by_channel(int id, void *arg)
{
	Session *s = session_by_channel(id);
	u_int i;

	if (s == NULL) {
		debug("session_close_by_channel: no session for id %d", id);
		return;
	}
	debug("session_close_by_channel: channel %d child %ld",
	    id, (long)s->pid);
	if (s->pid != 0) {
		debug("session_close_by_channel: channel %d: has child", id);
		/*
		 * delay detach of session, but release pty, since
		 * the fd's to the child are already closed
		 */
		if (s->ttyfd != -1)
			session_pty_cleanup(s);
		return;
	}
	/* detach by removing callback */
	channel_cancel_cleanup(s->chanid);

	/* Close any X11 listeners associated with this session */
	if (s->x11_chanids != NULL) {
		for (i = 0; s->x11_chanids[i] != -1; i++) {
			session_close_x11(s->x11_chanids[i]);
			s->x11_chanids[i] = -1;
		}
	}

	s->chanid = -1;
	session_close(s);
}

void
session_destroy_all(void (*closefunc)(Session *))
{
	int i;
	for (i = 0; i < sessions_nalloc; i++) {
		Session *s = &sessions[i];
		if (s->used) {
			if (closefunc != NULL)
				closefunc(s);
			else
				session_close(s);
		}
	}
}

static char *
session_tty_list(void)
{
	static char buf[1024];
	int i;
	buf[0] = '\0';
	for (i = 0; i < sessions_nalloc; i++) {
		Session *s = &sessions[i];
		if (s->used && s->ttyfd != -1) {
			if (buf[0] != '\0')
				strlcat(buf, ",", sizeof buf);
			strlcat(buf, strrchr(s->tty, '/') + 1, sizeof buf);
		}
	}
	if (buf[0] == '\0')
		strlcpy(buf, "notty", sizeof buf);
	return buf;
}

void
session_proctitle(Session *s)
{
	if (s->pw == NULL)
		error("no user for session %d", s->self);
	else
		setproctitle("%s@@%s", s->pw->pw_name, session_tty_list());
}

int
session_setup_x11fwd(Session *s)
{
	struct stat st;
	char display[512], auth_display[512];
	char hostname[NI_MAXHOST];
	u_int i;

	if (no_x11_forwarding_flag) {
		packet_send_debug("X11 forwarding disabled in user configuration file.");
		return 0;
	}
	if (!options.x11_forwarding) {
		debug("X11 forwarding disabled in server configuration file.");
		return 0;
	}
	if (options.xauth_location == NULL ||
	    (stat(options.xauth_location, &st) == -1)) {
		packet_send_debug("No xauth program; cannot forward with spoofing.");
		return 0;
	}
	if (s->display != NULL) {
		debug("X11 display already set.");
		return 0;
	}
	if (x11_create_display_inet(options.x11_display_offset,
	    options.x11_use_localhost, s->single_connection,
	    &s->display_number, &s->x11_chanids) == -1) {
		debug("x11_create_display_inet failed.");
		return 0;
	}
	for (i = 0; s->x11_chanids[i] != -1; i++) {
		channel_register_cleanup(s->x11_chanids[i],
		    session_close_single_x11, 0);
	}

	/* Set up a suitable value for the DISPLAY variable. */
	if (gethostname(hostname, sizeof(hostname)) < 0)
		fatal("gethostname: %.100s", strerror(errno));
	/*
	 * auth_display must be used as the displayname when the
	 * authorization entry is added with xauth(1).  This will be
	 * different than the DISPLAY string for localhost displays.
	 */
	if (options.x11_use_localhost) {
		snprintf(display, sizeof display, "localhost:%u.%u",
		    s->display_number, s->screen);
		snprintf(auth_display, sizeof auth_display, "unix:%u.%u",
		    s->display_number, s->screen);
		s->display = xstrdup(display);
		s->auth_display = xstrdup(auth_display);
	} else {
		snprintf(display, sizeof display, "%.400s:%u.%u", hostname,
		    s->display_number, s->screen);
		s->display = xstrdup(display);
		s->auth_display = xstrdup(display);
	}

	return 1;
}

static void
do_authenticated2(Authctxt *authctxt)
{
	server_loop2(authctxt);
}

void
do_cleanup(Authctxt *authctxt)
{
	static int called = 0;

	debug("do_cleanup");

	/* no cleanup if we're in the child for login shell */
	if (is_child)
		return;

	/* avoid double cleanup */
	if (called)
		return;
	called = 1;

	if (authctxt == NULL || !authctxt->authenticated)
		return;
#ifdef KRB5
	if (options.kerberos_ticket_cleanup &&
	    authctxt->krb5_ctx)
		krb5_cleanup_proc(authctxt);
#endif

#ifdef GSSAPI
	if (options.gss_cleanup_creds)
		ssh_gssapi_cleanup_creds();
#endif

	/* remove agent socket */
	auth_sock_cleanup_proc(authctxt->pw);

	/*
	 * Cleanup ptys/utmp only if privsep is disabled,
	 * or if running in monitor.
	 */
	if (!use_privsep || mm_is_monitor())
		session_destroy_all(session_pty_cleanup2);
}

/* Return a name for the remote host that fits inside utmp_size */

const char *
session_get_remote_name_or_ip(struct ssh *ssh, u_int utmp_size, int use_dns)
{
	const char *remote = "";

	if (utmp_size > 0)
		remote = auth_get_canonical_hostname(ssh, use_dns);
	if (utmp_size == 0 || strlen(remote) > utmp_size)
		remote = ssh_remote_ipaddr(ssh);
	return remote;
}

@


1.285
log
@fix previous, a condition was modified incorrectly; ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.284 2016/08/19 03:18:06 djm Exp $ */
d242 1
a242 1
	if (no_port_forwarding_flag ||
@


1.284
log
@remove UseLogin option and support for having /bin/login manage
login sessions; ok deraadt markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.283 2016/08/13 17:47:41 markus Exp $ */
d508 1
a508 2
		if (command != NULL)
			do_login(s, command);
@


1.283
log
@remove ssh1 server code; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.282 2016/03/10 11:47:57 djm Exp $ */
d508 1
a508 1
		if (!(options.use_login && command == NULL))
d807 17
a823 17
	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, "USER", pw->pw_name);
		child_set_env(&env, &envsize, "LOGNAME", pw->pw_name);
		child_set_env(&env, &envsize, "HOME", pw->pw_dir);
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, "PATH", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, "PATH", getenv("PATH"));

		snprintf(buf, sizeof buf, "%.200s/%.50s",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, "MAIL", buf);
a824 3
		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, "SHELL", shell);
	}
d829 13
a841 15
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
d876 1
a876 1
	if (options.permit_user_env && !options.use_login) {
a1105 14
launch_login(struct passwd *pw, const char *hostname)
{
	/* Launch login(1). */

	execl("/usr/bin/login", "login", "-h", hostname,
	    "-p", "-f", "--", pw->pw_name, (char *)NULL);

	/* Login couldn't be executed, die. */

	perror("login");
	exit(1);
}

static void
a1151 1
	struct ssh *ssh = active_state;	/* XXX */
d1155 1
a1155 1
	const char *shell, *shell0, *hostname = NULL;
a1169 4
	/* login(1) is only called if we execute the login shell */
	if (options.use_login && command != NULL)
		options.use_login = 0;

d1174 2
a1175 4
	if (!options.use_login) {
		do_nologin(pw);
		do_setusercontext(pw);
	}
a1190 4
	/* we have to stash the hostname before we close our socket. */
	if (options.use_login)
		hostname = session_get_remote_name_or_ip(ssh, utmp_len,
		    options.use_dns);
d1247 1
a1247 2
	if (!options.use_login)
		do_rc_files(s, shell);
a1273 5
	if (options.use_login) {
		launch_login(pw, hostname);
		/* NEVERREACHED */
	}

a2077 5
		return 0;
	}
	if (options.use_login) {
		packet_send_debug("X11 forwarding disabled; "
		    "not compatible with UseLogin=yes.");
@


1.282
log
@sanitise characters destined for xauth
reported by github.com/tintinweb
feedback and ok deraadt and markus
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.281 2016/03/07 19:02:43 djm Exp $ */
a59 1
#include "ssh1.h"
a113 1
static void do_authenticated1(Authctxt *);
d250 1
a250 5
	if (compat20)
		do_authenticated2(authctxt);
	else
		do_authenticated1(authctxt);

a268 158
/*
 * Prepares for an interactive session.  This is called after the user has
 * been successfully authenticated.  During this message exchange, pseudo
 * terminals are allocated, X11, TCP/IP, and authentication agent forwardings
 * are requested, etc.
 */
static void
do_authenticated1(Authctxt *authctxt)
{
	Session *s;
	char *command;
	int success, type, screen_flag;
	int enable_compression_after_reply = 0;
	u_int proto_len, data_len, dlen, compression_level = 0;

	s = session_new();
	if (s == NULL) {
		error("no more sessions");
		return;
	}
	s->authctxt = authctxt;
	s->pw = authctxt->pw;

	/*
	 * We stay in this loop until the client requests to execute a shell
	 * or a command.
	 */
	for (;;) {
		success = 0;

		/* Get a packet from the client. */
		type = packet_read();

		/* Process the packet. */
		switch (type) {
		case SSH_CMSG_REQUEST_COMPRESSION:
			compression_level = packet_get_int();
			packet_check_eom();
			if (compression_level < 1 || compression_level > 9) {
				packet_send_debug("Received invalid compression level %d.",
				    compression_level);
				break;
			}
			if (options.compression == COMP_NONE) {
				debug2("compression disabled");
				break;
			}
			/* Enable compression after we have responded with SUCCESS. */
			enable_compression_after_reply = 1;
			success = 1;
			break;

		case SSH_CMSG_REQUEST_PTY:
			success = session_pty_req(s);
			break;

		case SSH_CMSG_X11_REQUEST_FORWARDING:
			s->auth_proto = packet_get_string(&proto_len);
			s->auth_data = packet_get_string(&data_len);

			screen_flag = packet_get_protocol_flags() &
			    SSH_PROTOFLAG_SCREEN_NUMBER;
			debug2("SSH_PROTOFLAG_SCREEN_NUMBER: %d", screen_flag);

			if (packet_remaining() == 4) {
				if (!screen_flag)
					debug2("Buggy client: "
					    "X11 screen flag missing");
				s->screen = packet_get_int();
			} else {
				s->screen = 0;
			}
			packet_check_eom();
			if (xauth_valid_string(s->auth_proto) &&
			    xauth_valid_string(s->auth_data))
				success = session_setup_x11fwd(s);
			else {
				success = 0;
				error("Invalid X11 forwarding data");
			}
			if (!success) {
				free(s->auth_proto);
				free(s->auth_data);
				s->auth_proto = NULL;
				s->auth_data = NULL;
			}
			break;

		case SSH_CMSG_AGENT_REQUEST_FORWARDING:
			if (!options.allow_agent_forwarding ||
			    no_agent_forwarding_flag || compat13) {
				debug("Authentication agent forwarding not permitted for this authentication.");
				break;
			}
			debug("Received authentication agent forwarding request.");
			success = auth_input_request_forwarding(s->pw);
			break;

		case SSH_CMSG_PORT_FORWARD_REQUEST:
			if (no_port_forwarding_flag) {
				debug("Port forwarding not permitted for this authentication.");
				break;
			}
			if (!(options.allow_tcp_forwarding & FORWARD_REMOTE)) {
				debug("Port forwarding not permitted.");
				break;
			}
			debug("Received TCP/IP port forwarding request.");
			if (channel_input_port_forward_request(s->pw->pw_uid == 0,
			    &options.fwd_opts) < 0) {
				debug("Port forwarding failed.");
				break;
			}
			success = 1;
			break;

		case SSH_CMSG_MAX_PACKET_SIZE:
			if (packet_set_maxsize(packet_get_int()) > 0)
				success = 1;
			break;

		case SSH_CMSG_EXEC_SHELL:
		case SSH_CMSG_EXEC_CMD:
			if (type == SSH_CMSG_EXEC_CMD) {
				command = packet_get_string(&dlen);
				debug("Exec command '%.500s'", command);
				if (do_exec(s, command) != 0)
					packet_disconnect(
					    "command execution failed");
				free(command);
			} else {
				if (do_exec(s, NULL) != 0)
					packet_disconnect(
					    "shell execution failed");
			}
			packet_check_eom();
			session_close(s);
			return;

		default:
			/*
			 * Any unknown messages in this phase are ignored,
			 * and a failure message is returned.
			 */
			logit("Unknown packet type received after authentication: %d", type);
		}
		packet_start(success ? SSH_SMSG_SUCCESS : SSH_SMSG_FAILURE);
		packet_send();
		packet_write_wait();

		/* Enable compression now that we have replied if appropriate. */
		if (enable_compression_after_reply) {
			enable_compression_after_reply = 0;
			packet_start_compression(compression_level);
		}
	}
}

d416 2
a417 8
	if (compat20) {
		session_set_fds(s, pin[1], pout[0], perr[0],
		    s->is_subsystem, 0);
	} else {
		/* Enter the interactive session. */
		server_loop(pid, pin[1], pout[0], perr[0]);
		/* server_loop has closed pin[1], pout[0], and perr[0]. */
	}
d427 2
a428 7
	if (compat20) {
		session_set_fds(s, inout[1], inout[1], err[1],
		    s->is_subsystem, 0);
	} else {
		server_loop(pid, inout[1], inout[1], err[1]);
		/* server_loop has closed inout[1] and err[1]. */
	}
d529 1
a529 6
	if (compat20) {
		session_set_fds(s, ptyfd, fdout, -1, 1, 1);
	} else {
		server_loop(pid, ptyfd, fdout, -1);
		/* server_loop _has_ closed ptyfd and fdout. */
	}
d1553 2
a1554 8

	if (compat20) {
		s->col = packet_get_int();
		s->row = packet_get_int();
	} else {
		s->row = packet_get_int();
		s->col = packet_get_int();
	}
d1576 1
a1576 3
	/* for SSH1 the tty modes length is not given */
	if (!compat20)
		n_bytes = packet_remaining();
a1791 2
	if (!compat20)
		fatal("session_set_fds: called for proto != 2.0");
d2192 1
a2192 1
	if (compat20 && options.gss_cleanup_creds)
@


1.281
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.280 2016/02/16 03:37:48 djm Exp $ */
d43 1
d260 15
d348 7
a354 1
			success = session_setup_x11fwd(s);
d1834 7
a1840 1
	success = session_setup_x11fwd(s);
@


1.280
log
@add a "Close session" log entry (at loglevel=verbose) to correspond
to the existing "Starting session" one. Also include the session id
number to make multiplexed sessions more apparent.

feedback and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.279 2015/10/24 22:52:22 djm Exp $ */
d698 1
d741 2
a742 2
	    get_remote_ipaddr(),
	    get_remote_port(),
d774 1
d797 1
a797 1
		    get_remote_name_or_ip(utmp_len,
d947 1
d1009 2
a1010 1
	    get_remote_ipaddr(), get_remote_port(), get_local_port());
d1015 2
a1016 1
	    get_remote_ipaddr(), get_remote_port(), laddr, get_local_port());
d1329 1
d1377 1
a1377 1
		hostname = get_remote_name_or_ip(utmp_len,
d1384 1
a1384 1
	 * get_remote_ipaddr there.
d2128 1
d2133 2
a2134 2
	    get_remote_ipaddr(),
	    get_remote_port(),
d2368 15
@


1.280.2.1
log
@MFC:
revision 1.282
sanitise characters destined for xauth
reported by github.com/tintinweb
feedback and ok deraadt and markus
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.280 2016/02/16 03:37:48 djm Exp $ */
a42 1
#include <ctype.h>
a258 15
/* Check untrusted xauth strings for metacharacters */
static int
xauth_valid_string(const char *s)
{
	size_t i;

	for (i = 0; s[i] != '\0'; i++) {
		if (!isalnum((u_char)s[i]) &&
		    s[i] != '.' && s[i] != ':' && s[i] != '/' &&
		    s[i] != '-' && s[i] != '_')
		return 0;
	}
	return 1;
}

d332 1
a332 7
			if (xauth_valid_string(s->auth_proto) &&
			    xauth_valid_string(s->auth_data))
				success = session_setup_x11fwd(s);
			else {
				success = 0;
				error("Invalid X11 forwarding data");
			}
d1806 1
a1806 7
	if (xauth_valid_string(s->auth_proto) &&
	    xauth_valid_string(s->auth_data))
		success = session_setup_x11fwd(s);
	else {
		success = 0;
		error("Invalid X11 forwarding data");
	}
@


1.279
log
@skip "Could not chdir to home directory" message when chrooted

patch from Christian Hesse in bz#2485 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.278 2015/04/24 01:36:00 deraadt Exp $ */
d699 2
a700 2
	const char *forced = NULL;
	char session_type[1024], *tty = NULL;
d735 1
a735 1
	verbose("Starting session: %s%s%s for %s from %.200s port %d",
d741 2
a742 1
	    get_remote_port());
d2124 6
a2129 1
	debug("session_close: session %d pid %ld", s->self, (long)s->pid);
@


1.278
log
@rename xrealloc() to xreallocarray() since it follows that form.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.277 2015/01/16 06:40:12 deraadt Exp $ */
d145 1
d1216 1
a1216 1
		if (options.chroot_directory != NULL &&
d1228 1
d1417 1
a1417 2
		if (r || options.chroot_directory == NULL ||
		    strcasecmp(options.chroot_directory, "none") == 0)
d1421 1
@


1.278.2.1
log
@MFC:
revision 1.282
sanitise characters destined for xauth
reported by github.com/tintinweb
feedback and ok deraadt and markus
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.278 2015/04/24 01:36:00 deraadt Exp $ */
a42 1
#include <ctype.h>
a257 15
/* Check untrusted xauth strings for metacharacters */
static int
xauth_valid_string(const char *s)
{
	size_t i;

	for (i = 0; s[i] != '\0'; i++) {
		if (!isalnum((u_char)s[i]) &&
		    s[i] != '.' && s[i] != ':' && s[i] != '/' &&
		    s[i] != '-' && s[i] != '_')
		return 0;
	}
	return 1;
}

d331 1
a331 7
			if (xauth_valid_string(s->auth_proto) &&
			    xauth_valid_string(s->auth_data))
				success = session_setup_x11fwd(s);
			else {
				success = 0;
				error("Invalid X11 forwarding data");
			}
d1803 1
a1803 7
	if (xauth_valid_string(s->auth_proto) &&
	    xauth_valid_string(s->auth_data))
		success = session_setup_x11fwd(s);
	else {
		success = 0;
		error("Invalid X11 forwarding data");
	}
@


1.277
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.276 2015/01/14 20:05:27 djm Exp $ */
d882 1
a882 1
			env = (*envp) = xrealloc(env, envsize, sizeof(char *));
d1536 1
a1536 1
		tmp = xrealloc(sessions, sessions_nalloc + 1,
d1863 1
a1863 1
			s->env = xrealloc(s->env, s->num_env + 1,
@


1.277.2.1
log
@MFC:
revision 1.282
sanitise characters destined for xauth
reported by github.com/tintinweb
feedback and ok deraadt and markus
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.277 2015/01/16 06:40:12 deraadt Exp $ */
a42 1
#include <ctype.h>
a257 15
/* Check untrusted xauth strings for metacharacters */
static int
xauth_valid_string(const char *s)
{
	size_t i;

	for (i = 0; s[i] != '\0'; i++) {
		if (!isalnum((u_char)s[i]) &&
		    s[i] != '.' && s[i] != ':' && s[i] != '/' &&
		    s[i] != '-' && s[i] != '_')
		return 0;
	}
	return 1;
}

d331 1
a331 7
			if (xauth_valid_string(s->auth_proto) &&
			    xauth_valid_string(s->auth_data))
				success = session_setup_x11fwd(s);
			else {
				success = 0;
				error("Invalid X11 forwarding data");
			}
d1803 1
a1803 7
	if (xauth_valid_string(s->auth_proto) &&
	    xauth_valid_string(s->auth_data))
		success = session_setup_x11fwd(s);
	else {
		success = 0;
		error("Invalid X11 forwarding data");
	}
@


1.276
log
@move authfd.c and its tentacles to the new buffer/key API;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.275 2014/12/22 07:55:51 djm Exp $ */
a40 1
#include <sys/param.h>
d55 1
d1154 1
a1154 1
	char component[MAXPATHLEN];
@


1.275
log
@make internal handling of filename arguments of "none" more consistent
with ssh. "none" arguments are now replaced with NULL when the
configuration is finalised.

Simplifies checking later on (just need to test not-NULL rather than
that + strcmp) and cleans up some inconsistencies. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.274 2014/07/15 15:54:14 millert Exp $ */
d1277 1
a1277 1
	extern AuthenticationConnection *auth_conn;
d1279 3
a1281 3
	if (auth_conn) {
		ssh_close_authentication_connection(auth_conn);
		auth_conn = NULL;
@


1.274
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.273 2014/07/03 22:40:43 djm Exp $ */
d2258 1
a2258 1
	if (!options.xauth_location ||
@


1.273
log
@Add a sshd_config PermitUserRC option to control whether ~/.ssh/rc is
executed, mirroring the no-user-rc authorized_keys option;
bz#2160; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.272 2014/07/03 03:34:09 djm Exp $ */
d77 1
a81 1
#include "misc.h"
a168 1
	struct sockaddr_un sunaddr;
d194 2
a195 18
	/* Create the socket. */
	sock = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sock < 0) {
		error("socket: %.100s", strerror(errno));
		restore_uid();
		goto authsock_err;
	}

	/* Bind it to the name. */
	memset(&sunaddr, 0, sizeof(sunaddr));
	sunaddr.sun_family = AF_UNIX;
	strlcpy(sunaddr.sun_path, auth_sock_name, sizeof(sunaddr.sun_path));

	if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {
		error("bind: %.100s", strerror(errno));
		restore_uid();
		goto authsock_err;
	}
d200 2
a201 3
	/* Start listening on the socket. */
	if (listen(sock, SSH_LISTEN_BACKLOG) < 0) {
		error("listen: %.100s", strerror(errno));
a202 1
	}
d241 1
d361 1
a361 1
			    options.gateway_ports) < 0) {
@


1.272
log
@standardise on NI_MAXHOST for gethostname() string lengths; about
1/2 the cases were using it already. Fixes bz#2239 en passant
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.271 2014/03/03 22:22:30 djm Exp $ */
d1081 2
a1082 1
	    !no_user_rc && stat(_PATH_SSH_USER_RC, &st) >= 0) {
@


1.271
log
@ignore enviornment variables with embedded '=' or '\0' characters;
spotted by Jann Horn; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.270 2014/01/31 16:39:19 tedu Exp $ */
d48 1
d2264 1
a2264 1
	char hostname[MAXHOSTNAMELEN];
@


1.270
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.269 2014/01/18 09:36:26 dtucker Exp $ */
d874 5
d1866 2
a1867 2
	name = packet_get_string(&name_len);
	val = packet_get_string(&val_len);
@


1.269
log
@explicitly define USE_PIPES to 1 to prevent redefinition warnings in portable
on platforms that use pipes for everything.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.268 2013/10/29 09:48:02 djm Exp $ */
d1525 1
a1525 1
	bzero(&sessions[id], sizeof(*sessions));
@


1.268
log
@shd_config PermitTTY to disallow TTY allocation, mirroring the
longstanding no-pty authorized_keys option;
bz#2070, patch from Teran McKinney; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.267 2013/10/14 21:20:52 djm Exp $ */
d427 1
a427 1
#define USE_PIPES
@


1.267
log
@Add logging of session starts in a useful format; ok markus@@ feedback and
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.266 2013/07/19 07:37:48 markus Exp $ */
d1703 1
a1703 1
	if (no_pty_flag) {
@


1.266
log
@add ssh-agent(1) support to sshd(8); allows encrypted hostkeys,
or hostkeys on smartcards; most of the work by Zev Weiss; bz #1974
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.265 2013/05/17 00:13:14 djm Exp $ */
d715 2
d721 1
a721 6
		if (IS_INTERNAL_SFTP(command)) {
			s->is_subsystem = s->is_subsystem ?
			    SUBSYSTEM_INT_SFTP : SUBSYSTEM_INT_SFTP_ERROR;
		} else if (s->is_subsystem)
			s->is_subsystem = SUBSYSTEM_EXT;
		debug("Forced command (config) '%.900s'", command);
d725 3
d733 10
a742 1
		debug("Forced command (key option) '%.900s'", command);
d745 14
d1764 1
a1764 1
	char *prog, *cmd, *subsys = packet_get_string(&len);
d1767 1
d1769 1
a1769 1
	logit("subsystem request for %.100s by user %s", subsys,
d1773 1
a1773 1
		if (strcmp(subsys, options.subsystem_name[i]) == 0) {
d1792 2
a1793 2
		logit("subsystem request for %.100s failed, subsystem not found",
		    subsys);
a1794 1
	free(subsys);
d2141 1
@


1.265
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.264 2013/04/19 01:03:01 djm Exp $ */
d73 1
d1265 7
@


1.264
log
@reintroduce 1.262 without the connection-killing bug:

fatal() when ChrootDirectory specified by running without root privileges;

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.263 2013/04/17 09:04:09 dtucker Exp $ */
d185 1
a185 1
		xfree(auth_sock_dir);
d230 1
a230 2
	if (auth_sock_name != NULL)
		xfree(auth_sock_name);
d233 1
a233 1
		xfree(auth_sock_dir);
d349 2
a350 2
				xfree(s->auth_proto);
				xfree(s->auth_data);
d397 1
a397 1
				xfree(command);
d862 1
a862 1
		xfree(env[i]);
d985 2
a986 2
			xfree(ce->s);
			xfree(ce);
d998 1
a998 1
	xfree(laddr);
d1119 1
a1119 1
			xfree(nl);
d1694 1
a1694 1
		xfree(s->term);
d1702 1
a1702 2
		if (s->term)
			xfree(s->term);
d1763 1
a1763 1
	xfree(subsys);
d1785 2
a1786 2
		xfree(s->auth_proto);
		xfree(s->auth_data);
d1808 1
a1808 1
	xfree(command);
d1854 2
a1855 2
	xfree(name);
	xfree(val);
d2037 1
a2037 1
	xfree(s->x11_chanids);
d2039 8
a2046 16
	if (s->display) {
		xfree(s->display);
		s->display = NULL;
	}
	if (s->auth_proto) {
		xfree(s->auth_proto);
		s->auth_proto = NULL;
	}
	if (s->auth_data) {
		xfree(s->auth_data);
		s->auth_data = NULL;
	}
	if (s->auth_display) {
		xfree(s->auth_display);
		s->auth_display = NULL;
	}
d2104 6
a2109 12
	if (s->term)
		xfree(s->term);
	if (s->display)
		xfree(s->display);
	if (s->x11_chanids)
		xfree(s->x11_chanids);
	if (s->auth_display)
		xfree(s->auth_display);
	if (s->auth_data)
		xfree(s->auth_data);
	if (s->auth_proto)
		xfree(s->auth_proto);
d2112 2
a2113 2
			xfree(s->env[i].name);
			xfree(s->env[i].val);
d2115 1
a2115 1
		xfree(s->env);
@


1.263
log
@revert rev 1.262; it fails because uid is already set here.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.261 2012/12/02 20:46:11 djm Exp $ */
d1212 3
d1222 3
d1226 1
@


1.262
log
@fatal() when ChrootDirectory specified by running without root privileges;
ok markus@@
@
text
@d1219 1
a1219 4
	} else if (options.chroot_directory != NULL &&
	    strcasecmp(options.chroot_directory, "none") != 0)
		fatal("server lacks privileges to chroot to ChrootDirectory");

@


1.261
log
@make AllowTcpForwarding accept "local" and "remote" in addition to its
current "yes"/"no" to allow the server to specify whether just local or
remote TCP forwarding is enabled. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.260 2012/03/15 03:10:27 guenther Exp $ */
d1219 4
a1222 1
	}
@


1.260
log
@root should always be excluded from the test for /etc/nologin instead
of having it always enforced even when marked as ignorenologin.  This
regressed when the logic was incompletely flipped around in rev 1.251

ok halex@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.259 2011/10/24 02:13:13 djm Exp $ */
d259 4
a262 1
	if (!no_port_forwarding_flag && options.allow_tcp_forwarding)
d372 1
a372 1
			if (!options.allow_tcp_forwarding) {
@


1.259
log
@bz#1859: send tty break to pty master instead of (probably already
closed) slave side; "looks good" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.258 2010/11/25 04:10:09 djm Exp $ */
d1111 1
a1111 1
	if (login_getcapbool(lc, "ignorenologin", 0) && pw->pw_uid)
@


1.258
log
@replace close() loop for fds 3->64 with closefrom();
ok markus deraadt dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.257 2010/11/13 23:27:50 djm Exp $ */
d1811 1
a1811 1
	if (s->ttyfd == -1 || tcsendbreak(s->ttyfd, 0) < 0)
@


1.257
log
@allow ssh and sshd to set arbitrary TOS/DSCP/QoS values instead of
hardcoding lowdelay/throughput.

bz#1733 patch from philipp AT redfish-solutions.com; ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.256 2010/06/25 07:20:04 djm Exp $ */
a1254 2
	int i;

d1280 1
a1280 2
	for (i = 3; i < 64; i++)
		close(i);
@


1.256
log
@bz#1750: fix requirement for /dev/null inside ChrootDirectory for
internal-sftp accidentally introduced in r1.253 by removing the code
that opens and dup /dev/null to stderr and modifying the channels code
to read stderr but discard it instead; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.255 2010/06/22 04:59:12 djm Exp $ */
d562 2
a563 1
	packet_set_interactive(s->display != NULL);
d693 2
a694 1
	packet_set_interactive(1);
@


1.255
log
@include the user name on "subsystem request for ..." log messages;
bz#1571; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.254 2010/06/18 03:16:03 djm Exp $ */
d100 1
a100 1
void	session_set_fds(Session *, int, int, int, int);
d451 8
a458 21
	if (s->is_subsystem) {
	    	if ((perr[1] = open(_PATH_DEVNULL, O_WRONLY)) == -1) {
			error("%s: open(%s): %s", __func__, _PATH_DEVNULL,
			    strerror(errno));
			close(pin[0]);
			close(pin[1]);
			close(pout[0]);
			close(pout[1]);
			return -1;
		}
		perr[0] = -1;
	} else {
		if (pipe(perr) < 0) {
			error("%s: pipe err: %.100s", __func__,
			    strerror(errno));
			close(pin[0]);
			close(pin[1]);
			close(pout[0]);
			close(pout[1]);
			return -1;
		}
d471 6
a476 17
	if (s->is_subsystem) {
	    	if ((err[0] = open(_PATH_DEVNULL, O_WRONLY)) == -1) {
			error("%s: open(%s): %s", __func__, _PATH_DEVNULL,
			    strerror(errno));
			close(inout[0]);
			close(inout[1]);
			return -1;
		}
		err[1] = -1;
	} else {
		if (socketpair(AF_UNIX, SOCK_STREAM, 0, err) < 0) {
			error("%s: socketpair #2: %.100s", __func__,
			    strerror(errno));
			close(inout[0]);
			close(inout[1]);
			return -1;
		}
d491 1
a491 2
		if (perr[0] != -1)
			close(perr[0]);
d497 1
a497 2
		if (err[1] != -1)
			close(err[1]);
d531 1
a531 2
		if (perr[0] != -1)
			close(perr[0]);
d542 1
a542 2
		if (err[1] != -1)
			close(err[1]);
d571 2
a572 1
		session_set_fds(s, pin[1], pout[0], perr[0], 0);
d588 2
a589 1
		session_set_fds(s, inout[1], inout[1], err[1], 0);
d694 1
a694 1
		session_set_fds(s, ptyfd, fdout, -1, 1);
d1913 2
a1914 1
session_set_fds(Session *s, int fdin, int fdout, int fderr, int is_tty)
d1926 1
a1926 1
	    fderr == -1 ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,
@


1.254
log
@Missing check for chroot_director == "none" (we already checked against
NULL); bz#1564 from Jan.Pechanec AT Sun.COM
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.253 2010/04/23 22:42:05 djm Exp $ */
d1756 2
a1757 1
	logit("subsystem request for %.100s", subsys);
@


1.253
log
@set stderr to /dev/null for subsystems rather than just closing it.
avoids hangs if a subsystem or shell initialisation writes to stderr.
bz#1750; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.252 2010/03/07 11:57:13 dtucker Exp $ */
d1413 2
a1414 1
		if (r || options.chroot_directory == NULL)
@


1.252
log
@Hold authentication debug messages until after successful authentication.
Fixes an info leak of environment variables specified in authorized_keys,
reported by Jacob Appelbaum.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.251 2010/01/12 08:33:17 dtucker Exp $ */
d45 1
d437 3
d451 21
a471 7
	if (pipe(perr) < 0) {
		error("%s: pipe err: %.100s", __func__, strerror(errno));
		close(pin[0]);
		close(pin[1]);
		close(pout[0]);
		close(pout[1]);
		return -1;
d476 3
d484 17
a500 5
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, err) < 0) {
		error("%s: socketpair #2: %.100s", __func__, strerror(errno));
		close(inout[0]);
		close(inout[1]);
		return -1;
a503 3
	if (s == NULL)
		fatal("do_exec_no_pty: no session");

d515 2
a516 1
		close(perr[0]);
d522 2
a523 1
		close(err[1]);
d557 2
a558 1
		close(perr[0]);
d569 2
a570 1
		close(err[1]);
a598 4
		if (s->is_subsystem) {
			close(perr[0]);
			perr[0] = -1;
		}
d615 1
a615 4
		session_set_fds(s, inout[1], inout[1],
		    s->is_subsystem ? -1 : err[1], 0);
		if (s->is_subsystem)
			close(err[1]);
@


1.251
log
@Add explicit stat so we reliably detect nologin with bad perms. ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.250 2010/01/12 01:31:05 dtucker Exp $ */
d260 2
@


1.250
log
@Do not allow logins if /etc/nologin exists but is not readable by the user
logging in.  Noted by Jan.Pechanec at Sun, ok djm@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.249 2009/11/20 00:15:41 dtucker Exp $ */
d1103 2
a1104 1
	char buf[1024];
d1106 13
a1118 9
	if (!login_getcapbool(lc, "ignorenologin", 0) && pw->pw_uid)
		f = fopen(login_getcapstr(lc, "nologin", _PATH_NOLOGIN,
		    _PATH_NOLOGIN), "r");
	if (f != NULL || errno == EPERM) {
		/* /etc/nologin exists.  Print its contents and exit. */
		logit("User %.100s not allowed because %s exists",
		    pw->pw_name, _PATH_NOLOGIN);
		if (f == NULL)
			exit(254);
a1121 1
		exit(254);
d1123 1
@


1.249
log
@Warn but do not fail if stat()ing the subsystem binary fails.  This helps
with chrootdirectory+forcecommand=sftp-server and restricted shells.
bz #1599, ok djm.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.248 2009/11/19 23:39:50 djm Exp $ */
d1108 1
a1108 1
	if (f) {
d1112 2
@


1.248
log
@bz#1606: error when an attempt is made to connect to a server
with ForceCommand=internal-sftp with a shell session (i.e. not a
subsystem session). Avoids stuck client when attempting to ssh to such a
service. ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.247 2009/10/06 04:46:40 djm Exp $ */
d1725 1
a1725 1
			if (!strcmp(INTERNAL_SFTP_NAME, prog)) {
d1727 1
a1727 4
			} else if (stat(prog, &st) < 0) {
				error("subsystem: cannot stat %s: %s", prog,
				    strerror(errno));
				break;
d1729 3
d1733 1
a1734 1
			debug("subsystem: exec() %s", cmd);
@


1.247
log
@bz#1596: fflush(NULL) before exec() to ensure that everying (motd
in particular) has made it out before the streams go away.
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.246 2009/04/17 19:23:06 stevesk Exp $ */
d134 4
a137 3
#define SUBSYSTEM_NONE		0
#define SUBSYSTEM_EXT		1
#define SUBSYSTEM_INT_SFTP	2
d711 4
a714 3
		if (IS_INTERNAL_SFTP(command))
			s->is_subsystem = SUBSYSTEM_INT_SFTP;
		else if (s->is_subsystem)
d720 4
a723 3
		if (IS_INTERNAL_SFTP(command))
			s->is_subsystem = SUBSYSTEM_INT_SFTP;
		else if (s->is_subsystem)
d1393 5
a1397 1
	if (s->is_subsystem == SUBSYSTEM_INT_SFTP) {
@


1.246
log
@use INTERNAL_SFTP_NAME for setproctitle() of in-process sftp-server;
ok djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.245 2009/01/22 09:46:01 djm Exp $ */
d1405 2
@


1.245
log
@make Channel->path an allocated string, saving a few bytes here and
there and fixing bz#1380 in the process; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.244 2008/11/09 12:34:47 tobias Exp $ */
d1395 1
a1395 1
		setproctitle("%s@@internal-sftp-server", s->pw->pw_name);
@


1.244
log
@typo fixed (overriden -> overridden)

ok espie, jmc
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.243 2008/10/02 14:39:35 millert Exp $ */
d224 1
a224 1
	strlcpy(nc->path, auth_sock_name, sizeof(nc->path));
@


1.243
log
@Convert an unchecked strdup to xstrdup.  OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.242 2008/08/21 04:09:57 djm Exp $ */
d830 1
a830 1
 * already exists, its value is overriden.
@


1.242
log
@allow ForceCommand internal-sftp with arguments. based on patch from
michael.barabanov AT gmail.com; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.241 2008/06/16 13:22:53 dtucker Exp $ */
d1396 1
a1396 1
		args = strdup(command ? command : "sftp-server");
@


1.241
log
@Rename the isatty argument to is_tty so we don't shadow isatty(3).
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.240 2008/06/15 20:06:26 djm Exp $ */
d90 6
d710 1
a710 1
		if (strcmp(INTERNAL_SFTP_NAME, command) == 0)
d718 1
a718 1
		if (strcmp(INTERNAL_SFTP_NAME, command) == 0)
@


1.240
log
@don't call isatty() on a pty master, instead pass a flag down to
channel_set_fds() indicating that te fds refer to a tty. Fixes a
hang on exit on Solaris (bz#1463) in portable but is actually
a generic bug; ok dtucker deraadt markus
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.239 2008/06/14 18:33:43 djm Exp $ */
d1886 1
a1886 1
session_set_fds(Session *s, int fdin, int fdout, int fderr, int isatty)
d1899 1
a1899 1
	    1, isatty, CHAN_SES_WINDOW_DEFAULT);
@


1.239
log
@suppress the warning message from chdir(homedir) failures
when chrooted (bz#1461); ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.238 2008/05/09 16:16:06 markus Exp $ */
d93 1
a93 1
void	session_set_fds(Session *, int, int, int);
d560 1
a560 1
		session_set_fds(s, pin[1], pout[0], perr[0]);
d577 1
a577 1
		    s->is_subsystem ? -1 : err[1]);
d684 1
a684 1
		session_set_fds(s, ptyfd, fdout, -1);
d1886 1
a1886 1
session_set_fds(Session *s, int fdin, int fdout, int fderr)
d1899 1
a1899 2
	    1,
	    CHAN_SES_WINDOW_DEFAULT);
@


1.238
log
@re-add the USE_PIPES code and enable it.
without pipes shutdown-read from the sshd does not trigger
a SIGPIPE when the forked program does a write.

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.237 2008/05/08 12:21:16 djm Exp $ */
d1279 1
d1366 7
a1372 3
		fprintf(stderr, "Could not chdir to home directory %s: %s\n",
		    pw->pw_dir, strerror(errno));
		if (login_getcapbool(lc, "requirehome", 0))
@


1.237
log
@Make the maximum number of sessions run-time controllable via
a sshd_config MaxSessions knob. This is useful for disabling
login/shell/subsystem access while leaving port-forwarding working
(MaxSessions 0), disabling connection multiplexing (MaxSessions 1) or
simply increasing the number of allows multiplexed sessions.

Because some bozos are sure to configure MaxSessions in excess of the
number of available file descriptors in sshd (which, at peak, might be
as many as 9*MaxSessions), audit sshd to ensure that it doesn't leak fds
on error paths, and make it fail gracefully on out-of-fd conditions -
sending channel errors instead of than exiting with fatal().

bz#1090; MaxSessions config bits and manpage from junyer AT gmail.com

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.236 2008/05/08 12:02:23 djm Exp $ */
d414 1
d424 23
d460 1
d471 8
d483 1
d499 22
d532 1
d535 2
d549 18
d584 1
@


1.236
log
@Implement a channel success/failure status confirmation callback
mechanism. Each channel maintains a queue of callbacks, which will
be drained in order (RFC4253 guarantees confirm messages are not
reordered within an channel).

Also includes a abandonment callback to clean up if a channel is
closed without sending confirmation messages. This probably
shouldn't happen in compliant implementations, but it could be
abused to leak memory.

ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.235 2008/05/07 05:49:37 pyr Exp $ */
d97 3
a99 3
void	do_exec_pty(Session *, const char *);
void	do_exec_no_pty(Session *, const char *);
void	do_exec(Session *, const char *);
d124 3
a126 2
#define MAX_SESSIONS 10
Session	sessions[MAX_SESSIONS];
d158 1
a158 1
	int sock;
d170 1
a170 3
	auth_sock_name = xmalloc(MAXPATHLEN);
	auth_sock_dir = xmalloc(MAXPATHLEN);
	strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
a176 1
		xfree(auth_sock_name);
a177 1
		auth_sock_name = NULL;
d179 1
a179 1
		return 0;
d181 3
a183 2
	snprintf(auth_sock_name, MAXPATHLEN, "%s/agent.%ld",
		 auth_sock_dir, (long) getpid());
d187 5
a191 2
	if (sock < 0)
		packet_disconnect("socket: %.100s", strerror(errno));
d198 5
a202 2
	if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0)
		packet_disconnect("bind: %.100s", strerror(errno));
d208 4
a211 2
	if (listen(sock, SSH_LISTEN_BACKLOG) < 0)
		packet_disconnect("listen: %.100s", strerror(errno));
d220 13
d382 3
a384 1
				do_exec(s, command);
d387 3
a389 1
				do_exec(s, NULL);
d419 1
a419 1
void
d423 1
a424 1
	int inout[2], err[2];
d426 11
a436 4
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) < 0 ||
	    socketpair(AF_UNIX, SOCK_STREAM, 0, err) < 0)
		packet_disconnect("Could not create socket pairs: %.100s",
				  strerror(errno));
d443 9
a451 1
	if ((pid = fork()) == 0) {
d455 2
a456 1
		log_init(__progname, options.log_level, options.log_facility, log_stderr);
d474 1
a474 1
		if (dup2(inout[0], 1) < 0)	/* stdout.  Note: same socket as stdin. */
d482 2
d485 1
a485 2
	if (pid < 0)
		packet_disconnect("fork failed: %.100s", strerror(errno));
d499 4
a502 1
		session_set_fds(s, inout[1], inout[1], s->is_subsystem ? -1 : err[1]);
d507 1
d516 1
a516 1
void
d527 22
d550 9
a558 1
	if ((pid = fork()) == 0) {
d561 3
d565 2
a566 1
		log_init(__progname, options.log_level, options.log_facility, log_stderr);
d588 4
a591 1
		/* Do common processing for the child, such as execing the command. */
d594 2
a596 2
	if (pid < 0)
		packet_disconnect("fork failed: %.100s", strerror(errno));
d602 1
a602 13
	/*
	 * Create another descriptor of the pty master side for use as the
	 * standard input.  We could use the original descriptor, but this
	 * simplifies code in server_loop.  The descriptor is bidirectional.
	 */
	fdout = dup(ptyfd);
	if (fdout < 0)
		packet_disconnect("dup #1 failed: %.100s", strerror(errno));

	/* we keep a reference to the pty master */
	ptymaster = dup(ptyfd);
	if (ptymaster < 0)
		packet_disconnect("dup #2 failed: %.100s", strerror(errno));
a603 2

	/* Enter interactive session. */
d611 1
d618 1
a618 1
void
d621 2
d649 1
a649 1
		do_exec_pty(s, command);
d651 1
a651 1
		do_exec_no_pty(s, command);
d661 2
d1368 21
d1392 36
a1427 24
	int i;
	static int did_init = 0;
	if (!did_init) {
		debug("session_new: init");
		for (i = 0; i < MAX_SESSIONS; i++) {
			sessions[i].used = 0;
		}
		did_init = 1;
	}
	for (i = 0; i < MAX_SESSIONS; i++) {
		Session *s = &sessions[i];
		if (! s->used) {
			memset(s, 0, sizeof(*s));
			s->chanid = -1;
			s->ptyfd = -1;
			s->ttyfd = -1;
			s->used = 1;
			s->self = i;
			s->x11_chanids = NULL;
			debug("session_new: session %d", i);
			return s;
		}
	}
	return NULL;
d1434 1
a1434 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1436 3
a1438 1
		debug("dump: used %d session %d %p channel %d pid %ld",
d1440 1
d1470 1
a1470 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1486 1
a1486 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1489 2
a1490 1
			debug("session_by_channel: session %d channel %d", i, id);
d1504 1
a1504 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1527 1
a1527 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1583 2
a1584 1
	if (!PRIVSEP(pty_allocate(&s->ptyfd, &s->ttyfd, s->tty, sizeof(s->tty)))) {
d1637 1
a1637 2
			do_exec(s, cmd);
			success = 1;
d1680 1
a1680 2
	do_exec(s, NULL);
	return 1;
d1686 2
a1687 1
	u_int len;
d1690 1
a1690 1
	do_exec(s, command);
d1692 1
a1692 1
	return 1;
d1702 1
a1702 2
	if (s->ttyfd == -1 ||
	    tcsendbreak(s->ttyfd, 0) < 0)
d1849 3
a1851 2
	if (close(s->ptymaster) < 0)
		error("close(s->ptymaster/%d): %s", s->ptymaster, strerror(errno));
a2006 1
	s->used = 0;
d2015 1
d2079 1
a2079 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d2096 1
a2096 1
	for (i = 0; i < MAX_SESSIONS; i++) {
@


1.235
log
@Enable the AllowAgentForwarding option in sshd_config (global and match
context), to specify if agents should be permitted on the server.
As the man page states:

``Note that disabling Agent forwarding does not improve security
unless users are also denied shell access, as they can always install
their own forwarders.''

ok djm@@, ok and a mild frown markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.234 2008/04/18 22:01:33 djm Exp $ */
d42 1
@


1.234
log
@remove unneccessary parentheses
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.233 2008/03/26 21:28:14 djm Exp $ */
d325 2
a326 1
			if (no_agent_forwarding_flag || compat13) {
d1638 1
a1638 1
	if (no_agent_forwarding_flag) {
@


1.233
log
@add no-user-rc authorized_keys option to disable execution of ~/.ssh/rc
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.232 2008/03/25 23:01:41 djm Exp $ */
d883 1
a883 1
	    !no_user_rc &&  (stat(_PATH_SSH_USER_RC, &st) >= 0)) {
@


1.232
log
@last patch had backwards test; spotted by termim AT gmail.com
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.231 2008/03/25 11:58:02 djm Exp $ */
d883 1
a883 1
	    (stat(_PATH_SSH_USER_RC, &st) >= 0)) {
@


1.231
log
@ignore ~/.ssh/rc if a sshd_config ForceCommand is specified;
from dtucker@@ ok deraadt@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.230 2008/02/22 05:58:56 djm Exp $ */
d882 1
a882 1
	if (!s->is_subsystem && options.adm_forced_command != NULL &&
@


1.230
log
@closefrom() call was too early, delay it until just before we execute
the user's rc files (if any).
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.229 2008/02/20 15:25:26 markus Exp $ */
d881 3
a883 2
	/* ignore _PATH_SSH_USER_RC for subsystems */
	if (!s->is_subsystem && (stat(_PATH_SSH_USER_RC, &st) >= 0)) {
@


1.230.2.1
log
@ignore ~/.ssh/rc if a sshd_config ForceCommand is specified;

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.230 2008/02/22 05:58:56 djm Exp $ */
d881 2
a882 3
	/* ignore _PATH_SSH_USER_RC for subsystems and admin forced commands */
	if (!s->is_subsystem && options.adm_forced_command == NULL &&
	    (stat(_PATH_SSH_USER_RC, &st) >= 0)) {
@


1.229
log
@correct boolean encoding for coredump; der Mouse via dugsong
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.228 2008/02/13 22:38:17 djm Exp $ */
a437 2
		closefrom(STDERR_FILENO + 1);

a507 2
		closefrom(STDERR_FILENO + 1);

d1217 2
@


1.228
log
@rekey arc4random and OpenSSL RNG in postauth child
closefrom fds > 2 before shell/command execution
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.227 2008/02/10 10:54:29 djm Exp $ */
d1848 1
a1848 1
		packet_put_char(WCOREDUMP(status));
@


1.227
log
@delay ~ expansion for ChrootDirectory so it expands to the logged-in user's
home, rather than the user who starts sshd (probably root)
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.226 2008/02/08 23:24:07 djm Exp $ */
a88 3
/* Magic name for internal sftp-server */
#define INTERNAL_SFTP_NAME	"internal-sftp"

d438 2
d509 2
@


1.226
log
@add sshd_config ChrootDirectory option to chroot(2) users to a directory and
tweak internal sftp server to work with it (no special files in chroot
required). ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.225 2008/02/04 21:53:00 markus Exp $ */
d1019 2
d1031 4
a1034 4
			char *chroot_path;

			chroot_path = percent_expand(options.chroot_directory,
			    "h", pw->pw_dir, "u", pw->pw_name, (char *)NULL);
d1036 1
@


1.225
log
@link sftp-server into sshd; feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.224 2007/09/11 15:47:17 gilles Exp $ */
d77 1
d89 3
d557 3
a559 1
		if (s->is_subsystem)
d565 3
a567 1
		if (s->is_subsystem)
a578 1

d960 55
d1020 1
d1022 1
a1022 1
		    (LOGIN_SETALL & ~LOGIN_SETPATH)) < 0) {
d1026 16
d1237 1
a1237 1
		exit(sftp_server_main(i, argv));
d1512 1
a1512 1
			if (!strcmp("internal-sftp", prog)) {
@


1.224
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.223 2007/08/23 02:55:51 djm Exp $ */
d82 1
d125 4
d553 2
d559 2
d1038 1
d1044 1
a1044 1
	char *argv[10];
d1145 16
d1433 3
a1435 1
			if (stat(prog, &st) < 0) {
d1439 2
a1442 1
			s->is_subsystem = 1;
@


1.223
log
@missed include bits from last commit
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.222 2007/08/23 02:49:43 djm Exp $ */
d727 3
a729 2
		if (strchr(cp, '\n'))
			*strchr(cp, '\n') = '\0';
@


1.222
log
@unifdef HAVE_LOGIN_CAP; ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.221 2007/01/21 01:41:54 stevesk Exp $ */
d45 1
@


1.221
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.220 2006/10/09 23:36:11 djm Exp $ */
a122 1
#ifdef HAVE_LOGIN_CAP
a123 1
#endif
a625 1
#ifdef HAVE_LOGIN_CAP
a627 3
#else
		f = fopen("/etc/motd", "r");
#endif
a650 1
#ifdef HAVE_LOGIN_CAP
a652 4
#else
	if (stat(buf, &st) >= 0)
		return 1;
#endif
a773 1
#ifdef HAVE_LOGIN_CAP
a777 3
#else
		child_set_env(&env, &envsize, "PATH", _PATH_STDPATH);
#endif
a927 1
#ifdef HAVE_LOGIN_CAP
a930 4
#else
	if (pw->pw_uid)
		f = fopen(_PATH_NOLOGIN, "r");
#endif
a946 1
#ifdef HAVE_LOGIN_CAP
a951 17
#else
		if (setlogin(pw->pw_name) < 0)
			error("setlogin failed: %s", strerror(errno));
		if (setgid(pw->pw_gid) < 0) {
			perror("setgid");
			exit(1);
		}
		/* Initialize the group list. */
		if (initgroups(pw->pw_name, pw->pw_gid) < 0) {
			perror("initgroups");
			exit(1);
		}
		endgrent();

		/* Permanently switch to the desired uid. */
		permanently_set_uid(pw);
#endif
a1071 1
#ifdef HAVE_LOGIN_CAP
a1072 1
#endif
a1122 1
#ifdef HAVE_LOGIN_CAP
a1124 1
#endif
@


1.221.4.1
log
@ignore ~/.ssh/rc if a sshd_config ForceCommand is specified;

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.221 2007/01/21 01:41:54 stevesk Exp $ */
d881 2
a882 3
	/* ignore _PATH_SSH_USER_RC for subsystems and admin forced commands */
	if (!s->is_subsystem && options.adm_forced_command == NULL &&
	    (stat(_PATH_SSH_USER_RC, &st) >= 0)) {
@


1.221.2.1
log
@ignore ~/.ssh/rc if a sshd_config ForceCommand is specified;

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.221 2007/01/21 01:41:54 stevesk Exp $ */
d881 2
a882 3
	/* ignore _PATH_SSH_USER_RC for subsystems and admin forced commands */
	if (!s->is_subsystem && options.adm_forced_command == NULL &&
	    (stat(_PATH_SSH_USER_RC, &st) >= 0)) {
@


1.220
log
@xmalloc -> xcalloc that was missed previously, from portable
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.219 2006/08/29 10:40:19 djm Exp $ */
d1601 1
a1601 1
			success =  session_pty_req(s);
d1726 1
a1726 1
	if ((s  = session_by_x11_channel(id)) == NULL)
@


1.219
log
@normalise some inconsistent (but harmless) NULL pointer checks
spotted by the Stanford SATURN tool, via Isil Dillig;
ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.218 2006/08/18 09:15:20 markus Exp $ */
d766 1
a766 1
	env = xmalloc(envsize * sizeof(char *));
@


1.219.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.220 2006/10/09 23:36:11 djm Exp $ */
d766 1
a766 1
	env = xcalloc(envsize, sizeof(char *));
@


1.218
log
@delay authentication related cleanups until we're authenticated and
all alarms have been cancelled; ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.217 2006/08/04 20:46:05 stevesk Exp $ */
d1826 6
a1831 3
	for (i = 0; i < s->num_env; i++) {
		xfree(s->env[i].name);
		xfree(s->env[i].val);
a1832 2
	if (s->env != NULL)
		xfree(s->env);
@


1.217
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.216 2006/08/03 03:34:42 deraadt Exp $ */
d2023 1
a2023 1
	if (authctxt == NULL)
@


1.216
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.215 2006/08/01 23:22:47 stevesk Exp $ */
d1173 1
a1173 1
	signal(SIGPIPE,  SIG_DFL);
@


1.215
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.214 2006/07/26 13:57:17 stevesk Exp $ */
a35 2
#include "includes.h"

d53 1
a56 1
#include "xmalloc.h"
d64 4
a67 1
#include "bufaux.h"
d77 3
a79 1
#include "kex.h"
a83 4
#endif

#ifdef GSSAPI
#include "ssh-gss.h"
@


1.214
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.213 2006/07/26 02:35:17 stevesk Exp $ */
d50 1
@


1.213
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.212 2006/07/22 20:48:23 stevesk Exp $ */
d50 1
@


1.212
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.211 2006/07/20 15:26:15 stevesk Exp $ */
d43 1
@


1.211
log
@missed some needed #include <unistd.h> when KERBEROS5=no; issue from
massimo@@cedoc.mo.it
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.210 2006/07/19 13:07:10 dtucker Exp $ */
d49 1
@


1.210
log
@Add ForceCommand keyword to sshd_config, equivalent to the "command="
key option, man page entry and example in sshd_config.  Feedback & ok djm@@,
man page corrections & ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.209 2006/07/11 20:07:25 stevesk Exp $ */
d49 1
@


1.209
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.208 2006/07/11 18:50:48 markus Exp $ */
d542 5
a546 1
	if (forced_command) {
d549 1
a549 1
		debug("Forced command '%.900s'", command);
@


1.208
log
@add ExitOnForwardFailure: terminate the connection if ssh(1)
cannot set up all requested dynamic, local, and remote port
forwardings. ok djm, dtucker, stevesk, jmc
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.207 2006/07/08 21:48:53 stevesk Exp $ */
d44 1
@


1.207
log
@missed these from last commit:
move #include <sys/socket.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.206 2006/07/06 16:03:53 stevesk Exp $ */
d333 5
a337 1
			channel_input_port_forward_request(s->pw->pw_uid == 0, options.gateway_ports);
@


1.206
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.205 2006/07/06 10:47:05 djm Exp $ */
d42 1
@


1.205
log
@support arguments to Subsystem commands; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.204 2006/07/02 22:45:59 stevesk Exp $ */
d45 1
@


1.204
log
@move #include <grp.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.203 2006/04/20 21:53:44 djm Exp $ */
d1422 1
a1422 1
	char *cmd, *subsys = packet_get_string(&len);
d1430 4
a1433 3
			cmd = options.subsystem_command[i];
			if (stat(cmd, &st) < 0) {
				error("subsystem: cannot stat %s: %s", cmd,
@


1.203
log
@Switch from using pipes to socketpairs for communication between
sftp/scp and ssh, and between sshd and its subprocesses. This saves
a file descriptor per session and apparently makes userland ppp over
ssh work; ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.202 2006/03/25 13:17:02 djm Exp $ */
d43 1
@


1.202
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a381 7
#ifdef USE_PIPES
	int pin[2], pout[2], perr[2];
	/* Allocate pipes for communicating with the program. */
	if (pipe(pin) < 0 || pipe(pout) < 0 || pipe(perr) < 0)
		packet_disconnect("Could not create pipes: %.100s",
				  strerror(errno));
#else /* USE_PIPES */
a387 1
#endif /* USE_PIPES */
a406 22
#ifdef USE_PIPES
		/*
		 * Redirect stdin.  We close the parent side of the socket
		 * pair, and make the child side the standard input.
		 */
		close(pin[1]);
		if (dup2(pin[0], 0) < 0)
			perror("dup2 stdin");
		close(pin[0]);

		/* Redirect stdout. */
		close(pout[0]);
		if (dup2(pout[1], 1) < 0)
			perror("dup2 stdout");
		close(pout[1]);

		/* Redirect stderr. */
		close(perr[0]);
		if (dup2(perr[1], 2) < 0)
			perror("dup2 stderr");
		close(perr[1]);
#else /* USE_PIPES */
a419 1
#endif /* USE_PIPES */
a429 5
#ifdef USE_PIPES
	/* We are the parent.  Close the child sides of the pipes. */
	close(pin[0]);
	close(pout[1]);
	close(perr[1]);
a430 12
	if (compat20) {
		if (s->is_subsystem) {
			close(perr[0]);
			perr[0] = -1;
		}
		session_set_fds(s, pin[1], pout[0], perr[0]);
	} else {
		/* Enter the interactive session. */
		server_loop(pid, pin[1], pout[0], perr[0]);
		/* server_loop has closed pin[1], pout[0], and perr[0]. */
	}
#else /* USE_PIPES */
a444 1
#endif /* USE_PIPES */
@


1.201
log
@change OpenSSH's xrealloc() function from being xrealloc(p, new_size) to
xrealloc(p, new_nmemb, new_itemsize).

realloc is particularly prone to integer overflows because it is almost
always allocating "n * size" bytes, so this is a far safer API;
ok deraadt@@
@
text
@d1 1
@


1.200
log
@annoying spacing fixes getting in the way of real diffs
@
text
@d731 1
a731 1
			env = (*envp) = xrealloc(env, envsize * sizeof(char *));
d1576 2
a1577 2
			s->env = xrealloc(s->env, sizeof(*s->env) *
			    (s->num_env + 1));
@


1.199
log
@spacing
@
text
@d182 1
a182 1
	if (bind(sock, (struct sockaddr *) & sunaddr, sizeof(sunaddr)) < 0)
d629 1
a629 1
		    (struct sockaddr *) & from, &fromlen) < 0) {
@


1.198
log
@RCSID() can die
@
text
@d1821 1
a1821 1
	 * the channel gets EOF. The session will be then be closed 
@


1.197
log
@fix logout recording when privilege separation is disabled, analysis and
patch from vinschen at redhat.com; tested by dtucker@@ ok deraadt@@
@
text
@a35 1
RCSID("$OpenBSD: session.c,v 1.196 2006/02/20 17:19:54 stevesk Exp $");
@


1.197.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: session.c,v 1.219 2006/08/29 10:40:19 djm Exp $ */
d35 3
a41 2
#include <sys/socket.h>
#include <sys/param.h>
a42 2
#include <errno.h>
#include <grp.h>
a43 1
#include <pwd.h>
a44 4
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
a45 1
#include "xmalloc.h"
d49 1
d57 1
a57 4
#include "key.h"
#include "cipher.h"
#include "kex.h"
#include "hostfile.h"
d67 1
a67 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
d74 4
d183 1
a183 1
	if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0)
d330 1
a330 5
			if (channel_input_port_forward_request(s->pw->pw_uid == 0,
			    options.gateway_ports) < 0) {
				debug("Port forwarding failed.");
				break;
			}
d382 7
d395 1
d415 22
d450 1
d461 5
d467 12
d493 1
d583 1
a583 5
	if (options.adm_forced_command) {
		original_command = command;
		command = options.adm_forced_command;
		debug("Forced command (config) '%.900s'", command);
	} else if (forced_command) {
d586 1
a586 1
		debug("Forced command (key option) '%.900s'", command);
d630 1
a630 1
		    (struct sockaddr *)&from, &fromlen) < 0) {
d732 1
a732 1
			env = (*envp) = xrealloc(env, envsize, sizeof(char *));
d1206 1
a1206 1
	signal(SIGPIPE, SIG_DFL);
d1470 1
a1470 1
	char *prog, *cmd, *subsys = packet_get_string(&len);
d1478 3
a1480 4
			prog = options.subsystem_command[i];
			cmd = options.subsystem_args[i];
			if (stat(prog, &st) < 0) {
				error("subsystem: cannot stat %s: %s", prog,
d1577 2
a1578 2
			s->env = xrealloc(s->env, s->num_env + 1,
			    sizeof(*s->env));
d1822 1
a1822 1
	 * the channel gets EOF. The session will be then be closed
d1858 5
a1862 5
	if (s->env != NULL) {
		for (i = 0; i < s->num_env; i++) {
			xfree(s->env[i].name);
			xfree(s->env[i].val);
		}
a1863 1
	}
d2055 1
a2055 1
	if (authctxt == NULL || !authctxt->authenticated)
@


1.197.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.220 2006/10/09 23:36:11 djm Exp $ */
d766 1
a766 1
	env = xcalloc(envsize, sizeof(char *));
@


1.196
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.195 2006/02/20 17:02:44 stevesk Exp $");
a1818 1
	s->pid = 0;
d1880 1
@


1.195
log
@move #include <signal.h> out of includes.h; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.194 2006/02/20 16:36:14 stevesk Exp $");
d41 1
@


1.194
log
@move #include <sys/un.h> out of includes.h; ok djm@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.193 2006/02/10 01:44:27 stevesk Exp $");
d43 1
@


1.193
log
@move #include <sys/wait.h> out of includes.h; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.192 2006/02/08 12:15:27 stevesk Exp $");
d40 1
@


1.192
log
@move #include <paths.h> out of includes.h; ok markus@@
@
text
@d36 4
a39 1
RCSID("$OpenBSD: session.c,v 1.191 2005/12/24 02:27:41 djm Exp $");
@


1.191
log
@eliminate some code duplicated in privsep and non-privsep paths, and
explicitly clear SIGALRM handler; "groovy" deraadt@@
@
text
@d36 3
a38 1
RCSID("$OpenBSD: session.c,v 1.190 2005/12/17 21:13:05 stevesk Exp $");
@


1.190
log
@spelling: fowarding, fowarded
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.189 2005/12/12 13:46:18 markus Exp $");
a208 9
	/*
	 * Cancel the alarm we set to limit the time taken for
	 * authentication.
	 */
	alarm(0);
	if (startup_pipe != -1) {
		close(startup_pipe);
		startup_pipe = -1;
	}
@


1.189
log
@make sure protocol messages for internal channels are ignored.
allow adjust messages for non-open channels; with and ok djm@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.188 2005/10/30 08:52:17 djm Exp $");
d1508 1
a1508 1
		    "x11 fowarding already active", s->self);
@


1.188
log
@no need to escape single quotes in comments, no binary change
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.187 2005/10/10 10:23:08 djm Exp $");
d1740 1
a1740 1
	if ((c = channel_lookup(id)) == NULL) {
@


1.187
log
@fix regression I introduced in 4.2: X11 forwardings initiated after
a session has exited (e.g. "(sleep 5; xterm) &") would not start.
bz #1086 reported by t8m AT centrum.cz; ok markus@@ dtucker@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.186 2005/07/25 11:59:40 markus Exp $");
d1085 1
a1085 1
	 * Close any extra open file descriptors so that we don\'t have them
d1193 1
a1193 1
	/* Change current directory to the user\'s home directory. */
@


1.186
log
@add a new compression method that delays compression until the user
has been authenticated successfully and set compression to 'delayed'
for sshd.

this breaks older openssh clients (< 3.5) if they insist on
compression, so you have to re-enable compression in sshd_config.
ok djm@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.185 2005/07/17 07:17:55 djm Exp $");
a1794 1
	u_int i;
d1820 9
a1828 1
	channel_cancel_cleanup(s->chanid);
a1836 9
	s->chanid = -1;

	/* Close any X11 listeners associated with this session */
	if (s->x11_chanids != NULL) {
		for (i = 0; s->x11_chanids[i] != -1; i++) {
			session_close_x11(s->x11_chanids[i]);
			s->x11_chanids[i] = -1;
		}
	}
d1880 2
a1881 1
	session_close(s);
d1892 1
d1912 9
d2006 1
a2006 1
		    session_close_single_x11);
@


1.186.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.191 2005/12/24 02:27:41 djm Exp $");
d209 9
d1085 1
a1085 1
	 * Close any extra open file descriptors so that we don't have them
d1193 1
a1193 1
	/* Change current directory to the user's home directory. */
d1508 1
a1508 1
		    "x11 forwarding already active", s->self);
d1740 1
a1740 1
	if ((c = channel_by_id(id)) == NULL) {
d1795 1
d1821 1
a1821 9
	s->pid = 0;

	/*
	 * Adjust cleanup callback attachment to send close messages when
	 * the channel gets EOF. The session will be then be closed 
	 * by session_close_by_channel when the childs close their fds.
	 */
	channel_register_cleanup(c->self, session_close_by_channel, 1);

d1830 9
d1882 1
a1882 2
	if (s->ttyfd != -1)
		session_pty_cleanup(s);
a1892 1
	u_int i;
a1911 9

	/* Close any X11 listeners associated with this session */
	if (s->x11_chanids != NULL) {
		for (i = 0; s->x11_chanids[i] != -1; i++) {
			session_close_x11(s->x11_chanids[i]);
			s->x11_chanids[i] = -1;
		}
	}

d1997 1
a1997 1
		    session_close_single_x11, 0);
@


1.186.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: session.c,v 1.219 2006/08/29 10:40:19 djm Exp $ */
d35 2
a36 16
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/param.h>

#include <errno.h>
#include <grp.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
a37 1
#include "xmalloc.h"
d41 1
d49 1
a49 4
#include "key.h"
#include "cipher.h"
#include "kex.h"
#include "hostfile.h"
d59 1
a59 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
d66 4
d175 1
a175 1
	if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0)
d322 1
a322 5
			if (channel_input_port_forward_request(s->pw->pw_uid == 0,
			    options.gateway_ports) < 0) {
				debug("Port forwarding failed.");
				break;
			}
d374 7
d387 1
d407 22
d442 1
d453 5
d459 12
d485 1
d575 1
a575 5
	if (options.adm_forced_command) {
		original_command = command;
		command = options.adm_forced_command;
		debug("Forced command (config) '%.900s'", command);
	} else if (forced_command) {
d578 1
a578 1
		debug("Forced command (key option) '%.900s'", command);
d622 1
a622 1
		    (struct sockaddr *)&from, &fromlen) < 0) {
d724 1
a724 1
			env = (*envp) = xrealloc(env, envsize, sizeof(char *));
d1198 1
a1198 1
	signal(SIGPIPE, SIG_DFL);
d1462 1
a1462 1
	char *prog, *cmd, *subsys = packet_get_string(&len);
d1470 3
a1472 4
			prog = options.subsystem_command[i];
			cmd = options.subsystem_args[i];
			if (stat(prog, &st) < 0) {
				error("subsystem: cannot stat %s: %s", prog,
d1569 2
a1570 2
			s->env = xrealloc(s->env, s->num_env + 1,
			    sizeof(*s->env));
d1811 1
d1815 1
a1815 1
	 * the channel gets EOF. The session will be then be closed
d1851 5
a1855 5
	if (s->env != NULL) {
		for (i = 0; i < s->num_env; i++) {
			xfree(s->env[i].name);
			xfree(s->env[i].val);
		}
a1856 1
	}
a1872 1
	s->pid = 0;
d2047 1
a2047 1
	if (authctxt == NULL || !authctxt->authenticated)
@


1.186.2.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.220 2006/10/09 23:36:11 djm Exp $ */
d766 1
a766 1
	env = xcalloc(envsize, sizeof(char *));
@


1.185
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.184 2005/07/17 06:49:04 djm Exp $");
d59 1
d273 1
a273 1
			if (!options.compression) {
@


1.184
log
@Fix a number of X11 forwarding channel leaks:
1. Refuse multiple X11 forwarding requests on the same session
2. Clean up all listeners after a single_connection X11 forward, not just
   the one that made the single connection
3. Destroy X11 listeners when the session owning them goes away
testing and ok dtucker@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.183 2005/07/16 01:35:24 djm Exp $");
d1176 1
a1176 1
	     (s->authctxt->krb5_ctx != NULL)) {
@


1.183
log
@spacing
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.182 2005/06/17 02:44:33 djm Exp $");
d1280 1
d1354 23
d1505 5
d1735 56
d1794 1
d1830 8
d1852 2
d1892 1
d1964 1
d1990 1
a1990 1
	    &s->display_number) == -1) {
d1993 4
@


1.182
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.181 2004/12/23 17:35:48 markus Exp $");
d196 5
a200 5
        if (buffer_len(&loginmsg) > 0) {
                buffer_append(&loginmsg, "\0", 1);
                printf("%s", (char *)buffer_ptr(&loginmsg));
                buffer_clear(&loginmsg);
        }
@


1.181
log
@check for NULL; from mpech
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.180 2004/07/28 09:40:29 markus Exp $");
d1447 1
a1447 1
	int i;
d1749 1
a1749 1
	int i;
@


1.181.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.186 2005/07/25 11:59:40 markus Exp $");
a58 1
#include "kex.h"
d196 5
a200 5
	if (buffer_len(&loginmsg) > 0) {
		buffer_append(&loginmsg, "\0", 1);
		printf("%s", (char *)buffer_ptr(&loginmsg));
		buffer_clear(&loginmsg);
	}
d272 1
a272 1
			if (options.compression == COMP_NONE) {
d1176 1
a1176 1
	    (s->authctxt->krb5_ctx != NULL)) {
a1279 1
			s->x11_chanids = NULL;
a1352 23
session_by_x11_channel(int id)
{
	int i, j;

	for (i = 0; i < MAX_SESSIONS; i++) {
		Session *s = &sessions[i];

		if (s->x11_chanids == NULL || !s->used)
			continue;
		for (j = 0; s->x11_chanids[j] != -1; j++) {
			if (s->x11_chanids[j] == id) {
				debug("session_by_x11_channel: session %d "
				    "channel %d", s->self, id);
				return s;
			}
		}
	}
	debug("session_by_x11_channel: unknown channel %d", id);
	session_dump();
	return NULL;
}

static Session *
d1447 1
a1447 1
	u_int i;
a1480 5
	if (s->auth_proto != NULL || s->auth_data != NULL) {
		error("session_x11_req: session %d: "
		    "x11 fowarding already active", s->self);
		return 0;
	}
a1705 56
session_close_x11(int id)
{
	Channel *c;

	if ((c = channel_lookup(id)) == NULL) {
		debug("session_close_x11: x11 channel %d missing", id);
	} else {
		/* Detach X11 listener */
		debug("session_close_x11: detach x11 channel %d", id);
		channel_cancel_cleanup(id);
		if (c->ostate != CHAN_OUTPUT_CLOSED)
			chan_mark_dead(c);
	}
}

static void
session_close_single_x11(int id, void *arg)
{
	Session *s;
	u_int i;

	debug3("session_close_single_x11: channel %d", id);
	channel_cancel_cleanup(id);
	if ((s  = session_by_x11_channel(id)) == NULL)
		fatal("session_close_single_x11: no x11 channel %d", id);
	for (i = 0; s->x11_chanids[i] != -1; i++) {
		debug("session_close_single_x11: session %d: "
		    "closing channel %d", s->self, s->x11_chanids[i]);
		/*
		 * The channel "id" is already closing, but make sure we
		 * close all of its siblings.
		 */
		if (s->x11_chanids[i] != id)
			session_close_x11(s->x11_chanids[i]);
	}
	xfree(s->x11_chanids);
	s->x11_chanids = NULL;
	if (s->display) {
		xfree(s->display);
		s->display = NULL;
	}
	if (s->auth_proto) {
		xfree(s->auth_proto);
		s->auth_proto = NULL;
	}
	if (s->auth_data) {
		xfree(s->auth_data);
		s->auth_data = NULL;
	}
	if (s->auth_display) {
		xfree(s->auth_display);
		s->auth_display = NULL;
	}
}

static void
a1708 1
	u_int i;
a1743 8

	/* Close any X11 listeners associated with this session */
	if (s->x11_chanids != NULL) {
		for (i = 0; s->x11_chanids[i] != -1; i++) {
			session_close_x11(s->x11_chanids[i]);
			s->x11_chanids[i] = -1;
		}
	}
d1749 1
a1749 1
	u_int i;
a1757 2
	if (s->x11_chanids)
		xfree(s->x11_chanids);
a1795 1

a1866 1
	u_int i;
d1892 1
a1892 1
	    &s->display_number, &s->x11_chanids) == -1) {
a1894 4
	}
	for (i = 0; s->x11_chanids[i] != -1; i++) {
		channel_register_cleanup(s->x11_chanids[i],
		    session_close_single_x11);
@


1.181.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.191 2005/12/24 02:27:41 djm Exp $");
d209 9
d1085 1
a1085 1
	 * Close any extra open file descriptors so that we don't have them
d1193 1
a1193 1
	/* Change current directory to the user's home directory. */
d1508 1
a1508 1
		    "x11 forwarding already active", s->self);
d1740 1
a1740 1
	if ((c = channel_by_id(id)) == NULL) {
d1795 1
d1821 1
a1821 9
	s->pid = 0;

	/*
	 * Adjust cleanup callback attachment to send close messages when
	 * the channel gets EOF. The session will be then be closed 
	 * by session_close_by_channel when the childs close their fds.
	 */
	channel_register_cleanup(c->self, session_close_by_channel, 1);

d1830 9
d1882 1
a1882 2
	if (s->ttyfd != -1)
		session_pty_cleanup(s);
a1892 1
	u_int i;
a1911 9

	/* Close any X11 listeners associated with this session */
	if (s->x11_chanids != NULL) {
		for (i = 0; s->x11_chanids[i] != -1; i++) {
			session_close_x11(s->x11_chanids[i]);
			s->x11_chanids[i] = -1;
		}
	}

d1997 1
a1997 1
		    session_close_single_x11, 0);
@


1.180
log
@more s/illegal/invalid/
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.179 2004/07/17 05:31:41 dtucker Exp $");
d245 4
@


1.180.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.181 2004/12/23 17:35:48 markus Exp $");
a244 4
	if (s == NULL) {
		error("no more sessions");
		return;
	}
@


1.180.2.2
log
@upgrade to OpenSSH 4.2
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.186 2005/07/25 11:59:40 markus Exp $");
a58 1
#include "kex.h"
d196 5
a200 5
	if (buffer_len(&loginmsg) > 0) {
		buffer_append(&loginmsg, "\0", 1);
		printf("%s", (char *)buffer_ptr(&loginmsg));
		buffer_clear(&loginmsg);
	}
d272 1
a272 1
			if (options.compression == COMP_NONE) {
d1176 1
a1176 1
	    (s->authctxt->krb5_ctx != NULL)) {
a1279 1
			s->x11_chanids = NULL;
a1352 23
session_by_x11_channel(int id)
{
	int i, j;

	for (i = 0; i < MAX_SESSIONS; i++) {
		Session *s = &sessions[i];

		if (s->x11_chanids == NULL || !s->used)
			continue;
		for (j = 0; s->x11_chanids[j] != -1; j++) {
			if (s->x11_chanids[j] == id) {
				debug("session_by_x11_channel: session %d "
				    "channel %d", s->self, id);
				return s;
			}
		}
	}
	debug("session_by_x11_channel: unknown channel %d", id);
	session_dump();
	return NULL;
}

static Session *
d1447 1
a1447 1
	u_int i;
a1480 5
	if (s->auth_proto != NULL || s->auth_data != NULL) {
		error("session_x11_req: session %d: "
		    "x11 fowarding already active", s->self);
		return 0;
	}
a1705 56
session_close_x11(int id)
{
	Channel *c;

	if ((c = channel_lookup(id)) == NULL) {
		debug("session_close_x11: x11 channel %d missing", id);
	} else {
		/* Detach X11 listener */
		debug("session_close_x11: detach x11 channel %d", id);
		channel_cancel_cleanup(id);
		if (c->ostate != CHAN_OUTPUT_CLOSED)
			chan_mark_dead(c);
	}
}

static void
session_close_single_x11(int id, void *arg)
{
	Session *s;
	u_int i;

	debug3("session_close_single_x11: channel %d", id);
	channel_cancel_cleanup(id);
	if ((s  = session_by_x11_channel(id)) == NULL)
		fatal("session_close_single_x11: no x11 channel %d", id);
	for (i = 0; s->x11_chanids[i] != -1; i++) {
		debug("session_close_single_x11: session %d: "
		    "closing channel %d", s->self, s->x11_chanids[i]);
		/*
		 * The channel "id" is already closing, but make sure we
		 * close all of its siblings.
		 */
		if (s->x11_chanids[i] != id)
			session_close_x11(s->x11_chanids[i]);
	}
	xfree(s->x11_chanids);
	s->x11_chanids = NULL;
	if (s->display) {
		xfree(s->display);
		s->display = NULL;
	}
	if (s->auth_proto) {
		xfree(s->auth_proto);
		s->auth_proto = NULL;
	}
	if (s->auth_data) {
		xfree(s->auth_data);
		s->auth_data = NULL;
	}
	if (s->auth_display) {
		xfree(s->auth_display);
		s->auth_display = NULL;
	}
}

static void
a1708 1
	u_int i;
a1743 8

	/* Close any X11 listeners associated with this session */
	if (s->x11_chanids != NULL) {
		for (i = 0; s->x11_chanids[i] != -1; i++) {
			session_close_x11(s->x11_chanids[i]);
			s->x11_chanids[i] = -1;
		}
	}
d1749 1
a1749 1
	u_int i;
a1757 2
	if (s->x11_chanids)
		xfree(s->x11_chanids);
a1795 1

a1866 1
	u_int i;
d1892 1
a1892 1
	    &s->display_number, &s->x11_chanids) == -1) {
a1894 4
	}
	for (i = 0; s->x11_chanids[i] != -1; i++) {
		channel_register_cleanup(s->x11_chanids[i],
		    session_close_single_x11);
@


1.179
log
@Move "Last logged in at.." message generation to the monitor, right
before recording the new login.  Fixes missing lastlog message when
/var/log/lastlog is not world-readable and incorrect datestamp when
multiple sessions are used (bz #463);  much assistance & ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.178 2004/07/11 17:48:47 deraadt Exp $");
d264 1
a264 1
				packet_send_debug("Received illegal compression level %d.",
@


1.178
log
@spaces
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.177 2004/06/30 08:36:59 djm Exp $");
d97 1
d193 9
d599 7
a612 1
	char *time_string;
d642 1
a642 10
	if (options.print_lastlog && s->last_login_time != 0) {
		time_string = ctime(&s->last_login_time);
		if (strchr(time_string, '\n'))
			*strchr(time_string, '\n') = 0;
		if (strcmp(s->hostname, "") == 0)
			printf("Last login: %s\r\n", time_string);
		else
			printf("Last login: %s from %s\r\n", time_string,
			    s->hostname);
	}
d1027 1
a1387 6
	}
	/* Get the time and hostname when the user last logged in. */
	if (options.print_lastlog) {
		s->hostname[0] = '\0';
		s->last_login_time = get_last_login_time(s->pw->pw_uid,
		    s->pw->pw_name, s->hostname, sizeof(s->hostname));
@


1.177
log
@unbreak TTY break, diagnosed by darren AT dazwin.com; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.176 2004/06/21 17:53:03 djm Exp $");
d801 1
a801 1
			child_set_env(&env, &envsize, s->env[i].name, 
d1022 1
a1022 1
	    	fprintf(stderr,
@


1.176
log
@fix fd leak for multiple subsystem connections; with markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.175 2004/05/11 19:01:43 deraadt Exp $");
a1604 2
		} else if (strcmp(rtype, "break") == 0) {
			success = session_break_req(s);
d1611 2
d1614 1
@


1.175
log
@improve some code lint did not like; djm millert ok
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.174 2004/05/09 01:19:28 djm Exp $");
d454 5
a458 1
		session_set_fds(s, pin[1], pout[0], s->is_subsystem ? -1 : perr[0]);
@


1.174
log
@kill some more tiny files; ok deraadt@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.173 2004/04/27 09:46:37 djm Exp $");
a1508 1
	u_int break_length;
d1510 1
a1510 1
	break_length = packet_get_int();	/* ignored */
@


1.173
log
@bz #815: implement ability to pass specified environment variables from the
client to the server; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.172 2004/01/30 09:48:57 markus Exp $");
a45 1
#include "mpaux.h"
@


1.172
log
@support for password change; ok dtucker@@
(set password-dead=1w in login.conf to use this).
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.171 2004/01/13 19:23:15 markus Exp $");
d45 1
d797 4
d1522 35
d1605 2
d1740 2
d1756 6
@


1.172.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.180 2004/07/28 09:40:29 markus Exp $");
d45 1
a45 1
#include "match.h"
a96 1
extern Buffer loginmsg;
a191 9
static void
display_loginmsg(void)
{
        if (buffer_len(&loginmsg) > 0) {
                buffer_append(&loginmsg, "\0", 1);
                printf("%s", (char *)buffer_ptr(&loginmsg));
                buffer_clear(&loginmsg);
        }
}
d254 1
a254 1
				packet_send_debug("Received invalid compression level %d.",
d454 1
a454 5
		if (s->is_subsystem) {
			close(perr[0]);
			perr[0] = -1;
		}
		session_set_fds(s, pin[1], pout[0], perr[0]);
a584 7

	/*
	 * Clear loginmsg: it's the child's responsibility to display
	 * it to the user, otherwise multiple sessions may accumulate
	 * multiple copies of the login messages.
	 */
	buffer_clear(&loginmsg);
d592 1
d622 10
a631 1
	display_loginmsg();
a795 4
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

a1011 1
	fflush(NULL);
d1014 1
a1014 1
		fprintf(stderr,
d1373 6
d1505 1
d1507 1
a1507 1
	packet_get_int();	/* ignored */
a1516 35
session_env_req(Session *s)
{
	char *name, *val;
	u_int name_len, val_len, i;

	name = packet_get_string(&name_len);
	val = packet_get_string(&val_len);
	packet_check_eom();

	/* Don't set too many environment variables */
	if (s->num_env > 128) {
		debug2("Ignoring env request %s: too many env vars", name);
		goto fail;
	}

	for (i = 0; i < options.num_accept_env; i++) {
		if (match_pattern(name, options.accept_env[i])) {
			debug2("Setting env %d: %s=%s", s->num_env, name, val);
			s->env = xrealloc(s->env, sizeof(*s->env) *
			    (s->num_env + 1));
			s->env[s->num_env].name = name;
			s->env[s->num_env].val = val;
			s->num_env++;
			return (1);
		}
	}
	debug2("Ignoring env request %s: disallowed name", name);

 fail:
	xfree(name);
	xfree(val);
	return (0);
}

static int
d1563 2
a1564 2
		} else if (strcmp(rtype, "env") == 0) {
			success = session_env_req(s);
a1568 2
	} else if (strcmp(rtype, "break") == 0) {
		success = session_break_req(s);
a1569 1

a1697 2
	int i;

a1711 6
	for (i = 0; i < s->num_env; i++) {
		xfree(s->env[i].name);
		xfree(s->env[i].val);
	}
	if (s->env != NULL)
		xfree(s->env);
@


1.172.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.181 2004/12/23 17:35:48 markus Exp $");
a244 4
	if (s == NULL) {
		error("no more sessions");
		return;
	}
@


1.171
log
@-Wall; ok henning
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.170 2003/12/23 16:12:10 jakob Exp $");
d1010 16
d1039 34
a1085 1
	u_int i;
d1090 8
d1138 1
a1138 27
	if (packet_get_connection_in() == packet_get_connection_out())
		close(packet_get_connection_in());
	else {
		close(packet_get_connection_in());
		close(packet_get_connection_out());
	}
	/*
	 * Close all descriptors related to channels.  They will still remain
	 * open in the parent.
	 */
	/* XXX better use close-on-exec? -markus */
	channel_close_all();

	/*
	 * Close any extra file descriptors.  Note that there may still be
	 * descriptors left by system functions.  They will be closed later.
	 */
	endpwent();

	/*
	 * Close any extra open file descriptors so that we don\'t have them
	 * hanging around in clients.  Note that we want to do this after
	 * initgroups, because at least on Solaris 2.3 it leaves file
	 * descriptors open.
	 */
	for (i = 3; i < 64; i++)
		close(i);
@


1.170
log
@implement KerberosGetAFSToken server option. ok markus@@, beck@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.169 2003/12/02 17:01:15 markus Exp $");
d60 4
@


1.169
log
@use SSH_LISTEN_BACKLOG (=128) in listen(2).
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.168 2003/11/21 11:57:03 djm Exp $");
d1110 26
@


1.168
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.167 2003/11/04 08:54:09 djm Exp $");
d176 1
a176 1
	if (listen(sock, 5) < 0)
@


1.167
log
@standardise arguments to auth methods - they should all take authctxt.
check authctxt->valid rather then pw != NULL; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.166 2003/10/14 19:54:39 markus Exp $");
d784 1
a784 1
	/* Allow any GSSAPI methods that we've used to alter 
@


1.166
log
@10X for mkdtemp; djm@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.165 2003/09/23 20:17:11 markus Exp $");
d1232 1
a1232 1
	if (s->pw == NULL)
@


1.165
log
@replace fatal_cleanup() and linked list of fatal callbacks with static
cleanup_exit() function.  re-refine cleanup_exit() where appropriate,
allocate sshd's authctxt eary to allow simpler cleanup in sshd.
tested by many, ok deraadt@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.164 2003/09/18 08:49:45 markus Exp $");
d143 1
a143 1
	strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXX", MAXPATHLEN);
@


1.164
log
@more buffer allocation fixes; from Solar Designer; CAN-2003-0682; ok millert@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.163 2003/08/31 13:29:05 markus Exp $");
d69 1
a69 1
void	session_pty_cleanup(void *);
d105 2
d114 1
a114 1
auth_sock_cleanup_proc(void *_pw)
a115 2
	struct passwd *pw = _pw;

a158 3
	/* delete agent socket on fatal() */
	fatal_add_cleanup(auth_sock_cleanup_proc, pw);

d212 1
a212 7
	/* remove agent socket */
	if (auth_sock_name != NULL)
		auth_sock_cleanup_proc(authctxt->pw);
#ifdef KRB5
	if (options.kerberos_ticket_cleanup)
		krb5_cleanup_proc(authctxt);
#endif
d385 1
a385 1
		fatal_remove_all_cleanups();
d493 1
a493 1
		fatal_remove_all_cleanups();
d604 1
a604 1
			fatal_cleanup();
d924 1
a924 1
  			    options.xauth_location, s->auth_display);
a1353 5
	/*
	 * Add a cleanup function to clear the utmp entry and record logout
	 * time in case we call fatal() (e.g., the connection gets closed).
	 */
	fatal_add_cleanup(session_pty_cleanup, (void *)s);
d1535 1
a1535 1
session_pty_cleanup2(void *session)
a1536 2
	Session *s = session;

d1567 1
a1567 1
session_pty_cleanup(void *session)
d1569 1
a1569 1
	PRIVSEP(session_pty_cleanup2(session));
d1638 1
a1638 2
	if (s->ttyfd != -1) {
		fatal_remove_cleanup(session_pty_cleanup, (void *)s);
a1639 1
	}
d1688 1
a1688 2
		if (s->ttyfd != -1) {
			fatal_remove_cleanup(session_pty_cleanup, (void *)s);
a1689 1
		}
d1806 24
a1829 3
#if defined(GSSAPI)
	if (options.gss_cleanup_creds)
		ssh_gssapi_cleanup_creds(NULL);
d1831 15
@


1.163
log
@call ssh_gssapi_storecreds conditionally from do_exec(); with sxw@@inf.ed.ac.uk
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.162 2003/08/28 12:54:34 markus Exp $");
d698 2
a700 1
	char **env;
d717 7
a723 6
		if (i >= (*envsizep) - 1) {
			if (*envsizep >= 1000)
				fatal("child_set_env: too many env vars,"
				    " skipping: %.100s", name);
			(*envsizep) += 50;
			env = (*envp) = xrealloc(env, (*envsizep) * sizeof(char *));
@


1.163.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.172 2004/01/30 09:48:57 markus Exp $");
a60 4
#ifdef KRB5
#include <kafs.h>
#endif

d69 1
a69 1
void	session_pty_cleanup(Session *);
a104 2
static int is_child = 0;

d112 1
a112 1
auth_sock_cleanup_proc(struct passwd *pw)
d114 2
d143 1
a143 1
	strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
d159 3
d179 1
a179 1
	if (listen(sock, SSH_LISTEN_BACKLOG) < 0)
d215 7
a221 1
	do_cleanup(authctxt);
d394 1
a394 1
		is_child = 1;
d502 1
a502 1
		is_child = 1;
d613 1
a613 1
			cleanup_exit(255);
d698 1
a699 2
	u_int envsize;
	u_int i, namelen;
d716 6
a721 7
		envsize = *envsizep;
		if (i >= envsize - 1) {
			if (envsize >= 1000)
				fatal("child_set_env: too many env vars");
			envsize += 50;
			env = (*envp) = xrealloc(env, envsize * sizeof(char *));
			*envsizep = envsize;
d791 1
a791 1
	/* Allow any GSSAPI methods that we've used to alter
d931 1
a931 1
			    options.xauth_location, s->auth_display);
a1012 16
do_pwchange(Session *s)
{
	fprintf(stderr, "WARNING: Your password has expired.\n");
	if (s->ttyfd != -1) {
	    	fprintf(stderr,
		    "You must change your password now and login again!\n");
		execl(_PATH_PASSWD_PROG, "passwd", (char *)NULL);
		perror("passwd");
	} else {
		fprintf(stderr,
		    "Password change required but no TTY available.\n");
	}
	exit(1);
}

static void
a1025 34
static void
child_close_fds(void)
{
	int i;

	if (packet_get_connection_in() == packet_get_connection_out())
		close(packet_get_connection_in());
	else {
		close(packet_get_connection_in());
		close(packet_get_connection_out());
	}
	/*
	 * Close all descriptors related to channels.  They will still remain
	 * open in the parent.
	 */
	/* XXX better use close-on-exec? -markus */
	channel_close_all();

	/*
	 * Close any extra file descriptors.  Note that there may still be
	 * descriptors left by system functions.  They will be closed later.
	 */
	endpwent();

	/*
	 * Close any extra open file descriptors so that we don\'t have them
	 * hanging around in clients.  Note that we want to do this after
	 * initgroups, because at least on Solaris 2.3 it leaves file
	 * descriptors open.
	 */
	for (i = 3; i < 64; i++)
		close(i);
}

d1039 1
a1043 8
	/* Force a password change */
	if (s->authctxt->force_pwchange) {
		do_setusercontext(pw);
		child_close_fds();
		do_pwchange(s);
		exit(1);
	}

d1084 12
a1095 1
	child_close_fds();
d1098 2
a1099 2
	 * Must take new environment into use so that .ssh/rc,
	 * /etc/ssh/sshrc and xauth are run in the proper environment.
d1101 1
a1101 1
	environ = env;
a1102 1
#ifdef KRB5
d1104 4
a1107 5
	 * At this point, we check to see if AFS is active and if we have
	 * a valid Kerberos 5 TGT. If so, it seems like a good idea to see
	 * if we can (and need to) extend the ticket into an AFS token. If
	 * we don't do this, we run into potential problems if the user's
	 * home directory is in AFS and it's not world-readable.
d1109 2
d1112 5
a1116 16
	if (options.kerberos_get_afs_token && k_hasafs() &&
	     (s->authctxt->krb5_ctx != NULL)) {
		char cell[64];

		debug("Getting AFS token");

		k_setpag();

		if (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)
			krb5_afslog(s->authctxt->krb5_ctx,
			    s->authctxt->krb5_fwd_ccache, cell, NULL);

		krb5_afslog_home(s->authctxt->krb5_ctx,
		    s->authctxt->krb5_fwd_ccache, NULL, NULL, pw->pw_dir);
	}
#endif
d1239 1
a1239 1
	if (s->pw == NULL || !authctxt->valid)
d1361 5
d1547 1
a1547 1
session_pty_cleanup2(Session *s)
d1549 2
d1581 1
a1581 1
session_pty_cleanup(Session *s)
d1583 1
a1583 1
	PRIVSEP(session_pty_cleanup2(s));
d1652 2
a1653 1
	if (s->ttyfd != -1)
d1655 1
d1704 2
a1705 1
		if (s->ttyfd != -1)
d1707 1
d1824 3
a1826 24
}

void
do_cleanup(Authctxt *authctxt)
{
	static int called = 0;

	debug("do_cleanup");

	/* no cleanup if we're in the child for login shell */
	if (is_child)
		return;

	/* avoid double cleanup */
	if (called)
		return;
	called = 1;

	if (authctxt == NULL)
		return;
#ifdef KRB5
	if (options.kerberos_ticket_cleanup &&
	    authctxt->krb5_ctx)
		krb5_cleanup_proc(authctxt);
a1827 15

#ifdef GSSAPI
	if (compat20 && options.gss_cleanup_creds)
		ssh_gssapi_cleanup_creds();
#endif

	/* remove agent socket */
	auth_sock_cleanup_proc(authctxt->pw);

	/*
	 * Cleanup ptys/utmp only if privsep is disabled,
	 * or if running in monitor.
	 */
	if (!use_privsep || mm_is_monitor())
		session_destroy_all(session_pty_cleanup2);
@


1.163.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.180 2004/07/28 09:40:29 markus Exp $");
d45 1
a45 1
#include "match.h"
a96 1
extern Buffer loginmsg;
a191 9
static void
display_loginmsg(void)
{
        if (buffer_len(&loginmsg) > 0) {
                buffer_append(&loginmsg, "\0", 1);
                printf("%s", (char *)buffer_ptr(&loginmsg));
                buffer_clear(&loginmsg);
        }
}
d254 1
a254 1
				packet_send_debug("Received invalid compression level %d.",
d454 1
a454 5
		if (s->is_subsystem) {
			close(perr[0]);
			perr[0] = -1;
		}
		session_set_fds(s, pin[1], pout[0], perr[0]);
a584 7

	/*
	 * Clear loginmsg: it's the child's responsibility to display
	 * it to the user, otherwise multiple sessions may accumulate
	 * multiple copies of the login messages.
	 */
	buffer_clear(&loginmsg);
d592 1
d622 10
a631 1
	display_loginmsg();
a795 4
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

a1011 1
	fflush(NULL);
d1014 1
a1014 1
		fprintf(stderr,
d1373 6
d1505 1
d1507 1
a1507 1
	packet_get_int();	/* ignored */
a1516 35
session_env_req(Session *s)
{
	char *name, *val;
	u_int name_len, val_len, i;

	name = packet_get_string(&name_len);
	val = packet_get_string(&val_len);
	packet_check_eom();

	/* Don't set too many environment variables */
	if (s->num_env > 128) {
		debug2("Ignoring env request %s: too many env vars", name);
		goto fail;
	}

	for (i = 0; i < options.num_accept_env; i++) {
		if (match_pattern(name, options.accept_env[i])) {
			debug2("Setting env %d: %s=%s", s->num_env, name, val);
			s->env = xrealloc(s->env, sizeof(*s->env) *
			    (s->num_env + 1));
			s->env[s->num_env].name = name;
			s->env[s->num_env].val = val;
			s->num_env++;
			return (1);
		}
	}
	debug2("Ignoring env request %s: disallowed name", name);

 fail:
	xfree(name);
	xfree(val);
	return (0);
}

static int
d1563 2
a1564 2
		} else if (strcmp(rtype, "env") == 0) {
			success = session_env_req(s);
a1568 2
	} else if (strcmp(rtype, "break") == 0) {
		success = session_break_req(s);
a1569 1

a1697 2
	int i;

a1711 6
	for (i = 0; i < s->num_env; i++) {
		xfree(s->env[i].name);
		xfree(s->env[i].val);
	}
	if (s->env != NULL)
		xfree(s->env);
@


1.162
log
@remove kerberos support from ssh1, since it has been replaced with GSSAPI;
but keep kerberos passwd auth for ssh1 and 2; ok djm, hin, henning, ...
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.161 2003/08/22 10:56:09 markus Exp $");
a391 6
#ifdef GSSAPI
	temporarily_use_uid(s->pw);
	ssh_gssapi_storecreds();
	restore_uid();
#endif

a499 6
#ifdef GSSAPI
	temporarily_use_uid(s->pw);
	ssh_gssapi_storecreds();
	restore_uid();
#endif

d575 8
@


1.161
log
@support GSS API user authentication; patches from Simon Wilkinson,
stripped down and tested by Jakob and myself.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.160 2003/08/13 08:33:02 markus Exp $");
a328 24

#ifdef KRB5
		case SSH_CMSG_HAVE_KERBEROS_TGT:
			if (!options.kerberos_tgt_passing) {
				verbose("Kerberos TGT passing disabled.");
			} else {
				char *kdata = packet_get_string(&dlen);
				packet_check_eom();

				/* XXX - 0x41, used for AFS */
				if (kdata[0] != 0x41) {
					krb5_data tgt;
					tgt.data = kdata;
					tgt.length = dlen;

					if (auth_krb5_tgt(s->authctxt, &tgt))
						success = 1;
					else
						verbose("Kerberos v5 TGT refused for %.100s", s->authctxt->user);
				}
				xfree(kdata);
			}
			break;
#endif
@


1.160
log
@use more portable tcsendbreak(3) and ignore break_length;
ok deraadt, millert
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.159 2003/07/22 13:35:22 markus Exp $");
d61 4
d416 6
d530 6
d722 1
a722 1
static void
d818 7
d1852 4
@


1.159
log
@remove (already disabled) KRB4/AFS support, re-enable -k in ssh(1);
test+ok henning@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.158 2003/06/02 09:17:34 markus Exp $");
d1463 1
a1463 1
	break_length = packet_get_int();
d1466 2
a1467 1
	if (s->ttyfd == -1)
a1468 7
	/* we will sleep from 500ms to 3000ms */
	break_length = MIN(break_length, 3000);
	break_length = MAX(break_length,  500);
	ioctl(s->ttyfd, TIOCSBRK, NULL);
	/* should we care about EINTR? */
	usleep(break_length * 1000);
	ioctl(s->ttyfd, TIOCCBRK, NULL);
@


1.158
log
@deprecate VerifyReverseMapping since it's dangerous if combined
with IP based access control as noted by Mike Harding; replace with
a UseDNS option, UseDNS is on by default and includes the
VerifyReverseMapping check; with itojun@@, provos@@, jakob@@ and deraadt@@
ok deraadt@@, djm@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.157 2003/05/14 22:24:42 markus Exp $");
a213 4
#ifdef KRB4
	if (options.kerberos_ticket_cleanup)
		krb4_cleanup_proc(authctxt);
#endif
d326 1
a326 1
#if defined(AFS) || defined(KRB5)
d334 1
a334 1
				/* XXX - 0x41, see creds_to_radix version */
a335 1
#ifdef KRB5
a343 8
#endif /* KRB5 */
				} else {
#ifdef AFS
					if (auth_krb4_tgt(s->authctxt, kdata))
						success = 1;
					else
						verbose("Kerberos v4 TGT refused for %.100s", s->authctxt->user);
#endif /* AFS */
d348 1
a348 20
#endif /* AFS || KRB5 */

#ifdef AFS
		case SSH_CMSG_HAVE_AFS_TOKEN:
			if (!options.afs_token_passing || !k_hasafs()) {
				verbose("AFS token passing disabled.");
			} else {
				/* Accept AFS token. */
				char *token = packet_get_string(&dlen);
				packet_check_eom();

				if (auth_afs_token(s->authctxt, token))
					success = 1;
				else
					verbose("AFS token refused for %.100s",
					    s->authctxt->user);
				xfree(token);
			}
			break;
#endif /* AFS */
a863 5
#ifdef KRB4
	if (s->authctxt->krb4_ticket_file)
		child_set_env(&env, &envsize, "KRBTKFILE",
		    s->authctxt->krb4_ticket_file);
#endif
a1121 12

#ifdef AFS
	/* Try to get AFS tokens for the local cell. */
	if (k_hasafs()) {
		char cell[64];

		if (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)
			krb_afslog(cell, 0);

		krb_afslog(0, 0);
	}
#endif /* AFS */
@


1.157
log
@allow to send a BREAK to the remote system; ok various
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.156 2003/05/11 20:30:25 markus Exp $");
d665 1
a665 1
		    options.verify_reverse_mapping),
d1118 1
a1118 1
		    options.verify_reverse_mapping);
@


1.156
log
@make channel_new() strdup the 'remote_name' (not the caller); ok theo
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.155 2003/04/08 20:21:29 itojun Exp $");
d1508 20
d1574 2
@


1.155
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.154 2003/03/05 22:33:43 markus Exp $");
d182 1
a182 1
	    0, xstrdup("auth socket"), 1);
@


1.154
log
@fix memory leaks; from dlheine@@suif.Stanford.EDU/CLOUSEAU; ok djm@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.153 2003/02/06 09:26:23 markus Exp $");
d401 1
a401 1
			log("Unknown packet type received after authentication: %d", type);
d1012 1
a1012 1
		log("User %.100s not allowed because %s exists",
d1441 1
a1441 1
	log("subsystem request for %.100s", subsys);
d1460 1
a1460 1
		log("subsystem request for %.100s failed, subsystem not found",
d1531 1
a1531 1
		log("session_input_channel_req: no session %d req %.100s",
@


1.154.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.163 2003/08/31 13:29:05 markus Exp $");
a60 4
#ifdef GSSAPI
#include "ssh-gss.h"
#endif

d182 1
a182 1
	    0, "auth socket", 1);
d214 4
d330 52
d401 1
a401 1
			logit("Unknown packet type received after authentication: %d", type);
a627 8
#ifdef GSSAPI
	if (options.gss_authentication) {
		temporarily_use_uid(s->pw);
		ssh_gssapi_storecreds();
		restore_uid();
	}
#endif

d665 1
a665 1
		    options.use_dns),
d738 1
a738 1
void
a833 7
#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter 
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

d896 5
d1012 1
a1012 1
		logit("User %.100s not allowed because %s exists",
d1118 1
a1118 1
		    options.use_dns);
d1160 12
d1441 1
a1441 1
	logit("subsystem request for %.100s", subsys);
d1460 1
a1460 1
		logit("subsystem request for %.100s failed, subsystem not found",
a1507 14
session_break_req(Session *s)
{
	u_int break_length;

	break_length = packet_get_int();	/* ignored */
	packet_check_eom();

	if (s->ttyfd == -1 ||
	    tcsendbreak(s->ttyfd, 0) < 0)
		return 0;
	return 1;
}

static int
d1531 1
a1531 1
		logit("session_input_channel_req: no session %d req %.100s",
a1553 2
		} else if (strcmp(rtype, "break") == 0) {
			success = session_break_req(s);
a1861 4
#if defined(GSSAPI)
	if (options.gss_cleanup_creds)
		ssh_gssapi_cleanup_creds(NULL);
#endif
@


1.154.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.172 2004/01/30 09:48:57 markus Exp $");
a60 4
#ifdef KRB5
#include <kafs.h>
#endif

d69 1
a69 1
void	session_pty_cleanup(Session *);
a104 2
static int is_child = 0;

d112 1
a112 1
auth_sock_cleanup_proc(struct passwd *pw)
d114 2
d143 1
a143 1
	strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
d159 3
d179 1
a179 1
	if (listen(sock, SSH_LISTEN_BACKLOG) < 0)
d215 7
a221 1
	do_cleanup(authctxt);
d394 1
a394 1
		is_child = 1;
d502 1
a502 1
		is_child = 1;
d613 1
a613 1
			cleanup_exit(255);
d698 1
a699 2
	u_int envsize;
	u_int i, namelen;
d716 6
a721 7
		envsize = *envsizep;
		if (i >= envsize - 1) {
			if (envsize >= 1000)
				fatal("child_set_env: too many env vars");
			envsize += 50;
			env = (*envp) = xrealloc(env, envsize * sizeof(char *));
			*envsizep = envsize;
d791 1
a791 1
	/* Allow any GSSAPI methods that we've used to alter
d931 1
a931 1
			    options.xauth_location, s->auth_display);
a1012 16
do_pwchange(Session *s)
{
	fprintf(stderr, "WARNING: Your password has expired.\n");
	if (s->ttyfd != -1) {
	    	fprintf(stderr,
		    "You must change your password now and login again!\n");
		execl(_PATH_PASSWD_PROG, "passwd", (char *)NULL);
		perror("passwd");
	} else {
		fprintf(stderr,
		    "Password change required but no TTY available.\n");
	}
	exit(1);
}

static void
a1025 34
static void
child_close_fds(void)
{
	int i;

	if (packet_get_connection_in() == packet_get_connection_out())
		close(packet_get_connection_in());
	else {
		close(packet_get_connection_in());
		close(packet_get_connection_out());
	}
	/*
	 * Close all descriptors related to channels.  They will still remain
	 * open in the parent.
	 */
	/* XXX better use close-on-exec? -markus */
	channel_close_all();

	/*
	 * Close any extra file descriptors.  Note that there may still be
	 * descriptors left by system functions.  They will be closed later.
	 */
	endpwent();

	/*
	 * Close any extra open file descriptors so that we don\'t have them
	 * hanging around in clients.  Note that we want to do this after
	 * initgroups, because at least on Solaris 2.3 it leaves file
	 * descriptors open.
	 */
	for (i = 3; i < 64; i++)
		close(i);
}

d1039 1
a1043 8
	/* Force a password change */
	if (s->authctxt->force_pwchange) {
		do_setusercontext(pw);
		child_close_fds();
		do_pwchange(s);
		exit(1);
	}

d1084 12
a1095 1
	child_close_fds();
d1098 2
a1099 2
	 * Must take new environment into use so that .ssh/rc,
	 * /etc/ssh/sshrc and xauth are run in the proper environment.
d1101 1
a1101 1
	environ = env;
a1102 1
#ifdef KRB5
d1104 4
a1107 5
	 * At this point, we check to see if AFS is active and if we have
	 * a valid Kerberos 5 TGT. If so, it seems like a good idea to see
	 * if we can (and need to) extend the ticket into an AFS token. If
	 * we don't do this, we run into potential problems if the user's
	 * home directory is in AFS and it's not world-readable.
d1109 2
d1112 5
a1116 16
	if (options.kerberos_get_afs_token && k_hasafs() &&
	     (s->authctxt->krb5_ctx != NULL)) {
		char cell[64];

		debug("Getting AFS token");

		k_setpag();

		if (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)
			krb5_afslog(s->authctxt->krb5_ctx,
			    s->authctxt->krb5_fwd_ccache, cell, NULL);

		krb5_afslog_home(s->authctxt->krb5_ctx,
		    s->authctxt->krb5_fwd_ccache, NULL, NULL, pw->pw_dir);
	}
#endif
d1239 1
a1239 1
	if (s->pw == NULL || !authctxt->valid)
d1361 5
d1547 1
a1547 1
session_pty_cleanup2(Session *s)
d1549 2
d1581 1
a1581 1
session_pty_cleanup(Session *s)
d1583 1
a1583 1
	PRIVSEP(session_pty_cleanup2(s));
d1652 2
a1653 1
	if (s->ttyfd != -1)
d1655 1
d1704 2
a1705 1
		if (s->ttyfd != -1)
d1707 1
d1824 3
a1826 24
}

void
do_cleanup(Authctxt *authctxt)
{
	static int called = 0;

	debug("do_cleanup");

	/* no cleanup if we're in the child for login shell */
	if (is_child)
		return;

	/* avoid double cleanup */
	if (called)
		return;
	called = 1;

	if (authctxt == NULL)
		return;
#ifdef KRB5
	if (options.kerberos_ticket_cleanup &&
	    authctxt->krb5_ctx)
		krb5_cleanup_proc(authctxt);
a1827 15

#ifdef GSSAPI
	if (compat20 && options.gss_cleanup_creds)
		ssh_gssapi_cleanup_creds();
#endif

	/* remove agent socket */
	auth_sock_cleanup_proc(authctxt->pw);

	/*
	 * Cleanup ptys/utmp only if privsep is disabled,
	 * or if running in monitor.
	 */
	if (!use_privsep || mm_is_monitor())
		session_destroy_all(session_pty_cleanup2);
@


1.153
log
@missing call to setproctitle() after authentication; ok provos@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.152 2002/12/10 08:56:00 markus Exp $");
d826 1
a826 1
	char **env;
d881 1
d883 2
a884 2
	    get_remote_ipaddr(), get_remote_port(),
	    get_local_ipaddr(packet_get_connection_in()), get_local_port());
@


1.152
log
@Make sure $SHELL points to the shell from the password file, even if shell
is overridden from login.conf; bug#453; semen at online.sinor.ru; ok millert@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.151 2002/12/04 04:36:47 stevesk Exp $");
d191 2
@


1.151
log
@remove xauth entries before add; PR 2994 from janjaap@@stack.nl.
ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.150 2002/09/16 19:55:33 stevesk Exp $");
d1101 7
a1110 2

	env = do_setup_env(s, shell);
@


1.150
log
@log when _PATH_NOLOGIN exists; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.149 2002/09/12 19:50:36 stevesk Exp $");
d969 4
a972 2
			    "Running %.500s add "
			    "%.100s %.100s %.100s\n",
d980 2
@


1.150.2.1
log
@Update to OpenSSH 3.6
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.154 2003/03/05 22:33:43 markus Exp $");
a190 2
	setproctitle("%s", authctxt->pw->pw_name);

d824 1
a824 1
	char **env, *laddr;
a878 1
	laddr = get_local_ipaddr(packet_get_connection_in());
d880 2
a881 2
	    get_remote_ipaddr(), get_remote_port(), laddr, get_local_port());
	xfree(laddr);
d969 2
a970 4
			    "Running %.500s remove %.100s\n",
  			    options.xauth_location, s->auth_display);
			fprintf(stderr,
			    "%.500s add %.100s %.100s %.100s\n",
a977 2
			fprintf(f, "remove %s\n",
			    s->auth_display);
a1096 7

	/*
	 * Make sure $SHELL points to the shell from the password file,
	 * even if shell is overridden from login.conf
	 */
	env = do_setup_env(s, shell);

d1100 2
@


1.150.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.163 2003/08/31 13:29:05 markus Exp $");
a60 4
#ifdef GSSAPI
#include "ssh-gss.h"
#endif

d182 1
a182 1
	    0, "auth socket", 1);
d214 4
d330 52
d401 1
a401 1
			logit("Unknown packet type received after authentication: %d", type);
a627 8
#ifdef GSSAPI
	if (options.gss_authentication) {
		temporarily_use_uid(s->pw);
		ssh_gssapi_storecreds();
		restore_uid();
	}
#endif

d665 1
a665 1
		    options.use_dns),
d738 1
a738 1
void
a833 7
#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter 
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

d896 5
d1012 1
a1012 1
		logit("User %.100s not allowed because %s exists",
d1118 1
a1118 1
		    options.use_dns);
d1160 12
d1441 1
a1441 1
	logit("subsystem request for %.100s", subsys);
d1460 1
a1460 1
		logit("subsystem request for %.100s failed, subsystem not found",
a1507 14
session_break_req(Session *s)
{
	u_int break_length;

	break_length = packet_get_int();	/* ignored */
	packet_check_eom();

	if (s->ttyfd == -1 ||
	    tcsendbreak(s->ttyfd, 0) < 0)
		return 0;
	return 1;
}

static int
d1531 1
a1531 1
		logit("session_input_channel_req: no session %d req %.100s",
a1553 2
		} else if (strcmp(rtype, "break") == 0) {
			success = session_break_req(s);
a1861 4
#if defined(GSSAPI)
	if (options.gss_cleanup_creds)
		ssh_gssapi_cleanup_creds(NULL);
#endif
@


1.149
log
@add SSH_CONNECTION and deprecate SSH_CLIENT; bug #384.  ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.148 2002/08/29 15:57:25 stevesk Exp $");
d1005 2
@


1.148
log
@pass addrlen with sockaddr *; from Hajimu UMEMOTO <ume@@FreeBSD.org>
NOTE: there are also p-specific parts to this patch. ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.147 2002/08/22 21:45:41 markus Exp $");
d874 1
d878 5
@


1.147
log
@send signal name (not signal number) in "exit-signal" message; noticed
by galb@@vandyke.com
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.146 2002/07/30 17:03:55 markus Exp $");
d650 1
a651 1
		fromlen = sizeof(from);
d664 1
a664 1
		    (struct sockaddr *)&from);
@


1.146
log
@add PermitUserEnvironment (off by default!); from dot@@dotat.at; ok provos, deraadt
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.145 2002/07/22 11:03:06 markus Exp $");
d1604 21
d1642 1
a1642 1
		packet_put_int(WTERMSIG(status));
@


1.145
log
@fallback to _PATH_STDPATH on setusercontext+LOGIN_SETPATH errors;
suggeted by millert@@; ok deraadt@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.144 2002/07/19 15:43:33 markus Exp $");
d902 1
a902 1
	if (!options.use_login) {
@


1.144
log
@remove fatal cleanups after fork; based on discussions with and code
from solar.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.143 2002/06/30 21:54:16 deraadt Exp $");
d838 4
a841 2
		(void) setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH);
		child_set_env(&env, &envsize, "PATH", getenv("PATH"));
@


1.143
log
@lint asks that we use names that do not overlap
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.142 2002/06/26 13:49:26 deraadt Exp $");
d444 2
d552 1
@


1.142
log
@disclose less information from environment files; based on input from djm, and dschultz@@uclink.Berkeley.EDU
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.141 2002/06/26 08:58:26 markus Exp $");
d855 1
a855 1
			char *s = ce->s;
d857 1
a857 1
			for (i = 0; s[i] != '=' && s[i]; i++)
d859 3
a861 3
			if (s[i] == '=') {
				s[i] = 0;
				child_set_env(&env, &envsize, s, s + i + 1);
@


1.141
log
@limit # of env vars to 1000; ok deraadt/djm
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.140 2002/06/23 21:06:41 deraadt Exp $");
d784 1
d791 2
d801 2
a802 1
			fprintf(stderr, "Bad line in %.100s: %.200s\n", filename, buf);
@


1.140
log
@display, screen, row, col, xpixel, ypixel are u_int; markus ok
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.139 2002/06/23 20:39:45 deraadt Exp $");
d756 3
@


1.139
log
@compression_level is u_int
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.138 2002/06/20 23:05:55 markus Exp $");
d1773 3
a1775 3
	s->display_number = x11_create_display_inet(options.x11_display_offset,
	    options.x11_use_localhost, s->single_connection);
	if (s->display_number == -1) {
d1789 1
a1789 1
		snprintf(display, sizeof display, "localhost:%d.%d",
d1791 1
a1791 1
		snprintf(auth_display, sizeof auth_display, "unix:%d.%d",
d1796 1
a1796 1
		snprintf(display, sizeof display, "%.400s:%d.%d", hostname,
@


1.138
log
@allow Compression=yes/no in sshd_config
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.137 2002/06/11 05:46:20 mpech Exp $");
d234 2
a235 2
	int compression_level = 0, enable_compression_after_reply = 0;
	u_int proto_len, data_len, dlen;
@


1.137
log
@pid_t cleanup. Markus need this now to keep hacking.
markus@@, millert@@ ok

Note: big usr.bin/ cleanup is comming. Now I'm waiting Ok from espie@@ for
make/.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.136 2002/06/10 22:28:41 markus Exp $");
d259 4
@


1.136
log
@move creation of agent socket to session.c; no need for uidswapping
in channel.c.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.135 2002/05/16 22:09:59 stevesk Exp $");
d152 2
a153 2
	snprintf(auth_sock_name, MAXPATHLEN, "%s/agent.%d",
		 auth_sock_dir, (int) getpid());
d417 1
a417 1
	int pid;
d1237 1
a1237 1
		debug("dump: used %d session %d %p channel %d pid %d",
d1242 1
a1242 1
		    s->pid);
d1300 1
a1300 1
	debug("session_by_pid: pid %d", pid);
d1306 1
a1306 1
	error("session_by_pid: unknown pid %d", pid);
d1596 2
a1597 2
	debug("session_exit_message: session %d channel %d pid %d",
	    s->self, s->chanid, s->pid);
d1632 1
a1632 1
	debug("session_close: session %d pid %d", s->self, s->pid);
d1656 2
a1657 1
		debug("session_close_by_pid: no session for pid %d", pid);
d1677 2
a1678 1
	debug("session_close_by_channel: channel %d child %d", id, s->pid);
@


1.135
log
@don't limit xauth pathlen on client side and longer print length on
server when debug; ok markus@@
patch from pin@@math.chalmers.se
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.134 2002/03/29 18:59:31 markus Exp $");
d101 87
d210 1
a210 1
	if (auth_get_socket_name())
d881 1
a881 1
	if (auth_get_socket_name() != NULL)
d883 1
a883 1
		    auth_get_socket_name());
@


1.134
log
@retrieve last login time before the pty is allocated, store per session
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.133 2002/03/28 15:34:51 markus Exp $");
d860 1
a860 1
			    "Running %.100s add "
@


1.134.2.1
log
@Pull in OpenSSH-3.4
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.142 2002/06/26 13:49:26 deraadt Exp $");
a100 87
/* Name and directory of socket for authentication agent forwarding. */
static char *auth_sock_name = NULL;
static char *auth_sock_dir = NULL;

/* removes the agent forwarding socket */

static void
auth_sock_cleanup_proc(void *_pw)
{
	struct passwd *pw = _pw;

	if (auth_sock_name != NULL) {
		temporarily_use_uid(pw);
		unlink(auth_sock_name);
		rmdir(auth_sock_dir);
		auth_sock_name = NULL;
		restore_uid();
	}
}

static int
auth_input_request_forwarding(struct passwd * pw)
{
	Channel *nc;
	int sock;
	struct sockaddr_un sunaddr;

	if (auth_sock_name != NULL) {
		error("authentication forwarding requested twice.");
		return 0;
	}

	/* Temporarily drop privileged uid for mkdir/bind. */
	temporarily_use_uid(pw);

	/* Allocate a buffer for the socket name, and format the name. */
	auth_sock_name = xmalloc(MAXPATHLEN);
	auth_sock_dir = xmalloc(MAXPATHLEN);
	strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXX", MAXPATHLEN);

	/* Create private directory for socket */
	if (mkdtemp(auth_sock_dir) == NULL) {
		packet_send_debug("Agent forwarding disabled: "
		    "mkdtemp() failed: %.100s", strerror(errno));
		restore_uid();
		xfree(auth_sock_name);
		xfree(auth_sock_dir);
		auth_sock_name = NULL;
		auth_sock_dir = NULL;
		return 0;
	}
	snprintf(auth_sock_name, MAXPATHLEN, "%s/agent.%ld",
		 auth_sock_dir, (long) getpid());

	/* delete agent socket on fatal() */
	fatal_add_cleanup(auth_sock_cleanup_proc, pw);

	/* Create the socket. */
	sock = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sock < 0)
		packet_disconnect("socket: %.100s", strerror(errno));

	/* Bind it to the name. */
	memset(&sunaddr, 0, sizeof(sunaddr));
	sunaddr.sun_family = AF_UNIX;
	strlcpy(sunaddr.sun_path, auth_sock_name, sizeof(sunaddr.sun_path));

	if (bind(sock, (struct sockaddr *) & sunaddr, sizeof(sunaddr)) < 0)
		packet_disconnect("bind: %.100s", strerror(errno));

	/* Restore the privileged uid. */
	restore_uid();

	/* Start listening on the socket. */
	if (listen(sock, 5) < 0)
		packet_disconnect("listen: %.100s", strerror(errno));

	/* Allocate a channel for the authentication agent socket. */
	nc = channel_new("auth socket",
	    SSH_CHANNEL_AUTH_SOCKET, sock, sock, -1,
	    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,
	    0, xstrdup("auth socket"), 1);
	strlcpy(nc->path, auth_sock_name, sizeof(nc->path));
	return 1;
}


d123 1
a123 1
	if (auth_sock_name != NULL)
d147 2
a148 2
	int enable_compression_after_reply = 0;
	u_int proto_len, data_len, dlen, compression_level = 0;
a173 4
			if (!options.compression) {
				debug2("compression disabled");
				break;
			}
d330 1
a330 1
	pid_t pid;
a664 3
			if (*envsizep >= 1000)
				fatal("child_set_env: too many env vars,"
				    " skipping: %.100s", name);
a689 1
	u_int lineno = 0;
a695 2
		if (++lineno > 1000)
			fatal("Too many lines in environment file %s", filename);
d704 1
a704 2
			fprintf(stderr, "Bad line %u in %.100s\n", lineno,
			    filename);
d794 1
a794 1
	if (auth_sock_name != NULL)
d796 1
a796 1
		    auth_sock_name);
d860 1
a860 1
			    "Running %.500s add "
d1150 1
a1150 1
		debug("dump: used %d session %d %p channel %d pid %ld",
d1155 1
a1155 1
		    (long)s->pid);
d1213 1
a1213 1
	debug("session_by_pid: pid %ld", (long)pid);
d1219 1
a1219 1
	error("session_by_pid: unknown pid %ld", (long)pid);
d1509 2
a1510 2
	debug("session_exit_message: session %d channel %d pid %ld",
	    s->self, s->chanid, (long)s->pid);
d1545 1
a1545 1
	debug("session_close: session %d pid %ld", s->self, (long)s->pid);
d1569 1
a1569 2
		debug("session_close_by_pid: no session for pid %ld",
		    (long)pid);
d1589 1
a1589 2
	debug("session_close_by_channel: channel %d child %ld",
	    id, (long)s->pid);
d1680 3
a1682 3
	if (x11_create_display_inet(options.x11_display_offset,
	    options.x11_use_localhost, s->single_connection,
	    &s->display_number) == -1) {
d1696 1
a1696 1
		snprintf(display, sizeof display, "localhost:%u.%u",
d1698 1
a1698 1
		snprintf(auth_display, sizeof auth_display, "unix:%u.%u",
d1703 1
a1703 1
		snprintf(display, sizeof display, "%.400s:%u.%u", hostname,
@


1.134.2.2
log
@Update to OpenSSH 3.5
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.150 2002/09/16 19:55:33 stevesk Exp $");
a443 2
		fatal_remove_all_cleanups();

a549 1
		fatal_remove_all_cleanups();
a646 1
	fromlen = sizeof(from);
d648 1
d661 1
a661 1
		    (struct sockaddr *)&from, fromlen);
d835 2
a836 4
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, "PATH", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, "PATH", getenv("PATH"));
d855 1
a855 1
			char *str = ce->s;
d857 1
a857 1
			for (i = 0; str[i] != '=' && str[i]; i++)
d859 3
a861 3
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
a868 1
	/* SSH_CLIENT deprecated */
a872 5
	snprintf(buf, sizeof buf, "%.50s %d %.50s %d",
	    get_remote_ipaddr(), get_remote_port(),
	    get_local_ipaddr(packet_get_connection_in()), get_local_port());
	child_set_env(&env, &envsize, "SSH_CONNECTION", buf);

d897 1
a897 1
	if (options.permit_user_env && !options.use_login) {
a993 2
		log("User %.100s not allowed because %s exists",
		    pw->pw_name, _PATH_NOLOGIN);
a1598 21
static char *
sig2name(int sig)
{
#define SSH_SIG(x) if (sig == SIG ## x) return #x
	SSH_SIG(ABRT);
	SSH_SIG(ALRM);
	SSH_SIG(FPE);
	SSH_SIG(HUP);
	SSH_SIG(ILL);
	SSH_SIG(INT);
	SSH_SIG(KILL);
	SSH_SIG(PIPE);
	SSH_SIG(QUIT);
	SSH_SIG(SEGV);
	SSH_SIG(TERM);
	SSH_SIG(USR1);
	SSH_SIG(USR2);
#undef	SSH_SIG
	return "SIG@@openssh.com";
}

d1616 1
a1616 1
		packet_put_cstring(sig2name(WTERMSIG(status)));
@


1.134.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.154 2003/03/05 22:33:43 markus Exp $");
a190 2
	setproctitle("%s", authctxt->pw->pw_name);

d824 1
a824 1
	char **env, *laddr;
a878 1
	laddr = get_local_ipaddr(packet_get_connection_in());
d880 2
a881 2
	    get_remote_ipaddr(), get_remote_port(), laddr, get_local_port());
	xfree(laddr);
d969 2
a970 4
			    "Running %.500s remove %.100s\n",
  			    options.xauth_location, s->auth_display);
			fprintf(stderr,
			    "%.500s add %.100s %.100s %.100s\n",
a977 2
			fprintf(f, "remove %s\n",
			    s->auth_display);
a1096 7

	/*
	 * Make sure $SHELL points to the shell from the password file,
	 * even if shell is overridden from login.conf
	 */
	env = do_setup_env(s, shell);

d1100 2
@


1.133
log
@do not call record_login twice (for use_privsep)
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.132 2002/03/19 10:49:35 markus Exp $");
a545 1
	char hostname[MAXHOSTNAMELEN];
a547 1
	time_t last_login_time;
a564 7
	/* Get the time and hostname when the user last logged in. */
	if (options.print_lastlog) {
		hostname[0] = '\0';
		last_login_time = get_last_login_time(pw->pw_uid, pw->pw_name,
		    hostname, sizeof(hostname));
	}

d575 2
a576 2
	if (options.print_lastlog && last_login_time != 0) {
		time_string = ctime(&last_login_time);
d579 1
a579 1
		if (strcmp(hostname, "") == 0)
d582 2
a583 1
			printf("Last login: %s from %s\r\n", time_string, hostname);
d1249 6
@


1.132
log
@KNF whitespace
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.131 2002/03/19 10:35:39 markus Exp $");
d575 5
a579 3
	record_login(pid, s->tty, pw->pw_name, pw->pw_uid,
	    get_remote_name_or_ip(utmp_len, options.verify_reverse_mapping),
	    (struct sockaddr *)&from);
@


1.131
log
@clean up prototypes
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.130 2002/03/18 17:50:31 provos Exp $");
d1247 1
a1247 1
	
@


1.130
log
@integrate privilege separated openssh; its turned off by default for now.
work done by me and markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.128 2002/02/16 00:51:44 markus Exp $");
d942 1
a942 1
void
@


1.129
log
@move auth_approval into getpwnamallow with help from millert@@
@
text
@d59 1
a59 28

/* types */

#define TTYSZ 64
typedef struct Session Session;
struct Session {
	int	used;
	int	self;
	struct passwd *pw;
	Authctxt *authctxt;
	pid_t	pid;
	/* tty */
	char	*term;
	int	ptyfd, ttyfd, ptymaster;
	int	row, col, xpixel, ypixel;
	char	tty[TTYSZ];
	/* X11 */
	int	display_number;
	char	*display;
	int	screen;
	char	*auth_display;
	char	*auth_proto;
	char	*auth_data;
	int	single_connection;
	/* proto 2 */
	int	chanid;
	int	is_subsystem;
};
d65 1
a65 1
static void	session_pty_cleanup(void *);
a78 1
static void session_close(Session *);
d910 1
a910 1
static void
d942 14
d1072 2
a1073 9
		/* Launch login(1). */

		execl("/usr/bin/login", "login", "-h", hostname,
		    "-p", "-f", "--", pw->pw_name, (char *)NULL);

		/* Login couldn't be executed, die. */

		perror("login");
		exit(1);
d1183 16
d1247 1
a1247 1

d1276 1
a1276 1
	if (!pty_allocate(&s->ptyfd, &s->ttyfd, s->tty, sizeof(s->tty))) {
d1297 2
a1298 1
	pty_setowner(s->pw, s->tty);
d1461 2
a1462 2
static void
session_pty_cleanup(void *session)
d1480 2
a1481 1
	pty_release(s->tty);
d1489 1
a1489 1
		error("close(s->ptymaster): %s", strerror(errno));
d1495 6
d1542 1
a1542 1
static void
d1609 1
a1609 1
session_destroy_all(void)
d1614 6
a1619 2
		if (s->used)
			session_close(s);
@


1.128
log
@typo
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.127 2002/02/15 23:11:26 markus Exp $");
d126 1
a126 1
static login_cap_t *lc;
a140 12
#ifdef HAVE_LOGIN_CAP
	if ((lc = login_getclass(authctxt->pw->pw_class)) == NULL) {
		error("unable to get login class");
		return;
	}
#ifdef BSD_AUTH
	if (auth_approval(NULL, lc, authctxt->pw->pw_name, "ssh") <= 0) {
		packet_disconnect("Approval failure for %s",
		    authctxt->pw->pw_name);
	}
#endif
#endif
@


1.127
log
@split do_child(), ok mouring@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.126 2002/02/14 23:28:00 markus Exp $");
d1127 1
a1127 1
		    <= sizeof(argv0) - 1) {
@


1.126
log
@increase the SSH v2 window size to 4 packets. comsumes a little
bit more memory for slow receivers but increases througput.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.125 2002/02/09 17:37:34 deraadt Exp $");
d764 2
a765 7
/*
 * Performs common processing for the child, such as setting up the
 * environment, closing extra file descriptors, setting the user and group
 * ids, and executing the command or shell.
 */
void
do_child(Session *s, const char *command)
a766 2
	const char *shell, *hostname = NULL, *cp = NULL;
	struct passwd *pw = s->pw;
d768 1
a768 3
	char cmd[1024];
	FILE *f = NULL;
	u_int envsize, i;
d770 1
a770 72
	extern char **environ;
	struct stat st;
	char *argv[10];
	int do_xauth;

	do_xauth =
	    s->display != NULL && s->auth_proto != NULL && s->auth_data != NULL;

	/* remove hostkey from the child's memory */
	destroy_sensitive_data();

	/* login(1) is only called if we execute the login shell */
	if (options.use_login && command != NULL)
		options.use_login = 0;

	if (!options.use_login) {
#ifdef HAVE_LOGIN_CAP
		if (!login_getcapbool(lc, "ignorenologin", 0) && pw->pw_uid)
			f = fopen(login_getcapstr(lc, "nologin", _PATH_NOLOGIN,
			    _PATH_NOLOGIN), "r");
#else
		if (pw->pw_uid)
			f = fopen(_PATH_NOLOGIN, "r");
#endif
		if (f) {
			/* /etc/nologin exists.  Print its contents and exit. */
			while (fgets(buf, sizeof(buf), f))
				fputs(buf, stderr);
			fclose(f);
			exit(254);
		}
	}
	/* Set login name, uid, gid, and groups. */
	/* Login(1) does this as well, and it needs uid 0 for the "-h"
	   switch, so we let login(1) to this for us. */
	if (!options.use_login) {
		if (getuid() == 0 || geteuid() == 0) {
#ifdef HAVE_LOGIN_CAP
			if (setusercontext(lc, pw, pw->pw_uid,
			    (LOGIN_SETALL & ~LOGIN_SETPATH)) < 0) {
				perror("unable to set user context");
				exit(1);
			}
#else
			if (setlogin(pw->pw_name) < 0)
				error("setlogin failed: %s", strerror(errno));
			if (setgid(pw->pw_gid) < 0) {
				perror("setgid");
				exit(1);
			}
			/* Initialize the group list. */
			if (initgroups(pw->pw_name, pw->pw_gid) < 0) {
				perror("initgroups");
				exit(1);
			}
			endgrent();

			/* Permanently switch to the desired uid. */
			permanently_set_uid(pw);
#endif
		}
		if (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)
			fatal("Failed to set uids to %u.", (u_int) pw->pw_uid);
	}
	/*
	 * Get the shell from the password data.  An empty shell field is
	 * legal, and means /bin/sh.
	 */
	shell = (pw->pw_shell[0] == '\0') ? _PATH_BSHELL : pw->pw_shell;
#ifdef HAVE_LOGIN_CAP
	shell = login_getcapstr(lc, "shell", (char *)shell, (char *)shell);
#endif
d804 1
a804 1
			int i;
d818 1
a818 1
		 get_remote_ipaddr(), get_remote_port(), get_local_port());
d856 168
d1091 2
a1092 62
	/*
	 * Run $HOME/.ssh/rc, /etc/ssh/sshrc, or xauth (whichever is found
	 * first in this order).
	 */
	if (!options.use_login) {
		/* ignore _PATH_SSH_USER_RC for subsystems */
		if (!s->is_subsystem && (stat(_PATH_SSH_USER_RC, &st) >= 0)) {
			snprintf(cmd, sizeof cmd, "%s -c '%s %s'",
			    shell, _PATH_BSHELL, _PATH_SSH_USER_RC);
			if (debug_flag)
				fprintf(stderr, "Running %s\n", cmd);
			f = popen(cmd, "w");
			if (f) {
				if (do_xauth)
					fprintf(f, "%s %s\n", s->auth_proto,
					    s->auth_data);
				pclose(f);
			} else
				fprintf(stderr, "Could not run %s\n",
				    _PATH_SSH_USER_RC);
		} else if (stat(_PATH_SSH_SYSTEM_RC, &st) >= 0) {
			if (debug_flag)
				fprintf(stderr, "Running %s %s\n", _PATH_BSHELL,
				    _PATH_SSH_SYSTEM_RC);
			f = popen(_PATH_BSHELL " " _PATH_SSH_SYSTEM_RC, "w");
			if (f) {
				if (do_xauth)
					fprintf(f, "%s %s\n", s->auth_proto,
					    s->auth_data);
				pclose(f);
			} else
				fprintf(stderr, "Could not run %s\n",
				    _PATH_SSH_SYSTEM_RC);
		} else if (do_xauth && options.xauth_location != NULL) {
			/* Add authority data to .Xauthority if appropriate. */
			if (debug_flag) {
				fprintf(stderr,
				    "Running %.100s add "
				    "%.100s %.100s %.100s\n",
				    options.xauth_location, s->auth_display,
				    s->auth_proto, s->auth_data);
			}
			snprintf(cmd, sizeof cmd, "%s -q -",
			    options.xauth_location);
			f = popen(cmd, "w");
			if (f) {
				fprintf(f, "add %s %s %s\n",
				    s->auth_display, s->auth_proto,
				    s->auth_data);
				pclose(f);
			} else {
				fprintf(stderr, "Could not run %s\n",
				    cmd);
			}
		}
		/* Get the last component of the shell name. */
		cp = strrchr(shell, '/');
		if (cp)
			cp++;
		else
			cp = shell;
	}
d1097 18
d1121 1
a1121 2
		if (!options.use_login) {
			char buf[256];
d1123 2
a1124 8
			/* Start the shell.  Set initial character to '-'. */
			buf[0] = '-';
			strlcpy(buf + 1, cp, sizeof(buf) - 1);

			/* Execute the shell. */
			argv[0] = buf;
			argv[1] = NULL;
			execve(shell, argv, env);
d1126 3
a1128 1
			/* Executing the shell failed. */
d1131 1
d1133 8
a1140 11
		} else {
			/* Launch login(1). */

			execl("/usr/bin/login", "login", "-h", hostname,
			    "-p", "-f", "--", pw->pw_name, (char *)NULL);

			/* Login couldn't be executed, die. */

			perror("login");
			exit(1);
		}
d1146 1
a1146 1
	argv[0] = (char *) cp;
@


1.125
log
@move ssh config files to /etc/ssh
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.124 2002/02/06 14:37:22 markus Exp $");
d1430 2
a1431 1
	    1);
@


1.124
log
@minor KNF
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.123 2002/02/03 17:53:25 markus Exp $");
d976 2
a977 2
	 * Must take new environment into use so that .ssh/rc, /etc/sshrc and
	 * xauth are run in the proper environment.
d1004 2
a1005 2
	 * Run $HOME/.ssh/rc, /etc/sshrc, or xauth (whichever is found first
	 * in this order).
@


1.123
log
@don't use channel_input_channel_request and callback
use new server_input_channel_req() instead:
	server_input_channel_req does generic request parsing on server side
	session_input_channel_req handles just session specific things now
ok djm@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.122 2002/01/29 22:46:41 markus Exp $");
d1474 2
a1475 4
	if (s == NULL)
		fatal("session_close: no session");
	c = channel_lookup(s->chanid);
	if (c == NULL)
d1482 1
a1482 2
		channel_request_start(s->chanid,
		    "exit-status", 0);
d1486 1
a1486 2
		channel_request_start(s->chanid,
		    "exit-signal", 0);
@


1.122
log
@don't depend on servconf.c; ok djm@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.121 2002/01/29 16:29:02 stevesk Exp $");
d1378 2
a1379 2
void
session_input_channel_req(int id, void *arg)
a1380 2
	u_int len;
	int reply;
a1381 1
	char *rtype;
a1382 1
	Channel *c;
d1384 6
a1389 12
	rtype = packet_get_string(&len);
	reply = packet_get_char();

	s = session_by_channel(id);
	if (s == NULL)
		fatal("session_input_channel_req: channel %d: no session", id);
	c = channel_lookup(id);
	if (c == NULL)
		fatal("session_input_channel_req: channel %d: bad channel", id);

	debug("session_input_channel_req: session %d channel %d request %s reply %d",
	    s->self, id, rtype, reply);
d1413 1
a1413 8

	if (reply) {
		packet_start(success ?
		    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);
		packet_put_int(c->remote_id);
		packet_send();
	}
	xfree(rtype);
@


1.121
log
@limit subsystem length in log; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.120 2002/01/29 14:32:03 markus Exp $");
d1309 1
@


1.120
log
@s/ReverseMappingCheck/VerifyReverseMapping/ and avoid confusion; ok stevesk@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.119 2002/01/27 14:57:46 stevesk Exp $");
d1295 1
a1295 1
	log("subsystem request for %s", subsys);
d1313 1
a1313 1
		log("subsystem request for %s failed, subsystem not found",
@


1.119
log
@add X11UseLocalhost; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.118 2002/01/26 16:44:22 stevesk Exp $");
d616 1
a616 1
	    get_remote_name_or_ip(utmp_len, options.reverse_mapping_check),
d939 1
a939 1
		    options.reverse_mapping_check);
@


1.118
log
@revert code to add x11 localhost display authorization entry for
hostname/unix:d and uts.nodename/unix:d if nodename was different than
hostname.  just add entry for unix:d instead.  ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.117 2001/12/28 14:50:54 markus Exp $");
d1666 1
a1666 1
	    options.gateway_ports, s->single_connection);
d1680 1
a1680 1
	if (!options.gateway_ports) {
@


1.117
log
@packet_read* no longer return the packet length, since it's not used.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.116 2001/12/28 12:14:27 markus Exp $");
d79 1
a79 1
	char	*auth_display[2];
d1042 1
a1042 1
				    options.xauth_location, s->auth_display[0],
a1043 5
				if (s->auth_display[1])
					fprintf(stderr,
					    "add %.100s %.100s %.100s\n",
					    s->auth_display[1],
					    s->auth_proto, s->auth_data);
d1050 1
a1050 1
				    s->auth_display[0], s->auth_proto,
a1051 4
				if (s->auth_display[1])
					fprintf(f, "add %s %s %s\n",
					    s->auth_display[1], s->auth_proto,
					    s->auth_data);
d1543 2
a1544 4
	if (s->auth_display[0])
		xfree(s->auth_display[0]);
	if (s->auth_display[1])
		xfree(s->auth_display[1]);
a1679 1
	s->auth_display[1] = NULL;
a1680 2
		struct utsname uts;

d1683 2
a1684 2
		snprintf(auth_display, sizeof auth_display, "%.400s/unix:%d.%d",
		    hostname, s->display_number, s->screen);
d1686 1
a1686 16
		s->auth_display[0] = xstrdup(auth_display);
		/*
		 * Xlib may use gethostbyname() or uname() hostname to
		 * look up authorization data for FamilyLocal; see:
		 * xc/lib/xtrans/Xtrans.c:TRANS(GetHostname)
		 * We just add authorization entries with both
		 * hostname and nodename if they are different.
		 */
		if (uname(&uts) == -1)
			fatal("uname: %.100s", strerror(errno));
		if (strcmp(hostname, uts.nodename) != 0) {
			snprintf(auth_display, sizeof auth_display,
			    "%.400s/unix:%d.%d", uts.nodename,
			    s->display_number, s->screen);
			s->auth_display[1] = xstrdup(auth_display);
		}
d1691 1
a1691 1
		s->auth_display[0] = xstrdup(display);
@


1.116
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.115 2001/12/27 20:39:58 markus Exp $");
d186 1
a186 1
	int success, type, plen, screen_flag;
d202 1
a202 1
		type = packet_read(&plen);
@


1.115
log
@get rid of packet_integrity_check, use packet_done() instead.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.114 2001/12/20 16:37:29 markus Exp $");
d208 1
a208 1
			packet_done();
d239 1
a239 1
			packet_done();
d283 1
a283 1
				packet_done();
d317 1
a317 1
				packet_done();
d339 1
a339 1
			packet_done();
d1224 1
a1224 1
	packet_done();
d1289 1
a1289 1
	packet_done();
d1303 1
a1303 1
	packet_done();
d1338 1
a1338 1
	packet_done();
d1353 1
a1353 1
	packet_done();
d1363 1
a1363 1
	packet_done();
d1373 1
a1373 1
	packet_done();
@


1.114
log
@setup x11 listen socket for just one connect if the client requests so.
(v2 only, but the openssh client does not support this feature).
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.113 2001/12/19 15:43:11 stevesk Exp $");
a206 1
			packet_integrity_check(plen, 4, type);
d208 1
d283 1
a283 1
				packet_integrity_check(plen, 4 + dlen, type);
d317 1
a317 1
				packet_integrity_check(plen, 4 + dlen, type);
@


1.113
log
@handle utsname.nodename case for FamilyLocal X authorization; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.112 2001/12/19 07:18:56 deraadt Exp $");
d1677 1
a1677 1
	    options.gateway_ports);
@


1.112
log
@basic KNF done while i was looking for something else
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.111 2001/12/06 18:09:23 stevesk Exp $");
d79 1
a79 1
	char	*auth_display;
a1037 1

d1042 1
a1042 1
				    options.xauth_location, s->auth_display,
d1044 5
d1054 7
a1060 2
				fprintf(f, "add %s %s %s\n", s->auth_display,
				    s->auth_proto, s->auth_data);
d1552 4
a1555 2
	if (s->auth_display)
		xfree(s->auth_display);
d1691 1
d1693 2
d1700 16
a1715 1
		s->auth_display = xstrdup(auth_display);
d1720 1
a1720 1
		s->auth_display = xstrdup(display);
@


1.111
log
@strncpy->strlcpy.  remaining strncpy's are necessary.  ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.110 2001/12/01 21:41:48 markus Exp $");
d211 1
a211 1
				     compression_level);
d276 1
a276 1
			
d284 1
a284 1
				
d291 1
a291 1
					
d309 1
a309 1
			
d318 1
a318 1
				
d601 1
a601 1
		     (struct sockaddr *) & from, &fromlen) < 0) {
d690 1
a690 1
	      const char *value)
d731 1
a731 1
		      const char *filename)
d913 1
a913 1
			      s->authctxt->krb4_ticket_file);
d918 1
a918 1
			      s->authctxt->krb5_ticket_file);
d922 1
a922 1
			      auth_get_socket_name());
d985 1
a985 1
		
d988 1
a988 1
		
d1095 1
a1095 1
			     "-p", "-f", "--", pw->pw_name, (char *)NULL);
d1123 1
a1123 1
		for(i = 0; i < MAX_SESSIONS; i++) {
d1128 1
a1128 1
	for(i = 0; i < MAX_SESSIONS; i++) {
d1148 1
a1148 1
	for(i = 0; i < MAX_SESSIONS; i++) {
d1181 1
a1181 1
	for(i = 0; i < MAX_SESSIONS; i++) {
d1198 1
a1198 1
	for(i = 0; i < MAX_SESSIONS; i++) {
d1601 1
a1601 1
	for(i = 0; i < MAX_SESSIONS; i++) {
d1603 1
a1603 1
		if (s->used) 
d1614 1
a1614 1
	for(i = 0; i < MAX_SESSIONS; i++) {
@


1.110
log
@don't pass user defined variables to /usr/bin/login
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.109 2001/11/29 21:10:51 stevesk Exp $");
d1080 1
a1080 2
			strncpy(buf + 1, cp, sizeof(buf) - 1);
			buf[sizeof(buf) - 1] = 0;
@


1.109
log
@sshd X11 fake server will now listen on localhost by default:
$ echo $DISPLAY
localhost:12.0
$ netstat -an|grep 6012
tcp        0      0  127.0.0.1.6012         *.*                    LISTEN
tcp6       0      0  ::1.6012               *.*                    LISTEN
sshd_config gatewayports=yes can be used to revert back to the old
behavior.  will control this with another option later.  ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.108 2001/10/11 13:45:21 markus Exp $");
d880 14
a893 8
	while (custom_environment) {
		struct envstring *ce = custom_environment;
		char *s = ce->s;
		int i;
		for (i = 0; s[i] != '=' && s[i]; i++);
		if (s[i] == '=') {
			s[i] = 0;
			child_set_env(&env, &envsize, s, s + i + 1);
a894 3
		custom_environment = ce->next;
		xfree(ce->s);
		xfree(ce);
@


1.108
log
@delay detach of session if a channel gets closed but the child is still alive.
however, release pty, since the fd's to the child are already closed.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.107 2001/10/10 22:18:47 markus Exp $");
d76 1
d79 1
a1034 1
			char *screen = strchr(s->display, ':');
d1040 1
a1040 1
				    options.xauth_location, s->display,
a1041 6
				if (screen != NULL)
					fprintf(stderr,
					    "Adding %.*s/unix%s %s %s\n",
					    (int)(screen - s->display),
					    s->display, screen,
					    s->auth_proto, s->auth_data);
d1047 1
a1047 1
				fprintf(f, "add %s %s %s\n", s->display,
a1048 6
				if (screen != NULL)
					fprintf(f, "add %.*s/unix%s %s %s\n",
					    (int)(screen - s->display),
					    s->display, screen,
					    s->auth_proto,
					    s->auth_data);
d1541 2
d1638 2
d1663 3
a1665 2
	s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
	if (s->display == NULL) {
d1669 23
@


1.108.2.1
log
@Update to OpenSSH-3.0.2 from patch by markus.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.108 2001/10/11 13:45:21 markus Exp $");
d878 8
a885 14
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *s = ce->s;
			int i;
			for (i = 0; s[i] != '=' && s[i]; i++)
				;
			if (s[i] == '=') {
				s[i] = 0;
				child_set_env(&env, &envsize, s, s + i + 1);
			}
			custom_environment = ce->next;
			xfree(ce->s);
			xfree(ce);
d887 3
@


1.108.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.128 2002/02/16 00:51:44 markus Exp $");
a75 1
	int	display_number;
a77 1
	char	*auth_display;
d184 1
a184 1
	int success, type, screen_flag;
d200 1
a200 1
		type = packet_read();
d205 1
a206 1
			packet_check_eom();
d209 1
a209 1
				    compression_level);
d237 1
a237 1
			packet_check_eom();
d274 1
a274 1

d281 2
a282 2
				packet_check_eom();

d289 1
a289 1

d307 1
a307 1

d315 2
a316 2
				packet_check_eom();

d337 1
a337 1
			packet_check_eom();
d599 1
a599 1
		    (struct sockaddr *) & from, &fromlen) < 0) {
d614 1
a614 1
	    get_remote_name_or_ip(utmp_len, options.verify_reverse_mapping),
d688 1
a688 1
	const char *value)
d729 1
a729 1
	const char *filename)
d762 7
a768 2
static char **
do_setup_env(Session *s, const char *shell)
d770 2
d773 3
a775 1
	u_int i, envsize;
d777 72
a848 1
	struct passwd *pw = s->pw;
d882 1
a882 1

d896 1
a896 1
	    get_remote_ipaddr(), get_remote_port(), get_local_port());
d911 1
a911 1
		    s->authctxt->krb4_ticket_file);
d916 1
a916 1
		    s->authctxt->krb5_ticket_file);
d920 1
a920 1
		    auth_get_socket_name());
a933 168
	return env;
}

/*
 * Run $HOME/.ssh/rc, /etc/ssh/sshrc, or xauth (whichever is found
 * first in this order).
 */
static void
do_rc_files(Session *s, const char *shell)
{
	FILE *f = NULL;
	char cmd[1024];
	int do_xauth;
	struct stat st;

	do_xauth =
	    s->display != NULL && s->auth_proto != NULL && s->auth_data != NULL;

	/* ignore _PATH_SSH_USER_RC for subsystems */
	if (!s->is_subsystem && (stat(_PATH_SSH_USER_RC, &st) >= 0)) {
		snprintf(cmd, sizeof cmd, "%s -c '%s %s'",
		    shell, _PATH_BSHELL, _PATH_SSH_USER_RC);
		if (debug_flag)
			fprintf(stderr, "Running %s\n", cmd);
		f = popen(cmd, "w");
		if (f) {
			if (do_xauth)
				fprintf(f, "%s %s\n", s->auth_proto,
				    s->auth_data);
			pclose(f);
		} else
			fprintf(stderr, "Could not run %s\n",
			    _PATH_SSH_USER_RC);
	} else if (stat(_PATH_SSH_SYSTEM_RC, &st) >= 0) {
		if (debug_flag)
			fprintf(stderr, "Running %s %s\n", _PATH_BSHELL,
			    _PATH_SSH_SYSTEM_RC);
		f = popen(_PATH_BSHELL " " _PATH_SSH_SYSTEM_RC, "w");
		if (f) {
			if (do_xauth)
				fprintf(f, "%s %s\n", s->auth_proto,
				    s->auth_data);
			pclose(f);
		} else
			fprintf(stderr, "Could not run %s\n",
			    _PATH_SSH_SYSTEM_RC);
	} else if (do_xauth && options.xauth_location != NULL) {
		/* Add authority data to .Xauthority if appropriate. */
		if (debug_flag) {
			fprintf(stderr,
			    "Running %.100s add "
			    "%.100s %.100s %.100s\n",
			    options.xauth_location, s->auth_display,
			    s->auth_proto, s->auth_data);
		}
		snprintf(cmd, sizeof cmd, "%s -q -",
		    options.xauth_location);
		f = popen(cmd, "w");
		if (f) {
			fprintf(f, "add %s %s %s\n",
			    s->auth_display, s->auth_proto,
			    s->auth_data);
			pclose(f);
		} else {
			fprintf(stderr, "Could not run %s\n",
			    cmd);
		}
	}
}

static void
do_nologin(struct passwd *pw)
{
	FILE *f = NULL;
	char buf[1024];

#ifdef HAVE_LOGIN_CAP
	if (!login_getcapbool(lc, "ignorenologin", 0) && pw->pw_uid)
		f = fopen(login_getcapstr(lc, "nologin", _PATH_NOLOGIN,
		    _PATH_NOLOGIN), "r");
#else
	if (pw->pw_uid)
		f = fopen(_PATH_NOLOGIN, "r");
#endif
	if (f) {
		/* /etc/nologin exists.  Print its contents and exit. */
		while (fgets(buf, sizeof(buf), f))
			fputs(buf, stderr);
		fclose(f);
		exit(254);
	}
}

/* Set login name, uid, gid, and groups. */
static void
do_setusercontext(struct passwd *pw)
{
	if (getuid() == 0 || geteuid() == 0) {
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid,
		    (LOGIN_SETALL & ~LOGIN_SETPATH)) < 0) {
			perror("unable to set user context");
			exit(1);
		}
#else
		if (setlogin(pw->pw_name) < 0)
			error("setlogin failed: %s", strerror(errno));
		if (setgid(pw->pw_gid) < 0) {
			perror("setgid");
			exit(1);
		}
		/* Initialize the group list. */
		if (initgroups(pw->pw_name, pw->pw_gid) < 0) {
			perror("initgroups");
			exit(1);
		}
		endgrent();

		/* Permanently switch to the desired uid. */
		permanently_set_uid(pw);
#endif
	}
	if (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)
		fatal("Failed to set uids to %u.", (u_int) pw->pw_uid);
}

/*
 * Performs common processing for the child, such as setting up the
 * environment, closing extra file descriptors, setting the user and group
 * ids, and executing the command or shell.
 */
void
do_child(Session *s, const char *command)
{
	extern char **environ;
	char **env;
	char *argv[10];
	const char *shell, *shell0, *hostname = NULL;
	struct passwd *pw = s->pw;
	u_int i;

	/* remove hostkey from the child's memory */
	destroy_sensitive_data();

	/* login(1) is only called if we execute the login shell */
	if (options.use_login && command != NULL)
		options.use_login = 0;

	/*
	 * Login(1) does this as well, and it needs uid 0 for the "-h"
	 * switch, so we let login(1) to this for us.
	 */
	if (!options.use_login) {
		do_nologin(pw);
		do_setusercontext(pw);
	}

	/*
	 * Get the shell from the password data.  An empty shell field is
	 * legal, and means /bin/sh.
	 */
	shell = (pw->pw_shell[0] == '\0') ? _PATH_BSHELL : pw->pw_shell;
#ifdef HAVE_LOGIN_CAP
	shell = login_getcapstr(lc, "shell", (char *)shell, (char *)shell);
#endif

	env = do_setup_env(s, shell);

d937 1
a937 1
		    options.verify_reverse_mapping);
d974 2
a975 2
	 * Must take new environment into use so that .ssh/rc,
	 * /etc/ssh/sshrc and xauth are run in the proper environment.
d983 1
a983 1

d986 1
a986 1

d1001 75
a1075 2
	if (!options.use_login)
		do_rc_files(s, shell);
a1079 18
	if (options.use_login) {
		/* Launch login(1). */

		execl("/usr/bin/login", "login", "-h", hostname,
		    "-p", "-f", "--", pw->pw_name, (char *)NULL);

		/* Login couldn't be executed, die. */

		perror("login");
		exit(1);
	}

	/* Get the last component of the shell name. */
	if ((shell0 = strrchr(shell, '/')) != NULL)
		shell0++;
	else
		shell0 = shell;

d1086 2
a1087 1
		char argv0[256];
d1089 9
a1097 2
		/* Start the shell.  Set initial character to '-'. */
		argv0[0] = '-';
d1099 1
a1099 3
		if (strlcpy(argv0 + 1, shell0, sizeof(argv0) - 1)
		    >= sizeof(argv0) - 1) {
			errno = EINVAL;
d1102 11
a1113 9

		/* Execute the shell. */
		argv[0] = argv0;
		argv[1] = NULL;
		execve(shell, argv, env);

		/* Executing the shell failed. */
		perror(shell);
		exit(1);
d1119 1
a1119 1
	argv[0] = (char *) shell0;
d1135 1
a1135 1
		for (i = 0; i < MAX_SESSIONS; i++) {
d1140 1
a1140 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1160 1
a1160 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1193 1
a1193 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1210 1
a1210 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1227 1
a1227 1
	packet_check_eom();
d1292 1
a1292 1
	packet_check_eom();
d1306 2
a1307 2
	packet_check_eom();
	log("subsystem request for %.100s", subsys);
a1320 1
			break;
d1325 1
a1325 1
		log("subsystem request for %.100s failed, subsystem not found",
d1341 1
a1341 1
	packet_check_eom();
d1356 1
a1356 1
	packet_check_eom();
d1366 1
a1366 1
	packet_check_eom();
d1376 1
a1376 1
	packet_check_eom();
d1389 2
a1390 2
int
session_input_channel_req(Channel *c, const char *rtype)
d1392 2
d1395 1
d1397 4
d1402 9
a1410 6
	if ((s = session_by_channel(c->self)) == NULL) {
		log("session_input_channel_req: no session %d req %.100s",
		    c->self, rtype);
		return 0;
	}
	debug("session_input_channel_req: session %d req %s", s->self, rtype);
d1434 8
a1441 1
	return success;
d1458 1
a1458 2
	    1,
	    CHAN_SES_WINDOW_DEFAULT);
d1502 4
a1505 2

	if ((c = channel_lookup(s->chanid)) == NULL)
d1512 2
a1513 1
		channel_request_start(s->chanid, "exit-status", 0);
d1517 2
a1518 1
		channel_request_start(s->chanid, "exit-signal", 0);
a1554 2
	if (s->auth_display)
		xfree(s->auth_display);
d1611 1
a1611 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1613 1
a1613 1
		if (s->used)
d1624 1
a1624 1
	for (i = 0; i < MAX_SESSIONS; i++) {
a1649 2
	char display[512], auth_display[512];
	char hostname[MAXHOSTNAMELEN];
d1673 2
a1674 3
	s->display_number = x11_create_display_inet(options.x11_display_offset,
	    options.x11_use_localhost, s->single_connection);
	if (s->display_number == -1) {
a1677 23

	/* Set up a suitable value for the DISPLAY variable. */
	if (gethostname(hostname, sizeof(hostname)) < 0)
		fatal("gethostname: %.100s", strerror(errno));
	/*
	 * auth_display must be used as the displayname when the
	 * authorization entry is added with xauth(1).  This will be
	 * different than the DISPLAY string for localhost displays.
	 */
	if (options.x11_use_localhost) {
		snprintf(display, sizeof display, "localhost:%d.%d",
		    s->display_number, s->screen);
		snprintf(auth_display, sizeof auth_display, "unix:%d.%d",
		    s->display_number, s->screen);
		s->display = xstrdup(display);
		s->auth_display = xstrdup(auth_display);
	} else {
		snprintf(display, sizeof display, "%.400s:%d.%d", hostname,
		    s->display_number, s->screen);
		s->display = xstrdup(display);
		s->auth_display = xstrdup(display);
	}

@


1.108.2.3
log
@apply the necessary openbsd30_3.1.patch patch.
--
Ok'd by markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.108.2.2 2002/03/07 17:37:47 jason Exp $");
d860 1
a860 1
 * Run $HOME/.ssh/rc, /etc/sshrc, or xauth (whichever is found
d1065 1
a1065 1
	 * /etc/sshrc and xauth are run in the proper environment.
@


1.108.2.4
log
@Update OpenSSH to version 3.2.2.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.134 2002/03/29 18:59:31 markus Exp $");
d59 28
a86 1
#include "monitor_wrap.h"
d92 1
a92 1
void	session_pty_cleanup(void *);
d106 1
d126 1
a126 1
login_cap_t *lc;
d141 12
d586 1
d589 1
d607 7
d615 3
a617 5
	if (!use_privsep)
		record_login(pid, s->tty, pw->pw_name, pw->pw_uid,
		    get_remote_name_or_ip(utmp_len,
		    options.verify_reverse_mapping),
		    (struct sockaddr *)&from);
d622 2
a623 2
	if (options.print_lastlog && s->last_login_time != 0) {
		time_string = ctime(&s->last_login_time);
d626 1
a626 1
		if (strcmp(s->hostname, "") == 0)
d629 1
a629 2
			printf("Last login: %s from %s\r\n", time_string,
			    s->hostname);
d950 1
a950 1
void
a981 14
static void
launch_login(struct passwd *pw, const char *hostname)
{
	/* Launch login(1). */

	execl("/usr/bin/login", "login", "-h", hostname,
	    "-p", "-f", "--", pw->pw_name, (char *)NULL);

	/* Login couldn't be executed, die. */

	perror("login");
	exit(1);
}

d1098 9
a1106 2
		launch_login(pw, hostname);
		/* NEVERREACHED */
a1215 16
Session *
session_by_tty(char *tty)
{
	int i;
	for (i = 0; i < MAX_SESSIONS; i++) {
		Session *s = &sessions[i];
		if (s->used && s->ttyfd != -1 && strcmp(s->tty, tty) == 0) {
			debug("session_by_tty: session %d tty %s", i, tty);
			return s;
		}
	}
	debug("session_by_tty: unknown tty %.100s", tty);
	session_dump();
	return NULL;
}

a1272 6
	/* Get the time and hostname when the user last logged in. */
	if (options.print_lastlog) {
		s->hostname[0] = '\0';
		s->last_login_time = get_last_login_time(s->pw->pw_uid,
		    s->pw->pw_name, s->hostname, sizeof(s->hostname));
	}
d1293 1
a1293 1
	if (!PRIVSEP(pty_allocate(&s->ptyfd, &s->ttyfd, s->tty, sizeof(s->tty)))) {
d1314 1
a1314 2
	if (!use_privsep)
		pty_setowner(s->pw, s->tty);
d1477 2
a1478 2
void
session_pty_cleanup2(void *session)
d1496 1
a1496 2
	if (getuid() == 0)
		pty_release(s->tty);
d1504 1
a1504 1
		error("close(s->ptymaster/%d): %s", s->ptymaster, strerror(errno));
a1509 6
void
session_pty_cleanup(void *session)
{
	PRIVSEP(session_pty_cleanup2(session));
}

d1551 1
a1551 1
void
d1618 1
a1618 1
session_destroy_all(void (*closefunc)(Session *))
d1623 2
a1624 6
		if (s->used) {
			if (closefunc != NULL)
				closefunc(s);
			else
				session_close(s);
		}
@


1.108.2.5
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.108.2.4 2002/05/17 00:03:24 miod Exp $");
a100 87
/* Name and directory of socket for authentication agent forwarding. */
static char *auth_sock_name = NULL;
static char *auth_sock_dir = NULL;

/* removes the agent forwarding socket */

static void
auth_sock_cleanup_proc(void *_pw)
{
	struct passwd *pw = _pw;

	if (auth_sock_name != NULL) {
		temporarily_use_uid(pw);
		unlink(auth_sock_name);
		rmdir(auth_sock_dir);
		auth_sock_name = NULL;
		restore_uid();
	}
}

static int
auth_input_request_forwarding(struct passwd * pw)
{
	Channel *nc;
	int sock;
	struct sockaddr_un sunaddr;

	if (auth_sock_name != NULL) {
		error("authentication forwarding requested twice.");
		return 0;
	}

	/* Temporarily drop privileged uid for mkdir/bind. */
	temporarily_use_uid(pw);

	/* Allocate a buffer for the socket name, and format the name. */
	auth_sock_name = xmalloc(MAXPATHLEN);
	auth_sock_dir = xmalloc(MAXPATHLEN);
	strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXX", MAXPATHLEN);

	/* Create private directory for socket */
	if (mkdtemp(auth_sock_dir) == NULL) {
		packet_send_debug("Agent forwarding disabled: "
		    "mkdtemp() failed: %.100s", strerror(errno));
		restore_uid();
		xfree(auth_sock_name);
		xfree(auth_sock_dir);
		auth_sock_name = NULL;
		auth_sock_dir = NULL;
		return 0;
	}
	snprintf(auth_sock_name, MAXPATHLEN, "%s/agent.%ld",
		 auth_sock_dir, (long) getpid());

	/* delete agent socket on fatal() */
	fatal_add_cleanup(auth_sock_cleanup_proc, pw);

	/* Create the socket. */
	sock = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sock < 0)
		packet_disconnect("socket: %.100s", strerror(errno));

	/* Bind it to the name. */
	memset(&sunaddr, 0, sizeof(sunaddr));
	sunaddr.sun_family = AF_UNIX;
	strlcpy(sunaddr.sun_path, auth_sock_name, sizeof(sunaddr.sun_path));

	if (bind(sock, (struct sockaddr *) & sunaddr, sizeof(sunaddr)) < 0)
		packet_disconnect("bind: %.100s", strerror(errno));

	/* Restore the privileged uid. */
	restore_uid();

	/* Start listening on the socket. */
	if (listen(sock, 5) < 0)
		packet_disconnect("listen: %.100s", strerror(errno));

	/* Allocate a channel for the authentication agent socket. */
	nc = channel_new("auth socket",
	    SSH_CHANNEL_AUTH_SOCKET, sock, sock, -1,
	    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,
	    0, xstrdup("auth socket"), 1);
	strlcpy(nc->path, auth_sock_name, sizeof(nc->path));
	return 1;
}


d123 1
a123 1
	if (auth_sock_name != NULL)
a173 4
			if (!options.compression) {
				debug2("compression disabled");
				break;
			}
d330 1
a330 1
	pid_t pid;
d794 1
a794 1
	if (auth_sock_name != NULL)
d796 1
a796 1
		    auth_sock_name);
d860 1
a860 1
			    "Running %.500s add "
d1150 1
a1150 1
		debug("dump: used %d session %d %p channel %d pid %ld",
d1155 1
a1155 1
		    (long)s->pid);
d1213 1
a1213 1
	debug("session_by_pid: pid %ld", (long)pid);
d1219 1
a1219 1
	error("session_by_pid: unknown pid %ld", (long)pid);
d1509 2
a1510 2
	debug("session_exit_message: session %d channel %d pid %ld",
	    s->self, s->chanid, (long)s->pid);
d1545 1
a1545 1
	debug("session_close: session %d pid %ld", s->self, (long)s->pid);
d1569 1
a1569 2
		debug("session_close_by_pid: no session for pid %ld",
		    (long)pid);
d1589 1
a1589 2
	debug("session_close_by_channel: channel %d child %ld",
	    id, (long)s->pid);
@


1.108.2.6
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.108.2.5 2002/06/22 07:23:17 miod Exp $");
d234 2
a235 2
	int enable_compression_after_reply = 0;
	u_int proto_len, data_len, dlen, compression_level = 0;
a755 3
			if (*envsizep >= 1000)
				fatal("child_set_env: too many env vars,"
				    " skipping: %.100s", name);
a780 1
	u_int lineno = 0;
a786 2
		if (++lineno > 1000)
			fatal("Too many lines in environment file %s", filename);
d795 1
a795 2
			fprintf(stderr, "Bad line %u in %.100s\n", lineno,
			    filename);
d1773 3
a1775 3
	if (x11_create_display_inet(options.x11_display_offset,
	    options.x11_use_localhost, s->single_connection,
	    &s->display_number) == -1) {
d1789 1
a1789 1
		snprintf(display, sizeof display, "localhost:%u.%u",
d1791 1
a1791 1
		snprintf(auth_display, sizeof auth_display, "unix:%u.%u",
d1796 1
a1796 1
		snprintf(display, sizeof display, "%.400s:%u.%u", hostname,
@


1.108.2.7
log
@Update to OpenSSH 3.5
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.150 2002/09/16 19:55:33 stevesk Exp $");
a443 2
		fatal_remove_all_cleanups();

a549 1
		fatal_remove_all_cleanups();
a646 1
	fromlen = sizeof(from);
d648 1
d661 1
a661 1
		    (struct sockaddr *)&from, fromlen);
d835 2
a836 4
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, "PATH", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, "PATH", getenv("PATH"));
d855 1
a855 1
			char *str = ce->s;
d857 1
a857 1
			for (i = 0; str[i] != '=' && str[i]; i++)
d859 3
a861 3
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
a868 1
	/* SSH_CLIENT deprecated */
a872 5
	snprintf(buf, sizeof buf, "%.50s %d %.50s %d",
	    get_remote_ipaddr(), get_remote_port(),
	    get_local_ipaddr(packet_get_connection_in()), get_local_port());
	child_set_env(&env, &envsize, "SSH_CONNECTION", buf);

d897 1
a897 1
	if (options.permit_user_env && !options.use_login) {
a993 2
		log("User %.100s not allowed because %s exists",
		    pw->pw_name, _PATH_NOLOGIN);
a1598 21
static char *
sig2name(int sig)
{
#define SSH_SIG(x) if (sig == SIG ## x) return #x
	SSH_SIG(ABRT);
	SSH_SIG(ALRM);
	SSH_SIG(FPE);
	SSH_SIG(HUP);
	SSH_SIG(ILL);
	SSH_SIG(INT);
	SSH_SIG(KILL);
	SSH_SIG(PIPE);
	SSH_SIG(QUIT);
	SSH_SIG(SEGV);
	SSH_SIG(TERM);
	SSH_SIG(USR1);
	SSH_SIG(USR2);
#undef	SSH_SIG
	return "SIG@@openssh.com";
}

d1616 1
a1616 1
		packet_put_cstring(sig2name(WTERMSIG(status)));
@


1.107
log
@try to keep channels open until an exit-status message is sent.
don't kill the login shells if the shells stdin/out/err is closed.
this should now work:
ssh -2n localhost 'exec > /dev/null 2>&1; sleep 10; exit 5'; echo ?
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.106 2001/10/09 21:59:41 markus Exp $");
d1490 3
a1586 1
		/* delay detach */
d1588 8
@


1.106
log
@simplify session close: no more delayed session_close, no more blocking wait() calls.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.105 2001/10/09 19:32:49 markus Exp $");
d1579 1
a1579 1
		debug("session_close_by_channel: no session for channel %d", id);
d1582 7
a1588 1
	/* disconnect channel */
a1590 8

	debug("session_close_by_channel: channel %d kill %d", id, s->pid);
	if (s->pid != 0) {
		/* notify child */
		if (kill(s->pid, SIGHUP) < 0)
			error("session_close_by_channel: kill %d: %s",
			    s->pid, strerror(errno));
	}
d1595 1
a1595 1
session_close_all(void)
d1600 1
a1600 5
		if (s->used) {
			if (s->chanid != -1) {
				channel_cancel_cleanup(s->chanid);
				s->chanid = -1;
			}
a1601 1
		}
@


1.105
log
@stat subsystem command before calling do_exec, and return error to client.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.104 2001/10/09 10:12:08 markus Exp $");
a1569 16
int
session_have_children(void)
{
	int i;

	for(i = 0; i < MAX_SESSIONS; i++) {
		Session *s = &sessions[i];
		if (s->used && s->pid != -1) {
			debug("session_have_children: id %d pid %d", i, s->pid);
			return 1;
		}
	}
	debug("session_have_children: no more children");
	return 0;
}

d1587 3
a1589 6
	if (s->pid == 0) {
		/* close session immediately */
		session_close(s);
	} else {
		/* notify child, delay session cleanup */
		if (kill(s->pid, (s->ttyfd == -1) ? SIGTERM : SIGHUP) < 0)
d1592 17
@


1.104
log
@chdir $HOME after krb_afslog(); from bbense@@networking.stanford.edu
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.103 2001/10/06 00:36:42 markus Exp $");
d1297 1
d1300 1
a1300 1
	char *subsys = packet_get_string(&len);
d1307 8
a1314 2
		if(strcmp(subsys, options.subsystem_name[i]) == 0) {
			debug("subsystem: exec() %s", options.subsystem_command[i]);
d1316 1
a1316 1
			do_exec(s, options.subsystem_command[i]);
d1322 2
a1323 1
		log("subsystem request for %s failed, subsystem not found", subsys);
@


1.103
log
@fix typo in error message, sync with do_exec_nopty
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.102 2001/09/16 14:46:54 markus Exp $");
a969 10
	/* Change current directory to the user\'s home directory. */
	if (chdir(pw->pw_dir) < 0) {
		fprintf(stderr, "Could not chdir to home directory %s: %s\n",
			pw->pw_dir, strerror(errno));
#ifdef HAVE_LOGIN_CAP
		if (login_getcapbool(lc, "requirehome", 0))
			exit(1);
#endif
	}

d987 10
@


1.102
log
@calls krb_afslog() after setting $HOME; mattiasa@@e.kth.se; fixes pr 1943
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.101 2001/09/14 18:59:11 markus Exp $");
d506 7
a512 11
		/* Redirect stdin from the pseudo tty. */
		if (dup2(ttyfd, fileno(stdin)) < 0)
			error("dup2 stdin failed: %.100s", strerror(errno));

		/* Redirect stdout to the pseudo tty. */
		if (dup2(ttyfd, fileno(stdout)) < 0)
			error("dup2 stdin failed: %.100s", strerror(errno));

		/* Redirect stderr to the pseudo tty. */
		if (dup2(ttyfd, fileno(stderr)) < 0)
			error("dup2 stdin failed: %.100s", strerror(errno));
@


1.101
log
@command=xxx overwrites subsystems, too
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.100 2001/08/16 19:18:34 jakob Exp $");
a853 12
#ifdef AFS
	/* Try to get AFS tokens for the local cell. */
	if (k_hasafs()) {
		char cell[64];
		
		if (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)
			krb_afslog(cell, 0);
		
		krb_afslog(0, 0);
	}
#endif /* AFS */

d989 12
@


1.100
log
@deprecate CheckMail. ok markus@@
----------------------------------------------------------------------
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.99 2001/07/09 07:04:53 deraadt Exp $");
d1313 1
a1313 1
			do_exec_no_pty(s, options.subsystem_command[i]);
@


1.99
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.98 2001/07/02 13:59:15 markus Exp $");
a1089 19
			/*
			 * Check for mail if we have a tty and it was enabled
			 * in server options.
			 */
			if (s->ttyfd != -1 && options.check_mail) {
				char *mailbox;
				struct stat mailstat;

				mailbox = getenv("MAIL");
				if (mailbox != NULL) {
					if (stat(mailbox, &mailstat) != 0 ||
					    mailstat.st_size == 0)
						printf("No mail.\n");
					else if (mailstat.st_mtime < mailstat.st_atime)
						printf("You have mail.\n");
					else
						printf("You have new mail.\n");
				}
			}
@


1.98
log
@wait until !session_have_children(); bugreport from Lutz.Jaenicke@@aet.TU-Cottbus.DE
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.97 2001/06/27 02:12:53 markus Exp $");
d1127 1
a1127 1
			     "-p", "-f", "--", pw->pw_name, NULL);
@


1.97
log
@quick hack to make ssh2 work again.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.96 2001/06/26 16:15:24 dugsong Exp $");
d1583 16
@


1.96
log
@Kerberos v5 support for SSH1, mostly from Assar Westerlund <assar@@freebsd.org> and Bjorn Gronvall <bg@@sics.se>. markus@@ ok
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.95 2001/06/25 08:25:39 markus Exp $");
d497 1
a499 1

d1192 1
a1192 1
session_open(int chanid)
d1200 2
a1201 1
	s->pw = auth_get_user();
d1679 1
a1679 1
	server_loop2();
@


1.95
log
@update copyright for 2001
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.94 2001/06/23 15:12:20 itojun Exp $");
d67 2
a68 1
	struct	passwd *pw;
d163 8
d189 1
d274 52
d669 1
a669 1
	struct passwd * pw = s->pw;
d775 1
a775 1
	struct passwd * pw = s->pw;
d858 1
a858 1

d861 1
a861 1

a920 1

d922 9
a930 8
	{
		extern char *ticket;

		if (ticket)
			child_set_env(&env, &envsize, "KRBTKFILE", ticket);
	}
#endif /* KRB4 */

@


1.94
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d12 1
a12 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.93 2001/06/21 21:08:25 markus Exp $");
@


1.93
log
@don't reset forced_command (we allow multiple login shells in ssh2); dwd@@bell-labs.com
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.92 2001/06/19 15:40:45 markus Exp $");
d88 9
a96 11
void	session_set_fds(Session *s, int fdin, int fdout, int fderr);
void	session_pty_cleanup(void *session);
int	session_pty_req(Session *s);
void	session_proctitle(Session *s);
int	session_setup_x11fwd(Session *s);
void	session_close(Session *s);
void	do_exec_pty(Session *s, const char *command);
void	do_exec_no_pty(Session *s, const char *command);
void	do_exec(Session *s, const char *command);
void	do_login(Session *s, const char *command);
void	do_child(Session *s, const char *command);
d98 1
a98 1
int	check_quietlogin(Session *s, const char *command);
d100 5
a104 2
void	do_authenticated1(Authctxt *authctxt);
void	do_authenticated2(Authctxt *authctxt);
d170 1
a170 1
void
d628 1
a628 1
void
d669 1
a669 1
void
d1114 1
a1114 1
void
d1146 1
a1146 1
Session *
d1162 1
a1162 1
Session *
d1177 1
a1177 1
int
d1189 1
a1189 1
int
d1254 1
a1254 1
int
d1281 1
a1281 1
int
d1302 1
a1302 1
int
d1310 1
a1310 1
int
d1321 1
a1321 1
int
d1414 1
a1414 1
void
d1444 1
a1444 1
void
d1489 1
a1489 1
void
d1550 1
a1550 1
char *
d1613 1
a1613 1
void
@


1.92
log
@allocate and free at the same level.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.91 2001/06/19 14:09:45 markus Exp $");
a507 1
		forced_command = NULL;
@


1.91
log
@disable x11-fwd if use_login is enabled; from lukem@@wasabisystems.com
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.90 2001/06/19 12:34:09 markus Exp $");
d115 1
a115 1
char *original_command = NULL;
d269 2
a270 1
				packet_integrity_check(plen, 4 + dlen, type);
d272 1
a272 2
				command = NULL;
				packet_integrity_check(plen, 0, type);
d274 1
a274 1
			do_exec(s, command);
d517 1
a517 7
	if (command != NULL)
		xfree(command);

	if (original_command != NULL) {
		xfree(original_command);
		original_command = NULL;
	}
d1317 1
@


1.90
log
@cleanup forced command handling, from dwd@@bell-labs.com
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.89 2001/06/13 09:10:31 markus Exp $");
d1599 5
@


1.89
log
@typo, use pid not s->pid, mstone@@cs.loyola.edu
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.88 2001/06/12 21:30:57 markus Exp $");
d96 1
d274 1
a274 11
			if (forced_command != NULL) {
				original_command = command;
				command = forced_command;
				debug("Forced command '%.500s'", forced_command);
			}
			if (s->ttyfd != -1)
				do_exec_pty(s, command);
			else
				do_exec_no_pty(s, command);
			if (command != NULL)
				xfree(command);
d498 29
a1310 2
	/* if forced_command == NULL, the shell is execed */
	char *shell = forced_command;
d1312 1
a1312 4
	if (s->ttyfd == -1)
		do_exec_no_pty(s, shell);
	else
		do_exec_pty(s, shell);
d1322 1
a1322 11
	if (forced_command) {
		original_command = command;
		command = forced_command;
		debug("Forced command '%.500s'", forced_command);
	}
	if (s->ttyfd == -1)
		do_exec_no_pty(s, command);
	else
		do_exec_pty(s, command);
	if (forced_command == NULL)
		xfree(command);
@


1.88
log
@unused
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.87 2001/06/12 21:21:29 markus Exp $");
d1514 1
a1514 1
		debug("session_close_by_pid: no session for pid %d", s->pid);
@


1.87
log
@remove xauth-cookie-in-tmp handling. use default $XAUTHORITY, since
we do already trust $HOME/.ssh
you can use .ssh/sshrc and .ssh/environment if you want to customize
the location of the xauth cookies
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.86 2001/06/12 16:10:38 markus Exp $");
a1580 1
	int fd;
@


1.86
log
@merge ssh1/ssh2 tty msg parse and alloc code
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.85 2001/06/12 10:58:29 markus Exp $");
a99 1
void	xauthfile_cleanup_proc(void *pw);
a112 3
/* Local Xauthority file. */
static char *xauthfile;

d157 1
a157 3
	/* remote user's local Xauthority file and agent socket */
	if (xauthfile)
		xauthfile_cleanup_proc(authctxt->pw);
a162 24
 * Remove local Xauthority file.
 */
void
xauthfile_cleanup_proc(void *_pw)
{
	struct passwd *pw = _pw;
	char *p;

	debug("xauthfile_cleanup_proc called");
	if (xauthfile != NULL) {
		temporarily_use_uid(pw);
		unlink(xauthfile);
		p = strrchr(xauthfile, '/');
		if (p != NULL) {
			*p = '\0';
			rmdir(xauthfile);
		}
		xfree(xauthfile);
		xauthfile = NULL;
		restore_uid();
	}
}

/*
a854 2
	if (xauthfile)
		child_set_env(&env, &envsize, "XAUTHORITY", xauthfile);
d1597 1
a1597 1
	if (s->display != NULL || xauthfile != NULL) {
a1600 16
	xauthfile = xmalloc(MAXPATHLEN);
	strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", MAXPATHLEN);
	temporarily_use_uid(s->pw);
	if (mkdtemp(xauthfile) == NULL) {
		error("private X11 dir: mkdtemp %s failed: %s",
		    xauthfile, strerror(errno));
		restore_uid();
		xfree(xauthfile);
		xauthfile = NULL;
		return 0;
	}
	strlcat(xauthfile, "/cookies", MAXPATHLEN);
	fd = open(xauthfile, O_RDWR|O_CREAT|O_EXCL, 0600);
	if (fd >= 0)
		close(fd);
	restore_uid();
d1603 1
a1603 1
		xauthfile_cleanup_proc(s->pw);
a1605 1
	fatal_add_cleanup(xauthfile_cleanup_proc, s->pw);
@


1.85
log
@merge session_free into session_close()
merge pty_cleanup_proc into session_pty_cleanup()
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.84 2001/06/11 10:18:24 markus Exp $");
d90 1
d203 1
a203 1
	int success, type, n_bytes, plen, screen_flag, have_pty = 0;
d236 1
a236 45
			if (no_pty_flag) {
				debug("Allocating a pty not permitted for this authentication.");
				break;
			}
			if (have_pty)
				packet_disconnect("Protocol error: you already have a pty.");

			debug("Allocating pty.");

			/* Allocate a pty and open it. */
			if (!pty_allocate(&s->ptyfd, &s->ttyfd, s->tty,
			    sizeof(s->tty))) {
				error("Failed to allocate pty.");
				break;
			}
			fatal_add_cleanup(session_pty_cleanup, (void *)s);
			pty_setowner(s->pw, s->tty);

			/* Get TERM from the packet.  Note that the value may be of arbitrary length. */
			s->term = packet_get_string(&dlen);
			packet_integrity_check(dlen, strlen(s->term), type);
			/* packet_integrity_check(plen, 4 + dlen + 4*4 + n_bytes, type); */
			/* Remaining bytes */
			n_bytes = plen - (4 + dlen + 4 * 4);

			if (strcmp(s->term, "") == 0) {
				xfree(s->term);
				s->term = NULL;
			}
			/* Get window size from the packet. */
			s->row = packet_get_int();
			s->col = packet_get_int();
			s->xpixel = packet_get_int();
			s->ypixel = packet_get_int();
			pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);

			/* Get tty modes from the packet. */
			tty_parse_modes(s->ttyfd, &n_bytes);
			packet_integrity_check(plen, 4 + dlen + 4 * 4 + n_bytes, type);

			session_proctitle(s);

			/* Indicate that we now have a pty. */
			success = 1;
			have_pty = 1;
d308 1
a308 1
			if (have_pty)
d1213 2
a1214 1
	if (no_pty_flag)
d1216 3
a1218 1
	if (s->ttyfd != -1)
d1220 2
d1223 8
a1230 2
	s->col = packet_get_int();
	s->row = packet_get_int();
d1238 1
d1240 1
d1242 2
a1243 1
		xfree(s->term);
d1251 6
d1263 2
a1264 1
	/* Get window size from the packet. */
a1266 2
	/* Get tty modes from the packet. */
	tty_parse_modes(s->ttyfd, &n_bytes);
a1267 1

a1268 1

@


1.84
log
@reset pointer to NULL after xfree(); report from solar@@openwall.com
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.83 2001/06/07 22:25:02 markus Exp $");
d89 1
a89 1
void	session_pty_cleanup(Session *s);
a191 21
 * Function to perform cleanup if we get aborted abnormally (e.g., due to a
 * dropped connection).
 */
void
pty_cleanup_proc(void *session)
{
	Session *s=session;
	if (s == NULL)
		fatal("pty_cleanup_proc: no session");
	debug("pty_cleanup_proc: %s", s->tty);

	if (s->pid != 0) {
		/* Record that the user has logged out. */
		record_logout(s->pid, s->tty);
	}

	/* Release the pseudo-tty. */
	pty_release(s->tty);
}

/*
d250 1
a250 1
			fatal_add_cleanup(pty_cleanup_proc, (void *)s);
a1155 1
			sessions[i].self = i;
d1167 1
d1284 1
a1284 1
	fatal_add_cleanup(pty_cleanup_proc, (void *)s);
d1468 4
d1473 1
a1473 1
session_pty_cleanup(Session *s)
d1475 7
a1481 1
	if (s == NULL || s->ttyfd == -1)
a1485 3
	/* Cancel the cleanup function. */
	fatal_remove_cleanup(pty_cleanup_proc, (void *)s);

d1487 2
a1488 1
	record_logout(s->pid, s->tty);
d1510 1
a1510 1
		fatal("session_close: session %d: no channel %d",
d1548 1
a1548 1
session_free(Session *s)
d1550 5
a1554 1
	debug("session_free: session %d pid %d", s->self, s->pid);
a1563 7
}

void
session_close(Session *s)
{
	session_pty_cleanup(s);
	session_free(s);
@


1.83
log
@don't overwrite errno
delay deletion of the xauth cookie
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.82 2001/06/05 16:46:19 markus Exp $");
d324 2
d802 4
a805 1
	int do_xauth = s->auth_proto != NULL && s->auth_data != NULL;
d1361 2
@


1.82
log
@let session_close() delete the pty.  deny x11fwd if xauthfile is set.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.81 2001/06/04 23:16:16 markus Exp $");
a1570 4
	if (s->display) {
		xauthfile_cleanup_proc(s->pw);
		fatal_remove_cleanup(xauthfile_cleanup_proc, s->pw);
	}
a1671 1
		restore_uid();
d1674 1
@


1.81
log
@merge ssh1/2 x11-fwd setup, create listener after tmp-dir
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.80 2001/06/04 21:59:43 markus Exp $");
d92 1
a373 1

d376 1
a595 1
		session_pty_cleanup(s);
d1668 1
a1668 1
	if (s->display != NULL) {
a1699 1

@


1.80
log
@switch uid when cleaning up tmp files and sockets; reported by zen-parse@@gmx.net on bugtraq
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.79 2001/06/03 14:55:39 markus Exp $");
d91 1
d222 1
a222 1
	int success, type, fd, n_bytes, plen, screen_flag, have_pty = 0;
a224 1
	struct stat st;
a302 17
			if (!options.x11_forwarding) {
				packet_send_debug("X11 forwarding disabled in server configuration file.");
				break;
			}
			if (!options.xauth_location ||
			    (stat(options.xauth_location, &st) == -1)) {
				packet_send_debug("No xauth program; cannot forward with spoofing.");
				break;
			}
			if (no_x11_forwarding_flag) {
				packet_send_debug("X11 forwarding not permitted for this authentication.");
				break;
			}
			debug("Received request for X11 forwarding with auth spoofing.");
			if (s->display != NULL)
				packet_disconnect("Protocol error: X11 display already set.");

a313 2
				packet_integrity_check(plen,
				    4 + proto_len + 4 + data_len + 4, type);
a315 2
				packet_integrity_check(plen,
				    4 + proto_len + 4 + data_len, type);
d318 5
a322 17
			s->display = x11_create_display_inet(s->screen, options.x11_display_offset);

			if (s->display == NULL)
				break;

			/* Setup to always have a local .Xauthority. */
			xauthfile = xmalloc(MAXPATHLEN);
			strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", MAXPATHLEN);
			temporarily_use_uid(s->pw);
			if (mkdtemp(xauthfile) == NULL) {
				restore_uid();
				error("private X11 dir: mkdtemp %s failed: %s",
				    xauthfile, strerror(errno));
				xfree(xauthfile);
				xauthfile = NULL;
				/* XXXX remove listening channels */
				break;
a323 7
			strlcat(xauthfile, "/cookies", MAXPATHLEN);
			fd = open(xauthfile, O_RDWR|O_CREAT|O_EXCL, 0600);
			if (fd >= 0)
				close(fd);
			restore_uid();
			fatal_add_cleanup(xauthfile_cleanup_proc, s->pw);
			success = 1;
d1344 1
a1344 23
	int fd;
	struct stat st;
	if (no_x11_forwarding_flag) {
		debug("X11 forwarding disabled in user configuration file.");
		return 0;
	}
	if (!options.x11_forwarding) {
		debug("X11 forwarding disabled in server configuration file.");
		return 0;
	}
	if (!options.xauth_location ||
	    (stat(options.xauth_location, &st) == -1)) {
		packet_send_debug("No xauth program; cannot forward with spoofing.");
		return 0;
	}
	if (xauthfile != NULL) {
		debug("X11 fwd already started.");
		return 0;
	}

	debug("Received request for X11 forwarding with auth spoofing.");
	if (s->display != NULL)
		packet_disconnect("Protocol error: X11 display already set.");
d1352 2
a1353 2
	s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
	if (s->display == NULL) {
a1355 1
		return 0;
d1357 1
a1357 21
	xauthfile = xmalloc(MAXPATHLEN);
	strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", MAXPATHLEN);
	temporarily_use_uid(s->pw);
	if (mkdtemp(xauthfile) == NULL) {
		restore_uid();
		error("private X11 dir: mkdtemp %s failed: %s",
		    xauthfile, strerror(errno));
		xfree(xauthfile);
		xauthfile = NULL;
		xfree(s->auth_proto);
		xfree(s->auth_data);
		/* XXXX remove listening channels */
		return 0;
	}
	strlcat(xauthfile, "/cookies", MAXPATHLEN);
	fd = open(xauthfile, O_RDWR|O_CREAT|O_EXCL, 0600);
	if (fd >= 0)
		close(fd);
	restore_uid();
	fatal_add_cleanup(xauthfile_cleanup_proc, s->pw);
	return 1;
d1571 4
d1647 48
@


1.79
log
@use fatal_register_cleanup instead of atexit, sync with x11 authdir handling
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.78 2001/05/31 10:30:16 markus Exp $");
d97 1
a97 1
void	xauthfile_cleanup_proc(void *ignore);
d160 1
a160 1
		xauthfile_cleanup_proc(NULL);
d162 1
a162 1
		auth_sock_cleanup_proc(NULL);
d169 1
a169 1
xauthfile_cleanup_proc(void *ignore)
d171 3
a174 1

d176 1
a176 1
		char *p;
d185 1
d362 1
a362 1
			fatal_add_cleanup(xauthfile_cleanup_proc, NULL);
d1439 1
a1439 1
	fatal_add_cleanup(xauthfile_cleanup_proc, s);
@


1.78
log
@undo the .c file split, just merge the header and keep the cvs history
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.77 2001/05/30 12:55:13 markus Exp $");
d97 1
d157 6
a412 3
			/* Cleanup user's local Xauthority file. */
			if (xauthfile)
				xauthfile_cleanup_proc(NULL);
a1729 2
	if (xauthfile)
		xauthfile_cleanup_proc(NULL);
@


1.77
log
@channel layer cleanup: merge header files and split .c files
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.76 2001/05/19 00:36:40 djm Exp $");
d48 1
a48 1
#include "channel.h"
@


1.76
log
@Disable X11 forwarding if xauth binary is not found. Patch from Nalin
Dahyabhai <nalin@@redhat.com>; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.75 2001/05/03 15:45:15 markus Exp $");
d48 1
a48 2
#include "channels.h"
#include "nchan.h"
@


1.75
log
@exec shell -c /bin/sh .ssh/sshrc, from abartlet@@pcug.org.au
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.74 2001/04/17 19:34:25 markus Exp $");
d215 1
d298 2
a299 1
			if (!options.xauth_location) {
d1379 1
d1386 5
@


1.74
log
@move auth_approval to do_authenticated().
do_child(): nuke hostkeys from memory
don't source .ssh/rc for subsystems.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.73 2001/04/16 08:19:31 djm Exp $");
d1056 2
d1059 2
a1060 3
				fprintf(stderr, "Running %s %s\n", _PATH_BSHELL,
				    _PATH_SSH_USER_RC);
			f = popen(_PATH_BSHELL " " _PATH_SSH_USER_RC, "w");
@


1.74.2.1
log
@Pull in patch from current:
Fix (markus):
- use fatal_register_cleanup instead of atexit, sync with x11 authdir handling
- switch uid when cleaning up tmp files and sockets; reported by zen-parse@@gmx.net on bugtraq
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.74 2001/04/17 19:34:25 markus Exp $");
d111 3
d157 1
d159 19
a177 3
	/* remove agent socket */
	if (auth_get_socket_name())
		auth_sock_cleanup_proc(authctxt->pw);
d212 1
a212 1
	int success, type, n_bytes, plen, screen_flag, have_pty = 0;
d333 19
d405 3
d976 2
d1375 1
d1384 5
d1405 20
d1718 2
@


1.74.2.2
log
@Pull in OpenSSH-2.9.9
@
text
@d12 1
a12 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.102 2001/09/16 14:46:54 markus Exp $");
d49 1
d68 1
a68 2
	struct passwd *pw;
	Authctxt *authctxt;
d89 7
a95 9
void	session_set_fds(Session *, int, int, int);
static void	session_pty_cleanup(void *);
void	session_proctitle(Session *);
int	session_setup_x11fwd(Session *);
void	do_exec_pty(Session *, const char *);
void	do_exec_no_pty(Session *, const char *);
void	do_exec(Session *, const char *);
void	do_login(Session *, const char *);
void	do_child(Session *, const char *);
d97 1
a97 1
int	check_quietlogin(Session *, const char *);
d99 2
a100 5
static void do_authenticated1(Authctxt *);
static void do_authenticated2(Authctxt *);

static void session_close(Session *);
static int session_pty_req(Session *);
d112 1
a112 1
const char *original_command = NULL;
d158 21
a178 8
#ifdef KRB4
	if (options.kerberos_ticket_cleanup)
		krb4_cleanup_proc(authctxt);
#endif
#ifdef KRB5
	if (options.kerberos_ticket_cleanup)
		krb5_cleanup_proc(authctxt);
#endif
d187 1
a187 1
static void
d192 1
a192 1
	int success, type, plen, screen_flag;
a196 1
	s->authctxt = authctxt;
d225 45
a269 1
			success = session_pty_req(s);
d273 16
d300 2
d304 2
d308 6
a313 8
			packet_done();
			success = session_setup_x11fwd(s);
			if (!success) {
				xfree(s->auth_proto);
				xfree(s->auth_data);
				s->auth_proto = NULL;
				s->auth_data = NULL;
			}
a342 52
			
#if defined(AFS) || defined(KRB5)
		case SSH_CMSG_HAVE_KERBEROS_TGT:
			if (!options.kerberos_tgt_passing) {
				verbose("Kerberos TGT passing disabled.");
			} else {
				char *kdata = packet_get_string(&dlen);
				packet_integrity_check(plen, 4 + dlen, type);
				
				/* XXX - 0x41, see creds_to_radix version */
				if (kdata[0] != 0x41) {
#ifdef KRB5
					krb5_data tgt;
					tgt.data = kdata;
					tgt.length = dlen;
					
					if (auth_krb5_tgt(s->authctxt, &tgt))
						success = 1;
					else
						verbose("Kerberos v5 TGT refused for %.100s", s->authctxt->user);
#endif /* KRB5 */
				} else {
#ifdef AFS
					if (auth_krb4_tgt(s->authctxt, kdata))
						success = 1;
					else
						verbose("Kerberos v4 TGT refused for %.100s", s->authctxt->user);
#endif /* AFS */
				}
				xfree(kdata);
			}
			break;
#endif /* AFS || KRB5 */
			
#ifdef AFS
		case SSH_CMSG_HAVE_AFS_TOKEN:
			if (!options.afs_token_passing || !k_hasafs()) {
				verbose("AFS token passing disabled.");
			} else {
				/* Accept AFS token. */
				char *token = packet_get_string(&dlen);
				packet_integrity_check(plen, 4 + dlen, type);
				
				if (auth_afs_token(s->authctxt, token))
					success = 1;
				else
					verbose("AFS token refused for %.100s",
					    s->authctxt->user);
				xfree(token);
			}
			break;
#endif /* AFS */
d349 1
a349 2
				do_exec(s, command);
				xfree(command);
d351 2
a352 1
				do_exec(s, NULL);
d354 12
a365 2
			packet_done();
			session_close(s);
a523 1

d526 1
d585 1
a588 22
/*
 * This is called to fork and execute a command.  If another command is
 * to be forced, execute that instead.
 */
void
do_exec(Session *s, const char *command)
{
	if (forced_command) {
		original_command = command;
		command = forced_command;
		debug("Forced command '%.900s'", command);
	}

	if (s->ttyfd != -1)
		do_exec_pty(s, command);
	else
		do_exec_no_pty(s, command);

	original_command = NULL;
}


d675 1
a675 1
	struct passwd *pw = s->pw;
d696 1
a696 1
static void
d737 1
a737 1
static void
d781 1
a781 1
	struct passwd *pw = s->pw;
d790 1
a790 4
	int do_xauth;

	do_xauth =
	    s->display != NULL && s->auth_proto != NULL && s->auth_data != NULL;
d857 12
d924 1
d926 8
a933 9
	if (s->authctxt->krb4_ticket_file)
		child_set_env(&env, &envsize, "KRBTKFILE",
			      s->authctxt->krb4_ticket_file);
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ticket_file)
		child_set_env(&env, &envsize, "KRB5CCNAME",
			      s->authctxt->krb5_ticket_file);
#endif
a1004 12
#ifdef AFS
	/* Try to get AFS tokens for the local cell. */
	if (k_hasafs()) {
		char cell[64];
		
		if (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)
			krb_afslog(cell, 0);
		
		krb_afslog(0, 0);
	}
#endif /* AFS */

a1011 2
			snprintf(cmd, sizeof cmd, "%s -c '%s %s'",
			    shell, _PATH_BSHELL, _PATH_SSH_USER_RC);
d1013 3
a1015 2
				fprintf(stderr, "Running %s\n", cmd);
			f = popen(cmd, "w");
d1092 19
d1129 1
a1129 1
			     "-p", "-f", "--", pw->pw_name, (char *)NULL);
d1159 1
a1170 1
			s->self = i;
d1178 1
a1178 1
static void
d1194 1
a1194 1
session_open(Authctxt *authctxt, int chanid)
d1202 1
a1202 2
	s->authctxt = authctxt;
	s->pw = authctxt->pw;
d1210 1
a1210 1
static Session *
d1226 1
a1226 1
static Session *
d1241 1
a1241 1
static int
d1253 1
a1253 1
static int
d1259 1
a1259 2
	if (no_pty_flag) {
		debug("Allocating a pty not permitted for this authentication.");
d1261 1
a1261 3
	}
	if (s->ttyfd != -1) {
		packet_disconnect("Protocol error: you already have a pty.");
a1262 2
	}

d1264 2
a1265 8

	if (compat20) {
		s->col = packet_get_int();
		s->row = packet_get_int();
	} else {
		s->row = packet_get_int();
		s->col = packet_get_int();
	}
a1272 1

a1273 1
	debug("Allocating pty.");
d1275 1
a1275 2
		if (s->term)
			xfree(s->term);
a1282 6

	/* for SSH1 the tty modes length is not given */
	if (!compat20)
		n_bytes = packet_remaining();
	tty_parse_modes(s->ttyfd, &n_bytes);

d1287 1
a1287 1
	fatal_add_cleanup(session_pty_cleanup, (void *)s);
d1289 1
a1289 2

	/* Set window size from the packet. */
d1292 2
d1295 1
d1297 1
d1301 1
a1301 1
static int
d1316 1
a1316 1
			do_exec(s, options.subsystem_command[i]);
d1328 1
a1328 1
static int
d1331 11
a1341 1
	int success;
d1349 2
a1350 2
	success = session_setup_x11fwd(s);
	if (!success) {
d1353 1
a1353 2
		s->auth_proto = NULL;
		s->auth_data = NULL;
d1355 1
a1355 1
	return success;
d1358 1
a1358 1
static int
d1361 2
d1364 4
a1367 1
	do_exec(s, NULL);
d1371 1
a1371 1
static int
d1377 11
a1387 2
	do_exec(s, command);
	xfree(command);
d1391 1
a1391 1
static int
d1480 2
a1481 6
/*
 * Function to perform pty cleanup. Also called if we get aborted abnormally
 * (e.g., due to a dropped connection).
 */
static void
session_pty_cleanup(void *session)
d1483 1
a1483 7
	Session *s = session;

	if (s == NULL) {
		error("session_pty_cleanup: no session");
		return;
	}
	if (s->ttyfd == -1)
d1488 3
d1492 1
a1492 2
	if (s->pid != 0)
		record_logout(s->pid, s->tty);
d1506 1
a1506 1
static void
d1514 1
a1514 1
		fatal("session_exit_message: session %d: no channel %d",
d1551 2
a1552 2
static void
session_close(Session *s)
d1554 1
a1554 5
	debug("session_close: session %d pid %d", s->self, s->pid);
	if (s->ttyfd != -1) {
		fatal_remove_cleanup(session_pty_cleanup, (void *)s);
		session_pty_cleanup(s);
	}
d1564 7
d1579 1
a1579 1
		debug("session_close_by_pid: no session for pid %d", pid);
a1586 16
int
session_have_children(void)
{
	int i;

	for(i = 0; i < MAX_SESSIONS; i++) {
		Session *s = &sessions[i];
		if (s->used && s->pid != -1) {
			debug("session_have_children: id %d pid %d", i, s->pid);
			return 1;
		}
	}
	debug("session_have_children: no more children");
	return 0;
}

d1615 1
a1615 1
static char *
d1643 2
a1644 2
int
session_setup_x11fwd(Session *s)
a1645 1
	struct stat st;
d1647 1
a1647 34
	if (no_x11_forwarding_flag) {
		packet_send_debug("X11 forwarding disabled in user configuration file.");
		return 0;
	}
	if (!options.x11_forwarding) {
		debug("X11 forwarding disabled in server configuration file.");
		return 0;
	}
	if (!options.xauth_location ||
	    (stat(options.xauth_location, &st) == -1)) {
		packet_send_debug("No xauth program; cannot forward with spoofing.");
		return 0;
	}
	if (options.use_login) {
		packet_send_debug("X11 forwarding disabled; "
		    "not compatible with UseLogin=yes.");
		return 0;
	}
	if (s->display != NULL) {
		debug("X11 display already set.");
		return 0;
	}
	s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
	if (s->display == NULL) {
		debug("x11_create_display_inet failed.");
		return 0;
	}
	return 1;
}

static void
do_authenticated2(Authctxt *authctxt)
{
	server_loop2(authctxt);
@


1.74.2.3
log
@Merge OpenSSH 3.0
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.74.2.2 2001/09/27 19:03:55 jason Exp $");
d506 11
a516 7
		/* Redirect stdin/stdout/stderr from the pseudo tty. */
		if (dup2(ttyfd, 0) < 0)
			error("dup2 stdin: %s", strerror(errno));
		if (dup2(ttyfd, 1) < 0)
			error("dup2 stdout: %s", strerror(errno));
		if (dup2(ttyfd, 2) < 0)
			error("dup2 stderr: %s", strerror(errno));
d974 10
a1001 10
	/* Change current directory to the user\'s home directory. */
	if (chdir(pw->pw_dir) < 0) {
		fprintf(stderr, "Could not chdir to home directory %s: %s\n",
		    pw->pw_dir, strerror(errno));
#ifdef HAVE_LOGIN_CAP
		if (login_getcapbool(lc, "requirehome", 0))
			exit(1);
#endif
	}

a1300 1
	struct stat st;
d1303 1
a1303 1
	char *cmd, *subsys = packet_get_string(&len);
d1310 2
a1311 8
		if (strcmp(subsys, options.subsystem_name[i]) == 0) {
			cmd = options.subsystem_command[i];
			if (stat(cmd, &st) < 0) {
				error("subsystem: cannot stat %s: %s", cmd,
				    strerror(errno));
				break;
			}
			debug("subsystem: exec() %s", cmd);
d1313 1
a1313 1
			do_exec(s, cmd);
d1319 1
a1319 2
		log("subsystem request for %s failed, subsystem not found",
		    subsys);
a1485 3

	/* unlink pty from session */
	s->ttyfd = -1;
d1566 16
d1591 1
a1591 1
		debug("session_close_by_channel: no session for id %d", id);
d1594 1
a1594 14
	debug("session_close_by_channel: channel %d child %d", id, s->pid);
	if (s->pid != 0) {
		debug("session_close_by_channel: channel %d: has child", id);
		/*
		 * delay detach of session, but release pty, since
		 * the fd's to the child are already closed
		 */
		if (s->ttyfd != -1) {
			fatal_remove_cleanup(session_pty_cleanup, (void *)s);
			session_pty_cleanup(s);
		}
		return;
	}
	/* detach by removing callback */
a1596 2
	session_close(s);
}
d1598 9
a1606 8
void
session_destroy_all(void)
{
	int i;
	for(i = 0; i < MAX_SESSIONS; i++) {
		Session *s = &sessions[i];
		if (s->used) 
			session_close(s);
@


1.74.2.4
log
@Upgrade OpenSSH to version 3.0.2.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.74.2.3 2001/11/15 00:15:19 miod Exp $");
d878 8
a885 14
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *s = ce->s;
			int i;
			for (i = 0; s[i] != '=' && s[i]; i++)
				;
			if (s[i] == '=') {
				s[i] = 0;
				child_set_env(&env, &envsize, s, s + i + 1);
			}
			custom_environment = ce->next;
			xfree(ce->s);
			xfree(ce);
d887 3
@


1.74.2.5
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.128 2002/02/16 00:51:44 markus Exp $");
a75 1
	int	display_number;
a77 1
	char	*auth_display;
d184 1
a184 1
	int success, type, screen_flag;
d200 1
a200 1
		type = packet_read();
d205 1
a206 1
			packet_check_eom();
d209 1
a209 1
				    compression_level);
d237 1
a237 1
			packet_check_eom();
d274 1
a274 1

d281 2
a282 2
				packet_check_eom();

d289 1
a289 1

d307 1
a307 1

d315 2
a316 2
				packet_check_eom();

d337 1
a337 1
			packet_check_eom();
d599 1
a599 1
		    (struct sockaddr *) & from, &fromlen) < 0) {
d614 1
a614 1
	    get_remote_name_or_ip(utmp_len, options.verify_reverse_mapping),
d688 1
a688 1
	const char *value)
d729 1
a729 1
	const char *filename)
d762 7
a768 2
static char **
do_setup_env(Session *s, const char *shell)
d770 2
d773 3
a775 1
	u_int i, envsize;
d777 72
a848 1
	struct passwd *pw = s->pw;
d882 1
a882 1

d896 1
a896 1
	    get_remote_ipaddr(), get_remote_port(), get_local_port());
d911 1
a911 1
		    s->authctxt->krb4_ticket_file);
d916 1
a916 1
		    s->authctxt->krb5_ticket_file);
d920 1
a920 1
		    auth_get_socket_name());
a933 168
	return env;
}

/*
 * Run $HOME/.ssh/rc, /etc/sshrc, or xauth (whichever is found
 * first in this order).
 */
static void
do_rc_files(Session *s, const char *shell)
{
	FILE *f = NULL;
	char cmd[1024];
	int do_xauth;
	struct stat st;

	do_xauth =
	    s->display != NULL && s->auth_proto != NULL && s->auth_data != NULL;

	/* ignore _PATH_SSH_USER_RC for subsystems */
	if (!s->is_subsystem && (stat(_PATH_SSH_USER_RC, &st) >= 0)) {
		snprintf(cmd, sizeof cmd, "%s -c '%s %s'",
		    shell, _PATH_BSHELL, _PATH_SSH_USER_RC);
		if (debug_flag)
			fprintf(stderr, "Running %s\n", cmd);
		f = popen(cmd, "w");
		if (f) {
			if (do_xauth)
				fprintf(f, "%s %s\n", s->auth_proto,
				    s->auth_data);
			pclose(f);
		} else
			fprintf(stderr, "Could not run %s\n",
			    _PATH_SSH_USER_RC);
	} else if (stat(_PATH_SSH_SYSTEM_RC, &st) >= 0) {
		if (debug_flag)
			fprintf(stderr, "Running %s %s\n", _PATH_BSHELL,
			    _PATH_SSH_SYSTEM_RC);
		f = popen(_PATH_BSHELL " " _PATH_SSH_SYSTEM_RC, "w");
		if (f) {
			if (do_xauth)
				fprintf(f, "%s %s\n", s->auth_proto,
				    s->auth_data);
			pclose(f);
		} else
			fprintf(stderr, "Could not run %s\n",
			    _PATH_SSH_SYSTEM_RC);
	} else if (do_xauth && options.xauth_location != NULL) {
		/* Add authority data to .Xauthority if appropriate. */
		if (debug_flag) {
			fprintf(stderr,
			    "Running %.100s add "
			    "%.100s %.100s %.100s\n",
			    options.xauth_location, s->auth_display,
			    s->auth_proto, s->auth_data);
		}
		snprintf(cmd, sizeof cmd, "%s -q -",
		    options.xauth_location);
		f = popen(cmd, "w");
		if (f) {
			fprintf(f, "add %s %s %s\n",
			    s->auth_display, s->auth_proto,
			    s->auth_data);
			pclose(f);
		} else {
			fprintf(stderr, "Could not run %s\n",
			    cmd);
		}
	}
}

static void
do_nologin(struct passwd *pw)
{
	FILE *f = NULL;
	char buf[1024];

#ifdef HAVE_LOGIN_CAP
	if (!login_getcapbool(lc, "ignorenologin", 0) && pw->pw_uid)
		f = fopen(login_getcapstr(lc, "nologin", _PATH_NOLOGIN,
		    _PATH_NOLOGIN), "r");
#else
	if (pw->pw_uid)
		f = fopen(_PATH_NOLOGIN, "r");
#endif
	if (f) {
		/* /etc/nologin exists.  Print its contents and exit. */
		while (fgets(buf, sizeof(buf), f))
			fputs(buf, stderr);
		fclose(f);
		exit(254);
	}
}

/* Set login name, uid, gid, and groups. */
static void
do_setusercontext(struct passwd *pw)
{
	if (getuid() == 0 || geteuid() == 0) {
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid,
		    (LOGIN_SETALL & ~LOGIN_SETPATH)) < 0) {
			perror("unable to set user context");
			exit(1);
		}
#else
		if (setlogin(pw->pw_name) < 0)
			error("setlogin failed: %s", strerror(errno));
		if (setgid(pw->pw_gid) < 0) {
			perror("setgid");
			exit(1);
		}
		/* Initialize the group list. */
		if (initgroups(pw->pw_name, pw->pw_gid) < 0) {
			perror("initgroups");
			exit(1);
		}
		endgrent();

		/* Permanently switch to the desired uid. */
		permanently_set_uid(pw);
#endif
	}
	if (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)
		fatal("Failed to set uids to %u.", (u_int) pw->pw_uid);
}

/*
 * Performs common processing for the child, such as setting up the
 * environment, closing extra file descriptors, setting the user and group
 * ids, and executing the command or shell.
 */
void
do_child(Session *s, const char *command)
{
	extern char **environ;
	char **env;
	char *argv[10];
	const char *shell, *shell0, *hostname = NULL;
	struct passwd *pw = s->pw;
	u_int i;

	/* remove hostkey from the child's memory */
	destroy_sensitive_data();

	/* login(1) is only called if we execute the login shell */
	if (options.use_login && command != NULL)
		options.use_login = 0;

	/*
	 * Login(1) does this as well, and it needs uid 0 for the "-h"
	 * switch, so we let login(1) to this for us.
	 */
	if (!options.use_login) {
		do_nologin(pw);
		do_setusercontext(pw);
	}

	/*
	 * Get the shell from the password data.  An empty shell field is
	 * legal, and means /bin/sh.
	 */
	shell = (pw->pw_shell[0] == '\0') ? _PATH_BSHELL : pw->pw_shell;
#ifdef HAVE_LOGIN_CAP
	shell = login_getcapstr(lc, "shell", (char *)shell, (char *)shell);
#endif

	env = do_setup_env(s, shell);

d937 1
a937 1
		    options.verify_reverse_mapping);
d974 2
a975 2
	 * Must take new environment into use so that .ssh/rc,
	 * /etc/sshrc and xauth are run in the proper environment.
d983 1
a983 1

d986 1
a986 1

d1001 75
a1075 2
	if (!options.use_login)
		do_rc_files(s, shell);
a1079 18
	if (options.use_login) {
		/* Launch login(1). */

		execl("/usr/bin/login", "login", "-h", hostname,
		    "-p", "-f", "--", pw->pw_name, (char *)NULL);

		/* Login couldn't be executed, die. */

		perror("login");
		exit(1);
	}

	/* Get the last component of the shell name. */
	if ((shell0 = strrchr(shell, '/')) != NULL)
		shell0++;
	else
		shell0 = shell;

d1086 2
a1087 1
		char argv0[256];
d1089 9
a1097 2
		/* Start the shell.  Set initial character to '-'. */
		argv0[0] = '-';
d1099 1
a1099 3
		if (strlcpy(argv0 + 1, shell0, sizeof(argv0) - 1)
		    >= sizeof(argv0) - 1) {
			errno = EINVAL;
d1102 11
a1113 9

		/* Execute the shell. */
		argv[0] = argv0;
		argv[1] = NULL;
		execve(shell, argv, env);

		/* Executing the shell failed. */
		perror(shell);
		exit(1);
d1119 1
a1119 1
	argv[0] = (char *) shell0;
d1135 1
a1135 1
		for (i = 0; i < MAX_SESSIONS; i++) {
d1140 1
a1140 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1160 1
a1160 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1193 1
a1193 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1210 1
a1210 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1227 1
a1227 1
	packet_check_eom();
d1292 1
a1292 1
	packet_check_eom();
d1306 2
a1307 2
	packet_check_eom();
	log("subsystem request for %.100s", subsys);
a1320 1
			break;
d1325 1
a1325 1
		log("subsystem request for %.100s failed, subsystem not found",
d1341 1
a1341 1
	packet_check_eom();
d1356 1
a1356 1
	packet_check_eom();
d1366 1
a1366 1
	packet_check_eom();
d1376 1
a1376 1
	packet_check_eom();
d1389 2
a1390 2
int
session_input_channel_req(Channel *c, const char *rtype)
d1392 2
d1395 1
d1397 4
d1402 9
a1410 6
	if ((s = session_by_channel(c->self)) == NULL) {
		log("session_input_channel_req: no session %d req %.100s",
		    c->self, rtype);
		return 0;
	}
	debug("session_input_channel_req: session %d req %s", s->self, rtype);
d1434 8
a1441 1
	return success;
d1458 1
a1458 2
	    1,
	    CHAN_SES_WINDOW_DEFAULT);
d1502 4
a1505 2

	if ((c = channel_lookup(s->chanid)) == NULL)
d1512 2
a1513 1
		channel_request_start(s->chanid, "exit-status", 0);
d1517 2
a1518 1
		channel_request_start(s->chanid, "exit-signal", 0);
a1554 2
	if (s->auth_display)
		xfree(s->auth_display);
d1611 1
a1611 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1613 1
a1613 1
		if (s->used)
d1624 1
a1624 1
	for (i = 0; i < MAX_SESSIONS; i++) {
a1649 2
	char display[512], auth_display[512];
	char hostname[MAXHOSTNAMELEN];
d1673 2
a1674 3
	s->display_number = x11_create_display_inet(options.x11_display_offset,
	    options.x11_use_localhost, s->single_connection);
	if (s->display_number == -1) {
a1677 23

	/* Set up a suitable value for the DISPLAY variable. */
	if (gethostname(hostname, sizeof(hostname)) < 0)
		fatal("gethostname: %.100s", strerror(errno));
	/*
	 * auth_display must be used as the displayname when the
	 * authorization entry is added with xauth(1).  This will be
	 * different than the DISPLAY string for localhost displays.
	 */
	if (options.x11_use_localhost) {
		snprintf(display, sizeof display, "localhost:%d.%d",
		    s->display_number, s->screen);
		snprintf(auth_display, sizeof auth_display, "unix:%d.%d",
		    s->display_number, s->screen);
		s->display = xstrdup(display);
		s->auth_display = xstrdup(auth_display);
	} else {
		snprintf(display, sizeof display, "%.400s:%d.%d", hostname,
		    s->display_number, s->screen);
		s->display = xstrdup(display);
		s->auth_display = xstrdup(display);
	}

@


1.74.2.6
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.134 2002/03/29 18:59:31 markus Exp $");
d59 28
a86 1
#include "monitor_wrap.h"
d92 1
a92 1
void	session_pty_cleanup(void *);
d106 1
d126 1
a126 1
login_cap_t *lc;
d141 12
d586 1
d589 1
d607 7
d615 3
a617 5
	if (!use_privsep)
		record_login(pid, s->tty, pw->pw_name, pw->pw_uid,
		    get_remote_name_or_ip(utmp_len,
		    options.verify_reverse_mapping),
		    (struct sockaddr *)&from);
d622 2
a623 2
	if (options.print_lastlog && s->last_login_time != 0) {
		time_string = ctime(&s->last_login_time);
d626 1
a626 1
		if (strcmp(s->hostname, "") == 0)
d629 1
a629 2
			printf("Last login: %s from %s\r\n", time_string,
			    s->hostname);
d950 1
a950 1
void
a981 14
static void
launch_login(struct passwd *pw, const char *hostname)
{
	/* Launch login(1). */

	execl("/usr/bin/login", "login", "-h", hostname,
	    "-p", "-f", "--", pw->pw_name, (char *)NULL);

	/* Login couldn't be executed, die. */

	perror("login");
	exit(1);
}

d1098 9
a1106 2
		launch_login(pw, hostname);
		/* NEVERREACHED */
a1215 16
Session *
session_by_tty(char *tty)
{
	int i;
	for (i = 0; i < MAX_SESSIONS; i++) {
		Session *s = &sessions[i];
		if (s->used && s->ttyfd != -1 && strcmp(s->tty, tty) == 0) {
			debug("session_by_tty: session %d tty %s", i, tty);
			return s;
		}
	}
	debug("session_by_tty: unknown tty %.100s", tty);
	session_dump();
	return NULL;
}

a1272 6
	/* Get the time and hostname when the user last logged in. */
	if (options.print_lastlog) {
		s->hostname[0] = '\0';
		s->last_login_time = get_last_login_time(s->pw->pw_uid,
		    s->pw->pw_name, s->hostname, sizeof(s->hostname));
	}
d1293 1
a1293 1
	if (!PRIVSEP(pty_allocate(&s->ptyfd, &s->ttyfd, s->tty, sizeof(s->tty)))) {
d1314 1
a1314 2
	if (!use_privsep)
		pty_setowner(s->pw, s->tty);
d1477 2
a1478 2
void
session_pty_cleanup2(void *session)
d1496 1
a1496 2
	if (getuid() == 0)
		pty_release(s->tty);
d1504 1
a1504 1
		error("close(s->ptymaster/%d): %s", s->ptymaster, strerror(errno));
a1509 6
void
session_pty_cleanup(void *session)
{
	PRIVSEP(session_pty_cleanup2(session));
}

d1551 1
a1551 1
void
d1618 1
a1618 1
session_destroy_all(void (*closefunc)(Session *))
d1623 2
a1624 6
		if (s->used) {
			if (closefunc != NULL)
				closefunc(s);
			else
				session_close(s);
		}
@


1.73
log
@Split motd and hushlogin checks into seperate functions, helps for portable.
From Chris Adams <cmadams@@hiwaay.net>; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.72 2001/04/14 16:33:20 stevesk Exp $");
a107 1

d109 1
d142 6
d834 3
a868 7
#ifdef BSD_AUTH
			if (auth_approval(NULL, lc, pw->pw_name, "ssh") <= 0) {
				error("approval failure for %s", pw->pw_name);
				fprintf(stderr, "Approval failure");
				exit(1);
			}
#endif
d1054 2
a1055 1
		if (stat(_PATH_SSH_USER_RC, &st) >= 0) {
@


1.72
log
@protocol 2 tty modes support; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.71 2001/04/06 21:00:12 markus Exp $");
d96 2
a628 1
	FILE *f;
a629 1
	char buf[256];
a632 1
	struct stat st;
d663 1
a663 9
	/* Done if .hushlogin exists or a command given. */
	if (command != NULL)
		return;
	snprintf(buf, sizeof(buf), "%.200s/.hushlogin", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
	if (login_getcapbool(lc, "hushlogin", 0) || stat(buf, &st) >= 0)
#else
	if (stat(buf, &st) >= 0)
#endif
d665 1
d675 13
d701 25
@


1.71
log
@do gid/groups-swap in addition to uid-swap, should help if /home/group
is chmod 750 + chgrp grp /home/group/, work be deraadt and me, thanks
to olar@@openwall.com is comments.  we had many requests for this.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.70 2001/04/05 15:48:18 stevesk Exp $");
d1268 1
a1268 1
	char *term_modes;	/* encoded terminal modes */
a1278 2
	term_modes = packet_get_string(&len);
	packet_done();
a1290 1
		xfree(term_modes);
d1303 4
a1308 2
	/* XXX parse and set terminal modes */
	xfree(term_modes);
@


1.70
log
@move get_remote_name_or_ip() to canohost.[ch]; for portable.  ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.69 2001/03/25 13:16:11 stevesk Exp $");
d328 1
a328 1
			temporarily_use_uid(s->pw->pw_uid);
d852 1
a852 1
			permanently_set_uid(pw->pw_uid);
d1375 1
a1375 1
	temporarily_use_uid(s->pw->pw_uid);
@


1.69
log
@PrintLastLog option; from chip@@valinux.com with some minor
changes by me.  ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.68 2001/03/25 00:01:34 djm Exp $");
a622 11
const char *
get_remote_name_or_ip(void)
{
	static const char *remote = "";
	if (utmp_len > 0)
		remote = get_canonical_hostname(options.reverse_mapping_check);
	if (utmp_len == 0 || strlen(remote) > utmp_len)
		remote = get_remote_ipaddr();
	return remote;
}

d661 2
a662 1
	    get_remote_name_or_ip(), (struct sockaddr *)&from);
d964 2
a965 1
		hostname = get_remote_name_or_ip();
@


1.68
log
@shorten; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.67 2001/03/23 14:28:32 markus Exp $");
d664 5
a668 3
	hostname[0] = '\0';
	last_login_time = get_last_login_time(pw->pw_uid, pw->pw_name,
	    hostname, sizeof(hostname));
d684 1
a684 1
	if (last_login_time != 0) {
@


1.67
log
@ignore SIGPIPE, restore in child, fixes x11-fwd crashes; with djm@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.66 2001/03/21 21:06:30 markus Exp $");
d1184 1
a1184 2
			s->pid = 0;
			s->is_subsystem = 0;
a1187 7
			s->tty[0] = '\0';                                                       
			s->term = NULL;
			s->pw = NULL;
			s->display = NULL;
			s->screen = 0;
			s->auth_data = NULL;
			s->auth_proto = NULL;
a1188 1
			s->pw = NULL;
@


1.66
log
@missing init; from mib@@unimelb.edu.au
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.65 2001/03/21 11:43:44 markus Exp $");
d1097 4
@


1.65
log
@merge common ssh v1/2 code
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.64 2001/03/20 19:35:29 markus Exp $");
d1185 1
@


1.64
log
@rename
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.63 2001/03/20 19:21:21 markus Exp $");
d97 3
d123 28
d200 1
a200 1
do_authenticated(struct passwd * pw)
d203 2
a204 1
	int type, fd;
a205 4
	int have_pty = 0;
	char *command;
	int n_bytes;
	int plen;
a206 11
	int screen_flag;

	/*
	 * Cancel the alarm we set to limit the time taken for
	 * authentication.
	 */
	alarm(0);
	if (startup_pipe != -1) {
		close(startup_pipe);
		startup_pipe = -1;
	}
d209 1
a209 11
	s->pw = pw;

	if (!no_port_forwarding_flag && options.allow_tcp_forwarding)
		channel_permit_all_opens();

#ifdef HAVE_LOGIN_CAP
	if ((lc = login_getclass(pw->pw_class)) == NULL) {
		error("unable to get login class");
		return;
	}
#endif
d216 1
a216 1
		int success = 0;
d253 1
a253 1
			pty_setowner(pw, s->tty);
d328 1
a328 1
			temporarily_use_uid(pw->pw_uid);
d353 1
a353 1
			success = auth_input_request_forwarding(pw);
d366 1
a366 1
			channel_input_port_forward_request(pw->pw_uid == 0, options.gateway_ports);
d1695 1
a1695 17
	/*
	 * Cancel the alarm we set to limit the time taken for
	 * authentication.
	 */
	alarm(0);
	if (startup_pipe != -1) {
		close(startup_pipe);
		startup_pipe = -1;
	}
	if (!no_port_forwarding_flag && options.allow_tcp_forwarding)
		channel_permit_all_opens();
#ifdef HAVE_LOGIN_CAP
	if ((lc = login_getclass(authctxt->pw->pw_class)) == NULL) {
		error("unable to get login class");
		return;
	}
#endif
@


1.63
log
@remove unused arg
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.62 2001/03/20 18:57:04 markus Exp $");
a67 1
	int	extended;
d83 1
d508 1
a508 1
		session_set_fds(s, pin[1], pout[0], s->extended ? perr[0] : -1);
d512 1
a512 1
		/* server_loop has closed pin[1], pout[1], and perr[1]. */
d524 1
a524 1
		session_set_fds(s, inout[1], inout[1], s->extended ? err[1] : -1);
d1174 1
a1174 1
			s->extended = 0;
d1331 1
a1405 1
	s->extended = 1;
a1423 1
	s->extended = 1;
d1474 2
a1475 2
	 * a session is in LARVAL state until a shell
	 * or programm is executed
@


1.62
log
@add changes need for BSD_AUTH plus disabled BSD_AUTH code
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.61 2001/03/16 19:06:30 markus Exp $");
d92 2
a93 2
void	do_exec_pty(Session *s, const char *command, struct passwd * pw);
void	do_exec_no_pty(Session *s, const char *command, struct passwd * pw);
d384 1
a384 1
				do_exec_pty(s, command, pw);
d386 1
a386 1
				do_exec_no_pty(s, command, pw);
d420 1
a420 1
do_exec_no_pty(Session *s, const char *command, struct passwd * pw)
d539 1
a539 1
do_exec_pty(Session *s, const char *command, struct passwd * pw)
d1331 1
a1331 1
			do_exec_no_pty(s, options.subsystem_command[i], s->pw);
d1407 1
a1407 1
		do_exec_no_pty(s, shell, s->pw);
d1409 1
a1409 1
		do_exec_pty(s, shell, s->pw);
d1426 1
a1426 1
		do_exec_no_pty(s, command, s->pw);
d1428 1
a1428 1
		do_exec_pty(s, command, s->pw);
@


1.61
log
@implement "permitopen" key option, restricts -L style forwarding to
to specified host:port pairs. based on work by harlan@@genua.de
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.60 2001/03/15 22:07:08 markus Exp $");
a60 4
#ifdef HAVE_LOGIN_CAP
#include <login_cap.h>
#endif

a829 1

d831 7
@


1.60
log
@pass Session to do_child + KNF
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.59 2001/03/04 01:46:30 djm Exp $");
d195 3
a197 7
	/*
	 * Inform the channel mechanism that we are the server side and that
	 * the client may request to connect to any port at all. (The user
	 * could do it anyway, and we wouldn\'t know what is permitted except
	 * by the client telling us, so we can equally well trust the client
	 * not to request anything bogus.)
	 */
a200 3
	s = session_new();
	s->pw = pw;

d1696 2
@


1.59
log
@Rename pty.[ch] -> sshpty.[ch] and login.[ch] to sshlogin.[ch] to avoid
header conflicts in portable; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.58 2001/03/02 18:54:31 deraadt Exp $");
d99 1
a99 5

void
do_child(const char *command, struct passwd * pw, const char *term,
    const char *display, const char *auth_proto,
    const char *auth_data, const char *ttyname);
d504 1
a504 1
		do_child(command, pw, NULL, s->display, s->auth_proto, s->auth_data, NULL);
d591 1
a591 2
		do_child(command, pw, s->term, s->display, s->auth_proto,
		    s->auth_data, s->tty);
d796 1
a796 3
do_child(const char *command, struct passwd * pw, const char *term,
	 const char *display, const char *auth_proto,
	 const char *auth_data, const char *ttyname)
d799 1
d808 1
d931 6
a936 6
	if (ttyname)
		child_set_env(&env, &envsize, "SSH_TTY", ttyname);
	if (term)
		child_set_env(&env, &envsize, "TERM", term);
	if (display)
		child_set_env(&env, &envsize, "DISPLAY", display);
d1029 2
a1030 2
				fprintf(stderr, "Running %s %s\n", _PATH_BSHELL, _PATH_SSH_USER_RC);

d1033 3
a1035 2
				if (auth_proto != NULL && auth_data != NULL)
					fprintf(f, "%s %s\n", auth_proto, auth_data);
d1038 2
a1039 1
				fprintf(stderr, "Could not run %s\n", _PATH_SSH_USER_RC);
d1042 2
a1043 2
				fprintf(stderr, "Running %s %s\n", _PATH_BSHELL, _PATH_SSH_SYSTEM_RC);

d1046 3
a1048 2
				if (auth_proto != NULL && auth_data != NULL)
					fprintf(f, "%s %s\n", auth_proto, auth_data);
d1051 3
a1053 2
				fprintf(stderr, "Could not run %s\n", _PATH_SSH_SYSTEM_RC);
		} else if (options.xauth_location != NULL) {
d1055 9
a1063 3
			if (auth_proto != NULL && auth_data != NULL) {
				char *screen = strchr(display, ':');
				if (debug_flag) {
d1065 21
a1085 24
					    "Running %.100s add %.100s %.100s %.100s\n",
					    options.xauth_location, display,
					    auth_proto, auth_data);
					if (screen != NULL)
						fprintf(stderr,
						    "Adding %.*s/unix%s %s %s\n",
						    (int)(screen-display), display,
						    screen, auth_proto, auth_data);
				}
				snprintf(cmd, sizeof cmd, "%s -q -",
				    options.xauth_location);
				f = popen(cmd, "w");
				if (f) {
					fprintf(f, "add %s %s %s\n", display,
					    auth_proto, auth_data);
					if (screen != NULL)
						fprintf(f, "add %.*s/unix%s %s %s\n",
						    (int)(screen-display), display,
						    screen, auth_proto, auth_data);
					pclose(f);
				} else {
					fprintf(stderr, "Could not run %s\n",
					    cmd);
				}
d1108 1
a1108 1
			if (ttyname && options.check_mail) {
d1111 1
@


1.58
log
@make copyright lines the same format
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.57 2001/02/23 15:37:45 markus Exp $");
d42 1
a42 1
#include "pty.h"
d56 1
a56 1
#include "login.h"
@


1.57
log
@handle SSH_PROTOFLAG_SCREEN_NUMBER for buggy clients
@
text
@d12 1
a12 1
 * Copyright (c) 2000 Markus Friedl. All rights reserved.
d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.56 2001/02/16 14:03:43 markus Exp $");
@


1.56
log
@proper payload-length check for x11 w/o screen-number
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.55 2001/02/08 19:30:52 itojun Exp $");
d187 1
d312 8
a319 2
			if (packet_get_protocol_flags() & SSH_PROTOFLAG_SCREEN_NUMBER) {
				debug2("SSH_PROTOFLAG_SCREEN_NUMBER == true");
a323 1
				debug2("SSH_PROTOFLAG_SCREEN_NUMBER == false");
@


1.55
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.54 2001/02/08 17:11:23 stevesk Exp $");
a309 1
			packet_integrity_check(plen, 4 + proto_len + 4 + data_len + 4, type);
d311 4
a314 1
			if (packet_get_protocol_flags() & SSH_PROTOFLAG_SCREEN_NUMBER)
d316 4
a319 1
			else
d321 1
@


1.54
log
@%i -> %d
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.53 2001/02/04 15:32:25 stevesk Exp $");
d59 1
@


1.53
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.52 2001/02/03 10:08:37 markus Exp $");
d1208 1
a1208 1
		fatal("no user for session %i", s->self);
d1518 1
a1518 1
	debug("session_pty_cleanup: session %i release %s", s->self, s->tty);
@


1.52
log
@make ReverseMappingCheck optional in sshd_config; ok djm@@,dugsong@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.51 2001/01/21 19:05:56 markus Exp $");
d117 1
a117 1
char *original_command = NULL; 
d833 1
a833 1
				
d1062 1
a1062 1
					if (screen != NULL) 
@


1.51
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.50 2001/01/19 15:55:11 markus Exp $");
d624 1
a624 1
		remote = get_canonical_hostname();
@


1.50
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.49 2001/01/18 17:00:00 markus Exp $");
d38 3
a41 1
#include "ssh.h"
a45 1
#include "servconf.h"
a49 1

a50 2
#include "ssh1.h"
#include "ssh2.h"
d54 5
@


1.49
log
@1) removes fake skey from sshd, since this will be much
   harder with /usr/libexec/auth/login_XXX
2) share/unify code used in ssh-1 and ssh-2 authentication (server side)
3) make addition of BSD_AUTH and other challenge reponse methods
   easier.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.48 2001/01/13 18:43:31 markus Exp $");
d51 1
d55 1
d1016 1
a1016 1
		if (stat(SSH_USER_RC, &st) >= 0) {
d1018 1
a1018 1
				fprintf(stderr, "Running %s %s\n", _PATH_BSHELL, SSH_USER_RC);
d1020 1
a1020 1
			f = popen(_PATH_BSHELL " " SSH_USER_RC, "w");
d1026 2
a1027 2
				fprintf(stderr, "Could not run %s\n", SSH_USER_RC);
		} else if (stat(SSH_SYSTEM_RC, &st) >= 0) {
d1029 1
a1029 1
				fprintf(stderr, "Running %s %s\n", _PATH_BSHELL, SSH_SYSTEM_RC);
d1031 1
a1031 1
			f = popen(_PATH_BSHELL " " SSH_SYSTEM_RC, "w");
d1037 1
a1037 1
				fprintf(stderr, "Could not run %s\n", SSH_SYSTEM_RC);
@


1.48
log
@Wall
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.47 2001/01/13 18:32:50 markus Exp $");
d1671 1
a1671 1
do_authenticated2(void)
a1672 2
	struct passwd *pw;

d1683 1
a1683 2
	pw = auth_get_user();
	if ((lc = login_getclass(pw->pw_class)) == NULL) {
@


1.47
log
@split out keepalive from packet_interactive (from dale@@accentre.com)
set IPTOS_LOWDELAY TCP_NODELAY IPTOS_THROUGHPUT for ssh2, too.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.46 2001/01/04 22:41:03 markus Exp $");
d497 1
a497 1
	packet_set_interactive(s->display);
@


1.46
log
@consistent use of _PATH_BSHELL; from stevesk@@pobox.com
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.45 2000/12/19 23:17:58 markus Exp $");
a366 4
			/* Set interactive/non-interactive mode. */
			packet_set_interactive(have_pty || s->display != NULL,
			    options.keepalives);

d496 2
d604 1
@


1.45
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.44 2000/11/14 23:44:19 markus Exp $");
d1017 1
a1017 1
				fprintf(stderr, "Running /bin/sh %s\n", SSH_USER_RC);
d1019 1
a1019 1
			f = popen("/bin/sh " SSH_USER_RC, "w");
d1028 1
a1028 1
				fprintf(stderr, "Running /bin/sh %s\n", SSH_SYSTEM_RC);
d1030 1
a1030 1
			f = popen("/bin/sh " SSH_SYSTEM_RC, "w");
@


1.44
log
@check no_agent_forwarding_flag for ssh-2, too
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.43 2000/11/06 23:04:56 markus Exp $");
d104 1
a104 1
extern unsigned int utmp_len;
d180 1
a180 1
	unsigned int proto_len, data_len, dlen;
d703 1
a703 1
child_set_env(char ***envp, unsigned int *envsizep, const char *name,
d706 1
a706 1
	unsigned int i, namelen;
d744 1
a744 1
read_environment_file(char ***env, unsigned int *envsize,
d792 1
a792 1
	unsigned int envsize, i;
d1256 1
a1256 1
	unsigned int len;
d1305 1
a1305 1
	unsigned int len;
d1401 1
a1401 1
	unsigned int len;
d1439 1
a1439 1
	unsigned int len;
@


1.43
log
@agent forwarding and -R for ssh2, based on work from jhuuskon@@messi.uku.fi
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.42 2000/10/27 07:32:18 markus Exp $");
d1424 4
@


1.42
log
@enable non-blocking IO on channels, and tty's (except for the client ttys).
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.41 2000/10/18 18:42:00 markus Exp $");
d1419 13
d1468 2
@


1.42.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.56 2001/02/16 14:03:43 markus Exp $");
d38 1
a39 3
#include "ssh1.h"
#include "ssh2.h"
#include "xmalloc.h"
d44 1
d49 1
d51 1
a53 7
#include "pathnames.h"
#include "log.h"
#include "servconf.h"
#include "login.h"
#include "serverloop.h"
#include "canohost.h"
#include "session.h"
d104 1
a104 1
extern u_int utmp_len;
d112 1
a112 1
char *original_command = NULL;
d180 1
a180 1
	u_int proto_len, data_len, dlen;
d304 1
d306 1
a306 4
			if (packet_get_protocol_flags() & SSH_PROTOFLAG_SCREEN_NUMBER) {
				debug2("SSH_PROTOFLAG_SCREEN_NUMBER == true");
				packet_integrity_check(plen,
				    4 + proto_len + 4 + data_len + 4, type);
d308 1
a308 4
			} else {
				debug2("SSH_PROTOFLAG_SCREEN_NUMBER == false");
				packet_integrity_check(plen,
				    4 + proto_len + 4 + data_len, type);
a309 1
			}
d367 4
a499 2
	/* Set interactive/non-interactive mode. */
	packet_set_interactive(s->display != NULL);
a605 1
	packet_set_interactive(1);
d620 1
a620 1
		remote = get_canonical_hostname(options.reverse_mapping_check);
d703 1
a703 1
child_set_env(char ***envp, u_int *envsizep, const char *name,
d706 1
a706 1
	u_int i, namelen;
d744 1
a744 1
read_environment_file(char ***env, u_int *envsize,
d792 1
a792 1
	u_int envsize, i;
d829 1
a829 1

d1015 1
a1015 1
		if (stat(_PATH_SSH_USER_RC, &st) >= 0) {
d1017 1
a1017 1
				fprintf(stderr, "Running %s %s\n", _PATH_BSHELL, _PATH_SSH_USER_RC);
d1019 1
a1019 1
			f = popen(_PATH_BSHELL " " _PATH_SSH_USER_RC, "w");
d1025 2
a1026 2
				fprintf(stderr, "Could not run %s\n", _PATH_SSH_USER_RC);
		} else if (stat(_PATH_SSH_SYSTEM_RC, &st) >= 0) {
d1028 1
a1028 1
				fprintf(stderr, "Running %s %s\n", _PATH_BSHELL, _PATH_SSH_SYSTEM_RC);
d1030 1
a1030 1
			f = popen(_PATH_BSHELL " " _PATH_SSH_SYSTEM_RC, "w");
d1036 1
a1036 1
				fprintf(stderr, "Could not run %s\n", _PATH_SSH_SYSTEM_RC);
d1058 1
a1058 1
					if (screen != NULL)
d1204 1
a1204 1
		fatal("no user for session %d", s->self);
d1256 1
a1256 1
	u_int len;
d1305 1
a1305 1
	u_int len;
d1401 1
a1401 1
	u_int len;
a1418 17
int
session_auth_agent_req(Session *s)
{
	static int called = 0;
	packet_done();
	if (no_agent_forwarding_flag) {
		debug("session_auth_agent_req: no_agent_forwarding_flag");
		return 0;
	}
	if (called) {
		return 0;
	} else {
		called = 1;
		return auth_input_request_forwarding(s->pw);
	}
}

d1422 1
a1422 1
	u_int len;
a1454 2
		} else if (strcmp(rtype, "auth-agent-req@@openssh.com") == 0) {
			success = session_auth_agent_req(s);
d1495 1
a1495 1
	debug("session_pty_cleanup: session %d release %s", s->self, s->tty);
d1653 1
a1653 1
do_authenticated2(Authctxt *authctxt)
d1655 2
d1667 2
a1668 1
	if ((lc = login_getclass(authctxt->pw->pw_class)) == NULL) {
@


1.42.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.42.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d12 1
a12 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.61 2001/03/16 19:06:30 markus Exp $");
d42 1
a42 1
#include "sshpty.h"
d56 1
a56 1
#include "sshlogin.h"
d99 5
a103 1
void	do_child(Session *s, const char *command);
a186 1
	int screen_flag;
d198 10
a210 3
	if (!no_port_forwarding_flag && options.allow_tcp_forwarding)
		channel_permit_all_opens();

d311 2
a312 8
			screen_flag = packet_get_protocol_flags() &
			    SSH_PROTOFLAG_SCREEN_NUMBER;
			debug2("SSH_PROTOFLAG_SCREEN_NUMBER: %d", screen_flag);

			if (packet_remaining() == 4) {
				if (!screen_flag)
					debug2("Buggy client: "
					    "X11 screen flag missing");
d317 1
d502 1
a502 1
		do_child(s, command);
d589 2
a590 1
		do_child(s, command);
d795 3
a797 1
do_child(Session *s, const char *command)
a799 1
	struct passwd * pw = s->pw;
a807 1
	int do_xauth = s->auth_proto != NULL && s->auth_data != NULL;
d930 6
a935 6
	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, "SSH_TTY", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, "TERM", s->term);
	if (s->display)
		child_set_env(&env, &envsize, "DISPLAY", s->display);
d1028 2
a1029 2
				fprintf(stderr, "Running %s %s\n", _PATH_BSHELL,
				    _PATH_SSH_USER_RC);
d1032 2
a1033 3
				if (do_xauth)
					fprintf(f, "%s %s\n", s->auth_proto,
					    s->auth_data);
d1036 1
a1036 2
				fprintf(stderr, "Could not run %s\n",
				    _PATH_SSH_USER_RC);
d1039 2
a1040 2
				fprintf(stderr, "Running %s %s\n", _PATH_BSHELL,
				    _PATH_SSH_SYSTEM_RC);
d1043 2
a1044 3
				if (do_xauth)
					fprintf(f, "%s %s\n", s->auth_proto,
					    s->auth_data);
d1047 2
a1048 3
				fprintf(stderr, "Could not run %s\n",
				    _PATH_SSH_SYSTEM_RC);
		} else if (do_xauth && options.xauth_location != NULL) {
d1050 3
a1052 9
			char *screen = strchr(s->display, ':');

			if (debug_flag) {
				fprintf(stderr,
				    "Running %.100s add "
				    "%.100s %.100s %.100s\n",
				    options.xauth_location, s->display,
				    s->auth_proto, s->auth_data);
				if (screen != NULL)
d1054 24
a1077 21
					    "Adding %.*s/unix%s %s %s\n",
					    (int)(screen - s->display),
					    s->display, screen,
					    s->auth_proto, s->auth_data);
			}
			snprintf(cmd, sizeof cmd, "%s -q -",
			    options.xauth_location);
			f = popen(cmd, "w");
			if (f) {
				fprintf(f, "add %s %s %s\n", s->display,
				    s->auth_proto, s->auth_data);
				if (screen != NULL)
					fprintf(f, "add %.*s/unix%s %s %s\n",
					    (int)(screen - s->display),
					    s->display, screen,
					    s->auth_proto,
					    s->auth_data);
				pclose(f);
			} else {
				fprintf(stderr, "Could not run %s\n",
				    cmd);
d1100 1
a1100 1
			if (s->ttyfd != -1 && options.check_mail) {
a1102 1

a1693 2
	if (!no_port_forwarding_flag && options.allow_tcp_forwarding)
		channel_permit_all_opens();
@


1.42.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.74 2001/04/17 19:34:25 markus Exp $");
d61 4
d72 1
a87 1
	int	is_subsystem;
d96 2
a97 2
void	do_exec_pty(Session *s, const char *command);
void	do_exec_no_pty(Session *s, const char *command);
a99 5
void	do_motd(void);
int	check_quietlogin(Session *s, const char *command);

void	do_authenticated1(Authctxt *authctxt);
void	do_authenticated2(Authctxt *authctxt);
d107 1
a108 1
extern void destroy_sensitive_data(void);
a123 34
void
do_authenticated(Authctxt *authctxt)
{
	/*
	 * Cancel the alarm we set to limit the time taken for
	 * authentication.
	 */
	alarm(0);
	if (startup_pipe != -1) {
		close(startup_pipe);
		startup_pipe = -1;
	}
#ifdef HAVE_LOGIN_CAP
	if ((lc = login_getclass(authctxt->pw->pw_class)) == NULL) {
		error("unable to get login class");
		return;
	}
#ifdef BSD_AUTH
	if (auth_approval(NULL, lc, authctxt->pw->pw_name, "ssh") <= 0) {
		packet_disconnect("Approval failure for %s",
		    authctxt->pw->pw_name);
	}
#endif
#endif
	/* setup the channel layer */
	if (!no_port_forwarding_flag && options.allow_tcp_forwarding)
		channel_permit_all_opens();

	if (compat20)
		do_authenticated2(authctxt);
	else
		do_authenticated1(authctxt);
}

d173 1
a173 1
do_authenticated1(Authctxt *authctxt)
d176 3
d180 2
a181 2
	int success, type, fd, n_bytes, plen, screen_flag, have_pty = 0;
	int compression_level = 0, enable_compression_after_reply = 0;
d183 11
d196 11
a206 1
	s->pw = authctxt->pw;
d213 1
a213 1
		success = 0;
d250 1
a250 1
			pty_setowner(s->pw, s->tty);
d325 1
a325 1
			temporarily_use_uid(s->pw);
d350 1
a350 1
			success = auth_input_request_forwarding(s->pw);
d363 1
a363 1
			channel_input_port_forward_request(s->pw->pw_uid == 0, options.gateway_ports);
d388 1
a388 1
				do_exec_pty(s, command);
d390 1
a390 1
				do_exec_no_pty(s, command);
d424 1
a424 1
do_exec_no_pty(Session *s, const char *command)
d512 1
a512 1
		session_set_fds(s, pin[1], pout[0], s->is_subsystem ? -1 : perr[0]);
d516 1
a516 1
		/* server_loop has closed pin[1], pout[0], and perr[0]. */
d528 1
a528 1
		session_set_fds(s, inout[1], inout[1], s->is_subsystem ? -1 : err[1]);
d543 1
a543 1
do_exec_pty(Session *s, const char *command)
d620 11
d635 1
d637 1
d641 1
d661 3
a663 5
	if (options.print_lastlog) {
		hostname[0] = '\0';
		last_login_time = get_last_login_time(pw->pw_uid, pw->pw_name,
		    hostname, sizeof(hostname));
	}
d667 1
a667 2
	    get_remote_name_or_ip(utmp_len, options.reverse_mapping_check),
	    (struct sockaddr *)&from);
d669 9
a677 1
	if (check_quietlogin(s, command))
d679 1
a679 2

	if (options.print_lastlog && last_login_time != 0) {
a687 13

	do_motd();
}

/*
 * Display the message of the day.
 */
void
do_motd(void)
{
	FILE *f;
	char buf[256];

a702 25

/*
 * Check for quiet login, either .hushlogin or command given.
 */
int
check_quietlogin(Session *s, const char *command)
{
	char buf[256];
	struct passwd * pw = s->pw;
	struct stat st;

	/* Return 1 if .hushlogin exists or a command given. */
	if (command != NULL)
		return 1;
	snprintf(buf, sizeof(buf), "%.200s/.hushlogin", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
	if (login_getcapbool(lc, "hushlogin", 0) || stat(buf, &st) >= 0)
		return 1;
#else
	if (stat(buf, &st) >= 0)
		return 1;
#endif
	return 0;
}

a802 3
	/* remove hostkey from the child's memory */
	destroy_sensitive_data();

d834 1
d851 1
a851 1
			permanently_set_uid(pw);
d963 1
a963 2
		hostname = get_remote_name_or_ip(utmp_len,
		    options.reverse_mapping_check);
d1020 1
a1020 2
		/* ignore _PATH_SSH_USER_RC for subsystems */
		if (!s->is_subsystem && (stat(_PATH_SSH_USER_RC, &st) >= 0)) {
a1087 4

	/* restore SIGPIPE for child */
	signal(SIGPIPE,  SIG_DFL);

d1171 2
a1172 1
			memset(s, 0, sizeof(*s));
d1176 6
d1183 1
d1270 1
a1270 1
	int n_bytes;
d1281 2
d1295 1
a1307 4
	/* Get tty modes from the packet. */
	tty_parse_modes(s->ttyfd, &n_bytes);
	packet_done();

d1310 2
d1329 1
a1329 2
			s->is_subsystem = 1;
			do_exec_no_pty(s, options.subsystem_command[i]);
d1376 1
a1376 1
	temporarily_use_uid(s->pw);
d1403 1
d1405 1
a1405 1
		do_exec_no_pty(s, shell);
d1407 1
a1407 1
		do_exec_pty(s, shell);
d1422 1
d1424 1
a1424 1
		do_exec_no_pty(s, command);
d1426 1
a1426 1
		do_exec_pty(s, command);
d1473 2
a1474 2
	 * a session is in LARVAL state until a shell, a command
	 * or a subsystem is executed
d1687 17
a1703 1

@


1.42.2.5
log
@Pull in patch from current:
Errata:
sshd(8) allows users to delete arbitrary files named "cookies" if
X11 forwarding is enabled. X11 forwarding is disabled by default.
Fix (markus):
- use fatal_register_cleanup instead of atexit, sync with x11 authdir
  handling
- switch uid when cleaning up tmp files and sockets; reported by
  zen-parse@@gmx.net on bugtraq
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.42.2.4 2001/05/07 21:09:33 jason Exp $");
d111 3
d157 1
d159 19
a177 3
	/* remove agent socket */
	if (auth_get_socket_name())
		auth_sock_cleanup_proc(authctxt->pw);
d212 1
a212 1
	int success, type, n_bytes, plen, screen_flag, have_pty = 0;
d333 19
d405 3
d976 2
d1375 1
d1384 5
d1405 20
d1718 2
@


1.42.2.6
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d12 1
a12 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.102 2001/09/16 14:46:54 markus Exp $");
d49 1
d68 1
a68 2
	struct passwd *pw;
	Authctxt *authctxt;
d89 7
a95 9
void	session_set_fds(Session *, int, int, int);
static void	session_pty_cleanup(void *);
void	session_proctitle(Session *);
int	session_setup_x11fwd(Session *);
void	do_exec_pty(Session *, const char *);
void	do_exec_no_pty(Session *, const char *);
void	do_exec(Session *, const char *);
void	do_login(Session *, const char *);
void	do_child(Session *, const char *);
d97 1
a97 1
int	check_quietlogin(Session *, const char *);
d99 2
a100 5
static void do_authenticated1(Authctxt *);
static void do_authenticated2(Authctxt *);

static void session_close(Session *);
static int session_pty_req(Session *);
d112 1
a112 1
const char *original_command = NULL;
d158 21
a178 8
#ifdef KRB4
	if (options.kerberos_ticket_cleanup)
		krb4_cleanup_proc(authctxt);
#endif
#ifdef KRB5
	if (options.kerberos_ticket_cleanup)
		krb5_cleanup_proc(authctxt);
#endif
d187 1
a187 1
static void
d192 1
a192 1
	int success, type, plen, screen_flag;
a196 1
	s->authctxt = authctxt;
d225 45
a269 1
			success = session_pty_req(s);
d273 16
d300 2
d304 2
d308 6
a313 8
			packet_done();
			success = session_setup_x11fwd(s);
			if (!success) {
				xfree(s->auth_proto);
				xfree(s->auth_data);
				s->auth_proto = NULL;
				s->auth_data = NULL;
			}
a342 52
			
#if defined(AFS) || defined(KRB5)
		case SSH_CMSG_HAVE_KERBEROS_TGT:
			if (!options.kerberos_tgt_passing) {
				verbose("Kerberos TGT passing disabled.");
			} else {
				char *kdata = packet_get_string(&dlen);
				packet_integrity_check(plen, 4 + dlen, type);
				
				/* XXX - 0x41, see creds_to_radix version */
				if (kdata[0] != 0x41) {
#ifdef KRB5
					krb5_data tgt;
					tgt.data = kdata;
					tgt.length = dlen;
					
					if (auth_krb5_tgt(s->authctxt, &tgt))
						success = 1;
					else
						verbose("Kerberos v5 TGT refused for %.100s", s->authctxt->user);
#endif /* KRB5 */
				} else {
#ifdef AFS
					if (auth_krb4_tgt(s->authctxt, kdata))
						success = 1;
					else
						verbose("Kerberos v4 TGT refused for %.100s", s->authctxt->user);
#endif /* AFS */
				}
				xfree(kdata);
			}
			break;
#endif /* AFS || KRB5 */
			
#ifdef AFS
		case SSH_CMSG_HAVE_AFS_TOKEN:
			if (!options.afs_token_passing || !k_hasafs()) {
				verbose("AFS token passing disabled.");
			} else {
				/* Accept AFS token. */
				char *token = packet_get_string(&dlen);
				packet_integrity_check(plen, 4 + dlen, type);
				
				if (auth_afs_token(s->authctxt, token))
					success = 1;
				else
					verbose("AFS token refused for %.100s",
					    s->authctxt->user);
				xfree(token);
			}
			break;
#endif /* AFS */
d349 1
a349 2
				do_exec(s, command);
				xfree(command);
d351 2
a352 1
				do_exec(s, NULL);
d354 12
a365 2
			packet_done();
			session_close(s);
a523 1

d526 1
d585 1
a588 22
/*
 * This is called to fork and execute a command.  If another command is
 * to be forced, execute that instead.
 */
void
do_exec(Session *s, const char *command)
{
	if (forced_command) {
		original_command = command;
		command = forced_command;
		debug("Forced command '%.900s'", command);
	}

	if (s->ttyfd != -1)
		do_exec_pty(s, command);
	else
		do_exec_no_pty(s, command);

	original_command = NULL;
}


d675 1
a675 1
	struct passwd *pw = s->pw;
d696 1
a696 1
static void
d737 1
a737 1
static void
d781 1
a781 1
	struct passwd *pw = s->pw;
d790 1
a790 4
	int do_xauth;

	do_xauth =
	    s->display != NULL && s->auth_proto != NULL && s->auth_data != NULL;
d857 12
d924 1
d926 8
a933 9
	if (s->authctxt->krb4_ticket_file)
		child_set_env(&env, &envsize, "KRBTKFILE",
			      s->authctxt->krb4_ticket_file);
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ticket_file)
		child_set_env(&env, &envsize, "KRB5CCNAME",
			      s->authctxt->krb5_ticket_file);
#endif
a1004 12
#ifdef AFS
	/* Try to get AFS tokens for the local cell. */
	if (k_hasafs()) {
		char cell[64];
		
		if (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)
			krb_afslog(cell, 0);
		
		krb_afslog(0, 0);
	}
#endif /* AFS */

a1011 2
			snprintf(cmd, sizeof cmd, "%s -c '%s %s'",
			    shell, _PATH_BSHELL, _PATH_SSH_USER_RC);
d1013 3
a1015 2
				fprintf(stderr, "Running %s\n", cmd);
			f = popen(cmd, "w");
d1092 19
d1129 1
a1129 1
			     "-p", "-f", "--", pw->pw_name, (char *)NULL);
d1159 1
a1170 1
			s->self = i;
d1178 1
a1178 1
static void
d1194 1
a1194 1
session_open(Authctxt *authctxt, int chanid)
d1202 1
a1202 2
	s->authctxt = authctxt;
	s->pw = authctxt->pw;
d1210 1
a1210 1
static Session *
d1226 1
a1226 1
static Session *
d1241 1
a1241 1
static int
d1253 1
a1253 1
static int
d1259 1
a1259 2
	if (no_pty_flag) {
		debug("Allocating a pty not permitted for this authentication.");
d1261 1
a1261 3
	}
	if (s->ttyfd != -1) {
		packet_disconnect("Protocol error: you already have a pty.");
a1262 2
	}

d1264 2
a1265 8

	if (compat20) {
		s->col = packet_get_int();
		s->row = packet_get_int();
	} else {
		s->row = packet_get_int();
		s->col = packet_get_int();
	}
a1272 1

a1273 1
	debug("Allocating pty.");
d1275 1
a1275 2
		if (s->term)
			xfree(s->term);
a1282 6

	/* for SSH1 the tty modes length is not given */
	if (!compat20)
		n_bytes = packet_remaining();
	tty_parse_modes(s->ttyfd, &n_bytes);

d1287 1
a1287 1
	fatal_add_cleanup(session_pty_cleanup, (void *)s);
d1289 1
a1289 2

	/* Set window size from the packet. */
d1292 2
d1295 1
d1297 1
d1301 1
a1301 1
static int
d1316 1
a1316 1
			do_exec(s, options.subsystem_command[i]);
d1328 1
a1328 1
static int
d1331 11
a1341 1
	int success;
d1349 2
a1350 2
	success = session_setup_x11fwd(s);
	if (!success) {
d1353 1
a1353 2
		s->auth_proto = NULL;
		s->auth_data = NULL;
d1355 1
a1355 1
	return success;
d1358 1
a1358 1
static int
d1361 2
d1364 4
a1367 1
	do_exec(s, NULL);
d1371 1
a1371 1
static int
d1377 11
a1387 2
	do_exec(s, command);
	xfree(command);
d1391 1
a1391 1
static int
d1480 2
a1481 6
/*
 * Function to perform pty cleanup. Also called if we get aborted abnormally
 * (e.g., due to a dropped connection).
 */
static void
session_pty_cleanup(void *session)
d1483 1
a1483 7
	Session *s = session;

	if (s == NULL) {
		error("session_pty_cleanup: no session");
		return;
	}
	if (s->ttyfd == -1)
d1488 3
d1492 1
a1492 2
	if (s->pid != 0)
		record_logout(s->pid, s->tty);
d1506 1
a1506 1
static void
d1514 1
a1514 1
		fatal("session_exit_message: session %d: no channel %d",
d1551 2
a1552 2
static void
session_close(Session *s)
d1554 1
a1554 5
	debug("session_close: session %d pid %d", s->self, s->pid);
	if (s->ttyfd != -1) {
		fatal_remove_cleanup(session_pty_cleanup, (void *)s);
		session_pty_cleanup(s);
	}
d1564 7
d1579 1
a1579 1
		debug("session_close_by_pid: no session for pid %d", pid);
a1586 16
int
session_have_children(void)
{
	int i;

	for(i = 0; i < MAX_SESSIONS; i++) {
		Session *s = &sessions[i];
		if (s->used && s->pid != -1) {
			debug("session_have_children: id %d pid %d", i, s->pid);
			return 1;
		}
	}
	debug("session_have_children: no more children");
	return 0;
}

d1615 1
a1615 1
static char *
d1643 2
a1644 2
int
session_setup_x11fwd(Session *s)
a1645 1
	struct stat st;
d1647 1
a1647 34
	if (no_x11_forwarding_flag) {
		packet_send_debug("X11 forwarding disabled in user configuration file.");
		return 0;
	}
	if (!options.x11_forwarding) {
		debug("X11 forwarding disabled in server configuration file.");
		return 0;
	}
	if (!options.xauth_location ||
	    (stat(options.xauth_location, &st) == -1)) {
		packet_send_debug("No xauth program; cannot forward with spoofing.");
		return 0;
	}
	if (options.use_login) {
		packet_send_debug("X11 forwarding disabled; "
		    "not compatible with UseLogin=yes.");
		return 0;
	}
	if (s->display != NULL) {
		debug("X11 display already set.");
		return 0;
	}
	s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
	if (s->display == NULL) {
		debug("x11_create_display_inet failed.");
		return 0;
	}
	return 1;
}

static void
do_authenticated2(Authctxt *authctxt)
{
	server_loop2(authctxt);
@


1.42.2.7
log
@Merge OpenSSH 3.0
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.42.2.6 2001/09/27 00:15:42 miod Exp $");
d506 11
a516 7
		/* Redirect stdin/stdout/stderr from the pseudo tty. */
		if (dup2(ttyfd, 0) < 0)
			error("dup2 stdin: %s", strerror(errno));
		if (dup2(ttyfd, 1) < 0)
			error("dup2 stdout: %s", strerror(errno));
		if (dup2(ttyfd, 2) < 0)
			error("dup2 stderr: %s", strerror(errno));
d974 10
a1001 10
	/* Change current directory to the user\'s home directory. */
	if (chdir(pw->pw_dir) < 0) {
		fprintf(stderr, "Could not chdir to home directory %s: %s\n",
		    pw->pw_dir, strerror(errno));
#ifdef HAVE_LOGIN_CAP
		if (login_getcapbool(lc, "requirehome", 0))
			exit(1);
#endif
	}

a1300 1
	struct stat st;
d1303 1
a1303 1
	char *cmd, *subsys = packet_get_string(&len);
d1310 2
a1311 8
		if (strcmp(subsys, options.subsystem_name[i]) == 0) {
			cmd = options.subsystem_command[i];
			if (stat(cmd, &st) < 0) {
				error("subsystem: cannot stat %s: %s", cmd,
				    strerror(errno));
				break;
			}
			debug("subsystem: exec() %s", cmd);
d1313 1
a1313 1
			do_exec(s, cmd);
d1319 1
a1319 2
		log("subsystem request for %s failed, subsystem not found",
		    subsys);
a1485 3

	/* unlink pty from session */
	s->ttyfd = -1;
d1566 16
d1591 1
a1591 1
		debug("session_close_by_channel: no session for id %d", id);
d1594 1
a1594 14
	debug("session_close_by_channel: channel %d child %d", id, s->pid);
	if (s->pid != 0) {
		debug("session_close_by_channel: channel %d: has child", id);
		/*
		 * delay detach of session, but release pty, since
		 * the fd's to the child are already closed
		 */
		if (s->ttyfd != -1) {
			fatal_remove_cleanup(session_pty_cleanup, (void *)s);
			session_pty_cleanup(s);
		}
		return;
	}
	/* detach by removing callback */
a1596 2
	session_close(s);
}
d1598 9
a1606 8
void
session_destroy_all(void)
{
	int i;
	for(i = 0; i < MAX_SESSIONS; i++) {
		Session *s = &sessions[i];
		if (s->used) 
			session_close(s);
@


1.42.2.8
log
@Merge OpenSSH 3.1.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.128 2002/02/16 00:51:44 markus Exp $");
a75 1
	int	display_number;
a77 1
	char	*auth_display;
d184 1
a184 1
	int success, type, screen_flag;
d200 1
a200 1
		type = packet_read();
d205 1
a206 1
			packet_check_eom();
d209 1
a209 1
				    compression_level);
d237 1
a237 1
			packet_check_eom();
d274 1
a274 1

d281 2
a282 2
				packet_check_eom();

d289 1
a289 1

d307 1
a307 1

d315 2
a316 2
				packet_check_eom();

d337 1
a337 1
			packet_check_eom();
d599 1
a599 1
		    (struct sockaddr *) & from, &fromlen) < 0) {
d614 1
a614 1
	    get_remote_name_or_ip(utmp_len, options.verify_reverse_mapping),
d688 1
a688 1
	const char *value)
d729 1
a729 1
	const char *filename)
d762 7
a768 2
static char **
do_setup_env(Session *s, const char *shell)
d770 2
d773 3
a775 1
	u_int i, envsize;
d777 72
a848 1
	struct passwd *pw = s->pw;
d878 8
a885 14
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *s = ce->s;

			for (i = 0; s[i] != '=' && s[i]; i++)
				;
			if (s[i] == '=') {
				s[i] = 0;
				child_set_env(&env, &envsize, s, s + i + 1);
			}
			custom_environment = ce->next;
			xfree(ce->s);
			xfree(ce);
d887 3
d893 1
a893 1
	    get_remote_ipaddr(), get_remote_port(), get_local_port());
d908 1
a908 1
		    s->authctxt->krb4_ticket_file);
d913 1
a913 1
		    s->authctxt->krb5_ticket_file);
d917 1
a917 1
		    auth_get_socket_name());
a930 168
	return env;
}

/*
 * Run $HOME/.ssh/rc, /etc/sshrc, or xauth (whichever is found
 * first in this order).
 */
static void
do_rc_files(Session *s, const char *shell)
{
	FILE *f = NULL;
	char cmd[1024];
	int do_xauth;
	struct stat st;

	do_xauth =
	    s->display != NULL && s->auth_proto != NULL && s->auth_data != NULL;

	/* ignore _PATH_SSH_USER_RC for subsystems */
	if (!s->is_subsystem && (stat(_PATH_SSH_USER_RC, &st) >= 0)) {
		snprintf(cmd, sizeof cmd, "%s -c '%s %s'",
		    shell, _PATH_BSHELL, _PATH_SSH_USER_RC);
		if (debug_flag)
			fprintf(stderr, "Running %s\n", cmd);
		f = popen(cmd, "w");
		if (f) {
			if (do_xauth)
				fprintf(f, "%s %s\n", s->auth_proto,
				    s->auth_data);
			pclose(f);
		} else
			fprintf(stderr, "Could not run %s\n",
			    _PATH_SSH_USER_RC);
	} else if (stat(_PATH_SSH_SYSTEM_RC, &st) >= 0) {
		if (debug_flag)
			fprintf(stderr, "Running %s %s\n", _PATH_BSHELL,
			    _PATH_SSH_SYSTEM_RC);
		f = popen(_PATH_BSHELL " " _PATH_SSH_SYSTEM_RC, "w");
		if (f) {
			if (do_xauth)
				fprintf(f, "%s %s\n", s->auth_proto,
				    s->auth_data);
			pclose(f);
		} else
			fprintf(stderr, "Could not run %s\n",
			    _PATH_SSH_SYSTEM_RC);
	} else if (do_xauth && options.xauth_location != NULL) {
		/* Add authority data to .Xauthority if appropriate. */
		if (debug_flag) {
			fprintf(stderr,
			    "Running %.100s add "
			    "%.100s %.100s %.100s\n",
			    options.xauth_location, s->auth_display,
			    s->auth_proto, s->auth_data);
		}
		snprintf(cmd, sizeof cmd, "%s -q -",
		    options.xauth_location);
		f = popen(cmd, "w");
		if (f) {
			fprintf(f, "add %s %s %s\n",
			    s->auth_display, s->auth_proto,
			    s->auth_data);
			pclose(f);
		} else {
			fprintf(stderr, "Could not run %s\n",
			    cmd);
		}
	}
}

static void
do_nologin(struct passwd *pw)
{
	FILE *f = NULL;
	char buf[1024];

#ifdef HAVE_LOGIN_CAP
	if (!login_getcapbool(lc, "ignorenologin", 0) && pw->pw_uid)
		f = fopen(login_getcapstr(lc, "nologin", _PATH_NOLOGIN,
		    _PATH_NOLOGIN), "r");
#else
	if (pw->pw_uid)
		f = fopen(_PATH_NOLOGIN, "r");
#endif
	if (f) {
		/* /etc/nologin exists.  Print its contents and exit. */
		while (fgets(buf, sizeof(buf), f))
			fputs(buf, stderr);
		fclose(f);
		exit(254);
	}
}

/* Set login name, uid, gid, and groups. */
static void
do_setusercontext(struct passwd *pw)
{
	if (getuid() == 0 || geteuid() == 0) {
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid,
		    (LOGIN_SETALL & ~LOGIN_SETPATH)) < 0) {
			perror("unable to set user context");
			exit(1);
		}
#else
		if (setlogin(pw->pw_name) < 0)
			error("setlogin failed: %s", strerror(errno));
		if (setgid(pw->pw_gid) < 0) {
			perror("setgid");
			exit(1);
		}
		/* Initialize the group list. */
		if (initgroups(pw->pw_name, pw->pw_gid) < 0) {
			perror("initgroups");
			exit(1);
		}
		endgrent();

		/* Permanently switch to the desired uid. */
		permanently_set_uid(pw);
#endif
	}
	if (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)
		fatal("Failed to set uids to %u.", (u_int) pw->pw_uid);
}

/*
 * Performs common processing for the child, such as setting up the
 * environment, closing extra file descriptors, setting the user and group
 * ids, and executing the command or shell.
 */
void
do_child(Session *s, const char *command)
{
	extern char **environ;
	char **env;
	char *argv[10];
	const char *shell, *shell0, *hostname = NULL;
	struct passwd *pw = s->pw;
	u_int i;

	/* remove hostkey from the child's memory */
	destroy_sensitive_data();

	/* login(1) is only called if we execute the login shell */
	if (options.use_login && command != NULL)
		options.use_login = 0;

	/*
	 * Login(1) does this as well, and it needs uid 0 for the "-h"
	 * switch, so we let login(1) to this for us.
	 */
	if (!options.use_login) {
		do_nologin(pw);
		do_setusercontext(pw);
	}

	/*
	 * Get the shell from the password data.  An empty shell field is
	 * legal, and means /bin/sh.
	 */
	shell = (pw->pw_shell[0] == '\0') ? _PATH_BSHELL : pw->pw_shell;
#ifdef HAVE_LOGIN_CAP
	shell = login_getcapstr(lc, "shell", (char *)shell, (char *)shell);
#endif

	env = do_setup_env(s, shell);

d934 1
a934 1
		    options.verify_reverse_mapping);
d971 2
a972 2
	 * Must take new environment into use so that .ssh/rc,
	 * /etc/sshrc and xauth are run in the proper environment.
d980 1
a980 1

d983 1
a983 1

d998 75
a1072 2
	if (!options.use_login)
		do_rc_files(s, shell);
a1076 18
	if (options.use_login) {
		/* Launch login(1). */

		execl("/usr/bin/login", "login", "-h", hostname,
		    "-p", "-f", "--", pw->pw_name, (char *)NULL);

		/* Login couldn't be executed, die. */

		perror("login");
		exit(1);
	}

	/* Get the last component of the shell name. */
	if ((shell0 = strrchr(shell, '/')) != NULL)
		shell0++;
	else
		shell0 = shell;

d1083 2
a1084 1
		char argv0[256];
d1086 9
a1094 2
		/* Start the shell.  Set initial character to '-'. */
		argv0[0] = '-';
d1096 1
a1096 3
		if (strlcpy(argv0 + 1, shell0, sizeof(argv0) - 1)
		    >= sizeof(argv0) - 1) {
			errno = EINVAL;
d1099 11
a1110 9

		/* Execute the shell. */
		argv[0] = argv0;
		argv[1] = NULL;
		execve(shell, argv, env);

		/* Executing the shell failed. */
		perror(shell);
		exit(1);
d1116 1
a1116 1
	argv[0] = (char *) shell0;
d1132 1
a1132 1
		for (i = 0; i < MAX_SESSIONS; i++) {
d1137 1
a1137 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1157 1
a1157 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1190 1
a1190 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1207 1
a1207 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1224 1
a1224 1
	packet_check_eom();
d1289 1
a1289 1
	packet_check_eom();
d1303 2
a1304 2
	packet_check_eom();
	log("subsystem request for %.100s", subsys);
a1317 1
			break;
d1322 1
a1322 1
		log("subsystem request for %.100s failed, subsystem not found",
d1338 1
a1338 1
	packet_check_eom();
d1353 1
a1353 1
	packet_check_eom();
d1363 1
a1363 1
	packet_check_eom();
d1373 1
a1373 1
	packet_check_eom();
d1386 2
a1387 2
int
session_input_channel_req(Channel *c, const char *rtype)
d1389 2
d1392 1
d1394 1
d1396 12
a1407 6
	if ((s = session_by_channel(c->self)) == NULL) {
		log("session_input_channel_req: no session %d req %.100s",
		    c->self, rtype);
		return 0;
	}
	debug("session_input_channel_req: session %d req %s", s->self, rtype);
d1431 8
a1438 1
	return success;
d1455 1
a1455 2
	    1,
	    CHAN_SES_WINDOW_DEFAULT);
d1499 4
a1502 2

	if ((c = channel_lookup(s->chanid)) == NULL)
d1509 2
a1510 1
		channel_request_start(s->chanid, "exit-status", 0);
d1514 2
a1515 1
		channel_request_start(s->chanid, "exit-signal", 0);
a1551 2
	if (s->auth_display)
		xfree(s->auth_display);
d1608 1
a1608 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1610 1
a1610 1
		if (s->used)
d1621 1
a1621 1
	for (i = 0; i < MAX_SESSIONS; i++) {
a1646 2
	char display[512], auth_display[512];
	char hostname[MAXHOSTNAMELEN];
d1670 2
a1671 3
	s->display_number = x11_create_display_inet(options.x11_display_offset,
	    options.x11_use_localhost, s->single_connection);
	if (s->display_number == -1) {
a1674 23

	/* Set up a suitable value for the DISPLAY variable. */
	if (gethostname(hostname, sizeof(hostname)) < 0)
		fatal("gethostname: %.100s", strerror(errno));
	/*
	 * auth_display must be used as the displayname when the
	 * authorization entry is added with xauth(1).  This will be
	 * different than the DISPLAY string for localhost displays.
	 */
	if (options.x11_use_localhost) {
		snprintf(display, sizeof display, "localhost:%d.%d",
		    s->display_number, s->screen);
		snprintf(auth_display, sizeof auth_display, "unix:%d.%d",
		    s->display_number, s->screen);
		s->display = xstrdup(display);
		s->auth_display = xstrdup(auth_display);
	} else {
		snprintf(display, sizeof display, "%.400s:%d.%d", hostname,
		    s->display_number, s->screen);
		s->display = xstrdup(display);
		s->auth_display = xstrdup(display);
	}

@


1.41
log
@restore old record login behaviour
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.40 2000/10/15 14:14:01 markus Exp $");
d1485 2
a1486 1
	    fderr == -1 ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ);
@


1.40
log
@typos; from stevesk@@sweden.hp.com
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.39 2000/10/14 12:12:09 markus Exp $");
d92 1
a92 1
void	do_login(Session *s);
d575 2
a576 2
		if (command == NULL && !options.use_login)
			do_login(s);
d628 1
a628 1
do_login(Session *s)
d664 3
a666 1
	/* Done if .hushlogin exists. */
@


1.39
log
@AllowTcpForwarding; from naddy@@
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.38 2000/10/11 20:27:23 markus Exp $");
d676 1
a676 1
		if (strcmp(buf, "") == 0)
@


1.38
log
@new cipher framework
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.37 2000/09/07 20:27:53 deraadt Exp $");
d199 1
a199 1
	if (!no_port_forwarding_flag)
d349 4
@


1.37
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.36 2000/09/05 08:59:57 markus Exp $");
a42 1
#include "cipher.h"
@


1.36
log
@print hostname (not hushlogin)
@
text
@d4 7
a10 2
 */
/*
d13 20
d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.35 2000/09/04 19:07:21 markus Exp $");
@


1.35
log
@fix get_last_login_time order; from andre@@van-veen.de
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.34 2000/09/04 19:06:03 markus Exp $");
d628 1
d651 1
a651 1
			printf("Last login: %s from %s\r\n", time_string, buf);
@


1.34
log
@set SSH_ORIGINAL_COMMAND; from Leakin@@dfw.nostrum.com, bet@@rahul.net
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.33 2000/09/04 19:03:40 markus Exp $");
d605 1
d627 4
a642 6
	/*
	 * Get the time when the user last logged in.  'buf' will be set
	 * to contain the hostname the last login was from. 
	 */
	last_login_time = get_last_login_time(pw->pw_uid, pw->pw_name,
	    buf, sizeof(buf));
@


1.33
log
@missing close; ok theo
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.33 2000/09/04 18:51:04 markus Exp $");
d87 3
d352 1
d895 3
d1375 1
a1375 1
		xfree(command);
@


1.32
log
@Wall
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.31 2000/08/28 03:50:54 deraadt Exp $");
d147 1
a147 1
	int type;
d302 3
a304 1
			open(xauthfile, O_RDWR|O_CREAT|O_EXCL, 0600);
d1294 1
d1339 3
a1341 1
	open(xauthfile, O_RDWR|O_CREAT|O_EXCL, 0600);
@


1.31
log
@print uid/gid as unsigned
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.30 2000/08/25 16:10:05 deraadt Exp $");
d752 1
a752 1
	const char *shell, *hostname, *cp = NULL;
@


1.30
log
@Wall
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.29 2000/08/21 16:23:31 millert Exp $");
d814 1
a814 1
			fatal("Failed to set uids to %d.", (int) pw->pw_uid);
@


1.29
log
@Fix incorrect PATH setting; noted by Markus.
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.28 2000/08/20 18:42:40 millert Exp $");
d1010 1
a1010 1
						    screen-display, display,
d1021 1
a1021 1
						    screen-display, display,
@


1.28
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.25 2000/08/17 20:06:34 markus Exp $");
d848 2
a849 1
		cp = login_getcapstr(lc, "path", _PATH_STDPATH, _PATH_STDPATH);
d851 1
a851 1
		cp = _PATH_STDPATH;
a852 2
		child_set_env(&env, &envsize, "PATH", cp);
		cp = NULL;
@


1.27
log
@Only check /etc/nologin if "UseLogin no" since login(1) may have its
own policy on determining who is allowed to login when /etc/nologin
is present.  Also use the _PATH_NOLOGIN define.
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.26 2000/08/20 18:25:53 millert Exp $");
d31 4
d91 4
d178 7
d626 3
d630 1
d648 4
d653 1
d767 5
d774 1
d783 1
a783 5
	/* Set login name in the kernel. */
	if (setlogin(pw->pw_name) < 0)
		error("setlogin failed: %s", strerror(errno));

	/* Set uid, gid, and groups. */
d788 10
d811 1
d821 3
d847 7
a853 1
		child_set_env(&env, &envsize, "PATH", _PATH_STDPATH);
d957 1
a957 1
	if (chdir(pw->pw_dir) < 0)
d960 5
d1613 2
d1624 7
@


1.26
log
@We have to stash the result of get_remote_name_or_ip() before we
close our socket or getpeername() will get EBADF and the process
will exit.  Only a problem for "UseLogin yes".
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.25 2000/08/17 20:06:34 markus Exp $");
d731 1
a731 1
	FILE *f;
d742 8
a749 7
	f = fopen("/etc/nologin", "r");
	if (f) {
		/* /etc/nologin exists.  Print its contents and exit. */
		while (fgets(buf, sizeof(buf), f))
			fputs(buf, stderr);
		fclose(f);
		if (pw->pw_uid != 0)
d751 1
@


1.25
log
@sshd -u len, similar to telnetd
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.24 2000/08/17 20:05:10 markus Exp $");
d728 1
a728 1
	const char *shell, *cp = NULL;
d870 3
d1029 1
a1029 2
			execl("/usr/bin/login", "login",
			     "-h", get_remote_name_or_ip(),
@


1.24
log
@cleanup login(1)-like jobs, no duplicate utmp entries
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.23 2000/07/11 08:11:33 deraadt Exp $");
d76 1
d566 11
d604 1
d607 1
a607 2
	    get_canonical_hostname(),
	    (struct sockaddr *)&from);
d1026 3
a1028 2
			execl("/usr/bin/login", "login", "-h", get_remote_ipaddr(),
			      "-p", "-f", "--", pw->pw_name, NULL);
@


1.23
log
@make MaxStartups code still work with -d; djm
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.22 2000/07/05 20:18:07 deraadt Exp $");
d64 1
a489 4
	FILE *f;
	char buf[100], *time_string;
	char line[256];
	const char *hostname;
a490 1
	int quiet_login;
a491 4
	socklen_t fromlen;
	struct sockaddr_storage from;
	struct stat st;
	time_t last_login_time;
a497 12
	/* Get remote host name. */
	hostname = get_canonical_hostname();

	/*
	 * Get the time when the user last logged in.  Buf will be set to
	 * contain the hostname the last login was from.
	 */
	if (!options.use_login) {
		last_login_time = get_last_login_time(pw->pw_uid, pw->pw_name,
						      buf, sizeof(buf));
	}

d500 1
a500 4
		pid = getpid();

		/* Child.  Reinitialize the log because the pid has
		   changed. */
d524 3
a526 22
/* XXXX ? move to do_child() ??*/
		/*
		 * Get IP address of client.  This is needed because we want
		 * to record where the user logged in from.  If the
		 * connection is not a socket, let the ip address be 0.0.0.0.
		 */
		memset(&from, 0, sizeof(from));
		if (packet_connection_is_on_socket()) {
			fromlen = sizeof(from);
			if (getpeername(packet_get_connection_in(),
			     (struct sockaddr *) & from, &fromlen) < 0) {
				debug("getpeername: %.100s", strerror(errno));
				fatal_cleanup();
			}
		}
		/* Record that there was a login on that terminal. */
		record_login(pid, s->tty, pw->pw_name, pw->pw_uid, hostname,
			     (struct sockaddr *)&from);

		/* Check if .hushlogin exists. */
		snprintf(line, sizeof line, "%.200s/.hushlogin", pw->pw_dir);
		quiet_login = stat(line, &st) >= 0;
a527 38
		/*
		 * If the user has logged in before, display the time of last
		 * login. However, don't display anything extra if a command
		 * has been specified (so that ssh can be used to execute
		 * commands on a remote machine without users knowing they
		 * are going to another machine). Login(1) will do this for
		 * us as well, so check if login(1) is used
		 */
		if (command == NULL && last_login_time != 0 && !quiet_login &&
		    !options.use_login) {
			/* Convert the date to a string. */
			time_string = ctime(&last_login_time);
			/* Remove the trailing newline. */
			if (strchr(time_string, '\n'))
				*strchr(time_string, '\n') = 0;
			/* Display the last login time.  Host if displayed
			   if known. */
			if (strcmp(buf, "") == 0)
				printf("Last login: %s\r\n", time_string);
			else
				printf("Last login: %s from %s\r\n", time_string, buf);
		}
		/*
		 * Print /etc/motd unless a command was specified or printing
		 * it was disabled in server options or login(1) will be
		 * used.  Note that some machines appear to print it in
		 * /etc/profile or similar.
		 */
		if (command == NULL && options.print_motd && !quiet_login &&
		    !options.use_login) {
			/* Print /etc/motd if it exists. */
			f = fopen("/etc/motd", "r");
			if (f) {
				while (fgets(line, sizeof(line), f))
					fputs(line, stdout);
				fclose(f);
			}
		}
d562 61
@


1.22
log
@use no_x11_forwarding_flag correctly; provos ok
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.21 2000/06/26 21:59:18 markus Exp $");
d150 4
a153 1
	close(startup_pipe);
d1569 4
a1572 1
	close(startup_pipe);
@


1.21
log
@MaxStartups: limit number of unauthenticated connections, work by theo and me
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.20 2000/06/18 04:42:54 markus Exp $");
d1241 1
a1241 1
	if (!no_port_forwarding_flag) {
@


1.20
log
@typo
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.19 2000/06/18 04:05:02 markus Exp $");
d76 2
d150 1
d1566 1
@


1.19
log
@split auth-rsa option parsing into auth-options
add options support to authorized_keys2
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.18 2000/06/17 22:52:33 jakob Exp $");
d1305 1
@


1.18
log
@add support for ssh v2 subsystems. ok markus@@.
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.17 2000/06/05 19:53:40 markus Exp $");
d29 1
a82 12
/* Flags set in auth-rsa from authorized_keys flags.  These are set in auth-rsa.c. */
int no_port_forwarding_flag = 0;
int no_agent_forwarding_flag = 0;
int no_x11_forwarding_flag = 0;
int no_pty_flag = 0;

/* RSA authentication "command=" option. */
char *forced_command = NULL;

/* RSA authentication "environment=" options. */
struct envstring *custom_environment = NULL;

d1166 2
d1238 4
d1288 34
d1351 1
a1351 7
			packet_done();
			s->extended = 1;
			if (s->ttyfd == -1)
				do_exec_no_pty(s, NULL, s->pw);
			else
				do_exec_pty(s, NULL, s->pw);
			success = 1;
d1353 1
a1353 9
			char *command = packet_get_string(&len);
			packet_done();
			s->extended = 1;
			if (s->ttyfd == -1)
				do_exec_no_pty(s, command, s->pw);
			else
				do_exec_pty(s, command, s->pw);
			xfree(command);
			success = 1;
@


1.17
log
@allow use_login only for login sessions, otherwise remote commands are execed with uid==0
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.16 2000/05/31 06:36:40 markus Exp $");
d1224 1
d1228 11
@


1.16
log
@xauth_location support; pr 1234
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.15 2000/05/30 17:23:37 markus Exp $");
d749 4
@


1.15
log
@don't panic if mkdtemp fails for authfwd; jkb@@yahoo-inc.com via kris@@FreeBSD.org
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.14 2000/05/25 03:10:18 deraadt Exp $");
d251 4
a254 1
#ifdef XAUTH_PATH
a294 4
#else /* XAUTH_PATH */
			packet_send_debug("No xauth program; cannot forward with spoofing.");
			break;
#endif /* XAUTH_PATH */
d742 1
d951 1
a951 3
		}
#ifdef XAUTH_PATH
		else {
d958 2
a959 1
					    XAUTH_PATH, display, auth_proto, auth_data);
d966 3
a968 1
				f = popen(XAUTH_PATH " -q -", "w");
d977 4
a980 3
				} else
					fprintf(stderr, "Could not run %s -q -\n",
					    XAUTH_PATH);
a982 2
#endif /* XAUTH_PATH */

@


1.14
log
@just some line shortening
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.13 2000/05/22 16:51:44 markus Exp $");
d303 1
a303 2
			auth_input_request_forwarding(pw);
			success = 1;
@


1.13
log
@make x11-fwd work w/ localhost (xauth add host/unix:11)
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.12 2000/05/03 18:03:07 markus Exp $");
d616 2
a617 1
		do_child(command, pw, s->term, s->display, s->auth_proto, s->auth_data, s->tty);
d721 4
a724 1
		/* Replace the equals sign by nul, and advance value to the value string. */
d869 2
a870 1
		snprintf(buf, sizeof buf, "%.200s/.ssh/environment", pw->pw_dir);
d959 2
a960 1
					fprintf(stderr, "Running %.100s add %.100s %.100s %.100s\n",
d963 4
a966 2
						fprintf(stderr, "Adding %.*s/unix%s %s %s\n",
						    screen-display, display, screen, auth_proto, auth_data);
d970 2
a971 1
					fprintf(f, "add %s %s %s\n", display, auth_proto, auth_data);
d974 2
a975 1
						     screen-display, display, screen, auth_proto, auth_data);
d978 2
a979 1
					fprintf(stderr, "Could not run %s -q -\n", XAUTH_PATH);
d1009 2
a1010 1
					if (stat(mailbox, &mailstat) != 0 || mailstat.st_size == 0)
@


1.12
log
@GatewayPorts for sshd, ok deraadt@@
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.11 2000/05/02 12:44:38 markus Exp $");
d952 2
a953 1
				if (debug_flag)
d955 5
a959 2
						XAUTH_PATH, display, auth_proto, auth_data);

d963 3
@


1.12.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.17 2000/06/05 19:53:40 markus Exp $");
d251 1
a251 4
			if (!options.xauth_location) {
				packet_send_debug("No xauth program; cannot forward with spoofing.");
				break;
			}
d292 4
d303 2
a304 1
			success = auth_input_request_forwarding(pw);
d616 1
a616 2
		do_child(command, pw, s->term, s->display, s->auth_proto,
		    s->auth_data, s->tty);
d720 1
a720 4
		/*
		 * Replace the equals sign by nul, and advance value to
		 * the value string.
		 */
a739 1
	char cmd[1024];
a746 4
	/* login(1) is only called if we execute the login shell */
	if (options.use_login && command != NULL)
		options.use_login = 0;

d865 1
a865 2
		snprintf(buf, sizeof buf, "%.200s/.ssh/environment",
		    pw->pw_dir);
d947 3
a949 1
		} else if (options.xauth_location != NULL) {
d952 5
a956 15
				char *screen = strchr(display, ':');
				if (debug_flag) {
					fprintf(stderr,
					    "Running %.100s add %.100s %.100s %.100s\n",
					    options.xauth_location, display,
					    auth_proto, auth_data);
					if (screen != NULL)
						fprintf(stderr,
						    "Adding %.*s/unix%s %s %s\n",
						    screen-display, display,
						    screen, auth_proto, auth_data);
				}
				snprintf(cmd, sizeof cmd, "%s -q -",
				    options.xauth_location);
				f = popen(cmd, "w");
d958 1
a958 6
					fprintf(f, "add %s %s %s\n", display,
					    auth_proto, auth_data);
					if (screen != NULL) 
						fprintf(f, "add %.*s/unix%s %s %s\n",
						    screen-display, display,
						    screen, auth_proto, auth_data);
d960 2
a961 4
				} else {
					fprintf(stderr, "Could not run %s\n",
					    cmd);
				}
d964 2
d991 1
a991 2
					if (stat(mailbox, &mailstat) != 0 ||
					    mailstat.st_size == 0)
@


1.12.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.31 2000/08/28 03:50:54 deraadt Exp $");
a28 5
#include "auth-options.h"

#ifdef HAVE_LOGIN_CAP
#include <login_cap.h>
#endif
a62 1
void	do_login(Session *s);
a73 3
extern unsigned int utmp_len;

extern int startup_pipe;
d82 11
a92 3
#ifdef HAVE_LOGIN_CAP
static login_cap_t *lc;
#endif
a158 4
	if (startup_pipe != -1) {
		close(startup_pipe);
		startup_pipe = -1;
	}
a172 7
#ifdef HAVE_LOGIN_CAP
	if ((lc = login_getclass(pw->pw_class)) == NULL) {
		error("unable to get login class");
		return;
	}
#endif

d494 4
d499 1
d501 4
d511 12
d525 4
a528 1
		/* Child.  Reinitialize the log because the pid has changed. */
d552 22
a573 3
		/* record login, etc. similar to login(1) */
		if (command == NULL && !options.use_login)
			do_login(s);
d575 38
a649 81
const char *
get_remote_name_or_ip(void)
{
	static const char *remote = "";
	if (utmp_len > 0)
		remote = get_canonical_hostname();
	if (utmp_len == 0 || strlen(remote) > utmp_len)
		remote = get_remote_ipaddr();
	return remote;
}

/* administrative, login(1)-like work */
void
do_login(Session *s)
{
	FILE *f;
	char *time_string;
	char buf[256];
	socklen_t fromlen;
	struct sockaddr_storage from;
	struct stat st;
	time_t last_login_time;
	struct passwd * pw = s->pw;
	pid_t pid = getpid();

	/*
	 * Get IP address of client. If the connection is not a socket, let
	 * the address be 0.0.0.0.
	 */
	memset(&from, 0, sizeof(from));
	if (packet_connection_is_on_socket()) {
		fromlen = sizeof(from);
		if (getpeername(packet_get_connection_in(),
		     (struct sockaddr *) & from, &fromlen) < 0) {
			debug("getpeername: %.100s", strerror(errno));
			fatal_cleanup();
		}
	}

	/* Record that there was a login on that tty from the remote host. */
	record_login(pid, s->tty, pw->pw_name, pw->pw_uid,
	    get_remote_name_or_ip(), (struct sockaddr *)&from);

	/* Done if .hushlogin exists. */
	snprintf(buf, sizeof(buf), "%.200s/.hushlogin", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
	if (login_getcapbool(lc, "hushlogin", 0) || stat(buf, &st) >= 0)
#else
	if (stat(buf, &st) >= 0)
#endif
		return;
	/*
	 * Get the time when the user last logged in.  'buf' will be set
	 * to contain the hostname the last login was from. 
	 */
	last_login_time = get_last_login_time(pw->pw_uid, pw->pw_name,
	    buf, sizeof(buf));
	if (last_login_time != 0) {
		time_string = ctime(&last_login_time);
		if (strchr(time_string, '\n'))
			*strchr(time_string, '\n') = 0;
		if (strcmp(buf, "") == 0)
			printf("Last login: %s\r\n", time_string);
		else
			printf("Last login: %s from %s\r\n", time_string, buf);
	}
	if (options.print_motd) {
#ifdef HAVE_LOGIN_CAP
		f = fopen(login_getcapstr(lc, "welcome", "/etc/motd",
		    "/etc/motd"), "r");
#else
		f = fopen("/etc/motd", "r");
#endif
		if (f) {
			while (fgets(buf, sizeof(buf), f))
				fputs(buf, stdout);
			fclose(f);
		}
	}
}

d740 1
a740 1
	const char *shell, *hostname, *cp = NULL;
d743 1
a743 1
	FILE *f = NULL;
d754 7
a760 14
	if (!options.use_login) {
#ifdef HAVE_LOGIN_CAP
		if (!login_getcapbool(lc, "ignorenologin", 0) && pw->pw_uid)
			f = fopen(login_getcapstr(lc, "nologin", _PATH_NOLOGIN,
			    _PATH_NOLOGIN), "r");
#else
		if (pw->pw_uid)
			f = fopen(_PATH_NOLOGIN, "r");
#endif
		if (f) {
			/* /etc/nologin exists.  Print its contents and exit. */
			while (fgets(buf, sizeof(buf), f))
				fputs(buf, stderr);
			fclose(f);
a761 1
		}
d763 5
a767 1
	/* Set login name, uid, gid, and groups. */
a771 10
#ifdef HAVE_LOGIN_CAP
			if (setusercontext(lc, pw, pw->pw_uid,
			    (LOGIN_SETALL & ~LOGIN_SETPATH)) < 0) {
				perror("unable to set user context");
				exit(1);
				
			}
#else
			if (setlogin(pw->pw_name) < 0)
				error("setlogin failed: %s", strerror(errno));
a784 1
#endif
d787 1
a787 1
			fatal("Failed to set uids to %u.", (u_int) pw->pw_uid);
a793 3
#ifdef HAVE_LOGIN_CAP
	shell = login_getcapstr(lc, "shell", (char *)shell, (char *)shell);
#endif
a816 4
#ifdef HAVE_LOGIN_CAP
		(void) setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH);
		child_set_env(&env, &envsize, "PATH", getenv("PATH"));
#else
a817 1
#endif
a881 3
	/* we have to stash the hostname before we close our socket. */
	if (options.use_login)
		hostname = get_remote_name_or_ip();
d918 1
a918 1
	if (chdir(pw->pw_dir) < 0) {
a920 5
#ifdef HAVE_LOGIN_CAP
		if (login_getcapbool(lc, "requirehome", 0))
			exit(1);
#endif
	}
d967 1
a967 1
						    (int)(screen-display), display,
d978 1
a978 1
						    (int)(screen-display), display,
d1038 2
a1039 2
			execl("/usr/bin/login", "login", "-h", hostname,
			     "-p", "-f", "--", pw->pw_name, NULL);
a1176 2
	if (no_pty_flag)
		return 0;
a1223 1
	int i;
a1227 11
	for (i = 0; i < options.num_subsystems; i++) {
		if(strcmp(subsys, options.subsystem_name[i]) == 0) {
			debug("subsystem: exec() %s", options.subsystem_command[i]);
			do_exec_no_pty(s, options.subsystem_command[i], s->pw);
			success = 1;
		}
	}

	if (!success)
		log("subsystem request for %s failed, subsystem not found", subsys);

a1234 4
	if (no_x11_forwarding_flag) {
		debug("X11 forwarding disabled in user configuration file.");
		return 0;
	}
a1280 35
int
session_shell_req(Session *s)
{
	/* if forced_command == NULL, the shell is execed */
	char *shell = forced_command;
	packet_done();
	s->extended = 1;
	if (s->ttyfd == -1)
		do_exec_no_pty(s, shell, s->pw);
	else
		do_exec_pty(s, shell, s->pw);
	return 1;
}

int
session_exec_req(Session *s)
{
	unsigned int len;
	char *command = packet_get_string(&len);
	packet_done();
	if (forced_command) {
		xfree(command);
		command = forced_command;
		debug("Forced command '%.500s'", forced_command);
	}
	s->extended = 1;
	if (s->ttyfd == -1)
		do_exec_no_pty(s, command, s->pw);
	else
		do_exec_pty(s, command, s->pw);
	if (forced_command == NULL)
		xfree(command);
	return 1;
}

d1310 7
a1316 1
			success = session_shell_req(s);
d1318 9
a1326 1
			success = session_exec_req(s);
a1529 2
	struct passwd *pw;

a1534 11
	if (startup_pipe != -1) {
		close(startup_pipe);
		startup_pipe = -1;
	}
#ifdef HAVE_LOGIN_CAP
	pw = auth_get_user();
	if ((lc = login_getclass(pw->pw_class)) == NULL) {
		error("unable to get login class");
		return;
	}
#endif
@


1.12.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d4 2
a5 7
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
a7 20
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.42 2000/10/27 07:32:18 markus Exp $");
d18 1
d68 1
a68 1
void	do_login(Session *s, const char *command);
a86 3
/* original command from peer. */
char *original_command = NULL; 

d147 1
a147 1
	int type, fd;
d172 1
a172 1
	if (!no_port_forwarding_flag && options.allow_tcp_forwarding)
d302 1
a302 3
			fd = open(xauthfile, O_RDWR|O_CREAT|O_EXCL, 0600);
			if (fd >= 0)
				close(fd);
a321 4
			if (!options.allow_tcp_forwarding) {
				debug("Port forwarding not permitted.");
				break;
			}
a346 1
				original_command = command;
d541 2
a542 2
		if (!(options.use_login && command == NULL))
			do_login(s, command);
d594 1
a594 1
do_login(Session *s, const char *command)
a598 1
	char hostname[MAXHOSTNAMELEN];
a619 5
	/* Get the time and hostname when the user last logged in. */
	hostname[0] = '\0';
	last_login_time = get_last_login_time(pw->pw_uid, pw->pw_name,
	    hostname, sizeof(hostname));

d624 1
a624 3
	/* Done if .hushlogin exists or a command given. */
	if (command != NULL)
		return;
d632 6
d642 1
a642 1
		if (strcmp(hostname, "") == 0)
d645 1
a645 1
			printf("Last login: %s from %s\r\n", time_string, hostname);
d752 1
a752 1
	const char *shell, *hostname = NULL, *cp = NULL;
a888 3
	if (original_command)
		child_set_env(&env, &envsize, "SSH_ORIGINAL_COMMAND",
		    original_command);
a1291 1
	int fd;
d1336 1
a1336 3
	fd = open(xauthfile, O_RDWR|O_CREAT|O_EXCL, 0600);
	if (fd >= 0)
		close(fd);
d1363 1
a1363 1
		original_command = command;
d1443 1
a1443 2
	    fderr == -1 ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,
	    1);
@


1.12.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.56 2001/02/16 14:03:43 markus Exp $");
d38 1
a39 3
#include "ssh1.h"
#include "ssh2.h"
#include "xmalloc.h"
d44 1
d49 1
d51 1
a53 7
#include "pathnames.h"
#include "log.h"
#include "servconf.h"
#include "login.h"
#include "serverloop.h"
#include "canohost.h"
#include "session.h"
d104 1
a104 1
extern u_int utmp_len;
d112 1
a112 1
char *original_command = NULL;
d180 1
a180 1
	u_int proto_len, data_len, dlen;
d304 1
d306 1
a306 4
			if (packet_get_protocol_flags() & SSH_PROTOFLAG_SCREEN_NUMBER) {
				debug2("SSH_PROTOFLAG_SCREEN_NUMBER == true");
				packet_integrity_check(plen,
				    4 + proto_len + 4 + data_len + 4, type);
d308 1
a308 4
			} else {
				debug2("SSH_PROTOFLAG_SCREEN_NUMBER == false");
				packet_integrity_check(plen,
				    4 + proto_len + 4 + data_len, type);
a309 1
			}
d367 4
a499 2
	/* Set interactive/non-interactive mode. */
	packet_set_interactive(s->display != NULL);
a605 1
	packet_set_interactive(1);
d620 1
a620 1
		remote = get_canonical_hostname(options.reverse_mapping_check);
d703 1
a703 1
child_set_env(char ***envp, u_int *envsizep, const char *name,
d706 1
a706 1
	u_int i, namelen;
d744 1
a744 1
read_environment_file(char ***env, u_int *envsize,
d792 1
a792 1
	u_int envsize, i;
d829 1
a829 1

d1015 1
a1015 1
		if (stat(_PATH_SSH_USER_RC, &st) >= 0) {
d1017 1
a1017 1
				fprintf(stderr, "Running %s %s\n", _PATH_BSHELL, _PATH_SSH_USER_RC);
d1019 1
a1019 1
			f = popen(_PATH_BSHELL " " _PATH_SSH_USER_RC, "w");
d1025 2
a1026 2
				fprintf(stderr, "Could not run %s\n", _PATH_SSH_USER_RC);
		} else if (stat(_PATH_SSH_SYSTEM_RC, &st) >= 0) {
d1028 1
a1028 1
				fprintf(stderr, "Running %s %s\n", _PATH_BSHELL, _PATH_SSH_SYSTEM_RC);
d1030 1
a1030 1
			f = popen(_PATH_BSHELL " " _PATH_SSH_SYSTEM_RC, "w");
d1036 1
a1036 1
				fprintf(stderr, "Could not run %s\n", _PATH_SSH_SYSTEM_RC);
d1058 1
a1058 1
					if (screen != NULL)
d1204 1
a1204 1
		fatal("no user for session %d", s->self);
d1256 1
a1256 1
	u_int len;
d1305 1
a1305 1
	u_int len;
d1401 1
a1401 1
	u_int len;
a1418 17
int
session_auth_agent_req(Session *s)
{
	static int called = 0;
	packet_done();
	if (no_agent_forwarding_flag) {
		debug("session_auth_agent_req: no_agent_forwarding_flag");
		return 0;
	}
	if (called) {
		return 0;
	} else {
		called = 1;
		return auth_input_request_forwarding(s->pw);
	}
}

d1422 1
a1422 1
	u_int len;
a1454 2
		} else if (strcmp(rtype, "auth-agent-req@@openssh.com") == 0) {
			success = session_auth_agent_req(s);
d1495 1
a1495 1
	debug("session_pty_cleanup: session %d release %s", s->self, s->tty);
d1653 1
a1653 1
do_authenticated2(Authctxt *authctxt)
d1655 2
d1667 2
a1668 1
	if ((lc = login_getclass(authctxt->pw->pw_class)) == NULL) {
@


1.12.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d12 1
a12 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.61 2001/03/16 19:06:30 markus Exp $");
d42 1
a42 1
#include "sshpty.h"
d56 1
a56 1
#include "sshlogin.h"
d99 5
a103 1
void	do_child(Session *s, const char *command);
a186 1
	int screen_flag;
d198 10
a210 3
	if (!no_port_forwarding_flag && options.allow_tcp_forwarding)
		channel_permit_all_opens();

d311 2
a312 8
			screen_flag = packet_get_protocol_flags() &
			    SSH_PROTOFLAG_SCREEN_NUMBER;
			debug2("SSH_PROTOFLAG_SCREEN_NUMBER: %d", screen_flag);

			if (packet_remaining() == 4) {
				if (!screen_flag)
					debug2("Buggy client: "
					    "X11 screen flag missing");
d317 1
d502 1
a502 1
		do_child(s, command);
d589 2
a590 1
		do_child(s, command);
d795 3
a797 1
do_child(Session *s, const char *command)
a799 1
	struct passwd * pw = s->pw;
a807 1
	int do_xauth = s->auth_proto != NULL && s->auth_data != NULL;
d930 6
a935 6
	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, "SSH_TTY", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, "TERM", s->term);
	if (s->display)
		child_set_env(&env, &envsize, "DISPLAY", s->display);
d1028 2
a1029 2
				fprintf(stderr, "Running %s %s\n", _PATH_BSHELL,
				    _PATH_SSH_USER_RC);
d1032 2
a1033 3
				if (do_xauth)
					fprintf(f, "%s %s\n", s->auth_proto,
					    s->auth_data);
d1036 1
a1036 2
				fprintf(stderr, "Could not run %s\n",
				    _PATH_SSH_USER_RC);
d1039 2
a1040 2
				fprintf(stderr, "Running %s %s\n", _PATH_BSHELL,
				    _PATH_SSH_SYSTEM_RC);
d1043 2
a1044 3
				if (do_xauth)
					fprintf(f, "%s %s\n", s->auth_proto,
					    s->auth_data);
d1047 2
a1048 3
				fprintf(stderr, "Could not run %s\n",
				    _PATH_SSH_SYSTEM_RC);
		} else if (do_xauth && options.xauth_location != NULL) {
d1050 3
a1052 9
			char *screen = strchr(s->display, ':');

			if (debug_flag) {
				fprintf(stderr,
				    "Running %.100s add "
				    "%.100s %.100s %.100s\n",
				    options.xauth_location, s->display,
				    s->auth_proto, s->auth_data);
				if (screen != NULL)
d1054 24
a1077 21
					    "Adding %.*s/unix%s %s %s\n",
					    (int)(screen - s->display),
					    s->display, screen,
					    s->auth_proto, s->auth_data);
			}
			snprintf(cmd, sizeof cmd, "%s -q -",
			    options.xauth_location);
			f = popen(cmd, "w");
			if (f) {
				fprintf(f, "add %s %s %s\n", s->display,
				    s->auth_proto, s->auth_data);
				if (screen != NULL)
					fprintf(f, "add %.*s/unix%s %s %s\n",
					    (int)(screen - s->display),
					    s->display, screen,
					    s->auth_proto,
					    s->auth_data);
				pclose(f);
			} else {
				fprintf(stderr, "Could not run %s\n",
				    cmd);
d1100 1
a1100 1
			if (s->ttyfd != -1 && options.check_mail) {
a1102 1

a1693 2
	if (!no_port_forwarding_flag && options.allow_tcp_forwarding)
		channel_permit_all_opens();
@


1.11
log
@use c-style comments
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.10 2000/05/02 08:05:32 markus Exp $");
d313 1
a313 1
			channel_input_port_forward_request(pw->pw_uid == 0);
@


1.10
log
@update proctitle for proto 1, too
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.9 2000/05/02 07:32:44 markus Exp $");
d554 1
a554 1
///XXXX ? move to do_child() ??
@


1.9
log
@update proctitle on pty alloc/dealloc, e.g. w/ windows client
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.8 2000/04/29 16:06:08 markus Exp $");
d238 2
@


1.8
log
@don't call chan_write_failed() if we are not writing
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.7 2000/04/28 08:10:20 markus Exp $");
d60 1
d396 1
a396 1
	setproctitle("%s@@notty", pw->pw_name);
a521 1
	setproctitle("%s@@%s", pw->pw_name, strrchr(s->tty, '/') + 1);
d1187 2
d1431 1
d1473 28
@


1.7
log
@support for x11-fwding, client+server
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.33 2000/04/27 13:16:39 markus Exp $");
d1404 2
a1405 1
	chan_write_failed(c);
@


1.6
log
@cleanup logging for sshd/2, respect PasswordAuth no
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.5 2000/04/19 09:24:39 markus Exp $");
d37 1
d50 1
d170 1
d280 1
d460 1
a460 1
		session_set_fds(s, pin[1], pout[0], perr[0]);
d476 1
a476 1
		session_set_fds(s, inout[1], inout[1], err[1]);
d1053 1
d1064 1
d1096 3
a1100 4
	s->pw = auth_get_user();
	if (s->pw == NULL)
		fatal("no user for session %i channel %d",
		    s->self, s->chanid);
d1192 63
d1285 1
d1294 1
d1303 4
d1480 2
@


1.5
log
@remove bogus chan_read_failed. this could cause data
corruption (missing data) at end of a SSH2 session.
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.4 2000/04/14 10:30:33 markus Exp $");
a1404 1
	log("do_authenticated2");
@


1.4
log
@whitespace cleanup
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.3 2000/04/14 10:09:16 markus Exp $");
d1324 6
a1329 2
	if (c->istate == CHAN_INPUT_OPEN)
		chan_read_failed(c);
@


1.3
log
@check payload for (illegal) extra data
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.2 2000/04/06 08:55:22 markus Exp $");
d116 1
a116 1
void 
d139 1
a139 1
void 
d369 1
a369 1
void 
d486 1
a486 1
void 
d649 1
a649 1
void 
d690 1
a690 1
void 
d727 1
a727 1
void 
@


1.2
log
@ssh2 server side, see README.openssh2; enable with 'sshd -2'
@
text
@d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.29 2000/04/04 21:12:40 markus Exp $");
d1137 1
d1146 1
d1149 1
a1149 1
		return -1;
d1155 2
d1169 2
a1170 1
		return -1;
d1182 2
d1216 1
d1224 1
d1232 1
a1232 2
			if (session_pty_req(s) > 0)
				success = 1;
@


1.1
log
@split sshd.c -> auth.c session.c sshd.c plus cleanup and goto-removal
@
text
@d5 4
d11 1
a11 1
RCSID("$OpenBSD: session.c,v 1.26 2000/03/17 16:13:06 markus Exp $");
d26 4
d455 7
a461 3
	/* Enter the interactive session. */
	server_loop(pid, pin[1], pout[0], perr[0]);
	/* server_loop has closed pin[1], pout[1], and perr[1]. */
d471 6
a476 2
	server_loop(pid, inout[1], inout[1], err[1]);
	/* server_loop has closed inout[1] and err[1]. */
d636 7
a642 3
	server_loop(pid, ptyfd, fdout, -1);
	/* server_loop _has_ closed ptyfd and fdout. */
	session_pty_cleanup(s);
d1081 175
d1280 115
@

