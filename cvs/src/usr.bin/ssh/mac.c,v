head	1.34;
access;
symbols
	OPENBSD_6_2:1.34.0.4
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.33.0.6
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.4
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.32.0.6
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.18.0.2
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.2
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.12
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.10
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.6
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.7.0.4
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_8:1.1.0.2;
locks; strict;
comment	@ * @;


1.34
date	2017.05.08.22.57.38;	author djm;	state Exp;
branches;
next	1.33;
commitid	noNsHa38yr7MsUCg;

1.33
date	2016.07.08.03.44.42;	author djm;	state Exp;
branches;
next	1.32;
commitid	oSZWAdBfrLcRSRTm;

1.32
date	2015.01.15.18.32.54;	author naddy;	state Exp;
branches;
next	1.31;
commitid	0eh8R0OXO4eZejE1;

1.31
date	2015.01.13.19.31.40;	author markus;	state Exp;
branches;
next	1.30;
commitid	sCqZ9ho1RfL2Vg0U;

1.30
date	2014.04.30.19.07.48;	author naddy;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2014.02.07.06.55.54;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2014.01.27.18.58.14;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2014.01.04.17.50.55;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2013.11.07.11.58.27;	author dtucker;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.03.00.03.18;	author dtucker;	state Exp;
branches;
next	1.23;

1.23
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2013.04.19.01.06.50;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2012.12.11.22.51.45;	author sthen;	state Exp;
branches;
next	1.20;

1.20
date	2012.12.11.22.31.18;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2012.10.04.13.21.50;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2012.06.28.05.07.45;	author dtucker;	state Exp;
branches;
next	1.17;

1.17
date	2011.12.02.00.43.57;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2011.08.02.01.22.11;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.13.00.51.47;	author dtucker;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.07.19.37.34;	author pvalchev;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.05.06.52.37;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.30.09.58.15;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches
	1.7.2.1
	1.7.4.1;
next	1.6;

1.6
date	2003.09.18.13.02.21;	author miod;	state Exp;
branches
	1.6.4.1
	1.6.6.1;
next	1.5;

1.5
date	2002.05.16.22.02.50;	author markus;	state Exp;
branches
	1.5.4.1
	1.5.6.1;
next	1.4;

1.4
date	2002.01.25.22.07.40;	author markus;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.05.10.42.51;	author markus;	state Exp;
branches
	1.2.2.1
	1.2.4.1;
next	1.1;

1.1
date	2001.02.11.12.59.24;	author markus;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2001.02.16.20.13.05;	author jason;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.02.19.17.19.04;	author jason;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.03.21.19.46.26;	author jason;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.05.07.21.09.30;	author jason;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.1.4.1
date	2001.03.12.15.44.11;	author jason;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.03.21.18.52.51;	author jason;	state Exp;
branches;
next	;

1.2.2.1
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	;

1.2.4.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	;

1.5.4.1
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.5.6.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	;

1.6.4.1
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.6.6.1
date	2005.09.04.18.40.02;	author brad;	state Exp;
branches;
next	;

1.7.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.7.4.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.34
log
@remove hmac-ripemd160; ok dtucker
@
text
@/* $OpenBSD: mac.c,v 1.33 2016/07/08 03:44:42 djm Exp $ */
/*
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>

#include <string.h>
#include <stdio.h>

#include "digest.h"
#include "hmac.h"
#include "umac.h"
#include "mac.h"
#include "misc.h"
#include "ssherr.h"
#include "sshbuf.h"

#define SSH_DIGEST	1	/* SSH_DIGEST_XXX */
#define SSH_UMAC	2	/* UMAC (not integrated with OpenSSL) */
#define SSH_UMAC128	3

struct macalg {
	char		*name;
	int		type;
	int		alg;
	int		truncatebits;	/* truncate digest if != 0 */
	int		key_len;	/* just for UMAC */
	int		len;		/* just for UMAC */
	int		etm;		/* Encrypt-then-MAC */
};

static const struct macalg macs[] = {
	/* Encrypt-and-MAC (encrypt-and-authenticate) variants */
	{ "hmac-sha1",				SSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 0 },
	{ "hmac-sha1-96",			SSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 0 },
	{ "hmac-sha2-256",			SSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 0 },
	{ "hmac-sha2-512",			SSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 0 },
	{ "hmac-md5",				SSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 0 },
	{ "hmac-md5-96",			SSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 0 },
	{ "umac-64@@openssh.com",		SSH_UMAC, 0, 0, 128, 64, 0 },
	{ "umac-128@@openssh.com",		SSH_UMAC128, 0, 0, 128, 128, 0 },

	/* Encrypt-then-MAC variants */
	{ "hmac-sha1-etm@@openssh.com",		SSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 1 },
	{ "hmac-sha1-96-etm@@openssh.com",	SSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 1 },
	{ "hmac-sha2-256-etm@@openssh.com",	SSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 1 },
	{ "hmac-sha2-512-etm@@openssh.com",	SSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 1 },
	{ "hmac-md5-etm@@openssh.com",		SSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 1 },
	{ "hmac-md5-96-etm@@openssh.com",	SSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 1 },
	{ "umac-64-etm@@openssh.com",		SSH_UMAC, 0, 0, 128, 64, 1 },
	{ "umac-128-etm@@openssh.com",		SSH_UMAC128, 0, 0, 128, 128, 1 },

	{ NULL,					0, 0, 0, 0, 0, 0 }
};

/* Returns a list of supported MACs separated by the specified char. */
char *
mac_alg_list(char sep)
{
	char *ret = NULL, *tmp;
	size_t nlen, rlen = 0;
	const struct macalg *m;

	for (m = macs; m->name != NULL; m++) {
		if (ret != NULL)
			ret[rlen++] = sep;
		nlen = strlen(m->name);
		if ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {
			free(ret);
			return NULL;
		}
		ret = tmp;
		memcpy(ret + rlen, m->name, nlen + 1);
		rlen += nlen;
	}
	return ret;
}

static int
mac_setup_by_alg(struct sshmac *mac, const struct macalg *macalg)
{
	mac->type = macalg->type;
	if (mac->type == SSH_DIGEST) {
		if ((mac->hmac_ctx = ssh_hmac_start(macalg->alg)) == NULL)
			return SSH_ERR_ALLOC_FAIL;
		mac->key_len = mac->mac_len = ssh_hmac_bytes(macalg->alg);
	} else {
		mac->mac_len = macalg->len / 8;
		mac->key_len = macalg->key_len / 8;
		mac->umac_ctx = NULL;
	}
	if (macalg->truncatebits != 0)
		mac->mac_len = macalg->truncatebits / 8;
	mac->etm = macalg->etm;
	return 0;
}

int
mac_setup(struct sshmac *mac, char *name)
{
	const struct macalg *m;

	for (m = macs; m->name != NULL; m++) {
		if (strcmp(name, m->name) != 0)
			continue;
		if (mac != NULL)
			return mac_setup_by_alg(mac, m);
		return 0;
	}
	return SSH_ERR_INVALID_ARGUMENT;
}

int
mac_init(struct sshmac *mac)
{
	if (mac->key == NULL)
		return SSH_ERR_INVALID_ARGUMENT;
	switch (mac->type) {
	case SSH_DIGEST:
		if (mac->hmac_ctx == NULL ||
		    ssh_hmac_init(mac->hmac_ctx, mac->key, mac->key_len) < 0)
			return SSH_ERR_INVALID_ARGUMENT;
		return 0;
	case SSH_UMAC:
		if ((mac->umac_ctx = umac_new(mac->key)) == NULL)
			return SSH_ERR_ALLOC_FAIL;
		return 0;
	case SSH_UMAC128:
		if ((mac->umac_ctx = umac128_new(mac->key)) == NULL)
			return SSH_ERR_ALLOC_FAIL;
		return 0;
	default:
		return SSH_ERR_INVALID_ARGUMENT;
	}
}

int
mac_compute(struct sshmac *mac, u_int32_t seqno,
    const u_char *data, int datalen,
    u_char *digest, size_t dlen)
{
	static union {
		u_char m[SSH_DIGEST_MAX_LENGTH];
		u_int64_t for_align;
	} u;
	u_char b[4];
	u_char nonce[8];

	if (mac->mac_len > sizeof(u))
		return SSH_ERR_INTERNAL_ERROR;

	switch (mac->type) {
	case SSH_DIGEST:
		put_u32(b, seqno);
		/* reset HMAC context */
		if (ssh_hmac_init(mac->hmac_ctx, NULL, 0) < 0 ||
		    ssh_hmac_update(mac->hmac_ctx, b, sizeof(b)) < 0 ||
		    ssh_hmac_update(mac->hmac_ctx, data, datalen) < 0 ||
		    ssh_hmac_final(mac->hmac_ctx, u.m, sizeof(u.m)) < 0)
			return SSH_ERR_LIBCRYPTO_ERROR;
		break;
	case SSH_UMAC:
		POKE_U64(nonce, seqno);
		umac_update(mac->umac_ctx, data, datalen);
		umac_final(mac->umac_ctx, u.m, nonce);
		break;
	case SSH_UMAC128:
		put_u64(nonce, seqno);
		umac128_update(mac->umac_ctx, data, datalen);
		umac128_final(mac->umac_ctx, u.m, nonce);
		break;
	default:
		return SSH_ERR_INVALID_ARGUMENT;
	}
	if (digest != NULL) {
		if (dlen > mac->mac_len)
			dlen = mac->mac_len;
		memcpy(digest, u.m, dlen);
	}
	return 0;
}

int
mac_check(struct sshmac *mac, u_int32_t seqno,
    const u_char *data, size_t dlen,
    const u_char *theirmac, size_t mlen)
{
	u_char ourmac[SSH_DIGEST_MAX_LENGTH];
	int r;

	if (mac->mac_len > mlen)
		return SSH_ERR_INVALID_ARGUMENT;
	if ((r = mac_compute(mac, seqno, data, dlen,
	    ourmac, sizeof(ourmac))) != 0)
		return r;
	if (timingsafe_bcmp(ourmac, theirmac, mac->mac_len) != 0)
		return SSH_ERR_MAC_INVALID;
	return 0;
}

void
mac_clear(struct sshmac *mac)
{
	if (mac->type == SSH_UMAC) {
		if (mac->umac_ctx != NULL)
			umac_delete(mac->umac_ctx);
	} else if (mac->type == SSH_UMAC128) {
		if (mac->umac_ctx != NULL)
			umac128_delete(mac->umac_ctx);
	} else if (mac->hmac_ctx != NULL)
		ssh_hmac_free(mac->hmac_ctx);
	mac->hmac_ctx = NULL;
	mac->umac_ctx = NULL;
}

/* XXX copied from ciphers_valid */
#define	MAC_SEP	","
int
mac_valid(const char *names)
{
	char *maclist, *cp, *p;

	if (names == NULL || strcmp(names, "") == 0)
		return 0;
	if ((maclist = cp = strdup(names)) == NULL)
		return 0;
	for ((p = strsep(&cp, MAC_SEP)); p && *p != '\0';
	    (p = strsep(&cp, MAC_SEP))) {
		if (mac_setup(NULL, p) < 0) {
			free(maclist);
			return 0;
		}
	}
	free(maclist);
	return 1;
}
@


1.33
log
@Improve crypto ordering for Encrypt-then-MAC (EtM) mode MAC algorithms.

Previously we were computing the MAC, decrypting the packet and then
checking the MAC. This gave rise to the possibility of creating a
side-channel oracle in the decryption step, though no such oracle has
been identified.

This adds a mac_check() function that computes and checks the MAC in
one pass, and uses it to advance MAC checking for EtM algorithms to
before payload decryption.

Reported by Jean Paul Degabriele, Kenny Paterson, Torben Hansen and
Martin Albrecht. feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.32 2015/01/15 18:32:54 naddy Exp $ */
a60 2
	{ "hmac-ripemd160",			SSH_DIGEST, SSH_DIGEST_RIPEMD160, 0, 0, 0, 0 },
	{ "hmac-ripemd160@@openssh.com",		SSH_DIGEST, SSH_DIGEST_RIPEMD160, 0, 0, 0, 0 },
a70 1
	{ "hmac-ripemd160-etm@@openssh.com",	SSH_DIGEST, SSH_DIGEST_RIPEMD160, 0, 0, 0, 1 },
@


1.32
log
@handle UMAC128 initialization like UMAC; ok djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.31 2015/01/13 19:31:40 markus Exp $ */
d162 2
a163 1
mac_compute(struct sshmac *mac, u_int32_t seqno, const u_char *data, int datalen,
d204 18
@


1.31
log
@adapt mac.c to ssherr.h return codes (de-fatal) and simplify dependencies
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.30 2014/04/30 19:07:48 naddy Exp $ */
d153 2
a154 1
		mac->umac_ctx = umac128_new(mac->key);
@


1.30
log
@UMAC can use our local fallback implementation of AES when OpenSSL isn't
available.  Glue code straight from Ted Krovetz's original umac.c.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.29 2014/04/29 18:01:49 markus Exp $ */
a27 2
#include <openssl/hmac.h>

d29 1
a29 10
#include <signal.h>

#include "xmalloc.h"
#include "log.h"
#include "cipher.h"
#include "buffer.h"
#include "key.h"
#include "kex.h"
#include "mac.h"
#include "misc.h"
d34 4
d84 1
a84 1
	char *ret = NULL;
d92 5
a96 1
		ret = xrealloc(ret, 1, rlen + nlen + 2);
d103 2
a104 2
static void
mac_setup_by_alg(Mac *mac, const struct macalg *macalg)
d109 1
a109 1
			fatal("ssh_hmac_start(alg=%d) failed", macalg->alg);
d119 1
d123 1
a123 1
mac_setup(Mac *mac, char *name)
d130 3
a132 5
		if (mac != NULL) {
			mac_setup_by_alg(mac, m);
			debug2("mac_setup: setup %s", name);
		}
		return (0);
d134 1
a134 2
	debug2("mac_setup: unknown %s", name);
	return (-1);
d138 1
a138 1
mac_init(Mac *mac)
d141 1
a141 1
		fatal("%s: no key", __func__);
d146 1
a146 1
			return -1;
d149 2
a150 1
		mac->umac_ctx = umac_new(mac->key);
d156 1
a156 1
		return -1;
d160 3
a162 2
u_char *
mac_compute(Mac *mac, u_int32_t seqno, u_char *data, int datalen)
d165 1
a165 1
		u_char m[EVP_MAX_MD_SIZE];
d172 1
a172 2
		fatal("mac_compute: mac too long %u %zu",
		    mac->mac_len, sizeof(u));
d182 1
a182 1
			fatal("ssh_hmac failed");
d185 1
a185 1
		put_u64(nonce, seqno);
d195 1
a195 1
		fatal("mac_compute: unknown MAC type");
d197 6
a202 1
	return (u.m);
d206 1
a206 1
mac_clear(Mac *mac)
d228 3
a230 2
		return (0);
	maclist = cp = xstrdup(names);
a233 1
			debug("bad mac %s [%s]", p, names);
d235 1
a235 1
			return (0);
a237 1
	debug3("macs ok: [%s]", names);
d239 1
a239 1
	return (1);
@


1.29
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.28 2014/02/07 06:55:54 djm Exp $ */
a69 1
#ifdef WITH_OPENSSL
a71 1
#endif
a80 1
#ifdef WITH_OPENSSL
a82 1
#endif
a114 1
#ifdef WITH_OPENSSL
a117 1
#endif
a152 1
#ifdef WITH_OPENSSL
a158 1
#endif
a171 1
#ifdef WITH_OPENSSL
a172 1
#endif
a187 1
#ifdef WITH_OPENSSL
a197 1
#endif
a206 1
#ifdef WITH_OPENSSL
a213 1
#endif
@


1.28
log
@remove some logging that makes ssh debugging output very verbose;
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.27 2014/01/27 18:58:14 markus Exp $ */
d70 1
d73 1
d83 1
d86 1
d119 1
d123 1
d159 1
d166 1
d179 4
a182 1
	u_char b[4], nonce[8];
d198 1
d209 1
d219 1
d227 1
@


1.27
log
@replace openssl HMAC with an implementation based on our ssh_digest_*
ok and feedback djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.26 2014/01/04 17:50:55 tedu Exp $ */
d132 1
a132 1
		if (mac != NULL)
d134 2
a135 1
		debug2("mac_setup: found %s", name);
d146 1
a146 1
		fatal("mac_init: no key");
a233 2
		} else {
			debug3("mac ok: %s [%s]", p, names);
@


1.26
log
@use standard types and formats for size_t like variables. ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.25 2013/11/07 11:58:27 dtucker Exp $ */
d42 2
d46 1
a46 1
#define SSH_EVP		1	/* OpenSSL EVP-based MAC */
d53 1
a53 1
	const EVP_MD *	(*mdfunc)(void);
d62 10
a71 10
	{ "hmac-sha1",				SSH_EVP, EVP_sha1, 0, 0, 0, 0 },
	{ "hmac-sha1-96",			SSH_EVP, EVP_sha1, 96, 0, 0, 0 },
	{ "hmac-sha2-256",			SSH_EVP, EVP_sha256, 0, 0, 0, 0 },
	{ "hmac-sha2-512",			SSH_EVP, EVP_sha512, 0, 0, 0, 0 },
	{ "hmac-md5",				SSH_EVP, EVP_md5, 0, 0, 0, 0 },
	{ "hmac-md5-96",			SSH_EVP, EVP_md5, 96, 0, 0, 0 },
	{ "hmac-ripemd160",			SSH_EVP, EVP_ripemd160, 0, 0, 0, 0 },
	{ "hmac-ripemd160@@openssh.com",		SSH_EVP, EVP_ripemd160, 0, 0, 0, 0 },
	{ "umac-64@@openssh.com",		SSH_UMAC, NULL, 0, 128, 64, 0 },
	{ "umac-128@@openssh.com",		SSH_UMAC128, NULL, 0, 128, 128, 0 },
d74 9
a82 9
	{ "hmac-sha1-etm@@openssh.com",		SSH_EVP, EVP_sha1, 0, 0, 0, 1 },
	{ "hmac-sha1-96-etm@@openssh.com",	SSH_EVP, EVP_sha1, 96, 0, 0, 1 },
	{ "hmac-sha2-256-etm@@openssh.com",	SSH_EVP, EVP_sha256, 0, 0, 0, 1 },
	{ "hmac-sha2-512-etm@@openssh.com",	SSH_EVP, EVP_sha512, 0, 0, 0, 1 },
	{ "hmac-md5-etm@@openssh.com",		SSH_EVP, EVP_md5, 0, 0, 0, 1 },
	{ "hmac-md5-96-etm@@openssh.com",	SSH_EVP, EVP_md5, 96, 0, 0, 1 },
	{ "hmac-ripemd160-etm@@openssh.com",	SSH_EVP, EVP_ripemd160, 0, 0, 0, 1 },
	{ "umac-64-etm@@openssh.com",		SSH_UMAC, NULL, 0, 128, 64, 1 },
	{ "umac-128-etm@@openssh.com",		SSH_UMAC128, NULL, 0, 128, 128, 1 },
d84 1
a84 1
	{ NULL,					0, NULL, 0, 0, 0, 0 }
a108 2
	int evp_len;

d110 4
a113 5
	if (mac->type == SSH_EVP) {
		mac->evp_md = macalg->mdfunc();
		if ((evp_len = EVP_MD_size(mac->evp_md)) <= 0)
			fatal("mac %s len %d", mac->name, evp_len);
		mac->key_len = mac->mac_len = (u_int)evp_len;
d147 3
a149 2
	case SSH_EVP:
		if (mac->evp_md == NULL)
a150 2
		HMAC_CTX_init(&mac->evp_ctx);
		HMAC_Init(&mac->evp_ctx, mac->key, mac->key_len, mac->evp_md);
d177 1
a177 1
	case SSH_EVP:
d180 5
a184 4
		HMAC_Init(&mac->evp_ctx, NULL, 0, NULL);
		HMAC_Update(&mac->evp_ctx, b, sizeof(b));
		HMAC_Update(&mac->evp_ctx, data, datalen);
		HMAC_Final(&mac->evp_ctx, u.m, NULL);
d211 3
a213 3
	} else if (mac->evp_md != NULL)
		HMAC_cleanup(&mac->evp_ctx);
	mac->evp_md = NULL;
@


1.25
log
@Output the effective values of Ciphers, MACs and KexAlgorithms when
the default has not been overridden.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.24 2013/06/03 00:03:18 dtucker Exp $ */
d175 2
a176 2
		fatal("mac_compute: mac too long %u %lu",
		    mac->mac_len, (u_long)sizeof(u));
@


1.24
log
@force the MAC output to be 64-bit aligned so umac won't see unaligned
accesses on strict-alignment architectures.  bz#2101, patch from
tomas.kuthan at oracle.com, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.23 2013/05/17 00:13:13 djm Exp $ */
d85 1
a85 1
/* Returns a comma-separated list of supported MACs. */
d87 1
a87 1
mac_alg_list(void)
d95 1
a95 1
			ret[rlen++] = '\n';
@


1.23
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.22 2013/04/19 01:06:50 djm Exp $ */
d168 4
a171 1
	static u_char m[EVP_MAX_MD_SIZE];
d174 1
a174 1
	if (mac->mac_len > sizeof(m))
d176 1
a176 1
		    mac->mac_len, (u_long)sizeof(m));
d185 1
a185 1
		HMAC_Final(&mac->evp_ctx, m, NULL);
d190 1
a190 1
		umac_final(mac->umac_ctx, m, nonce);
d195 1
a195 1
		umac128_final(mac->umac_ctx, m, nonce);
d200 1
a200 1
	return (m);
@


1.22
log
@add the ability to query supported ciphers, MACs, key type and KEX
algorithms to ssh. Includes some refactoring of KEX and key type handling
to be table-driven; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.21 2012/12/11 22:51:45 sthen Exp $ */
d229 1
a229 1
			xfree(maclist);
d236 1
a236 1
	xfree(maclist);
@


1.21
log
@fix typo, s/tem/etm in hmac-ripemd160-tem. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.20 2012/12/11 22:31:18 markus Exp $ */
d48 1
a48 1
struct {
d56 3
a58 1
} macs[] = {
d85 19
d105 1
a105 1
mac_setup_by_id(Mac *mac, int which)
d108 2
a109 1
	mac->type = macs[which].type;
d111 1
a111 1
		mac->evp_md = (*macs[which].mdfunc)();
d116 2
a117 2
		mac->mac_len = macs[which].len / 8;
		mac->key_len = macs[which].key_len / 8;
d120 3
a122 3
	if (macs[which].truncatebits != 0)
		mac->mac_len = macs[which].truncatebits / 8;
	mac->etm = macs[which].etm;
d128 1
a128 1
	int i;
d130 7
a136 7
	for (i = 0; macs[i].name; i++) {
		if (strcmp(name, macs[i].name) == 0) {
			if (mac != NULL)
				mac_setup_by_id(mac, i);
			debug2("mac_setup: found %s", name);
			return (0);
		}
@


1.20
log
@add encrypt-then-mac (EtM) modes to openssh by defining new mac algorithms
that change the packet format and compute the MAC over the encrypted
message (including the packet size) instead of the plaintext data;
these EtM modes are considered more secure and used by default.
feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.19 2012/10/04 13:21:50 markus Exp $ */
d76 1
a76 1
	{ "hmac-ripemd160-tem@@openssh.com",	SSH_EVP, EVP_ripemd160, 0, 0, 0, 1 },
@


1.19
log
@add umac128 variant; ok djm@@ at n2k12
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.18 2012/06/28 05:07:45 dtucker Exp $ */
d55 1
d57 24
a80 11
	{ "hmac-sha1",			SSH_EVP, EVP_sha1, 0, -1, -1 },
	{ "hmac-sha1-96",		SSH_EVP, EVP_sha1, 96, -1, -1 },
	{ "hmac-sha2-256",		SSH_EVP, EVP_sha256, 0, -1, -1 },
	{ "hmac-sha2-512",		SSH_EVP, EVP_sha512, 0, -1, -1 },
	{ "hmac-md5",			SSH_EVP, EVP_md5, 0, -1, -1 },
	{ "hmac-md5-96",		SSH_EVP, EVP_md5, 96, -1, -1 },
	{ "hmac-ripemd160",		SSH_EVP, EVP_ripemd160, 0, -1, -1 },
	{ "hmac-ripemd160@@openssh.com",	SSH_EVP, EVP_ripemd160, 0, -1, -1 },
	{ "umac-64@@openssh.com",	SSH_UMAC, NULL, 0, 128, 64 },
	{ "umac-128@@openssh.com",	SSH_UMAC128, NULL, 0, 128, 128 },
	{ NULL,				0, NULL, 0, -1, -1 }
d100 1
@


1.18
log
@Remove hmac-sha2-256-96 and hmac-sha2-512-96 MACs since they were removed
from draft6 of the spec and will not be in the RFC when published.  Patch
from mdb at juniper net via bz#2023, ok markus.
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.17 2011/12/02 00:43:57 djm Exp $ */
d46 1
d65 1
d120 3
d152 5
d169 3
@


1.17
log
@fix bz#1934: newer OpenSSL versions will require HMAC_CTX_Init before
HMAC_init (this change in policy seems insane to me)
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.16 2011/08/02 01:22:11 djm Exp $ */
a57 1
	{ "hmac-sha2-256-96",		SSH_EVP, EVP_sha256, 96, -1, -1 },
a58 1
	{ "hmac-sha2-512-96",		SSH_EVP, EVP_sha512, 96, -1, -1 },
@


1.16
log
@Add new SHA256 and SHA512 based HMAC modes from
http://www.ietf.org/id/draft-dbider-sha2-mac-for-ssh-02.txt

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.15 2008/06/13 00:51:47 dtucker Exp $ */
d114 1
@


1.15
log
@upcast another size_t to u_long to match format
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.14 2007/06/07 19:37:34 pvalchev Exp $ */
d57 4
@


1.14
log
@Add a new MAC algorithm for data integrity, UMAC-64 (not default yet, must
specify umac-64@@openssh.com). Provides about 20% end-to-end speedup
compared to hmac-md5. Represents a different approach to message
authentication to that of HMAC that may be beneficial if HMAC based on one
of its underlying hash algorithms is found to be vulnerable to a new attack.
http://www.ietf.org/rfc/rfc4418.txt

in conjunction with and OK djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.13 2007/06/05 06:52:37 djm Exp $ */
d128 1
a128 1
		    mac->mac_len, sizeof(m));
@


1.13
log
@Preserve MAC ctx between packets, saving 2xhash calls per-packet.
Yields around a 12-16% end-to-end speedup for arcfour256/hmac-md5

patch from markus@@ tested dtucker@@ and myself, ok markus@@ and me (I'm
committing at his request)
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.12 2006/08/03 03:34:42 deraadt Exp $ */
d42 5
d49 1
d52 2
d55 8
a62 7
	{ "hmac-sha1",			EVP_sha1, 0, },
	{ "hmac-sha1-96",		EVP_sha1, 96 },
	{ "hmac-md5",			EVP_md5, 0 },
	{ "hmac-md5-96",		EVP_md5, 96 },
	{ "hmac-ripemd160",		EVP_ripemd160, 0 },
	{ "hmac-ripemd160@@openssh.com",	EVP_ripemd160, 0 },
	{ NULL,				NULL, 0 }
d65 19
d87 1
a87 1
	int i, evp_len;
d91 2
a92 8
			if (mac != NULL) {
				mac->md = (*macs[i].mdfunc)();
				if ((evp_len = EVP_MD_size(mac->md)) <= 0)
					fatal("mac %s len %d", name, evp_len);
				mac->key_len = mac->mac_len = (u_int)evp_len;
				if (macs[i].truncatebits != 0)
					mac->mac_len = macs[i].truncatebits/8;
			}
d101 1
a101 1
void
d106 12
a117 1
	HMAC_Init(&mac->ctx, mac->key, mac->key_len, mac->md);
d124 1
a124 1
	u_char b[4];
d127 20
a146 6
		fatal("mac_compute: mac too long");
	put_u32(b, seqno);
	HMAC_Init(&mac->ctx, NULL, 0, NULL);	/* reset HMAC context */
	HMAC_Update(&mac->ctx, b, sizeof(b));
	HMAC_Update(&mac->ctx, data, datalen);
	HMAC_Final(&mac->ctx, m, NULL);
d153 7
a159 1
	HMAC_cleanup(&mac->ctx);
@


1.12
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.11 2006/07/22 20:48:23 stevesk Exp $ */
d57 1
a57 1
mac_init(Mac *mac, char *name)
d71 1
a71 1
			debug2("mac_init: found %s", name);
d75 1
a75 1
	debug2("mac_init: unknown %s", name);
d79 8
a89 1
	HMAC_CTX c;
a92 2
	if (mac->key == NULL)
		fatal("mac_compute: no key");
a94 1
	HMAC_Init(&c, mac->key, mac->key_len, mac->md);
d96 4
a99 4
	HMAC_Update(&c, b, sizeof(b));
	HMAC_Update(&c, data, datalen);
	HMAC_Final(&c, m, NULL);
	HMAC_cleanup(&c);
d103 6
d121 1
a121 1
		if (mac_init(NULL, p) < 0) {
@


1.11
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.10 2006/03/30 09:58:15 djm Exp $ */
d26 1
a26 1
#include "includes.h"
d31 1
d36 2
@


1.10
log
@replace {GET,PUT}_XXBIT macros with functionally similar functions,
silencing a heap of lint warnings. also allows them to use
__bounded__ checking which can't be applied to macros; requested
by and feedback from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mac.c,v 1.9 2006/03/25 13:17:02 djm Exp $ */
d29 2
@


1.9
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a30 1
#include "getput.h"
d35 1
d86 1
a86 1
	PUT_32BIT(b, seqno);
@


1.8
log
@RCSID() can die
@
text
@d1 1
@


1.7
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@a25 1
RCSID("$OpenBSD: mac.c,v 1.6 2003/09/18 13:02:21 miod Exp $");
@


1.7.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: mac.c,v 1.12 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 1
#include <sys/types.h>
a29 3
#include <string.h>
#include <signal.h>

d31 1
a33 2
#include "buffer.h"
#include "key.h"
a35 1
#include "misc.h"
d86 1
a86 1
	put_u32(b, seqno);
@


1.7.4.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: mac.c,v 1.12 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 1
#include <sys/types.h>
a29 3
#include <string.h>
#include <signal.h>

d31 1
a33 2
#include "buffer.h"
#include "key.h"
a35 1
#include "misc.h"
d86 1
a86 1
	put_u32(b, seqno);
@


1.6
log
@A few signedness fixes for harmless situations; markus@@ ok
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.5 2002/05/16 22:02:50 markus Exp $");
d54 2
a55 1
	int i;
d60 3
a62 1
				mac->key_len = mac->mac_len = EVP_MD_size(mac->md);
d83 1
a83 1
	if ((u_int)mac->mac_len > sizeof(m))
@


1.6.6.1
log
@upgrade to OpenSSH 4.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.7 2005/06/17 02:44:32 djm Exp $");
d54 1
a54 2
	int i, evp_len;

d59 1
a59 3
				if ((evp_len = EVP_MD_size(mac->md)) <= 0)
					fatal("mac %s len %d", name, evp_len);
				mac->key_len = mac->mac_len = (u_int)evp_len;
d80 1
a80 1
	if (mac->mac_len > sizeof(m))
@


1.6.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.7 2005/06/17 02:44:32 djm Exp $");
d54 1
a54 2
	int i, evp_len;

d59 1
a59 3
				if ((evp_len = EVP_MD_size(mac->md)) <= 0)
					fatal("mac %s len %d", name, evp_len);
				mac->key_len = mac->mac_len = (u_int)evp_len;
d80 1
a80 1
	if (mac->mac_len > sizeof(m))
@


1.5
log
@fix warnings (openssl 0.9.7 requires const)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.4 2002/01/25 22:07:40 markus Exp $");
d80 1
a80 1
	if (mac->mac_len > sizeof(m))
@


1.5.4.1
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.6 2003/09/18 13:02:21 miod Exp $");
d80 1
a80 1
	if ((u_int)mac->mac_len > sizeof(m))
@


1.5.6.1
log
@upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.6 2003/09/18 13:02:21 miod Exp $");
d80 1
a80 1
	if ((u_int)mac->mac_len > sizeof(m))
@


1.4
log
@use EVP_MD_size(evp_md) and not evp_md->md_size; ok steveks@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.3 2001/12/19 07:18:56 deraadt Exp $");
d39 1
a39 1
	EVP_MD *	(*mdfunc)(void);
@


1.4.2.1
log
@Pull in OpenSSH-3.4
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.5 2002/05/16 22:02:50 markus Exp $");
d39 1
a39 1
	const EVP_MD *	(*mdfunc)(void);
@


1.3
log
@basic KNF done while i was looking for something else
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.2 2001/04/05 10:42:51 markus Exp $");
d59 1
a59 1
				mac->key_len = mac->mac_len = mac->md->md_size;
@


1.2
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.1 2001/02/11 12:59:24 markus Exp $");
d102 1
a102 1
	     (p = strsep(&cp, MAC_SEP))) {
@


1.2.2.1
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.4 2002/01/25 22:07:40 markus Exp $");
d59 1
a59 1
				mac->key_len = mac->mac_len = EVP_MD_size(mac->md);
d102 1
a102 1
	    (p = strsep(&cp, MAC_SEP))) {
@


1.2.4.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.4 2002/01/25 22:07:40 markus Exp $");
d59 1
a59 1
				mac->key_len = mac->mac_len = EVP_MD_size(mac->md);
d102 1
a102 1
	    (p = strsep(&cp, MAC_SEP))) {
@


1.2.4.2
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.2.4.1 2002/03/07 17:37:46 jason Exp $");
d39 1
a39 1
	const EVP_MD *	(*mdfunc)(void);
@


1.1
log
@1) clean up the MAC support for SSH-2
2) allow you to specify the MAC with 'ssh -m'
3) or the 'MACs' keyword in ssh(d)_config
4) add hmac-{md5,sha1}-96
	ok stevesk@@, provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.7 2001/02/08 19:30:51 itojun Exp $");
d48 1
a48 1
        { NULL,				NULL, 0 }
@


1.1.4.1
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.1 2001/02/11 12:59:24 markus Exp $");
@


1.1.4.2
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.1.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.1 2001/02/11 12:59:24 markus Exp $");
@


1.1.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.1.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.1.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.2 2001/04/05 10:42:51 markus Exp $");
d48 1
a48 1
	{ NULL,				NULL, 0 }
@


1.1.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@@


1.1.2.6
log
@Merge OpenSSH 3.1.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: mac.c,v 1.4 2002/01/25 22:07:40 markus Exp $");
d59 1
a59 1
				mac->key_len = mac->mac_len = EVP_MD_size(mac->md);
d102 1
a102 1
	    (p = strsep(&cp, MAC_SEP))) {
@


