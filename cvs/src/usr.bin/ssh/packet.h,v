head	1.82;
access;
symbols
	OPENBSD_6_2_BASE:1.82
	OPENBSD_6_1:1.76.0.4
	OPENBSD_6_1_BASE:1.76
	OPENBSD_6_0:1.71.0.4
	OPENBSD_6_0_BASE:1.71
	OPENBSD_5_9:1.70.0.2
	OPENBSD_5_9_BASE:1.70
	OPENBSD_5_8:1.66.0.4
	OPENBSD_5_8_BASE:1.66
	OPENBSD_5_7:1.66.0.2
	OPENBSD_5_7_BASE:1.66
	OPENBSD_5_6:1.61.0.4
	OPENBSD_5_6_BASE:1.61
	OPENBSD_5_5:1.59.0.6
	OPENBSD_5_5_BASE:1.59
	OPENBSD_5_4:1.59.0.2
	OPENBSD_5_4_BASE:1.59
	OPENBSD_5_3:1.57.0.6
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.57.0.4
	OPENBSD_5_2_BASE:1.57
	OPENBSD_5_1_BASE:1.57
	OPENBSD_5_1:1.57.0.2
	OPENBSD_5_0:1.56.0.2
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.55.0.2
	OPENBSD_4_9_BASE:1.55
	OPENBSD_4_8:1.52.0.6
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.52.0.4
	OPENBSD_4_6_BASE:1.52
	OPENBSD_4_5:1.49.0.4
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.49.0.2
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.46.0.2
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.45.0.6
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.45.0.4
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.44.0.2
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.43.0.2
	OPENBSD_3_8_BASE:1.43
	OPENBSD_3_7:1.41.0.4
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.41.0.2
	OPENBSD_3_6_BASE:1.41
	OPENBSD_3_5:1.40.0.4
	OPENBSD_3_5_BASE:1.40
	OPENBSD_3_4:1.40.0.2
	OPENBSD_3_4_BASE:1.40
	OPENBSD_3_3:1.35.0.4
	OPENBSD_3_3_BASE:1.35
	OPENBSD_3_2:1.35.0.2
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.34.0.2
	OPENBSD_3_1_BASE:1.34
	OPENBSD_3_0:1.25.0.2
	OPENBSD_3_0_BASE:1.25
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.82
date	2017.09.12.06.32.07;	author djm;	state Exp;
branches;
next	1.81;
commitid	Amj5uk8F1JrQpmI5;

1.81
date	2017.05.31.08.09.45;	author markus;	state Exp;
branches;
next	1.80;
commitid	U3YdddehbFcy84WY;

1.80
date	2017.05.30.14.18.15;	author markus;	state Exp;
branches;
next	1.79;
commitid	WzNNZXNcMAmgkxwG;

1.79
date	2017.05.03.21.08.09;	author naddy;	state Exp;
branches;
next	1.78;
commitid	wlKSvaBqtNpb5VOS;

1.78
date	2017.04.30.23.23.54;	author djm;	state Exp;
branches;
next	1.77;
commitid	PfkEUj5xzREsKxoN;

1.77
date	2017.04.30.23.13.25;	author djm;	state Exp;
branches;
next	1.76;
commitid	Ss7V57MvgEZubdtr;

1.76
date	2017.02.03.23.03.33;	author djm;	state Exp;
branches;
next	1.75;
commitid	43aNO043fq67hPdQ;

1.75
date	2017.02.03.02.56.00;	author dtucker;	state Exp;
branches;
next	1.74;
commitid	FFnrndqVo2L4heRx;

1.74
date	2016.10.11.21.47.45;	author djm;	state Exp;
branches;
next	1.73;
commitid	yhU8hSEKFqFZ68zX;

1.73
date	2016.09.30.09.19.13;	author markus;	state Exp;
branches;
next	1.72;
commitid	VHQRRel9yTEUINVH;

1.72
date	2016.09.28.16.33.07;	author djm;	state Exp;
branches;
next	1.71;
commitid	e2NJzal9PUi2o22D;

1.71
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.70;
commitid	kr9hjdmg99uVnhW2;

1.70
date	2016.02.08.10.57.07;	author djm;	state Exp;
branches;
next	1.69;
commitid	eSwtzi7BWC7eBzrp;

1.69
date	2016.01.29.02.54.45;	author dtucker;	state Exp;
branches;
next	1.68;
commitid	PeK9nimTzIqJuIOX;

1.68
date	2016.01.14.16.17.40;	author markus;	state Exp;
branches;
next	1.67;
commitid	W9ye0gltieEl87AJ;

1.67
date	2015.12.11.03.24.25;	author djm;	state Exp;
branches;
next	1.66;
commitid	ynQOJ17hX0UjbjoH;

1.66
date	2015.01.30.01.13.33;	author djm;	state Exp;
branches;
next	1.65;
commitid	BuE3vBiYMFEA1E3u;

1.65
date	2015.01.28.21.15.47;	author djm;	state Exp;
branches;
next	1.64;
commitid	Iqzpomw0YO4gLwGY;

1.64
date	2015.01.19.20.30.23;	author markus;	state Exp;
branches;
next	1.63;
commitid	74WAJgdQCKxDqTwt;

1.63
date	2015.01.19.20.07.45;	author markus;	state Exp;
branches;
next	1.62;
commitid	GrtSC5ve2VERgUln;

1.62
date	2015.01.19.19.52.16;	author markus;	state Exp;
branches;
next	1.61;
commitid	UHlhoIB5NMb8eAPm;

1.61
date	2014.05.03.17.20.34;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2014.04.28.03.09.18;	author djm;	state Exp;
branches;
next	1.59;

1.59
date	2013.07.12.00.19.59;	author djm;	state Exp;
branches;
next	1.58;

1.58
date	2013.05.16.02.00.34;	author dtucker;	state Exp;
branches;
next	1.57;

1.57
date	2012.01.25.19.40.09;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2011.05.06.21.14.05;	author djm;	state Exp;
branches;
next	1.55;

1.55
date	2010.11.13.23.27.50;	author djm;	state Exp;
branches;
next	1.54;

1.54
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.53;

1.53
date	2010.08.31.09.58.37;	author djm;	state Exp;
branches;
next	1.52;

1.52
date	2009.06.27.09.29.06;	author andreas;	state Exp;
branches;
next	1.51;

1.51
date	2009.05.27.06.36.07;	author andreas;	state Exp;
branches;
next	1.50;

1.50
date	2009.05.25.06.48.01;	author andreas;	state Exp;
branches;
next	1.49;

1.49
date	2008.07.10.18.08.11;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2008.06.12.20.38.28;	author dtucker;	state Exp;
branches;
next	1.47;

1.47
date	2008.05.08.06.59.01;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2008.02.22.20.44.02;	author dtucker;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.25.22.22.43;	author djm;	state Exp;
branches;
next	1.44;

1.44
date	2006.02.07.01.42.00;	author stevesk;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2005.07.25.11.59.40;	author markus;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2005.06.17.02.44.33;	author djm;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.11.19.01.43;	author deraadt;	state Exp;
branches
	1.41.2.1
	1.41.4.1;
next	1.40;

1.40
date	2003.06.24.08.23.46;	author markus;	state Exp;
branches
	1.40.2.1
	1.40.4.1;
next	1.39;

1.39
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.02.09.48.07;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2003.04.01.10.22.21;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2003.04.01.10.10.23;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.19.18.01.00;	author markus;	state Exp;
branches
	1.35.2.1
	1.35.4.1;
next	1.34;

1.34
date	2002.03.18.17.16.38;	author markus;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2002.03.04.17.27.39;	author stevesk;	state Exp;
branches;
next	1.32;

1.32
date	2001.12.28.14.50.54;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.28.13.57.33;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.27.20.39.58;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.20.22.50.24;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.19.17.16.13;	author stevesk;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.07.16.03.17;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.26.17.27.24;	author markus;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2001.06.26.06.32.57;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.28.23.58.35;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2001.04.14.16.33.20;	author stevesk;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.02.28.21.27.47;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.28.09.57.07;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.13.18.32.50;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2000.12.19.23.17.57;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.07.20.27.52;	author deraadt;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2000.06.20.01.39.43;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.14.10.30.32;	author markus;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2000.04.14.10.09.15;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.12.09.39.10;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.03.20.12.55;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.03.07.07.15;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.16.20.56.14;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.04.16.54.58;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.04.00.07.59;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	99.12.27.10.46.11;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.11.24.19.53.48;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	99.11.24.00.26.02;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.11.19.19.58.18;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	99.11.15.21.38.54;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.04.45.36;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.36;	author deraadt;	state Exp;
branches;
next	;

1.15.2.1
date	2000.09.01.18.23.21;	author jason;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2000.11.08.21.31.03;	author jason;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2001.03.12.15.44.12;	author jason;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2001.03.21.18.52.55;	author jason;	state Exp;
branches;
next	;

1.17.2.1
date	2001.02.16.20.13.09;	author jason;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2001.02.19.17.19.10;	author jason;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2001.03.21.19.46.27;	author jason;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2001.05.07.21.09.32;	author jason;	state Exp;
branches;
next	1.17.2.5;

1.17.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.17.2.6;

1.17.2.6
date	2001.11.15.22.50.30;	author miod;	state Exp;
branches;
next	1.17.2.7;

1.17.2.7
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.22.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2001.11.15.22.51.15;	author miod;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.25.2.1
date	2001.11.14.03.24.38;	author jason;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.25.2.4;

1.25.2.4
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	;

1.34.2.1
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	;

1.35.2.1
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.35.4.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.35.4.2;

1.35.4.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.40.2.1
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.40.4.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	;

1.41.2.1
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.41.4.1
date	2005.09.04.18.40.02;	author brad;	state Exp;
branches;
next	;

1.43.2.1
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	;

1.44.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.82
log
@refactor channels.c

Move static state to a "struct ssh_channels" that is allocated at
runtime and tracked as a member of struct ssh.

Explicitly pass "struct ssh" to all channels functions.

Replace use of the legacy packet APIs in channels.c.

Rework sshd_config PermitOpen handling: previously the configuration
parser would call directly into the channels layer. After the refactor
this is not possible, as the channels structures are allocated at
connection time and aren't available when the configuration is parsed.
The server config parser now tracks PermitOpen itself and explicitly
configures the channels code later.

ok markus@@
@
text
@/* $OpenBSD: packet.h,v 1.81 2017/05/31 08:09:45 markus Exp $ */

/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Interface for the packet protocol functions.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#ifndef PACKET_H
#define PACKET_H

#include <termios.h>

#include <openssl/bn.h>
#include <openssl/ec.h>
#include <sys/signal.h>
#include <sys/queue.h>

struct kex;
struct sshkey;
struct sshbuf;
struct session_state;	/* private session data */

#include "dispatch.h"	/* typedef, DISPATCH_MAX */

struct key_entry {
	TAILQ_ENTRY(key_entry) next;
	struct sshkey *key;
};

struct ssh {
	/* Session state */
	struct session_state *state;

	/* Key exchange */
	struct kex *kex;

	/* cached local and remote ip addresses and ports */
	char *remote_ipaddr;
	int remote_port;
	char *local_ipaddr;
	int local_port;

	/* Optional preamble for log messages (e.g. username) */
	char *log_preamble;

	/* Dispatcher table */
	dispatch_fn *dispatch[DISPATCH_MAX];
	/* number of packets to ignore in the dispatcher */
	int dispatch_skip_packets;

	/* datafellows */
	int compat;

	/* Lists for private and public keys */
	TAILQ_HEAD(, key_entry) private_keys;
	TAILQ_HEAD(, key_entry) public_keys;

	/* Client/Server authentication context */
	void *authctxt;

	/* Channels context */
	struct ssh_channels *chanctxt;

	/* APP data */
	void *app_data;
};

typedef int (ssh_packet_hook_fn)(struct ssh *, struct sshbuf *,
    u_char *, void *);

struct ssh *ssh_alloc_session_state(void);
struct ssh *ssh_packet_set_connection(struct ssh *, int, int);
void     ssh_packet_set_timeout(struct ssh *, int, int);
int	 ssh_packet_stop_discard(struct ssh *);
int	 ssh_packet_connection_af(struct ssh *);
void     ssh_packet_set_nonblocking(struct ssh *);
int      ssh_packet_get_connection_in(struct ssh *);
int      ssh_packet_get_connection_out(struct ssh *);
void     ssh_packet_close(struct ssh *);
void	 ssh_packet_set_input_hook(struct ssh *, ssh_packet_hook_fn *, void *);
void	 ssh_packet_clear_keys(struct ssh *);
void	 ssh_clear_newkeys(struct ssh *, int);

int	 ssh_packet_is_rekeying(struct ssh *);
void     ssh_packet_set_protocol_flags(struct ssh *, u_int);
u_int	 ssh_packet_get_protocol_flags(struct ssh *);
int      ssh_packet_start_compression(struct ssh *, int);
void	 ssh_packet_set_tos(struct ssh *, int);
void     ssh_packet_set_interactive(struct ssh *, int, int, int);
int      ssh_packet_is_interactive(struct ssh *);
void     ssh_packet_set_server(struct ssh *);
void     ssh_packet_set_authenticated(struct ssh *);
void     ssh_packet_set_mux(struct ssh *);
int	 ssh_packet_get_mux(struct ssh *);
int	 ssh_packet_set_log_preamble(struct ssh *, const char *, ...)
    __attribute__((format(printf, 2, 3)));

int	 ssh_packet_log_type(u_char);

int	 ssh_packet_send2_wrapped(struct ssh *);
int	 ssh_packet_send2(struct ssh *);

int      ssh_packet_read(struct ssh *);
int	 ssh_packet_read_expect(struct ssh *, u_int type);
int      ssh_packet_read_poll(struct ssh *);
int ssh_packet_read_poll2(struct ssh *, u_char *, u_int32_t *seqnr_p);
int	 ssh_packet_process_incoming(struct ssh *, const char *buf, u_int len);
int      ssh_packet_read_seqnr(struct ssh *, u_char *, u_int32_t *seqnr_p);
int      ssh_packet_read_poll_seqnr(struct ssh *, u_char *, u_int32_t *seqnr_p);

const void *ssh_packet_get_string_ptr(struct ssh *, u_int *length_ptr);
void     ssh_packet_disconnect(struct ssh *, const char *fmt, ...)
	__attribute__((format(printf, 2, 3)))
	__attribute__((noreturn));
void     ssh_packet_send_debug(struct ssh *, const char *fmt, ...) __attribute__((format(printf, 2, 3)));

int	 ssh_set_newkeys(struct ssh *, int mode);
void	 ssh_packet_get_bytes(struct ssh *, u_int64_t *, u_int64_t *);

int	 ssh_packet_write_poll(struct ssh *);
int	 ssh_packet_write_wait(struct ssh *);
int      ssh_packet_have_data_to_write(struct ssh *);
int      ssh_packet_not_very_much_data_to_write(struct ssh *);

int	 ssh_packet_connection_is_on_socket(struct ssh *);
int	 ssh_packet_remaining(struct ssh *);

void	 tty_make_modes(int, struct termios *);
void	 tty_parse_modes(int, int *);

void	 ssh_packet_set_alive_timeouts(struct ssh *, int);
int	 ssh_packet_inc_alive_timeouts(struct ssh *);
int	 ssh_packet_set_maxsize(struct ssh *, u_int);
u_int	 ssh_packet_get_maxsize(struct ssh *);

int	 ssh_packet_get_state(struct ssh *, struct sshbuf *);
int	 ssh_packet_set_state(struct ssh *, struct sshbuf *);

const char *ssh_remote_ipaddr(struct ssh *);
int	 ssh_remote_port(struct ssh *);
const char *ssh_local_ipaddr(struct ssh *);
int	 ssh_local_port(struct ssh *);

void	 ssh_packet_set_rekey_limits(struct ssh *, u_int64_t, u_int32_t);
time_t	 ssh_packet_get_rekey_timeout(struct ssh *);

void	*ssh_packet_get_input(struct ssh *);
void	*ssh_packet_get_output(struct ssh *);

/* new API */
int	sshpkt_start(struct ssh *ssh, u_char type);
int	sshpkt_send(struct ssh *ssh);
int     sshpkt_disconnect(struct ssh *, const char *fmt, ...)
	    __attribute__((format(printf, 2, 3)));
int	sshpkt_add_padding(struct ssh *, u_char);
void	sshpkt_fatal(struct ssh *ssh, const char *tag, int r);
int	sshpkt_msg_ignore(struct ssh *, u_int);

int	sshpkt_put(struct ssh *ssh, const void *v, size_t len);
int	sshpkt_putb(struct ssh *ssh, const struct sshbuf *b);
int	sshpkt_put_u8(struct ssh *ssh, u_char val);
int	sshpkt_put_u32(struct ssh *ssh, u_int32_t val);
int	sshpkt_put_u64(struct ssh *ssh, u_int64_t val);
int	sshpkt_put_string(struct ssh *ssh, const void *v, size_t len);
int	sshpkt_put_cstring(struct ssh *ssh, const void *v);
int	sshpkt_put_stringb(struct ssh *ssh, const struct sshbuf *v);
int	sshpkt_put_ec(struct ssh *ssh, const EC_POINT *v, const EC_GROUP *g);
int	sshpkt_put_bignum2(struct ssh *ssh, const BIGNUM *v);

int	sshpkt_get(struct ssh *ssh, void *valp, size_t len);
int	sshpkt_get_u8(struct ssh *ssh, u_char *valp);
int	sshpkt_get_u32(struct ssh *ssh, u_int32_t *valp);
int	sshpkt_get_u64(struct ssh *ssh, u_int64_t *valp);
int	sshpkt_get_string(struct ssh *ssh, u_char **valp, size_t *lenp);
int	sshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp);
int	sshpkt_peek_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp);
int	sshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp);
int	sshpkt_get_ec(struct ssh *ssh, EC_POINT *v, const EC_GROUP *g);
int	sshpkt_get_bignum2(struct ssh *ssh, BIGNUM *v);
int	sshpkt_get_end(struct ssh *ssh);
const u_char	*sshpkt_ptr(struct ssh *, size_t *lenp);

/* OLD API */
extern struct ssh *active_state;
#include "opacket.h"

#endif				/* PACKET_H */
@


1.81
log
@clear session keys from memory; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.80 2017/05/30 14:18:15 markus Exp $ */
d69 3
a134 1
void	 ssh_packet_send_ignore(struct ssh *, int);
d165 1
d184 1
@


1.80
log
@sshd: pass struct ssh to auth functions; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.79 2017/05/03 21:08:09 naddy Exp $ */
d86 2
@


1.79
log
@remove miscellaneous SSH1 leftovers; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.78 2017/04/30 23:23:54 djm Exp $ */
d65 3
@


1.78
log
@remove SSHv1 support from packet and buffer APIs

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.77 2017/04/30 23:13:25 djm Exp $ */
a81 1
void	 ssh_packet_set_encryption_key(struct ssh *, const u_char *, u_int, int);
@


1.77
log
@remove compat20/compat13/compat15 variables

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.76 2017/02/03 23:03:33 djm Exp $ */
a106 1
int ssh_packet_read_poll1(struct ssh *, u_char *);
a168 1
int	sshpkt_put_bignum1(struct ssh *ssh, const BIGNUM *v);
a178 1
int	sshpkt_get_bignum1(struct ssh *ssh, BIGNUM *v);
@


1.76
log
@add ssh_packet_set_log_preamble() to allow inclusion of a preamble
string in disconnect messages; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.75 2017/02/03 02:56:00 dtucker Exp $ */
a100 1
int	 ssh_packet_send1(struct ssh *);
@


1.75
log
@Make ssh_packet_set_rekey_limits take u32 for the number of seconds
until rekeying (negative values are rejected at config parse time).
This allows the removal of some casts and a signed vs unsigned
comparison warning.

rekey_time is cast to int64 for the comparison which is a no-op
on OpenBSD, but should also do the right thing in -portable on
anything still using 32bit time_t (until the system time actually
wraps, anyway).

some early guidance deraadt@@, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.74 2016/10/11 21:47:45 djm Exp $ */
d51 3
d96 2
@


1.74
log
@Add a per-packet input hook that is called with the decrypted packet
contents. This will be used for fuzzing; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.73 2016/09/30 09:19:13 markus Exp $ */
d143 1
a143 1
void	 ssh_packet_set_rekey_limits(struct ssh *, u_int64_t, time_t);
@


1.73
log
@ssh proxy mux mode (-O proxy; idea from Simon Tatham):
- mux client speaks the ssh-packet protocol directly over unix-domain socket.
- mux server acts as a proxy, translates channel IDs and relays to the server.
- no filedescriptor passing necessary.
- combined with unix-domain forwarding it's even possible to run mux client
  and server on different machines.
feedback & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.72 2016/09/28 16:33:07 djm Exp $ */
d67 3
d80 2
@


1.72
log
@Remove support for pre-authentication compression. Doing compression
early in the protocol probably seemed reasonable in the 1990s, but
today it's clearly a bad idea in terms of both cryptography (cf.
multiple compression oracle attacks in TLS) and attack surface.

Moreover, to support it across privilege-separation zlib needed
the assistance of a complex shared-memory manager that made the
required attack surface considerably larger.

Prompted by Guido Vranken pointing out a compiler-elided security
check in the shared memory manager found by Stack
(http://css.csail.mit.edu/stack/); ok deraadt@@ markus@@

NB. pre-auth authentication has been disabled by default in sshd
for >10 years.
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.71 2016/03/07 19:02:43 djm Exp $ */
d86 4
@


1.71
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.70 2016/02/08 10:57:07 djm Exp $ */
a107 5

typedef void *(ssh_packet_comp_alloc_func)(void *, u_int, u_int);
typedef void (ssh_packet_comp_free_func)(void *, void *);
void	 ssh_packet_set_compress_hooks(struct ssh *, void *,
    ssh_packet_comp_alloc_func *, ssh_packet_comp_free_func *);
@


1.70
log
@refactor activation of rekeying

This makes automatic rekeying internal to the packet code (previously
the server and client loops needed to assist). In doing to it makes
application of rekey limits more accurate by accounting for packets
about to be sent as well as packets queued during rekeying events
themselves.

Based on a patch from dtucker@@ which was in turn based on a patch
Aleksander Adamowski in bz#2521; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.69 2016/01/29 02:54:45 dtucker Exp $ */
d45 1
a45 1
	/* cached remote ip address and port*/
d48 2
d136 2
@


1.69
log
@Allow RekeyLimits in excess of 4G up to 2**63 bits (limited by the return
type of scan_scaled).  Part of bz#2521, ok djm.
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.68 2016/01/14 16:17:40 markus Exp $ */
d75 1
a134 1
int	 ssh_packet_need_rekeying(struct ssh *);
@


1.68
log
@remove roaming support; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.67 2015/12/11 03:24:25 djm Exp $ */
d135 1
a135 1
void	 ssh_packet_set_rekey_limits(struct ssh *, u_int32_t, time_t);
@


1.67
log
@include remote port number in a few more messages; makes tying log
messages together into a session a bit easier; bz#2503 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.66 2015/01/30 01:13:33 djm Exp $ */
a136 4

/* XXX FIXME */
void	 ssh_packet_backup_state(struct ssh *, struct ssh *);
void	 ssh_packet_restore_state(struct ssh *, struct ssh *);
@


1.66
log
@avoid more fatal/exit in the packet.c paths that ssh-keyscan
uses; feedback and "looks good" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.65 2015/01/28 21:15:47 djm Exp $ */
d132 1
@


1.65
log
@avoid fatal() calls in packet code
makes ssh-keyscan more reliable against server failures
ok dtucker@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.64 2015/01/19 20:30:23 markus Exp $ */
d89 1
a89 1
void     ssh_packet_read_expect(struct ssh *, int type);
d111 2
a112 2
void     ssh_packet_write_poll(struct ssh *);
void     ssh_packet_write_wait(struct ssh *);
d147 2
a148 1
int     sshpkt_disconnect(struct ssh *, const char *fmt, ...) __attribute__((format(printf, 2, 3)));
d150 1
@


1.64
log
@add experimental api for packet layer; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.63 2015/01/19 20:07:45 markus Exp $ */
d93 1
a93 1
void     ssh_packet_process_incoming(struct ssh *, const char *buf, u_int len);
@


1.63
log
@move dispatch to struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.62 2015/01/19 19:52:16 markus Exp $ */
d33 5
d56 7
@


1.62
log
@update packet.c & isolate, introduce struct ssh
a) switch packet.c to buffer api and isolate per-connection info into struct ssh
b) (de)serialization of the state is moved from monitor to packet.c
c) the old packet.c API is implemented in opacket.[ch]
d) compress.c/h is removed and integrated into packet.c
with and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.61 2014/05/03 17:20:34 markus Exp $ */
d31 2
d43 5
@


1.61
log
@unbreak compression, by re-init-ing the compression code in the
post-auth child. the new buffer code is more strict, and requires
buffer_init() while the old code was happy after a bzero();
originally from djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.60 2014/04/28 03:09:18 djm Exp $ */
d23 2
d26 74
a99 67
void     packet_set_connection(int, int);
void     packet_set_timeout(int, int);
void     packet_set_nonblocking(void);
int      packet_get_connection_in(void);
int      packet_get_connection_out(void);
void     packet_close(void);
void	 packet_set_encryption_key(const u_char *, u_int, int);
u_int	 packet_get_encryption_key(u_char *);
void     packet_set_protocol_flags(u_int);
u_int	 packet_get_protocol_flags(void);
void     packet_start_compression(int);
void     packet_set_interactive(int, int, int);
int      packet_is_interactive(void);
void     packet_set_server(void);
void     packet_set_authenticated(void);

void     packet_start(u_char);
void     packet_put_char(int ch);
void     packet_put_int(u_int value);
void     packet_put_int64(u_int64_t value);
void     packet_put_bignum(BIGNUM * value);
void     packet_put_bignum2(BIGNUM * value);
void     packet_put_ecpoint(const EC_GROUP *, const EC_POINT *);
void     packet_put_string(const void *buf, u_int len);
void     packet_put_cstring(const char *str);
void     packet_put_raw(const void *buf, u_int len);
void     packet_send(void);

int      packet_read(void);
void     packet_read_expect(int type);
void     packet_process_incoming(const char *buf, u_int len);
int      packet_read_seqnr(u_int32_t *seqnr_p);
int      packet_read_poll_seqnr(u_int32_t *seqnr_p);

u_int	 packet_get_char(void);
u_int	 packet_get_int(void);
u_int64_t packet_get_int64(void);
void     packet_get_bignum(BIGNUM * value);
void     packet_get_bignum2(BIGNUM * value);
void	 packet_get_ecpoint(const EC_GROUP *, EC_POINT *);
void	*packet_get_raw(u_int *length_ptr);
void	*packet_get_string(u_int *length_ptr);
char	*packet_get_cstring(u_int *length_ptr);
const void	*packet_get_string_ptr(u_int *length_ptr);
void     packet_disconnect(const char *fmt,...) __attribute__((noreturn)) __attribute__((format(printf, 1, 2)));
void     packet_send_debug(const char *fmt,...) __attribute__((format(printf, 1, 2)));

void	 set_newkeys(int mode);
int	 packet_get_keyiv_len(int);
void	 packet_get_keyiv(int, u_char *, u_int);
int	 packet_get_keycontext(int, u_char *);
void	 packet_set_keycontext(int, u_char *);
void	 packet_get_state(int, u_int32_t *, u_int64_t *, u_int32_t *, u_int64_t *);
void	 packet_set_state(int, u_int32_t, u_int64_t, u_int32_t, u_int64_t);
int	 packet_get_ssh1_cipher(void);
void	 packet_set_iv(int, u_char *);
void	*packet_get_newkeys(int);

void     packet_write_poll(void);
void     packet_write_wait(void);
int      packet_have_data_to_write(void);
int      packet_not_very_much_data_to_write(void);

int	 packet_connection_is_on_socket(void);
int	 packet_remaining(void);
void	 packet_send_ignore(int);
void	 packet_add_padding(u_char);
d104 55
a158 26
void	 packet_set_alive_timeouts(int);
int	 packet_inc_alive_timeouts(void);
int	 packet_set_maxsize(u_int);
u_int	 packet_get_maxsize(void);

/* don't allow remaining bytes after the end of the message */
#define packet_check_eom() \
do { \
	int _len = packet_remaining(); \
	if (_len > 0) { \
		logit("Packet integrity error (%d bytes remaining) at %s:%d", \
		    _len ,__FILE__, __LINE__); \
		packet_disconnect("Packet integrity error."); \
	} \
} while (0)

int	 packet_need_rekeying(void);
void	 packet_set_rekey_limits(u_int32_t, time_t);
time_t	 packet_get_rekey_timeout(void);

void	 packet_backup_state(void);
void	 packet_restore_state(void);
void	 packet_set_postauth(void);

void	*packet_get_input(void);
void	*packet_get_output(void);
@


1.60
log
@buffer_get_string_ptr's return should be const to remind
callers that futzing with it will futz with the actual buffer
contents
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.59 2013/07/12 00:19:59 djm Exp $ */
d117 1
@


1.59
log
@fix pointer-signedness warnings from clang/llvm-3.3; "seems nice" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.58 2013/05/16 02:00:34 dtucker Exp $ */
d67 1
a67 1
void	*packet_get_string_ptr(u_int *length_ptr);
@


1.58
log
@Add an optional second argument to RekeyLimit in the client to allow
rekeying based on elapsed time in addition to amount of traffic.
with djm@@ jmc@@, ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.57 2012/01/25 19:40:09 markus Exp $ */
d68 1
a68 1
void     packet_disconnect(const char *fmt,...) __attribute__((format(printf, 1, 2)));
@


1.57
log
@packet_read_poll() is not used anymore.
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.56 2011/05/06 21:14:05 djm Exp $ */
d112 2
a113 1
void	 packet_set_rekey_limit(u_int32_t);
@


1.56
log
@set traffic class for IPv6 traffic as we do for IPv4 TOS;
patch from lionel AT mamane.lu via Colin Watson in bz#1855;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.55 2010/11/13 23:27:50 djm Exp $ */
a53 1
int      packet_read_poll(void);
@


1.55
log
@allow ssh and sshd to set arbitrary TOS/DSCP/QoS values instead of
hardcoding lowdelay/throughput.

bz#1733 patch from philipp AT redfish-solutions.com; ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.54 2010/08/31 11:54:45 djm Exp $ */
a88 1
int	 packet_connection_is_ipv4(void);
@


1.54
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.53 2010/08/31 09:58:37 djm Exp $ */
d35 1
a35 1
void     packet_set_interactive(int);
@


1.53
log
@Add buffer_get_cstring() and related functions that verify that the
string extracted from the buffer contains no embedded \0 characters*
This prevents random (possibly malicious) crap from being appended to
strings where it would not be noticed if the string is used with
a string(3) function.

Use the new API in a few sensitive places.

* actually, we allow a single one at the end of the string for now because
we don't know how many deployed implementations get this wrong, but don't
count on this to remain indefinitely.
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.52 2009/06/27 09:29:06 andreas Exp $ */
d22 1
d46 1
d64 1
@


1.52
log
@packet_bacup_state() and packet_restore_state() will be used to
temporarily save the current state ren resuming a suspended connection.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.51 2009/05/27 06:36:07 andreas Exp $ */
d64 1
@


1.51
log
@Add packet_put_int64() and packet_get_int64(), part of a larger change
from Martin Forssen.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.50 2009/05/25 06:48:01 andreas Exp $ */
d111 3
@


1.50
log
@Put the globals in packet.c into a struct and don't access it directly
from other files. No functional changes.
ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.49 2008/07/10 18:08:11 markus Exp $ */
d42 1
d59 1
@


1.49
log
@sync v1 and v2 traffic accounting; add it to sshd, too; ok djm@@, dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.48 2008/06/12 20:38:28 dtucker Exp $ */
d75 1
d91 2
a92 2
extern u_int max_packet_size;
extern int keep_alive_timeouts;
d94 1
a94 1
#define  packet_get_maxsize() max_packet_size
d109 3
@


1.48
log
@Make keepalive timeouts apply while waiting for a packet, particularly during
key renegotiation (bz #1363).  With djm and Matt Day, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.47 2008/05/08 06:59:01 markus Exp $ */
d71 2
a72 2
void	 packet_get_state(int, u_int32_t *, u_int64_t *, u_int32_t *);
void	 packet_set_state(int, u_int32_t, u_int64_t, u_int32_t);
@


1.47
log
@avoid extra malloc/copy/free when receiving data over the net;
~10% speedup for localhost-scp; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.46 2008/02/22 20:44:02 dtucker Exp $ */
d24 1
@


1.46
log
@Allow all SSH2 packet types, including UNIMPLEMENTED to reset the
keepalive timer (bz #1307).  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.45 2006/03/25 22:22:43 djm Exp $ */
d61 1
@


1.45
log
@standardise spacing in $OpenBSD$ tags; requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.44 2006/02/07 01:42:00 stevesk Exp $ */
d89 1
@


1.44
log
@move #include <termios.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.43 2005/07/25 11:59:40 markus Exp $	*/
@


1.44.2.1
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.45 2006/03/25 22:22:43 djm Exp $ */
@


1.43
log
@add a new compression method that delays compression until the user
has been authenticated successfully and set compression to 'delayed'
for sshd.

this breaks older openssh clients (< 3.5) if they insist on
compression, so you have to re-enable compression in sshd_config.
ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.42 2005/06/17 02:44:33 djm Exp $	*/
d18 2
@


1.43.2.1
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: packet.h,v 1.45 2006/03/25 22:22:43 djm Exp $ */
a17 2

#include <termios.h>
@


1.42
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.41 2004/05/11 19:01:43 deraadt Exp $	*/
d33 2
@


1.41
log
@improve some code lint did not like; djm millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.40 2003/06/24 08:23:46 markus Exp $	*/
d55 1
a55 1
void	*packet_get_raw(int *length_ptr);
@


1.41.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.43 2005/07/25 11:59:40 markus Exp $	*/
a32 2
void     packet_set_server(void);
void     packet_set_authenticated(void);
d55 1
a55 1
void	*packet_get_raw(u_int *length_ptr);
@


1.41.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.43 2005/07/25 11:59:40 markus Exp $	*/
a32 2
void     packet_set_server(void);
void     packet_set_authenticated(void);
d55 1
a55 1
void	*packet_get_raw(u_int *length_ptr);
@


1.40
log
@int -> u_int; ok djm@@, deraadt@@, mouring@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.39 2003/04/08 20:21:29 itojun Exp $	*/
d85 1
a85 1
u_int	 packet_set_maxsize(u_int);
@


1.40.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.41 2004/05/11 19:01:43 deraadt Exp $	*/
d85 1
a85 1
int	 packet_set_maxsize(u_int);
@


1.40.4.1
log
@upgrade to OpenSSH 3.9
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.41 2004/05/11 19:01:43 deraadt Exp $	*/
d85 1
a85 1
int	 packet_set_maxsize(u_int);
@


1.39
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.38 2003/04/02 09:48:07 markus Exp $	*/
d84 2
a85 2
extern int max_packet_size;
int      packet_set_maxsize(int);
@


1.38
log
@reapply rekeying chage, tested by henning@@, ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.37 2003/04/01 10:22:21 markus Exp $	*/
d93 1
a93 1
		log("Packet integrity error (%d bytes remaining) at %s:%d", \
@


1.37
log
@backout rekeying changes (for 3.6.1)
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.36 2003/04/01 10:10:23 markus Exp $	*/
d65 2
a66 2
u_int32_t packet_get_seqnr(int);
void	 packet_set_seqnr(int, u_int32_t);
d98 3
@


1.36
log
@rekeying bugfixes and automatic rekeying:

* both client and server rekey _automatically_
      (a) after 2^31 packets, because after 2^32 packets
          the sequence number for packets wraps
      (b) after 2^(blocksize_in_bits/4) blocks
  (see: http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-00.txt)
  (a) and (b) are _enabled_ by default, and only disabled for known
  openssh versions, that don't support rekeying properly.
* client option 'RekeyLimit'
* do not reply to requests during rekeying
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.35 2002/06/19 18:01:00 markus Exp $	*/
d65 2
a66 2
void	 packet_get_state(int, u_int32_t *, u_int64_t *, u_int32_t *);
void	 packet_set_state(int, u_int32_t, u_int64_t, u_int32_t);
a97 3

int	 packet_need_rekeying(void);
void	 packet_set_rekey_limit(u_int32_t);
@


1.35
log
@make the monitor sync the transfer ssh1 session key;
transfer keycontext only for RC4 (this is still depends on EVP
implementation details and is broken).
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.34 2002/03/18 17:16:38 markus Exp $	*/
d65 2
a66 2
u_int32_t packet_get_seqnr(int);
void	 packet_set_seqnr(int, u_int32_t);
d98 3
@


1.35.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.40 2003/06/24 08:23:46 markus Exp $	*/
d65 2
a66 2
void	 packet_get_state(int, u_int32_t *, u_int64_t *, u_int32_t *);
void	 packet_set_state(int, u_int32_t, u_int64_t, u_int32_t);
d84 2
a85 2
extern u_int max_packet_size;
u_int	 packet_set_maxsize(u_int);
d93 1
a93 1
		logit("Packet integrity error (%d bytes remaining) at %s:%d", \
a97 3

int	 packet_need_rekeying(void);
void	 packet_set_rekey_limit(u_int32_t);
@


1.35.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.40 2003/06/24 08:23:46 markus Exp $	*/
d65 2
a66 2
void	 packet_get_state(int, u_int32_t *, u_int64_t *, u_int32_t *);
void	 packet_set_state(int, u_int32_t, u_int64_t, u_int32_t);
d84 2
a85 2
extern u_int max_packet_size;
u_int	 packet_set_maxsize(u_int);
d93 1
a93 1
		logit("Packet integrity error (%d bytes remaining) at %s:%d", \
a97 3

int	 packet_need_rekeying(void);
void	 packet_set_rekey_limit(u_int32_t);
@


1.35.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@@


1.34
log
@export/import cipher state, iv and ssh2 seqnr; needed by ssh-privsep
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.33 2002/03/04 17:27:39 stevesk Exp $	*/
d27 1
@


1.34.2.1
log
@Pull in OpenSSH-3.4
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.35 2002/06/19 18:01:00 markus Exp $	*/
a26 1
u_int	 packet_get_encryption_key(u_char *);
@


1.33
log
@$OpenBSD$ and RCSID() cleanup: don't use RCSID() in .h files; add
missing RCSID() to .c files and remove dup /*$OpenBSD$*/ from .c
files.  ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.32 2001/12/28 14:50:54 markus Exp $	*/
d58 10
@


1.32
log
@packet_read* no longer return the packet length, since it's not used.
@
text
@d1 2
a14 2

/* RCSID("$OpenBSD: packet.h,v 1.31 2001/12/28 13:57:33 markus Exp $"); */
@


1.31
log
@packet_get_bignum* no longer returns a size
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.30 2001/12/28 12:14:27 markus Exp $"); */
d43 3
a45 3
int      packet_read(int *payload_len_ptr);
void     packet_read_expect(int *payload_len_ptr, int type);
int      packet_read_poll(int *packet_len_ptr);
d47 2
a48 2
int      packet_read_seqnr(int *payload_len_ptr, u_int32_t *seqnr_p);
int      packet_read_poll_seqnr(int *packet_len_ptr, u_int32_t *seqnr_p);
@


1.30
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.29 2001/12/27 20:39:58 markus Exp $"); */
d52 2
a53 2
void     packet_get_bignum(BIGNUM * value, int *length_ptr);
void     packet_get_bignum2(BIGNUM * value, int *length_ptr);
@


1.29
log
@get rid of packet_integrity_check, use packet_done() instead.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.28 2001/12/20 22:50:24 djm Exp $"); */
d77 2
a78 1
#define packet_done() \
@


1.28
log
@Conformance fix: we should send failing packet sequence number when
responding with a SSH_MSG_UNIMPLEMENTED message. Spotted by
yakk@@yakk.dot.net; ok markus@@
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.27 2001/12/19 17:16:13 stevesk Exp $"); */
a75 10

#define packet_integrity_check(payload_len, expected_len, type) \
do { \
	int _p = (payload_len), _e = (expected_len); \
	if (_p != _e) { \
		log("Packet integrity error (%d != %d) at %s:%d", \
		    _p, _e, __FILE__, __LINE__); \
		packet_disconnect("Packet integrity error. (%d)", (type)); \
	} \
} while (0)
@


1.27
log
@change the buffer/packet interface to use void* vs. char*; ok markus@@
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.26 2001/11/07 16:03:17 markus Exp $"); */
d47 2
@


1.26
log
@pad using the padding field from the ssh2 packet instead of sending
extra ignore messages. tested against several other ssh servers.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.25 2001/06/26 17:27:24 markus Exp $"); */
d38 1
a38 1
void     packet_put_string(const char *buf, u_int len);
d40 1
a40 1
void     packet_put_raw(const char *buf, u_int len);
d52 2
a53 2
char	*packet_get_raw(int *length_ptr);
char    *packet_get_string(u_int *length_ptr);
@


1.25
log
@remove comments from .h, since they are cut&paste from the .c files
and out of sync
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.24 2001/06/26 06:32:57 itojun Exp $"); */
d66 1
a66 1
void	 packet_inject_ignore(int);
@


1.25.2.1
log
@Pull in patches from current (Errata 002):
Update to OpenSSH-3.0.1 via errata patch (Instead of using release tarball)
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.26 2001/11/07 16:03:17 markus Exp $"); */
d66 1
a66 1
void	 packet_add_padding(u_char);
@


1.25.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@a0 2
/*	$OpenBSD: packet.h,v 1.33 2002/03/04 17:27:39 stevesk Exp $	*/

d14 2
d38 1
a38 1
void     packet_put_string(const void *buf, u_int len);
d40 1
a40 1
void     packet_put_raw(const void *buf, u_int len);
d43 3
a45 3
int      packet_read(void);
void     packet_read_expect(int type);
int      packet_read_poll(void);
a46 2
int      packet_read_seqnr(u_int32_t *seqnr_p);
int      packet_read_poll_seqnr(u_int32_t *seqnr_p);
d50 4
a53 4
void     packet_get_bignum(BIGNUM * value);
void     packet_get_bignum2(BIGNUM * value);
void	*packet_get_raw(int *length_ptr);
void	*packet_get_string(u_int *length_ptr);
d75 11
a85 2
/* don't allow remaining bytes after the end of the message */
#define packet_check_eom() \
@


1.25.2.3
log
@Update OpenSSH to version 3.2.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.34 2002/03/18 17:16:38 markus Exp $	*/
a57 10

void	 set_newkeys(int mode);
int	 packet_get_keyiv_len(int);
void	 packet_get_keyiv(int, u_char *, u_int);
int	 packet_get_keycontext(int, u_char *);
void	 packet_set_keycontext(int, u_char *);
u_int32_t packet_get_seqnr(int);
void	 packet_set_seqnr(int, u_int32_t);
int	 packet_get_ssh1_cipher(void);
void	 packet_set_iv(int, u_char *);
@


1.25.2.4
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.25.2.3 2002/05/17 00:03:23 miod Exp $	*/
a26 1
u_int	 packet_get_encryption_key(u_char *);
@


1.24
log
@prototype pedant.  not very creative...
- () -> (void)
- no variable names
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.23 2001/05/28 23:58:35 markus Exp $"); */
d21 31
a51 112
/*
 * Sets the socket used for communication.  Disables encryption until
 * packet_set_encryption_key is called.  It is permissible that fd_in and
 * fd_out are the same descriptor; in that case it is assumed to be a socket.
 */
void    packet_set_connection(int, int);

/* Puts the connection file descriptors into non-blocking mode. */
void    packet_set_nonblocking(void);

/* Returns the file descriptor used for input. */
int     packet_get_connection_in(void);

/* Returns the file descriptor used for output. */
int     packet_get_connection_out(void);

/*
 * Closes the connection (both descriptors) and clears and frees internal
 * data structures.
 */
void    packet_close(void);

/*
 * Causes any further packets to be encrypted using the given key.  The same
 * key is used for both sending and reception.  However, both directions are
 * encrypted independently of each other.  Cipher types are defined in ssh.h.
 */
void
packet_set_encryption_key(const u_char *, u_int, int);

/*
 * Sets remote side protocol flags for the current connection.  This can be
 * called at any time.
 */
void    packet_set_protocol_flags(u_int);

/* Returns the remote protocol flags set earlier by the above function. */
u_int packet_get_protocol_flags(void);

/* Enables compression in both directions starting from the next packet. */
void    packet_start_compression(int);

/*
 * Informs that the current session is interactive.  Sets IP flags for
 * optimal performance in interactive use.
 */
void    packet_set_interactive(int);

/* Returns true if the current connection is interactive. */
int     packet_is_interactive(void);

/* Starts constructing a packet to send. */
void    packet_start(u_char);

/* Appends a character to the packet data. */
void    packet_put_char(int ch);

/* Appends an integer to the packet data. */
void    packet_put_int(u_int value);

/* Appends an arbitrary precision integer to packet data. */
void    packet_put_bignum(BIGNUM * value);
void    packet_put_bignum2(BIGNUM * value);

/* Appends a string to packet data. */
void    packet_put_string(const char *buf, u_int len);
void    packet_put_cstring(const char *str);
void    packet_put_raw(const char *buf, u_int len);

/*
 * Finalizes and sends the packet.  If the encryption key has been set,
 * encrypts the packet before sending.
 */
void    packet_send(void);

/* Waits until a packet has been received, and returns its type. */
int     packet_read(int *payload_len_ptr);

/*
 * Waits until a packet has been received, verifies that its type matches
 * that given, and gives a fatal error and exits if there is a mismatch.
 */
void    packet_read_expect(int *payload_len_ptr, int type);

/*
 * Checks if a full packet is available in the data received so far via
 * packet_process_incoming.  If so, reads the packet; otherwise returns
 * SSH_MSG_NONE.  This does not wait for data from the connection.
 * SSH_MSG_DISCONNECT is handled specially here.  Also, SSH_MSG_IGNORE
 * messages are skipped by this function and are never returned to higher
 * levels.
 */
int     packet_read_poll(int *packet_len_ptr);

/*
 * Buffers the given amount of input characters.  This is intended to be used
 * together with packet_read_poll.
 */
void    packet_process_incoming(const char *buf, u_int len);

/* Returns a character (0-255) from the packet data. */
u_int packet_get_char(void);

/* Returns an integer from the packet data. */
u_int packet_get_int(void);

/*
 * Returns an arbitrary precision integer from the packet data.  The integer
 * must have been initialized before this call.
 */
void    packet_get_bignum(BIGNUM * value, int *length_ptr);
void    packet_get_bignum2(BIGNUM * value, int *length_ptr);
d53 14
d68 2
a69 33
/*
 * Returns a string from the packet data.  The string is allocated using
 * xmalloc; it is the responsibility of the calling program to free it when
 * no longer needed.  The length_ptr argument may be NULL, or point to an
 * integer into which the length of the string is stored.
 */
char   *packet_get_string(u_int *length_ptr);

/*
 * Logs the error in syslog using LOG_INFO, constructs and sends a disconnect
 * packet, closes the connection, and exits.  This function never returns.
 * The error message should not contain a newline.  The total length of the
 * message must not exceed 1024 bytes.
 */
void    packet_disconnect(const char *fmt,...) __attribute__((format(printf, 1, 2)));

/*
 * Sends a diagnostic message to the other side.  This message can be sent at
 * any time (but not while constructing another message). The message is
 * printed immediately, but only if the client is being executed in verbose
 * mode.  These messages are primarily intended to ease debugging
 * authentication problems.  The total length of the message must not exceed
 * 1024 bytes.  This will automatically call packet_write_wait.  If the
 * remote side protocol flags do not indicate that it supports SSH_MSG_DEBUG,
 * this will do nothing.
 */
void    packet_send_debug(const char *fmt,...) __attribute__((format(printf, 1, 2)));

/* Checks if there is any buffered output, and tries to write some of the output. */
void    packet_write_poll(void);

/* Waits until all pending output data has been written. */
void    packet_write_wait(void);
a70 7
/* Returns true if there is buffered data to write to the connection. */
int     packet_have_data_to_write(void);

/* Returns true if there is not too much data to write to the connection. */
int     packet_not_very_much_data_to_write(void);

/* maximum packet size, requested by client with SSH_CMSG_MAX_PACKET_SIZE */
d72 2
a73 8
int     packet_set_maxsize(int);
#define packet_get_maxsize() max_packet_size

/* Stores tty modes from the fd or tiop into current packet. */
void    tty_make_modes(int, struct termios *);

/* Parses tty modes for the fd from the current packet. */
void    tty_parse_modes(int, int *);
d77 6
a82 6
  int _p = (payload_len), _e = (expected_len); \
  if (_p != _e) { \
    log("Packet integrity error (%d != %d) at %s:%d", \
	_p, _e, __FILE__, __LINE__); \
    packet_disconnect("Packet integrity error. (%d)", (type)); \
  } \
a93 13

/* remote host is connected via a socket/ipv4 */
int	packet_connection_is_on_socket(void);
int	packet_connection_is_ipv4(void);

/* returns remaining payload bytes */
int	packet_remaining(void);

/* append an ignore message */
void	packet_send_ignore(int);

/* add an ignore message and make sure size (current+ignore) = n*sumlen */
void	packet_inject_ignore(int);
@


1.23
log
@remove some lines, simplify.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.22 2001/04/14 16:33:20 stevesk Exp $"); */
d26 1
a26 1
void    packet_set_connection(int fd_in, int fd_out);
d49 1
a49 2
packet_set_encryption_key(const u_char *key, u_int keylen,
    int cipher_type);
d55 1
a55 1
void    packet_set_protocol_flags(u_int flags);
d61 1
a61 1
void    packet_start_compression(int level);
d67 1
a67 1
void    packet_set_interactive(int interactive);
d73 1
a73 1
void    packet_start(u_char type);
d177 1
a177 1
int     packet_set_maxsize(int s);
d181 1
a181 1
void    tty_make_modes(int fd, struct termios *tiop);
d184 1
a184 1
void    tty_parse_modes(int fd, int *n_bytes_ptr);
d214 1
a214 1
void	packet_send_ignore(int nbytes);
d217 1
a217 1
void	packet_inject_ignore(int sumlen);
@


1.22
log
@protocol 2 tty modes support; ok markus@@
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.21 2001/02/28 21:27:47 markus Exp $"); */
d74 1
a74 1
void    packet_start(int type);
a209 3

/* enable SSH2 packet format */
void	packet_set_ssh2_format(void);
@


1.22.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.25 2001/06/26 17:27:24 markus Exp $"); */
d21 113
a133 31
void     packet_set_connection(int, int);
void     packet_set_nonblocking(void);
int      packet_get_connection_in(void);
int      packet_get_connection_out(void);
void     packet_close(void);
void	 packet_set_encryption_key(const u_char *, u_int, int);
void     packet_set_protocol_flags(u_int);
u_int	 packet_get_protocol_flags(void);
void     packet_start_compression(int);
void     packet_set_interactive(int);
int      packet_is_interactive(void);

void     packet_start(u_char);
void     packet_put_char(int ch);
void     packet_put_int(u_int value);
void     packet_put_bignum(BIGNUM * value);
void     packet_put_bignum2(BIGNUM * value);
void     packet_put_string(const char *buf, u_int len);
void     packet_put_cstring(const char *str);
void     packet_put_raw(const char *buf, u_int len);
void     packet_send(void);

int      packet_read(int *payload_len_ptr);
void     packet_read_expect(int *payload_len_ptr, int type);
int      packet_read_poll(int *packet_len_ptr);
void     packet_process_incoming(const char *buf, u_int len);

u_int	 packet_get_char(void);
u_int	 packet_get_int(void);
void     packet_get_bignum(BIGNUM * value, int *length_ptr);
void     packet_get_bignum2(BIGNUM * value, int *length_ptr);
a134 14
char    *packet_get_string(u_int *length_ptr);
void     packet_disconnect(const char *fmt,...) __attribute__((format(printf, 1, 2)));
void     packet_send_debug(const char *fmt,...) __attribute__((format(printf, 1, 2)));

void     packet_write_poll(void);
void     packet_write_wait(void);
int      packet_have_data_to_write(void);
int      packet_not_very_much_data_to_write(void);

int	 packet_connection_is_on_socket(void);
int	 packet_connection_is_ipv4(void);
int	 packet_remaining(void);
void	 packet_send_ignore(int);
void	 packet_inject_ignore(int);
d136 33
a168 2
void	 tty_make_modes(int, struct termios *);
void	 tty_parse_modes(int, int *);
d170 7
d178 8
a185 2
int      packet_set_maxsize(int);
#define  packet_get_maxsize() max_packet_size
d189 6
a194 6
	int _p = (payload_len), _e = (expected_len); \
	if (_p != _e) { \
		log("Packet integrity error (%d != %d) at %s:%d", \
		    _p, _e, __FILE__, __LINE__); \
		packet_disconnect("Packet integrity error. (%d)", (type)); \
	} \
d206 16
@


1.22.2.2
log
@Merge OpenSSH 3.0.1.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.22.2.1 2001/09/27 19:03:54 jason Exp $"); */
d66 1
a66 1
void	 packet_add_padding(u_char);
@


1.22.2.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@a0 2
/*	$OpenBSD: packet.h,v 1.33 2002/03/04 17:27:39 stevesk Exp $	*/

d14 2
d38 1
a38 1
void     packet_put_string(const void *buf, u_int len);
d40 1
a40 1
void     packet_put_raw(const void *buf, u_int len);
d43 3
a45 3
int      packet_read(void);
void     packet_read_expect(int type);
int      packet_read_poll(void);
a46 2
int      packet_read_seqnr(u_int32_t *seqnr_p);
int      packet_read_poll_seqnr(u_int32_t *seqnr_p);
d50 4
a53 4
void     packet_get_bignum(BIGNUM * value);
void     packet_get_bignum2(BIGNUM * value);
void	*packet_get_raw(int *length_ptr);
void	*packet_get_string(u_int *length_ptr);
d75 11
a85 2
/* don't allow remaining bytes after the end of the message */
#define packet_check_eom() \
@


1.22.2.4
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.h,v 1.34 2002/03/18 17:16:38 markus Exp $	*/
a57 10

void	 set_newkeys(int mode);
int	 packet_get_keyiv_len(int);
void	 packet_get_keyiv(int, u_char *, u_int);
int	 packet_get_keycontext(int, u_char *);
void	 packet_set_keycontext(int, u_char *);
u_int32_t packet_get_seqnr(int);
void	 packet_set_seqnr(int, u_int32_t);
int	 packet_get_ssh1_cipher(void);
void	 packet_set_iv(int, u_char *);
@


1.21
log
@use ignore message to simulate a SSH2_MSG_CHANNEL_DATA message
use random content in ignore messages.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.20 2001/02/28 09:57:07 markus Exp $"); */
d181 2
a182 2
/* Stores tty modes from the fd into current packet. */
void    tty_make_modes(int fd);
@


1.20
log
@in ssh protocol v2 use ignore messages for padding (instead of trailing \0).
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.19 2001/01/13 18:32:50 markus Exp $"); */
d218 3
@


1.19
log
@split out keepalive from packet_interactive (from dale@@accentre.com)
set IPTOS_LOWDELAY TCP_NODELAY IPTOS_THROUGHPUT for ssh2, too.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.18 2000/12/19 23:17:57 markus Exp $"); */
d216 3
@


1.18
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.17 2000/09/07 20:27:52 deraadt Exp $"); */
d68 1
a68 1
void    packet_set_interactive(int interactive, int keepalives);
@


1.17
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.16 2000/06/20 01:39:43 markus Exp $"); */
d49 1
a49 1
packet_set_encryption_key(const unsigned char *key, unsigned int keylen,
d56 1
a56 1
void    packet_set_protocol_flags(unsigned int flags);
d59 1
a59 1
unsigned int packet_get_protocol_flags(void);
d80 1
a80 1
void    packet_put_int(unsigned int value);
d87 1
a87 1
void    packet_put_string(const char *buf, unsigned int len);
d89 1
a89 1
void    packet_put_raw(const char *buf, unsigned int len);
d120 1
a120 1
void    packet_process_incoming(const char *buf, unsigned int len);
d123 1
a123 1
unsigned int packet_get_char(void);
d126 1
a126 1
unsigned int packet_get_int(void);
d142 1
a142 1
char   *packet_get_string(unsigned int *length_ptr);
@


1.17.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.19 2001/01/13 18:32:50 markus Exp $"); */
d49 1
a49 1
packet_set_encryption_key(const u_char *key, u_int keylen,
d56 1
a56 1
void    packet_set_protocol_flags(u_int flags);
d59 1
a59 1
u_int packet_get_protocol_flags(void);
d68 1
a68 1
void    packet_set_interactive(int interactive);
d80 1
a80 1
void    packet_put_int(u_int value);
d87 1
a87 1
void    packet_put_string(const char *buf, u_int len);
d89 1
a89 1
void    packet_put_raw(const char *buf, u_int len);
d120 1
a120 1
void    packet_process_incoming(const char *buf, u_int len);
d123 1
a123 1
u_int packet_get_char(void);
d126 1
a126 1
u_int packet_get_int(void);
d142 1
a142 1
char   *packet_get_string(u_int *length_ptr);
@


1.17.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.17.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.21 2001/02/28 21:27:47 markus Exp $"); */
a215 6

/* append an ignore message */
void	packet_send_ignore(int nbytes);

/* add an ignore message and make sure size (current+ignore) = n*sumlen */
void	packet_inject_ignore(int sumlen);
@


1.17.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.22 2001/04/14 16:33:20 stevesk Exp $"); */
d181 2
a182 2
/* Stores tty modes from the fd or tiop into current packet. */
void    tty_make_modes(int fd, struct termios *tiop);
@


1.17.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.25 2001/06/26 17:27:24 markus Exp $"); */
d21 113
a133 31
void     packet_set_connection(int, int);
void     packet_set_nonblocking(void);
int      packet_get_connection_in(void);
int      packet_get_connection_out(void);
void     packet_close(void);
void	 packet_set_encryption_key(const u_char *, u_int, int);
void     packet_set_protocol_flags(u_int);
u_int	 packet_get_protocol_flags(void);
void     packet_start_compression(int);
void     packet_set_interactive(int);
int      packet_is_interactive(void);

void     packet_start(u_char);
void     packet_put_char(int ch);
void     packet_put_int(u_int value);
void     packet_put_bignum(BIGNUM * value);
void     packet_put_bignum2(BIGNUM * value);
void     packet_put_string(const char *buf, u_int len);
void     packet_put_cstring(const char *str);
void     packet_put_raw(const char *buf, u_int len);
void     packet_send(void);

int      packet_read(int *payload_len_ptr);
void     packet_read_expect(int *payload_len_ptr, int type);
int      packet_read_poll(int *packet_len_ptr);
void     packet_process_incoming(const char *buf, u_int len);

u_int	 packet_get_char(void);
u_int	 packet_get_int(void);
void     packet_get_bignum(BIGNUM * value, int *length_ptr);
void     packet_get_bignum2(BIGNUM * value, int *length_ptr);
a134 14
char    *packet_get_string(u_int *length_ptr);
void     packet_disconnect(const char *fmt,...) __attribute__((format(printf, 1, 2)));
void     packet_send_debug(const char *fmt,...) __attribute__((format(printf, 1, 2)));

void     packet_write_poll(void);
void     packet_write_wait(void);
int      packet_have_data_to_write(void);
int      packet_not_very_much_data_to_write(void);

int	 packet_connection_is_on_socket(void);
int	 packet_connection_is_ipv4(void);
int	 packet_remaining(void);
void	 packet_send_ignore(int);
void	 packet_inject_ignore(int);
d136 33
a168 2
void	 tty_make_modes(int, struct termios *);
void	 tty_parse_modes(int, int *);
d170 7
d178 8
a185 2
int      packet_set_maxsize(int);
#define  packet_get_maxsize() max_packet_size
d189 6
a194 6
	int _p = (payload_len), _e = (expected_len); \
	if (_p != _e) { \
		log("Packet integrity error (%d != %d) at %s:%d", \
		    _p, _e, __FILE__, __LINE__); \
		packet_disconnect("Packet integrity error. (%d)", (type)); \
	} \
d206 16
@


1.17.2.6
log
@Merge OpenSSH 3.0.1.

This is likely to be the last commit to the 2.8-STABLE branch.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.17.2.5 2001/09/27 00:15:42 miod Exp $"); */
d66 1
a66 1
void	 packet_add_padding(u_char);
@


1.17.2.7
log
@Merge OpenSSH 3.1.
@
text
@a0 2
/*	$OpenBSD: packet.h,v 1.33 2002/03/04 17:27:39 stevesk Exp $	*/

d14 2
d38 1
a38 1
void     packet_put_string(const void *buf, u_int len);
d40 1
a40 1
void     packet_put_raw(const void *buf, u_int len);
d43 3
a45 3
int      packet_read(void);
void     packet_read_expect(int type);
int      packet_read_poll(void);
a46 2
int      packet_read_seqnr(u_int32_t *seqnr_p);
int      packet_read_poll_seqnr(u_int32_t *seqnr_p);
d50 4
a53 4
void     packet_get_bignum(BIGNUM * value);
void     packet_get_bignum2(BIGNUM * value);
void	*packet_get_raw(int *length_ptr);
void	*packet_get_string(u_int *length_ptr);
d75 11
a85 2
/* don't allow remaining bytes after the end of the message */
#define packet_check_eom() \
@


1.16
log
@OpenBSD tag
@
text
@a1 3
 *
 * packet.h
 *
a2 1
 *
a4 3
 *
 * Created: Sat Mar 18 02:02:14 1995 ylo
 *
d7 5
d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.15 2000/04/14 10:30:32 markus Exp $"); */
@


1.15
log
@whitespace cleanup
@
text
@d16 1
a16 1
/* RCSID("$Id: packet.h,v 1.14 2000/04/14 10:09:15 markus Exp $"); */
@


1.15.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d16 1
a16 1
/* RCSID("$OpenBSD: packet.h,v 1.16 2000/06/20 01:39:43 markus Exp $"); */
@


1.15.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a13 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d16 1
a16 1
/* RCSID("$OpenBSD: packet.h,v 1.17 2000/09/07 20:27:52 deraadt Exp $"); */
@


1.15.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.19 2001/01/13 18:32:50 markus Exp $"); */
d49 1
a49 1
packet_set_encryption_key(const u_char *key, u_int keylen,
d56 1
a56 1
void    packet_set_protocol_flags(u_int flags);
d59 1
a59 1
u_int packet_get_protocol_flags(void);
d68 1
a68 1
void    packet_set_interactive(int interactive);
d80 1
a80 1
void    packet_put_int(u_int value);
d87 1
a87 1
void    packet_put_string(const char *buf, u_int len);
d89 1
a89 1
void    packet_put_raw(const char *buf, u_int len);
d120 1
a120 1
void    packet_process_incoming(const char *buf, u_int len);
d123 1
a123 1
u_int packet_get_char(void);
d126 1
a126 1
u_int packet_get_int(void);
d142 1
a142 1
char   *packet_get_string(u_int *length_ptr);
@


1.15.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: packet.h,v 1.21 2001/02/28 21:27:47 markus Exp $"); */
a215 6

/* append an ignore message */
void	packet_send_ignore(int nbytes);

/* add an ignore message and make sure size (current+ignore) = n*sumlen */
void	packet_inject_ignore(int sumlen);
@


1.14
log
@check payload for (illegal) extra data
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d13 1
a13 1
 * 
d16 1
a16 1
/* RCSID("$Id: packet.h,v 1.13 2000/04/12 09:39:10 markus Exp $"); */
d50 1
a50 1
void 
@


1.13
log
@#include <ssl/foo.h> -> <openssh/foo.h>
@
text
@d16 1
a16 1
/* RCSID("$Id: packet.h,v 1.12 2000/04/03 20:12:55 markus Exp $"); */
d199 10
d215 3
@


1.12
log
@ssh2 packet format
@
text
@d16 1
a16 1
/* RCSID("$Id: packet.h,v 1.3 2000/03/31 09:40:42 markus Exp $"); */
d21 1
a21 1
#include <ssl/bn.h>
@


1.11
log
@channel layer support for ssh2
@
text
@d16 1
a16 1
/* RCSID("$Id: packet.h,v 1.10 2000/03/16 20:56:14 markus Exp $"); */
d135 1
a135 1
void	packet_get_bignum2(BIGNUM * value, int *length_ptr);
d202 3
@


1.10
log
@-pedantic: signed vs. unsigned, void*-arithm, etc
@
text
@d16 1
a16 1
/* RCSID("$Id: packet.h,v 1.9 2000/01/04 16:54:58 markus Exp $"); */
d86 1
d90 2
d135 2
@


1.9
log
@allow auth-kerberos for IPv4 only
@
text
@d16 1
a16 1
/* RCSID("$Id: packet.h,v 1.8 2000/01/04 00:07:59 markus Exp $"); */
d147 1
a147 1
void    packet_disconnect(const char *fmt,...) __attribute__((format(printf, 1, 2)));;
d159 1
a159 1
void    packet_send_debug(const char *fmt,...) __attribute__((format(printf, 1, 2)));;
@


1.8
log
@ipv6 support: mostly gethostbyname->getaddrinfo/getnameinfo, new features:
sshd allows multiple ListenAddress and Port options.  note that libwrap is
not IPv6-ready. (based on patches from <kick@@kyoto.wide.ad.jp> and
fujiwara@@rcac.tdi.co.jp)
@
text
@d16 1
a16 1
/* RCSID("$Id: packet.h,v 1.7 1999/12/27 10:46:11 markus Exp $"); */
d194 1
a194 1
/* remote host is connected via a socket */
d196 1
@


1.7
log
@check format string for packet_disconnect and packet_send_debug, too
@
text
@d16 1
a16 1
/* RCSID("$Id: packet.h,v 1.6 1999/11/24 19:53:48 markus Exp $"); */
d193 3
@


1.6
log
@KNF, final part 3
@
text
@d16 1
a16 1
/* RCSID("$Id: packet.h,v 1.5 1999/11/24 00:26:02 deraadt Exp $"); */
d147 1
a147 1
void    packet_disconnect(const char *fmt,...);
d159 1
a159 1
void    packet_send_debug(const char *fmt,...);
@


1.5
log
@much more KNF
@
text
@d16 1
a16 1
/* RCSID("$Id: packet.h,v 1.4 1999/11/19 19:58:18 markus Exp $"); */
d23 5
a27 4
/* Sets the socket used for communication.  Disables encryption until
   packet_set_encryption_key is called.  It is permissible that fd_in
   and fd_out are the same descriptor; in that case it is assumed to
   be a socket. */
d39 4
a42 2
/* Closes the connection (both descriptors) and clears and frees
   internal data structures. */
d45 5
a49 4
/* Causes any further packets to be encrypted using the given key.  The same
   key is used for both sending and reception.  However, both directions
   are encrypted independently of each other.  Cipher types are
   defined in ssh.h. */
d54 4
a57 2
/* Sets remote side protocol flags for the current connection.  This can
   be called at any time. */
d66 4
a69 2
/* Informs that the current session is interactive.  Sets IP flags for optimal
   performance in interactive use. */
d90 4
a93 2
/* Finalizes and sends the packet.  If the encryption key has been set,
   encrypts the packet before sending. */
d99 4
a102 2
/* Waits until a packet has been received, verifies that its type matches
   that given, and gives a fatal error and exits if there is a mismatch. */
d105 8
a112 7
/* Checks if a full packet is available in the data received so far via
   packet_process_incoming.  If so, reads the packet; otherwise returns
   SSH_MSG_NONE.  This does not wait for data from the connection.

   SSH_MSG_DISCONNECT is handled specially here.  Also,
   SSH_MSG_IGNORE messages are skipped by this function and are never returned
   to higher levels. */
d115 4
a118 2
/* Buffers the given amount of input characters.  This is intended to be
   used together with packet_read_poll. */
d127 4
a130 2
/* Returns an arbitrary precision integer from the packet data.  The integer
   must have been initialized before this call. */
d133 6
a138 4
/* Returns a string from the packet data.  The string is allocated using
   xmalloc; it is the responsibility of the calling program to free it when
   no longer needed.  The length_ptr argument may be NULL, or point to an
   integer into which the length of the string is stored. */
d141 6
a146 4
/* Logs the error in syslog using LOG_INFO, constructs and sends a disconnect
   packet, closes the connection, and exits.  This function never returns.
   The error message should not contain a newline.  The total length of the
   message must not exceed 1024 bytes. */
d149 10
a158 8
/* Sends a diagnostic message to the other side.  This message
   can be sent at any time (but not while constructing another message).
   The message is printed immediately, but only if the client is being
   executed in verbose mode.  These messages are primarily intended to
   ease debugging authentication problems.  The total length of the message
   must not exceed 1024 bytes.  This will automatically call
   packet_write_wait.  If the remote side protocol flags do not indicate
   that it supports SSH_MSG_DEBUG, this will do nothing. */
d161 1
a161 2
/* Checks if there is any buffered output, and tries to write some of the
   output. */
@


1.4
log
@SSH_CMSG_MAX_PACKET_SIZE, some clients use this, some need this, niels@@
[hope this time my ISP stays alive during commit]
@
text
@d2 13
d16 1
a16 14
packet.h

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Sat Mar 18 02:02:14 1995 ylo

Interface for the packet protocol functions.

*/

/* RCSID("$Id: packet.h,v 1.3 1999/11/15 21:38:54 markus Exp $"); */
d27 1
a27 1
void packet_set_connection(int fd_in, int fd_out);
d30 1
a30 1
void packet_set_nonblocking(void);
d33 1
a33 1
int packet_get_connection_in(void);
d36 1
a36 1
int packet_get_connection_out(void);
d39 2
a40 2
   internal data structures. */ 
void packet_close(void);
d46 3
a48 2
void packet_set_encryption_key(const unsigned char *key, unsigned int keylen,
			       int cipher_type);
d52 1
a52 1
void packet_set_protocol_flags(unsigned int flags);
d58 1
a58 1
void packet_start_compression(int level);
d62 1
a62 1
void packet_set_interactive(int interactive, int keepalives);
d65 1
a65 1
int packet_is_interactive(void);
d68 1
a68 1
void packet_start(int type);
d71 1
a71 1
void packet_put_char(int ch);
d74 1
a74 1
void packet_put_int(unsigned int value);
d77 1
a77 1
void packet_put_bignum(BIGNUM *value);
d80 1
a80 1
void packet_put_string(const char *buf, unsigned int len);
d84 1
a84 1
void packet_send(void);
d87 1
a87 1
int packet_read(int *payload_len_ptr);
d91 1
a91 1
void packet_read_expect(int *payload_len_ptr, int type);
d95 2
a96 2
   SSH_MSG_NONE.  This does not wait for data from the connection. 
   
d100 1
a100 1
int packet_read_poll(int *packet_len_ptr);
d104 1
a104 1
void packet_process_incoming(const char *buf, unsigned int len);
d114 1
a114 1
void packet_get_bignum(BIGNUM *value, int *length_ptr);
d120 1
a120 1
char *packet_get_string(unsigned int *length_ptr);
d126 1
a126 1
void packet_disconnect(const char *fmt, ...);
d136 1
a136 1
void packet_send_debug(const char *fmt, ...);
d140 1
a140 1
void packet_write_poll(void);
d143 1
a143 1
void packet_write_wait(void);
d146 1
a146 1
int packet_have_data_to_write(void);
d149 1
a149 1
int packet_not_very_much_data_to_write(void);
d153 1
a153 1
int packet_set_maxsize(int s);
d157 1
a157 1
void tty_make_modes(int fd);
d160 1
a160 1
void tty_parse_modes(int fd, int *n_bytes_ptr);
d172 1
a172 1
#endif /* PACKET_H */
@


1.3
log
@remove support for cipher RC4
@
text
@d16 1
a16 1
/* RCSID("$Id: packet.h,v 1.2 1999/09/28 04:45:36 provos Exp $"); */
d149 5
@


1.2
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d16 1
a16 1
/* RCSID("$Id: packet.h,v 1.9 1999/06/14 15:00:03 bg Exp $"); */
d47 1
a47 1
			       int cipher_type, int is_client);
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d21 1
a21 2
#include <gmp.h>
#include "randoms.h"
d27 1
a27 1
void packet_set_connection(int fd_in, int fd_out, RandomState *state);
d76 1
a76 1
void packet_put_mp_int(MP_INT *value);
d113 1
a113 1
void packet_get_mp_int(MP_INT *value, int *length_ptr);
@

