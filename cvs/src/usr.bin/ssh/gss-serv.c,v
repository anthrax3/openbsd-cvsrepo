head	1.30;
access;
symbols
	OPENBSD_6_2:1.30.0.2
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.29.0.10
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.8
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.4
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.2
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.8
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.12
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.10
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.6
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.4
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.4
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_2:1.3.0.6
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.30
date	2017.06.24.06.34.38;	author djm;	state Exp;
branches;
next	1.29;
commitid	t1sqOvl7ysAY3CkV;

1.29
date	2015.05.22.03.50.02;	author djm;	state Exp;
branches;
next	1.28;
commitid	FvDetWtDGSVa4xnt;

1.28
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	cBx23BaCk6gYBpRj;

1.27
date	2014.07.03.03.34.09;	author djm;	state Exp;
branches;
next	1.26;
commitid	O9Tt7hhD3nOW2fIY;

1.26
date	2014.02.26.20.28.44;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2013.07.20.01.55.13;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2011.08.01.19.18.15;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.08.12.02.23;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.12.08.20.00;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.18;

1.18
date	2006.07.02.18.36.47;	author stevesk;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.30.09.58.15;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.25.22.22.43;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.20.04.08.18;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.08.13.15.44;	author stevesk;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2005.10.13.22.24.31;	author stevesk;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.13.19.08.08;	author stevesk;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.13.14.20.37;	author stevesk;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.13.14.03.01;	author stevesk;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.19.11.48.10;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.30.22.08.05;	author djm;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2005.07.17.07.17.55;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.17.11.06.07;	author markus;	state Exp;
branches
	1.5.4.1
	1.5.6.1;
next	1.4;

1.4
date	2003.09.23.20.17.11;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.31.13.31.57;	author markus;	state Exp;
branches
	1.3.2.1
	1.3.4.1
	1.3.6.1;
next	1.2;

1.2
date	2003.08.31.13.30.18;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.22.10.56.09;	author markus;	state Exp;
branches;
next	;

1.3.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	;

1.3.4.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.3.6.1
date	2003.09.16.21.20.25;	author brad;	state Exp;
branches;
next	;

1.5.4.1
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.5.6.1
date	2005.09.04.18.40.02;	author brad;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.8.2.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.14.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.30
log
@refactor authentication logging

optionally record successful auth methods and public credentials
used in a file accessible to user sessions

feedback and ok markus@@
@
text
@/* $OpenBSD: gss-serv.c,v 1.29 2015/05/22 03:50:02 djm Exp $ */

/*
 * Copyright (c) 2001-2003 Simon Wilkinson. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/queue.h>

#ifdef GSSAPI

#include <string.h>

#include "xmalloc.h"
#include "buffer.h"
#include "key.h"
#include "hostfile.h"
#include "auth.h"
#include "log.h"
#include "channels.h"
#include "session.h"
#include "misc.h"
#include "servconf.h"

#include "ssh-gss.h"

extern ServerOptions options;

static ssh_gssapi_client gssapi_client =
    { GSS_C_EMPTY_BUFFER, GSS_C_EMPTY_BUFFER,
    GSS_C_NO_CREDENTIAL, NULL, {NULL, NULL, NULL, NULL}};

ssh_gssapi_mech gssapi_null_mech =
    { NULL, NULL, {0, NULL}, NULL, NULL, NULL, NULL};

#ifdef KRB5
extern ssh_gssapi_mech gssapi_kerberos_mech;
#endif

ssh_gssapi_mech* supported_mechs[]= {
#ifdef KRB5
	&gssapi_kerberos_mech,
#endif
	&gssapi_null_mech,
};

/*
 * ssh_gssapi_supported_oids() can cause sandbox violations, so prepare the
 * list of supported mechanisms before privsep is set up.
 */
static gss_OID_set supported_oids;

void
ssh_gssapi_prepare_supported_oids(void)
{
	ssh_gssapi_supported_oids(&supported_oids);
}

OM_uint32
ssh_gssapi_test_oid_supported(OM_uint32 *ms, gss_OID member, int *present)
{
	if (supported_oids == NULL)
		ssh_gssapi_prepare_supported_oids();
	return gss_test_oid_set_member(ms, member, supported_oids, present);
}

/*
 * Acquire credentials for a server running on the current host.
 * Requires that the context structure contains a valid OID
 */

/* Returns a GSSAPI error code */
/* Privileged (called from ssh_gssapi_server_ctx) */
static OM_uint32
ssh_gssapi_acquire_cred(Gssctxt *ctx)
{
	OM_uint32 status;
	char lname[NI_MAXHOST];
	gss_OID_set oidset;

	if (options.gss_strict_acceptor) {
		gss_create_empty_oid_set(&status, &oidset);
		gss_add_oid_set_member(&status, ctx->oid, &oidset);

		if (gethostname(lname, MAXHOSTNAMELEN)) {
			gss_release_oid_set(&status, &oidset);
			return (-1);
		}

		if (GSS_ERROR(ssh_gssapi_import_name(ctx, lname))) {
			gss_release_oid_set(&status, &oidset);
			return (ctx->major);
		}

		if ((ctx->major = gss_acquire_cred(&ctx->minor,
		    ctx->name, 0, oidset, GSS_C_ACCEPT, &ctx->creds,
		    NULL, NULL)))
			ssh_gssapi_error(ctx);

		gss_release_oid_set(&status, &oidset);
		return (ctx->major);
	} else {
		ctx->name = GSS_C_NO_NAME;
		ctx->creds = GSS_C_NO_CREDENTIAL;
	}
	return GSS_S_COMPLETE;
}

/* Privileged */
OM_uint32
ssh_gssapi_server_ctx(Gssctxt **ctx, gss_OID oid)
{
	if (*ctx)
		ssh_gssapi_delete_ctx(ctx);
	ssh_gssapi_build_ctx(ctx);
	ssh_gssapi_set_oid(*ctx, oid);
	return (ssh_gssapi_acquire_cred(*ctx));
}

/* Unprivileged */
void
ssh_gssapi_supported_oids(gss_OID_set *oidset)
{
	int i = 0;
	OM_uint32 min_status;
	int present;
	gss_OID_set supported;

	gss_create_empty_oid_set(&min_status, oidset);
	gss_indicate_mechs(&min_status, &supported);

	while (supported_mechs[i]->name != NULL) {
		if (GSS_ERROR(gss_test_oid_set_member(&min_status,
		    &supported_mechs[i]->oid, supported, &present)))
			present = 0;
		if (present)
			gss_add_oid_set_member(&min_status,
			    &supported_mechs[i]->oid, oidset);
		i++;
	}

	gss_release_oid_set(&min_status, &supported);
}


/* Wrapper around accept_sec_context
 * Requires that the context contains:
 *    oid
 *    credentials	(from ssh_gssapi_acquire_cred)
 */
/* Privileged */
OM_uint32
ssh_gssapi_accept_ctx(Gssctxt *ctx, gss_buffer_desc *recv_tok,
    gss_buffer_desc *send_tok, OM_uint32 *flags)
{
	OM_uint32 status;
	gss_OID mech;

	ctx->major = gss_accept_sec_context(&ctx->minor,
	    &ctx->context, ctx->creds, recv_tok,
	    GSS_C_NO_CHANNEL_BINDINGS, &ctx->client, &mech,
	    send_tok, flags, NULL, &ctx->client_creds);

	if (GSS_ERROR(ctx->major))
		ssh_gssapi_error(ctx);

	if (ctx->client_creds)
		debug("Received some client credentials");
	else
		debug("Got no client credentials");

	status = ctx->major;

	/* Now, if we're complete and we have the right flags, then
	 * we flag the user as also having been authenticated
	 */

	if (((flags == NULL) || ((*flags & GSS_C_MUTUAL_FLAG) &&
	    (*flags & GSS_C_INTEG_FLAG))) && (ctx->major == GSS_S_COMPLETE)) {
		if (ssh_gssapi_getclient(ctx, &gssapi_client))
			fatal("Couldn't convert client name");
	}

	return (status);
}

/*
 * This parses an exported name, extracting the mechanism specific portion
 * to use for ACL checking. It verifies that the name belongs the mechanism
 * originally selected.
 */
static OM_uint32
ssh_gssapi_parse_ename(Gssctxt *ctx, gss_buffer_t ename, gss_buffer_t name)
{
	u_char *tok;
	OM_uint32 offset;
	OM_uint32 oidl;

	tok = ename->value;

	/*
	 * Check that ename is long enough for all of the fixed length
	 * header, and that the initial ID bytes are correct
	 */

	if (ename->length < 6 || memcmp(tok, "\x04\x01", 2) != 0)
		return GSS_S_FAILURE;

	/*
	 * Extract the OID, and check it. Here GSSAPI breaks with tradition
	 * and does use the OID type and length bytes. To confuse things
	 * there are two lengths - the first including these, and the
	 * second without.
	 */

	oidl = get_u16(tok+2); /* length including next two bytes */
	oidl = oidl-2; /* turn it into the _real_ length of the variable OID */

	/*
	 * Check the BER encoding for correct type and length, that the
	 * string is long enough and that the OID matches that in our context
	 */
	if (tok[4] != 0x06 || tok[5] != oidl ||
	    ename->length < oidl+6 ||
	    !ssh_gssapi_check_oid(ctx, tok+6, oidl))
		return GSS_S_FAILURE;

	offset = oidl+6;

	if (ename->length < offset+4)
		return GSS_S_FAILURE;

	name->length = get_u32(tok+offset);
	offset += 4;

	if (UINT_MAX - offset < name->length)
		return GSS_S_FAILURE;
	if (ename->length < offset+name->length)
		return GSS_S_FAILURE;

	name->value = xmalloc(name->length+1);
	memcpy(name->value, tok+offset, name->length);
	((char *)name->value)[name->length] = 0;

	return GSS_S_COMPLETE;
}

/* Extract the client details from a given context. This can only reliably
 * be called once for a context */

/* Privileged (called from accept_secure_ctx) */
OM_uint32
ssh_gssapi_getclient(Gssctxt *ctx, ssh_gssapi_client *client)
{
	int i = 0;

	gss_buffer_desc ename;

	client->mech = NULL;

	while (supported_mechs[i]->name != NULL) {
		if (supported_mechs[i]->oid.length == ctx->oid->length &&
		    (memcmp(supported_mechs[i]->oid.elements,
		    ctx->oid->elements, ctx->oid->length) == 0))
			client->mech = supported_mechs[i];
		i++;
	}

	if (client->mech == NULL)
		return GSS_S_FAILURE;

	if ((ctx->major = gss_display_name(&ctx->minor, ctx->client,
	    &client->displayname, NULL))) {
		ssh_gssapi_error(ctx);
		return (ctx->major);
	}

	if ((ctx->major = gss_export_name(&ctx->minor, ctx->client,
	    &ename))) {
		ssh_gssapi_error(ctx);
		return (ctx->major);
	}

	if ((ctx->major = ssh_gssapi_parse_ename(ctx,&ename,
	    &client->exportedname))) {
		return (ctx->major);
	}

	/* We can't copy this structure, so we just move the pointer to it */
	client->creds = ctx->client_creds;
	ctx->client_creds = GSS_C_NO_CREDENTIAL;
	return (ctx->major);
}

/* As user - called on fatal/exit */
void
ssh_gssapi_cleanup_creds(void)
{
	if (gssapi_client.store.filename != NULL) {
		/* Unlink probably isn't sufficient */
		debug("removing gssapi cred file\"%s\"",
		    gssapi_client.store.filename);
		unlink(gssapi_client.store.filename);
	}
}

/* As user */
void
ssh_gssapi_storecreds(void)
{
	if (gssapi_client.mech && gssapi_client.mech->storecreds) {
		(*gssapi_client.mech->storecreds)(&gssapi_client);
	} else
		debug("ssh_gssapi_storecreds: Not a GSSAPI mechanism");
}

/* This allows GSSAPI methods to do things to the childs environment based
 * on the passed authentication process and credentials.
 */
/* As user */
void
ssh_gssapi_do_child(char ***envp, u_int *envsizep)
{

	if (gssapi_client.store.envvar != NULL &&
	    gssapi_client.store.envval != NULL) {
		debug("Setting %s to %s", gssapi_client.store.envvar,
		    gssapi_client.store.envval);
		child_set_env(envp, envsizep, gssapi_client.store.envvar,
		    gssapi_client.store.envval);
	}
}

/* Privileged */
int
ssh_gssapi_userok(char *user)
{
	OM_uint32 lmin;

	if (gssapi_client.exportedname.length == 0 ||
	    gssapi_client.exportedname.value == NULL) {
		debug("No suitable client data");
		return 0;
	}
	if (gssapi_client.mech && gssapi_client.mech->userok)
		if ((*gssapi_client.mech->userok)(&gssapi_client, user))
			return 1;
		else {
			/* Destroy delegated credentials if userok fails */
			gss_release_buffer(&lmin, &gssapi_client.displayname);
			gss_release_buffer(&lmin, &gssapi_client.exportedname);
			gss_release_cred(&lmin, &gssapi_client.creds);
			explicit_bzero(&gssapi_client,
			    sizeof(ssh_gssapi_client));
			return 0;
		}
	else
		debug("ssh_gssapi_userok: Unknown GSSAPI mechanism");
	return (0);
}

/* Privileged */
OM_uint32
ssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)
{
	ctx->major = gss_verify_mic(&ctx->minor, ctx->context,
	    gssbuf, gssmic, NULL);

	return (ctx->major);
}

/* Privileged */
const char *ssh_gssapi_displayname(void)
{
	if (gssapi_client.displayname.length == 0 ||
	    gssapi_client.displayname.value == NULL)
		return NULL;
	return (char *)gssapi_client.displayname.value;
}

#endif
@


1.29
log
@add knob to relax GSSAPI host credential check for multihomed hosts
bz#928, patch by Simon Wilkinson; ok dtucker
(kerberos/GSSAPI is not compiled by default on OpenBSD)
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.28 2015/01/20 23:14:00 deraadt Exp $ */
d390 9
@


1.28
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.27 2014/07/03 03:34:09 djm Exp $ */
d43 1
d47 2
d101 18
a118 7
	gss_create_empty_oid_set(&status, &oidset);
	gss_add_oid_set_member(&status, ctx->oid, &oidset);

	if (gethostname(lname, sizeof(lname))) {
		gss_release_oid_set(&status, &oidset);
		return (-1);
	}
a119 1
	if (GSS_ERROR(ssh_gssapi_import_name(ctx, lname))) {
d122 3
d126 1
a126 7

	if ((ctx->major = gss_acquire_cred(&ctx->minor,
	    ctx->name, 0, oidset, GSS_C_ACCEPT, &ctx->creds, NULL, NULL)))
		ssh_gssapi_error(ctx);

	gss_release_oid_set(&status, &oidset);
	return (ctx->major);
@


1.27
log
@standardise on NI_MAXHOST for gethostname() string lengths; about
1/2 the cases were using it already. Fixes bz#2239 en passant
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.26 2014/02/26 20:28:44 djm Exp $ */
a27 1
#include <sys/param.h>
@


1.26
log
@bz#2107 - cache OIDs of supported GSSAPI mechanisms before privsep
sandboxing, as running this code in the sandbox can cause violations;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.25 2014/02/02 03:44:31 djm Exp $ */
d96 1
a96 1
	char lname[MAXHOSTNAMELEN];
d102 1
a102 1
	if (gethostname(lname, MAXHOSTNAMELEN)) {
@


1.25
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.24 2013/07/20 01:55:13 djm Exp $ */
d65 19
@


1.24
log
@fix kerberos/GSSAPI deprecation warnings and linking; "looks okay" millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.23 2011/08/01 19:18:15 markus Exp $ */
d345 2
a346 1
			memset(&gssapi_client, 0, sizeof(ssh_gssapi_client));
@


1.23
log
@prevent post-auth resource exhaustion (int overflow leading to 4GB malloc);
report Adam Zabrock; ok djm@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.22 2008/05/08 12:02:23 djm Exp $ */
d49 1
a49 1
    GSS_C_NO_CREDENTIAL, NULL, {NULL, NULL, NULL}};
@


1.22
log
@Implement a channel success/failure status confirmation callback
mechanism. Each channel maintains a queue of callbacks, which will
be drained in order (RFC4253 guarantees confirm messages are not
reordered within an channel).

Also includes a abandonment callback to clean up if a channel is
closed without sending confirmation messages. This probably
shouldn't happen in compliant implementations, but it could be
abused to leak memory.

ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.21 2007/06/12 08:20:00 djm Exp $ */
d228 2
@


1.21
log
@relocate server-only GSSAPI code from libssh to server; bz #1225
patch from simon AT sxw.org.uk; ok markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.20 2006/08/03 03:34:42 deraadt Exp $ */
d29 1
@


1.20
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.19 2006/07/22 20:48:23 stevesk Exp $ */
d28 1
d63 47
@


1.19
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.18 2006/07/02 18:36:47 stevesk Exp $ */
d27 1
a27 1
#include "includes.h"
d33 4
a36 1
#include "bufaux.h"
a40 1
#include "xmalloc.h"
@


1.18
log
@no "servconf.h" needed here
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.17 2006/03/30 09:58:15 djm Exp $ */
d30 2
@


1.17
log
@replace {GET,PUT}_XXBIT macros with functionally similar functions,
silencing a heap of lint warnings. also allows them to use
__bounded__ checking which can't be applied to macros; requested
by and feedback from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.16 2006/03/25 22:22:43 djm Exp $ */
a35 1
#include "servconf.h"
@


1.16
log
@standardise spacing in $OpenBSD$ tags; requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.15 2006/03/20 04:08:18 djm Exp $ */
d38 1
a38 1
#include "getput.h"
d156 1
a156 1
	oidl = GET_16BIT(tok+2); /* length including next two bytes */
d173 1
a173 1
	name->length = GET_32BIT(tok+offset);
@


1.15
log
@last lot of GSSAPI related leaks detected by Coverity via
elad AT netbsd.org; reviewed by simon AT sxw.org.uk; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.14 2006/02/08 13:15:44 stevesk Exp $	*/
@


1.14
log
@small KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.13 2005/10/13 22:24:31 stevesk Exp $	*/
d81 2
@


1.14.2.1
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.20 2006/08/03 03:34:42 deraadt Exp $ */
d27 1
a27 1
#include <sys/types.h>
d31 1
a31 6
#include <string.h>

#include "xmalloc.h"
#include "buffer.h"
#include "key.h"
#include "hostfile.h"
d36 3
a38 1
#include "misc.h"
a80 2

	gss_release_oid_set(&min_status, &supported);
d154 1
a154 1
	oidl = get_u16(tok+2); /* length including next two bytes */
d171 1
a171 1
	name->length = get_u32(tok+offset);
@


1.13
log
@KNF; ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.12 2005/10/13 19:08:08 stevesk Exp $	*/
d178 1
a178 1
	memcpy(name->value, tok+offset,name->length);
d237 2
a238 1
		debug("removing gssapi cred file\"%s\"", gssapi_client.store.filename);
@


1.12
log
@unused declarations; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.11 2005/10/13 14:20:37 stevesk Exp $	*/
d137 1
a137 1
	tok=ename->value;
d144 1
a144 1
	if (ename->length<6 || memcmp(tok,"\x04\x01", 2)!=0)
d163 1
a163 1
	    !ssh_gssapi_check_oid(ctx,tok+6,oidl))
d178 1
a178 1
	memcpy(name->value,tok+offset,name->length);
a261 1

d263 1
a263 1
		gssapi_client.store.envval);
@


1.11
log
@spelling in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.10 2005/10/13 14:03:01 stevesk Exp $	*/
a40 2

extern ServerOptions options;
@


1.10
log
@remove unneeded #includes; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.9 2005/09/19 11:48:10 djm Exp $	*/
d62 1
a62 1
/* Unpriviledged */
d91 1
a91 1
/* Priviledged */
d189 1
a189 1
/* Priviledged (called from accept_secure_ctx) */
d299 1
a299 1
/* Priviledged */
@


1.9
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.8 2005/08/30 22:08:05 djm Exp $	*/
a31 1
#include "compat.h"
a36 1
#include "monitor_wrap.h"
@


1.8
log
@destroy credentials if krb5_kuserok() call fails. Stops credentials being
delegated to users who are not authorised for GSSAPIAuthentication when
GSSAPIDeletegateCredentials=yes and another authentication mechanism succeeds;
bz#1073 reported by paul.moore AT centrify.com, fix by simon AT sxw.org.uk,
tested todd@@ biorn@@ jakob@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.7 2005/07/17 07:17:55 djm Exp $	*/
d274 1
a274 1
/* Priviledged */
@


1.8.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.13 2005/10/13 22:24:31 stevesk Exp $	*/
d32 1
d38 1
d44 2
d64 1
a64 1
/* Unprivileged */
d93 1
a93 1
/* Privileged */
d141 1
a141 1
	tok = ename->value;
d148 1
a148 1
	if (ename->length < 6 || memcmp(tok, "\x04\x01", 2) != 0)
d167 1
a167 1
	    !ssh_gssapi_check_oid(ctx, tok+6, oidl))
d182 1
a182 1
	memcpy(name->value, tok+offset,name->length);
d191 1
a191 1
/* Privileged (called from accept_secure_ctx) */
d266 1
d268 1
a268 1
		    gssapi_client.store.envval);
d274 1
a274 1
/* Privileged */
d301 1
a301 1
/* Privileged */
@


1.8.2.2
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: gss-serv.c,v 1.20 2006/08/03 03:34:42 deraadt Exp $ */
d27 1
a27 1
#include <sys/types.h>
d31 1
a31 6
#include <string.h>

#include "xmalloc.h"
#include "buffer.h"
#include "key.h"
#include "hostfile.h"
d36 3
a38 1
#include "misc.h"
a80 2

	gss_release_oid_set(&min_status, &supported);
d154 1
a154 1
	oidl = get_u16(tok+2); /* length including next two bytes */
d171 1
a171 1
	name->length = get_u32(tok+offset);
d178 1
a178 1
	memcpy(name->value, tok+offset, name->length);
d237 1
a237 2
		debug("removing gssapi cred file\"%s\"",
		    gssapi_client.store.filename);
@


1.7
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.6 2005/06/17 02:44:32 djm Exp $	*/
d278 2
d286 10
a295 1
		return ((*gssapi_client.mech->userok)(&gssapi_client, user));
@


1.6
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.5 2003/11/17 11:06:07 markus Exp $	*/
d167 1
a167 1
	   !ssh_gssapi_check_oid(ctx,tok+6,oidl))
d270 1
a270 1
		     gssapi_client.store.envval);
@


1.5
log
@replace "gssapi" with "gssapi-with-mic"; from Simon Wilkinson; test + ok jakob.
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.4 2003/09/23 20:17:11 markus Exp $	*/
d137 1
a137 1
	char *tok;
@


1.5.6.1
log
@upgrade to OpenSSH 4.2
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.8 2005/08/30 22:08:05 djm Exp $	*/
d137 1
a137 1
	u_char *tok;
d167 1
a167 1
	    !ssh_gssapi_check_oid(ctx,tok+6,oidl))
d270 1
a270 1
		    gssapi_client.store.envval);
a277 2
	OM_uint32 lmin;

d284 1
a284 10
		if ((*gssapi_client.mech->userok)(&gssapi_client, user))
			return 1;
		else {
			/* Destroy delegated credentials if userok fails */
			gss_release_buffer(&lmin, &gssapi_client.displayname);
			gss_release_buffer(&lmin, &gssapi_client.exportedname);
			gss_release_cred(&lmin, &gssapi_client.creds);
			memset(&gssapi_client, 0, sizeof(ssh_gssapi_client));
			return 0;
		}
@


1.5.6.2
log
@upgrade to OpenSSH 4.3
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.13 2005/10/13 22:24:31 stevesk Exp $	*/
d32 1
d38 1
d44 2
d64 1
a64 1
/* Unprivileged */
d93 1
a93 1
/* Privileged */
d141 1
a141 1
	tok = ename->value;
d148 1
a148 1
	if (ename->length < 6 || memcmp(tok, "\x04\x01", 2) != 0)
d167 1
a167 1
	    !ssh_gssapi_check_oid(ctx, tok+6, oidl))
d182 1
a182 1
	memcpy(name->value, tok+offset,name->length);
d191 1
a191 1
/* Privileged (called from accept_secure_ctx) */
d266 1
d268 1
a268 1
		    gssapi_client.store.envval);
d274 1
a274 1
/* Privileged */
d301 1
a301 1
/* Privileged */
@


1.5.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.8 2005/08/30 22:08:05 djm Exp $	*/
d137 1
a137 1
	u_char *tok;
d167 1
a167 1
	    !ssh_gssapi_check_oid(ctx,tok+6,oidl))
d270 1
a270 1
		    gssapi_client.store.envval);
a277 2
	OM_uint32 lmin;

d284 1
a284 10
		if ((*gssapi_client.mech->userok)(&gssapi_client, user))
			return 1;
		else {
			/* Destroy delegated credentials if userok fails */
			gss_release_buffer(&lmin, &gssapi_client.displayname);
			gss_release_buffer(&lmin, &gssapi_client.exportedname);
			gss_release_cred(&lmin, &gssapi_client.creds);
			memset(&gssapi_client, 0, sizeof(ssh_gssapi_client));
			return 0;
		}
@


1.4
log
@replace fatal_cleanup() and linked list of fatal callbacks with static
cleanup_exit() function.  re-refine cleanup_exit() where appropriate,
allocate sshd's authctxt eary to allow simpler cleanup in sshd.
tested by many, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.3 2003/08/31 13:31:57 markus Exp $	*/
d288 10
@


1.3
log
@whitspace KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.2 2003/08/31 13:30:18 markus Exp $	*/
d235 1
a235 1
/* As user - called through fatal cleanup hook */
d237 1
a237 1
ssh_gssapi_cleanup_creds(void *ignored)
a251 2
		if (options.gss_cleanup_creds)
			fatal_add_cleanup(ssh_gssapi_cleanup_creds, NULL);
@


1.3.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.5 2003/11/17 11:06:07 markus Exp $	*/
d235 1
a235 1
/* As user - called on fatal/exit */
d237 1
a237 1
ssh_gssapi_cleanup_creds(void)
d252 2
a289 10
}

/* Priviledged */
OM_uint32
ssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)
{
	ctx->major = gss_verify_mic(&ctx->minor, ctx->context,
	    gssbuf, gssmic, NULL);

	return (ctx->major);
@


1.3.6.1
log
@upgrade to OpenSSH 3.7
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.3 2003/08/31 13:31:57 markus Exp $	*/
@


1.3.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.3 2003/08/31 13:31:57 markus Exp $	*/
@


1.3.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.5 2003/11/17 11:06:07 markus Exp $	*/
d235 1
a235 1
/* As user - called on fatal/exit */
d237 1
a237 1
ssh_gssapi_cleanup_creds(void)
d252 2
a289 10
}

/* Priviledged */
OM_uint32
ssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)
{
	ctx->major = gss_verify_mic(&ctx->minor, ctx->context,
	    gssbuf, gssmic, NULL);

	return (ctx->major);
@


1.2
log
@correct string termination in parse_ename(); sxw@@inf.ed.ac.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: gss-serv.c,v 1.1 2003/08/22 10:56:09 markus Exp $	*/
d140 1
a140 1
	
d142 3
a144 3
	
	/* 
	 * Check that ename is long enough for all of the fixed length 
d148 1
a148 1
	if (ename->length<6 || memcmp(tok,"\x04\x01", 2)!=0) 
d166 1
a166 1
	    ename->length < oidl+6 ||        
d171 1
a171 1
	
d174 1
a174 1
		
d177 1
a177 1
	
d179 2
a180 2
        	return GSS_S_FAILURE;
	
d186 1
a186 1
} 
d198 1
a198 1
	
d209 1
a209 1
	if (client->mech == NULL) 
d211 2
a212 2
	
	if ((ctx->major = gss_display_name(&ctx->minor, ctx->client, 
d214 2
a215 2
	        ssh_gssapi_error(ctx);
	        return (ctx->major);
d217 2
a218 2
	
	if ((ctx->major = gss_export_name(&ctx->minor, ctx->client, 
d223 1
a223 1
	
@


1.1
log
@support GSS API user authentication; patches from Simon Wilkinson,
stripped down and tested by Jakob and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d181 1
a181 1
	name->value = xmalloc(name->length);
d183 2
a184 1
	
@

