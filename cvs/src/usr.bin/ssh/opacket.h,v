head	1.11;
access;
symbols
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.11
date	2017.05.31.08.09.45;	author markus;	state Exp;
branches;
next	1.10;
commitid	U3YdddehbFcy84WY;

1.10
date	2017.05.03.21.08.09;	author naddy;	state Exp;
branches;
next	1.9;
commitid	wlKSvaBqtNpb5VOS;

1.9
date	2016.09.30.09.19.13;	author markus;	state Exp;
branches;
next	1.8;
commitid	VHQRRel9yTEUINVH;

1.8
date	2016.09.28.16.33.07;	author djm;	state Exp;
branches;
next	1.7;
commitid	e2NJzal9PUi2o22D;

1.7
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.6;
commitid	kr9hjdmg99uVnhW2;

1.6
date	2016.02.08.10.57.07;	author djm;	state Exp;
branches;
next	1.5;
commitid	eSwtzi7BWC7eBzrp;

1.5
date	2016.01.14.16.17.40;	author markus;	state Exp;
branches;
next	1.4;
commitid	W9ye0gltieEl87AJ;

1.4
date	2015.02.13.18.57.00;	author markus;	state Exp;
branches;
next	1.3;
commitid	FXpQflsh1UdymeRb;

1.3
date	2015.01.30.01.13.33;	author djm;	state Exp;
branches;
next	1.2;
commitid	BuE3vBiYMFEA1E3u;

1.2
date	2015.01.28.21.15.47;	author djm;	state Exp;
branches;
next	1.1;
commitid	Iqzpomw0YO4gLwGY;

1.1
date	2015.01.19.19.52.16;	author markus;	state Exp;
branches;
next	;
commitid	UHlhoIB5NMb8eAPm;


desc
@@


1.11
log
@clear session keys from memory; ok djm@@
@
text
@#ifndef _OPACKET_H
/* Written by Markus Friedl. Placed in the public domain.  */

/* Map old to new API */
void     ssh_packet_start(struct ssh *, u_char);
void     ssh_packet_put_char(struct ssh *, int ch);
void     ssh_packet_put_int(struct ssh *, u_int value);
void     ssh_packet_put_int64(struct ssh *, u_int64_t value);
void     ssh_packet_put_bignum2(struct ssh *, BIGNUM * value);
void     ssh_packet_put_ecpoint(struct ssh *, const EC_GROUP *, const EC_POINT *);
void     ssh_packet_put_string(struct ssh *, const void *buf, u_int len);
void     ssh_packet_put_cstring(struct ssh *, const char *str);
void     ssh_packet_put_raw(struct ssh *, const void *buf, u_int len);
void     ssh_packet_send(struct ssh *);

u_int	 ssh_packet_get_char(struct ssh *);
u_int	 ssh_packet_get_int(struct ssh *);
u_int64_t ssh_packet_get_int64(struct ssh *);
void     ssh_packet_get_bignum2(struct ssh *, BIGNUM * value);
void	 ssh_packet_get_ecpoint(struct ssh *, const EC_GROUP *, EC_POINT *);
void	*ssh_packet_get_string(struct ssh *, u_int *length_ptr);
char	*ssh_packet_get_cstring(struct ssh *, u_int *length_ptr);

/* don't allow remaining bytes after the end of the message */
#define ssh_packet_check_eom(ssh) \
do { \
	int _len = ssh_packet_remaining(ssh); \
	if (_len > 0) { \
		logit("Packet integrity error (%d bytes remaining) at %s:%d", \
		    _len ,__FILE__, __LINE__); \
		ssh_packet_disconnect(ssh, \
		    "Packet integrity error."); \
	} \
} while (0)

/* old API */
void	 packet_close(void);
u_int	 packet_get_char(void);
u_int	 packet_get_int(void);
void     packet_set_connection(int, int);
int	 packet_read_seqnr(u_int32_t *);
int	 packet_read_poll_seqnr(u_int32_t *);
void	 packet_process_incoming(const char *buf, u_int len);
void	 packet_write_wait(void);
void	 packet_write_poll(void);
void	 packet_read_expect(int expected_type);
#define packet_set_timeout(timeout, count) \
	ssh_packet_set_timeout(active_state, (timeout), (count))
#define packet_connection_is_on_socket() \
	ssh_packet_connection_is_on_socket(active_state)
#define packet_set_nonblocking() \
	ssh_packet_set_nonblocking(active_state)
#define packet_get_connection_in() \
	ssh_packet_get_connection_in(active_state)
#define packet_get_connection_out() \
	ssh_packet_get_connection_out(active_state)
#define packet_set_protocol_flags(protocol_flags) \
	ssh_packet_set_protocol_flags(active_state, (protocol_flags))
#define packet_get_protocol_flags() \
	ssh_packet_get_protocol_flags(active_state)
#define packet_start_compression(level) \
	ssh_packet_start_compression(active_state, (level))
#define packet_start(type) \
	ssh_packet_start(active_state, (type))
#define packet_put_char(value) \
	ssh_packet_put_char(active_state, (value))
#define packet_put_int(value) \
	ssh_packet_put_int(active_state, (value))
#define packet_put_int64(value) \
	ssh_packet_put_int64(active_state, (value))
#define packet_put_string( buf, len) \
	ssh_packet_put_string(active_state, (buf), (len))
#define packet_put_cstring(str) \
	ssh_packet_put_cstring(active_state, (str))
#define packet_put_raw(buf, len) \
	ssh_packet_put_raw(active_state, (buf), (len))
#define packet_put_bignum2(value) \
	ssh_packet_put_bignum2(active_state, (value))
#define packet_send() \
	ssh_packet_send(active_state)
#define packet_read() \
	ssh_packet_read(active_state)
#define packet_get_int64() \
	ssh_packet_get_int64(active_state)
#define packet_get_bignum2(value) \
	ssh_packet_get_bignum2(active_state, (value))
#define packet_remaining() \
	ssh_packet_remaining(active_state)
#define packet_get_string(length_ptr) \
	ssh_packet_get_string(active_state, (length_ptr))
#define packet_get_string_ptr(length_ptr) \
	ssh_packet_get_string_ptr(active_state, (length_ptr))
#define packet_get_cstring(length_ptr) \
	ssh_packet_get_cstring(active_state, (length_ptr))
#define packet_send_debug(fmt, args...) \
	ssh_packet_send_debug(active_state, (fmt), ##args)
#define packet_disconnect(fmt, args...) \
	ssh_packet_disconnect(active_state, (fmt), ##args)
#define packet_have_data_to_write() \
	ssh_packet_have_data_to_write(active_state)
#define packet_not_very_much_data_to_write() \
	ssh_packet_not_very_much_data_to_write(active_state)
#define packet_set_interactive(interactive, qos_interactive, qos_bulk) \
	ssh_packet_set_interactive(active_state, (interactive), (qos_interactive), (qos_bulk))
#define packet_is_interactive() \
	ssh_packet_is_interactive(active_state)
#define packet_set_maxsize(s) \
	ssh_packet_set_maxsize(active_state, (s))
#define packet_inc_alive_timeouts() \
	ssh_packet_inc_alive_timeouts(active_state)
#define packet_set_alive_timeouts(ka) \
	ssh_packet_set_alive_timeouts(active_state, (ka))
#define packet_get_maxsize() \
	ssh_packet_get_maxsize(active_state)
#define packet_add_padding(pad) \
	sshpkt_add_padding(active_state, (pad))
#define packet_send_ignore(nbytes) \
	ssh_packet_send_ignore(active_state, (nbytes))
#define packet_set_server() \
	ssh_packet_set_server(active_state)
#define packet_set_authenticated() \
	ssh_packet_set_authenticated(active_state)
#define packet_get_input() \
	ssh_packet_get_input(active_state)
#define packet_get_output() \
	ssh_packet_get_output(active_state)
#define packet_check_eom() \
	ssh_packet_check_eom(active_state)
#define set_newkeys(mode) \
	ssh_set_newkeys(active_state, (mode))
#define packet_get_state(m) \
	ssh_packet_get_state(active_state, m)
#define packet_set_state(m) \
	ssh_packet_set_state(active_state, m)
#define packet_get_raw(lenp) \
        sshpkt_ptr(active_state, lenp)
#define packet_get_ecpoint(c,p) \
	ssh_packet_get_ecpoint(active_state, c, p)
#define packet_put_ecpoint(c,p) \
	ssh_packet_put_ecpoint(active_state, c, p)
#define packet_get_rekey_timeout() \
	ssh_packet_get_rekey_timeout(active_state)
#define packet_set_rekey_limits(x,y) \
	ssh_packet_set_rekey_limits(active_state, x, y)
#define packet_get_bytes(x,y) \
	ssh_packet_get_bytes(active_state, x, y)
#define packet_set_mux() \
	ssh_packet_set_mux(active_state)
#define packet_get_mux() \
	ssh_packet_get_mux(active_state)
#define packet_clear_keys() \
	ssh_packet_clear_keys(active_state)

#endif /* _OPACKET_H */
@


1.10
log
@remove miscellaneous SSH1 leftovers; ok markus@@
@
text
@d151 2
@


1.9
log
@ssh proxy mux mode (-O proxy; idea from Simon Tatham):
- mux client speaks the ssh-packet protocol directly over unix-domain socket.
- mux server acts as a proxy, translates channel IDs and relays to the server.
- no filedescriptor passing necessary.
- combined with unix-domain forwarding it's even possible to run mux client
  and server on different machines.
feedback & ok djm@@
@
text
@a8 1
void     ssh_packet_put_bignum(struct ssh *, BIGNUM * value);
a18 1
void     ssh_packet_get_bignum(struct ssh *, BIGNUM * value);
a62 2
#define packet_set_encryption_key(key, keylen, number) \
	ssh_packet_set_encryption_key(active_state, (key), (keylen), (number))
a76 2
#define packet_put_bignum(value) \
	ssh_packet_put_bignum(active_state, (value))
a84 2
#define packet_get_bignum(value) \
	ssh_packet_get_bignum(active_state, (value))
@


1.8
log
@Remove support for pre-authentication compression. Doing compression
early in the protocol probably seemed reasonable in the 1990s, but
today it's clearly a bad idea in terms of both cryptography (cf.
multiple compression oracle attacks in TLS) and attack surface.

Moreover, to support it across privilege-separation zlib needed
the assistance of a complex shared-memory manager that made the
required attack surface considerably larger.

Prompted by Guido Vranken pointing out a compiler-elided security
check in the shared memory manager found by Stack
(http://css.csail.mit.edu/stack/); ok deraadt@@ markus@@

NB. pre-auth authentication has been disabled by default in sshd
for >10 years.
@
text
@d155 4
@


1.7
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@a134 3
#define packet_set_compress_hooks(ctx, allocfunc, freefunc) \
	ssh_packet_set_compress_hooks(active_state, ctx, \
	    allocfunc, freefunc);
@


1.6
log
@refactor activation of rekeying

This makes automatic rekeying internal to the packet code (previously
the server and client loops needed to assist). In doing to it makes
application of rekey limits more accurate by accounting for packets
about to be sent as well as packets queued during rekeying events
themselves.

Based on a patch from dtucker@@ which was in turn based on a patch
Aleksander Adamowski in bz#2521; ok markus@@
@
text
@a145 4
#if 0
#define get_remote_ipaddr() \
	ssh_remote_ipaddr(active_state)
#endif
@


1.5
log
@remove roaming support; ok djm@@
@
text
@a126 2
#define packet_need_rekeying() \
	ssh_packet_need_rekeying(active_state)
@


1.4
log
@make rekey_limit for sshd w/privsep work; ok djm@@ dtucker@@
@
text
@a41 2
void	 packet_backup_state(void);
void	 packet_restore_state(void);
@


1.3
log
@avoid more fatal/exit in the packet.c paths that ssh-keyscan
uses; feedback and "looks good" markus@@
@
text
@a130 2
#define packet_set_rekey_limit(bytes) \
	ssh_packet_set_rekey_limit(active_state, (bytes))
@


1.2
log
@avoid fatal() calls in packet code
makes ssh-keyscan more reliable against server failures
ok dtucker@@ markus@@
@
text
@d48 3
a90 2
#define packet_read_expect(expected_type) \
	ssh_packet_read_expect(active_state, (expected_type))
a108 4
#define packet_write_poll() \
	ssh_packet_write_poll(active_state)
#define packet_write_wait() \
	ssh_packet_write_wait(active_state)
@


1.1
log
@update packet.c & isolate, introduce struct ssh
a) switch packet.c to buffer api and isolate per-connection info into struct ssh
b) (de)serialization of the state is moved from monitor to packet.c
c) the old packet.c API is implemented in opacket.[ch]
d) compress.c/h is removed and integrated into packet.c
with and ok djm@@
@
text
@d47 1
a89 2
#define packet_process_incoming(buf, len) \
	ssh_packet_process_incoming(active_state, (buf), (len))
@

