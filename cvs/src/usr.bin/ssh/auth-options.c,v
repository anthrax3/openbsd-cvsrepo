head	1.74;
access;
symbols
	OPENBSD_6_2_BASE:1.74
	OPENBSD_6_1:1.72.0.4
	OPENBSD_6_1_BASE:1.72
	OPENBSD_6_0:1.71.0.4
	OPENBSD_6_0_BASE:1.71
	OPENBSD_5_9:1.70.0.2
	OPENBSD_5_9_BASE:1.70
	OPENBSD_5_8:1.68.0.2
	OPENBSD_5_8_BASE:1.68
	OPENBSD_5_7:1.65.0.2
	OPENBSD_5_7_BASE:1.65
	OPENBSD_5_6:1.64.0.4
	OPENBSD_5_6_BASE:1.64
	OPENBSD_5_5:1.62.0.4
	OPENBSD_5_5_BASE:1.62
	OPENBSD_5_4:1.59.0.2
	OPENBSD_5_4_BASE:1.59
	OPENBSD_5_3:1.57.0.2
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.56.0.4
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.2
	OPENBSD_5_0:1.54.0.4
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.54.0.2
	OPENBSD_4_9_BASE:1.54
	OPENBSD_4_8:1.52.0.2
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.44.0.6
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.2
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.43.0.2
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.40.0.8
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.40.0.6
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.40.0.2
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.40.0.4
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.31.0.4
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.31.0.2
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.28.0.6
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.28.0.4
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.26.0.4
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.2.0.2;
locks; strict;
comment	@ * @;


1.74
date	2017.09.12.06.32.07;	author djm;	state Exp;
branches;
next	1.73;
commitid	Amj5uk8F1JrQpmI5;

1.73
date	2017.05.31.10.54.00;	author markus;	state Exp;
branches;
next	1.72;
commitid	S8mXQQankLwOyhst;

1.72
date	2016.11.30.02.57.40;	author djm;	state Exp;
branches;
next	1.71;
commitid	RBXxsfvp5NR7LTy5;

1.71
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.70;
commitid	kr9hjdmg99uVnhW2;

1.70
date	2015.12.10.17.08.40;	author mmcc;	state Exp;
branches;
next	1.69;
commitid	qST12VGCwbX5zIfM;

1.69
date	2015.11.16.00.30.02;	author djm;	state Exp;
branches;
next	1.68;
commitid	hT0bGFTnDnms93C3;

1.68
date	2015.07.03.03.43.18;	author djm;	state Exp;
branches;
next	1.67;
commitid	cnvu1kGgoFFYv6D3;

1.67
date	2015.05.01.03.20.54;	author djm;	state Exp;
branches;
next	1.66;
commitid	7SYl9PS9c9a0zT2J;

1.66
date	2015.04.22.01.24.01;	author djm;	state Exp;
branches;
next	1.65;
commitid	oe57hMH2z41cfLqi;

1.65
date	2015.01.14.10.30.34;	author markus;	state Exp;
branches;
next	1.64;
commitid	Sp8RW7pAkbmkIGY9;

1.64
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.63;
commitid	z7plx8Gkj6l2sxem;

1.63
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.62;
commitid	1h9UxAQmwdaqUzyX;

1.62
date	2013.12.19.00.27.57;	author djm;	state Exp;
branches;
next	1.61;

1.61
date	2013.11.08.00.39.14;	author djm;	state Exp;
branches;
next	1.60;

1.60
date	2013.11.02.22.34.01;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2013.07.12.00.19.58;	author djm;	state Exp;
branches
	1.59.2.1;
next	1.58;

1.58
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.57;

1.57
date	2012.12.02.20.46.11;	author djm;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2011.10.18.04.58.26;	author djm;	state Exp;
branches;
next	1.55;

1.55
date	2011.09.23.00.22.04;	author dtucker;	state Exp;
branches;
next	1.54;

1.54
date	2010.12.24.21.41.48;	author djm;	state Exp;
branches;
next	1.53;

1.53
date	2010.08.31.09.58.37;	author djm;	state Exp;
branches;
next	1.52;

1.52
date	2010.05.20.23.46.02;	author djm;	state Exp;
branches;
next	1.51;

1.51
date	2010.05.07.11.30.29;	author djm;	state Exp;
branches;
next	1.50;

1.50
date	2010.04.16.01.47.26;	author djm;	state Exp;
branches;
next	1.49;

1.49
date	2010.03.16.15.46.52;	author stevesk;	state Exp;
branches;
next	1.48;

1.48
date	2010.03.07.11.57.13;	author dtucker;	state Exp;
branches;
next	1.47;

1.47
date	2010.03.04.23.27.25;	author djm;	state Exp;
branches;
next	1.46;

1.46
date	2010.03.03.01.44.36;	author djm;	state Exp;
branches;
next	1.45;

1.45
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.22.10.09.16;	author djm;	state Exp;
branches;
next	1.43;

1.43
date	2008.06.10.23.06.19;	author djm;	state Exp;
branches;
next	1.42;

1.42
date	2008.05.08.12.02.23;	author djm;	state Exp;
branches;
next	1.41;

1.41
date	2008.03.26.21.28.14;	author djm;	state Exp;
branches;
next	1.40;

1.40
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.17.12.02.24;	author dtucker;	state Exp;
branches;
next	1.37;

1.37
date	2006.07.12.22.28.51;	author stevesk;	state Exp;
branches;
next	1.36;

1.36
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.08.18.34.11;	author reyk;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2005.12.06.22.38.27;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.10.22.40.38;	author deraadt;	state Exp;
branches
	1.31.2.1
	1.31.4.1;
next	1.30;

1.30
date	2005.03.10.22.01.05;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.01.10.09.52;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.02.09.17.34;	author markus;	state Exp;
branches
	1.28.4.1
	1.28.6.1;
next	1.27;

1.27
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.30.17.03.55;	author markus;	state Exp;
branches
	1.26.2.1
	1.26.4.1;
next	1.25;

1.25
date	2002.07.21.18.32.20;	author stevesk;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.13.20.44.58;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.19.10.35.39;	author markus;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2002.03.18.17.50.31;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.29.14.32.03;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.30.20.36.34;	author stevesk;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.06.24.05.25.09;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.31.10.30.12;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.30.12.55.06;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.18.12.07.52;	author markus;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.03.16.19.06.28;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.13.17.34.42;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.09.13.38.07;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.03.10.08.36;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.21.19.05.41;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.20.15.55.20;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.19.15.55.10;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.13.18.38.00;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.19.23.17.54;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.15.22.31.36;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.09.21.32.34;	author markus;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.09.07.21.13.36;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.07.20.27.49;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.20.01.39.38;	author markus;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.06.18.04.05.01;	author markus;	state Exp;
branches;
next	;

1.2.2.1
date	2000.09.01.18.23.16;	author jason;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2000.11.08.21.30.17;	author jason;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.03.12.15.44.07;	author jason;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2001.03.21.18.52.32;	author jason;	state Exp;
branches;
next	;

1.5.2.1
date	2001.02.16.20.12.51;	author jason;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.02.19.17.18.33;	author jason;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.03.21.19.46.22;	author jason;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2001.05.07.21.09.25;	author jason;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2002.03.08.17.04.41;	author brad;	state Exp;
branches;
next	;

1.16.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.03.09.00.20.43;	author miod;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2002.06.02.22.56.09;	author miod;	state Exp;
branches;
next	;

1.20.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.23.2.1
date	2002.05.18.04.12.10;	author jason;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2002.05.18.04.50.37;	author jason;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	1.23.2.4;

1.23.2.4
date	2002.10.11.14.51.51;	author miod;	state Exp;
branches;
next	;

1.26.2.1
date	2003.09.16.21.20.24;	author brad;	state Exp;
branches;
next	;

1.26.4.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.26.4.2;

1.26.4.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.28.4.1
date	2005.03.10.17.15.03;	author brad;	state Exp;
branches;
next	;

1.28.6.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.28.6.2;

1.28.6.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	;

1.31.2.1
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.31.4.1
date	2006.02.03.03.01.55;	author brad;	state Exp;
branches;
next	1.31.4.2;

1.31.4.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.33.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;

1.57.2.1
date	2013.11.08.05.52.21;	author djm;	state Exp;
branches;
next	;

1.59.2.1
date	2013.11.08.01.33.56;	author djm;	state Exp;
branches;
next	;


desc
@@


1.74
log
@refactor channels.c

Move static state to a "struct ssh_channels" that is allocated at
runtime and tracked as a member of struct ssh.

Explicitly pass "struct ssh" to all channels functions.

Replace use of the legacy packet APIs in channels.c.

Rework sshd_config PermitOpen handling: previously the configuration
parser would call directly into the channels layer. After the refactor
this is not possible, as the channels structures are allocated at
connection time and aren't available when the configuration is parsed.
The server config parser now tracks PermitOpen itself and explicitly
configures the channels code later.

ok markus@@
@
text
@/* $OpenBSD: auth-options.c,v 1.73 2017/05/31 10:54:00 markus Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <netdb.h>
#include <pwd.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>

#include "key.h"	/* XXX for typedef */
#include "buffer.h"	/* XXX for typedef */
#include "xmalloc.h"
#include "match.h"
#include "ssherr.h"
#include "log.h"
#include "canohost.h"
#include "packet.h"
#include "sshbuf.h"
#include "misc.h"
#include "channels.h"
#include "servconf.h"
#include "sshkey.h"
#include "auth-options.h"
#include "hostfile.h"
#include "auth.h"

/* Flags set authorized_keys flags */
int no_port_forwarding_flag = 0;
int no_agent_forwarding_flag = 0;
int no_x11_forwarding_flag = 0;
int no_pty_flag = 0;
int no_user_rc = 0;
int key_is_cert_authority = 0;

/* "command=" option. */
char *forced_command = NULL;

/* "environment=" options. */
struct envstring *custom_environment = NULL;

/* "tunnel=" option. */
int forced_tun_device = -1;

/* "principals=" option. */
char *authorized_principals = NULL;

extern ServerOptions options;

/* XXX refactor to be stateless */

void
auth_clear_options(void)
{
	struct ssh *ssh = active_state;		/* XXX */

	no_agent_forwarding_flag = 0;
	no_port_forwarding_flag = 0;
	no_pty_flag = 0;
	no_x11_forwarding_flag = 0;
	no_user_rc = 0;
	key_is_cert_authority = 0;
	while (custom_environment) {
		struct envstring *ce = custom_environment;
		custom_environment = ce->next;
		free(ce->s);
		free(ce);
	}
	free(forced_command);
	forced_command = NULL;
	free(authorized_principals);
	authorized_principals = NULL;
	forced_tun_device = -1;
	channel_clear_permitted_opens(ssh);
}

/*
 * Match flag 'opt' in *optsp, and if allow_negate is set then also match
 * 'no-opt'. Returns -1 if option not matched, 1 if option matches or 0
 * if negated option matches. 
 * If the option or negated option matches, then *optsp is updated to
 * point to the first character after the option and, if 'msg' is not NULL
 * then a message based on it added via auth_debug_add().
 */
static int
match_flag(const char *opt, int allow_negate, char **optsp, const char *msg)
{
	size_t opt_len = strlen(opt);
	char *opts = *optsp;
	int negate = 0;

	if (allow_negate && strncasecmp(opts, "no-", 3) == 0) {
		opts += 3;
		negate = 1;
	}
	if (strncasecmp(opts, opt, opt_len) == 0) {
		*optsp = opts + opt_len;
		if (msg != NULL) {
			auth_debug_add("%s %s.", msg,
			    negate ? "disabled" : "enabled");
		}
		return negate ? 0 : 1;
	}
	return -1;
}

/*
 * return 1 if access is granted, 0 if not.
 * side effect: sets key option flags
 * XXX remove side effects; fill structure instead.
 */
int
auth_parse_options(struct passwd *pw, char *opts, const char *file,
    u_long linenum)
{
	struct ssh *ssh = active_state;		/* XXX */
	const char *cp;
	int i, r;

	/* reset options */
	auth_clear_options();

	if (!opts)
		return 1;

	while (*opts && *opts != ' ' && *opts != '\t') {
		if ((r = match_flag("cert-authority", 0, &opts, NULL)) != -1) {
			key_is_cert_authority = r;
			goto next_option;
		}
		if ((r = match_flag("restrict", 0, &opts, NULL)) != -1) {
			auth_debug_add("Key is restricted.");
			no_port_forwarding_flag = 1;
			no_agent_forwarding_flag = 1;
			no_x11_forwarding_flag = 1;
			no_pty_flag = 1;
			no_user_rc = 1;
			goto next_option;
		}
		if ((r = match_flag("port-forwarding", 1, &opts,
		    "Port forwarding")) != -1) {
			no_port_forwarding_flag = r != 1;
			goto next_option;
		}
		if ((r = match_flag("agent-forwarding", 1, &opts,
		    "Agent forwarding")) != -1) {
			no_agent_forwarding_flag = r != 1;
			goto next_option;
		}
		if ((r = match_flag("x11-forwarding", 1, &opts,
		    "X11 forwarding")) != -1) {
			no_x11_forwarding_flag = r != 1;
			goto next_option;
		}
		if ((r = match_flag("pty", 1, &opts,
		    "PTY allocation")) != -1) {
			no_pty_flag = r != 1;
			goto next_option;
		}
		if ((r = match_flag("user-rc", 1, &opts,
		    "User rc execution")) != -1) {
			no_user_rc = r != 1;
			goto next_option;
		}
		cp = "command=\"";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			opts += strlen(cp);
			free(forced_command);
			forced_command = xmalloc(strlen(opts) + 1);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
					forced_command[i++] = '"';
					continue;
				}
				forced_command[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: missing end quote",
				    file, linenum);
				free(forced_command);
				forced_command = NULL;
				goto bad_option;
			}
			forced_command[i] = '\0';
			auth_debug_add("Forced command.");
			opts++;
			goto next_option;
		}
		cp = "principals=\"";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			opts += strlen(cp);
			free(authorized_principals);
			authorized_principals = xmalloc(strlen(opts) + 1);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
					authorized_principals[i++] = '"';
					continue;
				}
				authorized_principals[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: missing end quote",
				    file, linenum);
				free(authorized_principals);
				authorized_principals = NULL;
				goto bad_option;
			}
			authorized_principals[i] = '\0';
			auth_debug_add("principals: %.900s",
			    authorized_principals);
			opts++;
			goto next_option;
		}
		cp = "environment=\"";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			char *s;
			struct envstring *new_envstring;

			opts += strlen(cp);
			s = xmalloc(strlen(opts) + 1);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
					s[i++] = '"';
					continue;
				}
				s[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: missing end quote",
				    file, linenum);
				free(s);
				goto bad_option;
			}
			s[i] = '\0';
			opts++;
			if (options.permit_user_env) {
				auth_debug_add("Adding to environment: "
				    "%.900s", s);
				debug("Adding to environment: %.900s", s);
				new_envstring = xcalloc(1,
				    sizeof(*new_envstring));
				new_envstring->s = s;
				new_envstring->next = custom_environment;
				custom_environment = new_envstring;
				s = NULL;
			}
			free(s);
			goto next_option;
		}
		cp = "from=\"";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			const char *remote_ip = ssh_remote_ipaddr(ssh);
			const char *remote_host = auth_get_canonical_hostname(
			    ssh, options.use_dns);
			char *patterns = xmalloc(strlen(opts) + 1);

			opts += strlen(cp);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
					patterns[i++] = '"';
					continue;
				}
				patterns[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: missing end quote",
				    file, linenum);
				free(patterns);
				goto bad_option;
			}
			patterns[i] = '\0';
			opts++;
			switch (match_host_and_ip(remote_host, remote_ip,
			    patterns)) {
			case 1:
				free(patterns);
				/* Host name matches. */
				goto next_option;
			case -1:
				debug("%.100s, line %lu: invalid criteria",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: "
				    "invalid criteria", file, linenum);
				/* FALLTHROUGH */
			case 0:
				free(patterns);
				logit("Authentication tried for %.100s with "
				    "correct key but not from a permitted "
				    "host (host=%.200s, ip=%.200s).",
				    pw->pw_name, remote_host, remote_ip);
				auth_debug_add("Your host '%.200s' is not "
				    "permitted to use this key for login.",
				    remote_host);
				break;
			}
			/* deny access */
			return 0;
		}
		cp = "permitopen=\"";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			char *host, *p;
			int port;
			char *patterns = xmalloc(strlen(opts) + 1);

			opts += strlen(cp);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
					patterns[i++] = '"';
					continue;
				}
				patterns[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: missing "
				    "end quote", file, linenum);
				free(patterns);
				goto bad_option;
			}
			patterns[i] = '\0';
			opts++;
			p = patterns;
			/* XXX - add streamlocal support */
			host = hpdelim(&p);
			if (host == NULL || strlen(host) >= NI_MAXHOST) {
				debug("%.100s, line %lu: Bad permitopen "
				    "specification <%.100s>", file, linenum,
				    patterns);
				auth_debug_add("%.100s, line %lu: "
				    "Bad permitopen specification", file,
				    linenum);
				free(patterns);
				goto bad_option;
			}
			host = cleanhostname(host);
			if (p == NULL || (port = permitopen_port(p)) < 0) {
				debug("%.100s, line %lu: Bad permitopen port "
				    "<%.100s>", file, linenum, p ? p : "");
				auth_debug_add("%.100s, line %lu: "
				    "Bad permitopen port", file, linenum);
				free(patterns);
				goto bad_option;
			}
			if ((options.allow_tcp_forwarding & FORWARD_LOCAL) != 0)
				channel_add_permitted_opens(ssh, host, port);
			free(patterns);
			goto next_option;
		}
		cp = "tunnel=\"";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			char *tun = NULL;
			opts += strlen(cp);
			tun = xmalloc(strlen(opts) + 1);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				tun[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: missing end quote",
				    file, linenum);
				free(tun);
				forced_tun_device = -1;
				goto bad_option;
			}
			tun[i] = '\0';
			forced_tun_device = a2tun(tun, NULL);
			free(tun);
			if (forced_tun_device == SSH_TUNID_ERR) {
				debug("%.100s, line %lu: invalid tun device",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: invalid tun device",
				    file, linenum);
				forced_tun_device = -1;
				goto bad_option;
			}
			auth_debug_add("Forced tun device: %d", forced_tun_device);
			opts++;
			goto next_option;
		}
next_option:
		/*
		 * Skip the comma, and move to the next option
		 * (or break out if there are no more).
		 */
		if (!*opts)
			fatal("Bugs in auth-options.c option processing.");
		if (*opts == ' ' || *opts == '\t')
			break;		/* End of options. */
		if (*opts != ',')
			goto bad_option;
		opts++;
		/* Process the next option. */
	}

	/* grant access */
	return 1;

bad_option:
	logit("Bad options in %.100s file, line %lu: %.50s",
	    file, linenum, opts);
	auth_debug_add("Bad options in %.100s file, line %lu: %.50s",
	    file, linenum, opts);

	/* deny access */
	return 0;
}

#define OPTIONS_CRITICAL	1
#define OPTIONS_EXTENSIONS	2
static int
parse_option_list(struct sshbuf *oblob, struct passwd *pw,
    u_int which, int crit,
    int *cert_no_port_forwarding_flag,
    int *cert_no_agent_forwarding_flag,
    int *cert_no_x11_forwarding_flag,
    int *cert_no_pty_flag,
    int *cert_no_user_rc,
    char **cert_forced_command,
    int *cert_source_address_done)
{
	struct ssh *ssh = active_state;		/* XXX */
	char *command, *allowed;
	const char *remote_ip;
	char *name = NULL;
	struct sshbuf *c = NULL, *data = NULL;
	int r, ret = -1, result, found;

	if ((c = sshbuf_fromb(oblob)) == NULL) {
		error("%s: sshbuf_fromb failed", __func__);
		goto out;
	}

	while (sshbuf_len(c) > 0) {
		sshbuf_free(data);
		data = NULL;
		if ((r = sshbuf_get_cstring(c, &name, NULL)) != 0 ||
		    (r = sshbuf_froms(c, &data)) != 0) {
			error("Unable to parse certificate options: %s",
			    ssh_err(r));
			goto out;
		}
		debug3("found certificate option \"%.100s\" len %zu",
		    name, sshbuf_len(data));
		found = 0;
		if ((which & OPTIONS_EXTENSIONS) != 0) {
			if (strcmp(name, "permit-X11-forwarding") == 0) {
				*cert_no_x11_forwarding_flag = 0;
				found = 1;
			} else if (strcmp(name,
			    "permit-agent-forwarding") == 0) {
				*cert_no_agent_forwarding_flag = 0;
				found = 1;
			} else if (strcmp(name,
			    "permit-port-forwarding") == 0) {
				*cert_no_port_forwarding_flag = 0;
				found = 1;
			} else if (strcmp(name, "permit-pty") == 0) {
				*cert_no_pty_flag = 0;
				found = 1;
			} else if (strcmp(name, "permit-user-rc") == 0) {
				*cert_no_user_rc = 0;
				found = 1;
			}
		}
		if (!found && (which & OPTIONS_CRITICAL) != 0) {
			if (strcmp(name, "force-command") == 0) {
				if ((r = sshbuf_get_cstring(data, &command,
				    NULL)) != 0) {
					error("Unable to parse \"%s\" "
					    "section: %s", name, ssh_err(r));
					goto out;
				}
				if (*cert_forced_command != NULL) {
					error("Certificate has multiple "
					    "force-command options");
					free(command);
					goto out;
				}
				*cert_forced_command = command;
				found = 1;
			}
			if (strcmp(name, "source-address") == 0) {
				if ((r = sshbuf_get_cstring(data, &allowed,
				    NULL)) != 0) {
					error("Unable to parse \"%s\" "
					    "section: %s", name, ssh_err(r));
					goto out;
				}
				if ((*cert_source_address_done)++) {
					error("Certificate has multiple "
					    "source-address options");
					free(allowed);
					goto out;
				}
				remote_ip = ssh_remote_ipaddr(ssh);
				result = addr_match_cidr_list(remote_ip,
				    allowed);
				free(allowed);
				switch (result) {
				case 1:
					/* accepted */
					break;
				case 0:
					/* no match */
					logit("Authentication tried for %.100s "
					    "with valid certificate but not "
					    "from a permitted host "
					    "(ip=%.200s).", pw->pw_name,
					    remote_ip);
					auth_debug_add("Your address '%.200s' "
					    "is not permitted to use this "
					    "certificate for login.",
					    remote_ip);
					goto out;
				case -1:
				default:
					error("Certificate source-address "
					    "contents invalid");
					goto out;
				}
				found = 1;
			}
		}

		if (!found) {
			if (crit) {
				error("Certificate critical option \"%s\" "
				    "is not supported", name);
				goto out;
			} else {
				logit("Certificate extension \"%s\" "
				    "is not supported", name);
			}
		} else if (sshbuf_len(data) != 0) {
			error("Certificate option \"%s\" corrupt "
			    "(extra data)", name);
			goto out;
		}
		free(name);
		name = NULL;
	}
	/* successfully parsed all options */
	ret = 0;

 out:
	if (ret != 0 &&
	    cert_forced_command != NULL &&
	    *cert_forced_command != NULL) {
		free(*cert_forced_command);
		*cert_forced_command = NULL;
	}
	free(name);
	sshbuf_free(data);
	sshbuf_free(c);
	return ret;
}

/*
 * Set options from critical certificate options. These supersede user key
 * options so this must be called after auth_parse_options().
 */
int
auth_cert_options(struct sshkey *k, struct passwd *pw, const char **reason)
{
	int cert_no_port_forwarding_flag = 1;
	int cert_no_agent_forwarding_flag = 1;
	int cert_no_x11_forwarding_flag = 1;
	int cert_no_pty_flag = 1;
	int cert_no_user_rc = 1;
	char *cert_forced_command = NULL;
	int cert_source_address_done = 0;

	*reason = "invalid certificate options";

	/* Separate options and extensions for v01 certs */
	if (parse_option_list(k->cert->critical, pw,
	    OPTIONS_CRITICAL, 1, NULL, NULL, NULL, NULL, NULL,
	    &cert_forced_command,
	    &cert_source_address_done) == -1)
		return -1;
	if (parse_option_list(k->cert->extensions, pw,
	    OPTIONS_EXTENSIONS, 0,
	    &cert_no_port_forwarding_flag,
	    &cert_no_agent_forwarding_flag,
	    &cert_no_x11_forwarding_flag,
	    &cert_no_pty_flag,
	    &cert_no_user_rc,
	    NULL, NULL) == -1)
		return -1;

	no_port_forwarding_flag |= cert_no_port_forwarding_flag;
	no_agent_forwarding_flag |= cert_no_agent_forwarding_flag;
	no_x11_forwarding_flag |= cert_no_x11_forwarding_flag;
	no_pty_flag |= cert_no_pty_flag;
	no_user_rc |= cert_no_user_rc;
	/*
	 * Only permit both CA and key option forced-command if they match.
	 * Otherwise refuse the certificate.
	 */
	if (cert_forced_command != NULL && forced_command != NULL) {
		if (strcmp(forced_command, cert_forced_command) == 0) {
			free(forced_command);
			forced_command = cert_forced_command;
		} else {
			*reason = "certificate and key options forced command "
			    "do not match";
			free(cert_forced_command);
			return -1;
		}
	} else if (cert_forced_command != NULL)
		forced_command = cert_forced_command;
	/* success */
	*reason = NULL;
	return 0;
}

@


1.73
log
@make sure we don't pass a NULL string to vfprintf (triggered by the
principals-command regress test); ok bluhm
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.72 2016/11/30 02:57:40 djm Exp $ */
d61 2
d66 2
d85 1
a85 1
	channel_clear_permitted_opens();
d121 1
d385 1
a385 1
				channel_add_permitted_opens(host, port);
@


1.72
log
@When a forced-command appears in both a certificate and an
authorized keys/principals command= restriction, refuse to accept
the certificate unless they are identical.

The previous (documented) behaviour of having the certificate forced-
command override the other could be a bit confused and more error-prone.

Pointed out by Jann Horn of Project Zero; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.71 2016/03/07 19:02:43 djm Exp $ */
d119 2
a120 1
auth_parse_options(struct passwd *pw, char *opts, char *file, u_long linenum)
@


1.71
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.70 2015/12/10 17:08:40 mmcc Exp $ */
d601 1
a601 1
auth_cert_options(struct sshkey *k, struct passwd *pw)
d611 2
d634 15
a648 3
	/* CA-specified forced command supersedes key option */
	if (cert_forced_command != NULL) {
		free(forced_command);
d650 2
a651 1
	}
@


1.70
log
@Remove NULL-checks before free().

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.69 2015/11/16 00:30:02 djm Exp $ */
d29 1
d121 1
d275 3
a277 3
			const char *remote_ip = get_remote_ipaddr();
			const char *remote_host = get_canonical_hostname(
			    options.use_dns);
d459 1
d533 1
a533 1
				remote_ip = get_remote_ipaddr();
@


1.69
log
@Add a new authorized_keys option "restrict" that includes all current
and future key restrictions (no-*-forwarding, etc). Also add permissive
versions of the existing restrictions, e.g. "no-pty" -> "pty". This
simplifies the task of setting up restricted keys and ensures they are
maximally-restricted, regardless of any permissions we might implement
in the future.

Example:

restrict,pty,command="nethack" ssh-ed25519 AAAAC3NzaC1lZDI1...

Idea from Jann Horn; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.68 2015/07/03 03:43:18 djm Exp $ */
d75 4
a78 8
	if (forced_command) {
		free(forced_command);
		forced_command = NULL;
	}
	if (authorized_principals) {
		free(authorized_principals);
		authorized_principals = NULL;
	}
d171 1
a171 2
			if (forced_command != NULL)
				free(forced_command);
d201 1
a201 2
			if (authorized_principals != NULL)
				free(authorized_principals);
d587 1
a587 2
	if (name != NULL)
		free(name);
d631 1
a631 2
		if (forced_command != NULL)
			free(forced_command);
@


1.68
log
@delete support for legacy v00 certificates; "sure" markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.67 2015/05/01 03:20:54 djm Exp $ */
d88 30
d125 1
a125 1
	int i;
d134 2
a135 4
		cp = "cert-authority";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			key_is_cert_authority = 1;
			opts += strlen(cp);
d138 2
a139 3
		cp = "no-port-forwarding";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			auth_debug_add("Port forwarding disabled.");
d141 9
a149 1
			opts += strlen(cp);
d152 3
a154 5
		cp = "no-agent-forwarding";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			auth_debug_add("Agent forwarding disabled.");
			no_agent_forwarding_flag = 1;
			opts += strlen(cp);
d157 3
a159 5
		cp = "no-X11-forwarding";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			auth_debug_add("X11 forwarding disabled.");
			no_x11_forwarding_flag = 1;
			opts += strlen(cp);
d162 3
a164 5
		cp = "no-pty";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			auth_debug_add("Pty allocation disabled.");
			no_pty_flag = 1;
			opts += strlen(cp);
d167 3
a169 5
		cp = "no-user-rc";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			auth_debug_add("User rc file execution disabled.");
			no_user_rc = 1;
			opts += strlen(cp);
@


1.67
log
@Don't make parsing of authorized_keys' environment= option conditional
on PermitUserEnv - always parse it, but only use the result if the
option is enabled. This prevents the syntax of authorized_keys changing
depending on which sshd_config options were enabled.

bz#2329; based on patch from coladict AT gmail.com, ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.66 2015/04/22 01:24:01 djm Exp $ */
d588 15
a602 29
	if (sshkey_cert_is_legacy(k)) {
		/* All options are in the one field for v00 certs */
		if (parse_option_list(k->cert->critical, pw,
		    OPTIONS_CRITICAL|OPTIONS_EXTENSIONS, 1,
		    &cert_no_port_forwarding_flag,
		    &cert_no_agent_forwarding_flag,
		    &cert_no_x11_forwarding_flag,
		    &cert_no_pty_flag,
		    &cert_no_user_rc,
		    &cert_forced_command,
		    &cert_source_address_done) == -1)
			return -1;
	} else {
		/* Separate options and extensions for v01 certs */
		if (parse_option_list(k->cert->critical, pw,
		    OPTIONS_CRITICAL, 1, NULL, NULL, NULL, NULL, NULL,
		    &cert_forced_command,
		    &cert_source_address_done) == -1)
			return -1;
		if (parse_option_list(k->cert->extensions, pw,
		    OPTIONS_EXTENSIONS, 0,
		    &cert_no_port_forwarding_flag,
		    &cert_no_agent_forwarding_flag,
		    &cert_no_x11_forwarding_flag,
		    &cert_no_pty_flag,
		    &cert_no_user_rc,
		    NULL, NULL) == -1)
			return -1;
	}
@


1.66
log
@unknown certificate extensions are non-fatal, so don't fatal
when they are encountered; bz#2387 reported by Bob Van Zant;
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.65 2015/01/14 10:30:34 markus Exp $ */
d209 1
a209 2
		if (options.permit_user_env &&
		    strncasecmp(opts, cp, strlen(cp)) == 0) {
a234 2
			auth_debug_add("Adding to environment: %.900s", s);
			debug("Adding to environment: %.900s", s);
d236 12
a247 4
			new_envstring = xcalloc(1, sizeof(struct envstring));
			new_envstring->s = s;
			new_envstring->next = custom_environment;
			custom_environment = new_envstring;
@


1.65
log
@swith auth-options to new sshbuf/sshkey; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.64 2014/07/15 15:54:14 millert Exp $ */
d603 1
a603 1
		    OPTIONS_EXTENSIONS, 1,
@


1.64
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.63 2014/06/24 01:13:21 djm Exp $ */
d22 2
d26 1
d29 1
a29 1
#include "buffer.h"
d33 1
a33 1
#include "key.h"
d421 1
a421 1
parse_option_list(u_char *optblob, size_t optblob_len, struct passwd *pw,
d434 15
a448 15
	u_char *data_blob = NULL;
	u_int nlen, dlen, clen;
	Buffer c, data;
	int ret = -1, result, found;

	buffer_init(&data);

	/* Make copy to avoid altering original */
	buffer_init(&c);
	buffer_append(&c, optblob, optblob_len);

	while (buffer_len(&c) > 0) {
		if ((name = buffer_get_cstring_ret(&c, &nlen)) == NULL ||
		    (data_blob = buffer_get_string_ret(&c, &dlen)) == NULL) {
			error("Certificate options corrupt");
d451 2
a452 3
		buffer_append(&data, data_blob, dlen);
		debug3("found certificate option \"%.100s\" len %u",
		    name, dlen);
d476 4
a479 4
				if ((command = buffer_get_cstring_ret(&data,
				    &clen)) == NULL) {
					error("Certificate constraint \"%s\" "
					    "corrupt", name);
d492 4
a495 4
				if ((allowed = buffer_get_cstring_ret(&data,
				    &clen)) == NULL) {
					error("Certificate constraint "
					    "\"%s\" corrupt", name);
d543 1
a543 1
		} else if (buffer_len(&data) != 0) {
a547 1
		buffer_clear(&data);
a548 1
		free(data_blob);
a549 1
		data_blob = NULL;
d563 2
a564 4
	if (data_blob != NULL)
		free(data_blob);
	buffer_free(&data);
	buffer_free(&c);
d573 1
a573 1
auth_cert_options(Key *k, struct passwd *pw)
d583 1
a583 1
	if (key_cert_is_legacy(k)) {
d585 1
a585 2
		if (parse_option_list(buffer_ptr(k->cert->critical),
		    buffer_len(k->cert->critical), pw,
d597 1
a597 2
		if (parse_option_list(buffer_ptr(k->cert->critical),
		    buffer_len(k->cert->critical), pw,
d602 1
a602 2
		if (parse_option_list(buffer_ptr(k->cert->extensions),
		    buffer_len(k->cert->extensions), pw,
@


1.63
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.62 2013/12/19 00:27:57 djm Exp $ */
d27 1
a29 1
#include "misc.h"
d326 1
@


1.62
log
@simplify freeing of source-address certificate restriction
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.61 2013/11/08 00:39:14 djm Exp $ */
d587 2
a588 2
		if (parse_option_list(buffer_ptr(&k->cert->critical),
		    buffer_len(&k->cert->critical), pw,
d600 2
a601 2
		if (parse_option_list(buffer_ptr(&k->cert->critical),
		    buffer_len(&k->cert->critical), pw,
d606 2
a607 2
		if (parse_option_list(buffer_ptr(&k->cert->extensions),
		    buffer_len(&k->cert->extensions), pw,
@


1.61
log
@use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.60 2013/11/02 22:34:01 markus Exp $ */
d433 1
a433 1
	int ret = -1, found;
d502 4
a505 2
				switch (addr_match_cidr_list(remote_ip,
				    allowed)) {
a507 1
					free(allowed);
a519 1
					free(allowed);
d522 1
a524 1
					free(allowed);
@


1.60
log
@no need to include monitor_wrap.h and ssh-gss.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.59 2013/07/12 00:19:58 djm Exp $ */
d236 1
a236 1
			new_envstring = xmalloc(sizeof(struct envstring));
@


1.59
log
@fix pointer-signedness warnings from clang/llvm-3.3; "seems nice" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.58 2013/05/17 00:13:13 djm Exp $ */
a33 4
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"
@


1.59.2.1
log
@cherrypick commit:

date: 2013/11/08 00:39:15;  author: djm;  state: Exp;  lines: +2 -2;
use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.59 2013/07/12 00:19:58 djm Exp $ */
d240 1
a240 1
			new_envstring = xcalloc(1, sizeof(struct envstring));
@


1.58
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.57 2012/12/02 20:46:11 djm Exp $ */
d433 2
a434 1
	u_char *name = NULL, *data_blob = NULL;
d552 2
a553 1
		name = data_blob = NULL;
@


1.57
log
@make AllowTcpForwarding accept "local" and "remote" in addition to its
current "yes"/"no" to allow the server to specify whether just local or
remote TCP forwarding is enabled. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.56 2011/10/18 04:58:26 djm Exp $ */
d73 2
a74 2
		xfree(ce->s);
		xfree(ce);
d77 1
a77 1
		xfree(forced_command);
d81 1
a81 1
		xfree(authorized_principals);
d150 1
a150 1
				xfree(forced_command);
d168 1
a168 1
				xfree(forced_command);
d181 1
a181 1
				xfree(authorized_principals);
d199 1
a199 1
				xfree(authorized_principals);
d233 1
a233 1
				xfree(s);
d270 1
a270 1
				xfree(patterns);
d278 1
a278 1
				xfree(patterns);
d288 1
a288 1
				xfree(patterns);
d324 1
a324 1
				xfree(patterns);
d338 1
a338 1
				xfree(patterns);
d347 1
a347 1
				xfree(patterns);
d352 1
a352 1
			xfree(patterns);
d371 1
a371 1
				xfree(tun);
d377 1
a377 1
			xfree(tun);
d485 1
a485 1
					xfree(command);
d501 1
a501 1
					xfree(allowed);
d509 1
a509 1
					xfree(allowed);
d522 1
a522 1
					xfree(allowed);
d527 1
a527 1
					xfree(allowed);
d549 2
a550 2
		xfree(name);
		xfree(data_blob);
d560 1
a560 1
		xfree(*cert_forced_command);
d564 1
a564 1
		xfree(name);
d566 1
a566 1
		xfree(data_blob);
d628 1
a628 1
			xfree(forced_command);
@


1.57.2.1
log
@openssh-6.4 for the 5.3 branch; reminded by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.59.2.1 2013/11/08 01:33:56 djm Exp $ */
d240 1
a240 1
			new_envstring = xcalloc(1, sizeof(struct envstring));
@


1.56
log
@remove explict search for \0 in packet strings, this job is now done
implicitly by buffer_get_cstring; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.55 2011/09/23 00:22:04 dtucker Exp $ */
d350 1
a350 1
			if (options.allow_tcp_forwarding)
@


1.55
log
@Add wildcard support to PermitOpen, allowing things like "PermitOpen
localhost:*".  bz #1857, ok djm markus.
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.54 2010/12/24 21:41:48 djm Exp $ */
a452 4
		if (strlen(name) != nlen) {
			error("Certificate constraint name contains \\0");
			goto out;
		}
a481 5
				if (strlen(command) != clen) {
					error("force-command constraint "
					    "contains \\0");
					goto out;
				}
a495 5
					goto out;
				}
				if (strlen(allowed) != clen) {
					error("source-address constraint "
					    "contains \\0");
@


1.54
log
@don't send the actual forced command in a debug message; ok markus deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.53 2010/08/31 09:58:37 djm Exp $ */
d342 1
a342 1
			if (p == NULL || (port = a2port(p)) <= 0) {
@


1.53
log
@Add buffer_get_cstring() and related functions that verify that the
string extracted from the buffer contains no embedded \0 characters*
This prevents random (possibly malicious) crap from being appended to
strings where it would not be noticed if the string is used with
a string(3) function.

Use the new API in a few sensitive places.

* actually, we allow a single one at the end of the string for now because
we don't know how many deployed implementations get this wrong, but don't
count on this to remain indefinitely.
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.52 2010/05/20 23:46:02 djm Exp $ */
d173 1
a173 1
			auth_debug_add("Forced command: %.900s", forced_command);
@


1.52
log
@Move the permit-* options to the non-critical "extensions" field for v01
certificates. The logic is that if another implementation fails to
implement them then the connection just loses features rather than fails
outright.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.51 2010/05/07 11:30:29 djm Exp $ */
d445 1
a445 1
		if ((name = buffer_get_string_ret(&c, &nlen)) == NULL ||
d480 1
a480 1
				if ((command = buffer_get_string_ret(&data,
d501 1
a501 1
				if ((allowed = buffer_get_string_ret(&data,
@


1.51
log
@add some optional indirection to matching of principal names listed
in certificates. Currently, a certificate must include the a user's name
to be accepted for authentication. This change adds the ability to
specify a list of certificate principal names that are acceptable.

When authenticating using a CA trusted through ~/.ssh/authorized_keys,
this adds a new principals="name1[,name2,...]" key option.

For CAs listed through sshd_config's TrustedCAKeys option, a new config
option "AuthorizedPrincipalsFile" specifies a per-user file containing
the list of acceptable names.

If either option is absent, the current behaviour of requiring the
username to appear in principals continues to apply.

These options are useful for role accounts, disjoint account namespaces
and "user@@realm"-style naming policies in certificates.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.50 2010/04/16 01:47:26 djm Exp $ */
d418 12
a429 6
/*
 * Set options from critical certificate options. These supersede user key
 * options so this must be called after auth_parse_options().
 */
int
auth_cert_options(Key *k, struct passwd *pw)
d431 2
d436 1
a436 9
	int ret = -1;

	int cert_no_port_forwarding_flag = 1;
	int cert_no_agent_forwarding_flag = 1;
	int cert_no_x11_forwarding_flag = 1;
	int cert_no_pty_flag = 1;
	int cert_no_user_rc = 1;
	char *cert_forced_command = NULL;
	int cert_source_address_done = 0;
d442 1
a442 2
	buffer_append(&c,
	    buffer_ptr(&k->cert->critical), buffer_len(&k->cert->critical));
d451 1
a451 1
		debug3("found certificate constraint \"%.100s\" len %u",
d457 42
a498 17
		if (strcmp(name, "permit-X11-forwarding") == 0)
			cert_no_x11_forwarding_flag = 0;
		else if (strcmp(name, "permit-agent-forwarding") == 0)
			cert_no_agent_forwarding_flag = 0;
		else if (strcmp(name, "permit-port-forwarding") == 0)
			cert_no_port_forwarding_flag = 0;
		else if (strcmp(name, "permit-pty") == 0)
			cert_no_pty_flag = 0;
		else if (strcmp(name, "permit-user-rc") == 0)
			cert_no_user_rc = 0;
		else if (strcmp(name, "force-command") == 0) {
			char *command = buffer_get_string_ret(&data, &clen);

			if (command == NULL) {
				error("Certificate constraint \"%s\" corrupt",
				    name);
				goto out;
d500 45
a544 3
			if (strlen(command) != clen) {
				error("force-command constraint contains \\0");
				goto out;
d546 6
a551 46
			if (cert_forced_command != NULL) {
				error("Certificate has multiple "
				    "force-command options");
				xfree(command);
				goto out;
			}
			cert_forced_command = command;
		} else if (strcmp(name, "source-address") == 0) {
			char *allowed = buffer_get_string_ret(&data, &clen);
			const char *remote_ip = get_remote_ipaddr();
			
			if (allowed == NULL) {
				error("Certificate constraint \"%s\" corrupt",
				    name);
				goto out;
			}
			if (strlen(allowed) != clen) {
				error("source-address constraint contains \\0");
				goto out;
			}
			if (cert_source_address_done++) {
				error("Certificate has multiple "
				    "source-address options");
				xfree(allowed);
				goto out;
			}
			switch (addr_match_cidr_list(remote_ip, allowed)) {
			case 1:
				/* accepted */
				xfree(allowed);
				break;
			case 0:
				/* no match */
				logit("Authentication tried for %.100s with "
				    "valid certificate but not from a "
				    "permitted host (ip=%.200s).",
				    pw->pw_name, remote_ip);
				auth_debug_add("Your address '%.200s' is not "
				    "permitted to use this certificate for "
				    "login.", remote_ip);
				xfree(allowed);
				goto out;
			case -1:
				error("Certificate source-address contents "
				    "invalid");
				xfree(allowed);
d553 3
d557 2
a558 8
		} else {
			error("Certificate constraint \"%s\" is not supported",
			    name);
			goto out;
		}

		if (buffer_len(&data) != 0) {
			error("Certificate constraint \"%s\" corrupt "
a566 1

d570 64
d645 1
a645 9
	
 out:
	if (name != NULL)
		xfree(name);
	if (data_blob != NULL)
		xfree(data_blob);
	buffer_free(&data);
	buffer_free(&c);
	return ret;
@


1.50
log
@revised certificate format ssh-{dss,rsa}-cert-v01@@openssh.com with the
following changes:

move the nonce field to the beginning of the certificate where it can
better protect against chosen-prefix attacks on the signature hash

Rename "constraints" field to "critical options"

Add a new non-critical "extensions" field

Add a serial number

The older format is still support for authentication and cert generation
(use "ssh-keygen -t v00 -s ca_key ..." to generate a v00 certificate)

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.49 2010/03/16 15:46:52 stevesk Exp $ */
d56 3
d80 4
d149 2
d174 32
@


1.49
log
@spelling in error message. ok djm kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.48 2010/03/07 11:57:13 dtucker Exp $ */
a27 1
#include "auth-options.h"
d31 1
d378 2
a379 2
 * Set options from certificate constraints. These supersede user key options
 * so this must be called after auth_parse_options().
d382 1
a382 1
auth_cert_constraints(Buffer *c_orig, struct passwd *pw)
d401 2
a402 1
	buffer_append(&c, buffer_ptr(c_orig), buffer_len(c_orig));
d407 1
a407 1
			error("Certificate constraints corrupt");
d441 1
a441 1
				    "force-command constraints");
d461 1
a461 1
				    "source-address constraints");
d504 1
a504 1
	/* successfully parsed all constraints */
@


1.48
log
@Hold authentication debug messages until after successful authentication.
Fixes an info leak of environment variables specified in authorized_keys,
reported by Jacob Appelbaum.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.47 2010/03/04 23:27:25 djm Exp $ */
d435 1
a435 1
				error("force-command constrain contains \\0");
d455 1
a455 1
				error("source-address constrain contains \\0");
@


1.47
log
@"force-command" is not spelled "forced-command"; spotted by
imorgan AT nas.nasa.gov
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.46 2010/03/03 01:44:36 djm Exp $ */
a78 1
	auth_debug_reset();
a363 3
	if (!use_privsep)
		auth_debug_send();

a371 3

	if (!use_privsep)
		auth_debug_send();
@


1.46
log
@reject strings with embedded ASCII nul chars in certificate key IDs,
principal names and constraints
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.45 2010/02/26 20:29:54 djm Exp $ */
d447 1
a447 1
				    "forced-command constraints");
@


1.45
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.44 2009/01/22 10:09:16 djm Exp $ */
d392 1
a392 1
	u_int len;
d411 2
a412 2
		if ((name = buffer_get_string_ret(&c, NULL)) == NULL ||
		    (data_blob = buffer_get_string_ret(&c, &len)) == NULL) {
d416 1
a416 1
		buffer_append(&data, data_blob, len);
d418 5
a422 1
		    name, len);
d434 1
a434 1
			char *command = buffer_get_string_ret(&data, NULL);
d441 4
d453 1
a453 1
			char *allowed = buffer_get_string_ret(&data, NULL);
d459 4
@


1.44
log
@another chunk of a2port() diff that got away. wtfdjm??
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.43 2008/06/10 23:06:19 djm Exp $ */
d45 1
d66 1
d99 6
d383 140
@


1.43
log
@support CIDR address matching in .ssh/authorized_keys from="..." stanzas

ok and extensive testing dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.42 2008/05/08 12:02:23 djm Exp $ */
d256 1
a256 1
			u_short port;
d294 1
a294 1
			if (p == NULL || (port = a2port(p)) == 0) {
@


1.42
log
@Implement a channel success/failure status confirmation callback
mechanism. Each channel maintains a queue of callbacks, which will
be drained in order (RFC4253 guarantees confirm messages are not
reordered within an channel).

Also includes a abandonment callback to clean up if a channel is
closed without sending confirmation messages. This probably
shouldn't happen in compliant implementations, but it could be
abused to leak memory.

ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.41 2008/03/26 21:28:14 djm Exp $ */
d227 13
a239 2
			if (match_host_and_ip(remote_host, remote_ip,
			    patterns) != 1) {
d248 1
a248 2
				/* deny access */
				return 0;
d250 2
a251 3
			xfree(patterns);
			/* Host name matches. */
			goto next_option;
@


1.41
log
@add no-user-rc authorized_keys option to disable execution of ~/.ssh/rc
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.40 2006/08/03 03:34:41 deraadt Exp $ */
d14 1
@


1.40
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.39 2006/07/22 20:48:22 stevesk Exp $ */
d43 1
d63 1
d121 7
@


1.39
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.38 2006/07/17 12:02:24 dtucker Exp $ */
a12 2
#include "includes.h"

d18 2
d25 1
d30 6
a36 1
#include "auth.h"
@


1.38
log
@Use '\0' rather than 0 to terminates strings; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.37 2006/07/12 22:28:51 stevesk Exp $ */
d19 1
@


1.37
log
@move #include <netdb.h> out of includes.h; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.36 2006/07/06 16:03:53 stevesk Exp $ */
d139 1
a139 1
			forced_command[i] = 0;
d171 1
a171 1
			s[i] = 0;
d208 1
a208 1
			patterns[i] = 0;
d253 1
a253 1
			patterns[i] = 0;
d301 1
a301 1
			tun[i] = 0;
@


1.36
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.35 2006/03/25 13:17:01 djm Exp $ */
d17 1
@


1.35
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d14 4
@


1.34
log
@RCSID() can die
@
text
@d1 1
@


1.33
log
@two changes to the new ssh tunnel support. this breaks compatibility
with the initial commit but is required for a portable approach.
- make the tunnel id u_int and platform friendly, use predefined types.
- support configuration of layer 2 (ethernet) or layer 3
(point-to-point, default) modes. configuration is done using the
Tunnel (yes|point-to-point|ethernet|no) option is ssh_config(5) and
restricted by the PermitTunnel (yes|point-to-point|ethernet|no) option
in sshd_config(5).

ok djm@@, man page bits by jmc@@
@
text
@a12 1
RCSID("$OpenBSD: auth-options.c,v 1.32 2005/12/06 22:38:27 reyk Exp $");
@


1.33.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth-options.c,v 1.40 2006/08/03 03:34:41 deraadt Exp $ */
d12 2
a13 7
#include <sys/types.h>

#include <netdb.h>
#include <pwd.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
a18 1
#include "buffer.h"
d23 1
a23 2
#include "key.h"
#include "hostfile.h"
a24 4
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"
d134 1
a134 1
			forced_command[i] = '\0';
d166 1
a166 1
			s[i] = '\0';
d203 1
a203 1
			patterns[i] = '\0';
d248 1
a248 1
			patterns[i] = '\0';
d296 1
a296 1
			tun[i] = '\0';
@


1.32
log
@Add support for tun(4) forwarding over OpenSSH, based on an idea and
initial channel code bits by markus@@. This is a simple and easy way to
use OpenSSH for ad hoc virtual private network connections, e.g.
administrative tunnels or secure wireless access. It's based on a new
ssh channel and works similar to the existing TCP forwarding support,
except that it depends on the tun(4) network interface on both ends of
the connection for layer 2 or layer 3 tunneling. This diff also adds
support for LocalCommand in the ssh(1) client.

ok djm@@, markus@@, jmc@@ (manpages), tested and discussed with others
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.31 2005/03/10 22:40:38 deraadt Exp $");
d299 1
a299 1
			if (forced_tun_device < -1) {
@


1.31
log
@spacing
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.30 2005/03/10 22:01:05 deraadt Exp $");
d38 3
d60 1
d274 35
@


1.31.4.1
log
@upgrade to OpenSSH 4.3
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.33 2005/12/08 18:34:11 reyk Exp $");
a37 3
/* "tunnel=" option. */
int forced_tun_device = -1;

a56 1
	forced_tun_device = -1;
a269 35
			goto next_option;
		}
		cp = "tunnel=\"";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			char *tun = NULL;
			opts += strlen(cp);
			tun = xmalloc(strlen(opts) + 1);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				tun[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: missing end quote",
				    file, linenum);
				xfree(tun);
				forced_tun_device = -1;
				goto bad_option;
			}
			tun[i] = 0;
			forced_tun_device = a2tun(tun, NULL);
			xfree(tun);
			if (forced_tun_device == SSH_TUNID_ERR) {
				debug("%.100s, line %lu: invalid tun device",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: invalid tun device",
				    file, linenum);
				forced_tun_device = -1;
				goto bad_option;
			}
			auth_debug_add("Forced tun device: %d", forced_tun_device);
			opts++;
@


1.31.4.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth-options.c,v 1.40 2006/08/03 03:34:41 deraadt Exp $ */
d12 2
a13 7
#include <sys/types.h>

#include <netdb.h>
#include <pwd.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
a18 1
#include "buffer.h"
d23 1
a23 2
#include "key.h"
#include "hostfile.h"
a24 4
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"
d134 1
a134 1
			forced_command[i] = '\0';
d166 1
a166 1
			s[i] = '\0';
d203 1
a203 1
			patterns[i] = '\0';
d248 1
a248 1
			patterns[i] = '\0';
d296 1
a296 1
			tun[i] = '\0';
@


1.31.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.33 2005/12/08 18:34:11 reyk Exp $");
a37 3
/* "tunnel=" option. */
int forced_tun_device = -1;

a56 1
	forced_tun_device = -1;
a269 35
			goto next_option;
		}
		cp = "tunnel=\"";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			char *tun = NULL;
			opts += strlen(cp);
			tun = xmalloc(strlen(opts) + 1);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				tun[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: missing end quote",
				    file, linenum);
				xfree(tun);
				forced_tun_device = -1;
				goto bad_option;
			}
			tun[i] = 0;
			forced_tun_device = a2tun(tun, NULL);
			xfree(tun);
			if (forced_tun_device == SSH_TUNID_ERR) {
				debug("%.100s, line %lu: invalid tun device",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: invalid tun device",
				    file, linenum);
				forced_tun_device = -1;
				goto bad_option;
			}
			auth_debug_add("Forced tun device: %d", forced_tun_device);
			opts++;
@


1.30
log
@spacing
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.29 2005/03/01 10:09:52 djm Exp $");
d250 1
a250 1
				    "specification <%.100s>", file, linenum, 
@


1.29
log
@bz#413: allow optional specification of bind address for port forwardings.
Patch originally by Dan Astorian, but worked on by several people
Adds GatewayPorts=clientspecified option on server to allow remote forwards
to bind to client-specified ports.

ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.28 2003/06/02 09:17:34 markus Exp $");
d258 2
a259 2
 			host = cleanhostname(host);
 			if (p == NULL || (port = a2port(p)) == 0) {
@


1.28
log
@deprecate VerifyReverseMapping since it's dangerous if combined
with IP based access control as noted by Mike Harding; replace with
a UseDNS option, UseDNS is on by default and includes the
VerifyReverseMapping check; with itojun@@, provos@@, jakob@@ and deraadt@@
ok deraadt@@, djm@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.27 2003/04/08 20:21:28 itojun Exp $");
d220 1
a220 1
			char host[256], sport[6];
d239 2
a240 2
				auth_debug_add("%.100s, line %lu: missing end quote",
				    file, linenum);
d246 6
a251 4
			if (sscanf(patterns, "%255[^:]:%5[0-9]", host, sport) != 2 &&
			    sscanf(patterns, "%255[^/]/%5[0-9]", host, sport) != 2) {
				debug("%.100s, line %lu: Bad permitopen specification "
				    "<%.100s>", file, linenum, patterns);
d253 2
a254 1
				    "Bad permitopen specification", file, linenum);
d258 4
a261 3
			if ((port = a2port(sport)) == 0) {
				debug("%.100s, line %lu: Bad permitopen port <%.100s>",
				    file, linenum, sport);
@


1.28.4.1
log
@upgrade to OpenSSH 4.0
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.29 2005/03/01 10:09:52 djm Exp $");
d220 1
a220 1
			char *host, *p;
d239 2
a240 2
				auth_debug_add("%.100s, line %lu: missing "
				    "end quote", file, linenum);
d246 4
a249 6
			p = patterns;
			host = hpdelim(&p);
			if (host == NULL || strlen(host) >= NI_MAXHOST) {
				debug("%.100s, line %lu: Bad permitopen "
				    "specification <%.100s>", file, linenum, 
				    patterns);
d251 1
a251 2
				    "Bad permitopen specification", file,
				    linenum);
d255 3
a257 4
 			host = cleanhostname(host);
 			if (p == NULL || (port = a2port(p)) == 0) {
				debug("%.100s, line %lu: Bad permitopen port "
				    "<%.100s>", file, linenum, p ? p : "");
@


1.28.6.1
log
@upgrade to OpenSSH 4.0
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.29 2005/03/01 10:09:52 djm Exp $");
d220 1
a220 1
			char *host, *p;
d239 2
a240 2
				auth_debug_add("%.100s, line %lu: missing "
				    "end quote", file, linenum);
d246 4
a249 6
			p = patterns;
			host = hpdelim(&p);
			if (host == NULL || strlen(host) >= NI_MAXHOST) {
				debug("%.100s, line %lu: Bad permitopen "
				    "specification <%.100s>", file, linenum, 
				    patterns);
d251 1
a251 2
				    "Bad permitopen specification", file,
				    linenum);
d255 3
a257 4
 			host = cleanhostname(host);
 			if (p == NULL || (port = a2port(p)) == 0) {
				debug("%.100s, line %lu: Bad permitopen port "
				    "<%.100s>", file, linenum, p ? p : "");
@


1.28.6.2
log
@upgrade to OpenSSH 4.1
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.31 2005/03/10 22:40:38 deraadt Exp $");
d250 1
a250 1
				    "specification <%.100s>", file, linenum,
d258 2
a259 2
			host = cleanhostname(host);
			if (p == NULL || (port = a2port(p)) == 0) {
@


1.27
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.26 2002/07/30 17:03:55 markus Exp $");
d176 1
a176 1
			    options.verify_reverse_mapping);
@


1.26
log
@add PermitUserEnvironment (off by default!); from dot@@dotat.at; ok provos, deraadt
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.25 2002/07/21 18:32:20 stevesk Exp $");
d204 1
a204 1
				log("Authentication tried for %.100s with "
d290 1
a290 1
	log("Bad options in %.100s file, line %lu: %.50s",
@


1.26.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.28 2003/06/02 09:17:34 markus Exp $");
d176 1
a176 1
			    options.use_dns);
d204 1
a204 1
				logit("Authentication tried for %.100s with "
d290 1
a290 1
	logit("Bad options in %.100s file, line %lu: %.50s",
@


1.26.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.28 2003/06/02 09:17:34 markus Exp $");
d176 1
a176 1
			    options.use_dns);
d204 1
a204 1
				logit("Authentication tried for %.100s with "
d290 1
a290 1
	logit("Bad options in %.100s file, line %lu: %.50s",
@


1.26.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@@


1.25
log
@unneeded includes
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.24 2002/05/13 20:44:58 markus Exp $");
d136 2
a137 1
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
@


1.24
log
@move the packet_send_debug handling from auth-options.c to auth.c; ok provos@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.23 2002/03/19 10:35:39 markus Exp $");
a14 1
#include "packet.h"
a21 1
#include "bufaux.h"
@


1.23
log
@clean up prototypes
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.22 2002/03/18 17:50:31 provos Exp $");
d26 1
a26 4

/* Debugging messages */
Buffer auth_debug;
int auth_debug_init;
a41 12
static void
auth_send_debug(Buffer *m)
{
	char *msg;

	while (buffer_len(m)) {
		msg = buffer_get_string(m, NULL);
		packet_send_debug("%s", msg);
		xfree(msg);
	}
}

a44 7
	if (auth_debug_init)
		buffer_clear(&auth_debug);
	else {
		buffer_init(&auth_debug);
		auth_debug_init = 1;
	}

d60 1
a69 1
	char tmp[1024];
d82 1
a82 2
			snprintf(tmp, sizeof(tmp), "Port forwarding disabled.");
			buffer_put_cstring(&auth_debug, tmp);
d89 1
a89 2
			snprintf(tmp, sizeof(tmp), "Agent forwarding disabled.");
			buffer_put_cstring(&auth_debug, tmp);
d96 1
a96 2
			snprintf(tmp, sizeof(tmp), "X11 forwarding disabled.");
			buffer_put_cstring(&auth_debug, tmp);
d103 1
a103 2
			snprintf(tmp, sizeof(tmp), "Pty allocation disabled.");
			buffer_put_cstring(&auth_debug, tmp);
d126 1
a126 1
				snprintf(tmp, sizeof(tmp), "%.100s, line %lu: missing end quote",
a127 1
				buffer_put_cstring(&auth_debug, tmp);
d133 1
a133 2
			snprintf(tmp, sizeof(tmp), "Forced command: %.900s", forced_command);
			buffer_put_cstring(&auth_debug, tmp);
d158 1
a158 1
				snprintf(tmp, sizeof(tmp), "%.100s, line %lu: missing end quote",
a159 1
				buffer_put_cstring(&auth_debug, tmp);
d164 1
a164 2
			snprintf(tmp, sizeof(tmp), "Adding to environment: %.900s", s);
			buffer_put_cstring(&auth_debug, tmp);
d195 1
a195 1
				snprintf(tmp, sizeof(tmp), "%.100s, line %lu: missing end quote",
a196 1
				buffer_put_cstring(&auth_debug, tmp);
d209 1
a209 2
				snprintf(tmp, sizeof(tmp),
				    "Your host '%.200s' is not "
a211 1
				buffer_put_cstring(&auth_debug, tmp);
d240 1
a240 1
				snprintf(tmp, sizeof(tmp), "%.100s, line %lu: missing end quote",
a241 1
				buffer_put_cstring(&auth_debug, tmp);
d251 1
a251 1
				snprintf(tmp, sizeof(tmp), "%.100s, line %lu: "
a252 1
				buffer_put_cstring(&auth_debug, tmp);
d259 1
a259 1
				snprintf(tmp, sizeof(tmp), "%.100s, line %lu: "
a260 1
				buffer_put_cstring(&auth_debug, tmp);
d285 1
a285 1
		auth_send_debug(&auth_debug);
d293 1
a293 2
	snprintf(tmp, sizeof(tmp),
	    "Bad options in %.100s file, line %lu: %.50s",
a294 1
	buffer_put_cstring(&auth_debug, tmp);
d297 1
a297 1
		auth_send_debug(&auth_debug);
@


1.23.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.24 2002/05/13 20:44:58 markus Exp $");
d26 4
a29 1
#include "auth.h"
d45 12
d60 7
a81 1
	auth_debug_reset();
d91 1
d104 2
a105 1
			auth_debug_add("Port forwarding disabled.");
d112 2
a113 1
			auth_debug_add("Agent forwarding disabled.");
d120 2
a121 1
			auth_debug_add("X11 forwarding disabled.");
d128 2
a129 1
			auth_debug_add("Pty allocation disabled.");
d152 1
a152 1
				auth_debug_add("%.100s, line %lu: missing end quote",
d154 1
d160 2
a161 1
			auth_debug_add("Forced command: %.900s", forced_command);
d186 1
a186 1
				auth_debug_add("%.100s, line %lu: missing end quote",
d188 1
d193 2
a194 1
			auth_debug_add("Adding to environment: %.900s", s);
d225 1
a225 1
				auth_debug_add("%.100s, line %lu: missing end quote",
d227 1
d240 2
a241 1
				auth_debug_add("Your host '%.200s' is not "
d244 1
d273 1
a273 1
				auth_debug_add("%.100s, line %lu: missing end quote",
d275 1
d285 1
a285 1
				auth_debug_add("%.100s, line %lu: "
d287 1
d294 1
a294 1
				auth_debug_add("%.100s, line %lu: "
d296 1
d321 1
a321 1
		auth_debug_send();
d329 2
a330 1
	auth_debug_add("Bad options in %.100s file, line %lu: %.50s",
d332 1
d335 1
a335 1
		auth_debug_send();
@


1.23.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.23.2.3
log
@Pull in OpenSSH-3.4
@
text
@@


1.23.2.4
log
@Update to OpenSSH 3.5
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.26 2002/07/30 17:03:55 markus Exp $");
d15 1
d23 1
d138 1
a138 2
		if (options.permit_user_env &&
		    strncasecmp(opts, cp, strlen(cp)) == 0) {
@


1.22
log
@integrate privilege separated openssh; its turned off by default for now.
work done by me and markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.21 2002/01/29 14:32:03 markus Exp $");
d45 1
a45 1
void
@


1.21
log
@s/ReverseMappingCheck/VerifyReverseMapping/ and avoid confusion; ok stevesk@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.20 2001/08/30 20:36:34 stevesk Exp $");
d23 1
d25 5
d46 12
d60 7
d91 1
d104 2
a105 1
			packet_send_debug("Port forwarding disabled.");
d112 2
a113 1
			packet_send_debug("Agent forwarding disabled.");
d120 2
a121 1
			packet_send_debug("X11 forwarding disabled.");
d128 2
a129 1
			packet_send_debug("Pty allocation disabled.");
d152 1
a152 1
				packet_send_debug("%.100s, line %lu: missing end quote",
d154 1
d160 2
a161 1
			packet_send_debug("Forced command: %.900s", forced_command);
d186 1
a186 1
				packet_send_debug("%.100s, line %lu: missing end quote",
d188 1
d193 2
a194 1
			packet_send_debug("Adding to environment: %.900s", s);
d225 1
a225 1
				packet_send_debug("%.100s, line %lu: missing end quote",
d227 1
d240 2
a241 1
				packet_send_debug("Your host '%.200s' is not "
d244 1
d273 1
a273 1
				packet_send_debug("%.100s, line %lu: missing end quote",
d275 1
d285 1
a285 1
				packet_send_debug("%.100s, line %lu: "
d287 1
d294 1
a294 1
				packet_send_debug("%.100s, line %lu: "
d296 1
d319 4
d329 2
a330 1
	packet_send_debug("Bad options in %.100s file, line %lu: %.50s",
d332 5
@


1.20
log
@validate ports for permitopen key file option. add host/port
alternative syntax for IPv6. ok markus@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.19 2001/06/24 05:25:09 markus Exp $");
d173 1
a173 1
			    options.reverse_mapping_check);
@


1.20.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.21 2002/01/29 14:32:03 markus Exp $");
d173 1
a173 1
			    options.verify_reverse_mapping);
@


1.20.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.24 2002/05/13 20:44:58 markus Exp $");
a22 1
#include "bufaux.h"
a23 2
#include "monitor_wrap.h"
#include "auth.h"
a56 1
	auth_debug_reset();
d78 1
a78 1
			auth_debug_add("Port forwarding disabled.");
d85 1
a85 1
			auth_debug_add("Agent forwarding disabled.");
d92 1
a92 1
			auth_debug_add("X11 forwarding disabled.");
d99 1
a99 1
			auth_debug_add("Pty allocation disabled.");
d122 1
a122 1
				auth_debug_add("%.100s, line %lu: missing end quote",
d129 1
a129 1
			auth_debug_add("Forced command: %.900s", forced_command);
d154 1
a154 1
				auth_debug_add("%.100s, line %lu: missing end quote",
d160 1
a160 1
			auth_debug_add("Adding to environment: %.900s", s);
d191 1
a191 1
				auth_debug_add("%.100s, line %lu: missing end quote",
d205 1
a205 1
				auth_debug_add("Your host '%.200s' is not "
d236 1
a236 1
				auth_debug_add("%.100s, line %lu: missing end quote",
d247 1
a247 1
				auth_debug_add("%.100s, line %lu: "
d255 1
a255 1
				auth_debug_add("%.100s, line %lu: "
a278 4

	if (!use_privsep)
		auth_debug_send();

d285 1
a285 1
	auth_debug_add("Bad options in %.100s file, line %lu: %.50s",
a286 4

	if (!use_privsep)
		auth_debug_send();

@


1.20.2.3
log
@Update to OpenSSH 3.5
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.26 2002/07/30 17:03:55 markus Exp $");
d15 1
d23 1
d138 1
a138 2
		if (options.permit_user_env &&
		    strncasecmp(opts, cp, strlen(cp)) == 0) {
@


1.19
log
@move ip+hostname check to match.c
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.18 2001/05/31 10:30:12 markus Exp $");
d23 1
d217 1
a218 1
			char *c, *ep;
d243 6
a248 6
			c = strchr(patterns, ':');
			if (c == NULL) {
				debug("%.100s, line %lu: permitopen: missing colon <%.100s>",
				    file, linenum, patterns);
				packet_send_debug("%.100s, line %lu: missing colon",
				    file, linenum);
d252 5
a256 8
			*c = 0;
			c++;
			port = strtol(c, &ep, 0);
			if (c == ep) {
				debug("%.100s, line %lu: permitopen: missing port <%.100s>",
				    file, linenum, patterns);
				packet_send_debug("%.100s, line %lu: missing port",
				    file, linenum);
d261 1
a261 1
				channel_add_permitted_opens(patterns, port);
@


1.18
log
@undo the .c file split, just merge the header and keep the cvs history
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.17 2001/05/30 12:55:06 markus Exp $");
a169 1
			int mname, mip;
d197 3
a199 12
			/*
			 * Deny access if we get a negative
			 * match for the hostname or the ip
			 * or if we get not match at all
			 */
			mname = match_hostname(remote_host, patterns,
			    strlen(patterns));
			mip = match_hostname(remote_ip, patterns,
			    strlen(patterns));
			xfree(patterns);
			if (mname == -1 || mip == -1 ||
			    (mname != 1 && mip != 1)) {
d210 1
@


1.17
log
@channel layer cleanup: merge header files and split .c files
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.16 2001/03/18 12:07:52 markus Exp $");
d20 1
a20 1
#include "channel.h"
@


1.16
log
@ignore permitopen="host:port" if AllowTcpForwarding==no
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.15 2001/03/16 19:06:28 markus Exp $");
d20 1
a20 1
#include "channels.h"
@


1.16.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.20 2001/08/30 20:36:34 stevesk Exp $");
a22 1
#include "misc.h"
d170 1
d198 12
a209 3
			if (match_host_and_ip(remote_host, remote_ip,
			    patterns) != 1) {
				xfree(patterns);
a219 1
			xfree(patterns);
a224 1
			char host[256], sport[6];
d226 1
d251 6
a256 6
			if (sscanf(patterns, "%255[^:]:%5[0-9]", host, sport) != 2 &&
			    sscanf(patterns, "%255[^/]/%5[0-9]", host, sport) != 2) {
				debug("%.100s, line %lu: Bad permitopen specification "
				    "<%.100s>", file, linenum, patterns);
				packet_send_debug("%.100s, line %lu: "
				    "Bad permitopen specification", file, linenum);
d260 8
a267 5
			if ((port = a2port(sport)) == 0) {
				debug("%.100s, line %lu: Bad permitopen port <%.100s>",
				    file, linenum, sport);
				packet_send_debug("%.100s, line %lu: "
				    "Bad permitopen port", file, linenum);
d272 1
a272 1
				channel_add_permitted_opens(host, port);
@


1.16.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.21 2002/01/29 14:32:03 markus Exp $");
d173 1
a173 1
			    options.verify_reverse_mapping);
@


1.16.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.24 2002/05/13 20:44:58 markus Exp $");
a22 1
#include "bufaux.h"
a23 2
#include "monitor_wrap.h"
#include "auth.h"
a56 1
	auth_debug_reset();
d78 1
a78 1
			auth_debug_add("Port forwarding disabled.");
d85 1
a85 1
			auth_debug_add("Agent forwarding disabled.");
d92 1
a92 1
			auth_debug_add("X11 forwarding disabled.");
d99 1
a99 1
			auth_debug_add("Pty allocation disabled.");
d122 1
a122 1
				auth_debug_add("%.100s, line %lu: missing end quote",
d129 1
a129 1
			auth_debug_add("Forced command: %.900s", forced_command);
d154 1
a154 1
				auth_debug_add("%.100s, line %lu: missing end quote",
d160 1
a160 1
			auth_debug_add("Adding to environment: %.900s", s);
d191 1
a191 1
				auth_debug_add("%.100s, line %lu: missing end quote",
d205 1
a205 1
				auth_debug_add("Your host '%.200s' is not "
d236 1
a236 1
				auth_debug_add("%.100s, line %lu: missing end quote",
d247 1
a247 1
				auth_debug_add("%.100s, line %lu: "
d255 1
a255 1
				auth_debug_add("%.100s, line %lu: "
a278 4

	if (!use_privsep)
		auth_debug_send();

d285 1
a285 1
	auth_debug_add("Bad options in %.100s file, line %lu: %.50s",
a286 4

	if (!use_privsep)
		auth_debug_send();

@


1.15
log
@implement "permitopen" key option, restricts -L style forwarding to
to specified host:port pairs. based on work by harlan@@genua.de
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.14 2001/03/13 17:34:42 markus Exp $");
d271 2
a272 1
			channel_add_permitted_opens(patterns, port);
@


1.14
log
@missing xfree, deny key on parse error; ok stevesk@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.13 2001/02/09 13:38:07 markus Exp $");
d20 1
d55 1
d66 1
a104 1
			int i;
a133 1
			int i;
d136 1
d175 1
a175 1
			int i;
d221 52
@


1.13
log
@reset options if no option is given; from han.holl@@prismant.nl
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.12 2001/02/03 10:08:36 markus Exp $");
d121 3
a123 1
				continue;
d153 2
a154 1
				continue;
d191 2
a192 1
				continue;
@


1.12
log
@make ReverseMappingCheck optional in sshd_config; ok djm@@,dugsong@@
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.11 2001/01/21 19:05:41 markus Exp $");
a63 2
	if (!opts)
		return 1;
d67 3
@


1.11
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.10 2001/01/20 15:55:20 markus Exp $");
d21 1
d35 2
d61 1
a61 1
auth_parse_options(struct passwd *pw, char *options, char *file, u_long linenum)
d64 1
a64 1
	if (!options)
d70 1
a70 1
	while (*options && *options != ' ' && *options != '\t') {
d72 1
a72 1
		if (strncasecmp(options, cp, strlen(cp)) == 0) {
d75 1
a75 1
			options += strlen(cp);
d79 1
a79 1
		if (strncasecmp(options, cp, strlen(cp)) == 0) {
d82 1
a82 1
			options += strlen(cp);
d86 1
a86 1
		if (strncasecmp(options, cp, strlen(cp)) == 0) {
d89 1
a89 1
			options += strlen(cp);
d93 1
a93 1
		if (strncasecmp(options, cp, strlen(cp)) == 0) {
d96 1
a96 1
			options += strlen(cp);
d100 1
a100 1
		if (strncasecmp(options, cp, strlen(cp)) == 0) {
d102 2
a103 2
			options += strlen(cp);
			forced_command = xmalloc(strlen(options) + 1);
d105 2
a106 2
			while (*options) {
				if (*options == '"')
d108 2
a109 2
				if (*options == '\\' && options[1] == '"') {
					options += 2;
d113 1
a113 1
				forced_command[i++] = *options++;
d115 1
a115 1
			if (!*options) {
d124 1
a124 1
			options++;
d128 1
a128 1
		if (strncasecmp(options, cp, strlen(cp)) == 0) {
d132 2
a133 2
			options += strlen(cp);
			s = xmalloc(strlen(options) + 1);
d135 2
a136 2
			while (*options) {
				if (*options == '"')
d138 2
a139 2
				if (*options == '\\' && options[1] == '"') {
					options += 2;
d143 1
a143 1
				s[i++] = *options++;
d145 1
a145 1
			if (!*options) {
d155 1
a155 1
			options++;
d163 1
a163 1
		if (strncasecmp(options, cp, strlen(cp)) == 0) {
d165 4
a168 1
			char *patterns = xmalloc(strlen(options) + 1);
d170 1
a170 1
			options += strlen(cp);
d172 2
a173 2
			while (*options) {
				if (*options == '"')
d175 2
a176 2
				if (*options == '\\' && options[1] == '"') {
					options += 2;
d180 1
a180 1
				patterns[i++] = *options++;
d182 1
a182 1
			if (!*options) {
d190 1
a190 1
			options++;
d196 4
a199 4
			mname = match_hostname(get_canonical_hostname(),
			    patterns, strlen(patterns));
			mip = match_hostname(get_remote_ipaddr(),
			    patterns, strlen(patterns));
d203 7
a209 5
				log("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
				    pw->pw_name, get_canonical_hostname(),
				    get_remote_ipaddr());
				packet_send_debug("Your host '%.200s' is not permitted to use this key for login.",
				get_canonical_hostname());
d221 1
a221 1
		if (!*options)
d223 1
a223 1
		if (*options == ' ' || *options == '\t')
d225 1
a225 1
		if (*options != ',')
d227 1
a227 1
		options++;
d235 1
a235 1
	    file, linenum, options);
d237 1
a237 1
	    file, linenum, options);
@


1.10
log
@pass the filename to auth_parse_options()
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.9 2001/01/19 15:55:10 markus Exp $");
a14 1
#include "ssh.h"
d18 3
@


1.9
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.8 2001/01/13 18:38:00 markus Exp $");
a18 1
#include "pathnames.h"
d51 4
a54 1
/* return 1 if access is granted, 0 if not. side effect: sets key option flags */
d56 1
a56 1
auth_parse_options(struct passwd *pw, char *options, u_long linenum)
d112 1
a112 1
				    _PATH_SSH_USER_PERMITTED_KEYS, linenum);
d114 1
a114 1
				    _PATH_SSH_USER_PERMITTED_KEYS, linenum);
d142 1
a142 1
				    _PATH_SSH_USER_PERMITTED_KEYS, linenum);
d144 1
a144 1
				    _PATH_SSH_USER_PERMITTED_KEYS, linenum);
d176 1
a176 1
				    _PATH_SSH_USER_PERMITTED_KEYS, linenum);
d178 1
a178 1
				    _PATH_SSH_USER_PERMITTED_KEYS, linenum);
d225 1
a225 1
	    _PATH_SSH_USER_PERMITTED_KEYS, linenum, options);
d227 1
a227 1
	    _PATH_SSH_USER_PERMITTED_KEYS, linenum, options);
@


1.8
log
@fix comment
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.7 2000/12/19 23:17:54 markus Exp $");
d19 1
d110 1
a110 1
				    SSH_USER_PERMITTED_KEYS, linenum);
d112 1
a112 1
				    SSH_USER_PERMITTED_KEYS, linenum);
d140 1
a140 1
				    SSH_USER_PERMITTED_KEYS, linenum);
d142 1
a142 1
				    SSH_USER_PERMITTED_KEYS, linenum);
d174 1
a174 1
				    SSH_USER_PERMITTED_KEYS, linenum);
d176 1
a176 1
				    SSH_USER_PERMITTED_KEYS, linenum);
d223 1
a223 1
	    SSH_USER_PERMITTED_KEYS, linenum, options);
d225 1
a225 1
	    SSH_USER_PERMITTED_KEYS, linenum, options);
@


1.7
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@a4 4
 * RSA-based authentication.  This code determines whether to admit a login
 * based on RSA authentication.  This file also contains functions to check
 * validity of the host key.
 *
d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.6 2000/11/15 22:31:36 markus Exp $");
@


1.6
log
@case insensitive key options; from stevesk@@sweden.hp.com
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-options.c,v 1.5 2000/10/09 21:32:34 markus Exp $");
d57 1
a57 1
auth_parse_options(struct passwd *pw, char *options, unsigned long linenum)
@


1.5
log
@clear options on every call.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-options.c,v 1.4 2000/09/07 21:13:36 markus Exp $");
d68 1
a68 1
		if (strncmp(options, cp, strlen(cp)) == 0) {
d75 1
a75 1
		if (strncmp(options, cp, strlen(cp)) == 0) {
d82 1
a82 1
		if (strncmp(options, cp, strlen(cp)) == 0) {
d89 1
a89 1
		if (strncmp(options, cp, strlen(cp)) == 0) {
d96 1
a96 1
		if (strncmp(options, cp, strlen(cp)) == 0) {
d124 1
a124 1
		if (strncmp(options, cp, strlen(cp)) == 0) {
d159 1
a159 1
		if (strncmp(options, cp, strlen(cp)) == 0) {
@


1.5.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d5 4
d17 1
a17 1
RCSID("$OpenBSD: auth-options.c,v 1.13 2001/02/09 13:38:07 markus Exp $");
d19 1
a22 4
#include "log.h"
#include "canohost.h"
#include "auth-options.h"
#include "servconf.h"
a35 2
extern ServerOptions options;

d55 1
a55 4
/*
 * return 1 if access is granted, 0 if not.
 * side effect: sets key option flags
 */
d57 1
a57 1
auth_parse_options(struct passwd *pw, char *opts, char *file, u_long linenum)
d60 2
d66 1
a66 4
	if (!opts)
		return 1;

	while (*opts && *opts != ' ' && *opts != '\t') {
d68 1
a68 1
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
d71 1
a71 1
			opts += strlen(cp);
d75 1
a75 1
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
d78 1
a78 1
			opts += strlen(cp);
d82 1
a82 1
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
d85 1
a85 1
			opts += strlen(cp);
d89 1
a89 1
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
d92 1
a92 1
			opts += strlen(cp);
d96 1
a96 1
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
d98 2
a99 2
			opts += strlen(cp);
			forced_command = xmalloc(strlen(opts) + 1);
d101 2
a102 2
			while (*opts) {
				if (*opts == '"')
d104 2
a105 2
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
d109 1
a109 1
				forced_command[i++] = *opts++;
d111 1
a111 1
			if (!*opts) {
d113 1
a113 1
				    file, linenum);
d115 1
a115 1
				    file, linenum);
d120 1
a120 1
			opts++;
d124 1
a124 1
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
d128 2
a129 2
			opts += strlen(cp);
			s = xmalloc(strlen(opts) + 1);
d131 2
a132 2
			while (*opts) {
				if (*opts == '"')
d134 2
a135 2
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
d139 1
a139 1
				s[i++] = *opts++;
d141 1
a141 1
			if (!*opts) {
d143 1
a143 1
				    file, linenum);
d145 1
a145 1
				    file, linenum);
d151 1
a151 1
			opts++;
d159 1
a159 1
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
d161 1
a161 4
			const char *remote_ip = get_remote_ipaddr();
			const char *remote_host = get_canonical_hostname(
			    options.reverse_mapping_check);
			char *patterns = xmalloc(strlen(opts) + 1);
d163 1
a163 1
			opts += strlen(cp);
d165 2
a166 2
			while (*opts) {
				if (*opts == '"')
d168 2
a169 2
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
d173 1
a173 1
				patterns[i++] = *opts++;
d175 1
a175 1
			if (!*opts) {
d177 1
a177 1
				    file, linenum);
d179 1
a179 1
				    file, linenum);
d183 1
a183 1
			opts++;
d189 4
a192 4
			mname = match_hostname(remote_host, patterns,
			    strlen(patterns));
			mip = match_hostname(remote_ip, patterns,
			    strlen(patterns));
d196 5
a200 7
				log("Authentication tried for %.100s with "
				    "correct key but not from a permitted "
				    "host (host=%.200s, ip=%.200s).",
				    pw->pw_name, remote_host, remote_ip);
				packet_send_debug("Your host '%.200s' is not "
				    "permitted to use this key for login.",
				    remote_host);
d212 1
a212 1
		if (!*opts)
d214 1
a214 1
		if (*opts == ' ' || *opts == '\t')
d216 1
a216 1
		if (*opts != ',')
d218 1
a218 1
		opts++;
d226 1
a226 1
	    file, linenum, opts);
d228 1
a228 1
	    file, linenum, opts);
@


1.5.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.5.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.16 2001/03/18 12:07:52 markus Exp $");
a19 1
#include "channels.h"
a53 1
	channel_clear_permitted_opens();
a63 1
	int i;
d102 1
d121 1
a121 3
				xfree(forced_command);
				forced_command = NULL;
				goto bad_option;
d130 1
a132 1

d151 1
a151 2
				xfree(s);
				goto bad_option;
d170 1
a170 1

d188 1
a188 2
				xfree(patterns);
				goto bad_option;
a214 53
			goto next_option;
		}
		cp = "permitopen=\"";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			u_short port;
			char *c, *ep;
			char *patterns = xmalloc(strlen(opts) + 1);

			opts += strlen(cp);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
					patterns[i++] = '"';
					continue;
				}
				patterns[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				packet_send_debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				xfree(patterns);
				goto bad_option;
			}
			patterns[i] = 0;
			opts++;
			c = strchr(patterns, ':');
			if (c == NULL) {
				debug("%.100s, line %lu: permitopen: missing colon <%.100s>",
				    file, linenum, patterns);
				packet_send_debug("%.100s, line %lu: missing colon",
				    file, linenum);
				xfree(patterns);
				goto bad_option;
			}
			*c = 0;
			c++;
			port = strtol(c, &ep, 0);
			if (c == ep) {
				debug("%.100s, line %lu: permitopen: missing port <%.100s>",
				    file, linenum, patterns);
				packet_send_debug("%.100s, line %lu: missing port",
				    file, linenum);
				xfree(patterns);
				goto bad_option;
			}
			if (options.allow_tcp_forwarding)
				channel_add_permitted_opens(patterns, port);
			xfree(patterns);
@


1.5.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.5.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.20 2001/08/30 20:36:34 stevesk Exp $");
a22 1
#include "misc.h"
d170 1
d198 12
a209 3
			if (match_host_and_ip(remote_host, remote_ip,
			    patterns) != 1) {
				xfree(patterns);
a219 1
			xfree(patterns);
a224 1
			char host[256], sport[6];
d226 1
d251 6
a256 6
			if (sscanf(patterns, "%255[^:]:%5[0-9]", host, sport) != 2 &&
			    sscanf(patterns, "%255[^/]/%5[0-9]", host, sport) != 2) {
				debug("%.100s, line %lu: Bad permitopen specification "
				    "<%.100s>", file, linenum, patterns);
				packet_send_debug("%.100s, line %lu: "
				    "Bad permitopen specification", file, linenum);
d260 8
a267 5
			if ((port = a2port(sport)) == 0) {
				debug("%.100s, line %lu: Bad permitopen port <%.100s>",
				    file, linenum, sport);
				packet_send_debug("%.100s, line %lu: "
				    "Bad permitopen port", file, linenum);
d272 1
a272 1
				channel_add_permitted_opens(host, port);
@


1.5.2.6
log
@Merge OpenSSH 3.1.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.21 2002/01/29 14:32:03 markus Exp $");
d173 1
a173 1
			    options.verify_reverse_mapping);
@


1.4
log
@some more Copyright fixes
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-options.c,v 1.3 2000/09/07 20:27:49 deraadt Exp $");
d36 19
d62 4
d113 1
a113 1
				      SSH_USER_PERMITTED_KEYS, linenum);
d115 1
a115 1
						  SSH_USER_PERMITTED_KEYS, linenum);
d143 1
a143 1
				      SSH_USER_PERMITTED_KEYS, linenum);
d145 1
a145 1
						  SSH_USER_PERMITTED_KEYS, linenum);
a200 15
				/* key invalid for this host, reset flags */
				no_agent_forwarding_flag = 0;
				no_port_forwarding_flag = 0;
				no_pty_flag = 0;
				no_x11_forwarding_flag = 0;
				while (custom_environment) {
					struct envstring *ce = custom_environment;
					custom_environment = ce->next;
					xfree(ce->s);
					xfree(ce);
				}
				if (forced_command) {
					xfree(forced_command);
					forced_command = NULL;
				}
@


1.3
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@a13 23
 *
 *
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d17 1
a17 1
RCSID("$OpenBSD: auth-options.c,v 1.2 2000/06/20 01:39:38 markus Exp $");
@


1.2
log
@OpenBSD tag
@
text
@d1 38
d40 1
a40 1
RCSID("$OpenBSD: auth-options.c,v 1.1 2000/06/18 04:05:01 markus Exp $");
@


1.2.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d2 1
a2 1
RCSID("$OpenBSD: auth-options.c,v 1.2 2000/06/20 01:39:38 markus Exp $");
@


1.2.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@a0 15
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * RSA-based authentication.  This code determines whether to admit a login
 * based on RSA authentication.  This file also contains functions to check
 * validity of the host key.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

d2 1
a2 1
RCSID("$OpenBSD: auth-options.c,v 1.5 2000/10/09 21:32:34 markus Exp $");
a20 19
void
auth_clear_options(void)
{
	no_agent_forwarding_flag = 0;
	no_port_forwarding_flag = 0;
	no_pty_flag = 0;
	no_x11_forwarding_flag = 0;
	while (custom_environment) {
		struct envstring *ce = custom_environment;
		custom_environment = ce->next;
		xfree(ce->s);
		xfree(ce);
	}
	if (forced_command) {
		xfree(forced_command);
		forced_command = NULL;
	}
}

a27 4

	/* reset options */
	auth_clear_options();

d75 1
a75 1
				    SSH_USER_PERMITTED_KEYS, linenum);
d77 1
a77 1
				    SSH_USER_PERMITTED_KEYS, linenum);
d105 1
a105 1
				    SSH_USER_PERMITTED_KEYS, linenum);
d107 1
a107 1
				    SSH_USER_PERMITTED_KEYS, linenum);
d163 15
@


1.2.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d5 4
d17 1
a17 1
RCSID("$OpenBSD: auth-options.c,v 1.13 2001/02/09 13:38:07 markus Exp $");
d19 1
a22 4
#include "log.h"
#include "canohost.h"
#include "auth-options.h"
#include "servconf.h"
a35 2
extern ServerOptions options;

d55 1
a55 4
/*
 * return 1 if access is granted, 0 if not.
 * side effect: sets key option flags
 */
d57 1
a57 1
auth_parse_options(struct passwd *pw, char *opts, char *file, u_long linenum)
d60 2
d66 1
a66 4
	if (!opts)
		return 1;

	while (*opts && *opts != ' ' && *opts != '\t') {
d68 1
a68 1
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
d71 1
a71 1
			opts += strlen(cp);
d75 1
a75 1
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
d78 1
a78 1
			opts += strlen(cp);
d82 1
a82 1
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
d85 1
a85 1
			opts += strlen(cp);
d89 1
a89 1
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
d92 1
a92 1
			opts += strlen(cp);
d96 1
a96 1
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
d98 2
a99 2
			opts += strlen(cp);
			forced_command = xmalloc(strlen(opts) + 1);
d101 2
a102 2
			while (*opts) {
				if (*opts == '"')
d104 2
a105 2
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
d109 1
a109 1
				forced_command[i++] = *opts++;
d111 1
a111 1
			if (!*opts) {
d113 1
a113 1
				    file, linenum);
d115 1
a115 1
				    file, linenum);
d120 1
a120 1
			opts++;
d124 1
a124 1
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
d128 2
a129 2
			opts += strlen(cp);
			s = xmalloc(strlen(opts) + 1);
d131 2
a132 2
			while (*opts) {
				if (*opts == '"')
d134 2
a135 2
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
d139 1
a139 1
				s[i++] = *opts++;
d141 1
a141 1
			if (!*opts) {
d143 1
a143 1
				    file, linenum);
d145 1
a145 1
				    file, linenum);
d151 1
a151 1
			opts++;
d159 1
a159 1
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
d161 1
a161 4
			const char *remote_ip = get_remote_ipaddr();
			const char *remote_host = get_canonical_hostname(
			    options.reverse_mapping_check);
			char *patterns = xmalloc(strlen(opts) + 1);
d163 1
a163 1
			opts += strlen(cp);
d165 2
a166 2
			while (*opts) {
				if (*opts == '"')
d168 2
a169 2
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
d173 1
a173 1
				patterns[i++] = *opts++;
d175 1
a175 1
			if (!*opts) {
d177 1
a177 1
				    file, linenum);
d179 1
a179 1
				    file, linenum);
d183 1
a183 1
			opts++;
d189 4
a192 4
			mname = match_hostname(remote_host, patterns,
			    strlen(patterns));
			mip = match_hostname(remote_ip, patterns,
			    strlen(patterns));
d196 5
a200 7
				log("Authentication tried for %.100s with "
				    "correct key but not from a permitted "
				    "host (host=%.200s, ip=%.200s).",
				    pw->pw_name, remote_host, remote_ip);
				packet_send_debug("Your host '%.200s' is not "
				    "permitted to use this key for login.",
				    remote_host);
d212 1
a212 1
		if (!*opts)
d214 1
a214 1
		if (*opts == ' ' || *opts == '\t')
d216 1
a216 1
		if (*opts != ',')
d218 1
a218 1
		opts++;
d226 1
a226 1
	    file, linenum, opts);
d228 1
a228 1
	    file, linenum, opts);
@


1.2.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.16 2001/03/18 12:07:52 markus Exp $");
a19 1
#include "channels.h"
a53 1
	channel_clear_permitted_opens();
a63 1
	int i;
d102 1
d121 1
a121 3
				xfree(forced_command);
				forced_command = NULL;
				goto bad_option;
d130 1
a132 1

d151 1
a151 2
				xfree(s);
				goto bad_option;
d170 1
a170 1

d188 1
a188 2
				xfree(patterns);
				goto bad_option;
a214 53
			goto next_option;
		}
		cp = "permitopen=\"";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			u_short port;
			char *c, *ep;
			char *patterns = xmalloc(strlen(opts) + 1);

			opts += strlen(cp);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
					patterns[i++] = '"';
					continue;
				}
				patterns[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				packet_send_debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				xfree(patterns);
				goto bad_option;
			}
			patterns[i] = 0;
			opts++;
			c = strchr(patterns, ':');
			if (c == NULL) {
				debug("%.100s, line %lu: permitopen: missing colon <%.100s>",
				    file, linenum, patterns);
				packet_send_debug("%.100s, line %lu: missing colon",
				    file, linenum);
				xfree(patterns);
				goto bad_option;
			}
			*c = 0;
			c++;
			port = strtol(c, &ep, 0);
			if (c == ep) {
				debug("%.100s, line %lu: permitopen: missing port <%.100s>",
				    file, linenum, patterns);
				packet_send_debug("%.100s, line %lu: missing port",
				    file, linenum);
				xfree(patterns);
				goto bad_option;
			}
			if (options.allow_tcp_forwarding)
				channel_add_permitted_opens(patterns, port);
			xfree(patterns);
@


1.1
log
@split auth-rsa option parsing into auth-options
add options support to authorized_keys2
@
text
@d2 1
a2 1
RCSID("$Id: auth-rsa.c,v 1.24 2000/06/06 19:32:13 markus Exp $");
@

