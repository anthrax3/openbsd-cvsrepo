head	1.291;
access;
symbols
	OPENBSD_6_1_BASE:1.291
	OPENBSD_6_0:1.286.0.4
	OPENBSD_6_0_BASE:1.286
	OPENBSD_5_9:1.284.0.2
	OPENBSD_5_9_BASE:1.284
	OPENBSD_5_8:1.275.0.2
	OPENBSD_5_8_BASE:1.275
	OPENBSD_5_7:1.272.0.2
	OPENBSD_5_7_BASE:1.272
	OPENBSD_5_6:1.261.0.4
	OPENBSD_5_6_BASE:1.261
	OPENBSD_5_5:1.258.0.4
	OPENBSD_5_5_BASE:1.258
	OPENBSD_5_4:1.253.0.2
	OPENBSD_5_4_BASE:1.253
	OPENBSD_5_3:1.248.0.2
	OPENBSD_5_3_BASE:1.248
	OPENBSD_5_2:1.240.0.2
	OPENBSD_5_2_BASE:1.240
	OPENBSD_5_1_BASE:1.238
	OPENBSD_5_1:1.238.0.2
	OPENBSD_5_0:1.236.0.2
	OPENBSD_5_0_BASE:1.236
	OPENBSD_4_9:1.231.0.2
	OPENBSD_4_9_BASE:1.231
	OPENBSD_4_8:1.222.0.2
	OPENBSD_4_8_BASE:1.222
	OPENBSD_4_7:1.219.0.2
	OPENBSD_4_7_BASE:1.219
	OPENBSD_4_6:1.213.0.2
	OPENBSD_4_6_BASE:1.213
	OPENBSD_4_5:1.209.0.2
	OPENBSD_4_5_BASE:1.209
	OPENBSD_4_4:1.201.0.2
	OPENBSD_4_4_BASE:1.201
	OPENBSD_4_3:1.188.0.2
	OPENBSD_4_3_BASE:1.188
	OPENBSD_4_2:1.181.0.2
	OPENBSD_4_2_BASE:1.181
	OPENBSD_4_1:1.178.0.2
	OPENBSD_4_1_BASE:1.178
	OPENBSD_4_0:1.175.0.4
	OPENBSD_4_0_BASE:1.175
	OPENBSD_3_9:1.155.0.2
	OPENBSD_3_9_BASE:1.155
	OPENBSD_3_8:1.141.0.2
	OPENBSD_3_8_BASE:1.141
	OPENBSD_3_7:1.136.0.2
	OPENBSD_3_7_BASE:1.136
	OPENBSD_3_6:1.131.0.2
	OPENBSD_3_6_BASE:1.131
	OPENBSD_3_5:1.117.0.2
	OPENBSD_3_5_BASE:1.117
	OPENBSD_3_4:1.112.0.2
	OPENBSD_3_4_BASE:1.112
	OPENBSD_3_3:1.105.0.2
	OPENBSD_3_3_BASE:1.105
	OPENBSD_3_2:1.104.0.2
	OPENBSD_3_2_BASE:1.104
	OPENBSD_3_1:1.99.0.2
	OPENBSD_3_1_BASE:1.99
	OPENBSD_3_0:1.84.0.2
	OPENBSD_3_0_BASE:1.84
	OPENBSD_2_9_BASE:1.65
	OPENBSD_2_9:1.65.0.2
	OPENBSD_2_8:1.39.0.2
	OPENBSD_2_8_BASE:1.39
	OPENBSD_2_7:1.26.0.2
	OPENBSD_2_7_BASE:1.26
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7;
locks; strict;
comment	@ * @;


1.291
date	2017.03.10.05.01.13;	author djm;	state Exp;
branches;
next	1.290;
commitid	HluTvf214lFtBKk0;

1.290
date	2017.01.29.21.35.23;	author dtucker;	state Exp;
branches;
next	1.289;
commitid	jOiA0BnLXSo7YePd;

1.289
date	2016.09.30.09.19.13;	author markus;	state Exp;
branches;
next	1.288;
commitid	VHQRRel9yTEUINVH;

1.288
date	2016.09.17.18.00.27;	author tedu;	state Exp;
branches;
next	1.287;
commitid	1NFGN0hoIUPAnf1P;

1.287
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.286;
commitid	ZllbGwdb0fOmLhjK;

1.286
date	2016.07.23.02.54.08;	author djm;	state Exp;
branches;
next	1.285;
commitid	8x14tvYtsN3PMRNm;

1.285
date	2016.07.11.21.38.13;	author tb;	state Exp;
branches;
next	1.284;
commitid	OCRDwkjeqabm8pRV;

1.284
date	2016.02.08.10.57.07;	author djm;	state Exp;
branches;
next	1.283;
commitid	eSwtzi7BWC7eBzrp;

1.283
date	2016.02.01.21.18.17;	author millert;	state Exp;
branches;
next	1.282;
commitid	QkEtPCvzzz0PPNae;

1.282
date	2016.01.29.23.04.46;	author dtucker;	state Exp;
branches;
next	1.281;
commitid	QcD6pxiWpWjN3TWa;

1.281
date	2016.01.23.05.31.35;	author jsg;	state Exp;
branches;
next	1.280;
commitid	nJG2BD545C0FjL5p;

1.280
date	2016.01.14.16.17.39;	author markus;	state Exp;
branches;
next	1.279;
commitid	W9ye0gltieEl87AJ;

1.279
date	2016.01.13.23.04.47;	author djm;	state Exp;
branches;
next	1.278;
commitid	ALMWb9LK721aNRnl;

1.278
date	2015.12.26.07.46.03;	author semarie;	state Exp;
branches;
next	1.277;
commitid	9bx9feiyf0CCkRyA;

1.277
date	2015.12.03.17.00.18;	author semarie;	state Exp;
branches;
next	1.276;
commitid	m8AGU3kOgtFV5kYk;

1.276
date	2015.10.20.03.36.35;	author mmcc;	state Exp;
branches;
next	1.275;
commitid	Dx6qbkUsVjwNhPjo;

1.275
date	2015.07.10.06.21.53;	author markus;	state Exp;
branches
	1.275.2.1;
next	1.274;
commitid	iQTtbsbSVdO9zivU;

1.274
date	2015.07.01.02.26.31;	author djm;	state Exp;
branches;
next	1.273;
commitid	qLSneKZZQQvEyM5i;

1.273
date	2015.05.04.06.10.48;	author djm;	state Exp;
branches;
next	1.272;
commitid	KfZDG8r2EByk0YBR;

1.272
date	2015.02.25.19.54.02;	author djm;	state Exp;
branches
	1.272.2.1;
next	1.271;
commitid	09CiNSceWKHiA07I;

1.271
date	2015.02.23.16.33.25;	author djm;	state Exp;
branches;
next	1.270;
commitid	ZFxLp12OXp0caW03;

1.270
date	2015.02.20.22.17.21;	author djm;	state Exp;
branches;
next	1.269;
commitid	9L88tCQWzQkTa0uX;

1.269
date	2015.02.16.22.13.32;	author djm;	state Exp;
branches;
next	1.268;
commitid	vWL0dluw4oITNbM8;

1.268
date	2015.02.16.22.08.57;	author djm;	state Exp;
branches;
next	1.267;
commitid	iBG3mh48h4UsmNe0;

1.267
date	2015.01.26.03.04.45;	author djm;	state Exp;
branches;
next	1.266;
commitid	Xp9DfQmHQHbZ815k;

1.266
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.265;
commitid	cBx23BaCk6gYBpRj;

1.265
date	2015.01.19.20.16.15;	author markus;	state Exp;
branches;
next	1.264;
commitid	U9l75XYAjMKaQ8Jp;

1.264
date	2015.01.19.20.07.45;	author markus;	state Exp;
branches;
next	1.263;
commitid	GrtSC5ve2VERgUln;

1.263
date	2015.01.19.19.52.16;	author markus;	state Exp;
branches;
next	1.262;
commitid	UHlhoIB5NMb8eAPm;

1.262
date	2015.01.14.20.05.27;	author djm;	state Exp;
branches;
next	1.261;
commitid	YqNUZu0ifI7Q95nk;

1.261
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.260;
commitid	z7plx8Gkj6l2sxem;

1.260
date	2014.06.27.16.41.56;	author markus;	state Exp;
branches;
next	1.259;
commitid	npS0wYoZKjQDRx0P;

1.259
date	2014.04.29.13.10.30;	author djm;	state Exp;
branches;
next	1.258;

1.258
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.257;

1.257
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.256;

1.256
date	2013.11.20.20.54.10;	author deraadt;	state Exp;
branches;
next	1.255;

1.255
date	2013.11.08.00.39.15;	author djm;	state Exp;
branches;
next	1.254;

1.254
date	2013.09.12.01.41.12;	author djm;	state Exp;
branches;
next	1.253;

1.253
date	2013.06.07.15.37.52;	author dtucker;	state Exp;
branches
	1.253.2.1;
next	1.252;

1.252
date	2013.06.02.23.36.29;	author dtucker;	state Exp;
branches;
next	1.251;

1.251
date	2013.06.01.13.15.51;	author dtucker;	state Exp;
branches;
next	1.250;

1.250
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.249;

1.249
date	2013.05.16.02.00.34;	author dtucker;	state Exp;
branches;
next	1.248;

1.248
date	2013.01.02.00.32.07;	author djm;	state Exp;
branches
	1.248.2.1;
next	1.247;

1.247
date	2012.09.07.06.34.21;	author dtucker;	state Exp;
branches;
next	1.246;

1.246
date	2012.09.07.01.10.21;	author dtucker;	state Exp;
branches;
next	1.245;

1.245
date	2012.09.07.00.30.19;	author dtucker;	state Exp;
branches;
next	1.244;

1.244
date	2012.09.06.09.50.13;	author dtucker;	state Exp;
branches;
next	1.243;

1.243
date	2012.09.06.06.25.41;	author dtucker;	state Exp;
branches;
next	1.242;

1.242
date	2012.09.06.04.37.38;	author dtucker;	state Exp;
branches;
next	1.241;

1.241
date	2012.08.17.00.45.45;	author dtucker;	state Exp;
branches;
next	1.240;

1.240
date	2012.06.20.04.42.58;	author djm;	state Exp;
branches;
next	1.239;

1.239
date	2012.04.11.13.16.19;	author djm;	state Exp;
branches;
next	1.238;

1.238
date	2012.01.18.21.46.43;	author dtucker;	state Exp;
branches;
next	1.237;

1.237
date	2011.09.10.22.26.34;	author markus;	state Exp;
branches;
next	1.236;

1.236
date	2011.06.22.22.08.42;	author djm;	state Exp;
branches;
next	1.235;

1.235
date	2011.06.17.21.57.25;	author djm;	state Exp;
branches;
next	1.234;

1.234
date	2011.05.08.12.52.01;	author djm;	state Exp;
branches;
next	1.233;

1.233
date	2011.05.06.21.34.32;	author djm;	state Exp;
branches;
next	1.232;

1.232
date	2011.04.17.22.42.41;	author djm;	state Exp;
branches;
next	1.231;

1.231
date	2011.01.16.12.05.59;	author djm;	state Exp;
branches;
next	1.230;

1.230
date	2011.01.16.11.50.05;	author djm;	state Exp;
branches;
next	1.229;

1.229
date	2011.01.11.06.13.10;	author djm;	state Exp;
branches;
next	1.228;

1.228
date	2011.01.08.10.51.51;	author djm;	state Exp;
branches;
next	1.227;

1.227
date	2011.01.06.22.23.02;	author djm;	state Exp;
branches;
next	1.226;

1.226
date	2010.11.23.23.57.24;	author djm;	state Exp;
branches;
next	1.225;

1.225
date	2010.11.21.01.01.13;	author djm;	state Exp;
branches;
next	1.224;

1.224
date	2010.11.13.23.27.50;	author djm;	state Exp;
branches;
next	1.223;

1.223
date	2010.10.06.06.39.28;	author djm;	state Exp;
branches;
next	1.222;

1.222
date	2010.07.19.09.15.12;	author djm;	state Exp;
branches;
next	1.221;

1.221
date	2010.06.25.23.15.36;	author djm;	state Exp;
branches;
next	1.220;

1.220
date	2010.04.10.02.08.44;	author djm;	state Exp;
branches;
next	1.219;

1.219
date	2010.03.13.21.10.38;	author djm;	state Exp;
branches;
next	1.218;

1.218
date	2010.01.28.00.21.18;	author djm;	state Exp;
branches;
next	1.217;

1.217
date	2010.01.26.01.28.35;	author djm;	state Exp;
branches;
next	1.216;

1.216
date	2010.01.09.05.04.24;	author djm;	state Exp;
branches;
next	1.215;

1.215
date	2009.11.17.05.31.44;	author djm;	state Exp;
branches;
next	1.214;

1.214
date	2009.10.24.11.15.29;	author andreas;	state Exp;
branches;
next	1.213;

1.213
date	2009.07.05.19.28.33;	author stevesk;	state Exp;
branches;
next	1.212;

1.212
date	2009.05.28.16.50.16;	author andreas;	state Exp;
branches;
next	1.211;

1.211
date	2009.05.27.06.33.39;	author andreas;	state Exp;
branches;
next	1.210;

1.210
date	2009.05.25.06.48.01;	author andreas;	state Exp;
branches;
next	1.209;

1.209
date	2009.02.12.03.00.56;	author djm;	state Exp;
branches;
next	1.208;

1.208
date	2009.01.22.10.02.34;	author djm;	state Exp;
branches;
next	1.207;

1.207
date	2008.12.09.22.37.33;	author stevesk;	state Exp;
branches;
next	1.206;

1.206
date	2008.12.09.02.38.18;	author djm;	state Exp;
branches;
next	1.205;

1.205
date	2008.12.02.19.01.07;	author markus;	state Exp;
branches;
next	1.204;

1.204
date	2008.11.05.03.23.09;	author stevesk;	state Exp;
branches;
next	1.203;

1.203
date	2008.11.01.17.40.33;	author stevesk;	state Exp;
branches;
next	1.202;

1.202
date	2008.10.30.19.31.16;	author stevesk;	state Exp;
branches;
next	1.201;

1.201
date	2008.07.16.11.51.14;	author djm;	state Exp;
branches;
next	1.200;

1.200
date	2008.07.10.18.08.11;	author markus;	state Exp;
branches;
next	1.199;

1.199
date	2008.06.12.21.06.25;	author djm;	state Exp;
branches;
next	1.198;

1.198
date	2008.06.12.15.19.17;	author djm;	state Exp;
branches;
next	1.197;

1.197
date	2008.06.12.04.17.47;	author djm;	state Exp;
branches;
next	1.196;

1.196
date	2008.06.12.04.06.00;	author djm;	state Exp;
branches;
next	1.195;

1.195
date	2008.06.12.03.40.52;	author djm;	state Exp;
branches;
next	1.194;

1.194
date	2008.05.19.20.53.52;	author djm;	state Exp;
branches;
next	1.193;

1.193
date	2008.05.09.16.21.13;	author markus;	state Exp;
branches;
next	1.192;

1.192
date	2008.05.09.14.18.44;	author djm;	state Exp;
branches;
next	1.191;

1.191
date	2008.05.09.04.55.56;	author djm;	state Exp;
branches;
next	1.190;

1.190
date	2008.05.08.13.06.10;	author djm;	state Exp;
branches;
next	1.189;

1.189
date	2008.05.08.12.02.23;	author djm;	state Exp;
branches;
next	1.188;

1.188
date	2008.02.22.20.44.02;	author dtucker;	state Exp;
branches;
next	1.187;

1.187
date	2008.01.23.01.56.54;	author dtucker;	state Exp;
branches;
next	1.186;

1.186
date	2008.01.19.20.48.53;	author djm;	state Exp;
branches;
next	1.185;

1.185
date	2007.12.28.22.34.47;	author dtucker;	state Exp;
branches;
next	1.184;

1.184
date	2007.12.28.15.32.24;	author dtucker;	state Exp;
branches;
next	1.183;

1.183
date	2007.11.03.00.36.14;	author djm;	state Exp;
branches;
next	1.182;

1.182
date	2007.09.04.03.21.03;	author djm;	state Exp;
branches;
next	1.181;

1.181
date	2007.08.15.08.14.46;	author markus;	state Exp;
branches;
next	1.180;

1.180
date	2007.08.07.07.32.53;	author djm;	state Exp;
branches;
next	1.179;

1.179
date	2007.03.20.03.56.12;	author tedu;	state Exp;
branches;
next	1.178;

1.178
date	2007.02.20.10.25.14;	author djm;	state Exp;
branches;
next	1.177;

1.177
date	2007.01.21.01.41.54;	author stevesk;	state Exp;
branches;
next	1.176;

1.176
date	2006.10.11.12.38.03;	author markus;	state Exp;
branches;
next	1.175;

1.175
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.175.4.1;
next	1.174;

1.174
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.173;

1.173
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.172;

1.172
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.171;

1.171
date	2006.07.25.02.59.21;	author stevesk;	state Exp;
branches;
next	1.170;

1.170
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.169;

1.169
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.168;

1.168
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.167;

1.167
date	2006.07.11.18.50.47;	author markus;	state Exp;
branches;
next	1.166;

1.166
date	2006.07.08.21.47.12;	author stevesk;	state Exp;
branches;
next	1.165;

1.165
date	2006.07.02.23.01.55;	author stevesk;	state Exp;
branches;
next	1.164;

1.164
date	2006.06.26.10.36.15;	author djm;	state Exp;
branches;
next	1.163;

1.163
date	2006.05.16.09.00.00;	author markus;	state Exp;
branches;
next	1.162;

1.162
date	2006.04.20.09.27.09;	author djm;	state Exp;
branches;
next	1.161;

1.161
date	2006.03.25.18.30.55;	author deraadt;	state Exp;
branches;
next	1.160;

1.160
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.159;

1.159
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.158;

1.158
date	2006.03.20.18.14.02;	author deraadt;	state Exp;
branches;
next	1.157;

1.157
date	2006.03.19.18.56.41;	author deraadt;	state Exp;
branches;
next	1.156;

1.156
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.155;

1.155
date	2006.02.22.00.04.44;	author stevesk;	state Exp;
branches
	1.155.2.1;
next	1.154;

1.154
date	2006.02.20.17.19.54;	author stevesk;	state Exp;
branches;
next	1.153;

1.153
date	2006.02.20.17.02.44;	author stevesk;	state Exp;
branches;
next	1.152;

1.152
date	2006.02.10.00.27.13;	author stevesk;	state Exp;
branches;
next	1.151;

1.151
date	2006.02.08.12.15.27;	author stevesk;	state Exp;
branches;
next	1.150;

1.150
date	2006.02.07.01.42.00;	author stevesk;	state Exp;
branches;
next	1.149;

1.149
date	2005.12.30.15.56.37;	author reyk;	state Exp;
branches;
next	1.148;

1.148
date	2005.12.28.22.46.06;	author stevesk;	state Exp;
branches;
next	1.147;

1.147
date	2005.12.07.03.52.22;	author djm;	state Exp;
branches;
next	1.146;

1.146
date	2005.12.06.22.38.27;	author reyk;	state Exp;
branches;
next	1.145;

1.145
date	2005.10.30.08.52.17;	author djm;	state Exp;
branches;
next	1.144;

1.144
date	2005.10.14.02.29.37;	author stevesk;	state Exp;
branches;
next	1.143;

1.143
date	2005.10.10.10.23.08;	author djm;	state Exp;
branches;
next	1.142;

1.142
date	2005.09.09.19.18.05;	author markus;	state Exp;
branches;
next	1.141;

1.141
date	2005.07.16.01.35.24;	author djm;	state Exp;
branches
	1.141.2.1;
next	1.140;

1.140
date	2005.07.04.00.58.43;	author djm;	state Exp;
branches;
next	1.139;

1.139
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches;
next	1.138;

1.138
date	2005.06.16.03.38.36;	author djm;	state Exp;
branches;
next	1.137;

1.137
date	2005.06.08.11.25.09;	author djm;	state Exp;
branches;
next	1.136;

1.136
date	2005.03.10.22.01.05;	author deraadt;	state Exp;
branches
	1.136.2.1;
next	1.135;

1.135
date	2005.03.01.10.09.52;	author djm;	state Exp;
branches;
next	1.134;

1.134
date	2004.11.07.00.01.46;	author djm;	state Exp;
branches;
next	1.133;

1.133
date	2004.10.29.22.53.56;	author djm;	state Exp;
branches;
next	1.132;

1.132
date	2004.10.29.21.47.15;	author djm;	state Exp;
branches;
next	1.131;

1.131
date	2004.09.07.23.41.30;	author djm;	state Exp;
branches
	1.131.2.1;
next	1.130;

1.130
date	2004.08.11.21.43.04;	author avsm;	state Exp;
branches;
next	1.129;

1.129
date	2004.07.11.17.48.47;	author deraadt;	state Exp;
branches;
next	1.128;

1.128
date	2004.06.18.11.11.54;	author djm;	state Exp;
branches;
next	1.127;

1.127
date	2004.06.17.15.10.13;	author djm;	state Exp;
branches;
next	1.126;

1.126
date	2004.06.17.14.52.48;	author djm;	state Exp;
branches;
next	1.125;

1.125
date	2004.06.15.05.45.04;	author djm;	state Exp;
branches;
next	1.124;

1.124
date	2004.06.14.01.44.38;	author djm;	state Exp;
branches;
next	1.123;

1.123
date	2004.06.13.15.03.02;	author djm;	state Exp;
branches;
next	1.122;

1.122
date	2004.05.22.06.32.12;	author djm;	state Exp;
branches;
next	1.121;

1.121
date	2004.05.21.11.33.11;	author djm;	state Exp;
branches;
next	1.120;

1.120
date	2004.05.20.10.58.05;	author dtucker;	state Exp;
branches;
next	1.119;

1.119
date	2004.05.08.00.21.31;	author djm;	state Exp;
branches;
next	1.118;

1.118
date	2004.05.08.00.01.37;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2003.12.16.15.49.51;	author markus;	state Exp;
branches
	1.117.2.1;
next	1.116;

1.116
date	2003.12.09.23.45.32;	author dtucker;	state Exp;
branches;
next	1.115;

1.115
date	2003.09.23.20.41.11;	author markus;	state Exp;
branches;
next	1.114;

1.114
date	2003.09.23.20.17.11;	author markus;	state Exp;
branches;
next	1.113;

1.113
date	2003.09.19.17.43.35;	author markus;	state Exp;
branches;
next	1.112;

1.112
date	2003.06.28.16.23.06;	author deraadt;	state Exp;
branches
	1.112.2.1;
next	1.111;

1.111
date	2003.05.14.22.24.42;	author markus;	state Exp;
branches;
next	1.110;

1.110
date	2003.05.11.20.30.24;	author markus;	state Exp;
branches;
next	1.109;

1.109
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches;
next	1.108;

1.108
date	2003.04.02.09.48.07;	author markus;	state Exp;
branches;
next	1.107;

1.107
date	2003.04.01.10.22.21;	author markus;	state Exp;
branches;
next	1.106;

1.106
date	2003.04.01.10.10.23;	author markus;	state Exp;
branches;
next	1.105;

1.105
date	2002.11.18.16.43.44;	author markus;	state Exp;
branches
	1.105.2.1;
next	1.104;

1.104
date	2002.08.22.19.38.42;	author stevesk;	state Exp;
branches
	1.104.2.1;
next	1.103;

1.103
date	2002.06.30.21.59.45;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2002.06.24.14.33.27;	author markus;	state Exp;
branches;
next	1.101;

1.101
date	2002.06.09.13.32.01;	author markus;	state Exp;
branches;
next	1.100;

1.100
date	2002.04.22.21.04.52;	author markus;	state Exp;
branches;
next	1.99;

1.99
date	2002.03.21.23.07.37;	author markus;	state Exp;
branches
	1.99.2.1;
next	1.98;

1.98
date	2002.03.21.16.58.13;	author markus;	state Exp;
branches;
next	1.97;

1.97
date	2002.03.21.15.17.26;	author jakob;	state Exp;
branches;
next	1.96;

1.96
date	2002.02.06.14.55.15;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2002.01.10.11.24.04;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2001.12.28.15.06.00;	author markus;	state Exp;
branches;
next	1.93;

1.93
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.92;

1.92
date	2001.12.27.20.39.58;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2001.12.20.22.50.24;	author djm;	state Exp;
branches;
next	1.90;

1.90
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2001.12.05.03.50.01;	author itojun;	state Exp;
branches;
next	1.88;

1.88
date	2001.11.22.12.34.22;	author markus;	state Exp;
branches;
next	1.87;

1.87
date	2001.11.09.18.59.23;	author markus;	state Exp;
branches;
next	1.86;

1.86
date	2001.10.24.19.57.40;	author markus;	state Exp;
branches;
next	1.85;

1.85
date	2001.10.24.08.51.35;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2001.10.11.15.24.00;	author markus;	state Exp;
branches
	1.84.2.1;
next	1.83;

1.83
date	2001.10.10.22.18.47;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2001.09.17.20.52.47;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2001.07.17.21.04.57;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2001.06.30.18.08.40;	author stevesk;	state Exp;
branches;
next	1.79;

1.79
date	2001.06.29.18.38.44;	author stevesk;	state Exp;
branches;
next	1.78;

1.78
date	2001.06.25.08.25.36;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2001.06.23.15.12.18;	author itojun;	state Exp;
branches;
next	1.76;

1.76
date	2001.06.20.13.56.39;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2001.06.04.23.07.20;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2001.05.31.10.30.15;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	2001.05.30.12.55.10;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2001.05.24.18.57.53;	author stevesk;	state Exp;
branches;
next	1.71;

1.71
date	2001.05.16.21.53.53;	author markus;	state Exp;
branches;
next	1.70;

1.70
date	2001.05.11.14.59.55;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2001.05.08.19.17.31;	author markus;	state Exp;
branches;
next	1.68;

1.68
date	2001.05.06.21.45.14;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2001.05.04.23.47.34;	author markus;	state Exp;
branches;
next	1.66;

1.66
date	2001.04.29.19.16.52;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2001.04.20.07.17.51;	author djm;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2001.04.17.09.52.48;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2001.04.15.17.16.00;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2001.04.14.16.33.20;	author stevesk;	state Exp;
branches;
next	1.61;

1.61
date	2001.04.08.11.27.33;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2001.04.05.21.05.23;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2001.04.05.20.01.10;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2001.04.05.11.09.15;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2001.04.05.10.42.49;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2001.04.04.20.25.37;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2001.04.04.14.34.58;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2001.04.04.00.06.53;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2001.03.06.01.08.27;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2001.02.28.08.45.39;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2001.02.13.21.51.09;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2001.02.12.22.56.08;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2001.02.08.19.30.51;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2001.02.06.22.43.02;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2001.01.29.19.42.35;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2001.01.29.16.55.36;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2001.01.21.19.05.47;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2001.01.19.15.55.10;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2001.01.13.19.14.08;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2000.12.19.23.17.56;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2000.12.05.20.34.10;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2000.11.06.23.04.56;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2000.10.27.07.48.22;	author markus;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2000.10.27.07.32.18;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2000.09.26.19.59.58;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2000.09.21.11.25.33;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.14.20.25.14;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.07.20.40.30;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.07.20.27.50;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.19.22.21.19;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.19.21.55.52;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.19.18.48.11;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.16.08.27.21;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.13.23.14.08;	author provos;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.20.01.39.40;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2000.05.08.17.42.24;	author markus;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2000.05.07.18.23.32;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2000.05.02.22.25.03;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2000.05.02.07.28.40;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2000.04.28.08.10.20;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.19.07.05.48;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.14.10.30.30;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.14.10.09.15;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.12.06.37.02;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2000.04.04.17.29.46;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.04.15.19.42;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.28.20.31.26;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	99.12.06.20.15.26;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.11.24.19.53.46;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	99.11.24.00.26.01;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.11.23.22.25.53;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	99.11.19.19.58.18;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.11.11.23.36.53;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	99.11.10.23.36.43;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	99.10.16.20.57.52;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.09.30.08.34.24;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.09.30.05.53.04;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.09.30.05.11.29;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.09.30.05.03.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.04.45.36;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.34;	author deraadt;	state Exp;
branches;
next	;

1.26.2.1
date	2000.09.01.18.23.18;	author jason;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2000.11.08.21.30.37;	author jason;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2001.03.12.15.44.09;	author jason;	state Exp;
branches;
next	1.26.2.4;

1.26.2.4
date	2001.03.21.18.52.41;	author jason;	state Exp;
branches;
next	;

1.39.2.1
date	2001.02.16.20.12.59;	author jason;	state Exp;
branches;
next	1.39.2.2;

1.39.2.2
date	2001.02.19.17.18.48;	author jason;	state Exp;
branches;
next	1.39.2.3;

1.39.2.3
date	2001.03.21.19.46.24;	author jason;	state Exp;
branches;
next	1.39.2.4;

1.39.2.4
date	2001.05.07.21.09.28;	author jason;	state Exp;
branches;
next	1.39.2.5;

1.39.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.39.2.6;

1.39.2.6
date	2001.11.15.00.14.59;	author miod;	state Exp;
branches;
next	1.39.2.7;

1.39.2.7
date	2001.11.15.22.50.30;	author miod;	state Exp;
branches;
next	1.39.2.8;

1.39.2.8
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.65.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.65.2.2;

1.65.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.65.2.3;

1.65.2.3
date	2001.11.15.22.51.15;	author miod;	state Exp;
branches;
next	1.65.2.4;

1.65.2.4
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.65.2.5;

1.65.2.5
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.84.2.1
date	2001.11.14.03.24.38;	author jason;	state Exp;
branches;
next	1.84.2.2;

1.84.2.2
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.84.2.3;

1.84.2.3
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.84.2.4;

1.84.2.4
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.84.2.5;

1.84.2.5
date	2002.06.26.18.22.34;	author miod;	state Exp;
branches;
next	1.84.2.6;

1.84.2.6
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.99.2.1
date	2002.05.18.04.12.10;	author jason;	state Exp;
branches;
next	1.99.2.2;

1.99.2.2
date	2002.05.18.04.50.38;	author jason;	state Exp;
branches;
next	1.99.2.3;

1.99.2.3
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.99.2.4;

1.99.2.4
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.99.2.5;

1.99.2.5
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.104.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.104.2.2;

1.104.2.2
date	2003.09.16.21.20.25;	author brad;	state Exp;
branches;
next	;

1.105.2.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.105.2.2;

1.105.2.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.112.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.112.2.2;

1.112.2.2
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.117.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	1.117.2.2;

1.117.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.131.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.131.2.2;

1.131.2.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	1.131.2.3;

1.131.2.3
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.136.2.1
date	2005.09.04.18.40.01;	author brad;	state Exp;
branches;
next	1.136.2.2;

1.136.2.2
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.141.2.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.141.2.2;

1.141.2.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	1.141.2.3;

1.141.2.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.155.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	1.155.2.2;

1.155.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.175.4.1
date	2006.11.08.00.42.10;	author brad;	state Exp;
branches;
next	;

1.248.2.1
date	2013.11.08.05.52.21;	author djm;	state Exp;
branches;
next	;

1.253.2.1
date	2013.11.08.01.33.56;	author djm;	state Exp;
branches;
next	;

1.272.2.1
date	2016.01.14.11.53.20;	author sthen;	state Exp;
branches;
next	1.272.2.2;
commitid	T6tcqH9MXVck1Xkf;

1.272.2.2
date	2016.01.27.12.20.09;	author sthen;	state Exp;
branches;
next	;
commitid	rLIr3joTk7xJXtme;

1.275.2.1
date	2016.01.14.11.50.37;	author sthen;	state Exp;
branches;
next	1.275.2.2;
commitid	kuomKbPjnfGwrKrZ;

1.275.2.2
date	2016.01.27.12.19.42;	author sthen;	state Exp;
branches;
next	;
commitid	mIcpufpXslF1W9Qg;


desc
@@


1.291
log
@When updating hostkeys, accept RSA keys if HostkeyAlgorithms contains
any RSA keytype. Previously, ssh could ignore RSA keys when any of the
ssh-rsa-sha2-* methods was enabled in HostkeyAlgorithms nit ssh-rsa
(SHA1 signatures) was not. bz#2650 reported by Luis Ressel;
ok dtucker@@
@
text
@/* $OpenBSD: clientloop.c,v 1.290 2017/01/29 21:35:23 dtucker Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * The main loop for the interactive session (client side).
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
 * Copyright (c) 1999 Theo de Raadt.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * SSH2 support added by Markus Friedl.
 * Copyright (c) 1999, 2000, 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/queue.h>

#include <ctype.h>
#include <errno.h>
#include <paths.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <pwd.h>
#include <unistd.h>
#include <limits.h>

#include "xmalloc.h"
#include "ssh.h"
#include "ssh1.h"
#include "ssh2.h"
#include "packet.h"
#include "buffer.h"
#include "compat.h"
#include "channels.h"
#include "dispatch.h"
#include "key.h"
#include "cipher.h"
#include "kex.h"
#include "myproposal.h"
#include "log.h"
#include "misc.h"
#include "readconf.h"
#include "clientloop.h"
#include "sshconnect.h"
#include "authfd.h"
#include "atomicio.h"
#include "sshpty.h"
#include "match.h"
#include "msg.h"
#include "ssherr.h"
#include "hostfile.h"

/* import options */
extern Options options;

/* Flag indicating that stdin should be redirected from /dev/null. */
extern int stdin_null_flag;

/* Flag indicating that no shell has been requested */
extern int no_shell_flag;

/* Flag indicating that ssh should daemonise after authentication is complete */
extern int fork_after_authentication_flag;

/* Control socket */
extern int muxserver_sock; /* XXX use mux_client_cleanup() instead */

/*
 * Name of the host we are connecting to.  This is the name given on the
 * command line, or the HostName specified for the user-supplied name in a
 * configuration file.
 */
extern char *host;

/*
 * Flag to indicate that we have received a window change signal which has
 * not yet been processed.  This will cause a message indicating the new
 * window size to be sent to the server a little later.  This is volatile
 * because this is updated in a signal handler.
 */
static volatile sig_atomic_t received_window_change_signal = 0;
static volatile sig_atomic_t received_signal = 0;

/* Flag indicating whether the user's terminal is in non-blocking mode. */
static int in_non_blocking_mode = 0;

/* Time when backgrounded control master using ControlPersist should exit */
static time_t control_persist_exit_time = 0;

/* Common data for the client loop code. */
volatile sig_atomic_t quit_pending; /* Set non-zero to quit the loop. */
static int escape_char1;	/* Escape character. (proto1 only) */
static int escape_pending1;	/* Last character was an escape (proto1 only) */
static int last_was_cr;		/* Last character was a newline. */
static int exit_status;		/* Used to store the command exit status. */
static int stdin_eof;		/* EOF has been encountered on stderr. */
static Buffer stdin_buffer;	/* Buffer for stdin data. */
static Buffer stdout_buffer;	/* Buffer for stdout data. */
static Buffer stderr_buffer;	/* Buffer for stderr data. */
static u_int buffer_high;	/* Soft max buffer size. */
static int connection_in;	/* Connection to server (input). */
static int connection_out;	/* Connection to server (output). */
static int need_rekeying;	/* Set to non-zero if rekeying is requested. */
static int session_closed;	/* In SSH2: login session closed. */
static u_int x11_refuse_time;	/* If >0, refuse x11 opens after this time. */

static void client_init_dispatch(void);
int	session_ident = -1;

/* Track escape per proto2 channel */
struct escape_filter_ctx {
	int escape_pending;
	int escape_char;
};

/* Context for channel confirmation replies */
struct channel_reply_ctx {
	const char *request_type;
	int id;
	enum confirm_action action;
};

/* Global request success/failure callbacks */
struct global_confirm {
	TAILQ_ENTRY(global_confirm) entry;
	global_confirm_cb *cb;
	void *ctx;
	int ref_count;
};
TAILQ_HEAD(global_confirms, global_confirm);
static struct global_confirms global_confirms =
    TAILQ_HEAD_INITIALIZER(global_confirms);

void ssh_process_session2_setup(int, int, int, Buffer *);

/* Restores stdin to blocking mode. */

static void
leave_non_blocking(void)
{
	if (in_non_blocking_mode) {
		unset_nonblock(fileno(stdin));
		in_non_blocking_mode = 0;
	}
}

/* Puts stdin terminal in non-blocking mode. */

static void
enter_non_blocking(void)
{
	in_non_blocking_mode = 1;
	set_nonblock(fileno(stdin));
}

/*
 * Signal handler for the window change signal (SIGWINCH).  This just sets a
 * flag indicating that the window has changed.
 */
/*ARGSUSED */
static void
window_change_handler(int sig)
{
	received_window_change_signal = 1;
	signal(SIGWINCH, window_change_handler);
}

/*
 * Signal handler for signals that cause the program to terminate.  These
 * signals must be trapped to restore terminal modes.
 */
/*ARGSUSED */
static void
signal_handler(int sig)
{
	received_signal = sig;
	quit_pending = 1;
}

/*
 * Returns current time in seconds from Jan 1, 1970 with the maximum
 * available resolution.
 */

static double
get_current_time(void)
{
	struct timeval tv;
	gettimeofday(&tv, NULL);
	return (double) tv.tv_sec + (double) tv.tv_usec / 1000000.0;
}

/*
 * Sets control_persist_exit_time to the absolute time when the
 * backgrounded control master should exit due to expiry of the
 * ControlPersist timeout.  Sets it to 0 if we are not a backgrounded
 * control master process, or if there is no ControlPersist timeout.
 */
static void
set_control_persist_exit_time(void)
{
	if (muxserver_sock == -1 || !options.control_persist
	    || options.control_persist_timeout == 0) {
		/* not using a ControlPersist timeout */
		control_persist_exit_time = 0;
	} else if (channel_still_open()) {
		/* some client connections are still open */
		if (control_persist_exit_time > 0)
			debug2("%s: cancel scheduled exit", __func__);
		control_persist_exit_time = 0;
	} else if (control_persist_exit_time <= 0) {
		/* a client connection has recently closed */
		control_persist_exit_time = monotime() +
			(time_t)options.control_persist_timeout;
		debug2("%s: schedule exit in %d seconds", __func__,
		    options.control_persist_timeout);
	}
	/* else we are already counting down to the timeout */
}

#define SSH_X11_VALID_DISPLAY_CHARS ":/.-_"
static int
client_x11_display_valid(const char *display)
{
	size_t i, dlen;

	if (display == NULL)
		return 0;

	dlen = strlen(display);
	for (i = 0; i < dlen; i++) {
		if (!isalnum((u_char)display[i]) &&
		    strchr(SSH_X11_VALID_DISPLAY_CHARS, display[i]) == NULL) {
			debug("Invalid character '%c' in DISPLAY", display[i]);
			return 0;
		}
	}
	return 1;
}

#define SSH_X11_PROTO		"MIT-MAGIC-COOKIE-1"
#define X11_TIMEOUT_SLACK	60
int
client_x11_get_proto(const char *display, const char *xauth_path,
    u_int trusted, u_int timeout, char **_proto, char **_data)
{
	char cmd[1024], line[512], xdisplay[512];
	char xauthfile[PATH_MAX], xauthdir[PATH_MAX];
	static char proto[512], data[512];
	FILE *f;
	int got_data = 0, generated = 0, do_unlink = 0, r;
	struct stat st;
	u_int now, x11_timeout_real;

	*_proto = proto;
	*_data = data;
	proto[0] = data[0] = xauthfile[0] = xauthdir[0] = '\0';

	if (!client_x11_display_valid(display)) {
		if (display != NULL)
			logit("DISPLAY \"%s\" invalid; disabling X11 forwarding",
			    display);
		return -1;
	}
	if (xauth_path != NULL && stat(xauth_path, &st) == -1) {
		debug("No xauth program.");
		xauth_path = NULL;
	}

	if (xauth_path != NULL) {
		/*
		 * Handle FamilyLocal case where $DISPLAY does
		 * not match an authorization entry.  For this we
		 * just try "xauth list unix:displaynum.screennum".
		 * XXX: "localhost" match to determine FamilyLocal
		 *      is not perfect.
		 */
		if (strncmp(display, "localhost:", 10) == 0) {
			if ((r = snprintf(xdisplay, sizeof(xdisplay), "unix:%s",
			    display + 10)) < 0 ||
			    (size_t)r >= sizeof(xdisplay)) {
				error("%s: display name too long", __func__);
				return -1;
			}
			display = xdisplay;
		}
		if (trusted == 0) {
			/*
			 * Generate an untrusted X11 auth cookie.
			 *
			 * The authentication cookie should briefly outlive
			 * ssh's willingness to forward X11 connections to
			 * avoid nasty fail-open behaviour in the X server.
			 */
			mktemp_proto(xauthdir, sizeof(xauthdir));
			if (mkdtemp(xauthdir) == NULL) {
				error("%s: mkdtemp: %s",
				    __func__, strerror(errno));
				return -1;
			}
			do_unlink = 1;
			if ((r = snprintf(xauthfile, sizeof(xauthfile),
			    "%s/xauthfile", xauthdir)) < 0 ||
			    (size_t)r >= sizeof(xauthfile)) {
				error("%s: xauthfile path too long", __func__);
				unlink(xauthfile);
				rmdir(xauthdir);
				return -1;
			}

			if (timeout >= UINT_MAX - X11_TIMEOUT_SLACK)
				x11_timeout_real = UINT_MAX;
			else
				x11_timeout_real = timeout + X11_TIMEOUT_SLACK;
			if ((r = snprintf(cmd, sizeof(cmd),
			    "%s -f %s generate %s " SSH_X11_PROTO
			    " untrusted timeout %u 2>" _PATH_DEVNULL,
			    xauth_path, xauthfile, display,
			    x11_timeout_real)) < 0 ||
			    (size_t)r >= sizeof(cmd))
				fatal("%s: cmd too long", __func__);
			debug2("%s: %s", __func__, cmd);
			if (x11_refuse_time == 0) {
				now = monotime() + 1;
				if (UINT_MAX - timeout < now)
					x11_refuse_time = UINT_MAX;
				else
					x11_refuse_time = now + timeout;
				channel_set_x11_refuse_time(x11_refuse_time);
			}
			if (system(cmd) == 0)
				generated = 1;
		}

		/*
		 * When in untrusted mode, we read the cookie only if it was
		 * successfully generated as an untrusted one in the step
		 * above.
		 */
		if (trusted || generated) {
			snprintf(cmd, sizeof(cmd),
			    "%s %s%s list %s 2>" _PATH_DEVNULL,
			    xauth_path,
			    generated ? "-f " : "" ,
			    generated ? xauthfile : "",
			    display);
			debug2("x11_get_proto: %s", cmd);
			f = popen(cmd, "r");
			if (f && fgets(line, sizeof(line), f) &&
			    sscanf(line, "%*s %511s %511s", proto, data) == 2)
				got_data = 1;
			if (f)
				pclose(f);
		}
	}

	if (do_unlink) {
		unlink(xauthfile);
		rmdir(xauthdir);
	}

	/* Don't fall back to fake X11 data for untrusted forwarding */
	if (!trusted && !got_data) {
		error("Warning: untrusted X11 forwarding setup failed: "
		    "xauth key data not generated");
		return -1;
	}

	/*
	 * If we didn't get authentication data, just make up some
	 * data.  The forwarding code will check the validity of the
	 * response anyway, and substitute this data.  The X11
	 * server, however, will ignore this fake data and use
	 * whatever authentication mechanisms it was using otherwise
	 * for the local connection.
	 */
	if (!got_data) {
		u_int8_t rnd[16];
		u_int i;

		logit("Warning: No xauth data; "
		    "using fake authentication data for X11 forwarding.");
		strlcpy(proto, SSH_X11_PROTO, sizeof proto);
		arc4random_buf(rnd, sizeof(rnd));
		for (i = 0; i < sizeof(rnd); i++) {
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x",
			    rnd[i]);
		}
	}

	return 0;
}

/*
 * This is called when the interactive is entered.  This checks if there is
 * an EOF coming on stdin.  We must check this explicitly, as select() does
 * not appear to wake up when redirecting from /dev/null.
 */

static void
client_check_initial_eof_on_stdin(void)
{
	int len;
	char buf[1];

	/*
	 * If standard input is to be "redirected from /dev/null", we simply
	 * mark that we have seen an EOF and send an EOF message to the
	 * server. Otherwise, we try to read a single character; it appears
	 * that for some files, such /dev/null, select() never wakes up for
	 * read for this descriptor, which means that we never get EOF.  This
	 * way we will get the EOF if stdin comes from /dev/null or similar.
	 */
	if (stdin_null_flag) {
		/* Fake EOF on stdin. */
		debug("Sending eof.");
		stdin_eof = 1;
		packet_start(SSH_CMSG_EOF);
		packet_send();
	} else {
		enter_non_blocking();

		/* Check for immediate EOF on stdin. */
		len = read(fileno(stdin), buf, 1);
		if (len == 0) {
			/*
			 * EOF.  Record that we have seen it and send
			 * EOF to server.
			 */
			debug("Sending eof.");
			stdin_eof = 1;
			packet_start(SSH_CMSG_EOF);
			packet_send();
		} else if (len > 0) {
			/*
			 * Got data.  We must store the data in the buffer,
			 * and also process it as an escape character if
			 * appropriate.
			 */
			if ((u_char) buf[0] == escape_char1)
				escape_pending1 = 1;
			else
				buffer_append(&stdin_buffer, buf, 1);
		}
		leave_non_blocking();
	}
}


/*
 * Make packets from buffered stdin data, and buffer them for sending to the
 * connection.
 */

static void
client_make_packets_from_stdin_data(void)
{
	u_int len;

	/* Send buffered stdin data to the server. */
	while (buffer_len(&stdin_buffer) > 0 &&
	    packet_not_very_much_data_to_write()) {
		len = buffer_len(&stdin_buffer);
		/* Keep the packets at reasonable size. */
		if (len > packet_get_maxsize())
			len = packet_get_maxsize();
		packet_start(SSH_CMSG_STDIN_DATA);
		packet_put_string(buffer_ptr(&stdin_buffer), len);
		packet_send();
		buffer_consume(&stdin_buffer, len);
		/* If we have a pending EOF, send it now. */
		if (stdin_eof && buffer_len(&stdin_buffer) == 0) {
			packet_start(SSH_CMSG_EOF);
			packet_send();
		}
	}
}

/*
 * Checks if the client window has changed, and sends a packet about it to
 * the server if so.  The actual change is detected elsewhere (by a software
 * interrupt on Unix); this just checks the flag and sends a message if
 * appropriate.
 */

static void
client_check_window_change(void)
{
	struct winsize ws;

	if (! received_window_change_signal)
		return;
	/** XXX race */
	received_window_change_signal = 0;

	debug2("client_check_window_change: changed");

	if (compat20) {
		channel_send_window_changes();
	} else {
		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
			return;
		packet_start(SSH_CMSG_WINDOW_SIZE);
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
		packet_send();
	}
}

static int
client_global_request_reply(int type, u_int32_t seq, void *ctxt)
{
	struct global_confirm *gc;

	if ((gc = TAILQ_FIRST(&global_confirms)) == NULL)
		return 0;
	if (gc->cb != NULL)
		gc->cb(type, seq, gc->ctx);
	if (--gc->ref_count <= 0) {
		TAILQ_REMOVE(&global_confirms, gc, entry);
		explicit_bzero(gc, sizeof(*gc));
		free(gc);
	}

	packet_set_alive_timeouts(0);
	return 0;
}

static void
server_alive_check(void)
{
	if (packet_inc_alive_timeouts() > options.server_alive_count_max) {
		logit("Timeout, server %s not responding.", host);
		cleanup_exit(255);
	}
	packet_start(SSH2_MSG_GLOBAL_REQUEST);
	packet_put_cstring("keepalive@@openssh.com");
	packet_put_char(1);     /* boolean: want reply */
	packet_send();
	/* Insert an empty placeholder to maintain ordering */
	client_register_global_confirm(NULL, NULL);
}

/*
 * Waits until the client can do something (some data becomes available on
 * one of the file descriptors).
 */
static void
client_wait_until_can_do_something(fd_set **readsetp, fd_set **writesetp,
    int *maxfdp, u_int *nallocp, int rekeying)
{
	struct timeval tv, *tvp;
	int timeout_secs;
	time_t minwait_secs = 0, server_alive_time = 0, now = monotime();
	int ret;

	/* Add any selections by the channel mechanism. */
	channel_prepare_select(readsetp, writesetp, maxfdp, nallocp,
	    &minwait_secs, rekeying);

	if (!compat20) {
		/* Read from the connection, unless our buffers are full. */
		if (buffer_len(&stdout_buffer) < buffer_high &&
		    buffer_len(&stderr_buffer) < buffer_high &&
		    channel_not_very_much_buffered_data())
			FD_SET(connection_in, *readsetp);
		/*
		 * Read from stdin, unless we have seen EOF or have very much
		 * buffered data to send to the server.
		 */
		if (!stdin_eof && packet_not_very_much_data_to_write())
			FD_SET(fileno(stdin), *readsetp);

		/* Select stdout/stderr if have data in buffer. */
		if (buffer_len(&stdout_buffer) > 0)
			FD_SET(fileno(stdout), *writesetp);
		if (buffer_len(&stderr_buffer) > 0)
			FD_SET(fileno(stderr), *writesetp);
	} else {
		/* channel_prepare_select could have closed the last channel */
		if (session_closed && !channel_still_open() &&
		    !packet_have_data_to_write()) {
			/* clear mask since we did not call select() */
			memset(*readsetp, 0, *nallocp);
			memset(*writesetp, 0, *nallocp);
			return;
		} else {
			FD_SET(connection_in, *readsetp);
		}
	}

	/* Select server connection if have data to write to the server. */
	if (packet_have_data_to_write())
		FD_SET(connection_out, *writesetp);

	/*
	 * Wait for something to happen.  This will suspend the process until
	 * some selected descriptor can be read, written, or has some other
	 * event pending, or a timeout expires.
	 */

	timeout_secs = INT_MAX; /* we use INT_MAX to mean no timeout */
	if (options.server_alive_interval > 0 && compat20) {
		timeout_secs = options.server_alive_interval;
		server_alive_time = now + options.server_alive_interval;
	}
	if (options.rekey_interval > 0 && compat20 && !rekeying)
		timeout_secs = MINIMUM(timeout_secs, packet_get_rekey_timeout());
	set_control_persist_exit_time();
	if (control_persist_exit_time > 0) {
		timeout_secs = MINIMUM(timeout_secs,
			control_persist_exit_time - now);
		if (timeout_secs < 0)
			timeout_secs = 0;
	}
	if (minwait_secs != 0)
		timeout_secs = MINIMUM(timeout_secs, (int)minwait_secs);
	if (timeout_secs == INT_MAX)
		tvp = NULL;
	else {
		tv.tv_sec = timeout_secs;
		tv.tv_usec = 0;
		tvp = &tv;
	}

	ret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);
	if (ret < 0) {
		char buf[100];

		/*
		 * We have to clear the select masks, because we return.
		 * We have to return, because the mainloop checks for the flags
		 * set by the signal handlers.
		 */
		memset(*readsetp, 0, *nallocp);
		memset(*writesetp, 0, *nallocp);

		if (errno == EINTR)
			return;
		/* Note: we might still have data in the buffers. */
		snprintf(buf, sizeof buf, "select: %s\r\n", strerror(errno));
		buffer_append(&stderr_buffer, buf, strlen(buf));
		quit_pending = 1;
	} else if (ret == 0) {
		/*
		 * Timeout.  Could have been either keepalive or rekeying.
		 * Keepalive we check here, rekeying is checked in clientloop.
		 */
		if (server_alive_time != 0 && server_alive_time <= monotime())
			server_alive_check();
	}

}

static void
client_suspend_self(Buffer *bin, Buffer *bout, Buffer *berr)
{
	/* Flush stdout and stderr buffers. */
	if (buffer_len(bout) > 0)
		atomicio(vwrite, fileno(stdout), buffer_ptr(bout),
		    buffer_len(bout));
	if (buffer_len(berr) > 0)
		atomicio(vwrite, fileno(stderr), buffer_ptr(berr),
		    buffer_len(berr));

	leave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);

	/*
	 * Free (and clear) the buffer to reduce the amount of data that gets
	 * written to swap.
	 */
	buffer_free(bin);
	buffer_free(bout);
	buffer_free(berr);

	/* Send the suspend signal to the program itself. */
	kill(getpid(), SIGTSTP);

	/* Reset window sizes in case they have changed */
	received_window_change_signal = 1;

	/* OK, we have been continued by the user. Reinitialize buffers. */
	buffer_init(bin);
	buffer_init(bout);
	buffer_init(berr);

	enter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);
}

static void
client_process_net_input(fd_set *readset)
{
	int len;
	char buf[8192];

	/*
	 * Read input from the server, and add any such data to the buffer of
	 * the packet subsystem.
	 */
	if (FD_ISSET(connection_in, readset)) {
		/* Read as much as possible. */
		len = read(connection_in, buf, sizeof(buf));
		if (len == 0) {
			/*
			 * Received EOF.  The remote host has closed the
			 * connection.
			 */
			snprintf(buf, sizeof buf,
			    "Connection to %.300s closed by remote host.\r\n",
			    host);
			buffer_append(&stderr_buffer, buf, strlen(buf));
			quit_pending = 1;
			return;
		}
		/*
		 * There is a kernel bug on Solaris that causes select to
		 * sometimes wake up even though there is no data available.
		 */
		if (len < 0 && (errno == EAGAIN || errno == EINTR))
			len = 0;

		if (len < 0) {
			/*
			 * An error has encountered.  Perhaps there is a
			 * network problem.
			 */
			snprintf(buf, sizeof buf,
			    "Read from remote host %.300s: %.100s\r\n",
			    host, strerror(errno));
			buffer_append(&stderr_buffer, buf, strlen(buf));
			quit_pending = 1;
			return;
		}
		packet_process_incoming(buf, len);
	}
}

static void
client_status_confirm(int type, Channel *c, void *ctx)
{
	struct channel_reply_ctx *cr = (struct channel_reply_ctx *)ctx;
	char errmsg[256];
	int tochan;

	/*
	 * If a TTY was explicitly requested, then a failure to allocate
	 * one is fatal.
	 */
	if (cr->action == CONFIRM_TTY &&
	    (options.request_tty == REQUEST_TTY_FORCE ||
	    options.request_tty == REQUEST_TTY_YES))
		cr->action = CONFIRM_CLOSE;

	/* XXX supress on mux _client_ quietmode */
	tochan = options.log_level >= SYSLOG_LEVEL_ERROR &&
	    c->ctl_chan != -1 && c->extended_usage == CHAN_EXTENDED_WRITE;

	if (type == SSH2_MSG_CHANNEL_SUCCESS) {
		debug2("%s request accepted on channel %d",
		    cr->request_type, c->self);
	} else if (type == SSH2_MSG_CHANNEL_FAILURE) {
		if (tochan) {
			snprintf(errmsg, sizeof(errmsg),
			    "%s request failed\r\n", cr->request_type);
		} else {
			snprintf(errmsg, sizeof(errmsg),
			    "%s request failed on channel %d",
			    cr->request_type, c->self);
		}
		/* If error occurred on primary session channel, then exit */
		if (cr->action == CONFIRM_CLOSE && c->self == session_ident)
			fatal("%s", errmsg);
		/*
		 * If error occurred on mux client, append to
		 * their stderr.
		 */
		if (tochan) {
			buffer_append(&c->extended, errmsg,
			    strlen(errmsg));
		} else
			error("%s", errmsg);
		if (cr->action == CONFIRM_TTY) {
			/*
			 * If a TTY allocation error occurred, then arrange
			 * for the correct TTY to leave raw mode.
			 */
			if (c->self == session_ident)
				leave_raw_mode(0);
			else
				mux_tty_alloc_failed(c);
		} else if (cr->action == CONFIRM_CLOSE) {
			chan_read_failed(c);
			chan_write_failed(c);
		}
	}
	free(cr);
}

static void
client_abandon_status_confirm(Channel *c, void *ctx)
{
	free(ctx);
}

void
client_expect_confirm(int id, const char *request,
    enum confirm_action action)
{
	struct channel_reply_ctx *cr = xcalloc(1, sizeof(*cr));

	cr->request_type = request;
	cr->action = action;

	channel_register_status_confirm(id, client_status_confirm,
	    client_abandon_status_confirm, cr);
}

void
client_register_global_confirm(global_confirm_cb *cb, void *ctx)
{
	struct global_confirm *gc, *last_gc;

	/* Coalesce identical callbacks */
	last_gc = TAILQ_LAST(&global_confirms, global_confirms);
	if (last_gc && last_gc->cb == cb && last_gc->ctx == ctx) {
		if (++last_gc->ref_count >= INT_MAX)
			fatal("%s: last_gc->ref_count = %d",
			    __func__, last_gc->ref_count);
		return;
	}

	gc = xcalloc(1, sizeof(*gc));
	gc->cb = cb;
	gc->ctx = ctx;
	gc->ref_count = 1;
	TAILQ_INSERT_TAIL(&global_confirms, gc, entry);
}

static void
process_cmdline(void)
{
	void (*handler)(int);
	char *s, *cmd;
	int ok, delete = 0, local = 0, remote = 0, dynamic = 0;
	struct Forward fwd;

	memset(&fwd, 0, sizeof(fwd));

	leave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);
	handler = signal(SIGINT, SIG_IGN);
	cmd = s = read_passphrase("\r\nssh> ", RP_ECHO);
	if (s == NULL)
		goto out;
	while (isspace((u_char)*s))
		s++;
	if (*s == '-')
		s++;	/* Skip cmdline '-', if any */
	if (*s == '\0')
		goto out;

	if (*s == 'h' || *s == 'H' || *s == '?') {
		logit("Commands:");
		logit("      -L[bind_address:]port:host:hostport    "
		    "Request local forward");
		logit("      -R[bind_address:]port:host:hostport    "
		    "Request remote forward");
		logit("      -D[bind_address:]port                  "
		    "Request dynamic forward");
		logit("      -KL[bind_address:]port                 "
		    "Cancel local forward");
		logit("      -KR[bind_address:]port                 "
		    "Cancel remote forward");
		logit("      -KD[bind_address:]port                 "
		    "Cancel dynamic forward");
		if (!options.permit_local_command)
			goto out;
		logit("      !args                                  "
		    "Execute local command");
		goto out;
	}

	if (*s == '!' && options.permit_local_command) {
		s++;
		ssh_local_cmd(s);
		goto out;
	}

	if (*s == 'K') {
		delete = 1;
		s++;
	}
	if (*s == 'L')
		local = 1;
	else if (*s == 'R')
		remote = 1;
	else if (*s == 'D')
		dynamic = 1;
	else {
		logit("Invalid command.");
		goto out;
	}

	if (delete && !compat20) {
		logit("Not supported for SSH protocol version 1.");
		goto out;
	}

	while (isspace((u_char)*++s))
		;

	/* XXX update list of forwards in options */
	if (delete) {
		/* We pass 1 for dynamicfwd to restrict to 1 or 2 fields. */
		if (!parse_forward(&fwd, s, 1, 0)) {
			logit("Bad forwarding close specification.");
			goto out;
		}
		if (remote)
			ok = channel_request_rforward_cancel(&fwd) == 0;
		else if (dynamic)
			ok = channel_cancel_lport_listener(&fwd,
			    0, &options.fwd_opts) > 0;
		else
			ok = channel_cancel_lport_listener(&fwd,
			    CHANNEL_CANCEL_PORT_STATIC,
			    &options.fwd_opts) > 0;
		if (!ok) {
			logit("Unknown port forwarding.");
			goto out;
		}
		logit("Canceled forwarding.");
	} else {
		if (!parse_forward(&fwd, s, dynamic, remote)) {
			logit("Bad forwarding specification.");
			goto out;
		}
		if (local || dynamic) {
			if (!channel_setup_local_fwd_listener(&fwd,
			    &options.fwd_opts)) {
				logit("Port forwarding failed.");
				goto out;
			}
		} else {
			if (channel_request_remote_forwarding(&fwd) < 0) {
				logit("Port forwarding failed.");
				goto out;
			}
		}
		logit("Forwarding port.");
	}

out:
	signal(SIGINT, handler);
	enter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);
	free(cmd);
	free(fwd.listen_host);
	free(fwd.listen_path);
	free(fwd.connect_host);
	free(fwd.connect_path);
}

/* reasons to suppress output of an escape command in help output */
#define SUPPRESS_NEVER		0	/* never suppress, always show */
#define SUPPRESS_PROTO1		1	/* don't show in protocol 1 sessions */
#define SUPPRESS_MUXCLIENT	2	/* don't show in mux client sessions */
#define SUPPRESS_MUXMASTER	4	/* don't show in mux master sessions */
#define SUPPRESS_SYSLOG		8	/* don't show when logging to syslog */
struct escape_help_text {
	const char *cmd;
	const char *text;
	unsigned int flags;
};
static struct escape_help_text esc_txt[] = {
    {".",  "terminate session", SUPPRESS_MUXMASTER},
    {".",  "terminate connection (and any multiplexed sessions)",
	SUPPRESS_MUXCLIENT},
    {"B",  "send a BREAK to the remote system", SUPPRESS_PROTO1},
    {"C",  "open a command line", SUPPRESS_MUXCLIENT},
    {"R",  "request rekey", SUPPRESS_PROTO1},
    {"V/v",  "decrease/increase verbosity (LogLevel)", SUPPRESS_MUXCLIENT},
    {"^Z", "suspend ssh", SUPPRESS_MUXCLIENT},
    {"#",  "list forwarded connections", SUPPRESS_NEVER},
    {"&",  "background ssh (when waiting for connections to terminate)",
	SUPPRESS_MUXCLIENT},
    {"?", "this message", SUPPRESS_NEVER},
};

static void
print_escape_help(Buffer *b, int escape_char, int protocol2, int mux_client,
    int using_stderr)
{
	unsigned int i, suppress_flags;
	char string[1024];

	snprintf(string, sizeof string, "%c?\r\n"
	    "Supported escape sequences:\r\n", escape_char);
	buffer_append(b, string, strlen(string));

	suppress_flags = (protocol2 ? 0 : SUPPRESS_PROTO1) |
	    (mux_client ? SUPPRESS_MUXCLIENT : 0) |
	    (mux_client ? 0 : SUPPRESS_MUXMASTER) |
	    (using_stderr ? 0 : SUPPRESS_SYSLOG);

	for (i = 0; i < sizeof(esc_txt)/sizeof(esc_txt[0]); i++) {
		if (esc_txt[i].flags & suppress_flags)
			continue;
		snprintf(string, sizeof string, " %c%-3s - %s\r\n",
		    escape_char, esc_txt[i].cmd, esc_txt[i].text);
		buffer_append(b, string, strlen(string));
	}

	snprintf(string, sizeof string,
	    " %c%c   - send the escape character by typing it twice\r\n"
	    "(Note that escapes are only recognized immediately after "
	    "newline.)\r\n", escape_char, escape_char);
	buffer_append(b, string, strlen(string));
}

/* 
 * Process the characters one by one, call with c==NULL for proto1 case.
 */
static int
process_escapes(Channel *c, Buffer *bin, Buffer *bout, Buffer *berr,
    char *buf, int len)
{
	char string[1024];
	pid_t pid;
	int bytes = 0;
	u_int i;
	u_char ch;
	char *s;
	int *escape_pendingp, escape_char;
	struct escape_filter_ctx *efc;

	if (c == NULL) {
		escape_pendingp = &escape_pending1;
		escape_char = escape_char1;
	} else {
		if (c->filter_ctx == NULL)
			return 0;
		efc = (struct escape_filter_ctx *)c->filter_ctx;
		escape_pendingp = &efc->escape_pending;
		escape_char = efc->escape_char;
	}
	
	if (len <= 0)
		return (0);

	for (i = 0; i < (u_int)len; i++) {
		/* Get one character at a time. */
		ch = buf[i];

		if (*escape_pendingp) {
			/* We have previously seen an escape character. */
			/* Clear the flag now. */
			*escape_pendingp = 0;

			/* Process the escaped character. */
			switch (ch) {
			case '.':
				/* Terminate the connection. */
				snprintf(string, sizeof string, "%c.\r\n",
				    escape_char);
				buffer_append(berr, string, strlen(string));

				if (c && c->ctl_chan != -1) {
					chan_read_failed(c);
					chan_write_failed(c);
					if (c->detach_user)
						c->detach_user(c->self, NULL);
					c->type = SSH_CHANNEL_ABANDONED;
					buffer_clear(&c->input);
					chan_ibuf_empty(c);
					return 0;
				} else
					quit_pending = 1;
				return -1;

			case 'Z' - 64:
				/* XXX support this for mux clients */
				if (c && c->ctl_chan != -1) {
					char b[16];
 noescape:
					if (ch == 'Z' - 64)
						snprintf(b, sizeof b, "^Z");
					else
						snprintf(b, sizeof b, "%c", ch);
					snprintf(string, sizeof string,
					    "%c%s escape not available to "
					    "multiplexed sessions\r\n",
					    escape_char, b);
					buffer_append(berr, string,
					    strlen(string));
					continue;
				}
				/* Suspend the program. Inform the user */
				snprintf(string, sizeof string,
				    "%c^Z [suspend ssh]\r\n", escape_char);
				buffer_append(berr, string, strlen(string));

				/* Restore terminal modes and suspend. */
				client_suspend_self(bin, bout, berr);

				/* We have been continued. */
				continue;

			case 'B':
				if (compat20) {
					snprintf(string, sizeof string,
					    "%cB\r\n", escape_char);
					buffer_append(berr, string,
					    strlen(string));
					channel_request_start(c->self,
					    "break", 0);
					packet_put_int(1000);
					packet_send();
				}
				continue;

			case 'R':
				if (compat20) {
					if (datafellows & SSH_BUG_NOREKEY)
						logit("Server does not "
						    "support re-keying");
					else
						need_rekeying = 1;
				}
				continue;

			case 'V':
				/* FALLTHROUGH */
			case 'v':
				if (c && c->ctl_chan != -1)
					goto noescape;
				if (!log_is_on_stderr()) {
					snprintf(string, sizeof string,
					    "%c%c [Logging to syslog]\r\n",
					     escape_char, ch);
					buffer_append(berr, string,
					    strlen(string));
					continue;
				}
				if (ch == 'V' && options.log_level >
				    SYSLOG_LEVEL_QUIET)
					log_change_level(--options.log_level);
				if (ch == 'v' && options.log_level <
				    SYSLOG_LEVEL_DEBUG3)
					log_change_level(++options.log_level);
				snprintf(string, sizeof string,
				    "%c%c [LogLevel %s]\r\n", escape_char, ch,
				    log_level_name(options.log_level));
				buffer_append(berr, string, strlen(string));
				continue;

			case '&':
				if (c && c->ctl_chan != -1)
					goto noescape;
				/*
				 * Detach the program (continue to serve
				 * connections, but put in background and no
				 * more new connections).
				 */
				/* Restore tty modes. */
				leave_raw_mode(
				    options.request_tty == REQUEST_TTY_FORCE);

				/* Stop listening for new connections. */
				channel_stop_listening();

				snprintf(string, sizeof string,
				    "%c& [backgrounded]\n", escape_char);
				buffer_append(berr, string, strlen(string));

				/* Fork into background. */
				pid = fork();
				if (pid < 0) {
					error("fork: %.100s", strerror(errno));
					continue;
				}
				if (pid != 0) {	/* This is the parent. */
					/* The parent just exits. */
					exit(0);
				}
				/* The child continues serving connections. */
				if (compat20) {
					buffer_append(bin, "\004", 1);
					/* fake EOF on stdin */
					return -1;
				} else if (!stdin_eof) {
					/*
					 * Sending SSH_CMSG_EOF alone does not
					 * always appear to be enough.  So we
					 * try to send an EOF character first.
					 */
					packet_start(SSH_CMSG_STDIN_DATA);
					packet_put_string("\004", 1);
					packet_send();
					/* Close stdin. */
					stdin_eof = 1;
					if (buffer_len(bin) == 0) {
						packet_start(SSH_CMSG_EOF);
						packet_send();
					}
				}
				continue;

			case '?':
				print_escape_help(berr, escape_char, compat20,
				    (c && c->ctl_chan != -1),
				    log_is_on_stderr());
				continue;

			case '#':
				snprintf(string, sizeof string, "%c#\r\n",
				    escape_char);
				buffer_append(berr, string, strlen(string));
				s = channel_open_message();
				buffer_append(berr, s, strlen(s));
				free(s);
				continue;

			case 'C':
				if (c && c->ctl_chan != -1)
					goto noescape;
				process_cmdline();
				continue;

			default:
				if (ch != escape_char) {
					buffer_put_char(bin, escape_char);
					bytes++;
				}
				/* Escaped characters fall through here */
				break;
			}
		} else {
			/*
			 * The previous character was not an escape char.
			 * Check if this is an escape.
			 */
			if (last_was_cr && ch == escape_char) {
				/*
				 * It is. Set the flag and continue to
				 * next character.
				 */
				*escape_pendingp = 1;
				continue;
			}
		}

		/*
		 * Normal character.  Record whether it was a newline,
		 * and append it to the buffer.
		 */
		last_was_cr = (ch == '\r' || ch == '\n');
		buffer_put_char(bin, ch);
		bytes++;
	}
	return bytes;
}

static void
client_process_input(fd_set *readset)
{
	int len;
	char buf[8192];

	/* Read input from stdin. */
	if (FD_ISSET(fileno(stdin), readset)) {
		/* Read as much as possible. */
		len = read(fileno(stdin), buf, sizeof(buf));
		if (len < 0 && (errno == EAGAIN || errno == EINTR))
			return;		/* we'll try again later */
		if (len <= 0) {
			/*
			 * Received EOF or error.  They are treated
			 * similarly, except that an error message is printed
			 * if it was an error condition.
			 */
			if (len < 0) {
				snprintf(buf, sizeof buf, "read: %.100s\r\n",
				    strerror(errno));
				buffer_append(&stderr_buffer, buf, strlen(buf));
			}
			/* Mark that we have seen EOF. */
			stdin_eof = 1;
			/*
			 * Send an EOF message to the server unless there is
			 * data in the buffer.  If there is data in the
			 * buffer, no message will be sent now.  Code
			 * elsewhere will send the EOF when the buffer
			 * becomes empty if stdin_eof is set.
			 */
			if (buffer_len(&stdin_buffer) == 0) {
				packet_start(SSH_CMSG_EOF);
				packet_send();
			}
		} else if (escape_char1 == SSH_ESCAPECHAR_NONE) {
			/*
			 * Normal successful read, and no escape character.
			 * Just append the data to buffer.
			 */
			buffer_append(&stdin_buffer, buf, len);
		} else {
			/*
			 * Normal, successful read.  But we have an escape
			 * character and have to process the characters one
			 * by one.
			 */
			if (process_escapes(NULL, &stdin_buffer,
			    &stdout_buffer, &stderr_buffer, buf, len) == -1)
				return;
		}
	}
}

static void
client_process_output(fd_set *writeset)
{
	int len;
	char buf[100];

	/* Write buffered output to stdout. */
	if (FD_ISSET(fileno(stdout), writeset)) {
		/* Write as much data as possible. */
		len = write(fileno(stdout), buffer_ptr(&stdout_buffer),
		    buffer_len(&stdout_buffer));
		if (len <= 0) {
			if (errno == EINTR || errno == EAGAIN)
				len = 0;
			else {
				/*
				 * An error or EOF was encountered.  Put an
				 * error message to stderr buffer.
				 */
				snprintf(buf, sizeof buf,
				    "write stdout: %.50s\r\n", strerror(errno));
				buffer_append(&stderr_buffer, buf, strlen(buf));
				quit_pending = 1;
				return;
			}
		}
		/* Consume printed data from the buffer. */
		buffer_consume(&stdout_buffer, len);
	}
	/* Write buffered output to stderr. */
	if (FD_ISSET(fileno(stderr), writeset)) {
		/* Write as much data as possible. */
		len = write(fileno(stderr), buffer_ptr(&stderr_buffer),
		    buffer_len(&stderr_buffer));
		if (len <= 0) {
			if (errno == EINTR || errno == EAGAIN)
				len = 0;
			else {
				/*
				 * EOF or error, but can't even print
				 * error message.
				 */
				quit_pending = 1;
				return;
			}
		}
		/* Consume printed characters from the buffer. */
		buffer_consume(&stderr_buffer, len);
	}
}

/*
 * Get packets from the connection input buffer, and process them as long as
 * there are packets available.
 *
 * Any unknown packets received during the actual
 * session cause the session to terminate.  This is
 * intended to make debugging easier since no
 * confirmations are sent.  Any compatible protocol
 * extensions must be negotiated during the
 * preparatory phase.
 */

static void
client_process_buffered_input_packets(void)
{
	dispatch_run(DISPATCH_NONBLOCK, &quit_pending, active_state);
}

/* scan buf[] for '~' before sending data to the peer */

/* Helper: allocate a new escape_filter_ctx and fill in its escape char */
void *
client_new_escape_filter_ctx(int escape_char)
{
	struct escape_filter_ctx *ret;

	ret = xcalloc(1, sizeof(*ret));
	ret->escape_pending = 0;
	ret->escape_char = escape_char;
	return (void *)ret;
}

/* Free the escape filter context on channel free */
void
client_filter_cleanup(int cid, void *ctx)
{
	free(ctx);
}

int
client_simple_escape_filter(Channel *c, char *buf, int len)
{
	if (c->extended_usage != CHAN_EXTENDED_WRITE)
		return 0;

	return process_escapes(c, &c->input, &c->output, &c->extended,
	    buf, len);
}

static void
client_channel_closed(int id, void *arg)
{
	channel_cancel_cleanup(id);
	session_closed = 1;
	leave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);
}

/*
 * Implements the interactive session with the server.  This is called after
 * the user has been authenticated, and a command has been started on the
 * remote host.  If escape_char != SSH_ESCAPECHAR_NONE, it is the character
 * used as an escape character for terminating or suspending the session.
 */

int
client_loop(int have_pty, int escape_char_arg, int ssh2_chan_id)
{
	fd_set *readset = NULL, *writeset = NULL;
	double start_time, total_time;
	int r, max_fd = 0, max_fd2 = 0, len;
	u_int64_t ibytes, obytes;
	u_int nalloc = 0;
	char buf[100];

	debug("Entering interactive session.");

	if (options.control_master &&
	    !option_clear_or_none(options.control_path)) {
		debug("pledge: id");
		if (pledge("stdio rpath wpath cpath unix inet dns recvfd proc exec id tty",
		    NULL) == -1)
			fatal("%s pledge(): %s", __func__, strerror(errno));

	} else if (options.forward_x11 || options.permit_local_command) {
		debug("pledge: exec");
		if (pledge("stdio rpath wpath cpath unix inet dns proc exec tty",
		    NULL) == -1)
			fatal("%s pledge(): %s", __func__, strerror(errno));

	} else if (options.update_hostkeys) {
		debug("pledge: filesystem full");
		if (pledge("stdio rpath wpath cpath unix inet dns proc tty",
		    NULL) == -1)
			fatal("%s pledge(): %s", __func__, strerror(errno));

	} else if (!option_clear_or_none(options.proxy_command) ||
	    fork_after_authentication_flag) {
		debug("pledge: proc");
		if (pledge("stdio cpath unix inet dns proc tty", NULL) == -1)
			fatal("%s pledge(): %s", __func__, strerror(errno));

	} else {
		debug("pledge: network");
		if (pledge("stdio unix inet dns tty", NULL) == -1)
			fatal("%s pledge(): %s", __func__, strerror(errno));
	}

	start_time = get_current_time();

	/* Initialize variables. */
	escape_pending1 = 0;
	last_was_cr = 1;
	exit_status = -1;
	stdin_eof = 0;
	buffer_high = 64 * 1024;
	connection_in = packet_get_connection_in();
	connection_out = packet_get_connection_out();
	max_fd = MAXIMUM(connection_in, connection_out);

	if (!compat20) {
		/* enable nonblocking unless tty */
		if (!isatty(fileno(stdin)))
			set_nonblock(fileno(stdin));
		if (!isatty(fileno(stdout)))
			set_nonblock(fileno(stdout));
		if (!isatty(fileno(stderr)))
			set_nonblock(fileno(stderr));
		max_fd = MAXIMUM(max_fd, fileno(stdin));
		max_fd = MAXIMUM(max_fd, fileno(stdout));
		max_fd = MAXIMUM(max_fd, fileno(stderr));
	}
	quit_pending = 0;
	escape_char1 = escape_char_arg;

	/* Initialize buffers. */
	buffer_init(&stdin_buffer);
	buffer_init(&stdout_buffer);
	buffer_init(&stderr_buffer);

	client_init_dispatch();

	/*
	 * Set signal handlers, (e.g. to restore non-blocking mode)
	 * but don't overwrite SIG_IGN, matches behaviour from rsh(1)
	 */
	if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
		signal(SIGHUP, signal_handler);
	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		signal(SIGINT, signal_handler);
	if (signal(SIGQUIT, SIG_IGN) != SIG_IGN)
		signal(SIGQUIT, signal_handler);
	if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
		signal(SIGTERM, signal_handler);
	signal(SIGWINCH, window_change_handler);

	if (have_pty)
		enter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);

	if (compat20) {
		session_ident = ssh2_chan_id;
		if (session_ident != -1) {
			if (escape_char_arg != SSH_ESCAPECHAR_NONE) {
				channel_register_filter(session_ident,
				    client_simple_escape_filter, NULL,
				    client_filter_cleanup,
				    client_new_escape_filter_ctx(
				    escape_char_arg));
			}
			channel_register_cleanup(session_ident,
			    client_channel_closed, 0);
		}
	} else {
		/* Check if we should immediately send eof on stdin. */
		client_check_initial_eof_on_stdin();
	}

	/* Main loop of the client for the interactive session mode. */
	while (!quit_pending) {

		/* Process buffered packets sent by the server. */
		client_process_buffered_input_packets();

		if (compat20 && session_closed && !channel_still_open())
			break;

		if (ssh_packet_is_rekeying(active_state)) {
			debug("rekeying in progress");
		} else if (need_rekeying) {
			/* manual rekey request */
			debug("need rekeying");
			if ((r = kex_start_rekex(active_state)) != 0)
				fatal("%s: kex_start_rekex: %s", __func__,
				    ssh_err(r));
			need_rekeying = 0;
		} else {
			/*
			 * Make packets of buffered stdin data, and buffer
			 * them for sending to the server.
			 */
			if (!compat20)
				client_make_packets_from_stdin_data();

			/*
			 * Make packets from buffered channel data, and
			 * enqueue them for sending to the server.
			 */
			if (packet_not_very_much_data_to_write())
				channel_output_poll();

			/*
			 * Check if the window size has changed, and buffer a
			 * message about it to the server if so.
			 */
			client_check_window_change();

			if (quit_pending)
				break;
		}
		/*
		 * Wait until we have something to do (something becomes
		 * available on one of the descriptors).
		 */
		max_fd2 = max_fd;
		client_wait_until_can_do_something(&readset, &writeset,
		    &max_fd2, &nalloc, ssh_packet_is_rekeying(active_state));

		if (quit_pending)
			break;

		/* Do channel operations unless rekeying in progress. */
		if (!ssh_packet_is_rekeying(active_state))
			channel_after_select(readset, writeset);

		/* Buffer input from the connection.  */
		client_process_net_input(readset);

		if (quit_pending)
			break;

		if (!compat20) {
			/* Buffer data from stdin */
			client_process_input(readset);
			/*
			 * Process output to stdout and stderr.  Output to
			 * the connection is processed elsewhere (above).
			 */
			client_process_output(writeset);
		}

		/*
		 * Send as much buffered packet data as possible to the
		 * sender.
		 */
		if (FD_ISSET(connection_out, writeset))
			packet_write_poll();

		/*
		 * If we are a backgrounded control master, and the
		 * timeout has expired without any active client
		 * connections, then quit.
		 */
		if (control_persist_exit_time > 0) {
			if (monotime() >= control_persist_exit_time) {
				debug("ControlPersist timeout expired");
				break;
			}
		}
	}
	free(readset);
	free(writeset);

	/* Terminate the session. */

	/* Stop watching for window change. */
	signal(SIGWINCH, SIG_DFL);

	if (compat20) {
		packet_start(SSH2_MSG_DISCONNECT);
		packet_put_int(SSH2_DISCONNECT_BY_APPLICATION);
		packet_put_cstring("disconnected by user");
		packet_put_cstring(""); /* language tag */
		packet_send();
		packet_write_wait();
	}

	channel_free_all();

	if (have_pty)
		leave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);

	/* restore blocking io */
	if (!isatty(fileno(stdin)))
		unset_nonblock(fileno(stdin));
	if (!isatty(fileno(stdout)))
		unset_nonblock(fileno(stdout));
	if (!isatty(fileno(stderr)))
		unset_nonblock(fileno(stderr));

	/*
	 * If there was no shell or command requested, there will be no remote
	 * exit status to be returned.  In that case, clear error code if the
	 * connection was deliberately terminated at this end.
	 */
	if (no_shell_flag && received_signal == SIGTERM) {
		received_signal = 0;
		exit_status = 0;
	}

	if (received_signal)
		fatal("Killed by signal %d.", (int) received_signal);

	/*
	 * In interactive mode (with pseudo tty) display a message indicating
	 * that the connection has been closed.
	 */
	if (have_pty && options.log_level != SYSLOG_LEVEL_QUIET) {
		snprintf(buf, sizeof buf,
		    "Connection to %.64s closed.\r\n", host);
		buffer_append(&stderr_buffer, buf, strlen(buf));
	}

	/* Output any buffered data for stdout. */
	if (buffer_len(&stdout_buffer) > 0) {
		len = atomicio(vwrite, fileno(stdout),
		    buffer_ptr(&stdout_buffer), buffer_len(&stdout_buffer));
		if (len < 0 || (u_int)len != buffer_len(&stdout_buffer))
			error("Write failed flushing stdout buffer.");
		else
			buffer_consume(&stdout_buffer, len);
	}

	/* Output any buffered data for stderr. */
	if (buffer_len(&stderr_buffer) > 0) {
		len = atomicio(vwrite, fileno(stderr),
		    buffer_ptr(&stderr_buffer), buffer_len(&stderr_buffer));
		if (len < 0 || (u_int)len != buffer_len(&stderr_buffer))
			error("Write failed flushing stderr buffer.");
		else
			buffer_consume(&stderr_buffer, len);
	}

	/* Clear and free any buffers. */
	explicit_bzero(buf, sizeof(buf));
	buffer_free(&stdin_buffer);
	buffer_free(&stdout_buffer);
	buffer_free(&stderr_buffer);

	/* Report bytes transferred, and transfer rates. */
	total_time = get_current_time() - start_time;
	packet_get_bytes(&ibytes, &obytes);
	verbose("Transferred: sent %llu, received %llu bytes, in %.1f seconds",
	    (unsigned long long)obytes, (unsigned long long)ibytes, total_time);
	if (total_time > 0)
		verbose("Bytes per second: sent %.1f, received %.1f",
		    obytes / total_time, ibytes / total_time);
	/* Return the exit status of the program. */
	debug("Exit status %d", exit_status);
	return exit_status;
}

/*********/

static int
client_input_stdout_data(int type, u_int32_t seq, void *ctxt)
{
	u_int data_len;
	char *data = packet_get_string(&data_len);
	packet_check_eom();
	buffer_append(&stdout_buffer, data, data_len);
	explicit_bzero(data, data_len);
	free(data);
	return 0;
}
static int
client_input_stderr_data(int type, u_int32_t seq, void *ctxt)
{
	u_int data_len;
	char *data = packet_get_string(&data_len);
	packet_check_eom();
	buffer_append(&stderr_buffer, data, data_len);
	explicit_bzero(data, data_len);
	free(data);
	return 0;
}
static int
client_input_exit_status(int type, u_int32_t seq, void *ctxt)
{
	exit_status = packet_get_int();
	packet_check_eom();
	/* Acknowledge the exit. */
	packet_start(SSH_CMSG_EXIT_CONFIRMATION);
	packet_send();
	/*
	 * Must wait for packet to be sent since we are
	 * exiting the loop.
	 */
	packet_write_wait();
	/* Flag that we want to exit. */
	quit_pending = 1;
	return 0;
}

static int
client_input_agent_open(int type, u_int32_t seq, void *ctxt)
{
	Channel *c = NULL;
	int r, remote_id, sock;

	/* Read the remote channel number from the message. */
	remote_id = packet_get_int();
	packet_check_eom();

	/*
	 * Get a connection to the local authentication agent (this may again
	 * get forwarded).
	 */
	if ((r = ssh_get_authentication_socket(&sock)) != 0 &&
	    r != SSH_ERR_AGENT_NOT_PRESENT)
		debug("%s: ssh_get_authentication_socket: %s",
		    __func__, ssh_err(r));


	/*
	 * If we could not connect the agent, send an error message back to
	 * the server. This should never happen unless the agent dies,
	 * because authentication forwarding is only enabled if we have an
	 * agent.
	 */
	if (sock >= 0) {
		c = channel_new("", SSH_CHANNEL_OPEN, sock, sock,
		    -1, 0, 0, 0, "authentication agent connection", 1);
		c->remote_id = remote_id;
		c->force_drain = 1;
	}
	if (c == NULL) {
		packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(remote_id);
	} else {
		/* Send a confirmation to the remote host. */
		debug("Forwarding authentication connection.");
		packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
		packet_put_int(remote_id);
		packet_put_int(c->self);
	}
	packet_send();
	return 0;
}

static Channel *
client_request_forwarded_tcpip(const char *request_type, int rchan,
    u_int rwindow, u_int rmaxpack)
{
	Channel *c = NULL;
	struct sshbuf *b = NULL;
	char *listen_address, *originator_address;
	u_short listen_port, originator_port;
	int r;

	/* Get rest of the packet */
	listen_address = packet_get_string(NULL);
	listen_port = packet_get_int();
	originator_address = packet_get_string(NULL);
	originator_port = packet_get_int();
	packet_check_eom();

	debug("%s: listen %s port %d, originator %s port %d", __func__,
	    listen_address, listen_port, originator_address, originator_port);

	c = channel_connect_by_listen_address(listen_address, listen_port,
	    "forwarded-tcpip", originator_address);

	if (c != NULL && c->type == SSH_CHANNEL_MUX_CLIENT) {
		if ((b = sshbuf_new()) == NULL) {
			error("%s: alloc reply", __func__);
			goto out;
		}
		/* reconstruct and send to muxclient */
		if ((r = sshbuf_put_u8(b, 0)) != 0 ||	/* padlen */
		    (r = sshbuf_put_u8(b, SSH2_MSG_CHANNEL_OPEN)) != 0 ||
		    (r = sshbuf_put_cstring(b, request_type)) != 0 ||
		    (r = sshbuf_put_u32(b, rchan)) != 0 ||
		    (r = sshbuf_put_u32(b, rwindow)) != 0 ||
		    (r = sshbuf_put_u32(b, rmaxpack)) != 0 ||
		    (r = sshbuf_put_cstring(b, listen_address)) != 0 ||
		    (r = sshbuf_put_u32(b, listen_port)) != 0 ||
		    (r = sshbuf_put_cstring(b, originator_address)) != 0 ||
		    (r = sshbuf_put_u32(b, originator_port)) != 0 ||
		    (r = sshbuf_put_stringb(&c->output, b)) != 0) {
			error("%s: compose for muxclient %s", __func__,
			    ssh_err(r));
			goto out;
		}
	}

 out:
	sshbuf_free(b);
	free(originator_address);
	free(listen_address);
	return c;
}

static Channel *
client_request_forwarded_streamlocal(const char *request_type, int rchan)
{
	Channel *c = NULL;
	char *listen_path;

	/* Get the remote path. */
	listen_path = packet_get_string(NULL);
	/* XXX: Skip reserved field for now. */
	if (packet_get_string_ptr(NULL) == NULL)
		fatal("%s: packet_get_string_ptr failed", __func__);
	packet_check_eom();

	debug("%s: %s", __func__, listen_path);

	c = channel_connect_by_listen_path(listen_path,
	    "forwarded-streamlocal@@openssh.com", "forwarded-streamlocal");
	free(listen_path);
	return c;
}

static Channel *
client_request_x11(const char *request_type, int rchan)
{
	Channel *c = NULL;
	char *originator;
	u_short originator_port;
	int sock;

	if (!options.forward_x11) {
		error("Warning: ssh server tried X11 forwarding.");
		error("Warning: this is probably a break-in attempt by a "
		    "malicious server.");
		return NULL;
	}
	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
		verbose("Rejected X11 connection after ForwardX11Timeout "
		    "expired");
		return NULL;
	}
	originator = packet_get_string(NULL);
	if (datafellows & SSH_BUG_X11FWD) {
		debug2("buggy server: x11 request w/o originator_port");
		originator_port = 0;
	} else {
		originator_port = packet_get_int();
	}
	packet_check_eom();
	/* XXX check permission */
	debug("client_request_x11: request from %s %d", originator,
	    originator_port);
	free(originator);
	sock = x11_connect_display();
	if (sock < 0)
		return NULL;
	c = channel_new("x11",
	    SSH_CHANNEL_X11_OPEN, sock, sock, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0, "x11", 1);
	c->force_drain = 1;
	return c;
}

static Channel *
client_request_agent(const char *request_type, int rchan)
{
	Channel *c = NULL;
	int r, sock;

	if (!options.forward_agent) {
		error("Warning: ssh server tried agent forwarding.");
		error("Warning: this is probably a break-in attempt by a "
		    "malicious server.");
		return NULL;
	}
	if ((r = ssh_get_authentication_socket(&sock)) != 0) {
		if (r != SSH_ERR_AGENT_NOT_PRESENT)
			debug("%s: ssh_get_authentication_socket: %s",
			    __func__, ssh_err(r));
		return NULL;
	}
	c = channel_new("authentication agent connection",
	    SSH_CHANNEL_OPEN, sock, sock, -1,
	    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0,
	    "authentication agent connection", 1);
	c->force_drain = 1;
	return c;
}

int
client_request_tun_fwd(int tun_mode, int local_tun, int remote_tun)
{
	Channel *c;
	int fd;

	if (tun_mode == SSH_TUNMODE_NO)
		return 0;

	if (!compat20) {
		error("Tunnel forwarding is not supported for protocol 1");
		return -1;
	}

	debug("Requesting tun unit %d in mode %d", local_tun, tun_mode);

	/* Open local tunnel device */
	if ((fd = tun_open(local_tun, tun_mode)) == -1) {
		error("Tunnel device open failed.");
		return -1;
	}

	c = channel_new("tun", SSH_CHANNEL_OPENING, fd, fd, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, "tun", 1);
	c->datagram = 1;

	packet_start(SSH2_MSG_CHANNEL_OPEN);
	packet_put_cstring("tun@@openssh.com");
	packet_put_int(c->self);
	packet_put_int(c->local_window_max);
	packet_put_int(c->local_maxpacket);
	packet_put_int(tun_mode);
	packet_put_int(remote_tun);
	packet_send();

	return 0;
}

/* XXXX move to generic input handler */
static int
client_input_channel_open(int type, u_int32_t seq, void *ctxt)
{
	Channel *c = NULL;
	char *ctype;
	int rchan;
	u_int rmaxpack, rwindow, len;

	ctype = packet_get_string(&len);
	rchan = packet_get_int();
	rwindow = packet_get_int();
	rmaxpack = packet_get_int();

	debug("client_input_channel_open: ctype %s rchan %d win %d max %d",
	    ctype, rchan, rwindow, rmaxpack);

	if (strcmp(ctype, "forwarded-tcpip") == 0) {
		c = client_request_forwarded_tcpip(ctype, rchan, rwindow,
		    rmaxpack);
	} else if (strcmp(ctype, "forwarded-streamlocal@@openssh.com") == 0) {
		c = client_request_forwarded_streamlocal(ctype, rchan);
	} else if (strcmp(ctype, "x11") == 0) {
		c = client_request_x11(ctype, rchan);
	} else if (strcmp(ctype, "auth-agent@@openssh.com") == 0) {
		c = client_request_agent(ctype, rchan);
	}
	if (c != NULL && c->type == SSH_CHANNEL_MUX_CLIENT) {
		debug3("proxied to downstream: %s", ctype);
	} else if (c != NULL) {
		debug("confirm %s", ctype);
		c->remote_id = rchan;
		c->remote_window = rwindow;
		c->remote_maxpacket = rmaxpack;
		if (c->type != SSH_CHANNEL_CONNECTING) {
			packet_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);
			packet_put_int(c->remote_id);
			packet_put_int(c->self);
			packet_put_int(c->local_window);
			packet_put_int(c->local_maxpacket);
			packet_send();
		}
	} else {
		debug("failure %s", ctype);
		packet_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(rchan);
		packet_put_int(SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED);
		if (!(datafellows & SSH_BUG_OPENFAILURE)) {
			packet_put_cstring("open failed");
			packet_put_cstring("");
		}
		packet_send();
	}
	free(ctype);
	return 0;
}

static int
client_input_channel_req(int type, u_int32_t seq, void *ctxt)
{
	Channel *c = NULL;
	int exitval, id, reply, success = 0;
	char *rtype;

	id = packet_get_int();
	c = channel_lookup(id);
	if (channel_proxy_upstream(c, type, seq, ctxt))
		return 0;
	rtype = packet_get_string(NULL);
	reply = packet_get_char();

	debug("client_input_channel_req: channel %d rtype %s reply %d",
	    id, rtype, reply);

	if (id == -1) {
		error("client_input_channel_req: request for channel -1");
	} else if (c == NULL) {
		error("client_input_channel_req: channel %d: "
		    "unknown channel", id);
	} else if (strcmp(rtype, "eow@@openssh.com") == 0) {
		packet_check_eom();
		chan_rcvd_eow(c);
	} else if (strcmp(rtype, "exit-status") == 0) {
		exitval = packet_get_int();
		if (c->ctl_chan != -1) {
			mux_exit_message(c, exitval);
			success = 1;
		} else if (id == session_ident) {
			/* Record exit value of local session */
			success = 1;
			exit_status = exitval;
		} else {
			/* Probably for a mux channel that has already closed */
			debug("%s: no sink for exit-status on channel %d",
			    __func__, id);
		}
		packet_check_eom();
	}
	if (reply && c != NULL && !(c->flags & CHAN_CLOSE_SENT)) {
		packet_start(success ?
		    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);
		packet_put_int(c->remote_id);
		packet_send();
	}
	free(rtype);
	return 0;
}

struct hostkeys_update_ctx {
	/* The hostname and (optionally) IP address string for the server */
	char *host_str, *ip_str;

	/*
	 * Keys received from the server and a flag for each indicating
	 * whether they already exist in known_hosts.
	 * keys_seen is filled in by hostkeys_find() and later (for new
	 * keys) by client_global_hostkeys_private_confirm().
	 */
	struct sshkey **keys;
	int *keys_seen;
	size_t nkeys;

	size_t nnew;

	/*
	 * Keys that are in known_hosts, but were not present in the update
	 * from the server (i.e. scheduled to be deleted).
	 * Filled in by hostkeys_find().
	 */
	struct sshkey **old_keys;
	size_t nold;
};

static void
hostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)
{
	size_t i;

	if (ctx == NULL)
		return;
	for (i = 0; i < ctx->nkeys; i++)
		sshkey_free(ctx->keys[i]);
	free(ctx->keys);
	free(ctx->keys_seen);
	for (i = 0; i < ctx->nold; i++)
		sshkey_free(ctx->old_keys[i]);
	free(ctx->old_keys);
	free(ctx->host_str);
	free(ctx->ip_str);
	free(ctx);
}

static int
hostkeys_find(struct hostkey_foreach_line *l, void *_ctx)
{
	struct hostkeys_update_ctx *ctx = (struct hostkeys_update_ctx *)_ctx;
	size_t i;
	struct sshkey **tmp;

	if (l->status != HKF_STATUS_MATCHED || l->key == NULL ||
	    l->key->type == KEY_RSA1)
		return 0;

	/* Mark off keys we've already seen for this host */
	for (i = 0; i < ctx->nkeys; i++) {
		if (sshkey_equal(l->key, ctx->keys[i])) {
			debug3("%s: found %s key at %s:%ld", __func__,
			    sshkey_ssh_name(ctx->keys[i]), l->path, l->linenum);
			ctx->keys_seen[i] = 1;
			return 0;
		}
	}
	/* This line contained a key that not offered by the server */
	debug3("%s: deprecated %s key at %s:%ld", __func__,
	    sshkey_ssh_name(l->key), l->path, l->linenum);
	if ((tmp = reallocarray(ctx->old_keys, ctx->nold + 1,
	    sizeof(*ctx->old_keys))) == NULL)
		fatal("%s: reallocarray failed nold = %zu",
		    __func__, ctx->nold);
	ctx->old_keys = tmp;
	ctx->old_keys[ctx->nold++] = l->key;
	l->key = NULL;

	return 0;
}

static void
update_known_hosts(struct hostkeys_update_ctx *ctx)
{
	int r, was_raw = 0;
	int loglevel = options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK ?
	    SYSLOG_LEVEL_INFO : SYSLOG_LEVEL_VERBOSE;
	char *fp, *response;
	size_t i;

	for (i = 0; i < ctx->nkeys; i++) {
		if (ctx->keys_seen[i] != 2)
			continue;
		if ((fp = sshkey_fingerprint(ctx->keys[i],
		    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)
			fatal("%s: sshkey_fingerprint failed", __func__);
		do_log2(loglevel, "Learned new hostkey: %s %s",
		    sshkey_type(ctx->keys[i]), fp);
		free(fp);
	}
	for (i = 0; i < ctx->nold; i++) {
		if ((fp = sshkey_fingerprint(ctx->old_keys[i],
		    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)
			fatal("%s: sshkey_fingerprint failed", __func__);
		do_log2(loglevel, "Deprecating obsolete hostkey: %s %s",
		    sshkey_type(ctx->old_keys[i]), fp);
		free(fp);
	}
	if (options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK) {
		if (get_saved_tio() != NULL) {
			leave_raw_mode(1);
			was_raw = 1;
		}
		response = NULL;
		for (i = 0; !quit_pending && i < 3; i++) {
			free(response);
			response = read_passphrase("Accept updated hostkeys? "
			    "(yes/no): ", RP_ECHO);
			if (strcasecmp(response, "yes") == 0)
				break;
			else if (quit_pending || response == NULL ||
			    strcasecmp(response, "no") == 0) {
				options.update_hostkeys = 0;
				break;
			} else {
				do_log2(loglevel, "Please enter "
				    "\"yes\" or \"no\"");
			}
		}
		if (quit_pending || i >= 3 || response == NULL)
			options.update_hostkeys = 0;
		free(response);
		if (was_raw)
			enter_raw_mode(1);
	}

	/*
	 * Now that all the keys are verified, we can go ahead and replace
	 * them in known_hosts (assuming SSH_UPDATE_HOSTKEYS_ASK didn't
	 * cancel the operation).
	 */
	if (options.update_hostkeys != 0 &&
	    (r = hostfile_replace_entries(options.user_hostfiles[0],
	    ctx->host_str, ctx->ip_str, ctx->keys, ctx->nkeys,
	    options.hash_known_hosts, 0,
	    options.fingerprint_hash)) != 0)
		error("%s: hostfile_replace_entries failed: %s",
		    __func__, ssh_err(r));
}

static void
client_global_hostkeys_private_confirm(int type, u_int32_t seq, void *_ctx)
{
	struct ssh *ssh = active_state; /* XXX */
	struct hostkeys_update_ctx *ctx = (struct hostkeys_update_ctx *)_ctx;
	size_t i, ndone;
	struct sshbuf *signdata;
	int r;
	const u_char *sig;
	size_t siglen;

	if (ctx->nnew == 0)
		fatal("%s: ctx->nnew == 0", __func__); /* sanity */
	if (type != SSH2_MSG_REQUEST_SUCCESS) {
		error("Server failed to confirm ownership of "
		    "private host keys");
		hostkeys_update_ctx_free(ctx);
		return;
	}
	if ((signdata = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	/* Don't want to accidentally accept an unbound signature */
	if (ssh->kex->session_id_len == 0)
		fatal("%s: ssh->kex->session_id_len == 0", __func__);
	/*
	 * Expect a signature for each of the ctx->nnew private keys we
	 * haven't seen before. They will be in the same order as the
	 * ctx->keys where the corresponding ctx->keys_seen[i] == 0.
	 */
	for (ndone = i = 0; i < ctx->nkeys; i++) {
		if (ctx->keys_seen[i])
			continue;
		/* Prepare data to be signed: session ID, unique string, key */
		sshbuf_reset(signdata);
		if ( (r = sshbuf_put_cstring(signdata,
		    "hostkeys-prove-00@@openssh.com")) != 0 ||
		    (r = sshbuf_put_string(signdata, ssh->kex->session_id,
		    ssh->kex->session_id_len)) != 0 ||
		    (r = sshkey_puts(ctx->keys[i], signdata)) != 0)
			fatal("%s: failed to prepare signature: %s",
			    __func__, ssh_err(r));
		/* Extract and verify signature */
		if ((r = sshpkt_get_string_direct(ssh, &sig, &siglen)) != 0) {
			error("%s: couldn't parse message: %s",
			    __func__, ssh_err(r));
			goto out;
		}
		if ((r = sshkey_verify(ctx->keys[i], sig, siglen,
		    sshbuf_ptr(signdata), sshbuf_len(signdata), 0)) != 0) {
			error("%s: server gave bad signature for %s key %zu",
			    __func__, sshkey_type(ctx->keys[i]), i);
			goto out;
		}
		/* Key is good. Mark it as 'seen' */
		ctx->keys_seen[i] = 2;
		ndone++;
	}
	if (ndone != ctx->nnew)
		fatal("%s: ndone != ctx->nnew (%zu / %zu)", __func__,
		    ndone, ctx->nnew);  /* Shouldn't happen */
	ssh_packet_check_eom(ssh);

	/* Make the edits to known_hosts */
	update_known_hosts(ctx);
 out:
	hostkeys_update_ctx_free(ctx);
}

/*
 * Returns non-zero if the key is accepted by HostkeyAlgorithms.
 * Made slightly less trivial by the multiple RSA signature algorithm names.
 */
static int
key_accepted_by_hostkeyalgs(const struct sshkey *key)
{
	const char *ktype = sshkey_ssh_name(key);
	const char *hostkeyalgs = options.hostkeyalgorithms != NULL ?
	    options.hostkeyalgorithms : KEX_DEFAULT_PK_ALG;

	if (key == NULL || key->type == KEY_UNSPEC)
		return 0;
	if (key->type == KEY_RSA &&
	    (match_pattern_list("rsa-sha2-256", hostkeyalgs, 0) == 1 ||
	    match_pattern_list("rsa-sha2-512", hostkeyalgs, 0) == 1))
		return 1;
	return match_pattern_list(ktype, hostkeyalgs, 0) == 1;
}

/*
 * Handle hostkeys-00@@openssh.com global request to inform the client of all
 * the server's hostkeys. The keys are checked against the user's
 * HostkeyAlgorithms preference before they are accepted.
 */
static int
client_input_hostkeys(void)
{
	struct ssh *ssh = active_state; /* XXX */
	const u_char *blob = NULL;
	size_t i, len = 0;
	struct sshbuf *buf = NULL;
	struct sshkey *key = NULL, **tmp;
	int r;
	char *fp;
	static int hostkeys_seen = 0; /* XXX use struct ssh */
	extern struct sockaddr_storage hostaddr; /* XXX from ssh.c */
	struct hostkeys_update_ctx *ctx = NULL;

	if (hostkeys_seen)
		fatal("%s: server already sent hostkeys", __func__);
	if (options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK &&
	    options.batch_mode)
		return 1; /* won't ask in batchmode, so don't even try */
	if (!options.update_hostkeys || options.num_user_hostfiles <= 0)
		return 1;

	ctx = xcalloc(1, sizeof(*ctx));
	while (ssh_packet_remaining(ssh) > 0) {
		sshkey_free(key);
		key = NULL;
		if ((r = sshpkt_get_string_direct(ssh, &blob, &len)) != 0) {
			error("%s: couldn't parse message: %s",
			    __func__, ssh_err(r));
			goto out;
		}
		if ((r = sshkey_from_blob(blob, len, &key)) != 0) {
			error("%s: parse key: %s", __func__, ssh_err(r));
			goto out;
		}
		fp = sshkey_fingerprint(key, options.fingerprint_hash,
		    SSH_FP_DEFAULT);
		debug3("%s: received %s key %s", __func__,
		    sshkey_type(key), fp);
		free(fp);

		if (!key_accepted_by_hostkeyalgs(key)) {
			debug3("%s: %s key not permitted by HostkeyAlgorithms",
			    __func__, sshkey_ssh_name(key));
			continue;
		}
		/* Skip certs */
		if (sshkey_is_cert(key)) {
			debug3("%s: %s key is a certificate; skipping",
			    __func__, sshkey_ssh_name(key));
			continue;
		}
		/* Ensure keys are unique */
		for (i = 0; i < ctx->nkeys; i++) {
			if (sshkey_equal(key, ctx->keys[i])) {
				error("%s: received duplicated %s host key",
				    __func__, sshkey_ssh_name(key));
				goto out;
			}
		}
		/* Key is good, record it */
		if ((tmp = reallocarray(ctx->keys, ctx->nkeys + 1,
		    sizeof(*ctx->keys))) == NULL)
			fatal("%s: reallocarray failed nkeys = %zu",
			    __func__, ctx->nkeys);
		ctx->keys = tmp;
		ctx->keys[ctx->nkeys++] = key;
		key = NULL;
	}

	if (ctx->nkeys == 0) {
		debug("%s: server sent no hostkeys", __func__);
		goto out;
	}

	if ((ctx->keys_seen = calloc(ctx->nkeys,
	    sizeof(*ctx->keys_seen))) == NULL)
		fatal("%s: calloc failed", __func__);

	get_hostfile_hostname_ipaddr(host,
	    options.check_host_ip ? (struct sockaddr *)&hostaddr : NULL,
	    options.port, &ctx->host_str,
	    options.check_host_ip ? &ctx->ip_str : NULL);

	/* Find which keys we already know about. */
	if ((r = hostkeys_foreach(options.user_hostfiles[0], hostkeys_find,
	    ctx, ctx->host_str, ctx->ip_str,
	    HKF_WANT_PARSE_KEY|HKF_WANT_MATCH)) != 0) {
		error("%s: hostkeys_foreach failed: %s", __func__, ssh_err(r));
		goto out;
	}

	/* Figure out if we have any new keys to add */
	ctx->nnew = 0;
	for (i = 0; i < ctx->nkeys; i++) {
		if (!ctx->keys_seen[i])
			ctx->nnew++;
	}

	debug3("%s: %zu keys from server: %zu new, %zu retained. %zu to remove",
	    __func__, ctx->nkeys, ctx->nnew, ctx->nkeys - ctx->nnew, ctx->nold);

	if (ctx->nnew == 0 && ctx->nold != 0) {
		/* We have some keys to remove. Just do it. */
		update_known_hosts(ctx);
	} else if (ctx->nnew != 0) {
		/*
		 * We have received hitherto-unseen keys from the server.
		 * Ask the server to confirm ownership of the private halves.
		 */
		debug3("%s: asking server to prove ownership for %zu keys",
		    __func__, ctx->nnew);
		if ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||
		    (r = sshpkt_put_cstring(ssh,
		    "hostkeys-prove-00@@openssh.com")) != 0 ||
		    (r = sshpkt_put_u8(ssh, 1)) != 0) /* bool: want reply */
			fatal("%s: cannot prepare packet: %s",
			    __func__, ssh_err(r));
		if ((buf = sshbuf_new()) == NULL)
			fatal("%s: sshbuf_new", __func__);
		for (i = 0; i < ctx->nkeys; i++) {
			if (ctx->keys_seen[i])
				continue;
			sshbuf_reset(buf);
			if ((r = sshkey_putb(ctx->keys[i], buf)) != 0)
				fatal("%s: sshkey_putb: %s",
				    __func__, ssh_err(r));
			if ((r = sshpkt_put_stringb(ssh, buf)) != 0)
				fatal("%s: sshpkt_put_string: %s",
				    __func__, ssh_err(r));
		}
		if ((r = sshpkt_send(ssh)) != 0)
			fatal("%s: sshpkt_send: %s", __func__, ssh_err(r));
		client_register_global_confirm(
		    client_global_hostkeys_private_confirm, ctx);
		ctx = NULL;  /* will be freed in callback */
	}

	/* Success */
 out:
	hostkeys_update_ctx_free(ctx);
	sshkey_free(key);
	sshbuf_free(buf);
	/*
	 * NB. Return success for all cases. The server doesn't need to know
	 * what the client does with its hosts file.
	 */
	return 1;
}

static int
client_input_global_request(int type, u_int32_t seq, void *ctxt)
{
	char *rtype;
	int want_reply;
	int success = 0;

	rtype = packet_get_cstring(NULL);
	want_reply = packet_get_char();
	debug("client_input_global_request: rtype %s want_reply %d",
	    rtype, want_reply);
	if (strcmp(rtype, "hostkeys-00@@openssh.com") == 0)
		success = client_input_hostkeys();
	if (want_reply) {
		packet_start(success ?
		    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);
		packet_send();
		packet_write_wait();
	}
	free(rtype);
	return 0;
}

void
client_session2_setup(int id, int want_tty, int want_subsystem,
    const char *term, struct termios *tiop, int in_fd, Buffer *cmd, char **env)
{
	int len;
	Channel *c = NULL;

	debug2("%s: id %d", __func__, id);

	if ((c = channel_lookup(id)) == NULL)
		fatal("client_session2_setup: channel %d: unknown channel", id);

	packet_set_interactive(want_tty,
	    options.ip_qos_interactive, options.ip_qos_bulk);

	if (want_tty) {
		struct winsize ws;

		/* Store window size in the packet. */
		if (ioctl(in_fd, TIOCGWINSZ, &ws) < 0)
			memset(&ws, 0, sizeof(ws));

		channel_request_start(id, "pty-req", 1);
		client_expect_confirm(id, "PTY allocation", CONFIRM_TTY);
		packet_put_cstring(term != NULL ? term : "");
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
		if (tiop == NULL)
			tiop = get_saved_tio();
		tty_make_modes(-1, tiop);
		packet_send();
		/* XXX wait for reply */
		c->client_tty = 1;
	}

	/* Transfer any environment variables from client to server */
	if (options.num_send_env != 0 && env != NULL) {
		int i, j, matched;
		char *name, *val;

		debug("Sending environment.");
		for (i = 0; env[i] != NULL; i++) {
			/* Split */
			name = xstrdup(env[i]);
			if ((val = strchr(name, '=')) == NULL) {
				free(name);
				continue;
			}
			*val++ = '\0';

			matched = 0;
			for (j = 0; j < options.num_send_env; j++) {
				if (match_pattern(name, options.send_env[j])) {
					matched = 1;
					break;
				}
			}
			if (!matched) {
				debug3("Ignored env %s", name);
				free(name);
				continue;
			}

			debug("Sending env %s = %s", name, val);
			channel_request_start(id, "env", 0);
			packet_put_cstring(name);
			packet_put_cstring(val);
			packet_send();
			free(name);
		}
	}

	len = buffer_len(cmd);
	if (len > 0) {
		if (len > 900)
			len = 900;
		if (want_subsystem) {
			debug("Sending subsystem: %.*s",
			    len, (u_char*)buffer_ptr(cmd));
			channel_request_start(id, "subsystem", 1);
			client_expect_confirm(id, "subsystem", CONFIRM_CLOSE);
		} else {
			debug("Sending command: %.*s",
			    len, (u_char*)buffer_ptr(cmd));
			channel_request_start(id, "exec", 1);
			client_expect_confirm(id, "exec", CONFIRM_CLOSE);
		}
		packet_put_string(buffer_ptr(cmd), buffer_len(cmd));
		packet_send();
	} else {
		channel_request_start(id, "shell", 1);
		client_expect_confirm(id, "shell", CONFIRM_CLOSE);
		packet_send();
	}
}

static void
client_init_dispatch_20(void)
{
	dispatch_init(&dispatch_protocol_error);

	dispatch_set(SSH2_MSG_CHANNEL_CLOSE, &channel_input_oclose);
	dispatch_set(SSH2_MSG_CHANNEL_DATA, &channel_input_data);
	dispatch_set(SSH2_MSG_CHANNEL_EOF, &channel_input_ieof);
	dispatch_set(SSH2_MSG_CHANNEL_EXTENDED_DATA, &channel_input_extended_data);
	dispatch_set(SSH2_MSG_CHANNEL_OPEN, &client_input_channel_open);
	dispatch_set(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);
	dispatch_set(SSH2_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);
	dispatch_set(SSH2_MSG_CHANNEL_REQUEST, &client_input_channel_req);
	dispatch_set(SSH2_MSG_CHANNEL_WINDOW_ADJUST, &channel_input_window_adjust);
	dispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &channel_input_status_confirm);
	dispatch_set(SSH2_MSG_CHANNEL_FAILURE, &channel_input_status_confirm);
	dispatch_set(SSH2_MSG_GLOBAL_REQUEST, &client_input_global_request);

	/* rekeying */
	dispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);

	/* global request reply messages */
	dispatch_set(SSH2_MSG_REQUEST_FAILURE, &client_global_request_reply);
	dispatch_set(SSH2_MSG_REQUEST_SUCCESS, &client_global_request_reply);
}

static void
client_init_dispatch_13(void)
{
	dispatch_init(NULL);
	dispatch_set(SSH_MSG_CHANNEL_CLOSE, &channel_input_close);
	dispatch_set(SSH_MSG_CHANNEL_CLOSE_CONFIRMATION, &channel_input_close_confirmation);
	dispatch_set(SSH_MSG_CHANNEL_DATA, &channel_input_data);
	dispatch_set(SSH_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);
	dispatch_set(SSH_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);
	dispatch_set(SSH_MSG_PORT_OPEN, &channel_input_port_open);
	dispatch_set(SSH_SMSG_EXITSTATUS, &client_input_exit_status);
	dispatch_set(SSH_SMSG_STDERR_DATA, &client_input_stderr_data);
	dispatch_set(SSH_SMSG_STDOUT_DATA, &client_input_stdout_data);

	dispatch_set(SSH_SMSG_AGENT_OPEN, options.forward_agent ?
	    &client_input_agent_open : &deny_input_open);
	dispatch_set(SSH_SMSG_X11_OPEN, options.forward_x11 ?
	    &x11_input_open : &deny_input_open);
}

static void
client_init_dispatch_15(void)
{
	client_init_dispatch_13();
	dispatch_set(SSH_MSG_CHANNEL_CLOSE, &channel_input_ieof);
	dispatch_set(SSH_MSG_CHANNEL_CLOSE_CONFIRMATION, & channel_input_oclose);
}

static void
client_init_dispatch(void)
{
	if (compat20)
		client_init_dispatch_20();
	else if (compat13)
		client_init_dispatch_13();
	else
		client_init_dispatch_15();
}

void
client_stop_mux(void)
{
	if (options.control_path != NULL && muxserver_sock != -1)
		unlink(options.control_path);
	/*
	 * If we are in persist mode, or don't have a shell, signal that we
	 * should close when all active channels are closed.
	 */
	if (options.control_persist || no_shell_flag) {
		session_closed = 1;
		setproctitle("[stopped mux]");
	}
}

/* client specific fatal cleanup */
void
cleanup_exit(int i)
{
	leave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);
	leave_non_blocking();
	if (options.control_path != NULL && muxserver_sock != -1)
		unlink(options.control_path);
	ssh_kill_proxy_command();
	_exit(i);
}
@


1.290
log
@Fix typo in ~C error message for bad port forward cancellation.
bz#2672, from Brad Marshall via Colin Watson and Ubuntu's bugtracker.
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.289 2016/09/30 09:19:13 markus Exp $ */
d2376 20
d2441 1
a2441 4
		/* Check that the key is accepted in HostkeyAlgorithms */
		if (match_pattern_list(sshkey_ssh_name(key),
		    options.hostkeyalgorithms ? options.hostkeyalgorithms :
		    KEX_DEFAULT_PK_ALG, 0) != 1) {
@


1.289
log
@ssh proxy mux mode (-O proxy; idea from Simon Tatham):
- mux client speaks the ssh-packet protocol directly over unix-domain socket.
- mux server acts as a proxy, translates channel IDs and relays to the server.
- no filedescriptor passing necessary.
- combined with unix-domain forwarding it's even possible to run mux client
  and server on different machines.
feedback & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.288 2016/09/17 18:00:27 tedu Exp $ */
d985 1
a985 1
			logit("Unkown port forwarding.");
@


1.288
log
@replace two arc4random loops with arc4random_buf
ok deraadt natano
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.287 2016/09/12 01:22:38 deraadt Exp $ */
d1874 2
a1875 1
client_request_forwarded_tcpip(const char *request_type, int rchan)
d1878 1
d1881 1
d1896 25
d2070 2
a2071 1
		c = client_request_forwarded_tcpip(ctype, rchan);
d2079 3
a2081 2
/* XXX duplicate : */
	if (c != NULL) {
d2117 3
d2128 1
a2128 1
	} else if ((c = channel_lookup(id)) == NULL) {
@


1.287
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.286 2016/07/23 02:54:08 djm Exp $ */
d306 1
a306 1
	int got_data = 0, generated = 0, do_unlink = 0, i, r;
d433 2
a434 1
		u_int32_t rnd = 0;
d439 2
a440 3
		for (i = 0; i < 16; i++) {
			if (i % 4 == 0)
				rnd = arc4random();
d442 1
a442 2
			    rnd & 0xff);
			rnd >>= 8;
@


1.286
log
@fix pledge violation with ssh -f; reported by Valentin Kozamernik
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.285 2016/07/11 21:38:13 tb Exp $ */
a62 1
#include <sys/param.h>	/* MIN MAX */
d666 1
a666 1
		timeout_secs = MIN(timeout_secs, packet_get_rekey_timeout());
d669 1
a669 1
		timeout_secs = MIN(timeout_secs,
d675 1
a675 1
		timeout_secs = MIN(timeout_secs, (int)minwait_secs);
d1543 1
a1543 1
	max_fd = MAX(connection_in, connection_out);
d1553 3
a1555 3
		max_fd = MAX(max_fd, fileno(stdin));
		max_fd = MAX(max_fd, fileno(stdout));
		max_fd = MAX(max_fd, fileno(stderr));
@


1.285
log
@Add missing "recvfd" pledge promise: Raf Czlonka reported ssh coredumps
when Control* keywords were set in ssh_config. This patch also fixes
similar problems with scp and sftp.

ok deraadt, looks good to millert
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.284 2016/02/08 10:57:07 djm Exp $ */
d118 3
d1504 1
a1504 1
	    ! option_clear_or_none(options.control_path)) {
d1522 2
a1523 1
	} else if (! option_clear_or_none(options.proxy_command)) {
@


1.284
log
@refactor activation of rekeying

This makes automatic rekeying internal to the packet code (previously
the server and client loops needed to assist). In doing to it makes
application of rekey limits more accurate by accounting for packets
about to be sent as well as packets queued during rekeying events
themselves.

Based on a patch from dtucker@@ which was in turn based on a patch
Aleksander Adamowski in bz#2521; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.283 2016/02/01 21:18:17 millert Exp $ */
d1503 1
a1503 1
		if (pledge("stdio rpath wpath cpath unix inet dns proc exec id tty",
@


1.283
log
@Avoid ugly "DISPLAY "(null)" invalid; disabling X11 forwarding"
message when DISPLAY is not set.  This could also result in a crash
on systems with a printf that doesn't handle NULL.  OK djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.282 2016/01/29 23:04:46 dtucker Exp $ */
d1493 1
a1493 1
	int r, max_fd = 0, max_fd2 = 0, len, rekeying = 0;
d1608 1
a1608 3
		rekeying = (active_state->kex != NULL && !active_state->kex->done);

		if (rekeying) {
d1610 7
d1647 1
a1647 1
		    &max_fd2, &nalloc, rekeying);
d1653 1
a1653 1
		if (!rekeying) {
a1654 9
			if (need_rekeying || packet_need_rekeying()) {
				debug("need rekeying");
				active_state->kex->done = 0;
				if ((r = kex_send_kexinit(active_state)) != 0)
					fatal("%s: kex_send_kexinit: %s",
					    __func__, ssh_err(r));
				need_rekeying = 0;
			}
		}
@


1.282
log
@Remove leftover roaming dead code.  ok djm markus.
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.281 2016/01/23 05:31:35 jsg Exp $ */
d313 3
a315 2
		logit("DISPLAY \"%s\" invalid; disabling X11 forwarding",
		    display);
@


1.281
log
@Zero a stack buffer with explicit_bzero() instead of memset() when
returning from client_loop() for consistency with
buffer_free()/sshbuf_free().

ok dtucker@@ deraadt@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.280 2016/01/14 16:17:39 markus Exp $ */
a162 2
int	session_resumed = 0;

a1672 8
		}

		if (session_resumed) {
			connection_in = packet_get_connection_in();
			connection_out = packet_get_connection_out();
			max_fd = MAX(max_fd, connection_out);
			max_fd = MAX(max_fd, connection_in);
			session_resumed = 0;
@


1.280
log
@remove roaming support; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.279 2016/01/13 23:04:47 djm Exp $ */
d1778 1
a1778 1
	memset(buf, 0, sizeof(buf));
@


1.279
log
@eliminate fallback from untrusted X11 forwarding to trusted
forwarding when the X server disables the SECURITY extension;
Reported by Thomas Hoger; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.278 2015/12/26 07:46:03 semarie Exp $ */
a105 1
#include "roaming.h"
d750 1
a750 1
	int len, cont = 0;
d759 2
a760 2
		len = roaming_read(connection_in, buf, sizeof(buf), &cont);
		if (len == 0 && cont == 0) {
@


1.278
log
@adjust pledge promises for ControlMaster: when using "ask" or "autoask", the process will use ssh-askpass for asking confirmation.

problem found by halex@@

ok halex@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.277 2015/12/03 17:00:18 semarie Exp $ */
d283 3
d299 1
a299 1
void
d303 2
a304 3
	char cmd[1024];
	char line[512];
	char xdisplay[512];
d307 1
a307 2
	int got_data = 0, generated = 0, do_unlink = 0, i;
	char xauthdir[PATH_MAX] = "", xauthfile[PATH_MAX] = "";
d313 1
a313 1
	proto[0] = data[0] = '\0';
d315 6
a320 1
	if (xauth_path == NULL ||(stat(xauth_path, &st) == -1)) {
d322 4
a325 8
	} else if (!client_x11_display_valid(display)) {
		logit("DISPLAY '%s' invalid, falling back to fake xauth data",
		    display);
	} else {
		if (display == NULL) {
			debug("x11_get_proto: DISPLAY not set");
			return;
		}
d334 6
a339 2
			snprintf(xdisplay, sizeof(xdisplay), "unix:%s",
			    display + 10);
a342 1
			mktemp_proto(xauthdir, PATH_MAX);
d344 2
d350 16
d370 15
a384 21
			if (mkdtemp(xauthdir) != NULL) {
				do_unlink = 1;
				snprintf(xauthfile, PATH_MAX, "%s/xauthfile",
				    xauthdir);
				snprintf(cmd, sizeof(cmd),
				    "%s -f %s generate %s " SSH_X11_PROTO
				    " untrusted timeout %u 2>" _PATH_DEVNULL,
				    xauth_path, xauthfile, display,
				    x11_timeout_real);
				debug2("x11_get_proto: %s", cmd);
				if (x11_refuse_time == 0) {
					now = monotime() + 1;
					if (UINT_MAX - timeout < now)
						x11_refuse_time = UINT_MAX;
					else
						x11_refuse_time = now + timeout;
					channel_set_x11_refuse_time(
					    x11_refuse_time);
				}
				if (system(cmd) == 0)
					generated = 1;
d386 2
d409 1
a409 3
		} else
			error("Warning: untrusted X11 forwarding setup failed: "
			    "xauth key data not generated");
d417 7
d446 2
@


1.277
log
@pledges ssh client:
  - mux client: which is used when ControlMaster is in use.
    will end with "stdio proc tty" (proc is to permit sending SIGWINCH to mux master on window resize)

  - client loop: several levels of pledging depending of your used options

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.276 2015/10/20 03:36:35 mmcc Exp $ */
d1476 8
a1483 1
	if (options.forward_x11 || options.permit_local_command) {
a1497 7
			fatal("%s pledge(): %s", __func__, strerror(errno));

	} else if (options.control_master &&
	    ! option_clear_or_none(options.control_path)) {
		debug("pledge: filesystem create");
		if (pledge("stdio cpath unix inet dns tty",
		    NULL) == -1)
@


1.276
log
@Replace a function-local allocation with stack memory.

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.275 2015/07/10 06:21:53 markus Exp $ */
d1475 30
@


1.275
log
@Turn off DSA by default; add HostKeyAlgorithms to the server and
PubkeyAcceptedKeyTypes to the client side, so it still can be
tested or turned back on; feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.274 2015/07/01 02:26:31 djm Exp $ */
d306 1
a306 1
	char *xauthdir, *xauthfile;
a309 1
	xauthdir = xauthfile = NULL;
a336 2
			xauthdir = xmalloc(PATH_MAX);
			xauthfile = xmalloc(PATH_MAX);
a398 2
	free(xauthdir);
	free(xauthfile);
@


1.275.2.1
log
@MFC changes by djm@@cvs.openbsd.org, 2016/01/13 16:04:47

"eliminate fallback from untrusted X11 forwarding to trusted
forwarding when the X server disables the SECURITY extension;
Reported by Thomas Hoger; ok deraadt@@"
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.275 2015/07/10 06:21:53 markus Exp $ */
a282 3
	if (display == NULL)
		return 0;

d296 1
a296 1
int
d300 3
a302 1
	char cmd[1024], line[512], xdisplay[512];
d305 1
a305 1
	int got_data = 0, generated = 0, do_unlink = 0, i, r;
d315 4
a318 2
	if (!client_x11_display_valid(display)) {
		logit("DISPLAY \"%s\" invalid; disabling X11 forwarding",
d320 5
a324 8
		return -1;
	}
	if (xauth_path != NULL && stat(xauth_path, &st) == -1) {
		debug("No xauth program.");
		xauth_path = NULL;
	}

	if (xauth_path != NULL) {
d333 2
a334 6
			if ((r = snprintf(xdisplay, sizeof(xdisplay), "unix:%s",
			    display + 10)) < 0 ||
			    (size_t)r >= sizeof(xdisplay)) {
				error("%s: display name too long", __func__);
				return -1;
			}
d340 1
a341 2
			 * Generate an untrusted X11 auth cookie.
			 *
a345 16
			mktemp_proto(xauthdir, PATH_MAX);
			if (mkdtemp(xauthdir) == NULL) {
				error("%s: mkdtemp: %s",
				    __func__, strerror(errno));
				return -1;
			}
			do_unlink = 1;
			if ((r = snprintf(xauthfile, sizeof(xauthfile),
			    "%s/xauthfile", xauthdir)) < 0 ||
			    (size_t)r >= sizeof(xauthfile)) {
				error("%s: xauthfile path too long", __func__);
				unlink(xauthfile);
				rmdir(xauthdir);
				return -1;
			}

d350 21
a370 15
			if ((r = snprintf(cmd, sizeof(cmd),
			    "%s -f %s generate %s " SSH_X11_PROTO
			    " untrusted timeout %u 2>" _PATH_DEVNULL,
			    xauth_path, xauthfile, display,
			    x11_timeout_real)) < 0 ||
			    (size_t)r >= sizeof(cmd))
				fatal("%s: cmd too long", __func__);
			debug2("%s: %s", __func__, cmd);
			if (x11_refuse_time == 0) {
				now = monotime() + 1;
				if (UINT_MAX - timeout < now)
					x11_refuse_time = UINT_MAX;
				else
					x11_refuse_time = now + timeout;
				channel_set_x11_refuse_time(x11_refuse_time);
a371 2
			if (system(cmd) == 0)
				generated = 1;
d393 3
a395 1
		}
a404 7
	/* Don't fall back to fake X11 data for untrusted forwarding */
	if (!trusted && !got_data) {
		error("Warning: untrusted X11 forwarding setup failed: "
		    "xauth key data not generated");
		return -1;
	}

a426 2

	return 0;
@


1.275.2.2
log
@When backporting the xauth fix, I had corrected for the malloc/stack
difference for xauth*dir* but missed the xauth*file* case. Fix from
Matthias Pitzl at genua and confirmed by markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.275.2.1 2016/01/14 11:50:37 sthen Exp $ */
d360 1
a360 1
			if ((r = snprintf(xauthfile, PATH_MAX,
d362 1
a362 1
			    (size_t)r >= PATH_MAX) {
@


1.274
log
@better refuse ForwardX11Trusted=no connections attempted after
ForwardX11Timeout expires; reported by Jann Horn
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.273 2015/05/04 06:10:48 djm Exp $ */
d95 1
d2348 1
d2350 3
a2352 3
		if (options.hostkeyalgorithms != NULL &&
		    match_pattern_list(sshkey_ssh_name(key),
		    options.hostkeyalgorithms, 0) != 1) {
@


1.273
log
@Remove pattern length argument from match_pattern_list(),
we only ever use it for strlen(pattern).

Prompted by hanno AT hboeck.de pointing an out-of-bound read
error caused by an incorrect pattern length found using AFL
and his own tools.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.272 2015/02/25 19:54:02 djm Exp $ */
d158 1
a158 1
static int x11_refuse_time;	/* If >0, refuse x11 opens after this time. */
d293 2
a294 1
#define SSH_X11_PROTO "MIT-MAGIC-COOKIE-1"
d307 1
a307 1
	u_int now;
d340 9
d356 2
a357 1
				    xauth_path, xauthfile, display, timeout);
a358 2
				if (system(cmd) == 0)
					generated = 1;
d365 2
d368 2
d1893 1
a1893 1
	if (x11_refuse_time != 0 && monotime() >= x11_refuse_time) {
@


1.272
log
@fix small memory leak when UpdateHostkeys=no
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.271 2015/02/23 16:33:25 djm Exp $ */
d2337 1
a2337 2
		    options.hostkeyalgorithms,
		    strlen(options.hostkeyalgorithms), 0) != 1) {
@


1.272.2.1
log
@MFC changes by djm@@cvs.openbsd.org, 2016/01/13 16:04:47

"eliminate fallback from untrusted X11 forwarding to trusted
forwarding when the X server disables the SECURITY extension;
Reported by Thomas Hoger; ok deraadt@@"
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.272 2015/02/25 19:54:02 djm Exp $ */
a281 3
	if (display == NULL)
		return 0;

d294 1
a294 1
int
d298 3
a300 1
	char cmd[1024], line[512], xdisplay[512];
d303 1
a303 1
	int got_data = 0, generated = 0, do_unlink = 0, i, r;
d313 4
a316 2
	if (!client_x11_display_valid(display)) {
		logit("DISPLAY \"%s\" invalid; disabling X11 forwarding",
d318 5
a322 8
		return -1;
	}
	if (xauth_path != NULL && stat(xauth_path, &st) == -1) {
		debug("No xauth program.");
		xauth_path = NULL;
	}

	if (xauth_path != NULL) {
d331 2
a332 6
			if ((r = snprintf(xdisplay, sizeof(xdisplay), "unix:%s",
			    display + 10)) < 0 ||
			    (size_t)r >= sizeof(xdisplay)) {
				error("%s: display name too long", __func__);
				return -1;
			}
a337 1
			/* Generate an untrusted X11 auth cookie. */
d339 18
a356 29
			if (mkdtemp(xauthdir) == NULL) {
				error("%s: mkdtemp: %s",
				    __func__, strerror(errno));
				return -1;
			}
			do_unlink = 1;
			if ((r = snprintf(xauthfile, sizeof(xauthfile),
			    "%s/xauthfile", xauthdir)) < 0 ||
			    (size_t)r >= sizeof(xauthfile)) {
				error("%s: xauthfile path too long", __func__);
				unlink(xauthfile);
				rmdir(xauthdir);
				return -1;
			}
			if ((r = snprintf(cmd, sizeof(cmd),
			    "%s -f %s generate %s " SSH_X11_PROTO
			    " untrusted timeout %u 2>" _PATH_DEVNULL,
			    xauth_path, xauthfile, display, timeout)) < 0 ||
			    (size_t)r >= sizeof(cmd))
				fatal("%s: cmd too long", __func__);
			debug2("%s: %s", __func__, cmd);
			if (system(cmd) == 0)
				generated = 1;
			if (x11_refuse_time == 0) {
				now = monotime() + 1;
				if (UINT_MAX - timeout < now)
					x11_refuse_time = UINT_MAX;
				else
					x11_refuse_time = now + timeout;
d379 3
a381 1
		}
a390 7
	/* Don't fall back to fake X11 data for untrusted forwarding */
	if (!trusted && !got_data) {
		error("Warning: untrusted X11 forwarding setup failed: "
		    "xauth key data not generated");
		return -1;
	}

a412 2

	return 0;
@


1.272.2.2
log
@When backporting the xauth fix, I had corrected for the malloc/stack
difference for xauth*dir* but missed the xauth*file* case. Fix from
Matthias Pitzl at genua and confirmed by markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.272.2.1 2016/01/14 11:53:20 sthen Exp $ */
d352 1
a352 1
			if ((r = snprintf(xauthfile, PATH_MAX,
d354 1
a354 1
			    (size_t)r >= PATH_MAX) {
@


1.271
log
@fix setting/clearing of TTY raw mode around UpdateHostKeys=ask
confirmation question; reported by Herb Goldman
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.270 2015/02/20 22:17:21 djm Exp $ */
d2306 1
a2306 3
	struct hostkeys_update_ctx *ctx;

	ctx = xcalloc(1, sizeof(*ctx));
d2315 2
@


1.270
log
@UpdateHostKeys fixes:

I accidentally changed the format of the hostkeys@@openssh.com messages
last week without changing the extension name, and this has been causing
connection failures for people who are running -current. First reported
by sthen@@

s/hostkeys@@openssh.com/hostkeys-00@@openssh.com/
Change the name of the proof message too, and reorder it a little.

Also, UpdateHostKeys=ask is incompatible with ControlPersist (no TTY
available to read the response) so disable UpdateHostKeys if it is in
ask mode and ControlPersist is active (and document this)
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.269 2015/02/16 22:13:32 djm Exp $ */
d2155 2
a2156 1
	int r, loglevel = options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK ?
d2180 4
a2183 1
		leave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);
d2203 2
a2204 1
		enter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);
@


1.269
log
@Revise hostkeys@@openssh.com hostkey learning extension.

The client will not ask the server to prove ownership of the private
halves of any hitherto-unseen hostkeys it offers to the client.

Allow UpdateHostKeys option to take an 'ask' argument to let the
user manually review keys offered.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.268 2015/02/16 22:08:57 djm Exp $ */
d2250 3
a2252 1
		if ((r = sshbuf_put_string(signdata, ssh->kex->session_id,
a2253 2
		    (r = sshbuf_put_cstring(signdata,
		    "hostkeys-prove@@openssh.com")) != 0 ||
d2285 1
a2285 1
 * Handle hostkeys@@openssh.com global request to inform the client of all
d2320 4
a2323 2
		if ((r = sshkey_from_blob(blob, len, &key)) != 0)
			fatal("%s: parse key: %s", __func__, ssh_err(r));
d2363 1
a2363 1
		error("%s: server sent no hostkeys", __func__);
d2366 1
d2406 1
a2406 1
		    "hostkeys-prove@@openssh.com")) != 0 ||
d2453 1
a2453 1
	if (strcmp(rtype, "hostkeys@@openssh.com") == 0)
@


1.268
log
@Refactor hostkeys_foreach() and dependent code
Deal with IP addresses (i.e. CheckHostIP)
Don't clobber known_hosts when nothing changed
ok markus@@ as part of larger commit
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.267 2015/01/26 03:04:45 djm Exp $ */
d2074 210
d2292 1
d2294 1
a2294 1
	u_int i, len = 0, nkeys = 0;
d2296 3
a2298 3
	struct sshkey *key = NULL, **tmp, **keys = NULL;
	int r, success = 1;
	char *fp, *host_str = NULL, *ip_str = NULL;
d2301 1
d2303 1
a2303 8
	/*
	 * NB. Return success for all cases other than protocol error. The
	 * server doesn't need to know what the client does with its hosts
	 * file.
	 */

	blob = packet_get_string_ptr(&len);
	packet_check_eom();
d2307 3
d2312 1
a2312 3
	if ((buf = sshbuf_from(blob, len)) == NULL)
		fatal("%s: sshbuf_from failed", __func__);
	while (sshbuf_len(buf) > 0) {
d2315 6
a2320 1
		if ((r = sshkey_froms(buf, &key)) != 0)
d2336 21
a2356 6
		if ((tmp = reallocarray(keys, nkeys + 1,
		    sizeof(*keys))) == NULL)
			fatal("%s: reallocarray failed nkeys = %u",
			    __func__, nkeys);
		keys = tmp;
		keys[nkeys++] = key;
d2360 1
a2360 1
	if (nkeys == 0) {
d2364 3
d2370 2
a2371 1
	    options.port, &host_str, options.check_host_ip ? &ip_str : NULL);
d2373 5
a2377 11
	debug3("%s: update known hosts for %s%s%s with %u keys from server",
	    __func__, host_str,
	    options.check_host_ip ? " " : "",
	    options.check_host_ip ? ip_str : "", nkeys);

	if ((r = hostfile_replace_entries(options.user_hostfiles[0],
	    host_str, options.check_host_ip ? ip_str : NULL,
	    keys, nkeys, options.hash_known_hosts, 0,
	    options.fingerprint_hash)) != 0) {
		error("%s: hostfile_replace_entries failed: %s",
		    __func__, ssh_err(r));
d2381 46
d2429 1
a2429 2
	free(host_str);
	free(ip_str);
a2430 2
	for (i = 0; i < nkeys; i++)
		sshkey_free(keys[i]);
d2432 5
a2436 1
	return success;
@


1.267
log
@Host key rotation support.

Add a hostkeys@@openssh.com protocol extension (global request) for
a server to inform a client of all its available host key after
authentication has completed. The client may record the keys in
known_hosts, allowing it to upgrade to better host key algorithms
and a server to gracefully rotate its keys.

The client side of this is controlled by a UpdateHostkeys config
option (default on).

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.266 2015/01/20 23:14:00 deraadt Exp $ */
d2087 1
a2087 1
	char *fp, *host_str = NULL;
d2089 1
a2133 1
	debug3("%s: received %u keys from server", __func__, nkeys);
d2139 13
a2151 4
	get_hostfile_hostname_ipaddr(host, NULL, options.port, &host_str, NULL);

	if ((r = hostfile_replace_entries(options.user_hostfiles[0], host_str,
	    keys, nkeys, options.hash_known_hosts, 1)) != 0) {
d2160 1
@


1.266
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.265 2015/01/19 20:16:15 markus Exp $ */
d107 1
d1773 1
d2025 1
d2073 85
d2165 1
a2165 1
	rtype = packet_get_string(NULL);
d2169 2
@


1.265
log
@adapt kex to sshbuf and struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.264 2015/01/19 20:07:45 markus Exp $ */
d63 1
a68 1
#include <sys/param.h>
d81 1
d335 3
a337 3
			xauthdir = xmalloc(MAXPATHLEN);
			xauthfile = xmalloc(MAXPATHLEN);
			mktemp_proto(xauthdir, MAXPATHLEN);
d340 1
a340 1
				snprintf(xauthfile, MAXPATHLEN, "%s/xauthfile",
@


1.264
log
@move dispatch to struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.263 2015/01/19 19:52:16 markus Exp $ */
d1404 1
a1404 2
	dispatch_run(DISPATCH_NONBLOCK, &quit_pending,
	    compat20 ? active_state->kex : NULL);
d1458 1
a1458 1
	int max_fd = 0, max_fd2 = 0, len, rekeying = 0;
d1588 3
a1590 1
				kex_send_kexinit(active_state->kex);
@


1.263
log
@update packet.c & isolate, introduce struct ssh
a) switch packet.c to buffer api and isolate per-connection info into struct ssh
b) (de)serialization of the state is moved from monitor to packet.c
c) the old packet.c API is implemented in opacket.[ch]
d) compress.c/h is removed and integrated into packet.c
with and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.262 2015/01/14 20:05:27 djm Exp $ */
d531 1
a531 1
static void
d537 1
a537 1
		return;
d547 1
d1731 1
a1731 1
static void
d1740 1
d1742 1
a1742 1
static void
d1751 1
d1753 1
a1753 1
static void
d1768 1
d1770 1
a1770 1
static void
d1813 1
d1968 1
a1968 1
static void
d2019 1
d2021 1
a2021 1
static void
d2066 1
d2068 1
a2068 1
static void
d2086 1
@


1.262
log
@move authfd.c and its tentacles to the new buffer/key API;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.261 2014/07/15 15:54:14 millert Exp $ */
a186 3
/*XXX*/
extern Kex *xxx_kex;

d1404 1
a1404 1
	    compat20 ? xxx_kex : NULL);
d1543 1
a1543 1
		rekeying = (xxx_kex != NULL && !xxx_kex->done);
d1587 2
a1588 2
				xxx_kex->done = 0;
				kex_send_kexinit(xxx_kex);
d1717 1
a1717 2
	packet_get_state(MODE_IN, NULL, NULL, NULL, &ibytes);
	packet_get_state(MODE_OUT, NULL, NULL, NULL, &obytes);
@


1.261
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.260 2014/06/27 16:41:56 markus Exp $ */
d105 1
d1774 1
a1774 1
	int remote_id, sock;
d1784 5
a1788 1
	sock = ssh_get_authentication_socket();
d1906 1
a1906 1
	int sock;
d1914 4
a1917 2
	sock = ssh_get_authentication_socket();
	if (sock < 0)
d1919 1
@


1.260
log
@fix remote fwding with same listen port but different listen address
with gerhard@@, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.259 2014/04/29 13:10:30 djm Exp $ */
d95 1
a101 1
#include "misc.h"
d865 3
a867 4
	char *s, *cmd, *cancel_host;
	int delete = 0, local = 0, remote = 0, dynamic = 0;
	int cancel_port, ok;
	Forward fwd;
a869 1
	fwd.listen_host = fwd.connect_host = NULL;
d935 3
a937 11
		cancel_port = 0;
		cancel_host = hpdelim(&s);	/* may be NULL */
		if (s != NULL) {
			cancel_port = a2port(s);
			cancel_host = cleanhostname(cancel_host);
		} else {
			cancel_port = a2port(cancel_host);
			cancel_host = NULL;
		}
		if (cancel_port <= 0) {
			logit("Bad forwarding close port");
d941 1
a941 2
			ok = channel_request_rforward_cancel(cancel_host,
			    cancel_port) == 0;
d943 2
a944 2
                	ok = channel_cancel_lport_listener(cancel_host,
			    cancel_port, 0, options.gateway_ports) > 0;
d946 3
a948 3
                	ok = channel_cancel_lport_listener(cancel_host,
			    cancel_port, CHANNEL_CANCEL_PORT_STATIC,
			    options.gateway_ports) > 0;
d960 2
a961 3
			if (!channel_setup_local_fwd_listener(fwd.listen_host,
			    fwd.listen_port, fwd.connect_host,
			    fwd.connect_port, options.gateway_ports)) {
d966 1
a966 3
			if (channel_request_remote_forwarding(fwd.listen_host,
			    fwd.listen_port, fwd.connect_host,
			    fwd.connect_port) < 0) {
d979 1
d981 1
d1824 2
a1825 3
	debug("client_request_forwarded_tcpip: listen %s port %d, "
	    "originator %s port %d", listen_address, listen_port,
	    originator_address, originator_port);
d1836 21
d1977 2
@


1.259
log
@bz#1818 - don't send channel success/failre replies on channels that
have sent a close already; analysis and patch from Simon Tatham;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.258 2014/02/02 03:44:31 djm Exp $ */
d1840 1
a1840 1
	c = channel_connect_by_listen_address(listen_port,
@


1.258
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.257 2014/01/31 16:39:19 tedu Exp $ */
d2039 1
a2039 1
	if (reply && c != NULL) {
@


1.257
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.256 2013/11/20 20:54:10 deraadt Exp $ */
d1752 1
a1752 1
	memset(data, 0, data_len);
d1762 1
a1762 1
	memset(data, 0, data_len);
@


1.256
log
@unsigned casts for ctype macros where neccessary
ok guenther millert markus
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.255 2013/11/08 00:39:15 djm Exp $ */
d544 1
a544 1
		bzero(gc, sizeof(*gc));
d870 1
a870 1
	bzero(&fwd, sizeof(fwd));
@


1.255
log
@use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.254 2013/09/12 01:41:12 djm Exp $ */
d284 1
a284 1
		if (!isalnum(display[i]) &&
d878 1
a878 1
	while (isspace(*s))
d932 1
a932 1
	while (isspace(*++s))
@


1.254
log
@fix connection crash when sending break (~B) on ControlPersist'd session;
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.253 2013/06/07 15:37:52 dtucker Exp $ */
d831 1
a831 1
	struct channel_reply_ctx *cr = xmalloc(sizeof(*cr));
d854 1
a854 1
	gc = xmalloc(sizeof(*gc));
d1429 1
a1429 1
	ret = xmalloc(sizeof(*ret));
@


1.253
log
@Add an "ABANDONED" channel state and use for mux sessions that are
disconnected via the ~. escape sequence.  Channels in this state will
be able to close if the server responds, but do not count as active channels.
This means that if you ~. all of the mux clients when using ControlPersist
on a broken network, the backgrounded mux master will exit when the
Control Persist time expires rather than hanging around indefinitely.
bz#1917, also reported and tested by tedu@@.  ok djm@@ markus@@.
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.252 2013/06/02 23:36:29 dtucker Exp $ */
d1147 1
a1147 1
					channel_request_start(session_ident,
@


1.253.2.1
log
@cherrypick commit:

date: 2013/11/08 00:39:15;  author: djm;  state: Exp;  lines: +2 -2;
use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.253 2013/06/07 15:37:52 dtucker Exp $ */
d831 1
a831 1
	struct channel_reply_ctx *cr = xcalloc(1, sizeof(*cr));
d854 1
a854 1
	gc = xcalloc(1, sizeof(*gc));
d1429 1
a1429 1
	ret = xcalloc(1, sizeof(*ret));
@


1.252
log
@No need for the mux cleanup callback to be visible so restore it to static
and call it through the detach_user function pointer.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.251 2013/06/01 13:15:51 dtucker Exp $ */
d1105 3
@


1.251
log
@Use clock_gettime(CLOCK_MONOTONIC ...) for ssh timers so that things like
keepalives and rekeying will work properly over clock steps.  Suggested by
markus@@, "looks good" djm@@.
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.250 2013/05/17 00:13:13 djm Exp $ */
d1103 2
a1104 2
					mux_master_session_cleanup_cb(c->self,
					    NULL);
@


1.250
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.249 2013/05/16 02:00:34 dtucker Exp $ */
d268 1
a268 1
		control_persist_exit_time = time(NULL) +
d351 1
a351 1
					now = time(NULL) + 1;
d576 1
a576 1
	time_t minwait_secs = 0, server_alive_time = 0, now = time(NULL);
d671 1
a671 1
		if (server_alive_time != 0 && server_alive_time <= time(NULL))
d1641 1
a1641 1
			if (time(NULL) >= control_persist_exit_time) {
d1859 1
a1859 1
	if (x11_refuse_time != 0 && time(NULL) >= x11_refuse_time) {
@


1.249
log
@Add an optional second argument to RekeyLimit in the client to allow
rekeying based on elapsed time in addition to amount of traffic.
with djm@@ jmc@@, ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.248 2013/01/02 00:32:07 djm Exp $ */
d388 2
a389 4
	if (xauthdir)
		xfree(xauthdir);
	if (xauthfile)
		xfree(xauthfile);
d545 1
a545 1
		xfree(gc);
d818 1
a818 1
	xfree(cr);
d824 1
a824 1
	xfree(ctx);
d991 3
a993 6
	if (cmd)
		xfree(cmd);
	if (fwd.listen_host != NULL)
		xfree(fwd.listen_host);
	if (fwd.connect_host != NULL)
		xfree(fwd.connect_host);
d1250 1
a1250 1
				xfree(s);
d1436 1
a1436 1
	xfree(ctx);
d1647 2
a1648 4
	if (readset)
		xfree(readset);
	if (writeset)
		xfree(writeset);
d1750 1
a1750 1
	xfree(data);
d1760 1
a1760 1
	xfree(data);
d1840 2
a1841 2
	xfree(originator_address);
	xfree(listen_address);
d1875 1
a1875 1
	xfree(originator);
d1996 1
a1996 1
	xfree(ctype);
d2042 1
a2042 1
	xfree(rtype);
d2061 1
a2061 1
	xfree(rtype);
d2111 1
a2111 1
				xfree(name);
d2125 1
a2125 1
				xfree(name);
d2134 1
a2134 1
			xfree(name);
@


1.248
log
@channel_setup_local_fwd_listener() returns 0 on failure, not -ve
bz#2055 reported by mathieu.lacage AT gmail.com
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.247 2012/09/07 06:34:21 dtucker Exp $ */
d578 1
a578 1
	time_t minwait_secs = 0;
d627 1
a627 1
	if (options.server_alive_interval > 0 && compat20)
d629 4
d636 1
a636 1
			control_persist_exit_time - time(NULL));
d668 9
a676 2
	} else if (ret == 0)
		server_alive_check();
@


1.248.2.1
log
@openssh-6.4 for the 5.3 branch; reminded by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.253.2.1 2013/11/08 01:33:56 djm Exp $ */
d822 1
a822 1
	struct channel_reply_ctx *cr = xcalloc(1, sizeof(*cr));
d845 1
a845 1
	gc = xcalloc(1, sizeof(*gc));
d1420 1
a1420 1
	ret = xcalloc(1, sizeof(*ret));
@


1.247
log
@when muxmaster is run with -N, make it shut down gracefully when a client
sends it "-O stop" rather than hanging around.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.246 2012/09/07 01:10:21 dtucker Exp $ */
d962 1
a962 1
			if (channel_setup_local_fwd_listener(fwd.listen_host,
d964 1
a964 1
			    fwd.connect_port, options.gateway_ports) < 0) {
@


1.246
log
@Merge escape help text for ~v and ~V; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.245 2012/09/07 00:30:19 dtucker Exp $ */
d2229 2
a2230 2
	 * If we are in persist mode, signal that we should close when all
	 * active channels are closed.
d2232 1
a2232 1
	if (options.control_persist) {
@


1.245
log
@Print '^Z' instead of a raw ^Z when the sequence is not supported.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.244 2012/09/06 09:50:13 dtucker Exp $ */
d1008 1
a1008 2
    {"V",  "decrease verbosity (LogLevel)", SUPPRESS_MUXCLIENT},
    {"v",  "increase verbosity (LogLevel)", SUPPRESS_MUXCLIENT},
d1035 1
a1035 1
		snprintf(string, sizeof string, " %c%-2s - %s\r\n",
d1041 1
a1041 1
	    " %c%c  - send the escape character by typing it twice\r\n"
@


1.244
log
@Make the escape command help (~?) context sensitive so that only commands
that will work in the current session are shown.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.243 2012/09/06 06:25:41 dtucker Exp $ */
d1108 1
d1110 4
d1115 1
a1115 1
					    "%c%c escape not available to "
d1117 1
a1117 1
					    escape_char, ch);
@


1.243
log
@Put help text for ~v and ~V around the correct way
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.242 2012/09/06 04:37:38 dtucker Exp $ */
d990 58
d1229 3
a1231 40
				if (c && c->ctl_chan != -1) {
					snprintf(string, sizeof string,
"%c?\r\n\
Supported escape sequences:\r\n\
  %c.  - terminate session\r\n\
  %cB  - send a BREAK to the remote system\r\n\
  %cR  - Request rekey (SSH protocol 2 only)\r\n\
  %c#  - list forwarded connections\r\n\
  %c?  - this message\r\n\
  %c%c  - send the escape character by typing it twice\r\n\
(Note that escapes are only recognized immediately after newline.)\r\n",
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char);
				} else {
					snprintf(string, sizeof string,
"%c?\r\n\
Supported escape sequences:\r\n\
  %c.  - terminate connection (and any multiplexed sessions)\r\n\
  %cB  - send a BREAK to the remote system\r\n\
  %cC  - open a command line\r\n\
  %cR  - Request rekey (SSH protocol 2 only)\r\n\
  %cV  - Decrease verbosity (LogLevel)\r\n\
  %cv  - Increase verbosity (LogLevel)\r\n\
  %c^Z - suspend ssh\r\n\
  %c#  - list forwarded connections\r\n\
  %c&  - background ssh (when waiting for connections to terminate)\r\n\
  %c?  - this message\r\n\
  %c%c  - send the escape character by typing it twice\r\n\
(Note that escapes are only recognized immediately after newline.)\r\n",
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char);
				}
				buffer_append(berr, string, strlen(string));
@


1.242
log
@Add ~v and ~V escape sequences to raise and lower the logging level
respectively. Man page help from jmc, ok deraadt jmc
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.241 2012/08/17 00:45:45 dtucker Exp $ */
d1194 2
a1195 2
  %cV  - Increase verbosity (LogLevel)\r\n\
  %cv  - Decrease verbosity (LogLevel)\r\n\
@


1.241
log
@Force a clean shutdown of ControlMaster client sessions when the ~. escape
sequence is used.  This means that ~. should now work in mux clients even
if the server is no longer responding.  Found by tedu, ok djm.
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.240 2012/06/20 04:42:58 djm Exp $ */
d1093 25
d1194 2
d1202 1
@


1.240
log
@initialise accept() backoff timer to avoid EINVAL from select(2) in
rekeying
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.239 2012/04/11 13:16:19 djm Exp $ */
d1040 2
@


1.239
log
@don't spin in accept() when out of fds (ENFILE/ENFILE) - back off for a
while; ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.238 2012/01/18 21:46:43 dtucker Exp $ */
d578 1
a578 1
	time_t minwait_secs;
@


1.238
log
@Ensure that $DISPLAY contains only valid characters before using it to
extract xauth data so that it can't be used to play local shell
metacharacter games.  Report from r00t_ati at ihteam.net, ok markus.
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.237 2011/09/10 22:26:34 markus Exp $ */
d578 1
d582 2
a583 1
	channel_prepare_select(readsetp, writesetp, maxfdp, nallocp, rekeying);
d636 2
@


1.237
log
@support cancellation of local/dynamic forwardings from ~C commandline;
ok & feedback djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.236 2011/06/22 22:08:42 djm Exp $ */
d276 17
d315 3
@


1.236
log
@hook up a channel confirm callback to warn the user then requested X11
forwarding was refused by the server; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.235 2011/06/17 21:57:25 djm Exp $ */
d833 2
a834 3
	int delete = 0;
	int local = 0, remote = 0, dynamic = 0;
	int cancel_port;
d860 2
d864 2
d894 1
a894 5
	if ((local || dynamic) && delete) {
		logit("Not supported.");
		goto out;
	}
	if (remote && delete && !compat20) {
d917 15
a931 1
		channel_request_rforward_cancel(cancel_host, cancel_port);
a951 1

@


1.235
log
@setproctitle for a mux master that has been gracefully stopped;
bz#1911 from Bert.Wesarg AT googlemail.com
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.234 2011/05/08 12:52:01 djm Exp $ */
a168 1
enum confirm_action { CONFIRM_WARN = 0, CONFIRM_CLOSE, CONFIRM_TTY };
d794 1
a794 1
static void
@


1.234
log
@improve our behaviour when TTY allocation fails: if we are in
RequestTTY=auto mode (the default), then do not treat at TTY
allocation error as fatal but rather just restore the local TTY
to cooked mode and continue. This is more graceful on devices that
never allocate TTYs.

If RequestTTY is set to "yes" or "force", then failure to allocate
a TTY is fatal.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.233 2011/05/06 21:34:32 djm Exp $ */
d2142 1
a2142 1
	if (options.control_persist)
d2144 2
@


1.233
log
@Add a RequestTTY ssh_config option to allow configuration-based
control over tty allocation (like -t/-T); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.232 2011/04/17 22:42:41 djm Exp $ */
d169 1
d172 2
a173 1
	int id, do_close;
d735 9
d761 1
a761 1
		if (cr->do_close && c->self == session_ident)
d763 8
a770 4
		/* If error occurred on mux client, append to their stderr */
		if (tochan)
			buffer_append(&c->extended, errmsg, strlen(errmsg));
		else
d772 10
a781 1
		if (cr->do_close) {
d796 2
a797 1
client_expect_confirm(int id, const char *request, int do_close)
d802 1
a802 1
	cr->do_close = do_close;
d1993 1
a1993 1
		client_expect_confirm(id, "PTY allocation", 1);
d2052 1
a2052 1
			client_expect_confirm(id, "subsystem", 1);
d2057 1
a2057 1
			client_expect_confirm(id, "exec", 1);
d2063 1
a2063 1
		client_expect_confirm(id, "shell", 1);
@


1.232
log
@allow graceful shutdown of multiplexing: request that a mux server removes
its listener socket and refuse future multiplexing requests; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.231 2011/01/16 12:05:59 djm Exp $ */
a124 3
/* Force TTY allocation */
extern int force_tty_flag;

d654 1
a654 1
	leave_raw_mode(force_tty_flag);
d675 1
a675 1
	enter_raw_mode(force_tty_flag);
d817 1
a817 1
	leave_raw_mode(force_tty_flag);
d921 1
a921 1
	enter_raw_mode(force_tty_flag);
d1040 2
a1041 1
				leave_raw_mode(force_tty_flag);
d1333 1
a1333 1
	leave_raw_mode(force_tty_flag);
d1404 1
a1404 1
		enter_raw_mode(force_tty_flag);
d1548 1
a1548 1
		leave_raw_mode(force_tty_flag);
d2125 1
a2125 1
	leave_raw_mode(force_tty_flag);
@


1.231
log
@a couple more tweaks to the post-close protocol 1 stderr/stdout flush:
now that we use atomicio(), convert them from while loops to if statements
add test and cast to compile cleanly with -Wsigned
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.230 2011/01/16 11:50:05 djm Exp $ */
d260 1
a260 1
	    || options.control_persist_timeout == 0)
d263 1
a263 1
	else if (channel_still_open()) {
d1410 8
a1417 6
		if (escape_char_arg != SSH_ESCAPECHAR_NONE)
			channel_register_filter(session_ident,
			    client_simple_escape_filter, NULL,
			    client_filter_cleanup,
			    client_new_escape_filter_ctx(escape_char_arg));
		if (session_ident != -1)
d1420 1
d2108 13
@


1.230
log
@Use atomicio when flushing protocol 1 std{out,err} buffers at
session close. This was a latent bug exposed by setting a SIGCHLD
handler and spotted by kevin.brott AT gmail.com; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.229 2011/01/11 06:13:10 djm Exp $ */
d1581 1
a1581 1
	while (buffer_len(&stdout_buffer) > 0) {
d1584 1
a1584 1
		if (len != buffer_len(&stdout_buffer)) {
d1586 2
a1587 3
			break;
		}
		buffer_consume(&stdout_buffer, len);
d1591 1
a1591 1
	while (buffer_len(&stderr_buffer) > 0) {
d1594 1
a1594 1
		if (len != buffer_len(&stderr_buffer)) {
d1596 2
a1597 3
			break;
		}
		buffer_consume(&stderr_buffer, len);
@


1.229
log
@some unsigned long long casts that make things a bit easier for
portable without resorting to dropping PRIu64 formats everywhere
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.228 2011/01/08 10:51:51 djm Exp $ */
d1582 3
a1584 3
		len = write(fileno(stdout), buffer_ptr(&stdout_buffer),
		    buffer_len(&stdout_buffer));
		if (len <= 0) {
d1593 3
a1595 3
		len = write(fileno(stderr), buffer_ptr(&stderr_buffer),
		    buffer_len(&stderr_buffer));
		if (len <= 0) {
@


1.228
log
@use host and not options.hostname, as the latter may have unescaped
substitution characters
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.227 2011/01/06 22:23:02 djm Exp $ */
d1613 1
a1613 1
	    obytes, ibytes, total_time);
@


1.227
log
@when exiting due to ServerAliveTimeout, mention the hostname that caused
it (useful with backgrounded controlmaster)
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.226 2010/11/23 23:57:24 djm Exp $ */
d539 1
a539 1
		logit("Timeout, server %s not responding.", options.hostname);
@


1.226
log
@avoid NULL deref on receiving a channel request on an unknown or invalid
channel; report bz#1842 from jchadima AT redhat.com; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.225 2010/11/21 01:01:13 djm Exp $ */
d539 1
a539 1
		logit("Timeout, server not responding.");
@


1.225
log
@honour $TMPDIR for client xauth and ssh-agent temporary directories;
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.224 2010/11/13 23:27:50 djm Exp $ */
d1918 1
a1918 1
	if (reply) {
@


1.224
log
@allow ssh and sshd to set arbitrary TOS/DSCP/QoS values instead of
hardcoding lowdelay/throughput.

bz#1733 patch from philipp AT redfish-solutions.com; ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.223 2010/10/06 06:39:28 djm Exp $ */
d320 1
a320 1
			strlcpy(xauthdir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
@


1.223
log
@kill proxy command on fatal() (we already kill it on clean exit);
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.222 2010/07/19 09:15:12 djm Exp $ */
d1957 3
@


1.222
log
@add a "ControlPersist" option that automatically starts a background
ssh(1) multiplex master when connecting. This connection can stay alive
indefinitely, or can be set to automatically close after a user-specified
duration of inactivity. bz#1330 - patch by dwmw2 AT infradead.org, but
further hacked on by wmertens AT cisco.com, apb AT cequrux.com,
martin-mindrot-bugzilla AT earth.li and myself; "looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.221 2010/06/25 23:15:36 djm Exp $ */
d2114 1
@


1.221
log
@Add X11ForwardTimeout option to specify timeout for untrusted X11
authentication cookies to avoid fallback in X11 code to fully-trusted
implicit authentication using SO_PEERCRED described at:
http://lists.x.org/archives/xorg-devel/2010-May/008636.html

After the X11ForwardTimeout has expired the client will now refuse
incoming X11 channel opens.

based on patch from Tavis Ormandy; "nice" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.220 2010/04/10 02:08:44 djm Exp $ */
d140 3
d250 28
d559 1
d603 1
a603 1
	 * event pending.
d606 11
a616 1
	if (options.server_alive_interval == 0 || !compat20)
d619 1
a619 1
		tv.tv_sec = options.server_alive_interval;
d623 1
d1512 12
@


1.220
log
@bz#1698: kill channel when pty allocation requests fail. Fixed
stuck client if the server refuses pty allocation.
ok dtucker@@ "think so" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.219 2010/03/13 21:10:38 djm Exp $ */
d150 1
a150 1
static u_int buffer_high;/* Soft max buffer size. */
d154 2
a155 1
static int session_closed = 0;	/* In SSH2: login session closed. */
d250 1
a250 1
    u_int trusted, char **_proto, char **_data)
d260 1
d296 2
a297 2
				    " untrusted timeout 1200 2>" _PATH_DEVNULL,
				    xauth_path, xauthfile, display);
d301 7
d1684 5
@


1.219
log
@protocol conformance fix: send language tag when disconnecting normally;
spotted by 1.41421 AT gmail.com, ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.218 2010/01/28 00:21:18 djm Exp $ */
d1897 1
a1897 1
		client_expect_confirm(id, "PTY allocation", 0);
@


1.218
log
@downgrade an error() to a debug() - this particular case can be hit in
normal operation for certain sequences of mux slave vs session closure
and is harmless
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.217 2010/01/26 01:28:35 djm Exp $ */
d1475 1
@


1.217
log
@rewrite ssh(1) multiplexing code to a more sensible protocol.

The new multiplexing code uses channels for the listener and
accepted control sockets to make the mux master non-blocking, so
no stalls when processing messages from a slave.

avoid use of fatal() in mux master protocol parsing so an errant slave
process cannot take down a running master.

implement requesting of port-forwards over multiplexed sessions. Any
port forwards requested by the slave are added to those the master has
established.

add support for stdio forwarding ("ssh -W host:port ...") in mux slaves.

document master/slave mux protocol so that other tools can use it to
control a running ssh(1). Note: there are no guarantees that this
protocol won't be incompatibly changed (though it is versioned).

feedback Salvador Fandino, dtucker@@
channel changes ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.216 2010/01/09 05:04:24 djm Exp $ */
d1842 3
a1844 2
			error("client_input_channel_req: unexpected channel %d",
			    session_ident);
@


1.216
log
@quell tc[gs]etattr warnings when forcing a tty (ssh -tt), since we
usually don't actually have a tty to read/set; bz#1686 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.215 2009/11/17 05:31:44 djm Exp $ */
d116 1
a116 1
extern int muxserver_sock;
d141 1
a141 1
static volatile sig_atomic_t quit_pending; /* Set non-zero to quit the loop. */
a558 3
	if (muxserver_sock != -1)
		FD_SET(muxserver_sock, *readsetp);

d686 1
a686 1
	    c->ctl_fd != -1 && c->extended_usage == CHAN_EXTENDED_WRITE;
d830 1
d928 1
a928 1
				if (c && c->ctl_fd != -1) {
d938 1
a938 1
				if (c && c->ctl_fd != -1) {
d983 1
a983 1
				if (c && c->ctl_fd != -1)
d1034 1
a1034 1
				if (c && c->ctl_fd != -1) {
d1083 1
a1083 1
				if (c && c->ctl_fd != -1)
a1315 2
	if (muxserver_sock != -1)
		max_fd = MAX(max_fd, muxserver_sock);
a1432 6
		/* Accept control connections.  */
		if (muxserver_sock != -1 &&FD_ISSET(muxserver_sock, readset)) {
			if (muxserver_accept_control())
				quit_pending = 1;
		}

d1834 2
a1835 3
		if (c->ctl_fd != -1) {
			/* Dispatch to mux client */
			atomicio(vwrite, c->ctl_fd, &exitval, sizeof(exitval));
@


1.215
log
@fix incorrect exit status when multiplexing and channel ID 0 is recycled
bz#1570 reported by peter.oliver AT eon-is.co.uk; ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.214 2009/10/24 11:15:29 andreas Exp $ */
d125 3
d608 1
a608 1
	leave_raw_mode();
d629 1
a629 1
	enter_raw_mode();
d771 1
a771 1
	leave_raw_mode();
d874 1
a874 1
	enter_raw_mode();
d993 1
a993 1
				leave_raw_mode();
d1285 1
a1285 1
	leave_raw_mode();
d1358 1
a1358 1
		enter_raw_mode();
d1492 1
a1492 1
		leave_raw_mode();
d2050 1
a2050 1
	leave_raw_mode();
@


1.214
log
@client_loop() must detect if the session has been suspended and resumed,
and take appropriate action in that case.
From Martin Forssen, maf at appgate dot com
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.213 2009/07/05 19:28:33 stevesk Exp $ */
d1841 6
a1846 1
		if (id == session_ident) {
d1849 1
a1849 1
		} else if (c->ctl_fd == -1) {
a1851 3
		} else {
			atomicio(vwrite, c->ctl_fd, &exitval, sizeof(exitval));
			success = 1;
@


1.213
log
@only send SSH2_MSG_DISCONNECT if we're in compat20; from dtucker@@
ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.212 2009/05/28 16:50:16 andreas Exp $ */
d156 2
d1451 8
@


1.212
log
@Keep track of number of bytes read and written. Needed for upcoming
changes. Most code from Martin Forssen, maf at appgate dot com.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.211 2009/05/27 06:33:39 andreas Exp $ */
d1468 7
a1474 5
	packet_start(SSH2_MSG_DISCONNECT);
	packet_put_int(SSH2_DISCONNECT_BY_APPLICATION);
	packet_put_cstring("disconnected by user");
	packet_send();
	packet_write_wait();
@


1.211
log
@Send SSH2_MSG_DISCONNECT when the client disconnects. From a larger
change from Martin Forssen, maf at appgate dot com.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.210 2009/05/25 06:48:01 andreas Exp $ */
d104 1
d630 1
a630 1
	int len;
d639 2
a640 2
		len = read(connection_in, buf, sizeof(buf));
		if (len == 0) {
@


1.210
log
@Put the globals in packet.c into a struct and don't access it directly
from other files. No functional changes.
ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.209 2009/02/12 03:00:56 djm Exp $ */
d1466 6
@


1.209
log
@support remote port forwarding with a zero listen port (-R0:...) to
dyamically allocate a listen port at runtime (this is actually
specified in rfc4254); bz#1003 ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.208 2009/01/22 10:02:34 djm Exp $ */
d486 1
a486 1
	keep_alive_timeouts = 0;
d492 1
a492 1
	if (++keep_alive_timeouts > options.server_alive_count_max) {
@


1.208
log
@make a2port() return -1 when it encounters an invalid port number
rather than 0, which it will now treat as valid (needed for future work)

adjust current consumers of a2port() to check its return value is <= 0,
which in turn required some things to be converted from u_short => int

make use of int vs. u_short consistent in some other places too

feedback & ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.207 2008/12/09 22:37:33 stevesk Exp $ */
d843 1
a843 1
		if (!parse_forward(&fwd, s, dynamic ? 1 : 0)) {
@


1.207
log
@fix typo in error message
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.206 2008/12/09 02:38:18 djm Exp $ */
d759 1
a759 1
	u_short cancel_port;
d837 1
a837 1
		if (cancel_port == 0) {
d1629 1
a1629 1
	int listen_port, originator_port;
d1655 1
a1655 1
	int originator_port;
@


1.206
log
@The ~C escape handler does not work correctly for multiplexed sessions -
it opens a commandline on the master session, instead of on the slave
that requested it. Disable it on slave sessions until such time as it
is fixed; bz#1543 report from Adrian Bridgett via Colin Watson
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.205 2008/12/02 19:01:07 markus Exp $ */
d1719 1
a1719 1
		error("Tunnel forwarding is not support for protocol 1");
@


1.205
log
@we have to use the recipient's channel number (RFC 4254) for
SSH2_MSG_CHANNEL_SUCCESS/SSH2_MSG_CHANNEL_FAILURE messages,
otherwise we trigger 'Non-public channel' error messages on sshd
systems with clientkeepalive enabled; noticed by sturm; ok djm;
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.204 2008/11/05 03:23:09 stevesk Exp $ */
a1035 1
  %cC  - open a command line\r\n\
d1044 1
a1044 2
					    escape_char, escape_char,
					    escape_char);
d1079 2
@


1.204
log
@add dynamic forward escape command line; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.203 2008/11/01 17:40:33 stevesk Exp $ */
d1837 1
a1837 1
		packet_put_int(id);
@


1.203
log
@merge dynamic forward parsing into parse_forward(); 'i think this is OK' djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.202 2008/10/30 19:31:16 stevesk Exp $ */
d758 1
a758 1
	int local = 0;
d783 2
d804 7
a810 1
	if (*s != 'L' && *s != 'R') {
d814 2
a815 3
	if (*s == 'L')
		local = 1;
	if (local && delete) {
d819 1
a819 1
	if ((!local || delete) && !compat20) {
d843 1
a843 1
		if (!parse_forward(&fwd, s, 0)) {
d847 1
a847 1
		if (local) {
@


1.202
log
@don't need to #include "monitor_fdpass.h"
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.201 2008/07/16 11:51:14 djm Exp $ */
d836 1
a836 1
		if (!parse_forward(&fwd, s)) {
@


1.201
log
@rename variable first_gc -> last_gc (since it is actually the last
in the list).
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.200 2008/07/10 18:08:11 markus Exp $ */
a101 1
#include "monitor_fdpass.h"
@


1.200
log
@sync v1 and v2 traffic accounting; add it to sshd, too; ok djm@@, dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.199 2008/06/12 21:06:25 djm Exp $ */
d735 1
a735 1
	struct global_confirm *gc, *first_gc;
d738 5
a742 5
	first_gc = TAILQ_LAST(&global_confirms, global_confirms);
	if (first_gc && first_gc->cb == cb && first_gc->ctx == ctx) {
		if (++first_gc->ref_count >= INT_MAX)
			fatal("%s: first_gc->ref_count = %d",
			    __func__, first_gc->ref_count);
@


1.199
log
@I was coalescing expected global request confirmation replies at the
wrong end of the queue - fix; prompted by markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.198 2008/06/12 15:19:17 djm Exp $ */
a146 1
static u_long stdin_bytes, stdout_bytes, stderr_bytes;
a430 1
		stdin_bytes += len;
a1194 1
		stdout_bytes += len;
a1214 1
		stderr_bytes += len;
d1289 1
a1320 3
	stdin_bytes = 0;
	stdout_bytes = 0;
	stderr_bytes = 0;
a1505 1
		stdout_bytes += len;
a1516 1
		stderr_bytes += len;
d1527 4
a1530 2
	debug("Transferred: stdin %lu, stdout %lu, stderr %lu bytes in %.1f "
	    "seconds", stdin_bytes, stdout_bytes, stderr_bytes, total_time);
d1532 2
a1533 4
		debug("Bytes per second: stdin %.1f, stdout %.1f, stderr %.1f",
		    stdin_bytes / total_time, stdout_bytes / total_time,
		    stderr_bytes / total_time);

@


1.198
log
@The multiplexing escape char handler commit last night introduced a
small memory leak per session; plug it.
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.197 2008/06/12 04:17:47 djm Exp $ */
d740 1
a740 1
	first_gc = TAILQ_FIRST(&global_confirms);
@


1.197
log
@thall shalt not code past the eightieth column
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.196 2008/06/12 04:06:00 djm Exp $ */
d1255 7
d1359 1
@


1.196
log
@maintain an ordered queue of outstanding global requests that we
expect replies to, similar to the per-channel confirmation queue.

Use this queue to verify success or failure for remote forward
establishment in a race free way.

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.195 2008/06/12 03:40:52 djm Exp $ */
d142 2
a143 2
static int exit_status;		/* Used to store the exit status of the command. */
static int stdin_eof;		/* EOF has been encountered on standard error. */
d387 4
a390 1
			/* EOF.  Record that we have seen it and send EOF to server. */
d599 2
a600 1
		atomicio(vwrite, fileno(stdout), buffer_ptr(bout), buffer_len(bout));
d602 2
a603 1
		atomicio(vwrite, fileno(stderr), buffer_ptr(berr), buffer_len(berr));
d643 7
a649 3
			/* Received EOF.  The remote host has closed the connection. */
			snprintf(buf, sizeof buf, "Connection to %.300s closed by remote host.\r\n",
				 host);
d662 7
a668 3
			/* An error has encountered.  Perhaps there is a network problem. */
			snprintf(buf, sizeof buf, "Read from remote host %.300s: %.100s\r\n",
				 host, strerror(errno));
d940 1
a940 2
				/* Suspend the program. */
				/* Print a message to that effect to the user. */
d967 2
a968 1
						logit("Server does not support re-keying");
d978 3
a980 2
				 * Detach the program (continue to serve connections,
				 * but put in background and no more new connections).
d1009 3
a1011 3
					 * Sending SSH_CMSG_EOF alone does not always appear
					 * to be enough.  So we try to send an EOF character
					 * first.
d1090 2
a1091 2
			 * The previous character was not an escape char. Check if this
			 * is an escape.
d1094 4
a1097 1
				/* It is. Set the flag and continue to next character. */
d1133 2
a1134 1
				snprintf(buf, sizeof buf, "read: %.100s\r\n", strerror(errno));
d1158 3
a1160 2
			 * Normal, successful read.  But we have an escape character
			 * and have to process the characters one by one.
d1188 2
a1189 1
				snprintf(buf, sizeof buf, "write stdout: %.50s\r\n", strerror(errno));
d1208 4
a1211 1
				/* EOF or error, but can't even print error message. */
d1237 2
a1238 1
	dispatch_run(DISPATCH_NONBLOCK, &quit_pending, compat20 ? xxx_kex : NULL);
d1442 4
a1445 1
		/* Send as much buffered packet data as possible to the sender. */
d1490 2
a1491 1
		snprintf(buf, sizeof buf, "Connection to %.64s closed.\r\n", host);
d1527 2
a1528 2
	debug("Transferred: stdin %lu, stdout %lu, stderr %lu bytes in %.1f seconds",
	    stdin_bytes, stdout_bytes, stderr_bytes, total_time);
d1654 2
a1655 1
		error("Warning: this is probably a break-in attempt by a malicious server.");
d1688 2
a1689 1
		error("Warning: this is probably a break-in attempt by a malicious server.");
d1809 2
a1810 1
		error("client_input_channel_req: channel %d: unknown channel", id);
d1976 1
d1996 1
d2004 1
@


1.195
log
@Enable ~ escapes for multiplex slave sessions; give each channel
its own escape state and hook the escape filters up to muxed
channels. bz #1331

Mux slaves do not currently support the ~^Z and ~& escapes.

NB. this change cranks the mux protocol version, so a new ssh
mux client will not be able to connect to a running old ssh
mux master.

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.194 2008/05/19 20:53:52 djm Exp $ */
d169 11
d474 12
a486 1
	client_global_request_reply_fwd(type, seq, ctxt);
d500 2
d719 21
@


1.194
log
@unbreak tree by committing this bit that I missed from:

Fix sending tty modes when stdin is not a tty (bz#1199). Previously
we would send the modes corresponding to a zeroed struct termios,
whereas we should have been sending an empty list of modes.
Based on patch from daniel.ritz AT alcatel.ch; ok dtucker@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.193 2008/05/09 16:21:13 markus Exp $ */
d139 2
a140 2
static int escape_char;		/* Escape character. */
static int escape_pending;	/* Last character was the escape character */
d157 7
d387 2
a388 2
			if ((u_char) buf[0] == escape_char)
				escape_pending = 1;
d815 3
a817 1
/* process the characters one by one */
d819 2
a820 1
process_escapes(Buffer *bin, Buffer *bout, Buffer *berr, char *buf, int len)
d828 2
d831 11
d849 1
a849 1
		if (escape_pending) {
d852 1
a852 1
			escape_pending = 0;
d858 2
a859 1
				snprintf(string, sizeof string, "%c.\r\n", escape_char);
d862 6
a867 1
				quit_pending = 1;
d871 11
d884 2
a885 1
				snprintf(string, sizeof string, "%c^Z [suspend ssh]\r\n", escape_char);
d917 2
d967 19
a985 1
				snprintf(string, sizeof string,
d988 9
a996 9
%c.  - terminate connection\r\n\
%cB  - send a BREAK to the remote system\r\n\
%cC  - open a command line\r\n\
%cR  - Request rekey (SSH protocol 2 only)\r\n\
%c^Z - suspend ssh\r\n\
%c#  - list forwarded connections\r\n\
%c&  - background ssh (when waiting for connections to terminate)\r\n\
%c?  - this message\r\n\
%c%c  - send the escape character by typing it twice\r\n\
d998 7
a1004 3
				    escape_char, escape_char, escape_char, escape_char,
				    escape_char, escape_char, escape_char, escape_char,
				    escape_char, escape_char, escape_char);
d1009 2
a1010 1
				snprintf(string, sizeof string, "%c#\r\n", escape_char);
d1036 1
a1036 1
				escape_pending = 1;
d1087 1
a1087 1
		} else if (escape_char == SSH_ESCAPECHAR_NONE) {
d1098 2
a1099 2
			if (process_escapes(&stdin_buffer, &stdout_buffer,
			    &stderr_buffer, buf, len) == -1)
d1174 14
a1187 2
static int
simple_escape_filter(Channel *c, char *buf, int len)
d1192 2
a1193 1
	return process_escapes(&c->input, &c->output, &c->extended, buf, len);
d1225 1
a1225 1
	escape_pending = 0;
d1252 1
a1252 1
	escape_char = escape_char_arg;
d1280 1
a1280 1
		if (escape_char != SSH_ESCAPECHAR_NONE)
d1282 2
a1283 1
			    simple_escape_filter, NULL);
@


1.193
log
@unbreak
	ssh -2 localhost od /bin/ls | true
ignoring SIGPIPE by adding a new channel message (EOW) that signals
the peer that we're not interested in any data it might send.
fixes bz #85; discussion, debugging and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.192 2008/05/09 14:18:44 djm Exp $ */
a1713 1
		struct termios tio;
d1726 3
a1728 2
		tio = get_saved_tio();
		tty_make_modes(-1, tiop != NULL ? tiop : &tio);
@


1.192
log
@tidy up session multiplexing code, moving it into its own file and
making the function names more consistent - making ssh.c and
clientloop.c a fair bit more readable.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.191 2008/05/09 04:55:56 djm Exp $ */
d1655 3
@


1.191
log
@Try additional addresses when connecting to a port forward destination
whose DNS name resolves to more than one address. The previous behaviour
was to try the first address and give up.

Reported by stig AT venaas.com in bz#343

great feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.190 2008/05/08 13:06:10 djm Exp $ */
d116 1
a116 1
extern int control_fd;
a156 11
struct confirm_ctx {
	int want_tty;
	int want_subsys;
	int want_x_fwd;
	int want_agent_fwd;
	Buffer cmd;
	char *term;
	struct termios tio;
	char **env;
};

d522 2
a523 2
	if (control_fd != -1)
		FD_SET(control_fd, *readsetp);
a690 278
client_extra_session2_setup(int id, void *arg)
{
	struct confirm_ctx *cctx = arg;
	const char *display;
	Channel *c;
	int i;

	if (cctx == NULL)
		fatal("%s: cctx == NULL", __func__);
	if ((c = channel_lookup(id)) == NULL)
		fatal("%s: no channel for id %d", __func__, id);

	display = getenv("DISPLAY");
	if (cctx->want_x_fwd && options.forward_x11 && display != NULL) {
		char *proto, *data;
		/* Get reasonable local authentication information. */
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted, &proto, &data);
		/* Request forwarding with authentication spoofing. */
		debug("Requesting X11 forwarding with authentication spoofing.");
		x11_request_forwarding_with_spoofing(id, display, proto, data);
		/* XXX wait for reply */
	}

	if (cctx->want_agent_fwd && options.forward_agent) {
		debug("Requesting authentication agent forwarding.");
		channel_request_start(id, "auth-agent-req@@openssh.com", 0);
		packet_send();
	}

	client_session2_setup(id, cctx->want_tty, cctx->want_subsys,
	    cctx->term, &cctx->tio, c->rfd, &cctx->cmd, cctx->env);

	c->open_confirm_ctx = NULL;
	buffer_free(&cctx->cmd);
	xfree(cctx->term);
	if (cctx->env != NULL) {
		for (i = 0; cctx->env[i] != NULL; i++)
			xfree(cctx->env[i]);
		xfree(cctx->env);
	}
	xfree(cctx);
}

static void
client_process_control(fd_set *readset)
{
	Buffer m;
	Channel *c;
	int client_fd, new_fd[3], ver, allowed, window, packetmax;
	socklen_t addrlen;
	struct sockaddr_storage addr;
	struct confirm_ctx *cctx;
	char *cmd;
	u_int i, j, len, env_len, command, flags;
	uid_t euid;
	gid_t egid;

	/*
	 * Accept connection on control socket
	 */
	if (control_fd == -1 || !FD_ISSET(control_fd, readset))
		return;

	memset(&addr, 0, sizeof(addr));
	addrlen = sizeof(addr);
	if ((client_fd = accept(control_fd,
	    (struct sockaddr*)&addr, &addrlen)) == -1) {
		error("%s accept: %s", __func__, strerror(errno));
		return;
	}

	if (getpeereid(client_fd, &euid, &egid) < 0) {
		error("%s getpeereid failed: %s", __func__, strerror(errno));
		close(client_fd);
		return;
	}
	if ((euid != 0) && (getuid() != euid)) {
		error("control mode uid mismatch: peer euid %u != uid %u",
		    (u_int) euid, (u_int) getuid());
		close(client_fd);
		return;
	}

	unset_nonblock(client_fd);

	/* Read command */
	buffer_init(&m);
	if (ssh_msg_recv(client_fd, &m) == -1) {
		error("%s: client msg_recv failed", __func__);
		close(client_fd);
		buffer_free(&m);
		return;
	}
	if ((ver = buffer_get_char(&m)) != SSHMUX_VER) {
		error("%s: wrong client version %d", __func__, ver);
		buffer_free(&m);
		close(client_fd);
		return;
	}

	allowed = 1;
	command = buffer_get_int(&m);
	flags = buffer_get_int(&m);

	buffer_clear(&m);

	switch (command) {
	case SSHMUX_COMMAND_OPEN:
		if (options.control_master == SSHCTL_MASTER_ASK ||
		    options.control_master == SSHCTL_MASTER_AUTO_ASK)
			allowed = ask_permission("Allow shared connection "
			    "to %s? ", host);
		/* continue below */
		break;
	case SSHMUX_COMMAND_TERMINATE:
		if (options.control_master == SSHCTL_MASTER_ASK ||
		    options.control_master == SSHCTL_MASTER_AUTO_ASK)
			allowed = ask_permission("Terminate shared connection "
			    "to %s? ", host);
		if (allowed)
			quit_pending = 1;
		/* FALLTHROUGH */
	case SSHMUX_COMMAND_ALIVE_CHECK:
		/* Reply for SSHMUX_COMMAND_TERMINATE and ALIVE_CHECK */
		buffer_clear(&m);
		buffer_put_int(&m, allowed);
		buffer_put_int(&m, getpid());
		if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
			error("%s: client msg_send failed", __func__);
			close(client_fd);
			buffer_free(&m);
			return;
		}
		buffer_free(&m);
		close(client_fd);
		return;
	default:
		error("Unsupported command %d", command);
		buffer_free(&m);
		close(client_fd);
		return;
	}

	/* Reply for SSHMUX_COMMAND_OPEN */
	buffer_clear(&m);
	buffer_put_int(&m, allowed);
	buffer_put_int(&m, getpid());
	if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
		error("%s: client msg_send failed", __func__);
		close(client_fd);
		buffer_free(&m);
		return;
	}

	if (!allowed) {
		error("Refused control connection");
		close(client_fd);
		buffer_free(&m);
		return;
	}

	buffer_clear(&m);
	if (ssh_msg_recv(client_fd, &m) == -1) {
		error("%s: client msg_recv failed", __func__);
		close(client_fd);
		buffer_free(&m);
		return;
	}
	if ((ver = buffer_get_char(&m)) != SSHMUX_VER) {
		error("%s: wrong client version %d", __func__, ver);
		buffer_free(&m);
		close(client_fd);
		return;
	}

	cctx = xcalloc(1, sizeof(*cctx));
	cctx->want_tty = (flags & SSHMUX_FLAG_TTY) != 0;
	cctx->want_subsys = (flags & SSHMUX_FLAG_SUBSYS) != 0;
	cctx->want_x_fwd = (flags & SSHMUX_FLAG_X11_FWD) != 0;
	cctx->want_agent_fwd = (flags & SSHMUX_FLAG_AGENT_FWD) != 0;
	cctx->term = buffer_get_string(&m, &len);

	cmd = buffer_get_string(&m, &len);
	buffer_init(&cctx->cmd);
	buffer_append(&cctx->cmd, cmd, strlen(cmd));

	env_len = buffer_get_int(&m);
	env_len = MIN(env_len, 4096);
	debug3("%s: receiving %d env vars", __func__, env_len);
	if (env_len != 0) {
		cctx->env = xcalloc(env_len + 1, sizeof(*cctx->env));
		for (i = 0; i < env_len; i++)
			cctx->env[i] = buffer_get_string(&m, &len);
		cctx->env[i] = NULL;
	}

	debug2("%s: accepted tty %d, subsys %d, cmd %s", __func__,
	    cctx->want_tty, cctx->want_subsys, cmd);
	xfree(cmd);

	/* Gather fds from client */
	for(i = 0; i < 3; i++) {
		if ((new_fd[i] = mm_receive_fd(client_fd)) == -1) {
			error("%s: failed to receive fd %d from slave",
			    __func__, i);
			for (j = 0; j < i; j++)
				close(new_fd[j]);
			for (j = 0; j < env_len; j++)
				xfree(cctx->env[j]);
			if (env_len > 0)
				xfree(cctx->env);
			xfree(cctx->term);
			buffer_free(&cctx->cmd);
			close(client_fd);
			xfree(cctx);
			return;
		}
	}

	debug2("%s: got fds stdin %d, stdout %d, stderr %d", __func__,
	    new_fd[0], new_fd[1], new_fd[2]);

	/* Try to pick up ttymodes from client before it goes raw */
	if (cctx->want_tty && tcgetattr(new_fd[0], &cctx->tio) == -1)
		error("%s: tcgetattr: %s", __func__, strerror(errno));

	/* This roundtrip is just for synchronisation of ttymodes */
	buffer_clear(&m);
	if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
		error("%s: client msg_send failed", __func__);
		close(client_fd);
		close(new_fd[0]);
		close(new_fd[1]);
		close(new_fd[2]);
		buffer_free(&m);
		xfree(cctx->term);
		if (env_len != 0) {
			for (i = 0; i < env_len; i++)
				xfree(cctx->env[i]);
			xfree(cctx->env);
		}
		return;
	}
	buffer_free(&m);

	/* enable nonblocking unless tty */
	if (!isatty(new_fd[0]))
		set_nonblock(new_fd[0]);
	if (!isatty(new_fd[1]))
		set_nonblock(new_fd[1]);
	if (!isatty(new_fd[2]))
		set_nonblock(new_fd[2]);

	set_nonblock(client_fd);

	window = CHAN_SES_WINDOW_DEFAULT;
	packetmax = CHAN_SES_PACKET_DEFAULT;
	if (cctx->want_tty) {
		window >>= 1;
		packetmax >>= 1;
	}
	
	c = channel_new("session", SSH_CHANNEL_OPENING,
	    new_fd[0], new_fd[1], new_fd[2], window, packetmax,
	    CHAN_EXTENDED_WRITE, "client-session", /*nonblock*/0);

	/* XXX */
	c->ctl_fd = client_fd;

	debug3("%s: channel_new: %d", __func__, c->self);

	channel_send_open(c->self);
	channel_register_open_confirm(c->self,
	    client_extra_session2_setup, cctx);
}

static void
d1154 2
a1155 2
	if (control_fd != -1)
		max_fd = MAX(max_fd, control_fd);
d1275 4
a1278 1
		client_process_control(readset);
d1860 1
a1860 1
	if (options.control_path != NULL && control_fd != -1)
@


1.190
log
@Use new channel status confirmation callback system to properly deal
with "important" channel requests that fail, in particular command exec,
shell and subsystem requests. Previously we would optimistically assume
that the requests would always succeed, which could cause hangs if they
did not (e.g. when the server runs out of fds) or were unimplemented by
the server (bz #1384)

Also, properly report failing multiplex channel requests via the mux
client stderr (subject to LogLevel in the mux master) - better than
silently failing.

most bits ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.189 2008/05/08 12:02:23 djm Exp $ */
a1756 1
	int sock;
d1765 6
a1770 2
	debug("client_request_forwarded_tcpip: listen %s port %d, originator %s port %d",
	    listen_address, listen_port, originator_address, originator_port);
a1771 10
	sock = channel_connect_by_listen_address(listen_port);
	if (sock < 0) {
		xfree(originator_address);
		xfree(listen_address);
		return NULL;
	}
	c = channel_new("forwarded-tcpip",
	    SSH_CHANNEL_CONNECTING, sock, sock, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0,
	    originator_address, 1);
@


1.189
log
@Implement a channel success/failure status confirmation callback
mechanism. Each channel maintains a queue of callbacks, which will
be drained in order (RFC4253 guarantees confirm messages are not
reordered within an channel).

Also includes a abandonment callback to clean up if a channel is
closed without sending confirmation messages. This probably
shouldn't happen in compliant implementations, but it could be
abused to leak memory.

ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.188 2008/02/22 20:44:02 dtucker Exp $ */
d168 5
d645 1
a645 1
client_subsystem_reply(int type, u_int32_t seq, void *ctxt)
d647 41
a687 2
	int id;
	Channel *c;
d689 4
a692 2
	id = packet_get_int();
	packet_check_eom();
d694 2
a695 4
	if ((c = channel_lookup(id)) == NULL) {
		error("%s: no channel for id %d", __func__, id);
		return;
	}
d697 2
a698 6
	if (type == SSH2_MSG_CHANNEL_SUCCESS)
		debug2("Request suceeded on channel %d", id);
	else if (type == SSH2_MSG_CHANNEL_FAILURE) {
		error("Request failed on channel %d", id);
		channel_free(c);
	}
d733 1
a733 2
	    cctx->term, &cctx->tio, c->rfd, &cctx->cmd, cctx->env,
	    client_subsystem_reply);
d1400 3
a1402 1
	/* XXX we assume c->extended is writeable */
d1992 1
a1992 2
    const char *term, struct termios *tiop, int in_fd, Buffer *cmd, char **env,
    dispatch_fn *subsys_repl)
d2010 2
a2011 1
		channel_request_start(id, "pty-req", 0);
d2066 4
a2069 8
			debug("Sending subsystem: %.*s", len, (u_char*)buffer_ptr(cmd));
			channel_request_start(id, "subsystem", subsys_repl != NULL);
			if (subsys_repl != NULL) {
				/* register callback for reply */
				/* XXX we assume that client_loop has already been called */
				dispatch_set(SSH2_MSG_CHANNEL_FAILURE, subsys_repl);
				dispatch_set(SSH2_MSG_CHANNEL_SUCCESS, subsys_repl);
			}
d2071 4
a2074 2
			debug("Sending command: %.*s", len, (u_char*)buffer_ptr(cmd));
			channel_request_start(id, "exec", 0);
d2079 2
a2080 1
		channel_request_start(id, "shell", 0);
@


1.188
log
@Allow all SSH2 packet types, including UNIMPLEMENTED to reset the
keepalive timer (bz #1307).  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.187 2008/01/23 01:56:54 dtucker Exp $ */
d69 1
d696 1
a696 1
	c->confirm_ctx = NULL;
d936 2
a937 1
	channel_register_confirm(c->self, client_extra_session2_setup, cctx);
d2059 2
@


1.187
log
@Revert the change for bz #1307 as it causes connection aborts if an IGNORE
packet arrives while we're waiting in packet_read_expect (and possibly
elsewhere).
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.183 2007/11/03 00:36:14 djm Exp $ */
a151 1
static int server_alive_timeouts = 0;
d461 1
a461 1
	server_alive_timeouts = 0;
d468 1
a468 1
	if (++server_alive_timeouts > options.server_alive_count_max) {
@


1.186
log
@fd leak on session multiplexing error path. Report and patch from
gregory_shively AT fanniemae.com
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.185 2007/12/28 22:34:47 dtucker Exp $ */
a459 6
client_global_keepalive(int type, u_int32_t seq, void *ctxt)
{
	server_alive_timeouts = 0;
}

static void
a2065 2
	dispatch_set(SSH2_MSG_IGNORE, &client_global_keepalive);
	dispatch_set(SSH2_MSG_UNIMPLEMENTED, &client_global_keepalive);
@


1.185
log
@Use the correct packet maximum sizes for remote port and agent forwarding.
Prevents the server from killing the connection if too much data is queued
and an excessively large packet gets sent.  bz #1360, ok djm@@.
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.184 2007/12/28 15:32:24 dtucker Exp $ */
d883 1
@


1.184
log
@Make SSH2_MSG_UNIMPLEMENTED and SSH2_MSG_IGNORE messages reset the
ServerAlive and ClientAlive timers.  Prevents dropping a connection
when these are enabled but the peer does not support our keepalives.
bz #1307, ok djm@@.
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.183 2007/11/03 00:36:14 djm Exp $ */
d1740 1
a1740 1
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_WINDOW_DEFAULT, 0,
d1798 1
a1798 1
	    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_WINDOW_DEFAULT, 0,
@


1.183
log
@fix memory leak in process_cmdline(), patch from Jan.Pechanec AT Sun.COM;
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.182 2007/09/04 03:21:03 djm Exp $ */
d460 6
d2071 2
@


1.182
log
@make file descriptor passing code return an error rather than call fatal()
when it encounters problems, and use this to make session multiplexing
masters survive slaves failing to pass all stdio FDs; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.181 2007/08/15 08:14:46 markus Exp $ */
d948 3
d1050 4
@


1.181
log
@do NOT fall back to the trused x11 cookie if generation of an untrusted
cookie fails; from security-alert at sun.com; ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.180 2007/08/07 07:32:53 djm Exp $ */
d717 1
a717 1
	u_int i, len, env_len, command, flags;
d865 16
a880 3
	new_fd[0] = mm_receive_fd(client_fd);
	new_fd[1] = mm_receive_fd(client_fd);
	new_fd[2] = mm_receive_fd(client_fd);
@


1.180
log
@bz#1232: ensure that any specified LocalCommand is executed after the
tunnel device is opened. Also, make failures to open a tunnel device
fatal when ExitOnForwardFailure is active.
Reported by h.goebel AT goebel-consult.de; ok dtucker markus reyk deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.179 2007/03/20 03:56:12 tedu Exp $ */
d285 23
a307 13
		snprintf(cmd, sizeof(cmd),
		    "%s %s%s list %s 2>" _PATH_DEVNULL,
		    xauth_path,
		    generated ? "-f " : "" ,
		    generated ? xauthfile : "",
		    display);
		debug2("x11_get_proto: %s", cmd);
		f = popen(cmd, "r");
		if (f && fgets(line, sizeof(line), f) &&
		    sscanf(line, "%*s %511s %511s", proto, data) == 2)
			got_data = 1;
		if (f)
			pclose(f);
@


1.179
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.178 2007/02/20 10:25:14 djm Exp $ */
d1766 38
@


1.178
log
@set maximum packet and window sizes the same for multiplexed clients
as normal connections; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.177 2007/01/21 01:41:54 stevesk Exp $ */
d930 1
a930 1
	while (*s && isspace(*s))
d977 2
a978 3
	s++;
	while (*s && isspace(*s))
		s++;
@


1.177
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.176 2006/10/11 12:38:03 markus Exp $ */
d702 1
a702 1
	int client_fd, new_fd[3], ver, allowed;
d895 7
d903 1
a903 2
	    new_fd[0], new_fd[1], new_fd[2],
	    CHAN_SES_WINDOW_DEFAULT, CHAN_SES_PACKET_DEFAULT,
@


1.176
log
@exit instead of doing a blocking tcp send if we detect a client/server timeout,
since the tcp sendqueue might be already full (of alive requests); ok dtucker, report mpf
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.175 2006/08/03 03:34:42 deraadt Exp $ */
d1752 1
a1752 1
	sock =  ssh_get_authentication_socket();
@


1.175
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.174 2006/08/01 23:22:47 stevesk Exp $ */
d459 4
a462 2
	if (++server_alive_timeouts > options.server_alive_count_max)
		packet_disconnect("Timeout, server not responding.");
@


1.175.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.176 2006/10/11 12:38:03 markus Exp $ */
d459 2
a460 4
	if (++server_alive_timeouts > options.server_alive_count_max) {
		logit("Timeout, server not responding.");
		cleanup_exit(255);
	}
@


1.174
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.173 2006/07/26 13:57:17 stevesk Exp $ */
a61 1
#include "includes.h"
d63 1
a64 1
#include <sys/types.h>
d78 1
d81 1
a84 1
#include "xmalloc.h"
a89 2
#include "buffer.h"
#include "bufaux.h"
d91 1
@


1.173
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.172 2006/07/26 02:35:17 stevesk Exp $ */
d75 1
@


1.172
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.171 2006/07/25 02:59:21 stevesk Exp $ */
d75 1
@


1.171
log
@move #include <sys/time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.170 2006/07/22 20:48:22 stevesk Exp $ */
d69 1
@


1.170
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.169 2006/07/17 01:31:09 stevesk Exp $ */
d68 1
@


1.169
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.168 2006/07/11 20:07:25 stevesk Exp $ */
d73 1
@


1.168
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.167 2006/07/11 18:50:47 markus Exp $ */
d74 1
@


1.167
log
@add ExitOnForwardFailure: terminate the connection if ssh(1)
cannot set up all requested dynamic, local, and remote port
forwardings. ok djm, dtucker, stevesk, jmc
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.166 2006/07/08 21:47:12 stevesk Exp $ */
d70 1
@


1.166
log
@move #include <sys/socket.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.165 2006/07/02 23:01:55 stevesk Exp $ */
d995 1
a995 1
			channel_request_remote_forwarding(fwd.listen_host,
d997 4
a1000 1
			    fwd.connect_port);
@


1.165
log
@use -KR[bind_address:]port here; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.164 2006/06/26 10:36:15 djm Exp $ */
d67 1
@


1.164
log
@mention optional bind_address in runtime port forwarding setup
command-line help. patch from santhi.amirta AT gmail.com
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.163 2006/05/16 09:00:00 markus Exp $ */
d928 1
a928 1
		logit("      -KR[bind_address:]hostport             "
@


1.163
log
@missing free; from Kylene Hall
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.162 2006/04/20 09:27:09 djm Exp $ */
d924 6
a929 3
		logit("      -Lport:host:hostport    Request local forward");
		logit("      -Rport:host:hostport    Request remote forward");
		logit("      -KRhostport             Cancel remote forward");
d932 2
a933 1
		logit("      !args                   Execute local command");
@


1.162
log
@replace the last non-sig_atomic_t flag used in a signal handler with a
sig_atomic_t, unfortunately with some knock-on effects in other (non-
signal) contexts in which it is used; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.161 2006/03/25 18:30:55 deraadt Exp $ */
d843 1
@


1.161
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.160 2006/03/25 13:17:01 djm Exp $ */
d130 1
a130 1
static int quit_pending;	/* Set to non-zero to quit the client loop. */
@


1.160
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d581 1
a581 1
client_process_net_input(fd_set * readset)
d689 1
a689 1
client_process_control(fd_set * readset)
d1183 1
a1183 1
client_process_input(fd_set * readset)
d1236 1
a1236 1
client_process_output(fd_set * writeset)
@


1.159
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.158
log
@sprinkle u_int throughout pty subsystem, ok markus
@
text
@d819 1
a819 2
	cctx = xmalloc(sizeof(*cctx));
	memset(cctx, 0, sizeof(*cctx));
d834 1
a834 1
		cctx->env = xmalloc(sizeof(*cctx->env) * (env_len + 1));
@


1.157
log
@ARGSUSED for signal handlers
@
text
@d433 4
a436 4
		packet_put_int(ws.ws_row);
		packet_put_int(ws.ws_col);
		packet_put_int(ws.ws_xpixel);
		packet_put_int(ws.ws_ypixel);
d1880 4
a1883 4
		packet_put_int(ws.ws_col);
		packet_put_int(ws.ws_row);
		packet_put_int(ws.ws_xpixel);
		packet_put_int(ws.ws_ypixel);
@


1.156
log
@RCSID() can die
@
text
@d189 1
a189 1

d201 1
a201 1

@


1.155
log
@move #include <ctype.h> out of includes.h; ok djm@@
@
text
@a61 1
RCSID("$OpenBSD: clientloop.c,v 1.154 2006/02/20 17:19:54 stevesk Exp $");
@


1.155.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: clientloop.c,v 1.175 2006/08/03 03:34:42 deraadt Exp $ */
d61 2
d64 1
a65 1
#include <sys/ioctl.h>
a66 3
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/param.h>
a68 1
#include <errno.h>
a70 3
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
a71 2
#include <pwd.h>
#include <unistd.h>
a72 1
#include "xmalloc.h"
d76 1
d82 2
a84 1
#include "cipher.h"
d130 1
a130 1
static volatile sig_atomic_t quit_pending; /* Set non-zero to quit the loop. */
d190 1
a190 1
/*ARGSUSED */
d202 1
a202 1
/*ARGSUSED */
d434 4
a437 4
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
d581 1
a581 1
client_process_net_input(fd_set *readset)
d689 1
a689 1
client_process_control(fd_set *readset)
d820 2
a821 1
	cctx = xcalloc(1, sizeof(*cctx));
d836 1
a836 1
		cctx->env = xcalloc(env_len + 1, sizeof(*cctx->env));
a843 1
	xfree(cmd);
d924 3
a926 6
		logit("      -L[bind_address:]port:host:hostport    "
		    "Request local forward");
		logit("      -R[bind_address:]port:host:hostport    "
		    "Request remote forward");
		logit("      -KR[bind_address:]port                 "
		    "Cancel remote forward");
d929 1
a929 2
		logit("      !args                                  "
		    "Execute local command");
d990 1
a990 1
			if (channel_request_remote_forwarding(fwd.listen_host,
d992 1
a992 4
			    fwd.connect_port) < 0) {
				logit("Port forwarding failed.");
				goto out;
			}
d1184 1
a1184 1
client_process_input(fd_set *readset)
d1237 1
a1237 1
client_process_output(fd_set *writeset)
d1881 4
a1884 4
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
@


1.155.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.176 2006/10/11 12:38:03 markus Exp $ */
d459 2
a460 4
	if (++server_alive_timeouts > options.server_alive_count_max) {
		logit("Timeout, server not responding.");
		cleanup_exit(255);
	}
@


1.154
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.153 2006/02/20 17:02:44 stevesk Exp $");
d68 1
@


1.153
log
@move #include <signal.h> out of includes.h; ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.152 2006/02/10 00:27:13 stevesk Exp $");
d65 2
@


1.152
log
@move #include <sys/ioctl.h> out of includes.h; ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.151 2006/02/08 12:15:27 stevesk Exp $");
d67 1
@


1.151
log
@move #include <paths.h> out of includes.h; ok markus@@
@
text
@d62 3
a64 1
RCSID("$OpenBSD: clientloop.c,v 1.150 2006/02/07 01:42:00 stevesk Exp $");
@


1.150
log
@move #include <termios.h> out of includes.h; ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.149 2005/12/30 15:56:37 reyk Exp $");
d64 1
@


1.149
log
@add channel output filter interface.

ok djm@@, suggested by markus@@
@
text
@d62 3
a64 1
RCSID("$OpenBSD: clientloop.c,v 1.148 2005/12/28 22:46:06 stevesk Exp $");
@


1.148
log
@use 'break-in' for consistency; ok deraadt@@ ok and input jmc@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.147 2005/12/07 03:52:22 djm Exp $");
d1389 1
a1389 1
			    simple_escape_filter);
@


1.147
log
@reyk forgot to compile with -Werror (missing header)
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.146 2005/12/06 22:38:27 reyk Exp $");
d1691 1
a1691 1
		error("Warning: this is probably a break in attempt by a malicious server.");
d1724 1
a1724 1
		error("Warning: this is probably a break in attempt by a malicious server.");
@


1.146
log
@Add support for tun(4) forwarding over OpenSSH, based on an idea and
initial channel code bits by markus@@. This is a simple and easy way to
use OpenSSH for ad hoc virtual private network connections, e.g.
administrative tunnels or secure wireless access. It's based on a new
ssh channel and works similar to the existing TCP forwarding support,
except that it depends on the tun(4) network interface on both ends of
the connection for layer 2 or layer 3 tunneling. This diff also adds
support for LocalCommand in the ssh(1) client.

ok djm@@, markus@@, jmc@@ (manpages), tested and discussed with others
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.145 2005/10/30 08:52:17 djm Exp $");
d80 1
@


1.145
log
@no need to escape single quotes in comments, no binary change
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.144 2005/10/14 02:29:37 stevesk Exp $");
d917 9
@


1.144
log
@free()->xfree(); ok djm@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.143 2005/10/10 10:23:08 djm Exp $");
d116 1
a116 1
/* Flag indicating whether the user\'s terminal is in non-blocking mode. */
@


1.143
log
@fix regression I introduced in 4.2: X11 forwardings initiated after
a session has exited (e.g. "(sleep 5; xterm) &") would not start.
bz #1086 reported by t8m AT centrum.cz; ok markus@@ dtucker@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.142 2005/09/09 19:18:05 markus Exp $");
d1883 1
a1883 1
				free(name);
d1897 1
a1897 1
				free(name);
d1906 1
a1906 1
			free(name);
@


1.142
log
@typo; from mark at mcs.vuw.ac.nz, bug #1082
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.141 2005/07/16 01:35:24 djm Exp $");
d1382 1
a1382 1
			    client_channel_closed);
@


1.141
log
@spacing
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.140 2005/07/04 00:58:43 djm Exp $");
d269 1
a269 1
		    "%s %s%s list %s . 2>" _PATH_DEVNULL,
@


1.141.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.149 2005/12/30 15:56:37 reyk Exp $");
a79 1
#include "sshconnect.h"
d116 1
a116 1
/* Flag indicating whether the user's terminal is in non-blocking mode. */
d269 1
a269 1
		    "%s %s%s list %s 2>" _PATH_DEVNULL,
a916 9
		if (!options.permit_local_command)
			goto out;
		logit("      !args                   Execute local command");
		goto out;
	}

	if (*s == '!' && options.permit_local_command) {
		s++;
		ssh_local_cmd(s);
d1379 1
a1379 1
			    simple_escape_filter, NULL);
d1382 1
a1382 1
			    client_channel_closed, 0);
d1681 1
a1681 1
		error("Warning: this is probably a break-in attempt by a malicious server.");
d1714 1
a1714 1
		error("Warning: this is probably a break-in attempt by a malicious server.");
d1883 1
a1883 1
				xfree(name);
d1897 1
a1897 1
				xfree(name);
d1906 1
a1906 1
			xfree(name);
@


1.141.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: clientloop.c,v 1.175 2006/08/03 03:34:42 deraadt Exp $ */
d61 2
a63 19
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/param.h>

#include <ctype.h>
#include <errno.h>
#include <paths.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <pwd.h>
#include <unistd.h>

#include "xmalloc.h"
d67 1
d73 2
a75 1
#include "cipher.h"
d121 1
a121 1
static volatile sig_atomic_t quit_pending; /* Set non-zero to quit the loop. */
d181 1
a181 1
/*ARGSUSED */
d193 1
a193 1
/*ARGSUSED */
d425 4
a428 4
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
d572 1
a572 1
client_process_net_input(fd_set *readset)
d680 1
a680 1
client_process_control(fd_set *readset)
d811 2
a812 1
	cctx = xcalloc(1, sizeof(*cctx));
d827 1
a827 1
		cctx->env = xcalloc(env_len + 1, sizeof(*cctx->env));
a834 1
	xfree(cmd);
d915 3
a917 6
		logit("      -L[bind_address:]port:host:hostport    "
		    "Request local forward");
		logit("      -R[bind_address:]port:host:hostport    "
		    "Request remote forward");
		logit("      -KR[bind_address:]port                 "
		    "Cancel remote forward");
d920 1
a920 2
		logit("      !args                                  "
		    "Execute local command");
d981 1
a981 1
			if (channel_request_remote_forwarding(fwd.listen_host,
d983 1
a983 4
			    fwd.connect_port) < 0) {
				logit("Port forwarding failed.");
				goto out;
			}
d1175 1
a1175 1
client_process_input(fd_set *readset)
d1228 1
a1228 1
client_process_output(fd_set *writeset)
d1872 4
a1875 4
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
@


1.141.2.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.176 2006/10/11 12:38:03 markus Exp $ */
d459 2
a460 4
	if (++server_alive_timeouts > options.server_alive_count_max) {
		logit("Timeout, server not responding.");
		cleanup_exit(255);
	}
@


1.140
log
@implement support for X11 and agent forwarding over multiplex slave
connections. Because of protocol limitations, the slave connections inherit
the master's DISPLAY and SSH_AUTH_SOCK rather than distinctly forwarding
their own.

ok dtucker@@ "put it in" deraadt@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.139 2005/06/17 02:44:32 djm Exp $");
d645 1
a645 1
	display = getenv("DISPLAY");	
@


1.139
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.138 2005/06/16 03:38:36 djm Exp $");
d143 2
d636 1
d645 18
d728 1
a728 1
	if ((ver = buffer_get_char(&m)) != 1) {
d762 1
a762 1
		if (ssh_msg_send(client_fd, /* version */1, &m) == -1) {
d782 1
a782 1
	if (ssh_msg_send(client_fd, /* version */1, &m) == -1) {
d803 1
a803 1
	if ((ver = buffer_get_char(&m)) != 1) {
d814 2
d849 1
a849 1
	if (ssh_msg_send(client_fd, /* version */1, &m) == -1) {
@


1.138
log
@move x11_get_proto from ssh.c to clientloop.c, to make muliplexed xfwd easier
later; ok deraadt@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.137 2005/06/08 11:25:09 djm Exp $");
d662 1
a662 1
	int client_fd, new_fd[3], ver, i, allowed;
d667 1
a667 1
	u_int len, env_len, command, flags;
d974 4
a977 1
	for (i = 0; i < len; i++) {
@


1.137
log
@add ControlMaster=auto/autoask options to support opportunistic multiplexing;
tested avsm@@ and jakob@@, ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.136 2005/03/10 22:01:05 deraadt Exp $");
d209 103
@


1.136
log
@spacing
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.135 2005/03/01 10:09:52 djm Exp $");
d619 2
a620 1
		if (options.control_master == 2)
d626 2
a627 1
		if (options.control_master == 2)
@


1.136.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.141 2005/07/16 01:35:24 djm Exp $");
a142 2
	int want_x_fwd;
	int want_agent_fwd;
a210 103
#define SSH_X11_PROTO "MIT-MAGIC-COOKIE-1"
void
client_x11_get_proto(const char *display, const char *xauth_path,
    u_int trusted, char **_proto, char **_data)
{
	char cmd[1024];
	char line[512];
	char xdisplay[512];
	static char proto[512], data[512];
	FILE *f;
	int got_data = 0, generated = 0, do_unlink = 0, i;
	char *xauthdir, *xauthfile;
	struct stat st;

	xauthdir = xauthfile = NULL;
	*_proto = proto;
	*_data = data;
	proto[0] = data[0] = '\0';

	if (xauth_path == NULL ||(stat(xauth_path, &st) == -1)) {
		debug("No xauth program.");
	} else {
		if (display == NULL) {
			debug("x11_get_proto: DISPLAY not set");
			return;
		}
		/*
		 * Handle FamilyLocal case where $DISPLAY does
		 * not match an authorization entry.  For this we
		 * just try "xauth list unix:displaynum.screennum".
		 * XXX: "localhost" match to determine FamilyLocal
		 *      is not perfect.
		 */
		if (strncmp(display, "localhost:", 10) == 0) {
			snprintf(xdisplay, sizeof(xdisplay), "unix:%s",
			    display + 10);
			display = xdisplay;
		}
		if (trusted == 0) {
			xauthdir = xmalloc(MAXPATHLEN);
			xauthfile = xmalloc(MAXPATHLEN);
			strlcpy(xauthdir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
			if (mkdtemp(xauthdir) != NULL) {
				do_unlink = 1;
				snprintf(xauthfile, MAXPATHLEN, "%s/xauthfile",
				    xauthdir);
				snprintf(cmd, sizeof(cmd),
				    "%s -f %s generate %s " SSH_X11_PROTO
				    " untrusted timeout 1200 2>" _PATH_DEVNULL,
				    xauth_path, xauthfile, display);
				debug2("x11_get_proto: %s", cmd);
				if (system(cmd) == 0)
					generated = 1;
			}
		}
		snprintf(cmd, sizeof(cmd),
		    "%s %s%s list %s . 2>" _PATH_DEVNULL,
		    xauth_path,
		    generated ? "-f " : "" ,
		    generated ? xauthfile : "",
		    display);
		debug2("x11_get_proto: %s", cmd);
		f = popen(cmd, "r");
		if (f && fgets(line, sizeof(line), f) &&
		    sscanf(line, "%*s %511s %511s", proto, data) == 2)
			got_data = 1;
		if (f)
			pclose(f);
	}

	if (do_unlink) {
		unlink(xauthfile);
		rmdir(xauthdir);
	}
	if (xauthdir)
		xfree(xauthdir);
	if (xauthfile)
		xfree(xauthfile);

	/*
	 * If we didn't get authentication data, just make up some
	 * data.  The forwarding code will check the validity of the
	 * response anyway, and substitute this data.  The X11
	 * server, however, will ignore this fake data and use
	 * whatever authentication mechanisms it was using otherwise
	 * for the local connection.
	 */
	if (!got_data) {
		u_int32_t rnd = 0;

		logit("Warning: No xauth data; "
		    "using fake authentication data for X11 forwarding.");
		strlcpy(proto, SSH_X11_PROTO, sizeof proto);
		for (i = 0; i < 16; i++) {
			if (i % 4 == 0)
				rnd = arc4random();
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x",
			    rnd & 0xff);
			rnd >>= 8;
		}
	}
}

a530 1
	const char *display;
a538 18
	display = getenv("DISPLAY");
	if (cctx->want_x_fwd && options.forward_x11 && display != NULL) {
		char *proto, *data;
		/* Get reasonable local authentication information. */
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted, &proto, &data);
		/* Request forwarding with authentication spoofing. */
		debug("Requesting X11 forwarding with authentication spoofing.");
		x11_request_forwarding_with_spoofing(id, display, proto, data);
		/* XXX wait for reply */
	}

	if (cctx->want_agent_fwd && options.forward_agent) {
		debug("Requesting authentication agent forwarding.");
		channel_request_start(id, "auth-agent-req@@openssh.com", 0);
		packet_send();
	}

d559 1
a559 1
	int client_fd, new_fd[3], ver, allowed;
d564 1
a564 1
	u_int i, len, env_len, command, flags;
d604 1
a604 1
	if ((ver = buffer_get_char(&m)) != SSHMUX_VER) {
d619 1
a619 2
		if (options.control_master == SSHCTL_MASTER_ASK ||
		    options.control_master == SSHCTL_MASTER_AUTO_ASK)
d625 1
a625 2
		if (options.control_master == SSHCTL_MASTER_ASK ||
		    options.control_master == SSHCTL_MASTER_AUTO_ASK)
d636 1
a636 1
		if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
d656 1
a656 1
	if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
d677 1
a677 1
	if ((ver = buffer_get_char(&m)) != SSHMUX_VER) {
a687 2
	cctx->want_x_fwd = (flags & SSHMUX_FLAG_X11_FWD) != 0;
	cctx->want_agent_fwd = (flags & SSHMUX_FLAG_AGENT_FWD) != 0;
d721 1
a721 1
	if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
d869 1
a869 4
	if (len <= 0)
		return (0);

	for (i = 0; i < (u_int)len; i++) {
@


1.136.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.149 2005/12/30 15:56:37 reyk Exp $");
a79 1
#include "sshconnect.h"
d116 1
a116 1
/* Flag indicating whether the user's terminal is in non-blocking mode. */
d269 1
a269 1
		    "%s %s%s list %s 2>" _PATH_DEVNULL,
a916 9
		if (!options.permit_local_command)
			goto out;
		logit("      !args                   Execute local command");
		goto out;
	}

	if (*s == '!' && options.permit_local_command) {
		s++;
		ssh_local_cmd(s);
d1379 1
a1379 1
			    simple_escape_filter, NULL);
d1382 1
a1382 1
			    client_channel_closed, 0);
d1681 1
a1681 1
		error("Warning: this is probably a break-in attempt by a malicious server.");
d1714 1
a1714 1
		error("Warning: this is probably a break-in attempt by a malicious server.");
d1883 1
a1883 1
				xfree(name);
d1897 1
a1897 1
				xfree(name);
d1906 1
a1906 1
			xfree(name);
@


1.135
log
@bz#413: allow optional specification of bind address for port forwardings.
Patch originally by Dan Astorian, but worked on by several people
Adds GatewayPorts=clientspecified option on server to allow remote forwards
to bind to client-specified ports.

ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.134 2004/11/07 00:01:46 djm Exp $");
d630 1
a630 1
		/* FALLTHROUGH */	
@


1.134
log
@add basic control of a running multiplex master connection; including the
ability to check its status and request it to exit; ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.133 2004/10/29 22:53:56 djm Exp $");
d766 1
a766 3
	char *s, *cmd;
	u_short fwd_port, fwd_host_port;
	char buf[1024], sfwd_port[6], sfwd_host_port[6];
d769 2
d816 8
a823 3
		if (sscanf(s, "%5[0-9]", sfwd_host_port) != 1) {
			logit("Bad forwarding specification.");
			goto out;
d825 2
a826 2
		if ((fwd_host_port = a2port(sfwd_host_port)) == 0) {
			logit("Bad forwarding port(s).");
d829 1
a829 1
		channel_request_rforward_cancel(fwd_host_port);
d831 1
a831 4
		if (sscanf(s, "%5[0-9]:%255[^:]:%5[0-9]",
		    sfwd_port, buf, sfwd_host_port) != 3 &&
		    sscanf(s, "%5[0-9]/%255[^/]/%5[0-9]",
		    sfwd_port, buf, sfwd_host_port) != 3) {
a834 5
		if ((fwd_port = a2port(sfwd_port)) == 0 ||
		    (fwd_host_port = a2port(sfwd_host_port)) == 0) {
			logit("Bad forwarding port(s).");
			goto out;
		}
d836 3
a838 2
			if (channel_setup_local_fwd_listener(fwd_port, buf,
			    fwd_host_port, options.gateway_ports) < 0) {
d842 6
a847 3
		} else
			channel_request_remote_forwarding(fwd_port, buf,
			    fwd_host_port);
@


1.133
log
@factor out common permission-asking code to separate function; ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.132 2004/10/29 21:47:15 djm Exp $");
d564 1
a564 1
	u_int len, env_len;
d594 17
d612 2
a613 3
	if (options.control_master == 2)
		allowed = ask_permission("Allow shared connection to %s? ",
		    host);
d615 1
a615 1
	unset_nonblock(client_fd);
d617 34
a650 1
	buffer_init(&m);
d652 2
d656 1
a656 1
	if (ssh_msg_send(client_fd, /* version */0, &m) == -1) {
a661 1
	buffer_clear(&m);
d670 1
d677 1
a677 2

	if ((ver = buffer_get_char(&m)) != 0) {
d686 2
a687 3

	cctx->want_tty = buffer_get_int(&m);
	cctx->want_subsys = buffer_get_int(&m);
d719 1
d721 1
a721 1
	if (ssh_msg_send(client_fd, /* version */0, &m) == -1) {
d728 6
@


1.132
log
@fix some window size change bugs for multiplexed connections: windows sizes
were not being updated if they had changed after ~^Z suspends and SIGWINCH
was not being processed unless the first connection had requested a tty;
ok markus
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.131 2004/09/07 23:41:30 djm Exp $");
d595 3
a597 18
	if (options.control_master == 2) {
		char *p, prompt[1024];

		allowed = 0;
		snprintf(prompt, sizeof(prompt),
		    "Allow shared connection to %s? ", host);
		p = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);
		if (p != NULL) {
			/*
			 * Accept empty responses and responses consisting
			 * of the word "yes" as affirmative.
			 */
			if (*p == '\0' || *p == '\n' ||
			    strcasecmp(p, "yes") == 0)
				allowed = 1;
			xfree(p);
		}
	}
@


1.131
log
@cleanup multiplex control socket on SIGHUP too, spotted by sturm@@
ok markus@@ deraadt@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.130 2004/08/11 21:43:04 avsm Exp $");
a434 2
	struct winsize oldws, newws;

a450 3
	/* Save old window size. */
	ioctl(fileno(stdin), TIOCGWINSZ, &oldws);

d454 2
a455 7
	/* Check if the window size has changed. */
	if (ioctl(fileno(stdin), TIOCGWINSZ, &newws) >= 0 &&
	    (oldws.ws_row != newws.ws_row ||
	    oldws.ws_col != newws.ws_col ||
	    oldws.ws_xpixel != newws.ws_xpixel ||
	    oldws.ws_ypixel != newws.ws_ypixel))
		received_window_change_signal = 1;
d1197 1
a1197 2
	if (have_pty)
		signal(SIGWINCH, window_change_handler);
d1305 1
a1305 2
	if (have_pty)
		signal(SIGWINCH, SIG_DFL);
d1672 1
d1676 3
d1697 1
@


1.131.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.135 2005/03/01 10:09:52 djm Exp $");
d435 2
d453 3
d459 7
a465 2
	/* Reset window sizes in case they have changed */
	received_window_change_signal = 1;
d574 1
a574 1
	u_int len, env_len, command, flags;
d604 3
a606 1
	unset_nonblock(client_fd);
d608 14
a621 13
	/* Read command */
	buffer_init(&m);
	if (ssh_msg_recv(client_fd, &m) == -1) {
		error("%s: client msg_recv failed", __func__);
		close(client_fd);
		buffer_free(&m);
		return;
	}
	if ((ver = buffer_get_char(&m)) != 1) {
		error("%s: wrong client version %d", __func__, ver);
		buffer_free(&m);
		close(client_fd);
		return;
d624 1
a624 3
	allowed = 1;
	command = buffer_get_int(&m);
	flags = buffer_get_int(&m);
d626 1
a626 36
	buffer_clear(&m);

	switch (command) {
	case SSHMUX_COMMAND_OPEN:
		if (options.control_master == 2)
			allowed = ask_permission("Allow shared connection "
			    "to %s? ", host);
		/* continue below */
		break;
	case SSHMUX_COMMAND_TERMINATE:
		if (options.control_master == 2)
			allowed = ask_permission("Terminate shared connection "
			    "to %s? ", host);
		if (allowed)
			quit_pending = 1;
		/* FALLTHROUGH */	
	case SSHMUX_COMMAND_ALIVE_CHECK:
		/* Reply for SSHMUX_COMMAND_TERMINATE and ALIVE_CHECK */
		buffer_clear(&m);
		buffer_put_int(&m, allowed);
		buffer_put_int(&m, getpid());
		if (ssh_msg_send(client_fd, /* version */1, &m) == -1) {
			error("%s: client msg_send failed", __func__);
			close(client_fd);
			buffer_free(&m);
			return;
		}
		buffer_free(&m);
		close(client_fd);
		return;
	default:
		error("Unsupported command %d", command);
		buffer_free(&m);
		close(client_fd);
		return;
	}
a627 2
	/* Reply for SSHMUX_COMMAND_OPEN */
	buffer_clear(&m);
d630 1
a630 1
	if (ssh_msg_send(client_fd, /* version */1, &m) == -1) {
d636 1
a644 1
	buffer_clear(&m);
d651 2
a652 1
	if ((ver = buffer_get_char(&m)) != 1) {
d661 3
a663 2
	cctx->want_tty = (flags & SSHMUX_FLAG_TTY) != 0;
	cctx->want_subsys = (flags & SSHMUX_FLAG_SUBSYS) != 0;
a694 1
	/* This roundtrip is just for synchronisation of ttymodes */
d696 1
a696 1
	if (ssh_msg_send(client_fd, /* version */1, &m) == -1) {
a702 6
		xfree(cctx->term);
		if (env_len != 0) {
			for (i = 0; i < env_len; i++)
				xfree(cctx->env[i]);
			xfree(cctx->env);
		}
d735 3
a737 1
	char *s, *cmd, *cancel_host;
a739 2
	u_short cancel_port;
	Forward fwd;
d785 3
a787 8
		cancel_port = 0;
		cancel_host = hpdelim(&s);	/* may be NULL */
		if (s != NULL) {
			cancel_port = a2port(s);
			cancel_host = cleanhostname(cancel_host);
		} else {
			cancel_port = a2port(cancel_host);
			cancel_host = NULL;
d789 2
a790 2
		if (cancel_port == 0) {
			logit("Bad forwarding close port");
d793 1
a793 1
		channel_request_rforward_cancel(cancel_host, cancel_port);
d795 4
a798 1
		if (!parse_forward(&fwd, s)) {
d802 5
d808 2
a809 3
			if (channel_setup_local_fwd_listener(fwd.listen_host,
			    fwd.listen_port, fwd.connect_host,
			    fwd.connect_port, options.gateway_ports) < 0) {
d813 3
a815 6
		} else {
			channel_request_remote_forwarding(fwd.listen_host,
			    fwd.listen_port, fwd.connect_host,
			    fwd.connect_port);
		}

d1207 2
a1208 1
	signal(SIGWINCH, window_change_handler);
d1316 2
a1317 1
	signal(SIGWINCH, SIG_DFL);
a1683 1
	Channel *c = NULL;
a1686 3
	if ((c = channel_lookup(id)) == NULL)
		fatal("client_session2_setup: channel %d: unknown channel", id);

a1704 1
		c->client_tty = 1;
@


1.131.2.2
log
@upgrade to OpenSSH 4.1
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.136 2005/03/10 22:01:05 deraadt Exp $");
d630 1
a630 1
		/* FALLTHROUGH */
@


1.131.2.3
log
@upgrade to OpenSSH 4.2
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.141 2005/07/16 01:35:24 djm Exp $");
a142 2
	int want_x_fwd;
	int want_agent_fwd;
a210 103
#define SSH_X11_PROTO "MIT-MAGIC-COOKIE-1"
void
client_x11_get_proto(const char *display, const char *xauth_path,
    u_int trusted, char **_proto, char **_data)
{
	char cmd[1024];
	char line[512];
	char xdisplay[512];
	static char proto[512], data[512];
	FILE *f;
	int got_data = 0, generated = 0, do_unlink = 0, i;
	char *xauthdir, *xauthfile;
	struct stat st;

	xauthdir = xauthfile = NULL;
	*_proto = proto;
	*_data = data;
	proto[0] = data[0] = '\0';

	if (xauth_path == NULL ||(stat(xauth_path, &st) == -1)) {
		debug("No xauth program.");
	} else {
		if (display == NULL) {
			debug("x11_get_proto: DISPLAY not set");
			return;
		}
		/*
		 * Handle FamilyLocal case where $DISPLAY does
		 * not match an authorization entry.  For this we
		 * just try "xauth list unix:displaynum.screennum".
		 * XXX: "localhost" match to determine FamilyLocal
		 *      is not perfect.
		 */
		if (strncmp(display, "localhost:", 10) == 0) {
			snprintf(xdisplay, sizeof(xdisplay), "unix:%s",
			    display + 10);
			display = xdisplay;
		}
		if (trusted == 0) {
			xauthdir = xmalloc(MAXPATHLEN);
			xauthfile = xmalloc(MAXPATHLEN);
			strlcpy(xauthdir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
			if (mkdtemp(xauthdir) != NULL) {
				do_unlink = 1;
				snprintf(xauthfile, MAXPATHLEN, "%s/xauthfile",
				    xauthdir);
				snprintf(cmd, sizeof(cmd),
				    "%s -f %s generate %s " SSH_X11_PROTO
				    " untrusted timeout 1200 2>" _PATH_DEVNULL,
				    xauth_path, xauthfile, display);
				debug2("x11_get_proto: %s", cmd);
				if (system(cmd) == 0)
					generated = 1;
			}
		}
		snprintf(cmd, sizeof(cmd),
		    "%s %s%s list %s . 2>" _PATH_DEVNULL,
		    xauth_path,
		    generated ? "-f " : "" ,
		    generated ? xauthfile : "",
		    display);
		debug2("x11_get_proto: %s", cmd);
		f = popen(cmd, "r");
		if (f && fgets(line, sizeof(line), f) &&
		    sscanf(line, "%*s %511s %511s", proto, data) == 2)
			got_data = 1;
		if (f)
			pclose(f);
	}

	if (do_unlink) {
		unlink(xauthfile);
		rmdir(xauthdir);
	}
	if (xauthdir)
		xfree(xauthdir);
	if (xauthfile)
		xfree(xauthfile);

	/*
	 * If we didn't get authentication data, just make up some
	 * data.  The forwarding code will check the validity of the
	 * response anyway, and substitute this data.  The X11
	 * server, however, will ignore this fake data and use
	 * whatever authentication mechanisms it was using otherwise
	 * for the local connection.
	 */
	if (!got_data) {
		u_int32_t rnd = 0;

		logit("Warning: No xauth data; "
		    "using fake authentication data for X11 forwarding.");
		strlcpy(proto, SSH_X11_PROTO, sizeof proto);
		for (i = 0; i < 16; i++) {
			if (i % 4 == 0)
				rnd = arc4random();
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x",
			    rnd & 0xff);
			rnd >>= 8;
		}
	}
}

a530 1
	const char *display;
a538 18
	display = getenv("DISPLAY");
	if (cctx->want_x_fwd && options.forward_x11 && display != NULL) {
		char *proto, *data;
		/* Get reasonable local authentication information. */
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted, &proto, &data);
		/* Request forwarding with authentication spoofing. */
		debug("Requesting X11 forwarding with authentication spoofing.");
		x11_request_forwarding_with_spoofing(id, display, proto, data);
		/* XXX wait for reply */
	}

	if (cctx->want_agent_fwd && options.forward_agent) {
		debug("Requesting authentication agent forwarding.");
		channel_request_start(id, "auth-agent-req@@openssh.com", 0);
		packet_send();
	}

d559 1
a559 1
	int client_fd, new_fd[3], ver, allowed;
d564 1
a564 1
	u_int i, len, env_len, command, flags;
d604 1
a604 1
	if ((ver = buffer_get_char(&m)) != SSHMUX_VER) {
d619 1
a619 2
		if (options.control_master == SSHCTL_MASTER_ASK ||
		    options.control_master == SSHCTL_MASTER_AUTO_ASK)
d625 1
a625 2
		if (options.control_master == SSHCTL_MASTER_ASK ||
		    options.control_master == SSHCTL_MASTER_AUTO_ASK)
d636 1
a636 1
		if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
d656 1
a656 1
	if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
d677 1
a677 1
	if ((ver = buffer_get_char(&m)) != SSHMUX_VER) {
a687 2
	cctx->want_x_fwd = (flags & SSHMUX_FLAG_X11_FWD) != 0;
	cctx->want_agent_fwd = (flags & SSHMUX_FLAG_AGENT_FWD) != 0;
d721 1
a721 1
	if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
d869 1
a869 4
	if (len <= 0)
		return (0);

	for (i = 0; i < (u_int)len; i++) {
@


1.130
log
@some signed/unsigned int comparison cleanups; markus@@ ok
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.129 2004/07/11 17:48:47 deraadt Exp $");
d1199 2
@


1.129
log
@spaces
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.128 2004/06/18 11:11:54 djm Exp $");
d351 1
a351 1
    int *maxfdp, int *nallocp, int rekeying)
d1150 2
a1151 1
	int max_fd = 0, max_fd2 = 0, len, rekeying = 0, nalloc = 0;
@


1.128
log
@clientloop.c
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.127 2004/06/17 15:10:13 djm Exp $");
d405 1
a405 1
	else {  
d520 1
a520 1
	
d543 1
a543 1
	
d549 1
a549 1
	client_session2_setup(id, cctx->want_tty, cctx->want_subsys, 
d560 1
a560 1
	}			
d617 1
a617 1
			if (*p == '\0' || *p == '\n' || 
d717 1
a717 1
	c = channel_new("session", SSH_CHANNEL_OPENING, 
d1676 1
a1676 1
client_session2_setup(int id, int want_tty, int want_subsystem, 
@


1.127
log
@Add option for confirmation (ControlMaster=ask) via ssh-askpass before opening
shared connections; ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.126 2004/06/17 14:52:48 djm Exp $");
d1629 3
a1631 2
	c = channel_lookup(id);
	if (c == NULL) {
d1650 1
a1650 1
		packet_put_int(c->remote_id);
@


1.126
log
@support environment passing over shared connections; ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.125 2004/06/15 05:45:04 djm Exp $");
d552 1
a552 1
	
d569 1
a569 1
	int client_fd, new_fd[3], ver, i;
d603 20
a622 1
	/* XXX: implement use of ssh-askpass to confirm additional channels */
d628 1
d633 1
d638 7
d648 1
d702 1
@


1.125
log
@missed one unset_nonblock; spotted by Tim Rice
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.124 2004/06/14 01:44:38 djm Exp $");
d146 1
d542 1
d550 1
a550 1
	    cctx->term, &cctx->tio, c->rfd, &cctx->cmd, 
d555 7
a561 2
	free(cctx->term);
	free(cctx);
d569 1
a569 1
	int client_fd, new_fd[3], ver;
d574 1
a574 1
	u_int len;
d641 10
d1646 1
a1646 1
    const char *term, struct termios *tiop, int in_fd, Buffer *cmd, 
d1674 1
a1674 1
	if (options.num_send_env != 0) {
a1675 1
		extern char **environ;
d1679 1
a1679 1
		for (i = 0; environ && environ[i] != NULL; i++) {
d1681 1
a1681 1
			name = xstrdup(environ[i]);
@


1.124
log
@set_nonblock() instead of fnctl(...,O_NONBLOCK); "looks sane" deraadt@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.123 2004/06/13 15:03:02 djm Exp $");
d159 1
a159 1
		(void) fcntl(fileno(stdin), F_SETFL, 0);
@


1.123
log
@implement session multiplexing in the client (the server has supported this
since 2.0); ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.122 2004/05/22 06:32:12 djm Exp $");
d170 1
a170 1
	(void) fcntl(fileno(stdin), F_SETFL, O_NONBLOCK);
@


1.122
log
@use '-h' for help in ~C commandline instead of '-?'; inspired by jmc@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.121 2004/05/21 11:33:11 djm Exp $");
d84 3
d97 3
d140 8
d151 2
a309 3
	if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
		return;

d313 1
a313 6
		channel_request_start(session_ident, "window-change", 0);
		packet_put_int(ws.ws_col);
		packet_put_int(ws.ws_row);
		packet_put_int(ws.ws_xpixel);
		packet_put_int(ws.ws_ypixel);
		packet_send();
d315 2
a347 1

d393 3
d515 170
a1085 3
	if (id != session_ident)
		error("client_channel_closed: id %d != session_ident %d",
		    id, session_ident);
d1119 2
d1238 3
d1572 1
a1572 1
	int id, reply, success = 0;
a1581 6
	if (session_ident == -1) {
		error("client_input_channel_req: no channel %d", session_ident);
	} else if (id != session_ident) {
		error("client_input_channel_req: channel %d: wrong channel: %d",
		    session_ident, id);
	}
d1586 11
a1596 2
		success = 1;
		exit_status = packet_get_int();
d1627 92
d1785 2
@


1.121
log
@bz #756: add support for the cancel-tcpip-forward request for the server and
the client (through the ~C commandline). reported by z3p AT twistedmatrix.com;
ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.120 2004/05/20 10:58:05 dtucker Exp $");
d524 1
a524 1
	if (*s == '?') {
@


1.120
log
@Trivial type fix 0 -> '\0'; ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.119 2004/05/08 00:21:31 djm Exp $");
d509 1
d519 2
d523 14
a536 1
	if (strlen(s) < 2 || s[0] != '-' || !(s[1] == 'L' || s[1] == 'R')) {
d540 1
a540 1
	if (s[1] == 'L')
d542 5
a546 1
	if (!local && !compat20) {
d550 2
a551 1
	s += 2;
d555 21
a575 16
	if (sscanf(s, "%5[0-9]:%255[^:]:%5[0-9]",
	    sfwd_port, buf, sfwd_host_port) != 3 &&
	    sscanf(s, "%5[0-9]/%255[^/]/%5[0-9]",
	    sfwd_port, buf, sfwd_host_port) != 3) {
		logit("Bad forwarding specification.");
		goto out;
	}
	if ((fwd_port = a2port(sfwd_port)) == 0 ||
	    (fwd_host_port = a2port(sfwd_host_port)) == 0) {
		logit("Bad forwarding port(s).");
		goto out;
	}
	if (local) {
		if (channel_setup_local_fwd_listener(fwd_port, buf,
		    fwd_host_port, options.gateway_ports) < 0) {
			logit("Port forwarding failed.");
d578 12
a589 4
	} else
		channel_request_remote_forwarding(fwd_port, buf,
		    fwd_host_port);
	logit("Forwarding port.");
@


1.119
log
@kill a tiny header; ok deraadt@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.118 2004/05/08 00:01:37 deraadt Exp $");
d518 1
a518 1
	if (*s == 0)
@


1.118
log
@make two tiny header files go away; djm ok
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.117 2003/12/16 15:49:51 markus Exp $");
a83 1
#include "readpass.h"
@


1.117
log
@application layer keep alive (ServerAliveInterval ServerAliveCountMax)
for ssh(1), similar to the sshd(8) option; ok beck@@; with help from
jmc and dtucker@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.116 2003/12/09 23:45:32 dtucker Exp $");
d82 1
a82 1
#include "sshtty.h"
@


1.117.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.130 2004/08/11 21:43:04 avsm Exp $");
d82 1
a82 1
#include "sshpty.h"
d84 1
a84 3
#include "monitor_fdpass.h"
#include "match.h"
#include "msg.h"
a94 3
/* Control socket */
extern int control_fd;

a134 9
struct confirm_ctx {
	int want_tty;
	int want_subsys;
	Buffer cmd;
	char *term;
	struct termios tio;
	char **env;
};

a137 2
void ssh_process_session2_setup(int, int, int, Buffer *);

d144 1
a144 1
		unset_nonblock(fileno(stdin));
d155 1
a155 1
	set_nonblock(fileno(stdin));
d295 3
d301 6
a306 1
		channel_send_window_changes();
a307 2
		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
			return;
d339 1
d342 1
a342 1
    int *maxfdp, u_int *nallocp, int rekeying)
a384 3
	if (control_fd != -1)
		FD_SET(control_fd, *readsetp);

d393 1
a393 1
	else {
a503 216
client_subsystem_reply(int type, u_int32_t seq, void *ctxt)
{
	int id;
	Channel *c;

	id = packet_get_int();
	packet_check_eom();

	if ((c = channel_lookup(id)) == NULL) {
		error("%s: no channel for id %d", __func__, id);
		return;
	}

	if (type == SSH2_MSG_CHANNEL_SUCCESS)
		debug2("Request suceeded on channel %d", id);
	else if (type == SSH2_MSG_CHANNEL_FAILURE) {
		error("Request failed on channel %d", id);
		channel_free(c);
	}
}

static void
client_extra_session2_setup(int id, void *arg)
{
	struct confirm_ctx *cctx = arg;
	Channel *c;
	int i;

	if (cctx == NULL)
		fatal("%s: cctx == NULL", __func__);
	if ((c = channel_lookup(id)) == NULL)
		fatal("%s: no channel for id %d", __func__, id);

	client_session2_setup(id, cctx->want_tty, cctx->want_subsys,
	    cctx->term, &cctx->tio, c->rfd, &cctx->cmd, cctx->env,
	    client_subsystem_reply);

	c->confirm_ctx = NULL;
	buffer_free(&cctx->cmd);
	xfree(cctx->term);
	if (cctx->env != NULL) {
		for (i = 0; cctx->env[i] != NULL; i++)
			xfree(cctx->env[i]);
		xfree(cctx->env);
	}
	xfree(cctx);
}

static void
client_process_control(fd_set * readset)
{
	Buffer m;
	Channel *c;
	int client_fd, new_fd[3], ver, i, allowed;
	socklen_t addrlen;
	struct sockaddr_storage addr;
	struct confirm_ctx *cctx;
	char *cmd;
	u_int len, env_len;
	uid_t euid;
	gid_t egid;

	/*
	 * Accept connection on control socket
	 */
	if (control_fd == -1 || !FD_ISSET(control_fd, readset))
		return;

	memset(&addr, 0, sizeof(addr));
	addrlen = sizeof(addr);
	if ((client_fd = accept(control_fd,
	    (struct sockaddr*)&addr, &addrlen)) == -1) {
		error("%s accept: %s", __func__, strerror(errno));
		return;
	}

	if (getpeereid(client_fd, &euid, &egid) < 0) {
		error("%s getpeereid failed: %s", __func__, strerror(errno));
		close(client_fd);
		return;
	}
	if ((euid != 0) && (getuid() != euid)) {
		error("control mode uid mismatch: peer euid %u != uid %u",
		    (u_int) euid, (u_int) getuid());
		close(client_fd);
		return;
	}

	allowed = 1;
	if (options.control_master == 2) {
		char *p, prompt[1024];

		allowed = 0;
		snprintf(prompt, sizeof(prompt),
		    "Allow shared connection to %s? ", host);
		p = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);
		if (p != NULL) {
			/*
			 * Accept empty responses and responses consisting
			 * of the word "yes" as affirmative.
			 */
			if (*p == '\0' || *p == '\n' ||
			    strcasecmp(p, "yes") == 0)
				allowed = 1;
			xfree(p);
		}
	}

	unset_nonblock(client_fd);

	buffer_init(&m);

	buffer_put_int(&m, allowed);
	buffer_put_int(&m, getpid());
	if (ssh_msg_send(client_fd, /* version */0, &m) == -1) {
		error("%s: client msg_send failed", __func__);
		close(client_fd);
		buffer_free(&m);
		return;
	}
	buffer_clear(&m);

	if (!allowed) {
		error("Refused control connection");
		close(client_fd);
		buffer_free(&m);
		return;
	}

	if (ssh_msg_recv(client_fd, &m) == -1) {
		error("%s: client msg_recv failed", __func__);
		close(client_fd);
		buffer_free(&m);
		return;
	}

	if ((ver = buffer_get_char(&m)) != 0) {
		error("%s: wrong client version %d", __func__, ver);
		buffer_free(&m);
		close(client_fd);
		return;
	}

	cctx = xmalloc(sizeof(*cctx));
	memset(cctx, 0, sizeof(*cctx));

	cctx->want_tty = buffer_get_int(&m);
	cctx->want_subsys = buffer_get_int(&m);
	cctx->term = buffer_get_string(&m, &len);

	cmd = buffer_get_string(&m, &len);
	buffer_init(&cctx->cmd);
	buffer_append(&cctx->cmd, cmd, strlen(cmd));

	env_len = buffer_get_int(&m);
	env_len = MIN(env_len, 4096);
	debug3("%s: receiving %d env vars", __func__, env_len);
	if (env_len != 0) {
		cctx->env = xmalloc(sizeof(*cctx->env) * (env_len + 1));
		for (i = 0; i < env_len; i++)
			cctx->env[i] = buffer_get_string(&m, &len);
		cctx->env[i] = NULL;
	}

	debug2("%s: accepted tty %d, subsys %d, cmd %s", __func__,
	    cctx->want_tty, cctx->want_subsys, cmd);

	/* Gather fds from client */
	new_fd[0] = mm_receive_fd(client_fd);
	new_fd[1] = mm_receive_fd(client_fd);
	new_fd[2] = mm_receive_fd(client_fd);

	debug2("%s: got fds stdin %d, stdout %d, stderr %d", __func__,
	    new_fd[0], new_fd[1], new_fd[2]);

	/* Try to pick up ttymodes from client before it goes raw */
	if (cctx->want_tty && tcgetattr(new_fd[0], &cctx->tio) == -1)
		error("%s: tcgetattr: %s", __func__, strerror(errno));

	buffer_clear(&m);
	if (ssh_msg_send(client_fd, /* version */0, &m) == -1) {
		error("%s: client msg_send failed", __func__);
		close(client_fd);
		close(new_fd[0]);
		close(new_fd[1]);
		close(new_fd[2]);
		buffer_free(&m);
		return;
	}
	buffer_free(&m);

	/* enable nonblocking unless tty */
	if (!isatty(new_fd[0]))
		set_nonblock(new_fd[0]);
	if (!isatty(new_fd[1]))
		set_nonblock(new_fd[1]);
	if (!isatty(new_fd[2]))
		set_nonblock(new_fd[2]);

	set_nonblock(client_fd);

	c = channel_new("session", SSH_CHANNEL_OPENING,
	    new_fd[0], new_fd[1], new_fd[2],
	    CHAN_SES_WINDOW_DEFAULT, CHAN_SES_PACKET_DEFAULT,
	    CHAN_EXTENDED_WRITE, "client-session", /*nonblock*/0);

	/* XXX */
	c->ctl_fd = client_fd;

	debug3("%s: channel_new: %d", __func__, c->self);

	channel_send_open(c->self);
	channel_register_confirm(c->self, client_extra_session2_setup, cctx);
}

static void
a509 1
	int delete = 0;
d519 1
a519 10
	if (*s == '-')
		s++;	/* Skip cmdline '-', if any */
	if (*s == '\0')
		goto out;

	if (*s == 'h' || *s == 'H' || *s == '?') {
		logit("Commands:");
		logit("      -Lport:host:hostport    Request local forward");
		logit("      -Rport:host:hostport    Request remote forward");
		logit("      -KRhostport             Cancel remote forward");
d521 1
a521 7
	}

	if (*s == 'K') {
		delete = 1;
		s++;
	}
	if (*s != 'L' && *s != 'R') {
d525 1
a525 1
	if (*s == 'L')
d527 1
a527 5
	if (local && delete) {
		logit("Not supported.");
		goto out;
	}
	if ((!local || delete) && !compat20) {
d531 1
a531 2

	s++;
d535 16
a550 21
	if (delete) {
		if (sscanf(s, "%5[0-9]", sfwd_host_port) != 1) {
			logit("Bad forwarding specification.");
			goto out;
		}
		if ((fwd_host_port = a2port(sfwd_host_port)) == 0) {
			logit("Bad forwarding port(s).");
			goto out;
		}
		channel_request_rforward_cancel(fwd_host_port);
	} else {
		if (sscanf(s, "%5[0-9]:%255[^:]:%5[0-9]",
		    sfwd_port, buf, sfwd_host_port) != 3 &&
		    sscanf(s, "%5[0-9]/%255[^/]/%5[0-9]",
		    sfwd_port, buf, sfwd_host_port) != 3) {
			logit("Bad forwarding specification.");
			goto out;
		}
		if ((fwd_port = a2port(sfwd_port)) == 0 ||
		    (fwd_host_port = a2port(sfwd_host_port)) == 0) {
			logit("Bad forwarding port(s).");
d553 4
a556 12
		if (local) {
			if (channel_setup_local_fwd_listener(fwd_port, buf,
			    fwd_host_port, options.gateway_ports) < 0) {
				logit("Port forwarding failed.");
				goto out;
			}
		} else
			channel_request_remote_forwarding(fwd_port, buf,
			    fwd_host_port);
		logit("Forwarding port.");
	}

d871 3
d891 1
a891 2
	int max_fd = 0, max_fd2 = 0, len, rekeying = 0;
	u_int nalloc = 0;
a906 2
	if (control_fd != -1)
		max_fd = MAX(max_fd, control_fd);
a1023 3
		/* Accept control connections.  */
		client_process_control(readset);

d1355 1
a1355 1
	int exitval, id, reply, success = 0;
d1365 8
a1372 3
	if (id == -1) {
		error("client_input_channel_req: request for channel -1");
	} else if ((c = channel_lookup(id)) == NULL) {
d1375 2
a1376 11
		exitval = packet_get_int();
		if (id == session_ident) {
			success = 1;
			exit_status = exitval;
		} else if (c->ctl_fd == -1) {
			error("client_input_channel_req: unexpected channel %d",
			    session_ident);
		} else {
			atomicio(vwrite, c->ctl_fd, &exitval, sizeof(exitval));
			success = 1;
		}
d1382 1
a1382 1
		packet_put_int(id);
a1406 91
void
client_session2_setup(int id, int want_tty, int want_subsystem,
    const char *term, struct termios *tiop, int in_fd, Buffer *cmd, char **env,
    dispatch_fn *subsys_repl)
{
	int len;

	debug2("%s: id %d", __func__, id);

	if (want_tty) {
		struct winsize ws;
		struct termios tio;

		/* Store window size in the packet. */
		if (ioctl(in_fd, TIOCGWINSZ, &ws) < 0)
			memset(&ws, 0, sizeof(ws));

		channel_request_start(id, "pty-req", 0);
		packet_put_cstring(term != NULL ? term : "");
		packet_put_int(ws.ws_col);
		packet_put_int(ws.ws_row);
		packet_put_int(ws.ws_xpixel);
		packet_put_int(ws.ws_ypixel);
		tio = get_saved_tio();
		tty_make_modes(-1, tiop != NULL ? tiop : &tio);
		packet_send();
		/* XXX wait for reply */
	}

	/* Transfer any environment variables from client to server */
	if (options.num_send_env != 0 && env != NULL) {
		int i, j, matched;
		char *name, *val;

		debug("Sending environment.");
		for (i = 0; env[i] != NULL; i++) {
			/* Split */
			name = xstrdup(env[i]);
			if ((val = strchr(name, '=')) == NULL) {
				free(name);
				continue;
			}
			*val++ = '\0';

			matched = 0;
			for (j = 0; j < options.num_send_env; j++) {
				if (match_pattern(name, options.send_env[j])) {
					matched = 1;
					break;
				}
			}
			if (!matched) {
				debug3("Ignored env %s", name);
				free(name);
				continue;
			}

			debug("Sending env %s = %s", name, val);
			channel_request_start(id, "env", 0);
			packet_put_cstring(name);
			packet_put_cstring(val);
			packet_send();
			free(name);
		}
	}

	len = buffer_len(cmd);
	if (len > 0) {
		if (len > 900)
			len = 900;
		if (want_subsystem) {
			debug("Sending subsystem: %.*s", len, (u_char*)buffer_ptr(cmd));
			channel_request_start(id, "subsystem", subsys_repl != NULL);
			if (subsys_repl != NULL) {
				/* register callback for reply */
				/* XXX we assume that client_loop has already been called */
				dispatch_set(SSH2_MSG_CHANNEL_FAILURE, subsys_repl);
				dispatch_set(SSH2_MSG_CHANNEL_SUCCESS, subsys_repl);
			}
		} else {
			debug("Sending command: %.*s", len, (u_char*)buffer_ptr(cmd));
			channel_request_start(id, "exec", 0);
		}
		packet_put_string(buffer_ptr(cmd), buffer_len(cmd));
		packet_send();
	} else {
		channel_request_start(id, "shell", 0);
		packet_send();
	}
}

a1472 2
	if (options.control_path != NULL && control_fd != -1)
		unlink(options.control_path);
@


1.117.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.135 2005/03/01 10:09:52 djm Exp $");
d435 2
d453 3
d459 7
a465 2
	/* Reset window sizes in case they have changed */
	received_window_change_signal = 1;
d574 1
a574 1
	u_int len, env_len, command, flags;
d604 3
a606 1
	unset_nonblock(client_fd);
d608 14
a621 13
	/* Read command */
	buffer_init(&m);
	if (ssh_msg_recv(client_fd, &m) == -1) {
		error("%s: client msg_recv failed", __func__);
		close(client_fd);
		buffer_free(&m);
		return;
	}
	if ((ver = buffer_get_char(&m)) != 1) {
		error("%s: wrong client version %d", __func__, ver);
		buffer_free(&m);
		close(client_fd);
		return;
d624 1
a624 3
	allowed = 1;
	command = buffer_get_int(&m);
	flags = buffer_get_int(&m);
d626 1
a626 36
	buffer_clear(&m);

	switch (command) {
	case SSHMUX_COMMAND_OPEN:
		if (options.control_master == 2)
			allowed = ask_permission("Allow shared connection "
			    "to %s? ", host);
		/* continue below */
		break;
	case SSHMUX_COMMAND_TERMINATE:
		if (options.control_master == 2)
			allowed = ask_permission("Terminate shared connection "
			    "to %s? ", host);
		if (allowed)
			quit_pending = 1;
		/* FALLTHROUGH */	
	case SSHMUX_COMMAND_ALIVE_CHECK:
		/* Reply for SSHMUX_COMMAND_TERMINATE and ALIVE_CHECK */
		buffer_clear(&m);
		buffer_put_int(&m, allowed);
		buffer_put_int(&m, getpid());
		if (ssh_msg_send(client_fd, /* version */1, &m) == -1) {
			error("%s: client msg_send failed", __func__);
			close(client_fd);
			buffer_free(&m);
			return;
		}
		buffer_free(&m);
		close(client_fd);
		return;
	default:
		error("Unsupported command %d", command);
		buffer_free(&m);
		close(client_fd);
		return;
	}
a627 2
	/* Reply for SSHMUX_COMMAND_OPEN */
	buffer_clear(&m);
d630 1
a630 1
	if (ssh_msg_send(client_fd, /* version */1, &m) == -1) {
d636 1
a644 1
	buffer_clear(&m);
d651 2
a652 1
	if ((ver = buffer_get_char(&m)) != 1) {
d661 3
a663 2
	cctx->want_tty = (flags & SSHMUX_FLAG_TTY) != 0;
	cctx->want_subsys = (flags & SSHMUX_FLAG_SUBSYS) != 0;
a694 1
	/* This roundtrip is just for synchronisation of ttymodes */
d696 1
a696 1
	if (ssh_msg_send(client_fd, /* version */1, &m) == -1) {
a702 6
		xfree(cctx->term);
		if (env_len != 0) {
			for (i = 0; i < env_len; i++)
				xfree(cctx->env[i]);
			xfree(cctx->env);
		}
d735 3
a737 1
	char *s, *cmd, *cancel_host;
a739 2
	u_short cancel_port;
	Forward fwd;
d785 3
a787 8
		cancel_port = 0;
		cancel_host = hpdelim(&s);	/* may be NULL */
		if (s != NULL) {
			cancel_port = a2port(s);
			cancel_host = cleanhostname(cancel_host);
		} else {
			cancel_port = a2port(cancel_host);
			cancel_host = NULL;
d789 2
a790 2
		if (cancel_port == 0) {
			logit("Bad forwarding close port");
d793 1
a793 1
		channel_request_rforward_cancel(cancel_host, cancel_port);
d795 4
a798 1
		if (!parse_forward(&fwd, s)) {
d802 5
d808 2
a809 3
			if (channel_setup_local_fwd_listener(fwd.listen_host,
			    fwd.listen_port, fwd.connect_host,
			    fwd.connect_port, options.gateway_ports) < 0) {
d813 3
a815 6
		} else {
			channel_request_remote_forwarding(fwd.listen_host,
			    fwd.listen_port, fwd.connect_host,
			    fwd.connect_port);
		}

a1198 2
	if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
		signal(SIGHUP, signal_handler);
d1205 2
a1206 1
	signal(SIGWINCH, window_change_handler);
d1314 2
a1315 1
	signal(SIGWINCH, SIG_DFL);
a1681 1
	Channel *c = NULL;
a1684 3
	if ((c = channel_lookup(id)) == NULL)
		fatal("client_session2_setup: channel %d: unknown channel", id);

a1702 1
		c->client_tty = 1;
@


1.116
log
@Clear exit code when ssh -N is terminated with a SIGTERM.  ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.115 2003/09/23 20:41:11 markus Exp $");
d130 1
d317 18
d344 3
d388 1
a388 4
	 * event pending. Note: if you want to implement SSH_MSG_IGNORE
	 * messages to fool traffic analysis, this might be the place to do
	 * it: just have a random timeout for the select, and send a random
	 * SSH_MSG_IGNORE packet when the timeout expires.
d391 9
a399 1
	if (select((*maxfdp)+1, *readsetp, *writesetp, NULL, NULL) < 0) {
d416 2
a417 1
	}
d1396 2
a1397 1
	debug("client_input_global_request: rtype %s want_reply %d", rtype, want_reply);
@


1.115
log
@move client only agent code to clientloop.c
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.114 2003/09/23 20:17:11 markus Exp $");
d92 3
d1036 10
@


1.114
log
@replace fatal_cleanup() and linked list of fatal callbacks with static
cleanup_exit() function.  re-refine cleanup_exit() where appropriate,
allocate sshd's authctxt eary to allow simpler cleanup in sshd.
tested by many, ok deraadt@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.113 2003/09/19 17:43:35 markus Exp $");
d1128 40
d1403 1
a1403 1
	    &auth_input_open_request : &deny_input_open);
@


1.113
log
@remove fatal callbacks from client code; ok deraadt
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.112 2003/06/28 16:23:06 deraadt Exp $");
d1387 1
a1387 1
fatal(const char *fmt,...)
a1388 5
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_FATAL, fmt, args);
	va_end(args);
d1391 1
a1391 1
	_exit(255);
@


1.112
log
@deal with typing of write vs read in atomicio
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.111 2003/05/14 22:24:42 markus Exp $");
a141 1
		fatal_remove_cleanup((void (*) (void *)) leave_non_blocking, NULL);
a151 1
	fatal_add_cleanup((void (*) (void *)) leave_non_blocking, NULL);
d845 1
a845 2
	if (in_raw_mode())
		leave_raw_mode();
d1034 1
a1034 3
	if (received_signal) {
		if (in_non_blocking_mode)	/* XXX */
			leave_non_blocking();
a1035 1
	}
d1383 14
@


1.112.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.117 2003/12/16 15:49:51 markus Exp $");
a91 3
/* Flag indicating that no shell has been requested */
extern int no_shell_flag;

a126 1
static int server_alive_timeouts = 0;
d142 1
d153 1
a314 18
static void
client_global_request_reply(int type, u_int32_t seq, void *ctxt)
{
	server_alive_timeouts = 0;
	client_global_request_reply_fwd(type, seq, ctxt);
}

static void
server_alive_check(void)
{
	if (++server_alive_timeouts > options.server_alive_count_max)
		packet_disconnect("Timeout, server not responding.");
	packet_start(SSH2_MSG_GLOBAL_REQUEST);
	packet_put_cstring("keepalive@@openssh.com");
	packet_put_char(1);     /* boolean: want reply */
	packet_send();
}

a323 3
	struct timeval tv, *tvp;
	int ret;

d365 4
a368 1
	 * event pending.
d371 1
a371 9
	if (options.server_alive_interval == 0 || !compat20)
		tvp = NULL;
	else {  
		tv.tv_sec = options.server_alive_interval;
		tv.tv_usec = 0;
		tvp = &tv;
	}
	ret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);
	if (ret < 0) {
d388 1
a388 2
	} else if (ret == 0)
		server_alive_check();
d847 2
a848 1
	leave_raw_mode();
d1037 4
a1040 8
	/*
	 * If there was no shell or command requested, there will be no remote
	 * exit status to be returned.  In that case, clear error code if the
	 * connection was deliberately terminated at this end.
	 */
	if (no_shell_flag && received_signal == SIGTERM) {
		received_signal = 0;
		exit_status = 0;
a1042 3
	if (received_signal)
		fatal("Killed by signal %d.", (int) received_signal);

a1133 40
static void
client_input_agent_open(int type, u_int32_t seq, void *ctxt)
{
	Channel *c = NULL;
	int remote_id, sock;

	/* Read the remote channel number from the message. */
	remote_id = packet_get_int();
	packet_check_eom();

	/*
	 * Get a connection to the local authentication agent (this may again
	 * get forwarded).
	 */
	sock = ssh_get_authentication_socket();

	/*
	 * If we could not connect the agent, send an error message back to
	 * the server. This should never happen unless the agent dies,
	 * because authentication forwarding is only enabled if we have an
	 * agent.
	 */
	if (sock >= 0) {
		c = channel_new("", SSH_CHANNEL_OPEN, sock, sock,
		    -1, 0, 0, 0, "authentication agent connection", 1);
		c->remote_id = remote_id;
		c->force_drain = 1;
	}
	if (c == NULL) {
		packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(remote_id);
	} else {
		/* Send a confirmation to the remote host. */
		debug("Forwarding authentication connection.");
		packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
		packet_put_int(remote_id);
		packet_put_int(c->self);
	}
	packet_send();
}
d1321 1
a1321 2
	debug("client_input_global_request: rtype %s want_reply %d",
	    rtype, want_reply);
d1369 1
a1369 1
	    &client_input_agent_open : &deny_input_open);
a1388 9
}

/* client specific fatal cleanup */
void
cleanup_exit(int i)
{
	leave_raw_mode();
	leave_non_blocking();
	_exit(i);
@


1.112.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.130 2004/08/11 21:43:04 avsm Exp $");
d82 1
a82 1
#include "sshpty.h"
d84 1
a84 3
#include "monitor_fdpass.h"
#include "match.h"
#include "msg.h"
a94 3
/* Control socket */
extern int control_fd;

a134 9
struct confirm_ctx {
	int want_tty;
	int want_subsys;
	Buffer cmd;
	char *term;
	struct termios tio;
	char **env;
};

a137 2
void ssh_process_session2_setup(int, int, int, Buffer *);

d144 1
a144 1
		unset_nonblock(fileno(stdin));
d155 1
a155 1
	set_nonblock(fileno(stdin));
d295 3
d301 6
a306 1
		channel_send_window_changes();
a307 2
		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
			return;
d339 1
d342 1
a342 1
    int *maxfdp, u_int *nallocp, int rekeying)
a384 3
	if (control_fd != -1)
		FD_SET(control_fd, *readsetp);

d393 1
a393 1
	else {
a503 216
client_subsystem_reply(int type, u_int32_t seq, void *ctxt)
{
	int id;
	Channel *c;

	id = packet_get_int();
	packet_check_eom();

	if ((c = channel_lookup(id)) == NULL) {
		error("%s: no channel for id %d", __func__, id);
		return;
	}

	if (type == SSH2_MSG_CHANNEL_SUCCESS)
		debug2("Request suceeded on channel %d", id);
	else if (type == SSH2_MSG_CHANNEL_FAILURE) {
		error("Request failed on channel %d", id);
		channel_free(c);
	}
}

static void
client_extra_session2_setup(int id, void *arg)
{
	struct confirm_ctx *cctx = arg;
	Channel *c;
	int i;

	if (cctx == NULL)
		fatal("%s: cctx == NULL", __func__);
	if ((c = channel_lookup(id)) == NULL)
		fatal("%s: no channel for id %d", __func__, id);

	client_session2_setup(id, cctx->want_tty, cctx->want_subsys,
	    cctx->term, &cctx->tio, c->rfd, &cctx->cmd, cctx->env,
	    client_subsystem_reply);

	c->confirm_ctx = NULL;
	buffer_free(&cctx->cmd);
	xfree(cctx->term);
	if (cctx->env != NULL) {
		for (i = 0; cctx->env[i] != NULL; i++)
			xfree(cctx->env[i]);
		xfree(cctx->env);
	}
	xfree(cctx);
}

static void
client_process_control(fd_set * readset)
{
	Buffer m;
	Channel *c;
	int client_fd, new_fd[3], ver, i, allowed;
	socklen_t addrlen;
	struct sockaddr_storage addr;
	struct confirm_ctx *cctx;
	char *cmd;
	u_int len, env_len;
	uid_t euid;
	gid_t egid;

	/*
	 * Accept connection on control socket
	 */
	if (control_fd == -1 || !FD_ISSET(control_fd, readset))
		return;

	memset(&addr, 0, sizeof(addr));
	addrlen = sizeof(addr);
	if ((client_fd = accept(control_fd,
	    (struct sockaddr*)&addr, &addrlen)) == -1) {
		error("%s accept: %s", __func__, strerror(errno));
		return;
	}

	if (getpeereid(client_fd, &euid, &egid) < 0) {
		error("%s getpeereid failed: %s", __func__, strerror(errno));
		close(client_fd);
		return;
	}
	if ((euid != 0) && (getuid() != euid)) {
		error("control mode uid mismatch: peer euid %u != uid %u",
		    (u_int) euid, (u_int) getuid());
		close(client_fd);
		return;
	}

	allowed = 1;
	if (options.control_master == 2) {
		char *p, prompt[1024];

		allowed = 0;
		snprintf(prompt, sizeof(prompt),
		    "Allow shared connection to %s? ", host);
		p = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);
		if (p != NULL) {
			/*
			 * Accept empty responses and responses consisting
			 * of the word "yes" as affirmative.
			 */
			if (*p == '\0' || *p == '\n' ||
			    strcasecmp(p, "yes") == 0)
				allowed = 1;
			xfree(p);
		}
	}

	unset_nonblock(client_fd);

	buffer_init(&m);

	buffer_put_int(&m, allowed);
	buffer_put_int(&m, getpid());
	if (ssh_msg_send(client_fd, /* version */0, &m) == -1) {
		error("%s: client msg_send failed", __func__);
		close(client_fd);
		buffer_free(&m);
		return;
	}
	buffer_clear(&m);

	if (!allowed) {
		error("Refused control connection");
		close(client_fd);
		buffer_free(&m);
		return;
	}

	if (ssh_msg_recv(client_fd, &m) == -1) {
		error("%s: client msg_recv failed", __func__);
		close(client_fd);
		buffer_free(&m);
		return;
	}

	if ((ver = buffer_get_char(&m)) != 0) {
		error("%s: wrong client version %d", __func__, ver);
		buffer_free(&m);
		close(client_fd);
		return;
	}

	cctx = xmalloc(sizeof(*cctx));
	memset(cctx, 0, sizeof(*cctx));

	cctx->want_tty = buffer_get_int(&m);
	cctx->want_subsys = buffer_get_int(&m);
	cctx->term = buffer_get_string(&m, &len);

	cmd = buffer_get_string(&m, &len);
	buffer_init(&cctx->cmd);
	buffer_append(&cctx->cmd, cmd, strlen(cmd));

	env_len = buffer_get_int(&m);
	env_len = MIN(env_len, 4096);
	debug3("%s: receiving %d env vars", __func__, env_len);
	if (env_len != 0) {
		cctx->env = xmalloc(sizeof(*cctx->env) * (env_len + 1));
		for (i = 0; i < env_len; i++)
			cctx->env[i] = buffer_get_string(&m, &len);
		cctx->env[i] = NULL;
	}

	debug2("%s: accepted tty %d, subsys %d, cmd %s", __func__,
	    cctx->want_tty, cctx->want_subsys, cmd);

	/* Gather fds from client */
	new_fd[0] = mm_receive_fd(client_fd);
	new_fd[1] = mm_receive_fd(client_fd);
	new_fd[2] = mm_receive_fd(client_fd);

	debug2("%s: got fds stdin %d, stdout %d, stderr %d", __func__,
	    new_fd[0], new_fd[1], new_fd[2]);

	/* Try to pick up ttymodes from client before it goes raw */
	if (cctx->want_tty && tcgetattr(new_fd[0], &cctx->tio) == -1)
		error("%s: tcgetattr: %s", __func__, strerror(errno));

	buffer_clear(&m);
	if (ssh_msg_send(client_fd, /* version */0, &m) == -1) {
		error("%s: client msg_send failed", __func__);
		close(client_fd);
		close(new_fd[0]);
		close(new_fd[1]);
		close(new_fd[2]);
		buffer_free(&m);
		return;
	}
	buffer_free(&m);

	/* enable nonblocking unless tty */
	if (!isatty(new_fd[0]))
		set_nonblock(new_fd[0]);
	if (!isatty(new_fd[1]))
		set_nonblock(new_fd[1]);
	if (!isatty(new_fd[2]))
		set_nonblock(new_fd[2]);

	set_nonblock(client_fd);

	c = channel_new("session", SSH_CHANNEL_OPENING,
	    new_fd[0], new_fd[1], new_fd[2],
	    CHAN_SES_WINDOW_DEFAULT, CHAN_SES_PACKET_DEFAULT,
	    CHAN_EXTENDED_WRITE, "client-session", /*nonblock*/0);

	/* XXX */
	c->ctl_fd = client_fd;

	debug3("%s: channel_new: %d", __func__, c->self);

	channel_send_open(c->self);
	channel_register_confirm(c->self, client_extra_session2_setup, cctx);
}

static void
a509 1
	int delete = 0;
d519 1
a519 10
	if (*s == '-')
		s++;	/* Skip cmdline '-', if any */
	if (*s == '\0')
		goto out;

	if (*s == 'h' || *s == 'H' || *s == '?') {
		logit("Commands:");
		logit("      -Lport:host:hostport    Request local forward");
		logit("      -Rport:host:hostport    Request remote forward");
		logit("      -KRhostport             Cancel remote forward");
d521 1
a521 7
	}

	if (*s == 'K') {
		delete = 1;
		s++;
	}
	if (*s != 'L' && *s != 'R') {
d525 1
a525 1
	if (*s == 'L')
d527 1
a527 5
	if (local && delete) {
		logit("Not supported.");
		goto out;
	}
	if ((!local || delete) && !compat20) {
d531 1
a531 2

	s++;
d535 16
a550 21
	if (delete) {
		if (sscanf(s, "%5[0-9]", sfwd_host_port) != 1) {
			logit("Bad forwarding specification.");
			goto out;
		}
		if ((fwd_host_port = a2port(sfwd_host_port)) == 0) {
			logit("Bad forwarding port(s).");
			goto out;
		}
		channel_request_rforward_cancel(fwd_host_port);
	} else {
		if (sscanf(s, "%5[0-9]:%255[^:]:%5[0-9]",
		    sfwd_port, buf, sfwd_host_port) != 3 &&
		    sscanf(s, "%5[0-9]/%255[^/]/%5[0-9]",
		    sfwd_port, buf, sfwd_host_port) != 3) {
			logit("Bad forwarding specification.");
			goto out;
		}
		if ((fwd_port = a2port(sfwd_port)) == 0 ||
		    (fwd_host_port = a2port(sfwd_host_port)) == 0) {
			logit("Bad forwarding port(s).");
d553 4
a556 12
		if (local) {
			if (channel_setup_local_fwd_listener(fwd_port, buf,
			    fwd_host_port, options.gateway_ports) < 0) {
				logit("Port forwarding failed.");
				goto out;
			}
		} else
			channel_request_remote_forwarding(fwd_port, buf,
			    fwd_host_port);
		logit("Forwarding port.");
	}

d871 3
d891 1
a891 2
	int max_fd = 0, max_fd2 = 0, len, rekeying = 0;
	u_int nalloc = 0;
a906 2
	if (control_fd != -1)
		max_fd = MAX(max_fd, control_fd);
a1023 3
		/* Accept control connections.  */
		client_process_control(readset);

d1355 1
a1355 1
	int exitval, id, reply, success = 0;
d1365 8
a1372 3
	if (id == -1) {
		error("client_input_channel_req: request for channel -1");
	} else if ((c = channel_lookup(id)) == NULL) {
d1375 2
a1376 11
		exitval = packet_get_int();
		if (id == session_ident) {
			success = 1;
			exit_status = exitval;
		} else if (c->ctl_fd == -1) {
			error("client_input_channel_req: unexpected channel %d",
			    session_ident);
		} else {
			atomicio(vwrite, c->ctl_fd, &exitval, sizeof(exitval));
			success = 1;
		}
d1382 1
a1382 1
		packet_put_int(id);
a1406 91
void
client_session2_setup(int id, int want_tty, int want_subsystem,
    const char *term, struct termios *tiop, int in_fd, Buffer *cmd, char **env,
    dispatch_fn *subsys_repl)
{
	int len;

	debug2("%s: id %d", __func__, id);

	if (want_tty) {
		struct winsize ws;
		struct termios tio;

		/* Store window size in the packet. */
		if (ioctl(in_fd, TIOCGWINSZ, &ws) < 0)
			memset(&ws, 0, sizeof(ws));

		channel_request_start(id, "pty-req", 0);
		packet_put_cstring(term != NULL ? term : "");
		packet_put_int(ws.ws_col);
		packet_put_int(ws.ws_row);
		packet_put_int(ws.ws_xpixel);
		packet_put_int(ws.ws_ypixel);
		tio = get_saved_tio();
		tty_make_modes(-1, tiop != NULL ? tiop : &tio);
		packet_send();
		/* XXX wait for reply */
	}

	/* Transfer any environment variables from client to server */
	if (options.num_send_env != 0 && env != NULL) {
		int i, j, matched;
		char *name, *val;

		debug("Sending environment.");
		for (i = 0; env[i] != NULL; i++) {
			/* Split */
			name = xstrdup(env[i]);
			if ((val = strchr(name, '=')) == NULL) {
				free(name);
				continue;
			}
			*val++ = '\0';

			matched = 0;
			for (j = 0; j < options.num_send_env; j++) {
				if (match_pattern(name, options.send_env[j])) {
					matched = 1;
					break;
				}
			}
			if (!matched) {
				debug3("Ignored env %s", name);
				free(name);
				continue;
			}

			debug("Sending env %s = %s", name, val);
			channel_request_start(id, "env", 0);
			packet_put_cstring(name);
			packet_put_cstring(val);
			packet_send();
			free(name);
		}
	}

	len = buffer_len(cmd);
	if (len > 0) {
		if (len > 900)
			len = 900;
		if (want_subsystem) {
			debug("Sending subsystem: %.*s", len, (u_char*)buffer_ptr(cmd));
			channel_request_start(id, "subsystem", subsys_repl != NULL);
			if (subsys_repl != NULL) {
				/* register callback for reply */
				/* XXX we assume that client_loop has already been called */
				dispatch_set(SSH2_MSG_CHANNEL_FAILURE, subsys_repl);
				dispatch_set(SSH2_MSG_CHANNEL_SUCCESS, subsys_repl);
			}
		} else {
			debug("Sending command: %.*s", len, (u_char*)buffer_ptr(cmd));
			channel_request_start(id, "exec", 0);
		}
		packet_put_string(buffer_ptr(cmd), buffer_len(cmd));
		packet_send();
	} else {
		channel_request_start(id, "shell", 0);
		packet_send();
	}
}

a1472 2
	if (options.control_path != NULL && control_fd != -1)
		unlink(options.control_path);
@


1.111
log
@allow to send a BREAK to the remote system; ok various
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.110 2003/05/11 20:30:24 markus Exp $");
d398 1
a398 1
		atomicio(write, fileno(stdout), buffer_ptr(bout), buffer_len(bout));
d400 1
a400 1
		atomicio(write, fileno(stderr), buffer_ptr(berr), buffer_len(berr));
@


1.110
log
@make channel_new() strdup the 'remote_name' (not the caller); ok theo
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.109 2003/04/08 20:21:28 itojun Exp $");
d577 13
d652 1
d663 1
a663 1
				    escape_char, escape_char);
@


1.109
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.108 2003/04/02 09:48:07 markus Exp $");
d1148 1
a1148 1
	    xstrdup(originator_address), 1);
d1184 1
a1184 2
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0,
	    xstrdup("x11"), 1);
d1206 1
a1206 1
	    xstrdup("authentication agent connection"), 1);
@


1.108
log
@reapply rekeying chage, tested by henning@@, ok djm@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.107 2003/04/01 10:22:21 markus Exp $");
d493 1
a493 1
		log("Invalid command.");
d499 1
a499 1
		log("Not supported for SSH protocol version 1.");
d510 1
a510 1
		log("Bad forwarding specification.");
d515 1
a515 1
		log("Bad forwarding port(s).");
d521 1
a521 1
			log("Port forwarding failed.");
d527 1
a527 1
	log("Forwarding port.");
d580 1
a580 1
						log("Server does not support re-keying");
@


1.107
log
@backout rekeying changes (for 3.6.1)
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.106 2003/04/01 10:10:23 markus Exp $");
d971 2
a972 3

			if (need_rekeying) {
				debug("user requests rekeying");
@


1.106
log
@rekeying bugfixes and automatic rekeying:

* both client and server rekey _automatically_
      (a) after 2^31 packets, because after 2^32 packets
          the sequence number for packets wraps
      (b) after 2^(blocksize_in_bits/4) blocks
  (see: http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-00.txt)
  (a) and (b) are _enabled_ by default, and only disabled for known
  openssh versions, that don't support rekeying properly.
* client option 'RekeyLimit'
* do not reply to requests during rekeying
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.105 2002/11/18 16:43:44 markus Exp $");
d971 3
a973 2
			if (need_rekeying || packet_need_rekeying()) {
				debug("need rekeying");
@


1.105
log
@don't overwrite SIG{INT,QUIT,TERM} handler if set to SIG_IGN;
e.g. if ssh is used for backup; report Joerg Schilling; ok millert@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.104 2002/08/22 19:38:42 stevesk Exp $");
d971 2
a972 3

			if (need_rekeying) {
				debug("user requests rekeying");
@


1.105.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.112 2003/06/28 16:23:06 deraadt Exp $");
d398 1
a398 1
		atomicio(vwrite, fileno(stdout), buffer_ptr(bout), buffer_len(bout));
d400 1
a400 1
		atomicio(vwrite, fileno(stderr), buffer_ptr(berr), buffer_len(berr));
d493 1
a493 1
		logit("Invalid command.");
d499 1
a499 1
		logit("Not supported for SSH protocol version 1.");
d510 1
a510 1
		logit("Bad forwarding specification.");
d515 1
a515 1
		logit("Bad forwarding port(s).");
d521 1
a521 1
			logit("Port forwarding failed.");
d527 1
a527 1
	logit("Forwarding port.");
a576 13
			case 'B':
				if (compat20) {
					snprintf(string, sizeof string,
					    "%cB\r\n", escape_char);
					buffer_append(berr, string,
					    strlen(string));
					channel_request_start(session_ident,
					    "break", 0);
					packet_put_int(1000);
					packet_send();
				}
				continue;

d580 1
a580 1
						logit("Server does not support re-keying");
a638 1
%cB  - send a BREAK to the remote system\r\n\
d649 1
a649 1
				    escape_char, escape_char, escape_char);
d971 3
a973 2
			if (need_rekeying || packet_need_rekeying()) {
				debug("need rekeying");
d1149 1
a1149 1
	    originator_address, 1);
d1185 2
a1186 1
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0, "x11", 1);
d1208 1
a1208 1
	    "authentication agent connection", 1);
@


1.105.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.117 2003/12/16 15:49:51 markus Exp $");
a91 3
/* Flag indicating that no shell has been requested */
extern int no_shell_flag;

a126 1
static int server_alive_timeouts = 0;
d142 1
d153 1
a314 18
static void
client_global_request_reply(int type, u_int32_t seq, void *ctxt)
{
	server_alive_timeouts = 0;
	client_global_request_reply_fwd(type, seq, ctxt);
}

static void
server_alive_check(void)
{
	if (++server_alive_timeouts > options.server_alive_count_max)
		packet_disconnect("Timeout, server not responding.");
	packet_start(SSH2_MSG_GLOBAL_REQUEST);
	packet_put_cstring("keepalive@@openssh.com");
	packet_put_char(1);     /* boolean: want reply */
	packet_send();
}

a323 3
	struct timeval tv, *tvp;
	int ret;

d365 4
a368 1
	 * event pending.
d371 1
a371 9
	if (options.server_alive_interval == 0 || !compat20)
		tvp = NULL;
	else {  
		tv.tv_sec = options.server_alive_interval;
		tv.tv_usec = 0;
		tvp = &tv;
	}
	ret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);
	if (ret < 0) {
d388 1
a388 2
	} else if (ret == 0)
		server_alive_check();
d847 2
a848 1
	leave_raw_mode();
d1037 4
a1040 8
	/*
	 * If there was no shell or command requested, there will be no remote
	 * exit status to be returned.  In that case, clear error code if the
	 * connection was deliberately terminated at this end.
	 */
	if (no_shell_flag && received_signal == SIGTERM) {
		received_signal = 0;
		exit_status = 0;
a1042 3
	if (received_signal)
		fatal("Killed by signal %d.", (int) received_signal);

a1133 40
static void
client_input_agent_open(int type, u_int32_t seq, void *ctxt)
{
	Channel *c = NULL;
	int remote_id, sock;

	/* Read the remote channel number from the message. */
	remote_id = packet_get_int();
	packet_check_eom();

	/*
	 * Get a connection to the local authentication agent (this may again
	 * get forwarded).
	 */
	sock = ssh_get_authentication_socket();

	/*
	 * If we could not connect the agent, send an error message back to
	 * the server. This should never happen unless the agent dies,
	 * because authentication forwarding is only enabled if we have an
	 * agent.
	 */
	if (sock >= 0) {
		c = channel_new("", SSH_CHANNEL_OPEN, sock, sock,
		    -1, 0, 0, 0, "authentication agent connection", 1);
		c->remote_id = remote_id;
		c->force_drain = 1;
	}
	if (c == NULL) {
		packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(remote_id);
	} else {
		/* Send a confirmation to the remote host. */
		debug("Forwarding authentication connection.");
		packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
		packet_put_int(remote_id);
		packet_put_int(c->self);
	}
	packet_send();
}
d1321 1
a1321 2
	debug("client_input_global_request: rtype %s want_reply %d",
	    rtype, want_reply);
d1369 1
a1369 1
	    &client_input_agent_open : &deny_input_open);
a1388 9
}

/* client specific fatal cleanup */
void
cleanup_exit(int i)
{
	leave_raw_mode();
	leave_non_blocking();
	_exit(i);
@


1.104
log
@format with current EscapeChar; bugzilla #388 from wknox@@mitre.org.
ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.103 2002/06/30 21:59:45 deraadt Exp $");
d891 10
a900 4
	/* Set signal handlers to restore non-blocking mode.  */
	signal(SIGINT, signal_handler);
	signal(SIGQUIT, signal_handler);
	signal(SIGTERM, signal_handler);
@


1.104.2.1
log
@Update to OpenSSH 3.6
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.105 2002/11/18 16:43:44 markus Exp $");
d891 4
a894 10
	/*
	 * Set signal handlers, (e.g. to restore non-blocking mode)
	 * but don't overwrite SIG_IGN, matches behaviour from rsh(1)
	 */
	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		signal(SIGINT, signal_handler);
	if (signal(SIGQUIT, SIG_IGN) != SIG_IGN)
		signal(SIGQUIT, signal_handler);
	if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
		signal(SIGTERM, signal_handler);
@


1.104.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.112 2003/06/28 16:23:06 deraadt Exp $");
d398 1
a398 1
		atomicio(vwrite, fileno(stdout), buffer_ptr(bout), buffer_len(bout));
d400 1
a400 1
		atomicio(vwrite, fileno(stderr), buffer_ptr(berr), buffer_len(berr));
d493 1
a493 1
		logit("Invalid command.");
d499 1
a499 1
		logit("Not supported for SSH protocol version 1.");
d510 1
a510 1
		logit("Bad forwarding specification.");
d515 1
a515 1
		logit("Bad forwarding port(s).");
d521 1
a521 1
			logit("Port forwarding failed.");
d527 1
a527 1
	logit("Forwarding port.");
a576 13
			case 'B':
				if (compat20) {
					snprintf(string, sizeof string,
					    "%cB\r\n", escape_char);
					buffer_append(berr, string,
					    strlen(string));
					channel_request_start(session_ident,
					    "break", 0);
					packet_put_int(1000);
					packet_send();
				}
				continue;

d580 1
a580 1
						logit("Server does not support re-keying");
a638 1
%cB  - send a BREAK to the remote system\r\n\
d649 1
a649 1
				    escape_char, escape_char, escape_char);
d971 3
a973 2
			if (need_rekeying || packet_need_rekeying()) {
				debug("need rekeying");
d1149 1
a1149 1
	    originator_address, 1);
d1185 2
a1186 1
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0, "x11", 1);
d1208 1
a1208 1
	    "authentication agent connection", 1);
@


1.103
log
@minor KNF
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.102 2002/06/24 14:33:27 markus Exp $");
d638 8
a645 8
~.  - terminate connection\r\n\
~C  - open a command line\r\n\
~R  - Request rekey (SSH protocol 2 only)\r\n\
~^Z - suspend ssh\r\n\
~#  - list forwarded connections\r\n\
~&  - background ssh (when waiting for connections to terminate)\r\n\
~?  - this message\r\n\
~~  - send the escape character by typing it twice\r\n\
d647 3
a649 1
					 escape_char);
@


1.102
log
@move channel counter to u_int
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.101 2002/06/09 13:32:01 markus Exp $");
d1117 1
a1117 1
	Channel* c = NULL;
d1147 1
a1147 1
static Channel*
d1183 1
a1183 1
static Channel*
@


1.101
log
@use tab not spaces (|unexpand)
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.100 2002/04/22 21:04:52 markus Exp $");
a1210 1
	u_int len;
d1212 1
a1212 2
	int rmaxpack;
	int rwindow;
@


1.100
log
@request reply (success/failure) for -R style fwd in protocol v2,
depends on ordered replies.
fixes http://bugzilla.mindrot.org/show_bug.cgi?id=215; ok provos@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.99 2002/03/21 23:07:37 markus Exp $");
d484 1
a484 1
 	handler = signal(SIGINT, SIG_IGN);
@


1.99
log
@remove unused, sync w/ cmdline patch in my tree.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.98 2002/03/21 16:58:13 markus Exp $");
d1317 1
d1331 4
@


1.99.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.100 2002/04/22 21:04:52 markus Exp $");
a1316 1

a1329 4

	/* global request reply messages */
	dispatch_set(SSH2_MSG_REQUEST_FAILURE, &client_global_request_reply);
	dispatch_set(SSH2_MSG_REQUEST_SUCCESS, &client_global_request_reply);
@


1.99.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.99.2.3
log
@Pull in OpenSSH-3.4
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.102 2002/06/24 14:33:27 markus Exp $");
d484 1
a484 1
	handler = signal(SIGINT, SIG_IGN);
d1211 1
d1213 2
a1214 1
	u_int rmaxpack, rwindow, len;
@


1.99.2.4
log
@Update to OpenSSH 3.5
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.104 2002/08/22 19:38:42 stevesk Exp $");
d638 8
a645 8
%c.  - terminate connection\r\n\
%cC  - open a command line\r\n\
%cR  - Request rekey (SSH protocol 2 only)\r\n\
%c^Z - suspend ssh\r\n\
%c#  - list forwarded connections\r\n\
%c&  - background ssh (when waiting for connections to terminate)\r\n\
%c?  - this message\r\n\
%c%c  - send the escape character by typing it twice\r\n\
d647 1
a647 3
				    escape_char, escape_char, escape_char, escape_char,
				    escape_char, escape_char, escape_char, escape_char,
				    escape_char, escape_char);
d1117 1
a1117 1
	Channel *c = NULL;
d1147 1
a1147 1
static Channel *
d1183 1
a1183 1
static Channel *
@


1.99.2.5
log
@Merge OpenSSH 3.6.1
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.107 2003/04/01 10:22:21 markus Exp $");
d891 4
a894 10
	/*
	 * Set signal handlers, (e.g. to restore non-blocking mode)
	 * but don't overwrite SIG_IGN, matches behaviour from rsh(1)
	 */
	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		signal(SIGINT, signal_handler);
	if (signal(SIGQUIT, SIG_IGN) != SIG_IGN)
		signal(SIGQUIT, signal_handler);
	if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
		signal(SIGTERM, signal_handler);
@


1.98
log
@remove unused
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.97 2002/03/21 15:17:26 jakob Exp $");
d475 1
a475 1
process_cmdline(Buffer *bin, Buffer *bout, Buffer *berr)
a481 1
	int n;
d485 1
a485 1
	s = read_passphrase("\r\nssh> ", RP_ECHO);
a487 2
	cmd = s;

a489 1

a491 1

d493 1
a493 1
		log("Invalid command");
d499 1
a499 1
		log("Not supported for SSH protocol version 1");
a501 1

d510 1
a510 1
		log("Bad forwarding specification");
d515 1
a515 1
		log("Bad forwarding port(s)");
d519 3
a521 4
		n = channel_setup_local_fwd_listener(fwd_port, buf,
		    fwd_host_port, options.gateway_ports);
		if (n <= 0) {
			log("Port forwarding failed");
d527 1
a527 1
	log("Forwarding port");
d660 1
a660 1
				process_cmdline(bin, bout, berr);
@


1.97
log
@add built-in command line for adding new port forwardings on the fly.
based on a patch from brian wellington. ok markus@@.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.96 2002/02/06 14:55:15 markus Exp $");
a476 1
	char string[1024];
@


1.96
log
@channel_new never returns NULL, mouring@@; ok djm@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.95 2002/01/10 11:24:04 markus Exp $");
d84 1
d474 69
d647 1
d665 4
@


1.95
log
@handle SSH2_MSG_GLOBAL_REQUEST (just reply with failure); ok djm@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.94 2001/12/28 15:06:00 markus Exp $");
a1074 4
	if (c == NULL) {
		error("client_request_forwarded_tcpip: channel_new failed");
		close(sock);
	}
a1111 4
	if (c == NULL) {
		error("client_request_x11: channel_new failed");
		close(sock);
	}
a1133 4
	if (c == NULL) {
		error("client_request_agent: channel_new failed");
		close(sock);
	}
@


1.94
log
@remove plen from the dispatch fn. it's no longer used.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.93 2001/12/28 12:14:27 markus Exp $");
d1239 18
d1271 1
@


1.93
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.92 2001/12/27 20:39:58 markus Exp $");
d1011 1
a1011 1
client_input_stdout_data(int type, int plen, u_int32_t seq, void *ctxt)
d1021 1
a1021 1
client_input_stderr_data(int type, int plen, u_int32_t seq, void *ctxt)
d1031 1
a1031 1
client_input_exit_status(int type, int plen, u_int32_t seq, void *ctxt)
d1152 1
a1152 1
client_input_channel_open(int type, int plen, u_int32_t seq, void *ctxt)
d1204 1
a1204 1
client_input_channel_req(int type, int plen, u_int32_t seq, void *ctxt)
@


1.92
log
@get rid of packet_integrity_check, use packet_done() instead.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.91 2001/12/20 22:50:24 djm Exp $");
d1015 1
a1015 1
	packet_done();
d1025 1
a1025 1
	packet_done();
d1034 1
a1034 1
	packet_done();
d1060 1
a1060 1
	packet_done();
d1104 1
a1104 1
	packet_done();
d1229 1
a1229 1
		packet_done();
@


1.91
log
@Conformance fix: we should send failing packet sequence number when
responding with a SSH_MSG_UNIMPLEMENTED message. Spotted by
yakk@@yakk.dot.net; ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.90 2001/12/19 07:18:56 deraadt Exp $");
d1015 1
a1015 1
	packet_integrity_check(plen, 4 + data_len, type);
d1025 1
a1025 1
	packet_integrity_check(plen, 4 + data_len, type);
a1032 1
	packet_integrity_check(plen, 4, type);
d1034 1
@


1.90
log
@basic KNF done while i was looking for something else
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.89 2001/12/05 03:50:01 itojun Exp $");
d1011 1
a1011 1
client_input_stdout_data(int type, int plen, void *ctxt)
d1021 1
a1021 1
client_input_stderr_data(int type, int plen, void *ctxt)
d1031 1
a1031 1
client_input_exit_status(int type, int plen, void *ctxt)
d1152 1
a1152 1
client_input_channel_open(int type, int plen, void *ctxt)
d1204 1
a1204 1
client_input_channel_req(int type, int plen, void *ctxt)
@


1.89
log
@deal with LP64 printf issue with sig_atomic_t.  from thorpej
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.88 2001/11/22 12:34:22 markus Exp $");
d257 1
a257 1
	       packet_not_very_much_data_to_write()) {
d420 3
a422 3
	     oldws.ws_col != newws.ws_col ||
	     oldws.ws_xpixel != newws.ws_xpixel ||
	     oldws.ws_ypixel != newws.ws_ypixel))
d997 1
a997 1
	      stdin_bytes, stdout_bytes, stderr_bytes, total_time);
d1000 2
a1001 2
		      stdin_bytes / total_time, stdout_bytes / total_time,
		      stderr_bytes / total_time);
@


1.88
log
@volatile sig_atomic_t
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.87 2001/11/09 18:59:23 markus Exp $");
d952 1
a952 1
		fatal("Killed by signal %d.", received_signal);
@


1.87
log
@don't memset too much memory, ok millert@@
original patch from jlk@@kamens.brookline.ma.us via nalin@@redhat.com
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.86 2001/10/24 19:57:40 markus Exp $");
d104 2
a105 2
static volatile int received_window_change_signal = 0;
static volatile int received_signal = 0;
@


1.86
log
@make ~& (backgrounding) work again for proto v1; add support ~& for v2, too
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.85 2001/10/24 08:51:35 markus Exp $");
d349 2
a350 2
			memset(*readsetp, 0, *maxfdp);
			memset(*writesetp, 0, *maxfdp);
d378 2
a379 2
		memset(*readsetp, 0, *maxfdp);
		memset(*writesetp, 0, *maxfdp);
@


1.85
log
@ignore SIGPIPE early, makes ssh work if agent dies, netbsd-pr via itojun@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.84 2001/10/11 15:24:00 markus Exp $");
a524 3
				/* XXX does not work yet with proto 2 */
				if (compat20)
					continue;
a528 16
				if (!stdin_eof) {
					/*
					 * Sending SSH_CMSG_EOF alone does not always appear
					 * to be enough.  So we try to send an EOF character
					 * first.
					 */
					packet_start(SSH_CMSG_STDIN_DATA);
					packet_put_string("\004", 1);
					packet_send();
					/* Close stdin. */
					stdin_eof = 1;
					if (buffer_len(bin) == 0) {
						packet_start(SSH_CMSG_EOF);
						packet_send();
					}
				}
d533 1
a533 1
				channel_close_all();	/* proto1 only XXXX */
d535 3
a537 1
				printf("%c& [backgrounded]\n", escape_char);
d550 21
a570 1
				continue; /*XXX ? */
@


1.84
log
@clear select masks if we return before calling select().
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.83 2001/10/10 22:18:47 markus Exp $");
a822 1
	signal(SIGPIPE, SIG_IGN);
@


1.84.2.1
log
@Pull in patches from current (Errata 002):
Update to OpenSSH-3.0.1 via errata patch (Instead of using release tarball)
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.87 2001/11/09 18:59:23 markus Exp $");
d349 2
a350 2
			memset(*readsetp, 0, *nallocp);
			memset(*writesetp, 0, *nallocp);
d378 2
a379 2
		memset(*readsetp, 0, *nallocp);
		memset(*writesetp, 0, *nallocp);
d525 3
d532 16
d552 1
a552 1
				channel_stop_listening();
d554 1
a554 3
				snprintf(string, sizeof string,
				    "%c& [backgrounded]\n", escape_char);
				buffer_append(berr, string, strlen(string));
d567 1
a567 21
				if (compat20) {
					buffer_append(bin, "\004", 1);
					/* fake EOF on stdin */
					return -1;
				} else if (!stdin_eof) {
					/*
					 * Sending SSH_CMSG_EOF alone does not always appear
					 * to be enough.  So we try to send an EOF character
					 * first.
					 */
					packet_start(SSH_CMSG_STDIN_DATA);
					packet_put_string("\004", 1);
					packet_send();
					/* Close stdin. */
					stdin_eof = 1;
					if (buffer_len(bin) == 0) {
						packet_start(SSH_CMSG_EOF);
						packet_send();
					}
				}
				continue;
d823 1
@


1.84.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.96 2002/02/06 14:55:15 markus Exp $");
d104 2
a105 2
static volatile sig_atomic_t received_window_change_signal = 0;
static volatile sig_atomic_t received_signal = 0;
d257 1
a257 1
	    packet_not_very_much_data_to_write()) {
d420 3
a422 3
	    oldws.ws_col != newws.ws_col ||
	    oldws.ws_xpixel != newws.ws_xpixel ||
	    oldws.ws_ypixel != newws.ws_ypixel))
d952 1
a952 1
		fatal("Killed by signal %d.", (int) received_signal);
d997 1
a997 1
	    stdin_bytes, stdout_bytes, stderr_bytes, total_time);
d1000 2
a1001 2
		    stdin_bytes / total_time, stdout_bytes / total_time,
		    stderr_bytes / total_time);
d1011 1
a1011 1
client_input_stdout_data(int type, u_int32_t seq, void *ctxt)
d1015 1
a1015 1
	packet_check_eom();
d1021 1
a1021 1
client_input_stderr_data(int type, u_int32_t seq, void *ctxt)
d1025 1
a1025 1
	packet_check_eom();
d1031 1
a1031 1
client_input_exit_status(int type, u_int32_t seq, void *ctxt)
d1033 1
a1034 1
	packet_check_eom();
d1060 1
a1060 1
	packet_check_eom();
d1075 4
d1104 1
a1104 1
	packet_check_eom();
d1116 4
d1142 4
d1152 1
a1152 1
client_input_channel_open(int type, u_int32_t seq, void *ctxt)
d1204 1
a1204 1
client_input_channel_req(int type, u_int32_t seq, void *ctxt)
d1229 1
a1229 1
		packet_check_eom();
a1238 18
static void
client_input_global_request(int type, u_int32_t seq, void *ctxt)
{
	char *rtype;
	int want_reply;
	int success = 0;

	rtype = packet_get_string(NULL);
	want_reply = packet_get_char();
	debug("client_input_global_request: rtype %s want_reply %d", rtype, want_reply);
	if (want_reply) {
		packet_start(success ?
		    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);
		packet_send();
		packet_write_wait();
	}
	xfree(rtype);
}
a1252 1
	dispatch_set(SSH2_MSG_GLOBAL_REQUEST, &client_input_global_request);
@


1.84.2.3
log
@Update OpenSSH to version 3.2.2.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.100 2002/04/22 21:04:52 markus Exp $");
a83 1
#include "readpass.h"
a472 61
static void
process_cmdline(void)
{
	void (*handler)(int);
	char *s, *cmd;
	u_short fwd_port, fwd_host_port;
	char buf[1024], sfwd_port[6], sfwd_host_port[6];
	int local = 0;

	leave_raw_mode();
 	handler = signal(SIGINT, SIG_IGN);
	cmd = s = read_passphrase("\r\nssh> ", RP_ECHO);
	if (s == NULL)
		goto out;
	while (*s && isspace(*s))
		s++;
	if (*s == 0)
		goto out;
	if (strlen(s) < 2 || s[0] != '-' || !(s[1] == 'L' || s[1] == 'R')) {
		log("Invalid command.");
		goto out;
	}
	if (s[1] == 'L')
		local = 1;
	if (!local && !compat20) {
		log("Not supported for SSH protocol version 1.");
		goto out;
	}
	s += 2;
	while (*s && isspace(*s))
		s++;

	if (sscanf(s, "%5[0-9]:%255[^:]:%5[0-9]",
	    sfwd_port, buf, sfwd_host_port) != 3 &&
	    sscanf(s, "%5[0-9]/%255[^/]/%5[0-9]",
	    sfwd_port, buf, sfwd_host_port) != 3) {
		log("Bad forwarding specification.");
		goto out;
	}
	if ((fwd_port = a2port(sfwd_port)) == 0 ||
	    (fwd_host_port = a2port(sfwd_host_port)) == 0) {
		log("Bad forwarding port(s).");
		goto out;
	}
	if (local) {
		if (channel_setup_local_fwd_listener(fwd_port, buf,
		    fwd_host_port, options.gateway_ports) < 0) {
			log("Port forwarding failed.");
			goto out;
		}
	} else
		channel_request_remote_forwarding(fwd_port, buf,
		    fwd_host_port);
	log("Forwarding port.");
out:
	signal(SIGINT, handler);
	enter_raw_mode();
	if (cmd)
		xfree(cmd);
}

a576 1
~C  - open a command line\r\n\
a595 4
			case 'C':
				process_cmdline();
				continue;

a1249 1

a1262 4

	/* global request reply messages */
	dispatch_set(SSH2_MSG_REQUEST_FAILURE, &client_global_request_reply);
	dispatch_set(SSH2_MSG_REQUEST_SUCCESS, &client_global_request_reply);
@


1.84.2.4
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.84.2.3 2002/05/17 00:03:23 miod Exp $");
d484 1
a484 1
	handler = signal(SIGINT, SIG_IGN);
@


1.84.2.5
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.84.2.4 2002/06/22 07:23:17 miod Exp $");
d1211 1
d1213 2
a1214 1
	u_int rmaxpack, rwindow, len;
@


1.84.2.6
log
@Update to OpenSSH 3.5
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.104 2002/08/22 19:38:42 stevesk Exp $");
d638 8
a645 8
%c.  - terminate connection\r\n\
%cC  - open a command line\r\n\
%cR  - Request rekey (SSH protocol 2 only)\r\n\
%c^Z - suspend ssh\r\n\
%c#  - list forwarded connections\r\n\
%c&  - background ssh (when waiting for connections to terminate)\r\n\
%c?  - this message\r\n\
%c%c  - send the escape character by typing it twice\r\n\
d647 1
a647 3
				    escape_char, escape_char, escape_char, escape_char,
				    escape_char, escape_char, escape_char, escape_char,
				    escape_char, escape_char);
d1117 1
a1117 1
	Channel *c = NULL;
d1147 1
a1147 1
static Channel *
d1183 1
a1183 1
static Channel *
@


1.83
log
@try to keep channels open until an exit-status message is sent.
don't kill the login shells if the shells stdin/out/err is closed.
this should now work:
ssh -2n localhost 'exec > /dev/null 2>&1; sleep 10; exit 5'; echo ?
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.82 2001/09/17 20:52:47 markus Exp $");
d346 6
a351 3
		if (session_closed && !channel_still_open()) {
			if (!packet_have_data_to_write())
				return;
@


1.82
log
@try to fix agent-forwarding-backconnection-bug, as seen on HPUX, for example;
with Lutz.Jaenicke@@aet.TU-Cottbus.DE,
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.81 2001/07/17 21:04:57 markus Exp $");
d756 1
@


1.81
log
@keep track of both maxfd and the size of the malloc'ed fdsets.
update maxfd if maxfd gets closed.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.80 2001/06/30 18:08:40 stevesk Exp $");
d1114 1
d1140 1
@


1.80
log
@adress -> address; ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.79 2001/06/29 18:38:44 stevesk Exp $");
d321 1
a321 1
    int *maxfdp, int rekeying)
d324 1
a324 1
	channel_prepare_select(readsetp, writesetp, maxfdp, rekeying);
d773 1
a773 1
	int max_fd = 0, len, rekeying = 0;
d880 1
d882 1
a882 1
		    &max_fd, rekeying);
@


1.79
log
@sync function definition with declaration; ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.78 2001/06/25 08:25:36 markus Exp $");
d1058 1
a1058 1
	sock = channel_connect_by_listen_adress(listen_port);
@


1.78
log
@update copyright for 2001
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.77 2001/06/23 15:12:18 itojun Exp $");
d1274 1
a1274 1
void
@


1.77
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d38 1
a38 1
 * Copyright (c) 1999,2000 Markus Friedl.  All rights reserved.
d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.76 2001/06/20 13:56:39 markus Exp $");
@


1.76
log
@move from channel_stop_listening to channel_free_all,
call channel_free_all before calling waitpid() in serverloop.
fixes the utmp handling; report from Lutz.Jaenicke@@aet.TU-Cottbus.DE
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.75 2001/06/04 23:07:20 markus Exp $");
d127 1
a127 1
void	client_init_dispatch(void);
d135 1
a135 1
void
d147 1
a147 1
void
d160 1
a160 1
void
d172 1
a172 1
void
d184 1
a184 1
double
d198 1
a198 1
void
d250 1
a250 1
void
d282 1
a282 1
void
d319 1
a319 1
void
d387 1
a387 1
void
d430 1
a430 1
void
d471 1
a471 1
int
d621 1
a621 1
void
d674 1
a674 1
void
d735 1
a735 1
void
d743 1
a743 1
int
d750 1
a750 1
void
d1003 1
a1003 1
void
d1013 1
a1013 1
void
d1023 1
a1023 1
void
d1040 1
a1040 1
Channel *
d1077 1
a1077 1
Channel*
d1116 1
a1116 1
Channel*
d1142 1
a1142 1
void
d1194 1
a1194 1
void
d1231 1
a1231 1
void
d1248 1
a1248 1
void
d1267 1
a1267 1
void
@


1.75
log
@set flags in the signal handlers, do real work in the main loop, ok provos@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.74 2001/05/31 10:30:15 markus Exp $");
d549 1
a549 1
				channel_stop_listening();
d929 1
a929 2
	/* Stop listening for connections. */
	channel_stop_listening();
@


1.74
log
@undo the .c file split, just merge the header and keep the cvs history
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.73 2001/05/30 12:55:10 markus Exp $");
d105 1
d175 2
a176 7
	if (in_raw_mode())
		leave_raw_mode();
	if (in_non_blocking_mode)
		leave_non_blocking();
	channel_stop_listening();
	packet_close();
	fatal("Killed by signal %d.", sig);
d932 17
a957 8
	/* restore blocking io */
	if (!isatty(fileno(stdin)))
		unset_nonblock(fileno(stdin));
	if (!isatty(fileno(stdout)))
		unset_nonblock(fileno(stdout));
	if (!isatty(fileno(stderr)))
		unset_nonblock(fileno(stderr));

a980 3

	if (have_pty)
		leave_raw_mode();
@


1.73
log
@channel layer cleanup: merge header files and split .c files
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.72 2001/05/24 18:57:53 stevesk Exp $");
d71 1
a71 1
#include "channel.h"
@


1.72
log
@don't perform escape processing when ``EscapeChar none''; ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.71 2001/05/16 21:53:53 markus Exp $");
d71 1
a71 1
#include "channels.h"
@


1.71
log
@check for open sessions before we call select(); fixes the x11 client
bug reported by bowman@@math.ualberta.ca
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.70 2001/05/11 14:59:55 markus Exp $");
d575 1
a575 1
~R - Request rekey (SSH protocol 2 only)\r\n\
d660 1
a660 1
		} else if (escape_char == -1) {
d768 2
a769 2
 * remote host.  If escape_char != -1, it is the character used as an escape
 * character for terminating or suspending the session.
d832 1
a832 1
		if (escape_char != -1)
@


1.70
log
@add unset_nonblock for stdout/err flushing in client_loop().
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.69 2001/05/08 19:17:31 markus Exp $");
d349 7
a355 1
		FD_SET(connection_in, *readsetp);
@


1.69
log
@adds correct error reporting to async connect()s
fixes the server-discards-data-before-connected-bug found by onoe@@sm.sony.co.jp
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.68 2001/05/06 21:45:14 markus Exp $");
d938 9
d948 2
a949 2
	if (buffer_len(&stdout_buffer) > 0) {
		len = atomicio(write, fileno(stdout), buffer_ptr(&stdout_buffer),
d951 1
a951 1
		if (len != buffer_len(&stdout_buffer))
d953 2
d960 2
a961 2
	if (buffer_len(&stderr_buffer) > 0) {
		len = atomicio(write, fileno(stderr), buffer_ptr(&stderr_buffer),
d963 1
a963 1
		if (len != buffer_len(&stderr_buffer))
d965 2
@


1.68
log
@use atomicio for flushing stdout/stderr bufs. thanks to jbw@@izanami.cee.hw.ac.uk
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.67 2001/05/04 23:47:34 markus Exp $");
d1153 8
a1160 7

		packet_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);
		packet_put_int(c->remote_id);
		packet_put_int(c->self);
		packet_put_int(c->local_window);
		packet_put_int(c->local_maxpacket);
		packet_send();
d1167 1
a1167 1
			packet_put_cstring("bla bla");
@


1.67
log
@move to Channel **channels (instead of Channel *channels), fixes realloc problems.
channel_new now returns a Channel *, favour Channel * over channel id.
remove old channel_allocate interface.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.66 2001/04/29 19:16:52 markus Exp $");
d939 2
a940 2
	while (buffer_len(&stdout_buffer) > 0) {
		len = write(fileno(stdout), buffer_ptr(&stdout_buffer),
d942 1
a942 1
		if (len <= 0) {
a943 2
			break;
		}
d949 2
a950 2
	while (buffer_len(&stderr_buffer) > 0) {
		len = write(fileno(stderr), buffer_ptr(&stderr_buffer),
d952 1
a952 1
		if (len <= 0) {
a953 2
			break;
		}
@


1.66
log
@more ssh.com-2.0.x bug-compat; from per@@appgate.com
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.65 2001/04/20 07:17:51 djm Exp $");
d1030 1
a1030 1
	int sock, newch;
d1043 12
a1054 6
	if (sock >= 0) {
		newch = channel_new("forwarded-tcpip",
		    SSH_CHANNEL_CONNECTING, sock, sock, -1,
		    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_WINDOW_DEFAULT, 0,
		    xstrdup(originator_address), 1);
		c = channel_lookup(newch);
d1067 1
a1067 1
	int sock, newch;
d1085 1
d1087 9
a1095 6
	if (sock >= 0) {
		newch = channel_new("x11",
		    SSH_CHANNEL_X11_OPEN, sock, sock, -1,
		    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0,
		    xstrdup("x11"), 1);
		c = channel_lookup(newch);
a1096 1
	xfree(originator);
d1104 1
a1104 1
	int sock, newch;
d1112 9
a1120 6
	if (sock >= 0) {
		newch = channel_new("authentication agent connection",
		    SSH_CHANNEL_OPEN, sock, sock, -1,
		    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_WINDOW_DEFAULT, 0,
		    xstrdup("authentication agent connection"), 1);
		c = channel_lookup(newch);
@


1.65
log
@Split out and improve escape character documentation, mention ~R in
~? help text; ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.64 2001/04/17 09:52:48 markus Exp $");
d1157 4
a1160 2
		packet_put_cstring("bla bla");
		packet_put_cstring("");
@


1.65.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d38 1
a38 1
 * Copyright (c) 1999, 2000, 2001 Markus Friedl.  All rights reserved.
d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.82 2001/09/17 20:52:47 markus Exp $");
a104 1
static volatile int received_signal = 0;
d126 1
a126 1
static void client_init_dispatch(void);
d134 1
a134 1
static void
d146 1
a146 1
static void
d159 1
a159 1
static void
d171 1
a171 1
static void
d174 7
a180 2
	received_signal = sig;
	quit_pending = 1;
d188 1
a188 1
static double
d202 1
a202 1
static void
d254 1
a254 1
static void
d286 1
a286 1
static void
d323 1
a323 1
static void
d325 1
a325 1
    int *maxfdp, int *nallocp, int rekeying)
d328 1
a328 1
	channel_prepare_select(readsetp, writesetp, maxfdp, nallocp, rekeying);
d349 1
a349 7
		/* channel_prepare_select could have closed the last channel */
		if (session_closed && !channel_still_open()) {
			if (!packet_have_data_to_write())
				return;
		} else {
			FD_SET(connection_in, *readsetp);
		}
d385 1
a385 1
static void
d428 1
a428 1
static void
d469 1
a469 1
static int
d547 1
a547 1
				channel_close_all();	/* proto1 only XXXX */
d569 1
a569 1
~R  - Request rekey (SSH protocol 2 only)\r\n\
d619 1
a619 1
static void
d654 1
a654 1
		} else if (escape_char == SSH_ESCAPECHAR_NONE) {
d672 1
a672 1
static void
d733 1
a733 1
static void
d741 1
a741 1
static int
d748 1
a748 1
static void
d762 2
a763 2
 * remote host.  If escape_char != SSH_ESCAPECHAR_NONE, it is the character
 * used as an escape character for terminating or suspending the session.
d771 1
a771 1
	int max_fd = 0, max_fd2 = 0, len, rekeying = 0, nalloc = 0;
d826 1
a826 1
		if (escape_char != SSH_ESCAPECHAR_NONE)
a877 1
		max_fd2 = max_fd;
d879 1
a879 1
		    &max_fd2, &nalloc, rekeying);
d927 2
a928 18
	channel_free_all();

	if (have_pty)
		leave_raw_mode();

	/* restore blocking io */
	if (!isatty(fileno(stdin)))
		unset_nonblock(fileno(stdin));
	if (!isatty(fileno(stdout)))
		unset_nonblock(fileno(stdout));
	if (!isatty(fileno(stderr)))
		unset_nonblock(fileno(stderr));

	if (received_signal) {
		if (in_non_blocking_mode)	/* XXX */
			leave_non_blocking();
		fatal("Killed by signal %d.", received_signal);
	}
a937 1

d962 3
d987 1
a987 1
static void
d997 1
a997 1
static void
d1007 1
a1007 1
static void
d1024 1
a1024 1
static Channel *
d1030 1
a1030 1
	int sock;
d1042 7
a1048 13
	sock = channel_connect_by_listen_address(listen_port);
	if (sock < 0) {
		xfree(originator_address);
		xfree(listen_address);
		return NULL;
	}
	c = channel_new("forwarded-tcpip",
	    SSH_CHANNEL_CONNECTING, sock, sock, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_WINDOW_DEFAULT, 0,
	    xstrdup(originator_address), 1);
	if (c == NULL) {
		error("client_request_forwarded_tcpip: channel_new failed");
		close(sock);
d1055 1
a1055 1
static Channel*
d1061 1
a1061 1
	int sock;
a1078 1
	xfree(originator);
d1080 6
a1085 9
	if (sock < 0)
		return NULL;
	c = channel_new("x11",
	    SSH_CHANNEL_X11_OPEN, sock, sock, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0,
	    xstrdup("x11"), 1);
	if (c == NULL) {
		error("client_request_x11: channel_new failed");
		close(sock);
d1087 1
a1087 1
	c->force_drain = 1;
d1091 1
a1091 1
static Channel*
d1095 1
a1095 1
	int sock;
d1103 6
a1108 9
	if (sock < 0)
		return NULL;
	c = channel_new("authentication agent connection",
	    SSH_CHANNEL_OPEN, sock, sock, -1,
	    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_WINDOW_DEFAULT, 0,
	    xstrdup("authentication agent connection"), 1);
	if (c == NULL) {
		error("client_request_agent: channel_new failed");
		close(sock);
a1109 1
	c->force_drain = 1;
d1114 1
a1114 1
static void
d1145 7
a1151 8
		if (c->type != SSH_CHANNEL_CONNECTING) {
			packet_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);
			packet_put_int(c->remote_id);
			packet_put_int(c->self);
			packet_put_int(c->local_window);
			packet_put_int(c->local_maxpacket);
			packet_send();
		}
d1157 2
a1158 4
		if (!(datafellows & SSH_BUG_OPENFAILURE)) {
			packet_put_cstring("open failed");
			packet_put_cstring("");
		}
d1163 1
a1163 1
static void
d1200 1
a1200 1
static void
d1217 1
a1217 1
static void
d1236 1
a1236 1
static void
d1243 1
a1243 1
static void
@


1.65.2.2
log
@Merge OpenSSH 3.0
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.65.2.1 2001/09/27 19:03:54 jason Exp $");
d346 3
a348 6
		if (session_closed && !channel_still_open() &&
		    !packet_have_data_to_write()) {
			/* clear mask since we did not call select() */
			memset(*readsetp, 0, *maxfdp);
			memset(*writesetp, 0, *maxfdp);
			return;
a755 1
	channel_cancel_cleanup(id);
@


1.65.2.3
log
@Merge OpenSSH 3.0.1.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.65.2.2 2001/11/15 00:15:19 miod Exp $");
d349 2
a350 2
			memset(*readsetp, 0, *nallocp);
			memset(*writesetp, 0, *nallocp);
d378 2
a379 2
		memset(*readsetp, 0, *nallocp);
		memset(*writesetp, 0, *nallocp);
d525 3
d532 16
d552 1
a552 1
				channel_stop_listening();
d554 1
a554 3
				snprintf(string, sizeof string,
				    "%c& [backgrounded]\n", escape_char);
				buffer_append(berr, string, strlen(string));
d567 1
a567 21
				if (compat20) {
					buffer_append(bin, "\004", 1);
					/* fake EOF on stdin */
					return -1;
				} else if (!stdin_eof) {
					/*
					 * Sending SSH_CMSG_EOF alone does not always appear
					 * to be enough.  So we try to send an EOF character
					 * first.
					 */
					packet_start(SSH_CMSG_STDIN_DATA);
					packet_put_string("\004", 1);
					packet_send();
					/* Close stdin. */
					stdin_eof = 1;
					if (buffer_len(bin) == 0) {
						packet_start(SSH_CMSG_EOF);
						packet_send();
					}
				}
				continue;
d823 1
@


1.65.2.4
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.96 2002/02/06 14:55:15 markus Exp $");
d104 2
a105 2
static volatile sig_atomic_t received_window_change_signal = 0;
static volatile sig_atomic_t received_signal = 0;
d257 1
a257 1
	    packet_not_very_much_data_to_write()) {
d420 3
a422 3
	    oldws.ws_col != newws.ws_col ||
	    oldws.ws_xpixel != newws.ws_xpixel ||
	    oldws.ws_ypixel != newws.ws_ypixel))
d952 1
a952 1
		fatal("Killed by signal %d.", (int) received_signal);
d997 1
a997 1
	    stdin_bytes, stdout_bytes, stderr_bytes, total_time);
d1000 2
a1001 2
		    stdin_bytes / total_time, stdout_bytes / total_time,
		    stderr_bytes / total_time);
d1011 1
a1011 1
client_input_stdout_data(int type, u_int32_t seq, void *ctxt)
d1015 1
a1015 1
	packet_check_eom();
d1021 1
a1021 1
client_input_stderr_data(int type, u_int32_t seq, void *ctxt)
d1025 1
a1025 1
	packet_check_eom();
d1031 1
a1031 1
client_input_exit_status(int type, u_int32_t seq, void *ctxt)
d1033 1
a1034 1
	packet_check_eom();
d1060 1
a1060 1
	packet_check_eom();
d1075 4
d1104 1
a1104 1
	packet_check_eom();
d1116 4
d1142 4
d1152 1
a1152 1
client_input_channel_open(int type, u_int32_t seq, void *ctxt)
d1204 1
a1204 1
client_input_channel_req(int type, u_int32_t seq, void *ctxt)
d1229 1
a1229 1
		packet_check_eom();
a1238 18
static void
client_input_global_request(int type, u_int32_t seq, void *ctxt)
{
	char *rtype;
	int want_reply;
	int success = 0;

	rtype = packet_get_string(NULL);
	want_reply = packet_get_char();
	debug("client_input_global_request: rtype %s want_reply %d", rtype, want_reply);
	if (want_reply) {
		packet_start(success ?
		    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);
		packet_send();
		packet_write_wait();
	}
	xfree(rtype);
}
a1252 1
	dispatch_set(SSH2_MSG_GLOBAL_REQUEST, &client_input_global_request);
@


1.65.2.5
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.100 2002/04/22 21:04:52 markus Exp $");
a83 1
#include "readpass.h"
a472 61
static void
process_cmdline(void)
{
	void (*handler)(int);
	char *s, *cmd;
	u_short fwd_port, fwd_host_port;
	char buf[1024], sfwd_port[6], sfwd_host_port[6];
	int local = 0;

	leave_raw_mode();
 	handler = signal(SIGINT, SIG_IGN);
	cmd = s = read_passphrase("\r\nssh> ", RP_ECHO);
	if (s == NULL)
		goto out;
	while (*s && isspace(*s))
		s++;
	if (*s == 0)
		goto out;
	if (strlen(s) < 2 || s[0] != '-' || !(s[1] == 'L' || s[1] == 'R')) {
		log("Invalid command.");
		goto out;
	}
	if (s[1] == 'L')
		local = 1;
	if (!local && !compat20) {
		log("Not supported for SSH protocol version 1.");
		goto out;
	}
	s += 2;
	while (*s && isspace(*s))
		s++;

	if (sscanf(s, "%5[0-9]:%255[^:]:%5[0-9]",
	    sfwd_port, buf, sfwd_host_port) != 3 &&
	    sscanf(s, "%5[0-9]/%255[^/]/%5[0-9]",
	    sfwd_port, buf, sfwd_host_port) != 3) {
		log("Bad forwarding specification.");
		goto out;
	}
	if ((fwd_port = a2port(sfwd_port)) == 0 ||
	    (fwd_host_port = a2port(sfwd_host_port)) == 0) {
		log("Bad forwarding port(s).");
		goto out;
	}
	if (local) {
		if (channel_setup_local_fwd_listener(fwd_port, buf,
		    fwd_host_port, options.gateway_ports) < 0) {
			log("Port forwarding failed.");
			goto out;
		}
	} else
		channel_request_remote_forwarding(fwd_port, buf,
		    fwd_host_port);
	log("Forwarding port.");
out:
	signal(SIGINT, handler);
	enter_raw_mode();
	if (cmd)
		xfree(cmd);
}

a576 1
~C  - open a command line\r\n\
a595 4
			case 'C':
				process_cmdline();
				continue;

a1249 1

a1262 4

	/* global request reply messages */
	dispatch_set(SSH2_MSG_REQUEST_FAILURE, &client_global_request_reply);
	dispatch_set(SSH2_MSG_REQUEST_SUCCESS, &client_global_request_reply);
@


1.64
log
@handle EINTR/EAGAIN on read; ok deraadt@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.63 2001/04/15 17:16:00 markus Exp $");
d569 1
@


1.63
log
@set stdin/out/err to nonblocking in SSH proto 1, too. suggested by ho@@
should fix some of the blocking problems for rsync over SSH-1
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.62 2001/04/14 16:33:20 stevesk Exp $");
d628 2
d683 1
a683 1
			if (errno == EAGAIN)
d706 1
a706 1
			if (errno == EAGAIN)
@


1.62
log
@protocol 2 tty modes support; ok markus@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.61 2001/04/08 11:27:33 markus Exp $");
d83 1
d786 7
@


1.61
log
@leave_raw_mode if ssh2 "session" is closed
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.60 2001/04/05 21:05:23 markus Exp $");
d82 1
a104 9
/* Terminal modes, as saved by enter_raw_mode. */
static struct termios saved_tio;

/*
 * Flag indicating whether we are in raw mode.  This is used by
 * enter_raw_mode and leave_raw_mode.
 */
static int in_raw_mode = 0;

a130 40
/* Returns the user\'s terminal to normal mode if it had been put in raw mode. */

void
leave_raw_mode(void)
{
	if (!in_raw_mode)
		return;
	in_raw_mode = 0;
	if (tcsetattr(fileno(stdin), TCSADRAIN, &saved_tio) < 0)
		perror("tcsetattr");

	fatal_remove_cleanup((void (*) (void *)) leave_raw_mode, NULL);
}

/* Puts the user\'s terminal in raw mode. */

void
enter_raw_mode(void)
{
	struct termios tio;

	if (tcgetattr(fileno(stdin), &tio) < 0)
		perror("tcgetattr");
	saved_tio = tio;
	tio.c_iflag |= IGNPAR;
	tio.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);
	tio.c_lflag &= ~(ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);
#ifdef IEXTEN
	tio.c_lflag &= ~IEXTEN;
#endif				/* IEXTEN */
	tio.c_oflag &= ~OPOST;
	tio.c_cc[VMIN] = 1;
	tio.c_cc[VTIME] = 0;
	if (tcsetattr(fileno(stdin), TCSADRAIN, &tio) < 0)
		perror("tcsetattr");
	in_raw_mode = 1;

	fatal_add_cleanup((void (*) (void *)) leave_raw_mode, NULL);
}

d173 1
a173 1
	if (in_raw_mode)
d751 1
a751 1
	if (in_raw_mode)
@


1.60
log
@don't request a session for 'ssh -N', pointed out slade@@shore.net
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.59 2001/04/05 20:01:10 markus Exp $");
d799 2
@


1.59
log
@for ~R print message if server does not support rekeying. (and fix ~R).
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.58 2001/04/05 11:09:15 markus Exp $");
d131 1
d792 9
d864 3
d878 3
a881 5

		if (compat20 && !channel_still_open()) {
			debug2("!channel_still_open.");
			break;
		}
@


1.58
log
@add SSH_BUG_NOREKEY and detect broken (=all old) openssh versions.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.57 2001/04/05 10:42:49 markus Exp $");
d557 6
a562 2
				if (compat20 && !(datafellows && SSH_BUG_NOREKEY))
					need_rekeying = 1;
@


1.57
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.56 2001/04/04 20:25:37 markus Exp $");
d557 1
a557 1
				if (compat20)
@


1.56
log
@more robust rekeying
don't send channel data after rekeying is started.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.55 2001/04/04 14:34:58 markus Exp $");
d738 1
a738 1
		stdout_bytes += len; 
d756 1
a756 1
		stderr_bytes += len; 
d967 1
a967 1
		stdout_bytes += len; 
d979 1
a979 1
		stderr_bytes += len; 
@


1.55
log
@enable server side rekeying + some rekey related clientup.
todo: we should not send any non-KEX messages after we send KEXINIT
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.54 2001/04/04 00:06:53 markus Exp $");
d130 1
d371 1
a371 1
    int *maxfdp)
d374 1
a374 1
	channel_prepare_select(readsetp, writesetp, maxfdp);
d557 2
a558 2
				debug("Rekeying");
				kex_send_kexinit(xxx_kex);
a797 1
	int max_fd = 0;
d799 1
a799 1
	int len;
d861 2
d868 9
a876 6
		/*
		 * Make packets of buffered stdin data, and buffer them for
		 * sending to the server.
		 */
		if (!compat20)
			client_make_packets_from_stdin_data();
d878 6
a883 6
		/*
		 * Make packets from buffered channel data, and enqueue them
		 * for sending to the server.
		 */
		if (packet_not_very_much_data_to_write())
			channel_output_poll();
d885 5
a889 8
		/*
		 * Check if the window size has changed, and buffer a message
		 * about it to the server if so.
		 */
		client_check_window_change();

		if (quit_pending)
			break;
d891 3
d898 2
a899 1
		client_wait_until_can_do_something(&readset, &writeset, &max_fd);
d904 11
a914 2
		/* Do channel operations. */
		channel_after_select(readset, writeset);
@


1.54
log
@enable client rekeying
	(1) force rekeying with ~R, or
	(2) if the server requests rekeying.
works against ssh-2.0.12/2.0.13/2.1.0/2.2.0/2.3.0/2.3.1/2.4.0
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.53 2001/03/06 01:08:27 millert Exp $");
d1208 1
a1208 4
	int i;
	/* dispatch_init(&dispatch_protocol_error); */
	for (i = 50; i <= 254; i++)
		dispatch_set(i, &dispatch_protocol_error);
d1218 3
@


1.53
log
@If read() fails with EINTR deal with it the same way we treat EAGAIN
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.52 2001/02/28 08:45:39 markus Exp $");
d76 1
d134 3
d555 5
d774 1
a774 1
	dispatch_run(DISPATCH_NONBLOCK, &quit_pending, NULL);
d1208 4
a1211 1
	dispatch_init(&dispatch_protocol_error);
@


1.52
log
@fix byte counts for ssh protocol v1
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.51 2001/02/13 21:51:09 markus Exp $");
d494 1
a494 1
		if (len < 0 && errno == EAGAIN)
@


1.51
log
@clear select masks on EINTR, noticed by itojun@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.50 2001/02/12 22:56:08 deraadt Exp $");
d282 1
a282 1
			else {
a283 2
				stdin_bytes += 1;
			}
d311 1
a421 1
		stderr_bytes += strlen(buf);
a486 1
			stderr_bytes += strlen(buf);
a501 1
			stderr_bytes += strlen(buf);
a534 1
				/*stderr_bytes += strlen(string); XXX*/
a543 1
				/*stderr_bytes += strlen(string); XXX*/
a652 1
	int ret;
a668 1
				stderr_bytes += strlen(buf);
a688 1
			stdin_bytes += len;
d694 2
a695 2
			ret = process_escapes(&stdin_buffer, &stdout_buffer, &stderr_buffer, buf, len);
			if (ret == -1)
a696 1
			stdout_bytes += ret;
a721 1
				stderr_bytes += strlen(buf);
d728 1
d746 1
a932 1
		stderr_bytes += strlen(buf);
d943 1
d955 1
a989 1
	stdout_bytes += data_len;
a999 1
	stdout_bytes += data_len;
@


1.50
log
@deal with EAGAIN/EINTR selects which were skipped
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.49 2001/02/08 19:30:51 itojun Exp $");
d409 8
@


1.49
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.48 2001/02/06 22:43:02 markus Exp $");
d409 1
@


1.48
log
@remove confusing callback code
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.47 2001/01/29 19:42:35 markus Exp $");
d136 1
a136 1
leave_raw_mode()
d150 1
a150 1
enter_raw_mode()
d176 1
a176 1
leave_non_blocking()
d188 1
a188 1
enter_non_blocking()
d230 1
a230 1
get_current_time()
d244 1
a244 1
client_check_initial_eof_on_stdin()
d298 1
a298 1
client_make_packets_from_stdin_data()
d329 1
a329 1
client_check_window_change()
d763 1
a763 1
client_process_buffered_input_packets()
d1198 1
a1198 1
client_init_dispatch_20()
d1212 1
a1212 1
client_init_dispatch_13()
d1231 1
a1231 1
client_init_dispatch_15()
d1238 1
a1238 1
client_init_dispatch()
@


1.47
log
@add get_peer_ipaddr(socket), x11-fwd in ssh2 requires ipaddr, not DNS
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.46 2001/01/29 16:55:36 markus Exp $");
a129 1

d836 7
a842 2
	/* Check if we should immediately send eof on stdin. */
	if (!compat20)
d844 1
a844 3

	if (compat20 && escape_char != -1)
		channel_register_filter(ssh2_chan_id, simple_escape_filter);
d1160 36
d1208 1
a1208 1
	dispatch_set(SSH2_MSG_CHANNEL_REQUEST, &channel_input_channel_request);
a1245 46
}

void
client_input_channel_req(int id, void *arg)
{
	Channel *c = NULL;
	u_int len;
	int success = 0;
	int reply;
	char *rtype;

	rtype = packet_get_string(&len);
	reply = packet_get_char();

	debug("client_input_channel_req: rtype %s reply %d", rtype, reply);

	c = channel_lookup(id);
	if (c == NULL)
		fatal("client_input_channel_req: channel %d: bad channel", id);

	if (session_ident == -1) {
		error("client_input_channel_req: no channel %d", id);
	} else if (id != session_ident) {
		error("client_input_channel_req: bad channel %d != %d",
		    id, session_ident);
	} else if (strcmp(rtype, "exit-status") == 0) {
		success = 1;
		exit_status = packet_get_int();
		packet_done();
	}
	if (reply) {
		packet_start(success ?
		    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);
		packet_put_int(c->remote_id);
		packet_send();
	}
	xfree(rtype);
}

void
clientloop_set_session_ident(int id)
{
	debug2("clientloop_set_session_ident: id %d", id);
	session_ident = id;
	channel_register_callback(id, SSH2_MSG_CHANNEL_REQUEST,
	    client_input_channel_req, (void *)0);
@


1.46
log
@fix select overflow; ok deraadt@@ and stevesk@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.45 2001/01/21 19:05:47 markus Exp $");
d1072 2
@


1.45
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.44 2001/01/19 15:55:10 markus Exp $");
a126 1
static int max_fd;		/* Maximum file descriptor number in select(). */
d367 2
a368 1
client_wait_until_can_do_something(fd_set * readset, fd_set * writeset)
d370 2
a371 3
	/* Initialize select masks. */
	FD_ZERO(readset);
	FD_ZERO(writeset);
d378 1
a378 1
			FD_SET(connection_in, readset);
d384 1
a384 1
			FD_SET(fileno(stdin), readset);
d388 1
a388 1
			FD_SET(fileno(stdout), writeset);
d390 1
a390 1
			FD_SET(fileno(stderr), writeset);
d392 1
a392 1
		FD_SET(connection_in, readset);
a394 3
	/* Add any selections by the channel mechanism. */
	channel_prepare_select(readset, writeset);

d397 1
a397 6
		FD_SET(connection_out, writeset);

/* move UP XXX */
	/* Update maximum file descriptor number, if appropriate. */
	if (channel_max_fd() > max_fd)
		max_fd = channel_max_fd();
d408 1
a408 1
	if (select(max_fd + 1, readset, writeset, NULL, NULL) < 0) {
a409 3
		/* Some systems fail to clear these automatically. */
		FD_ZERO(readset);
		FD_ZERO(writeset);
d788 2
d806 7
a812 3
	max_fd = connection_in;
	if (connection_out > max_fd)
		max_fd = connection_out;
a845 1
		fd_set readset, writeset;
d863 1
a863 1
		 * Make packets from buffered channel data, and buffer them
d882 1
a882 1
		client_wait_until_can_do_something(&readset, &writeset);
d888 1
a888 1
		channel_after_select(&readset, &writeset);
d891 1
a891 1
		client_process_net_input(&readset);
d898 1
a898 1
			client_process_input(&readset);
d903 1
a903 1
			client_process_output(&writeset);
d907 1
a907 1
		if (FD_ISSET(connection_out, &writeset))
d910 4
@


1.44
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.43 2001/01/13 19:14:08 markus Exp $");
d64 3
a67 1
#include "ssh.h"
a69 4
#include "readconf.h"

#include "ssh1.h"
#include "ssh2.h"
a72 1

a74 3

#include <openssl/dsa.h>
#include <openssl/rsa.h>
d76 3
d80 1
a80 1
#include "clientloop.h"
@


1.43
log
@move callback to headerfile
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.42 2000/12/19 23:17:56 markus Exp $");
d70 1
@


1.42
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.41 2000/12/05 20:34:10 markus Exp $");
d82 1
d1251 1
a1251 1
client_set_session_ident(int id)
d1253 1
a1253 1
	debug2("client_set_session_ident: id %d", id);
@


1.41
log
@async connects for -R/-L; ok deraadt@@
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.40 2000/11/06 23:04:56 markus Exp $");
d126 2
a127 2
static unsigned long stdin_bytes, stdout_bytes, stderr_bytes;
static unsigned int buffer_high;/* Soft max buffer size. */
d283 1
a283 1
			if ((unsigned char) buf[0] == escape_char)
d303 1
a303 1
	unsigned int len;
d525 2
a526 2
	unsigned int i;
	unsigned char ch;
d987 1
a987 1
	unsigned int data_len;
d998 1
a998 1
	unsigned int data_len;
d1116 1
a1116 1
	unsigned int len;
d1216 1
a1216 1
	unsigned int len;
@


1.40
log
@agent forwarding and -R for ssh2, based on work from jhuuskon@@messi.uku.fi
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.39 2000/10/27 07:48:22 markus Exp $");
d1044 1
a1044 1
		    SSH_CHANNEL_OPEN, sock, sock, -1,
@


1.39
log
@deny agent/x11 forwarding unless requested; thanks to jwl@@pobox.com
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.38 2000/10/27 07:32:18 markus Exp $");
d78 4
d1023 87
a1115 1
	int id;
d1129 6
a1134 22
	if (strcmp(ctype, "x11") == 0 && options.forward_x11) {
		int sock;
		char *originator;
		int originator_port;
		originator = packet_get_string(NULL);
		if (datafellows & SSH_BUG_X11FWD) {
			debug2("buggy server: x11 request w/o originator_port");
			originator_port = 0;
		} else {
			originator_port = packet_get_int();
		}
		packet_done();
		/* XXX check permission */
		xfree(originator);
		/* XXX move to channels.c */
		sock = x11_connect_display();
		if (sock >= 0) {
			id = channel_new("x11", SSH_CHANNEL_X11_OPEN,
			    sock, sock, -1, CHAN_X11_WINDOW_DEFAULT,
			    CHAN_X11_PACKET_DEFAULT, 0, xstrdup("x11"), 1);
			c = channel_lookup(id);
		}
@


1.39.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.51 2001/02/13 21:51:09 markus Exp $");
d64 1
a65 3
#include "ssh1.h"
#include "ssh2.h"
#include "xmalloc.h"
d68 3
d74 1
d77 1
a77 6
#include "key.h"
#include "log.h"
#include "readconf.h"
#include "clientloop.h"
#include "authfd.h"
#include "atomicio.h"
d122 3
a124 2
static u_long stdin_bytes, stdout_bytes, stderr_bytes;
static u_int buffer_high;/* Soft max buffer size. */
d128 1
d135 1
a135 1
leave_raw_mode(void)
d149 1
a149 1
enter_raw_mode(void)
d175 1
a175 1
leave_non_blocking(void)
d187 1
a187 1
enter_non_blocking(void)
d229 1
a229 1
get_current_time(void)
d243 1
a243 1
client_check_initial_eof_on_stdin(void)
d279 1
a279 1
			if ((u_char) buf[0] == escape_char)
d297 1
a297 1
client_make_packets_from_stdin_data(void)
d299 1
a299 1
	u_int len;
d328 1
a328 1
client_check_window_change(void)
d365 1
a365 2
client_wait_until_can_do_something(fd_set **readsetp, fd_set **writesetp,
    int *maxfdp)
d367 3
a369 2
	/* Add any selections by the channel mechanism. */
	channel_prepare_select(readsetp, writesetp, maxfdp);
d376 1
a376 1
			FD_SET(connection_in, *readsetp);
d382 1
a382 1
			FD_SET(fileno(stdin), *readsetp);
d386 1
a386 1
			FD_SET(fileno(stdout), *writesetp);
d388 1
a388 1
			FD_SET(fileno(stderr), *writesetp);
d390 1
a390 1
		FD_SET(connection_in, *readsetp);
d393 3
d398 6
a403 1
		FD_SET(connection_out, *writesetp);
d414 1
a414 1
	if (select((*maxfdp)+1, *readsetp, *writesetp, NULL, NULL) < 0) {
d416 3
a418 9

		/*
		 * We have to clear the select masks, because we return.
		 * We have to return, because the mainloop checks for the flags
		 * set by the signal handlers.
		 */
		memset(*readsetp, 0, *maxfdp);
		memset(*writesetp, 0, *maxfdp);

d521 2
a522 2
	u_int i;
	u_char ch;
d773 1
a773 1
client_process_buffered_input_packets(void)
a796 2
	fd_set *readset = NULL, *writeset = NULL;
	int max_fd = 0;
d813 3
a815 7
	max_fd = MAX(connection_in, connection_out);

	if (!compat20) {
		max_fd = MAX(max_fd, fileno(stdin));
		max_fd = MAX(max_fd, fileno(stdout));
		max_fd = MAX(max_fd, fileno(stderr));
	}
d840 2
a841 7
	if (compat20) {
		session_ident = ssh2_chan_id;
		if (escape_char != -1)
			channel_register_filter(session_ident,
			    simple_escape_filter);
	} else {
		/* Check if we should immediately send eof on stdin. */
d843 3
a845 1
	}
d849 1
d867 1
a867 1
		 * Make packets from buffered channel data, and enqueue them
d886 1
a886 1
		client_wait_until_can_do_something(&readset, &writeset, &max_fd);
d892 1
a892 1
		channel_after_select(readset, writeset);
d895 1
a895 1
		client_process_net_input(readset);
d902 1
a902 1
			client_process_input(readset);
d907 1
a907 1
			client_process_output(writeset);
d911 1
a911 1
		if (FD_ISSET(connection_out, writeset))
a913 4
	if (readset)
		xfree(readset);
	if (writeset)
		xfree(writeset);
d983 1
a983 1
	u_int data_len;
d994 1
a994 1
	u_int data_len;
a1018 89
Channel *
client_request_forwarded_tcpip(const char *request_type, int rchan)
{
	Channel* c = NULL;
	char *listen_address, *originator_address;
	int listen_port, originator_port;
	int sock, newch;

	/* Get rest of the packet */
	listen_address = packet_get_string(NULL);
	listen_port = packet_get_int();
	originator_address = packet_get_string(NULL);
	originator_port = packet_get_int();
	packet_done();

	debug("client_request_forwarded_tcpip: listen %s port %d, originator %s port %d",
	    listen_address, listen_port, originator_address, originator_port);

	sock = channel_connect_by_listen_adress(listen_port);
	if (sock >= 0) {
		newch = channel_new("forwarded-tcpip",
		    SSH_CHANNEL_CONNECTING, sock, sock, -1,
		    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_WINDOW_DEFAULT, 0,
		    xstrdup(originator_address), 1);
		c = channel_lookup(newch);
	}
	xfree(originator_address);
	xfree(listen_address);
	return c;
}

Channel*
client_request_x11(const char *request_type, int rchan)
{
	Channel *c = NULL;
	char *originator;
	int originator_port;
	int sock, newch;

	if (!options.forward_x11) {
		error("Warning: ssh server tried X11 forwarding.");
		error("Warning: this is probably a break in attempt by a malicious server.");
		return NULL;
	}
	originator = packet_get_string(NULL);
	if (datafellows & SSH_BUG_X11FWD) {
		debug2("buggy server: x11 request w/o originator_port");
		originator_port = 0;
	} else {
		originator_port = packet_get_int();
	}
	packet_done();
	/* XXX check permission */
	debug("client_request_x11: request from %s %d", originator,
	    originator_port);
	sock = x11_connect_display();
	if (sock >= 0) {
		newch = channel_new("x11",
		    SSH_CHANNEL_X11_OPEN, sock, sock, -1,
		    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0,
		    xstrdup("x11"), 1);
		c = channel_lookup(newch);
	}
	xfree(originator);
	return c;
}

Channel*
client_request_agent(const char *request_type, int rchan)
{
	Channel *c = NULL;
	int sock, newch;

	if (!options.forward_agent) {
		error("Warning: ssh server tried agent forwarding.");
		error("Warning: this is probably a break in attempt by a malicious server.");
		return NULL;
	}
	sock =  ssh_get_authentication_socket();
	if (sock >= 0) {
		newch = channel_new("authentication agent connection",
		    SSH_CHANNEL_OPEN, sock, sock, -1,
		    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_WINDOW_DEFAULT, 0,
		    xstrdup("authentication agent connection"), 1);
		c = channel_lookup(newch);
	}
	return c;
}

d1025 2
a1026 1
	u_int len;
d1039 22
a1060 6
	if (strcmp(ctype, "forwarded-tcpip") == 0) {
		c = client_request_forwarded_tcpip(ctype, rchan);
	} else if (strcmp(ctype, "x11") == 0) {
		c = client_request_x11(ctype, rchan);
	} else if (strcmp(ctype, "auth-agent@@openssh.com") == 0) {
		c = client_request_agent(ctype, rchan);
a1085 36
void
client_input_channel_req(int type, int plen, void *ctxt)
{
	Channel *c = NULL;
	int id, reply, success = 0;
	char *rtype;

	id = packet_get_int();
	rtype = packet_get_string(NULL);
	reply = packet_get_char();

	debug("client_input_channel_req: channel %d rtype %s reply %d",
	    id, rtype, reply);

	if (session_ident == -1) {
		error("client_input_channel_req: no channel %d", session_ident);
	} else if (id != session_ident) {
		error("client_input_channel_req: channel %d: wrong channel: %d",
		    session_ident, id);
	}
	c = channel_lookup(id);
	if (c == NULL) {
		error("client_input_channel_req: channel %d: unknown channel", id);
	} else if (strcmp(rtype, "exit-status") == 0) {
		success = 1;
		exit_status = packet_get_int();
		packet_done();
	}
	if (reply) {
		packet_start(success ?
		    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);
		packet_put_int(c->remote_id);
		packet_send();
	}
	xfree(rtype);
}
d1088 1
a1088 1
client_init_dispatch_20(void)
d1098 1
a1098 1
	dispatch_set(SSH2_MSG_CHANNEL_REQUEST, &client_input_channel_req);
d1102 1
a1102 1
client_init_dispatch_13(void)
d1121 1
a1121 1
client_init_dispatch_15(void)
d1128 1
a1128 1
client_init_dispatch(void)
d1136 46
@


1.39.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.39.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.53 2001/03/06 01:08:27 millert Exp $");
d282 1
a282 1
			else
d284 2
a312 1
		stdin_bytes += len;
d423 1
d489 1
d497 1
a497 1
		if (len < 0 && (errno == EAGAIN || errno == EINTR))
d505 1
d539 1
d549 1
d659 1
d676 1
d697 1
d703 2
a704 2
			if (process_escapes(&stdin_buffer, &stdout_buffer,
			    &stderr_buffer, buf, len) == -1)
d706 1
d732 1
a738 1
		stdout_bytes += len; 
a755 1
		stderr_bytes += len; 
d942 1
a952 1
		stdout_bytes += len; 
a963 1
		stderr_bytes += len; 
d998 1
d1009 1
@


1.39.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.65 2001/04/20 07:17:51 djm Exp $");
a75 1
#include "kex.h"
a80 2
#include "sshtty.h"
#include "misc.h"
d103 9
a128 2
static int need_rekeying;	/* Set to non-zero if rekeying is requested. */
static int session_closed = 0;	/* In SSH2: login session closed. */
d133 39
a171 2
/*XXX*/
extern Kex *xxx_kex;
d215 1
a215 1
	if (in_raw_mode())
d366 1
a366 1
    int *maxfdp, int rekeying)
d369 1
a369 1
	channel_prepare_select(readsetp, writesetp, maxfdp, rekeying);
a550 9
			case 'R':
				if (compat20) {
					if (datafellows & SSH_BUG_NOREKEY)
						log("Server does not support re-keying");
					else
						need_rekeying = 1;
				}
				continue;

a600 1
~R - Request rekey (SSH protocol 2 only)\r\n\
a659 2
		if (len < 0 && (errno == EAGAIN || errno == EINTR))
			return;		/* we'll try again later */
d713 1
a713 1
			if (errno == EINTR || errno == EAGAIN)
d728 1
a728 1
		stdout_bytes += len;
d736 1
a736 1
			if (errno == EINTR || errno == EAGAIN)
d746 1
a746 1
		stderr_bytes += len;
d765 1
a765 1
	dispatch_run(DISPATCH_NONBLOCK, &quit_pending, compat20 ? xxx_kex : NULL);
a776 11
void
client_channel_closed(int id, void *arg)
{
	if (id != session_ident)
		error("client_channel_closed: id %d != session_ident %d",
		    id, session_ident);
	session_closed = 1;
	if (in_raw_mode())
		leave_raw_mode();
}

d788 1
d790 1
a790 1
	int max_fd = 0, len, rekeying = 0;
a807 7
		/* enable nonblocking unless tty */
		if (!isatty(fileno(stdin)))
			set_nonblock(fileno(stdin));
		if (!isatty(fileno(stdout)))
			set_nonblock(fileno(stdout));
		if (!isatty(fileno(stderr)))
			set_nonblock(fileno(stderr));
a840 3
		if (session_ident != -1)
			channel_register_cleanup(session_ident,
			    client_channel_closed);
d852 2
a853 1
		if (compat20 && session_closed && !channel_still_open())
d855 1
d857 6
a862 1
		rekeying = (xxx_kex != NULL && !xxx_kex->done);
d864 6
a869 9
		if (rekeying) {
			debug("rekeying in progress");
		} else {
			/*
			 * Make packets of buffered stdin data, and buffer
			 * them for sending to the server.
			 */
			if (!compat20)
				client_make_packets_from_stdin_data();
d871 5
a875 6
			/*
			 * Make packets from buffered channel data, and
			 * enqueue them for sending to the server.
			 */
			if (packet_not_very_much_data_to_write())
				channel_output_poll();
d877 2
a878 5
			/*
			 * Check if the window size has changed, and buffer a
			 * message about it to the server if so.
			 */
			client_check_window_change();
a879 3
			if (quit_pending)
				break;
		}
d884 1
a884 2
		client_wait_until_can_do_something(&readset, &writeset,
		    &max_fd, rekeying);
d889 2
a890 11
		/* Do channel operations unless rekeying in progress. */
		if (!rekeying) {
			channel_after_select(readset, writeset);

			if (need_rekeying) {
				debug("user requests rekeying");
				xxx_kex->done = 0;
				kex_send_kexinit(xxx_kex);
				need_rekeying = 0;
			}
		}
d943 1
a943 1
		stdout_bytes += len;
d955 1
a955 1
		stderr_bytes += len;
a1208 3

	/* rekeying */
	dispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);
@


1.39.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d38 1
a38 1
 * Copyright (c) 1999, 2000, 2001 Markus Friedl.  All rights reserved.
d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.82 2001/09/17 20:52:47 markus Exp $");
a104 1
static volatile int received_signal = 0;
d126 1
a126 1
static void client_init_dispatch(void);
d134 1
a134 1
static void
d146 1
a146 1
static void
d159 1
a159 1
static void
d171 1
a171 1
static void
d174 7
a180 2
	received_signal = sig;
	quit_pending = 1;
d188 1
a188 1
static double
d202 1
a202 1
static void
d254 1
a254 1
static void
d286 1
a286 1
static void
d323 1
a323 1
static void
d325 1
a325 1
    int *maxfdp, int *nallocp, int rekeying)
d328 1
a328 1
	channel_prepare_select(readsetp, writesetp, maxfdp, nallocp, rekeying);
d349 1
a349 7
		/* channel_prepare_select could have closed the last channel */
		if (session_closed && !channel_still_open()) {
			if (!packet_have_data_to_write())
				return;
		} else {
			FD_SET(connection_in, *readsetp);
		}
d385 1
a385 1
static void
d428 1
a428 1
static void
d469 1
a469 1
static int
d547 1
a547 1
				channel_close_all();	/* proto1 only XXXX */
d569 1
a569 1
~R  - Request rekey (SSH protocol 2 only)\r\n\
d619 1
a619 1
static void
d654 1
a654 1
		} else if (escape_char == SSH_ESCAPECHAR_NONE) {
d672 1
a672 1
static void
d733 1
a733 1
static void
d741 1
a741 1
static int
d748 1
a748 1
static void
d762 2
a763 2
 * remote host.  If escape_char != SSH_ESCAPECHAR_NONE, it is the character
 * used as an escape character for terminating or suspending the session.
d771 1
a771 1
	int max_fd = 0, max_fd2 = 0, len, rekeying = 0, nalloc = 0;
d826 1
a826 1
		if (escape_char != SSH_ESCAPECHAR_NONE)
a877 1
		max_fd2 = max_fd;
d879 1
a879 1
		    &max_fd2, &nalloc, rekeying);
d927 2
a928 18
	channel_free_all();

	if (have_pty)
		leave_raw_mode();

	/* restore blocking io */
	if (!isatty(fileno(stdin)))
		unset_nonblock(fileno(stdin));
	if (!isatty(fileno(stdout)))
		unset_nonblock(fileno(stdout));
	if (!isatty(fileno(stderr)))
		unset_nonblock(fileno(stderr));

	if (received_signal) {
		if (in_non_blocking_mode)	/* XXX */
			leave_non_blocking();
		fatal("Killed by signal %d.", received_signal);
	}
a937 1

d962 3
d987 1
a987 1
static void
d997 1
a997 1
static void
d1007 1
a1007 1
static void
d1024 1
a1024 1
static Channel *
d1030 1
a1030 1
	int sock;
d1042 7
a1048 13
	sock = channel_connect_by_listen_address(listen_port);
	if (sock < 0) {
		xfree(originator_address);
		xfree(listen_address);
		return NULL;
	}
	c = channel_new("forwarded-tcpip",
	    SSH_CHANNEL_CONNECTING, sock, sock, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_WINDOW_DEFAULT, 0,
	    xstrdup(originator_address), 1);
	if (c == NULL) {
		error("client_request_forwarded_tcpip: channel_new failed");
		close(sock);
d1055 1
a1055 1
static Channel*
d1061 1
a1061 1
	int sock;
a1078 1
	xfree(originator);
d1080 6
a1085 9
	if (sock < 0)
		return NULL;
	c = channel_new("x11",
	    SSH_CHANNEL_X11_OPEN, sock, sock, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0,
	    xstrdup("x11"), 1);
	if (c == NULL) {
		error("client_request_x11: channel_new failed");
		close(sock);
d1087 1
a1087 1
	c->force_drain = 1;
d1091 1
a1091 1
static Channel*
d1095 1
a1095 1
	int sock;
d1103 6
a1108 9
	if (sock < 0)
		return NULL;
	c = channel_new("authentication agent connection",
	    SSH_CHANNEL_OPEN, sock, sock, -1,
	    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_WINDOW_DEFAULT, 0,
	    xstrdup("authentication agent connection"), 1);
	if (c == NULL) {
		error("client_request_agent: channel_new failed");
		close(sock);
a1109 1
	c->force_drain = 1;
d1114 1
a1114 1
static void
d1145 7
a1151 8
		if (c->type != SSH_CHANNEL_CONNECTING) {
			packet_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);
			packet_put_int(c->remote_id);
			packet_put_int(c->self);
			packet_put_int(c->local_window);
			packet_put_int(c->local_maxpacket);
			packet_send();
		}
d1157 2
a1158 4
		if (!(datafellows & SSH_BUG_OPENFAILURE)) {
			packet_put_cstring("open failed");
			packet_put_cstring("");
		}
d1163 1
a1163 1
static void
d1200 1
a1200 1
static void
d1217 1
a1217 1
static void
d1236 1
a1236 1
static void
d1243 1
a1243 1
static void
@


1.39.2.6
log
@Merge OpenSSH 3.0
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.39.2.5 2001/09/27 00:15:41 miod Exp $");
d346 3
a348 6
		if (session_closed && !channel_still_open() &&
		    !packet_have_data_to_write()) {
			/* clear mask since we did not call select() */
			memset(*readsetp, 0, *maxfdp);
			memset(*writesetp, 0, *maxfdp);
			return;
a755 1
	channel_cancel_cleanup(id);
@


1.39.2.7
log
@Merge OpenSSH 3.0.1.

This is likely to be the last commit to the 2.8-STABLE branch.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.39.2.6 2001/11/15 00:14:59 miod Exp $");
d349 2
a350 2
			memset(*readsetp, 0, *nallocp);
			memset(*writesetp, 0, *nallocp);
d378 2
a379 2
		memset(*readsetp, 0, *nallocp);
		memset(*writesetp, 0, *nallocp);
d525 3
d532 16
d552 1
a552 1
				channel_stop_listening();
d554 1
a554 3
				snprintf(string, sizeof string,
				    "%c& [backgrounded]\n", escape_char);
				buffer_append(berr, string, strlen(string));
d567 1
a567 21
				if (compat20) {
					buffer_append(bin, "\004", 1);
					/* fake EOF on stdin */
					return -1;
				} else if (!stdin_eof) {
					/*
					 * Sending SSH_CMSG_EOF alone does not always appear
					 * to be enough.  So we try to send an EOF character
					 * first.
					 */
					packet_start(SSH_CMSG_STDIN_DATA);
					packet_put_string("\004", 1);
					packet_send();
					/* Close stdin. */
					stdin_eof = 1;
					if (buffer_len(bin) == 0) {
						packet_start(SSH_CMSG_EOF);
						packet_send();
					}
				}
				continue;
d823 1
@


1.39.2.8
log
@Merge OpenSSH 3.1.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.96 2002/02/06 14:55:15 markus Exp $");
d104 2
a105 2
static volatile sig_atomic_t received_window_change_signal = 0;
static volatile sig_atomic_t received_signal = 0;
d257 1
a257 1
	    packet_not_very_much_data_to_write()) {
d420 3
a422 3
	    oldws.ws_col != newws.ws_col ||
	    oldws.ws_xpixel != newws.ws_xpixel ||
	    oldws.ws_ypixel != newws.ws_ypixel))
d952 1
a952 1
		fatal("Killed by signal %d.", (int) received_signal);
d997 1
a997 1
	    stdin_bytes, stdout_bytes, stderr_bytes, total_time);
d1000 2
a1001 2
		    stdin_bytes / total_time, stdout_bytes / total_time,
		    stderr_bytes / total_time);
d1011 1
a1011 1
client_input_stdout_data(int type, u_int32_t seq, void *ctxt)
d1015 1
a1015 1
	packet_check_eom();
d1021 1
a1021 1
client_input_stderr_data(int type, u_int32_t seq, void *ctxt)
d1025 1
a1025 1
	packet_check_eom();
d1031 1
a1031 1
client_input_exit_status(int type, u_int32_t seq, void *ctxt)
d1033 1
a1034 1
	packet_check_eom();
d1060 1
a1060 1
	packet_check_eom();
d1075 4
d1104 1
a1104 1
	packet_check_eom();
d1116 4
d1142 4
d1152 1
a1152 1
client_input_channel_open(int type, u_int32_t seq, void *ctxt)
d1204 1
a1204 1
client_input_channel_req(int type, u_int32_t seq, void *ctxt)
d1229 1
a1229 1
		packet_check_eom();
a1238 18
static void
client_input_global_request(int type, u_int32_t seq, void *ctxt)
{
	char *rtype;
	int want_reply;
	int success = 0;

	rtype = packet_get_string(NULL);
	want_reply = packet_get_char();
	debug("client_input_global_request: rtype %s want_reply %d", rtype, want_reply);
	if (want_reply) {
		packet_start(success ?
		    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);
		packet_send();
		packet_write_wait();
	}
	xfree(rtype);
}
a1252 1
	dispatch_set(SSH2_MSG_GLOBAL_REQUEST, &client_input_global_request);
@


1.38
log
@enable non-blocking IO on channels, and tty's (except for the client ttys).
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.37 2000/09/26 19:59:58 markus Exp $");
d78 4
a796 1
	extern Options options;
d1039 1
a1039 1
	if (strcmp(ctype, "x11") == 0) {
a1110 1
	dispatch_set(SSH_SMSG_AGENT_OPEN, &auth_input_open_request);
d1114 5
a1118 1
	dispatch_set(SSH_SMSG_X11_OPEN, &x11_input_open);
@


1.37
log
@use debug2
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.36 2000/09/21 11:25:33 markus Exp $");
d1055 1
a1055 1
			    CHAN_X11_PACKET_DEFAULT, 0, xstrdup("x11"));
@


1.36
log
@add context to dispatch_run
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.35 2000/09/14 20:25:14 markus Exp $");
d336 1
a336 1
	debug("client_check_window_change: changed");
a362 2
	/*debug("client_wait_until_can_do_something"); */

a480 1
/*debug("read connection_in len %d", len); XXX */
d852 1
a852 1
			debug("!channel_still_open.");
d1042 1
a1042 1
			debug("buggy server: x11 request w/o originator_port");
d1172 1
a1172 1
	debug("client_set_session_ident: id %d", id);
@


1.35
log
@typo
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.34 2000/09/07 20:40:30 markus Exp $");
d774 1
a774 1
	dispatch_run(DISPATCH_NONBLOCK, &quit_pending);
d981 1
a981 1
client_input_stdout_data(int type, int plen)
d992 1
a992 1
client_input_stderr_data(int type, int plen)
d1003 1
a1003 1
client_input_exit_status(int type, int plen)
d1021 1
a1021 1
client_input_channel_open(int type, int plen)
@


1.34
log
@cleanup window and packet sizes for ssh2 flow control; ok niels
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.33 2000/09/07 20:27:50 deraadt Exp $");
d1151 1
a1151 1
		fatal("session_input_channel_req: channel %d: bad channel", id);
@


1.33
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.32 2000/08/19 22:21:19 markus Exp $");
a1055 1
/*XXX MAXPACK */
d1057 2
a1058 2
			    sock, sock, -1, 4*1024, 32*1024, 0,
			    xstrdup("x11"));
@


1.32
log
@oops
@
text
@a1 3
 *
 * clientloop.c
 *
a2 1
 *
d5 1
d7 28
a35 1
 * Created: Sat Sep 23 12:23:57 1995 ylo
d37 2
a38 1
 * The main loop for the interactive session (client side).
d40 19
a58 1
 * SSH2 support added by Markus Friedl.
d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.31 2000/08/19 21:55:52 markus Exp $");
@


1.31
log
@more ~ support for ssh2
@
text
@d19 1
a19 1
RCSID("$OpenBSD: clientloop.c,v 1.30 2000/08/19 18:48:11 markus Exp $");
d474 1
d494 3
a496 3
				snprintf(buf, sizeof buf, "%c.\r\n", escape_char);
				buffer_append(berr, buf, strlen(buf));
				/*stderr_bytes += strlen(buf); XXX*/
d504 3
a506 3
				snprintf(buf, sizeof buf, "%c^Z [suspend ssh]\r\n", escape_char);
				buffer_append(berr, buf, strlen(buf));
				/*stderr_bytes += strlen(buf); XXX*/
d560 1
a560 1
				snprintf(buf, sizeof buf,
d571 1
a571 1
				buffer_append(berr, buf, strlen(buf));
d575 2
a576 2
				snprintf(buf, sizeof buf, "%c#\r\n", escape_char);
				buffer_append(berr, buf, strlen(buf));
@


1.30
log
@support for ~. in ssh2
@
text
@d19 1
a19 1
RCSID("$OpenBSD: clientloop.c,v 1.29 2000/07/16 08:27:21 markus Exp $");
d66 2
d75 1
a79 3
static unsigned long stdin_bytes, stdout_bytes, stderr_bytes;
static int quit_pending;	/* Set to non-zero to quit the client loop. */
static int escape_char;		/* Escape character. */
d385 1
a385 1
client_suspend_self()
d390 4
a393 6
	if (buffer_len(&stdout_buffer) > 0)
		atomicio(write, fileno(stdout), buffer_ptr(&stdout_buffer),
		    buffer_len(&stdout_buffer));
	if (buffer_len(&stderr_buffer) > 0)
		atomicio(write, fileno(stderr), buffer_ptr(&stderr_buffer),
		    buffer_len(&stderr_buffer));
d401 3
a403 3
	buffer_free(&stdin_buffer);
	buffer_free(&stdout_buffer);
	buffer_free(&stderr_buffer);
d420 3
a422 3
	buffer_init(&stdin_buffer);
	buffer_init(&stdout_buffer);
	buffer_init(&stderr_buffer);
d470 142
d615 1
d617 1
a617 2
	pid_t pid;
	char buf[8192], *s;
d659 4
a662 139
			unsigned int i;
			for (i = 0; i < len; i++) {
				unsigned char ch;
				/* Get one character at a time. */
				ch = buf[i];

				if (escape_pending) {
					/* We have previously seen an escape character. */
					/* Clear the flag now. */
					escape_pending = 0;
					/* Process the escaped character. */
					switch (ch) {
					case '.':
						/* Terminate the connection. */
						snprintf(buf, sizeof buf, "%c.\r\n", escape_char);
						buffer_append(&stderr_buffer, buf, strlen(buf));
						stderr_bytes += strlen(buf);
						quit_pending = 1;
						return;

					case 'Z' - 64:
						/* Suspend the program. */
						/* Print a message to that effect to the user. */
						snprintf(buf, sizeof buf, "%c^Z\r\n", escape_char);
						buffer_append(&stderr_buffer, buf, strlen(buf));
						stderr_bytes += strlen(buf);

						/* Restore terminal modes and suspend. */
						client_suspend_self();

						/* We have been continued. */
						continue;

					case '&':
						/*
						 * Detach the program (continue to serve connections,
						 * but put in background and no more new connections).
						 */
						if (!stdin_eof) {
							/*
							 * Sending SSH_CMSG_EOF alone does not always appear
							 * to be enough.  So we try to send an EOF character
							 * first.
							 */
							packet_start(SSH_CMSG_STDIN_DATA);
							packet_put_string("\004", 1);
							packet_send();
							/* Close stdin. */
							stdin_eof = 1;
							if (buffer_len(&stdin_buffer) == 0) {
								packet_start(SSH_CMSG_EOF);
								packet_send();
							}
						}
						/* Restore tty modes. */
						leave_raw_mode();

						/* Stop listening for new connections. */
						channel_stop_listening();

						printf("%c& [backgrounded]\n", escape_char);

						/* Fork into background. */
						pid = fork();
						if (pid < 0) {
							error("fork: %.100s", strerror(errno));
							continue;
						}
						if (pid != 0) {	/* This is the parent. */
							/* The parent just exits. */
							exit(0);
						}
						/* The child continues serving connections. */
						continue;

					case '?':
						snprintf(buf, sizeof buf,
"%c?\r\n\
Supported escape sequences:\r\n\
~.  - terminate connection\r\n\
~^Z - suspend ssh\r\n\
~#  - list forwarded connections\r\n\
~&  - background ssh (when waiting for connections to terminate)\r\n\
~?  - this message\r\n\
~~  - send the escape character by typing it twice\r\n\
(Note that escapes are only recognized immediately after newline.)\r\n",
							 escape_char);
						buffer_append(&stderr_buffer, buf, strlen(buf));
						continue;

					case '#':
						snprintf(buf, sizeof buf, "%c#\r\n", escape_char);
						buffer_append(&stderr_buffer, buf, strlen(buf));
						s = channel_open_message();
						buffer_append(&stderr_buffer, s, strlen(s));
						xfree(s);
						continue;

					default:
						if (ch != escape_char) {
							/*
							 * Escape character followed by non-special character.
							 * Append both to the input buffer.
							 */
							buf[0] = escape_char;
							buf[1] = ch;
							buffer_append(&stdin_buffer, buf, 2);
							stdin_bytes += 2;
							continue;
						}
						/*
						 * Note that escape character typed twice
						 * falls through here; the latter gets processed
						 * as a normal character below.
						 */
						break;
					}
				} else {
					/*
					 * The previous character was not an escape char. Check if this
					 * is an escape.
					 */
					if (last_was_cr && ch == escape_char) {
						/* It is. Set the flag and continue to next character. */
						escape_pending = 1;
						continue;
					}
				}

				/*
				 * Normal character.  Record whether it was a newline,
				 * and append it to the buffer.
				 */
				last_was_cr = (ch == '\r' || ch == '\n');
				buf[0] = ch;
				buffer_append(&stdin_buffer, buf, 1);
				stdin_bytes += 1;
				continue;
			}
d733 1
a733 1
/* scan stdin buf[] for '~' before sending data to the peer */
d736 1
a736 1
simple_escape_filter(Buffer *bin, char *buf, int len)
d738 2
a739 22
	unsigned int i;
	unsigned char ch;
	for (i = 0; i < len; i++) {
		ch = buf[i];
		if (escape_pending) {
			escape_pending = 0;
			if (ch == '.') {
				quit_pending = 1;
				return -1;
			}
			if (ch != escape_char)
				buffer_put_char(bin, escape_char);
		} else {
			if (last_was_cr && ch == escape_char) {
				escape_pending = 1;
				continue;
			}	
		}
		last_was_cr = (ch == '\n' || ch == '\r');
		buffer_put_char(bin, ch);
	}
	return 0;
@


1.29
log
@make ssh-add accept dsa keys (the agent does not)
@
text
@d19 1
a19 1
RCSID("$OpenBSD: clientloop.c,v 1.28 2000/07/13 23:14:08 provos Exp $");
d32 3
d728 29
d765 1
a765 1
client_loop(int have_pty, int escape_char_arg)
d815 3
d1027 1
@


1.28
log
@typo; todd@@fries.net
@
text
@d19 1
a19 1
RCSID("$OpenBSD: clientloop.c,v 1.27 2000/06/20 01:39:40 markus Exp $");
a24 1
#include "authfd.h"
a30 1

@


1.27
log
@OpenBSD tag
@
text
@d19 1
a19 1
RCSID("$OpenBSD: clientloop.c,v 1.26 2000/05/08 17:42:24 markus Exp $");
d781 1
a781 1
	/* Check if we should immediately send of on stdin. */
@


1.26
log
@bug compat w/ ssh-2.0.13 x11, split out bugs
@
text
@d19 1
a19 1
RCSID("$Id: clientloop.c,v 1.25 2000/05/07 18:23:32 markus Exp $");
@


1.26.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d19 1
a19 1
RCSID("$OpenBSD: clientloop.c,v 1.32 2000/08/19 22:21:19 markus Exp $");
d25 1
a32 2
#include "buffer.h"
#include "bufaux.h"
a64 2
static int quit_pending;	/* Set to non-zero to quit the client loop. */
static int escape_char;		/* Escape character. */
a71 1
static unsigned long stdin_bytes, stdout_bytes, stderr_bytes;
d76 3
d384 1
a384 1
client_suspend_self(Buffer *bin, Buffer *bout, Buffer *berr)
d389 6
a394 4
	if (buffer_len(bout) > 0)
		atomicio(write, fileno(stdout), buffer_ptr(bout), buffer_len(bout));
	if (buffer_len(berr) > 0)
		atomicio(write, fileno(stderr), buffer_ptr(berr), buffer_len(berr));
d402 3
a404 3
	buffer_free(bin);
	buffer_free(bout);
	buffer_free(berr);
d421 3
a423 3
	buffer_init(bin);
	buffer_init(bout);
	buffer_init(berr);
a470 143
/* process the characters one by one */
int
process_escapes(Buffer *bin, Buffer *bout, Buffer *berr, char *buf, int len)
{
	char string[1024];
	pid_t pid;
	int bytes = 0;
	unsigned int i;
	unsigned char ch;
	char *s;

	for (i = 0; i < len; i++) {
		/* Get one character at a time. */
		ch = buf[i];

		if (escape_pending) {
			/* We have previously seen an escape character. */
			/* Clear the flag now. */
			escape_pending = 0;

			/* Process the escaped character. */
			switch (ch) {
			case '.':
				/* Terminate the connection. */
				snprintf(string, sizeof string, "%c.\r\n", escape_char);
				buffer_append(berr, string, strlen(string));
				/*stderr_bytes += strlen(string); XXX*/

				quit_pending = 1;
				return -1;

			case 'Z' - 64:
				/* Suspend the program. */
				/* Print a message to that effect to the user. */
				snprintf(string, sizeof string, "%c^Z [suspend ssh]\r\n", escape_char);
				buffer_append(berr, string, strlen(string));
				/*stderr_bytes += strlen(string); XXX*/

				/* Restore terminal modes and suspend. */
				client_suspend_self(bin, bout, berr);

				/* We have been continued. */
				continue;

			case '&':
				/* XXX does not work yet with proto 2 */
				if (compat20)
					continue;
				/*
				 * Detach the program (continue to serve connections,
				 * but put in background and no more new connections).
				 */
				if (!stdin_eof) {
					/*
					 * Sending SSH_CMSG_EOF alone does not always appear
					 * to be enough.  So we try to send an EOF character
					 * first.
					 */
					packet_start(SSH_CMSG_STDIN_DATA);
					packet_put_string("\004", 1);
					packet_send();
					/* Close stdin. */
					stdin_eof = 1;
					if (buffer_len(bin) == 0) {
						packet_start(SSH_CMSG_EOF);
						packet_send();
					}
				}
				/* Restore tty modes. */
				leave_raw_mode();

				/* Stop listening for new connections. */
				channel_stop_listening();

				printf("%c& [backgrounded]\n", escape_char);

				/* Fork into background. */
				pid = fork();
				if (pid < 0) {
					error("fork: %.100s", strerror(errno));
					continue;
				}
				if (pid != 0) {	/* This is the parent. */
					/* The parent just exits. */
					exit(0);
				}
				/* The child continues serving connections. */
				continue; /*XXX ? */

			case '?':
				snprintf(string, sizeof string,
"%c?\r\n\
Supported escape sequences:\r\n\
~.  - terminate connection\r\n\
~^Z - suspend ssh\r\n\
~#  - list forwarded connections\r\n\
~&  - background ssh (when waiting for connections to terminate)\r\n\
~?  - this message\r\n\
~~  - send the escape character by typing it twice\r\n\
(Note that escapes are only recognized immediately after newline.)\r\n",
					 escape_char);
				buffer_append(berr, string, strlen(string));
				continue;

			case '#':
				snprintf(string, sizeof string, "%c#\r\n", escape_char);
				buffer_append(berr, string, strlen(string));
				s = channel_open_message();
				buffer_append(berr, s, strlen(s));
				xfree(s);
				continue;

			default:
				if (ch != escape_char) {
					buffer_put_char(bin, escape_char);
					bytes++;
				}
				/* Escaped characters fall through here */
				break;
			}
		} else {
			/*
			 * The previous character was not an escape char. Check if this
			 * is an escape.
			 */
			if (last_was_cr && ch == escape_char) {
				/* It is. Set the flag and continue to next character. */
				escape_pending = 1;
				continue;
			}
		}

		/*
		 * Normal character.  Record whether it was a newline,
		 * and append it to the buffer.
		 */
		last_was_cr = (ch == '\r' || ch == '\n');
		buffer_put_char(bin, ch);
		bytes++;
	}
	return bytes;
}

a473 1
	int ret;
d475 2
a476 1
	char buf[8192];
d518 139
a656 4
			ret = process_escapes(&stdin_buffer, &stdout_buffer, &stderr_buffer, buf, len);
			if (ret == -1)
				return;
			stdout_bytes += ret;
a726 9
/* scan buf[] for '~' before sending data to the peer */

int
simple_escape_filter(Channel *c, char *buf, int len)
{
	/* XXX we assume c->extended is writeable */
	return process_escapes(&c->input, &c->output, &c->extended, buf, len);
}

d735 1
a735 1
client_loop(int have_pty, int escape_char_arg, int ssh2_chan_id)
d781 1
a781 1
	/* Check if we should immediately send eof on stdin. */
a784 3
	if (compat20 && escape_char != -1)
		channel_register_filter(ssh2_chan_id, simple_escape_filter);

a993 1
/*XXX MAXPACK */
@


1.26.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
a8 1
 * The main loop for the interactive session (client side).
a9 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d11 1
d13 1
a13 22
 * Copyright (c) 1999 Theo de Raadt.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
a15 21
 * Copyright (c) 1999,2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d19 1
a19 1
RCSID("$OpenBSD: clientloop.c,v 1.39 2000/10/27 07:48:22 markus Exp $");
a34 4

/* import options */
extern Options options;

d293 1
a293 1
	debug2("client_check_window_change: changed");
d320 2
d440 1
d731 1
a731 1
	dispatch_run(DISPATCH_NONBLOCK, &quit_pending, NULL);
d753 1
d812 1
a812 1
			debug2("!channel_still_open.");
d938 1
a938 1
client_input_stdout_data(int type, int plen, void *ctxt)
d949 1
a949 1
client_input_stderr_data(int type, int plen, void *ctxt)
d960 1
a960 1
client_input_exit_status(int type, int plen, void *ctxt)
d978 1
a978 1
client_input_channel_open(int type, int plen, void *ctxt)
d996 1
a996 1
	if (strcmp(ctype, "x11") == 0 && options.forward_x11) {
d1002 1
a1002 1
			debug2("buggy server: x11 request w/o originator_port");
d1013 1
d1015 2
a1016 2
			    sock, sock, -1, CHAN_X11_WINDOW_DEFAULT,
			    CHAN_X11_PACKET_DEFAULT, 0, xstrdup("x11"), 1);
d1069 1
d1073 1
a1073 5

	dispatch_set(SSH_SMSG_AGENT_OPEN, options.forward_agent ?
	    &auth_input_open_request : &deny_input_open);
	dispatch_set(SSH_SMSG_X11_OPEN, options.forward_x11 ?
	    &x11_input_open : &deny_input_open);
d1109 1
a1109 1
		fatal("client_input_channel_req: channel %d: bad channel", id);
d1133 1
a1133 1
	debug2("client_set_session_ident: id %d", id);
@


1.26.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.51 2001/02/13 21:51:09 markus Exp $");
d64 1
a65 3
#include "ssh1.h"
#include "ssh2.h"
#include "xmalloc.h"
d68 3
d74 1
d77 1
a77 6
#include "key.h"
#include "log.h"
#include "readconf.h"
#include "clientloop.h"
#include "authfd.h"
#include "atomicio.h"
d122 3
a124 2
static u_long stdin_bytes, stdout_bytes, stderr_bytes;
static u_int buffer_high;/* Soft max buffer size. */
d128 1
d135 1
a135 1
leave_raw_mode(void)
d149 1
a149 1
enter_raw_mode(void)
d175 1
a175 1
leave_non_blocking(void)
d187 1
a187 1
enter_non_blocking(void)
d229 1
a229 1
get_current_time(void)
d243 1
a243 1
client_check_initial_eof_on_stdin(void)
d279 1
a279 1
			if ((u_char) buf[0] == escape_char)
d297 1
a297 1
client_make_packets_from_stdin_data(void)
d299 1
a299 1
	u_int len;
d328 1
a328 1
client_check_window_change(void)
d365 1
a365 2
client_wait_until_can_do_something(fd_set **readsetp, fd_set **writesetp,
    int *maxfdp)
d367 3
a369 2
	/* Add any selections by the channel mechanism. */
	channel_prepare_select(readsetp, writesetp, maxfdp);
d376 1
a376 1
			FD_SET(connection_in, *readsetp);
d382 1
a382 1
			FD_SET(fileno(stdin), *readsetp);
d386 1
a386 1
			FD_SET(fileno(stdout), *writesetp);
d388 1
a388 1
			FD_SET(fileno(stderr), *writesetp);
d390 1
a390 1
		FD_SET(connection_in, *readsetp);
d393 3
d398 6
a403 1
		FD_SET(connection_out, *writesetp);
d414 1
a414 1
	if (select((*maxfdp)+1, *readsetp, *writesetp, NULL, NULL) < 0) {
d416 3
a418 9

		/*
		 * We have to clear the select masks, because we return.
		 * We have to return, because the mainloop checks for the flags
		 * set by the signal handlers.
		 */
		memset(*readsetp, 0, *maxfdp);
		memset(*writesetp, 0, *maxfdp);

d521 2
a522 2
	u_int i;
	u_char ch;
d773 1
a773 1
client_process_buffered_input_packets(void)
a796 2
	fd_set *readset = NULL, *writeset = NULL;
	int max_fd = 0;
d813 3
a815 7
	max_fd = MAX(connection_in, connection_out);

	if (!compat20) {
		max_fd = MAX(max_fd, fileno(stdin));
		max_fd = MAX(max_fd, fileno(stdout));
		max_fd = MAX(max_fd, fileno(stderr));
	}
d840 2
a841 7
	if (compat20) {
		session_ident = ssh2_chan_id;
		if (escape_char != -1)
			channel_register_filter(session_ident,
			    simple_escape_filter);
	} else {
		/* Check if we should immediately send eof on stdin. */
d843 3
a845 1
	}
d849 1
d867 1
a867 1
		 * Make packets from buffered channel data, and enqueue them
d886 1
a886 1
		client_wait_until_can_do_something(&readset, &writeset, &max_fd);
d892 1
a892 1
		channel_after_select(readset, writeset);
d895 1
a895 1
		client_process_net_input(readset);
d902 1
a902 1
			client_process_input(readset);
d907 1
a907 1
			client_process_output(writeset);
d911 1
a911 1
		if (FD_ISSET(connection_out, writeset))
a913 4
	if (readset)
		xfree(readset);
	if (writeset)
		xfree(writeset);
d983 1
a983 1
	u_int data_len;
d994 1
a994 1
	u_int data_len;
a1018 89
Channel *
client_request_forwarded_tcpip(const char *request_type, int rchan)
{
	Channel* c = NULL;
	char *listen_address, *originator_address;
	int listen_port, originator_port;
	int sock, newch;

	/* Get rest of the packet */
	listen_address = packet_get_string(NULL);
	listen_port = packet_get_int();
	originator_address = packet_get_string(NULL);
	originator_port = packet_get_int();
	packet_done();

	debug("client_request_forwarded_tcpip: listen %s port %d, originator %s port %d",
	    listen_address, listen_port, originator_address, originator_port);

	sock = channel_connect_by_listen_adress(listen_port);
	if (sock >= 0) {
		newch = channel_new("forwarded-tcpip",
		    SSH_CHANNEL_CONNECTING, sock, sock, -1,
		    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_WINDOW_DEFAULT, 0,
		    xstrdup(originator_address), 1);
		c = channel_lookup(newch);
	}
	xfree(originator_address);
	xfree(listen_address);
	return c;
}

Channel*
client_request_x11(const char *request_type, int rchan)
{
	Channel *c = NULL;
	char *originator;
	int originator_port;
	int sock, newch;

	if (!options.forward_x11) {
		error("Warning: ssh server tried X11 forwarding.");
		error("Warning: this is probably a break in attempt by a malicious server.");
		return NULL;
	}
	originator = packet_get_string(NULL);
	if (datafellows & SSH_BUG_X11FWD) {
		debug2("buggy server: x11 request w/o originator_port");
		originator_port = 0;
	} else {
		originator_port = packet_get_int();
	}
	packet_done();
	/* XXX check permission */
	debug("client_request_x11: request from %s %d", originator,
	    originator_port);
	sock = x11_connect_display();
	if (sock >= 0) {
		newch = channel_new("x11",
		    SSH_CHANNEL_X11_OPEN, sock, sock, -1,
		    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0,
		    xstrdup("x11"), 1);
		c = channel_lookup(newch);
	}
	xfree(originator);
	return c;
}

Channel*
client_request_agent(const char *request_type, int rchan)
{
	Channel *c = NULL;
	int sock, newch;

	if (!options.forward_agent) {
		error("Warning: ssh server tried agent forwarding.");
		error("Warning: this is probably a break in attempt by a malicious server.");
		return NULL;
	}
	sock =  ssh_get_authentication_socket();
	if (sock >= 0) {
		newch = channel_new("authentication agent connection",
		    SSH_CHANNEL_OPEN, sock, sock, -1,
		    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_WINDOW_DEFAULT, 0,
		    xstrdup("authentication agent connection"), 1);
		c = channel_lookup(newch);
	}
	return c;
}

d1025 2
a1026 1
	u_int len;
d1039 22
a1060 6
	if (strcmp(ctype, "forwarded-tcpip") == 0) {
		c = client_request_forwarded_tcpip(ctype, rchan);
	} else if (strcmp(ctype, "x11") == 0) {
		c = client_request_x11(ctype, rchan);
	} else if (strcmp(ctype, "auth-agent@@openssh.com") == 0) {
		c = client_request_agent(ctype, rchan);
a1085 36
void
client_input_channel_req(int type, int plen, void *ctxt)
{
	Channel *c = NULL;
	int id, reply, success = 0;
	char *rtype;

	id = packet_get_int();
	rtype = packet_get_string(NULL);
	reply = packet_get_char();

	debug("client_input_channel_req: channel %d rtype %s reply %d",
	    id, rtype, reply);

	if (session_ident == -1) {
		error("client_input_channel_req: no channel %d", session_ident);
	} else if (id != session_ident) {
		error("client_input_channel_req: channel %d: wrong channel: %d",
		    session_ident, id);
	}
	c = channel_lookup(id);
	if (c == NULL) {
		error("client_input_channel_req: channel %d: unknown channel", id);
	} else if (strcmp(rtype, "exit-status") == 0) {
		success = 1;
		exit_status = packet_get_int();
		packet_done();
	}
	if (reply) {
		packet_start(success ?
		    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);
		packet_put_int(c->remote_id);
		packet_send();
	}
	xfree(rtype);
}
d1088 1
a1088 1
client_init_dispatch_20(void)
d1098 1
a1098 1
	dispatch_set(SSH2_MSG_CHANNEL_REQUEST, &client_input_channel_req);
d1102 1
a1102 1
client_init_dispatch_13(void)
d1121 1
a1121 1
client_init_dispatch_15(void)
d1128 1
a1128 1
client_init_dispatch(void)
d1136 46
@


1.26.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.53 2001/03/06 01:08:27 millert Exp $");
d282 1
a282 1
			else
d284 2
a312 1
		stdin_bytes += len;
d423 1
d489 1
d497 1
a497 1
		if (len < 0 && (errno == EAGAIN || errno == EINTR))
d505 1
d539 1
d549 1
d659 1
d676 1
d697 1
d703 2
a704 2
			if (process_escapes(&stdin_buffer, &stdout_buffer,
			    &stderr_buffer, buf, len) == -1)
d706 1
d732 1
a738 1
		stdout_bytes += len; 
a755 1
		stderr_bytes += len; 
d942 1
a952 1
		stdout_bytes += len; 
a963 1
		stderr_bytes += len; 
d998 1
d1009 1
@


1.25
log
@make x11-fwd interop w/ ssh-2.0.13
@
text
@d19 1
a19 1
RCSID("$Id: clientloop.c,v 1.24 2000/05/02 22:25:03 markus Exp $");
d982 1
a982 3
		if (packet_remaining() > 0) {
			originator_port = packet_get_int();
		} else {
d985 2
@


1.24
log
@typo, rm verbose debug
@
text
@d19 1
a19 1
RCSID("$Id: clientloop.c,v 1.23 2000/05/02 07:28:40 markus Exp $");
d982 6
a987 1
		originator_port = packet_get_int();
@


1.23
log
@typo
@
text
@d19 1
a19 1
RCSID("$Id: clientloop.c,v 1.22 2000/04/28 08:10:20 markus Exp $");
d974 1
a974 1
	log("server_input_open: ctype %s rchan %d win %d max %d",
@


1.22
log
@support for x11-fwding, client+server
@
text
@d19 1
a19 1
RCSID("$Id: clientloop.c,v 1.21 2000/04/19 07:05:48 deraadt Exp $");
d1080 1
a1080 1
	debug("session_input_channel_req: rtype %s reply %d", rtype, reply);
@


1.21
log
@pid_t
@
text
@d19 1
a19 1
RCSID("$Id: clientloop.c,v 1.20 2000/04/14 10:30:30 markus Exp $");
d957 63
d1028 1
a1039 1
	dispatch_set(SSH_MSG_CHANNEL_DATA, &channel_input_data);
@


1.20
log
@whitespace cleanup
@
text
@d19 1
a19 1
RCSID("$Id: clientloop.c,v 1.19 2000/04/14 10:09:15 markus Exp $");
d474 2
a475 1
	int len, pid;
@


1.19
log
@check payload for (illegal) extra data
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 2
a10 2
 * 
 * 
d12 1
a12 1
 * 
d14 1
a14 1
 * 
d19 1
a19 1
RCSID("$Id: clientloop.c,v 1.18 2000/04/12 06:37:02 markus Exp $");
d86 1
a86 1
void 
d100 1
a100 1
void 
d126 1
a126 1
void 
d138 1
a138 1
void 
d151 1
a151 1
void 
d163 1
a163 1
void 
d180 1
a180 1
double 
d194 1
a194 1
void 
d248 1
a248 1
void 
d279 1
a279 1
void 
d316 1
a316 1
void 
d383 1
a383 1
void 
d428 1
a428 1
void 
d471 1
a471 1
void 
d660 1
a660 1
void 
d720 1
a720 1
void 
d733 1
a733 1
int 
d956 1
a956 1
void 
d969 1
a969 1
void 
d986 1
a986 1
void 
d993 1
a993 1
void 
@


1.18
log
@less debugging output
@
text
@d19 1
a19 1
RCSID("$Id: clientloop.c,v 1.17 2000/04/04 17:29:46 markus Exp $");
d1030 1
@


1.17
log
@re-order: group ssh1 vs. ssh2
@
text
@d19 1
a19 1
RCSID("$Id: clientloop.c,v 1.13 2000/04/04 15:28:24 markus Exp $");
d1016 1
a1016 1
	log("session_input_channel_req: rtype %s reply %d", rtype, reply);
@


1.16
log
@ssh2 client implementation, interops w/ ssh.com and lsh servers.
@
text
@d19 1
a19 1
RCSID("$Id: clientloop.c,v 1.12 2000/03/31 09:40:42 markus Exp $");
d323 1
a324 1
	/* Read from the connection, unless our buffers are full. */
d326 1
d331 12
a346 10
	/*
	 * Read from stdin, unless we have seen EOF or have very much
	 * buffered data to send to the server.
	 */
	if (!compat20)
		if (!stdin_eof && packet_not_very_much_data_to_write())
			FD_SET(fileno(stdin), readset);

	FD_ZERO(writeset);

a353 10
	if (!compat20) {
		/* Select stdout if have data in buffer. */
		if (buffer_len(&stdout_buffer) > 0)
			FD_SET(fileno(stdout), writeset);

		/* Select stderr if have data in buffer. */
		if (buffer_len(&stderr_buffer) > 0)
			FD_SET(fileno(stderr), writeset);
	}

d429 1
a429 1
client_process_input(fd_set * readset)
d431 2
a432 2
	int len, pid;
	char buf[8192], *s;
d469 1
d471 5
a475 2
	if (compat20)
		return;
d781 1
a781 1
	if(!compat20)
d800 1
a800 1
		if(!compat20)
d831 5
a835 5
		/*
		 * Process input from the connection and from stdin. Buffer
		 * any data that is available.
		 */
		client_process_input(&readset);
d837 7
a843 5
		/*
		 * Process output to stdout and stderr.   Output to the
		 * connection is processed elsewhere (above).
		 */
		if(!compat20)
d845 1
@


1.15
log
@replace big switch() with function tables (prepare for ssh2)
@
text
@d15 1
d19 1
a19 1
RCSID("$Id: clientloop.c,v 1.9 2000/03/21 22:26:48 markus Exp $");
d28 1
d80 4
d282 26
a307 17
	/* Send possible window change message to the server. */
	if (received_window_change_signal) {
		struct winsize ws;

		/* Clear the window change indicator. */
		received_window_change_signal = 0;

		/* Read new window size. */
		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) >= 0) {
			/* Successful, send the packet now. */
			packet_start(SSH_CMSG_WINDOW_SIZE);
			packet_put_int(ws.ws_row);
			packet_put_int(ws.ws_col);
			packet_put_int(ws.ws_xpixel);
			packet_put_int(ws.ws_ypixel);
			packet_send();
		}
d319 2
d325 6
a330 3
	if (buffer_len(&stdout_buffer) < buffer_high &&
	    buffer_len(&stderr_buffer) < buffer_high &&
	    channel_not_very_much_buffered_data())
d332 1
d338 3
a340 2
	if (!stdin_eof && packet_not_very_much_data_to_write())
		FD_SET(fileno(stdin), readset);
d351 9
a359 7
	/* Select stdout if have data in buffer. */
	if (buffer_len(&stdout_buffer) > 0)
		FD_SET(fileno(stdout), writeset);

	/* Select stderr if have data in buffer. */
	if (buffer_len(&stderr_buffer) > 0)
		FD_SET(fileno(stderr), writeset);
d361 1
d448 1
d476 4
a735 2
void client_init_dispatch(void);

d784 2
a785 1
	client_check_initial_eof_on_stdin();
d794 5
d803 2
a804 1
		client_make_packets_from_stdin_data();
d844 2
a845 1
		client_process_output(&writeset);
d957 13
d996 3
a998 1
	if (compat13)
d1002 45
@


1.14
log
@move atomicio into it's own file.  wrap all socket write()s which were doing
write(sock, buf, len) != len, with atomicio() calls.
@
text
@d18 1
a18 1
RCSID("$Id: clientloop.c,v 1.13 1999/11/24 19:53:46 markus Exp $");
d27 5
a235 102
/*
 * Get packets from the connection input buffer, and process them as long as
 * there are packets available.
 */

void 
client_process_buffered_input_packets()
{
	int type;
	char *data;
	unsigned int data_len;
	int payload_len;

	/* Process any buffered packets from the server. */
	while (!quit_pending &&
	       (type = packet_read_poll(&payload_len)) != SSH_MSG_NONE) {
		switch (type) {

		case SSH_SMSG_STDOUT_DATA:
			data = packet_get_string(&data_len);
			packet_integrity_check(payload_len, 4 + data_len, type);
			buffer_append(&stdout_buffer, data, data_len);
			stdout_bytes += data_len;
			memset(data, 0, data_len);
			xfree(data);
			break;

		case SSH_SMSG_STDERR_DATA:
			data = packet_get_string(&data_len);
			packet_integrity_check(payload_len, 4 + data_len, type);
			buffer_append(&stderr_buffer, data, data_len);
			stdout_bytes += data_len;
			memset(data, 0, data_len);
			xfree(data);
			break;

		case SSH_SMSG_EXITSTATUS:
			packet_integrity_check(payload_len, 4, type);
			exit_status = packet_get_int();
			/* Acknowledge the exit. */
			packet_start(SSH_CMSG_EXIT_CONFIRMATION);
			packet_send();
			/*
			 * Must wait for packet to be sent since we are
			 * exiting the loop.
			 */
			packet_write_wait();
			/* Flag that we want to exit. */
			quit_pending = 1;
			break;

		case SSH_SMSG_X11_OPEN:
			x11_input_open(payload_len);
			break;

		case SSH_MSG_PORT_OPEN:
			channel_input_port_open(payload_len);
			break;

		case SSH_SMSG_AGENT_OPEN:
			packet_integrity_check(payload_len, 4, type);
			auth_input_open_request();
			break;

		case SSH_MSG_CHANNEL_OPEN_CONFIRMATION:
			packet_integrity_check(payload_len, 4 + 4, type);
			channel_input_open_confirmation();
			break;

		case SSH_MSG_CHANNEL_OPEN_FAILURE:
			packet_integrity_check(payload_len, 4, type);
			channel_input_open_failure();
			break;

		case SSH_MSG_CHANNEL_DATA:
			channel_input_data(payload_len);
			break;

		case SSH_MSG_CHANNEL_CLOSE:
			packet_integrity_check(payload_len, 4, type);
			channel_input_close();
			break;

		case SSH_MSG_CHANNEL_CLOSE_CONFIRMATION:
			packet_integrity_check(payload_len, 4, type);
			channel_input_close_confirmation();
			break;

		default:
			/*
			 * Any unknown packets received during the actual
			 * session cause the session to terminate.  This is
			 * intended to make debugging easier since no
			 * confirmations are sent.  Any compatible protocol
			 * extensions must be negotiated during the
			 * preparatory phase.
			 */
			packet_disconnect("Protocol error during session: type %d",
					  type);
		}
	}
}
d682 18
d706 2
d742 2
d877 74
@


1.13
log
@KNF, final part 3
@
text
@d18 1
a18 1
RCSID("$Id: clientloop.c,v 1.12 1999/11/24 00:26:01 deraadt Exp $");
d469 2
a470 3
		write(fileno(stdout),
		      buffer_ptr(&stdout_buffer),
		      buffer_len(&stdout_buffer));
d472 2
a473 3
		write(fileno(stderr),
		      buffer_ptr(&stderr_buffer),
		      buffer_len(&stderr_buffer));
d740 1
a740 1
			    buffer_len(&stdout_buffer));
d763 1
a763 1
			    buffer_len(&stderr_buffer));
d912 1
a912 1
			    buffer_len(&stdout_buffer));
d923 1
a923 1
			    buffer_len(&stderr_buffer));
@


1.12
log
@much more KNF
@
text
@d18 1
a18 1
RCSID("$Id: clientloop.c,v 1.11 1999/11/23 22:25:53 markus Exp $");
d30 5
a34 3
/* Name of the host we are connecting to.  This is the name given on the
   command line, or the HostName specified for the user-supplied name
   in a configuration file. */
d37 6
a42 4
/* Flag to indicate that we have received a window change signal which has
   not yet been processed.  This will cause a message indicating the new
   window size to be sent to the server a little later.  This is volatile
   because this is updated in a signal handler. */
d48 4
a51 2
/* Flag indicating whether we are in raw mode.  This is used by enter_raw_mode
   and leave_raw_mode. */
d73 1
a73 2
/* Returns the user\'s terminal to normal mode if it had been put in raw
   mode. */
d135 4
a138 2
/* Signal handler for the window change signal (SIGWINCH).  This just
   sets a flag indicating that the window has changed. */
d147 4
a150 2
/* Signal handler for signals that cause the program to terminate.  These
   signals must be trapped to restore terminal modes. */
d164 4
a167 2
/* Returns current time in seconds from Jan 1, 1970 with the maximum available
   resolution. */
d177 5
a181 3
/* This is called when the interactive is entered.  This checks if there
   is an EOF coming on stdin.  We must check this explicitly, as select()
   does not appear to wake up when redirecting from /dev/null. */
d189 8
a196 7
	/* If standard input is to be "redirected from /dev/null", we
	   simply mark that we have seen an EOF and send an EOF message to
	   the server. Otherwise, we try to read a single character; it
	   appears that for some files, such /dev/null, select() never
	   wakes up for read for this descriptor, which means that we
	   never get EOF.  This way we will get the EOF if stdin comes
	   from /dev/null or similar. */
a203 1
		/* Enter non-blocking mode for stdin. */
d209 1
a209 2
			/* EOF.  Record that we have seen it and send EOF
			   to server. */
d215 5
a219 3
			/* Got data.  We must store the data in the
			   buffer, and also process it as an escape
			   character if appropriate. */
a226 1
		/* Leave non-blocking mode. */
d231 4
a234 2
/* Get packets from the connection input buffer, and process them as long
   as there are packets available. */
d273 4
a276 2
			/* Must wait for packet to be sent since we are
			   exiting the loop. */
d320 8
a327 6
			/* Any unknown packets received during the actual
			   session cause the session to terminate.  This
			   is intended to make debugging easier since no
			   confirmations are sent.  Any compatible
			   protocol extensions must be negotiated during
			   the preparatory phase. */
d334 4
a337 2
/* Make packets from buffered stdin data, and buffer them for sending to
   the connection. */
d363 6
a368 4
/* Checks if the client window has changed, and sends a packet about it to
   the server if so.  The actual change is detected elsewhere (by a software
   interrupt on Unix); this just checks the flag and sends a message if
   appropriate. */
d393 4
a396 2
/* Waits until the client can do something (some data becomes available on
   one of the file descriptors). */
d410 4
a413 2
	/* Read from stdin, unless we have seen EOF or have very much
	   buffered data to send to the server. */
d438 8
a445 7
	/* Wait for something to happen.  This will suspend the process
	   until some selected descriptor can be read, written, or has
	   some other event pending. 
	   Note: if you want to implement SSH_MSG_IGNORE messages to fool
	   traffic analysis, this might be the place to do it:
	   just have a random timeout for the select, and send a random
	   SSH_MSG_IGNORE packet when the timeout expires. */
a476 1
	/* Leave raw mode. */
d479 4
a482 2
	/* Free (and clear) the buffer to reduce the amount of data that
	   gets written to swap. */
a505 1
	/* Re-enter raw mode. */
d515 4
a518 2
	/* Read input from the server, and add any such data to the buffer
	   of the packet subsystem. */
d531 4
a534 3
		/* There is a kernel bug on Solaris that causes select to
		   sometimes wake up even though there is no data
		   available. */
d554 5
a558 3
			/* Received EOF or error.  They are treated
			   similarly, except that an error message is
			   printed if it was an error condition. */
d566 7
a572 5
			/* Send an EOF message to the server unless there
			   is data in the buffer.  If there is data in the
			   buffer, no message will be sent now.  Code
			   elsewhere will send the EOF when the buffer
			   becomes empty if stdin_eof is set. */
d578 4
a581 2
			/* Normal successful read, and no escape
			   character.  Just append the data to buffer. */
d585 4
a588 3
			/* Normal, successful read.  But we have an escape
			   character and have to process the characters
			   one by one. */
a594 2
				/* Check if we have a pending escape
				   character. */
d623 4
a626 2
						/* Detach the program (continue to serve connections,
						   but put in background and no more new connections). */
d628 5
a632 3
							/* Sending SSH_CMSG_EOF alone does not always appear
							   to be enough.  So we try to send an EOF character
							   first. */
d689 4
a692 2
							/* Escape character followed by non-special character.
							   Append both to the input buffer. */
d699 5
a703 3
						/* Note that escape character typed twice
						   falls through here; the latter gets processed
						   as a normal character below. */
d707 4
a710 2
					/* The previous character was not an escape char. Check if this
					   is an escape. */
d718 4
a721 2
				/* Normal character.  Record whether it was a newline, and append it to the
				   buffer. */
d747 4
a750 2
				/* An error or EOF was encountered.  Put
				   an error message to stderr buffer. */
d770 1
a770 2
				/* EOF or error, but can't even print
				   error message. */
d780 6
a785 5
/* Implements the interactive session with the server.  This is called
   after the user has been authenticated, and a command has been
   started on the remote host.  If escape_char != -1, it is the character
   used as an escape character for terminating or suspending the
   session. */
a828 1
	/* Enter raw mode if have a pseudo terminal. */
d839 1
a839 1
		/* Precess buffered packets sent by the server. */
d842 4
a845 2
		/* Make packets of buffered stdin data, and buffer them
		   for sending to the server. */
d848 4
a851 2
		/* Make packets from buffered channel data, and buffer
		   them for sending to the server. */
d855 4
a858 2
		/* Check if the window size has changed, and buffer a
		   message about it to the server if so. */
d864 4
a867 2
		/* Wait until we have something to do (something becomes
		   available on one of the descriptors). */
d876 4
a879 2
		/* Process input from the connection and from stdin.
		   Buffer any data that is available. */
d882 4
a885 2
		/* Process output to stdout and stderr.   Output to the
		   connection is processed elsewhere (above). */
d888 1
a888 2
		/* Send as much buffered packet data as possible to the
		   sender. */
d902 4
a905 2
	/* In interactive mode (with pseudo tty) display a message
	   indicating that the connection has been closed. */
a932 1
	/* Leave raw mode. */
@


1.11
log
@KNF part 1
@
text
@d2 14
a15 14

clientloop.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved


Created: Sat Sep 23 12:23:57 1995 ylo

The main loop for the interactive session (client side).

*/
d18 1
a18 1
RCSID("$Id: clientloop.c,v 1.10 1999/11/19 19:58:18 markus Exp $");
@


1.10
log
@SSH_CMSG_MAX_PACKET_SIZE, some clients use this, some need this, niels@@
[hope this time my ISP stays alive during commit]
@
text
@d18 1
a18 1
RCSID("$Id: clientloop.c,v 1.9 1999/11/11 23:36:53 markus Exp $");
d52 11
a62 11
static int escape_pending;  /* Last character was the escape character */
static int last_was_cr; /* Last character was a newline. */
static int exit_status; /* Used to store the exit status of the command. */
static int stdin_eof; /* EOF has been encountered on standard error. */
static Buffer stdin_buffer;  /* Buffer for stdin data. */
static Buffer stdout_buffer; /* Buffer for stdout data. */
static Buffer stderr_buffer; /* Buffer for stderr data. */
static unsigned int buffer_high; /* Soft max buffer size. */
static int max_fd; /* Maximum file descriptor number in select(). */
static int connection_in; /* Connection to server (input). */
static int connection_out; /* Connection to server (output). */
d64 2
a65 2
static int quit_pending; /* Set to non-zero to quit the client loop. */
static int escape_char; /* Escape character. */
d67 1
a67 1
/* Returns the user\'s terminal to normal mode if it had been put in raw 
d70 2
a71 1
void leave_raw_mode()
d73 5
a77 5
  if (!in_raw_mode)
    return;
  in_raw_mode = 0;
  if (tcsetattr(fileno(stdin), TCSADRAIN, &saved_tio) < 0)
    perror("tcsetattr");
d79 1
a79 1
  fatal_remove_cleanup((void (*)(void *))leave_raw_mode, NULL);
d84 2
a85 1
void enter_raw_mode()
d87 1
a87 1
  struct termios tio;
d89 6
a94 6
  if (tcgetattr(fileno(stdin), &tio) < 0)
    perror("tcgetattr");
  saved_tio = tio;
  tio.c_iflag |= IGNPAR;
  tio.c_iflag &= ~(ISTRIP|INLCR|IGNCR|ICRNL|IXON|IXANY|IXOFF);
  tio.c_lflag &= ~(ISIG|ICANON|ECHO|ECHOE|ECHOK|ECHONL);
d96 8
a103 8
  tio.c_lflag &= ~IEXTEN;
#endif /* IEXTEN */
  tio.c_oflag &= ~OPOST;
  tio.c_cc[VMIN] = 1;
  tio.c_cc[VTIME] = 0;
  if (tcsetattr(fileno(stdin), TCSADRAIN, &tio) < 0)
    perror("tcsetattr");
  in_raw_mode = 1;
d105 2
a106 4
  fatal_add_cleanup((void (*)(void *))leave_raw_mode, NULL);
}  

/* Puts stdin terminal in non-blocking mode. */
d110 2
a111 1
void leave_non_blocking()
d113 5
a117 6
  if (in_non_blocking_mode)
    {
      (void)fcntl(fileno(stdin), F_SETFL, 0);
      in_non_blocking_mode = 0;
      fatal_remove_cleanup((void (*)(void *))leave_non_blocking, NULL);
    }
d120 4
a123 1
void enter_non_blocking()
d125 3
a127 3
  in_non_blocking_mode = 1;
  (void)fcntl(fileno(stdin), F_SETFL, O_NONBLOCK);
  fatal_add_cleanup((void (*)(void *))leave_non_blocking, NULL);
d133 2
a134 1
void window_change_handler(int sig)
d136 2
a137 2
  received_window_change_signal = 1;
  signal(SIGWINCH, window_change_handler);
d143 2
a144 1
void signal_handler(int sig)
d146 7
a152 7
  if (in_raw_mode)
    leave_raw_mode();
  if (in_non_blocking_mode)
    leave_non_blocking();
  channel_stop_listening();
  packet_close();
  fatal("Killed by signal %d.", sig);
d158 2
a159 1
double get_current_time()
d161 3
a163 3
  struct timeval tv;
  gettimeofday(&tv, NULL);
  return (double)tv.tv_sec + (double)tv.tv_usec / 1000000.0;
d170 2
a171 1
void client_check_initial_eof_on_stdin()
d173 2
a174 2
  int len;
  char buf[1];
d176 40
a215 46
  /* If standard input is to be "redirected from /dev/null", we simply
     mark that we have seen an EOF and send an EOF message to the server.
     Otherwise, we try to read a single character; it appears that for some
     files, such /dev/null, select() never wakes up for read for this
     descriptor, which means that we never get EOF.  This way we will get
     the EOF if stdin comes from /dev/null or similar. */
  if (stdin_null_flag)
    {
      /* Fake EOF on stdin. */
      debug("Sending eof.");
      stdin_eof = 1;
      packet_start(SSH_CMSG_EOF);
      packet_send();
    }
  else
    {
      /* Enter non-blocking mode for stdin. */
      enter_non_blocking();

      /* Check for immediate EOF on stdin. */
      len = read(fileno(stdin), buf, 1);
      if (len == 0)
	{
	  /* EOF.  Record that we have seen it and send EOF to server. */
	  debug("Sending eof.");
	  stdin_eof = 1;
	  packet_start(SSH_CMSG_EOF);
	  packet_send();
	}
      else
	if (len > 0)
	  {
	    /* Got data.  We must store the data in the buffer, and also
	       process it as an escape character if appropriate. */
	    if ((unsigned char)buf[0] == escape_char)
	      escape_pending = 1;
	    else
	      {
		buffer_append(&stdin_buffer, buf, 1);
		stdin_bytes += 1;
	      }
	  }
      
      /* Leave non-blocking mode. */
      leave_non_blocking();
    }
d221 2
a222 1
void client_process_buffered_input_packets()
d224 88
a311 87
  int type;
  char *data;
  unsigned int data_len;
  int payload_len;

  /* Process any buffered packets from the server. */
  while (!quit_pending && (type = packet_read_poll(&payload_len)) != SSH_MSG_NONE)
    {
      switch (type)
	{
	  
	case SSH_SMSG_STDOUT_DATA:
	  data = packet_get_string(&data_len);
	  packet_integrity_check(payload_len, 4 + data_len, type);
	  buffer_append(&stdout_buffer, data, data_len);
	  stdout_bytes += data_len;
	  memset(data, 0, data_len);
	  xfree(data);
	  break;

	case SSH_SMSG_STDERR_DATA:
	  data = packet_get_string(&data_len);
	  packet_integrity_check(payload_len, 4 + data_len, type);
	  buffer_append(&stderr_buffer, data, data_len);
	  stdout_bytes += data_len;
	  memset(data, 0, data_len);
	  xfree(data);
	  break;

	case SSH_SMSG_EXITSTATUS:
	  packet_integrity_check(payload_len, 4, type);
	  exit_status = packet_get_int();
	  /* Acknowledge the exit. */
	  packet_start(SSH_CMSG_EXIT_CONFIRMATION);
	  packet_send();
	  /* Must wait for packet to be sent since we are exiting the
	     loop. */
	  packet_write_wait();
	  /* Flag that we want to exit. */
	  quit_pending = 1;
	  break;

	case SSH_SMSG_X11_OPEN:
	  x11_input_open(payload_len);
	  break;

	case SSH_MSG_PORT_OPEN:
	  channel_input_port_open(payload_len);
	  break;

	case SSH_SMSG_AGENT_OPEN:
	  packet_integrity_check(payload_len, 4, type);
	  auth_input_open_request();
	  break;

	case SSH_MSG_CHANNEL_OPEN_CONFIRMATION:
	  packet_integrity_check(payload_len, 4 + 4, type);
	  channel_input_open_confirmation();
	  break;

	case SSH_MSG_CHANNEL_OPEN_FAILURE:
	  packet_integrity_check(payload_len, 4, type);
	  channel_input_open_failure();
	  break;

	case SSH_MSG_CHANNEL_DATA:
	  channel_input_data(payload_len);
	  break;

	case SSH_MSG_CHANNEL_CLOSE:
	  packet_integrity_check(payload_len, 4, type);
	  channel_input_close();
	  break;

	case SSH_MSG_CHANNEL_CLOSE_CONFIRMATION:
	  packet_integrity_check(payload_len, 4, type);
	  channel_input_close_confirmation();
	  break;

	default:
	  /* Any unknown packets received during the actual session
	     cause the session to terminate.  This is intended to make
	     debugging easier since no confirmations are sent.  Any
	     compatible protocol extensions must be negotiated during
	     the preparatory phase. */
	  packet_disconnect("Protocol error during session: type %d",
			    type);
a312 1
    }
d318 2
a319 1
void client_make_packets_from_stdin_data()
d321 1
a321 1
  unsigned int len;
d323 16
a338 16
  /* Send buffered stdin data to the server. */
  while (buffer_len(&stdin_buffer) > 0 && 
	 packet_not_very_much_data_to_write())
    {
      len = buffer_len(&stdin_buffer);
      if (len > packet_get_maxsize())
	len = packet_get_maxsize();  /* Keep the packets at reasonable size. */
      packet_start(SSH_CMSG_STDIN_DATA);
      packet_put_string(buffer_ptr(&stdin_buffer), len);
      packet_send();
      buffer_consume(&stdin_buffer, len);
      /* If we have a pending EOF, send it now. */
      if (stdin_eof && buffer_len(&stdin_buffer) == 0)
	{
	  packet_start(SSH_CMSG_EOF);
	  packet_send();
a339 1
    }
d347 2
a348 1
void client_check_window_change()
d350 17
a366 18
  /* Send possible window change message to the server. */
  if (received_window_change_signal)
    {
      struct winsize ws;

      /* Clear the window change indicator. */
      received_window_change_signal = 0;

      /* Read new window size. */
      if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) >= 0)
	{
	  /* Successful, send the packet now. */
	  packet_start(SSH_CMSG_WINDOW_SIZE);
	  packet_put_int(ws.ws_row);
	  packet_put_int(ws.ws_col);
	  packet_put_int(ws.ws_xpixel);
	  packet_put_int(ws.ws_ypixel);
	  packet_send();
a367 1
    }
d373 63
a435 1
void client_wait_until_can_do_something(fd_set *readset, fd_set *writeset)
d437 59
a495 204
  /* Initialize select masks. */
  FD_ZERO(readset);
  
  /* Read from the connection, unless our buffers are full. */
  if (buffer_len(&stdout_buffer) < buffer_high &&
      buffer_len(&stderr_buffer) < buffer_high &&
      channel_not_very_much_buffered_data())
    FD_SET(connection_in, readset);

  /* Read from stdin, unless we have seen EOF or have very much buffered
     data to send to the server. */
  if (!stdin_eof && packet_not_very_much_data_to_write())
    FD_SET(fileno(stdin), readset);
  
  FD_ZERO(writeset);
  
  /* Add any selections by the channel mechanism. */
  channel_prepare_select(readset, writeset);
  
  /* Select server connection if have data to write to the server. */
  if (packet_have_data_to_write())
    FD_SET(connection_out, writeset);

  /* Select stdout if have data in buffer. */
  if (buffer_len(&stdout_buffer) > 0)
    FD_SET(fileno(stdout), writeset);

  /* Select stderr if have data in buffer. */
  if (buffer_len(&stderr_buffer) > 0)
    FD_SET(fileno(stderr), writeset);

  /* Update maximum file descriptor number, if appropriate. */
  if (channel_max_fd() > max_fd)
    max_fd = channel_max_fd();

  /* Wait for something to happen.  This will suspend the process until
     some selected descriptor can be read, written, or has some other
     event pending.  Note: if you want to implement SSH_MSG_IGNORE
     messages to fool traffic analysis, this might be the place to do
     it: just have a random timeout for the select, and send a random
     SSH_MSG_IGNORE packet when the timeout expires. */
  if (select(max_fd + 1, readset, writeset, NULL, NULL) < 0)
    {
      char buf[100];
      /* Some systems fail to clear these automatically. */
      FD_ZERO(readset);
      FD_ZERO(writeset);
      if (errno == EINTR)
	return;
      /* Note: we might still have data in the buffers. */
      snprintf(buf, sizeof buf, "select: %s\r\n", strerror(errno));
      buffer_append(&stderr_buffer, buf, strlen(buf));
      stderr_bytes += strlen(buf);
      quit_pending = 1;
    }
}

void client_suspend_self()
{
  struct winsize oldws, newws;

  /* Flush stdout and stderr buffers. */
  if (buffer_len(&stdout_buffer) > 0)
    write(fileno(stdout), 
	  buffer_ptr(&stdout_buffer), 
	  buffer_len(&stdout_buffer));
  if (buffer_len(&stderr_buffer) > 0)
    write(fileno(stderr), 
	  buffer_ptr(&stderr_buffer), 
	  buffer_len(&stderr_buffer));

  /* Leave raw mode. */
  leave_raw_mode();

  /* Free (and clear) the buffer to reduce the
     amount of data that gets written to swap. */
  buffer_free(&stdin_buffer);
  buffer_free(&stdout_buffer);
  buffer_free(&stderr_buffer);

  /* Save old window size. */
  ioctl(fileno(stdin), TIOCGWINSZ, &oldws);

  /* Send the suspend signal to the program
     itself. */
  kill(getpid(), SIGTSTP);

  /* Check if the window size has changed. */
  if (ioctl(fileno(stdin), TIOCGWINSZ, &newws) >= 0 &&
      (oldws.ws_row != newws.ws_row || oldws.ws_col != newws.ws_col ||
       oldws.ws_xpixel != newws.ws_xpixel || 
       oldws.ws_ypixel != newws.ws_ypixel))
    received_window_change_signal = 1;

  /* OK, we have been continued by the user. 
     Reinitialize buffers. */
  buffer_init(&stdin_buffer);
  buffer_init(&stdout_buffer);
  buffer_init(&stderr_buffer);

  /* Re-enter raw mode. */
  enter_raw_mode();
}

void client_process_input(fd_set *readset)
{
  int len, pid;
  char buf[8192], *s;

  /* Read input from the server, and add any such data to the buffer of the
     packet subsystem. */
  if (FD_ISSET(connection_in, readset))
    {
      /* Read as much as possible. */
      len = read(connection_in, buf, sizeof(buf));
      if (len == 0)
	{ 
	  /* Received EOF.  The remote host has closed the connection. */
	  snprintf(buf, sizeof buf, "Connection to %.300s closed by remote host.\r\n",
		  host);
	  buffer_append(&stderr_buffer, buf, strlen(buf));
	  stderr_bytes += strlen(buf);
	  quit_pending = 1;
	  return;
	}

      /* There is a kernel bug on Solaris that causes select to sometimes
	 wake up even though there is no data available. */
      if (len < 0 && errno == EAGAIN)
	len = 0;

      if (len < 0)
	{
	  /* An error has encountered.  Perhaps there is a network
	     problem. */
	  snprintf(buf, sizeof buf, "Read from remote host %.300s: %.100s\r\n", 
		  host, strerror(errno));
	  buffer_append(&stderr_buffer, buf, strlen(buf));
	  stderr_bytes += strlen(buf);
	  quit_pending = 1;
	  return;
	}
      packet_process_incoming(buf, len);
    }

  /* Read input from stdin. */
  if (FD_ISSET(fileno(stdin), readset))
    {
      /* Read as much as possible. */
      len = read(fileno(stdin), buf, sizeof(buf));
      if (len <= 0)
	{
	  /* Received EOF or error.  They are treated similarly,
	     except that an error message is printed if it was
	     an error condition. */
	  if (len < 0)
	    {
	      snprintf(buf, sizeof buf, "read: %.100s\r\n", strerror(errno));
	      buffer_append(&stderr_buffer, buf, strlen(buf));
	      stderr_bytes += strlen(buf);
	    }
	  /* Mark that we have seen EOF. */
	  stdin_eof = 1;
	  /* Send an EOF message to the server unless there is data
	     in the buffer.  If there is data in the buffer, no message
	     will be sent now.  Code elsewhere will send the EOF
	     when the buffer becomes empty if stdin_eof is set. */
	  if (buffer_len(&stdin_buffer) == 0)
	    {
	      packet_start(SSH_CMSG_EOF);
	      packet_send();
	    }
	}
      else
	if (escape_char == -1)
	  {
	    /* Normal successful read, and no escape character.  Just 
	       append the data to buffer. */
	    buffer_append(&stdin_buffer, buf, len);
	    stdin_bytes += len;
	  }
	else
	  {
	    /* Normal, successful read.  But we have an escape character
	       and have to process the characters one by one. */
	    unsigned int i;
	    for (i = 0; i < len; i++)
	      {
		unsigned char ch;
		/* Get one character at a time. */
		ch = buf[i];
		
		/* Check if we have a pending escape character. */
		if (escape_pending)
		  {
		    /* We have previously seen an escape character. */
		    /* Clear the flag now. */
		    escape_pending = 0;
		    /* Process the escaped character. */
		    switch (ch)
		      {
		      case '.':
			/* Terminate the connection. */
			snprintf(buf, sizeof buf, "%c.\r\n", escape_char);
d500 39
a538 30

		      case 'Z' - 64:
			  /* Suspend the program. */
			  /* Print a message to that effect to the user. */
			  snprintf(buf, sizeof buf, "%c^Z\r\n", escape_char);
			  buffer_append(&stderr_buffer, buf, strlen(buf));
			  stderr_bytes += strlen(buf);

			  /* Restore terminal modes and suspend. */
			  client_suspend_self();

			  /* We have been continued. */
			  continue;
			
		      case '&':
			/* Detach the program (continue to serve connections,
			   but put in background and no more new 
			   connections). */
			if (!stdin_eof)
			  {
			    /* Sending SSH_CMSG_EOF alone does not always
			       appear to be enough.  So we try to send an
			       EOF character first. */
			    packet_start(SSH_CMSG_STDIN_DATA);
			    packet_put_string("\004", 1);
			    packet_send();
			    /* Close stdin. */
			    stdin_eof = 1;
			    if (buffer_len(&stdin_buffer) == 0)
			      {
d541 86
a626 28
			      }
			  }
			/* Restore tty modes. */
			leave_raw_mode();

			/* Stop listening for new connections. */
			channel_stop_listening();

			printf("%c& [backgrounded]\n", escape_char);
			
			/* Fork into background. */
			pid = fork();
			if (pid < 0)
			  {
			    error("fork: %.100s", strerror(errno));
			    continue;
			  }
			if (pid != 0)
			  { /* This is the parent. */
			    /* The parent just exits. */
			    exit(0);
			  }

			/* The child continues serving connections. */
			continue;

		      case '?':
			snprintf(buf, sizeof buf, "%c?\r\n\
d635 54
a688 3
				escape_char);
			buffer_append(&stderr_buffer, buf, strlen(buf));
			continue;
d690 39
a728 100
		      case '#':
			snprintf(buf, sizeof buf, "%c#\r\n", escape_char);
			buffer_append(&stderr_buffer, buf, strlen(buf));
			s = channel_open_message();
			buffer_append(&stderr_buffer, s, strlen(s));
			xfree(s);
			continue;

		      default:
			if (ch != escape_char)
			  {
			    /* Escape character followed by non-special
			       character.  Append both to the input
			       buffer. */
			    buf[0] = escape_char;
			    buf[1] = ch;
			    buffer_append(&stdin_buffer, buf, 2);
			    stdin_bytes += 2;
			    continue;
			  }
			/* Note that escape character typed twice falls through
			   here; the latter gets processed as a normal
			   character below. */
			break;
		      }
		  }
		else
		  {
		    /* The previous character was not an escape char. 
		       Check if this is an escape. */
		    if (last_was_cr && ch == escape_char)
		      {
			/* It is. Set the flag and continue to next
			   character. */
			escape_pending = 1;
			continue;
		      }
		  }

		/* Normal character.  Record whether it was a newline,
		   and append it to the buffer. */
		last_was_cr = (ch == '\r' || ch == '\n');
		buf[0] = ch;
		buffer_append(&stdin_buffer, buf, 1);
		stdin_bytes += 1;
		continue;
	      }
	  }
    }
}

void client_process_output(fd_set *writeset)
{
  int len;
  char buf[100];

  /* Write buffered output to stdout. */
  if (FD_ISSET(fileno(stdout), writeset))
    {
      /* Write as much data as possible. */
      len = write(fileno(stdout), buffer_ptr(&stdout_buffer),
		  buffer_len(&stdout_buffer));
      if (len <= 0)
	{
	  if (errno == EAGAIN)
	    len = 0;
	  else
	    {
	      /* An error or EOF was encountered.  Put an error message
		 to stderr buffer. */
	      snprintf(buf, sizeof buf, "write stdout: %.50s\r\n", strerror(errno));
	      buffer_append(&stderr_buffer, buf, strlen(buf));
	      stderr_bytes += strlen(buf);
	      quit_pending = 1;
	      return;
	    }
	}
      /* Consume printed data from the buffer. */
      buffer_consume(&stdout_buffer, len);
    }

  /* Write buffered output to stderr. */
  if (FD_ISSET(fileno(stderr), writeset))
    {
      /* Write as much data as possible. */
      len = write(fileno(stderr), buffer_ptr(&stderr_buffer),
		  buffer_len(&stderr_buffer));
      if (len <= 0) {
	if (errno == EAGAIN)
	  len = 0;
	else
	  {
	    /* EOF or error, but can't even print error message. */
	    quit_pending = 1;
	    return;
	  }
      }
      /* Consume printed characters from the buffer. */
      buffer_consume(&stderr_buffer, len);
    }
d737 2
a738 1
int client_loop(int have_pty, int escape_char_arg)
d740 153
a892 159
  extern Options options;
  double start_time, total_time;
  int len;
  char buf[100];

  debug("Entering interactive session.");

  start_time = get_current_time();

  /* Initialize variables. */
  escape_pending = 0;
  last_was_cr = 1;
  exit_status = -1;
  stdin_eof = 0;
  buffer_high = 64 * 1024;
  connection_in = packet_get_connection_in();
  connection_out = packet_get_connection_out();
  max_fd = connection_in;
  if (connection_out > max_fd)
    max_fd = connection_out;
  stdin_bytes = 0;
  stdout_bytes = 0;
  stderr_bytes = 0;
  quit_pending = 0;
  escape_char = escape_char_arg;

  /* Initialize buffers. */
  buffer_init(&stdin_buffer);
  buffer_init(&stdout_buffer);
  buffer_init(&stderr_buffer);

  /* Set signal handlers to restore non-blocking mode.  */
  signal(SIGINT, signal_handler);
  signal(SIGQUIT, signal_handler);
  signal(SIGTERM, signal_handler);
  signal(SIGPIPE, SIG_IGN);
  if (have_pty)
    signal(SIGWINCH, window_change_handler);

  /* Enter raw mode if have a pseudo terminal. */
  if (have_pty)
    enter_raw_mode();

  /* Check if we should immediately send of on stdin. */
  client_check_initial_eof_on_stdin();

  /* Main loop of the client for the interactive session mode. */
  while (!quit_pending)
    {
      fd_set readset, writeset;

      /* Precess buffered packets sent by the server. */
      client_process_buffered_input_packets();

      /* Make packets of buffered stdin data, and buffer them for sending
	 to the server. */
      client_make_packets_from_stdin_data();

      /* Make packets from buffered channel data, and buffer them for sending
	 to the server. */
      if (packet_not_very_much_data_to_write())
	channel_output_poll();

      /* Check if the window size has changed, and buffer a message about
	 it to the server if so. */
      client_check_window_change();

      if (quit_pending)
	break;

      /* Wait until we have something to do (something becomes available
	 on one of the descriptors). */
      client_wait_until_can_do_something(&readset, &writeset);

      if (quit_pending)
	break;

      /* Do channel operations. */
      channel_after_select(&readset, &writeset);

      /* Process input from the connection and from stdin.  Buffer any data
         that is available. */
      client_process_input(&readset);

      /* Process output to stdout and stderr.   Output to the connection
         is processed elsewhere (above). */
      client_process_output(&writeset);

      /* Send as much buffered packet data as possible to the sender. */
      if (FD_ISSET(connection_out, &writeset))
	packet_write_poll();
    }

  /* Terminate the session. */

  /* Stop watching for window change. */
  if (have_pty)
    signal(SIGWINCH, SIG_DFL);

  /* Stop listening for connections. */
  channel_stop_listening();

  /* In interactive mode (with pseudo tty) display a message indicating that
     the connection has been closed. */
  if (have_pty && options.log_level != SYSLOG_LEVEL_QUIET)
    {
      snprintf(buf, sizeof buf, "Connection to %.64s closed.\r\n", host);
      buffer_append(&stderr_buffer, buf, strlen(buf));
      stderr_bytes += strlen(buf);
    }

  /* Output any buffered data for stdout. */
  while (buffer_len(&stdout_buffer) > 0)
    {
      len = write(fileno(stdout), buffer_ptr(&stdout_buffer), 
		  buffer_len(&stdout_buffer));
      if (len <= 0)
	{
	  error("Write failed flushing stdout buffer.");
	  break;
	}
      buffer_consume(&stdout_buffer, len);
    }

  /* Output any buffered data for stderr. */
  while (buffer_len(&stderr_buffer) > 0)
    {
      len = write(fileno(stderr), buffer_ptr(&stderr_buffer), 
		  buffer_len(&stderr_buffer));
      if (len <= 0)
	{
	  error("Write failed flushing stderr buffer.");
	  break;
	}
      buffer_consume(&stderr_buffer, len);
    }

  /* Leave raw mode. */
  if (have_pty)
    leave_raw_mode();

  /* Clear and free any buffers. */
  memset(buf, 0, sizeof(buf));
  buffer_free(&stdin_buffer);
  buffer_free(&stdout_buffer);
  buffer_free(&stderr_buffer);

  /* Report bytes transferred, and transfer rates. */
  total_time = get_current_time() - start_time;
  debug("Transferred: stdin %lu, stdout %lu, stderr %lu bytes in %.1f seconds",
	stdin_bytes, stdout_bytes, stderr_bytes, total_time);
  if (total_time > 0)
    debug("Bytes per second: stdin %.1f, stdout %.1f, stderr %.1f",
	  stdin_bytes / total_time, stdout_bytes / total_time,
	  stderr_bytes / total_time);

  /* Return the exit status of the program. */
  debug("Exit status %d", exit_status);
  return exit_status;
@


1.9
log
@make all access to options via 'extern Options options'
and 'extern ServerOptions options' respectively;
options are no longer passed as arguments:
 * make options handling more consistent
 * remove #include "readconf.h" from ssh.h
 * readconf.h is only included if necessary
@
text
@d18 1
a18 1
RCSID("$Id: clientloop.c,v 1.8 1999/11/10 23:36:43 markus Exp $");
d325 2
a326 2
      if (len > 32768)
	len = 32768;  /* Keep the packets at reasonable size. */
@


1.8
log
@add LogLevel {QUIET, FATAL, ERROR, INFO, CHAT, DEBUG} to ssh/sshd,
obsoletes QuietMode and FascistLogging in sshd.
@
text
@d18 1
a18 1
RCSID("$Id: clientloop.c,v 1.7 1999/10/16 20:57:52 deraadt Exp $");
a26 3
/* Flag indicating whether quiet mode is on. */
extern Options options;

d764 1
@


1.7
log
@snprintf
@
text
@d18 1
a18 1
RCSID("$Id: clientloop.c,v 1.6 1999/09/30 08:34:24 deraadt Exp $");
d25 1
d28 1
a28 1
extern int quiet_flag;
d870 1
a870 1
  if (have_pty && !quiet_flag)
@


1.6
log
@even smaller
@
text
@d18 1
a18 1
RCSID("$Id: clientloop.c,v 1.5 1999/09/30 05:53:04 deraadt Exp $");
d426 1
a426 1
      sprintf(buf, "select: %.100s\r\n", strerror(errno));
d494 1
a494 1
	  sprintf(buf, "Connection to %.300s closed by remote host.\r\n",
d511 1
a511 1
	  sprintf(buf, "Read from remote host %.300s: %.100s\r\n", 
d533 1
a533 1
	      sprintf(buf, "read: %.100s\r\n", strerror(errno));
d579 1
a579 1
			sprintf(buf, "%c.\r\n", escape_char);
d588 1
a588 1
			  sprintf(buf, "%c^Z\r\n", escape_char);
d643 1
a643 1
			sprintf(buf, "%c?\r\n\
d657 1
a657 1
			sprintf(buf, "%c#\r\n", escape_char);
d726 1
a726 1
	      sprintf(buf, "write stdout: %.50s\r\n", strerror(errno));
d871 1
a871 1
      sprintf(buf, "Connection to %.64s closed.\r\n", host);
@


1.5
log
@"ssh is a very large program" -- anonymous
@
text
@d18 1
a18 1
RCSID("$Id: clientloop.c,v 1.4 1999/09/30 05:11:29 deraadt Exp $");
d132 1
a132 1
RETSIGTYPE window_change_handler(int sig)
d141 1
a141 1
RETSIGTYPE signal_handler(int sig)
@


1.4
log
@do not bother with dinosaur pacification
@
text
@d18 1
a18 1
RCSID("$Id: clientloop.c,v 1.3 1999/09/30 05:03:04 deraadt Exp $");
a36 1
#ifdef SIGWINCH
a41 1
#endif /* SIGWINCH */
a128 1
#ifdef SIGWINCH
a136 1
#endif /* SIGWINCH */
a348 1
#ifdef SIGWINCH
a368 1
#endif /* SIGWINCH */
a434 1
#ifdef SIGWINCH
a435 1
#endif /* SIGWINCH */
a455 1
#ifdef SIGWINCH
a457 1
#endif /* SIGWINCH */
a462 1
#ifdef SIGWINCH
a468 1
#endif /* SIGWINCH */
a800 1
#ifdef SIGWINCH
a802 1
#endif /* SIGWINCH */
a859 1
#ifdef SIGWINCH
a862 1
#endif /* SIGWINCH */
@


1.3
log
@cull more ancient garbage from pre-POSIX days
@
text
@d18 1
a18 1
RCSID("$Id: clientloop.c,v 1.2 1999/09/28 04:45:36 provos Exp $");
a126 1
#if defined(O_NONBLOCK) && !defined(O_NONBLOCK_BROKEN)
a127 3
#else /* O_NONBLOCK && !O_NONBLOCK_BROKEN */
  (void)fcntl(fileno(stdin), F_SETFL, O_NDELAY);
#endif /* O_NONBLOCK && !O_NONBLOCK_BROKEN */
a160 1
#ifdef HAVE_GETTIMEOFDAY
a163 3
#else /* HAVE_GETTIMEOFDAY */
  return (double)time(NULL);
#endif /* HAVE_GETTIMEOFDAY */
@


1.2
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d18 1
a18 1
RCSID("$Id: clientloop.c,v 1.4 1999/05/04 11:58:37 bg Exp $");
a45 1
#ifdef USING_TERMIOS
a46 4
#endif
#ifdef USING_SGTTY
static struct sgttyb saved_tio;
#endif
a78 1
#ifdef USING_TERMIOS
a80 5
#endif /* USING_TERMIOS */
#ifdef USING_SGTTY
  if (ioctl(fileno(stdin), TIOCSETP, &saved_tio) < 0)
    perror("ioctl(stdin, TIOCSETP, ...)");
#endif /* USING_SGTTY */
a88 1
#ifdef USING_TERMIOS
a105 13
#endif /* USING_TERMIOS */
#ifdef USING_SGTTY
  struct sgttyb tio;

  if (ioctl(fileno(stdin), TIOCGETP, &tio) < 0)
    perror("ioctl(stdin, TIOCGETP, ...)");
  saved_tio = tio;
  tio.sg_flags &= ~(CBREAK | ECHO | CRMOD | LCASE | TANDEM);
  tio.sg_flags |= (RAW | ANYP);
  if (ioctl(fileno(stdin), TIOCSETP, &tio) < 0)
    perror("ioctl(stdin, TIOCSETP, ...)");
  in_raw_mode = 1;
#endif /* USING_SGTTY */
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@a20 1
#include "randoms.h"
d788 1
a788 1
      if (len <= 0)
d797 1
@

