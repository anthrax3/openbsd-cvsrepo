head	1.24;
access;
symbols
	OPENBSD_6_1:1.23.0.4
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.22.0.6
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.2
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.6.0.12
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.10
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.24
date	2017.05.30.14.15.17;	author markus;	state Exp;
branches;
next	1.23;
commitid	pcw29D46qgooep3E;

1.23
date	2016.10.28.03.33.52;	author djm;	state Exp;
branches;
next	1.22;
commitid	CCBHiYQ0XCyOoezG;

1.22
date	2016.02.12.00.20.30;	author djm;	state Exp;
branches;
next	1.21;
commitid	6yYqZ9LxGumzJ8YH;

1.21
date	2015.07.18.08.02.17;	author djm;	state Exp;
branches;
next	1.20;
commitid	oriNQCDrHD1n1CcN;

1.20
date	2015.07.18.08.00.21;	author djm;	state Exp;
branches;
next	1.19;
commitid	06fsDpkpCo3Rm3as;

1.19
date	2015.05.27.05.15.02;	author djm;	state Exp;
branches;
next	1.18;
commitid	iKDvpxkUazPxRaDa;

1.18
date	2015.04.24.01.36.01;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	LHkUmZjv49ojnnuH;

1.17
date	2015.02.03.08.07.20;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	krFUVDyjU26MeuCn;

1.16
date	2015.02.02.22.48.53;	author djm;	state Exp;
branches;
next	1.15;
commitid	hYzkR5orccs0VEGD;

1.15
date	2015.01.15.09.40.00;	author djm;	state Exp;
branches;
next	1.14;
commitid	akRUKeZEbb3ylbKG;

1.14
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.13;
commitid	1h9UxAQmwdaqUzyX;

1.13
date	2014.05.02.03.27.54;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2014.03.26.04.55.35;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2013.11.13.13.48.20;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2013.11.06.23.05.59;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2013.11.02.20.03.54;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2013.07.12.00.20.00;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.08.21.32.19;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.15.20.32.55;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.24.06.12.53;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.21.06.19.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2010.02.20.20.28.11;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2010.02.08.10.50.20;	author markus;	state Exp;
branches;
next	;


desc
@@


1.24
log
@sshkey_new() might return NULL (pkcs#11 code only); ok djm@@
@
text
@/* $OpenBSD: ssh-pkcs11.c,v 1.23 2016/10/28 03:33:52 djm Exp $ */
/*
 * Copyright (c) 2010 Markus Friedl.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <stdarg.h>
#include <stdio.h>

#include <string.h>
#include <dlfcn.h>

#include <openssl/x509.h>

#define CRYPTOKI_COMPAT
#include "pkcs11.h"

#include "log.h"
#include "misc.h"
#include "sshkey.h"
#include "ssh-pkcs11.h"
#include "xmalloc.h"

struct pkcs11_slotinfo {
	CK_TOKEN_INFO		token;
	CK_SESSION_HANDLE	session;
	int			logged_in;
};

struct pkcs11_provider {
	char			*name;
	void			*handle;
	CK_FUNCTION_LIST	*function_list;
	CK_INFO			info;
	CK_ULONG		nslots;
	CK_SLOT_ID		*slotlist;
	struct pkcs11_slotinfo	*slotinfo;
	int			valid;
	int			refcount;
	TAILQ_ENTRY(pkcs11_provider) next;
};

TAILQ_HEAD(, pkcs11_provider) pkcs11_providers;

struct pkcs11_key {
	struct pkcs11_provider	*provider;
	CK_ULONG		slotidx;
	int			(*orig_finish)(RSA *rsa);
	RSA_METHOD		rsa_method;
	char			*keyid;
	int			keyid_len;
};

int pkcs11_interactive = 0;

int
pkcs11_init(int interactive)
{
	pkcs11_interactive = interactive;
	TAILQ_INIT(&pkcs11_providers);
	return (0);
}

/*
 * finalize a provider shared libarary, it's no longer usable.
 * however, there might still be keys referencing this provider,
 * so the actuall freeing of memory is handled by pkcs11_provider_unref().
 * this is called when a provider gets unregistered.
 */
static void
pkcs11_provider_finalize(struct pkcs11_provider *p)
{
	CK_RV rv;
	CK_ULONG i;

	debug("pkcs11_provider_finalize: %p refcount %d valid %d",
	    p, p->refcount, p->valid);
	if (!p->valid)
		return;
	for (i = 0; i < p->nslots; i++) {
		if (p->slotinfo[i].session &&
		    (rv = p->function_list->C_CloseSession(
		    p->slotinfo[i].session)) != CKR_OK)
			error("C_CloseSession failed: %lu", rv);
	}
	if ((rv = p->function_list->C_Finalize(NULL)) != CKR_OK)
		error("C_Finalize failed: %lu", rv);
	p->valid = 0;
	p->function_list = NULL;
#ifdef HAVE_DLOPEN
	dlclose(p->handle);
#endif
}

/*
 * remove a reference to the provider.
 * called when a key gets destroyed or when the provider is unregistered.
 */
static void
pkcs11_provider_unref(struct pkcs11_provider *p)
{
	debug("pkcs11_provider_unref: %p refcount %d", p, p->refcount);
	if (--p->refcount <= 0) {
		if (p->valid)
			error("pkcs11_provider_unref: %p still valid", p);
		free(p->slotlist);
		free(p->slotinfo);
		free(p);
	}
}

/* unregister all providers, keys might still point to the providers */
void
pkcs11_terminate(void)
{
	struct pkcs11_provider *p;

	while ((p = TAILQ_FIRST(&pkcs11_providers)) != NULL) {
		TAILQ_REMOVE(&pkcs11_providers, p, next);
		pkcs11_provider_finalize(p);
		pkcs11_provider_unref(p);
	}
}

/* lookup provider by name */
static struct pkcs11_provider *
pkcs11_provider_lookup(char *provider_id)
{
	struct pkcs11_provider *p;

	TAILQ_FOREACH(p, &pkcs11_providers, next) {
		debug("check %p %s", p, p->name);
		if (!strcmp(provider_id, p->name))
			return (p);
	}
	return (NULL);
}

/* unregister provider by name */
int
pkcs11_del_provider(char *provider_id)
{
	struct pkcs11_provider *p;

	if ((p = pkcs11_provider_lookup(provider_id)) != NULL) {
		TAILQ_REMOVE(&pkcs11_providers, p, next);
		pkcs11_provider_finalize(p);
		pkcs11_provider_unref(p);
		return (0);
	}
	return (-1);
}

/* openssl callback for freeing an RSA key */
static int
pkcs11_rsa_finish(RSA *rsa)
{
	struct pkcs11_key	*k11;
	int rv = -1;

	if ((k11 = RSA_get_app_data(rsa)) != NULL) {
		if (k11->orig_finish)
			rv = k11->orig_finish(rsa);
		if (k11->provider)
			pkcs11_provider_unref(k11->provider);
		free(k11->keyid);
		free(k11);
	}
	return (rv);
}

/* find a single 'obj' for given attributes */
static int
pkcs11_find(struct pkcs11_provider *p, CK_ULONG slotidx, CK_ATTRIBUTE *attr,
    CK_ULONG nattr, CK_OBJECT_HANDLE *obj)
{
	CK_FUNCTION_LIST	*f;
	CK_SESSION_HANDLE	session;
	CK_ULONG		nfound = 0;
	CK_RV			rv;
	int			ret = -1;

	f = p->function_list;
	session = p->slotinfo[slotidx].session;
	if ((rv = f->C_FindObjectsInit(session, attr, nattr)) != CKR_OK) {
		error("C_FindObjectsInit failed (nattr %lu): %lu", nattr, rv);
		return (-1);
	}
	if ((rv = f->C_FindObjects(session, obj, 1, &nfound)) != CKR_OK ||
	    nfound != 1) {
		debug("C_FindObjects failed (nfound %lu nattr %lu): %lu",
		    nfound, nattr, rv);
	} else
		ret = 0;
	if ((rv = f->C_FindObjectsFinal(session)) != CKR_OK)
		error("C_FindObjectsFinal failed: %lu", rv);
	return (ret);
}

/* openssl callback doing the actual signing operation */
static int
pkcs11_rsa_private_encrypt(int flen, const u_char *from, u_char *to, RSA *rsa,
    int padding)
{
	struct pkcs11_key	*k11;
	struct pkcs11_slotinfo	*si;
	CK_FUNCTION_LIST	*f;
	CK_OBJECT_HANDLE	obj;
	CK_ULONG		tlen = 0;
	CK_RV			rv;
	CK_OBJECT_CLASS		private_key_class = CKO_PRIVATE_KEY;
	CK_BBOOL		true_val = CK_TRUE;
	CK_MECHANISM		mech = {
		CKM_RSA_PKCS, NULL_PTR, 0
	};
	CK_ATTRIBUTE		key_filter[] = {
		{CKA_CLASS, &private_key_class, sizeof(private_key_class) },
		{CKA_ID, NULL, 0},
		{CKA_SIGN, &true_val, sizeof(true_val) }
	};
	char			*pin = NULL, prompt[1024];
	int			rval = -1;

	if ((k11 = RSA_get_app_data(rsa)) == NULL) {
		error("RSA_get_app_data failed for rsa %p", rsa);
		return (-1);
	}
	if (!k11->provider || !k11->provider->valid) {
		error("no pkcs11 (valid) provider for rsa %p", rsa);
		return (-1);
	}
	f = k11->provider->function_list;
	si = &k11->provider->slotinfo[k11->slotidx];
	if ((si->token.flags & CKF_LOGIN_REQUIRED) && !si->logged_in) {
		if (!pkcs11_interactive) {
			error("need pin entry%s", (si->token.flags &
			    CKF_PROTECTED_AUTHENTICATION_PATH) ?
			    " on reader keypad" : "");
			return (-1);
		}
		if (si->token.flags & CKF_PROTECTED_AUTHENTICATION_PATH)
			verbose("Deferring PIN entry to reader keypad.");
		else {
			snprintf(prompt, sizeof(prompt),
			    "Enter PIN for '%s': ", si->token.label);
			pin = read_passphrase(prompt, RP_ALLOW_EOF);
			if (pin == NULL)
				return (-1);	/* bail out */
		}
		rv = f->C_Login(si->session, CKU_USER, (u_char *)pin,
		    (pin != NULL) ? strlen(pin) : 0);
		if (pin != NULL) {
			explicit_bzero(pin, strlen(pin));
			free(pin);
		}
		if (rv != CKR_OK && rv != CKR_USER_ALREADY_LOGGED_IN) {
			error("C_Login failed: %lu", rv);
			return (-1);
		}
		si->logged_in = 1;
	}
	key_filter[1].pValue = k11->keyid;
	key_filter[1].ulValueLen = k11->keyid_len;
	/* try to find object w/CKA_SIGN first, retry w/o */
	if (pkcs11_find(k11->provider, k11->slotidx, key_filter, 3, &obj) < 0 &&
	    pkcs11_find(k11->provider, k11->slotidx, key_filter, 2, &obj) < 0) {
		error("cannot find private key");
	} else if ((rv = f->C_SignInit(si->session, &mech, obj)) != CKR_OK) {
		error("C_SignInit failed: %lu", rv);
	} else {
		/* XXX handle CKR_BUFFER_TOO_SMALL */
		tlen = RSA_size(rsa);
		rv = f->C_Sign(si->session, (CK_BYTE *)from, flen, to, &tlen);
		if (rv == CKR_OK) 
			rval = tlen;
		else 
			error("C_Sign failed: %lu", rv);
	}
	return (rval);
}

static int
pkcs11_rsa_private_decrypt(int flen, const u_char *from, u_char *to, RSA *rsa,
    int padding)
{
	return (-1);
}

/* redirect private key operations for rsa key to pkcs11 token */
static int
pkcs11_rsa_wrap(struct pkcs11_provider *provider, CK_ULONG slotidx,
    CK_ATTRIBUTE *keyid_attrib, RSA *rsa)
{
	struct pkcs11_key	*k11;
	const RSA_METHOD	*def = RSA_get_default_method();

	k11 = xcalloc(1, sizeof(*k11));
	k11->provider = provider;
	provider->refcount++;	/* provider referenced by RSA key */
	k11->slotidx = slotidx;
	/* identify key object on smartcard */
	k11->keyid_len = keyid_attrib->ulValueLen;
	if (k11->keyid_len > 0) {
		k11->keyid = xmalloc(k11->keyid_len);
		memcpy(k11->keyid, keyid_attrib->pValue, k11->keyid_len);
	}
	k11->orig_finish = def->finish;
	memcpy(&k11->rsa_method, def, sizeof(k11->rsa_method));
	k11->rsa_method.name = "pkcs11";
	k11->rsa_method.rsa_priv_enc = pkcs11_rsa_private_encrypt;
	k11->rsa_method.rsa_priv_dec = pkcs11_rsa_private_decrypt;
	k11->rsa_method.finish = pkcs11_rsa_finish;
	RSA_set_method(rsa, &k11->rsa_method);
	RSA_set_app_data(rsa, k11);
	return (0);
}

/* remove trailing spaces */
static void
rmspace(u_char *buf, size_t len)
{
	size_t i;

	if (!len)
		return;
	for (i = len - 1;  i > 0; i--)
		if (i == len - 1 || buf[i] == ' ')
			buf[i] = '\0';
		else
			break;
}

/*
 * open a pkcs11 session and login if required.
 * if pin == NULL we delay login until key use
 */
static int
pkcs11_open_session(struct pkcs11_provider *p, CK_ULONG slotidx, char *pin)
{
	CK_RV			rv;
	CK_FUNCTION_LIST	*f;
	CK_SESSION_HANDLE	session;
	int			login_required;

	f = p->function_list;
	login_required = p->slotinfo[slotidx].token.flags & CKF_LOGIN_REQUIRED;
	if (pin && login_required && !strlen(pin)) {
		error("pin required");
		return (-1);
	}
	if ((rv = f->C_OpenSession(p->slotlist[slotidx], CKF_RW_SESSION|
	    CKF_SERIAL_SESSION, NULL, NULL, &session))
	    != CKR_OK) {
		error("C_OpenSession failed: %lu", rv);
		return (-1);
	}
	if (login_required && pin) {
		rv = f->C_Login(session, CKU_USER,
		    (u_char *)pin, strlen(pin));
		if (rv != CKR_OK && rv != CKR_USER_ALREADY_LOGGED_IN) {
			error("C_Login failed: %lu", rv);
			if ((rv = f->C_CloseSession(session)) != CKR_OK)
				error("C_CloseSession failed: %lu", rv);
			return (-1);
		}
		p->slotinfo[slotidx].logged_in = 1;
	}
	p->slotinfo[slotidx].session = session;
	return (0);
}

/*
 * lookup public keys for token in slot identified by slotidx,
 * add 'wrapped' public keys to the 'keysp' array and increment nkeys.
 * keysp points to an (possibly empty) array with *nkeys keys.
 */
static int pkcs11_fetch_keys_filter(struct pkcs11_provider *, CK_ULONG,
    CK_ATTRIBUTE [], CK_ATTRIBUTE [3], struct sshkey ***, int *)
	__attribute__((__bounded__(__minbytes__,4, 3 * sizeof(CK_ATTRIBUTE))));

static int
pkcs11_fetch_keys(struct pkcs11_provider *p, CK_ULONG slotidx,
    struct sshkey ***keysp, int *nkeys)
{
	CK_OBJECT_CLASS		pubkey_class = CKO_PUBLIC_KEY;
	CK_OBJECT_CLASS		cert_class = CKO_CERTIFICATE;
	CK_ATTRIBUTE		pubkey_filter[] = {
		{ CKA_CLASS, &pubkey_class, sizeof(pubkey_class) }
	};
	CK_ATTRIBUTE		cert_filter[] = {
		{ CKA_CLASS, &cert_class, sizeof(cert_class) }
	};
	CK_ATTRIBUTE		pubkey_attribs[] = {
		{ CKA_ID, NULL, 0 },
		{ CKA_MODULUS, NULL, 0 },
		{ CKA_PUBLIC_EXPONENT, NULL, 0 }
	};
	CK_ATTRIBUTE		cert_attribs[] = {
		{ CKA_ID, NULL, 0 },
		{ CKA_SUBJECT, NULL, 0 },
		{ CKA_VALUE, NULL, 0 }
	};

	if (pkcs11_fetch_keys_filter(p, slotidx, pubkey_filter, pubkey_attribs,
	    keysp, nkeys) < 0 ||
	    pkcs11_fetch_keys_filter(p, slotidx, cert_filter, cert_attribs,
	    keysp, nkeys) < 0)
		return (-1);
	return (0);
}

static int
pkcs11_key_included(struct sshkey ***keysp, int *nkeys, struct sshkey *key)
{
	int i;

	for (i = 0; i < *nkeys; i++)
		if (sshkey_equal(key, (*keysp)[i]))
			return (1);
	return (0);
}

static int
pkcs11_fetch_keys_filter(struct pkcs11_provider *p, CK_ULONG slotidx,
    CK_ATTRIBUTE filter[], CK_ATTRIBUTE attribs[3],
    struct sshkey ***keysp, int *nkeys)
{
	struct sshkey		*key;
	RSA			*rsa;
	X509 			*x509;
	EVP_PKEY		*evp;
	int			i;
	const u_char		*cp;
	CK_RV			rv;
	CK_OBJECT_HANDLE	obj;
	CK_ULONG		nfound;
	CK_SESSION_HANDLE	session;
	CK_FUNCTION_LIST	*f;

	f = p->function_list;
	session = p->slotinfo[slotidx].session;
	/* setup a filter the looks for public keys */
	if ((rv = f->C_FindObjectsInit(session, filter, 1)) != CKR_OK) {
		error("C_FindObjectsInit failed: %lu", rv);
		return (-1);
	}
	while (1) {
		/* XXX 3 attributes in attribs[] */
		for (i = 0; i < 3; i++) {
			attribs[i].pValue = NULL;
			attribs[i].ulValueLen = 0;
		}
		if ((rv = f->C_FindObjects(session, &obj, 1, &nfound)) != CKR_OK
		    || nfound == 0)
			break;
		/* found a key, so figure out size of the attributes */
		if ((rv = f->C_GetAttributeValue(session, obj, attribs, 3))
		    != CKR_OK) {
			error("C_GetAttributeValue failed: %lu", rv);
			continue;
		}
		/*
		 * Allow CKA_ID (always first attribute) to be empty, but
		 * ensure that none of the others are zero length.
		 * XXX assumes CKA_ID is always first.
		 */
		if (attribs[1].ulValueLen == 0 ||
		    attribs[2].ulValueLen == 0) {
			continue;
		}
		/* allocate buffers for attributes */
		for (i = 0; i < 3; i++) {
			if (attribs[i].ulValueLen > 0) {
				attribs[i].pValue = xmalloc(
				    attribs[i].ulValueLen);
			}
		}

		/*
		 * retrieve ID, modulus and public exponent of RSA key,
		 * or ID, subject and value for certificates.
		 */
		rsa = NULL;
		if ((rv = f->C_GetAttributeValue(session, obj, attribs, 3))
		    != CKR_OK) {
			error("C_GetAttributeValue failed: %lu", rv);
		} else if (attribs[1].type == CKA_MODULUS ) {
			if ((rsa = RSA_new()) == NULL) {
				error("RSA_new failed");
			} else {
				rsa->n = BN_bin2bn(attribs[1].pValue,
				    attribs[1].ulValueLen, NULL);
				rsa->e = BN_bin2bn(attribs[2].pValue,
				    attribs[2].ulValueLen, NULL);
			}
		} else {
			cp = attribs[2].pValue;
			if ((x509 = X509_new()) == NULL) {
				error("X509_new failed");
			} else if (d2i_X509(&x509, &cp, attribs[2].ulValueLen)
			    == NULL) {
				error("d2i_X509 failed");
			} else if ((evp = X509_get_pubkey(x509)) == NULL ||
			    evp->type != EVP_PKEY_RSA ||
			    evp->pkey.rsa == NULL) {
				debug("X509_get_pubkey failed or no rsa");
			} else if ((rsa = RSAPublicKey_dup(evp->pkey.rsa))
			    == NULL) {
				error("RSAPublicKey_dup");
			}
			if (x509)
				X509_free(x509);
		}
		if (rsa && rsa->n && rsa->e &&
		    pkcs11_rsa_wrap(p, slotidx, &attribs[0], rsa) == 0) {
			if ((key = sshkey_new(KEY_UNSPEC)) == NULL)
				fatal("sshkey_new failed");
			key->rsa = rsa;
			key->type = KEY_RSA;
			key->flags |= SSHKEY_FLAG_EXT;
			if (pkcs11_key_included(keysp, nkeys, key)) {
				sshkey_free(key);
			} else {
				/* expand key array and add key */
				*keysp = xreallocarray(*keysp, *nkeys + 1,
				    sizeof(struct sshkey *));
				(*keysp)[*nkeys] = key;
				*nkeys = *nkeys + 1;
				debug("have %d keys", *nkeys);
			}
		} else if (rsa) {
			RSA_free(rsa);
		}
		for (i = 0; i < 3; i++)
			free(attribs[i].pValue);
	}
	if ((rv = f->C_FindObjectsFinal(session)) != CKR_OK)
		error("C_FindObjectsFinal failed: %lu", rv);
	return (0);
}

#ifdef HAVE_DLOPEN
/* register a new provider, fails if provider already exists */
int
pkcs11_add_provider(char *provider_id, char *pin, struct sshkey ***keyp)
{
	int nkeys, need_finalize = 0;
	struct pkcs11_provider *p = NULL;
	void *handle = NULL;
	CK_RV (*getfunctionlist)(CK_FUNCTION_LIST **);
	CK_RV rv;
	CK_FUNCTION_LIST *f = NULL;
	CK_TOKEN_INFO *token;
	CK_ULONG i;

	*keyp = NULL;
	if (pkcs11_provider_lookup(provider_id) != NULL) {
		debug("%s: provider already registered: %s",
		    __func__, provider_id);
		goto fail;
	}
	/* open shared pkcs11-libarary */
	if ((handle = dlopen(provider_id, RTLD_NOW)) == NULL) {
		error("dlopen %s failed: %s", provider_id, dlerror());
		goto fail;
	}
	if ((getfunctionlist = dlsym(handle, "C_GetFunctionList")) == NULL) {
		error("dlsym(C_GetFunctionList) failed: %s", dlerror());
		goto fail;
	}
	p = xcalloc(1, sizeof(*p));
	p->name = xstrdup(provider_id);
	p->handle = handle;
	/* setup the pkcs11 callbacks */
	if ((rv = (*getfunctionlist)(&f)) != CKR_OK) {
		error("C_GetFunctionList for provider %s failed: %lu",
		    provider_id, rv);
		goto fail;
	}
	p->function_list = f;
	if ((rv = f->C_Initialize(NULL)) != CKR_OK) {
		error("C_Initialize for provider %s failed: %lu",
		    provider_id, rv);
		goto fail;
	}
	need_finalize = 1;
	if ((rv = f->C_GetInfo(&p->info)) != CKR_OK) {
		error("C_GetInfo for provider %s failed: %lu",
		    provider_id, rv);
		goto fail;
	}
	rmspace(p->info.manufacturerID, sizeof(p->info.manufacturerID));
	rmspace(p->info.libraryDescription, sizeof(p->info.libraryDescription));
	debug("provider %s: manufacturerID <%s> cryptokiVersion %d.%d"
	    " libraryDescription <%s> libraryVersion %d.%d",
	    provider_id,
	    p->info.manufacturerID,
	    p->info.cryptokiVersion.major,
	    p->info.cryptokiVersion.minor,
	    p->info.libraryDescription,
	    p->info.libraryVersion.major,
	    p->info.libraryVersion.minor);
	if ((rv = f->C_GetSlotList(CK_TRUE, NULL, &p->nslots)) != CKR_OK) {
		error("C_GetSlotList failed: %lu", rv);
		goto fail;
	}
	if (p->nslots == 0) {
		debug("%s: provider %s returned no slots", __func__,
		    provider_id);
		goto fail;
	}
	p->slotlist = xcalloc(p->nslots, sizeof(CK_SLOT_ID));
	if ((rv = f->C_GetSlotList(CK_TRUE, p->slotlist, &p->nslots))
	    != CKR_OK) {
		error("C_GetSlotList for provider %s failed: %lu",
		    provider_id, rv);
		goto fail;
	}
	p->slotinfo = xcalloc(p->nslots, sizeof(struct pkcs11_slotinfo));
	p->valid = 1;
	nkeys = 0;
	for (i = 0; i < p->nslots; i++) {
		token = &p->slotinfo[i].token;
		if ((rv = f->C_GetTokenInfo(p->slotlist[i], token))
		    != CKR_OK) {
			error("C_GetTokenInfo for provider %s slot %lu "
			    "failed: %lu", provider_id, (unsigned long)i, rv);
			continue;
		}
		if ((token->flags & CKF_TOKEN_INITIALIZED) == 0) {
			debug2("%s: ignoring uninitialised token in "
			    "provider %s slot %lu", __func__,
			    provider_id, (unsigned long)i);
			continue;
		}
		rmspace(token->label, sizeof(token->label));
		rmspace(token->manufacturerID, sizeof(token->manufacturerID));
		rmspace(token->model, sizeof(token->model));
		rmspace(token->serialNumber, sizeof(token->serialNumber));
		debug("provider %s slot %lu: label <%s> manufacturerID <%s> "
		    "model <%s> serial <%s> flags 0x%lx",
		    provider_id, (unsigned long)i,
		    token->label, token->manufacturerID, token->model,
		    token->serialNumber, token->flags);
		/* open session, login with pin and retrieve public keys */
		if (pkcs11_open_session(p, i, pin) == 0)
			pkcs11_fetch_keys(p, i, keyp, &nkeys);
	}
	if (nkeys > 0) {
		TAILQ_INSERT_TAIL(&pkcs11_providers, p, next);
		p->refcount++;	/* add to provider list */
		return (nkeys);
	}
	debug("%s: provider %s returned no keys", __func__, provider_id);
	/* don't add the provider, since it does not have any keys */
fail:
	if (need_finalize && (rv = f->C_Finalize(NULL)) != CKR_OK)
		error("C_Finalize for provider %s failed: %lu",
		    provider_id, rv);
	if (p) {
		free(p->slotlist);
		free(p->slotinfo);
		free(p);
	}
	if (handle)
		dlclose(handle);
	return (-1);
}
#else
int
pkcs11_add_provider(char *provider_id, char *pin, struct sshkey ***keyp)
{
	error("dlopen() not supported");
	return (-1);
}
#endif
@


1.23
log
@Improve pkcs11_add_provider() logging: demote some excessively
verbose error()s to debug()s, include PKCS#11 provider name and slot
in log messages where possible.
bz#2610, based on patch from Jakub Jelen
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.22 2016/02/12 00:20:30 djm Exp $ */
d529 2
a530 1
			key = sshkey_new(KEY_UNSPEC);
@


1.22
log
@avoid fatal() for PKCS11 tokens that present empty key IDs
bz#1773, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.21 2015/07/18 08:02:17 djm Exp $ */
d570 2
a571 1
		error("provider already registered: %s", provider_id);
d588 2
a589 1
		error("C_GetFunctionList failed: %lu", rv);
d594 2
a595 1
		error("C_Initialize failed: %lu", rv);
d600 2
a601 1
		error("C_GetInfo failed: %lu", rv);
d606 1
a606 1
	debug("manufacturerID <%s> cryptokiVersion %d.%d"
d608 1
d620 2
a621 1
		error("no slots");
d627 2
a628 1
		error("C_GetSlotList failed: %lu", rv);
d638 2
a639 1
			error("C_GetTokenInfo failed: %lu", rv);
d643 3
a645 2
			debug2("%s: ignoring uninitialised token in slot %lu",
			    __func__, (unsigned long)i);
d652 3
a654 2
		debug("label <%s> manufacturerID <%s> model <%s> serial <%s>"
		    " flags 0x%lx",
d666 1
a666 1
	error("no keys");
d670 2
a671 1
		error("C_Finalize failed: %lu", rv);
@


1.21
log
@don't ignore PKCS#11 hosted keys that return empty CKA_ID;
patch by Jakub Jelen via bz#2429; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.20 2015/07/18 08:00:21 djm Exp $ */
d316 4
a319 2
	k11->keyid = xmalloc(k11->keyid_len);
	memcpy(k11->keyid, keyid_attrib->pValue, k11->keyid_len);
@


1.20
log
@skip uninitialised PKCS#11 slots; patch from Jakub Jelen in bz#2427
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.19 2015/05/27 05:15:02 djm Exp $ */
d473 6
a478 3
		/* check that none of the attributes are zero length */
		if (attribs[0].ulValueLen == 0 ||
		    attribs[1].ulValueLen == 0 ||
d483 7
a489 2
		for (i = 0; i < 3; i++)
			attribs[i].pValue = xmalloc(attribs[i].ulValueLen);
@


1.19
log
@support PKCS#11 devices with external PIN entry devices
bz#2240, based on patch from Dirk-Willem van Gulik;
feedback and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.18 2015/04/24 01:36:01 deraadt Exp $ */
d622 5
@


1.18
log
@rename xrealloc() to xreallocarray() since it follows that form.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.17 2015/02/03 08:07:20 deraadt Exp $ */
d234 1
a234 1
	char			*pin, prompt[1024];
d249 3
a251 1
			error("need pin");
d254 15
a268 7
		snprintf(prompt, sizeof(prompt), "Enter PIN for '%s': ",
		    si->token.label);
		pin = read_passphrase(prompt, RP_ALLOW_EOF);
		if (pin == NULL)
			return (-1);	/* bail out */
		rv = f->C_Login(si->session, CKU_USER,
		    (u_char *)pin, strlen(pin));
a269 1
			free(pin);
a272 1
		free(pin);
@


1.17
log
@missing ;
djm and mlarkin really having great interactions recently
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.16 2015/02/02 22:48:53 djm Exp $ */
d519 1
a519 1
				*keysp = xrealloc(*keysp, *nkeys + 1,
@


1.16
log
@handle PKCS#11 C_Login returning CKR_USER_ALREADY_LOGGED_IN;
based on patch from Yuri Samoilenko; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.15 2015/01/15 09:40:00 djm Exp $ */
d362 1
a362 1
		    (u_char *)pin, strlen(pin))
@


1.15
log
@sync ssh-keysign, ssh-keygen and some dependencies to the new
buffer/key API; mostly mechanical, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.14 2014/06/24 01:13:21 djm Exp $ */
d257 3
a259 2
		if ((rv = f->C_Login(si->session, CKU_USER,
		    (u_char *)pin, strlen(pin))) != CKR_OK) {
d361 3
a363 2
		if ((rv = f->C_Login(session, CKU_USER,
		    (u_char *)pin, strlen(pin))) != CKR_OK) {
@


1.14
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.13 2014/05/02 03:27:54 djm Exp $ */
d33 1
a33 1
#include "key.h"
d379 1
a379 1
    CK_ATTRIBUTE [], CK_ATTRIBUTE [3], Key ***, int *)
d384 1
a384 1
    Key ***keysp, int *nkeys)
d414 1
a414 1
pkcs11_key_included(Key ***keysp, int *nkeys, Key *key)
d419 1
a419 1
		if (key_equal(key, (*keysp)[i]))
d427 1
a427 1
    Key ***keysp, int *nkeys)
d429 1
a429 1
	Key			*key;
d509 1
a509 1
			key = key_new(KEY_UNSPEC);
d514 1
a514 1
				key_free(key);
d518 1
a518 1
				    sizeof(Key *));
d537 1
a537 1
pkcs11_add_provider(char *provider_id, char *pin, Key ***keyp)
d647 1
a647 1
pkcs11_add_provider(char *provider_id, char *pin, Key ***keyp)
@


1.13
log
@revert __bounded change; it causes way more problems for portable than
it solves; pointed out by dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.11 2013/11/13 13:48:20 markus Exp $ */
d512 1
a512 1
			key->flags |= KEY_FLAG_EXT;
@


1.12
log
@use __bounded(...) attribute recently added to sys/cdefs.h instead of
longform __attribute__(__bounded(...));

for brevity and a warning free compilation with llvm/clan
@
text
@d380 1
a380 1
	__bounded((__minbytes__,4, 3 * sizeof(CK_ATTRIBUTE)));
@


1.11
log
@add missing braces found by pedro
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.10 2013/11/06 23:05:59 djm Exp $ */
d380 1
a380 1
	__attribute__((__bounded__(__minbytes__,4, 3 * sizeof(CK_ATTRIBUTE))));
@


1.10
log
@from portable: s/true/true_val/ to avoid name collisions on dump platforms
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.9 2013/11/02 20:03:54 markus Exp $ */
d419 1
a419 1
		if (key_equal(key, *keysp[i]))
@


1.9
log
@support pkcs#11 tokes that only provide x509 zerts instead of raw pubkeys;
fixes bz#1908; based on patch from Laurent Barbe; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.8 2013/07/12 00:20:00 djm Exp $ */
d225 1
a225 1
	CK_BBOOL		true = CK_TRUE;
d232 1
a232 1
		{CKA_SIGN, &true, sizeof(true) }
@


1.8
log
@fix pointer-signedness warnings from clang/llvm-3.3; "seems nice" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.7 2013/05/17 00:13:14 djm Exp $ */
d26 2
d378 35
d414 14
a427 2
pkcs11_fetch_keys(struct pkcs11_provider *p, CK_ULONG slotidx, Key ***keysp,
    int *nkeys)
d431 2
d434 1
a439 9
	CK_OBJECT_CLASS		pubkey_class = CKO_PUBLIC_KEY;
	CK_ATTRIBUTE		pubkey_filter[] = {
		{ CKA_CLASS, &pubkey_class, sizeof(pubkey_class) }
	};
	CK_ATTRIBUTE		attribs[] = {
		{ CKA_ID, NULL, 0 },
		{ CKA_MODULUS, NULL, 0 },
		{ CKA_PUBLIC_EXPONENT, NULL, 0 }
	};
d444 1
a444 1
	if ((rv = f->C_FindObjectsInit(session, pubkey_filter, 1)) != CKR_OK) {
d472 5
a476 1
		/* retrieve ID, modulus and public exponent of RSA key */
d480 9
a488 2
		} else if ((rsa = RSA_new()) == NULL) {
			error("RSA_new failed");
d490 26
a515 10
			rsa->n = BN_bin2bn(attribs[1].pValue,
			    attribs[1].ulValueLen, NULL);
			rsa->e = BN_bin2bn(attribs[2].pValue,
			    attribs[2].ulValueLen, NULL);
			if (rsa->n && rsa->e &&
			    pkcs11_rsa_wrap(p, slotidx, &attribs[0], rsa) == 0) {
				key = key_new(KEY_UNSPEC);
				key->rsa = rsa;
				key->type = KEY_RSA;
				key->flags |= KEY_FLAG_EXT;
a521 2
			} else {
				RSA_free(rsa);
d523 2
@


1.7
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.6 2010/06/08 21:32:19 markus Exp $ */
d255 2
a256 2
		if ((rv = f->C_Login(si->session, CKU_USER, pin, strlen(pin)))
		    != CKR_OK) {
d320 1
a320 1
rmspace(char *buf, size_t len)
d358 2
a359 2
		if ((rv = f->C_Login(session, CKU_USER, pin, strlen(pin)))
		    != CKR_OK) {
@


1.6
log
@check length of value returned  C_GetAttributValue for != 0
from mdrtbugzilla@@codefive.co.uk; bugzilla #1773; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.5 2010/04/15 20:32:55 markus Exp $ */
d117 3
a119 3
		xfree(p->slotlist);
		xfree(p->slotinfo);
		xfree(p);
d177 2
a178 3
		if (k11->keyid)
			xfree(k11->keyid);
		xfree(k11);
d257 1
a257 1
			xfree(pin);
d261 1
a261 1
		xfree(pin);
d457 1
a457 1
			xfree(attribs[i].pValue);
d567 3
a569 5
		if (p->slotlist)
			xfree(p->slotlist);
		if (p->slotinfo)
			xfree(p->slotinfo);
		xfree(p);
@


1.5
log
@retry lookup for private key if there's no matching key with CKA_SIGN
attribute enabled; this fixes fixes MuscleCard support (bugzilla #1736)
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-pkcs11.c,v 1.4 2010/02/24 06:12:53 djm Exp $ */
d421 7
a427 1
		/* allocate buffers for attributes, XXX check ulValueLen? */
@


1.4
log
@Add $OpenBSD$ tags in comments, our portable-syncing scripts use these
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d184 28
d221 1
a221 1
	CK_ULONG		tlen = 0, nfound = 0;
d267 4
a270 7
	if ((rv = f->C_FindObjectsInit(si->session, key_filter, 3)) != CKR_OK) {
		error("C_FindObjectsInit failed: %lu", rv);
		return (-1);
	}
	if ((rv = f->C_FindObjects(si->session, &obj, 1, &nfound)) != CKR_OK ||
	    nfound != 1) {
		error("C_FindObjects failed (%lu nfound): %lu", nfound, rv);
a281 2
	if ((rv = f->C_FindObjectsFinal(si->session)) != CKR_OK)
		error("C_FindObjectsFinal failed: %lu", rv);
@


1.3
log
@dlclose() call should also be #ifdef HAVE_DLOPEN
@
text
@d1 1
@


1.2
log
@unbreak build for NOPIC systems; noticed, help and ok deraadt@@
@
text
@d100 1
d102 1
@


1.1
log
@replace our obsolete smartcard code with PKCS#11.
	ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-11/v2-20/pkcs-11v2-20.pdf
ssh(1) and ssh-keygen(1) use dlopen(3) directly to talk to a PKCS#11
provider (shared library) while ssh-agent(1) delegates PKCS#11 to
a forked a ssh-pkcs11-helper process.
PKCS#11 is currently a compile time option.
feedback and ok djm@@; inspired by patches from Alon Bar-Lev
@
text
@d433 1
d546 8
@

